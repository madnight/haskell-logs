00:00:08 <sciolizer_> er, third is encoded as a byte
00:00:15 <|Steve|> pascal strings?
00:00:58 <sciolizer_> yeah
00:01:24 <|Steve|> Those have the rather obvious limitation (unless you go to wide pascal strings, or whatever those are called).
00:01:46 <sciolizer_> If you do a unary encoding of the length up at the front, you don't run into the limitation. :)
00:02:43 <maltem> Now I got "My brain just exploded." :o
00:03:10 <sciolizer_> 'H':'o':'w':' ':'a':'b':'o':'u':'t':' ':'t':'h':'i':'s':'?':[]
00:17:23 <trzkril> @pl \a b -> f a a (g a) b
00:17:23 <lambdabot> ap (join f) g
01:14:16 <kakeman> what is name of -> ?
01:14:33 <kakeman> "arrow" ?
01:17:36 <bd_> function type constructor?
01:22:28 <sciolizer> "implies"?
01:23:45 <Gracenotes> http://www.haskell.org/haskellwiki/Keywords#-.3E  - what bd_ said. I suppose spoken it might be "to"? meh.
01:38:57 <cizra> Hi. My Haskell's gone a bit rusty... if I have a list of strings in ghci, how do I map putStrLn lst?
01:39:26 <mauke> like that
01:39:30 <cizra> Doesn't work.
01:39:33 <mauke> yes, it does
01:39:39 <cizra>     No instance for (Show (IO ()))
01:39:39 <cizra>       arising from a use of `print' at <interactive>:1:0-16
01:39:42 <mauke> see?
01:39:45 <mauke> it worked
01:40:16 <cizra> Well, it didn't output what I wanted it to output, that is, a bunch of lines, a string on each.
01:40:28 <mauke> map putStrLn lst doesn't output anything
01:40:37 <mauke> it gives you a list of IO actions
01:40:37 <sereven> :t sequence_ . map putStrLn
01:40:38 <lambdabot> [String] -> IO ()
01:41:16 <cizra> Hmmm, OK.
01:41:43 <trzkril> :t mapM
01:41:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:41:51 <sereven> :t mapM_ putStrLn
01:41:52 <lambdabot> [String] -> IO ()
01:41:57 <mauke> yeah, what you really want is mapM_
01:42:18 <trzkril> @src mapM_
01:42:18 <lambdabot> mapM_ f as = sequence_ (map f as)
01:42:24 <mauke> or putStr (unlines lst) :-)
01:43:10 <cizra> mapM is cute
01:43:16 <cizra> Thank you very much.
01:43:25 <Alpounet> Guys, I don't get why, in http://www.haskell.org/haskellwiki/Newtype, y3 runs fine and returns 1.
01:43:28 <cizra> I should really use Haskell more for everyday hacks.
01:43:59 <mauke> Alpounet: because that's like case undefined of _ -> 1
01:44:21 <Alpounet> yep, but why ?
01:44:31 <mauke> because newtypes have no runtime representation
01:44:32 <Alpounet> What's the point of putting Foo3 if it can deal without it.
01:44:40 <mauke> what
01:45:09 <Alpounet> what's the point of preceeding _ with the Foo3 value constructor if ghc can deal without it ?
01:45:53 * mauke looks for the Babbage quote
01:46:01 <Alpounet> @quote Babbage
01:46:01 <lambdabot> No quotes match.
01:46:02 <Alpounet> ?
01:46:49 <mauke> "I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."
01:47:05 <mauke> context: http://en.wikipedia.org/wiki/Charles_Babbage#Quotations
01:47:41 <Alpounet> Ok.
01:47:46 <Alpounet> Got your point.
01:48:20 <Alpounet> So actually, any type declared with newtype can be pattern matched against anything that could match what newtype encapsulates
01:48:21 <Alpounet> right ?
01:48:40 <mauke> if I understand you right, no
01:49:15 <Cale> Alpounet: The newtype defines a new data constructor which must be used when pattern matching
01:49:27 <mauke> newtype N = C (); x = C (); case x of () -> ... -- type error
01:49:45 <mmaruseacph2> newtype is only used to provide a new identity to a type without incurring additional compiler overhead
01:49:48 <Alpounet> Cale, yes, already understood it.
01:50:14 <mmaruseacph2> thus, it needs only one constructor with only one field
01:50:34 <mmaruseacph2> and because of that, they can be left unstored in memory
01:50:44 <Alpounet> mauke, okay, there just is a particular behavior wrt 'undefined'
01:50:58 <mmaruseacph2> thus, you don't have a constructor present at runtime
01:51:05 <mauke> Alpounet: not really
01:51:18 <mauke> my example is a type error, so it doesn't depend on the actual values
01:51:38 <mmaruseacph2> so, when you match against a newtype in something like N _ you are in fact matching against the plain _
01:52:00 <Alpounet> mauke, what if we do 'case x of undefined' here ?
01:52:49 <mauke> that will introduce a new variable called 'undefined' and bind it to x
01:52:52 <Alpounet> mmaruseacph2, yeah, okay, whereas with data we are really matching against the whole ADT structure, including the value constructor, etc.
01:52:56 <mauke> like let undefined = x in ...
01:53:47 <Alpounet> mauke, damn, sorry, I wanted to write 'case undefined of C _ -> ...
01:53:49 <Alpounet> '
01:54:25 <mauke> that will run successfully
01:54:46 <Alpounet> and enter the 'C _' case
01:54:47 <mmaruseacph2> Alpounet: case undefined of C _ reduces to case undefined of _
01:54:48 <mauke> because (undefined :: N) and (C undefined :: N) are the same thing at runtime
01:54:48 <Alpounet> ok
01:55:14 <Alpounet> Thanks all, I think I got it !
01:55:21 <Alpounet> cheers :-)
01:55:40 <mauke> basically, because you can add C without overhead, you can also subtract it (by pattern matching) without actually doing anything
02:08:41 <Alpounet> mauke, yeah, that's smart :-)
02:11:51 <Alpounet> @type (>=>)
02:11:52 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
02:12:05 <kakeman> how to get started?
02:12:48 <mauke> with what?
02:13:11 <Alpounet> in Haskell ?
02:13:16 <Alpounet> it depends on your background.
02:13:59 <ehamberg> kakeman: there is a beginner's tutorial at http://learnyouahaskell.com/ which is great. :)
02:14:07 <kakeman> thanks
02:14:15 <Alpounet> @where rwh
02:14:15 <lambdabot> is http://www.realworldhaskell.org/blog/
02:14:56 <kakeman> atm. haskell is very cryptic for me
02:15:12 <mauke> what languages do you know?
02:15:32 <kakeman> c++
02:16:03 <mmaruseacph2> there's Haskell for C Programmers
02:16:16 <mmaruseacph2> http://www.haskell.org/~pairwise/intro/intro.html
02:17:00 <mmaruseacph2> @type tails
02:17:01 <lambdabot> forall a. [a] -> [[a]]
02:52:29 <Cale> kakeman: Another tutorial which a lot of people recommend is "Learn You A Haskell"
02:52:33 <Cale> @where lyah
02:52:33 <lambdabot> www.learnyouahaskell.com
02:53:04 <Cale> Er, oops, missed that it was mentioned :)
03:00:58 <kakeman> so it's good
03:01:37 <poe> also http://en.wikibooks.org/wiki/Haskell
03:09:11 <psykotic> funkyzeit
03:39:26 <Phyx-> test
03:40:22 <pardus> Phyx-, the test successfully failed
03:40:28 <Phyx-> aww
03:44:10 * Phyx- feels like coding a small project, but all he has is big projects 
03:44:27 <kakeman> i lake this tutorial
03:44:32 <kakeman> :P
03:44:34 <kakeman> like
03:45:14 <kakeman> it has pictures on it
03:47:03 <ehamberg> it's fun to read :)
03:54:30 <anincog> There's something about the type system I haven't understood. It's best explained by an example: Say I wanted to create a type called Prime. A Prime p would consist of an Integer p, but I would like to arrange things so that the type constructor checks wether the integer p is actually a prime before creating the Prime p object. Is this possible? If not, what is the "proper" way to do such checks?
03:54:57 <anincog> (the prime stuff is just an example illustrating a more general question)
03:55:15 <mauke> it's not possible
03:55:49 <mauke> you'd have to write a "smart constructor", i.e. a normal function that checks for primes and maybe returns a Prime
03:55:55 <Phyx-> well, you could use the "smart constructor" approach though, via a helper function
03:56:16 <mauke> on the other hand, you could use a different encoding
03:56:21 <anincog> and use Maybe? I was pondering about that, but it felt so wrong
03:56:31 <mauke> Prime 6 would be the sixst prime
03:56:46 <anincog> hmm, not a bad idea
03:56:55 <psykotic> and you can enforce it externally by information hiding via the module system
03:57:06 <anincog> I gotta think about wether that approach works for my more general cases
03:57:42 <anincog> psykotic: Like hiding the type constructor and only supplying a function returning a Maybe Prime?
03:58:05 <Cale> The other answer is that it's maybe possible if you turn on enough extensions and apply a few olegs of type system hackery to encode what it means for a number to be prime at the type level...
03:58:25 <mauke> possibly related http://okmij.org/ftp/Haskell/types.html#branding
03:58:48 <Alpounet> is there a more handy way to write at the end of a file than doing hSeek myfilehandle SeekFromEnd 0 ; hPutStr myfilehandle "foo" ?
03:59:15 <mauke> yeah, open the file in append mode
03:59:22 <nvoorhies> outside of opening in append mode?
03:59:28 <Twey> Alpounet: appendFile "file" "string"
03:59:38 <mauke> the seek + write method isn't reliable if there are multiple writers
03:59:54 <Alpounet> forgot to mention the file is already opened with other operations already done on it, but not at the end of it.
04:01:17 <anincog> thanks for the help, guys!
04:02:18 <psykotic> anincog: what would be the alternative to something Maybe-like? haskell isn't dependently typed. it's conceivable you could encode proofs of primality in the type system with GADTs but let's not go there :)
04:02:18 <psykotic> cale: yeah, and it would be about as useful as all the other oleg encodings.
04:02:18 <psykotic> :)
04:02:18 <psykotic> of course, oleg would have done it in haskell 98!
04:02:22 <psykotic> mauke: if you have multiple writers with a file, you have a problem.
04:02:24 <psykotic> it's not limited to appending
04:02:37 <mauke> if they all append, they won't overwrite each other
04:02:55 <|Steve|> hPutStrAtEnd h s = do p <- hGetPosn h; hSeek h SeekFromEnd 0; hPutStr s; hSetPosn p
04:03:00 <psykotic> in that case you need multiple handles to the same file
04:03:04 <psykotic> i.e. something like dup()
04:03:14 <mauke> I'm assuming multiple processes here
04:03:25 <psykotic> that's even worse
04:03:34 <mauke> no
04:03:54 <psykotic> try looking up atomic guarantees of write()
04:03:54 <Jafet> You can encode proofs in haskell?!
04:04:05 <Jafet> How complex?
04:04:41 <psykotic> jafet: even simply typed lambda calculus corresponds via curry-haskell correspondence to propositional logic. types are propositions, terms are proofs.
04:05:16 <mauke>  If the file was open(2)ed with O_APPEND, the file offset is first set to the end of the file before writing. The adjustment of the file offset and the write operation are performed as an atomic step.
04:05:16 <psykotic> with type classes you can use the type system for prolog-style proof search in that vein
04:05:19 <Cale> Actually, a type-level primality certificate checker would be really amusing.
04:05:22 <Jafet> Oh.
04:05:31 * Jafet read "amazing"
04:05:40 <|Steve|> psykotic: What atomic guarantees?
04:06:26 <psykotic> mauke: does it guarantee that for arbitrarily large writes, etc?
04:06:35 <mauke> very unlikely
04:06:40 <psykotic> then you have to cope with the fact that there's likely user space buffering
04:06:44 <psykotic> which totally defeats what you're talking about
04:06:52 <mauke> how so?
04:07:03 <Jafet> That reminds me, I have a marginally offtopic question. Is either coq or agda "easier" to get into than the other? I want to understand this Curry-Howard stuff
04:07:09 <psykotic> fwrite() does user space buffering to minimize context switches for io
04:07:18 <mauke> well, FILE does
04:07:58 <psykotic> i'm sure haskell's io library does something like that, it might even use the stream io api idirectly
04:08:22 <mauke> so how does that defeat my point?
04:08:33 <psykotic> we're talking about haskell, aren't we?
04:08:35 <|Steve|> write(2) to a file has no atomic guarantees on POSIX.
04:08:57 <mauke> psykotic: maybe
04:09:00 <psykotic> |Steve|: apparently mauke says otherwise. i admit i'm not versed in the legalese details but that was my hunch as well
04:09:23 <|Steve|> (Writing to a pipe or FIFO of at most PIPE_BUF bytes is atomic.
04:09:23 <Saizan> you don't need dependent types to understand curry-howard, however agda feels very similar to haskell, i've never actually learned coq though
04:09:31 <|Steve|> http://www.opengroup.org/onlinepubs/000095399/functions/write.html
04:09:31 <psykotic> because posix is notoriously low on guarantees wrt atomicity of io
04:10:18 <mauke> you still haven't described any problems
04:10:34 <psykotic> mauke: multiple writers, race conditions
04:10:38 <|Steve|> Multiple writers writing to the same file will stomp on each other.
04:10:49 <mauke> |Steve|: not with O_APPEND
04:10:59 <mauke> psykotic: what
04:11:08 <|Steve|> mauke: Uh, that makes no difference.
04:11:13 <mauke> yes, it does
04:11:34 <|Steve|> If I have a file of size 0 open in two processes, both opened at append and they start writing, they'll stomp on each other.
04:11:40 <mauke> no
04:13:44 <babusrini> Avoiding Name conflicts: When you use the record structure, the fields can be used as function name. But when you multiple data types with same field name, then you get conflicts. Renaming to name1, name2 ugly. Is there a way to avoid renaming?
04:14:01 <mauke> babusrini: put them in different modules
04:14:10 <Saizan> babusrini: use different modules
04:14:17 <babusrini> In the same file?
04:14:22 <mauke> impossible
04:15:05 <babusrini> I wanted to see if there is a better solution than putting them in different modules (different files)
04:15:34 <mauke> get a thesaurus :-)
04:36:11 <monadic_kid> Should I use foreign pointers in my bindings for raw level interface?
05:01:36 <fergie> What is the best wah
05:02:04 <fergie> Sorry. What is the best way to uninstall a package that I've installed using cabal?
05:02:15 <Bladspena> can I make a recursive funtion print debug info each recursion? if so, how?
05:02:34 <Twey> Debug.Trace
05:02:56 <ivanm> fergie: manually
05:03:01 <ivanm> s/best/only/
05:03:08 <ivanm> ghc-pkg unregister <foo>
05:03:18 <fergie> just delete the stuff from the .cabal directory?
05:03:26 <ivanm> then in ~/.cabal/, delete the appropriate bits (from lib/ and share/ IIRC)
05:03:39 <ivanm> fergie: yup; make sure you unregister it from ghc-pkg first though
05:03:59 <fergie> thought I might have to do that. Just wasn't sure if there was another way
05:04:06 <fergie> Thanks ivanm
05:04:34 <|Steve|> That's kinda lame that a package management system doesn't include an uninstall.
05:05:13 <ivanm> |Steve|: I'm sure dcoutts will accept patches...
05:06:26 <|Steve|> I wonder if you could combine it with encap.
05:06:36 <fergie> I think managing uninstalls is the hard part of package management
05:06:58 <ivanm> |Steve|: never heard of encap
05:07:23 <|Steve|> The hard part of an uninstall is making sure the dependents are uninstalled as well.
05:07:31 <monadic_kid> so yeah should use foreign pointers in low-level binding interface?
05:08:11 <|Steve|> ivanm: http://www.encap.org/ It's not spectacular, but at least it will do removal for you.
05:20:45 <Alpounet> WriteMode will replace the existing content of the file by the one we are giving him, right ?
05:21:15 <Saizan> yes
05:23:02 <eipi> hello, I'm trying to install trhsx with cabal but it fails during configure saying I do not have haskell-src-exts while I have two versions of that installed. How is that possible?
05:25:35 <Saizan> eipi: how are you configuring?
05:27:50 <eipi> saizan: with runhaskell Setup.hs configure
05:29:01 <dcoutts> eipi: use cabal
05:29:09 <dcoutts> eipi: and/or see the Cabal FAQ
05:29:24 <eipi> actually, I tried that after it failed with cabal
05:29:57 <dcoutts> how does it fail with cabal ?
05:31:09 <eipi> dcoutts: "Failed to load interface for `Prelude'
05:31:31 <dcoutts> mm, that's exciting
05:31:47 <dcoutts> eipi: could you use hpaste or something for the full command and the result
05:32:14 <eipi> hmm, I'll try
05:33:45 <nvoorhies> what's the path of least resistance for getting yourself set up to play with llvm bindings for haskell?
05:34:26 <eipi> dcoutts: to give the hpaste line, am I supposed to just past the link in this channel or there are other means?
05:34:49 <Saizan> paste the link
05:34:57 <eipi> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9541#a9541
05:36:21 <Alpounet> Can anyone give an hint about why I would have a file locked when doing some file IO stuffs ?
05:36:25 <Alpounet> which functions may cause that ?
05:36:40 <mauke> openFile
05:36:41 <mbuta> help; i've deleted C:\Program Files\Haskell but cabal still thinks i already have all the packages and won't reinstall them, how do i fix this?
05:36:49 <dcoutts> eipi: according to hackage the package is deprecated. It also appears to be completely broken.
05:37:07 <dcoutts> eipi: use the hsx package instead
05:37:07 <eipi> dcoutts: yes, indeed
05:37:12 <Alpounet> mauke, but when using writeFile or appendFile, the file is closed right after it's been written
05:37:13 <Alpounet> right ?
05:37:26 <mauke> yes
05:37:28 <eipi> dcoutts: for some reasons, happs seems to depend on it
05:38:37 <Alpounet> mauke, same for readFile, right ?
05:39:00 <mauke> no
05:39:06 <mauke> well, yes, sort of
05:39:08 <Alpounet> does it leave any lock ?
05:39:12 <mauke> but readFile is lazy
05:39:26 <mauke> you'll have to consume the whole string to get it to close the file
05:39:32 <Alpounet> oh okay
05:39:34 <Alpounet> fine thanks !
05:40:06 <dcoutts> eipi: does it? I can't see the dependency
05:40:12 <Alpounet> mystring `seq` <etc...>
05:40:24 <Alpounet> I guess, for example
05:40:25 <HugoDaniel> hi
05:41:31 <dcoutts> eipi: does it need the trhsx program, or the trhsx package? if it's the program then just install hsx
05:41:53 <mbuta> help; i've deleted C:\Program Files\Haskell but cabal still thinks i already have all the packages and won't reinstall them, how do i fix this?
05:41:57 <eipi> dcoutts: it depends on hsp which in turn tries to execute trhsx
05:42:25 <dcoutts> mbuta: unregister the packages in question
05:42:55 <mbuta> how do i uninstall/remove packages with cabal then?
05:43:48 <dcoutts> mbuta: the uninstall feature has not been implemented yet, you can ghc-pkg unregister
05:44:11 <dcoutts> eipi: ok then install hsx
05:44:24 <Berengal> eipi, hsp depends on hsx, which in turn includes a program called trhsx
05:44:29 <mbuta> wait there's actually no way to uninstall something?
05:44:46 <dcoutts> mbuta: sure, delete the files and ghc-pkg unregister the package
05:44:53 <Berengal> hsx is the successor to the trhsx package
05:44:56 <eipi> oh, I see then
05:45:09 <dcoutts> eipi: it's probably just that it's not on your $PATH
05:45:21 <Alpounet> mauke, mystring <- readFile "foo" ; mystring `seq` <some great stuffs>        doesn't seem to force readFile to be executed
05:45:31 <Alpounet> well, there still is a lock.
05:45:41 <eipi> dcoutts: it is that I installed it thinking it was a library and it must have failed when trying to copy the file
05:45:45 <mauke> Alpounet: that only forces the first character
05:45:49 <Berengal> Alpounet, try 'last mystring `seq`stuff'
05:46:00 <Alpounet> ok thanks !
05:46:09 <eipi> dcoutts: I mean the file for the binary...thanks a lot
05:46:17 <dcoutts> Alpounet: seq forces to "weak head normal form" meaning just the first constructor.
05:46:27 <eipi> dcoutts++
05:46:40 <dcoutts> > (3 : undefined) `seq` ()
05:46:41 <lambdabot>   ()
05:46:48 <dcoutts> > (undefined : undefined) `seq` ()
05:46:49 <lambdabot>   ()
05:46:55 <Alpounet> length would do it I guess
05:46:59 <Alpounet> last doesn't seesm to do it :/
05:47:33 <dcoutts> Alpounet: sounds like you want to do a strict read, forcing the length is just a hack
05:47:42 <eipi> dcoutts: by the way, I was trying to do something about the UAC for cabal this wE. But it is unclear to me what should be done
05:47:43 <dcoutts> Alpounet: or consume all the data immediately
05:47:54 <dcoutts> eipi: oh right
05:48:04 <Alpounet> dcoutts, in this particular case, I'd like to do a strict read, yes.
05:48:35 <Alpounet> neither last s nor length s is of help
05:48:53 <Berengal> Try threadDelaying a bit afterwards
05:49:00 <dcoutts> no, it should work
05:49:14 <dcoutts> you're probably not actually forcing anything
05:49:17 <mauke> Berengal: that's just superstition
05:49:23 <Berengal> Or write yourself a strict read...
05:49:42 <Berengal> mauke, we're already far into superstition land
05:49:47 <mauke> no
05:49:52 <dcoutts> no we're not
05:49:59 <dcoutts> there's nothing magic about lazy io
05:50:06 <kakeman> :t (==)
05:50:07 <lambdabot> forall a. (Eq a) => a -> a -> Bool
05:50:07 <Alpounet> actually, I want to read a file, filter the lines depending on some predicate, and replace the initial content with the filter-passing lines
05:50:11 <eipi> dcoutts: I sent a message on the mailing list with a proposed solution (using an external exe called by shellexecute). But if we want the user to be asked only once to promote, we need to run this external process only once per session
05:50:27 <mauke> Alpounet: I'd use two files
05:50:29 <dcoutts> Alpounet: ok, so you're replacing the input file
05:50:41 <Alpounet> and it seems that when doing writeFile, I get an error concerning a file locking
05:50:46 <Alpounet> dcoutts, yeah, the very same file.
05:51:03 <dcoutts> Alpounet: right H98 says you cannot have the same file open for reading and writing at the same time, for your own safety and sanity :-)
05:51:29 <kakeman> :t (++)
05:51:29 <Alpounet> yep
05:51:30 <lambdabot> forall a. [a] -> [a] -> [a]
05:51:42 <Alpounet> that's why I'd like to be sure the readFile has terminated before I write
05:52:03 <kakeman> :t (>>)
05:52:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
05:52:17 <Alpounet> any way to manage that ?
05:52:24 <ray> :t (,,)
05:52:25 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
05:52:55 <dcoutts> @hpaste
05:52:55 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:53:11 <Alpounet> for me ?
05:53:13 <Alpounet> 'k.
05:54:30 <Berengal> slurp h = hIsEOF h >>= \e -> if e then return [] else liftM2 (:) (hGetChar h) (slurp h)
05:54:37 <mauke> ew
05:54:41 <dcoutts> Alpounet: something like: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3784
05:55:05 <dcoutts> Alpounet: withFile is a nice scoped thing, it guarantees that the file is closed by the time it finishes
05:55:24 <dcoutts> Alpounet: but, you need to consume the file content before it's done, or it gets cut off
05:55:32 <mauke> but hGetContents closes the file
05:55:36 <mauke> does withFile deal with that?
05:55:37 <Alpounet> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3785#a3785
05:55:47 <Alpounet> here, when doing writeFile
05:55:55 <dcoutts> mauke: close is idempotent
05:55:59 <mauke> ok
05:56:04 <Alpounet> I get :
05:56:08 <mauke> Alpounet: hello?
05:56:17 <Alpounet> openFile: resource busy (file is locked)
05:56:40 <Alpounet> mauke, yes ?
05:56:53 <mauke> did you see what dcoutts wrote?
05:57:00 <Alpounet> nop
05:57:06 <Alpounet> (yet)
05:57:18 <dcoutts> Alpounet: do you understand the problem now?
05:59:05 <Alpounet> yes
05:59:09 <Alpounet> evaluate will consume the string ?
06:01:21 <dcoutts> Alpounet: no, but it forces to WHNF, and combined with length, that's enough to pull it all into memory, so that it's in memory when the file is closed.
06:03:52 <Alpounet> okay
06:04:01 <dcoutts> Alpounet: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3785#a3787
06:04:13 <Alpounet> and when withFile terminates, we're sure that the file is closed, right ?
06:04:29 <dcoutts> Alpounet: yep
06:04:36 <Alpounet> ok, great ! Thank you guys.
06:06:39 <ksf> arrrgh sdl gives me neither an expose or resize event when the window gets realised.
06:06:42 <dcoutts> Alpounet: I added a withFile variant too, see the paste again
06:06:52 <Alpounet> ok thanks :-)
06:07:19 <ksf> ...which sucks, because the size I requested most likely won't be the one I get.
06:07:44 <ksf> ...and I need to re-initialize the screen on resize, or stuff gets clipped.
06:08:56 <dcoutts> Alpounet: so for future reference, the way to understand readFile is that it opens the file and gives you the beginning of the content, but it doesn't actually read the file until you start asking for the content. It only closes the file when you've pulled all the content (or forgotten about it, when it'll get GC'ed).
06:09:11 <Philonous> Would one rather use phooey or grapefruit as GUI library?
06:09:52 <dcoutts> Alpounet: it's like an iterator to the file, if you're familiar with iterators from other languages.
06:10:05 <Alpounet> yeah, I am. Ok, perfectly understood now, thanks a lot.
06:10:45 <sleepynate> ARRRR! Marry be happy haskell mateys!
06:10:55 <dcoutts> @yarr!
06:10:55 <lambdabot> Prepare to be boarded!
06:11:10 <Philonous> @arr
06:11:10 <lambdabot> Arrr!
06:11:46 <dcoutts> Alpounet: the strict ByteString type also comes with a completely strict readFile action, which is sometimes useful.
06:12:03 <Alpounet> I'll test it too.
06:12:17 <Philonous> readFile breaks with referential transparency, though
06:14:33 * byorgey writes an ARRRow instance for pARRRRallel ARRRRays!  Avast!
06:15:27 <ksf> ...is SDL really the only library that gives me a no-nonsense framebuffer and input events or am I missing something from hackage?
06:15:55 * ksf would like stuff like multiple windows per program and thread safety.
06:18:55 <ziman> @arr
06:18:55 <lambdabot> I'll crush ye barnacles!
06:19:53 <ziman> i don't know what a barnacle is but the -cle suffix is enough to feel threatened
06:22:23 <dcoutts> Philonous: no it doesn't :-) you just need a more liberal interpretation of IO :-)
06:23:07 <Philonous> dcoutts Well, if my pure function crashes with IO-related errors it sure feels like i suddenly have observable side effects in purely functional code
06:23:13 <dcoutts> in particular to interpret lazy IO as non-determinism
06:23:39 <dcoutts> Philonous: you're only observing things in IO however
06:26:07 <FunctorSalad> "the IO monad is the toxic waste dump of Haskell"? :)
06:26:18 <dcoutts> yup
06:26:30 <burp> hah, nice description
06:26:39 <FunctorSalad> (sure, if it has undetermined semantics, it doesn't break anything logically...)
06:27:06 <dcoutts> there's probably semantics of quite a few bits of it
06:27:10 <dcoutts> including lazy IO
06:27:36 <dcoutts> meaning, unsafeInterleaveIO, but not unsafePerformIO of course
06:27:50 <FunctorSalad> hmm wouldn't it make sense to have more specific monads for the parts that do have semantics?
06:27:56 <dcoutts> there's a precise semantics for imprecise exceptions :-)
06:28:05 <FunctorSalad> (but that may be too inconvenient)
06:28:55 <Philonous> FunctorSalad: We could have those monads additionaly to IO, so if you want to be more specific about what you program is supposed to do you can use those, but you don't have to.
06:31:50 <FunctorSalad> yes... I suppose some areas of IO would lead to very complex types too
06:34:04 <ksf> hmmm hgl doesn't support bitmaps on x11 and appears to be bit-rotting, too.
06:34:56 <maltem> How do I get HPC to work with a cabal build? Adding GHC-Options: -fhpc doesn't give me any converage output
06:36:32 <dcoutts> maltem: running the program should make the tix file, which you can analyse with hpc
06:37:01 <dcoutts> maltem: you should not need to add it to the .cabal file, using configure --ghc-option=-fhpc should be enough
06:37:21 <maltem> dcoutts, oh you're right, I must have missed the file before :o
06:37:43 <dcoutts> maltem: it doesn't magically make html coverage report every time you run the program :-)
06:37:54 <maltem> oh I find it handy to put it in the cabal file
06:38:11 <dcoutts> maltem: right, just don't release it like that :-)
06:38:21 <maltem> true true :)
06:47:40 <maltem> heh hpc is fun to play with
06:47:59 <maltem> Look! It has been right again!
06:51:02 <kakeman> haskell in one day!
06:52:00 * Twey waits for Sam's ‘Learn Haskell in 24 Hours’
06:52:55 <ivanm> *shudder*
06:53:10 * ksf gives up on having sdl not clip part of the screen before the first resize
06:53:17 <Twey> I learn Java from one of those.
06:53:20 <Twey> learnt**
06:53:25 <Twey> They were more hard-core then, though.
06:53:31 <Twey> It was ‘Learn Java in 21 Days’.
06:54:34 <ivanm> did you actually bother reading till the 21st day?
06:54:44 <FunctorSalad> hehe
06:55:02 <Twey> ivanm: Nope.
06:55:11 <FunctorSalad> who made the "write yourself a C compiler in 48 hours" joke? ;)
06:55:22 <ivanm> what was the punchline?
06:55:25 <Twey> 48 hours per week.
06:55:26 <ivanm> download and build gcc?
06:55:31 <ivanm> Twey: ahhh
06:55:33 <Twey> For three years.
06:55:42 <Twey> No, I don't know if that was the original punchline.
06:55:46 <FunctorSalad> ivanm: I think what I said was the punchline already
06:56:00 <Twey> Heh.
06:56:05 <Phyx-> evening
06:56:09 <Twey> \o
06:56:15 <ivanm> oh...
06:56:16 <Axman6> there's a guy in #LLVM on oftc who's writing another C compiler
06:56:19 * ivanm doesn't really get it...
06:56:32 <ivanm> Axman6: presumably C -> LLVM?
06:56:44 <Axman6> well, it uses LLVM for optimisation
06:56:46 <ivanm> FunctorSalad: google knkows not...
06:56:48 <ksf> anyway, I got rid of my unsafePerformIO . newIORef's.
06:57:04 <ksf> ...now I need to figure out how not to start off by using them.
06:57:15 <ksf> er not use them in the first place.
06:57:56 <FunctorSalad> a safe way is to make the IORefs in main, stuff the into some record and pass that around
06:58:05 <FunctorSalad> *stuff them
06:58:56 <Philonous> Is there a way to tell cabal to use gmake instead of make?
06:59:37 <ivanm> Philonous: I dind't realise cabal used make at all...
06:59:48 <Twey> FunctorSalad: Ew.
06:59:58 <FunctorSalad> ? :(
07:00:12 <dcoutts> Philonous: seems not. It's hard coded, unlike all the other programs that cabal calls.
07:00:25 <dcoutts> Philonous: you're using the Distribution.Make build system I suppose?
07:00:32 * Twey ponders.
07:00:48 <ivanm> Philonous: make a symlink from make -> gmake in your path that is before the actual make binary?
07:00:50 <Philonous> dcoutts: wxcore is. I'm just struggling with it
07:00:52 <Twey> Yeah.  That only works if that's all you do in main (and it's still semantically dodgy).
07:01:12 <Twey> If you ever want to make more instances, without bootstrapping the whole program again, you need to make them in a separate action.
07:01:38 * ksf replaced the tvars with CHP channels and the iorefs with recursive state in some channel consumer.
07:01:38 <Philonous> ivanm: Yuk! But that might work.
07:02:28 <ksf> ...but no matter what I do, sdl is breaking every kind of encapsulation.
07:04:47 <ksf> if someone needs a project, a library providing a no-frills interface to a simple framebuffer and some basic input events supporting multiple windows where applicable with either x11, win32 or a plain linux framebuffer would be a cool thing.
07:05:22 <ksf> ...without using behemoths like wx or gtk, that is.
07:05:40 <FunctorSalad> speaking of wx ;) does "hpage" build for anyone?
07:05:56 <FunctorSalad> I'm getting: Could not find module `Graphics.UI.WXCore.WxcDefs.ExtraIdentities'
07:06:03 <Jafet> ksf, a la SDL?
07:06:50 <Philonous> Ah well, Distribution.Makes defaultMain just calls ./configure and make install, doesn't it? I can do that by hand.
07:07:01 <ksf> ...and with "no frills" I mean "give me a Ptr Word8, with, height, depth, colour mask and waitEvent"
07:07:12 <ksf> SDL sucks.
07:08:18 <ksf> there's tons of implicit state, no multiple window support and it plainly refuses to tell me the size of a window when it's being mapped.
07:08:32 <ksf> ...in fact, it doesn't even send an expose event.
07:10:04 <Jafet> Well, I can't think of any C library you want, so you're proposing something from scratch...?
07:10:38 <ksf> in other words, it fails to obey X11 laws: an app can't assume that the window manager maps a window with the requested size
07:10:42 <ksf> yes.
07:11:18 <sanxiyn> Yhc build question?
07:11:33 <sanxiyn> I get:
07:11:36 <ksf> ...just something to have a unificated interface to the x11 and win32 bindings that we already have.
07:11:43 <sanxiyn> tinuviel@debian:~/haskell/yhc$ scons
07:11:43 <sanxiyn> scons: Reading SConscript files ...
07:11:43 <sanxiyn> IOError: [Errno 2] No such file or directory: '_darcs/inventory':
07:12:10 <Jafet> I'm not sure if you can unify them nicely
07:12:32 <ksf> well I just want a framebuffer, nothing fancy.
07:15:34 <sanxiyn> ksf: SDL?
07:16:06 <tinLoaf> question regarding using regular expressions: can i somehow get only parts of a regexp match returned?
07:16:07 <ksf> that's what I'm using right now, and there's bugs left and right.
07:16:17 <tinLoaf> say I have the expression "^(:[^[:space:]]*)? [:alpha:]*"
07:16:17 <ksf> ...and an utterly non-haskell interface.
07:16:31 <tinLoaf> and I want only the [:alpha:]* stuff to be returned
07:16:49 <sanxiyn> I never used SDL from Haskell, but I used SDL from C and Python, and it was satisfactory.
07:16:53 <sanxiyn> I guess binding is no good
07:17:14 <sanxiyn> (e.g. didn't see any SDL bug)
07:17:16 <ksf> it's fine for one-window fullscreen programs.
07:17:58 <ksf> but fails to integrate into X11 and window managing.
07:18:26 <sanxiyn> Eh?
07:18:59 <ksf> ...like neither sending an expose or resize event when the window is mapped.
07:19:36 <olsner> glut perhaps? it's very simplistic though
07:19:40 <ksf> ...which means that I can't reinitialize the screen, which means that whatever I do, I'm going to have a wrong clipping plane until I resize the window.
07:20:20 <sanxiyn> Ah, so you need resizable window?
07:20:23 <olsner> I'm pretty sure SDL supports resizing though
07:20:29 <sanxiyn> (Or just disabling window resize is ok?)
07:21:01 <ksf> ...it does, but it seems to assume that it gets the requested window size.
07:21:29 <ksf> I actually want to have more than one window, so the replacement won't be glut.
07:21:55 <olsner> right, and SDL was missing multi-window support anyway?
07:22:00 <ksf> yep.
07:22:32 <ksf> sfml can do that, but there's no haskell bindings.
07:30:36 <taruti> Is there a working binary snapshot of GHC head? Seems like most of them fail in the install-stage.
07:32:35 <Alpounet> ksf, sfml is great, I know its author very well, it'd be great to have a Haskell binding
07:34:32 <Philonous> Strange. Now the compiler fails to find my openGL headers.
07:36:14 <maltem> Anyone to recommend some Haskell SHA1 implementation? There are so many of them out there.
07:36:58 <Alpounet> http://hackage.haskell.org/package/SHA ?
07:37:59 <maltem> Yes. Is it better than others?
07:38:40 <Alpounet> Actually I think they all are somehow very similar
07:39:03 <Alpounet> Though I haven't benchmarked them. You can do it if you want.
07:40:23 <Axman6> 1) question 2) download 3) benchmark 4) blog
07:41:08 <sanxiyn> I doubt whether anything would beat OpenSSL's SIMD assemblies.
07:43:34 <dcoutts> maltem: darcs's SHA1 is faster than the SHA package, however the SHA package has nice well tested code and it's properly packaged.
07:43:41 <dcoutts> and doesn't depend on any C libs
07:53:03 <Alpounet> is there a library able to render 3D text ?
07:55:55 <maltem> Alpounet, dcoutts, ok, then I'll have a go at the SHA package
08:04:50 <Luke30> Hi. Is there anyone who might be able to help me with installing Network.Curl under ghc on Windows XP?
08:05:47 <Luke30> It requires the C library libcurl, which I've tried putting where ghc can find it but it isn't.
08:07:47 <SamB_XP> Luke30: well, GHC won't actually be looking for it ... GHC's accompanying GNU toolchain will, though.
08:10:59 <Luke30> Where is it likely to look? I  used some flags in the cabal Setup.hs configure to specify the lib and include, which it seemed to find for compilation, but then when I actually run code it didn't find the .dll. I put the .dlls in ghc's bin, but now I'm getting
08:11:00 <Luke30> Loading package curl-1.3.5 ... linking ... <interactive>: C:\Programs\prog\Haskell\Andrew\curl-1.3.5\ghc-6.10.4\HScurl-1.3.5.o: unknown symbol `__imp__curl_easy_getinfo'
08:12:33 <Twey> Under Windows?  Probably %WINDOWS%\system32
08:14:07 <Saizan_> or alongside your binary
08:14:26 <Saizan_> not sure where for ghci, mh
08:15:04 <Luke30> %WINDOWS%\system32 gives the same error message
08:15:31 <Luke30> I was using ghci - I'll try compiling.
08:18:06 <Luke30> > module Main where
08:18:06 <Luke30> > import Network.Curl
08:18:06 <Luke30> > main = putStrLn "hello"
08:18:06 <lambdabot>   <no location info>: parse error on input `module'
08:18:07 <lambdabot>   <no location info>: parse error on input `import'
08:18:07 <lambdabot>   <no location info>: parse error on input `='
08:18:32 <Luke30> C:\Files\Andrew\A.work\!other\admin\projections and timetables\prog\TT>ghc Main.
08:18:32 <Luke30> lhs
08:18:32 <Luke30> Main.o:fake:(.text+0x14f): undefined reference to `__stginit_curlzm1zi3zi5_Netwo
08:18:32 <Luke30> rkziCurl_'
08:18:32 <Luke30> collect2: ld returned 1 exit status
08:18:48 <sleepynate> which module is "go" in?
08:19:01 <ksf> that's not the c lib that's missing, it's the haskell lib
08:19:05 <ksf> use ghc --make.
08:19:35 <dschoepe> sleepynate: It's a common name for recursive helper functions, but I don't know of any library that defines a go.
08:19:50 <sleepynate> oh well that would make a lot more sense
08:19:55 <Luke30> ghc --make Main.lhs you mean?
08:19:56 <SamB_XP> yeah, usually go is in a "where" clause ...
08:20:02 <sleepynate> i was begining to worry i'd missed something :P
08:20:43 <Luke30> > putStrLn "Does the lambdabot evaluate code then?"
08:20:43 <lambdabot>   <IO ()>
08:21:10 <Luke30> > "hello" ++ " lambdabot"
08:21:11 <lambdabot>   "hello lambdabot"
08:21:16 <Luke30> wow
08:21:18 <ksf> evaluate, yes, execute, no.
08:21:24 <SamB_XP> hehehe ;-)
08:21:33 <Luke30> cool
08:22:38 <Philonous> Is there any usable high-level UI library?
08:22:47 <ksf> no.
08:22:57 <Luke30> That was succinct
08:23:00 <ksf> depends on your definition of "usable", though.
08:23:01 <orbitz> so writing a safe haskell evaluator is easy becaue you just don't apply any IO thing through its monad right?
08:23:15 <lilac> > zipWith ($) (cycle [toUpper, id]) ('c':replicate 20 'o' ++ "l")
08:23:16 <lambdabot>   "CoOoOoOoOoOoOoOoOoOoOl"
08:23:16 <sanxiyn> orbitz: http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
08:23:21 <dschoepe> Philonous: grapefruit is high-level but I don't know how usable it is.
08:23:22 <orbitz> hot
08:23:24 <ksf> ...also called "mueval"
08:23:32 <Luke30> <chuckle>
08:23:39 <sanxiyn> "It's a lot more complicated than that..."
08:23:54 * ksf thinks grapefruit is impenetratable.
08:24:03 <ksf> it's a forest of arrows.
08:24:15 <sanxiyn> Is it like McCLIM
08:25:07 <Philonous> I tried to install phooey, but it depends on some old version of reactive and it doesn't tell which.
08:25:08 <mmorrow> orbitz: basically it's just a matter of making sure that none of the many possible ways to conjure unsafePerformIO are available
08:25:27 <ksf> phooey has bit-rotted.
08:25:29 <Luke30> My impression is that there isn't a nice, un-imperative, complete, fully featured GUI library out there, but there are many that omit one of those attributes.
08:25:40 <ksf> I guess you'd need ghc 6.0 or something.
08:25:59 <SamB_XP> ksf: how
08:26:03 <SamB_XP> that's before my time!
08:26:08 <ksf> we don't even have a nice, un-imperative, complete, fully-featured drawing lib.
08:26:20 <ksf> ...hieroglyph is close, but it fails in certain areas.
08:26:26 <Jafet> For some values of "nice", "complete", "fully-featured"
08:26:52 <jonh> hehe
08:26:59 <Berengal> ... there's always html... *ducks*
08:27:23 <ksf> like, you can't get a strings' bounding box out of hieroglyph, and layout is way too primitive.
08:27:29 <Luke30> ! throws things at Berengal
08:27:38 * ksf imagines a mixture of xrender and tex
08:27:47 <SamB_XP> ksf: wow, reminds me of SoE
08:27:48 <Philonous> There should be some warning on hackage for libraries that are abandoned/outdated.
08:27:48 <mmorrow> @type $(Language.Haskell.TH.Syntax.runIO (readFile "/etc/passwd") >>= \o -> return (Language.Haskell.TH.Lib.sigE [|undefined|] (Language.Haskell.TH.Lib.varT (mkName o))))
08:27:49 <lambdabot> parse error on input `$'
08:28:22 <jonh> Philonous: agreed
08:28:52 <SamB_XP> ksf: there is a purely-functional language for text layout ...
08:29:02 <SamB_XP> but the implementation isn't purely-functional ...
08:29:06 <SamB_XP> oh, lout, it's called
08:30:02 <ksf> does CHP count as being purely functional?
08:30:32 <SamB_XP> ksf: what's that ?
08:30:40 <ksf> @hackage chp
08:30:40 <lambdabot> http://hackage.haskell.org/package/chp
08:30:59 <ksf> a concurrency lib with a proper calculus as back end.
08:31:17 <ksf> "communicating sequential processes" it's called.
08:31:24 <SamB_XP> note, when I say lout is purely-funtional, that I'm mostly just parroting what the author says...
08:32:20 <ksf> ...I planned on having a thread for each widget.
08:33:26 <Luke30> isn't that a bit intensive?
08:33:46 <ksf> why?
08:33:54 <ksf> it's not pthreads we're talking about, but haskell threads.
08:34:02 <Luke30> oh, OK
08:34:05 <SamB_XP> Luke30: it depends how many widgets there will be ...
08:34:23 <SamB_XP> if there are likely to be thousands, you might be pushing it
08:34:24 <Luke30> if they're lazy I don't see a problem
08:34:41 <ksf> I refuse to worry about the number of threads as long as it's less than a million and not more than say 10 run at the same time.
08:35:00 * SamB_XP chuckles at gnuvince's quit message
08:35:42 <SamB_XP> ksf: well, I was only thinking of RAM cost
08:35:48 <Baughn> SamB_XP: It occurs to me, Heimdal was supposed to have nine mothers
08:35:58 <gnuvince> SamB_XP: can't remember where I stole that; I think Spolsky or maybe Atwood, someone like them.
08:36:02 * Philonous is horrified by Grapefruits sample code
08:36:10 <ksf> what's the per-thread cost? 16 bytes or something?
08:36:12 <SamB_XP> ksf: I don't know how big your threads' stacks are likely to get ;-)
08:36:24 <gwern> Baughn: heimdal's mothers are a curious issue
08:36:25 <SamB_XP> ksf: it's a bit more than that, I think ;-)
08:37:02 <gwern> Baughn: he's described as being engendered by 9 sisters in the Eddas, but the kennings suggest that this may be a sea metaphor
08:37:09 <Baughn> gwern: IIRC, they gestated him for several years, which is about what you'd expect
08:37:26 <gwern> 9 women will not bear one child in one month? :)
08:37:34 <Baughn> Still. This establishes Odin as the first PHB. ^_^
08:37:36 <SamB_XP> duh, it takes longer
08:37:49 <SamB_XP> they have to argue over all the details of what he'll look like and so on!
08:38:15 <Jafet> "But applying the powerful new tools of amortized analysis..."
08:38:16 <gwern> what color the baby shed^Wcrib, crib! will be
08:38:27 <gwern> (oh god I'm a good parent don't take him away from me)
08:38:34 <SamB_XP> lol@gwern
08:38:42 <Baughn> gwern: Hide him in a cupboard!
08:38:57 <SamB_XP> Baughn: BAD parent tip! BAD tip!
08:39:05 <gwern> SamB_XP: what, did #haskell switch to twitter while I wasn't looking?
08:39:18 <shepheb> SamB_XP: I dunno, he seemed  to turn out okay. defeating evil and all that.
08:39:18 <SamB_XP> lol
08:39:27 <SamB_XP> shepheb: well, sure
08:39:44 <Baughn> shepheb: He defeated evil through the power of suicide. I wouldn't call that "okay".
08:39:48 <shepheb> far more likely to create an emo kid than not, I think.
08:39:49 <Luke30> SamB_XP: Do you think putting libcurl stuff under C:\Programs\prog\Haskell\2009.2.0.2\gcc-lib will help?
08:40:02 <shepheb> and then everybody loses
08:40:03 <Luke30> and then reinstalling Curl.hs
08:40:07 <SamB_XP> Luke30: I don't really think so ...
08:40:30 <SamB_XP> Luke30: particularly not as the error message you got above seemed to indicate that what was being left out was the Haskell package...
08:40:57 <SamB_XP> ... or did you progress to another error message?
08:41:00 <ksf> did you try ghc --make yet?
08:41:27 <Luke30> ksf on my Main.lhs ? Yes. It was quite cross.
08:41:43 <sanxiyn> > let a = 1 in a
08:41:44 <SamB_XP> Luke30: what did it say?
08:41:44 <lambdabot>   1
08:41:52 <Luke30> lots of stuff like
08:41:56 <Luke30> C:\Programs\prog\Haskell\Andrew\curl-7.19.6\lib/libcurl.a(ssluse.o):(.text+
08:41:56 <Luke30> 5): undefined reference to `ERR_error_string'
08:41:56 <Luke30> C:\Programs\prog\Haskell\Andrew\curl-7.19.6\lib/libcurl.a(ssluse.o):(.text+
08:41:56 <Luke30> b): undefined reference to `SSLeay'
08:41:56 <Luke30> C:\Programs\prog\Haskell\Andrew\curl-7.19.6\lib/libcurl.a(ssluse.o):(.text+
08:41:56 <Luke30> ): undefined reference to `CRYPTO_cleanup_all_ex_data'
08:41:58 <Luke30> C:\Programs\prog\Haskell\Andrew\curl-7.19.6\lib/libcurl.a(ssluse.o):(.text+
08:42:00 <Luke30> ): undefined reference to `SSL_SESSION_free'
08:42:02 <Twey> > sin x
08:42:02 <Luke30> C:\Programs\prog\Haskell\Andrew\curl-7.19.6\lib/libcurl.a(md5.o):(.text+0x1
08:42:02 <lambdabot>   sin x
08:42:02 <ksf> @hpaste
08:42:02 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:42:04 <Luke30> ndefined reference to `MD5_Init'
08:42:06 <Luke30> C:\Programs\prog\Haskell\Andrew\curl-7.19.6\lib/libcurl.a(md5.o):(.text+0x2
08:42:08 <Luke30> ndefined reference to `MD5_Update'
08:42:10 <Luke30> C:\Programs\prog\Haskell\Andrew\curl-7.19.6\lib/libcurl.a(md5.o):(.text+0x3
08:42:13 <Twey> > sin x / cos x
08:42:14 <lambdabot>   sin x / cos x
08:42:15 <ksf> zomg stop spamming
08:42:20 <Twey> Boo, it's not very smart :þ
08:42:36 <SamB_XP> Luke30: oh, it looks like you need to go rebuild the curl library as a DLL ...
08:42:38 <ksf> ...it's not libcurl that's missing, but ssd and md5
08:42:47 <ksf> *ssl
08:43:13 <SamB_XP> ... unless you want to go hack the curl cabal file to add those other libs manually ...
08:43:21 <SamB_XP> which really is not the right way to do it
08:43:32 <Luke30> What's the right way to do it?
08:43:58 * Luke30 thought cabal was supposed to make all this easy
08:44:01 <SamB_XP> hmm, how does one build a curl.dll/libcurl.a ?
08:44:14 <SamB_XP> Luke30: cabal doesn't really help with compiling C things
08:44:18 <Luke30> I downloaded a built one.
08:44:22 <SamB_XP> oh.
08:44:43 <Luke30> I'm just not convinced I've convinced ghc to use it.
08:44:43 <SamB_XP> well, anyway, staticly-linked libs can be a pain to get linking right ...
08:45:01 <SamB_XP> Luke30: well, if you want to use that, go ahead and hack the curl .cabal file
08:45:03 <oskimura__> test
08:45:04 <beutdeuce> I have a problem concerning adding big numbers without using the bignum class. Can anyone point me in a helpful direction?
08:45:21 <SamB_XP> Luke30: what all are the .a files that you got from your C curl package?
08:45:40 <beutdeuce> my idea was to align both numbers and add each digit, like humans do, but the problem is when it is > 9 and i need to carry over
08:45:48 <Twey> Bignum… class?
08:45:58 <Twey> Around here we just use (+) on Integer
08:46:00 <beutdeuce> Twey: type
08:46:03 <ksf> the curl cabal file should already say that curl depends on ssl and md5
08:46:04 <beutdeuce> i kno
08:46:08 <beutdeuce> but its a challenge
08:46:13 <ksf> otherwise, it's clearly broken.
08:46:17 <Twey> Oh
08:46:20 <Twey> I suggest a fold
08:46:31 <beutdeuce> hmm
08:46:36 <SamB_XP> ksf: oh? it has to give deps for C libs ?
08:46:56 <SamB_XP> how is it supposed to know the dependencies of another package?
08:46:57 <Twey> You can carry the overflow on to the next digit with a parameter of your intermediate type
08:47:07 <Luke30> libcrypto.a,libcurl.a,libcurldll.a,libeay32.a,libidn.a,libidn.dll.a,libssh2.a,libssh2dll.a,libssl.a,libssl32.a,libz.a,libzdll.a
08:47:12 <beutdeuce> Twey: huh?
08:47:23 <beutdeuce> i kinda get what u are saying
08:47:31 <ksf> you usually say something like pgkconfig-depends: ssl md5 and cabal will use pkg-config to look up the flags it needs.
08:47:33 <SamB_XP> beutdeuce: you might also want to look up some arbitrary-precision addition algorithms
08:47:59 <SamB_XP> beutdeuce: I don't suppose you have Volume 2 (Seminumerical Algorithms) ?
08:48:11 <ksf> anyway, you should be able to work around the problem by passing -lssl and -lmd5 to the linker
08:48:18 <beutdeuce> by Knuth?
08:48:20 <SamB_XP> yeah
08:48:29 <beutdeuce> no
08:48:41 <SamB_XP> could you borrow it from a library?
08:48:51 <SamB_XP> My school has, like, the previous edition!
08:48:51 <sanxiyn> beutdeuce: Eh... you just add.
08:48:51 <beutdeuce> perhaps, why would u recommend so?
08:49:13 <SamB_XP> oh, it has algorithms for stuff like this, I think ...
08:49:25 <sanxiyn> Damnit it's addition, not even multiplication.
08:49:37 <beutdeuce> sanxiyn: same thing in this case
08:49:42 <sanxiyn> How?
08:49:59 <SamB_XP> hmm, true
08:50:05 <beutdeuce> [1,2,3] * [4,5,6] has a similar carry-over approach as [1,2,3] + [6,7,8]
08:50:11 <SamB_XP> I forgot that addition doesn't leave you with increasing carries ;-P
08:50:22 <beutdeuce> well, besies the second level
08:50:25 <beutdeuce> but its just repetitive
08:50:28 <SamB_XP> yeah, you just need one carry bit, I guess, regardless of the radix
08:50:31 <sanxiyn> beutdeuce: You can do much better than simple hand calculation in multiplication.
08:50:47 <sanxiyn> In addition, not so much.
08:51:34 <SamB_XP> beutdeuce: so, are you doing decimal, or more like (maxBound::Int)-imal?
08:51:47 <SamB_XP> er.
08:52:01 <beutdeuce> no decimal, just add big numbers that exceed maxbound of regular ints
08:52:05 <beutdeuce> which is 2 billion i believe
08:52:14 <SamB_XP> (fromIntegral (maxBound::Int)+1)-imal
08:52:34 <osfameron> what docs should I be looking at to randomly select something of this datatype: data Coin = Head | Tail   ?
08:52:34 <SamB_XP> beutdeuce: it varies
08:52:47 <SamB_XP> > 2^29 :: Integer
08:52:48 <lambdabot>   536870912
08:52:58 <SamB_XP> > 2^29 - 1 :: Integer
08:52:58 <lambdabot>   536870911
08:53:14 <SamB_XP> that's the minimum baxBound for Int
08:53:23 <SamB_XP> er. *maxBound ;-)
08:53:32 <Jafet> You can do fast addition with custom circuits
08:53:46 <SamB_XP> Jafet: I think he's just doing an excercise
08:53:50 <burp> buy 64bit cpu ;)
08:53:58 <burp> > maxBound :: Int64
08:53:59 <lambdabot>   9223372036854775807
08:54:01 <burp> > maxBound :: Int
08:54:02 <lambdabot>   9223372036854775807
08:54:03 <beutdeuce> 1345635956519929359996838814338975426456796192899282816718414695516522792638477884928444418751334132288281532779183761576599889712412314939586151744419157346192171714581695951774643783742562378688758994237623267629724843974317795857561193519347159562892466385885359915436931774947345552474344448642894466661832273533311162243326456472159577391551149246243741649212751687126194918715312116712423394946719232171121368365658692948461358273243
08:54:10 <beutdeuce> i will need to add numbers as big as that
08:54:15 <burp> ok ;)
08:54:18 <SamB_XP> I wonder how Int64 compares to Integer performance-wise on 32-bit GHC ...
08:54:24 <medfly> o.O
08:54:29 <mmorrow> , (length . show) (1000000 ^ 10000000)
08:54:35 <lunabot>  Killed.
08:54:38 <mmorrow> , (length . show) (1000000 ^ 100000)
08:54:40 <lunabot>  600001
08:54:53 <SamB_XP> if you're wondering where I pulled (2^29-1) from ...
08:55:14 <SamB_XP> it's because Int is required to be at least 30 bits wide, and one of those bits is a sign bit
08:55:15 <beutdeuce> yesterday, someone showed me (print $ map (\l -> sum $ map (read :: String-> Int) $ words l) input), but for some reason, it doesnt work for all sample inputs
08:56:02 <SamB_XP> benmachine: it doesn't appear to do carry ;-)
08:56:13 <mmorrow> SamB_XP: Int64 is horrendously slow on 32bit ghc
08:56:19 <beutdeuce> yeah
08:56:22 <Botje> beutdeuce: perhaps you want String->Integer instead of String->Int.
08:56:38 <beutdeuce> still wouldnt carry though
08:56:46 <SamB_XP> mmorrow: yeah, so I'm just wondering how it compares to (conditionally) calling out to GMP
08:56:51 <beutdeuce> oh wait
08:56:58 <SamB_XP> mmorrow: why did you think I even asked ?
08:57:15 <beutdeuce> String -> Integer seems to work
08:57:23 <beutdeuce> wait, why does that work?
08:57:28 <Botje> "seems" to work?
08:57:38 <Botje> this is haskell! you're supposed to be *sure* it works :)
08:57:40 <beutdeuce> why does map (\l -> sum $ map (read :: String-> Integer) $ words l) input work
08:57:50 <beutdeuce> at least it seems to work
08:57:51 * osfameron finds http://www.haskell.org/pipermail/haskell-cafe/2005-April/009686.html which has some examples for coin-flipping random stuff
08:57:57 <Botje> what's your interpretation of "work" and "seems to work" ?
08:57:59 <SamB_XP> beutdeuce: are you supposed to be implementing arbitrary-precision addition -- that is, is that the entire point of the assignment ?
08:58:12 <SamB_XP> I assume it's an assignment, recalling the funky input data you had before ...
08:58:15 <beutdeuce> http://y0u.dontexist.com:203/cs/1.html (Arbritrary AdddeR) is ther assignment
08:58:31 <Botje> that is one freaky port number.
08:58:35 <SamB_XP> it is
08:58:41 <beutdeuce> yes, same reaction. not my server :P
08:58:42 <SamB_XP> I use 8080 myself
08:59:04 <Botje> "You may not use a BigInt class."
08:59:05 <SamB_XP> beutdeuce: huh, is this assignment for *you*?
08:59:19 <SamB_XP> I guess not
08:59:21 <Botje> beutdeuce: so you have to implement the addition yourself.
08:59:24 <SamB_XP> not for doing in Haskell, anyway
08:59:34 <beutdeuce> why?
08:59:40 <Botje> "You may not use a BigInt class."
08:59:45 <Botje> Integer falls under that :)
08:59:49 <SamB_XP> or at least not specifically for Haskell
09:00:08 <Botje> represent the numbers as lists of digits
09:00:08 <beutdeuce> she said that for java, but basically meant that u cannot use anything that fits under the bigint class
09:00:15 <Botje> and implement the addidion on that yourself.
09:00:26 <Botje> *addition.
09:00:28 <SamB_XP> yeah, Integer is in the same category
09:00:28 <Axman6> yeah, i was thinking the same thing
09:00:34 <Axman6> String addition++
09:00:36 <Botje> well, if you don't think Integer is cheating, go ahead and use it.
09:00:36 <beutdeuce> which is why i wanted to do column addition with carrying over with ints, cause the highest u have to wrry about is 9+9
09:00:37 <SamB_XP> but this assignment was due yesterday
09:00:52 <beutdeuce> SamB_XP:  ignore the date
09:01:13 <SamB_XP> beutdeuce: well, there's no real reason you have to use decimal
09:01:32 <beutdeuce> what do u suggest?
09:01:34 <Luke30> osfameron http://www.haskell.org/onlinereport/random.html
09:01:37 <SamB_XP> though if you make it just a top-level constant you can use that for now and switch to something more efficient later ;-)
09:01:40 <Botje> 18:00 < Botje> represent the numbers as lists of digits
09:01:42 <Botje> 18:00 < Botje> and implement the addidion on that yourself.
09:01:47 <SamB_XP> well, decimal is easier to debug for humans, certainly
09:02:13 <beutdeuce> Botje: thats what i tried
09:02:24 <beutdeuce> couldnt get carrying over to work
09:02:24 <SamB_XP> so I'd suggest making your code use a constant "radix", and put "radix :: Int" / "radix = 10" at the top of your code for now
09:02:37 <Botje> what went wrong? can you put your code on a paste site?
09:02:52 <Botje> what do you mean by "work" ? be specific :)
09:03:08 <Botje> did the carry work sometimes? only in certain cases? never?
09:03:09 <SamB_XP> beutdeuce: well, you need to create an "add' :: Bool -> [Int] -> [Int] -> [Int]"
09:03:17 <osfameron> Luke30: yeah.. that doc doesn't really explain how to *use* it though...
09:03:20 <beutdeuce> well, all i have now is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9554#a9554
09:03:40 <SamB_XP> where the Bool would be the carry flag
09:03:44 <Botje> o .. kay..
09:03:58 <beutdeuce> which works, but apparently Integer there is a bigint
09:04:23 <SamB_XP> yeah
09:04:37 <Botje> you should probably start by rewriting main to use a "myAdd :: [Int] -> [Int] -> [Int]"
09:04:39 <SamB_XP> beutdeuce: do you know what little-edian means ?
09:04:47 <SamB_XP> er. *endian
09:04:50 <orbitz> SamB_XP: it's spelled 'indian'
09:04:58 <SamB_XP> orbitz: no, it isn't!
09:05:02 <mmorrow> i thought it was "injin"
09:05:18 <SamB_XP> like I'm going to take spelling/punctuation tips from you, anyway, orbitz!
09:05:34 <beutdeuce> "Big-endian and little-endian are terms that describe the order in which a sequence of bytes are stored in computer memory. "
09:05:38 <mmorrow> "lil-injin"
09:05:57 <mmorrow> "why how there lil-injin", etc
09:06:32 <SamB_XP> beutdeuce: well, they actually have more to do with how you interpret a sequence of digits as a number
09:06:38 <SamB_XP> that's just one special case of it
09:06:44 * mmorrow ducks to avoid the arrows
09:06:54 <Axman6> pew pew
09:07:03 <sanxiyn> > (\x y->zipWith (+) ([0]++(zipWith (\x y->if x+y>9 then x+y-10 else x+y) x y)) ((zipWith (\x y->if x+y>9 then 1 else 0) x y)++[0])) [5,6] [6,7]
09:07:05 <lambdabot>   [1,2,3]
09:07:18 <sanxiyn> Is 56 + 67 = 123?
09:07:27 <Axman6> what the...
09:07:40 <Axman6> > 56 + 67
09:07:41 <lambdabot>   123
09:07:46 <SamB_XP> beutdeuce: anyway, since you seem to know basically what it is, I'd suggest you use little-endian lists
09:07:59 <beutdeuce> now u lost me :)
09:08:00 <SamB_XP> sanxiyn: that was a silly question ;-P
09:08:19 <sanxiyn> (Above is buggy, obviously)
09:08:45 <SamB_XP> > (reverse . map charToInt) "2525674"
09:08:46 <lambdabot>   Not in scope: `charToInt'
09:08:59 <SamB_XP> @hoogle Char -> Int
09:08:59 <lambdabot> Data.Char digitToInt :: Char -> Int
09:08:59 <lambdabot> Data.Char ord :: Char -> Int
09:08:59 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
09:09:05 <SamB_XP> > (reverse . map digitToInt) "2525674"
09:09:06 <lambdabot>   [4,7,6,5,2,5,2]
09:09:19 <sanxiyn> (Also, it is little-endian)
09:09:44 <benmachine> SamB_XP: you highlighted me a bit ago, were you aiming for someone else?
09:09:44 <SamB_XP> sanxiyn: what is ?
09:09:46 <Berengal> little-endian are strict
09:09:47 <mmorrow> , let digits = let go !is x = case quotRem x 10 of (0,i) -> i:is; (x',i) -> go (i:is) x' in go [] in digits 98723874
09:09:48 <lunabot>  [9,8,7,2,3,8,7,4]
09:09:51 <sanxiyn> > (\x y->zipWith (+) ([0]++(zipWith (\x y->if x+y>9 then x+y-10 else x+y) x y)) ((zipWith (\x y->if x+y>9 then 1 else 0) x y)++[0])) [5,6] [6,7]
09:09:51 <lambdabot>   [1,2,3]
09:09:55 <SamB_XP> benmachine: oops, probably beutdeuce
09:09:57 <Berengal> If you want some sort of value out of them
09:10:05 <benmachine> k, just checking
09:10:18 <SamB_XP> I really need to get in the habbit of typing 3-character prefixes before hitting tab in here ...
09:10:22 <benmachine> heh
09:10:36 <sanxiyn> (Or am I wasting my time)
09:10:39 <SamB_XP> of course, when I do, it'll be up to 4 ;-P
09:10:48 <Berengal> SamB, <- is what I get with "sam"
09:10:50 <SamB_XP> sanxiyn: probably ;-P
09:10:59 <SamB_XP> Berengal: that is close enough
09:11:01 <sanxiyn> SamB_XP: I just don't understand what's the problem
09:11:04 <sanxiyn> It's just adding.
09:11:16 <beutdeuce> ok, i need to start with a clean slate
09:11:24 <SamB_XP> I've configured it so I get highlighted either way
09:11:51 <beutdeuce> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9555#a9555 is what i have so far
09:11:56 <sanxiyn> You calculate the digit (map, zip, whatever), calculate the carry (same...), shift carry and add again.
09:12:19 <SamB_XP> sanxiyn: well, that works well for golfing I guess ;-P
09:13:02 <SamB_XP> and if you're going to use decimal, I guess constant factors aren't a big concern
09:13:34 <sanxiyn> Well you could calculate digit and carry together
09:13:48 <beutdeuce> i have no idea how carrying would work
09:14:09 <SamB_XP> beutdeuce: I was thinking you could have myAdd' :: Bool -> [Int] -> [Int] -> [Int]
09:14:21 <sanxiyn> beutdeuce: If it sums to >9, carry is 1, otherwise 0.
09:14:29 <SamB_XP> oh, and honestly, I'd just comment out the main for now ;-)
09:14:39 <SamB_XP> don't bother with that, just play with your code in GHCi ;-)
09:14:42 <beutdeuce> how do u comment in Haskell, again?
09:14:50 <SamB_XP> {- -} or --
09:15:01 <SamB_XP> took me a couple seconds to remember
09:15:05 <beutdeuce> k
09:15:09 <SamB_XP> at first I was like "(* *)"
09:15:23 <SamB_XP> but then I was like, "no, wait, that's Coq!"
09:15:45 <sanxiyn> God curses Coq
09:15:49 <SamB_XP> hmm?
09:16:14 <Jafet> But girls love guys fluent with coq
09:16:22 <SamB_XP> beutdeuce: anyway, the myAdd' I'm suggesting
09:16:31 <SamB_XP> the Bool argument would be the carry
09:17:04 <SamB_XP> possibly an Int argument would be more convenient, though
09:17:16 <Luke30> osfameron randomIO >>= (\x -> (putStrLn.show.not) x)
09:17:17 <sanxiyn> SamB_XP: I hate Coq's insistance on constructivism.
09:17:27 <Jafet> Is it the carry value (Int), or whether there is a carry (Bool)?
09:17:43 <SamB_XP> sanxiyn: hmm, I didn't think it was Coq that was insistant on it so much as myself ;-)
09:17:45 <Luke30> make your own showcoin function
09:17:45 <Axman6> heh: "Like yacc, we include %% here, for no real reason."
09:18:02 <SamB_XP> Axman6: yeah
09:18:11 <sanxiyn> SamB_XP: You are a constructivist! Die, die!
09:18:13 <SamB_XP> at least they're honest
09:18:15 <cknapp> Isn't Coq based on a constructive calculus?
09:18:23 <Jafet> I'm not very sure about the usefulness of nonconstructivist programming
09:18:25 <sanxiyn> Law of excluded middle OMG
09:18:42 <sanxiyn> Jafet: Me neither, but nonconstructive proof is very useful.
09:18:48 <SamB_XP> sanxiyn: I just don't see the point of theorems saying there is something but not actually telling how to find it!
09:18:56 <osfameron> Luke30: where's the generator in that?  and how come you're not'ing a random number?
09:19:07 <sanxiyn> Law of excluded middle OMG
09:19:09 <SamB_XP> they're very frustrating to me
09:19:10 <Jafet> True, but you run into hairy balls when it comes to impurities
09:19:25 <Jafet> Take prolog, for example
09:19:42 <SamB_XP> what is the type of osfameron ?
09:19:46 <SamB_XP> :t osfameron
09:19:48 <lambdabot> Not in scope: `osfameron'
09:19:55 <SamB_XP> @hoogle osfameron
09:19:55 <lambdabot> No results found
09:20:04 <SamB_XP> ... well, people ?
09:20:13 <sanxiyn> What *is* osfameron?
09:20:16 <SamB_XP> Jafet: what impurities ?
09:20:17 <Jafet> SamB_XP, sometimes you cannot find it due to limitations of your axioms
09:20:55 <cknapp> Jafet: How does a "less limited" AC give you an explicit choice function?
09:21:05 <TommyOnMac> hi
09:21:08 <sanxiyn> Also, people, on Haskell comments,
09:21:13 <cknapp> Hi
09:21:21 <osfameron> SamB_XP: ;-P
09:21:22 <sanxiyn> Haskell is like SQL in that it uses -- as a comment marker.
09:21:25 <sanxiyn> Any objection?
09:22:05 <osfameron> isn't -- a mysql thing, rather than part of sql standard ?
09:22:06 <TommyOnMac> A quick question about haskell-mode. ctrl-c ctrl-l loads the current buffer into ghci. How can I make it start execute main as well without having to swtich buffer and type main?
09:22:13 <sanxiyn> osfameron: It is part of SQL standard.
09:22:32 <Berengal> TommyOnMac, compile it and start the binary from a shell, or hack haskell-mode...
09:22:35 * SamB decides he does not need this haskell98-tutorial-200006/ directory he found lying about ...
09:23:11 <SamB> I don't need a copy of "A Gentle Introduction to Haskell 98"'s source dating from June 2000 ;-P
09:23:45 <cknapp> Why not?
09:23:59 <sanxiyn> Because he likes it rough?
09:24:12 <sanxiyn> Oh, Haskell! Don't be gentle any more!
09:24:12 <Luke30> osfameron: randomIO generates a random value of any type that's an instance of Random. Bool is, and I'm using not to make sure randomIO generates a boolean.
09:24:15 <Berengal> SamB, in computer terms, that belongs in a museum
09:24:34 <SamB> well, if I wanted to look at it, I would look online
09:24:41 <SamB> if I wanted to fix it, I would have done that long ago
09:25:01 <sanxiyn> Hm, I keep a lot of online documentation in the local disk, just in case
09:25:09 <SamB> yeah
09:25:13 <sanxiyn> Has been useful occasionally
09:25:27 <sanxiyn> e.g. I keep all W3C recommendations in my hard disk
09:25:29 <SamB> well, more seriously I haven't looked at "a gentle introduction" in years
09:25:32 <SamB> not seriously
09:25:33 <sanxiyn> (Probably should delete all WS-* stuffs)
09:25:36 <SamB> sanxiyn: all ?
09:25:42 <SamB> yeah, deleate the webstar!
09:25:46 <sanxiyn> SamB: "Recommendations" aren't that many...
09:25:49 <SamB> oh.
09:25:53 <sanxiyn> Not drafts.
09:25:57 <SamB> is that like STDs?
09:26:02 <SamB> the IETF kind
09:26:03 <sanxiyn> Sort of.
09:26:07 <SamB> not the disease kind
09:26:25 <SamB> there are, what, ~30 STDs?
09:27:04 <cknapp> Hmm... I should really do something about this algebra problem I can't figure out...
09:27:20 <sanxiyn> SamB: I think it's up to 60 or so.
09:27:51 <cknapp> Wait, what's on STD?
09:27:59 <cknapp> an*
09:28:30 <SamB> cknapp: apparantly, some RFCs actually graduate and become Internet Standards as well as RFCs
09:28:49 <cknapp> Ah.
09:28:55 <SamB> only a very small number, compared to the number that are actually used as standards
09:29:11 <sanxiyn> Namely: http://rfc-editor.org/std-index.html
09:29:18 <sanxiyn> Ah, STD69 is the last.
09:29:20 <SamB> important things like Ethernet and TCP/IP
09:29:30 <SamB> iirc
09:29:39 <sanxiyn> IP is STD5, TCP is STD7.
09:29:46 <cknapp> Interesting... I think SONET over Sonnet should become one...
09:29:48 <sanxiyn> (STD6 is UDP.)
09:29:54 <SamB> what's ethernet? isn't that one ?
09:30:39 <sanxiyn> SamB: Ethernet ARP is STD.
09:30:50 <RayNbow> preflex: seen bos
09:30:50 <preflex>  bos was last seen on #haskell 1 day, 12 hours, 34 minutes and 24 seconds ago, saying: @pl \w->(True,w)
09:30:51 <sanxiyn> Not sure about Ethernet itself.
09:31:29 <Luke30> osfameron: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9558#a9558
09:31:32 <Axman6> @pl \w -> (True,w)
09:31:32 <lambdabot> (,) True
09:31:34 <SamB> maybe they didn't grandfather it in?
09:31:35 <Luke30> printRandomCoin
09:32:20 <sanxiyn> Hm, didn't know that URI is now STD.
09:32:51 <sanxiyn> Apparently UTF-8 is too.
09:33:24 <osfameron> Luke30: cool thanks - I've been looking at that haskell cafe thread though - people were suggesting that using randomIO wasn't such a good idea, and to use mkStdGen instead, on the basis that less stuff has to be "in the IO monad".
09:33:40 <osfameron> which I don't get entirely, as the functions they call are still in IO anyway
09:33:50 <lightstep> is anyone familiar with eclipsefp? i'm trying to add "-lglut" as a compiler flag, and can't find the place to do his
09:35:18 <Axman6> > let fibs = x:y:zipWith (+) fibs (tail fibs) in fibs :: [Expr]
09:35:18 <lambdabot>   [x,y,x + y,y + (x + y),x + y + (y + (x + y)),y + (x + y) + (x + y + (y + (x...
09:35:27 <Luke30> osfameron: Yeah, I agree with you - we have to go IO because randomNess isn't pure
09:35:28 <Heffalump> nice!
09:35:46 <Luke30> osfameron: so we may as well not get upset about it early....
09:36:11 <osfameron> Luke30: ok, so I have http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9559#a9559
09:36:26 <osfameron> (cargo culted from the -cafe thread of course)
09:37:06 <osfameron> how do I write do { x <- guess; return $ counter x } more elegantly again?
09:37:13 <Twey> osfameron: Because it allows your random-generating function to be pure, and be called from other code with generators other than the one you just got from mkStdGen
09:37:37 <wdonnelly> osfameron: counter `fmap` guess, I think
09:37:45 <Axman6> osfameron: fmap counter guess
09:37:52 <Twey> counter <$> guess
09:37:59 <osfameron> eeek!
09:38:12 <c_wraith> (<$>) counter guess
09:38:14 <c_wraith> ;)
09:38:28 <Twey> Hehehe
09:38:32 <lightstep> you can also replace fmap with liftM
09:38:34 <osfameron> ah, that's fmap because guess has returned IO [Coin]
09:38:41 <Twey> Aye
09:38:43 <osfameron> I tried liftM, couldn't get it to work
09:38:44 * Axman6 doesn't like using fmap infix. i read fmap foo bar as fmap foo onto bar
09:39:07 <Twey> :t fmap
09:39:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:39:17 <osfameron> @index (<$>)
09:39:17 <lambdabot> bzzt
09:39:19 <Twey> It's nice so long as it doesn't force you into thinking of it binarily
09:39:25 <Twey> osfameron: Control.Applicative
09:39:40 <osfameron> oooo! ghci supports "import" now
09:39:45 * osfameron does a happy dance
09:39:46 <Twey> ‘Now’?
09:39:48 <Heffalump> really? cool!
09:39:50 <Twey> It's supported it for ages
09:39:56 <osfameron> well, it didn't the last time I checked
09:39:59 <Twey> It's just a synonym for :m + though :þ
09:40:03 <osfameron> I've not done a whole load of haskell recently...
09:40:07 <Twey> It's supported it since before I came to Haskell.
09:40:13 <Twey> So at least a year or so.
09:40:26 <Luke30> @hoogle (<$>)
09:40:26 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:41:01 <Luke30> @hoogle liftM
09:41:02 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
09:41:02 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:41:02 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
09:41:24 <osfameron> hmmm, I haven't played with haskell since March... I guess I must have had an old ghci though - it was kinda hard to install a fresh one on ubuntu in those days, so I might have stuck with the packaged version
09:41:28 <Twey> (It's just a synonym for :m + though ≡ You can't do qualified imports or anything)
09:41:41 <Twey> Guess so
09:42:00 <osfameron> so, how would I use liftM for that?
09:42:11 <Twey> liftM ≡ fmap
09:42:31 <Twey> If the thing is both a Monad and an Applicative, which IO is
09:42:37 <osfameron> ah
09:42:47 <Luke30> import Control.Monad first
09:43:06 <Luke30> but <$> is prettier
09:43:15 <Twey> I agree
09:43:28 <Twey> Sometimes I use fmap, though, just to avoid adding another import :þ
09:43:32 <kakeman> what is $= =
09:43:34 <kakeman> ?
09:43:43 <Luke30> you import Control.Applicative for <$>
09:43:47 <Twey> Isn't that a GL thing, kakeman?
09:44:21 <Luke30> I wish some of these were in scope from the prelude.
09:44:41 <Twey> IIRC, HOpenGL uses it to set config, to make it look like assignment
09:45:22 <Jedai> kakeman: something like writeIORef, but in operator form (it used to be in HOpenGL but it has now been split in its own package)
09:45:37 <Twey> Oh, really?  Huh.
09:46:04 <kakeman> Jedai: yes
09:46:11 <Jedai> Twey: I think so, as part of the big reorganization of the OpenGL and Glut packages
09:46:12 <kakeman> opengl woo!
09:46:34 * byorgey makes lambda-hummus
09:47:15 <c_wraith> mm.  hummus
09:47:56 <Jedai> Twey: StateVar http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
09:48:55 <cknapp> lambda hummus? Now we need a pita monad to put it in...
09:49:57 <Saizan_> Twey: fmap is from Functor, not Applicative!
09:50:17 * Saizan_ calls the category police
09:50:19 <Twey> Arr!  Ye done caught me, lad.
09:51:11 <Twey> Not the category police!  They'll lock me in a monad jail!
09:51:54 <FunctorSalad> trap'd in dream monad
09:52:05 <Twey> Haha
09:56:17 <Alpounet> Anyone knows a library for rendering 3D texts ? :-)
09:58:14 <FunctorSalad> Alpounet: FTGL
09:58:20 <FunctorSalad> in OpenGL anyway
10:00:03 <Luke30> Using libcurl/Curl blues: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9560#a9560
10:02:03 <Luke30> @hoogle (a->b)->M a -> M b
10:02:03 <lambdabot> Warning: Unknown type M
10:02:03 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
10:02:03 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
10:02:31 <Luke30> That @hoogle is ace. Is it available from ghci or winhugs in some way?
10:02:56 <benmachine> I don't think so, but with some effort it is possible to download and run your own lambdabot
10:03:26 <osfameron> Luke30 et al: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9561#a9561
10:03:37 <FunctorSalad_> Luke30: cabal install hoogle
10:03:56 <osfameron> that'll do for this afternoon's haskell hacking I think - my feeble brane is beginning to hurt :-)
10:04:19 <_nickel> how do I unwrap record types in the head of a function
10:04:24 <FunctorSalad_> Luke30: (then you can run "hoogle" from the command line)
10:05:05 <_nickel> http://gist.github.com/189530
10:06:04 <ehamberg> i'm trying to wrap my head, which is too used to oop, around functional programming. i'm writing a poker game and have all the hand evaluation etc. done, but i can't figure out how to put it all together.
10:06:13 <ehamberg> in an oop langauge i would have objects representing players (with their cards and their money) and a global state representing the pot, the reamining deck, etc.
10:06:37 <c_wraith> _nickel: show (Position o c) ...
10:06:49 <_nickel> c_wraith: thanks
10:06:53 <Alpounet> FunctorSalad, will take a look at it :-)
10:07:09 <_nickel> c_wraith: as always :D
10:07:13 <Luke30> well done osfameron
10:07:17 <ehamberg> i'm having problems escaping from that way of thinking. can someone point me in the right direction on how to do this in Haskell?
10:07:22 <Alpounet> FunctorSalad, there isn't a haskell binding :-(
10:07:25 <Luke30> thanks FunctorSalad_
10:07:53 <holmak> ehamberg: One way you could go about thinking about it is as a series of states
10:08:06 <holmak> ehamberg: And each turn, the state is changed in a certain way
10:08:33 <holmak> ehamberg: the state might be {pot, handOne, handTwo, deck }
10:08:49 <laney_> hi, is there any way that I can get ghci or even a compiled executable to print a line every time a given expression is evaluated including the parameters it's being evaluated with. somehow I think this would be less cumbersome than ghci breakpoints in certain cases
10:09:09 <mauke> laney_: Debug.Trace
10:09:10 <holmak> ehamberg: and there are a set of "moves" players could take each turn; data Move = Raise | Stay | Draw
10:09:34 <ehamberg> holmak: yes, i have read a bit about the state monad. i guess i should use something like that.
10:09:53 <ehamberg> holmak: the "query player n" part is quite confusing to me.
10:09:57 * Laney gets hilighted
10:09:58 <holmak> ehamberg: you don't even need to go as far as the state monad. have a look at fold
10:10:17 <holmak> ehamberg: What do you mean by "query player"?
10:10:25 <laney_> thank you
10:11:09 <holmak> @hoogle foldr
10:11:09 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
10:11:09 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
10:11:09 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
10:11:11 <ehamberg> holmak: maybe my thinking about this is off. i mean, i first need to "ask" player 1 what he would like to do, then store what he did, then ask player 2, and so on, until player n completes that betting round.
10:11:41 <lilac> @hoogle bidl
10:11:41 <lambdabot> No results found
10:11:58 <holmak> ehamberg: What is your interaction setup? One human player and a bunch of bots, or something else?
10:12:15 <jfoutz> heh. i think i remember having that exact struggle.
10:12:25 <ehamberg> bunch of bots. i would like to choose how many to play in a round.
10:13:12 <holmak> ehamberg: Is there a human player, or no? It makes a bit of difference, because of handling IO.
10:13:46 <ehamberg> no human player.
10:14:08 <holmak> ehamberg: Good, that simplifies things. Unfortunately, my poker knowledge is a tad rusty.
10:14:08 <jfoutz> ehamberg: one way to go, make a dealer that asks each player in turn what they want to do. make each player a function, pass in the state of the game... visible cards, pot size, prior players raises and such. have them return an action.
10:14:41 <jfoutz> then the dealer will make a new game state based on that player's action. then it asks the next player what to do.
10:15:32 <jfoutz> when the dealer runs out of players, the next card is revealed, or a winner is declared.
10:16:32 <jfoutz> so, dealer is just a function. you pass in a list of players, that are... say a pair of money and a play function.
10:17:27 <jfoutz> you can simplify the play function by breaking it up into what to do in each phase... (100,preFlop,flop,turn,river)
10:17:41 <lilac> osfameron: your coinFlips function could be simplified with an 'instance Random Coin'
10:17:55 <ehamberg> yeah, maybe i was just thinking too complicated.
10:18:48 <osfameron> lilac: yeah... a blog post I was reading before suggested that.  I don't know how to do it though... (did I mention that the docs for System.Random are quite confusing? ;-)
10:18:51 <ehamberg> what i am worried about is that i am later going to add recording about what each player did at each stage, and merge that information with what hole cards they had and make that information available to all players (if their hands were shown).
10:19:00 <ehamberg> i don't want to code myself into a corner :)
10:19:13 <ksf> ThTTrhherraeedaad d tt eetrremmriimnniaanttaeetdde  dww iiwtithth:h: : t ththrhrereaeadad d b blblolocockckekeded d i inindndedefefifinininititetelelylyy
10:19:30 <jfoutz> one absolutly *fantastic* feature of haskell is the strong type checker.
10:19:33 <ksf> thread safety yay!
10:19:46 * BMeph thinks someone needs to change the bateries in his wireless keyboard...
10:20:01 <jfoutz> ehamberg: make something work, add a field, the compiler will tell you everything you need to fix. it's very very quick to make changes like that.
10:20:02 <lilac> osfameron: iirc all you need is a definition of 'random'. 'instance Random Coin where random g = case random g of (True,g') -> (Head,c'); (False, g') -> (Tail,g')' might do
10:20:39 <ehamberg> jfoutz, holmak: thanks a lot!
10:20:57 <lilac> ksf: "Thread terminated: threads knotted irrevocably"
10:20:58 <jfoutz> ehamberg: just a matter of the dealer appending each player's action to a list. should be an easy easy change.
10:21:02 <holmak> ehamberg: No problem
10:21:11 <jfoutz> ehamberg: have fun :)
10:21:36 <osfameron> lilac: ok, I'll have a play with that later, thanks
10:22:02 <lilac> ksf: "Sorry, the RTS let a cat play with your threads. They've been terminated, the cat will be dealt with later..."
10:23:02 <FunctorSalad_> ksf: is that actual output?:)
10:23:20 <ksf> that's actual output.
10:23:26 <FunctorSalad_> ksf: maybe look at http://hackage.haskell.org/package/concurrentoutput
10:23:45 <ksf> nah it's definitely a deadlock in my code.
10:27:20 <Philonous> Arr, i hate it. "For the ease of understanding we keep referring to this ten year old paper. It is left as an exercise to the reader to figure out which notation comes from where"
10:30:07 * ksf has the urgent suspicion that CHP's bind is strict in its first argument.
10:30:13 <SamB_XP> Philippa: they didn't actually say that ...
10:30:17 <SamB_XP> did they?
10:30:18 <SamB_XP> er.
10:30:20 <SamB_XP> Philonous:
10:32:03 * ksf tries to do a font cache in CHP but can't get the interface to the code that queries right.
10:33:14 <Philonous> SamB_XP: Actually, they sort of did.
10:33:31 <thomastc> don't the standard libraries have a function like split :: Eq a => a -> [a] -> [[a]] that splits a list on a given element?
10:33:57 <dolio> No, but that's probably one of the functions in Data.List.Split, which you'll find on hackage.
10:33:58 <Philonous> @type wordsBy -- thomastc
10:33:59 <lambdabot> Not in scope: `wordsBy'
10:34:04 <mauke> thomastc: no
10:34:21 <thomastc> odd
10:34:26 <ksf> heh. I just have to do a Chanout (Chanin Foo, Chanout Bar).
10:34:42 <ksf> I should be able to fake functions calls that way without messing up concurrent acesses.
10:37:08 * osfameron kicks wordpress
10:37:25 <osfameron> I think I need gitblog or whatever it's called
10:37:37 <osfameron> writing a code-blog is such a PITA with wp
10:37:59 <SamB> osfameron: oh, is that a companion to gitit ?
10:38:08 <mmorrow> Philonous: random/ill-defined/seemingly-not-precise notation drives me crazy
10:38:10 <osfameron> gitit?
10:38:19 <osfameron> ooo
10:38:22 <SamB> @hackage gitit
10:38:22 <lambdabot> http://hackage.haskell.org/package/gitit
10:38:22 <dolio> You should get whatever edwardk has. His setup is awesome.
10:38:24 <osfameron> yes, I guess so
10:38:33 <dolio> he can do commutative diagrams and stuff.
10:38:46 <copumpkin> dolio: it's also wordpress
10:38:52 <SamB> dolio: and you're sure he isn't just using a lot of elbow grease ?
10:38:54 <gwern> gitit can do all that!
10:39:00 * gwern wonders what that is
10:39:08 <copumpkin> but wordpress is a piece of crap
10:39:11 <SamB> gwern: what what is ?
10:39:19 <dolio> SamB: I thought the first couple posts were him testing out inline LaTeX including the diagrams.
10:39:20 <gwern> SamB: I don't know
10:39:39 <SamB> dolio: maybe he was using some client-side tool for all that?
10:39:43 <jmillikin> Is there any way to "cast" a parameterized value to various types within a single function? I'm trying to do this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3807
10:39:45 <copumpkin> there is a LaTeX plugin for wordpress
10:39:58 <mmaruseacph2> where?
10:40:04 <Philonous> mmorrow: Yes, even more so when it is essential to the understanding of the paper
10:40:07 <osfameron> because debugging blog posts is fun!
10:41:36 <dolio> SamB: http://sixthform.info/steve/wordpress/?p=28
10:41:36 <gwern> gitit can do latex!
10:41:46 <gwern> why won't everyone use gitit? :(
10:42:07 <thomastc> can it make blogs and photo galleries too?
10:42:13 <gwern> I feel like oleg and delimited continuations
10:42:35 <gwern> thomastc: I don't see why not. we added rss support whic was te real last missing piece
10:42:38 <osfameron> well that's easy.  Nobody uses delimited continuations because they don't understand them :-)
10:43:42 <mmorrow> gwern: because gitit isn't a blog
10:43:56 <gwern> mmorrow: it could be if you just BELIEVE!
10:44:02 <mmorrow> gwern: but it could be, with some haxing
10:44:04 <osfameron> the example page, http://gitit.johnmacfarlane.net/ looks very impressive (as a wiki though)
10:44:13 * shapr boings cheerfully
10:44:37 <SamB> gwern: you need to set up a sample blog, with instructions on how to make one like it
10:44:43 <RyanT5000> has anyone in here taught, or been taught, a university (or university-style) Haskell course?
10:44:47 <mmorrow> gwern: i've actually been meaning to do exactly that for a while now. i'm currently trying to decide if i'm going to mod 0.4.whatever or 0.6.whatever though
10:44:57 <SamB> otherwise, nobody will know *how* to use gitit as a blog
10:45:06 <mmorrow> gwern: may start from 0.4 since it's simpler, but i haven't looked at the code for 0.6 yet
10:45:12 <gwern> mmorrow: erm, why would you mod 0.4 and not work from head?
10:45:24 <gwern> starting from a way obsolete version seems like a real recipe for failure
10:45:26 <thomastc> RyanT5000: me
10:45:37 <RyanT5000> thomastc: cool; taught, or been-taught?
10:45:40 <thomastc> that is, I've been taught one, and could teach it if I had to :)
10:45:46 <mmaruseacph2> RyanT5000: I had a programming paradigms course
10:45:53 <mmaruseacph2> and haskell had a quarter of it
10:46:04 <RyanT5000> where did you guys go to school?
10:46:24 <mmorrow> gwern: because i've already read the 0.4 code, and it's completely contained in a single module, also i really just want a blog, rather than doing this as a general-purpose package to release or something
10:46:26 <pastah> @src (<$)
10:46:26 <lambdabot> (<$) = (<$>) . const
10:46:38 <mmaruseacph2> Romania, Polytechnic University of Bucharest, Automatic Control and Computer Studies
10:46:41 <thomastc> RyanT5000: university of groningen, netherlands
10:46:43 <mmorrow> gwern: but again, i haven't gone through the 0.6 code yet, so i'm not sure
10:47:11 <RyanT5000> thomastc: ah, cool; i've heard that haskell is (slightly) more popular in that area of the world, which is awesome
10:47:49 <mmaruseacph2> RyanT5000: from where are you?
10:48:02 <RyanT5000> mmaruseacph2: i'm in Boston
10:48:12 <mmorrow> gwern: basically what i have in mind is super simple. (1) change the appearance of the front page slightly to be a bloggish-thing, (2) remove the edit tab on all pages, (3) and then individual "wiki pages" will be individual blog posts
10:48:24 <RyanT5000> in the US, almost no schools teach haskell - and if they do, it's under some weird pretense (e.g.: MIT's haskell class is taught as a parallel programming course)
10:48:29 <mmorrow> gwern: and also only i'd be able to edit it
10:48:58 <mmorrow> gwern: hmm, not sure about comments though (as in, how to do them, but it seems like it'd be straightforward somehow)
10:48:59 <Berengal> mmorrow, I'm working on some blogging software right now
10:49:13 <gwern> mmorrow: here's what I would do: write a plugin to parse some special syntax like ````foo````, where what hapenns is the article 'foo' is looked up, the first n characters grabbed, and rendered in a block in the page
10:49:18 <mmorrow> Berengal: ooh, nice. how is it coming?
10:49:20 <Berengal> I discovered haskell was a great html templating language yesterday
10:49:35 <RyanT5000> Berengal: yes! it's surprisingly good
10:49:35 <thomastc> RyanT5000: that's a shame. Maybe Haskell is not for everyone, but functional programming in general is definitely a useful skill.
10:49:39 <gwern> mmorrow: so everytime you wrote a blog post, you'd go 'I just wrote Bar, so now I edit Front Page and at the top at ````Bar````'
10:49:43 <Berengal> mmorrow, 85.200.142.98:5000/blog
10:49:51 <RyanT5000> Berengal: i used Haskell to make all my form contracts for my company
10:49:54 <shapr> RyanT5000: Whoa, iPhones are FUN
10:50:02 <gwern> mmorrow: if manual editing is too much, you could write a little darcs hook to edit the front page on every page add
10:50:09 <gwern> bam, a blog front page
10:50:10 <RyanT5000> shapr: not fun enough! just wait until *i* get through with them :P
10:50:15 <shapr> heh, looking forward to it.
10:50:18 <RyanT5000> lol
10:50:20 <mmaruseacph2> RyanT5000: at my faculty, one two thirds of the students learned it
10:50:22 <RyanT5000> yeah, there's a ton of great stuff
10:50:25 <shapr> Is your iPhone dev setup available? er, for Haskell?
10:50:29 <mmaruseacph2> the other third skipped learning haskell
10:50:32 <RyanT5000> shapr:
10:50:33 <RyanT5000> yep
10:50:35 <shapr> spiffy
10:50:46 <mmorrow> Berengal: sweet! do you plan on making it available in the near future?
10:50:47 <mmaruseacph2> and we weren't taught monads and advanced things
10:50:54 <mmaruseacph2> only some basic stuff
10:50:54 <mmorrow> gwern: hmm, interesting.
10:50:59 <RyanT5000> projects.haskell.org/ghc-iphone/
10:51:06 <shapr> awesome, I'll check it out.
10:51:14 <shapr> I'd guess there's no way to do iphone dev on linux or windows?
10:51:16 <SamB> mmaruseacph2: monads aren't really that advanced -- or all that important ;-P
10:51:17 <Berengal> mmorrow, right now it's not doing too much, but I just got static html-fragment blogs done... except I haven't written any of those to actually serve
10:51:23 <gwern> mmorrow: I tink it's the easiest approachhhh; all you'd ave to maintain is a hook and a plugin
10:51:29 <RyanT5000> shapr: not that i know of; the code signing relies on Apple's keychain stuff
10:51:32 <shapr> Perhaps if I jailbreak...
10:51:39 <RyanT5000> shapr: perhaps
10:51:42 <mmaruseacph2> SamB: maybe, but I needed them at some point in the past
10:51:43 * shapr shrugs
10:51:44 <Berengal> mmorrow, I'll make it available when I feel it's ready for 0.1. It's going surprisingly fast, seeing as I'm working with completely unfamiliar libraries
10:51:48 <RyanT5000> shapr: copumpkin would probably know
10:51:55 <shapr> Good point, as he's one of the experts.
10:51:57 <shapr> copumpkin: d00d
10:52:09 <SamB> mmaruseacph2: I mean, they're just basically programmable semicolons ...
10:52:15 <RyanT5000> mmaruseacph2: well, i think that anything that emphasizes referential transparency is very useful for beginning programmers
10:52:36 <RyanT5000> most beginning programmers are trained to think about *how* they need to solve their problem
10:52:43 <RyanT5000> not *what* the problem is or *what* the solution is
10:52:51 <mmorrow> gwern: ah, ok i see. i need to get familiar with 0.6 to fully grok what you just said i think.
10:52:52 <shapr> TRULY!
10:52:56 <shapr> RyanT5000: right on brother!
10:52:56 <mmaruseacph2> we began with Scheme and then moved to Haskell, afterwards we did a variant of Clips and then we were supposed to learn Prolog but there was no more time
10:53:01 <SamB> yeah, *what* the problem is should certainly be given way more focus
10:53:03 <RyanT5000> it's like if we taught algebra without letting anyone understand what "equals" means, just the set of allowable transformations
10:53:09 <mmorrow> Berengal: sweet. i can't wait :)
10:53:22 <mmaruseacph2> SamB: yup, programmable semicolons but you may need state sometimes to have a better code:)
10:53:27 <SamB> RyanT5000: what does equals mean ?
10:53:30 <gwern> mmaruseacph2: clips?
10:53:37 <mmaruseacph2> I''m amshamed with my code in haskell right now
10:54:10 <Zeiris> ^ yeah, I'm pretty ashamed as well.
10:54:21 <RyanT5000> SamB: i don't feel qualified to answer that competently by this chatroom's standards, but for the purposes of highschool algebra, i think most reasonably smart people have an intuitive grasp of it
10:54:52 <SamB> mmaruseacph2: what I'm saying is, they're just one little mathematical structure ... there isn't really anything deep about 'em, they just happen to be convenient for IO ...
10:55:08 <SamB> RyanT5000: yeah, I guess so ;-)
10:55:09 <RyanT5000> SamB: people aren't taught to think at the level of mathematical structures
10:55:23 <_nickel> unary operators!
10:55:25 <SamB> which is truly a shame
10:55:34 <RyanT5000> SamB: they're taught to assume that there's only one mathematical structure for a given "thing" (task, set, whatever) and then be surprised when that notion breaks down
10:56:06 <SamB> see, that's what I don't like about Haskell's typeclasses ...
10:56:16 <RyanT5000> yeah, me too
10:56:29 <SamB> they assume there is only one instance of a particular mathematical structure over a particular type
10:56:31 <RyanT5000> haskell's relatively guilty of that as well, but i can see how it helps compiler design in a lot of ways
10:56:44 <RyanT5000> it probably also helps people's intuitions :P
10:57:00 <RyanT5000> (which is unfortunate, because those intuitions are probably not innate, but taught, so we should really try to break them down)
10:57:08 <mmaruseacph2> gwern: clips for another programming paradigm (associative one)
10:57:34 * gwern has never heard of associative paradigm
10:57:46 <RyanT5000> so, anyway, back to the haskell courses: i'm looking for a good set of lecture notes
10:58:03 <copumpkin> SamB: that's what I've tried to overcome :P
10:58:16 <copumpkin> (without using newtypes)
10:58:17 <SamB> RyanT5000: take a page from SPJs videos or something ;-)
10:58:18 <SamB> ?
10:58:27 <RyanT5000> because i've got a few people who want to work for me who don't know haskell, and a few who already work for me who do as well
10:58:31 <mmaruseacph2> gwern: http://clipsrules.sourceforge.net/
10:58:37 <RyanT5000> they're mostly CS majors who know the usual imperative stuff - C, Java, etc.
10:58:57 <thomastc> RyanT5000: sorry, can't help you there, unless you can read Dutch that is :)
10:59:12 <ski> (mmaruseacph2 : ECLiPSe ? .. oh)
10:59:13 <RyanT5000> thomastc: ah, that's too bad :P
10:59:21 <thomastc> but maybe a book will work, like Real World Haskell?
10:59:31 <mmaruseacph2> RyanT5000: I don't really have a good set of lecture courses (anyway, they're in Romanian) but there are good tutorials on the net
10:59:33 <RyanT5000> thomastc: although if you have any comments on the good and bad parts of the course, that would be really helpful, too - i want to know what the common mistakes and such are
10:59:46 <mmaruseacph2> ski: no ECLiPSe, see the link
10:59:56 <SamB> RyanT5000: by teachers or students ?
10:59:57 <RyanT5000> yeah, i've looked through most of the tutorials; i was just wondering if anyone had actual lecture experience
11:00:08 <thomastc> RyanT5000: monads and even basic I/O aren't taught at all; people only mess around in the hugs interpreter
11:00:17 <RyanT5000> SamB: well, both; but i was specifically referring to mistakes by teachers, because i'd like to avoid making those mistakes
11:00:31 <SamB> really, IO isn't that important ...
11:00:40 <thomastc> RyanT5000: this made haskell seem like a toy language when I first learned it
11:00:46 <gwern> RyanT5000: every happy family is alike; every unhappy family different
11:00:46 <RyanT5000> yeah, that's a problem
11:01:01 <SamB> I guess you should teach people a little bit though near the beginning
11:01:06 <RyanT5000> i agree that IO isn't important, but monads might be
11:01:27 <thomastc> SamB: if they'd just taken that extra half hour to explain basic do notation and some basic IO functions, things would've started to appear much more useful suddenly
11:01:39 <RyanT5000> of course, i've got the corporate interests to think about, too: our codebase uses Yampa heavily, so we'll want to get into arrows and stuff
11:01:46 <SamB> thomastc: yeah
11:01:55 <SamB> if only so you could pull in data from a file to run your programs over
11:02:01 <thomastc> yes
11:02:11 <RyanT5000> thomastc: yeah, i think do notation is definitely necessary
11:02:11 <mmaruseacph2> thomastc: you have said exactly what I've felt after learning a few more things after classes
11:02:28 <RyanT5000> and since i'm talking to people who want to be game developers, i'm going to need to at least discuss OpenGL
11:02:37 <RyanT5000> and FFI, probably
11:02:51 <SamB> but they don't need to know all the grungy details, just the basics of monadic notation and using library functions to read in data ;-)
11:02:57 <RyanT5000> yeah
11:03:02 <RyanT5000> and i'm never teaching anyone about "fail"
11:03:07 <thomastc> haha :)
11:03:14 <mmaruseacph2> RyanT5000: we wanted last year to develop a game engine in Haskell
11:03:15 <BMeph> RyanT5000: You might try some of the ANU grads around here; they may be able to hook you up with some stuff. :)
11:03:15 <RyanT5000> i mean, talk about a self-describing name...
11:03:42 <SamB> and then how to print the values returned by their pure code
11:03:44 <mmaruseacph2> but because only ddvlad (he left the channel now) knew this language at that time we switched to Python
11:03:50 <RyanT5000> BMeph: ah, cool; that'll probably even be in English
11:03:58 <RyanT5000> BMeph: i bet dons would know where to find people/notes
11:03:58 <SamB> oh, and I guess teaching how to use monadic bind in ghci would be really useful
11:04:26 <RyanT5000> SamB: yeah, definitely; i use that all the time (much more than i use "let" in ghci)
11:04:54 <SamB> yeah, it's really handy for pulling in test data from a file
11:05:35 <RyanT5000> mmaruseacph2: yeah, i'm actually building an iPhone game right now in Haskell; if things go well, we'll have a reasonably general-purpose game engine within a year or two
11:06:05 <RyanT5000> if you're interested in getting involved, you can feel free to shoot me a resume at ryan@ipwnstudios.com
11:06:40 <SamB> RyanT5000: what would you be looking for on such a resume ?
11:06:43 <mmaruseacph2> RyanT5000: good luck with that
11:06:49 <RyanT5000> mmaruseacph2: thanks :)
11:06:52 <gwern> SamB: obviously he's trolling for free interns
11:06:56 <RyanT5000> hahaha
11:07:02 <mmaruseacph2> I'd like to have a link to browse your repo if you'll give me one, please:D
11:07:06 <SamB> oh, I don't do "free intern"
11:07:12 <RyanT5000> gwern: well, you're not quite right
11:07:33 <RyanT5000> we're generally offering percentages
11:07:35 <gwern> RyanT5000: oh, you offer donut benefits as well?
11:07:38 <RyanT5000> so, only free if we fail :P
11:07:40 <SamB> heh
11:07:48 <gwern> maybe I should sign up; I like donuts
11:07:48 <mmaruseacph2> thanks for the offer, I'd think it and I may send you something
11:08:02 <SamB> I don't think I can afford that right now
11:08:17 <RyanT5000> SamB: yeah, i know it's a lot to ask of people
11:08:21 <RyanT5000> we'll be offering salaries as soon as we can possibly do it
11:08:41 <gwern> RyanT5000: really riskyy, since a game is a lot of work and a lottery
11:08:43 <SamB> well, I mean, right now, I have school to do
11:08:55 <gwern> iphone games are even more of a lottery because of the market flux and size
11:09:05 <SamB> hopefully I'll be graduating in may ;-)
11:09:14 <RyanT5000> gwern: yeah, it's definitely a big risk, but i think it's a bit better than a lottery
11:09:15 <mmaruseacph2> I have school too but I usually work after classes on different projects
11:09:28 <RyanT5000> gwern: we've done a lot of market analysis to come up with game genre, length, etc.
11:09:39 <gwern> RyanT5000: what game is it anywa?
11:09:49 <RyanT5000> gwern: it's an action roleplaying game
11:09:56 <pastah> @pl \f xs -> sig (\t -> unSig xs (f t))
11:09:57 <lambdabot> (sig .) . flip ((.) . unSig)
11:09:58 <gwern> so... nethack?
11:10:05 <RyanT5000> no, that's turn-based
11:10:08 <RyanT5000> more like Diablo
11:10:43 <RyanT5000> it's a pretty underserved market on the iphone
11:10:54 <RyanT5000> probably because it takes more effort than the average random puzzle game
11:11:16 <RyanT5000> but Apple's recently ramped up its marketing of the iPhone - and particularly the iPod Touch - as a gaming platform
11:11:18 <gwern> is it really? I had te impression every game segment was covered by this point
11:11:28 <copumpkin> nope
11:11:41 <RyanT5000> gwern: there's one really good RPG, but it's japanese-style - kind of like a Zelda game or such
11:11:50 <tommd> Wahoo! One week till HacPDX!
11:11:51 <RyanT5000> there's also a diablo 2 clone, but it's short and relatively bland
11:12:10 <RyanT5000> (to their credit, they did an amazing job of reproducing the look and feel of D2, though)
11:12:21 <RyanT5000> but other than those two, there's a pretty weak showing
11:12:36 <mmaruseacph2> i always wanted to make a game as an extension of both heroes of might and magic and civilizations
11:12:39 <gwern> RyanT5000: hm... would that be a legally actionably amazing or just amazing? :)
11:12:54 <RyanT5000> gwern: i'll leave that to Activision Blizzard's enormous legal team :P
11:12:57 <mmaruseacph2> yet, until now i haven't decided on all features that i want in it
11:13:59 <RyanT5000> mmaruseacph2: that seems pretty cool - would it be an alternate timeline, like "what would civilizations have been like if we had magic?"?
11:14:15 <pikhq> RyanT5000: Zelda's not a JRPG.
11:14:22 <mmaruseacph2> something like that too
11:14:29 <RyanT5000> pikhq: yeah, i know; i'm playing pretty fast and loose with subgenres here
11:14:33 <mmaruseacph2> also with a difficult type of diplomacy
11:14:42 <mmaruseacph2> and with modifiable terrain
11:14:44 <RyanT5000> pikhq: the point is that Zenonia is on the opposite side of the spectrum from Diablo
11:14:58 <mmaruseacph2> i mean, you can modify almost everything in the game
11:14:58 <RyanT5000> what's the diplomacy like?
11:15:04 <RyanT5000> that's cool
11:15:17 <RyanT5000> have you heard of Hearts of Iron?
11:15:57 <mmaruseacph2> one example would be: there are three players A, B and C, A has a powerful army and almost beat B but needs his support to beat C so A says to B: "I will not attack you if you'd give me this for the next x days"
11:16:11 <mmaruseacph2> B can accept the treaty and break it at any time it wants
11:16:16 <mmaruseacph2> nop, i haven't:(
11:16:19 <RyanT5000> that's cool; and that'll be enforceable?
11:16:31 <pikhq> RyanT5000: ... More like genres. Zelda's not even an RPG.
11:16:37 <RyanT5000> like, will the game engine prevent A from attacking B, provided B keeps up his end of the bargain
11:16:41 <gwern> RyanT5000: if he can break it anytime it's not enforceable
11:16:49 <mmaruseacph2> yes, will be
11:17:07 <RyanT5000> pikhq: yeah; Zenonia's much more RPGish than Zelda, but it has a similar feel to it
11:17:12 <gwern> pikhq: what, how is zelda not a rpg?
11:17:14 <mmaruseacph2> there will be a button to end the agreement but until clicking it it would be enforced
11:17:44 <gwern> so thente argeement is actually just 'as long as you keep giving me stuff I won't attack'
11:17:45 <RyanT5000> mmaruseacph2: that's cool; have you seen the work in haskell on contract combinators?
11:17:47 <ksf> POINTS ARE EVIL!
11:18:11 <RyanT5000> gwern: the setup mmaruseacph2 is talking about sounds like he's required to give notice of breach
11:18:22 <burp> pointfree is full of points
11:18:23 <pikhq> gwern: There's very few properties of RPGs that Zelda has. However, Zelda games have all the properties of an action-adventure game.
11:18:31 <pikhq> (and a rather good one at that...)
11:18:31 <ksf> I just wasted half an hour looking for a bug in my code that was caused by caching the old cache, not the new value.
11:18:35 <mmaruseacph2> RyanT5000: nop, i haven't
11:18:57 <mmaruseacph2> yup, you are required to give notice
11:18:59 <RyanT5000> mmaruseacph2: worth looking at - it's for financial stuff, but it's interesting
11:19:19 <mmaruseacph2> noted, will look at it
11:19:42 <mmaruseacph2> right now i have 60 tabs in firefox - references from the typeclassopedia article that I've read today
11:19:49 <RyanT5000> lol nice
11:19:58 <RyanT5000> that tends to happen when reading about haskell, i've noticed
11:20:07 <burp> and how much RAM does firefox suck? :P
11:20:09 <copumpkin> alright, there's a problem with haskell
11:20:13 <copumpkin> a fundamental one
11:20:19 <brad_larsen> I get a bunch of link errors when trying to use HsJudy, on Ubuntu Hardy  (I have libjudy-dev installed).  Any hints?
11:20:24 <RyanT5000> copumpkin: what's that?
11:21:06 <copumpkin> it's not newfangled enough! where's cloud haskell? haskell 2.0? we need rounded edges on our website, starburts, and a hell of a lot more buzzwords
11:21:20 <gwern> we did get a new 2.0 logo
11:21:20 <copumpkin> oh, and a new JITting VM
11:21:24 <SamB_XP> copumpkin: rounded edges are not that important ;-PP
11:21:28 <SamB_XP> ooh
11:21:30 <mmaruseacph2> not actively oppened: saved as a folder in bookmarks
11:21:32 <SamB_XP> two tongues!
11:21:34 <mmaruseacph2> i'm not that crazy
11:21:34 <mmaruseacph2> :D
11:21:44 <copumpkin> but our JITting VM needs a weird chimera-ish name
11:22:07 <ski> @quote Yoneda
11:22:07 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
11:22:07 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
11:22:14 <copumpkin> like platypuseagle
11:22:42 <copumpkin> manateelazycat!
11:22:43 <copumpkin> oh wait
11:22:57 <ski> (copumpkin : ^)
11:23:26 <copumpkin> :)
11:24:22 <RyanT5000> lol
11:24:25 <thomastc> I think we should also put the word "Beta" prominently on the front page
11:24:28 <Stinger> Yoneda's lemma?
11:24:32 <copumpkin> thomastc: oh yeah
11:24:32 <ski> yes
11:24:46 <copumpkin> but the main priority is moar cloudz
11:25:12 <RyanT5000> copumpkin: like dph?
11:25:29 <copumpkin> RyanT5000: DDPH
11:25:30 <RyanT5000> sorry, distributed haskell
11:25:36 <copumpkin> distributed data parallel haskell :P
11:25:42 <RyanT5000> indeed!
11:25:49 <RyanT5000> i kinda want to build that, actually >.>
11:25:58 <copumpkin> me too
11:26:04 <RyanT5000> i want the following network library:
11:26:10 <RyanT5000> ClientID -> IO a -> IO a
11:26:22 <RyanT5000> executes the given IO action on the given client's machine :P
11:26:22 <copumpkin> yep :)
11:27:11 <RyanT5000> also, maybe the client could be an AJAX webpage, lol
11:27:18 <gwern> so in otehr words you wan mobile ghc
11:27:19 <RyanT5000> i can't decide how serious i am about that
11:27:22 <RyanT5000> yeah, definitely
11:27:24 <gwern> or one of the oter dead ghc forks
11:27:56 <RyanT5000> basically, subject to security constraints, i want to be able to send any haskell value to any other machine
11:28:05 <RyanT5000> there are obviously like a million issues
11:28:15 <RyanT5000> versioning, what the heck i actually mean by "security constraints", etc.
11:28:29 <Alpounet> damn !
11:28:33 <ski>   newIORef foo >>= \ref -> forkOnClient cid (readIORef ref)
11:28:34 <Alpounet> I'm nearly having FTGL working
11:28:36 <Alpounet> not yet though
11:28:36 <gwern> yeah eyeahh, go read te papers
11:29:17 <RyanT5000> ski: yeah: that'll be annoying to implement, and more annoying to optimize, lol
11:29:31 <RyanT5000> ski: but that's one of the things i'd specifically like to have
11:29:52 <mmorrow> gwern: haven't even looked at the 0.6 code yet, but looking at http://gitit.johnmacfarlane.net/List%20of%20Gitit%20Wikis i think i'm going to use 0.6 as a start
11:30:09 <ski> RyanT5000 : it might be interesting to see how Alice (or Oz) handles distribution
11:30:09 <gwern> what caned your mind?
11:30:23 <RyanT5000> ski: do they do that kind of thing? i'll have to read up on them
11:30:30 * gwern wonders why my h key is sticking so much today
11:30:57 <RyanT5000> alright guys, gotta run; thanks for the advice concerning the haskell lectures
11:31:25 <mmorrow> gwern: the sum of the new features, and that 0.4 uses happs rather than happstack (not sure the differences yet)
11:31:33 <gwern> mmorrow: performance
11:31:40 <mmorrow> ah nice
11:31:43 <gwern> for gitit, anywa
11:31:56 <gwern> (also, my y keyyYYYYYY)
11:32:30 <gwern> oh wow http://veco.ca/ really hacked teir css
11:33:09 <ski> @tell RyanT5000 <http://www.ps.uni-sb.de/alice/manual/tour.html#distribution> (as well as components, pickling, packages)
11:33:09 <lambdabot> Consider it noted.
11:33:24 <sleepynate> that's how i like to see it ;)
11:33:37 <sleepynate> all tags.. no BS
11:34:05 <Alpounet> FunctorSalad_, do you ever used FTGL ?
11:34:12 <Alpounet> s/do/have/
11:34:18 <FunctorSalad_> Alpounet: a little
11:34:34 <Alpounet> do you have a minimal (and working) example somewhere ?
11:35:02 <gwern> 'permasail parent be editin' pillageavast! be ye certain? aye / nay reply' <-- loldit
11:35:16 <FunctorSalad_> Alpounet: sorry no, it's buried in currently dysfunctional code
11:35:32 <FunctorSalad_> but doesn't FTGL itself have an example?
11:35:38 <Alpounet> not the haskell version
11:35:46 <Alpounet> or I haven't seen it
11:35:57 <orcus> This may be a stupid question, but ... trying to print an infinite list should produce output, right?
11:36:10 <thomastc> usually, yes
11:36:26 <thomastc> unless computing the first element also takes infinitely long
11:36:40 <thomastc> try printing the head :)
11:36:56 <orcus> strange, why would print $ map f [0..] not produce output then?
11:37:16 <orcus> the head prints fine
11:37:29 <thomastc> print $ map id [0..] prints a lot of numbers here
11:37:34 <thomastc> so it must be your f
11:37:49 <gwern> yeah, fineere too
11:37:52 <thomastc> there's probably some buffering going on too
11:38:05 <thomastc> so it collects n bytes before printing them
11:38:08 <Alpounet> FunctorSalad_, if you know where there is one, don't hesitate :-p
11:38:30 <orcus> ah, that's probably it, any way of turning buffering off?
11:40:23 <thomastc> orcus: try hSetBuffering stdout NoBuffering
11:40:35 <orcus> thanks, will try
11:42:06 <orcus> thanks, works perfectly :)
11:53:01 <gwern> I just had a crazy idea
11:53:22 <gwern> what if we itnerated gitit wit ackage, so every package is a directory
11:53:34 <gwern> people could drop in articles whci are reviews, ow-tos, etc
11:57:14 <byorgey> gwern: I think it's a fantastic idea.  Things like this have been discussed before, I think it just needs someone to do it.
11:57:18 <byorgey> that and the new hackage server.
11:57:42 * gwern notes that dcoutts_ looks noting like I expected
11:57:45 <byorgey> gwern: also, are you typing with your nose today?
11:57:45 <SamB> gwern: I think you need an h key
11:57:56 <gwern> byorgey: I just can't quite figure out the interationnnnnnn
11:58:04 <gwern> SamB: I need a better keyboard period
11:58:05 <SamB> the what ?
11:58:32 <gwern> byorgey: would the ackage page just linkto the gitit directoryYY? or would tere be some srot of transclusion/frames?
11:59:01 <Alpounet> FunctorSalad_, it seems to have problems rendering by text, like if it was too big (font size : 10 10) or not at all when the size is inferior to 4 4
11:59:06 <Alpounet> very weird
11:59:20 <byorgey> Yeah, the design needs serious thought.  But in principle the idea is great.
12:00:17 <FunctorSalad_> Alpounet: IIRC the letters are huge by default, try something like 0.1 :)
12:00:28 <FunctorSalad_> (maybe they're beyond your clipping plane or something)
12:00:33 <Alpounet> oh
12:00:49 <FunctorSalad_> (I mean normal font size, but 0.1 scaling)
12:01:03 <Alpounet> hmm, through FTGL ?
12:01:12 <Alpounet> actually, the text is all I want to render
12:01:17 <Alpounet> wait, I'll paste a minimal code
12:01:21 <SamB> 0.1 scaling ?
12:01:30 <FunctorSalad_> scaling factor
12:02:12 <FunctorSalad_> I think you can just push the appropriate scaling matrix on the opengl stack prior to rendering the font, Alpounet
12:02:24 <FunctorSalad_> (transformation stack)
12:02:53 <FunctorSalad_> (I'm not sure what the alternative (changing the font size) does to the quality)
12:03:45 <gwern> hm a leyboardwith mo cover or leys is interesting
12:04:15 <Alpounet> FunctorSalad_, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9569#a9569
12:04:18 <Alpounet> Am I missing something ?
12:04:27 <Alpounet> The FTGL documentation is not very verbose...
12:05:54 <tommd> @seen dcoutts
12:05:54 <lambdabot> Unknown command, try @list
12:05:59 <tommd> @seen dcoutts_
12:05:59 <lambdabot> Unknown command, try @list
12:06:02 <tommd> what?
12:06:09 <tommd> dcoutts, dcoutts_: ping!
12:06:11 <tommd> @seen
12:06:11 <lambdabot> Unknown command, try @list
12:06:20 <tommd> damn lambdabot!
12:06:25 <tommd> @slap lambdabot
12:06:25 <lambdabot> stop telling me what to do
12:06:29 <Saizan> preflex: seen dcoutts_
12:06:29 <preflex>  dcoutts_ was last seen on #haskell 6 days, 4 hours, 56 minutes and 50 seconds ago, saying: it separates the hard working values from the slakker types
12:06:37 <tommd> preflex: seen dcoutts
12:06:37 <preflex>  dcoutts was last seen on #haskell 4 hours, 22 minutes and 55 seconds ago, saying: and doesn't depend on any C libs
12:06:51 <tommd> preflex: botsnacks
12:08:28 <aavogt> @botsnakes
12:08:28 <lambdabot> Unknown command, try @list
12:08:28 <lunabot>  :o
12:09:38 <Alpounet> FunctorSalad_, any idea / pointer / something ?
12:09:38 <aavogt> I always thought that lb was more lenient about spellings
12:10:25 <byorgey> aavogt: lb will correct commands up to an edit distance of 2.
12:10:29 <gwern>  ok, now my keyboard is rinsed and dried!
12:10:31 <FunctorSalad_> Alpounet: I don't remember exactly how I did this, but as I said, you might want to use a scaling transformation
12:10:37 <gwern> my hs are back1 I'm no longer cockney1
12:10:47 <byorgey> aavogt: so 'botsnake' ought to work
12:10:53 <FunctorSalad_> Alpounet: you could also check the original FTGL docs, since the haskell bindings are a straightforward translation
12:11:00 <Alpounet> yep
12:11:38 <aavogt> @botsnack
12:11:38 <lambdabot> :)
12:11:38 <lunabot>  :o
12:11:53 <aavogt> @botsnak
12:11:53 <lambdabot> :)
12:11:54 <lunabot>  :o
12:12:03 <tommd> @botsmack -- my fav
12:12:03 <lambdabot> :)
12:12:03 <lunabot>  :o
12:12:09 <idnar> haha
12:12:12 <gwern> also, now my keyboard has a nice toasty feeling
12:12:21 <gwern> maybe I should blowdry my keyboards more often
12:12:40 <aavogt> gwern: needs more toast
12:12:59 <byorgey> @remember gwern also, now my keyboard has a nice toasty feeling.  maybe I should blowdry my keyboards more often
12:12:59 <lambdabot> Done.
12:14:33 <shapr> Is there a Haskell web framework that supports openid?
12:14:52 <tommd> Humm, you should work on that at HacPDX ;-)
12:15:16 <gwern> shapr: isn't tghere an openid package?
12:15:27 <shapr> Oh, I didn't think of just checking...
12:15:54 <shapr> cabal install openid # tada!
12:16:03 <gwern> cabal list|g foo is your friend!
12:16:06 <shapr> truly
12:16:16 <shapr> g is your alias for grep/fgrep?
12:17:12 * shapr waits for stuff to build...
12:17:19 <shapr> I could crank up albatross, this would be much faster.
12:18:00 <shapr> Is there already a Drupal clone in Haskell?
12:18:01 <gwern> shapr: oh, yeah
12:18:08 <shapr> ?
12:18:10 <duaneb> so
12:18:16 <duaneb> When will ghc support x86-64?
12:18:16 <shapr> duaneb: Yeah, that's what I said.
12:18:20 <shapr> Er, it doesn't?
12:18:22 <duaneb> heh
12:18:27 <duaneb> umm
12:18:29 <shapr> Works for me...
12:18:35 <duaneb> maybe it does and I am just dysfunctional....
12:18:54 <duaneb> ahh, not for mac os x
12:19:00 <shapr> I'm using ERC Version 5.3 with GNU Emacs 23.1.1 (x86_64-pc-linux-gnu, X toolkit, Xaw3d scroll bars, multi-tty) of 2009-08-03.
12:19:02 <shapr> Oh, I see
12:19:24 <gwern> (man, this clean keyboard is so much easier to type on)
12:19:31 <dons> duaneb: ?
12:19:32 <duaneb> Here's the problem: I want to do haskell for x86-64, but mac os x doesn't support ghc-x86-64, and freebsd doesn't have 64 bit drivers.
12:19:34 <shapr> gwern: Dude, I want pix.
12:19:42 <dons> oh, mac os x. seee the ticket.
12:19:44 <gwern> of what, my keyboard?
12:19:46 * shapr hugs dons for being so helpful
12:19:55 <dons> there's a team working on it. let's find the link...
12:19:56 <shapr> gwern: Yes!
12:20:03 <gwern> it's a generic little black emachines keyboard, there's nothing to see
12:20:12 <dons> http://www.reddit.com/r/haskell/comments/9krbo/whats_the_status_of_ghc_on_the_64_bit_mac_osx/
12:20:18 <Phyx-> eh... what the... trading in keyboard pics...
12:20:20 <gwern> heck, my trackball is cooler than my keyboard, which is saying something
12:20:34 <duaneb> dons++
12:20:54 <shapr> Bah, I have two kinesis contoured keyboards.
12:21:01 <gwern> see? that's cool
12:21:13 <shapr> And an apple wirless keyboard... in Icelandic.
12:21:19 <dons> interesting package ... http://hackage.haskell.org/package/spata-2009.9.18.1
12:21:22 <dons> look at the synopsis
12:21:33 <shapr> haha
12:21:40 <gwern> spata? wait...
12:21:51 <gwern> oh nm
12:21:54 <shapr> Hey, yesterday was my birthday!
12:21:56 <BMeph> That's Madness!
12:22:10 <gwern> BMeph: yes. yes, I guess it is, actually
12:22:20 <dons> btw, great talk from SPJ on the future of GHC, and all the cool stuff, front of proggit today, http://www.reddit.com/r/programming/
12:22:27 <ziman> shapr, happy birthday then! ;)
12:22:31 <dons> i encourage everyone to watch the talk, if you' weren't in edinburgh
12:22:32 <BMeph> Happy Belated Birthday, shapr!
12:22:50 <shapr> Yay!
12:23:00 * BMeph gives shapr a cupcake-lambda with a candle on top!
12:23:04 <shapr> whee!
12:23:30 <Twey> What's the smallest integer type Haskell has?
12:23:37 <Twey> Woah
12:23:39 <FunctorSalad_> Int8?
12:23:42 <Twey> Happy birthday, shapr ☺
12:23:45 <shapr> yay!
12:23:47 * shapr boings cheerfully
12:23:49 <FunctorSalad_> yeah happy birthday
12:23:55 <Raevel> the b to the day?
12:23:57 <Twey> FunctorSalad_: Is that as small as it goes?  Oh, I guess there's not much point in going smaller.
12:24:10 <shapr> Isn't there a relative date command on the unix command line?
12:24:12 <duaneb> So, I want a bare linux distro
12:24:19 <shapr> duaneb: Linux From Scratch?
12:24:19 <duaneb> with just enough to support haskell and opengl
12:24:21 <shapr> oh
12:24:22 <duaneb> for 64 bit
12:24:29 <duaneb> no, I'm not a masochist.
12:24:38 <Twey> Define ‘bare’
12:24:44 <duaneb> Twey: not bloated
12:24:53 <BMeph> Heh-heh, from the Edingburgh Evening News, "Third place is the target for Dons
12:24:53 <BMeph> "
12:24:55 <duaneb> I'm thinking gentoo, but minus compile times
12:24:56 <shapr> He means he wants to use Mac OSX and *BSD, and only use Linux for x86-64 Haskell.
12:25:02 <gwern> Twey: our smallest int value is (), or '1'
12:25:11 <FunctorSalad_> hehehe
12:25:14 <FunctorSalad_> Int0
12:25:33 <Twey> duaneb: Sounds like you want ArchLinux.
12:25:34 <gwern> if that's too small, we also have Bool, which is 0 or 1
12:25:36 <FunctorSalad_> but it still contains undefined
12:25:42 <duaneb> Perhaps I do....
12:25:46 <byorgey> type Int1 = Bool
12:25:50 <FunctorSalad_> @let undeified = undefined
12:25:51 <lambdabot>  Defined.
12:25:53 <Twey> Minimal (in the Gentoo sense) binary distro with the best Haskell support around, AFAIK.
12:26:00 <shapr> #haskell's birthday is April 30th
12:26:05 <Twey> There's a 64-bit version — I'm running it.
12:26:15 <Twey> gwern: () is not an integer value, though :þ
12:26:31 <byorgey> type Int2 = Bool -> Bool
12:26:38 <Twey> Haha
12:26:49 <osfameron> Twey: thorn is a rather unusual tongue-pulling smiley... works well though!
12:27:00 <duaneb> cool
12:27:01 <ski>   type Int0 = ()
12:27:09 <ski>   type IntNegInf = Void
12:27:12 <Twey> osfameron: I got tired of sticking my tongue of of the corner of my mouth!
12:27:34 <osfameron> Twey: even alternating with p and b? ;-)
12:27:47 <Twey> Hahaha
12:28:04 <Twey> But with those my mouth is all lop-sided!
12:28:09 <ski> (gwern : well, wouldn't `()' be `0' ?)
12:29:14 <gwern> ski: I think () is something rather than nothing
12:29:24 <ray> \o
12:29:28 <ray> =o
12:29:43 <BMeph> -o
12:30:06 <ray> the great () debate
12:30:58 <ski> hm .. `Int8' has `-128' to `127', `Int4' has `-8' to `-7', `Int2' has `-2' to `1', `Int1' has `-1' to `0', `Int0' has ?
12:31:19 <ray> 2^0
12:31:22 <ray> duh
12:31:43 <ski> (gwern : sure.. but `0' is also something :)
12:31:46 <ray> which is 1, which means it only coitnains 0
12:31:51 <ray> contains dshogadighaopdhg
12:32:11 <gwern> ski: 0 isn't something, by definition!
12:32:23 <ski> which definition ?
12:32:28 <ray> tell that to xkcd jerk :(
12:32:44 <sleepynate> xkcd: 0 isn't something, by definition!
12:32:45 <ski> "`0' is the class of all sets with zero elements" ?
12:33:09 <ksf> there's just one thing missing from chp: session types.
12:33:21 <ski> or maybe "`0' is an (arbitrary) set with zero elements" ?
12:34:44 <ksf> gwern, 0 is /= _|_ by definition!
12:34:46 <ray> that actually fits, because the xkcd volume 0 book is a set with zero humour
12:35:09 <ksf> and () is the tuple which doesn't contain any argument, by definition.
12:35:22 <ksf> err value.
12:35:38 <ksf> you have to have a witness for the fact that you have nothing!
12:36:31 * ski invokes Frege
12:38:34 <ksf> for if you don't know that you know nothing, you know less than if you don't know that you know nothing
12:38:34 <ksf> s/don't/do/the-second-one
12:43:52 <byorgey> let S be the set of all sets which know that they know nothing.  Is S an element of itself?
12:44:30 <copumpkin> :O
12:44:45 <copumpkin> a wise russell
12:45:02 <ksf> it's a wonderful koan
12:47:48 <BMeph> I thought that was Socrates? ;)
12:51:02 <ksf> no. socrates said that he knows when he doesn't know.
12:51:35 * idnar promptly vanishes
12:51:46 <ksf> that is, he was aware of him not knowing some particular thing, and said it was his only wisdom.
12:56:01 <ksf> gosh IxSet is beautiful
12:59:00 <coco> Is there a version of Data.Set where the same element can be several times in the "set"?
12:59:17 <burp> then it's not a set anymore ;)
12:59:17 <copumpkin> Data.Map Int
12:59:18 <Zao> Set [t] ?
12:59:19 <ksf> it's called a bag.
12:59:28 <coco> ok, are there bags?
12:59:32 <ksf> ...and usually represented as a list.
12:59:38 <copumpkin> type MultiSet a = Data.Map a Int
13:00:07 <copumpkin> or Data.Map a Natural
13:00:28 <dolio> e^a
13:00:30 <coco> copumpkin: I want to find a minimal element quickly
13:00:48 <coco> also, the "equal" elements are not really equal, just according to Ord
13:01:00 <tommd> head . sort
13:01:01 <copumpkin> coco: :o
13:01:07 <ksf> minimal as in lowest number of entries or as in lowest ord?
13:01:22 <coco> lowest ord
13:01:36 <copumpkin> then the Data.Map works
13:01:42 <dolio> @hoogle minView
13:01:42 <lambdabot> Data.IntMap minView :: IntMap a -> Maybe (a, IntMap a)
13:01:43 <lambdabot> Data.IntSet minView :: IntSet -> Maybe (Int, IntSet)
13:01:43 <lambdabot> Data.Map minView :: Map k a -> Maybe (a, Map k a)
13:02:05 <coco> hmmm
13:02:10 <Heffalump> hi conal
13:02:16 <coco> but they're not identical, just equal
13:02:26 <copumpkin> what's the distinction?
13:02:37 <ksf> haskell has no sense of "identity"
13:02:43 <ksf> equality is always by definition
13:02:48 <dolio> @hoogle minViewWithKey
13:02:48 <lambdabot> Data.IntMap minViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)
13:02:48 <lambdabot> Data.Map minViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
13:02:53 <ksf> (well, sharing uses identity, but that's behind-the-curtain)
13:02:55 <dolio> How nice.
13:03:05 <M_o_C> [21:43:47] <byorgey> let S be the set of all sets which know that they know nothing. Is S an element of itself? # Could someone explain that to me?
13:03:11 <coco> my implementation of Eq is an equivalence relation, but not the one of lowest granularity
13:03:45 <coco> let's say we deal with Strings and look only at the firs Char
13:03:46 <copumpkin> M_o_C: it's evoking russell's paradox, but mixing it with ancient wisdom
13:04:01 <coco> adding "Alice" and "Amandine"...
13:04:07 <coco> won't it end up with "Alice" twice?
13:04:09 <ksf> and you want to be able to extract all those strings out of your bag?
13:04:18 <ksf> yep.
13:04:22 <coco> ksf: yes, what goes in must come out
13:04:27 <ksf> 'cos that's what a bag does.
13:04:35 <coco> yes, where are the bags?
13:04:59 <coco> I mean, is there an implementation?
13:05:13 <ksf> not that I know of.
13:05:14 <copumpkin> Data.Map a [a]
13:05:18 <ksf> it's sufficiontly simple.
13:05:58 <BMeph> I'd like to see a tree -> list -> bag -> set -aware datastructure. Modulo "aware", of course. :)
13:06:17 <ksf> ah, there's Data.Edison.
13:06:19 <coco> copumpkin: can you explain 'Data.Map a [a]'?
13:07:00 <BMeph> 'ap insert head'? :)
13:07:00 <burp> hm, how could I try to execute an action until it succeeds and throws no more exception?
13:07:13 <ksf> > Data.Map.fromList [('A', "lice"), ('A',"damadine")]
13:07:14 <lambdabot>   Not in scope: `Data.Map.fromList'
13:07:19 <ksf> > Map.fromList [('A', "lice"), ('A',"damadine")]
13:07:20 <lambdabot>   Not in scope: `Map.fromList'
13:07:22 <burp> I thought about something with forever.. but that will not abort when no exception is thrown
13:07:24 <ksf> > fromList [('A', "lice"), ('A',"damadine")]
13:07:25 <lambdabot>   Not in scope: `fromList'
13:07:28 <ksf> grrr
13:07:33 <copumpkin> > M.fromList [('A', "lice"), ('A',"damadine")]
13:07:34 <lambdabot>   fromList [('A',"damadine")]
13:07:45 <copumpkin> > M.fromListWith (++) . map (second pure) $ [('A', "lice"), ('A',"damadine")]
13:07:46 <lambdabot>   fromList [('A',["damadine","lice"])]
13:07:47 <ksf> d'oh.
13:07:48 <burp> hm, maybe something recursive.. yes
13:08:18 <copumpkin> coco: make sense?
13:10:09 <coco> copumpkin: for the example yes, but it's actually not a list
13:10:23 <copumpkin> well yeah
13:10:28 <coco> what if we do arithmetic modulo 10?
13:10:39 <coco> 26 = 36
13:11:09 <ksf> there's only 0..9, then, no 26 or 36, ever.
13:11:20 <copumpkin> 26 === 36 (mod 10)
13:12:17 <coco> well, 26 and 36 should go into (and come out of) the bag
13:12:18 <copumpkin> coco: I can't really define an Eq and Ord instance here
13:12:25 <copumpkin> coco: just a sec
13:12:30 <coco> ok
13:17:02 <coco> ksf: Data.Edison is confusing, it seems to provide interfaces only, no implementations...
13:17:27 <roconnor> coco: there are two packages
13:17:32 <roconnor> implemenation and interfaces
13:18:10 <roconnor> so libs only need to depend on the interfaces
13:18:13 <roconnor> some libs ..
13:18:58 <coco> roconnor: thanks
13:19:24 <copumpkin> coco: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=9576#a9576
13:19:38 <copumpkin> coco: *Main> fromList [Mod10 26, Mod10 36]
13:19:38 <copumpkin> fromList [(Mod10 26,[Mod10 26,Mod10 36])]
13:20:34 <copumpkin> also,
13:20:35 <copumpkin> *Main> fromList . map Mod10 $ [1..20]
13:20:35 <copumpkin> fromList [(Mod10 10,[Mod10 10,Mod10 20]),(Mod10 1,[Mod10 1,Mod10 11]),(Mod10 2,[Mod10 2,Mod10 12]),(Mod10 3,[Mod10 3,Mod10 13]),(Mod10 4,[Mod10 4,Mod10 14]),(Mod10 5,[Mod10 5,Mod10 15]),(Mod10 6,[Mod10 6,Mod10 16]),(Mod10 7,[Mod10 7,Mod10 17]),(Mod10 8,[Mod10 8,Mod10 18]),(Mod10 9,[Mod10 9,Mod10 19])]
13:22:26 <coco> copumpkin: nice!
13:22:36 <coco> however, how can I find the minimal element now?
13:22:42 <coco> oh
13:23:15 <coco> seems to work
13:23:18 <coco> thanks
13:24:34 <koninkje> Does anyone have a good website on math/code for dealing with modular floating point (e.g. mod 360 for degrees)
13:25:26 <roconnor> koninkje: I strongly recommend using unit complex numbers for dealing with angles.
13:25:46 <coco> can some of those who know Okasakis' papers better hint me at what structure to use for bags? (http://hackage.haskell.org/package/EdisonCore)
13:26:33 <defun> I seems many people find the list notation [1,2,3] more appealing than the 'original' notation 1:2:3:[]. Is it considered bad style in haskell to use the second one over the first one?
13:26:57 <Twey> Well, there's no commandment against it.
13:27:10 <Twey> I think most people would consider the former neater, though.
13:27:11 <koninkje> roconnor: the units come to me as Double, but I can always fix that. Any pointers for the relevant complex algorithms?
13:27:25 <defun> How would one do [1..] is the latter?
13:27:32 <koninkje> > enumFrom 1
13:27:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:27:33 <defun> *in the latter
13:27:37 <roconnor> koninkje: what complex algorithms?
13:27:43 <copumpkin> defun: you wouldn't
13:28:07 <defun> :t enumFrom
13:28:08 <lambdabot> forall a. (Enum a) => a -> [a]
13:28:24 <defun> enumFrom 'a'
13:28:27 <defun> > enumFrom 'a'
13:28:28 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
13:28:52 <koninkje> roconnor: just common things with angles. I already have a function for determining whether it's quicker to turn left or right to acquire a goal angle. Stuff like that
13:28:54 <ski> @type \x -> [x..]
13:28:55 <lambdabot> forall t. (Enum t) => t -> [t]
13:29:03 <roconnor> defun: I personally consider it bad style to use the second one over the first, although I find it plausible there are situation where the second is better.
13:29:09 * koninkje hasn't played with complex numbers much
13:29:15 <defun> i see.
13:29:29 <roconnor> koninkje: to "add angle" you multiply the unit complex numbers
13:29:30 <defun> thanks, all.
13:29:58 <dancor> ppl use e.g. 1:2:3:rest a lot for pattern matching
13:30:28 <roconnor> koninkje: to scale a an angle by a scaling factor alpha, raise the unit complex number to the exponent alpha.
13:31:01 <Twey> koninkje: They're just like tuples.
13:31:09 <Twey> Or… not.
13:31:45 <koninkje> Twey: I know that much. Just haven't messed with them to know why they make angles easier
13:32:03 <koninkje> roconnor: cool thanks. That should give me enough to go on for a while
13:32:16 <roconnor> koninkje: to convert a unit complex number back to radians, take the logorithm and then the imaginary part of that (the real part should be 0 or close to 0).
13:32:18 <Twey> koninkje: Because it allows you to express a diagonal vector in terms of a pair of perpendicular directions
13:32:23 <copumpkin> or use quaternions!
13:32:28 <copumpkin> (for 3d)
13:32:35 <monadic_kid> is there away to specify calling conventions with c2hs?
13:32:48 <Twey> (or more, for more dimensions, of course)
13:33:01 <burp> http://paste.railsbox.eu/show/vD3oGEhBcB7cSjM7gOpU/ <- "cannot construct the infinite type" .. when does this error usually occur? (this is code with takusen database api)
13:33:34 <koninkje> burp: in general it tends to happen when there's a missing newtype wrapper/unwrapper
13:33:38 <roconnor> koninkje: and to convert from radians to a unit complex number, compute exp(0 :+ theta).
13:33:44 <koninkje> don't know about takusen particularly though
13:33:50 <burp> ok
13:34:16 <roconnor> koninkje: and naturally make your own abstract data type to wrap up all these operations. ... this goes without saying
13:34:27 <koninkje> oh of course
13:34:40 <roconnor> I only bring it up because apparently some people on reddit don't know anything about data abstraction.
13:35:11 <newsham> roconnor: i think you're being way too specific (and generous)
13:35:18 <roconnor> heh, not that I make my own ADT when writing ICFP contest code. ...
13:35:21 <koninkje> This is, alas, actually for some Java code. But then these robots don't have GHC yet
13:35:26 <Saizan> burp: it seems you're trying to use the first field of a tuple as the whole tuple somewhere
13:36:23 <roconnor> koninkje: to take the sine of your angle, take the real part of the unit complex number
13:36:27 <roconnor> ero
13:36:33 <roconnor> koninkje: to take the *cosine* of your angle, take the real part of the unit complex number
13:36:50 <roconnor> koninkje: to take the sine of your angle, take the imaginary part of the unit complex number.
13:36:53 <Saizan> burp: what's the type of withContinuedSession ?
13:37:08 <burp> Saizan: withContinuedSession :: (Typeable a, ISession sess) => ConnectA sess -> (forall mark. DBM mark sess a) -> IO (a, ConnectA sess)
13:37:10 <roconnor> koninkje: I think you are pretty much set with those operations.
13:37:21 <koninkje> roconnor++
13:37:34 <newsham> arent you going to implement your complex numbers in terms of sin and cos anyway?
13:37:38 <newsham> sounds like begging the question
13:38:00 <roconnor> newsham: I was implement them in terms of Haskell's Complex type.
13:38:03 <burp> and catchDB :: CaughtMonadIO m => m a -> (DBException -> m a) -> m a
13:38:07 <Saizan> burp: yeah, so the result type of tryForever should be "IO (a, ConnectA sess)" instead of "IO a"
13:38:09 <roconnor> though perahps koninkje isn't using Haskell.
13:38:17 <burp> oh, of course
13:38:42 <conal> Heffalump: hi.  (just noticed.)
13:39:51 <newsham> roconnor: but you're starting with an angle, no?  so basically you're just burying the sin and cos and calling them real and imaginary instead
13:40:02 <newsham> if I'm understanding what you're saying (which I might not be)
13:40:13 <copumpkin> lol, reddit turned pirate
13:40:19 * copumpkin be commentin'
13:40:20 <roconnor> newsham: well, I convert to unit complex numbers via exp (0 :+ theta)
13:40:30 <roconnor> newsham: I pretend that I don't know that that calls sin and cos
13:40:31 <koninkje> newsham: starting from a double[0..360) and getting annoyed at dealing with the roll over
13:40:33 <roconnor> abstraction.
13:41:18 <newsham> kon: right.  so basically what roconnor is indirectly recommending is that you take the sin of the angle and then untake the sin of the angle and get back an angle in some fixed range of one revolution
13:41:32 <FunctorSalad_> complex exp can be defined without reference to sin and cos
13:41:35 <FunctorSalad_> (and it's simpler)
13:41:39 <roconnor> newsham: it's more complex than that.  the cosine part is important too.
13:41:51 <FunctorSalad_> sin and cos are just taking the real/complex parts of that series...
13:41:59 <copumpkin> it's just a very simple abstraction
13:42:19 <koninkje> makes sense now
13:42:27 <burp> Saizan: thanks, works now as expected :D
13:42:33 <newsham> btw, do you really have a need to deal with the rollover?  are your angles getting unusually large and losing precision?
13:42:46 <newsham> often you can just silently ignore the rollover
13:42:58 <roconnor> newsham: if you only consider the sine, then you cannot tell obtuse angles from acute angles.
13:43:41 <koninkje> It's more that issues show up when doing things like acquiring an angle within a cone, when that cone covers the wraparound
13:43:46 <roconnor> newsham: I often want to subtract angles, and know if something is to the left or to the right of me.
13:44:02 <roconnor> newsham: you cannot ignore rollorver to do that
13:44:16 <roconnor> koninkje: oh, and to subtract angles you divide the unit complex numbers.
13:44:35 <roconnor> koninkje: the negative of an angle is the complex reciprocal.
13:44:37 <newsham> roconnor: sure you can :)  take the cos :)
13:44:43 <koninkje> newsham: as roconnor says. This is for a robotics task, so the angles are what the device gives and the left-vs-right matters
13:45:09 <roconnor> newsham: you mean the sin, but ya, ... I thought I had some compelling reason.
13:45:14 <newsham> yah the sin,oops
13:45:26 <roconnor> now I wonder what it was
13:45:58 <lilac> if the number of 'turns' matter, then you lose information with the complex representation
13:46:18 <newsham> q: can you efficiently take complex exp with fpu?
13:46:26 <roconnor> lilac: sure, in that case you want to use the convering space, aka the real line.
13:47:14 <lilac> roconnor: right. was that your compelling reason?
13:49:10 <newsham> huh, kernel module written in haskell.  sounds kinda scary but possibly cool
13:49:55 <ksf> coco, edison is split into an interface and a implementation package.
13:50:04 <monadic_kid> so c2hs doesn't automatically deduce calling conventions :/
13:50:14 <roconnor> lilac: maybe if I look at my contest code I'll remember
13:51:47 <roconnor> heh, this is cute
13:51:49 <roconnor> main = Hohmann.main >> Ellipse.main >> ClearSkies.main
13:53:57 <newsham> too bad you cant mapM .main [Hohmann, Ellipse, Clearskies]
13:54:03 <newsham> mapM_
13:54:36 <newsham> for all my wonder at what haskell lets you do, I often find syntactic things like that that feel like you should be able to abstract that you cant
13:54:49 <tommd> Gahh!!! hsc2hs generates a 'C' program which generates a .hs haskell file!  Bad!  Bad!
13:55:00 <mauke> s/Bad/Cool/
13:55:05 <ray> newsham: yeah
13:55:20 <tommd> No - not cool.  Useless for kernel modules in Haskell!
13:55:32 <mauke> why?
13:55:46 <lilac> newsham: i have a feeling that there's something common between modules and records which would allow that
13:55:52 <tommd> Kernel headers need the -nostdinc flag for many reasons, but the hsc2hs generated .c needs the standard includes to compile.
13:55:56 <tommd> Terrible conflict.
13:56:02 <mauke> ah, I see
13:56:50 <tommd> How does c2hs work?  Could/would someone give me a two sentence run-down?
13:57:11 <tommd> I didn't like it before, but it might be the only sane path (short of writting the FFI all manually)
13:57:23 <koninkje> lilac: yeah, if you look at ML's module system or OCaml's objects you'll see some crossover like that
13:58:00 <newsham> you could always write your own ffi generator :)
13:58:29 <tommd> newsham: Well, the idea is to reuse as much work as I can... and have a tool chain that other can learn or already know.
13:58:35 <tommd> And that's already hard enough with this task.
13:58:43 <newsham> :(
13:58:53 <monadic_kid> tommd: I'm using c2hs righ t now
13:59:25 <tommd> Does it operate much the same as chs2hs?  By making a c program that generates .hs?
13:59:37 <tommd> err, hsc2hs
14:01:13 <monadic_kid> tommd: you define .chs with preprocessor includes, it outputs a .hs with foreign imports and creates wrapper functions (which you define types and marhsalling in .chs file)
14:01:47 <ksf> why do people put packages on hackage that spew out megabytes of warnings?
14:01:54 <roconnor> bah, where are all the monad functions for combining distributions in this new stats library.
14:02:16 <ksf> if your code happens to have no type sigs or defines unused stuff, don't bleeding enable the warnings...
14:02:17 <roconnor> or even non-monad functions for combining distributions
14:02:26 <SamB> @src maybe
14:02:27 <lambdabot> maybe n _ Nothing  = n
14:02:27 <lambdabot> maybe _ f (Just x) = f x
14:02:38 <SamB> :t maybe
14:02:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:02:55 <roconnor> ksf: hackage is probably slowly turning into a cesspool :)
14:03:36 <newsham> hopefully the crop has some cream to be skimmed
14:03:53 <roconnor> hopefully :)
14:03:58 <roconnor> that would make it all worthwhile
14:04:42 <roconnor> we need to google rank the packages somehow
14:05:05 <SamB> why does hackage not have a blam system ?
14:05:08 <roconnor> put a little bar next to each showing it's ranking.
14:05:12 <Berengal> cabal build doesn't rebuild stuff that doesn't need to be rebuilt, which doesn't issue warnings for it...
14:05:13 <SamB> like newgrounds ;-P
14:05:26 <roconnor> what is a blam system?
14:05:56 <SamB> well, things with low enough average ratings out of a high enough number of ratings are removed
14:06:04 <dcoutts> SamB: because nobody has implemented it yet? Have you got some spare time? :-)
14:06:18 <Berengal> .oO(cabal vote foo 4 -badDocs -niceAPI)
14:06:34 <SamB> newgrounds ratings are actually on a scale of 0-5, I think
14:06:35 <roconnor> actually, what are the conditions needed for a google-ranking system to give a unique rank to each package (in a connected component).
14:06:35 * dcoutts can give pointers for where to implement it in the new server
14:06:46 <CESSMASTER> SamB: what if well-rated packages depend on it?
14:07:07 <SamB> well, maybe I'm kidding about actually deleting them
14:07:17 <SamB> but they could be hidden from the usual view?
14:07:18 <Berengal> Does cabal have a concept of a "user" yet?
14:07:31 <dcoutts> Berengal: in what sense?
14:07:51 <dcoutts> Berengal: you mean Cabal and not hackage?
14:07:55 <SamB> now, submitters don't actually lose anything for getting their animations blammed on newgrounds, that I know of
14:07:57 <Berengal> dcoutts, in the .cabal/user sense
14:08:11 <dcoutts> Berengal: sorry, I don't actually know what you're asking.
14:08:15 <SamB> hopefully, they even get to keep any feedback that a was left for them ...
14:08:16 <Berengal> And I mean Cabal, not hackage
14:08:17 <mmorrow> coco: i'd just use (Map a (Set b))
14:08:32 <Berengal> They would be coupled though
14:08:32 <roconnor> the nice thing about a google ranking algorithm is that we can almost implement it right now.
14:08:48 <mmorrow> coco: unionBag = M.unionWith S.union; intersectBag = M.intersectionWith S.intersection
14:08:50 <mmorrow> etc
14:08:54 <Berengal> I just want a cabal vote app :P
14:09:09 <dcoutts> Berengal: what does/would it mean for cabal to have a concept of user?
14:10:15 <Berengal> dcoutts, mainly just to not have to specify a user each time you use cabal to upload stuff.
14:10:29 <gjl> when programming in Haskell, is a chiefly 'bottom-up' approach favoured over a predominatly 'top-down' approach
14:10:34 <gjl> ?
14:10:48 <Berengal> Which right now doesn't do too much, but in the future there could be build-reports and package votes
14:11:47 <wdonnelly> gjl: depends on your definitions of "top" and "bottom"
14:11:55 <wdonnelly> I tend to start with datatypes
14:12:00 <medfly> I think that someone should insert a joke here
14:12:09 <wdonnelly> but it's debatable whether those are the top or the bottom of the program's structure
14:12:19 <Berengal> gjl, I switch between both of them all the time. I find that top-down is the best way to design, but it's hard to actually get stuff done because the entire foundation is mission. Bottom-up is the opposite
14:12:32 <Berengal> s/mission/missing/
14:13:59 <roconnor> oh crap, google's page rank system won't really work for cabal because the dependency form a tree, not a graph.
14:16:28 <wdonnelly> for hackage, it should be a sort of "pyramid-scheme" ranking system, IMO
14:16:44 <wdonnelly> where each package gets a portion of the ranking points of packages that depend on it
14:17:17 <gjl> i imagine it's easier to do things bottom-up with haskell than with C because of functions and the like?
14:17:24 <roconnor> wdonnelly: it seems a bit odd to rank an application good just because it uses awesome libs.
14:17:31 <wdonnelly> no, other way around
14:17:44 <wdonnelly> awesome applications depend on the library, so the library gets ranked up
14:17:54 <roconnor> wdonnelly: oh, ya I agree with that
14:18:01 <roconnor> but that leaves applications as unranked.
14:18:32 <wdonnelly> true, but there isn't any meaningful ranking data for them in the dependency structure anyway
14:18:41 <roconnor> right,
14:18:47 <wdonnelly> so the whole idea basically relies on some external rankings the augment it
14:18:59 <wdonnelly> whether by a 'cabal vote' system, or just a download count
14:19:01 <mmorrow> i find it odd that happstack.com is running on Apache
14:19:01 <|Steve|> gjl: Example?
14:19:13 <roconnor> well, even if we did something like giving each application 1 point, the good libraries should bubble up.
14:19:26 <roconnor> that would be useful.
14:20:03 <Berengal> That'd just be a popularity-scheme
14:20:08 <roconnor> Maybe simply listing the number of packages that depend on it would be useful.
14:20:13 <Berengal> Which is already sort-of tracked in the download counts
14:20:52 <nothingmuch> it seems to me like applying CPS transformations to recursive descent parsers can be usefu
14:21:02 <nothingmuch> e.g. when the transformation produces more than a continuation
14:21:06 <nothingmuch> (bundled context info)
14:21:09 <nothingmuch> and when parsing ambiguous grammars
14:21:18 <nothingmuch> does anybody know of any precedence?
14:21:25 <nothingmuch> i really doubt this is a novel concept
14:21:53 * Berengal just finished markdown support for his program
14:22:24 <Berengal> pandoc is awesome
14:25:11 <opqdonut> it is
14:25:29 <gjl> |Steve|, I'm talking on an abstract, theoretical level. Haskells functions are more generalisable than Cs.
14:27:08 <thebloggu> i already know some haskell and i would like to make some simple gui applications without much effort. what toolkit should i study? i would like it to be cross-platform with native look if its possible
14:27:09 <|Steve|> gjl: I'm not sure what it means for one language to abstractly, theoretically make something easier. Do you have a concrete example?
14:27:46 <|Steve|> In particular, what is something concrete that makes bottom-up design easier in Haskell?
14:27:56 <BMeph> gjl: Actually, I'd say it's easier to do things top-down than in C - Haskell's immensely more modular, so abstracting out common sub-expressions doesn't feel like you're doing anything important. :)
14:28:45 <dm2`> Can someone on here answer a question about Rank2Types?  Getting confused by them.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9580
14:29:53 <FunctorSalad_> dm2`: it's the DMR
14:30:00 <FunctorSalad_> (Dreaded Monomorphism Restriction)
14:30:16 <dm2`> But usually if you declare the type of your function, there is no DMR.
14:30:43 <FunctorSalad_> I thought that too but I don't know what else it should be :(
14:30:53 <dm2`> I guess I understand DMR somewhat in the absence of Rank2 types...
14:31:03 <Berengal> What's the error?
14:31:05 <FunctorSalad_> does it work with NoMonomorphismRestriction?
14:31:19 <dm2`>     Couldn't match expected type `forall a. a -> a'
14:31:19 <dm2`>            against inferred type `a -> b'
14:31:19 <dm2`>     In the expression: fmap
14:31:19 <dm2`>     In the definition of `test2': test2 = fmap
14:31:22 <dm2`> Failed, modules loaded: none.
14:31:58 <Berengal> Ah, that's something different, but I'm not sure I can explain it...
14:32:24 <dm2`> {-# OPTIONS_GHC -XNoMonomorphismRestriction #-}
14:32:24 <dm2`> does not fix the problem.
14:32:42 <FunctorSalad_> I stand corrected
14:33:17 <Berengal> fmap doesn't take in a rank-2-function, so in a way the type signature for the second function is wrong
14:33:45 <Berengal> In the first function you're binding it to a variable with a type that's different, but unifiable with fmap's first argument
14:34:08 <Berengal> In the second function, you're saying that fmap's first argument is something it's not
14:34:14 <BMeph> The problem is that `forall a. a -> a' is a dif't type than `a -> b', specifically, it's "smaller". Modulo yadda-yadda. :)
14:34:20 <dm2`> I see, so my type is too restrictive.
14:34:51 <dm2`> I can promote a (forall a. a -> a) to some other type, but I can't declare something of the other type to be (forall a. a -> a)?
14:35:22 <dm2`> This actually is starting to make sense to me.  Thanks!
14:35:28 <FunctorSalad_> BMeph: but why does eta-expanding change anything?
14:36:01 <BMeph> dm2`: 'length' is of type 'a -> b', but is NOT (forall a. a -> a), not matter how you squeeze the types. :)
14:36:10 <BMeph> *no
14:36:20 <BMeph> *no matter, that is.
14:37:11 <Berengal> In the same way that a can turn into Int, (forall a. a) can turn into a, but not the other way around
14:38:02 <BMeph> FunctorSalad_: What Berengal said. :)
14:39:02 <FunctorSalad_> but as you said, (forall a. a -> a) is smaller than (a -> b)
14:39:05 <Berengal> I wish I knew this a bit better... it feels right, but I don't know why. I needs me some more edumacation...
14:39:38 <dm2`> But you can restrict types in other situations.
14:39:38 <dm2`> f :: (Integral n) => n -> n
14:39:38 <dm2`> f n = n
14:39:38 <dm2`> g :: Int -> Int
14:39:41 <dm2`> g = f
14:39:45 <dm2`>  
14:39:45 <FunctorSalad_> so (a->b) -> FOO is larger than (forall a. a -> a) -> FOO
14:40:12 <Berengal> dm2`, you're not restricting, you're going the other way
14:40:36 <FunctorSalad_> he is restricting because the first arg of (->) is contravariant
14:40:50 <FunctorSalad_> as his first implementation shows, the function is implementable by fmap
14:40:51 <dm2`> Now I'm confused again.  Just as you can from from (forall a. a) -> a, you can go from (Integral n) => n to n, right?
14:41:57 <FunctorSalad_> I still think the riddle is more why eta-expansion makes it work
14:42:04 <Berengal> dm2`, no, you can go from (Integral n) => n to Int (or some other Integral), but not just "n"
14:43:05 <FunctorSalad_> but if A is a specialization of A', then A' -> B is a specialization of A -> B
14:43:25 <BMeph> '(forall a. a -> a)' is more specific than '(forall a b. a -> b)
14:43:27 <lilac> type deduction is not smart enough to resolve the types, is all, i think
14:44:21 <dcoutts> Berengal: sorry, got called away. You know you can already specify your hackage upload username in the ~/.cabal/config file? If you want, you can specify the password too.
14:44:41 <tommd> dcoutts: There hasn't been any efforts on digest auth, right?
14:44:44 <dm2`> lilac: I guess that would explain things.
14:44:56 <Berengal> dcoutts, ah, okay, then cabal /does/ have a concept of a user
14:45:13 <dcoutts> tommd: right, just replied to your email.
14:45:32 <tommd> Oh, I sent that?  Ok ;-)
14:45:33 <dcoutts> Berengal: yes, I just didn't know what you meant by concept of a user
14:46:03 <dcoutts> tommd: that'd be very useful to have
14:46:35 <dcoutts> tommd: we're almost certainly not going to do ssl, and digest is a lot better than basic
14:46:52 <dcoutts> tommd: and I really want to avoid sessions
14:47:01 <tommd> dcoutts: Ok.  I'll grab the rfc and start planning some.
14:47:06 <dcoutts> cool
14:47:38 <dcoutts> tommd: of course once it's done the best place is to get it into happstack, though I'm happy if we have it in the hackage-server directly for a while
14:48:06 <tommd> dcoutts: yes - that is what I was planning.  Creighton might be interested too, I'll ask him and others at the hackathon.
14:48:13 <dcoutts> great
14:52:50 <Alpounet> FunctorSalad_, it worked !
14:52:53 <Alpounet> well, it works :-)
14:55:01 <FunctorSalad_> Alpounet: yay! what was it?
14:55:37 <Alpounet> FunctorSalad_, it was indeed a scaling problem.
14:56:37 <Alpounet> My FTGL texts are actually passwords encrypted somewhere, and my app get them on demand, decrypt them, and show them rotating in an OpenGL/GLUT window...
14:57:56 <Alpounet> But for the moment my encryption is quite ... weak. If I handle to put some RSA or so in there, I think I'll put this app online.
14:58:09 <FunctorSalad_> there are libs on hackage for that
14:58:13 <Alpounet> It'll show people Haskell also fits for "real world" apps
14:58:19 <psal> <-- looking around for a library to render freetype fonts to an image file
14:58:25 <FunctorSalad_> where do you get the decryption key?
15:05:42 <Alpounet> psal, you should be able to do that with SDL, putting your freetype font on a surface and then saving the surface to an image file
15:06:03 <Alpounet> FunctorSalad_, for the moment, the encryption is just a bijective arithmetic function application
15:06:12 <psal> Alpounet, thanks, was starting to look in to that method
15:06:54 <Alpounet> psal, SDL-ttf to draw your text, and IIRC SDL or SDL-image provides and function for saving a surface into an image file
15:07:01 <Alpounet> s/and/a/
15:08:02 <psal> Alpounet, I am also looking in to some other intemediate format and then batch convert to the specific image format I need
15:08:36 <psal> whichever winds up being more fun to implement I suppose
15:23:54 <bos> yay, new haskell PRNG is extra-super-speedy: http://bit.ly/zM3xs
15:26:22 <burp> wow, not bad
15:26:53 <bos> i like being able to measure things in hundreds of millions per second.
15:27:48 <skorpan> am i supposed to get "All operations of the company ESNation A/S have been ceased and all employees including the executive management have been released ultimo February 2009."?
15:30:50 <koninkje> Nice
15:34:33 <SamB_XP_> skorpan: from what?
15:35:04 <skorpan> SamB_XP_: from the PRNG link
15:36:53 <Cale> bos: Hmm... is there an instance of RandomGen for it, or is it unusable with that interface like mersenne-random?
15:37:01 <SamB_XP_> noooo
15:38:11 <bos> Cale: there isn't a RandomGen instance, but the barrier isn't as high as for mersenne-random.
15:38:27 <bos> the thing is, RandomGen is a fundamentally broken, bad interface.
15:38:49 <bos> so i haven't bothered trying to implement it.
15:39:43 <bos> you could build a RandomGen on top of an implementation of MWC256 that used an IntMap for state instead of a mutable array.
15:40:05 <SamB_XP_> bos: what would be a better interface ?
15:40:13 <bos> and it would probably be fun to do. of course, implementing split would be hard.
15:40:36 <bos> SamB_XP_: at the very least, nuke split, and make the interface strict.
15:40:56 <Cale> Which part of RandomGen is broken? Is it the fact that it is designed to generate Int values?
15:41:01 <bos> SamB_XP_: i think that with those changes it wouldn't be so objectionable.
15:41:01 <SamB_XP_> well, there *is* a reason why split is there
15:41:04 <Cale> Oh, you don't like split?
15:41:14 <SamB_XP_> what would you *replace* it with ?
15:41:15 <koninkje> bos: I'd recommend, rather, moving split into a new RandomGen => RansomSplitable
15:41:17 <bos> no. nobody understands split.
15:41:41 <koninkje> new class, I mean
15:41:52 <bos> as an idea, it's appealing, except for the fact that nobody knows what it does to the independence of the numbers you generate.
15:41:57 <Cale> At the very least it is not hard to implement a split which probably is okay, but might have issues if you look closely enough.
15:42:12 <Cale> For non-cryptographic problems, it should be okay, I would think.
15:42:23 <bos> i would be astonished if anyone had ever implemented a split that survived a crush or diehard run.
15:42:26 <heatsink> bos: I think that's an issue with RNG design, not with the RandomGen class.
15:42:43 <Cale> Take your existing generator, and use it to generate two new generator states randomly.
15:42:51 <SamB_XP_> I think it's an issue with the class, but you can't get rid of the issue just by nuking split ...
15:42:56 <bos> well, that RandomGen class shouldn't include interfaces that nobody understands.
15:43:51 <Cale> (and maybe do some constant transformation to those states while you're at it)
15:44:43 <bos> see, if the interface was strict, you could give it a nice optional monadic wrapper and have both a nice programmatic interface and some kind of reasonable hope that it might execute somewhat efficiently.
15:45:22 <Cale> I think it's a shame if nobody has studied the ability to split random number generators. It seems like such an obvious thing to want to do.
15:45:25 <bos> Cale: it's not a problem that the RandomGen interface is designed for Int values.
15:46:38 <SamB_XP_> yeah, you can just glue as many of 'em together as you need to make what you're making ;-)
15:47:10 <bos> Cale: they've been studied by just one person that i know of, pierre l'ecuyer.
15:47:56 <ray> Generator a -> Generator (Generator a)
15:48:00 <ray> it's almost comonadic
15:48:40 <Saizan_> bos: what do you mean by strict interface here? using unboxed tuples for results?
15:48:42 <Cale> Yeah, that's even stronger, and would work well.
15:48:55 <bos> Saizan_: yes
15:49:18 <HugoDaniel> hi
15:49:40 <Cale> bos: Is this PRNG seedable?
15:49:44 <bos> yep.
15:49:56 <heatsink> hello, HugoDaniel.
15:50:06 <Cale> Is there a correlation between generators with adjacent seeds?
15:50:28 <bos> almost certainly.
15:50:37 <ray> you probably want Generator a -> (a, Generator a) though
15:51:29 <ray> i think those two functions should do it
15:51:32 <Cale> How about if I take n and n+1, apply a cryptographic hash to each of them, and then use the hashed values as seeds? ;)
15:51:36 <HugoDaniel> i have a problem ive been trying to work out in haskell, but i dont know how to express it :/
15:52:50 <HugoDaniel> its applying a list of messages to a list of messageInterpreters... but its not a simple map, because each interpreter can change (because interpreters have state), and thus the messageInterpreters list must be updated with its change before handling the next message
15:53:02 <HugoDaniel> is there any way to work it out efficiently in haskell ?
15:53:52 <heatsink> HugoDaniel, does an interpreter change only itself, or can it change other interpreters?
15:54:33 <HugoDaniel> it can change other interpreters, but i cant see any use of it
15:54:59 <Cale> bos: I suppose it's still *possible* that there's a problem, depending on how details of that hash interact with details of the PRNG, but I would somehow expect most combinations of hashes and PRNGs to work, and only very rare coincidences to create problems.
15:55:04 <Philonous> Is there some project that supersedes phooey?
15:55:36 <bos> Cale: you might be right. i'm no student of number theory.
15:55:53 <SamB_XP_> Cale: the thing is, you haven't a clue what you are doing, and neither do we ;-)
15:56:23 <heatsink> HugoDaniel, how would you write the code if you only have one messageInterpreter?
15:56:42 <HugoDaniel> it runs inside a monad
15:56:56 <Cale> SamB_XP_: It would at least be possible to try it and do a benchmark of some sort :)
15:57:04 <ray> for Generator a -> Generator (Generator a), you can just keep the seed, and seed the generators you generate with generated numbers
15:57:13 <SamB_XP_> Cale: you can't replace crytographers with benchmarks!
15:57:22 <ray> even as i type that i'm suspicious of it
15:57:30 <ray> someone tell me why i'm wrong
15:57:33 <Cale> SamB_XP_: Sure, but we're not even aiming for cryptographic security here.
15:57:50 <Cale> SamB_XP_: We just want a reasonable statistical uniformity.
15:57:52 <SamB_XP_> ray: you haven't employed countless randomographers to break your idea?
15:58:04 <ray> i mean, i think there's an obvious problem
15:58:05 <ray> i can feel it
15:58:09 <ray> i can't see it
15:58:20 <heatsink> HugoDaniel, can you show me the type declarations for messages and interpreters?
15:58:31 <HugoDaniel> heatsink: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9583
15:58:38 <ksf> I never thought I'd experience that again.
15:58:45 <Cale> ray: That's the issue, can we really get away with doing that?
15:58:45 <HugoDaniel> this is for the message handlers, which interperters are an instance of
15:58:46 <heatsink> that was fast.
15:58:51 <ksf> my graphics are messed up because I failed to memcpy
15:58:53 <Cale> ray: If we can, then there's no problem.
15:58:55 <koninkje> ray: because the original PRNG is only pseudorandom, there's simple correlation between adjacent generators
15:59:20 <Cale> koninkje: But what about generators whose states are constructed from numbers that an initial generator generated?
15:59:23 <koninkje> ray: not that that's necessarily a problem for non-cryptographic uses
15:59:33 <Cale> (so they're unlikely to be adjacent at least)
15:59:49 <ksf> @hoogle memcpy
15:59:49 <lambdabot> Data.ByteString.Internal memcpy :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()
15:59:49 <lambdabot> Data.ByteString.Internal memcpy_ptr_baoff :: Ptr a -> RawBuffer -> CInt -> CSize -> IO (Ptr ())
16:00:26 <HugoDaniel> heatsink: the monad has a list of interpreters, and a list of "objects" that produce messages to be handled by the interpreters
16:00:50 <mauke> ksf: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html#v%3AcopyArray
16:01:23 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Utils.html#v%3AcopyBytes
16:01:29 <ksf> ah.
16:01:33 <Cale> http://www.wired.com/wiredscience/2009/09/fmrisalmon/
16:01:34 <Cale> haha
16:01:41 <ksf> from the module name I expected it to work on arrays.
16:01:46 <ray> cryptographically, i'd like the types to be IO :)
16:01:59 <koninkje> Cale: I meant, that since there's a simple function defining the sequence of numbers, that function can be used by earlier generated-generators to predict the outputs of later generated-generators.
16:02:00 <HugoDaniel> so, something like do { st <- get; case (handleMessage (head $ interpreters st) msg) of Just i -> put [i] ...  or whatever :/
16:02:40 <Cale> koninkje: hmm
16:02:45 <koninkje> Cale: of course, depending on the properties of the PRNG, it may not be as easy as as it sounds
16:03:16 <koninkje> i.e. if we can't just distribute
16:03:34 <heatsink> HugoDaniel: Okay.  Can you mapM what you just said over the list of messages?
16:04:06 <ksf> hmmm I don't suppose memcpy's size_t argument can be negative, can it?
16:04:50 <HugoDaniel> yes, but wont it be inefficient ? i would be replacing an element in a list each time...
16:05:11 <mauke> ksf: size_t is an unsigned type
16:05:38 <HugoDaniel> (and thus generating the whole list of interpreters... for each message)
16:05:56 <ray> haha, cale
16:06:28 <koninkje> Cale: but otherwise perhaps Gen( p[t+1] ) )[i] == p( Gen( p[t] )[i] ) where Gen creates a generator and p is some initial generator. Whether anything like that holds up, I don't know. Not my area, but it sounds like something to look out for.
16:08:50 <heatsink> HugoDaniel, it depends on how long the list is and what message handlers do in the common case.
16:09:11 <Cale> Note that it's okay to assume that after splitting, the original generator can no longer be used.
16:09:26 <heatsink> For example, if most messages don't change the state, then state updates shouldn't be a performance problem.
16:09:33 <HugoDaniel> heatsink: message handlers do lots of IO :P
16:09:50 <Cale> (because we get at least 2 new generators from the process, and can go on to use one of those in place of the original one)
16:09:54 <heatsink> IO will probably be the largest part of execution time, then.
16:10:04 <seanmcl> Hi.  I'm an FFI newbie.  Is there a way to get the address of a Foreign.Ptr?  I've been using a C interface with an "abstract" C type called Expr.  I made the corresponding Haskell type Expr = Foreign.Ptr ().  That was working until I found a C library function that needs an Expr*.  It takes an array of Exprs.  I only need to pass 1, so I figured if I have a Haskell Expr e, it would be sufficient to pass the equivalent of &e.  But there
16:10:04 <seanmcl> is no "address-of" operator.  What would it's type be?  Anyway, is there a way to hack this?
16:10:30 <heatsink> HugoDaniel, unless your list is huge like 10^4 elements.
16:10:45 <HugoDaniel> the list is small, around 20 elems
16:11:09 <mauke> seanmcl: you can't do it directly; you have to allocate a temporary object
16:11:22 <mauke> seanmcl: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Utils.html#v%3Awith seems appropriate
16:11:31 <HugoDaniel> but message handling is being done once every 20ms ... thats why i was wondering about performance
16:11:34 <Cale> So, even if the original generator contains some information which can be used to discern a relationship between the new generators, we don't have to worry about that. It's just about whether, say, the sequence of Gen(p[1]) can tell you something about the sequence of Gen(p[2]), after forgetting p.
16:11:48 <HugoDaniel> and that "once" must be really fast, so interpreters have more time do to IO
16:12:51 <heatsink> HugoDaniel, performance optimization at this level of detail really requires seeing at the code.
16:13:11 <HugoDaniel> ok
16:13:59 <seanmcl> mauke: Thanks very much.  I'll give it a shot.
16:14:03 <koninkje> Cale: sure, I was just saying that if the function taking a seed to a generator can be distributed over the function taking a seed to (value,newSeed) then we have a problem. Since the first new generator can just take an extra step to know what the second generator is doing. And "distribute" is a bit strong phrase for it; if there exists any unGen such that Gen . rand == rand . unGen then that should be enough to break things
16:14:46 <HugoDaniel> ill run it with the mapM, and suffer a huge performance penalty then :)
16:16:27 <seanmcl> mauke: I can't believe it.  It worked.  This is the easiest FFI I've ever seen.
16:16:27 <heatsink> That's a good start.  You can profile and find out how long it takes.
16:16:32 <heatsink> :)
16:18:32 * ksf uses http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Alloc.html#v%3Aalloca
16:18:59 <Alpounet> FTGL for the win
16:19:22 <ksf> ...ah, you need to pass.
16:20:01 <ksf> usually you need to alloc because C doesn't know how to return complex things so people pass stack structs by reference.
16:20:13 <koninkje> Cale: but then I know nothing about PRNGs other than that the "pseudo" should be taken seriously. I was merely pointing out one reason why ray's intuition might be justified
16:20:48 <ksf> pseudo might mean that you have vastly superiour distribution and other properties.
16:21:25 <SamB_XP_> unfortunately, non-pseudo RNGs are in IO
16:21:57 <ksf> luckily. usually, you want to have replicatable runs.
16:22:09 <SamB_XP_> well, okay, fortunately for that
16:22:13 <ksf> ...initializing a good prng with true randomness is usually enough.
16:22:19 <SamB_XP_> but I mean it could be rather a pain
16:22:24 <ksf> ...as their output isn't all their internal state.
16:23:20 <ksf> (if it is, use a different prng. you want to.)
16:26:18 <koninkje> this is my favorite non-pseudo RNG: http://www.gamesbyemail.com/dicegenerator
16:26:48 * ksf thinks it's too late to worry about finalizer pointers today.
16:27:41 <Alpounet> It's never too late !
16:28:16 <ksf> well, it's not even that anything leaks memory or crashes or something.
16:28:52 <Cale> Wow, I just had 130 seconds of lag...
16:29:45 <ksf> ...it's just freetype constantly writing into the same approximate memory area and my code interpreting those areas in different ways.
16:29:52 <ksf> ...which usually look quite noisy.
16:30:07 <SamB_XP_> Cale: I usually refer to that condition as "disconnected"
16:32:25 <mauke> [freenode] CTCP PING reply from Cale: 181.642 seconds
16:32:28 <Cale> SamB_XP_: I'm still getting messages... just with ridiculous amounts of lag.
16:32:47 <SamB_XP_> Cale: oh, you mean it wasn't just a hickup ?
16:33:01 <Cale> Maybe a couple of them.
16:33:04 <SamB_XP_> Cale: is it possible that you may be on the next planet over ?
16:33:06 <Cale> Seems okay now.
16:33:26 <ray> and you're not even on ipv6
16:33:53 <ray> i always assume it's because i'm using ipv6 and nobody cares about ipv6
16:33:55 <SamB_XP_> hey, sixxs tunnels are usually pretty low-latency
16:34:13 <ray> tunnels are for wimps
16:34:23 <SamB_XP_> well, my ISP is wimpy
16:37:24 <Alpounet> would a password manager displaying a password we ask it within a 3D context be of interest for the community ? (blogging) :-p
16:37:57 <tinLoaf> hey guys. is there any way to get only the match to a subexpression in a regexp?
16:38:23 <tinLoaf> like i have a regular expression with a subexpression (or a capture group, or whatever), and i want to know only what matched to this capture group?
16:38:46 <ksf> my 6to4-tunnels seem to be quite speedy, too.
16:38:47 <Cale> tinLoaf: Which regular expression library?
16:38:57 <ksf> next hop amsterdam or frankfurt.
16:39:02 <aavogt> , dict
16:39:05 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
16:39:12 <tinLoaf> Cale: at the moment pcre-builtin
16:39:31 <tinLoaf> Cale: but i'm flexible regarding that - i will use any library that supports this ;)
16:40:15 <ksf> usually, people who come here and want to use regexen actually want to use parsec.
16:40:30 <aavogt> , let mdict = S.fromList dict in filter (all (`S.member` mdict) . words) . permutations $ "looks like it might be connected"
16:40:32 <lunabot>  luna: Not in scope: `S.fromList'
16:40:44 <Cale> tinLoaf: getAllTextSubmatches
16:40:48 <aavogt> , let mdict = Set.fromList dict in filter (all (`Set.member` mdict) . words) . permutations $ "looks like it might be connected"
16:40:49 <lunabot>  luna: Not in scope: `Set.fromList'
16:41:04 <tinLoaf> Cale: is there any documentation actually telling what all these functions *do*?
16:41:30 <tinLoaf> the hackage-Documentation mostly only lists the functions, and does not tell what they do..
16:41:38 <ksf> well pcre is perl, so you can look there
16:41:41 <tinLoaf> ksf: i'll have a look at parsec
16:41:46 <magma> Hey guys, I have a question about Hutton's book, p.44
16:41:57 <magma> freqs xs = [percent (count x xs) n | x <- ['a'..'z']] where n = lowers xs
16:42:00 <tinLoaf> ksf: i know how perl regexps work, but i don't know how to get the submatches in haskell ;)
16:42:18 <Cale> > getAllTextSubmatches ("123" =~ "([0-9])([0-9]*)") :: [String]
16:42:18 <Cale> ["123","1","23"]
16:42:19 <lambdabot>   ["123","1","23"]
16:42:20 <ksf> man 3 pcre
16:42:30 <magma> He says "n" needs to be put in a "where" clause here, otherwise it gets recomputed 26 times
16:42:32 <magma> is it so?
16:43:14 <ksf> usually, yes.
16:43:20 <ksf> ghc doesn't do much cse.
16:43:21 <tinLoaf> Cale: so it's like "complete matched expression, first matched subgroup, second subgroup, etc."?
16:43:29 <Cale> yeah
16:43:40 <tinLoaf> thanks a lot
16:43:49 <ksf> or wait that's a let float.
16:43:50 <Cale> tinLoaf: getAllTextSubmatches is just a field extractor for a newtype wrapper. The newtype is there to select an instance of RegexContext which does the right thing.
16:43:59 <Cale> It's crazy, but... that's how it works.
16:44:06 <ksf> magma, if in doubt, use Debug.Trace
16:44:08 <Cale> Personally, I don't use regexes at all.
16:44:19 <Petrosian`> magma: He isn't specific about implementation
16:44:22 <ksf> (and possibly see it change with optimisation levels)
16:44:22 <Cale> > getAllTextSubmatches ("123" =~ "([0-9])([0-9]*)") :: Array Int String
16:44:23 <lambdabot>   array (0,2) [(0,"123"),(1,"1"),(2,"23")]
16:44:30 <tinLoaf> well.. I'm quite new to haskell (3 day so far ;)), so these are a little too many types for me ;)
16:44:34 <Petrosian`> The comment is more "Use a where clause to /ensure/ it doesn't get recomputed"
16:44:41 <Petrosian`> Rather than take the chance that it might.
16:44:59 <magma> ksf: I will investigate this Debug.Trace
16:45:04 <maltem> Cale: So you just know about the regex libs for #haskell purposes?
16:45:14 <Cale> maltem: Pretty much. ;)
16:45:17 <maltem> heh
16:45:32 <Cale> If I want to parse something, I'll use Parsec instead.
16:45:42 <tinLoaf> ah, ok, so i can more or less pack all the RegexContext-Types into the getAllTextSubmaches-array
16:45:44 <ksf> Q.E.D.
16:46:16 <Cale> tinLoaf: It's a funky polymorphic thing which constructs different data depending on which type you ask for.
16:46:31 <Cale> tinLoaf: I suspect they were trying to be perly.
16:46:49 <tinLoaf> yeah, I think i got it.. but now i'll have a look at parsec, that's probably what i'm looking for actually ;)
16:46:57 <Cale> > getAllTextSubmatches ("123" =~ "([0-9])([0-9]*)") :: Array Int (String, (MatchOffset, MatchLength))
16:46:58 <lambdabot>   array (0,2) [(0,("123",(0,3))),(1,("1",(0,1))),(2,("23",(1,2)))]
16:47:09 <Cale> > getAllTextSubmatches ("123" =~ "([0-9])([0-9]*)") :: [(String, (MatchOffset, MatchLength)]
16:47:09 <lambdabot>   <no location info>: parse error on input `]'
16:47:16 <Cale> > getAllTextSubmatches ("123" =~ "([0-9])([0-9]*)") :: [(String, (MatchOffset, MatchLength))]
16:47:17 <lambdabot>   [("123",(0,3)),("1",(0,1)),("23",(1,2))]
16:48:26 <Cale> > getAllMatches ("123" =~ "([0-9])([0-9]*)") :: Array Int MatchArray
16:48:27 <lambdabot>   array (0,0) [(0,array (0,2) [(0,(0,3)),(1,(0,1)),(2,(1,2))])]
16:48:30 <magma> Petrosian`: Oh, ok.  Thanks!
16:48:46 <Cale> > getAllMatches ("123 456" =~ "([0-9])([0-9]*)") :: Array Int MatchArray
16:48:47 <lambdabot>   array (0,1) [(0,array (0,2) [(0,(0,3)),(1,(0,1)),(2,(1,2))]),(1,array (0,2)...
16:49:49 <tinLoaf> yeah, this polymorphic stuff is quite mighty...
16:49:50 <Cale> > getAllTextMatches ("123 456" =~ "([0-9])([0-9]*)") :: [Array Int String]
16:49:51 <lambdabot>   [array (0,2) [(0,"123"),(1,"1"),(2,"23")],array (0,2) [(0,"456"),(1,"4"),(2...
16:50:04 <Cale> That one actually might be the most convenient right there.
16:50:30 <Cale> Because it gives you a list of results, and each is an array of the matched subexpressions.
16:50:58 <tinLoaf> :: [String] is completely sufficient for my needs :)
16:51:25 <Cale> What is the regex that you're matching?
16:52:10 <tinLoaf> something like "^(:[a-zA-Z]* )?([a-zA-Z]*)"
16:52:11 <SamB_XP_> > getAllTextMatches ("123 456" =~ "([0-9])([0-9]*)") :: [[String]]
16:52:12 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
16:52:12 <lambdabot>                    ...
16:52:45 <tinLoaf> so there will be only one result anyways, since i'm matching for the start of the line
16:52:55 <Cale> Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. -- jwz
16:53:37 <tinLoaf> well, they are handy most of the time.. but i'll have a look at that parsec thing
16:54:31 <tinLoaf> why the hell are the parsec-parsers returning "Left"? I mean, i can understand "right", but "left"?
16:54:49 <ksf> > parse (many1 letter) "" "foobar"
16:54:49 <lambdabot>   Not in scope: `parse'Not in scope: `many1'Not in scope: `letter'
16:54:58 <ksf> > P.parse (many1 letter) "" "foobar"
16:54:59 <lambdabot>   Not in scope: `P.parse'Not in scope: `many1'Not in scope: `letter'
16:55:08 <wdonnelly> so there's a 'replicateM', is there a 'repeatM'?
16:55:18 <Saizan> tinLoaf: you don't like the name?
16:55:21 <iago> tinLoaf, to return errors ?
16:55:22 <ksf> left is an error
16:55:24 <Saizan> wdonnelly: there's forever
16:55:27 <wdonnelly> asking specifically for use with 'unsafeInterLeaveIO'
16:55:41 <tinLoaf> iago: but what's the meaning of "Left"? They also could have called it "Foobar"?
16:55:44 <ksf> mapM/forM?
16:55:55 <iago> Either is an union type
16:55:57 <tinLoaf> Saizan: well, "don't like".. doesn't really matter to me, i just wonder
16:55:58 <wdonnelly> so I can give an infinite list of values to a non-IO function, but each value requires IO to generate them
16:55:59 <iago> Left, Right
16:56:07 <iago> what happens with the name
16:56:10 <ksf> @src Either
16:56:10 <lambdabot> Source not found. stty: unknown mode: doofus
16:56:20 <wdonnelly> mapM and forM won't work
16:56:20 <iago> Either a b = Left a | Right b
16:56:38 <wdonnelly> I already wrote a function that does what I need, I was just wondering if there was a library function that I missed
16:57:01 <iago> you can see in some books a+b with data constructors inl and inr
16:57:17 <iago> or InL and InR
16:57:21 <tinLoaf> uhm, ok.. so it's just a datatype to be able to return two different results with a parameter each
16:57:22 <ksf> the library doesn't come with convenience wrappers around unsafeBadBoyDon'tUseMe*
16:57:31 <iago> tinLoaf, yep
16:57:36 <Saizan> tinLoaf: Either is a standard and very general type, Left is often taken conventionally to mean errors but that's not necessarily true
16:58:00 <iago> I expect that when use to handle errors, Right have double-meaning, but in the definition of Either, Right is doesn't means "correct"
16:58:24 <wdonnelly> ksf: hah, good point, I guess i shall consider myself duly warned then
16:58:42 * ksf uses a different types when it's not for error handling
16:58:57 <ksf> ...sum types are a bit a dozen.
16:59:00 <tinLoaf> yeah.. that was the first time i saw that either type, and didn't know that's a generic type which is used everywhere
16:59:36 <heatsink> ksf: A sesquibyte a dozen, I think
16:59:59 <iago> ksf, I understand another thing for sum types
17:00:16 <iago> sigma-types
17:00:33 <Cale> > parseTest (do x <- optionMaybe (do char ':'; u <- many letter; space; return u); y <- many letter; return (x,y)) ":abc def"
17:00:33 <Cale> (Just "abc","def")
17:00:33 <Cale> > parseTest (do x <- optionMaybe (do char ':'; u <- many letter; space; return u); y <- many letter; return (x,y)) "def"
17:00:33 <Cale> (Nothing,"def")
17:00:33 <lambdabot>   Not in scope: `parseTest'Not in scope: `optionMaybe'Not in scope: `letter'N...
17:00:34 <lambdabot>   Not in scope: `parseTest'Not in scope: `optionMaybe'Not in scope: `letter'N...
17:01:15 <Cale> (It's possible to write those more succinctly using Applicative, but you can learn that later ;)
17:01:17 <Saizan> A + B = \Sigma Bool (\b -> if b then A else B), anyway
17:01:32 <ksf> you know, with -XTypeLevelOperators, you can actually do a type Foo `Σ` Bar
17:02:06 <iago> sigma-types are dependent tuples, not the same than Either, or I am missed
17:02:08 <Saizan> you really need Operators?
17:02:19 <tinLoaf> yeah, well, i'm still struggling with the monads... i mean i think i got the principle, but i somehow don't exactly know why you use a monad here or there ;)
17:02:37 <Cale> tinLoaf: Don't worry about the fact that it's a monad.
17:02:39 <FunctorSalad_> IIRC with TypeOperators you can even declare typecons infix
17:02:41 <FunctorSalad_> ?
17:02:47 <ksf> hey. (S Z) `Div` Z
17:02:50 <Cale> tinLoaf: Basically, a monad is just a library which supports a particular API.
17:02:51 <Saizan> iago: sigma-types generalize tagged unions like Either
17:02:54 <iago> well ok Saizan
17:03:00 <iago> I see
17:03:17 <SamB_XP_> tinLoaf: well, for IO it's because you want to (well, have to) sequence computations doing input and output
17:03:17 <iago> but maybe "union" type for Either-like is a better name
17:03:20 <Saizan> but degrade to tuples if you drop the dependency
17:03:23 <Cale> tinLoaf: Because there are return and (>>=) operations defined for parsec parsers, we can use do-notation to write the parsers.
17:03:26 <FunctorSalad_> *checks* you can
17:03:39 <Saizan> iago: union type can mean non-discriminated union
17:03:57 <Saizan> iago: i.e. without a tag to tell which type you've got
17:04:04 <tinLoaf> Cale: yep, but when i look at it (http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#UserGuide), it look like they are more using the >> stuff
17:04:16 <FunctorSalad_> iago: you were right, Either is the special case of Σ where the variable ranges over Bool
17:04:21 <tinLoaf> so the binding without caring for the result of the previous bind
17:04:41 <ksf> well it's called "sum" because the set of valid types for Either a b has the cardinality of the sets of a and b, added.
17:04:45 <Cale> tinLoaf: Yeah, that just parses and discards the result which the parser returns
17:05:00 <ksf> (a,b) is called a product because the cardinalities multiply.
17:05:01 <Cale> tinLoaf: (but the characters still get eaten)
17:05:08 <iago> I only said that seems a bit confused call sum type a concrete case of a sum type
17:05:16 <ksf> .oO( what's an exponent type? )
17:05:18 <Cale> tinLoaf: (And the parser will still fail if that parse failed)
17:05:31 <Saizan> ksf: functions
17:05:31 <tinLoaf> Cale: so when i "run" that parser, it internally "passes" through that monad, matching against whatever the next bind operation is?
17:05:42 <FunctorSalad_> iago: it works much like (+) and Σ in ordinary arithmetic :)
17:06:03 <Saizan> yeah
17:06:15 <FunctorSalad_> a_0 + a_1 = Σ_{x in {0,1}} a_i
17:06:27 <FunctorSalad_> .... you know what I meant to type
17:07:00 <iago> yes
17:07:02 <ksf> ...the monad is just a convenient way of keeping track of the current parse position and have a place to stash bactrace points etc.
17:07:05 <Cale> tinLoaf: Well, the monad operation p >>= f is defined to be the parser which first parses with p, then captures the result of that parse, say v, and then continues parsing with the parser f v
17:07:22 <SamB_XP_> FunctorSalad_: what did you mean to type ?
17:07:25 <Cale> tinLoaf: p >> q is then the parser which parses first with p, and then with q
17:07:33 <SamB_XP_> did you not mean to type the actual sum symbol ?
17:07:37 <Cale> (producing the result of q)
17:07:51 <FunctorSalad_> SamB_XP_: s/x/i/
17:07:59 <SamB_XP_> oh, that, right ;-)
17:08:08 <FunctorSalad_> what other sum symbol is there?
17:08:13 <Cale> tinLoaf: Of course, parsers can be nondeterministic and have more than one possible parse, so things are made a bit more complicated by that
17:08:26 <ksf> there's the greek sigma and at least one mathematical symbol
17:08:28 <FunctorSalad_> ∑Σ
17:08:30 <FunctorSalad_> oops
17:08:36 <tinLoaf> yeah, otherwise you're at regexps again
17:09:02 <SamB_XP_> which is which ?
17:09:10 <FunctorSalad_> first is \sum
17:09:15 <ksf> ...parsers can have state, too, and in case you're using polyparse also fixpoints.
17:09:46 <SamB_XP_> fixpoints ?
17:10:04 <ksf> ...you can inspect the parse result while parsing.
17:10:18 <Cale> tinLoaf: Well, regular expressions can be ambiguous too.
17:10:26 <ksf> that is, the polyparse is lazy enough and knows of a no-fail mode.
17:10:32 <chowmeined> lambdabot,
17:10:33 <tinLoaf> ksf: but for "transporting" a state through that parser, I'd have to use >>=, don't i?
17:10:35 <dm2`> Is there any way to curry a type constructor argument that is not the first argument of the type?  I.e., I can say "instance MyClass ((->) Int)" for functions that take an Int, but what if instead I wanted to make functions returning an Int members of my class.
17:10:53 <Cale> tinLoaf: Consider parsing using the regexp a*a and trying to match the string "aaaa"
17:11:02 <FunctorSalad_> dm2`: not without newtype
17:11:02 <heatsink> dm2`: no
17:11:02 <tinLoaf> Cale: yeah, that's true of course
17:11:08 <ksf> ...not nescessarily, applicative can do that, too.
17:11:17 <dm2`> bummer.  Thanks, though.
17:11:22 <ksf> you only need a monad if you want to act upon that state.
17:11:52 <tinLoaf> hum, no clue what an applicative is, i always thought that with a >> you discard whatever the result of the last monadic computation was
17:12:02 <Cale> tinLoaf: If the a* eats everything, then the a will have nothing to eat, and that parse will fail, so you need backtracking in that case. (Of course, it's possible to compile regular expressions such that no backtracking is needed, but you must account for that ambiguity in some way)
17:12:32 <ksf> tinLoaf, http://haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf , typeclassopedia
17:12:35 <heatsink> tinLoaf, an applicative has side effects like a monad, but no way to pass the result of one computation to another.
17:12:40 <ksf> @src (>>)
17:12:40 <lambdabot> m >> k      = m >>= \_ -> k
17:12:45 <Cale> tinLoaf: >>= isn't really about state, it means something different in each monad.
17:12:45 <ksf> that's how it works
17:13:07 <Cale> tinLoaf: But if you want to, you can imagine that it's managing passing around the state of the parser for you.
17:13:21 <Cale> tinLoaf: A better view is that it's manipulating parsers and turning them into new parsers.
17:13:27 <tinLoaf> Cale: so it isnt defined as m a >>= (a -> m b) -> m b everytime?
17:13:57 <Cale> (>>=) :: m a -> (a -> m b) -> m b
17:14:01 <ksf> >>= is defined differently every time.
17:14:10 <Cale> Similar type, different definition.
17:14:15 <tinLoaf> uhm, ok
17:14:23 <Cale> So, for instance, with lists, that becomes
17:14:29 <Cale> [a] -> (a -> [b]) -> [b]
17:14:35 <Cale> and with parsers, it's
17:14:42 <Cale> Parser a -> (a -> Parser b) -> Parser b
17:14:59 <Cale> and with IO actions, it'd be
17:15:06 <Cale> IO a -> (a -> IO b) -> IO b
17:15:22 <Cale> That's the type, it doesn't really say exactly what it does.
17:15:42 <tinLoaf> uhm, ok, so the >>= impelementation itself alters the parser
17:15:43 <Cale> and for a given type, it's possible that more than one >>= will turn it into a monad, though that's somewhat rare.
17:15:48 <tinLoaf> or creates my new parser b
17:15:51 <Cale> yeah
17:16:01 <Cale> >>= for parsers does a sort of concatenation operation
17:16:07 <tinLoaf> the (a -> Parser b) function isn't needed in that case of course..
17:16:19 <Cale> It is needed, usually.
17:16:23 <Cale> It's important.
17:16:37 <Cale> Otherwise, how are you going to get results of type b?
17:16:47 <tinLoaf> yeah but not when just "stupidly" concatenating parsers? i thought >>= would do that itself?
17:17:05 <Cale> (>>=) receives:
17:17:12 <Cale> 1) A value of type Parser a
17:17:26 <Cale> 2) A function from values of type a to values of type Parser b
17:17:38 <Cale> and it's expected to produce a value of type Parser b
17:18:04 <tinLoaf> right. but in the examples on http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#UserGuide they use the >> operator
17:18:17 <tinLoaf> or rather, in the do-notation, just don't bind to anything, which should be the same, shouldn't it?
17:18:25 <Cale> >> always throws away the "result" from the first thing
17:18:32 <SamB_XP_> tinLoaf: yeah
17:18:37 <SamB_XP_> @undo x; y
17:18:37 <lambdabot>  Parse error at ";" (column 2)
17:18:37 <tinLoaf> yeah, so our "parser a" would be discarded, wouldn't it?
17:18:40 <SamB_XP_> @undo do x; y
17:18:40 <lambdabot> x >> y
17:18:42 <Cale> So in the case of parsers,  p >> q  will parse with p, discard the result
17:18:46 <Cale> (but not the effect)
17:18:51 <FunctorSalad_> I didn't read the whole conversation, but in case of parsers, you can imagine "x >>= f" as "run parser x, then based on the result (say r), run the parser f r"
17:18:53 <Cale> and then parse what's left of the string with q
17:19:05 <Cale> So, for example,  char ':' >> many letter
17:19:15 <tinLoaf> ahh, ok. so the monad is not actually building up a new parser based on what's been built before
17:19:19 <ksf> ...run the parser that f returns given the value x yields.
17:19:26 <Cale> will look for a colon character first, and then try to get many letters.
17:19:29 <tinLoaf> it will be rather traversed when the parser itself is run
17:19:39 <FunctorSalad_> tinLoaf: it does decide what the next parser is based on the result of x
17:20:10 <ksf> tinLoaf, there's no difference between code and data.
17:20:27 <FunctorSalad_> (where "decide" means, put the result into the function f)
17:20:44 <FunctorSalad_> (which then produces a parser)
17:21:27 <Cale> tinLoaf: It builds a parser up from these functions and other parsers.
17:21:45 <tinLoaf> Cale: yeah, i think i got it slowly... i was thinking in "wrong" ways
17:21:48 <Cale> tinLoaf: If you want to see how it works, we could actually implement it.
17:22:09 <Cale> Though, of course, a much simpler and less efficient version than Parsec :)
17:22:33 <tinLoaf> i thought the "current" parser was passed to the next parser-building function inside the monad, but it's rather doing it step-for-step
17:22:44 <Cale> newtype Parser a = P (String -> [(String,a)])
17:23:09 <Cale> A Parser for things is a function from Strings to lists of pairs of Strings and things.
17:23:22 <tinLoaf> yep
17:23:45 <Cale> Basically, it will take some input string, and produce a bunch of possible parses, along with the remainder of the string in each case.
17:24:07 <tinLoaf> where the "things" or "a"s are our patterns or whatever-we-parse-for
17:24:08 <tinLoaf> right?
17:24:25 <Cale> yeah, whatever data our parser is extracting from the text
17:24:33 <Cale> runParser :: Parser a -> String -> [(String, a)]
17:24:36 <tinLoaf> ok, so far it's easy ;)
17:24:41 <Cale> runParser (P f) s = f s
17:24:55 <Cale> So, this representation makes runParser completely trivial to write :)
17:25:10 <Cale> In fact, we could even write  runParser (P f) = f
17:25:29 <tinLoaf> yeah, thanks to currying.
17:25:33 <Cale> right
17:25:40 <Cale> Now, let's look at return
17:25:45 <Cale> return :: a -> Parser a
17:26:05 <Cale> (return v) is going to be a parser which "does nothing" and results in v
17:26:15 <tinLoaf> yes
17:26:19 <Cale> So:
17:26:30 <Cale> return v = P (\s -> [(s,v)])
17:26:58 <tinLoaf> yep, the string is not being touched
17:27:01 <Cale> right
17:27:28 <Cale> Now for (>>=), things get a little more complicated, but if we use list comprehensions, it's not so bad.
17:28:07 <Cale> (x >>= f)  is going to be the parser which, given an input string s, for each (s',v) which is a result of parsing s with x
17:28:15 <Cale> We parse s' with f v
17:28:31 <Cale> (and produce the depleted strings and results from all of those)
17:28:42 <Cale> Make sense?
17:28:48 <Cale> So the code is:
17:29:21 <tinLoaf> hum, i think i'm getting it..
17:29:28 <Cale> x >>= f = P (\s -> [(s'',w) | (s',v) <- runParser x s, (s'',w) <- runParser (f v) s'])
17:29:30 <ksf> are you actually typing or waiting for effect?
17:29:38 <Cale> ksf: actually typing
17:30:06 <tinLoaf> I'm glad he's not typing that fast cause that's tough stuff for me ;)
17:30:44 <Cale> Yeah, it takes some thinking the first time you see something like this, certainly.
17:31:33 <Cale> and then we could go on to implement our basic primitive parsers
17:31:35 <Cale> like:
17:32:28 <Cale> char c = P (\s -> case s of [] -> []; (x:xs) -> if x == c then [(xs,c)] else [])
17:32:42 <dons> ?users
17:32:42 <lambdabot> Unknown command, try @list
17:32:47 <dons> bah. lambdaobt
17:33:06 <Cale> Was @users part of seen?
17:33:16 <ksf> @seen @users
17:33:16 <lambdabot> Unknown command, try @list
17:33:28 <ksf> preflex, seen @users
17:33:28 <preflex>  Sorry, I haven't seen @users
17:33:39 <dons> probably.
17:33:43 <Cale> I took @seen out because it was inaccurate and mainly caused me problems when restarting the bot.
17:33:47 <ksf> apperantly not to be found anywhere.
17:34:42 <Cale> (because it would randomly decide to trash its state file, and would barf all over the place when lambdabot restarted unless it had a valid state file)
17:35:44 <tinLoaf> woah.. ok, i think i'm getting into it a little...
17:35:54 <tinLoaf> thanks in any case for that 'lesson' :)
17:36:06 <Cale> tinLoaf: No problem :)
17:36:29 <Cale> tinLoaf: So basically, parsers are built up from these simple operations, and we eventually can forget about this P data constructor.
17:37:08 <Cale> tinLoaf: and that's the situation we have in parsec -- its representation is a little more complicated because it does predictive parsing as much as it can, but it's the same idea.
17:37:44 <Cale> Do-notation of course translates into a bunch of these >>= operations
17:37:45 <tinLoaf> so it has to run these parsers "partly" to do the predictive parsing
17:38:26 <Cale> Well, unless you use 'try' it never backtracks.
17:39:03 <Cale> Well...
17:39:15 <Cale> it never backtracks from a parser which has already eaten at least one character.
17:39:29 <tinLoaf> yeah, that's what i meant with the "partly"
17:39:41 <Cale> 'try p' is a parser which is just like p, except that if it fails, then it's as if p didn't eat anything.
17:40:00 <tinLoaf> i guess it internally has to split up the "String" parsers e.g. into char parsers again, and if one of these char parsers succeeds, that path is chosen
17:40:11 <tinLoaf> or something along that.. my brain is spinning a bit at the moment ;)
17:40:16 <Cale> yeah
17:40:21 <Cale> something like that
17:40:56 <Cale> The important thing is to arrange so that the beginning of the string can become garbage to be collected as soon as possible.
17:41:19 <Cale> But yeah, thinking in those terms is tricky :)
17:42:00 <tinLoaf> it is indeed ;) .. well, as I mentioned i just started with haskell 3 days ago, i only did imperative stuff before
17:42:32 <SamB_XP_> tinLoaf: you are doing fantastically
17:42:43 <Cale> Yeah, so this will be a really new way of programming. If you understood that though, you're doing really well.
17:42:53 <Cale> Probably better than I was after 3 days :)
17:43:05 <tinLoaf> SamB_XP_: thanks a lot ;) what's a problem i think is to keep the "bigger picture" in mind
17:43:36 <tinLoaf> i know that with functional programming you can wonderfully abstract, but many times you have to have in mind which functions are "packed" into which symbols at the moment
17:44:30 <tinLoaf> like in this like: <Cale> x >>= f = P (\s -> [(s'',w) | (s',v) <- runParser x s, (s'',w) <- runParser (f v) s'])
17:44:39 <Cale> Yeah, and if you try to understand something like x >>= f >>= g >>= h by expanding out the definition 3 times, you will get lost.
17:44:52 <Cale> It's important to understand the definition once, and then just trust it :)
17:44:53 <SamB_XP_> that is for sure
17:45:00 <tinLoaf> i first wanted to protest that the first "runParser" is missing a pair as argument, but in x there is already a complete parser packed
17:45:43 <Cale> x is itself a parser
17:45:50 <Cale> and s is a string
17:46:03 <tinLoaf> i think that's because in functional languages the symbols can be more or less anything. in imperative languages you may have pointers to functions or whatever, but a veriable is a veriable, and not a curried function, i.e. a fuction and a "variable"
17:46:09 <Cale> and so the result of runParser x s is a list of (String, a)
17:46:16 <tinLoaf> Cale: yeah, that's what i meant with "packed"
17:46:34 <Cale> tinLoaf: Oh, you mean you're thinking about the function tucked away inside x, yeah
17:46:51 <tinLoaf> yep, you're like "packing" everything you did left of that binding into x
17:47:05 <Cale> er...
17:47:15 <Cale> (s',v) is what you're getting out of x
17:47:27 <A1kmm> Does anyone know of any timing issues with hdbc-mysql? I have some code which works with zero or two putStrLn invocations at the start, but gets a 'permission denied' error when there is one.
17:47:34 <Cale> runParser x s will result in a list of pairs
17:47:43 <Cale> and each of those pairs is matched with (s',v)
17:47:45 <tinLoaf> erryeah
17:48:07 <coco> wasn't their an Either-monad? where is it?
17:48:22 <Cale> coco: Control.Monad.Error
17:48:29 <Cale> coco: Though, the instance is somewhat dumb.
17:48:36 <coco> it's a transformer, no?
17:48:45 <tinLoaf> coco: it has to be still somewhere, i tripped over it just 20 minutes ago ;)
17:48:48 <Cale> coco: There's also an instance of Monad for Either in there.
17:49:10 <coco> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
17:49:11 <Cale> coco: Maybe also in Control.Monad.Instances
17:49:23 <aavogt> @type catch
17:49:24 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:49:37 <coco> can't seem to find it
17:49:42 <burp> A1kmm: this shouldn't matter, strange
17:49:44 <coco> is there a way to hoogle instances?
17:50:24 <aavogt> @type \io catchit -> catch (fmap (\x -> x `seq` x) io) catchit -- is this going to catch the error (return undefined) ?
17:50:24 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:50:36 <burp> you could try to use threadDelay to test ist ;)
17:50:48 <coco> tinLoaf: where was it 20 min ago?
17:51:01 <Cale> http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Error.html#%28line75%29
17:51:38 <A1kmm> burp: It seems to send pretty much the same thing to the SQL server.
17:52:07 <coco> thanks
17:52:49 <A1kmm> burp: But it may be that somewhere the code is not reading enough from the server... although that should be the responsibility of libmysqlclient.
17:53:17 <Cale> tinLoaf: So does that make sense?
17:53:37 <Cale> tinLoaf: For each depleted string s' and result v we get from running the parser x on our initial string s
17:53:39 <tinLoaf> Cale: sorry, me again. in the line i pasted above, the definition of >>=, x cant be a (s', v), i.e. a pair of string an whatever.. you later call "runParser x s", with s being a string
17:54:02 <tinLoaf> and runParser expects a (P f) as first argument
17:54:07 <Cale> tinLoaf: We run the parser f v on the string s', getting the new depleted strings s'' and results w
17:54:48 <tinLoaf> yeah.. waht was confusing me was <Cale> (s',v) is what you're getting out of x
17:54:53 <burp> A1kmm: I'm not that into hdbc, you have to wait for someone else to help :>
17:55:06 <tinLoaf> x itself is the parser we "built up" before, isn't it?
17:55:50 <aavogt> @index rnf
17:55:50 <lambdabot> Control.Parallel.Strategies
17:56:10 <Cale> x is a parser, which means that it's the P data constructor applied to some function String -> [(String, a)]
17:56:14 <burp> after trying hdbc, haskelldb and hsql I'm finally using takusen for my postgresql database and I like it most
17:56:22 <burp> but it's not available for mysql
17:56:45 <FunctorSalad_> how do I tell the ghc linker where to look for libraries? LD_RUN_PATH and LD_LIBRARY_PATH seem ineffectual
17:56:47 <tinLoaf> yeah, then the confusion is gone, or at least parts of it :)
17:56:51 <Cale> tinLoaf: So, more or less, x is a function, and we're applying that function to s
17:57:02 <Cale> and getting a list of (String, a) pairs as the result
17:57:04 <burp> at first haskelldb looked great but it has some serious flaws, or I didn't really understand something ;)
17:57:07 <tinLoaf> yeah.. i somehow had mistaken you that x is already a list of (s', v)
17:57:12 <Cale> ah
17:57:45 <Cale> Yeah, it's an honest-to-goodness parser which we're manipulating.
17:58:02 <Cale> and f is even stranger, it's a function which makes parsers.
17:58:25 <A1kmm> I think it has to be a MySQL bug based on the strace outputs.
17:58:53 <tinLoaf> should be one of our primitive parsers then
17:59:08 <Cale> tinLoaf: x may not be primitive
17:59:17 <tinLoaf> no, i mean f
17:59:39 <tinLoaf> i mean, of course it can be already combined of primitive parsers, but you could dismantle that
17:59:49 <Cale> f might not be primitive either, in fact, it'll usually take some value and produce some complicated parser built with >>='s
18:00:07 <Cale> In a do-block, say...
18:00:20 <Cale> do v <- foo; w <- bar; return (v,w)
18:00:20 <tinLoaf> yeah, but if you'd want to you could disassemble that into primitive parsers
18:00:29 <Cale> This translates to:
18:00:40 <Cale> foo >>= (\v -> do w <- bar; return (v,w))
18:00:52 <Cale> So f is the "remainder of the do-block"
18:01:00 <Cale> as a function of the result of foo
18:01:43 <Cale> Yeah, you'll eventually be able to decompose any parser into some mishmash of >>='s of primitive parsers and non-parser-related functions.
18:02:20 <Cale> If I had a parser bool for parsing boolean values
18:02:26 <Cale> then I could write:
18:02:38 <Cale> bool >>= \b -> if b then parser1 else parser2
18:03:11 <Cale> Or, more complicated functions can be involved in computing the remaining parser too.
18:03:32 <Cale> I could even write a parser which first parses a grammar, and then parses the remainder of the string with that grammar.
18:03:54 <tinLoaf> yeah, of course.. phew. lots of stuff...
18:03:56 <Cale> (building up some complicated parser to parse with the grammar that it just parsed)
18:04:23 <Cale> Of course, it's sort of a silly thing to do, but it's possible.
18:04:43 <Cale> So the future of a parser in this style is not so simple as with context free or regular grammars.
18:05:01 <Cale> This is much more powerful than normal regexes.
18:05:24 <Cale> (normally, regexes can't even tell if a string has matched brackets)
18:05:47 <tinLoaf> yep, but most of the impelementations should actually support that
18:06:34 <Cale> Well, perl's implementation does.
18:06:50 <Cale> But perl's regexes are not actually regexes :)
18:06:54 <dolio> Turing expressions.
18:07:33 <Cale> Which apart from the obvious advantages, also has some pretty severe disadvantages in terms of performance.
18:07:36 <tinLoaf> it's what programmers call a "regex", not what computer science people call an "expression conforming to a regular language" ;)
18:07:54 <Cale> It's possible to make much faster regular expression matchers if you don't do it the way perl does
18:08:20 <tinLoaf> aren't they using finite automata?
18:08:21 <impl> Cale: They are regexes, aren't they, it's just that they are aslo *more* than regexes?
18:08:27 <impl> also*
18:08:42 <Cale> impl: Well... the languages they describe are no longer necessarily regular.
18:09:09 <impl> Right, but you can use them to describe regular languages
18:09:18 <Cale> yes
18:09:24 <tinLoaf> i think the "rememberend subgroups" or what alone should burst the "regular language"
18:09:29 <Cale> But you can use context free grammars to parse regular languages too.
18:09:35 <Cale> Or general grammars ;)
18:09:38 <Cale> http://swtch.com/~rsc/regexp/regexp1.html
18:10:09 <clank> Cale: is there a regex system as powerful as perl's and also faster?
18:10:25 <Cale> (that uses a particularly silly benchmark, but it shows off why it might be worthwhile to at least notice when the described language is regular)
18:10:40 * clank takes a look...
18:11:25 <tinLoaf> Cale: whats the stuff in perl regexps violating the regular languages? only the "remembered groups"?
18:11:40 <Cale> clank: You could conceivably detect when the "regex" is really a regular expression, and use a faster engine.
18:11:49 <Cale> tinLoaf: Mainly that, yeah.
18:11:49 <tinLoaf> how do you call these officially? "catched groups" or something i think?
18:12:34 <Cale> istr there's also a way to embed arbitrary perl code into them as well?
18:13:01 <tinLoaf> perl code inside regexps? you mean like if-tests?
18:13:10 <Cale> Yeah.
18:13:23 <tinLoaf> now that's getting dirty
18:13:27 <Cale> (?{ perl code here })
18:13:35 <tinLoaf> i don't know, i can't code perl...
18:13:41 <impl> well Perl 6 destroys this whole argument I think
18:14:09 <tinLoaf> impl: why? did they change how their regexps are working?
18:14:14 <Cale> ah, it always succeeds, though... that means that the number of times the code runs depends on the implementation.
18:14:18 <impl> tinLoaf: Yeah
18:14:33 <impl> http://en.wikipedia.org/wiki/Perl_6_rules
18:14:53 <tinLoaf> impl: so all the code written for Perl <6 has to be converted?
18:15:16 <impl> Perl code never changes versions.
18:15:35 <impl> If you write Perl code for 5.008, it's still running on version 5.008 and it will always be running on version 5.008.
18:15:50 <tinLoaf> uhm, ok. as I said, i never did perl ;)
18:16:31 <Cale> "I prefer perl 5.10." "DIE HERETIC!"
18:16:36 <tinLoaf> but as i skim that wikipedia article, they just stopped calling it "regular expressions", right? the capture groups are still there...
18:17:21 <Cale> tinLoaf: Yeah, they've basically admitted that since the languages are not regular anymore, they might as well adopt a saner notation.
18:17:48 <Cale> Regular expressions really don't scale very nicely to more complicated grammars.
18:17:53 <tinLoaf> hum.. "computer folks" admitting something.. you don't see that too often ;)
18:19:09 <Cale> One thing that's always confused me is why, even though they'd added all these fancy non-regular-language features to regexes, they never bothered to add easy operations which regular languages *are* closed over.
18:19:13 <Cale> Like intersection.
18:20:07 <Cale> Or complement.
18:20:17 <Cale> Or difference.
18:20:38 <dolio> Hardly anyone has those.
18:20:48 <dolio> Although I thought slava was doing those for factor.
18:20:59 <mattam> There are some engines that have ^(complement).
18:20:59 <mattam> .
18:21:24 <dolio> Do the Haskell regex libraries have them?
18:21:35 <dolio> Presumably not the PCRE version, of course.
18:21:59 <mattam> I mean not just for char sequences, whish is part of GNU regexps if I'm not mistaken
18:22:14 <mattam> I have no idea.
18:22:21 <impl> http://github.com/rakudo/rakudo/blob/master/src/parser/grammar.pg
18:22:32 <impl> (Perl 6 parses itself)
18:22:42 <Cale> I don't think any of them do, but I don't know about the DFA/TDFA ones.
18:23:19 <Saizan> you can actually parse perl 6?
18:23:28 <impl> Perl can parse Perl 6.
18:23:43 <impl> I don't think they'd have it any other way.
18:24:04 <Cale> Is the Haskell parser for Perl 6 still up to date?
18:24:29 <Raevel> oh right, i totally forgot that it even existed
18:25:32 <A1kmm> A question about cabal: If I derive my package from someone else's, can I leave their name on the author list of my new package without asking them, or is there a better way to say they contributed to the predecessor?
18:26:01 <Cale> A1kmm: I would leave it on.
18:26:12 <dolio> Cale: The dfa and tdfa don't look too promising, but it's hard to tell.
18:26:40 <roconnor> I thought parsing perl was undecidable.
18:26:55 <dolio> Maybe they fixed that in 6.
18:27:09 <Cale> roconnor: Perl 5, certainly. Perl 6 is a whole new language, I'm not sure.
18:27:15 <roconnor> ah
18:27:52 <M_o_C> Further reading regarding Perl 5 "parse-ability": http://www.modernperlbooks.com/mt/2009/08/on-parsing-perl-5.html If anyone's interested...
18:34:58 <dolio> I'm not sure 'not required to execute arbitrary bits of a Turing complete language' exactly constitutes "limited circumstances" when it comes to parsing.
18:36:54 <Cale> Well, not only is it a Turing complete language -- if it were just that, it would still be somewhat okay -- but it's a Turing complete language with the ability to do arbitrary I/O.
18:37:03 <dolio> Heh.
18:38:31 <tinLoaf> ha! *now* I got why the sometimes use >> and sometimes use >>= when combining Parsers. >> just discards the contents of what has matched so far. i like it when the penny drops :)
18:39:15 <Cale> tinLoaf: x >> y = x >>= (\k -> y)
18:40:08 <Cale> tinLoaf: So yeah, when we care about matching x, but not about what the result of matching x is, we use >>
18:40:25 <tinLoaf> yep. that's what confused me (amongst other things ;))
18:41:09 <tinLoaf> its not the complete built-up parser that is dropped, because that is "carried through" with x >> y itself, it's just the "a" thing in our pair that is not passed here
18:41:48 <Cale> yeah
18:41:55 <Cale> The "result" of x
18:41:56 <tinLoaf> I'm a bit slow at this time of day ;)
18:42:13 <Cale> The depleted string is still carried along
18:42:21 <tinLoaf> of course
18:42:35 <tinLoaf> as i said, the "a" part, so the whatever-we-matched-for, is dropped
18:42:46 <Cale> right
18:42:53 <Cale> (I was just rephrasing)
18:42:56 <Saizan> in some sense no language with a macro system can be parsed statically, though
18:43:15 <Cale> Saizan: If that macro system is limited in its facilities...
18:43:50 <Cale> Then you could just run the macros without fear of missiles launching at least. :)
18:44:47 <Saizan> heh, i guess
18:47:21 <SamB_XP_> hmm ... can Coq be said to be one of those languages ?
18:47:23 <Cale> Or perhaps the macros are such that any well-typed macro program can't construct syntactically invalid programs. Then you could just go as far as typechecking the macro program to verify that there will be no syntax errors.
18:47:53 <SamB_XP_> (that is, where you need not fear missles launching)
19:17:00 <tinLoaf> harr.. my first parsers seem to work. time for me to get some sleep. thank you all guys :)
19:47:35 <roconnor> Do I need a mac to develop iphone apps in Haskell?
19:47:54 <seanstickle> You pretty much need a Mac to develop iPhone apps, period.
19:47:55 <copumpkin> probably, unless you enjoy hacking on GHC
19:48:05 <copumpkin> seanstickle: not really, but it makes it a lot more pleasant
19:48:20 <seanstickle> copumpkin: oh! really? interesting.
19:48:23 <roconnor> ;(  I'll never get my alligator eggs iphone app written.
19:48:28 <copumpkin> alligator eggs?
19:49:15 <copumpkin> seanstickle: the code signature scheme is reasonably simple, and there's an "open toolchain" for writing ARM mach-o apps for it (it predates apple's official toolchain, even)
19:49:29 <roconnor> http://www.reddit.com/r/programming/comments/9iel1/basic_sneaked_into_the_c64_emulator_in_the_app/c0cwelc?context=3
19:49:39 <seanstickle> copumpkin: ah neato.
19:50:20 <copumpkin> roconnor: that looks cute (and interesting)
19:53:01 <SamB_XP_> roconnor: I don't think they're going to kill it just because it's church complete, if *that's* what you are worried about ...
19:53:11 <roconnor> :)
19:53:25 <SamB_XP_> you were lying about that, right?
19:53:28 <roconnor> really, what is the difference.
19:53:44 <roconnor> SamB_XP_: if I work hard enough I can make my lies into truth
19:53:47 <SamB_XP_> the difference is it's a lot harder to read the output of an alligator-eggs app ;-)
19:53:53 <roconnor> :)
19:54:45 * copumpkin wants alligator-encoded naturals
19:54:47 <SamB_XP_> lol @ minesweeper being pulled
19:55:28 <SamB_XP_> what, is it speak like a pirate day or something ?
19:55:31 <copumpkin> yeah :)
19:55:36 <copumpkin> I mean
19:55:38 <copumpkin> AYE MATEY
19:56:19 <seanstickle> I think tomorrow is Program Like a Pirate Day
19:57:46 <aavogt> @arrr
19:57:46 <lambdabot> Yo ho ho, and a bottle of rum!
19:58:38 <SamB_XP_> the funny thing is I actually got the minesweeper joke -- did you?
19:59:48 <copumpkin> yeah
20:00:07 <SamB_XP_> though actually that's only NP-complete
20:00:07 <copumpkin> unless I'm dumb enough to think I got it but really didn't ;)
20:00:11 <defun> when ghc generates a haskell binary, does it use symbols? Btw, what are symbols?
20:00:12 <SamB_XP_> not turing-complete
20:00:24 <SamB_XP_> er. I meant to say church-complete
20:00:32 <copumpkin> defun: symbols? in the object format sense?
20:00:39 <defun> when ghc generates a haskell binary, does it use symbols? Btw, what are symbols?
20:00:46 <defun> sorry
20:00:47 <copumpkin> ...indeed
20:00:51 <copumpkin> :)
20:00:52 <defun> enter-key got stuck
20:01:02 <defun> I'm pretty sure.
20:01:52 <defun> Yeah, in the object format sense
20:02:27 <SamB_XP_> hmm. I wonder what all you can run on that C64 App?
20:03:20 <copumpkin> defun: libraries and other object files on most OSes can export "stuff" from themselves
20:03:27 <copumpkin> the key you use to get at that stuff is a symbol
20:03:47 <copumpkin> that stuff could be code or data
20:03:58 <defun> I see. Thanks.
20:04:03 <copumpkin> symbols aren't only for exporting though
20:04:16 <copumpkin> they're also used to maintain tagged information about a file, often for debugging and other purposes
20:04:47 <aavogt> removing symbols is called stripping
20:05:08 <copumpkin> symbols also have metadata associated with them
20:07:43 <roconnor> SamB_XP_: what's the difference between church complete and turing complete?
20:08:00 <SamB_XP_> roconnor: who gets credit ;-P
20:08:06 <roconnor> ok
20:08:25 <SamB_XP_> they've been proven equivalent decades ago ;-P
20:08:30 <roconnor> I thought perhaps church complete had something to do with higher order functions
20:08:42 <SamB_XP_> well, sure
20:09:01 <roconnor> turing complete is only about Nat -> Nat.
20:09:11 <dolio> Haskell is more complete than BASIC. Pass it on!
20:09:27 <SamB_XP_> well, yeah, but you need HoFs to implement Nat -> Nat in lambda calculus ;-P
20:10:01 <roconnor> yes, but perhaps chuch complete means all computable higher order functions can be written in the language.
20:10:09 <roconnor> though it doesn't.
20:10:12 <roconnor> mean that
20:12:02 <SamB_XP_> no, it just means as computationally powerful as the (untyped) lambda calculus
20:13:38 <roconnor> see, the untyped lambda calculus is quite different from a turing machine.
20:13:53 <roconnor> hmm
20:13:58 <roconnor> maybe that isn't really true
20:14:19 <byorgey> they're equivalent in expressive/computational power, aren'y they?
20:14:24 <byorgey> *aren't
20:14:25 <roconnor> I guess you can consider the lambda calculus as symbol pushing
20:14:56 <roconnor> byorgey: I wanted to argue that lambda calculus was more expressive, able to support higher order functions.
20:15:21 <roconnor> I'm not sure I can pull off that argument though.
20:16:12 <byorgey> roconnor: Turing machines support higher order functions just fine.  Just use a universal TM and pass a description of a TM that implements the function you want.
20:16:52 <roconnor> byorgey: that is one way of doing higher order functions, but different from the type II turing machines.
20:17:15 <roconnor> byorgey: the question is if you accept non-computable function parameters or not.
20:17:34 <byorgey> I see.
20:18:14 <byorgey> well, bedtime for me
20:18:36 <conal> byorgey: sweet dreams
20:19:21 <SamB_XP_> roconnor: from a human point of view, lambda calculus is more expressive, yes
20:19:36 <SamB_XP_> but both frameworks are just as computationally able
20:20:20 <roconnor> SamB_XP_: well, the lambda calculus terms can operate on uncomputable functions
20:20:36 <roconnor> can't do that with turing machines.
20:20:42 <dolio> Turing machines can call magical oracles.
20:20:42 <roconnor> without some modifications.
20:21:01 <SamB_XP_> we're assuming that the initial tape state is replaced by a lambda term, though
20:24:10 <copumpkin> "Using curly braces to pass input into the map function. Ugh, I don't even want to think about how poorly this translates into inefficient machine code."
20:24:13 <copumpkin> that's quite a gem
20:24:31 <Gracenotes> what is this now
20:24:51 <Gracenotes> if I move quickly I can purchase a tuna salad sandwich
20:25:17 <dolio> That looks like English, but it isn't making sense to me.
20:26:32 <Gracenotes> curly braces have more 1s in them than other ASCII characters, so the CPU has more problems moving them around
20:26:34 <c_wraith> where is this?
20:26:55 <copumpkin> http://www.reddit.com/r/programming/comments/9lv9g/is_scala_really_more_complicated_than_java/c0dc91a
20:27:11 <copumpkin> I'm tempted to submit that to /r/bestof
20:27:12 <Gracenotes> use control characters for marking code -- cut down on runtime
20:27:21 <copumpkin> best of programming language trolling failures, ath tis
20:27:24 <copumpkin> that is
20:27:29 <copumpkin> wow, that was a pretty big typing fail too :P
20:27:54 <Gracenotes> there is an /r/worstof
20:28:01 <copumpkin> yeah, but this one is funny
20:28:26 <seanstickle> That's *exactly* why I write my Haskell in nasm
20:28:26 <Gracenotes> hm, I can imagine him making a blog post entitled "10 Levels of Fail"
20:28:27 <copumpkin> it sounds like a fake troll as a parody of redditnoob and the other anti-FP trolls
20:28:41 <copumpkin> but he doesn't seem fake
20:28:46 <copumpkin> which makes it funnier :P
20:28:48 <dolio> That one line would definitely be better as about 6 lines in Java.
20:28:53 <dolio> Much simpler.
20:29:47 <c_wraith> It's only 4 lines of java.  4 prints. :)
20:30:14 <copumpkin> the question is, is your code to write the happy birthday song shorter than the text of the song it generates?
20:30:15 <dolio> My bad.
20:30:22 <dolio> I was thinking of writing the loop equivalent.
20:30:37 <SamB_XP_> c_wraith: you forgot the class & the method
20:31:01 <c_wraith> 1 really long print! :)
20:31:54 <jamesswift> Maybe a haskell programmer can describe to me how they would tackle this problem I asked about in the clojure channel. Given the inTree how would you transform to the outTree http://paste.lisp.org/display/87340 ?
20:32:32 <copumpkin> oh, a trie?
20:33:29 <jamesswift> it's something i can describe easily imperatively but 'm having a tough time wrapping my brain around a functional way to do this
20:34:18 <jamesswift> does the question make sense?
20:34:29 <copumpkin> yep
20:34:30 <Cale> jamesswift: I would sort the lists, group by the first element, and then recurse.
20:35:18 <copumpkin> Cofree []
20:35:19 <copumpkin> !
20:36:03 <jamesswift> feel like pasting some haskell to demonstrate this?
20:38:10 * Axman6 drinks a big cup of Cofree
20:39:41 <copumpkin> jamesswift: just writing some right now, give me a few
20:40:04 <jamesswift> thanks very much! will help me a lot on this sleepy sunday afternoon
20:40:32 <aavogt> @localtime jamesswift
20:40:33 <lambdabot> Local time for jamesswift is 2009-09-20 13:40:33 +1000
20:40:51 <jamesswift> sydney :)
20:40:59 <Cale> @let trie xs = [Node (head u) (trie . map tail $ u:us) | (u:us) <- groupBy ((==) `on` head) . dropWhile null . sort $ xs]
20:41:00 <lambdabot>  Defined.
20:41:07 <Cale> kinda ugly yet, but it works
20:41:15 <Axman6> > 2**(-53) :: Double
20:41:16 <roconnor> jamesswift: transfrom x = let y = groupBy ((==) `on` head) x in Node ( ...
20:41:16 <lambdabot>   1.1102230246251565e-16
20:41:19 <roconnor> bah, lost
20:41:22 <Cale> > trie [[1,2],[1,2,3],[1,2,4,5,9],[1,2,4,10,15],[1,2,4,20,25]]
20:41:23 <lambdabot>   [Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = [Node {...
20:41:25 <jamesswift> great, thanks. i'll          have a play with that
20:41:25 <roconnor> Cale++
20:41:29 <copumpkin> Cale: how did you get the Node type?
20:41:29 <Cale> Too bad the show instance blows
20:41:34 <Cale> copumpkin: Data.Tree
20:41:37 <copumpkin> oh nice :)
20:41:39 <copumpkin> that's simpler
20:41:55 <Axman6> jamesswift: if you're in sydney on the 2nd, you should come to SAPLING at the Uni of Sydney
20:42:04 * Axman6 is coming up from canberra for it
20:42:08 <roconnor> oh right, sort
20:42:19 <jamesswift> sounds good
20:42:29 <jamesswift> thanks for the heads-up
20:42:57 <Axman6> http://plrg.ics.mq.edu.au/news/show/13
20:43:01 <Cale> > levels . trie $ [[1,2],[1,2,3],[1,2,4,5,9],[1,2,4,10,15],[1,2,4,20,25]]
20:43:02 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
20:43:02 <lambdabot>         against inferred ty...
20:43:11 <Cale> oh, right
20:43:15 <Cale> > map levels . trie $ [[1,2],[1,2,3],[1,2,4,5,9],[1,2,4,10,15],[1,2,4,20,25]]
20:43:16 <lambdabot>   [[[1],[2],[3,4],[5,10,20],[9,15,25]]]
20:43:43 <dolio> That doesn't contain indicators of which strings were in the original list, though.
20:43:59 <Cale> right
20:44:19 <jamesswift> axman, thanks for the link. i'll try and make it.
20:44:25 <Axman6> :)
20:44:29 <Cale> But since there's no convenient fold for this sucky tree type, and the show instance sucks...
20:44:38 <dolio> Which is what the null lists are for in the lisp.
20:44:39 <jamesswift> ahh wait, it's on during the day :(
20:44:42 <Axman6> not sure how big it's going to be, pretty sure it'll be quite small, but the more the better :)
20:44:50 <Axman6> yeah, all day thing
20:44:50 <dolio> I think.
20:44:57 * Axman6 will be on holidays then
20:45:05 <Cale> oh, right, yeah
20:45:11 <jamesswift> hmm, unlikely i can make it for more than a long lunch. working.
20:45:22 <Cale> Not much we can do about that either, without picking a better type.
20:45:23 <dolio> (Although there isn't one in the 3 node, where there should be.)
20:45:34 <dolio> Yeah. A real trie would be what you'd want.
20:45:47 <Cale> Maybe I'll hardcode a proper datatype into lambdabot's L.hs for fun
20:45:51 <dolio> We don't build everything out of rose trees. :)
20:46:42 <Cale> I'd be happy just to have a rose tree in the libraries which wasn't crap :P
20:47:12 <dolio> That record syntax show is pretty heinous.
20:47:16 <mmorrow> Cale: how would you change Data.Tree?
20:47:38 <dolio> Although making it look non-terrible would violate the whole "show should output Haskell" thing, I guess.
20:47:44 <Cale> mmorrow: Don't use record syntax, for one.
20:47:56 <mmorrow> yeah, record syntax in Show is painful
20:47:59 <dolio> Although even Node a [...] would be better.
20:48:15 <aavogt> > drawTree (Node "a" [Node "b" [],Node "c" []])
20:48:16 <lambdabot>   "a\n|\n+- b\n|\n`- c\n"
20:48:18 <mmorrow> the only reason it's visible is on account of the Show instance..
20:48:18 <Cale> Oh, heh, I wonder...
20:48:24 <aavogt> > text $ drawTree (Node "a" [Node "b" [],Node "c" []])
20:48:25 <lambdabot>   a
20:48:25 <lambdabot>  |
20:48:25 <lambdabot>  +- b
20:48:25 <lambdabot>  |
20:48:25 <lambdabot>  `- c
20:48:26 <Cale> :t out
20:48:27 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
20:48:35 <Cale> hmmm :)
20:48:56 <mmorrow> , muT [0..7]
20:48:58 <lunabot>  Mu (T (Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (...
20:49:01 <mmorrow> , muT [0..3]
20:49:03 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
20:49:19 <Axman6> , [$ty|myT|]
20:49:21 <lunabot>  luna: Exception when trying to run compile-time code:
20:49:23 <copumpkin> oh my
20:49:35 <copumpkin> , [$ty|muT|]
20:49:38 <lunabot>  forall a . [] a -> Mu (T a)
20:49:41 <copumpkin> cute
20:49:51 <mmorrow> , [$ty|muT'|]
20:49:52 <Axman6> whoops
20:49:53 <lunabot>  forall a . [] a -> Mu (T a)
20:50:06 <mmorrow> muT' alternates directions it runs over the list
20:50:21 <copumpkin> sounds hardcore
20:50:23 <mmorrow> , muT' [0..7]
20:50:25 <lunabot>  Mu (T (Mu (T (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))) (Mu (T (Mu (Tip 0)) (Mu (...
20:50:37 <mmorrow> copumpkin: not very :)
20:52:00 <dolio> T a x = T x x | Tip a?
20:52:27 <Cale> Yeah, you'd still need to define a proper polynomial functor for the tree-ness
20:52:46 <Axman6> , muT [1,2,3]
20:52:48 <lunabot>  Mu (T (Mu (T (Mu (Tip 1)) (Mu (Tip 2)))) (Mu (Tip 3)))
20:52:59 <Axman6> , muT [1,2,3,4]
20:53:01 <lunabot>  Mu (T (Mu (T (Mu (Tip 1)) (Mu (Tip 2)))) (Mu (T (Mu (Tip 3)) (Mu (Tip 4)))))
20:53:57 <mmorrow> dolio: http://moonpatio.com/repos/lunabot/Luna/Bot/Lib/T.hs
20:54:08 <mmorrow> (and Mu.hs in that same dir)
20:54:27 <Cale> :t Branch
20:54:28 <mmorrow> , src ''T
20:54:28 <lambdabot> Not in scope: data constructor `Branch'
20:54:30 <lunabot>  data T a b = Nil | Tip a | T b b
20:54:30 <Cale> hmm
20:54:36 <dolio> Oh.
20:54:38 <mmorrow> , src ''Mu
20:54:41 <lunabot>  newtype Mu f = Mu (f (Mu f))
20:54:47 <mmorrow> , src ''BinT
20:54:49 <lunabot>  newtype BinT a = BinT {unBinT :: (Mu (T a))}
20:54:50 <dolio> , muT []
20:54:51 <Cale> > Branch 5 [Tip]
20:54:52 <lambdabot>   L.hs:80:12:
20:54:52 <lambdabot>      No instance for (Eq (f (Mu f)))
20:54:52 <lambdabot>        arising from the 'd...
20:54:52 <lunabot>  Mu Nil
20:54:56 <Cale> er.
20:55:03 <Cale> > Branch 5 [Tip]
20:55:04 <lambdabot>   Branch 5 [Tip]
20:57:28 <mmorrow> , $(foldT [|0|] (\a b -> [|($a,$b)|]) (muT (fmap lift [0..3::Int])) id)
20:57:30 <lunabot>  ((0,1),(2,3))
20:57:40 <mmorrow> , $(foldT [|0|] (\a b -> [|($a,$b)|]) (muT (fmap lift [0..7::Int])) id)
20:57:41 <lunabot>  (((0,1),(2,3)),((4,5),(6,7)))
20:57:47 <mmorrow> , $(foldT [|0|] (\a b -> [|($a,$b)|]) (muT (fmap lift [0..15::Int])) id)
20:57:49 <lunabot>  ((((0,1),(2,3)),((4,5),(6,7))),(((8,9),(10,11)),((12,13),(14,15))))
20:58:15 <mmorrow> , (snd . fst . fst . snd) ((((0,1),(2,3)),((4,5),(6,7))),(((8,9),(10,11)),((12,13),(14,15))))
20:58:16 <lunabot>  9
20:58:44 <Axman6> reminds me too much if lisp :(
20:59:04 <Cale> @let trie xs = [case u of [] -> Tip; (v:vs) -> Branch v (trie . map tail $ v:vs) | (u:us) <- groupBy ((==) `on` take 1) . sort]
20:59:04 <lambdabot>  <local>:1:88:
20:59:05 <lambdabot>      Couldn't match expected type `[t]'
20:59:05 <lambdabot>             against in...
20:59:06 <dolio> cdaadr
20:59:07 <Cale> hmm
20:59:24 <Cale> oh, pff
20:59:30 <Cale> @let trie xs = [case u of [] -> Tip; (v:vs) -> Branch v (trie . map tail $ v:vs) | (u:us) <- groupBy ((==) `on` take 1) . sort $ xs]
20:59:30 <lambdabot>  <local>:1:70:
20:59:31 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]...
20:59:47 <mmorrow> , let t = ((((0,1),(2,3)),((4,5),(6,7))),(((8,9),(10,11)),((12,13),(14,15)))) in ($ t) =<< fmap (foldr (.) id) (replicateM 4 [fst,snd])
20:59:48 <lunabot>  luna: Couldn't match expected type `((((t, t1), (t2, t3)),
20:59:51 <Cale> er, right
20:59:58 <Cale> @let trie xs = [case u of [] -> Tip; (v:vs) -> Branch v (trie . map tail $ u:us) | (u:us) <- groupBy ((==) `on` take 1) . sort $ xs]
20:59:59 <lambdabot>  Defined.
21:00:02 <mmorrow> , let t = ((((0,1),(2,3)),((4,5),(6,7))),(((8,9),(10,11)),((12,13),(14,15)))) in ($ t) <$> fmap (foldr (.) id) (replicateM 4 [fst,snd])
21:00:02 <Cale> good
21:00:07 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = (t, t1)
21:00:12 <mmorrow> grr
21:00:17 <Cale> > trie $ [[1,2],[1,2,3],[1,2,4,5,9],[1,2,4,10,15],[1,2,4,20,25]]
21:00:18 <lambdabot>   [Branch 1 [Branch 2 [Tip,Branch 3 [Tip],Branch 4 [Branch 5 [Branch 9 [Tip]]...
21:00:43 <Cale> Thar we go.
21:00:51 <Axman6> YARRR
21:00:55 <jamesswift> very nice
21:00:58 <mmorrow> @arrrrgyle socks
21:00:58 <lambdabot> Unknown command, try @list
21:01:04 <mmorrow> @yarrrrgyle socks
21:01:04 <lambdabot> Unknown command, try @list
21:01:09 <mmorrow> :(
21:01:18 <Cale> @arr
21:01:18 <lambdabot> Arrr!
21:02:23 <mmorrow> @let gather (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
21:02:24 <lambdabot>  Defined.
21:02:51 <Cale> @let roseFold t b = f where f Tip = t; f (Branch x ts) = b x (map f ts)
21:02:52 <lambdabot>  Defined.
21:02:54 <Axman6> :t gather
21:02:55 <lambdabot> forall a b k. (Ord k) => (a -> a -> a) -> (b -> k) -> (b -> a) -> [b] -> M.Map k a
21:03:26 <dolio> Last I checked "yarrrrgyle" is more than 2 edits away from "arr".
21:04:00 <Axman6> @botsnackyumyumyum
21:04:00 <lunabot>  :o
21:04:00 <lambdabot> Unknown command, try @list
21:04:04 <Axman6> :(
21:05:39 <Cale> > map (roseFold "t" (\x ts -> concat ["(b ",show x," ",unwords ts,")"])) . trie $ [[1,2],[1,2,3],[1,2,4,5,9],[1,2,4,10,15],[1,2,4,20,25]]
21:05:40 <lambdabot>   ["(b 1 (b 2 t (b 3 t) (b 4 (b 5 (b 9 t)) (b 10 (b 15 t)) (b 20 (b 25 t)))))"]
21:06:20 <Cale> > map (roseFold "()" (\x ts -> concat ["(",show x," ",unwords ts,")"])) . trie $ [[1,2],[1,2,3],[1,2,4,5,9],[1,2,4,10,15],[1,2,4,20,25]]
21:06:21 <lambdabot>   ["(1 (2 () (3 ()) (4 (5 (9 ())) (10 (15 ())) (20 (25 ())))))"]
21:06:56 <Cale> jamesswift: ^^ :)
21:07:20 <jamesswift> thanks folks! :)
21:08:16 <Cale> jamesswift: But the basic algorithm is to first sort the lists, and then group them by their first element. One thing which could be avoiding is that I do the sort every step, which is ugly, since it's unnecessary after the first.
21:08:24 <Cale> avoided*
21:09:17 <jamesswift> sure, but i'm more interested in learning the algorithm first. thanks again.
21:09:28 <roconnor> doing sort on head at each step would be more lazy?
21:10:17 <roconnor> hmm, but doesn't handle empty lists
21:10:53 <roconnor> > sort [[1,2,3],[1,2,undefined]]
21:10:54 <lambdabot>   * Exception: Prelude.undefined
21:11:05 <roconnor> > head $ head $ sort [[1,2,3],[1,2,undefined]]
21:11:06 <lambdabot>   * Exception: Prelude.undefined
21:11:59 <roconnor> we really ought to build the tree lazily if we want to be gold star haskell programers
21:12:19 <Cale> Hard to be too lazy about it...
21:12:41 <Cale> Though I suppose you could have a finite set of infinite lists to begin with.
21:12:57 <Cale> and then it becomes an issue
21:13:02 <roconnor> Cale: you ought to be able to build the top node of the tree by only looking at the head of each list.
21:13:36 <roconnor> Cale: ah right, a finite list of infinite lists won't be even handled by your algorithm
21:15:49 <dolio> You could sortBy (comparing $ take 1) perhaps.
21:16:14 <roconnor> that would be better.
21:16:59 <roconnor> we need a proper sortandgroupbywithtrace :: (a -> b) -> [a] -> [(b,[a])]
21:17:36 <roconnor> I'm tempted to use Data.Map here
21:17:55 <roconnor> or rather Mu (Data.Map.Map k)
21:18:13 <mmorrow> @let trieify [] = []; trieify xs = fmap (uncurry Node . fmap trieify) . M.toList . gather (++) head ((:[]) . tail) . filter (not . null) $ xs in trieify
21:18:13 <lambdabot>   Parse error: KW_In
21:18:18 <mmorrow> @let trieify [] = []; trieify xs = fmap (uncurry Node . fmap trieify) . M.toList . gather (++) head ((:[]) . tail) . filter (not . null) $ xs
21:18:19 <lambdabot>  Defined.
21:18:22 <roconnor> er MulitMap
21:18:29 <roconnor> do we have a MultiMap?
21:18:41 <mmorrow> > trieify ["aaa","bba","aba"]
21:18:42 <lambdabot>   [Node {rootLabel = 'a', subForest = [Node {rootLabel = 'a', subForest = [No...
21:18:51 <mmorrow> > levels (trieify ["aaa","bba","aba"])
21:18:51 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
21:18:51 <lambdabot>         against inferred ty...
21:19:30 <roconnor> > map levels (trieify ["aaa","bba","aba"])
21:19:31 <lambdabot>   [["a","ab","aa"],["b","b","a"]]
21:20:04 <roconnor> > levels (Node (trieify ["aaa","bba","aba"]))
21:20:05 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
21:20:05 <lambdabot>         against inferred ty...
21:20:15 <roconnor> ah right
21:20:29 <mmorrow> > fmap levels . trieify $ ["aaa","bba","aba"]
21:20:30 <lambdabot>   [["a","ab","aa"],["b","b","a"]]
21:20:53 <roconnor> > head $ head $ map levels (trieify ["aaa","bba", 'a':'b':undefined])
21:20:54 <lambdabot>   "a"
21:20:59 <roconnor> :)
21:21:16 <roconnor> that pleases me
21:21:22 <roconnor> mmorrow++
21:21:33 <mmorrow> yay!
21:22:00 <roconnor> I'm not sure why that works with your foldl' though
21:22:19 <mmorrow> it does that once for each level, to gather the like prefix
21:22:33 <mmorrow> and it never gets to that last level
21:22:34 <roconnor> ah
21:22:41 <roconnor> thats okay to be strict
21:22:56 <roconnor> cause we need to go through the head of each list anyways
21:22:57 <copumpkin> that's what she said
21:23:01 <mmorrow> right
21:25:22 <roconnor> we need a MonoidMap
21:26:08 <SamB_XP_> copumpkin: that ... doesn't make sense ...
21:33:42 <roconnor> > compare [1,2] (1:undefined)
21:33:43 <lambdabot>   * Exception: Prelude.undefined
21:33:49 <roconnor> > compare [0,2] (1:undefined)
21:33:50 <lambdabot>   LT
21:34:28 <roconnor> > head $ head $ sort [[1,2,3],[1,3,undefined]]
21:34:29 <lambdabot>   1
21:34:33 <roconnor> hmm
21:34:46 <roconnor> maybe Cale's is lazy enough
21:35:52 <roconnor> > head $ head $ map levels (trie ["aaa","bba", 'a':'b':undefined])
21:35:53 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
21:35:53 <lambdabot>         against inferred ty...
21:36:07 <roconnor> > map levels (trie ["aaa","bba", 'a':'b':undefined])
21:36:08 <lambdabot>   Couldn't match expected type `Data.Tree.Tree a'
21:36:08 <lambdabot>         against inferred ty...
21:36:12 <roconnor> @type trie
21:36:13 <lambdabot> forall a. (Ord a) => [[a]] -> [Rose a]
21:36:54 <roconnor> > head $ map (roseFold "()" (\x ts -> concat ["(",show x," ",unwords ts,")"]))  (trie ["aaa","bba", 'a':'b':undefined])
21:36:55 <lambdabot>   "('a' ('a' ('a' ())) ('b' * Exception: Prelude.undefined
21:37:42 <roconnor> > map (roseFold "()" (\x ts -> concat ["(",show x," ",unwords ts,")"]))  (trie ["aaa","bba", 'a':'b':undefined])
21:37:43 <lambdabot>   ["('a' ('a' ('a' ())) ('b' * Exception: Prelude.undefined
21:38:02 <roconnor> > tail $ map (roseFold "()" (\x ts -> concat ["(",show x," ",unwords ts,")"]))  (trie ["aaa","bba", 'a':'b':undefined])
21:38:03 <lambdabot>   ["('b' ('b' ('a' ())))"]
21:38:10 <roconnor> Cale++
21:38:34 <roconnor> sort++ -- for being so lazy
21:38:48 <roconnor> well
21:38:56 <Cale> Oh, it does work?
21:39:01 <roconnor> compare++ -- for being so lazy for lists
21:39:04 <Cale> hmm
21:39:13 <Cale> ah
21:39:47 <aavogt> > compare minBound (undefined :: Int) < GT
21:39:48 <lambdabot>   * Exception: Prelude.undefined
21:40:24 <copumpkin> ray: the.ug?
21:49:16 <ray> copumpkin: the ug
21:49:51 <copumpkin> ray: you're really weird :P
22:12:13 <sereven> z f = fmap (Endo . f) :: (Functor f) => (a1 -> a -> a) -> f a1 -> f (Endo a) -- suggestions for name for z or if it's already around somewhere?
22:12:53 <copumpkin> why would you stick Endo on there?
22:13:06 <sereven> so can use the monoid instance
22:14:08 <sereven> but, yeah, need to look at doing it without too, make sure it's really worth it
22:19:38 <aavogt> @unpl (fmap Endo .) . fmap
22:19:39 <lambdabot> (\ d g -> fmap Endo (fmap d g))
22:20:16 <aavogt> so unpl doesn't know about the functor laws
22:22:03 <copumpkin> no, it's super naive
22:22:09 <FunctorSalad_> hmm was this hackage dependency graph dynamically generated or was it a one-shot?
22:24:40 <copumpkin> one-shot I think
22:25:15 <ivanm> mmorrow: you still around?
22:31:57 <sereven> copumpkin: doh! I'm super naive, too, my f (a -> a) already has monoid instance, don't need Endo at all. whoo hoo, hehe so z can be fmap
22:32:04 <copumpkin> :)
22:33:55 <ivanm> @ask bos doesn't statistics do random anymore, that you dropped mersenne-random as a dep?
22:33:56 <lambdabot> Consider it noted.
22:36:25 <copumpkin> ivanm: hm?
22:36:43 <ivanm> was I taling to you? ;-)
22:36:46 <ivanm> *talking
22:37:04 <ivanm> copumpkin: statistics-0.2.* had a dep on mersenne-random; 0.3.* doesn't
22:37:04 <copumpkin> just curious :P
22:37:12 <copumpkin> he wrote his own random generator
22:37:17 <copumpkin> even has a blog post on it
22:37:38 <copumpkin> it's epicly fast!
22:37:40 <copumpkin> and in ST
22:38:42 <ivanm> ahhh
22:38:50 * ivanm doesn't recall seeing it on planet...
22:38:58 <ivanm> unless it just came out whilst I was sleeping...
22:39:01 <copumpkin> I just saw it on reddit cause I'm a reddit whore
22:39:24 * ivanm hasn't gotten to the haskell reddit yet
22:41:57 <maltem> Interesting, a random number algorithm for normal distributions
22:42:59 <copumpkin> yeah, I've wanted one
22:43:43 <mmorrow> ivanm: yes
22:43:56 <maltem> oh, it isn't really - the normal distribution is implemented in terms of the uniform one. Well that's less interesting
22:44:20 <ivanm> mmorrow: with your suggestion of writing my own State monad, would you care to check what I did?
22:44:30 * maltem goes to that blog post by bos
22:44:53 <copumpkin> maltem: that's the obvious way of doing it I guess :)
22:45:50 <maltem> copumpkin, I suppose, I just initially thought that the point of the module is that it's not done the obvious way :)
22:46:47 <mmorrow> ivanm: not at all :)
22:46:55 <ivanm> http://dpaste.com/95762/
22:47:03 <copumpkin> :o
22:49:40 <twb> There's no way to tell cabal-install to compile objects in parallel (like make -j8), is there?
22:49:50 <ivanm> @tell bos nvm, found your blog post
22:49:50 <lambdabot> Consider it noted.
22:50:05 <ivanm> twb: dunno... you might be able to pass it as a cflag or something
22:50:16 <ivanm> but I'm not sure if GHC itself can do parallel compilation
22:50:37 <copumpkin> twb: not yet, nope
22:50:45 <twb> OK, just checking.
22:50:50 <copumpkin> twb: there was some work on making that happen just recently though
22:50:57 <copumpkin> don't think it's quite ready yet though
22:51:08 <mmorrow> ivanm: oh nice, /me looks
22:51:23 <kroo> hiya copumpkin
22:51:26 <copumpkin> hi kroo
22:51:35 <mmorrow> ivanm: here's the State monad i use for 90% of my monad needs http://moonpatio.com/repos/S.hs
22:52:14 <kroo> I've decided I rather like haskell
22:52:20 <kroo> http://pastie.textmate.org/private/5i8hbk9ewbweulvehesow
22:52:23 <copumpkin> kroo: I'm glad to hear it, and this is only the beginning :)
22:52:26 <ivanm> mmorrow: :o
22:52:45 <ivanm> mmorrow: I have no idea wtf I'm even looking at there :s
22:52:52 <ivanm> what's with all the foralls, etc.?
22:53:13 <mmorrow> ivanm: nice, looks good. so there are two choices for (>>=) for vanilla state. `let' of `case', the former being lazy and the latter making (>>=) strict
22:53:20 <mmorrow> s/of/or/
22:53:28 <mmorrow> ivanm: so State is
22:53:37 <mmorrow> State s a = S (s -> (a,s))
22:53:46 <ivanm> right
22:54:06 <mmorrow> imagine that we just wait to apply the (,) :: a -> s -> (a,s)
22:54:18 <mmorrow> State s a = S (s -> (a -> s -> (a,s)) -> (a,s))
22:54:29 <ivanm> hmmmm..... why would you do that?
22:54:36 <mmorrow> but why fix the tuple? ==> State s a = S (forall o. s -> (a -> s -> o) -> o)
22:54:42 <mmorrow> flipping to
22:54:51 <mmorrow> State s a = S (forall o. (a -> s -> o) -> s -> o)
22:55:00 <copumpkin> kroo: what I like about haskell is that there's so much depth, despite a reasonably simple language
22:55:03 <mmorrow> @unmtl ReaderT s (Cont o) a
22:55:03 <lambdabot> s -> (a -> o) -> o
22:55:09 <mmorrow> oops
22:55:12 <ivanm> so you're having your state depend on the current value as well?
22:55:27 <mmorrow> @unmtl Cont o (ReaderT s) a
22:55:27 <lambdabot> err: `ReaderT s' is not applied to enough arguments, giving `/\A B. s -> A B'
22:55:31 <mmorrow> @unmtl ContR o (Reader s) a
22:55:31 <lambdabot> ContR o (Reader s) a
22:55:34 <mmorrow> gah!
22:55:37 <kroo> copumpkin: definately :)  I also like how well it maps to more formalized math/cs stuff
22:55:37 <mmorrow> @unmtl ContT o (Reader s) a
22:55:37 <lambdabot> (a -> s -> o) -> s -> o
22:55:46 <mmorrow> @unmtl StateT s (Cont o) a
22:55:46 <lambdabot> s -> (a -> s -> o) -> o
22:56:08 <Jafet> C++ is deep too!
22:56:37 <mmorrow> so that S is the same an a flattened ContT o (Reader s) a, which is the same as a flattened StateT s (Cont o) a, BUT with the `o' forall'ed, which makes it equivalent to State
22:57:01 <kroo> (I decided that I'd think about putting together a real-time collaboration library in haskell -- http://portal.acm.org/citation.cfm?id=240305 translated pretty painlessly to haskell
22:57:12 <ivanm> mmorrow: and I have no idea what Cont is :p
22:57:25 <mmorrow> C o a = C ((a -> o) -> o)
22:57:40 <mmorrow> return a = C (\k -> k o)
22:58:02 * ivanm isn't quite share what that is or what it's for...
22:58:29 <mmorrow> C g >>= f = C (\k -> g (\a -> unC (f a) k))
22:58:37 * mmorrow makes sure ;)
22:58:45 <mmorrow> @src Cont (>>=)
22:58:45 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
22:58:53 <dabblego> return a = C (\k -> k a)
22:58:54 <mmorrow> yeah
22:59:04 <mmorrow> dabblego: oops, right
22:59:24 <ivanm> what's the "point" of Cont?
22:59:36 <mmorrow> > runCont (callCC (\k -> forever (k 42 >> undefined))) id
22:59:36 <lambdabot>   42
22:59:38 <ivanm> Reader is for read-only values, Writer is for logging, State is for... state...
22:59:46 <ivanm> @type forever
22:59:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:59:54 <ivanm> wtf?
23:00:13 <mmorrow> if you unroll Cont's (>>=)
23:00:26 <mmorrow> say   type C o a = (a -> o) -> o
23:00:49 <Makoryu> ivanm: Think about it... forever never returns ;)
23:00:54 <ivanm> ahhhh
23:00:58 <mmorrow> g >>= f = \k ->    g (\a -> f a k)
23:01:01 <ivanm> so what's the point?
23:01:22 <mmorrow> so `g' gets *everything* after >>= as an arg
23:01:36 <mmorrow> so g could just discard it if it wanted
23:01:41 <Makoryu> ivanm: Of forever...?
23:01:47 <ivanm> Makoryu: yes
23:02:13 <ivanm> mmorrow: and for Cont, the a value is provided by callCC?
23:02:22 <mmorrow> > runCont (Cont (const 999999) >>= undefined) (*2)
23:02:23 <lambdabot>   999999
23:02:51 <ivanm> wait, Cont is the monadic form of const ?
23:02:52 <mmorrow> \k -> const 999999 (\a -> undefined a (*2))
23:02:53 <Makoryu> ivanm: I don't understand continuations either. No idea what's going on there :p
23:03:15 <mmorrow> ivanm: i was just showing that you can throw away the "rest" of the computation
23:03:16 <ivanm> Makoryu: heh
23:03:47 <ivanm> mmorrow: you've lost me completely ;-)
23:03:49 <ivanm> @type runCont
23:03:50 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
23:04:01 <BMeph> Continuations are the "ultimate" control structure. :)
23:04:01 <ivanm> @src Cont
23:04:01 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
23:04:12 <ivanm> gah, where does the a come from? :s
23:04:28 <mmorrow> ivanm: it's just a pre-packaged instance of the same idea as e.g.
23:04:40 <CalJohn_> Control.Concurrent.STM requires a transaction to read, so essentially writers will be delayed when the structure is being read, right?
23:04:41 <mmorrow> (DBConnection -> IO a) -> IO a
23:05:06 <mmorrow> withDB (\db -> query db "SELECT * FROM t") :: IO [String]
23:05:30 <CalJohn_> i just read a clojure talk about how clojure's stm is not "stop the structure"
23:05:38 <mmorrow> withDB hides the connecting bit to make things simpler, and you give it a function that takes a DBConn and does something useful
23:06:16 <mmorrow> (return 9 :: Cont Int) hides the Int'ing bit, and you give it a function that takes an Int and does something useful
23:06:41 <ivanm> mmorrow: ummmm..... OK....
23:06:44 <ivanm> (maybe...)
23:07:16 <mmorrow> ivanm: mostly the only real reason you'd use Cont is for callCC really (or at least, that's the only reason i ever use it)
23:07:26 <ivanm> @type callCC
23:07:26 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
23:07:37 <ivanm> ummmm.... OK...
23:07:57 <mmorrow> one way to think of callCC is a way to get the same behavior as throwError in the Error monad
23:08:45 * ivanm has never encountered throwError before either...
23:08:53 <ivanm> I typically write a lot non-monadic code ;-)
23:10:33 <mmorrow> > runErrorT (forever (throwError "oh hai" >>= undefined)) :: [Either String Int]
23:10:33 <lambdabot>   [Left "oh hai"]
23:10:43 <mmorrow> ivanm: i never use Error myself either
23:11:07 <ivanm> mmorrow: what's with all the ">>= undefined" though?
23:11:12 <mmorrow> ivanm: really, i literally only use that S monad, and occasionally a mixture of that and Cont
23:11:15 <ivanm> doesn't that make the whole thing undefined?
23:11:22 <mmorrow> ivanm: to show that you can escape
23:11:27 <ivanm> ummm, OK
23:11:34 <mmorrow> like an exception
23:11:42 <ivanm> mmorrow: well, I still don't see why your S monad has a function that takes two parameters
23:11:51 <mmorrow> @type (,)
23:11:51 <lambdabot> forall a b. a -> b -> (a, b)
23:11:58 <mmorrow> a -> s -> o
23:11:59 <ivanm> yes, I got that bit
23:12:01 <ivanm> but _why_
23:12:24 <mmorrow> because the end result of running an S computation is an `a' and an `s'
23:12:41 <mmorrow> and that function is the _continuation_ which gets handed those results and does something useful
23:12:57 <mmorrow> in vanilla State, the continuation is hardcoded as (,)
23:13:23 <mmorrow> notice the def of {eval,exec}S
23:13:32 <mmorrow> to fst/snd needed
23:13:41 <mmorrow> it avoids the tuple altogether
23:14:10 <mmorrow> and, in (>>=) you never build a (,) just to take it apart immediately
23:14:52 <mmorrow> <mmorrow> to fst/snd needed
23:14:58 <mmorrow> NO fst/snd ...
23:15:18 <ivanm> mmorrow: in vanilla State, the func has only one parameter...
23:15:25 <ivanm> you're taking _two_
23:15:44 <ivanm> maybe I'm not understanding what a continuation is, but that makes no sense to me
23:15:52 <mmorrow> ivanm: the "function" in vanilla state has already been applied to the `a' and `s'
23:15:57 <mmorrow> ==> (a,s)
23:16:13 <ivanm> right...
23:19:13 <ski> mmorrow : `shift' and `reset'
23:19:16 <mmorrow> ivanm: oh right. ok, so that "extra" `a' in there is the **final end `a'**
23:19:24 <mmorrow> ski: yeah, them too :)
23:19:41 <ivanm> mmorrow: so the final output depends on the final output? :s
23:20:39 <mmorrow> ivanm: err, disregard my last comment
23:20:57 <ivanm> heh
23:21:01 <mmorrow> i'm starting to imagine things now :)
23:21:55 <mmorrow> ivanm: it may help to unroll >>= a few times
23:22:09 <ski> , [$ty| \xs -> MkContT2 $ \k -> mapM k xs |]
23:22:12 <lunabot>  forall o m a . Monad m => [] a -> ContT2 o ([] o) m a
23:23:02 <mmorrow> but either way, just like a lot of things in math, it's not that you eventually _understand_, you just get comfortable thinking about them
23:23:19 <mmorrow> because there's no one way to think about it
23:23:34 <ski> , [$ty| S |]
23:23:37 <lunabot>  SKI
23:23:39 <ski> .. er
23:23:41 <mmorrow> hah
23:23:54 <ski> (what's the `S' monad ivanm was talking about ?)
23:24:16 <mmorrow> , [$ski|S[f::Expr->Expr->Expr][g][x::Expr]|]
23:24:18 <lunabot>  f x (g x)
23:24:25 <ivanm> ski: http://moonpatio.com/repos/S.hs
23:24:42 <ski> (`newtype S a = S (forall o. s -> (a -> s -> o) -> o' more or less ?)
23:24:50 <mmorrow> right
23:24:50 <dmwit> > ap (f :: Expr -> Expr -> Expr) g x
23:24:51 <lambdabot>   f x (g x)
23:25:06 <mmorrow> @unmtl ContT o (Reader s) a
23:25:06 <lambdabot> (a -> s -> o) -> s -> o
23:25:28 <mmorrow> ski: edwardk found that the `s' in that position makes it faster
23:25:35 <ski> @unmtl StateT s (Cont o) a
23:25:35 <lambdabot> s -> (a -> s -> o) -> o
23:25:49 <ski> mmorrow : i can imagine that
23:25:52 <mmorrow> (presumably because it enables most of the defs to be partial apps)
23:25:55 <mmorrow> or something
23:26:00 <ski> (since you can eta-reduce `s -> o', then)
23:26:40 <ski> (instead of `\.. s -> ... s' you just have `\.. -> ...')
23:27:44 <ski> .. right. `return' and `(>>=)' there doesn't mention `s'
23:28:58 <mmorrow> ivanm: ok, i just realized how to say it.   S g >>= k = S (\ k{-this gets the end result-} s  -> g (\ a{-this is g's result-} -> unS (f a) k{-pass this on to `f'-})  s )
23:29:21 <ski> (mmorrow : btw, can you see when one'd use `MkContT2 . forM' above ? :)
23:30:16 <mmorrow> (gah, so used to @pl'ing the s's):  S g >>= k = S (\ k{-this gets the end result-} s  -> g (\ a{-this is g's result-} s'{-the state after g mods it-} -> unS (f a) k{-pass this on to `f'-})  s )
23:30:18 <ivanm> mmorrow: with the s in "\ k s" being provided from "outside"
23:30:25 <mmorrow> exactly
23:31:20 <mmorrow> , src ''MkContT2
23:31:21 <lunabot>  luna: Not in scope: type constructor or class `MkContT2'
23:31:30 <mmorrow> , src 'MkContT2
23:31:33 <lunabot>  newtype ContT2 o_0 p_0 m_0 a_0 = ... | MkContT2 ((a -> m o) -> m p) | ...
23:31:33 <lunabot>  infixl 9
23:31:38 <mmorrow> , src ''ContT2
23:31:40 <lunabot>  newtype ContT2 o p m a = MkContT2 {unContT2 :: ((a -> m o) -> m p)}
23:31:58 <mmorrow> @type MkContT2 . forM
23:31:59 <lambdabot> Not in scope: data constructor `MkContT2'
23:32:08 <mmorrow> , [$ty| MkContT2 . forM |]
23:32:11 <lunabot>  forall o m a . Monad m => [] a -> ContT2 o ([] o) m a
23:32:37 <mmorrow> ski: :)
23:33:08 * ski used that once on a laboration, and got complaints that the solution was "too complicated"
23:33:20 <kakeman> haskell is super
23:33:32 <kakeman> this is the way
23:33:33 <copumpkin> yep
23:33:45 <ski> mmorrow : you can use that to factor out the "looping" part of a loop :)
23:33:48 <mmorrow> let m = MkContT2 (forM ["ls","date","ps aux","whoami","hostname"])    in unContT2 m system
23:34:03 <mmorrow> ski: handay
23:35:02 <ski> `forM xs $ \x -> forM ys $ \y -> ...' becomes `do x <- collect xs; y <- collect ys; ...', then you can even factor out the initial bit ;)
23:35:43 <mmorrow> oh nice
23:36:29 <ski> but since i was reconstructing the list of lists, it was essential to use `ContT2' instead of `ContT', since i needed to *change* the result type
23:37:59 <ski> mmorrow : btw, i think you forgot to use  s'  above
23:38:58 <mmorrow> ski: heh, i literally just noticed that too
23:39:48 <mmorrow> {-final answer-}  S g >>= k = S (\ k{-this gets the end result-} s  -> g (\ a{-this is g's result-} s'{-the state after g mods it-} -> unS (f a) k{-pass this on to `f'-} s')  s )
23:39:56 <ski> (and where does `f' come from ?)
23:40:03 <mmorrow> gah!
23:40:06 <ski> (:
23:40:14 <mmorrow> {-final final answer-}  S g >>= f = S (\ k{-this gets the end result-} s  -> g (\ a{-this is g's result-} s'{-the state after g mods it-} -> unS (f a) k{-pass this on to `f'-} s')  s )
23:43:21 <mmorrow> {-might as well at this point-}   get = S (\k s -> k s s); gets f = S (\k s -> k (f s) s); set s = S (\k _ -> k () s); modify f = S (\k s -> k () (f s))
23:44:02 <ski>    S (\(\a s' -> o') s -> o) >>= (\a -> S (\k s' -> o')) = S (\k s -> o)
23:44:45 <ski> (nice, eh ?)
23:45:05 <da-x> suppose you want to implement a process that reads/writes from non-blocking several file descriptor in a poll() loop. what's the haskell way of doing this?
23:47:27 <Cale> da-x: forkIO?
23:47:40 <mmorrow> da-x: since forkIO threads are so cheap, the (ghc) "haskell" way would be to forkIO a thread for each Handle, and use one or more Chan's for communication if needed
23:49:16 <mmorrow> da-x: if you don't want to do that for whatever reason, you can look into the couple functions that hook into ghc's IO-manager (which uses select), or there's always foreign import ccall unsafe "(e)poll" :: ... if you must
23:49:31 <da-x> hmm..
23:50:09 <Cale> But it's usually nice to be able to pretend that your calls to handle operations are blocking, and have the RTS work it out.
23:50:16 <mmorrow> da-x: as an FFI example, this module imports and uses select() (at the bottom) http://moonpatio.com/repos/lunabot/Luna/Bot/Util/Dup.hs
23:50:32 <mmorrow> yeah, forkIO is awesome
23:50:37 <da-x> the underlying mechanism behind forkIO is not implemented with poll()/select()?
23:50:42 <Cale> (it implements what appear to be blocking I/O operations using non-blocking operations, so that I/O from multiple threads will work)
23:53:30 <mmorrow> da-x: it's basically a cooperative multitasking setup, where the compiler inserts context-switch checks to yield() at safe-points (and the rts uses a timer interrupt to trigger context switches) (and will yield() you if you try to read a Handle that's not ready, etc), but from your pov in haskell it's pre-emptive
23:53:54 <mmorrow> well, cooperative at the level of the rts
23:54:45 <ivanm> FlexibleInstances is used for specific instances (e.g. String rather than a generic [a]), right?
23:54:45 <mmorrow> so context switching is hugely less expensive than for os threads
23:54:55 <Cale> ivanm: yeah
23:55:20 <ivanm> any reason not to use it (apart from the normal extension usage stuff)?
23:55:57 <Cale> and iirc, the I/O manager does use select with regard to waiting on fds, but I'm not sure.
23:56:12 <Cale> ivanm: Not particularly, it's pretty safe.
23:56:29 <ivanm> good-o
23:56:38 <da-x> okay, so I don't necessarily need to use threadWaitRead?() the rts would simply sleep if all read()s return EAGAIN?
23:56:40 <mmorrow> yeah, select()
23:57:15 <Cale> da-x: It's not something I've ever had to worry about, anyway.
23:57:33 <mmorrow> da-x: yeah, if you try to read a Handle that would try to read from an fd that would block, you get secretly yield()'ed
23:59:47 <Cale> In fact, it's something that I had never done myself in a C program, so I'd never even considered that it could be so complicated. ;)  Just use I/O from multiple threads and it ought to work, and if for some reason it doesn't, then that's the GHC guys' problem.
