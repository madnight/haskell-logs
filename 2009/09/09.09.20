00:00:24 <Cale> Specifically, probably Simon Marlow's problem ;)
00:18:48 <dons> there's an epoll lib on hackage, for some problems
00:20:25 <aconbere> I'm trying to pick up QuickCheck and struggling a bit with defining an arbitrary String type
00:20:56 <Taejo> if I want to install Platform from source, what version of GHC do I need?
00:21:02 <aconbere> so defining an arbitrary char type in my charset isn't hard
00:21:29 <aconbere> but I'm not entirely sure how to specify that I want to choose a random number of those chars to fill a list
00:27:08 <Cale> aconbere: ...doesn't that instance already sort of exist?
00:28:00 <Cale> instance Arbitrary a => Arbitrary [a] where
00:28:00 <Cale>   arbitrary = sized $ \n ->
00:28:00 <Cale>     do k <- choose (0,n)
00:28:00 <Cale>        sequence [ arbitrary | _ <- [1..k] ]
00:28:00 <Cale>   shrink xs = shrinkList shrink xs
00:32:03 <aconbere> Cale: I would suspect so, but I'm learning and things haven't coalesced yet :)
00:35:33 <maltem> Is HsOpenSSL broken for anyone else?
00:36:31 <Cale> aconbere: That instance automatically gives you an instance for lists of values of your type, if you can just implement Arbitrary just for your type.
00:37:09 <Cale> aconbere: Even if you need mutual recursion (like with tree types) :)
00:38:12 <aconbere> Cale: yeah I'm seeing that now. I think I was confused by the RWH chapter and their definition of an arbitrary two tuple
02:14:53 <monadic_kid> c2hs is giving me the error message: "Feature not yet implemented: GenBind.evalConstCExpr: Casts are not implemented yet." in an {#enum #} which makes no sense
02:17:01 <monadic_kid> anyone have any ideas?
02:18:00 <Taejo> GHCi, version 6.10.4 <-- yay
02:23:17 <monadic_kid> oh yay macros which expand to casts now the message makes sense :/
02:43:39 <ksf> @hoogle IArray Uarray a -> Ptr a
02:43:39 <lambdabot> Did you mean: IArray (UArray a a) a -> Ptr a /count=20
02:43:39 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
02:43:39 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
02:46:47 <ksf> it's nice that sdl associates a finalizerptr with a surface, but it's not so nice that I don't have a way to piggyback on it and free a Ptr () alongside.
02:52:12 <mihai_maruseac> acum e mai bine?:P
02:53:20 <ivanm> mihai_maruseac: this is an English channel
02:53:33 <mihai_maruseac> my mistake, I thought i was in another one
03:16:15 <ksf> fsck. now I'm caching glyphs between draws, and stuff isn't getting any faster, anyway.
03:17:35 <ksf> do we have a Writer or something specialized for benchmarking? that is, adding up timedeltas with separate keys?
03:20:16 <ksf> oh. there's actually a 2x speedup in -O2 code.
03:32:02 <Beelsebob> ksf: depends on the task oft, some programs will get much more of a speedup than that (not just a constant factor for example)
03:32:26 <Beelsebob> 2x is actually about the least speedup I've ever seen from -O1/2
03:33:51 <ksf> I'v just shaved off another 0.04 by not creating sdl surfaces every draw.
03:34:04 <ksf> it's the blitting that takes that long.
03:34:49 <ksf> ...which involves showing continous Word8-data into the green channel of the surface
03:35:00 <ksf> ...I guess I should make it memcpyable.
03:37:52 <ksf> ...well, on a nokia series40 I'd be happy with 4fps, as the graphics pipeline can't take any more, anyway...
03:40:33 <ksf> can I tell ghc not to use profiling for those libraries that don't have profiling compiled? I just wanna time my app...
03:42:37 <jkr> Ahoy
03:42:55 <ksf> those 2x were the speedup for caching glyphs, btw. -O2 speedup is another 2x, and, more importantly, made the cache speedup visible.
03:43:09 <maltem__> ksf: I don't think there's a way to link profiled against non-profiled libs
03:43:51 <maltem__> I remember some compile-all-those-hackage-libs-again-with-profiling sessions :)
03:44:04 <ksf> so do I
03:44:29 <ksf> which basically bogs down to nuking ~/.cabal and ~/.ghc and installing what you need.
03:44:49 <ksf> ...and that's a lot. IxSet has insane dependencies.
03:45:14 <jkr> I've written my first simple module and I'd like to upload it to hackage. Is there some process like on CPAN where you have to apply for a package namespace etc?
03:45:18 <ksf> ...like haxml for some TH magic the base happstack package uses.
03:45:30 <maltem__> --reinstall saves you the keystrokes to nuke .cabal and .ghc
03:45:30 <jkr> Or are there any other rules that you have to follow when choosing a
03:45:34 <jkr> odule namespace?
03:45:36 <jkr> Narf
03:46:01 <ksf> nah, it's not that complicated. you have to worship someone who can give you an account (usually here or via email), and if they're gratious, you get one.
03:46:18 <jkr> Ah, cool
03:46:23 <ksf> in the meantime, just upload it to githup or somewhere and do a wiki page
03:46:29 <ksf> (if you've got a wiki account)
03:47:06 <jkr> And how do I know if my namespace is a good choice? Are there any conventions?
03:47:08 <ksf> I guess wiki account creation is still disabled because noone responsible trusted my recommendation of recaptcha...
03:47:16 <jkr> hehe
03:47:32 <ksf> there's common usage.
03:47:53 <maltem> jkr: Put the code up somewhere and if you're not bashed due to your choice of names, you're alright :)
03:48:28 <jkr> Hehe, ok
03:49:40 <jkr> Is it correct that a packages name doesn't have to be related to the namespace in any way?
03:50:15 <ksf> maltem, -reinstall doesn't resolve profiling dependencies.
03:50:40 <ksf> "not related" is a bit harsh. "not equal" is more correct.
03:51:21 <ksf> you shouldn't put win32 bindings in the package "posix", for example, that'd be heresy.
03:51:56 <maltem> ksf, hey, I never thought about *that*!
03:52:06 <maltem> (re --reinstall)
03:52:26 <ivanm> where can I find the meaning of the different terms used by HSX?
03:56:03 <jkr> http://github.com/jkramer/text-ini
03:56:16 <jkr> Start the namespace bashing :)
03:57:04 <skorpan> i would start by bashing the physical tabs
03:57:06 <ksf> don't we have .ini-support, already?
03:57:19 <skorpan> we do
03:57:48 <Twey> Eww, hardtabs.
03:58:07 <jkr> I didn't find any usable module for ini parsing
03:58:19 <jkr> Probably because of the not-related package names :)
03:58:36 <jkr> What's wrong with the tabs?
03:58:50 <Twey> (\ section -> (section, pairs section)) ≡ second pairs
03:59:03 <Twey> jkr: Editors render tab characters differently.
03:59:23 <jkr> That's right
04:00:05 <ksf> tabs are going to be outlawed in h', and that's for a very, very, very good reason
04:00:13 <skorpan> let's not discuss tabs
04:00:23 <mauke> (fst) better written as fst
04:00:23 <Twey> http://urchin.earth.li/~ian/style/haskell.html
04:00:44 <ksf> http://www.haskell.org/pipermail/haskell-prime/2009-January/002718.html
04:00:55 <ehamberg> jkr: have you run hlint on it?
04:01:04 <jkr> Nope, what's that?
04:01:14 <jkr> Ah, I see
04:01:17 <jkr> Nice
04:01:34 <ivanm> ksf: \o/
04:01:52 <ehamberg> jkr: yeah, it's very cool :)
04:02:08 <Twey> Oh, sorry, not ‘second pairs’ but ‘id &&& pairs’
04:03:03 <maltem> jkr, there's ConfigFile on hackage. I prefer your choice of module name though (^^)
04:03:13 <jkr> I like haskell tools that analyze/rewrite haskell code, like the pointfree tool or this hlint thing
04:04:19 <jkr> Or that haskell can parse/compile haskell code :)
04:04:20 <ivanm> jkr: hlint doesn't re-write anything
04:04:35 <ivanm> it tells you what to rewrite instead ;-)
04:04:37 <skorpan> it analyzes the code though...
04:04:43 <skorpan> just like jkr said
04:04:45 <ksf> there's also Text.PrettyPrint.HughesPJ wich comes with sane Read instances (i.e. you get the position of parse errors) and stuff like JSON
04:04:57 <ksf> there's no need to do all that boilerplate you need for ini files
04:05:47 <osfameron> .HughesPJ is the author?  it seems like a funny place in the namespace to put author
04:06:06 <ksf> there's different prettyprint combinator libraries.
04:06:07 <ivanm> osfameron: no
04:06:12 <ivanm> it's by hughes + SPJ
04:06:18 <ksf> ...and that's john hughes and simon peyton jones.
04:06:22 <ivanm> well, based on a paper by hughes and edited by SPJ
04:06:23 <jkr> I'm coming from Perl initially and I always found it fascinating that no-one was every able to use Perl to sanely parse Perl :)
04:06:38 <ksf> perl can't be parsed.
04:06:42 <ksf> there's a proof of that.
04:06:44 <osfameron> so HughesPJ is the algorithm, I see
04:06:49 <ksf> it involves solving the halting problem.
04:06:56 <ivanm> heh
04:07:38 <osfameron> I do wish they'd solved the non-parsability problem for Perl 6, but they seem to have insisted on keeping the features that make it non-parsable, even when they're annoying/barely useful
04:07:42 <Jafet> Well, it is semi-decidable
04:07:51 * ksf still wonders who this halting guy is and why we're supposed to solve his problems.
04:08:08 <Jafet> MC Hammer's important role in computing
04:08:13 <mauke> if you insist on static parsing, you can't allow lisp-style macros
04:09:06 <jkr> http://pastie.org/623466 - how is liftM better than >>= ?
04:09:15 <Jafet> lisp is exempted due to an obscure grandfather clause
04:09:16 <jkr> Just because it's 5 chars less?
04:09:31 <mauke> jkr: because it shows more clearly what you're doing
04:09:43 <mauke> >>= return . is a bit redundant
04:10:01 <jkr> Hmm
04:10:16 <jkr> Gotta check what liftM does at all ;)
04:10:19 <ksf> don't worry about it, though.
04:11:08 <ksf> ...your code is going to get more conscise as you really _need_ to use some function, develop an intuition for it and then see its applicability everywhere.
04:12:04 <ksf> ...so using >>= return . or do notation is better than trying to get a line of code to work for half an hour.
04:12:27 <jkr> Right
04:12:33 <jkr> Also liftM seems to require another import
04:12:43 <ksf> but control.monad is common
04:12:47 <ksf> as is control.applicative
04:12:48 <mauke> use fmap instead :-)
04:13:19 <jkr> fmap is even weirder :)
04:13:24 <ksf> especially the liftA* functions can be very handy.
04:13:31 <ksf> fmap is less weird than >>=
04:13:39 <ksf> @where typeclassopedia
04:13:39 <lambdabot> I know nothing about typeclassopedia.
04:13:43 <mauke> oh, what's weird about fmap?
04:13:45 <ksf> ouch.
04:14:11 <ksf> @where+ typeclassopedia http://www.haskell.org/haskellwiki/Typeclassopedia
04:14:11 <lambdabot> I will never forget.
04:14:19 <jkr> mauke: I just don't understand it :)
04:14:43 <ksf> jkr, read it, it explains how applicative functors are based on funtors and how monads are based on applicatives.
04:15:15 <Cale> jkr: fmap is intuitively easy, it's map, but with more arbitrary datastructures
04:15:19 <ksf> > [succ, pred] <*> [10.20,30]
04:15:20 <lambdabot>   [11.2,31.0,9.2,29.0]
04:15:21 <mauke> jkr: fmap takes a function and a box and applies the function to all elements in the box
04:15:25 <maltem> ... and how the type class hierarchy sucks
04:15:36 <ksf> > [succ, pred] <*> [10,20,30]
04:15:37 <lambdabot>   [11,21,31,9,19,29]
04:16:13 <ksf> > fmap succ [10,20,30]
04:16:14 <lambdabot>   [11,21,31]
04:16:38 <Cale> jkr: Of course, when the 'container' turns into a 'computation' that gets a little strange, but instead of being the elements of the container, it becomes the results of the computation that you're applying the function to.
04:16:44 <mauke> > fmap (* 2) (Just 21)
04:16:45 <lambdabot>   Just 42
04:17:17 <mauke> well, there are magic boxes, you know
04:17:39 <jkr> So it just applies the function to the content of a monad?
04:17:45 <mauke> not monad, functor
04:18:02 <jkr> Hrm, I really have to read more about that stuff :)
04:18:05 <ksf> the "box" mauke is talking about is the "Maybe" in "Maybe a", and the "element" mauke is talking about is the "a" in "Maybe a"
04:18:17 <Twey> Monads tend to be functors, but it's the functor side of things that defines fmap.
04:18:22 <ksf> ...it's a type thing, not a container thing.
04:18:26 <jkr> ksf: I just thought Maybe was a monad
04:18:32 <mauke> it is, but that's irrelevant here
04:18:32 <ksf> that, too.
04:19:20 <jkr> http://github.com/jkramer/text-ini/blob/master/Text/INI.hs - cleaned up
04:19:37 <Twey> I still see tabs.
04:20:02 <ksf> jkr, http://www.vim.org/ , :set et
04:21:06 <Twey> (or (setq-default indent-tabs-mode nil) if you're not an infidel ;))
04:21:17 <jkr> I think I'll  wait with using spaces over tabs until everyone else uses camelcase over underscores :)
04:21:34 <ksf> haskell uses camelCase
04:21:58 <jkr> But I see underscored code in packages on hackage all the time
04:22:18 <Twey> jkr: Not the good ones.  ;)
04:22:19 * Heffalump just follows whatever conventions are nearby
04:22:24 <skorpan> case { _ -> True }
04:22:27 <skorpan> underscore!
04:22:30 <ksf> ...but that's either at the end of an identifier where it has a special meaning by convention (like mapM_), or ffi bindings.
04:22:31 <Twey> :þ
04:22:31 <jkr> Hehe
04:22:40 <Twey> Oh, and those.
04:22:51 <skorpan> and __init__ of course!
04:23:16 <jkr> I really mean functions like do_foo_and_then_bar, they're everywhere on hackage
04:23:25 <ivanm> anyone know where can I find the meaning of the different terms used by HSX?
04:23:43 <ksf> ...and if ffi bindings have underscores the author is not lazy enought to use c2hs
04:23:52 <jkr> http://hackage.haskell.org/packages/archive/ConfigFile/1.0.5/doc/html/Data-ConfigFile.html
04:24:22 <jkr> That was one reason why started writing my own
04:24:26 <ksf> john should be smacked for that
04:24:32 <ksf> @smack john
04:24:32 * lambdabot karate-chops john into two equally sized halves
04:24:52 <jkr> Even worse, it's mixed camelcase and underscores
04:24:55 <skorpan> i quite like that package
04:25:00 <ksf> ...and all-lowercase.
04:25:04 <ksf> eg "defaulthandler"
04:25:05 <jkr> Yup, that too
04:25:16 <Twey> Yeah.  This is how packages should not be written.
04:25:21 <skorpan> it's based on a python library, that's why
04:25:51 <maltem> bad reason
04:25:56 <ksf> I don't like the interface, too.
04:26:01 <ksf> it should be more read/show like
04:26:24 <ksf> marshalling the fields manually to your adts is pure boilerplate.
04:27:17 <jkr> One more question about tabs: When I use tabs consistently (not mixed with spaces), then it maybe doesn't look the same in all editors, but the editor displays it the way the user configured it, which is good in my opinion. Or am I wrong?
04:27:20 <Twey> Say, are there Lua bindings for Haskell?
04:27:37 <ivanm> Twey: there's a lua library IIRC...
04:27:46 <mauke> jkr: that works, but it also requires you to write code in a special way
04:28:01 <jkr> For example, I like to have my tabs displayed as 4 spaces, but others might prefer 2 spaces. When I use expandtab, then everyone is forced to see 4 spaces
04:28:04 <ivanm> @hackage hslua
04:28:04 <lambdabot> http://hackage.haskell.org/package/hslua
04:28:05 <mauke> jkr: because Haskell's layout rules are about making things line up, not just indentation
04:28:09 <ivanm> Twey: ^^
04:28:13 <Twey> ivanm: Ta
04:28:43 <ksf> ...the Right Way to indent is either 4 spaces or depending on keyword.
04:29:06 <maltem> mauke, which is, arguably, a thing about Haskell syntax to fix. And the bikeshed should be brownish, of course.
04:29:23 <mauke> I don't see it as a problem
04:30:01 <maltem> not a problem, but it's not dead-simple, as most things about programming should be
04:30:32 <maltem> anyway, jkr, the point, I think, is that you won't see tabs in any public Haskell code
04:30:45 <jkr> mauke: Do you have an example where things have to line up?
04:30:55 <jkr> ...where tabs don't work
04:31:12 <mauke> jkr: where you don't start a new line after where/do/of/let
04:31:42 <mauke> guards don't have to line up, but they look better that way
04:35:43 <jkr> mauke: Do you have any useful vim-tweaks for haskell code?
04:36:19 <jkr> I've added syn match hsEolSpace "\s\+$" and HiLink hsEolSpace     Error to my haskell.vim syntax file, for example
04:37:12 <mauke> setl isk+=' et sts=4 sw=4 nospell
04:37:53 <mauke> I also have a indent/haskell.vim written by someone else
04:38:29 <jkr> http://www.vim.org/scripts/script.php?script_id=1968 - this one?
04:38:50 <lilac> so. the Either Monad gives rise to an applicative. But it's not the Either Applicative. is this a good thing or a bad thing? :)
04:39:13 <mauke> jkr: yeah, looks like it
04:42:50 <maltem> wow. thank you for talking about softtabstop and that indent script
04:45:05 <Phyx-> hoogle "ticks to time"
04:45:12 <Phyx-> @hoogle "ticks to time"
04:45:12 <lambdabot> Parse error:
04:45:12 <lambdabot>   --count=20 ""ticks to time""
04:45:12 <lambdabot>              ^
04:45:18 <Phyx-> @hoogle ticks to time
04:45:18 <lambdabot> Did you mean: ticks -> time /count=20
04:45:18 <lambdabot> No results found
04:48:03 <Assasinof6> Yo
04:48:07 <Phyx-> hello
04:48:16 <Assasinof6> does anyone here use python?
04:48:22 <Assasinof6> I need some help w/ it
04:48:33 <cjs> You know, Haskell might actually be easier to learn, or at least learn properly, if it had no map function.
04:48:46 <mauke> Assasinof6: this is #haskell
04:49:01 <Assasinof6> hello
04:49:19 <ivanm> cjs: :o
04:49:22 <ivanm> heresy!
04:49:36 <Assasinof6> and..
04:50:00 <cjs> The Prelude is really showing the difference between pre-typeclass and post-typeclass ideas, I'm guessing.
04:50:07 <maltem> Assasinof6, mauke was introducing you to the channel, not to himself ^^
04:50:16 <Assasinof6> ok sorry thanks btw
04:50:25 <mauke> you seem to be new to this irc thing
04:50:27 <Assasinof6> whoops crappy colour
04:50:29 <ivanm> heh
04:50:31 <Assasinof6> yep
04:50:36 <Assasinof6> just joined this chat room
04:50:41 <Assasinof6> just needed a bit of help
04:50:42 <mauke> (I don't see any colors)
04:50:52 <ivanm> Assasinof6: as mauke was saying, this is the wrong place to ask about python
04:50:53 <mauke> if you need help with python, why not join #python?
04:50:55 <ivanm> try #python
04:50:56 <ivanm> heh
04:50:58 <Assasinof6> oh...
04:51:01 <Assasinof6> lol thanks
04:51:06 <Assasinof6> im such a noobcake
04:51:09 <Assasinof6> =)
04:51:11 <ivanm> mauke: as for the colours, either Assasinof6 is on LSD or his client has colours and yours doesn't ;-)
04:51:17 <ivanm> mmmm..... cake....
04:51:23 <mauke> or he sent colors and we are +c
04:51:37 * ivanm has colours in his client for the different nicks, etc.
04:51:42 * Berengal has a semi-blog
04:51:54 <ivanm> Berengal: you must be so proud!
04:52:01 <Berengal> ivanm, I wrote it myself
04:52:03 <mauke> a bl?
04:52:04 <Berengal> http://85.200.142.98:5000/blog
04:52:14 <ivanm> a bo?
04:52:23 <ivanm> Berengal: *sigh*
04:52:30 <ivanm> I'm guessing you mean you have a semi-blog engine?
04:52:39 <ivanm> (the *sigh* was for the description)
04:52:43 <Berengal> ivanm, that too
04:52:47 <cjs> In fact, it would definitely be easier all around. A beginner is going to have no problem when you tell him "Lists are a functor, and here's what fmap does when you apply it to a list", even if he doesn't understand what a functor is. But it lays the groundwork for everything else.
04:52:53 <ivanm> Berengal: I want to see these "sweet maidens" you used to polish the bytes...
04:52:56 <Berengal> Don't read the description. I just needed to vent :P
04:53:16 <ivanm> cjs: oh, by "getting rid of map", you mean "make map fmap"?
04:53:35 <ivanm> in which case, we should probably have a newbie-prelude for people to see how it's done
04:53:37 <ksf> I CAN'T BELIEVE IT
04:53:42 <cjs> Or, possibly, leave fmap as fmap, but remove Prelude.map (and similar functions).
04:53:45 <lilac> cjs: actually, pre-haskell'98 there was a version of haskell where 'map' was fmap and ++ was mappend and ...
04:53:46 <ivanm> and I would just make fmap map, not drop map
04:54:03 <cjs> lilac: Really?! Why did they abandon that?
04:54:06 <ivanm> lilac: I thought they didn't have functors pre-98
04:54:07 <ksf> the code that's slowing my app is actually adding 2-vectors of Data.Fixed
04:54:10 <lilac> the 'simpler' forms were added to help beginners iirc
04:54:31 <cjs> Berengal: Cool. I have a semi-mailing-list-manager. :-)
04:54:48 <mauke> I have scrollwheel support in my irc client
04:54:56 <Berengal> cjs, cool, we should like totally merge and hang out, dude :P
04:55:10 <cjs> Indeed. Especially once I get the clustering added to my system. :-)
04:55:15 <ivanm> mauke: I have no idea if mine supports a scroll wheel, since I don't really use a mouse with it...
04:55:26 * ivanm wishes HSX had yet more documentation...
04:55:28 <mauke> ivanm: then how do you click on links?
04:55:42 <ivanm> mauke: "rarely", not "never" ;-)
04:56:01 <cjs> Actually, drop me a note at cjs@cynic.net if you like, and I'll get back to you next week with some thoughts. I don't actually have the clustering stuff implemented, but if you merely use my storage back-end, the clustering will come really, really cheap once I do it.
04:56:15 <ivanm> and if by "scroll wheel support" you mean that it goes up and down in the history... then so does mine (xchat)
04:56:29 <cjs> And I'll definitely need some web fu for browsing the list archives.
04:56:31 <mauke> yeah, but this is irssi
04:56:36 <mauke> no gui :-)
04:56:42 <ivanm> ahhh
04:57:20 <ivanm> anyone know what "A declaration of default types" means? is that like how GHC has Integral set to Integer by default?
04:57:57 <mauke> http://haskell.org/onlinereport/decls.html#default-decls
04:58:11 <ivanm> thanks mauke
04:58:19 <Berengal> cjs, as of right now, I'm still in the "messing around with libraries I know nothing about" stage. Knowing my track-record, I'll get bored in a week :/ I'll keep it in mind though
04:58:46 <Berengal> There might be some nice CMS synergy to this
05:01:44 <ivanm> type families are a way of defining a specialised data type inside a class?
05:02:30 <lilac> associated types are
05:03:02 <jkr> Is there a short introduction in haddock somewhere?
05:03:20 <dschoepe> mauke: you could use this for opening links without the mouse (if you use urxvt): http://www.jukie.net/~bart/blog/20070503013555
05:03:29 <jkr> I've been reading this, but it seems to e outdated: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Build_some_haddock_documentation
05:03:50 <ivanm> lilac: associated types are a type (no pun intended) of type family?
05:03:52 <mauke> dschoepe: I already do (well, a heavily modified version of it)
05:03:57 <mauke> with a few bugfixes
05:04:09 <maltem> jkr, outdated?
05:04:15 <ivanm> oh, wait, associated types are type families for a class?
05:04:27 <dschoepe> maltem: ah, okay. I thought you might not know about it because you asked ivanm how he did that without mouse
05:04:54 <mauke> ivanm doesn't use urxvt for irc
05:05:27 <jkr> maltem: I throws syntax errors at me when I add a comment like in the example
05:05:48 <Phyx-> irssi ftw
05:05:53 <maltem> jkr, which example?
05:06:36 <ivanm> lilac: what is the point of non-associated type familys? the page on haskell.org doesn't really give a decent reason...
05:07:05 <lilac> ivanm: they let you define type functions without defining a typeclass
05:07:12 <ivanm> hmmmmm....
05:07:17 <ivanm> by using a family instead?
05:07:23 <ivanm> rather than a useless type class?
05:07:37 <lilac> cjs: http://haskell.org/definition/haskell-report-1.4-html.tar.gz <-- haskell 1.4 had 'class Functor f where map :: (a -> b) -> f a -> f b'
05:07:46 <lilac> ivanm: right, essentially
05:07:47 <ivanm> how does it differ from just using a type alias?
05:08:14 <lilac> type aliases aren't open type functions, they're just simple rewrite rules
05:08:19 <ivanm> what? Haskell had functors, got rid of them, then put them back _after_ having monads? :o
05:08:20 <lilac> that is, they can't have 'instances'
05:08:37 <lilac> ivanm: haskell never got rid of functors afaik
05:09:01 <ivanm> then what's with the whole thing of monads not being functors by default?
05:09:08 <lilac> but it renamed map to fmap and introduced a specialized map for lists only, in the 1.4 -> '98 transition
05:09:38 <ivanm> lilac: know of any short examples online I can see the point of type families?
05:10:46 <lilac> no; i've used (non-associated) type families but only for fairly esoteric things
05:11:15 <Assasinof6> how to I joing another server?
05:11:20 <lilac> associated types are put to good use in the MemoTrie package on haskell iirc
05:11:21 <Assasinof6> lol
05:11:25 <lilac> *hackage
05:11:29 <mauke> oh, mirc. no idea
05:11:44 <lilac> Assasinof6: have a look at the documentation for your irc client :)
05:11:47 <Assasinof6> [red]
05:11:50 <ivanm> lilac: yeah, associated types are just another way of doing fundep-style things, aren't they?
05:12:00 <ivanm> Assasinof6: another room or another server?
05:12:01 <Assasinof6> k
05:12:08 <mauke> s/room/channel/
05:12:10 <Assasinof6> another room i guess
05:12:13 <Berengal> ivanm, class Addable a b where type Add a b :: *; (+) :: a -> b -> Add a b; instance Addable Int Integer where type Add Int Integer = Integer; instance Addable Integer Double where Add Integer Double = Double;
05:12:14 <Assasinof6> #python
05:12:16 <ivanm> same diff
05:12:18 <mauke> /join #python
05:12:19 <ivanm> Assasinof6: /join #python
05:12:20 <monadic_kid> it's a lot like doing metaprogramming with templates in C++ and nested types
05:12:27 <ivanm> Berengal: I get that
05:12:32 <mauke> Assasinof6: and /part to leave a channel
05:12:39 <Berengal> ivanm, you want them outside of classes?
05:12:40 <Assasinof6> ok thanks guys
05:12:40 <ivanm> I just don't get non-associated type families
05:12:42 <lilac> ivanm: common wisdom seems to be that, if superclass equality constraints worked, they'd be equivalent in power
05:12:50 <Assasinof6> I'll leave u non-noobs alone
05:12:50 <lilac> (to fundeps)
05:12:54 <ivanm> Berengal: _I_ don't want them... but I have to understand how to deal with them when using HSX
05:13:14 <ivanm> lilac: you mean the reverse of "instance (Foo a) => ... " ?
05:13:29 <ivanm> e.g. automatically make all Monads Functors?
05:13:58 <lilac> ivanm: 'class (Foo [a] ~ b) => Bar a where type Foo a :: *'
05:14:22 <ivanm> which means?
05:15:13 <lilac> which means, for a to be a Bar, it must give a type for 'Foo a', and further, the type 'Foo [a] must be the same as the type b'
05:16:11 <ivanm> with b being an alias for [a] ?
05:16:40 <cjs> Berengal: Well, yeah, mhailist (you can probably google it to find source) has been going it little fits and starts for more than a year now. But it will happen one day.
05:16:47 <lilac> a more likely example: 'class Error (ErrorType m) => MonadError m where type ErrorType m :: *; throw :: ErrorType m -> m a'
05:18:10 <ivanm> what is the point of the "type ErrorType m :: *"? you've already specified that m must be an instance of ErrorType, haven't you?
05:19:03 <lilac> no, i've specified that ErrorType m must be an instance of Error
05:19:32 <ivanm> oh, whoops, mis-read that :s
05:19:49 <ivanm> and by saying ErrorType m :: *, it doesn't take any other type param?
05:20:30 <lilac> approximately. anyway, gtg...
05:20:46 <ivanm> k
05:20:50 <ivanm> thanks anyway
05:21:00 <Berengal> ivanm, that means the result is a type of kind *
05:21:19 <ivanm> yes, which means it doesn't take another type param, right?
05:21:24 <ivanm> e.g. Maybe Int vs Maybe
05:21:25 <Berengal> Right
05:21:44 <Berengal> But type Foo a :: * -> * isn't the same as type Foo a b :: *
05:21:49 <neuron> Hello haskellers! I'm a newbie, trying to write my first program in Haskell to manipulate ID3 tags. Found idiii library on Hackage, installed Cabal and said "cabal install idiii". The result was "idiii-0.0 depends on encoding-0.6.2 which failed to install"
05:21:51 <neuron> Is there anything which could be done with this?
05:22:14 <Berengal> neuron, why does encoding fail to install?
05:22:56 <neuron> There was a ton of output, here are the last lines:
05:22:58 <neuron> Building utf8-string-0.3.5...
05:23:00 <neuron> [1 of 7] Compiling Codec.Binary.UTF8.String ( Codec/Binary/UTF8/String.hs, dist/build/Codec/Binary/UTF8/String.o )
05:23:01 <neuron> [2 of 7] Compiling Codec.Binary.UTF8.Generic ( Codec/Binary/UTF8/Generic.hs, dist/build/Codec/Binary/UTF8/Generic.o )
05:23:03 <neuron> [3 of 7] Compiling Data.String.UTF8 ( Data/String/UTF8.hs, dist/build/Data/String/UTF8.o )
05:23:04 <neuron> [4 of 7] Compiling System.IO.UTF8   ( System/IO/UTF8.hs, dist/build/System/IO/UTF8.o )
05:23:06 <neuron> [5 of 7] Compiling System.Environment.UTF8 ( System/Environment/UTF8.hs, dist/build/System/Environment/UTF8.o )
05:23:08 <neuron> [6 of 7] Compiling Data.ByteString.UTF8 ( Data/ByteString/UTF8.hs, dist/build/Data/ByteString/UTF8.o )
05:23:10 <neuron> [7 of 7] Compiling Data.ByteString.Lazy.UTF8 ( Data/ByteString/Lazy/UTF8.hs, dist/build/Data/ByteString/Lazy/UTF8.o )
05:23:11 <neuron> ar: creating archive dist/build/libHSutf8-string-0.3.5.a
05:23:13 <neuron> Installing library in /Users/neuron/.cabal/lib/utf8-string-0.3.5/ghc-6.10.1
05:23:14 <neuron> Registering utf8-string-0.3.5...
05:23:15 --- mode: ChanServ set +o mauke
05:23:16 <neuron> Reading package info from "dist/installed-pkg-config" ... done.
05:24:02 <dcoutts> neuron: hpaste :-)
05:24:04 <Berengal> @paste
05:24:04 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:24:16 --- mode: mauke set -o mauke
05:24:19 <neuron> Sorry :)
05:25:49 <neuron> Here you go (the same output): http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3858#a3858
05:26:12 <dcoutts> apparently the encoding package is naughty and depends on HaXml without specifying so
05:26:21 <ivanm> *tsk, tsk*
05:26:27 <Berengal> Bad package
05:26:34 <dcoutts> in its Setup.hs no less
05:26:42 <dcoutts> so it dies pretty early
05:26:47 <dcoutts> without a good message
05:26:53 <ivanm> dcoutts: how could you tell? the paste doesn't say so...
05:27:05 <dcoutts> ivanm: that's how it fails when I try it
05:27:28 <dcoutts> ivanm: the paste doesn't show the failing package
05:27:33 <dcoutts> just the tail end
05:27:41 <ivanm> ahhh
05:27:42 <neuron> Could I do anything about it (i.e. install HaXml)?
05:27:58 <ivanm> maybe that explains why so many people have trouble installing encoding...
05:28:04 <ivanm> neuron: that'd probably do it
05:28:15 <dcoutts> neuron: but it looks like it needs 'HaXml >= 1.19'
05:28:24 <dcoutts> neuron: cabal install 'HaXml >= 1.19'
05:28:51 <dcoutts> I've got the stable HaXml version and encoding still doesn't like it
05:29:28 <ivanm> dcoutts: this is 0.5.1?
05:29:35 <dcoutts> ivanm: 0.6.2
05:29:41 <ivanm> oh, there's a newer one?
05:29:50 <ivanm> heh, guess no gentoo user users encoding :p
05:30:18 <dcoutts> gads this is horrible
05:30:31 <Berengal> dcoutts, it is... I'm a bit saddened
05:31:11 <dcoutts> someone should point it out to the package author
05:31:12 <ivanm> Berengal: why are you saddened? your name doesn't appear to be Henning Gunther...
05:31:29 <dcoutts> it could use the external HaXml programs, as build-tools
05:31:33 <Woof> Memory allocation is a horrible affair : /
05:31:38 <Berengal> ivanm, sucky things make me sad in general
05:31:44 <Woof> I'm glad for Haskell and Scala : D
05:31:57 <ivanm> Berengal: heh
05:32:16 <Berengal> Few things suck more than non-optimal packaging
05:33:09 <Berengal> Got encoding 0.6.2 installed. Worked once HaXml 1.19 was installed
05:33:14 <roelvandijk> Are you guys trying to get encoding to build?
05:33:46 <Berengal> roelvandijk, not any longer
05:33:48 <roelvandijk> It has a build-time dependency on HaXml 1.19
05:33:51 <roelvandijk> Ah I see
05:34:03 <roelvandijk> I had the same problem
05:34:30 <roelvandijk> The HaXml == 1.13.* line in hackage's preferred-versions doesn't make it any easier
05:34:48 <ivanm> roelvandijk: where's this?
05:35:45 <roelvandijk> ivanm: In the archive directory of hackage there is a small text file called preferred-versions
05:35:59 <roelvandijk> base < 4
05:36:00 <roelvandijk> parsec < 3
05:36:00 <roelvandijk> HaXml == 1.13.*
05:36:00 <roelvandijk> QuickCheck < 2
05:36:04 <roelvandijk> That is the only content there
05:36:09 <ivanm> hmmm...
05:36:13 <roelvandijk> It is a bit of a hack
05:36:16 * ivanm wonders if that's for cabal-install
05:36:24 <roelvandijk> That is indeed for cabal-install
05:36:25 <ivanm> and the rest of the automated build/test suite
05:37:04 <roelvandijk> Here is the file: http://hackage.haskell.org/packages/archive/preferred-versions
05:37:19 <Berengal> Those preferred versions have caused me no end of trouble. I don't even dare think about what would happen if they weren't there...
05:37:36 <roelvandijk> Berengal: I think even more things would go wrong
05:37:50 <Berengal> roelvandijk, that's what I don't even dare think about
05:38:15 <roelvandijk> Berengal: The main reason for its existence is probably that most packages are to liberal with their dependencies
05:38:34 <ivanm> yup
05:38:38 <ivanm> especially older ones
05:38:42 <Berengal> There are standards, and when standards migrate there should be versioning tools there as well
05:38:56 <ivanm> dcoutts: any further plans on PVP opt-in in .cabal files?
05:39:46 <neuron> Folks, I've got HaXml (I used "cabal install HaXml" and got version 1.13.3) on my box, but idiii still fails with the same message
05:40:07 <Berengal> neurocyte, "cabal install 'HaXml >= 1.19'"
05:40:11 <Berengal> neuron*
05:40:21 <ksf> hey I'm up to 9 to 11fps
05:40:36 <neuron> Berengal, trying this...
05:40:42 <roelvandijk> neuron: You can also specify the exact version "cabal install HaXml-1.19.7"
05:41:08 <dcoutts> neuron: that's why I said: cabal install 'HaXml >= 1.19'
05:41:34 <dcoutts> ivanm: plans but no implementations
05:41:39 <neuron> dcoutts, sorry, I missed that line
05:42:39 * Berengal wonders if HaXml perhaps should've bumped a major version somewhere
05:44:34 <neuron> Thanks you all guys, this helped!
05:44:35 <neuron> Now heading toward parsing ID3 out of MP3 files :)
05:45:49 <cjs> This whole kind of thing is actually part of the reason why I tend to include less common dependencies with my apps. I try to keep my base system (i.e., what's globally available to everybody on that host) as simple as possible in part so that I quickly discover what the heck my own code depends upon.
05:47:21 <Berengal> build-type: Simple also helps chasing dependencies
05:47:35 <ksf> Data.Map isn't really tight-loop capable.
05:47:37 <cjs> But there could be other ways of doing this. I wonder if it doesn't make sense to add something to ghc's packaging system that says, "unhide this if it's available," so that you could have a foo-1.3.7 shared by every application on the system, but when I wrote something new that depended on foo>=1.3, it wouldn't link until I explicitly specified somewhere that I want to link against foo>=1.3.
05:47:54 <cjs> ksf: What's up?
05:48:00 <ksf> ...even if you do less than 100 lookups per loop
05:48:27 <Phyx-> lol, after the os goes to sleep and back,ghci doesn't seem to terminate nicely anymore
05:48:35 <Phyx-> the instance that was already running
05:49:48 <luca___m> hello
05:50:06 <roelvandijk> hello
05:51:44 <luca___m> i'm new to HS, and i'm stuck with a typing issue while rewriting the elem function
05:51:59 <Berengal> @paste
05:51:59 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:52:13 <Berengal> ↑ paste the code and show us
05:52:39 <luca___m> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3859#a3859
05:53:48 <luca___m> it compiles fine, but a simple 1 isInto [1..10] gives a "no instance for Num ... " message
05:54:07 <mauke> yeah, should be 1 `isInto` [1..10]
05:54:15 <Berengal> Did you forget the `'s around the function?
05:54:38 <roelvandijk> Otherwise you would get: (1 isInto) [1..10]
05:54:42 <luca___m> omg :|
05:55:02 <roelvandijk> luca__m: The easiest problems are sometimes the hardest to spot
05:56:10 <luca___m> ty! and what about this? Another typing error http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3860#a3860
05:56:32 <luca___m> it's a simple tweak of a function found in a tutorial
05:56:43 <Berengal> Again, you're forgetting ` around mod
05:57:15 <jkr> maltem: The "-- | 'main' runs the main program" example
05:57:22 <roelvandijk> But it is styll typeable, just completely different than what you mean :-)
05:57:23 <jkr> (was at the phone)
05:57:35 * Berengal prefers prefix functions
05:58:17 <roelvandijk> luca___m: showTime :: (Num a, Ord a, Integral b, Num t, Num c, Ord c) => ((b -> b -> b) -> t -> c) -> a -> String
05:58:41 <roelvandijk> luca___m: Ofcourse, Berangal's suggestion is much more usefull
05:58:57 <luca___m> ok
05:59:09 <Berengal> Mine probably has correct semantics as well
05:59:13 <luca___m> i need to figure out why that function has that type
05:59:58 <luca___m> showTime :: (Num a, Ord a, Integral b, Num t, Num c, Ord c) => ((b -> b -> b) -> t -> c) -> a -> String
06:00:02 <roelvandijk> luca___m: With the mod function correctly used you get the much nicer type (Num a, Ord a, Intergal b) => b -> a -> String
06:00:52 <Berengal> A good idea is to write the type signature first. You'll get nicer messages
06:01:11 <Berengal> Well, "nicer"... the Num type class tends to make a mess of things
06:01:35 <luca___m> now it's more clear!
06:01:46 <roelvandijk> luca___m: I didn't infer that type by myself. I just enlisted the help of GHCI :-)
06:01:58 <mauke> hah, I need to tweak my hash function
06:02:05 <mauke> Berengal and roelvandijk have the same color
06:02:44 <luca___m> so, if an infix function appears into a guard term, this appears into inferred type
06:02:44 <Berengal> mauke, I did that once, and spent weeks confusing people for eachother
06:02:57 <roelvandijk> luca___m: Also, the extra parens around your (show (hours `mod` 24)) are not necessary
06:03:17 <roelvandijk> luca___m: And you can write ("0" ++ show minutes) as ('0' : show minutes)
06:03:55 <luca___m> ok
06:04:17 <Orclev> well, that was an interesting experiment... I just called an assembly procedure from haskell, and in turn had the assembly call a haskell function
06:05:02 <Berengal> Orclev, needs more wooden table?
06:05:29 <Orclev> Berengal: I plan on submitting a photo of the printed source code on a wooden table soon
06:05:50 <mauke> Orclev: have you seen http://mauke.ath.cx/stuff/haskell/hell.hs ?
06:06:03 <Orclev> mauke: not yet, but I will shortly
06:06:19 * luca___m would really like to find more about functional languages implementation
06:06:45 <Berengal> mauke, haha
06:06:48 <Orclev> lol, is that machine code?
06:06:51 <mauke> yes
06:07:06 <Orclev> that's all kinds of wrong and awesome at the same time
06:07:35 <luca___m> isn't \0 seen as end of string?
06:07:43 <Orclev> no, it's null
06:07:51 <Orclev> it just happens that sometimes it means end of string
06:08:14 <Berengal> "Now we've invented a type-safe, pure language. Let's use it to run machine code directly."
06:08:28 <luca___m> hehe
06:09:07 <Orclev> I could probably do that with x86, but I'm running on x86-64 and I'm not familiar with the 64 bit ops in machine code
06:09:30 <jafet> unsafePerformx86Execution
06:10:23 <maltem> jkr, looks but like it should work. What's the error?
06:11:18 <jkr> Just 'parse error on input' and then the line
06:12:23 <maltem> the "-- |" line?
06:12:24 * roelvandijk wonders why Set is not a Functor
06:12:28 <jkr> Yup
06:12:40 <jkr> Maybe I'm calling it in a wrong way
06:12:49 <jkr> I'm using "cabal haddock"
06:13:32 <jkr> But "runhaskell Setup.hs haddock" fails with the same error
06:13:32 <dcoutts> roelvandijk: because of the Ord constraint
06:14:01 <roelvandijk> dcoutts: Ah, I see
06:16:03 <maltem> jkr, sorry, turns out my haddock setup is screwed so I cannot test this
06:16:27 <jkr> D'oh
06:16:36 <jkr> I just retabbed it to use 4 spaces and now it works ;)
06:18:38 <maltem> what, were there tabs?
06:19:07 <jkr> Yup, there was a tab before -- | instead of 4 spaces
06:19:19 <eipi> trying to figure out what to do regarding cabal interaction with UAC
06:19:52 <eipi> would it be correct to assume this is relevant only within the context of the platform windows distribution?
06:20:15 <dcoutts> eipi: we have a similar thing on unix, the root-cmd feature
06:20:20 <maltem> jkr: so much for Haskell and tabs ^^
06:21:26 <dcoutts> eipi: on unix, if you set the root-cmd in your ~/.cabal/config, then when you do a global install it builds as user, but when it gets to the install step, it re-invokes itself with the root-cmd (usually sudo) which prompts the user for password and then calls the program.
06:22:03 <dcoutts> eipi: on windows my guess is we can do it within the same process rather than having to re-invoke ourselves, but that's an ok approach too.
06:22:27 <eipi> the problem is we can't elevate within the same process
06:22:44 <dcoutts> eipi: is that right? I thought that's exactly what the UAC thing did.
06:23:03 <dcoutts> prompted at the moment the process was about to do something that needs the priviledges
06:23:21 <eipi> no, it is at startup time
06:23:47 <kuribas> Has anyone tried to use gstreamer to play movie?
06:23:55 <eipi> although many application prompt only when needed by either starting a new process or by invoking a com component
06:24:17 <dcoutts> eipi: doesn't UAC work for old pre-vista programs too?
06:24:29 <eipi> so that means, the UAC dialog can only get displayed once for a process, and only at startup
06:24:47 <eipi> on pre-vista, there is no UAC and so the manisfest in the exe file is ignored
06:25:13 <dcoutts> eipi: right, I mean a program compiled for XP but run on Vista, so unaware of UAC. It surely doesn't just fail.
06:25:40 <eipi> yes, pre-vista programs running on vista have two cases
06:25:46 <dcoutts> eg an old exe lacking any manifest
06:26:16 <eipi> the first case is if the exe is setup or install
06:26:32 <eipi> in that case, vista prompts for elevation even though there is no manifest
06:26:36 <dcoutts> right, if it's literally named "setup.exe" or "install.exe"
06:26:48 <eipi> or the exe is called something else and vista will assume no elevation
06:27:04 <eipi> it will raise an exception if one of the protected operation is invoked
06:27:11 <dcoutts> I see
06:27:44 <dcoutts> eipi: ok, so can we re-invoke the same program with different priviledges or does it have to be a separate .exe with a different manifest?
06:28:09 <dcoutts> eipi: it's ok if we need to do something like "run as" or "run this program with these priviledges"
06:28:26 <eipi> hmm, runas itself won't be enough
06:28:46 <eipi> the best is having two exe
06:28:55 <eipi> but some program use one just to get the other started
06:29:13 <eipi> there is a possibility to specify that the exe runs under the callee priviledge
06:29:40 <eipi> so we could get the same cabal to run priviledged or not if we go through that other program
06:30:55 <eipi> that's is, cabal runs elevating program and terminates, elevated program triggers UAC display and if confirmed then run cabal (would need to check that, but seems possible)
06:31:42 <eipi> that is why I was suggesting to have a cabal-global and cabal-user
06:32:17 <eipi> if you want to do it all through the same cabal, you cannot avoid having an auxiliary exe
06:32:56 <dcoutts> mm, an auciliary exe is possible but rather annoying
06:33:01 <eipi> (except if working with COM, but that might get things even more messy)
06:33:27 <eipi> dcoutts: my question about the platform is because of the rational for doing that on cabal
06:33:48 <dcoutts> eipi: I don't follow
06:33:49 <eipi> meaning, say you are a windows user under msys and install cabal manually
06:34:06 <eipi> your ghc folder will likely be in some msys folder
06:34:12 <eipi> you won't ever have to deal with UAC
06:34:16 <jiyunatori> hey there. i've just tried to use lenses (http://hackage.haskell.org/package/lenses-0.1.2) to build functional references. it works like a charm, except the "alter" function that returns an error - even with the example given in the documentation. here is an example : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9600#a9600
06:34:28 <dcoutts> eipi: where ghc lives is not related to where we install libs and progs
06:34:34 <eipi> so this concerns only users who would install in program files, probably using the platform
06:35:56 <eipi> dcoutts: yes, I'm not sure yet where cabal gets its defaults but it seems to write in program files by default
06:36:21 <dcoutts> eipi: it gets them from its config file
06:36:42 <eipi> yes, but I mean, how does the config file gets initialized
06:37:05 <eipi> is it hardcoded or it retrives the program files folder through win api
06:37:36 <jiyunatori> ok. now I understand my error. sorry for the disturbance :-/
06:37:40 <jiyunatori> bye
06:40:10 <cjs> Fascinating! Very early pattern matching by Dijkstra: http://www.cs.utexas.edu/~EWD/transcriptions/EWD02xx/EWD292.html
06:40:17 <eipi> the bottom line of my question is that we have to choices here regarding UAC: either make it a cabal issue or make it a platform issue
06:40:23 <dcoutts> eipi: it gets the program files folder through an api
06:40:31 <cjs> (Oh, and algebraic data types.)
06:40:36 <dcoutts> eipi: it must be a cabal issue, not platform
06:41:37 <kuribas> There seems to be no way to show a video with gstreamer in gtk2hs...
06:42:29 <eipi> dcoutts: ok, but I'm not sure I see why since a windows user under msys would not care too much about UAC if the defaults were not set this way
06:42:44 <cjs> Hm. Not quite pattern matching, but I think it even brings up the implication of dependent types. Wow.
06:42:55 <eipi> dcoutts: but fine with me, I just needed to understand
06:44:06 <dcoutts> eipi: then the solution is to check if the permissions are needed before prompting, eg if the install target is writeable by us then we don't need to elevate.
06:44:28 <gwern> 'removeColonPrefix s = if ':' `elem` s then drop 1 $ dropWhile (':' ≠ ) s else s' <-- any thoughts peeps?
06:44:28 <eipi> dcoutts: yes
06:45:18 <jkr> Is there a guideline for haddock attributes for modules, such as "stability: " and "portability:" ?
06:45:29 <jkr> When is a module stable?
06:45:29 <eipi> dcoutts: then there are two ways to handle: have the external program perform the elevated operation and keep cabal unique and avoid restarting the process
06:46:02 <eipi> dcoutts: or restart cabal elevated (and likely, redo a part of the work as I do not see it trivial to transfer the state)
06:46:03 <gwern> jkr: when it won't react with any elements without an input of joules; ie. there are no exothermic reactions
06:46:42 <jkr> Great
06:48:14 <Entroacceptor> hi, I'm trying to compile something and get src/River.hs:59:10: Type constructor `Exception' used as a class
06:48:34 <gwern> ah, the good ol' control.exception change strikes again
06:48:45 <Entroacceptor> but my ghc is 6.10.4
06:49:59 <Entroacceptor> (if that's what you were up to *g*)
06:50:10 <Entroacceptor> errr
06:50:12 <Entroacceptor> WTF?
06:50:17 <eipi> dcoutts: anyway, I'll try different things and let you know. I mainly wanted to be sure having an external exe was ok with you
06:50:50 <dcoutts> eipi: according to MSDN ShellExecute calls AIS to re-run the program at the higher priviledge level
06:50:57 <Entroacceptor> gwern: any idea why it does work with runhaskell Setup build, but NOT cabal install?
06:51:23 <gwern> Entroacceptor: cabal-install can ask for different deps than runhaskell; I'd turn on verbose to see what's happening
06:52:09 <dcoutts> Entroacceptor: it's because cabal picks base 3 by default, but that app clearly needs base 4
06:52:44 <dcoutts> Entroacceptor: runhaskell Setup configure just picks the latest of everything where as cabal picks stuff that's more likely to work more of the time
06:53:04 <Entroacceptor> ok, thanks
06:53:15 <Entroacceptor> can I tell cabal to use base 4 for this package, then?
06:53:29 <Entroacceptor> (to tell the programmer, maybe)
06:53:51 <dcoutts> Entroacceptor: the package author should fix the .cabal file, you can workaround it using --preference='base>=4'
06:54:50 <Entroacceptor> thanks
06:55:46 <chrisdone> what's that pastebin written partly in haskell that actually compiles and runs the code?
06:55:55 <Entroacceptor> dcoutts: thank you, that worked
06:56:10 <whoppix> chrisdone, codepad.org?
06:56:11 <eipi> dcoutts: afaik, shellexecute is indeed the mechanism for calling the exe, but it won't make priviledged an appli that is not marked with the manifest...have you found it will?
06:56:21 <chrisdone> whoppix: thanks
06:56:30 <dcoutts> eipi: yes, http://msdn.microsoft.com/en-us/library/bb756945.aspx
06:56:44 <dcoutts> eipi: "ShellExecute() looks specifically for this new error and, upon receiving it, calls across to the Application Information service (AIS) to attempt the elevated launch."
06:57:39 <dcoutts> eipi: however I cannot find any docs on the AIS
06:58:49 <eipi> dcoutts: AIS is just the subsystem, not an API
06:59:07 <eipi> dcoutts: but you were reading the "elevated user" section right?
06:59:18 <dcoutts> eipi: it must have one, but it looks like it's not one that we're expected to use
06:59:51 <eipi> dcoutts: the problem is that even an admin is running things as "standard user" with UAC
06:59:52 <gwern> bleh. given a function foo :: ComplFunction where type ComplFunction = String -> IO [String], and given bar :: [String] -> [String], how do I rewrite 'quux ... $ foo $ baz' to 'quux ... $ bar foo $ baz'? 'fmap bar foo' isn't working
07:00:40 <mauke> gwern: too confusing
07:00:45 <gwern> and 'fmap bar . foo' doesn't seem to work either
07:01:23 <eipi> dcoutts: to run things as elevated, you must make it clear (e.g., starting a cmd shell elevated) and then, you would follow the "elevated" path for launching
07:01:33 <gwern> mauke: well, I'm not sure it isn't a syntax issue; usually I don't have problems figuring out what the right incantation is to combine stuff like 'String -> IO [String]' and '[String] -> [String]'
07:01:36 <eipi> dcoutts: even if you are admin
07:01:53 <mauke> gwern: what are the types of baz and quux?
07:02:11 <gwern> dunno
07:02:14 <dcoutts> eipi: I realise
07:02:24 <eipi> dcoutts: but maybe would it be acceptable to request that from the user, we could document that to use cabal, you need to open an elevated command line
07:02:43 <eipi> dcoutts: the audience are developers after all, they are typically aware of UAC issues
07:03:09 <dcoutts> eipi: I was hoping I could just call AIS or ShellExecute to run the same cabal.exe but with elevated permissions, without having to make a separate .exe
07:03:18 <eipi> dcoutts: current problem with cabal is mainly a lake of reporting of the problem (it fails silently I think)
07:03:37 <dcoutts> eipi: I'd rather make it "Just Work" and not require the users do funny workarounds
07:03:42 <eipi> dcoutts: yes, that's what I understood from your message...I would have liked it too :)
07:04:40 <dcoutts> eipi: what doesn't make sense from that page, is it says that CreateProcess will return an error code if the program needs elevated priviledges, which ExecuteShell looks for
07:04:59 <eipi> yes, they created a new exception
07:05:10 <dcoutts> eipi: but if that's the case then how do we use CreateProcess to run our helper program that does need elevated priviledges
07:05:36 <dcoutts> supposing we have a helper with the manifest that says it needs elevated priviledges
07:06:00 <eipi> eipi: shellexecute runs things with different verbs
07:06:05 <dcoutts> or do we have to call ShellExecute instead
07:06:10 <dcoutts> which is fairly horrible
07:06:17 <eipi> eipi: to launch a process requiring elevated, you would use the "runas" verb
07:07:01 <eipi> create process is just a nicer API for the old shellexecute
07:07:16 <eipi> ro something like that
07:08:19 <eipi> dcoutts: launching the appli elevated when it has the manifest is trivial with shellexecute
07:08:38 <dcoutts> wow, ShellExecute really is horrible
07:08:44 <eipi> dcoutts: I don't know about createprocess, but I believe it's not part of what we have access to
07:08:45 <dcoutts> it requires you initialise COM
07:09:01 <dcoutts> eipi: CreateProcess is the normal api we use
07:09:27 <eipi> dcoutts: ah, I see
07:10:12 <eipi> dcoutts: yes, sorry, createprocess is lower level than shellexecute...shellexecute corresponds to launching application or documents as the user does (with double-click on icons)
07:10:20 <dcoutts> right
07:10:44 <eipi> dcoutts: that is why we need shellexecute: to simulate the user right-clicking on the exe and selecting "runas"
07:13:21 <Twey> gwern: fmap (quux … . bar) $ foo baz
07:13:32 <SamB> anyone know if SVN supports symlinks ?
07:15:00 <eipi> dcoutts: I do not see shellexecute in the haskell win32 binding library
07:15:36 <sereven> gwern: if you're still having trouble need more context, looks like fmap bar . complF :: String -> IO [String] is indeed what you were describing.
07:17:37 <zack> is there any way to calculate more than about 18 digits of precision in floating point calculations, without extra libraries?
07:19:20 <byorgey> zack: not without basically reimplementing existing libraries yourself.
07:19:32 <byorgey> what's the point of not using extra libraries?
07:20:20 <zack> so that anyone can run it with any haskell interpreter without setting up a hugs mess of libraries?
07:20:22 <dcoutts> eipi: http://msdn.microsoft.com/en-us/library/bb756990.aspx also says we have to use ShellExecute
07:20:27 <thebloggu> i am programming an application that needs to connect and fetch info from gmail. can someone give me some hints how can i do that?
07:20:43 <dcoutts> eipi: that or worse, make some COM object
07:21:34 <ksf> thebloggu, connect to the internet.
07:21:44 <ksf> get the data, in whatever format you get it.
07:21:48 <ksf> then analyse it.
07:22:28 <ksf> what part of that you're worried about?
07:22:55 <Saizan> does google offer a gmail api?
07:23:12 <ksf> they could even offer imap or such
07:23:31 <thebloggu> Saizan, that's my point
07:23:41 <thebloggu> ksf what library could i use for that?
07:23:43 <dcoutts> eipi: perhaps we could spend our time better making things work nicely for the user-only case.
07:23:46 <zack> does haskell come with any sort of bigdecimal library?
07:23:52 <eipi> dcoutts: yes, no way arround, so far was clear
07:23:54 <dcoutts> zack: Integer
07:24:04 <dcoutts> eipi: ie --user installs
07:24:15 <eipi> dcoutts: :) hence my questions regarding the defaults and the platform
07:24:18 <ksf> http://hackage.haskell.org/package/HaskellNet
07:24:29 <ksf> ...offering imap, pop3 and smtp.
07:24:39 <ksf> with any kind of luck that's all the net code you're going to need.
07:24:49 <eipi> dcoutts: also, one thing to address would be to fail with an error (I'll work on that)
07:25:23 <ksf> > 2^64^64
07:25:24 <zack> dcoutts: sorry? i said big decimals
07:25:27 <dcoutts> eipi: I presume it already fails with an error :-) just not a very nice one right? Presumably it fails as soon as it starts copying files to the destination right?
07:25:28 <lambdabot>   mueval: ExitFailure 1
07:25:32 <Saizan> zack: there's the Rational type
07:25:33 <ksf> > 2^64^4
07:25:36 <lambdabot>   181858529856973800789277132777499061892485968097894083110781124867581621200...
07:25:42 <ksf> is that big enough?
07:25:52 <dcoutts> zack: do you mean only positive integers?
07:26:00 <FunctorSalad_> is there a difference in use case between UArray and uvector? http://hackage.haskell.org/package/uvector
07:26:34 <FunctorSalad_> (or is uvector a remake taking advantage of associated classes)
07:26:37 <ksf> > maxBound :: Integer
07:26:38 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
07:26:38 <lambdabot>    arising...
07:26:38 <zack> > 1/7
07:26:39 <lambdabot>   0.14285714285714285
07:26:44 <eipi> dcoutts: I'll need to check precisely, but from what I remember, it fails with error if during the build, but silently during the install
07:26:46 <FunctorSalad_> err, associated types :)
07:27:00 <ksf> > 1%7 + 1%3
07:27:01 <lambdabot>   10 % 21
07:27:12 <zack> if i wanted more precision with 1/7 what do i do
07:27:14 <dcoutts> eipi: an example log of a failure would be useful to attach to the ticket in trac
07:27:32 <thebloggu> ksf thanks :)
07:27:38 <eipi> dcoutts: sure. I'll check all that.
07:27:41 <dcoutts> zack: so you mean precise rationals ?
07:28:05 <ksf> > 1/7 :: CReal
07:28:05 <lambdabot>   0.1428571428571428571428571428571428571429
07:28:16 <zack> oh yea
07:28:43 <ksf> but I 1 % 7 is the most prescision you will get.
07:28:43 <dcoutts> zack: ok, then you want Rational
07:29:13 <zack> can you get a few thousand / million digits?
07:29:22 <ksf> with Rational Integer, yes.
07:29:50 <ksf> > (1 % 2^52) * (1%3)
07:29:51 <dcoutts> zack: you can make them as big as you've got RAM to hold them in :-)
07:29:51 <lambdabot>   1 % 13510798882111488
07:30:07 <ksf> > (1 % 2^52) / (1%3)
07:30:08 <lambdabot>   3 % 4503599627370496
07:30:19 <dcoutts> zack: which is a problem in itself, there's no limit on the precision which makes it unsuitable for some algorithms.
07:30:21 <ksf> > (1 % 2^52^4) / (1%3)
07:30:24 <lambdabot>   3 % 54047635068644565872947646127077290943963966421881803212654285483473985...
07:31:23 <ksf> you don't get all the members of the Floating class, that is. sqrt, cos, atan etc.
07:31:27 <zack> > 1/7 :: Rational
07:31:28 <lambdabot>   1 % 7
07:32:06 <zack> what's the best solution then
07:33:03 <FunctorSalad_> CReal or similar if you want both arbitrary precision and sqrt etc
07:33:19 <zack> > 1/7 :: CReal
07:33:20 <lambdabot>   0.1428571428571428571428571428571428571429
07:33:34 <zack> > sqrt 7 :: CReal
07:33:34 <lambdabot>   2.6457513110645905905016157536392604257103
07:33:35 <byorgey> zack: what exactly are you trying to do?  the best solution depends a lot on what you need.
07:33:51 <zack> i'm trying to perform calculations involving decimals
07:34:23 <Saizan> we got that part already :)
07:34:48 <Saizan> on an higher level?
07:35:22 <zack> example: 20000th digit of sqrt 7
07:35:41 <Saizan> so you're building a calculator?
07:36:14 <zack> no
07:36:40 <benmachine> finding out the 20000th digit of sqrt 7 probably wouldn't be too hard
07:36:51 <benmachine> but finding out the nth digit of f(m) might be more difficult
07:39:09 <byorgey> zack: sounds to me like you want CReal, then
07:39:14 <nainaide> :t maybe
07:39:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:39:24 <byorgey> or one of the other infinite-precision real number libraries
07:39:33 <FunctorSalad_> > floor ((sqrt 7)*(10^20000)) `mod` 10
07:39:34 <lambdabot>   6
07:39:47 <FunctorSalad_> that was fast...
07:39:56 <byorgey> hahaha, right =)
07:40:15 <ksf> is gmap the state of the art wrt. generic, blazingly fast maps? it seems a bit old.
07:40:16 <nainaide> What is  does funtion  maybe  work  for? Please
07:40:42 <byorgey> nainaide: the maybe function is for taking a value of type  (Maybe a)  and turning it into something else.
07:40:54 <byorgey> the first argument says what to do if you have Nothing
07:41:00 <byorgey> the second argument says what to do if you have Just.
07:41:18 <Orclev> hey, does ghc honor the settings in your .ghci file?
07:41:23 <byorgey> > maybe "hello" show (Just 3)
07:41:24 <lambdabot>   "3"
07:41:28 <byorgey> > maybe "hello" show Nothing
07:41:29 <lambdabot>   "hello"
07:41:55 <byorgey> Orclev: I doubt ghc looks at your .ghci file.
07:42:27 <Orclev> byorgey: I didn't think so, but figured I'd check... just trying to figure out a way to enable -fglasgow-exts by default
07:43:00 <nainaide> byorgey,  thanks
07:43:01 <benmachine> > maybe 0 length $ lookup 2 [(0,[1]),(2,[4,3])]
07:43:02 <lambdabot>   2
07:43:06 <zack> > floor ((sqrt 7)*(10^2000)) `mod` 10
07:43:07 <lambdabot>   6
07:43:16 <zack> > floor ((sqrt 7)*(10^5000)) `mod` 10
07:43:17 <lambdabot>   6
07:43:36 <zack> > floor ((sqrt 7)*(10^5001)) `mod` 10
07:43:36 <lambdabot>   6
07:43:41 <byorgey> zack: bet you didn't know that sqrt 7 eventually turns into all 6's, did you? ;-)
07:43:49 <zack> no it does not
07:43:54 <FunctorSalad_> hmm? was I doing it wrong?
07:44:21 <zack> CReal doesn't give you more than a certain amount of digits
07:44:37 <byorgey> zack: it gives you as many as you want.  Just by default it only prints out a certain number
07:44:59 <byorgey> FunctorSalad_: ...I can't tell if you're joking or not.
07:45:19 <Orclev> if I recall correctly the imprecision of the floating point operations mean that after a certain point you lose any real results to noise
07:45:28 <byorgey> Orclev: that's correct.
07:45:32 <zack> > floor ((sqrt 100)*(10^2000)) `mod` 10
07:45:33 <lambdabot>   6
07:45:50 <byorgey> haha, well done =)
07:46:07 * FunctorSalad_ is afraid to answer now :(
07:46:32 <byorgey> FunctorSalad_: computing (sqrt 7)*(10^20000) is well beyond the precision of double
07:46:42 <byorgey> you'll get SOME answer but it won't have anything to do with sqrt 7.
07:46:59 <FunctorSalad_> byorgey: hehe I somehow assumed it was CReal
07:47:08 <byorgey> ah, no, it defaults to double =)
07:47:23 <zack> how do i compute with a CReal?
07:47:31 <FunctorSalad_> @set -vDWIM
07:47:31 <lambdabot>   Parse error: SemiColon
07:47:37 <byorgey> > floor ((sqrt 7 :: CReal) * (10^20000)) `mod` 10
07:47:41 <lambdabot>   mueval-core: Time limit exceeded
07:47:55 <Orclev> lol
07:48:40 <zack> Not in scope: class or type constructor CReal
07:48:49 <Orclev> what package is CReal in?
07:49:00 <FunctorSalad_> Orclev: numbers and HERA
07:50:26 <Orclev> hmm... what's HERA for?
07:50:40 <Orclev> no description is provided in the cabal listing
07:52:51 <byorgey> zack: you have to install the 'numbers' package and 'import Data.Number.CReal'
07:54:12 <zack> i have a feeling that BigFloat is what i need
07:54:23 <monadic_kid> BigFoot?
07:54:25 <Orclev> wow, I've got a 3.2 ghz, and running that thing has pegged one of my cores
07:54:48 <Orclev> and no sign of stopping anytime soon
07:55:01 <byorgey> how would it give you a sign of stopping soon?
07:55:29 <FunctorSalad_> :)
07:55:31 <Orclev> ... probably by stopping and/or complaining about lack of memory, the later being highly unlikely as I've got 8G
07:55:33 <byorgey> "ghc: warning: computation will stop soon"
07:56:08 <Orclev> maybe heap overflow I suppose... that's more likely
07:56:14 <FunctorSalad_> hmm it could accept a callback to which it sends how many digits it has computed
07:56:27 <byorgey> I would assume that it would run in constant memory, if properly optimized
07:56:55 <byorgey> Orclev: are you running it in ghci?  or did you make a .hs file and compile it with -O2 ?
07:57:03 <FunctorSalad_> are you using numbers or the HERA? HERA seems to have some tricky IORef stuff
07:57:04 <byorgey> (I suggest the latter...)
07:57:04 <Orclev> byorgey: ghci
07:57:21 <Orclev> I'm using numbers
07:57:35 <FunctorSalad_> the numbers implementation is data CReal = CR (Int -> Integer)
07:57:46 <byorgey> Orclev: running something like this in ghci can be orders of magnitude slower than properly compiling+optimizing it
07:58:00 <FunctorSalad_> HERA: data CReal = CReal { state :: IORef (Nat, DI.Interval),
07:58:00 <FunctorSalad_>                      eval :: Nat -> CReal -> DI.Interval }
07:58:21 <jkr> Can I uninstall packages with cabal?
07:59:01 <byorgey> jkr: no
07:59:09 <byorgey> jkr: ghc-pkg unregister
07:59:16 <byorgey> is all you can do.
07:59:25 <jkr> Thanks
08:00:59 <defun> I remeber that someone mentioned that the current hardware architectures are designed for imperitive languages, and are not designed with functional languages like haskell in mind. Are there any CPUs out there for which this is not true?
08:01:29 <Orclev> byorgey: I compiled it with -O2, lets see if it runs any faster than the previous aborted attempt
08:01:48 <blackdog> defun: that's largely a misconception, i think. functional languages can be pretty efficient on stock hardware, and with massive multicore that's only going to become more true...
08:02:05 <Orclev> lol, oh yeah, core3 is pegged at 100%
08:02:10 <Twey> defun: The Reduceron
08:02:14 <defun> I figured as much, just wanted to verify
08:02:16 <Jafet> What is an imperative, and what is a functional language?
08:02:23 <defun> Twey: lol
08:02:23 <Twey> http://www.cs.york.ac.uk/fp/reduceron/
08:02:37 <defun> oh, you were serious
08:02:42 <Twey> Quite.  :þ
08:03:45 <byorgey> Jafet: in general, imperative languages are centered around the notion of sequencing commands/modifying state; functional languages are centered around the notion of composing functions/computing outputs from inputs.
08:03:59 <Twey> Interestingly, early tests show that it is capable of executing most functional algorithms much faster than the equivalent imperative hardware can the equivalent imperative algorithms.
08:04:01 <byorgey> although both can be rather fuzzy notions.
08:04:20 <Twey> I think ‘state-oriented’ and ‘value-oriented’ would be a better distinction to make here.
08:04:30 <Orclev> at some point it always has to come back to the notion of twiddling bits
08:04:44 <Berengal> I need a structured data language that's easily readable and has a pure haskell implementation... any recommendations?
08:05:17 <ksf> not if you're an fpga, as then the universe cares about fiddling bits.
08:05:34 <Jafet> byorgey, a lot of people have very vague stereotypical notions, unfortunately
08:05:39 <ksf> Berengal, adt's?
08:06:00 <Jafet> xml!
08:06:09 <ksf> ZOMG NO!
08:06:20 <ksf> yaml?
08:06:36 <ksf> *gasp* JSON?
08:06:38 <Berengal> I was looking at yaml, but none of the implementations struck me as being awesome
08:06:46 <Orclev> depending on how complex your structure needs to be, JSON can work in some cases, but I don't know if there's a implementation in haskell
08:06:50 <Jafet> I find it funny that XML has a comment syntax. That's like... missing the entire point of XML (if it had one to begin with)
08:06:51 <Berengal> JSON is borderline unreadable for my purposes...
08:07:06 <pakito> juego de boxeo online http://www.kobox.org/kobox-fande-Nourine.html
08:07:36 <Berengal> I basically just need a map... simple colon-separated fields would probably do, but I could be wrong and that'd mean rewriting
08:08:20 <Orclev> hmm... doesn't haskell serialize maps as more or less a colon-seperated field by default?
08:08:29 <jkr> What does the ":=" syntax mean?
08:08:39 <jkr> As in "data Foo = Bar := Baz"
08:08:54 <Berengal> Orclev, the show instance is just "fromList $assoc-list"
08:09:03 <ksf> @hoogle (:=)
08:09:04 <lambdabot> Control.Parallel.Strategies (:=) :: a -> b -> Assoc a b
08:09:08 <Saizan> jkr: ":=" is the name of the data constructor for jkr there
08:09:16 <FunctorSalad_> Berengal: that sounds like what you wanted
08:09:21 <Saizan> ehm, for Foo, i mean
08:09:33 <jkr> Ah, o
08:09:34 <jkr> k
08:09:37 <monadic_kid> lol
08:09:50 <ksf> read it as data Foo = Assoc Bar Baz
08:09:54 <Berengal> FunctorSalad_, by readable I meant human-readable
08:09:56 <Saizan> you can have infix operators as data constructors as long as they start with :
08:10:15 <ksf> with the right extension, you could also write data Foo = Bar `Assoc` Baz
08:10:34 <Saizan> do you really need an extension for that?
08:10:35 <Berengal> Computers read anything that throws a grammar at it. Humans have all these silly notions of whitespace and formatting...
08:10:54 * ksf guesses its TypeLevelOperators, but I might be wrong
08:11:27 <Orclev> maybe just write a simple parser... something like <key>:<value>\n
08:11:27 <Saizan> TypeOperators is about allowing operators as variable names, iirc
08:12:21 <Orclev> or depending on your platform \r\n I guess
08:12:21 <ksf> ...you can't do type Foo = Bar `Baz` Quux without TypeLevelOperators, at least.
08:12:35 <Berengal> Orclev, I could do that, but then one of the fields would be a huge-large thing tacked onto the end... which works, but doesn't if I want more of them, in lists, which I'm pretty sure I do, at least if it's easy to do
08:12:44 <FunctorSalad_> Berengal: but a whitespaced haskell-syntax assoc-list is still readable by read
08:12:47 <ksf> but yeah, as Assoc is a constructor and not a type...
08:12:56 <ksf> (damn them capital letters!)
08:13:16 <jkr> So if Bar and Baz were both Strings, I could construct a Foo with "foo" := "bar" ?
08:13:34 <Berengal> FunctorSalad_, I'd also need a datatype inside to get at least a semi-tree like structure
08:14:53 <Orclev> I thought this was supposed to be a simple map? Now it needs to be tree-like?
08:15:02 <Warrigal> jkr: if Bar and Baz are both the same type as String.
08:15:25 <jkr> I think they are
08:15:29 <Warrigal> In that declaration, (:=) :: Bar -> Baz -> Foo
08:15:32 <jkr> I'm trying to understand this: http://hackage.haskell.org/packages/archive/hSimpleDB/0.3/doc/html/Network-AWS-SimpleDB.html#t%3AAttribute
08:15:41 <jkr> The Attribute
08:16:12 <jkr> So instead of writing Attribute "foo" "bar", I could write "foo" := "bar"?
08:16:34 <Saizan> jkr: yes
08:16:44 <jkr> Great, thanks :)
08:17:02 <Berengal> Orclev, simple tree-like map
08:17:06 <Saizan> there's no requirement that the constructor is the same as the type name
08:17:30 <Berengal> Orclev, basically... yaml seems to fit nicely...
08:18:04 <Orclev> byorgey: not sure when but that code finally terminated with a result of 3
08:18:19 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9602#a9602
08:23:58 <HugoDaniel> hi
08:24:11 <roelvandijk> HugoDaniel: Hello
08:44:50 <bjorkintosh> i installed some packages via cabal, but ghc doesn't seem to know where they are...
08:45:02 <bjorkintosh> is there a GHCPATH variable setting i need to make?
08:45:37 <dcoutts> bjorkintosh: are you sure they installed ok? ghc-pkg list will say if ghc knows about them.
08:45:40 <ehamberg> check ghc-pkg list
08:46:07 <dcoutts> bjorkintosh: if you're running runghc Setup configure and that says it can't find them then see the Cabal FAQ
08:46:26 <bjorkintosh> dcoutts, i'm not running runghc Setup.
08:46:32 <bjorkintosh> i purged debian and installed archlinux.
08:46:47 <bjorkintosh> it seems far more ghc friendly than debian.
08:47:04 <dcoutts> it's certainly more bleeding edge when it comes to ghc
08:48:00 <maurer_> Debian just isn't used to things like compilers having this fast a release cycle.
08:49:01 <bjorkintosh> ghc-pkg list knows nothing of the packages in .cabal
08:49:07 <bjorkintosh> can i register them somehow?
08:49:21 <dcoutts> bjorkintosh: then they didn't install properly
08:49:37 <dcoutts> bjorkintosh: unless you're looking at programs, which do not get registered
08:49:59 <bjorkintosh> how do i tell ghc about them then?
08:50:04 <dcoutts> you need to install them
08:53:31 * Alpounet recording a 3D Text Rendering video (Haskell of course)
08:54:41 <dcoutts> bjorkintosh: did you upgrade ghc or something since you installed those user packages?
08:54:55 <bjorkintosh> no.
08:55:23 <bjorkintosh> i run cabal as root expecting that it would install everything somewhere under /usr/lib/ghc etc...
08:55:28 <dcoutts> ohhh
08:55:32 <bjorkintosh> but it installed everything under /root/.cabal/
08:55:40 <dcoutts> bjorkintosh: per-user install is the default
08:55:48 <bjorkintosh> oh.
08:56:08 <dcoutts> bjorkintosh: if you really want to do global installs you can use --global, and you can set the default in the ~/.cabal/config file
08:56:31 <dcoutts> bjorkintosh: but per-user installs is a reasonable default
08:56:52 <bjorkintosh> okay.
08:56:58 <bjorkintosh> so how do i convince ghc to look at that?
08:57:05 <dcoutts> it does it automatically
08:57:16 <bjorkintosh> okay.
08:57:30 <bjorkintosh> i just moved everything to ~bjork/.cabal/
08:57:39 <bjorkintosh> and i'm changing the conf file to look at the ~ as well..
08:57:40 <dcoutts> right, that will not work
08:57:53 <dcoutts> because the ghc registration info is separate
08:58:08 <dcoutts> and you can't easily move that since it embeds paths
08:59:35 <dcoutts> bjorkintosh: the point is you can't really move them about, you just need to install them as your own user
08:59:47 <dcoutts> ie the default behaviour works
09:00:14 <bjorkintosh> okay.
09:02:05 <porges> does anyone know of an example of tying-the-knot on a graph-like data structure?
09:02:52 <osfameron> ooo, would pandoc be a good way to typeset a book?  I really really really *hate* latex for authoring (mainly because its crappy error reporting makes it excruciating to debug) but it makes pretty output, and pandoc can write latex
09:03:35 <ehamberg> osfameron: (a bit off-topic) tried lyx?
09:04:32 <osfameron> ehamberg: yeah... I found it very easy to confuse by making it write invalid latex... but that's another good option, yeah
09:05:13 <osfameron> my next preferred option is probably HTML -> print to PDF in firefox :-)
09:05:17 <porges> oh, found the dfa example on the wiki :)
09:05:18 <osfameron> but that's *really* offtopic
09:11:07 <Berengal> osfameron, if markdown/ReST is good enough, then pandoc can probably do what you want
09:13:02 <osfameron> yeah... I think it might be.  And I guess if it isn't I can get it to output latex and then swear blindly at that till it does the right thing
09:15:35 <Berengal> I wouldn't want to typeset a book in HTML though...
09:17:19 <osfameron> the HTML source would compile, silently screwing you over, while the latex refuses to compile, giving you a misleading error that screws you over more loudly :-)
09:27:54 <ksf> I want faster sparse indexing than O(log n). I don't care much about insert performance, as long as it's not exessively abysmal.
09:32:35 <FunctorSalad_> there are a lot of test frameworks on hackage these days
09:33:39 <ksf> something like an IntTree that splits on the lowest bit first.
09:33:51 <ksf> er IntTrie
09:33:52 <ziman> something like IntMap?
09:34:19 <ksf> IntMap (or, rather, EnumMap) is fast, but not as fast as I want it to be.
09:35:04 <ksf> ...I'm looking for something specifically tuned towards lookups, as those occur like 10000 to a million times more often.
09:35:50 <Phyx-> oh, i'm on irc
09:39:33 <benmachine> hi, me too
09:41:34 <sleepynate> orly? ><
09:43:50 <Gracenotes> ksf: maybe a hand-made binary trie?
09:43:56 <Berengal> ksf, array?
09:45:01 <Gracenotes> uh, EnumMap? you mean, mapping every element of an Enum to an element? an Array (UArray, if possible) would be nice there
09:45:31 <Berengal> EnumMap is an IntMap for Enums
09:45:45 <Gracenotes> if the Enum is small enough of course
09:45:49 <Berengal> Basically a wrapper, as far as I gathered
09:46:53 <Gracenotes> java, incidentally, has an EnumMap, which is just an array of enums with a mapping indices<->enums. Java enums are not as flexible as Haskell's, though..
09:46:54 <Gracenotes> ...
09:47:15 <Gracenotes> and some of ours are not finite
09:47:30 <ksf> Enums have to be small enough.
09:47:36 <ksf> :t fromEnum
09:47:37 <lambdabot> forall a. (Enum a) => a -> Int
09:47:49 <Twey> Well, they don't.
09:47:55 <Berengal> Java enums are just singletons
09:48:02 <Twey> They could be non-unique on that Int.
09:48:14 <Gracenotes> oh, yes, that's true. They have a finite operating range, even if they are infinite types
09:48:16 <Twey> (but still compare non-equal)
09:48:34 <Twey> > maxBound :: Int
09:48:34 <lambdabot>   9223372036854775807
09:48:53 <Twey> :t toEnum
09:48:54 <lambdabot> forall a. (Enum a) => Int -> a
09:49:00 <Gracenotes> Berengal: yeah. similar to Haskell in that you can go from index to item, and item to index
09:49:12 <Twey> > succ $ toEnum maxBound
09:49:13 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
09:49:18 <Twey> Woah.
09:49:22 <Gracenotes> and also get a collection with a range of them
09:49:24 <Twey> > succ $ toEnum (maxBound - 1)
09:49:24 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
09:49:32 <aavogt> @check \x -> (toEnum . fromEnum) x == x
09:49:32 * Twey scratches his head.
09:49:33 <lambdabot>   "OK, passed 500 tests."
09:49:33 <Gracenotes> huh
09:49:36 <Twey> > succ $ toEnum (maxBound - 2)
09:49:36 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
09:49:51 <Twey> I don't understand.
09:50:00 <Gracenotes> > succ $ toEnum (maxBound :: Int)
09:50:00 <Twey> > succ $ toEnum 3
09:50:01 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
09:50:01 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
09:50:09 <Twey> Oh
09:50:13 <Twey> It's trying to convert it to ()?
09:50:31 <Twey> > toEnum 0
09:50:32 <lambdabot>   ()
09:50:32 <Berengal> Gracenotes, the indexes aren't what define the enum though. EnumMap is just a wrapper around a bitmap
09:50:36 <Twey> > succ $ toEnum 0
09:50:37 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
09:50:40 <Twey> Arr.
09:51:15 <Gracenotes> Berengal: in terms of similarity to Haskell's
09:51:22 <ray> > (toEnum maxBound) :: Float
09:51:23 <lambdabot>   9.2233721e18
09:51:28 <aavogt> > minBound == maxBound
09:51:29 <lambdabot>   True
09:51:43 <Gracenotes> > succ (maxBound :: Int)
09:51:43 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
09:51:51 <Gracenotes> psh, cheater
09:52:11 <ray> stupid not-stupid haskell
09:52:40 <Gracenotes> > abs minBound == (minBound :: Int)
09:52:41 <lambdabot>   True
09:53:16 <ray> > abs Int h
09:53:17 <lambdabot>   Not in scope: data constructor `Int'
09:54:52 <Twey> o.@
09:56:05 <roconnor> > abs minBound
09:56:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:56:05 <lambdabot>    `GHC.Enum.Bounded a'
09:56:05 <lambdabot>    ...
09:56:11 <roconnor> > abs minBound :: Int
09:56:12 <lambdabot>   -9223372036854775808
09:56:18 <ray> =o
09:56:57 <Twey> > minBound :: Int
09:56:57 <lambdabot>   -9223372036854775808
09:57:01 <Twey> > abs minBound :: Int
09:57:01 <roconnor> > negate minBound :: Int
09:57:02 <lambdabot>   -9223372036854775808
09:57:02 <lambdabot>   -9223372036854775808
09:57:09 <Twey> Haha
09:57:15 <Twey> abs can produce a negative result
09:57:33 <Elly> this is always how twos-complement integers have worked :P
09:57:35 * roconnor puts that question on an exam for his students
09:57:44 <aavogt> @check \x -> abs x >= 0
09:57:45 <lambdabot>   "OK, passed 500 tests."
09:57:52 <Twey> The illogic and counter-intuitiveness of overflows never fails to astonish me
09:58:11 <Elly> @hoogle fix
09:58:11 <lambdabot> Data.Function fix :: (a -> a) -> a
09:58:11 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
09:58:11 <lambdabot> module Control.Monad.Fix
09:58:52 <Gracenotes> yes, the abs value is a fixpoint for the particular pattern of bits of the lowest value in two'
09:58:55 <Gracenotes> s complement
09:59:15 <aavogt> > abs 0
09:59:16 <lambdabot>   0
09:59:22 <roconnor> if only 2^64 was prime
09:59:25 <Gracenotes> a
09:59:38 <mux> @check \n -> n >= 0 ==> sum [1..n] == n * (n+1) `div` 2
09:59:39 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:59:39 <lambdabot>                     (Test.QuickCh...
09:59:46 <Baughn> @check \x -> abs (x :: Int) >= 0
09:59:47 <lambdabot>   "OK, passed 500 tests."
10:00:01 <mux> @check \n -> (n::Int) >= 0 ==> sum [1..n] == n * (n+1) `div` 2
10:00:01 <lambdabot>   No instance for (Test.QuickCheck.Testable
10:00:01 <lambdabot>                     (Test.QuickCh...
10:00:05 <Gracenotes> it's funny, doing the bitwise absolute value procedure, and getting exactly what you started with. for 0 it's less surprising, but still :P
10:00:35 <aavogt> > minBound + maxBound :: Int
10:00:36 <lambdabot>   -1
10:01:44 <Twey> roconnor: If 2^64 were prime then it wouldn't be 2^64… :þ
10:02:14 <Gracenotes> Twey: it is the 1970s. You must choose: 1. Having an extra negative value in integers 2. Having two zeroes. WHAT IS YOUR CHOICE :o
10:02:28 <Elly> having two zeroes is lame
10:02:42 <Elly> roconnor: haha
10:03:06 <Gracenotes> to be fair, you do get a nice subtraction algorithm for free..
10:07:36 <FunctorSal> is there some package for pretty tree printing?
10:08:23 <Saizan> Data.Tree has drawTree
10:09:08 <FunctorSal> hmm yes, I guess converting it to a Data.Tree is simplest, thanks
10:12:57 <Twey> Gracenotes: No no, I'm okay with having an extra negative value in integers.
10:13:13 <Twey> I just think we ought to handle overflows in a more sensible way.
10:13:17 <Twey> Like with an error.
10:13:44 <Gracenotes> Twey: like, say, the ALU setting an overflow flag if overflow occurs?
10:13:55 <mux> @check \n -> sum [1..n] == signum n * n * (n+1) `div` 2
10:13:55 <Twey> Yeah.  Like that.  :þ
10:13:56 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
10:14:04 <Gracenotes> (hint: it does)
10:14:08 <FunctorSal> :o
10:14:19 <Twey> It does, but C didn't use it
10:14:31 <Twey> (automatically)
10:14:32 <Gracenotes> no one uses it, afaik -_-
10:14:36 <Twey> So we get this.
10:14:44 <mux> @check \n -> sum [1..n] == signum n * (n * (n+1)) `div` 2
10:14:45 <lambdabot>   "Falsifiable, after 6 tests:\n-2\n"
10:15:04 <holmak> hm?
10:15:15 <holmak> sorry, wrong window
10:15:33 <mux> oh
10:15:42 <mux> @check \n -> sum [1..abs n] == signum n * (n * (n+1)) `div` 2
10:15:43 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n"
10:16:26 <Heffalump> n(n+1) will always be positive
10:16:26 <c_wraith> I wish quickcheck counted tests properly.
10:16:32 <c_wraith> or 0
10:16:58 <Gracenotes> for integers at least
10:17:02 <c_wraith> unless n is not an integer
10:17:04 <HugoDaniel> how do i transform this: mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b, into something like this: (Monad m) => (a -> m b) -> IntMap (Maybe a) -> m (IntMap b)  ?
10:17:04 <c_wraith> yeah
10:18:06 <Alpounet> you meant IntMap (m a) right ?
10:18:36 <mux> @check \n -> let n' = abs n in sum [1..n'] == n' * (n' + 1) `div` 2
10:18:36 <lambdabot>   "OK, passed 500 tests."
10:18:46 <Gracenotes> or even (IntMap a).. to be honest, I'm not inferring what that function does from its type signature
10:19:07 <M_o_C> Gracenotes: (How) Can you detect if the overflow bit is set from within haskell?
10:19:18 <benmachine> there's an overflow bit?
10:19:21 <Gracenotes> I'm not positive if you can
10:19:43 <HugoDaniel> alpounet, no i mean m (IntMap a)
10:19:54 <HugoDaniel> i just search at hoogle, and it gave me mapM_
10:19:58 <aavogt> HugoDaniel: traverse has has the right type
10:20:00 <holmak> There was an interesting article by Slava Pestov recently about adding control of floating-point ops to Factor
10:20:01 <Gracenotes> of the limited number of PLs I know, I can't say I /know/ of any that do. well, besides assembly :o
10:20:05 <roconnor> checking an overflow bit doesn't sound very pure
10:20:18 <aavogt> but that is the same as mapM
10:20:30 <Alpounet> anyone has a pointer to a *sweet* intro to Kleisli related stuffs ?
10:20:45 <roconnor> not without making a whole new operator
10:20:50 <Gracenotes> roconnor: not sure if addition itself is that pure
10:21:06 <aavogt> > mapM (\x -> case x of 0 -> Nothing; _ -> Just x) [0..10]
10:21:07 <lambdabot>   Nothing
10:21:22 <aavogt> > mapMaybe (\x -> case x of 0 -> Nothing; _ -> Just x) [0..10]
10:21:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:21:54 <aavogt> > Data.Foldable.traverse (\x -> case x of 0 -> Nothing; _ -> Just x) (S.fromList [0..10])
10:21:55 <lambdabot>   Not in scope: `Data.Foldable.traverse'
10:21:59 <Alpounet> @type mapM
10:22:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:22:06 <aavogt> > Data.Traversable.traverse (\x -> case x of 0 -> Nothing; _ -> Just x) (S.fromList [0..10])
10:22:06 <lambdabot>   No instance for (Data.Traversable.Traversable Data.Set.Set)
10:22:06 <lambdabot>    arising from...
10:22:23 <aavogt> > Data.Traversable.traverse (\x -> case x of 0 -> Nothing; _ -> Just x) (M.fromList $ map (join (,)) [0..10])
10:22:24 <lambdabot>   Nothing
10:22:35 <Gracenotes> > mapM (\x -> case x of 0 -> Nothing; _ -> Just x) $ [1..5]++[0..4]
10:22:36 <lambdabot>   Nothing
10:22:46 <frwmanne1s> how would anyone represent " a (mod p) "?
10:23:01 <aavogt> > Data.Traversable.traverse (Just) (M.fromList $ map (join (,)) [0..10])
10:23:02 <lambdabot>   Just (fromList [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)...
10:23:08 <frwmanne1s> so you can add them and stuff
10:23:43 <Gracenotes> well, there is generally no modulus mode in programming languages; you just do the operations, then mod the result
10:23:54 <aavogt> HugoDaniel: but IntMap has its own mapMaybe if traverse is not the right thing
10:24:21 <Gracenotes> of course, there are more efficient algorithms for specific mod operations... those would have to be called manually.
10:24:31 <frwmanne1s> Gracenotes: sure, I was just trying to make it all nice
10:24:37 <Gracenotes> would be interesting, though, maybe having a Modulus monad...
10:25:22 <frwmanne1s> Gracenotes: along the lines of newtype Modulus a = Modulus { unModulus :: a -> a } deriving Monad ?
10:25:27 <HugoDaniel> my monad is not Maybe :/
10:26:14 <Gracenotes> frwmanne1s: hm, if you wanted to make it like the Reader monad, I suppose. I was (less creatively) thinking it would be like the identity monad except it provides special arithmetic operations that automatically mod numbers
10:26:58 <Gracenotes> not sure if that'd work.. I haven't made a monad in months :x
10:26:58 <frwmanne1s> Gracenotes: ok.  The problem is telling it modulo *what*.  That information can't be carried by the type
10:27:39 <frwmanne1s> Gracenotes: I just had distant dreams of giving it a Field instance ...
10:28:23 <Gracenotes> maybe just Applicative would be sufficient; context is not always needed for arithmetic operations
10:28:53 <aavogt> HugoDaniel: if it is to work with any monad, then I suppose that traverse does the only thing you are allowed to do
10:29:26 <Gracenotes> but, just using mod as necessary seems to work for me :)
10:29:58 <aavogt> @type fmap unwrapMonad . Data.Traversable.traverse (WrapMonad . ?f)
10:29:59 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a a1. (Monad m1, ?f::a1 -> m1 a, Data.Traversable.Traversable (WrappedMonad m)) => WrappedMonad m a1 -> WrappedMonad m1 (m a)
10:30:11 <frwmanne1s> Hmm.  Gaussian elimination should work on any Field.  The integers (mod p) are a field.  I just can't find a way to bring the two together.
10:30:36 <Gracenotes> that's what you're doing, then
10:30:42 <aavogt> hmm, that didn't work out correctly
10:30:57 <frwmanne1s> Gracenotes: should have mentioned earlier I guess :)
10:31:30 <aavogt> @type unwrapMonad . Data.Traversable.traverse (WrapMonad . ?f)
10:31:31 <lambdabot> forall (m :: * -> *) a a1 (t :: * -> *). (?f::a1 -> m a, Data.Traversable.Traversable t, Monad m) => t a1 -> m (t a)
10:32:04 <frwmanne1s> Gracenotes: so, I think NumericPrelude uses something isomorphic to Modulus above.  I did that, then ran into *massive* sharing problems.
10:32:56 <frwmanne1s> the problem being that a matrix doesn't know that all its elements have the same modulus for all time
10:33:25 <frwmanne1s> Of course, dependent types would fix it
10:34:12 <Gracenotes> would a simple Num newtype fix it?
10:34:25 <frwmanne1s> Gracenotes: how would that work?
10:34:27 <Saizan> it's not that hard to express the modulus at the type level, even in haskell
10:34:39 <HugoDaniel> aavogt: what about mapM ?
10:34:57 <frwmanne1s> Saizan: true, but I'd like to be able to decide on the modulus at runtime
10:35:18 <Gracenotes> not a creative idea, but maybe it'd work? making a Num instance over a newtype identity wrapper that preserves the range invariants for a number
10:35:25 <Saizan> frwmanne1s: you can do that too with higher-rank/existential types
10:35:33 <aavogt> HugoDaniel: mapM needs a list, and intmaps are not lists
10:35:47 <frwmanne1s> Saizan: how?
10:36:24 <Saizan> frwmanne1s: http://hackage.haskell.org/package/reflection
10:36:34 <Gracenotes> I think there's something in the numbers package. on the other hand, I think I don't quite understand the level of generality you require
10:37:01 <frwmanne1s> Gracenotes: "require" is overstating it a bit :)
10:37:04 <frwmanne1s> Saizan: thanks
10:38:10 <Saizan> frwmanne1s: see http://comonad.com/reader/2009/clearer-reflection/ for examples and the linked paper for details, the main example in the paper is modular arithmetic too
10:38:39 <dubhrosa> question: I was reading this blog http://cdsmith.wordpress.com/2009/09/20/side-computations-via-type-classes/ and I thought the swap function (swap :: Int->Int->[a]->[a], swap two elements of a list) was really verbose, anyone here got a more elegant way of doing this (I tried but ended up with two takes, two drops and two !!s ?
10:38:50 * frwmanne1s has some reading to do
10:38:53 <frwmanne1s> thanks all
10:39:41 <maurer_> Does anyone happen to know how to get the latest ghc to work with cabal-install? Attempting to build gets errors where it can't parse ghc-pkg dump
10:39:46 <Saizan> dubhrosa: i'd do something with splitAt
10:42:09 <dons> maurer_: you need the cabal-install built against the cabal that comes with ghc i think
10:42:12 <dons> dcoutts_: ^^ right?
10:42:51 <dcoutts> dons: right, however the HEAD Cabal lib and cabal-install are out of sync atm
10:43:10 <dubhrosa> Saizan: trying now...
10:43:38 <dcoutts> dons: really I should do release a point release of cabal-install which gives a better error message
10:43:55 <dcoutts> dons: btw, want me to release bytestring ?
10:44:10 <dcoutts> dons: anything more than checking the tests needed?
10:44:14 <dons> i want to run the testsuite and look at the patch, but then i can give you the goahead
10:44:20 <dcoutts> dons: thanks
10:44:21 <dons> i'll do that today.
10:44:25 <dcoutts> ta
10:44:38 <osfameron> dammit, cabal install --reinstall also recompiles everything :-(
10:44:39 <dons> did you see a new minor rev on QuickCheck 2?
10:44:54 <dcoutts> dons: I didn't, but good
10:44:57 <osfameron> I just wanted it to install pandoc (given that I'm guessing I previously forgot to do it with 'sudo')
10:45:03 <dons> dcoutts: but a different maintainer
10:45:04 <dcoutts> dons: Igloo was asking about the bytestring to use with 6.12.1
10:45:07 <dons> so i'm not sure what's going on.
10:45:07 <HugoDaniel> aavogt: im going to think about my problem, and see if i can ditch the traversal of the intmap, by going directly to the index i want...
10:45:09 <dcoutts> dons: oh?
10:45:11 <HugoDaniel> thanks for the help
10:45:11 * osfameron waits while ghc takes over his entire memory/cpu, as is its wont
10:45:14 * dcoutts checks hackage
10:45:30 <dons> note the new 'quickcheck team'
10:46:10 <HugoDaniel> dons, i really enjoyed the paper on the stream fusion, congrats
10:46:32 <Twey> osfameron: nice!
10:47:14 <deech> Hi all, are there resources on how to read Haskell code? I have made it through a good portion of RWH so I'm comfortable with the basic concepts.
10:48:22 <codejedi> dons: any suggestion please
10:48:35 <codejedi> dons: for the same
10:48:39 <osfameron> Twey: even better!  It made my CPU overheat and my laptop shut down
10:48:52 <osfameron> next time I will sit inside the fridge when I want to install a module
10:48:59 <osfameron> or maybe I'll just apt-get install an older pandoc...
10:50:21 <dons> codejedi: on how to read haskell?
10:50:23 <dons> hmm.
10:50:48 <dons> daily practice. install the source for ghc and the libraries, (and get more source via 'cabal unpack') and read it
10:51:42 <Berengal> What's the prefered way of writing this? maybe Nothing makeMaybe . decode <$> U.readFile filePath; join . fmap makeMaybe . decode <$> U.readFile filePath; something else?
10:52:09 <Berengal> decode :: (Monad m) => a -> m b
10:52:53 <deech> dons: Is there a systematic way? There is, for example, a book on code reading for C (http://search.barnesandnoble.com/Code-Reading/Diomidis-Spinellis/e/9780201799408).
10:53:12 <dons> i know of no such resource for haskell. ask the community on haskell-cafe@
10:53:30 <deech> will do, thanks!
10:53:48 <codejedi> dons: thanks, any visualizing tool, to show same code in different ways e.g. showing dynamically changing view of the pointfree function composition to pipelene style etc.
10:54:26 <dons> hare is a cool refactoring tool, though hard to use.
10:54:33 <dons> hlint is a good tool for recommending improvements to your code
10:55:25 <codejedi> dons: ok, but what if one is only interested in transforming the code in libraries just to get a better understanding
10:56:50 <codejedi> dons: e.g. rearranging funtions, showing data declarations near use, showing function definitions with and without necessary parameters etc.
10:57:42 <Saizan> codejedi: there aren't tools like that around yet
10:57:56 <Saizan> scion might be relevant though
10:57:58 <ksf> what's the most efficient and safe way to do a function call to a worker thread?
10:58:05 <codejedi> dons: code re-arrangement to make it better to understand while reading from top to bottom that too for a given use case or element etc
10:58:12 <codejedi> Saizan: thanks
10:58:20 <dons> hlint is great for that
10:58:28 <FunctorSal> ksf: put a message in a chan?
10:58:44 <dons> codejedi: http://community.haskell.org/~ndm/hlint/
10:58:49 <dons> HLint (formerly Dr. Haskell) reads Haskell programs and suggests changes that hopefully make them easier to read. HLint also makes it easy to disable unwanted suggestions, and to add your own custom suggestions.
10:58:52 <ksf> ...I want to get an answer back, too.
10:59:01 <codejedi> dons: thanks, means i need to get using hlint greatly
10:59:05 <deech> hlint is awesome! I learnt so much from it's suggestions. Althought I don't understand why it wants to eta-reduce everything.
10:59:32 <Saizan> hlint makes local improvements to code, it doesn't give you different views rearranging the code etc..
10:59:49 <ksf> ...and two chans won't work, of course, as all those different callers can't synchronize the write/reads.
11:00:08 <deech> Saizan: true, and you have to run it more than once.
11:00:18 <Saizan> ksf: send a (writeMVar mvar) closure together with the call?
11:00:22 <codejedi> dons: but i understand that it is an iterative process to improve code in standardized  and usefull ways
11:00:38 <codejedi> Saizan: deech : same to u too
11:00:39 <ksf> ...but the worker thread has to be single threaded. fon once because it does heavy single-threaded ffi work, and then because it needs to cache.
11:01:31 <codejedi> a dynamic tool doing such stuff could be a killer application of sorts
11:02:09 <Saizan> forever $ do (call,ret) <- readChan c; result <- perform call; ret result
11:02:42 <dons> hare will let you do whole program changes, but it is hard to use
11:02:53 <codejedi> dons: ok
11:03:52 <ksf> maybe I should stop trying to fit stuff into STM or CHP
11:05:55 <codejedi> dons: it would be interesting to check if it can attempt things like minimizing the case in a tree of if then else and case expressions, extracting function definitions and similar stuff
11:06:19 <Berengal> Isn't '@' a valid operator?
11:06:35 <sleepynate> anybody have an xmobar with XFT support packed for ubuntu?
11:06:52 <FunctorSal> Berengal: taken by @-patterns I think
11:07:00 <ksf> Berengal, it is.
11:07:02 <FunctorSal> @let (@)=1 in (@)
11:07:02 <lambdabot>   Parse error: At
11:07:07 <Berengal> FunctorSal, I guess you're right
11:07:21 <dons> codejedi: it might be a cool project for you to work on?
11:07:32 <ksf> > let @? = (+) in 2 @? 3
11:07:33 <lambdabot>   <no location info>: parse error on input `@?'
11:07:39 <ksf> > let (@?) = (+) in 2 @? 3
11:07:40 <lambdabot>   5
11:07:45 <ksf> > let (@) = (+) in 2 @? 3
11:07:46 <lambdabot>   <no location info>: parse error on input `@'
11:07:50 <ksf> > let (@) = (+) in 2 @ 3
11:07:51 <lambdabot>   <no location info>: parse error on input `@'
11:08:17 <FunctorSal> I see
11:08:35 <ksf> ixset uses @* functions for indexing.
11:08:39 <Berengal> I now need a new symbol for dictionary lookups
11:08:50 <FunctorSal> Berengal: (!)?
11:08:52 <ksf> @hoogle (@=)
11:08:52 <lambdabot> Test.HUnit.Base (
11:08:58 <FunctorSal> (as in Data.Map)
11:09:00 <ksf> hmmm.
11:09:06 <Berengal> FunctorSal, I use ! as the postfix operator for extracting a scalar
11:09:12 <Berengal> FunctorSal, navigating JSON objects
11:09:19 <FunctorSal> (!!!)? :)
11:09:36 <Berengal> & perhaps
11:09:42 <FunctorSal> inverted !? ;)
11:09:48 <Berengal> 
11:09:54 <Berengal> 
11:10:20 <Berengal> Looks a bit too much like an i...
11:10:29 <FunctorSal> yes
11:12:41 <osfameron> dammit... markdown2pdf doesn't work (dones't have the unicode package - I'd have thought the ubuntu .deb would have selected the right stuff)
11:12:45 <deech> Does Hare only work on GHC 6.8.2?
11:14:59 <sjw> does lambdabot no longer @seen?
11:15:10 <olsner> @seen sjw
11:15:10 <lambdabot> Unknown command, try @list
11:15:29 <sjw> see :)
11:15:59 <Gracenotes> preflex be up in the hood for seen, yo
11:16:00 <preflex>  no quotes found for up in the hood for seen, yo
11:16:12 <Gracenotes> yeah homes
11:16:13 <monadic_kid> why doesn't c2hs like using with function as in marshaller?
11:16:42 <ksf> ...because the parser is quite stupid.
11:17:00 <ksf> or, rather, doesnt' know how to parse anything more complex than an identifier
11:17:23 <ksf> ...if that's not your problem, then it could be that you're lacking a * or - at the end of the ident
11:17:24 <monadic_kid> it gives an error message about it so there might be a reason
11:18:06 <monadic_kid> *must be a reason
11:18:20 <monadic_kid> no i have *, i can make it worked by having a forwarding function with a more restricted type
11:18:49 <burp> is Integer really unbounded? does it only depend on the available memory I have?
11:19:04 <ksf> burp, yes.
11:19:17 <burp> some time ago I heard here that it was bounded by some _very_ large number
11:19:28 <ksf> ah yes, but that's because of gmp.
11:19:43 <dubhrosa> Saizan: here are the list element swap functions, I've written one using splitAt but it still doesn't feel as short as it should be, any suggestions? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9608#a9608
11:19:47 <ksf> I think it was size_t^size_t or something.
11:19:53 <ksf> ...you should run out of memory first.
11:20:04 <monadic_kid> how is greencard compared to c2hs/hsc2hs?
11:20:22 <ksf> ...unless you happen to have the whole google server farm as swap memory.
11:20:32 <burp> hehe
11:21:25 <ksf> there's a pure haskell implementation written for some other compiler but usable with ghc though, that one should be truly unbounded.
11:21:48 <ksf> ...up to adressable memory.
11:22:06 <burp> ok
11:22:29 <Berengal> Yay, JSON object navigator combinators
11:22:36 <Berengal> With a bit ugly syntax...
11:22:47 <Twey> Ooh, where?
11:23:02 <ksf> like, even with my 64 bit pointers, I can't mmap the whole of a file spanning the maximum extent of a zfs volume.
11:23:03 <Berengal> In my module
11:24:07 <Berengal> Twey, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9609#a9609
11:24:21 <ksf> I bet a lot of people will volunteer to fix the code if you run into problems and can give them ssh access to a machine that actually has enough memory...
11:24:51 <Twey> Nice :-D
11:25:37 <Berengal> Twey, postfix operators requires you to enclose the entire thing in parens though, and it only takes Maybe Objects
11:25:46 <Twey> Yeah
11:27:08 <Berengal> Also, lack of safe (!!) annoys me a bit. I haven't had to resort to primitive recursion for ages!
11:28:15 <copumpkin> Berengal: lookup?
11:28:27 <m0nkfish> hi guys how do i generate a random number in a given range
11:28:33 <copumpkin> :t lookup
11:28:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:28:39 <copumpkin> oh I guess not :)
11:28:45 <copumpkin> there's another function for it though
11:28:47 <Berengal> copumpkin, well, I could do that..., but I'd have to zip first
11:29:08 <Lemmih> Berengal: zip is cheap.
11:29:10 <Berengal> I could also drop and do listToMaybe
11:29:10 <copumpkin> guess not
11:29:20 <wdonnelly> m0nkfish: randomR, IIRC
11:29:27 <Berengal> @type randomR
11:29:28 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
11:30:03 <idnar> > let xs `at` n = listToMaybe . drop n in [0..10] `at` 5
11:30:04 <lambdabot>   {[]->Nothing;[()]->Nothing;[(),()]->Nothing;[(),(),()]->Nothing}
11:30:25 <idnar> > let xs `at` n = listToMaybe . drop n $ xs in [0..10] `at` 5
11:30:26 <lambdabot>   Just 5
11:30:26 <Berengal> Lemmih, indeed, but I'm concerned more about the brevity. I've written a semi-workable blog-engine with only about two ifs and one case, and no primitive recursions...
11:30:33 <idnar> what the heck was that first output?
11:30:37 <idnar> > let xs `at` n = listToMaybe . drop n $ xs in [0..10] `at` 15
11:30:38 <lambdabot>   Nothing
11:31:17 <Makoryu> :t listToMaybe
11:31:18 <lambdabot> forall a. [a] -> Maybe a
11:31:24 <Lemmih> Half a line is too bloated?
11:31:39 <idnar> > let (`at` n) = listToMaybe . drop n in [0..10] `at` 5
11:31:39 <lambdabot>   <no location info>: Parse error in pattern
11:31:42 <idnar> aww
11:32:01 <Berengal> I don't really care that much, it's just that I discovered that just now and felt like ranting a bit
11:33:05 <Berengal> I've been aware of not needing primitive recursion for a while, but the few ifs and cases are new to me
11:33:11 <Makoryu> > let at = flip (@@) where (@@) n = listToMaybe . drop n in [0..10] `at` 5
11:33:11 <lambdabot>   Just 5
11:33:41 <Makoryu> Of course, "= flip (@@) where (@@)" is a lot longer than "xs"
11:33:52 <Twey> > let at = (!!) in [0..10] `at` 5
11:33:53 <lambdabot>   5
11:33:54 <Twey> >.>
11:34:01 <Twey> Oh, I see, safety.
11:34:22 <Twey> Yes, that makes sense.
11:34:59 <Berengal> Twey, there's Nothing like Maybe to make partial code total. It Just works
11:35:07 * Berengal ducks
11:35:08 <idnar> haha
11:35:22 <Twey> *groooan*
11:35:23 <Twey> Hehehe
11:35:45 <codejedi> dons: sorry, had a phone call, thanks may be i will work surely when i take the current project i am working on to enough maturity
11:36:12 * Makoryu calmly hands Berengal a pair of sunglasses
11:39:01 <codejedi> dons: hope to get some great feature suggestions from the community
11:48:19 <sm> hey all
11:48:51 <sm> when generating multiple cabal packages from a single source tree, is there any reason I can't keep all .cabal files in the top-level directory ?
11:49:43 <wdonnelly> I think cabal complains when it sees multiple .cabal files in the same directory
11:49:50 <dcoutts> sm: the only reason is cabal doesn't support that yet
11:49:51 <ksf> > maxbound ::Char
11:49:52 <lambdabot>   Not in scope: `maxbound'
11:49:56 <ksf> > maxBound ::Char
11:49:57 <lambdabot>   '\1114111'
11:50:01 <sm> I see, thanks
11:50:12 <ksf> > 0x1114111
11:50:12 <lambdabot>   17907985
11:50:26 <ksf> > log 0x1114111
11:50:27 <lambdabot>   16.700757260728167
11:50:45 <ksf> > log 64
11:50:46 <lambdabot>   4.1588830833596715
11:50:50 <ksf> grrr
11:50:54 <ksf> log base two?
11:51:04 <wdonnelly> > log 64 / log 2
11:51:04 <lambdabot>   6.0
11:51:06 <copumpkin> > logBase 2 0x1114111
11:51:07 <lambdabot>   24.094099679142875
11:58:01 <jkr> Can someone point me to an example on how to use Data.Supply?
11:59:57 <pastah> how do i use cabal install and force a certain version?
12:00:10 <copumpkin> cabal install moo-0.2.3.4
12:00:11 <dcoutts> pastah: see the --help
12:00:59 <dcoutts> copumpkin: I like the fact that you used 0.2.3.4 and not 1.2.3.4, since obviously none of our software ever hits 1.0 ;-)
12:01:06 <kalven> if I have "data Foo = Bar String | Zonk", and a [Foo], is there a nice way of getting all the Bar's from that list?
12:01:08 <copumpkin> lol
12:01:17 <copumpkin> kalven: nope
12:01:23 <pastah> dcoutts: did that, that's why i asked :{
12:01:26 <pastah> :)
12:01:38 <copumpkin> kalven: if you use Maybe for that same type, there is
12:01:41 <dcoutts> pastah: did you use cabal install --help? it gives a bunch of examples.
12:01:55 <Saizan_> kalven: [ x | Bar x <- list ]
12:02:04 <copumpkin> oh!
12:02:08 <copumpkin> cute
12:02:09 <pastah> dcoutts: cool, didn't notice that, i was just looking for mentions of "version"
12:02:14 <kalven> Saizan_: cool, thanks
12:02:16 <deech> copumpkin: Amazing, that's the same combination as my luggage.
12:02:21 <lilac> i have a monad transformer 'newtype MyMonadT m a = ...' and a monad 'type MyMonad a = MyMonadT Identity a'. if i try to use my monad in a transformer stack: 'StateT Foo MyMonad a' i get an error (type synonym should have 1 argument but has been given 0). how do i fix this?
12:02:22 <pastah> copumpkin: thanks ;)
12:02:24 <copumpkin> deech: I'm psychic that way
12:03:05 <Saizan_> lilac: type MyMonad = MyMonadT Identity
12:03:07 <bwr> So, I notice there are several library choices for XML. Which should I learn?
12:03:23 <jkr> I'm looking for a way to generate unique ids. Does anyone know a nice way to do that?
12:03:28 <lilac> Saizan_: thanks, that works. what's going on there?
12:03:39 <bwr> jkr: UUID?
12:03:54 <lilac> oh, i see. :) the partially-applied type might not have the remaining parameters at the end
12:03:57 <Saizan_> lilac: type synonyms can't be partially applied, it's a restriction to keep unification decdable
12:04:10 <jkr> I think UUID needs input for hashing
12:04:13 <bwr> jkr: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uuid
12:04:16 <lilac> i didn't know you could have higher-kinded type synonyms ;-)
12:04:42 <bwr> jkr: Hmm. I've not used the haskell implementation
12:06:51 <jkr> bwr: Ah, UUID.V1 seems to work without input
12:06:52 <jkr> Thanks
12:07:18 <bwr> np
12:07:21 <deech> bwr : I've had good luck with HXT.
12:07:37 <bwr> deech: Thanks
12:08:18 <deech> bwr : It took a while to understand because it uses Arrows a lot. But once I did things became easy. Tagsoup is easy-to-use but less powerful.
12:09:34 <ksf> is there a bit trick to reverse the order of bits in an int?
12:10:49 <bwr> deech: I want to understand arrows anyway, so I will go with HXT
12:10:54 <burp> Data.Bits?
12:13:20 <lilac> ksf: i think there is, but i don't recall it :)
12:16:14 <ksf> rotateR 1 32 :: Int
12:16:25 <ksf> > rotateR 1 32 :: Word32
12:16:26 <lambdabot>   1
12:16:31 <ksf> > rotateR 1 31 :: Word32
12:16:32 <lambdabot>   2
12:16:40 <lilac> ksf: you can do something like: reverseBits x = let a = (x `rShift` 1) .&. 0x55555555 .|. (x `lShift` 1) .&. 0xaaaaaaaa; b = (a `rShift` 2) .&. 0x0f0f0f0f .|. (a `lShift` 2) .&. 0xf0f0f0f0 etc.
12:16:41 <ksf> > rotateR 1 1 :: Word32
12:16:42 <lambdabot>   2147483648
12:17:10 <lilac> ksf: that at least is logarithmic in the number of bits, i don' know if you can do better
12:17:13 <ksf> > (flip (showIntAtBase 2 intToDigit) ) "" $ (rotateR 1 1 :: Word32)
12:17:14 <lambdabot>   "10000000000000000000000000000000"
12:17:25 <Botje> ksf: http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel
12:17:27 <ksf> > (flip (showIntAtBase 2 intToDigit) ) "" $ (rotateR 0xd 1 :: Word32)
12:17:28 <lambdabot>   "10000000000000000000000000000110"
12:18:08 <lilac> Botje: yeah, that's the same algorithm :)
12:18:56 <Botje> oh :)
12:19:29 <sinelaw> PeakerWork, ??
12:20:00 <SamB> :t left
12:20:00 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
12:20:12 <SamB> :t right
12:20:13 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
12:23:48 <lilac> > flip showHex "" $ (\n -> foldl' (\v (m,s) -> (v `shiftR` s) .&. m .|. ((v .&. m) `shiftL` s)) n (zip [0x55555555,0x33333333,0x0f0f0f0f,0x00ff00ff,0x0000ffff::Word32] [1,2,4,8,16])) 12345678
12:23:49 <lambdabot>   "72863d00"
12:24:35 <FunctorSal> ooh this should be hackagified http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/
12:24:37 <lilac> ksf: ^^ there's a bit reverser for Word32
12:28:02 <ksf> yeah I was hoping there'd be something more O(1)
12:28:28 <ksf> ...involving nasty reverse-complement tricks or such.
12:28:46 <Vanadium> It is O(32)~
12:31:12 * ksf likes b = ((b * 0x80200802ULL) & 0x0884422110ULL) * 0x0101010101ULL >> 32;
12:31:42 <ksf> ...as I've got 128 bit registers, there should be a way to do that for 64 bits, too.
12:33:05 <mmorrow> ksf: bswap %rax
12:33:22 <SamB_XP> mmorrow: that's a *byte* reverser
12:33:35 <mmorrow> argh
12:33:47 <mmorrow> what are we trying to do?
12:33:55 <ksf> but then... actually that should be sufficient, or even better.
12:34:07 <mmorrow> $ echo 'bswap %rax' | asm2c3.sh
12:34:07 <mmorrow> [0x48,0x0f,0xc8]
12:34:09 <mmorrow> ;)
12:34:56 <mmorrow> (#!/bin/sh;;ASM=`mktemp`;OBJ=`mktemp`;cat > $ASM;as $ASM -o $OBJ;objcopy $OBJ -O binary;asC3 < $OBJ;rm -f $ASM $OBJ;exit 0;)
12:34:58 <ksf> the original idea was to improve IntMap performance by giving it more information faster: most of the keys have the same msbs
12:35:26 <ksf> ("the same msbs" is quite a common occurence when you've got 64 bit ints)
12:35:36 <mmorrow> ksf: oh. there's actually an x86_64 instr for the exact op that IntMap uses
12:35:47 <mmorrow> currently it compiles to about 20
12:35:56 <mmorrow> bsr or bsf
12:36:08 <mmorrow> i can never remember which is which
12:36:29 <mmorrow> err, there is no bsr
12:37:07 <dolio> You think that's air your breathing?
12:37:10 <mmorrow> oh no there is
12:37:17 <mmorrow> yeah, bsr and bsf
12:37:19 <copumpkin> I wonder how hard it would be to add specialized instructions like that to the code gen
12:37:41 <ksf> would it be an advantage?
12:37:55 <ksf> they get compiled down by the processor, anyway.
12:38:18 <mmorrow> ksf: 20 x(2/3-10) instruction for every insert/delete/lookup
12:38:20 <Botje> i doubt your processor is smart enough to replace 20 insns with one :)
12:38:41 <mmorrow> Botje: but teh humans are :)
12:38:50 <ksf> nah, but to replace one insn with 20
12:38:58 <Botje> .. not if GHC keeps evolving like that :P
12:39:12 <ksf> ...which'd be approx the same as a non-specialising codegen would generate.
12:39:14 * copumpkin adds a massive special case to the codegen
12:39:24 <copumpkin> :P
12:40:32 <aconbere> I have a buffer type I've been playing with. And as I'm learning to use quickcheck and constructing an arbitrary instance of that type. I'm realizing that some constraints of the type are not encoded in it's definition.
12:40:46 <aconbere> for instance the cursor can't be outside the bounds of the content of the buffer
12:40:59 <aconbere> it can never be negative... etc...etc.
12:41:10 <ksf> use a smart constructor?
12:41:20 <aconbere> ksf: okay... that was my question :)
12:41:58 <ksf> yep, I just finished polishing my chrystal ball. Thought I give it a try.
12:42:07 <copumpkin> or use a language like agda
12:42:14 <aconbere> I guess I was sure from a QuickCheck perspective if I should be trying to encode those constraints into the arbitrary instance, so that it could be used by other functions when checking.
12:42:35 <mmorrow> here's the C, the gcc asm, the haskell, and the ghc asm for highbit http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3861#a3861
12:43:00 <copumpkin> mmorrow: and that can be a single instruction?
12:43:28 <mmorrow> and here's the instruction (w/ ccall)
12:43:38 <mmorrow> bsr: movq $64, %rax; bsr %rdi, %rax; ret
12:43:44 <mmorrow> (it's either that or)
12:43:50 <mmorrow> bsr: movq $64, %rax; bsf %rdi, %rax; ret
12:44:00 <mmorrow>  /* i meant */ bsf: movq $64, %rax; bsf %rdi, %rax; ret
12:44:20 <copumpkin> that seems like it'd be pretty useful
12:44:29 <copumpkin> for heavy duty intmap users
12:44:50 <mmorrow> totally, i've (as i guess is apparent by my ability to conjure up all this) thought about this before for sure
12:45:04 <ksf> ...and a choice between trieing on msb or lsb first
12:45:19 <mmorrow> there's also a popcnt instruction
12:45:29 <mmorrow> which could be handy for random misc
12:45:45 <ksf> or even nesting two intmaps, the first one working on a hash of the int
12:46:24 <ksf> inline asm anyone?
12:46:54 <vyom> http://gist.github.com/189900 I do not understand the concept of MVar in this snippet of code (taken from hs-twitter package). How can two separate calls to twitter_user reference the same MVar..?
12:47:26 <copumpkin> vyom: by using a global variable
12:47:37 <copumpkin> vyom: it's not considered good practice though
12:47:54 <ksf> the unsafePerformIO is evaluated just once.
12:49:06 <aavogt> poll: which is worse for MVars: ImplicitParams or unsafePerformIO at top level?
12:49:41 <copumpkin> unsafePerformIO at top level
12:49:41 <ksf> I guess it's fine here, though, as that code seems to be intentended to be run in a ghci session.
12:49:43 <BMeph> preflex: seen poll
12:49:44 <preflex>  Sorry, I haven't seen poll
12:49:51 <copumpkin> @poll
12:49:51 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
12:49:53 <ksf> arguably, you could just read a config file.
12:50:02 <BMeph> aavogt: Sorry, I couldn't resist. :)
12:50:20 <ksf> ...and write to the file on setTwitterUser
12:50:35 <ksf> it's exactly as dirty, but doesn't use unsafePerformIO...
12:51:03 <wdonnelly> why should unsafePerformIO be avoided, then?
12:51:21 <wdonnelly> just because it has 'unsafe' in the name?
12:51:38 <aavogt> @quote PerformIO
12:51:38 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
12:51:43 <aavogt> @quote performIO
12:51:44 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
12:51:44 <lambdabot> a really bad one
12:51:53 <Twey> Hehe
12:51:57 <aavogt> hmm, it is not case sensitive
12:51:58 <wdonnelly> personally, I prefer using the toplevel unsafePerformIO hack to storing data in external files
12:52:31 <wdonnelly> (although I would much rather have an officially-sanctioned way to augment the world data that IO encapsulates, but that's just me wishing)
12:52:35 <Twey> wdonnelly: The problem (theoretical dirtiness aside) is that you don't know when it's going to be evaluated.
12:52:50 <Twey> And don't have any way of handling errors should they arise.
12:53:11 <aavogt> BMeph: =)
12:53:28 <BMeph> This stuff is why we need to have comonads "built-in". :)
12:54:15 <Twey> So something innocent like adding one to a variable can end up performing file IO behind the scenes, and without any method of handling whatever exceptions may arise that aren't already handled by the unsafePerformed IO value
12:54:32 <Twey> (since as far as Haskell is concerned the code is pure and no IO exceptions can arise)
13:01:34 <dolio> Comonads?
13:03:08 <copumpkin> Cococomonads
13:03:23 <Botje> i'l have a coco monad to go, please.
13:04:42 <Rotaerk> Botje, would you like that with cream?
13:07:26 <dons> shapr: someone else has written about how xmonad improves concentration and focus, http://jeremy.zawodny.com/blog/archives/011331.html
13:07:40 <dons> its been ages since i've thought about that, but it was a big issues in the early days. remember talking about it?
13:08:50 <blackdog> dons: xmonad is about the only thing i miss from linux, actually.
13:09:10 <blackdog> mac is lickable, but i spend ten minutes each time i reboot setting up my tiling windows juuuuust right.
13:10:34 <dons> mmm
13:13:31 <Makoryu> blackdog: Quick, someone should write a tiling window manager plugin for OS X! (You could probably get away with it using code injection on the Dock like some older virtual desktop implementations...)
13:15:44 <blackdog> heh
13:16:15 <blackdog> sizeup gets you some of the way there - at least you can maximise windows sanely
13:18:03 <dons> if only we had dyn libs on mac os x :)
13:19:46 <jmcarthur_work> heh, i try graphics-drawingcombinators, have to make a few changes to update it for the opengl package changes, then two days later, after a year and four months, luke palmer updates the original package unprompted by myself
13:20:03 <blackdog> dons: subtle!
13:20:04 <dons> heh
13:20:51 <copumpkin> blackdog: has your patch for that been integrated?
13:21:54 <blackdog> copumpkin: no. i'm just validating it now.
13:22:08 <blackdog> want to make sure i don't break linux as i go :)
13:23:53 <copumpkin> blackdog: :)
13:24:46 <blackdog> it's a real art learning how to change the ghc build process with minimal disruption.
13:26:58 <roconnor> All 657 people here are invited to my PhD defence on Oct. 5th in the Aula at Radboud University in Nijmegen, The Netherlands at 13:30 sharp!
13:27:04 <roconnor> including lambdabot
13:27:08 <copumpkin> :)
13:27:21 <copumpkin> is that your coq work?
13:27:29 <roconnor> there will be a reception afterwards
13:27:33 <roconnor> copumpkin: yep
13:27:44 <dons> roconnor: that seems like a lot !
13:28:01 <roconnor> dons: I'm screwed if everyone comes.
13:28:23 <astrolabe> Let's all go
13:28:52 <roconnor> there will also be a workshop on constructive analysis the next day
13:29:04 <roconnor> at least I think it is on constructive analysis.
13:29:27 <BMeph> roconnor: So, you're inviting us to your PhD-level Coq-fight? ;p
13:29:47 <roconnor> more or less
13:31:09 <BMeph> roconnor: Cool! I'll wear my FFF shirt - provided that I can find a way to afford transport from San Diego to Nijmegen in two weeks...
13:32:39 <monoidal> has anyone done something similiar? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3862
13:33:17 <roconnor> FFF?
13:33:19 <monoidal> this could enumerate all members of [()] etc
13:36:10 <roconnor> monoidal: your coproduct isn't a coproduct
13:36:13 <roconnor> call it sum instead
13:36:20 <roconnor> domains don't have a coproduct
13:36:35 <roconnor> your product also isn't a product
13:37:08 <roconnor> I forget what Scott called that
13:38:43 <monoidal> roconnor, why it isn't the product? should it be (bot, bot) = bot?
13:39:56 <monoidal> I'm trying to model values of Haskell's types, so this doesn't have to be precise
13:40:42 <roconnor> monoidal: yes, it should be (bot, bot) = bot for the product
13:40:50 <roconnor> that isn't how haskell types work
13:40:58 <roconnor> Haskell's product isn't a product
13:41:54 <Makoryu> instance Num [()] where -- Hmm, not actually as useful as one might think
13:46:27 <monoidal> it would be nice if that enumerated all 4 inhabitants of () -> () and went on to () -> ((), ()) etc. don't know how hard this could be
13:46:27 <RayNbow> http://nickelcode.com/2009/09/19/algebra-of-programming-chapter-1-section-3/ "As an example we can easily redefine the haskell infix cons operator to work with Snoc lists just as it would a Cons list" <-- this isn't possible, is it?
13:46:50 <RayNbow> since names starting with a colon are reserved for constructors, right?
13:48:09 <Makoryu> Raynes: Correct. Some people go for a long time without knowing this.
13:48:10 <eipi> when compiling on windows, are there cases where the macro mingw32_HOST_OS might not be set by GHC or may this happen only for other compilers?
13:48:43 <Raynes> Makoryu: Wrong Rayn bro.
13:48:48 <Makoryu> Oh dang
13:49:00 <RayNbow> too many ray-nicks :p
13:49:01 <Raynes> When I'm here you'll have to type Raynb :p.
13:49:05 <Makoryu> Raynes, RayNbow: Sorry 'bout that :p
13:49:24 <Raynes> :)
13:54:32 <eipi> it seems ghc considers all window versions as mingw32...is there a way to have a conditional compilation depending on the exact windows version?
14:03:32 <gjl> Can someone please suggest any Haskell projects with a a high openness and low barrier to entry for contributions?
14:03:49 <shepheb> gjl: xmonad?
14:04:15 <gjl> That's a good candidate. Any others, perhaps?
14:04:24 <ray> raynbow: i'd like to point out that while i have less than half of your nick, you have all of mine
14:04:30 <Heffalump> how do define low barrier to entry?
14:04:37 <ray> not ghc
14:04:47 <Heffalump> darcs has some areas that are easy to understand
14:04:51 <Heffalump> (and some that aren't :-)
14:04:59 <Heffalump> but we definitely welcome contributions
14:05:19 <Baughn> > [derive x y | y <- ys, x <- xs]
14:05:19 <lambdabot>   Not in scope: `ys'Not in scope: `xs'Not in scope: `derive'
14:05:28 <Baughn> > [f x y | y <- [1,2], x <- [3,4]]
14:05:29 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:05:29 <lambdabot>    `SimpleReflect.FromExpr ...
14:05:50 <Baughn> > [(x,y) | y <- [1,2], x <- [3,4]] -- And what's the point of f if we can't use it?
14:05:51 <lambdabot>   [(3,1),(4,1),(3,2),(4,2)]
14:06:13 <copumpkin> > [f x y | y <- [1,2], x <- [3,4]] :: [Expr]
14:06:14 <lambdabot>   [f 3 1,f 4 1,f 3 2,f 4 2]
14:06:56 <Baughn> copumpkin: I get that, but it's less convenient than it should be. What was the other possible typing, above?
14:07:32 * dons types 'lemonad' instead of 'lemond' while googling for bikes
14:07:37 <copumpkin> f :: FromExpr a => a
14:07:42 <copumpkin> :t f
14:07:43 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:08:01 <Baughn> @instances FromExpr
14:08:01 <lambdabot> Couldn't find class `FromExpr'. Try @instances-importing
14:08:10 <Baughn> @instances-importing SimpleReflect FromExpr
14:08:11 <lambdabot> Couldn't find class `FromExpr'. Try @instances-importing
14:08:12 <copumpkin> Baughn: you get that problem with any instance of such a class
14:08:14 <gjl> Heffalump: that has reminded me that I need to begin lurking the darcs mailing list.
14:08:26 <copumpkin> Baughn: same problem as read "1", really
14:08:44 <Baughn> copumpkin: Hm. I suppose.
14:09:03 <copumpkin> if the typeclass were closable, it could do it
14:09:28 <copumpkin> (not with read though)
14:09:28 <Baughn> By the time you're compiling, it's effectively closed already
14:09:46 <Baughn> Or.. no, I suppose there could be plugins
14:09:53 <copumpkin> you could be exporting something
14:10:22 <Baughn> Perhaps I should say, by the time it's being linked into an executable
14:14:07 <copumpkin> it could probably be smarter, but the way it works right now, the typechecker is too detached from the "target" to know that (and I sort of feel that's the right behavior)
14:18:16 <pastah> i'm having serious trouble with compiling OpenGL; in Graphics/Rendering/OpenGL/GL/Domain.hs i got loads of errors where it tries to match a CDouble against a GLDouble. This is for verios 2.3.0.0; the last to be tied to OpenGL 2
14:18:32 <pastah> (my gfx card isn't nearly cool enough for OpenGL 3.2)
14:19:16 <ray> baughn: linking can happen at runtime too
14:57:01 <brad_larsen> dons:  with the toy program I was having performance problems with, a big contributor is slow random number generation.  I need to play around with things more.
14:59:52 <blackdog> brad_larsen: bos just wrote a new RNG - tried that?
15:00:19 <brad_larsen> blackdog: i don't think so.  I was using monad-random from hackage
15:00:27 <brad_larsen> wrapping the standard rng
15:00:33 <ksf> and then there's sfmt, paced up as mersenne-random
15:01:03 <ksf> which is the fastest and best-quality (though non-crypto) prng you're going to get.
15:01:52 <blackdog> http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/
15:01:56 <blackdog> might be usefule.
15:02:38 <Axman6> yeah i was just about to suggest that. it's something like 3 times faster than the mersenne random one
15:02:41 <brad_larsen> i don't need super high quality numbers
15:02:45 * brad_larsen takes a look
15:03:01 <ksf> sfmt is faster than that.
15:03:13 <ksf> he must be using the double-by-double interface, not the array one.
15:05:37 <brad_larsen> wow, the System.Random generator is slow!
15:08:45 <roconnor> System.Random has some pretty tough constraints to meet: being splitable
15:22:44 <monoidal> is there a simple way to enumerate all (computable) functions Natural -> Natural?
15:23:14 <monoidal> or must I write a universal Turing machine?
15:24:54 <osfameron> meh... pandoc->latex can't do footnotes in headings
15:26:52 <ksf> "By all means break the rules, and break them beautifully, deliberately and well. That is one oth the ends for which they exist"
15:26:57 <ksf> heck I couldn't have said it better.
15:27:27 <ksf> found in "The Elements of Typographic Style"
15:28:38 <Peaker> Do TypeSynonymInstances mean the type String no longer really equals [Char]?
15:29:45 <ksf> I never tried, but I guess you'd be doing an instance for [Char]
15:30:00 <jmcarthur_work> ksf, TEOTS is good reading, and i have no idea how to describe why
15:30:24 <ksf> for once, it's written in brilliant english.
15:30:29 <ksf> for one.
15:30:34 <ksf> mine isn't as brilliant, at all.
15:30:44 <osfameron> aha, that's a pandoc bug.  It should apparently generate a "\protect" before the "\footnote"
15:30:46 <BMeph> monoidal: Real. :)
15:30:52 <ksf> anyway, I can distinguish tolkien and american high school.
15:31:01 <jmcarthur_work> the book just feels like an art piece
15:34:18 <benmachine> @hoogle liftA
15:34:19 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
15:34:19 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:34:19 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
15:42:21 <lilac> Peaker: no, type synonyms (wherever they're legal) may as well be macro replacements
15:43:29 <benmachine> so TypeSynonymInstances means you're allowed to write instance String Foo where, but it's not actually any different from instance [Char] Foo where
15:43:32 <benmachine> is that right?
15:44:06 <jmcarthur_work> not any different afaik
15:45:58 <SamB> benmachine: of course it's not any different
15:46:02 <SamB> how could it be ?
15:46:09 <SamB> :t "Foo"
15:46:09 <lambdabot> [Char]
15:46:36 <benmachine> "yes" would have done :P
15:57:45 <solrize> @seen dons
15:57:45 <lambdabot> Unknown command, try @list
15:57:55 <solrize> @list
15:57:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:58:03 <ivanm> preflex_: seen dons
15:58:03 <preflex_>  dons was last seen on #ghc 14 minutes and 6 seconds ago, saying: which aren't that common, but are used, notably, for the regular hash table impl. design
15:59:10 <solrize> i just saw dons' post about RWH being in some bookstore in oregon, so wanted to mention it's been available at borders near me (san francisco) basically since a few weeks after it first came out
15:59:48 <HugoDaniel> hi
16:00:27 <roconnor> I wish imports were allowed anywhere in a module.
16:00:48 <solrize> i wish you could have more than one module in a .hs file
16:01:04 <SamB> solrize: that tends to confuse tools ;-P
16:01:13 <roconnor> solrize: you can.  the problem is with GHC, not haskell.
16:01:15 <SamB> and people looking for the source
16:01:30 <SamB> roconnor: what Haskell compiler actually implements it that way ?
16:01:46 <HugoDaniel> can someone comment out on this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9614#a9614 ?
16:02:17 <HugoDaniel> data.typeable does not have a function that could do that automatically ?
16:03:29 <roconnor> oh crap, You don't have to begin a haskell file with module. If it is omitted it is assumed to be `module Main(main) where'
16:05:22 * ivanm notices that hash tables are once again the main reason why Haskell is bad
16:05:31 <ivanm> why are people so obsessed with hash tables? :s
16:05:37 <dolio> If you're just loading it in ghci, it might just assume "module Main where".
16:06:05 <SamB> ivanm: no idea
16:06:47 <dolio> ivanm: It's probably because all those popular P languages out there refer to their maps as "hashtables" so people can't conceive of them being anything else.
16:06:56 <ivanm> dolio: true
16:07:05 <dolio> Also hashtables are definitely way faster!
16:07:20 <ivanm> and the O(1)* (footnote: *averaged) sounds so great :s
16:08:31 <roconnor> ivanm: do hash tables grow the hash as entries are added?
16:08:48 <ivanm> roconnor: IIRC, usually not
16:08:55 <ivanm> you get collisions, etc.
16:09:04 <dolio> Depending on the style, you pretty much have to at some point.
16:09:05 <roconnor> ivanm: :O  So the O(1) is a lie, even for averages?
16:09:08 * ivanm hasn't used hash tables since his data structures course 3 or 4 years ago
16:09:37 <ivanm> IIRC, the O(1) refers to the fact that it's an array lookup
16:09:41 <ivanm> since that's what most hash tables use
16:10:30 <roconnor> ivanm: but it should be on average O(n/hash size) ~ O(n)
16:10:39 <roconnor> unless I misunderstand
16:10:40 <dolio> If your hash tables use chaining then with lots of elements you get O(n/m) lookup, where m is the number of chains.
16:10:46 <Cale> O(1) is a lie when you work in the complexity of computing the hash, which is at least O(log n)
16:11:11 <Cale> (since any function whose range has n elements takes at least O(log n) time to compute, it's non-negotiable)
16:11:13 <ivanm> Cale: isn't just about every aspect of hash-tables a lie? :p
16:11:35 <ivanm> I keep losing/forgetting the link to that article online about why red-black trees > hash tables
16:11:39 <dolio> If you store single elements in the buckets (which is how I learned them in a data structures course), you start getting really poor behavior when too many buckets are filled (because you're searcing an ever-more-filled space for empty buckets).
16:11:47 <ivanm> (because they are _guaranteed_ O(log n) )
16:11:47 <roconnor> Cale: with a fixed sized hash, lookup of the bucket is O(1)
16:12:03 <dolio> So you have to resize to keep things reasonable.
16:12:04 <Cale> roconnor: With a fixed size hash, lookup is O(n).
16:12:20 <roconnor> Cale: which is why I asked if hash tables grow the size of the hash.
16:12:37 <roconnor> ivanm said usually not
16:12:46 * roconnor grabs his data structures book
16:13:02 <Cale> roconnor: Yeah, you either have to resize periodically, or asymptotically, things are very bad.
16:13:22 <roconnor> even thought this talk of complexity is mostly academic
16:14:40 <dolio> With single-element-per-bucket you get something exponential in the load factor, as I recall.
16:15:32 <Cale> But usually hashtables assume that you'll never have more than a fixed number of elements n. Access times are at least logarithmic in that n.
16:15:36 <dolio> Or is it 1/(1 - load factor)? I guess that'd make more sense.
16:16:15 <dolio> Since there's obviously a discontinuity when all the buckets are filled, and you'll never find an open one.
16:16:51 <Cale> But this is all ignoring the bigger problem with hashtables.
16:16:55 <roconnor> Cale: that's seems like a dishonest assumption.
16:17:04 <roconnor> that makes all operations O(1)
16:17:26 <Cale> Which is that in order to insert or delete a single element, you either have to destroy the original hashtable, or copy the whole thing.
16:17:47 <idnar> dolio: Python calls them "dictionaries"
16:18:06 <dolio> Ah. Just two of the P languages, then.
16:18:06 <Cale> roconnor: It makes everything O(1) unless you measure things in terms of that n.
16:18:20 <idnar> the actual type is "dict"
16:18:45 <Cale> roconnor: and if you measure them in terms of that maximum size, then you see that computing the hash is going to be O(log n)
16:19:41 <Cale> and even if you make the somewhat unreasonable but common assumption that you can access any element of an array in O(1) time no matter how large it gets, that log term is still there.
16:20:01 <idnar> I think people are just used to "hashtable == FAST!!"
16:20:08 <lpsmith> In practice,  hashtables perform very well.
16:20:16 <tommd> Are there any c2hs experts here?
16:20:24 <benmachine> you can do worse than a hash table
16:20:32 <Cale> lpsmith: As long as you don't mind destroying your original hashtable on any operation.
16:20:54 <Cale> (well, any write operation)
16:20:56 <lpsmith> cale:  true enough;  but sometimes that's acceptable :-)
16:20:57 <dolio> Cale: Deleting elements is what null is for. :)
16:21:05 <roconnor> hashtables makes undo cry
16:21:11 <lpsmith> haha
16:21:14 <tommd> I'm trying to figure out how to use get and set hooks for something like "struct point { int x; int y; };"  in c2hs.
16:21:27 <Cale> For backtracking searches, hashtables are a pain.
16:21:36 <Cale> Mutable structures in general are.
16:21:37 <tommd> If anyone knows how to do that (notice there is no "typedef struct point point_t") then I'm all ears.
16:21:41 <lpsmith> cale:  you can also amortize the cost of rehashing a bit;  one of my friends did some research into lazy rehashing in Scheme
16:22:14 <roconnor> Haskell's maps are way better than maps in strict languages when it comes to backtracking.
16:22:22 <tommd> From what I can tell c2hs needs the typedef as "struct foo" will cause a parse error - it expects a one word token.
16:22:46 <Cale> lpsmith: yeah, for sure. You can do Fibonacci growing or something, and I think it still amortizes out to constant time.
16:22:56 <Cale> lpsmith: (that part of it does)
16:23:09 <Cale> But as the hashtable grows, computing the hash must become more expensive.
16:25:53 <Cale> The one place where hashtables do win in practical terms is that well-designed ones will get to store the data in a contiguous block of memory, which improves caching performance.
16:26:15 <Cale> It's much harder to arrange for that with trees.
16:27:43 <dolio> That's only going to happen with open addressing, no?
16:27:55 <dolio> We could do those sorts of hashtables with uvector.
16:28:45 <Makoryu> I could see a region-based allocation scheme enabling better cache friendliness for trees.
16:29:07 <lpsmith> roconnor:  what do you mean, exactly?   That sounds like a rather interesting statement...
16:29:20 <dons> my plan: IO-based binding to fast, small hashtable in C. called io-hash or something, released on hackage.
16:29:27 <dons> pure open-addressed ST-based hashing via uvector
16:29:28 <dons> done.
16:30:25 <dons> this isn't a real problem until someone with a haskell app says Data.IntMap/memcached/Ix-set/hsjudy/... is too slow for their use case.
16:30:45 <dons> its far more a branding issue: having a crappy 'HashTable' module in base is just wrong.
16:30:47 <roconnor> lpsmith: when you add an element to a map in Haskell, all the elements in the tree are shared expect the path from the root to the inserted node.
16:30:48 <dolio> Those are all too slow for Jon Harrop's benchmarks!
16:31:12 <dons> he's irrelevant. his benchmark is insert 10M elements.
16:31:36 <Makoryu> dolio: Someone should try and convince him to debate the issue over on /prog/... I'm sure he'd have a blast
16:31:38 <lpsmith> roconnor:   right,  but what does that have to do with laziness or backtracking?  :-)
16:31:39 <dons> so the uvector soln should be fine. i expect it to be very fine.
16:31:44 <dolio> Not only that, I think his benchmark is inserting 10 million Ints.
16:31:50 <dons> si.
16:31:58 <dons> so, enough talk. more action.
16:31:59 <roconnor> lpsmith: in a strict language the entire tree needs to be copied.
16:32:39 <lpsmith> No,  ML only copies the path that changes as well, not the entire tree...
16:32:45 <dolio> roconnor: You mean, mutable trees?
16:32:47 <roconnor> it does?
16:32:53 <roconnor> oh right
16:32:57 <lpsmith> immutable is what matters here, not laziness :-)
16:33:01 <SamB> yeah
16:33:02 <roconnor> lpsmith: thanks for schooling me.
16:33:07 <dons> for immutable hashes we have the perfecthash lib
16:33:21 <SamB> dons: not *that* kind of immutable
16:33:26 <centrinia> copumpkin, Why are they using a fMRI to scan dead fish at your school?
16:33:27 <dons> hmm. a survey of association-based structures would be useful
16:33:31 <lpsmith> heh,  I was hoping for something interesting,  not to show you wrong.
16:33:32 <dons> burn off this fog of confusion
16:33:38 <copumpkin> centrinia: I wasn't aware that they were :)
16:33:44 <copumpkin> centrinia: where did you see that?
16:33:48 <centrinia> http://www.wired.com/wiredscience/2009/09/fmrisalmon/
16:34:16 <SamB> centrinia: the fish did not live long enough to be scanned while still alive ?
16:34:25 <copumpkin> lol
16:34:39 <copumpkin> sounds like pretty exciting research
16:34:46 <centrinia> It seems that they just brought the dead fish (possibly at a fish market) and scanned it. :p
16:34:54 <centrinia> *bought
16:35:35 <SamB> I guess they just had an fMRI machine and they couldn't think of anything better to do with it?
16:35:54 <centrinia> Yeah, that's what I thought. :)
16:37:00 <Makoryu> "I've got an fMRI machine that I need to test. What do I do?" "No idea. Meanwhile, I've got this dead fish. What do I do with that?" "THEY FIGHT CRIME!"
16:37:17 <copumpkin> they use the machine a lot for other stuff too
16:37:36 <copumpkin> there are posters everywhere all the time saying "wanna make quick money? let us scan your brain"
16:37:48 <copumpkin> unfortunately I'm not allowed to do that cause I'm not right-handed and I don't only know one language
16:37:59 <SamB> what the ?
16:38:01 <copumpkin> and I guess they want to simplify their experiments
16:38:16 <lpsmith> copumpkin:  but you know C++, Ruby and Haskell!
16:38:19 <copumpkin> lol
16:38:26 <centrinia> Sinister bilingual students are not allowed. :)
16:38:32 <copumpkin> yeah :)
16:38:34 <SamB> lpsmith: he said "don't"
16:38:44 <lpsmith> oh
16:39:06 <lpsmith> I wish I knew a natural language other than English.  SIgh
16:40:34 <benmachine> hey so I wrote with a lot of words what could be described in not very many http://benmachine.co.uk/machine/class
16:40:42 <benmachine> I feel like I'm too new to be writing these sorts of things
16:40:48 <benmachine> but I did anyway
16:40:58 <benmachine> if anyone has any comments I want to hear them
16:41:37 <benmachine> comments about anything
16:41:42 <benmachine> up to and including the weather today
16:42:03 <dolio> benmachine: I'm pretty sure I've seen this suggested before.
16:42:12 <benmachine> it might have been by me!
16:42:19 <benmachine> or
16:42:20 <benmachine> yeah
16:42:22 <benmachine> okay
16:42:44 <benmachine> can I dig up a mailing list archive somewhere?
16:42:46 <dolio> Like, Haskell' officially suggested, even.
16:42:55 <benmachine> oh
16:43:04 <benmachine> so I don't have to do anything, then? :P
16:43:35 <benmachine> as far as I can see it does basically everything class aliases do only much simpler and easier...er.
16:43:58 <dolio> benmachine: http://www.haskell.org/haskellwiki/Superclass_defaults
16:44:04 <benmachine> aha
16:44:06 <benmachine> thx
16:44:12 <benmachine> (it was fun writing anyway)
16:44:20 <FunctorSal> arrr dolio was faster
16:44:34 <benmachine> isn't a single name for multiple classes already possible?
16:44:51 <dolio> benmachine: You might want to re-suggest it anyway, since I doubt anyone's actually doing anything about it.
16:44:54 <benmachine> heh
16:44:58 <FunctorSal> (and I'd like to see it too :))
16:45:06 <benmachine> okay
16:45:17 <benmachine> I will make it my mission to make people pay attention to that wiki page
16:45:23 <FunctorSal> =)
16:45:37 <benmachine> thanks for the link :)
16:45:48 <benmachine> (is my website design minimalist or just plain boring?)
16:46:11 <FunctorSal> so will you end every speech with "furthermore, I'm of the opinion that superclass defaults ought to be implemented"?
16:46:41 <benmachine> pretty much.
16:46:55 <FunctorSal> benmachine: I liked the design before you asked this
16:47:25 <benmachine> and after. ?
16:47:27 <benmachine> er
16:47:28 <FunctorSal> (I like minimalism, and also the colors in the header)
16:47:32 <benmachine> fix my punctuation
16:47:38 <benmachine> oh, thanks :)
16:47:42 <FunctorSal> (I prefer higher contrast for the main text but dunno how it would look)
16:47:50 <FunctorSal> hmm nothing else after
16:48:14 <benmachine> contrast's intentionally low, but I guess monitors vary
16:48:21 <benmachine> so I should possibly be more generous
16:48:25 <FunctorSal> or I could just crank up my display...
16:48:50 <benmachine> heh
16:49:27 <benmachine> well anyway, thank you both for your comments
16:49:31 <benmachine> big hugs
16:49:38 <benmachine> (and ghci)
16:49:38 <FunctorSal> :)
16:49:40 * benmachine goes to bed
16:49:48 <FunctorSal> good night
17:30:06 <roconnor> preflex: seen dbushong
17:30:17 <roconnor> preflex_: seen dbushong
17:30:17 <preflex_>  Sorry, I haven't seen dbushong
17:30:53 <ivanm> preflex_: seen preflex
17:30:54 <preflex_>  Sorry, I haven't seen preflex
17:30:57 <ivanm> hmmm...
17:31:30 <SamB_XP_> preflex_: seen preflex_
17:31:31 <preflex_>  what
17:31:36 <SamB_XP_> preflex_: seen preflex_
17:31:37 <preflex_>  what
17:32:59 <ivanm> heh
17:33:36 <roconnor> preflex_: seen stupidbotsayswhat
17:33:36 <preflex_>  Sorry, I haven't seen stupidbotsayswhat
17:46:40 <daofma> Hello #haskell. I was wondering if anybody could shed some light on this blog post I found. http://blogs.msdn.com/matt/archive/2008/05/11/breadth-first-tree-traversal-in-haskell.aspx refers to a standard library implementation of breadth first search on trees, and posts the code. However, I'm unable to locate where this function is (through Hoogle or Hayoo or ghci). Has anybody heard of it?
17:47:24 <ivanm> daofma: Data.Tree maybe?
17:47:42 <ivanm> "Standard Libraray" -- lol
17:48:40 <ivanm> daofma: looks like an edited version of Data.Tree.levels
17:48:43 <daofma> ivanm: I looked in Data.Tree
17:49:07 <ivanm> he added the concat after "map rootLabel"
17:49:11 <ivanm> (don't know why...)
17:49:17 <ivanm> daofma: read the paragraph above :p
17:49:20 <ivanm> he even says that
17:49:35 <daofma> aha, I misinterpreted what was written!
17:50:03 <daofma> or just missed that sentence. Comment in-code threw me off
17:50:10 <daofma> thanks!
17:50:29 * Cale bets that it's in fgl due to the stupidly short name.
17:51:04 <ivanm> Cale: nope
17:51:19 <ivanm> the guy says he edited the levels function from Data.Tree
17:51:19 <Cale> yeah, not there
17:51:26 <ivanm> Cale: also, FGL doesn't have a Tree datatype
17:51:27 <FunctorSal> what is so funny about the "Standard Library"? ;)
17:51:32 <ivanm> FunctorSal: the spelling
17:51:38 <ivanm> "Libraray"
17:51:44 <FunctorSal> ah
17:52:07 <Cale> It's the Forrest Gump version
17:52:13 <FunctorSal> thought you were criticizing the stdlib, and I thought "it isn't THAT bad!" ;)
17:52:41 <Cale> It's also apparently not in containers.
17:52:42 <FunctorSal> (so bad that one would "lol" at the mere idea of calling it a standard library)
17:52:46 <ivanm> Cale: *sigh*
17:52:52 <ivanm> he took Data.Tree.levels and edited it
17:52:56 <ivanm> it _is_ in containers!
17:53:30 <Cale> ah
17:53:46 <ivanm> read the paragraph before the code :p
17:54:01 <ivanm> (though I found it in Data.Tree before I read that paragraph...)
17:54:02 <Cale> ah, right :)
17:54:12 * Cale notes the abuse of $
17:54:32 <ivanm> yup
17:55:17 <Cale> br = map rootLabel . concat . takeWhile (not . null) . iterate (concatMap subForest) . (:[])
17:56:36 <ivanm> Cale: eh, I prefer return to :[]
17:56:49 <BMeph> Heh-heh, "In Russia, Robot Monkey uses YOU!" ;p
17:57:04 <chessguy> @quote russia
17:57:04 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
17:57:12 <Cale> module Prelude where ... robotMonkey = (:[])
17:57:13 <ivanm> heh
17:57:28 <daofma> Is there a better way to do a shortest path search on a graph? So far I was using Data.Graph, which only has a dfs, while shortest path needs a bfs, and so the best I've come up with so far is running that dfs to get a tree and using bfs. Alternatively I was looking at FGL, but it seems a bit more complex than I need.
17:58:12 <roconnor> @google dijstra shortest path
17:58:13 <lambdabot> http://en.wikipedia.org/wiki/Dijkstra's_algorithm
17:58:14 <lambdabot> Title: Dijkstra's algorithm - Wikipedia, the free encyclopedia
17:58:15 <Cale> daofma: I wrote an A* search which you can find on Hackage.
17:58:40 <Cale> (which is somewhat related, if not exactly what you're looking for)
17:58:43 <SamB_XP_> daofma: generally I find Data.Graph to be unhelpful and weird...
17:58:50 <daofma> roconnor: Djikstra's has proven unwieldy, and I was looking for something in a library
17:59:07 <daofma> cale: what's the package called?
17:59:10 <ivanm> oh, was about to say that FGL has djikstra...
17:59:13 <Cale> astar, iirc.
17:59:28 <SamB_XP_> why not just use FGL anyway ?
17:59:48 <Cale> Data.Graph and FGL both use awful graph representations.
17:59:57 <roconnor> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/Data-Graph-Inductive-Query-SP.html
18:00:08 <ivanm> Cale: FGLs isn't bad
18:00:08 <Cale> Though, FGL is at least flexible enough that you can define new instances.
18:00:24 <Cale> I hate all the function names in FGL though.
18:00:28 <ivanm> but it needs to be updated to stop over-using tuples, etc.
18:00:32 <ivanm> Cale: yeah, they suck
18:00:34 <roconnor> Cale: why awful?
18:00:44 <ivanm> roconnor: many of them are too short, or too vague
18:00:47 <ivanm> or too general
18:01:02 <Cale> roconnor: I just prefer using a Data.Map of adjacency information.
18:01:19 <roconnor> ivanm: how can a representation be too short or too vague?
18:01:36 <Cale> roconnor: He's talking about the function names in fgl
18:01:38 <ivanm> also, too many of them return lists of nodes rather than graphs (e.g. the connected components function)
18:01:45 <ivanm> roconnor: what Cale said ;-)
18:01:58 <FunctorSal> what is dfs about the dfs function in Data.Graph? doesn't it depend on how you eval the returned Forest?
18:02:03 <Cale> roconnor: Like, quick, what's the difference between bfe and lbft ?
18:02:12 <roconnor> okay, but I want to know why the representations are bad.
18:02:19 <roconnor> which was Cale's claim
18:02:22 <ivanm> roconnor: the actual data structures, etc.?
18:02:26 <FunctorSal> oh nvm I suppose the forest isn't guaranteed to have shortest path
18:02:29 <AAOsok> Anyone here use Haskell-Net?
18:02:33 <FunctorSal> (since the graph is pruned)
18:02:36 <ivanm> roconnor: you can't define an Eq instance of an FGL graph without overlapping instances
18:02:36 <Cale> roconnor: The Array representation has horrible modification performance
18:02:37 <AAOsok> It provides SMTP/POP3/IMAP/etc...
18:02:43 <ivanm> since they use tuples for everything
18:03:01 <ivanm> Cale: what array representation in FGL?
18:03:14 <roconnor> <Cale> Data.Graph and FGL both use awful graph representations.
18:03:14 <Cale> roconnor: and fgl uses a funny structure such that the same graph decomposes in many different ways
18:03:17 <Cale> ivanm: In Data.Graph
18:03:20 <ivanm> ahhh
18:03:39 <ivanm> Cale: I don't mind the whole decomposition stuff in FGL
18:03:54 <roconnor> Cale: isn't it a fundamental property of a graph that how it decomposes is arbitrary
18:03:56 <SamB_XP_> Cale: that's not a big deal as long as you don't do that ...
18:04:01 <ivanm> it's just that in a lot of cases, to be able to do any effective maps or anything you have to split out a context, perform your function then put it in
18:04:02 <Cale> In fgl, a graph is effectively a list of "contexts", where a context is a node together with *some* of its inarcs and outarcs.
18:04:03 <ivanm> *back in
18:04:34 <ivanm> Cale: it makes sense if you consider each context like a patch on the graph it's applied to
18:04:37 <Cale> So in order to tell if there's an arc from x to y, you have to look at 4 sets of arcs.
18:04:41 <roconnor> Cale: aren't you are the one in love with the axiom of choice :P
18:04:46 <ivanm> but it means that things like a map over the contexts doesn't work too well
18:05:32 <daofma> The FGL docs say they're from 2001 and are outdated. Do more up to date docs exist?
18:05:33 <SamB_XP_> Cale: but it has a much nicer API than Data.Graph, other than the absurd function names ...
18:05:38 <Cale> also, those sets are stored as lists
18:05:52 <ivanm> daofma: ummmm.... how are they outdated?
18:05:57 <ivanm> the docs still relate to the code...
18:06:15 <FunctorSal> Cale: if the modification performance is the only downside to Data.Graph's representation, couldn't one just change it to use STArray?
18:06:18 <Cale> daofma: You can look at the haddock documentation which is pretty much guaranteed to be up to date.
18:06:30 <Cale> FunctorSal: STArray would be horribly ugly.
18:06:38 <daofma> ivanm: "it has not been updated to reflect the extensions and changes of the current version.  "
18:06:39 <ivanm> FunctorSal: not just that
18:06:40 <roconnor> Cale: I've never used these libs, I assumed that to tell if there is an arc from x to y, you split the graph at x, and look at all the edges and see if any of them lead to y.
18:06:48 <ivanm> daofma: you're referring to the paper?
18:06:49 <Cale> FunctorSal: I would prefer something along the lines of Map Vertex (Set Vertex)
18:06:51 <ivanm> if so, ignore it
18:06:54 <ivanm> just use the haddock docs
18:06:54 <SamB_XP_> FunctorSal: it isn't!
18:06:59 <daofma> I was looking for more of a general idea, as opposed to what each individual function does
18:07:01 <FunctorSal> hmm
18:07:03 <AAOsok> SamB_XP_: say my name.
18:07:07 <SamB_XP_> the API also sucks because of the representation ;-P
18:07:27 <ivanm> daofma: in that case, the papers are still OK for that
18:07:31 <FunctorSal> is ST really that ugly? I thought ST had clean semantics
18:07:32 <SamB_XP_> AAOsok: but ... I don't even remember what haskell-net is!
18:07:36 <daofma> alrighty
18:07:43 <FunctorSal> (in spite of using IO under the hood)
18:08:08 <Cale> roconnor: Yeah, there's an API which makes it easy to do, it's just that the representation ensures that it will take as long as possible :P
18:08:29 <FunctorSal> (it's just a strict State monad implemented efficiently, no?)
18:08:31 <roconnor> oh okay. :(
18:08:39 <Cale> FunctorSal: ST is still imperative style. There's no need for anything but immutable structures here.
18:09:08 <burp> hm, doesn't hstringtemplate support conditionals?
18:09:39 <Cale> FunctorSal: They just need to be better-selected immutable structures -- ones which like Data.Map can be updated in O(log n) space and time.
18:10:45 <FunctorSal> maybe... I'm not knowledgable about the specifics of graph algorithm performance
18:10:58 <FunctorSal> the array seems to be much more packed
18:11:11 <FunctorSal> (less GC?)
18:11:18 <FunctorSal> but I'm just speculating :)
18:12:29 <Cale> FunctorSal: Sure, but to change anything there are two possibilities: destroy the original graph (mutation), or copy the whole graph
18:12:57 <ehamberg> if i have a function that returns and IO Int, how can I call that function 100 times and store the 100 ints in a list?
18:13:07 <ehamberg> (from main)
18:13:11 <Cale> ehamberg: replicateM 100 foo
18:14:05 <ehamberg> excellent. thanks. :)
18:14:17 <jmillikin> Is there any way to let unit tests access internal implementation functions, without exposing them to the world?
18:14:47 <roconnor> @hoogle Int -> IO Int -> IO [Int]
18:14:48 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
18:14:48 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
18:14:48 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
18:14:56 <roconnor> ehamberg: ^^
18:15:03 <SamB_XP_> jmillikin: not without putting the tests in the same module, or hiding those entire modules from the world ...
18:16:03 <roconnor> SamB_XP_: not exactly true.
18:16:13 <SamB_XP_> roconnor: hmm?
18:16:18 <roconnor> jmillikin: you can define a main modules that isn't exported, but I think runhaskell will still run it.
18:16:28 <roconnor> jmillikin: though your tests will run interpreted code :/
18:16:32 <roconnor> which isn't so great
18:16:42 <ivanm> or else CPP magic?
18:16:46 <SamB_XP_> roconnor: uh, jmillikin wanted to access internal functions *from* the unit tests
18:16:50 <ivanm> (in terms of exporting/not exporting)
18:16:58 <FunctorSal> you could also have one module that exposes the internals, and one that just reexports the nice interface
18:17:19 <roconnor> SamB_XP_: ah, I see that is consistent with what you said about putting the tests in the module
18:17:22 <jmillikin> Right. Right now, to test my modules, I'm just exporting their guts to everything. I'd rather avoid this, for obvious reasons, but can't figure out how to without merging the test and source files.
18:17:23 <roconnor> SamB_XP_: my bad.
18:17:43 <roconnor> the tests probably belong in the same modules anyways
18:17:45 <ivanm> jmillikin: are you distributing the tests?
18:17:58 <jmillikin> ivanm: Yes, in a separate Tests.hs file.
18:29:48 <BMeph> jmillikin: Just curious, since it's one of my peeves - have you checked your tests to make sure that they test what you think they do, without relying on implementation details that they shouldn't?
18:30:11 <jfredett_> whee, parsers done. :) only 44 lines. :)
18:30:25 <jmillikin> BMeph: Yes. There's a bunch of top-level tests, which test only the exposed public bits, but during development I tend to add tests for low-level components so I can track down errors more easily.
18:31:01 <jmillikin> And something about *removing* tests, even tests for implementation details, seems wrong somehow.
18:31:58 <ivanm> jmillikin: what is this library for?
18:32:11 <BMeph> jmillikin: Well, don't *remove* them, per se, just be sure to make a note to yourself about what they actually test, so that you're not blind-sided in a "trivial" refactoring. :)
18:32:52 <jmillikin> ivanm: it's a small library for parsing IEEE754 halves, floats, and doubles: http://hackage.haskell.org/package/data-binary-ieee754
18:33:13 <ivanm> *shudder*
18:37:14 <roconnor> heh, parsing IEEE floats would allow me to remove my unsafeCoerce :: Double -> Word32 code
18:41:10 <ivanm> gah!  I've just realised that the reason my code using index of coincidence is wrong is because I stupidly trusted wikipedia that the IC of english text is 0.067, when it's actually 0.065! :@
18:42:49 <FunctorSal> roconnor: -> Word64, or is that some really deep bit hacking? ;)
18:43:00 <byorgey> any program which is wrong because of some constant being off by 0.002 has bigger problems than the value of the constant ;-)
18:43:27 <ivanm> byorgey: I'm using it to guesstimate the keylength of vigenere text using the Friedman Test
18:43:40 <ivanm> as such, with that constant being used twice in the calculation, it makes a difference ;-)
18:59:04 <Axman6ol_> i don't suppose anyone here has any experience with OpenCL?
19:03:36 <conal> Axman6ol_: are you working with OpenCL?  i haven't started yet.
19:06:39 <Axman6ol_> conal: I'm trying to, but it's frustrating
19:06:59 <Axman6ol_> i can’t figure out why my kernel is failing to compile
19:07:05 <SamB_XP_> byorgey: is that so?
19:07:14 <SamB_XP_> what if the constant was suppsed to be 0?
19:07:21 <conal> Axman6ol_: oh, oops :(
19:08:13 <Axman6ol_> PROGRESS!
19:08:27 <Axman6ol_> i got it to compile... but now it won't execute :'(
19:08:57 <SamB_XP_> hoooray!
19:09:16 <SamB_XP_> btw, does that "ol" stand for online or offline?
19:10:17 <Axman6ol_> online
19:10:25 <Axman6ol_> messed up my home network yesterday, and can't ssh home
19:14:50 <Orclev> what's the simplest way to convert an int into a hex string... I'm sure there's got to be a function that does exactly that somewhere but I'm not sure where to start looking
19:15:11 <jmillikin> Text.Printf.printf looks promising
19:15:12 <Saizan_> ?hoogle showHex
19:15:13 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
19:15:27 <Saizan_> > showHex 42 ""
19:15:28 <lambdabot>   "2a"
19:15:57 <Orclev> > showHex 15
19:15:58 <lambdabot>   ""->
19:15:58 <lambdabot>    "f"
19:15:58 <lambdabot>  "a"->
19:15:58 <lambdabot>    "fa"
19:15:58 <lambdabot>  "aa"->
19:16:00 <lambdabot> [5 @more lines]
19:16:06 <Orclev> > showHex 15 ""
19:16:06 <lambdabot>   "f"
19:17:04 <Saizan_> a bit spammy for a Show instance
19:17:43 <Orclev> what's ShowS?... I see a type of String -> String in ghci, but I thought type was more or less just a alias for an existing type... that looks like a function
19:18:09 <Saizan_> type ShowS = String -> String
19:18:19 <Saizan_> it allows fast appending
19:18:22 <jmillikin> ShowS is a function, so it can be efficiently composed
19:18:34 <jmillikin> showHex 15 . showHex 20 . showHex 25 $ ""
19:18:35 <jmillikin> > showHex 15 . showHex 20 . showHex 25 $ ""
19:18:36 <lambdabot>   "f1419"
19:19:17 <Orclev> ok
19:20:00 <Orclev> so how do I got about figuring out which module showHex is in?
19:20:06 <Orclev> go about even
19:20:30 <Saizan_> ?hoogle showHex
19:20:30 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
19:20:40 <Saizan_> ^^^ the first one is the module
19:20:48 <jmillikin> Use Hoogle <http://haskell.org/hoogle/> to search for function names
19:21:21 <Orclev> ah, ok, the Numeric confused me, I thought it was a class or something at first, but that makes sense
19:22:31 <SamB_XP_> it's, like, one of two modules that did not get renamed during the Great Renaming
19:22:50 <SamB_XP_> or possibly 3
19:23:37 <Saizan_> which is the third?
19:25:53 <Orclev> > flip showHex "" 32
19:25:53 <lambdabot>   "20"
19:28:29 <Orclev> it's foldr that's safe to use on infinite lists right?
19:28:36 <dobblego> yes
19:29:19 <Saizan_> assuming your folding function is lazy enough
19:30:24 <aavogt> Saizan_: Prelude?
19:30:53 <ivanm> aavogt: if that's the third, what is the second? ;-)
19:34:02 <SamB_XP_> ivanm: Foreign
19:34:07 <ivanm> ahhhh
19:34:24 <SamB_XP_> that was the one that made me go from 2 to 3 ;-)
19:34:28 <SamB_XP_> that was the one that made me go from 2 to 3 ;-)
19:34:31 <SamB_XP_> oops
19:34:36 <SamB_XP_> damn scroll ...
19:34:39 <ivanm> heh
19:35:02 <Raynes> It obviously made you say the same thing twice. same thing twice.
19:35:02 <SamB_XP_> I was scrolled just one or two lines up
19:35:19 <SamB_XP_> Raynes: no, not a nethack scroll!
19:35:35 <FunctorSal> why should Foreign be renamed... it's a hierarchy itself?
19:36:00 <SamB_XP_> FunctorSal: well, yeah
19:36:17 <SamB_XP_> and Numeric probably should be ;-P
19:36:46 * Axman6ol_ rages
19:36:48 <aavogt> Data.Numeric is probably as helpful as Numeric
19:37:06 <aavogt> or it should go somewhere else?
19:41:48 <Orclev> ok, now that's really cool (to me anyway)... I wrote a function that's overloaded based on return type which is something I've never seen done in another language (although no doubt it has been, probably in Lisp or Scheme or something)
19:42:40 <jmillikin> Use Hoogle <http://haskell.org/hoogle/> to search for function names
19:42:48 <jmillikin> Oops, apologies.
19:42:57 <pastah> Orclev: some typeclass hack?
19:42:58 <SamB_XP_> Orclev: I'm pretty sure it can't be done in Lisp or Scheme
19:43:06 <SamB_XP_> or any other duck-typed language
19:43:19 <Makoryu> Orclev: There are very few languages that allow this
19:43:19 <pastah> Orclev: i saw a reddit post on that, i understood like... 3 words...
19:43:42 <SamB_XP_> because how the heck is it going to figure out what type it's returning from the call site?
19:43:51 <pastah> Orclev: http://www.reddit.com/r/haskell/comments/94gfo/innermap_is_this_abusing_the_type_system_ask/
19:43:54 <Makoryu> You can fake it in most Lisps if you do everything with macros, of course
19:45:23 <Orclev> pastah: nah, mine isn't anywhere near as complicated as that
19:45:45 <FunctorSal> @type read
19:45:46 <lambdabot> forall a. (Read a) => String -> a
19:47:20 <Orclev> my first attempt failed though as I was attempting to use type Foo = String, and type Bar = String, and then select the function using either Foo or Bar which ghc didn't care for
19:47:28 <SamB_XP_> pastah: it *might* be considered an abuse of the typesystem if you implement a turing-complete programming language in it
19:47:48 <SamB_XP_> Orclev: indeed ;-)
19:47:52 <jmillikin> Orclev: the "type" keyword is for humans, the compiler disregards it.
19:48:10 <SamB_XP_> jmillikin: I think he probably figured that out ;-)
19:48:13 <jmillikin> You might try "newtype" instead, which will allow you to parameterize on it.
19:48:32 <Orclev> hmm, I'll have to look into newtype
19:48:55 <Orclev> I've seen it mentioned before as half way between data and type, but I don't remember anything else about it
19:49:02 <pastah> SamB_XP_: seriously, i have NO idea as to how that code works, i just posted it because i remembered reading it :)
19:49:23 <pastah> s/posted/linked to/
19:49:24 <FunctorSal> it's data with a single constructor with a single field
19:49:36 <jmillikin> Orclev: newtype is useful when you need the typechecker to distinguish between two types, but are really just wrapping an already-existing type.
19:50:22 <Orclev> jmillikin: sounds like what I'm doing... I finally did data Foo = Foo String deriving (Show), but newtype might be better
19:50:50 <SamB_XP_> Orclev: it is a bit more efficient and has some differences regarding _|_
19:50:56 <FunctorSal> newtype gets you GeneralizedNewtypeDeriving too
19:51:31 <FunctorSal> (hint: derive Monoid for a String newtype :))
19:51:37 <pastah> has someone written a hack for records yet? data Foo = { x :: X }; f :: (X -> X) -> Foo -> Foo; f g foo = foo { x \ g }
19:52:29 <pastah> i saw that as a suggestion on haskell' or somewhere, i'm just curious as to if there is a hack that enables this notation
19:52:55 <SamB_XP_> pastah: it's called an extension, and I've not heard anything
19:54:41 <pastah> SamB_XP_: i know it's called extension, but that sounds too academic
19:55:00 <SamB_XP_> huh, the way my dog is sleeping on my laundry is so cute ...
19:55:08 <pastah> hehe
19:55:28 <SamB_XP_> pastah: well, when you say hack, it sounds like "way of abusing GHC"
19:56:12 <SamB_XP_> either a type-system hack, or possibly something like vacuum that does low-level stuff that you aren't supposed to be able to do ;-)
19:56:12 <pastah> SamB_XP_: do you know anything about writing your own extensions? could this maybe be covered with some advanced rewrites
19:56:39 <dolio> fc-labels can derive lenses for record types using template haskell.
19:56:40 <SamB_XP_> rewrite rules are for efficiency
19:56:52 <pastah> SamB_XP_: well, preprocessing then
19:57:03 <Orclev> so, if I'm reading this right, when I do a newtype, do I still need to derive any classes, or does it automatically inherit the classes of whatever it's wrapping?
19:57:12 <SamB_XP_> pastah: maybe the quasi-quoting syntax?
19:57:23 <FunctorSal> @google GeneralizedNewtypeDeriving
19:57:24 <lambdabot> http://book.realworldhaskell.org/read/programming-with-monads.html
19:57:24 <lambdabot> Title: Chapter 15. Programming with monads
19:57:51 <dolio> http://hackage.haskell.org/package/fclabels
19:57:55 <SamB_XP_> @google "generalized newtype deriving"
19:57:55 <lambdabot> No Result Found.
19:58:07 <pastah> Orclev: {# LANGUAGE GeneralizedNewtypeDeriving #}; newtype Celsius = C Double; deriving (Num,Eq,Ord,Floating,...)
19:58:09 <SamB_XP_> @google GeneralizedNewtypeDeriving site:haskell.org
19:58:10 <lambdabot> No Result Found.
19:59:11 <SamB_XP_> pastah: most of Num makes no sense on celcius or fehrenheit!
19:59:38 <pastah> SamB_XP_: well, it's just an example
19:59:51 <SamB_XP_> now, on kelvin, maybe it does ;-)
20:00:07 <FunctorSal> (*) still seems meaningless
20:00:17 <FunctorSal> prelude reform for great justice
20:00:22 <SamB_XP_> hmm, innapropriately typed, at least
20:01:02 <pastah> Orclev: don't let SamB_XP_ confuse you, that Celsius example should be paired with a Farenheit newtype, for pointing out how much greater GeneralizedNewtypDeriving is than just a simple 'type Celsius = Float'
20:01:08 <FunctorSal> (not really, it would probably break more than it's worth to get rid of Num)
20:01:30 <SamB_XP_> FunctorSal: well, it surely needs a great deal of work
20:01:51 <pastah> the simple solution would allow you to pass a Celsius into hasFever :: Farenheit -> Bool
20:02:02 <SamB_XP_> probably half of my contemplated Num instances have key methods returning _|_
20:02:14 <FunctorSal> pastah: you'd use a Temperature class
20:02:32 <SamB_XP_> FunctorSal: he's pointing out how "type" phails
20:02:34 <FunctorSal> with a method that converts to/from, say, Kelvin
20:02:46 <FunctorSal> ah thought he wanted polymorphism
20:02:58 <pastah> why are you taking this so serious? he was just asking about deriving stuff for newtype
20:03:20 <FunctorSal> hehe
20:03:26 <SamB_XP_> pastah: we are always thinking about everything!
20:03:31 <SamB_XP_> well, slight exhaggeration
20:03:42 <pastah> SamB_XP_: NP-brain
20:04:04 <SamB_XP_> you can replace my brain with a game of minesweeper, you say?
20:04:33 <pastah> well, i could probably do lot's of cool stuff with you if i did
20:04:52 <medfly> like play minesweeper
20:04:57 <Axman6ol> rarg
20:05:01 <Axman6ol> frigging OpenCL
20:05:10 <FunctorSal> a LONG minesweeper board maybe
20:05:13 <pastah> Axman6ol: CL is shourt for?
20:05:35 <smarmy> computing language
20:05:35 <SamB_XP_> what was that minesweeper page ?
20:05:44 <c_wraith> Out of curiosity, given that every problem we know of is in NP, does that mean nothing should take worse than O(n!) time?
20:06:02 <pastah> SamB_XP_: you ever played xbomb?
20:06:25 <SamB_XP_> pastah: huh?
20:06:27 <FunctorSal> c_wraith: not every problem is in NP
20:06:27 <SamB_XP_> why do you ask?
20:06:47 <SamB_XP_> yeah, some problems, just checking the answer is NP-complete, right?
20:06:47 <Orclev> ok, so after reading through all that I discover that I DO still need to add a deriving declaration when using newtype... unless there's another language extension that makes that automatic as well
20:06:59 <c_wraith> Hmm.  I missed a memo, then.  crap.  >_>
20:07:07 <SamB_XP_> what do you call that, NNP?
20:07:11 <c_wraith> (and by "a memo", I mean "paying attention")
20:07:22 <pastah> SamB_XP_: we were talking about minesweeper
20:07:34 <jmillikin> Orclev: You need to explicitly add declarations for classes to inherit, since the underlying type might support operations that don't make sense for the new type.
20:07:34 <SamB_XP_> oh, I know one that isn't in Np
20:07:39 <SamB_XP_> the halting problem!
20:07:54 <FunctorSal> there are infinitely many non-collapsing complexities by http://en.wikipedia.org/wiki/Time_hierarchy_theorem
20:08:03 <pastah> Orclev: post your code on http://hpaste.org
20:08:26 <SamB_XP_> FunctorSal: what do you do with the uncecidable problems ?
20:08:28 <pastah> Orclev: with some comments on what you want to achieve with wigglin your little finger
20:09:06 <FunctorSal> SamB_XP_: I think these are still all decidable
20:09:13 <twb> Suppose I have a package "foo".  I want to load its modules in ghci (with :m+).  How do I know what modules foo provides?
20:09:24 <SamB_XP_> FunctorSal: well, I mean, like the halting problem
20:09:24 <FunctorSal> (decidability is implied by being in some time complexity class)
20:09:33 <SamB_XP_> twb: you could :!ghc-pkg info foo
20:09:40 <twb> SamB_XP_: ah, thanks.
20:09:44 <SamB_XP_> I think that's the right command
20:09:45 <twb> I only knew about ghc-pkg list
20:09:56 <SamB_XP_> well, there's definately a command that will tell you that
20:10:05 <Orclev> well, what my problem boils down to, is I've got a couple functions that all take the same args, and all return a string, just in different ways of processing the args, I was hoping to do something like type Foo = String, and then just use the return type to select the appropriate function
20:11:03 <Orclev> but since type is ignored by the compiler, that sort of screws all that up... I can also just wrap String in various data constructors, but then I have to unwrap them using show which is just annoying
20:11:22 <orbitz> @pl (\x -> f x / f 2)
20:11:22 <lambdabot> (/ f 2) . f
20:11:32 <pastah> Orclev: make a paste, please
20:11:46 <orbitz> hrm
20:11:49 <orbitz> i might stick wiht poitns verson
20:12:32 <SamB_XP_> orbitz: i'd suggest it
20:12:45 <Orclev> pastah: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9624#a9624
20:13:03 <pastah> orbitz: heh, that looks like lisp, sorta
20:13:13 <orbitz> hah
20:13:17 <SamB_XP_> @pl (\g x y -> f (g x) (g y)
20:13:17 <lambdabot> (line 1, column 25):
20:13:17 <lambdabot> unexpected end of input
20:13:17 <lambdabot> expecting variable, "(", operator or ")"
20:13:18 <SamB_XP_> @pl (\g x y -> f (g x) (g y))
20:13:18 <lambdabot> flip =<< (((.) . f) .)
20:13:21 <FunctorSal> SamB_XP_: I was just saying that for every time-complexity class there is a problem that takes more time than that, so in particular not everything is in NP
20:13:23 <SamB_XP_> nooo
20:13:45 <SamB_XP_> FunctorSal: well, Halting surely does take more time than that ;-P
20:14:39 <jmillikin> Orclev: If you're storing bytes, have you considered the ByteString module? <http://hackage.haskell.org/package/bytestring>
20:14:42 <pastah> Orclev: toString :: [Word8] -> String +
20:14:44 <pastah> ?
20:15:02 <Orclev> pastah: I don't understand the question
20:15:41 <orbitz> does Haskell have anything equivalent to Ocaml's polymorphic variants?
20:15:41 <pastah> is that the type of it...
20:15:42 <FunctorSal> SamB_XP_: decidable problem
20:15:45 <FunctorSal> ;)
20:15:54 <pastah> this isn't exactly the biggest paste i've seen
20:15:56 <Orclev> pastah: yeah, more or less
20:16:02 <SamB_XP_> FunctorSal: oh, how long have you been a girl/
20:16:05 <pastah> and not very commented with desires either
20:16:14 <Orclev> pastah: the type is actually toString :: [Word8] -> a
20:16:28 <FunctorSal> SamB_XP_: I don't remember
20:16:32 <Orclev> pastah: but a is really just different names for a String
20:17:01 <FunctorSal> (seemed like a good idea at the time)
20:17:03 <Orclev> pastah: the difference lies with the contents of the string
20:17:06 <twb> Grr, ^L doesn't work in my ghci
20:17:32 <SamB_XP_> twb: to refresh the current line?
20:17:55 <SamB_XP_> what line-reading library is it using?
20:18:02 <twb> SamB_XP_: no, to clear the line (i.e. tput clear)
20:18:07 <SamB_XP_> readline usually handles it afaik ...
20:18:07 <pastah> Orclev: i don't understand this, so i don't know in what way to write this better. please give exapmles of computations and desired results
20:18:07 <twb> clear the screen, rather
20:18:16 <SamB_XP_> twb: it's not supposed to do that1
20:18:23 <SamB_XP_> that's supposed to redraw
20:18:31 <twb> It does in bash
20:18:36 <SamB_XP_> if you mean, when you type on the keyboard
20:18:45 <Orclev> pastah: I want to be able to do, toString x :: Hex and get a string of hex digits, or toString x :: Decimal and get a string of decimal digits, etc.
20:18:54 <SamB_XP_> hmm, I guess that's a valid way of redrawing
20:18:56 <twb> I want ^L to throw away everything above the prompt
20:19:03 <SamB_XP_> when your app doesn't cover the entire screen
20:19:03 <Orclev> pastah: for some arbitrary set of conversions
20:19:11 <twb> Which IME is what ^L does for line-oriented (not ncurses) apps
20:19:13 <SamB_XP_> perhaps the only really valid way
20:19:27 <Draconx> twb, it works in my ghci.
20:19:40 <twb> The Glorious Glasgow Haskell Compilation System, version 6.10.4
20:19:42 <SamB_XP_> twb: so, anyway, which *line is it using ?
20:19:48 <twb> SamB_XP_: dunno, lemme ask ldd
20:19:51 <SamB_XP_> readline, haskelline ?
20:20:03 <twb> "not a dynamic executable"... sigh
20:20:17 <twb> It's the stock Debian/unstable GHC
20:20:20 <SamB_XP_> twb: I think it's a shell script
20:20:24 <twb> Oh, right.
20:20:43 <SamB_XP_> it should have the path in it somewhere
20:20:46 <pastah> Orclev: ok, i think GADTs are what you need here
20:20:53 <pastah> lemme see if i can hack this...
20:21:02 <twb> OK, the actual executable doesn't refer to either readline or haskeline
20:21:14 <twb> But it clearly has some kind of line editing
20:21:24 <SamB_XP_> twb: i'm going to assume that means haskeline
20:21:33 <SamB_XP_> because that's presumably statically linked
20:21:35 <twb> Yep
20:21:43 <SamB_XP_> so, blame that ;-P
20:21:57 <jmillikin> Orclev: is the string supposed to be backwards? toString [1, 2, 3, 4, 5] -> (Hex "54321")
20:22:00 <SamB_XP_> file a bug if you like, even ;-)
20:22:01 <twb> haskeline fixed that ages ago, though
20:22:04 <SamB_XP_> oh
20:22:07 <twb> in 0.5 or so IIRC
20:22:09 <orbitz> @pl (\x -> - f x)
20:22:09 <lambdabot> (line 1, column 8):
20:22:09 <lambdabot> unexpected "-"
20:22:09 <lambdabot> expecting lambda abstraction or expression
20:22:16 <orbitz> @pl (\x -> - (f x))
20:22:17 <lambdabot> (line 1, column 8):
20:22:17 <lambdabot> unexpected "-"
20:22:17 <lambdabot> expecting lambda abstraction or expression
20:22:20 <orbitz> ho hum
20:22:34 <SamB_XP_> well, blame GHC for not listing the versions of the libraries it uses in it's version output ?
20:23:03 * SamB_XP_ goes to bed
20:23:05 * SamB_XP_ is late
20:25:40 <jmillikin> Orclev: is this helpful? <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9625>
20:25:40 <ivanm> as in "the late SamB_XP_"? :p
20:26:54 <twb> ivanm: then he'd be more powerful than we could possibly imagine?
20:27:47 <Orclev> jmillikin: yes, thanks, I hadn't gotten to the point of refining and verifying the output, so that saves me some time... still trying to figure out if there's a better way to select the converter to use
20:28:26 <jmillikin> Orclev: Using a typeclass like you're doing looks like a good strategy, there are several standard libraries which do the same sort of thing.
20:29:18 <Orclev> jmillikin: I just whish there was a way I could get a real String out if it without having to use show every time
20:29:35 <pastah> Orclev: i'm writing a nice little typeclass hack
20:29:58 <jmillikin> Orclev: It looks like you already have a "toString" method, you can just use that.
20:30:07 <jmillikin> Or, sorry, other way around
20:30:28 <Orclev> pastah: thanks... I'm afraid I'm still trying to get my head around the whole type system... reminds me of when I first tried to understand pointers, I'm sure it'll all click on of these days
20:31:04 <pastah> Orclev: still, you need to give CLEAR examples of computations
20:31:14 <pastah> i'm not entirely sure about what you want
20:31:51 <pastah> i wanna see "toString [1,2] == Hex "0x01 0x02"
20:32:05 <pastah> so i can know what the goal is
20:33:03 <Axman6ol> god damn it. why is OpenCL so messed up >_<
20:33:29 <copumpkin> Axman6ol: you tried opencl?
20:33:31 <copumpkin> I mean #opencl
20:33:43 <Orclev> what I really want to see is "toString [1,15] :: Hex == "010F"", and "toString [1,15] :: Decimal == "0115""
20:33:46 <Axman6ol> nope, didn't know it existed
20:34:11 <Orclev> but I don't think that's possible
20:34:28 <pastah> Orclev: see, that wasn't too hard
20:34:41 <pastah> Orclev: don't underestimate GADTs
20:35:22 <pastah> this would have been easier if you had told about the existance of the newtype Decimal
20:35:30 <copumpkin> why would you need a GADT for that?
20:35:49 <pastah> copumpkin: unsafeUnsafeNaughtyFilthyCoerce
20:35:58 <pastah> though not too naughty...
20:36:00 <jmillikin> Orclev: something like this? <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9626>
20:36:00 <Orclev> pastah: well, there will eventually be a whole bunch of conversions, including Octal, UTF8, ASCII, and maybe others
20:36:35 <Axman6ol> thanks for the tip copumpkin
20:36:41 <copumpkin> Axman6ol: no problem :)
20:36:56 <Axman6ol> sadly it seems like a rather dead channel :(
20:38:51 <copumpkin> well, the only public opencl implementation was just released a couple of weeks ago
20:39:16 <pastah> Orclev: why can't you just send an extra variable?
20:39:34 <pastah> data RenderMode = Hex | Decimal | Octal ...
20:39:54 <jmillikin> Orclev: If you're going to have many rendering modes, I would do something like this: <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9627>
20:40:07 <Orclev> pastah: I suppose I could, but I was trying to make it plugable so all you needed to do was implement an instance of renderer
20:41:30 <Orclev> jmillikin: that looks interesting
20:42:29 <Orclev> I hadn't realized you could make the contents of a type a function, but that makes sense now that I think about it
20:48:48 <Orclev> I think maybe my object oriented background is getting in the way here, I'm having trouble thinking about the problem clearly... if I was doing this in C# or Java, I'd just declare an interface that does something like String toString(List<Word8>) or whatever then make several instances of it...
20:49:42 <jmillikin> That takes a while to go away, I've been using haskell for months and still break down to drawing class diagrams occasionally
20:49:51 <pastah> i'd just make a simple function (format :: [Word8] -> RenderMode -> String]
20:50:16 <Orclev> pastah: one of the goals is to allow it to be extended down the road by a third party, I don
20:50:33 <Orclev> don't see how that's possible unless they recompile whatever file RenderMode is defined in
20:51:35 <Orclev> bah, maybe I'll just go with the simple solution and worry about redoing it once I actually have it working
20:51:48 <pastah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9624#a9628
20:53:05 <Orclev> pastah: yeah, I think that's what I'm going to endup going with for now, I can just derive Show and all I need to do is pass it to show to "unwrap" it
20:53:40 <pastah> Orclev: i have a cool typeclass i built i while back, let me fetch the source for you real quick...
20:54:26 <Orclev> pastah: ok, I'll look it over, but I'd be suprised if I fully understand it... a lot of haskell still looks greek to me, and I'm not talking about lambdas
20:54:35 <jmillikin> Orclev: Be careful about using "show" for unwrapping, it makes investigating values while debugging a bit more difficult.
20:55:10 <Orclev> jmillikin: I haven't had much luck with debugging in ghci anyway
20:55:11 <jmillikin> If you see (Hex "1234") then you know what it is, but "1234" could be anything
20:55:37 <jmillikin> Unit test output is also debugging, and I tend to find those more helpful
20:56:43 <Orclev> jmillikin: yeah, I haven't done any unit testing in haskell yet, but I imagine it's easier in functional languages as they already have a strong emphasis on composition
21:00:31 <pastah> Orclev: didn't have it, but i'll rewrite it, gimme five mins...
21:01:39 <Orclev> pastah: if it's going to be a pain don't worry about it, it's probably wasted on me at this point anyway
21:02:06 <jfredett> @remember Orclev ... a lot of haskell still looks greek to me, and I'm not talking about lambdas.
21:02:06 <lambdabot> Done.
21:02:28 <jfredett> maybe it's all this tagsoup I've been drinking, but I got a good chuckle out of that.
21:02:42 <pastah> Orclev: read a little about GADTs while you wait :)
21:02:45 <Axman6ol> copumpkin: if you're interested, i got my problem fixed. needed to add f to my float constants >_< (0.5 -> 0.5f)
21:02:50 <Orclev> pastah: already started to
21:02:56 <Axman6ol> and i must say OpenCL is fucking fast
21:02:59 <pastah> the chapter in learnyouahaskell is quite good iirc
21:03:01 <copumpkin> Axman6ol: aha :)
21:06:38 <Axman6ol> Discrete Cosine Transform on 2^15 floats takes 44.089224s using plain C, 76.675806s using Haskell, and 7.219165s using OpcnCL
21:06:56 <copumpkin> exact same algorithm?
21:07:32 <Axman6ol> the haskell one isn't exactly the same (i need to rewrite it to make it more haskellish i think. it doesn't want to parallelise well either)
21:07:46 <copumpkin> have you tried writing it in dph?
21:07:54 <pastah> @pl (\f v0 v1 -> pack (f (unpack v0) (unpack v1)))
21:07:54 <lambdabot> ((pack .) .) . flip flip unpack . ((.) .) . (. unpack)
21:07:58 <Axman6ol> nope, i should though
21:08:05 <pastah> @pl (\f v1 v0 -> pack (f (unpack v0) (unpack v1)))
21:08:05 <lambdabot> ((pack .) .) . (. unpack) . flip . (. unpack)
21:08:07 <copumpkin> pastah: that can be an `on`
21:08:19 <pastah> copumpkin: Data.Function, right?
21:08:27 <copumpkin> (pack .) . (f `on` unpack)
21:08:28 <aavogt> @type off
21:08:29 <lambdabot> Not in scope: `off'
21:08:34 <copumpkin> pastah: yep
21:08:37 <aavogt> @type on
21:08:38 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:09:05 <Axman6ol> anyway, time to get going. later al
21:09:08 <pastah> copumpkin: sorry, it can't
21:09:09 <copumpkin> Axman6ol: ciao
21:09:19 <pastah> i'm not sure both are 'a':s
21:09:29 <copumpkin> pastah: oh
21:09:36 <pastah> my function could be (a -> b -> c)
21:09:46 <pastah> copumpkin: paste in 30 seconds...
21:09:50 <copumpkin> :)
21:10:11 <copumpkin> I've wanted a more polymorphic on, but I don't think it's possible to write one in current haskell
21:10:24 <aavogt> copumpkin: rank-something types?
21:10:47 <copumpkin> class polymorphism or something
21:11:27 <aavogt> @type unpack
21:11:27 <lambdabot> Not in scope: `unpack'
21:11:50 <BMeph> @hoogle unpack
21:11:50 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
21:11:50 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
21:11:50 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
21:12:28 <aavogt> that sounds inefficient
21:12:50 <pastah> Orclev: you ready?
21:12:55 <pastah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9629#a9629
21:13:07 <pastah> copumpkin: ^^
21:13:27 <Orclev> pastah: yeah, one sec while I check that out
21:13:46 <copumpkin> pastah: why not do that with an associated type?
21:14:03 <pastah> copumpkin: that Pack stuff i wrote there is great if you ever write an interpreter
21:14:13 <pastah> copumpkin: a what? gief example pl0x
21:14:58 <copumpkin> class Moo a where type Value a :: **; pack :: a -> Value a; unpack :: Value a -> a
21:15:18 <copumpkin> whoops, an extra asterisk crept in
21:16:05 <copumpkin> or are you mainly trying to close the typeclass?
21:16:07 <pastah> copumpkin: annotate plz... i don't get in... and comment about advantages plz, because i can't see any
21:16:35 <copumpkin> I'm wondering why you need a GADT
21:16:39 <Orclev> pastah: where is on used at? I see it imported but not used anywhere
21:16:53 <pastah> copumpkin: data Exp a = EAdd (Value a) (Value a)
21:17:11 <pastah> eval (EAdd v0 v1) = liftV2 (+) v0 v1
21:17:32 <pastah> Orclev: it isn't, i forgot to remove the import
21:17:52 <Orclev> pastah: ah, ok
21:17:55 <pastah> copumpkin: i tried to do this in an interpreter _without_ GADTs, NOT fun
21:17:59 <pastah> read comment
21:19:15 <BMeph> copumpkin: What's up with the GADT hate, man? :)
21:19:17 <pastah> copumpkin: just data Value = VI Int | VD Double ... is not evough if you want to make an interpreter without loads of boilerplate code
21:19:41 <pastah> yeah! what BMeph said!
21:19:43 <copumpkin> BMeph: just wondering what the point of it is, when all the constructors are effectively a -> Value a
21:19:48 <Orclev> pastah: it's interesting, in some ways reminds me of monads in the way values are wrapped, and functions are lifted
21:20:52 <copumpkin> pastah: I guess I see :)
21:21:08 <pastah> Orclev: i was thinking that perhaps you could use this, in some way...
21:21:21 <pastah> so you make a datatype as a GADT
21:21:38 <pastah> then you have Hex :: String -> MyType Word8
21:21:50 <pastah> Dec :: String -> MyType Int
21:22:24 <pastah> and then you do typeclasses for making your toString function
21:23:10 <pastah> copumpkin: see, even if all it holds is a string (:: String -> Lol RandomType), you can use the RandomType as a base for typeclasses
21:23:46 <copumpkin> yeah, my question was more along the lines of why you weren't just doing data Value a = Value a
21:24:03 <copumpkin> or newtype, I guess
21:24:55 <copumpkin> but you want to be able to switch on the type, too?
21:24:56 <pastah> copumpkin: because haskell can't decide how to 'pack' if i do that
21:25:25 <copumpkin> how do you mean?
21:25:26 <pastah> copumpkin: well, you have the typesigs for liftV* right there :p
21:25:56 <copumpkin> pack = Value; unpack (Value a) = a, no typeclas at all :P
21:26:28 <pastah> ok, so say that you have some expression structure ; data Exp a = EAdd (Exp a) (Exp a) | EValue (Value a)
21:27:16 <pastah> if you want to make an evaluator for this you will need to have, firstly the 'a' in the Exp declaration and secondly a GADT Value type
21:28:00 <pastah> what i tried to do first was to do this packing and unpacking of constructors without the 'a' in the Exp type
21:28:02 <deech`> I found a Haskell debugging tool called Hood (http://www.haskell.org/hood/). It doesn't seem to have been updated in close to a decade - is it still useful or has it been superceded by the GHC debugger?
21:28:52 <pastah> copumpkin: THAT caused me major headache, even with 'forall.'s all over the place :/
21:32:09 <Cale> "The Snowball Haskell Compiler" -- there's one I've never heard of
21:32:26 <AAOsok> Anyone here use Haskell-Net? It provides POP3/IMAP/etc...
21:33:11 <Orclev> AAOsok: I can't tell from that context, is it a client, a server, or a website?
21:33:16 <dons> Cale: andy gill's java backend
21:33:33 <AAOsok> Orclev: It is a library.
21:33:44 <AAOsok> Orclev: it provides IMAP/POP3/SMTP routines to Haskell.
21:33:52 <AAOsok> @hackage haskell-net
21:33:52 <lambdabot> http://hackage.haskell.org/package/haskell-net
21:33:55 <Orclev> AAOsok: interesting and badly named
21:34:01 <AAOsok> Yes, it is badly named.
21:34:04 <AAOsok> But it is really useful.
21:34:10 <AAOsok> It should be called hsMail or something.
21:35:03 <Cale> deech`: I'm fairly sure you'll have trouble getting hood working, but it was pretty cool, like a nicer version of Debug.Trace
21:36:26 <pastah> anyone here has any knowledge on the haskell OpenGL bindings? I've been quite a lot of grief from it because it couldn't match GLfloat to CFloat
21:36:47 <Cale> pastah: can't you just realToFrac to convert?
21:37:06 <pastah> but in Graphics.Render.OpenGL.Raw.? i saw that it was just a type alias
21:37:19 <Orclev> last time I did anything with OpenGL was when OpenGL 2.0 was first released and that was working on C
21:37:26 <pastah> Cale: well, this was when i was installing stuff from cabal
21:37:59 <pastah> and i'm not about to read all of frags source code to change weird type errors that shouldn't be there...
21:38:30 <Cale> pastah: Perhaps it used to be a type alias but that changed?
21:38:55 <orbitz> is HM type system difficult to implement?
21:40:11 <pastah> that's why i'm asking if anyone here has familiriarity with the OpenGL bindings; if there is some easy way to fix this
21:41:30 <aavogt> pastah: perhaps if you force frag to use an older version of the opengl binding things will work?
21:41:59 <aavogt> it requests OpenGL>=2.0
21:43:27 <pastah> --cabal-lib-version=VERSION <-- this seems useful
21:43:58 <aavogt> but maybe you end up building it with opengl-2.4.0.1, which looks like it changed GLFloat to a newtype instead of a type CFloat (just from the errors you've been getting)
21:45:03 <pastah> hmm... i'll try with 2.2.3.0, which i happend to have installed...
21:45:39 <pastah> nope...
21:47:04 <deech`> Is Gtk2Hs necessary for Vacuum-Cairo?
21:47:26 <aavogt> deech`: where else is cario going to come from?
21:47:40 <ivanm> deech`: I think so, yes
21:47:57 <deech`> aavogt, ivanm : Ok thanks, just checking.
21:48:32 * pastah is installing his fourth version of OpenGL...
21:48:40 <Orclev> yep, frag doesn't compile for me either, type mismatch between GLFloat and Float
21:49:18 <Orclev> well, GLfloat, but same difference
21:49:33 <pastah> Orclev: i'll tell you how forcing 2.2.2.0 on it goes...
21:50:17 <aavogt> pastah: It worked for me with OpenGL-2.2.1.1
21:50:59 <Orclev> hmm, I thought Cairo was a standalone library that had bindings for Gtk+, SDL, and a couple other frameworks
21:51:07 <pastah> nooo....!
21:51:14 <pastah>     --preference=DEPENDENCY        Specify preferences (soft constraints) on
21:51:15 <pastah>                                    the version of a package
21:51:27 <pastah> this sounds like cabal package building to me, not installation
21:55:55 <dons> deech`: yes, you need gtk2hs
21:56:09 <dons> Orclev: frag will need the version of OpenGL that comes with the Haskell Platform
21:56:19 <dons> I'd encourage people to use that version, unless they have a specific reason to use the new one on hackage
21:57:17 <ivanm> dons: why?
21:57:29 <ivanm> how/why else would people start using new libs then?
21:58:41 <Orclev> hmm, I'm not sure what version came with my "haskell platform"... I suppose I might be able to look it up somewhere or other
21:59:53 <dons> ivanm: because more things build with the stable version
22:00:05 <dons> so if you're a new user who just wants things to work, use the platform version of things
22:00:20 <ivanm> oh, for users rather than devs?
22:00:20 <dons> Orclev: or just install the haskell platform, http://hackage.haskell.org/platform
22:00:33 <dons> indeed. devs who want  to try out experimental versions of things
22:00:40 <dons> or new users like Orclev
22:00:49 <Orclev> dons: I installed ghc using emerge ghc
22:00:58 <dons> Orclev: the haskell platform for Gentoo then,
22:01:02 <dons> follow the links on the page :)
22:01:36 <lpsmith> ugh...  I had a go with Gentoo;  I ran back to Debian.   I'm definitely a believer in binary distros now :-)
22:02:11 <Orclev> I like gentoo, although I've been considering arch... unfortunately neither one ships with a proper keymap for my apple keyboard :(
22:02:42 <lpsmith> I've been using Debian for a long time;  every time I've tried something different I've always come back.
22:04:00 <lpsmith> dons:   is the 6.12 release candidate going to be coming from the HEAD branch, or the STABLE?
22:05:27 <dons> 6.12 is the head branch
22:05:31 <ivanm> Orclev: for gentoo problems, see #gentoo-haskell ;-)
22:06:10 <Orclev> ivanm: heh, I'm not having gentoo problems, more like compatability issues with some cabal packages
22:06:47 <ivanm> yes, but we can answer ebuild and dep related problems better there :p
22:06:52 <ivanm> (without annoying everyone else)
22:08:04 <lpsmith> dons:  so the ghc-6.10.4.2009-09-20    for example is just conservative bugfixes on 6.10.4?
22:09:05 <dons> yep
22:09:12 <Orclev> so, if frag won't build with newer releases of OpenGL, shouldn't the cabal package dependencies be updated to specify OpenGL >= 2.0 and <= 2.2?
22:09:36 <ivanm> Orclev: that's one thing that dcoutts is pushing people to do
22:09:46 <ivanm> Orclev: problem is, we can't touch/change packages that are already on hackage
22:09:51 <tommd> That is what the deps are for - I think the latest restrictions on Hackage prevent package uploads if the deps don't have an upper bound.
22:09:58 <ivanm> since part of hackage's purpose is to archive the growth of the haskell community, etc.
22:10:08 <ivanm> tommd: only on base and a few other libs
22:10:10 <ivanm> not in general
22:10:13 <tommd> oh, ok
22:10:29 <ivanm> the problem is picking deps for packages that don't match the PVP
22:10:39 <Orclev> PVP?
22:10:42 <tommd> I've been doing it in general - only once causing an issue with needing a new package simply to cover a newer version of 'binary'.
22:10:48 <ivanm> Orclev: Package Versioning Policy
22:11:21 <ivanm> the biggest problem is when package A has an upper bound on its dep for package B, but works with newer versions of B
22:11:37 <ivanm> and the developer doesn't release an updated version of A
22:11:51 <tommd> yep - thats what I ment that I ran into, but just once thus far.
22:12:12 <tommd> I can imagine the issue getting slightly out of hand.
22:13:14 <ivanm> the real problem is that most of our "core" libraries are still in a limited state of flux (i.e. we're still working on them, making changes, etc.)
22:13:25 <ivanm> and we tend to make many releases
22:13:36 <ivanm> as opposed to big C libs which might release every 6 months, if that
22:16:35 <Orclev> this if totally off topic, but something you said reminded me of, is there a equivalent in haskell to annotations ala C# or Java? Something that you can add meta-information on to types/functions/whatever?
22:17:33 <lament> comments
22:18:01 <lament> there're strictness annotations but they are not really meta
22:18:11 <Orclev> ok, slight correction, runtime readable meta-information
22:18:54 <Cale> Orclev: Compilation destroys all non-essential information about functions, including their names.
22:19:24 <Cale> (well, except if they are exported, in which case a mangled form of the name is preserved)
22:19:54 <Cale> If you want to do reflection, you have to arrange for it specifically, basically.
22:20:30 <Orclev> hmm, ok, I figured that was the case, but I decided I'd check just on the off chance I was wrong
22:21:14 <Cale> Typeclasses can give you quite a good simulation of type reflection
22:22:56 <Orclev> Cale: actually even though I said runtime what I was more interested in was inspection of a compiled binary not necessarily the running process... I could probably fudge it using a pre-processor to build a meta-file that does the same thing if I really felt like it
22:23:33 <Orclev> it was just an idea anyway, not important
22:36:29 <stanv> is it possible to find remote job haskell programmer ?
22:39:52 <vegai> stanv: trivial, I suppose
22:40:14 <stanv> hmm
22:47:03 <Makoryu> stanv: Assuming you've got the necessary qualifications (CS degree, etc.) it really should be trivial. Poke around on the mailing lists for places that are constantly hiring
22:47:50 <tobe> @pl(\x->(f x))
22:47:51 <lambdabot> Unknown command, try @list
22:48:07 <Cale> @pl (\x -> f x)
22:48:07 <lambdabot> f
22:48:26 <Cale> (mainly, you need to leave a space after @pl)
23:21:19 <okie1> has anyone messed with hardware (FPGA, uC) Haskell implementations
23:56:16 <copumpkin> @ask roconnor In your paper on reals for Coq, you mention that you wrote your implementation in Haskell first, then translated it to Coq. Is the Haskell implementation available somewhere? I'd be interested in reading it
23:56:16 <lambdabot> Consider it noted.
23:58:06 <copumpkin> @tell roconnor oh I think I found it at http://r6.ca/FewDigits/, nevermind :)
23:58:06 <lambdabot> Consider it noted.
