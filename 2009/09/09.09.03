00:22:22 <vegai> so people using C++ win ICFP again? :)
00:24:19 <Peaker> C++ wins more frequently than Haskell/et al?
00:27:18 <ketil> Looks like it.  A couple of Java entries in the top-scoring segment, too, wasn't there?
00:28:11 <Peaker> so, how come?  :)
00:29:11 <osfameron> because c++ is the language of discerning hackers :-)
00:29:44 <ray> clearly the competition is fixed by curly brace partisans
00:30:06 <jethr0> from my experience in 2007, 'haskell teams' tend to want to prove more. maybe some of the c++/java teams are more flexible regarding aesthetics and use of supporting languages?
00:31:31 <jethr0> also, since there are people who know c++ than haskell, maybe some of the c++ programmers have better familiarity with libraries etc. (not even to speak of base rate fallacy, which doesn't apply because not overwhelmingly more c++ teams participate than haskell afaik)
00:31:31 <jethr0> osfameron: hehe
00:31:47 <jethr0> s/are people/are more people/
00:32:32 <arw_> ray: haskell has curly braces.
00:33:13 <jethr0> is there a list with participants 'languages' used?
00:33:30 <Kaidelong> can someone help a newbie?
00:33:32 <kmc> arw_, invisible ones at that :)
00:33:38 <kmc> (usually)
00:34:16 <jethr0> Kaidelong: absolutely
00:34:30 <Kaidelong> let numtodigitls n acc = if (n < 10) then (n:acc) else (numtodigitls (n div 10) ((n mod 10):acc))
00:34:36 <Kaidelong> GHC doesn't like this in the shell
00:34:45 <kmc> > let numtodigitls n acc = if (n < 10) then (n:acc) else (numtodigitls (n div 10) ((n mod 10):acc))
00:34:46 <Kaidelong> it works in the F# shell so it's something haskell specific
00:34:46 <lambdabot>   not an expression: `let numtodigitls n acc = if (n < 10) then (n:acc) else ...
00:35:14 <Kaidelong> complains about constructing an infinite type
00:35:20 <kmc> Kaidelong, to use names like "div" and "mod" infix, surround them with backticks
00:35:26 <jethr0> > let numtodigitls n acc = if (n < 10) then (n:acc) else (numtodigitls (n div 10) ((n mod 10):acc)) in numtodigitls 10 []
00:35:27 <lambdabot>   Occurs check: cannot construct the infinite type:
00:35:27 <lambdabot>    a = (a1 -> a1 -> a1) -...
00:35:27 <Kaidelong> oh, thanks
00:35:34 <kmc> > let numtodigitls n acc = if (n < 10) then (n:acc) else (numtodigitls (n `div` 10) ((n `mod` 10):acc))
00:35:35 <lambdabot>   not an expression: `let numtodigitls n acc = if (n < 10) then (n:acc) else ...
00:35:51 <kmc> > let numtodigitls n acc = if (n < 10) then (n:acc) else (numtodigitls (n `div` 10) ((n `mod` 10):acc)) in numtodicits 31337 []
00:35:52 <lambdabot>   Not in scope: `numtodicits'
00:36:03 <kmc> > let numtodigitls n acc = if (n < 10) then (n:acc) else (numtodigitls (n `div` 10) ((n `mod` 10):acc)) in numtodigitls 31337 []
00:36:04 <lambdabot>   [3,1,3,3,7]
00:36:21 <Kaidelong> thanks :)
00:36:28 <davidL> > let numtodigits = map digitToInt . show in numtodigits 31337
00:36:29 <lambdabot>   [3,1,3,3,7]
00:37:33 <kmc> :t map (read . return) . show
00:37:34 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> [a]
00:37:44 <jethr0> > let digits = map digitToInt . show in digits 1234
00:37:45 <lambdabot>   [1,2,3,4]
00:37:59 <ksf> assume that a certain piece of code allows a pokeElemOff index to depend on say network input. How hard would it be to mess with the rts to inject code?
00:38:00 <kmc> > let n = map (read . return) . show in n 1357
00:38:01 <lambdabot>   [* Exception: Prelude.read: no parse
00:38:24 <kmc> > let { n :: Int -> Int; n = map (read . return) . show } in n 1357
00:38:25 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
00:38:35 <kmc> > let { n :: Int -> [Int`; n = map (read . return) . show } in n 1357
00:38:36 <lambdabot>   <no location info>: parse error on input `;'
00:38:38 <kmc> > let { n :: Int -> [Int]; n = map (read . return) . show } in n 1357
00:38:40 <lambdabot>   [1,3,5,7]
00:38:48 <jethr0> kmc: what's that return for? it's already a string?
00:38:59 <Twey> > let digits base = reverse . map (`mod` base) . takeWhile (/= 0) . iterate (`div` base) in digits 10 "31337"
00:39:00 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
00:39:00 <lambdabot>    arising from a use ...
00:39:06 <kmc> :t \f -> map f . show
00:39:06 <Twey> Ech
00:39:07 <lambdabot> forall b a. (Show a) => (Char -> b) -> a -> [b]
00:39:09 <Twey> > let digits base = reverse . map (`mod` base) . takeWhile (/= 0) . iterate (`div` base) in digits 10 31337
00:39:10 <lambdabot>   [3,1,3,3,7]
00:39:15 <kmc> jethr0, the elems of a string are chars
00:39:19 <kmc> read wants a string not a char
00:39:35 <Twey> :t digitToInt
00:39:36 <lambdabot> Char -> Int
00:39:44 <Twey> > map digitToInt "31337"
00:39:45 <lambdabot>   [3,1,3,3,7]
00:39:46 <jethr0> ah, my bad
00:40:40 <Twey> I wonder which is faster.
00:40:55 <ksf> the divmod one.
00:41:01 <ksf> ...show does divmod, too.
00:41:09 <kmc> :t scanl
00:41:09 <Twey> Ah.
00:41:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
00:41:23 <kmc> > let f = scanl (\x y
00:41:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:41:45 <kmc> > let f = scanl (\x y -> (10*x)+y) 0 in f [1,2,3,4]
00:41:47 <lambdabot>   [0,1,12,123,1234]
00:42:16 <jethr0> that's micro-optimizing. write the simplest/most expressive code and optimize after profiling ;)
00:42:17 <ksf> there should probably be digitsAtBase :: Integral a => Int -> a -> [Int] in the stdlib.
00:42:32 <Twey> Meh
00:42:46 <jethr0> > let f = foldl (\x y -> (10*x)+y) 0 in f [1,2,3,4]
00:42:46 <kmc> let { f :: [Int] -> Int; f = read . concatMap show } in f [1,2,3,4]
00:42:47 <lambdabot>   1234
00:42:51 <kmc> > let { f :: [Int] -> Int; f = read . concatMap show } in f [1,2,3,4]
00:42:52 <lambdabot>   1234
00:43:00 <davidL> :t showIntAtBase
00:43:02 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
00:43:03 <Twey> Well, the string is also limited in that it's restricted to the base in which the string was written.
00:43:17 <Peaker> jethr0: how many C++ teams vs Haskell teams?
00:43:31 <Twey> Whereas the mathematical interpretation can return any reasonable base.
00:43:33 <jethr0> don't know, couldn't find a proper list
00:43:40 <Peaker> jethr0: also, is ICFP more about development speed, or about execution speed? If its the latter, I can see why C++ would have an advantage given a short development time frame
00:44:21 <Twey> C++ in *my* ICFPâ€½
00:44:26 <jethr0> rarely the second is the major factor even though speed can count to some degree. it's more about who get's to solve a tricky problem within 24/48 hours
00:44:59 <Peaker> jethr0: I'd expect experienced Haskell folk to do better than experienced C++ folk in that regard
00:45:01 <ksf> > (sum . zipWith (\s b -> b * 2^(s*8)) [0..]) [1..1000]
00:45:02 <lambdabot>   681433418657719609743005363085892125569666797627740081080794169704658248725...
00:45:31 <jethr0> usually a good approach/good data types will be more important (at least imho) as bit-twiddling speed
00:45:34 <Peaker> jethr0: Though I guess its probably more about the individual hackers than the languages they use (to a point, slow untyped languages might be below the barrier of entry altogether)
00:45:56 <Peaker> jethr0: In Haskell, performance tuning (in light of laziness) is more expensive..
00:46:18 <jethr0> Peaker: yes, and you have to consider the self-selection effect of languages on programmers and of who takes part in the contest ^_^
00:46:55 <Peaker> jethr0: are you talking about Python? :) I think Python guys tend to be quite capable, at least around here
00:47:09 <Peaker> jethr0: C++ guys too. I don't know enough Haskell guys around here to tell
00:47:23 <jethr0> i consider the average experienced haskell programmer to be more savvy than the average C++ experienced programmer. but firstly, that is pure opinion and secondly, averages never count for anything ;)
00:47:44 <ksf> jethr0, not nescessarily performance-wise.
00:48:07 <Orclev> ok, this is most likely a stupid question I'm going to hate myself for asking soon, but how do I get a value out of a monad?
00:48:09 <ksf> ...as, tbh, ghc does a bloody good job optimising code.
00:48:17 <Twey> Orclev: Depends on the monad
00:48:23 <Twey> In some of them, you don't
00:48:24 <doserj> Orclev: using <- in do-notation
00:48:25 <ksf> if it's IO, forget it.
00:48:30 <jethr0> i think quite a few of the experienced haskellers would be able to produce performant code in haskell or at least one other fast language
00:48:37 <ksf> you can't escape monads if they don't let you.
00:48:38 <Orclev> ksf: I was afraid of that
00:48:43 <Orclev> hmm
00:48:48 <ksf> Orclev, but you don't need to, either.
00:48:49 <Peaker> jethr0: how many "average experienced Haskell programmers" do you know?  I only know people in IRC, and having never actually worked with any of them on a project, its hard for me to tell how competent they really are at getting things done in a short time frame
00:48:57 <quicksilver> the Endo ICFP project was pretty CPU constrained
00:49:00 <ksf> :t (>>=)
00:49:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:49:15 <quicksilver> several of the haskell teams didn't have a complete solution because they couldn't get it going fast enough
00:49:23 <quicksilver> that kind of thing doesn't always happen
00:49:26 <Peaker> jethr0: I'm working on converting my co-workers to Haskell, though, its very difficult (Good workplaces keep their employees too busy)
00:49:28 <jethr0> Peaker: i've worked with a few on the icfp contests, and i've seen them produce solutions to tricky problems in a really short time frame.
00:49:40 <ksf> see? the a in the second argument isn't bound to m. so you can treat a monadic value as pure, as long as you stay within the monad.
00:50:30 <quicksilver> although it seems to me that recent ICFPs have tended to be more CPU intensive
00:50:42 <Orclev> hmm, I've got a value that's returned as a IO a, that I want to use in a pure function... the only way I can see to do that is to sort of wrap the pure function in a layer that only shuttles the value from the impure one into the pure one, and then sort of re-wraps it
00:50:52 <ksf> ...that's because the IO monad can't return any useful value, because, in fact your whole program is an expression inside the IO monad. you can't get out of your own program...
00:51:21 <arw_> .oO( exec... )
00:51:22 <Twey> Orclev: But if you're using an IO value in your function, it's no longer a pure function.
00:51:22 <ksf> other monads have functions like e.g. runState, so that you can run a stateful computation, and get the result back.
00:51:32 <quicksilver> Orclev: fmap purefun impurefun
00:52:04 <jethr0> Orclev: you can do: "do {x <- monadicAction; return (pureFunction x)}" or "do {liftM pureFunction monadicAction}"
00:52:08 <ksf> getLine >>= return . toUpper >>= putStrLn
00:52:12 <Twey> You can bind your function into the monad and let the monad provide it with a pure value, however.
00:52:22 <Twey> And Haskell provides a variety of tools for doing that nicely.
00:52:26 <ksf> ...which is equivalent to fmap toUpper getLine >>= putStrLn.
00:52:37 <ksf> ...where "toUpper" is obviously pure.
00:52:44 <quicksilver> @type fmap length System.getArgs
00:52:44 <Twey> jethr0: The do in the latter being completely redundant, of course.  ;)
00:52:45 <lambdabot> IO Int
00:52:46 <jethr0> obviously! ^_^
00:52:50 <quicksilver> Orclev: like that.
00:53:10 <jethr0> Twey: of course, but who wants to scare people with ">>="? *g*
00:53:12 <quicksilver> Although <$> is an infix version of fmap which I think looks more attractive, in which case it looks like "length <$> getArgs".
00:53:12 <Orclev> ok, well that gives me some tools to try and beat this thing into submission at least... now to see which one I can bend to fit
00:53:19 <Twey> jethr0: Hehe
00:53:25 <Peaker> ksf: if you combine >>= and ., use =<< ?
00:53:45 <jethr0> Peaker: i tend to
00:53:47 <Peaker> ksf: and (return . f =<<) -> fmap ?
00:53:59 <jethr0> i find it annoying to switch reading directions too often though
00:54:07 * ksf uses fmap there, almost exclusively.
00:54:08 <jethr0> Peaker: yes
00:54:20 <jethr0> or liftM
00:54:31 <ksf> ...I generally don't use =<<, just >=>.
00:54:32 <Orclev> I think ultimately I'm going to need to create some sort of state monad because I'm passing around an ever increasing list of state and it's getting a little out of hand
00:54:41 <jethr0> @hoogle (>=>)
00:54:42 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:54:54 <Peaker> jethr0: yeah, I find right-to-left annoying, but I see the rational of having function application work that way  f x  rather than   x f   as the function gets to decide whether to even evaluate the "x", so is more important in understanding the expression, so should appear first, and (.) and (=<<) should mirror that
00:55:00 <ksf> Orclev, state, or just arguments?
00:55:07 <ray> backwards kleisli rocketship
00:55:14 <jethr0> lol
00:55:18 <ksf> if it's the latter, you can use the Reader Monad, if it's the former, there's a state monad at your disposal.
00:55:39 <Orclev> ksf: little of both... some pointers, a handle, couple "magic values"
00:55:48 <Orclev> plus good old arguments
00:55:51 <jethr0> how do you give 3 args to an infix/mixfix function (>=>)?
00:56:04 <jethr0> IO i guess, then
00:56:15 <ksf> ...well, it's good practice to combine both monads, and use reader for stuff that won't change during the computation.
00:56:27 <ray> jethr0: it's just a function
00:56:52 <ray> it may be clearer if you add some parentheses to the type signature
00:57:05 <ray> so it reads (a -> m b) -> (b -> m c) -> (a -> m c)
00:57:12 <ksf> http://www.haskell.org/all_about_monads/html/index.html is a good monad-specific reference.
00:57:16 <Orclev> my biggest problem with haskell right now is I'm still trying to wrap my head around monads
00:57:28 <Orclev> ksf: I'll check that out
00:57:44 <ksf> you already understand monads, you just didn't realise it yet.
00:58:11 <ray> also, you already understand monads, you just don't have an intuition for their applications
00:58:29 <jethr0> Orclev: that happens eventually. and every user writes a tutorial about their experience. hence the wide variety ^_^
00:58:35 <Orclev> lol
00:58:39 <ksf> ...the hard part is to accept that haskell is powerful enough to abstact the pattern they represent.
00:58:45 <ray> monads are like monad tutorials
00:58:52 <jethr0> i'm looking forward to your tutorials funny metaphors
00:59:19 <Orclev> ok, I'm going to start with... monads are like peanut butter... I'll work out the details of the metaphor later
00:59:22 <jethr0> spacemen, containers, functions, ...
00:59:25 <ray> >>= takes a brain and a ridiculous metaphor about monads and returns a mangled brain
00:59:29 <ksf> ...burritos.
00:59:33 <Twey> Hahaha
00:59:43 <jethr0> monads are like peanut butter: they tend to stick to everything they touch ;)
00:59:52 <Orclev> .... ouch
01:00:04 <ksf> monads are monoids in the category of endofunctors.
01:00:28 <ksf> ...which is the only correct definition, but also the least helpful one
01:00:31 <ray> monads are monoid objects in *a* category of endofunctors
01:00:34 <ksf> (except for utter nerds)
01:00:40 <jethr0> but in some monads you can define a function "getPeanutButterOff :: m x -> x"
01:00:51 <Orclev> lol
01:01:10 <Peaker> Orclev: Computations that have "effects" can be seen as an interlacing of "effect(with result) -> computation -> effect -> computation -> ...", right?
01:02:05 <ray> "m b" in type signatures is shorthand for mangled brain
01:02:29 <Peaker> Orclev: Something of type (m a) where m is some Monad, is basically an "effect" or a chain of effects and computations.  (>>=) lets you connect such chains/effects together with computations
01:02:29 <ksf> I thought we once decided that there are no effects because there's no mutable state because the universe is a fixpoint?
01:02:29 <Orclev> is there a easy way to extract a value from a Maybe monad? I've been using pattern matching to do it, but I've got a feeling that's a horrible thing to be doing... also need to read up on exception handling in haskell
01:02:40 <ray> no, pattern matching is a good way to do it
01:02:42 <Peaker> Orclev: it takes  (m a) which is an effect or chain of effects/computations with a result of a.  And a computation (a -> m b)  and chains them together, resulting in a chain within an "m b"
01:02:44 <ray> a horrible way is fromJust
01:02:53 <Peaker> Orclev: just call it a "Maybe type", not a "Maybe Monad".
01:02:54 <ray> an alternative good way is maybe
01:02:58 <ksf> the other is "maybe"
01:03:00 <ksf> :t maybe
01:03:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:03:05 <Peaker> Orclev: the fact "Maybe" is a Monad has little to do with how you get its values out of it
01:03:33 <ksf> > maybe "hey" id (Just "there")
01:03:34 <lambdabot>   "there"
01:03:39 <ksf> > maybe "hey" id Nothing
01:03:40 <Peaker> Orclev: the foundational way to look at Maybe's contents is to use pattern matching.   case myMaybeValue of Nothing -> ....   ; Just x -> ....
01:03:40 <lambdabot>   "hey"
01:04:00 <Orclev> Peaker: yeah, that's more or less what I've been doing
01:04:03 <Peaker> Orclev: "maybe" is a shortcut to such pattern matching, allowing you to give the pattern cases as arguments
01:04:19 <ksf> @src maybe
01:04:19 <lambdabot> maybe n _ Nothing  = n
01:04:19 <lambdabot> maybe _ f (Just x) = f x
01:04:36 <Peaker> Orclev: instead of       case someMaybe of Nothing -> nothingCase ; Just y -> justCase y        you can use:  maybe nothingCase justCase someMaybe
01:04:44 <ray> fromJust is the only bad way to get something out of a Just
01:04:59 <ksf> > fromJust Nothing
01:05:01 <lambdabot>   * Exception: Maybe.fromJust: Nothing
01:05:03 <Orclev> :t fromJust
01:05:04 <lambdabot> forall a. Maybe a -> a
01:05:07 <Twey> And then there's fromMaybe, for when you want to perform a final transformation on the value
01:05:20 <ray> unless you really do want your program to explode if there's a Nothing
01:05:25 <Peaker> I prefer using   fromMaybe (error "Why I think Nothing should not have occurred here")    over "fromJust"
01:05:30 <ksf> nontotal functions are generally evil.
01:05:30 <Orclev> well, yeah, I kind of do in this case
01:05:37 <Twey> Concur
01:06:01 <Peaker> I think with a bit of refactoring -- you don't end up with Maybe's that you know for sure are "Justs"
01:06:21 <Twey> Peaker: Unless some library function provides them
01:06:21 <Orclev> right now I'm trying to bash together a proof of concept program that eventually is going to be rewritten as a library and a program using it
01:06:24 <Peaker> (you can usually get the point in the code that proves the Maybe is not Nothing to just extract the value at that point)
01:06:32 <Peaker> Twey: refactor the library :)
01:06:37 * Twey chuckles.
01:06:54 <Twey> Well, it might not be true for every case, just true for yours
01:07:09 <ksf> .
01:07:11 <ksf> oh.
01:07:18 <Twey> Like Nothing representing FileNotFound for a file you created just the line above (and checked for successful creation)
01:07:32 <ksf> another evil thing is head.
01:07:34 <Orclev> so for now, I really don't care if it explodes horribly when given unusual input as I'm just trying to get it to work at all
01:07:39 <Twey> ksf: Safe library FTW.
01:07:39 <ksf> avoid it like the plague.
01:07:46 <Orclev> why head?
01:07:49 <ray> nontotal head is somewhat evil
01:07:51 <ray> > head []
01:07:51 <Peaker> Twey: yeah, you can't refactor libc.  I agree there are some cases where you can't refactor it out
01:07:52 <lambdabot>   * Exception: Prelude.head: empty list
01:07:52 <Orclev> *cough*
01:07:52 <ksf> ...pattern matching or take 1
01:07:54 <Twey> Orclev: Because it explodes on an empty list.
01:07:58 <ksf> > take 1 []
01:08:00 <lambdabot>   []
01:08:03 <Orclev> oh, didn't know that
01:08:03 <ksf> > take 1 [1,2]
01:08:04 <lambdabot>   [1]
01:08:08 <Peaker> Twey: though still,   fromMaybe (error "A file has disappeared immediately after being created!")   is nice than fromJust
01:08:24 <Twey> Peaker: Oh, true
01:08:37 <Twey> It's just not necessarily possible to avoid the extraction completely
01:08:37 <ksf> Peaker, assert (isJust foo) foo
01:08:45 <etpace_> How can I see the source of certain functions for a certain class?
01:08:50 <ksf> :t assert
01:08:51 <lambdabot> Not in scope: `assert'
01:08:54 <ksf> grr
01:08:55 <Peaker> data [] a = [] | (:) { head :: a ; tail :: [] a }
01:08:58 <etpace_> @hoogle fmap (State s)
01:08:59 <lambdabot> Did you mean: :: fmap (State s fmap) /count=20
01:08:59 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
01:08:59 <lambdabot> Control.Applicative empty :: Alternative f => f a
01:09:04 <Twey> fromJust $ assert (isJust foo) foo?
01:09:10 <Warrigal> Does Haskell actually have an empty type already defined?
01:09:15 <Peaker> ksf: why?
01:09:22 <Twey> Warrigal: Haskell doesn't, but GHC does
01:09:22 <Peaker> ksf: where's the explanation?
01:09:22 <ksf> assert gives you the line number.
01:09:29 <Twey> Warrigal: It's called Void
01:09:29 <Orclev> so, since I couldn't find it, I'm working on a library to interface with the skype API... mostly because I got bored
01:09:30 <ksf> it's an ghc hack, but it works.
01:09:34 <Warrigal> @index Void
01:09:34 <lambdabot> bzzt
01:09:41 <Twey> Yeah, empty types aren't valid in H98
01:09:48 <ray> warrigal: if you turn on the EmptyDataDecls extension, you can get one
01:09:49 <ksf> ...we should just have a $(linenumber) TH function.
01:09:51 <Peaker> Twey: not even: newtype Void = Void Void  ?
01:10:07 <ray> Void should be standard
01:10:16 <Twey> Peaker: That's not empty, it's recursive
01:10:18 <Warrigal> newtype Void = Void Void isn't nearly as populated as I thought at first.
01:10:26 <Peaker> Twey: What values does it have?
01:10:37 <ray> that's a crazy trick though
01:10:41 <ksf> every newtype can be bottom.
01:10:45 <Warrigal> Or is it? I can't actually think whether fix Void would work.
01:10:50 <Peaker> ksf: every type has bottom in general, yeah
01:10:52 <ksf> everything can be bottom in haskell, currently.
01:10:52 <Cale> Well, it has  x = Void x
01:11:02 <Twey> Bottom, Void Bottom, Void (Void Bottom), Void (Void (Void Bottom))â€¦
01:11:10 <Peaker> Warrigal: all types are inhabited by bottom in Haskell. There's no truly empty type
01:11:19 <Cale> Except that it's the same as _|_
01:11:32 <Warrigal> If you defined newtype Void = Void Void, then could you evaluate seq (let Void x = fix Void in x) 3?
01:11:36 <Cale> Since newtypes are unlifted
01:11:40 <ksf> the ghc guys are thinknig about introducing uninhabited types along with properly types kind.
01:11:43 <ksf> *kinds
01:11:53 <Peaker> Twey: interesting point, but newtype makes sure they're all equivalent, I believe
01:11:57 <Twey> ksf: Completely uninhabited?
01:12:03 <ray> scary
01:12:08 <ksf> data kind Foo = Bar | Baz would introduce a kind Foo and two types Bar and Baz, completely uninhabited
01:12:13 <Cale> data Void = Void Void  however would have those all be different
01:12:25 <ray> actually i like that
01:12:28 <ksf> ...you won't be able to use them in type sigs, of course, as functions can't take uninhabited things as arguments.
01:12:30 <Twey> Peaker: Hmm, I don't think so (at least in code)
01:12:34 <Peaker> ksf: for HList like hackery?
01:12:51 <Warrigal> ksf: they wouldn't really be types, would they? Types have to have kind *, and those have kind Foo.
01:12:59 <ksf> Peaker, well, currently type-level programming is completely untyped.
01:13:03 <Peaker> Twey: the code may look different, but they all denote the same value
01:13:13 <Peaker> ksf: that sounds funny :)
01:13:16 <ray> types don't have to have kind *
01:13:19 <ray> types with values in them do
01:13:25 <ksf> Warrigal, the point is that you can say type family Frob a :: Foo
01:13:43 <Twey> newtype Foo = Term x | Rec Foo deriving Ord; Term 3 /= Rec (Term 3)
01:13:45 <Warrigal> Is "type family" a new keyphrase?
01:13:49 <ksf> uh that won't work, that's an arity mismatch.
01:13:50 <Twey> Oh, not a valid newtype
01:13:51 <Twey> Heh
01:14:05 <Twey> Are those really equivalent?  That's kind of counterintuitive.
01:14:11 <ksf> Warrigal, http://www.haskell.org/haskellwiki/GHC/Type_families
01:14:28 <ksf> or, even better, http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
01:14:41 <Peaker> in Dependent Types, when (=) is defined as:  (s :: S, t :: T) => data s = t where refl :: s = s     why can't I create refl "proving" the equality of "s" with any "t" at all, since t does not appear in the type of refl?
01:15:22 <Warrigal> Maybe I'll just muse about a language in which * :: *.
01:16:11 <Warrigal> And, you know, in which data, types, and kinds aren't all separate scopes.
01:17:06 <ksf> ...no, the ghc guys don't even plan on implementing sorts, much less a proper tower or crossing the :: from value to type level.
01:19:19 <mux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8989#a8989
01:19:30 <mux> would you guys have coded this differently?
01:19:30 <Warrigal> They probably will never do that.
01:20:35 <Peaker> Warrigal: * :: T   and T :: T       is nicer than * :: *  I think
01:20:51 <Peaker> Warrigal: dependent types try to do that, no?
01:21:04 <ksf> isn't that (zipWith (++) (inits foo) (tails foo)?
01:21:12 <jethr0> mux: maybe you could adapt this solution to your needs:
01:21:23 <jethr0> > filterM (return [True, False]) [1,2,3]
01:21:24 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
01:22:00 <mux> ksf: nope
01:22:15 <Warrigal> Peaker: if you think that a capital T looks nicer than an asterisk, good for you.
01:22:19 <jethr0> you could substitute filterM with some function splitM that doesn't leave out, but rather assigns to left or right
01:22:21 <mux> jethr0: I know of this definition of the powerset, but it doesn't really help to implement my splits function
01:22:23 <ksf> > (\foo (zipWith (++) (inits foo) (tails foo) [1,2,3]
01:22:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:22:30 <ksf> > (\foo (zipWith (++) (inits foo) (tails foo))) [1,2,3]
01:22:31 <lambdabot>   <no location info>: Parse error in pattern
01:22:34 <Peaker> Warrigal: its not about * vs T, its about not having the type of values be the same as the type of types
01:22:37 <ksf> > (\foo -> (zipWith (++) (inits foo) (tails foo))) [1,2,3]
01:22:38 <lambdabot>   Ambiguous occurrence `++'
01:22:38 <lambdabot>  It could refer to either `GHC.Base.++', imported...
01:22:42 <ksf> @undef
01:22:44 <ksf> > (\foo -> (zipWith (++) (inits foo) (tails foo))) [1,2,3]
01:22:45 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
01:22:51 <ksf> err yes.
01:22:53 <Warrigal> And yeah, dependent types do mix types and values quite promiscuously.
01:22:55 <ksf> > (\foo -> (zipWith (,) (inits foo) (tails foo))) [1,2,3]
01:22:56 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
01:23:00 <Peaker> Warrigal: value :: * :: T :: T :: ...        rather than value :: * :: * :: * ...       its slightly different semantically
01:23:23 <Warrigal> Peaker: I know of no convention by which 3 :: *.
01:23:44 <mux> ksf: this is still different
01:24:01 <Warrigal> I would say value :: type :: * :: * :: ...
01:24:16 <mux> splits [1..3] returns [([3,2,1],[]),([2,1],[3]),([3,1],[2]),([1],[3,2])]
01:24:19 <Peaker> Warrigal: oops, I did indeed forget the "type" in that chain
01:24:37 <ksf> but you can't split [1..3] and get [3,2,1]
01:24:38 <bsdemon> Why I can't use this simple funciton in guards:
01:24:39 <Warrigal> So what did you mean to say?
01:24:40 <bsdemon> is_dict(Data) -> is_tuple(Data) andalso element(1, Data) == dict.
01:24:44 <Peaker> Warrigal: I think * should be the kind of types that have values
01:24:48 <bsdemon> sorry, it is for #erlang channel
01:24:48 <quicksilver> rather than "not having the type of values be the same as the type of types" I think you meant "not having the sort of value-types the same as the sort of type-types"
01:25:04 <Peaker> quicksilver: yeah
01:25:16 <Peaker> Warrigal: And not the kind of types that have types
01:25:27 <Warrigal> Peaker: so value :: type :: * :: T :: T :: ...?
01:25:31 <ksf> so, either your function is wrong, or misnamed. therefore, my function is right. Q.E.D.
01:25:33 <Peaker> Warrigal: yeah
01:25:38 <mux> mmm, I should call this function partitions
01:26:05 <Peaker> Warrigal: I'm not entirely sure about it though. I think someone who has implemented a DT language would have a better formed opinion :)
01:26:20 <Peaker> or at least used one extensively
01:26:39 <Warrigal> Well, that would mean the things that can go on the RHS of :: could be typed either * or T.
01:27:33 <mux> I guess I'm satisfied with this code now :-)
01:28:06 <Warrigal> That doesn't seem useful to me.
01:28:15 <Warrigal> Then again, I'm not in this for the utility.
01:28:22 <Peaker> Warrigal: they can be simple types, or * in your case too, right?
01:29:14 <jethr0> it's not exactly beautiful, but it works ;)
01:29:15 <jethr0> > let splitM _ [] = return ([],[]); splitM p (x:xs)= do {flg <- p x; (l,r) <- splitM p xs; return (if flg then (x:l,r) else (l,x:r))} in splitM (return [True,False]) [1,2,3]
01:29:16 <lambdabot>   [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3]),([2,3],[1]),([2],[1,3]),(...
01:29:40 <ksf> > let f xs = zipWith (,) $ (take (length xs) $ inits $ cycle xs) (take (length xs) $ tails $ cycle xs)  in f [1,2,3]
01:29:41 <lambdabot>   Couldn't match expected type `t -> [a]'
01:29:44 <Warrigal> I wonder what is the most well-explored area of math that has never been put to any practical use.
01:29:54 <mux> jethr0: mmm, I like my definition much better; it's shorter, and you have duplicate pairs of sublists
01:30:01 <jethr0> define "use"...
01:30:01 <ksf> > let f xs = zipWith (,) (take (length xs) $ inits $ cycle xs) (take (length xs) $ tails $ cycle xs)  in f [1,2,3]
01:30:03 <lambdabot>   [([],[1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
01:30:32 <ksf> > let f xs = zipWith (,) (map (take (length xs)) $ inits $ cycle xs) (map (take (length xs)) $ tails $ cycle xs)  in f [1,2,3]
01:30:34 <lambdabot>   [([],[1,2,3]),([1],[2,3,1]),([1,2],[3,1,2]),([1,2,3],[1,2,3]),([1,2,3],[2,3...
01:30:36 <jethr0> mux: i kinda agree (even though i really liked ksf's solution). just trying to get it to work
01:30:48 <ksf> close.
01:30:50 <jethr0> ksf's first solution ^_^
01:30:52 <ksf> ...but you get the idea.
01:30:57 <mux> ksf's solution doesn't do the same unfortunately :-)
01:31:03 <mux> I don't think you can implement that function this way
01:31:31 <jethr0> ah
01:31:32 <ksf> > let f xs = take (length xs) $ zipWith (,) (map (take (length xs)) $ inits $ cycle xs) (map (take (length xs)) $ tails $ cycle xs)  in f [1,2,3]
01:31:33 <lambdabot>   [([],[1,2,3]),([1],[2,3,1]),([1,2],[3,1,2])]
01:31:49 * ksf is to lazy to generalize that drop now.
01:31:51 <mux> getting closer :-P
01:34:01 <ksf> > permutations [1..3]
01:34:02 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
01:34:07 <mux> @let partitions xs = let select (ts,fs) (x,b) = if b then (x:ts,fs) else (ts,x:fs) in map (foldl select ([],[]) . zip xs . (True:)) $ replicateM (length xs - 1) [True,False]
01:34:09 <lambdabot>  Defined.
01:34:17 <mux> > partitions [1..4]
01:34:19 <lambdabot>   [([4,3,2,1],[]),([3,2,1],[4]),([4,2,1],[3]),([2,1],[4,3]),([4,3,1],[2]),([3...
01:34:28 <mux> > partitions [1..3]
01:34:30 <lambdabot>   [([3,2,1],[]),([2,1],[3]),([3,1],[2]),([1],[3,2])]
01:35:03 <ksf> > let f xs =  (zipWith (,) (inits xs) (tails xs))) in map f $ permutations [1,2,3]
01:35:04 <lambdabot>   <no location info>: parse error on input `)'
01:35:08 <ksf> > let f xs =  (zipWith (,) (inits xs) (tails xs)) in map f $ permutations [1,2,3]
01:35:10 <lambdabot>   [[([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])],[([],[2,1,3]),([2],[1,...
01:35:27 <jethr0> > let f ls = map (\x -> (x, filter (not . (`elem` x)) ls)) . filterM (return [True, False]) $ ls in f [1,2,3]
01:35:28 <lambdabot>   [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3]),([2,3],[1]),([2],[1,3]),(...
01:35:30 <Peaker> :t foldr (.) id
01:35:31 <lambdabot> forall a. [a -> a] -> a -> a
01:35:41 <Peaker> does this function exist?
01:35:52 <ksf> ...well it's the same, modulo duplicates.
01:36:21 <mux> ksf: yeah but you have a hell lot of duplicates here
01:36:22 <quicksilver> Peaker: yes, it exists. You just proved that ;) It doesn't have a single name though
01:36:35 <ksf> > let f xs =  (zipWith (,) (inits xs) (tails xs)) in length $ map f $ permutations [1,2,3]
01:36:36 <lambdabot>   6
01:36:40 <ksf> not at all.
01:36:41 <jethr0> @djinn forall a. [a -> a] -> a -> a
01:36:42 <lambdabot> Error: Undefined type []
01:36:53 <jethr0> @djinn [a -> a] -> a -> a
01:36:54 <lambdabot> Error: Undefined type []
01:36:59 <ksf> n-1, to be precise.
01:37:09 <Warrigal> @djinn Maybe (a -> a) -> a -> a
01:37:09 <lambdabot> f a =
01:37:09 <lambdabot>     case a of
01:37:09 <lambdabot>     Nothing -> \ b -> b
01:37:09 <lambdabot>     Just c -> c
01:37:10 <ksf> ...and they're at calculatable positions.
01:37:20 <ksf> so dropping them is O(n)
01:37:20 <mux> > let f xs =  (zipWith (,) (inits xs) (tails xs)) in length $ map f $ permutations [1,2,3,4]
01:37:21 <lambdabot>   24
01:37:32 <Warrigal> djinn likes verbose proofs.
01:37:33 <mux> > length (partitions [1..4])
01:37:34 <ray> quicksilver: modulo one Endo wrapper, it's mconcat
01:37:34 <lambdabot>   8
01:37:35 <pantsd_pcf> Is there a way to keep show from putting ""s around the string it is showing?
01:37:41 <mux> ksf: you do have a lot of duplicates
01:37:54 <Peaker> > map (($ ([], [])) . applys) . mapM (\x -> [putInFirst x, putInSecond x]) $ [1..3]
01:37:55 <lambdabot>   Not in scope: `applys'Not in scope: `putInFirst'Not in scope: `putInSecond'
01:38:02 <Warrigal> @src show
01:38:03 <lambdabot> show x = shows x ""
01:38:05 <mux> you return three times too much elements for sets of cardinality 4
01:38:12 <Warrigal> @src shows
01:38:12 <lambdabot> Source not found. Wrong!  You cheating scum!
01:38:19 <Peaker> > let putInFirst x = first (x:) ; putInSecond x = second (x:) ; applys = foldr (.) id in map (($ ([], [])) . applys) . mapM (\x -> [putInFirst x, putInSecond x]) $ [1..3]
01:38:20 <lambdabot>   [([1,2,3],[]),([1,2],[3]),([1,3],[2]),([1],[2,3]),([2,3],[1]),([2],[1,3]),(...
01:38:20 <Warrigal> @src String shows
01:38:20 <lambdabot> Source not found. You type like i drive.
01:38:24 <Warrigal> Mrf.
01:38:26 <Peaker> mux: this?
01:38:27 <ksf> 1 is prime, 2 is a special case, 3 is prime, 5 is prime, 7 is prime, therefore, all odd numbers and two are prime.
01:39:03 <mux> Peaker: not quite, apparently
01:39:15 <Warrigal> Of course, this is under the archaic definition of "prime", under which all integers are prime, except for 2, which is prime by definition.
01:39:30 <Peaker> mux: which of the items don't you want?
01:39:41 <quicksilver> ray: quite so.
01:39:54 <mux> Peaker: I want unique pairs, as in I don't want (a,b) and (b,a)
01:40:08 <mux> which is why my code passes length xs - 1 to replicateM
01:40:22 <mux> and then cons'es a True on top of all lists of booleans
01:40:48 <mux> that gives me all the 2^(n - 1) pairs I'm interested in
01:41:00 <mux> all the unordered partitions of the input list
01:41:26 <ray> gah, stupid mconcat and msum should really have their names flipped
01:41:28 <ksf> ...the cycle.
01:41:48 <Peaker> ray: why? concat<->append.   sum<->plus
01:42:00 * ksf doesn't want msum to be foldr mappend mzero.
01:42:03 <ray> mconcat generalizes sum and msum generalizes concat
01:42:36 <Peaker> > mconcat [[1,2],[3,4]]
01:42:37 <lambdabot>   [1,2,3,4]
01:42:39 <Peaker> > msum [[1,2],[3,4]]
01:42:40 <lambdabot>   [1,2,3,4]
01:42:47 <Peaker> ray: mconcat generalizes sum?
01:42:54 <ray> arguably, all the names in those classes are wrong
01:42:58 <ray> :t mconcat
01:42:59 <lambdabot> forall a. (Monoid a) => [a] -> a
01:43:14 <mux> > mconcat (map Sum [1..4])
01:43:15 <lambdabot>   Sum {getSum = 10}
01:43:33 <ray> :t msum
01:43:34 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
01:43:59 <mux> yes, mconcat generalizes sum
01:44:01 <mmorrow> instance (MonadPlus m) => Monoid (m a) where mempty = mzero; mappend = mplus
01:44:16 <ray> that's just confusing things more mmorrow :)
01:44:20 <mmorrow> :)
01:44:41 <ray> without fail, i mix up mconcat and msum every time
01:44:54 <Peaker> mux: the fact Sum is a Monoid doesn't mean Monoids generalize sums
01:45:04 <ray> when i typed that line above, i typed msum, then paused for a minute to check hoogle
01:45:08 <ray> i have done this many times
01:45:38 <mux> Peaker: mconcat generalizes folding a list with a monoidal operation
01:46:05 <mux> sum is a specific mconcat for the (Z,+) monoid
01:46:11 <mux> so mconcat is a generalization of sum
01:46:12 <mmorrow> Peaker: anything that you can sum is a monoid
01:46:55 <jml> surely concatenation is the archetypical monoid operation
01:47:14 <ray> i bet msum was named first, as "monad sum"
01:47:22 <mmorrow> haskell just can't do instance Monoid Int where mempty = 0; mappend = (+); ...  instance Monoid Int where mempty = 1; mappend = (*); due to annoying reasons
01:47:22 <ray> and that's how the mess began
01:48:14 <mmorrow> well it can do either of those, but once you try to do both everything goes to hell
01:48:30 <ray> so you need wrappers, same with Any and All
01:48:31 <Peaker> I think MonadPlus should have been an empty class: class (Monad m, Monoid (m a)) => MonadPlus m    (for the laws).  That would free up mzero/msum to be used by Monoid
01:48:45 * mmorrow thinks wrappers are an abomination :)
01:49:04 <Peaker> mmorrow: newtype wrappers for instances?
01:49:10 <mmorrow> yes
01:49:13 <Peaker> mmorrow: why?
01:49:17 <Peaker> I like them :)
01:49:20 <ray> wrappers are icky, it's true
01:49:25 <FunctorSalad> jml: quite literally...
01:49:43 <quicksilver> Peaker: you know that's not possible?
01:49:48 <ray> they let you get this stuff done in haskell, but they aren't pretty doing it
01:50:00 <quicksilver> Peaker: you need a nested forall a in the context
01:50:04 <ray> i'm pretty sure monadplus was written first and took all the good names
01:50:04 <quicksilver> it's like a second-order context
01:50:19 <Peaker> quicksilver: I know. I should have suffixed with "If Haskell's type system was strong enough"
01:50:23 <quicksilver> (Monad m, (forall a . Monoid (m a))) => MonadPlus m
01:51:00 <Peaker> ray: I think types are good for representation and newtype wrappers are good for assigning nice semantics to those representations
01:51:02 <jml> well, the other solution is to get better namespacing.
01:51:14 <jml> another solution, I should say
01:51:42 <quicksilver> namespacing instances would be a problem, not a solution
01:51:48 <ray> newtype wrappers for instances are just about confusing the type system so you can pull one over on it :)
01:52:16 <ray> i can't think of anything better, but i never found them pretty
01:52:27 <Peaker> naming instances is exactly what I see newtypes as doing
01:52:39 <jml> quicksilver, why?
01:53:09 <jml> (I have a pretty shallow understanding of the problem)
01:53:26 <mmorrow> whoever says haskell doesn't have global vars isn't considering instances... ;)
01:53:47 <Peaker> Maybe we need another indirection. A type-class defines methods and laws.  Something in between types and classes associates names with the methods.  Instances are of that in-between something. That way we can have as many Monoid instances as we want for a type, without duplicating the laws/methods
01:55:03 <doserj> for making namespacing instances work, the instances would have to be attached to values, not only to types, which is exactly what newtype wrappers do.
01:55:40 <FunctorSalad> mmorrow: haskell obviously has immutable globals... do you have some trick to mutate instances or? ;)
01:56:05 <dolio> First-class modules or dependent records (that you can open like modules) are a better solution for things like Monoid.
01:56:14 <quicksilver> jml: because the globality of instances is a fairly basic assumption
01:56:21 <dolio> If you had both, you could use modules for what they're fore, and type classes for what they're for.
01:56:23 <Peaker> dolio: so you choose explicitly the instances?
01:56:26 <dolio> For.
01:56:35 <quicksilver> jml: it's used to guarantee invariants (consider, Ord for Data.Map, or Typeable for Dynamic, or Binary for Binary)
01:56:38 <mmorrow> dolio: totally
01:57:02 <dolio> They'd have names.
01:57:06 <quicksilver> jml: any solution which gives instances either lexical or dynamic scope means we can no longer use the class system for this kind of invariant, we'd need something else.
01:57:13 <Peaker> dolio: I think type-classes would still be somewhat insufficient. If you had re-done Num properly, probably (+) and (*) could be two "instances" (not quite the right word here) of Monoids, but you wouldn't want to duplicate the definitions and the laws
01:57:44 <jml> quicksilver, ahh, I see.
01:57:54 <dolio> record Monoid a where { (++) :: a -> a -> a ; laws-go-here-since-we-have-fancy-dependent-types }
01:58:04 <dolio> Oh, there should be "zero" there, too.
01:58:21 <Peaker> dolio: and how do you use this for both addition and multiplication on numbers?
01:58:41 <FunctorSalad> the ssreflect guys wrote a whole paper on how dependent record for algebraic structures get complicated fast soon after monoids ;)
01:58:43 <Peaker> dolio: I don't mean explicitly, I mean replacing Num with something better
01:59:15 <dolio> foo :: Monoid a -> a ; foo mon = zero ++ zero ++ zero where open Monoid mon
01:59:17 <Peaker> where's the best place to ask about dependent types, btw?
01:59:29 <FunctorSalad> link http://hal.inria.fr/docs/00/40/16/97/PDF/main.pdf
01:59:34 <mmorrow> i was thinking yesterday about haskell's module system and typeclasses and a way (a different language) might do things..: so haskell modules and typeclasses exist at the levels of (ML) functors (are like functions), signatures (are like types), and structures (are like values). then, haskell modules provide namespacing *for this ML-like module system*, and typeclasses and instances operate *on signatures and functors*
01:59:41 <mmorrow> was my thought
01:59:43 <FunctorSalad> I don't even get it :(
01:59:48 <dolio> foo plusMonoid = 0, foo timesMonoid = 1.
02:01:12 <FunctorSalad> with dependent record there's the important choice of what to make parameters and what to make members...
02:01:28 <dolio> Yeah. That's difficult.
02:18:06 <hackagebot> tkhs 0.1.0.3 - Simple Presentation Utility (YusakuHashimoto)
02:30:16 <fasta> I use <> in Text.PrettyPrint.ANSI.Leijen and some basic functions to create Doc values. Now, why does it introduce new line characters in the output? I never told it to do that, AFAIK.
02:35:55 <fasta> The default page width is ridiculously low and there was some combinator which did not just put stuff next to each other, but had behaviour depending on the page width.
02:41:33 <ksf> ...that's the point of pretty printing.
02:41:53 <ksf> not only manage indentation, which is trivial, but also wrapping.
02:42:07 <ksf> err combinators, at least.
02:43:35 <ksf> iirc HughesPJ has a beside operator, but still can't be tuned not to wrap... you can just set the linewidth ridiciously high.
02:44:06 <ksf> ...or tell it not to do any newlines at all, which is quite of beside the point as it generates into show, then.
02:44:15 <ksf> *degenerates
02:48:40 <Athas> Is there a safe variant of 'read' that returns 'Maybe a' instead of throwing IO errors?
02:49:13 <dibblego> @type reads
02:49:14 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:49:36 <Peaker> there's that package named after the initials of its author
02:50:12 <Twey> safeRead s = case reads s of ((x, rest) : _) -> Just x; _ -> Nothing
02:50:25 <Twey> Ooh.
02:50:28 <Athas> Thanks.
02:50:30 <dmwit> My preferred implementation of that is
02:50:53 <dmwit> safeRead s = case filter (null . snd) (reads s) of ((x, _):_) -> Just x; _ -> Nothing
02:50:54 <Twey> safeRead = fmap fst . listToMaybe . reads
02:51:02 <Twey> Er
02:51:02 <dmwit> sure, even better
02:51:05 <Twey> safeRead = fmap fst listToMaybe . reads
02:51:08 <dancor> fmap fst . listToMaybe . reads
02:51:11 <Twey> Yeah
02:51:12 <dancor> was right
02:51:31 <dmwit> fmap fst . listToMaybe . filter (null . snd) . reads -- don't want any partial results, personally
02:51:44 <Twey> I prefer partial results
02:51:45 <dmwit> or
02:51:56 <Twey> If it's ambiguous, anything'll do, right?
02:52:12 <dmwit> \s -> listToMaybe [x | (x, "") <- reads s]
02:52:21 <dmwit> Twey: It's not ambiguity I'm worried about.
02:52:38 <dmwit> > reads "123this is what I'm worried about" :: [(Int, String)]
02:52:39 <lambdabot>   [(123,"this is what I'm worried about")]
02:52:50 <Twey> What's wrong with that?
02:52:51 <fasta> ksf: it does't degenerates into show, because it doesn't use ++.
02:53:07 <fasta> ksf: it's a more efficient version of ++ essentially.
02:53:09 <dmwit> Twey: It's a matter of taste.  I prefer to only deal with full reads.
02:53:15 <Twey> â€˜Be strict in what you send and lenient in what you receive.â€™
02:53:36 <dancor> trailing whitespace kills
02:53:48 <Twey> Yeah
02:53:51 <dmwit> "Be explicit about what you accept." -- dmwit
02:53:55 <Twey> Pedantic applications are annoying :Ã¾
02:54:23 <fasta> If the applications are right, they are not.
02:54:39 <fasta> The problem is that it is not always clear what is right and what is wrong.
02:54:41 <Twey> â€˜Please type yes or no.â€™ â€˜yâ€™ â€˜Please type yes or no.â€™ â€˜Please type yes or no.â€™ â€˜Yesâ€™ â€˜Please type yes or no.â€™ â€¦
02:54:54 <fasta> Twey: you can change that trivially.
02:54:57 <dancor> it should give you encouragement
02:55:04 <dancor> 'You were really close that time.'
02:55:06 <dmwit> Nothing is more annoying than trying to figure out why you're getting totally wrong answers when the problem is a small typo in your input that the application didn't complain about.
02:55:07 <Twey> fasta: Yeah, by being more lenient :Ã¾
02:55:11 <Twey> dancor: Hahaha
02:55:17 <fasta> Twey: no, I mean in Emacs.
02:55:28 <Twey> fasta: Oh, really?  How?
02:55:45 <fasta> Twey: (defalias 'yes-or-no-p 'y-or-n-p)
02:55:51 <Twey> Ah :Ã¾
02:55:53 <fasta> Twey: was that so hard? ;)
02:56:12 <Twey> Well, I wasn't taking about emacs specifically :Ã¾
02:56:16 <Twey> talking** argh.
02:56:45 <dancor> @vixen Please type yes or no.
02:56:45 <lambdabot> i didn't think so
02:58:43 <Twey> dancor: Hahaha
02:59:00 <Twey> fasta: Thanks for the tip, though â˜»
02:59:28 <jethr0> *omg*, i have just spent an entire day on a non-strict channel issue *face-palm*
02:59:40 <Twey> But you are wiser for it!
02:59:49 <Twey> (hopefully)
03:00:15 <dancor> no one ever said laziness was easy (tho it's probably implied in various haskell propagandata)
03:00:47 <Twey> Heh
03:00:59 <Twey> â€˜tho â€¦ propagandataâ€™
03:01:00 <Twey> Nice
03:01:07 <Botje> blame the english language for the connotation that lazy people have it easier :]
03:01:13 * Twey laughs.
03:01:50 * Cale considers it no harder than strictness...
03:01:53 <Twey> Dictionary: â€˜Propaganda is uncountable, you Philistine!â€™
03:02:38 <Twey> Cale: Depends if you're talking about mind work or finger work ;)
03:02:51 <Twey> Heh, advantage of C: burns more calories!
03:03:35 <Botje> calories are mostly _made_ out of C ;)
03:04:25 <Cale> Mind work... with strictness you have to put up with perfectly acceptable programs spuriously failing to work.
03:04:57 <Twey> Heheh.
03:05:15 <Peaker> Cale: With laziness you have to put up with perfectly acceptable programs leaking until you machine is dead :)
03:05:24 <Peaker> you need some sort of hybrid
03:05:30 <Cale> Well, yeah, there is that.
03:05:56 <Twey> Hehe
03:06:20 <jethr0> Cale: actually, lazy channels can cause problems other than leaking. at least if that is what i had.
03:06:38 <Cale> But at least in theory, if there is an evaluation order under which a program will terminate, then it will terminate under lazy evaluation.
03:07:03 <Cale> jethr0: What do you mean by 'lazy channels' here? Are you using getChanContents?
03:07:03 <jethr0> the channels seems to have been SOO lazy, that not even reading it on the other and forced the evaluation... please don't ask about details, i would have to start crying again...
03:07:13 <Peaker> Cale: what if you have _|_ && something  vs: something && _|_  ?
03:07:15 <FunctorSalad> Cale: with infinite space ;)
03:07:17 <doserj> with strictness, it is relatively easy to see whether a "perfectly acceptable program" works. with laziness, it may work more often, but is not that easy to see when it will work.
03:07:32 <jethr0> no, just Control.Concurrent.Channel.{read,write}Chan
03:07:39 <Peaker> Cale: there is an evaluation order that would work, but lazy evaluation might try _|_ && .. instead of the other
03:07:43 <Cale> doserj: why is that?
03:08:01 <Cale> Peaker: hm?
03:08:31 <FunctorSalad> Peaker: the def of (&&) is simpy such that there isn't an order such that _|_ && ... terminates
03:08:35 <doserj> Cale: because the operational behavior is easier to follow
03:08:35 <fasta> jethr0: can you tell us about the details? :P
03:08:42 <FunctorSalad> (it's not parallel or)
03:08:47 <Cale> Peaker: Oh, you're saying there's nothing to take care of information that operators may be commutative?
03:08:54 <Peaker> > let p = p in p && False
03:09:00 <lambdabot>   mueval-core: Prelude.read: no parse
03:09:00 <lambdabot>  mueval: ExitFailure 1
03:09:03 <Peaker> > let p = p in False && p
03:09:04 <lambdabot>   False
03:09:17 <jethr0> barely. i'm still so confused by the whole thing. i had locking behavior on non-locking calls and stuff like that. not sure how i can convey my issues
03:09:19 <Peaker> Cale: there is an evaluation order under which the above example would terminate, but laziness failed to find it
03:09:34 <jethr0> i could post code, but it's > 1500 LOC and it's not pretty atm.
03:09:36 <Cale> Peaker: There's no evaluation order under which _|_ && False will not be _|_
03:09:44 <Peaker> Cale: oh wait, I guess the pattern order doesn't count as "evaluation order" :)
03:10:17 <Cale> Peaker: There's a different definition of && for which it's not _|_, but that's a different definition.
03:10:36 <Peaker> the lub one?
03:10:50 <jethr0> fasta: basically though: i wrote to a channel, i read to a channel and never got back what i wrote in...
03:11:00 <jethr0> until i switched to Channel.Strict that is
03:11:01 <dolio> Merely pattern matching on the right works, too, but it fails if you provide bottom to the right.
03:12:33 <FunctorSalad> parallel or: http://hackage.haskell.org/packages/archive/unamb/0.2.2/doc/html/Data-Unamb.html#v%3Apor
03:16:27 <int-e> does hackage make the haddock interfaces (.haddock) available for its generated documentation?
03:16:30 <fasta> Is there a function somewhere which displays all the numbers before the dot and only two behind the decimal point and converts 0.0 to 0 and so on? That is something, which only shows the essential information of a double or float?
03:16:59 <dolio> @type showGFloat
03:17:00 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
03:17:12 <dolio> > showGFloat (Just 2) pi ""
03:17:14 <lambdabot>   "3.14"
03:17:30 <dolio> > showGFloat (Just 2) (pi * 1000) ""
03:17:31 <lambdabot>   "3141.59"
03:17:39 <dolio> > showGFloat (Just 2) (pi * 100000000) ""
03:17:41 <lambdabot>   "3.14e8"
03:17:51 <dolio> > showFFloat (Just 2) (pi * 100000000) ""
03:17:52 <lambdabot>   "314159265.36"
03:17:52 <ksf> jethr0, have you had a look at http://hackage.haskell.org/package/chp?
03:18:09 <dolio> > showFFloat (Just 2) 0 ""
03:18:10 <lambdabot>   "0.00"
03:18:55 <fasta> dolio: thanks, I always forget that function.
03:19:05 <dolio> I can never remember which is which.
03:19:29 <dolio> That doesn't solve the 0.0 problem, though, obviously.
03:19:47 <Twey> > showFFloat Nothing 0 ""
03:19:48 <lambdabot>   "0.0"
03:20:02 <Twey> Why is that parameter a Maybe?
03:20:15 <fasta> dolio: no, but that's quite specific.
03:21:13 <dolio> There's another one too...
03:21:25 <dolio> > showEFloat (Just 2) 0 ""
03:21:28 <lambdabot>   "0.00e0"
03:21:55 <Twey> Wait a minuteâ€¦
03:22:22 <Twey> Oh, right, yeah.
03:24:38 <Twey> Hey, awesome.
03:25:02 <Twey> CHP is my first â€˜hey, hang on, I've invented half a hackish version of this myselfâ€™ library
03:30:03 <jethr0> isn't STM supposed to minimize races?
03:30:15 <ksf> the barrier stuff is really interesting, what's worrying me a bit is that phased barriers seems to be a bit isomorphic to those server/client function signatures that are duals of each other like in http://hackage.haskell.org/packages/archive/Coroutine/0.1.0.0/doc/html/Control-Coroutine.html http://hackage.haskell.org/packages/archive/Coroutine/0.1.0.0/doc/html/Control-Coroutine.html
03:30:22 <Twey> jethr0: Only if you write it properly
03:30:30 <jethr0> hehe
03:31:07 <ksf> it's designed to stop you from shooting your own foot by abusing locks.
03:31:22 <Twey> Aye.
03:31:22 <ksf> ...or, actually, using and getting them wrong.
03:31:38 <Twey> But it's still possible to race/deadlock it, I think
03:31:40 <Twey> If you try hard
03:31:51 <ksf> sure it's possible.
03:32:04 <ksf> ...especially if you use chans.
03:34:46 <lvh> Hi! What's the recommended way of using Cabal in a way that won't annoy my pcakage manager? (I'm on Debian.)
03:34:59 <ksf> in your home directory.
03:35:15 <ksf> ...which is the default if you use the cabal executable.
03:35:16 <ehamberg> (which is the default)
03:36:24 <ksf> your binaries are going to end up in ~/.cabal/bin, so you've got to add it to your path, but then you should be set.
03:41:13 <lvh> Oh, cool.
03:41:18 <lvh> Thanks :-)
03:45:39 <lvh> Hm. I thought Cabal came with ghc? I have ghc installed (6.10.4) with the Debian package, but I can't find it. Is this normal? Am I supposed to install the cabal-install tarball manually?
03:45:55 <lvh> (I'd like to use the gps package from Hackage, which doesn't have a Debian package yet.)
03:46:39 <ksf> ghc comes with cabal, but only the library, not the executable
03:46:51 <ksf> ...which is in the package cabal-install.
03:47:05 <ksf> you can use runhaskell Setup.hs --user, though
03:47:26 <ksf> ...but that won't install dependencies automagically.
03:47:37 <lvh> ksf: Is that supposed to be a Debian package, or is that the tarball?
03:47:55 <lvh> apt-cache search cabal yields mostly ghc and haskell-devscripts - Tools to help Debian developers build Haskell packages
03:48:00 <ksf> I don't use debian, but I bet there's a package for cabal-install.
03:48:52 <lvh> Eep. http://haskell-unsafe.alioth.debian.org/archive/i386/unstable/h/haskell-cabal/
03:50:21 <ksf> huh. the current cabal-install version is 0.6.2, and the one of the cabal lib 1.6.0.3
03:51:21 <ksf> ...well, if in doubt, use the tarball.
03:51:42 <lvh> Yeah, I think I'll do that instead. Thanks ksf :-)
03:51:57 <doserj> cabal the library != cabal-install the program
03:53:14 <ksf> another option is to switch to a proper distribution, of course, like gentoo, or gentoo.
03:54:13 <lvh> ksf: no thanks :-)
03:55:04 <Martijn_> Morning
03:55:29 <ksf> morning? it's 1 am.
03:55:34 <ksf> ...even where you are.
03:56:26 <lvh> 1 PM
03:56:31 <lvh> surely
03:56:33 <ksf> yeah.
03:56:37 <ksf> well, 13:00
03:56:57 <ksf> continentals aren't required to get that am/pm thing right.
03:57:08 <lvh> im a continental!
03:57:17 <lvh> well, born in the US, but that doesnt count :-)
03:59:04 <Martijn_> Okay, good afternoon then :-)
03:59:32 <Martijn_> How do I turn off login/out messages in irssi?
04:00:00 <elbar> with /ignore
04:00:17 <etpace_> :t first
04:00:18 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
04:00:32 <opqdonut> Martijn_: something like /ignore #channel JOINS QUITS
04:01:17 <elbar> PARTS maybe too
04:01:27 <opqdonut> those too
04:01:43 <opqdonut> or something like ALL -PUBLIC -ACTIONS
04:04:45 <Martijn_> Thanks
04:06:40 <ksf> ahh spj.
04:06:59 <ksf> he actually uses words like "hitherto"
04:06:59 <lvh> ksf: what has he done this time? ;-)
04:07:33 <lvh> ksf: be thankful you're not writing scala code
04:07:35 <ksf> now I've got to locate a "thitherfrom"
04:08:21 <ksf> maybe I'm going to find an "alas", too.
04:08:47 <elbar> alas = at last?
04:08:59 <ksf> er no.
04:09:04 <ksf> @wc alas
04:09:04 <lambdabot> Maybe you meant: rc wn
04:09:09 <ksf> @wn alas
04:09:12 <lambdabot> *** "alas" wn "WordNet (r) 2.0"
04:09:12 <lambdabot> alas
04:09:12 <lambdabot>      adv : by bad luck; "unfortunately it rained all day"; "alas, I
04:09:12 <lambdabot>            cannot stay" [syn: {unfortunately}, {unluckily}, {regrettably}]
04:09:12 <lambdabot>            [ant: {fortunately}, {fortunately}]
04:09:35 <elbar> oh..
04:09:44 <Martijn_> In Dutch we have "helaas"
04:09:59 <lvh> but nobody actually says alas
04:10:00 <ksf> "I wanted to write 'class (Foo a) => Bar a', but, alas! That requires UndecidableInstances"
04:10:26 <lvh> but, alas! should be folloed by `my plans are foiled!`
04:10:57 <ksf> tolkien was very fond of it.
04:11:11 <ksf> ...or, rather, arathorn.
04:11:47 <ksf> gandalf too, /me thinks.
04:26:13 <Twey> ksf: Who doesn't?
05:22:08 <p_l> ksf: I think I used it in speech few times...
05:33:03 <pr> =+
05:40:26 <Peaker> quiet
06:25:35 <defun> I'm not really a hardware guy, but how do haskell's bytestrings compare with bitfields?
06:26:15 <Axman6> bitfields? is that like the bit syntax in erlang?
06:26:17 <Lemmih> What are bitfields?
06:26:23 <defun> one sec
06:26:28 <edwardk> defun: well, they align on byte boundaries for one ;)
06:26:45 <edwardk> assuming you meant the erlang one
06:26:54 <defun> http://en.wikipedia.org/wiki/Bitfield
06:26:57 <defun> I meant the kind found in C
06:27:22 <edwardk> a bytestring is a pointer to a buffer, and two integers indicating where it starts and ends in that buffer.
06:27:51 <edwardk> so they are more closely analogous to c -style char buffers with an extra couple of integer indexes.
06:28:03 <defun> I see. That makes sense
06:28:24 <defun> Now buffers. Those are just reserved memory?
06:28:51 <edwardk> a c/c++ style bitfield is a fairly poorly specified in memory representation of shift/offset bit masks. poorly specified because the endianness, and even if they get packed at all is platform specific.
06:28:56 <edwardk> yeah
06:31:40 <defun> I was reading parts of The C Prog Lang by Richie. I find pointer arithmatic to be ugliest, buggiest language feature. It is so much easier to understand haskell code because there is no distinction between equality and identity.
06:32:14 <defun> Now, I have an /even greater/ appreciation for what SPJ and the comitee for haskell have accomplished.
06:32:35 <Axman6> anyone remember the name of this function? f n x | n <= 1 = x | otherwise = if even n then f (n `div` 2) (x+1) else f (3*n+1) (x+1)
06:32:49 <edwardk> pointer arithmetic is pretty dangerous, but it is occasionally pretty convenient. i've occasionally pined for the ability to declare directly inline in my constructor a small array of chars for instance without having to point off to some ByteArray# or something like that
06:33:07 <Ferdirand> Axman6: collatz ?
06:33:14 * Axman6 googles
06:33:15 <arw_> defun: totally different context. c is a higher level common syntax for assembler languages.
06:33:16 <edwardk> Thats the Collatz conjecture
06:33:38 <ksf> heh. Footnote: "Here, "Miranda" is not the trade mark. It is the last name of a researcher at Queen Mary and Westfield College, London"
06:33:48 <arw_> defun: and pointer arithmetics is exactly what your cpu will do to pointers anyways.
06:33:52 <Axman6> yep, that's it, thanks Ferdirand and edwardk
06:34:32 <defun> I know, but haskell abstracts it making more suitable for high-level stuff. Whereas C is good for hardware-level programming.
06:34:48 <arw_> haskell could be just as useful there.
06:34:50 <ksf> c is darn good at pointer arithmetic.
06:34:59 <defun> arw: seriously?
06:35:11 <arw_> you would just need a (copy-free) way to map some structure to a fixed layout of bytes.
06:35:14 <edwardk> Axman6: i only remembered because i used it as an example on stack overflow: http://stackoverflow.com/questions/1111155/what-exactly-is-the-halting-problem/1111256#1111256
06:35:17 <ksf> ...you might hate pointer arithmetic, but if you want to do it, c is a _very_ good language to do it in.
06:35:17 <defun> arw: without binding to C?
06:35:30 <Peaker> you can already peek via ptrs?
06:35:32 <Axman6> edwardk: heh :)
06:35:32 <defun> ksf: I agree.
06:35:47 <defun> Peaker: eh?
06:36:15 <ksf> ...especially if you ever had to care about adressing modes in assembly languages, especially older ones.
06:36:24 <arw_> defun: the "low-level" stuff you do in c, especially most interfacing with hardware consists of the following: take a 'buffer' of type char* or void*.
06:36:33 <arw_> defun: cast it to struct whatever*
06:36:39 <arw_> defun: access the members.
06:37:36 <Peaker> defun: you can already "map some structure to a fixed layout of bytes", that was
06:37:45 <arw_> defun: its just some very fast and easy way to get some untyped bunch of bytes into a certain structure. and mostly its fast, because there is no copy operation involved.
06:37:48 <Peaker> that's what c2hs uses, I think
06:38:01 <defun> I see.
06:38:56 <ksf> c2hs generates plain and simple (\ptr -> pokeByteOff 123 ptr) for every {#get struct_foo->bar#}
06:39:52 <defun> Is it me, or is C's type system made intentionally to be weak? Is this truly beneficial? Sorry if I'm asking dumb questions, but I'm still very much in the haskell mindset...
06:39:58 <ksf> sometimes, I think that it'd be better to just memcpy the whole struct and treat it as a pure value.
06:40:00 <defun> Oh thanks for the explanation
06:40:12 <ksf> it's strong.
06:40:17 <ksf> ...compared to assembly, that is.
06:40:30 <defun> yeah... I meant compared to Haskell.
06:40:49 <ksf> it's also way more flexible than say lisps.
06:40:50 <dolio> C's a lot older than Haskell.
06:40:55 <ksf> (as you can actually define types)
06:41:26 <Jafet> Well, it came from B. We all know the legendary unity of the B type system.
06:41:27 <defun> I know, but I suppose it wouldn't hurt to rethink low-level bit-twidling languages a bit. No pun intended.
06:41:50 <dolio> That wouldn't be C anymore.
06:41:51 <edwardk> defun: its a tricky proposition because most nice language features want garbage collection
06:42:01 <defun> Ah.
06:42:20 <defun> Yes, I'm not used to thinking about the GC. Thanks for pointing it out.
06:42:22 <ksf> and c is going to stay what it is: a high-level assembler.
06:42:28 <edwardk> defun: that isn't to say a more consistent c-like language couldn't exist.
06:42:42 <dolio> Some already do.
06:42:54 <defun> dolio: You mean Cyclone?
06:43:04 <dolio> That's one.
06:43:10 <edwardk> cyclone has other overhead ;)
06:43:13 <dolio> People have worked on typed assembly language, too.
06:43:19 <dolio> And dependently typed assembly language.
06:43:23 <defun> dolio: sweet!
06:43:33 <defun> dolio: that would be nice.
06:43:40 <edwardk> TAL is pretty spiffy =)
06:43:46 <Jafet> C-like is becoming obsolescent
06:44:00 <defun> anyway, I'm late for class...
06:44:04 <defun> bye
06:44:10 <edwardk> I still program in c++ occasionally.
06:44:17 <ksf> my condolences.
06:44:22 <edwardk> occasionally in a very c-like subset of it ;)
06:44:24 <dolio> There's BitC.
06:44:30 <ksf> how can you stand the angle brackets?
06:44:33 <edwardk> dolio: might as well not be.
06:44:42 <edwardk> shapiro left to take a job at Microsoft, so its dead.
06:44:48 <dolio> Ah well.
06:45:09 <dolio> Lisaac probably has a more rigorous type system than C, too, if I had to guess.
06:45:14 <ksf> C isn't bad, anyway.
06:45:14 <dolio> Not that that's saying a lot.
06:45:25 <edwardk> ksf: i migrated to haskell _after_ having learned template meta-programming, so i was innoculated ;)
06:45:37 <ksf> grokking the whole of its semantics isn't that big of a task.
06:45:54 <Axman6> :t unlines
06:45:55 <lambdabot> [String] -> String
06:46:14 <ksf> ...learning how to use it best to get stuff done is an entirely different matter, of course.
06:46:20 <edwardk> If I could get over its 'MLness' I'd probably like ATS ;)
06:46:24 <ksf> but at least it's quite easy to know what you're doing.
06:47:08 <Jafet> ksf, it depends on which C
06:47:54 <ksf> let's say C99.
06:48:08 <ksf> ...or ansi.
06:48:24 <edwardk> I just wish c++ would get around to adopting some of the extra clarifications from C99.
06:48:29 <Peaker> dolio: BitC is fiction :)
06:48:33 <Peaker> dolio: I mean, nobody is working on it
06:48:38 <Jafet> Ok, tell me how you pass a pointer to a struct with a flexible array member as a function parameter
06:49:07 <Jafet> (I have no idea, either.)
06:49:18 <ksf> like any other pointer?
06:49:20 <edwardk> jafet: you just pass the pointer. ;)
06:49:31 <ksf> a flexible array member in a struct is just a pointer, too.
06:49:38 <edwardk> void foo(struct mycrazystruct * bar) { ... }
06:49:51 <ksf> as struct types have a fixed size, by definition.
06:50:16 <benmachine> void foo(void *cheating);
06:50:27 <Jafet> Oh, hur
06:50:33 <edwardk> ksf: not necessarily, the gcc convention of allowing [0] length arrays to be an unbounded buffer at the end of the struct allocated by you manually also holds
06:50:40 <Jafet> I was thinking VLAs
06:51:17 <ksf> well that trick should work with any compiler, /me thinks.
06:51:31 <ksf> ...but you'd still have sizeof reporting a fixed size.
06:51:33 <edwardk> technically its not in the c specification ;)
06:51:38 <edwardk> *nods*
06:52:15 <benmachine> what advantage does that have over a pointer and just mallocing
06:52:23 <benmachine> how do you allocate it manually anyway
06:52:32 <ksf> only one indirection.
06:52:32 <edwardk> benmachine: one fewer pointer dereferences
06:52:47 <ksf> malloc.
06:52:50 <edwardk> benmachine: and you can allocate the structure and the trailing buffer in one allocation
06:53:01 <benmachine> pointer dereferences are expensive now? ;/
06:53:03 <benmachine> er :/
06:53:14 <benmachine> edwardk: ah, I see what you mean
06:53:21 <ksf> they once were, and still are, if you get cache misses.
06:53:46 <edwardk> benmachine: they can cause pipeline stalls, they are typically looking at different pages of memory so you now have loss of cache line sharing, etc.
06:54:34 <edwardk> even GHC does this. every code pointer used by GHC is actually a pointer to code with a struct describing the tag glued before it in this very fashion.
06:54:46 <edwardk> it nets them about a 5% overall speed boost.
06:55:34 <edwardk> (even though the cache wins aren't the factor for code, because of i-cache vs. d-cache)
06:56:28 <int-e> 2nd level caches are usually unified, aren't they?
06:56:42 <arw_> the most important optimizations (if algorithmic optimizations are already done) are cache and memory layout.
06:57:03 <arw_> int-e: depends on the cpu, there are huge differences.
07:02:03 <edwardk> int-e: typically, so it helps, but you don't want to even go out that far if you can help it ;)
07:13:55 <mux> @pl \x y -> 2 * (x - y)
07:13:55 <lambdabot> ((2 *) .) . (-)
07:14:23 <Jafet> How pointless
07:15:13 <Jafet> @pl \f l -> l ++ map f l
07:15:13 <lambdabot> ap (++) . map
07:17:00 <Peaker> (result . result) (2*) (-)      is perhaps more readable
07:17:09 <Peaker> (apply (2*) on the result of the result of (-))
07:17:50 <sohum> foldl1 (.) (map XLam fs) $ expr
07:17:52 <int-e> > let step xs = xs ++ map succ xs in iterate step [1] !! 10
07:17:53 <lambdabot>   [1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,...
07:17:54 <sohum> where fs :: [Var], expr :: Exp, and XLam :: Var -> Exp -> Exp
07:18:05 <sohum> I love that haskell lets me do stuff like that
07:18:36 <Peaker> @type foldl1
07:18:37 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:18:40 * trez love you long time
07:18:51 <Peaker> sohum: I don't think you need the ($) there
07:19:47 <sohum> Peaker: I wasn't sure, but I thought it might try to apply expr as an argument to foldl1
07:20:23 <Peaker> sohum: functions have just 1 arg. in a sense, it is an arg to that foldl1 -- because the foldl1's "a" is itself a function
07:20:36 <edwardk> sohum: it is doing so, either way ;)
07:20:45 <sohum> Peaker, edwardk: aha, true
07:26:34 <etpace_> Are there any OCR tools for Haskell?
07:29:04 <Jafet> "for Haskell"?
07:30:05 <etpace_> hmm, any OCR tools that interface well with Haskell I guess
07:30:48 <Jafet> A shell pipe should do, I would think
07:31:00 <Jafet> Unless you're talking about libraries, not applications
07:31:09 <artagnon> I want to learn about how GHC works so that I can write better code: At the grassroots, everything is essentially imperative/ procedural. So how can I get the equivalent imperative version (like C code)?
07:32:41 <Jafet> Suppose you could get ghc to emit C code.
07:32:46 <sohum> you can
07:32:49 <koala_man> artagnon: you can compile a file with -C to get C code
07:32:58 <sohum> it's horrendously ugly and illegible, but you can
07:33:20 <koala_man> just like hand-written C code
07:33:27 <sohum> *snerk*
07:33:29 <Jafet> Also there is no the equivalent imperative version. There would be one of the many equivalent imperative versions
07:33:31 <koala_man> badum-zing
07:33:45 <quicksilver> it's not even C
07:33:53 <Botje> artagnon: you want to study the Core haskell generates.
07:33:54 <artagnon> koala_man: I tried that. It's hardly even readable.
07:33:56 <sohum> you'd do better trying to understand each step of the transformations it applies to get to the imperative result
07:34:06 <quicksilver> it's a custom language which GCC will accept to compile to somethign which isn't assembly language
07:34:09 <artagnon> Botje: Correct.
07:34:22 <quicksilver> which the evil mangler converts to real assembly.
07:34:27 <doserj> you'd do better not trying to understand the imperative result
07:34:28 <quicksilver> It's not called the evil mangler for no reason.
07:34:36 <Jafet> GNU C, then.
07:34:47 <Jafet> Wait, so ghc depends on gcc?
07:34:47 <sohum> I thought it was called evil because it was written in perl
07:34:50 <artagnon> Jafet: Right. I want to know the various equivalents.
07:35:04 <Jafet> I think ghc will only give you one, artagnon
07:35:05 <Botje> artagnon: it's actually called 'Core' :)
07:35:06 <artagnon> and what I should write to produce the best/ fastest imperative equivalent.
07:35:16 <Berengal> sohum, it's called evil because it is
07:35:19 <Jafet> (...why?)
07:35:19 <Botje> try ghc -ddump-simpl
07:35:32 <artagnon> doserj: Why?
07:35:38 <Jafet> If you want it faster, rewrite in ocaml, erlang, or whatever
07:35:43 <artagnon> Botje: Oh, one sec. Lemme try.
07:36:07 <artagnon> Jafet: Er, no. I want to understand what "faster" means.
07:36:17 <artagnon> I want to understand why a compiler produces faster/ slower code.
07:36:30 <artagnon> THAT is more fundamental than switching languages for speed.
07:36:59 <sohum> Berengal: heh
07:37:24 <Lemmih> artagnon: You definitely want to look at the Core, then.
07:37:38 <doserj> artagnon: it is easer to understand Core, how Core performs, and what input haskell transforms to what Core output
07:37:56 <Jafet> The AMOP has a reference to this, which it calls the "paradox of high-level programming languages"
07:38:08 <doserj> (and even that is highly non-trivial)
07:38:16 <quicksilver> Jafet: not normally, no. GHC normally compiles direct to native code. The via-C route still exists but is deprecates.
07:38:20 <artagnon> doserj && Lemmih: Got it. Will do.
07:38:28 <Jafet> Ah, ok
07:38:45 <quicksilver> on reflection, s/direct//;
07:38:53 <quicksilver> it's quite the opposite of direct.
07:38:57 <quicksilver> there are about 42 intermediate forms.
07:39:14 <doserj> no modern compiler compiles "direct" :)
07:39:41 <quicksilver> what I meant was "not going via another compiler"
07:39:48 <quicksilver> rather than "not going via an intermediate form"
07:39:54 <quicksilver> but it was a poor choice of word.
07:40:32 <artagnon> bah, I can't understand a damn thing in the Core output. Where should I start learning?
07:40:37 <artagnon> learning compiler theory ie.
07:40:59 <quicksilver> artagnon: SPJ's book
07:41:02 <fasta> artagnon: Core output is quite horrible too.
07:41:05 <quicksilver> artagnon: it's out of date but very interesting.
07:41:08 <lilac> it's direct in the way a stopping train service is direct -- at least you don't get put on a replacement bus service
07:41:32 <lilac> artagnon: how are you viewing the core?
07:41:34 <fasta> artagnon: variable names are random, instead of based on the original source and so on. The theory part is just System F, IIRC.
07:41:45 <quicksilver> artagnon: http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
07:42:05 <quicksilver> artagnon: it doesn't quite reflect how modern GHC works, but you will learn a *lot* about compiler theory from it.
07:42:10 <lilac> artagnon: there's a program ghc-core on hackage which produces a nice syntax-highlighted version which is a fair bit more readable than the standard ghc output.
07:42:28 <artagnon> sorry about that..
07:42:31 <fasta> lilac: Yes, it is, but still my points apply to that.
07:42:32 <quicksilver> artagnon: http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
07:42:36 <quicksilver> artagnon: it doesn't quite reflect how modern GHC works, but you will learn a *lot* about compiler theory from it.
07:42:46 <Makoryu> http://www.cafepress.com/haskell_books <- Quick, someone update the logo!
07:42:55 <artagnon> quicksilver: Thanks! Will read that :)
07:43:02 <lilac> fasta: i wasn't disagreeing ;-)
07:43:06 <fasta> Core shouldn't be read by humans. Someone should fix Core to make it human readable and until then it is a crime against humanity ;)
07:43:50 <quicksilver> in 21
07:43:54 <quicksilver> *sigh*
07:43:54 <lilac> i don't find reading core any worse than reading assembly language
07:44:01 <jfoutz> hah
07:44:24 <lilac> and i read both for largely the same reasons, and at largely the same times
07:44:38 <fasta> Reading assembly code with C labels seems more easy to me.
07:44:46 <quicksilver> just practice, I think
07:44:49 <Botje> fasta: ghc-core makes it quite not-bad
07:44:59 <Botje> some color coding helps ;)
07:45:00 <fasta> Botje: read the scollback.
07:45:01 <quicksilver> there are some very annoying thins about core though
07:45:09 <quicksilver> like the fact that it's constantly updated
07:45:16 <quicksilver> and the fact that some identitiers get rather long
07:45:21 <artagnon> quicksilver: um... before I start reading, why exactly doesn't GHC work that way?
07:45:22 <quicksilver> s/updated/indented/
07:45:25 <quicksilver> damn it.
07:45:32 <quicksilver> artagnon: more recent discovers in compiler design ;)
07:45:39 <Botje> woops, sorry :)
07:45:42 <quicksilver> artagnon: most of which are documented in more recent SPJ papers.
07:46:41 <artagnon> quicksilver: Ah, impressive :)
07:47:10 <lilac> the type lambdas and type applications really don't help core's readability
07:47:40 <Vanadium> type lambdas?
07:47:46 <fasta> Vanadium: System F.
07:48:08 <artagnon> anyway, I'm off to do some reading. As usual, thanks to everyone. #haskell is a wonderful channel! :)
07:49:55 <greap> Can anyone build HTTP-Simple from Hackage? It seems to work, but no library folder is created, and the package seems to be missing any source code.
07:50:03 <jpcooper> hello
07:50:55 <jpcooper> will anything be done to Network so that when a socket is closed on one side, the handle on the other side will accordingly show that it is not readable or writeable?
07:51:14 <Lemmih> greap: HTTP-Simple has been deprecated.
07:51:22 <Saizan> greap: the maintainer uploaded an empty package to deprecate it, apparently
07:51:56 <jpcooper> at the moment I have to write a sigPIPE handler, which is not convenient because I would like the thread which calls hPutStrLn to know whether or not a handle associated with a socket is really writeable
07:52:36 <benmachine> jpcooper: I'm not sure that information is available
07:52:51 <benmachine> but I know that in other languages, if you ignore SIGPIPE then the write fails with error EPIPE
07:53:23 <greap> Saizan: Lemmih: What are people using now?
07:54:06 <jpcooper> I'm wondering whether or not it's the same in C. Does it not give facilities to check, given a file descriptor, whether or not its associated socket has been closed on the other end?
07:54:14 <Lemmih> greap: HTTP.
07:54:53 <greap> Lemmih: ok.
07:55:09 <benmachine> jpcooper: umm, it's possible that it does but if so I don't know about it
07:56:15 <jpcooper> benmachine, in Haskell if I have a handle, what is the current way in which the real ability to read or write is checked?
07:56:29 <greap> Lemmih: Ah, I only had a subset of http installed. That explains why I thought it was just the low level stuff.
07:57:04 <jpcooper> right now if I close the handle on one end, hIsReadable and hIsWriteable on the handle on the other end stay true
07:57:05 <benmachine> jpcooper: I'm afraid you've reached the limits of my expertise (didn't take long, did it :P)
07:58:57 <Peaker> jpcooper: are you sure its the only handle/fd to the other end's file?
07:59:14 <jpcooper> I don't understand
07:59:38 <Peaker> jpcooper: if you create a pipe/socket, and fork a process or dup, for example, you get multiple fd's pointing to the same socket/pipe end
07:59:56 <Peaker> jpcooper: close() on such a handle/fd doesn't do anything but decrease a refcount
08:00:03 <jpcooper> I'm wondering about Haskell here
08:01:59 <Peaker> jpcooper: My guess would be use of select for hIsReadable/hIsWritable
08:03:11 <jpcooper> Peaker, is there any current solution given Haskell's libraries?
08:04:03 <Peaker> jpcooper: What happens if you write after that close?
08:04:16 <Peaker> jpcooper: I think you should be notified of the close by reading an EOF
08:04:36 <jpcooper> yes I suppose that I could peak
08:04:40 <jpcooper> peek*
08:05:29 <jav_> Hi there! Is it possible to remove packages that one uploaded to HackageDB? or can you only update them?
08:05:44 <edwardk> jav_: you can only add new versions
08:06:08 <jav_> I see, thx
08:06:39 <edwardk> jav_: its occasionally annoying ;)
08:06:52 <edwardk> jav_: but then the alternative is even stranger i suppose
08:07:27 <jav_> edwardk: I guess so... I will just add some note that the package is obsolete, I just wanted to make sure that I'm not missing a way to delete it
08:08:12 <edwardk> jav_: yeah you can upload a latest version give it some requirement list that can't be satisfied and add a description, etc. saying that i suppose.
08:08:35 <edwardk> jav_: what package?
08:09:03 <jav_> edwardk: bluetileutils... I'm merging it in with the main package 'bluetile'
08:09:16 <edwardk> jav_: ahh
08:09:34 <edwardk> jav_: you could just make a current version that requires bluetile and exports nothing new
08:09:45 <edwardk> jav_: thats how i plan to handle a couple of package refactorings I am doing
08:10:01 <jav_> edwardk: good idea, I'll think about it
08:10:08 <edwardk> then importing bluetileutils will bring in bluetile which will bring in the functionality that bluetileutils used to provide
08:10:13 <Peaker> jpcooper: I would expect isWritable to be turned off when the other side closes
08:10:17 <jav_> right, makes sense
08:11:30 <Saizan> jav_: you can email the hackagedb maintainer or cabal-devel to ask them to mark it deprecated
08:11:50 <jpcooper> Peaker, well it isn't\
08:12:00 <jav_> Saizan: oh, I see... what's the effect of it being makred deprecated?
08:12:00 <jpcooper> nor is hIsReadable
08:12:11 <Peaker> jpcooper: isReadable should be true, because you have the EOF to read
08:12:17 <Peaker> jpcooper: (and the EOF remains there forever)
08:12:28 <Saizan> jav_: it won't show up in the package list
08:12:39 <jpcooper> right
08:13:05 <jav_> Saizan: ah, good, thx for the info
08:14:54 <jethr0> has anyone here gotten hsSDL to compile under windows?
08:28:58 <jethr0> ...
08:29:15 <jethr0> that's what i call a non-sequitur ;)
08:30:03 * DrSyzygy 'd rather call it a nemo-sequitur.
08:32:57 <Twey> You could upload a new version that just printed a deprecation error.
08:33:26 <jethr0> DrSyzygy: any experience with ghc under windows? profiling with "+RTS -p" is producing an empty ".prof" ;(
08:34:37 <Twey> Did you remember to compile it with profiling?
08:35:18 <jethr0> sure
08:35:48 <jethr0> could have to do with the error message AFTER QUITTING: "BM.exe: schedule: re-entered unsafely."
08:35:59 <DrSyzygy> jethr0: Yeah, my talking about latin certainly indicates me knowing what's going on with your specific problem.
08:36:10 <jethr0> since profiling often doesn't produce a file on an interrupted execution
08:36:57 <jethr0> it indicates that you are a person of considerable knowledge intellectual prowess
08:37:07 <jethr0> s/dge /dge and/
08:39:36 <jethr0> what's the accepted way to quit a multithreaded application? is system.exit in the "main thread" acceptable, or do i need to jump through some extra hoops?
08:40:00 <benmachine> if the main thread dies then all the other threads die too
08:40:03 <benmachine> so I've heard
08:40:08 <benmachine> well, so I believe
08:40:18 <jethr0> true, doesn't mean it very clean though...
08:41:48 <quicksilver> it's fine as far as the RTS is concerned
08:42:00 <quicksilver> if you have to do something else to cleanly clean up any resources you may hold
08:42:05 <quicksilver> well, that's your responsibility ;)
08:45:14 <jethr0> quicksilver: ever tried SDL bindings under windows or MacOS?
08:48:34 <quicksilver> jethr0: no
08:48:47 <quicksilver> jethr0: I know there are two bindings, I know one is a bit more live than the other.
08:48:58 <quicksilver> I can never remember which is which
08:49:12 <jethr0> i'm trying hsSDL right now. but under anything but linux it's a mess to get running
08:49:47 <jethr0> in part due to really strange library call semantics (like insisting on owning the program's "main") *tststs*
08:52:14 <quicksilver> yup
08:52:22 <quicksilver> everybody complains about that about sdl
08:52:27 <quicksilver> although tis' quite common for that kind of library
08:53:31 <jethr0> i wonder if everybody eventually finds a fix for that
08:54:02 <jethr0> may be common, but the whole GHC/FFI/HSC/Core mangling makes it a bit of a drag to figure out oneself
08:55:22 <ezyang> Hmm: ErrorT on Reader, or ReaderT on Error? Choices... choices...
08:55:52 <EvilTerran> ?untml ErrorT e (Reader r) a
08:55:53 <lambdabot> Maybe you meant: unmtl unpl
08:55:57 <EvilTerran> ?unmtl ErrorT e (Reader r) a
08:55:57 <lambdabot> r -> Either e a
08:56:10 <EvilTerran> ?unmtl ReaderT r (Error e) a
08:56:10 <lambdabot> r -> Error e a
08:56:43 <ezyang> ... huh?
08:56:56 <EvilTerran> ezyang, it seems they're the same
08:56:59 <EvilTerran> (i thought so)
08:57:05 <EvilTerran> ?src ErrorT
08:57:05 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
08:57:09 <EvilTerran> ?src ReaderT
08:57:09 <lambdabot> Source not found.
08:57:11 <EvilTerran> hm
08:57:48 <jethr0> who is spamming my irc window?
08:58:18 <ezyang> @src ReaderT
08:58:18 <lambdabot> Source not found. I feel much better now.
08:58:29 <ezyang> @src Control.Monad.ReaderT
08:58:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:58:42 <ezyang> @src Control.Monad.Reader.ReaderT
08:58:42 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:58:57 <Saizan> ezyang: qualifications never help for @src
08:59:28 * jethr0 proposes a more intimate chat with /msg lambdabot
08:59:33 <EvilTerran> ,src ''ReaderT
09:00:11 <EvilTerran> no lunabot? =/
09:02:32 <benmachine> @unmtl ReaderT
09:02:32 <lambdabot> err: `ReaderT' is not applied to enough arguments, giving `/\A B C. A -> B C'
09:02:56 <benmachine> @unmtl ReaderT s m a
09:02:57 <lambdabot> s -> m a
09:03:19 <EvilTerran> @unmtl ErrorT e m a
09:03:19 <lambdabot> m (Either e a)
09:03:23 * quicksilver proposes @src be removed from lambdabot.
09:03:50 <EvilTerran> removed or fixed up, anyway
09:04:34 <ezyang> fail or Left? Choices...
09:08:58 <CrazyAzrael1> This is completely random, but if you haven't seen Data.MemoCombinators yet, I suggest you check it out--it avoids alot of the annoying stuff that one normally has to do when building a memoized function
09:09:59 <Saizan> MemoTrie is nice too
09:16:56 * lispy laughs as the idea of "intimate chat" with lambdabot
09:17:09 <lispy> ?vixen should we take this to a more intimate chat?
09:17:09 <lambdabot> yes
09:18:08 <ski> ezyang : ?
09:24:27 <ezyang> ski: while inside the Error monad
09:25:50 <ski> what is the type of errors ?
09:26:38 <ezyang> I'm planning on shuffling them to the IO monad and then turning them into exceptions
09:27:04 <ski> is the type of errors `String', then ?
09:27:45 <ski> `Exception' ?
09:28:13 <ski> if its just `String', `fail' would suffice
09:32:04 <ezyang> ski: Right, but if I'm not careful about my monads this could make me very sad
09:33:24 <ski> ezyang : elaborate ?
09:34:18 <ezyang> ski: A lot of monads use error/bottom for their fail implementation, which sucks
09:34:23 <lispy> ski: calling fail for the wrong monad (like the inner one)
09:34:50 <lispy> oh, maybe I misunderstood actually
09:35:02 * ski generally tries to avoid using `fail'
09:36:04 <ezyang> Syntax error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9002#a9002 help?
09:37:04 <kmc> Is it fair to say that Haskell doesn't have subtyping?  Or that it doesn't have monomorphic subtyping?
09:37:13 <lispy> ezyang: member { memberAffil -> x}, looks weird to me.  I don't recall that bit of syntax
09:37:22 <ezyang> ohh ho ho
09:37:26 <ezyang> Looking at the wrong -> :-)
09:37:46 <ski> s/-> x/= x/, yes
09:38:05 <ski> kmc : no subtyping
09:38:18 <ski> (for that, look at e.g. O'Haskell and Timber)
09:38:19 <lilac> kmc: haskell has subclassing, which can sometimes be used for similar things
09:38:29 <lispy> kmc: I'm not really an expert in subtyping, but have you read Oleg's OOHaskell paper?  He compares Haskell (with and without commond extensions) to OO languages
09:38:31 <kmc> couldn't we say that (forall a. a -> a) is a supertype of Int -> Int
09:38:44 <ski> no
09:38:50 <lilac> ski: why not?
09:38:52 <Peaker> OO languages don't really "have" subtyping
09:38:52 <ski> the latter is an instance of the former
09:39:00 <jethr0> has anyone gotten SDL to run under windows
09:39:04 <lispy> Peaker: well, subtyping is undecidable in general
09:39:07 <lispy> Peaker: so yeah :)
09:39:11 <jethr0> and secondly, has anyone compiled with ghc under cygwin?
09:39:16 <lilac> ski: surely types aren't instances of types?
09:39:24 <kmc> ski, does this presume that the relationship "is subtype of" is defined only on monomorphic types?
09:39:27 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9003#a9003 do these seem like reasonable definitions for a parser?
09:39:37 <Peaker> lispy: what do you mean? You could have subtypes as a language feature, I'd suppose (e.g BRules enforcement)
09:39:38 <kmc> or can we talk about subtyping between polymorphic types, but this isn't one for some reason?
09:39:50 <ski> kmc : subtyping is about variant and record types
09:40:13 <kmc> ski, i think those are two common examples, yes
09:40:26 <lilac> by LSP, Int -> Int would seem to be a supertype of (forall a. a -> a)
09:40:33 <kmc> ?
09:41:11 <lilac> http://en.wikipedia.org/wiki/Liskov_substitution_principle
09:41:48 <lilac> if a function wants an argument of type Int -> Int, you can always give it an argument of type (forall a. a -> a).
09:42:01 <kmc> lilac, but the left of a function arrow is contravariant in subtyping
09:42:08 <ski> etpace_ : yes
09:42:29 <ski> kmc : yes, but that's not relevant, here
09:42:51 <etpace_> ok thanks ski
09:43:30 <lispy> Peaker: never heard of BRules enforcement.  But, what I recall learning is that in general you don't know if a subclass has the same behavior (halting problem) so therefore you can't know for sure if the subclass is a true subtype
09:43:32 <ski> etpace_ : i think the original papers about monadic parsers used more or less exactly that
09:44:01 <lispy> Peaker: at least in languages like Smalltalk, C++, Java, ...
09:44:38 <ski> in O'Caml, some subclasses does not generate subtypes (and the type system knows this)
09:45:02 <kmc> hmm, ski, i see
09:45:08 <kmc> that's counterintuitive, to me at least
09:45:25 <kmc> you sort of have to think of the polymorphism as an implementation detail
09:45:46 <kmc> "this function of type Int -> Int happens to be a type-applied polymorphic function"
09:46:07 <ski> if you have a class `A' with a method that takes an argument of the same class as the current class, then in a subclass `B' of `A', that method will not accept arguments of type `A
09:46:15 <ski> ', so `B' is not a subtype of `A'
09:46:48 <ski> s/same class as the current class/same type as the current class/
09:47:24 <kmc> ski, does O'Caml cleanly distinguish between subclassing for subtyping and subclassing for code reuse?
09:47:54 <ski> (an instance object of `A' will accept `A's to that method, but an instance object of `B' will only accept `B's, not `A's)
09:48:27 <lispy> I read an essay at Oleg's website recently about getting into trouble by subclassing for reuse and the thing I thought was, "Huh, I thought the wisdom in the OO community was that subclassing for reuse is bad."
09:48:31 <ski> kmc : afaik, in O'Caml subclassing and subtyping is not coupled like that
09:49:06 <kmc> classes are record types, and subtyping is the usual relation on records?
09:49:14 <ski> two different classes (onw not obtained by subclassing from the other) can still generate types which are subtypes of each other (in one direction)
09:49:26 <lispy> I seem to recall learning that if you want reuse that composition (has-a like how we do newtype wrappers) is the preferred method
09:49:38 <ski> object types are (more or less) record types, yes
09:50:02 <ski> a `class' in ocaml is a special kind of function that returns a value of object type
09:50:18 <ski> (special in the sense that one can use subclassing on it to produce new classes)
09:50:19 <kmc> lispy, but the c++ designers decided in their infinite wisdom to add two forms of subclassing explicitly and only for code reuse
09:50:28 <kmc> which muddles the issue considerably
09:51:16 <ski> (and you can create objects of object type without using classes)
09:51:59 <lispy> kmc: hmm, which two?  remind me please :)
09:52:09 <kmc> protected and private inheritance
09:52:21 <kmc> in addition to public (which gives you *both* subtyping and code reuse)
09:53:04 <kmc> also it is easy to start with something that's a pure interface specification and end up with a lot of behavior tacked on
09:53:05 <lispy> Well, protected/private inheritance is like the compostion pattern, I think
09:56:24 <hackagebot> bluetile 0.2 - A modern tiling window manager with a gentle learning curve (JanVornberger)
09:59:25 <hackagebot> bluetileutils 0.2 - Utilities for Bluetile (JanVornberger)
10:11:11 <kmc> anyone know why papers from research.microsoft.com won't load on my internet connection?
10:11:19 <kmc> nobody else seems to have trouble
10:13:03 <Lemmih> kmc: It's down for me as well.
10:15:13 <jethr0> probably all patented ;)
10:15:48 <babusrini> I am getting this error when compiling with -prof "Dynamic linking required, but this is a non-standard build (eg. prof). You need to build the program twice: once the normal way, and then in the desired way using -osuf to set the object file suffix." Can someone explain how I can do this? Thanks
10:16:05 <Lemmih> jethr0: You'd be surprised.
10:16:22 <kmc> babusrini, http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html 7.9.4 may be helpful
10:16:36 <kmc> not sure if it's exactly your situation but it sounds related
10:16:38 <Lemmih> babusrini: First build without -prof, then with -prof.
10:17:10 <Lemmih> babusrini: Cabal does so by default, me thinks.
10:17:30 <kmc> babusrini, probably ghc wants to run some code at compile time in its own RTS, but it's a non-prof build of ghc so it can't run your prof code.  hence compiling twice
10:18:11 <jethr0> Lemmih: in what way?
10:19:49 <kmc> > do { if False then mzero; return 3 } :: Maybe Int
10:19:51 <lambdabot>   <no location info>: parse error on input `;'
10:20:13 <kmc> i seem to remember a do-notation variant of 'if' where else defaults to "return ()",
10:20:16 <kmc> but i can't make it work
10:20:20 <Lemmih> jethr0: They're very open about all the research they do.
10:20:21 <kmc> am i imagining this?
10:21:08 <jethr0> i know, i admire the guys at microsoft research and what they are doing. just wanted to get a little windows flamewar started ^_^
10:21:19 <roconnor> @src when
10:21:19 <lambdabot> when p s = if p then s else return ()
10:21:26 <roconnor> @src unless
10:21:26 <lambdabot> unless p s = if p then return () else s
10:21:33 <kmc> ah thanks
10:21:41 <kmc> shades of perl in the last one...
10:22:46 <roconnor> It's really nice having control structures as functions
10:23:02 <kmc> yeah, and laziness so that short-circuiting is not special
10:23:09 <roconnor> right
10:23:18 <kmc> this is part of why i think haskell is a great imperative language
10:23:26 <kmc> though people look at me funny when i say that outside of this channel :/
10:23:37 <roconnor> :)
10:23:57 <kmc> i'm excited about lenses, because i think record updates are the ugliest part of imperative stateful haskell code
10:24:22 <roconnor> kmc: you know about the accessor package?
10:24:41 <xci> whoa, what are lenses
10:24:43 <roconnor> (and it's template haskell partner?)
10:24:53 <pikhq> Haskell is not a great imperative language. Haskell is the language almost all other languages aspire to be.
10:25:09 <kmc> xci, http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
10:25:33 <roconnor> xci: a lens is a structure that pairs together the field update and field access functions.
10:25:48 <kmc> roconnor, this looks nice; i'm not sure if it's equivalent to the lenses approach or another angle on the problem
10:26:00 <roconnor> Thought the fields don't have to be actual fields.  They could even be virtual fields
10:26:42 <roconnor> kmc:  I guess I'm giving the easy to grasp view on lenses.  They are indeed more broad than I describe.
10:27:20 <roconnor> kmc: or were you talking about the accessor package?
10:27:24 <kmc> accessor
10:27:47 <roconnor> ah, in what way do is it not the lenses approach?
10:27:52 <babusrini> kmc, thanks for the link. After building without -prof I built with -prof -osuf p_o and it worked. It created a 50 Meg binary.
10:27:56 <kmc> :D
10:28:50 <kmc> roconnor, in the link i pasted "get" and "set" are record fields themselves of the accessor type; in accessor they're combined into one function
10:28:56 <kmc> probably not an important difference
10:29:24 <roconnor> ah
10:29:46 <roconnor> I'm not so fond of the accessor implementation; however it is abstract and I like their interface.
10:29:56 <Lanjiao> @djinn a -> b -> a
10:29:57 <lambdabot> f a _ = a
10:30:11 <roconnor> I think you could swap in a pair of functions instead of what they have and nothing would break.
10:30:14 <kmc> @djinn ((p -> q) -> p) -> p
10:30:14 <lambdabot> -- f cannot be realized.
10:30:48 <roconnor> @djinn J r ((p -> q) -> p) -> p
10:30:48 <lambdabot> Error: Undefined type J
10:30:53 <lilac> @djinn (forall a. a -> p) -> p
10:30:54 <lambdabot> -- f cannot be realized.
10:31:04 <kmc> can i define types in djinn here?
10:31:12 <roconnor> yes, but I forget how
10:31:24 <ski> @djinn NotNot (((p -> q) -> p) -> p)
10:31:24 <lambdabot> f a =
10:31:24 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
10:31:43 <ski> kmc : like `@djinn-add type NotNot a = Not (Not a)', e.g.
10:31:48 <kmc> @djinn (NotNot a -> a) -> (((p -> q) -> p) -> p)
10:31:48 <lambdabot> -- f cannot be realized.
10:31:54 <uzytkownik> Hello. I have Map a b and Map a c. I have functions (b ->d), (c -> d) and (b -> c -> d). I'd like to create union in efficient way using first function for the first map only, second for second map only and third for their 'union'. Is there any simple, efficient way?
10:32:07 <lilac> @djinn-add F x y = x -> y
10:32:08 <lambdabot> Cannot parse command
10:32:18 <ski> @djinn (NotNot p -> p) -> (((p -> q) -> p) -> p)
10:32:18 <lambdabot> f a b = a (\ c -> void (c (b (\ d -> void (c d)))))
10:32:19 <kmc> :t M.union
10:32:20 <lambdabot> forall k a. (Ord k) => M.Map k a -> M.Map k a -> M.Map k a
10:32:30 <dolio> kmc: NotNot a -> a is useless to djinn for producing ((p -> q) -> p) -> p, because the latter doesn't mention 'a' anywhere.
10:32:51 <dolio> kmc: And it doesn't have polymorphism that works like that.
10:32:55 <ski> (and djinn doesn't do higher-ranked types, i think)
10:32:57 <lilac> @djinn-add type J a b = ((a -> b) -> a) -> a
10:33:09 <kmc> @djinn (forall a. NotNot a -> a) -> (((p -> q) -> p) -> p)
10:33:09 <lambdabot> -- f cannot be realized.
10:33:11 <kmc> :/
10:33:20 <dolio> No higher rank.
10:33:24 <roconnor> lilac: wrong type for J
10:33:29 <lilac> :(
10:33:37 <roconnor> J r a = (a -> r) -> a
10:33:42 <ski> @djinn-clr
10:33:50 <ray> djinn .NET
10:33:51 <etpace_> hmm, how do I collect the values output by my parser?
10:33:54 <uzytkownik> kmc: Please read the requirements. It's more then union or even unionWith
10:33:58 <lilac> @djinn-add type J a b = (b -> a) -> b
10:34:13 <kmc> uzytkownik, i know, i was just testing if Map is in scope in lambda
10:34:14 <kmc> bot
10:34:22 <lilac> @djinn (a -> J s b) -> (b -> J s c) -> a -> J s c
10:34:23 <lambdabot> f a b c d = b (a c (\ e -> d (b e d))) d
10:34:41 <uzytkownik> kmc: Sorry. I thought it is for me.
10:35:52 <roconnor> uzytkownik: why isn't unionWith good enough?
10:36:35 <dolio> @djinn Not (Not (Either a (Not a)))
10:36:35 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
10:36:57 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9004#a9004 i've got the foundations for an 'ambiguous' parser but, how would I collect the final result? how would I store my `a's?
10:37:28 <kmc> uzytkownik, one approach would be to lift them to Map.Map a (Maybe b), Map.Map a (Maybe c), then insert Nothing elements so their keys sets are the same, then unionWith using an appropriate combination of your functions
10:37:38 <kmc> that involves a lot of tagging
10:37:50 <desp> Has anyone tried installing GHC on Mac OS X 10.6?
10:39:19 <kmc> uzytkownik, or compute the key sets for (b - a), (a - b), (a intersect b), and then fold a lookup/apply/insert for each in turn
10:39:31 <uzytkownik> kmc: I thought about something like this. But I guess it should be possible in single 'run'
10:40:11 <ski> uzytkownik : assuming `bd :: b -> d',`cd :: c -> d',`bcd :: b -> c -> d', if you have `x :: b',`y :: c', then if `bd x == cd y' you want to merge them using `bcd x y' ?
10:40:54 <ski> .. hm, no. forgot about that you had a map from `a' (was thinking of set)
10:41:27 <roconnor> uzytkownik, kmc: I'm thinking something similar: data Foo a b = This a | That b | Both a b.  (map This) over the first map, (map That) over the other map.  unionWith a both function, and then a final map.
10:41:45 <jethr0> desp: not directly but a friend of mine just did without real problems...
10:42:02 <desp> jethr0: did he have to use the HEAD?
10:42:08 <roconnor> However, I think uzytkownik might rightly be pointing to a hole in the Data.Map interface.  His function (or a similar function) ought to exist.
10:42:21 <uzytkownik> roconnor: Nearly. Union and then I create simply Foo -> d.
10:42:46 <desp> jethr0: which version did he install, GHC-6.10.4-i386.pkg?  Or haskell-platform-2009.2.0.2-i386.dmg?
10:42:54 <jethr0> not sure, but i don't think so. i think he may have used darwin-ports. but as he had no issues i'm not aware of any specifics
10:43:08 <desp> Hm.
10:43:18 * desp is finding conflicting information.
10:43:29 <dolio> @djinn (((Either p (Not p) -> Void) -> Either p (Not p)) -> Either p (Not p)) -> Either p (Not p)
10:43:29 * uzytkownik have to leave
10:43:29 <lambdabot> f a =
10:43:29 <lambdabot>     case a (\ b -> Right (\ c -> b (Left c))) of
10:43:29 <lambdabot>     Left d -> Left d
10:43:29 <lambdabot>     Right e -> Right e
10:43:43 <jethr0> have you tried darwin-ports and mac-ports?
10:43:43 <roconnor> uzytkownik: you need to use unionWith and not union.
10:44:04 <desp> jethr0: checking macports now.  I thought they weren't compatible with 10.6 yet.
10:44:15 <jethr0> not really sure, sorry
10:44:20 <desp> No problem, thanks.
10:45:08 <roconnor> is Data.Map.alter a new function?  It looks nifty.
10:45:34 <Deewiant> It's been there as long as I remember
10:45:45 <Deewiant> Which may still make it relatively new, but anyway. :-P
10:45:56 <lilac> @type \f g h a b -> either (either f g) id <$> M.unionWith (\(Left (Left a)) (Left (Right b)) -> Right (h a b))  (Left <$> Left <$> a) (Left <$> Right <$> b)
10:45:57 <lambdabot> forall a b b1 k. (Ord k) => (a -> b1) -> (b -> b1) -> (a -> b -> b1) -> M.Map k a -> M.Map k b -> M.Map k b1
10:46:03 <dolio> I like that djinn output. The totally superfluous case statement is great.
10:46:04 <lilac> aww, e left
10:46:10 <roconnor> Hmm, I guess I never noticed it before.
10:47:08 <roconnor> lilac: ya, but I really don't like the irrefutable patterns in unionWith's function parameter.
10:47:10 <Asztal> :t M.alter
10:47:11 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
10:47:24 <roconnor> lilac: however I see no way around it with the current Data.Map interface.
10:48:00 <roconnor> lilac: which is why I sort of think uzytkownik's function should be part of Data.Map.
10:49:04 <roconnor> lilac: Um, is Data.Map really a Functor?
10:49:15 <dolio> Yes.
10:49:39 <roconnor> I thought the Ord constraint made that impossible?
10:49:46 <dolio> That's on the keys.
10:50:10 <roconnor> ok
10:50:16 <opqdonut> Ord makes Data.Set being a functor impossible
10:50:20 <roconnor> ah
10:50:24 <dolio> Yeah, that one's the problem.
10:50:35 <roconnor> I guess I let the trouble with Data.Set colour me too much
10:51:12 <opqdonut> hmm, is there a monad instance for Map?
10:51:42 <opqdonut> a "stupid" instance that merely merges the results
10:51:57 <opqdonut> if you see what i mean
10:52:04 <roconnor> there is a question on what to do with conflicts
10:52:05 <dolio> Well, how do you make up keys for, say, return?
10:52:26 <Asztal> Make the key type a monoid?
10:52:29 <roconnor> @type (<$>)
10:52:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:52:45 <opqdonut> what Asztal said sounds good
10:52:46 <opqdonut> maybe
10:52:48 <dolio> I think whatever you do, you're probably doomed to fail some laws.
10:52:56 <opqdonut> or at least that'd give us a natural choice for the return key
10:53:29 <dolio> I suppose that could possibly work.
10:53:37 <lilac> "data TotalMap a b = TM a (Map a b)" is a Monad
10:53:46 <lilac> (it's just reader in disguise)
10:54:25 <lilac> TM b (Map a b) rather
10:54:31 <opqdonut> lilac: yes, of course
10:56:31 <elliottt> has anyone seen this bug when compiling the base library before? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9005#a9005
10:56:37 <FunctorSalad> seems more special than reader
10:56:55 <elliottt> It seems to happen reliably on Foreign.Ptr, and the W# constructor.
10:56:59 <FunctorSalad> opqdonut: btw I think there *is* an instance for fixed k
10:57:31 <lilac> is it possible for two Monad instances for the same type constructor to give rise to extensionally equal Applicative instances?
10:57:53 <FunctorSalad> opqdonut: hmm or not quite Monad. Foldable and Traversable
10:58:28 <lilac> FunctorSalad: which k? there's an instance for uninhabited k :)
10:58:44 <opqdonut> :D
10:58:50 <FunctorSalad> lilac: it's Traversable and Foldable for any k
10:59:01 <lilac> right, naturally.
10:59:50 <lilac> actually... any k? not just Ord k => k?
11:00:29 <FunctorSalad> according to haddock, any http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Map.html#1
11:00:49 <dolio> You don't need to look at the ks to go trough and do stuff with the as.
11:01:50 <opqdonut> yep
11:01:58 <opqdonut> once you have access to the internal tree structure
11:02:12 <opqdonut> or wait, fromList is enough?
11:02:49 <FunctorSalad> @free a -> [(k,a)]
11:02:49 <lambdabot> Extra stuff at end of line
11:02:55 <lilac> dolio: going through and doing stuff with the as means Foldable and Functor.
11:03:25 <dolio> Traversable too, really. It doesn't let you do anything with the ks.
11:03:32 <dolio> It just keeps them where they are.
11:03:51 <lilac> i guess traversable is about effects commuting with traversal, so yeah
11:04:19 <FunctorSalad>   forall t1,t2 in TYPES, R in REL(t1,t2).
11:04:19 <FunctorSalad>    forall t3,t4 in TYPES, S in REL(t3,t4).
11:04:19 <FunctorSalad>     forall (x, y) in R. (f1 x, f1 y) in lift{[]}(lift{(,)}(S,R))
11:04:20 * lilac doesn't really ahve a good intuition for Traversable yet
11:04:26 <FunctorSalad> (ran it in ftshell)
11:05:27 <opqdonut> FunctorSalad: did that get truncated
11:05:31 <opqdonut> or can't i just read it
11:05:45 <FunctorSalad> opqdonut: three lines (it does look odd)
11:06:12 <FunctorSalad> but it wasn't really the right type since we said k could be fixed
11:07:39 <FunctorSalad> does anyone know how I can declare a fixed type K in ftshell?
11:08:13 <FunctorSalad> opqdonut: right there was a part missing, f1 is the function   f1 :: forall a k . a -> [(k, a)]
11:08:35 <opqdonut> okay
11:11:32 <FunctorSalad> (I used [(k,a)] because presumably it doesn't know about Map)
11:12:53 <FunctorSalad> hmm isn't "return x = singleton 0 x" a valid instance for Map Int?
11:13:04 <FunctorSalad> (for example)
11:13:24 <dolio> And bind adds keys?
11:14:14 <FunctorSalad> hmm bind would have to be like cartesian product as for list, correct?
11:14:21 <FunctorSalad> so you'd need a pairing function for ints
11:18:35 <desp> So macports doesn't build GHC at all.
11:18:41 <desp> (On 10.6)
11:18:53 <desp> Not supported yet.
11:19:01 <desp> Any other Mac users here?
11:19:44 <c_wraith> desp: there are relatively often.  Possibly not at the moment, though
11:20:46 <lilac> FunctorSalad: [(k,a)] isn't the same as Map k a. The former allows duplicate keys, the latter does not.
11:21:29 <mornfall> lilac: What's the difference? :)
11:22:41 <desp> Igloo: ping?
11:22:41 <noteventime> Would [(k,a)] be equivalent to Map k [a] then?
11:23:14 <lilac> no, the former contains extra information (the order of the elements)
11:24:08 <noteventime> Right, I forgot you didn't have to use insert
11:24:30 <dolio> So, you can write "return a = singleton mempty a ; m >>= f = foldWithKey (\k a m' -> mapKeys (k `mappend`) (f a) `union` m') empty m"
11:24:48 <dolio> Does that satisfy associativity for monads?
11:25:43 <dolio> It should easily follow left and right identity due to monoid left and right identity.
11:26:50 <dolio> monoid associativity might get you monad associativity, too.
11:26:54 <lilac> i'd be worried about bias on the union
11:27:03 <dolio> Yeah, that's my concern.
11:30:29 <dolio> I'm too lazy to rig up quickcheck to test it now, too.
11:32:05 <dolio> Mainly because I suspect I'd have to write up an instance for Map.
11:33:50 <lilac> @check let return a = M.singleton mempty a; m >>= f = M.foldWithKey (\k a m' -> M.mapKeys (k `mappend`) (f a) `M.union` m') M.empty m; join = (>>=id) in \l -> let m = fmap (fmap M.fromList . M.fromList) (M.fromList l) in join (join m) == join (join <$> m)
11:33:52 <lambdabot>   "OK, passed 500 tests."
11:34:48 <aavogt> might that be passing because of the defaulting to ()?
11:34:57 <FunctorSalad> *away*
11:35:03 <dolio> Maybe.
11:35:05 <dolio> Map () ()
11:35:14 <lilac> aavogt: yeah, i think so. still working on it ;-)
11:36:05 <aavogt> @check \x y z -> (x `M.union` y) `M.union` z == x `M.union` (y `M.union` (z::M.Map Int Int))
11:36:06 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
11:36:06 <lambdabot>                     (Data.Map.Ma...
11:36:17 <lilac> @check let return a = M.singleton mempty a; m >>= f = M.foldWithKey (\k a m' -> M.mapKeys (k `mappend`) (f a) `M.union` m') M.empty m; join = (>>=id) in \l -> let k = M.mapKeys Sum . M.fromList; m :: M.Map (Sum Int) (M.Map (Sum Int) (M.Map (Sum Int) Int)); m = fmap (fmap k . k) (k l) in join (join m) == join (join <$> m)
11:36:18 <lambdabot>   "Falsifiable, after 10 tests:\n[(-1,[(-3,[(4,6),(5,4),(0,-7),(4,-5),(-6,7),...
11:36:32 <dolio> Awesome.
11:37:18 <aavogt> @check \x' y' z' -> let (x,y,z) = (M.fromList x',M.fromList y',M.fromList z') in (x `M.union` y) `M.union` z == x `M.union` (y `M.union` (z::M.Map Int Int))
11:37:19 <lambdabot>   "OK, passed 500 tests."
11:37:46 <lilac> nice simple counterexample: [(-1,[(1,[]),(0,[])]),(0,[(-1,[(2,1)])])]
11:39:06 <lilac> join.join gets "fromList []", join.fmap join gets "fromList [(Sum {getSum = 1},1)])"
11:39:38 <dolio> That's that, then, I guess.
11:42:35 * benmachine calculated 54 million primes up to 1079205163 before his app got OOM-killed
11:43:16 <benmachine> I was hoping I'd manage to run out of Ints first :P
11:43:41 <aavogt> > maxBound :: Int
11:43:42 <lambdabot>   9223372036854775807
11:44:03 <benmachine> Prelude> maxBound :: Int
11:44:03 <benmachine> 2147483647
11:44:08 <benmachine> I was almost halfway there
11:44:13 <benmachine> in fact
11:44:22 <c_wraith> lambdabot seems to be using bigger Ints
11:44:27 <benmachine> > 1079205163 / 2147483647
11:44:28 <lambdabot>   0.5025440657057539
11:44:32 <benmachine> lambdabot is 64-bit I guess
11:44:54 <benmachine> if I could halve my memory usage then I could finish the list
11:44:57 <CrazyAzrael1> > 2 ** 32
11:44:59 <lambdabot>   4.294967296e9
11:44:59 <benmachine> or double my available memory, either
11:45:03 <Orclev> ok, I'm having trouble figuring something out... I'm looking at http://www.haskell.org/all_about_monads/html/statemonad.html and I can't figure out where the state is being passed around inside makeRandomValueST
11:45:03 <benmachine> > 2 ^ 32
11:45:05 <lambdabot>   4294967296
11:45:53 <CrazyAzrael1> > 1079205163.0 / (2 ** 32)
11:45:54 <lambdabot>   0.2512720327358693
11:46:01 <dv_> > 2 ^ 64
11:46:02 <lambdabot>   18446744073709551616
11:46:19 <CrazyAzrael1> benmachine: You were far from finished :P
11:46:55 <benmachine> actually I need less than twice the amount of memory, because primes get sparser
11:47:26 <CrazyAzrael1> The primes get sparser, but you're going to be spending longer for each check as the numbers get larger, unless you're using some kind of intelligent prime checking instead of the simple seive
11:47:31 <benmachine> CrazyAzrael1: Ints are signed, so they only go up to 2 ^ 31 - 1
11:47:55 <CrazyAzrael1> benmachine: Sure, I was more commenting on time than space.
11:47:56 <benmachine> yeah but time isn't the issue, space is
11:48:05 <CrazyAzrael1> benmachine: How much space were you using when it died?
11:48:11 <benmachine> um, all of it
11:48:14 <Orclev> lol
11:48:20 <CrazyAzrael1> "all of it" isn't a number.
11:48:21 <burp> > 2^63 - 1 == maxBound :: Int
11:48:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:48:34 <benmachine> well it was OOM-killed and I didn't have much else running; this machine has 2 GB memory
11:48:38 <benmachine> now you know as much as I do
11:48:46 <CrazyAzrael1> OK, I was looking for the 2 GB :P
11:48:53 <benmachine> p.s. real	94m55.204s
11:49:02 <Orclev> maybe I could run it here, I've got 8 GB physical memory, plus like another 10G of swap
11:49:21 <benmachine> probably you could
11:49:31 <benmachine> but it would mean giving up your CPU for a couple of hours
11:49:44 <benmachine> and it wouldn't mean me learning about more efficient programming :P
11:49:44 <Orclev> well, one of them at least, is it multi-threaded?
11:49:52 <benmachine> it's not multithreaded
11:49:56 <benmachine> I did wonder about that
11:49:57 <CrazyAzrael1> If you are still having this problem in a couple hours when I get home from work, I could lend you a couple cores.
11:50:07 <benmachine> but each new prime uses previous primes so I'm not sure how I'd thread it well
11:50:12 <Orclev> yeah, I got 4 cores, I can afford to peg one of them for a while
11:50:15 <benmachine> heh
11:50:23 <benmachine> I don't actually need to know what the primes are
11:50:30 <benmachine> I need to write better programs
11:50:34 <CrazyAzrael1> benmachine: As far as threading, think speculative execution--most of them will drop out before they get through all the primes
11:50:34 <Orclev> hmm
11:50:50 <Orclev> using the seive of erasothenes (sp?)?
11:51:03 <CrazyAzrael1> If you just need to halve memory, you could probably do it by unboxing your ints
11:51:09 <elbar> well...calculating primes seem to be an art
11:51:11 <Orclev> there's a few tricks you can do to improve the basic seive
11:51:21 <CrazyAzrael1> (Right now there's a pointer indirection level between you and every stored number you have)
11:51:35 <CrazyAzrael1> Additionally, if you're using a list, switch to an array.
11:51:39 <burp> calculating primes.. hmm
11:51:45 <benmachine> primes = 2:[x | x <- [3,5..], (not . any (\y -> x `mod` y == 0)) . takeWhile (\z -> z * z <= x) $ primes]
11:51:54 <CrazyAzrael1> Should reduce container overhead.
11:51:57 <benmachine> so yeah I was doing it the "easy" way
11:52:09 <benmachine> I suspect you are all much better at this than I am
11:52:19 <Orclev> I'm not... at least not in haskell
11:52:32 <Orclev> I wrote a pretty good prime number finder in C# many moons ago
11:53:16 <msteele_> ben: You could swap out your primes with the one shown in http://lambda-the-ultimate.org/node/3127
11:53:19 <CrazyAzrael1> Alternatively, if you can get your hands on 4 GB, and you feel like doing it statefully, you can do it the fun way.
11:53:37 <CrazyAzrael1> (allocate an array for every number you will check, then just tick off in multiples
11:53:38 <CrazyAzrael1> :P
11:54:05 <benmachine> hah
11:54:14 <Orclev> so yeah, speaking of state, can someone help me understand wtf is going on in this example http://www.haskell.org/all_about_monads/html/statemonad.html
11:54:24 <CrazyAzrael1> Which part?
11:54:52 <Orclev> I can't figure how state is being passed between the instances of getAny and getOne
11:55:28 <Orclev> I see the calls to get and put, but no argument to them
11:55:39 <CrazyAzrael1> So, that's the whole point of the monad
11:55:49 <CrazyAzrael1> Look right above that
11:55:59 <CrazyAzrael1> at instance MonadState
11:56:02 <Orclev> yeah, but I don't see any instance of the monad
11:57:22 <CrazyAzrael1> So, the state monad is implemented as a wrapper record around a function that takes an initial state, does something, and generates a return value and state
11:57:42 <CrazyAzrael1> The monadic form of it just instruct is to pass through the state from the previous command.
11:58:12 <Orclev> so the do notation is passing the state around?
11:58:20 <CrazyAzrael1> The do notation is causing bind
11:58:30 <CrazyAzrael1> Look at the bind in the monad instance
11:58:50 <CrazyAzrael1> You'll see that it takes the state out of the snd of the tuple and passes it into the runState
11:59:08 <CrazyAzrael1> So when you do put, it rewrites that, which then gets passed onto the next command
11:59:17 <CrazyAzrael1> When you do get, it pulls from whatever was last passed in.
11:59:29 <Orclev> ok, that's the part I was missing... I forgot that bind is defined per monad
12:00:03 <CrazyAzrael1> Without bind, monads would be kind of silly--they'd just be imperative programming instead of user-defined semantics
12:00:29 <CrazyAzrael1> When you get done with State, read up on List, it'll probably help you get a more general view of monads.
12:00:49 <Orclev> yeah, and I was thinking of do notation as just syntactic sugar for imperative programming which I why I missed it at first
12:01:33 <path[l]> is dons here?
12:01:36 <path[l]> !seen dons
12:01:51 <CrazyAzrael1> Other fun uses of monads include statistical sampling, simulation, nondeterministic programming, and quantum programming (in simulation).
12:01:52 <Orclev> ... maybe @seen?
12:01:54 <lispy> path[l]: he's at ICFP
12:01:59 <path[l]> @seen dons
12:02:00 <lambdabot> dons is in #haskell-in-depth, #yi, #xmonad, #ghc, #haskell, #arch-haskell, #concatenative and #darcs. I don't know when dons last spoke.
12:02:02 <path[l]> oh
12:02:06 <lispy> ,seen dons
12:02:15 <path[l]> nice
12:02:29 <lispy> I thought we had that other bot, luna or something, that had a better database
12:02:43 <FunctorSalad> @bot
12:02:43 <lambdabot> :)
12:02:52 <FunctorSalad> lunabot is missing :o
12:03:00 <lispy> dun dun dun!
12:03:00 <Orclev> no clue, I haven't been around here much, but the only bot I've ever seen is lambdabot
12:03:14 <Orclev> at least that's the only one I've ever seen anyone interact with
12:03:19 <lispy> ?vixen what did you do with lunabot?
12:03:19 <lambdabot> no, why? do i seem "botty"?
12:03:31 <path[l]> Ive been struggling with haskell vs ruby performance issue for like 2 weeks now. Sadly because of my timezon I havent been able to get any help with it yet
12:03:48 <Igloo> desp: pong
12:03:48 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
12:03:49 <lispy> path[l]: what steps have you taken?
12:03:53 <Orclev> what do you mean by haskell vs ruby performance issue?
12:04:06 <lispy> Igloo: hi!  (nothing to say, just haven't seen you in a long time)
12:04:26 <path[l]> Orclev: I ported a ruby code I had written to haskell, and its just 30% faster.  =p, trying to understand why
12:04:27 <lispy> path[l]: I doubt you'll get ruby to the same level of efficiency as haskell, FWIW
12:04:43 <Orclev> lol, JUST 30%
12:04:56 <burp> lol
12:04:56 <HugoDaniel> hello
12:05:14 <Vanadium> Wait, ruby is slow as fuck, I would expect an equivalent Haskell thing to be orders of magnitude faster, not 30%
12:05:20 <path[l]> lispy: so I made sure first that I changed all my haskell data structures to the best I could find for the problem, made it strict and tail recursive. After that I profiled it and found 30% of my time is spent in GC. But couldnt do much after that
12:05:26 <dino-> Ruby is kind of incredibly, horrifically slow. Yes, what Vanadium said.
12:05:35 <path[l]> Vanadium: exactly, thats why I need help
12:05:43 <path[l]> Im trying to figure out what Im doing wrong
12:05:44 <desp> Igloo: just wondering about the status of GHC fixes for 10.6
12:05:58 <FunctorSalad> 30% is pretty little going from an interpreted language to a compiled one that in principle allows lots of optimization...
12:06:01 <path[l]> the equivalent C code is probably blazingly fast
12:06:05 <path[l]> yeah
12:06:05 <FunctorSalad> (@ Orclev)
12:06:07 <lispy> path[l]: have you read chapter 25 of real-world haskell?
12:06:08 <desp> Igloo: http://hackage.haskell.org/trac/ghc/ticket/3400 says the -m32 flags are in HEAD now, yes?
12:06:13 <path[l]> and 30% is only when compiled with O2
12:06:23 <path[l]> lispy: nope, Ill do that now :)
12:06:24 <CrazyAzrael1> path[I]: Pastebin it for us?
12:06:32 <Vanadium> path[l]: What amount of code are we talking about here?
12:06:49 <path[l]> sure, it's already there. Let me get the links. About a half pageish
12:06:51 <Igloo> desp: 10.6?
12:06:57 <lispy> path[l]: also, hp2any (install via cabal, I think the package is named hp2any-graph) is supposed to be pretty cool
12:06:59 <desp> Igloo: Mac OS X 10.6
12:06:59 <Igloo> lispy: Hi  :-)
12:07:20 <desp> Igloo: I thought it was your name on the ticket. :)
12:07:41 <path[l]> http://www.codechef.com/problems/TEAMSEL <--- problem I solved
12:07:45 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3424 <--- ruby code
12:07:52 <Igloo> Ah, I see. Yes, AFAIK it should be fine in the HEAD
12:07:52 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425 <--- haskell
12:08:07 <lispy> oh array
12:08:17 <lispy> arrays can be hard to use efficiently in hSaklel
12:08:20 <lispy> Haskell*
12:08:31 <Vanadium> Oi
12:08:52 <path[l]> well it used to be a list, I switched to an array to make it faster
12:08:54 <desp> lispy: that's a nice typo.
12:08:56 <path[l]> (and it did improve)
12:09:01 <FunctorSalad> desp: indeed
12:09:05 <path[l]> Im using the array purely for random access
12:09:20 <path[l]> and its created only once
12:09:27 <Vanadium> Right, you do not seem to be mutating it
12:09:31 <CrazyAzrael1> Yeah, it doesn't look like he's doing any modification, so the array is likely not the bottleneck
12:10:09 <Vanadium> Also it is an UArray and U means fast
12:10:15 <lispy> I think he needs to do some heap profiling
12:10:42 <path[l]> oh I forgot, Ive not pasted the latest version
12:10:46 <path[l]> let me do that quickly
12:10:53 <path[l]> I managed to get to about 60% now
12:10:59 <path[l]> but the code is SUPERR ugly
12:11:40 <lispy> does sum use foldl or foldl'?
12:11:58 <FunctorSalad> why do you need random access? don't you just need to sort the thing?
12:12:11 <FunctorSalad> I only briefly skimmed the problem spec
12:12:17 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425#a3509 <---- I went from creating a list of (,) and making it a map to creating a map and inserting into it. And it was actually faster
12:12:27 <path[l]> FunctorSalad:  no I need to create all possible subsets
12:12:27 <sjanssen> "reverse $ sort list" is slow
12:12:33 <path[l]> so I cant use a heuristic
12:12:41 <path[l]> sjanssen:  that runs once though :)
12:13:00 <FunctorSalad> path[l]: I understood it such that you are supposed to implement greedy
12:13:22 <FunctorSalad> the exact solution for knapsack is NP-hard and this seems very similar...
12:13:41 <path[l]> FunctorSalad: no the problem statement was to show that greedy doesnt work. Also this problem is not np-hard because of one difference
12:13:45 <Orclev> what exactly is this line doing? let (v,s') = x s... is that binding x to v and s to s'?
12:13:52 <CrazyAzrael1> I'm guessing createTeams is what's killing you due to allocation, but I could be wrong.
12:13:59 <path[l]> the partition problem is np hard, but this one says equal sized subsets
12:14:09 <FunctorSalad> path[l]: ahh, missed that
12:14:18 <path[l]> CrazyAzrael1: yeah most of my time is spent there
12:14:21 <lispy> Orclev: x s, would be a function call
12:14:27 <path[l]> did you see the new version CrazyAzrael1
12:14:37 <CrazyAzrael1> I think I'm looking at the new version (I refreshed)
12:14:53 <path[l]> oh ok, the one where I have 3 nested wheres =p
12:14:57 <path[l]> really ugly lol
12:15:30 <CrazyAzrael1> Specifically, IntMaps, while really fast, are a bitch to allocate and deallocate properly if I remember correctly.
12:16:36 <path[l]> hmm, is there a different structure you suggest I use? I need that mainly to group and make sure I only have one item of any type. (the fast random access is useful at that point)
12:16:49 <Lemmih> path[l]: Changing your main loop slightly cuts the runtime down from 4s to 2.3s on my box.
12:17:06 <path[l]> wow thats a huge difference, could you let me know what you did
12:17:41 <Lemmih> path[l]: Oops, sorry. From 2.7s to 2.3s
12:17:55 <path[l]> ah, still every little bit and all :)
12:18:01 <CrazyAzrael1> What I'm trying to figure out is if there is a more efficient form to hold it in while you're editing it, then once done sort of 'freeze' it into an IntMap
12:18:09 <path[l]> yeah
12:18:16 <path[l]> I dont even need an intMap
12:18:23 <path[l]> ultimately it could be a list for all I care
12:18:30 <path[l]> I just need 2 things
12:18:45 <path[l]> eleminate tuples if they are similar
12:18:51 <path[l]> err 1 thing
12:19:05 <path[l]> so if I find (3,5) and (3,6) I want (3,5)
12:19:09 <path[l]> thats really it
12:19:44 <path[l]> at the end of it all on the next iteration I end up doing a map of the keys anyway
12:20:32 <FunctorSalad> what is your general strategy at the moment? (the algorithm)
12:20:44 <CrazyAzrael1> Do you have bounds on the indexes?
12:21:06 <path[l]> CrazyAzrael1: yeah, just a sec
12:21:15 <CrazyAzrael1> If so, you could try a DiffArray over the total size
12:21:40 <CrazyAzrael1> Faster lookup afterwards, and as long as you don't do any back reference, it should internally optimize to in place updates.
12:21:49 <FunctorSalad> btw shouldn't we run it with profiling rather than guessing? ;)
12:21:52 <path[l]> FunctorSalad:  the general strategy is to first use the greedy heuristic. Then start creating all possible equal sized subsets and eleminate any branch early if it cannot beat the greedy heursitic
12:22:27 <CrazyAzrael1> FunctorSalad: I'm at work, don't trust them not to be logging (so I can't access my home box), and I don't have -prof working on my toolchain here at the moment.
12:22:31 <FunctorSalad> path[l]: it seems you could equalize the sets by a swapping tactic
12:22:39 <FunctorSalad> since as you say the sized must be equal
12:22:39 <path[l]> and I create all possible subsets by choosing first all elements from (1 to N-k) then from the previous chosen element to (N-k +1) etc
12:22:44 <FunctorSalad> but I didn't think it through
12:22:53 <FunctorSalad> *sizes
12:23:08 <path[l]> CrazyAzrael1: could you explain that a bit more
12:23:17 <path[l]> FunctorSalad:  sorry yeah I didnt quite get that either
12:23:41 <path[l]> in terms of bounds. I know the array size, so the smaller set can has N/2 elements.
12:23:55 <path[l]> Also each element can vary from 1 to 450
12:24:07 <path[l]> so I have a bound on index as N/2 -> 450N/2
12:24:15 <CrazyAzrael1> path[I]: If you have bounded indexes, you can store the current value for each in an array. If you use a DiffArray, it will allow you to have an IOarray cleanly inside functional-land
12:24:24 <path[l]> I can probably improve that by doing a first pass and grabbing the max and the min
12:24:24 <CrazyAzrael1> Sure
12:24:30 <CrazyAzrael1> So then you make an array sufficiently big
12:24:49 <CrazyAzrael1> And access/insertion on a diffarray (so long as you don't backtrack) should be O(1)
12:24:56 <path[l]> do you mean an array where I populate the i'th element instead of using i as an index?
12:25:04 <CrazyAzrael1> yes.
12:25:06 <path[l]> hmm
12:25:14 <CrazyAzrael1> But a regular Array will be slow (due to copying)
12:25:28 <CrazyAzrael1> So you can either muck up your code really hard with an IOArray (which will be the fastest)
12:25:37 <CrazyAzrael1> Or be careful to avoid backreference, and use DiffArray
12:25:42 <path[l]> hmm
12:25:49 <path[l]> let me read up about a DiffArray
12:25:52 <path[l]> but one question
12:25:59 <Orclev> so if I'm reading this right... StateT is used to wrap another monad in state?
12:26:04 <ezyang> When should I use Either and when should I use MonadError e m => ErrorMonad?
12:26:07 <path[l]> in general my hash would at any time have much less elements than the array would
12:26:10 <CrazyAzrael1> Orclev: Yes, it's a monad transformer
12:26:17 <FunctorSalad> path[l]: I'd have to think about it
12:26:18 <CrazyAzrael1> path[I]: Yup
12:26:32 <path[l]> Also each iteration Id have to iterate over the ENTIRE array to find which elements have been allocated
12:26:37 <path[l]> I wouldnt care about the 0s
12:26:49 <aavogt> DiffArray seems to be unloved: http://hackage.haskell.org/trac/ghc/ticket/2727
12:27:02 <Orclev> CrazyAzrael1: so all these monads that end in T, are those all transformers then that wrap other monads?
12:27:09 <CrazyAzrael1> Orclev: Yes
12:27:24 <CrazyAzrael1> aavogt: Sometimes it's slower, specifically if you have any backreference
12:28:20 <FunctorSalad> path[l]: btw there's always ST but that wouldn't be  appropriate purity propaganda of course *g*
12:28:32 <path[l]> so if I had about 45000 elements. Every time I create subsets, Id be running through this array to find which elements had values and which ones were empty
12:28:46 <Itkovian> Anybody seen this visualisation? http://www.youtube.com/watch?v=lP3JaOFy-qM
12:28:49 <path[l]> FunctorSalad:  ah to tell the truth Im new to haskell, so I dont understand monads well yet =p
12:28:57 <path[l]> Im still reading those bits
12:28:58 <path[l]> lol
12:29:11 <path[l]> anyway let me read through those suggestions
12:29:14 <CrazyAzrael1> aavogt: I'm looking at that code though, and not seeing any backreference, which is weird. I've gotten 40-50% speedups in a few programs by using DiffArrays
12:29:28 <FunctorSalad> path[l]: ST is a monad for mutatable data
12:29:50 <FunctorSalad> it's different from IO in that you can extract the result purely
12:30:08 <FunctorSalad> (because ST "can't launch missiles", the slogan goes)
12:30:23 <lispy> :t runST
12:30:24 <lambdabot> forall a. (forall s. ST s a) -> a
12:30:31 <path[l]> hmm
12:30:48 <CrazyAzrael1> Yeah, if you were thinking about doing my suggestion of using an IOArray, don't, use ST instead
12:31:04 <path[l]> how would I use ST?
12:31:12 <lispy> ?hoogle STUArray
12:31:13 <lambdabot> Data.Array.Base data STUArray s i a
12:31:13 <lambdabot> Data.Array.Base STUArray :: i -> i -> Int -> MutableByteArray# s -> STUArray s i a
12:31:13 <lambdabot> Data.Array.ST data STUArray s i a
12:31:22 <lispy> path[l]: you'd probably use that type
12:31:33 <path[l]> ah you mean its an array which is mutable?
12:31:41 <lispy> mutable and unboxed
12:31:49 <lispy> there is a boxy version if you need it
12:31:51 <path[l]> ah
12:31:55 <path[l]> hmm
12:32:05 <path[l]> is there a mutable hash?
12:32:06 <CrazyAzrael1> STU = riced to high hell
12:32:18 <path[l]> Thats probably the one that easily replaces my IntMap
12:32:22 <lispy> CrazyAzrael1: all the gentoo users in the house say, hey!
12:32:22 <path[l]> sorry mutable map
12:32:42 <path[l]> Im not sure if the array version will work for the problem I was describing earlier
12:32:47 <lispy> CrazyAzrael1: (sorry, when someone talks about riced things I think of gentoo)
12:33:04 <CrazyAzrael1> lispy: It's OK-everyone's tried gentoo once or twice.
12:33:23 <lispy> it is a cool idea
12:33:33 * lispy hugs debian
12:33:45 <elbar> pfft...
12:33:45 * Elly has one gentoo box and six debian boxes :P
12:33:53 <doublethink_work> <3 archlinux
12:34:05 <benmachine> I don't think I <3 any of them
12:34:09 <doublethink_work> but debian is pretty nice, although I am never upgrading to sid again because my vmware instance broke horribly immediately afterwords
12:34:12 <benmachine> arch is very nice but I don't really like pacman
12:34:20 <doublethink_work> benmachine: i use yaourt
12:34:27 <doublethink_work> automatic AUR installs, aur voting, etc
12:34:27 <benmachine> doublethink_work: that's not really better :P
12:34:46 <doublethink_work> pacman has yet to fail me on anything - care to list some problems?
12:34:52 <path[l]> ok thanks guys, I was hoping I wouldnt have to use a mutable structure, but oh well. now it feels like Im going the imperative route lol
12:34:53 <doublethink_work> personally I think all distro package managers suck
12:35:04 <benmachine> yeah I'm inclined to agree
12:35:25 <FunctorSalad> path[l]: I wasn't saying there isn't a nice pure solution, I just didn't think about it yet
12:35:26 <CrazyAzrael1> For me, Ubuntu goes on the laptops and on other people's computers, debian goes on the servers and desktops, gentoo alternate boot on the desktop for rice-offs
12:35:34 <doublethink_work> yaourt is particularly nice because AUR has a bit of stuff that I want but isn't in community
12:35:44 <benmachine> (pacman hasn't done anything horrible to me, but I didn't like how long it took me to memorise how to get stuff; I don't think the man page is very well written)
12:35:52 <CrazyAzrael1> doublethink_work: I've found apt to be pretty nice, other than its build facility.
12:36:19 <benmachine> I do like about arch how easy it is to choose between binary and source
12:36:29 <benmachine> (i.e. ABS)
12:36:33 <desp> Igloo: FYI, http://trac.macports.org/ticket/20132#comment:19
12:36:39 <path[l]> oh ok
12:36:41 <doublethink_work> CrazyAzrael1: apt is pretty good, yeah
12:37:20 <benmachine> I don't think I had any particular objections to apt, but I didn't get on with ubuntu because it tends to be always one version behind
12:37:31 <benmachine> (i.e. python 2.5 ghc 6.8)
12:37:48 <FunctorSalad> path[l]: what libraries can one use?
12:37:49 <benmachine> also it is slow to boot
12:38:06 <CrazyAzrael1> benmachine: Yeah, I only use ubuntu on systems that are either "end user"y, or for which the drivers might be a pain otherwise.
12:38:24 <doublethink_work> benmachine: debian/ubuntu patch their stuff like crazy which is why it's normally a little behind
12:38:35 <benmachine> doublethink_work: I don't particularly like that either
12:38:44 <doublethink_work> me neither
12:39:14 <doublethink_work> like I said, they all suck in a lot of different ways. :) I think yaourt + pacman is my favorite so far because it's just "yaourt pkgname", although yaourt can bug you with conformations
12:39:26 <benmachine> I've actually been wondering about how practical it would be to create a package manager that could work with multiple package formats, to make things easier for distributors
12:39:28 <Orclev> I noticed reading the urxvt site that he seems to have a bone to pick with gentoo
12:39:41 <Orclev> benmachine: alien, does that more or less
12:39:43 <benmachine> doublethink_work: isn't it yaourt -S, or is -S default
12:39:51 <lispy> benmachine: didn't the smart project do that?
12:39:53 <hackagebot> haskell-src-exts 1.1.4 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
12:39:56 <benmachine> Orclev: oh yeah that's a name I've heard before, but I never looked it up
12:39:57 * benmachine does
12:40:07 <benmachine> it'd be really nice to have a pm standard
12:40:11 <Orclev> benmachine: it's a program that converts between various package formats
12:40:20 <lispy> benmachine: http://labix.org/smart
12:40:33 <Orclev> benmachine: doesn't really work as a "universal" package manager, but it lets you use a foreign package in your native format
12:41:13 <benmachine> I think smart sounds interesting
12:41:20 <Orclev> I've been eyeballing arch linux lately... I've never used it, but it's peaked my interest
12:41:21 <Athas> Is it possible to use Cabal to deal with normal installation things, like moving binaries to /usr/bin, handling data that needs to go in /usr/share, and setting up man/infopages?
12:41:36 <Orclev> Athas: cabal install --global so far as I know
12:41:43 <benmachine> I think there's no reason why distributions should differ in anything other than their package *set* rather than their tool to download and install them
12:42:04 <benmachine> since the tools differ in usually only trivial ways
12:42:33 <benmachine> Orclev: I would recommend arch if and only if you enjoy playing with things and learning about your system and have the time to spend doing so
12:42:45 <Orclev> benmachine: I'm using gentoo currently ;P
12:42:50 <benmachine> haha
12:43:03 <benmachine> then I guess arch would be more of a sideways move than up or down?
12:43:09 <Orclev> yeah
12:43:12 * benmachine convoluted spatial analogy
12:43:34 <Orclev> arch looks like a little bit easier to manage than gentoo though
12:44:39 <doublethink_work> benmachine: -S is default, if you do 'yaourt pkg' it searches for things matching the phrase 'pkg' across the repositories and returns a list of results for you to choose from
12:44:46 <Orclev> I'm getting a little sick of random packages insisting on rebuilding xulrunner
12:44:55 <benmachine> doublethink_work: ah, fair enough
12:45:01 <doublethink_work> well, I guess for varying definitions of 'default', but search + install is the default operation
12:45:12 <doublethink_work> which is quite handy sometimes
12:45:57 <Orclev> has anyone else seen the rant about gentoo on the urxvt page?
12:46:04 <elbar> ofc
12:46:15 <Orclev> ofc?
12:46:24 <elbar> that guy seems to have mental problem
12:46:49 <benmachine> (ofc[ourse])
12:46:50 <Orclev> what's ofc mean?
12:46:52 <Orclev> ah
12:46:54 <Orclev> ok
12:47:07 <CrazyAzrael1> elbar: You would too if you maintained a terminal emulator long term
12:47:13 <Orclev> lol
12:47:15 <elbar> gentoo can build 1500 and more packages from source with no problem and he thinks it totaly broken?
12:47:40 <burp> no reason to use gentoo except wasting energy :p
12:47:49 <path[l]> FunctorSalad:  only inbuilt
12:48:01 <Orclev> actually from the sounds of it his biggest bone is with the fact that the gentoo maintainer would *gasp* dare to patch his sources without explicit written consent
12:48:05 <elbar> i like it to be able to build kde 4 from trunk
12:48:38 <elbar> use ur 3.5.10 or ghc-6.8.2 if you want....
12:48:59 <CrazyAzrael1> burp: Not wasting energy if you live in a cold climate--any energy put into your computer comes out as heat, which reduces your heating bill.
12:49:01 <benmachine> I kind of wonder given that it must be one of the most commonly-used applications why terminal emulators aren't better
12:49:14 <benmachine> (commonly-used by people in a position to improve them, I mean)
12:49:34 <Orclev> benmachine: nothing itches bad enough to scratch
12:49:36 <CrazyAzrael1> benmachine: They have to conform to a lot of specs related to their operation
12:49:37 <burp> CrazyAzrael1: oh, sure :)
12:49:45 <srush> so, when using TypeFamilies, is there any way to specify the typeclass of internal types
12:49:45 <elbar> btw i'm currently using that bloody terminal ...
12:49:58 <Orclev> elbar: likewise
12:49:59 <benmachine> I had one that tended to segfault when you changed the user settings
12:50:02 <CrazyAzrael1> xterm ftw
12:50:11 <burp> I wonder if this is the cheapest way to heat
12:50:21 <benmachine> I don't know if it still does, but it forgets one on a regular basis
12:50:21 <srush> like class Test where type Element :: (Show) *
12:50:34 <CrazyAzrael1> burp: No, it isn't. It's only a reasonable idea if you're actually getting something from the compute as well.
12:50:54 <CrazyAzrael1> burp: Kind of like how Peltier coolers don't actually work how you'd want them to.
12:51:04 <srush> class Map where type Key :: (Ord)
12:51:11 <Orclev> I used to use eterm long ago
12:51:22 <Orclev> CrazyAzrael1: peltier cooler is just a solid state heat pump
12:51:45 <elbar> urxvt or whatever its called works  nice with xmonad
12:51:53 <CrazyAzrael1> Orclev: Yes, my point is that solid state heat generation/moving is generally fairly inefficient and doesn't do what you hope it would.
12:52:16 <CrazyAzrael1> Orclev: If you are heating, you could have used whatever produced the electricity in the first place, and skipped a few steps
12:52:32 <CrazyAzrael1> Orclev: If you are cooling, a peltier cooler has a side that needs to be cooled, or it doesn't work
12:52:33 <Orclev> CrazyAzrael1: yeah, but who uses a peltier for heating? That's just stupid
12:53:13 <pcc1> is there a way of adding an "uninstall" target to cabal?
12:53:14 <CrazyAzrael1> Orclev: You are completely missing my point-it was that electrical temp manipulation via solid state is generally a poor idea.
12:53:18 <aavogt> speaking of haskell-src-exts, are there any alternate PPHsModeS out there?
12:53:46 <burp> > 2^8 - 1 :: Word8
12:53:47 <lambdabot>   255
12:53:50 <burp> > 2^8 +1 :: Word8
12:53:52 <lambdabot>   1
12:54:06 <Vanadium> > -1 :: Word8
12:54:07 <lambdabot>   255
12:54:09 <Orclev> CrazyAzrael1: actually it's a really great idea if used properly... there's been talk of building peltiers into the tops of CPU/GPUs
12:54:40 <elbar> Orclev: its never a good idea...
12:54:47 <Vanadium> > -1 + sum (repeat [2^8]) :: Word8
12:54:49 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
12:55:01 <Vanadium> err.
12:55:19 <Vanadium> > -1 + sum (repeat $ 2^8) :: Word8
12:55:22 <benmachine> so I've read about class aliases and think they would be really cool
12:55:30 <Orclev> elbar: put a peltier inside the CPU die just below the heatspreader and it helps mitigate hot spots for a more even heat distribution across the top of the chip
12:55:33 <burp> heating up lambdabot :p
12:55:35 <lambdabot>   thread killed
12:55:39 <CrazyAzrael1> Orclev: Yes, but they only work correctly if you couple them with fans or heatsinks
12:56:03 <Vanadium> stupid lambdabot :(
12:56:03 <benmachine> are they implemented anywhere and if not then what is stopping them (optional: how can I help remove such obstacles)
12:56:08 <Orclev> CrazyAzrael1: actually that's a waste, better to couple them with a phase change cooler
12:56:09 <burp> > fromIntegral $ 2^256 - 1 :: Word256
12:56:16 <lambdabot>   mueval-core: Prelude.read: no parse
12:56:16 <lambdabot>  mueval: ExitFailure 1
12:56:17 <elbar> using electricity to produce heat sux in general
12:56:24 <burp> seems he doesn't have Data.LargeWord
12:56:29 <elbar> although its done alot ;)
12:56:37 <CrazyAzrael1> Orclev: Phase change coolers are hella expensive and there's a lot of failure modes
12:56:58 <Orclev> CrazyAzrael1: actually they're not that expensive anymore... but you're right, they can fail in a whole lot of ways
12:57:10 <Orclev> CrazyAzrael1: but if you want sub-ambient they're really the only practical solution
12:57:43 <CrazyAzrael1> Orclev: for CPUs, sub-ambient is not necessary
12:58:01 <Orclev> CrazyAzrael1: necessary? no... fun, definitely :P
12:58:12 <CrazyAzrael1> Unless you've got an Async CPU, in which case I want to know who sold it to you, and you definitely want to strap it on.
12:58:34 <Orclev> async cpu?
12:58:58 <CrazyAzrael1> Asynchronous VLSI is a technology wherin you use handshaking rather than a clock signal and wait states to do signal propogation
12:59:23 <CrazyAzrael1> The result is a CPU that is able to dynamically change speeds based on available voltage and temperature--the better its parts are working, the faster it goes
12:59:32 <Orclev> ah, are there any comercial implementations of that?
13:02:27 <CrazyAzrael1> The only ones I know of are some switches made by a place called Fulcrum Microsystems and a few printers by Epson
13:02:47 <CrazyAzrael1> Epson was using it to make the CPUs bendable, and Fulcrum was using it to minimize latency
13:02:59 <CrazyAzrael1> (as this lets them shave off the parts of wait states that aren't strictly necessary
13:03:10 <CrazyAzrael1> And I'm off (gotta give a presentation)
13:03:24 <erikc> when i was in ece classes 5 years ago, my profs claimed async vlsi was 'the future'
13:03:38 <erikc> and were all excited about it
13:03:44 <Orclev> hmm... I found some mention of old MIPS processors based on it... and a press release from 2004 claiming ARM was making one
13:04:59 <Orclev> I wonder how a async CPU compares to a normal CPU at equal temps/voltages... probably worse I imagine as that's usually the way these things work
13:06:14 <dbpatterson> is there any simple library for two way encryption? Something that can take a RandomGen, create a key really easily, and then encrypt a bytestring with the key and decrypt it later? It can even be only private key. I've been wrestling with the various things in Codec.Crypto and either they are only encrypting Word128s or they are throwing exceptions on me.
13:07:12 <Orclev> technically isn't a one way encryption a hash?
13:08:12 <dbpatterson> Orclev:
13:08:16 <dbpatterson> two way encryption
13:08:22 <dbpatterson> (sorry hit enter by accident)
13:08:49 <Orclev> yeah, I know, I'm just thinking when you say encryption it should normally imply two way
13:08:58 <Orclev> unless I'm missing something
13:09:12 <Orclev> which wouldn't surprise me much
13:09:55 <dbpatterson> you may be right... either way, however it is called, I am looking for the style of cryptography when you make something unreadable and later on can make it readable, based on a secret key you have.
13:11:07 <Orclev> well, Codec.Crypto.RSA will do PKI crypto... still looking for some other modules
13:11:30 <aavogt> dbpatterson: you've tried these functions here to convert to [Octet]: http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Codec-Utils.html
13:12:34 <ezyang> If I have a data type and an instance and want to find out where it's defined, how do I go about doing that?
13:12:54 <benmachine> dbpatterson: do you care if the encryption is symmetric or asymmetric?
13:13:09 <dbpatterson> aavogt: no not yet; but it only takes integrals (perhaps I'm really dumb, but how do I take a string or bytestring and turn it into an integral)?
13:13:23 <woggle> dbpatterson: OpenSSL.EVP.Cipher looks relevant.
13:13:29 <ezyang> (I'm pretty good at finding the 'class' definition and the data type itself, but not the 'instance')
13:13:46 <benmachine> ezyang: try :info in ghci
13:14:35 <dbpatterson_> it's not important symmetric vs assymetric
13:14:43 <dbpatterson_> looking at the OpenSSL lib
13:16:01 <ezyang> benmachine: Ah, excellent!
13:17:55 <jethr0> getting MinGW/MSYS to actually run takes quite a bit of tenacity
13:18:06 <aavogt> dbpatterson_: for bytestrings, you can just use Data.ByteString.unpack... but maybe there are more efficient ways of directly encryping the bytestring
13:18:25 <dbpatterson_> hmm... OpenSSL is segfaulting... this is why we don't like to C libraries!
13:18:32 <erikc> jethr0: especially on 64-bit vista
13:18:41 <erikc> where it takes an act of god
13:18:47 <jethr0> *brrr*, don't even want to think about that
13:19:02 <Adamant> Win7 is coming, look busy
13:20:15 <ezyang> Oh doh, these instance signatures are confuuusing
13:23:17 <kmc> ezyang, which ones
13:24:14 <Orclev> erikc: Hah, try doing it on XP 64-bit
13:24:21 <ezyang> Something like instance (Error e) => Monad (Either e)
13:24:29 <ezyang> which messes up my parsing
13:24:35 <kmc> ezyang, do you want hints
13:24:43 <ezyang> I know what the parse is now :-)
13:26:46 <Orclev> ok, so just to see if I'm getting this... (ReaderT (String, String, Int) IO) a... declares a new type of a that is wrapped in a IO and Reader monad and that has an environment of two strings and a int?
13:27:34 <Orclev> the parens might not be necessary around that... the code I'm looking at actually has like 4 more transforms applied around all that
13:27:56 <ezyang> Orclev: sounds about right
13:28:02 <kmc> Orclev, that's just a type, it doesn't declare anything.  but otherwise, yes
13:29:17 <kmc> @src ReaderT
13:29:17 <lambdabot> Source not found. Take a stress pill and think things over.
13:30:35 <aavogt> @unmtl ReaderT String IO
13:30:35 <lambdabot> err: `ReaderT String IO' is not applied to enough arguments, giving `/\A. String -> IO A'
13:30:42 <aavogt> @unmtl ReaderT String IO a
13:30:42 <lambdabot> String -> IO a
13:31:02 <kmc> big lambda!
13:31:13 <kmc> :k ReaderT String IO
13:31:15 <lambdabot> * -> *
13:31:22 <kmc> :k Int#
13:31:22 <ezyang> I have a simple source file that I'm trying to generate docs for with Haddock, but I'm getting: "Main: could not find link destinations for:     GHC.IOBase.IO". Any suggestions?
13:31:23 <lambdabot> Not in scope: type constructor or class `Int#'
13:31:50 <aavogt> ezyang: those aren't fatal
13:32:10 <aavogt> I guess you don't have that documentation installed
13:32:10 <kmc> :k ReaderT
13:32:12 <lambdabot> * -> (* -> *) -> * -> *
13:32:28 <ezyang> aavogt: Ah, ok. Where does the documentation go to live, then?
13:32:49 <aavogt> ?docs GHC.IOBase.IO
13:32:49 <lambdabot> GHC.IOBase.IO not available
13:32:59 <aavogt> ?docs IO
13:32:59 <lambdabot> IO not available
13:33:06 <aavogt> ?docs System.IO
13:33:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
13:33:09 <benmachine> it annoys me that `on` is infixl 0
13:33:24 <benmachine> it can't be combined with $
13:33:29 <ezyang> Oh, I mean, the docs that haddock generates
13:33:56 <aavogt> ezyang: my install of ghc includes those docs, and haddock manages to find them...
13:34:12 <ezyang> (what I'm actually trying to do is get a birds eye view of my functions and their type signatures)
13:34:36 <ezyang> aavogt: My install of ghc is... kind of special
13:39:29 <dons> experience report from icfp on building trading systems in haskell, http://www.reddit.com/r/programming/comments/9h26x/live_from_icfp_experience_report_haskell_in_the/
13:39:33 <dons> check it out.
13:39:39 <dons> and thank cjs for the work
13:39:49 <yrlnry> Suppose I'm making a state transformer monad.  such monads normally have type state -> (val, state), where val and state are independent.  But in this case I want the state to be of type (Queue a) and val = a, so the value is the same type as the data stored in the queues.  But I can't declare this as an instance of Monad, I think because the type is insufficiently general.  (GHC says "Couldn't match expected type `b' against inferred type `a
13:39:49 <yrlnry> ';  `b' is a rigid type variable bound by the type signature for `>>='...")
13:39:55 <yrlnry> Am I making a conceptual error here?
13:40:10 <kmc> that's not a monad
13:40:14 <yrlnry> It's not?
13:40:26 <yrlnry> Oh, because it doesn't upport fmap?
13:40:33 <periodic> Man, the haskell channel is just humming.  So many other channels have one brief exchange daily.  I wish I spent more time with haskell...
13:40:46 <kmc> a monad is a type of kind * -> *, meaning it can be applied to *any* type
13:40:57 <kmc> :t return
13:40:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:41:21 <yrlnry> My monad is QueueState, where QueueState a = (Queue a -> (a, Queue a)).  The kind is correct.
13:41:22 <benmachine> yrlnry: maybe you could do type MyType = StateT (Queue a) m a
13:41:33 <benmachine> er
13:41:36 <benmachine> no you couldn't
13:41:48 <kmc> so, maybe i'm misunderstanding
13:52:21 <yrlnry> Do you think it might help for me to paste the code?
13:52:21 <kmc> yes
13:52:21 <yrlnry> Just a minute.
13:52:21 * aavogt is confused as to whether partially applied types can be called types
13:52:21 <benmachine> aavogt: type constructors?
13:52:21 <dons> periodic: just do it.
13:52:21 <kmc> or sometimes higher-kinded types?
13:52:21 <yrlnry> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9010#a9010
13:52:21 <dons> visit hackage.haskell.org/platfor and start coding in 10 seconds.
13:52:21 <yrlnry> Please pardon my awful variable names.
13:52:21 <kmc> why does newQueue take an argument of type ()
13:52:21 <yrlnry> No reason at all.
13:52:21 <mauke> should be called Queue.empty :-)
13:52:21 <mauke> yrlnry: I can't typecheck fv q1
13:52:21 <aavogt> benmachine, kmc: yeah, those names sound right.
13:52:21 <mauke> fv takes a 'b', q1 is an 'a'
13:52:21 <flazz> how can i uninstall something from cabal
13:52:21 <flazz> ?
13:52:21 <yrlnry> mauke:  that's the whole problem.   I want it to infer that f must have type a -> QueueMonad a, not a -> QueueMonad b.  It correctly infers that, but that is not sufficiently genrea lfor >>=.
13:52:21 <yrlnry> s/genrea l/general /
13:52:21 <kmc> yrlnry, that's why it's not a monad
13:52:21 <kmc> :t (>>=)
13:52:21 <mauke> yrlnry: wait, it's actually qt q
13:52:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:52:21 <lispy> "...and facilities that would allow us easily to use parallelism."  <-- yeah, big with for haskell
13:52:21 <yrlnry> kmc:  I think it actually fails to be a functor.
13:52:21 <kmc> :t fmap
13:52:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:52:21 <yrlnry> I wonder what it is I really want here.
13:52:21 <kmc> yrlnry, why do you need to decouple the state?
13:52:21 <kmc> err to constrain it
13:52:21 <yrlnry> kmc:  That may be just the right question.  I'm going to think about it a minute . Thanks.
13:52:21 <kmc> instead of "QueueMonad a" you might want "QueueMonad a ()"
13:52:21 <yrlnry> I hate >>=.  I think from now on I'm going to define everything in terms of fmap or >=>.
13:52:21 <kmc> that way the state type is fixed, but not coupled to the monadified type
13:52:21 <ezyang> yrlnry: :-/ I find it generally useful?
13:52:21 <kmc> and you can provide getQueue :: QueueMonad a a
13:52:21 <mauke> it's just fmap + join
13:52:21 <yrlnry> Yes, I know.
13:52:21 <roconnor> and return
13:52:21 <yrlnry> It lacks symmetry.
13:52:22 <etpace_> If I have a Parser with type String -> [(String, a)], how would I create a parser that 'eats' a character (that is, returns tail string), but doesn't return an a?
13:52:33 <mauke> (=<<) :: (a -> m b) -> m a -> m b
13:52:41 <etpace_> basically a 'ignore character' parser
13:52:55 <yrlnry> etpace_:   String -> [(String, ())]
13:53:00 <kmc> :t \s -> [(tail s, ())]
13:53:01 <mauke> etpace_: why do you care what it returns?
13:53:01 <ezyang> etpace_: Follow the types!
13:53:01 <lambdabot> forall a. [a] -> [([a], ())]
13:53:31 <etpace_> hmm, thats true mauke
13:53:48 <ezyang> Do people prefer to directly say Either MyError or typedef it to be something like ErrorMonad or something else? And if the latter, what name do you like?
13:54:02 <kmc> ezyang, i prefer to newtype my monads
13:54:33 <ezyang> kmc: Mmm, interesting.
13:54:48 <ezyang> I guess that gives you more flexibility
13:55:05 <kmc> i have a lot of code like
13:55:36 <kmc> newtype FooM a = FooM (ErrorT FooError (State FooState) a) deriving (Monad, MonadPlus, MonadState FooState, MonadError FooError)
13:56:00 <ezyang> do you... need a GHC extension to do that?
13:56:03 <yrlnry> I thought you couldn't deriving Monad.
13:56:06 <kmc> which admittedly once you've derived MonadState and MonadError you've sucked a lot of things into the newtype
13:56:12 <kmc> but at least you can easily change it later
13:56:24 <yrlnry> I thought deriving worked only for Eq, Ord, Show, and Read.
13:56:24 <kmc> yrlnry, ezyang, yes, it's GeneralizedNewtypeDeriving
13:56:35 <yrlnry> Okay.
13:56:48 <kmc> yrlnry, since a newtype wraps one and only one type, GHC lets you derive any of the inner type's instances
13:56:57 <jethr0> does anybody know the process by which "runghc Setup.hs build" gathers the build flags, etc? does it come from configure.ac?
13:56:59 <yrlnry> That makes sense.
13:57:23 <benmachine> jethr0: from runghc Setup.hs configure, I think
13:57:40 <benmachine> i.e. from a .cabal file
13:58:14 <jethr0> yes, that i understand. but where do all the build commands come from for the build stage?
13:58:44 <kmc> yrlnry, also Enum and Bounded
13:58:55 <kmc> and GHC has an unrelated extension for Typeable and Data
13:59:08 <yrlnry> kmc:  that's not H98, is it?
13:59:14 <kmc> Enum and Bounded are
13:59:16 <kmc> iirc
13:59:36 <kmc> Typeable and Data are not, they come from the Scrap your Boilerplate series of papers and are used for generic programming and runtime type introspection
13:59:47 <benmachine> you definitely get Enum and Bounded without any -Xs
14:00:13 <kmc> Typeable gives you a runtime description of the type's structure from a (unevaluated) value of the type
14:00:14 <yrlnry> "# C is one of Eq, Ord, Enum, Bounded, Show, or Read."
14:00:23 <yrlnry> Funny, I thought there were only four.  Thanks.
14:00:39 <kmc> Data allows you to do generic structural recursion on the data in the type
14:01:06 <jethr0> hmm
14:05:45 <ezyang> Suggestions for function with type ErrorMonad a -> IO a, which terminates if ErrorMonad a is a failure?
14:06:41 <jmcarthur_work> terminates... the program?
14:06:49 <ezyang> jmcarthur_work: by returning bottom
14:06:51 <yrlnry> Got my QueueMonad to compile.  I did have a conceptual problem.   Thanks very much to kmc and mauke and anyone else who helped.
14:07:00 <ezyang> basically, "this pure computation failed, we canot proceed in a meaningful way"
14:07:00 <jmcarthur_work> so you mean it *doesn't* terminate ;)
14:07:13 <ezyang> *cannot
14:07:19 <ezyang> jmcarthur_work: haha, true dat
14:07:26 <yrlnry> Unsurprisingly, once I finished the definition, it was exactly the same as the definition of >>= for any other state transformer monad.
14:07:49 <desp> > listArray (1 :: Int, 1 :: Int) [1 :: Int]
14:07:50 <lambdabot>   array (1,1) [(1,1)]
14:07:59 <desp> So why doesn't that work in ghci?
14:08:06 <desp> > listArray (1, 1) [1]
14:08:08 <lambdabot>   array (1,1) [(1,1)]
14:08:12 <benmachine> what does it do
14:08:22 <ezyang> jmcarthur_work: do you have any suggestions?
14:08:28 <desp> The former does:  No instance for (IArray a Int)
14:08:29 <kmc> desp, import Array?
14:08:30 <jmcarthur_work> ezyang, what exactly is ErrorMonad?
14:08:38 <desp> The latter does:  Ambiguous type variables `t', `a' in the constraint
14:08:48 <kmc> it works for me after the import
14:09:01 <yrlnry> And then my queueMonad "get" function has type QueueMonad a a, which is as it should be.
14:09:01 <ezyang> jmcarthur_work: typedef ErrorMonad a = ErrorMonad (Either MyError a)
14:09:11 <ezyang> Where MyError is an instance of Error and Exceptoin
14:09:11 <desp> Doh.
14:09:14 <ezyang> *Exception
14:09:19 <desp> I was importing Data.Array.IArray
14:09:20 <jmcarthur_work> ezyang, is typedef type or newtype?
14:09:25 <desp> Thanks, I guess.
14:09:35 <jmcarthur_work> newtype i assume?
14:09:40 <jmcarthur_work> since you have a constructor?
14:09:55 <kmc> ezyang, do you want perhaps something of type (MonadError e m) => m a -> IO a
14:10:04 <kmc> that'd be the most general
14:10:10 <jmcarthur_work> ezyang, \(ErrorMonad (Right a) -> return a
14:10:13 <ezyang> jmcarthur_work: newtype
14:10:32 <jmcarthur_work> ezyang, it's _|_ if it has Left err
14:11:02 <ezyang> kmc: I'm not quite sure if I want generality.
14:11:28 <ezyang> jmcarthur_work: That almost works, except that Left err has useful info that I'd like not to get lost
14:11:32 <jmcarthur_work> kmc, i have doubts that that is possible
14:11:43 <jmcarthur_work> ezyang, it is necessarily lost if the result must be _|_
14:11:54 <ezyang> Ah, but then the trick is, I use exceptions
14:12:27 <jmcarthur_work> :t either
14:12:28 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:13:06 <kmc> jmcarthur_work, ah, yes, because runError and friends are not in MonadError
14:13:10 <desp> > listArray (2, 2) [1, 2, 3, 4]
14:13:11 <lambdabot>   array (2,2) [(2,1)]
14:13:15 * benmachine wonders if there is any practical use to forever' a x = a x >>= forever' a
14:13:22 <desp> What's wrong with this, though?
14:13:30 <kmc> was thinking you could do something clever with catchError but i guess not
14:13:51 <ezyang> jmcarthur_work: Using either would still result in a little duplicated boilerplate?
14:14:05 <jmcarthur_work> ezyang, \(ErrorMonad a) -> either (throw and stuff) return a
14:14:24 <jmcarthur_work> ezyang, i don't understand what you mean
14:14:36 <desp> :t listArray
14:14:37 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
14:14:48 <desp> So it should take a plain list of elements, and not pairs.
14:15:32 <ezyang> jmcarthur_work: As in, ErrorMonad is the essential parameter, and this is something that I'm going to have to commonly do coming out of ErrorMonad into IO, so make it into a function
14:16:05 <jmcarthur_work> ezyang, then define a function
14:16:12 <ezyang> And thus I need a name :-)
14:16:24 <jmcarthur_work> rethrow?
14:16:32 <jmcarthur_work> i dunno
14:16:36 <ezyang> I like that
14:16:39 <jmcarthur_work> i don't use exceptions
14:16:49 <jmcarthur_work> when i can help it, at least
14:16:52 <ezyang> >.>
14:16:57 <ezyang> Wow, no one uses exceptions
14:17:14 <jmcarthur_work> i just find them mostly unnecessary and hard to reason about
14:17:39 <jmcarthur_work> hard to avoid in an imperative language, but i haven't really had to touch them at all in haskell yet
14:17:54 <jmcarthur_work> i'm sure there are cases where it makes sense to use exceptions. i just haven't found one yet, myself
14:18:03 <ezyang> jmcarthur_work: How do you terminate execution in programs you write?
14:18:25 <jmcarthur_work> ezyang, normally it just gets to the end of main
14:18:30 <jmcarthur_work> ezyang, or i use exit, if not
14:18:36 <lispy> :t exit
14:18:38 <lambdabot> Not in scope: `exit'
14:18:41 <jmcarthur_work> i assume you mean how do i terminate the whole program
14:18:46 <jmcarthur_work> @hoogle exist
14:18:46 <lambdabot> Distribution.Extension ExistentialQuantification :: Extension
14:18:46 <lambdabot> Language.Haskell.Extension ExistentialQuantification :: Extension
14:18:46 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
14:18:48 <jmcarthur_work> @hoogle exit
14:18:48 <lambdabot> module System.Exit
14:18:48 <lambdabot> System.Exit data ExitCode
14:18:48 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
14:18:54 <jmcarthur_work> System.Exit.exit
14:19:07 <glguy> benmachine: I've used such a forever' before
14:19:18 <jmcarthur_work> :t iterateM
14:19:19 <lambdabot> Not in scope: `iterateM'
14:19:24 <jmcarthur_work> @hoogle iterateM
14:19:24 <lambdabot> No results found
14:19:28 <glguy> jmcarthur_work: iterateM_
14:19:32 <jmcarthur_work> aha!
14:19:35 <jmcarthur_work> :t iterateM_
14:19:37 <lambdabot> Not in scope: `iterateM_'
14:19:41 <jmcarthur_work> aha....
14:19:43 <glguy> I didn't say it existed
14:20:09 <jmcarthur_work> i know i've seen it before. has to be in a package somewhere
14:21:09 <ezyang> jmcarthur_work: I guess I'm using exceptions for essentially ~that purpose
14:21:34 <ezyang> (because I've found that I get better composability in Python if I use uncaught exceptions to terminate execution as opposed to calling sys.exit)
14:21:37 <benmachine> I googled and found a haskell-cafe thread
14:21:44 <glguy> :t fix . (>=>)
14:21:46 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
14:21:51 <benmachine> http://www.mail-archive.com/haskell-cafe@haskell.org/msg57678.html
14:22:07 <glguy> iterateM_ = fix . (>=>)
14:22:26 <jmcarthur_work> ezyang, well surely it's still nicer to handle the exceptions and terminate cleanly, even if only at the top level...
14:22:56 <ezyang> jmcarthur_work: *shrugs* it's all mostly boilerplate, right? Throw an error code, print an error message, terminate
14:23:26 <jmcarthur_work> ezyang, you are getting these errors from pure code?
14:23:47 <ezyang> jmcarthur_work: yes, but the pure code generates an Either (or, soon, an ErrorMonad)
14:23:52 <jmcarthur_work> are they programmer errors, user errors?
14:23:58 <ezyang> jmcarthur_work: user errors
14:24:30 <ezyang> things like parse failures
14:24:43 <ezyang> and "oh, that doesn't actually make sense"
14:24:56 <jmcarthur_work> well, i'm not gonna argue about how the top level of your program should function. it just seems to me that communicating with the user via uncaught exceptions is just in bad style
14:25:11 <kmc> i tend to communicate user errors like parsing via Either
14:25:25 <jmcarthur_work> why not just pattern match over the Either and do different things depending on success or failure?
14:25:31 <kmc> each bit of the program will have perhaps an Error and/or State monad, but the interface to the top level is non-monadic Either
14:25:43 <kmc> (well, it's still a monad, but we don't use that fact)
14:26:25 <ezyang> jmcarthur_work: I suppose this is a weird bit of style I've picked up over time
14:27:28 <ezyang> jmcarthur_work: Essentially, I believe that any fatal error can be implemented using an uncaught exception that contains in it a helpful, long error message.
14:27:29 <jmcarthur_work> i don't like using Either to express errors, personally, although i usually do it anyway out of convenience. it makes otherwise lazy functions suddenly maximally strict. the only way to determine whether there is an error or not is to go ahead and perform the entire computation, even if you don't need it yet
14:28:21 <jmcarthur_work> ezyang, my opinion is that can /= should, but again, it's not really a technical issue so much as stylistic i suppose
14:28:34 <jmcarthur_work> plus, what if you have to clean some things up first?
14:29:05 <jmcarthur_work> like gracefully telling network-connected clients that you're terminating before dying
14:29:06 <ezyang> catch, cleanup, rethrow
14:29:26 <jmcarthur_work> so really all you're saving is a big catch-all at the top level
14:29:27 <ezyang> Do note that Python implements sys.exit as a "special" exception
14:29:33 <ezyang> jmcarthur_work: Basically
14:29:37 <kmc> jmcarthur_work, i think that's a fundamental problem with error-ful functions
14:29:44 <kmc> the Either monad is not specially strict or anything
14:29:46 <jmcarthur_work> haskell isn't python, is all i mean
14:29:48 <kmc> but i agree in general
14:29:53 <jmcarthur_work> and i disagree with that style in python, as well
14:29:59 <lament> haskell isn't python, but i wish it were
14:30:08 <ezyang> jmcarthur_work: So... I didn't start writing in Haskell to write Python.
14:30:36 <ezyang> So, in all earnestness, I'm trying to figure out what a good way of doing this in Haskell is.
14:31:00 <jmcarthur_work> i would handle each case accordingly
14:31:09 <jmcarthur_work> and if you don't care yet, then stay in the monad
14:31:18 <ezyang> ok
14:31:19 <desp> @hoogle Int -> [a] -> [[a]]
14:31:19 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
14:31:19 <lambdabot> Prelude drop :: Int -> [a] -> [a]
14:31:19 <lambdabot> Prelude take :: Int -> [a] -> [a]
14:31:24 <jmcarthur_work> at best, you only care at the top level
14:31:50 <jmcarthur_work> at worst, you care in many places, and it's probably not beneficial to have that monad around if you are constantly wrapping and unwrapping it all the time
14:32:20 <kmc> there is also something to be said for good ol' error :: String -> a
14:32:27 <kmc> in cases where you don't need any handling at all
14:32:32 <kmc> and don't want to otherwise muck up the types
14:32:33 <jmcarthur_work> i use error for programmer error, though
14:32:36 <jmcarthur_work> not for user error
14:32:42 <ezyang> ==
14:32:56 <kmc> jmcarthur_work, in prototype / experimental code it's less important to distinguish the two
14:33:07 <kmc> but in production i agree
14:33:31 <kmc> i know people who use assert in C for important things and don't realize that it's defined away on release builds...
14:33:40 <jmcarthur_work> well sure, but i usually just don't let users get direct access to a partial function
14:34:04 <jmcarthur_work> even in prototyping, i guess i just don't run into that
14:34:09 <jmcarthur_work> maybe i just work differently
14:34:33 <jmcarthur_work> i like totality
14:34:54 <ezyang> jmcarthur_work: Do you tend to do only one call to pure code from inside a monad, or do you need the semicolons?
14:35:19 <jmcarthur_work> ezyang, no, i usually am in monads for a long time
14:35:37 <jmcarthur_work> ezyang, i also don't usually use do notation, so "semicolons" have no use for me ;)
14:35:45 <ezyang> Yay combinators :-)
14:36:26 <jmcarthur_work> ezyang, arguably, if you are only ever calling one pure function within a monad, you don't really need the monad
14:36:33 * kmc likes do notation with its invisible semicolons
14:36:55 <ezyang> jmcarthur_work: True dat.  I just get kind of titchy because my monadic code is incredibly imperative
14:37:28 <jmcarthur_work> ezyang, try using more functional combinators like <=<, <$>, <*>, etc.
14:37:46 <jmcarthur_work> ezyang, within reason, of course
14:37:56 <ezyang> I use <$> and <*> a lot. They're awesome. :-)
14:38:14 <jmcarthur_work> ezyang, or if you paste some of the code you are aren't so happy with maybe i could show you how i would do it?
14:38:20 <lispy> I still use fmap instead of <$> it seems
14:38:33 <ezyang> jmcarthur_work: I would never refuse an offer like that :-)
14:38:40 <jmcarthur_work> lispy, i switch around depending on if i have both arguments or not
14:38:55 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9011#a9011
14:39:00 <lispy> <$> seems better, I was just wondering why I haven't mentally upgraded yet
14:39:02 <jmcarthur_work> not a big fan of sections when there are already textual identifiers for the same thing
14:39:20 <benmachine> I tend to use `fmap`
14:39:23 <benmachine> for some reason
14:39:33 <benmachine> sometimes I use (.) :p
14:39:40 <ezyang> I only use fmap when I don't need <*>
14:39:43 <jmcarthur_work> ezyang, could you give me a type signature and high-level description of what it does?
14:39:48 <ezyang> Oh, right
14:39:51 <jmcarthur_work> plz :)
14:39:54 <ezyang> doCommand :: String -> Options -> [String] -> IO ()
14:40:24 <lispy> :t fromRight
14:40:25 <lambdabot> Not in scope: `fromRight'
14:40:34 <lispy> fromRight sounds partial
14:40:53 <ezyang> main determines what command to do, dispatches to doCommand, we pattern match to determine which subcommand it is, we parse the arguments (the third arg), read out state, put the new member in state, and then save the state
14:40:58 <ezyang> lispy: It is :-)
14:41:05 <lispy> ezyang: ah, where do you check for left?
14:41:14 <ezyang> Current impl is that it throws an exception if it is left
14:41:29 <ezyang> lispy: It's intended as an escape hatch for program execution
14:41:38 <ezyang> Although after the conversation we had here, I maybe changing this
14:42:21 <ezyang> parseMember ::  String -> String -> String -> Either MyError Member
14:42:26 <lispy> on line 7, it's possible that you want $!
14:42:26 <jmcarthur_work> ezyang, i'll play with it a bit
14:42:40 <lispy> er
14:42:51 <ezyang> lispy: looking up
14:42:51 <lispy> ezyang: what I mean is, on line 7, there maybe a space leak
14:43:04 <lispy> ezyang: I hink $! is wrong, you probably would need a strict insert
14:43:41 <ezyang> lispy: I don't quite understand?
14:43:51 <lispy> Well, I'm not an expert here
14:44:00 <lispy> so i'll just shut up
14:44:06 <lispy> if you have a space leak, you'll notice
14:44:15 <ezyang> The program is not long-lived enough to notice
14:44:18 <jmcarthur_work> what is putState and getState? global state?
14:44:35 <ezyang> Poor man's macid: putState = writeFile "statefile" . show
14:44:43 <jmcarthur_work> aha
14:44:46 <lispy> ezyang: also, have you considered making a data type to represent your commands?  It would be much safer from a typeful point of view than passing lists and strings
14:45:05 <jmcarthur_work> yeah, that's probably the first thing i would do
14:45:10 <jmcarthur_work> separate the parsing from the execution
14:45:43 <ezyang> jmcarthur_work: Ok.
14:45:45 <lispy> data Command = Create TypeOfOpts String String String | ...
14:45:53 <lispy> and you could name the strings too
14:45:57 <lispy> if you want to use records
14:46:13 <jmcarthur_work> i see parseMember idString name affilString ... is that more parsing?
14:46:20 <ezyang> jmcarthur_work: Yes
14:46:41 <jmcarthur_work> maybe the result of that should be in the Command data type instead of separate?
14:46:42 <lispy> ezyang: are you familiar with abstract syntax trees?
14:46:46 <ezyang> I didn't create a command opt because it only gets passed from one command to another
14:46:58 <jmcarthur_work> doesn't mean it's not worth it :)
14:47:06 <ezyang> Heh, true :-)
14:47:09 <jmcarthur_work> data types are rather lightweight to make in haskell
14:47:16 <jmcarthur_work> conceptually, i mean
14:47:29 <ezyang> lispy: A little bit
14:47:41 <lispy> ezyang: because if you do, then you can create a data type that represents  your syntax trees.  And pass that to doCommand.  In other words, it becomes a little interpreter
14:47:46 <ezyang> Ok. So essentially, I'll have some parsing stage for each subcommand that turns things into the Command tree
14:47:50 <jmcarthur_work> often i will have more type definitions in my code than functions!
14:48:07 <ezyang> lispy: Hmmm... that seems a bit... heavyweight?
14:48:22 <ezyang> jmcarthur_work: I have a large number already :-)
14:48:30 <lispy> ezyang: it's quite nice because you can then separate the parsing into commands from the interpretation of commands
14:48:31 <jmcarthur_work> ezyang, i recommend just trying it and then see if you still think it is heavy after :)
14:48:45 <jmcarthur_work> you will probably be pleasantly surprised at how nice it looks
14:48:47 <ezyang> Ok. Time to code!
14:49:25 <ezyang> I've never implemented an AST myself. Is there a good reference impl to look at?
14:49:25 <jmcarthur_work> ezyang, i will wait on my refactoring of the paste since we already discussed some sweeping changes
14:49:45 <ezyang> yeah, definitely
14:50:01 <lispy> ezyang: well, just start with the variations of your commands
14:50:35 <lispy> ezyang: like this example I gave earlier: data Command = Create TypeOfOpts String String String | ...a
14:51:00 <ezyang> lispy: Ok, sure
14:51:05 <ezyang> That's the unparsed abstract syntax tree
14:51:06 <jmcarthur_work> ezyang, here is a very simple example http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Return_Values
14:51:18 <ezyang> I guess, after that, then I want to transform that into some sort of... I dunno
14:51:37 <lispy> ezyang: just start simple.  WHat is it that you need for the create command?
14:51:55 <lispy> ezyang: you can make it fancier later
14:51:59 <lispy> start bottom up
14:52:06 <ezyang> lispy: id string, name string, and affiliation string
14:52:18 <lispy> no opts?
14:52:22 <jmcarthur_work> ezyang, what is a "member"?
14:52:52 <ezyang> lispy: Nope, unless I want to give informative messages during the parsing process :-)
14:53:09 <ezyang> jmcarthur_work: A member of an organization that may or may not have paid dues
14:53:24 <jmcarthur_work> ezyang, data Command = Create Member | ...
14:53:26 <jmcarthur_work> :)
14:54:38 <ezyang> jmcarthur_work: Ok!
14:54:45 <ezyang> but that's not an AST, is it?
14:54:49 <jmcarthur_work> why not?
14:55:18 <jmcarthur_work> an AST is abstract. it needn't have a bunch of strings and stuff
14:55:36 <lispy> ezyang: your syntax is just simplier than that of a general purpose programming language
14:55:47 <ezyang> ok
14:55:48 <jmcarthur_work> if those strings represent data, you want the data and not the strings
14:55:56 <ezyang> Right-o
14:56:27 <jmcarthur_work> that's not to say you have to write the command parser all in one function. you can have one high level command parsing function that uses a lower level member parsing function
14:56:32 <jmcarthur_work> etc.
14:56:38 <ezyang> GetOpt does most of the parsing for me
14:56:43 <jmcarthur_work> but the final data type should have only what you need to know and nothing else
14:57:15 <lispy> I think of this like a generalized law of demeter, or maybe just an FP law of demeter
14:57:27 <jmcarthur_work> ezyang, most batch processing programs can be expressed as  input => parse => process => format => output
14:57:38 <jmcarthur_work> ezyang, if you can shape your program like that you will have an easy time
14:58:13 <ezyang> savvy
14:58:17 <jmcarthur_work> where input and output are IO, of course, and everything else is pure
14:59:19 <jmcarthur_work> yours being an interpreter, you may not be able to keep the IO out of process so easily (that's not to say you *can't*), but it's a rule of thumb
15:00:02 <jmcarthur_work> i can think of some kinds of designs that can keep process pure, though
15:01:02 <jmcarthur_work> MonadPrompt is an interesting way to keep the IO out of your core algorithms while still allowing you to have side effects at the top level during execution
15:01:19 <jmcarthur_work> it's effectively imperative, but easier to isolate
15:01:31 <kmc> jmcarthur_work, do you have a link?
15:01:42 <jmcarthur_work> ?hackage MonadPrompt
15:01:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadPrompt
15:04:46 <ezyang> Ok, finally got my program to typecheck (it was a semi-broken state before). Now looking at refactoring
15:04:49 <ezyang> I see: doCommand (head nonOptions) opts (tail nonOptions)
15:05:01 <ezyang> So I guess I'll turn that into parseCommand nonOptions
15:05:25 <byorgey> ezyang: use pattern-matching instead of head + tail
15:05:49 <ezyang> byorgey: Ah, good call
15:05:53 <byorgey> i.e.  blah (firstNonOption:otherNonOptions) = ... doCommand firstNonOption opts otherNonOptions
15:06:06 <byorgey> but with better names =)
15:06:28 <byorgey> 'head' considered harmful
15:06:42 <jmcarthur_work> :t toMaybe
15:06:44 <lambdabot> Not in scope: `toMaybe'
15:06:47 <jmcarthur_work> :t Data.List.toMaybe
15:06:49 <lambdabot> Not in scope: `Data.List.toMaybe'
15:06:53 <kmc> :t listToMaybe
15:06:54 <lambdabot> forall a. [a] -> Maybe a
15:06:56 <jmcarthur_work> aha
15:07:01 <kmc> > listToMaybe []
15:07:01 <jmcarthur_work> shows how much i use it
15:07:02 <lambdabot>   Nothing
15:07:04 <kmc> > listToMaybe [1,2,3]
15:07:05 <lambdabot>   Just 1
15:07:26 <ezyang> Ok, question about ASTs: Let's say I have an "edit" command, where the value is polytypic
15:07:36 <ezyang> (since it could be applying to separate fields)
15:08:01 <ezyang> Do I do EditName Name | EditAffiliation Affiliation... or something cleverer?
15:08:50 <jmcarthur_work> ezyang, what is your final data type?
15:09:17 <ezyang> Something like "Edit Id *"?
15:09:26 <ezyang> (where * is some field inside Member?)
15:09:39 <defun> is bluespec a language for programming the hardware or for describing/designing the hardware. I would guess the latter, but someone said earlier today that it is the former.
15:09:44 <jmcarthur_work> so Member is a record which has different types?
15:10:08 <ezyang> jmcarthur_work: yep
15:10:32 <ezyang> data Member = Member Id Name Affiliation Dues
15:10:56 <lispy> defun: when I saw a talk for it, I thought the speaker was saying it describes hardware.
15:11:08 <lispy> defun: but, I also think it's fairly complex
15:11:12 <lispy> defun: so maybe it does both?
15:11:16 <ezyang> Right now I have: data Command = Create Member              | Collect Id Dollars              | EditName Id Name              | EditAffil Id Affiliation              | EditDues Id Dues
15:11:36 <jmcarthur_work> ezyang, that's not many attributes. i would just have different constructors for each, unless you might edit more than one field at a time?
15:11:47 <ezyang> Nope, only one field at a time
15:11:50 <ezyang> savvy
15:11:53 <jmcarthur_work> okay, that sounds fine to me then
15:12:28 <defun> lispy: hmm. Thanks. It does seem to have some facilities that appear like hardware /programming/ but I guess I'll have to dig a little deaper.
15:12:33 <jmcarthur_work> that is looking like a decent ast, btw
15:13:24 <ezyang> Ok, so I guess parseCommand :: [String] -> Command
15:13:37 <ezyang> Or do I want Maybe Command, since it's incomplete otherwise?
15:13:53 <jmcarthur_work> ezyang, one possible alternative might be to have an UpdateField type for each of the fields and then just have Edit Id UpdateField as the command
15:14:06 <jmcarthur_work> ezyang, you would either want Maybe Command or Either String Command, maybe
15:14:14 <ezyang> jmcarthur_work: That would probably work well for lots of things
15:14:17 <ezyang> ok
15:14:22 <ezyang> gonna use my error monad whoo
15:14:26 <jmcarthur_work> i just used either and maybe in the same sentence as Either and Maybe...
15:15:34 <jmcarthur_work> ezyang, what does your error monad do that's unique?
15:15:48 <ezyang> It's just a wrapper around Either
15:16:54 <jmcarthur_work> @instances MonadError
15:16:55 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
15:17:17 <jmcarthur_work> ezyang, Either is in there ;)
15:17:46 <ezyang> Mmmmmmmm...
15:17:57 <ezyang> mumble hiding implementation details mumble
15:19:00 <jmcarthur_work> ezyang, is it an implementation detail if Either *is* the abstraction? :)
15:19:19 <ezyang> Probably not :-)
15:19:32 <ezyang> Ohh, I know why I did that
15:19:39 <ezyang> Either doesn't have a monad instance...
15:19:47 <jmcarthur_work> sure it does
15:19:52 <jmcarthur_work> @instances Monad
15:19:53 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:20:00 <ezyang> Hm, I don't know why what wrong headed thinking made me think that
15:20:17 <ezyang> agggh, I already converted everything to use MonadError
15:20:21 <ezyang> time to convert back (yay vcs)
15:20:26 <jmcarthur_work> ezyang, http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad-Instances.html
15:20:31 <jmcarthur_work> you do have to import that
15:21:19 <ezyang> ok
15:21:35 <lispy> ezyang: you might want to read this tutorial and think about how to apply the material to your designs in the future: http://user.cs.tu-berlin.de/~magr/pub/Transformers.en.html
15:21:36 <aavogt> is RWST redundant since you could use ReaderT r (WriterT w (StateT s m)) instead?
15:21:55 <aavogt> or is it just there for performance concerns?
15:22:01 <jmcarthur_work> aavogt, i think it's about efficiency and making you not have to worry that they are not commutative
15:22:20 <kmc> maybe convenience too
15:22:27 <aavogt> jmcarthur_work: what do you mean by not commutative?
15:22:40 <jmcarthur_work> not all monad transformers commute
15:22:49 <aavogt> can't I order those 3 transformers any way I like?
15:22:50 <jmcarthur_work> i don't even know if writer, state, and reader are among those
15:22:52 <ezyang> lispy: I don't think I need monad transformers?
15:22:58 <kmc> ErrorT e (State s)  is not the same as StateT s (Error e)
15:23:07 <jmcarthur_work> there are some combinations that are not the same in other orders
15:23:09 <kmc> you can, and each ordering has different behavior
15:23:18 <jmcarthur_work> @unmtl  ErrorT e (State s)
15:23:19 <lambdabot> err: `ErrorT e (State s)' is not applied to enough arguments, giving `/\A. s -> (Either e A, s)'
15:23:27 <jmcarthur_work> @unmtl  ErrorT e (State s) a
15:23:27 <lambdabot> s -> (Either e a, s)
15:23:36 <jmcarthur_work> @unmtl StateT s (Error e) a
15:23:37 <lambdabot> s -> Error e (a, s)
15:23:44 <benmachine> @unmtl ReaderT s (Writer t) a
15:23:44 <lambdabot> s -> (a, t)
15:24:06 <benmachine> :o ReaderT s (Writer s) a == State
15:24:17 <aavogt> @unmtl WriterT t (Reader s) a
15:24:17 <lambdabot> s -> (a, t)
15:24:21 <benmachine> er
15:24:22 <benmachine> maybe.
15:24:24 <benmachine> not really
15:24:26 <lispy> ezyang: they are not a necessity.  But, as you write your interpreter for your command language, you might wonder about how to pass an environment and how to handle errors
15:24:35 <benmachine> it looks the same but isn't
15:24:56 <ezyang> lispy: Sure.
15:24:58 <lpjhjdh> is there any other work on using combined algebras to modularize compilers/evaluators with a better solution than switchAlgebra?
15:24:59 <lispy> ezyang: that paper takes you through a development similar to what you're doing now and explains when/why to  use a few monad transformers.  It's a light read mostly
15:25:03 <kmc> :t maybeToList
15:25:04 <lambdabot> forall a. Maybe a -> [a]
15:25:22 <benmachine> is that surprising? :P
15:25:28 <ezyang> I have one part of my code that I might want to use a transformer: Reader Environment (ErrorMonad Member)
15:26:26 <lispy> monad transformers + newtype + generalized new type deriving allows for quickly building robost interpreters and other fancy do dads
15:26:26 <aavogt> benmachine: you mean either ReaderT and WriterT don't commute, or that they can't emulate the state monad together?
15:26:38 <benmachine> aavogt: they don't emulate the state monad
15:26:54 <flazz> ghc is telling me i have two packages with Control.Monad.State: monads-fd, mtl. what is a good way to resolve this?
15:27:01 <jmcarthur_work> tell followed by ask is not the same as put following by get
15:27:02 <benmachine> things being the same type doesn't necessarily imply they are the same value >_>
15:27:21 <benmachine> flazz: ghc-pkg hide monads-fd
15:27:25 <jmcarthur_work> flazz, -hide-package monads-fd
15:27:30 <benmachine> or that
15:27:45 <ezyang> jmcarthur_work: The other thing, I think, was that it encouraged me to use return/throwError instead of Right/Left
15:27:59 <jmcarthur_work> benmachine's hides it permanently until you unhide it. mine hides it temporarily, but you must do it every time
15:28:04 <flazz> what is the relationship between cabal and ghc-pkg?
15:28:34 <jmcarthur_work> ezyang, if you continue to just use return/throwError, perhaps many of your functions can be made polymorphic rather than tied to a specific monad?
15:28:39 <dschoepe> Why doesn't the parser `spaces *> newline' accept the string " \n"? (Using parsec-3.0.0)
15:28:43 <ezyang> jmcarthur_work: I suspect so
15:28:56 <benmachine> dschoepe: spaces is probably greedy
15:29:02 <ezyang> Ok, let's do that
15:29:12 <benmachine> dschoepe: so spaces parses " \n" leaving "" for newline
15:29:22 <ezyang> Ah, excellent
15:29:22 <benmachine> that'd be my guess
15:29:43 <benmachine> wait, I assume spaces is multiple whitespace characters rather than multiple ' ' characters
15:29:50 <dschoepe> benmachine: it's defined as skipMany space. That shouldn't be greedy, should it?
15:29:51 * benmachine doesn't really remember
15:29:54 <lispy> flazz: ghc-pkg is the ghc specific tool that does low level management of ghc packages (registering and unregistering them, showing meta data).  Cabal is a library for using the cabal build/install system.  Cabal-install is a tool that uses the cabal library to provide a package manager on top of your haskell implementation (it can fetch packages and build/install them)
15:30:07 <ezyang> jmcarthur_work: So I convert everything to use MonadError m e => ... and then force higher level to use Either or something. Excellent.
15:30:09 <benmachine> dschoepe: why not?
15:30:20 <dschoepe> > isSpace '\n'
15:30:21 <jmcarthur_work> ezyang, i love it when that happens :D
15:30:21 <lambdabot>   True
15:30:24 <aavogt> @type spaces
15:30:25 <lambdabot> Not in scope: `spaces'
15:30:26 <dschoepe> benmachine: ah, there's the problem
15:30:27 <dschoepe> thanks
15:30:36 <jmcarthur_work> ezyang, *that's* true implementation hiding :)
15:31:18 <flazz> lispy: so cabal is like cpan or ruby gems and ghc stuff is the implementation i'm using, but cabal can work with non ghc haskell?
15:32:32 <lispy> flazz: cabal-install is like easy_install or gem.  cabal-library describes the format for .cabal files and provides the interface to work with them.  Yes, cabal (both install and library) work with multiple haskell implementations
15:32:51 <flazz> lispy: thanks
15:32:54 <lispy> flazz: np
15:33:06 <dschoepe> flazz: I guess hackage is the pendant to cpan though.
15:33:42 <ezyang> Huh, I generally don't use the e type parameter
15:33:49 <ezyang> in MonadError e m
15:35:34 <jmcarthur_work> ezyang, does that mean you aren't using throw?
15:35:39 <ezyang> Nope
15:35:41 <ezyang> throwError
15:35:48 <ezyang> I only use throw in IO monad (and probably not for long)
15:35:52 <jmcarthur_work> i meant throw as shorthand for that
15:36:02 <ezyang> I am using throwError
15:36:11 <jmcarthur_work> :t throwError
15:36:12 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
15:36:25 <jmcarthur_work> and yet e is polymorphic?
15:36:33 <jmcarthur_work> what are you throwing?
15:37:13 <ezyang> MyError, which is an instance of Error
15:37:38 * jmcarthur_work reads the doc
15:37:40 <jmcarthur_work> s
15:38:43 <aavogt> I can't find a Boyer-Moore implementation on hackage... shouldn't isInfixOf be using this algorithm?
15:38:49 <aavogt> @src isInfixOf
15:38:50 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
15:39:09 <jmcarthur_work> ezyang, ah, so you are using strMsg?
15:39:21 <jmcarthur_work> or noMsg
15:39:27 <ezyang> Um... no...
15:39:36 <ezyang> (I defined it though)
15:40:27 <jmcarthur_work> ezyang, i don't understand how the type would be polymorphic if you are using throwError without using noMsg or strMsg
15:40:45 <ezyang> Hmm...
15:40:49 <ezyang> I guess it wouldn't be
15:41:07 <ezyang> because I'm doing "throwError FooBarError"
15:41:19 <ezyang> so e is constrained to be MyError
15:41:38 <jmcarthur_work> so you should actually have MonadError MyError m
15:41:48 <jmcarthur_work> but it's typechecking without that?
15:42:19 <ezyang> I haven't tried yet >:-)
15:42:23 <jmcarthur_work> aha
15:42:41 <jmcarthur_work> i would just remove some type signatures, load it in ghci, and see what it says the types of your functions are :)
15:43:11 <ezyang> Well, it's not typechecking right now
15:43:14 <ezyang> Let me go fixor
15:43:42 <jmcarthur_work> if you do that, make sure you remove the lowest level function signatures first so that it doesn't unnecessarily constrain your higher level function types
15:43:57 <ezyang> Ah, you're exactly right
15:44:06 <ezyang> Could not deduce (MonadError MyError m)       from the context (MonadError e1 m)
15:44:30 * ezyang wonders if he should type MyMonadError = MonadError MyError 
15:44:39 * ezyang doesn't know if that would actually work 
15:44:46 <jmcarthur_work> i don't think that would work
15:45:03 <ezyang> ok.
15:45:19 <jmcarthur_work> i'm curious. how is MyError defined?
15:45:45 <ezyang> Ooh, now I need FlexibleContexts
15:45:49 <jmcarthur_work> yup
15:46:07 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9012#a9012
15:46:31 <ezyang> merf
15:46:33 <ezyang> Could not deduce (Applicative m2)       from the context (MonadError MyError m2)
15:46:38 <ezyang> T_T
15:47:06 <aavogt> just add that to the context
15:47:07 <jmcarthur_work> yeah, sucks that Monad doesn't require Applicative :(
15:47:30 <jmcarthur_work> (Applicative m, MonadError MyError m) => ...
15:47:37 <ezyang> aavogt: That's a lot of contexts to add it to...
15:47:44 <jmcarthur_work> yup
15:47:45 <jmcarthur_work> :(
15:47:54 <ezyang> Can't I, like, define applicative for MonadError MyError m or something?
15:48:07 <jmcarthur_work> ezyang, sometimes i use ap instead of <*>, etc. to avoid that
15:48:23 <jmcarthur_work> ezyang, or liftM2 instead of liftA2, etc.
15:48:36 <aavogt> is there some alternate Prelude + base library with that hierarchy mistake corrected?
15:48:44 <ezyang> :-( "Class `MonadError' used as a type     In the type `MonadError MyError'"
15:48:54 <jmcarthur_work> ezyang, defining Applicative for all Monads would mean overlapping instances
15:49:06 <jmcarthur_work> ezyang, use m
15:49:13 <dschoepe> Is that likely to change in future ghc versions or Haskell'?
15:49:22 <ezyang> Ok
15:49:31 <jmcarthur_work> aavogt, i have no idea
15:49:40 <benmachine> ezyang: most common reason for that afaik is -> being used instead of =>
15:49:41 <jmcarthur_work> dschoepe, i would be surprised if this is not fixed in Haskell'
15:50:27 <aavogt> the problem is that changing the Monad class will break everybody's instances for it
15:50:36 <jmcarthur_work> oh, right
15:50:43 <ezyang> Yup, sure enough, overlapping instances
15:50:48 <jmcarthur_work> so maybe i shouldn't be surprised if haskell' doesn't have that fixed :(
15:50:56 <ezyang> I like my <$> :-(
15:51:09 <jmcarthur_work> ezyang, i would highly recommend just using ap and liftM* instead of <*> and liftA*
15:51:16 <jmcarthur_work> ezyang, <$> is actually Functor ;)
15:51:26 <jmcarthur_work> although, that is also not required by Monad
15:51:26 <ezyang> And my <*> :-(
15:51:29 <ezyang> :-)
15:51:30 <aavogt> or don't import Control.Applicative
15:51:33 <jmcarthur_work> you can replace it with liftM, of course
15:51:38 <aavogt> and define (<*>) = ap
15:51:47 <ezyang> aavogt: ok, sounds good
15:51:57 <jmcarthur_work> aavogt, oh that's a nice idea, actually
15:52:06 <benmachine> I wish someone would make class aliases
15:52:20 <benmachine> I mean, implement them
15:52:24 <benmachine> unless they did and didn't tell me
15:53:04 <ezyang> Hm, something wonky happened
15:53:05 <jmcarthur_work> ezyang, how are you using MyError at the top level? are you actually doing different things for each of those constructors?
15:53:09 <ezyang> I think operator precedences are wrong
15:53:17 <aavogt> and 'specializing' those functions it isn't too annoying when reading code
15:53:20 <ezyang> jmcarthur_work: not reaaally...
15:53:24 <jmcarthur_work> ezyang, ah, yeah, might have to check the source for Control.Applicative
15:53:26 <ezyang> although I guess, in theory, I could
15:53:44 <jmcarthur_work> ezyang, well, i think you can guess what my next suggestion might be :)
15:54:15 <jfoutz> aavogt: maybe add a new class WarmFuzzyThing, change all the prelude classes to use that, and them implement Monad in terms WarmFuzzyThing for backwards compatibility?
15:54:22 <ezyang> use strMsg instead, hai hai
15:54:25 <jmcarthur_work> not that it's bad to have that type, i mean, but if it's not strictly necessary... :)
15:54:50 <aavogt> jfoutz: does that work?
15:55:01 * aavogt wants proof
15:55:07 <ezyang> jmcarthur_work: I come from a long and proud tradition of the Python school
15:55:14 <ezyang> where string exceptions are the bane of existence!
15:55:17 <ezyang> Rawr!
15:55:35 <jmcarthur_work> ezyang, maybe define throwStr = throwError . strMsg, for convenience. it doesn't seem to exist already
15:55:48 <jmcarthur_work> oh, i bet fail already does that
15:55:56 <jmcarthur_work> i hate fail, but it at least makes sense in an error monad
15:56:00 <ezyang> yeah. But I want to be careful about fail
15:56:11 <ezyang> If you pick the wrong monad, kzzt off goes your bottom
15:56:34 <jmcarthur_work> ah, well, fail wouldn't be written in terms of throwError anyway, i just realized
15:56:43 <jmcarthur_work> it would be in terms of the raw implementation
15:56:51 <glguy> async exceptions are always possible, regardless of type. just worrying about the ocassional "fail" won't be enough to save your bottom
15:56:54 <ezyang> I think... it would probably work?
15:57:12 <jmcarthur_work> i think fail would be a reasonable enough bet
15:57:34 <jmcarthur_work> although i do wish fail wasn't in Monad :(
15:57:49 <ezyang> Hmm, my infixl doesn't seem to be working
15:58:13 <jmcarthur_work> oh wow, Either has no monad instance in Control.Monad.Instances? i thought it did.....
15:58:35 <jmcarthur_work> is Either's appearance in @instances due to Caleskell or something?
15:58:52 <dibblego> Error iirc
15:58:53 <glguy> Hascale?
15:58:54 <jmcarthur_work> well.... it must be defined somewhere. it's a MonadError
15:59:42 <jmcarthur_work> ah, it's defined in Control.Monad.Error
15:59:46 <aavogt> @quote anon
15:59:46 <lambdabot> LoganCapaldo says: thisWouldBeAnonymousButMyTeacherIsAnExPythonProgrammerOrSomething x = ...
15:59:49 <jmcarthur_work> that's a silly place for that
16:00:20 <ezyang> infixl still not working :-(
16:00:27 <jmcarthur_work> and indeed, we have fail = Left . strMsg
16:00:31 <ezyang> I guess time to add some parens
16:00:45 <lament> we have fail!
16:00:45 <jmcarthur_work> wait...
16:00:57 <jmcarthur_work> instance (Error e) => Monad (Either e) where
16:01:02 <jmcarthur_work> that sucks!
16:01:23 <jmcarthur_work> i understand why, but it still sucks
16:01:26 <jmcarthur_work> stupid fail
16:01:36 <ezyang> fouling it up
16:01:54 <jmcarthur_work> on the plus side, it does mean fail does what you want here :)
16:02:17 <glguy> jmcarthur_work: in monadlib, fail is lifted from the base monad
16:02:48 <glguy> jmcarthur_work: and raise let's you throw whatever the exception type is
16:03:02 <glguy> (in ExceptionT)
16:03:50 <jmcarthur_work> glguy, ah that's rather nice
16:03:55 <dons> monadLib cited at the haskell workshop today
16:04:08 <dons> "competition for mtl, but noone except galois uses it"
16:04:11 <jmcarthur_work> having that would mean we could liberate Either from fail, too
16:04:26 <jmcarthur_work> i like monadLib
16:04:40 <jmcarthur_work> but am too afraid to use it in libraries
16:04:43 <dons> someone should write a tutorial.
16:04:44 <dons> huh
16:04:53 <jmcarthur_work> since most people use mtl
16:05:05 <jmcarthur_work> and it could mean a choice between using and not using the library
16:05:11 <aavogt> @karma mtl
16:05:12 <lambdabot> mtl has a karma of 0
16:05:15 <dons> btw, after the haskell workshop today, i put together a reading list for getting into parallel haskell, http://donsbot.wordpress.com/2009/09/03/parallel-programming-in-haskell-a-reading-list/
16:05:15 <glguy> mtl--
16:05:17 <Berengal> mtl and friends all step on eachother's toes in the namespace. Makes me a sad panda :(
16:05:46 <jmcarthur_work> dons, oh nice!
16:06:09 <aavogt> Berengal: presumably they do that to make it easier to switch?
16:06:13 <Vanadium> What is the difference between monadlib and mtl
16:06:13 <ezyang> Haha!
16:06:23 <ezyang> The order in which I define <$> and <*> is important
16:06:36 <SamB> ezyang: in which langauge?
16:06:40 <jmcarthur_work> ezyang, huh?!
16:06:47 <SamB> and do you mean, even in the same file?
16:07:04 <jmcarthur_work> that sounds like a bug to me
16:07:11 <ezyang> for operator precedence
16:07:23 <jmcarthur_work> Vanadium, basically, monadLib is just cleaner, imo
16:07:23 <SamB> aavogt: an easier way might involve first-class modules ...
16:07:39 <jmcarthur_work> Vanadium, it's mtl after some lessons learned
16:07:50 <Vanadium> I see
16:08:06 * aavogt is annoyed by top level TH splices whose order does matter
16:08:09 <jmcarthur_work> there are a few others, too
16:08:14 <jmcarthur_work> monad-fd, i believe?
16:08:24 <SamB> aavogt: ah, in TH
16:08:24 <aavogt> transformers
16:08:41 <SamB> aavogt: why do they matter -- do they use introspection?
16:08:41 <jmcarthur_work> monads-fd
16:08:47 <glguy> Vanadium: monadlib stacks the monads with continuations correctly
16:08:55 <glguy> Vanadium: has more reasonable exception monad
16:08:57 <Vanadium> I do not know about continuations :(
16:09:00 * ezyang wonders if he should use monadlib 
16:09:06 <jmcarthur_work> continuations are fun
16:09:12 <glguy> the only case for mtl is legacy compatibility
16:09:15 <SamB> jmcarthur_work: brain-explodey!
16:09:24 * jmcarthur_work agrees with glguy 
16:09:29 <aavogt> SamB: I guess, they refer to eachother's results
16:09:37 <SamB> glguy: and, of course, some people might just use it out of habbit
16:10:23 <jmcarthur_work> yeah, a monadLib tutorial would be a great way to spread the word about it a bit
16:10:32 <jmcarthur_work> and maybe be a bit nicer for newbies?
16:10:46 <jmcarthur_work> except that so many packages use mtl
16:10:56 <dons> why does no monadLib user ever write about it? or put a tutorial together?
16:11:11 <dons> there's no champion for it
16:11:14 <jmcarthur_work> i never thought it needed a tutorial
16:11:21 <glguy> step one
16:11:22 <jmcarthur_work> but it does sound good now that it has been brought up
16:11:23 <glguy> import MonadLib
16:11:28 <ezyang> Huh. (<*>) = foo is different from a (<*>) b = foo a b
16:11:39 <dons> oh, non-hier namespace is also kinda weird.
16:11:45 <mauke> MR
16:11:50 <jmcarthur_work> ezyang, a <*> b = foo a b
16:11:56 <jmcarthur_work> oh, yeah, MR
16:12:02 <mauke> well, no
16:12:02 <dons> idiosyncratic
16:12:15 <mauke> a (<*>) b = ... defines a function called a
16:12:23 <jmcarthur_work> haha
16:12:35 <jmcarthur_work> didn't even think about that
16:12:44 <glguy> It should probably be Control.Monads.Transformers.MonadLib
16:12:46 <ezyang> Ok, I meant jmcarthur_work
16:12:48 <glguy> something long
16:12:53 <ezyang> It's still different.
16:13:20 <jmcarthur_work> ezyang, in what way?
16:13:26 <glguy> yav: when are we going to get a new, longer namespace for monadlib?
16:13:27 <jmcarthur_work> is one a type error?
16:13:35 <ezyang> jmcarthur_work: Operator precedence changes
16:13:37 <hackagebot> djinn 2009.9.3 - Generate Haskell code from a type (LennartAugustsson)
16:13:44 <jmcarthur_work> O_o
16:13:51 <yav> glguy: MonadLib.MonadLib?
16:13:57 <dons> Control.MonadLib
16:13:58 <jmcarthur_work> seriously?
16:14:02 <glguy> yav: I like it
16:14:03 <ezyang> Let me cook up a test-case
16:14:13 <dons> MonadLib isn't very descriptive in general though. Control.Monad.Light would have been clearer
16:14:28 <dons> shrug.
16:14:30 <yav> dons: I prefer Mind.Control.MonadLib :p
16:14:37 <benmachine> ezyang: you can check the precedence of an operator in ghci with :i
16:14:39 <jmcarthur_work> > fix ("MonadLib."++)
16:14:40 <lambdabot>   "MonadLib.MonadLib.MonadLib.MonadLib.MonadLib.MonadLib.MonadLib.MonadLib.Mo...
16:14:41 <dons> that's not a bad namespace actually
16:14:53 <glguy> Mo.nad.lib
16:14:58 <glguy> err Mo.Nad.Lib
16:15:17 <Berengal> Yay.Monads
16:15:33 <ray> > fix ("Control.Module.Fix."++)
16:15:34 <lambdabot>   "Control.Module.Fix.Control.Module.Fix.Control.Module.Fix.Control.Module.Fi...
16:15:53 <glguy> All of the unsafe functions should be moved to a module whose name has infinite length
16:15:57 <glguy> for great safety
16:16:01 <ezyang> benmachine: Wait, really?
16:16:08 <ezyang> (<~>) :: (Num a) => a -> a -> a 	-- Defined at prec.hs:1:2-4
16:16:12 <dons> trevor wins the prize. http://hackage.haskell.org/package/openid
16:16:17 <dons> only package that relies on monadlib on hackage.
16:16:34 <jmcarthur_work> O_O
16:16:35 <benmachine> ezyang: for example, :i + has infixl + 6 at the bottom
16:16:36 <dons> good to see someone made the move.
16:16:37 <yav> hurray!
16:16:37 <jmcarthur_work> *only*?
16:16:41 <jmcarthur_work> :(
16:16:45 <benmachine> er infixl 6 +
16:16:53 <jmcarthur_work> now i feel i must take some initiative
16:16:58 <dons> yeah, because no one has heard of monadlib, unless they've met Iavor.
16:17:00 <glguy> hpaste.org uses monadlib irrc
16:17:02 <glguy> iirc
16:17:04 <ezyang> Oh, maybe I have to omit parens
16:17:05 <dons> its a secret.
16:17:06 <jmcarthur_work> well, there are some others, i thought...
16:17:11 <dons> glguy: 2.0?
16:17:23 <ezyang> oh that's because I didn't put any precedence in
16:17:32 <jmcarthur_work> oh, just data-accessors-monadLib
16:17:33 <elliottt> yav: you need to start adding some unnecessary dependencies in your packages :)
16:17:37 <jmcarthur_work> i guess that doesn't count
16:17:49 <glguy> dons: yeah, at least that one
16:18:03 <glguy> it also uses mtl because of cgi
16:18:13 <Vanadium> So are error monad transformers making Control.Exception obsolete?
16:18:14 <dons> there's a short tutorial, http://www.haskell.org/haskellwiki/MonadLib
16:18:31 <dons> but no clear motivation for why people should switch. so instead its this kind of in-joke.
16:18:58 <elliottt> dons: monadLib is a joke?!?!  it's the best monad transformer library!
16:19:05 <dons> no, an "in-joke"
16:19:15 <elliottt> dons: pardon me. :)
16:19:16 <dons> we've been talking about why no one uses it for the last 2 years
16:19:18 <yav> Vanadium: not really, they are differnt, mostly Control.Exception deals with IO-ish exceptions
16:19:59 <Vanadium> It just seems that a lot of magic has flown into this whole dynamically typed exception hierarchy thing and yet we are still stuck with static error transformers~
16:20:01 <dons> like, whenever someone mentions mtl, someone from galois says "monadlib is better, but no one uses it". its like a little secret code
16:20:15 <elliottt> public secret code :)
16:20:35 <jmcarthur_work> i've used it for unreleased projects
16:20:42 <glguy> well, it is stored in a git repos
16:20:50 <elliottt> jmcarthur_work: how do you like it in comparison to mtl?
16:20:54 <glguy> so maybe the Haskell devs don't know how to open it
16:20:58 <jmcarthur_work> i much prefer it
16:21:03 <jmcarthur_work> ^^ elliottt
16:21:07 <dons> no, github is pretty popular
16:21:25 <jmcarthur_work> it's on hackage. that should be good enough regardless of VCS
16:21:27 <Vanadium> oh look yav is The Monadlib Guy I had no idea
16:21:32 <dons> esp. for those guys who like to put stuff up on github and never release on hackage :)
16:21:49 <dons> at least we have github now, so the repos don't languish on laptop harddrives
16:21:52 <yav> my stuff is mostly on hackage i think
16:21:54 <elliottt> jmcarthur_work: me too :)
16:21:59 <yav> even parsimony! :-)
16:22:03 <elliottt> yav: that's what you think.
16:22:06 <elliottt> oh snap.
16:22:08 <dons> yeah, yav is good :)
16:22:11 <glguy> yav: way to not evangelize :(
16:22:39 <dons> parsimony wins some prizes i think :)
16:22:46 <dons> also, the meme of 1 digit versions
16:22:49 <jmcarthur_work> oh that's one i've been meaning to look into
16:23:13 <yav> the 1 digit versions is not a meme but a bug in cabal
16:23:20 <dons> no no. its cool.
16:23:23 <dons> all the kids are doing it.
16:23:34 <dons> i want a tshirt that says "web 2"
16:23:37 <elliottt> is the bug the fact that you can have 4 distinct digits?
16:23:58 <yav> the bug is that 1 < 1.0
16:24:16 <elliottt> clearly.
16:24:20 <glguy> > compare "1" "1.0"
16:24:21 <lambdabot>   LT
16:24:24 <glguy> lgtm
16:24:28 <dons> "An instance of 'Ord' is also provided, which gives lexicographic
16:24:29 <dons> ordering on the 'versionBranch' fields (i.e. 2.1 > 2.0, 1.2.3 > 1.2.2,
16:24:29 <dons> etc.).  This is expected to be sufficient for many uses, but note that
16:24:29 <dons> you may need to use a more specific ordering for your versioning
16:24:29 <dons> scheme. "
16:24:41 <dons> maybe that's a bad default?
16:24:46 <elliottt> maybe so
16:25:15 <dons> they sadly don't mention 1 < 1.0
16:25:16 <glguy> dons: if you would come back to work we could just do this by yelling to each other
16:25:25 <dons> glguy: i can't. they won't let me back in yet.
16:25:44 <dons> but i need my weekly yelling fix about monadlib and version numbres
16:25:47 <ezyang> Huh, now it's not doing operator precedence rtl
16:25:59 * glguy throws a ball at dons' desk
16:26:14 * dons watches ball fall into cup of coffee
16:26:18 <glguy> eww
16:26:27 <jmcarthur_work> SPLASH
16:26:32 <dons> yeah, you shouldn't throw things at my desk
16:26:44 <dons> time to fire up elliottt's usb missles
16:26:54 <elliottt> and fire them at dons desk :)
16:26:54 <ezyang> holy smack
16:27:00 <ezyang> My imports are messing things up
16:27:22 * dons is glad he's not sitting at his desk
16:28:04 <yav> dons: did you hear that we imported adam to the "cool kids" area?
16:28:26 <elliottt> is that what we're calling it now?
16:28:40 <ezyang> We have a winner!
16:28:47 <dons> yav, yeah, he mentioned something about that.
16:29:09 <elliottt> hooray!
16:29:28 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9013#a9013
16:29:29 <dons> elliottt is leader of the cool kids gang
16:29:39 <ezyang> Without Control.Monad.Error, this expression fails to typecheck
16:30:01 <elliottt> totally cool.
16:30:18 <jfoutz> wow. iavor.diatchki site:hackage.haskell.org/package finds all sorts of neat stuff.
16:30:21 <ezyang> and, switching a <$> b = liftM a b to (<$>) = liftM also causes a typecheck fail
16:30:26 <ezyang> gahhh
16:31:12 <benmachine> ezyang: try Control.Monad.Instances instead of Control.Monad.Error
16:31:19 <jmcarthur_work> ezyang, Control.Monad.Instances
16:31:31 <jmcarthur_work> ezyang, it wants the function monad
16:31:32 <benmachine> for the latter part, I bet it will also work if you give <$> an explicit type signature
16:31:53 <jmcarthur_work> ezyang, the second problem is due to MR
16:32:02 <ezyang> MR?
16:32:07 <jmcarthur_work> monomorphism restriction
16:32:13 <ezyang> ahhh, that makes sense
16:32:21 <jmcarthur_work> *dreaded* monomorphism restriction ;)
16:32:38 <benmachine> (instead of importing Control.Monad.Instances you could also do instance Monad ((->) t) where return = const; m >>= f = \p -> f (m p) p
16:32:42 <benmachine> )
16:32:53 <jmcarthur_work> which would be an orphan
16:32:54 <ezyang> Wow... that's kind of neat
16:32:56 <jmcarthur_work> but you could
16:33:07 <benmachine> an orphan?
16:33:17 <benmachine> monomorphism restriction trips a lot of people up but I don't dread it as such
16:33:18 <jmcarthur_work> benmachine, try building that with -Wall ;)
16:33:24 <benmachine> so long as you know to look out for it you're fine
16:33:47 <jmcarthur_work> benmachine, an orphan instance is an instance not defined in the same module as either the data type or the type class
16:33:51 <benmachine> ah
16:33:56 <benmachine> so what?
16:34:07 <jmcarthur_work> benmachine, orphans are avoided because it could lead to conflicting instances
16:34:18 <benmachine> oh right
16:34:25 <benmachine> yeah that makes snse
16:34:29 <benmachine> that makes snes.
16:34:39 <jmcarthur_work> sense?
16:34:45 <benmachine> yes.
16:34:54 <jmcarthur_work> super nintendo entertainment system?
16:35:06 <benmachine> that too
16:35:19 <jmcarthur_work> time to head home
16:35:23 <benmachine> when you said those words, gaming hardware materialised next to my laptop
16:36:08 <yrlnry> byorgey:  Hi!
16:36:16 <yrlnry> byorgey:  Are you in Edinburgh or something now?
16:37:11 <yrlnry> Hmm, I guess now.
16:39:00 <ezyang> These type errors are making my head hurt
16:40:24 <Berengal> @botsnack
16:40:25 <lambdabot> :)
16:40:32 <Berengal> Lunabot left?
16:41:24 <kmc> are lambdabot and lunabot friends, or fierce rivals?
16:41:50 <benmachine> 05:01:13 -!- lunabot [n=lunabot@64.131.71.65] has quit [Read error: 113 (No  route to host)]
16:41:53 <Berengal> @vixey are you and lunabot friends or enemies?
16:41:53 <lambdabot> a bot? what is that?
16:42:15 <lament> @vixey have you ever sailed on a sailbot?
16:42:16 <lambdabot> no, why? do i seem "botty"?
16:42:31 <lament> not at all defensive eh
16:42:35 <desp>     No instance for (Data.Array.Base.MArray IOUArray (Maybe Char) IO)
16:42:36 <desp>       arising from a use of `newArray'
16:42:41 <desp> I'm sorry, what?
16:42:56 <aavogt> @. leet vixen how are you?
16:42:56 <lambdabot> Plugin `compose' failed with: Unknown command: "leet"
16:42:57 <desp> I was trying to use  type SinkTable = IOUArray (Int, Int) (Maybe Char)
16:42:59 <ezyang> WHOO! TYPEFIXED!
16:43:06 * ezyang does happy dance 
16:43:13 <aavogt> @. elite vixen how are you?
16:43:14 <lambdabot> I Am W0nDerFu|, 7h4Nk$ F0R aSKiNg!
16:43:21 <Berengal> desp, it's saying it can't unbox Maybe Char
16:43:32 <Berengal> ... I think...
16:43:43 <desp> Ahh.
16:43:49 <desp> Indeed, thanks.
16:44:00 <elliottt> can anyone tell me what -O expands out to?  there seems to be a bug whe compiling the base library, but when expanding the referenced flags on the user guide, i don't get the same error
16:44:07 <elliottt> (this is using ghc)
16:44:18 <jfoutz> ezyang: now you just have the *really* hard bugs to fix :)
16:44:31 <kmc> @. elite djinn (a -> b) -> a -> b
16:44:32 <lambdabot> f a = a
16:44:40 <ezyang> jfoutz: Muahahaha
16:44:43 <kmc> @. elite djinn ((p -> q) -> p) -> p
16:44:44 <lambdabot> -- f CAnnO+ bE rEA1IZ3D.
16:44:54 <yav> elliottt: Is -0 an abbrevation?  I would have though that it is just -O 1
16:45:25 <elliottt> it's an abbreviation for -O1
16:45:48 <ezyang> Ok, now where was I...
16:50:38 <ezyang> Hmm, I want a really, really low precedence return
16:51:08 <ezyang> Anything like that exist?
16:51:17 <aavogt> return $
16:51:26 <ezyang> That's what I'm using right now
16:51:35 <aavogt> you would be using return infix?
16:51:59 <aavogt> > 1 `return` 2
16:52:00 <lambdabot>   1
16:52:04 <ezyang> Huh
16:52:06 <ezyang> That's funny
16:52:35 <jfoutz> :t (`return`)
16:52:36 <bjorkintosh> which llinux distro is most compatible with haskell?
16:52:36 <lambdabot> parse error on input `)'
16:52:37 <ezyang> Also obfuscating enough to not be good
16:52:38 <aavogt> that's what you asked for?
16:52:44 <jfoutz> :t `return`
16:52:45 <lambdabot> parse error on input ``'
16:52:52 <bjorkintosh> i'm experiencing nightmares with ubuntu and debian
16:53:08 <aavogt> :t (`return` 2)
16:53:08 <ezyang> Well, here's my command parsing codes http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9014#a9014
16:53:09 <lambdabot> forall a. a -> a
16:53:16 <ezyang> I should probably add in a base case
16:53:25 <jfoutz> a9014
16:53:25 <jfoutz> 19:53 < lambdabot> forall a. a -> a
16:53:29 <aavogt> jfoutz: (`return` undefined) == id
16:53:36 <jfoutz> oops. mispaste
16:53:41 <jfoutz> aavogt: thanks
16:53:43 <benmachine> this is the monad return so return is effectively const here
16:53:56 <aavogt> benmachine: ?
16:54:06 <benmachine> aavogt: am I wrong?
16:54:09 <benmachine> er
16:54:17 <benmachine> I had the right idea in my head
16:54:22 <benmachine> it just didn't make it to the keyboard
16:54:29 <benmachine> I meant to say the function monad
16:55:07 <aavogt> actually, it _is_ const for that monad instance
16:55:12 <benmachine> yes
16:55:30 <benmachine> but me saying that it was the monad return was redundant and/or nonsensical
16:56:11 <Cale> bjorkintosh: Well, ubuntu isn't a nightmare. It's just that it's behind in terms of the GHC version, almost perpetually because of a bad misalignment in dev schedules. Installing the generic linux binary is fine.
16:56:50 <ezyang> Here's my new parsing code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9015#a9015
16:57:00 <bjorkintosh> cale, do you use ubuntu?
16:57:08 <ezyang> I use Ubuntu
16:57:14 <ezyang> Let me dig out the PPA I'm using
16:57:37 <ezyang> bjorkintosh: http://ppa.launchpad.net/someone561/ppa/ubuntu
16:58:00 <ezyang> And then use the Haskell Platform
16:58:15 <benmachine> I tried to install the haskell platform from yaourt but I got bored
16:58:40 <benmachine> because it kept prompting me three times for every single one of about ten dependencies
16:58:45 <jfoutz> ezyang: nice. very clean.
16:59:01 <ezyang> jfoutz: sweeto
16:59:07 <ezyang> now, to make my code actually use this :-)
16:59:12 <benmachine> can it be installed in a distribution-agnostic way?
16:59:22 <ezyang> well, first, I should make it compile
16:59:36 <ezyang> aww, I can't do "foobar":_
16:59:41 <ezyang> guards guards!
16:59:53 <bjorkintosh> ah, thanks ezyang
16:59:58 <Makoryu> ezyang: Well, you can, but it means something else
17:00:12 <aavogt> benmachine: that arch packaging issue is fixed (has to do with duplicated depends and makedepends not being nicely tolerated by yaourt)
17:00:41 <benmachine> aavogt: yeah, I'm just really lazy
17:02:13 <kmc> bjorkintosh, did you try debian stable or something newer?
17:02:30 <kmc> with unstable i get GHC 6.10.4 though not every package i'd like
17:02:38 <ezyang> Why doesn't this parse: parseCommand x:_ | x == "create" || x == "collect" || x == "set" = throwError BadArgumentCount
17:02:41 <bjorkintosh> kmc yes.
17:02:42 <kmc> there's probably some cabal interface to dpkg i don't know about
17:02:51 <bjorkintosh> how does haskell fare on freebsd?
17:03:04 <kmc> ezyang, did you try parens around x:_
17:03:10 <ezyang> whoooops
17:03:13 <mike-burns> bjorkintosh: The GHC in ports is old, but there is a working patch that's pending for 6.10.4
17:03:20 <kmc> :t elem
17:03:21 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:03:45 <kmc> ezyang, you can change that guard to ... | x `elem` ["create", "collect", "set"]
17:03:49 <kmc> :t unwords
17:03:50 <lambdabot> [String] -> String
17:03:53 <kmc> > unwords "create collect set"
17:03:54 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:04:02 <ezyang> Well, that means: parseCommand ("create":_) = throwError BadArgumentCount works again
17:04:06 <kmc> > words "create collect set"
17:04:07 <lambdabot>   ["create","collect","set"]
17:04:23 <ezyang> hm
17:04:36 <ezyang> ok, I guess I'll do that
17:05:16 <bjorkintosh> hmm. thanks mike-burns.
17:13:22 <temoto_> Hello. There's a logic board game Corners. http://en.wikipedia.org/wiki/Ugolki How implementation of bot for such game could look in haskell? Program must find best (or some good) move for a given field state.
17:15:18 <Cale> temoto_: Well, you might start by constructing the complete game tree.
17:15:52 <temoto_> Cale: pardon, 'game tree'?
17:16:20 <Cale> A tree whose nodes represent the positions that the game can be in
17:16:24 <mike-burns> bjorkintosh: I was incorrect about FreeBSD: 32 hours ago 6.10.4 hit the ports tree.
17:16:32 <Cale> and the children of any node are the possible moves from that node
17:19:03 <temoto_> Cale: but there may be thousands of states for 8x8 fields. I don't understand what you mean by 'constructing the tree'.
17:19:25 <Cale> temoto_: Well, it'll be a lazily evaluated data structure. It'll never all be in memory at once.
17:19:31 <bjorkintosh> awesome!
17:20:02 <jfoutz> > 16 * 16 * 3
17:20:03 <lambdabot>   768
17:20:04 <temoto_> I can define a   data CellState = Empty | Chip1 | Chip2
17:20:51 <temoto_> Is   CellState[8][8]    that 'tree'?
17:20:55 <Cale> No
17:21:22 <Cale> That's just one board. I'm talking about all possible positions that the board can get into, as a single datastructure.
17:21:27 <temoto_> jfoutz: yeah, well still much to define those by hand :)
17:21:43 <jfoutz> temoto_: i think there's way more than that ;)
17:23:06 <temoto_> CellState[8][8][8*8*3] ?
17:23:18 <Cale> It's not an array, it's a tree.
17:23:33 <Cale> and it encodes the rules of the game
17:23:49 <temoto_> Defining a tree of field states doesn't fit my mind :(
17:23:57 <Cale> A tree of boards
17:24:08 <temoto_> I can only imagine that.
17:24:34 <Cale> If you can imagine it, why shouldn't it be possible to program it? :)
17:25:00 <Cale> But this is actually a really common strategy for writing AIs
17:25:05 <temoto_> Because i'm very new to haskell and i don't understand how to code it.
17:26:07 <temoto_> In C implementation i had a Field (like here CellState[8][8]) and Move which is a pair of coordinates, defining which chip moved where.
17:26:30 <jfoutz> temoto_: if you make some sort of borard representation, say [[C1,C1,C1,C1,E,E,E,E], ...] then make a function c1move that trys every C1 move in every square. you'd make a list of answers. then for every answer try c2move
17:27:03 <temoto_> I guess you mean that i must define a tree with fields as nodes as moves as edges, but i can't imagine how to formally define it.
17:27:23 <jfoutz> recurse till youve worked out every possible game state
17:28:08 <temoto_> I thought Cale wanted me to define a haskell data type, no?
17:28:21 <jfoutz> or, better, don't bother calculating the c2moves for c1moves you didn't take. yeah... same thing.
17:28:22 <Cale> temoto_: Well, a datatype along with a value...
17:28:29 <jfoutz> kinda
17:29:13 <Cale> temoto_: How did your AI explore the set of possibilities in the C program?
17:30:48 <temoto_> Well, for data Field = CellState[8][8]   (is that even correct? :) )   i'd define  data HmmTree = HmmTree Move | Field ?
17:31:39 <Cale> data Tree a = Branch a [Tree a]
17:31:44 <jfoutz> think about tictacktoe. _________ -> [x________->[xo_______->[xox_...],x_o______...],_x_______->[ox_______,_xo______,...],__x....]
17:32:06 <Cale> Then you'd have it be a value of type  Tree Field
17:32:20 <Cale> where Field is any one of a number of appropriate representations...
17:34:04 <temoto_> Cale: very dumb way :) i wrote an field_eval function which summs up all distances from current chips to the enemy corner. Then i iterate all 'my' chips, try a move in 4 directions, for each possible move i calculate field_eval again. If that beats previous stored best_eval - we have a good move!
17:34:49 <temoto_> jfoutz: i understand that! Thanks :)
17:36:01 <temoto_> But how this tree helps?
17:36:19 <Cale> temoto_: So when you're trying those moves, you're really exploring a tree, aren't you?
17:36:36 <Cale> It's just that in C, you couldn't actually give that tree a name because it was too large.
17:37:16 <Cale> From any given position, there will be some list or set of positions that we can get to.
17:37:42 <Cale> and we're trying to find the one we think is the best from where we are in the tree already
17:38:09 <Cale> and to do that, we might look two or more levels down in the tree from where we are
17:38:25 <temoto_> Yeah i thought about making it better to look deeper.
17:38:40 <temoto_> it would be great
17:39:11 <ezyang> Typecheck +1!
17:39:33 <EvilTerran> ?type (+1) -- :P
17:39:34 <lambdabot> forall a. (Num a) => a -> a
17:40:06 <temoto_> It's hard to think in lazy structures.
17:40:26 <temoto_> I can't imagine program state.
17:40:39 <Cale> Well, it's not so hard to define. Start with a function  movesFrom :: Board -> [Board]
17:41:02 <Cale> and a starting position:  start :: Board
17:41:13 <dancor> I'm still unsure when it's good to use an actual Tree vs just a -> [a]
17:41:20 <ezyang> Ok, anyone willing to do some code review?
17:41:24 <temoto_> Right.
17:41:33 <ezyang> (essentially, making it look /more like Haskell/)
17:41:36 <aavogt> ezyang: paste away
17:41:40 <jfoutz> ezyang: i'm happy to loock, but i'm a big old noob.
17:41:45 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9016#a9016
17:41:57 <Cale> treeFrom :: Board -> Tree Board
17:42:18 <Cale> treeFrom b = Branch b (map treeFrom (movesFrom b))
17:42:35 <Cale> gameTree = treeFrom start
17:43:58 <temoto_> erh... treeFrom seems to be forever
17:44:00 <jfoutz> ezyang: "let id =" seems creepy. i know you meen member id.
17:44:13 <ezyang> I can call it mid or something
17:44:31 <Cale> temoto_: Well, if we never run out of possible moves, then yeah, it'll be an infinite tree.
17:44:55 <jfoutz> might be better. reads sort of like for = i; i<10; i++;
17:45:01 <Cale> temoto_: But probably the game will eventually force you into a position from which you can't move, or one player has already won.
17:45:29 <Cale> temoto_: But even if it was an infinite tree, that would be no problem.
17:45:50 <Cale> temoto_: We're never going to look at it all, so we don't need to worry about the infinite storage it might take.
17:45:51 <blackh1> ezyang: Can you write this without the IO?
17:46:13 <temoto_> Cale: i must define movesFrom such way so in win position it returns a [] so treeFrom will stop?
17:46:31 <Cale> temoto_: Well, you don't *have* to.
17:46:42 <ezyang> blackh1: The code living in IO mostly has to live in IO
17:46:46 <Cale> temoto_: But it's probably a good idea if there are no moves from there.
17:46:59 <blackh1> ezyang: Just checking. :)
17:46:59 <ezyang> doCommand lives in IO, but it uses subfunctions that are not in IO
17:47:06 <ezyang> Actually, they should probably live on their own
17:47:20 <Cale> temoto_: If it's easier to check for a winner separately, you could just prune the tree after the fact.
17:47:49 <blackh1> ezyang: Not sure which Exception module you're using but throw should probably be throwIO
17:48:06 <ezyang> throw is correct
17:48:09 <jfoutz> ezyang: i think pulling out of io would make the setname/affil/dues cleaner.
17:48:29 <ezyang> (for now, anyway. I think that's probably going to change)
17:48:39 <ezyang> jfoutz: Hmm, how would you suggest doing that?
17:49:03 <Cale> temoto_: There's nothing wrong with using an infinite datastructure in Haskell. In fact, it's often the best option, and one which you don't usually get in strict languages.
17:49:47 <lament> data is code!
17:49:50 <blackh1> ezyang: You could implement Create as modifyState $ \state -> .... and do most of your work inside modifyState
17:50:08 <blackh1> I mean... most of your work as an argument to modifyState.
17:50:10 <temoto_> Cale: it's very hard to imagine using an infinite data structure on a real finite resources system :)
17:50:22 <Cale> temoto_: The way it works is that any part of the tree which you haven't explicitly pattern matched against will still be stored as a piece of code for generating that part of the tree.
17:50:26 <ezyang> True.
17:50:51 <Cale> temoto_: When you pattern match on that part of the tree, that code runs and is replaced with the actual data which it constructs.
17:51:10 <Cale> (which might itself contain some unevaluated expressions)
17:51:30 <blackh1> ezyang: It may be too trivial to warrant doing that in this case, but I usually find it's good to do it anyway, because it makes the code move in the right direction (towards being pure).
17:51:58 <Cale> temoto_: If you lose your last reference to some part of the tree, then that part of the tree is discarded by the garbage collector.
17:52:00 <ezyang> So, at the very least, moving this out of the IO monad means I need at least Reader and ERror
17:52:04 <ezyang> *Error
17:52:24 <ezyang> Probably Writer too
17:52:46 <ezyang> (for verbose logging)
17:52:54 <blackh1> ezyang: What I usually do is just write it straight, and only add Reader and error and such if it really makes it clearer.
17:52:55 <Cale> temoto_: So the part of the tree which is actually in memory at any one time will be some fragment, possibly not including the root anymore (since it will hopefully be garbage collected once you've actually started making moves), and only including whatever nodes you've actually examined for real.
17:53:59 <blackh1> ezyang: Another cool thing you can do is return IO actions for processing later.
17:54:02 <temoto_> Cale: now i see how linked lists are better than arrays. You can free unused items.
17:54:12 <Cale> temoto_: yeah.
17:54:14 <ezyang> blackh1: That counts as living in the IO monad :-)
17:54:19 <jfoutz> blackh1: i was just gonna suggest that.
17:54:26 <Cale> temoto_: Well, and they can be infinite.
17:54:55 <Cale> temoto_: For many lists, only one element will ever be in memory at any given time.
17:54:56 <fnord123> Hi all. I'm looking for a version of zip that will zip into a list. so... zipList :: [a] -> [a] -> [[a]]. I see something in Control.Applicative but I don't think that's what I want.
17:55:03 <ezyang> Hmm, opts probably wants to live in Reader anyway
17:55:16 <Cale> Lists are effectively the datastructure version of loops.
17:55:45 <Cale> fnord123: Perhaps you mean zipWith (\x y -> [x,y]) ?
17:55:57 <Makoryu> :t zipWith (\x y -> [x,y])
17:55:58 <lambdabot> forall b. [b] -> [b] -> [[b]]
17:56:06 <fnord123> Cale. thanks. /me hangs head in shame
18:03:14 <ezyang> When should I use =<< instead of >>=?
18:03:23 <benmachine> when it looks prettier
18:03:25 <kmc> :t (>>=)
18:03:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:03:29 <kmc> :t (=<<)
18:03:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:03:39 <kmc> it just swaps the order of arguments
18:03:48 <ezyang> Hmm, do I like putState =<< doCommand command =<< getState better?
18:03:58 <ezyang> or getState >>= doCommand command >>= putstate?
18:03:58 <benmachine> I don't
18:04:16 <benmachine> imo =<< shouldn't usually form a chain
18:04:27 <kmc> i would go with the latter, because we read english left to righw
18:04:35 <benmachine> it is sometimes useful because it looks a little like function application
18:04:35 <kmc> and haskell is englishy
18:04:50 <benmachine> e.g. print =<< getArgs
18:05:07 <ezyang> ah
18:05:35 <benmachine> so if you have a >>= b and b is quite long and a is quite short, it might be easier to write b =<< a
18:07:04 <benmachine> or maybe it looks nicer with <-
18:07:44 <temoto_> Is there a better way to write [Chip1, Chip1, Chip1, Chip1, Empty, Empty, Empty, Empty] ?
18:07:51 <benmachine> text <- hGetContents =<< openFile "" ReadMode
18:08:29 <benmachine> temoto_: depends how you judge "better" -- it could be written replicate 4 Chip1 ++ replicate 4 Empty
18:08:50 <aavogt> > concatMap (replicate 4) ["a","b"]
18:08:51 <lambdabot>   ["a","a","a","a","b","b","b","b"]
18:09:02 <benmachine> or that
18:09:10 <benmachine> > concatMap (replicate 4) [a, b]
18:09:11 <lambdabot>   [a,a,a,a,b,b,b,b]
18:09:21 <benmachine> (lambdabot is cleverer than she looks)
18:09:24 <aavogt> :t a
18:09:25 <lambdabot> Expr
18:09:31 <aavogt> :t a
18:09:33 <lambdabot> Expr
18:09:33 <aavogt> :t ab
18:09:35 <lambdabot> Not in scope: `ab'
18:09:43 <benmachine> I think it is just for some common names
18:09:46 <benmachine> :t f
18:09:47 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
18:09:59 <aavogt> :t a f
18:10:00 <ezyang> Ok, I removed it from IO
18:10:01 <lambdabot>     Couldn't match expected type `a -> t' against inferred type `Expr'
18:10:01 <lambdabot>     In the expression: a f
18:10:04 <benmachine> :t f a
18:10:05 <lambdabot> forall t. (SimpleReflect.FromExpr (Expr -> t)) => t
18:12:21 <aavogt> > f [a..]
18:12:22 <lambdabot>   Add a type signature
18:12:39 <aavogt> > map f [a..]
18:12:40 <lambdabot>   Add a type signature
18:12:52 <aavogt> > map f [a..] :: [Expr]
18:12:53 <benmachine> is instance Monoid IO where mempty = return (); mappend = (>>) valid?
18:12:54 <lambdabot>   * Exception: not a number
18:13:09 <ezyang> Do I get Monad m => m a1 -> (a1->r) -> m r ?
18:13:23 <aavogt> ezyang: flip fmap
18:13:34 <aavogt> or flip liftM
18:13:52 <ezyang> I was hoping for a <**> style operator
18:13:58 <ezyang> This is in the >>= >>= chain I was making
18:14:15 <aavogt> :t flip (<$>)
18:14:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
18:15:34 <aavogt> benmachine: I think the monad laws take care of the associativity needed for a monoid instance
18:15:42 <temoto_> > data Board = String[8][8]
18:15:44 <lambdabot>   <no location info>: parse error on input `data'
18:15:50 <aavogt> but I think you meant :   instances Monoid (IO ()) where ...
18:15:54 <temoto_> , data Board = String[8][8]
18:16:08 <benmachine> aavogt: oh, yeah I did
18:16:13 <aavogt> heh, typos here too
18:16:36 <temoto_> how do you this bot evaluating what needed... no matter, the point is i get
18:17:15 <aavogt> temoto_: it doesn't let you declare new data types
18:17:18 <temoto_> data Cell = Empty | Chip1 | Chip2       data Board = Cell[8][8]   <- error on this line
18:17:27 <temoto_> (on second)
18:17:34 <benmachine> I was thinking of making a Writer that spat out actions, but actually I think a list of strings'd be just as good for my use
18:17:45 <chessguy_work> 'evening
18:18:07 <temoto_> Only unit numeric type pattern is valid
18:18:29 <aavogt> temoto_: How is this Board supposed to be represented?
18:18:34 <chessguy> temoto_, http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
18:19:02 <temoto_> aavogt: array of arrays, i suppose. I'm not sure.
18:19:39 * BMeph restrains himself from throwing his over-used meme at temoto_...
18:19:58 <aavogt> @quote BMeph
18:19:58 <lambdabot> BMeph says: feels like the Village Idiom of #haskell
18:20:36 <lament> @quote yo dude
18:20:36 <lambdabot> No quotes for this person. Just try something else.
18:20:42 <lament> @quote yo
18:20:43 <lambdabot> edwardk says: People are strange, when you're a shapr, faces look ugly when you're alone, women seem wicked when you're unwanted, streets are all uphill when you're a clown. when you're straaaange
18:20:43 <lambdabot> no one remembers your name... coz its changed...coz its changed.. coz its... chaaannnngeed.
18:21:27 <lament> @quote dawg
18:21:27 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
18:21:29 <aavogt> @quote yo.*.dude
18:21:29 <lambdabot> No quotes match. That's something I cannot allow to happen.
18:21:35 <aavogt> @quote yo.dude
18:21:35 <lambdabot> No quotes match. I am sorry.
18:21:38 <kmc> @quote mem
18:21:38 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
18:21:40 <kmc> @quote meme
18:21:40 <lambdabot> No quotes match. You type like i drive.
18:21:40 <lament> it's not even dude. it's dawg.
18:21:44 <lament> @quote dawg
18:21:45 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
18:22:06 <chessguy> pjdelport++
18:22:21 <lament> no way that's the only dawg quote :(
18:22:35 <temoto_> I'm sorry i don't understand how Data-Array link could help.
18:22:44 <meanburrito920_> cabal is complaining I don't have base installed, but when I try and cabal install base it gives me the following error:
18:22:44 <fnord123> @quote comonad
18:22:44 <lambdabot> wli says: Monads are like constipation. Comonads are like Ex-Lax.
18:23:05 <meanburrito920_> cabal: Distribution/Client/Dependency/TopDown.hs:170:37-73: Non-exhaustive patterns in lambda
18:23:16 <BMeph> meanburrito920_: Yeah, ur doin it rong. :\
18:23:23 <temoto_> Do i have to replace data Board with = Array Cell 8 8 or something?
18:23:29 <meanburrito920_> BMeph: how so?
18:24:23 <BMeph> meanburrito920_: If cabal is complaining that base isn't installed, it pretty much means that it can't find GHC.
18:24:36 <meanburrito920_> i know I do have ghc installed
18:24:53 <ezyang> Holy crap I had a eureka moment
18:25:06 <BMeph> meanburrito920_: Ah, but does cabal know it? I think not. ;)
18:25:14 <meanburrito920_> BMeph: how do I tell it so?
18:25:42 <BMeph> ezyang: What, did Joe Morton pop in and tell you  you were ding it wrong? ;p
18:26:38 <vav> meanburrito920_: if it's looking for base-4 for something you're trying to install that means ghc-6.10.1 or greater, if your ghc's older upgrade ghc or use Haskell Platform
18:26:52 <ezyang> Maaaybe :-)
18:27:10 <meanburrito920_> this is the version: cabal: Distribution/Client/Dependency/TopDown.hs:170:37-73: Non-exhaustive patterns in lambda
18:27:12 <meanburrito920_> oops
18:27:19 <meanburrito920_> i mean 6.10.3
18:27:57 <meanburrito920_> I'm just trying to install a skeleton project I'm going to start
18:28:00 <BMeph> meanburrito920_: Yeah, I'd get  .4, and try it again. :)
18:29:58 <dancor> is haskell-prime actually happening in late 2009?
18:31:26 <meanburrito920_> BMeph: if I make install .4 over the top of .3, will that cause problems? should I remove .3 first?
18:33:12 <BMeph> meanburrito920_: I don't think it's a problem, but I'd remove it anyway. YMMV. :)
18:33:54 <meanburrito920_> k
18:35:31 <meanburrito920_> BMeph: is there a method of automatic uninstall?
18:38:11 <BMeph> meanburrito920_: It depends on which way you installed in the first place. :)
18:38:43 <meanburrito920_> make install from the tarball.
18:41:23 <ezyang> Ok, I removed IO from my code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9016#a9017
18:41:34 <SamB> ... is curses supposed to support C-<function-key> ?
18:49:17 <meanburrito920_> ok, i got it all working but cabal is complaining that MIT is not a recognized license
18:49:26 <meanburrito920_> is there a list of recognized licenses somewhere?
18:50:07 <blackh> ezyang: I like it
18:50:56 <ezyang> blackh: whoo
19:04:06 <Makoryu> meanburrito920_: That's odd... http://hackage.haskell.org/trac/hackage/ticket/561
19:04:57 <aavogt> what happened to this ghc extension: http://web.archive.org/web/20051225233302/http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#linear-implicit-parameters
19:04:57 <Makoryu> meanburrito920_: http://hackage.haskell.org/package/HList
19:06:03 <dancor> what does takusen gain by being in its weird monad instead of io?
19:06:32 <dancor> you can't accidentally do a query outside of session
19:14:44 <yrlnry> I just had an inspiration.  I renamed my QueueMonad type "QueueOperation" instead, and suddenly everything makes perfect sense.
19:22:13 <jaredj> i'm parsing an SGML file. some tags are sort of structural elements, and others are just tags for a single value that follows
19:22:50 <jaredj> i had the bright idea of parsing the structural tags with state into their own record types
19:23:12 <jaredj> and the file as a whole with no state, into a record type
19:23:28 <jaredj> problem: trying to run the stateful parsers inside the stateless parser results in a type conflict
19:23:54 <jaredj> i'm in a rut
19:24:19 <jaredj> i think i need to think in terms of a different data structure but i don't know what
19:29:35 <blackh> jaredj: What kind of parser is the stateful one?
19:30:23 * heatsink 's heap usage graph looks like a right triangle :(
19:39:21 <fnord123> > pl (\x y -> x y)
19:39:22 <lambdabot>   Not in scope: `pl'
19:40:56 <fnord123> @pl (\x y -> x y)
19:40:56 <lambdabot> id
19:41:52 <Makoryu> :t id map (+)
19:41:53 <lambdabot> forall a. (Num a) => [a] -> [a -> a]
19:44:26 <meanburrito920_> is there a way to make cabal compile the project in the current directory?
19:44:40 <meanburrito920_> I don't want to send all my binaries off to another folder
19:45:19 <lispy> heatsink: that's not uncommon
19:45:35 <lispy> heatsink: does it ascend up to the max usage or start high and go down?
19:46:24 <heatsink> lispy: It rises to the maximum usage.
19:48:20 <Makoryu> :t (`id`)
19:48:21 <lambdabot> parse error on input `)'
19:49:04 <kmc> heatsink, is it building a bunch of thunks and then evaluating them all at the end?
19:50:35 <heatsink> I don't know, but it seems to be making progress as it goes, so my guess is that it's holding on to some data that it never evaluates.
19:50:54 <Orclev> ok, so I've got a (Either a (Maybe b)) and I want to apply a pure function to b... I know there's a way to do that using something like ap, but I'm having trouble figuring it out
19:50:58 <lispy> heatsink: I think that' sa pretty good guess
19:51:01 <heatsink> I'm going to put in SCCs manually and profile again so I can narrow down where the problem is.
19:51:16 <dibblego> Orclev, see fmap
19:51:18 <lispy> heatsink: you have the auto-all and cafs specificed riht?
19:51:38 <Orclev> dibblego: yeah, I'm looking at fmap currently, but it's complaining about the types not matching up
19:51:44 <dibblego> @type fmap fmap fmap
19:51:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:51:57 <lispy> Orclev: well, you have two functors wrapped up
19:52:03 <lispy> Orclev: so you may need to fmap more than once
19:52:10 <Orclev> ah
19:52:19 <kmc> :t fmap fmap
19:52:20 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
19:52:24 <dibblego> Orclev, it might help to work all the types by hand
19:52:48 <heatsink> lispy: I have auto-all, but it's not very helpful.   Something like 10% of time is in various bind and return functions.
19:52:57 <copumpkin> fmap . fmap === fmap fmap fmap
19:53:05 <kmc> :t fmap
19:53:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:53:08 <kmc> :t fmap . fmap
19:53:09 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:53:19 <Rotaerk> what do you guys usually do when two modules have the same operator?
19:53:27 <Rotaerk> such as Array and Map
19:53:29 <copumpkin> import one or both of them qualified
19:53:31 <Rotaerk> having (!)
19:53:37 <dibblego> Rotaerk, import qualified
19:53:49 <kmc> or use the qualified name only in case of ambiguity
19:53:50 <Rotaerk> k, was wondering if you aliased it with a different op name or something
19:53:55 <Makoryu> Rotaerk: Import qualified, and maybe assign new names for them in the current module.
19:53:55 <heatsink> lispy: And the code that prints debug output is the biggest single contributor to the time and allocation counts for some reason.
19:53:56 <volante> hi, haskell newbie here.. i want to make a function to turn [[1,2,3],[4,5,6],[2,2]] into [1,2,3,4,5,6,2,2]
19:54:02 <Rotaerk> hmm k
19:54:04 <Makoryu> volante: concat
19:54:06 <psal> :t concat
19:54:07 <lambdabot> forall a. [[a]] -> [a]
19:54:07 <Orclev> could also hide one of them if you don't need it
19:54:11 <kmc> Rotaerk, Map is mostly intended to be imported qualified otherwise it conflicts with a lot of prelude stuff
19:54:15 <volante> but im getting errors... let join x = if length x == 1 then head x else head x ++ join (tail x)
19:54:18 <dibblego> volante, concat or join
19:54:42 <lispy> heatsink: it's probably forcing computations
19:54:46 <lispy> heatsink: try removing it
19:55:04 <dibblego> volante, there are a number of things wrong with that function -- why not just call concat or join?
19:55:16 <heatsink> lispy: Good idea, I shall do that.
19:55:17 <kmc> dibblego, it is a good exercise
19:55:20 <volante> i didnt realise contact or join exist. but out of interest i'd like to know what's wrong
19:55:35 <dibblego> kmc, you mean volante is trying to write concat?
19:55:39 <lispy> volante: sounds like homework :)
19:55:45 <kmc> volante, so definitely don't match a list, then call length and head
19:55:49 <kmc> you should pattern-match the list instead
19:55:55 <kmc> a case for [], and a case for (x:xs)
19:56:04 <heatsink> volante: 'head' doesn't give you a list, it gives you a single element, so you can't use "head x" as a list.
19:56:24 <volante> ok, sounds like i need to go off and read much more about haskell than the 1 page tutorial i've read so far :)
19:56:35 <Petrosian> heatsink: Well, it does if you do head of [[a]]
19:56:37 <copumpkin> volante: beware
19:56:39 <volante> can you recommend some good online reading?
19:56:43 <Petrosian> Which in this case, he is, isn't he?
19:56:48 <psal> volante: I've been reading for a month now and I haven't written much code yet, but it is still fascinating
19:57:09 <psal> volante: real world haskell, learn you a haskell, various monad tutorials
19:57:19 <dibblego> volante, let join [] = error "todo"; join (head:tail) = error "todo" -- start here
19:57:19 <heatsink> oh... right.
19:58:02 <copumpkin> (?) = undefined
19:58:10 <copumpkin> then you can put "holes" in agda-style
19:58:28 <copumpkin> might not work though :(
19:58:32 <volante> so, "let join x = " doesnt specify whether x is a list or a single element?
19:58:38 <copumpkin> as it's not gonna be used infix :/
19:58:50 <kmc> volante, no, the type is inferred
19:58:59 <blackh> @lyah
19:58:59 <lambdabot> Unknown command, try @list
19:58:59 <kmc> from what you do with x
19:59:07 <copumpkin> volante: I'd start with concat x, cause if you look at the type of join it might be a little scary :P
19:59:11 <dibblego> @where lyah
19:59:12 <lambdabot> www.learnyouahaskell.com
19:59:24 <blackh> volante: What he said^
20:01:19 <volante> thanks for the help, its clear i need to do some more reading :)
20:02:11 <Orclev> wtf... how is it figuring that "foo a = putStrLn a" has type IO ()?... I mean, a -> IO () sure... but just IO ()???
20:02:29 <Orclev> :t foo a = putStrLn a
20:02:30 <lambdabot> parse error on input `='
20:02:32 <Orclev> hmm
20:02:41 <dibblego> Orclev, it isn't
20:02:48 <Orclev> is it :let?
20:02:58 <dibblego> @type let foo a = putStrLn a in foo
20:02:59 <lambdabot> String -> IO ()
20:03:09 <Orclev> yeah, that's what I expected
20:03:56 <Orclev> I'm getting "Couldn't match expected type `a -> b' against inferred type `IO ()'"
20:04:08 <blackh> volante: Enjoy! Haskell is fun.
20:04:09 <copumpkin> what did you write?
20:04:14 <dibblego> then you must have something else
20:04:25 <copumpkin> getting an a -> b type is hard :P
20:05:03 <Vanadium> Trying to understand the monadlib source is causing me headaches. :(
20:05:48 <Orclev> fmap . fmap (\s -> foo s) response... I started with just (foo), but it was complaining so I figured I'd try making it explicit
20:06:24 <dibblego> (fmap . fmap) (\s -> foo s)
20:06:41 <dibblego> fmap . fmap $ foo -- more conventional
20:07:02 <aavogt> fmap fmap fmap foo -- more controversial
20:07:02 <Orclev> the first one yields Couldn't match expected type `()' against inferred type `f b'
20:07:17 <kmc> :t fix fmap
20:07:18 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
20:07:18 <lambdabot>       Expected type: a
20:07:18 <lambdabot>       Inferred type: f a
20:07:37 <lispy> heatsink: did removing the traces help?
20:08:18 <Rotaerk> hmm just made tic-tac-toe in haskell
20:08:22 <Rotaerk> code probably sucks though
20:08:25 <heatsink> lispy: It's not on this computer.  I'll do it tomorrow.
20:08:43 <lispy> heatsink: unacceptable ;)
20:08:46 <Orclev> Rotaerk: I did something similar... and likewise, the code probably sucks
20:09:06 <heatsink> thx lispy
20:10:00 <lispy> heatsink: have you looked for obvious leaks like foldr and foldl?
20:10:05 <lispy> (foldl' is okay though)
20:11:13 <Cale> foldl' can be just as bad as foldr if misused, and foldr can be just as good as foldl' if used properly...
20:11:58 <lispy> Cale: fair enough, i've seen leaky foldl's now that mention it
20:12:57 <BMeph> Orclev: Do you have an hpaste of what you're doing to get that error? :)
20:13:04 <heatsink> I didn't see something obvious like that, but also, there's a lot of code.  Most of it's in a monad, and the monad is in IO because it's doing unification, but I'll be taking it out soon because I added in nondeterministic choice to deal with a problem case, which means I shouldn't be doing unification with pointer updates now.  The code's kind of complicated.
20:13:12 <Orclev> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9018#a9018
20:13:14 <Orclev> it's partial
20:13:54 <kmc> :t (fmap . fmap print)
20:13:56 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Show a1) => (a -> a1) -> f a -> f (IO ())
20:14:01 <kmc> :t (fmap . fmap) print
20:14:02 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1, Show a) => f (f1 a) -> f (f1 (IO ()))
20:15:14 <Rotaerk> here 'tis http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9019#a9019
20:15:38 <Rotaerk> my first complete (though perhaps not quite finished... might make an AI) program
20:16:30 <Orclev> :t fmap . fmap $ putStrLn
20:16:31 <lambdabot> forall (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f (f1 String) -> f (f1 (IO ()))
20:16:46 <Orclev> ... I don't get it, that's more or less exactly what I'm doing
20:17:02 <Orclev> :t fmap . fmap $ putStrLn Just "Blah"
20:17:03 <lambdabot>     Couldn't match expected type `String'
20:17:04 <lambdabot>            against inferred type `a -> Maybe a'
20:17:04 <lambdabot>     In the first argument of `putStrLn', namely `Just'
20:17:13 <Orclev> oh right
20:17:25 <Orclev> :t fmap . fmap $ putStrLn (Right (Just "Blah"))
20:17:26 <lambdabot>     Couldn't match expected type `String'
20:17:26 <lambdabot>            against inferred type `Either a (Maybe [Char])'
20:17:26 <lambdabot>     In the first argument of `putStrLn', namely `(Right (Just "Blah"))'
20:17:49 <Orclev> :t (fmap . fmap $ putStrLn) (Right (Just "Blah"))
20:17:50 <lambdabot> forall a. Either a (Maybe (IO ()))
20:18:00 <aavogt> @type fmap fmap fmap putStrLn $ Right $ Just "Blah"
20:18:01 <lambdabot> forall a. Either a (Maybe (IO ()))
20:18:36 <Orclev> hmm.... maybe the type of what I'm passing in is screwed up
20:18:38 <kmc> wait what's the goal here?
20:18:50 <Orclev> to print the thing buried inside all those wrappers
20:18:56 <kmc> for all this functory goodness there's probably a more explicit way
20:19:00 <kmc> why not just case out on the value
20:20:01 <kmc> :t let f x = case x of { Right (Just y) -> print y; Left _ -> putStrLn "whooops" } in f
20:20:02 <lambdabot> forall t t1. (Show t1) => Either t (Maybe t1) -> IO ()
20:20:04 <aavogt> @type let tra = Data.Traversable.traverse in tra (tra putStrLn) (Right $ Just "Blah")
20:20:05 <lambdabot> forall a. (Data.Traversable.Traversable (Either a)) => IO (Either a (Maybe ()))
20:20:26 <kmc> @pl let f x = case x of { Right (Just y) -> print y; Left _ -> putStrLn "whooops" } in f
20:20:26 <lambdabot> (line 1, column 21):
20:20:26 <lambdabot> unexpected "{"
20:20:26 <lambdabot> expecting variable, "(", operator, ";" or "in"
20:20:29 <Orclev> that's the way I got it to work before, but I'm trying to take advantage of the fact that one of the wrappers is a Error monad
20:20:32 <aavogt> @type let tra = Data.Traversable.traverse_ in tra (tra putStrLn) (Right $ Just "Blah")
20:20:33 <lambdabot> Not in scope: `Data.Traversable.traverse_'
20:20:43 <aavogt> @type let tra = Data.Foldable.traverse_ in tra (tra putStrLn) (Right $ Just "Blah")
20:20:44 <lambdabot>     No instance for (Data.Foldable.Foldable (Either a))
20:20:44 <lambdabot>       arising from a use of `tra' at <interactive>:1:37-76
20:20:44 <lambdabot>     Possible fix:
20:21:05 <kmc> in the end the case seems clearer than anything involving fmap fmap fmap
20:21:09 <kmc> but, suit yourself :)
20:21:45 <Orclev> Data.Traversable.traverse_?... that looks promising
20:24:35 <aavogt> @type Data.Foldable.traverse_
20:24:36 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
20:25:19 <forgot> is there a library function that can split "123,45" into ["123","45"]?
20:25:27 <dibblego> Data.List.Split
20:25:44 <dibblego> @type break (== ',') -- also
20:25:45 <lambdabot> [Char] -> ([Char], [Char])
20:25:46 <copumpkin> are Wouter and Doaitse related?
20:27:29 <forgot> break (== ',') "123,45" gives me ["123", ",45"]
20:27:44 <roconnor> Data.List.Split
20:28:11 <forgot> where do i find Data.List.Split?
20:28:19 <kmc> :t Data.List.split
20:28:20 <lambdabot> Not in scope: `Data.List.split'
20:28:27 <kmc> hmm, awkward
20:28:31 <roconnor> @hackage split
20:28:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
20:28:34 <dibblego> @type Data.List.Split.split
20:28:34 <BMeph> @hackage split
20:28:35 <lambdabot> Couldn't find qualified module.
20:28:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
20:28:59 <forgot> i have to use a library then
20:29:10 <BMeph> kmc: What roconnor (and I) said. ;)
20:29:13 <aavogt> > (read . ('[':) . (++"]") $ "123,45") :: [Int]
20:29:15 <lambdabot>   [123,45]
20:29:15 <dibblego> or break
20:29:28 <roconnor> <forgot> break (== ',') "123,45" gives me ["123", ",45"]
20:29:50 <kmc> haha
20:29:53 <yrlnry> I would like to know if there is a better or simpler way to write this 4-line function: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9022#a9022
20:29:55 <dibblego> \[x, y] -> (x, y)
20:30:00 <aavogt> break gives you a tuple too
20:30:24 <roconnor> dibblego: I think the problem is the ',' at the head of the second string.
20:30:52 <dibblego> oops, \(x, y) -> [x, y]
20:31:19 <dibblego> I don't see a ',' at the end of a String
20:31:19 <kmc> @undo let mUntil qOp p = do { z <- p; v <- qOp; r <- mUntil qOp p; return (if z then [] else v:r) }
20:31:20 <lambdabot>  Parse error at end of input
20:31:23 <kmc> @undo let mUntil qOp p = do { z <- p; v <- qOp; r <- mUntil qOp p; return (if z then [] else v:r) } in mUntil
20:31:23 <lambdabot> let { mUntil qOp p = p >>= \ z -> qOp >>= \ v -> mUntil qOp p >>= \ r -> return (if z then [] else v : r)} in mUntil
20:31:30 <copumpkin> dibblego: the head?
20:31:30 <dibblego> oh I see, sorry
20:31:33 <kmc> @pl let mUntil qOp p = do { z <- p; v <- qOp; r <- mUntil qOp p; return (if z then [] else v:r) } in mUntil
20:31:33 <lambdabot> (line 1, column 23):
20:31:33 <lambdabot> unexpected "{"
20:31:33 <lambdabot> expecting variable, "(", operator, ";" or "in"
20:33:38 <kmc> :t liftM2 (,)
20:33:39 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
20:33:54 <copumpkin> :t uncurry $ liftM2 (,)
20:33:55 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
20:34:43 * BMeph cyber lifts his shirt and yells, TOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOR!
20:36:50 <yrlnry> Thanks all.  Good night.
20:54:35 <jli> when I use inferior-haskell-mode with ghci 6.8.2 and emacs 23, the prompt never returns anything
20:54:52 <jli> everything is Debian Testing. anyone have similar issues?
21:02:15 <pacopil> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
21:02:37 <blackh> Is there an unboxed version?
21:02:55 * copumpkin pulls out his I# and uses it on pacopil
21:17:47 <ksf> http://research.microsoft.com/en-us/um/people/simonpj/papers/stack-trace/DebugTraces.pdf
21:17:50 <ksf> finally!
21:18:39 <copumpkin> :)
21:20:24 <ksf> thunk traces could be fun, too, though.
21:21:08 <ksf> ...say something like "break", with an interface like "trace", but which gives you a thunktrace as soon as it's evaluated and then lets you continue the program.
21:21:40 <ksf> ...which might help to debug laziness and strictness related stuff.
22:01:57 <kmc> @hoogle [a -> m a] -> a -> m a
22:01:57 <lambdabot> Data.Generics.Basics gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
22:01:58 <lambdabot> Data.Generics.Basics gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
22:01:58 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
22:02:39 <kmc> :t foldr (>>=)
22:02:40 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
22:02:40 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
22:02:40 <lambdabot>     In the first argument of `foldr', namely `(>>=)'
22:02:49 <kmc> :t foldr (<<=)
22:02:50 <lambdabot> Not in scope: `<<='
22:03:00 <kmc> :t foldr (=<<)
22:03:01 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
22:03:10 <kmc> :t flip foldr (=<<)
22:03:11 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a -> ((a1 -> m b) -> m a1 -> m b) -> (a1 -> m b) -> m a1 -> m b) -> [a] -> (a1 -> m b) -> m a1 -> m b
22:03:14 <kmc> :t flip $ foldr (=<<)
22:03:15 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> m b -> m b
22:03:46 <aavogt> @type mconcat (undefined :: Monad m => [a -> m a])
22:03:47 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => a -> m a
22:03:54 <dolio> @type foldr (<=<) return
22:03:55 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
22:04:51 <aavogt> @type msum (undefined :: Monad m => [a -> m a])
22:04:52 <lambdabot> forall a (m :: * -> *). (Monad m, MonadPlus ((->) a)) => a -> m a
22:27:58 <greap> Hi. I've got cairo-devel 1.9.2 and cairo 1.8.8 installed with macports. I get "There is no available version of cairo that satisfies >=0.9.11" when I try to cabal install chart. Is there some environment variable I need to set to point to this version of cairo-devel?
22:28:25 <greap> locate cairo-devel
22:59:19 <ksf> I wanna type threads.
23:00:46 <ksf> greap, you need the haskell cairo bindings, which come with gtk2hs
23:01:19 <ksf> ...those are the ones that message is referring to, not the c ones.
23:02:26 <ksf> sadly enough gtk2hs can't be installed with cabal, for historical reasons that I don't event want to begin to understand.
23:02:55 <greap> ksf: Ah
23:05:00 <greap> ksf: While you're there: You wouldn't know how to use native windowing for opengl apps would you? I Had this, but after I upgraded ghc, it seems to be using x11.
23:06:12 <ksf> hehe.
23:06:25 <ksf> x11 is the native windowing on my system...
23:07:23 <ksf> I guess it depends on what you use to open the window and then in turn what that uses... glut vs. freeglut vs. opengl.
23:07:37 <ksf> er s/opengl/glfw
23:08:49 <greap> I've been using glut.
23:09:11 <greap> I just compiled my program with 6.10.3 and now it seems to have switched to using x11.
23:12:44 <ksf> hmm the cabal file mentions
23:12:45 <ksf>       if os(darwin)
23:12:45 <ksf>          frameworks: GLUT
23:12:45 <ksf>       else
23:12:45 <ksf>          extra-libraries: glut
23:13:43 <ksf> ...you could check whether it's still the same GLUT version and check for any changes, I seriously doubt it has to do anything with ghc 6.10 per se.
23:14:07 <ksf> or just ask on the hopengl mailing list.
23:14:14 <greap> ah, yeah, glut may have updated :)
23:15:10 <ehird> So, what's the best way to get a Haskell environment up on Windows? Haskell Platform?
23:16:07 <ksf> I've heard so.
23:16:28 <ehird> does the haskell platform come with winghci? I guess not
23:16:53 <ksf> I suppose it even comes with half of cygwin
23:17:15 <ehird> it's based on cygwin? :(
23:17:32 <ksf> well, you need something to interpret bash files...
23:17:43 <ksf> but, honestly, I don't know jack about windoze.
23:18:18 <ksf> ...only that cygwin was the first thing I installed on my pc at work, to at least have a proper shell.
23:18:55 <ehird> cygwin is kinda icky due to being non-native and such. there are native ports of *nix shells and tools and suchlike
23:18:56 <ksf> iirc ghc on windoze uses mingw.
23:19:02 <ehird> right
23:21:01 <ksf> @seen conal
23:21:02 <lambdabot> I saw conal leaving #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah 9d 9h 59m 7s ago, and .
23:21:26 <ksf> ah yes, the symposium.
23:22:22 <ksf> I bet all the guys are drowning in fine, scottish whiskey now that it's over.
23:22:31 <ehird> i read that as fire.
23:22:39 <ehird> drowning in fire and scottish whiskey.
23:23:14 <ksf> ...proper whiskey is smooth.
23:23:34 <ksf> and you have to heat alcohol of that percentage to have it burn, properly.
23:24:28 <ksf> (flaming a steak is great fun, btw)
23:25:29 <ehird> ksf: i was just imagining some horrific accident in which two buckets spilled on them
23:25:37 <ehird> one filled with whiskey, the other fire
23:26:56 <ksf> ...there might be some ancestral memory left that identifies scotland with pillage+plundering, yes.
23:27:53 <ksf> but then I think kilts are quite flame-resistant, so they should be fine
23:28:30 * ksf tries not to imagine spj in one of his thousand red pullovers and a kilt
23:29:39 <dancor> does takusen support pulling TIMESTAMP datatypes as anything cooler than String?
23:30:00 <dancor> parsing the string isn't so bad but thought i'd ask
23:30:21 <ehird> (actually liquid fire could have several good applications, like: - drinking it to show how manly you are - demonstrating your manliness by swigging it - gulping it and thus proving your manliness - ...)
23:30:28 <ehird> (i'll stop being silly now...)
23:30:29 * ksf is wondering why he's still trying to find a page that lists all the papers from the symposium for download, given that apparantly acm does the publishing
23:31:02 <ksf> http://en.wikipedia.org/wiki/Snap-dragon_%28game%29
23:35:09 <ksf> mmmmh http://research.microsoft.com/en-us/um/people/adg/Publications/stm-haskell09.pdf
23:37:57 <ksf> indexed monads are utterly underused.
23:38:15 <ksf> ...and utterly undersupported by the libraries.
23:55:05 <ehird> Anyone used WinGhci? It seems that if it's maximised when I quit it it works fine but if it isn't, the next run it just sits there grey without showing the text window. If I bash the keyboard a bit it appears, with a lot of Prelude> before.
