00:05:40 <khora> ok, reinstalled... some cabal worth installing?
00:28:55 <fergie> is there an easy way to see if a string can be read to a float?
00:29:09 <dobblego> @type reads
00:29:10 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:29:36 <fergie> I'm looking for a function of type String->Bool
00:29:48 <dobblego> @type null . reads
00:29:49 <lambdabot>     Ambiguous type variable `a' in the constraint:
00:29:49 <lambdabot>       `Read a' arising from a use of `reads' at <interactive>:1:7-11
00:29:49 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
00:29:50 <Fragsworth> http://stackoverflow.com/questions/1475896/haskell-function-composition
00:30:08 <dobblego> @type \t -> null (reads t)
00:30:08 <lambdabot>     Ambiguous type variable `a' in the constraint:
00:30:08 <lambdabot>       `Read a' arising from a use of `reads' at <interactive>:1:12-18
00:30:08 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
00:31:03 <dobblego> > reads =<< ["0", "7.7", "abc"] :: [(Float, String)]
00:31:04 <lambdabot>   [(0.0,""),(7.7,"")]
00:31:11 <dolio> @type null . (reads :: String -> [(Bool,String)])
00:31:11 <lambdabot> String -> Bool
00:31:25 <dolio> That's ambiguous without the signature.
00:32:45 <fergie> so null . reads is what I'm looking for?
00:33:02 <dobblego> yes, with an appropriate type signature (using Float)
00:33:17 <dobblego> @type null . (reads :: String -> [(Float, String)])
00:33:18 <lambdabot> String -> Bool
00:33:37 <fergie> cool. I'll try that
00:45:42 <bos> @seen dons
00:45:42 <lambdabot> Unknown command, try @list
00:45:48 <bos> ,seen dons
00:45:49 <lunabot>  luna: Not in scope: `seen'
00:53:44 <dmwit> dobblego: You've got to be careful, though, (null . reads) doesn't quite match the contract he asked for.  I guess you know this, but he probably didn't...
00:54:14 <dobblego> dmwit, how do you mean?
00:54:15 <dmwit> > (read "7.7a", reads "7.7a") :: (Float, [(Float, String)])
00:54:16 <lambdabot>   (* Exception: Prelude.read: no parse
00:54:31 <dmwit> > (reads "7.7a", read "7.7a") :: ([(Float, String)], Float)
00:54:31 <lambdabot>   ([(7.7,"a")],* Exception: Prelude.read: no parse
00:54:41 <dobblego> ah yeah good point
00:56:43 <bos> what's the name of the transformation where ghc notices that the body of a function is constant, and floats it up to the top level?
00:57:08 <Fragsworth> How can I display a list of functions? Like in python - printing the list will display functions as <function f at 0xWhatever>
00:58:11 <jfoutz> bos: lambda lifiting? i think that's right.
00:58:15 <bos> i believe i have ghc doing some undesired let floating.
00:58:29 <bos> jfoutz: i think it's let floating in this case.
00:58:32 <jfoutz> oh.
00:58:56 <Cale> Fragsworth: By writing an instance of Show for (a -> b)
00:59:42 <Cale> Fragsworth: There are multiple possibilities. If you choose some constraints on the domain and codomain of the functions for your instance, you can do more interesting things than just printing <function>
00:59:49 <Cale> > not
00:59:49 <lambdabot>   {True->False;False->True}
00:59:58 <Axman6> ...
01:00:02 <Cale> Lambdabot has the instance from the SmallCheck library
01:00:03 <Axman6> where'd that come from :o
01:00:04 <jfoutz> SmallCheck provides something
01:00:05 <Fragsworth> Cale: I'm only barely learning the language, I was wondering if I could do something for debugging/practicing purposes
01:00:08 <jfoutz> heh.
01:00:16 <Axman6> > map
01:00:17 <lambdabot>   {{()->()}->{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}}
01:00:22 <Axman6> o.O
01:00:25 <jfoutz> map (+1)
01:00:31 <jfoutz> > map (+1)
01:00:31 <lambdabot>   []->
01:00:31 <lambdabot>    []
01:00:31 <lambdabot>  [-2]->
01:00:31 <lambdabot>    [-1]
01:00:31 <lambdabot>  [-2,-1]->
01:00:33 <lambdabot> [4 @more lines]
01:00:42 <Axman6> 8|
01:00:49 <jfoutz> it's cool man.
01:00:52 <Cale> Fragsworth: If you just want something quick, you can use  instance Show (a -> b) where show _ = "<fun>"
01:01:10 <Cale> Fragsworth: That will cause all functions to print as <fun>
01:01:23 <danr> > filter
01:01:24 <lambdabot>   {()->True}->
01:01:24 <lambdabot>    {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}...
01:01:28 <Cale> heh
01:01:33 <danr> > mapMaybe
01:01:34 <lambdabot>   {()->Nothing}->
01:01:34 <lambdabot>    {[]->[];[()]->[];[(),()]->[];[(),(),()]->[]}
01:01:34 <lambdabot>  {()->Just ...
01:01:43 <Axman6> :t mapMaybe
01:01:44 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
01:01:45 <Cale> > filter odd
01:01:45 <danr> what is lambdabot actually trying to achieve here?
01:01:46 <lambdabot>   []->
01:01:46 <lambdabot>    []
01:01:46 <lambdabot>  [-2]->
01:01:46 <lambdabot>    []
01:01:46 <lambdabot>  [-2,-1]->
01:01:48 <lambdabot> [5 @more lines]
01:01:50 <mmorrow> @tell ddarius http://moonpatio.com/images/rfft.png
01:01:50 <lambdabot> Consider it noted.
01:02:05 <danr> > liftM unlines
01:02:06 <lambdabot>   No instances for (Test.SmallCheck.Serial (m [GHC.Base.String]),
01:02:06 <lambdabot>            ...
01:02:10 <Cale> I should really see about making it strip the newlines.
01:02:17 <danr> SmallCheck, hrm?
01:02:21 <Axman6> @users
01:02:21 <lambdabot> Unknown command, try @list
01:02:23 <mmorrow> lpsmith: re: loops, this is a pretty sweet flowgraph http://moonpatio.com/images/rfft.png
01:02:26 <Axman6> broken :'(
01:02:41 <mmorrow> for this misc real fft http://moonpatio.com/repos/MISC/fft-misc/rsplitfft.c
01:02:50 <mmorrow> (asm by gcc)
01:03:05 <ehird> Does Leksah have GHCi support?
01:03:19 <danr> flowcharts makes me think of this http://xkcd.com/518/
01:03:26 <lpsmith> ehird:  as far as I can tell, not really
01:03:33 <Axman6> x[i]=(double)10.0*cos(6.2831853071719586*3.0/n*i); o.O
01:03:41 <lpsmith> But I only tried it out for 10 or 15 minutes once :-)
01:03:48 <ehird> lpsmith: what a shame. is there any sort of decent non-terminal ghci stuff in existence?
01:03:50 <ehird> for x11
01:03:55 <danr> > (map *** filter)
01:03:56 <lambdabot>   ({()->()},{()->True})->
01:03:56 <lambdabot>    ({[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]-...
01:04:12 <bos> ooh, i appear to be able to benchmark things down to the level of tens of nanoseconds.
01:04:29 <lpsmith> mmorrow:  is that a fortran-based fft or your unrolled haskell fft?
01:04:34 <danr> > map . (head *** length) . group . sort
01:04:34 <lambdabot>   Couldn't match expected type `([a], [a1])'
01:04:34 <lambdabot>         against inferred type `[...
01:04:38 <lpsmith> bos:  sweet!   How?
01:04:41 <Axman6> oh hey bos, i saw your benchmarking video the other day, and i was very interested in it
01:04:42 <danr> > map (head *** length) . group . sort
01:04:43 <lambdabot>   Couldn't match expected type `([a], [a1])'
01:04:43 <lambdabot>         against inferred type `[...
01:04:46 <ehird> what the cripes is that <lambdabot>   ({()->()},{()->True})->
01:04:46 <ehird>     ({[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]-...
01:04:50 <Cale> > (&&)
01:04:51 <bos> lpsmith: great care
01:04:51 <lambdabot>   {True->{True->True;False->False};False->{True->False;False->False}}
01:05:06 <bos> hey, the lambdabot noise is getting obnoxious.
01:05:27 <Axman6> i've been doing a lot benchmarking recently, and it's all been pretty ad hoc
01:05:38 <danr> > map (head &&& length) . group . sort
01:05:39 <lambdabot>   {[]->[];[()]->[((),1)];[(),()]->[((),2)];[(),(),()]->[((),3)]}
01:05:43 <danr> cute ^_^
01:06:03 <bos> i just defeated ghc's let floater, which had been causing me trouble with benchmarking pure code.
01:06:50 <ehird> i guess all the darned kids just use ghci in emacs :)
01:07:04 <lpsmith> So I assume you aren't using GHC's getCPUTime?
01:07:09 <mmorrow> lpsmith: it's some fft i found on the interwebs, that in the comment says was transcribed from fortran in 1995
01:07:09 <bos> i am.
01:07:11 <mmorrow> hehe
01:07:34 <lpsmith> How do you adjust the resolution?
01:07:37 <Axman6> bos: any chance you'll be releasing this benchmarking code sometime soonish (not like days, but less than years hopefully ;))
01:08:10 <bos> lpsmith: measure the clock resolution and the overhead of a clock call.
01:08:18 <mmorrow> bos: cool
01:08:23 <bos> lpsmith: then run enough loop iterations to make the clock resolution a non-issue.
01:08:43 <bos> lpsmith: i.e. if the clock ticks every 10Âµs, then measure for at least 100ms.
01:08:57 <bos> Axman6: in the next few days.
01:09:10 <Axman6> excellent :D that will be perfectly timed
01:10:00 <Axman6> i'm working on some fourier transform code, trying to find a way to make it faster in haskell, and none of my haskell versions are any faster than each other by much at all
01:10:24 <lpsmith> I tried doing a much cruder version of your benchmarking methodology in my corecursive queue paper,  getCPUTime has a max resolution of 10 milliseconds.   I reported the mean in millis though.
01:10:27 <Axman6> Â±10% roughly (hoping to make that less rough with your benchmarking stuff)
01:10:48 <lpsmith> So you are doing statistical inference to get below 10 millis?   I guess I don't quite understand, but I am intrigued.
01:11:03 <lispy|web> Any way to get GHC to tell me which functions in a module are allocating which types?  I can get heap usage by type for a given module, but now I want to drill deeper and I'm sort of stuck.  The .prof file isn't that useful.
01:11:22 <bos> lpsmith: i see how many loops i need to run for the elapsed time to go above a 10ms threshold.
01:11:46 <bos> run 100 times. did it take more than 10ms? no? run 200 times. run 400 times. etc.
01:11:50 <mmorrow> lpsmith: but regarding earlier and talking about loops in code (by "loop" i just mean a jump to a known location, doesn't have to be within/whatever the same source-level-function), getting more than a single closed-path loop in ghc-produced asm is rare/you really have to try. let alone getting something like that monster.
01:12:43 <mmorrow> but i think there's nothing inherent preventing that
01:14:14 <mmorrow> err, "... by \"loop\" i just mean a closed path of jumps all the labels of which are statically known...."
01:14:48 <mmorrow> so s/loop/whatever you want to call that/
01:15:07 <lispy|web> I might call that the result of TCO :)
01:15:42 <ehird> So is there a cabal2deb yet, or will I stick to an abomination such as writing a script that does "checkinstall cabal install $1 --blah=foo"?
01:20:01 <mmorrow> lispy|web: sure, but in the same way that a golf cart is a drag racer ;)
01:20:47 <lispy|web> mmorrow: you should see the aftermarket mods on my golf cart :)
01:20:55 <mmorrow> snap!
01:28:01 <lpsmith> mmorrow:  what do you mean closed-path loop?   I.e. jumping without an indirect jump?
01:28:43 <lpsmith> err,  looping without any indirect jumps?
01:28:52 <mmorrow> lispy|web: the nontrivial part with functional langs is taking a big expression with multiple levels of nested local function defs, all mutually recursive, some possibly taking functions as args, and eliminating *all* the control flow that's actually statically known
01:29:11 <lpsmith> oh right
01:29:15 <lpsmith> n/m :-)
01:29:22 <lpsmith> You answered my question already
01:29:25 <mmorrow> :)
01:29:34 <lispy|web> mmorrow: I can see how that would be non-trivial and important
01:30:05 <mmorrow> err, s/eliminating/figuring out/, but    you know what i mean
01:30:35 <lispy|web> is there away to turn on cost centres for the CAFs of just *one* module?
01:30:37 <Baughn> lispy|web: Preferably including data-dependent control flow where the data happens to be constrained - not generating a check for empty lists in "foo [] = 1; foo x = ...", for example
01:30:53 <mmorrow> Baughn: totally
01:31:59 <lispy|web> Baughn: wait, how do you avoid a check for an empty list in that example?  Don't you need to know if x is null?
01:32:20 <Baughn> lispy|web: Well.. how about this:
01:33:01 <Baughn> lispy|web: "foo [] = 1; foo (x:xs) = x" <- It should not generate code to check for and produce pattern-match failures in the second clause here
01:33:50 <Baughn> Of course it seems obvious in this case, but the code that actually constrains the list may be located in a different place entirely, in principle
01:34:40 <lispy|web> Baughn: oh, I see
01:34:41 <Baughn> lispy|web: So, hopefully you now understand why it's taken thirty years to make good functional-language compilers. :)
01:35:17 <lispy|web> That's actually pretty fast -- I'm still waiting to see good OO-language compilers
01:35:17 <Botje> we're
01:35:27 <Botje> we're just waiting for Intel to make chips that say "STG inside!"
01:36:24 <lpsmith> heh
01:37:02 <lpsmith> Botje:  ever hear of the Intel iAPX 432?
01:37:12 <Baughn> lispy|web: This is also why you should take care not to export more from a module than absolutely necessary. Well, one of the reasons.
01:37:19 <Baughn> GHC isn't very specialize-happy
01:37:29 <Baughn> ..dynamic optimization could help a lot, there
01:37:45 <lispy|web> I ran into the lack of specialization today
01:38:10 <Baughn> There's a SPECIALIZE pragma, isn't there?
01:38:24 <lispy|web> yeah
01:38:37 <Baughn> Any good?
01:38:52 <lispy|web> In my case, I just rewrote the union function to 1) take advantaged of the list being sorted 2) used my concrete type instead of Ord a
01:39:04 <lispy|web> orders of magnitude faster
01:39:26 <Baughn> Ah. I suppose what you really wanted was a multiset?
01:39:44 <lispy|web> Set actually
01:39:45 <lispy|web> But, I had a list
01:39:48 <lispy|web> I'm kinda lazy...
01:39:53 <lispy|web> This work well enough for now
01:40:20 <Baughn> I'm pretty sure Set has a fromDistinctAscList function
01:40:40 <lispy|web> You're thinking of Map?
01:40:50 <lispy|web> association lists are usually things maps take
01:40:51 <lispy|web> right?
01:40:56 <Baughn> No, I /know/ Map has one
01:40:59 <lispy|web> or Asc means ascending?
01:41:04 <Baughn> Yes
01:41:07 <lispy|web> ah
01:41:13 <Baughn> Ah. Yes, it does.
01:41:24 <Baughn> fromDistinctAscList should be pretty fast
01:41:41 <ManateeLazyCat> http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
01:41:52 <lispy|web> Baughn: but from two lists at once?
01:42:20 <Baughn> lispy|web: A bit more work. Though I might argue that you should stop using lists.
01:42:55 <lispy|web> Well, mornfall tells me the idealest solution is a recursive traversal over the trees.
01:43:17 <lispy|web> Using a sortedUnion instead of union made this function fall off the profiling radar so I stopped
01:43:28 <Baughn> Which is of course exactly what Set.union does
01:43:32 <lispy|web> sortedUnion was like 5 minutes to write so that has advantages :)
01:43:52 <lispy|web> is there a way to get a descending list from the map?
01:44:24 <Baughn> You can probably do something with Foldable, but I haven't looked very closely at it.
01:44:54 <Baughn> It has both left and right-fold, after all. :)
01:45:18 <lispy|web> Baughn: also, a huge win comes from not using Ord
01:45:23 <lispy|web> but a Data.Set will use Ord
01:45:34 <lispy|web> So I'd have to figure out how to make it specialize, right?
01:45:45 <lispy|web> Perhaps I could do that with a type signature
01:46:19 <Botje> lpsmith: sorry, was away. i'll google it
01:47:35 <lpsmith> heh, np
01:48:05 <lpsmith> I'm just a little skeptical of radical hardware shifts,  or trying to do too much in hardware ;-)
01:48:06 <Botje> lpsmith: woah. that is one cool chip :)
01:48:36 <lispy|web> Baughn: hmm...using Data.Set I have to make my list into a Set, union, convert to a list
01:48:46 <lispy|web> Baughn: which is sort of painful.
01:49:04 <lpsmith> and probably slow
01:49:12 <Baughn> lispy|web: Why do you need to make it back into a list?
01:49:24 <lpsmith> but yes,  the iAPX 432 sounds like it was quite interesting
01:50:11 <lispy|web> Baughn: the function returns a list of values
01:50:16 <lispy|web> Baughn: it's a zip
01:50:24 <mmorrow> ManateeLazyCat: ooh, nice
01:50:30 <Baughn> lispy|web: You might make it return a set instead?
01:50:40 <Baughn> lispy|web: Also, Data.Set is considerably faster than Data.List despite using union, as it needs considerably fewer comparison operations
01:50:56 <ManateeLazyCat> mmorrow: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
01:50:58 <mmorrow> ManateeLazyCat: how is that coming along?
01:51:01 <ManateeLazyCat> http://farm3.static.flickr.com/2676/3821227364_e739332f63_o.png
01:51:03 <Baughn> Though probably not as fast as your highly specialized list implementation
01:51:04 <ManateeLazyCat> http://farm3.static.flickr.com/2539/3843685031_9184ddf049_o.png
01:51:06 <lispy|web> Baughn: No that wouldn't be right because the function it's zipping with may return duplicate values
01:51:07 <ManateeLazyCat> http://farm4.static.flickr.com/3483/3947340553_933df88a22_o.png
01:51:15 <Baughn> lispy|web: I see.
01:51:24 <lpsmith> mmorrow:  well, the problem with "closed loops" in GHC is that you have so many thunks lying around,  and those typically involve indirect jumps
01:51:34 <mmorrow> ManateeLazyCat: awesome!
01:51:37 <ManateeLazyCat> mmorrow: I don't know, now i need finish code-completion UI
01:51:54 <ManateeLazyCat> mmorrow: After then i need develop some module.
01:52:25 <ManateeLazyCat> mmorrow: IRC-client, mail-client, download-manager, multimedia-player, web-browser.
01:52:38 <ManateeLazyCat> mmorrow: If i finish above, then i will release it.
01:52:47 <ManateeLazyCat> mmorrow: Maybe at 2009-12
01:53:32 <lpsmith> ManateeLazyCat:   wow,  I really should spend some time streamlining my workflow and workspace a bit :-)
01:53:35 <mmorrow> lpsmith: right, so there'd be outgoing/incoming edges from/into your loop too... much more interesting than boring do/while loops ;) :|
01:53:42 <ManateeLazyCat> mmorrow: It's aim is bulid all fully environment make me live in it, drop Emacs, drop firefox. drop everything.
01:53:43 <lispy|web> Baughn: okay, I'll give a try.
01:53:51 <lispy|web> Baughn: if it's at least as fast as the previous version I'll use it
01:53:54 <eevar2> hm.. does it make coffee?
01:54:13 <lispy|web> Baughn: just have that extra to/from Data.Set that looks awkward to me, but if it's fast, then hey
01:54:14 <kw-> hi, is there a chance that nanocurses gets fixed any time soon?
01:54:17 <lpsmith> ManateeLazyCat:  are you writing your own text editor too?
01:54:19 <mmorrow> ManateeLazyCat: very cool, i look forward to it
01:54:26 <ManateeLazyCat> lpsmith: Yes.
01:54:33 <lispy|web> Baughn: but also, my custom union was fast because it exploited the sorted nature
01:54:40 <Baughn> lispy|web: Ah.. I don't think it'd be faster than your existing one
01:54:53 <ManateeLazyCat> lpsmith: I rewrite everything if it need better than exist tools.
01:54:56 <lispy|web> Baughn: oh, why not?
01:55:11 <Baughn> lispy|web: It's more /flexible/, sure, and Set has more operations than your list supports, but that's little use if you won't use them
01:55:23 <lpsmith> hmm
01:55:49 <ManateeLazyCat> mmorrow: I want make it became best develop environment for programmer.
01:55:58 <Baughn> lispy|web: Because your union function on sorted lists already does no more comparisons than Set.union would, is specialized, and also doesn't have to recurse through trees like the Set variant does
01:56:03 <ManateeLazyCat> mmorrow: Not just editor, i will build everything that i need live in it.
01:56:25 <ManateeLazyCat> mmorrow: And important is, this all implement by Haskell.
01:57:04 <mmorrow> ManateeLazyCat: sounds excellent
01:57:09 <Baughn> lispy|web: OTOH most /other/ operations are far slower. Like checking for the existence of a particular element..
01:58:03 <ManateeLazyCat> mmorrow: I have VTE C library for Haskell, I just need two lines build terminal with Haskell.
01:58:24 <ManateeLazyCat> mmorrow: But VTE C code have something wrong, maybe i need change low-level C code when i have spare time.
01:58:44 <lispy|web> Baughn: the Data.Set version is about 1 second slower
01:59:03 <Baughn> lispy|web: What's that in percent? :P
01:59:06 <lispy|web> Baughn: overall takes about 25 seconds
01:59:17 <lispy|web> used to take about 23
01:59:30 <Baughn> Ah. That's pretty good, considering you keep fromlisting and tolisting it, I guess.
01:59:30 <ManateeLazyCat> mmorrow: Another aim of my project is, i wish my project became very cool, then bring many programmer in it, make them interested Haskell, and contribution for Haskell.
02:00:08 <dancor> can i do   instance (ThingAndMore a) => Thing a   and also have some types that are just Thing without being ThingAndMore?  i seem to be getting overlapping instance errors
02:00:14 <Baughn> lispy|web: I'd bet that the List.union version is slow not because of specialization, but because it does N^2 comparisons.
02:00:29 <lispy|web> Baughn: that's also a slow down
02:00:42 <lispy|web> But, I used Data.OrdList and it was also slow
02:00:51 <Baughn> Hm
02:00:58 <Baughn> Slower than Data.Set?
02:01:02 <Baughn> That shouldn't happen
02:01:11 <lispy|web> then I realized the only difference between my version and Data.OrdList was that I gave a specific type and OrdList just uses Ord
02:01:16 <mmorrow> ManateeLazyCat: having some sort of development environment for/in/whatever haskell is a common question, i think your prog would do exactly that
02:01:27 <lpsmith> OrdList also provides -By functions
02:01:43 <lpsmith> and if you inline the -By functions, all the higher-order stuff goes away :-)
02:01:57 <ManateeLazyCat> mmorrow: My editor is generic-editor for any language, not just for Haskell.
02:01:58 <mmorrow> ManateeLazyCat: good luck!
02:02:03 <Baughn> lpsmith: Sure, but *are* they inlined?
02:02:04 <lpsmith> The control flow graph becomes statically known at that point,  modulo laziness
02:02:18 <Baughn> lpsmith: For that matter, shouldn't the same be true for the Ord functions?
02:02:30 <ManateeLazyCat> mmorrow: Thanks! :)
02:03:12 <ManateeLazyCat> mmorrow: BTW, use Haskell programming with GTK+ is very cool, clearer code and clearer logic....
02:03:56 <lpsmith> Baughn:   the ord functions wouldn't be a big deal unless they are specialized,  and I'll admit I should add specializations to the Ord functions
02:04:39 <mmorrow> ManateeLazyCat: yeah, that seems to happen with pretty much everything ;)
02:05:18 <lpsmith> Baughn:  if you look at the source of unionBy,  it uses the manually-applied static argument transform
02:05:35 <lpsmith> so inlining unionBy would not be worthwhile without that
02:05:55 <lpsmith> the higher-order cmp wouldn't be able to get inlined, or at least transformed into a known call
02:05:56 <ManateeLazyCat> mmorrow: Recently, i'm use GTK+ build frontend UI for code-completion, then implement Haskell API analysis backend.
02:06:57 <ManateeLazyCat> mmorrow: Do you know any package analysis Haskell for code-completion? I mean backend.
02:07:27 <ManateeLazyCat> mmorrow: Not just generate API.
02:07:47 <lispy|web> ManateeLazyCat: Scion?
02:07:55 <ManateeLazyCat> mmorrow: I think ghci can do it, perhaps need some GHC-API do it.
02:08:25 <ManateeLazyCat> lispy|web: Yes, i know it, but i try it in Emacs, it just completion some package or module name.
02:08:35 <ManateeLazyCat> lispy|web: Not completion for code in typing.
02:10:02 * ManateeLazyCat Looks i need implement this module self.
02:10:10 <Axman6> so, today, i finally learnt what P and NP actually mean
02:10:58 <ManateeLazyCat> lispy|web: AFAIK, best code completion for Haskell, is my elisp code with Auto-Completion in Emacs.
02:11:22 <ManateeLazyCat> lispy|web: Never try Eclipse or other IDE.
02:11:35 <ManateeLazyCat> lispy|web: But it's have bug,
02:11:39 <lispy|web> ManateeLazyCat: I've never really enjoyed the time I spent with Eclipse.
02:11:55 <ManateeLazyCat> lispy|web: I use it with hoogle, not support regexp search.
02:12:07 <lispy|web> It seemed buggy.   Like sometimes you restart it and it fails to load.  The solution is to reinstall.
02:12:22 <ManateeLazyCat> lispy|web: I don't like Eclipse, i prefer Emacs. Emacs is clean and improve REAL efficient.
02:12:49 <ManateeLazyCat> lispy|web: I hate use mouse click everything in Eclipse, i like do everything with keyword.
02:12:59 <ManateeLazyCat> lispy|web: Mouse is really slow when programming.
02:13:25 <dancor> overlapping instances, what's the right way: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=4127#a4127
02:15:36 <ManateeLazyCat> mmorrow: BTW, my friend -- Cjacker Huang have finish WebKits Haskell binding, and he have send patch to Axel, then i can run Web-browser in my project. That's really really coool.
02:19:58 <ManateeLazyCat> mmorrow: I really confusion TH, poor document, or my stupid, i will ask you question about TH in the feature, now i need develop my project. Bye.
02:20:01 <lpsmith> ManateeLazyCat:   you should write a blog,  including tips about how to best configure a haskell development environment
02:20:24 <Axman6> > '\' == '\'
02:20:24 <lambdabot>   <no location info>:
02:20:24 <lambdabot>      lexical error in string/character literal at chara...
02:21:55 <ManateeLazyCat> lpsmith: Wait my project.... :) I think i will release it 2009-12 , then i will detail document.....
02:22:05 <ManateeLazyCat> lpsmith: Now i still use Emacs.
02:33:09 <darren^> can i hope to really make small practical programs  after learning some Haskell ?
02:33:27 <darren^> or is it really tough
02:33:32 <mmaruseacph2> darren^, you can
02:33:38 <darren^> thx
02:33:52 <mmaruseacph2> but you have to exercise
02:33:59 <mmaruseacph2> and don't give up at the first failure
02:34:56 <darren^> someone told me.. that i can't have any input in the middlle of teh program.. or i guess they mean... that i should have thought off of made allowance for all inputs in the beginning of my code itself.. is that true ?
02:35:08 <Axman6> darren^: you don'tt have to limit yourself to small programs though ;)
02:35:31 <c_wraith> I wrote a small completely unpractical yet did-as-specified program earlier today.  Mostly because a friend of my kept typing "wtfd", leading me to joke it should be a server.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9808#a9809
02:35:33 <Axman6> darren^: not necessarilly. but you have to be in the IO monad to do any IO
02:35:52 <darren^> Axman6, yes.. i meant.. that if i start learning it i surely wanna use it practically.. not just learn it from an educational standpoint or something
02:36:03 <darren^> Axman6, okay
02:36:14 <Axman6> darren^: if you
02:36:30 <vaibhav> any php guiders
02:36:33 <sohum> I just realised one of the reasons I love Haskell
02:36:37 <sohum> I knew I needed /something/ to plug in to different bits of functionality to get what I wanted, but I couldn't quite wrap my head around what was going on
02:36:39 <Axman6> if you're just beginning with haskell, i'd advise you stay away from using IO, at least for a few days. just use GHCi
02:36:45 <sohum> so I sat down with the definitions of the functions in question, and wrote an identity for the thing I wanted
02:36:51 <sohum> called it x
02:36:56 <sohum> and /solved for x/
02:37:05 <Axman6> heh
02:37:07 <vaibhav> i wanna generate report
02:37:23 <Axman6> vaibhav: does that have anything to do with haskell?
02:37:24 <vaibhav> fetching the datat from BD
02:37:41 <vaibhav> i want some programmers to help me coding
02:37:49 <Axman6> what's wrong with #php?
02:38:05 <vaibhav> nothing am not geting the proper output
02:38:15 <darren^> Axman6, GHC is the compiler , right ?.. what's ghci ?
02:38:37 <Axman6> ghci is an interpreter, where you can write haskell code, and see the result
02:38:41 <Axman6> a lot like lambdabot:
02:38:48 <sohum> darren^: ghc-interactive
02:38:48 <darren^> ok, got it
02:38:51 <Axman6> > map (^2) [1..10]
02:38:51 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
02:38:59 <vaibhav> helllo
02:39:05 <darren^> ;)
02:39:19 <darren^> sweet
02:39:33 <c_wraith> > map (join (*)) [1..10]
02:39:34 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
02:39:34 <darren^> map
02:39:38 <darren^> oops
02:39:42 <sohum> I wish ghci would get some of the functionality of lambdabot
02:39:44 <Axman6> darren^: you can write your code in a file, then run ghci file.hs, and play with your functions
02:39:54 <sohum> I wonder what the show inst for fns looks like
02:39:55 <Axman6> sohum: it can
02:39:56 <sohum> > map
02:39:57 <lambdabot>   {{()->()}->{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}}
02:40:03 <darren^> map (^2) [2 16]
02:40:17 <darren^> map (^2) [2..16]
02:40:23 <sohum> > map :: (Int -> Int) -> [Int] -> [Int]
02:40:24 <lambdabot>   {-3->0;-2->-1;-1->-2;0->-3;1->-2;2->-1;3->0}->
02:40:24 <lambdabot>    []->
02:40:24 <lambdabot>      []
02:40:24 <lambdabot>    [-2]->
02:40:24 <lambdabot>   ...
02:40:27 <sohum> darren^: prefix with >
02:40:33 <Axman6> sohum: i can't remember the name, but it had ACID in the name...
02:40:39 <Axman6> ghci on acid or something
02:40:43 <darren^> > map (^2) [2..16]
02:40:44 <sohum> cool
02:40:44 <lambdabot>   [4,9,16,25,36,49,64,81,100,121,144,169,196,225,256]
02:41:34 <doserj> > map (^2) [a,b,c,d]
02:41:34 <lambdabot>   [a * a,b * b,c * c,d * d]
02:42:16 <Axman6> > map (^4) [a,b,c,d]
02:42:17 <lambdabot>   [a * a * (a * a),b * b * (b * b),c * c * (c * c),d * d * (d * d)]
02:42:23 <Exteris> > map (*3) [1..9]
02:42:24 <lambdabot>   [3,6,9,12,15,18,21,24,27]
02:42:34 <sohum> that's the weird variable hackery it does for foldl and such, I think
02:42:37 <Axman6> > iterate (^3) a
02:42:37 <lambdabot>   [a,a * a * a,a * a * a * (a * a * a) * (a * a * a),a * a * a * (a * a * a) ...
02:42:55 <sohum> foldl1 f [1..5]
02:42:57 <sohum> > foldl1 f [1..5]
02:42:57 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:42:57 <lambdabot>    `SimpleReflect.FromExpr ...
02:43:05 <sohum> boo
02:43:16 <Axman6> > foldl1 f [a,b,c,d]
02:43:17 <lambdabot>   f (f (f a b) c) d
02:43:24 <sohum> oh, duh
02:43:40 <lispy|web> sohum: yes, Ic an confirm, you want GHCI on Acid, goa
02:43:41 <sohum> > foldr1 f [a,b,c,d]
02:43:41 <Axman6> hmm, SimplReflect should have a num instance...
02:43:41 <lambdabot>   f a (f b (f c d))
02:43:48 <Axman6> well, it must have. huh
02:43:50 <sohum> It does
02:43:53 <doserj> > foldl1 f [1..5]::Expr
02:43:54 <lambdabot>   f (f (f (f 1 2) 3) 4) 5
02:43:57 <lispy|web> sohum: http://chrisdone.com/blog/html/2008-08-01-ghci-on-acid.html
02:44:06 <sohum> I suppose the f and a type hackery doesn't play well with others
02:44:15 <sohum> lispy|web: ooh shiny
02:44:32 <c_wraith> > join (*)
02:44:33 <lambdabot>   {-3->9;-2->4;-1->1;0->0;1->1;2->4;3->9}
02:45:10 <c_wraith> @src (->) (>>=)
02:45:10 <lambdabot> f >>= k = \ r -> k (f r) r
02:46:19 <c_wraith> > (*) >>= (+)
02:46:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
02:46:44 <Axman6> > (*a) >>= (+)
02:46:44 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
02:46:44 <lambdabot>    arising from...
02:46:50 <Axman6> > (*a) >>= (+) 7
02:46:51 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> b'
02:46:51 <lambdabot>         against infe...
02:46:53 <Axman6> > (*a) >>= (+) b
02:46:57 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> b'
02:46:59 <doserj> > (*) >=> (+)
02:47:01 <lambdabot>         against infe...
02:47:03 <lambdabot>   -3->
02:47:05 <lambdabot>    {-3->6;-2->4;-1->2;0->0;1->-2;2->-4;3->-6}
02:47:07 <lambdabot>  -2->
02:47:09 <lambdabot>    {-3->3;-2->2;-1...
02:49:54 <c_wraith> > (+1) >>= (*)
02:49:55 <lambdabot>   {-3->6;-2->2;-1->0;0->0;1->2;2->6;3->12}
02:50:48 <hackagebot> usb-id-database 0.3 - A database of USB identifiers (RoelVanDijk)
02:51:08 <shaniaki> I have a function which should run in IO monad. It manipulates elements of an input list (say simply yi=xi*2) and outputs a list: [a]->IO ([b]). I need to wrap this function with unsafePerformIO and connect it to other functions in the pure world. The problem is that I want the output elements to be produced when each element is consumed not after reading whole list. Any idea how this could be done?
02:51:47 <lispy|web> shaniaki: unsafeInterleaveIO
02:52:19 <lispy|web> :t unsafePerformIO . unsafeInterleaveIO
02:52:20 <lambdabot> Not in scope: `unsafePerformIO'
02:52:20 <lambdabot> Not in scope: `unsafeInterleaveIO'
02:52:39 * lispy|web >>= bed
02:53:34 <Cale> It's not as simple as just applying unsafeInterleaveIO to the whole thing, you'd have to make it part of the recursion.
02:54:35 <shaniaki>  lispy|web, tnx, I will check it but when I use my function in ghci like "myWrap [1..]" I still dont see anything. That is why I thought the problem may be related to the way you write the code
02:55:14 <Cale> There's nothing you can do to a pre-existing function of type [a] -> IO [b] after the fact to magically make it lazy. You'll have to modify its definition.
02:57:05 <shaniaki> Cale, thats what I thought. Do you have any further suggestions? I found this: http://users.aber.ac.uk/afc/stricthaskell.html  (hGetContents, hClose, readFile) but didnt manage :(
02:57:19 <Cale> shaniaki: Uh, you want to make it stricter?
02:57:49 <Cale> I thought you were trying to make it lazier.
02:58:08 <Cale> shaniaki: Can you tell me more about what the actual function does?
02:58:22 <Cale> If it's just multiplying by 2, then it shouldn't even be in the IO monad to begin with.
02:58:40 <Cale> But something like  foo xs = return (map (*2) xs)  would be sufficiently lazy.
02:59:22 <shaniaki> Cale: well... say simply it invokes a function from another library (say C library) and applies it on the elements of a list
02:59:26 <Cale> (return x doesn't evaluate x when it's executed)
02:59:35 <Cale> Ah, that's easy then.
03:00:08 <Cale> Because you can just use unsafePerformIO on that function and use map to apply it to the elements of the list.
03:01:05 <Cale> (or unsafeInterleaveIO and mapM if you prefer to keep things in IO)
03:03:06 <shaniaki> I missed unsafeInterleaveIO (strange!) I will check it. But if using mapM is not possible, is there any rule like making it recursive to be able to run it in this way?
03:03:18 <Cale> If you know for sure that the C function is really referentially transparent, it doesn't hurt to apply unsafePerformIO to it, or even foreign import it as pure.
03:03:38 <Cale> (just leave the IO off of the result type in the foreign import)
03:04:53 <Cale> C doesn't provide any facilities for lazy evaluation, so there's nothing you could do on the C side of things to make the function lazy.
03:05:45 <shaniaki> No, I mean the way I write my wrapper... the [a] -> IO ([b]) function.
03:07:48 <Cale> Well, you could write something like mapM but which had an unsafeInterleaveIO that wrapped the recursive call, so that the computations responsible for the rest of the list won't happen until the tail is demanded.
03:09:47 <Cale> mapMI f (x:xs) = unsafeInterleaveIO $ do v <- f x; vs <- mapMI f xs; return (v:vs)
03:10:32 <mmaruseacph2> > :t unsafePerformIO
03:10:33 <lambdabot>   <no location info>: parse error on input `:'
03:10:50 <Cale> Oh, there might be an issue with that.
03:11:00 <Cale> hmm...
03:11:08 <Cale> nah, I think it'll be okay
03:11:27 <Cale> mmaruseacph2: unsafePerformIO :: IO a -> a
03:11:57 <mmaruseacph2> thanks :)
03:12:01 <mmaruseacph2> i got it in the ghci
03:12:11 <mmaruseacph2> i don't know how to call lambdabot :(
03:12:20 <lispy|web> ?hoogle unsafePerformIO
03:12:20 <lambdabot> Foreign unsafePerformIO :: IO a -> a
03:12:20 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:12:29 <mmaruseacph2> thanks
03:12:32 <Cale> mmaruseacph2: unsafeInterleaveIO :: IO a -> IO a -- it transforms an IO action into one which finishes immediately, producing a magical result which when evaluated will cause the IO to really occur.
03:13:03 <mmaruseacph2> eh, i needed a function of type IO a -> a
03:13:10 <Cale> mmaruseacph2: For what?
03:13:21 <mmaruseacph2> selecting a button from a gtk interface
03:13:31 <Cale> mmaruseacph2: You should normally treat uses of unsafePerformIO with about the same gravity as modifying your compiler.
03:13:47 <Cale> You can do it, but if you're doing something normal, it's not the answer.
03:14:04 <mmaruseacph2> I know, it's only a temporarily solution
03:15:03 <Cale> Another rule is that you should only use unsafePerformIO if you don't care how many times the IO action you apply it to is executed, or when.
03:15:28 <Cale> (and it should produce the same result every time, just to be safe)
03:15:34 <pao> @paste
03:15:34 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:16:28 <Cale> If there's any chance that the IO action is going to produce different results each time, you probably don't want unsafePerformIO.
03:16:58 <mmaruseacph2> the second rule is passed successfully
03:17:01 <Cale> mmaruseacph2: selecting a button from a gtk interface seems like it should be easy without that though.
03:17:17 <sohum> launch one missile - /one/ missile, dammit! nooooooo!
03:17:26 <pao> hi all!
03:17:27 <pao> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4133#a4133
03:17:35 <pao> two little question on the paste...
03:17:36 <mmaruseacph2> I'll have the writer of that code rewrite it next week when we will meet again
03:17:57 <pao> 1) is randomRState a reasonable name, how would you have called it?
03:18:17 <Cale> pao: You are reinventing MonadRandom
03:18:21 <pao> 2) am I reinventing the wheel? is there anything like that in some library?
03:18:37 <Cale> http://hackage.haskell.org/package/MonadRandom
03:18:40 <pao> Cale: that was the answer for the second question :-) you cheet :-)
03:19:13 <pao> Cale, thanks
03:19:43 <Cale> randomRState seems an okay name, though a little long for what it is
03:20:05 <Cale> mmaruseacph2: What is it that the code really does?
03:21:21 <pao> Cale, thank you very much... as helpful as usual
03:21:26 <Cale> pao: no problem :)
03:21:58 <mmaruseacph2> it is a graphical clone of the Berkeley espresso program: the user gives a description of the logic problem (algebraic, truth table or Verilog-ish) and the program outputs the same problem minimized according to some rules (user specified if possible) and a diagram of the entire circuit
03:22:24 <Cale> mmaruseacph2: I was talking about the code that you're applying unsafePerformIO to specifically.
03:22:35 <mmaruseacph2> I have a team of three people working on this, all of us being students, knowing haskell for a little over than 7 months
03:22:52 <mmaruseacph2> ah, there are a few buttons to select what form the input is
03:23:06 <mmaruseacph2> and the code needs to select one of them and call another function afterwards
03:23:14 <Cale> (I'm a little surprised that you would ever want to do anything regarding selecting a button from the middle of some pure code.
03:23:40 <Cale> It sounds like you almost certainly do not want unsafePerformIO here.
03:23:47 <Cale> Because you care about the order in which things happen.
03:24:11 <mmaruseacph2> well, the problem is that when we started none of us knew something about monads except that the IO is done via them
03:24:24 <Cale> and unsafePerformIO foo might just execute foo right at the beginning of your program, for all the compiler cares.
03:24:24 <mmaruseacph2> and it's kind of hard to rewrite the code right now
03:24:43 <mmaruseacph2> ouch, in this case we need to change it quick
03:24:54 <Cale> (it won't, but it could)
03:25:27 <Cale> Typically, it will execute foo when the resulting value is pattern matched against.
03:25:37 <Cale> Inlining makes this hard to reason about though.
03:26:04 <Cale> Turning on and off optimisations can change the behaviour of it.
03:26:36 <mmaruseacph2> ok, thanks for the info, we'll change the code then
03:26:43 <Cale> Why is it that in the middle of computing something pure, you need to select that button?
03:26:54 <Cale> Aren't those two separate?
03:26:59 <mmaruseacph2> poor organizing :(
03:27:19 <Cale> Surely the pure function doesn't need to select the button in order to be able to compute its result.
03:27:32 <Cale> So why can't it be separate?
03:27:37 <mmaruseacph2> yeah, that can be changed easily
03:28:25 <Cale> If the important thing is *which* button to select, then you can just have it return an appropriate IO action to select the button as part of its result, and run that action in sequence with other actions later.
03:29:04 <mmaruseacph2> yup, this seems to work, thanks
03:32:58 <pao> Cale: MonadRandom rulez
03:34:54 <Cale> pao: thanks!
03:36:17 <ct529> hi everybody!
03:36:47 <Axman6> o/ ct529
03:36:53 <ct529> who are the the ihg partners? there are only two listed on the website
03:40:28 <markspezzano> hello
03:40:46 <Axman6> 'lo markspezzano
03:41:02 <markspezzano> I'm currently going thru Bird's books Introduction to Functional programming using Haskell
03:41:14 <markspezzano> I'm finding that the book is full of proofs
03:42:03 <ggreg_> hi there
03:42:06 <markspezzano> are they acutally worth doing? I've done some of them and got the right answer but it seems that they're aimed more at mathematicians
03:42:35 * Axman6 dislikes proofs
03:42:42 <markspezzano> I can't for the life of me figure out how to do some ... all I want to do is WRITE CODE
03:43:46 <Axman6> markspezzano: in that case, skip them
03:43:53 <markspezzano> I'm forcing myself to do the proofs out of a sense of duty and completion rather than enjoyment...
03:43:56 <Axman6> also, you might try another tutorial, like lyah
03:43:56 <markspezzano> you think so?
03:44:04 <Axman6> @where lyah
03:44:04 <lambdabot> www.learnyouahaskell.com
03:44:18 <markspezzano> cool thanks.
03:44:43 <sohum> @hoogle a -> (b, IO c)
03:44:43 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
03:44:43 <lambdabot> Data.Traversable mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
03:44:43 <lambdabot> Data.Generics.Twins gmapAccumM :: (Data d, Monad m) => (a -> e -> (a, m e)) -> a -> d -> (a, m d)
03:44:55 <markspezzano> I just hope I won't lose anything by skipping so many proofs. Do really need to be able to do them to write quality haskell code?
03:45:06 <sohum> proofs are fun
03:45:08 * sohum thwacks Axman6 
03:45:20 <sohum> but not necessary to initial learning, no
03:45:22 <Axman6> i can't do them. they just don't make any sense to me
03:45:42 <markspezzano> They are fun...but only if you get the right answer. Otherwise they're just plain frustrating.
03:46:00 <Axman6> well, actually, i like inductive proofs
03:46:05 <Axman6> and using haskell for them
03:46:10 <sohum> a proof is the process of showing /how/ to get the right answer
03:46:38 <ivanm> markspezzano: don't forget, that book is aimed at CS students rather than code monkeys...
03:46:54 <markspezzano> I've got a bachelors degree
03:47:07 <markspezzano> They're still hard :(
03:47:35 <lispy|web> do the regexp libs have a way to optimize your regular expressions?
03:47:49 <ivanm> no idea, but I doubt it
03:48:01 <ivanm> lispy|web: methinks the pcre one is probably one of the faster ones
03:48:11 <ivanm> since it uses a C lib and all...
03:48:12 <lispy|web> I wonder if it's faster to map a big list of tiny regexp or to make one big regexp
03:48:13 <lilac> markspezzano: there are a few places where you should either have a proof or a good intuition of why a result holds, such as when defining Monad instances
03:48:26 <lispy|web> ivanm: not sure which one we actulaly use
03:48:31 <lilac> fortunately, defining monad instances can usually be avoided by using the mtl
03:48:52 <lispy|web> regex-compat
03:49:15 <sohum> the mtl gets all unwieldy though. Don't quite grok transformers, but that's a common complaint I've seen
03:49:27 <lilac> there are places where proofs are /necessary/ such as when violating the type system or referential transparency, but those don't apply very often
03:49:30 <benmachine> :t makeRegex
03:49:31 <lambdabot> forall compOpt execOpt source regex. (RegexMaker regex compOpt execOpt source) => source -> regex
03:49:56 <lilac> ... unless your first name is Simon
03:50:00 <benmachine> I'd be surprised if that didn't fastise them somehow
03:50:01 <lispy|web> ?hoogle mkRegex
03:50:01 <lambdabot> Text.Regex mkRegex :: String -> Regex
03:50:01 <lambdabot> Text.Regex mkRegexWithOpts :: String -> Bool -> Bool -> Regex
03:50:18 * lilac ponders whether unsafePerformIO would be better as simonSaysPerformIO
03:50:49 <Axman6> @remember lilac ponders whether unsafePerformIO would be better as simonSaysPerformIO
03:50:49 <lambdabot> It is stored.
03:53:25 <ivanm> heh
03:57:18 <lispy|web> interesting.  Gluing them together into one big regex seems to make the run-time worsen
03:57:51 <ivanm> :o
03:57:56 <lispy|web> ?hoogle makeRegex
03:57:56 <lambdabot> Text.Regex.Base.RegexLike makeRegex :: RegexMaker regex compOpt execOpt source => source -> regex
03:57:56 <lambdabot> Text.Regex.Base.RegexLike makeRegexM :: (RegexMaker regex compOpt execOpt source, Monad m) => source -> m regex
03:57:56 <lambdabot> Text.Regex.Base.RegexLike makeRegexOpts :: RegexMaker regex compOpt execOpt source => compOpt -> execOpt -> source -> regex
04:01:08 <hackagebot> curry-base 0.2.4 - Functions for manipulating Curry programs (HolgerSiegel)
04:01:16 <lilac> lispy|web: the runtime of makeRegex or the runtime of matching the regex?
04:02:08 <hackagebot> curry-frontend 0.2.4 - Compile the functional logic language Curry to several intermediate formats (HolgerSiegel)
04:02:29 <lispy|web> lilac: the run-time of using the regex to match stuff
04:03:32 <lilac> weird. does the first regexp in the list usually match? :)
04:05:41 <lispy|web> I think typically none of them match
04:05:47 <lispy|web> at least in my test case
04:06:10 <lispy|web> I'm tring to record all the files of the linux repo in one patch in darcs and measuring the performance of changing various things
04:06:29 <lispy|web> these regex are to determine if the file is a 'binary' file like a jpg
04:06:37 <lispy|web> and I don't think the linux source has antyhing like that
04:10:20 <ehird> So, is the best non-console GHCi really running it in Emacs?
04:10:54 <ivanm> ehird: depends on what you mean
04:11:02 <ivanm> in windows, there's winhaskell IIRC
04:11:36 <ehird> WinHugs is the most popular example. Something like that, but s/Hugs/GHCi/ and s/Windows/X11/ is what I'm looking for.
04:12:55 <ivanm> no idea
04:13:03 <ivanm> there's at least limited eclipse support
04:13:13 <ehird> Ew.
04:13:17 <opqdonut> á
04:13:21 <opqdonut> oops
04:13:22 <ivanm> and there's vim support for haskell, but I'm not sure if that includes a ghci session
04:13:25 <ehird> I'd take Emacs over Eclipse any day...
04:13:25 <Twey> Doesn't Leksah have something built-in?
04:13:32 <ivanm> ehird: what is wrong with running ghci in a terminal?
04:13:34 <ehird> Twey: I asked that before; answer appeared to be no.
04:13:40 <BleSS> does haskell is shared memory?
04:13:49 <ivanm> BleSS: hmmm?
04:13:55 <Twey> Huh.
04:13:57 <ehird> ivanm: Nothing per se, it'd just be nice to have something a little smarter. Also, copy/paste with terminals in X is a pain.
04:14:02 <ivanm> do you mean "does Haskell use shared memory?" ?
04:14:04 <ehird> Twey: Or rather, "not really".
04:14:09 <ivanm> and if so, what do you mean by "shared memory"
04:14:11 <BleSS> ivanm: yes
04:14:12 <ivanm> ehird: true
04:14:23 <Twey> ehird: You'd think that'd be top-priority for an IDE-to-be.
04:14:29 <ivanm> but for the most part, apart from integration with editing, terminal ghci > emacs ghci
04:14:41 <ehird> Twey: It's an IDE if we pile a lot of features onto our editor!
04:14:46 <ivanm> tab completion, history, no limit on line length (OK, there probably is one due to memory issues, etc.)
04:14:48 <Twey> Yeah, but I can't make GHCi use my shell keybindings.
04:14:54 <Twey> ehird: Oh, of course.  :Ã¾
04:14:59 <ehird> Maybe I should set up an IRC development environment.
04:15:06 <ehird> Just use lambdabot without a prefix.
04:15:07 <BleSS> it looks that the model shared nothing (used in erlang) is better to scalability
04:15:09 <Twey> erc?  :Ã¾
04:15:10 <Twey> Haha.
04:15:13 <ehird> With a bunch of file-editing and shell commands.
04:15:38 <ehird> ivanm: also, inferior-ghci has history, no?
04:16:00 <ivanm> ehird: to a limited extent
04:16:06 <ivanm> it uses emacs comint history
04:16:12 <ivanm> but it's per-session AFAICT
04:16:25 <ivanm> whereas ghci in a terminal has saved history (like bash does)
04:16:32 <ehird> I only use inter-session history when I break something and restart my REPL. :)
04:16:36 <ivanm> BleSS: oh, you mean for concurrency?
04:16:40 <ehird> "Let's see if that happens again."
04:16:59 <altmattr> BleSS:  shared nothing is better for scalability in all languages
04:17:33 <BleSS> ivanm: well, the shared memory - locking, not scalable
04:17:40 <sexindacity893> hello
04:17:49 <sexindacity893> room
04:18:01 <sexindacity893> hackers want to say hi
04:18:04 <ivanm> BleSS: are you talking about concurrency? it sounds like you are, but I'm wanting to be sure
04:18:07 <altmattr> BleSS: in that case, the answer is no - haskell does not use (or encourage the use of) shared state requiring locks, etc
04:18:16 <ivanm> altmattr: not quite true...
04:18:20 <ivanm> you can use MVars, etc.
04:18:30 <ivanm> but nowadays the preferred concurrency approach is STM
04:18:41 <altmattr> ivanm: indeed
04:18:44 <sexindacity893> please newbie in the house
04:18:44 <ivanm> which does use shared memory AFAICT, but it's lockless
04:18:48 <Botje> sexindacity893: hello.
04:18:55 <sexindacity893> botje
04:18:56 <sexindacity893> hi
04:18:57 <ivanm> sexindacity893: don't ask to ask ;-)
04:19:09 <altmattr> ivanm: thus my strange turn of phrase :)
04:19:23 <ivanm> sexindacity893: if we bothered to say hello to everyone that came into the channel, we'd never get anything done ;-)
04:19:32 <ivanm> altmattr: heh, fair enough
04:19:51 <sexindacity893> kk
04:19:54 <int-e> @users
04:19:55 <lambdabot> Unknown command, try @list
04:19:55 <BleSS> ivanm: I know that haskell is well for concurrency and has several models but I'm not sure if its shared memory is well suited for scalability
04:20:08 <ivanm> BleSS: depends on how you define scalability
04:20:10 <altmattr> I think the short answer to BleSS is "haskell does concurrency better than most other languages and you are very unlikely to have to deal with shared state in the way you are thinking"
04:20:17 <ivanm> BleSS: erlang's is better for distributed computing
04:20:40 <ivanm> BleSS: but STM is more akin to message passing than traditional shared memory
04:21:02 <altmattr> ivanm: really?  I figured STM and erlangs messages are analogous in a lot of ways
04:21:27 <ivanm> altmattr: reasonably so, except STM is limited to the one machine ;-)
04:21:33 <altmattr> but this is certainly not an area I think about often
04:21:35 <Twey> Really?  I figured Chans are closer to Erlang's message-passing than TChans.
04:21:37 <altmattr> ivanm: of course
04:21:57 <ivanm> then again, I've never done any Erlang (just read some stuff), and I only did a bit with STM
04:22:03 <ivanm> so Twey could possibly be right
04:22:12 <altmattr> ivanm: lets go with that
04:22:36 <ivanm> heh
04:23:13 <int-e> Note that Chans lack the interaction with the scheduler (penalizing writers to full channels) that Erlang has.
04:24:45 <BleSS> ivanm: so generally, erlang also would be better for internet services? which could be distributed if were needed more servers to manage more users
04:25:06 <ivanm> BleSS: atm, probably yes
04:25:12 <ivanm> (if you want the distributed nature)
04:25:30 <ivanm> I would argue that Haskell is probably better in general performance though (AFAIK, anyway)
04:25:47 <ivanm> but erlang has distributed + soft restarts, which might be what you want
04:25:57 <ehird> BleSS: note that erlang the language is lame.
04:26:13 <int-e> that's ok if it gets the job done ;)
04:26:14 <ivanm> ehird: :o
04:26:24 <ivanm> ehird: why?
04:26:48 <ivanm> (I'm not a big fan of erlang's syntax, but that's a rather weird thing to say... especially since we have to get rid of Java first :p )
04:26:55 <BleSS> ehird: I heve seen the sintaxis and it's awfull but it looks that it's very fast to learning erlang
04:26:59 <altmattr> BleSS: and if you are talking about internet services, are you writing all the clients that talk to the service?  If not you are forced through an abstraction layer that makes the whole discussion completely different
04:27:00 <ehird> ivanm: well the syntax is stolen from prolog which doesn't work if your language isn't like prolog for one. secondly the [97,98] stringifying as 'ab' stuff is just *freaky* and a pain
04:27:08 <ehird> ivanm: thirdly it's Yet Another Duck Typed Language :P
04:27:14 <ivanm> ehird: yeah
04:27:14 <vegai> is there a lazy getDirectoryContents?
04:27:21 <ivanm> but is the _language_ lame or the _syntax_?
04:27:32 <vegai> oh, wait. I'm running this on ghci. Perhaps it's already lazy
04:27:46 <ehird> ivanm: the latter two weren't syntax
04:27:51 <ehird> only the first complaint was syntax
04:27:55 <vegai> no, it's definitely strict
04:28:03 <vegai> so, is there a lazy getDirectoryContents?
04:28:23 <ivanm> I would say the stringy stuff is syntax
04:28:34 <ehird> no, it's a design decision
04:28:52 <ivanm> *shrug* probably also a design decision for what they originally wanted
04:28:58 <ehird> they chose to represent strings as lists of numbers in a totally duck typed language, and so bam, you increment a number, now it shows as a freaky string
04:29:01 <ehird> that's not really syntax
04:29:13 <ivanm> if you could write Haskell (or something like Haskell) for the erlang VM, _that_ would be cool
04:29:21 <Botje> shrug. sexindacity883 wanted to learn about credit card hacking.
04:29:29 <ivanm> Botje: heh
04:29:47 <ivanm> I figured something like that from this: <sexindacity893> hackers want to say hi
04:29:53 <ehird> ivanm: ditto
04:29:59 <Botje> he was "pointed" to this channel
04:30:04 <ehird> wat
04:30:06 <ivanm> Botje: by?
04:30:10 <Botje> i guess we can expect a creditcard package on hackage soon :)
04:30:11 <ivanm> people who don't like Haskell?
04:30:13 <Botje> didn't say
04:30:25 <Botje> i think he simply picked out the largest channel on freenode and asked
04:31:00 <altmattr> Botje: what are you talking about?
04:31:05 <ivanm> Botje: I thought we were only 4th largest...
04:31:06 * altmattr confused
04:31:14 <ehird> ivanm: slightly further down
04:31:21 <Botje> 13:18 < sexindacity893> hackers want to say hi
04:31:23 <Botje> that guy
04:31:30 <ehird> #8 atm
04:31:35 <bastl> what do you prefer: 'map (lookupF record) (lookupList record)' or 'map $ lookupF record $ lookupList record' ( and why? )
04:31:51 <Botje> bastl: those don't do the same.
04:31:56 <bastl> ouch :-)
04:32:29 <Botje> map (lookupF record) $ lookupList record, i guess
04:33:01 <bastl> anyhow: mixing () and $ looks strange ...
04:33:10 <hamishmack> ehird: Leksah has ghci support
04:33:54 <ehird> hamishmack: is it any good?
04:33:55 <ivanm> bastl: I do it sometimes when I'm doing two things at once, though more of a "foo (bar 1) $ bar 2" approach
04:34:34 <hamishmack> ehird: I like to think it is ok
04:35:03 <hamishmack> If you get the leksah-head branch it has a few minor improvements
04:35:39 <hamishmack> ctrl+Enter in the editor will evaluate the current selection or the current line if nothing is selected
04:36:09 <hamishmack> There is a scratch pad where you can put stuff to try out
04:36:56 <ivanm> hamishmack: "scratch pad"?
04:37:12 <bastl> hm, i tend to combine things to (lookup bar), especially when it came from 'let bar = MakeBar {lookup=...}'
04:37:20 <hamishmack> Just a editor window that you can try things out in
04:37:32 <hamishmack> since there is no traditional command line
04:38:00 <hamishmack> but if you type something in any edit window and press Ctrl+Enter it runs it in ghci
04:38:05 <bastl> perhaps an OO-habit coming from thinking "bar.lookup"
04:38:34 <BleSS> another thing; I'm supposed that the nature of distributed computing in erlang is beacuse it has been used to build so many DBMS as couchdb, scalaris, riack, ringo, dynomite. Because I've not seen an only DBMS in haskell
04:41:04 <ehird> hamishmack: can you run the usual ghci commands or are they all included in the gui?
04:41:25 <ivanm> BleSS: because no-one has bothered to ;-)
04:41:40 <hamishmack> Yes anything you select is sent straight to ghci
04:42:04 <hamishmack> so you can type your commands into the scratch pad and send them from there
04:43:15 <hamishmack> we wrap multi line selections with :{} though
04:43:44 <hamishmack> so you can only send one command at a time
04:44:09 <ivanm> how does the scratch pad differ from actually writing your commands in the file?
04:44:19 <ivanm> or is it equivalent to emacs' scratchpad for elisp code?
04:45:04 <hamishmack> It only differs in that leksah does not treat it as a file in your project
04:45:22 <hamishmack> it won't send :module before your commands either
04:45:40 <ivanm> *nod*
04:46:37 <hamishmack> We still have more improvements to make (starting stopping ghci is a bit unreliable)
04:46:55 <hamishmack> There is a toggle button on the toolbar
04:47:28 <hamishmack> but it does not turn off when the debugger stops unexpectedly
04:48:39 <ivanm> probably my biggest problem with switching to a full Haskell IDE like leksah is that with emacs, I can work on more than just Haskell code, and that I can switch back and forth between what I'm doing
04:49:33 <hamishmack> I have made a start on integrating Yi
04:49:49 <hamishmack> which may help emacs users make the transition
04:50:03 <hamishmack> but it is going to be a lot of work
04:50:25 <hamishmack> and I will not have any time to spend on it for a couple of weeks
04:51:28 <hamishmack> But the result is that the TextEditor interface in Leksah is now all in one module
04:52:01 <hamishmack> it may be possible for someone to have it talk to emacs somehow
04:53:28 <vegai> argh!
04:53:40 <vegai> I have a thing that writes ByteString content into an sqlite3 db just fine
04:53:46 <vegai> I try to add a gzip phase before writing
04:53:49 <vegai> and
04:53:55 <vegai>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
04:53:55 <vegai>            against inferred type `BS.ByteString'
04:54:10 <vegai> the type of compress is just compress :: ByteString -> ByteString
04:54:20 <vegai> where does this Data.ByteString.Lazy.Internal.ByteString come from...
04:56:03 <vegai> http://paste.factorcode.org/paste?id=925   if you care
04:57:08 <vegai> oh, wait
04:57:24 <vegai> it's a pure function :-|
04:58:02 <vegai> fixed that, and
04:58:05 <vegai> XmlToSqlite.hs:21:71:
04:58:05 <vegai>     Couldn't match expected type `Data.ByteString.Internal.ByteString'
04:58:05 <vegai>            against inferred type `BS.ByteString'
04:58:09 <vegai> :-S
04:58:34 <Botje> vegai: apparently compress is defined for lazy bytestrings, whereas you're using strict bytestrings.
04:59:02 <vegai> Actually, now it's the SqlByteString constructor that doesn't accept these bytestrings
04:59:19 <vegai> I mean after noticing what you just said and fixing that, too
04:59:42 <vegai> I'm doing this in a hurry now, as you might see. Since weekend is close by
04:59:54 <Botje> vegai: the Codec.Compression.GZip page lists a possible workaround
04:59:59 <Botje> (search for strict)
05:00:14 <ehird> hamishmack: so is there not a ghci-in-a-window thing, just the ctrlenter?
05:00:46 <vegai> ah, thank you, Botje
05:00:50 <hamishmack> Output is shown in the Log window
05:01:59 <hamishmack> It has windows for breakpoints and variables
05:02:01 <vegai> yes, works now. Whew.
05:02:07 <Botje> yay!
05:02:19 <hamishmack> the trace window has a few bugs still
05:04:04 <hamishmack> Quite a few things are accessible through the context menu
05:07:34 <sonnexw> > 1
05:07:34 <lambdabot>   1
05:08:19 <sonnexw> > pl \f g a b -> f a (g b)
05:08:20 <lambdabot>   <no location info>: parse error on input `\'
05:08:38 <Botje> @pl \f g a b -> f a (g b)
05:08:38 <lambdabot> flip . ((.) .)
05:08:46 <sonnexw> @pl \f g a b -> f a (g b)
05:08:46 <lambdabot> flip . ((.) .)
05:08:49 <sonnexw> ty
05:10:38 <sonnexw> speaking of flip . ((.) .)
05:10:49 <sonnexw> type sig being: (a -> b' -> c) -> (b -> b') -> a -> b -> c
05:10:55 <sonnexw> is there anything like this already?
05:11:01 <sonnexw> seems like a useful pointfree combinator
05:11:29 <trzkril> hm, seems a bit like s
05:11:33 <trzkril> from pca
05:13:32 <sonnexw> hah lol yeh its exactly the same
05:14:17 <sonnexw> scratch that
05:14:21 <sonnexw> not quite the same
05:15:15 <Twey> What is âpcaâ?
05:15:27 <trzkril> Twey: partial combinatory algebra, iirc
05:15:42 <Twey> Huh.
05:15:58 <trzkril> Twey: heard of unlambda?
05:16:22 <Twey> Aye
05:18:33 <Jafet> Now an image of combinatory logic in haskell is stuck in my head
05:21:31 <hackagebot> diagrams 0.2.1.1 - An EDSL for creating simple diagrams (BrentYorgey)
05:50:29 <lilac> why did ByteString not come with a typeclass for the stringlike operations?
05:51:56 <gwern> lilac: given how poorly StringLike has done, what differenc would that make?
05:51:56 <ivanm> lilac: just to annoy you
05:51:59 <ivanm> ;-)
05:52:23 <lilac> gwern: StringLike?
05:53:18 <lilac> i found a StringLike class on hackage but it seemed to have a pretty thin interface, missing most of ByteString's operations
05:53:22 <lilac> s/hackage/google/
05:54:28 <ivanm> heh
05:56:02 <lilac> http://community.haskell.org/~ndm/darcs/tagsoup/Text/StringLike.hs <-- that one
05:58:47 <lilac> gwern: did you mean IsString?
05:58:53 <gwern> MAYBE I DID
05:58:58 <jkr> Ahoy
05:59:11 <jkr> How can I make a type class derivable?
05:59:21 <Twey> Data.Derives, I think
05:59:22 <jkr> Is there a keyword or something like that? Can't find anything :(
05:59:27 <Twey> (i.e. TH magic)
05:59:52 <lilac> heh :) to be honest i can see why IsString isn't very common -- for practically all of the human-readable text i use, String seems most appropriate
06:00:24 <lilac> jkr: no, extending the 'deriving (Foo)' mechanism is not possible in Haskell'98
06:00:54 <ivanm> the best you can do is the generalized newtype deriving extension in GHC AFAIK
06:00:56 <lilac> there are various library solutions, and there's a language extension
06:01:01 * lilac looks up the extension
06:01:23 <lilac> http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
06:03:07 <jkr> lilac: That looks pretty much like what I've done (except for the {||} stuff)
06:03:18 <jkr> Do I need a compiler flag to enable that extension?
06:03:27 <lilac> yeah
06:03:29 <jkr> Ah, found it
06:03:30 <jkr> :)
06:08:49 <jkr> Hmm, still getting the error
06:10:12 <jkr> http://pastie.org/630331
06:10:45 <hackagebot> uuagc 0.9.11 - Attribute Grammar System of Universiteit Utrecht (ArieMiddelkoop)
06:11:49 <doserj> jkr: according to the documentation, you don't derive generic classes, you give empty instance declarations.
06:13:02 <jkr> So I have to define the two functions in the type class itself instead of the deriving types?
06:13:30 <lilac> yes
06:13:39 <lilac> then you say 'instance Storable Account' somewhere
06:14:04 <lilac> its like having a default implementation for the class methods, except that the default can depend on how the type is constructed
06:14:09 <jkr> Still getting the same error
06:15:18 <jkr> http://pastie.org/630335
06:17:25 <doserj> jkr: if you are getting the same error as before, that means you still have data Account = ... deriving Storable?
06:18:30 <jkr> No, I'm using "instance Storable Account"
06:18:35 <jkr> Oh, wait
06:18:47 <jkr> My fault :)
06:19:02 <jkr> Now it works, thanks a lot!
06:41:37 <casbon> anyone know what's wrong with this: "concat' = foldl (:) []"
06:42:35 <ivanm> @type foldl (:) []
06:42:35 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
06:42:35 <lambdabot>       Expected type: a
06:42:35 <lambdabot>       Inferred type: [a]
06:42:45 <ivanm> @type foldl
06:42:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:42:50 <ivanm> casbon: check the type
06:42:52 <ivanm> @type (:)
06:42:53 <lambdabot> forall a. a -> [a] -> [a]
06:43:11 <casbon> ah yeah got it
06:43:42 <ivanm> @type foldl (flip (:)) []
06:43:43 <lambdabot> forall b. [b] -> [b]
06:43:57 <ivanm> casbon: but that's not really concatenating anything...
06:43:58 <casbon> thanks
06:44:02 <ivanm> looks like reverse to me...
06:44:04 <ivanm> @src reverse
06:44:04 <lambdabot> reverse = foldl (flip (:)) []
06:44:09 <ivanm> yup, it's reverse
06:44:30 <casbon> this works: " concat' = foldl (++) []"
06:44:37 <benmachine> > foldl (++) [] [[1], [1]]
06:44:37 <lambdabot>   [1,1]
06:44:39 <benmachine> > foldl (++) [] [[1], [2]]
06:44:40 <lambdabot>   [1,2]
06:44:44 <benmachine> > foldr (++) [] [[1], [2]]
06:44:45 <lambdabot>   [1,2]
06:45:18 <ivanm> @src concat
06:45:18 <lambdabot> concat = foldr (++) []
06:46:41 <Cale> > foldr (++) [] [[k,-k] | k <- [1..]]
06:46:42 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
06:46:44 <EvilTerran> > foldl (++) [] ([1]:[1]:undefined)
06:46:45 <lambdabot>   * Exception: Prelude.undefined
06:46:46 <Cale> > foldl (++) [] [[k,-k] | k <- [1..]]
06:46:50 <lambdabot>   mueval-core: Time limit exceeded
06:46:55 <EvilTerran> > foldr (++) [] ([1]:[1]:undefined)
06:46:57 <lambdabot>   [1,1* Exception: Prelude.undefined
06:47:12 <casbon> can't get why foldr better than foldl though
06:47:25 <benmachine> foldr is lazy
06:47:26 <Cale> casbon: because foldr finishes evaluating immediately
06:47:29 <EvilTerran> casbon, do you see the difference between the two answers i got?
06:47:43 <Cale> (or in the two that I got? :)
06:47:52 <Cale> @src foldl
06:47:53 <lambdabot> foldl f z []     = z
06:47:53 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:48:07 <Cale> foldl does nothing but call itself until it reaches the end of the list
06:48:27 <Cale> which in the case of an infinite list means that it will take forever and not give any answer
06:48:55 <EvilTerran> and in the case of a list with a partial tail, it won't take forever, but you still won't get an answer
06:48:55 <Cale> and in the case of a list which is partially defined, like EvilTerran's, it means that it will die before producing any results
06:49:02 <Cale> @src foldr
06:49:02 <lambdabot> foldr f z []     = z
06:49:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:49:13 <casbon> but foldr starts at the end of a list which is not helpfu for an infinite list?
06:49:14 <Cale> By contrast, the first thing that foldr does is calls f, not foldr
06:49:22 <EvilTerran> nontermination and errors are semantically equivalent :)
06:49:48 <Cale> So foldr passes control to the function which is combining the elements of the list *immediately*, before recursing.
06:50:05 <Cale> and it passes f an expression containing foldr as its second parameter
06:50:25 <Cale> only if and when f gets around to using its second parameter will that recursive call be made
06:50:49 <EvilTerran> > foldr const undefined (1:undefined)
06:50:50 <lambdabot>   1
06:51:10 <Cale> and if f produces a constructor without pattern matching on its second parameter, then you get a result without having to evaluate the list any further
06:51:10 <doserj> > foldl (flip (&&)) True [undefined, False] -- :)
06:51:11 <lambdabot>   False
06:51:14 <casbon> ok thanks I'm starting to see now - this is, I think, the most useful IRC channel I've ever been to
06:51:48 <EvilTerran> foldr const undefined (1:undefined)  -->  const 1 (foldr const undefined undefined)  -->  1; the foldr over the tail is never evaluated
06:52:18 <Cale> > foldr (:) [] [1..]
06:52:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:53:06 * EvilTerran demonstrates "if", Cale  demonstrates "when" :)
06:53:34 <Cale> That's kind of a silly example there, but it's also quite instructive. You can see foldr f z as naturally replacing each (:) in the list with f and each [] with z
06:53:48 <Cale> foldl by contrast does something less natural, flipping the list around
06:54:02 <Cale> > foldl (flip (:)) [] [1..10]
06:54:02 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:54:58 <Cale> Well, it walks all the way to the end of the list and then results in an expression which starts combining elements of the list.
06:55:33 <EvilTerran> casbon, as i understand it, an unusually high proportion of this channel are either academics or aspire that way. i figure that helps keep the standard of conversation up.
06:56:05 <Cale> That expression can get fairly large, and since it's not evaluated until reaching the end of the list, there can be problems if you were hoping for the combination to happen as you went along.
06:56:05 <casbon> thought so :)
06:56:17 <Cale> > foldl (+) 0 [1..1000000]
06:56:18 <lambdabot>   * Exception: stack overflow
06:57:14 <Cale> This builds up a large expression which looks like ((...(((0+1)+2)+3)...)+999999)+1000000
06:57:27 <Cale> and then dies with a stack overflow when it tries to evaluate that
06:57:47 <Cale> So to avoid that, there's a strictified version of foldl, called foldl'
06:58:00 <Cale> foldl' does the combining as it walks down the list
06:58:13 <Cale> (instead of just building up a large expression)
06:58:20 <Cale> > foldl' (+) 0 [1..1000000]
06:58:20 <lambdabot>   500000500000
06:58:43 <Cale> @src foldl
06:58:44 <lambdabot> foldl f z []     = z
06:58:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:58:45 <Cale> @src foldl'
06:58:45 <lambdabot> foldl' f a []     = a
06:58:45 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:00:04 <Cale> x `seq` y is an expression which when evaluated, ensures that x is evaluated before resulting in y.
07:00:31 <EvilTerran> *ensures that x is non-bottom
07:00:37 <Cale> (where by 'evaluated', I mean up to determining just the top level constructor)
07:01:19 <EvilTerran> > undefined `seq` ()
07:01:20 <lambdabot>   * Exception: Prelude.undefined
07:01:26 <EvilTerran> > (undefined : undefined) `seq` ()
07:01:27 <lambdabot>   ()
07:01:40 <Cale> Which is the same as ensuring that it's not an infinite loop or error (which we group together and call "bottom", the bottom of the definedness lattice)
07:06:33 <Cale> Heh, if we had a Turing oracle, we could totally undermine the Report's definition of seq
07:07:00 <Cale> Just check that the term will terminate without actually doing any evaluation at all ;)
07:07:08 * idnar performs a summoning spell
07:09:19 <Cale> Heh, actually, even with a program that produced some information about termination, you could make a conforming version of seq which was pretty stupid. :)
07:11:03 <lilac> note that "x `seq` y `seq` x" and "y `seq` x" are assigned the same semantics by the Report :)
07:11:11 <Cale> Yeah
07:11:51 <Cale> But you could also have a compiler which when it sees x `seq` y, tries to prove that x will always terminate, and if it can, replaces the expression with y.
07:12:11 <Cale> "optimising" the seq away ;)
07:12:23 <lilac> sure. and likewise if it sees x will never terminate it can replace the expression with (coerce x)
07:12:41 <Cale> hm?
07:12:45 <Cale> oh, right
07:12:51 <Cale> "will never terminate"
07:12:58 <Cale> misread that the first time somehow
07:13:47 <lilac> if it sees neither will terminate it can replace it with x `unamb` y :)
07:14:05 <lilac> (coerce x) `unamb` y
07:14:11 <benmachine> :t coerce
07:14:13 <lambdabot> Not in scope: `coerce'
07:14:19 <lilac> benmachine: coerce :: a -> b ;-)
07:14:25 <benmachine> ic
07:15:34 <Cale> We should write a vicious Haskell implementation which does everything to the spec, but in the most surprising possible way.
07:15:47 <Zao> Sounds like the Evil C++ Standard Library.
07:15:53 <Zao> Which has an affinity for starting nethack.
07:16:08 <lilac> a 'seq' that collects together 'forced' things and only evaluates them when you get back to the IO action which initiated them?
07:16:23 <lilac> Zao: i think gcc did that for a while on an unknown #pragma
07:16:25 <benmachine> Zao: I googled that and just found the normal C++ standard library
07:16:29 <benmachine> is google trying to tell me something
07:18:12 <Cale> It would indeed be fun to see a C or C++ implementation which replaced everything that had undefined behaviour according to the standard with starting nethack.
07:18:25 <lilac> i think you could do better than nethack
07:18:51 <lilac> for instance: "std::vector<int> x; ...; ++x.end();" could randomly shuffle the vector
07:19:27 <Cale> hehe
07:19:51 <mpg> quit
07:19:56 <lilac> "int x = INT_MAX; ++x;" could search through memory for something which looks like a small integer and increment it
07:20:10 <Cale> yeah, doing subtler things which would be less likely to be detected for a while is possibly more funny
07:21:10 <McManiaC> cabal: Missing dependency on a foreign library:
07:21:10 <McManiaC> * Missing header file: HsUnixCompat.h
07:21:10 <lilac> p[n] = ++n; could delete a random file from the current directory
07:21:15 <McManiaC> what package is that? (debian)
07:23:42 * Cale just realised that he had 3 complete old versions of GHC installed. :]
07:24:18 <Cale> McManiaC: cabal install unix-compat -- perhaps
07:24:34 <BleSS> haskell is well suietted for parallel computing, but with the output of OpenCL, don't you think that haskell could loose that advantage over another languages?
07:24:43 <McManiaC> Cale: well yeh, thats where the message is from
07:24:51 <Cale> McManiaC: The only copies of that file on my system are in ~/.cabal/lib/unix-compat-*
07:25:03 <Cale> They appear to come with the package
07:25:19 * int-e would have at least 3 versions, too ... but failed to build 6.6.1.
07:25:32 <int-e> (it wasn't a high priority on my list)
07:26:32 * Cale realises that ~/.cabal/lib has the hierarchy backward.
07:26:47 <Cale> It goes  package-version/ghc-version
07:27:07 <Cale> Instead of the obviously more sensible  ghc-version/package-version
07:28:54 <McManiaC> :S
07:29:04 <int-e> but it reflects the structure for global installs. /prefix/lib/package-version/ghc-version/...
07:29:25 <Cale> That is also less sensible than doing it the other way, I think.
07:29:49 <int-e> (which btw looks funny when the prefix contains the ghc version as well: /opt/ghc-6.10.4/lib/mtl-1.1.0.2/ghc-6.10.4/...)
07:30:50 <Cale> I don't know why I'm doing this cleaning up now, rather than in a short while when 6.12 is out.
07:31:36 <McManiaC> Cale: are you using debian too?
07:32:03 <Cale> McManiaC: I'm using Ubuntu, but not Ubuntu's packages for Haskell stuff, because they're ridiculously out of date.
07:32:39 <Cale> I just install the generic linux binaries for GHC, which work fine.
07:32:40 <McManiaC> hmm
07:33:27 <Cale> after that, you just install cabal install, and you're set.
07:34:11 <Cale> int-e: actually, it *doesn't* reflect the structure for global installs on my system
07:34:35 <Cale> int-e: I have /usr/local/lib/ghc-6.10.3/packagename-version/
07:35:31 <int-e> oh, right. I have a mix of both. the example I had was installed by cabal, I guess. /opt/ghc-6.10.4/lib/ghc-6.10.4/base-4.1.0.0/... also looks silly, of course.
07:36:49 <Cale> I suppose I don't mind having to use  rm -r */ghc-6.10.1
07:36:58 <Cale> But it feels a bit strange to type something like that
07:44:02 <McManiaC> ffs
07:44:20 <McManiaC> whats wrong with that header
07:44:36 <Cale> How are you trying to install the package? Just with a plain cabal install?
07:44:57 <McManiaC> cabal install and ghc 6-10
07:45:16 <McManiaC> cabal install unix-compat
07:45:36 <McManiaC> http://ix.io/k6
07:46:27 <McManiaC> ghc 6.10.4
07:47:47 <Baughn> McManiaC: So.. that error's pretty self-explanatory, isn't it?
07:48:03 <McManiaC> not since i cant find any packages
07:48:20 <Baughn> Ah. Hm.
07:48:24 <Baughn> It's apparently part of the package.
07:48:29 <McManiaC> yeh
07:48:52 <McManiaC> i can even download the package and use that --extra-include-dirs=.. and it wont work
07:49:22 <Baughn> It certainly looks like it ought to work..
07:49:31 * Baughn blinks. It *did* work.
07:49:38 <Baughn> McManiaC: What distribution are you running this on?
07:49:45 <McManiaC> debian lenny
07:49:45 <Baughn> McManiaC: And what version of cabal and cabal-install?
07:49:48 <McManiaC> (with ghc from sid)
07:50:05 <McManiaC> cabal-install version 0.6.2
07:50:09 <McManiaC> using version 1.6.0.3 of the Cabal library
07:50:21 <Baughn> Same as here..
07:50:34 <McManiaC> on my arch linux it works too
07:50:37 <McManiaC> :S
07:50:49 <Baughn> I'm boggled. Still, one possibility: GHC on Debian is packaged prety horribly
07:50:56 <Saizan> with cabal-install it works?
07:51:03 <Baughn> You could try uninstalling the OS's version, and installing your own
07:51:04 <Saizan> or with yaourt/pacman?
07:51:13 <McManiaC> Saizan: cabal
07:51:13 <Baughn> Works with cabal-install on gentoo, here
07:51:34 <Saizan> Baughn: with the same version?
07:51:41 <Baughn> Yes
07:52:04 <Baughn> ghc 6.10.4, cabal 1.6.0.3, cabal-install 0.6.2
07:52:05 <Saizan> of the Cabal lib too? weird
07:52:27 <Baughn> The one difference is that I used the binary package from haskell.org to install GHC
07:52:38 <McManiaC> ill try that
07:58:06 <linopolus> anyone worked with Qt and can say me which bindings i should use?
08:06:29 <McManiaC> Baughn: !!
08:06:39 <McManiaC> it works with the binary package from haskell.org
08:06:39 <McManiaC> :)
08:07:05 <Baughn> McManiaC: Score one for Debian.
08:07:17 <McManiaC> ^^
08:08:59 <McManiaC> now i just get a lot of other errors with cabal :s
08:09:04 <McManiaC> but --reinstall seems to be working
08:25:07 <forgot> how do most of you normally go about getting the source code of a cabal package?
08:25:38 <maltem> dig in .cabal/packages
08:25:39 <dcoutts> forgot: cabal unpack foobar; cd foobar-x.y/
08:25:45 <dcoutts> maltem: nooo!
08:25:53 <maltem> hey unpack must be new :)
08:25:56 <dcoutts> it is
08:25:56 <Raevel> oooh i didnt know about unpack
08:25:58 <dcoutts> :-)
08:26:30 <maltem> nice to have
08:26:34 <Raevel> y
08:26:44 <dcoutts> it was new in version 0.6.2, released in February
08:26:49 <McManiaC>     Failed to load interface for `Prelude':
08:26:50 <McManiaC> wtf
08:27:06 <maltem> so much for "new"
08:27:16 <forgot> oh yum i didn't know that
08:27:53 <linopolus> McManiaC: xD
08:28:30 <lilac> McManiaC: are you using -hide-package base or something equally perverse? :)
08:28:38 <McManiaC> no
08:28:54 <lilac> cabal hides all packages by default iirc
08:28:54 <maltem> McManiaC, have a file called Prelude.hs floating around?
08:29:14 <maltem> (will confuse ghci)
08:29:57 <lilac> maltem: that gives me: <command line>: module `Prelude' is not loaded
08:30:06 <lilac> which is somewhat surprising :)
08:32:16 <McManiaC> ok how do i remove all libs, packages etc?
08:32:16 <McManiaC> :D
08:34:50 <lilac> McManiaC: rm -rf /lib /opt /etc ;-)
08:34:56 <McManiaC> :P
08:36:48 <benmachine> okay so I'm back with the polynomials again
08:37:16 <benmachine> coefficients of ascending powers of x as lists of Nums
08:37:31 <benmachine> so here I have three implementations of applying the polynomial:
08:37:31 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9834#a9834
08:37:41 <benmachine> I think the first two are pretty much the same
08:37:56 <benmachine> the third is stricter but I'm not sure how the efficiency compares
08:38:00 <benmachine> any comments?
08:38:34 <benmachine> (why doesn't sum use foldl'?)
08:39:02 <burp> because foldl' would be strict
08:39:03 <lilac> > sum [1..] > (0 :: Natural)
08:39:08 <lambdabot>   mueval: ExitFailure 1
08:39:37 <maltem> benmachine, most of the time one would want sum to use foldl'
08:39:50 <lilac> gah, it's lazy but it's still a left fold ;)
08:39:58 <benmachine> lilac: I know right
08:40:04 <maltem> there should indeed be a sum' somewhere
08:40:14 <lilac> > foldr (+) 0 [1..] > (0 :: Natural)
08:40:14 <benmachine> maltem: but it'd nearly always be the preference
08:40:14 <lambdabot>   True
08:40:19 <McManiaC> where does ghc-pkg save its informations?
08:40:29 <benmachine> > undefined >= (0 :: Natural)
08:40:29 <lambdabot>   True
08:40:30 <McManiaC> or get them from..?
08:40:58 <lilac> benmachine: oops, that looks like a bug ;-)
08:41:05 <sohum> > -1 :: Natural
08:41:05 <lambdabot>   * Exception: Natural: (-)
08:41:06 <maltem> benmachine, anyways, I'd prefer a left fold (foldl', that is) for your function
08:41:15 <sohum> lilac: actually, it probably isn't
08:41:22 <lilac> sohum: i implemented that (>=) ...
08:41:27 <sohum> ah
08:41:32 <jmcarthur_work> sohum, i'd say it is
08:41:36 <lilac> > (0::Natural) <= undefined
08:41:36 <lambdabot>   True
08:41:38 <sohum> but still, that's what I'd expect lazy evaluation to do
08:41:46 <lilac> > compare undefined (0::Natural)
08:41:47 <lambdabot>   * Exception: Prelude.undefined
08:41:47 <jmcarthur_work> _|_ shouldn't really be >= anything, i think
08:41:57 <benmachine> maltem: the foldl's I tried consumed the list in the wrong way
08:41:59 <lilac> > compare (0::Natural) undefined
08:42:00 <lambdabot>   * Exception: Prelude.undefined
08:42:21 <doserj> compare not matching <= definitely is a bug
08:42:47 <benmachine> doserj: compare needs more information than >= provides
08:42:53 <jmcarthur_work> actually i guess _|_ >= 0 is fine, but yeah, different results from compare is bad
08:43:12 <lilac> > undefined < (0 :: Natural)
08:43:13 <lambdabot>   * Exception: Prelude.undefined
08:43:18 <lilac> ^^ that's the bug
08:43:22 <benmachine> I suppose having a non-strict >= when == is strict is a little strange
08:43:34 <benmachine> lilac: isn't that a bit like
08:43:38 <benmachine> > zip undefined []
08:43:39 <lambdabot>   * Exception: Prelude.undefined
08:43:43 <benmachine> > zip [] undefined
08:43:44 <lambdabot>   []
08:44:00 <jmcarthur_work> benmachine, i don't think nonstrict >= but strict == is that strange
08:44:05 <sohum> what's the literal for infinity in float?
08:44:05 <lilac> benmachine: undefined >= (0 :: Natural) i'm OK with, but i want (a >= b) == not (a < b)
08:44:14 <lilac> even if a or b is _|_
08:44:37 <maltem> > foldl' (+) 0 . zipWith (*) [1..10^5] $ iterate (*17) 1
08:44:41 <lambdabot>   mueval-core: Time limit exceeded
08:44:47 <maltem> > foldl' (+) 0 . zipWith (*) [1..10^4] $ iterate (*17) 1
08:44:48 <lambdabot>   192792922050363447961299005215730095333139885081798640312937648084855283068...
08:45:08 <sohum> @instances Bounded
08:45:10 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
08:45:10 <benmachine> 17 is a pretty high number to go with
08:45:34 <sohum> ? what's Any and All?
08:45:41 <maltem> > foldl' (+) 0 . zipWith (*) [1..10^4] $ iterate (/17) 1
08:45:41 <lambdabot>   1.1289062499999996
08:45:52 <jmcarthur_work> sohum, Bool wrappers
08:46:06 <sohum> ah
08:46:08 <benmachine> sohum: they are newtype wrappers for Bool to reflect the two possible instances of Monoid
08:46:30 <benmachine> Any has mempty False and mappend || where All has TRue and &&
08:46:57 <sohum> > isInfinite 0/0
08:46:58 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Bool.Bool)
08:46:58 <lambdabot>    arising from a use o...
08:47:09 <sohum> > isInfinite (0/0)
08:47:09 <lambdabot>   False
08:47:25 <sohum> benmachine: ah, cool
08:47:34 <sohum> > Infinity
08:47:34 <lambdabot>   Not in scope: data constructor `Infinity'
08:48:00 <sohum> > tan pi
08:48:01 <lambdabot>   -1.2246467991473532e-16
08:48:12 <benmachine> > tan (pi / 2)
08:48:13 <lambdabot>   1.633123935319537e16
08:48:15 <sohum> > tan (pi/2)
08:48:16 <lambdabot>   1.633123935319537e16
08:48:20 <sohum> grrr.
08:48:26 <doserj> > 1/0::Float
08:48:26 <lambdabot>   Infinity
08:48:40 <sohum> > isInfinite (1/0)
08:48:40 <lambdabot>   True
08:48:48 <doserj> 0/0 is NaN
08:48:50 <sohum> > (1/0) + 1
08:48:51 <lambdabot>   Infinity
08:48:53 <benmachine> why is that?
08:48:56 <sohum> > (1/0) + undefined
08:48:56 <lambdabot>   * Exception: Prelude.undefined
08:49:06 <sohum> > undefined + (1/0)
08:49:07 <lambdabot>   * Exception: Prelude.undefined
08:49:22 <sohum> > let x = 1/0 in x + undefined
08:49:23 <lambdabot>   * Exception: Prelude.undefined
08:49:53 <benmachine> > (-1) / (-0)
08:49:54 <lambdabot>   Infinity
08:49:57 <benmachine> > (-1) / (0)
08:49:58 <lambdabot>   -Infinity
08:50:08 <doserj> sohum: Infinity + x is not always Infinity
08:50:24 <doserj> > 1/0 + (-1/0)
08:50:24 <lambdabot>   NaN
08:50:25 <benmachine> > (-1) / (-0) + (-1) / 0
08:50:26 <lambdabot>   NaN
08:50:31 <sohum> doserj: huh. fair enough
08:50:44 <benmachine> I guess that answers my question too
08:50:52 <sohum> > mplus (Just 5) undefined
08:50:53 <lambdabot>   Just 5
08:50:57 <benmachine> > (0 / 0) + undefined
08:50:58 <lambdabot>   * Exception: Prelude.undefined
08:51:02 <benmachine> owell
08:51:03 <sohum> > mplus undefined (Just 5)
08:51:03 <lambdabot>   * Exception: Prelude.undefined
08:51:27 <benmachine> I never got the point of mplus
08:51:37 <benmachine> I don't get how it is useful when you already have Monoid
08:52:00 <sohum> I've used mplus a lot; haven't looked into Monoid, though
08:52:10 <yottis> hmm. is there a techical reason why type subclasses without any definitions of their own aren't implicitly instantiated?
08:52:24 <lilac> benmachine: some things are MonadPlus but not Monoid
08:52:50 <sohum> @instances MonadPlus
08:52:50 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
08:52:53 <sohum> @instances Monoid
08:52:53 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:52:53 <benmachine> lilac: can't you make them Monoid by going mempty = mzero and mappend = mplus?
08:52:59 <idnar> benmachine: the instances usually do different things
08:53:06 <idnar> > Just 5 `mplus` Just 6
08:53:07 <lambdabot>   Just 5
08:53:11 <idnar> > Just 5 `mappend` Just 6
08:53:12 <lambdabot>   Ambiguous type variable `t' in the constraints:
08:53:12 <lambdabot>    `GHC.Num.Num t' arising ...
08:53:16 <idnar> doh
08:53:18 <sohum> :t mappend
08:53:19 <lambdabot> forall a. (Monoid a) => a -> a -> a
08:53:22 <idnar> > Just "foo" `mappend` Just "bar"
08:53:23 <lambdabot>   Just "foobar"
08:53:23 <benmachine> > (First (Just 5)) `mappend` (First (Just 6))
08:53:24 <lambdabot>   First {getFirst = Just 5}
08:53:26 <idnar> > Just "foo" `mplus` Just "bar"
08:53:26 <lilac> > Just 3 `mappend` Just (4 :: Int)
08:53:26 <lambdabot>   Just "foo"
08:53:27 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
08:53:27 <lambdabot>    arising from a use of...
08:53:38 <yottis> ie. if i had "class Identity a where identity :: a", "class SemIGroup a where (Â¤) :: a -> a -> a" and then "class (Identity a, SemiGroup a) => Monoid a" would be inherited automatically if the two first are
08:53:48 <lilac> idnar: it's a good example. Maybe is MonadPlus but Maybe Int is not Monoid
08:53:55 <idnar> > "foo" `msum` "bar"
08:53:56 <lambdabot>   Couldn't match expected type `m a'
08:53:56 <lambdabot>         against inferred type `GHC.Types...
08:54:08 <idnar> > "foo" `mappend` "bar"
08:54:09 <lambdabot>   "foobar"
08:54:27 <idnar> hmm, I thought [] was MonadPlus
08:54:37 <sohum> it is
08:54:45 <lilac> > "foo" `mplus` "bar
08:54:46 <idnar> so why didn't that work?
08:54:46 <lambdabot>   <no location info>:
08:54:46 <lambdabot>      lexical error in string/character literal at end o...
08:54:47 <lilac> > "foo" `mplus` "bar"
08:54:47 <lambdabot>   "foobar"
08:54:50 <idnar> oh
08:54:52 * idnar facepalms
08:54:55 <lilac> idnar: because msum :: [m a] -> m a
08:55:02 <idnar> I somehow always get those mixed up
08:55:12 <benmachine> the MonadPlus [] instance is basically the Monoid [a] instance
08:55:30 <benmachine> I don't think Maybe should be MonadPlus
08:55:33 <benmachine> I think First should be
08:55:40 <benmachine> oh oh also
08:56:04 <benmachine> what about Alternative
08:56:04 <benmachine> isn't that basically the same as well
08:56:29 <sohum> Maybe as MonadPlus is very useful
08:56:42 <benmachine> sohum: First would be just as useful, and less ambiguous
08:56:46 <benmachine> well
08:56:47 <benmachine> maybe.
08:57:00 <benmachine> I'm not actually sure, I haven't played around with it
08:57:01 <sohum> what's First?
08:57:11 <benmachine> it's a newtype on Maybe
08:57:14 <sohum> @src First
08:57:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:57:18 <benmachine> Maybe has three Monoid instances
08:57:40 <benmachine> there's plain old (Monoid a) => Maybe a
08:57:42 <sohum> oh, so same semantics, but clearer name
08:57:46 <benmachine> and then there's First a and Last a
08:57:59 <benmachine> First a uses the Just on the left, and Last a uses the Just on the right
08:58:11 <benmachine> the unwrapped version mappends the values
08:58:26 <sohum> right
08:58:42 <sohum> > "foo" `mappend` "bar"
08:58:42 <lambdabot>   "foobar"
08:59:07 <thaldyron> Is there a way to serialize a function in Haskell?
09:00:27 <Baughn> No. I've been planning to do /something/ like that, but only post-6.12; it requires proper shared-library support
09:01:00 <Baughn> (And it wouldn't really be serializing functions, just symbols - better make sure the other executable is the exact same version)
09:01:16 <thaldyron> Baughn: I see, thanks for the answer!
09:03:02 <sohum> serialising functions is /hard/
09:03:10 <sohum> especially in the context of closures
09:03:23 <benmachine> if the domain is bounded and the codomain is showable, then...
09:03:28 <Baughn> sohum: Extremely
09:03:29 <sohum> I suppose it's easier in a purely functional language, because definitions don't change
09:03:42 <Baughn> Even with plugins? :P
09:03:54 <sohum> ?
09:04:15 <Baughn> sohum: GHC has this plugin system.. you can load new functions at runtime, or replace them
09:04:19 <sohum> oh
09:04:21 <sohum> pffffff
09:04:30 <sohum> that's cheating
09:04:47 <lilac> benmachine: regarding Alternative, you're stepping into the question of whether Applicative should be a superclass of Monad
09:05:12 * benmachine steps into the answer "yes"
09:05:43 <lilac> benmachine: do you think the Monoid m => Applicative (Either m) instance or the Error e => Monad (Either e) instance is wrong?
09:06:10 <benmachine> I think both of those are non-obvious
09:06:17 <lilac> hmm, is that the right context for the Applicative one?
09:06:28 <benmachine> I suppose just newtyping everything is not always best
09:06:41 <jmcarthur_work> there are several sensible instances i can think of, i think
09:06:43 <benmachine> but, I don't know
09:06:44 <Baughn> sohum: I'm pretty sure thunks are position-independent, so at the very least serializing and deserializing data into the exact same executable image should work
09:07:10 <benmachine> it's my opinion that if you want to support multiple identical systems
09:07:13 <Baughn> sohum: Adding a bit of symbol resolution, /small/ changes would also be handlable.. should really find a way to extract the types, I think
09:07:19 <tinLoaf> question: with this code: http://pastebin.com/m282df991 ghci yells at me at the last line
09:07:20 <jmcarthur_work> but i think if there is to be an instance for unwrapped Either it should behave like the Maybe monad
09:07:29 <benmachine> you should do so with multiple identical types, not multiple identical classes
09:07:29 <tinLoaf> it wants to match some type "k" against the Int
09:07:32 <tinLoaf> what the heck?
09:08:18 <Baughn> sohum: ..it's so insane, I'm really looking forward to trying. :3
09:08:29 <sohum> Baughn: that sounds /crazy/. Good luck!
09:08:40 <copumpkin> tinLoaf: the type is too free
09:09:12 <tinLoaf> copumpkin: which type?
09:09:18 <copumpkin> the type it wants is forall k. (Ord k) => IntField -> k
09:09:22 <copumpkin> of getKey
09:09:41 <copumpkin> that's saying that any instance of Ord that someone wants out of that function, you can provide
09:09:45 <copumpkin> whereas all you can give is an Int
09:10:10 <tinLoaf> oh, ok.. i thought this was interpreted as "the function has to spit out something in the Ord typeclass"
09:10:19 <copumpkin> it sort of is
09:10:25 <copumpkin> but the (often implicit) forall is important
09:10:26 <benmachine> lilac: the way I see it, having a Monad and an Applicative for Either that are different means you can have two implementations of ap/<*> for Either - fine
09:10:30 <benmachine> but what if you want three?
09:10:34 <tinLoaf> yeah, but like the function had the possibility to chose
09:10:41 <tinLoaf> thanks
09:10:45 <copumpkin> the caller has the ability to choose
09:10:55 <benmachine> it's a problem that is only generally solved with newtypes, and if you do it like that there is nothing wrong with having Applicative a superclass of Monad
09:11:06 <copumpkin> the solution for your exact situation might not be obvious though
09:11:19 <copumpkin> there's a GHC extension that would cover it nicely
09:11:23 <tinLoaf> yeah, i realized that now.. that's exactly the way to implement a function with polymorphic return, right?
09:11:36 <tinLoaf> hum.. i think I can live with getKey :: a -> Int
09:11:52 <tinLoaf> or.. hum..
09:11:55 <copumpkin> yeah, and for something like Integral with a "conversion" function you can usually do polymorphic return types
09:11:58 <tinLoaf> what's that extension?
09:12:06 <copumpkin> it's called TypeFamilies
09:12:17 <tinLoaf> i'll have a look at that
09:12:23 <tinLoaf> thanks
09:12:26 <sohum> I still haven't quite figured out type families
09:12:27 <copumpkin> it allows you to put a return type in your class to say that the return type depends on the instance
09:12:57 <copumpkin> so your class would change to: class Field a where type ReturnType a :: *; getKey a -> ReturnType a
09:13:17 <copumpkin> and then instance Field IntField where ReturnType IntField = Int; getKey (IntField k) = k
09:13:37 <sohum> huh
09:13:51 <copumpkin> ReturnType is effectively a type function that takes a type and returns one
09:13:56 <jmcarthur_work> sohum, i'd say type classes are to functions as type families are to types
09:14:05 <copumpkin> so ReturnType Intfield = Int
09:14:14 <tinLoaf> uhm, ok, so you have like sets of types that that thing might return
09:14:17 <eyeris> Is there any mechanism in the list comprehensions to provide me with the index of the item in a list. e.g. in [ z | x <- repeat 1, y <- repeat2, ...] I want to use the index into the x and y lists in a guard in place of the ...
09:14:28 <lilac> benmachine: the Either ones are intuitively 'right', though
09:14:39 <jmcarthur_work> s/functions/values/
09:14:43 <lilac> benmachine: the Monad instance carries only a single error, the Applicative instance carries all errors
09:14:52 <lilac> after all, that sort of thing is what Applicatives are about
09:15:06 <copumpkin> tinLoaf: yeah, it's basically extending the idea of methods in a class to work for types too, so not only can your typeclass carry functions associated with a type, but other types
09:15:09 <sohum> jmcarthur_work: whoa.
09:15:27 <tinLoaf> hum, i think i'll try to use that
09:15:28 <tinLoaf> thanks
09:15:33 <copumpkin> you can also get type families on their own, without the typeclass baggage, if you want to do crazy type stuff without value stuff
09:15:37 <copumpkin> tinLoaf: cool!
09:16:08 <Lemmih> eyeris: You can zip with the index.
09:19:30 <eyeris> Lemmih Thanks
09:20:05 <dons> bos: http://hackage.haskell.org/package/epoll
09:20:05 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:20:06 <eyeris> That is zip myList [0..]?
09:20:23 <eyeris> Or, flip those args.
09:20:29 <bos> dons: huh
09:20:30 <sohum> hm. why does lambdabot do messages?
09:20:35 <sohum> don't we have memoserv?
09:22:00 <lilac> sohum: a lot of stuff on hackage is reinventing the wheel, but building it out of lambdas. lambdabot is no exception ;-)
09:22:27 <sereven> eyeris: flipped is more generally useful, say with lookup or functor (,) but depends how you'll be using it.
09:24:37 <sohum> lilac: heh. fair enough
09:29:43 <xenoblitz> Hi people, I have a problem with type classes here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9836#a9836
09:29:53 <xenoblitz> can anyone help?
09:36:19 <lilac> xenoblitz: regions is supposed to return "forall b. (BasicLand b) => Regions b" but it only returns "Regions Country"
09:36:19 <tinLoaf> functions (that I apply to a) are automatically chosen from the functions that are defined for the typeclasses a is in, right?
09:36:19 <lilac> tinLoaf: no, it's more general than that.
09:36:20 <tinLoaf> so if i  have two typeclasses defining a "foo" function, and a is member of one of these typeclasses, automatically the "right" foo is chosen for "foo a"?
09:36:31 <Botje> xenoblitz: the type you give for continentRegions is narrower than the type the instance wants
09:36:44 <tinLoaf> lilac: so i should not define two typeclasses with the same functions?
09:36:52 <lilac> tinLoaf: no, that would be an error. if you have two 'foo's in scope, you can't call foo unqualified
09:37:11 <tinLoaf> hum, ok
09:37:59 <lilac> tinLoaf: 'class Foo a where foo :: Int -> [a]' defines a function 'foo :: Foo a => Int -> [a]'
09:38:06 <xenoblitz> lilac, Botje: hmmm makes sense... so I'm being to restrictive... is it possible for me to somehow show it that it is of type Country (sort of pass it the type) without having to explicitly define the regions as Region Country?
09:38:45 <tinLoaf> lilac: yeah, i thought this function was only "visible" when applied to stuff of a type that is member of the foo typeclass
09:39:01 <lilac> xenoblitz: if you want regions for Continent to return Region Country, then you need to change the type of 'regions'.
09:39:21 <xenoblitz> lilac: in the type class right?
09:39:36 <lilac> xenoblitz: no, the type class is the bit that's wrong
09:40:12 <lilac> xenoblitz: regions, when applied to a Continent, does not produce forall b. BasicLand b => Region b.
09:40:56 <xenoblitz> lilac: hmmm so how do I remove the implicit forall part?
09:41:16 <lilac> xenoblitz: you could either add another type parameter to RegionalLand for the region type, or you could use an associated type, or you can change the type of regions to be a -> Regions Country
09:41:49 <xenoblitz> 3rd is bad because I don't want it to be restricted that way... see a planet has a region of continents... and so on hierarchically
09:41:54 <xenoblitz> I want it generic
09:41:59 <xenoblitz> I tried the 1st
09:42:01 <xenoblitz> but I had problems
09:42:15 <lilac> or you can use an existential wrapper for the result, which would be like saying "regions returns a Regions b, for some b which is a BasicLand, but i'm not saying which one"
09:42:26 <lilac> i would recommend a type parameter or associated type
09:42:29 <xenoblitz> let me edit to how I tried the first one
09:42:33 <xenoblitz> just a sec :)
09:44:40 <lilac> xenoblitz: if you're going down the MPTC route, you'll want a functional dependency landType -> regionType
09:45:00 <xenoblitz> er MPTC?
09:45:05 <xenoblitz> lilac: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9836#a9838
09:45:06 <lilac> multi-parameter type class
09:45:31 <xenoblitz> lilac: is that remotely correct?
09:45:36 <lilac> xenoblitz: that looks ok apart from the missing fundep
09:46:11 <lilac> xenoblitz: also, remove the context from the type for regions
09:46:14 <xenoblitz> hmmm I don't know much about this part of Haskell ... is there something I should read?
09:46:56 <xenoblitz> lilac: that way you are suggesting... I kept getting an error requesting an instance of RegionalLand Continent b
09:47:09 <etate> kmc: so you neglected to tell me about unsafePerformIO :)
09:47:28 <lilac> xenoblitz: can you paste the error?
09:47:42 <lilac> (it's probably due to the missing fundep)
09:48:04 <xenoblitz> lilac: sure just a sec
09:49:20 <sohum> etate: everyone neglects to mention the existence of unsafePerformIO ;)
09:49:53 <etate> sohum: :D well i was asking how you can get IO a -> a
09:49:57 <gwern> sohum: if by neglects you means 'dare not speak its name', then yes
09:50:16 <sohum> The Function Which Must Not Be Named?
09:50:20 <etate> it might be useful for example when you want to print stuff in a pure function
09:50:26 <etate> for debugging
09:50:31 <etate> no?
09:50:31 <Twey> unsafePerformIO isn't really Haskell >.>
09:50:38 <Twey> etate: Not directly.
09:50:42 <sohum> usually you just poke the function in ghci instead, etate
09:50:48 <Twey> Or use Debug.Trace.
09:51:10 <gwern> it's like plutonium - useful, but you want something in between it and you
09:52:05 <Twey> Haha, aye.
09:52:37 <xenoblitz> lilac: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9836#a9839
09:53:49 <lilac> xenoblitz: yeah, looks like it's just the missing fundep causing that.
09:54:05 <lilac> 'class (Basic...) => RegionalLand a b | a -> b where'
09:55:12 <lilac> xenoblitz: the problem is that getResourcesForOwner doesn't nail down the region type for Continent, so it's looking for an instance RegionalLand Continent b
09:55:36 <lilac> (ie it doesn't know what b is, and there could in general be multiple 'b's with different instances)
09:55:55 <lilac> xenoblitz: you might want to read this: http://www.haskell.org/haskellwiki/Functional_dependencies
09:57:05 <xenoblitz> thanks a lot lilac :D
09:57:46 <xenoblitz> lilac: it works :) I will read it for sure
10:48:34 <hackagebot> bindings-posix 1.0 - Low level bindings to posix. (MauricioAntunes)
10:49:07 <merijn> Maybe I'm missing something obvious but, while I'm trying to play around with GHCi I run into trouble writing some of the example code. "let {fib 1 = 1; fib 2 =1; fib n = fib (n-1) + fib n-2)}" returns a stack overflow for n > 2 which hardly seems right.
10:49:34 <hackagebot> bindings-libusb 1.0 - Low level bindings to libusb. (MauricioAntunes)
10:49:57 <ClaudiusMaximus> merijn: missing () in  ( n - 2 )
10:51:24 <merijn> ClaudiusMaximus: That was actually a type in my question here. But I did find it and it was a stupid parenthesis mistake. I wrote "(fib n-2)" my last attempt, while I actually wrote it right the first time...
10:52:12 <ClaudiusMaximus> merijn: most stack overflows i've got are defining x in terms of x itself, without any way of breaking the loop
10:52:36 <ClaudiusMaximus> > let x = x + 1 in x
10:52:40 <lambdabot>   mueval-core: Time limit exceeded
10:52:58 <merijn> Note to self: Proof-read more carefully
11:04:30 <joy_girl> hello my programmers
11:04:47 <joy_girl> I am neeeeew
11:04:57 <joy_girl> i have problemas
11:05:01 <joy_girl> heeeeeelp me
11:05:04 <joy_girl> pleeeeeach
11:05:15 <themroc-> pleachybeachy
11:05:22 <joy_girl> hi themroc
11:05:29 <joy_girl> are you looking for a good time?
11:05:54 <themroc-> gimme ur page and i pay all my money just to you!
11:06:20 <joy_girl> oh my, you naughty naughty programmer
11:06:58 <themroc-> arrr
11:07:02 <joy_girl> my phone number is ...... call me
11:07:15 <dons> tommd: i'll be at the hackathon sat + sun (some other galwegians too). prob. not today though.
11:09:23 <gjl> Hi all. A beginner with a question here. I'm currently learning Haskell but I'd like to be able to get into writing extensions for Chrome on the side, which is something that would unfortunately require me to learn javascript. Aside from taking away time I could spend working in Haskell, would learning javascript simultaneously interfere with my learning of Haskell?
11:09:58 <dons> hmm. maybe? no? hard to say.
11:11:14 <tommd> dons: Ok
11:11:33 <dons> looks like Lee and Adam will be coming down, at least.
11:11:34 <merijn> gjl: Depends on the person and prior exposure to languages I guess
11:11:52 <McManiaC> hmmm is there anything special with forkIO and background jobs?
11:11:54 <tommd> dons: Sounds good - the room will be brimming, but that's cool.
11:12:03 <dons> sweet
11:12:12 <dons> McManiaC: special??
11:12:19 <dons> McManiaC: its very special and super magic
11:12:25 <McManiaC> i just started this application via ssh and as long as i keep connected everythings running fine, but as soon as i disconnect it stops working
11:12:46 <McManiaC> (yes i did a disown and everything)
11:13:09 <dons> you mean, you're running a haskell application?
11:13:14 <dons> that happens to use forkIO?
11:13:17 <merijn> McManiaC: Disconnecting from SSH terminates the shell and everything you start from it normally on unix systems
11:13:30 <McManiaC> dons: yes
11:13:42 <dons> you might want to use 'screen' to create a separate session, not tied to your ssh connection
11:13:44 <FunctorSalad> but he disowned it
11:13:47 <merijn> This includes background jobs, unless you fork them into daemons before disconnecting
11:13:57 <dons> this isn't a haskell issue
11:14:00 <merijn> You need to do a double fork to daemonize a process
11:14:57 <McManiaC> hmm
11:15:01 <merijn> McManiaC: And if you do any amount of work over SSH I have to second dons suggestion of screen. It's the single most important *nix program for people who work over SSH and in terminals
11:15:15 <McManiaC> i use screen
11:15:35 <McManiaC> but just thought with a little "disown" i wouldnt need it
11:16:13 <McManiaC> its even listed on htop
11:16:14 <McManiaC> hmmm
11:16:46 <McManiaC> well ok, gonna use screen then, nevermind
11:16:46 <McManiaC> :)
11:19:53 <merijn> McManiaC: This code shows how to daemonize properly (it's in python, but should be trivial to grok even if you don't know it) http://code.activestate.com/recipes/66012/
11:22:39 <merijn> Is there a pass/no-op statement I can use if I need one for the terminating call in a recursive action?
11:22:53 <monochrom> return ()
11:23:46 <hackagebot> bindings 0.1.2 - Deprecated package. (MauricioAntunes)
11:24:25 <McManiaC> merijn: this should do it, shouldnt it? http://paste.n-sch.de/5
11:25:40 <merijn> McManiaC: I can't really tell, I'm only just starting Haskell so I have no idea what that does :p
11:25:45 <McManiaC> ok
11:25:46 <McManiaC> ^^
11:26:05 <merijn> Also, as someone pointed out in the comments to the code, it might be wise to redirect stdin/stdout/stderr to /dev/null before the second fork
11:26:35 <FunctorSalad> McManiaC: uhm I'm a newbie with this too but forkIO doesn't actually fork (I think merijn meant OS fork)
11:26:49 <FunctorSalad> the threads are managed by the haskell runtime
11:26:54 <McManiaC> ok
11:27:07 <McManiaC> i copy&pasted most of this soâ¦ :)
11:27:09 <merijn> That's not gonna work then, you need OS forks, yeah
11:27:22 <McManiaC> then its even more weird why this doesnt workâ¦
11:28:49 <FunctorSalad> maybe this? http://hackage.haskell.org/packages/archive/unix/2.3.2.0/doc/html/System-Posix-Process.html#2
11:32:01 <merijn> How do I rewrite this "putStrLn ("The sum is " ++ read . sum nums)" to actually do what I expect? I've tried various variations of parenthesis and composition (or not) but I keep getting typing errors.
11:33:17 <FunctorSalad> I think you mean show, not read
11:33:29 <merijn> ah, damn
11:33:36 <FunctorSalad> and (show . sum) nums
11:36:42 <merijn> That still won't work, but I think I'm indeed confusing show and read. I'll figure it out later, dinner time.
11:38:48 <Makoryu> merijn: A quick rundown on operator precedence, from highest to lowest: Function application (foo bar), composition (foo . bar), the standard math operators (+ - * /), list concatenation (foo ++ bar), and the application operator (foo $ bar)
11:39:20 <Makoryu> merijn: In the case of (foo . bar), both foo and bar must be functions
12:05:08 <m4ik3ru> What it is.
12:05:11 <m4ik3ru> I mean...
12:05:12 <m4ik3ru> Howdy.
12:08:38 <det> Is it possible to constrain the return type of a method? For example, I am returning an object of a certain class but would like to hide a method in the return type.
12:09:21 <dons> well, you can return a function
12:09:31 <dons> or a dictionary, or a data structure wrapping all
12:09:39 <det> Im sorry
12:09:45 <opqdonut> det: you're thinking about wrong things, objects and methods
12:09:45 <det> I am talking in the wrong channel
12:09:50 <opqdonut> heh :)
12:09:53 <tommd> I was thinking that was the case "object"
12:09:54 <dons> oh my
12:10:14 <det> #haskell and #csharp are right next to each other in my channel list :<
12:10:30 <tommd> It would get old too fast, but it's tempting to have a lambdabot auto-response when people say "object".
12:10:32 <opqdonut> "the channels, they're like right next to each other"
12:11:01 <dons> heh
12:11:53 <tommd> @quote object
12:11:54 <lambdabot> ghc says: internal error: Invalid object in processHeapClosureForDead
12:12:00 <tommd> @quote object
12:12:00 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
12:12:00 <lambdabot>  but then I look at some java code and I'm all happy again
12:12:40 <tommd> Por paczesiowa.
12:12:44 <tommd> s/Por/Poor
12:17:51 <dons> heh
12:18:26 <Rotaerk> does anyone here actually have a job for which they code in haskell?
12:18:32 <tommd> Yep
12:18:34 <Rotaerk> don't think I've ever seen a job description including haskell
12:18:51 <tommd> There are several Galois folks here, some financial, and a few others (any Eaton people in here?)
12:18:52 <dons> yes.
12:19:13 <dons> you must not read the mailing lists, Rotaerk ?
12:19:22 <Rotaerk> nope
12:19:28 <Rotaerk> I'm bad at mailing lists
12:19:28 <Tobsan> :-)
12:19:30 <dons> there was heavy recruiting happening at ICFP, for example.
12:19:37 <dons> http://haskell.org/haskellwiki/Haskell_in_industry from these guys
12:19:39 <FunctorSalad> that all the examples are known isn't very encouraging though :(
12:19:54 <dons> no, there are secret orgs that don't publicise.
12:19:54 <FunctorSalad> (don't get me wrong, I'd love for haskell jobs to be more widespread)
12:19:55 <tommd> And academics, of coarse.  That is a job too, even if it involves lower pay and more time-off/flexibility than you usually think of in a job.
12:20:22 <Rotaerk> tommd, nope, that's just the delusion that academics have
12:20:39 <FunctorSalad> which part?
12:20:46 <Rotaerk> that it's a real job
12:20:48 <tommd> Rotaerk: If you don't want to consider broader job markets then feel free.
12:20:51 <Rotaerk> *cough*
12:20:59 <tommd> Work for pay, it fits my definition.
12:21:04 <FunctorSalad> yes
12:21:25 <copumpkin> tommd: very coarse academics indeed!
12:21:43 <FunctorSalad> moar!
12:21:51 <tommd> Yes, I always do that.  I blame my fingers for typing it wrong, but I know the problem is in my head :-(
12:22:12 <copumpkin> moar coarse academics!
12:22:24 <tommd> Its quite abrasive, really!
12:26:09 <randomwords> I have some code of type :: Double -> Color3 GLdouble which basically reads "col = fmap realToFrac $ Color3 r g b". After the latest OpenGL update it runs several orders of magnitude slowers. The culprit seem to be the realToFrac conversion from Double to GLDouble. Any ideas how I can resolve this?
12:26:16 <m4ik3ru> So I talked to the prof about the last assignment y'all helped me with, the "fake" parser.
12:26:25 <m4ik3ru> It was a whole bunch of conditionals.
12:26:52 <m4ik3ru> Like, isValid s = condition1 & condition2 & ... where condition1 s = ...
12:26:54 <m4ik3ru> So on.
12:27:11 <m4ik3ru> But now we're writing an actual lexer for the Clite language.
12:27:16 <m4ik3ru> And we have ten days.
12:27:21 <m4ik3ru> But we get to work in groups.
12:27:25 <jagwire> Hey guys, I have a question for you
12:27:28 <m4ik3ru> I. Can't. Wait. :)
12:27:46 <jagwire> What is the difference between the cons ':' operator and the append '++' operator?
12:27:56 <tommd> M4ik3ru: Did he specify a library you could or should use?  Parsec or some such?
12:28:04 <Zao> jagwire: The types involved.
12:28:12 <tommd> jagwire: connecting lists verse just a single element and a list
12:28:20 <tommd> > 1 : [2,3,4]
12:28:20 <randomwords> jagwire: The type. Cons appends an element to a list. Append joins two lists.
12:28:20 <lambdabot>   [1,2,3,4]
12:28:21 <Zao> @type (++)
12:28:21 <lambdabot> forall a. [a] -> [a] -> [a]
12:28:22 <Zao> @type (:)
12:28:23 <lambdabot> forall a. a -> [a] -> [a]
12:28:27 <tommd> > [1, 2] ++ [3,4]
12:28:28 <lambdabot>   [1,2,3,4]
12:28:28 <jagwire> aha!
12:28:47 <jagwire> well shoot, I was just overcomplicating things
12:28:50 <jagwire> many thanks!
12:29:11 <m4ik3ru> tommd: we can't use libraries, we have to write it from scratch
12:29:23 <m4ik3ru> tommd: no parsing libraries at least.
12:29:41 <burp> :t (:)
12:29:41 <tommd> randomwords: To "answer" your question - I'd e-mail the maintainer or file a bug report.
12:29:42 <lambdabot> forall a. a -> [a] -> [a]
12:29:49 <m4ik3ru> tommd: it would be ridiculous to think we couldn't use ANY libraries, sorry for the unqualified stament there :)
12:30:17 <randomwords> tommd: Oh sure I will, just wanted to see if it was an issue people were aware of first. A little googling turned up nothing
12:30:24 <tommd> m4ik3ru: I understood.  Unlike true programming language folks I don't tend to follow the exact wording too carefully.
12:31:40 <m4ik3ru> tommd: i guess that fact that i do it incessantly with english helps me with programming :D
12:34:35 <m4ik3ru> just looked at the files we were given, we have a fairly useful skeleton as far as knowing what we have to write
12:34:40 <m4ik3ru> not we just have to write it...
12:42:24 <m4ik3ru> :t elem
12:42:24 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:42:49 <mrsolo> @type liftM2
12:42:49 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:43:01 <mrsolo> @type liftM2 id
12:43:02 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
12:43:05 <mrsolo> why?
12:49:52 <mrsolo> rather how does haskell derives the type signature of liftM2 id?
12:49:59 <m4ik3ru> scanl1 (+) [1,3..10]
12:50:03 <m4ik3ru> > scanl1 (+) [1,3..10]
12:50:04 <lambdabot>   [1,4,9,16,25]
12:50:11 <m4ik3ru> heh :)
12:50:15 <m4ik3ru> still makes me smile
12:50:21 <m4ik3ru> i enjoy haskell immensely.
12:51:53 <tommd> m4ik3ru: What University?
12:52:54 <skorpan> 23:52 *** 314 m4ik3ru n=m4ik3ru OOC-5N6PJG1.TAMU.EDU * Mikey
12:53:09 <skorpan> texas a&m university it seems
12:57:17 <dm`> Does anyone know how to report bugs in the system libraries?  I get bounced when I try to email libraries@haskell.org.
12:57:49 <tommd> dm`: I think you must be subscribed to send email to l@h.o
12:57:59 <tommd> dm`: But the trac should be fine.
12:58:14 <tommd> dm`: GHC trac if there isn't a separate one for libraries.
13:00:51 <dm`> Hmm... Maybe I should just subscribe to the list, as I'm interested in seeing a few things improved if people are willing to accept changes.  GHC is the right place to report bugs in, say Network.Socket?
13:06:03 <tommd> dm`: No, network has its own trac somewhere.  I always forget where
13:06:06 <tommd> @where network
13:06:06 <lambdabot> I know nothing about network.
13:06:31 <tommd> @where+ network http://trac.haskell.org/network/
13:06:31 <lambdabot> Done.
13:06:37 <tommd> there
13:07:26 <tommd> dm`: What bug?  I might get to it at the Hackathon.
13:12:40 <dons> on projects.haskell.org i think
13:12:51 <dm`> Can't connect a bound socket.  Yet this is something you need to do all the time, either to get a reserved port number in TCP, or with UDP in order to get feedback from ICMP port unreachable messages.
13:16:51 <dons> dm`: something funny about your network/os/distro
13:17:41 <dm`> No, very simple fix needed in Network.Socket.
13:18:16 <dm`> connect sock@(MkSocket s _family _stype _protocol socketStatus) addr = do
13:18:16 <dm`>  ...
13:18:16 <dm`>  if currentStatus /= NotConnected
13:18:16 <dm`>  
13:18:52 <dm`> Should be if not NotConnected and not Bound
13:20:04 <dm`> http://hackage.haskell.org/packages/archive/network/2.2.1.3/doc/html/src/Network-Socket.html#connect
13:36:36 <Gracenotes> ugh. is there an Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c?
13:37:28 <Gracenotes> well, particularly, to be used for Ord k => Map k a -> Map k a -> Map k (a, a)
13:37:57 <Gracenotes> oh, wait, it's intersections I'm looking for. not unions
13:38:02 <Gracenotes> never mind :D
13:55:37 <dons> there's a good FFI tutorial to be written on binding to libs that primarily use macros for their interface
13:59:14 <randomwords> I have some code of type :: Double -> Color3 GLdouble which basically reads "col = fmap realToFrac $ Color3 r g b". After the latest OpenGL update it runs several orders of magnitude slowers. The culprit seem to be the realToFrac conversion from Double to GLDouble. Any ideas how I can resolve this? (Sorry to spam, I'm hoping someone has seen this)
14:02:37 <benmachine> interesting that you should say that
14:02:51 <benmachine> I haven't been able to compile Frag because GLfloat is not matching Float
14:03:08 <benmachine> I guess they used to be a type synonym and now are different
14:04:09 <benmachine> that's just my guess though
14:04:17 <benmachine> randomwords: does that sound like it might be possible?
14:06:26 <sciolizer__> setUncaughtExceptionHandler has been moved to Control.OldException. Is there any replacement for it in the new exception library?
14:33:58 <Alpounet> pas
14:38:49 <randomwords> benmachine: Yes - I believe it was 2.3.0.0 that broke the compatability between Float/GLFloat
14:38:59 <randomwords> this is a separate issue though
14:39:04 <benmachine> oh okay
14:39:34 <randomwords> the reccomended (I believe) way to fix that is to call realToFrac f :: GLflaot
14:40:28 <randomwords> but now in 2.4.0.1 This process is much slower than it used to be - I believe it's to do with the newtypes in OpenGLRaw 1.1.0.0. But I've already spent more time looking into this than I would like
14:41:20 <randomwords> Fixing frag should be a case of changing the cabal file to put an upper bound on the version of OpenGL (and possibly glut). < 2.3.0.0 should do it
14:44:46 <tommd1> HacPDX has kicked off (a bit early).  The room is ours!
14:46:04 <hackagebot> checkers 0.2.2 - Check properties on standard classes and data structures. (ConalElliott)
14:46:21 <tommd1> The question is: did SyntaxNinja leave to come to HacPDX.
14:46:40 <dons> he just got up from his desk.
14:46:51 <dons> crazy day here, so he might be chillin' on a bike ride.
14:47:24 <TomMD> I wonder what qualifies as a crazy day.  Perhaps I'll hear about it another time.
14:48:37 * dons looks over the HsJudy code with a small degree of horror
14:48:56 <dons> TomMD: well, you'll have to send in your resume to find out :)
14:49:14 <dons> what time are we starting tomorrow?
14:53:48 <TomMD> dons: I intend to be here around 9:00 and we officially start 10:00
14:54:06 <TomMD> If you want to show at 9:00 then just say and I'll be _sure_ to be here by then.
14:54:52 <FunctorSalad> how do you begin to understand the code for a beast like yi?
14:55:23 <FunctorSalad> (the big picture)
14:55:26 <randomwords> haruspicy
14:55:36 <FunctorSalad> it doesn't load in ghci so I can't go-to-definition :(
14:55:37 <randomwords> You'll need 1 goat
14:56:14 <FunctorSalad> the "graphmod" too had already helped, btw
14:56:15 <dons> TomMD: 9.30 to 10 is about when i'll be there.
14:56:21 <FunctorSalad> (makes a module dependency graph)
14:56:30 <dons> TomMD: with help, advice, and otherwise hacking on judy bindings.
14:56:30 <randomwords> FunctorSalad: Perhaps using an Ide such as leksah might make it slightly easier
14:56:43 <FunctorSalad> s/too/tool/
15:01:23 <FunctorSalad> oooh they thought of everything. the makefile has a target "interactive"
15:03:10 <hackagebot> hfractal 0.3.2.1 - OpenGL fractal renderer (ChrisHoldsworth)
15:08:28 <jaredj> i parsed an sgml document into a tagsoup, then made the tagsoup into a tree of tags and strings. is it worth parsing my tree using parsec, or should i just parse it myself and keep my own state?
15:09:54 <altmattr> jaredj: get whatever program is doing all the parsing to output it in haskell syntax
15:10:00 <altmattr> then just read it in
15:26:04 <merijn> Do I always have to store the result of getLine into a name before I can use it? I find myself constantly doing "foo <- getLine; let bar = read foo" which clutters up my code.
15:26:35 <benmachine> you definitely don't
15:26:37 <ivanm> @hoogle readLine
15:26:37 <lambdabot> Network.Stream readLine :: Stream x => x -> IO (Result String)
15:26:37 <lambdabot> Network.TCP readLine :: HStream bufType => HandleStream bufType -> IO (Result bufType)
15:26:37 <lambdabot> module System.Console.Editline.Readline
15:26:42 <ivanm> @hoogle liftM
15:26:42 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
15:26:43 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:26:43 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:26:46 <ivanm> @hoogle fmap
15:26:46 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
15:26:46 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
15:26:46 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
15:26:47 <benmachine> there are a lot of ways of doing what you ask though
15:27:22 <benmachine> the fmap function, as ivanm has pointed out, allows you to apply a function over the value returned by an IO action
15:27:39 <benmachine> so fmap read getLine is an IO action that gets a line and then reads it
15:27:51 <benmachine> I believe there is a readLn or some such which does a similar thing
15:32:03 <Alpounet> liftM read getLine wouldn't work ?
15:32:19 <FunctorSalad> it would
15:32:21 <merijn> Well, there seems to be 2 readlines for console, but they seem to require and extra library. fmap works, but doesn't win the beauty award
15:32:34 <ivanm> benmachine: look at the first function I @hoogle'd
15:32:51 <merijn> Not sure whether Network.Stream/Network.TCP would work for stdin, trying that now
15:32:54 <benmachine> @type readLn
15:32:55 <lambdabot> forall a. (Read a) => IO a
15:33:07 <ivanm> benmachine: oh, I did the wrong one :s
15:33:12 <benmachine> yup :)
15:33:16 <ivanm> Alpounet: for monads, fmap = liftM
15:33:18 <benmachine> you did the logical one to be fair
15:33:31 <ivanm> @slap function names
15:33:31 * lambdabot moulds function names into a delicous cookie, and places it in her oven
15:33:41 <benmachine> I only found out it was called that by typing System.IO.<tab>
15:33:41 <ivanm> mmmmm..... cookie....
15:33:46 <ivanm> heh
15:33:50 <Alpounet> ivanm, yeah
15:34:00 <ivanm> realistically, readLn is usually bad for big programs though
15:34:08 <ivanm> since it throws an error if it can't be read
15:34:18 <benmachine> yeah I guess so
15:34:19 <merijn> Ah, yeah readLn is exactly what I was looking for, knew there had to be something simple
15:34:29 * benmachine had never written anything that could reasonably be called a big program
15:34:49 <benmachine> merijn: usually I'd just do fmap read getLine, less to remember
15:34:58 <benmachine> (or read <$> getLine, but that's just me)
15:35:09 <merijn> Realistically I don't intend for my first 3 days of Haskell to be about large programs and more trivial reading stuff in and printing stuff out :p
15:35:16 <exlevan> why not just getLine >>= read ?
15:35:26 <benmachine> because read doesn't return a monad
15:35:27 <FunctorSalad> getLine >>= return.read
15:35:34 <benmachine> you could do getLine >>= return . read
15:35:37 <copumpkin> readLn
15:35:39 <benmachine> but that is basically just liftM
15:35:43 <benmachine> which is the same as fmap
15:35:45 <copumpkin> :t readLn
15:35:46 <lambdabot> forall a. (Read a) => IO a
15:35:47 <merijn> Anyhoo, thanks ivanm/benmachine
15:35:51 <benmachine> copumpkin: been there :P
15:35:56 <FunctorSalad> but it has the advantage that you can chain it with further >>=
15:36:05 <FunctorSalad> (without parens0
15:36:06 <FunctorSalad> )
15:36:12 <benmachine> FunctorSalad: you can do that with liftM/fmap too
15:36:22 <benmachine> I'd demonstrate but lambdabot doesn't do IO
15:36:26 <benmachine> well
15:36:27 <copumpkin> you can still get types
15:36:29 <FunctorSalad> without parentheses?
15:36:35 <benmachine> :t fmap read getLine >>= putStrLn
15:36:36 <lambdabot> IO ()
15:36:46 <benmachine> er wait
15:36:48 <benmachine> that is silly
15:36:51 <copumpkin> :t readFile <=< readFile
15:36:52 <lambdabot> FilePath -> IO String
15:36:56 <FunctorSalad> hehe
15:36:56 <benmachine> :t fmap read getLine >>= print . (+3)
15:36:57 <lambdabot> IO ()
15:36:59 <benmachine> that is more sensible
15:37:09 <benmachine> (relies on type-defaulting though, so still a little silly)
15:37:16 <copumpkin> :t readFile <=< readFile <=< readFile
15:37:16 <lambdabot> FilePath -> IO String
15:37:17 * maltem is delighted by further looks at MonadPrompt... But, do people have any ideas how to handle all those runAinB functions that arise naturally? I don't see a good way to, say, stuff them into a typeclass
15:37:19 <FunctorSalad> print . (+3) =<< fmap read getLine
15:37:30 <FunctorSalad> (slightly less evil)
15:37:49 <benmachine> copumpkin: is that a bit like symlinks?
15:37:51 <FunctorSalad> (at least write function composition the wrong way consistently ;))
15:37:53 <skorpan> i just can't realy =<<...
15:37:55 <copumpkin> benmachine: I guess :P
15:37:55 <ddarius> benmachine: Your first function would unescape a string.
15:37:55 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
15:38:07 <ivanm> maltem: what's MonadPrompt? a monad for console interaction?
15:38:07 <benmachine> ddarius: yeah
15:38:19 <benmachine> valid, but silly
15:38:25 <benmachine> unless you want strings unescaped I guess
15:38:28 <skorpan> uh, s/realy/read/
15:38:31 <dm`> What's runAinB?
15:38:44 <benmachine> skorpan: I read it a bit like function application
15:38:54 <skorpan> benmachine: i know, but i just can't get used to it
15:39:07 <benmachine> like, if foo is a string and bar is return foo, putStrLn foo is putStrLn =<< bar
15:39:12 <benmachine> oh
15:39:16 <benmachine> well I sympathise
15:39:18 <skorpan> :)
15:39:22 <benmachine> just One Of Those Things I suppose
15:39:23 <maltem> ivanm, no, the basic idea is "I want to have a monad that can do the following things" and Prompt gives you a return and a bind
15:39:36 <ivanm> OK...
15:39:43 <ddarius> skorpan: Read it as application and/or lifting.
15:40:31 <maltem> often you write some run* function
15:40:58 <maltem> but I'm getting the impression that, if you peruse this, you'll have loads of run* functions
15:42:11 <maltem> s/peruse/slightly abuse/
15:42:36 <ivanm> only slightly abuse?
15:43:28 <maltem> I'm not sure, examples for MonadPrompt are mostly just a couple of lines
15:43:32 <maltem> not telling much
15:45:44 <aavogt> @hoogle copyFile
15:45:44 <lambdabot> System.Directory copyFile :: FilePath -> FilePath -> IO ()
15:45:51 <aavogt> @hoogle copyDirectory
15:45:51 <lambdabot> No results found
15:46:13 * aavogt is struggling to write a portable "cp -r"
15:46:26 <aavogt> I suppose it is possible
15:48:04 <ivanm> aavogt: make the new directory, then recursively copy the files or make a new directory
15:48:44 <aavogt> ivanm: yeah, it's tricky if the recursion is done in IO
15:49:11 <ivanm> aavogt: have a FilePath -> IO () function
15:49:23 <ivanm> for directory filepaths
15:50:09 <ivanm> then you getDirectoryContents, filter out . and .., then filterM on isDirectory
15:50:17 <ivanm> (maybe write a partitionM if there isn't already one)
15:50:54 <ivanm> then a mapM_ copyFile on the files, and mapM_ the function you've written on the directories
15:51:04 <ivanm> aavogt: the tricky thing is what to do with symlinks, etc.
15:59:20 <dm`> @hoogle MonadReader
15:59:20 <lambdabot> No results found
15:59:28 <aavogt> @hoogle eithers
15:59:28 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
16:09:08 <aavogt> ivanm: this is what I came up with: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9847#a9847
16:15:00 <aavogt> what was your comment about symlinks? I'm not sure how I can detect them with the FilePath api
16:15:04 <aavogt> ivanm: ^^
16:15:06 <djanatyn> Hello :)
16:15:16 <ivanm> aavogt: hang on a minute! ;-)
16:16:56 <ivanm> aavogt: I would have done it a level at a time
16:17:03 <ivanm> rather than trying to recurse directly
16:17:19 <ivanm> that avoids getting too big a file list to play with + avoiding concatenation
16:17:53 <ivanm> and then recurse on cpr
16:18:59 <aavogt> ivanm: but I can address those by using unsafeInterleaveIO, and a dlist or ReadS style concatentation?
16:19:27 <ivanm> why would you want to use unsafe anything?
16:19:40 <PetRat> @unmtl StateT [a] [] a
16:19:40 <lambdabot> [a] -> [(a, [a])]
16:19:46 * Alpounet about to install arch
16:19:52 <benmachine> woo arch
16:19:57 <PetRat> @unmtl StateT b [] a
16:19:57 <lambdabot> b -> [(a, b)]
16:20:00 <aavogt> because I don't care about when the IO gets run to find the tree?
16:20:08 <PetRat> @unmtl State b a
16:20:08 <lambdabot> b -> (a, b)
16:20:11 <aavogt> it does get run eventually
16:20:39 <ivanm> benmachine: s/w/b/ :p
16:20:42 <ivanm> j/k
16:20:47 <benmachine> heh
16:20:54 <ivanm> aavogt: *shrug* do it how you want, I just said how _I_ would do it
16:21:20 <PetRat> So when transforming the list monad with StateT, the list monad is considered the "inner monad", but the type is s -> [(s,a)] which looks a little like the list monad is the "outer" monad.
16:21:28 <djanatyn> Heh. I just started learning Haskell on Arch.
16:21:38 <djanatyn> I'm reading "Learn You A Haskell For Great Good!"
16:21:42 <benmachine> I read that
16:21:44 <benmachine> it's pretty good
16:21:53 <benmachine> except that it's quite a while before you write an actual program
16:21:56 <benmachine> if I recall correctly
16:21:58 <djanatyn> I noticed that.
16:22:04 <ivanm> *shudder*
16:22:11 <aavogt> @unmtl StateT () [] String
16:22:11 <lambdabot> () -> [(String, ())]
16:22:20 <ivanm> just the title of that thing offends my language sensibilities
16:22:25 <aavogt> @unmtl StateT Int [] String
16:22:25 <lambdabot> Int -> [(String, Int)]
16:22:36 <djanatyn> Heh.
16:22:43 <djanatyn> I find it quite amusing :D
16:22:58 <PetRat> Oh, s -> [(a,s)]
16:23:39 <Berengal> I love pure functions...
16:23:41 <djanatyn> I started out trying to figure out how to mess with xmonad, and fell in love with Haskell's syntax.
16:23:55 * Berengal hugs referential transparency
16:24:46 <ivanm> @remember djanatyn I started out trying to figure out how to mess with xmonad, and fell in love with Haskell's syntax.
16:24:46 <lambdabot> Good to know.
16:24:48 <PetRat> Is this a good way to think of the list monad: I think of it as making multiple passes, or perhaps more like the branches of a tree. For each list encountered in a do statement, the program will branch out and make multiple passes down the rest of the do statement.
16:25:11 <ivanm> Berengal: as we all do, but any particular reason for mentioning it explicitly now?
16:25:24 <ivanm> PetRat: kinda
16:25:52 <Berengal> ivanm, not really, I just can't get over how awesome it is. I feel like instituting a holiday or something...
16:25:57 <ivanm> for-each element in the list, do everything after it for that element, and then concat them together
16:26:00 <ivanm> Berengal: heh
16:26:11 <aavogt> PetRat: that's how I think of it
16:26:15 <FunctorSalad> Referential transparency celebration day?
16:26:30 <ivanm> @remember Berengal I just can't get over how awesome it [referential transparency] is. I feel like instituting a holiday or something...
16:26:31 <lambdabot> It is forever etched in my memory.
16:26:44 <sereven> ivanm: http://translationparty.com/#4457199
16:26:47 <ivanm> we don't want jfredett to complain there aren't enough quotes after all :p
16:26:55 <Berengal> Between strong typing and purity, about 95% of all pure modules I write are bug-free the first time they compile
16:26:59 <ivanm> sereven: heh
16:27:02 <deech> I've been reading Haskell code and "error" is used a fair amount to signal error conditions. Is this good practice?
16:27:04 <ivanm> I quite like translation party
16:27:23 <ivanm> I tried a phrase that is not quite SFW, and it turned into a huge mess of obsceneties...
16:27:25 <benmachine> deech: if you know "assert" from other languages, error is a bit like that
16:27:42 <benmachine> deech: it should be reserved for conditions that indicate a programmer mistake
16:27:46 <ivanm> "Please. I love xmonad start of work. Ruined."
16:27:55 <FunctorSalad> deech: it's not good because you can't catch it in pure code (only in IO)
16:28:07 <ivanm> deech: only for stop-the-world errors
16:28:11 <FunctorSalad> and you are not warned of the possiblity of error by the type signature
16:28:15 <ivanm> as it automatically kills the programming
16:28:20 <ivanm> s/ming//
16:28:28 <ivanm> @src undefined
16:28:29 <lambdabot> undefined =  error "Prelude.undefined"
16:28:29 <benmachine> ivanm: well, you can catch them these days I think
16:28:36 <ivanm> benmachine: in IO, yeah
16:29:00 <ivanm> but usually you should write your code such that you don't _want_ to recover from errors (mainly because you should ensure you never reach one...)
16:29:01 <deech> FunctorSalad: yeah, that's what I thought. So I shouldn't generally need it for production code, correct?
16:29:12 <ivanm> deech: correct
16:29:31 <ivanm> wrap possible error values in a Maybe or something
16:30:00 <deech> ivanm: Cool, so I'm using Control.Exception and it's keeping me in the IO monad a lot.
16:30:19 <FunctorSalad> you could use MonadError
16:30:35 <Berengal> deech, take a look at MonadError, or just use Either or Maybe instead.
16:30:36 <benmachine> yeah, there are a lot of options which aren't so restrictive
16:30:45 <ivanm> @hoogle MonadError
16:30:46 <lambdabot> No results found
16:30:48 <ivanm> ...
16:31:15 <Gracenotes> @type MonadError
16:31:16 <lambdabot> Not in scope: data constructor `MonadError'
16:31:17 <Berengal> ... at least I think it was called that...
16:31:25 <FunctorSalad> @docs MonadError
16:31:25 <lambdabot> MonadError not available
16:31:26 * Berengal tends to simply use Maybe instead
16:31:30 <Gracenotes> class (Monad m) => MonadError e m | m -> e where
16:31:32 <Gracenotes>   throwError :: forall a. e -> m a
16:31:34 <Gracenotes>   catchError :: forall a. m a -> (e -> m a) -> m a
16:31:41 <FunctorSalad> failmonad
16:31:46 <benmachine> @instances-importing Control.Monad.Error MonadError
16:31:46 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
16:31:58 <deech> FunctorSalad: So for example, you do a database query and no result is returned. You want to signal an error, so since I'm in the IO Monad is Control.Exception your only option?
16:32:28 <dm`> deech:  What do you mean keeping you in the IO monad slot?
16:32:50 <dm`> Recently I implemente a library that allows you to wrap computations in one monad from within another monad.
16:33:07 <dm`> It allows you to use functions like catch and finally from within transformed versions of the IO monad.
16:33:12 <Berengal> dm`, you mean monad transformers?
16:33:26 <ivanm> benmachine: so MonadError is a class with monads where fail doesn't use error?
16:33:37 <benmachine> ivanm: um, pass
16:33:39 <benmachine> never used it
16:33:41 <ivanm> heh
16:33:42 <dm`> Yes, I made it work with all of the mtl transformers except for ContT, and just supplied a replacement for contT.
16:33:49 <Berengal> ivanm, not neccessarily.
16:33:56 <ivanm> *nod*
16:34:03 <benmachine> aww my quotes aren't in lambdabot anymore
16:34:10 <benmachine> I had two and I liked them :(
16:34:14 <Berengal> ivanm, though fail being anything different than throwError is, well, phail
16:34:15 <FunctorSalad> ivanm: "Either String" is sort-of the standard example
16:34:18 <FunctorSalad> (for MonadError)
16:34:34 <ivanm> yup
16:34:43 * Berengal wants fail out of Monad
16:34:43 <FunctorSalad> (err, for MonadError String)
16:34:55 <copumpkin> Berengal: fail = fail
16:35:07 * benmachine agrees with Berengal 
16:35:24 <Berengal> No refutable patterns in do-notation, except for FailMonads
16:35:25 <FunctorSalad> deech: of course you could also return something like IO (Maybe Foo)
16:35:46 <FunctorSalad> deech: but if your outer monad has to be IO then obviously it can't be some other error-handling monad ;)
16:36:05 <Berengal> class (Monad m) => FailMonad m where fail :: String -> m a
16:36:16 <Gracenotes> Berengal: er. or non-exhaustive pattern somelike
16:36:26 <FunctorSalad> Berengal: sounds like failboat or something
16:36:36 <copumpkin> failboat is sailing
16:36:49 <Berengal> Gracenotes, patterns don't fall through in do-notation.
16:37:07 <Gracenotes> wha
16:37:16 <dm`> BTW, I found this page enlightening on error handling:  http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
16:37:42 <Gracenotes> they wall through in do notation in much the same way they'd fall through in a lambda
16:37:46 <Gracenotes> fall
16:37:56 <Berengal> @undo do {Just x <- lookup 5 []; [x]}
16:37:56 <lambdabot> lookup 5 [] >>= \ a -> case a of { Just x -> [x]; _ -> fail ""}
16:38:16 <PetRat> What does "determinism" and "nondeterminism" mean and how is this related to the list monad?
16:38:40 <Berengal> Gracenotes, they don't fall through in lambdas either, they raise an error
16:39:19 <Gracenotes> Berengal: similarly, (\(Just x) -> x) is, \y -> (case a of { Just x -> 4; _ -> throw "Non-exhaustive patterns in lambda" })
16:39:26 <Gracenotes> s/y/a/
16:39:34 <FunctorSalad> PetRat: in the context of automata or turing-machines or complexity classes, non-determinism means that the machine transitions from one state to a set of states
16:39:48 <FunctorSalad> much like a program in the list monad, actually
16:40:17 <Berengal> Gracenotes, to me, that's not fallthrough, that's fail
16:40:22 <Gracenotes> I'm talking hypothetically, if MonadFail was a typeclass, then non-exhaustive patterns in a non-MonadFail monad should behave similarly to lambdas
16:40:36 <FunctorSalad> (usually these machines have to decide yes/no problems, and a non-deterministic machine is defined to answer yes if at least one "yes" state is reached eventually)
16:41:38 <Berengal> Gracenotes, I disagree. Firstly, you can't really exhaust patterns, because you only get the one. Secondly, I want failures to only be allowed in monads that allow for failures
16:42:30 * FunctorSalad never uses do-patterns which don't always succeed
16:42:48 <Berengal> Besides, it's refutable patterns that cause fail, which is why they should be banned. Irrefutable patterns are "fine" (except for the whole throwing exceptions later part, which is programmer phail)
16:42:55 <PetRat> FunctorSalad: thanks.
16:43:19 <Berengal> FunctorSalad, they're quite handy in e.g. Maybe or []
16:43:21 <Gracenotes> I forget, what's the distinction between refutable and not?
16:43:28 <Berengal> Gracenotes, ~
16:43:41 <FunctorSalad> Berengal: refutable patterns cause fail?? e.g. in a case statement?
16:44:03 <Berengal> @undo do {Just x <- lookup 5 []; [x]} --  FunctorSalad
16:44:03 <lambdabot> lookup 5 [] >>= \ a -> case a of { Just x -> [x]; _ -> fail ""}
16:44:12 <Berengal> @undo do {~(Just x) <- lookup 5 []; [x]}
16:44:13 <lambdabot> lookup 5 [] >>= \ ~(Just x) -> [x]
16:44:20 <dons> Cale: fwiw, my judy hashtable bindings do the 10M inserts test in 2.16s, versus 48s for Data.HashTable
16:44:28 <FunctorSalad> isn't that an irrefutable pattern, Berengal?
16:44:30 <Saizan_> (a,b) is not a refutable pattern either
16:44:39 <Berengal> FunctorSalad, the last one is, the first one isn't
16:45:10 <Berengal> Saizan_, it might be bottom... pattern matching semantics and all
16:45:45 <Saizan_> Berengal: right, but you don't get to pattern match against bottom, so you can't use fail in that case anyway
16:45:47 <FunctorSalad> hmm I thought both are considered irrefutable
16:46:29 <Saizan_> though ~(a,b) is lazier
16:46:45 <FunctorSalad> @undo \x -> do { return (case x of { Just _ -> 1 }) }
16:46:45 <lambdabot> \ x -> return (case x of { Just _ -> 1})
16:46:56 <FunctorSalad> phew I was afraid you were saying that *that* can call fail
16:47:15 <Berengal> Saizan_, true, you don't get to match against bottom, but you get to match against (a,b), which can be "refuted" in case the value matched is bottom. ~(a,b) is irrefutable, even in the face of bottoms
16:47:21 <FunctorSalad> (that would be weird)
16:47:29 <Berengal> (Of course, it may fail later when you try to look at a or b)
16:47:40 <Saizan_> @undo do (a,b) <- foo; return a
16:47:40 <lambdabot> foo >>= \ (a, b) -> return a
16:48:43 <Saizan_> Berengal: i don't think that's an useful definition of refutable, but i get what you're saying :)
16:48:45 <FunctorSalad> doesn't this fail thing violate principle of least surprise?
16:49:00 <FunctorSalad> you expect pattern matches to fail with error
16:49:25 <FunctorSalad> but anyway :)
16:50:06 <Saizan_> i mostly use list comprehensions for that behaviour
16:50:07 <Berengal> FunctorSalad, I expect failed computations to call fail... and I don't expect every monad to be failable
16:50:45 <FunctorSalad> Berengal: well, that behaviour is the reason "fail" is in Monad in the first place
16:50:47 <Berengal> (But nobody expects the spanish inquisition, which is why so few languages implement them at all)
16:52:19 <Berengal> FunctorSalad, yes, but it doesn't have to be. It could just as well be in a FailMonad
16:53:44 <Berengal> I've rewritten the Monad class with fail in it's own FailMonad class (using NoImplicitPrelude), and it works. Functions with refutable patterns have a FailMonad constraint, those without don't
16:53:53 <copumpkin> MonadFail
16:54:33 <copumpkin> Berengal: I think it all happened to simplify errors and make it "easy for beginners", along with monad comprehension removal and various other concretizing of polymorphic things
16:54:44 <copumpkin> Berengal: but I wish they'd take that all back
16:54:51 <Saizan_> Berengal: does do (a,b) <- ..; .. have a FailMonad constraint in that settings ?
16:55:20 <FunctorSalad> special cases aren't easy for beginners :)
16:56:05 <Berengal> Saizan_, well, it doesn't desugar to case x of _ -> fail, so no, but as you said, the definition of irrefutable I used there is pretty useless and doesn't have anything to do with this really
16:56:14 <Berengal> (I was just going by the definition of ~ in patterns)
16:56:54 <Berengal> If (a,b) <- ..; fails, it fails with error
16:57:00 <Saizan_> Berengal: i was just curious about ghc's actual desugaring :)
16:57:16 <aavogt> @undo do (a,Nothing) <- [(1,Just 1),(2,Nothing]; return a
16:57:16 <lambdabot> Unbalanced parentheses
16:57:21 <aavogt> @undo do (a,Nothing) <- [(1,Just 1),(2,Nothing)]; return a
16:57:21 <lambdabot> [(1, Just 1), (2, Nothing)] >>= \ b -> case b of { (a, Nothing) -> return a; _ -> fail ""}
16:57:56 <aavogt> Berengal: so undo is different from the actual translation sometimes?
16:58:16 <Berengal> aavogt, how is this different?
16:58:17 <benmachine> I thought the idea was that (a, b) <- foo can't fail because tuples only have one constructor
16:58:30 <Berengal> aavogt, you're matching against Nothing, not just (a, b)
16:59:00 <aavogt> @undo do Just a <- [Just 1,Nothing]; return a
16:59:00 <lambdabot> [Just 1, Nothing] >>= \ b -> case b of { Just a -> return a; _ -> fail ""}
16:59:01 <benmachine> and hence there are irrefutable patterns, which are lazy patterns, and then there are patterns that are guaranteed by the type system to match
16:59:08 <benmachine> and they are entirely different things
16:59:48 <Berengal> Indeed, exhaustive patterns and irrefutable patterns are different
17:00:09 <benmachine> but there are some cases where a single pattern is exhaustive all on its own
17:00:20 <benmachine> and those are the ones for which you definitely won't need fail
17:01:00 <benmachine> every other kind of pattern is eminently failable and should only be allowed when there is a MonadZero or something
17:01:32 <benmachine> (I think if fail is in a separate class there is no need for String to be involved)
17:01:46 <benmachine> (er, whether or not fail is in a separate class)
17:01:49 <dobblego> what's a good trivial example of using Cont?
17:02:40 <dolio> Saizan_: If you make 'data Pair a b = P a b', though, 'do P a b <- m ; return a' has a Fail constraint. So apparently it only desugars smartly for built-in tuples.
17:02:44 <Saizan_> dobblego: aborting a computation at some point?
17:03:07 <dobblego> Saizan_, ah yeah, so something like 1/0?
17:03:30 <FunctorSalad> > (1/fail "hello")
17:03:30 <lambdabot>   No instance for (GHC.Real.Fractional (m a))
17:03:30 <lambdabot>    arising from a use of `GHC.R...
17:03:49 <Saizan_> dobblego: or a product where a term is 0
17:03:59 <Saizan_> dolio: that's a shame
17:04:52 <Saizan_> benmachine: the source location is quite handy, e.g. in IO
17:05:47 <TomMD> Is mightybyte on here ever?
17:06:01 <Saizan_> sometimes
17:06:09 <aavogt> more in #happs
17:06:11 <benmachine> Saizan_: for this purpose I recommend the application of magic
17:06:30 <benmachine> *or* some generalised debugging annotation system for calls to error
17:06:33 <benmachine> that would also be nice
17:06:40 <Berengal> > let division x y = if y == 0 then Cont (\r -> "Division by zero") else return (div x y) in runCont (division 8 0) show
17:06:41 <lambdabot>   "Division by zero"
17:07:10 <Saizan_> benmachine: the IO monad is MonadPlus
17:07:23 <benmachine> is it?
17:07:31 <benmachine> does foo >>= mzero hold?
17:07:34 <benmachine> er
17:07:41 <benmachine> foo >>= mzero = mzero
17:07:42 <Saizan_> ?instances MonadPlus
17:07:42 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:07:54 <ivanm> dm`: that link on monads and errors is bad
17:08:13 <Saizan_> foo >> mzero = mzero except for the effect of foo :) so not much
17:08:15 <ivanm> I used to believe it too, until someone pointed out to me that many (most?) monads cheat by having fail = error
17:08:15 <benmachine> Saizan_: must be importing something, here the only MonadPlusses I have are [] and Maybe
17:08:36 <benmachine> Saizan_: oh I though even including the effects of foo
17:08:54 <benmachine> well
17:09:04 <benmachine> allegedly there is some controversy on the monadplus laws
17:09:08 <benmachine> so I heard, anyway
17:09:12 <Berengal> MonadPlus is almost, but not quite, a monoid...
17:09:32 <FunctorSalad> I thought "foo >>= mzero === mzero" is not a law for just that reason?
17:09:35 <dobblego> benmachine, there is a proposal to split it into two possible interpretations of useful laws
17:09:43 <Berengal> Well, it's sometimes a monoid, sometimes not, depending on the monad and the author
17:10:04 <benmachine> Berengal: can't the same be said for monoids? >_>
17:10:18 <FunctorSalad> "except for the effect of foo" isn't "good enough" IMHO;)
17:10:26 <Berengal> benmachine, well, the monoid laws are absolute. MonadZero, not so much
17:10:27 <FunctorSalad> insert missile example
17:11:15 <benmachine> :t M.insertWith unsafePerformIO
17:11:16 <lambdabot> Not in scope: `unsafePerformIO'
17:11:19 <benmachine> :(
17:11:26 <FunctorSalad> but what does bind have to do with whether mplus/mzero makes a monoid?
17:11:51 <FunctorSalad> I thought each M A is supposed to be a monoid for MonadPlus M
17:11:54 <aavogt> Berengal: ah, I see what you mean by MonadFail showing up at the right time. I misunderstood you.
17:12:00 <Saizan_> the question is if (M,>>,mzero) is a monoid
17:12:14 <Saizan_> M a
17:12:52 <Saizan_> all the instances respect the monoid laws for mplus/mzero i think
17:13:21 <Saizan_> ah, wait
17:13:24 <mrsolo> FlexibleInstances extension, safe to use or best to avoid?
17:13:51 <ddarius> If it is what I think it is, it's rather minor.
17:13:52 <FunctorSalad> mrsolo: safe AFAIK
17:13:52 <Saizan_> (M,>>,mzero) should be a product with an annihilator, not a monoid, right?
17:14:04 <ddarius> Saizan_: It's definitely not a monoid.
17:14:04 * mrsolo tries not to pick up bad habits early on...
17:14:16 <FunctorSalad> mrsolo: it's included in -fglasgow-exts
17:14:18 <fxr`> hmm
17:14:47 <mrsolo> FunctorSalad: so generally glasgow-exts is safe to use?
17:14:54 <ddarius> No
17:15:00 <fxr`> it is looking like a monoid
17:15:19 <FunctorSalad> No?
17:15:41 <Saizan_> fxr`: mzero >> a = a = a >> mzero would be quite weird
17:16:11 <ddarius> It would violate the MonadPlus laws except perhaps for a very trivial monad.
17:16:37 <fxr`> Saizan_: hmm
17:16:49 <fxr`> Saizan_: everything is identity?
17:16:58 <ddarius> mrsolo: -fglasgow-exts includes a huge mass of extensions.  It's best to be specific about what you are using.
17:17:09 <FunctorSalad> it activates more than I thought... http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
17:17:14 <FunctorSalad> never heard of a few of these
17:17:24 <FunctorSalad> -XConstrainedClassMethods
17:17:28 <mrsolo> yea i just read up on those... yes best just to turn on then one by one
17:19:14 <Saizan_> fxr`: what do you mean?
17:29:22 <aavogt> @src sequence
17:29:22 <lambdabot> sequence []     = return []
17:29:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:29:22 <lambdabot> --OR
17:29:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:30:57 <aavogt> @unpl (+) . succ
17:30:57 <lambdabot> (\ c -> (+) (succ c))
17:34:59 <fxr`> Saizan_: mzero >> a = a does not hold o it's not a monoid sure.
17:38:52 <dolio> mzero is typically an annihilator on the left. There are some where it isn't on the right (IO).
17:41:04 <fxr`> what do you mean by annihilator?
17:41:39 <dolio> mzero >> m = mzero forall m
17:42:43 <Saizan_> like 0 for *
17:43:14 <dolio> Which works in IO. failure >> launchMissile = failure
17:43:23 <dolio> But launchMissiles >> failure /= failure
17:43:46 <coco> is there a way to tell ghc to use absolute path names in error messages? my emacs gets confused by the Makefile's being in a different directory...
17:44:43 <Saizan_> well, who cares about missiles anyway?
17:44:53 <BMeph> coco: That sounds more like Emacs' problem. Still, I'm sure it can be done; lambdabot said Yes! ;)
17:45:02 <dolio> Well, I could come up with examples that don't involve missiles. :)
17:45:23 <BMeph> dolio: That doesn't sound dangerous and fun, though. :)
17:45:33 <coco> BMeph: it wouldn't be an emacs problem if ghc gave absolute path names
17:45:50 <dolio> putStr "Yo mama so fat!" >> failure /= failure, either.
17:48:49 <FunctorSalad> @type \x s -> runState (runMaybeT x) s
17:48:50 <lambdabot> Not in scope: `runMaybeT'
17:48:58 <FunctorSalad> @type \x s -> runState (runListT x) s
17:48:58 <lambdabot> Not in scope: `runListT'
17:49:10 <FunctorSalad> ... I was trying to make a non-IO example :)
17:50:06 <FunctorSalad> @unmtl StateT Maybe a
17:50:06 <lambdabot> err: `StateT Maybe a' is not applied to enough arguments, giving `/\A. Maybe -> a (A, Maybe)'
17:50:35 <FunctorSalad> @unmtl MaybeT State a
17:50:35 <lambdabot> err: `State (Maybe a)' is not applied to enough arguments, giving `/\A. Maybe a -> (A, Maybe a)'
17:50:51 <FunctorSalad> think I confused the order of params
17:51:09 <dolio> State needs an s.
17:51:22 <FunctorSalad> the "a" was supposed to be the state type
17:51:55 <FunctorSalad> @unmtl StateT Int Maybe a
17:51:55 <lambdabot> Int -> Maybe (a, Int)
17:52:10 <FunctorSalad> @unmtl MaybeT (State Int) a
17:52:10 <lambdabot> Int -> (Maybe a, Int)
17:52:29 <FunctorSalad> I keep forgetting the difference between these two
17:52:54 <FunctorSalad> so the former may fail to produce a new state...
17:53:19 <fxr`> FunctorSalad: isn't it clear when you @unmtl it?
17:53:29 <FunctorSalad> yes
17:53:43 <FunctorSalad> but not how to read transformers so it's clear without @unmtl
17:55:49 <BMeph> So a <pick-a-monad>Transformer takes types and another monad, and makes a monad that does <pick-a-monad> stuff "on the inside." Right? :)
17:56:12 <BMeph> <insert various "modulo" disclaimers here> ;)
17:58:15 <dolio> > runState (runErrorT (put 5 >> mzero)) 1
17:58:16 <lambdabot>   Ambiguous type variable `e' in the constraints:
17:58:16 <lambdabot>    `Control.Monad.Error.Cla...
17:58:49 <dolio> > runState (runErrorT (put 5 >> mzero)) 1 :: (Either String Int, Int)
17:58:49 <lambdabot>   (Left "",5)
18:00:29 <FunctorSalad> that's what I was trying for, yes
18:04:52 <coco> how can I figure out whether a particular type class instance has been specialized or not?
18:05:13 <dolio> Look at the core?
18:05:19 <coco> the what?
18:05:28 <dolio> The intermediate language generated by GHC.
18:05:33 <coco> oh
18:05:37 <coco> how can this be done?
18:05:49 <dolio> There's a nice program for it on hackage. ghc-core.
18:06:03 <fxr`> omg
18:06:43 <dolio> 'ghc-core foo.hs' should show you the core and assembly for foo.
18:07:11 <dolio> And the non-library files it depends on, as well.
18:08:30 <coco> ghc-core needs pcre-light, which complains about a missing foreign library, pcre
18:08:45 <coco> I'm on OS X and installed that through fink, though
18:09:23 <dolio> I'd try to get cabal-install if you can. It's pretty handy for installing haskell packages.
18:09:38 <coco> that's what I'm using...
18:09:45 <coco> cabal install ghc-core
18:09:47 <dolio> Oh, huh.
18:10:16 <ivanm> hmmmm, didn't realise that 0.5 of ghc-core had been released...
18:10:28 <fxr`> coco: grep?
18:10:36 <coco> ok, --extra-lib-dirs=/sw/lib helped
18:10:40 <coco> grep what?
18:11:12 <ivanm> that doesn't work, grep needs at least two arguments :p
18:11:35 <coco> not in a pipe
18:11:54 <ivanm> well, it has a second argument then returned by the pipe
18:12:07 <coco> dolio: you promised me colors
18:12:15 <coco> I just get black and white in a terminal
18:12:18 <dolio> colors?
18:12:22 <ivanm> @ask dons how do you know that ghc-core will work with all versions of base up to but not including 10? :p
18:12:22 <lambdabot> Consider it noted.
18:12:33 <ivanm> coco: which pager do you use?
18:12:51 <FunctorSalad> does ghc-core work with cabal btw?
18:13:07 <FunctorSalad> (it can be inconvenient to manually compile a cabalized project)
18:13:11 <SamB_XP> ivanm: crystal ball, duh
18:13:14 <ivanm> hmmmm.... Iavor really needs to fix up his cabal file for colorize-haskell...
18:13:14 <dolio> I don't think I did, although it's somewhat colored for me if I recall correctly.
18:13:19 <coco> dolio: sorry, wasn't you
18:13:20 <ivanm> SamB_XP: heh
18:13:25 <coco> from hackage: A convenient command line wrapper for GHC that displays GHC's optimised core and assembly output in a human readable, colourised manner, in a pager. Unix systems only, currently.
18:13:25 <coco>  
18:13:25 <coco>  
18:13:31 <ivanm> FunctorSalad: what do you mean?
18:13:43 <ivanm> dolio: it probably depends on the pager you use
18:13:48 <FunctorSalad> ivanm: output the core for a cabalized project
18:13:56 <coco> ivanm: don't know what pager
18:14:15 <ivanm> coco: echo $PAGER
18:14:23 <coco> nothing
18:14:27 <ivanm> IIRC, ghc-core uses the pager
18:14:29 <ivanm> hmmm...
18:14:34 <ivanm> maybe it doesn't, *shrug*
18:14:47 <SamB_XP> ivanm: I expect it does
18:14:51 <dolio> Oh, it promised you "colours". Those are totally different than what you probably think of as "colors". :)
18:14:59 <ivanm> heh
18:14:59 <SamB_XP> but what does it do if $PAGER is empty
18:15:02 <FunctorSalad> latest ghc-core does have colour for me
18:15:07 <SamB_XP> dolio: uhm no, they aren't...
18:15:21 <ivanm> anyone know what this colorize-haskell project is and how it differs from hscolour?
18:15:21 <coco> it does use the PAGER variable
18:15:33 <FunctorSalad> but I have: alias less='less -R'
18:15:43 * ivanm uses most
18:15:44 <FunctorSalad> which allows escape stuff IIRC
18:15:45 <SamB_XP> ivanm: is it possible that it has a different license ?
18:15:54 <fxr`> :)
18:16:01 <coco> ok, what does all that gibberish mean that it spits out?
18:16:22 <ivanm> SamB_XP: yup
18:16:30 <ivanm> and it uses haskell-lexer, whatever that is
18:17:16 <dolio> coco: Anyhow, what you're looking for in the core, once you find your function, is stuff that looks like '@type', which is what dictionaries look like in the core language.
18:17:35 <coco> what pager supports color? ;)
18:17:43 <FunctorSalad> less -R
18:17:57 <ivanm> most
18:18:06 <dolio> As opposed to a specialized type like 'Int -> Int -> Int'.
18:18:19 <ivanm> FunctorSalad: hmmmm.... I wonder why that isn't the default...
18:18:41 <FunctorSalad> while we're at it, what are all these "lvl" things in core?
18:18:55 <FunctorSalad> (identifiers obviously, but where do they come from)
18:19:30 <SamB_XP> lazy values floated out ?
18:19:53 <FunctorSalad> aha! I always read it as "level"
18:20:12 <dolio> GHC names a lot of literals in your code.
18:20:22 <SamB_XP> oh, that could be too
18:20:24 <SamB_XP> literal value
18:20:33 <SamB_XP> my first idea was lvalue
18:20:37 <SamB_XP> but that makes no sense ;-P
18:20:45 <dolio> So if you do 'if x == 0 then t else f', it'll frequently do 'y = 0 ; ... if x == y then t else f'.
18:21:30 <dolio> "aN" is another name it likes. :)
18:21:31 <Raevel> thanx you Lemmih for bittorrent file parser
18:21:37 <coco> dolio: I don't need to read the assembly part, do I?
18:21:39 <dolio> For some integer N.
18:22:00 <dolio> coco: Nah. Unless you're curious what assembly is being generated for your code.
18:22:30 <FunctorSalad> it also contains "CoIO"
18:22:40 <dolio> Yeah, I don't relaly know what that is.
18:26:24 <Raevel> anyone know what Data.ByteString.Base is, outdated? im trying to compile the torrent package on hackage
18:27:15 <coco> dolio: I can't seem to produce any difference in the core by adding a 'SPECIALIZE instance' pragma
18:28:01 <ivanm> Raevel: ummm, what?
18:28:05 <ivanm> why would it be outdated?
18:28:20 <ivanm> ahhh, maybe it isn't exported anymore
18:28:23 <ivanm> whereas it used to be
18:29:22 <Raevel> the torrent package is two years old, so i thought things have probably changed a lot since then
18:29:25 <coco> hmm, how can I get my hands at the core without using ghc-core?
18:29:50 <ivanm> coco: have a look at the ghc flags
18:29:53 <dolio> coco: I think the flag to pass is -ddump-simpl.
18:29:55 <ivanm> IIRC one of them spits out the core
18:30:01 <ivanm> yeah, that sounds about right
18:30:20 <ivanm> Raevel: .Base was a module that people weren't meant to have used IIRC
18:30:32 <dolio> coco: Also, I'm not sure what your code looks like. But you won't necessarily see a specialized function if you define the function and give a specialize pragma, I think.
18:30:35 <Saizan_> Raevel: there's .Internal and .Unsafe now
18:30:48 <dolio> coco: It's only when it's used for the type elsewhere that a specialized version is generated, presumably.
18:31:00 <Raevel> ah yes, found them
18:31:10 <coco> dolio: but what if it's outside the module?
18:31:20 <coco> isn't that the point of specialize pragmas?
18:31:35 <coco> if it's used *outside* the module, I mean
18:31:40 <dolio> coco: I'm not really sure. On second though, that seems like it'd lead to duplication of the specializations, but I'm not really sure.
18:31:57 <coco> ok, thanks anyway
18:32:05 <ivanm> "Not in scope: data constructor `C.ExitException'" :o
18:32:10 <ivanm> this is when building ghc-core :s
18:32:21 <ivanm> @hoogle ExitException
18:32:22 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
18:32:32 <ivanm> hmmmm, so does ghc-core need base-3?
18:32:40 <dolio> coco: I'd look for a specialized version to be generated in the module where it's used, though.
18:32:54 <dolio> If it isn't in the module where it's defined.
18:35:19 <ivanm> @tell dons well, ghc-core only seems to build with base-3 due to old-style exceptions...
18:35:20 <lambdabot> Consider it noted.
18:49:55 <copumpkin> > product []
18:49:56 <lambdabot>   1
18:54:55 <lpsmith> > and []
18:54:56 <lambdabot>   True
18:54:59 <lpsmith> > or []
18:55:00 <lambdabot>   False
18:55:04 <copumpkin> > sum []
18:55:05 <lambdabot>   0
18:55:20 <copumpkin> > concat []
18:55:21 <lambdabot>   []
18:55:50 <lpsmith> it's always the identity element of the repeated operation :o
18:55:56 <copumpkin> yep :)
18:56:00 <copumpkin> BUT
18:56:03 <copumpkin> what if it has none!!!!
18:56:06 <copumpkin> > maximum []
18:56:06 <lambdabot>   * Exception: Prelude.maximum: empty list
18:56:08 <copumpkin> boom!
18:56:20 <FunctorSalad> it would need a bounded constraint
18:56:26 <copumpkin> cass Semigroup a where
18:56:50 <copumpkin> FunctorSalad: it wouldn't know how to use it if it were present, anyway
18:56:55 <dobblego> I use a separate Semigroup/Monoid type-class in Scala and it's much better
18:57:11 <FunctorSalad> copumpkin: ?
18:57:12 <lpsmith> what's much better?
18:57:20 <copumpkin> we need a Semisemigroup, where the operation is just alternative!
18:57:31 <copumpkin> that was meant to be class but I'm tired :)
18:57:34 <FunctorSalad> @let maximum' xs = case xs of { [] -> maxBound; _ -> maximum xs }
18:57:35 <lambdabot>  Defined.
18:57:41 <FunctorSalad> > maximum' :: Int
18:57:42 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:57:42 <lambdabot>         against inferred type ...
18:57:44 <FunctorSalad> > maximum' [] :: Int
18:57:45 <lambdabot>   9223372036854775807
18:57:47 <dobblego> it's better because maximum is not defined on [a] but instead on (a, [a])
18:57:51 <FunctorSalad> @let maximum' xs = case xs of { [] -> minBound; _ -> maximum xs }
18:57:52 <lambdabot>  <local>:3:0:
18:57:52 <lambdabot>      Warning: Pattern match(es) are overlapped
18:57:52 <lambdabot>               In...
18:57:56 <FunctorSalad> @unlet maximum'
18:57:56 <lambdabot>   Parse error: SemiColon
18:58:00 <lpsmith> See,  I find maximalsBy to be useful from time to time
18:58:05 <FunctorSalad> @let maximum' xs = case xs of { [] -> minBound; _ -> maximum xs }
18:58:05 <lambdabot>  <local>:3:0:
18:58:05 <lambdabot>      Warning: Pattern match(es) are overlapped
18:58:05 <lambdabot>               In...
18:58:10 <lpsmith> That's total
18:58:11 <FunctorSalad> @unlet
18:58:12 <lambdabot>  Defined.
18:58:13 <FunctorSalad> @let maximum' xs = case xs of { [] -> minBound; _ -> maximum xs }
18:58:14 <lambdabot>  <local>:3:0:
18:58:14 <lambdabot>      Warning: Pattern match(es) are overlapped
18:58:14 <lambdabot>               In...
18:58:18 <FunctorSalad> :(
18:58:20 <copumpkin> aw
18:58:25 <FunctorSalad> my original def was bogus
18:58:32 <BMeph> > maximum' [] :: Integer
18:58:33 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
18:58:33 <lambdabot>    arising...
18:58:33 <FunctorSalad> must be min, not max
18:58:38 <BMeph> -- BOOM! :\
18:59:12 <lpsmith> Or I suppose we could define maximum :: Ord a => [a] -> Maybe a
18:59:19 <FunctorSalad> well Integer doesn't have a min ;)
19:00:14 <BMeph> FunctorSalad: And who made that decision, huh? Was it YOU?!?!!? ;)
19:00:56 <FunctorSalad> BMeph: that's why I called it maximum' not maximum
19:04:23 <FunctorSalad> to be more accurate, I mean it would have to be a function in addition to maximum, not a replacement
19:07:02 <lpsmith> mmm... Brewer's CAP Theorem in action
19:12:16 <gnut> hi all
19:12:26 <gnut> has anyone here tried calling haskell routines from MATLAB using mex?
19:12:36 <ivanm> *shudder*
19:12:50 <gnut> heh
19:15:10 <SamB_XP> why the heck are you in that mess ?
19:15:50 <FunctorSalad> lpsmith: huh?
19:17:12 <gnut> me?
19:17:16 <__m> what does '$' and '<+>' mean?
19:17:21 <__m> :-/
19:17:36 <Raevel> $ is just application
19:17:51 <Raevel> f (g h) is the same as f $ g h
19:17:56 <lpsmith> FunctorSalad:   Consistency,  Availability, and Partition Tolerance:   pick two.   IRC chooses the first two.  (More or less)
19:18:21 <__m> i see here f $ g $ h i
19:18:47 <FunctorSalad> lpsmith: was there a split? I have part messages hidden
19:18:47 <idnar> @src ($)
19:18:47 <lambdabot> f $ x = f x
19:18:48 <SamB_XP> Raevel: and what's the notation for utility again ?
19:19:01 <lpsmith> FunctorSalad:  oh, yes.
19:19:02 <Raevel> __m: so, you can replace each $ with a paren and a paren at the end f (g (h i))
19:19:04 <FunctorSalad> what was the portable way to obtain $HOME again?
19:19:14 <lpsmith> I suppose I should consider hiding part messages
19:19:14 <idnar> it's defined to have a very low precedence, though, so it lets you save on the ()
19:19:25 <__m> ohhh ok. got it
19:19:27 <sjanssen> FunctorSalad: something in System.Env
19:19:33 <sjanssen> no, System.Directory
19:19:33 <idnar> and it's left-associative (although some consider that a mistake)
19:19:34 <Raevel> __m: <+>, i'm guessing it's xmonad, it merges two hooks
19:19:45 <__m> ahh, thanks
19:19:46 <idnar> @type (<+>)
19:19:47 <lambdabot>     Ambiguous occurrence `<+>'
19:19:47 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:4:0-19
19:19:47 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:54:0-46
19:19:55 <Gracenotes> or, a b $ c d $ e f... a b (c d (e f))
19:19:57 <idnar> @type Control.Arrow.(<+>)
19:19:57 <lambdabot> Couldn't find qualified module.
19:20:00 <Raevel> (<+>) :: ManageHook -> ManageHook -> ManageHook
19:20:28 <FunctorSalad> sjanssen: thanks. I hayoo'ed for "home" but apparently that part isn't indexed
19:20:35 <FunctorSalad> I thought hayoo had everything indexed
19:20:56 <Raevel> SamB_XP: ? :-o
19:21:17 <SamB_XP> Raevel: is lame joke
19:21:26 <Raevel> >:(
19:21:41 <idnar> what the heck is ArrowPlus?
19:21:58 <Raevel> monadplus for arrows? i'm guessing
19:22:00 <idnar> the documentation is a bit sparse
19:22:11 <ivanm> to use copumpkin-style terminology, it's Arrows + moar awesome :p
19:22:11 <idnar> although it has a heading "Monoid operations"
19:22:28 <idnar> > (+1) <+> (+5)
19:22:28 <lambdabot>   Ambiguous occurrence `<+>'
19:22:28 <lambdabot>  It could refer to either `Control.Arrow.<+>', i...
19:22:35 <idnar> > (+1) Control.Arrow.<+> (+5)
19:22:36 <lambdabot>   No instance for (Control.Arrow.ArrowPlus (->))
19:22:36 <lambdabot>    arising from a use of `Co...
19:22:50 <idnar> @instances ArrowPlus
19:22:51 <lambdabot> Kleisli m
19:23:48 <idnar> > (Kleisli [5]) Control.Arrow.<+> (Kleisli [10])
19:23:49 <lambdabot>   Couldn't match expected type `b -> m c' against inferred type `[a]'
19:24:00 <idnar> oh
19:24:05 <idnar> bleh, I'm too tired for this
19:24:24 <Raevel> me too, good night
19:25:13 <idnar> > (Kleisli return) Control.Arrow.<+> return)
19:25:14 <lambdabot>   <no location info>: parse error on input `)'
19:25:18 <idnar> > (Kleisli return) Control.Arrow.<+> (Kleisli return)
19:25:19 <lambdabot>   No instance for (GHC.Show.Show (Control.Arrow.Kleisli m b b))
19:25:19 <lambdabot>    arising fr...
19:25:35 <idnar> > runKleisli $ (Kleisli return) Control.Arrow.<+> (Kleisli return)
19:25:36 <lambdabot>   No instance for (GHC.Show.Show (m b))
19:25:36 <lambdabot>    arising from a use of `M6590739633...
19:25:47 <idnar> > runKleisli $ (Kleisli return) Control.Arrow.<+> (Kleisli return) $ 10
19:25:48 <lambdabot>   Couldn't match expected type `a -> b'
19:25:48 <lambdabot>         against inferred type `Contro...
19:25:51 <Gracenotes> ArrowPlus, MonadPlus, Alternative... where does the fun end?
19:26:09 <idnar> oh, heh
19:26:15 <Alpounet> my brain's been blown away
19:26:17 * idnar gives up
19:26:40 <FunctorSalad> aren't they all just workarounds for not having context quantification
19:26:55 <FunctorSalad> @src Alternative
19:26:55 <lambdabot> class Applicative f => Alternative f where
19:26:55 <lambdabot>     empty :: f a
19:26:55 <lambdabot>     (<|>) :: f a -> f a -> f a
19:27:40 <FunctorSalad> (namely, (forall a. Monoid(m a)))
19:29:29 <Gracenotes> hm. it is certainly more convenient, though
19:30:11 <Saizan_> ?type Control.Arrow.<+>
19:30:11 <lambdabot> parse error on input `Control.Arrow.<+>'
19:30:21 <Saizan_> ?type (Control.Arrow.<+>)
19:30:22 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
19:30:52 <FunctorSalad> Gracenotes: but you could define mplus as a specialization of mappend
19:31:10 <FunctorSalad> with the extra constraint
19:58:52 <coco> can ghc compile several modules in parallel?
19:59:02 <copumpkin> not right now
19:59:04 <copumpkin> almost!
19:59:14 <coco> ...?
19:59:45 <Veinor> copumpkin: maybe it should be programmed in a more parallel-aware language
19:59:46 <copumpkin> I think there's a patch in HEAD to get rid of most of stuff preventing the parallel compilation
19:59:47 <Veinor> like, oh, haskell
19:59:50 <Veinor> (yes I'm joking)
20:00:06 <copumpkin> the problem is that ghc actually uses a global variable or two
20:00:09 <dm`> Is there any trick for defining multi-parameter type class instances on two types that are not equal, I.e.,
20:00:09 <dm`> instance (Monad m1, Monad m2) => MyClass m1 m2
20:00:33 <copumpkin> dm`: like, you want to only be able to define instances of MyClass when m1 /= m2 ?
20:00:48 <dm`> Well, I want to define one instance if m1 == m2, and a different if they are different.
20:00:56 <dm`> Would allow very powerful recursion over monad transformers.
20:01:01 <copumpkin> hmm
20:01:32 <copumpkin> you could try adding an additional constraint m1 ~ m2 in one of the two instances
20:01:41 <copumpkin> and enable OverlappingInstances and TypeFamilies, but it might not work
20:01:46 <dm`> Ooh.. what is ~?
20:01:51 <copumpkin> type equality
20:02:00 <copumpkin> I've never tried doing something like that
20:02:30 <dm`> So the type equality is not a problem.  I can say instance MyClass m m, and with flexibleinstances it's okay.
20:02:36 <dm`> it's the inequality that has me stumped.
20:03:24 <copumpkin> well, with overlappinginstances I think it might consider the equal types more specific?
20:03:26 <copumpkin> dunno
20:03:57 <dm`> Strangely, overlappinginstances seems to have no effect on this.
20:04:36 <dm`> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9856#a9856
20:07:01 <ivanm> overlapping instances is more for [Char], etc. IIRC
20:07:40 <copumpkin> yeah, it isn't smart enough to figure this out
20:07:54 <dm`> I guess I could manually do instances for a bunch of numbers of levels.  I.e., types m and (t1 (t2 (t2 (m)))) can't be the same
20:09:13 <dm`> Or use fundeps to associate a numeric type with each monad transformer, that is it's nesting level.
20:10:13 * copumpkin never uses monad transformers anyway
20:10:20 <dons> @tell bos i need a benchmarking library
20:10:20 <lambdabot> Consider it noted.
20:10:41 <FunctorSalad> dm`: type-equality-check package
20:10:54 <FunctorSalad> (deep Oleg hack o_O)
20:11:14 <dm`> FunctorSalad: thanks for the reference, will check it out
20:12:26 <coco> I'm profiling a program that uses parsec
20:12:36 <coco> is there anyway to filter out parsec's cost centres?
20:12:39 <coco> they are so many...
20:12:59 * dons boings
20:12:59 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
20:13:12 <FunctorSalad> oh god this works... Ghci> typeEq (1::Int) ""
20:13:12 <FunctorSalad> False
20:13:29 <FunctorSalad> Ghci> typeEq "" ""
20:13:29 <FunctorSalad> True
20:13:38 <brad_larsen> copumpkin: what do you use if not monad transformers?
20:13:40 <FunctorSalad> (type-equality-check)
20:13:46 <brad_larsen> copumpkin: do you write all your monads by hand?
20:13:55 <FunctorSalad> (the bool is type-level)
20:14:15 <copumpkin> brad_larsen: I just jump through hoops ;)
20:14:42 <dm`> Are we talking about this? http://hackage.haskell.org/packages/archive/type-equality/0.1.0/doc/html/src/Data-Type-Equality.html
20:14:53 <dm`> I don't see typeEq in there
20:15:20 <dm`> Maybe they renamed it :=:
20:15:36 <FunctorSalad> dm`: no, type-equality-check
20:15:42 <__max__> If you have a list that's guaranteed to have a cycle in it, is there a good way of identifying the length of that cycle?
20:15:47 <copumpkin> a lot of people write that type in every project
20:16:05 <FunctorSalad> IIRC it uses some quirk in how overlapping instances work ;)
20:16:10 <ivanm> __max__: break the cycle first?
20:16:28 <coco> __max__: it's undecidable
20:16:34 <__max__> ivanm: that's what I'm trying to figure out how to do....
20:16:47 <brad_larsen> __max__: see what coco says
20:16:54 <brad_larsen> __max__: unless, your lists are always finite
20:17:17 <brad_larsen> (in length)
20:17:22 <copumpkin> __max__: if you're talking about cycles in haskell-land,and are willing to go impure, you can do it
20:17:27 <__max__> brad: they're not, so I had a feeling it would be undecidable.... They're convergents for a continued fraction so maybe there's a way of computing the maximum length to expect them to be?
20:17:57 <__max__> because they're convergents for a square root they're guaranteed to repeat at some point.
20:18:18 <coco> is every element uniquely determined by its predecessor?
20:18:27 <ivanm> __max__: well, you could get the first element, and then takeWhile (/= first_value)
20:18:31 <ivanm> that would break the cycle
20:18:40 <__max__> nah that doesn't work so great 'cause you get cycles like [1,1,1,4] repeated.
20:18:44 <ivanm> so it's not quite undecidable ;-)
20:18:53 <ivanm> but picking the exact spot a cycle breaks might be tricky...
20:19:01 <ivanm> __max__: ahhh
20:19:03 <__max__> hold on though they might be guaranteed to be nondecreasing....
20:19:45 <ivanm> then you'd have to have a memory of what you've seen before and see if there's a pattern (larger than 1 elem); once you've seen it say 3 times in a row you can probably say that it really is a cycle
20:19:59 <__max__> hmmm.
20:20:12 <brad_larsen> but that's probabilistic!
20:20:13 <ray> @hucage type-equality-check
20:20:13 <lambdabot> http://hackage.haskell.org/package/type-equality-check
20:20:15 <brad_larsen> ;-)
20:20:20 <copumpkin> hucage :o
20:20:31 <coco> can profiling be told to print the core uniques instead of the haskell names? or, can a different cost center be assigned to a specialized version of a function?
20:20:36 <copumpkin> @fuckage hmatrix
20:20:36 <lambdabot> http://hackage.haskell.org/package/hmatrix
20:20:37 <ray> <3 edit distance
20:20:37 <ivanm> brad_larsen: yeah, well, *shrug*
20:20:39 <copumpkin> o.O
20:20:41 <ray> actualyl it's <2
20:20:48 <ivanm> @slap copumpkin
20:20:48 <lambdabot> why on earth would I slap copumpkin?
20:20:49 <ray> =o
20:20:50 <ivanm> this is a PG channel!
20:21:02 <ray> @map copumpkin
20:21:02 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:21:05 <copumpkin> http://en.wikipedia.org/wiki/Fucking,_Austria
20:21:17 <copumpkin> wow, that needs to get updated
20:22:01 <__max__> hmmmm.... ok wait. I think I'm just doing this wrong....
20:22:12 <copumpkin> ur doin it ron
20:22:42 <__max__> There's a tuple of values I'm iterating with this function... and I should just see when the latter two values of the tuple repeat...?
20:23:00 <__max__> One of these days I'm gonna come back here and actually answer a question rather than just asking a bunch of stupid ones I promise guys. I'll do it. Someday.
20:24:17 <SamB_XP> __max__: just one question ?
20:24:44 <__max__> lol changed my nick. I've come in here as "maxstahl" a few times now. Folks have been helpful. It's been lovely.
20:24:52 <copumpkin> :)
20:25:04 <maxstahl> there we go.
20:25:07 <copumpkin> we love answering questions
20:25:26 <ivanm> do we?
20:25:27 <maxstahl> Excellent! I do, too, so if y'all have ruby questions you let me know.
20:28:39 <shachaf> maxstahl: I'm sure we would ask them in #ruby-lang. :-)
20:29:17 <maxstahl> shachaf: I can most frequently be found in #midwest.rb
20:30:14 * copumpkin used to hang out in #ruby and #ruby-lang
20:31:07 <copumpkin> got called a retard for pointing out a bug in MRI
20:31:21 <maxstahl> lol really? nice.
20:31:28 <copumpkin> yeah
20:31:56 <maxstahl> ruby programmers on the whole are a pretty weird bunch. In general I feel more at home among them than more button-down type programmers like (shudder) java and ASP programmers.
20:32:09 <maxstahl> Java programmers weird me the hell out.... they wear polo shirts.
20:32:37 <ivanm> maxstahl: I wear polo shirts...
20:32:46 <ivanm> and I try to avoid Java...
20:32:47 <copumpkin> do you pop your collar?
20:32:53 <SamB_XP> the EE secretary is going to make me wear polo shirts too
20:32:55 <maxstahl> ivanm: I'm so sorry....
20:33:05 <ivanm> copumpkin: what do you mean?
20:33:11 <ivanm> maxstahl: for your stupid comment? :p
20:33:17 <ray> i thought all you sleazy programmer-types wore polo shirts
20:33:18 <SamB_XP> ... said something about I should look presentable for tutoring ...
20:33:20 <copumpkin> ivanm: http://en.wikipedia.org/wiki/Upturned_collar
20:33:33 <SamB_XP> ... though, she mentioned helicopters
20:33:41 <ray> polos are maximum sleaze, dude
20:33:44 <ray> not presentable at all
20:33:51 <ivanm> copumpkin: no, I don't turn the collar up
20:33:55 <ivanm> ray: why?
20:33:55 <copumpkin> http://knucklesunited.com/wp-content/uploads/2009/06/4popped-collars.png
20:33:57 <ray> maybe only a programmer thinks they are
20:33:59 <ivanm> they're better than T-shirts
20:34:02 <maxstahl> ivanm: I didn't mean to rub it in...
20:34:08 <ray> t-shirts are underwear
20:34:14 <SamB_XP> ray: what if they have helicopters on them?
20:34:30 <ray> sleaze+1 for each blade on the helicopter
20:34:34 <ivanm> ray: and I'm not a professional yet (I still classify myself as a student)
20:34:46 <maxstahl> ivanm: I wear t-shirts generally, but java and asp programmers always seem more like businesspeople than programmers to me, is what I was getting at.
20:34:47 <SamB_XP> ray: anyway, consider that I am a college student
20:36:48 <ivanm> maxstahl: because they're usually not programmers but "consultants" ;-)
20:38:24 <SamB_XP> and, guys, try not to freak out, but ...
20:38:27 <maxstahl> ivanm: yeah.
20:38:34 <SamB_XP> ... I actually, um
20:38:39 <copumpkin> oh no, SamB_XP has a confession
20:38:44 <maxstahl> uh oh
20:38:44 <ivanm> aagggghhhh!
20:38:46 * copumpkin freaks out
20:38:48 <ivanm> run! run for your lives!
20:38:48 <SamB_XP> own a ... suit *sob*
20:38:54 <copumpkin> SamB_XP: ZOMG
20:38:59 <ivanm> SamB_XP: oh, is that all...
20:39:06 <ivanm> it's a bit hard to go to funerals in anything else...
20:39:08 <maxstahl> hey I *own* a suit, too. I just don't wear it too often is all. I actually haven't worn it yet.
20:39:22 <maxstahl> Go to them in a tasteful black bathrobe.
20:39:22 <SamB_XP> ivanm: that's actually not what I got it for
20:39:32 <ivanm> oh, interviews?
20:39:38 <SamB_XP> and I doubt my grandmother cared ...
20:39:38 <maxstahl> bathrobe.
20:39:40 <ivanm> I have a custom-made suit... :p
20:39:42 <SamB_XP> ivanm: yeah
20:39:49 <SamB_XP> custom-made by whom?
20:39:51 <SamB_XP> a cat?
20:39:54 <ivanm> yeah, kinda need a suit for scholarship interviews
20:40:00 <copumpkin> ozwald boateng!
20:40:02 <ivanm> SamB_XP: some dodgy tailor in Hong Kong ;-)
20:40:20 <maxstahl> ivanm: me too, 'cept mine was in Thailand. I figured, when in Rome right?
20:40:32 <SamB_XP> maxstahl: heck no
20:40:38 <ivanm> and I felt like wasting money, especially since I had it delivered to me at home :s
20:40:39 <SamB_XP> it must be a lot more expensive in rome!
20:40:50 <ivanm> (since I was only in HK whilst waiting for a flight)
20:40:58 <maxstahl> lol yeah s/Rome/Bangkok/g.
20:41:26 * copumpkin 's from Rome!
20:41:32 <copumpkin> (maybe we should take this to #haskell-blah though)
20:42:01 <maxstahl> hehe
20:42:19 <ivanm> copumpkin: as soon as someone says something on-topic
20:42:22 * ivanm waits for it...
20:42:43 <SamB_XP> hey, let's all coq around
20:42:46 <Saizan> http://www.serpentine.com/blog/2009/09/25/riddle-me-this/ <- try to solve this
20:43:23 <ivanm> OK, I thought copumpkin was going to mention some random babble featuring monads or something...
20:44:01 <SamB_XP> boov boov
20:47:54 <copumpkin> :)
20:50:11 <SamB_XP> copumpkin: you be getting the reference ?
20:50:38 * ivanm isn't
20:51:50 <SamB_XP> boov is supposed to be the sound of a comonod, IIRC
20:52:15 <copumpkin> :O
20:52:16 <copumpkin> I didn't know
20:52:35 <SamB_XP> it's from some ancient joke/quotes from hawiki ...
20:52:50 * copumpkin is by no means an old-timer :P
20:52:55 <ivanm> ahhh
20:53:08 <ivanm> yes, he's a co-old timer!
20:53:18 <copumpkin> :P
20:53:33 <Gracenotes> so you just gave up 'pumpkin'?
20:53:34 <copumpkin> I'll be hitting my one-year anniversary with haskell soon!
20:53:45 <Gracenotes> zomgz me too
20:53:46 <copumpkin> Gracenotes: yeah, for a while, but I go through phases
20:53:57 <Gracenotes> I mean, is it registered to someone else?
20:54:00 <copumpkin> Gracenotes: we started at roughly the same time I think! zomg!
20:54:04 <Gracenotes> !1!!
20:54:09 <copumpkin> Gracenotes: nah, I still use it occasionally and it's registered to me
20:55:13 <ivanm> let's see if this works :p : s/co//
20:56:03 <pumpkin> zomg
20:56:11 <Gracenotes> have some ffee
20:56:21 <pumpkin> where's nal?
20:56:26 <Gracenotes> with snes
20:57:09 <maxstahl> btw I got it, my wee cycle-finder.
20:57:12 <ivanm> \o/
20:57:16 <ivanm> it worked!
20:57:19 <maxstahl> it's a bit janky but it does what it's supposed to.
20:58:41 * Gracenotes starts to read a book about the linux kernel
20:58:53 <Gracenotes> and how the hell it works
20:59:26 <ray> lol
21:00:11 <Gracenotes> besides magic I mean
21:00:15 <ivanm> you mean people actually know why it works? :o
21:00:21 <ivanm> I thought it was _just_ magic
21:01:08 <ray> linux fetishism is a bit weird
21:01:22 <ivanm> you know from experience, do you ray?
21:01:28 <ray> yes
21:01:36 <ivanm> all that dressing up in penguin suits and all in the bodouir...
21:01:37 <ivanm> ;-)
21:01:37 <ray> i wouldn't start to read a book about <vendor> c compiler
21:01:56 <Gracenotes> I don't think there's a book on the Windows kernel, is there? well, if there is, I'd want to stay the heck away from it...
21:01:58 <ray> i'd read the dragon book or whatever
21:02:21 <ray> gracenotes you made me feel suicidal twice in one line
21:02:23 <ivanm> I wouldn't cal that "linux fetishism"
21:02:44 <Gracenotes> if nothing else, it gives one an idea of what an OS *does* and just where between hardware and software it is situated
21:02:47 <ivanm> since isn't the dragon book meant to be about "real" C, rather than some custom C?
21:02:47 <ray> no, in that example it'd be <vendor> fetishism
21:02:56 <ray> it's about COMPILERS
21:03:12 <ivanm> ray: why did Gracenotes make you suicidal?
21:03:23 <Gracenotes> hypnotism
21:04:00 <ray> well, i get these suicidal urges when people say things like that
21:04:01 <ray> :)
21:04:55 <Gracenotes> how two times, anyway? "Windows" and "kernel"?
21:05:07 <ray> first part and second part :)
21:05:38 <Gracenotes> zomgz cryptic statement
21:06:20 <ray> anyway, zomg linux fetishism
21:07:54 <Gracenotes> there is a possibility your distaste is misplaced here..
21:13:54 <hackagebot> judy 0.1 - Fast, scalable, mutable dynamic arrays, maps and hashes (DonaldStewart)
21:14:21 <jmcarthur> yay judy!
21:14:53 <ray> my distaste is never misplaced
21:16:34 <dons> basic binding is a mutable IntMap, basically. about 4x faster than IntMap, and should scale further.
21:16:45 <dons> I'll extend it with a hash layer over the weekend.
21:16:52 <pumpkin> :o
21:17:04 <dons> type families should let us switch between different optimized judy structures at compile time
21:17:12 <dons> which would be something other languages don't do
21:17:17 <pumpkin> nice
21:17:30 <dons> i.e. Judy Bool -> Judy1
21:17:33 <pumpkin> does judy have any external dependencies?
21:17:40 <dons> the Judy library.
21:17:48 <pumpkin> I meant that library
21:17:53 <dons> nope.
21:17:58 <pumpkin> cool
21:18:10 <dons> i need bos' benchmarking lib though, to put a stamp on this.
21:18:20 <dons> and more instances (i.e. for bytestring keys or values)
21:18:35 <dons> but should be easy.
21:18:44 <dons> and then, hell yeah, scalable hashtables.
21:18:50 <pumpkin> did he release it?
21:18:56 <dons> not yet.
21:18:59 <pumpkin> ah
21:19:11 * dons -> dinner. HacPDX tomorrow
21:43:02 <hackagebot> judy 0.1.0.1 - Fast, scalable, mutable dynamic arrays, maps and hashes (DonaldStewart)
21:44:16 <linopolus> anyone worked with Qt and can say me which bindings i should use?
21:44:46 <dons> there's only one set of QtHaskell bindings
21:44:48 <dons> on sourceforge
21:44:55 <dons> not sure how stable they are.
21:45:28 <gwern> dons: I think I've seen people using qthaskell say it's good stuff
21:45:40 <gwern> (but as ever, pity about the build process)
21:48:21 <gwern> qt being big and corporate, I'd guess stability isn't an issue
21:49:19 <linopolus> are other bindings for other toolkits better?
21:49:34 <Veinor> you should totally use ncurses :P
21:49:36 <pumpkin> gtk's pretty well tested
21:49:56 <linopolus> Veinor: i can't make an systray icon with ncursesâ¦
21:51:33 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9857#a9859 -- comments?
21:53:06 <Veinor> I was joking
21:53:16 <Veinor> from what i've heard ncurses is has absolutely horrible bindings.
21:54:08 <ivanm> dons: what's your obsession with using "base < 10" in your .cabal files?
21:54:13 <Saizan_> you can do a StatusIcon with gtk2hs
21:54:16 <ivanm> I thought dcoutts didn't like it when people did things like that...
21:54:57 <Saizan_> dons has special informations on the future of the base package
21:55:13 <ivanm> Saizan_: I doubt it
21:55:14 <Saizan_> so he knows his code won't break until base 11 :)
21:55:18 <ivanm> ghc-core-0.5 fails with base-4
21:55:59 <Saizan_> well, the future! base-4 is already there
21:56:38 <ivanm> yup
21:59:24 <linopolus> Veinor: ncurses IS completely horrible for devs ^^
21:59:53 <linopolus> how about vty? ^^
22:00:00 <ivanm> what is a pattern binding? declaring a variable?
22:00:03 <Veinor> vty?
22:00:28 <linopolus> Veinor: this haskell alternative for ncurses. mom i'm searchingâ¦
22:00:51 <ivanm> @hackage vty
22:00:51 <lambdabot> http://hackage.haskell.org/package/vty
22:01:02 <linopolus> http://hackage.haskell.org/package/vty
22:01:04 <linopolus> yes
22:01:06 <Veinor> cool :D
22:01:09 <linopolus> ^^
22:01:19 <linopolus> not tried yet but looks nice
22:01:46 <Saizan_> ivanm: i think it has to involve a constructor
22:01:56 <linopolus> Known issues: no windows support <-- that's an issue???
22:01:57 <dmwit> ivanm: I'm not totally sure, but I thought a pattern binding was just what you have in a case/function/do block.
22:02:03 <ivanm> so something like (Just a) = foo ?
22:02:04 <Saizan_> like "(a,b) = ..."
22:02:09 <dmwit> ivanm: exactly
22:02:09 <Saizan_> ivanm: right
22:02:31 <dmwit> grr
22:02:33 <ivanm> *sigh* I love how clear and unambiguous haskell-src-exts is
22:02:35 <Saizan_> a pattern binding is when a pattern is used with let, basically, or at the toplevel
22:02:46 <ivanm> or a where?
22:02:46 <dmwit> "I'm feeling lucky" has stopped working for me recently. =(
22:02:53 <dmwit> ivanm: Yeah, where, too.
22:03:00 <ivanm> "a pattern binding occurs when the left hand side is a pat0;"
22:03:18 <ivanm> and it says it can at the top level
22:03:25 <ivanm> http://haskell.org/onlinereport/decls.html section 4.4.3
22:03:30 * ivanm isn't good at reading language specs
22:12:33 <ivanm> dmwit, Saizan_: so would I be right in assuming that you can't have a pattern bind in a class or instance declaration?
22:15:54 <dmwit> Sadly, yes.
22:16:25 <dmwit> [(*), (+), (-), (/)] = map liftM2 [(*), (+), (-), (/)] -- would be so hott
22:16:42 <dmwit> or s/liftM2/whatever/
22:18:21 <ivanm> heh
22:19:34 <linopolus> now: which gui toolkit + bindings would you recommend to me?
22:20:12 <dmwit> gtk2hs seems like a pretty standard choice
22:20:19 <dmwit> Whatcha gonna do with them?
22:22:41 <linopolus> a simple tray icon for controlling mpd ^^
22:23:18 <dmwit> The existing tray icons for controlling mpd are no good?
22:23:57 <ivanm> linopolus: which panel are you using?
22:24:19 <ivanm> xfce4-panel has (or at least had) good mpd support
22:24:23 <linopolus> ivanm: kde plasma panel
22:24:29 <ivanm> ahhh
22:24:34 <linopolus> dmwit: no :(
22:24:36 <ivanm> well, I don't think gtk2hs will work
22:24:38 <ivanm> ;-)
22:24:49 <ivanm> linopolus: also, I'm not sure how valid Haskell would be for something like that
22:25:03 <ray> WHAT
22:25:14 <dmwit> There's certainly nothing wrong with using Haskell for it, but I would strongly suggest trying to fix up one of the existing apps rather than start your own.
22:25:45 <ivanm> ray: well, if he wants to distribute it later on
22:25:51 <ivanm> I thought all of KDE was in C++
22:26:02 <ivanm> not sure how much cross-language stuff they allow
22:26:18 <ray> gmblssod
22:26:27 <ivanm> (whereas GNOME seems to allow any language you want... especially if it's Python or C# :p )
22:26:41 <ivanm> ray: is that actually meant to mean something?
22:26:55 <ray> google it noob
22:26:59 <ivanm> I did
22:27:05 <ivanm> google has nfi what you're talking about
22:27:07 <ray> :C
22:27:21 <ivanm> hence why I asked
22:27:23 <ivanm> @slap ray
22:27:23 * lambdabot is overcome by a sudden desire to hurt ray
22:27:29 <linopolus> ivanm: you don't know anything about kde?
22:27:37 <ivanm> linopolus: I don't use it
22:27:40 <ivanm> but I use some KDE apps
22:27:44 <ivanm> (e.g. okular)
22:28:00 <ray> does kde use dbus these days or what
22:28:26 <ivanm> I think so
22:28:35 <linopolus> trayicons are a freedesktop.org standard, so i can make my icons in haskell or ruby or python or C++, in gtk or wx or Qt or shoooes or anything!
22:28:51 <ivanm> linopolus: oh, for the systray?
22:28:56 <ivanm> I thought you meant a panel plugin
22:29:06 <ivanm> plasma is probably not gtk ;-)
22:29:35 <ray> nothing is gtk
22:29:38 <ray> oh wait
22:29:48 <ray> sorry i just came from a marginally better universe
22:29:54 <ray> the lack of gtk is the marginal improvement
22:30:10 <ivanm> *sigh*
22:30:19 <hydo> Hehe
22:31:07 <linopolus> yes i meant systray ^^
22:31:53 <ivanm> linopolus: I would argue that that is a bad idea
22:32:02 <ivanm> since you're not meant to have a large systray plugin with heaps of buttons
22:32:23 <ivanm> or are you wanting to right-click it or something to do stuff?
22:32:44 <ray> @faq can haskell do all the stuff you want so don't listen to naysayers
22:32:44 <lambdabot> The answer is: Yes! Haskell can do that.
22:36:12 <linopolus> ivanm: yes. rightclick to open the menu and choose the option
22:36:21 <ivanm> ahhh, k
22:36:28 <ivanm> right, that'll probably be OK then
22:37:00 * ivanm sticks with his multimedia-key-keybindings
22:46:10 <jfredett> has anyone recieved the new HWN from either mailinglist yet?
22:46:29 <jfredett> I think something might have gone awry in the sending.
22:46:29 <ivanm> jfredett: nope, but I get digests
22:47:19 <jfredett> ivanm: I'm still trying to figure out those line ending problems, I tried sending it via raw sendmail this time.
22:47:34 <jfredett> I don't think I did it right, but I also don't want to double post.
22:47:54 <ivanm> *nod*
22:48:18 <ivanm> gmane doesn't have it yet
22:48:31 <ivanm> (on cafe, anyway)
22:48:33 <jfredett> I figure, if the wierd endings happen even when sendmail sends it, then it's probably not the sending app thats doing it.
22:49:00 <jfredett> hmm, See, I set the From: field in the message to the list, but the sendmail executable wants to list recipients on the command line.
22:49:37 <jfredett> methinks that is why it hasn't come up. but I suppose I can wait till tomorrow in any case. I don't know what the turn around is on gmane.
22:51:44 <ivanm> jfredett: it's not on the main haskell ML site either: http://www.haskell.org/pipermail/haskell/2009-September/thread.html
22:51:53 <ivanm> not sure what its turn-around is though
22:51:54 <jfredett> hmm.
22:52:12 <jfredett> yeh, I suppose I should just wait, usually I send it out around noon.
22:52:25 <jfredett> noon US-EST, that is.
22:58:03 <orbitz> do UML style tools have little-to-no meaning in a langauge liek haskell?
22:59:34 <jfredett> alright, sleeptime. gnite folks.
23:01:27 <ivanm> cya jfredett
23:01:43 <ivanm> orbitz: depends if you think they have meaning in other languages ;-)
23:08:01 <orbitz> ivanm: hah
23:08:22 <orbitz> ivanm: it seems like things become less clear when you have firstclass functions
23:09:00 <Gracenotes> okay, time for a sequence diagram! Let's see, first we add these two numbers together.. oh wait.. is the list evaluated by then? should be.. but wait, with strictness analysis... oh, screw it
23:10:43 <ivanm> heh
23:10:55 <ivanm> Gracenotes: usually when you do that kind of thing, people assume haskell is strict
23:11:34 <Gracenotes> true. either way, that the result you need will be evaluated by the time you use it
23:12:08 <Gracenotes> ...mostly
23:12:59 <ivanm> if it needs to be evaluated...
