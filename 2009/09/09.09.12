00:20:41 <stanv_> @src id
00:20:41 <lambdabot> id x = x
00:23:23 <copumpkin> :t id id id id id
00:23:23 <lambdabot> forall a. a -> a
00:28:37 <ksf> i'd like to feature creep h' a bit.
00:29:07 <ksf> ...we _absolutely_ need open adts
00:29:31 <ksf> ...both to removal and addition of constructors.
00:29:58 <Berengal> As an addition, or as an alternative to closed adts?
00:30:15 <ksf> ...introducing a new type, of course. and possibly requiring a hell a lot of annotation to be able to tell whether a pattern match may fail or not.
00:30:36 <copumpkin> :o
00:30:38 <ksf> I guess it works well in addition, if new types are introduced.
00:31:08 <copumpkin> why do we absolutely need open ADTs?
00:31:15 <ksf> ...the point is that I _might_ want to have LineTerminator in my token stream, and then filter them out. the rest of the code shouldn't care about LineTerminators.
00:31:39 <ksf> ...type safety.
00:31:51 <Berengal> You could do it with type families... ish... maybe
00:31:59 <copumpkin> seems like you sort of want subtyping?
00:32:05 <ksf> yep.
00:32:16 <copumpkin> why not just existentials with typeclasses then?
00:32:27 <copumpkin> not exactly pretty but it works
00:32:55 <ksf> ..."not pretty" is an euphenism.
00:33:54 * ksf wonders how oohaskell would look like if it used type families.
00:34:11 <ksf> AddMember Foo Bar
00:34:17 <ksf> Baz :: AddMember Foo Bar
00:36:08 <Berengal> @paste
00:36:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
00:36:20 <Berengal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3576#a3576
00:37:59 <copumpkin> and now you've gone and taken the Super name
00:38:11 * copumpkin pouts
00:38:39 <Berengal> You can have Supertron if you want
00:38:51 <Berengal> But I want hyper
00:56:03 <ivanm> is there a better way of doing Set (Set a) -> Set a than Set.unions . Set.toList ?
00:58:06 <dolio> fold union empty?
00:58:26 <ivanm> hmmm.... foldl or r?
00:58:38 <ivanm> l' sounds like the best bet...
00:58:50 <dolio> I thought Set just had a function called fold.
00:58:58 <ivanm> oh, right
00:58:59 <ivanm> duh
00:59:08 <ivanm> thanks dolio
01:00:15 <dolio> You can get foldl' from Data.Foldable, though.
01:00:21 <dolio> Which Set is an instance of.
01:00:25 <dolio> That might be the way to go.
01:00:40 <ivanm> yeah, that's what I was thinking of
01:00:53 <ivanm> I didn't realise Set had its own fold function though
01:02:17 <ivanm> hmmm, Set.fold is foldr...
01:03:54 <kakeman> how to install these depends: base==4.*, array, random?
01:04:46 <ivanm> kakeman: base-4 comes with ghc 6.10.*
01:04:52 <ivanm> array and random will also come with ghc
01:05:03 <ivanm> kakeman: how are you trying to build/install packages?
01:05:42 <kakeman> runhaskell Setup configure...
01:05:51 <kakeman> but i have ghc 6.8
01:05:59 <ivanm> have you considered using cabal-install?
01:06:05 <ivanm> kakeman: well, you have a problem then :p
01:06:14 <ivanm> @where cabal-install
01:06:14 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
01:06:56 <kakeman> ubuntus packages are always ancient
01:13:38 <kakeman> but Tested-with:         GHC==6.8.2 ?
01:14:06 <kakeman> i have same version of ghc
02:05:48 <Axman6> http://www.bookdepository.co.uk/category/1990/Functional-Programming functional programming fail :(
02:05:52 <lambdabot> Title: All Functional Programming books - page 1. Free delivery worldwide at The Book D ..., http://tinyurl.com/ntj7gp
02:23:49 <ivanm> Axman6: I guess they don't list the books under "Functional Programming" properly
02:24:01 <ivanm> (i.e. the people running it have no idea wtf the books are about)
02:24:10 <Axman6> most likely
02:43:28 <bavardage> is there a reader equivalent with two environments?
02:43:46 <bavardage> or should I make a custom environment and modify with record syntax
02:44:27 <greap> Hi guys. I posted this problem on haskell-cafe a while ago, but didn't get any responses that I could use. Is anyone running glut programs from haskell on os x? Mine used to use the native opengl libraries, but after upgrading something (I suspect GLUT) my programs now use an X11 wrapper.
02:46:37 <Axman6> Cale: any chance you could turn off the lambdabot URL announcing?
02:50:59 <mle> greap: are you on 10.5 or 10.6?
02:51:38 <greap> mle: 10.5.8
02:53:42 <mle> greap: not sure.  I'm encountering other difficulties on 10.6.
02:55:12 <greap> mle: Yes, I've heard there are some issues with getting bootstrapped.
02:56:17 <mle> Past that, though yes that is troublesome.  I tried fiddling with opengl briefly and got some error to the effect that the headers weren't present at all.  I don't use opengl though, so I didn't look further.  Be wary, though.
02:57:23 <greap> mle: Thanks. I pretty much need to stick with opengl as this is going to be for a 3d game. But through X11 things are so sluggish it's painful.
02:58:40 <mle> Hm, I didn't realize there was such a large performance gap there.
03:08:55 <greap> mle: Well I'm doing development on an Air with intel graphics, so I'm sure that doesn't help :)
03:09:57 <mle> ouch.
03:11:03 <mle> greap: look with ghc-pkg list to see if you have the old (non-upgraded) ones still installed.  If so, you can ghc-pkg hide them and possibly continue work until you have a chance to diagnose the upgrade trouble in detail.
03:14:23 <greap> mle: how do you tell which packages are outdated?
03:14:40 <mle> ...carefully?
03:15:29 <mle> cabal update && cabal upgrade will howl furiously that it's too dangerous and give you a nice list of things that might be update-able.
03:18:00 <greap> haha
03:44:26 <dons> ?yow
03:44:27 <lambdabot> Couldn't find fortune file
03:44:29 <dons> ?users
03:44:29 <lambdabot> Maximum users seen in #haskell: 658, currently: 553 (84.0%), active: 4 (0.7%)
03:45:23 <maltem> Just wanted to say, the feature list of vty-4 read quite impressive now. Congrats!
03:51:50 <gjl> So is xmonad the window manager of choice around here?
03:54:26 <dons> its popular, but not esp. so among haskellers. its core users aren't haskellers
03:55:03 <Axman6> dons: you still planning to come down to canberra while you're over here?
03:55:22 <ivanm> :o I take it the version of lambdabot that Cale put up is an older one with the @users plugin still in there?
03:55:43 <ivanm> dons: even though it initially became popluar in the haskell community?
03:57:37 <dons> Axman6: maybe. but i need to determine when i'll be in .au
03:57:43 <dons> ivanm: yeah, the early days it was all haskellers
03:57:52 <Axman6> righto.
03:58:21 <Axman6> dons: trying to see if i can get ChilliX to come down at the same time, and have a few talks at once.. or something
03:58:29 <Axman6> i think he was somewhat interested
04:01:24 <ibt> gjl: debating whether to use xmonad?
04:03:02 <ivanm> dons: if you're coming up to brisbane for some reason whilst you're down here, could we con you into giving a talk for BFG? :p
04:03:16 <Axman6> BFG?
04:03:39 <FunctorSalad> hehe
04:03:55 <ivanm> oh, that's right, they did put that P in there...
04:03:56 <ivanm> Brisbane Functional Programming Group
04:04:12 <ivanm> (it was originally just BFG for some reason...)
04:10:03 <gjl> ibt, well I've tried awesome and I liked the whole concept of a tiling wm. I don't fancy learning lua just to customise it. Would a Haskell beginner be able to dive into using xmonad, particularly as I hear it's not as functional 'out of the box' as awesome?
04:10:31 <dons> doesn't really need haskell knowledge.
04:10:43 <ivanm> define "functional out-of-the-box"
04:10:45 <dons> but also, it doesn't come with 95 dependencies, like awesome.
04:10:50 <ivanm> you can use xmonad with the default config...
04:10:59 <ivanm> dons: depends on how you count dependencies...
04:11:06 <dons> by adding them together
04:11:16 <ivanm> if you just count haskell ones, then it will be less
04:11:26 <wjt> i don't suppose there are any plans to make xmonad do ewmh etc. out of the box?
04:11:31 <ivanm> but if you include all recursive dependencies needed... it depends on your system ;-)
04:11:35 <ivanm> wjt: I doubt it
04:12:04 <dons> wjt: no, its just a simple import to add though
04:12:24 <dons> the core system is a minimal tiling wm that works for most people. you add in bits and pieces via imports as you need them
04:12:51 <dons> http://unethicalblogger.com/posts/2009/07/awesomely_bad
04:12:52 <lambdabot> Title: Awesomely Bad | unethical blogger
04:12:53 <dons> on why dependencies are bad
04:13:44 <ibt> gjl: it could be a little frustrating at first if you're wanting to do some non-standard configuration and you haven't been exposed to much haskell. if you're a haskell user or have interest in learning haskell, then it should be a problem.
04:13:50 <ivanm> dons: on why either openSUSE has bad packages or that user is an idiot
04:14:11 <wjt> dons: it just seems silly to have the default config not support completely standard hints that, in practice, applications expect to be present
04:14:15 <ivanm> (also, why binary distros are stupid with splitting up libs into ones with similar names)
04:14:26 <ivanm> wjt: ummmm.... what hints are expected?
04:14:28 <dons> he's packaging stuff, and there's good advice in there on things that seemed to me that awesome is doing obviously wrong
04:14:45 <ivanm> ewmh is only useful for pagers AFAIK, and not everyone uses one...
04:14:51 <dons> wjt: EWMH has an E for a reason :)
04:14:53 <wjt> ivanm: pagers, panels, fullscreen, etc etc.
04:15:03 <dons> import EWMH and be done with it
04:15:09 <ivanm> dons: I suppose at least we have cabal-install, which in theory can help people...
04:15:20 <dons> no one installs xmonad from cabal
04:15:22 <wjt> dons: throwing it into the XMC sin-bin seems like a shame
04:15:27 <ivanm> wjt: ummm... AFAIK the EWMH in contrib only supports pagers and that's it...
04:15:28 <wjt> anyway, opinions. :)
04:15:42 <dons> no, there's more than that
04:16:22 <ivanm> OK, pagers and app lists
04:16:29 <ivanm> don't see anything there about fullscreen...
04:16:43 <eoeas> Hi, I want to add more expressions to to my app which starts:
04:16:43 <eoeas> main = interact textCount
04:16:43 <eoeas>                           where   textCount input = show (length (input))
04:16:43 <eoeas> What can I use to add more code, I tried encapsulating in { ; } no luck
04:17:18 <ivanm> dons: though with the awesome guy, I'm not sure if I agree about requiring upstream to keep track of "stable" versions of all distros
04:17:27 <ivanm> or else we'd be stuck with 5 yo libs for Debian :p
04:17:50 <ivanm> eoeas: ummm.... what are you wanting to do?
04:17:50 <dons> its not a slippery slope. you can do better than they do, where /no/ distro had the packages they were using.
04:18:06 <ivanm> I'm sure gentoo did :p
04:18:24 <ivanm> and I would have thought that arch would have had them in AUR or something...
04:18:48 <eoeas> ivanm: continue working with "input" file, if then else, etc
04:18:55 <ivanm> but still, if there's newer versions of libs available and no-one uses them, then no-one will ever use them...
04:19:09 <ivanm> eoeas: well, yes, they can go in the main function, in seperate functions, etc.
04:19:14 <ivanm> maybe you should read a tutorial or something
04:20:32 <eoeas> ivanm: seperated by "," and ()  ??
04:20:47 <ivanm> eoeas: no
04:21:30 <ivanm> eoeas: I highly suggest you read a tutorial or two rather than trying to stumble your way through this
04:21:32 <ivanm> @where tutorial
04:21:32 <lambdabot> http://www.haskell.org/tutorial/
04:21:38 <ivanm> @where wikibook
04:21:38 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:21:42 <ivanm> @where LYAH
04:21:42 <lambdabot> www.learnyouahaskell.com
04:23:35 <eoeas> ivanm: :-D I am, just a bit impatient, I just seem to hit a wall when it comes to understanding flow control of Haskell (if that makes any sense)
04:23:58 <ivanm> you typically don't have much of a flow control as such in haskell like other languages do
04:24:13 <ivanm> Haskell is more about what you're doing rather than how you're doing it
04:24:31 <ivanm> and you don't really worry about execution order
04:26:36 <kakeman> would you use haskell in graphics programming?
04:26:42 <eoeas> ivanm: I see, problem is most tutorials are for people with some experience in other languages, which I don't have much of. Any suggestions ??
04:27:08 <maltem> eoeas, sounds basically like you'll want to read about "do" notation, one way to, e.g., combine several IO actions
04:27:10 <Axman6> kakeman: what sort of graphics programming?
04:27:50 <kakeman> 3d games, demos, video processing?
04:28:36 <maltem> eoeas, and if you don't mind fancy pictures, lyah may be a good start
04:29:13 <maltem> also, the wiki maintains a list of tutorials and books somewhere
04:29:34 <Axman6> kakeman: i don't see why not, the tools are there
04:29:54 <eoeas> maltem: I see, thnx
04:30:13 <kakeman> i'm sick of c++
04:30:23 <kakeman> don't want it anymore
04:36:03 <gwern> jefferson heard does a lot of graphic stuff in haskell
04:36:07 <gwern> check his blog out maybe
04:36:22 <Axman6> zomg! a boostrapping, self compiling crain compiler! http://www.wired.com/gadgetlab/2009/09/video-how-a-construction-crane-is-erected/
04:36:25 <lambdabot> Title: Video: How a Construction Crane is Erected | Gadget Lab | Wired.com, http://tinyurl.com/momddp
04:42:11 <ivanm> Axman6: does the crane build itself?
04:42:17 <ivanm> or just build other cranes of the same type?
04:42:24 <Axman6> it sure does, with the help of another crane
04:42:41 <hackagebot> cmdargs 0.1 - Command line argument processing (NeilMitchell)
04:42:46 <Axman6> hence the bootstrapping. once it's off the ground, it builds itself
04:43:35 <ivanm> hmmmm..... cmdargs sounds interesting...
04:43:39 <ivanm> @haddock cmdargs
04:43:39 <lambdabot> Unknown command, try @list
04:43:46 <ivanm> @hackage cmdargs
04:43:46 <lambdabot> http://hackage.haskell.org/package/cmdargs
04:43:58 * ivanm has been doing "cabal haddock" too many times...
04:46:00 <ivanm> base >= 4 is slightly dissapointing though... :(
04:48:20 <ivanm> @tell ndm the link to the haddock docs for cmdargs on its homepage links to cs.york.blah (and doesn't work/exist)
04:48:21 <lambdabot> Consider it noted.
04:50:14 <mauke> http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm
04:50:14 <lambdabot> Title: CmdArgs: Easy Command Line Processing
04:52:31 <ivanm> any idea what this Diffy app that ndm uses is?
04:53:08 <mauke> diffy - a program to compare the differences between directories.
04:53:59 <ivanm> where did you get that from?  It doesn't seem to be on hackage...
04:54:08 <mauke> see previous link
04:55:13 <ivanm> ahhh, missed that bit
05:16:19 <aflash> Hei, I'm a new to Haskell, and is making a little programm that is solving a puzzle. And I have a hard time figuring out have to make a function that takes a piece and find evrery possible position it can have. So I was wondering if there maybe was some here that could help a newbie out?
05:17:36 <Botje> can you put what you have so far on a pastebin? hpaste.org or something like it.
05:19:59 <aflash> What I have now is not any good at all, trying a new approach since the code is kind of horrible. Anyway here it is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9319#a9319
05:21:25 <Botje> uh .. okay, that's not really helpful :)
05:21:33 <Botje> can you show what puzzle you're trying to solve?
05:22:01 <Tobsan> could somebody please explain this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9320#a9320
05:22:16 <skorpan> hard tabs, nice
05:22:28 <aflash> Hehe. I havent found it anywhere on the net, but I can try to explain it.
05:22:38 <Botje> Tobsan: are they symlinks?
05:22:45 <Tobsan> no, none of them
05:22:52 <mauke> Tobsan: current working directory
05:22:55 <mauke> relative names
05:23:04 <mauke> #$*!#&
05:23:09 <Tobsan> mauke: how do you mean?
05:23:34 <mauke> Tobsan: doesFileExist is not magic. it checks if the filename you give it exists
05:23:43 <Tobsan> Ah, and the filename is relative
05:23:46 <Tobsan> I get it now... :(
05:24:01 <skorpan> a fool could have figured that out!
05:24:02 <mauke> you need to prepend the directory you're reading from
05:24:08 <Tobsan> skorpan: indeed! ;-)
05:24:12 <Tobsan> mauke: yes
05:24:30 <aflash> Its a set of wood blocks ten in total. Each block has either some pegs or holes,  They can be in five fosition therfor the Intger list with -1 or 1, To solve it you have to put five blocks at the bottom and five on top.
05:24:33 <skorpan> Tobsan: you can do this with "map"!!!
05:25:22 <Tobsan> skorpan: NO WAY!
05:25:25 <skorpan> ya rly
05:25:43 <Botje> aflash: so you want all the different ways the list [a,b,c,d,e] can be ordered?
05:27:17 <Botje> one way of writing that is: perms [] = [[]]; perms xs = [ x:xss | x <- xs, xss <- perms (delete x xs) ]
05:27:19 <aflash> let say I have stick a, I want a function that gives me all the possible a can be placed,
05:28:42 <Botje> all the possible what?
05:29:26 <ivanm> Botje: I think all the possible positions where a can be placed
05:29:27 <aflash> sorry, all the possible positions a can be in.
05:29:37 <ivanm> aflash: you want all the possible next moves?
05:30:37 <aflash> I'm trying implent a brutforce solution just trying every piece in every possible postion
05:33:40 <poe> aflash: what's the domain of the positions?
05:34:49 <aflash> Each piece can be in ten positions and also flipped so twenty in total
05:35:05 <poe> how do you represent the positions
05:36:06 <aflash> A matrix, each piece is a list of Int. So I have a list containg all the pieces
05:36:14 <jpcooper> hello
05:36:59 <jpcooper> does anyone here have experience with using FastCGI? I have a fastcgi programme whose main = runFastCGIConcurrent' forkIO 10 $ output "HELLO" . I am trying to understand why when I try to wget the fastcgi page, it hangs.
05:37:54 <maltem> Can someone guess for me what the  x  in this class declaration means? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9321
05:39:00 <poe> aflash: so you need a list of indices?
05:39:24 <Botje> maltem: the "a" is an action that produces an x, somehow.
05:40:00 <Botje> or rather "can be transformed into an Action that eventually produces x" ?
05:40:20 <aflash> poe: jupp, something like that
05:41:38 <maltem> Botje, ah, so the idea is that the result of the action can be Shown?
05:41:55 <maltem> That's a confusing encoding to me :)
05:42:52 <Botje> yeah.
05:43:05 <Botje> if i had a bit more time i'd investigate but i have a proposal to write by tomorrow ;)
05:43:24 <maltem> Nevermind, I basically got it now
05:43:45 <maltem> There's some of those things to find when browsing the yi sources
05:43:50 <maltem> I think
06:10:31 <aflash> I drew up a illustration of the puzzle if that helps some of you understand the problem. Just want a function that prodeces every possible set.
06:11:22 <aflash> http://bildr.no/view/486544
06:11:23 <lambdabot> Title: Bildr.no
06:12:09 <Botje> ah. that's brilliant :)
06:13:17 <Botje> so you basically want to permute a list of 10 sticks, and put the first 5 on top of the other five.
06:13:39 <aflash> jupp
06:13:40 <Botje> the perms function i showed above can be used, with a slight adjustment
06:14:25 <Botje> perms [] = [[]]; perms xs = [ x':xss | x <- xs, xss <- perms (delete x xs), x' <- [x, flip x] ]
06:14:47 <Botje> that will produce all 2*10! positions (if i got it right)
06:15:07 <Botje> and then you can split each list into two parts, transpose the second and match it up with the first.
06:16:14 <aflash> I'll check it out, looks good.
06:16:56 <Botje> of course it'll be dog slow :)
06:17:56 <Botje> a slightly faster approach would be to generate all possibilities for the first five sticks, and then select the other five according to the ones that will match.
06:18:19 <Botje> llc
06:18:41 <Botje> also, working with Int is better than Integer, in this case
06:19:34 <aflash> I get some kind of type failure...
06:19:39 <Botje> and i'd write calcChecksum as all (==0) $ zipWith (+) xs ys
06:20:10 <Botje> hmm, it's untested of course.
06:20:12 <Botje> let me see
06:20:27 <LeoD> what's the flip x supposed to do there?
06:20:38 <Botje> oh
06:20:43 <Botje> that flip should be flipStick
06:20:51 <Botje> or just reverse.
06:21:42 <Botje> actually, it should be reverse :)
06:23:29 <aflash> Sorry, I don't understand your function completly. It expecst to take in a list, and produces as list of lists. Is that right
06:23:44 <Botje> yes
06:25:00 <aflash> would this be the correct type perms :: [Integer] ->[[Integer]] ?
06:25:21 <Botje> no, you want [[Integer]] -> [[[Integer]]]
06:25:34 <Botje> or if you do type Stick = [Integer]
06:25:39 <Botje> you get [Stick] -> [[Stick]]
06:25:48 <Botje> which is a bit clearer :)
06:26:48 <aflash> Ok, then understand. Thanks
06:31:32 <aflash> Wouldn't the function run eternally since x' is put back.
06:32:30 <Botje> waht do you mean by "put back" ?
06:33:11 <ErhardtMundt> hi
06:33:39 <Botje> do you mean the x':xs part to the left of the | ?
06:33:47 <Botje> hello
06:35:15 <aflash> I guees I don't see how the lists ever get empty and return the completed set of solutions
06:36:04 <Botje> the x':xss part is simply what the list comprehension returns
06:36:25 <Botje> do you see the recursive call to perms?
06:36:40 <Botje> note how x is deleted from xs before it's passed along
06:36:53 <Botje> so the next invocation of perms always receives a list that is one element smaller
06:37:22 <Botje> until you reach [], at which point it returns [[]] (not [], because that's a failure in the list comprehension)
06:38:26 <Botje> you should reach that list comprehension as follows: "take one element from xs and call it x, then take one element from perms (delete x xs) and call it xss, then take one element from the list [x, reverse x] and call it x'. Finally, return x': xss
06:38:30 <Botje> "
06:39:28 <aflash> Hmm, sounds right. But the I'e
06:40:01 <aflash> I've tested out with ten piceses, and it runs continuesly  never ending. Is it that slow yout think?
06:40:43 <Botje> hmm, it *should* start returning elements soonish.
06:42:07 <aflash> ahh, right it ruturs elements but never stops. Seems like the set is really really big
06:42:16 <Botje> well, yes.
06:42:39 <Botje> it's _very_ big
06:43:02 <Botje> i think it's 10! * 2^10
06:43:08 <Botje> so about 7 billion combinations.
06:43:13 <aflash> Hehe, thats right
06:43:15 <Botje> now that i think of it :P
06:43:20 <aflash> hehe, bruteforce :P
06:43:23 <mauke> it's háµ«g
06:44:00 <Botje> aflash: but you can prune the search tree by eliminating elements sooner rather than later.
06:46:43 <aflash> I have to go no. Botje: seems like a good idea, I will look into it later
06:46:49 <Botje> okay
06:46:52 <Botje> have fun!
06:46:58 * Botje goes back to writing
06:47:03 <aflash> Thank you for the help
06:47:05 <aflash> \quit
06:54:55 <sohum> @pl \(x,y) -> mplus x y == mzero
06:54:55 <lambdabot> uncurry (flip flip mzero . ((==) .) . mplus)
06:55:06 <sohum> ...wow
06:56:51 <mauke> :t uncurry (((== mzero) .) . mplus)
06:56:52 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Eq (m a)) => (m a, m a) -> Bool
06:56:59 <opqdonut> gah, mauke beat me to it
06:57:01 <mauke> @unpl uncurry (((== mzero) .) . mplus)
06:57:01 <lambdabot> uncurry (\ e h -> (mplus e h) == mzero)
06:59:15 <sohum> @hoogle Monad m => m a -> a
06:59:15 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
06:59:16 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
06:59:16 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
06:59:32 <sohum> @hoogle MonadPlus m => m a -> a
06:59:32 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
06:59:32 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
06:59:32 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
06:59:57 <dibblego> sohum, trying to escape from IO are we?
06:59:57 <lambdabot> dibblego: You have 1 new message. '/msg lambdabot @messages' to read it.
07:00:05 <sohum> dibblego: nope, from Maybe
07:00:17 <sohum> dibblego: either Maybe or List, I can't decide which
07:00:25 <mauke> sohum: uh, just use pattern matching
07:00:28 <dibblego> sohum, might I recommend fromMaybe or the more dangerous fromJust
07:00:28 <sohum> dibblego: which is why I wanted a general one
07:00:53 <dibblego> sohum, what value would Nothing or [] return?
07:01:01 <sohum> dibblego: an error, of course
07:01:08 <mauke> what value would [10, 10, 12] return?
07:01:12 <dibblego> then you want fromJust or head
07:01:13 <sohum> mauke: head
07:01:58 <sohum> there's no Extractable typeclass?
07:02:02 <sohum> or similar?
07:02:08 <dibblego> @type head . Data.Foldable.toList
07:02:08 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> a
07:03:04 <sohum> > (head . Data.Foldable.toList) (Maybe 4)
07:03:04 <lambdabot>   Not in scope: data constructor `Maybe'
07:03:13 <sohum> bah, I always do that
07:03:17 <sohum> > (head . Data.Foldable.toList) (Just 4)
07:03:17 <lambdabot>   4
07:03:25 <sohum> > (head . Data.Foldable.toList) Nothing
07:03:26 <lambdabot>   * Exception: Prelude.head: empty list
07:03:35 <sohum> cool
07:03:44 <sohum> I'll have to look into Foldable
07:03:47 <sohum> thankee, dibblego
07:10:27 <sohum> incidentally, does haskell have the generic case? where it isn't the one thing you're always comparing against, it's just an alternative way to write nested ifs?
07:11:24 <mauke> case () of _ | cond1 -> foo | cond2 -> bar | otherwise -> baz
07:11:29 <Botje> case () of _ | condition1 -> ...; _ | condition2 -> ...
07:11:49 <sohum> ah
07:12:10 <sohum> so guards, basically, right
07:12:12 <sohum> thankee
07:19:33 <jmcarthur> @check \e -> either (+1) (+2) e == ((+1) ||| (+2)) e
07:19:34 <lambdabot>   "OK, passed 500 tests."
07:19:37 <jmcarthur> huh
07:20:43 <sohum> is there any way to compare with mzero without requiring the contained type be of Eq?
07:22:12 <sohum> :t (mzero ==)
07:22:13 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Eq (m a)) => m a -> Bool
07:22:46 <jpcooper> (Read a, Show b) => data Transporter a b = Transporter {send :: (b -> IO (Either Success TransportError)),
07:22:47 <jpcooper>                                                         receive :: IO  (Either a TransportError)}
07:22:50 <jpcooper> how can I do something like that?
07:23:42 <Axman6> jpcooper: firstly, putting constraints on types is a bad idea in general. secondly, you'd use type (Foo a) => Bar a = ...
07:23:46 <jpcooper> I suppose I can add those to the types of the functions in there
07:24:19 <benmachine> yeah, if you look at the Map class, the Ord k constraint is mostly enforced by the handler functions
07:24:30 <benmachine> and by mostly I mean solely
07:24:38 <jpcooper> okay
07:25:35 <benmachine> @botsnack
07:25:35 <lunabot>  :o
07:25:35 <lambdabot> :)
07:25:46 <Botje> @hoogle singleton
07:25:46 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
07:25:46 <lambdabot> Data.IntMap singleton :: Key -> a -> IntMap a
07:25:46 <lambdabot> Data.IntSet singleton :: Int -> IntSet
07:26:12 <benmachine> :t insert
07:26:13 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
07:26:19 <benmachine> erm
07:26:23 <benmachine> @hoogle insert
07:26:23 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
07:26:23 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
07:26:23 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
07:26:29 <Botje> so you can create singleton maps and sets for types that are not Ord. cool :)
07:26:47 <benmachine> @type Data.Map.insert
07:26:48 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
07:26:51 <benmachine> there we go
07:27:04 <benmachine> so you can make singleton maps without an Ord key, but you can't make anything else :P
07:30:18 <huntse> > newType Tick a = Tick { t :: UTCTime, , v :: a }
07:30:19 <lambdabot>   <no location info>: parse error on input `='
08:00:47 <liquid> http://cambio.mendigogame.es/change_please/1687023/
08:00:48 <lambdabot> Title: Mendigogame
08:01:48 --- mode: ChanServ set +o mauke
08:01:49 --- mode: mauke set +b *!*@44.231.221.87.dynamic.jazztel.es
08:02:41 <mauke> http://mauke.ath.cx/tmp/dev.html
08:02:42 <lambdabot> Title: Developers Developers Developers Developers Developers Developers Developers Dev ...
08:02:48 --- mode: mauke set -o mauke
08:10:56 <jeffwheeler> I'm having a lot of trouble building gtk2hs on Windows, because 'make' fails with lots of weird errors related to autom4te.
08:11:31 <jeffwheeler> Is it possible to rebuild the binary installer using 6.10.4?
08:11:39 <dcoutts> jeffwheeler: yes, I did
08:11:57 <jeffwheeler> dcoutts: oh, that's awesome; where can I find it?
08:12:13 <Crito> heh. Interesting. freenode uses 'requested by' instead of 'removed by'
08:12:15 <dcoutts> jeffwheeler: the one I rolled is only minimal though, so if you need the extra stuff like glade etc then you'll need to do your own or wait
08:12:35 <jeffwheeler> dcoutts: found it: http://www.mail-archive.com/gtk2hs-devel@lists.sourceforge.net/msg00340.html; this may be just perfect
08:12:40 <lambdabot> Title: [Gtk2hs-devel] minimal windows build for ghc-6.10.4, http://tinyurl.com/q69utj
08:12:45 <jeffwheeler> dcoutts: I mostly just need it for doing Yi work
08:12:45 <dcoutts> right
08:12:54 <benmachine> so what do dudes recommend as a source preprocessor if I think CPP is boring?
08:13:41 <dcoutts> jeffwheeler: looks like the minimal one is ok for you then
08:13:45 <sohum> @instances Foldable
08:13:45 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
08:13:46 <Botje> benmachine: XSLT!
08:13:56 <SamB_XP> benmachine: m5!
08:14:04 <Botje> never a dull moment with xslt >:)
08:14:11 <benmachine> heheh
08:14:15 <SamB_XP> xslt is a bit verbose ;-P
08:14:18 * benmachine hasn't heard of m5
08:14:28 <SamB_XP> benmachine: I figure it must be better than m4 ;-P
08:14:42 <benmachine> It runs from a junction with the M6 at Great Barr near Birmingham to Exeter in Devon.
08:14:52 <chessguy_> @instances-importing Data.Foldable Foldable
08:14:53 <lambdabot> Maybe, []
08:15:26 <sohum> chessguy_: thanks, was just looking up the syntax
08:16:00 <FunctorSalad_> @halp instances-importing
08:16:00 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
08:16:10 <benmachine> so does everyone just use cpp then
08:16:56 <gwern> dcoutts: I've long wondered - why doesn't gtk2hs just take the autotools output and use that? what requires systemic changes and regeneration of .cabal files?
08:17:06 <gwern> benmachine: pretty common yeah
08:17:30 <benmachine> fair enough
08:17:40 <benmachine> is anyone going to reimplement cpp in haskell
08:17:42 <benmachine> just for fun
08:17:50 <Saizan> already done
08:17:56 <benmachine> :D
08:17:59 <Saizan> ?hackage cpphs
08:18:00 <lambdabot> http://hackage.haskell.org/package/cpphs
08:18:05 <benmachine> nice
08:18:08 <benmachine> thx
08:18:13 <gwern> well, it's not like cpp is too terribly complex
08:18:51 <Makoryu> benmachine: Now to write the *rest* of a C compiler....
08:19:05 <dcoutts> gwern: I'm not sure I understand what you mean?
08:19:15 <benmachine> it's not that hard to write a bad C compiler is it
08:19:41 <benmachine> it's just if you want something that anyone'd ever use
08:19:42 <SamB_XP> benmachine: not with a decent C parser ...
08:19:57 <gwern> dcoutts: well, the autotools configure and then race through the .cabal files, replacing various @foo@ thingies and then doign configure/build/install. why not run the tools, and commit the changes to the cabal files, so everything could be uploaded to hackage?
08:19:59 <SamB_XP> but writing that might be rather hard
08:20:09 <gwern> SamB_XP: thought we had one
08:20:21 <SamB_XP> well, yeah, we do
08:20:29 <dcoutts> gwern: it never generates .cabal files, it generated the installed package info files
08:20:37 <SamB_XP> I was just saying, I don't think it was that easy to write ;-)
08:20:53 <gwern> SamB_XP: oh. well, it wasn't tis true!
08:21:01 <gwern> dcoutts: what are those?
08:21:10 <dcoutts> gwern: the input to ghc-pkg register
08:21:36 <dcoutts> gwern: Cabal makes them for you so you don't usually see them. Same format as the ghc-pkg describe output
08:21:43 <gwern> hum. that does sound more complex
08:21:51 <dcoutts> gwern: also, the gtk2hs build system builds the .chs files in the correct order
08:22:24 <SamB_XP> dcoutts: is there a bug about cabal not doing that ?
08:22:27 <dcoutts> gwern: the key things to be able to switch over are 1. moving to mainline c2hs (not the fork) and 2. getting Cabal to handle .chs deps
08:22:31 <dcoutts> SamB_XP: yes
08:22:38 <dons> Makoryu: http://hackage.haskell.org/package/language-c
08:22:38 <lambdabot> Title: HackageDB: language-c-0.3.1.1
08:22:39 <gwern> one day...
08:23:39 <dcoutts> gwern: if you'd like to help I can point out the various sub-tasks :-)
08:24:18 <dcoutts> gwern: and there's the option to do hacky things in Setup.hs files rather than doing it properly in Cabal.
08:24:31 <Makoryu> dons: Hmmm. Excellent! Now to wire it up to an optimizer/code generator and spend over 9000 man hours writing what's just supposed to be glue code...
08:24:33 <dcoutts> which might get things moving a bit quicker
08:24:36 <gwern> dcoutts: I'd rather work on default-build-from-sdist :)
08:24:54 <dcoutts> gwern: the "make disttest" thing?
08:24:58 <gwern> that'd be more valuable to me. or CHANGELOG support
08:25:03 <dcoutts> right
08:25:09 <dcoutts> all good useful stuff
08:25:14 <gwern> dcoutts: as I've long said, I think cabal should build from sdist by default
08:25:24 <dcoutts> what do you mean?
08:25:36 <gwern> if you suspect you've forgotten something, then you aren't the sort of person who really needed the feature in the first place
08:26:12 <gwern> it wouldn't be any more of a pain for users than cabal's fascist approach to build-depends, at least :)
08:26:43 <dcoutts> gwern: we could make cabal upload require a cabal check --whatever first :-)
08:27:14 <gwern> dcoutts: mm. but then we'd get false failures due to the usual issues of platforms and ffi wouldn't we? so it could only be advisory
08:27:24 <CalJohn> {-# LANGAGE OverloadedStrings #-} <-- why does ghci complain that this is an unrecognised pragma?
08:27:38 <gwern> and our advisory haddock checks don't seem to encourage many authors to make their haddocks beautiful...
08:27:59 <dcoutts> gwern: what advisory haddock checks?
08:28:14 <gwern> dcoutts: you know, the build reports?
08:28:20 <dcoutts> oh right
08:28:23 <gwern> hackage configures, build, then build haddocks
08:28:24 <FunctorSalad_> CalJohn: LANGUAGE
08:28:31 <CalJohn> FunctorSalad_: silly me
08:28:33 <hackagebot> dyre 0.8.0 - Dynamic reconfiguration in Haskell (WillDonnelly)
08:28:34 <dcoutts> gwern: people will pay more attention once we start handing out gold QA stars and sad faces on hackage
08:28:35 <FunctorSalad_> :)
08:28:48 <gwern> heh. wait, are you serious?
08:28:55 <dcoutts> gwern: absolutely
08:29:33 <gwern> dcoutts: so would the upload check be asynchronous like the current buildreports?
08:29:53 <dcoutts> gwern: yes, most of these checks have to be async
08:30:20 <dcoutts> gwern: which is a good argument for a beta.hackage.haskell.org
08:30:50 <dcoutts> upload there, get feedback and shift it over if it passes the battery of tests
08:30:58 <gwern> mm. I'm not sure that's good. asynchronous is fine when the tests give false positives, like a gtk package uploaded would always fail even if it's fine; but there can't be false negatives or positives if we force build-from-sdist - if it doesn't work on the dev's machine how is it going to work anywhere?
08:31:17 <gwern> omitting necessary modules is a major QA issue
08:31:43 <dcoutts> gwern: there's a proper fix for that, but it's a bit more tricky
08:31:55 <dcoutts> for that specific issue of missing "other-modules"
08:32:02 <gwern> what's the fix?
08:32:15 <dcoutts> gwern: the long term on is that cabal does the import chasing
08:32:43 <dcoutts> gwern: a short term one might be to ask ghc at the end, (eg ghc -M) what modules it thinks are being used
08:32:51 <gwern> does the import chasing? what , if the build errors out with missing modules, cabal will retry looking in all child directories?
08:33:06 <gwern> or are we abandoning explicit module lists a la build-depends?
08:33:16 <dcoutts> gwern: I mean cabal taking over the job of ghc --make
08:33:52 <dcoutts> gwern: then we have the option of warning or erroring out over unspecified modules
08:35:39 <gwern> hm. I don't have an opinion on that. but I think what I like about build-from-sdist is that it makes your current directory more == your cabal package
08:36:01 <gwern> as it is, it's very easy to create something which works brilliantly in your repo but which you can't distribute, entirely unawares
08:36:11 <etpace> @pl \x -> (10 mod x) /= 0
08:36:11 <lambdabot> (0 /=) . 10 mod
08:36:14 <dcoutts> gwern: sometimes that's a feature
08:36:33 <gwern> for testing, sure
08:36:53 <gwern> you don't always want to distribute and integrate your test infrasturcture or random drafts
08:36:59 <dcoutts> gwern: eg some of the cabal packages in the ghc tree cannot work with sdist since they use paths like ../blah
08:37:04 <gwern> but compilation should always work
08:38:18 <dcoutts> gwern: there's a tradeoff to be made, I fully agree that we want to check as much stuff before/when it gets into hackage, but a tool that screams at you when you're just making a local throw-away script is a bit annoying
08:38:34 <gwern> when do you cabalize a throw-away script?
08:38:36 <dcoutts> gwern: eg I'd like to get cabal to be able to build stuff without any .cabal file
08:38:44 <dcoutts> like we use ghc --make now
08:39:00 <dcoutts> but support for pre-processors, fetching deps, whatever
08:39:05 <gwern> hum. sounds like a task for the AI strike force...
08:39:12 <dcoutts> generating minimal .cabal files
08:39:30 <dcoutts> gwern: only using the info we can glean from the sources, like ghc --make does
08:39:54 <gwern> that really does sound like a bridge too far
08:40:01 <dcoutts> I don't think so
08:40:10 <dcoutts> but it needs a decent build system within Cabal
08:40:13 <dcoutts> something that's lacking atm
08:40:35 <dcoutts> gwern: hmake was doing this years ago
08:40:37 <gwern> cabal-install shouldn't be all things to all developers; it's a declarative build system which is easy to work with & easy to compile into various distribution formats
08:40:47 <gwern> that's hard enough
08:41:09 <dcoutts> it needs a sensible architecture that's for sure
08:41:16 <SamB_XP> well, yeah, why not make another tool built on the cabal lib that does that job ?
08:41:16 <dcoutts> so it doesn't become spageti
08:41:17 <jjohnsson> is there any way to use variables that start with an upper case character in haskell? I really like using T for temperature and t for time, for example. And C would be some arbitrary constant, and c is the speed of light.
08:41:41 <dcoutts> gwern: the aim is that 'cabal' is just the CLI and all the smarts are in various libs
08:41:49 <mauke> jjohnsson: no
08:41:51 <Saizan_> a good thing would be to spin off an hackage-client library
08:41:53 <gwern> jjohnsson: use a unicode character that looks like T? :)
08:41:58 <dcoutts> Saizan_: indeed
08:42:20 <dcoutts> Saizan_: that was on my "cabal 2" architecture slide in my talk at the HIW
08:42:27 <SamB_XP> jjohnsson: you could use Coq or something ;-P
08:42:47 <jjohnsson> mauke: ok. sad. can a function name start with something other than alphabetical, so I can cheat by starting the names with some silent character?
08:42:55 <Twey> jjohnsson: Try t' for temperature.
08:43:06 <Makoryu> jjohnsson: The use of upper/lower case in Haskell was chosen as the most straightforward way to distinguish between variables and concrete types/constructors, which is a distinction that you really need to be able to make in Haskell.
08:43:20 <dcoutts> Saizan_: split Cabal into cabal-lib and cabal-build, have cabal-build depend on a generic make lib (like some future version of your hbuild lib) and then cabal depends on all of those + hackage-client
08:43:39 <SamB_XP> Makoryu: yeah, it is kind of important with no explicit forall in types ...
08:43:52 <huntse> jjohnsson: Sometimes doing the idiomatic thing is best.  Why try to swim upstream?
08:44:25 <Saizan_> dcoutts: so you think splitting Cabal is a prerequisite to expose hackage-client?
08:44:29 <dcoutts> Saizan_: btw, what are you working on atm? What can I recruit you into doing :-)
08:44:37 <dcoutts> Saizan_: no, that bit is not a prerequisite
08:44:50 <jjohnsson> huntse: I also like doing the "idiomatic thing" so that my code is easily read by physicists. we have conventions too, that we're quite used to.
08:44:54 <dcoutts> Saizan_: getting a hackage-client is mostly a matter of turning bits of cabal-install into a lib
08:45:28 <Saizan_> dcoutts: nothing specific, atm :)
08:45:37 <dcoutts> Saizan_: and it'd be pretty useful to do soon since we'll need more specialised clients, like building docs for the new hackage server
08:45:47 <Makoryu> jjohnsson: You know that the underscore is considered lowercase, don't you? :p
08:45:52 <jjohnsson> Makoryu: ok, I see there is some need for this restriction.
08:46:01 <dcoutts> Saizan_: perhaps I can persuade you to help us with the hackage-server and/or the interactions with the clients
08:46:11 <jjohnsson> Makoryu: no, I didn't.
08:46:21 <gwern> a leading underscore is not recommended, because that is interpreted specially by ghc
08:46:22 <SamB_XP> jjohnsson: well, not strictly-speaking ...
08:46:25 <jjohnsson> need to think of some non-ugly way to write my code.
08:46:35 <SamB_XP> we could have done like ML and used ' instead of lowercase, I think
08:46:45 <gwern> if you use variables with leading underscores, GHC will never warn you if you don't use it, for example
08:47:08 <SamB_XP> it's also interpreted specially by programmers ;-)
08:47:10 <Saizan_> dcoutts: yeah, do you have something in particular?
08:47:27 <Makoryu> SamB_XP: And then we'd have inconsistent syntax between the type and value namespaces.... Though that might be a good thing
08:47:31 <SamB_XP> like "oh, that must be some kind of secret, ugly implementation detail"
08:47:38 <SamB_XP> "even if it's exported"
08:47:43 <Berengal> We could've allowed arbitrary casing, but that just moves the restriction to some other piece of grammar
08:47:46 <dcoutts> Saizan_: I'm sure I can find something... -> #haskell-overflow
08:47:58 <Makoryu> gwern: Whoops
08:48:07 <SamB_XP> Makoryu: or, we could have used explicit foralls from the start
08:48:12 <jjohnsson> I understand the problem. Just that my worlds clash. :)
08:48:27 <SamB_XP> like basically every language which *actually* has one syntax for types and values ;-)
08:48:35 <Berengal> jjohnsson, the alternative, using 'time' and 'temperature' isn't too horrible, is it?
08:48:54 <SamB_XP> Berengal: yes, yes it is
08:48:59 <jjohnsson> Berengal: well, in some formulas it might.
08:49:10 <SamB_XP> jjohnsson: I can suggest just sticking a v in front
08:49:14 <SamB_XP> or something
08:49:57 <jjohnsson> yes, I suppose. it seems like I have to add some "noise", then.
08:50:02 <SamB_XP> of course, that could get confusing with v=velocity or v=time-varying voltage ;-)
08:50:32 <SamB_XP> or, you could just use "temp" when you really need a temperature ...
08:50:39 <SamB_XP> and keep using t for time
08:50:53 <Berengal> I must be too used to single-letter variables providing only very weak hints at it's purpose at most...
08:51:32 <Makoryu> jjohnsson: If you really want your code's purpose to be as clear as possible to people only familiar with the formulas, write the whole thing as LHS and document it with the actual formula encoded in TeX
08:51:35 <SamB_XP> jjohnsson: what are you writing ?
08:52:21 <Berengal> ... might be possible to do something with a quasiquoter...
08:52:22 <SamB_XP> hmm, can't some LHS processors actually let you reformat your variables for more pretty ?
08:52:34 <jjohnsson> SamB_XP: I'm just going to try to (re)write our model for a laser-based diagnostic technique using haskell.
08:52:50 <SamB_XP> jjohnsson: what quantities does it use most heavily ?
08:53:39 <jjohnsson> Makoryu: yes, I've thought of that. and maybe it's just that I'm used to some conventions. It's not like the physics is the majority of the code. I just want it to be clear and easy to read. Of course I document it anyway.
08:55:53 <SamB_XP> jjohnsson: well, what does the model diagnose ?
08:55:58 <SamB_XP> does it involve velocity?
08:56:20 <SamB_XP> if not, I'd suggest just prefixing all your physicsy variables with v ;-)
08:56:21 <jjohnsson> no
08:56:37 <jjohnsson> yes, maybe that'll do.
08:57:04 <SamB_XP> that would have the bonus of making your physicsy variables easy to tell from your programmingy variables ;-)
08:57:07 <Twey> I don't see what's wrong with suffixing a ' to represent capitals.
08:57:11 <jjohnsson> my Matlab habits die hard. :)
08:57:23 <SamB_XP> hehehe
08:58:02 <SamB_XP> my matlab habbits mostly consist of trying to do FP even with it's pathetic facilities for same ;-)
08:58:03 <jjohnsson> Twey: If I read t', that would to me seem like some alternative time measure, or maybe an integration variable over time. I wouldn't think of temperature. but of course that could be done as well.
08:58:35 <SamB_XP> jjohnsson: not a differentiation of time with respect to time ;-P?
08:58:56 <jjohnsson> SamB_XP: yeah, that is quite useful... :P
08:59:02 <Petrosian> Why not use _T?
08:59:08 <Petrosian> > let _T = 1 in _T
08:59:08 <lambdabot>   1
08:59:19 <jpcooper> SamB_XP, habits and its
08:59:21 <SamB_XP> Petrosian: gives both GHC and programmers the wrong impression
08:59:23 <Makoryu> Petrosian: GHC warnings
08:59:25 <SamB_XP> jpcooper: oh, true
08:59:35 <Twey> Petrosian: GHC treats underscore-variables specially
08:59:52 <Petrosian> Twey: How so?
08:59:54 <SamB_XP> and, as I mentioned above, so do most programmers ;-)
08:59:57 <Twey> They're not expected to be used and (IIRC) aren't memoised
09:00:01 <Twey> Aye.
09:00:05 <SamB_XP> Twey: nothing is memoized!
09:00:19 <SamB_XP> unless you memoize it yourself, I mean
09:00:26 * Twey scratches his head.
09:00:37 <SamB_XP> Twey: unless you meant okasaki-style ...
09:00:49 <sohum> is there a way to automatically descend an ADT recursively? as in, data Tree a = Leaf a | Node (Tree a) (Tree a); ppr (Leaf x) = show x; ppr t@(Tree a) = descend ppr t
09:01:01 <benmachine> :t forever evalStateT
09:01:01 <lambdabot> forall s (m :: * -> *) a b. (Monad m) => StateT s m a -> b
09:01:06 <Berengal> _foo only affects warnings
09:01:08 <benmachine> ^ dang this tripped me up
09:01:14 <Twey> Well, it does *something* to do with memoisation.  I'm fairly sure I remember reasonably clearly it being said by someone at some point in the past!
09:01:24 <jjohnsson> thanks all for your help. I'll consider my options. :) need to leave now.
09:01:26 <SamB_XP> benmachine: what the ?
09:01:26 * benmachine had forever evalStateT myStateT
09:01:36 <Twey> Hahaha
09:01:38 <SamB_XP> :t forever
09:01:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
09:01:48 --- mode: ChanServ set +o mauke
09:01:48 --- mode: mauke set -b *!*@44.231.221.87.dynamic.jazztel.es
09:01:52 <SamB_XP> :t evalStateT
09:01:52 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
09:02:01 <SamB_XP> benmachine: hmm, reader monad strikes again?
09:02:06 <benmachine> guess so
09:02:23 <benmachine> seems there is such a thing as too much polymorphism >_>
09:02:33 <Twey> Hehe
09:02:48 --- mode: mauke set -o mauke
09:02:55 <SamB_XP> too bad instances aren't imported more explicitly, I guess :-(
09:03:04 <SamB_XP> in this case
09:03:40 <Berengal> The function monad instance is almost always imported. Don't be too surprised
09:03:42 <SamB_XP> though I don't think even Coq actually works that way -- though of course with coq you could Print your function after defining it and see that it was referencing setoid_eq when you wanted some other instance ...
09:03:58 <SamB_XP> er. eq_setoid.
09:04:01 <SamB_XP> whatever ;-)
09:06:47 <SamB_XP> see, in Coq, typeclass instance dictionaries are passed around in the user-level term language
09:07:30 <Berengal> Twey, preliminary googling doesn't show anything about underscores affecting memoization
09:08:04 <Twey> Hmn, okay.
09:09:38 <SamB_XP> ... but the typeclass-dictionary arguments use an extension of Coq's implicit argument facility, and an attempt is made to automatically resolve them unless they are explicitly passed (by name) in the code
09:10:26 <SamB_XP> so incoherant instances are *not* a huge problem in Coq
09:12:30 <SamB_XP> ... though, historically, I've had a lot of cases where I was trying to use some specific Setoid instance but it picked eq_setoid (which is applicable basically everywhere, I believe) instead :-(
09:27:25 <Woof> Cale! lambdabot has left my channel : (
09:28:25 <Woof> > "test"
09:28:26 <lambdabot>   "test"
09:28:29 <Woof> Hm
09:28:44 <Woof> She's left #functionaljava too
09:37:14 <hackagebot> data-accessor-template 0.2.1.2 - Utilities for accessing and manipulating fields of records (HenningThielemann)
09:37:22 <jeffwheeler> and #yi!
09:50:19 <hackagebot> hlint 1.6.9 - Source code suggestions (NeilMitchell)
09:53:40 <Gracenotes> when will it stop raining..
09:55:46 <nlogax> yo, i don't know
09:59:32 <jeffwheeler> dcoutts: thanks again for the binary installer; that was awesome
09:59:56 <jeffwheeler> Now I'm just stuck on figuring out regex-posix problems (there's an old thread with the issue which I might revive)
10:00:03 <jeffwheeler> but I've got to go for now, so thanks
10:03:47 <zenzike> I'm trying to compile the source of the darcs version of haskeline, and I've compiled the Setup.hs file. When I do Setup configure, I get told that mtl and utf8-string are missing -- yet using cabal list shows that the right versions are there -- can anybody help?
10:04:43 <Berengal> zenzike, try --user
10:06:04 <zenzike> thanks, that's worked :-)
10:13:04 <dcoutts> zenzike: or just use 'cabal' instead of 'runghc Setup'
10:14:19 <zenzike> dcoutts: I'm guessing that cabal would install the package right into my .cabal directory though? Since I'm modifying haskeline, I didn't want an actual installation, so I've just left it at Setup build, and linking the libraries produced when I need them
10:14:42 <dcoutts> zenzike: cabal configure; cabal build
10:15:02 <dcoutts> zenzike: the cabal program subsumes the runghc Setup command line interface
10:15:06 <zenzike> dcoutts: ah, brilliant :-)
10:15:50 <zenzike> dcoutts: it turns out that modifying haskeline to play well with our colouring is a lot harder than we imagined
10:16:07 <dcoutts> zenzike: ah
10:16:17 <dcoutts> zenzike: it likes to render the output itself I suppose
10:16:28 <dcoutts> does it support colour itself?
10:16:50 <dcoutts> zenzike: if it's really hard then perhaps email the author and ask for suggestions
10:17:04 <zenzike> dcoutts: I don't think it does colour itself, no. in addition, it does a whole load of other stuff before it actually gets to output
10:17:11 <dons> zenzike: also, you might play with iavor's http://hackage.haskell.org/package/colorize-haskell
10:17:12 <lambdabot> Title: HackageDB: colorize-haskell-1.0.0
10:17:42 <zenzike> dcoutts: I already emailed Judah about some of the issues, I'm still trying to understand all his code :)
10:17:52 <zenzike> dons: thanks, I'll have a look
10:18:11 <dcoutts> dons: the main difference is that ghci should be using ghc's lexer
10:19:33 <zenzike> geesh. I'm always typing "cabal show" instead of "cabal list"; muscle memory from aptitude
10:19:35 <dons> yeah. iavor's code is bsd-licensed too, so that makes it easier
10:24:50 <zenzike> dons: ah, colourize-haskell looks like a drop-in bsd replacement of HsColour?
10:28:23 <thaldyron> dcoutts: Is cabal-install HEAD supposed to build with Cabal HEAD? (right now it doesn't for me so I'm wondering if I'm doing something wrong...)
10:29:48 <dcoutts> thaldyron: not at the moment, I need to finish changing things in Cabal and then update cabal-install
10:46:08 <dcoutts> jfredett: Congratulations on becoming the new HWN editor!
10:46:35 <dcoutts> jfredett: can I suggest that you look at the line wrapping on the email version of the news
10:46:47 <dcoutts> it's a tad messed up
10:49:33 <byorgey> really?  the line wrapping looks OK to me
10:49:39 <byorgey> dcoutts: where is it messed up?
10:50:18 <dcoutts> @hpaste
10:50:18 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:51:07 <dcoutts> byorgey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3579#a3579
10:51:31 <dcoutts> byorgey: it all wraps at 72 columns or something
10:51:40 <BMeph> Is there a way to specify in your program, which package to get an imported module?
10:51:52 <kmc> BMeph, there's a ghc extension
10:52:00 <byorgey> dcoutts: oh, weird, doesn't look like that in my mail reader.
10:52:25 <kmc> import "network" Network.Socket
10:52:32 <kmc> -XPackageImports
10:52:43 <Igloo> byorgey: I see something differently wrong
10:53:26 <BMeph> kmc: Excellent; that, I can use. Thanks! :)
10:53:43 <Igloo> I think mutt's rewrapped it, as it's format=flowed, except there are also some hard line breaks
10:54:10 <zenzike> byorgey: mine looks just fine
10:54:14 <Igloo> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3579#a3580 is what I see, anyway
10:54:29 <kmc> on a related note, when I do ":m + Control.Monad.State" in ghci, it gives me an error and says "it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2"
10:54:41 <kmc> should i remove one of these, and if so can i do it through cabal
10:54:48 <benmachine> you can hide one of them
10:54:59 <Igloo> And http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3579#a3581 is the source
10:55:00 <kmc> with ghc-pkg?
10:55:03 <benmachine> yeah
10:55:04 <benmachine> or
10:55:08 <dcoutts> kmc: ghc-pkg hide --user monads-fd
10:55:09 <benmachine> with ghc -hide-package
10:55:13 <benmachine> or whatever it is
10:56:57 <kmc> i'm going to be adventurous and hide mtl instead :)
10:57:08 <Igloo> Oh, and the charset looks wrong too, unless Mr Fourn<sqrt><copyright> has been writing Haskell libraries  :-)
10:57:50 <gwern> M. Fourn<sqrt><copyright>, the eminent 20th century russian-american philosopher?
11:04:26 <EnglishGent^afk> @hoogle shift'
11:04:26 <lambdabot> No results found
11:08:19 <FunctorSalad_> does anyone know what happened to this? http://www.haskell.org/haskellwiki/LambdaCubeEngine
11:08:20 <lambdabot> Title: LambdaCubeEngine - HaskellWiki
11:08:26 <FunctorSalad_> 2009.06.18 - The first (cabalized) release is coming soon. (in 3 weeks)
11:34:18 <babusrini> How do I resolve this?
11:34:19 <babusrini> Windows, ghc 6.10.3: cabal.exe: Error: some packages failed to install: unix-2.3.2.0 failed during the building phase. The exception was ExitFailure
11:35:27 <dcoutts> babusrini: the only solution is to avoid installing the unix package on windows
11:36:19 <SamB_XP_> dcoutts: perhaps that should be specified in the .cabal file?
11:36:31 <SamB_XP_> so cabal install would quit trying to install it?
11:38:25 <babusrini> dcoutts, When I install gitit package it installs caucautious-file-0 which depends on unix-2.3.2.0 which failed to install.
11:38:49 <dcoutts> babusrini: I guess that means gitit will not work on windows at the moment
11:38:58 <dcoutts> talk to the author
11:39:41 <babusrini> dcoutts, thanks. Will do
11:40:01 <dcoutts> babusrini: ah, looks like you can build cautious-file without posix
11:40:11 <dcoutts> though the way it does it is a bit bonkers
11:40:20 <dcoutts> babusrini: try installing with -f -posix
11:41:26 <gwern> @quote 400
11:41:26 <lambdabot> ghc says: ld64: WARNING 47 : This module contains branch instruction(s) that might degrade performance on an R4000 processor.
11:41:30 <gwern> @quote 400
11:41:31 <lambdabot> ghc says: internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
11:41:33 <gwern> @quote 400
11:41:33 <lambdabot> ghc says: ld64: WARNING 47 : This module contains branch instruction(s) that might degrade performance on an R4000 processor.
11:41:42 <gwern> @quote than.*400
11:41:42 <lambdabot> No quotes match. Just what do you think you're doing Dave?
11:41:55 <gwern> @remember lispy All haskell lists have less than 400 elements
11:41:55 <lambdabot> Done.
11:42:02 <gwern> @quote dysfunctional
11:42:02 <lambdabot> tristes_tigres says: thinks that programming languages can be divided into two broad classes: functional and dysfunctional
11:42:06 <gwern> @quote dysfunctional
11:42:06 <lambdabot> tristes_tigres says: thinks that programming languages can be divided into two broad classes: functional and dysfunctional
11:42:09 <gwern> @quote dysfunctional
11:42:09 <lambdabot> tristes_tigres says: thinks that programming languages can be divided into two broad classes: functional and dysfunctional
11:42:21 <gwern> @quote C.*preprocessor
11:42:21 <lambdabot> No quotes match. My mind is going. I can feel it.
11:42:30 <gwern> @remember Jafet The C preprocessor is purely dysfunctional
11:42:30 <lambdabot> It is forever etched in my memory.
11:42:33 <Saizan> gwern: you could do that in privmsg
11:42:39 <gwern> Saizan: I COULD
11:42:48 <gwern> @quote dogs.*and
11:42:48 <lambdabot> No quotes match. There are some things that I just don't know.
11:42:51 <ibid> @quote applicable
11:42:51 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
11:42:57 <gwern> @remember edwardk so the -> is matched on the outside, but the ->  and , fail to match on the inside, unification fails, dogs and cats start living together in harmony, general chaos.
11:42:57 <lambdabot> I will never forget.
11:42:59 <copumpkin> o.O
11:43:11 <gwern> @quote fine.*precursor
11:43:11 <lambdabot> No quotes match. My mind is going. I can feel it.
11:43:15 <kmc> @quote php
11:43:15 <lambdabot> EvilTerran says: writing machine code by hand on tape with a magnetised needle looks good compared to PHP :P
11:43:23 <gwern> @remember yaxu [about lambdabot] an irc bot that no-one understands the workings of has to be a fine precursor to artificial intelligence
11:43:23 <lambdabot> Done.
11:43:30 <gwern> @quote \-Wall
11:43:30 <lambdabot> No quotes match. Maybe you made a typo?
11:43:34 <gwern> @quote Wall
11:43:34 <lambdabot> autrijus says: Woot. I got Larry Wall started learning Haskell ;)
11:43:38 <gwern> @quote Wall
11:43:39 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
11:43:45 <Saizan> are you protesting against lambdabot hazy memory, or what?
11:43:51 <gwern> hm. not case-sensitive
11:43:59 <gwern> Saizan: no, I'm protesting Vietnam
11:44:10 <gwern> @quote just.*another
11:44:10 <lambdabot> dons says: global state is just another pure value :)
11:44:13 <copumpkin> all 584 people definitely need to see all those quotes
11:44:21 <gwern> @quote just.*another.brick
11:44:21 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
11:44:23 <benmachine> well, I liked them
11:44:33 <gwern> @remember Gracenotes all in all, you're just another brick in the -Wall
11:44:33 <lambdabot> I will never forget.
11:44:34 <gwern> @flush
11:44:36 <ibid> @remember AlanJPerlis Purely applicative languages are poorly applicable.
11:44:36 <lambdabot> I will remember.
11:44:45 * gwern thinks it's surprising how many hits '400' gets
11:45:25 <ibid> yeah, all those broken web servers
11:46:06 <gwern> I also wonder why we have those ghc quotes; at some point I'm going to erase them all
11:46:17 <Saizan> because they are funny?
11:46:21 <gwern> but I can't because then the darcs repo's quote file won't commute with the live quote file...
11:46:25 <ibid> what does flush do?
11:46:36 <gwern> Saizan: they're funny? what sort of mental disease is required to make those ghc quotes funny?
11:46:53 <Saizan> ibid: makes it write out the state to disk
11:46:57 <ibid> ah
11:47:15 <Saizan> gwern: a compiler with a brain that explodes or similar is quite peculiar
11:47:35 <ibid> a compiler with a brain is quite peculiar
11:47:35 <gwern> Saizan: but the exploding errors aren't the question - look at the 2 or 3 that showed up
11:47:48 <gwern> what's funny about that branch warning? or that scavenge error?
11:47:50 <ibid> @quote explod
11:47:50 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
11:47:54 <Saizan> gwern: in all that flooding i can't find much
11:48:06 <gwern> here, let me help...
11:48:08 <gwern> @quote 400
11:48:08 <lambdabot> ghc says: ld64: WARNING 47 : This module contains branch instruction(s) that might degrade performance on an R4000 processor.
11:48:16 <gwern> show me teh funny
11:48:22 <eoeas> Hi, in a function definition, what does the "=>" stand for ??
11:48:22 <copumpkin> HAHAAHAHAHAHAHAHA
11:48:32 <kmc> eoeas, a typeclass context usually
11:48:35 <copumpkin> eoeas: class constraint
11:48:42 <kmc> eoeas, in a type signature?
11:48:58 <eoeas> :) thnx
11:49:35 <dolio> That question was pretty funny.
11:49:58 <Saizan> gwern: a warning about the presence of branch instructions? isn't that quite bizarre? (even if it probably has its reasons)
11:50:11 <sshc> how do I limit a type variable to a typeclass in a "data" definition?
11:50:14 <gwern> any error is bizarre. why should this error be in @quote?
11:50:22 <Saizan> not any error is
11:50:28 <dsouza> hi everyone ... could someone help me figuring out why aren't these two programs equivalent?
11:50:30 <Lemmih> sshc: You don't.
11:50:30 <dsouza> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3582#a3582
11:50:50 <dolio> You can, but you shouldn't.
11:50:52 <dsouza> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3583#a3583
11:51:05 <sshc> dolio: why not?
11:51:12 <sshc> dolio: if I did, how would I?
11:51:16 <dsouza> I was trying hard to solve this spoj problem: https://www.spoj.pl/problems/SBANK/
11:51:18 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem SBANK
11:51:20 <dolio> It doesn't buy you what people normally want from it.
11:51:33 <dolio> data Foo a => Bar a = ...
11:51:53 <babusrini> dcoutts, I tried -f -posix but I get the same error. pcre-light-0.3.1 failed during the configure step. The exception was: exit: ExitFailure 1 unix-2.3.2.0 failed during the building phase. The exception was: exit: ExitFailure 1
11:51:54 <dolio> But that still requires signatures like "Foo a => ... Bar a ..." on all functions.
11:51:55 <dsouza> but couldn't get this right in haskell ... then I tried it in C++ and got AC (accepted). But I can't tall why the haskell version didn't work
11:51:58 <copumpkin> sshc: it will restrict what you pass the constructor, but you won't get the context from it
11:52:17 <copumpkin> dolio: is there a fundamental reason for that? couldn't the fact that the context isn't passed on be seen as a bug?
11:52:30 <copumpkin> and don't GADT constructors retain the context?
11:52:33 <kmc> sshc, you might want to use GADT style instead
11:52:57 <dolio> It's a bug in the report if it's a bug, I think.
11:53:03 <copumpkin> yeah
11:53:12 <kmc> data Foo a where { Foo:: (Show a) => a -> Foo a }
11:53:16 <copumpkin> still wondering if it was intentional, or just an oversight
11:53:17 <dolio> In previous versions, there was a reason, because seq required a context.
11:53:20 <kmc> that will probably do what you want
11:53:21 <copumpkin> ah
11:53:41 <dolio> So 'data Eval a => Foo a = Foo !a' was the only way to use strictness annotations in datatypes.
11:53:51 <gwern> proper context pah. it's always a good time for seq!
11:54:08 <dolio> But that's no longer required, so contexts on data is kind of useless.
11:54:11 <copumpkin> wow
11:54:20 <kmc> also existentials use the same syntax -- you just mention a tyvar that's not in the result type
11:54:43 <dcoutts> babusrini: so that's two separate problems, one you almost certainly do not have the pcre C lib installed, and 2, there's still something else that depends on the unix package
11:54:53 * gwern ruminates again on how FPers seem to have a gift for bad names. I mean, really, what one one infer from names like 'Coq' or 'seq'?
11:55:12 <copumpkin> what does coq have to do with it?
11:55:24 <gwern> copumpkin: surprised by coq, eh?
11:55:30 * copumpkin loves the coq
11:55:36 <copumpkin> -the, whoops
11:55:41 <Badger> hurr hurr
11:55:57 <copumpkin> le coq sportif!
11:56:54 <dolio> Stalin's a pretty well chosen name, too.
11:57:08 <copumpkin> I agree that seq's a bit of a silly name
11:57:11 <gwern> dolio: at least stalin isn't obscene
11:57:14 <copumpkin> Coq is cute
11:57:32 * copumpkin names his new language Poulet
11:57:42 <dolio> So Hitler would be a better name than Coq, too?
11:57:52 <gwern> YES
11:58:16 <kmc> i am disappointed that there is no tool named CoqBlock
11:58:29 <copumpkin> http://fr.wikipedia.org/wiki/Gallus_gallus_domesticus
11:58:31 * Saizan wonders if gwern is going to kill all the roosters in france
11:58:49 <gwern> Saizan: and once I finish with them, the dogs
11:59:06 <copumpkin> in the style of the Inglourious Basterds
12:00:41 <FunctorSalad_> "Did you really have to name it like that?" (coq FAQ)
12:00:47 <_dsouza_> ouch! got disconnected ... did I miss any reply :-)
12:03:37 <copumpkin> "Some French computer scientists have a tradition of naming their software as animal species: Caml, Elan, Foc or Phox are examples of this tacit convention. In French, âcoqâ means rooster, and it sounds like the initials of the Calculus of Constructions CoC on which it is based."
12:05:18 <dolio> Maybe you can start to swing things the other direction.
12:05:24 <dolio> Hitler COBOL compiler.
12:05:41 <kmc> ha, it's the second question
12:05:58 <gwern> there's actually probably a lot of money in good COBOL compilers, since you'll have next to no competition from FLOSS...
12:07:18 <Athas> But you're catering to a super-conservative market.
12:07:27 <Vanadium> surely we can hack something together with parsec in like five minutes
12:07:31 <Athas> It's not like anyone decides to write new Cobol on a new platform.  Right?
12:07:53 <dolio> Hopefully.
12:08:02 <Vanadium> Athas: Surely you have seen http://www.coboloncogs.org/
12:08:35 <Saizan> what about a cobol quasiquoter? so you can really write cobol in haskell, not just in spirit like the other languages.
12:08:38 <dolio> Heh, "DATE OVERFLOW".
12:08:42 <Athas> The <DATA OVERFLOW> is the best part.
12:08:47 <Athas> Urgh, date.
12:09:02 <gwern> ADD NEWDATA TO MAXBOUND GIVING TOOMUCH
12:11:00 <Saizan> can we apply hlint suggestions without editing the source manually yet?
12:11:53 <gwern> no
12:12:01 <gwern> and that wouldn't give you a fixpoint anyway
12:12:30 <Saizan> why do i need a fixpoint?
12:12:36 <gwern> I think this was discussed on darcs-users and we and ndm thought autoapplying hlint suggestions would be a bad thing
12:12:54 <Saizan> i was thinking of an interactive darcs-like ui
12:12:55 <gwern> Saizan: well, presumably the next step after autoediting would be rejecting anything that causes hlint suggestions
12:13:16 <gwern> Saizan: and there are further problems - iirc haskell-src-exts drops formatting and comments
12:13:16 <Saizan> not for me :)
12:13:36 <Saizan> gwern: i was asking precisely because the new version of it keeps them
12:13:41 <gwern> so you couldn't just stick in the suggestion because you'd lose stuff even if the indenting/whatever worked
12:13:47 <gwern> oh, was it fixed already?
12:14:09 <Saizan> se the .Annotated.* modules
12:14:18 <Saizan> s/se/see/
12:15:56 <_dsouza_> nevermind, I'm just curious anyway, just sent an email to haskell-cafe@. Let's see.
12:16:59 <Saizan> _dsouza_: in the future it's best to annotate the original paste instead of creating a new one
12:17:21 <_dsouza_> ok. I'll do it next time.
12:20:17 <_dsouza_> thx
12:44:31 <BMeph> Is there a way to automatically convert functions to CPS form, to get forms more amenable to rewrites? :)
12:46:55 <kmc> in what context
12:49:27 <Saizan> BMeph: there's a standard source level transformation, or you could write the monadic version and then use Cont
12:59:49 <brum> i don't understand this very simple question (what exactly does it ask for) : http://www.cstutoringcenter.com/problems/problems.php?id=67
12:59:50 <lambdabot> Title: Fractions in a triangle (Stern-Brocot tree)- Problem 66, C++ programming challen ...
13:00:10 <copumpkin> heh
13:01:08 <copumpkin> brum: do you see how the tree works?
13:01:31 <brum> no; i have no idea what the problem is asking for
13:01:32 <shachaf> _dsouza_: Oh, you're in this channel too.
13:02:36 * Twey has no idea what the problem is asking for, either.
13:03:34 <copumpkin> it's saying find the row that contains 7/10
13:03:40 <copumpkin> and give them the sum of all the fractions in it
13:03:53 <brum> oooh i get it now
13:03:58 <_dsouza_> I'm back
13:11:44 <cloudhead> is there a function to remove all elements in xs, from ys ?
13:12:43 <kmc> :t \xs -> filter (not . (`elem` xs))
13:12:44 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:12:49 <Veinor> Ah, elem, thank you.
13:12:54 <Twey> filter (not . (`elem` xs)) ys
13:13:50 <kmc> that will be O(m*n) where m,n are the sizes of the lists
13:13:57 <kmc> i.e. slow
13:14:16 <Veinor> how do you do it faster then?
13:14:32 <kmc> build a Data.Set.Set from xs first
13:14:49 <Veinor> True.
13:15:10 <kmc> O(m+n*log(m))
13:15:15 <kmc> err
13:15:25 <Veinor> then use filter (not . (`member` xsset)) ys I assume
13:15:26 <kmc> perhaps O(m*log(m)+n*log(m))
13:15:38 <kmc> yeah
13:18:17 <kmc> you can get faster with lookup arrays / hashing, at the expense of significantly more complexity
13:18:42 <BMeph> filter (`notElem` xs) ys
13:19:24 <skorpan> :t exclude
13:19:24 <lambdabot> Not in scope: `exclude'
13:19:32 <skorpan> did i dream that?
13:19:45 <kmc> :t \xs -> let s = S.fromList xs in filter (`S.notMember` s)
13:19:45 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
13:21:02 <cloudhea> I ended up doing this: sub xs ys = [ x | x <- xs, not (elem x ys) ]
13:22:41 <dschoepe> > [1..10] \\ [2,3]
13:22:42 <lambdabot>   [1,4,5,6,7,8,9,10]
13:22:51 <Veinor> http://thenextweb.com/2009/09/12/video-turn-software-pirate-instantly/
13:22:52 <lambdabot> Title: This video will turn you into a Software Pirate. Instantly., http://tinyurl.com/qzq9sc
13:23:28 <copumpkin> @djinn Not (Not (Not a)) -> Not a
13:23:29 <lambdabot> No output from Djinn; installed?
13:23:43 <copumpkin> @ask Cale we can haz djinn plsthx? :)
13:23:43 <lambdabot> Consider it noted.
13:23:45 <kmc> @src (\\)
13:23:45 <lambdabot> (\\) = foldl (flip delete)
13:23:51 <kmc> @src delete
13:23:51 <lambdabot> delete = deleteBy (==)
13:23:54 <kmc> @src deleteBy
13:23:54 <lambdabot> deleteBy eq x []        = []
13:23:55 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
13:24:54 <Botje> actually, i don't want to be a software pirate. i want to replace commercial software with free software :)
13:27:07 <Veinor> dschoepe: but
13:27:08 <vav> > [1,1,2,3,4,3] \\ [1,3]
13:27:09 <lambdabot>   [1,2,4,3]
13:27:13 <Veinor> yeah, that.
13:27:44 <Peaker> why would dual pivot quicksort be faster than a single-pivot quicksort?
13:27:49 <dschoepe> that's why you shouldn't use a list when you need a set
13:28:07 <Veinor> Multisets? :P
13:29:06 <kmc> type Multiset a = Data.Map.Map a Int
13:29:08 <Cale> @djinn Not (Not (Not a)) -> Not a
13:29:08 <lambdabot> f a b = void (a (\ c -> c b))
13:29:10 <kmc> though there are problems with that as well
13:29:28 <copumpkin> Cale: thank you!
13:29:33 <kmc> :D
13:30:23 <dsouza> void?
13:30:27 <dsouza> @type void
13:30:28 <lambdabot> Not in scope: `void'
13:30:35 <etpace> @info Not
13:30:35 <lambdabot> Not
13:30:47 <BMeph> Botje: So,...you're saying you want to me a Software Ninja? <shakes head> Memes. They're everywhere.
13:30:50 <copumpkin> type Not a = a -> Void
13:30:54 <BMeph> *be
13:30:55 <copumpkin> data Void
13:31:21 <etpace> What is this void magic?
13:31:22 <Botje> BMeph: pirates and ninjas can coexist!
13:31:35 <copumpkin> etpace: the emptiest type we can muster in haskell
13:31:43 <BMeph> Botje: Tell that to the Somalis. ;p
13:32:09 <kmc> newtype Voider = Voider !Void
13:32:12 <kmc> is that legal?
13:32:28 <copumpkin> you could just do newtype Voider = Voider Voider
13:32:53 <kmc> is it emptier?
13:33:00 <copumpkin> nope, I think it's just as empty
13:33:07 <tommd> Could anyone point me to an example of FFI importing C functions with a variable number of arguments?
13:33:25 <Baughn> > Just Nothing
13:33:27 <lambdabot>   Just Nothing
13:33:35 * BMeph points NNW for tommd... ;p
13:33:36 <Saizan> there's no point in strictness annotations in newtypes, i don't think they are even allowed
13:33:40 <copumpkin> tommd: never seen something like that actually
13:33:42 <tommd> @where NNW
13:33:42 <lambdabot> I know nothing about nnw.
13:33:54 <tommd> @google NNW Haskell FFI
13:33:55 <lambdabot> No Result Found.
13:34:00 <copumpkin> tommd: I've wondered about it, but I think you may need to deal with the calling convention by hand
13:34:02 <kmc> tommd, that sounds like a terrible pain.  i'd wrap it non-variadically in C first
13:34:21 <kmc> sometimes there is already a variant like vprintf
13:34:29 * BMeph hooks his thumb north-by-northwest
13:34:29 <tommd> kmc: I think I just won't do that.
13:34:56 <tommd> kmc: I did look at the Printf-TH package, but it didn't import anything of variable argument.
13:35:13 <kmc> it's not using FFI is it?
13:35:19 <tommd> It is
13:35:52 <kmc> this is?: http://hackage.haskell.org/packages/archive/Printf-TH/0.1.1/doc/html/src/Text-Printf-TH.html
13:35:53 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/osdylw
13:35:55 <tommd> Oh, nevermind... what package was it I was looking at.
13:36:16 <tommd> I just greped that one, you're right... there was another I thought should have it but didn't.
13:38:03 <kmc> System.Posix.Process uses the execv* family
13:41:02 <maxstahl> howdy folks
13:41:40 <jfredett> dcoutts_: I noticed it (the line wrapping problem), but it didn't show up on any of my sensors till after I sent it, I think the issue is that I did some copypasta magic and ended up with some line endings that were weird.
13:41:42 <gwern> GREETINGS FELLOW HUMAN
13:42:09 <maxstahl> got a memoization question if anyone's interested in helping me out.
13:43:42 <jfredett> Mostly I just struggled with getting all the tools working before the deadline, I kindof started midweek. This time, I'll have the whole week to work it out.
13:45:17 <sgf> maxstahl: People might be willing to help if you ask the question. :) (although probably not me, as I'm no memoization expert)
13:45:31 <maxstahl> sgf: oh! ok then.
13:46:08 <maxstahl> I found this page, http://www.haskell.org/haskellwiki/Memoization, which kinda explains it kiiiinda but not really. I'm not quite 100% clear on how the (map some_function [1.. ] !!) idiom works.
13:46:09 <lambdabot> Title: Memoization - HaskellWiki
13:47:49 <maxstahl> I keep getting a stack overflow though when I try to write that into my code.
13:48:28 <Peaker> maxstahl: its basically a ghc-based trick, where assigning a value to a name keeps it alive for the entire scope of that name. So if you make a list of results, its lazy, so they are only computed when needed, but since the list has a name, it is (and all the values that were computed in it) are kept alive by ghc
13:48:58 <maxstahl> ah cool so I can still access them later on. but why the stack overflow?
13:50:37 <sgf> Are you doing something insufficiently lazily, so that it ends up trying to actually evaluate the infinite list?
13:50:37 <Peaker> maxstahl: perhaps your thunks are being built up to form a very large thunk and then it is evaluated?
13:51:01 <maxstahl> I have a suspicion that might be....
13:51:15 <int-e> what are you evaluationg? something like some_function 1000000?
13:51:44 <maxstahl> I've been using project euler to learn haskell better, and this is for problem 214.
13:58:46 <BMeph> maxstahl: Oh, that's an easy one to answer: "UR DOIN IT RONG!" ;)
13:58:53 <maxstahl> damnit! i knew it.
14:00:17 <maxstahl> ok this is killing me though, not solving this.
14:05:10 <randomwords> maxstahl: Hint - you're probably going about the problem the wrong way
14:05:31 <maxstahl> randomwords: just like every other problem....
14:05:39 <hackagebot> hashed-storage 0.3.8 - Hashed file storage support code. (PetrRockai)
14:05:49 <randomwords> Heh
14:06:37 <randomwords> I assume you're use memoization to compute phi(n*m) = phi(n) * phi(m) for n,m coprime?
14:08:28 <badsheepy> does that mean that memoisation like that isnt guaranteed to work and is entirely compiler specific?
14:09:16 <sgf> I was wondering about that...
14:09:19 <randomwords> maxstahl: That may work (and be slow) but there is a better way to compute phi(n) from 1 - lim
14:09:50 <roconnor> since Haskell has no operational semantics, in some sense any code designed to improve operational efficiency is compiler specific.
14:10:03 <maxstahl> No I'm memoizing the chain lengths only, with chain_length n = 1 + chain_length (totient n)
14:10:22 <randomwords> oh right yeah. You want to do that
14:10:55 <maxstahl> Yeah I feel like that's the right way to do it, 'cause then you only compute totient n once for each n, too.
14:11:29 <randomwords> maxstahl: That will still be too slow. But I'll let you puzzle it out
14:11:29 <Saizan> maxstahl: do you have code to show?
14:11:55 <maxstahl> Trying to puzzle it out. Frustrating though.
14:12:17 <maxstahl> saizan: yeah I have this
14:12:17 <maxstahl> chain_length =
14:12:17 <maxstahl>   let memo 1 = 1
14:12:18 <maxstahl>       memo n = 1 + (chain_length (totient n))
14:12:18 <maxstahl>   in (map memo [1..] !!)
14:13:07 <maxstahl> . . . is it that it's not tail recursive?
14:13:20 <randomwords> maxstahl: Here's the relevant function from my code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3584#a3584. IOArrays aren't that idiomatic but I got into the habbit of using them for PE
14:13:21 <Saizan> yeah, that can be it.
14:13:39 <roconnor> maxstahl: you probably want to move memo outside of chain_length
14:13:52 <roconnor> maybe I shouldn't comment
14:13:59 <maxstahl> roconnor: hmm why?
14:14:20 <roconnor> maxstahl: to make sure that you don't reconstruct memo for every call to chain_length.
14:14:39 <maxstahl> roconnor: crap that's a really good point.
14:14:45 <roconnor> maxstahl: it's okay to make chain_lenght and memo mutually recursive.
14:14:53 <maxstahl> like I said I'm still kind of new to haskell but I really like it.
14:14:55 <roconnor> haskell is fine with that, and is normal when doing memoization.
14:15:19 <maxstahl> hold on lemme try that.
14:16:06 <maxstahl> yeah stack overflow....
14:16:38 <randomwords> maxstahl: Are you sure your totient function is behaving properly
14:16:53 <randomwords> that could explain the SO
14:17:05 <maxstahl> randomwords: pretty sure. I've been using it. Lemme test it.
14:17:47 <maxstahl> randomword: yeah it's working fine.
14:20:59 <randomwords> maxstahl: Just try quickCheck (\n -> n >= 2 ==> totient n < n)
14:26:59 <Saizan_> well, the fact that it's not tail recursive can cause the stack overflow too, if you directly ask for the chainLength of a number that causes a lot of recursion
14:27:20 <roconnor> ugh, again with the tail recursion nonsense
14:27:34 <Saizan_> roconnor: why nonsense?
14:28:25 <roconnor> Saizan_: were you around when I was arguing that syntactic tail recursion is irrellavent to stack usage in GHC?
14:28:58 <blackdog> roconnor: how do you figure?
14:29:04 <Saizan_> roconnor: no, but i disagree anyhow
14:29:09 <Saizan_> ?src length
14:29:09 <lambdabot> Source not found.
14:29:20 <blackdog> you can still get a blowup in the heap with tail recursive functions - how would you get a stack blowout?
14:29:30 <roconnor> blackdog: in a strict language, entering a function causes a stack frame to be pushed.
14:29:57 <roconnor> blackdog: this isn't the case in GHC.  It is entering a case expression that causes a stack frame to be pushed in GHC.
14:30:35 <roconnor> so it is something like case recursion that you have to be worried about, not function recursion.
14:30:52 <roconnor> Now often the first thing a function does is case analysis (pattern matching), but not always.
14:31:08 <Saizan_> well, yeah, it matters when the combining function is strict
14:32:31 <Saizan_> like (+) there
14:32:35 <blackdog> roconnor: have you got an example where the  stack blows out with something that's syntactically tail-recursive? my brain works better on concrete data sometimes...
14:33:32 <Saizan_> blackdog: foldl (+) 0 written out explicitly is tail recursive and makes the stack blow at the end, but not while it's recursing, not sure if that counts :)
14:34:13 <roconnor> I was going to say foldl (+) 0.
14:34:41 <roconnor> lemme see if I can think of one more compelling
14:34:48 <Saizan_> while foldr (+) 0 makes the stack blow while it's recursing
14:36:46 <Saizan_> so you've to adjust the concept of "tail recursion" for laziness, but it's not irrelevant
14:37:24 <roconnor> Saizan_: you need to adjust it so much it deserves a new name
14:39:03 <blackdog> so in the foldl example, you build up a big closure on the heap first, then you try to evaluate it - what are the frames it's putting on the heap?
14:39:26 <blackdog> (sorry to be dense, but i suspect my not understanding this is why i get stack blowouts in big programs and have trouble finding them)
14:39:37 <Saizan_> though it's not so simple to do such a transformation and keep memoization working, is it?
14:40:07 <roconnor> blackdog: one the big closure is built, each call to + pushes a stack frame becuase it counts as doing case analysis.
14:40:09 <Saizan_> blackdog: frames of (x+) where x is an element of the list
14:40:28 <roconnor> actualy + pushes a stack frame for each side, although one side pops back right away.
14:42:44 <blackdog> and foldl' pushes a stack frame for each side, but pops both immediately?
14:43:43 <Saizan_> foldl' doesn't let the big thunks of (+)s build up
14:44:01 <Saizan_> since each single addition gets evaluated immediately
14:44:06 <Saizan_> by seq
14:44:20 <Saizan_> s/immediately/before recursing/
14:44:45 <Saizan_> that works well for Ints and similar since seq evaluates them completely
14:49:04 <blackdog> Saizan_: is this something inherent to lazy evaluation, or a quirk of GHC? What's a good resource to read up on it?
14:49:18 * blackdog is sort of embarrassed not to have a firm grasp on this
14:51:18 <Saizan_> well it's an operational detail of the STG machine
14:51:40 <Saizan_> @wiki Stack overflow
14:51:41 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
14:51:43 <Saizan_> to start
14:52:09 <jmcarthur> i'd say it's an abstraction leak in the same way that blowing the stack with a non tail recursive function in a strict language is an abstraction leak
14:52:16 <Saizan_> and "implementing lazy functional languages" by SPJ to get a more in-depth knowledge
14:52:47 <jmcarthur> not a horrible abstraction leak, just something you have to learn and work around
14:53:15 <Saizan_> there's also ministg on hackage, that's a demonstrative implementation of the stg machine
15:00:07 <blackdog> Saizan_: thanks. I've read SPJ's paper, but it was an awfully long time ago.
15:01:21 <cloudhea> any reason why:     factors x = [ y | y <- [2..(x-1)], x `mod` y == 0 ]     isn't finding the factors of  600851475143 ?
15:01:39 <cloudhea> going through project euler >_>
15:02:00 <kmc> cloudhea, are you passing it (600851475143 :: Integer) ?
15:02:19 <cloudhea> kmc: Int
15:02:27 <kmc> it might be overflowing then
15:02:37 <cloudhea> ah : )
15:02:53 <cloudhea> I was wondering what the difference was between Int and Integer
15:02:54 <kmc> > maxBound :: Int
15:02:55 <lambdabot>   9223372036854775807
15:03:18 <kmc> Int is machine size and is only guaranteed to go up to 2^30 or so
15:03:27 <kmc> Integer is an arbitrarily large bignum
15:03:30 <cloudhea> yea, that was the problem! thanks : >
15:04:13 <kmc> > (log $ fromIntegral (maxBound :: Int)) / (log 2)
15:04:14 <lambdabot>   63.0
15:06:19 <lispy> ?hoogle <$>
15:06:20 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
15:09:28 <mun_> hi
15:09:54 <generic> Im a little new to this but in my book it says "in, haskell when referring to an operator as a value we enclose it in parentheses such as when declaring its type as in:   (+) :: Integer -> Integer -> Integer" Can some one explain that alittle better?
15:10:00 <mun_> i got a slightly irrelevant question and it's about FOL theorem provers: since FOL is semi-decidable, how come FOL provers like Vampire work well? do they try to make a way around somehow?
15:10:59 <Vanadium> generic: You cannot just say "+", you always have to say "something + something". But if you want to do something else with + than applying it right away, you need to say "(+)", which is just an expression of that function type
15:11:24 <Gracenotes> note, in Haskell there's a distinction between functions/values that only have letters and numbers, and those that have only punctuation.
15:12:48 <generic> Vanadium: so would tht example listed be essentially: " Integer + Integer + Integer"?
15:12:52 <generic> ^that
15:12:59 <Vanadium> No
15:13:14 <Vanadium> Integer -> Integer -> Integer is the type of functions that take two integers and return a thir
15:13:17 <Vanadium> third integer*
15:13:40 <Vanadium> > let f = (+) in f 3 5
15:13:41 <lambdabot>   8
15:13:45 <Vanadium> See, f is such a function now~
15:13:47 <roconnor> techinically Integer -> Integer -> Integer is the type of functions that takes one integer and return another function that takes one integer and returns an integer.
15:14:07 <roconnor> but it is isomorphic to (Integer,Integer) -> Integer.
15:14:18 <roconnor> well, isomorphic enough.
15:14:24 <Vanadium> heh
15:14:26 <Vanadium> Sorry
15:14:38 <skorpan> "isomorphic enough"?
15:14:44 <Gracenotes> the most basic equivalent in (for example) C is "int add(int, int)", but in Haskell it is very different and much more flexible.
15:14:50 <roconnor> skorpan: let us not talk about partial values.
15:15:05 <generic> Thx that clears up some of the smoke
15:15:28 <skorpan> what's a partial value? (oops.)
15:15:33 <generic> It seems that haskell was made by mathematicans?
15:16:02 <roconnor> skorpan: loosely speaking a partial values is a value that contains an undefined somewhere.
15:16:03 <generic> and i dont me this just by the fucntion this
15:16:04 <Gracenotes> computer science was made by mathematicians, wasn't it? :P
15:16:06 <generic> ^thing
15:16:14 <skorpan> roconnor: could you give me an example of such a value?
15:16:26 <roconnor> skorpan: (0:fix id)
15:16:44 <roconnor> or in this case, (fix id,fix id) :: (Integer,Integer)
15:16:46 <skorpan> is that to be read as "cons 0 (fix id)"?
15:16:53 <roconnor> skorpan: yes
15:16:53 <generic> The "let" "in" "->" and the way the functions are used, it feels like Im reading a mathematical proof at times
15:17:06 <kmc> skorpan, you can write a function of type (a,a) -> a which throws an error on input "undefined" but not "(undefined, undefined)"
15:17:21 <generic> Gracenotes: yeah but C does feeling like a formal math papaer
15:17:27 <generic> ^paper
15:17:40 <generic> ^doesnt
15:17:46 <dfdf> feel*
15:17:57 <generic> jeez, im an too tired
15:17:59 <generic> o.0
15:18:12 <generic> Anyway thank you guys that helped.
15:18:15 <generic> Later
15:18:27 <Gracenotes> see you, and good luck
15:18:32 <skorpan> > fix id
15:18:35 <generic> thx!
15:18:37 <lambdabot>   mueval-core: Prelude.read: no parse
15:18:37 <lambdabot>  mueval: ExitFailure 1
15:18:47 <skorpan> the fixed point of the identity function?
15:18:53 <skorpan> or fix-point, or whatever
15:19:06 <roconnor> skorpan: undefined, or more technically bottom.
15:19:21 <skorpan> roconnor: would (0:undefined) be a partial value?
15:19:27 <roconnor> yes
15:19:48 <skorpan> is (undefined, 4) a partial value?
15:19:53 <roconnor> yes
15:19:58 <skorpan> Just undefined?
15:20:01 <roconnor> yes
15:20:11 <skorpan> hm, okay how about THIS
15:20:16 <Gracenotes> :O
15:20:21 <skorpan> (0:[undefined])!!!!!!!!
15:20:24 <dfdf> hmm
15:20:33 <roconnor> skorpan: bear in mind being a parital value is not decidable.
15:20:35 <dfdf> a fixed point of a function f is a value a such that f a == a
15:20:36 <roconnor> skorpan: yes
15:20:45 <dfdf> but, id a == a ,for all a
15:20:53 <roconnor> skorpan: (though it is semi-decidable).
15:20:54 <dfdf> so any value would do?
15:21:03 <skorpan> roconnor: i never delved into the mysticism of decidability
15:21:10 <roconnor> dfdf: good point.
15:21:29 <roconnor> skorpan: dfdf rightly points out that any value is a fixed point of id; however bottom is the "least" fixed point.
15:21:38 <roconnor> skorpan: which is the one returned by fix id.
15:21:39 <kmc> heh
15:21:57 <Gracenotes> roconnor: how about (\x y -> y x) undefined const?
15:22:00 <skorpan> this "least" business is strange to me.  someone said to me that bottom is the least defined value of some type, iirc.
15:22:06 <roconnor> skorpan: I'm just warning you that you might ask me if a certain value is partial and I might not be able to answer yes.
15:22:29 <roconnor> @type  (\x y -> y x) undefined const
15:22:29 <lambdabot> forall a b. b -> a
15:22:45 <skorpan> :t Just undefined
15:22:46 <lambdabot> forall a. Maybe a
15:23:11 <roconnor> Gracenotes: that is partial.
15:23:20 <Gracenotes> it is
15:23:32 <roconnor> Gracenotes: if you replace (const) with (flip const) then it is total.
15:23:38 <kmc> "const undefined" is partial?
15:23:42 <Gracenotes> oh, you mean partial value. so it does look inside lambdas.
15:23:49 <roconnor> > const undefined 5
15:23:50 <lambdabot>   * Exception: Prelude.undefined
15:24:13 <roconnor> Gracenotes: a function is partial if it maps a total value to a partial value.
15:24:27 <kmc> but the function itself is a total value, yes?
15:24:40 <Gracenotes> this seems a bit stronger than even normal form in Haskell
15:25:09 <roconnor> kmc: a function is total only if it maps every total value to a total value.
15:25:29 <roconnor> technically length is a partial function.
15:25:40 <kmc> so this is the definition of "total value" for function types?
15:25:41 <roconnor> > length (repeat ())
15:25:46 <lambdabot>   mueval-core: Prelude.read: no parse
15:25:46 <lambdabot>  mueval: ExitFailure 1
15:25:56 <roconnor> kmc: yes.
15:26:15 <Gracenotes> it seems partial/total is difference for functions and non-functions.
15:26:26 <Gracenotes> the way you are using it
15:26:36 <dschoepe> roconnor: but repeat () is partial, isn't it? So by above criterion it would still be total?
15:26:44 <dschoepe> (it meaning length)
15:26:48 <roconnor> repeat () is total.
15:26:53 <roconnor> is a total value.
15:27:02 <roconnor> it has no undefined/bottoms
15:27:28 <dschoepe> but evaluating it, doesn't terminate, which I thought of being the same as being bottom?
15:27:52 <roconnor> dschoepe: being productive is enough to be a total value.
15:28:09 <dschoepe> ah, okay. thanks for the clarification
15:28:26 <kmc> liveness not progress :D
15:28:29 <Gracenotes> as in, data and codata?
15:28:58 <roconnor> the technical definition of a total value is a maximal element in the type's domain, or something like that.
15:29:16 <roconnor> kmc: how do you mean.
15:29:17 <kmc> how is the relevant poset defined?
15:29:55 <roconnor> Gracenotes: totality is well defined with respect to non-positive recursive types too, though I hope I don't get any questions about whether values of such types are total or not.
15:29:57 <kmc> this goes back to "why is bottom the least value in a type"
15:31:22 <roconnor> kmc: the poset is defined recursively on the definition of the ADT
15:32:33 <roconnor> kmc: I know the definition for product and sum types.  But not sure I myself could recreate the definition for function and recursive types. :(
15:32:35 <kmc> a <= b iff a is bot, or they have the same ctor and every field in b that's bot is also bot in a?
15:33:05 <Gracenotes> :o
15:33:13 <roconnor> a <= b iff a is bot, or they have the same ctor and every field is <= the corresponding field.
15:33:27 <kmc> ah right
15:34:06 <Gracenotes> I think I might buy a tuna salad sandwich
15:34:29 <heatsink> Yeah! Go for it!
15:34:34 <roconnor> a function f <= g if for when a <= b then f b <= f a ... I guess.
15:34:37 <Gracenotes> !!
15:34:47 * roconnor sighs
15:34:53 <roconnor> but then there is seq ...
15:35:06 <roconnor> that makes the domains for functions more complex I guess.
15:35:21 <heatsink> roconnor, for functions, will the direction of the <= be reversed on function arguments?
15:35:40 <roconnor> heatsink: that is what I would guess, and what I wrote.
15:36:10 <roconnor> I'm not sure that is right
15:36:15 * roconnor thinks about this.
15:36:18 <aavogt> roconnor: where does g go?
15:36:27 <roconnor> ah opps
15:36:28 <Gracenotes> g goes WHERE?
15:36:46 <roconnor> a function f <= g if for when a <= b then f b <= g a ... I guess.
15:37:45 <roconnor> Don't quote me on this
15:38:01 <roconnor> and I totally have not considered seq here.
15:38:17 <heatsink> @quote roconnor
15:38:17 <lambdabot> roconnor says: if you click your heels and say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
15:39:52 <roconnor> well, these definitions might be right anways, even for recursive types since I haven't really defined the domain elements.
15:40:04 * Saizan_ thinks it makes more sense to have f <= g if forall a. f a <= g a
15:40:16 <dschoepe> roconnor: hmm, the "denotational semantics" chapter in the Haskell wikibook says, that f <= g iff forall x. f x <= g x. Is that article mistaken or am I misunderstanding something?
15:40:37 <roconnor> dschoepe: I could very well be wrong.
15:41:11 <FunctorSalad_> roconnor: did you flip the order intentionally?
15:41:23 <FunctorSalad_> I guess that's what dschoepe is asking
15:41:39 <roconnor> dschoepe: ya I am totally wrong.
15:41:42 <generic> so in ghci do you have to use let before pretty much every "="?
15:41:43 <roconnor> so ignore what I said.
15:42:01 <roconnor> in my definition, it isn't the case that f <= f, which is bad.
15:42:03 <Saizan_> generic: yes, it's like being in a do-block
15:42:06 <generic> c = 3 is invalid in ghci but would in be valid in a .hs file?
15:42:16 <Saizan_> right
15:42:20 <generic> Saizan_: Ok good :)
15:42:54 <heatsink> generic, the ghci prompt is a "do" block
15:43:00 <generic> Saizan_: I was trying an example from a book and I was wondering the syntax of haskell has changed since its printing gave me a little scare...
15:43:04 <roconnor> a function f <= g if for when a <= b then f a <= g b and I think this is equivalent to Saizan_ and dschoepe's definitions given that we are going to be restricting ourselves to monotone functions.
15:43:09 <heatsink> oh, someone already said that
15:43:14 <Peaker> ghci with   :set -XNoMonomorphismRestriction   is more usable
15:43:50 <generic> Peaker: will that make take off the "do" block ?
15:43:57 <generic> ^make it
15:44:02 <Saizan_> no
15:44:43 <roconnor> FunctorSalad_: I did flip the order intensionally, and it was wrong of me to do so.
15:45:03 <generic> :/ its fine, not a bigdeal right now. As you can see Im learning the basics.
15:45:06 <roconnor> FunctorSalad_: for once a definition is covarient in it's argument.
15:45:22 <Peaker> generic: no, it makes ghci be less annoying about choosing types for variables
15:45:50 <FunctorSalad_> roconnor: yeah variance is evil.
15:45:51 <kmc> generic, what do you want to do with the "do" block?
15:45:58 <generic> Haskell has a very interesting way of doing things. Compared to C++/C which i tried to learn as a first lang (o.0)
15:46:11 <FunctorSalad_> I think the least head-spinny approach is to just count the number of sign changes rather than really thinking about it :)
15:46:12 <heatsink> Yeah, Haskell is like that.
15:46:14 <kmc> C++ and C are two languages
15:46:16 <kmc> and very different
15:46:21 <generic> kmc: i know
15:46:26 <generic> I trie dto learn both
15:46:27 * roconnor has  -XNoMonomorphismRestriction in his .ghci file
15:46:39 <Makoryu> generic: So don't call 'em a single language :p
15:46:41 <kmc> C is simple, C++ is not
15:46:42 <roconnor> $ cat ~/.ghci
15:46:44 <roconnor> :set -fno-print-bind-result
15:46:45 <roconnor> :set -fno-monomorphism-restriction
15:47:09 <generic> kmc: actually I found c++ much more percise in its sytax
15:47:33 <kmc> syntax is superficial
15:47:39 <kmc> also C++ syntax is awful
15:47:47 <generic> kmc: it can make a huge difference
15:47:53 <cloudhead> I'm trying to figure out the type signature for factors x = [ ceiling y | y <- [2 .. (x/2)], x `mod` y == 0 ] -- anyone?
15:47:59 <kmc> yeah but it's not the sense in which I claim C is much simpler
15:48:13 <kmc> cloudhead, what've you got
15:48:15 <aavogt> @type let factors x = [ ceiling y | y <- [2 .. (x/2)], x `mod` y == 0 ] in factors
15:48:16 <lambdabot> forall a b. (Integral b, Integral a, RealFrac a) => a -> [b]
15:48:36 <Peaker> kmc: superficial yet imporatnt
15:48:55 <cloudhead> hmm
15:49:13 <Saizan_> cloudhead: i think you want div instead of / and not use ceiling
15:49:14 <generic> I found it pretty nice actually. It was sort of like english. It just felt "natural". BUt thats probably because I learned all everything about programing from c++
15:49:15 <aavogt> @type let factors x = [ ceiling y | y <- [2 .. x `div` 2], x `mod` y == 0 ] in factors
15:49:15 <FunctorSalad_> random question... why isn't there a language yet which exists only for the purpose of translating from/to it
15:49:16 <lambdabot> forall a b. (Integral b, Integral a, RealFrac a) => a -> [b]
15:49:16 <Makoryu> <generic> more percise <- s/per/con/, perhaps? ;)
15:49:21 <FunctorSalad_> (as an intermediate)
15:49:26 <kmc> FunctorSalad_, what do you mean?
15:49:30 <FunctorSalad_> (source code translation)
15:49:32 <aavogt> @type let factors x = [ y | y <- [2 .. x `div` 2], x `mod` y == 0 ] in factors
15:49:33 <generic> anyway thx guys later
15:49:33 <lambdabot> forall a. (Integral a) => a -> [a]
15:49:35 <kmc> Cmm, LLVM?
15:49:38 <cloudhead> Saizan_: cool, will try that
15:49:45 <Peaker> roconnor: thanks, good idea (about .ghci)
15:50:06 <FunctorSalad_> kmc: I don't know about LLVM, but I wasn't thinking of an VM
15:50:08 <aavogt> > 1 `div` 2
15:50:09 <lambdabot>   0
15:50:15 <kmc> every language is a VM
15:50:23 <roconnor> > 1 `divMod` 2
15:50:24 <lambdabot>   (0,1)
15:50:46 <Peaker> > 1 / 2
15:50:47 <lambdabot>   0.5
15:51:06 <roconnor> > 1 / 2 :: CReal
15:51:07 <lambdabot>   0.5
15:51:24 <jmcarthur> > 1/3 :: CReal
15:51:25 <lambdabot>   0.3333333333333333333333333333333333333333
15:51:26 <FunctorSalad_> I was thinking more of a common semantics
15:51:45 <FunctorSalad_> so it would be an abstract/mathematical thing
15:51:45 <kmc> C-- and LLVM are source languages for compiler backends / instruction-level optimizers
15:52:08 <kmc> so you'd describe the semantics of your object language in this metalanguage?
15:52:37 <FunctorSalad_> I would translate source code from say Haskell, to this metalanguage, such that semantics is preserved
15:52:50 <FunctorSalad_> (and then from the metalanguage to whatever other language)
15:52:54 <kmc> but how are the semantics of the metalanguage defined, such that they can encompass every other language?
15:53:06 <SamB> kmc: they are just assembly languages
15:53:08 <FunctorSalad_> the high-level structure should be preserved so you don't get quasi-assembly output in the target lang
15:53:17 <kmc> that's the hard part
15:53:36 <kmc> i'll bet you it's undecidable in most every case
15:53:38 <SamB> oh, you're talking about something else ...
15:53:41 <FunctorSalad_> kmc: yes that's the interesting part. it would have to be a very general semantics
15:53:57 <kmc> it would have a million features that are not orthogonal at all
15:53:58 <kmc> like C++
15:54:00 <FunctorSalad_> what is undecidable?
15:54:05 <SamB> kmc: only worse!
15:54:16 <FunctorSalad_> yeah, but the metalang itself needn't be convenient to use
15:54:34 <FunctorSalad_> it must just be able to capture lots of structure... like math :D
15:54:35 <SamB> and you'd never be able to convert anything out of the language again ...
15:54:37 <kmc> FunctorSalad_, given a program in language A produce a program in language B with the same meaning, in a "high-level" way
15:54:41 <SamB> except to lower-level langauges ...
15:55:01 <heatsink> But if it's too general, then it interferes with doing useful transformations on it, which is the point to translating to it.
15:55:05 <Makoryu> http://hackage.haskell.org/trac/ghc/ticket/3452 <- It bugs me that there's no switch to enable this behavior. It bugs me more that I'd have to dig through GHC's source to come up with a patch to make it work
15:55:06 <lambdabot> Title: #3452 (Show type of most recent expression in GHCi) - GHC - Trac
15:55:22 <Peaker> What would it take for the type of (\x -> (x,x)) y  to always be the same type as (y,y) ?  Could a language with this property work?
15:55:44 <FunctorSalad_> I'm thinking of domain theory, for example
15:55:54 <kmc> :t \y -> (\x -> (x,x)) y
15:55:55 <lambdabot> forall t. t -> (t, t)
15:55:57 <Peaker> > let f x = (x,x) in f show
15:55:58 <lambdabot>   ({()->"()"},{()->"()"})
15:56:00 <Saizan_> Makoryu: not very deep though
15:56:01 <kmc> :t \y -> (y,y)
15:56:01 <lambdabot> forall t. t -> (t, t)
15:56:03 <FunctorSalad_> the constructions there can describe haskell types, ML types and so on
15:56:23 <Peaker> @type let f x = (x,x) in f show
15:56:24 <lambdabot> forall a. (Show a) => (a -> String, a -> String)
15:56:27 <Peaker> @type (show, show)
15:56:27 <Saizan_> Makoryu: and i think you could :define a command to do something like that
15:56:27 <lambdabot> forall a a1. (Show a, Show a1) => (a -> String, a1 -> String)
15:56:35 <Peaker> kmc: different types ^^
15:56:36 <Makoryu> Saizan_: Oh?
15:57:09 <kmc> Peaker, doesn't it work in System F?
15:57:10 <Saizan_> Makoryu: like and :eval that gives you the type after the result or something
15:57:15 <kmc> because the point at which you apply the type is explicit
15:57:15 <Peaker> kmc: I don't know..
15:57:17 <Saizan_> *an
15:57:23 <kmc> (what you lose is inference in every case)
15:57:40 <Peaker> kmc: perhaps
15:57:40 <FunctorSalad_> System F and friends are a candidate too for this intermediate language
15:57:53 <Peaker> is System F a specific language?
15:58:07 <kmc> FunctorSalad_, you're going to translate idiomatic Perl into System F and then into idiomatic C#?
15:58:22 <kmc> Peaker, yes
15:58:28 <FunctorSalad_> maybe not System F, but with full-on dependent types?
15:58:44 <FunctorSalad_> I think you could mirror Perl's structures in coq or something
15:59:02 <heatsink> FunctorSalad_, what would be the benefit of this language?  Correctness?  Interoperability?  Optimization?
15:59:06 <kmc> but that's different -- now you're describing the semantics of the object language using a metalanguage
15:59:13 <kmc> not claiming the metalanguage itself has those semantics
15:59:35 <FunctorSalad_> heatsink: I was thinking of interop... the "instead of n*n converters, you need n+n converters" thing
15:59:41 <kmc> Peaker, System F is the simply typed lambda calculus + quantification on types with type application
15:59:44 <FunctorSalad_> (with a single metalang)
15:59:58 <kmc> FunctorSalad_, what's an example of one of the n*n converters you'd eliminate?
16:00:19 <FunctorSalad_> n is the number of languages you're interested in interconverting
16:00:38 <kmc> i mean an actual example
16:00:39 <Peaker> FunctorSalad_: you use a common language as a HUB/ABI (e.g FFI always through C)
16:00:47 <Peaker> FunctorSalad_: that way, you get (n+n)
16:00:53 <FunctorSalad_> kmc: Haskell -> COBOL? j/k
16:01:03 <kmc> Peaker, linking two languages is not the same as translating between them
16:01:10 <kmc> no, i mean one that people do now
16:01:15 <kmc> i don't see the use case basically
16:01:26 <FunctorSalad_> yeah, they don't do that much at the moment I think
16:01:28 <kmc> there are specialized converters like f2c
16:01:35 <kmc> and there are compilers, which always go "down"
16:01:38 <Makoryu> FunctorSalad_: COBOL has fantastic features like self-modifying code
16:01:39 <kmc> and decompilers which are also very specialized
16:01:48 <Peaker> kmc: I don't understand -- you can use FFI calls with C's ABI to non-C languages, if they also support the C ABI
16:01:48 <heatsink> FunctorSalad_, To do that, what you really want to change is at the level of each langauge's FFI, not at the level of the IR.
16:01:48 <FunctorSalad_> but it would be nice to translate libraries from one lang to another
16:01:53 <Peaker> kmc: (and "link" to them)
16:01:57 <FunctorSalad_> (instead of linking)
16:02:00 <Peaker> FunctorSalad_: why?
16:02:16 <lispy> No instance of NFData for strict bytestrings
16:02:33 <FunctorSalad_> lispy: they are rnf already, aren't they
16:02:33 <lispy> so I guess just instance NFData (ByteString) where rnf _ = ()  ?
16:02:41 <lispy> FunctorSalad_: I think so, yeah, just double checking
16:02:43 <kmc> Peaker, the topic is converting code in one language to another
16:02:49 <FunctorSalad_> well, you would seq the head constructor lispy I think
16:03:03 <Peaker> kmc: oh
16:03:08 <FunctorSalad_> Peaker: actually I'm not sure translation would be better than bindings
16:03:11 <lispy> FunctorSalad_: which is what in this case ? :)
16:03:21 <FunctorSalad_> the disadvage would be that you fork it, I suppose
16:03:22 <Peaker> I don't think you would want to auto-translate code
16:03:27 <Peaker> unless you're porting it
16:03:30 <Peaker> and going to discard the source
16:03:30 <lispy> FunctorSalad_: I guess I could do rnf !b = ()
16:03:42 <kmc> the result will usually be awful, and that's with a bunch of customized tweaks
16:03:43 <FunctorSalad_> lispy: yeah, I meant the Bytestring constructor itself
16:03:55 <lispy> FunctorSalad_: I think that is hidden
16:04:16 <FunctorSalad_> lispy: then I think you'd just seq it, or bang pattern as you did
16:04:16 <blackdog> kmc: i think interoperability's a more interesting idea than trying to automatically translate
16:04:22 <kmc> i agree
16:04:37 <blackdog> but then, i'm writing a ruby-haskell bridge, so i _would_ say that
16:04:54 <kmc> cool
16:04:56 <FunctorSalad_> ok ok you win, it was just an idea ;)
16:05:22 <FunctorSalad_> but common ground could be useful on the level of bindings too, no?
16:05:26 <Peaker> I wrote a C/Python bridge once, it was over a pipe, so you could control remote processes, and plenty of them :)
16:05:36 <kmc> FunctorSalad_, yes but it's a much more modest (read, possible) goal
16:06:00 <blackdog> FunctorSalad_: what sort of common ground are you thinking of? C ABI? SWIG?
16:06:22 <heatsink> What do you call operators like (++) in the list or parsing monads?
16:06:25 <FunctorSalad_> blackdog: I'd have to look these up
16:06:45 <blackdog> the real problem i'm having is marshalling - at what stage do you decide that it's worthwhile moving the whole Ruby dictionary over to Haskell, etc
16:06:58 <Peaker> heatsink: I guess its mplus, so maybe "catch" or "orElse"?
16:08:48 <heatsink> Actually, I was asking about that execution behavior.  The best name I can think of is "nondetermistic choice", but that sounds like randomly choosing an alternative.  What they do is to choose the first alternative that succeeds.
16:09:09 <FunctorSalad_> mplus
16:10:29 <FunctorSalad_> @src Tree
16:10:29 <lambdabot> Source not found. I feel much better now.
16:11:58 <roconnor> Saizan_: hmm, length seems to be a maximally defined element.
16:12:01 <Saizan_> [] is called the nondeterminism monad, as in "angelic nondeterminism" where all paths are eventually tried
16:12:07 <roconnor> yet is maps repeat () to bottom.
16:12:37 <roconnor> I wonder if I have the wrong definition of partial value for functions.
16:13:24 <FunctorSalad_> hmm what else is it supposed to do with "repeat ()"?
16:13:36 <Peaker> instead of "quantum computers", we should make "list monad computers"
16:13:43 <heatsink> Saizan_, thanks, that confirms that I'm using 'nondeterminsm' correctly.
16:13:55 <roconnor> well, it could map it to 7, if we include discontinuous functions in the domain.
16:14:12 <FunctorSalad_> roconnor: but how would it ever know to stop consuming elements?
16:14:13 <roconnor> but I don't think discontinuous functions are part of function domains.
16:14:35 <roconnor> FunctorSalad_: there is no haskell function that can do this because all haskell functions are continuous.
16:14:53 <Saizan_> FunctorSalad_: it could give the same length for all lists at that length or above
16:15:07 <Saizan_> eh?
16:15:20 <Saizan_> it surely can become constant after a certain point
16:15:43 <Saizan_> but that won't get you <= forall inputs i guess.
16:16:23 <FunctorSalad_> this sequence converges to the infinite list, right? bot, ():bot, ():():bot, ...
16:16:25 <roconnor> Saizan_: if a function of type ([a] -> Integer) becomes constant at a point is is both a total function and a maximal element in the domain.
16:16:58 <roconnor> Saizan_: my oddness that that length appears to be both a partial function (according to my definition) and still a maximal element in its domain.
16:16:58 <FunctorSalad_> so f( repeat ()) = sup ( that sequence )
16:17:27 <Saizan_> roconnor: yeah, now i see it
16:18:11 <roconnor> Obviously I need to study domain theory at some point.
16:18:49 <Saizan_> FunctorSalad_: you mean sup ( map f (the sequence))?
16:19:02 <FunctorSalad_> Saizan_: yes, sorry
16:19:37 <FunctorSalad_> in Integer only singleton sets and sets of the form {bot,n} have a sup
16:20:09 <Saizan_> well map length sequence gives you a sequence of _|_
16:20:20 <Saizan_> so the sup is _|_
16:20:29 <FunctorSalad_> yes
16:20:37 <FunctorSalad_> > length (1:2:undefined)
16:20:38 <lambdabot>   * Exception: Prelude.undefined
16:20:43 <FunctorSalad_> > length (1:2:undefined) :: Natural
16:20:44 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
16:20:54 <FunctorSalad_> > show (length (1:2:undefined) :: Natural)
16:20:55 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
16:20:58 <FunctorSalad_> :p
16:21:15 <bob0> http://downforeveryoneorjustme.com/haskell.org
16:21:21 <lambdabot> Title: It's not just you!
16:21:32 <Peaker> > genericLength (1:2:undefined) :: Natural
16:21:33 <lambdabot>   * Exception: Prelude.undefined
16:21:41 <FunctorSalad_> good point
16:22:07 <roconnor> > 1 < (genericLength (1:2:undefined) :: Natural)
16:22:08 <lambdabot>   True
16:22:33 <FunctorSalad_>  > show (genericLength (1:2:undefined) :: Natural)
16:22:41 <FunctorSalad_> > show (genericLength (1:2:undefined) :: Natural)
16:22:42 <lambdabot>   "* Exception: Prelude.undefined
16:22:47 <Peaker> > 5 :: Natural
16:22:48 <lambdabot>   5
16:22:54 <FunctorSalad_> I thought it'd print (S (S exception
16:22:55 <Peaker> its not (Succ (Succ ...)
16:22:57 <sshc> is there a standard function to contact a list of lists into one list with a seperator in between?
16:23:14 <Saizan_> sshc: intercalate/intersperse
16:23:23 <shachaf> FunctorSalad_: It would, except for its Show instance.
16:23:58 <sshc> where f ! ["foo", "bar", "baz"] = "foo!bar!baz"
16:24:07 <sshc> @hoogle intercalate
16:24:07 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
16:24:07 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:24:07 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
16:24:46 <sshc> > intercalate "!" ["foo", "bar", "baz"]
16:24:47 <lambdabot>   "foo!bar!baz"
16:24:56 <sshc> > intersperse "!" ["foo", "bar", "baz"]
16:24:57 <lambdabot>   ["foo","!","bar","!","baz"]
16:26:45 <bos> @unpl join (*)
16:26:45 <lambdabot> ((*) >>= \ a -> a)
16:27:07 <Makoryu> @unpl ap
16:27:07 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
16:30:58 <Makoryu> :t hFlush
16:30:59 <lambdabot> Not in scope: `hFlush'
16:31:14 * roconnor reads http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=7C9C399A4DF4FBE4583E7FFB33A939DD?doi=10.1.1.50.8851&rep=rep1&type=pdf
16:31:15 <lambdabot> Title: Domain Theory, http://tinyurl.com/q7fmxh
16:31:15 <heatsink> :t IO.hFlush
16:31:16 <lambdabot> GHC.IOBase.Handle -> IO ()
16:32:19 <heatsink> > let {s f (a:b:c:d:e) g = e`f`g[a,b,c,d];e = (++).(++["-"]);o a b c d e f = (e`on`uncurry f)(a,b)(c,d)} in intercalate"-"$o e e e((.map(' ':)).zipWith(++))e$(s$s$s$s$flip const)["work it","make it","do it","makes us","harder","better","faster","stronger","more than","hour","hour","never","ever","after","work is","over"]o
16:32:19 <lambdabot>   "work it-make it-do it-makes us---harder-better-faster-stronger---more than...
16:33:08 <Badger> heatsink: you are a genius
16:33:23 <heatsink> thank you Badger :)
16:33:27 <roconnor> I kinda wish I had a kindle
16:33:51 <Badger> :)
16:53:39 <Makoryu> What the heck? Is "default" really a reserved word?
16:54:21 <dobblego> > let default = 7 in default
16:54:22 <lambdabot>   <no location info>: parse error on input `default'
16:54:28 <dobblego> > let default' = 7 in default'
16:54:29 <lambdabot>   7
16:55:30 <enolan> You can specify default instances of typeclasses.
16:56:04 <enolan> > print 1 -- defaults to Int
16:56:05 <lambdabot>   No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
16:56:05 <lambdabot>    arising from a use of...
16:56:15 <enolan> err. show
16:57:06 <Makoryu> Ahhh I see
16:57:12 <Makoryu> > print ()
16:57:13 <lambdabot>   No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
16:57:13 <lambdabot>    arising from a use of...
16:57:50 <enolan> No IO in lambdabot
16:57:50 * aavogt thinks it defaults to Integer
16:57:59 <Makoryu> > show ()
16:57:59 <lambdabot>   "()"
16:58:14 <benmachine> I thought lambdabot had a show for IO that was just <IO ()>
16:58:25 <aavogt> > show (undefined :: Num a => a)
16:58:25 <lambdabot>   "* Exception: Prelude.undefined
16:58:31 <Makoryu> :t let a = show; b = show 5 in a
16:58:31 <lambdabot> forall a. (Show a) => a -> String
16:58:35 <Makoryu> Damn
16:58:59 <benmachine> :t let a = show in const (a 5) a
16:59:00 <lambdabot> String
16:59:04 <benmachine> er
16:59:09 <benmachine> :t let a = show in const a (a 5)
16:59:10 <lambdabot> forall a. (Show a) => a -> String
16:59:14 <benmachine> oh
16:59:28 <benmachine> no monomorphism restriction
16:59:31 <benmachine> I suppose
17:02:07 <Asztal> > toDyn 2
17:02:07 <lambdabot>   <<Integer>>
17:06:30 <hackagebot> statistics 0.2 - A library of statistical types, data, and functions (BryanOSullivan)
17:25:28 <tommd> For the interested: http://tommd.wordpress.com/2009/09/13/kernel-modules-in-haskell/
17:25:28 <lambdabot> Title: Kernel Modules in Haskell Â« Beware the Jabberwolk
17:25:41 <Makoryu> @pl \p -> takeWhile (not p)
17:25:41 <lambdabot> takeWhile . not
17:25:55 * tommd runs to the store
17:32:59 <NEEDMOAR> tommd: uhm. The files referenced (e.g. [3]) can't be accessed.
17:32:59 <lambdabot> NEEDMOAR: You have 1 new message. '/msg lambdabot @messages' to read it.
17:33:18 <NEEDMOAR> I get a 403 http error.
17:53:13 <tommd> NEEDMOAR: Should be fine now
17:53:15 <tommd> Thanks
18:03:10 <stylesm> so.... "unrecognized option `--with-cabal-install=../cabal-install-0.6.2/dist/build/cabal/cabal'" when make installing, any ideas? 8-|
18:04:01 <dcoutts> stylesm: it's a bug in the makefile that one notices when re-running make
18:04:21 * dcoutts needs to make a new tarball
18:05:13 <stylesm> hm, alright, so i simply remove that argument in makefile?
18:08:35 <dcoutts> stylesm: it's needed for one of the packages (the top level meta-package) but the logic is wrong so it uses it for others too when make is re-run (because it decided on the basis of if it exists yet)
18:09:13 <stylesm> so it's not needed, dcoutts?
18:09:38 <stylesm> well, in the sense that i did make, success, but can't make install
18:11:10 <dcoutts> stylesm: it's not needed in the install step
18:11:23 <Orclev> ok, I'm trying to duplicate one of the lazy foo SDL tutorials, and I need to figure how to either divide some Word32 values, or to convert a couple values that I can divide into Word32 values
18:12:49 <stylesm> so, how do i go about removing that command-line option?
18:15:31 <bos> What I've been hacking on lately: http://bit.ly/ykOeK
18:15:32 <lambdabot> Title: teideal glic deisbhÃ©alach Â» Blog Archive Â» Lazy functional yak shaving in Has ...
18:25:49 <stylesm> or, dcoutts, is it easier to change the logic to not add the option?
18:26:24 <dcoutts> stylesm: I'm not sure, it's fixed in the darcs repo but I need to re-roll the tarball
18:30:27 <copumpkin> bos: why not use the variance algorithm that's in statistics-fusion? I see the one you have takes two passes and is thus not fusible
18:31:11 <copumpkin> wait, it does look like a single pass, hmm
18:31:21 <copumpkin> oh wait, nope
18:32:04 <blackdog> bos: oh thank christ, a real benchmarking library...
18:34:30 <bos> copumpkin: there are two variance functions.
18:34:43 <bos> copumpkin: read the docs about why you'd want one over the other.
18:34:57 <stylesm> hugs it is for now! lol
18:35:18 <Orclev> hmm, is there any way to convert a Rational into a Word32?
18:35:26 <copumpkin> oh I see, I didn't see the lower one, thanks
18:37:28 <copumpkin> looks great :D
18:37:34 <bos> Thanks!
18:38:56 <copumpkin> the existing stats package was a little odd
18:39:44 <bos> you mean hstats?
18:39:45 <copumpkin> in the sense that many of the functions didn't even work on large lists due to not being strict enough and overflowing the stack
18:39:46 <copumpkin> yeah
18:40:52 <bos> i think it's newbie code, so i'm not surprised.
18:41:13 <copumpkin> ah
18:48:39 <byorgey> @type fromRational
18:48:39 <lambdabot> forall a. (Fractional a) => Rational -> a
18:49:04 <copumpkin> bos: what does teideal glic deisbhÃ©alach mean?
18:49:09 <byorgey> Orclev: what exactly do you mean?  what Word32 should, say, 3/5 be converted to?
18:49:58 <bos> copumpkin: "Clever witty title"
18:50:01 <copumpkin> lol
18:50:06 <byorgey> hahaha
18:53:00 <Axman6> "Russia's President Dmitry Medvedev issued a decree established a professional holiday - Day of the programmer, which is celebrated on Sept. 13 if a leap year - September 12, the press office of head of state."
18:54:15 <Orclev> byorgey: well, in that case I'd assume 0, but something like 1000/10 should be converted to 100::Word32
19:00:50 <BMeph> Orclev: You mean something clunky, like: 'if denominator r then (fromIntegral (numerator r))::Word32 else 0'? ;)
19:01:21 <BMeph> Er, *denominator r == 1
19:02:23 <jethr0> good <time-of-day `mod` 3>, haskell
19:02:41 <Orclev> BMeph: that would probably work if it was evenly divisible, but I'd like it to also work in instances where it's not evenly divisible but still greater than 1
19:05:06 <jethr0> i have a little issue with a program under windows. it uses a tcp connection under a forkIO and unlike linux, the windows program doesn't completely quit using "exitWith"
19:05:40 <jethr0> it's a little tricky to debug, but at least the Network.accept is still accepting connections after it was supposed to be killed as a child process
19:05:45 <jethr0> any ideas?
19:06:00 <Orclev> basically here's my issue, the code I'm trying to duplicate uses SDLs getTicks (which returns Word32 values) to calculate a FPS, and then uses delay (which takes a Word32) to limit the FPS
19:06:30 <jethr0> Orclev: ok, i'm doing sth very similar right now
19:06:45 <jethr0> and want to do it using what?
19:07:09 <jethr0> s/and/and you/
19:07:41 <Orclev> jethr0: well, I'm trying to do it the same as the way it's done in the lazy foo tutorials, but I can't divide Word32 values
19:07:56 <byorgey> Orclev: maybe instead of Rational you just want integer division with `div` ?
19:08:03 <byorgey> > 100 `div` 7
19:08:04 <lambdabot>   14
19:08:12 <Orclev> ... doh... yes
19:08:17 <byorgey> so use  `div` and fromIntegral
19:08:54 <Orclev> perfect, using div it compiles
19:09:00 <byorgey> great =)
19:09:41 <jethr0> do you know the best way to reliably kill a program including its daughter threads (exitWith) doesn't seem to work under windows...
19:13:04 <jethr0> ...
19:14:53 <tommd> jethr0: You mean OS threads?  It sounds like exitWith should terminate all Haskell threads and if it isn't I would ask on ghc@h.o
19:16:31 <jethr0> i have a ghc thread running a Network.accept that isn't killed on windows using exitWith... on linux it works fine
19:16:50 <jethr0> just wondering what the expected behavior of exitWith re: ghc child threads is
19:18:58 <tommd> Which version of GHC?  It sounds like a blocked FFI thread is hanging around.
19:19:22 <jethr0> i think 10.4, let me check
19:19:36 <jethr0> 6.10.4
19:26:17 <jethr0> hmm
19:27:46 <holmak> Is there a function like "read" that returns Nothing on failure instead of throwing an error?
19:28:32 <aavogt> @type reads
19:28:33 <lambdabot> forall a. (Read a) => String -> [(a, String)]
19:28:33 <roconnor> holmak: there is reads
19:28:59 <roconnor> AFAIK all the default implementations of Read only return [] or a singleton set
19:29:43 <roconnor> read x = let [(y,"")] = reads x in y
19:29:49 <holmak> well, i can listToMaybe that, and I'll get exactly what I want
19:29:51 <ivanm> because all default implementations of Read have a fixed, known singleton possibility of reading
19:29:52 <holmak> thanks
19:29:58 <defun> is this (nub.concat.reverse list) any different from (nub $ concat $ reverse list)? Because, the second one compiles, but the first one doesn't...
19:30:00 <ivanm> (my guess, anyway)
19:30:17 <roconnor> holmak: more complex than that cause you have to check if the unparsed string is empty.
19:30:21 <wdonnelly> (nub . concat . reverse $ list)
19:30:52 <defun> wdonnely: I see.
19:30:52 <holmak> ah, is the second element of the tuple the remainder of the string that wasn't parsed?
19:30:56 <ivanm> @seen jfredett
19:30:56 <lambdabot> jfredett is in #xmonad, #haskell-blah and #haskell. I last heard jfredett speak 5h 47m 14s ago.
19:30:58 <jethr0> any hints on the exitWith thingey under windows or should i really bother ghc@haskell.org with this?
19:31:28 <defun> > nub . concat. reverse [[1,2,3],[4,5,6]]
19:31:29 <lambdabot>   Couldn't match expected type `a -> [[a1]]'
19:31:37 <defun> > nub . concat. reverse $ [[1,2,3],[4,5,6]]
19:31:38 <lambdabot>   [4,5,6,1,2,3]
19:31:42 <ivanm> @tell jfredett you might want to double-check what you put in future versions of HWN... you copied my announcement of graphviz where I use "I like to think...", which might make people think that that is what _you_ think...
19:31:42 <lambdabot> Consider it noted.
19:31:57 <roconnor> > let holmark x = do { [(y,"")] <- return (reads x); return y  } in  holmak 7 :: Maybe Integer
19:31:58 <lambdabot>   Not in scope: `holmak'
19:32:09 <roconnor> > let holmak x = do { [(y,"")] <- return (reads x); return y  } in  holmak  7 :: Maybe Integer
19:32:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
19:32:10 <lambdabot>    arising from the literal `...
19:32:16 <defun> :t (.)
19:32:16 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:32:36 <roconnor> > let holmak x = do { [(y,"")] <- return (reads x); return y  } in  holmak  7 :: Maybe String
19:32:37 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
19:32:37 <lambdabot>    arising from the literal `...
19:32:45 <roconnor> ah duh
19:32:49 <roconnor> > let holmak x = do { [(y,"")] <- return (reads x); return y  } in  holmak "7" :: Maybe Integer
19:32:49 <lambdabot>   Just 7
19:32:55 <roconnor> > let holmak x = do { [(y,"")] <- return (reads x); return y  } in  holmak "holmak" :: Maybe Integer
19:32:56 <lambdabot>   Nothing
19:32:57 <aavogt> > reads "\"hello there\" and the rest" :: [(String,String)]
19:32:58 <lambdabot>   [("hello there"," and the rest")]
19:33:23 <holmak> looks good, this shoulf work, thanks folks
19:33:41 <roconnor> > let holmak x = do { [(y,"")] <- return (reads x); return y  } in  holmak "7holmak" :: Maybe Integer
19:33:42 <lambdabot>   Nothing
19:33:49 <roconnor> > reads "7holmak"
19:33:50 <lambdabot>   []
19:34:08 <roconnor> ah
19:34:09 <BMeph> > reads "7holmak" :: Int
19:34:09 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:34:37 <roconnor> > reads "7holmak" :: [(Int,String)]
19:34:38 <lambdabot>   [(7,"holmak")]
19:34:44 <BMeph> > reads "7holmak" :: [(Int,String)]
19:34:45 <lambdabot>   [(7,"holmak")]
19:34:56 <BMeph> roconnor: Thanks. :)
19:35:36 <BMeph> > let holmak x = do { [(y,_)] <- return (reads x); return y  } in  holmak "7holmak" :: Maybe Integer
19:35:37 <lambdabot>   Just 7
19:35:45 <BMeph> @bo
19:35:45 <lambdabot> :)
19:36:54 <roconnor> > read "7holmak" :: Int
19:36:55 <lambdabot>   * Exception: Prelude.read: no parse
19:38:04 <aavogt> @hoogle reads
19:38:04 <lambdabot> Prelude reads :: Read a => ReadS a
19:38:04 <lambdabot> Text.Read reads :: Read a => ReadS a
19:38:04 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
19:38:31 <holmak> really guys, i've got it under control, thanks :D
19:38:45 <roconnor> once #haskell gets started ...
19:38:57 <aavogt> Control.Applicative.Error.maybeRead :: (Read a) => String -> Maybe a
19:39:04 <copumpkin> :P
19:39:23 <roconnor> holmak: you are fairly lucky that we haven't one off talking about using Alternative.
19:39:35 <roconnor> dah
19:40:16 <roconnor> I think aavogt might be walking towards that topic
19:40:24 <jsoffer> I want to translate the Haskell Cheat Sheet to spanish - is there any work on this already?
19:40:58 <BMeph> jsoffer: No, we were waiting for you! ;)
19:41:42 <roconnor> @hoogle String -> Maybe a
19:41:42 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
19:41:42 <lambdabot> Prelude fail :: Monad m => String -> m a
19:41:42 <lambdabot> Control.Monad fail :: Monad m => String -> m a
19:41:47 <jethr0> jsoffer: you mean there is a spanish haskell? ;)
19:42:14 <roconnor> Network.CGI.Protocol ...
19:42:16 * roconnor sighs
19:42:36 <jethr0> System.IO.exitWith
19:42:39 * jethr0 sighs
19:42:54 <jsoffer> Only the documentation... it would be somewhat silly to talk of "haz" notation vs. >>= notation
19:43:09 <jethr0> hehe
19:45:11 <canvon> > loop (\(b,d) -> (d,f d)) x
19:45:11 <lambdabot>   Add a type signature
19:45:15 <roconnor> hmm, parseTime is lower in the hoogle search results that I think it ought to be.
19:45:38 <canvon> > loop (\(b,d) -> (d,f d :: Expr -> Expr)) x
19:45:39 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
19:45:39 <lambdabot>    arising from...
19:45:53 <canvon> hmm..
19:46:12 <canvon> > loop (\(b,d) -> (d,b:d)) 'x'
19:46:13 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
19:47:14 <jethr0> btw, if i write an infinite recursive loop in IO, is that unfolded as an infinite list before it's consumed by the RTS?
19:47:28 <Twey> No
19:47:59 <Twey> Lists and loops aren't always the same thing âº
19:48:32 <jethr0> i was just wondering theoretically what the RTS does with an infinite recursion in IO...
19:48:46 <Twey> It just executes it.
19:48:50 <Gracenotes> the general way of doing IO actions of a list, 'sequence', does in fact do them in sequence, one after another
19:49:03 <Gracenotes> even for infinite lists
19:49:29 <Twey> Aye.
19:49:41 <Twey> That's not the same thing as an IO loop, though.
19:49:45 <jethr0> 'myFunc = print "hello" >> myFunc'
19:49:52 <Gracenotes> there is even a method "forever" that repeats the same IO action again and again
19:49:55 <jethr0> Twey: i am aware of that
19:49:57 <Gracenotes> forever (print "hello")
19:50:32 <Twey> Aye
19:50:35 <jethr0> hmm, i should probably have a look at how the rts does IO to answer my question ^_^
19:50:39 <Twey> forever a = a >> forever a
19:50:42 <Gracenotes> the whole point of making IO a monad, really, is that actions happen one after another :o
19:50:55 <Twey> jethr0: It's more a case of understanding how Haskell evaluation works.
19:51:11 <roconnor> > mapM_ (repeat (print "hello"))
19:51:11 <lambdabot>   Couldn't match expected type `a -> m b'
19:51:21 <roconnor> > sequence_ (repeat (print "hello"))
19:51:22 <lambdabot>   No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
19:51:22 <lambdabot>    arising from a use of...
19:51:34 <Gracenotes> for 'regular' code, order of operations is not as important to maintain, as long as what needs to be calculated gets calculated (it is still relatively predictable, however)
19:52:05 <roconnor> jethr0: when it comes time for the RTS to run some IO action, it only evaluates just barely enough to execute the one action.
19:53:04 <absentia> re
19:53:12 <jethr0> roconnor: k, thx. does it see "IO actions" as IO though or do only the "core" IO functions (like print, hPutStr, or whatever sits at the bottom) interpreted as "real IO" at that level?
19:53:29 <jethr0> s/do/are/
19:53:46 <roconnor> right, I should have said when the RTS wants to run a primitive IO action
19:55:07 <jethr0> if i do "forever (print "hello")", i guess that is substituted into whatever the definitions of "forever" and "print" are, then it executes the first primitive and gives control back to "normal" haskell code?
19:55:35 <jethr0> as you can see, i really have no idea how the behind-the-curtain IO interleaving works
19:55:37 <roconnor> jethr0: that is a fair model of what is happening.
19:55:59 <roconnor> I'd say gives control back to the RTS
19:56:14 <roconnor> which goes computing for the next primitive IO op
19:56:34 <jethr0> i once read that IO is like a worm or sth like that that is always enclosed by the IO type and therefore is always connected to "main", even if the code branches and does gets really complex
19:57:00 <roconnor> jethr0: if you ignore forkIO, that is essentially true.
19:57:14 <canvon> > loop (\(b,d) -> (d,f d :: Expr)) x
19:57:14 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
19:57:15 <jethr0> probably one of the papers like "tackling the awkward squad".
19:57:30 <canvon> copumpkin: reveals loops loopiness :)
19:57:36 <jethr0> is there a good document to study how the RTS does its thing?
19:57:39 <copumpkin> canvon: hah
19:57:58 <copumpkin> canvon: not quite as loopy as it could be though, as that just looks like fix now
19:58:05 <roconnor> jethr0: understanding ghc's RTS isn't the best way of understanding IO in haskell, IMHO
19:58:12 <canvon> copumpkin: yeah that's true :(
19:58:23 <jethr0> roconnor: i think my understanding of how to use IO is pretty decent
19:58:44 <absentia> ya
19:59:06 <canvon> copumpkin: btw, do you have an example for a (slightly) non-trivial use of loop? i could only think of a replacement for fix so far, as you saw.
19:59:46 <copumpkin> canvon: I think blackh's tutorial on arrows had one
20:00:24 <jethr0> isn't there some use of loop arrow in reactive?
20:00:43 <jethr0>  /frp/yampa/...?
20:01:13 <canvon> copumpkin: where can i find it?
20:01:49 <copumpkin> canvon: can't remember, it was posted on the haskell reddit recently I think
20:05:05 <canvon> it seems to be here: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
20:05:20 <copumpkin> ah yes
20:17:33 <Woof> Cale?
20:17:46 <copumpkin> meow
20:37:29 * SamB wonders about a gkrellm plugin to show cpu speed
20:39:56 <copumpkin> gkrellm?
20:40:40 <SamB> copumpkin: you know, those graphs of system vitals you keep on the left side of your screen ?
20:40:45 <copumpkin> ah
20:40:50 <SamB> or don't you ?
20:41:03 <copumpkin> yes, I've definitely seen them, but I didn't recognize the name :)
20:41:10 <copumpkin> I'm sure there are other implementations of the idea
20:41:26 <SamB> hmm, apparantly gkrellm-x86info is the one I want ...
20:42:01 <SamB> copumpkin: oh, probably -- but probably none of 'em can display so much info or so nicely
20:42:21 <hydo> Where on windows is the cabal cache located?  I'm using the latest haskell platform and I'm trying to set up leksah.
20:42:37 <Veinor> I use conky :D
20:43:01 <SamB> well, maybe someone wrote a work-alike for windows or something ;-)
20:50:24 <SamB> hmm ... but gkrellm-x86info is giving me a much higher number than cpufreq-info claims should be the case ...
21:22:46 <Gracenotes> hm, apparently graphviz's dot just uses the median method+adjacent exchange for reducing edge crossings
21:23:34 <dancor> @pl \ f -> g (f x) (f y) (f z)
21:23:34 <lambdabot> ap (liftM2 g ($ x) ($ y)) ($ z)
21:24:03 <dancor> @pl \ f -> g (f x) (f y)
21:24:04 <lambdabot> liftM2 g ($ x) ($ y)
21:24:24 <copumpkin> :t on
21:24:25 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:24:42 <dancor> @unpl liftM3 g ($ x) ($ y) ($ z)
21:24:42 <lambdabot> liftM3 g (\ a -> a x) (\ b -> b y) (\ c -> c z)
21:25:42 <canvon> @unpl liftM3 g ($ x) ($ y) ($ z)
21:25:42 <lambdabot> liftM3 g (\ a -> a x) (\ b -> b y) (\ c -> c z)
21:26:08 <canvon> :t \ f -> g (f x) (f y) (f z)
21:26:09 <lambdabot> forall t t1. (SimpleReflect.FromExpr (t -> t -> t -> t1)) => (Expr -> t) -> t1
21:26:27 <canvon> :t liftM3 g ($ x) ($ y) ($ z)
21:26:28 <lambdabot> forall r b. (Show b, SimpleReflect.FromExpr r) => (Expr -> b) -> r
21:27:41 <ivanm> Gracenotes: I think it's a bit more complicated than that
21:27:51 <ivanm> and depending on which algorithm you ask for...
21:28:51 <Gracenotes> hm, really... the function 'mincross_step' just does up/down passes, depending the iteration number, followed by a transpose function
21:30:22 <copumpkin> is there an easy way to determine if a peano natural is a square?
21:31:03 <Gracenotes> copumpkin: subtract 1, then 3, then 5, etc.?
21:31:05 <Jafet> A natural number?
21:31:21 <Jafet> Square the square root
21:31:31 <Gracenotes> O(n), but not sure how you'd get better than that :)
21:31:42 <copumpkin> Gracenotes: I'm sort of trying to prove that that procedure produces squares :P
21:31:48 <copumpkin> so I'm not sure that'll help :)
21:31:52 <Gracenotes> hah.
21:32:02 <Gracenotes> s/determine/prove/ ;)
21:32:40 <Jafet> That reminds me of the time I proved the correctness of a numerical library using brute force
21:32:45 <SamB> copumpkin: well, why don't you prove that that gives you the same thing as squaring the appropriate ns ?
21:32:50 <Gracenotes> well, logically stated, there exists a number <= it such that num*num = it
21:33:06 <sohum> I just realised
21:33:08 <SamB> copumpkin: or you just can't figure out how to do that ?
21:33:10 <Gracenotes> ..don't think that's useful from a formal proof perspective either
21:33:19 <sohum> I'm not sure if haskell implements it this way, but
21:33:23 <SamB> actually, sure it is!
21:33:28 <sohum> arguably, f x y z = x `f` y z = y `(x `f`)` z
21:33:55 <copumpkin> SamB: well I was doing to do a simple inductive proof of the sum of the first n odd numbers being n^2
21:34:03 <SamB> you can prove it because clearly n*S n = n+(n*n)
21:34:05 <copumpkin> I guess I don't need an isSquare for that
21:34:16 <Gracenotes> copumpkin: it's not enough to do something with n*n and (n+1)*(n+1)?
21:34:35 <Gracenotes> if you have distributive, at least
21:34:42 <SamB> Gracenotes: of course he has
21:34:46 <SamB> it's in stdlib
21:34:51 <copumpkin> ?
21:34:59 <copumpkin> nah, I haven't proved distributive yet
21:34:59 <Gracenotes> what is this? coq?
21:35:02 <copumpkin> agda
21:35:06 <SamB> oh, you're not using the stdlib?
21:35:06 <copumpkin> I'm not touching the std lib
21:35:15 <canvon> sohum: in f x y z, z is applied to (f x y). in x `f` y z, z is applied to y. in the first, y is just an argument to f, in the second, y would need to be a function.
21:35:16 <SamB> well, it's not that hard to prove it yourself iirc ?
21:35:24 <copumpkin> it probably isn't, I just forgot about it :)
21:35:27 <SamB> you'll surely benefit from it ;-)
21:35:40 <SamB> oh, agda
21:35:41 <canvon> er, the other way round. ;) @"apply"
21:35:49 <SamB> no wonder you don't want to touch stdlib
21:36:03 <SamB> it is rather spotty, and uses so much unicode!
21:36:06 <ivanm> Gracenotes: you're actually looking at the code? :o
21:36:14 <Gracenotes> is there a way to just say "this is fact" in Agda, without having to prove it? like, a dummy method in the proof?
21:36:15 <ivanm> and by "dot", do you mean the actual dot command?
21:36:16 <SamB> and it's slow, too, probably ;-)
21:36:17 <copumpkin> SamB: I'm using just as much actually :P
21:36:27 <copumpkin> Gracenotes: you can put a hole in your definition, or postulate it
21:36:33 <Gracenotes> ...even thought it might yield undecidable results
21:36:38 <SamB> copumpkin: yeah, but at least if you're doing it you know which identically-rendered character to type ;-)
21:36:47 <copumpkin> SamB: true :)
21:37:00 <copumpkin> SamB: it's mostly just to play around, don't really have a need to prove any of this stuff :)
21:37:05 <SamB> (I may be exhaggerating slightly -- the characters might differ by a few pixels ;-)
21:37:21 <sohum> canvon: well, no, because it's left associative. x `f` y z = ((x `f`) y) z
21:37:23 <Gracenotes> ivanm: yeah, the C source code for dot. I started looking through that, but I'm finding the paper it's based on to be an easier read (duh), and I'm doing some basic cross-referencing now
21:37:27 <copumpkin> > let (â>) = (+) in 5 â> 6
21:37:27 <lambdabot>   11
21:37:34 <ivanm> Gracenotes: heh
21:37:35 <SamB> copumpkin: I think I may well have proved those things in Agda ...
21:37:37 <ivanm> what are you doing this for?
21:37:39 <SamB> or maybe it was Epigram?
21:37:44 <SamB> or coq
21:37:47 <SamB> or heck, all three ;-)
21:37:49 <canvon> sohum: but function application has the highest precedence, so it's x `f` (y z)
21:37:56 <SamB> the nat things, I mean, but not that square one ...
21:38:09 <sohum> canvon: right, and x `f` is a form of function application
21:38:11 <copumpkin> SamB: I expect once you get one you get the others not too far behind :P
21:38:12 <canvon> sohum: but f x y z = (x `f` y) z should hold
21:38:33 <Gracenotes> ivanm: trying to see how far I can go doing a *basic* STT-type method for layered graph drawing, but in Haskell, which will be relayed to a website and painted in canvas
21:38:49 <Gracenotes> ...if all goes well. really well.
21:38:53 <ivanm> Gracenotes: IIRC, there's better algorithms around now for graph drawing...
21:39:04 <ivanm> (well, by "better" I mean "newer" :p )
21:39:33 <Gracenotes> mm. not STT exactly per se, but ranking -> ordering -> positioning -> rendering
21:40:00 <SamB> well, it really looks like having my CPU clock down when it gets >50 celcius is preventing my computer from "randomly" rebooting ...
21:40:07 <canvon> 06:38:09 < sohum> canvon: right, and x `f` is a form of function application <- no, `f` is an infix operator, not "plain" function application
21:40:13 <ivanm> Gracenotes: STT?
21:40:18 <ivanm> SamB: heh
21:40:33 <sohum> canvon: why not? I'm not talking in Haskell, but just as a theoretical thing
21:40:51 <canvon> sohum: ok, then it could be defined that way ;)
21:40:56 <SamB> ... so I'm guessing it's not a problem with the mobo or the RAM ;-)
21:40:57 <Gracenotes> ivanm: something I haven't seen much of is efficiently maintaining aesthetic relationships in layered graphs while adding/removing/merging nodes, but the graphs I'm working on are somewhat small so I could probably just do recalculation for the whole thing
21:41:11 <SamB> in fact, I'm thinking it's probably a fan problem ...
21:41:15 <Gracenotes> ivanm: Sugiyama method.. forgot who T and T are -.-
21:41:30 <SamB> ... or an ACPI problem :-(
21:41:31 <ivanm> Gracenotes: yeah, I don't think it's really possible to have a good graph layout that you can arbitrarily add vertices/edges to whilst keeping it looking nice...
21:41:36 <ivanm> not without re-drawing it
21:42:40 <SamB> ivanm: well, it would be nice if you could redraw it without totally altering the layout ...
21:43:09 <SamB> you know, for animations or series' of figures or whatever ...
21:43:12 <ivanm> SamB: yes, it would... but whether it's feasible or not is a different story
21:43:16 <Gracenotes> in the setup I'm working with, there is a huge graph of thousands of nodes, and the point is to show subgraphs of 10, maybe 40 nodes at most
21:43:22 <ivanm> I suppose if you have a "good-enough" criterai...
21:43:26 <SamB> ivanm: well, it must be at least sometimes ;-)
21:43:55 <Gracenotes> an idea I have is to calculate several ideal situations for the entire graph, and locally optimize them for smaller subgraphs, but getting closer to the global model for larger subgraphs
21:44:31 <Gracenotes> after all, it is easy to just remove nodes and display the results there, but some shrinking would be nice, which might have to be undone when adding nodes back
21:45:13 <Gracenotes> one problem is that ranks have several configurations that is very sensitive to the absence/presence of particular nodes
21:45:18 <Gracenotes> are
21:45:40 <ivanm> bugger, whilst reading the Dot language wikipedia page, I've just come across a bit of code that IIRC wasn't in the spec page and that my graphviz lib can't parse :@
21:46:24 <Gracenotes> what does your graphviz lib do?
21:47:03 <ivanm> @hackage graphviz
21:47:03 <lambdabot> http://hackage.haskell.org/package/graphviz
21:47:03 <ivanm> ;-)
21:47:09 <Gracenotes> binding?
21:47:13 <ivanm> yeah
21:47:49 <ivanm> (though technically more of a wrapper library than bindings)
21:48:37 <Gracenotes> so anyway, the global/local optimization is interesting, but I doubt it can be quantified so well..
21:51:14 <dancor> @src on
21:51:14 <lambdabot> (*) `on` f = \x y -> f x * f y
21:52:35 <Makoryu> @pl \f x -> on f ($x)
21:52:35 <lambdabot> (. flip id) . on
21:53:08 <Makoryu> @unpl liftA2
21:53:08 <lambdabot> liftA2
21:53:13 <ivanm> flip id?
21:53:16 <ivanm> @type flip id
21:53:17 <lambdabot> forall b c. b -> (b -> c) -> c
21:53:19 <Makoryu> :t (. flip id) . on
21:53:19 <lambdabot> forall a b c. (b -> b -> c) -> a -> (a -> b) -> (a -> b) -> c
21:53:23 <ivanm> ahhh
21:53:24 <Makoryu> :t liftA2
21:53:25 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
21:55:33 <dancor> let on3 f g a b c = f (g a) (g b) (g c)
21:55:36 <dancor> @let on3 f g a b c = f (g a) (g b) (g c)
21:55:37 <lambdabot>  Defined.
21:55:54 <dancor> is there an `ap`-style way to do onN
22:02:14 <dolio> @type \f g a b c -> (f <$> ($a) <*> ($b) <*> ($c)) g
22:02:15 <lambdabot> forall b a b1. (b1 -> b1 -> b1 -> b) -> (a -> b1) -> a -> a -> a -> b
22:03:10 <canvon> @pl \ f g a b c -> f (g a) (g b) (g c)
22:03:11 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
22:03:19 <canvon> ... omg ;)
22:03:53 <canvon> @pl \ f a b c g -> f (g a) (g b) (g c)
22:03:53 <lambdabot> flip flip (flip id) . ((flip . (((.) . ap) .)) .) . flip flip (flip id) . (((.) . ap) .) . (. flip id) . (.)
22:06:10 <Makoryu> @pl \f g a b c -> f (g a) (g b) (g c)
22:06:10 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
22:06:15 <Makoryu> Yeah.
22:06:35 <Makoryu> Whoops you did that one.
22:08:43 <canvon> nvm, happened to me just half an hour ago...
22:09:10 <dancor> dolio: nice
22:10:19 <hackagebot> statistics 0.2.1 - A library of statistical types, data, and functions (BryanOSullivan)
22:12:08 <ivanm> bos: I could have done with that library this time last year... :s
22:12:30 <bos> ivanm: alas
22:13:11 <ivanm> is the hstats package now definitely completely useless?
22:14:15 <copumpkin> I think it always has been almost that
22:15:19 <ivanm> bos: does it really work with base-2, etc.? :o
22:15:26 <Zeiris> Newb question: I had the confusing idea that you couldn't use monads in pure code, but that only applies to the IO monad right? Or can even the IO monad be used in a pure function if you wrap it with something like "woops :: IO a -> Int"?
22:15:39 <ivanm> Zeiris: the former
22:15:45 <bos> ivanm: base-2?
22:15:55 <ivanm> (can't do IO and related monads in pure code, but can use monads in pure code for list monad, etc.)
22:16:03 <ivanm> bos: the version of base before base-3? :p
22:16:14 <Zeiris> ivanm, what determines whether or not a certain monad can be used in pure code?
22:16:29 <ivanm> Zeiris: if it has IO in it, it can't ;-)
22:16:40 <Zeiris> That simple eh.
22:16:49 <ivanm> Zeiris: pure means that given the same inputs, it will always return the same outputs
22:16:49 <mmorrow> Zeiris: if you have a function (m a -> a), then it can be used in pure code
22:17:04 <ivanm> mmorrow: well, and the function isn't unsafe* ;-)
22:17:08 <bos> ivanm: there are a few functions in hstats that are not in the statistics package.
22:17:19 <copumpkin> ivanm: that's a requirement only if you don't mind unsafety
22:17:20 <bos> ivanm: if you want to implement them, please send me patches.
22:17:25 <mmorrow> ivanm: that doesn't stop you though ;)
22:17:40 <ivanm> bos: heh, I don't do much statistics any more ;-)
22:17:49 <ivanm> mmorrow: well, it _should_
22:17:53 <bos> ivanm: but be warned, i think that the code in hstats is generally crap, and not something that's safe to just import.
22:18:03 <ivanm> it is
22:18:16 <ivanm> I wanted to use it last year, but didn't because the mean function, etc. are wrong
22:18:44 <ivanm> and ended up re-implementing mean, correlation, etc. based on the blog article dons did on using mean as a sample function to speed up
22:18:46 <SamB> ivanm: unless you really *do* know what you are doing
22:18:53 <ivanm> tried contacting the dev, no response :(
22:18:56 <ivanm> SamB: true
22:19:03 <SamB> of course, generally the only way to find out otherwise is to try and fail ?
22:19:14 <mmorrow> exactly
22:19:32 <ivanm> SamB: or to know that the function you're unsafing is actually pure...
22:19:39 <SamB> ivanm: or that!
22:19:43 <ivanm> how can you "definitely" fail in finding out it isn't pure?
22:20:06 <copumpkin> you get an impurity exception
22:20:09 <copumpkin> like, duh
22:20:16 <ivanm> heh
22:20:25 <SamB> ivanm: did I say you definately would fail ?
22:20:26 <ivanm> I don't think ghc is _that_ smart yet
22:20:37 <ivanm> SamB: fine, you didn't
22:20:44 <SamB> but, hopefully you would test your program some ?
22:21:09 <ivanm> hopefully :p
22:21:25 <SamB> oh, man, I really have to go to bed, it's getting much later than I knew ...
22:21:32 <ivanm> but still, how can you test the safety/unsafety of a possibly pure IO action?
22:22:07 <copumpkin> @remember jfredett A monster! HAH! It will not be a monster, but a god! ALL SHALL BOW BEFORE MY SPAWN AND DESPAIR! ALL HAIL THE PROGRAMMER CHILD! ALL HAIL THE HYPNOTOAD!
22:22:07 <lambdabot> It is forever etched in my memory.
22:22:10 <SamB> well, if you messed up, hopefully it bites you in the ass ...
22:22:34 <ivanm> copumpkin: ummm.... where's that quote from?
22:22:38 <SamB> ... I mean, you really do need unsafePerformIO sometimes ...
22:22:42 <ivanm> SamB: without biting off too much else of your system?
22:22:45 <copumpkin> ivanm: wouldn't you like to know
22:23:02 <SamB> ivanm: I mean, look at Data.ByteString and friends ...
22:23:19 <ivanm> yeah, memory management
22:23:32 <copumpkin> ivanm: http://www.reddit.com/r/programming/comments/9jy8p/12yearold_cousin_wants_to_learn_to_program/c0d2z6r
22:23:33 <lambdabot> Title: jfredett comments on 12-year-old cousin wants to learn to program computers. Any ..., http://tinyurl.com/otlvom
22:23:35 <SamB> and writing into arrays ...
22:23:43 <SamB> ivanm: or even Data.Array.*
22:23:56 <ivanm> jfredett == new HWN editor?
22:23:56 <SamB> and I don't mean the mutable ones ;-P
22:24:01 <copumpkin> ivanm: yep
22:24:33 <ivanm> copumpkin: jedhezra's response is better... >_>
22:24:36 <SamB> ... hypnotard ?
22:24:43 <copumpkin> isn't it weird that the language we use to express regular expressions is itself not regular? is that an inherent property? would it be possible to come up with another language that reduces to a DFA that is itself regular?
22:25:00 <copumpkin> probably not, eh
22:25:15 <tessier> gwern: Protesting Vietnam? You're a wee bit late.
22:25:30 <copumpkin> tessier: as are you, reacting to him :P
22:25:32 <SamB> copumpkin: no
22:25:36 <ivanm> copumpkin: heh
22:25:37 <SamB> it isn't possible
22:26:07 <SamB> unless, of course, you allow the language to contain things that don't correspond with DFAs!
22:27:17 <copumpkin> like what? how is babby formed?
22:28:02 <SamB> what I mean is, such a language would not guarentee that a string in that language was valid ...
22:28:17 <SamB> unlikes a traditional regular expression language
22:29:01 <copumpkin> hmm
22:29:08 <copumpkin> you could have the "identity language" I guess
22:29:48 <BMeph> copumpkin: Isn't that (in a way) part of the point of PEGs? Anyone else, feel free to correct me. :)
22:29:52 <copumpkin> not exactly interesting
22:30:00 <SamB> copumpkin: well, I was thinking of a slightly more informative language, maybe
22:30:09 <copumpkin> BMeph: but they're for context-free languages
22:30:15 <SamB> one that actually gave you something that could easily be transformed into a DFA if valid
22:30:46 <copumpkin> well, by identity language, I mean the language that only recognized values that are itself
22:30:58 <copumpkin> so if I wrote the "abc" program, it would only recognize abc
22:33:28 <SamB> g'night, folks!
22:34:00 <canvon> i think fgrep is an interpreter for a variant of that language...
22:34:13 <SamB> canvon: heh
22:34:16 <SamB> you're right!
22:34:22 <SamB> now good night for realz ;-P
22:34:31 <canvon> g'night SamB ;)
22:41:17 <shikanai> @pl last3 xs = head (drop (length xs - 1) xs)
22:41:17 <lambdabot> last3 = head . (drop =<< subtract 1 . length)
22:42:08 <shikanai> @pl last2 xs = xs !! (length xs - 1)
22:42:08 <lambdabot> last2 = ap (!!) (subtract 1 . length)
22:46:20 <absentia> xn/whois cale
22:50:16 <sohum> how does quickcheck find all the functions that begin with prop_?
22:50:45 <BMeph> sohum: Surprisingly well. ;)
22:51:00 <sohum> BMeph: :P
22:51:07 * BMeph laughs
22:56:59 <ivanm> @seen mmorrow
22:56:59 <lambdabot> mmorrow is in #haskell-blah, #haskell and #ghc. I last heard mmorrow speak 37m 45s ago.
22:57:12 <ivanm> mmorrow: why doesn't cairo need your haskell-src-meta package anymore?
22:57:19 <ivanm> s/cairo/vacuum/
22:57:31 <canvon> :t ap (!!) (subtract 1 . length)
22:57:31 <lambdabot> forall b. [b] -> b
22:57:33 <canvon> :t flip (!!) =<< subtract 1 . length
22:57:34 <lambdabot> forall a. [a] -> a
22:58:38 <shikanai> I can't get that one with ap to compile
22:59:06 <canvon> you need Control.Monad.Instances, for Monad ((->) r)
22:59:17 <shikanai> oh!
22:59:42 <canvon> does that help?
22:59:49 <shikanai> it compiled!  omg
22:59:53 <canvon> :D
23:00:06 <shikanai> wow that's insane
23:00:14 <shikanai> I have no idea how it works, but somehow it does
23:00:21 <canvon> :-)
23:01:06 <shikanai> thanks a lot--someday I'll figure that out!
23:01:22 <shikanai> Right now I'm going through the "what does it look like in point-free?" phase
23:01:29 <shikanai> sometimes it looks better
23:01:32 <shikanai> sometimes much worse
23:01:42 <mmorrow> ivanm: the only thing it was using it for was "ppHs", which is (Text.PrettyPrint . Language.Haskell.Meta.Utils.pretty), which while convenient, wasn't worth adding like 5MB to linked binaries (on account of haskell-src-meta + haskell-src-exts), so i dropped the dep
23:01:45 <canvon> the ((->) r) monad are functions that all get the same argument applied, and the "value" that lies "in" the monad is the result of that function application
23:02:36 <shikanai> * ponders canvon's statement
23:02:39 <ivanm> mmorrow: ahhh
23:02:53 <ivanm> thought -meta did more than that, wondering why the deps for vacuum suddenly dropped ;-)
23:04:16 <shikanai> canvon: ok I get it: somehow using 'ap' here allows the same input list to be passed to both (!!) and (subtract 1 . length)
23:04:25 <canvon> > let m = (+1); m' = do x <- m; return (x * 2) in m' 4  -- should be 10
23:04:26 <lambdabot>   10
23:05:10 <shikanai> ooo I've never seen "return __ in ___" before!
23:05:22 <canvon> here the increment function is interpreted as an ((->) r) monad; the value "in" the monad is the result of the increment.
23:05:31 <mmorrow> ivanm: (err, s/Text.PrettyPrint/Text.PrettyPrint.text/)
23:05:44 <ivanm> heh
23:05:50 <ivanm> yeah, I guessed it was something like that
23:05:56 <canvon> in m' that result is used as if the increment already happened, but what should be incremented at all is passed into m' only later.
23:06:00 <ivanm> so you just copy-pasted the code, or dropped the functionality?
23:06:02 <canvon> it's a bit like tha State monad
23:06:23 <canvon> shikanai: well, basically, yes ;)
23:06:52 <mmorrow> ivanm: i just commented out ppHs (it wasn't used for anything in particular, just was meant to provide a handay way to format the Show'n output of vacuum in a readable way)
23:07:05 <shikanai> @unso do x <- m; return (x * 2) in m' 4
23:07:05 <lambdabot>  Parse error at "in" (column 27)
23:07:09 <shikanai> @undo do x <- m; return (x * 2) in m' 4
23:07:09 <lambdabot>  Parse error at "in" (column 27)
23:07:17 <canvon> shikanai: that "in" is just part of the "let".
23:07:27 <mmorrow> ppHs uses haskell-src-exts to parse the Show output as a haskell expression, then prettyprints that back to a String
23:07:39 <shikanai> canvon: oh yeah duh
23:07:53 <mmorrow> s/ppHs/Language.Haskell.Meta.Utils.pretty/
23:08:35 <mmorrow> so instead of getting a wall of jumbled show output, you get a nice pretty formatted display
23:09:03 <canvon> > let { m = (+1); m' = do { x <- m; return (x * 2) } } in m' 4   -- this is just a complicated way of saying: (\i -> const (((+1) i) * 2) i) 4  -- i.e., (4 + 1) * 2
23:09:04 <lambdabot>   10
23:09:23 <ivanm> ooohhhh..... pretty...
23:09:24 <ivanm> :p
23:09:32 <canvon> ..oh dear, i'm making it unnecessary complicated now ;)
23:09:43 <ivanm> mmorrow: but you're using GHC for parsing though, so you didn't need haskell-src-* for that?
23:09:50 <canvon> 08:04:16 < shikanai> canvon: ok I get it: somehow using 'ap' here allows the same input list to be passed to both (!!) and (subtract 1 . length) <- in practical terms, that's just all there is to it.
23:09:55 <mmorrow> ivanm: i hacked around the GHC dep as well
23:10:10 <mmorrow> ivanm: by reproducing all that i was using GHC for in vacuum itself
23:10:22 <ivanm> :o
23:10:31 <ivanm> so vacuum is a whole bunch of copy-pasta? :p
23:10:48 <mmorrow> ivanm: so the vacuum package is completely self-contained (and doesn't charge a 30MB-fee to your linked binary)
23:11:13 * BMeph prefers 'succ' to '(+1)'
23:11:27 * ivanm does as well
23:11:31 * BMeph also prefers 'pred' to '(subtract 1)'
23:11:35 <mmorrow> ivanm: it only took about one module of copy/pasting (w/ a minor mod here and there)
23:11:58 <mmorrow> ivanm: http://hackage.haskell.org/packages/archive/vacuum/1.0.0/doc/html/src/GHC-Vacuum-Internal.html
23:11:59 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/pa5vgw
23:12:07 <mmorrow> "-- * Fabricate what we need to avoid the ghc pkg dep"
23:12:10 <shikanai> canvon: thanks for the explanation.  My only experience with monads so far is the List monad, but I've saved your examples in the "stuff to look at after learning more" file
23:12:47 <shikanai> canvon: one thing I'd really like to know is whether you think the point-free version with ap is readable?
23:12:54 <ivanm> mmorrow: you might also want to update vacuum's home page, seeing as how version 1 is out now...
23:12:57 <canvon> BMeph: somehow i never got the hang of using Enum explicitly... but i guess i should really use succ and pred where appropriate
23:13:15 <mmorrow> ivanm: ahh, right. thx for the reminder.
23:13:29 <ivanm> no worries
23:13:45 <ivanm> mmorrow: what does MagicHash do?
23:14:06 <BMeph> shikanai: The 'trick' to understanding monads is that there really is no 'trick'; it's just like "design patterns" in that folks noticed an abstract way i which a whole lot of code works in a similar way, and that similar way resembles the way that monads work in Cat Theory. :)
23:14:06 <mmorrow> ivanm: it allows you to have identifiers ending in `#'
23:14:17 <ivanm> ahhh
23:14:18 <mmorrow> ivanm: (which -fglasgow-exts turns on too)
23:14:20 <BMeph> way *in
23:14:21 <ivanm> pseudo-boxed?
23:14:37 <mmorrow> ivanm: just turns on that syntax
23:14:51 <mmorrow> ivanm: otherwise foo# = (4::Int) would be a parse error
23:14:57 <ivanm> *nod*
23:15:04 <canvon> shikanai: :) -- i'm no haskell expert, but "ap (!!) (subtract 1 . length)" looks ok to me. it would even look nicer with applicative functors (Control.Applicative), where <*> essentially is `ap`: (!!) <*> subtract 1 . length
23:15:06 <ivanm> I take it that kind of syntax isn't covered by the report?
23:15:17 <mmorrow> ivanm: right, a ghc extension
23:15:42 <canvon> :t ap
23:15:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:15:47 <canvon> :t (<*>)
23:15:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:16:55 <canvon> Applicative ((->) r) is basically the same as Monad ((->) r), with ap = (<*>), and liftM = (<$>)
23:18:49 <shikanai> canvon: ack now there's TWO mind-blowing ways to do it!
23:19:17 <canvon> :)
23:20:24 <canvon> .oO("some people say, i've got i problem, so i'll use $x for the job! - now they've got two problems.", for $x in {sed, awk, perl, c++, ...})
23:20:39 <shikanai> canvon: But I think I see what you mean--that the precedence of <*> allows you to drop the parens in the definition: last2 = (!!) <*> subtract 1 . length
23:20:44 <canvon>    (..and, apparently, applicative functors, too ^^')
23:21:11 <shikanai> canvon: lol I'd only heard that for regular expressions before
23:21:17 <canvon> ^^
23:22:02 <canvon> and yes, losing the parens is a nice advantage. but you could have that also by using ap infix: (!!) `ap` subtract 1 . length
23:22:27 <canvon> but a "real" infix operator looks even nicer ;)
23:23:00 <shikanai> canvon: with `ap` I got a precedence parsing error: it says it can't mix `ap` and '.' cuz they're both infix 9
23:23:21 <canvon> oh dear ;)
23:23:34 <canvon> then you don't get the advantage of losing the parens, then
23:23:38 <canvon> *so
23:24:22 <canvon> but if the right side would have been plain function application (e.g., just "subtract 1"), you wouldn't have needed parens
23:24:43 <shikanai> gotcha
23:25:01 <shikanai> I like the pointfree version with ap (or <*>)--it feels very Forthish
23:25:17 <canvon> :p
23:25:30 <canvon> mh.. guess i really have to have a look at Forth, some day ^^'
23:26:00 <canvon> its used in the Sparc boot loader (OpenBoot), isn't it?
23:26:05 <canvon> 'it's
23:26:27 <shikanai> canvon: Well, actually I've never used the *real* Forth, just Factor and Cat, which are its more modern descendants
23:27:37 <shikanai> canvon: Factor is kinda fun in, but since you must always be pointfree, you can imagine the pros and cons
23:29:24 <canvon> hehe, yeah
23:31:53 <shikanai> ooh ooh while I've got you here, would you do one more quick readability evaluation for me?
23:32:16 <shikanai> I have four versions of a function that looks up keys in an assoc list
23:32:30 <shikanai> they get progressively more unreadable
23:32:44 <shikanai> well, I think they do anyway, but I'm a n00b
23:32:55 <shikanai> maybe to a l33t haskell h4x0r they're all transparent?
23:32:59 <shikanai> anyway here they are:
23:33:17 <shikanai> find0, find1, find2, find3 :: Eq a => a -> [(a,b)] -> [b]
23:33:21 <shikanai> find3 k t = [v | (k',v) <- t, k == k']
23:33:24 <shikanai> find2 k t = map snd (filter (\x -> fst x == k) t)
23:33:30 <shikanai> find1 k   = map snd . filter ((==k) . fst)
23:33:33 <shikanai> find0     = (map snd .) . filter . (. fst) . (==) -- pointfree by lambdabot
23:33:56 <shikanai> At what point do you say "it's too obscure"?
23:34:09 <mle> at the point where you don't understand it without the bot
23:34:45 <shikanai> that sounds like a good rule of thumb
23:37:46 <ivanm> I generally don't use ones like (foo .) . bar
23:37:54 <ivanm> as I find the double dots too obscure
23:38:14 <ivanm> I think find1 OK though
23:38:51 <mle> find1 looks pretty good.
23:39:02 <canvon> double dots struck me hard when i first saw them (in this channel ;) ), but i think they're ok as long as one reads them as "bar eats up two outer arguments"
23:39:12 <canvon> yes, find1 here, too
23:39:15 <Tony[`]> A few months ago for work, we had a need for a specialized variant on memcached, and since it's such a light piece of code, I took a look at the original, and just started hacking. Came out pretty good, and pretty nicely performing for our task, not a lot of hours either.
23:39:25 <Tony[`]> I'm curious, how would you approach a functional language version of something like memcached? :)
23:39:33 <glguy> stacking up the (.)s like that is ok as long as you are only pasting your code in #haskell
23:39:39 <canvon> heh
23:40:15 * ivanm has no idea what memcached is...
23:40:24 <shikanai> invanm, mle, canvon, glguy: thank you!!  Now I don't feel like I need to master the double dots
23:40:35 <canvon> :)
23:40:54 <mle> Tony[`]: if you mean pure functional... there's a whole different set of problems, just in data structures.  Chris Okasaki has a book out "Purely Functional Data Structures" that shows some of what is involved.  Even things like a queue need to be thought about differently if you aren't going to allow mutation.
23:45:21 <shikanai> thanks again everybody--really appreciate your help!
23:52:28 <BMeph> Hmm, memcached looks like memoization. :)
23:53:18 <Tony[`]> BMeph: I've pesonally used it exactly that way, transparently, in some model classes
23:55:34 <BMeph> Tony[`]: But, yeah - as mle said, FP uses a different paradigm, especially with regards to mutable data.
23:56:12 <Tony[`]> BMeph: I completely understand, I was just talking about usage, not implementation just now
23:58:18 <BMeph> Tony[`]: So was I. :)
