00:25:01 <ivanm> hmmm... the scoreboard of ICFP contest teams is up, but it doesn't mention langs...
00:25:08 <ivanm> so which language "officially" won?
00:27:23 <sioraiocht> ivanm: it was a one man team, japanese guy
00:27:27 <sioraiocht> can't remember the name...
00:27:44 <DrTeggy> Matz?  Ruby?  ;-)
00:27:51 <ivanm> shinh ?
00:27:57 <ivanm> http://icfpcontest.org/scoreboard.php
00:31:01 <eevar2> ivanm: ocaml as usual? ;)
00:31:15 <ivanm> no idea...
00:31:49 <wmealing__> i might be reading things wrong, but is there an haskell client for amqp ?
00:32:21 <wmealing__> i found something on code.haskell
00:32:24 <wmealing__> but I'm not sure if its a full client.
00:32:35 <ivanm> no idea what amqp is...
00:32:47 <wmealing__> message queue.
00:33:19 * ivanm can't find anything on hackage that looks relevant...
00:33:24 <ivanm> so I guess not
00:33:26 <wmealing__> http://en.wikipedia.org/wiki/AMQP
00:33:36 * wmealing__ nods
00:46:43 <mmorrow> icfp winner used C++
00:46:58 <sioraiocht> mmorrow: that's right
00:47:00 <sioraiocht> was a sad day
00:47:00 <ray> ic++p
00:47:12 <sioraiocht> ivanm: yes, it was shinh
00:48:33 <mmorrow> is anyone is up for an "omfg", run nm on /usr/lib/libboost_whatever.a
00:48:36 <mmorrow> s/is/if/
00:49:09 <mmorrow> i don't even think the irc msg limit is enough to paste some of those in a single line
00:50:06 <mmorrow> i've gotta read about how that stuff works at some point
01:09:48 <ivanm> ray: heh
01:09:53 <ivanm> mmorrow: what's nm?
01:11:42 <mmorrow> rtfm!
01:11:44 <mmorrow> :)
01:11:53 <ray> it stands for nprint msymbols
01:11:55 <mmorrow> dumps symbols from object files
01:12:17 <ray> another clear, easy to understand uniax command name
01:12:41 <ivanm> ahhh, I was thinking of network manager
01:12:53 <ivanm> and was trying to work out what you were talking about...
01:13:09 <mmorrow> nm: /usr/bin/nm: no symbols :(
01:13:46 <ivanm> mmorrow: ls -l /usr/bin/nm
01:13:50 <ivanm> it's a symlink probably
01:13:56 <ivanm> hence no symbols?
01:13:58 <mmorrow> i think it's stripped
01:14:14 <ivanm> take it back, still no symbols
01:14:14 <mmorrow> file $(which nm)
01:14:32 <ivanm> ghc has no symbols either
01:14:47 * ivanm prefers backticks to $( )
01:14:57 <mmorrow> i don't even want to imagine how gimungous it'd be if it did
01:15:20 <mmorrow> ivanm: backticks are nice for sure, but only if you don't need to nest
01:15:25 <ivanm> true
01:19:51 <ski> mmorrow : `strings /usr/lib/libboost_*' shows some pretty long lines ..
01:21:22 <mmorrow> [m@monire ~]$ nm /usr/lib64/libboost_graph.a | cut -d' ' -f3 | perl -lne 'print length($_)' | sort -rnu | head -1
01:21:22 <mmorrow> 1736
01:21:23 <mmorrow> :o
01:24:29 <centrinia> Damn, _ZNK5boost6spirit7classic4i.........._S1P_E16do_parse_virtualERKS18_
01:24:44 <centrinia> Wait, mine is 1744.
01:24:58 <mmorrow> conspiracy!
01:25:19 <pozic> Is there a way to have Foo{..} syntax work, but not be able to use the constructor?
01:25:27 <centrinia> I got it from libboost_graph-mt.a
01:25:54 <centrinia> pozic, what do you mean?
01:25:58 <pozic> I only need to read from already constructed values.
01:26:15 <ivanm> pozic: don't export the constructor, but export the record functions?
01:26:56 <pozic> ivanm: I happen to believe that matching on a constructor is only possible if the constructor has been exported.
01:26:58 <centrinia> data Foo a = Foo { bar :: a, baz :: String}; bar :: Foo a -> a; baz :: Foo a -> String
01:27:23 <jpcooper> is there any reason for using "type" over "newtype"?
01:27:25 <pozic> centrinia: I have never seen you here before. It is pointless to try to answer this question, unless you have significant Haskell experience.
01:27:27 <ivanm> pozic: have you checked?
01:27:35 <ivanm> jpcooper: you don't want a newtype?
01:27:47 <pozic> ivanm: yes.
01:28:01 <ivanm> i.e. you're using the alias purely for documentation reasons, or to avoid using Foo -> Bar -> Baz all the time (when you can use FBB)
01:28:15 <ivanm> also, if you newtype then you can't use the default functions...
01:28:20 <jpcooper> ivanm, can you cut the shit?
01:28:26 <ivanm> jpcooper: what shit?
01:28:56 <ivanm> I was being serious
01:29:05 <jpcooper> so?
01:29:13 <jpcooper> it's still shit
01:29:13 <ivanm> so what?
01:29:20 <pozic> ivanm: I will just put a comment on it for users of the library.
01:29:22 <ivanm> what is shit?
01:29:34 <ivanm> pozic: that you shouldn't use the constructor?
01:29:47 <centrinia> Which library is it?
01:29:54 <pozic> ivanm: yes, so, people can use it to use record puns.
01:30:03 <ivanm> *nod*
01:30:43 <jpcooper> ivanm, right so it must be that your answer is the solution to my question, and I am an idiot for not being able to see this
01:30:54 <Baughn> PeakerWork: http://cdsmith.wordpress.com/2009/09/14/on-inverses-of-haskell-functions/ <-- I suspect you'll be interested
01:31:04 * ivanm has no idea wtf jpcooper is talking about or where he's going with this
01:31:22 <Saizan> jpcooper: have you seen the "i.e. you're using the alias purely for documentation reasons, or to avoid using Foo -> Bar -> Baz all the time (when you can use FBB)" line from ivanm?
01:31:31 <ivanm> people use type rather than newtype because they don't want to or can't use a newtype for one reason or another
01:31:41 <centrinia> pozic, do you simply want to be able to retrieve fields from a value without being able to construct a new value?
01:31:56 <Saizan> centrinia: no, he wants to use pattern matching
01:32:19 <Saizan> centrinia: because of syntactic convenience
01:32:20 <jpcooper> Saizan, yes I have seen this
01:32:28 <jpcooper> I don't know why the silly remark before was needed
01:33:04 <ivanm> 1) as a lead up
01:33:17 <ivanm> 2) summary
01:33:20 * jpcooper must first bring the seeker of help down to a suitable level and then bestow upon him his divine wisdom
01:33:24 <ivanm> 3) because people use type over newtype because they don't want to use newtype
01:33:44 <jpcooper> please explain 3)
01:33:49 <jpcooper> "they don't want to"
01:33:51 <Saizan> ivanm: it didn't add any content and could be misunderstood as rude, as it happened
01:34:06 <jpcooper> are you genuinely saying that that is a suitable answer and that I should be content with that?
01:34:16 <ivanm> jpcooper: if I'm writing a quick-and-dirty hack, I don't want a newtype
01:34:34 <ivanm> or if I'm using it as a temporary placeholder type until I sort out how I'm going to define my type
01:34:48 <jpcooper> and why would newtype make a difference?
01:34:49 <ivanm> (but I still want to use that in my type sigs)
01:35:10 <Saizan> jpcooper: because with newtype you have to use the new constructor introduced by it
01:35:14 <ivanm> if I have "newtype Money = M Double", I have to re-define addition, etc.
01:35:20 <jpcooper> I'm asking this clearly because of my ignorance of the difference (evidence being my asking of the question in the first place), so I can't take anything from "because he wants to"
01:35:34 <ivanm> but if I have "type Money = Double" (and I know users aren't going to be able to do anything wrong because I'm the only user), then I don't have to bother
01:35:39 <jpcooper> okay then thank you
01:35:50 <ivanm> jpcooper: some people just might have a philosophical objection to newtype :p
01:36:05 <ivanm> jpcooper: I'm sorry, but that's just the general way I answer such questions
01:36:07 <Saizan> jpcooper: from your question it wasn't clear that you didn't see any difference between them
01:36:22 <ivanm> quick overall summary kind of thing, then in more depth
01:36:38 <ivanm> also, your question sounded weird and I wasn't sure if you were a) serious, b) knew what you were talking about
01:36:41 <ivanm> (as Saizan said)
01:37:05 <Saizan> though your summary this time didn't have much content :)
01:37:25 <jpcooper> wasn't there some kind of saying going along the lines of assuming ignorance rather than malice?
01:37:51 <ivanm> jpcooper: I wasn't assuming malice
01:37:59 <ivanm> it just sounded like a weird question
01:38:16 <jpcooper> it seems that for every question I ask, I am acquainted with some kind of witticism on your side
01:39:12 <jpcooper> it's not important. I'll have to define my problems more
01:39:13 <ivanm> I think I"m funny :p
01:39:50 --- mode: irc.freenode.net set +o ChanServ
01:52:18 <c_wraith> Hmm.  I'm still thinking about permutation algorithms.  The properties that are desirable are lexicographic ordering (assuming the input is sorted), and efficiency.  I'm completely failing to get both of those at the same time.
01:52:54 <c_wraith> I also note that Data.List.sort doesn't bother with lexicographic ordering.
01:54:25 <Saizan> no?
01:54:39 <c_wraith> , Data.List.sort [1..3]
01:54:40 <lunabot>  [1,2,3]
01:54:43 <c_wraith> err
01:54:52 <c_wraith> , Data.List.permute [1..3]
01:54:53 <lunabot>  luna: Not in scope: `Data.List.permute'
01:54:59 <c_wraith> , Data.List.permutations [1..3]
01:55:00 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
01:55:20 <c_wraith> That's not lexicographic order
01:55:21 <Saizan> ah, you meant permutations, not sort in the first sentence, then
01:55:26 <c_wraith> yes, sorry
01:55:28 <c_wraith> it's late
01:55:35 <c_wraith> don't know why I'm thinking about this instead of sleeping
01:55:35 <c_wraith> :)
01:55:43 <Saizan> eheh :)
01:56:30 <|Steve|> , let f [] = [[]]; f xs = do x <- xs; rest <- f (delete x xs); return (x:xs) in f [1..3]
01:56:31 <lunabot>  [[1,1,2,3],[1,1,2,3],[2,1,2,3],[2,1,2,3],[3,1,2,3],[3,1,2,3]]
01:56:35 <ivanm> gah, I'm testing a sample Python program (solution for a project I'm helping to write) to crack Vigenere by using pre-done samples online... it doesn't help when those samples don't seem to actually be correct! :@
01:56:48 <|Steve|> erm, that isn't right at all.
01:56:54 <|Steve|> ah
01:56:58 <|Steve|> , let f [] = [[]]; f xs = do x <- xs; rest <- f (delete x xs); return (x:rest) in f [1..3]
01:57:00 <lunabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
01:57:13 <|Steve|> Lexicographic!
01:57:26 <c_wraith> Not efficient, though, I'm betting
01:57:36 <ziman> , let f [] = [[]]; f xs = do x <- xs; rest <- f (delete x xs); return (x:rest) in f [1,1,3]
01:57:37 <lunabot>  [[1,1,3],[1,3,1],[1,1,3],[1,3,1],[3,1,1],[3,1,1]]
01:57:52 <|Steve|> Efficient? There are n! of these. In what sense do you want efficiency?
01:57:59 <Saizan> you can avoid using delete by defining select :: [a] -> [(a,[a])]
01:58:06 <c_wraith> an algorithm that's not worse than O(n!) :)
01:58:10 <c_wraith> That algorithm is worse
01:59:01 <|Steve|> It's worse because of the delete?
01:59:09 <c_wraith> yes
01:59:34 <|Steve|> Then take Saizan's suggestion.
01:59:42 <c_wraith> same thing
01:59:46 <Saizan> select [] = []; select (x:xs) = (x,xs) : map (second (x:)) (select xs)
01:59:47 <|Steve|> No it isn't.
02:00:03 <c_wraith> it re-computes sub-values many times
02:00:07 <Saizan> not sure what the overall O() would be, even with selects
02:00:37 <Saizan> yeah, there's sharing that's not exploited
02:01:54 <|Steve|> At level i of the recursion, it's performing i permutations of a set of size i-1.
02:02:27 <c_wraith> how's that definition of select compare to "select [] = []; select (x:xs) (x,xs):[(y, x:ys) | (y, ys) <- select xs]"?
02:02:36 <c_wraith> err, inserting the appropriate missing =
02:03:31 <Saizan> c_wraith: i'd expect them to be almost the same, second is probably lazier though
02:03:47 <c_wraith> That's the definition I've been using in my testing.
02:04:24 <Saizan> ah, so you're not comparing the asymptotics, you're comparing actual running time
02:04:36 <c_wraith> that too
02:04:57 <c_wraith> And then looking at numbers, and closely examing what the algorithms are actually doing to explain them
02:05:25 <Saizan> i see, it'd be a nice blog post :)
02:05:50 <c_wraith> all my algorithms based on select are far worse than algorithms based on an interleave-style strategy, like Data.List.permutations uses.  (I've found a couple variants of them, too)
02:07:35 <c_wraith> I'm pretty sure that's due to sharing issues, and needing to re-do a ton of calculations
02:07:54 <sioraiocht> does anyone know of any effort to port haskell to android?
02:08:03 <sioraiocht> or if it's even possible?
02:08:33 <sohum> does anyone have experience using arbtt?
02:08:56 <ivanm> sohum: is that the new time tracker?
02:09:00 <sohum> ivanm: yep
02:09:12 <sohum> ivanm: well, I don't know how "new" it is
02:09:23 <ivanm> sohum: new as in yesterday IIRC ;-)
02:09:38 <ivanm> so I don't hink many people would have experience (apart from nomeata)...
02:09:47 * sohum checks date. so it is.
02:10:10 <sohum> fair enough
02:11:05 <c_wraith> "look at all those shared subproblems" makes me think of memoizing.  But that's just going to lead to an explosion in memory use.  Still temping to try, despite it. :)
02:12:04 <Peaker> c_wraith: Its basically "Dynamic programming" (worst name ever)
02:12:23 <sioraiocht> Peaker: yeah, because what exactly is "static" programming?
02:12:26 <c_wraith> well.  in a lazy language, memoizing and dynamic programming are *nearly* the same
02:12:37 <sohum> ivanm: does nomeata frequent #haskell?
02:12:42 <Peaker> c_wraith: in any language they are similar
02:12:49 <c_wraith> I mean, they're close anyway.  But even moreso when the language is lazy
02:12:52 <ivanm> preflex: seen nomeata
02:12:53 <preflex>  nomeata was last seen on #haskell 16 hours, 38 minutes and 53 seconds ago, saying: Orclev: Iâ€™ll be away in a moment, but I hope the rest of #haskell can help you :-)
02:13:03 <ivanm> sohum: usually AFAIK...
02:13:05 <sohum> Peaker, sioraiocht: the name is awful, but it has a lineage, from maths
02:13:09 <sohum> ivanm: thanks
02:14:24 <Peaker> sohum: what's that lineage?
02:14:47 <c_wraith> I seem to recall something about "dynamic" having to do with tables.
02:15:36 <sohum> "Originally the word "programming" in "dynamic programming" had no connection to computer programming, and instead came from the term "mathematical programming" - a synonym for optimization."
02:15:57 <sioraiocht> yes well, historical connections are evil
02:15:59 <|Steve|> For the record, my solution is O((2en+1)n!-n). That isn't tight.
02:16:06 <sioraiocht> just look at English orthography for an example
02:16:06 <sohum> "The term was originally used in the 1940s by Richard Bellman to describe the process of solving problems where one needs to find the best decisions one after another. By 1953, he had refined this to the modern meaning, which refers specifically to nesting smaller decision problems inside larger decisions,[1] and the field was thereafter recognized by the IEEE as a systems analysis and engineering topic. "
02:17:47 <Peaker> |Steve|: why are the constants in there? What's the difference between that and O(n!) ?
02:18:08 <c_wraith> that's O((n+1)!)
02:18:20 <|Steve|> It's O(n*n!).
02:18:31 <|Steve|> The constants are there simply because I know them.
02:18:38 <c_wraith> which, if you look at the specific definition of big-O notation, isn't the same
02:19:23 <ivanm> hmmm... how does O(n*n!) differ from O(n!) ?
02:19:40 <c_wraith> |Steve|, that matches my empirical testing, too.  It's kind of vexing.
02:19:56 <|Steve|> Oh whoops,
02:19:59 <|Steve|> I made a mistake.
02:20:05 <|Steve|> It's O(n!).
02:20:14 <c_wraith> ivanm: work from the definition of O() notation
02:20:33 <quicksilver> ivanm: there is no constant k such that k*n! > n*n! for sufficientlly large nn
02:20:37 <ivanm> yes, but is it the same as O(n!) ?
02:20:48 <quicksilver> ivanm: so, it's different.
02:20:50 <ivanm> that's what I was wondering
02:21:01 <ivanm> (bigger, presumably :p )
02:21:13 <c_wraith> yes.  the definition.  n > k eventually, no matter what you pick for k. :)
02:21:17 <|Steve|> Specifically, for f(0) = 1, f(n) = n(f(n-1) + n), you get f(n) = n! + 2en*Gamma(n,1) - n where Gamma(n,1) < (n-1)!.
02:21:23 <ivanm> I've just never heard of O(n*n!) as a bound before...
02:21:48 <c_wraith> It's a bound of many algorithm.  Just not tight. :)
02:21:56 <|Steve|> So really, you have f(n) in O(n! + 2en(n-1)! - n) = O(n!).
02:22:30 <c_wraith> But the reason you don't hear about that O(n*n!) is that it generally indicates an algorithm that's suboptimal
02:22:50 <|Steve|> And in fact, the lower bound is Omega(n!), so we have a tight bound of Theta(n!). Asymptotically, my algorithm is optimal.
02:22:51 <Peaker> c_wraith: O((n+1)!) is different from O(n!) ?
02:23:02 <|Steve|> Peaker: Yes, of course.
02:23:06 <quicksilver> Peaker: yes. We just explained that. :)
02:23:07 <c_wraith> Peaker:  it is.  For the same reason
02:23:15 <Peaker> I'll re-read then
02:23:26 <Peaker> quicksilver: ah, I see
02:23:28 <ivanm> c_wraith: extremely sub-optimal? :p
02:23:57 <|Steve|> ivanm: You should look at the field of "exact algorithms." The run times given are absurd.
02:23:57 <Peaker> quicksilver: I remembered O(n!) = O(n^n), but that may not be true either
02:24:02 <psykotic> funkyzeit mit haskell
02:24:16 <c_wraith> n! is O(n^n)
02:24:26 <c_wraith> But n^n is not O(n!)
02:24:32 <Baconizer> http://pastebin.com/d74905e8f <- Sorry, I'm probably being a bit dense, but what do I do to fix this? I'm compiling the Haskell Platform on OpenSUSE 11.1, i686, with the GHC from devel:/languages/haskell and nothing else installed.
02:24:41 <Peaker> |Steve|: The constants usually aren't there even when you know them, because tons of constants were already neglected in the primitive operations you summed up
02:25:27 <|Steve|> Peaker: The constants came from the exact solution to the recurrence relation I gave.
02:25:41 <bastl> Why does cabal compile the same module twice when it appears in a library and a executable section? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3604#a3604
02:25:53 <bastl> (and how can I turn it off?)
02:26:03 <psykotic> c_wraith: yeah, it's only when you pass to logarithms that the two O-classes become equal.
02:26:05 <|Steve|> As I already demonstrated, my algorithm has an optimal run time, asymptotically.
02:26:21 <c_wraith> bastl: because you might have specified different compile flags for each.
02:26:28 <psykotic> then both are n log n
02:26:34 <Baconizer> :(
02:26:35 <Peaker> |Steve|: Didn't say it didn't. Just that I've never seen anyone not neglect the constants in that notation
02:27:21 <|Steve|> Peaker: I was merely trying to explain where my (originally incorrect, but strange looking) run time came from.
02:27:47 <|Steve|> Well, not incorrect, but not tight, as I mentioned.
02:27:51 <ziman> well, number of steps coming from a formula and run time are different things...
02:28:23 <bastl> c_wraith: i dont think so: see excerpt from my cabal-file: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3604#a3605
02:28:45 <Saizan> bastl: c_wraith's explanation was general
02:29:07 <Saizan> bastl: cabal doesn't try to check if they are the same to compile them only once
02:29:27 <|Steve|> At any rate, the difference in measured wall-clock time is coming from those constants, no doubt.
02:29:35 <Saizan> bastl: however in Cabal-1.8, not released yet, you can make your executable depend on the library
02:29:40 <pozic> Baconizer: you install a binary release from haskell.org/ghc.
02:29:58 <pozic> Baconizer: Clearly, the packager was having a bad day when he/she packaged it.
02:30:07 <bastl> Saizan: ah, thats good, because its often the case the the executable and the library need the same modules ...
02:30:15 <Baconizer> pozic: okay :[
02:30:20 <bastl> so i have to stick to it for the time being, i guess ...
02:30:27 <pozic> Baconizer: unless there is a ghc-profiling package, too.
02:30:28 <Saizan> yeah
02:30:31 <bastl> tx
02:30:46 <pozic> Baconizer: contact the OpenSuse package maintainer, and complain there.
02:31:28 <pozic> Adding a monadic parameter to somewhere deep _really_ sucks.
02:33:07 <Baconizer> pozic: okay, thanks
02:36:29 <bastl> I try to strip down the dependencies in my package and find, that the library is built without any build-depends section. How comes?
02:43:55 <etpace> :t \x -> $ x
02:44:34 <etpace> , ($ 5) (+3)
02:44:35 <lunabot>  8
02:46:31 <Cale> :t \x -> ($ x)
02:46:43 <Cale> oh, did lambdabot go down?
02:46:52 <etpace> looks like it
02:47:12 <bastl> Is there a tool that finds superflous dependencies in a cabal file !?
02:47:21 <Cale> ah, dang url module
02:47:35 <Cale> I guess I can fix that much :)
02:48:20 <etpace> How does lambdabot run our statements? Is it quite advanced?
02:48:31 <Cale> It uses hint
02:48:55 <Cale> Well, more precisely, it awkwardly uses a program which uses hint, called mueval :P
02:49:14 <Cale> Though that does give some more isolation if things go wrong.
02:49:28 <Cale> hint is a pretty easy to use library though
02:49:37 <Cale> It's a sort of high-level interface to the GHC API.
02:49:47 <etpace> cool
02:50:04 <etpace> Are there any alternatives to ghci? As in, `pretty' alternatives?
02:50:24 <ivanm> there's winhugs/winghci IIRC
02:50:34 <Cale> mmm... I don't know. I remember someone made a GUI version with some buttons to push, but it didn't seem all that special.
02:50:36 <ivanm> and IIRC, there's a way of using hscolour in ghci
02:50:59 <Cale> @seen me
02:51:04 <lambdabot> me has changed nick to ficthe.
02:51:06 <ivanm> heh
02:51:06 <Cale> hmm
02:51:09 <lambdabot> Last time I saw ficthe was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #
02:51:10 <ivanm> @users
02:51:20 <lambdabot> Plugin `seen' failed with: thread killed
02:51:21 <Cale> That's... incorrect.
02:51:30 <lambdabot> Plugin `seen' failed with: thread killed
02:52:22 * Cale tries building lambdabot again
03:05:04 <Cale> @seen Cale
03:05:04 <lambdabot> Unknown command, try @list
03:05:06 <Cale> good.
03:05:19 <Cale> The URL module should also be disabled now.
03:05:28 <Cale> That's what caused the crash before.
03:06:15 <ivanm> http://downforeveryoneorjustme.com/code.haskell.org
03:06:24 <ivanm> looks like it is
03:06:46 <ivanm> Cale: congratulations, you've successfully reduced lambdabot's functionality! :s
03:06:49 <ivanm> ;-)
03:07:18 <Cale> ivanm: But increased its longevity.
03:07:26 <ivanm> s/its/her/
03:07:33 <ivanm> bots have feelings too you know!
03:07:34 <ivanm> :p
03:08:46 <lilac> @@ @vixen
03:08:46 <lambdabot>  where on a map is Panama?
03:08:53 <lilac> well, that's better than before
03:09:16 <Beelsebob> @vixen
03:09:16 <lambdabot> :)
03:09:25 * Cale imagines lambdabot as a sort of steel cube from which a tinny voice emanates.
03:09:29 <Beelsebob> @vixen are you feeling okay lambdabot?
03:09:29 <lambdabot> no, how dare you ask if i'm a bot!
03:09:39 <lilac> @@ @nixon
03:09:40 <lambdabot>  It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
03:10:55 <|Steve|> @beat bot
03:10:55 <lambdabot> Maybe you meant: keal let read what
03:10:58 <Saizan> Cale: oh, how did it made lambdabot crash?
03:13:33 <nlogax> how can i invite lambdabot to a channel? :)
03:16:34 <Cale> Saizan: I don't know, it tends to die with a message along the lines of "Failure in contextual handler" or something like that.
03:16:57 <Cale> Saizan: I think it may have something to do with the content of the URL which was found.
03:17:07 <Cale> But I have no idea.
03:17:15 <Cale> nlogax: You ask me.
03:17:57 <nlogax> Cale: may i have her hand in marriage? or invite her to #jquery-ot?
03:18:46 <Cale> lambdabot: @join #jquery-ot
03:19:00 <Cale> nlogax: Let me know if you want to make that permanent.
03:19:46 <nlogax> Cale: great, thanks!
03:22:48 <pozic> Why does this give an error even without the monomorphism restriction?  xx = X{x = return ()};xxx = return ();data X m = X{x ::  m ()};set_x _x x = _x{x = x};err = set_x xx xxx
03:23:25 <lilac> pozic: what's the error?
03:23:50 <pozic> I get an ambiguous type. Yes, I know it's ambiguous if I would want to execute it right away, but when I put in some concrete monad type into it later, it should all work out.
03:23:59 <lilac> pozic: ahh
03:24:11 <lilac> pozic: it's because record{..} can change the type of the record
03:24:41 <lilac> pozic: for instance, in your case,  \_x -> _x { x = [()] } is of type X m -> X []
03:24:50 <pozic> lilac: you mean can't?
03:24:56 <lilac> pozic: no, i mean it /can/.
03:25:03 <pozic> lilac: ok
03:25:13 <lilac> so it has no idea what type you're using 'xx' at
03:25:52 <lilac> in this specific case it doesn't matter, but you don't have to change the example much before it does
03:25:56 <pozic> lilac: ok, and if I want them to be the same?
03:26:14 <pozic> lilac: that is, I basically want a subtype relation.
03:26:25 <Saizan> you give a type annotation to set_x when you use it in err
03:26:32 <lilac> you can say 'set_x _x x = _x { x = x} `asTypeOf` _x
03:26:46 <pozic> lilac: ok, let's see whether that works. Thanks.
03:26:51 <lilac> but yeah, a type annotation is probably a better option
03:30:05 <Phyx-> test
03:31:46 <pozic> I find it an unexpected feature that record update can change the type. I would expect people to have to recreate a completely new record then. Of course this is probably how it works, but it's not what I would expect naively.
03:32:34 <pozic> lilac: yes, that was the issue. Thanks.
03:33:03 <quicksilver> I find that unexpected too
03:33:17 <quicksilver> I suspect it was originally an unintended consequence of the way it desugars.
03:35:27 <Phyx-> record updates can change the type? wasn't paying attention here, anyone got an example?
03:36:22 <quicksilver> data Bar a = Bar { f :: Maybe a }
03:36:49 <quicksilver> suppose b :: Bar Int, then b { f = Nothing } has type Bar a
03:37:29 <Phyx-> aaaahh like that
03:38:20 <lilac> i read a proposal that it be dropped for haskell' somewhere
03:38:45 <jethr0> lilac: what would?
03:39:00 <jethr0> sorry, just read the last messages ;)
03:39:05 <lilac> jethr0: type-molesting field update :)
03:39:50 <jethr0> yes, i find it annoying because when "Bar" changes from "Bar {oneField :: a, twoField :: a}" then it will break updates that change only the type of one of the fields
03:40:01 <jethr0> which is exactly what records were supposed to prevent/alleviate
03:40:08 <jethr0> s/from/to/
03:40:17 <quicksilver> I don't think that's true
03:40:24 <jethr0> huh?
03:40:26 <quicksilver> I think if there is another field that will hold the type steady
03:40:42 <lilac> quicksilver: jethr0's point is that /adding/ another field can make code which does field update invalid
03:40:52 <quicksilver> ah
03:40:55 <jethr0> how can in "Bar a = Bar {bOne :: a, bTwo :: a}" the record fields have different types?
03:41:07 <quicksilver> but only if that code was broken anyway :)
03:41:18 <quicksilver> but yes, that's certainly true.
03:41:28 <jethr0> quicksilver: why? if it is using type-changing record updates that's a question of the definition of "broken"
03:41:49 <quicksilver> "broken" if you later thought it was valid to add that field
03:41:54 <quicksilver> broken w.r.t. the new field
03:42:27 <jethr0> hmm, i've always seen records as allowing you exactly to rearrange/rename/delete/add fields
03:42:36 <quicksilver> I agree.
03:42:46 <quicksilver> but by adding a new field which ties the type to a given a
03:42:52 <jethr0> as opposed to "Bar a = Bar a a" where you're pretty much locked into the number/order of args
03:42:58 <quicksilver> you are certainly breaking any previous code which deliberately changed teh type
03:42:59 <jethr0> yes, i agree
03:43:16 <quicksilver> so it's not really an unexpected breakage, as such
03:43:21 <quicksilver> although it could certainly be confusing.
03:43:36 <quicksilver> but the type checker is correct to alert you that you need to think again about that part of the code.
03:43:37 <jethr0> which is why my argument is that changing type transparently with records is a bit brittle in face of future changes to the types
03:43:46 <jethr0> quicksilver: i find it unexpected
03:44:02 <jethr0> the record could be in a library or sth
03:44:10 * quicksilver nods
03:44:17 <lilac> if you have: data Foo = Foo { bar :: Int }, and export only 'bar' (and not the 'Foo' constructor), can you still do record updates?
03:44:26 <quicksilver> I don't think so.
03:44:27 * lilac tries
03:44:34 * jethr0 wouldn't think so
03:44:39 <ivanm> someone was asking that before
03:44:45 <ivanm> and said they tried it and it didn't work
03:45:10 <pozic> lilac: no
03:45:21 <lilac> ghci allows it
03:45:24 <jethr0> isn't "b{oneField = 1}" maybe syntactic sugar for "Bar{oneField = 1, twoField = twoField b}"?
03:45:36 <jethr0> really? i'm amazed
03:45:36 <ivanm> lilac: because when you load a module in ghci, you're also using its internals
03:45:41 <lilac> ivanm: right
03:46:28 <amitprakash> hi.. whats wrong here? http://pastebin.ca/1565316
03:46:41 <lilac> ghci allows it even through an import
03:47:11 <lilac> and further ghc allows it
03:47:41 <Phyx-> amitprakash: what error are you getting?
03:48:00 <amitprakash> Phyx-, undefined symbol :
03:48:51 <lilac> like so: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9370
03:49:05 * lilac got the 'author' and 'title' fields backwards again :(
03:49:25 <Phyx-> amitprakash: in extract i presume? you need to ad () around the pattern match. ((Line p1 p2):xs))
03:49:26 <pozic> lilac: oh, right. I tried something slightly different, involving record puns.
03:49:30 <ivanm> lilac: that works?
03:49:33 <ivanm> :o
03:49:40 <lilac> ivanm: in 6.10.3, yep
03:49:55 <bastl> how can i quickly find out in what package a modue lives?
03:50:02 <bastl> *module
03:50:04 <Phyx-> amitprakash: also you're using the Types in the pattern matching, it should be variables there, which would be populated with the appropiate values if the match on the constructor succeeds
03:50:13 <amitprakash> hmm ok
03:50:32 <Phyx-> amitprakash: also sListAux doesn't seem to be type correct. [ map extract l]  would have the type [[Object]] not [Object]
03:50:52 <int-e> [[[Object]]] actually
03:50:56 <Phyx-> well, actually, it would have the type [[[Object]]]
03:51:10 <Phyx-> lol, int-e beat me to it :P
03:51:13 <bastl> @h Data.List
03:51:14 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
03:51:18 <bastl> hmm
03:51:28 <bastl> @hoogle Data.List
03:51:29 <lambdabot> module Data.List
03:51:29 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
03:51:29 <lambdabot> Data.Generics.Schemes listify :: Typeable r => (r -> Bool) -> GenericQ [r]
03:51:35 <int-e> @type concat
03:51:36 <lambdabot> forall a. [[a]] -> [a]
03:51:38 <int-e> @type concatMap
03:51:39 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
03:52:35 <Phyx-> amitprakash: also, in extract, you're using (++) there, but that wouldn't work, since (++) is type [a] -> [a] -> [a]
03:52:43 <centrinia> @type concatMap id
03:52:44 <lambdabot> forall b. [[b]] -> [b]
03:53:00 <Phyx-> amitprakash: and you're adding a single element to a list, so you need (:) instead
03:53:01 <amitprakash> Phyx-, nm.. i am redoing it from scratch now.. too many mistakes it seems
03:53:35 <Phyx-> amitprakash: sure, but you should know what they are in order to avoid them :)
03:53:52 <amitprakash> yes :) thanks a lot for the suggestions
03:55:00 <Saizan> if i had f mempty = mempty; f (a `mappend` b) = f a `mappend` f b i'd say f is a monoid isomorphism, is there a name for g mempty = mempty; g (a `mappend` b) = g b `mappend` g a ? (e.g. g = reverse)
03:55:20 <Saizan> s/iso/homo/
03:56:29 <Saizan> oh
03:56:44 <Saizan> it's just an homomorphism into the dual monoid, isn't it?
03:56:45 <lilac> @hitchcock
03:57:58 <lilac> Saizan: f is a monoid homomorphism not a monoid isomorphism, unless it's invertable, no?
03:59:03 <|Steve|> Indeed.
03:59:27 <amitprakash> Phyx-, thanks.. http://pastebin.ca/1565321 works now :)
04:00:31 <Phyx-> amitprakash: cool, np
04:02:39 <amitprakash> Phyx-, well the code is syntactically okay but logically flawed :D
04:02:55 <Phyx-> amitprakash: i didn't look at the logic :P
04:03:16 <amitprakash> why would simpleObj Figure [ Line (3,2) (3,6), Rect (0,0) (3,4), CompObject [ Line (0,0) (2,2), CompObject []]] be wrong?
04:03:33 <Saizan> lilac: yeah, see my s/iso/homo/
04:03:43 * Saizan suspects he's quite lagged
04:03:45 <lilac> Saizan: yeah, i saw that just a bit too late :)
04:04:23 <Phyx-> amitprakash: what error?
04:05:20 <Saizan> amitprakash: you need parentheses around "Figure ..." i guess
04:05:22 <centrinia> amitprakash, Put parentheses around the entire Figure value.
04:05:34 <Phyx-> oh, right
04:05:42 <Phyx-> or add a $ after simpleObject
04:05:55 <Phyx-> i completely missed that you passed it to a function
04:06:12 <centrinia> Or add a `id` after simpleObj ;)
04:06:39 <bastl> what is the suggested way to deal with compiler options in cabalized packages? I have a pragma -fglasgow-exts in my code, but i know that i can put such things into cabal. what is better? (and why?)
04:06:50 <Guest16568> Phyx-, what does adding a $ do?
04:07:01 <centrinia> :t ($)
04:07:02 <lambdabot> forall a b. (a -> b) -> a -> b
04:07:16 <Saizan> bastl: you should actually use the LANGUAGE pragma rather than -fglasgow-exts
04:07:44 <Guest16568> ah ok
04:08:10 <Phyx-> Guest16568: changed the evaluation order, forces the values on the right side to be computer before being passed to what every on the left sidd
04:08:10 <Saizan> $ is just function application, but with low precendence
04:08:24 <bastl> Saizan: ok, i have to strip thatone donw to the requiredparts in a compiler-independent way too. i see. but is pragma better than a cabal-setting?
04:08:27 <Saizan> Phyx-: no, it does nothing to the evaluation order
04:08:36 <centrinia> `id` is just function application, among other things.
04:08:59 <Saizan> Phyx-: in practice it only affects the parsing of the expression
04:09:04 <Phyx-> Saizan: no, but it's a rather simple way of explaining
04:09:12 <amitprakash> ah ok
04:09:25 <Phyx-> it effects the parsing? I thought it was a runtime thing, e.g. just another function
04:09:28 <Saizan> it's a quite wrong way to explain it, the issue is only one of syntax
04:09:49 <ski> it changes precedence
04:09:54 <quicksilver> it is just another function, but as a function it does nothign at all
04:09:59 <quicksilver> (and in fact it gets compiled out)
04:10:09 <quicksilver> the practical difference is makes is syntactical.
04:10:14 <centrinia> It is the identity function on functions.
04:10:28 <quicksilver> a b $ c d is (a b) (c d), whilst a b c d is (((a b) c) d)
04:10:37 <lilac> @type (4 `id`)
04:10:37 <lambdabot> forall t. (Num t) => t
04:10:51 <centrinia> @type (id `id`)
04:10:52 <lambdabot> forall a. a -> a
04:10:57 <Phyx-> quicksilver: well, i know what it does, I just never knew it only effected the parser
04:11:25 <Phyx-> live an learn i suppose, thanks Saizan
04:11:33 <quicksilver> well it's a funny way to say it
04:11:34 <ski> every operator effects the parser
04:11:40 <quicksilver> it doesn't "affect" the parser in any special way
04:11:45 <quicksilver> it's parsed like all other operators.
04:11:55 <centrinia> It is not magic.
04:11:59 <quicksilver> quite
04:12:01 <lilac> unary operators in slices is a ghc extension, right?
04:12:15 <ski> (s/slices/sections/ ?)
04:12:26 <lilac> ski: yeah, too much python ;-)
04:12:26 <amitprakash> Phyx-, w00t it works
04:12:27 <quicksilver> it has a very low precedence, while function application has higher precedence than any binary op
04:12:37 <Phyx-> ski: well, yes, the fixity and precedence effect the parser, you're right.
04:12:49 <ski> > let (!) = not in (True !)
04:12:49 <ski> False :: Bool
04:12:50 <lambdabot>   False
04:12:53 <ski> ^ hugs
04:12:54 <Phyx-> Meh, it's early and i Haven't had breakfast.. can we chalk this one up to morning sleepness? :P
04:13:21 <centrinia> Why are fixity values not arbitrary rational numbers in [1,11]?
04:13:39 <lilac> centrinia: in haskell'98 they're formulated as parsing rules iirc
04:13:41 <quicksilver> technically an extension nonetheless, ski
04:13:44 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
04:15:54 <ski> (imo, precedences should be a dense ordering (not necessarily total), with no direct mapping to or from integers or rationals)
04:17:29 <lilac> what does it mean for an ordering to be dense?
04:17:51 <quicksilver> there is always a new point between two old points
04:17:59 <centrinia> That's not an ordering.
04:18:17 <quicksilver> what's not?
04:18:39 <quicksilver> it might be nice if you just specified the constraints and it constructed a partial order for you.
04:18:54 <lilac> quicksilver: i was about to suggest something similar :)
04:20:07 <lilac> the downside is that you'd need to specify "($) is higher than (<^^>) is higher than (.)" for all operators <^^> you invent
04:20:45 <ski> lilac : the binary relation `R' is dense iff `forall a c. a R c => exists b. a R b /\ b R c'
04:26:31 <centrinia> Hmm, the less or equal to relation is dense.
04:26:39 <ski> yes
04:26:52 <ski> it's mostly used for strict orderings, i suppose
04:27:27 <ski> (irreflexive,assymetric,transitive)
04:27:38 <quicksilver> less than or equal to is trivially dense so that's not how you'd understand it ;)
04:27:44 <quicksilver> you'd choose to apply it to the strict version.
04:28:08 <quicksilver> lilac: yes, it woul dbe fiddly to design something useful.
04:28:21 <quicksilver> lilac: you'd have to permit wildcards " ($) is lower than everything "
04:28:30 <quicksilver> lilac: and that removes some of the elegance :(
04:28:54 <ski> quicksilver : groups would be better, imo
04:29:12 <ski> `$' is weaker than everything in this named group
04:29:13 <davidbe> When using cabal and defining data-files, it seems it's necessary to run "runhaskell Setup install" to acces them via getDataFileName. I think it's rather an "unclean" thing to install it on your system while you're still developping. Or am I wrong? Are there solutions? Workarounds?
04:30:08 <ivanm> davidbe: well, that way you're testing that it builds as you go... :p
04:31:03 <davidbe> ivanm: right, though it seems runhaskell Setup clean doesn't remove the files in ~/.cabal/
04:31:14 <davidbe> that way, files will remain there...
04:31:27 <ivanm> ummmm, it shouldn't
04:31:35 <lilac> davidbe: you might be able to get it working with 'cabal register --inplace'
04:31:45 <ivanm> clean cleans up build files
04:31:49 <davidbe> ivanm: ok, I'll check that out
04:31:50 <ivanm> ~/.cabal has installed files
04:32:06 <ivanm> per-user installed files, that is
04:34:07 <davidbe> ivanm: ok, I like the idea that compiled stuff is put in dist/ directory, but I don't like them leaving the dev-directory :)
04:34:23 <Saizan> davidbe: there's --in-place iirc
04:34:48 <amitprakash> does listof exist in haskell? if not.. how do i make a list from output of map f e
04:35:08 <lilac> amitprakash: the result of map f e /is/ a list. what do you mean by listof?
04:35:17 <Saizan> davidbe: it's actually --inplace
04:35:18 <ivanm> davidbe: ummm, what leaves the dev directory?
04:35:26 <amitprakash> lilac, ah ok.. i thought it wasnt  list... nm
04:35:30 <ivanm> stuff goes in ~/.cabal only if you do runhaskell Setup install
04:35:50 <Saizan> ivanm: he _is_ using install
04:35:55 <lilac> davidbe: i'm going to suggest 'cabal register --inplace' again on the off-chance you didn't see it last time :)
04:35:55 <davidbe> Saizan & ivanm : it seems --inplace is what I was looking for
04:35:59 <maltem> Is there a ghc 6.12 RC to come out today?
04:36:02 <lilac> :)
04:36:21 <ivanm> Saizan: ahhhh
04:36:23 <ivanm> my mistake
04:36:41 <ivanm> I thought he was just using build :s
04:36:42 <davidbe> lilac: thanks, as a newbie to Haskell & cabal, things might get overwhelming *information overload* :)
04:36:46 <funcA> sup haskellians
04:37:01 <lilac> davidbe: no problem ;-)
04:38:19 <funcA> reverse xs == xs where xs = "word"
04:38:27 <funcA> my teacher is doing something wrong there
04:38:31 <funcA> doesn't make sense
04:38:53 <SamB> > reverse xs == xs where xs = "word"
04:38:54 <lambdabot>   <no location info>: parse error on input `where'
04:39:05 <lilac> funcA: right, it doesn't. 'where' applies to a function definition, reverse xs == xs is an expression
04:39:13 <Saizan> > let b = reverse xs == xs where xs = "word" in b
04:39:14 <lambdabot>   False
04:39:35 <maltem> funcA, to be honest, that looks like a code fragment rippen out of all context
04:39:42 <SamB> yeah
04:39:55 <funcA> I thought that as well
04:40:04 <Saizan> the where is part of the b = declaration there
04:40:06 <funcA> but that's what he placed in the question
04:40:24 <lilac> funcA: can you show us the context?
04:40:28 <SamB> is this a teacher who hates being wrong ?
04:40:29 <arw_> perhaps a late night copy&paste error...
04:40:31 <Saizan> maybe it's an english where, rather than an haskell one :)
04:40:35 <amitprakash> umm why is http://pastebin.ca/1565358 wrong now.. it mentions  Type  checkcredit : Name -> Credits -> [[Char]]
04:40:35 <amitprakash> and not Name->Credits->Task when Task = [[Char]]
04:41:06 <Saizan> amitprakash: Task = [Char] not [[Char]]
04:41:09 <funcA> lilac: it's from a sheet that has exercises/questions on Haskell expressions and such
04:41:09 <lilac> > let xs = "word" in reverse xs == xs
04:41:10 <lambdabot>   False
04:41:13 <maltem> funcA: maybe the "where" is to be taken as English?
04:41:20 <amitprakash> Saizan, ah yes
04:41:44 <funcA> question = "Which is the value of the following expressions? And their type?"
04:41:49 <Botje> amitprakash: [Char] is commonly called String
04:42:01 <amitprakash> Botje, yes i misread
04:42:03 <funcA> the second expression is the one I provided to you, and I was ?_?
04:42:19 <Botje> might make your types more readable :)
04:42:21 <lilac> funcA: does the question use a different typeface for code? or is it possible the 'where' is just english rather than code?
04:42:45 <funcA> lilac: everything is written in portuguese, with the exception of Haskell things :P
04:43:10 <lilac> funcA: in that case i'd guess your teacher slipped up :)
04:43:44 <funcA> lilac: he drinks a lot :X
04:43:59 <lilac> depending on the teacher, i'd either answer the question he meant, or explain that it's invalid, give the valid version and answer the question for that version :)
04:44:13 <maltem> funcA, I'd just pretend the teacher wrote "where" where they meant the portuguese equivalent of "where". You know, copy'n'paste from old exercise sheets :)
04:45:13 <funcA> he also has this one:
04:45:16 <maltem> Towards many teachers, "explain that it's invalid" isn't an option
04:45:25 <lilac> it's possible this question has been adapted from one which said: given "f1 = ..; f2 = reverse xs == xs where xs = "word"; f3 = ...", what are the types and values of f1, f2, f3?
04:46:04 <funcA> zip xs ys where {xs = tail [0,1,2,3]; ys = init ['a','b','c','d']}
04:46:27 <funcA> lilac: nope
04:46:37 <funcA> I will provide you the pdf if you want to.
04:47:07 <lilac> funcA: i meant, the question may have been in that form in previous years, and been cut-and-pasted into the current form
04:47:49 <lilac> that is, it might be accident rather than misunderstanding on the part of the person setting the question
04:47:56 <funcA> I see
04:48:15 <funcA> it's possible
04:48:28 <funcA> It's the first that he's giving this class
04:49:22 <lilac> hmm. well, i'd be concerned about other people in your class incorrectly thinking that "where" is part of expression syntax like "let", so i'd talk to the teacher about it (unless you think he won't take kindly to that)
04:51:13 <funcA> lilac: I'll talk to him tomorrow I think
04:51:21 <funcA> first day of the class :)
04:51:52 <funcA> thanks for the assistance, haskellian gurus
04:52:27 <amitprakash> umm can someone help with this?
04:52:28 <amitprakash> http://pastebin.ca/1565364
04:57:30 <Saizan> > filter (not . null) ["Direction","Cast",""]
04:57:31 <lambdabot>   ["Direction","Cast"]
04:57:39 <Saizan> amitprakash: ^^
04:57:48 <amitprakash> thanks
05:01:42 <bastl> hmm. my project compiles fine, but haddock --executables stops with an error: "The last statement in a 'do' construct must be an expression". There is an empty line in the do block, but ghc compiles it just fine !?
05:03:54 <Saizan> bastl: which version of haddock?
05:04:08 <bastl> 2.4.2
05:04:44 <Saizan> and is it the one that comes with that ghc?
05:05:05 <bastl> ehm, dunno.
05:05:14 <bastl> its ghc 6.10.3
05:06:41 <Saizan> could the parsing at that point be affected by language pragmas or CPP?
05:06:48 <Philippa_> yeah, and from memory it's legit per the Report too. Sounds worth reporting to the maintainer
05:07:23 <Saizan> haddock uses the ghc-api to parse though
05:07:34 <kuribas> I want to use gstreamer to create a video editing application, but I cannot find the function to set the xwindow id of the xvideo to the gtk window...
05:08:06 <bastl> Saizan: hmm. i dont use such pragmas only DeriveDataTypeable and Rank2Types
05:09:00 <bastl> it seems i installed haddock via cabal
05:10:34 <Saizan> if cabal is managing to pass the same options to both haddock and ghc then it's something to report as an haddock bug
05:15:09 <eevar2> hmm.. is cabal supposed to die because of the -N4 flag in my GHCRTS?
05:15:29 <eevar2> or return with an inappropriate error code, anyway
05:16:24 <dcoutts> eevar2: it should not affect it, it doesn't really use threads
05:20:41 <akiel> hi
05:20:52 <Axman6> how handy. this just came up on reddit today, and it's exactly what we're studying
05:20:55 <Axman6> http://swtch.com/~rsc/regexp/regexp1.html?
05:22:57 <akiel> I have an encoding issue with Network.HTTP - my result XML document which comes as UTF-8 from the server is packed into a string not honoring the encoding - so that I get every UTF-8 byte as one char instead of converting multiple bytes into one char - can someone help me?
05:23:08 <ivanm> Axman6: I think that's old...
05:23:19 <Axman6> wouldn't surprise me
05:23:52 <ivanm> yup, Jan 07
05:28:03 <Saizan> akiel: you can use the utf8-string to decode it
05:28:15 <Saizan> akiel: utf8-string package, i mean
05:28:49 <akiel> Saizan: yes I know this but I don't like to have the UTF-8 bytes in the string in first place
05:29:14 <akiel> I like to understand why they are wrongly in the string
05:30:19 <Saizan> that's because not the IO layer not HTTP try to decode it, i think
05:30:28 <Saizan> s/not/nor/g
05:31:05 <Saizan> you could get your response in a ByteString from HTTP though
05:31:12 <akiel> hmm I try to find more documentation about Network.HTTP - is there anything more than that on HackageDB?
05:31:50 <akiel> you think that the HTTP lib doesn't look into the char-encoding HTTP header?
05:32:40 <Saizan> i'd think that, yes
05:33:46 <akiel> that would be bad because a String is a String and should not contain some byte noise
05:34:33 <Lemmih> akiel: String doubles as an inefficient ByteString.
05:34:56 <Saizan> the String interface is probably a legacy
05:35:34 <Saizan> however, i might be wrong
05:35:38 * ketil reads LWN: There must be a crowd of people out there thinking that they would get into kernel development, but only if they could do it in Haskell.
05:35:49 <ketil> http://lwn.net/
05:35:57 <akiel> hmm in Java a String contains Characters and a Character is considered much different as a byte
05:36:55 <Botje> yes. one of the few things java gets right
05:36:58 <Saizan> akiel: yeah, that's how you should think of Char in haskell too
05:37:06 <Botje> although their UTF8 implementation is nonstandard, iirc.
05:37:38 <Saizan> akiel: but some libraries, e.g. System.IO, don't get this right yet
05:38:20 <amitprakash> umm map f [list] = [f x] where xE[list] ... however if i want map f [list] y = [f x y] where xElist then how do i do this?
05:38:48 <akiel> Saizan: I can't believe hat now in 2009 using just a Haskell lib (the flickr API) returns me wrong encoded strings - its a pitty
05:39:15 <Lemmih> amitprakash: map (\x -> f x y) list
05:39:45 <akiel> all what I try to do is getting data out of the flickr API with the Haskell flickr package and the first not ascii user name I hit has encoding issues
05:40:16 <Lemmih> akiel: Use utf8-string and write a bug report?
05:40:20 <amitprakash> Lemmih, umm where x is?
05:41:01 <Lemmih> amitprakash: x E list.
05:41:43 <Lemmih> amitprakash: Another way to write it would be: [ f x y | x <- list ]
05:41:48 <amitprakash> Lemmih, so map getCredits (nub (names f)) f becomes map \x->getCredits x f nub(names f) ?
05:42:52 <Lemmih> amitprakash: Do you want 'f' to be the second argument to 'getCredits'?
05:42:58 <amitprakash> yes
05:43:15 <Lemmih> amitprakash: If so: map (\x -> getCredits x f) (nub (names f))
05:43:31 <Lemmih> amitprakash: Or: [ getCredits x f | x <- nub (names f) ]
05:43:43 <amitprakash> ah ok
05:44:13 <akiel> Lemmih: yes that would properly the best to do
06:01:04 <dancor> isn't it weird that showing UTCTime has 6 digits after . in the seconds, but if there are zeroes then it truncates?
06:01:23 <quicksilver> dancor: yes, it is weird.
06:01:34 <quicksilver> although postgres has the same strange behaviour too, I have noticed.
06:01:36 <dancor> so you can have a list of times ["2009-09-14 12:57:18.0027 UTC", "2009-09-14 12:57:23.761974 UTC"].  ya.
06:01:38 <quicksilver> it seems to be a common oddity.
06:01:40 <amitprakash> how do i invoke nub is haskell?
06:01:46 <amitprakash> s/is/in
06:02:01 <dancor> > nub "i don't understand"
06:02:02 <lambdabot>   "i don'tuersa"
06:02:45 <dancor> amitprakash: import Data.List
06:03:02 <dancor> amitprakash: http://haskell.org/hoogle/?q=nub
06:16:28 <eevar2> dcoutts: cabal bugging out because of -Nx: http://pastebin.org/17829
06:18:07 <quicksilver> looks like that copy of cabal was not ciompiled with -threaded?
06:18:14 <dcoutts> eevar2: oooh, so you can't use the -N flag with programs that do not use the threaded rts
06:18:15 <dcoutts> that's all
06:18:37 <dcoutts> eevar2: so not a good idea to put -N into a general env var
06:18:41 <Saizan> it's ghc-pkg that doesn't look compiled with -threaded
06:19:06 <eevar2> that's fairly inconvenient. when i asked about compiling -Nx into my app, the response i got here was to use an env var instead
06:19:06 <dcoutts> it probably isn't either
06:19:24 <dcoutts> eevar2: bug the ghc people about it
06:19:51 <dcoutts> eevar2: you can make a shell script wrapper for a program that sets the env var for just that program
06:19:52 <quicksilver> eevar2: that was the wrong response.
06:20:05 <quicksilver> eevar2: there is a supported, documented way to compile -Nx into your app
06:20:09 <napsy> Hello. http://codepad.org/t2vWxgAh  ... What am I doing wrong?
06:20:53 <quicksilver> http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/runtime-control.html#rts-hooks
06:20:53 <Lemmih> napsy: main = do ...
06:20:55 <Botje> napsy: you need a do
06:21:23 <napsy> oh thanks ot works now
06:21:28 <napsy> *it
06:22:03 <Cale> also, it might be nicer if you indent the if/then/else with the 'then' and 'else' aligned, and indented more than the 'if'
06:22:12 <Cale> http://codepad.org/6cYx1VpG -- like this
06:22:22 <eevar2> quicksilver: will aim for that, yes
06:23:03 <napsy> Cale: ok I'll do that
06:23:58 <amitprakash> hi.. i have a [( string, [string])] ... i want to get a list [ (String, [ String])] where length[String]>1.. how do i do this?
06:24:28 <dibblego> you mean you want to filter?
06:24:35 <amitprakash> dibblego, yes
06:24:42 <quicksilver> filter (\(a,b) -> length b > 1) list
06:24:48 <dibblego> there is a filter method on List
06:24:54 <dibblego> oh shit, wrong language
06:25:15 <Lemmih> amitprakash: Or: [ (k,v) | (k,v) <- list, length v > 1 ]
06:25:32 <amitprakash> Lemmih, quicksilver , dibblego reading up on filter
06:25:37 <dibblego> @type filter
06:25:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:25:58 <dibblego> > filter (\t -> length t > 1) ["abc", "", "a"]
06:25:59 <lambdabot>   ["abc"]
06:26:35 <Saizan> length xs > 1 is best written not (null xs), btw
06:26:51 <Saizan> because length has to traverse the whole list
06:27:01 <Lemmih> Saizan: It really isn't.
06:27:06 <dibblego> almost
06:27:09 <Saizan> oh
06:27:24 <Saizan> not (null (tail xs))
06:28:06 <quicksilver> which errors on empty strins
06:28:08 <quicksilver> so you need
06:28:08 <dibblego> \t -> not (null t) && not (null (tail t))
06:28:17 <quicksilver> not (null xs || null (tail xs))
06:28:25 <Saizan> or drop 1
06:28:28 <quicksilver> which is probably not worth the pain
06:30:34 <alc> :w
06:32:58 <dancor> everyone knows that fewer characters is how you decide what's best, so that comments aren't allowed and you have to radically change your over-@pl-ed program for the smallest refactorings ;)
06:35:33 <Pygma> What base is the log function in haskell?
06:35:54 <Cale> natural, of course ;)
06:36:06 <Cale> > exp 1
06:36:06 <lambdabot>   2.718281828459045
06:36:10 <Cale> > log (exp 1)
06:36:11 <lambdabot>   1.0
06:37:16 <Taejo> anybody ever notice that people ask what the base of "log" functions are, but never "exp"?
06:37:37 <burp> > log $ exp 1 :: CReal
06:37:38 <lambdabot>   1.0
06:37:43 <burp> uh, it terminates
06:38:02 <burp> oh, of course
06:38:20 <Cale> It's only approximating to n digits where n is some fixed number defined in the show instance.
06:38:23 <burp> > showCReal 100 $ log $ exp 1 :: CReal
06:38:24 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
06:38:30 <burp> yes, I remember that now ;-)
06:38:41 <burp> um yes..
06:38:43 <Cale> > showCReal 100 (log . exp $ 1)
06:38:44 <lambdabot>   "1.0"
06:40:46 <Saizan> (however i have a gut reaction everytime i see "length xs > n" since when that meant an unresponsive happs-server)
06:40:47 <Axman6> Taejo: why would they? exp is bascialy understood to be e^. but logs can have practically any base
06:42:14 <Taejo> Axman6: but that's what I'm saying: exponentials can have any base too, they're precisely dual to each other, but one is "understood" and the other is not
06:43:53 <pozic> Taejo: isn't exp _the_ exponential function?
06:44:25 <quicksilver> Taejo: exp means e^
06:44:29 <Taejo> pozic: isn't log _the_ logarithm function?
06:44:33 <quicksilver> Taejo: no
06:44:33 <pozic> Taejo: no.
06:44:40 <quicksilver> Taejo: ln is *the* logarithm function
06:44:40 <Taejo> why not?
06:44:42 <quicksilver> log is generic
06:44:48 <quicksilver> because that's what the words happen to mean.
06:45:04 <quicksilver> ln = natural logarithm, e^ = exp
06:45:20 <pozic> Taejo: do you know why ln is called natural?
06:45:30 <quicksilver> just because computers/early programming languages couldn't have a function called e^ I imagine
06:46:21 <Taejo> pozic: well I believe that it was called natural before calculus was discovered, but once you have calculus it's pretty clear that e is the "right" base for logs and exponentials
06:46:30 <anonym> log is generic, true, but log to the base e is mostly implicite, so it is kinda special ;)
06:46:30 <Pygma> Ah ty Cale, and Taejo, haven't used exp yet :P
06:47:24 <Cale> quicksilver: I hate that ln notation
06:47:28 <Cale> log is the natural log.
06:47:49 <quicksilver> Cale: sure, the notation isn't great, but I was attempting to describe acepted notation, not give an opinion on what is good :)
06:48:05 <burp> I don't like ln either
06:48:17 <Cale> As far as most mathematicians are concerned, log is more popular for the natural log.
06:48:18 * maltem does like ln. Bah!
06:48:42 <Cale> But engineers seem to like ln quite often. Physicists, I'm not sure.
06:48:51 <quicksilver> Cale: right, but this is about computer notation
06:49:01 <koeien> parser combinators rule
06:49:02 <quicksilver> Cale: mathematicians don't generally use 'exp' either
06:49:09 <quicksilver> they use e{superscript}
06:49:13 <maltem> It's not natural to express the "right" base by omitting the base from the notation. Rather, it suggests that an arbitrary base is meant.
06:49:17 <anonym> Cale: which is kinda incomprehensible as mathematicians are lazy and you can save one character writing ln down!
06:49:21 * merus uses exp a lot, and is a mathematician.
06:49:32 <koeien> quicksilver: that depends
06:49:34 <quicksilver> merus: it has become more common recently for some rason
06:49:38 <quicksilver> stops stacks getting too high
06:49:40 <quicksilver> etc.
06:49:42 <merus> quicksilver, because it's more legible
06:49:59 <quicksilver> traditionally e{supercsript} was the mathematics way and I"m fairly sure exp() was re-imported from computing
06:50:19 <Cale> I use exp when the important thing is that it's an inverse to log, or when I want it to be thought of as a power series.
06:50:48 <maltem> Also, e^{} is quite inconvenient when you don't supply an argument.
06:51:03 <Cale> I use e^(...) for polar notation with complex numbers though.
06:51:10 <koeien> maltem: in analysis, they don't care :)
06:51:13 <burp> and sometimes you need space, and don't want to write superscript
06:52:12 <amitprakash> Lemmih, loving haskell =)
06:52:16 <maltem> koeien, true :) but even for those it's useful for a margin note like "exp" for "take exp of both sides of the equation"
06:53:19 <Jafet> > cos $ (pi*) $ cos $ log (pi + 20)
06:53:20 <lambdabot>   -1.0
06:58:06 <burp> > showCReal 100 $  log (pi + 20)
06:58:07 <lambdabot>   "3.141631546259205254515999127103098351101174566538149795832453139243967086...
06:58:19 <burp> > showCReal 100 $  cos $ log (pi + 20)
06:58:20 <lambdabot>   "-0.99999999924368013309915205280081616303749021385159466922488226008922710...
06:59:24 <burp> > showCReal 100 $ cos $ (pi*) $ cos $ log (pi + 20)
06:59:25 <lambdabot>   "-0.99999999999999999717719572301811390729152041989463745242254395710444622...
06:59:26 <burp> kind of cheating :p
07:00:19 <Jafet> You are actually running into the limit of floating-point precision there, aren't you
07:00:27 <burp> yes
07:01:27 <quicksilver> Jafet: CReal isn't floating-point, which is why you can see that it isn't -1
07:03:10 <Cale> > showCReal 100 . cos . (pi*) . cos . log . (+20) $ pi
07:03:11 <lambdabot>   "-0.99999999999999999717719572301811390729152041989463745242254395710444622...
07:04:24 <Cale> > showCReal 100 (exp (pi * sqrt 163))
07:04:25 <lambdabot>   "262537412640768743.9999999999992500725971981856888793538563373369908627075...
07:05:00 <Jafet> > showCReal 100 0.1
07:05:00 <pozic> I just _love_ web-applications: http://holumbus.fh-wedel.de/hayoo/hayoo.html
07:05:00 <lambdabot>   "0.1"
07:07:51 <Cale> Astoundingly, there's an explanation for that being really close to an integer which has to do with the uniqueness of factorisation in the ring of integers of Q(sqrt(-163))
07:08:19 <quicksilver> I'm pretty sure there is a simpler explanation.
07:08:21 <Cale> > 640320^3 + 744
07:08:22 <lambdabot>   262537412640768744
07:08:26 <quicksilver> I saw a presentation on it once
07:08:30 <koeien> which is very interesting, yes
07:09:02 <quicksilver> you can factorise it in such a way that it's obviously (integer part) + (very small part)
07:10:36 <Cale> ah, wikipedia has an explanation
07:10:38 <Cale> http://en.wikipedia.org/wiki/Heegner_number#Almost_integers_and_Ramanujan.27s_constant
07:12:06 * quicksilver nots
07:12:14 <quicksilver> the version I saw was the same, but a bit more elementary
07:12:20 <quicksilver> quite an interesting talk actually.
07:12:33 <quicksilver> used that as a hook into the nature of mathematical proof
07:13:38 <Jafet> > let x = cos $ cos $ cos $ cos $ cos $ cos $ cos 1 in x / cos x
07:13:39 <lambdabot>   0.9622672354256365
07:13:50 <Jafet> Don't mind me, I'm just computing 1
07:14:08 <anonym> let x = (-) 2 1
07:14:11 <anonym> ;(
07:14:53 <Cale> The ideal class group and the class number are rather interesting, but among the most excruciating things I've ever had to calculate.
07:15:05 <saml> > sin pi
07:15:05 <lambdabot>   1.2246467991473532e-16
07:15:15 <quicksilver> > sin pi :: CReal
07:15:15 <lambdabot>   0.0
07:15:32 <saml> > sin (pi/2)
07:15:32 <lambdabot>   1.0
07:15:40 <mercury^> mmorrow: nope.
07:15:46 <akiel> can someone point me to a doc source where I can read something about unicode handling in Haskell? I mean the internal handling of chars vs. bytes. The data types and the encoding/decoding stuff. Thanks.
07:16:04 <mercury^> mmorrow: I think it's for a GHC developer to sort out anyway.
07:16:23 <mercury^> (and sorry for the laggy response :P)
07:16:30 <Cale> akiel: In GHC 6.12 it will work more or less out of the box, but for now, you'll have to use one of the encoding libraries.
07:16:47 <Cale> akiel: Char has always been capable of storing any unicode code point
07:16:53 <Cale> > maxBound :: Char
07:16:54 <lambdabot>   '\1114111'
07:17:21 <Cale> But the I/O stuff in every version of GHC up to 6.10 has been lacking in that regard.
07:17:34 <akiel> but what the hell is a ByteString? A String containing only 8-bit chars. Of which use should it be?
07:17:44 <koeien> akiel: it's way faster than String
07:17:50 <mercury^> Cale: how does that value arise?
07:18:00 <mercury^> Oh, it's octal.
07:18:02 <mercury^> right?
07:18:10 <Cale> mercury^: no, decimal
07:18:20 <mercury^> Ok then, how come it's that value?
07:18:21 <akiel> koeien: yes I read this - but this brings also many problems
07:18:57 <Cale> hmmm
07:19:27 <Cale> > 0x10ffff
07:19:28 <lambdabot>   1114111
07:19:31 <akiel> I like the strict Java approach which distinguishes between streams of bytes like the InputStream and streams of chars like the Reader
07:20:08 <burp> skaar: akiel http://hackage.haskell.org/packages/archive/utf8-string/0.3.5/doc/html/Data-ByteString-UTF8.html
07:20:09 <Cale> akiel: A ByteString is a string of bytes, not chars.
07:20:13 <burp> oops, akiel only
07:20:37 <Cale> akiel: But there's a ~.Char module with functions for treating it as a string of 8-bit chars
07:21:16 <akiel> burp: thanks
07:22:05 <Saizan> also, text and text-icu
07:22:14 <mercury^> Bytestring does weird stuff, like copying small strings twice when you use putStrLn on it.
07:22:32 <Cale> However, what you'll probably want to do is to either use the Data.Text module in the text package (which is an efficient packed unicode representation), or use something like utf-8-light which gives you an easy way to encode and decode UTF-8 ByteStrings to Strings of unicode characters.
07:22:49 <Cale> er, utf8-light, sorry
07:24:23 <desp> ICFP Contest 2009 results are in. :)
07:24:29 <Cale> Strings are still convenient for many tasks where all you need is a list
07:24:49 <akiel> what can I use to decode a ByteString returned from a Network.HTTP request with an arbitrary encoding? I mean the HTTP server can serve the response in every possible encoding.
07:25:26 <Cale> akiel: Perhaps the iconv binding would be more what you're looking for.
07:25:26 <akiel> desp: oh really than I have to look for it
07:25:43 <desp> http://icfpcontest.org/scoreboard.php
07:25:43 <Zao> akiel: Isn't there a header for restricting supported encodings?
07:26:02 <akiel> Zao: yes you are right
07:26:41 <mercury^> desp: you in there?
07:26:54 <Cale> You could convert whatever it is into UTF-8 using the iconv library, and then utf8-light to get a String of unicode Chars, for instance.
07:26:55 <mercury^> Was at a bad time, otherwise I'd have participated this year.
07:26:56 <akiel> we are place 186 (ICy Frantic People)
07:27:17 <desp> mercury^: #46
07:27:34 <desp> 2.(3) person team ;)
07:27:44 <mercury^> I'd go all assembler though, so it's hard to team up I guess.
07:29:35 <mmorrow> mercury^: (was that meant for me?)
07:29:46 <mmorrow> <mercury^> mmorrow: nope.
07:29:51 <mercury^> mmorrow: yes
07:29:55 <mercury^> 16:10 #haskell: < mmorrow> mercury^: did you ever get that fasta code sorted out?
07:30:18 <mmorrow> mercury^: ahh, nice :)
07:30:27 <mmorrow> well, not nice since nope that is
07:30:47 <mercury^> It's still a lot faster than the current submission, so if anyone wants to submit it I would not object.
07:30:56 <mercury^> I don't like to submit a suboptimal solution though.
07:31:08 <mmorrow> mercury^: remind me of what the issue was
07:31:20 <mmorrow> oh right, mutable arrays and allocation, right?
07:31:25 <mercury^> yep
07:33:43 <mercury^> On a side note: the algorithm you have to implement there (there's an obvious caching implementation, but because the contest/benchmark sucks you are forced to use some weird algorithm ofc) runs optimally using a single core on core2 if you use SSSE3.
07:34:30 <mercury^> And using SSSE3 it is also 2.3 times as fast as the current best.
07:35:03 <mmorrow> mercury^: it would be neato to have a harpy-like runtime assembler for SSE* stuff on x86_64
07:36:52 <mercury^> Shouldn't be hard to adjust it, and it might be useful to implement simple JITs.
07:37:14 <mmorrow> totally
07:38:13 <mercury^> It's quite a hack though to inject optimal ASM into a haskell program for a benchmark. :P
07:39:17 <mercury^> The GCC crowd should have an easy time writing a C program with GCC extensions that does not use inline asm and still is close to optimal.
07:46:09 <Pygma> Easy way to turn interger into a string?
07:46:14 <Botje> show
07:46:22 <Botje> > show 123
07:46:23 <lambdabot>   "123"
07:46:39 <Pygma> Oh should've realised
07:50:47 <mercury^> It should really be show :: (Showable a) exists b. (Medium b) => a -> b
07:51:21 <mercury^> So that show can create (motion-) pictures, sounds and so on.
07:51:33 <Botje> heh :P
07:51:37 <Botje> :t show &&& tell
07:51:38 <lambdabot> forall b (m :: * -> *). (Show b, MonadWriter b m) => b -> (String, m ())
07:52:22 <greap> Can you do type class matching like (X a, b) => ... somehow?
07:52:37 <greap> i.e. more than one cariable per class
07:52:42 <HugoDaniel> mercury^: try out the harpy module
07:52:49 <HugoDaniel> to generate assembly on the fly :)
07:53:58 <mercury^> greap: I'm not sure that I understand you, but maybe you're after so called "Multi Parameter Type Classes".
07:53:59 <lilac> greap: you mean like (X a b) => ... ?
07:54:45 <lilac> greap: take a look at the type signature lambdabot gave at 14:51 UTC
07:55:48 <greap> mercury^: not reelly, just defining more than one variable to be of the same class
07:56:02 <greap> excuse the spelling sorry :/
07:56:06 <mercury^> Ok, then just do it like (Show a, Show b)
07:56:33 <quicksilver> :t \x y -> show x ++ show y
07:56:33 <lambdabot> forall a a1. (Show a, Show a1) => a -> a1 -> [Char]
07:56:35 <greap> mercury^: I'm just trying to be a little terse.
07:56:37 <quicksilver> greap: no, you can't.
07:56:50 <greap> ok, thanks :)
07:57:02 * lilac ponders "let s = Show in (s a, s b)"
07:57:49 <lilac> nope, typeclasses just don't work like that :)
07:58:00 <mercury^> @pl (\s a b -> (s a, s b))
07:58:00 <lambdabot> flip =<< (((.) . (,)) .)
07:58:08 <dancor> haskell preprocessor
07:58:26 <quicksilver> it would be a fairly simple shorthand
07:58:41 <quicksilver> after all "x,y :: Int" is a simple, and very rarely used shorthand ;)
07:58:44 <mercury^> But it's really not a good feature.
07:58:53 <lilac> it would be not very useful, inconsistent and weird
07:58:53 <quicksilver> but in my experience, type sigs with multiple variables in the same class are not *that* common.
07:59:04 <lilac> typeclasses are just not expressions in any useful sense
07:59:13 <dancor> you might as well do something more interesting with a preprocessor like somehow allow the same type to be an Applicative in two ways at once or some such
07:59:59 <lilac> for types i can imagine a richer expression syntax being useful (but likely to make type resolution intractible)
08:00:31 <mercury^> Maybe it's time to switch to JavaScript and forget about types.
08:01:02 <Rotaerk> who needs em, eh?
08:01:09 <lilac> Maybe it's time to switch to classical logic and forget about values.
08:01:27 <mercury^> Let's create JavaLogic and forget about both.
08:01:53 <lilac> Isn't it enough to know the type's inhabited? :)
08:02:48 <mercury^> Absolutely not.
08:07:39 <ski> (mercury^ : why is it not a good feature ?)
08:08:21 <mercury^> ski: Anything that's used rarely and does not even noticably improve things then is bad.
08:08:38 <mercury^> A language needs to be as small as possible.
08:08:48 <Pygma> 2 : [x | x <- [3,5..], minimum [x `mod` y | y <- [3,5..x]] > 0] !! 0
08:08:52 <Pygma> Should return 2 right?
08:09:12 <Botje> yes.
08:10:03 <ski> mercury^ : it can avoid code duplication
08:10:16 <ski> (in this case of type expressions)
08:10:26 <Pygma> Gives an error I don't really understand (No instance for (Integral [t]) arising from a use of `mod` ...)
08:10:42 <mercury^> ski: and it's a bad feature. :)
08:11:10 <ski> i don't see why it is bad
08:11:20 <ski> i can see why you think is it mostly not necessary
08:14:02 <Lemmih> Pygma: (2 : [x | x <- [3,5..], minimum [x `mod` y | y <- [3,5..x]] > 0]) !! 0
08:14:08 <mercury^> And you can see that even when used it is almost useless?
08:15:01 <ski> i don't think that a means to avoiding repetition is almost useless, even if almost never used
08:15:18 <ski> (there might be better solutions, of course ..)
08:15:27 <Pygma> ty Lemmih
08:15:57 <ski> (.. also, such a feature might cause other problems which might outweight the benefits)
08:17:06 <lilac> would 'class Show s => S s; instance Show s => S s' work as a way of creating a shorthand for a typeclass?
08:18:51 <Asztal> doesn't it need UndecidableInstances?
08:19:16 <ski> it needs FlexibleInstances, no ?
08:19:41 <Asztal> instance S s => Show s -- what now?
08:20:03 <ski> "don't do that" :)
08:23:07 <lilac> hmm... 'class (Functor m, Applicative m, Monad m) => M m', 'instance (Functor m, Applicative m, Monad m) => M m'
08:23:34 <lilac> that's starting to look useful
08:23:39 <quicksilver> lilac: try it and tell me if it works :P
08:25:18 <lilac> quicksilver: yes, it works
08:25:28 <lilac> *Main> let f :: M m => m (m Int) -> m (m Int); f x = x >>= (return . (+1) <$>)
08:25:45 <lilac> *Main> :t f        ==>       f :: (Applicative m, Monad m) => m (m Int) -> m (m Int)
08:27:01 <lilac> add in overriding of defaults and defining instances of M, and that's type class aliases
08:28:55 <sioraiocht> Arnar: are you Icelandic?
08:31:51 <kakeman> :t True
08:31:51 <lambdabot> Bool
08:31:57 <kakeman> :o
08:32:17 <kakeman> what is that :t ?
08:32:21 <kakeman> variable?
08:32:49 <ski> @help type
08:32:49 <lambdabot> type <expr>. Return the type of a value
08:32:53 <Raevel> it's just a command
08:32:55 <ski> @type False
08:32:56 <lambdabot> Bool
08:33:06 <kakeman> type?
08:33:24 <ski> `:t' is an in-channel shorthand for `@type'
08:33:37 <quicksilver> lilac: cute. You should post it to the cafe
08:33:44 <coreyoconnor> :type map (+ 1)
08:33:53 <ski> (for some reason `:t' does not work in private communication with lambdabot)
08:33:58 <coreyoconnor> @type map (+ 1)
08:33:59 <lambdabot> forall a. (Num a) => [a] -> [a]
08:34:26 <coreyoconnor> :t map (+ 1)
08:34:27 <lambdabot> forall a. (Num a) => [a] -> [a]
08:34:34 <stroan> I don't suppose anyone has any experience with lambdabot acting up when trying to connect to an IRC server?
08:34:46 <coreyoconnor> ah. interesting. I would have expected :type to work as well
08:34:50 <coreyoconnor> oh well.
08:35:26 <Raevel> stroan: acting up how?
08:36:36 <stroan> not being able to connect, acting as if the host isn't there. "irc-connect netsoc irc.netsoc.tcd.ie 6667 lambdabot" fails, but connecting with the same details from the same host via irssi is grand
08:37:08 <kakeman> :t 0.1
08:37:09 <lambdabot> forall t. (Fractional t) => t
08:40:50 <coreyoconnor> @info Fractional
08:40:50 <lambdabot> Fractional
08:41:15 <coreyoconnor> hmm.. haha. Not quite the same as the ghci output of :info
08:42:06 <quicksilver> yes, :info would be too spammy for an in-channel bot IMO
08:43:14 <ski> @help info
08:43:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:43:19 <kakeman> :t (1, True)
08:43:20 <lambdabot> forall t. (Num t) => (t, Bool)
08:43:45 <coreyoconnor> ah good point.
08:44:35 <greb> hi
08:44:41 <ski>  lo
08:48:47 <greb> can some on explain to me what a arrow is?
08:52:10 <wmealing> greb:  => <- ?
08:52:23 <greb> wmealing: yep
08:52:26 <ski> greb : if you mean `Arrow', it is a generalization on the concept of function
08:52:37 <greb> ski: like a monad?
08:52:43 <ski> a bit similar, yes
08:53:04 <ski> but if you mean the syntax token `=>', then that's another thing entirely
08:53:29 <greb> sorry, i meant the abstraction, not the operator
08:53:50 <quicksilver> an Arrow is a function which can also have an effect, in the same sense that a Monad is a value which can also have an effect
08:54:16 <quicksilver> they are closely related in that each Monad m gives rise to an arrow (a -> m b), but the converse is not true in general.
08:54:45 <greb> for what is an arrow useful?
08:55:06 <ski> the basic idea is that an arrow "from" `a' "to" `b' is something which can be composed, can be constructed from a corresponding function, and where you can construct arrows over pairs from arrows working on the respective parts of the pair
08:55:13 <quicksilver> I don't think really convincing use cases have been demonstrated.
08:55:25 <quicksilver> but the swierstra-duponcheel parser is the best I know.
08:55:38 <kakeman> what is this <- ?
08:55:41 <ski> iirc, the initial use-case for them was a kind of parser that computed some static data before ever being applied to input to parse
08:55:58 <ski> (Swierstra & Duponcheel, iirc)
08:56:03 <greb> like look ahead parsers?
08:56:41 <quicksilver> that's what I said isn't it ski? ;)
08:56:50 * quicksilver checks he spelt it right.
08:57:29 <mux> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=9371#a9371
08:57:37 <kakeman> what is monad?
08:57:47 <mux> any idea why the commented instance doesn't work? I don't see how it conflicts since ST is not an instance of MonadIO
08:57:48 <ski> quicksilver : probably .. i didn't get to read that before after i hit <return> :|
08:57:54 <quicksilver> greb: a parser combinator library with some of the properties of a parser generator.
08:58:05 <quicksilver> greb: IIRC, it builds 'first-token' tables statically
08:58:08 <greb> a monad is a monoid with endo functors :D
08:58:21 <kakeman> hmm
08:58:22 <quicksilver> or, at least, it builds them on the first usage but then caches them
08:58:46 <quicksilver> kakeman: a Monad is a computation of a value with some associated side-effects, for a very general sense of the phrase 'side-effects'.
08:58:51 <ski> greb : like parsers that pre-compute their "first" set, and whether they can succeed while eating no input
08:59:09 <quicksilver> kakeman: http://www.haskell.org/haskellwiki/Monad
08:59:15 <coreyoconnor> greb: Whoa. I finally understood that statement. After all this time T_T
09:00:09 <quicksilver> mux: instances heads are not part of the instance selection decision.
09:00:33 <quicksilver> mux: "instance MonadIO m => MutRefM m" says "ALL m are instances of MutRefM"
09:00:46 <quicksilver> mux: (...but add a MonadIO context to the current context)
09:00:56 <mux> quicksilver: ewww.
09:01:43 <mux> quicksilver: well too bad for that instance, I'll ditch it
09:01:44 <quicksilver> it could not really be any other way... without changing haskell pretty fundamentally.
09:02:10 <mux> quicksilver: do you think this would be valuable to have on hackage, otherwise? I was thinking about pushing it
09:02:19 <mux> at least it's a nice example of type families at work
09:02:21 <maltem> mux: Welcome to the club of the "constrained instances work different from what you thought first" fallacy :)
09:02:32 <mux> maltem: I keep and keep on hitting that wall :-)
09:02:40 <maltem> heh
09:02:49 <quicksilver> mux: sure. It's already more useful than some packages on hackage ;)
09:03:17 <quicksilver> although if ST and IO are the only instances it's not really very useful
09:03:27 <quicksilver> anything which is polymorphich IO/ST might as well just be in ST
09:03:31 <mux> and if it becomes a problem, dons will maintain it :-P *runs laughing*
09:03:32 <quicksilver> (you can always run it)
09:03:50 <quicksilver> being polymorphic between lazy/strict ST is probably slightly useful
09:03:51 <mux> yeah, I just added both strict ST and lazy ST vs what's in the paper
09:04:14 <mux> oh, btw, since I took modifyGRef out of the class, I'm not forced into having the Monad m => pre-condition.
09:04:22 <mux> I'm not sure if it should be that way or not
09:04:46 <ski> quicksilver : in `foo :: MutRefM m => m Foo -> m Bar' it could be useful to pass an `IO Foo', no ?
09:05:27 * quicksilver doesn't quite see why
09:06:10 <ski> suppose `foo bar' embeds the `bar' action into some larger action which may only do mutation effects, but the `bar' fragment can still do `IO'-effects
09:06:51 <ski> e.g. `bar' might tell how to present some kind of structure to the user, while only mutation is needed for the computation of that structure itself
09:07:39 <ski> (you can replace `m Foo' with `(Baz -> m Foo)', if you prefer)
09:07:57 <quicksilver> yes, I see what you are saying.
09:08:23 <quicksilver> it is a good point.
09:08:31 <mux> I suppose there's nothing to be gained pusing modifyGRef into the class, I can't see an instance where it wouldn't be readRef >>= writeRef . f
09:09:07 * ski wanted in one example to possibly use `IO' to show solutions to a logic programming query, then backtrack and continue the LP execution
09:09:34 <ski> mux : maybe atomic stuff ?
09:09:35 <quicksilver> mux: it might be atomic
09:09:42 <ski> (:
09:09:44 <quicksilver> nuclear-combinators ++
09:10:41 <burp> Data.Map or Data.HashTable for ~100k entries lookup? Is HashTable lookup always O(1)?
09:11:27 <ski> mux : btw, could any of `MVar',`TVar',`SampleVar' &c. be captured in another class ?
09:13:34 <aavogt> burp: supposedly Data.HashTable isn't very good
09:13:47 <aavogt> plus it forces your algorithm to be in IO
09:13:51 <mux> quicksilver, ski: sorry, I'm back; did I miss anything?
09:13:53 <quicksilver> burp: Data.Map
09:14:08 <ski> (mux : also, what about `IOReadRef',`IOWriteRef', &c. ?)
09:14:31 <mux> ski: having separate classes for read and write references?
09:14:41 <ski> (mux : <http://tunes.org/~nef/logs/haskell/09.09.14>)
09:14:50 <mux> cheers
09:15:04 <ski> mux : maybe. i don't know. (just raising the issue)
09:15:24 <mux> since those are explicitely mutable references, I'm not sure about this
09:15:39 <ski> `IOReadRef' is also mutable
09:15:48 <ski> you just can't mutate it through that interface
09:16:11 <quicksilver> but it might get mutated by other people
09:16:17 <quicksilver> which is why it's different from a value
09:16:53 <mux> about atomic, only IO has one, but I guess that's enough to be wanting to put it in the class
09:17:01 <ski>   data IOReadRef a = forall x. IORRef (IORef x) (x -> a)  -- one possible conception
09:17:16 <mux> in which case, I'd define it to error "something" for ST, and to atomicModifyIORef for IO
09:17:31 <mux> I don't quite like that
09:17:39 <mux> maybe a superclass would be better?
09:17:50 <ski> it's possible
09:17:56 <mux> class MutRefM => AtomicMutRefM where ...
09:17:59 <quicksilver> nah
09:18:03 <quicksilver> ST *is* atomic
09:18:10 <quicksilver> it just doesn't need a special defintion to do so
09:18:12 <ski> (oh, you meant for atomicness ..)
09:18:17 <mux> quicksilver: aaaah.
09:18:21 <quicksilver> for ST you define modify = read >>= write
09:18:27 <quicksilver> but for IO you use the atomic one
09:18:32 <quicksilver> that's the point of having it as a method.
09:18:37 <mux> yeah
09:18:39 <quicksilver> ST is kept atomic by the type system
09:18:48 <quicksilver> (can't have the same ST in two process threads)
09:18:51 <mux> but should I also have a "standard" modifyGRef i the class ?
09:18:59 <mux> or should I put this one out of the class ?
09:19:39 <mux> and should the class declaration have a default definition for the atomicModifyGRef with error "not supported in this class" ?
09:19:43 <quicksilver> no.
09:19:48 <quicksilver> the standard one shuold be atomic
09:19:55 <quicksilver> is my suggestion.
09:20:02 <quicksilver> that's the only reason for it to exist :)
09:20:19 <quicksilver> as you correctly pointed out, otherwise it would just be read >>= write . f and what's the point of that?
09:20:23 <mux> I find it nice to have read >>= write . f already defined
09:20:33 <quicksilver> in isolation, perhaps
09:20:38 <quicksilver> but if you have it as a method there is no need :)
09:20:51 <mux> yeah, alright, I just leave it out of the class then
09:21:00 <quicksilver> no! put it in the class!
09:21:04 <quicksilver> but make it atomic when possible
09:21:10 <quicksilver> (and it is possible for IO and ST at least)
09:21:36 <mux> but I want to offer both a modify and an atomicModify, because the atomic one might have performance implications
09:22:01 <quicksilver> personally I wouldn't bother with that.
09:22:07 <ski> (.. maybe you want to add an `unsafeModify' ?)
09:22:19 <quicksilver> I can't imagine the case when you'd be writing polymorphic code and you would explicitly want to choose the non-atomic version.
09:22:26 <ski> (or s/unsafe/nonAtomic/ or something ..)
09:22:33 <mux> quicksilver: well in the case of IO
09:22:49 <mux> I suppose atomicModifyIORef has some cost attached to it
09:23:05 <mux> otherwise it would just be called modifyIORef
09:23:19 <ski> in the case of `IO' you can use `writeIORef ref . f =<< readIORef ref'
09:23:25 <mux> so you could indeed just not use GRef and use IORef
09:23:36 <ski> (or `modifyIORef')
09:23:38 <mux> right, but that performance implication is likely to hold for other monads
09:23:39 <mercury^> btw: if the name is already that long, why not call it "atomicallyModifyIORef"?
09:24:10 <ski> mercury^ : works for me
09:24:46 <mux> alright you have convinced me anyways
09:24:57 <mux> it just takes time for information to go all the way up to my brain
09:26:05 <mercury^> Now people will suddenly stop talking to you in the next discussion.
09:26:07 <quicksilver> mercury^: some of the naming decisions in the GHC library are a bit odd.
09:26:36 <mercury^> I don't like camel_case either btw.
09:26:44 <quicksilver> mercury^: "writeList2Chan" is a particular (un)favourite of mine.
09:27:05 <Twey> mercury^: Er
09:27:11 <Twey> mercury^: That's camelCase
09:27:53 <quicksilver> the camelCase boat sailed long ago, that's not changing now :)
09:28:17 <mux> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=9371#a9372
09:28:20 <mux> so that gives this
09:28:22 <mercury^> At least agda seems to do that right.
09:28:35 <mux> quicksilver: is this what you were thinking about?
09:28:40 <Twey> Don't see anything wrong with it, myself
09:28:41 <quicksilver> Data.Dynamic is another huge unfavourite : fromDyn/fromDynamic, dynApp/dynApply
09:28:53 <quicksilver> pairs of functions which differ only in being abbreviations of each other
09:28:59 <Twey> Hyphens are nice
09:29:01 <quicksilver> BUT MEAN SOMETHING DIFFERENT?
09:29:03 <quicksilver> I mean, wtf?
09:29:08 <Twey> quicksilver: Really?  Ew
09:29:11 <mercury^> quicksilver: haha
09:29:19 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Dynamic.html
09:29:29 <aavogt> at least you can't directly substitute one for the other
09:29:42 <quicksilver> mux: yes, that's what I meant.
09:29:49 <quicksilver> true, at least they have different types
09:29:54 <quicksilver> but still crazy crazy design.
09:30:03 <aavogt> almost as crazy as foldl'?
09:30:13 <mercury^> foldl' is okay
09:30:28 <quicksilver> far, far worse IMO
09:30:38 <quicksilver> foldl' is systematic, you just need to know the system.
09:30:38 <mercury^> strict_foldl would be better maybe
09:30:52 <mercury^> but the idea of having a strict version is totally fine.
09:31:12 <mux> quicksilver: I think modifyGRef should be called atomicModifyGRef, it seems a bit odd to not hint at that in the name
09:31:13 <kakeman> what is Just?
09:31:14 <aavogt> hmm, Data.Dynamic could be starting its own system ;)
09:31:37 <mercury^> kakeman: a constructor for the Maybe type.
09:31:52 <mercury^> data Maybe a = Nothing | Just a
09:31:52 <aavogt> at least it is consistent with itself
09:35:45 <malcolmw> Haskell Implementers Workshop 2009 videos now online here: http://vimeo.com/album/126462
09:37:01 <greb> malcolmw: thanks
09:39:39 <stroan> hmm, why would lambdabot be giving me Terminated for every @run command?
09:40:03 <gwern> maybe you're a terrible DOSing programmer
09:40:27 <stroan> there is that
09:40:40 <stroan> but imagining for a second that I'm not all that bad a guy :P
09:40:48 * gwern can't imagine that
09:43:28 <Saizan> stroan: are you referring to this channel's lambdabot or to your own instance?
09:43:33 <stroan> my own instance
09:43:37 <stroan> from cabal
09:43:44 <conal> malcolmw: thx!  are vimeo videos downloadable?
09:44:26 <gwern> conal: I think you can grovel the html source for a download link
09:44:38 <Saizan> stroan: it means you need to installe mueval then, probably
09:44:48 <ski> conal : hello
09:45:03 <ski> conal : jmcarthur wanted to write functions of types `(x0 -> x1) -> ((a -> x0) -> (a -> x1))',`((a0 -> x0) -> (a1 -> x1)) -> ((a0 -> b -> x0) -> (a1 -> b -> x2))',`((a0 -> b0 -> x0) -> (a1 -> b1 -> x1)) -> ((a0 -> b0 -> c -> x0) -> (a1 -> b1 -> c -> x2))'
09:45:29 <malcolmw> conal: yes, they should be downloadable
09:45:32 <ski> i thought you might be interested in pondering whether this can be done with SEC
09:45:32 <mmorrow> malcolmw: woot!
09:45:40 <mmorrow> malcolmw: thanks
09:45:41 <conal> ski: hi
09:47:18 <etpace> > [1..5] >>= \x -> [] >>= \y -> (x,y)
09:47:18 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(t, a)'
09:47:24 <etpace> > [1..5] >>= \x -> [] >>= \y -> return (x,y)
09:47:25 <lambdabot>   []
09:47:28 <conal> malcolmw: cool.  i'll poke around and see if i can figure out how.  at home, i don't have the bandwidth to watch videos.
09:47:32 <etpace> how does [] work in the list monad?
09:47:48 <etpace> is it just [] >>= _ = []>
09:47:51 <ski> @djinn ((a0 -> x) -> (a1 -> y)) -> ((a0 -> b -> x) -> (a1 -> b -> y))
09:47:51 <lambdabot> f a b c d = a (\ e -> b e d) c
09:47:52 <ski> @djinn ((x0 -> x1) -> (y0 -> y1)) -> (((a0 -> x0) -> (a1 -> x1)) -> ((a0 -> y0) -> (a1 -> y1)))
09:47:52 <etpace> ?*
09:47:52 <lambdabot> -- f cannot be realized.
09:47:52 <lambdabot> Maybe you meant: . ? @ v
09:47:56 <mux> etpace: (>>=) is just concatMap
09:48:03 <etpace> hm
09:48:04 <mux> and concatMap _ [] = []
09:48:35 <mux> > [1..5] >>= \x -> guard (odd x) >> return x
09:48:35 <lambdabot>   [1,3,5]
09:49:11 <ski> > map (\x -> guard (odd x) >> return x) [1..5]
09:49:12 <lambdabot>   No instance for (GHC.Show.Show (m a))
09:49:12 <lambdabot>    arising from a use of `M6506165284...
09:49:20 <malcolmw> conal: OK, at the bottom of each individual video page, on the right, is the download link
09:49:25 <ski> > map (\x -> guard (odd x) >> return x) [1..5] :: [[Integer]]
09:49:25 <lambdabot>   [[1],[],[3],[],[5]]
09:49:26 <etpace> guard p | p = return (); guard p | otherwise = fail?
09:49:43 <ski> etpace : yes, except s/fail/mzero/
09:49:43 <etpace> > fail :: [Int]
09:49:44 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
09:49:51 <mux> @src MonadPlus
09:49:51 <lambdabot> Source not found. My mind is going. I can feel it.
09:50:06 <ski> @src guard
09:50:07 <lambdabot> guard True  =  return ()
09:50:07 <lambdabot> guard False =  mzero
09:50:19 <etpace> > mzero :: [Int]
09:50:19 <lambdabot>   []
09:51:15 <conal> malcolmw: got it.  thanks!
09:51:41 <etpace> :t
09:51:44 <etpace> :t concatMap
09:51:45 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
09:52:11 <mux> :t (`concatMap`)
09:52:12 <lambdabot> parse error on input `)'
09:52:22 <mux> :t `concatMap`
09:52:23 <lambdabot> parse error on input ``'
09:52:26 <mux> oh well
09:52:30 <mux> :t flip concatMap
09:52:30 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
09:52:43 <etpace> aha
09:56:00 <pastah> @src guard
09:56:00 <lambdabot> guard True  =  return ()
09:56:00 <lambdabot> guard False =  mzero
09:56:33 <pastah> > [1..10] >>= guard even
09:56:34 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:56:36 <Berengal> Yay, haskell videos!
09:56:46 <ziman> :t guard
09:56:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:56:52 <mux> > [1..10] >>= guard . even
09:56:52 <lambdabot>   [(),(),(),(),()]
09:57:10 <mux> of course, that makes for a less interesting result
09:57:11 <pastah> > [1..10] >>= (x -> guard . even >> return x)
09:57:12 <lambdabot>   Pattern syntax in expression context: x -> guard . even >> return x
09:57:36 <pastah> > [1..10] >>= (x -> guard (even x) >> return x)
09:57:37 <lambdabot>   Pattern syntax in expression context:
09:57:37 <lambdabot>      x -> guard (even x) >> return x
09:57:45 <stroan> Saizan: installed mueval and rebuilt lambdabot as well and no love unfortunately
09:57:54 <ziman> you're missing the `\'
09:57:58 <pastah> > [1..10] >>= (\x -> guard (even x) >> return x)
09:57:59 <lambdabot>   [2,4,6,8,10]
09:58:07 <pastah> there we go :)
09:58:52 <mux> of course that's a contrived example
09:58:58 <pastah> i have NO clue as to how it works, though :/
09:59:18 <mux> well you've seen the source of guard?
09:59:27 <mux> for the list monad, mzero is just []
09:59:39 <benmachine> while return x is [x]
09:59:41 <pastah> mux: opening gvim now, expanding functions...
10:00:06 <mux> so this is the same as: [1..10] >>= \x -> if even x then [] else return x
10:00:41 <mux> which is the same as: concatMap (\x -> if even x then [] else [x]) [1..10]
10:01:11 <pastah> mux: chill out, i'm wrapping my head around this, slowly...
10:02:47 <Saizan> stroan: what happends if you try "mueval -e 'some haskell expression'" in the shell?
10:04:22 <stroan> Saizan: returns without output
10:04:25 <stroan> or error
10:07:31 <stroan> sorry, exits with return value 127
10:07:43 <etpace> @pl \f (a,b) -> (f a, b)
10:07:44 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
10:08:03 <mux> > (+1) `fmap` (1,2)
10:08:04 <lambdabot>   (1,3)
10:08:16 <mux> ah, it's the second one
10:08:25 <mux> etpace: anyways, that's first f
10:08:27 <mux> :t first
10:08:28 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
10:08:40 <mux> > first (+1) (1,2)
10:08:40 <etpace> thanks
10:08:41 <lambdabot>   (2,2)
10:08:47 <etpace> @hoogle first
10:08:47 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
10:08:47 <lambdabot> Data.Monoid newtype First a
10:08:47 <lambdabot> Data.Monoid First :: Maybe a -> First a
10:08:52 <mux> the connection is a bit fuzzy but ...
10:08:55 <mux> enjoy arrows
10:09:01 <ski> @src (,) fmap
10:09:01 <lambdabot> fmap f (x,y) = (x, f y)
10:09:07 <ski> @src (->) first
10:09:07 <lambdabot> first f = f *** id
10:09:09 <ski> @src (->) (***)
10:09:09 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
10:09:15 <ski> (note the `~')
10:09:35 <etpace> what's the significance?
10:09:37 <mux> I was referring to that precisely :-P
10:09:46 <ski> (and actually you wanted s/first/second/)
10:10:00 <mux> d'oh, sorry about that, it's the fever
10:10:03 * mux has bronchitis
10:10:26 <mishrak> first (+1) (1,2)
10:10:53 <ski> > snd (second (const ()) undefined)
10:10:54 <lambdabot>   ()
10:10:54 <ski> > snd (fmap (const ()) undefined)
10:10:55 <lambdabot>   * Exception: Prelude.undefined
10:10:59 <ski> etpace : ^
10:11:22 <mishrak> > snd (1,2)
10:11:22 <lambdabot>   2
10:12:09 <aavogt> is that just arbitrary that `Functor ((,) a)' is excessively strict?
10:13:29 <sohum> > first (1,2)
10:13:30 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
10:13:30 <lambdabot>    arising from a use of `Control...
10:13:42 <ski> the argument is that `fmap id' ought to be `id' (counting partial values)
10:13:42 <sohum> heh
10:14:23 <ski> thus `case fmap id undefined of (_,_) -> ()' ought to be `undefined', not `()'
10:15:23 <benmachine> ski: is that the same as fmap id (undefined, undefined) though?
10:15:35 <benmachine> oh wait no I see
10:15:47 <benmachine> carry on
10:16:33 <ski> no `(undefined,undefined)' is observably different from `undefined' (but maybe it shouldn't be ?)
10:16:34 <Berengal> Heh, "I'm tired of writing untyped functional programs at the type level" - SPJ
10:17:00 <ski> Berengal : is that `remember'ed ?
10:18:40 <stroan> Saizan: getting closer. Mueval works but lambdabot is now saying it can not find module `Control.Arrow.Transformer.All'
10:19:44 <aavogt> stroan: you can get rid of that import, or find the package that supplies it (something like arrow-transformers on hackage)
10:19:58 <aavogt> the import happens to be in State/L.hs
10:21:29 <stroan> cheers. Should these not be standard dependencies for lambdabot?
10:24:05 <aavogt> those are pretty much optional dependencies
10:25:00 <aavogt> idealy they could be in scope if they were installed, but cause nothing to fail if they were not
10:25:29 <aavogt> perhaps the easiest solution would be to remove those from L.hs?
10:28:42 <stroan> yeah, I'm installing the dependancies now.
10:29:20 <c_wraith> What sort of support for module availability checking does haskell have at runtime?
10:29:30 <c_wraith> Or would that need to be done at compile time?
10:31:42 <stroan> hmm, commenting out the lines don't seem to affect lambdabot, and recompiling overwrites the file.
10:32:20 <aavogt> stroan: that L.hs is looked at by lambdabot at runtime
10:32:53 <stroan> "L.hs:3:29: Module `Control.Arrow' does not export `pure'L.hs:3:29: Module `Control.Arrow' does not export `pure'"
10:32:58 <stroan> yet line 3 is commented out
10:33:20 <aavogt> stroan: where are you running lambdabot?
10:33:34 <stroan> from which directory?
10:33:38 <aavogt> yeah
10:33:40 <stroan> ~/
10:34:35 <aavogt> it should be with the sources (or at least copy state/{L.hs,imports.h,...} to whereever you want to run it)
10:35:37 <stroan> running in .cabal/share/lambdabot/State results in the same
10:35:57 <gwern> aavogt: easiest would just be some CPP to remove arrows
10:36:12 <gwern> and you should be able to just run lambdabot in ~/ and it'll populate .lambdabot on-demand
10:36:24 <gwern> (but bedtime now, so figure out the rest by yourself)
10:37:04 <aavogt> stroan: I guess there's a L.hs in  your ~/.lambdabot that needs fixing then
10:38:25 <stroan> aavogt: Many many thanks. It's been a headache getting this working, due to a long series of me being not quite as quick as I should be. Never noticed that dir.
10:38:59 <copumpkin> bos: if you stay in boston until wednesday, you could come to the boston haskell user group!
10:43:46 <bos> copumpkin: i'm already spoken for that night, unfortunately
10:43:51 <copumpkin> aw ok
10:55:13 <etpace> :t liftM
10:55:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:56:11 <etpace> :t ap
10:56:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:01:57 <etpace> > liftM2 (+) (Just 5) (Just 6)
11:01:57 <lambdabot>   Just 11
11:02:10 <etpace> > liftM (+) (Just 5) `ap` (Just 6)
11:02:11 <lambdabot>   Just 11
11:05:39 <copumpkin> psykotic: :O
12:01:56 <chrisdone> sup
12:06:33 <greap> Hi. Just trying to get vacuum running. I'm getting the error 'graphviz executable "dot" not found'. Any ideas what I'm missing here?
12:07:19 <Makoryu> greap: Run `which dot` in your shell
12:07:24 <mauke> an executable called dot, presumably
12:09:58 <Makoryu> greap: Does `which dot` return anything?
12:11:07 <greap> Makoryu: Nope :) I think that's the problem.
12:11:22 <Makoryu> greap: Yep. You'll need to install that somehow.
12:11:46 <greap> Makoryu: Yep, but I have no idea what project comes with the dot executable.
12:11:59 <defun> Hi. I have a datatype Vector (data Vector = Vec Float Float Float). I try to make it an instance of Functor (instance Functor Vector where fmap (v) (Vec a b c) = Vec (f a)(f b)(f c)). Ghc gives me the following error when I try to compile: Kind mismatch.  Expected kind `* -> *', but `Vector' has kind `*' . What am I doing wrong?
12:12:19 <defun> * should be fmap (f)
12:12:29 * tibbe realized today that I/O and laziness don't mix.
12:12:48 <Makoryu> greap: Search your package manager for graphviz. If you're on OS X, you might prefer to write a shell script that sends the input to a graphviz app.
12:13:21 <greap> Makoryu: Is that what dot does?
12:13:30 <Makoryu> greap: As far as I know.
12:13:33 <blackh> defun: You want to say "instance Functor (Vector a) where .."
12:13:44 <defun> Ah, thanks.
12:13:47 <greap> Makoryu: Ok, thanks.
12:13:49 <blackh> Functors are always containers
12:21:49 <shazam> hello, does anyone know anything about incorporating haskell's type system into context free grammars?
12:30:49 <Cale> shazam: Does that even entirely make sense? Hmm...
12:33:22 <shazam> Cale, sure: List a = a '::' List a | '[]', exp = exp '+' exp, ...
12:34:35 <shazam> basically, nonterminals are types and you allow them to be polymorphic
12:34:56 <jmcarthur_work> blackh, for some definition of "containers," sure
12:35:36 <blackh> jmcarthur_work: Just think of a definition that's broad enough to make me right. :)
12:35:44 <jmcarthur_work> haha
12:36:19 <jmcarthur_work> blackh, if you consider (a ->) to be some sort of container, sure :)
12:38:29 <blackh> jmcarthur_work: Maybe I can tape it up.
12:39:16 <tibbe> what's Lennart Kolomdin's handle?
12:40:11 <tibbe> @tell kolmodin did some more thinking on binary and continuations. I don't think it's possible to use continuations and preserve laziness.
12:40:11 <lambdabot> Consider it noted.
12:40:42 <rovar> anyone know if there is a way to configure leksah for single button mice?
12:40:49 <rovar> (e.g. macs)
12:41:09 <jmcarthur_work> rovar, control-click doesn't work?
12:41:25 <rovar> nup, that's my usual first try
12:41:34 <rovar> doesn't do anything
12:41:41 <jmcarthur_work> huh. well i don't know how to help you. i was just making sure
12:42:30 <Makoryu> rovar: Switch to Linux. That's the advice I always get when trying to beat GTK into shape, and having given up on such things, I'll simply repeat it.
12:42:35 <rovar> i guess I'll file a bug, I haven't been able to find anything on zie goog.
12:43:02 <rovar> Makoryu: heh.. I use leenucks at home, but I have a 1hr train ride and a macbook.
12:43:24 <rovar> so was trying to set up a haskell env on this little white piece of crap.
12:43:27 <Makoryu> rovar: You can still put Linux on your Scottish computer
12:45:03 <rovar> i'm often tempted to do that (or throw it out of a 10th floor window)  but I need a way to test on osx occasionally.
12:45:15 <Makoryu> Alternatively, you could install GTK-X11 on OS X, and then cry yourself to sleep at its embarrassing usability
12:45:38 <rovar> you don't appear optimistic
12:45:44 <Makoryu> I have learned not to be.
12:46:16 <Makoryu> It seems most of the time that OS X is not really considered a platform by the Haskell community
12:46:24 <Makoryu> And no, I didn't forget the word "viable" in there
12:46:28 <jsoffer> I'm near finishing translation of the Haskell Cheat Sheet to Spanish language (http://github.com/jsoffer/cheatsheet). Proofread, etc. pending. Where should I place a notice? The wiki?
12:49:26 <jmcarthur_work> i've never had a problem with haskell on os x
12:49:37 <jmcarthur_work> besides a little hoop jumping to get the sdl bindings to work
12:49:53 <jmcarthur_work> which was really the fault of sdl
12:51:27 <rovar> i've had no problems with haskell/platform there. I haven't really left the terminal though
12:59:24 <temoto> Hello. There is this Chomsky hierarchy of grammars. Is Haskell's grammar of type-2 (context-free) or not?
12:59:41 <copumpkin> no
12:59:50 <temoto> There were examples of Perl and LISP as context-sensitive.
13:00:06 <c_wraith> Oh, right.  indentation
13:00:12 <c_wraith> That's definitely context-sensitive
13:00:34 <temoto> copumpkin: why not? Could you explain?
13:00:44 <copumpkin> the main example is indentation as c_wraith said
13:01:11 <copumpkin> but apart from that I think it's mostly context-free
13:01:14 <Cale> Also, operator fixity declarations
13:01:15 <mauke> foo = a + b * c where infixr 8 +
13:01:26 <copumpkin> oh true
13:01:29 <jmcarthur_work> temoto, oh, it's been shown that perl cannot be parsed ;)
13:01:38 <mauke> jmcarthur_work: not really
13:01:46 <jmcarthur_work> not without runtime information
13:02:01 <mauke> yeah
13:02:08 <mauke> that puts it in the same class as lisp and c++
13:02:17 <jmcarthur_work> wait, c++?
13:02:21 <mauke> templates
13:02:30 <c_wraith> yeah, template metaprogramming makes a mess of parsing it
13:02:31 <jmcarthur_work> what about templates requires runtime info?
13:02:45 <mauke> jmcarthur_work: to parse templates you have to run them
13:02:55 <jmcarthur_work> right, but you don't have to run the code they parameterize
13:03:02 <rovar> a+++++b
13:03:03 <mauke> that doesn't really matter
13:03:13 <rovar> that should be legal, doesn't parse :)
13:03:22 <jmcarthur_work> i don't really think it's on the same level as perl's syntax
13:03:26 <copumpkin> > let (+++++) = (+) in 5 +++++ 6
13:03:27 <lambdabot>   11
13:03:34 <jmcarthur_work> i guess i see what you mean
13:03:41 <mauke> jmcarthur_work: ok, how about class layout, vtables, rtti, etc?
13:03:45 <rovar> (wrt c++)
13:03:53 <copumpkin> > let (+++++) = ((+) <=< (+) <=< (+)) in 5 +++++ 6
13:03:54 <mauke> jmcarthur_work: you have to do that in the lexer to parse c++
13:03:54 <lambdabot>   23
13:04:04 <jmcarthur_work> c++ is such a mess that i don't really care to defend it, anyway ;)
13:04:23 <copumpkin> > let (+++++) = ((+) >=> (+) <=< (+)) in 5 +++++ 6 -- zomg coproduct of (+)
13:04:24 <lambdabot>   23
13:04:26 <jmcarthur_work> @karma c
13:04:26 <lambdabot> c has a karma of 1
13:04:29 <jmcarthur_work> c--
13:04:38 <mauke> preflex: karma c
13:04:38 <preflex>  c: 37598
13:04:49 <jmcarthur_work> i have to assume that is an artifact of talking about c plus plus
13:04:56 <etpace> > let foo = ask >>= \e -> return (e*2) in runReader (ask >>= \e -> local foo (e*2) >>= \a -> return (a,e)) 10
13:04:57 <lambdabot>   Occurs check: cannot construct the infinite type:
13:04:57 <lambdabot>    r = Control.Monad.Read...
13:05:15 <etpace> how do I use local correctly?
13:05:28 <jmcarthur_work> :t local
13:05:29 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
13:06:15 <Makoryu> temoto: Even though Haskell's indentation-sensitive syntax isn't properly context-free, the compiler internally filters its input to change the indentation sensitive stuff to something that can be parsed with a less powerful grammar
13:06:23 <etpace> I don't really understand the typeclass
13:06:23 <temoto> Please, about indentation. uh.. having theorem "haskell grammar is context-sensitive", is proof "because x may refer to different values depending in which one of nested `let .. in` blocks you put x"?
13:06:36 <Twey> Argh!
13:06:57 <Twey> Scandal: â€˜fileâ€™ detects my xmonad config as â€˜ASCII Java program textâ€™
13:07:01 <Twey> >.<
13:07:25 <etpace> > let foo = ask >>= \e -> return (e*2) in runReader (ask >>= \e -> local (*2) foo >>= \a -> return (a,e)) 10
13:07:26 <lambdabot>   (40,10)
13:10:24 <temoto> Please, about indentation. uh.. having theorem "haskell grammar is context-sensitive", is proof "because x may refer to different values depending in which one of nested indented `let .. in` blocks you put x"?
13:13:53 <dolio> What language class a grammar is in has nothing to do with what values particular names refer to in a given scope.
13:14:20 <dolio> Or, unless it does, like in perl's case, I suppose.
13:14:46 <mauke> lol wut
13:14:54 <mauke> name lookup is simple in perl
13:15:22 <copumpkin> omgwtf
13:15:36 <copumpkin> (bbq)
13:15:36 <dolio> Yes, but you have to do it to parse perl. That's what makes parsing perl Turing complete.
13:15:39 <earthy> mauke: name lookup is runtime-dependant in perl
13:15:41 <dolio> You don't have to do it to parse Haskell.
13:15:49 <mauke> earthy: not really
13:15:55 <earthy> partially at least
13:15:58 <mauke> how?
13:16:05 <earthy> oh, waitsec, which version of perl are we discussing?
13:16:28 <mauke> let's say 5.10.1
13:16:51 <earthy> mauke: because names can be defined with different symbol arities (or even not at all) depending on if statements predicated on input.
13:17:22 <mjrosenb> oh man, if the evil mangler gets updated to perl6
13:17:33 <mauke> s/updated to/rewritten in/
13:17:39 <mjrosenb> and the only viable perl6 interpreter is pugs
13:17:40 <PeakerWork> how about rewritten in Haskell?
13:17:48 <mauke> I'd prefer it to be rewritten in perl5
13:17:51 <mjrosenb> we'll have an awesome bootstrapping proccess
13:18:03 <mauke> earthy: hmm, I wouldn't include that in name lookup
13:18:07 <mjrosenb> if you want registerised builds
13:18:20 <blackh> The evil mangler has already been re-written in Haskell
13:18:25 <mjrosenb> ghc -> pugs -> perl6 -> registerised ghc
13:18:37 <mjrosenb> blackh: quiet you, ncg does not exist
13:18:42 <earthy> mauke: what, if (/regexp/) { sub blurk() { bla; } } else { }; blurk
13:18:45 <mjrosenb> :-p
13:18:56 <mauke> earthy: that's not ambiguous
13:18:57 <earthy> where blurk is defined or not depending on if $_ matches regexp?
13:18:59 <dolio> The NCG doesn't have to do any evil mangling.
13:19:10 <mauke> earthy: that's not how perl works
13:19:24 <earthy> then I've been mistaken in my understanding of perl :)
13:19:31 <earthy> which is quite possible
13:19:36 <mauke> blurk will always be defined there
13:19:46 <dolio> http://www.perlmonks.org/?node_id=663393
13:20:00 <earthy> (perl is not very congruent with my mind, somehow)
13:20:06 <copumpkin> blackh: really? where?
13:20:40 <PeakerWork> blackh: ah, where?
13:20:45 <PeakerWork> blackh: why isn't it the new official one?
13:21:21 <mauke> earthy: my point is, when you reach 'blurk', parsing/resolving it is easy (given the state of the program so far)
13:21:22 <earthy> dolio: thanks, I was looking for that
13:21:28 <blackh> copumpkin, PeakerWork: I'm talking about the native codegen.  You're all going to say, "Ohhh... we knew about that!!"
13:21:51 <copumpkin> native codegen? I thought it still went through text?
13:21:58 <PeakerWork> blackh: well, that's rewriting something else, not the evil mangler
13:22:01 <earthy> yes, but not through the magler
13:22:17 <earthy> hm. typo's. maybe I should just call it a day
13:22:35 <PeakerWork> augustuss's LLVM function generators could possibly be considered a new backend too
13:23:30 <blackh> You're so fussy!
13:24:38 <PeakerWork> blackh: or, if you'd like, the rewrite kinda sucks for not having the ability to get gcc to optimize ghc's output
13:27:29 <dolio> GCC doesn't seem to do a particularly amazing job of applying optimizations to GHC's output anyway.
13:27:30 <blackh> PeakerWork: The problem is, of course, that gcc doesn't generate code exactly how GHC needs it (without the function prologue / epilogue).
13:27:50 <dolio> It doesn't recognize loops that GHC generates, for instance, so it doesn't get you unrolling.
13:28:17 <dolio> The only thing the C backend is well known for doing better is floating point math on x86-32.
13:29:17 <Athas> What about taking advantage of CPU-specific instructions?
13:29:46 <mauke> POI - punch operator immediately
13:30:07 <bd_> Athas: GCC will assume only i386 capabilities by default
13:30:14 <bd_> unless you pass in -march=
13:30:42 * mauke passes -march=native
13:31:13 <Athas> bd_: yes, but if you ask it to assume some other set of capabilities, will it do a noticeably better job than the native GHC backend?
13:31:22 <bd_> no idea :)
13:31:26 <Athas> What does GHC assume in terms of capabilities on x86 anyway?
13:31:28 <bd_> it might use CMOV and the like a bit
13:31:48 <mjrosenb> aaaeu
13:31:58 <mjrosenb> oops
13:32:02 <mjrosenb> silly screen
13:34:37 <etpace> :t liftIO
13:34:38 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
13:35:09 <wolgo> Hi, (Num a) => a -> a -> a is a function that takes two nums and returns a num right?
13:35:49 <poe> if by num you mean "a value of a type belonging to the type-class num" yes
13:36:23 <wolgo> yeah that is what I mean
13:36:28 <wolgo> Num as a type
13:36:54 <poe> Num is a class of types, not a type. "Num a =>" is a constraint on a which says "a belongs to Num"
13:37:22 <benmachine> the signature you showed requires that both argument types be the same as the result type
13:37:26 <coco> hi
13:37:39 <coco> does parsec come with a "parseable" typeclass that can be filled with instances?
13:37:57 <coco> if not, would it be good style to make my own?
13:38:09 <benmachine> coco: I'm not sure what it would look like
13:38:28 <coco> class Parseable a where parse :: String -> a
13:39:08 <wolgo> thanks I am learning haskell
13:39:22 <poe> cool! what are you reading?
13:39:35 <Asztal> coco: How is it different from Read, though?
13:39:37 <benmachine> coco: isn't that a bit like Read?
13:39:39 <benmachine> er
13:39:40 <benmachine> yeah
13:39:55 <Asztal> (Except that it's a bit simpler; you can't return multiple possibilities)
13:40:19 <dschoepe> coco: normally you use parsec to write that function.
13:40:43 <coco> hmmm, I guess I meant class Parseable a where parse :: Parser a
13:40:58 <benmachine> ah
13:41:03 <benmachine> that might be useful
13:41:15 <benmachine> might be
13:42:04 <jmcarthur_work> there are many way to return an Int with a Parser
13:42:22 <coco> jmcarthur_work: newtype is our friend for that
13:43:11 <jmcarthur_work> i'm not going to say it's a bad idea. i just don't know how useful it is
13:43:23 <coco> :)
13:50:40 <osfameron> meh, ghc takes some compilation
14:06:23 <funcA> sup haskellians
14:06:56 <tehgeekmeister> curious if anyone knows how to generate a list lazily from a stateful computation?  i was told to embed the writer monad inside state yesterday, but i'm just checking if someone has a simpler idea before i do that.
14:07:35 <tehgeekmeister> (also, i figured out i could use an mvar, but i'd really rather avoid that.  seems clunky to have to use an mvar just to lazily generate a list from inside the state monad)
14:08:38 <Makoryu> tehgeekmeister: How stateful is this computation, exactly?
14:09:30 <tehgeekmeister> Makoryu: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9357 <== makeNextBestReader is the function in question
14:09:38 <tehgeekmeister> since i'm not sure how to quantify how stateful something is
14:09:47 <PeakerWork> tehgeekmeister: do you care if consumption of the list executes your computation in an interlaced manner, or if the whole list is created at one go?
14:10:12 <tehgeekmeister> PeakerWork: interlaced is what i'm after, hence mvars being a plausible workaround
14:10:27 <PeakerWork> tehgeekmeister: there's the generator package by yairchu (with a bit of my help)
14:10:41 <earthy> then it seems like adding the writer monad inside that state monad seems the simplest solution
14:11:04 <earthy> I wouldn't know of a simpler off the top of my head
14:11:21 <PeakerWork> but Writer won't give you a list whose consumption lazily executes the monadic actions
14:11:26 <blackh> tehgeekmeister: I'm going to prototype the advice I gave you yesterday, just to make sure I am not talking out of a hole in my navel.
14:11:47 <earthy> peakerwork: true enough.
14:11:51 <tehgeekmeister> blackh: thanks, i tried, but got absolutely nowhere with it
14:11:54 <PeakerWork> that's what generator does
14:12:04 * earthy ponders
14:12:11 <tehgeekmeister> generator is exactly what i wanted, then, the whole time
14:12:38 <PeakerWork> tehgeekmeister: its basically like Python generators... lazy lists are like python generators of pure lists, but the generator packages gives you lists that embed monadic actions in between items
14:12:39 <tehgeekmeister> it's annoying this is such a tricky problem
14:13:40 <PeakerWork> tehgeekmeister: something like   action :: Producer String IO ; action = produce $ do { print "Hello world!" ; yield "First result" ; print "Blah" ; yield "Second" }
14:14:08 <earthy> the XTC controls from Dazzle (see http://www.cs.uu.nl/dazzle/ ) do something tehgeekmeister may want
14:14:26 <tehgeekmeister> PeakerWork: yeah, i'm familiar with python's generators.  that's exactly how i've been thinking about this thus far.  perhaps, given how limited my dependence is on the state monad, i could've made this totally pure and threaded state manually, but i'd really rather avoid that
14:14:43 <earthy> IIRC
14:14:44 <PeakerWork> tehgeekmeister: then something like:   evalConsumerT $ do { print "I am the mighty consumer" ; x <- next ; print x ; y <- next ; ... }
14:14:44 <Parkotron> I wrote the following to sum all the primes less than two million. While I think it's somewhat elegant, it's not terribly performant. http://pastebin.ca/1566008
14:14:46 <c_wraith> hehe.  You *could* do it with unfoldr :)
14:14:51 <PeakerWork> tehgeekmeister: the consumer and producer's action will be interlaced
14:14:56 <c_wraith> But unfoldr is terrible
14:14:59 <c_wraith> :t unfoldr
14:15:01 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:15:07 <Parkotron> Am I correct in assuming the problem is that primes is recalculated for each call to isPrime?
14:15:40 <tehgeekmeister> PeakerWork: cool
14:15:42 <earthy> see also section 6 of http://www.cs.uu.nl/dazzle/f08-schrage.pdf
14:16:08 <tehgeekmeister> PeakerWork: how long has this package been available, anyway?
14:16:18 <PeakerWork> tehgeekmeister: the idea was to emulate Python2.5's generators with a simple library, but we of course got something more general because it is useful for all monads.  Turns out to be really cute for the list monad too
14:16:23 <PeakerWork> tehgeekmeister: a few months, I think
14:16:31 <c_wraith> Seriously..  Is unfoldr ever the best solution to anything?
14:16:47 <Apocalisp> is it ever not?
14:16:56 <PeakerWork> tehgeekmeister: its not perfect though, we found out a conceptual problem with it. We intended to replace iteratee with it, but we discovered we are not as safe as iteratee later
14:17:09 <blackh> tehgeekmeister: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3613#a3613
14:17:12 <tehgeekmeister> PeakerWork: that explains why no one knew of it back when i worked on this last; it wasn't available then!
14:17:22 <c_wraith> Apocalisp: in cases where you like being able to read your code, unfoldr is often....  suboptimal. :)
14:17:37 <tehgeekmeister> blackh: it works!
14:17:49 <blackh> tehgeekmeister: It must be lazy, since it runs forever, otherwise it wouldn't produce any output.
14:17:56 <tehgeekmeister> blackh: what is this forever?
14:17:57 <PeakerWork> blackh: numbers is a pure list though. If you want a list that interlaces items with actions, you need something more
14:18:18 <PeakerWork> blackh: something like ListT
14:18:22 <blackh> @source forever
14:18:22 <lambdabot> forever not available
14:18:29 <PeakerWork> forever x = x >> forever x
14:18:59 <Badger> hm?
14:19:09 <Badger> @source onions
14:19:09 <lambdabot> onions not available
14:19:14 <Badger> how odd
14:19:30 <c_wraith> @src join
14:19:30 <lambdabot> join x =  x >>= id
14:22:01 <PeakerWork> join = (>>=id) ; (>>=f) = join . fmap f
14:22:25 <PeakerWork> (>>=id) = join . fmap id = join . id = join
14:22:36 <Apocalisp> > let f n = if n == 0 then Nothing else Just (n, n-1) in let fac = foldr (*) 1 . unfoldr f in fac 10
14:22:36 <lambdabot>   3628800
14:23:00 <PeakerWork> I hate the use of   Maybe (a, b)   to represent  [] | a : [a]
14:23:19 <c_wraith> Yeah, it's the Maybe bit that makes unfoldr annoying.
14:23:31 <Apocalisp> Totally agree
14:23:47 <PeakerWork> @type unfoldr
14:23:48 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:24:02 <c_wraith> It's only there so unfoldr can generate terminating lists...
14:24:12 <byorgey> > let f n = guard (n /= 0) >> return (n,n-1) in let fac = foldr (*) 1 . unfoldr f in fac 10
14:24:13 <lambdabot>   3628800
14:24:41 <Apocalisp> @type guard
14:24:42 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:24:44 <byorgey> that makes it slightly more palatable IMO
14:24:53 <PeakerWork> @type iterate
14:24:54 <lambdabot> forall a. (a -> a) -> a -> [a]
14:24:56 <c_wraith> I guess that's better, but still seems verbose
14:25:44 <Apocalisp> that's just the lets and ins
14:25:45 <byorgey> c_wraith: well, if you want to generate infinite lists, then you don't need the Maybe.
14:25:52 <byorgey> but that's because infinite lists only have one constructor.
14:26:06 <PeakerWork> @type map snd . iterate
14:26:07 <lambdabot>     Couldn't match expected type `[(a, b)]'
14:26:07 <lambdabot>            against inferred type `a1 -> [a1]'
14:26:07 <lambdabot>     In the second argument of `(.)', namely `iterate'
14:26:09 <byorgey> @type unfoldr
14:26:10 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:26:23 <PeakerWork> @type (map snd.) . iterate
14:26:24 <lambdabot> forall a b. ((a, b) -> (a, b)) -> (a, b) -> [b]
14:26:30 <c_wraith> Indeed.  I'd be happier with an unfoldr variant that only worked for infinite lists.  But I suspect the generator package is cleaner for the same purpose.
14:26:45 <PeakerWork> c_wraith: like this iterate thing? :)
14:26:46 <byorgey> in general  unfoldr :: b -> F a b -> b -> Fix F a
14:27:12 <byorgey> so the 'Maybe (a,b)' simply corresponds exactly to the list functor, L a b = 1 + a x b
14:27:54 <byorgey> I forget which *morphism this generalized unfoldr actually is
14:28:01 <c_wraith> heh.  The iterate thing does indeed do exactly that.
14:28:02 <dolio> ana
14:28:02 <Apocalisp> ana?
14:28:04 <byorgey> anamorphism, maybe
14:28:06 <byorgey> right, thanks
14:28:27 <dolio> (b -> F a b) -> b -> Fix F a, incidentally.
14:28:50 <byorgey> oh, right, missed those parens
14:28:51 <byorgey> thanks =)
14:30:27 <greap> Woot. Vacuum-opengl is up and running
14:30:34 <c_wraith> Hmm.  How expensive is constructing/matching pairs constantly, anyway?  (this isn't really related, but did remind me of that question)
14:31:07 <byorgey> c_wraith: anyway, my point is that the type of unfoldr is exactly what it needs to be for lists.  complaining that the Maybe is annoying is like complaining that the empty list is annoying.
14:31:15 <byorgey> i.e. if it is annoying, then use a different type =)
14:31:27 <c_wraith> hehe.  Yes, the empty list is annoying.  I like infinite lists. :)
14:32:24 <c_wraith> > fix (0:)
14:32:25 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:32:31 <c_wraith> That's a nice list. :)
14:34:16 <mmorrow> data OneOrMore a = One a | OrMore a (OneOrMore a)
14:34:45 <c_wraith> heh.  fine, take me at my word and show it's inconsistent. :)
14:34:52 <mmorrow> :)
14:35:48 <Cale> > print "hello"
14:35:49 <lambdabot>   No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
14:35:49 <lambdabot>    arising from a use of...
14:35:50 <Cale> hmm
14:36:02 <Cale> ah, I think I know why :)
14:36:04 <mmorrow> , print "hello"
14:36:06 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
14:36:22 <c_wraith> > (return ()):: IO ()
14:36:23 <byorgey> ac_wraith: constantly constructing/matching pairs can be fairly expensive if it involves allocating pairs on the heap, and the alternative is to just keep two values in registers.
14:36:23 <lambdabot>   No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
14:36:23 <lambdabot>    arising from a use of...
14:36:30 <byorgey> c_wraith*
14:36:31 <yav> mmorrow: data List1 a = List1 { one :: a, orMore :: [a] } might be a bit nicer
14:36:31 <lambdabot> yav: You have 1 new message. '/msg lambdabot @messages' to read it.
14:36:36 <mmorrow> (looks like the error prettifying module is off?)
14:36:41 <Cale> (The ShowFun module isn't imported)
14:36:44 <byorgey> c_wraith: but I'm not sure how good a job GHC does at optimizing this sort of thing
14:36:58 <mmorrow> yav: probably so
14:37:07 <Cale> I just uploaded a new version of the show package to hackage with a nonidiotic version of show for IO though.
14:37:09 <mmorrow> or just (a,[a])
14:37:13 <c_wraith> byorgey:  This is entirely something controlled by the implementation of GHC, right?
14:37:22 <Cale> (the other one made it into an error for some stupid reason)
14:37:52 <byorgey> c_wraith: yes, although if you want to get really fancy you can use unboxed tuples yourself using (# x, y #) notation or something crazy like that
14:38:18 * Cale is going to see if he can fix mueval's error messages.
14:38:19 <dolio> > id :: Int -> Int
14:38:20 <lambdabot>   {-3->-3;-2->-2;-1->-1;0->0;1->1;2->2;3->3}
14:38:43 <Cale> ah, we do have that...
14:38:48 <dolio> It's about time.
14:38:53 <c_wraith> I wasn't aware Int was limited in range quite that much. :)
14:39:03 <Cale> Perhaps the ShowFun module should be split up
14:39:25 <dolio> @check \f -> f 5 == f 6
14:39:26 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
14:39:26 <lambdabot>    arising from a use of `...
14:39:32 <c_wraith> > (>) :: Int -> Int -> Int
14:39:33 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:39:41 <c_wraith> > (>) :: Int -> Int -> Bool
14:39:42 <lambdabot>   -3->
14:39:42 <lambdabot>    {-3->False;-2->False;-1->False;0->False;1->False;2->False;3->False}...
14:39:59 <dolio> @check \f -> f 5 == (f :: Int -> Int) 6
14:39:59 <lambdabot>   Overlapping instances for GHC.Show.Show
14:40:00 <lambdabot>                              (GHC.T...
14:40:21 <funcA> teacher asked me what type could represent a tridimentional point
14:40:23 <dolio> Ah well.
14:40:37 <funcA> I'm thinking of a triple of Num's
14:40:43 <funcA> amirite?
14:40:46 <lament> depends on what type the dimensions are :)
14:40:47 <c_wraith> Num isn't a concrete type, though.
14:41:04 <c_wraith> Num is a typeclass that several types implement.
14:41:10 <Cale> dolio: hmm, I wonder what's overlapping there.
14:41:20 <funcA> oh come on, don't depress me this late in the night
14:41:25 <Cale> Oh, I can guess what it is.
14:41:26 <Apocalisp> funcA: (a, a, a)
14:41:27 <dolio> Cale: Maybe QuickCheck has a show instance for functions?
14:41:40 <lament> funcA: what type can represent a one-dimensional point?
14:41:40 <funcA> Num a => (a,a,a) ?
14:41:46 <PeakerWork> DebugShow class would be nice
14:41:54 <Apocalisp> forAll a. (a, a, a)  no?
14:42:05 <funcA> lament: I dunno, I'm dealing with a tridimentional point :P
14:42:59 <c_wraith> Apocalisp does have a point (pun not intended), in that your axis might not be numeric.
14:42:59 <lament> sorry, can't think of any witty response
14:43:17 <Apocalisp> Maybe even (a, b, c)
14:43:47 <funcA> c_wraith: how so? I'm really dumb, so if you could explain to me as if I'm a retarded at maths, which i am... I would apreciate it
14:43:50 <jmcarthur_work> as a general rule, i try not to think too hard about type class constraints when i am coming up with types
14:43:54 <lament> (Color, Temperature, Pitch)
14:44:12 <c_wraith> If this is intended to represent a point in R^3, make your type more concrete, like (Double, Double, Double)
14:44:25 <jmcarthur_work> the type class constraints could vary from function to function
14:44:34 <lament> c_wraith: that's what I always get at Tim Hortons
14:44:40 <c_wraith> Otherwise, lament provides a great example.  You might not always be working in a space that uses numeric indexing.
14:45:02 <funcA> c_wraith: this is about a normal tridimencional point, the one used in a x-y-z axis :P
14:45:25 <funcA> because in a following question he asks what type would be a polygon
14:45:47 <dolio> Cale: Looks like it doesn't (2.1 has a Function type that wraps functions for showing). But maybe the lambdabot module for quickcheck adds one or something?
14:45:53 <c_wraith> So then just pick an appropriate concrete type, rather than a typeclass
14:46:01 <c_wraith> Double is probably a decent choice.
14:46:10 <funcA> what is a concrete type?
14:46:26 <funcA> something that derives from a typeclass?
14:46:34 <funcA> like Int,Double from Num?
14:46:37 <c_wraith> A type with constructors.
14:46:38 <khufu> What do I need to compile Haskell
14:46:45 <khufu> Just the ghc6?
14:46:46 <c_wraith> As opposed to a typeclass, which just defines behavior
14:47:10 <burp> I heard 6.12 release is tomorrow?
14:47:10 <blackh> khufu: What operating system are you using?
14:47:25 <funcA> c_wraith: if I say: 3dpoint :: Num a => (a,a,a) what would be wrong?
14:47:25 <c_wraith> Actually, that's not totally accurate, as there's an extension that allows a concrete type with no constructors...  But don't worry about that detail. :)
14:47:27 <khufu> Linux
14:47:42 <yav> khufu: use ghc
14:47:56 <khufu> Okay ;)
14:48:01 <blackh> khufu: Use GHC version 6.10.
14:48:17 <blackh> khufu: If your Linux has 6.8, you can use that, but 6.10 is much better.
14:48:18 <c_wraith> funcA:  That doesn't define one type.  It defines a bunch of types.  There's nothing wrong with it as a type signature for a function that you intend to be polymorphic.
14:49:04 <c_wraith> funcA:  But in the end, GHC always has to pick a concrete type implementing the class constraints to actually work with (usually based on type inference)
14:49:35 <c_wraith> funcA:  My interpretation of the question is "what type would you actually use?", rather than "what type signature could you support?"
14:49:52 <dolio> burp: There hasn't been a release candidate yet, has there?
14:50:24 <funcA> c_wraith: I see. if you had to do it, how would you do it?
14:50:40 <c_wraith> funcA: I'd answer (Double, Double, Double), for this case.
14:51:25 <c_wraith> funcA:  As that's the type I'd end up using for my data set.
14:51:46 <burp> dolio: then it was a joke I heard ;(
14:51:59 <funcA> c_wraith: Double is the widest number thingy in Haskell?
14:52:00 <c_wraith> funcA: (In the absence of a compelling reason to reconsider that decision)
14:52:03 <Cale> 6.12 ought to be soon anyway...
14:52:14 <Cale> (I think...)
14:52:17 <dolio> burp: There's a mail on the GHC mailing list that says a RC was supposed to be released today (14th).
14:52:25 <burp> ah maybe that's it
14:52:43 <dolio> That hasn't happened yet, though, as far as I can tell.
14:52:43 <c_wraith> funcA: Well.  It's the widest relatively-efficient type.  It has good hardware support on most machines.  That sort of consideration.
14:53:39 <c_wraith> How long has it been since there were processors without FPUs?  386? 486?
14:54:00 <c_wraith> Um.  desktop processors.  I'm not thinking embedded stuff. :)
14:55:03 <funcA> c_wraith: I wanted to define with Num a because I'm crazy
14:55:41 <funcA> if I wanted to define a 3dpoint with complex numbers, I assumed it would work
14:56:04 <c_wraith> funcA:  It's not a bad impulse.  I'm just not sure if it answers the question at hand.  Not having the exact wording, and not knowing your prof, I can't say what (s)he'd prefer.
14:56:19 <c_wraith> funcA: And my tendency would be towards the concrete.
14:56:20 <Cale> aha, I might have figured out the reason for the funky error messages
14:56:25 <Cale> > fix id
14:56:30 <lambdabot>   mueval-core: Prelude.read: no parse
14:56:30 <lambdabot>  mueval: ExitFailure 1
14:56:31 <Cale> ^^ these ones.
14:57:00 <dolio> c_wraith: Wikipedia says 486 had a built-in FPU (new feature).
14:57:12 <c_wraith> thanks, dolio
14:57:18 <funcA> c_wraith: I haven't met him yet, school on starts tomorrow and I'm only answering to some of the exercises lin the
14:57:27 <funcA> listed in the classes' website
14:57:54 <funcA> :P
14:58:00 <funcA> I'm going to sleep now
14:58:02 <c_wraith> funcA:  I wouldn't worry about it yet, then.  Sounds like you know the intended material pretty well.
14:58:13 <funcA> thanks for your help, c_wraith
14:59:26 * Cale ã¯possibleãªfixã§lambdabotã‚’recompileã—ã¦ã„ã‚‹
15:00:01 <kmc> 486 DX had an FPU
15:00:04 <c_wraith> Man, I stopped japanese too early.  I'm not familiar with na as a particle
15:00:35 <kmc> 486 SX had the fpu burned out; you could buy an FPU add-on which was a 486 DX with the parts *except* the FPU burned out
15:00:40 <Cale> It's used for applying ãª-adjectives
15:00:53 <dolio> Classy.
15:00:54 <khufu> blackh, yeah,it only has 6.8 not 6.10
15:01:07 <Cale> lambdabot: @flush
15:01:13 <Cale> lambdabot: @quit
15:01:24 <blackh> khufu: Then I think you're using debian or Ubuntu! Well, the 6.10 binary from haskell.org works nicely on Debian and Ubuntu.
15:01:39 <c_wraith> > fix id
15:01:49 <lambdabot>   mueval-core: Prelude.read: no parse
15:01:52 <Cale> grrrr
15:01:54 <Cale> hmm
15:02:04 <c_wraith> That's...  less output.
15:02:06 <Cale> I wonder if there's something wrong with any of the other args.
15:02:16 <Cale> It was a malformed commandline argument
15:04:43 <Baconizer> :S I'm using the standard binary GHC to compile the Haskell Platform on openSUSE 11.1, i686. It compiled fine, but after 'sudo make install' I get the error that 'The mtl-1.1.0.2/Setup script does not exist or cannot be run'
15:06:13 <Cale> cale@li85-105:~/.lambdabot/State$ mueval -E --noimports -l L.hs "--expression=fix id" +RTS -N2 -RTS
15:06:13 <Cale> mueval-core: Time limit exceeded
15:06:24 <Cale> That's what it's *supposed* to print :P
15:07:15 <Cale> hmm
15:11:37 <Cale> å…¨ç„¶åˆ†ã‹ã‚‰ãªã„ã€‚
15:12:18 <c_wraith> I can pick out "I don't know", especially given context.  My kanji's weak, though. :)
15:12:33 <Cale> ãœã‚“ãœã‚“
15:12:49 <c_wraith> apparently, so is my vocab. :)
15:13:45 <Cale> It's like 'completely' or 'entirely', or when used with a negative verb 'not at all'
15:14:42 <c_wraith> Ah.  Thanks.
15:15:03 <Cale> I can pass what seem to be the same parameters to mueval that lambdabot does, and I get an appropriate error message. When lambdabot does it I get that "Prelude.read: no parse" garbage.
15:16:00 <Saizan__> Cale: yeah, i never figured that out
15:16:28 <Cale> I figured out part of it anyway
15:16:35 <jmcarthur_work> Cale, i am not familiar with LB's code, but is lambdabot parsing the output of the command with read, bychance?
15:16:42 <Cale> It was passing --timelimit= and 10 as two separate parameters.
15:16:53 <mauke> strace is your friend
15:16:55 <Cale> It doesn't appear to be doing anything with the output.
15:17:15 <Cale> I've completely disabled the 'cleaning' that it used to do.
15:17:25 <c_wraith> clean = id
15:17:29 <Cale> yeah
15:17:38 <Cale> Or, clean_ rather
15:18:19 <Cale> waaaiiit...
15:18:33 <Cale> cale@li85-105:~/lambdabot$ ./lambdabot
15:18:33 <Cale> Initialising plugins ................................................... done.
15:18:33 <Cale> lambdabot> > fix id
15:18:33 <Cale>   mueval-core: Time limit exceeded
15:18:39 <Cale> that looks good
15:19:02 <quicksilver> \o/
15:19:21 <Cale> @quit
15:19:36 <Cale> > fix id
15:19:45 <lambdabot>   mueval-core: Time limit exceeded
15:19:50 <c_wraith> woot :)
15:19:50 <Cale> hooray!
15:21:45 <tehgeekmeister> blackh: modified my code to use your approach, it compiles, will let you know if it works
15:23:34 <tehgeekmeister> blackh: failed.  only managed to print the very first item.
15:23:45 <tehgeekmeister> i believe PeakerWork was right.
15:24:51 <blackh> tehgeekmeister: Well, that's a good start. :)  Can you paste it?
15:25:03 <tehgeekmeister> blackh: yup, give me a sec
15:25:04 <PeakerWork> tehgeekmeister: if you don't have any IO or such in the stateful computation you might be ok with a simple lazy list
15:25:25 <tehgeekmeister> PeakerWork: nope, no io, only actions in the state monad
15:25:34 <tehgeekmeister> still monadic actions, however
15:25:45 <PeakerWork> tehgeekmeister: the strict or lazy state monads?
15:26:04 <PeakerWork> tehgeekmeister: I think you could do with the WriterT transformer, but I'm not sure
15:26:07 <tehgeekmeister> PeakerWork: didn't specify, just imported state
15:27:00 <PeakerWork> tehgeekmeister: I think that's the lazy one, but I'm not sure
15:27:10 <tehgeekmeister> blackh: oh.  because i didn't recurse, of course it didn't do anything but the first element.
15:27:31 <tehgeekmeister> blackh: forever doesn't work, since my computation ends, so i have to do something a touch different, not sure what yet
15:28:38 <blackh> forever just does the same as an explicit recursion, so it'd be fine just to use if ... then recurse.. else return ..
15:29:09 <tehgeekmeister> i'll try forever first, see if it doesn't like it
15:29:14 <tehgeekmeister> otherwise i'll figure out a way around
15:30:59 <tehgeekmeister> tada!
15:31:00 <tehgeekmeister> it works.
15:31:04 <tehgeekmeister> still want to see the paste?
15:31:24 <blackh> Yeah!
15:32:09 <tehgeekmeister> it does have significant semantic errors, so it doesn't do what it's meant to
15:32:09 <tehgeekmeister> but
15:32:15 <tehgeekmeister> in any case, it's lazy, and stateful
15:32:17 <tehgeekmeister> *pastes
15:33:17 <tehgeekmeister> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9378#a9379
15:33:51 <tehgeekmeister> left in the old code for my reference, in case i needed to revert.
15:34:15 <c_wraith> tehgeekmeister: use local source control! :)
15:34:31 <tehgeekmeister> c_wraith: i was but got lazy.  =/
15:35:04 <tehgeekmeister> i know, you really do have to be quite lazy to not put the time into committing a change.  still.
15:35:30 <PeakerWork> tehgeekmeister: why do you use (\f -> maybe ... f ...) $ ?
15:35:37 <blackh> tehgeekmeister: Thanks - I love looking at Haskell code.
15:35:42 <PeakerWork> tehgeekmeister: why not use maybe ... someName ...   where someName x = ...
15:35:53 <tehgeekmeister> PeakerWork: that's a good idea
15:36:17 <tehgeekmeister> i wanted to use a case statement originally, but couldn't get past some parse error
15:36:19 <tehgeekmeister> so i just stuck with this
15:37:37 <tehgeekmeister> really this file would be around half the size if i had thrown out all the junk i don't need as i was going.  think that's my next chore.
15:37:49 <tehgeekmeister> and quickcheck tests!  to catch my semantic errors.
15:38:09 <PeakerWork> tehgeekmeister: you also have some superfluous "do"s I think.  try hlint on it?
15:38:36 <Boney> in 1
15:39:07 <tehgeekmeister> PeakerWork: oh, yeah, i probably don't need the do in the innermost lambda
15:40:56 <PeakerWork> tehgeekmeister: hlint gives nice suggestions
15:41:34 <tehgeekmeister> is hlint a stand alone utility, or what?  i'm not sure if i have it
15:41:57 <PeakerWork> tehgeekmeister: cabal install hlint
15:42:02 <tehgeekmeister> k
15:43:31 <benmachine> all my list constructor sections have :) on the end
15:43:47 <benmachine> every time I look at it it makes me :) too
15:44:39 <tehgeekmeister> lol
15:45:16 <aconbere> anyone here have much experience with VTY? I'm seeing some strange behaviour with rendering ByteStrings but I could just be doing things wrong :)
15:46:29 <aconbere> Basically I'm rendering a bytestring from a preconstructed string plus an additional buffer to fill up the image
15:46:39 <aconbere> but no matter what size my window is
15:46:54 <aconbere> I'm getting an image that's 45 chars long with two extra lines
15:47:49 <Asztal> Is it just me, or does GHCI exit with "WriteConsole: resource exhausted" when you paste in a form feed character (Windows-only, I'd assume)? Here's one for you: ""
16:00:23 <aavogt> hmm, there is no way for haddock to just ask ghci for missing type signatures?
16:01:42 <Cale> Asztal: Well, on linux, I don't see anything too special about pasting a form feed in.
16:01:50 <Cale> Asztal: No error messages anyway.
16:30:51 <weirdo> hey
16:31:01 <weirdo> what's a good resource for a lisp programmer to learn haskell?
16:31:01 <dons> tommd: how many hits have you had for your kernel modules article?
16:31:15 <dons> weirdo: hmm. learnyouahaskell.com or real world haskell
16:31:33 <dons> you'll pick things up faster, since you already know higher order functions
16:31:36 <dons> tommd: its taken over the internet
16:31:36 <weirdo> because i once read some tutorial in pdf form, and literally half of it was about the type system
16:31:38 <weirdo> i consider that a bad thing
16:31:51 <dons> some tutorials emphasise different things
16:31:57 <dons> i'd start with the two I mentioned.
16:32:18 <weirdo> is there a REPL that can define new functions?
16:32:21 <dons> maybe you were reading a type system tutorial. it is an important part of haskell. it is what enables much of the awesomness.
16:32:29 <dons> weirdo: are you using ghc and ghci?
16:32:35 <dons> preferably from the Haskell Platform?
16:32:44 <dibblego> weirdo, you can use GHCi and the let keyword
16:32:49 <dons> http://hackage.haskell.org/platform/
16:32:54 <dibblego> Prelude> let x = (+1)
16:32:55 <weirdo> dons, right now i'm not using anything. i want to know whether it's worth the effort to learn haskell. because lots of lispniks defected to haskell lately
16:32:56 <dons> if so, > let f x = x + 2
16:32:58 <weirdo> maybe i should follow suit
16:33:24 <dons> one click installers on the link above. why wait?
16:33:33 <Peaker> weirdo: its extremely worth learning :)
16:33:35 <dons> and you could be writing multicore programs in 5 minutes.
16:34:05 <weirdo> i'm using LFS. and i'll learn it actually, because respectable people stopped lisping
16:34:13 <weirdo> but i need to take some math classes to write non-toy programs
16:34:33 <lament> what kind of non-toy programs do you want to write?
16:34:34 <dons> that's not true.
16:34:36 <weirdo> so it'll take me more than one click. but i'll start compiling right nao :-)
16:34:44 <dons> weirdo: grab a copy of "Real World Haskell". its free, online
16:34:45 <c_wraith> Nah.  You don't need that much math.
16:34:58 <dons> you might need to know about (+) or (*) :)
16:35:01 <dons> what a function is.
16:35:16 <c_wraith> The math is interesting abstraction layers...  But you can get by just fine without many of them.
16:35:21 <weirdo> lament, dons: stuff i did so far was either some simple database CRUD, or unix systems programming, e.g. how to replace a file atomically
16:35:25 <dons> seriously, install the Haskell Platform, and write some stuff.
16:35:26 <weirdo> dons, like i told, i know lisp
16:35:30 <dons> good.
16:35:48 <dons> I'd strongly suggest "Real World Haskell" then.
16:35:55 <weirdo> i also already implemented lazy evaluation in lisp
16:35:56 <dons> it has lots of unixy, databasey, networky stuff
16:36:06 <weirdo> i don't like side effects anymore :(
16:36:14 <aconbere> Is the RWH book significantly better than the online preview?
16:36:17 <lament> weirdo: www.lisperati.com/landoflisp/
16:36:20 <aconbere> I found the latter to be mostly unreadable
16:36:21 <weirdo> besides, i heard that mixing monad types makes for strange HM errors
16:36:26 <c_wraith> Then avoid anything with IO in its type signature, weirdo. :)
16:36:38 <dons> aconbere: plenty of people seem to use the online version.
16:36:43 <dons> the book is more polished though.
16:36:53 <weirdo> yeah. i need to learn math to write something that doesn't use io, though :)
16:36:59 <aconbere> dons: yeah I just don't know how they get through it :)
16:37:05 <dons> weirdo: why do you think that?
16:37:07 <aconbere> weirdo: that's not true
16:37:10 <dons> or are you just joking?
16:37:15 <dons> to write pure functions?
16:37:22 <dons> its a subset of Lisp, which you already know, so....
16:37:22 <weirdo> write non-toy pure functions
16:37:42 <dons> no, I think you need to do some programming in Haskell, then you'll have a more accurate opinion.
16:37:44 <c_wraith> You can write haskell like lisp.
16:37:45 <dons> less talk, more code!
16:37:51 <weirdo> ok!
16:38:02 <c_wraith> You can ignore category theory weirdness
16:38:10 <c_wraith> And just use relatively simple types.
16:38:17 <weirdo> so i'll download binary GHC and install it to /tmp/ghc, then install haskell-platform to /opt/haskell-platform-version
16:38:24 <weirdo> how do i launch a REPL in emacs, preferably/
16:38:34 <dons> use the haskell-emacs mode, I think.
16:38:40 <weirdo> :)
16:38:52 <dons> this math/category theory thing is funny.
16:39:01 <weirdo> i'll probably end up implementing HM for lisp
16:39:04 <dons> just because we understand the foundations of our language, doesn't mean that's what you use for day to day programming
16:39:16 <dons> any more than you use separation logic when programming in C.
16:39:16 <weirdo> as well as efficient lazy evaluation
16:39:22 <dons> most languages have no idea what their foundations are. and people get on fine.
16:39:40 <weirdo> lambda calculus has funny syntax
16:40:19 <Makoryu> Not just funny, but hilarious
16:41:14 <tehgeekmeister> hlint is pretty nifty
16:41:37 <weirdo> one big question
16:42:03 <weirdo> does static typing actually increase productivity as compared to lisp-style bottom-up programming?
16:42:17 <MyCatVerbs> dons: peoples whose C programs work tend to know just a little about Hoare logic. ;)
16:42:28 <dons> weirdo: bottom-up programming isn't a type system.
16:42:37 <dons> i'm not sure that's even something you can compare.
16:42:51 <c_wraith> Type systems are best in long-term situations.  They make it easy to have confidence in changes you make over time.
16:42:52 <dons> since the type system is something in addition to the development methodology
16:43:08 <weirdo> dons, but in lisp you can redefine stuff, introspect on it, change classes of instances, redefine the compiler, fix bugs while the program is running
16:43:10 <dons> i guess there's something you'll get to learn as you explore
16:43:17 <Makoryu> weirdo: Static typing is something you should compare to tests rather than one programming style or another
16:43:28 <tehgeekmeister> dons: have been curious, in general, how would *you* approach lazily generating a list from within the state monad.  two suggestions have been made: 1) embed the writer monad in the state monad, this seems to work, but is a touch unwieldy.  2) use the generator package from hackage.  as well, there's a final possibility i considered, which is even uglier: use mvars and multiple threads.  i just figure there's GOT to be a
16:43:29 <tehgeekmeister> more elegant way to do it.  halp?
16:43:48 <weirdo> and haskell is 'static', there's no fooling around, e.g. redefining a function to a different type
16:43:53 <Peaker> weirdo: I think Haskell is weaker w.r.t modifying stuff at runtime like that
16:44:13 <MyCatVerbs> tehgeekmeister: the trivial way would be to use WriterT State or StateT Writer, depending on whatever.
16:44:14 <weirdo> but what do you get out of static typing, really?
16:44:20 <Peaker> weirdo: but the Haskell type-system is powerful enough that it really doesn't stand in your way
16:44:22 <c_wraith> You get long-term confidence.
16:44:37 <Peaker> weirdo: When my code compiles, it almost always works. Also, the type system writes some of the code for me
16:44:39 <dons> i'd probably do the Writer monad trick.
16:44:43 <weirdo> can HM guarantee that no divide-by-zero error will ever occur?
16:44:44 <MyCatVerbs> weirdo: The need to write far fewer unit tests. (Though it doesn't save you from having to perform functional testing).
16:44:49 <Makoryu> weirdo: Yeah, the static typing does restrict the ways you can freely modify things. However, you can shadow stuff in ghci with stuff that has a different type
16:44:51 <dons> weirdo:  far fewer unit tests.
16:45:18 <weirdo> can i write actually useful types?
16:45:21 <MyCatVerbs> weirdo: No, you need a Halting Problem oracle to make a type system that can do that perfectly accurately. :)
16:45:25 <tehgeekmeister> MyCatVerbs: that's what i'm using right now, tho it's a bit unintuitive to me right now.  can't for the life of me see WHY it should work, only know that it does and i am proficient enough to slay type errors that result from attempting to use it!
16:45:26 <weirdo> not just (and fixnum (satisfies oddp))
16:45:28 <gwern> weirdo: it's more rigorous, and guards you from errors. working through SICP more than once I've cursed PLT for not catching things like missing arguments or wrong syntax
16:45:33 <dons> weirdo: yes, you can capture complicated design invariants in types
16:45:44 <tehgeekmeister> dons: thanks, i appreciate it
16:45:44 <gwern> (I mean, how stupid does a program have to be to not even warn you when you gave 1 argument to car instead of 2?)
16:45:44 <gwern> er, I mean 'cons' :) 1 argument to cons
16:45:44 <weirdo> dons, this is good
16:46:10 <MyCatVerbs> tehgeekmeister: Hrmn, that is ambiguous. Oh well. I'd do the embed-Writer-in-the-State-monad thing myself, FWIW.
16:46:29 <dons> weirdo: here's an experience report on using the type system from a company i work at, http://www.galois.com/blog/2009/04/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/
16:46:36 <weirdo> gwern, in CL with SLIME you'll get erroneous expression *underlined*
16:46:43 <weirdo> with a tooltip specifying the error
16:46:45 <dons> it talks about how we use the type system to enforce interesting design decisions automatically.
16:46:47 <tehgeekmeister> MyCatVerbs: i'm embedding writer in state, sorry for the ambiguity
16:46:59 <horms> hi dons
16:47:08 <dons> heya horms
16:47:26 <MyCatVerbs> tehgeekmeister: Oh, I didn't mean that what you're saying is ambiguous, sorry. I meant it was ambiguous as to whether it was a good situation or not. :)
16:47:33 <Makoryu> weirdo: IDE support still has yet to mature to that degree, sadly
16:47:53 <Peaker> MyCatVerbs: not an oracle, perhaps just a more restrictive type system
16:48:03 <weirdo> Makoryu, can i at least compile a defun with one keypress/
16:48:17 <Peaker> weirdo: QuickCheck is a nice example of how the type system can write code for you
16:48:31 <Peaker> weirdo: there's a nice video talk by Simon Peyton Jones about why Haskell is nice
16:48:31 <weirdo> is the type system turing complete?
16:48:34 <Makoryu> weirdo: There's probably such a setup, though I wouldn't know what it is :p
16:48:54 <tehgeekmeister> MyCatVerbs: mm, yeah.  hopefully i'll see the light soon.  combining laziness and monads is a sure path to confusion
16:48:57 <weirdo> Makoryu, it's when you type a function, then press one key and it gets executed in the haskell "interpreter"
16:49:05 <Peaker> weirdo: another nice factor is that purity makes the types of many functions tell the whole story (or almost the whole story). Combine their types with some sensible expectations of their behavior and you know what they do, without worrying about whether they mutate something or such
16:49:11 <Makoryu> weirdo: Yes, I understand what you were asking.
16:49:14 <Peaker> @type Data.Map.union
16:49:15 <lambdabot> forall k a. (Ord k) => M.Map k a -> M.Map k a -> M.Map k a
16:49:19 <Peaker> @type Data.Map.unionWith
16:49:20 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
16:49:26 <Peaker> @type Data.Map.intersectWith
16:49:26 <lambdabot> Not in scope: `Data.Map.intersectWith'
16:49:29 <gwern> with extensions, yeah
16:49:29 <Peaker> @type Data.Map.intersect
16:49:30 <lambdabot> Not in scope: `Data.Map.intersect'
16:50:08 <Peaker> @type Data.Map.intersectionWith
16:50:09 <lambdabot> forall a b c k. (Ord k) => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
16:50:16 <Peaker> weirdo: look at the type of this function, for example
16:50:23 <weirdo> cat's warmth makes it hard to concenrate. i'll try harder
16:50:34 <Axman6> meww
16:50:34 <Peaker> weirdo: its really great documentation of what the function does - and guarantees quite a lot about it
16:50:47 <weirdo> what does "forall" mean? a sequence with every element satisfying the type?
16:50:49 <Makoryu> weirdo: I've never seen a plug-in that can send definitions to the interpreter function-by-function... The more usual way is to reload your working .hs file
16:51:10 <weirdo> Makoryu, but a recompile cycle breaks short-term memory
16:51:32 <Peaker> weirdo: basically means that a b c and k are type variables that can be anything (k has to be comparable for order)
16:51:54 <weirdo> and now with IM, RSS and the like people have short attention spans
16:52:06 <weirdo> Peaker, and it uses unification, right?
16:52:11 <weirdo> i wrote a pattern matcher in CL
16:52:13 <Saizan_> weirdo: loading a file in ghci is quite fast
16:52:18 <Peaker> weirdo: HM does
16:53:11 <Peaker> weirdo: so for any a,b,c,k types such that k is Ordinal (its values are ordered), the function can take a function of a and b to c, and maps from k to a and b, and produce a map from k to c.. the types tell the whole story (no way you can make a "c" without both "a" and "b" so it has to be an intersection or less, but it wouldn't be sensible to for it to be less (arbitrarily throw away dict items)
16:53:35 <gwern> weirdo: also, compiling just a defun may be bad; the PLT folks specifically got rid of exactly that functionality; compiling/loading a buffer is perfectly possibly (jst write out to file and tell ghci :reload) but dependent on what you're using
16:53:36 <Peaker> weirdo: you also know for *sure* that this function doesn't mutate anything
16:53:40 <Makoryu> weirdo: Haskell's compile times are much better than C++ or Java :p And don't most CL implementations compile functions immediately, too?
16:54:07 <Makoryu> weirdo: I know SBCL compiles everything right away, if possible
16:54:58 <weirdo> Makoryu, in Lisp, the compiler doesn't quit when it produces a program. it doesn't compile to a file, but to memory
16:55:18 <weirdo> lisp programs don't run in separate processes; they run in separate threads in the same image
16:55:21 <Peaker> weirdo: a simple example:   const :: a -> b -> a        the only way for const to return an "a" is to use its first argument (because "a" can be any type, and you can't generate values of any type, but you can pass them on/return ones given to you)
16:55:22 <Cale> > (&&)
16:55:22 <lambdabot>   {True->{True->True;False->False};False->{True->False;False->False}}
16:55:27 <Makoryu> weirdo: I know. If you're running a ghci process, you can load a file in it and it will compile it to memory
16:55:47 <Peaker> Cale: is that new?
16:55:54 <Cale> Well, sort of.
16:56:09 <Cale> In that there's no overlapping instances error anymore.
16:56:15 <Cale> > print "hello"
16:56:16 <lambdabot>   <IO ()>
16:56:22 <Cale> and we still get IO printing.
16:56:24 <Peaker> Cale: an instance of (Bounded a, Enum a) => Show (a->)?
16:56:27 <Saizan_> > putStrLn
16:56:28 <lambdabot>   ""->
16:56:28 <lambdabot>    <IO ()>
16:56:28 <lambdabot>  "a"->
16:56:28 <lambdabot>    <IO ()>
16:56:28 <lambdabot>  "aa"->
16:56:30 <lambdabot> [4 @more lines]
16:56:33 <Cale> Not Bounded
16:56:39 <Cale> I think it's from SmallCheck
16:56:50 <Saizan_> what was that?
16:56:53 <Peaker> @src Enum
16:56:53 <Cale> Or maybe QuickCheck
16:56:54 <lambdabot> class  Enum a   where
16:56:54 <lambdabot>     succ                     :: a -> a
16:56:54 <lambdabot>     pred                     :: a -> a
16:56:54 <lambdabot>     toEnum                   :: Int -> a
16:56:54 <lambdabot>     fromEnum                 :: a -> Int
16:56:56 <lambdabot> [3 @more lines]
16:57:05 <Peaker> oh, toEnum 0  gives you an arbitrary starting point
16:57:06 <c_wraith> @more
16:57:06 <lambdabot>     enumFrom                 :: a -> [a]
16:57:06 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
16:57:06 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
16:57:14 <Cale> Not sure it needs Enum either
16:57:21 <Peaker> Cale: how does it enumerate inputs?
16:57:31 <Veinor> Why does haskell like punctuation operators so much>?
16:57:35 <Saizan_> Peaker: the SmallCheck class
16:57:48 <c_wraith> Veinor: a quirk of the syntax it uses, I think.
16:57:59 <Cale> Veinor: Infix operators are concise for certain things.
16:58:11 <Cale> Veinor: and often more readable than textual names
16:58:18 <Veinor> I mean, I'm half-expecting anime operators
16:58:22 <Cale> Imagine if every (.) was written as compose
16:58:31 <Peaker> @src SmallCheck
16:58:31 <lambdabot> Source not found. Are you on drugs?
16:58:36 <Cale> heh
16:58:37 <Peaker> hey, how did lambdabot know?
16:58:53 <gwern> Veinor: we have a few emoticons scattered around libraries...
16:59:00 * dons remembers how controversial the insults were when i added them.
16:59:03 <gwern> @quote monk
16:59:03 <lambdabot> bakert says: haskell is so weird.  you just monkey around with types until the program writes itself.
16:59:13 <Veinor> such as?
16:59:34 <Saizan_> @quote monkey
16:59:34 <lambdabot> mmorrow says: in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
16:59:45 <weirdo> --with-ghc doesn't work; i had to change PATH
16:59:48 <Cale> (^-^) is a good name for vector subtraction :)
16:59:56 <Veinor> Oh god.
17:00:14 <Veinor> Now we just need a \^-^/
17:00:31 <tehgeekmeister> and =^_^=
17:00:44 <Cale> It's unfortunate, but _ isn't allowed in infix operators
17:00:50 <weirdo> hmm haskell has user-definable infix operators?
17:00:55 <Makoryu> weirdo: Yep
17:00:56 <Cale> Somehow it's considered alphabetical.
17:01:04 <weirdo> are their names interned at readtime or at compile-time?
17:01:05 <Veinor> Cale: _ is usually an alphanumeric
17:01:20 <gwern> well, ^_^ is iirc valid, and I think I've seen it around
17:01:22 <c_wraith> > let (=^-^=) = (+) in 5 =^-^= 7
17:01:22 <tehgeekmeister> Cale: what shortsighted design!  couldn't they have figured on us wanting emoticon infix operators?!
17:01:22 <Cale> Yeah, since_some_oddballs_like_to_name_things_like_this
17:01:22 <lambdabot>   12
17:01:25 <gwern> Veinor: and we have all sorts of funny pointless expressions archived on the wiki
17:01:27 <gwern> like the monkey, which went like... (:): ?
17:01:46 <Veinor> I want to be able to write ^_^ x
17:01:46 <Cale> (:[])
17:01:49 <Veinor> for whether x is a happy number
17:01:51 <gwern> (how did the monkey operator go? I'm sure that's not right)
17:01:58 <weirdo> oh, and does haskell allow hyphens in variable names and why not?
17:02:00 <Cale> (:[]) is the robot monkey
17:02:11 <Cale> weirdo: It doesn't because that's subtraction.
17:02:17 <aavogt> @type (   (:):  )
17:02:18 <lambdabot> forall a. [a -> [a] -> [a]] -> [a -> [a] -> [a]]
17:02:18 <Makoryu> weirdo: Haskell allows apostrophes, but not hyphens
17:02:25 <tehgeekmeister> i <3 #haskell
17:02:28 <c_wraith> Well.  because it's an infix character, not an identifier character
17:02:34 <weirdo> Cale, substraction could use explicit whitespace
17:02:35 <gwern> Cale: ah, thanks
17:02:37 <Makoryu> > let isn't_this_cool = 5 in "yep"
17:02:38 <lambdabot>   "yep"
17:02:39 <Veinor> (:[]) wraps its argument in a list
17:02:48 <gwern> @quote happy.monkey
17:02:48 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
17:02:58 <Cale> weirdo: This is true. Some operator symbols are a bit awkward to put whitespace around... particularly ^
17:02:59 <weirdo> i think i'll swap _ and - in haskell-mode
17:03:23 <weirdo> i just hope it isn't community style to use camel case
17:03:23 <Cale> weirdo: But forcing infix operators to have whitespace would certainly open up the naming possibilities.
17:03:24 <Peaker> Cale: I_think_this_is_more_readable thanThisWhichIsLessReadable
17:03:31 <Makoryu> weirdo: You'll probably type - at least as often as _
17:03:38 <Cale> Peaker: I like camelCase better.
17:03:39 <Peaker> but I still stick to theHaskellConvention
17:03:54 <weirdo> Makoryu, i like long, descriptive names. that way i don't have to write every documentation
17:03:58 <Cale> hyphens-are-okay-though
17:04:03 <Peaker> Cale: even though its a bit less readable (when you have a lot of words in a name, at least)
17:04:10 <Cale> I just don't like underscores.
17:04:13 <Veinor> I like theHaskellConvention because it's consistent for one-word names
17:04:14 <weirdo> s/every/any
17:04:16 <Peaker> Cale: why?
17:04:26 <Makoryu> weirdo: FWIW, types are a huge part of the documentation in Haskell :p
17:04:31 <Cale> I just think they're typographically ugly.
17:04:54 <weirdo> eh haskell-platform says something about editline, how do i install it?
17:04:56 <weirdo> because it like, failed compiling
17:05:13 <weirdo> i dimly recall something about cabal
17:05:18 <Cale> For some odd reason they remind me a bit of the slugs that TeX places in your margins when you overfill a line and it can't hyphenate. :)
17:05:23 <gwern> @quote love.operator
17:05:23 <lambdabot> monochrom says: (<3) is the Haskell love operator :)
17:05:25 <Makoryu> weirdo: Editline is the BSD version of Readline
17:05:47 <weirdo> how great someone got rid of GPL pestilence
17:05:55 <Makoryu> Hahaha
17:05:59 <Cale> Editline is also a complete piece of garbage and I'm not sure why the Haskell platform would need it, since we have Haskeline now.
17:06:11 <c_wraith> yeah...  editline was crap.
17:06:18 <Makoryu> Cale: It was only very recently that we switched to Haskeline
17:06:23 <Peaker> weirdo: I like the GPL plague :)
17:06:31 <Cale> Well, yeah, but it's GHC 6.10.4 that's in there, isn't it?
17:06:46 <Cale> It was only 6.10.1 and 6.10.2 which used editline.
17:07:15 <Saizan_> maybe they didn't update the configure script, or some other lib picked up a dep on editline in the meantime
17:07:33 <c_wraith> if he's installing platform, it should be self-contained, I thought
17:07:50 <c_wraith> or at least, the required versions should be locked down
17:08:12 <Saizan_> yeah, some other lib distributed in the platform i meant
17:15:54 <tehgeekmeister> apparently hlint sometimes gives illegal advice
17:16:55 * aavogt says: but officer, hlint _told_ me to!
17:17:12 <weirdo> crap, this libeditline won't even cleanly compile on gcc 4.4.1
17:18:01 <dcoutts> editline is awful
17:18:08 <tehgeekmeister> aavogt: i trusted it blindly, made all the suggested changes in batch, and am now correcting the ones where it was wrong.
17:18:43 <tehgeekmeister> it seems like the eta reduction tips were all wrong
17:19:06 <aavogt> tehgeekmeister: I think it should be a bug if the suggestions aren't valid haskell
17:19:21 <tehgeekmeister> agreed
17:19:21 <weirdo> and you said i don't have to know match to write interesting purely-functional programs
17:19:25 <Makoryu> <hlint> Picking the lock at the IRS office is a good way to get a tax break!
17:19:25 <weirdo> s/match/math
17:19:35 <weirdo> i wrote a couple of lisp programs and none of them were interesting
17:19:51 <tehgeekmeister> weirdo: you don't NEED to, but it will be very useful, i suspect.
17:20:00 <tehgeekmeister> but it'll be useful in any other language, too.
17:20:17 <weirdo> yes. it's one thing to know how to program, and another how to write programs
17:20:54 <weirdo> i tried reading a calculus book but then it talks about proofs, and i don't know anything about proofs, or induction
17:20:57 <weirdo> blame polish education system
17:21:13 <weirdo> math in schools is more like trainin dogs
17:21:18 <weirdo> repeating the same thing ad nauseam
17:22:44 <tehgeekmeister> weirdo: it is not different ehre
17:22:50 <tehgeekmeister> (here being the us)
17:22:52 <Veinor> @yow
17:22:52 <lambdabot> Couldn't find fortune file
17:22:55 <Veinor> :(
17:26:35 <weirdo> got any ideas on how to learn math properly? i assume it is starting with set theory and working way up to simple arithmetic after a few years
17:26:38 <weirdo> and finally proving that 1 + 2 = 3
17:26:42 <tehgeekmeister> weirdo: fwiw, i found that between asking questions in #math, and brute force, i was able to teach myself most of calculus.  and i am by no means an outstanding student of math -- i failed four years in school.
17:26:55 <tehgeekmeister> weirdo: nonono!  don't do that!
17:27:01 <tehgeekmeister> you will drive yourself insane.
17:27:11 <tehgeekmeister> calculus and abstract algebra are good places to start.
17:27:16 <tehgeekmeister> linear algebra is boring, but useful.
17:27:30 <tehgeekmeister> get three or four texts on each, read until you don't understand something, look it up
17:27:32 <tehgeekmeister> repeat
17:27:34 <weirdo> people on #math flamed me and refused to answer my question because i didn't know the different between computability, np-completeness and decidability
17:27:38 <tehgeekmeister> if you can't look it up, ask
17:28:19 <weirdo> wikipedia math articles assume that people know the answer already
17:28:25 <weirdo> there should be some tooltip for every single symbol
17:28:35 <Cale> weirdo: Get Michael Spivak's book "Calculus" (not the same as Calculus on Manifolds by the same author, though that's a good one afterward)
17:28:37 <tehgeekmeister> #math can be unpredictable, but i've found that with some perserverance they have been helpful.  by far mathematician friends have been more helpful.
17:29:02 <tehgeekmeister> weirdo: there is a table of mathematical symbols in wikipedia, albeit not exhaustive
17:29:12 <weirdo> Cale, i already have that book, but it talks about proofs at the end of the first chapter and i don't know how to prove anything, even explicitly given eleven or so axioms for arithmetic
17:29:14 <Cale> weirdo: It starts from the basic properties of the real numbers (there's a construction of the real numbers in terms of sets of rationals in an appendix)
17:29:34 <Cale> weirdo: Well, if you'd like some help with the exercises, you can ask me :)
17:29:52 <weirdo> Cale, great, thank you! :-)
17:30:33 <c_wraith> Don't ask me.  I'll start ranting about how "real" numbers are fake. :)
17:30:42 <c_wraith> Or at least ~100% of them. :)
17:30:44 <Cale> Basically, you want to write down a sequence of statements each of which is either one of the things you're assuming (either an axiom or a condition of the thing you're trying to prove), or it follows from the previous things you've written down according to logic.
17:30:57 <weirdo> i hate it how configure scripts and the like don't provide a URL to the missing library
17:31:11 <weirdo> i tried two versions of libedit(line) before finding the correct one
17:31:21 <Cale> c_wraith: You just have too restrictive a definition of what it means for something to exist :)
17:31:48 <Cale> Anything we can imagine can exist if we want it to.
17:31:49 <weirdo> Cale, it's like philosophical arguments with premises?
17:31:55 <weirdo> not that i know anything about philosophy
17:32:07 <Cale> weirdo: Well, in philosophy they try to be logical anyway ;)
17:32:15 <Cale> weirdo: So yeah, to that extent :)
17:32:19 <weirdo> in philosophy they try to be polysyllabic
17:32:42 <weirdo> (see marx for example)
17:32:55 <Cale> weirdo: Did you at least get problem 1.i.?
17:33:04 <weirdo> hold on. i'll open the ebook
17:33:09 <c_wraith> I have this strange limiter that makes me automatically disregard things that can't have a physical basis, even given (countably) infinite time and energy.  Personal flaw. :)
17:33:15 <Cale> If ax = a for some number a /= 0, then x = 1.
17:33:19 <jfredett>  anyone care to help me with a TH error or two? :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9383#a9383
17:33:19 <lambdabot> jfredett: You have 1 new message. '/msg lambdabot @messages' to read it.
17:33:35 <weirdo> things have to be consistent if they are to exist
17:33:48 <djahandarie> I'm taking Calc 1 right now
17:33:54 <jfredett> silly \bot, I've already read that message
17:33:56 <djahandarie> I like my teacher, he's pretty clear
17:33:56 <weirdo> for instance, there can't be a cat that always meows and never meows at the same time
17:33:57 <jfredett> Calc 1 was fun.
17:34:17 <jfredett> weirdo: what if we put him in a box?
17:34:18 <Cale> weirdo: Well, you can take that approach, but you could also say that inconsistent systems are fine, they're just boring with regard to the truth of results.
17:34:35 <djahandarie> I'm terrible at all that factoring stuff though so that's probably going to own me on the tests. >_>
17:34:35 <Cale> weirdo: Because you already know that every statement is true and false.
17:34:35 <anonym> jfredett: you just can say if the cat is meowing or not
17:34:44 <djahandarie> The Calculus part about it is interesting though. :P
17:35:12 <jfredett> djahandarie: the algebra (at least, the algebra involved with calc) just requires alot of practice.
17:35:18 <anonym> so ternary logic incoming :)
17:35:23 * djahandarie is not very good at practicing things
17:35:34 <jfredett> djahandarie: I was never much good at the calc, but always pretty good at the algebra.
17:35:40 <tehgeekmeister> weirdo: it is hard doing your first few proofs, but do stick it thru, after you've done your first few you'll have found it well worthwhile.  =D
17:35:42 <aconbere> The difficulty in teaching oneself proofs is always the difficult in asserting the correctness of your proof to yourself.
17:35:53 <djahandarie> The calculus is straight up common sense to me...
17:35:59 <djahandarie> Algebra is like impossible though. T_T
17:36:06 <aconbere> it helps to have some friends that are either doing it with you, or are already aquainted with the material.
17:36:10 <jfredett> aconbere: thats why you do it all in Coq. :)
17:36:12 <tehgeekmeister> it's also useful to look at a few really elegant, simple, proofs
17:36:24 <anonym> come on, algebra is fun :>
17:36:26 <tehgeekmeister> like euclid's proof of the infinity of the primes
17:36:27 <djahandarie> Our teacher says to work backwards from the conclusion of the proof
17:36:35 <jfredett> djahandarie: I'm just the opposite, you'll love Analysis and Topology (if you ever get to it).
17:36:51 <djahandarie> jfredett, nah, not a Math major, so I don't think I'll be doing that
17:37:07 <jfredett> djahandarie: it's worth doing, if you can fit it in.
17:37:13 <jfredett> Analysis will blow your mind.
17:37:23 <djahandarie> Kinda like how Haskell did? ;p
17:37:38 <jfredett> and Topo has categories and functors in it. :)
17:37:50 <jfredett> at least, thats what my book advertises. :)
17:38:17 <jfredett> if I understand it all, CT came out of Topology, so -- yah.
17:38:26 <Cale_> ugh
17:38:42 <Cale> sorry about that
17:38:47 <djahandarie> Category theory?
17:38:48 <Cale> I missed everything since <anonym> jfredett: you just can say if the cat is meowing or not
17:39:10 <jfredett> djahandarie: the stuff that makes Haskell so awesome...
17:39:13 <weirdo> Cale, sorry, i don't know even how to prove 1.i. i think it comes from the premise that "1 Â· x = x" and law of excluded middle
17:39:24 <djahandarie> jfredett, I was just confirming that's what you were talking about
17:39:26 <jfredett> it's the power behind it's type system. more or less
17:39:29 <Cale> weirdo: start with P7 before P6
17:39:42 <jfredett> djahandarie: then yes, thats what I meant
17:40:01 <Cale> weirdo: Since a is not 0, P7 tells us that there is a number a^-1 such that a^-1 * a = 1
17:40:06 <djahandarie> I've read a bit about all the different Math stuff, enough to know what most of it is... I can't really go deep in because I always trip up on random symbols and shit I don't know. :P
17:40:09 <tehgeekmeister> anyone have tips for trying to figure out how your own code works?  the code was a mess when i left it, and it wasn't commented at all.  it does SOMETHING, but certainly not what it should.
17:40:35 <djahandarie> Haskell was easy in the sense that it wasn't hard to find out stuff about it really
17:40:40 <Cale> weirdo: If we multiply both sides of the equation by a^-1, we get that a^-1 (a x) = a^-1 a
17:40:49 <defun> In prelude, here is the definition for the acos function: (acosFloat   (F# x) = F# (acosFloat# x)). What is F#, etc?
17:40:50 <weirdo> it's too bad automatical proof writing software leads to combinatorial explosion
17:40:59 <weirdo> but at least it's in NP
17:41:07 <defun> or rather the def for acosFloat.
17:41:08 <Cale> On the right hand side, we already know that a^-1 a = 1
17:41:16 <djahandarie> I seriously need to learn LaTeX though
17:41:17 <anonym> but you haven't proofed P != NP ;)
17:41:19 <lament> unboxed float?
17:41:31 <anonym> uargs
17:41:38 <anonym> provend
17:41:39 <Cale> On the left hand side, we can use P5 (associativity of multiplication) to say that a^-1 (a x) = (a^-1 a) x
17:41:42 <weirdo> Cale, wow, this is clever
17:41:49 <jfredett> djahandarie: most math is kindof like haskell. Way confusing at first, then it just becomes "Oh my god my life is totally changed"
17:41:55 <jfredett> djahandarie: LaTeX is easy.
17:41:57 <Cale> but then (a^-1 a) x = 1 * x
17:42:06 <Cale> and 1 * x = x because of P6
17:42:06 <lament> jfredett: sounds more like psychedelic drugs really
17:42:15 <anonym> *proven for gods sake
17:42:22 <weirdo> Cale, this is like algebra in school, except that in algebra they only used two methods of finding out the result
17:42:27 <jfredett> lament: Math _is_ a psychedelic drug. :)
17:42:32 <djahandarie> jfredett, well, I don't know LaTeX well enough to take notes with it as fast as I could with a pencil
17:42:36 <djahandarie> Which is what I want to do
17:42:38 <weirdo> making a horizontal line and a plus to the right, and then summing up the values
17:42:40 <Cale> weirdo: It's just a refinement of what you did in highschool.
17:42:44 <anonym> djahandarie: practice ;)
17:42:52 <jfredett> djahandarie: honestly, taking notes in LaTeX isn't worth it...
17:42:52 <Cale> weirdo: You would divide both sides by a, right?
17:42:53 * djahandarie is not very good at practicing things
17:42:59 <Cale> (or 'cancel' the a)
17:43:01 <weirdo> i don't know what was the purpose of what i did in both high- and grammar school
17:43:06 <djahandarie> jfredett, I'll get it eventually. D:
17:43:13 <anonym> so practice practicing
17:43:16 <weirdo> it certainly wasn't to further my understanding of math
17:43:23 <jfredett> I tried to do so, but it turns out it's just way easier to transcribe ex-post homework-o.
17:43:45 <weirdo> Cale, i'd do that all over again, instead of writing an algorithm that did it for all defined values
17:43:56 <weirdo> which would be more interesting, especially on my very own
17:44:04 <weirdo> because in school, they hate original thought
17:44:14 <Cale> ii. mostly uses the distributive law
17:44:22 <Cale> (P9)
17:44:36 <Cale> and one instance of commutativity, as you'll see
17:44:39 <chessguy> 'evening ya'all
17:44:59 <weirdo> distributive law, they actually split that in two cases in school
17:45:09 <kmc> jfredett, i disagree because i've found that {drugs, math, cardboard} is a good orthogonal basis for most things
17:45:27 <weirdo> one with plus and one with minus, because dogs (we) didn't know that substraction can be defined in terms of addition and vice versa
17:45:34 <Cale> ah :)
17:45:35 <kmc> the strengths of haskell lie chiefly in its relative lack of cardboard
17:45:41 <Cale> The other way to split it in two is:
17:45:51 <jfredett> kmc... cardboard? hmm.
17:45:54 <Cale> a (b + c) = ab + ac and (a + b) c = ac + bc
17:46:09 <jfredett> so- 3d + 2m - 6c = ?
17:46:34 <Cale> (which becomes important in cases where you don't have commutativity of multiplication)
17:46:41 <Cale> (like with matrices)
17:46:54 <kmc> tehgeekmeister, the code you're trying to reverse-engineer is in haskell?
17:47:05 <tehgeekmeister> kmc: yes, and i wrote it.
17:47:20 <kmc> :)
17:47:25 <tehgeekmeister> when i was not nearly as clear minded as i am now.
17:47:28 <kmc> start by writing down the type of everything
17:47:28 <tehgeekmeister> or something.
17:47:44 <Cale> For problem iii, you use problem ii and the result on page 6 (in the third edition at least), that if ab = 0, then either a = 0 or b = 0.
17:47:46 <kmc> actually ghc -Wall will tell you the inferred types of all top-level binds
17:48:19 <defun> weirdo: everything from algebra can be defined in terms of addition. I.e. 4-2 = 4+-2, 2*6 = 6+6, 6/2 = 6*1/2 = 1/2+1/2+1/2+1/2+1/2+1/2. But you probably knew that :)
17:48:40 <kmc> defun, addition and iteration perhaps
17:48:47 <jfredett> weirdo: whats 2<pi> then?
17:48:49 <kmc> but you don't get abstract rings that way
17:48:49 <jfredett> :)
17:48:50 <wdonnelly> defun: how do you do 1/2 * 1/2?
17:49:02 <weirdo> defun, but i consider 1/2 application of division instead of an atom
17:49:04 <weirdo> same for -42
17:49:11 <kmc> for that matter, addition is iterated succession
17:49:14 <jfredett> sorry, that was for defun.
17:49:17 <weirdo> that's (-) 42
17:49:48 <defun> Well, not in all cases, but definately for addition and iteration.
17:49:52 <Cale> Not everything comes from addition alone... multiplication of two numbers which are not integers can't be expressed entirely as an addition
17:50:01 <Makoryu> :t (-)
17:50:02 <lambdabot> forall a. (Num a) => a -> a -> a
17:50:04 <defun> Cale: ah, yes.
17:50:09 <jfredett> defun: i suppose more accurately you can describe most simple things in the integers with iterated addition. :)
17:50:18 <weirdo> wait, what? it wants zlib 0.5?
17:50:21 <Philonous> Not as an addition of whole numbers at least
17:50:24 <Draconx> defun, complex multiplication is not defined by successive addition, for example.
17:50:26 <Cale> and irrational numbers like sqrt(2) are inaccessible that way
17:50:30 <weirdo> i have 1.2.3
17:50:37 <jfredett> so- in the ring of integers, with the standard defns of plus and times, times is iterated addition
17:50:43 <tehgeekmeister> kmc: nice, thank you
17:50:46 <Cale> (even with addition and multiplication, you can't get at sqrt(2) directly.
17:50:47 <Cale> )
17:50:48 <tehgeekmeister> that is a good place to start
17:51:03 <weirdo> does it fail so badly because i have ghc installed in /tmp rather than /usr/local?
17:51:13 <tehgeekmeister> i plan on writing quickcheck tests, but the functions i'm trying to test are so complicated i'm not sure they're a good place to start with learning quickcheck
17:51:23 <weirdo> the only thing i did was setting PATH for the compiler, because --with-ghc and friends erred out on me
17:52:01 <Cale> You can ask for "the number x such that x^2 = 2 and x > 0", but how do you know that such a number should exist? You need something more than the basic properties of arithmetic.
17:52:35 <jfredett> Cale: Yay for Q[x]/x^2 - 2 !
17:52:41 <defun> Got it.
17:52:51 <Cale> You could add something like this to your assumptions about what numbers there are, but then you miss out all sorts of other numbers.
17:52:53 <defun> #haskell is better than school.
17:53:05 <Cale> Like, for instance, sqrt(3).
17:53:17 <defun> > sqrt 3
17:53:18 <lambdabot>   1.7320508075688772
17:53:22 <tehgeekmeister> kmc: ghc -Wall did not tell me the inferred types
17:53:22 <Cale> and even if you add all square roots, then general nth roots are inaccessible
17:53:56 <Cale> and even with all nth roots, there are polynomials whose roots you won't be able to find, despite the fact that they are positive for some numbers and negative for others.
17:54:10 <aconbere> man I cannot figure out why VTY is adding two extra lines to my image
17:54:10 <Cale> Clearly, something more general is needed.
17:54:11 <aconbere> :-/
17:54:13 <weirdo> i never learned where do irrational real numbers come from, and how to compute their nth digit
17:54:32 <weirdo> i mean, there's pi, e (which i never learned about), sqrt 2
17:54:50 <djahandarie> Speaking of LaTeX, what do you guys use for LaTeX in Linux?
17:55:08 <jfredett> Cale: I think I heard about this. Field of Fractions or some such. I dunno, I've only just gotten to ideals in Alg...
17:55:14 <weirdo> i don't know latex, but debian has something called 'texlive'
17:55:27 <Cale> The property which completes the real numbers isn't in that first chapter of Spivak, you'll find it a bit later on as P13. Any nonempty set of numbers which is bounded above, has a least upper bound.
17:55:34 <aconbere> djahandarie: I just use latex... is that unusual?
17:55:42 <aconbere> djahandarie: pdftex if I want pdfs
17:56:11 <Draconx> weirdo, re: computing their nth digit: almost every irrational number is not computable.
17:56:44 <Cale> If S is any set of numbers, then an upper bound for S is a number x such that for any s in S, we have that s <= x.
17:57:08 <Cale> A least upper bound is an upper bound x so that if y is any other upper bound, then x <= y.
17:57:34 <kmc> tehgeekmeister, sorry :/
17:57:55 <jfredett> Cale: Ah! I'm flashing back to analysis... The Suprema! Tell them, Tell everybody, THE UPPER BOUNDS IS SUPREMUM!
17:58:00 <Cale> This property might seem a bit technical at first, but it's what eventually gives us all these fancy numbers like sqrt(2), pi, e, and all the others.
17:58:04 <tehgeekmeister> kmc: it's okay, just checking to see if you knew another way.  if not i'll figure it out fine on my own.  thanks for your help.
17:58:21 <Cale> Yeah, supremum is another term for least upper bound.
17:58:35 <jfredett> Bound, actually, but the soylent green reference was hard to shove in there...
17:59:34 <Cale> The set of rational numbers q such that q^2 < 2 is nonempty, since, for instance, 1 is in that set
17:59:53 <Baconizer> After compiling the Haskell Platform with the binary GHC distribution on openSUSE 11.1, i686, it won't install with 'sudo make install': 'The mtl-1.1.0.2/Setup script does not exist or cannot be run'
17:59:55 <kmc> tehgeekmeister, i would load it in ghci and ask it for types
17:59:57 <Philonous> Suppose you have a function limit' of a sequence a_n given as the limit of the sequence (Sum from 1 to n a_n )/n, i.e. you take the arithmetic mean of the first n members, that would suffice to build the real numbers from 1, -1 and +
18:00:04 <tehgeekmeister> kmc: okay.  =]
18:00:17 <kmc> also, what ghc are you using? i'm pretty sure 6.10.4 gives the types with -Wall.  maybe you should make everything exported first
18:00:32 <Cale> and it's bounded above, since, for instance, if q > 2, then q^2 > 4 > 2
18:00:43 <Veinor> Ooh, what're we talking about now?
18:01:19 <Baconizer> http://pastebin.com/mfda7485 <- here's the entire output of 'sudo make install'
18:01:23 <Cale> So that set of numbers must, according to our assumption, have a least upper bound. That number will turn out to be the square root of 2.
18:03:28 <Veinor> Ah, construction of real numbers.
18:05:36 <kmc> pay no attention to the ridiculous infinite structures behind the curtain
18:05:42 <tehgeekmeister> kmc: i'm using 6.10.1
18:06:18 <Cale> Nothing ridiculous here, it's all perfectly consistent.
18:06:36 <Cale> (unless you can find me a contradiction ;)
18:06:56 <weirdo> sorry for not responding, i simply don't know what to say
18:07:34 <Cale> weirdo: That's all right. Would you like to do some more of the problems? We can take this to PM if people prefer.
18:07:49 <Cale> weirdo: I was jumping ahead a good bit there.
18:08:28 <jfredett> Cale: is he doing Real Analysis (I assume as much as that looks like the beginning of my RA course... )
18:08:28 <jfredett> ?
18:08:48 <tehgeekmeister> Cale: is there a book you recommend for analysis/topology, for self study?  i attempted rudin and, well.  that was a bad idea.  to say the least.  =P
18:08:52 <Cale> jfredett: He has a copy of Spivak's Calculus
18:09:30 <jfredett> tehgeekmeister: I'm using Intro to Topo by Mendelson (I hope thats how it's spelt) it's lovely. Pretty readable.
18:09:40 <tehgeekmeister> jfredett: gracias
18:09:50 <Cale> tehgeekmeister: hmm... I never had an assigned textbook for my courses on it. However, depending on the stuff you're interested in, Ziemer's "Modern Real Analysis" is free online and really good at what it does.
18:09:53 <jfredett> There's another from the "Saunders series" I don't remember the name/authors..
18:09:55 <weirdo> Cale, i need to work on my attention span. IM and RSS has ruined it
18:10:02 <Cale> Mostly toward measure theory though
18:10:10 <weirdo> Cale, i also need to quit smoking. it makes me sleep every two days, which makes me out of order for half of awake-time
18:10:12 <tehgeekmeister> Cale: mm. good to know there's a free one!
18:10:51 <weirdo> Cale, i'm having problems with the actual thought process behind proving stuff. because i know "this is obviously right" but can't do anything about it
18:11:09 <Cale> I have a book by Munkres on point-set topology here which looks good.
18:11:32 <khufu> Okay, I have the ghc
18:11:39 <khufu> Wtf do I do with it now?
18:11:55 <weirdo> Cale, someone explained proofs like this: first prove something for n, then for n+2, and then it's true
18:11:59 <tehgeekmeister> Cale: i have been told munkres is good
18:12:01 <jfredett> Mendelson has point set and algebraic, for reference.
18:12:01 <khufu> I have no idea how to work this thing
18:12:03 <weirdo> ugh, n+1
18:12:12 <Cale> tehgeekmeister: another which people recommend is Royden's real analysis.
18:12:16 <jfredett> weirdo: thats just one way, it's called induction
18:12:24 <Cale> khufu: You should get a tutorial :)
18:12:31 <Cale> khufu: But you can start by running ghci
18:12:42 <Cale> and trying some numerical calculations like 2^500
18:12:42 <jfredett> weirdo: it's a bit like dominos- for instance, if I want to prove n < n+1 for all n > 0
18:12:52 <weirdo> jfredett, yes, he used the actual term, "dominoes"
18:12:55 <jfredett> I can start by saying 1 < 2
18:13:00 <khufu> Oh, nice. An interpreter ;)
18:13:13 <jfredett> and then say assume n < n +1, now show n+1 < n+2
18:13:40 <Cale> khufu: I would recommend sticking to ghci for the beginning, as it provides you with a nice little "user interface" for your programs for a while.
18:14:07 <jfredett> by the rules of '<', n + 1 < n + 1 + 1 => n+1<n+2, therefore n < n+1 for all n > 0
18:14:11 <khufu> Yeah
18:14:24 <Cale> khufu: Create a new foo.hs file and place your definitions in that, and then load it into ghci either by passing it as a parameter on your shell commandline, or by using :l foo.hs inside ghci
18:14:30 <jfredett> hence, dominoes. I set the first one up, then all the other ones, then watch them all fall into place. :)
18:14:38 <Cale> khufu: Then, when you update the file, you just :r in ghci to reload
18:14:50 <Cale> khufu: (It's good to keep two windows open)
18:15:17 <Cale> I can prove that mathematical induction works from a more basic thing if you like.
18:15:47 <Cale> The natural numbers have a very special property: any nonempty set of natural numbers has a least element.
18:16:44 <Cale> Note that, for example, the integers (under their standard ordering) don't have that property, because, for instance, if you take the whole set of integers, n-1 is always less than n
18:17:16 <weirdo> isn't minus infinity the least element?
18:17:29 <Cale> There's no number minus infinity
18:17:29 <Philonous> minus infinity is not an integer
18:17:33 <Cale> At least not in the integers.
18:17:36 <ivanm> it's more a concept
18:17:40 <Cale> (and not in the real numbers either)
18:17:52 <ivanm> is it in complex by default?
18:17:56 <Cale> nope
18:18:02 <jfredett> Cale: but it is true that any finite subset of the integers (or the Rationals, IIRC) has a least elt. or and closed interval on the reals?
18:18:06 <Cale> There are systems of numbers with 'infinities' of a sort
18:18:08 * ivanm recalls using infinity in complex numbers, but only in some extended complex set or something...
18:18:10 <jfredett> Well ordering is tricky...
18:18:16 <Cale> Numbers which are larger than any n = 1 + 1 + ... + 1
18:18:40 <Cale> but those have multiple infinities
18:18:49 <Cale> (at least, the ones which are rings do)
18:18:57 <burp> anyone knows of: Integral -> hexadecimal string representation?
18:19:01 <Cale> anyway, that's off-track :)
18:19:10 <ivanm> burp: there's something in Data.Char IIRC
18:19:28 <Cale> jfredett: Any compact interval of reals...
18:19:53 <Cale> jfredett: all of R is a closed interval of reals, and it has no least element.
18:20:07 <jfredett> Cale: ah. Haven't covered compactness yet, explains why I haven't seen that think pop up.
18:20:08 <ivanm> bos: what's the diff between 0.2.1 and 0.2.2 of statistics?
18:20:16 <jfredett> Cale: Oh- that makes sense.
18:20:18 <burp> > digitToInt 'F'
18:20:18 <lambdabot>   15
18:20:20 <burp> just the reverse :|
18:20:28 <ivanm> oh...
18:20:35 <ivanm> @hoogle hex
18:20:35 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
18:20:35 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
18:20:35 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
18:20:35 <Cale> weirdo: anyway...
18:20:38 <bos> ivanm: a bugfix, iirc
18:20:44 <ivanm> *nod*
18:20:47 <ivanm> you don't know? :p
18:21:03 <weirdo> Cale, :-)
18:21:17 <Cale> weirdo: If we have any set S with an ordering <= such that any nonempty subset of S has a least element, we say that S is well-ordered by <=
18:21:28 <vav> @type showHex
18:21:28 <lambdabot> forall a. (Integral a) => a -> String -> String
18:21:31 <Cale> Well-ordered sets are the ones where induction works.
18:21:41 <ivanm> it sometimes might be nice if we could tell lambdabot we don't want @hoogle to look in parsec, etc. and just care about the "standard" libraries (i.e. those that come with ghc)...
18:21:44 <Cale> I will prove it :)
18:21:56 <weirdo> Cale, what do you mean by "ordering"?
18:22:02 <Cale> Ah, good question :)
18:22:06 <vav> burp: showHex is in Numeric
18:22:09 <burp> > showHex 255
18:22:11 <jfredett> Cale: so in compact closed intervals of the reals, I can do induction? Sweet!
18:22:12 <lambdabot>   ""->
18:22:14 <lambdabot>    "ff"
18:22:18 <lambdabot>  "a"->
18:22:20 <lambdabot>    "ffa"
18:22:22 <lambdabot>  "aa"->
18:22:24 <lambdabot> [5 @more lines]
18:22:27 <Cale> jfredett: well... not quite :)
18:22:30 <ski> > showIntAtBase 16 intToDigit 100 ""  -- burp
18:22:30 <lambdabot>   "64"
18:22:33 <Draconx> jfredett, compact closed intervals of the reals are not necessarily well ordered (by the usual ordering)
18:22:51 <Draconx> jfredett, e.g. [0,1] has (0,1) as a subset, which has no least element.
18:22:54 <jfredett> Cale, Draconx: but he just said... :/
18:22:54 <ski> > showIntAtBase 16 intToDigit 255 ""
18:22:55 <lambdabot>   "ff"
18:22:55 <Cale> jfredett: any individual compact closed interval has a least element, but not every subset of it does.
18:22:58 <weirdo> function application is right-associative, right?
18:23:01 <burp> thanks
18:23:04 <jfredett> ah
18:23:09 <ski> weirdo : no, left-associative
18:23:18 <jfredett> nifty.
18:23:20 <aavogt> > \x y -> fromMaybe False $ max x y
18:23:21 <lambdabot>   Nothing->
18:23:21 <lambdabot>    {Nothing->False;Just True->True;Just False->False}
18:23:21 <lambdabot>  Just True-...
18:23:23 <ski> weirdo : `f x y = (f x) y'
18:23:28 <kmc> weirdo, it works so that currying works
18:23:29 <Cale> weirdo: Do you know what a relation is?
18:23:37 <kmc> > f g h x
18:23:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:23:38 <lambdabot>    `SimpleReflect.FromExpr ...
18:23:41 <kmc> :/
18:23:44 <weirdo> Cale, like in RDBMS?
18:23:46 <ski> > showHex 255 ""
18:23:47 <lambdabot>   "ff"
18:23:54 <Cale> weirdo: Well, it's the same thing in the end, but...
18:24:14 <jfredett> okay, time for a haskell question for all those who aren't doing math. I have some TH code that isn't parsing and I have no idea why, relevant stuff here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9383#a9383 -- any help is appreciated.
18:24:23 <burp> :t showHex
18:24:24 <lambdabot> forall a. (Integral a) => a -> String -> String
18:24:40 <Cale> weirdo: Perhaps it would help if we moved to a quieter/more-topical channel :)
18:24:48 <burp> strange thing the string argument
18:24:53 <Cale> In case anyone's listening, maybe #haskell-overflow?
18:25:02 <ski>   showHex :: Integral i => i -> ShowS
18:25:09 <weirdo> Cale, good idea. but the question is, where? either query or you could join #lisp-pl :)
18:25:15 <vav> burp: it's for easy appending of a bunch of them
18:25:18 <ski>   type ShowS = String -> String
18:25:39 <ski> weirdo : #haskell-overflow, maybe ?
18:25:42 <Cale> weirdo: I usually use #haskell-overflow for overflow discussions :)
18:25:47 <weirdo> okay :-)
18:27:25 <jfredett> any TH guru's around? :)
18:27:40 <dolio> jfredett: I don't think 'case s of <>' is a valid place to splice in.
18:27:57 <ivanm> hmmm.... if I have a function f :: (Handle -> IO a), and I want to close the handle as soon as f has finished, what's the best way of doing that?
18:28:12 <jfredett> Hmm, how could I do this then? Should I just construct the AST by hand?
18:28:26 <dolio> jfredett: The case expression at least.
18:28:42 <jfredett> or maybe I can splice in the whoel case expression? (not just the individual cases?
18:28:56 <dolio> Maybe. I've not done a lot of TH.
18:29:06 <jfredett> okay, I'll give that a shot.
18:29:17 <jfredett> thanks.
18:30:11 <kmc> jfredett, what's the type of "cases"?
18:31:08 <jfredett> kmc: good question, let me look.
18:31:33 <jfredett> Clause.
18:32:31 <jfredett> maybe is should be [Clause]? it seems that since the case expression needs the same name as the pattern part, splicing it in won't really work. hrm.
18:32:33 <kmc> so i don't really know TH at all, but aren't splices supposed to evaluate in the Q monad?
18:32:52 <kmc> i don't think clause splices are supported, as dolio said
18:33:11 <jfredett> It's part of the [d| |] business, so it's getting into the Q monad.
18:33:18 <jfredett> I think dolio is right too.
18:33:31 <kmc> ghc manual 7.9.1 says you can splice Q Exp or Q [Dec] only
18:33:39 <Baconizer> :(
18:33:53 <kmc> (and the latter at top level only)
18:34:00 <jfredett> hmm.
18:34:11 <kmc> so yeah, build the whole case in TH
18:34:15 <jfredett> I'll just write it out by hand... it's less confusing. :)
18:35:29 <dolio> That probably means $(name) is invalid, too.
18:35:42 <dolio> Which I suspected might be the case, but I wasn't sure, either.
18:35:45 <kmc> yeah, that looks like a pattern splice
18:36:34 <jfredett> yeh, I wonder why it sprung on $(cases) and not $(name) though... :/
18:38:25 <jfredett> oh, hmm... actually, I might have had the wrong type there...
18:38:45 <jfredett> case s of -- generates the clause stuff.
18:39:03 <khufu> Is there such a thing as CPAN for online Haskell code?
18:39:13 <jfredett> the stuff I'm trying to splice is the matches
18:39:18 <jfredett> khufu: Hackage
18:39:24 <khufu> Cool,
18:39:33 <jfredett> and Cabal is the command line portion.
18:39:39 <aconbere> anyone know about getting HSSDL working on OS X?
18:39:44 <jfredett> look them up on the haskell wiki for more info.
18:40:00 <aconbere> I can find lots of posts about it /not/ working
18:40:05 <aconbere> but very few solutions
18:40:06 <aconbere> :P
18:41:25 <kmc> khufu, the "cabal-install" package will give you the command-line utility "cabal", with which you can e.g. "cabal install uvector"
18:41:41 <kmc> it comes with Haskell Platform too
18:41:54 <khufu> That will install the source code for uvector ?
18:42:02 <jmcarthur> aconbere: the problem is that SDL provides its own main, the intent being that it gets to call your main
18:42:26 <kmc> khufu, it'll install it such that you can import the package into your own code
18:42:31 <jmcarthur> aconbere: my solution has been to write a C wrapper that calls my haskell main
18:42:32 <kmc> import its modules i mean
18:42:38 <jmcarthur> aconbere: and the linker manages okay then
18:42:41 <khufu> Sounds cool ;)
18:43:14 <jmcarthur> aconbere: i think somebody has explained this on the wiki somewhere by now
18:43:34 <jmcarthur> aconbere: although i appear to be wrong about that, now that i did a search
18:43:57 <jmcarthur> aconbere: on os x, you also have to make a .app bundle, or the sdl program won't receive your events properly
18:44:31 <jmcarthur> aconbere: i have some code somewhere, but it is not readily available to me at the moment
18:47:15 <aconbere> jmcarthur: interesting
18:47:27 <aconbere> jmcarthur: I mostly expected using it to be on par with using openGL
18:47:36 <aconbere> but was surprised to instantly run into issues :)
18:48:00 <kmc> what's the best way to get haskell-cafe as an rss feed?
18:48:24 <SamB> kmc: I dunno
18:48:29 <SamB> but one way is through gmane
18:48:33 <ray> cry
18:48:34 <ray> and cry
18:48:42 <ray>    and cry
18:48:53 <SamB> ray: you don't like gmane's rss feeds?
18:48:59 <SamB> I don't like 'em that much either ...
18:49:14 <kmc> trying nabble
18:50:31 <ray> i suppose it's better than mail :)
18:50:46 <ray> mailing lists so terrible
18:51:15 <SamB> the main problem is that people talk too much on them
18:51:20 <SamB> it's impossible to keep up
18:52:17 <ray> often only subscribers can post, so if you want to post you have to subscribe and then set up a rule to delete all the messages from the list, ugh
18:52:25 <ray> nobody should ever have to set up email rules, ever
18:52:42 <dons> kmc: via gmane
18:52:48 <ray> but the best thing you can do is post by mail and check web archives
18:52:49 <SamB> or at least make them skip your inbox
18:52:55 <ivanm> hmmm.... if I have a function f :: (Handle -> IO a), and I want to close the handle as soon as f has finished, what's the best way of doing that?
18:53:18 <dons> ivanm: how would you write 'f'?
18:53:29 <ray> "only let subscribers post" is the worst thing ever
18:53:39 <ivanm> dons: it's a function passed in to another function
18:53:41 <dons> ray: why?
18:53:48 <SamB> ray: well, it's slightly better than usenet ...
18:53:54 <ray> dons: see above
18:54:05 <ray> usenet is for cranks
18:54:11 <dons> ray: subscription is good for building communities
18:54:14 <ivanm> dons: for here: http://hackage.haskell.org/packages/archive/graphviz/2999.5.0.0/doc/html/Data-GraphViz-Commands.html#v%3AgraphvizWithHandle
18:54:19 <dons> anonymity/non-subscriptoin is good for cranks
18:54:22 <SamB> well, I mean, have you *seen* how much spam there is on usenet ?
18:54:34 <ivanm> I know there's a bug there for it, and now I've got users complaining about it... >_>
18:54:43 <SamB> dons: well, it would be nice if it weren't for getting all that email all the time!
18:54:49 <dons> ivanm: yes, why not a withHandle function?
18:54:50 <dons> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
18:54:51 <dons> withFile name mode = bracket (openFile name mode) hClose
18:55:01 <ray> dons: it forces you to manually dispose of the bajillion emails that get sent your way
18:55:11 <inimino> clearly there is a need for a Web-based email optimized for mailing lists for people who can't learn to use a normal email client effectively
18:55:19 <dons> perhaps :)
18:55:24 <ivanm> dons: not sure what you mean by a withHandle function
18:55:25 <ray> zing
18:55:28 <dons> we do have a newbies list, since haskell-cafe got too big
18:55:29 <SamB> inimino: I don't think that's the best approach
18:55:41 <ivanm> dons: s/got/is/ ;-)
18:55:44 <dons> ivanm: ii don't think i understand the question. its too general.
18:56:12 <dons> "bracket open close action" is the pattern for closing resources
18:56:20 <dons> modulo strictness
18:56:38 <ivanm> dons: atm, I'm using "a <- f outp; a `seq` hClose outp" to get the output of f and close the handle
18:57:12 <ivanm> but if a is a String for example, that doesn't (always) work since it just gets to the first (:)
18:57:16 <aavogt> hey, is  runghc Setup haddock --executables --internal --hyperlink-source # supposed to only run hscolour on the Main.hs?
18:57:32 <dons> ivanm: ah!
18:57:33 <dons> rnf
18:57:38 <ivanm> oh, yeah
18:57:40 <ivanm> @hoogle rnf
18:57:40 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
18:57:58 <dons> bracket ..open ... hClose $ do v <- a ; rnf v `seq` return v ; -- or so
18:58:16 <ivanm> @hoogle bracket
18:58:17 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:58:17 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:58:17 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:58:20 <dons> then note in the comments that it is fully strict in the action
18:58:32 <dons> bracket just ensures you will close even if there's an exception
18:58:44 <ivanm> *nod*
18:59:17 <ivanm> I think the biggest problem with that function is that it's a mish-mash of code from what matthew-_ originally had there with my bastard extensions to it...
19:02:36 <ivanm> dons: so leave the whole when to close thing in the "action" argument to bracket?
19:06:09 <dons> with bracket you can decompose it into open ; close; action
19:06:16 <ivanm> right
19:06:24 <dons> so make sure the action does everything you need to be ready to close when you're done
19:06:30 <ivanm> *nod*
19:09:59 <tehgeekmeister> oh dear
19:10:05 <tehgeekmeister> i have ^^ in some code
19:10:09 <tehgeekmeister> instead of ^
19:10:20 <tehgeekmeister> and it didn't cause any errors
19:10:24 <tehgeekmeister> what was it doing all this time?
19:10:37 <kmc> :type (^)
19:10:41 <kmc> :type (^^)
19:10:45 <kmc> :t (^)
19:10:46 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
19:10:46 <kmc> :t (^^)
19:10:47 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
19:11:13 <tehgeekmeister> oh, that's the only difference
19:11:19 <tehgeekmeister> boo.
19:11:22 <tehgeekmeister> thot i'd found my bug.
19:12:01 <mdordal2_> anyone done the build kernel module with haskell thing?
19:17:00 <jonh> mdordal2_: i haven't yet, but the guy who write that typically hangs out in here i believe
19:17:32 <dons> weirdo: did you work out how to get ghc installed in the end?
19:17:42 <mdordal2_> I gathered from his blog. I think one of the permissions for the patches is wrong. :(
19:18:39 <dons> mdordal2_: tommd hangs out here during work hours. he'll be around -- just ask him :)
19:19:04 <mdordal2_> dons: thanks. i'll try that
19:19:06 <ivanm> dons: so he hangs around in a semi-social forum during _work hours_?
19:19:09 <ivanm> hmmm...
19:19:10 <ivanm> ;-)
19:19:16 <dons> well, he's a grad student
19:19:19 <dons> so that's required
19:19:20 <sereven> too bad tommd doesn't go by housemd instead.
19:19:23 <Cale> weirdo: It also may make more sense once you've been using induction for a while
19:19:24 <ivanm> ahhhh
19:19:46 <weirdo> dons, Cale has been patiently explaining math to me the entire time :-) i installed binary ghc, but haskell-platform whines about the lack of zlib 0.5
19:19:52 <ivanm> s/work hours/I should be doing writing my thesis but stuff it hours/
19:19:55 <ivanm> :p
19:20:04 <dons> weirdo: watch out for Cale, he's also in #math.
19:20:09 <kmc> gaussmd
19:20:37 <dons> Cale's my alter-ego. I talk about applications and benchmarking, he talks about theory and math. We've been doing this for years :)
19:20:50 <weirdo> some people on #math are nasty: <antonfire> Why are you even asking this question if you don't know the meanings of the terms?
19:21:04 <dons> don't worry. we're aggressively friendly in here
19:21:24 <dons> weirdo: did you install the Haskell Platform?
19:21:25 <ivanm> dons: lol
19:21:34 <ivanm> @remember dons Cale's my alter-ego. I talk about applications and benchmarking, he talks about theory and math. We've been doing this for years :)
19:21:34 <lambdabot> It is stored.
19:21:58 <weirdo> dons, i'm trying to rebuild it again. probably some config.cache got stuck and it broke, so i purged the directory and unpacked it again
19:22:28 <weirdo> oh, bummer. not that again!
19:22:48 <weirdo> http://paste.lisp.org/display/87079
19:22:54 <shapr> bos: d00d
19:23:01 <bos> yo
19:23:06 <shapr> bos: How long will you be in town?
19:23:19 <bos> shapr: arrive tomorrow night, leave thursday afternoon
19:23:30 <dons> boston hackathon soon!!
19:23:30 <shapr> Bah, so much for putting the bos in boston :-/
19:23:36 <bos> yeah, it's a shame
19:23:36 <dons> ravi's organizing. shapr -- talk to him about it.
19:23:42 <dons> i'm flying over. shapr: we can rock out!
19:23:46 <shapr> What? When?
19:23:49 * shapr boings cheerfully
19:23:53 <dons> hmm. nov/dec?
19:23:56 <shapr> Oh..
19:23:59 <dons> some kind of winter hack wonderland
19:24:05 <shapr> Bah, I'm moving south :-(
19:24:12 <dons> what what what?
19:24:17 * dons is destined never to meet shapr
19:24:22 <shapr> Yup, October should see me back in Alabama.
19:24:25 <shapr> Yeah, what's up with that?
19:24:29 <dons> weird.
19:24:32 <shapr> bos: So, no time to autograph my copy of RWH?
19:24:38 * shapr sniffles piteously
19:24:42 <dons> we've been doing this haskell thing for like 7 years? and never met. ridiculous
19:24:46 <shapr> Yeah, it's crazy!
19:24:49 <bos> i know!
19:25:00 <shapr> I'll have to go on a pilgrimage to Galoisville.
19:25:15 <dons> or i'll fly south for the warm weather...
19:25:26 <ivanm> dons: why? you don't want to meet him?
19:25:33 <dons> PDX hackathon next week, btw
19:25:34 <bos> so i have a PRNG that's faster than the mersenne twister, and it's written using the ST monad, and i'm trying to figure out how to get users of it to fuse their loops.
19:25:36 <shapr> Yeah, geezusfreek lives near where I'll be.
19:25:48 <dons> bos: i saw the tweet. the new C code?
19:25:56 <bos> dons: pure haskell.
19:26:00 <dons> huh.
19:26:16 <dons> shapr: icfp in baltimore next year
19:26:22 <shapr> oh, interesting
19:26:28 <shapr> I could do that!
19:26:33 <dons> so hackathon, defun, cufp et al
19:26:38 <shapr> Much spiffiness!
19:26:48 <shapr> I've decided to attend school, so I'll have to save up.
19:26:49 <weirdo> could someone look at that paste,  http://paste.lisp.org/display/87079 and tell me why haskell-platform needs an ancient version of zlib?
19:26:53 <dons> bos: that's probably a publishable result
19:27:04 <bos> dons: it probably would be. if i could do it.
19:27:04 <dons> weirdo: what distro are you using?
19:27:11 <weirdo> dons, none
19:27:19 <dons> weirdo: its asking for the haskell zlib
19:27:24 <dons> not the C zlib
19:27:39 <dons> weirdo: you're on linux?
19:27:40 <weirdo> so i need to install cabal, then install zlib with cabal?
19:27:44 <shapr> jmcarthur: y0
19:27:45 <weirdo> dons, yes, amd64 linux
19:27:48 <shapr> @seen jmcarthur
19:27:48 <lambdabot> Unknown command, try @list
19:27:49 <ivanm> dons: heh, first time I've seen that situation for a lib that wasn't X11 :p
19:27:51 <shapr> wah
19:28:01 <ivanm> normally it's xmonad users having problems
19:28:01 <dons> weirdo: and you're installing the haskell platform source bundle?
19:28:04 <ivanm> shapr: buggy plugin
19:28:09 <ivanm> with heaps of memory leaks
19:28:10 <weirdo> dons, yes, after installing a binary GHC
19:28:14 <dons> ok. hmm.
19:28:16 <ivanm> IIRC
19:28:16 <shapr> and @users is down too?
19:28:19 <ivanm> yup
19:28:20 <bos> the best i can think of at the moment is to write a horrible stateful zipWith.
19:28:25 * ivanm checks a much more important command
19:28:27 <shapr> ivanm: Are you lambdabot maintainer now?
19:28:29 <ivanm> @get-shapr!!!
19:28:29 <lambdabot> Unknown command, try @list
19:28:31 <shapr> wheee!
19:28:33 <shapr> I'm here!
19:28:37 <shapr> no wait.. it didn't work!
19:28:41 <ivanm> shapr: no, I've just heard heaps of people asking/complaining (including myself)
19:28:45 <ivanm> shapr: :(
19:28:52 <shapr> Sooo, who's maintaining lambdabot these days?
19:28:57 <dons> weirdo: did you miss a step in the build?
19:28:59 <ivanm> good question :p
19:28:59 <dons> 'zlib          ==0.5.0.0'
19:29:04 <shapr> hrm
19:29:06 <ivanm> Cale: is this your lambdabot running still?
19:29:09 <dons> is what the platform ships with. so it should build that before it gets to cabal-install
19:29:11 <ivanm> or the official one?
19:29:19 <shapr> Was there an official lambdabot at some point?
19:29:28 <dons> when there was only one.
19:30:01 <dons> weirdo: so i'm confused. that's not an error you should see.
19:30:03 <shapr> dons: Oh hey! #haskell on a plane!
19:30:04 <weirdo> dons, i installed ghc to /opt/ghc-foo and made symlinks with a script, such that /opt/ghc-foo/bin/ghc => /usr/bin/ghc
19:30:08 <SamB> well, I still think that all but one should have an unusual name
19:30:15 <Nafai> shapr: Hey!
19:30:18 <ivanm> shapr: the server lambdabot was running on was down, so Cale was running an older one elsewhere
19:30:19 <shapr> hiya Nafai!
19:30:21 <dons> shapr: yeah, that's an awesome idea.
19:30:28 <shapr> dons: Oh, you saw the idea?
19:30:28 * dons just got off a loooong plane flight
19:30:31 <Nafai> shapr: How goes?
19:30:33 <Cale> lambdabot: 2^100
19:30:33 <dons> yeah, i think its very good
19:30:35 <Nafai> dons: Back in PDX?
19:30:35 <Cale> er
19:30:36 <ivanm> shapr: which idea?
19:30:38 <Cale> > 2^100
19:30:39 <lambdabot>   1267650600228229401496703205376
19:30:40 <dons> Nafai: indeed
19:30:43 <ivanm> Cale: lol
19:30:45 <Cale> It is working :)
19:30:51 <Cale> > fix id
19:30:55 <lambdabot>   mueval-core: Time limit exceeded
19:30:58 <Cale> ^^ I even fixed the error messages.
19:31:01 <bos> foldWithRandom :: Random r => (a -> r -> a) -> a -> Gen -> ST s a
19:31:04 <dons> weirdo: the question is: which source for the platform are you installing, and did you miss a step?
19:31:15 <shapr> ivanm: I had half an hour before a flight to grab stuff to do from the 'net, so I grabbed ruby and scala. Then I tried to find docs. But ruby is all online web pages, so not easy to grab. Scala had optional PDFs, so I learned Scala instead.
19:31:15 <ivanm> Cale: "fixed" == "less obscure"?
19:31:19 <Cale> ivanm: yeah.
19:31:19 <weirdo> what do you mean by "miss a step"?
19:31:27 <ivanm> shapr: heh
19:31:27 <psykotic> yo
19:31:32 <dons> shapr: its a good insight
19:31:33 * ivanm is going to a scala tutorial tonight
19:31:34 <dons> heya psykotic
19:31:35 <shapr> hej per!
19:31:41 <dolio> "Time limit exceeded" is better than "parse error".
19:31:47 <Cale> ivanm: It was saying "Prelude.read: no parse" followed by some other crap before.
19:31:47 <ivanm> shapr: by "docs", you mean tutorials?
19:31:49 <weirdo> dons, i'm installing haskell-platform-2009.2.0.2 and have already installed ghc-6.10.4-x86_64-unknown-linux-n.tar.bz2
19:31:51 <shapr> ivanm: Yup
19:31:55 <ivanm> Cale: :o
19:32:05 <shapr> ivanm: So my question was... is Haskell plane learning ready?
19:32:07 <Nafai> shapr: You learned Scala on a plane?
19:32:12 <jonh> weirdo: what distro you using?
19:32:17 <dons> weirdo: do you think you could link to a full transcript of the commands you typed?
19:32:19 <shapr> Nafai: Well, not all of it, but enough to get me excited and enjoying it.
19:32:20 <weirdo> jonh, none
19:32:21 <psykotic> shapr: hej med dig
19:32:22 <jonh> ah
19:32:24 <Nafai> shapr: I can't help but think "Snakes on a Plane!"
19:32:27 <jonh> ok n/m then
19:32:32 <weirdo> dons, okay. i'll run script(1)
19:32:36 <dons> weirdo: btw, what do you mean "no distro"
19:32:42 <Nafai> shapr: Our local alt-lang group is studying Scala this week
19:32:43 <shapr> psykotic: Vad hÃ¤nder? nÃ¥nting spannande?
19:32:54 <ivanm> shapr: hmmm... you can download YAHT
19:32:55 <shapr> Nafai: I really like Scala so far, what do you think?
19:32:59 <weirdo> dons, i compiled every single package from the source, including binutils, glibc and ghc
19:33:01 <ivanm> but apart from that, maybe not
19:33:08 <psykotic> shapr: intet specielt. er paa vej til at flytte fra korea efter 4 aar.
19:33:11 <dons> weirdo: ftw, thousands of people have installed the source bundle, and no one has reported this error
19:33:11 <ivanm> unless BONUS has made LYAH pdfs
19:33:23 <jonh> hehe
19:33:26 <dons> weirdo: so i'm a bit at a loss, other than that you might have skipped a step
19:33:36 <shapr> psykotic: flyttar frÃ¥n korea till var?
19:33:40 <weirdo> i'll try to give you a source transcript
19:33:42 <Nafai> shapr: I haven't looked into it deeply.  I've always been put off a bit by the mixture of OO and FP; seems weird to me.  But I do want to invest some time in it
19:33:50 <Cale> LYAH is on Pirate Bay
19:34:11 <Nafai> shapr: If I ever do an app for my phone (Android) Scala seems to be the most reasonable for me to use to avoid Java
19:34:23 <shapr> ivanm: Yeah, but it's not just about the documentation being there, it's also about it being plane trip accessible... specifically, someone should be able to go to haskell.org and see a link that says "Learn Haskell on a Plane here." or something equally as obvious.
19:34:32 <ivanm> lol
19:34:38 <ivanm> "Haskell: Plane edition"
19:34:41 <sshc> is "x `seq` y `seq` z" equal to "x `seq` (y `seq` z)"?
19:34:42 <psykotic> shapr: intet sted. har taenkt at rejse 1 aars tid. :)
19:34:46 <dons> shapr: haskell platform + docs in a single installer
19:34:51 <dons> + guided  tutorial
19:34:58 <psykotic> shapr: why are you going back to alabama?
19:35:04 <ivanm> comes with HP, an editor, tutorials, docs, all in a convenient 1L clear plastic bag carry case :p
19:35:06 <psykotic> (saw it in log)
19:35:06 <shapr> That is, standalone docs (and compiler/interpreter) should be findable in less than thirty seconds by someone unfamiliar with haskell.org
19:35:11 <shapr> psykotic: skolan
19:35:23 <shapr> psykotic: Jag har ingen diplom(?)
19:35:36 <psykotic> me neither :)
19:35:40 <shapr> I've never had any computer courses, I have no degree, and that gets in my way.
19:35:48 <psykotic> really?
19:35:51 <shapr> So, come to Alabama and go to school ;-)
19:35:52 <shapr> Yup
19:35:58 <psykotic> you mean formal requirements?
19:36:02 <psykotic> or stuff you wish you knew?
19:36:06 <shapr> Some of both.
19:36:27 <shapr> dons: Yes, that's exactly it.
19:36:33 <Nafai> shapr: You are moving back to AL?
19:36:36 <dons> bos: so what's the story with statistics-fusion, is it obsoleted? and do you have patches for uvector?
19:36:39 <shapr> dons: And it should be linked from the front page of haskell.org
19:36:44 <shapr> Nafai: Yup
19:36:59 <weirdo> hmm, by one source, "currying" translated to polish and back is "spicing"
19:37:01 <dons> shapr: interesting. maybe the platform should bundle some open licensed tutorials
19:37:07 <Nafai> shapr: Good luck on the move! :)  Am I to understand you are going to school?
19:37:09 <dons> weirdo: that's awesome
19:37:10 <bos> dons: yes, it's obsolete now. your copyright is still on the imported code, though.
19:37:16 <shapr> Nafai: I want to fill in the missing holes in my (complete lack of ) computer science education, and I want an actual degree I can wave in front of prospective employers.
19:37:16 <SamB> hmm, what do you call a relation that never holds ?
19:37:25 <dons> bos: ok. i should mark it as such.
19:37:25 <psykotic> samb: trivial relation
19:37:37 <shapr> SamB: That brother who never pays you back?
19:37:37 <dons> 'please use the statistics library'
19:37:38 <SamB> psykotic: I thought the trivial one was the one that *always* held
19:37:39 <psykotic> or maybe the zero relation, i've seen both
19:37:42 <Nafai> shapr: I can see how that could be a hinderance; hopefully school will be enjoyable for you!
19:37:55 <ivanm> weirdo: heh, came across a website the other day which looks to find a fixed point in English <-> Japanese translations
19:37:57 <shapr> dons: What's the license on RWH? Can it be PDF'd?
19:37:58 * ivanm tries to find it
19:38:03 <weirdo> shapr, don't bother with a degree. you can make money without employers even asking you your age
19:38:18 <Cale> Mathematician: The sort of jerk who when asked if the dishes are clean or dirty will flatly respond with 'yes'.
19:38:22 <ivanm> shapr: it is PDF'd... for money :(
19:38:23 <weirdo> or seeing them in person
19:38:24 <weirdo> that's what i did
19:38:34 <dons> shapr: http://creativecommons.org/licenses/by-nc/3.0/
19:38:37 <psykotic> samb: you might be right. when i think trivial i always think of 'low connectivity'. cf discrete topology vs trivial topology.
19:38:45 <shapr> weirdo: I agree, I'm making lots of money now, but I want jobs in the Haskell world, and I want to fill in the holes in my math and CS background, and there *are* holes.
19:38:50 <Nafai> bos: So, I have some data I would like to use the stats library with, but I admit to not remembering much from college stats.  You wouldn't happen to have a recommendation for a resource to reviewing stats?
19:39:28 <shapr> Well, cc is easy enough.
19:39:47 <psykotic> shapr: it also doesn't hurt to have spare hack time :)
19:39:49 <dons> i think that's something about the job market for haskellers. because of hysterical raisins, the standards for haskell programmers are rather high, in the current job market
19:40:12 <shapr> That's not a bad thing.
19:40:13 <psykotic> the current job market is the same as it's ever been if you aren't at the bottom
19:40:14 <bos> Nafai: not off the top of my head
19:40:19 <Cale> shapr: I've been looking for students to tutor to make some money, if you're ever interested :)
19:40:30 <shapr> Cale: You tutor math?
19:40:30 <ivanm> weirdo: http://translationparty.com/
19:40:35 <Cale> shapr: Yeah.
19:40:46 <shapr> Cale: I may contact you for that.
19:40:56 <psykotic> he's an algebraist
19:41:02 <psykotic> an evil creature
19:41:10 <shapr> What did you just call him? I mean... how's that different from other options?
19:41:23 <Cale> Hey, I know a fair amount of analysis too
19:41:31 <psykotic> i can teach you algebraic number theory from the riemann surface perspective, it's much nicer :)
19:41:31 <weirdo> ivanm, i typed in "homoiconicity" and it "worked"
19:41:33 <shapr> psykotic: So, what citizenships do you have anyway? Want to drop by the US while you travel?
19:41:46 <psykotic> just danish
19:41:54 <psykotic> but i'm planning on dropping by the us after i'm done with my asia trip
19:42:04 <ivanm> psykotic: where you going in asia?
19:42:07 <shapr> Cool, do you have a range of date/times?
19:42:26 <psykotic> not yet, i'll probably be traveling in east asia for at least 4-5 months
19:42:34 <psykotic> planning on hitting most of it
19:42:35 <Cale> psykotic: I have been somewhat scarred for life by the algebraic number theory course I took at Waterloo. ;)
19:42:54 <shapr> Awright, send me a message when you're in the hemisphere
19:42:58 <psykotic> cale: none of that stuff made any intuitive sense to me until i learned of the dedekind-weber analogy between algebraic numbers and algebraic functions.
19:43:01 <psykotic> shapr: will do!
19:43:10 <weirdo> oh, i'm supposed to enter whole phrases
19:43:42 <shapr> weirdo: I've been getting paid to write code for fifteen years or so without a degree, but now I'm looking for a different sort of job.
19:43:52 <Cale> psykotic: Yeah, I still don't know it. I have lots of memories of stumbling around in mazes of divisibility relations and proofs which break down into cases modulo 8...
19:44:18 <shapr> bos: So, not even an hour to spare in bos-tone?
19:44:30 <bos> shapr: maybe tomorrow night?
19:44:36 <shapr> Er, that would be cool.
19:45:03 <shapr> Does that mean I get to buy you a beer in Logan?
19:45:06 <psykotic> cale: yeah, that's horrible. i never liked most pure number theory unless i could connect it to something geometric.
19:45:07 <bos> shapr: my flight gets into grogan airport at about 6pm, as it turns out.
19:45:17 <bos> so i'll be downtown by, uh, 7?
19:45:25 <shapr> Ah, spiffy. Where at?
19:45:42 <shapr> As in, downtown Boston/Cambridge/Somerville/etc ?
19:45:43 <Cale> Computing ideal class groups where the only useful tool we had was the Minkowski bound, and where that gave something ridiculous and it turned into a brute forcing nightmare.
19:45:44 <psykotic> cale: that's actually why i like a lot of algebraic number theory, because of the connection to lattices, etc.
19:46:05 <psykotic> minkowski bound on 'lattice area packing'?
19:46:10 <shapr> I swear, I will have my copy of RWH fully autographed someday.
19:46:13 <bos> shapr: the marriott in cambridge.
19:46:17 <shapr> Oh, ok
19:46:33 <psykotic> see, that's the other beautiful thing about algebraic number theory.
19:46:35 <Cale> Yeah, the sqrt(|D|) (4/pi)^r2 n!/n^n thing.
19:46:48 <psykotic> the way 'complex multiplication' (presence of exceptional automorphisms) has to do with the packing tightness of the lattice, etc
19:46:57 <Cale> Or maybe a minor variation on that one... I forget.
19:47:03 <psykotic> which in turn can be related to packing tightness of convex sets generally. beautiful stuff.
19:47:39 <psykotic> of course most of that stuff only works on elliptic curves
19:47:44 <psykotic> but some of it continues working on other abelian varieties
19:47:54 <psykotic> i've mostly stuck to the nicer geometric areas
19:48:01 <psykotic> anyway, i have to run, later.
19:48:32 <Cale> Yeah, I'm sure that when you treat it abstractly enough, it's pretty, and there are some rather cool things in it. The whole idea of the ideal class group is brilliant in the first place. Just... the prof was a bit of a jerk about the assignments, I think. :) We asked him why he assigned such brutal stuff after the course was over and he said something like "sometimes math is hard".
19:48:38 <Cale> ah
19:49:35 <Cale> shapr: Mathematics breaks down into rough areas which overlap a fair amount...
19:50:11 <shapr> But not as much as Russel & Whitehead hoped.
19:51:46 <shapr> kpreid: I like Twitter!
19:53:05 <kpreid> shapr: catching up?
19:53:31 <shapr> Um, I'm only four or five days behind, yeah?
19:53:56 <shapr> I went to DragonCon last week, I'm still recovering.
19:54:03 <Cale> Algebra, to be a bit glib about it, is all about representing things abstractly with a variety of vaguely number-like devices (Monoids, Groups, Rings, Fields, Categories, etc.). Analysis is to some extent all about the behaviour of limits and convergence in various settings, but also things like distances and sizes.
19:54:36 <shapr> DragonCon was insanely cool... but the EFF computer security track was a bit slower than I'd hoped.
19:54:47 <Cale> Combinatorics is all about discrete structures: graphs, trees, partitions of integers, things of that sort. Counting them and decomposing them into simpler structures, and finding relationships between them.
19:54:51 <tehgeekmeister> how do i make sortBy do a reverse sort?
19:55:06 <Cale> tehgeekmeister: sortBy (flip compare)
19:55:10 <tehgeekmeister> i'm already using the compare `on` snd trick, so preferably something compatible with that
19:55:12 <tehgeekmeister> okay
19:55:26 <tehgeekmeister> sortBy ((flip compare) `on` snd)
19:55:27 <tehgeekmeister> ?
19:55:28 <shapr> bos: Do you get privmsgs?
19:55:30 <Cale> yep
19:55:40 <aavogt> excess parentheses though
19:55:41 <Cale> You don't need the inner brackets
19:56:08 <tehgeekmeister> ah, you're right
19:56:09 <tehgeekmeister> i don't
19:56:15 <Cale> shapr: This is a really cool site to browse around and get an idea for what topics there are: http://www.math-atlas.org/
19:56:18 <tehgeekmeister> i throw them in wherever i think i might
19:57:57 <Cale> I'm really more of an algebraic combinatorics and category theory sort of person, but I know a fair amount of basic real, complex and functional analysis.
19:58:07 <shapr> I was talking to a guy who everyone at works considers a well educated programmer, and I realized he doesn't know a lot of stuff I expect every programmer to know. He'd never of heard of IEEE754 !
19:58:17 <chessguy> @get-slap
19:58:17 <lambdabot> shapr!!
19:58:49 <shapr> He had no idea that algorithmic stability existed... I came up with a short of list of interesting uses of math in programming, and he'd never heard of most of them.
19:58:56 <Cale> shapr: It's always fun to see the surprise when people see that basic properties of numbers break down miserably for floating point.
19:59:07 <weirdo> i think now it compiles. unless it's going to fail soon.
19:59:12 <weirdo> yes, it just did
19:59:31 <shapr> I sort of expect anyone who can write code to understand the basics of IEEE754
19:59:33 <chessguy> Cale, i still remember the first time i saw equality fail for floating point numbers
19:59:48 <shapr> Perhaps I am more educated that I keep thinking.
20:00:01 <bos> shapr: sorry, putting the kids to  bed.
20:00:12 <shapr> No worries
20:00:21 <Cale> shapr: Just hanging around here, you can't help but pick lots of stuff up by osmosis :)
20:00:25 <shapr> Truly
20:00:28 <shapr> I like that!
20:00:44 <kmc> the math and programming thread on reddit was all like "math is useless because i've never used calc 1 while writing porn sites in php"
20:00:48 <shapr> Yeah, I thought a ring was something involving marriage before I spent time in #haskell
20:00:58 <chessguy> haha
20:01:17 <wmealing__> I really need to shape up my math.
20:01:18 <shapr> Nowadays the One Ring joke makes perfect sense to me.
20:01:29 <chessguy> what joke?
20:01:41 <shapr> orc joke, you wouldn't understand
20:01:47 <shapr> I mean...
20:01:49 * shapr looks it up
20:02:36 <shapr> Cale: Um, do you remember where to find the orc joke about the One Ring?
20:02:54 <shapr> uh oh
20:02:56 <Cale> I'm not sure I've heard that one
20:03:02 <chessguy> shapr, no big deal, don't worry about it
20:03:06 <shapr> Cale: You pointed it out to me, I thought.
20:03:09 <chessguy> i was just curious
20:03:27 <shapr> It's a webcomic, with some orcs talking about abelian groups of finite order....
20:03:49 <kmc> stick figure webcomic?
20:03:56 <shapr> Um, I don't think so.
20:04:07 <ray> you should have said webcomic to begin with
20:04:10 <ray> http://www.irregularwebcomic.net/470.html
20:04:34 <shapr> Ah yes! That's it!
20:04:38 <chessguy> haha, nice
20:05:07 <Cale> I knew a guy who had managed to get all the way through his Master's on functional analysis without hearing the "What's yellow and complete under the induced norm?" joke. I remember he told me his advisor told him the joke at the end of his thesis defense and he was floored by it.
20:05:30 <forgot> Hi, i got a really weird problem here: http://pastebin.com/mbed4c71 ; The row function works now but when you uncomment 'drop 2' i get a stack overflow?
20:05:33 <kmc> is that like "what's purple and commutes?"
20:05:41 <ivanm> Cale: what's the joke?
20:05:52 <Cale> "A banananach space"
20:06:08 * Axman6 doesn't get it :(
20:06:09 <ray> bananach?
20:06:13 * ivanm thinks he gets it
20:06:16 <Cale> (Look up Banach space)
20:06:21 <ivanm> ray: banana + banach space
20:06:39 <ivanm> Cale: yeah, that's worse than the integral of western europe joke[s]
20:06:47 <ray> i am saying "bananach" sounds better than "banananach"
20:06:51 * Axman6 isn't used to talking about spaces, let alone category theory (?)...
20:07:16 <Axman6> ivanm: which is?
20:07:17 <ray> vector spaces
20:07:38 <kmc> i demand a pun for each class in category-extras
20:07:48 <shapr> That's edwardk's job.
20:07:56 <ivanm> Axman6: down the bottom here: http://mathworld.wolfram.com/Pole.html
20:07:58 <weirdo> http://tehran.lain.pl/stuff/haskell-typescript-20090915
20:08:01 <weirdo> anyone knows what i did wrong?
20:08:19 <ivanm> there's also one as a secondary about that with migrant Poles in western europe
20:08:25 <kmc> i like the one about the dog better
20:08:42 <forgot> help anyone?
20:08:58 <Axman6> ivanm: heh
20:09:08 <ivanm> yeah, I've never heard the dog one before
20:09:09 <Axman6> forgot: not if we don't know the problem
20:09:24 <forgot> Hi, i got a really weird problem here: http://pastebin.com/mbed4c71 ; The row function works now but when you uncomment 'drop 2' i get a stack overflow?
20:09:25 <dons> weirdo: looking...
20:09:25 <ivanm> Axman6: look up :p
20:09:39 <ivanm> forgot: my guess: infinite loop
20:09:57 <ivanm> is that meant to be an extremely inefficient fibonacci implementation?
20:10:04 <dons> weirdo: what happens if you don't use ' make -j4'
20:10:08 <dons> and just use 'make'
20:10:09 <ivanm> if so, it appears to be saying that the value in n depends on the value in n
20:10:15 <ivanm> and as such, can never finish
20:10:28 <ivanm> (with more and more being allocated to the stack, resulting in a stack overflow)
20:10:44 <forgot> why is it able to run without the 'drop 2'?
20:10:52 <dons> weirdo: my guess is that the dependencies are under-specified in the Makefile we generate, so your -j4 is getting the ordering wrong
20:10:58 <ivanm> forgot: because there's no reason it can't
20:11:02 <ivanm> it just won't finish
20:11:02 <weirdo> now it says that program "happy" is required
20:11:05 <dons> weirdo: if that's the case, please open a ticket on the platform wiki.
20:11:10 <ivanm> weirdo: then install it! ;-)
20:11:15 <dons> weirdo: it will build happy
20:11:25 <forgot> no; without the 'drop 2' it works fine except i want it to drop 2
20:11:41 <ivanm> forgot: oh, I misread what you wrote, sorry
20:11:41 <dons> weirdo: that would also be a symptom of an incomplete build due to -j4
20:11:56 <dons> './configure
20:11:56 <dons> make
20:11:56 <dons> make install
20:12:02 <weirdo> hmm "pattern match is non-exhaustive"
20:12:02 <dons> ' with possible --prefix only, please.
20:12:06 <ivanm> forgot: what are you trying to do?
20:12:14 <weirdo> nice type system
20:12:15 <dons> weirdo: those warnings are fine. that's just happy. it has warnings.
20:12:21 <forgot> i'm trying to build a structure called a wythoff array
20:12:26 <ivanm> usually, if you use (!!) then you're doing it wrong
20:12:27 <weirdo> in CL, my pattern matching code is turing-complete
20:12:30 <weirdo> and i can't prove squat about it
20:12:40 <dons> indeed.
20:12:55 <weirdo> maybe if i made a formalism for declaring patterns
20:12:59 <dons> be nice to your compiler, use a type system
20:13:06 <weirdo> but then again i could implement HM for CL
20:13:13 <Axman6> HM?
20:13:18 <weirdo> hindley-milner
20:13:22 <dons> that'd be a bit weird though. since you'd have an ad-hoc haskell at the point
20:13:36 <dons> without the specialized runtime, nor the optimizations
20:13:36 <Axman6> hindley-milner? >_>
20:13:40 <weirdo> there's no problem with greenspunning haskell in CL :-)
20:13:45 <weirdo> mark tarver already did it with Qi
20:13:50 <Axman6> (i think those names came up in my formal methods course)
20:13:51 <dons> well, have a look at liskell
20:14:00 <dons> keep the type system and runtime, get back your lisp syntax
20:14:09 <weirdo> but doesn't liskell translate to haskell source code?
20:14:13 <dons> it does.
20:14:17 <weirdo> that kind of sucks
20:14:22 <kmc> can't you already write lisp syntax in haskell, more or less?
20:14:25 <dons> type correctness has its benefits
20:14:29 <kmc> if you stick to prefix and use lots of parens
20:14:30 <weirdo> don't you miss lisp macros in haskell?
20:14:41 <shapr> Should I?
20:14:41 <dons> weirdo: there's Template Haskell for arbitrary AST manipulation
20:14:57 <dons> but laziness gets rid of most uses wrt. generating control structures
20:14:59 <weirdo> dons, is it a separate dialect?
20:15:01 <forgot> ivanm do you know what i'm doing wrong
20:15:10 <dons> its an extension that's part of GHC.
20:15:21 <Axman6> but it's basically haskell isn't it?
20:15:24 <dons> -XTemplateHaskell, you can learn about it once you get the platform built, and you're working through RWH.
20:15:28 <dons> yes.
20:15:29 <weirdo> dons, how about harder stuff? in lisp, one can write pattern matching or call/cc from scratch
20:15:33 <dons> its haskell to extend haskell.
20:15:35 <kmc> you write a haskell program that writes haskell programs
20:15:41 <dons> weirdo: call/cc is just a library function in haskell
20:15:43 <dons> :t callCC
20:15:44 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:15:50 <Axman6> heh
20:16:00 <weirdo> dons, can it be implemented in portable haskell?
20:16:04 <dons> sure.
20:16:05 <dons> see above
20:16:09 <kmc> @djinn ((a -> b) -> a) -> a
20:16:09 <lambdabot> -- f cannot be realized.
20:16:10 <Axman6> @src calCC
20:16:10 <lambdabot> Source not found. Where did you learn to type?
20:16:13 <Axman6> :(
20:16:21 <kmc> weirdo, Cont is an ordinary monad implemented using no special primitives
20:16:22 <weirdo> dons, do you use CPS-transformation, stack-copying or what?
20:16:32 <dons> its just the continuation monad
20:16:38 <kmc> CPS transformation basically
20:16:39 <Axman6> weirdo: it's nothing special
20:16:40 <dons> so it relies on laziness
20:16:47 <kmc> @unmtl Cont a
20:16:47 <lambdabot> err: `Cont a' is not applied to enough arguments, giving `/\A. (A -> a) -> a'
20:16:51 <kmc> @unmtl Cont a b
20:16:51 <lambdabot> (b -> a) -> a
20:16:55 <weirdo> in CL CPS-xform sucks pretty much
20:17:02 <dons> instance (Monad m) => MonadCont (ContT r m) where callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
20:17:11 <weirdo> everything in the call stack has to be CPS-xformed
20:17:17 <weirdo> which is both costly, and painful
20:17:24 <dons> you still haven't got the platform installed...
20:17:25 <kmc> weirdo, the monad takes care of the plumbing for you
20:17:28 <dons> finish that first :)
20:17:32 <Axman6> heh
20:17:35 <kmc> it's no more (or less) painful than any other monadic syntax
20:17:44 <kmc> more mind-bending because, hey, call/cc
20:17:46 <weirdo> ha! it still fails with the same error
20:17:54 <dons> did you build in a clean tree?
20:18:01 <weirdo> yes
20:18:08 <dons> and it failed at cabal-install?
20:18:18 <weirdo> yes
20:18:28 <weirdo> i'll try rebuilding binary GHC again
20:18:28 <dons> ok. so you're 1 / 212,000 installs.
20:18:35 <dons> what's different about your system?
20:18:43 <weirdo> because make -j4 might have messed it up too
20:18:53 <weirdo> dons, LFS, linux amd64
20:18:55 <dons> ghc should be fine.
20:18:59 <weirdo> i can give you the list of my packages, hold on
20:19:34 * dons thinks that if weird builds his own distro from scratch, he can debug the platform build system 
20:19:49 <dons> :)
20:19:59 <weirdo> http://tehran.lain.pl/stuff/lfs-packages-20090915
20:20:25 <dons> shouldn't have any bearing on the platform build.
20:20:35 <dons> the build just builds, in sorted order, the dependencies of the complete platform
20:20:40 <weirdo> damn, it's the middle of the night, i thought i'd write a monad or two before i fall asleep
20:21:29 <dons> cabal-install is the last thing to be built.
20:21:34 <dons> zlib is second last.
20:22:02 <dons> is the C zlib missing on your system?
20:22:08 <dons> perhaps the build of haskell-zlib is failing
20:22:31 <dons> nope, it seems to be there. did you notice if haskell-zlib built, prior to cabal-install?
20:23:33 * tehgeekmeister is having haskell epiphanies =D
20:23:55 <dons> heya texodus
20:23:56 <dons> tehgeekmeister:
20:23:59 <dons> tab complete
20:24:23 <kmc> haskellgasm?
20:24:23 <tehgeekmeister> ?
20:24:26 <tehgeekmeister> i am confused
20:24:31 <weirdo> dons, but i've already built cabal on binary ghc, and even have darcs installed
20:24:34 <tehgeekmeister> haskellgasm, nice term
20:24:55 <forgot> anyone have any idea why in my program http://pastebin.com/mbed4c71 uncommenting 'drop 2' makes it crash?
20:25:55 <tehgeekmeister> something about trying to port imperative code to haskell made me write horribly ugly haskell, and now i'm finally realizing how it can be written better.  =D
20:26:28 <User331> hey if any of you are bored check out Facebook zombies game :D http://apps.facebook.com/zombies/links.php?r=719927515&nref=st
20:26:59 <dons> weirdo: reading the transcript, it is definitely trying to build cabal-install before it has built zlib
20:27:36 <dons> which i can only put down to make -j4. if you have indeed built the cabal binary, you could try explictily building zlib, a la, cabal install zlib
20:27:36 <weirdo> dons, what do i do to make it work?
20:27:43 <dons> but that doesn't explain why your build is out of order
20:27:48 <weirdo> ok.
20:27:58 <dons> and why yours is the only build that shows this
20:28:00 <weirdo> i'll try installing everything from scratch, again
20:28:35 <dons> well, you shouldn't need to reinstall ghc
20:28:40 <dons> assuming say, ghci works
20:28:50 <CalJohn> forgot: "crash" with an exception?
20:29:15 <forgot> stack overflow actually
20:29:27 <forgot> what's weird is that it works without the 'drop 2'
20:31:43 <ivanm> maybe the list isn't long enough when one of the !! is called?
20:32:42 <forgot> maybe, how do i find out?
20:33:57 <dons> bos: its yours now, http://hackage.haskell.org/package/statistics-fusion-1.0
20:34:26 <bos> dons: uh oh :-)
20:34:28 <bos> dons: thanks
20:34:43 <CalJohn> ivanm: that could not result in a stack overflow, that would look like: "Exception: Prelude.(!!): index too large"
20:35:22 <ivanm> dons: lol
20:35:25 <ivanm> CalJohn: oh, yeah...
20:36:00 <CalJohn> forgot: would you mind explaining to be what your code does?
20:36:25 <forgot> this problem: http://www.cstutoringcenter.com/problems/problems.php?id=75
20:43:03 <weirdo> oh, there are no keyword arguments in haskell?
20:43:12 <CalJohn> weirdo: no, there aren't
20:43:40 <c_wraith> record update syntax sometimes looks like it.
20:43:42 <CalJohn> people normally would use an algebraic record type to do that
20:44:00 <nyingen> why is [ x + x | x <- [2..], y <- [2..]] not equivalent to [ x + x | x <- [2..]] ?
20:44:56 <nyingen> I'm not real familiar with how list comprehensions work, but I was surprised by the result of the former expression
20:45:19 <c_wraith> They work the same way the list monad does.
20:45:25 <c_wraith> which means each <- is a product
20:45:37 <c_wraith> regardless of whether the value is used.
20:45:40 <weirdo> okay, what do i do to build zlib before cabal-install?
20:45:47 <kmc> nyingen, if you want a zip instead of a product, check out ghc's parallel list comprehension extension
20:46:01 <nyingen> hmm
20:46:16 <nyingen> what do we mean by 'product' here?
20:46:20 <kmc> weirdo, no point to kw args when every function has only one arg ;)
20:46:43 <c_wraith> > [ (x, y) | x <- [1..3], y <- [1, 2] ]
20:46:44 <lambdabot>   [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)]
20:46:58 <c_wraith> > [ (x, x) | x <- [1..3], y <- [1, 2] ]
20:46:59 <lambdabot>   [(1,1),(1,1),(2,2),(2,2),(3,3),(3,3)]
20:47:22 <Makoryu> nyingen: Basically, the total number of iterations will be the product of the lengths of all lists that you pull stuff out of.
20:48:06 <forgot> CalJohn do you know what's wrong with my code?
20:48:19 <Makoryu> nyingen: That doesn't necessarily mean that the final result will have that number of items (generally fewer, if you filter them) but it'll traverse that many combinations.
20:48:39 <CalJohn> forgot: no, sorry, i am looking at it and thinking, but apparently i am not that smart :)
20:49:01 <Makoryu> > let foo = [1..100] in [(x, y, z) | x <- foo, y <- foo, z <- foo]
20:49:02 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
20:49:03 <forgot> this is really weird, nobody knows what's wrong
20:50:57 <dons> weirdo: so why is your system not building zlib before cabal-install? any ideas?
20:51:23 <weirdo> maybe because i installed ghc to /opt but the configure script is finding it in /usr
20:51:51 <weirdo> if that fails, i'll try installing haskell-platform to the same prefix as ghc
20:51:56 <dons> you can use --with-ghc=/opt/.... as an argument to ./configure
20:51:58 <mmorrow> nyingen: [(x,y) | x <- xs, y <- ys] is the cartesian product
20:52:13 <weirdo> yeah, that's what i'm trying now
20:52:22 <dons> weirdo: that would explain some of the failures -- its installing in one place, but using libraries from another
20:52:27 <dons> so it doesn't see zlib
20:52:39 <weirdo> still doesn't work. i'll try the prefix thing
20:52:40 <dons> try adding /opt to the path
20:53:21 <dons> make sure it detects the ghc you actually want to use
20:53:36 <dons> checking for ghc... /usr/bin/ghc
20:53:36 <dons> checking for ghc-pkg... /usr/bin/ghc-pkg
20:53:36 <dons> checking for hsc2hs... /usr/bin/hsc2hs
20:53:36 <dons> should all match
20:53:39 <mmorrow> nyingen: [x + y | x <- xs, y <- ys] maps a 2D space to a 1D space, while [x + x | x <- xs] maps a 1D to 1D
20:54:14 <nyingen> hmm. i see now
20:54:16 <dons> weirdo: --prefix just says where to install things. probably won't make a difference.
20:54:16 <CalJohn> forgot: figured it out
20:54:39 <forgot> tell me
20:54:56 <psykotic> dons: do you know the guy writing the haskell-for-maths blog?
20:54:59 <dons> weirdo: it'd be worth checking that the build is installing the packages in the order listed in: packages/platform.packages
20:55:07 <dons> psykotic: no, but he's a friend of sigfpe
20:55:10 <CalJohn> i'm still not 100% certain what your code does, but when you call ((fb!!(y+1))+1)
20:55:18 <weirdo> dons, it installs cabal-install right after cgi
20:55:25 <CalJohn> fb = row size x
20:55:42 <dons> weirdo: it should install zlib between cgi and cabal-install
20:55:45 <CalJohn> you're problem is with the search function
20:55:53 <forgot> ah
20:55:54 <dons> weirdo: $ ghc-pkg list zlib
20:55:58 <CalJohn> clrealy it is not returning a smaller argument
20:56:00 <forgot> it seems to work
20:56:02 <dons> do you already have a haskell-zlib installed?
20:56:07 <CalJohn> and so you are looping forever
20:56:40 <CalJohn> i'm not sure for certain, but we can be sure the problem relates to the search function
20:57:00 <forgot> what's a correct version of my search function?
20:57:20 <CalJohn> i'm not sure, because i never figured out what it was supposed to do :)
20:57:29 <dons> weirdo: you can manually install zlib. cd packages/zlib-0.5.0.0 ; runhaskell Setup.hs configure ; runhaskell Setup.hs build ; runhaskell Setup.hs install (with appropriate --prefix)
20:58:37 <forgot> well search [[1,2,3],[4,5]] 4 returns (1,0)
20:58:56 <CalJohn> forgot: i can tell you that i wouldn't express the problem the way you are, but that is beside the point
20:59:16 <CalJohn> so search finds an element in a matrix
20:59:20 <forgot> yea
20:59:22 <weirdo> .wii Cale
20:59:26 <weirdo> oops.
20:59:30 <forgot> am i doing it completely wrong then?
21:00:06 <CalJohn> what is the rule for generating the left hand column on the problem?
21:00:24 <CalJohn> i would do:
21:00:43 <weirdo> :|
21:00:45 <forgot> i'm getting it from http://view.samurajdata.se/psview.php?id=9c9c91c8&page=1&all=1&size=full (wythoff arrays)
21:01:05 <weirdo> http://paste.lisp.org/display/87082
21:02:07 <dons> ghc might not have been able to create your Setup script
21:02:15 <dons> more funkiness in your system
21:02:36 <weirdo> my system? my system? :-)
21:02:38 <dons> you can cd into packages/mtl-* and see if you can build it by hand
21:02:46 <weirdo> you know, first thing after i installed xorg was installing emacs and sbcl
21:02:52 <weirdo> then i typed (require 'mcclim)
21:02:53 <CalJohn> forgot: map (\x -> fibsFrom x) firstNums !! 16 !! 16
21:02:58 <weirdo> and it all Just Worked
21:02:59 <dons> and you've got two versions of ghc installed?
21:03:01 <dons> one in /opt/
21:03:09 <CalJohn> where fibsFrom :: [Integer] and firstNums :: [Integer]
21:03:18 <dons> weirdo: its ok. you're the only person who's reported this problem (and we've had 250k installs :)
21:03:29 <dons> so, yep, i think its something about your build environment
21:03:42 <weirdo> dons, you know what? i'm gonna install it to /usr. not even /usr/local, but /usr
21:03:47 <dons> my current best guess is inconsistent ghc/ghc-pkg in your path
21:03:48 <weirdo> i haven't yet written any package manager
21:03:54 <CalJohn> fibsFrom x generates the fibonnaci sequence starting from x
21:04:07 <weirdo> but i'm gonna nuke this system when i write one
21:04:11 <weirdo> since /opt is unmaintainable
21:04:12 <forgot> but don't you need 2 numbers to start a fibonacci sequence
21:04:20 <dons> weirdo: i don't   think it matters where things are installed, as long as all tools ghc needs are in the same dir.
21:04:26 <dons> so not ghc from /opt, and ghc-pkg from /usr/local/
21:04:30 <dons> for example.
21:04:46 <dons> did you try building zlib by hand?
21:05:25 <weirdo> i did, and that error happened after i built zlib
21:05:39 <dons> the mtl error?
21:06:00 <weirdo> yes
21:06:31 <dons> i don't understand your build environment, then. try in a clean environment. one ghc version, consistent $PATH, consistent set of installed packages.
21:06:56 <CalJohn> forgot: yeah, obviously i don't really understand how the array is defined
21:07:02 <dons> sorry this is difficult. it hasn't been for other people, so I'd love to know what we can fix to make this easier for you.
21:07:39 <weirdo> if it won't work with --prefix=/usr then i'll be really surprised
21:07:59 <dons> well, that'll say where  to install things, not where to find ghc and ghc-pkg and hsc2hs
21:08:13 <dons> they'll be wherever you installed ghc, and need to be in your PatH
21:08:49 <weirdo> it both was in my path, and i have given the location to it by hand
21:09:09 <weirdo> perhaps there should be an option to give ghc *prefix*, not binary locations
21:09:24 <dons> that's a good idea.
21:09:29 <weirdo> but we'll know when the build fails/completes
21:09:39 <dons> the usual case is that the ghc prefix is in your $PATH, and you override that with flags
21:09:53 <weirdo> prefix isn't in $PATH
21:09:56 <weirdo> prefix/bin is in $PATH
21:10:02 <dons> yeah, that's all we need.
21:10:39 <dons> i don't really know enough about your system to be able to explain these out of order errors, nor the mtl one. i've never seen these errors before.
21:10:54 <dons> i've not been able to reproduce them locally, fwiw.
21:11:58 <forgot> CalJohn: i found the problem
21:12:13 <forgot> should have been [0..size] not [1..size]
21:13:46 <weirdo> ha! it still happens
21:13:59 <weirdo> dons, i can provide you with root access if you can help me with this
21:14:16 <weirdo> just one thing, if you delete libc, tell me on irc so i'll know it was an accident
21:14:16 <weirdo> :)
21:14:57 <weirdo> (if i reboot quickly i won't even have to restore it, because memory state won't be flushed to disk)
21:15:07 <weirdo> i actually did something like this a few days ago
21:15:37 <weirdo> maybe it's because i'm building binary ghc instead of sauce?
21:15:41 <dons> weirdo: i don't have time available to debug this, unfortunately. i would suggest providing a transcript to the haskell-platofrm@ list.
21:15:57 <dons> the only requirements for  the platform is that you have ghc 6.10.4 installed in binary form.
21:16:07 <dons> along with a small number of C libraries, like zlib and opengl
21:16:55 <weirdo> aww, why can't ghci print functions?
21:17:07 <weirdo> i typed '(+)' at it
21:17:20 <Cale> > (+)
21:17:21 <lambdabot>   -3->
21:17:21 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
21:17:21 <lambdabot>  -2->
21:17:21 <lambdabot>    {-3->-5;-2->...
21:17:32 <weirdo> <interactive>:1:0:
21:17:33 <weirdo>     No instance for (Show (a -> a -> a))
21:17:33 <weirdo>  
21:17:39 <Cale> Lambdabot shows functions using the instances of Show in smallcheck, I believe
21:17:52 <Cale> You can get the smallcheck library and import the module to show functions that way.
21:17:58 <weirdo> :-)
21:18:20 <weirdo> do i really /need/ haskell-platform, by the way?
21:18:37 <weirdo> i can install packages using cabal, right?
21:18:50 <weirdo> and i'm not concerned about standard library
21:18:57 <Cale> yeah, cabal install smallcheck
21:19:00 <weirdo> since in lisp, we don't even have sockets in the standard
21:19:01 <Makoryu> weirdo: Yeah. If you get GHC and cabal-install working, you're all set.
21:19:32 <Cale> instance (Serial a, Show a, Show b) => Show (a->b)
21:19:33 <weirdo> when i used cabal, it required fetching stuff and then cd-ing to its directory in ~/.cabal
21:19:36 <weirdo> can i do this with all command?
21:19:40 <weirdo> one command
21:19:43 <Cale> cabal install foo
21:19:51 <Cale> where foo is the name of the package you want
21:20:09 <Cale> You should usually cabal update beforehand too.
21:21:23 <dons> weirdo: Cabal is a library, cabal-install is a program, that provides the 'cabal' executable
21:34:32 <weirdo> hmm is it very hard to efficiently implement lazy evaluation?
21:34:49 <weirdo> because i just put stuff into thunks and applied them if they weren't applied before
21:35:13 <weirdo> i mean, if they really had to be applied, as opposed to, used as free variables in other thunks
21:36:18 <Makoryu> weirdo: I don't really follow
21:38:54 <dons> weirdo: its not really hard (see ghc), and efficient mechanisms are well documented.
21:39:18 <weirdo> Makoryu, my naive implementation of lazy evaluation was like this: put every function application into a thunk (no-argument function). so what is returned in a lazy code segment is one thunk that references other thunks as closure variables (free variables). a function called â€žSTRICTLYâ€ recursively expanded thunks into actual values
21:39:59 <Makoryu> weirdo: Ah, sorry, I misread your question!
21:41:53 <SamB> weirdo: well, a good implementation will have something called "strictness analysis"
21:42:21 <weirdo> i was thinking of something like this:
21:43:12 <weirdo> if a function returns a lazy sequence and another one takes that lazy sequence and maps over it or filters it, don't cons two sequences, "merge" these two together
21:43:27 <kmc> weirdo, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
21:43:37 <kmc> wonderful paper :)
21:43:43 <weirdo> but that only applies if the CDR of that sequence is only used to produce the next element
21:43:48 <SamB> kmc: is that from lists to streams to nothing ?
21:43:54 <kmc> no it's the stg machine paper
21:44:04 <SamB> @go from lists to strings to nothing at all
21:44:05 <lambdabot> Maybe you meant: google googleit do
21:44:08 <SamB> @google from lists to strings to nothing at all
21:44:09 <lambdabot> No Result Found.
21:44:17 <SamB> @google from lists to streams to nothing at all
21:44:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
21:44:19 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
21:44:28 <SamB> weirdo: read that ;-)
21:44:39 <SamB> you will hopefully enjoy it
21:44:56 <SamB> just, if your head starts to hurt, take a break and play zelda or something ;-)
21:46:21 <weirdo> hmm, seems like much badness ensued because i didn't delete ~/.ghc and ~/.cabal
21:47:13 <weirdo> now it'll be fun when the build completes without error
21:47:37 <weirdo> because i previously had ghc installed to build darcs, and then just did rm -rf /opt/ghc-foo
21:49:31 <wmealing__> wait, is that the same dons from reddit haskell ?
21:49:45 <SamB> wmealing__: yeah
21:49:54 <SamB> he was here first!
21:49:57 <wmealing__> its a small world.
21:50:03 * wmealing__ waves to dons
21:50:05 <SamB> it's also a big channel
21:50:09 <wmealing__> thats.. true
21:50:23 <SamB> though I think it's mostly lurkers ?
21:50:35 <wmealing__> possibly.. or people wanting to learn from the logs
21:50:35 <SamB> or at least, most people are lurking at any given time ;-P
21:50:49 <Makoryu> Lots of lurkers. Also, dons is omnipresent, so he's an exception anyway.
21:50:53 * wmealing__ is trying to learn, getting there ever so slowly.
21:51:55 <wmealing__> i see people do some amazing things.. i often wonder how long it would take me to get there.
22:02:12 <weirdo> dons, so far so good. reply to least-frequently-asked-question: don't keep broken references to packages in ~/.ghc or ~/.cabal
22:04:05 <nyingen> mueval and lambdabot are driving me nuts
22:04:39 <nyingen> I'm running a copy experimentally, but the @run command ignores resource limits
22:05:49 <nyingen> weirder still, running mueval outside of lambdabot works fine, its only inside of lambdabot that causes problems, and moreover, it only causes problems if run from irc (lambdabot -e '@run sum [1..]' behaves correctly)
22:09:41 <dons> weirdo: oh?
22:10:22 <dons> so you had a package.conf for ghc pointing to lots of packages that no longer existed?
22:10:24 <c_wraith> oh, yeah.  rebuilding stuff after setting the path correctly, you want to clear ~/.ghc and ~/.cabal
22:10:28 <weirdo> hold on. i had to remove the directory because rerunning ./configure apparently doesn't fix anything
22:10:32 <weirdo> yes
22:10:41 <dons> so they'd configure, then fail to build?
22:11:07 <dons> ok. not properly unregistered packages.
22:11:32 <dons> best to use "ghc-pkg unregister foo" when removing thiings (or zonk the entire package.conf and reinstall ghc)
22:14:06 <weirdo> nah, still whines about mtl
22:15:19 <weirdo> but there's already mtl in prefix/lib/ghc-foo
22:15:27 <dons> like this? http://trac.haskell.org/haskell-platform/ticket/92
22:17:00 <weirdo> now it works
22:17:08 <dons> what changed?
22:19:07 <weirdo> dons, i applied the patch
22:20:12 <dons> ok. good to know. you're on safe ground now then.
22:20:37 <dons> so a) no package system led to broken ghc package system. b) known bug with previously installed mtl (fixed in the head)
22:20:50 * dons feels comfortable now with the situation on weirdo's machine
22:44:57 <ivanm> dons: you still here?
22:47:30 <Cale> http://en.wikipedia.org/wiki/Harmonic_series_%28mathematics%29#Random_harmonic_series -- wow
22:48:13 <ray> good wow or bad wow
22:48:23 <Cale> good wow
22:48:29 <ivanm> yeah, wow
22:48:33 <ray> oh, wow
22:48:43 <ivanm> the 10^-42 is a definite wow
22:48:51 <ivanm> and not just because of the exponent :p
22:50:25 <ivanm> is it OK to do forkIO when using bracket?
22:50:35 * ivanm wouldn't think so, but if that's the case he might have some problems...
22:51:55 <Cale> well...
22:52:27 <Cale> Not if you're going to try to use the resource that the bracket deallocates.
22:52:46 <ivanm> I'm trying to fix up this function: http://hackage.haskell.org/packages/archive/graphviz/2999.5.0.0/doc/html/src/Data-GraphViz-Commands.html#graphvizWithHandle
22:52:53 <Cale> Unless you can be certain that the thread finishes before the bracket
22:53:16 <ivanm> and I was told that I had to use forkIO there for those two calls
22:54:37 <Cale> That a `seq` hClose outp seems dubious.
22:54:46 <ivanm> yeah, that's what I'm wanting to fix
22:55:09 <ivanm> dons told me to use rnf a `seq` hClose outp
22:55:16 <Cale> Tricky part is that a is polymorphic
22:55:32 <ivanm> oh, and that it should be wrapped in bracket
22:55:58 <ivanm> Cale: well, in the actual library I use it to get String output and to write to file
22:56:07 <Cale> Something really hacky that might work *okay* would be to rnf (show a) `seq` ...
22:56:08 <ivanm> which is why I need the polymorphic aspect
22:56:27 <ivanm> even if a :: () ?
22:56:36 <Cale> yeah
22:57:18 <Cale> What happens if you completely remove the hClose outp?
22:57:25 <Cale> The waitForProcess hangs?
22:57:32 <ivanm> Cale: well, it was there already...
22:57:51 <ivanm> but IIRC, it was there so that there wouldn't be random handles floating around opened...
22:57:55 <Cale> You could leave it up to f to close the handle.
22:58:06 <ivanm> hmmm...
22:58:12 <ivanm> true
22:58:23 <Cale> That way if you wanted to use lazy I/O, you just wouldn't close the handle
22:58:27 <ivanm> which is kinda bad in a sense...
22:59:08 <c_wraith> I feel like a file handle is a good thing to throw into a reader monad.
22:59:27 * ivanm isn't a big fan of IO :s
22:59:28 <c_wraith> Then you can just close it after runReader
22:59:37 <c_wraith> well, runReaderT
22:59:41 <c_wraith> since it also needs to do IO
22:59:58 <Cale> er... but that's not going to help the fundamental problem here.
23:00:09 <ivanm> heh
23:00:12 <Cale> That's equivalent to the (Handle -> IO a) type he's already using.
23:00:14 <c_wraith> oh.  I didn't read enough scrollback to get to the fundamental problem
23:00:56 <Cale> The problem is that when you have a higher-order IO action, the policy regarding how filehandles are managed gets complicated.
23:01:45 <c_wraith> it's true that a lot of types of apps can get away with just not closing them.
23:02:16 <c_wraith> but that's a bad general policy
23:02:32 <Cale> With lazy IO, you *must not* close them.
23:02:44 <Cale> Not until you're sure the result has been completely demanded.
23:02:55 <Cale> (and even then, they should close automatically)
23:03:20 <ivanm> they should, but you can't guarantee that?
23:03:43 <Cale> Well, they get closed when the thing is GC'd.
23:04:24 <Cale> So if the higher-order thingy gets a lazy-I/O-using parameter, and then closes the filehandle, things break.
23:05:37 <ivanm> so is doing something like this safe? \ h -> do c <- hGetContents h; hClose h; return c
23:06:02 <Cale> no
23:06:07 <ivanm> :(
23:06:16 <ivanm> what would be the safe way of using hGetContents then?
23:06:29 <Cale> hGetContents
23:06:37 <ivanm> oh, it closes the handle already? :o
23:06:47 <Cale> It will close the handle when it's done.
23:07:03 <Cale> The string that you get back from hGetContents is magic.
23:07:21 <Cale> When that string is demanded, the actual I/O happens.
23:07:35 <Cale> When you finish using the string, the handle gets closed.
23:07:39 <ivanm> :o
23:07:57 <Cale> I think there's an hClose tacked onto forcing the [] at the end of the string
23:08:19 <ivanm> right
23:08:30 <Cale> and Handles get closed when you lose your last reference to them, I think.
23:09:39 <Cale> Another option would be not to use normal hGetContents
23:09:52 <flux> ..but as GC isn't suitable for resources other than memory, it's not advisable to rely on GC doing it for you.
23:09:54 <ivanm> hey, if hGetContents does it automagically, that's OK with me!
23:09:56 <Cale> But to use the strict ByteString hGetContents, and convert the result to a String
23:10:38 <Cale> Limiting the number of open filehandles is stupid in the first place.
23:10:41 <flux> if you need to stop processing the contents, I suppose you can _either_ force it to the end (read all remaining elements) or just hClose it and swear you'll never touch the contents again :)
23:10:53 <flux> perhaps, but that's extremely difficult to fix
23:11:00 <flux> considering you need to fix all operating systems :)
23:11:12 <flux> but how about limiting the number of database connections?
23:11:22 <Cale> I don't really understand why there should be a limitation.
23:11:34 <Cale> Shouldn't the limitation be the amount of memory?
23:11:45 <flux> atleast postgresql uses non-trivial amount of resources per such connection
23:11:56 <flux> of course, you could just bump the limit very high
23:11:58 <Cale> I should just be able to open filehandles or database connections until I run out of memory.
23:12:06 <flux> but then you risk DOSsin the system when someone actually uses them all
23:12:13 <flux> systems just don't deal well in that situation
23:12:21 <flux> how does GHC deal when you run out of memory?
23:12:28 <Cale> With the artificial limitation, DOSsing the system is just easier.
23:12:36 <copumpkin> edwardk: I remember you said that a mealy machine is just a fixpoint of a -> (b, _). That looks very much like State... does that mean State is a mealy machine?
23:12:37 <flux> well, you DOS only one resource
23:12:44 <Cale> Well, I suppose it means you don't get the OOM killer
23:12:46 <flux> database systems have different limits for different users, user groups, etc
23:13:09 <flux> the rest of the database clients might not even notice someone leaking fds
23:13:23 <flux> ..especially there is a separate set of connections available for the superuser
23:15:03 <dolio> Stat isn't a fixed point.
23:15:05 <dolio> State, even.
23:15:34 <dolio> Aside from a trivial fixed point of the constant functor.
23:15:58 <copumpkin> dolio: but it definitely feels like there's some connection between bind on State and the fixpoint of that functor?
23:17:02 <dolio> Mealy machines by that definition would be: newtype Mealy a b = Mealy (a -> (b, Mealy a b))
23:17:26 <copumpkin> yeah
23:18:09 <dolio> That isn't a fixed point of State, though, because that would be like 'mu X. (X -> (b, X))'
23:18:18 <dolio> Or mu X. (s -> (s, X))
23:18:33 <dolio> Or something like that.
23:19:17 <copumpkin> yeah, so they aren't exactly the same, but they feel like they're pretty closely related
23:19:28 <dolio> I'm not sure which you're taking to be the state parameter.
23:19:35 <dolio> I guess it's a fixed point of indexed state.
23:20:36 <copumpkin> I just feel like it should be possible to write a bijection between the two, but maybe not
23:20:55 <copumpkin> not between the State type and Mealy, but a State computation and a Mealy
23:21:29 <Makoryu> http://www.clutter-project.org/ <- Now here is a toolkit I can abide by.
23:22:04 <copumpkin> hmm, maybe I should get back to what I should actually be doing for work and quit thinking about unrelated questions :)
23:22:30 <copumpkin> Makoryu: haskell bindings kthx
23:22:36 <Makoryu> copumpkin: Exactly.
23:22:45 <copumpkin> I vote for Makoryu doing them
23:22:52 * wmealing__ agrees
23:23:08 <wmealing__> Makoryu, how long will it take you ?
23:23:11 <Makoryu> I'll take a look at them. Surely it can't be too hard.
23:23:22 <copumpkin> damn GPL on it though
23:23:26 <Makoryu> Matter of hours, I'm positive.
23:23:27 <Makoryu> Eh?
23:23:29 <Makoryu> Damn.
23:23:33 <wmealing__> why is that a problem ?
23:24:03 <copumpkin> My flavor of groupthink is anti-GPL
23:24:12 <wmealing__> ah, continue then.
23:24:20 <Makoryu> wmealing__: A GPL library forces all apps that use it to be GPL
23:24:41 <wmealing__> even.. uses it ?
23:24:56 * Axman6 joins copumpkin's groupthink
23:25:01 * wmealing__ doesn't buy into it
23:25:01 <copumpkin> yay
23:25:13 * copumpkin sends thoughtpolice after wmealing__
23:25:27 * wmealing__ already has thoughtpolice here.
23:25:34 <copumpkin> :O
23:25:34 <Axman6> wmealing__: if it's using the LGPL, the code doesn't have to be GPL'd. but the GPL forces you to
23:25:47 <Makoryu> wmealing__: I seem to recall some court case where a dynamically linked GPL library resulted in an application being considered a derivative work.
23:26:15 <wmealing__> ah, its the LGPL that says 'you can use it'
23:26:16 <wmealing__> right.
23:26:34 <wmealing__> i wouldnt have thought so, its like using an API
23:26:35 <copumpkin> I don't actually mind the GPL in principle, but most of hackage is BSD right now and I like the additional freedom it gives people who use the libraries over GPL
23:26:37 <wmealing__> but.. what do i know
23:26:48 <wmealing__> is there a clutter like library for linux ?
23:26:59 <Makoryu> wmealing__: Clutter works on Linux.
23:27:01 <c_wraith> clutter is for linux...
23:27:17 <c_wraith> not exclusively, but if it targets gtk and gstreamer, it at least has a gnome frontend
23:27:25 <glguy> Of course GPL is a minefield if you want to do anything non-GPL with it. The point is to get to you use their license rather than deal with the intentional confusion
23:27:26 <Makoryu> Clutter seems nice because it's designed to be cross-platform in ways that GTK isn't.
23:27:45 <c_wraith> It also targets Cairo, which is mozilla's rendering engine, as I understand it.
23:28:38 <Makoryu> "Clutter is free software released under the GNU Lesser General Public License, version 2.1." <- Oh, phew!
23:28:50 <wmealing__> Makoryu,  i know what clutter is for, i was wondering if there was something with the same functionality that.. oh nevermind
23:29:19 <wmealing__> Makoryu, so you're in ! ?
23:29:19 <Makoryu> wmealing__: Something that's Linux-only, you mean? :p
23:29:25 <wmealing__> it.. doesn't bother me
23:29:41 <Makoryu> wmealing__: I am now completely into this project, yes.
23:29:47 <Makoryu> I think I will work on this.
23:29:49 <wmealing__> Makoryu, please keep me informed.
23:29:51 <wmealing__> wmealing@gmail.com
23:29:58 <DarkUnicorn> good morning
23:30:02 <wmealing__> very keen to see it happening.
23:30:20 <Makoryu> I'm really fed up with gtk2hs being the default Haskell toolkit, because GTK angers me.
23:30:22 <wmealing__> Makoryu, i'm rather knew to haskell, only done some very basic smelly code.
23:30:26 <Makoryu> So... yeah.
23:30:30 <wmealing__> good luck cowboy.
23:30:41 <Makoryu> wmealing__: I'm not terribly experienced myself, but we'll see what I can do.
23:30:44 <Makoryu> Not tonight though.
23:30:45 <wmealing__> :)
23:35:46 <trofi^w> Hi #haskell! I'm trying to register haskell function as a C callconv callback. It should be persistent. Ive written some code and have bunch of questions: http://code.haskell.org/~slyfox/ffi-cb-test-0.0.0.0.tar.gz
23:37:05 <trofi^w> First question. I believe this code is incorrect in respect to "-- FIXME:..." in Main.hs. How to achieve desired effect?
23:38:50 <blackh> trofi^w: my_c_cb won't get garbage collected
23:39:08 <blackh> FunPtrs are only cleaned up when you clean them up explicitly.
23:39:15 <trofi^w> that callback will be called slightly later - in do_stuff
23:39:22 <trofi^w> aha
23:39:51 <trofi^w> that was the second question, if it's not GCed - then there is a memleak (if reregister that callback many times)
23:40:03 <blackh> freeHaskellFunPtr is the function you want.  Yes - it is a memory leak if you don't call it explicitly.
23:40:19 <trofi^w> blackh: thanks a lot!
23:40:41 <blackh> You get one newly allocated each time you call 'wrap_cb'
23:40:47 <trofi^w> does reg_c_cb introduce any leaks?
23:41:24 <trofi^w> (it gets pointer to C function and just passes it)
23:41:55 <Tony[`]> hey can anyone remind me of the super-short sieve example using nubBy on an infinite list? :)
23:41:59 <blackh> I think I need to remind myself what "&" does
23:42:19 <trofi^w> and wrap_cb guarantees FunPtr won't move in memory, right?
23:42:30 <c_wraith> in C++?  & does like 4 things, depending on context. :)
23:42:35 <trofi^w> (or, the stuff it points to, thus not breaking C code)
23:42:41 <blackh> trofi^w: That's right - it looks like a C function pointer and stays put.
23:43:08 <c_wraith> I can only think of 3 things, but I'm sure I'm forgetting something.
23:43:30 <trofi^w> we are about 'foreign import ccall "&" reference_callback :: C_CB_T'
23:43:56 <c_wraith> oh.  that's in haskell then?  probably much easier to figure out. :)
23:44:07 <trofi^w> i might misuse it
23:45:00 <trofi^w> I still don't distinct it's usage when i need to declare C-reacheable object defined in haskell code and import static address of foreign C object
23:46:57 <Axman6> > let primes = 2 : nubBy (\x y -> y `mod`x == 0) [3,5..] in primes
23:46:58 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
23:47:04 <Axman6> Tony[`]: ^^
23:47:10 <Axman6> wait
23:47:18 <Axman6> > let primes = 2 : nubBy (\x y -> x `mod` y == 0) [3,5..] in primes
23:47:19 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:47:22 <Axman6> better
23:47:28 <blackh> trofi^w: I don't really know what "&" does.  I know that "&_something" gives you a Haskell function ptr to a C function.
23:47:37 <Tony[`]> Axman, I did it similarly, but I specifically remembered seeing someone do it with a reverse in there somewhere
23:47:46 <Tony[`]> so I was wondering why they used that, but I couldn't find the line itself
23:47:49 <trofi^w> and what if i want reverse behaviour?
23:48:09 <blackh> trofi^w: What do you want, exactly?
23:48:30 <trofi^w> I want to define function entirely in haskell
23:48:38 <trofi^w> which can be used in C
23:48:48 <blackh> trofi^w: You use "wrapper" for that.
23:49:10 <trofi^w> wrapper gives me pointer, but not name
23:49:55 <trofi^w> i want to link againts it as a usual C function. like having proto 'int foo(int)' and link againct library defining it
23:49:55 <blackh> trofi^w: I'm with ya. I'm not sure.  I've gotta go - catch ya later.
23:50:07 <trofi^w> ok, good luck
23:50:28 <mmorrow> trofi^w: the C function gets put into <module>_stub.{c,h} i believe
23:51:01 <Twey> trofi^w: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
23:51:01 <mmorrow> (the C-callable wrapper, that is)
23:51:53 <trofi^w> 'foreign export ccall fibonacci_hs' thanks Twey!
23:52:07 <Twey> Welcome o/
23:54:36 <mmorrow> trofi^w: you'll probably need this if you're doing some FFI hacking http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
23:55:49 <trofi^w> Ok. Seems I've clarified every bit. Thanks again!
23:57:35 <ray> ffi/ffi/ffi.html
23:58:10 <wmealing__> sounds like a daft punk song.
