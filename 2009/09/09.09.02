00:01:22 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
00:01:22 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
00:11:42 * Nafai installs the latest Haskell platform in an Ubuntu OpenVZ VE
00:11:55 <fynn> what's OpenVZ NE
00:12:02 <fynn> sounds way too 1337
00:12:14 <Nafai> OpenVZ is a virtualization solution, VE is "Virtual Environment"
00:12:31 <fynn> how is it like compared to VirtualBox?
00:12:36 <Nafai> It's better than a chroot but not as fancy as a full-on virtual machine
00:13:02 <Nafai> You are still running on the host kernel, but have limited resources, etc, and seem like a individual machine
00:13:23 <fynn> why use it rather than VB?
00:13:43 <Nafai> It allows you to run more isolated containers on lessor hardware
00:13:45 <Nafai> http://wiki.openvz.org/Introduction_to_virtualization
00:16:47 <mmorrow> Saizan: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3502
00:23:23 <gogonkt> c
00:23:36 <Nafai> c++
00:23:40 <mmorrow> --
00:23:43 <mmorrow> --
00:23:49 <gogonkt>  ~@_@~
00:24:07 <mmorrow> @quote comment
00:24:07 <lambdabot> Baughn says: remember that comments take up space in compiled Haskell programs, and furthermore they take up processing time if execution passes through them. For these reasons, keep comments to a
00:24:07 <lambdabot> minimum, and never put comments inside of optimized Haskell code. Ideally all of your comments will lie outside of the path of execution.
00:24:17 <mmorrow> @quote Help
00:24:17 <lambdabot> chessguy says: [in regards to #haskell] man, it's amazing the difference between what happens when someone asks for help here, and what happens when they ask for help in another language channel
00:24:30 <mmorrow> @quote {-Help!-}
00:24:30 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
00:24:34 <mmorrow> :(
00:27:17 <fynn> it's heroic that single C++ programmer singlehandedly won ICFP
00:27:45 <fynn> one man and his g++ against the colossal Haskell conglomerate
00:28:23 <mmorrow> yeah that's pretty badass that it was just him
00:28:48 <fynn> I wonder if there's more stuff on him online
00:29:04 <mmorrow> what was the problem this year again?
00:29:24 <erikc> mmorrow: make a virtual machine of some sort
00:29:32 <mmorrow> ah cool
00:29:59 <erikc> it isnt really surprising that C++ works well for small-scale tractable problems
00:30:26 <fynn> still impressive he solved it by himself
00:30:40 <fynn> tbh, I think the language is secondary at best in a problem like this
00:30:46 <erikc> yea, thats what i maen
00:30:56 <fynn> I meant it more generally :)
00:31:04 <mmorrow> erikc: otoh, spending 5 minutes looking at spidermonkey will take maybe 5 years off your life
00:31:12 <erikc> the problem isnt large enough to make language a significant issue
00:31:31 <erikc> mmorrow: haha, the spidermoney vm?
00:31:33 <fynn> in any programming contest that involves creative problem solving, 5% more talent wins everyday over 50% better language
00:31:38 <mmorrow> erikc: yeah
00:31:47 <mmorrow> erikc: c++ + vm made me immediately think of that
00:31:48 <fynn> I mean, how many times did a Java team take first place in ICFP?
00:32:48 <doserj> making the vm really was the trivial part of the contest
00:33:13 <mmorrow> err, wait am i thinking of spidermonkey? i may mean that newer one
00:33:15 <mmorrow> oh!
00:33:18 <mmorrow> squirrelfish
00:33:19 <erikc> tracemonkey
00:33:22 <erikc> oh
00:33:23 <mmorrow> heh
00:33:29 <nlogax> squirrelfish EXTREME
00:33:47 <nlogax> i think the pr folks dubbed it "nitro"
00:33:47 <mmorrow> it's as if nothing ever actually gets done in the code due to all the classes with boilerplate filler
00:34:22 <fynn> nlogax: seriously? SF code looked pretty clean.
00:34:32 * mmorrow quit trying to grok after a short while
00:34:35 <erikc> yea, at a certain point you cant see the forest for the trees
00:34:46 <mmorrow> fynn: i just mean how it's so spaced out
00:35:01 <nlogax> fynn: http://www.apple.com/safari/whats-new.html#performance "Nitro Engine" is squirrelfish (extreme) :)
00:35:02 <fynn> mmorrow: hm?
00:35:10 <fynn> nlogax: heh blah
00:35:20 <mmorrow> like, w/in a screenful of haskell code on a 1024x768 monitor, you could spend and hour just staring
00:35:47 <mmorrow> instead on neading 100 files open, 10 terminals with grep
00:35:51 <mmorrow> *needing
00:36:16 <mmorrow> i dunno, personal pet peeve is all :)
00:36:20 <erikc> at work today, i wrote 40 lines of haskell at 10 am, i spent the rest of the day implementing those 40 lines in C...
00:36:32 <mmorrow> heh, totally
00:36:53 <ketil> Is the ICFP results posted anywhere?
00:37:11 <doserj> http://twitter.com/liyanghu/status/3691832714
00:38:02 <mmorrow> fynn: but yeah, it was pretty clean
00:39:41 <fynn> mmorrow: Haskell is definitely more terse than even a good C++ project
00:41:32 <ketil> doserj, thanks.  (and I goes got coffee for benefit grammar worsen)
00:43:38 <mmorrow> ah nice, just randomly stumbled across this handay one-liner in a file
00:43:42 <mmorrow> @let reachable f a = let go seen a = let s = f a; as = S.toList (s `S.difference` seen) in foldl' go (s `S.union` seen) as in go (S.singleton a) a in reachable
00:43:43 <lambdabot>   Parse error
00:43:47 <mmorrow> :o
00:43:53 <arw_> 'map foo bar' vs. 'for (bar::iterator b = bar.begin(); b != bar.end(); b++) foo(b);'. what more is there to say?
00:43:54 <mmorrow> @let reachable f a = let go seen a = let s = f a; as = S.toList (s `S.difference` seen) in foldl' go (s `S.union` seen) as in go (S.singleton a) a
00:43:55 <lambdabot>  Defined.
00:44:02 <mmorrow> @type reachable
00:44:03 <lambdabot>     Ambiguous occurrence `reachable'
00:44:03 <lambdabot>     It could refer to either `L.reachable', defined at <local>:16:0
00:44:03 <lambdabot>                           or `Data.Graph.reachable', imported from Data.Graph
00:44:07 <mmorrow> sigh
00:44:14 <mmorrow> @let reach f a = let go seen a = let s = f a; as = S.toList (s `S.difference` seen) in foldl' go (s `S.union` seen) as in go (S.singleton a) a
00:44:15 <lambdabot>  Defined.
00:44:18 <mmorrow> @type reach
00:44:19 <lambdabot> forall a. (Ord a) => (a -> S.Set a) -> a -> S.Set a
00:47:41 <mmorrow> > let g = (fmap S.fromList . M.fromList) [(0,[1,2]),(2,[]),(9,[4]),(1,[0,9]),(3,[4,7,5]),(4,[9])] in reach (g M.!) 0
00:47:42 <lambdabot>   fromList [0,1,2,4,9]
00:48:21 <fynn> mmorrow: (that said, I bet you're comparing a non-production piece of code to a production one ;)
00:49:01 <fynn> production code tends to have all sorts of odds and ends, and needs to be split across multiple files
00:49:18 <fynn> (although file-splitting can be more elegant than what C/++ offers)
00:50:03 <mmorrow> fynn: i just mean in the sense that i personally prefer the greater information-density per loc (including spaces) of haskell code to C++
00:51:28 <erikc> the c++0x lambda funcs + auto keyword will probably help eliminate ~25% of c++ token boilerplate alone
00:51:35 <mmorrow> another way to say it is, imagine you have a single terminal, less, and grep.
00:51:43 <mmorrow> and that's all you get
00:53:18 <yitz> mmorrow: is that supposed to be Dijkstra or something?
00:53:24 <mmorrow> erikc: do you know of a link the spec for these c++ lambda functions?
00:53:39 <mmorrow> yitz: heh
00:53:59 <mmorrow> yitz: if that was the case, then you'd have to s/less/more/
00:54:24 <mmorrow> "don't hit pagedown unless you **really** mean it!"
00:55:47 <yitz> mmorrow: it's not really information density, it's information cleanliness. Cf. Perl.
00:56:14 <mmorrow> (i'm trying to put what i'm thinking of into a single descriptive sentence, but struggling..)
00:56:49 <mmorrow> yitz: hmm, yeah that may say it
00:57:14 <Berengal> "SNR" I believe the term is
00:57:26 <Berengal> With some minor abuse
00:58:29 <yitz> Berengal: you could say bzip2'ed haskell has an even higher SNR, but I wouldn't want to have to read a screenful of that.
00:59:06 <Berengal> yitz, depends on your definition of s and r
00:59:12 <Berengal> n*
00:59:22 <yitz> ok
00:59:46 <Berengal> (I know they have formal definitions, but this is where the abuse comes in. Genious!)
01:01:18 <erikc> mmorrow: http://msdn.microsoft.com/en-us/library/dd293608(VS.100).aspx
01:01:20 <mmorrow> related to this, gah! i hate when code has massive comments interspersed throughout it so you can't even see what's happening in the code due to all the paragraph+ of text *for every single source code line*
01:01:38 * mmorrow has nightmares about this
01:01:42 <mmorrow> erikc: thanks
01:02:07 <erikc> mmorrow: without gc, they are a bit gimped, but they'll at least eliminate one-off 'function objects'
01:03:48 <mmorrow> erikc: yeah, but otoh even being restricted to "downward" uses is still gives you a hugely useful thing
01:04:45 <Berengal> If only java had lambdas :(
01:05:47 <Berengal> The scary thing is that when I introduces MonadicFunction<Arg, Ret> and DyadicFunction<Arg1, Arg2, Ret> in my project, the code size was still reduced by 25%
01:06:21 <dibblego> Berengal, telled ya (Functional Java)
01:07:13 <Berengal> dibblego, I know, but it introduces yet another dependency. Anyway, I'm not in the habbit of playing around with java in my time off
01:07:52 <dibblego> why not push for Scala anyway?
01:08:17 <Berengal> Might just as well. I'll have to learn it properly first of course...
01:08:32 <dibblego> vast improvement on Java at least
01:08:47 <dibblego> though that's not necessarily saying a lot
01:08:50 <Berengal> Yes, but it's not Java, which is wherein the problem lies
01:08:59 <dibblego> the problem?
01:09:16 <Berengal> ¬java -> ¬good enough for work
01:09:23 <Berengal> :(
01:09:24 <Nafai> dibblego: I think he's saying that being on the JVM and interoping with Java isn't enough
01:09:29 <dibblego> you work with dummies?
01:09:53 <Berengal> They apparantly think learning a new language is like learning to program all over again
01:09:54 <dibblego> Nafai, that's all the Java language does
01:10:04 <dibblego> ah, my sympathies :(
01:10:36 <Berengal> This despite them using php and sql all the time...
01:10:51 <Berengal> (For legacy systems mind you)
01:10:57 <Nafai> dibblego: Hey, I know...just saying what the management and lazy coworkers are probably saying
01:10:58 <dibblego> so then it's not "learning a new language", rather "learning how to program"
01:12:41 <Berengal> I'm probably too harsh on them. The real cause is probably the corporate "industry best practice" cargo cult
01:13:13 <Nafai> Berengal: What you are saying doesn't sound too outlandish :(
01:13:50 <dibblego> I've converted lots of those types over time
01:14:12 <Berengal> I hope to as well.
01:14:15 <Nafai> That would be great
01:14:23 <arw_> i've got the exact same problem here with c++. legacy code, coworkers, "everybody else does it"
01:14:26 <Nafai> I'm hoping to introduce Haskell for projects here at work
01:14:29 <Berengal> I see a very small, narrow opening in the current project
01:14:39 <dibblego> you must prescribe a nice cold glass of harden the fuck up, without them knowing you're doing it
01:14:40 <Nafai> But I don't see that happening and I'm stuck with Python
01:16:16 <Berengal> I need to somehow ceverly expand the java language until it turns into Haskell
01:16:40 <dibblego> that's precisely what we do :)
01:17:13 <taruti> What LANGUAGE extension enables '#' in names?
01:17:26 <Deewiant> MagicHash
01:18:38 <dons> ?bug
01:18:38 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
01:19:38 <taruti> Deewiant: thanks
01:27:51 <quicksilver> Berengal: more like, learning a new language would require, for them, actually learning to program for the first time ;P
01:29:54 <Berengal> quicksilver, who knows... At least one guy knows C++ though, but he still thinks C++ and Java are widely different langguages
01:31:15 * Berengal is a member of the "you can't program until you can do it in ten different languages" club
01:31:32 <Berengal> (Although admittedly I only know Haskell and Blub myself)
01:51:44 <cads> Berengal: I think people aren't programmers till they can write proofs about their programs and use something like Z-notation to specify everything :)
01:52:00 * cads is relieved that he's not yet a programmer
01:52:27 <medfly> lol
01:52:59 <jorick> nah that would be more like a computer scientist, a programmer uses VBA to automate his excell sheets
01:54:27 <cads> well someone's gotta do the hotshot rocket science programming for nasa and such, and it's not the #ruby crowd
01:54:35 <hackagebot> bytestring-nums 0.3.1 - Parse numeric literals from ByteStrings. (JasonDusek)
01:54:42 <cads> probably the #fortranners
01:54:51 <cads> unfortunately :P
01:55:19 <cads> these days I here there's a lot of technical computing done in python
01:56:35 <cads> hrm, why am i hating
01:58:01 * ksf wants "cabal init"
01:58:21 <cads> hey, is there a paper talking about the theory of haskell extensions, how they're written, how it is that the system is designed to allow extensions, etc?
01:58:51 <cads> hehe, I say 'the theory', but I don't mean some formal description
02:00:05 <cads> I'd like to know stuff like whether extensions are supported by the standard, or just by specific compilers, and maybe see a survey of some of the details of the neater extensions, etc
02:00:51 <Saizan> you want to look at the haskell' trac
02:00:53 <cads> I love how every single innovative and neat aspect of haskell tends to have a paper written about it out there somewhere, and I'm hoping it'll be the case here :)
02:01:25 <Saizan> http://hackage.haskell.org/trac/haskell-prime/
02:01:43 <Saizan> that's the standardization process ^^^
02:02:40 <cads> we're getting a haskell 2010?!
02:03:03 <cads> should I be excited?
02:04:19 <Peaker> cads: I think Python is the nicest untyped language :)
02:04:26 <Saizan> cads: not really, it won't change much
02:04:43 <Saizan> cads: in the sense that it's just a collection of extensions
02:04:54 <vegai> Peaker: http://factorcode.org :)
02:04:59 <ksf> are there default monoid infix functions, somewhere?
02:05:11 <Saizan> no
02:05:13 <Peaker> @hoogle Monoid m => m -> m -> m
02:05:13 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
02:05:13 <lambdabot> Prelude asTypeOf :: a -> a -> a
02:05:13 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
02:05:42 <Peaker> vegai: in what senses is Factor nicer than Python?
02:06:21 <Peaker> also, I could say Python is the nicest untyped language that uses mostly widely known abstractions, even amongst non-programmers, so has a nice/simple learning curve (At least used to, before they added a myriad of features)
02:06:28 <cads> ruby is nicer than python if you're into those wierd object oriented systems
02:06:33 <vegai> Peaker: their implementation is modern
02:06:41 <Peaker> cads: I think Ruby is Python with an ugly syntax :-)
02:06:50 <cads> I think its syntax is 'friendlier'
02:07:11 <vegai> factor's learning curve might be rather bad
02:07:22 <cads> and its library support?
02:07:41 <etpace_> Is there a page anywhere with classes 'up' to Arrows, and their class declerations?
02:08:17 <cads> peaker, the ruby implementation still blows chunks, there's no formal semantics, it doesn't have anywhere near as many useful libraries python, so on and so forth
02:08:25 <Peaker> vegai: its funny they use a Dinasour as an icon, it does make you think of ancient bygone languages
02:08:29 <cads> dang it, I don't know why I just have a soft spot for it
02:08:39 <ksf> hmmm <+>, <0> and <*>?
02:08:46 <ksf> that is, mappend mempty mconcat.
02:08:50 <ksf> not sure about <*>.
02:09:04 <Peaker> cads: Ruby's Perlisms make it horrible, IMO. Ambiguity w.r.t () use. Regexps in the syntax, sigils being optional. Yuck!
02:09:27 <ksf> grrr <0> doesn't lex.
02:09:30 <vegai> Peaker: I think it's a joke on the word 'raptor'
02:09:35 <Peaker> ksf: ++ can be mappend
02:09:55 <ksf> (++) is monomorphed to lists
02:10:02 <Peaker> ksf: unmonomorph it :)
02:10:03 * doserj likes <> for mappend, ++ for mplus
02:10:08 <Peaker> ksf: e.g: What Control.Category did
02:10:11 <vegai> Peaker: and if you squint, it's a bit like lambda :P
02:11:40 <ksf> well I wrote a wrapper around c bitsets and just want to have a pre-defined operator to do the set union.
02:11:48 <ksf> (which is mappend)
02:12:01 <cads> Peaker, I've never tried to program any involved algorithm in python but in ruby you have some useful functional idioms to use, and lambdas to pass around at least
02:12:21 <cads> though I understand python has something called a generator for use instead of a lambda abstraction
02:12:22 <ksf> Read <+> Write <+> CloseOnExit doesn't seem too bad.
02:12:49 <ksf> better than toSet [Read,Write,CloseOnExit]
02:13:12 <Peaker> cads: Python has a slightly more cumbersome syntax for blocks than Ruby (about 4-5 characters more, and a name you have to specify) when your blocks are not expressions
02:13:19 <Peaker> cads: but I don't think its such a big deal
02:13:46 <Peaker> cads: And generators are not "lambda abstractions" they are basically lazy lists (that can do I/O lazily, too)
02:15:10 <cads> It may have been something else, but it was suggested as an alternative to lambdas, as those were to be removed from the language
02:15:11 <ksf> @hoogle <|>
02:15:11 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
02:15:11 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
02:15:11 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
02:15:14 <ksf> @hoogle <+>
02:15:14 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
02:15:14 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
02:15:14 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
02:16:55 <cads> haha, Peaker, basically I hate python because I started programming in ruby and python always had the library I wanted, and because I read an article stating that the inventor of the language doesn't think lambdas are necessary for it...
02:17:14 <ksf> tail recursion!
02:17:17 <ksf> tail recursion!
02:17:20 <cads> I think it's gotten to be a form bigotry on my part though
02:17:25 <ksf> there's no need to read sicp!
02:17:28 <cads> wait it has no tail recursion?
02:17:52 <ksf> no it would confuse coders not to get the stacktrace they expect.
02:17:58 <cads> wait that's right he spoke smack about tail recursion too
02:18:44 <cads> I dunno, I'd rather do science in haskell or lisp or... :P java
02:19:26 <Peaker> cads: lambdas are really just syntax here.  Python loses the syntax advantage on easy anonymous functions, but wins everywhere else on Ruby, IMO.  And it would be hard to put anonymous blocks into Python without destroying its simple indentation-based blocks
02:20:04 <Peaker> cads: in Ruby you'd  use [ blah ]  and in Python, you might have to:  def name(): blah ; <use name here>
02:20:22 <ksf> ruby and python both loose on typing.
02:20:35 <cads> Peaker, clojure is a pretty sweet for an untyped language, have you checked it out?
02:21:08 <arw_> i thought python also had no tail recursion because functional programming in python would then be a viable option?
02:21:35 <ksf> If I feel like doing duck-typing, I can perfectly well programm in haskell types. No need to use one of those "scripting" languages.
02:21:52 <cads> it's lisp built on top of the jvm, with real good concurrency and laziness primitives built in, as well as good persistent map and array data structures
02:22:19 <cads> ... I hate that its built on the jvm.
02:22:40 <cads> .. but it makes using java libraries palatable...
02:22:45 <Peaker> cads: no, I can't stand the JVM :)
02:23:12 <Peaker> arw_: It might make stack traces harder to implement, and Python does not really support FPL despite what some would say
02:23:13 <cads> yeah I want to harm myself for the last thing I said
02:23:23 <arw_> Peaker: http://mail.python.org/pipermail/python-dev/2004-July/046201.html
02:23:39 <cads> making programming 'palatable' should not be what I choose a programming language for :P
02:24:20 <cads> enlightening, fun, sexy, that is what I prefer
02:24:33 <Peaker> arw_: "so we could probably construct the stack
02:24:33 <Peaker> trace after-the-fact if needed." -- how would you know the local variable values?
02:24:38 <Peaker> oops
02:25:04 <cads> arw, what do you think about the dependently typed languages?
02:25:36 <cads> hehe, we go from languages with duck type systems to language with purely undecidable type systems :)
02:26:29 * ksf still has to see something that you can't code up in type families
02:26:32 * cads has been looking for a language that shares more of the symbols and syntax he uses when doing math
02:26:53 <ksf> cads, have a look at the agda standard lib.
02:26:58 <ksf> you're soon going to hate it.
02:27:38 <cads> coq isn't much better
02:28:04 <cads> it takes an awful lot of effort to explicitly explain to a computer _everything_ you're doing when you do a proof
02:28:28 <ksf> agda is actually a secret mindwar-weapon of the illuminati, who want to wrack your nerves with excessively big symbol sets requiring a keyboard with 10 modifier keys. just like APL.
02:28:38 <cads> when you do math you gloss over a phenomenal amount of stuff
02:29:46 <ksf> someone's going to implement a proof inference engine on top of type families, I bet. to enhance the quality of inferred types.
02:30:14 <arw_> cads: nothing really. i've never used it i guess, and i don't have a clear idea what one would get from it.
02:30:59 <cads> imagine typesetting programs in natural language mixed with informal math symbolism, and giving them to a expert system that interprets my mathematical chickenscratch as a actual computation in the category you're working in
02:31:13 <etpace_> > map pure [1..5]
02:31:14 <lambdabot>   No instance for (GHC.Show.Show (f a))
02:31:14 <lambdabot>    arising from a use of `M5600232147...
02:31:29 <ksf> arw_, I think using a thing like coq is somewhat like normal programming. just instead of specifying a thing that computes an interesting value, you specify a thing that cumputes a thing that inhabits an interesting type.
02:31:43 <ksf> I guess you have to be a total nerd to enjoy that.
02:32:06 <arw_> sounds a little like logical programming, prolog and stuff?
02:32:16 <ksf> > map pure [1..5] :: [[Int]]
02:32:17 <lambdabot>   [[1],[2],[3],[4],[5]]
02:32:39 <pozic> Anyone familar with XPath 1.0? I believe a certain implementation is wrong, but it could be my input. The input is: //Route[@a >= "0.9.9"]
02:32:42 <ksf> nah prolog actually computes interesting values.
02:32:48 <etpace_> > map head.pure [1..5] :: [[Int]]
02:32:49 <lambdabot>   Couldn't match expected type `[[GHC.Types.Int]]'
02:33:05 <etpace_> > map (head . pure) [1..5] :: [[Int]]
02:33:07 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Int])
02:33:07 <lambdabot>    arising from the arithme...
02:33:17 <ksf> > map (head.pure) [1..5] :: [Int]
02:33:18 <lambdabot>   [1,2,3,4,5]
02:33:22 <etpace_> doh
02:33:24 <ksf> head.pure = id
02:33:26 <cads> ksf, would you say that any of the dep. typed languages could be called 'friendly' for new users?
02:33:44 <idnar> @type head.pure
02:33:45 <lambdabot> forall a. a -> a
02:33:49 <ksf> nope.
02:33:54 <ksf> at least not friendly to me.
02:33:57 <cads> haha
02:34:02 <idnar> @type const undefined
02:34:04 <lambdabot> forall a b. b -> a
02:34:10 <cads> twelf seems interesting
02:34:21 <idnar> @type (undefined `asTypeOf`)
02:34:22 <cads> and bit-C
02:34:23 <lambdabot> forall a. a -> a
02:34:47 <ksf> cads, have a look at this: http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
02:35:10 <ksf> ...especially the second section.
02:35:25 <cads> it's kind of wild, bit-C is a low level programming language meant to serve the role C might serve instead, for the koyotos operating system or something
02:35:35 <etpace_> :t const
02:35:36 <lambdabot> forall a b. a -> b -> a
02:35:44 <cads> but it is dependently typed as well
02:36:47 <ksf> I doubt that dependent typing per se is of much use, except if you need a proof that your program doesn't loop.
02:36:58 * cads has not programmed using a type family yet
02:36:59 <idnar> I don't think I understand dependent typing at all
02:37:52 <Peaker> cads: bitC is dead, I think
02:37:52 <cads> ksf, little utility proofs like that are useful in kernel code, where you absolutely don't want any bugs you can avoid
02:38:02 <Peaker> idnar: do you understand Curry Howard?
02:38:20 <ksf> cads, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8960#a8960
02:38:35 <idnar> Peaker: probably not
02:38:43 <Peaker> idnar: its pretty much the basis of Dependent Typing
02:38:52 <Peaker> idnar: Curry Howard Isomorphism is pretty simple and very cool
02:39:19 <ksf> it's the basis of all typed functional programming
02:39:20 <Peaker> idnar: In a total functional language, types are like logic propositions, and values of those types are like proofs of those propositions
02:39:30 <idnar> I can tell you what the CurryâHoward isomorphism is, but I don't think I can say I understand it in any meaningful sense
02:39:31 <cads> idnar, basically the category of proofs of statements has a intimate connection to a category of dependent types, and this lets you write programs that represent math proofs directly
02:39:40 <Peaker> ksf: you don't have to know/understand CH to do typed FP
02:39:51 <ksf> nope, but it helps.
02:40:29 <ksf> I also don't have to grok electronics to use a phone.
02:40:41 <Peaker> idnar: well, I can try to explain what I understood about DT from the Epigram paper "Why Dependent Types matter"
02:40:58 <Peaker> ksf: did CH have to be understood to design FP languages?
02:41:05 <cads> how'd epigram doing, peaker?
02:41:21 <ksf> Peaker, CH predates most fp languages.
02:41:30 <ksf> ...at least them typed ones.
02:41:30 <Peaker> cads: I don't know, I only read that paper and was amazed at the achievements in the DT field :)
02:41:33 <opqdonut> Peaker: no, it's certainly not necessary
02:41:39 <Peaker> ksf: but how does it help in designing them?
02:42:02 <ksf> because you can line up those foo :: and foo = lines and see that they match 1:1
02:42:07 <Peaker> idnar: lets look at the type of "fix"
02:42:17 <Peaker> idnar: do you understand what logical proposition it represents?
02:42:35 <ksf> :t (+)
02:42:36 <lambdabot> forall a. (Num a) => a -> a -> a
02:42:39 <Peaker> :t fix
02:42:40 <lambdabot> forall a. (a -> a) -> a
02:42:52 <idnar> Peaker: no
02:43:07 <ksf> (+) means: if you have an a, that implies an implication that if you have another a, you have another a.
02:43:13 <ksf> :t (==)
02:43:14 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:43:19 <ski> @remember ksf agda is actually a secret mindwar-weapon of the illuminati, who want to wrack your nerves with excessively big symbol sets requiring a keyboard with 10 modifier keys. just like APL.
02:43:19 <lambdabot> It is stored.
02:43:32 <Peaker> idnar: (a -> a)  means that "if a is true, then a is true" and is definitely a true proposition. To prove (a -> a) you just construct   f x = x   and you have proven it.  You're basically saying: Given a proof that "a" is true, of course I can generate a proof that "a" is true
02:44:11 <Peaker> idnar: Now,  (a -> a) -> a   means  "if the proposition (a -> a) is true, then a is true".  Is this true?
02:44:12 <ksf> (==) means: if you have an (Eq a), that implies that if  another (Eq a) (both 'a"s match) implies a Bool.
02:44:31 <ksf> that is, -> isn't chosen at random: it really _means_ logical implication.
02:45:21 <idnar> Peaker: presumably it is true, but I don't see why
02:45:25 <Peaker> idnar: its not true
02:45:34 <Peaker> idnar: the reason a value for "fix" exists in Haskell, is because Haskell is not a total language
02:46:22 <Peaker> idnar: Haskell cheats here, and is allowed to use circular logic here -- to say "fix" is true only because the proof called "fix" already exists.  The fact the logic is circular and does not actually terminate into a proof sequence is represented by the fact that this does not halt
02:46:30 <Peaker> @src fix
02:46:30 <lambdabot> fix f = let x = f x in x
02:46:32 <etpace_> > Just (+1) <*> Just 3
02:46:33 <lambdabot>   Just 4
02:46:40 <etpace_> > Just (+1) <*> Nothing
02:46:41 <lambdabot>   Nothing
02:46:44 <ski> (though `[] ([] a -> a) -> [] a' is provable in logic ..)
02:46:48 <Peaker> idnar: the type    (a -> a) -> a   is not inhabitable in total languages
02:47:26 <Axman6> > fix (1:)
02:47:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:47:30 <Axman6> pew!
02:47:31 <Peaker> idnar: so Haskell values are not actually proofs, unless they are total
02:47:33 <ksf> ...but "fix f" can be proven true, for some f.
02:47:49 <ksf> that's why it's in the laguage, otherwise, it wouldn't be of any use.
02:48:28 <ski> (there the proposition `[] a' states "`a' is provable")
02:48:34 <Peaker> idnar: do you understand how logical And and Or are represented in C-H?
02:48:39 <cads> using any standard haskell feature, can a write a function called functional:: ân::(n>0, nâN). R^n -> R, to denote the type of a function which knows how to map R^n into R for any n?
02:48:43 <quicksilver> fix proves everything.
02:48:44 <ksf> well, it's dependent typing that's about crossing of the type/value border in the direction values -> types.
02:48:51 <quicksilver> once you have fix, all types are inhabited and CH becomes useless.
02:49:14 <Peaker> quicksilver: I thought all false propositions prove everything
02:49:19 <ksf> haskell only can cross the border from types to values, which is _far_ less problematic, and does not need as rigorous proofs.
02:49:32 <quicksilver> Peaker: indeed.
02:49:43 <Peaker> http://en.wikipedia.org/wiki/Principle_of_explosion
02:49:45 <quicksilver> Peaker: depending what you mean by 'false'
02:49:57 <quicksilver> Peaker: it's not true that all unprovable propositions prove everything.
02:50:12 <cads> ksf, is my example above, where n is free to range over all the natural numbers but one, and example of a function with a dependent type?
02:50:22 <Peaker> quicksilver: because some truths are unprovable, I'd venture
02:50:35 <quicksilver> Peaker: but it is true that all provably false propositions prove everythign, and it is also true that fix proves everything.
02:50:37 <ski> cads : `(R,[R]) -> R' ?
02:50:41 <ksf> a dependent type is a type that depends on a run-time value.
02:50:49 <quicksilver> exercise for the reader: is fix provably false?
02:51:01 <Peaker> @djinn (a -> a) -> a
02:51:02 <lambdabot> -- f cannot be realized.
02:51:07 <Peaker> yes! :-) j/k
02:51:09 <ksf> ...in some sense, that's old stuff: lisp people have been tagging their data for ages.
02:51:27 <pr> @djinn a -> a
02:51:27 <lambdabot> f a = a
02:51:37 <Peaker> quicksilver: well, if you assume fix and get a contradiction, then you've proven fix false?
02:51:47 <cads> ski, hehe, turning the vectors into lists is cheating :)
02:51:58 <quicksilver> right.
02:52:00 <Peaker> idnar: you following?
02:52:04 <ski> (cads : why ?)
02:52:34 <cads> well, I'd like functional to take tuples of varying size
02:52:55 <pr> why would you want tuples?
02:53:06 <pr> tuples don't enforce a type
02:53:30 <cads> tuples in R^n :D
02:54:39 <cads> tuples in haskell are a little different than math tuples I think, I'm not trying to be difficult
02:54:54 <cads> I guess lists are a good representation of vectors
02:55:26 <pr> well, i don't think they are that different. it's not like a "math tuple" consists only of things of the same type (set, whatever)
02:56:22 <pr> cads: you may find some useful package (for what you are doing/going to do) on http://hackage.haskell.org
02:56:30 <ksf> let's say I have a function foo :: (((Nat a) `Lt` (S (S (S Z))  ~ T)  => a -> IO (). how much stuff can I do with a at the value level, or, put differently, what do I have to _do_ at the value level to prove to the type checker that the runtime value, be, in every case, smaller than 3?
02:57:02 <cads> well, with a tuple type, I'm able to write f:(a,b,c) -> d, and then f is well typed only if applied to tuples not only of the same length as (a,b,c), but also containing the same respective types
02:58:37 <pr> @type \(a,b,c) -> (c,b,a)
02:58:38 <lambdabot> forall t t1 t2. (t, t1, t2) -> (t2, t1, t)
02:59:06 <pr> @type \[a,b,c] -> [c,b,a]
02:59:07 <lambdabot> forall t. [t] -> [t]
02:59:52 <etpace_> :t let foo g xs = flip fmap (pure . g) xs in foo
02:59:53 <lambdabot> forall a b (f :: * -> *) b1. (Applicative f) => (a -> b) -> (f b -> b1) -> a -> b1
03:00:04 <HugoDaniel> convertible doesn't build on ghc 6.10 :(
03:00:25 <HugoDaniel> is there any way to get around it, and having hdbc support on a installed haskell platform ?
03:00:50 <cads> pr, say you have a function that is well typed for vectors of only dimension less than  or equal to 3, with the list approach you'll just have your function throw an error when the dimension is anything higher
03:01:22 <ksf> HugoDaniel, http://hackage.haskell.org/packages/archive/convertible/1.0.5/logs/failure/ghc-6.10
03:01:33 <ksf> ...I bet that can be fixed by using old-time instead of time.
03:01:33 <pr> > fst ()
03:01:34 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `()'
03:01:37 <ksf> never did that though.
03:02:13 <pr> cads: yup
03:02:14 <etpace_> :t let foo x f = fmap (join . f) x in foo
03:02:15 <lambdabot> forall (f :: * -> *) a (m :: * -> *) a1. (Functor f, Monad m) => f a -> (a -> m (m a1)) -> f (m a1)
03:02:20 <cads> but if you could communicate to your type checker that the function can only ever be applied to the type of lists of numbers of length <= 3, then the checker could ostensibly look through your program and make sure you never try to call the function on a 4d vector
03:02:25 <ksf> oh it's already using old-time.
03:02:31 <idnar> Peaker: sorry, got pulled away
03:02:46 <pr> > let f (a,b,c) = (c,b,a) in f (5,4,3,2)
03:02:47 <lambdabot>   Couldn't match expected type `(t, t1, t2)'
03:02:59 <idnar> Peaker: I think I'm with you so far
03:03:11 <pr> > let f [a,b,c] = [c,b,a] in f [5,4,3]
03:03:12 <lambdabot>   [3,4,5]
03:03:13 <HugoDaniel> maybe i should get in contact with the maintainer and ask him about this
03:03:14 <pr> > let f [a,b,c] = [c,b,a] in f [5,4,3,2]
03:03:15 <lambdabot>   * Exception: <interactive>:1:153-171: Non-exhaustive patterns in function f
03:03:37 <cads> :)
03:03:43 <etpace_> > fmap (join . Just) $ Just 5
03:03:44 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
03:03:45 <lambdabot>    arising from the lite...
03:04:04 <etpace_> > join . Just $ 5
03:04:05 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
03:04:05 <lambdabot>    arising from the lite...
03:04:11 <cads> pr, the pattern [a,b,c] does not match all objects of list type
03:04:12 <etpace_> hm?
03:04:16 <ski>  fmap (join . Just) $ [Just 5,Just 3]
03:04:18 <pr> cads: true
03:04:19 <ski> > fmap (join . Just) $ [Just 5,Just 3]
03:04:20 <lambdabot>   [Just 5,Just 3]
03:04:23 <HugoDaniel> so there is no way to have HDBC in a freshly installed haskell platform ?
03:04:50 <ksf> HugoDaniel, you could also use takusen.
03:05:08 <etpace_> :t fmap
03:05:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:05:11 <etpace_> :t (>>=)
03:05:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:05:17 <ksf> ...or hsql
03:05:22 <ski> @type (=<<)
03:05:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:05:46 <etpace_> isnt x >>= f = fmap (join . f) x?
03:06:05 <etpace_> as join . f should make (a -> m b) into (a -> b)
03:06:17 <pr> > let f :: forall t . (t,t,t) -> (t,t,t); f (t1,t2,t3) = (t3,t2,t1) in f (1,2,3)
03:06:18 <lambdabot>   (3,2,1)
03:06:23 <pr> > let f :: forall t . (t,t,t) -> (t,t,t); f (t1,t2,t3) = (t3,t2,t1) in f (1,2,"a")
03:06:24 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
03:06:24 <lambdabot>    arising from the literal ...
03:06:32 <pr> i see
03:06:36 <pr> so you have to enforce the type cads
03:06:48 <cads> pr, I don't think that these properties are decidable at compile time without extreme effort
03:07:00 <cads> so your idea of an error message is better :)
03:07:03 <yitz> etpace_: no, it's join . fmap f
03:07:10 <ski> etpace_ : no, `x >>= f = join (fmap f x)'
03:07:36 <cads> shooth, I must go to bed
03:07:43 <cads> goodnight all
03:07:51 <pr> good night
03:07:56 <etpace_> that makes sense
03:08:33 <ski> > join . fmap Just $ Just 5
03:08:34 <lambdabot>   Just 5
03:08:38 <etpace_> > let foo x = join . (:[]) $ x in foo 5
03:08:39 <lambdabot>   No instance for (GHC.Num.Num [a])
03:08:39 <lambdabot>    arising from the literal `5' at <inter...
03:08:46 <yitz> @type \f -> join . fmap f
03:08:48 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
03:09:26 <taruti> Is somewhere a comparison between arrows and applicatives? I'm pondering which makes more sense for a datatype that could be either.
03:09:43 <taruti> which is less painfull in user code?
03:10:06 <etpace_> Why does my attempt generate the incorrect type? does join . (a -> m b) not pot produce a function (a -> b)?
03:10:23 <yitz> @type join
03:10:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:10:44 <yitz> it requires a m (m a), not just an m a
03:11:06 <ski> etpace_ : given `f :: Monad m => a -> m (m b)', you get `join . f :: Monad m => a -> m b'
03:11:10 <doserj> and it can only produce a 'm b', not just a 'b'
03:11:17 <etpace_> ahh
03:11:26 <etpace_> I was thinking join was m a -> a
03:11:28 <cads> }]}]]]]}]]]]}}}}}}}]]]]]}}}}}}]]]]]]]]]]]]]]]]]]]]]]]]\\\\\\\\\\\|\\\\\\\\\\\\\\\\\\\\\\\\
03:11:30 <etpace_> thanks
03:11:39 <yitz> in general, there is no function of type m a -> a. That is the whole reason IO is a monad.
03:11:54 <etpace_> yeah, just realised
03:12:34 <yitz> some monads do have it, but you can't count on such a thing existing.
03:13:33 <ski> taruti : "Arrows generalise monads and idioms" <http://lambda-the-ultimate.org/node/2799> might be relevant
03:14:22 <dancor> i'm making what is basically a glorified echo server, but i don't want to use sockets because i want single-user permission.  however, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ipc doesn't look like it will handle many clients very well.  what other ipc options are there?
03:14:43 <ski> yitz : `Identity' and `Monoid o => Writer o'. any more ?
03:14:43 <dancor> project README: http://dzl.no-ip.org:81/gitweb/?p=memoplex.git;a=blob;f=README
03:16:27 <yitz> ski: lists, Maybe
03:16:46 <ski> only partial such functions
03:17:01 <dancor> http://nsequence.svcs.cs.pdx.edu/node/258 is really nice with the STM stuff, but i don't think i can use sockets here without implementing authentication stuff that is probably not the easiest route
03:17:06 <yitz> yeah, those are partial
03:17:54 <yitz> Either e, but that's also partial
03:17:58 <ski> (for inhabited `r', also `(r ->)', i suppose .. not canonical unless `r' has a canonical value, though (like when `Monoid r'))
03:19:07 <yitz> ski, sort of. Reader (ie (->) and State have m v a -> v -> a
03:19:19 <taruti> ski: thanks, I'll read that
03:20:03 <yitz> s/)/))/
03:20:38 <ksf> test.hs:14:9:
03:20:38 <ksf>     Context reduction stack overflow; size = 20
03:20:38 <ksf>     Use -fcontext-stack=N to increase stack size to N
03:20:41 <ksf> w00t!
03:20:45 <ksf> longest type error ever.
03:20:48 <ski>   instance Monoid r => Comonad ((->) r) where extract f = f mempty; (f =>> k) r0 = k (\r1 -> f (r0 `mappend` r1))
03:20:55 <ski> does that satisfy the comonad laws ?
03:20:58 <ksf> ...even beats c++.
03:21:13 <quicksilver> ski: must do, surely ?
03:21:19 <quicksilver> ski: it just looks so right :P
03:21:50 <yitz> ksf: that's a great error! how did you do it?
03:22:13 <ski> (quicksilver : it probably does, but i'm a bit tired atm, and must leave. so i won't check it now)
03:22:23 <ksf>         `$dMonoid{aVj} :: {Monoid (Set (Set Flag))}'
03:22:23 <ksf>           arising from the superclasses of an instance declaration
03:22:23 <ksf>                        at test.hs:14:9-19
03:22:39 <ksf> ...and a lot more looking like Monoid (Set (Set (Set Flag)))
03:23:29 <ksf> the problem is, I'm just not sure how to express what I want to express.
03:25:35 <quicksilver> you probably have an instance which unifies with
03:25:45 <quicksilver> Monoid (Set x) => Monoid x
03:25:53 <ksf> exactly.
03:25:58 <quicksilver> so it builds up ever bigger constraints on the left.
03:26:14 <ksf> ...but I don't want the Monoid (Set (Set x)) => Monoid x
03:26:31 <ksf> ...as Sets can't nest.
03:26:34 <quicksilver> what you want is not possible. Go directly to jail, do not pass go.
03:26:39 <quicksilver> do not collect 200.
03:26:46 <ksf> ...and we don't have data kinds, yet.
03:26:49 <dancor> or in this case, 20.
03:27:42 <ksf> hum.
03:27:56 <ksf> if monoid was a proper type fun, I might be able to do something.
03:28:06 <ksf> (I don't really care for it being a standard class)
03:28:16 <quicksilver> you can use type families to get proper type funs.
03:29:24 <ksf> that's exactly what i've been thinking.
03:31:08 <ksf> ...that should teach me never to enable undecidableinstances, again.
03:32:41 <quicksilver> I hope so.
03:33:02 <quicksilver> what you're doing doesn't looke like a sane use of the class system but I'm too busy today to help you do something saner ;)
03:36:10 * pozic nominates XPath 1.0 as most useless language every conceived. 
03:40:13 <ksf> well, the run-time semantics are sane.
03:40:30 <jethr0> anyone know of a haskell game with simple network functionality (client/server)?
03:40:55 <ksf> jethr0, do you want turn-based or realtime?
03:41:19 <jethr0> realtime
03:41:47 <ksf> 'cos for turn based it's trivial, and for realtime it's so darn game dependent that there is no simple solution.
03:42:04 <jethr0> i'm currently working on a game in haskell. single-machine code is working beautifully and I have some ideas concerning networked code, but I want to reinvent the wheel as little as necesssary ;)
03:42:32 <jethr0> do you know of any networked realtime games in haskell?
03:42:51 <jethr0> you know whether 'frag' is networked?
03:43:21 <ksf> http://fabiensanglard.net/quakeSource/quakeSourceNetWork.php
03:44:56 <ksf> http://trac.bookofhook.com/bookofhook/trac.cgi/wiki/IntroductionToMultiplayerGameProgramming
03:45:14 <jethr0> thx, i was thinking of starting off as naively as possible (for LAN and not building any anti-cheat functionality)
03:46:05 <ksf> depending on what you mean, "anti-cheat" is either built in or impossible.
03:46:48 <ksf> that is, you won't ever be able to fly in quake, as the server will just ignore your wishes to do so, and other clients thus won't see it. the server uses the same physics as the (unhacked) clients.
03:47:28 <ksf> then, it won't ever be able to prevent wall-hacking, as it's just nescessary to send clients the position of invisible players, because of lag.
03:47:51 <jethr0> i was speaking of the quake1 pitfall that once people had access to the source, ever-new cheats where developed which the network architecture hadn't anticipated
03:48:00 <ksf> ...every position of every player you see on the screen is just a heuristic approximation, only the server knows where they really are.
03:48:12 <jethr0> k
03:48:40 <jethr0> i guess i'll just implement my naive network idea and see how that goes in a fast, low-latency local lan
03:48:40 <ksf> ...you might want to start off by taking your local code and just add random lag.
03:48:45 <ksf> and packet losses.
03:49:01 <ksf> and make your code robust to that.
03:49:11 <ksf> ...especially packet losses.
03:49:11 <jethr0> hmm
03:49:33 <jethr0> was thinking of using TCP (since it's a fact local network with low packet loss and low latency)
03:49:42 <ksf> you can't use tcp.
03:49:46 <jethr0> why?
03:50:18 <jethr0> window size?
03:50:29 <ksf> ...when one packet drops, it gets resend, and all other packets that could have arrived in time lag because tcp preserves package sequence.
03:50:40 <quicksilver> you *can* use TCP, if you want to
03:50:45 <quicksilver> you just have to be aware of the shortcomings.
03:51:06 <jethr0> i understand that, but since the network is gigabit and my packets are a few bytes large, this lag should be caught up very quickly
03:51:25 <quicksilver> retransmits are very rare on a quite local lan - but they will happen if someone starts to use most of the bandwidth, for example.
03:51:33 <ksf> ...well, but don't expect it to work on the inet.
03:51:35 <quicksilver> s/quite/quiet/
03:51:45 <jethr0> do you have any idea how often "normal" game servers send their updates? my guess would be far less often than 60Hz...
03:52:17 <opqdonut> i used to know how often quake did it
03:52:19 <ksf> quite often.
03:52:22 <opqdonut> something like 10Hz anyway
03:52:31 <jethr0> ksf: sure thing. but i'm not so keen on dealing with huge lags anyway. i'll start simple and then move to a more robust platform
03:52:32 <ksf> ...that is, shorter than the lag.
03:52:38 <opqdonut> yeh
03:52:47 <ksf> it depends on what kind of game it is.
03:52:59 <jethr0> it's one of the many, many bomberman clones ;)
03:53:13 <ksf> like, rts is turn-based, in comparison to a shooter.
03:54:30 <jethr0> i was thinking of transmitting the movements and actions, but with lag and packet loss I would scrap that approach for client positions (which would be more open to cheating)
03:55:11 <jethr0> any idea how shooters handle it when a "fire" command is in a lost packet?
03:55:12 <ksf> p2p doesn't really work for games... at least i've never seen it implemented.
03:55:20 <ksf> you just don't shoot.
03:55:27 <jethr0> nono, i wanna do client/server definitely
03:55:31 <ksf> if the package doesn't arrive at the server, you didn't shoot.
03:55:39 <jethr0> hmm, that could be annoying
03:55:56 <jethr0> you sure? don't these game implement some resending based on udp?
03:55:57 <ksf> otherwise, you desync the clients.
03:56:10 <ksf> sure
03:56:28 <ksf> I'm not sure whether or not shooting counts to those resend packages, though.
03:56:33 <quicksilver> I suspect you have to try it, to see the problems ;)
03:56:38 <ksf> yep.
03:56:43 <quicksilver> for example, if you were allowed to resend a shoot packet
03:56:51 <quicksilver> then a hacked client could "claim" that a shot was a resend
03:56:54 <quicksilver> and try to get it backdated
03:57:03 <jethr0> i'll just try with tcp first...
03:57:37 <quicksilver> ksf: myth: the fallen lords was p2p in a sense, but there was a preferred peer
03:58:31 <ksf> spring checksums the state of the whole engine to discover desyncs.
03:58:56 <ksf> (there's much fun to be had with floats, there)
03:58:56 <idnar> ;Starcraft was peer-to-peer
03:59:18 <ksf> you can certainly do it p2p.
03:59:20 <jethr0> quite a few games allow you to play on when the 'server' has left
03:59:21 <idnar> in a symmetric fashion
04:00:05 <ksf> but you should probably choose a preferred peer based on connection quality to distribute stuff for everyone.
04:00:06 <idnar> Warcraft III, on the other hand, had a "host"; if the host left "cleanly" by disconnecting or exiting the game, he would hand over to one of the other players in the game, but if his network connection just died, then everyone dropped from the game;
04:01:02 <ksf> ...you could get netsplits or something. having one definite authority allows you to resync.
04:01:22 <ksf> ...assuming that you can cleanly transmit the whole world state.
04:01:49 <quicksilver> jethr0: as you can see, it's interesting and complicated :)
04:02:08 <quicksilver> jethr0: I suggest you implement something, play with it, and then use what you've learnt to address the bigger issues.
04:02:47 <jethr0> yup, exactly my idea. i've known realtime game networking to be quite a challenge for a while, but now i want to try it for myself ;)
04:03:26 * ksf didn't dare to write a realtime game in haskell, yet.
04:03:47 <ksf> I know how much I circumvented the gc as I did it in java...
04:03:58 <jethr0> grmpf, 'frag' doesn't seem to implement network either
04:04:43 <quicksilver> ksf: well, realtime games are still fairly soft realtime
04:04:59 <ksf> in the end, you still end up running the gc on every update, just to prevent bigger gc runs
04:05:04 <quicksilver> ksf: if you figure on 10Hz world updates with a bit of tweening... 100ms is a long time.
04:05:26 <ksf> you just can't have a completely static heap with most java implementations.
04:05:39 <jethr0> i've implemented simple 2d tiles/sprites on top of opengl and annoyingly the only thing that allocated memory is the openGL displaying. and it allocated SOOO much memory (60mb per sec or so). it get's freed right away, but anyway...
04:05:56 <ksf> ...you call drawRectangle, and the j2me implementation new's some object and throws it away.
04:06:27 <jethr0> one step at a time ;)
04:06:41 <quicksilver> jethr0: well even simple operations like iterating through a list allocates some memory and throws it away in haskell
04:06:44 <ksf> ...sending 60mb/s to the gpu sounds like nothing to me.
04:06:56 <quicksilver> minor GCs - in the nursery - are completely in-cache though
04:07:00 <quicksilver> which makes them almost free
04:07:11 <quicksilver> sub-millisecond.
04:08:13 <PeakerWork> idnar: you there?
04:08:38 <idnar> PeakerWork: yeah
04:08:52 <PeakerWork> idnar: so do you know how to represent logical and and or?
04:09:12 <ksf> quicksilver, if you update the whole screen at every draw on a nokia series 40, you get approx. 2.6fps.
04:09:21 <ksf> they're decently fast, though.
04:09:29 <ksf> (cpu-wise)
04:09:42 <quicksilver> ksf: well, sure. But that's an increasingly rare case.
04:09:50 <ksf> it's a bigger challenge to get an a* to run on a who knows 50mhz arm.
04:10:10 <idnar> PeakerWork: no
04:10:13 <ksf> ..._interpreting_ java.
04:10:24 <quicksilver> ksf: all graphics even on mobile devices is moving towards the opengl model of whole screen per frame
04:10:36 <idnar> PeakerWork: I guess you can build them from implication somehow, but I don't recall how :P
04:10:39 <quicksilver> ksf: so the dirty rectangle optimisation will be consigned to the dustbin of history sometime soon ;)
04:10:40 <PeakerWork> idnar: AND is represented by a "type product" (e.g Tuples).   (a, b)  is a value (proof) that contains 2 values (2 proofs).  So it is in fact a proof that both the propositions are true
04:10:49 <idnar> oh right
04:10:58 <idnar> sum and product types
04:11:24 <PeakerWork> idnar: OR is represented by a "type sum" (e.g Either).  Either a b  is a value (proof) that contains either a proof of a, or of b. Its a proof that one of a and b are true
04:11:26 <PeakerWork> idnar: yep
04:11:29 <ksf> newfangled knick-knack!
04:11:36 <PeakerWork> idnar: now, how do we represent Not?
04:12:05 <ksf> why should you re-draw grass tiles if you scrolled one tile to the left and there's still grass there?
04:12:35 <PeakerWork> idnar: Let us define a "False" type.   data Void = <no constructors here>    in a total language it isn't inhabited,  not even by _|_ (which doesn't exist there).  All types that are uninhabited can be rewritten as Void.  For example, (a -> b) is uninhabitable so can be replaced by Void
04:13:42 <ksf> the data kinds page claims that we're going to get types that aren't inhabited by _|_.
04:13:48 <PeakerWork> idnar: Not can be written as:   type Not a = a -> Void.          False -> False   is True.   True -> False  is False,  so we see how this reverses a logical proposition.  Why does it work with values too?
04:13:51 <ksf> so no more foo (undefined :: Bar)
04:14:06 <quicksilver> ksf: link ?
04:14:22 <ksf> http://hackage.haskell.org/trac/ghc/wiki/KindSystem
04:15:19 <ksf> "We first declare a new kind Nat, that is defined by two types, Zero and Succ. Although Zero and Succ are types, they do not classify any haskell values (including undefined/bottom)."
04:15:50 <PeakerWork> idnar: Basically, if you look at a function as a potentially infinite mathematical mapping from a domain to a range, then an empty mapping (Void -> Whatever) always exists, even if it is (Void -> Void), so the value empty_map_func  inhabits the (Void -> Void) type.   However, (NonVoid -> Void) does not exist, because it must map a value in some non-empty domain into a completely empty range
04:16:12 <mmorrow> what's the definition of "void" in @djinn?
04:16:21 <quicksilver> @help djinn
04:16:21 <lambdabot> djinn <type>.
04:16:21 <lambdabot> Generates Haskell code from a type.
04:16:21 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
04:16:48 <PeakerWork> idnar: with me here? :)
04:16:56 <idnar> PeakerWork: yes
04:16:58 <quicksilver> mmorrow: /msg lambdabot @djinn-env
04:17:06 <PeakerWork> idnar: so do you see how the Not type works?
04:17:25 <PeakerWork> @djinn-add type Not a = (a -> Void)
04:17:25 <idnar> PeakerWork: yes, I think so
04:17:46 <mmorrow> quicksilver: it's not in there
04:17:51 <mmorrow> the function i mean
04:17:57 <mmorrow> @djinn Not(Not(Not a)) -> Not a
04:17:57 <lambdabot> f a b = void (a (\ c -> c b))
04:18:02 <mmorrow> @djinn Not a -> Not(Not(Not a))
04:18:02 <lambdabot> f a b = void (b a)
04:18:34 <PeakerWork> idnar: lets look at an example:   a -> Not (Not a)    that would open up to:    a -> Not a -> Void   or:  a -> (a -> Void) -> Void    you see the proof of this is   flip (.)  :-)
04:18:36 <mmorrow> i know those are isomorphic (Not a and Not(Not(Not a))), but i don't know what "void" is supposed to mean
04:19:11 * quicksilver expands that type
04:19:16 <mmorrow> Peaker: Not is in djinn by default
04:19:20 <PeakerWork> idnar: so we proved that if "a" is true, then (Not (Not a)) is also true, by showing that the type (a -> Not (Not a)) is inhabited by the value: flip (.)
04:19:28 <PeakerWork> mmorrow: ah, ok
04:19:30 <quicksilver> (A -> Void) -> (((A -> Void) -> Void) -> Void)
04:19:45 <quicksilver> right?
04:19:58 <quicksilver> so, (A -> Void) -> ((A -> Void) -> Void) -> Void ?
04:20:05 <PeakerWork> idnar: flip (.) halts, so the proof is valid, unlike the "fix" proof :)
04:20:13 <PeakerWork> idnar: in other words, it doesn't use circular logic
04:20:18 <quicksilver> so a :: A -> Void and b :: ((A -> Void) -> Void))
04:20:36 <quicksilver> so why isn't the answer just (b a) ?
04:21:07 <mmorrow> i guess it's not reducing or something (??)
04:21:28 <mmorrow> but i can't figure out what djinn's saying on account of the "void"
04:21:36 <PeakerWork> idnar: actually, I was wrong there, that should have been a flip ($) I guess nobody is proof reading me :-)
04:21:40 <mmorrow> to be able to try to reduce it by hand
04:21:47 <mmorrow> (reduce the composition to id)
04:21:58 <mmorrow> to see if djinn thinks they're iso as well
04:22:10 <opqdonut> @djinn-env
04:22:10 <lambdabot> data () = ()
04:22:10 <lambdabot> data Either a b = Left a | Right b
04:22:10 <lambdabot> data Maybe a = Nothing | Just a
04:22:10 <lambdabot> data Bool = False | True
04:22:10 <lambdabot> data Void
04:22:12 <lambdabot> type Not x = x -> Void
04:22:14 <lambdabot> class Eq a where (==) :: a -> a -> Bool
04:22:16 <lambdabot> type Not a = a -> Void
04:22:23 <mmorrow> djinn-env doesn't list the function `void'
04:22:29 <opqdonut> void :: a -> Void ?
04:22:39 <PeakerWork> if @djinn did recursive types, yummy!
04:22:41 <mmorrow> ?
04:22:42 <opqdonut> no, that's not a valid statement
04:22:44 <doserj> mmorrow: data Void; void :: Void -> a -- no definition, because there are no patterns to match on...
04:22:58 <opqdonut> ah, yes, void that way around
04:23:03 <mmorrow> @djinn a -> Void
04:23:03 <lambdabot> -- f cannot be realized.
04:23:09 <mmorrow> @djinn Void -> a
04:23:09 <lambdabot> f = void
04:23:11 <mmorrow> ahh
04:23:13 <mmorrow> :)
04:23:19 <mmorrow> um
04:23:37 <quicksilver> but it doesn't need it to prove that proposition
04:23:41 <quicksilver> it's using the wrong proof ;)
04:23:49 <Martijn_> doserj: is that valid haskell, a type sig without implementation?
04:23:55 <quicksilver> @djinn (a -> r) -> (((a -> r) -> r) -> r)
04:23:55 <lambdabot> f a b = b a
04:23:58 <doserj> Martijn_: no
04:23:59 <opqdonut> quicksilver: proofs in normal form, yay!
04:24:04 <quicksilver> no need for the special Void rule
04:24:06 <PeakerWork> idnar: anyway, having Not, And, Or, Implication already gives us a logical system.  Now the next thing I saw Epigram using was data constructors as sort of axioms.. still with me?
04:24:08 <quicksilver> it's true for all r
04:24:18 <mmorrow> quicksilver: ahh, nice ok.
04:24:52 <ketil> I've a problem building for profiling with cabal - it's ./Setup.hs configure -p, no?
04:24:57 <ksf> type instance Foo (Bar a) = a
04:25:02 <ksf> what's the name for that beast?
04:25:04 <Axman6> doserj: i believe it is valid
04:25:10 <Axman6> @src RealWorld
04:25:10 <lambdabot> Source not found. Do you think like you type?
04:25:12 <Axman6> :(
04:25:13 <idnar> PeakerWork: yeah, that makes sense
04:25:24 <Phyx-> morning
04:25:27 <Axman6> anyway, there's 'data RealWorld'
04:25:27 <mmorrow> quicksilver: so i guess since djinn doesn't have forall, it can't express that?
04:25:28 <ksf> copointed?
04:25:46 <quicksilver> mmorrow: it knows about that proof, it just finds the other one 'first'
04:25:55 <doserj> > let f::Int -> Int in f 3 -- Axman6
04:25:56 <lambdabot>   The type signature for `f' lacks an accompanying binding
04:25:56 <lambdabot>    (You cannot giv...
04:25:56 <mmorrow> quicksilver: ah, i see
04:26:12 <quicksilver> mmorrow: I don't think that's particularly significant. djinn has some tweaks to its proof search order to prefer using parameters to ignoring them
04:26:14 <Axman6> oh, i see what Martijn_ meant now
04:26:37 <doserj> data Void also is not valid Haskell98
04:27:21 <Martijn_> True, but there's an extension to allow that. I was just wondering if you can write void without referring to some form of bottom.
04:28:11 <quicksilver> Martijn_: you can't, no
04:28:21 <quicksilver> Martijn_: the syntax case of {} has been suggested
04:28:25 <doserj> newtype Void = Void { void :: forall a.a }
04:28:31 <quicksilver> void a = case a of {}
04:28:35 <Martijn_> Oh right, I remember that from a recent thread
04:29:00 <ksf> error:  Illegal type synonym family application in instance
04:29:02 <ksf> grrrr
04:29:03 <quicksilver> newtype Void = Void Void; void a = Void (void a)
04:29:05 <quicksilver> ;)
04:29:06 <PeakerWork> idnar: So, in Epigram, they define the Equality proposition as a type (types are propositions):   data (==) a b = <axioms here>         (or just:  data a == b where <axioms here>          and equality has one axiom, everything equals itself, so:   data  s == t  where  Refl :: t == t
04:29:50 <PeakerWork> idnar: so (==) is the proposition/type, and Refl is the proof/value.
04:30:00 <idnar> PeakerWork: s and t are type variables there?
04:30:07 <doserj> quicksilver: that void has the wrong type, doesn't it?
04:30:11 <mmorrow> isn't void :: Void -> a    though?
04:30:18 <PeakerWork> idnar: in DT, s and t can be types, values, whatever, at least iiuc
04:30:58 <quicksilver> oops
04:31:00 * mmorrow doesn't see what (Void -> a) is supposed to represent in terms of whatever
04:31:02 <idnar> I'm trying to understand what something like (==) Integer 6 would mean
04:31:18 <mmorrow> oh.
04:31:23 <doserj> mmorrow: Void -> a represents "false implies everything"
04:31:25 <mmorrow> Void is the initial object
04:31:42 <mmorrow> and void is the universal morphism from it to any a
04:31:48 <Martijn_> Dang, evaluating "fix id" in GHCi caused my computer to become unresponsive for two minutes
04:31:52 <ksf> i've got some strange, fuzzy isomorphism between type families and typeclasses in my head that I can neither explain nor prove nor disprove.
04:31:56 <PeakerWork> idnar: you couldn't create Refl for that, I think. That's a part I'm not fully understanding myself
04:31:59 <mmorrow> Martijn_: ^Z ftw
04:32:13 <PeakerWork> idnar: open up the Why Dependent Types Matter.pdf  and look at page 5
04:32:28 <Martijn_> mmorrow: I tried ^C but that didn't work. Will try ^Z next time.
04:32:30 <mmorrow> Martijn_: you're probably swapping..
04:32:46 <mmorrow> Martijn_: in ghc >= 6.10 it doesn't lock up like that
04:32:49 <idnar> PeakerWork: URL?
04:32:55 <ski_> quicksilver : `void (Void v) = void v'
04:33:05 <PeakerWork> idnar: www.e-pig.org/downloads/ydtm.pdf
04:33:05 <idnar> oh, apparently I can't use google
04:33:24 <Martijn_> mmorrow: Using The Glorious Glasgow Haskell Compilation System, version 6.10.1
04:33:30 <mmorrow> MarcWeber: :o
04:33:36 <mmorrow> MarcWeber: are you on unix?>
04:33:39 <mmorrow> s/>//
04:34:03 <idnar> mmorrow: s/MarcWeber/Martijn_/ ?
04:34:11 <mmorrow> err, yeah
04:34:19 <mmorrow> Martijn_: are you on unix?
04:34:20 <Martijn_> mmorrow: Mac OS X
04:34:23 <PeakerWork> idnar: stuff above the horizontal line are basically local definitions a new definition depends on, and stuff below it are the new definition, as I gather
04:34:24 <mmorrow> void (Void v) = Void (void v)
04:34:41 <mmorrow> id for Void
04:34:51 <mmorrow> Martijn_: hmm, maybe it still does that on osx
04:35:08 <Martijn_> mmorrow: Was there a bug entry?
04:35:53 <mmorrow> Martijn_: i think the behavior just got changed as a result of redo-ing how signals were handled by the rts
04:36:08 <Martijn_> mmorrow: mmkay
04:36:25 * ksf thinks he wants something like associated classes and fears he's sounding like an idiot
04:36:28 <mmorrow> Martijn_: on linux, (fix id) used to consume all of your memory then start swapping until you kill -9'd it
04:36:39 <mmorrow> now it just does nothing
04:36:42 <mmorrow> and you can ^C it
04:36:56 <mmorrow> (but if doesn't even spin, it just sits)
04:36:59 <mmorrow> s/if/it/
04:37:06 <PeakerWork> idnar: so the refl definition says what I said, pretty much. then the "let" below says that if   s : S  and  Q is a proof that S = T,  then s : T       (: is like Haskell's ::)
04:37:37 <Martijn_> That's nice
04:37:46 <Martijn_> That's much better than actively doing nothing
04:37:47 <ksf> Martijn_, ^\
04:37:50 <mmorrow> Martijn_: (and this is just wrt ghci)
04:37:54 <ksf> ...works, at least in zsh.
04:38:06 <mmorrow> Martijn_: in compiled code you immediately exit with <<loop>
04:38:07 <mmorrow> >
04:38:10 <ksf> could be that ghci traps it, though.
04:38:26 <PeakerWork> idnar: anyway, after understand the CH isomorphism, I could (with great effort) reverse engineer 70% of what the WDTM paper was saying :)
04:38:38 <Martijn_> I guess the nicer definition is type Void = forall a. a. That way void :: Void -> a, void x = x
04:38:42 <PeakerWork> idnar: And I found it really really insightful, even amazing :)
04:39:55 <Martijn_> You still need an extension for it, though
04:40:37 <ksf> now I get it
04:40:39 <ksf> (I hope)
04:40:46 <ksf> classes are implicite type funs.
04:40:56 <ksf> they just get applied to everything.
04:41:01 <ski> Martijn_ : that would make only a `void :: Void -> Void'
04:41:43 <ski> Martijn_ : .. oh, missed the `forall a. a' bit .. ignore what i said
04:41:43 <ksf> someone correct me, please.
04:41:49 <iabal> someone could explain to me why the first decl works but not the second? http://www.moonpatio.org/fastcgi/hpaste.fcgi/view?id=3503
04:42:01 <ksf> I feel to confused to accept I actually wrote something correct.
04:42:06 <ski> ksf : classes are a kind of relations on types
04:42:27 <ksf> ...well, type funs too.
04:42:39 <ksf> but you have to explititely apply them.
04:42:44 <Martijn_> ksf: I'm not sure how type classes relate to type funs but thinking of them in terms of dictionaries helped me a lot. It explains a lot of type classes' features, such as superclasses and multi-param classes.
04:43:14 <quicksilver> ksf: binary classes with a fundep are type functions
04:43:18 <quicksilver> is that what you meant?
04:43:26 <quicksilver> classes in general are properties of types
04:44:30 <Martijn_> iabal: ask GHCi for the type of the first definition of other, that should clarify things
04:45:06 <iabal> Martijn_: arg
04:45:25 <iabal> so it is no possible what I try to do?
04:45:41 <Martijn_> Maybe not in GHCi but in normal Haskell code it should be fine
04:45:50 <PeakerWork> iabal: seems to be the isomorphism restriction, which allows Num ad-hocishly
04:46:02 <PeakerWork> monomorphism that was
04:46:04 <ksf> ...well, the thing is, I basically want to have a type function, but I don't want to mention it. So I got onto that implicit-call thing.
04:46:29 <PeakerWork> iabal: yep, the monomorphism restriction has a special case for  Num a => a   probably to not make too much of a mess of x = 5
04:47:35 <Martijn_> ksf: right, so what quicksilver said applies then: you can represent type functions as type classes with fundeps
04:47:51 <PeakerWork> iabal: if you use an explicit (separate) type signature rather than type annotations, it will work too
04:48:09 <PeakerWork> iabal: or if you use LANGUAGE NoMonomorphismRestriction or -fno-monomorphism-restriction
04:50:12 <ksf> ...so I need fundeps, after all.
04:50:44 <ksf> someone should clean up all that syntax mess.
04:51:11 <ksf> or haskell will end up like c++
04:52:02 <Martijn_> I have a question about cardinalities of Haskell types. I know how about datatypes: sums of products. Functions can be seen as power functions. But how about polymorphic functions? I.e. "forall a. a -> a" has only one implementation (ignoring bottom), but how to compute this mechanically?
04:52:12 <iabal> Martijn_, PeakerWork: thanks a lot
04:52:29 <ksf> ...meaning that there should be some way to express fundeps concisely, too, not that type families would be a syntax mess.
04:52:55 <Martijn_> ksf: how much more concise do you want fundeps to be?
04:53:21 <ksf> well, the equivalent of reducing associated types to type families
04:53:41 <ksf> but I might just be talking gibberish right now.
04:55:12 <ksf> it's hard to ignore them scaffolders outside, one story below my window, _and_ not to ignore the important parts of what I'm currently thinking about.
04:55:36 <Martijn_> hehe :-)
04:58:07 <ksf> coffee also has the interesting property of letting you think that you're thinking about something important, because your brain chemistry is more awake than your thoughts.
04:58:53 <quicksilver> ksf: I think for the simple clase, the associated type syntax is nice
04:59:06 <quicksilver> class Foo a where data b; ...
04:59:23 <quicksilver> (or whatever it is ;)
05:00:33 <ksf> ...but aside from the compiler complaining if you do a class instance without a corresponding data instance, there's no difference.
05:00:47 <ksf> ...well, modulo default instances.
05:02:58 <Jafet> "but we make it this more general time just for generality" (excerpt from "best tutorial available online")
05:07:21 <quicksilver> ksf: makes a substantial difference to your type signatures
05:07:44 <quicksilver> (Foo a) => being a more useful constraint than (Foo a b) often
05:09:50 <chessguy_work> @pl \x -> w (f x) (g x)
05:09:50 <lambdabot> liftM2 w f g
05:11:33 <Martijn_> My dictionary can't find the word "genericity" :-(
05:11:35 <chessguy> @hoogle if'
05:11:35 <lambdabot> No results found
05:11:50 <chessguy> @hoogle Bool -> a -> a -> a
05:11:50 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
05:11:50 <lambdabot> Test.HUnit.Text PutText :: String -> Bool -> st -> IO st -> st -> PutText st
05:11:50 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
05:11:59 <chessguy> @hoogle+
05:11:59 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
05:11:59 <lambdabot> Foreign.C.Error throwErrnoIf :: a -> Bool -> String -> IO a -> IO a
05:11:59 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => Html -> b -> a -> b
05:12:10 <chessguy> i thought if' was in Data.Function now or something
05:13:02 <CalJohn> @type if'
05:13:03 <lambdabot> Not in scope: `if''
05:13:10 <Martijn_> You're looking for package "bool-extras"
05:13:13 <Martijn_> @hackage bool-extras
05:13:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bool-extras
05:13:38 <chessguy> bah
05:13:43 <chessguy> that's annoying
05:13:58 <chessguy> thanks though, Martijn_
05:14:07 <phil__> Phil Wadler's on youtube: http://www.youtube.com/watch?v=KYeys_in_Ng
05:14:34 <Martijn_> np
05:15:54 <ksf> w00t!
05:16:00 <ksf> I made the typechecker loop.
05:16:05 <Lanjiao> how to use hoogle here?
05:16:12 <chessguy> @hoogle map
05:16:12 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
05:16:12 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
05:16:12 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
05:16:24 <Lanjiao> thanks
05:17:04 <ksf> ...that is, I managed to do the same as I did as I got the reduce stack overflow, but managed to get ghc not to detect it.
05:17:22 <CalJohn> (i always imagined phil wadler would have a scottish accent)
05:17:24 <ksf> ... to not detect it.
05:17:30 <ksf> I should work on my english.
05:18:07 <CalJohn> ksf: actually, it was fine as it was
05:18:12 <ksf> ...at least I didn't say "it not to detect"
05:18:51 <phil__> CalJohn: There aren't that many Scottish accents at Edinburgh Informatics, sadly.
05:18:58 <surgeon> what can I do in a function to do nothing?
05:19:20 <ksf> one possibility is foo = undefined.
05:19:33 <ksf> the other is foo = id
05:19:36 <Martijn_> surgeon: what is the type of your function?
05:19:52 <surgeon> Martijn_: uh, I can't really say it calls another function I guess
05:20:04 <surgeon> Martijn_: so nothing?
05:20:06 <Martijn_> surgeon: the meaning of "do nothing" depends on the type
05:20:26 <chessguy> hiya ski_
05:20:29 <ksf> @src id
05:20:29 <lambdabot> id x = x
05:20:37 <Martijn_> surgeon: ksf just gave two examples. "return ()" is another example.
05:20:43 <ksf> that's about as do-nothing as you get.
05:20:47 <Martijn_> surgeon: but they all have different types
05:21:09 <pozic> Haskell would make quite a nice specification language for something like XPath.
05:21:09 <dibblego> surgeon, are you a surgeon?
05:21:10 <chessguy> not to mention different semantics
05:21:26 <Martijn_> naturally
05:21:26 <surgeon> dibblego: no^^ but when I was younger I wanted to get one
05:21:27 <pozic> Or Prolog or something even higher-level.
05:21:35 <ski> chessguy : hello
05:21:35 <surgeon> ok thanks, I'll find out the type of the function
05:21:36 <ksf> pozic, haskell makes xml, xslt and thus xml superfluous.
05:21:45 <chessguy> you wanted to get a surgeon?
05:21:51 <pozic> ksf: are you referring to read/show?
05:21:59 <surgeon> chessguy: a sry become, bad english^^
05:22:08 <ksf> nah, no adt's and function application.
05:22:16 <chessguy> oh! i thought maybe you were just a very sick boy
05:22:22 <chessguy> (or girl)
05:22:23 <surgeon> is there a good book you would recommend for haskell users who know the basics?
05:22:28 <phil__> surgeon: The analogue of void foo () {} is foo () = ().
05:22:34 <pozic> ksf: the value in XML is being able to communicate between different environments.
05:22:50 <pozic> ksf: it is a standard. It doesn't matter it's not a very good standard.
05:23:05 <chessguy> phil__, hmm. i would say it's return ()
05:23:17 <ksf> that's why we have haxml, so we don't have to do the grunt work of mapping xml to adts.
05:23:22 <chessguy> phil__, because of the implicit state monad in imperative programming
05:23:57 <chessguy> phil__, not to mention, the two functions you mentioned take different numbers of parameters
05:24:26 <quicksilver> the problem with answering "how do I do nothing" with "return ()" is in my experience that is often not what the questioner is looking for
05:24:32 <quicksilver> it's looking for the question behind the question.
05:24:45 <ksf> ...the analogue of foo () {} is ().
05:25:17 <pozic> ksf: sure, but you might want to have internal adts which represent the XML information in a different way.
05:25:17 <ksf> ...well, actually, as you don't return anything in foo, it's undefined.
05:25:20 <dino-> surgeon: For published books, there's _Real World Haskell_ http://oreilly.com/catalog/9780596514983/
05:25:37 <chessguy> quicksilver, oh yes, i certainly wouldn't just state that as the answer, i was just saying it's a closer equivalent to the other function phil__  gave
05:25:40 <phil__> chessguy: I should have said "rough analogue". It's the idea that void foo() is more like void foo(void).
05:25:45 <pozic> ksf: and you might want to have better error reporting.
05:25:48 <dino-> surgeon: I had a good learning experience from Yet Another Haskell Tutorial http://en.wikibooks.org/wiki/Haskell/YAHT
05:26:02 <phil__> surgeon: I loved the Haskell School of Expression.
05:26:07 <ksf> hell yes. I wanted to play with IxSet before I went onto this crazy voyage of abusing the type system to do completely irrelevant stuff.
05:26:55 <chessguy> +1 for HSOE. though it's hard to beat RWH for going from 0-60
05:27:07 <surgeon> dino-, phil__: thanks!
05:27:19 <edwardk_> Yaht works really well for a certain kind of learner
05:27:24 <chessguy> HSOE is just too stinkin' fun!
05:28:02 <edwardk_> Rwh and learn you a haskell
05:28:25 <dino-> surgeon: If you're attacking monads, there's a ton of reading out there. But a couple things that helped me tremendously were _All About Monads_ and _Monads as Containers_ http://www.haskell.org/all_about_monads/html/index.html http://www.haskell.org/haskellwiki/Monads_as_containers
05:28:31 <phil__> chessguy, I'm pretty nuts about the scripting side of game programming, so I absolutely loved it.
05:28:33 <edwardk_> Are my favorite two
05:28:40 <ksf> ...that's what happens if you try to do clean design bottom-up.
05:28:47 <dino-> Oh yeah, of course, Learn You
05:29:33 <chessguy> edwardk_, :)
05:29:36 <dino-> Wow, how do I not have Learn You in my bookmarks.
05:29:43 <dino-> That's not right.
05:29:45 <Lanjiao> somebody knows any real website powered by Haskell?
05:30:04 <Axman6> hpaste is i think
05:30:04 <dino-> Lanjiao: I'm working on something simple right now! :D
05:30:20 <Lemmih> Lanjiao: wiki.darcs.net
05:30:34 <Lanjiao> dino: online now? can i have a look?
05:30:46 <CalJohn> (I have yet to meet someone who is learning haskell who found rwh helpful)
05:30:56 <CalJohn> I didn't find it helpful
05:30:56 <Jafet> codepad uses geordi which is written in haskell
05:31:05 <sm> also hackage.haskell.org
05:31:25 <dino-> Lanjiao: Sure, this is a flash-card-like study thing for people who are preparing for the FCC Commercial Radio Operator's License exam. Multiple choice question drilling. http://ui3.info/fequiz/bin/fequiz.cgi
05:31:54 <ksf> hmmm with data kinds I could say instance (Monoid (Set a)) => Monoid a iff Set :: Foo -> *, couldn't I?
05:31:55 <dino-> I am working right now on randomly mixing up the questions and each question's answer as we speak. Should be ready in < another hour.
05:32:00 <quicksilver> CalJohn: I have heard plenty of people in here find RWH helpful.
05:32:01 <Lanjiao> sm: is there some doc about how hackage.haskell.org run by Haskell?
05:32:15 <quicksilver> certainly I learn haskell long before it was written so I can't really imagine how it reads to a beginner.
05:32:16 <ksf> ...as ghc couldn't go on and expand the constraint indefinitely.
05:32:31 <sm> just the source afaik. It uses the Happs framework
05:32:50 <pozic> ksf: isn't it better to use a Coq like to do these kinds of things?
05:32:52 <sm> which now lives at happstack.com, which has some docs
05:32:57 <Lanjiao> dino-: looking forward to it
05:32:58 <ksf> Lanjiao, iirc hackage is available on hackage.
05:32:58 <Lemmih> sm: Hackage doesn't use happstack yet.
05:33:14 <ksf> pozic, not if you want to write a haskell library.
05:33:18 <sm> right
05:33:24 <dino-> Lanjiao: That site works though, at the URL above. Go play with it.
05:33:29 <pozic> ksf: you can extract the Haskell code from it, no?>
05:33:42 <pozic> ksf: or is the mapping too low-level?
05:33:51 <CalJohn> quicksilver: i went to a summer school for intermediate (ish) haskellers in utrecht and out of about 6 or 7 people i asked, none like rwh and all but 1 disliked
05:34:12 <pozic> CalJohn: what books did they like?
05:34:16 <sm> for completeness: http://hledger.org:5000 is also haskell
05:34:29 <ksf> ...in general, not if you're someone who wants to code stuff that produces interesting effects and values, in contrast to coding stuff that produces things that inhabit interesting types.
05:34:34 <sm> that's 5 haskell-based sites on the public web. Not enough!
05:34:59 <Martijn_> CalJohn: Where are you from? Did you like the summer school?
05:35:09 <ksf> also, I fould every single proof assistant to be unaproachable without a PhD.
05:35:14 <CalJohn> Martijn_: i loved the summer school (from the UK)
05:35:23 <sm> http://gitit.net/, 6
05:35:26 <Martijn_> Glad to hear that :-)
05:36:08 <CalJohn> pozic: everyone really liked the bird book, and lots of the people who know the theoretic stuff before they arrived (I didn't) liked tapl
05:36:18 <CalJohn> *knew
05:36:42 <chessguy> CalJohn, maybe that's why they were in summer school? :)
05:37:09 <ksf> pozic, after all, the "proof" goes like this: I don't want to allow (Set (Set a)), therefore the above instance isn't undecidable, therefore we need data kinds so I can express it.
05:37:10 <CalJohn> i'm reading tapl at the moment
05:37:16 <CalJohn> chessguy: what is?
05:37:23 <Martijn_> What's tapl short for?
05:37:39 <CalJohn> types and programming languages
05:37:50 <CalJohn> by ben pierce
05:37:56 <dino-> That web app is built with nothing more than Network.CGI and Text.XHtml. I wanted to learn how the basic stuff works before diving into one of the several frameworks out there.
05:38:12 <pozic_> CalJohn: isn't that just because that's the only book they read?
05:38:19 <Martijn_> Aha
05:38:22 <Martijn_> Thanks
05:38:43 <mapreduce> What's the bird book?
05:39:03 <CalJohn> mapreduce: richard bird's functional programming book
05:39:24 <CalJohn> pozic_: no, i don't think so.  people seemed to have tried to read RWH (I _really_ have) and didn't like the presentation
05:39:31 <mapreduce> "Introduction Functional Programming"
05:39:40 <pozic_> CalJohn: there are a lot more books than those two.
05:39:42 <mapreduce> Wow, the title is ungrammatical.  Not a good start. :)
05:39:43 <phil__> CalJohn: Love that book. The second one has more cool stuff as well on dependent types and the like.
05:40:03 <phil__> CalJohn: It uses Ocaml unfortunately.
05:40:07 <CalJohn> phil__: the second of which book?
05:40:17 <phil__> CalJohn: Types and Programming Languages.
05:40:17 <pozic_> AFAIK, the Bird book solves some trivial problems in an elegant way.
05:40:38 <CalJohn> i think the bird book is aimed differently from RWH anyway
05:41:01 <phil__> CalJohn: It's called Advanced Topics in Types and Programming Languages.
05:41:01 <pozic_> In many ways RWH does more difficult things.
05:41:27 <mapreduce> Amazon says it's by Richard and Phillip Wadler Bird. :)
05:41:28 <pozic_> You could argue that RWH is not a good book to start with. I don't like RWH myself.
05:41:31 <mapreduce> http://www.amazon.com/Introduction-Functional-Programming-Richard-Philip/dp/B000OJ0KSY
05:41:52 <Martijn_> Amazon fails :-P
05:41:55 <ksf> we're getting into pascal-style arguments.
05:42:03 <ksf> "basic spoils programmers"
05:42:09 <chessguy> pozic_, i wouldn't recommend RWH to a beginner, but for an intermediate haskeller it's pretty good
05:42:16 <surgeon> what is the difference between types Int and Integer? I want to access a list element with list!!index and he complains about can't matching one of this type against a given (the other)
05:42:24 <pozic_> chessguy: yes, that's what I was saying.
05:42:28 <CalJohn> mapreduce: i think the second edition lists the authors differently
05:42:29 <chessguy> surgeon, an Integer is infinitely precise
05:42:31 <ksf> what a load of bull. if you can't code with goto without producing spaghetti code, pascal won't save you, either.
05:42:50 <chessguy> surgeon, an Int is 32 or 64 bits, depending on the system
05:43:00 <CalJohn> phil__: yes, I'll have a look into that one when I am back in the vicinity of a library
05:43:08 <chessguy> > maxBound :: Int
05:43:09 <lambdabot>   9223372036854775807
05:43:13 <surgeon> chessguy: can I easily convert between those?
05:43:18 <chessguy> > maxBound :: Integer
05:43:19 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
05:43:19 <lambdabot>    arising...
05:43:33 <ksf> so, no, rwh doesn't spoil programmers by not starting out with category theory and curry howard. even if it glosses over details.
05:43:37 <chessguy> surgeon, unlexx it's too big of a value, sure
05:43:59 <Martijn_> Integer is unbounded... so no Bounded instance exists
05:43:59 <chessguy> s/xx/ss/
05:44:04 <chessguy> weird typo
05:44:56 <CalJohn> i don't want to be rude about rwh, I don't think it's bad, but pretty much by problem learning from it was that it didn't introduce things in a sensible order (i remember lots of things being pointed out to be explained in a future chapter) and that the large examples obscured the lessons
05:44:58 <ksf> > 1/0 :: Integer
05:44:58 <Axman6> > fromIntegral (2^64 :: Integer) :: Int
05:44:59 <chessguy> Martijn_, that was my point
05:44:59 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
05:44:59 <lambdabot>    aris...
05:45:00 <lambdabot>   0
05:45:08 <dino-> Also terrific is the Rabhi/Lapalme Algorithms book. http://www.iro.umontreal.ca/~lapalme/AlgoFP/start.html
05:45:13 <Axman6> > fromIntegral (2^64 -1 :: Integer) :: Int
05:45:14 <ksf> > fromIntegral (1/0) :: Integer
05:45:14 <lambdabot>   -1
05:45:15 <lambdabot>   Add a type signature
05:45:19 <ksf> huh.
05:45:23 <CalJohn> i now understand almost everything in RWH, with the exclusion of monad transformers.  have to be off now
05:45:31 <ksf> > fromIntegral (1/0::Float) :: Integer
05:45:33 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Float)
05:45:33 <lambdabot>    arising from a use o...
05:45:42 <ksf> ugs.
05:45:52 <ksf> how did that Integer-maxbound bug work?
05:46:09 <dino-> CalJohn: This is good too for transformers: http://user.cs.tu-berlin.de/~magr/pub/Transformers.en.html
05:46:11 <pozic_> RWH is interesting, because it is the only book written by a user of the language and not just to communicate to the masses what the marbles of functional programming are.
05:46:36 <dino-> _Monad Transformers Step by Step_
05:46:37 <ksf> ...as if dons wasn't an evangelist...
05:46:42 <pozic_> ksf: he is
05:46:53 <pozic_> ksf: _just_
05:47:02 <Axman6> they're all users of the language no?
05:47:34 <pozic_> Axman6: I doubt there are useful applications written by Bird.
05:47:41 <ksf> rwh wins because it has the least amount of greek variables of the whole lot.
05:48:37 <chessguy> funny, i'd count that as a strike against RWH :)
05:49:06 <chessguy> (though not much of one)
05:49:07 <arw_> rwh has some really good points where it teaches real applications. but the parts where it tries to explain theory are not that nice.
05:49:11 <ksf> what's missing are the proofs.
05:49:48 <arw_> yep. whats missing are more accuracy and attention to detail. at least in the theoretical parts.
05:49:54 <ksf> ...those proofs that you carefully made the reader understand for the last 10 chapters, and then just spell them out, astonishing them that they can grok an qed instantly.
05:51:15 <Lanjiao> sm: thanks a lot.
05:51:18 <ksf> "To pick the first instance above, use -XIncoherentInstances
05:51:18 <ksf>      when compiling the other instance declarations"
05:51:23 <ksf> no I won't fall for that.
05:51:42 <ksf> ghc is trying to lead me to the dark side.
05:51:44 <ksf> I must resist.
05:51:55 <vav> > ceiling (1/0) :: Integer
05:51:56 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
05:52:03 <fasta> dino-: If by terrific, you mean terrible, then sure.
05:52:03 <ksf> yep that was it.
05:52:24 <Martijn_> huh?
05:52:41 <ksf> > length $ show (ceiling (1/0) :: Integer)
05:52:42 <lambdabot>   309
05:52:43 <dino-> fasta: :(
05:52:54 <fasta> dino-: there was one useful page in the whole book.
05:53:06 <ksf> > length $ show ((ceiling (1/0) :: Integer)*10)
05:53:07 <lambdabot>   310
05:53:12 <fasta> dino-: but maybe it depends on your background.
05:53:23 <ksf> so much for infinity * 10 = infinity...
05:53:26 <Martijn_> > length $ show (ceiling (2/0) :: Integer)
05:53:28 <lambdabot>   309
05:54:13 <pr> ksf: heh, it's wrong anyways
05:54:14 <pr> ;)
05:55:10 <Lemmih> Should 'ceiling (1/0)' throw an error?
05:55:15 <dino-> fasta: If you bought it, and then were basically totally bored, I could see being disappointed. It's an expensive book! At least it was for me.
05:55:36 <ksf> probably. how's it defined in IEEE?
05:56:08 <ksf> ...both floor and ceil of inf should be inf, I guess.
05:56:10 <fasta> dino-: I read it for free from the university library. I read it from start to end (otherwise you cannot make up an opinion about it).
05:56:53 <fasta> dino-: for me, it was a complete waste of time.
05:56:53 <ksf> ...we can do integral types that support infinity, though.
05:57:20 <ksf> ceiling (1/0) could be infinity = Succ infinity
05:58:36 <ksf> ...monad transformers are way more trivial than monads themselves.
05:58:51 <ksf> it's just nesting types.
05:59:46 <chessguy> hey edwardk_ do you have a minute to look at something?
06:00:12 <fasta> chessguy: what happened to your genetic programming based chess player?
06:00:43 <chessguy> fasta, shelved for now, i'm starting a little more basic
06:01:14 <chessguy> designing a language for talking about strategy before i automatically build programs in that language :)
06:01:40 <jethr0> anyone know what the difference between a "MVar []" and a "Network.Chan.Chan" is?
06:01:56 <jethr0> sorry, Control.Concurrent.Chan, that is
06:02:06 <Martijn_> The operations defined on those types?
06:02:27 <Martijn_> A channel is just a concept with some handy functions. Maybe you can implement it with MVar [].
06:02:51 <quicksilver> CalJohn: that's interesting but not really relevant to beginners
06:03:12 <quicksilver> which is what I thought we were discussing ;)
06:03:19 <quicksilver> intermediate summerschoolers != beginners
06:03:41 <Axman6> jethr0: Chans are non blocking for anything putting something onto the chan
06:03:45 <quicksilver> Martijn_: IIRC, you need at least MVar () + MVar [] to implement the basis features. But you need something much cleverer for dupChan
06:03:51 <jethr0> Martijn_: i can't see many handy functions. (writeChan, readChan, isEmptyChan) i could easily write for "MVar []" as well. you think that's the only difference?
06:03:53 <quicksilver> Martijn_: (which is why Chan uses something celverer)
06:04:03 <jethr0> ah
06:04:10 <Axman6> jethr0: with MVar [a], you need to take the list out, and when you do that, nothing else can place something in the queue
06:04:18 <jethr0> k
06:04:21 <Twey> jethr0: You couldn't
06:04:21 <Axman6> also, someone reading from the chan blocks someone writing to it
06:04:22 <Twey> Right
06:04:34 <Martijn_> Yes, I was just thinking about dupChan, it seems non-trivial
06:04:44 <jethr0> k, thx a lot guys
06:05:55 <Martijn_> data Chan a = Chan (MVar (Stream a)) (MVar (Stream a)). type Stream a = MVar (ChItem a). data ChItem a = ChItem a (Stream a).
06:06:05 <Martijn_> I'd call that non-trivial :-P
06:07:01 <jethr0> ups, Stream is an infinite stream of MVars... *aahh*
06:07:49 <chessguy> @tell edwardk_ i've been playing around with a zipper-based representation for composable tree-searching strategies. my hope is to write a combinator library that will allow you to quickly combine domain-specific and domain-agnostic searching strategies. the beginnings of my ideas are at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8961#a8961 . i'm sure this code is quite trivial for you, but i'd love to hear any feedback you might
06:07:49 <chessguy>  have
06:07:49 <lambdabot> Consider it noted.
06:10:10 <ksf> argh. I was thinking the worng way round the whole time.
06:12:58 <quicksilver> Martijn_: it's almost just a List with MVars all the way down
06:13:04 <quicksilver> Martijn_: which is quite a natural construct
06:13:12 <quicksilver> Martijn_: it just adds a tail pointer, too, for efficiency
06:13:23 <Martijn_> Yes
06:13:24 <quicksilver> (but that "efficiency" also gives you a clever way of doing dupChan)
06:13:45 <quicksilver> by sharing the spines of the list and only moving the tail pointers individually
06:17:11 <jethr0> when I have a socket open, can one thread write to it continually while another thread blocks while reading from it?
06:17:44 <quicksilver> jethr0: yes.
06:17:50 <quicksilver> jethr0: and that is the best way of doing things
06:17:50 <jethr0> cool
06:17:55 <quicksilver> always two threads per socket
06:17:58 <quicksilver> one reader, one writer.
06:18:10 <jethr0> what do you mean "always"?
06:18:20 <quicksilver> "always" - "in every case, without exception"
06:18:24 <quicksilver> ;)
06:18:43 <quicksilver> if you try to use one thread to both read and write you risk deadlocking.
06:18:48 <quicksilver> it's much saner to use two.
06:18:55 <jethr0> but in 'special' cases i could do "open socket; write to socket; read from socket" in a single thread, no?
06:19:22 <jethr0> k, and then i'd likely use a channel to sync the two threads
06:19:24 <Twey> Sure, but then you can't write until you've read.
06:19:43 <quicksilver> the writing might block
06:19:48 <quicksilver> and there might be some part ot read
06:19:51 <jethr0> yes, i understand that, just trying to get clear on the whole "always" business ^_^
06:19:54 <quicksilver> but you wouldn't read it
06:20:00 <quicksilver> because you're still blocked on the writing
06:20:35 <jethr0> so i split them with forkIO and reconnect them via a channel? is that an acceptable way of doing it?
06:21:03 <yitz> I thought of an exception - when you are not both reading and writing - hah!
06:21:03 <Craig`> hello
06:21:13 <Craig`> I might learn haskell again - I never got good at it
06:21:17 <yitz> hi Craig`
06:21:17 <jethr0> hello Craig`
06:21:19 <Twey> Good day
06:21:25 <ksf> I've made my stuff pass the type checker, but now I've got no way to get hold of the constructors and deconstructors of an associated data type.
06:21:28 <quicksilver> jethr0: right.
06:21:32 <jethr0> you can always continue from where you left it off ;)
06:21:43 <yitz> Craig`: have you seen Real World Haskell?
06:21:48 <Craig`> it's just that I'm going to be doing a lot of maths - GCSE - and I thought incorporating it into programming would be a two way gain
06:22:03 <Craig`> yitz: I looked at the site of it a little, never read it, or bought it
06:22:17 <Craig`> I went over this cartoony tutorial iirc
06:22:18 <Makoryu> Craig`: Hey, I had to follow three different tutorials (including RWH) before I got even remotely comfortable with it
06:22:21 <Craig`> it had an acroymn
06:22:28 <Makoryu> Craig`: LYAH?
06:22:31 <yitz> Craig`: if you already are good at a different programming language, that's the way to go
06:22:32 <Craig`> that's it
06:22:37 <jethr0> it's a really good book and you can always browse the site if you don't buy it. also there learn me a haskell
06:22:49 <ksf> the thing is, I want to make functions work on both a and Foo a, where Foo a is an associated type.
06:22:50 <orbitz> has anyone reads Marlow's high-speed web-server paper and know if the full-code is available somewhere?
06:22:53 <Makoryu> Craig`: http://learnyouahaskell.com/ <- Last vestige of the viral memes of _why
06:22:55 <jethr0> @where lyah
06:22:55 <lambdabot> www.learnyouahaskell.com
06:23:11 <ksf> and I want to automagically coerce between those two types.
06:23:12 <Twey> Craig`: You won't learn much at G.C.S.E. that will help you with Haskell ;)
06:23:28 <Craig`> yitz: I'm not really good at other languages, I just get the basics, would you advise me to learn C in depth before haskell (I know they don't relate in any way, but for theory?)
06:23:33 <jethr0> Twey: he might be looking at it the other way round
06:23:36 <Craig`> Twey: yeah I know GCSE won't help me learn haskell
06:23:38 <Twey> Point.
06:23:43 <Craig`> but haskell might help me get good at maths :P
06:23:44 <yitz> no need Craig`
06:23:59 <Craig`> I mean I'm going to revise for ~2 hours per night  on maths alone as I start school again next week
06:24:01 <jethr0> Craig`: not knowing any other languages can be a bonus in haskell. don't learn C before haskell. learn it after ^_^
06:24:02 <Craig`> to enter my last year
06:24:06 <Twey> Craig`: No, I would certainly not advise you to learn C before Haskell.
06:24:18 <ksf> Craig`, you should unlearn C in depth before picking up haskell.
06:24:22 <Twey> You'd immediately double your workload :Ã¾
06:24:23 <jethr0> hehe
06:24:28 <Craig`> I don't know C in depth :)
06:24:35 <Twey> Forget all about C.
06:24:40 <Twey> Pretend it never existed.
06:24:43 <Craig`> tbh the only thing that I'd say that I'm alright in is xhtml and css :P
06:24:51 <Makoryu> Craig`: I've found that imperative languages are much much easier to learn now that I know Haskell
06:24:52 <Craig`> as I want to be a web dev, but let's not get into that
06:24:52 <ksf> Craig`, xslt?
06:24:57 <dino-> Nothing to C here, folks. Move along.
06:25:01 <jethr0> see, first step already completed. easy as pie
06:25:19 <Twey> dino-: *grooan*
06:25:29 <Craig`> and also, if I remember correctly, last time I was here I was told that haskell is very nice when working with maths :)
06:25:31 <Twey> Craig`: You don't.  Trust me.  ;)
06:25:38 <saml> C is awesome /* means comment
06:25:50 <saml> > let 1 /* 2 = 0 in 1 /* 2
06:25:52 <lambdabot>   0
06:26:00 <ksf> ...xslt would be a viable functional programming language, if it wasn't for its syntax and general w3c-ness.
06:26:09 <Twey> Haskell is nice when working with anything, generally.
06:26:32 <yitz> ksf: xslt is a pain
06:26:34 <saml> can you help me to genergate C++ code from a tree?
06:26:48 <saml> like, lambda expression tree for example
06:26:53 <ksf> they always seem to spend the whole of panama on a two-banana problem.
06:26:58 <yitz> saml: cut it down, make it into paper, and write your C++ code on it
06:27:08 * yitz is in a weird mood today
06:27:24 <Craig`> ksf: no I haven't done any xslt yet,
06:27:42 <ksf> yitz, http://fxsl.sourceforge.net/articles/FuncProg/2.html
06:28:43 <Craig`> the main reason for haskell; as I've said for me would be maths, and this final unit focuses on trig, so I was thinking that I could use svg for shapes for exercises etc, and then once I was good at the formulas, I could embed them into programs and then, hopefully make something somewhat cool :P
06:29:31 <ksf> you can use hieroglyph to do vector graphics and export svg.
06:29:32 <saml> haskell has nothing to do with math. you just type stuff up, compile and run
06:30:03 <quicksilver> haskell has everything to do with math
06:30:04 <yitz> ksf: hahaha yeah, it sure is functional
06:30:08 <quicksilver> what you type *is* math
06:30:30 <Makoryu> Craig`: Haskell isn't so much about understanding programming in terms of math as about understanding math in terms of programming
06:30:32 <vav> Craig`: given that motivation, definitely see if you can find a copy of School of Expression, even though it's a bit dated, it's a fun and deep intro to haskell.
06:30:50 <etpace_> 2hours a night for GCSEs? ouch
06:30:52 <ksf> ...and me having a beer is physics.
06:31:10 <ksf> it's definitely applied biology, though.
06:31:49 <etpace_> is there a 'cheat sheet' for the typeclass heirarchy and their declerations?
06:31:58 <ksf> @where typeclassopedia
06:31:58 <lambdabot> Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
06:32:15 <Craig`> sorry about that
06:32:17 <Craig`> <Craig`> the main reason for haskell; as I've said for me would be maths, and this final unit focuses on trig, so I was thinking that I could use svg for shapes for exercises etc, and then once I was good at the formulas, I could embed them into programs and then, hopefully make something somewhat cool :P
06:32:27 <ksf> ...only the "strange" classes though, not for normal stuff like Num.
06:32:32 <etpace_> I was going to say to save me openin gup TMR each time I forget what's needed for each class :P
06:32:33 <ksf> ...there's the haddock for that.
06:32:49 <yitz> In the words of Dijkstra - computer science is not about computers, just like astronomy is not about telescopes.
06:32:52 <ksf> etpace_, just let the compiler tell you...
06:33:10 <etpace_> mm?
06:33:29 <etpace_> :t fmap
06:33:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:33:38 <etpace_> :t mappend
06:33:39 <lambdabot> forall a. (Monoid a) => a -> a -> a
06:33:44 <etpace_> I guess that works :P
06:33:49 <ksf> well, if you just say ... deriving (Bits), ghc is going to tell you that you also need Num, Show and Eq
06:34:29 <etpace_> It's more so I remember what class mconcat or mplus belong to
06:34:33 <ksf> ...and if you do instance Monoid Foo  without giving methods, it's going to tell you what's missing.
06:34:52 <Makoryu> :t fmap fmap fmap
06:34:53 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:39:13 <jethr0> quicksilver: concerning the read/write threads: do i need to put the Handle in an MVar or can one thread read from a Handle the same time another writes to it?
06:39:49 <Phyx-> lol, almost all the links on  http://tunes.org/~nef/logs/haskell/ for "prettier" logs are dead
06:39:57 <Craig`> I think I'd have to dedicate a few hours per night coding haskell to get it stuck into my head to really understand FP, and so I'll do that when I leave school; easter, but until then I'll experiment with sin, cos and tan a lot :P .. also has anyone here programmed opengl in haskell before?
06:40:15 <jethr0> Craig`: i'm just doing it
06:40:26 <jethr0> there are some nice examples in hackage
06:41:15 <Craig`> does it have any advantages/disadvantages to programming it, in say C? (I'm not going to rant on about speed, as If I needed speed I'd use assembly (but it's not incredibily slow is it?  like processing (made in java)))
06:41:40 <jethr0> you would use "assembly"????
06:42:30 <Makoryu> Craig`: Haskell is a healthy competitor to C in terms of speed. Of course, you have to be experienced and know what you're doing in order to write fast programs, but that's true of all languages
06:42:32 <jethr0> the advantage is that you get to use a non-shooting-yourself-in-the-foot-language. the disadvantage is that not all nice support libraries and game engines are bound to haskell
06:42:49 <Craig`> I didn't mean it like that, "I wouldn't", I'm just saying people rant on about speed, and if they truly wanted it they would use asm
06:42:54 <saml> Craig`, just learn haskell or whatever you want to learn. i tell you that you won't be wasting your time. any language is fine. learning is a good thing.
06:42:58 <Twey> Or FORTH.
06:43:02 <jethr0> but in general i must say that my experience with haskell+openGL was a very pleasant one.
06:43:04 <Twey> Yay FORTH.
06:43:22 <saml> try Java. distribution of java programs are easy as long as you don't use some JNI stuff
06:43:35 <Makoryu> Craig`: People who choose a language based purely on its reputation for speed are boneheads. That's called premature optimization, and every programmer knows what *that* means ;)
06:43:38 <quicksilver> jethr0: it's fine.
06:43:41 <Craig`> yeah, in these next months I'll be doing a lot of haskell/svg + maths, so I'll probs release a lot of somewhat crap snippets xD
06:43:47 <jethr0> except maybe "i'll code my OpenGL program in assembly". that might not be the way to go in 2009 ;)
06:43:49 <quicksilver> jethr0: a Handle is just a value, there is no problem with two threads using it at once
06:43:51 <Jafet> Java gets you to experience first hand mind rot
06:44:12 <Twey> Haskell won't offer you *huge* advantages in terms of using OpenGL, since OpenGL is an imperative library by nature, but of course you can use the functional Haskell style for the rest of your program.
06:44:30 <jethr0> java let's you type in the same thing over and over. and makes you wish you had type aliases
06:44:32 <copumpkin> if you try, you can golf away your imperative programs too
06:44:34 <yitz> Twey: more programs are created every day in a FORTH-family language than in any other language
06:44:34 <Twey> There are also functional wrappers on top of OpenGL, like FieldTrip and whatever that one was that got released the other day.
06:44:44 <copumpkin> but if you don't, you can just write stuff that looks like c
06:44:50 <Twey> yitz: Really?  O.O
06:44:55 <jethr0> reactive-opengl?
06:44:59 <yitz> Twey: yes. Postscript.
06:45:04 <Twey> jethr0: Ah, that could be it.
06:45:07 <Twey> yitz: Oh, aye.
06:45:14 <Makoryu> yitz: That's.... Honestly, that's cheating :p
06:45:21 <arw_> Makoryu: a certain amount of premature optimization is a good thing[tm]. nobody would ever think of starting with prolog and then beginning to optimize his 3d shooter.
06:45:22 <yitz> indeed.
06:45:26 <Makoryu> yitz: My pet rock is a stack machine!
06:45:31 * Makoryu stacks it on yitz's head
06:45:33 <jethr0> for me at least, the reactive experience was somewhat painful. a very cool concept, but rather too different for me yet
06:45:45 <yitz> Makoryu: yes. it's also a Monoid.
06:45:49 <Craig`> anyways, forget OpenGL that's something that I'd do with around 1 or 2 years of experience in a particular language
06:45:57 <Jafet> It's also an exception.
06:46:03 * Jafet throws it at Makoryu
06:46:31 * Makoryu catches and rethrows
06:46:38 <jethr0> arw_: not sure i agree completely. if your problem is sufficiently complex you might never get "any" solution in a low-level language. getting an albeit slow correct solution in a sane language can be a great help
06:46:42 <Jafet> Touche
06:46:46 <fasta> yitz: FORTH-family language? Like?
06:46:53 <Makoryu> Anyway
06:46:57 <yitz> fasta: Postscript.
06:47:05 <Jafet> I wonder if you can implement pong using exceptions
06:47:08 <jethr0> and if your problem isn't sufficiently complex, make it so by using incredibly difficult-to-implement but reall fast data types
06:47:22 <fasta> yitz: end-users don't write in PostScript a lot.
06:47:32 <Jafet> jethr0, the more dangerous reality is that you end up writing an inferior solution
06:47:32 <jethr0> fasta: you think?
06:47:43 <Jafet> And so you think that what you did is sufficient
06:47:56 <Makoryu> arw_: It's perfectly plausible to get your algorithm working in a high-level language of any kind, and then compile it (with a compiler, or by hand...!) to a lower-level language such as C
06:47:58 <fasta> jethr0: otherwise I wouldn't say it.
06:48:03 <yitz> fasta: I've done it. you can actually write decent programs in it for certain things. unlike the spaghetti that comes out of printer drivers.
06:48:22 <jethr0> Jafet: hmm, hmm. My second line was more of a joke. but i really think that high-level languages give you an immense advantage for really complex problems
06:48:23 <fasta> yitz: Forth is a good idea, imho. You don't have to convince me.
06:48:36 * Twey hearts FORTH.
06:48:49 <Craig`> would haskell be alright for this?: I would like to create a script of which you can move the mouse to certain places, click it etc, if it finds a specified color it'll click there, specified picture etc? (this is already done in pascal, but I wouldn't mind having a go of doing something like it myself but in haskell, obv this would be a long time in the making, though)
06:48:57 <Twey> Makes me wonder why more people don't use it instead of the mess that is C.
06:48:58 <Jafet> Paradoxically, sane languages tend not to just let you write a solution at all, the solution tends to be better
06:49:19 <Axman6> Craig`: that'll get you kicked off WoW man :P
06:49:29 <Twey> Hehehe, I was just thinking the same
06:49:34 <Twey> But yes, it's possible.
06:49:35 <Craig`> it's not for WoW :P
06:49:36 <jethr0> Jafet: and i've tried my heart out to write k-d-trees and the like in C++. I got so stuck with all the low-level bullshit that it was a misery. doing the same thing in haskell can be so much more concise and easy
06:49:47 <Axman6> Craig`: i'm pretty sure there's no way to move the mouse in haskell.
06:49:52 <fasta> Twey: Forth is too dynamic.
06:49:58 <Twey> Axman6: There probably is using the X11 library, though.
06:49:59 <Jafet> And if you do it in ocaml, it's more *efficient*
06:50:02 <Twey> (or the Win32 one)
06:50:06 <Axman6> not that there couldn't be, there just isn't. haskell is about computation more than IO
06:50:11 <yitz> Twey: people who have done serious system programming in Forth say that when things start to get complex, you end up wasting a lot of time trying not to get confused about the stack layout at any given point.
06:50:23 <fasta> Twey: businesses want static languages because they can hire a random guy of the street to continue working on the code.
06:50:26 <Twey> yitz: Really?  Huh.
06:50:29 <Axman6> Craig`: rune scape?
06:50:37 <saml> how would you model mouse movement? (time, (mouseX, mouseY))  ?
06:50:39 <fasta> Twey: at least, that's the reasoning.
06:50:44 <Craig`> Axman6: yeah :P
06:50:49 <jethr0> exactly! for many problems proper data types with good O() performance beat bit-twiddling. and the former is just so much easier in some languages
06:50:55 <Craig`> runescape, I don't play it, it would just be a projec
06:50:58 <Jafet> fasta, that used to be the reasoning. Now they use C because everything is in C.
06:51:00 <Axman6> i have a friend who mde a really good bot like that for RS
06:51:01 <Craig`> s/ec/ect/
06:51:11 * Jafet makes a snowball
06:51:12 <Craig`> Axman6: was it in SCAR?
06:51:18 <fasta> Jafet: and C==Java now.
06:51:19 <Axman6> i have no idea...
06:51:32 <Craig`> heh okay
06:51:45 <jfoutz> fasta: it cuts both ways. i'd say 90% of programmers show up for the check. no interest in anything other than what they learned back in school and get paid for.
06:52:04 <Axman6> here's some interesting news: the JVM in OS X 10.6 uses LLVM in the hotspot compiler bits.
06:52:13 <dino-> I've heard it derogatorily joked that Java and J2EE is the new COBOL. In the sense that many business got way down into the EJB hole and there's a ton of this stuff nobody wants to maintain anymore.
06:52:17 <Jafet> I bet mediocre C code is much much better than mediocre forth code
06:52:23 <dino-> *businesses
06:52:24 <Axman6> win 20
06:52:26 <Axman6> whoops
06:52:37 <Craig`> would you advise me to read LYAH or RWH first?
06:52:37 <yitz> dino-: MS would like you to believe that
06:53:02 <jfoutz> Jafet: no. mediocre c segfaults. mediocre java is just slow.
06:53:03 <dino-> yitz: Ha, I bet they would
06:53:12 <Axman6> Craig`: LYAH
06:53:46 <phil__> Craig: I wrote a simple SDL/OpenGL image viewer in Haskell recently. The OpenGL bindings are very nice.
06:53:51 <yitz> Jafet: for mediocre code, any language will do
06:54:28 <etpace_> is BONUS still working on LYAH?
06:54:52 <yitz> etpace_: last I heard he was working on typesetting it for print
06:55:26 <etpace_> i'm looking forward to Monad Transformers
06:56:49 <yitz> jfoutz: mediocre Java throws null pointer exception about as often as mediocre C segfaults
06:57:28 <fasta> Mediocre Coq on the other hand ...
06:57:49 <Craig`> sorry about that
06:57:51 <Craig`> my computer froze
06:58:00 <Craig`> so I don't know if you guys said anything to me
06:58:04 <Jafet> yitz, incredibly, the Java language does not have pointers
06:58:40 <Twey> Nevertheless, it throws NullPointerExceptions :Ã¾
06:58:46 <yitz> Jafet: but it throws that exception when you try to call a method on null
06:59:07 <Twey> I think it would be more accurate to say that it does have pointers, it just doesn't let you manipulate them manually.
06:59:26 <Twey> Any object assignment automatically results in a pointer.
06:59:30 <Jafet> That's like saying lisp has opintes
06:59:41 <Jafet> Wow, best typo ever
06:59:46 <Twey> Hahaha
06:59:52 <ski> Craig` : see end of <http://tunes.org/~nef/logs/haskell/09.09.02> for the scrollback
06:59:56 <SamB_XP_> Jafet: well, I used to say the same thing about Python!
07:00:19 <saml> > (+ 1 2 3 4 5)
07:00:20 <lambdabot>   Add a type signature
07:00:25 <Craig`> ski
07:00:30 <saml> > (+ 1 2 3 4 5) :: SExpr
07:00:31 <lambdabot>   Not in scope: type constructor or class `SExpr'
07:00:41 <Craig`> *thanks ski
07:00:49 <Jafet> > ((+) 1 2)
07:00:50 <lambdabot>   3
07:00:50 <ski> (EIAP ..)
07:01:24 <jfoutz> yitz: true enough. java is nurf C. there are soooo many ways to get into trouble in C that java just avoids. I'd bet if you hold rate of segfault & npe constant, and programmer time constant, there will be more lines of code of java, and probably more features.
07:03:48 <SamB_XP> I still think NullPointerException is a crazy exception to have in a language that doesn't support any kind of direct pointer access!
07:05:02 <Jafet> > ((+) 1 2 3)
07:05:04 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
07:05:04 <lambdabot>    arising from the literal `1' at <...
07:05:36 <jfoutz> > foldl1 (+) [1..3]
07:05:37 <lambdabot>   6
07:05:38 <saml> > let (+) = product in ((+) [1, 2, 3])
07:05:40 <lambdabot>   6
07:05:50 <Jafet> Har
07:06:53 <seanmcl> hi, is there a way to give a signature to instance declarations:
07:06:55 <seanmcl> instance Class Int where
07:07:02 <seanmcl>   f :: Int -> String
07:07:08 <seanmcl> f = show
07:07:10 <ski> SamB_XP : maybe it ought to be called `NullObjectException' ?
07:07:46 <SamB_XP> ski: is that what it means?
07:07:52 <Jafet> Maybe they should have just followed elementary common sense and made null an object.
07:08:02 <orbitz> is forkIO lightweight enough to create a ton of them?
07:08:17 <doserj> seanmcl: no. you can only give one type signature to a function, and one is already provided in the class definition.
07:08:18 <Jafet> Short or metric?
07:08:30 <SamB_XP> orbitz: how big a ton?
07:08:31 <Martijn_> > x + y
07:08:32 <lambdabot>   x + y
07:08:38 <orbitz> SamB_XP: hundreds
07:08:46 <SamB_XP> I think so
07:09:02 <seanmcl> doserj: ok, thanks.  That's a little annoying, since then to read the code you have to look into another file.
07:09:05 <Axman6> orbitz: sure
07:09:16 <ski> SamB_XP : afaik, you get it when you try to invoke a method (or access a member) on the `null' object
07:09:18 <orbitz> awesome
07:09:38 <Martijn_> Pointers in Java are called references
07:09:39 <saml> seanmcl, in ghci, you can use :i
07:09:48 <quicksilver> yes, it ought to be a NullReferenceException
07:10:05 <orbitz> null references, HISSSSSS
07:10:09 <seanmcl> saml: true, thanks
07:10:10 <Axman6> orbitz: it's pretty damn light weight. take a look at the shootout's thread ring program (that's #1 of all languages). it creates 503 threads, and passes a token between them 50,000,000 times in 15 seconds
07:10:15 <jfoutz> orbitz: each thread is about 300 bytes of overhead
07:10:27 <orbitz> awesome
07:10:42 <SamB_XP> quicksilver: I was thinking it should maybe be called that because you're trying to refer to somethinh on `null'
07:10:48 <orbitz> is the impl smart enough to maek OS threads to take advantage of multipel prcs?
07:11:09 <quicksilver> NullObject would also be a good name, yes.
07:11:20 <Jafet> Depends on which implementation, ainnit
07:11:23 <SamB_XP> orbitz: I'm not sure if it does that by itself ...
07:11:31 <SamB_XP> orbitz: but it can if you tell it
07:11:43 <sjanssen> orbitz: GHC can schedule green threads on multiple OS threads simultaneously
07:11:43 <orbitz> what should I look up in documentation?
07:11:47 <SamB_XP> and apparantly now you don't even have to tell it how many
07:11:57 <sjanssen> orbitz: search for "threaded RTS"
07:11:59 <SamB_XP> orbitz: RTS flags ?
07:12:12 <orbitz> dam threading in haskell sounds pretty f'ing amazing
07:12:25 <Craig`> does haskell have pointers? (I know that it's googleable)
07:12:32 <SamB_XP> Craig`: yeah!
07:12:38 <SamB_XP> @doc Foreign.Ptr
07:12:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
07:12:48 <Axman6> Craig`: technically... but yo won't be using them for a long time ;)
07:12:53 <Axman6> you*
07:12:55 <SamB_XP> Craig`: look, some nice juicy documentation
07:13:11 <SamB_XP> they're mostly intended for interfacing with C
07:13:12 <Craig`> thanks SamB_XP  and Axman6
07:13:40 <SamB_XP> though Data.ByteString uses them to, I believe
07:13:42 <orbitz> Craig`: you use Maybe monad where one would generaly use a null pointer in another langauge
07:13:44 <Craig`> haskell.org needs a rewrite - html that  is o.o
07:13:45 <SamB_XP> s/to/too/
07:13:52 <Martijn_> "This domain name, "monad.st", may still be available for registration!" Geez
07:13:56 <SamB_XP> Craig`: hmm?
07:14:00 <Craig`> the html is herrific
07:14:05 <SamB_XP> which page?
07:14:05 <Craig`> and unsemantic
07:14:10 <Craig`> the one you listed me
07:14:24 <orbitz> are you readign HTML raw these days?
07:14:28 <SamB_XP> ah, so you mean *haddock* needs a rewrite?
07:14:40 <copumpkin> Craig`: take the lead!
07:14:43 <SamB_XP> you can do this if you like :-)
07:14:44 <Axman6> Craig`: the code looks like that on purpose
07:14:57 <Axman6> there are good reasons for it
07:15:04 <Craig`> Axman6: why so
07:15:07 <SamB_XP> Axman6: like wut?
07:15:31 <SamB_XP> anyway, Craig` could still write an alternate format for haddock output, right?
07:15:43 <Axman6> well, making sure the close of one tag and the open of the next tag are next to each other, means you don't get any nasty surprises with whitespace you didn't expect
07:15:46 <jethr0> what is the behavior of "hGetLine" when there is nothing to read? i.e. when a message on a socket has not yet arrived?
07:15:52 <dino-> Apologies if this is silly to ask, but I really have no LISP knowledge. Does something similar happen with null in LISP? Something like npe?
07:15:53 <Craig`> SamB_XP: are you asking if I could recode the html?
07:16:02 <copumpkin> Craig`: it's autogenerated
07:16:06 <SamB_XP> Axman6: that doesn't have anything to do with unsemantic!
07:16:10 <Craig`> meh wysiwyg ftl
07:16:12 <Craig`> http://paste2.org/p/410422 yack
07:16:20 <Axman6> is unsemantic even a word?
07:16:20 <Jafet> dino-, what? lisp has no pointers.
07:16:32 <Jafet> It's an adjective
07:16:34 <phil__> dino-, nil is an object in Lisp.
07:16:40 <Craig`> Axman6: no, but un-semantic will be, I presume
07:16:41 <Jafet> I think samb wanted a noun there
07:16:41 <copumpkin> Craig`: the >< on the beginning of the line is fine, if not to your aesthetic taste
07:16:49 <copumpkin> the "unsemantic" problem is valid, I think
07:16:55 <Axman6> un-anything is not a word ;)
07:17:04 <Craig`> copumpkin: it's not the >< that I'm unhappy about xD
07:17:07 <lilac> Martijn_: you mean I can have Control.Monad.ST as my domain name? yow!
07:17:09 <Axman6> what's 'unsemantic' about it?
07:17:20 <copumpkin> Axman6: it doesn't "separate from from content"
07:17:24 <doserj> Axman6: un-derstood :)
07:17:24 <jethr0> does hGetLine then block?
07:17:26 <Craig`> it's that it doesn't seperate content (structure) and presentation
07:17:27 <SamB_XP> Axman6: tons of tables
07:17:37 <int-e> The naming of car and cdr has nothing to do with pointers? ;)
07:17:40 <jfoutz> dino-: sort of. take the car of an empty list. pretty much the same as head []. it's an exception because something is null... not nessecarily a null ponter though.
07:17:41 <Craig`> tables == tabular data, !layout
07:17:43 <Craig`> s/!/not/
07:17:50 <SamB_XP> copumpkin: first from should be "form", no?
07:17:52 <Axman6> s/not/Â¬
07:18:07 <copumpkin> SamB_XP: lol yeah
07:18:18 <phil__> dino-: If you try to add nil to a number in Lisp, it'll throw the same type error as if you tried to add a string to a number.
07:18:19 <Craig`> Axman6: you missed the fianl slash, nub :D
07:18:24 <copumpkin> Craig`: I think the html layout stuff was written before css was popular, or whoever wrote it wasn't aware of its popularity ;)
07:18:37 <phil__> I should probably put "type" in scare-quotes.
07:18:45 <dino-> ok
07:18:56 <SamB_XP> anyway, I'm certainly not going to dispute Craig`'s claim that haddocks' HTML output is non-semantic
07:18:59 <Craig`> copumpkin: he still needs sorting out :)
07:19:00 <ski> (int-e : "contents of address register","contents of decrement register" iirc)
07:19:01 <SamB_XP> it really really is!
07:19:08 <Axman6> Craig`: i don't need trailing slashes
07:19:48 <Craig`> right; back to haskell..
07:19:50 <Martijn_> The HTML style haddock uses prevents spaces from creeping into places where they shouldn't be
07:20:06 <copumpkin> yep, we've already established that :)
07:20:09 <Martijn_> oh sorry
07:20:19 <Jafet> When I make a website it will all be served in tex.
07:20:23 <Martijn_> Maybe I'm not paying attention
07:23:31 <Martijn_> "Guess your own IQ. If you guess right you have a high IQ."
07:23:37 <SamB_XP> what is that LaTeX package called that renders to HTML?
07:24:24 <SamB_XP> Craig`: anyway, you can submit a ticket to http://trac.haskell.org/haddock and then start fixing it by doing:
07:24:27 <pozic_> SamB_XP: latex2html
07:24:34 <SamB_XP>    darcs get http://code.haskell.org/haddock/
07:24:49 <SamB_XP> pozic_: that's not a LaTeX package, that's a perl program
07:25:20 <SamB_XP> which, ironically, used to be used (with custom extensions!) to build Python's HTML documentation!
07:25:29 <Craig`> SamB_XP: I would do it, I just don't have the time, as I return to school on monday, and I have a lot of coursework to be doing
07:25:49 <SamB_XP> yes, that's write, the Python people wrote custom Perl code to format their documentation in HTML!
07:25:53 <SamB_XP> er. s/write/right/
07:26:05 <SamB_XP> Craig`: well, you could at least make sure there's a ticket
07:26:27 <SamB_XP> Craig`: and you might be surprised how simple the code is!
07:26:28 <Craig`> how do I make this "ticket"?
07:27:05 <SamB_XP> well, first click "view tickets" and pick "active tickets" or something
07:27:12 <SamB_XP> to make sure there's not one for this already
07:28:12 <SamB_XP> ah, looks like #108 may be relevant...
07:28:30 <Craig`> where's view tickets o.o
07:28:45 <SamB_XP> it was at the top of the URL I gave you before
07:29:01 <Craig`> http://code.haskell.org/haddock/ ?
07:29:22 <SamB_XP> no, the http://trac.haskell.org/haddock/ one.
07:29:29 <SamB_XP> anyway, the ticket I found is http://trac.haskell.org/haddock/ticket/108
07:29:59 <Craig`> oh ok
07:30:23 <SamB_XP> so now the thing to do is CC yourself on this ticket
07:32:38 <SamB_XP> hmm. it would be nice if you could stick /raw/ just before an attachment name in trac to view the attachment at the usual mime type for it's extension ...
07:33:06 <pozic_> SamB_XP: does such a LaTeX package exist in the first place then?
07:33:12 <SamB_XP> pozic_: yes!
07:33:15 <SamB_XP> it does
07:33:51 <pozic_> SamB_XP: I would love to see that craziness.
07:33:54 <Craig`> meh I want to play on my pc games, but I'm waiting to get win7
07:34:00 <SamB_XP> it's more recent than latex2html or hevea, I think, but yeah
07:35:14 <SamB_XP> tex4ht, is it?
07:35:48 <SamB_XP> hmm. perhaps not ...
07:38:37 <SamB_XP> hyperlatex ?
07:45:22 <dmwit> Wow!  A segfault in ghci.
07:45:33 <dmwit> And that while just waiting at the command prompt!
07:46:10 <Jafet> Proof that ghc can do anything
07:46:10 <dmwit> I blame whatever line-editing library they're using.
07:48:01 <dmwit> Whoops, now I've gotten an internal error.
07:48:05 <dmwit> Today's not my lucky day.
07:48:22 <Philonous> Ah, man, why can't I have "instance (Functor f, Functor g) => Functor (Lambda a. f (g a)) where fmap = fmap.fmap -.-
07:48:55 <Saizan> Philonous: higher order unification is undecidable in general
07:48:57 <dmwit> type O f g a = f (g a) -- ?
07:49:05 <Martijn_> Philonous: you can using a newtype
07:49:12 <dmwit> Oh, right, newtype.
07:49:34 <Martijn_> Yes, instance (Functor f, Functor g) => Functor (f `O` g)
07:50:27 <Saizan> Philonous: though it'd be nice to allow provably decidable cases, there are papers about this
07:51:15 <Philonous> This type O thingy doesn't work, there is no eta reduction on the type level.
07:51:36 <ski> Saizan : something related to L-lambda unification ?
07:51:40 <Martijn_> A few days ago I found a paper that used Gofer I think. They could have partial application of type synonyms provided they say in advance in which functions that's going to be used.
07:52:28 <ski> Martijn_ : you're not talking about hugs' "restricted type synonyms", are you ?
07:52:49 <Martijn_> I don't remember
07:52:54 <Martijn_> Let me see if I can find the paper again
07:54:12 <Martijn_> Extending Fold and Unfold to Exponential Types
07:54:13 <skorpan> ping
07:54:53 <ski> Martijn_ : The Hugs 98 User Manual - 7.3.5 - Restricted type synonyms <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5>
07:56:06 <Saizan> Philonous: O needs to be a newtype, and you'd have to explicit wrap/unwrap the values with the corresponding constructor
07:56:51 <Martijn_> Yes, that seems to be what I meant
07:56:54 <Martijn_> Thanks
07:57:46 <Saizan> ski: i was referring to this http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.7505 , they don't mention L-lambda unification iirc
07:57:59 <Saizan> ski: is L-lambda the one of LambdaProlog?
07:58:06 <ski> yes
07:59:07 <ski> (Martijn_ : ok. but that's not really related to partial application of type synonyms)
07:59:23 <ksf> well... I managed to get the non-termination out of the type checker, and into the run-time code.
08:01:41 <Martijn_> ski: See the paper I mentioned, section 2.6, they write: type P f a = f (Rec f,a) in ..., and then later on: instance Functor f => Functor (P f)
08:02:21 <Martijn_> ski: But TBH I didn't take a good look at it. I just thought it interesting, worth checking out later, and read on.
08:03:54 <ski> Martijn_ : ok. so that does appear to be not quite the same thing, then
08:05:14 <Martijn_> ski: They do call it a restricted type synonym directly after
08:05:24 <ski> (Martijn_ : oh, that was "Bananas in Space" ..)
08:05:31 <ski> hm
08:05:40 <ski> ah, i see
08:05:42 <ski> yes
08:06:14 <ski> `P' is treated as a type synonym in the definitions mentioned after the `in'
08:06:14 <Martijn_> ski: Another interesting claim is 'covariant functors suffice'--will have to delve into that later, too
08:06:41 <ski> otherwhere it is treated as an abstract type (like `data' or `newtype' .. but with no constructors known)
08:07:15 <Martijn_> Including the instance. Right, that makes sense.
08:07:33 <ski> Martijn_ : therefore, in `Functor (P f)' it is in effect not a partially applied type synonym, but just a partially applied type constructor (like with `data' or `newtype'), which is fine
08:07:41 <Martijn_> Yes
08:07:44 <ski> *nod*
08:08:09 <Craig`> hello again
08:08:17 <ski> hi there again
08:09:47 <Martijn_> welcome back
08:11:18 <leimy> to me? :-)
08:11:50 <Martijn_> You too :-)
08:12:08 <temoto> Hello. Is tail recursion optimization restricted to same function?
08:13:29 <Taejo> temoto: no, all tail calls should be eliminated
08:13:36 <Craig`_> sorry about that
08:13:41 <Craig`_> did you get my question?
08:13:45 <ski> no
08:14:12 <ksf> ...because, there are, in fact, no calls anywhere that build up the stack 'cos there just is no stack.
08:14:29 <temoto> Taejo: pardon?
08:15:06 <ksf> temoto, haskell has no stack so the concept of "tail call" doesn't really apply.
08:15:36 <Taejo> ksf: well, Haskell implementations generally have a concept of a stack
08:15:47 <roconnor> ksf++
08:16:04 <roconnor> the word is getting out!
08:16:12 <ksf> to the best of my knowledge, ghc doesn't have any notion of stack, except while calling ffi functions.
08:16:15 <quicksilver> > foldl (+) 0 [1..1000000]
08:16:17 <lambdabot>   * Exception: stack overflow
08:16:22 <quicksilver> ksf: what's that then? ;)
08:16:25 <Martijn_> hehe
08:16:26 <ksf> hey, use a foldr.
08:16:30 <quicksilver> that's not the point.
08:16:33 <quicksilver> that's a stack.
08:16:34 <Craig`_> I said: Is iterative tasks in FP done via recursion?
08:16:36 <mmorrow> foldr is worse!
08:16:38 <roconnor> ksf: actually there is a stack push when entering a case analysis.
08:16:42 <Makoryu> > let (!.) = flip (.) not in filter (!. null) $ words "don't taze me bro"
08:16:43 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:16:46 <Makoryu> Ffff
08:16:47 <ski> Craig`_ : yes
08:17:02 <jfoutz> > foldl' (+) 0 [1..100000]
08:17:03 <Philonous> > (fmap.fmap) (+1) [[1,2,3][3,4,5]]
08:17:03 <lambdabot>   5000050000
08:17:04 <lambdabot>   Couldn't match expected type `t -> f a'
08:17:07 <Makoryu> > let (!.) = flip ((.) not) in filter (!. null) $ words "don't taze me bro"
08:17:09 * ksf has to digest that
08:17:10 <quicksilver> entering a thunk is a stack push, too, in GHC
08:17:12 <lambdabot>   ["don't","taze","me","bro"]
08:17:14 <mmorrow> actually, foldr and foldl are equally as bad on Int(egers) i guess
08:17:18 <Philonous> > (fmap.fmap) (+1) [[1,2,3],[3,4,5]]
08:17:20 <lambdabot>   [[2,3,4],[4,5,6]]
08:17:26 <quicksilver> well in some cases at least.
08:17:27 <Taejo> > foldr (+) 0 [1..1000000]
08:17:28 <lambdabot>   * Exception: stack overflow
08:17:35 <Taejo> ksf: foldr doesn't help
08:18:08 <roconnor> none the less, ksf is totally right about tail calls not being relevent in Haskell.
08:18:16 <roconnor> I should write a blog post about this.
08:18:21 <mmorrow> , time (foldl' (+) 0 [1..1000000])
08:18:25 <lunabot>  (0.187972,500000500000)
08:18:27 <ksf> roconnor, please do.
08:18:32 <mmorrow> , time (foldr (+) 0 [1..1000000])
08:18:34 <lunabot>  Stack space overflow: current size 8388608 bytes.
08:18:34 <lunabot>  Use `+RTS -Ksize' to increase it.
08:18:36 <mmorrow> , time (foldr (+) 0 [1..100000])
08:18:38 <lunabot>  (6.799e-2,5000050000)
08:18:48 <Craig`_> ski: something like http://pastebin.ws/3ytjj5 ? and then I'd do doStuff 5 or whatnot?
08:18:49 <mmorrow> , time (foldl' (+) 0 [1..100000])
08:18:51 <lunabot>  (9.998e-3,5000050000)
08:18:57 <Makoryu> Tail calls are only as relevant as strictness analysis for any given piece of code
08:19:04 <ksf> ...I can understand a push when entering a thunk, but I'm quite mystified by that case thing.
08:19:13 <quicksilver> I'm not sure what you mean by 'relevant'
08:19:15 <Taejo> roconnor: do you claim that tail calls are irrelevant in a Haskell implementation, too?
08:19:20 <quicksilver> tail calls are not relevant for semantics, no
08:19:22 <quicksilver> is that what you mean?
08:19:34 <quicksilver> TCO is certainly a useful optimisation in a haskell implementation, though.
08:19:41 <iabal> someone could help me to fix this problem http://www.moonpatio.org/fastcgi/hpaste.fcgi/view?id=3506 ?
08:19:51 <ski> Craig`_ : possibly something like that, yes
08:19:53 <quicksilver> optimisations are pretty much by definition not relevant for semantics.
08:20:04 <iabal> I think I need both instances
08:20:27 <roconnor> No I mean tail calls are not relevent for haskell code's operational speed etc.
08:20:58 <temoto> The question was particulary, whether tail recursion works (in ghc if that helps to narrow the answer) only with origin function as in foldr (+) or with any other function call as in f x = y(x - 1); y x = f(x - 2)  ?
08:21:03 <roconnor> let's be perfectly clear, as ksf said, entering a Haskell function doesn't push anything on the stack.
08:21:07 <Craig`_> at first the reasons for using functions for everything is a little void, does it actually become useful once you become useful when you're good at programming?
08:21:11 <Craig`_> *FP
08:21:37 <roconnor> TCO is an an optimization to remove the stack push early upon entering a function at a tail call.
08:21:40 <temoto> tail recursion optimization* works...
08:21:48 <roconnor> but Haskell has not stack push to optimize away!
08:21:58 <roconnor> no
08:22:05 <temoto> I.e., in erlang, any function call will be optimized.
08:22:28 <Taejo> roconnor: how is the stack overflowing if nothing is ever pushed onto it?
08:22:41 <ksf> now we're getting to the interesting bit.
08:23:01 <mmorrow> tail calls are never relevant for speed so much as they are for not having to be constrained to return back through the current point... a while loop is the same thing as a single function that tail calls itself, but of course a function tail calling *itself* is the trivial case
08:23:15 <roconnor> Taejo: two things: First, Primitives (and presumably FFI) have a stack like normal strict languages.
08:23:28 <Phyx-> A bit off topic, but anyone know a good site with resources to teach a beginner about algorithms and datastructures?
08:23:40 <roconnor> so these have the regular tail call issues.  But these also don't count as "Haskell functions" for my purposes here.
08:23:46 <Taejo> roconnor: but #+ isn't recursive, so it's not consuming stack space
08:23:48 <temoto> mmorrow: yeah! You got the point. Tail call to itself is trivial. What about tail call to something else?
08:23:58 <Jafet> Craig`, functional programming is one of the most elegant ways to express computation.
08:23:59 <Taejo> or rather, it's consuming a constant amount of stack
08:24:05 <mmorrow> temoto: that's when it gets interesting! :)
08:24:11 <ski> iabal : assume you're in the `Monad m => FreshVarT v (FreshVarT v m)' monad. what should `freshVar' do ?
08:24:16 <roconnor> secondly, there is a stack push upon entering a case analysis.
08:24:22 <temoto> mmorrow: meaning you don't know the answer?
08:24:33 <mmorrow> temoto: what's the question?
08:24:48 <temoto> mmorrow: is tail call to other function is optimized in ghc?
08:25:11 <Taejo> roconnor: yeah, the stack is a thunk evaluation stack, not a function call stack (temoto doesn't realise this, but I do)
08:25:14 <iabal> ski: well, the case should be FreshVarT w (FreshVarT v m), so you can ask for fresh variables of type w or v, in my case I have TyVar and Var, for types and expressions, that are different types
08:25:22 <orbitz> Craig`: i find i writ ea lot of callback heavy code and having fucntions as a firs class citizen is far less annoying than, for example java, where you have to write a bloody class for everything
08:25:34 <temoto> Taejo: i don't understand what a thunk is.
08:25:38 <ski> iabal : yes, but what if `w' and `v' are the same type ?
08:25:41 <roconnor> so the stack over flow has nothing to do with tail calls at all.
08:25:53 <ski> iabal : that's what GHC is complaining about
08:26:09 <orbitz> temoto: what do you mean 'tailcall ot soemthign else'?
08:26:29 <iabal> ski: and maybe there is no way to constraint v and w to be different...
08:27:09 <Botje> temoto: you have to know that haskell evaluation is graph reduction
08:27:19 <temoto> orbitz: f x = f (x - 1) + y x    i guess it is close
08:27:19 <mmorrow> temoto: ghc doesn't use call/ret instructions, so everything is a jmp. the only question is whether or not you're allocating on the stack or in the heap. but if you're allocating on the stack, it's different than in C in the sense that you're not "returning" to the instruction after the one you jumped from, but to some other place entirely
08:27:20 <iabal> ski: should I instance by-hand my FreshVarT (FreshVarT ...) stacks ?
08:27:32 <orbitz> temoto: there isn't anything to TCO there
08:27:39 <orbitz> unless you want to TCO the (+)
08:27:47 <Philonous> The newtype O f g a = O f (g a) trick works, but it is as ugly as sin.
08:27:47 <temoto> why not
08:27:55 <orbitz> temoto: that doesn't really get you much
08:28:41 <ksf> temoto, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
08:28:45 <temoto> orbitz: there could be more costly operation. I hope i explained what a 'tail call to something else' is.
08:28:47 <ski> iabal : i don't think there is a way to constrain two types to be different
08:29:01 <quicksilver> roconnor: why does "let f x = f x + f x" stack overflow then?
08:29:02 <orbitz> temoto: i don't see a tail call to somethign else in that example
08:29:08 <ski> iabal : i don't know what you are suggesting
08:29:22 <iabal> there is a way to constraint two types to be equal... (v ~ w) no?
08:29:26 <iabal> introduced with type families
08:29:29 <mmorrow> temoto: f x = f (x - 1) + y x    this would compile to a an asm loop ending in a conditional jump (assuming you add a termination condition), the same as a while loop would (err, maybe do/while, but whatever)
08:29:37 <roconnor> quicksilver: prim ops allocate stack.
08:29:52 <mmorrow> roconnor: only if you're code isn't tail recursive
08:29:55 <mmorrow> *your
08:30:09 <roconnor> again with the tail recursion.
08:30:17 <roconnor> nothing to do with tail recursion
08:30:37 <mmorrow> roconnor: i don't know why you're so convinced of this :)
08:31:07 <roconnor> because entering functions do not push anything on the stack!
08:31:12 <Jafet> mmorrow, it would compile to that, unless it doesn't
08:31:21 <roconnor> mmorrow: have you seen my swap example on this topic?
08:31:23 <temoto> mmorrow: thanks, i think it answers original question. :)
08:31:37 <mmorrow> foldr (+) 0 [0..10000] -- not tail recursive, which is relevant because the result is atomic, and you're demanding it
08:31:44 <Taejo> roconnor: I agree that there is no Haskell function-call stack. But at some level, actually code is getting run (at thunk evaluation time). And sometimes this code contains CALL instructions, and sometimes they are followed by RET, and CALL/RET can by turned into JMP
08:31:59 <mmorrow> foldl' (+) 0 [0..1000] -- tail recursive, does zero allocation
08:32:09 <mmorrow> well, save for the list
08:32:28 <ksf> ...which gets hopefully fused in.
08:32:41 <iabal> ski: what I am suggesting?
08:32:44 <quicksilver> roconnor: OK, change + to ++; now why is it overflowing?
08:33:03 <ski> <iabal> ski: should I instance by-hand my FreshVarT (FreshVarT ...) stacks ?
08:33:09 <Taejo> and changing CALL foo, RET to JMP foo is called tail-call elimination, and any code-generator that doesn't do so is stupid and ugly
08:33:29 <roconnor> mmorrow: the fact that foldl' (+) 0 [0..1000] is tail recursive is almost complete incidental.  The trick to getting zero stack allocation is proper arrangement of case analysis and constructor placement.
08:33:47 <mmorrow> foldr (+) 0 [0..10000] -- lays the *entire* list out on the stack until it finds the end, and *only then* starts doing (+)
08:33:50 <temoto> Taejo: assuming one is using LLVM, that's still a programmer job, right?
08:33:53 * ksf thinks "stack" in haskell could be best defined as "memory that's allocated, but not under control of the gc"
08:33:53 <Gracenotes> hm. What's the name of that Linux sheet-music-by-text-file creator?
08:34:07 <Gracenotes> something like.. melody.. or some flower..
08:34:19 <ksf> actually, I always assumed that there are exactly 0 bytes of that.
08:34:21 <iabal> ah, ski, well, I'm asking if I have to do the instance for every concrete case I need, so GHC won't complain about the "v v" case, for example, if I need w = TyVar v = Var, I have to do the instance for that case, etc
08:34:32 <Jafet> Gracenotes, lilypond
08:34:37 <Gracenotes> oh, right, lilypond.. yeah
08:34:39 <mmorrow> roconnor: the point is there are no constructors here, there is only a loop to spin around in a few thousand times, finally arriving at an Int#
08:34:42 <ksf> ...modulo registers, of course.
08:34:56 <Taejo> roconnor: but I encourage you to write that blog post, so we can see exactly what you're trying to say; if you write reasoned rubbish, we can give you a reasoned trashing; otherwise, we'll learn something.
08:35:04 <Gracenotes> Jafet: excellent :) Does it do MIDI->sheet music conversion, if you remember? I know for sure it does it vice versa..
08:35:19 <Jafet> It probably never will.
08:35:20 <quicksilver> roconnor: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/FunctionCalls
08:35:21 <ski> iabal : i suppose that could work .. but it's ugly :/
08:35:30 <quicksilver> roconnor: lists in exhaustive detail when GHC uses a stack.
08:35:31 <Jafet> MIDI does not preserve enough information to reconstruct scores
08:35:35 <ski> iabal : another option is to use `lift'
08:35:39 <quicksilver> it has a stack, it uses it for both return values *and* for arguments
08:35:48 <quicksilver> under some circumstances it manages to avoid using it
08:36:02 <quicksilver> and those circumstances, to me, are reasonably well described as a kind of generalised TCO
08:36:16 <quicksilver> although the execution model is more complex than simple TCO.
08:36:18 <Gracenotes> Jafet: yeah.. the other program I have that does MIDI->sheet music has to infer a lot of information about timing, note position, etc. It's an old Windows program, but it's suited me well, runs on wine too.
08:36:50 <iabal> ski: well, I have to think in it, I expect to have FreshVarT (FreshVarT (FreshVarT ... )), and lift $ lift $ freshVar is a bit ugly too :/
08:36:59 <iabal> lot of thanks
08:37:26 <ski> iabal : yes. i don't know of a good solution
08:37:33 <lispy> Gracenotes: I run on wine also
08:37:38 <lispy> Gracenotes: sometimes beer
08:37:43 * lispy ducks
08:37:53 <lispy> how is code, people?
08:38:02 <Gracenotes> :P
08:39:28 <roconnor> quicksilver: that link did not list in exhaustive detail when GHC uses a stack.
08:39:34 <mmorrow> roconnor: i think you should write that blog post as well. in a context where demanding any part of the result triggers the evaluation of the entire thing, you're exactly right
08:39:43 <quicksilver> I think I allowed hyperbole to get the better of me
08:39:48 <quicksilver> it's not exhaustive detail.
08:39:51 <ski> iabal : i wonder if one could somehow combine `v' and `w' into `(v,w)' in an instance ..
08:39:52 <mmorrow> err, that should have read:
08:39:57 <quicksilver> however it does explain how function calls are implemented
08:40:14 <mmorrow> * in a context where _it's not the case that_ demanding any part of the result triggers the evaluation of the entire thing, you're exactly right
08:40:18 <quicksilver> and show some cases when stack is used for argument but not return
08:40:24 <quicksilver> and some cases where its used for both
08:41:18 <roconnor> @let swap ~(a,b) = (b,a)
08:41:19 <lambdabot>  Defined.
08:41:23 <roconnor> @let swap' (a,b) = (b,a)
08:41:24 <lambdabot>  Defined.
08:41:52 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let z = x + y in swap (foo z xs) in foo 0 [0..1000000]
08:41:57 <lambdabot>   mueval-core: Prelude.read: no parse
08:41:57 <lambdabot>  mueval: ExitFailure 1
08:42:10 <mmorrow> roconnor: ghc pushes an update continuation on the stack whenever it starts evaluating a thunk, and APs are one of the types of THUNKs (an AP being an application of a function to the exact number of args it takes, i.e. a frozen function call)
08:42:22 <ski> (the stack tends to be used when one need to remember doing things later, no ?)
08:42:32 <quicksilver> ski: and also to pass arguments
08:42:42 <quicksilver> although you hope the register-colorer removes most of those afterwards
08:42:44 <roconnor> , let foo x [] = (x,0); foo x (y:xs) = let z = x + y in swap (foo z xs) in foo 0 [0..1000000]
08:42:49 <lunabot>  Stack space overflow: current size 8388608 bytes.
08:42:49 <lunabot>  Use `+RTS -Ksize' to increase it.
08:43:03 <roconnor> see that stack overflows
08:43:17 <roconnor> now let us make z strict, note that there is no tail call to foo!
08:43:23 <roconnor> , let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap (foo z xs) in foo 0 [0..1000000]
08:43:26 <lunabot>  (0,500000500000)
08:43:34 <roconnor> it worked!
08:43:44 <roconnor> our "tail-call" version has no stack overflow
08:43:55 <roconnor> only that this doesn't actually use a tail call at all.
08:44:01 <iabal> ski: MonadFreshVar (v,w) m ... I don't know how do it having sense (without get freeVar :: m (v,w))
08:44:18 <roconnor> and in fact, if we change swap with swap'
08:44:23 <roconnor> , let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap' (foo z xs) in foo 0 [0..1000000]
08:44:23 <mmorrow> and it also pushes an "app continuation" (i don't remember what the exact term is), that's used when a function is applied to more args than it takes, so you push a cont on the stack containing the extra args, then you eval the function applied to the first N args (where N is its arity), and you get back a function which then gets applied to these saved args on the stack
08:44:24 <lunabot>  luna: Not in scope: `swap''
08:44:35 <roconnor> :/
08:44:46 <roconnor> , let swap' (a,b) = (b,a) in let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap' (foo z xs) in foo 0 [0..1000000]
08:44:47 <lunabot>  Stack space overflow: current size 8388608 bytes.
08:44:47 <lunabot>  Use `+RTS -Ksize' to increase it.
08:44:48 <mmorrow> and the process repeats until you can't reduce anymore/there's nothing else to eval
08:44:53 <roconnor> we get a stack overflow again.
08:44:58 <ski> iabal : yes .. `m (v,w)' wouldn't be that useful .. you'd want to choose which you want to get
08:45:13 <roconnor> becaue swap' does a case analysis right there and then.
08:45:52 <quicksilver> roconnor: that doesn't prove that tail calls are irrelevant. All it proves is that whether or not a function builds a thunk is relevant.
08:46:06 <quicksilver> mind you, in a lazy language, every call is a tail call in some local sense.
08:46:42 <roconnor> quicksilver: hey, this is morally the same as your foldr, foldl' code
08:47:26 <Taejo> roconnor: I think that was just to disprove your "haskell has no stack" claim
08:48:04 <roconnor> Taejo: I don't claim that at all.  Perhaps that was ksf's claim.  (though you could implement Haskell without a stack).
08:48:17 <Taejo> roconnor: oh, sorry
08:48:44 * ksf isn't trustworthy, anyway, so it doesn't matter.
08:48:46 <roconnor> My only claim is that whether code is syntatically does a tail call or not is irrelevent for determining if stack space will be optimized.
08:49:48 <Taejo> roconnor: if I knew that's what you were claiming, then I would never have argued with you, because I agree
08:50:18 <ksf> however, I guess we answered the question whether there's a difference whether you call yourself or another function exhaustively: it doesn't matter.
08:50:28 <roconnor> Taejo: okay, I knew you agreed with me.
08:50:49 <Taejo> it's the tail position at the C-- level that matters
08:51:11 <ski> ksf : temoto asked about that, i think ..
08:51:22 <ksf> yep, exactly.
08:51:34 <roconnor> mmorrow: that's interesting about the app continuation.  I'd like to see a stack overflow involving only functions and no prim ops or case analysis.
08:52:10 <temoto> Yeah, thanks.
08:52:58 <ksf> > fix id
08:53:03 <lambdabot>   mueval-core: Prelude.read: no parse
08:53:03 <lambdabot>  mueval: ExitFailure 1
08:53:53 <roconnor> doesn't stack overflow to me
08:54:06 <roconnor> I'd be inclined to use newtype to create a infinite argument function
08:54:17 <iabal> ski: well, perhaps a map with the name of each type and freshVar (undefied::Var), but ugly too, perhaps more than the others solutions ;P
08:54:20 <roconnor> not sure if that would work.
08:55:06 <ski> roconnor : heh, same idea :)
08:55:27 <roconnor> doing a pattern match on a newtype, I don't think counts as a case analysis.
08:55:34 <quicksilver> > let f x = f x ++ f x in f []
08:55:36 <lambdabot>   * Exception: stack overflow
08:55:52 <quicksilver> roconnor: which category is that?
08:56:02 <roconnor> but ++ certainly does a case analysis.
08:56:08 <quicksilver> sure but ++ is never called.
08:56:24 <quicksilver> there's nothing to case-analyse
08:56:25 <roconnor> quicksilver: ++ is the first thing that is called!
08:56:31 <Jafet> Is that like the function so big god himself cannot call it
08:56:33 <quicksilver> that too.
08:56:38 <Jafet> Oh wait, you could curry it
08:56:39 <roconnor> and the first thing it does is case analysis
08:56:43 <quicksilver> it is both never called and the first thing that is called :)
08:56:58 <roconnor> @src (++)
08:56:58 <lambdabot> []     ++ ys = ys
08:56:58 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:56:58 <lambdabot> -- OR
08:56:58 <lambdabot> xs ++ ys = foldr (:) ys xs
08:57:54 <roconnor> quicksilver: f [] -> f [] ++ f [],  then ++ does *case analysis* on it's first argument (ie f[]).
08:58:08 <roconnor> this case analysis pushes a stack frame
08:58:15 <lilac> > let f x = x `seq` f (f x) in f ()
08:58:16 <roconnor> then f [] is evaluated the same way.
08:58:17 <lambdabot>   * Exception: stack overflow
08:58:21 * quicksilver nods
08:58:24 <quicksilver> yes, I do follow
08:58:32 <ski>   newtype W a = MkW {appW :: a -> W a}; w :: W (); w = w `appW` ()
08:58:37 <ski> would something like that work ?
08:58:40 <quicksilver> however I still claim that argument passing uses stack.
08:58:54 <quicksilver> and you should be able to exhaust the stack with argument passing alone
08:59:22 <roconnor> quicksilver: the documentation mmorrow pointed to seems to imply that, but I'm still somewhat skeptical.  I think I might not be understanding the documentation well.
08:59:24 <lilac> it seems to me that to get stack overflow you need 1) to build nested thunks arbitrarily deep, then 2) to force the outermost such thunk.
08:59:33 <quicksilver> > let f x = f x `seq` f x in f 0
08:59:34 <lambdabot>   * Exception: stack overflow
08:59:48 <quicksilver> lilac: that's certainly a way. I think the question here is if that is the only way.
08:59:50 <doserj> lilac: roconner could argue that seq is polymorphic case analysis :)
08:59:51 <roconnor> seq is morally a case analysis.
08:59:57 * ksf is going to have a look at some assembly
08:59:57 <doserj> :P
09:00:00 <roconnor> doserj: indeed
09:00:23 <quicksilver> I conclude that, by using a word like 'morally', roconnor is working with a *model*
09:00:23 <roconnor> I think ski's idea might be the way to go.
09:00:27 <quicksilver> not with what GHC actually does.
09:00:36 <lilac> in the core, case is the only way to force a thunk. if "no thunk forcing" is the rule, i think roconnor might be right
09:00:36 <danzat> Hi, I don't understand why a function definition like: add x (Negative x) = 0 gives me a parse error
09:00:39 <quicksilver> I think it's a good model and I understand the point he's making, inside that model.
09:00:46 <quicksilver> but I believe that GHC uses the stack for both arguments and return values
09:00:48 <quicksilver> (just not always)
09:00:57 <quicksilver> and you can exhaust it for a variety of reasons.
09:01:00 <lilac> danzat: you want the two 'x's to be the same? haskell doesn't support that.
09:01:10 <Makoryu> danzat: Are you typing this in ghci?
09:01:11 <lilac> danzat: try: add x (Negative y) | x == y = 0
09:01:26 <danzat> Makoryu, lilac, thanks
09:02:13 <Makoryu> danzat: If you type stuff in ghci, you'll get errors, because ghci expects either expressions, or lines from a "do" block
09:02:19 <roconnor> quicksilver: Fine.  take everything I said and replace case analaysis with "case analysis or seq" if you must.
09:02:35 <Makoryu> danzat: You can type "let foo = bar" but not just "foo = bar"
09:02:57 <roconnor> quicksilver: you have to admit that seq is a special function.
09:03:17 <ski>   !a `seq` b = b  -- no ?
09:03:31 <danzat> Makoryu, I'm loading it from a .hs file. But it's ok, lilac already answered my question
09:03:34 <roconnor> ski: ! patterns are defined by seq
09:03:40 <Makoryu> danzat: All right
09:03:45 <Makoryu> danzat: Just making sure :p
09:03:46 <ski> (or vice versa, i assume)
09:04:00 <quicksilver> roconnor: I do admit that seq is special. I don't understand why you don't accept that GHC passes arguments on the stack.
09:04:01 <roconnor> quicksilver: in fact, I think I should say that seq is a prim op, in which case I already covered that.
09:04:15 <danzat> Makoryu, it's ok, I appreciate your readiness to help
09:04:17 <quicksilver> you will find comments all over the GHC code talking about "the haskell stack" as opposed to "the C stack"
09:04:20 <quicksilver> and what lives where.
09:04:25 <roconnor> quicksilver: because I see no operational behaviour that suggests that GHC passes arguments on a stack.
09:04:42 <roconnor> quicksilver: I admit there is a Haskell stack!
09:05:30 <ksf> that's the worker function compiled for f x = f x ++ f x with -O2: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8963#a8963
09:05:33 <roconnor> quicksilver: question. can a function only be "called" when it appears in a case statement (or prim op or seq)?
09:05:53 <Alpounet> "BLACKHOLE"
09:05:56 <Alpounet> heh
09:06:07 <quicksilver> roconnor: if you reduce haskell to case and apply, then yes
09:06:10 <quicksilver> roconnor: (I think)
09:06:17 <quicksilver> roconnor: there's nothing else, really.
09:06:23 <ksf> seems to run in constant space, btw.
09:06:28 <quicksilver> roconnor: that's kind of what I meant by "everything is a tail call"
09:06:33 <roconnor> quicksilver: then I think we are might be saying the same thing almost.
09:06:42 <quicksilver> roconnor: if you look from the right heiht
09:06:51 <quicksilver> the only reason you call a function is when you want the answer
09:06:55 <quicksilver> when you want the answer, that's all you want
09:07:00 <quicksilver> so everything is a tail call.
09:07:00 <ksf> does lambdabot compile down to -O2?
09:07:11 <roconnor> quicksilver: I still argue that the case analysis is better because a case analysis my reenter a partially evaluated function, thus pushing the stack again.
09:07:14 <quicksilver> if you look at unoptimised core, it's all just cases and tail calls.
09:07:49 <roconnor> quicksilver: the Core code is a whole different story.  If I understand correctly core is a strict language, and so tail calls are totally relevent there.
09:08:16 <deech`> Hi all, how do I deal with 'user error (mzero)' exceptions arising from using 'guard (some condition) >> (some action)'?
09:08:53 <ski> deech` : which monad is that ?
09:09:23 <deech`> ski: The IO Monad
09:09:31 <ski> `if some condition then some action else do something else' ?'
09:10:05 <ski> or you mean you want to catch the error further out ?
09:10:21 <quicksilver> mzero in the IO monad presumably throws an exception which you can catch
09:10:26 <quicksilver> I'm not sure which one it throws
09:10:27 * ski presumes one can catch those errors
09:11:25 * Phyx- goes to read Purely Functional Data Structures
09:11:43 <opqdonut> good good
09:11:56 <quicksilver> ioError (userError "mzero")
09:11:59 <quicksilver> not very nice :(
09:12:06 <quicksilver> but you should be able to catch it.
09:12:16 <ski> @hoogle userError
09:12:17 <lambdabot> Prelude userError :: String -> IOError
09:12:17 <lambdabot> System.IO.Error userError :: String -> IOError
09:12:17 <lambdabot> Control.Exception userErrors :: Exception -> Maybe String
09:12:34 * ksf thinks using guard in io is a bad idea.
09:12:56 <ksf> never call fail if the monad will throw an exception.
09:13:04 <ski> ksf : it might be ok for preconditions, i suppose
09:13:14 <quicksilver> error in general is nasty
09:13:14 <ksf> (and that's what guard does)
09:13:15 <deech`> ski, quicksilver : I think I was using guard the wrong way. I am coding a database update function and I first wanted to check that the arguments are actually different from what is already in the database before doing a wasteful operation. So I used 'guard (oldValue /= newValue) ... and it threw the mzero exception at runtime.
09:13:17 <quicksilver> exceptions in IO are OK.
09:13:38 <quicksilver> it's unfortunate that that instance uses userError "mzero"
09:13:46 <quicksilver> instead of something nice like MZeroException
09:14:23 <quicksilver> btu obviously it predates the extensible exceptions stuff
09:16:00 * ksf still thinks fail doesn't belong into Monad.
09:16:13 <ski> that's a given
09:16:35 <opqdonut> everybody thinks that :P
09:16:38 <ksf> ...just make a MonadFail class with fail in it, and issue warnings if you have incomplete pattern matches in a do block with a monad that's no monadfail.
09:17:06 <ski> why not type error ?
09:17:23 <opqdonut> IMO we need some type class extensions before we explode the amount of standard type classes
09:17:26 <ksf> 'cos pattern match failures are runtime errors.
09:17:33 <opqdonut> type class aliases at least
09:17:58 <ski> (like `No instance for (MonadFail FooBar)')
09:18:04 <ksf> maybe we should just start designing better type classes by wishful thinking before bikeshedding extensions.
09:18:14 <opqdonut> (this exploding includes MonadFail, the "better" Monad hierarchy, proper algebraic typeclasses etc)
09:18:28 <opqdonut> ksf: or that, yeah
09:18:49 <Phyx-> "Programmers can use any language they want, as long as it's imperative"
09:18:49 <Phyx-> lol
09:19:10 <ksf> we actually have class aliases, it's called superclassing.
09:19:19 <ski> Phyx- : "Haskell is the worlds finest imperative language"
09:19:39 <ksf> @quote imperative
09:19:39 <lambdabot> BMeph says: <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
09:19:40 <opqdonut> ksf: needs undecideable instances or somesuch
09:19:52 <Phyx-> ski: ^_^
09:19:56 <ski> ksf : but you have to manually provide instances
09:22:18 <ksf> opqdonut, nope it doesn't.
09:22:33 <ksf> you can do class (Foo a, Bar a) => Baz a
09:22:45 <ski> `class (Frob a,Bozz a) => Frobozz a' doesn't automatically make any `a' in `Frob' and `Bozz' also an instance of `Frobozz'
09:22:52 <opqdonut> indeed
09:22:54 <ksf> that's doesn't need undecidable instances because it ain't an instnance.
09:22:55 <opqdonut> you need the instance
09:23:07 <opqdonut> instance (Frob a,Bozz a) => Frobozz a
09:23:38 <ksf> well, it doesn't need to, as Frobozz isn't going to have any methods.
09:23:56 <opqdonut> what ski said
09:24:21 <ksf> ...and you don't need instances when you don't have class methods.
09:24:25 <opqdonut> anyway, typeclasses need to be more than just something that gets plugged in after type inference
09:24:31 <opqdonut> ksf: sure you do
09:24:57 <ski> in fact it is irritating that the arrow there in `class ... => ...' doesn't point the other way
09:25:06 <opqdonut> mhmm
09:25:12 <quicksilver> well, it's a context.
09:25:13 <opqdonut> used to bug me too
09:25:16 <opqdonut> when i was learning haskell
09:25:29 <ski> that class declaration means that for any `a' such that `Frobozz a', we have `Frob a' and `Bozz a'
09:25:31 <ksf> no don't even think about changing that.
09:25:36 <ksf> it's an "implies".
09:25:54 <Phyx-> http://www.wired.com/underwire/2009/08/disney-buying-marvel/ NOOOOOOOOOOO
09:25:58 <quicksilver> but the implication is the other way
09:25:59 <Phyx-> *sniff sniff snickers*
09:26:04 <opqdonut> ksf: what ski said, the implication interpretation would need the arrow the other way
09:26:07 <ski> iow, what would logically be written as `Frobozz a => (Frob a,Bozz a)' (or `(Frob a,Bozz a) <= Frobozz a ' if you prefer)
09:26:07 <quicksilver> it's Frobozz that implies Frob,Bozz
09:26:16 <quicksilver> not Frob,Bozz that implies Frobozz
09:26:29 <ski> maybe if one could write a declaration like
09:26:34 <ksf> no if you've got an a that is Frob and Bozz, that implies Frobozz.
09:26:38 <ski>   class (Frob a,Bozz a) <=> Frobozz a
09:26:38 <quicksilver> ksf: wrong
09:26:50 <quicksilver> ksf: that is absolutely not what superclasses mean.
09:26:56 <ski> (assuming the `<=>' there is interpreted logically)
09:26:56 <quicksilver> "class (Eq a) => Num a where ....."
09:27:03 <quicksilver> this does *not* mean that all Eq are Num.
09:27:16 <quicksilver> but it does mean that all Num are Eq.
09:27:16 <ksf> ...well, _only then_ frobozz can ever be for an a.
09:27:33 <Yrogirg> Wich base version is in ghc 6.8.2?
09:27:38 <ksf> well that's true.
09:28:16 <ski> (btw, note that the `=>' arrow in `instance' declarations have a sane logical interpretation)
09:28:40 <quicksilver> ski: it's sane in classes too, just confusing.
09:28:48 <quicksilver> ski: it's a context over the class declaration.
09:29:04 <quicksilver> ski: it says that, in the follow declarations, "a" can be assumed to lie in the classes Frob and Bozz
09:29:22 <quicksilver> it *is* confusing, but it is still consistent with the way contexts are normally used.
09:29:35 <ski> maybe it's sane, but it's not a "sane *logical* interetation" ;)
09:30:19 <quicksilver> it's the same logical interpretation as a plain function foo :: (Frob a, Bozz a) => a -
09:30:25 <quicksilver> a -> a, I was going to say.
09:30:29 <ksf> there we are, bikeshedding classes. do you like it consistent or rigorous?
09:30:54 <ski> `foo :: (Frob a, Bozz a) => a -> a' means `(Frob a, Bozz a) => (foo :: a -> a)'
09:31:24 <quicksilver> ski: yes, and in a class declaration that implication applies to all the methods in teh class
09:31:40 <quicksilver> class (Frob a, Bozz a) => Foo a where foo :: a -> a
09:31:47 <quicksilver> ^^ context on the "foo" just like before.
09:32:14 <quicksilver> ...and the conclusion is that to make something an instance of Foo, you must have Frob and Bozz, otherwise it's not possible to make sense of the methods
09:32:50 <quicksilver> opqdonut: I keep meaning to write a post to the -cafe asking what the consequences of changing typeclass inference to be a more substantial logic programming language would be
09:32:54 <ksf> ...so the proof "whole class declaration" -> T is dependent on the context.
09:32:55 <quicksilver> opqdonut: ...much as people expect.
09:33:00 <ksf> ...which is what I mean by implication.
09:33:13 <quicksilver> opqdonut: I fear the answer is that we lose lots of things ew don't want to lose.
09:33:13 <lilac> i find it easy to think of => as being a function arrow on dictionaries
09:33:28 <quicksilver> opqdonut: so, I suspect there are good reasons for the current situation :(
09:33:40 <lilac> then "instance Foo a, Bar a => Baz a" is a function which creates dictionaries
09:33:57 <lilac> +parens :)
09:34:05 <ksf> now _that_ one needs UndecidableInstances.
09:34:24 <Twey> That would actually be a neat syntax for class aliases
09:34:29 <ski> if we had `class (Frob a, Bozz a) <= Frobozz a where frotz :: a -> a' could we not say that `Frobozz a' is assumed in the member signatures (and `Frobozz a' implies `Frob a' and `Bozz a') ?
09:34:49 <quicksilver> ski: sure, we could
09:35:00 <quicksilver> ski: I was only trying to show the perspective from which the current setup is consistent
09:35:07 <Twey> Change the default to âclass (Frob a, Bozz a) <= Frobozz aâ, and implement âclass (Frob a, Bozz a) => Frobozz aâ and âclass (Frob a, Bozz a) <=> Frobozz aâ
09:35:11 <quicksilver> ski: I do also see why the arrow the other way could be attractice.
09:35:45 <ski> quicksilver : yes, i agree that that view might be consistent. i haven't decided really
09:35:49 <opqdonut> quicksilver: a type family -based approach or something might be possible
09:35:51 <lilac> I wouldn't mind something like: 'class Frobozz a where instance Frob a; instance Bozz a; foo :: a -> a'
09:35:57 <ksf> all hell is going to break loose, changing syntax like that.
09:36:10 <ksf> rather use ~> or such.
09:36:16 <Twey> Alas.
09:37:03 <ski> lilac : that could possibly work as well, yes
09:37:13 <ksf> ...which is quite nice, ~ meaning equality and ~> , <~ and <~> equality definitions.
09:37:32 * ski thinks `=' means equality
09:37:47 <ray> no, = means northwise bit shift
09:37:47 <ksf> ...not for types, not if you read spj's papers.
09:37:59 <ski> oh, i see
09:38:14 <ksf> ...or have a look at the syntax for type equality in haskell.
09:38:17 <ski> (how come noone told me before !?)
09:38:34 <ksf> ...which looks like (Foo a ~ Succ Zero) => a
09:38:40 <Twey> â½ â I think you were looking for this
09:39:13 <quicksilver> I haved tended to read ~ as "unifies with"
09:39:14 <ski> ksf : as you might suspect, i think `=' should be used, there as well
09:39:28 <quicksilver> Im not sure if that makes sense in all cases.
09:39:42 <medfly> ??
09:39:44 <quicksilver> I think of the equality coercions and being constraints on the unifier.
09:39:51 <quicksilver> s/and being/as being/
09:40:10 <ksf> well, "unifies with" is a wish, "equals" is a definition/constraint.
09:40:22 <ksf> ...both mean the same.
09:40:26 <ksf> words! mere words...
09:40:28 <ski> imo, "unifies with" is an operational interpretation. (=)/2 in Prolog denotes equality, and is implemented using unification
09:40:48 <quicksilver> hmm
09:40:53 <quicksilver> I'm not sure
09:41:00 <quicksilver> "a unifies with (b,c)"
09:41:06 <quicksilver> but I don't think "a = (b,c)"
09:41:21 <ksf> well, if they unify, they're equal, aren't they.
09:41:22 <ksf> ?
09:41:24 <quicksilver> "unifies with" means "there is an assignment of free variables such that the terms are equal"
09:41:31 <ski> quicksilver : that's meta-level reasoning
09:41:38 <quicksilver> "a" and "(b,c)" are syntactically inequal terms.
09:41:54 <ksf> you can't unify the syntax, either.
09:42:04 <quicksilver> "id :: a -> a" and "id :: (b,c) -> (b,c)" are different types
09:42:08 <quicksilver> but they do unify with each other.
09:42:21 <ski> quicksilver : inside the object system, you should only be able to tell whether two things are equal by trying to unify them (and if they unify, you should not be able to back up and ununify them again)
09:42:24 <quicksilver> "unify with" is a partial order
09:43:01 <bos> @seen dons
09:43:01 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 8h 24m 23s ago.
09:43:11 <idnar> "id :: a -> a" unifies with "id :: (b,c) -> (b,c)" and "id :: (b,c,d) -> (b,c,d)"
09:43:18 <bos> glumph.
09:43:18 <idnar> but the latter two don't unify with each other
09:43:31 <quicksilver> yes, it's a partial order
09:44:18 <ksf> well, if you say class (Foo a) <~> Bar a you'd be saying that every Foo a unifies with any Bar a, and vica versa. If you say class a <~ (b,c), you're saying that (b,c) unifies with a, but not the other way round.
09:45:07 <ksf> did I just invent a new syntax for type definitons?
09:46:00 <Jafet> Mmm, squiggly arrows
09:46:36 <ksf> "they express the insecurity and hope we feel while asserting things"'''''''
09:47:14 <ksf> making us aware of our own failability and awe before the limitations of our type system
09:47:36 <ksf> wallowing in humbleness, we do not make straight assertions.
09:48:56 <ksf> may your type be inferred, as in syntax, so at runtime.
09:52:28 <ksf> So, we have class Functor a <~ Applicative a  and Applicative a <~ Monad a as well as say Monad a <~> Dual (CoMonad a)
09:53:16 <ksf> erm no that won't work, Dual looks like a class to me, or at least a type function, not the thing I wanted to define.
09:53:19 <ski> (in case it was not clear,  "id :: a -> a" unifies with "id :: (b,c) -> (b,c)" and "id :: (b,c,d) -> (b,c,d)"  imo would mean that there is a single substitution such that the former becomes equal to each of the latter .. anything else is meta-level reasoning (which there is nothing wrong with. but it shouldn't have a place inside the object system))
09:53:52 <ski> (if on the other hand, `id :: a -> a' is changed into `id :: forall a. a -> a', the situation is not quite the same)
09:55:06 * ksf suggests to write down the definitions you want to see (bikeshedding yay) _and_ use ~>, even if it's just for the sake of not confusing it with the current =>, which supposedly points into the other direction.
09:55:54 <ski> (ksf : i think if you wanted to express that the concept of a monad is dual to the concept of a comonad, you should remove the `a', there)
09:56:37 <ksf> yep, it doesn't really fit into a class declaration, anyway.
09:57:08 <ksf> I just found it hard to think of an example for a bijective class relation on the top of my head.
09:58:11 <ksf> we'd need Dual Monad <~> CoMonad, too, which imposes the question whether there should be some general notion of duality somewhere in the type system.
09:58:22 <chessguy_work> 'ello
10:00:06 <kmc> what does 'bikeshedding' mean
10:00:27 <ksf> http://www.urbandictionary.com/define.php?term=bikeshedding
10:00:53 <ksf> actually, http://catb.org/jargon/html/B/bikeshedding.html
10:01:03 <ksf> bikeshedding
10:01:03 <ksf>     [originally BSD, now common] Technical disputes over minor, marginal issues conducted while more serious ones are being overlooked. The implied image is of people arguing over what color to paint the bicycle shed while the house is not finished.
10:01:07 <skorpan> the entire emacs-devel mailing list is an example "bikeshedding"
10:01:13 <kmc> haha
10:01:21 <skorpan> example of*
10:01:31 <kmc> how can you have any pudding if you don't eat your meat
10:01:37 <ksf> chicken!
10:01:41 <ksf> it's "chicken"!
10:01:53 <ksf> heretic!
10:02:00 <skorpan> pink floyd?
10:02:03 <ksf> go repent, ye sinner!
10:02:23 <Phyx-> ew
10:02:28 <kmc> the sun's not yellow?
10:02:44 <Phyx-> god.. another gta??
10:02:47 <skorpan> "Wrong! Do it again!" which somehow sounds mocking, and "If you don't eat yer meat, you can't have any pudding! How can you have any pudding if you don't eat yer meat?!"
10:04:43 <ksf> ...but then what am I complaining about, I shouldn't expect a yankee to know pink floyd.
10:06:50 <skorpan> ksf: wikipedia says it's "meat"
10:07:19 <opqdonut> unfortunately the lovely accent is unreproducible in writing
10:08:06 <ksf> skorpan, listen to the wall, again.
10:08:44 <skorpan> from what i remember, he does say "chicken", but it's been a while
10:08:58 <lispy> anyone done much haskell research into having the compiler evaluate pure functions on a subset of their domain at compile time?  The goal is that at run-time you just do a lookup on the common inputs
10:08:58 <skorpan> i actually have the wall on vhs, yay
10:09:11 <lispy> I would call it compile time memoization
10:09:14 <exaltation> i know pink floyd pretty well, but don't recognize the reference :(
10:09:23 <skorpan> exaltation: it's from another brick in the wall
10:09:38 <opqdonut> from the end of "the best days of our lives" iirc
10:09:48 <exaltation> oh. I could never understand what those people are saying.
10:09:58 <exaltation> I guess one does need to be British.
10:10:00 <opqdonut> er, happiest
10:10:00 <lispy> pink floyd is a better topic for #haskell-blah than #haskell :)
10:10:01 <lilac> ksf: i listened to it last week, and he definitely says "meat". possibly there's also a "chicken" somewhere else in the song, thougg
10:10:11 <lilac> either that or my brain is fail
10:10:40 * lispy encourages off-topic stuff to go to #haskell-blah!
10:10:41 <ksf> lispy, I'd rather do that what's its called where you run the program collect data and re-compile based on that data.
10:10:59 <ksf> that "chicken" is etched into my brain.
10:11:03 <lispy> ksf: saving computations from previous runs?
10:11:30 <ksf> well, it's collecting data so the compiler knows what to optimize for.
10:11:43 <iabal> ski: finally I get a solution, not perfect but solves part of the problem, for curiosity http://www.moonpatio.org/fastcgi/hpaste.fcgi/view?id=3508 ;P
10:11:52 <lispy> I ask because a guy I work with wants to do this for haskell.  I thought I would see if people have already heard of work in that area
10:12:02 <ksf> ...so he can e.g. size optimize all those parts that are used only once, and work extra hard on the tight loops.
10:12:12 <lispy> I told him to implement a prototype with template haskell
10:12:26 <opqdonut> lispy: i haven't heard of anything like that, no
10:12:29 <opqdonut> th is a good way to go
10:12:36 <__wnh__> its definatly meat, not chicket
10:12:40 <__wnh__> *chicken
10:12:53 <lispy> how can you have any haskell if you don't eat your meat?
10:13:04 * lispy is vegetarian
10:13:10 <lispy> But I can still has the haskell!
10:13:18 <lilac> lispy: is this for a long-running process, or for a shorter-running process which is run multiple times?
10:13:46 <lilac> for the former, i'd have thought a specializing online optimizer jobby would be pretty good, and they certainly already exist.
10:13:53 <lispy> lilac: I think he wants to make a pragma or syntax extension so you can turn it on/off per function and specify the domain to pre-compute
10:14:17 <lispy> lilac: I did tell him about memoization, but he wants compile time
10:14:43 <lilac> hotspot optimizers have the benefit that you don't need to tell them what to optimize
10:15:24 <lilac> but yeah, TH sounds like a good solution if that is in fact the right problem :)
10:16:53 <lispy> lilac: heh yeah, I agree it may not be the right problem
10:17:31 <lispy> it seems like if you did this to enough of an extreme, you might end up doing more time looking things up than anything else
10:20:59 <jethr0> do you have a preferred library for doing serialization? there seem to be quite a few on hackage, any preferences?
10:21:37 <jethr0> i.e. serialization of haskell data type object to binary data (esp. more compressed than using Show/Read)
10:22:02 <EvilTerran> ghc bundles Data.Binary, iirc
10:22:08 <ski> iabal : example instance of `Variable' ?
10:22:09 <ksf> oh.
10:22:19 <ksf> another brick in the wall, 03:20
10:22:47 <ksf> he says "cheat your feet"
10:22:53 <ksf> and no I'm not deaf.
10:23:41 <jethr0> EvilTerran: ah, cool
10:25:09 <iabal> newtype TyVar = TyVar String; instance Variable TyVar where VarIdt = String, var = TyVar
10:26:51 <iabal> I wrapp strings just for type safety (no substitution with a wrong variable) and to get some more power with generics
10:26:59 <Philonous> I wonder if junctions have any use in haskell. It's fun playing around with them, though: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8966#a8966
10:27:30 <jethr0> EvilTerran: seems you have to semi-manually create instance declarations of Binary though. I had hoped this would be done transparently by the call to "encode"...
10:28:11 <ski> iabal : i see
10:28:13 <iabal> universeBi foo :: [TyVar] or universeBi foo :: [Var], in other case I can't make distinction
10:32:29 <ski> Philonous : i believe i may have played with something somewhat similar to some of that, using `Cont' (and variants) ..
10:33:07 * ski couldn't find a way to be more vague than that
10:33:56 <holmak> jethr0: Why do you need to have compressed serialization? Would using Show/Read work, if you compressed the "show"n output, like with gzip?
10:34:06 <holmak> I'm looking at http://www.haskell.org/haskellwiki/Library/Compression
10:35:05 <ksf> compression is usefull if you have spare cpu cycles but are short on disk bandwidth.
10:35:19 <ski> (Philonous : i'll try to remember looking more closely at that later, when i'm not as tired)
10:35:57 <holmak> Yeah, the solution is very dependent on why jethr0 wants his serialized data to be compact...
10:36:04 <ksf> still, I guess the   better solution is to get a faster array.
10:36:09 <Philonous> ski: please, go ahead.
10:36:30 <ski> Philonous : later
10:36:48 * ski wanders off into misty-magic land
10:36:52 <Philonous> ski: That's what I meant to say. Yet another idiom I got wring :)
10:36:59 <Philonous> wrong*
10:46:55 <idnar> ksf: compression is really cheap, though
10:47:14 <idnar> ksf: you'll have a hard time finding enough I/O bandwidth that you don't have the CPU cycles to spare for compression
10:47:53 <idnar> well, on typical desktop hardware anyhow
10:52:31 <Phyx-> hrm... is purely functional datastructures useful to read if you have been using haskell for 2-3 years already? so far it seems kike all repitition to me
10:52:54 <opqdonut> the analysis methods are good to know
10:54:14 <Phyx-> running time analysis? aren't those rather straight forward once you keep in mine persistancy and lazyness?
10:54:22 <jfoutz> Phyx-: if you've done the analysis methods from clrs, you're probably fine.
10:54:47 <opqdonut> istr there were some pretty nice ones in pfds
10:54:59 <opqdonut> but it's been a while
10:55:19 <Phyx-> jfoutz: ok
10:55:31 <Phyx-> i'll go get some food and browse throught it
10:56:35 <jfoutz> well, there's a bunch of tricks, it's sorta like integration right? but a good understanding of a few standards should at least let you know when you can't tell what's going on, and you need to look stuff up.
11:00:37 <Craig`> is anyone here using ubuntu?
11:00:38 <Philonous> Phyx-: Many of his data structures can be described as trees with monoidal annotations. http://apfelmus.nfshost.com/monoid-fingertree.html
11:00:56 <Craig`> just I would like to know if there's a sudo apt-get isntall for ghci and haskell - I'm downloading a file atm
11:01:25 <cygnus> Craig`: not recent enough, last time I checked.  I recommend just downloading manually.
11:01:29 <Berengal> Craig`, there is, but it's somewhat out of date
11:01:43 <lilac> Craig`: the version in karmic is up-to-date
11:02:06 <Craig`> http://haskell.org/ghc/download_ghc_6_10_4.html#sources I'm downloading the bz2, is that correct, or not?
11:02:40 <Berengal> Which of them? They're all bz2...
11:02:55 <lilac> depends whether you think that's easier than installing a package from the karmic repo :)
11:03:27 <lilac> to be honest i have no idea how much other stuff you'd need to install to get ghc from karmic working on older ubuntu releases. but if it's not many or none, then that'd be what i'd do
11:03:30 <Craig`> the first one in source distrubution? I've extracted it to desktop but I don't know how to install xD
11:03:39 <Berengal> I recommend getting http://haskell.org/ghc/dist/6.10.4/ghc-6.10.4-i386-unknown-linux-n.tar.bz2
11:04:05 <Craig`> Berengal: will that work for x64?
11:04:36 <lilac> Craig`: it's probably at least worth trying installing the deb from here: http://packages.ubuntu.com/ko/karmic/ghc6
11:04:39 <Berengal> Uh, it might, but the 64-bit version is http://haskell.org/ghc/dist/6.10.4/ghc-6.10.4-x86_64-unknown-linux-n.tar.bz2
11:05:11 <Craig`> can I not just get ghci for ubuntu?
11:05:28 <Twey> No: GHCi comes with GHC, and requires GHC to function.
11:06:00 <lilac> Craig`: sure, you can get ghc for ubuntu. apt-get install ghc6
11:06:02 <Craig`> oh right; sorry
11:06:05 <Berengal> GHCi is just ghc -i
11:06:40 <lilac> Craig`: the downside is that it's GHC 6.8 not GHC 6.10, which might matter to you and might not :)
11:07:26 <Craig`> I'll just download it vila the links Berengal gave me :)
11:07:39 <Craig`> 73mb will take me ages, I'm sure the internet provider has made my internet speed <= 16kB/s :< :<
11:07:56 <luite> if you can live with 6.8.2 for a while, you can get 6.10.4 automatically when you upgrade to ubuntu 9.10 in a few months
11:08:11 <Berengal> The downside to 6.8 is that cabal won't work so good I think. There are some incompatabilities which may make key libraries not build
11:08:12 <Cale> At which point 6.12 will probably be out
11:08:53 <Craig`> tbh I'm going to get windows 7 and then put ubu on a vb
11:10:30 <Petrosian> Out of curiosity, why does it appear GHC skips odd-numbered version increments?
11:10:43 <Petrosian> At least, recently, 6.8 to 6.10 and soon 6.12
11:10:43 <Botje> those are development releases
11:10:44 <Berengal> Petrosian, those are development versions
11:10:49 <Petrosian> Ah.
11:10:55 <Botje> much like the linux kernel did before 2.6
11:11:04 <Craig`> btw; does anyone here have experience with cgis in haskell?
11:11:08 <Berengal> The latest ghc version is 6.11.something
11:11:11 <Berengal> aka HEAD
11:11:16 <lilac> Botje: is linux not doing that any more?
11:11:21 <Botje> no
11:11:32 <blackh> Craig`: Yes, lots
11:11:54 <Botje> now they're on a simple -rcX system
11:11:59 <Craig`> is it alright? or is it very stressful? (compared to say; php)
11:12:15 <luite> Craig`: you might want to try happstack instead
11:12:22 <CrazyAzrael1> lilac: Linux hasn't abandoned that, they just haven't seen a major enough modification to their structure to require a 2.7 branch yet
11:12:39 <cygnus> Craig`: there are a handful of web-frameworky packages in hackage.
11:13:00 <Botje> CrazyAzrael1: uh, they have completely rewritten the DRM and SATA parts of the kernel, iirc
11:13:14 <dino-> Craig`: There are some basics of using simple Network.CGI here too: http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell
11:13:16 <Craig`> I just quickly looked at a CGI haskell script, and it looked like haskell handles a lot of the (x)html, I would like to be in full control of my html if that makes sense?
11:13:30 <CrazyAzrael1> Botje: Yes, but that change is minor when compared to the break between 2.4 and 2.6
11:13:33 <Botje> haskell itself does nothing for you
11:13:38 <Botje> CrazyAzrael1: agreed :)
11:13:43 <Craig`> also, do I _have_ to write my html via cgi? or can I have it in a .htmlf file and only have cgi for retreiving values etc
11:14:02 <cygnus> Craig`: you can use a templating system if you want, or just build it yourself. But if you use one of the HTML libraries, you'll be more likely to generate correct documents.
11:14:02 <blackh> Craig`: cgi is really good from my point of view and probably yours. It does all the hard work (such as parsing cgi fields), but leaves you in control of the HTML.
11:14:04 <Botje> Craig`: that's up to you. The only responsibility you have as a CGI script is spitting out headers and a body
11:14:10 <Berengal> Craig`, there are various templating libraries available
11:14:22 <luite> Craig`: not all frameworks even use CGI
11:14:26 <dino-> Craig`: There are frameworks for templating like HStringTemplate and also high-level building of pages in code like Text.XHtml
11:14:40 <Craig`> :)
11:14:42 <blackh> Craig`: Also your code is easily switchable between cgi, scgi and fastcgi with no modification
11:14:43 <Craig`> just things like: page :: Html  page = body << h1 << "Hello World!" scare me :P
11:15:02 <Botje> Craig`: oh, that's *much* better than the perl equivalent :)
11:15:07 <dino-> Craig`: But it's very powerful. That code will never ever make malformed HTML
11:15:12 <Botje> but if you want to work with templates, that's fine too
11:15:20 <Craig`> just I would love to use a program language of that I used and then use it for server-side, so e.g. C, or python, or, etc
11:15:20 <dino-> And you will never have to babysit an end tag.
11:15:21 <kmc> Craig`, there's nothing forcing you to use that.  A CGI program is just any program which follows a few basic conventions about handling environment variables and stdin/stdout
11:15:22 <luite> Craig`: you should probably get used to high level abstractions if you want to learn haskell ;)
11:15:41 <exaltation> I would not use Haskell for CGI.
11:15:51 <Craig`> exaltation: why is that?
11:15:53 <Alpounet> happstack :p
11:16:09 <Craig`> (would cgi with haskell be as easy to use via ajax as php would?)
11:16:22 <c_wraith> ajax is completely irrelevent
11:16:22 <exaltation> Craig`: Haskell is best when your program is doing something complicated
11:16:40 <exaltation> Craig`: otherwise, why not use a specialized tool like PHP?
11:16:50 <exaltation> (forgive me for suspecting your CGI does nothing complicated)
11:16:51 <sshc_> how do I raise a number to a non-integer power?
11:16:53 <kmc> because php is awful
11:17:01 <Alpounet> sshc_ :
11:17:02 * cygnus nods at kmc
11:17:02 <Craig`> exaltation: I probablys will end up doing so
11:17:04 <inimino> Craig`: it makes no difference what language you write a CGI script in
11:17:04 <c_wraith> (and as a matter of fact, my company has a haskell http server that we use with ajax)
11:17:08 <CrazyAzrael1> sshc_: **
11:17:12 <Alpounet> > 3.14**14
11:17:13 <lambdabot>   9057640.366350755
11:17:22 <c_wraith> >3 ** 1.5
11:17:26 <sshc_> > 3** (3.4)
11:17:27 <lambdabot>   41.89983049571471
11:17:41 <Craig`> as I said before, I think I'll mainly use haskell for maths (as A level maths will make it more fun than gcse :))
11:17:53 <Berengal> Hmmm, haskell could use a component-based html library...
11:18:04 <Cale> exaltation: But PHP is such a horrible mess...
11:18:29 <CrazyAzrael1> Craig`: Alternatively you could have some fun and go with the happstack
11:18:32 <blackh> Use Haskell - it's better at any level of complexity.
11:18:37 <CrazyAzrael1> Which is likely overkill.
11:18:54 <Berengal> Happstack is only as much overkill as you want it to be
11:19:26 <Cale> Formlets look cool
11:19:45 <etpace_> you wont really learn anything at A level or GCSE to do with Haskell, learn it if you want to, but if you want to use it "for" maths, you wont be using it much
11:19:51 <Berengal> Yeah, I've been looking at formlets a bit
11:21:19 <cwvh> Once you "go" Haskell, there is no coming back.
11:21:37 <cwvh> I write Python for my day job and cringe every time--testing helps, but.. ick :-)
11:21:50 <exaltation> I wish I could write Python for my day job!
11:21:58 <etpace_> i'm approaching that point cwvh, and I'm still a noob at haskell
11:22:03 <exaltation> (unless it's web programming or something)
11:22:10 <blackh> I write Haskell for my day job and I don't wish I could write Python.
11:22:16 <etpace_> even though not even a month ago I was more than happy with python
11:22:27 <sshc_> exaltation: which language do you use?
11:22:35 <exaltation> currently C#
11:22:52 <cwvh> blackh: I'm sneaking in some GEOS Haskell bindings and Happstack, but I doubt they will see much use.
11:22:59 <Craig`> I like C# :3
11:23:37 <Berengal> At least you don't have to write in Java :(
11:23:43 <Cale> sshc_: The three exponentiation operators in the Prelude (^), (^^), and (**) correspond to three definitions of exponentiation from mathematics. (^) only allows non-negative integer powers, but works with any kind of number as the base, since it only needs to multiply to do its job. (^^) works with negative exponents, but requires the base to be a fractional type of number, because it needs to invert. (**) allows any
11:23:43 <Cale> Floating as the exponent, but requires a Floating base as well, as it is generally defined in terms of exp and log
11:23:47 * Berengal writes in-house web-apps in java
11:24:32 <exaltation> Berengal: ouch
11:24:41 <exaltation> i actually like C#, i'd still prefer Python though
11:24:52 <Berengal> exaltation, it could be worse. It could be php
11:24:57 <sshc_> blackh: where do you work?
11:25:02 <exaltation> (and obviously Haskell, but well...)
11:25:40 <blackh> sshc_: I work at home and I spend 3/4 of my work time working on a game for iPhone with Ryan Trinkle.
11:25:53 <Craig`> so you guys think I should learn haskell (for maths mostly), and then maybe C (as it's advised before taking comp sci)
11:26:02 <cwvh> blackh: ah, cheater :-)
11:26:04 <blackh> sshc_: His company doesn't have much money, and we're taking a punt on making some money out of sales.
11:26:12 <CrazyAzrael1> You don't know how good static typing is until you run a long job in python, only to have a typo in a method name that it couldn't tell didn't exist because it was a dynamic language, the error hits and it rolls back several days of computation
11:26:13 <CrazyAzrael1> :(
11:26:16 <etpace_> its actually not advised to learn C by a few universities here CrazyAzrael1
11:26:19 <etpace_> Craig`: *
11:26:31 <c_wraith> C is a really bad language to learn computer science with
11:26:32 <CalJohn> Craig`: I think learning C is a bad idea
11:26:32 <etpace_> advised not to learn, even :P
11:26:35 <Craig`> etpace_: why is that?
11:26:36 <exaltation> Everyone needs to know C
11:26:40 <c_wraith> It's a decent language to learn computer architecture with
11:26:44 <exaltation> not knowing C is like not having read Shakespeare
11:26:48 <CrazyAzrael1> Learn C iff you are going to talk to a real machine.
11:26:56 <c_wraith> But it's very bad for learning how to think about programming.
11:27:03 <blackh> sshc_: You still have to make your own luck for Haskell work at this stage, but I think it's only a matter of time before it's easier to get real work.
11:27:03 <CrazyAzrael1> If you're always going to have some other guy between you and the machine then you don't need to worry about it.
11:27:07 <etpace_> see all of the above
11:27:40 <Berengal> Too many CS courses explain things imperatively...
11:27:44 <cwvh> C is good for learning how to think like the machine, Haskell is good for reasoning.
11:27:47 <luite> I think knowing a bit of C is still useful, even if you do haskell
11:27:50 <CalJohn> Craig`: i think it's nice just to learn any language you find interesting that won't instill negative habits.  Haskell and prolog are fun in this respect.  So is scheme (and it comes with the best learning materials of any language)
11:27:52 <Philonous> It's more like reading "The Very Hungry Caterpillar". Very basic, but almos everyone has done it.
11:27:53 <Craig`> yeah but haskell will give me good habbits, (or will they be considered bad in haskell)?
11:28:26 <etpace_> Berengal: most courses here teach FP as the first language, and dont touch on it again
11:28:26 <cwvh> Craig`: depends, if I see a lot of forM_, I may have to shake you.
11:28:30 <etpace_> which is a shame
11:28:51 <exaltation> Philonous: Shakespeare is a better comparison, because everyone quotes it and you're expected to catch the references
11:29:03 <sshc_> blackh: How are you handling the state in the game?
11:29:09 <Berengal> etpace_, we didn't even get it as a first language, and we had to share with prolog (which could be worse)
11:29:11 <CalJohn> exaltation: C really is not a good analogue for any literature
11:29:13 <Craig`> (I might not learn C in the end, I've just been told that learning C will make me learn other languages "easy" - that is; C - based languages)
11:29:22 <blackh> sshc_: We're using Yampa, slightly modified.
11:29:22 <dino-> cwvh: :O  I have never use forM. Ever.
11:29:27 <dino-> *used
11:29:39 <CalJohn> C will make learning most languages hard, because it includes almost no features and is a really simple and unhelpful language
11:29:53 <cwvh> dino-: tongue-in-cheek, it's very nice and appropriate some times.
11:29:57 <c_wraith> c-based languages?  C is an algol-based language!  Why does no one give algol credit for the syntax?
11:30:14 <c_wraith> (or blame, depending on viewpoint)
11:30:16 <exaltation> CalJohn: do you have any argument to back up your trolling?
11:30:24 <jfoutz> C coming up from EE is nice.
11:30:26 <exaltation> dislike for C doesn't count
11:30:33 <etpace_> I don't think many students take it seriously either Berengal, mostly 'what the hell is that nobody uses this in the real world why are they doing this to me'
11:30:52 <lilac> learning C will make you dislike other languages for making "hard" things easy; learning Haskell will make you dislike otehr languages for making "easy" things hard
11:31:43 <CrazyAzrael1> lilac: Caveat on that--it will make you dislike languages which make "hard" things easy without some kind of explanation of what's going on
11:31:56 <Berengal> etpace_, in my case, the prof. seemed to really like prolog though. He tried to use it in an earlier algorithms course, but it sort of failed. I'm still impressed he managed to write a bubble-sort that didn't become a selection sort though
11:32:08 <CrazyAzrael1> lilac: For example, one good thing that comes out of that is a strong hatred of Perl and RoR for wtfmagic and special casing
11:32:19 * Berengal only knows how to write bubble-sort in imperative languages
11:32:24 <mauke> CrazyAzrael1: wat
11:32:35 <CrazyAzrael1> mauke: Be more specific?
11:32:44 <mauke> ok, you're wrong
11:32:58 <c_wraith> I don't really understand bubble sort.  Why do people call it the "simplest" sort?  It's far less obvious than selection or insertion sorts.
11:32:59 <CrazyAzrael1> I just said several things, what part is wrong?
11:33:15 <mauke> CrazyAzrael1: hatred of Perl is not a good thing, and knowing C doesn't cause it
11:33:24 <bos> @seen dons
11:33:24 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 10h 14m 46s ago.
11:33:33 <Berengal> c_wraith, I know! I still can't explain it properly...
11:33:33 <exaltation> Python causes hatred of Perl :)
11:33:34 <bos> @seen conal
11:33:34 <lambdabot> I saw conal leaving #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah 7d 22h 11m 41s ago, and .
11:33:37 <bos> hmph
11:33:58 <mauke> exaltation: I blame that on general python brain damage
11:34:01 <CrazyAzrael1> c_wraith: It's simplest because you don't need a fully ordered set, and is essentially just extracting the best known minimum one at a time.
11:34:03 <etpace_> perls regex makes me scared of perl
11:34:13 <mauke> etpace_: you're doing it wrong
11:34:20 <skorpan> the regular expressions are the only thing right with perl
11:34:41 <mauke> etpace_: the other non-perl tools had way worse regex syntaxes
11:34:45 <c_wraith> CrazyAzrael1: "extracting the best known minimum one at a time" sounds more like selection sort than bubble sort
11:35:00 <exaltation> mauke: Possibly. I don't even know Perl, but I still hate it. I just know about the explicit references, and implicit typecasting, and that's enough for me to avoid it.
11:35:03 <mauke> etpace_: perl gave us a sort of sane de-facto standard for regex functionality
11:35:05 <CrazyAzrael1> c_wraith: Bubble sort is just doing that on a potentially partially ordered set
11:35:13 <etpace_> most likely, its more that I'm not very experienced with regex, so the power of perls is intimidating
11:35:22 <mauke> <exaltation> mauke: Possibly. I don't even know Perl, but I still hate it.  <- pfft
11:35:30 <c_wraith> My understanding of bubble sort is "swap out of order adjacent pairs until there aren't any"
11:36:19 <CrazyAzrael1> You start with a list of length n, then you swap left to right once through and now you have a list of length n - 1 that is unsorted, as the biggest or smallest (depending on how you were sorting) element has been pushed all the way through
11:36:36 <CrazyAzrael1> So then you sort the sublist until you get to size 1 and terminate
11:36:56 <CrazyAzrael1> A good example of where this can be practically be used is with job candidates
11:36:57 <mauke> etpace_: perl gave us rule #1 of basic regex sanity: backslash always escapes, and escaping a non-alphanumeric character makes it match literally
11:37:03 <FunctorSalad> omg, bubblesort.
11:37:09 <CrazyAzrael1> It is hard to assign a number to each of them, but easy to compare any two
11:37:10 <Craig`> haskell vs c cgi D: who wins ^>^
11:37:21 <CrazyAzrael1> (comparatively :P)
11:37:32 <CrazyAzrael1> thus making it a poset, and making it actually a useful algorithm for once
11:37:39 <Botje> Craig`: haskell obviously. string manipulation is a pain in C
11:37:47 <dino-> But regex is a really contradictory notation. The P6 "rules" overhaul would have been quite a bit nicer.
11:37:54 <lilac> mauke: perl gave us rule #1 of basic string interpolation insanity: to decide where interpolation ends, a bunch of heuristics take a vote
11:38:11 <c_wraith> CrazyAzrael1:  So it's really just selection sort with lots of extra swapping?
11:38:18 <FunctorSalad> CrazyAzrael1: bubblesort for posets?
11:38:23 <mauke> lilac: example?
11:38:33 <etpace_> mauke: it's just that it's such a 'beast to tame', I believe I saw a regex that deduced primality before?
11:38:39 <FunctorSalad> I thought you'd use 'topological' sort
11:38:40 <mauke> lilac: wait, do you mean the /$foo[1-2]/ stuff?
11:39:08 <mauke> etpace_: that's not hard, and the regex was just for testing possible divisors
11:39:15 <mauke> using brute force
11:39:30 <lilac> mauke: i mean "$foo{bar}{baz}->x(y)"
11:39:45 <lilac> from perlop: "Since the outcome may be determined by voting based on heuristic estimators, the result is not strictly predictable, but is usually correct for the ambiguous cases."
11:40:11 <etpace_> I guess it's just that I only thought of regex as pattern matching
11:40:13 <mauke> that case is unambiguous
11:40:19 <CrazyAzrael1> FunctorSalad: You can do it that way too--the bubblesort is just more convenient when doing it in real life (as rather than generating the graph, then generating the sort, you just generate the sorted component
11:40:29 <mauke> it's $foo{bar}{baz} . '->x(y)' or I'll eat my hat
11:40:32 <Craig`> heh printing out K&R :P
11:40:35 <CrazyAzrael1> FunctorSalad: Really, the only times I've seen bubblesort used are for sorting hiring orders by committee
11:41:06 <CrazyAzrael1> FunctorSalad: As each query to the "is there a partial ordering" function to create the graph is simply mapped onto a swap or not swap instead
11:41:27 <lilac> mauke: what if i insert some spaces into it?
11:41:36 <mauke> crap
11:41:52 <mauke> lilac: well, I've always worked under the assumption that interpolation stops at spaces
11:42:12 <FunctorSalad> CrazyAzrael1: ok, for manual operations things are a different matter
11:42:14 <mauke> it hasn't bitten me so far, but I think I'll have a look at the source
11:42:19 <sshc_> if I define Foo by "data Foo = FooConstructor", how do I export Foo without exporting FooConstructor?
11:42:31 <mauke> Foo
11:42:32 <sshc_> export Foo in a module
11:42:46 <CrazyAzrael1> FunctorSalad: Or if the encoding of the poset isn't as a graph but as a function which returns GT LT or EQ for unsure
11:42:49 <sshc_> module Module (Foo) where ...
11:43:07 <c_wraith> as opposed to "module Module (Foo(..) where ..."
11:43:13 <Berengal> sshc_, module FooMod(Foo) only exports the type, module FooMod(Foo(FooConstructor)) also exports the constructor
11:44:01 <sshc_> Berengal: can I use '..' to export all the constructors?
11:44:11 <Berengal> sshc_, yes
11:44:12 <FunctorSalad> CrazyAzrael1: hmm... haven't thought about that case :)
11:44:26 <FunctorSalad> CrazyAzrael1: I wonder what the complexity is
11:44:48 <FunctorSalad> naively you'd need O(n^2) comparisons, but you can use transitivity to infer parts of the poset...
11:45:12 <CrazyAzrael1> While true, I think there's probably some constant factor bound on how much of the poset you could infer
11:45:25 <CrazyAzrael1> (though that's just intuition, I have no proof of that)
11:46:32 <CrazyAzrael1> Also, while it loses formal correctness properties, iterated bubblesort is fun for non-transitive posets (i.e. their graphs are cyclic) which happen in certain opinion situations when done by vote
11:46:39 <FunctorSalad> CrazyAzrael1: but yeah, my comparison to toposort was a bit silly because with the way the input is given to toposort, sorting would be trivial for a total order
11:46:55 <FunctorSalad> (other sorts being for total orders)
11:47:01 <CrazyAzrael1> Sure.
11:47:02 <FunctorSalad> with the graph I mean
11:47:30 <CrazyAzrael1> Yeah. All I'm saying is that while worthless in the context it is usually introduced, there are valid uses of bubble sort--you just are unlikely to run into them.
11:47:41 <FunctorSalad> non-transitive poset? isn't that just a relation?:)
11:48:54 <CrazyAzrael1> FunctorSalad: Probably. I'm unfortunately not very up on my math--I've mostly just acquired terms as I needed them.
11:50:06 <FunctorSalad> transitivity and reflexivity are the only real properties of a poset... (you can always get antisymmetry by defining the equality from the order :))
11:50:10 <FunctorSalad> ;)
11:51:30 <CrazyAzrael1> What I really mean at that point is just a set accompanied by an ordering function, with the ordering function not gauranteed transitive :)
11:51:44 <CrazyAzrael1> I suppose I should learn some abstract algebra so that I know the proper term for that
11:52:17 <lispy> isn't that a partial order?
11:52:29 <FunctorSalad> isn't transitivity the defining property of order even informally?
11:52:54 <lispy> FunctorSalad: imagine an order where pairwise it works, but it has no transitivity
11:53:22 <CrazyAzrael1> FunctorSalad: A simple example can be found in political science if you look at preference schedules
11:53:34 <CrazyAzrael1> Each person submits a preference schedule which is internally consistent
11:53:40 <CrazyAzrael1> However, when composited you can get a cycle
11:53:58 <lispy> (looking at wikipedia) hmmm... a partially order set still has transitivity
11:54:31 <CrazyAzrael1> lispy: Yes, a poset (as far as I know) is supposed to just have some unknown relationships, but all known ones make sense in relation to one another.
11:54:39 <FunctorSalad> (btw with "defining the equality" I meant taking the quotient to be more accurate)
11:55:06 <CrazyAzrael1> (sure, just collapse the points and keep the structure)
11:55:09 <FunctorSalad> CrazyAzrael1: I seem to remember that example from voting. what was the relation there again?
11:55:45 <FunctorSalad> A > B if A is above B in more than 50% of voters?
11:56:12 <CrazyAzrael1> http://en.wikipedia.org/wiki/Voting_paradox
11:56:20 <lispy> http://en.wikipedia.org/wiki/Intransitivity
11:56:46 <CrazyAzrael1> It usually shows up when using a combination of preference schedules with condorcet criterion fulfilling methods
11:56:59 <CrazyAzrael1> (so there are multiple ways that will cause this problem)
11:59:20 <kynky> what are the practical differences between chan and tchan ?
12:01:12 <CrazyAzrael1> kynky: It might be more than this, but at the very least, TChan allows you to act within the STM monad only, without going to messy IO land.
12:01:14 <Philonous> kynky: Chan is in IO, TChan in STM
12:01:54 <lispy> :t Chat
12:01:55 <lambdabot> Not in scope: data constructor `Chat'
12:01:56 <lispy> :t Chan
12:01:57 <lambdabot> Not in scope: data constructor `Chan'
12:02:02 <lispy> ?hoogle Chan
12:02:02 <lambdabot> module Control.Concurrent.Chan
12:02:02 <lambdabot> Control.Concurrent.Chan data Chan a
12:02:02 <lambdabot> package change-monger
12:02:33 <CrazyAzrael1> Also looks like TChan is GHC only.
12:02:44 <kynky> needs threaded ?
12:02:59 <Berengal> Needs STM
12:03:30 <kynky> i mean the fact its ghc only
12:03:52 <Berengal> Yes, it needs STM
12:04:48 <kynky> was just trying to figure out when to use one over the other
12:23:30 <jethr0> is there a standard way to make the output of "show" more readable for complex data types?
12:24:25 <Botje> write a Pretty wrapper around it :)
12:24:39 <Petrosian> jethr0: Don't use derive, but write your own instance?
12:24:40 <Botje> Text.Prettyprint, i mean
12:24:48 <cygnus> http://hackage.haskell.org/package/pretty-1.0.1.0
12:25:37 <Rotaerk> hmm what's the appropriate use for show anyway
12:25:48 <Rotaerk> I mean there could be multiple ways you'd want to show a value, which one should show use
12:25:53 <jethr0> Rotaerk: hehe
12:25:59 <Gracenotes> jethr0: if your structure can be represented as a tree, drawTree is good for 2D layouts
12:26:07 <Gracenotes> from Data.Tree
12:26:20 <Gracenotes> @hoogle drawTree
12:26:21 <lambdabot> Data.Tree drawTree :: Tree String -> String
12:26:26 <jethr0> Gracenotes: what kind of input would you give it?
12:26:26 <FunctorSalad> Rotaerk: yeah, serialization vs. pretty display
12:26:29 <jethr0> ah
12:26:36 <Rotaerk> show is for serialization then?
12:26:47 <Gracenotes> Tree being a root and a list of subtrees (called forests)
12:26:53 <pacopil> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
12:26:53 <FunctorSalad> I don't think it's officially determined, Rotaerk
12:26:59 <Rotaerk> okay
12:27:18 <Gracenotes> however, it's not useful for any other purpose than looking pretty, drawTree and drawForest are..
12:27:26 <Rotaerk> I mean i wrote a show method for a tic-tac-toe grid (which is a 3x3 IArray)
12:27:49 <Rotaerk> and it labels the columns/rows
12:27:52 <FunctorSalad> use ansi-wl-pprint, it has colour!! :)
12:28:03 <Rotaerk> and I was like "maybe this shouldn't be the show method .."
12:28:11 <Gracenotes> Data.Binary is one way to do serialization. lazy at that, which can be both good and bad
12:28:25 <dons> not hard  to make it strict either
12:28:54 <Gracenotes> dons: and your library could also be used for it, if the IO is fixed by now
12:28:57 <FunctorSalad> colour is often dismissed as frivolous but I think it quite increases information content
12:29:00 <Craig`> I've downloaded 6.10.4 x64, now what do I do? it's just a bunch of files D:
12:29:05 <Gracenotes> uh.. uarray or something like... /me hasn't used it in a while
12:29:41 <Gracenotes> hm, is there a README or INSTALL?
12:29:45 <dons> "the IO is fixed by now" ?
12:29:55 <dons> oh, you mean uvector
12:29:55 <bos> dons: i texted you earlier to see if you were around
12:29:57 <dons> not binary
12:30:02 <Gracenotes> right right
12:30:03 <dons> bos, ah. just back from dinner
12:30:08 <bos> cool
12:30:13 <bos> just arrived late this afternoon
12:30:56 <Craig`> there's an install, but it's not making a lot of sense
12:31:51 <dino-> Craig`: Did you get the generic Linux binary installer?
12:32:27 <bos> @seen dcoutts
12:32:27 <lambdabot> Last time I saw dcoutts was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #bfpg, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc,
12:32:27 <lambdabot> #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-iphone, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #
12:32:27 <lambdabot> haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #interplanetarylazers, #jhc, #jtiger, #kata, #learnanycomputerlanguage, #macosx, #macosxdev, #
12:32:27 <lambdabot> novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #uscs2009, #xmonad and #yi 7d 10h 36m 53s ago, and .
12:32:41 <p_l> o_O
12:33:01 * Rotaerk fmaps all FunctorSalad's functors to the constant value 0.
12:33:14 <Rotaerk> mwahah
12:33:25 <Craig`> dino-: I don't know about binary installer; I've got the binary files though :
12:33:29 <Craig`> *:/
12:33:33 <Rotaerk> irreversible
12:33:55 <FunctorSalad> you can fmap functors?:o
12:34:38 <Rotaerk> FunctorSalad, yes, that's what a functor is in haskell :P
12:34:45 <Craig`> To set the ball rolling, run the configure script (as usual, run the script with --help to see what options it supports).  eg. to set up the package for installing in directory <my-dir>, use .. how do I even do that D:
12:35:11 <dons> btw guys, did you know the judges prize, and a top 10 place at ICFP contest this year was facebook, using haskell ....
12:35:12 <Craig`> I double clicked configure, and then some new files appeared
12:35:14 <dino-> Craig`: Ok, sounds like you have the generic Linux binary.
12:35:18 <dons> +(matlab, java, php)
12:35:30 <dons> they declared haskell their language
12:35:38 <FunctorSalad> Rotaerk: but the functor fmaps the function, it isn't fmapped itself. yes ladies and gentlemen, this remark doesn't have any point whatsoever
12:35:47 <dino-> Craig`: It may be more useful to run configure from a shell so you can see if it completed ok or had errors.
12:35:52 <dino-> It's not a GUI program
12:35:55 <Rotaerk> FunctorSalad, pfft
12:35:56 <Craig`> dino-: how do I do so?
12:36:23 <Rotaerk> FunctorSalad, I see it as ... the functor is mapped to another functor over a function
12:36:45 <FunctorSalad> you do get functors from functor categories to somewhere else in general, but not in haskell
12:36:46 <dino-> Craig`: Are you running a Linux? Hm. What did you dl exactly?
12:37:10 <Rotaerk> so I just mapped all your functors to ones that contain nothing but 0
12:37:17 <Craig`> yes I am running ubuntu, I downloaded ghc-6.10.4 x64; I'm asking how do I run haskell scripts or whatnot form the terminal?
12:37:32 <Gracenotes> in Ubuntu, for example, the shell is in applications/accessories/terminals
12:37:37 <Botje> runhaskell foo.hs
12:37:52 <dino-> Craig`: Ok, do it from a shell. A terminal emulator window.
12:38:26 <Craig`> what I'm saying is can you give me the command?
12:39:13 <dino-> Craig`: Try what Gracenotes said above. I don't use Ubuntu, and in fact have no launchy menu in my window manager.
12:39:21 <dino-> If you can get that shell up, we can help you with commands in there.
12:40:19 <Craig`> I've got the terminal open..
12:40:42 <dino-> Craig`: Ok, so cd into the dir where you unpacked the .tar.gz
12:41:03 <Craig`> yes
12:41:14 <dino-> And do this: ./configure
12:41:25 <dino-> And I'm going to guess that something is going to be missing, like that pesky gmp lib
12:41:34 <Craig`> bash: ./configure: No such file or directory
12:41:41 <Craig`> oh wait,
12:42:08 <Craig`> right I did ./configure
12:42:12 <Craig`> but then I did make install
12:42:14 <Craig`> and I got an error
12:42:32 <blackh> sudo make install?
12:42:33 <Craig`> mkdir: cannot create directory `/usr/local/lib/ghc-6.10.4': Permission denied .. how do I give it permission?
12:42:55 <holmak> sudo
12:43:05 <dino-> Craig`: You'll need to do the make install as root user, yes, sudo
12:43:18 <CrazyAzrael1> Craig`: You are trying to install a systemwide package, execute with superuser permissions or grant the current user write on /usr/local/* and friends
12:43:29 <Craig`> with sudo I get 2 errors
12:43:29 <Craig`> ld: Apply.o: No such file: No such file or directory make[1]: *** [HSrts.o] Error 1 make[1]: Leaving directory `/home/craig/Desktop/ghc-6.10.4/rts' make: *** [install] Error 2
12:44:08 <CrazyAzrael1> Try running make before make install
12:44:34 <dino-> hm, this is maybe the un-built sources?
12:44:45 <blackh> 6.10.4 works well on Ubuntu.  It could be that you have a missing package, such as libgmp.  Scroll up a bit and see if it mentions a missing library.
12:44:52 <blackh> This is the binary release, right?
12:44:53 <Craig`> the error is due to command not being found :<
12:44:59 <Craig`> meh I'll just wait til I get windows 7
12:45:01 <CrazyAzrael1> What command?
12:45:27 <CrazyAzrael1> sudo apt-get build-dep ghc6
12:45:30 <CrazyAzrael1> may fix your problem
12:45:48 <CrazyAzrael1> (it will install everything that debian needs to build 6.8, which is likely very similar to the build requirements for 6.10)
12:46:14 <Craig`> i'll pastebin it
12:46:33 <holmak> @djinn (a -> b) -> a -> b
12:46:34 <lambdabot> f a = a
12:48:23 <Craig`> http://pastebin.ws/4sbt4r
12:49:50 <Lemmih> Craig`: Did you run 'make' first?
12:50:14 <Craig`> sudo run?
12:50:27 <Lemmih> Craig`: No, just plain 'make'. No arguments, no sudo.
12:50:52 <Craig`> yes I got errors though, meh I'll wait til i get win7 bye ive gtg
12:51:00 <dino-> Is that recent? I've never had to do that with the generic Linux binary. Say with Debian.
12:51:28 <blackh> That 'c' command thing was very weird
12:51:30 <c_wraith> ubuntu doesn't come with libgmp-dev
12:51:40 <c_wraith> Which is needed to compile haskell programs
12:51:47 <c_wraith> So, there's at least one missing bit
12:51:56 <dino-> c_wraith: Yeah, I was expecting that to be a problem, but I don't think we go successfully through configure first
12:52:21 <dino-> This seems to be typical of all the debians
12:52:43 <dino-> Or maybe I'm nuts and misremember that it shakes out during configure
13:05:10 <etpace_> :t scan
13:05:11 <lambdabot> Not in scope: `scan'
13:05:17 <etpace_> :t scanr
13:05:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
13:07:33 <etpace_> @src scanl
13:07:34 <lambdabot> scanl f q ls = q : case ls of
13:07:34 <kyagrd> Haskell symposium is 12 hours left.
13:07:34 <lambdabot>     []   -> []
13:07:34 <lambdabot>     x:xs -> scanl f (f q x) xs
13:12:27 <etpace_> @src scanr
13:12:27 <lambdabot> scanr _ q0 []     =  [q0]
13:12:28 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
13:12:28 <lambdabot>     where qs@(q:_) = scanr f q0 xs
13:15:23 <etpace_> @src foldr
13:15:23 <lambdabot> foldr f z []     = z
13:15:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:16:43 <etpace_> @src foldl
13:16:43 <lambdabot> foldl f z []     = z
13:16:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:17:58 <ehamberg> (reading rwh) i can't seem to find the "generate" function in Test.QuickCheck. i have installed version 2.1.0.1 with cabal-install. is that function replaced with another or am i doing something wrong?
13:18:09 <ehamberg> Not in scope: `Test.QuickCheck.generate'
13:20:28 <CrazyAzrael1> ?hoogle generate
13:20:29 <lambdabot> Test.QuickCheck generate :: Int -> StdGen -> Gen a -> a
13:20:47 <byorgey> ehamberg: there's no generate function anymore.  what was the type of generate in the old version of CuickCheck?
13:21:03 <byorgey> I don't remember quite what it was supposed to do.
13:21:50 <byorgey> maybe try 'sample' or 'forAll'?
13:23:12 <ehamberg> ghci> generate 10 (System.Random.mkStdGen 2) arbitrary :: [Bool]
13:23:12 <ehamberg> [False,False,False,False,False,True]
13:23:18 <FunctorSalad> ehamberg: the sig quoted by lambdabot is just the fold of Gen
13:23:32 <FunctorSalad> Gen a = (Int -> StdGen -> a) IIRC
13:23:50 <FunctorSalad> @src Gen
13:23:51 <lambdabot> Source not found. You type like i drive.
13:23:58 <Tobsan> heh
13:24:24 <FunctorSalad> http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/Test-QuickCheck-Gen.html#v:Gen
13:24:55 <FunctorSalad> ehamberg: you need to import the .Gen module explicitly for Gen to be "public" I think
13:26:10 <ehamberg> hmmm, so what would i have to do in order to do something like the example quoted above?
13:26:42 <FunctorSalad> you'd define generate as: "generate n g (Gen foo) = foo n g"
13:32:24 <kmc> :t arbitrary
13:32:26 <lambdabot> forall a. (Arbitrary a) => Gen a
13:32:40 <kmc> @src Arbitrary
13:32:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:33:50 <chessguy_work> sup
13:34:10 <FunctorSalad> sup!
13:34:44 <jethr0> wazaaap
13:35:08 <jethr0> should be in QuickCheck somewhere
13:35:40 <FunctorSalad> kmc: it's the class method of Arbitrary :o
13:35:46 <jethr0> Test.QuickCheck.Arbitrary
13:35:51 <jethr0> class Arbitrary a where
13:35:52 <jethr0> arbitrary :: Gen a
13:35:55 <jethr0> shrink :: a -> [a]
13:36:03 <FunctorSalad> ah, and shrink.
13:36:07 <kyagrd> @hoogle arbitrary
13:36:07 <lambdabot> Test.QuickCheck arbitrary :: Arbitrary a => Gen a
13:36:07 <lambdabot> Test.QuickCheck class Arbitrary a
13:36:07 <lambdabot> Test.QuickCheck coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
13:36:59 <kyagrd> I've never defiend shrink myself.  Does shrink have default implementation? (I hope so ... but not sure)
13:37:04 <jethr0> @seen d00nibro
13:37:04 <lambdabot> I haven't seen d00nibro.
13:37:13 <mauke> preflex: seen d00nibro
13:37:13 <preflex>  Sorry, I haven't seen d00nibro
13:37:13 <chessguy> ....
13:37:44 <jethr0> huh?
13:37:54 <FunctorSalad> kyagrd: often you can implement it by shrinking one of the members of your type
13:38:17 <endojelly> is it bad style to reuse names for binding inside do blocks?
13:38:31 <endojelly> if I don't I get code like:
13:38:37 <kmc> there's a bit in one of the SYB papers about generic shrink
13:38:40 <FunctorSalad> data Foo = Foo Int String; shrink (Foo x y) = fmap (\y1 -> Foo x y1) shrink ++ fmap (\x1 -> Foo x1 y) shrink
13:38:40 <endojelly> x' <- someFoo x
13:38:42 <surgeon> how do I have to design a function which will return something, but has to execute another function that doesn't execute anything?
13:38:45 <endojelly> x'' <- someOtherFoo x'
13:38:47 <endojelly> ...
13:38:50 <surgeon> do I need a do block?
13:39:04 <kmc> ?
13:39:27 <kmc> surgeon, you never *need* a do block; it is syntactic shorthand for the use of monad operators
13:39:32 <Botje> endojelly: if you don't need x', you might want 'x' <- someOtherFoo =<< someFoo x'
13:39:49 <jethr0> surgeon: "do" is just syntactic sugar for ">>=" and ">>"
13:40:10 <surgeon> ah thanks for explaining
13:40:13 <kmc> surgeon, i'm not clear on what you want to do
13:40:13 <jethr0> if you have more than 5 expressions i would use a do, most likely. depends on circumstance as always ;)
13:40:14 <kyagrd> I just looked it up and shrink has default definition.  shrink _ = [] :)
13:40:16 <endojelly> Botje, doesn't really work in that case, unfortunately, because I'm actually foing x'' <- someOtherFoo (x', y)
13:40:32 <Botje> ah :)
13:40:33 <jethr0> kyagrd: seems like a very powerful and important function ^_^
13:40:43 <Botje> then yes, you're allowed to reuse variable names
13:40:43 <FunctorSalad> (fmap is map in my code, but I use fmap because it doesn't break if you import List or Set o_O)
13:40:55 <surgeon> kmc: hmm I'll think how I can explain it, but it's not easy, it's about the window manager xmonad
13:40:58 <Botje> but it can make your code pretty confusing
13:41:14 <kmc> surgeon, what do you mean by "execute a function that doesn't execute anything"
13:41:27 <FunctorSalad> kyagrd: but that def isn't very useful. shrink is used for finding smaller counterexamples
13:41:49 <kmc> well that's an okay default.  if you don't know how to shrink something, assume it's atomic
13:41:59 <jethr0> "To address this problem, newer versions of QuickCheck automatically shrink failing test cases after they are found, reporting a âminimalâ one in some sense." *hmm*
13:42:03 <surgeon> kmc: oh sry, I mean a function that doesn't return something
13:42:12 <kmc> surgeon, a function returns a value, by definition
13:42:19 <kmc> it can return the useless value, which is named ()
13:43:11 <kmc> but that's pretty useless, because you already know the answer before you ask the question
13:43:24 <FunctorSalad> Ghci> quickCheck (\x -> (x::Double) < 5)
13:43:24 <FunctorSalad> *** Failed! Falsifiable (after 8 tests and 1 shrink):
13:43:24 <FunctorSalad> 8.0
13:43:32 <kmc> it's more common to return an action in some monad, which has result value () but also some side effects in the monad
13:43:38 <surgeon> kmc: ok, so I have an expression that sets focus on a Xinerama screen (I don't understand this expression on myself), but it's: screenWorkspace 1 >>= flip whenJust (windows . W.view) e.g. sets focus to screen 2
13:43:42 <FunctorSalad> for double it tries to find a simpler example by cutting off the fractional part I think
13:43:51 <surgeon> kmc: an then I have a function, which returns something... hmm I have to check the types
13:44:15 <kmc> yes, check the types :)
13:45:29 <kmc> surgeon, that expression is equivalent to this do block: do { x <- screenWorkspace 1; flip whenJust (windows . W.view) x }
13:45:31 <kmc> if that helps any
13:45:42 <kmc> @do screenWorkspace 1 >>= flip whenJust (windows . W.view)
13:45:42 <lambdabot> screenWorkspace 1 >>= flip whenJust (windows . W.view) not available
13:46:05 <kmc> @redo screenWorkspace 1 >>= flip whenJust (windows . W.view)
13:46:05 <lambdabot> do { a <- screenWorkspace 1; flip whenJust (windows . W.view) a}
13:48:14 <jethr0> @pl do { a <- screenWorkspace 1; flip whenJust (windows . W.view) a}
13:48:14 <lambdabot> (line 1, column 4):
13:48:15 <lambdabot> unexpected "{"
13:48:15 <lambdabot> expecting variable, "(", operator or end of input
13:48:18 <jethr0> ohh
13:49:33 <mauke> @. redo unpl screenWorkspace 1 >>= flip whenJust (windows . W.view)
13:49:33 <lambdabot> (do { c <- (screenWorkspace 1); whenJust c (\ f -> windows (W.view f))})
13:49:53 <surgeon> kmc: ah ok, so screenWorkspace 1 is a monadic action or something like that?
13:50:20 <kmc> yeah
13:53:03 <tingi> mariano|syzygy, in a bipartite matching , how to get minimum vertex cover  from a maximum matching M? i've found the edges in M .
13:53:45 <tingi> sorry that was for another person in math. btw anyone knows solution to this problem ?
13:55:43 <jethr0> that is not a homework question by any chance?
13:59:15 <tingi> jethr0, no
13:59:58 <tingi> jethr0, can we take all the matched vertices in in left side and call it vertex cover ? i see some places specifying something like odd distance
14:00:41 <jethr0> sorry, i've forgotten most of what i once new about bipartite matchings ;)
14:00:58 <jethr0> anyone experienced with Data.Derive present?
14:02:44 <tromp> the m.v.c. may have vertices on both sides
14:04:09 <tingi> tromp, how to get the m.v.c if it have the maximal matching edges ?
14:04:36 <tromp> i dunno
14:16:52 <kmc> @pl \m f -> m >>= return . f
14:16:53 <lambdabot> (. (return .)) . (>>=)
14:17:02 <kmc> @pl \f m -> m >>= return . f
14:17:02 <lambdabot> fmap
14:17:11 <kmc> :t fmap
14:17:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:17:12 <kmc> :t liftM
14:17:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:17:53 <kmc> @pl \f m x -> m x >>= return . f
14:17:54 <lambdabot> flip (flip . ((>>=) .)) . (return .)
14:19:41 <jmcarthur_work> :t \f m x -> m x >>= return . f
14:19:42 <lambdabot> forall t a b (m :: * -> *). (Monad m) => (a -> b) -> (t -> m a) -> t -> m b
14:20:39 <jmcarthur_work> :t \f k -> fmap f . k
14:20:40 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
14:20:58 <jmcarthur_work> :t \f k -> (fmap.fmap) f k
14:21:00 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:21:11 <jmcarthur_work> :t fmap . fmap
14:21:12 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:21:33 <jmcarthur_work> :t fmap . fmap :: (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
14:21:34 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
14:21:41 <jmcarthur_work> :)
14:23:05 <jmcarthur_work> kmc, ^^
14:32:49 <jethr0> @src Data.Map
14:32:49 <lambdabot> Source not found.
14:32:53 <jethr0> @src Data.Map.Map
14:32:53 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:33:16 <jmcarthur_work> balanced tree
14:34:10 <jethr0> do i need GADTs to do sth like "data ABC a = (Ord a) => DEF a"?
14:34:20 <jmcarthur_work> no
14:34:20 <jethr0> i don't really know where to put the constraint...
14:34:27 <jmcarthur_work> but i don't recommend that style anyway
14:34:35 <jmcarthur_work> better to have it on every function that needs it
14:34:45 <jmcarthur_work> Data.Set and Data.Map are unfortunate
14:36:15 <jmcarthur_work> i think the syntax is data Ord a => ABC a = DEF a, for the record
14:36:19 <jmcarthur_work> not sure
14:36:26 <jmcarthur_work> but i still don't recommend it
14:36:31 <jethr0> data ObjectStore id obj = (Ord id) => ObjectStore
14:36:33 <mauke> depends on what you're trying to do
14:36:41 <jethr0> Data constructor `ObjectStore' has existential type variables, or a context
14:36:43 <jethr0>       (Use -XExistentialQuantification or -XGADTs to allow this)
14:36:48 <jmcarthur_work> oh existential is different
14:37:12 <jmcarthur_work> i thought you were putting the constraint on something on the lhs
14:37:14 <jethr0> i am trying to auto-derive an instance for binary. and the Data.Derive instance complains that Ord is not derivable....
14:38:09 <jethr0> then i get a different error
14:38:13 <Cale> jethr0: er... is that your whole data declaration?
14:38:22 <jmcarthur_work> yeah something looks fishy
14:38:23 <jethr0> when i have the constraint on the type, do i still need it on the functions?
14:38:30 <jethr0> Cale: no, would have been more lines
14:38:55 <mauke> jethr0: yes
14:39:02 <jmcarthur_work> i would seriously just not have Ord in the data definition if you are not using ET
14:39:04 <Cale> jethr0: Uh, yeah, putting class constraints on data declarations is mostly pointless -- at least in Haskell 98.
14:39:54 <Cale> jethr0: It just restricts the type of the data constructors that use that type variable, which ensures that any function which uses the data constructors will need such a constraint.
14:40:01 <jethr0> Cale: as i said, i am trying to use Data.Derive to auto-derive an instance of binary. and at least without the constraint it gave me an error about "... Ord a cannot be derived"
14:40:19 <Cale> Then... write an instance of Ord, or use deriving
14:40:20 <jethr0> i'll try again it with the constraint in place
14:40:44 <Cale> Leave the constraints out of your data declaration.
14:40:58 <Cale> The problem is not constraints, the problem is that there's no instance of Ord
14:41:10 <Cale> (at least, from the sound of it)
14:41:35 <jmcarthur_work> data ObjectStor id obj = ObjectStore <blah blah blah> deriving (Eq, Ord)
14:41:57 <Phyx-> hm
14:42:10 <Phyx-> oh wow, why did that look like java to me just now
14:42:18 <jmcarthur_work> Object
14:42:20 <jmcarthur_work> and < >
14:42:32 * jethr0 start to cry. I wanted to derive a Binary instance from outside the module. declaration is "data A b c = ...", "$(deriveBinary ''A)", but it said that A was wrong kind and that it needed type parameters.......
14:43:10 <Cale> jethr0: Naturally.
14:43:11 <jmcarthur_work> makes sense
14:43:50 <jethr0> yes, but "$(deriveBinary ''A ''Integer ''Integer)" didn't work, neither did "(deriveBinary ''(A Integer Integer))"....
14:44:57 <Cale> Well, I've never used that derive package myself, so I'm not sure of its limitations, but it might be that it just can't do that?
14:46:00 <jmcarthur_work> even if it can, you'd probably want it to work for instance (Binary a, Binary b) => Binary (A a b), right? doing only Integer would probably require some extensions
14:46:19 <jethr0> i may have just fixed my annoying error. I added the Ord constraint to the auto-generated instance code and now it compiles and runs. seems a bit dodgy to me, but oh well
14:46:25 <jmcarthur_work> i'm also not familiar with the package, though, so i can't help with its specifics
14:46:48 <jmcarthur_work> O_o
14:47:32 <jethr0> "a" really IS Integer where I'm using "A". never mind, seems to work now. if i have any further insights what just happened i'll gladly share them ^_^
14:48:06 <jmcarthur_work> from a design standpoint, why would you make the parameter polymorphic if you only will use Integer?
14:49:46 <mak__> j #lisp-pl
14:49:48 <jethr0> because the second parameter (which doesn't need Ord) is a data type i didn't want to import.
14:49:59 <jethr0> circular dependencies and all
14:50:35 <jmcarthur_work> but why have the first parameter if you only don't know the second?
14:51:34 <jethr0> i wanted to define a reusable container data type and so far i haven't had any problems with it
14:51:36 <jmcarthur_work> e.g. why   data Foo a b = Foo a b   instead of  data Foo a = Foo Integer a   ?
14:52:00 <jmcarthur_work> if it it to be reusable then surely you want Binary for more than just Integer
14:52:40 <jethr0> right now i'm just trying to get Binary working. i've spent far too much time on it already. as I said, i'll probably have more insights on this whole deriving business as i go along
14:53:51 <kyagrd> Is anyone using gitit?
14:53:57 <Lemmih> kyagrd: I am.
14:54:04 <kyagrd> Lemmih:
14:54:13 <kyagrd> Lemmih:
14:54:15 <kyagrd> oops
14:54:17 <Lemmih> Yes?
14:54:27 <dancor> when empty strings attack
14:54:44 <kyagrd> Lemmih: Are you running on that on 80?
14:54:54 <jmcarthur_work> jethr0, you could have just written it yourself. Binary isn't that hard to write for, i think
14:55:37 <kyagrd> Lemmih: I'm wondering if there is a way to use it with apache but I only want to use port 80.
14:55:39 <Lemmih> kyagrd: No, I run it through a proxy.
14:55:45 <jmcarthur_work> but don't mind me. if you're just trying to get it working that's fine. i don't mean to be annoying
14:56:36 <dancor> jethr0: dunno if this helps, but when i want an automagical Binary instance i just do:  import Data.DeriveTH  at the top and  $(derive makeBinary ''MyType)  at the bottom
14:56:54 <kyagrd> Lemmih: So, you're using a proxy service that the client talks to 80, or just forwarding the client using other ports?
14:57:06 <dancor> and MyType needs deriving Typeable, Data.  and you need {-# LANGUAGE DeriveDataTypeable, TemplateHaskell #-}
14:57:23 <dancor> and you are done!
14:57:25 <sshc_> what's a good way to use a configuration (mainly key bindings) for a game in haskell?
14:57:48 <dancor> sshc_: a good way to just read a configuration file?
14:57:48 <Lemmih> kyagrd: My lighttpd server forwards requests to gitit.
14:58:06 <jethr0> jmcarthur_work: yes, i've seen that now as well ;)
14:58:10 <Lemmih> kyagrd: http://seize.it/
14:58:16 <jethr0> dancor: thx, that's more or less how i am doing it
14:58:22 <sshc_> dancor: I'm trying to work out how I'd have the configuration interact with the game
14:58:43 <sshc_> dancor: passing ConfigState to every function seems a little,..
14:58:48 <dancor> sshc_: can't you just read it when the game loads?  http://hackage.haskell.org/package/ConfigFile
14:58:51 <mxc> @dancor - i like to keep my makeBinary calls in a seperate module since it usually throws a ton of compiler warnings which i only turn off for tht file
14:58:51 <lambdabot> Unknown command, try @list
14:59:24 <sshc_> dancor: I'm probably thinking too imperatively
14:59:44 <dancor> mxc: i'm more concerned about compilation time, so i split my types into different files and each makeBinary goes below the type definition
14:59:46 <jethr0> jmcarthur_work: and also because I have twenty data types with quite a few members. so i wanted to keep the typing to a minimum *g*
15:00:05 <kyagrd> Lemmih: Oh, lighthttpd. I was wondering if there is a way to work it with apache (I believe so ... but haven't yet bothered to look up the manual)
15:00:17 <dancor> i don't actually see warnings for mine..
15:00:26 * dancor isn't using cool enough types
15:00:26 <Lemmih> kyagrd: Probably. It's a very common thing to do.
15:00:37 <mxc> dancor: good idea..  i usually end up with a Com.Me.Module and Com.Me.ModuleTypes pair for every module to avoid cyclical imports
15:00:43 <mxc> never thought about a module for each typpe
15:00:54 <mxc> of course, i'd be at like 1000 modules if i did that
15:00:57 <dancor> waiting for template haskell to compile is the worst
15:01:38 <dancor> i don't do one-per, but i usually split them so it's a few similar ones per module
15:01:43 <jethr0> dancor: mine definitely aren't cool. i just had a problem with a type that had two type parameters and was wrapping a "Map". and derive had problems figuring out the "Ord" constraint on my first parameter. but i've worked around it now (by adding the Ord constraint onto the auto-derived instance)
15:02:38 <kyagrd> Lemmih: Thanks, I have a plan migrate my personal wiki homepage based on some php wiki enging into gitit one day, so just searching for technical details.
15:03:21 <jethr0> *argh*, which joker forgot "hPutStrLn" in "Data.ByteString.Lazy"  *knocks his head into table*
15:04:33 <dancor> maybe there is some way that converting to strict is essential to doing that?
15:05:13 <dancor> actually you have to go thru String anyway to do that conversion don't you?
15:05:19 <dancor> so nm
15:06:00 <jethr0> getting "binary-strict" now...
15:06:55 <dancor> ya i never understood the binary-using-internal-bytestring debacle
15:07:37 <jethr0> what's the debacle, ByteStrings are pretty cool.
15:07:56 <dancor> binary uses some internal interface to bytestrings
15:08:09 <dancor> which leads to issues like your current one i believe
15:08:45 <jethr0> not sure, i'll muddle my way through it ;)
15:10:20 <roconnor> @oesis 3,5,9,17,33
15:10:21 <lambdabot>  2^n + 1.
15:10:21 <lambdabot>  [2,3,5,9,17,33,65,129,257,513,1025,2049,4097,8193,16385,32769,65537,131073,2...
15:10:32 <roconnor> ah duh
15:13:47 <holmak> @djinn (a -> b) -> m a -> m b
15:13:47 <lambdabot> -- f cannot be realized.
15:15:26 <etpace_> how does that work lambdabot?
15:15:29 <etpace_> or, roconnor even
15:16:07 <poe> ?go online encyclopedia of integer sequences
15:16:08 <lambdabot> http://www.research.att.com/~njas/sequences/
15:16:08 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
15:16:18 <jethr0> what's the best way to convert a lazy bytestring into a strict one?
15:16:21 <c_wraith> so it's just a lookup? :)
15:17:44 <lispy> jethr0: there is a function for it IIRC.  Conceptually, a lazy byte string is just a list of strict ones
15:18:10 <lispy> jethr0: so you could also change the chunk size of the lazy one to be the size of the full lazy bytestring
15:18:15 <jethr0> hmm
15:18:59 <jethr0> toChunks: O(n) Convert a lazy ByteString into a list of strict ByteString
15:19:11 <jethr0> and now i want to join them again ;)
15:19:30 <lispy> there should be a function for that as well :)
15:19:33 <lispy> ?hoogle concat
15:19:33 <lambdabot> Prelude concat :: [[a]] -> [a]
15:19:33 <lambdabot> Data.ByteString concat :: [ByteString] -> ByteString
15:19:33 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
15:19:39 <c_wraith> @oeis 1,6,21,107
15:19:40 <lambdabot>  Busy Beaver problem: maximal number of steps that an n-state Turing machine ...
15:19:40 <lambdabot>  [1,6,21,107]
15:20:02 <c_wraith> I like that those 4 values are all the ones known. :)
15:20:12 <jethr0> who'd have thought
15:20:21 <dmwit> I think the next one has some hideously large lower bound proven.
15:20:52 <c_wraith> The next two do, actually.
15:21:01 <kmc> @oeis 1,1,1,1,1,1,1,1
15:21:02 <lambdabot>  The simplest sequence of positive numbers: the all 1's sequence.
15:21:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:21:18 <monoidal> is it possible to write a function f :: () -> () -> () such that f () _ = (), f _ () = (), f bot bot = bot?
15:21:24 <sclv> so i've got a type family issue.
15:21:25 <sclv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8973
15:21:30 <dmwit> monoidal: no
15:21:45 <xci> @oeis 1,2,3,6,11,20
15:21:45 <monoidal> what's the reason?
15:21:45 <lambdabot>  Triangular array T read by rows: T(n,0)=T(n,2n)=1 for n >= 0, T(n,1)=0 for n...
15:21:45 <lambdabot>  [1,1,0,1,1,0,1,2,1,1,0,1,2,3,4,1,1,0,1,2,3,6,9,8,1,1,0,1,2,3,6,11,18,23,18,1...
15:21:48 <sclv> the function works without a type signature, but the inferred type signature breaks.
15:21:59 <jethr0> why is that simpler than "twos = 2:twos"?
15:22:09 <sclv> for the same reason, the function can't be used as a drop-in default for func3 even though it obviously should be able to.
15:22:09 <dmwit> monoidal: As an artifact of Haskell's semantics, you must evaluate either the first argument or the second one first.
15:22:15 <c_wraith> because one is S0, but two is SS0
15:22:25 <kmc> is there not some flavor of par which returns when either side is whnf?
15:22:34 <sclv> looking for advice as to whether this is a real bug
15:22:38 <monoidal> so it is not possible to dovetail e.g. compute first argument for 1 second, then second for 2 seconds and so on?
15:22:43 <dmwit> There's unamb, but it use unsafe* functions.
15:23:02 <dmwit> monoidal: Not in Real Haskell, no.
15:23:10 <sclv> or if there's some "type families aren't injective" whatnot reason why this eminently sane thing shouldn't work.
15:23:11 <jmcarthur_work> monoidal, you want either unamb or lub, both are on hackage
15:23:11 <jli> I'm not sure I understand the difference between foldl and foldl'. is it that, when a foldl needs to be evaluated, it first builds a big thunk and then computes the value? as opposed to foldl', which deals with the accumulator strictly?
15:23:17 <monoidal> thanks, I'll check that
15:23:20 <c_wraith> Also, the number SS0 appears in my tattoo quite a lot. :)
15:23:23 <jmcarthur_work> monoidal, but yeah, those are black magic
15:24:21 <jmcarthur_work> monoidal, lub is especially neat:   (undefined, 5) `lub` ("foo", undefined) == ("foo", 5)
15:24:50 <kmc> @src foldl'
15:24:50 <lambdabot> foldl' f a []     = a
15:24:51 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:25:31 <kmc> forcing a foldl' will force the accumulator before folding any further
15:27:05 <jli> kmc: okay. whereas foldl is able to lazily build the accumulator expression before forcing the whole thing at the end?
15:27:17 <sclv> i guess icfp has taken all our type family experts off line for the time being?
15:27:30 <sclv> blah
15:27:35 <kmc> @src foldl
15:27:35 <lambdabot> foldl f z []     = z
15:27:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:28:42 <endojelly> the documentation to graphviz is not that good...
15:29:16 <kmc> so they're both basically tail recursive, so you can think of them as loops
15:29:31 <kmc> forcing the foldl' loop forces its accumulator at every "iteration"
15:31:14 <jli> kmc: got it. thanks
15:49:13 <defun> I see that most low-level, "systems" languages are procedural (i.e. C). Are there any other bit-twiddling languages, that are /not/ procedural? Or is this an inherent property for bit-twidling languages?
15:50:34 <sclv> ats
15:50:55 <sclv> forth
15:51:23 <sclv> arguably some compact schemes.
15:51:48 <roconnor> doesn't erlang have bitfields?
15:51:53 <defun> hmm. I will check out ATS. I read about FORTH, but didn't understand it. Is it like an assembly? Or am I totaly off?
15:52:03 <Berengal> What's a bit-twiddling language anyway?
15:52:04 <sclv> forth is nothing like assembly
15:52:18 <defun> sclv: sorry.
15:52:57 <defun> Berengal: languages with manual memory management, basically. Also, languages that are close the hardware.
15:53:02 <sclv> it does give insanely low level control however.
15:53:37 <defun> sclv: my friend says forth has the potential to be faster than C.
15:53:58 <sclv> basic forth doesn't have higher order functions though, as i recall, although other stack-like languages which are higher-level do.
15:54:05 <defun> sclv: though he couldn't quite explain why. Something about "words".
15:54:35 <exaltation> sure forth can do higher order
15:54:45 <exaltation> you can pass addresses of words around
15:55:00 <defun> like pointers?
15:56:31 <sclv> defun: my weak understanding of forth being v. efficient has to do with the fact that you're managing your stack explicitly and there's hence virtually no runtime.
15:56:52 <defun> sounds unsafe...
15:57:17 <sclv> only if you use it unsafely (but that's what low level languages are all about, hey)
15:57:38 <sclv> except of course ats which provides powerful guarantees by having a very fancy type system
15:57:55 <defun> sclv: oooh. I like type systems.
15:57:59 <Twey> http://bitc-lang.org/
15:58:13 <exaltation> defun: forth is extremely unsafe
15:58:18 <Twey> FORTH is very unsafe
15:58:20 <exaltation> ...for your brain
15:58:27 <Twey> But quite simple to keep safe, IME
15:58:44 <jmcarthur_work> yeah, very simple rules are enough to keep forth safe, afaik
15:59:18 <defun> Twey: bitc looks interesting. Like a C and ML hybrid.
15:59:23 <Twey> Yeah.
15:59:30 <pikhq> That is the idea, yes.
15:59:43 <jmcarthur_work> cyclone was cool while it lasted, too
15:59:44 <defun> Twey: too bad it never took off :(
15:59:53 <jmcarthur_work> or was it bitc that died, not cyclone?
15:59:54 <sclv> i think bitc is no longer under development as i recall
15:59:55 <jmcarthur_work> one of them did
15:59:57 <Twey> defun: What, BitC?
16:00:01 <Twey> Really?
16:00:02 <sclv> both did, i think
16:00:04 <Twey> That's a shame
16:00:08 <jmcarthur_work> oh :(
16:00:22 <defun> Twey: my understanding is that the main Dev abandoned it to work for MS.
16:00:24 <Twey> There's an update dated January 2009
16:00:33 <Twey> Ow.
16:00:36 <sclv> such is the fate of fledgeling research languages
16:00:49 <jmcarthur_work> i think he went to work on singularity or something, right?
16:00:53 <Twey> But it's a *good* fledgeling research language.
16:00:54 <defun> yeah
16:01:01 <jmcarthur_work> singularity has potential
16:01:12 <defun> it's now called midori or something.
16:01:31 <jmcarthur_work> i think midori is just the code name for a bigger scope project they have which uses singularity or something
16:01:39 <c_wraith> green?
16:01:41 <defun> ah
16:01:47 <Twey> Midori is a browser :<
16:01:52 <Twey> Damn name-stealers
16:02:02 <Twey> Call it Midori-Iro or something
16:02:08 <Twey> Or Ao.
16:02:14 <c_wraith> Midori is alcohol.  quit stealing booze names for software!
16:02:33 <jmcarthur_work> i think that software will share names is inevitable
16:02:57 <Twey> c_wraith: Nah, nah, that's covered by the sector overlap clause of copyright law, I think.
16:03:25 <c_wraith> Twey: it is.  I wasn't talking about legal issues, though.  Just keeping things straight when drunk.  :)
16:03:38 <Twey> Hahaha.
16:04:45 <jethr0> can someone help me with lazy bytestrings?
16:05:06 <lispy> jethr0: maybe, what seems to be the problem?
16:05:16 <jethr0> hehe
16:06:06 <jethr0> i am writing bytestrings over a tcp network socket. the data comes from Data.Binary and as far as I understand it, Data.Binary is quite capable of determining the end of the input it requires.
16:06:50 <jethr0> now my reading of the socket is done iteratively, so that hGetContents doesn't seem like such a good idea (unless I do hGetContents once at the beginning and read from it for a long time).
16:07:13 <jethr0> In the past, I've encountered flaky behavior with long-time use of a hGetContents string from a socket
16:07:41 <lispy> I'll be honest, that I have yet to try this kind of stuff in Haskell :)
16:08:16 <jethr0> me too. can be a bit aggravating though, like anything new and a bit stretching one's abilities
16:08:20 <lispy> So you're streaming some binary data, how big are the values that Data.Binary will return?
16:08:45 <lispy> Yeah, can you break this into smaller pieces that you can get working independently?
16:09:05 <BMeph> If you're doing things iteratively (except with Iteratees), "UR DOIN IT RONG". Or not... ;)
16:09:46 <jethr0> BMeph: nono, not iteratively in that sense. it's more like "loop = do step1; step2; read from socket/channel; step3; loop"
16:10:11 <BMeph> jethr0: That's EXACTLY the sort of thing I mean. :(
16:10:26 <jmcarthur_work> yeah that's not very functional
16:10:34 <jethr0> i find that a very broad statement, given that you don't know what kind of application i'm writing
16:10:52 <jmcarthur_work> explicit recursion is almost always something you want to avoid
16:11:02 <jethr0> BMeph: sure, i could be doing it "reactive"ly, but that almost made me insane the last time i tried
16:11:17 <mauke> correctness > elegance
16:11:25 <jethr0> what is this? good-advice-day?
16:11:46 <BMeph> jethr0: You're welcome! ;)
16:12:09 <mike-burns> Working > elegance.
16:12:11 <mike-burns> Just sayin'.
16:12:43 <jethr0> point 1: i have a game loop from SDL/GLUT/OpenGL that I cannot do much about. point 2: i have a network connection simultaneously to displaying graphics
16:13:12 <jethr0> as i said, reactive would be nice, but your advice seems applied a bit broadly for my taste!
16:13:32 <lispy> iteratees might be right here, but I agree that working/correct > elegant here.  Let's get this solved, then solve it better.
16:14:02 <lispy> jethr0: is this code private or shareable?
16:14:11 <lispy> jethr0: haskell-cafe is amazing for getting good help
16:14:15 <jethr0> how do iteratees even apply here? could you say sth. about iteratees?
16:14:42 <jethr0> lispy: thx, this channel is great too. the code is shareable albeit quite large for my standards.
16:14:59 <jmcarthur_work> iteratees abstract iteration, basically ^_^
16:15:03 <roconnor> @seen chessguy
16:15:03 <lambdabot> I saw chessguy leaving #rosettacode, #haskell-in-depth, #haskell-overflow, #novalang and #haskell 2h 29m 11s ago, and .
16:15:18 <jethr0> 1500 lines
16:15:28 <mauke> preflex: seen chessguy
16:15:28 <preflex>  chessguy was last seen on #haskell 2 hours, 38 minutes and 14 seconds ago, saying: ....
16:15:29 <jmcarthur_work> iteratees are not the simplest things in the world though, at least not yet
16:15:34 <jmcarthur_work> imo
16:16:11 <roconnor> @type foldr
16:16:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:16:16 <roconnor> @type foldr ($)
16:16:17 <lambdabot> forall b. b -> [b -> b] -> b
16:17:24 <lispy> jethr0: iteratees give you a way to stream data plus out of bound messages for terminating/continuing
16:17:44 <lispy> jethr0: it's an oleg-ism
16:18:01 <lispy> jethr0: the biggest critisim is that they are not fully composable
16:18:18 <jethr0> ah, cool thing. yes, i've glanced at the "fast left-fold IO" and "fast web-server with left-fold IO" articles, but haven't looked into it any further
16:18:29 <lispy> jethr0: http://okmij.org/ftp/Streams.html#iteratee
16:18:43 <jethr0> sounds like a very cool thing. is there any short example/tutorial content around?
16:18:52 <lispy> not that I'm aware of
16:19:01 <defun> ATS looks really good for a systems language.
16:19:16 <defun> just throwing it out there
16:19:18 <jethr0> fast too, but not completely free, right?
16:19:28 <lispy> jethr0: but I would love to be wrong.  If I had more round tuits, I would write a tutorial on them to teach myself how to use them.
16:19:32 <defun> didn't check the license
16:19:49 <Nafai> lispy: I think we are all missing some round tuits :(
16:20:20 <jethr0> nope, gpl3.
16:20:29 <defun> sweet
16:20:49 <jethr0> but when i looked at it last time it was lacking sth. probably was libraries. seemed like a very cool language more in the direction of dependable types though!
16:20:58 <jethr0> round tuits?
16:21:14 <mauke> he'll do it when he gets a round tuit
16:21:35 <jethr0> ah
16:24:27 <lispy> jethr0: there is also bounded chan on hackage, but that's probably not what you need
16:24:32 <kmc> @src zipWithM_
16:24:33 <lambdabot> zipWithM_ f xs ys = sequence_ (zipWith f xs ys)
16:25:02 <lispy> :t sequence_
16:25:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
16:25:12 <lispy> ?src sequence_
16:25:12 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
16:25:13 <kmc> @src zipWithM
16:25:13 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
16:25:47 <lispy> I guess return (), is the mzero of  m ()
16:25:54 <kmc> :t \f xs ys zs -> sequence_ (zipWith3 f xs ys zs)
16:25:56 <lambdabot> forall a b c (m :: * -> *) a1. (Monad m) => (a -> b -> c -> m a1) -> [a] -> [b] -> [c] -> m ()
16:28:26 <sclv_> i also wonder if the latest ghc fixes the hGetContents issue
16:28:36 <sclv_> (not that i heart lazy io over sockets or anything)
16:29:52 <lispy> lazy io is a bad idea in production code
16:30:01 <lispy> It always seems to come back to haunt  you
16:30:21 <lispy> it's great for project euler or just 1 one off haskell script though
16:30:23 <Berengal> There's a reason lazyness demands purity
16:30:32 <Heffalump> we need to learn how to make it work, not just dismiss it out of hand, IMO
16:30:39 <Berengal> Works nicely for filters though...
16:30:44 <exaltation> Berengal: that sounds a lot like "misery loves company"
16:31:04 <sclv_> the easy way to do it for binary over sockets, assuming you can write your own protocol, is just to write yr own length-prefixed protocol.
16:31:34 <sclv_> then you can read the appropriate amount from the socket explicitly, and parse it as a second step.
16:31:40 <endojelly> @hoogle (Ord a) => m a -> a
16:31:40 <lambdabot> Data.Foldable maximum :: (Foldable t, Ord a) => t a -> a
16:31:40 <lambdabot> Data.Foldable minimum :: (Foldable t, Ord a) => t a -> a
16:31:40 <lambdabot> Prelude maximum :: Ord a => [a] -> a
16:31:48 <Berengal> exaltation, last i checked, misery wanted to be left alone, he didn't want to talk to me I couldn't understand what it's like
16:31:58 <exaltation> :(
16:33:32 <lispy> jethr0: http://okmij.org/ftp/Haskell/Iteratee/Lazy-vs-correct.txt
16:33:37 <lispy> jethr0: that's a pretty simple example
16:44:20 <jethr0> do you know how thx
16:44:29 <jethr0> s/.*/thx/
16:47:20 <Berengal> I know how bbq
16:48:04 <Heffalump> anyone know how to put a kind signature on an empty data decl?
16:49:17 <jethr0> you guys rock!
16:55:30 <aavogt> @seen exalt
16:55:30 <lambdabot> exalt has changed nick to orgasm.
16:55:30 <lambdabot> orgasm is in #haskell. I last heard orgasm speak 23m 33s ago.
16:59:20 <Axman6> heh
16:59:45 <jfoutz> @seen you
16:59:45 <lambdabot> I haven't seen you.
16:59:53 * jfoutz waves at lambdabot
17:00:41 <lpjhjdh> so I'm writing a compiler in haskell and I was told about a method of creating temporary variable using some "New" construct and then a lift operator that figures out what name to give to the "New"s, is there some writing on this or something?
17:01:37 <Saizan> mmh, something like MonadPrompt?
17:01:57 <lpjhjdh> right now I just have a ScopedIdent node in my ast but I'm not sure what lift would look like
17:11:22 <psal> @search generate
17:11:22 <lambdabot> Unknown command, try @list
17:11:35 <psal> @hoogle generate
17:11:36 <lambdabot> Test.QuickCheck generate :: Int -> StdGen -> Gen a -> a
17:13:23 <jethr0> lpjhjdh: sounds remotely like Template Haskell to me
17:14:07 <jethr0> http://web.archive.org/web/20061011050035/http://www.haskell.org/hawiki/TemplateHaskellTutorial
17:17:18 <lpjhjdh> jethr0: hmm, I think it could be done without any metaprogramming, not sure, unfortunate I can't provide a more accurate description
17:17:36 <jfoutz> GADT maybe?
17:17:53 <psal> hmm imported Test.QuickCheck but no generate in scope, looks like hoogle is reporting from an old version of QuickCheck
17:18:00 <jethr0> yes, there was also something in this direction with something like SYB. you remember anything else about i?
17:18:01 <lpjhjdh> jfoutz: and encode the name in the type somehow?
17:18:02 <jethr0> it?
17:18:06 <jfoutz> there's parser example at the wiki... but each node would be its own type.
17:18:49 <jethr0> lpjhjdh: or maybe your are referring to one of the new monads...
17:19:41 <lpjhjdh> I also don't want to carry around an extra argument cause I've expressed it using a general catamorphism
17:19:49 <jethr0> maybe MonadSupply or MonadUnique
17:20:18 <jethr0> http://www.haskell.org/haskellwiki/New_monads#MonadSupply
17:22:52 <endojelly> is there some (quite possibly GHC specific) way to get a String representation of a value of any type? specifically I'd like to get the name of a function
17:23:11 <lpjhjdh> jethr0: I'll take a look, thanks
17:23:39 <lament> endojelly: i don't think so, considering how unlikely it is that a function would have a name
17:23:43 <jethr0> endojelly: what should it return for "(\x ->x+2)"?
17:24:02 <endojelly> lament, it is very likely in my case
17:24:06 <endojelly> jethr0, I don't care 8)
17:24:17 <endojelly> "_lambda" or an empty string or maybe even a runtime error
17:25:27 <jethr0> hmm, i think lambdabot had some kind of show instance for functions. but it definitely didn't give you the name. not sure this is feasible.
17:25:46 <c_wraith> > id
17:25:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:25:47 <lambdabot>    arising from a use of `...
17:26:05 <c_wraith> > let f x = x in f
17:26:06 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
17:26:06 <lambdabot>    arising from a use of `...
17:26:12 <c_wraith> It used to...
17:26:12 <heatsink> > ("A":)
17:26:13 <lambdabot>   Overlapping instances for GHC.Show.Show
17:26:14 <lambdabot>                              ([[GHC...
17:26:21 <c_wraith> I don't remember what cases it would show them in
17:26:28 <lpjhjdh> can you do it with template haskell?
17:26:44 <heatsink> I think it would just show the function's type.
17:27:17 <c_wraith> > let f x = (x::Int) in f
17:27:18 <lambdabot>   Overlapping instances for GHC.Show.Show
17:27:19 <lambdabot>                              (GHC.T...
17:27:34 <endojelly> the reason I ask:
17:27:42 <jethr0> lpjhjdh: i'm not even sure the function's name survives it very fast into the compilation/interpretatins. with a lot of work you might do sth with. language.haskell.exts, but i doubt it.
17:27:47 <jethr0> what do you need this for?
17:27:47 <endojelly> I have a little file where I do a lot of "perform foo" where foo is a function.
17:28:01 <endojelly> perform logs what the function does (it's all in a writer monad)
17:28:09 <endojelly> and I'd like to log the name of the function, too
17:28:17 <endojelly> of course I could do something like perform "foo" foo
17:28:26 <endojelly> but if ghc can do it for me...
17:29:04 <jethr0> this, you could do something about with template haskell. but i doubt it would merit the effort
17:29:25 <endojelly> yeah, that's not worth it.
17:29:32 <endojelly> guess I'll have to specify the strings myself
17:29:50 <endojelly> maybe define a lot of (description, function) tuples
17:29:54 <jethr0> poor you ;)
17:30:10 <c_wraith> TH might be easier. :)
17:30:43 <endojelly> it's okay, right now it's just... 7 operations
17:31:43 <sclv_> ?go scrap your nameplate
17:31:45 <lambdabot> http://homepages.inf.ed.ac.uk/jcheney/publications/cheney05icfp.pdf
17:31:45 <lambdabot> Title: Scrap your Nameplate
17:34:22 <endojelly> just skimmed over the paper. while it doesn't really look like what I need here, it looks like a solution to *another* problem I often had %)
17:34:26 <endojelly> namely the generation of names
17:34:32 <c_wraith> FreshLib?  That's an awesome name. :)
17:34:38 <endojelly> which for me always involves a pesky State monad and incrementing a counter within it
17:36:27 <dancor> is there an existing binding to select()?
17:36:54 <dancor> i heard there might be something in alt-network but i can only find dead links to that
17:41:14 <jethr0> not sure. googling "select site:hackage.haskell.org" yielded some results but most of them for array selection...
17:42:18 <dancor> http://hackage.haskell.org/package/epoll
17:42:19 <dancor> looks good
17:44:22 <jethr0> cool
17:44:34 <hackagebot> lenses 0.1.2 - Simple Functional Lenses (JobVranish)
17:45:05 <dancor> hopefully one day haskell' will have crossplatform file polling
17:45:33 <burp> @faq hsql or hdbc?
17:45:33 <lambdabot> The answer is: Yes! Haskell can do that.
17:46:09 <c_wraith> hdbc is a lot less magical.  That makes it more straighforward, but more clunky to work with.
17:46:21 <dancor> takusen is even more magical
17:46:58 <dancor> and good once you accept you will not be able to use type-sigs for some things
17:47:24 <burp> hm, I'll have a look at it
17:49:01 <dancor> i used it for recordGame/recordPosMove/getPosMoves in http://dzl.no-ip.org:81/gitweb/?p=copen.git;a=blob;f=src/Main.hs
17:50:57 <roconnor> What is the advantage of lenses over accessor?
17:51:10 <roconnor> hackagebot: What is the advantage of lenses over accessor?
17:53:52 <c_wraith> roconnor: Is hackagebot likely to answer that?
17:54:16 <roconnor> yes!
17:54:35 * roconnor is optimistic about our new bot overlords.
17:56:55 <jethr0> @faq can our new bot overlords answer roconnor's question, but deem it better not to?
17:56:55 <lambdabot> The answer is: Yes! Haskell can do that.
18:19:27 <Alpounet> > let t = [id, id :: [a] -> [a] ] :: [forall a. a -> a] in t
18:19:28 <lambdabot>   Couldn't match expected type `a1' against inferred type `[a]'
18:22:06 <dino-> I'm seeing a defaulting constraint warning for a function even though I'm using a type sig. Not sure how to make the warning go away.
18:22:11 <dino-> @paste
18:22:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:23:37 <dino-> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8976#a8976
18:24:00 <dino-> Can anyone help with what I should do to make that warning go away?
18:24:22 <dino-> Please don't say turn off warnings. :P
18:25:22 <ray> add a type signature? seems icky though
18:25:23 <dino-> Er, those to/fromOctets functions are from Codec.Utils
18:25:35 <dino-> I did add a type signature.
18:25:47 <ray> i mean to the subexpressions
18:25:48 <dino-> A different one?
18:25:50 <ray> which is why i said icky
18:25:57 <dino-> mm, I did a bunch of that and it didn't change anything.
18:27:52 <aavogt> dino-: the litteral 10 are defaulting to Integer... you still get warnings when you write them as  (10::Integer)?
18:28:10 <ray> both of those functions have two Integral constraints
18:28:13 <aavogt> @hoogle toOctets
18:28:14 <lambdabot> No results found
18:28:30 <ray> aavogt: http://www.haskell.org/crypto/doc/html/Codec-Utils.html
18:28:31 <dino-> aavogt: Nope, that was it.
18:28:49 <ray> not very pretty
18:28:50 <dino-> I was typeing wider stuff inside the function and apparently didn't get serious enough.
18:28:59 <dino-> Nope, not very.
18:29:07 <ray> sometimes you have to choose between pretty and passing -Wall
18:29:19 <ray> they both have their attractions
18:29:39 <dino-> ya. Thank you guys.
18:30:39 <dino-> Makes perfect sense now too because those functions are all Integrals, even the base (10 here).
18:30:50 <aavogt> perhaps prettier is to let ten = 10::Integer in ...
18:31:18 <dino-> I think so, yes, reuse it and have the type once.
18:32:46 <hackagebot> vty 4.0.0 - A simple terminal access library (CoreyOConnor)
18:33:38 <Cale> http://soranokakera.blog.eonet.jp/photos/uncategorized/2008/07/17/bou_2.png -- ehehe
18:34:31 <Makoryu> Cale: ÐÐ¾Ð»ÑÑÐ¾?
18:44:35 <roconnor> 4*(44*atan (1/57)-12*atan(1 / 682)+7*atan (1/239)+24*atan(1/12943)) :: CReal
18:44:37 <roconnor> > 4*(44*atan (1/57)-12*atan(1 / 682)+7*atan (1/239)+24*atan(1/12943)) :: CReal
18:44:39 <lambdabot>   3.1415926535897932384626433832795028841972
18:49:58 <andresj> hello, I am looking for a data type that represents a 2-dimensional matrix efficiently. I will not resize it very oftenâand quite often it will only be for initializing a new matrix. I will need to be able to `getWidth/Height myMatrix`, so the matrix must carry along size information with it. The purpose of this data type is to represent a computer screen ready to be painted onto (by modifying/creating a new modified canvas).
18:50:16 <andresj> any ideas as for Prelude data types, libraries, or just implementation ideas?
18:52:59 <Petrosian> Seems no one's going to reply unless I make an awful suggestion, that way someone can dive in and correct me
18:53:25 <Petrosian> The most awful thing I can think of is a tuple of tuples.
18:53:50 <jfoutz> heh.
18:53:56 <endojelly> dear god! 8)
18:54:13 <jfoutz> there's a'll sorts of ways to slice and dice lists. [[cell]] might not be bad
18:54:24 <endojelly> why not an array?
18:54:25 <Petrosian> Someone just needs to suggest list of lists now and we're making forward progress
18:54:28 <endojelly> a one-dimensional one
18:54:47 <endojelly> address with y*len+x
18:54:47 <Petrosian> Why not a two-dimensional one?
18:54:55 <jfoutz> or data Screen = S (Int,Int) (Map (Int,Int) Cell)
18:55:33 <endojelly> Petrosian, implementationwise, that may mean as many arrays as there are rows/columns (depending on which way you do it) and as many pointers pointing to them
18:55:42 <endojelly> while a 1-dimensional array is just a block of memory.
18:56:04 <dino-> jfoutz: oo, I like that one
18:56:26 <Petrosian> endojelly: Well, I really meant an array indexed by a tuple
18:56:32 <Petrosian> (x,y) to be precise
18:56:36 <endojelly> Petrosian, *that's* cool.
18:56:57 <kmc> i don't get it
18:57:57 <endojelly> kmc, the joke is that the priest can't marry because he's catholic, so he has no wife to begin with. get it?
18:57:57 <andresj> jfoutz: that actually sounds pretty goodâalthough I don't see the difference between a map and an array in that case
18:58:21 <kmc> andresj, there are various sorts of arrays in Data.Array
18:59:10 <jfoutz> hmm. i'd never looked at Ix before. that's cool.
18:59:37 <jfoutz> you could just instance your coord tuple, and use it to index into the one big array.
18:59:40 <endojelly> andresj, are you cool with staying in an ST monad while doing your stuff?
18:59:52 <endojelly> andresj, because there's the most efficient solution
19:01:10 <kmc> andresj, the major decisions to make are: lazy vs. strict, boxed vs. unboxed, immutable vs. mutable
19:01:25 <kmc> also for immutable, DiffArray versus regular, and for mutable, which monad to use
19:01:51 <andresj> endojelly: I do wonder about staying in a monad... I want to be able to say: f x = x ^ 2; graphRealFunction f canvas = let domain = [0..(getWidth canvas)] in { map someFunc domain, etc. }
19:02:24 <kmc> andresj, do you know how the ST monad works?
19:03:00 <andresj> kmc: not really, although I do remember seeing an introduction to how to represent state in Haskell in real world haskell
19:03:35 <endojelly> andresj, you can do that. the more important thing is: that array will be mutable. so, if you need previous states of it, it's bad
19:03:45 <andresj> aaaah
19:04:31 <andresj> endojelly: i cant picture a scenario where I'd need a previous state
19:04:48 <kmc> ST has mutable reference cells like IO does.  the difference is (a) it doesn't do actual input/output, and (b) you can get values back out of the ST monad
19:04:49 <andresj> i guess its off to learn ST monad and Array! :P
19:05:01 <kmc> andresj, also look at DiffArray
19:05:13 <jfoutz> DiffArray is neato.
19:05:20 <jfoutz> just saw that this week.
19:05:28 <andresj> hahaha
19:05:52 <jfoutz> no, really. it's a mutable array that saves the old state.
19:06:05 <endojelly> andresj, then staying in ST while mutating your canvas is an option! now, if you need efficiency, go for it. otherwise you don't need it
19:06:08 <andresj> oh really... that actually does seem interesting.
19:06:20 <andresj> endojelly: well, I really hope for effiency :P
19:06:34 <jfoutz> updates and reads of the newest stuff are fast. looking up old data makes you walk down a linked list. it's cool.
19:06:59 <jfoutz> at least, that's how i imagine it's implemented. didn't check the source.
19:07:10 <andresj> endojelly: i guess using a Map for the time being would be a good idea; and then optimize it with an STArrayâoptimize last
19:07:42 <kmc> the problem is that whether your program has monadic style is something you don't want to change later
19:07:55 <kmc> (which seems to be a weakness of haskell)
19:08:02 <andresj> kmc, it does, actually
19:08:03 <jethr0> wasn't there a tool to visualize the executing time profiling log?
19:08:12 <andresj> but i wonder how would that be fixed...
19:08:30 <andresj> well thank you very much guys (and girls? who knows; i usually say people lately); I should be leaving now. I'll be checking those libraries out; later!
19:08:43 <kmc> andresj, lambdabot is female
19:08:44 <endojelly> have fun
19:09:06 <andresj> well thank you, lambdabot, for your female assistance :P
19:09:15 <andresj> > "You're welcome."
19:09:16 <lambdabot>   "You're welcome."
19:09:24 <kmc> > "Kill all humans"
19:09:25 <lambdabot>   "Kill all humans"
19:09:52 <Gracenotes> even more convincing:
19:09:58 <ray> > text "Stop putting words in my mouth"
19:09:59 <lambdabot>   Stop putting words in my mouth
19:10:05 <jfoutz> @vixen
19:10:06 <lambdabot> Bollox!
19:10:09 <Gracenotes> indeed. sans quotes.
19:10:15 <Gracenotes> @vixen Visual Basic
19:10:15 <lambdabot> Can you really catch syphilis from Visual Basic?
19:10:38 <Gracenotes> oh, lilypond is still running ;( granted, the ly file was automatically translated from a 13-minute MIDI
19:10:44 <jethr0> @faq can haskell really give you STDs?
19:10:45 <lambdabot> The answer is: Yes! Haskell can do that.
19:11:07 <ray> > text "mueval-core: Prelude.read: no parse"
19:11:09 <lambdabot>   mueval-core: Prelude.read: no parse
19:12:01 <dancor> @faq can haskell make it hard to figure out where the code is for the toWord32 used in epoll's Base.hsc?
19:12:01 <lambdabot> The answer is: Yes! Haskell can do that.
19:12:34 <jfoutz> to be fair,
19:12:55 <jfoutz> @fac can haskell make it easy to figure out where the code is for the toWord32 used in epoll's Base.hsc?
19:12:56 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
19:12:59 <Gracenotes> this is hurting my browser
19:13:11 <jfoutz> faq even.
19:13:14 * jfoutz sighs
19:13:38 <dancor> i found it!  it wasn't easy tho
19:13:39 <ray> @faq can haskell beat ocaml in a cage match to the death?
19:13:39 <lambdabot> The answer is: Yes! Haskell can do that.
19:16:45 <Makoryu> <Haskell> RRAAAAGGGHH <OCaml> HRRRRUUUUUUUUDUHGHGH <Haskell> BRING IT OOONNNNNNN
19:16:45 <Gracenotes> okay.. so lilypond is using 300 MiB of mah RAM
19:17:13 <Gracenotes> I wonder where the bottleneck is. if anywhere.
19:17:28 <ray> more like <haskell> ATATATATATATATATATATATATATATATATATATATATATATATATATATATATATA
19:17:50 <Adamant> Haskell is the complete fighter
19:18:01 <Gracenotes> okay, so the input file is 6987 lines
19:18:02 <Adamant> of programming languages
19:18:32 <jfoutz> , 1+1
19:18:33 <lunabot>  2
19:18:47 <jfoutz> text ", 1+1"
19:18:53 <jfoutz> > text ", 1+1"
19:18:54 <Gracenotes> ray: or rather <haskell> SKSKSKSKSKSKSKSKSKSKSKSKSKSKSKSKSKSKSK
19:18:54 <lambdabot>   , 1+1
19:19:10 <jfoutz> ah. that's fine then.
19:19:10 <dancor> is there a way to load a .hsc file into ghci so that you can do :info on a function it imports from somewhere?
19:19:16 <ujihisa> , [1..]
19:19:17 <lunabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:19:25 <ray> when haskell fights you, you are already dead
19:19:32 <ray> that's how it maintains referential transparency
19:19:41 <kmc> :t ord
19:19:43 <lambdabot> Char -> Int
19:20:05 <KevinFish> why would anyone use haskell when there is..... COBOL!?!?
19:20:40 <ray> because cobol's easy to understand english syntax doesn't let us seem clever
19:20:53 <KevinFish> ahhh, that must b it!
19:21:21 <Makoryu> PERFORM VARYING INNER-LOOP-INDEX FROM 0 TO OVER-9000 DISPLAY "COBOL IS SUPERIOR" END-PERFORM
19:21:23 <ujihisa> , let f x = f x in f 1
19:21:29 <lunabot>  Killed.
19:21:47 <piroko> , cycle "LOL "
19:21:48 <lunabot>  "LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL LOL ...
19:21:51 <piroko> Buahaha
19:22:15 <Gracenotes> cobol might be English, but it's not how normal humans phrase things
19:22:43 <Gracenotes> dot notation got closer to natural-speak
19:22:53 <jfoutz> , "stuff"
19:22:54 <lunabot>  "stuff"
19:23:03 <ujihisa> , cycle 'L':'O':[]
19:23:03 <jfoutz> , text "stuff"
19:23:04 <lunabot>  luna: Couldn't match expected type `[a]'
19:23:05 <lunabot>  stuff
19:23:15 <ujihisa> , cycle$'L':'O':[]
19:23:17 <lunabot>  "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
19:23:18 <SamB_XP> Gracenotes: especially nowadays when people might use it in english ;-)
19:23:29 <jethr0> OPEN-FILE "file" BINDTO GET-FILE-CONTENTS BINDTO PRINT-STRING
19:23:43 <Gracenotes> I wonder what programming languages written in other languages would be like, syntactically
19:23:45 <SamB_XP> like self.tired == True
19:23:53 <Gracenotes> well, we do know of one example. GRUNNUR.
19:24:13 <kmc> > map (chr.pred.ord) "ljmm!bmm!ivnbot"
19:24:14 <lambdabot>   "kill all humans"
19:24:53 <jethr0> Gracenotes: microsoft had the fabulous idea to translate VBA to german. and the end result is uber-annoying
19:25:19 <SamB_XP> jethr0: just german?
19:25:25 <kmc> http://code.google.com/p/zhpy/
19:25:42 <Gracenotes> and then, what about natural languages without whitespace. I hope that feature wouldn't be kept
19:25:49 <dancor> > pred False
19:25:50 <lambdabot>   * Exception: Prelude.Enum.Bool.pred: bad argument
19:25:52 <roconnor> > foldr id x [f,g,h]
19:25:53 <lambdabot>   f (g (h x))
19:25:55 <dancor> is there a cyclic pred
19:25:56 <Makoryu> > succ False
19:25:57 <lambdabot>   True
19:26:02 <jethr0> =WENN(ISTLEER(A25);"";A25&"=")&WENN(ISTFEHLER(SVERWEIS(A25;Analysen;34;FALSCH));
19:26:08 <jethr0> i guess into many, many langauges
19:26:13 <Gracenotes> dancor: not really. but you can hack something if it's bounded
19:26:32 <jethr0> and each one has only limited internet support, because all the function names are different *arg*
19:26:39 <lpjhjdh> is there a way to flip the parameters to a type so I can say something like: given Stmt e x, Fix (Stmt e), Functor (FlipStmt x)?
19:26:45 <Gracenotes> ...or just write out a pattern-matched based function, more tedious but best engineering-wise
19:26:54 <roconnor> lpjhjdh: not without a newtype wrapper :(
19:27:06 <Gracenotes> wheee fast university connection
19:27:13 <lpjhjdh> roconnor: Damn! Thanks.
19:27:43 <maciej`> hi all
19:28:08 <pantsd_pcf> I'm trying to use the regex-tdfa package, but when I include it I get "(.text+0x121): undefined reference to `__stginit_regexzmtdfazm1zi1zi2_TextziRegexziTDFA_'"
19:28:28 <Gracenotes> eek. compiler oddness.
19:28:38 <pantsd_pcf> I tried upgradeding to the latest ghc
19:28:39 <Gracenotes> linking or something..? *waits for ghc gurus*
19:28:51 <aavogt> pantsd_pcf: use the --make flag
19:29:10 <Gracenotes> that looks like one of GHC's internal names for something
19:29:16 <aavogt> or -package regex-tdfa  # or whatever its called
19:29:50 <pantsd_pcf> schweet
19:29:51 <pantsd_pcf> thanks :)
19:29:53 <maciej`> subtrees' _    (Leaf _) = [] <- could that line ever cause a divide by 0 exception? because that's what :trace is telling me
19:30:04 <Gracenotes> eh
19:30:07 <jethr0> hmm, now i've switched my program to a client/server architecture over TCP and it spends almost 50% of the time blocking, it seems. any ideas how to pinpoint the problem and fix it?
19:30:41 <jethr0> maciej`: i guess THAT line is unlikely to do that.
19:30:47 <SamB_XP> jethr0: that's a problem?
19:31:06 <maciej`> [
19:31:06 <maciej`> Stopped at <exception thrown>
19:31:06 <maciej`> _exception :: e = GHC.IOBase.ArithException GHC.IOBase.DivideByZero
19:31:09 <maciej`> [<exception thrown>] *Genetic> :back
19:31:12 <maciej`> Logged breakpoint at Genetic.hs:80:32-33
19:31:15 <maciej`> _result :: [Subtree]
19:31:16 <jethr0> SamB_XP: yes, because my game went from having 85 frames to 15 frames
19:31:18 <maciej`> [-1: Genetic.hs:80:32-33] *Genetic> :list
19:31:18 <maciej`> 79        subtrees' :: [Int] -> SyntaxTree -> [Subtree]
19:31:22 <maciej`> 80        subtrees' _    (Leaf _) = []
19:31:25 <maciej`> 81        subtrees' path t@(Branch _ _ children) = (Subtree t path) : recurse children
19:31:28 <maciej`>  
19:31:37 <jethr0> i wonder whether switching to UDP will fix this whole problem or what might be the issue here?
19:31:46 <SamB_XP> jethr0: ah
19:31:55 <Gracenotes> lilypond.. still running..
19:32:09 <SamB_XP> UDP could help, assuming you keep in mind what the U stands for ;-)
19:32:27 <maciej`> maybe i'm misreading it, but isn't ghci telling me that line 80 caused a div by 0 error?
19:33:03 <Gracenotes> maciej`: it could be that the thing constructing the tree caused a divide by zero error, which was only discovered when matching the Leaf constructor
19:33:11 <Gracenotes> ..just a theory. not familiar with trace
19:33:14 <jethr0> SamB_XP: any idea how to find out where the most time is spent blocking? profiling just isn't helping as much here (i guess because the blocking time is not accounted for)
19:33:16 <jfoutz> is there a less noobish, or less cut and pasty way of doing this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8981#a8981
19:33:25 <SamB_XP> maciej`: and you're running the latest varient?
19:33:34 <SamB_XP> jethr0: not really ...
19:33:45 <maciej`> i'm running ghc 6.8.2
19:33:53 <SamB_XP> maciej`: of your code, I meant
19:34:02 <SamB_XP> I mean, what you're running is actually what's in that file?
19:34:08 <Gracenotes> maciej`: at least check for any instance of div/mod/etc in your program :)
19:34:51 <lpjhjdh> jethr0: thanks for the help by the way, the answer to my earlier question lies in the pi calculus and syntactic theories of control and state.  I also am embarrassed to say it was nu, not new :p
19:35:10 <jethr0> jfoutz: you could use FYB or any of the other scrap-your-boilerplate tools to auto-generate much of the code i guess
19:35:15 <maciej`> yeah i am running the latest version of the code, just did a :load and got the same thing
19:35:57 <SamB_XP> maciej`: and that code ... is it interpreted or compiled?
19:36:10 <maciej`> interpreted
19:36:24 <jfoutz> jethr0: yeah. that might be worth thinking about. thanks.
19:36:41 <copumpkin> jfoutz: or considering that Row and Col are almost identical
19:36:43 <SamB_XP> maciej`: okay, I have no idea why the heck it's giving you such crazy info then!
19:36:54 <copumpkin> jfoutz: just make the same type with a phantom type parameter
19:37:04 <maciej`> SamB_XP: thanks, i'll keep looking
19:37:48 <SamB_XP> but yes, do try and think of any div/mod/quot/rem anywhere within a ten kilometer radius!
19:39:11 <maciej`> SamB_XP: doing that right now
19:40:10 <SamB_XP> maciej`: have you considered compiling for profiling and using -xc, btw?
19:40:19 <SamB_XP> that is, +RTS -xc
19:40:45 <maciej`> no, will it give me something like a stack trace?
19:41:31 <SamB_XP> very like!
19:41:39 <jfoutz> copumpkin: oh... that's pretty cool.
19:42:00 <copumpkin> jfoutz: not sure what you'd call it though :)
19:42:05 <SamB_XP> except it will actually tell you something informative, unlike a trace of the actual stack -)
19:42:24 <maciej`> SamB_XP: great idea, thanks
19:42:39 <jfoutz> copumpkin: well... i was sorta disturbed about generalizing to more dimensions, the phantom type thing would solve that.
19:45:02 <jfoutz> :re
19:51:10 <jethr0> i have the weird feeling that "Control.Network.Chan.isEmptyChan" is blocking. which would be rather counter-productive
19:53:37 <jethr0> ok, not a feeling anymore... any ideas how i can check non-blockingly whether there is something in a channel?
19:54:56 <jfoutz> System has a bunch of handle querys
19:56:02 <jethr0> for channels, handles or for sth else?
19:56:05 <jfoutz> hGetBufNonBlocking
19:56:20 <jfoutz> seems like there was a ready one....
19:56:24 * jfoutz looks
19:57:06 <jfoutz> hReady
19:57:10 <jfoutz> both for handles
19:57:20 <piroko> , :t yourMom
19:57:21 <lunabot>  luna: Not in scope: `yourMom'
19:57:23 <piroko> :(
19:57:23 <jethr0> yes, but i don't have a handle, i have a channel of objects
19:58:09 <jfoutz> oh. i should read more closely. i think there's operations like that on chan as well... one sec.
20:00:30 <jethr0> maybe i should take an MVar and use tryTakeMVar. weird that this operation doesn't exist for a channel. which after all is implemented on MVars
20:01:01 <jfoutz> i don't see how isEmptyChan could block... it looks in an mvar to see if the queue is empty
20:01:50 <maciej`> alright, I ran the thing with +RTS -xc and got this: ./genetic +RTS -xc
20:01:51 <maciej`> [
20:01:51 <maciej`> <GHC.Err.CAF>genetic: divide by zero
20:01:51 <maciej`>  
20:02:00 <maciej`> not too informative
20:02:04 <jethr0> well, it definetely blocks for me
20:02:27 <Cale> maciej`: Means that the division by zero occurs inside of a constant.
20:02:30 <jethr0> when i do an isEmptyChan on an empty channel it blocks. when i comment out that one line, it doesn't...
20:02:38 <Cale> Er, hmm...
20:03:14 <jethr0> well it could be a top-level declaration that is calculated based on his function using division, no?
20:03:19 <Cale> maciej`: Do you have any division in your code?
20:03:31 <jethr0> maybe i'll try synchronous-channels
20:03:42 <SamB_XP> maciej`: you may need to tweek the build to get more SCCs
20:03:45 <Cale> maciej`: It would help if I could see it.
20:03:51 <maciej`> in a few places. I was hoping +RTS -xc would show me which one is causing this
20:04:07 <SamB_XP> and I may need to learn to spell ;-)
20:07:59 <maciej`> ha, found it
20:08:25 <maciej`> it was in a function called "choose" I had in my utils module
20:08:38 <maciej`> any idea why ghc didn't give me a more useful trace though?
20:08:55 <Makoryu> > let (â ) = (/=) in "yo" â  "dawg"
20:08:56 <lambdabot>   True
20:09:37 <Makoryu> :t (â)
20:09:38 <lambdabot> Not in scope: `???'
20:09:57 <SamB_XP> maciej`: I guess you didn't have enough SCCs in your build
20:10:15 <defun> Can anybody enlighten what the new 'views' feature in ghc 6.10 is supposed to accomplish? An example would be nice.
20:10:40 <SamB_XP> defun: is there nothing in the manual?
20:11:04 <defun> SamB_XP: which manual?
20:11:12 <defun> I searched the wiki
20:11:13 <SamB_XP> defn: the GHC manual!
20:11:14 <defun> nothing
20:11:20 <maciej`> SamB_XP: what are SCCs?
20:11:23 <SamB_XP> @go GHC manual
20:11:24 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/
20:11:24 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.10.4
20:11:29 <defun> ah. thanks.
20:11:34 <SamB_XP> maciej`: you should look at the profiling section of the manual -)
20:13:18 <BMeph> What manual? <ducks>
20:13:37 * SamB_XP hits BMeph with http://www.haskell.org/ghc/docs/latest/html/users_guide/
20:13:54 * BMeph likes it!
20:13:55 <SamB_XP> and it's a long URL, so I can hit you even if you've ducked!
20:14:20 <jfoutz> copumpkin: so... uh... how do i make a recursive phantom type? I don't think i can, unless there's some magic i'm missing.
20:14:30 <BMeph> SamB_XP: Fair enough - next time, I'll finch instead! ;p
20:14:47 <SamB_XP> finch?
20:14:53 <SamB_XP> you mean filch?
20:15:20 <copumpkin> jfoutz: how do you mean?
20:15:54 <copumpkin> jfoutz: oh, you mean how do you alternate the phantom "tags"?
20:16:00 <copumpkin> between rows and columns?
20:16:16 <jfoutz> copumpkin: well, my row and column refer to each other... so if i convert to a phantom type how do i alternate?
20:17:23 <copumpkin> jfoutz: if you aren't opposed to extensions, there's a simple solution :)
20:17:31 <jfoutz> sure
20:17:59 <copumpkin> type family Other a :: *; type instance Other Col = Row; type instance Other Row = Col
20:18:28 <copumpkin> and then just use (Other a) whenever you need to flip it
20:18:53 <jfoutz> that, is fantastic. i've been trying to figure this out for 3 days..
20:19:04 <copumpkin> type functions are loads of fun
20:19:05 <jfoutz> that'll work.
20:19:22 <copumpkin> you'll need -XTypeFamilies
20:21:11 <Petrosian> defun: if you mean what I think you mean by "views" as in view patterns
20:21:40 <Petrosian> Patterns essentially compile down to case statements, views essentially allow you to apply functions before performing case analysis
20:22:37 <Petrosian> It's probably far more complicated and clever than that simple explanation, but that's my understanding at least.
20:26:57 <jfoutz> copumpkin: that, is really really cool. thank you.
20:27:07 <copumpkin> jfoutz: yay, my pleasure
20:45:10 <Rotaerk> I think functional programming may be contagious
20:45:15 <Rotaerk> somehow my roommate caught it
20:45:59 <Apocalisp> it's the plague that cures all ailments
20:46:54 <jfoutz> copumpkin: i have another question... but i think it's just syntax. instance Functor (Dim (Other a)) where ... dosn't seem to work, and if i introduce Row and Col into a class, instance (Ortho (Other a)) => Functor (Dim a) where
20:47:18 <copumpkin> oh that won't work, nope
20:47:36 <copumpkin> why do you need to mention them in the class?
20:47:38 <jfoutz> i know i'm up one level.
20:48:12 <jfoutz> um. i'm not sure i understand your question.
20:48:58 <copumpkin> instance Functor (Dim a) where
20:49:05 <copumpkin> what does it need to know about a?
20:49:21 <jfoutz> to instance functor, i was breaking out each case. one of the cases refers to the Other a
20:50:00 <jfoutz> hmm.
20:50:18 <copumpkin> oh, so your two instances are different?
20:50:32 <copumpkin> you can just do instance Functor (Dim Col)
20:51:04 <jfoutz> hmm. well i don't want them to be, but i get couldn't mach expencted type 'a' against inferred type 'b', which i assume is the flip
20:51:33 <jfoutz> uh. if i could spell, i would be dangerous.
20:51:35 <dancor> Bindings.Posix has pselect, and some of the arguments have type Fd_set.  but how do you marshall into the Fd_set type?
20:52:28 <copumpkin> whoops, hotel wifi is a little patchy
20:54:16 <jfoutz> maybe a new paste would make sense... one sec.
20:55:43 <jfoutz> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8981#a8982
20:56:26 <copumpkin> jfoutz: so what's the problem there?
20:57:00 <jfoutz>     Couldn't match expected type `a' against inferred type `a1'
20:57:23 <jfoutz> ugh. let me put that in hpaste
20:58:33 <jfoutz> ok. sorry. i thought i was being fairly clueful, but i was wrong.
20:59:27 <copumpkin> oh, hmm
20:59:59 <jfoutz> i thought i understood how they fliped, the explicit version makes sense... i thought the phantom type version would follow the same model.
21:00:15 <copumpkin> it's probably an issue with the fact that it can't invert the type function
21:00:24 <copumpkin> so it doesn't know something that feels obvious to us
21:00:28 <jfoutz> i'm pretty sure i know what i want to say, it just seems like i need some syntax to tell it about the flip.
21:01:18 <copumpkin> oh, hmm
21:01:21 <copumpkin> so
21:01:23 <jfoutz> the wiki talked aobut associated type instances... seemed close.
21:01:25 <copumpkin> :t fmap
21:01:25 <hackagebot> vty 4.0.0.1 - A simple terminal access library (CoreyOConnor)
21:01:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:01:50 <copumpkin> what would the type of fmap f (x :: Dim Col Int) ?
21:02:38 <copumpkin> or wait
21:02:48 <jfoutz> (Functor f) => f (Dim Col Int)
21:02:50 <jfoutz> ?
21:02:58 <copumpkin> you're putting the phantom type as the last type parameter?
21:03:14 <copumpkin>              | DNext (Dim a (Other a)) (Dim a p)
21:03:33 <jfoutz> yes.
21:04:02 <jfoutz> you can almost see the gears turn, can't you. i think i see what you're getting at
21:04:18 <copumpkin> so the Functor is operating on the phantom type?
21:04:25 <copumpkin> that seems odd
21:04:26 <jfoutz> yeah. *blush*
21:04:46 <copumpkin> I think you'd have better luck flipping it :)
21:04:48 <jfoutz> thanks again.
21:04:51 <jfoutz> :)
21:04:56 <copumpkin> np
21:10:29 <dolio> a isn't a phantom type.
21:11:17 <dolio> Oh wait, p is the phantom type?
21:12:03 <jfoutz> there were 2 problems. one, i needed to move the phantom type to the first ... kind arguent? (not sure if that's the right name) second, needed to make (Other .) refer to the phantom type.
21:12:34 <jfoutz> so now it's Dim p a, and all the data constructors agree, and i'm happy.
21:12:46 <dolio> Yeah, that makes more sense.
21:14:57 <jfoutz> i have another implementation where the typechecker dosn't enforce the alternating row/column split. this is so much better.
21:16:57 <jfoutz> and just a few type instances would handle X Y Z.
21:18:37 <Makoryu> Oh man
21:18:43 <Makoryu> Try this in OCaml: let foo = print_endline "Yo dawg"; 5;;
21:19:33 <erikc> wow, those power7 specs are awesome
21:20:11 <jmcarthur> Makoryu: ?
21:20:17 <jmcarthur> it does what i would expect it to do
21:20:50 <Makoryu> jmcarthur: The trick is, it only prints once (on assignment)
21:21:06 <jmcarthur> i mean, as a haskell programming i'm not a fan, but it's what i would expect from ocaml at least
21:21:21 <jmcarthur> *haskell programmer
21:22:15 <Berengal> int foo = Integer.valueOf(System.in.read()); only reads one character as well
21:22:51 <jmcarthur> ewwwww
21:23:00 <jmcarthur> you just put Java in here
21:23:10 <Makoryu> Java? In my #haskell?
21:23:12 <jmcarthur> i feel gross now
21:23:15 <Apocalisp> Berengal: What language is that?
21:23:23 <Berengal> Apocalisp, see above
21:23:32 <Apocalisp> never heard of it
21:23:37 <jmcarthur> i need to take a shower or something
21:23:45 <Makoryu> Apocalisp: You must live in bliss
21:23:47 <jfoutz> yo dawg
21:23:49 <jmcarthur> maybe gouge my eyes out
21:24:03 * Berengal takes a shower, then goes to work to do some java programming
21:24:30 <jmcarthur> heh, well i've been doing C++ programming all day, so there
21:25:11 <Berengal> jmcarthur, not sure which of them is most eww. C++ has less enterprise in it at least as far as I've gathered...
21:25:27 <jmcarthur> less enterprise but at least as much suck
21:26:05 <jfoutz> aw, come on. c++ is getting lambda!
21:26:15 <kmc> and type inference
21:26:15 <roconnor> Berengal: you need to take a shower after doing some java programming to wash off that imperative ick.
21:26:49 <jmcarthur> both of which are clearly tacked on to a system not originally designed for it
21:26:52 <Berengal> roconnor, I usually bathe myself in gasoline and set myself on fire after a day's work, but sometimes I shower after that as well
21:26:57 * roconnor reads back
21:26:59 <roconnor> ah crap
21:27:01 * jfoutz is glad he is not responsible for the c++ compiler.
21:27:28 <Berengal> @quote new.features
21:27:29 <lambdabot> dhjdhj says: All new features added to C++ are intended to fix previously new features added to C++
21:27:50 <SamB_XP> ... what about the *first* new feature added to C++?
21:27:57 <Berengal> Objects!
21:28:07 <jmcarthur> i think the quote still holds
21:28:09 * Berengal likes to pronounce them "abjects"
21:28:17 <jmcarthur> i object!
21:28:23 <jfoutz> #define class struct?
21:28:24 <SamB_XP> they could *not* have been intended to fix any previous new feature !
21:28:31 <SamB_XP> of C++
21:28:54 <lpjhjdh> they took out the most important addition... concepts
21:28:55 <jmcarthur> oh you are complaining about base case
21:29:01 <SamB_XP> yeah!
21:29:05 <Berengal> SamB_XP, they could, because it was called C with objects, so when it became C++ it already had new features
21:29:19 <SamB_XP> considering that C++ hasn't been around forever, I *am* complaining about the lack of a base case!
21:29:27 <jmcarthur> All new features added to C++ after the first are intended to fix previously new features added to C++
21:29:30 <kmc> the irony is, the people who think C++ *is* C with objects are the ones who write terrible C++ code
21:29:47 <SamB_XP> but C *has* objects
21:29:52 <Berengal> kmc, there are features to fix that
21:30:03 <c_wraith> I thought it was the template metaprogrammers who wrote terrible C++ code
21:30:03 <jmcarthur> if you squint your eyes
21:30:06 <jfoutz> bah. i can write horrible code in any language.
21:30:06 <SamB_XP> Berengal: yeah, I added a flamethrower
21:30:07 <Berengal> C has a bunch of bits bundled together
21:30:08 <kmc> objects are a (*shudder*) design pattern, you can make them in any language
21:30:10 <SamB_XP> it fixes that real fast
21:30:31 <SamB_XP> kmc: actually, I was talking about what *C* calls objets
21:30:34 <SamB_XP> er. objects.
21:30:35 <jmcarthur> i can make functional languages in any language, too
21:30:49 <SamB_XP> encluding trefunge?
21:30:52 <Berengal> jmcarthur, I dare you to do it in Java.
21:30:59 <SamB_XP> Berengal: it's easy in Java
21:31:02 <kmc> actually, first class functions are easy in Java
21:31:03 <jmcarthur> Berengal: it's pretty easy
21:31:09 <jmcarthur> i've done it
21:31:15 <SamB_XP> just very verbose
21:31:16 <Berengal> I mean, it's technically possible but you'll stand a better chance facing chtullu
21:31:38 <Stinger> do it in bf
21:31:41 <SamB_XP> better to use Scala, which actually has some syntax
21:31:44 <kmc> return new Object { public void f() { /* stuff */ } };
21:31:46 <kmc> isn't it like that basically
21:31:51 <jmcarthur> SamB_XP: i don't know about trefunge. maybe i should have just said it was possible, not that i specifically could do it ;)
21:31:52 <jfoutz> or intercal
21:31:57 <kmc> i don't remember if that closes properly over free variables
21:32:09 <SamB_XP> I'm not sure trefunge has been proven turing complete yet?
21:32:21 <jmcarthur> i don't even know much about it
21:32:24 <Berengal> kmc, first class functions aren't. Function objects are, but unfortunately anonymous classes carry a reference to the entire enclosing scope, so you can pretty much kiss memory reclamation goodbye
21:32:33 <kmc> C++1x's closures are true to C++ philosophy so we will have concepts like "closure by const volatile pointer"
21:32:44 <mun> hi
21:32:53 <jmcarthur> just looked esoteric, and i assumed it was turing complete or it would not have fit my implicit qualification
21:32:53 <jfoutz> kmc, no. but you can make member variables and assign them using whatever's in scope.
21:33:03 <kmc> okay, so they implement real closure but in a space-inefficient way
21:33:23 <mun> i'm trying to run make and install something, but i keep getting the error "/usr/bin/ld: cannot find -lgmp" does anyone know why?
21:33:26 <Berengal> They also only allow you to reference final variables
21:33:33 <kmc> mun, you are missing the libgmp library
21:33:39 <Berengal> Of the method they're created in anyway
21:33:46 <kmc> ugh
21:33:49 <Makoryu> mun: GMP is the library that powers Haskell's Integer type
21:33:53 <mun> kmc, hmm i see. how do I install it?
21:33:55 <Makoryu> (And some other things, I think)
21:34:03 <kmc> mun, what operating system / distribution?
21:34:12 <mun> kmc, i'm using Ubuntu
21:34:17 <Berengal> mun, also, what are you trying to install?
21:34:22 <c_wraith> apt-get install libgmp-dev
21:34:23 <SamB_XP> jfoutz: well, on the other hand, Coq isn't Turing complete, and you can do as much FP as you like in it
21:34:25 <kmc> mun, you have a package manager you like?
21:34:44 <mun> aah it's the dev package
21:34:48 <c_wraith> yes
21:34:48 <kmc> the ideal programming language is *not* Turing complete
21:34:49 <SamB_XP> that is, it's term language isn't turing complete
21:34:56 <SamB_XP> the tactics language probably is
21:34:58 * jfoutz grins
21:35:00 <kmc> the ideal language will only let you write correct programs, not all programs
21:35:15 <SamB_XP> kmc: well, you could still write wrong specifications though!
21:35:22 <c_wraith> What if I'm writing a simulator for incorrect programs?
21:35:24 <mun> thanks guys
21:35:30 <kmc> SamB, not in the ideal world :)
21:35:38 <SamB_XP> c_wraith: you can still model them...
21:39:12 --- mode: irc.freenode.net set +o ChanServ
21:39:57 <jfoutz> gotta say, monkey from the pants thing is a fantastic idea though.
21:40:39 <jfoutz> i'll try that at the next scrum stand up featuring information radiators.
21:41:52 <Berengal> Speaking of scrums, I have one to attend myself in a couple of hours...
21:42:01 * Berengal goes looking for the monkey
21:43:29 <jfoutz> @faq can haskell find the monkey?
21:43:30 <lambdabot> The answer is: Yes! Haskell can do that.
21:43:43 <dolio> That was quite a split.
21:43:59 <Berengal> s'windy on the net today
21:44:03 <dolio> It was just me, copumpkin and jedediah_ for a minute there.
21:47:12 <copumpkin> :o
21:54:47 <kmc> so the strength of haskell's static checking is undeniably a feature, but it also makes the moment when one's code first compiles all the more ominous
21:55:03 <kmc> because you know that all of the low-hanging bug fruit is gone, and probably one or two nasties remain
21:55:23 <jfoutz> bah. it's probably fine. ship it!
21:55:30 * Warrigal plays Also Sprach Zarathustra.
21:55:36 <kmc> fuck it, we'll do it live
21:56:36 <jfoutz> kmc yes. haskell makes me face up to the fact that i often don't know what i'm doing far more often than i'm really comfortable with.
21:56:41 <Warrigal> Do... so... do...
21:56:52 <Warrigal> MI RI!
21:57:02 * kmc throws bones into the air
21:57:23 <SamB_XP_> jfoutz: but evidently not often enough!
21:57:27 <Warrigal> (Or is it me instead of ri?)
21:57:39 <kmc> jfoutz, that's the beauty, in Java you could write 3 pages of code before you realize you haven't a clue what it should do
21:57:41 <SamB_XP_> we've got over 500 people in here, for pity's sake!
21:58:23 <kmc> that said if you are paid by the line it is not a good choice :)
21:58:26 <jfoutz> kmc, oh you have no idea. factories and visitor patterns and mementos oh my.
21:58:50 <kmc> jfoutz, http://classnamer.com
21:58:59 <SamB_XP_> yeah, in Haskell you'd write half a page of types before you figured out you didn't know what you were doing ;-)
21:59:17 * jfoutz giggles
21:59:21 <jfoutz> that's awesome
21:59:39 <kmc> StatefulUploadState
22:00:08 <jfoutz> i made a class called IHaveJavaBugs where each member is a static method named bug<bugid>. i found it quite satisfying.
22:00:23 <kmc> the equivalent for Haskell involves opening your category theory text to a random page
22:01:06 <jfoutz> oh, right. instance codual where
22:01:10 <SamB_XP_> kmc: and then finding the existing class for that in category-extras?
22:01:41 <SamB_XP_> jfoutz: how about instance Cocoa where
22:01:58 <jfoutz> that makes me a little sad... the cocoa binding seems abandoned.
22:02:29 <SamB_XP_> OptimizedQueryDecoder ... PropertyQueryHelper ... SimpleNotificationQueue
22:02:30 <jfoutz> kmc: BindingGirlfriendTree
22:02:38 <SamB_XP_> huh, that last one even makes sense
22:05:12 <Warrigal> Multiple-word type names shouldn't be necessary.
22:05:26 <Warrigal> Optimized (Query Decoder), Property (Query Helper), Simple (Notification Queue)
22:12:39 <kmc> more like Decoder Query, and i suppose the Query-optimized decoder should be a data family instance :)
22:39:34 <taruti> I keep making stupid mistakes in type variable scope. How do I refer to type variables in "upper declarations" correctly. e.g. "t :: forall a. a; t = id where x :: forall b. a -> b -> a; x v _ = v" to make it match the 'a' in the main declaration
22:40:31 <kmc> that looks right to me
22:40:39 <kmc> but check http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
22:41:48 <taruti> actually *using* -XScopedTypeVariables helps, I was only using RankNTypes and getting weird errors :)
22:42:28 <kmc> ah tricky, didn't know you could enable the forall kw without getting the lexical scoping behavior
23:03:57 <ksf> assume that a certain piece of code allows a pokeElemOff index to depend on say network input. How hard would it be to mess with the rts to inject code?
