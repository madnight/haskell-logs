00:00:22 <ksf> how, possibly, can acm have the gall to offer you papers for money that you can download freely from the net?
00:01:03 <c_wraith> They're still stuck in the "paid journal" mindset.
00:03:08 <Heffalump> well, and because they run a centralised archive
00:03:18 <Heffalump> but then so do ArXiv
00:04:58 <ksf> ...a centralized archive for haskell-related papers would be nice.
00:05:19 <Heffalump> ...but the ACM have the copyright lock
00:05:44 <ksf> well, you can still link to freely available versions.
00:06:49 <ksf> after all, we have our own journal.
00:10:30 <Heffalump> links die over time though
00:11:07 <ksf> well, it's better than nothing.
00:11:20 <ksf> the other possibility, of course, is to boycott acm.
00:13:08 <Heffalump> academics need it for the status
00:22:02 <ksf> ...and oss guys need open access to attribute those academics any status at all.
00:36:55 * SubStack is having fun using real data types for persistent storage
00:37:42 <SubStack> although it'd be nice if I didn't need to use template haskell so much
00:38:16 <Saizan> happstack-state?
00:38:32 <SubStack> yep
00:39:31 * SubStack is pretty sick of relational databases and pesky ORM that doesn't work
00:39:43 <Saizan> heh
00:40:33 <Saizan> i wish i had a proper server to host an happstack application
00:42:23 <quicksilver> SubStack: relational databases are great when they are what you need, but they're not a good soultion to 'simple persistence'
00:43:22 <quicksilver> SubStack: on the other hand, the query engine / query optimiser of your DB is a useful tool - but it's only relevant if you need it.
01:05:53 * ksf had a look at IxSet, and it smells suspiciously like a db to me.
01:07:23 <ksf> ...and happstate seems to be intertwined with happstack quite a lot, at least from a quick glance I couldn't find any way to properly use it without pulling whole happstack as a dependency.
01:07:45 <ksf> "properly" meaning "save data to another location than _local/"
01:17:34 <ksf> http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
01:17:36 <ksf> wtf!
01:17:40 <ksf> look at those types.
01:19:37 <c_wraith> Looks kind of like the program is implemented at the type level
01:20:06 <vegai> hah
01:20:36 <ksf> ...that stuff _has_ to be generated, somehow.
01:23:44 <quicksilver> awesome, isn't it?
01:23:49 <quicksilver> that was matthew's phd thesis, I think
01:24:50 <Axman6> ksf: holy ... :O
01:25:00 <Saizan> those types are inferred i hope :)
01:25:30 <nlogax> *head asplodes*
01:30:46 <vegai> phd thesis -- cause of and the solution to all programming problems
01:30:51 <quicksilver> they might not be inferrable
01:30:56 <quicksilver> there are ~ constraints in there
01:31:18 <quicksilver> I don't see anything higher-rank though
01:31:21 <vegai> Saizan: they're in the source like that also
01:31:44 <dolio> As I recall, it at least has combinators for constructing types more easily, rather than having to write stuff like that yourself.
01:32:00 <dolio> But a lot of the names in those look too nice to have been automatically generated.
01:32:57 <dolio> @type let idd :: type -> type ; idd x = x in (idd, idd)
01:32:58 <lambdabot> parse error on input `type'
01:33:15 <dolio> @type let idd :: sadatay -> sadatay ; idd x = x in (idd, idd)
01:33:16 <lambdabot> forall sadatay sadatay1. (sadatay -> sadatay, sadatay1 -> sadatay1)
01:37:17 <dolio> If you look at the source, they're actually typed in.
01:37:21 <dolio> How about that?
01:39:12 <Saizan> they might have been inferred and adjusted
01:39:25 <dolio> Possibly.
01:39:36 <dolio> They're much more nicely formatted in the source. :)
01:40:26 <Saizan> yeah
01:45:09 * ksf is still wondering about session types and multi-way communication.
01:45:37 <ksf> there's for example http://hackage.haskell.org/packages/archive/chp/1.2.0/doc/html/Control-Concurrent-CHP-Barriers.html , which kind of takes that role, for N concurrent processes
01:46:03 <ksf> ...but you don't get all those cool concrete types that session types are about.
01:48:28 <Saizan> there's another less type-heavy encoding of session types, iirc?
01:48:35 <ksf> yep.
01:48:44 <ksf> http://hackage.haskell.org/packages/archive/Coroutine/0.1.0.0/doc/html/Control-Coroutine.html and a few others.
01:49:36 <ksf> ...type families yay.
01:52:50 <ksf> http://hackage.haskell.org/package/persistent-map is nice.
01:56:55 <ksf> ...or rather tcache. looks nice too, maybe even nicer.
02:01:55 <Kaidelong> what's haskell's name for "reduce"?
02:02:19 <Kaidelong> do I just have to do something like "tail . scan"?
02:02:21 <dibblego> foldl1
02:03:02 <Kaidelong> ah, okay, thanks
02:03:52 <ksf> @src foldl1
02:03:52 <lambdabot> foldl1 f (x:xs) = foldl f x xs
02:03:52 <lambdabot> foldl1 _ []     = undefined
02:04:40 <Saizan> foldl1'
02:05:09 <Kaidelong> @src scanl1
02:05:09 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
02:05:09 <lambdabot> scanl1 _ []     =  []
02:05:21 * ksf recommends an expedition into the jungle of Data.List
02:08:10 <EnglishGent> hello all :)
02:08:23 <Grey_Fox> hi EnglishGent
02:08:54 <EnglishGent> hi Grey_Fox :)
02:26:43 <pao> @hpaste
02:26:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:27:17 <pao> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9026#a9026
02:27:33 <pao> is that aligning definition on equal a "good" style?
02:28:05 <Axman6> i use it quite a bit. it does help readability imo
02:28:05 <quicksilver> I like to
02:28:17 <Axman6> i also try and align arguments in the same position
02:29:40 <pao> the only problem that I see is that it forces to retouch lines of code only for realigning the equals in case of new patterns... make the diff "uglier" somehow
02:31:15 <quicksilver> yes
02:31:22 <quicksilver> that is a definite disadvantage
02:31:33 <quicksilver> (which holds true for many kinds of 'nice' code layout)
02:31:48 <quicksilver> I'm generally prepared to pay that price though
02:32:27 <Axman6> who reads diffs anyway?
02:33:12 <Axman6> pao: if you've got yourself a nice text editor which can do column editing, then it's not so bad
02:34:25 <pao> Axman6: well ... it happens often to read source revisions logs and diffs... doesn't it?
02:34:42 <pao> quicksilver: so, your choice is to align...
02:34:46 <Axman6> not for me, but i don't do any development where i'd need to
02:46:48 <pozic> How can two matrices be added with the Vec library?
02:49:28 <pozic> I wrote it already, never mind.
02:57:54 <ManateeLazyCat> Can't do Binary instance for some type that match: "data Foo = forall c . FooClass c => Foo c" ?
02:57:54 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
02:59:03 <Axman6> ManateeLazyCat: i doubt it
02:59:20 <Axman6> you'd need to be able to figure out which FooClass it was first no?
02:59:46 * ManateeLazyCat pasted "my code" at http://paste2.org/get/413123
02:59:51 <ManateeLazyCat> Axman6: Above is my code example.
03:00:20 <ManateeLazyCat> Axman6: Will got error that "Ambiguous type variable `t' in the constraint: `PageViewState t' "
03:02:08 * jethr0 forgot how important and nice it is in haskell to design your data types first and do kind-of dataflow programming. i don't think there are quite enough tutorials about his. maybe i'll write one after my game is finished
03:03:07 <ManateeLazyCat> Axman6: PageViewState class is deriving Binary, Binary can't reduce class ?
03:03:31 <Axman6> no
03:03:53 <Axman6> binary is just a binary representation of a data structure
03:03:56 <Saizan> ManateeLazyCat: you need to find out which exact type you're parsing before you can use its get
03:04:03 <Axman6> there's no type information stored there
03:05:04 <Axman6> like, for a tree, it would be something like: put (Node a t1 t2) = putWord8 0 >> put a >> put t1 >> put t2; put (Leaf b) = putWord8 1 >> put a;
03:05:38 <jethr0> Axman6: do you actually have to know what type you want to get out of a such a Binary representation? i.e. do you have to do "get x :: Get MyType". or is the type somehow stored in there?
03:05:39 <Axman6> ManateeLazyCat: the return type has to be known to know which get to use
03:05:47 <Axman6> jethr0: yes
03:05:55 <Axman6> the firmer
03:05:56 <jethr0> ah
03:05:57 <Axman6> o*
03:06:37 <Axman6> it's an excellent library, but it has the same limitations of all binary representations: they only make sense in context ;)
03:07:55 <Saizan> jethr0: the type doesn't need to be completely fixed statically
03:08:37 <Saizan> jethr0: you can keep a Map Tag BinaryContext and store the Tag with the binary representation and do a lookup
03:09:26 <Saizan> where data BinaryContext = forall a. Binary a => BinaryContext
03:09:37 <jethr0> Saizan: would you store a "show Tag" with the binary rep then?
03:09:49 <Saizan> jethr0: yep
03:10:03 <jethr0> cool
03:11:03 <ManateeLazyCat> Saizan: Type can't deriving Binary automatically?
03:11:03 <Craig`> hello again
03:11:35 <Craig`> I fixed some of the errors before due to installation, it was due to java not installing probably another time; http://pastebin.ws/5fozlg .. I still get 2 errrors though; can you tell me a fix please :)
03:11:59 <Craig`> make[1]: c: Command not found .. is found a lot
03:12:20 <Saizan> ManateeLazyCat: the instances of typeclasses are indexed by types, if you don't know which type you want you can't choose an instance, and so you can't call its methods
03:14:25 <Saizan> ManateeLazyCat: that's why you get an ambiguity error
03:14:37 <ManateeLazyCat> Saizan: I see. I fix my problem now.
03:15:34 <ManateeLazyCat> Saizan: I have two instance for PageViewState: StringViewState and DiredViewState, now i write Binary instance with those type explicit.
03:15:58 <suiside> Craig`: are you  trying that in a linux setup? which distribution?
03:16:45 <Craig`> suiside: yes, I'm running ubuntu 9.04 x64, and I've downloaded ghc-6.10.4 (x64)
03:17:21 <suiside> Craig`: do you have the build-essential package installed from apt?
03:20:29 <ManateeLazyCat> Saizan: So if i need instance Binary for typeclass, i need tag every instance of typeclass ?
03:28:37 * ManateeLazyCat pasted "my code" at http://paste2.org/get/413148
03:28:38 <ManateeLazyCat> Saizan: I want split Binary instance with different type of typeclass, like above code, but can't work. Any idea?
03:30:01 <ManateeLazyCat> Saizan: If i tag different type of typeclass, i need write all type tag in one Binary instance, i want split those Binary instance in different module. Can implement it?
03:30:27 <quicksilver> Axman6: reading diffs is one of the most fundamental tasks in software development.
03:30:45 <Axman6> i don't doubt that :)
03:30:46 <quicksilver> Axman6: I almost always review the diff before I commit even on a one-person project, and certainly on a multi-person project.
03:31:19 <Axman6> i usually do too, just so i know what to write in the commit message
03:31:45 <quicksilver> exactly
03:32:13 <quicksilver> but you did say "who reads diffs anyway?" ;) I submit the answer is at least you, me, and pao ;)
03:33:45 <Axman6> yeah, i was joking somewhat :)
03:34:37 <path[l]> I almost never do =p. I usually just commit
03:34:50 <quicksilver> turpitude!
03:35:19 <path[l]> except as axman said when I want to figure out what the commit message should be lol
03:36:14 <LeCamarade> What's the cleanest way to "run all these actions concurrently". mergeIO?
03:37:35 <quicksilver> @hoogle mergeIO
03:37:35 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
03:37:35 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
03:37:45 <quicksilver> mergeIO doesn't run actions
03:38:12 <quicksilver> I don't believe there is a potted recipe for what you want although it's obviously not hard to do
03:38:16 <quicksilver> how do you want to collect the results?
03:39:17 <Axman6> LeCamarade: sequence . map forkIO?
03:40:01 <quicksilver> that doesn't collect the results
03:40:10 <quicksilver> (and that's spelt mapM forkIO)
03:40:42 <LeCamarade> Axman6, Well, they are not -> IO ().
03:41:01 <Saizan> ManateeLazyCat: you can't write multiple instances for the same type
03:41:06 <Axman6> quicksilver: so it is, thsnks
03:41:19 <LeCamarade> I'm going to do a wrapper that's the equivalent of Ruby's Array#map . Thread#join.
03:41:20 <Axman6> it's this damn thinkpad keyboard you see ;)
03:41:46 <ManateeLazyCat> Saizan: So i need write all type in same Binary instance?
03:41:49 <LeCamarade> Thanks, everyone.
03:42:13 <LeCamarade> I think there should be a potted solution.
03:43:12 <quicksilver> collecting the results into a list?
03:43:13 <Saizan> ManateeLazyCat: yes, and you'd also have to include some representation for the type in the binary representation, a tag you can match over to determine which type to parse
03:43:26 <quicksilver> in the order you had the actions, or in the order they come back?
03:43:38 <quicksilver> MVar list perhaps?
03:43:49 <quicksilver> or list of Mvars ;)
03:43:52 <quicksilver> or a Chan...
03:43:54 <quicksilver> quite a few choices.
03:44:03 <Saizan> ManateeLazyCat: so you probably need extend your existential
03:44:07 * Axman6 recommends a Chan
03:44:17 <ManateeLazyCat> Saizan: I don't like this style, i like write different type instance in it's own module.
03:44:47 <ManateeLazyCat> Saizan: I think i need change something for distributed instance....
03:45:48 <hackagebot> fclabels 0.4.0 - First class accessor labels. (SebastiaanVisser)
03:45:58 <Saizan> ManateeLazyCat: you could change PageViewRebootState into a sum type instead of an existential
03:46:18 <ManateeLazyCat> Saizan: I need keep different type's Binary for through reboot and then rebuild different widget, so i need write typeclass to abstract those type, but typeclass with Binary is problem.
03:47:09 <Saizan> ManateeLazyCat: xmonad has a similar problem with their existential types, maybe you could look at how they solve it
03:47:54 <dblick> I'm trying to figure out if it's possible to do OOP in Haskell.  Imagine I have defined in a module somewhere something like "class C a where asString :: a -> String" along with some functions that arguments of type "C".  I can take any type "T", make it implement the "C" interface, and then provide any instance of "T" to any one of those functions returning "C".  That's all good.  Now imagine that instead of a String, I want to return 
03:48:36 <quicksilver> dblick: you got cut off at ", I want to return"
03:48:52 <quicksilver> dblick: (just to be pedantic, 'C' is not a type)
03:48:54 <Axman6> y can't retrn nothing :O
03:48:59 <dblick> I want to return something like the "T", that wasn't known when I was writing "C" and its functions.  Can I do that?
03:49:00 <ManateeLazyCat> Saizan: If i tag every types in all Binary instance, it can work, but if some developers want add new type for rebuild widget, it's bad that developers must be modified this Binary instance for Center control, center control is bad design for extension.
03:49:03 <Axman6> god damn this thinkpad
03:49:11 <Lemmih> dblick: Yes.
03:49:23 <Axman6> you can? o_O
03:49:39 <Lemmih> 'class C a where doSomething :: a -> a'
03:49:51 <Saizan> ManateeLazyCat: yeah, i know
03:49:52 <ManateeLazyCat> Saizan: Thanks for your help, i will looks Xmonad source code or change my design.
03:50:14 <Saizan> ManateeLazyCat: have you seen my suggestion above about Map Tag BinaryContext?
03:50:29 <Saizan> ManateeLazyCat: you can manage to build that Map in a less centralized way
03:50:34 <dblick> hmm. good point.
03:51:33 <ManateeLazyCat> Saizan: You mean, add `tag` `type` in Map, then Binary lookup in this Map, if have a new type, just add in Map?
03:51:37 <Lemmih> dblick: You might look into existentials.
03:51:55 <dblick> okay, i'm happy again. thanks lemmih!
03:52:03 <Saizan> ManateeLazyCat: yes
03:52:27 <quicksilver> dblick: you might read http://homepages.cwi.nl/~ralf/OOHaskell/
03:52:30 <ManateeLazyCat> Saizan: That's will be cool, just create new unique tag for new type. Thanks! :)
03:52:41 <quicksilver> dblick: which explains how to implement various OOP features in haskell
03:52:55 <quicksilver> dblick: it has the added benefit that it will, at least once, cause your head to explode on reading.
03:53:26 <Saizan> best to read the HList paper first
03:53:28 <dblick> quicksilver, excellent :) thanks
03:55:34 * quicksilver doesn't agree.
03:55:46 <quicksilver> You may want ot read the HList paper at some point, to understand some of the later chapters
03:55:54 <quicksilver> but I would *start* by readin the OOHaskell paper
03:56:00 <jethr0> head-exploding is the first step toward learning ;)
03:56:09 <quicksilver> its motivational material at the beginning is good scene-setting.
03:56:33 <Saizan> uhm, that's true, HList is a prerequisite to understand the implementation though
03:57:01 <quicksilver> dblick: I would like to point out that I don't personally think that paper describes a sensible way to right programs. It's a detailed and thorough experiment in the possible.
03:57:05 <quicksilver> s/right/write/
03:57:08 <Phyx-> Morning
03:57:16 <Phyx-> does gtk2hs work on ghc 6.10.4?
03:57:23 <quicksilver> dblick: however, it contains quite a few individual techniques which are useful, and you might not have thought of.
03:58:10 <temoto> data Cell = Empty | Chip1 | Chip2
03:58:38 <temoto> data Board = Cell[8][8]  -- Only unit numeric type pattern is valid   <- what does it mean?
03:58:52 <quicksilver> temoto: [8][8] is not haskell syntax.
03:59:00 <Axman6> temoto: haskell doesn't have arrays like that
03:59:04 <quicksilver> temoto: it's C or Java or C++, for example ;)
03:59:21 <temoto> Yeah, i can read and write C.
03:59:29 <temoto> How to express the same in haskell?
03:59:36 <Axman6> well, Haskell /= C ;)
03:59:45 <quicksilver> the most naive idiomatic way is data Board = Board [[Cell]]
03:59:57 <quicksilver> that doesn't restrict the size to 8, and lists aren't always the right structure.
03:59:59 <dblick> quicksilver, that sounds very good.  i'll give it a shot.
04:00:02 <Axman6> data Board = Array (Int,Int) Cell
04:00:03 <quicksilver> but it's the simplest/most natural.
04:00:17 <quicksilver> Axman6: missing constructor :P
04:00:33 <Deewiant> type Cell8 = (Cell,Cell,Cell,Cell,Cell,Cell,Cell,Cell); data Board = Board (Cell8,Cell8,Cell8,Cell8,Cell8,Cell8,Cell8,Cell8)
04:00:34 <Axman6> yeah, i haven't used Arrays in some time ;)
04:00:45 <Axman6> Deewiant: you're a monster
04:00:49 <Deewiant> :-P
04:00:54 <int-e> Deewiant: and it might even perform better than the array solution.
04:01:05 <int-e> (updates are cheaper)
04:01:12 <Deewiant> Maybe, maybe not
04:01:18 <Phyx-> hmmm anyone know how to get gtk2hs to register under ghc 6.10.4
04:01:26 <Phyx-> the installer is version locked to .3
04:01:26 <int-e> (at least in terms of memory allocated)
04:01:28 <temoto> Deewiant: will it allow accessing items by (x,y) coordinate?
04:01:37 <quicksilver> data Board = Board (Seq (Seq Cell)) performs quite well.
04:01:53 <Axman6> temoto: no
04:01:57 <temoto> god so many choices
04:02:01 <quicksilver> but is slightly syntactically clumsy until you write a few basic access operations.
04:02:02 <Axman6> well, not without you writing a function for it
04:02:02 <int-e> temoto: sure, if you write the accessor function. ;)
04:02:03 <Deewiant> Sure! Just do case (x,y) of (0,0) -> fst8 . fst8 $ board; (0,1) -> snd8 . fst8 $ board; ...
04:02:28 <Axman6> trd8 . fft8?
04:02:29 <Deewiant> temoto: Note: I'm kidding here, you don't want to use 8-tuples for anything :-P
04:02:35 <Axman6> ((3,5))
04:02:47 <int-e> . o O ( @topic-cons "beware of the resident monster, Deewiant" )
04:03:22 <Deewiant> fst8, snd8, trd8, fth8, fft8, sxt8, snt8, eth8
04:04:12 <temoto> data Board = Array (8, 8) Cell gives same error.
04:04:27 <Arnar> hi all
04:05:00 <njd> Hi, i've hit an issue where cabal, template-haskell along with other libraries:  when cabal builds the package the template haskell run is given all the packages (one of which is pcap) BUT not the system library (libpcap) that it references, i've tried the extra-libraries: cabal statement, tried adding it via the cabal command line - but to no avail, the template haskell invocation fails because of the linker - any suggestions?
04:05:01 <Arnar> why would one write "type T = Either A (Either B (... (Either Z ()) ...)" ?
04:06:17 <maltem> that would be an infinite type
04:06:36 <maltem> but if you omit T on the right side, it would make sense ;)
04:06:47 <int-e> temoto: you need a constructor, and limits are fixed when allocating the array. data Board = Board (Array (Int, Int) Cell)  will work. newBoard = listArray ((0, 0), (7, 7)) (repeat Empty)
04:06:52 <Arnar> maltem: hmm..
04:07:03 <temoto> int-e: thanks.
04:07:14 <Arnar> maltem: specifically I'm looking at Section 4.1 on http://www.haskell.org/haskellwiki/Libraries_and_tools/HJS
04:07:17 * Phyx- edits the stupid msi and change the ghc version check
04:07:35 <Arnar> wondering why they don't just use data
04:07:38 <int-e> Arnar: hmm, maybe you want to use some type class T which has an Either instance?
04:08:27 <Arnar> int-e: mm, ok.. don't see it there. seems like they are just simulating a type class
04:08:47 <Arnar> this is Yhc code from 2007..
04:09:04 <int-e> Arnar: or they didn't want to think of constructor names for the alternatives, or it's generated code.
04:09:16 <int-e> (and I'm sure there are other reasonable explanations)
04:09:39 <Arnar> int-e: right.. I'm sure of that too :)
04:09:44 <maltem> Arnar: that example does look a little odd
04:09:49 <Arnar> was just wondering if this was a known trick to do something
04:09:56 <Arnar> maltem: I suspect they are avoiding type classes..
04:10:07 <Arnar> maltem: perhaps their compiler didn't support them at the time
04:10:31 <Arnar> no wait..
04:10:45 <Arnar> they have "class SubType ..." right below :)
04:10:58 <Arnar> I don't know.. just looks odd
04:11:11 <temoto> How to init array from [[Empty, Chip1...], [Chip1, Empty, Chip2...], etc] ?
04:11:41 * Phyx- taps his mike wondering if this thing's on
04:11:46 <Phyx-> mic*
04:11:59 <Arnar> we hear you
04:12:26 <maltem> Arnar: maybe it comes somehow handy with the Convert class, but I cannot see how anyways
04:13:11 <Arnar> maltem: aha..
04:13:21 <Phyx-> guess i need to wait till someone who uses gtk2hs on windows comes along
04:23:38 <Alpounet> Hi.
04:28:26 <Arnar> temoto: Something like http://codepad.org/xKKgkIK4 ?
04:31:06 <temoto> Arnar: no-no, totally different :)
04:31:33 <temoto> Arnar: http://codepad.org/ZyyzkloB
04:34:23 <dancor> is there a cool way to interleave line-by-line the output of two fifos (that could block arbitrarily)
04:34:30 <dancor> maybe with Data.Unamb.amb
04:34:56 <dancor> i want to build as little of my own STM stuff as possible
04:35:53 <dancor> i worry with amb that if the results do come in at nearly the same time, one of them would be permanently lost
04:36:35 <quicksilver> don't use evil stuff like unamb/amb
04:36:43 <dancor> ya i guess i should just use TChans
04:36:46 <quicksilver> when there are more sensible solutions.
04:36:59 <quicksilver> just one Chan (or one TChan)
04:37:32 <int-e> dancor: http://int-e.home.tlink.de/haskell/Logger.hs
04:37:33 <quicksilver> have one thread per fifo, reading off the fifo and writing to the Chan (resp. TChan)
04:38:06 <int-e> (it's cool because it's lock-free on the writing side)
04:39:39 <int-e> oh ... missing license. but it'd be MIT licensed.
04:40:07 * quicksilver doesn't think the lock on writeChan is terribly concerning
04:40:14 <quicksilver> but certainly, that's cool
04:40:26 * quicksilver supposes it matters if you expect to log 1000s of things per second.
04:40:40 <int-e> quicksilver: it usually isn't. I wrote this to debug unamb ;)
04:40:43 <quicksilver> ;)
04:40:51 <quicksilver> there kind-of isn't a lock on writeChan for TChans
04:41:03 <quicksilver> but of course there is the STM consistency check instead
04:41:09 <quicksilver> which I imagine is a comparable cost
04:41:34 <int-e> and it was essential that the code wouldn't block in the middle of some place with exceptions blocked. (hmm. 'block' is overloaded in this context.)
04:41:55 <quicksilver> I understand, though.
04:42:31 * quicksilver is not *really* a fan of unamb, and is quite *definitely* not a fan of 'amb' ;)
04:42:49 <quicksilver> although I should make it clear that I'm absolutely a fan of research into new kinds of combinators
04:42:52 <burp> @pl \x -> head .head $ [[x]]
04:42:52 <lambdabot> head . head . return . return
04:42:55 <quicksilver> I just don't like exposes non-determinism.
04:42:55 <int-e> neither am I, but it was still entertaining to debug.
04:43:22 <int-e> (especially since the effort turned up a few RTS bugs)
04:43:57 <dancor> i think unamb is worse, bc it creates a hard-to-ensure constraint
04:45:00 <dancor> (that the values are the same when defined)
04:45:36 <EvilRanter> lub!
04:45:53 <dancor> amb/race seems like something you would reasonably invent on your own for certain (possibly esoteric) things
04:46:05 <brian6> does 'cabal build' ignore --with-gcc?
04:47:00 <temoto-mobi> data Cell = Empty | Chip1 | Chip2
04:47:02 <temoto-mobi> instance Show Cell => Show (Cell c) where   -- what's wrong here? i get error: 'Cell' is applied to too many type arguments
04:47:20 <quicksilver> dancor: you might *reasonably* invent, but *misguidedly*
04:47:23 <quicksilver> dancor: (in my opinion)
04:47:33 <dancor> temoto-mobi: you probably wanted  Show c => Show (Cell c)  ?
04:47:35 <int-e> temoto-mobi: what are you trying to express? do you mean  instance Show Cell where?
04:47:47 <quicksilver> things like non-determinism or blocking are most elegantly represented in the type system with a tag
04:47:50 <quicksilver> the tag we have is IO
04:47:57 <quicksilver> a finer-grained tag system would be better ;)
04:48:05 <quicksilver> but with what we have, I'd rather these things had IO tags.
04:48:21 <dancor> but amb :: a -> a -> IO a fits your criteria doesn't it?
04:48:52 <quicksilver> oh, it's in IO? I didn't know that.
04:48:56 <quicksilver> yeah, that's better.
04:49:01 <quicksilver> I thought it was just a -> a -> a
04:49:07 <int-e> that's unamb
04:49:11 <quicksilver> yes, I know that ;)
04:49:21 <int-e> . o O ( short for unsafeAmb )
04:49:25 <temoto-mobi> I want Cell to be printable :)
04:49:25 <quicksilver> ;)
04:49:37 <Beelsebob> int-e: short for unambiguous choice
04:49:44 <int-e> Beelsebob: I know.
04:49:47 <Beelsebob> it has an unexpressed preconditions that the two arguments must be equal
04:49:53 <quicksilver> temoto-mobi: data Cell = Empty | Chip1 | Chip2 deriving (Show)
04:49:53 <int-e> Beelsebob: I was (half-)joking.
04:50:06 <temoto-mobi> quicksilver: thanks.
04:50:35 <dancor> it's short for preserving-referential-transparency-is-your-problem-not-mine
04:50:59 <int-e> Beelsebob: The other unsafe* functions have the same property really - they have some unexpressed preconditions that allow them to be used safely.
04:51:08 <quicksilver> right.
04:51:09 * Beelsebob nods
04:51:11 <dancor> int-e: +++++++++++++
04:51:19 <quicksilver> and most importantly, improper use doesn't result in runtime error.
04:51:39 <quicksilver> head has an unexpressed precondition, but it's semantically safe because you get a runtime _|_
04:51:53 <quicksilver> unamb will just do the wrong thing, with no flagging
04:52:00 <quicksilver> (not that it has any choice ;)
04:52:24 <quicksilver> so unamb is "semantically unsafe" much like unsafeCoerce or unsafePerformIO
04:57:53 * int-e wonders whether unamb can be used to break Data.Typeable (without writing broken Typeable instances)
05:01:13 <quicksilver> int-e: don't think so.
05:01:34 <quicksilver> int-e: given a program with N uses of unamb, there are 2^N possible traces
05:01:51 <quicksilver> int-e: each of those 2^N possible traces is a perfectly sensible haskell program
05:01:58 <quicksilver> so none of them breaks Data.Typeable.
05:01:59 <int-e> nope.
05:02:02 <quicksilver> no?
05:02:18 <int-e> unamb a b  may return b on one call and a on another.
05:02:52 <int-e> iow, unamb is impure. and that may break safety proofs for uses of more dangerous functions like unsafeCoerce - that's what I'm after.
05:03:45 <quicksilver> but I don't think it's observably impure
05:03:48 <quicksilver> (although it is)
05:04:06 <quicksilver> what I mean is, there *might* be some oracle determining when it returns a and when it returns b
05:04:10 <int-e> the two  unamb a b  calls may be unrelated as far as the compiler knows, and thus not shared.
05:04:23 <quicksilver> so there are countable traces, not 2^N
05:04:36 <quicksilver> ...I forgot that the "same" call might be called more than once
05:04:47 <quicksilver> but there is still a countable tree of possibilities
05:04:53 <quicksilver> with a branching point on each unamb.
05:05:05 <int-e> yes, but some of them clearly prove that unamb is not pure.
05:05:07 * quicksilver nods
05:05:16 <quicksilver> yes, you are right.
05:05:31 <int-e> well, may prove. it depends on the program.
05:05:43 <quicksilver> understood
05:05:59 <quicksilver> for example, you can write "typeOf a `unamb` typeOf b"
05:06:04 <quicksilver> and get a non-deterministic TypeRep
05:06:55 <FunctorSalad> *jumps into discussion* unamb is pure if it is used umab'ly :)
05:07:11 <FunctorSalad> otherwise you're supposed to use 'amb'
05:08:12 <int-e> yes, that much is clear. I'm just wondering how unsafe it is if not used as intended.
05:08:13 <temoto-mobi> quicksilver: i wrote deriving (Show), but 1) now it ignores my show and 2) i'd like to print a pretty table.
05:08:38 <quicksilver> temoto-mobi: no you wouldn't
05:08:46 <quicksilver> temoto-mobi: Show is not a pretty printer.
05:08:54 <quicksilver> temoto-mobi: Show is for producing valid haskell syntax.
05:08:59 <temoto-mobi> oh
05:09:01 <quicksilver> if you want a pretty printer, call it something else.
05:09:06 <quicksilver> "pp" is a traditional name
05:09:55 <dancor> pp :: MyThing -> String
05:09:55 <temoto-mobi> So i have to write  pp :: Cell -> IO()   pp c = do print ...  ?
05:09:56 <FunctorSalad> int-e: doesn't the type "a -> a -> a" ensure that two calls to typeOf will use the same instance?
05:10:00 <etpace_> @src concat
05:10:00 <lambdabot> concat = foldr (++) []
05:10:19 <int-e> FunctorSalad: in quicksilver's example a was TypeRep
05:10:33 <int-e> FunctorSalad: and I had something similar in mind - some existential, say.
05:10:57 <int-e> FunctorSalad: except that isn't quite enough, as far as I can make out.
05:10:57 <dancor> i would    putStrLn (pp myThing)
05:11:03 <FunctorSalad> doesn't an existential have a fixed typeRep?
05:11:07 <FunctorSalad> independent of the hidden type
05:11:11 <FunctorSalad> (no idea)
05:11:36 <quicksilver> int-e: but getting a non-determinstic TypeRep isn't enough. There is no "Coerce :: a -> TypeRep -> b" or anything
05:11:48 <quicksilver> as far as I can see
05:11:50 <FunctorSalad> ok, you could call typeOf on the hidden type
05:12:13 <int-e> quicksilver: right
05:13:21 <quicksilver> int-e: if you could somehow manufacture an expression "toDynamic (a `unamb` b)" in such a way that it gets called twice...
05:13:24 <lilac> how about, build two existentials "Typeable a => a" of different types, feed them into unamb, and give the result to coerve
05:13:28 <quicksilver> ...I still don't know what you'd have
05:13:48 <lilac> denotationally, coerce could use the Typeable instance from one and the value of the other
05:14:44 <quicksilver> that's true
05:14:50 <quicksilver> I wonder if you can increase the chance of that happening
05:15:25 <int-e> quicksilver: of course that
05:15:30 <int-e> nm
05:15:46 <lilac> at a minimum, i think you'd need to inline coerce and somehow get GHC to call unamb twice
05:15:52 <int-e> (^j and ^k are just too close to each other on my keyboard)
05:16:06 <lilac> the latter might be possible by sparking off the call to coerce simultaneously on multiple threads
05:18:48 <FunctorSalad> int-e: yay I broke it!!! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9027#a9027
05:19:09 <FunctorSalad> no coerce
05:19:50 <FunctorSalad> compiled with -threaded it sometimes prints 'Double'
05:21:16 <temoto-mobi> I can't come up with a pp that would print a table from Board Array (Int, Int) Cell. Please, help?
05:21:23 <int-e> FunctorSalad: that's ok though?
05:21:35 <FunctorSalad> int-e: then I misunderstood the problem
05:23:44 <int-e> FunctorSalad: we knew that unamb is nondeterministic and impure. the problem is, can this ... weakness ... be escalated into something more dangerous?
05:24:52 <Saizan> temoto-mobi: where are you stuck?
05:26:30 <lpsmith> Hey,  I might be giving a few Haskell lessons to somebody,  I've been thinking about how to do this effectively.   I'll be in the same room,  but I'm thinking about using Gobby or some other collaborative editor to write code.
05:27:02 <lpsmith> The issue is how can we "share" an instance of GHCi between our laptops?
05:27:22 <lilac> lpsmith: you could do worse than running a lambdabot in some IRC channel ;)
05:27:33 <lpsmith> :-)
05:27:56 <temoto-mobi> Saizan: at making type system happy :)
05:28:07 <lpsmith> yeah,  lambdabot is quite nice,   how hard is it to load the files into it though?
05:28:15 <Saizan> @hpaste
05:28:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:28:22 <Saizan> temoto-mobi: paste the code ^^
05:28:30 <otulp> lpsmith: screen -x via ssh, if I recall correctly.
05:28:32 <quicksilver> lambdabot: emacs
05:28:36 <quicksilver> lpsmith: emacs
05:28:55 <Saizan> temoto-mobi: if the type system is not happy that's because your code won't work, usually :)
05:29:04 <quicksilver> lpsmith: you can share emacs sessions which can include a ghci session in a buffer
05:29:15 <temoto-mobi> Saizan: http://codepad.org/4kKk4IiI
05:29:33 <Deewiant> ?ty map
05:29:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:29:38 <quicksilver> temoto-mobi: neither foldr nor map work on arrays
05:29:42 <temoto-mobi> Saizan: i'm not trying to say static typing is bad. That's just where i stuck.
05:29:43 <Deewiant> temoto-mobi: map wants an [a], you're giving it a Board
05:29:45 <quicksilver> temoto-mobi: arrays are arrays, lists are lists.
05:30:06 <quicksilver> (and that's quite apart from the fact that Board is not, literally, an array)
05:30:11 <temoto-mobi> Aren't both iterable sequences?
05:30:53 <Deewiant> Abstractly, yes, but then you need to use functions which can apply to any iterable sequence, not "map" and "foldr" which only work on lists :-)
05:31:15 <temoto-mobi> Alright, which function does?
05:31:15 <Deewiant> (See Data.Traversable / Data.Foldable, but this may be a bit over-complicating for a beginner)
05:31:32 <Deewiant> It may be preferable to just use the array-specific functions
05:31:35 <quicksilver> look at the documentation for array, use those functions.
05:31:37 <Deewiant> Or turn the array into a list at the start
05:31:46 <quicksilver> probably just the ones which convert the array to a list, to be honest.
05:31:58 <quicksilver> (this is why I suggested the list representation up front)
05:32:41 <Saizan> also, foldr lacks an argument there
05:32:42 <temoto-mobi> aha
05:33:04 <Saizan> and foldr (++) [] = concat
05:33:07 <Deewiant> Yes, you probably want concatMap instead of foldr
05:33:39 <quicksilver> but Array (Int,Int) doesn't have a built in function to convert to a nested list
05:33:46 <quicksilver> it just has one to convert to a list.
05:33:54 <quicksilver> these things are all solvable
05:33:56 <quicksilver> but, still
05:34:03 <quicksilver> that's why I suggested [[Cell]] to start with.
05:34:11 <Deewiant> Yep, you'll end up with [((Int,Int),Cell)]
05:34:50 <quicksilver> Deewiant: or just [Cell]
05:35:04 <quicksilver> but you'd then need 'chunksOf' which isn't in the standard library but should be.
05:35:06 <Deewiant> Yeah, or that.
05:35:14 <Deewiant> It's in Data.List.Split.
05:35:18 <quicksilver> is it?
05:35:28 <Deewiant> Yes, it is.
05:35:39 <Deewiant> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v%3Achunk
05:35:45 <quicksilver> so it is
05:35:51 <quicksilver> two bad name choices though :(
05:35:57 <Deewiant> :-P
05:36:01 <quicksilver> byorgey++ # getting stuff on haddock
05:36:06 <Deewiant> There are 10 different names for it
05:36:48 <lpsmith> Hmm... lambdabot needs some kind of hpaste integration
05:36:51 <quicksilver> "groupsOf" or "chunksOf" fit the general haskell theme of readable expressions though
05:37:04 <quicksilver> lpsmith: there is an hpaste bot but for some reason we're not using it.
05:37:07 <Deewiant> 4 `chunksOf` [1..500] ?
05:37:16 <quicksilver> I didn't mean it infix, no
05:37:20 <quicksilver> just "chunksOf 4"
05:37:24 <quicksilver> or "groupsOf 4"
05:37:43 <temoto-mobi> , groupsOf 4 [1..10]
05:37:51 <temoto-mobi> . groupsOf 4 [1..10]
05:37:52 <lpsmith> quicksilver:  my idea is to use hpaste as a convenient mechanism for introducing definitions that aren't practical to introduce in the channel itself
05:37:53 <Deewiant> Hmm, what about splitPlaces, then
05:38:00 <temoto-mobi> > groupsOf 4 [1..10]
05:38:00 <quicksilver> lpsmith: oh that's interesting.
05:38:01 <lambdabot>   Not in scope: `groupsOf'
05:38:07 <quicksilver> lpsmith: why not just PM it though?
05:38:11 <lpsmith> I'm not sure exactly how that'd work
05:38:12 <quicksilver> temoto-mobi: it's not in the library
05:38:13 <lpsmith> hmm
05:38:18 <Deewiant> [[1,2,3,4],[5,6,7,8],[9,10]]
05:38:18 <roconnor> [[1,2,3,4],[5,6,7,8],[9,10]]
05:38:25 <quicksilver> temoto-mobi: I just indicated what name I like
05:38:27 <lpsmith> well, it's nice to let everybody see what the definitions are :-)
05:39:18 <temoto-mobi> quicksilver: ah. Though, i can remember some similar function very builtin. Something like fold and take marriage.
05:39:21 <Deewiant> @let groupsOf n = map (take n) . takeWhile (not.null) . iterate (drop n)
05:39:22 <lambdabot>  <local>:2:0:
05:39:22 <lambdabot>      Warning: Pattern match(es) are overlapped
05:39:22 <lambdabot>               In...
05:39:28 <Deewiant> > groupsOf 4 [1..10]
05:39:29 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
05:39:34 <quicksilver> right
05:40:30 <lpsmith> also it's nice to allow definitions to be edited.
05:40:57 <lpsmith> But therein lies the problem... I'm not real clear on the semantic issues involved in an hpaste-lambdabot integration
05:41:45 <quicksilver> I don't think hpaste would be ther ight way
05:41:54 <quicksilver> I think what you really want is just for lambdabot to (also) have a web interface
05:42:02 <quicksilver> which you can use to iteractively edit larger defintions
05:42:18 <quicksilver> and the IRC part of LB could output, in the channel, the link you need to view to see the whole definition
05:42:35 <Jafet> Is codepad known here?
05:42:40 <Jafet> I think it does haskell
05:42:47 <temoto-mobi> It does, yup.
05:42:55 <Twey> It's known, I think.
05:43:09 <quicksilver> <quicksilver> lambdabot: @def groupsOf <lambdabot> groupsOf was defined by lpsmith at Sep 03 2009, 10:33 and the full definition is at http://lambdabot.com/12345
05:43:14 <quicksilver> lpsmith: something like that?
05:43:25 <quicksilver> Jafet: certainly known to me, yes ;)
05:43:37 <quicksilver> it only does hugs, so limited extension support compared to lambdabot/lunabot
05:45:36 <Phyx-> hmmm anyone know how to get gtk2hs to register under ghc 6.10.4
05:45:50 <lpsmith> yeah,  that's an idea
05:46:42 <lpsmith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9028    <-- a silly little attempt to see if lambdabot already had something like that
05:47:10 <lpsmith> But it should be able to cope with "loose" definitions like that
05:48:02 <brian6> Phyx-: i think i got it going the other day. are you getting some error about mismatch between 6103 and 6104 or something?
05:50:32 <Phyx-> brian6: yes, it didn't even register itself with ghc-pkg
05:52:21 <brian6> Phyx-: hmm. i'm not sure what i did. :(. i have the darcs repo checked out, though. maybe i installed from that.
05:52:38 <Phyx-> ok
06:31:52 <jethr0> (an eery quiet besets the otherwise so rambunctious channel)
06:33:19 <bjorkintosh>                                                                                                                                                                                                                                                                                                                                                                                                                                                        
06:33:19 <bjorkintosh>                                                                                                                                                                                                                                                                                                                                                                                                                                                        
06:33:20 <bjorkintosh>                                                                                                                                                                                                                                                                                                                                                                                                                                                        
06:33:25 <bjorkintosh>                                                                                                                                                            you're correct jethr0 tu11
06:33:30 <bjorkintosh>                                                                                                                                                                                                                                                                             
06:33:34 <bjorkintosh> holy crap!
06:34:26 <jfoutz> i think the europeans are in the after lunch lull, and the americans are not full of coffee yet.
06:34:27 <jethr0> bjorkintosh: wake up, your cat is dancing on your enter key
06:35:03 <quicksilver> after lunch lull is also correctly categorised as "not full of coffee yet"
06:35:24 <quicksilver> but this channel is generally quieter in summer
06:35:24 <jfoutz> heheh
06:35:29 <jethr0> as is sleeping, in most sane cases
06:35:57 <quicksilver> just wait till all the university types get back in channel and procrastinate to avoid their lectures / dissertations / research / teaching / paper deadlines / etc
06:35:57 <medfly> ...
06:36:08 <Vq> jfoutz: it's quite past the after lunch lull
06:36:08 <sohum> mmm, procastination
06:36:28 <Vq> jfoutz: more like after afternoon coffee break lull
06:36:39 <saml> > procastinate [1..]
06:36:42 <lambdabot>   Not in scope: `procastinate'
06:36:55 <jfoutz> Vq: maybe sneaking out early on friday afternoon lull?
06:37:00 <Grey_Fox> hi, I'm a newbie to haskell, and I've just finished "Learn you a haskell for great good", can anyone tell me where I should go from here?
06:37:11 <medfly> another language?
06:37:11 <saml> i'd go to japan from there
06:37:13 <medfly> :p
06:37:16 <quicksilver> Grey_Fox: heaven. Your life is now complete.
06:37:20 <jethr0> let procrastinate = procrastinate . procrastinate
06:37:26 <quicksilver> Grey_Fox: you might try real world haskell, though
06:37:32 <Vq> jfoutz: we don't call that lull, but yeah :)
06:37:42 <Saizan> Grey_Fox: you should write some code yourself :)
06:37:42 <saml> Grey_Fox, make a build system. or any other softawer that interests you
06:37:43 <Grey_Fox> ok
06:38:11 <saml> make a shell in haskell so that you can script things in haskell
06:38:25 <Grey_Fox> sounds hard
06:38:27 <medfly> do #haskell's work, apparently
06:38:46 <Saizan> more like fulfill saml's wishes :)
06:38:54 <saml> implement coreutils in haskell
06:38:57 <jethr0> Grey_Fox: anything you'd like to work on ;). personally, it helped me a lot to implement Prelude and the std. monads as an exercise. but you might be more pragmatically minded and jump right into a large application
06:39:07 <saml> start with echo and cat
06:39:11 <jethr0> oh yes, and real world haskell, of course
06:39:56 * jethr0 has implemented libc in haskell once when he thought that compiling c code under the house operating system was a likely scenario ;)
06:40:22 <Grey_Fox> to be honest, I'm more interested in the theory than practice
06:40:56 <Grey_Fox> is there a good tutorial on monads?
06:41:06 <jethr0> hehe, then read everything by the simons and oleg. some stuff on sigfpe is really interesting too. many good papers out there (left-fold IO, zippers, comonads, ...)
06:41:10 <jfoutz> typeclassopedia! it's neato
06:41:21 <jfoutz> @where typeclassopedia
06:41:21 <lambdabot> Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
06:41:26 <Saizan> ?google all about monads
06:41:27 <lambdabot> http://www.haskell.org/all_about_monads/
06:41:27 <lambdabot> Title: All About Monads
06:41:49 <Saizan> mmh, i've yet to read the typeclassopedia
06:41:53 <jfoutz> not just monads, but it fits large chunks of haskells typeclasses
06:42:02 <quicksilver> Grey_Fox: there are many tutorials on monads
06:42:08 <quicksilver> Grey_Fox: there is no consensus that any of them is good
06:42:13 <quicksilver> I think I like Cale's.
06:42:19 <Grey_Fox> :S
06:42:23 <jfoutz> Saizan: but you're a little more sophisticated haskell user.
06:43:11 <int-e> @index secondM
06:43:11 <lambdabot> bzzt
06:43:20 <jethr0> "_no_ consensus that _any_ is good" ^_^
06:43:20 <quicksilver> Grey_Fox: there are even anti-tutorial tutorials
06:43:38 <quicksilver> Grey_Fox: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
06:43:40 <jethr0> and a monad tutorial timeline in order to keep it all straight *g*
06:43:43 <quicksilver> (it's that byorgey again)
06:43:45 <int-e> sniff. (secondM :: Monad m => (a -> m b) -> (x, a) -> m (x, a))
06:43:51 <quicksilver> jethr0: of course, my grammar is poor
06:43:59 <quicksilver> jethr0: no consense that any _be_ good
06:44:03 <jethr0> nono, it just sounded as if they all suck, hehe
06:44:06 <quicksilver> woudl be correct grammar
06:44:20 <int-e> hmm, m (x, b) of course.
06:44:53 <int-e> @pl \(x, a) -> ?f a >>= (,) x
06:44:53 <lambdabot> (line 1, column 12):
06:44:53 <lambdabot> unexpected "?"
06:44:53 <lambdabot> expecting lambda abstraction or expression
06:45:00 <int-e> @pl \f (x, a) -> f a >>= (,) x
06:45:01 <lambdabot> (`ap` snd) . (. fst) . (. (,)) . flip . ((>>=) .)
06:45:18 <EvilRanter> @pl \(x, a) -> f a >>= (,) x
06:45:18 <lambdabot> uncurry (flip ((>>=) . f) . (,))
06:45:27 <jethr0> yes, dots and dots
06:45:45 <quicksilver> Grey_Fox: back issues of The.Monad.Reader are a good thing to glance through, actually
06:46:20 <int-e> @pl \f (x, a) -> f a >>= return . (,) x
06:46:20 <lambdabot> (`ap` snd) . (. fst) . (. ((return .) . (,))) . flip . ((>>=) .)
06:46:31 <int-e> (still ugly, but at least it's correct now)
06:47:26 <int-e> @pl \f (x, a) -> (,) <$> pure x <*> f a
06:47:26 <lambdabot> (`ap` snd) . (. fst) . ((((,) <$>) .) .) . flip ((.) . (<*>) . pure)
06:47:27 <Grey_Fox> ok
06:48:50 <quicksilver> int-e: HaRe has a monadification refactoring doesn't it?
06:49:26 <quicksilver> stick an "m" before all types in negative position.
06:49:27 <quicksilver> IIRC.
06:49:36 <int-e> I don't know
06:49:49 <quicksilver> it's completely mechanical.
06:49:50 <Grey_Fox> so, by implementing the Prelude, do you mean looking at the documentation for the function and then trying to write the corresponding haskell code ?
06:51:11 <jethr0> my chatzilla doesn't wrap long lines anymore ;(
06:52:02 <jethr0> Grey_Fox: exactly. stuff like foldl, foldr, sequence, etc. were quite enlightening for me. and implementing the standard monad helped me understand deeply too
06:53:03 <jethr0> and by implementing i mean implementing them properly (i.e. minimal use of explicit recursion, etc.). then you can compare your version with the one in the prelude and learn from that again ;)
06:53:38 <Grey_Fox> k
06:55:21 <Grey_Fox> jethr0: my chatzilla doesn't either
06:55:35 <jethr0> but i'm pretty sure it used to ;(
06:56:12 <int-e> , ''Maybe
06:56:37 <EvilRanter> preflex: seen lunabot
06:56:38 <preflex>  lunabot was last seen on #haskell 1 day, 10 hours, 59 minutes and 17 seconds ago, saying:  luna: Not in scope: `yourMom'
06:56:41 <int-e> TH question, what's the equivalent of ''Maybe for ''()?
06:57:04 <EvilRanter> ''()
06:57:07 <EvilRanter> :)
06:57:24 <EvilTerran> there's ''(,) etc, too
06:57:47 <EvilTerran> likewise '() '(,) '(+) etc
06:57:56 <Grey_Fox> so [a] or [] ?
06:58:01 <int-e> ok. it's something else going wrong then, hmm.
06:58:22 <Asztal> jethr0: mine neither, had to clear the tab, weird
06:58:28 <jethr0> so, ''() has kind * while ''(,) has kind *->*->*, right?
06:58:45 <jethr0> Asztal: what do you mean "clear the tab"?
06:58:48 <EvilTerran> jethr0, () has kind * and (,) has kind * -> * -> *, yes
06:58:54 <Asztal> jethr0: the chatzilla tab
06:59:11 <EvilTerran> jethr0, but ''() and ''(,) are values, of type Language.Haskell.TH.Syntax.Name
06:59:21 <EvilTerran> jethr0, (well, when you're using the TemplateHaskell extension)
06:59:51 <Grey_Fox> jethr0: right click the tab you're in and then click on "Clear tab"
07:00:34 <jethr0> i'm not quite sure on the kind vs. type thing. is (,) a type or is (a,b)?
07:00:56 <jethr0> thx
07:00:57 <Athas> @hoogle [a] -> [a] -> Bool
07:00:58 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
07:00:58 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:00:58 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
07:01:03 <Athas> Excellent.
07:01:13 <lilac> if you have a type constructor A' in scope, does TH still parse 'A' as a character literal? ;)
07:01:23 <int-e> jethr0: (,) is a type constructor. you might say it's a type of kind * -> * -> *
07:01:24 <jethr0> (==)
07:02:23 <jethr0> k, so both (,) and (a,b) are types, but only the former is a type constructor. what do you call the result of a type constructor?
07:02:27 <int-e> but it's less confusing to call only things of kind * 'types'.
07:02:35 <Grey_Fox> a type?
07:02:43 <int-e> (imho)
07:03:00 <int-e> jethr0: it depends on its kind.
07:03:17 <jethr0> i tend to agree with int-e. otherwise a (,) is both a type and a type constructor.
07:03:39 <int-e> (,) a  is still a type constructor, I'd say.
07:03:55 <jethr0> int-e: so what would you call (,)? type constructor?
07:04:05 <int-e> yes.
07:04:14 <EvilTerran> by my terminology, (,) is a type constructor, and a type expression
07:04:27 <quicksilver> but then you say "kinds classify {types and type constructors}"
07:04:27 <EvilTerran> and (a,b) is a type, and a type expression, but not a type constructor
07:04:28 * Beelsebob notes that id is both a value and a function
07:04:35 <quicksilver> instead of the more normal "kinds classify types"
07:04:43 <Beelsebob> no reason to consider being both a type and a type constructor a bad thing
07:05:00 <jethr0> Beelsebob: isn't any function also a value?
07:05:08 <quicksilver> is "(,) a" a type constructor?
07:05:14 <jethr0> i.e. first class citizenship
07:05:18 <int-e> but there's no reason to treat types and values in the same way either.
07:05:19 <quicksilver> or is that privilege reserved for "(,)" itself
07:05:20 <Beelsebob> jethr0: exactly
07:05:26 <EvilTerran> quicksilver, i'd call it a type expression, but not a type constructor or a type proper
07:05:35 <quicksilver> in which case "(,) a" is a partially-applied type constructor or somethign
07:05:36 <Beelsebob> jethr0: my point was that to consider (,) not a type would be demoting it to a lower class citizen
07:05:43 <int-e> (since the hierarchy, as far as Haskell is concerned, stops at kinds)
07:05:58 <jethr0> Beelsebob: point taken, thx
07:06:14 <Saizan> quicksilver: type function? :)
07:06:26 <quicksilver> Saizan: perhaps, yes.
07:06:41 * quicksilver would call them all types, and call "types of kind *" by some other name
07:06:44 <quicksilver> like "type of kind *" ;0
07:06:50 <quicksilver> but possibly "value types"
07:07:03 <EvilTerran> "fully-applied types"
07:07:12 <jethr0> trivial type *g*
07:07:14 <Saizan> i've seen concrete/proper types used for them
07:07:44 <jethr0> "boring type"
07:07:45 <quicksilver> it's a feature of haskell that all values belong to a type of kind *, but not of all possible systems
07:07:49 <benmachine> concrete is the word I've heard
07:07:59 <jethr0> "not of all possible systems"?
07:08:06 <quicksilver> you can imagine systems which have values of higher-kinded types, I think
07:08:18 <quicksilver> or can you?
07:08:31 * quicksilver stretches his imagination in a thoughtful friday afternoon kind of way
07:08:36 <quicksilver> EINSUFFICIENTCOFFEE
07:08:41 <pao> @hoogle
07:08:41 <lambdabot> No query entered
07:08:41 <lambdabot> Try --help for command line options
07:08:46 <pao> @paste
07:08:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:09:54 <pao> is this the most reasonable way to output utf8? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9033#a9033
07:09:58 <jethr0> quicksilver: i can imagine a recursive value having an infinite type...
07:11:19 <Saizan> pao: there's also System.IO.UTF8.putStrLn from utf8-string
07:11:31 <Saizan> pao: if you start with String
07:12:12 <jethr0> quicksilver: or (x, undefined) having type "forall b . (,) a b"
07:12:35 <path[l]> someone once told me I could submit some code for a "shootout" to be sped up
07:12:39 <path[l]> where can I do that?
07:12:47 <pao> Saizan: thanks
07:12:54 <pao> Saizan: nice to see you :-)
07:12:57 <Jafet> Presumably they are talking about *the* shootout
07:13:01 <pao> Saizan: thanks
07:13:13 <Jafet> http://shootout.alioth.debian.org/
07:13:43 <jethr0> path[l]: i think you can post it on the wiki and then some of the guys will upload it to the shootout (dons, ...)
07:13:57 <path[l]> ah ok. Is that the wiki?
07:14:01 <jethr0> @wiki
07:14:01 <lambdabot> http://www.haskell.org/haskellwiki/
07:14:14 <path[l]> thanks
07:14:24 <jethr0> @wiki Great language shootout
07:14:24 <lambdabot> http://www.haskell.org/haskellwiki/Great_language_shootout
07:15:19 <jethr0> on that site is also recommendations for submitting code
07:16:24 <path[l]> ah
07:16:43 <path[l]> hmm I feel like my solution will be shot down for lameness, but oh well
07:18:47 <jethr0> in general, few things are ever "shot down" in #haskell ;)
07:18:59 <fasta> Haskell shows 20 decimal digits of a Double, Python shows 21. Where does that difference come from?
07:19:22 <path[l]> hehe ok =p
07:19:42 <jethr0> display settings, different double specifications, ...
07:20:09 <jethr0> fasta: are the first 20 digits the same (modulo rounding the 21st?)
07:20:15 <fasta> jethr0: yes
07:20:48 <fasta> Basically, what I want is to get the 21 digits also in Haskell. Is there a way to show a number in that way?
07:21:32 <jethr0> if you need precision you could change to an arbitrary precision rational type. or do you need the equality with python?
07:21:43 <fasta> jethr0: just equality with Python.
07:22:07 <jethr0> fasta: are you using show in haskell?
07:22:19 <Saizan> mh, probably the Numeric module
07:22:20 <roconnor> fasta: reimplement Phython's Double -> String function in Haskell
07:22:28 <int-e> > printf "%40.33d" (1/7)
07:22:30 <lambdabot>   Add a type signature
07:22:33 <int-e> > printf "%40.33d" (1/7) :: String
07:22:34 <lambdabot>   "* Exception: Printf.printf: bad argument
07:22:43 <int-e> > printf "%40.33d" (1/7 :: Double) :: String
07:22:45 <lambdabot>   "* Exception: Printf.printf: bad argument
07:22:58 <int-e> > printf "%40.33f" (1/7 :: Double) :: String
07:22:59 <lambdabot>   "     0.142857142857142850000000000000000"
07:23:02 <fasta> jethr0: no, I use showFFloat Nothing double ""
07:23:21 <Jafet> For 64-bit IEEE double, the mantissa is only 16 digits...?
07:23:33 <RayNbow> > text $ showCReal 50 pi
07:23:34 <lambdabot>   3.14159265358979323846264338327950288419716939937511
07:24:02 <RayNbow> > text $ drop 50 $ showCReal 100 pi
07:24:03 <lambdabot>   105820974944592307816406286208998628034825342117068
07:24:19 <quicksilver> I think fasta's number are 19 and 20, not 20 and 21
07:24:27 <quicksilver> and I think it includes the "." and the leading 0
07:24:33 <quicksilver> > length (show (1/7))
07:24:34 <lambdabot>   19
07:24:44 <fasta> quicksilver: yes, you are right.
07:24:46 <int-e> > showFFloat Nothing (1/7 :: Double) ""
07:24:47 <lambdabot>   "0.14285714285714285"
07:25:10 <roconnor> > fix $ ((logBase10 2)*) . fromIntegral . floatDigits
07:25:11 <lambdabot>   Not in scope: `logBase10'
07:25:17 <roconnor> > fix $ ((logBase 10 2)*) . fromIntegral . floatDigits
07:25:18 <lambdabot>   15.954589770191001
07:25:32 <roconnor> Jafet: less than 16
07:25:35 <Jafet> What is the underlying representation used for Double?
07:25:48 <quicksilver> on typical setups, it's IEEE 64bit FP, jafet
07:25:56 <Jafet> Indeed
07:26:04 <int-e> which has 52 bits mantissa.
07:26:14 <roconnor> > floatDigits undefined
07:26:16 <lambdabot>   53
07:26:23 <roconnor> > floatRadix undefined
07:26:25 <lambdabot>   2
07:26:29 <quicksilver> under some circumstances you get to use the 80 bit x87 doubles
07:26:35 <int-e> (1 extra bit for normalized numbers)
07:26:36 <quicksilver> but you never get to observe the answer in 80bit form
07:26:39 <RayNbow> > text $ drop (50+2) $ showCReal 100 pi  -- a bit better, also gotta drop "3."
07:26:41 <lambdabot>   5820974944592307816406286208998628034825342117068
07:26:47 <benmachine> > floatDigits (undefined :: Float)
07:26:48 <lambdabot>   24
07:26:58 <quicksilver> so that's not very useful
07:27:02 <RayNbow> hmm...
07:27:18 <int-e> > 52 * log 2 / log 10
07:27:19 <lambdabot>   15.65355977452702
07:27:56 <roconnor> > printf "%40.33f" (1/7 :: Double) :: String
07:27:57 <lambdabot>   "     0.142857142857142850000000000000000"
07:28:03 <roconnor> > printf "%40.33f" (1/7 :: Rational) :: String
07:28:04 <lambdabot>   No instance for (Text.Printf.PrintfArg
07:28:04 <lambdabot>                     (GHC.Real.Ratio ...
07:28:54 <quicksilver> fasta: for me, if I type (1.0/7) at a python prompt
07:28:57 <quicksilver> > 1/7
07:28:58 <lambdabot>   0.14285714285714285
07:29:06 <quicksilver> fasta: the last digit is the 3rd 5
07:29:09 <quicksilver> (just like in haskell)
07:29:23 <jethr0> fasta: floating point equality under different environments is a very fickle thing
07:29:23 <quicksilver> I don't see a python/haskell difference
07:29:37 <roconnor> I don't know why printf puts all those 0's.  A Double is some (diadic) rational number.  It should print that.
07:29:55 <int-e> > (>>= show) . unfoldr (return . properFraction . (*10)) $ (1/7 :: Double)
07:29:56 <lambdabot>   "14285714285714283811046243499731644988059997558593750000000000000000000000...
07:30:11 <quicksilver> roconnor: because that's the specification of the %f format specifier
07:30:18 <jethr0> fasta: why do you need the exact match?
07:30:25 <roconnor> that's a dumb spec
07:30:26 <quicksilver> roconnor: you specifically asked for those 0s
07:30:41 <araujo> hello there guys, how are you?
07:30:43 <quicksilver> roconnor: I don't think it is. Why ask for %40.33f if that isn't what you want?
07:30:43 <int-e> quicksilver: not really
07:30:59 <int-e> quicksilver: we asked for 714283811046243499731644988059997558593750000000000000000000000
07:31:01 <roconnor> toRational (1/)
07:31:06 <roconnor> > toRational (1/7)
07:31:06 <quicksilver> oh, I see
07:31:07 <lambdabot>   2573485501354569 % 18014398509481984
07:31:11 <fasta> jethr0: just to minimize the differences between the two systems.
07:31:15 <roconnor> I expect to see that number
07:31:23 <quicksilver> OK, sorry, misunderstood your complaint.
07:31:34 <roconnor> > realFrac (1/7) :: CReal
07:31:35 <lambdabot>   Not in scope: `realFrac'
07:31:37 <quicksilver> because doubles are not, denotationally, diadic rational numbers
07:31:40 <roconnor> > realToFrac (1/7) :: CReal
07:31:41 <lambdabot>   0.1428571428571428492126926812488818541169
07:31:54 <quicksilver> denotationally, they are diadic rational approximations to real numbers
07:31:55 <araujo> hello guys
07:31:57 <araujo> how it goes?
07:32:10 <jethr0> well, as always
07:32:14 <roconnor> quicksilver: still, might as well print the most accurate representation. Why round even more?
07:32:17 <quicksilver> as such, it makes sense to clip the display in a way which signifies the approximation.
07:32:34 <roconnor> that is perhaps a valid argument
07:32:52 <roconnor> perhaps
07:32:56 <quicksilver> > 0.14285714285714285
07:32:57 <lambdabot>   0.14285714285714285
07:33:00 <quicksilver> > 0.14285714285714286
07:33:01 <lambdabot>   0.14285714285714285
07:33:04 <quicksilver> > 0.14285714285714287
07:33:05 <lambdabot>   0.14285714285714288
07:33:14 <jethr0> *ahh*
07:33:15 <Jafet> It only accounts for representation error, though. A competent programmer has to track calculation and data input errors.
07:33:15 <quicksilver> I would argue it should clip one more digit, actually
07:33:19 <int-e> > fromRational (toRational (1/7)) - realToFrac (1/7) :: CReal
07:33:20 <lambdabot>   0.0
07:33:22 <quicksilver> to get naive round-trip with string.
07:33:36 <quicksilver> ;)
07:33:41 <roconnor> @src realToFrac
07:33:41 <lambdabot> realToFrac = fromRational . toRational
07:33:43 <Jafet> So the default display should be rarely used.
07:33:52 <int-e> Oh. Right, my code introduces a small error in the first few iterations.
07:33:59 <quicksilver> Jafet: agreed yes
07:34:06 <int-e> subtle.
07:35:02 <quicksilver> surprisingly, there is quite a good treatment of these issues in the python docs : http://docs.python.org/tutorial/floatingpoint.html
07:35:07 <quicksilver> not quite where I'd expect to find it ;)
07:35:17 <quicksilver> python does indeed aim for string round-tripping
07:35:31 <jethr0> surprising                      for a python doc *g*
07:35:38 <quicksilver> "...produces 17 significant digits because it turns out that?s enough (on most machines) so that eval(repr(x)) == x exactly for all finite floats x,..."
07:35:57 <quicksilver> jethr0: there is no equivalent detail documentation in the haskell docs on Double :P
07:36:18 <quicksilver> > 0.14285714285714288
07:36:19 <lambdabot>   0.14285714285714288
07:36:22 <quicksilver> > 0.14285714285714285
07:36:22 <Jafet> All haskell programmers know all about floating-point anyway.
07:36:23 <lambdabot>   0.14285714285714285
07:36:26 <int-e> Haskell hates floats anyway :)
07:36:29 <Jafet> (Amirite?)
07:36:57 <int-e> > realToFrac (1/0 :: Float)
07:36:58 <lambdabot>   3.402823669209385e38
07:37:03 <quicksilver> > 0.14285714285714286 == 0.14285714285714285
07:37:05 <lambdabot>   True
07:37:15 <quicksilver> yes, that's why then
07:37:20 <quicksilver> same reason as python
07:37:20 <int-e> (ghc's optimizer changes that result)
07:37:36 <quicksilver> to embed string double equality in string equality under Show
07:37:41 <quicksilver> I think that is a good property to aim for
07:37:41 <jacobian> how do you get a cabal-install to use a hackage server
07:37:47 <quicksilver> roconnor: good enough answer?
07:37:58 <int-e> jacobian: you mean a different one?
07:38:13 <jacobian> my install says it doesn't have one
07:38:29 <int-e> jacobian: .cabal/config usually contains a line like  remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
07:38:40 <int-e> there may be issues with proxies though
07:38:42 <jacobian> ahhh
07:38:53 <jacobian> I made my config before running the first time
07:39:36 <int-e> ah, let cabal generate its own - it's a useful reference of available options.
07:42:51 <ManateeLazyCat> Saizan: I have implement dynamic Gtk application, so cool. Now, i can use Manatee (My project name) developing itself, and update dynamic!
07:42:55 * ManateeLazyCat Sweet.....
07:46:12 <Saizan> ManateeLazyCat: cool :)
07:46:21 * mux_ wishes first and second were in Data.Tuple
07:47:07 <yrlnry> I have a problem where an operation that I think should not be performed is being performed anyway.  Code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9038#a9038
07:47:51 <dooof> making a game: what would you recommend for storing a number of dynamic game objects (the number of objects and the objects can change at runtime)? right now I'm using a list of IORefs in a state monad. is there an efficient pure way?
07:48:09 <quicksilver> yrlnry: in "safeGet" you always call get
07:48:17 <quicksilver> yrlnry: surely you want to only call get inside the if
07:48:24 <yrlnry> Why does it call get even if v is unused?
07:48:37 <quicksilver> yrlnry: because you told it to.
07:48:41 <yrlnry> If z is true, the do block should return Nothing without ever calling for the value of v.
07:48:46 <dooof> I also need to be able to store references to objects
07:48:47 <quicksilver> yrlnry: sure
07:48:51 <quicksilver> yrlnry: but it still calls get.
07:49:03 <quicksilver> yrlnry: line 44 calls get unconditionally, it doesn't matter whether you use v or not
07:49:35 <yrlnry> Why does it not lazily defer the calling of get until the time that the value of v is inspected?
07:50:03 <benmachine> what if qGet (Q []) = (error "get attempted on empty queue", Q [])
07:50:14 <Jafet> dooof, a functional data structure?
07:50:14 <Lemmih> yrlnry: Same reason 'x3' fails even if you don't look at the result of 'get'.
07:50:26 <quicksilver> yrlnry: because it does not.
07:50:35 <benmachine> that might give you the laziness you needed, although the solutions everyone else presented are probably better
07:50:40 <yrlnry> What is the error in my understanding of the laziness?
07:50:50 <quicksilver> yrlnry: monadic actions are not lazy
07:50:57 <Lemmih> yrlnry: More in your understanding of Monads, really.
07:51:03 <quicksilver> yrlnry: the value bound to them will be
07:51:06 <quicksilver> (as all values are)
07:51:07 <yrlnry> Okay, what is the error in my understand of monads?
07:51:16 <quicksilver> but that actual execution of the action (here 'get') is no lazy
07:51:31 <dooof> Jafet: can you elaborate? :)
07:51:36 <Lemmih> yrlnry: Do you see why 'x3' fails?
07:51:36 <yrlnry> the (v <- get) line is equivalent to   get >>= (\v -> if z then ... ), correct?
07:51:38 <quicksilver> indeed, it can't be, that wouldn't make sense, it's not what 'lazy' means, although I do understand what you mean.
07:51:50 <quicksilver> "lazy" refers to deferring a pure calculation until it is needed
07:52:00 <benmachine> yrlnry: yeah, and if get returns undefined, that's undefined >>= (\v -> ...
07:52:06 <quicksilver> knowing that a pure calculation can be carried out at any time - or never - without doing harm.
07:52:10 <yrlnry> benmachine:  Aha!  Thanks.
07:52:11 <Jafet> dooof, elaborate on what?
07:52:20 <quicksilver> monadic actions are, well, actions
07:52:22 <ManateeLazyCat> Saizan: I use Data.Binary keep minimum gtk state for through reboot, it can restore state after reboot new version, then rebuild widget. Now, my project's develop speed will faster and faster..... Just rebuild speed need optimize, but core part have finish..... I think i will release my project after one or two month, then it provide "A full dynamic Haskell developing environment for Haskell hacker" ...
07:52:35 <dooof> Jafet: what did you mean by your comment?
07:52:36 <quicksilver> it may be you have been confused by the so-called "lazy IO"
07:52:45 <benmachine> yrlnry: I'm not sure if what I said is entirely accurate, but it kind of makes sense, right?
07:52:48 <Jafet> Functional data structures are immutable, so you do not have to use IO to manage state
07:52:49 <yrlnry> I don't think I have been confused by lazy IO.
07:52:53 <quicksilver> for the record, lazy IO is (a) an extremely bad name, because it's not lazyiness
07:53:04 <quicksilver> (b) a blight on the language and its semantic credentials.
07:53:08 <yrlnry> benmachine:  No, now I'm confused again.  Suppose I have  (\v -> 37) undefined.   This returns 37.
07:53:18 <benmachine> yrlnry: yeah
07:53:53 <yrlnry> Oh, I see.  >>= in this *particular* monad forces evaluation of its first argument, because that's how I wrote it.
07:54:00 <yrlnry> But in general, that might not be true.
07:54:07 <benmachine> I assume so
07:54:15 <Saizan> ManateeLazyCat: so you decided that rebuilding the gtk widgets at reboot wasn't too costly?
07:54:17 <benmachine> or, something somewhere is strict in something
07:54:25 <benmachine> such that when get gives an error it hurts
07:54:29 <greap> Does anyone know that logo where there is a circle with about 5 FP symbols around it? (bind, lambda, etc...)
07:54:37 <benmachine> I think it'd be a very strange >>= that was lazy in the first argument
07:54:57 <dolio> > (undefined >>= \_ -> ask) 5
07:54:58 <lambdabot>   5
07:55:05 <quicksilver> yrlnry: it's not about evaluation.
07:55:06 <benmachine> fine :(
07:55:08 <Saizan> greap: that was the haskell logo before to current one
07:55:11 <Vanadium> http://www.haskell.org/haskellwiki/Haskell_logos#Previous_Haskell.org_logo
07:55:14 <quicksilver> yrlnry: it's about the execution of monadic actions.
07:55:18 <ManateeLazyCat> Saizan: Yes, rebuild widgets is too costly, but it can keep current develop environment after reboot.
07:55:20 <Lemmih> benmachine: runReader (undefined >> return ()) ()
07:55:29 <greap> Saizan: is there a copy somewhere?
07:55:32 <yrlnry> quicksilver:  how so?
07:55:35 <ManateeLazyCat> Saizan: Or you have other better suggestions?
07:55:38 <quicksilver> yrlnry: in "do { v <- a; b }" the *action* a is unconditionally performed
07:55:42 <Lemmih> Ask, I'm too slow.
07:55:43 <dooof> Jafet: okay, I see what you mean. I was looking for more concrete solutions. For example I could use a Map so that I can use keys as references whenever I need to have one from one game object to another - but I'd like to know if there's a better way
07:55:46 <quicksilver> yrlnry: this is unrelated to evaluation.
07:55:50 <greap> Saizan: Never mind. Tracked it down on the wiki :)
07:55:53 <quicksilver> yrlnry: it is simply what monads mean.
07:56:10 <Saizan> ManateeLazyCat: no, i was just curious :)
07:56:14 <yrlnry> quicksilver:  Are you sure it is unconditionally performed?  Doesn't it depend on the behavior of >>= for the particular monad?
07:56:18 <quicksilver> no.
07:56:23 <quicksilver> the action is unconditionally performed.
07:56:28 <quicksilver> that is what "action" and "performed" mean.
07:56:46 <ManateeLazyCat> Saizan: Example, i use Manatee editor itself module, it will restore all edit status after entry new version, otherwise i need restore those status after init, but it's impossible if too many buffers open.
07:56:47 <quicksilver> what performing an action actually *involves* will vary from monad to monad.
07:56:59 <quicksilver> it presunably involves some kind of evaluation, because that's how haskell does stuff
07:57:05 <quicksilver> btu quite how much evaluation can vary
07:57:08 <ManateeLazyCat> Saizan: Dynamic reboot just for improve developing speed.
07:57:18 <ManateeLazyCat> Saizan: Like emacs's develop module.
07:57:37 <Saizan> ManateeLazyCat: i see
07:57:52 <Jafet> dooof, obviously your problem has 5000 various subtleties that you will reveal one-by-one after I tell you that I do not see any problem with that...
07:57:59 <Jafet> But I do not see any problem with that.
07:58:34 <benmachine> yrlnry: in your case, performing a get changes the state of the queue
07:58:45 <benmachine> so even if the v isn't used, the queue is still changed
07:59:28 <benmachine> because retrieving a value isn't the only thing get does
07:59:51 <yrlnry> benmachine:  and eventually the program displays the state of the queue, so that forces the get to occur.
07:59:57 <quicksilver> no.
08:00:05 <quicksilver> it always occurs., when you tell it to
08:00:14 <quicksilver> it does not eventually occur because it gets forced
08:00:16 <yrlnry> No, it doesn't always occur.
08:00:34 <quicksilver> it does.
08:00:42 <yrlnry> Because if I never ask GHCI to display the value of  x4, it doesn't.
08:00:46 <quicksilver> you're wrong
08:00:50 <quicksilver> it *does* occur
08:00:54 <quicksilver> it's just you don't see the error message
08:01:04 <quicksilver> because the error message is a _|_ hiding in a place you didn't force
08:01:10 <benmachine> I think we may have differing definitions of occur here?
08:01:11 <quicksilver> but it is there, so it does "occur"
08:01:12 <dooof> Jafet: okay, thank you
08:01:19 <quicksilver> yes, absolutely
08:01:38 <quicksilver> I'm being slightly agressively pedantic with yrlnry's definitions
08:01:40 <yrlnry> Doesn't the get remain an unevaluated thunk until something forces its evaluation?
08:01:53 <quicksilver> but I'm doing so because I believe I am giving the correct intuition.
08:02:02 <yrlnry> Please continue.
08:02:08 <quicksilver> yrlnry: yes, it does. As benmachine points out, it depends what you think 'occur' means.t
08:02:08 <lilac> quicksilver: this is 'occur' in the sense that a tree falling in a forest with no-one around 'occur's, right? :)
08:02:09 <Saizan> (what is the sound of a _|_ if no one is there to force it?)
08:02:14 <quicksilver> lilac: yes, it is.
08:03:01 <yrlnry> Suppose I have   launchMissiles :: IO ()    and I run a GHCI session and let x = launchMissiles.  Do this missiles launch?
08:03:01 <lilac> it's _|_, whether you look or not, but if you look, you're _|_ too!
08:03:05 * Lemmih bets on "Poof".
08:03:27 <yrlnry> And then suppose I launchMissiles >> print.  Does that launch the missiles?
08:03:34 <quicksilver> yrlnry: the first case, no
08:03:41 <quicksilver> yrlnry: useing "let" does not perform an action
08:03:57 <quicksilver> yrlnry: "launchMissiles >> print" is merely a composite action
08:04:09 <lilac> yrlnry: it sounds like you're missing the semantic difference between evaluating a computation and executing an IO action
08:04:09 <quicksilver> just writing that expressionin a file or on the screen doesn't necessarily perform it
08:04:26 <quicksilver> but, if you link that action into main (since we're now talking about IO)
08:04:29 <yrlnry> Maybe I'm missing the semantic difference between evaluating a computation and executing an IO action.
08:04:31 <quicksilver> so it gets performed
08:04:42 <quicksilver> yes, I think you are.
08:04:49 <yrlnry> What is the semantic difference between evaluating a computation and executing an IO action.
08:04:52 <yrlnry> ?
08:04:54 <lilac> yrlnry: ok, a value of type "IO a" is a pure action which doesn't /do/ anything. it's just a value
08:04:59 <yrlnry> Sure.
08:04:59 <quicksilver> I don't know how to answer that.
08:05:03 <quicksilver> they are entirely different things.
08:05:12 <yrlnry> How are they different?
08:05:13 <quicksilver> evaluation is just the process of evaluating a value
08:05:19 <quicksilver> execution is something else
08:05:22 <lilac> yrlnry: forcing a value of type "IO a" operationally might bottom out, but won't /perform/ an IO action
08:05:24 <quicksilver> it's actually "running" your actions
08:05:35 <yrlnry> What performs IO actions?
08:05:42 <quicksilver> GHC, or the RTS
08:05:44 <lilac> yrlnry: but if forcing the value bottoms out, the value /is/ bottom, whether you forced it or not
08:05:45 <quicksilver> depending on your perspective.
08:06:00 <quicksilver> puttin stuff into 'main' directly or indirectly
08:06:02 <lilac> yrlnry: the magic incantation 'main = ' performs IO actions.
08:06:07 <quicksilver> (or typing them on a GHCi command line too)
08:06:08 <yrlnry> Okay.
08:06:26 <yrlnry> quicksilver:  This is why I keep asking questions of the form "If I put .... into ghci, what does it do?"
08:06:26 <quicksilver> with other monads, there is typically a 'run' function
08:06:41 <quicksilver> (your runQueueOp being one exampel)
08:07:10 <quicksilver> "action" and "perform" are overloaded because monads are a typeclass
08:07:17 <yrlnry> Sure.  But runQueueOp only performs the queue operations because I later ask the RTS to display some value from the result of the computations.
08:07:24 <quicksilver> no.
08:07:26 <Lemmih> yrlnry: Imagine that IO = GetLine | PutStr | Bind IO IO. Composing values of type IO is different from actually reading and writing to stdin/stdout.
08:07:31 <quicksilver> now you've confused it again, yrlnry.
08:07:43 <quicksilver> runQueueOp constructs a value with represents performing all those actions.
08:07:53 <quicksilver> that's what I mean by 'the action is always performed'
08:07:54 <ManateeLazyCat> Saizan: Rebuild widget is very fast, 30 widgets less than 1 second, i think rebuild process will be faster. Save/Restore state process cost is little, example, I open file "A.hs" before reboot, i just save Filename instead file-content. If gtk is MVC model, i just save minimum state for restore `M` (model data for widget), then use `M` rebuild `V` (widget).
08:08:04 <quicksilver> the result of performing all those actions is hidden in that value
08:08:06 <Jafet> > (\x -> 0) (putStr "lalala")
08:08:07 <lambdabot>   0
08:08:13 <quicksilver> (there maye be _|_s deep inside)
08:08:16 <Jafet> > (putStr "lalala")
08:08:17 <lambdabot>   <IO ()>
08:08:24 <quicksilver> but you don't *evaluate* that result until you do.
08:09:12 <yrlnry> quicksilver:  how can there be _|_ values "deep inside" an unevaluated expression?  Until the expression is evaluated, it doesn't have a value.
08:09:21 <yrlnry> it's an unevaluated expression.
08:16:34 --- mode: irc.freenode.net set +o ChanServ
08:16:34 <quicksilver> because the reader monad is a very extreme example
08:16:34 <yrlnry> Oh, i think "perform" has some special technical meaning here of which I was unaware.
08:16:34 <quicksilver> it can perform actions without evaluating them
08:16:34 <quicksilver> yes, it does
08:16:34 <quicksilver> and that's the key to the understanding here
08:16:34 <yrlnry> when we write  x >>= f, we say x is "performed"?
08:16:34 <lpsmith> what's "perform" mean?  I haven't really heard of that before
08:16:34 <quicksilver> yes.
08:16:34 <yrlnry> Are there any other cases where we describe something as "performed"?
08:16:34 <quicksilver> lpsmith: "a >> b" performs a and then b
08:16:43 <quicksilver> "perform" on its own is not a technical word, I should make that clear
08:16:50 <quicksilver> but "perform an action" is a precise statement in the context of monads
08:16:53 <maltem> Is "perform" now coined as "used somewhere to the left of a (>>=)"?
08:17:06 <shachaf> Or "execute", perhaps.
08:17:08 <quicksilver> you will also hear things like "executed"
08:17:13 <quicksilver> and "performed its effects"
08:17:16 <lpsmith> quicksilver:  I wouldn't call that "performed"
08:17:31 <lpsmith> maybe  run (a >> b)   performs a and then b
08:17:46 <quicksilver> lpsmith: I was being lazy with the typing
08:18:01 <shachaf> But just (runState f 5) "performs" f.
08:18:01 <lpsmith> but depending on a,  b,  and >>=,   b might be performed multiple times, or not at all
08:18:18 <maltem> In the context of IO, "perform" means "run on a machine", quite orthogonally
08:18:21 <quicksilver> lpsmith: "(a >> b) represents the action which, when performed, performs "a" and then performs "b".
08:18:48 <ManateeLazyCat> Saizan_: More complicated situation is restore running process, such as process for IRC-client....
08:19:10 <maltem> quicksilver, ok, with that wording it's consistent with IO :)
08:19:22 <quicksilver> to talk about monads in general you have to coin a verb for whatever you do with effects, as opposed to evaluation.
08:19:32 <quicksilver> because effects are different from evaluation.
08:19:50 <quicksilver> perform is a natural choice but I'm not suggesting this is some formal terminology written down somewhere.
08:19:54 <jacobian> frobbing?
08:20:00 <quicksilver> you do need *some* word if you're going to discuss this though ;)
08:20:05 <quicksilver> "execute" is another one people use.
08:20:56 <shachaf> > ("abc" >> "defg") -- Keep in mind that here the Strings are "executed".
08:20:57 <lambdabot>   "defgdefgdefg"
08:21:04 <maltem> I fear the natural choice is due to common monads being IO, Reader, Writer, State, that is, monads with a natural notion of "effects"
08:21:07 <lilac> the same could be said of applicatives. f <*> x performs the effects of f then performs the effects of x
08:21:13 <ManateeLazyCat> Saizan_: I use `dyre` package manage save/restore state, and now project like Xmonad or Lambdabot that suppress "fully dynamic core", and not "static core", that is to say, i can rewrite all code in my project, and not like Emacs, static core is can't modified dynamic.
08:22:09 <jad4> maltem, actually I'd say [ ] and Maybe are as if not more common than all those Monads
08:22:17 <quicksilver> shachaf: absolutely.
08:22:33 <quicksilver> lilac: right.
08:22:37 <Lemmih> yrlnry: Has everything been made clear?
08:22:39 <yrlnry> quicksilver:  Suppose I say something like  x= a >> b.  Am I performing an action here?  I would have said no; I am only constructing a value which represents a compound action, and which, when eventually performed itself, will perform a and then b.
08:22:49 <quicksilver> yrlnry: yes. 100%.  :)
08:22:52 <maltem> jad4: True, but would anyone coin "perform" when thinking of the list and maybe monads?
08:22:53 <quicksilver> yrlnry: that is the key observation.
08:23:27 <yrlnry> And nothing is ever performed until the RTS actually executes is as part of Main.main.
08:23:31 <jad4> maltem, no... but that's an issue with your explanation not with what I said :P
08:23:36 <quicksilver> yrlnry: but the point is, if you have do { a <- foo; b <- bar; if a then baz else bam }
08:23:58 <quicksilver> yrlnry: then *assuming you perform that at all* you definitely perform bar.
08:24:00 <shachaf> yrlnry: Well, or other monadic expressions are evaluated/executed, somehow (e.g., from ghci).
08:24:17 <yrlnry> quicksilver:  I think we're on the same page; my question is why this necessarily performs bar.
08:24:20 <quicksilver> yrlnry: in particular, the bar is performed independent of that if.
08:24:30 <maltem> jad4, bah :P Rewrite it, then, as "due to people thinking of IO, Reader, ..."
08:24:44 <quicksilver> yrlnry: I don't really have a good answer except "because that's what << means"
08:24:54 <quicksilver> yrlnry: (or "because that's what do notaiton means")
08:24:56 <jad4> maltem, yeap :)
08:24:57 <yrlnry> bar >>= (\b -> if a then baz else bam)
08:25:29 <lilac> yrlnry: the left-hand side of (>>=) will certainly be /forced/ if the result depends on it. it /might/ be forced if the result does not. whether or not the result depends on the LHS can itself depend on the function on the RHS.
08:25:34 <yrlnry> So you can't truly understand why bar is performed here without knowing what is happening inside of >>=, because that's where bar gets magically turned into b.
08:25:56 <quicksilver> lilac: of course it's important to note that not only "perform" but also "effect" and even more importantly "then" are all overloaded words
08:25:58 <lilac> (that's "will certainly be forced [when the result is forced]")
08:26:04 <yrlnry> If bar :: IO a, then that magic moment is the moment at which the RTS executes the I/O action and launches the missiles.
08:26:05 <quicksilver> lilac: precisely what they mean depends on the instance.
08:26:25 <quicksilver> yrlnry: no. You can understand *why* bar is performed without understanding >>=
08:26:30 <quicksilver> bar is performed by definition
08:26:35 <maltem> Speculating about what gets "performed" in an expression of arbitrary monadic type looks futile to me
08:26:40 <Saizan_> "by the monad laws"
08:26:46 <quicksilver> bar >>= ... means "perform bar and then the result is fed to..."
08:27:03 <yrlnry> quicksilver:  No, you can't understand *why* bar is performed, and that's why you have had to keep saying "it just is" and "that's the definition of >>=".
08:27:10 <maltem> (Except for gaining some intuition, maybe)
08:27:24 <quicksilver> yrlnry: but that's the answer ;)
08:27:27 <lilac> yrlnry: bar is performed because you said to perform it when you wrote your do block
08:27:30 <yrlnry> That's one answer.
08:27:33 <quicksilver> yrlnry: it's like "in 3+4, why is 3 added to 4?"
08:27:36 <quicksilver> yrlnry: ...because that's what + means
08:27:40 <lilac> there is no deeper why than that :)
08:27:41 <Lemmih> yrlnry: 'bar' is always performed but you can't know the meaning of "perform" without looking at the Monad.
08:27:53 <quicksilver> "in putStrLn name, why is the name printed"? ... because that's what putStrLn means
08:28:26 <yrlnry> quicksilver:  But in the presence of an overloaded +, 3 might not be added to 4, absent some knowledge about the laws governing the behavior of the various +es.
08:28:36 <yrlnry> quicksilver:  and that  is exactly the situation we are in here.
08:28:39 <quicksilver> well indeed.
08:28:44 <quicksilver> so it comes back to how you define +
08:29:00 <yrlnry> Right.  But in this case there are some overarching laws governing the behavior of >>=.
08:29:09 <lilac> yrlnry: another perspective is that 3 + 4 /means/ add 3 to 4. by overloading (+) you're overloading what 'add' means too
08:29:24 <quicksilver> there are a few laws, yrlnry but you won't find the answers in them
08:29:35 <quicksilver> the monad laws won't answer your original question about why get is performed.
08:29:45 <lpsmith> quicksilver:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3510#a3510
08:30:20 <maltem> (To continue my pointless mumbling, I'd argue that in a formal language, you have definition/behaviour first, and meaning is derived from that.)
08:30:38 <quicksilver> lpsmith: is your point that, in "a >> b", it might be the case that "b" never happens?
08:30:46 <yrlnry> Not the monad monoid laws, but the type of >>= implies that the magic conversion of m to v  in   m >>= (\v -> ...)  must actually occur somewhere; you can't have a >>= that fails to do this.
08:30:57 <quicksilver> yrlnry: that's not the reason, no.
08:31:27 <quicksilver> lpsmith: if so, that's absolutely true, and unfortunately that's part of the overloading of "then" in "a then b"
08:31:33 <lilac> yrlnry: there exist rare monads where the RHS function is not invoked at all... :)
08:31:45 <yrlnry> lilac:  how can they be well-typed?
08:31:57 <Vanadium> Something like Maybe?
08:32:10 <yrlnry> To have m a -> (a -> m b) -> m b, you can't acquire the necessary m b unless you invoke the function somewhere.
08:32:13 <lilac> yrlnry: data UnitMonad a = UM; instance Monad UnitMonad where return a = UM; _ >>= _ = UM
08:32:14 <quicksilver> lpsmith: there is a simpler example, which is "throwError foo >> lift (putStrLn "hi")
08:32:30 <quicksilver> yrlnry: that's partly true but it honestly is not the answer you seek
08:32:41 <quicksilver> yrlnry: we could instead be talking about the simple "foo >> bar" case
08:32:41 <lpsmith> quicksilver:  you should try running the program :-)
08:33:03 <shachaf> lilac: I don't think that's a monad.
08:33:29 <dolio> UnitMonad is a monad.
08:33:29 <shachaf> lilac: Because undefined >>= return = UM.
08:33:49 <yrlnry> lilac:  Okay, thanks.
08:33:54 <lilac> shachaf: it's a matter of opinion whether the monad laws apply to partial values, but that case is fixed by making >>= left-strict.
08:34:08 <lpsmith> quicksilver:  I think my point is that,   the notion of "performs" is useful when applied to say,  IO and State,  but it doesn't generalize to arbitrary monads
08:34:13 <shachaf> Ah, that's not part of the monad laws?
08:34:24 <lilac> shachaf: depends who you ask :)
08:34:27 <ezyang> I'm not terribly happy with this function.  Any suggestions to make it more Haskell like? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9040#a9040
08:35:04 <shachaf> (Anyway, with strictness this is definitely a monad; like Maybe without the Just.)
08:35:04 <yrlnry> Okay, let's take a break.  Thanks very much to everyone for all the discussion.
08:35:05 <Lemmih> lpsmith: I believe it does.
08:35:17 <yrlnry> Also thanks for being patient with me.
08:35:38 <lpsmith> Lemmih:   did you see my example?
08:35:40 <dolio> > (undefined >>= return :: Reader Int Int) `seq` ()
08:35:43 <lambdabot>   ()
08:35:49 <dolio> Reader is not a monad. :)
08:35:52 <Lemmih> lpsmith: What example was that?
08:36:10 <lpsmith> Lemmih:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3510#a3510
08:36:12 <shachaf> @src Reader (>>=)
08:36:12 <lambdabot> Source not found. stty: unknown mode: doofus
08:36:16 <yrlnry> If this were #lisp then by this point there would be two people calling me an idiot, two telling me to go away, and two telling me that if I don't like how Common Lisp works I should go back to programming in RPG4.
08:36:25 <shachaf> @source Control.Monad.Reader
08:36:26 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
08:37:08 <dolio> > (undefined . id) `seq` ()
08:37:09 <shachaf> Huh.
08:37:09 <lambdabot>   ()
08:37:15 <dolio> Haskell is not a category.
08:37:16 <Lemmih> lpsmith: That "perform" doesn't mean the same in that Monad as it does in others is exactly the point.
08:37:23 <lilac> yrlnry: to be honest, i don't think the notion of 'perform' is enormously helpful :)
08:37:26 <jmcarthur_work> ezyang, explain what this does, please
08:37:40 <lilac> (except in the IO, ST, STM and similar monads)
08:37:41 <yrlnry> lilac:  I agree.
08:38:04 <Lemmih> I find that 'execute' is worse.
08:38:25 <jmcarthur_work> dolio, you're breaking my heart. stop that.
08:38:31 <ezyang> Yeah.  It modifies a member to have had their dues collected for "paid" amount of dollars (doing a computation to translate this into number of terms paid for, and then determining what the latest term they'd be paid for is).
08:38:54 <dolio> jmcarthur_work: It's all seq's fault.
08:39:05 <yrlnry> "perform" is suspect even in ST, since it's only computing new state values, and the computation of the state may be lazily elided.
08:39:14 <yrlnry> Just as any other pure computation might be lazily elided.
08:39:24 <jmcarthur_work> ezyang, what are the steps of the computation?
08:39:30 <maltem> Lemmih: How so? Both word have no meaning ;)
08:39:36 <lilac> yrlnry: right. in fact, ST has primitives to specify whether or not it should do that iirc
08:39:46 <jmcarthur_work> ezyang, high level steps, i mean
08:39:50 <Lemmih> maltem: Exactly, but 'execute' is more easily mistaken for 'evaluate'.
08:40:20 <maltem> That may well be true.
08:41:41 <ezyang> jmcarthur_work: latestTerm = the latest term that has been already paid for by the member; startTerm = either the term before the current one, or the latest term already paid (we start "paying for terms" after this one); terms = the number of terms "paid" dollars pays for; latestTerm' the new latest term that the person has been paid for
08:42:51 <jmcarthur_work> ezyang, can each of those ideas be separated cleanly into other functions?
08:43:11 <lpsmith> Lemmih:   I believe that if you work up what (I understand) "perform" to mean in the context of unrestricted first-class continuations,  it doesn't really mean anything at all
08:43:16 <Lemmih> maltem: "frobbing" is also a possibility but it doesn't convey that it is in the same general group as "evaluate", "execute" and "perform".
08:43:47 <Lemmih> lpsmith: Right, it really doesn't mean anything. But we need a word for it anyway.
08:43:49 <lpsmith> and in some sense,   continuations are monads,  and monads are continuations.
08:43:55 <lpsmith> heh
08:44:26 <lpsmith> :-)
08:44:32 <jmcarthur_work> ezyang, the simplest way to make simple code is to have simple functions :)
08:47:50 <maltem> "Frobbing" appeals to me, at least as to explain the meaning of the other word.
08:48:02 <jmcarthur_work> ezyang, once you have simple functions, you can use them like building blocks with pretty combinators and stuff
08:48:48 <jmcarthur_work> ezyang, and then designing your program boils down to whether you should have foo = a ; bar = b . c, or foo = a . b ; bar = c
08:49:01 <jmcarthur_work> modulo which combinators you are using, etc.
08:49:57 <jmcarthur_work> usually one of those choices is nicer than the other. for example, if b and c are both in a monad and a is not, it's probably nicer to have b and c used together and then fmap a into the result
08:50:17 <jmcarthur_work> if possible
08:50:54 <quicksilver> lpsmith: I believe we choose to generalise it to those cases.
08:50:57 <burp> @hoogle [Word8] -> String
08:50:57 <lambdabot> Prelude show :: Show a => a -> String
08:50:57 <lambdabot> Text.Show show :: Show a => a -> String
08:50:57 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
08:51:01 <flazz> what is a monad where the type is a function, not a algebraic data type?
08:51:22 <jmcarthur_work> flazz, like ((->) a)?
08:51:23 <quicksilver> lpsmith: it's useful to have a word, so we extrapolate the word 'perform' because of intuitions raise by particular examples
08:51:24 <elvenporn> flazz: Reader, State
08:51:24 <yrlnry> Mm, this all means that my mUntil :: Monad m => m a -> m Bool -> m [a] is wrong too
08:51:36 <quicksilver> lpsmith: (in the same way moggi/wadler extrapolated the word 'effect')
08:51:36 <Lemmih> flazz: Doing homework?
08:51:45 <jethr0> i have a GLUT program with mainloop and exit it via exitWith. now i get an error "warning: too many hs_exit()s". any ideas?
08:52:07 <Jafet> Is haskell ever assigned by any institution as homework?
08:52:17 <idnar> yrlnry: IF YOU DON'T LIKE HOW COMMON LISP WORKS YOU SHOULD GO BACK TO PROGRAMMING IN RPG4!^%!$^!!@@!!
08:52:37 <jmcarthur_work> Jafet, by some
08:52:49 <jmcarthur_work> usually in a programming languages course
08:53:15 <jethr0> Jafet: my university (University of Karlsruhe, Germany) did its complete entry level CS course with haskell
08:53:34 <jmcarthur_work> jethr0, lucky
08:53:36 <Jafet> Interesting.
08:53:42 <yrlnry> idnar:  Can't, I'm being laid off from my RPG4 job next week.  I have a new job lined up writing real-time missile guidance systems in Haskell, so I need to retool in a hurry.
08:53:46 <jmcarthur_work> mine was C++
08:53:47 <yrlnry> idnar:  But thanks for your concern!
08:54:11 <jethr0> the prof was a huge fan. the students 'obviously' hated it. they rather wanted to hack C and PERL
08:54:20 <Jafet> .oO( the missiles end up detonating before they launch )
08:54:56 <flazz> Lemmih: no, just trying to branch out with my monad use
08:55:01 <maltem> jethr0, lucky you. The Aachen people prefer to first torture people in a boring Java course, to glance over Haskell and Prolog in the last two or three weeks
08:55:40 <flazz> jmcarthur_work: i just did a graduate PLP course, but it was implementing RPAL
08:55:46 <jmcarthur_work> i've said this one here before, but it bears repeating. my programming languages teacher had this and only this to say about haskell: "Haskell is... just weird." ... and we never touched it again
08:56:04 <jethr0> oh well, for a "first" language Java isn't the worst possible. just very "bondage and discipline" ;)
08:56:17 <maltem> jethr0, That way, Haskell is relatively popular among cs students here, though :)
08:57:01 <idnar> yrlnry: hahaha
08:57:07 <jethr0> jmcarthur_work: to be honest, monads have made quite the difference for haskell. before that IO was a bit painful and your language teacher may have encountered it back then (i.e. via gofer)
08:57:43 <jmcarthur_work> jethr0, no, she didn't know haskell at all
08:57:45 <yrlnry> There would seem to be a lot of hurdles for someone to leap over if Haskell were their first language.
08:57:55 <Vanadium> If only we could get rid of monads and make more things instances of applicative
08:58:10 <jethr0> yrlnry: leap over to where?
08:58:12 <maltem> There's not much to calling a language "just weird" and pretend to be cool expressing that attitude.
08:58:23 <yrlnry> leap over to the other side of the hurdle.
08:58:34 <maltem> Actually, any concept or thing at all, not specifically a programming language
08:58:43 <jethr0> hurdles while leaping over hurdle?
08:58:56 <jmcarthur_work> she had a negative attitude toward every language that was not C
08:59:03 <jethr0> string theory is .. just weird ..
08:59:10 <jmcarthur_work> she only taught the class because nobody else would
08:59:41 <maltem> jmcarthur_work, that image you're conveying of that person is so ... weird
08:59:48 <jethr0> i am sorry that i never got around to fully comprehending prolog. and maybe a cool dataflow language, plus a dependent type lang ;)
09:00:27 <jmcarthur_work> prolog is worth some comprehension, although i still cannot claim i fully understand its pros compared to something like haskell
09:00:27 <jethr0> with regards to abstractions, C can go only so far without implement a subset of something else
09:01:04 <jmcarthur_work> nondeterminism, great. i'm just not used to using it for everything as i'm sure prolog programmers are
09:01:08 <jethr0> speak about no side effects. pure prolog is strange, i'd just love to "get it" more in order to apply the logical paradigm when suitable
09:01:19 <sohum> our intro to CS course is taught half in C, half in Haskell
09:01:27 <jmcarthur_work> sohum, seems a good balance
09:01:38 <jethr0> and of course the whole "i can prove it true, but not false" thing. or was it the other way round?
09:01:43 <sohum> about three-fifths of my batch hated haskell, the other two-fifth hated C
09:01:49 <jethr0> sohum: lots of FFI i guess ^_^
09:02:10 <sohum> jethr0: isn't that just a consequence of the open world assumption?
09:02:18 <sohum> jethr0: actually, no, no ffi at all
09:02:31 <jethr0> hating C is uncool. that's how the computer works (or rather worked before everything became pipelines, multicore, hyperthreaded, branch predicted)
09:02:42 <jethr0> sohum: i guess
09:02:52 <sohum> it was very much like two separate courses, complete with different lecturers
09:03:11 <sohum> well, "hate" may be a strong term
09:03:14 <Jafet> jethr0, you can run C using a warehouse full of Chinese
09:03:18 <sohum> it's just /so/ low level
09:03:25 <Jafet> There is no computer
09:03:43 <jethr0> Jafet: i don't get it...
09:03:43 <jmcarthur_work> C is too low level to be expressive, but not low level enough to be worth being low level, IMO.
09:04:03 <sohum> jmcarthur_work: I will agree with you there
09:04:13 <elvenporn> jethr0: C is not how the computer works. C is how C works
09:04:19 <Jafet> C is used as portable assembly. That is pretty much its enduring strength
09:04:27 <jethr0> jmcarthur_work: bah, for writing device drivers for example i think it's quite a good fit. OS in general too, unless you need/want cool data types and abstractions
09:04:46 <Jafet> You can probably write device drivers in haskell, given appropriate primitives.
09:04:48 <jmcarthur_work> jethr0, we could just as easily write device drivers in somewhat higher level languages
09:04:49 <medfly> C should be loved and praised because it's low level
09:04:56 <Jafet> Probably be more reliable and efficient, too.
09:04:56 * medfly kneels and worships.
09:05:03 <quicksilver> C should be hated and abused because it's *not* low level
09:05:15 <medfly> sorry, I thought we're in #haskell
09:05:17 <quicksilver> does it give access to registers? no. status flags? no.
09:05:25 <jmcarthur_work> jethr0, OS programming is better with assembly for the true low level stuff and a higher level language for the rest
09:05:26 <quicksilver> it's horribly high level.
09:05:27 <jmcarthur_work> IMO
09:05:27 <jethr0> elvenporn: well learning assembly seems a bit anachronistic these days. therefore C is as close to the machine workings as you will realisticly get these days.
09:05:34 <Jafet> It depends on which level you are currently on, and which level you need to get to.
09:05:39 <Jafet> jethr0, nonsense.
09:05:55 <elvenporn> jethr0: C is just another virtual machine
09:06:03 <quicksilver> using C, you can't even construct efficient 64-bit arithmetic for pairs of 32-bit integers.
09:06:05 <jethr0> maybe in a few years C will be outdated as assembly is today, and haskell will the lowest you can get ;)
09:06:08 <quicksilver> I mean, that's just absurd.
09:06:14 <medfly> :)
09:06:23 <idnar> jethr0: talking about C being "close to machine workings" is very misleading :P
09:06:25 <int-e> ... on CPUs that have a 32x32->64 bit multiplication
09:07:10 <jethr0> hmm
09:07:20 <benmachine> should we all use C-- then
09:07:23 <benmachine> or
09:07:33 <Jafet> brainfuck.
09:07:38 <benmachine> just abandon the idea and port the linux kernel to python
09:07:57 <jethr0> idnar: so, which language or model would you say comes closest to "machine workings" these days?
09:07:57 <jmcarthur_work> "portable assembly" just means "common denominator" :(
09:08:02 <Jafet> python would scream and die, because it is a duplo (TM) blocks language
09:08:14 <idnar> jethr0: assembly, obviously
09:08:20 <benmachine> jmcarthur_work: well, yeah
09:08:33 <benmachine> jmcarthur_work: you say that like you expect it to be something else
09:08:40 <jmcarthur_work> benmachine, many people do
09:08:41 <Jafet> Well, VHDL might be another contender
09:08:45 <Jafet> Or microcode.
09:08:54 <Jafet> Assembly, after all, is yet another interface.
09:08:56 <quicksilver> jethr0: There aren't any really good low level languages that I'm aware of.
09:08:56 <lilac> C's longevity seems to stem from: 1) its portability and 2) the relative ease with which it can be translated into reasonably efficient machine code
09:09:07 <jmcarthur_work> benmachine, whenever somebody touts C as being like portable assembly, it's implied that this is somehow a good thing
09:09:24 <jethr0> idnar: is it reasonable anymore to write assembly with all the advanced stuff that's going on in a modern processor? i thought your code would just be extremely slow or a bitch to write.
09:09:25 <benmachine> jmcarthur_work: well, nobody wants non-portable anything these days
09:09:30 <quicksilver> what people use, when writing close to the metal code, is generally a mixture of (1) C with hideously looking non-portable extenstions
09:09:35 <quicksilver> and (2) direct asm blocks.
09:09:49 <benmachine> so if you want to get as close to assembly as you can, then portable assembly is going to be what you use
09:09:55 <quicksilver> the linux kernel is a mixture of that I think.
09:10:08 <jmcarthur_work> jethr0, if your goal is to take advantage of being low level, C doesn't provide those advantages. there is nothing stopping you from writing your low level code in assembly and you high level code in a nicer language though
09:10:23 <jmcarthur_work> jethr0, no need to write entire programs in assembly, is what i mean
09:10:24 <dumael> ghc is a mix as well.
09:10:35 <idnar> jethr0: you didn't ask for "reasonable"
09:10:39 <quicksilver> dumael: ghc itself, as a program?
09:10:50 <dumael> the RTS portion.
09:10:55 <idnar> I don't think it's reasonable to write code in C, either :P
09:11:06 <elvenporn> idnar: why not?
09:11:18 <dumael> and some other small bits.
09:11:19 <burp> is there anything premade to combine Word8's to
09:11:25 <burp> a Word(x*8)?
09:11:31 <quicksilver> dumael: yeah. The compiler is mostly (all?) in haskell, but the RTS is in a mixture of not-haskell, and Cmm and C
09:11:32 <jmcarthur_work> the only advantage for C i can think of is to use C libraries
09:11:36 <benmachine> isn't C over assembly also an acknowledgement that compilers know more about CPUs than you do?
09:11:36 <idnar> elvenporn: for almost every task, there's a better tool than C
09:11:36 <lispy> burp: huh?
09:11:38 <burp> or do I have to bitshift manually?
09:11:46 <Axman6> burp: fromIntegral?
09:11:52 <jmcarthur_work> benmachine, that's a case for compilers, not C ;)
09:12:06 <Axman6> > fromIntegral (8 :: Word8) :: Word16
09:12:07 <lambdabot>   8
09:12:11 <benmachine> jmcarthur_work: it's a case for not writing assembly yourself but writing something that sort of looks a bit like it
09:12:14 <quicksilver> burp: bitshift manually.
09:12:29 <quicksilver> (or multiply by powers of 256 if you like ;)
09:12:35 <jmcarthur_work> benmachine, well, try and do some of the examples quicksilver mentioned earlier in C then
09:12:39 <jmcarthur_work> benmachine, it's not low level enough
09:12:47 <burp> well I have 16 Word8, and I want to use these as the key for encryption in Crypto
09:13:02 <elvenporn> idnar: not really; writing tools for the linux command line is a case where C is still very useful
09:13:09 <elvenporn> C, Perl or sh
09:13:24 <quicksilver> I thought crypto had useful functions for that purpose burp
09:13:30 <idnar> elvenporn: what's so great about C for writing linux command line tools?
09:13:32 <benmachine> perl and sh can go and die in a hole
09:13:43 <quicksilver> elvenporn: writing tools for the linux command line is fine in haskell, perl, python, etc...
09:13:46 <elvenporn> idnar: direct access to the system API
09:13:46 <benmachine> as for C I probably wouldn't ever use it if things didn't already exist in C++
09:13:49 <quicksilver> and there are reasons to prefer more of those to C ;)
09:13:50 <idnar> I write mine in python or haskell, I don't think I've ever even written one in C
09:13:52 <elvenporn> quicksilver: not haskell
09:13:54 <benmachine> er
09:14:01 <benmachine> C++ didn't need to be in that sentence
09:14:08 <benmachine> I have confused myself now
09:14:09 <benmachine> again
09:14:09 <quicksilver> elvenporn: in many cases haskell is an excellent tool for that.
09:14:10 <elvenporn> quicksilver: some programs are easier to write in C than in Perl
09:14:18 <quicksilver> elvenporn: not many though.
09:14:19 <elvenporn> quicksilver: I disagree
09:14:26 <benmachine> haskell does seem to be perfect for command line utilities
09:14:30 <quicksilver> elvenporn: would you like to say why? that would be more interesting ;)
09:14:37 <Axman6> elvenporn: only to someone who doesn't know perl
09:14:37 <jmcarthur_work> i use haskell for most of my utilities
09:14:47 <benmachine> where most of the time your application uses is the time it took you to write out its name
09:14:48 <elvenporn> haskell is nearly useless for command line tools because it doesn't have argv[0] and strerror(errno)
09:14:49 <jmcarthur_work> sh for some of the smallest ones
09:15:03 <elvenporn> Axman6: hah
09:15:06 <Axman6> elvenporn: oh really? it doesn't?
09:15:10 <quicksilver> the only disadvantage of haskell I can think of is the large size of the executables
09:15:12 <idnar> wow, that's the most ridiculous assertion I've heard all day
09:15:19 <ezyang> wahahaha
09:15:20 <benmachine> fmap head getArgs?
09:15:26 <elvenporn> benmachine: argv[1]
09:15:27 <jethr0> for quick one-off string manipulation i still revert to perl *ahem*. unless I can do it with a lot of "sed | grep | tr"
09:15:34 <benmachine> elvenporn: is it?
09:15:36 <benmachine> oh
09:15:37 <elvenporn> yes
09:15:38 <jmcarthur_work> Axman6, well, the function for getting the program name is unreliable because it's unreliable in any language, afaik
09:15:40 <benmachine> there's a different thing
09:15:44 <benmachine> getProgName or something
09:15:46 <benmachine> I forget the name
09:15:51 <elvenporn> jmcarthur_work: I don't want to get the program name, I want to get argv[0]
09:16:04 <ezyang> well, the two are equivalent
09:16:08 <elvenporn> no
09:16:15 <jmcarthur_work> nah, they aren't
09:16:27 <benmachine> what do you want argv[0] for if not the program name
09:16:30 <idnar> "argv[0]" is just a C runtime thing, so if you want to be pedantic, you probably shouldn't call it that
09:16:31 <elvenporn> it's possible in ghc by using the FFI to call an internal function that gives you access to argv, but ...
09:16:57 <benmachine> elvenporn: but nobody's done that because nobody actually cares about argv[0] :P
09:17:03 <quicksilver> having "getProgName" instead of "argv[0]" certainly does *not* make haskell useless for command line tools
09:17:03 <jmcarthur_work> yeah the source of getArgs is a good basis
09:17:12 * benmachine does kind of think that getArgs should return all of them
09:17:17 <quicksilver> I have written many such, and I've never cared about the differences between getProgName and argv[0]
09:17:22 <Axman6> elvenporn: so your point is that if you want to make tools that read command line arguments, don't use haskell, but it's great for real work? :)
09:17:24 <elvenporn> benmachine: my solution is not to write those tools in haskell
09:17:40 <benmachine> elvenporn: why? what are you missing?
09:17:51 <elvenporn> complete access to argv
09:17:51 <quicksilver> most command line tools do not alter their behaviour based on argv[0]
09:17:53 <ezyang> getProgName - Computation getProgName returns the name of the program as it was invoked.
09:18:03 <quicksilver> those that do, generally alter it based on the last component
09:18:06 <ezyang> The canonical use is to change the name of the program in your help string or something
09:18:19 <elvenporn> how about re-exec'ing yourself?
09:18:34 <ezyang> elvenporn: Ah, that's the other canonical use
09:18:35 <jmcarthur_work> ezyang, "for maximum portability, we just return the leafname of the program as invoked"
09:18:41 <ezyang> hmmm
09:18:41 <idnar> yeah, because it's impossible to write a command-line tool without re-exec'ing yourself
09:18:44 <quicksilver> re-execing yourself is not a common case.
09:18:57 <ezyang> "Reexec. It's more likely then you think."
09:19:07 <elvenporn> common enough that I've hit this problem
09:19:14 <mux> I wonder if there's a way to generalize those functions : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9042#a9042
09:19:18 <benmachine> okay I am kind of annoyed that getProgName doesn't get argv[0]
09:19:19 <ezyang> More seriously, re-exec is extremely common for any program that deals with dropping priviledges
09:19:23 <benmachine> now that I have looked at it
09:19:25 <mux> and if you can think of better names
09:19:31 <jmcarthur_work> ezyang, has my vague advice earlier helped?
09:19:44 <benmachine> ezyang: why?
09:19:48 <ezyang> jmcarthur_work: Sort of. I'm having difficulty crystallizing useful decompositions
09:20:01 <ezyang> jmcarthur_work: But once I figure it out, it'll be glorious!
09:20:02 <elvenporn> benmachine: withProgName has the undocumented feature that it also cuts off the "path"
09:20:10 <jmcarthur_work> ezyang, :D
09:20:29 <ezyang> benmachine: You don't actually want to write priviledge dropping code yourself. It's kind of gnarly
09:20:42 <benmachine> elvenporn: undocumented?
09:20:43 <ezyang> exec offers a non-intrusive way of dropping privs using sudo while pretending you're the same program
09:20:49 <jmcarthur_work> it's documented
09:20:50 <maltem> Now, maybe a System.Posix.getProgName that returns argv[0] unchanged wouldn't hurt.
09:20:52 <benmachine> ezyang: isn't it just, like, setuid
09:21:00 <ezyang> mux: fold, maybe?
09:21:06 <elvenporn> jmcarthur_work: oh, where?
09:21:07 <ezyang> benmachine: Nope
09:21:14 <ezyang> You also have to worry about euid and ruid
09:21:23 <jmcarthur_work> elvenporn, "for maximum portability, we just return the leafname of the program as invoked"
09:21:25 <mux> ezyang: no, I need access to an element and the rest of the field, that can't be a fold
09:21:27 <jmcarthur_work> it's right there
09:21:45 <lilac> suppose you want to find some files which are installed relative to your binary. how do you do that?
09:21:49 <ezyang> there's gotta be some morphism that does what you want :-)
09:21:51 <elvenporn> jmcarthur_work: that's getProgName
09:21:56 <mux> and I mean generalize for taking n elements; I imagine something along the lines of the ZipList instance of Applicative
09:22:18 <ezyang> mux: Oh, I see
09:22:27 <quicksilver> lilac: you don't. That's a broken idea.
09:22:29 <mux> it really looks similar to the generalization of zipWith problem
09:22:30 <jmcarthur_work> elvenporn, withProgName only says that it uses getProgName
09:22:37 <ezyang> well, it'll be pretty difficult to genericize the tuplification
09:22:40 <quicksilver> lilac: executables in a posix system shuold not depend on being able to locate themselves.
09:22:40 <jmcarthur_work> elvenporn, presumably you should look up with getProgName does
09:22:44 <jmcarthur_work> *what
09:22:45 <mux> ezyang: obviously
09:22:50 <ezyang> :t (,)
09:22:51 <lambdabot> forall a b. a -> b -> (a, b)
09:22:54 <ezyang> :t (,,)
09:22:55 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
09:22:59 <elvenporn> jmcarthur_work: it's actually withProgName that does the truncation
09:23:05 <jethr0> :t ,
09:23:06 <lambdabot> parse error on input `,'
09:23:11 <mux> ezyang: that ain't the problem; this is why ZipList generalizes zipWith and not zip
09:23:11 <quicksilver> lilac: the executable might be running in a chroot which no long has access to itself (to give one of a huge variety of possible reasons)
09:23:22 <Vanadium> elvenporn: Yes, because it gives a progname from an alternative source.
09:23:33 <ezyang> aha
09:23:33 <Vanadium> The source that getProgName gets it from also truncates.
09:23:55 <lilac> quicksilver: don't do that then
09:24:01 <jmcarthur_work> elvenporn, oh that is gross
09:24:27 <jmcarthur_work> Vanadium, he's right that that is not documented though
09:24:39 <ezyang> mux: hmm... this is tricky
09:24:47 <ezyang> May I ask what you need this sort of silliness for?
09:24:53 <lilac> quicksilver: how else do you solve this problem for executables which (1) can be installed anywhere, and (2) don't need recompilation with the path baked in, and (3) don't have script wrappers?
09:24:59 <Vanadium> I started reading halfways through the discussion, so I am not arguing against anything.
09:25:01 <mux> ezyang: it is indeed tricky, but I don't think it is silly...
09:25:14 <ezyang> A use-case would go a long way to making it not silly
09:25:20 <mux> ezyang: it's combinatorics
09:25:35 <jmcarthur_work> ezyang, looks quite unsilly to me as well :)
09:25:38 <quicksilver> lilac: Either a script wrapper, a known good path, or an environment variable.
09:25:46 <quicksilver> lilac: (or some combination of those three options)
09:25:54 <ezyang> ah
09:25:58 <quicksilver> lilac: I find all of these much more attractive than executables that 'magically' work out where they are.
09:26:05 <mux> ezyang: oneAndRest returns all the possible ways to pick an element of the list and the rest
09:26:18 <mux> ezyang: twoAndRest does the same but selecting two elements
09:26:23 <Vanadium> Maybe system.posix.process ought to have a "lowlevel" argv
09:26:23 <lilac> quicksilver: none of your options are acceptable to me, sorry!
09:26:26 <quicksilver> lilac: for security reasons, known good path is wise for privileged/system apps anyway.
09:26:33 <lilac> quicksilver: they all mean installation is not easy
09:26:49 <mux> > oneAndRest [1..3]
09:26:49 <mux> [(1,[2,3]),(2,[1,3]),(3,[1,2])]
09:26:50 <lambdabot>   Not in scope: `oneAndRest'
09:26:52 <lilac> this is not a privileged / system app.
09:26:53 <mux> > twoAndRest [1..3]
09:26:53 <mux> [(1,2,[3]),(1,3,[2]),(2,3,[1])]
09:26:55 <lambdabot>   Not in scope: `twoAndRest'
09:26:56 <ezyang> mux: Ok, I think I know what you want to do
09:27:00 <benmachine> lilac: a hardcoded default path with a --path option seems the most sensible to me
09:27:00 <mux> woops, sorry for the lambdabot spam.
09:27:03 <ezyang> Let me make sure it actually works
09:27:06 <quicksilver> lilac: I kind of accept your concerns, I just think they're incompatible with the general design of posix/LSB/SUS systems.
09:27:08 <elvenporn> readLink "/proc/self/exe" or something like that
09:27:08 <lilac> benmachine: again, that's not easy.
09:27:08 <benmachine> if it's a system-wide install
09:27:28 <quicksilver> lilac: for example, OSX does it's Foo.app/blah trick, and I think that's a good solution in the OSX context.
09:27:31 <lilac> benmachine: it's not. it's a tarball, where installation is 'tar -jxf'
09:27:39 * mux thinks that if things go on like this, project euler might cause him to upload a combinatorics package on hackage
09:27:47 <quicksilver> lilac: it is obviously a subjective issue
09:27:57 <quicksilver> but there are quite a long list of possible cases where finding yourself doesn't work.
09:27:59 <benmachine> lilac: it's also not easy if I make a symlink and suddenly it doesn't work anymore
09:28:03 <benmachine> for e.g.
09:28:14 <lilac> quicksilver: it's what we do and we've never had a single problem with it.
09:28:26 <lilac> benmachine: we resolve symlinks before looking for our files :)
09:28:32 <mux> I should read that paper on generalizing zipWith with applicative functors again
09:28:34 <jmcarthur_work> mux, looks a lot like a zipper or a comonad
09:28:42 <quicksilver> lilac: it's quite a common solution, but it's still ugly ;)
09:28:47 <mux> jmcarthur_work: if you say so ;-)
09:28:52 <jmcarthur_work> mux, extend :: (w a -> b) -> (w a -> w b)
09:28:55 <quicksilver> lilac: anyhow, we should stop boring the inhabitants of #haskell with this.
09:28:57 <mux> it does look like a zipper indeed
09:29:01 <mux> I can't say for comonads :-P
09:29:04 <quicksilver> lilac: feel free to harangue me in -blah if you like.
09:29:06 <elvenporn> so how about the bad integration of Control.Exception with errno
09:29:25 <lilac> quicksilver: i think we understand each others' positions ;-)
09:29:33 <jmcarthur_work> mux, the only thing is that is can't be a comonad since you can't define extract :: w a -> a for it
09:29:45 <benmachine> ho hum
09:29:54 <benmachine> I understand both your positions
09:29:57 <burp> quicksilver: you were right, Crypto has "fromOctets" in Codec.Utils, fromOctets 256 [Octets]
09:29:59 <benmachine> but I don't understand mine, now :(
09:30:16 <Axman6> heh
09:30:27 <quicksilver> burp: good :)
09:30:33 <quicksilver> burp: I thought it did somewhere.
09:31:04 <Axman6> @remember benmachine ho hum. I understand both your positions. but i don't understand mine, now :(
09:31:04 <lambdabot> It is forever etched in my memory.
09:31:33 <quicksilver> benmachine: I read quite a good rant on this which more-or-less cemented my current view but it was many years ago and (a) I can't remember where [probably a debian list] and (b) of course I can't call to mind the good points.
09:32:41 <jethr0> i had the ultimate reasons for my current position, but they were so self-evidently true that of course i have forgotten them and can thus not now present them ^_^
09:32:52 <quicksilver> jethr0: yes, that's about right :)
09:32:55 <benmachine> heh
09:34:57 <mux> I think this may be worthy a post to haskell-cafe
09:37:18 <jmcarthur_work> mux, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9042#a9043
09:37:31 <jmcarthur_work> untested, but i think it's right
09:38:07 <mux> let me try to process this :-)
09:38:29 <jmcarthur_work> oh it's wrong
09:38:44 <jmcarthur_work> my defs for *AndRestWith are wrong
09:38:48 <mux> I was wincing at the use of til
09:38:55 <mux> you probably don't get all the combinations
09:39:00 <mux> s/til/tail/
09:39:02 <jmcarthur_work> well, f' xs = xs is wrong
09:39:04 <jmcarthur_work> wrong type
09:39:10 <jmcarthur_work> no, tail is alright
09:39:14 <mux> okay
09:40:05 <jmcarthur_work> working on a fix
09:40:56 <jmcarthur_work> mux, i think i don't understand twoAndRestWith
09:41:05 * mux nods :)
09:41:37 <jmcarthur_work> i looks like it should work on groups of two elements at a time plus the rest of the list and return a list of the same length, but the implementation doesn't look like it would do that
09:41:38 <mux> it's probably best explained by running twoAndRest on [1..4]
09:41:56 <mux> which gives:
09:42:01 <mux> [(1,2,[3,4]),(1,3,[2,4]),(1,4,[2,3]),(2,3,[1,4]),(2,4,[1,3]),(3,4,[1,2])]
09:42:22 <mux> it returns all the ways to pick 2 elements out of the list, along with the elements that haven't been picked
09:42:34 <jmcarthur_work> i see
09:42:35 <jmcarthur_work> okay
09:43:03 <ezyang> Hey all, I have an implementation
09:43:12 <ezyang> It's kind of dirty though...
09:43:37 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9045#a9045
09:43:38 <jmcarthur_work> mux, well, here is what i have for oneAndRestWith http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9042#a9044
09:44:15 <ezyang> And the types are a little tripped, but that can be fixed with another f'n
09:44:28 <jethr0> can i use an MVar anywhere i can use an IORef? i.e. is MVar a superset of IORef?
09:44:41 <jmcarthur_work> ezyang, i think that is even a bit dirtier than the original ;)
09:45:02 <mux> jmcarthur_work: that doesn't seem to compile
09:45:12 <ezyang> It works though! :o)
09:45:42 <jmcarthur_work> mux, ah, i didn't test it. i'll just do that now
09:46:46 <osiant> jethr0: no
09:46:59 <mux> ezyang: I have something similar too, my hope was to generalize with the pattern used in oneAndRestWith!
09:47:00 <lawful_evil> can haskell displace python?
09:47:03 <lawful_evil> and lisp?
09:47:11 <lawful_evil> is it really that friggin good?
09:47:15 <osiant> jmcarthur_work: an MVar is either full or empty. writing to a full MVar blocks. reading from an empty MVar blocks.
09:47:16 <SamB_XP_> no
09:47:16 <kmc> @faq
09:47:17 <lambdabot> The answer is: Yes! Haskell can do that.
09:47:19 <mux> since as I said, it closely resembles the zipWith generalization problem
09:47:24 <lawful_evil> will there be a linux distro totally haskell powered or a haskell os?
09:47:29 <SamB_XP_> it could take over a lot of their market share though, probably
09:47:31 <kmc> @faq
09:47:31 <osiant> lawful_evil: welcome back
09:47:31 <lambdabot> The answer is: Yes! Haskell can do that.
09:47:32 <Badger> There is a Haskell OS!
09:47:36 <osiant> don't feed the trolls, please
09:47:36 <lawful_evil> I lvoe you guys
09:47:44 <lawful_evil> Im so not a troll i am an enthusiat
09:47:50 <osiant> @protontorpedo
09:47:50 <lambdabot> some dude called topmind says that oo is bs
09:47:51 <kmc> i saw haskell save a burning kitten from a tree
09:47:54 <osiant> @protontorpedo
09:47:55 <lambdabot> or does it become a mishmash of code?
09:47:57 <burp> LOL
09:47:59 <SamB_XP_> but I for one am pretty sure I'm still going to be writing Python and Perl and probably Emacs Lisp for quite some time ...
09:47:59 <osiant> @protontorpedo
09:47:59 <lambdabot> smalltalk is oo
09:48:04 <mux> ezyang: you can probably remove the map if you add a function parameter to combinationsOf
09:48:17 <SamB_XP_> oo *is* bs
09:48:26 <mux> I have yet to try this, it would resemble the other code more
09:48:30 <SamB_XP_> it doesn't mean much of anything ;-)
09:48:38 <lawful_evil> SamB_XP_: thank you
09:48:58 <mux> ezyang: also, this map with the concatenation looks wildly inefficient :-(
09:49:07 <lawful_evil> http://harmful.cat-v.org/software/OO_programming/
09:49:22 <SamB_XP_> sometimes you just don't want a hindley-milner type system :-(
09:49:28 <ezyang> mux: *shrugs* there are probably a number of refactorings that can make this work better
09:49:45 <ezyang> but it fundamentally ( I think ) doesn't have zipper structure
09:49:46 <lament> SamB_XP_: strange, i have always found the idea of OO pretty intuitive
09:49:53 <jmcarthur_work> mux, i'm actually applying extend to a case that doesn't quite fit it i think, thanks to [] not actually being a comonad, i think
09:50:13 <mux> ezyang: I don't care about zippers, I was thinking of applicative functors
09:50:21 <kmc> there's nothing wrong with OOP, and no reason to see it as an opponent of functional programming
09:50:27 <benmachine> apparently linspire got bought by xandros
09:50:31 * benmachine wonders what this means
09:50:42 <lawful_evil> what is interesting is that the division of labor of you will in web apps always follow the pattern of data store and the query commands, usually postgresql and php these days wit the commands in scripts or a centralized freamwork app fo some sort
09:50:57 <ezyang> mux: Hmmm
09:51:16 <lawful_evil> I look at that an wonder about the inefficiencies of moving data and state around to different programs, if that is duplication of effort...etc.
09:51:24 <jethr0> osiant: that's why i wrote superset. can IORefs do anything that MVars can't?
09:51:33 <lawful_evil> why shouldn't 1 program accept a web call and process it?
09:51:58 --- mode: ChanServ set +o osiant
09:52:21 --- kick: lawful_evil was kicked by osiant (osiant)
09:52:36 * benmachine is confused
09:52:47 <benmachine> (how unusual.)
09:52:57 --- mode: osiant set -o mauke
09:53:02 --- mode: osiant set -o osiant
09:53:07 <yrlnry> Why can't I   do { True; }?   The H98 report says that this should be the same as just True.
09:53:20 <osiant> yrlnry: doesn't it also add a type constraint?
09:53:20 <burp> @hoogle base64
09:53:21 <lambdabot> package base64-string
09:53:25 <quicksilver> osiant: was that really justified?
09:53:27 <jethr0> > do {True}
09:53:28 <lambdabot>   True
09:53:30 <osiant> quicksilver: yes
09:53:32 <quicksilver> osiant: he was rambling a bit but...
09:53:41 <burp> http://www.haskell.org/crypto/doc/html/Codec-Binary-Base64.html this seems to be gone in the newest Crypto package
09:53:42 <jethr0> yrlnry: ';' is for separating monadic actions
09:53:48 <jethr0> not as end-of-line characters
09:53:49 <osiant> quicksilver: yes, and that's all he does
09:53:50 <quicksilver> osiant: for future reference, why?
09:53:51 <kmc> :t do { True; }
09:53:52 <lambdabot> Bool
09:53:57 <jethr0> hmm
09:53:59 <osiant> quicksilver: are you familiar with @protontorpedo?
09:54:01 <kmc> jethr0, ; is not an operator
09:54:05 <yrlnry> kmc:  Interesting.  GHCI rejected it.
09:54:07 <kmc> it is for separating anything
09:54:12 <kmc> including let defns, cases, etc
09:54:13 <quicksilver> osiant: only by reputation :)
09:54:17 <Badger> @protontorpedo
09:54:17 <lambdabot> is haskell able to outdo perl or python for web?
09:54:21 <osiant> well, that was him
09:54:26 <benmachine> @help protontorpedo
09:54:26 <lambdabot> protontorpedo is silly
09:54:27 <jethr0> yrlnry: does it work without the trailing ';'?
09:54:30 <benmachine> I see
09:54:31 <lament> @protontorpedo
09:54:31 <lambdabot> I read somewhere that large systms get confusing and haskell ends up a s a bunch of functions
09:54:32 <quicksilver> osiant: ah ;)
09:54:35 <yrlnry> kmc: "Couldn't match expected type `t t1' against inferred type `Bool'"
09:54:35 <kmc> haskell's whitespace-dependent layout syntax is specified as a away to insert invisible braces and semicolons
09:54:37 <ezyang> I don't understand why this computation would have applicative structure.
09:54:51 <kmc> yrlnry, did you try to eval it in ghci or just get its type?
09:55:01 <lament> every dentist offers invisible braces now.
09:55:03 <yrlnry> I just tried to :t it.
09:55:04 <ezyang> (re mux)
09:55:17 <kmc> all of those work in my ghci 6.10.4
09:55:17 <sohum> what's protontorpedo?
09:55:22 <yrlnry> Executing it fails for the same reason.
09:55:23 <roconnor> haskell ends up as a bunch of functions?!
09:55:25 <yrlnry> Let me check my version.
09:55:26 <osiant> quicksilver: once you know a bit about him, spotting him after one or two lines is pretty easy. the *!n=g@* mask confirmed it
09:55:36 <yrlnry> 6.8.2.
09:55:41 <yrlnry> Thanks.
09:59:25 <lilac> > do { ; ; ; True; ; ; ; }
09:59:26 <lambdabot>   True
09:59:48 <Athas> Is anyone working on putting a more high-level library on top of XHB?
09:59:55 <roconnor> > do {}
09:59:56 <lambdabot>   <no location info>: Empty 'do' construct
10:00:13 <yrlnry> The H98 report doesn't define do {}.
10:00:30 <kmc> > let {} in 3
10:00:31 <lambdabot>   3
10:00:38 <kmc> >
10:00:38 <burp> @hoogle [[a]] -> [a]
10:00:38 <lambdabot> Prelude concat :: [[a]] -> [a]
10:00:38 <lambdabot> Data.List concat :: [[a]] -> [a]
10:00:38 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
10:00:41 <kmc> > case 3 of {}
10:00:42 <lambdabot>   <no location info>: parse error on input `}'
10:01:16 <Axman6> > let undef | False = undef in undef
10:01:17 <lambdabot>   * Exception: <interactive>:1:137-157: Non-exhaustive patterns in function u...
10:01:21 <yav> kmc: the empty case could actually be useful on occasion. we were discussing adding to haskell at one of the lists
10:01:23 <sohum> @hoogle m m a -> m a
10:01:24 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
10:01:24 <lambdabot> Control.Monad.ST runST :: ST s a -> a
10:01:24 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
10:01:33 <yrlnry> @hoogle (b -> m c) -> (a -> m b) -> (a -> m c)
10:01:33 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
10:01:33 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:01:33 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
10:01:43 <yrlnry> Nice.
10:01:57 <yrlnry> @hoogle ((p -> q) -> p) -> p
10:01:57 <lambdabot> No results found
10:02:27 <yav> @hoogle ((p -> m q) -> m q) -> m q
10:02:28 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
10:02:38 <yrlnry> @hoogle ((p -> q) -> q) -> p)
10:02:38 <lambdabot> Parse error:
10:02:38 <lambdabot>   --count=20 "((p -> q) -> q) -> p)"
10:02:38 <lambdabot>                                  ^
10:02:43 <yrlnry> @hoogle ((p -> q) -> q) -> p
10:02:44 <lambdabot> No results found
10:03:00 <yrlnry> @hoogle p->p
10:03:00 <lambdabot> Prelude id :: a -> a
10:03:00 <lambdabot> Data.Function id :: a -> a
10:03:00 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
10:03:43 <Axman6> > (\x -> x x) id 3
10:03:44 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
10:03:50 <Axman6> :(
10:03:53 <yrlnry> I notice that asking it for a-> a does not find all instances of a->a.
10:04:00 <kmc> what's a reasonable use of the continuation monad?
10:04:28 <yav> kmc: it is useful when you have complex control flow in a program
10:04:40 <lilac> kmc: IOHCC entries? :)
10:04:59 <yav> Axman6: what do you think should be the type of "x" in that expression?
10:05:05 <benmachine> iohcc sounds like it would be a lot of fun
10:05:06 <kmc> yav, can you give an example? typically i find an advantage of haskell / FP is not having to reason about control flow at all
10:05:11 <kmc> (especially in a lazy context)
10:05:18 <benmachine> or a cross between hilarious and soul-crushing
10:05:26 <SamB_XP_> lament: okay, OO means a few things
10:05:37 <yrlnry> Why does  @hoogle (a -> b) -> b -> a  find  a function with type (a->a) -> a -> a, but   @hoogle a->b doesn't find absolutly everything?
10:05:38 <Axman6> yav: i couldn't remember if that worked or not. i know quite well why it shouldn't though :)
10:05:39 <SamB_XP_> but not everyone can agree on exactly what it means
10:05:43 <ezyang> "deriving (Soul, Heart)"
10:05:48 <SamB_XP_> I guess it's a bit like FP, really ;-P
10:05:48 <lament> SamB_XP_: that's true of most things in life
10:05:55 <lament> including FP, sure :)
10:06:06 <sohum_> > :t join
10:06:07 <lambdabot>   <no location info>: parse error on input `:'
10:06:10 <lilac> benmachine: i wonder how hard it'd be to organise that
10:06:12 <kmc> SamB_XP_, i have a precise definition of FP which i like to hit people over the head with
10:06:14 <benmachine> yrlnry: hoogle approximates I think
10:06:18 <sohum_> @t join
10:06:18 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:06:23 <kmc> or of functional languages anyway
10:06:30 <jmcarthur_work> : join
10:06:32 <jmcarthur_work> :t join
10:06:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:06:36 <lilac> kmc: IEEE754? :-)
10:06:40 <kmc> which is that functions are first class, no more or less
10:06:41 <benmachine> as well as substituting types in a strict manner, it finds things which sort of look right-ish
10:06:41 <lament> kmc: the beauty of precise definitions is that there're so many of them
10:06:43 <kmc> har har
10:06:44 <yav> kmc: you are correct. i don't use continuations much either.  an example might be if you are programming a server that is performing a number of simlutaneous  transactions, and you want to "save" the state of a transaction.
10:06:47 <sohum_> ...oh. thankee, jmcarthur_work
10:07:05 <yrlnry> benmachine: Oh, so it's not that it understands that (a->a)->a->a is an instance of (a->b)->b->a, but rather that it's just doing some sort of string matching?
10:07:06 <benmachine> kmc: is python functional then?
10:07:10 <kmc> yes
10:07:25 <jmcarthur_work> there are many definitions for functional
10:07:32 <kmc> i guess it's harder to define functional programming "style" as opposed to the minimal necessary features
10:07:32 <benmachine> yrlnry: um, both perhaps
10:07:49 <kmc> certainly python does not encourage the *use* of first-class functions nearly as much as scheme
10:08:13 <benmachine> kmc: is a feature of a programming langauge that no-one ever uses still a feature? :P
10:08:18 <yrlnry> "Closures aren't important" -- GvR
10:08:19 <jmcarthur_work> mux, sorry, i quit. i do think there must be a reasonable combinator to describe this kind of function, but i should be working
10:08:34 <kmc> benmachine... why wouldn't it be
10:08:35 <jfoutz> kmc: early exit from foldM?
10:08:37 <jmcarthur_work> mux, i still think looking at a zipper-based formulation would be worth the time
10:08:41 <SamB_XP_> kmc: it doesn't discourage it nearly as much as C does, though
10:08:45 <mux> jmcarthur_work: thanks anyways :)
10:08:49 <jmcarthur_work> mux, i'm not sure how you hope Applicative applies
10:08:56 <SamB_XP_> yrlnry: when did he say that?
10:09:00 <kmc> and the functional features in python are commonly used, if that's what you mean
10:09:06 <mux> I have no idea, as I said it just seemed to resemble the zipWith generalization problem
10:09:08 <SamB_XP_> I'm pretty sure he's recanted at least that bit ...
10:09:09 <Orclev> is there a simple way to take an array [a] and convert it into [[a]] where each sub-array contains 20 or fewer pieces of the original array?
10:09:14 <arw_> its also possible to do something like closures in java. nobody would ever call java functional...
10:09:17 <sohum> I believe I heard somewhere that a lot of higher order functions are nonexistent, neutered, or going to be in python
10:09:21 <yrlnry> SamB_XP: In a hallway at OSCON a few years ago.
10:09:22 <kmc> arw_, i would
10:09:23 <Vanadium> Orclev: Yes
10:09:27 <benmachine> kmc: I dunno, but I tend to characterise languages more by how they are used than how they could be used
10:09:43 <jmcarthur_work> sohum, guido seems to have a vendetta against functional features
10:09:43 <arw_> kmc: thanks for spoiling my argument :)
10:09:44 <kmc> sohum, they're moving things like map and filter into a module. which you can import and use as before
10:09:46 <Orclev> Vanadium: something like foldl (take 20)?
10:09:54 <Orclev> ... or maybe foldr
10:09:54 <yrlnry> SamB_XP_: Tom Christiansen asked him "Guido, why doesn't Python have closures", and Guido said "Closures aren't important".
10:09:59 <benmachine> I suppose my line of thinking is that though it'd be possible to write python sort of like I write haskell, it wouldn't be sensible
10:10:00 <jmcarthur_work> kmc, ah, that is different from what i've heard. that's better at least
10:10:01 <yrlnry> Then he argued the point.
10:10:08 <Vanadium> Mhm, I think we discussed that a couple days back, but it appears I forgot the details.
10:10:10 <kmc> jmcarthur_work, perhaps i'm misinformed
10:10:16 <yrlnry> I don't know if he still thinks that, but I wouldn't be surprised.
10:10:17 <SamB_XP_> yrlnry: well, see, Python has closures now
10:10:22 <sohum> kmc: ah, fair enough
10:10:23 <lament> python has closures??
10:10:26 <lament> 3k?
10:10:32 <jmcarthur_work> he doesn't like closures, TCO, or combinators
10:10:36 <ezyang> lament: well, they've had it for a while
10:10:38 <ezyang> "sort of"
10:10:40 <yrlnry> Python has closures?
10:10:45 <lament> sort of doesn't count
10:11:03 <yrlnry> Last time I looked you had to bind the closure arguments into and array and then do mumblety mumble to get it to work.
10:11:04 <jethr0> weird. i have two threads deadlocking on a single MVar *scratches his head*
10:11:05 <ezyang> I've always been able to def a function and access variables from the outer context
10:11:05 <SamB_XP_> lament: what do *you* want them to do?
10:11:19 <ezyang> but only if they're mutable
10:11:22 <kmc> yup, every function object has a "func_closure" attribute
10:11:27 <ezyang> (the array mumble mumble)
10:11:30 <kmc> and yes closing over mutable variables is weird, but it's weird in scheme too
10:11:31 <ezyang> Also, Python is late binding
10:11:32 <yrlnry> Oh, right.  okay.
10:11:40 <lament> SamB_XP_: unlike FP and OOP, closures certainly do have a precise, agreed-upon definition :)
10:11:41 <SamB_XP_> kmc: I just figured that was always wierd!
10:11:50 <ezyang> Like, mutable variables mess things up a lot
10:12:07 <SamB_XP_> lament: yeah, sure, in the absence of mutable variables ;-)
10:12:09 <kmc> people incl. myself get confused when you build a bunch of closures in a for loop and they all end up with the last value of the loop variable
10:12:15 <lament> SamB_XP_: or in the presence
10:12:17 <ezyang> kmc: yup
10:12:26 <jethr0> ezyang: yes, but how can a deadlock occur with only one resource?!?
10:12:29 <ezyang> kmc: So you need to build a stack frame manually
10:12:29 <lament> SamB_XP_: read SICP :)
10:12:30 <SamB_XP_> lament: I don't think so!
10:12:38 <kmc> but it's what scheme would do, or Haskell if your loop variable were an IOVar
10:12:44 <kmc> it's just nobody programs that way in scheme or haskell
10:12:45 <ezyang> jethr0: ?
10:12:55 <jmcarthur_work> jethr0, if both threads are waiting on an empty mvar, that's a deadlock
10:12:57 <jethr0> one thread takes the resource, another tries to and the first never releases it...
10:13:08 <jethr0> shouldn't be empty...
10:13:13 <jethr0> actually, isn't
10:13:21 <jmcarthur_work> code?
10:13:27 <SamB_XP_> yeah, presumably scheme loops are usually done with macros that expand to tail-recursive functions
10:13:37 <kmc> IORef*
10:13:52 <kmc> or straight-up map
10:13:54 <ezyang> I wonder if "revenue recognition" has the vocabulary I'm looking for
10:14:06 <jethr0> @paste
10:14:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:14:12 <SamB_XP_> kmc: or that, yeah, but that doesn't bind any variables at all so...
10:15:32 * SamB_XP_ wonders why Google Reader doesn't include any indication of which feed is being viewed in it's window title ...
10:15:43 <ezyang> If I have a clear name for a variable with value n, but the code is simpler/more concise if the variable has value n-1, which do I opt for?
10:16:13 <jmcarthur_work> opt for point free ;)
10:16:19 <jmcarthur_work> more seriously, i guess it just depends
10:16:44 <SamB_XP_> ezyang: predN
10:17:07 <yrlnry> I've sometimes had simpleClearName = ...   scl' = simpleClearName - 1, with the idea that that way the code is simple, and the semantics of the badly-named "scl'" variable should be clear because of the adjacent declaration of SimpleClearName.
10:17:08 <SamB_XP_> that is, put pred in front of the clear name you had for the variable to name the variable-1
10:17:11 <yrlnry> But I guess it just depends.
10:17:21 <jethr0> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9047#a9047
10:17:25 <ezyang> Both excellent ideas
10:17:26 <benmachine> what is the real difference between Ix and Enum?
10:17:31 <yrlnry> :Ix
10:17:39 <ezyang> :t Ix
10:17:39 <yrlnry> typo, sorry
10:17:40 <lambdabot> Not in scope: data constructor `Ix'
10:17:40 <SamB_XP_> or, yeah, you could just do what yrlnry suggestsed
10:17:45 <benmachine> it seems to me like the Ix operations are pretty similar to the Enum operations
10:17:47 <SamB_XP_> that should be pretty clear too
10:17:57 <SamB_XP_> benmachine: well, Ix works on tuples
10:17:59 <SamB_XP_> enum doesn't
10:18:13 <SamB_XP_> also, Ix has pretty clear semantics
10:18:25 <jethr0> jmcarthur_work: ah, problems already solved. actually i haven't got threads but it's all sequential. therefore on thread is deadlocking with two accesses to MVar ;)
10:18:28 <Axman6> @src Ix
10:18:29 <lambdabot> class (Ord a) => Ix a where
10:18:29 <lambdabot>     range           :: (a,a) -> [a]
10:18:29 <lambdabot>     index           :: (a,a) -> a -> Int
10:18:29 <lambdabot>     inRange         :: (a,a) -> a -> Bool
10:18:29 <lambdabot>     rangeSize       :: (a,a) -> Int
10:18:31 <SamB_XP_> since it's for indexing arrays ;-)
10:18:41 <yrlnry> SamB:_XP_: I have a couple of programs somewhere with variables named blahm1, where "m1" stands for "minus 1".  I'm ashamed of it, but I couldn't do better at the time.
10:18:52 <jmcarthur_work> jethr0, i was about to say. there is no fork there ;)
10:19:00 <SamB_XP_> yrlnry: well, predBlah is a bit clearer I think ;-)
10:19:16 <benmachine> SamB_XP_: hmm, why can't tuples be enums?
10:19:25 <jmcarthur_work> jethr0, btw, i like to do callback code like this by setting new callbacks with closures whenever i want to update the "state"
10:19:26 <benmachine> (presuming enumerable parts)
10:19:31 <jethr0> jmcarthur_work: who knows what these toolkits do in their initialization routines. but in this case it seems to be sequential
10:19:31 <yrlnry> SamB_XP_:  You have to target the intended audience; I'm sure predBlah would have been less clear.
10:19:42 <quicksilver> benmachine: because, weirdly, Enum isn't about being enumerable.
10:19:52 <quicksilver> benmachine: Enum is about that stupid [a..b] syntax ;)
10:19:52 <SamB_XP_> yrlnry: whatever ;-)
10:19:56 <SamB_XP_> what language was it?
10:20:04 <benmachine> quicksilver: okay, so why can't tuples do that?
10:20:06 <yrlnry> Probably Perl.
10:20:10 <benmachine> hmm
10:20:10 <yrlnry> Possibly Java.
10:20:15 <quicksilver> benmachine: (but yes, logically, a tuple of finite Enums is Enum)
10:20:18 <yrlnry> Conceivably C.
10:20:32 <quicksilver> benmachine: the type system can't tell the difference between Enum and FiniteEnum though
10:20:36 <quicksilver> which is probably why it doesn't do it.
10:20:40 <SamB_XP_> benmachine: well, I think the thing is nobody knows what exactly should [(10,0)..(0,10)] consist of ?
10:20:56 <sohum> quicksilver: isn't being able to define semantics for the a..b syntax exactly what it means to be enumerable?
10:21:12 <quicksilver> no
10:21:22 <quicksilver> Double has an a..b instance
10:21:23 <SamB_XP_> and that fromEnum/toEnum screws things up immensely
10:21:32 <benmachine> SamB_XP_: what should range ((10,0),(0,10)) consist of? isn't that the same question?
10:21:50 <SamB_XP_> sohum: and have you ever noticed that the instance for Ratio doesn't work right?
10:21:53 <quicksilver> but Double is either (a) not Enumerable (if you think it is an approximation to real numbers) or (b) if it is Enumerable, it certainly isn't in that way ;)
10:21:54 <SamB_XP_> benmachine: not a bit!
10:21:58 <SamB_XP_> that's a rectangle
10:22:21 <SamB_XP_> quicksilver: yeah, it's enumerable in a couple ways
10:22:26 <ray> quicksilver: i think the instance should be for the way it really is enumerable
10:22:33 <benmachine> okay it's kind of weird, but I think I see
10:22:37 <jmcarthur_work> > [1%3..10%3]
10:22:38 <lambdabot>   [1 % 3,4 % 3,7 % 3,10 % 3]
10:22:42 <Vanadium> @pl (\(a, b) -> a : if null b then [] else split n b)
10:22:42 <lambdabot> uncurry ((. ap (flip if' [] . null) (split n)) . (:))
10:22:45 <SamB_XP_> but most of the ways you'd want to actually use would fold most of the NaNs together
10:22:59 <SamB_XP_> I think
10:23:01 <Vanadium> @pl (\(a, b) -> a : f n b)
10:23:01 <lambdabot> uncurry ((. f n) . (:))
10:23:03 <quicksilver> ray: that's because you think Enum is about enumeration.
10:23:16 <quicksilver> ray: which is a reasonable view, but not the view the haskell report takes.
10:23:22 <quicksilver> the haskell report thinks it is about [a..b]
10:23:28 <benmachine> class SillyDotSyntaxImplementation where
10:23:32 <quicksilver> > [5.0..10.0]
10:23:32 <ray> that should be a different class
10:23:33 <lambdabot>   [5.0,6.0,7.0,8.0,9.0,10.0]
10:23:35 <SamB_XP_> quicksilver: which it is, basically
10:23:37 <SamB_XP_> as it stands
10:23:42 <benmachine> ray: what would you call it?
10:23:45 <quicksilver> SamB_XP_: yes, because the report defines ;)
10:24:03 <SamB_XP_> except, of course, they threw in that silly toEnum/fromEnum as well
10:24:07 <ray> actually, i think [5.0..10.0] should give you a largely useless result based on the actual float enumeration
10:24:10 <quicksilver> I'd call it "FromThenTo", I think.
10:24:14 <greap> Is there a way to define multiple records with a commonly named accessor in one module? I know you can do it if the records are constructors of an algeb.. data type, but when they aren't I get collision errors.
10:24:18 <SamB_XP_> quicksilver: that's a good idea
10:24:26 <benmachine> seconded
10:24:29 <SamB_XP_> what would you do about fromEnum/toEnum?
10:24:35 <benmachine> nuke them? :P
10:24:35 <quicksilver> put them in the 'real' Enum cluss
10:24:43 <quicksilver> not in FromThenTo
10:24:49 <ray> change their type to have Integer
10:24:51 <yrlnry> ray: you mean that you think that [5.0 .. 10.0] should be [5.0, 5.0 + 2^^(-43), ... 10.0]?
10:24:53 <quicksilver> and that, yes.
10:25:03 <ray> yrlnry: yes
10:25:07 <SamB_XP_> greap: you really can't, I think?
10:25:13 <yrlnry> ray:  Okay.
10:25:18 <ray> that's what "largely useless" means
10:25:27 <quicksilver> greap: Is there a way to write two functions with the same name in the same module.
10:25:32 <ezyang> jmcarthur_work: I suppose this isn't substantially better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9048#a9048
10:25:33 <quicksilver> greap: ... because that's what you're asking.
10:25:50 <ray> the float trainwreck and the enum trainwreck are seperate trainwrecks
10:25:52 <SamB_XP_> greap: you should just prefix them with the initials of the datatype, I think, and then define (a) typeclass(es) for more convenient accessors ...
10:25:54 <quicksilver> greap: accessors aren't really accessors, or field names. They are functions. (selector functions) together with some weird syntactical sugar.
10:25:54 <jfoutz> > [1.0,1.1..2.0]
10:25:56 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
10:25:58 <ray> they just, er, intersect
10:25:59 <SamB_XP_> if you really want that
10:26:07 <benmachine> > last [1.0,1.1..2.0]
10:26:09 <lambdabot>   2.000000000000001
10:26:11 <quicksilver> ray: right, and the enum one isn't particularly hard to fix, is it?
10:26:12 <benmachine> *gasp*
10:26:16 <benmachine> > last [1.0,1.3..2.0]
10:26:17 <ray> right
10:26:17 <lambdabot>   1.9000000000000001
10:26:27 <quicksilver> ray: just change the type to Integer and decide if you want it 0-based or 1-based.
10:26:29 <benmachine> > last [0.1,0.3..0.8]
10:26:30 <lambdabot>   0.8999999999999999
10:26:30 <ray> it's not hard, and the solution to the float trainwreck is to make floats third-class citizens
10:26:41 <benmachine> ^ that is just off
10:26:45 <SamB_XP_> quicksilver: I would think the float one would be easier to fix ...
10:26:56 <ray> benmachine: no, 0.8 == 0.9
10:26:57 <sohum> third class citizens?
10:26:59 <ray> haven't you got the memo?
10:27:05 <SamB_XP_> quicksilver: which breakages did you mean though ?
10:27:17 <benmachine> ray: ah yes, of course
10:27:22 <benmachine> silly me.
10:27:34 <roconnor> floats shouldn't be part of enum
10:27:36 <greap> quicksilver: How come it works when they are defined in an ADT then?
10:27:38 <SamB_XP_> there ought to be a trac for griping about the Haskell typeclass hierarchies ;-)
10:27:45 <roconnor> or emum should at least be broken into two pieces
10:27:47 <SamB_XP_> and suggesting improvements
10:27:51 <ray> haskell.org/gripes
10:27:54 <SamB_XP_> roconnor: possibly three
10:28:04 <quicksilver> greap: because that is defining a single function.
10:28:08 <SamB_XP_> ray: you just made that up ;-P
10:28:08 <quicksilver> greap: (not two functions)
10:28:17 <ray> samb_xp_: suggesting a url
10:28:31 <SamB_XP_> ray: ah, okay.
10:28:32 <quicksilver> greap: data Foo = A { a :: Int} | B { a :: Int} defines a single function a of type Foo -> Int
10:28:43 <benmachine> someone should implement class aliases!
10:28:44 <roconnor> The Enum instance for Float doesn't enumarate the Floats, even though Floats are enumerable.
10:28:56 <greap> quicksilver: Ah I see
10:29:03 <SamB_XP_> I think a better one might be hackage.haskell.org/trac/haskell-gripes
10:29:06 <ray> someone should make a concrete class aliases proposal, liberally annotated with examples
10:29:13 <quicksilver> greap: data Foo = A { a :: Int }; data Bar = B { a :: Int } tries to define two, one of type Foo -> Int and one of type Bar -> Int
10:29:19 <roconnor> @wiki TheOtherPrelude
10:29:19 <lambdabot> http://www.haskell.org/haskellwiki/TheOtherPrelude
10:29:22 <quicksilver> roconnor: yes, we just agreed that :)
10:29:30 <SamB_XP_> ray: mostly because they already have a working trac on hackage.haskell.org
10:29:38 <SamB_XP_> and because that one gets google indexed
10:29:59 <roconnor> @wiki The_Other_Prelude
10:29:59 <lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
10:30:04 <SamB_XP_> ray: and with a parser that parses the examples
10:30:11 <benmachine> ray: that sounds excitingly like something I could help do, but what are the odds of it actually being taken seriously?
10:30:24 <SamB_XP_> ray: john's examples wouldn't parse when I tried to implement class aliases
10:30:26 <ray> they're directly proportional to the shouting i think
10:30:34 <SamB_XP_> though that was hardly the worst issue I encountered!
10:30:39 <ray> i promise to shout about it if it's good
10:30:48 <jmcarthur_work> ezyang, a little, but it could be improved further
10:30:49 <ray> or make a logo in inkscape
10:30:54 <benmachine> ray: <3 <3
10:31:00 * benmachine prepends to his todo list
10:31:06 <SamB_XP_> benmachine: just make sure to create a branch of haskell-src-exts that parses it to go with the proposal!
10:31:14 <yrlnry> Wow.   Michael A. Jackson, author of "Principles of Program Design", is know the best-known living person with that name.  Who would have predicted that?
10:31:22 <yrlnry> s/know/now/
10:31:29 <SamB_XP_> yrlnry: he is?
10:31:34 <jethr0> how frowned upon is the use of unsafePerformIO for initialization of top level CAFs?
10:31:38 <SamB_XP_> yrlnry: how do you tell that?
10:31:45 <benmachine> SamB_XP_: I may well start trying and will almost certainly fail but maybe in a sufficiently interesting way to let someone else finish it
10:31:48 <SamB_XP_> jethr0: depends what you do with it
10:31:48 <yav> jethr0: quite
10:31:51 <jethr0> i.e. "state = unsafePerformIO $ newMvar 0"
10:31:52 <jmcarthur_work> jethr0, making a global?
10:31:54 <SamB_XP_> jethr0: what are you gonna do?
10:31:59 <roconnor> jethr0: a little
10:32:04 <quicksilver> jethr0: depends who by.
10:32:05 <jethr0> jmcarthur_work: yes
10:32:08 <jmcarthur_work> jethr0, that is a common but ugly idiom ;)
10:32:10 <quicksilver> jethr0: I frown upon it muchly.
10:32:13 <SamB_XP_> depends what things you use in the IO
10:32:17 * quicksilver frowns for demonstration.
10:32:22 <SamB_XP_> it would be way better if you could do it with ST, certainly
10:32:36 <jmcarthur_work> jethr0, like i said, i prefer to set new callbacks with closures to update state with things like GLUT/GLFW, etc.
10:32:37 <SamB_XP_> jethr0: so ... what did you want to accomplish?
10:32:37 <ezyang> jmcarthur_work: does memberCollect or latestPaidTerm need further decomposition?
10:32:39 * yav frowns in agreement
10:32:46 <ezyang> (or both of them need it?)
10:32:58 <jmcarthur_work> ezyang, i think there are still some things that can be abstracted out, most likely
10:33:13 <yrlnry> SamB_XP_: I pull it out of my ass, obviously.
10:33:22 <jethr0> i am writing a game and the main loop wants to have IO callbacks. but I only have "StateT .. IO a" callbacks. and i'm using such a global to store the state between calls.
10:33:36 <jmcarthur_work> ezyang, i'm afraid to invest time in it here at work and without intimate details of what's going on, though
10:33:37 <SamB_XP_> I, for one, certainly dislike the Inform decompiler's usage of unsafePerformIO
10:33:41 <kmc> @hoogle Maybe [a] -> [Maybe a]
10:33:41 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:33:42 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:33:42 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
10:33:46 <SamB_XP_> it makes testing it a huge PITA
10:33:49 <jethr0> jmcarthur_work: like the code i posted earlier. is that objectionable? are there better reasonable solutions?
10:33:54 * ezyang nods 
10:34:08 <SamB_XP_> GHCs is maybe a *bit* more justified -- but then again maybe not!
10:34:14 <SamB_XP_> jethr0: URL?
10:34:20 <jmcarthur_work> jethr0, at the end of each state-changing callback, setCallbackA funcA newState, etc.
10:34:29 <quicksilver> jethr0: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
10:34:44 <jmcarthur_work> or whatever
10:34:48 <jethr0> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9047#a9047
10:34:58 <quicksilver> simpler to close over an IORef (or Mvar)
10:35:22 <jmcarthur_work> jethr0, oh, you have an explicit loop
10:35:41 <jethr0> jmcarthur_work: for this toolkit yes, but GLUT for example has only callbacks
10:35:57 <jmcarthur_work> jethr0, in that case, why use a callback for the keyboard instead of polling?
10:35:58 <jethr0> jmcarthur_work: i don't quite get your "newState" idea...
10:36:03 <quicksilver> jethr0: just create the IORef in the scope that creates the callbacks
10:36:11 <quicksilver> jethr0: (rather than tring to create it at the top level)
10:36:19 <jmcarthur_work> but yeah, what quicksilver says would be a less invasive change
10:36:19 <quicksilver> jethr0: then the callbacks have a reference to the IORef (or MVar) and it's all OK.
10:36:22 <jethr0> i am binding to different toolkits because windows and macos are a bit fickle with setting up SDL
10:36:25 <roconnor> quicksilver: that's a mighty fine link
10:36:33 <quicksilver> roconnor: very kind of you to say so.
10:36:36 <mux> jmcarthur_work, ezyang : yay, I think I've got it
10:36:44 <jethr0> quicksilver: good idea. should be possible! thx
10:37:14 <roconnor> quicksilver: I suspected doing something like that should be possible.  It's nice to see it does work.
10:37:16 <ezyang> mux: whoo, what did you use?
10:37:35 <mux> ezyang: it's a cross between my own poor version and yours; I think it is quite nice and it hsould be efficitn too
10:37:38 <mux> just a second :-)
10:37:45 <jethr0> quicksilver: thanks for the link. spot on! reading it right now
10:38:38 <roconnor> presumably this is all on hackage somewhere ^_^
10:38:55 <quicksilver> someone coded up a version of it yes
10:39:09 <quicksilver> http://hackage.haskell.org/package/interleavableIO
10:39:13 <quicksilver> I haven't actually tried the code ;)
10:39:18 <quicksilver> writing emails to the cafe is more fiun.
10:39:41 <quicksilver> jethr0: you don't necessarily need all that complexity; pragmatically what I suggested above is the same thing, but less general
10:40:12 <defun_lab> Hey, how does HaskellDirect relate to the haskell FFI I keep healing about? Is it a replacement, or library utilizing it?
10:40:31 <SamB_XP_> defun_lab: a tool using it
10:40:38 <defun_lab> I see.
10:40:38 <SamB_XP_> but iirc it's rather bitrotted?
10:40:44 <jethr0> this is basically my code, but so much more localized!
10:40:46 <jmcarthur_work> huh never heard of it until now
10:41:00 <SamB_XP_> I suppose someone could have revived it
10:41:11 <lilac> is it common to think that Applicative should be a superclass of Monad? if so, what do people propose doing about Either, where (<*>) /= ap?
10:41:16 <jmcarthur_work> latest is '04
10:41:26 <defun_lab> Same goes for GreenCard and C->Haskell?
10:41:26 <jethr0> i wonder how expensive such a frequent use of newIORef is?
10:41:30 <mux> jmcarthur_work, ezyang: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9049#a9049
10:41:38 <ray> lilac: yes and newtype wrapeprs probably
10:41:45 <jmcarthur_work> lilac, that's nasty (Either)
10:41:46 <SamB_XP_> GreenCard and c2hs do both use the FFI, yes
10:41:51 <ray> or maybe fixing it
10:41:53 <defun_lab> ok thanks.
10:41:54 <SamB_XP_> but they're less bitrotted
10:41:56 <ray> i don't know that case
10:42:00 <ray> maybe Either's wrong
10:42:02 <defun_lab> ah. good.
10:42:21 <SamB_XP_> c2hs is probably not bitrotted at all, not quite sure about GreenCard
10:42:38 <lilac> jmcarthur_work: i saw that come up in -cafe a while back, someone was confused about transformers (they had two different ReaderTs, one using Applicative and one using Monad, giving rise to different transformed applicatives)
10:42:47 <ray> i prefer functor => pointed and pointed => applicative and pointed => monad
10:42:48 <SamB_XP_> I mean, c2hs probably usually works with GHC HEAD ;-)
10:42:51 <mux> ezyang: using the function parameter, I can avoid the whole "map over the list adding stuff back" stuff
10:42:56 <defun_lab> kk
10:42:58 <lilac> i'm pretty sure that the Either Applicative is right, and there's no corresponding Monad
10:43:02 <jmcarthur_work> lilac, i think all Monads should be Applicative and it should be such that ap = (<*>)
10:43:04 <ezyang> mmm
10:43:18 <jethr0> i hate these old-as-methusalem libraries. up until its rejuvination "hat" was a complete timetravel back to 2001 or sth
10:43:23 <jmcarthur_work> lilac, the Monad instance is defined in Control.Monad.Error
10:43:34 <ray> lilac: it degenerates to Maybe
10:43:37 <jmcarthur_work> oh, not corresponding to the Applicative instance, n/m
10:43:46 <ray> lilac: i agree with you, kinda
10:44:11 <lilac> "collect together all the errors" just seems like the /right/ behaviour for an Either applicative
10:44:15 <mux> ezyang: elements don't come off in a nice order though
10:44:18 <jmcarthur_work> i am not familiar with the Either Applicative
10:44:20 <Vanadium> ray: Is there any chance of this functor => pointed => applicative => monad thing happening as far as base is concerned?
10:44:29 <lilac> if you're using the monadic one, why are you using an applicative rather than a monad?
10:44:34 <ray> it's possible
10:44:53 <ray> i think base should be shaken up
10:44:57 <ray> so do other people
10:45:37 <ray> haskell prime is conservative by design, so they won't do it, but that doesn't mean it is not a future possibility
10:45:37 <Vanadium> I have literally no idea of the theory involved, I just feel a bit uncomfortable trying to get used to the "current" way of doing things when so many clever people think it could be improved
10:45:41 <ray> for haskell unboxed
10:45:56 <ray> vanadium: if you learn enough haskell, you might come to some of these conclusions on your own
10:46:15 <Orclev> what's the function that has a signature like [a] -> [b] -> [(a, b)]?
10:46:16 <Vanadium> I can agree with the intuitive arguments
10:46:16 <mux> ezyang: that's better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9050#a9050
10:46:21 <lilac> Orclev: zip
10:46:24 <mux> Orclev: zip
10:46:30 <ray> :t zip
10:46:32 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
10:46:40 <Orclev> ok, thanks... that terminates if either list runs out right?
10:46:41 <Vanadium> :t unzip
10:46:42 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
10:46:46 <lilac> > zip "<lilac> Orclev: zip" "<mux> Orclev: zip"
10:46:46 <ray> yes
10:46:47 <lambdabot>   [('<','<'),('l','m'),('i','u'),('l','x'),('a','>'),('c',' '),('>','O'),(' '...
10:47:07 <ray> > zip "abcd" "ab"
10:47:08 <lambdabot>   [('a','a'),('b','b')]
10:47:24 <ray> > zip "abc" "adab"
10:47:25 <lambdabot>   [('a','a'),('b','d'),('c','a')]
10:47:29 <mux> > zip [1..] [10,9..1]
10:47:31 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
10:47:44 <ray> > unzip [(1,2),(3,4)]
10:47:45 <lambdabot>   ([1,3],[2,4])
10:47:54 <ezyang> This is a laaame type signature:  MonadError MyError m => Member -> m (Maybe Term)
10:48:02 * SamB_XP_ dreads haskell unboxed :-(
10:48:07 <lilac> > fix((0:).(1:).(zipWith(+)<*>tail))
10:48:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:48:15 <mux> gasp
10:48:18 <ray> in haskell unboxed we'll have all sorts of things
10:48:21 <ezyang> zomg
10:48:24 <SamB_XP_> "what have you done with my beautiful polymorphism! noooooooo!"
10:48:28 <kmc> lilac, nice
10:48:31 <Vanadium> This is the first I hear of "haskell unboxed"
10:48:34 <Vanadium> is this a tongue-in-cheek thing?
10:48:37 <ray> sorta
10:48:42 <SamB_XP_> I think it needs a better name
10:48:47 <ray> someone once suggested Haskell# as a name
10:48:48 <Vanadium> No, the name is awesome :v
10:48:54 <ray> GHC uses Something# for unboxed types
10:48:55 <SamB_XP_> one less likely to induce fears of monomorphism!
10:48:55 <Vanadium> It just needs google search results
10:48:58 <ray> so, haskell unboxed
10:49:11 <Vanadium> So, the intuition is Haskell#?
10:49:17 <ray> also haskell is coming out of its box
10:49:18 <Vanadium> As in, .net?
10:49:20 <ray> metaphorically
10:49:23 <SamB_XP_> variables of kind # aren't really able to be polymorphic...
10:49:29 <Vanadium> Yeah, it is kind of a dorky way of spelling "unleashed", I suppose
10:49:47 <ray> samb_xp_: and yet any super advanced standard makes things super polymorphic
10:49:53 <lilac> "haskell# -- a functional portable assembler for the new generation"
10:50:50 <SamB_XP_> what is that drink that Dr. Mariner has made by one of those laser-shooting robots in Short Circuit?
10:51:03 <jfoutz> nun soup?
10:51:07 <SamB_XP_> no, no
10:51:08 <mux> hmm, combinationsAndRestOfWith would be a terrible name, I guess
10:51:11 <SamB_XP_> it involved a lemon
10:51:17 <SamB_XP_> and was shaken but not stirred ;-)
10:51:41 <SamB_XP_> mostly because the robot moved with too much third dirivative (aka jerk)
10:51:43 <mux> but I just can't think of anything better
10:52:15 <roconnor> mux: rename it lemon
10:52:45 <mux> heh.
10:53:00 <mux> oh, maybe I can have combinationsOf and combinationsOf' for the version that gives the rest too
10:53:08 <SamB_XP_> was the drink a cocktail?
10:53:10 <mux> and then combinationsOfWith and combinationsOfWith'
10:53:18 <SamB_XP_> you could call it HaskellShaken
10:53:31 * jfoutz can't remember. i vaguley remember the party you mention
10:53:33 <EnglishGent> but not sirred?
10:53:38 <EnglishGent> stirred?*
10:53:39 <EnglishGent> :)
10:54:22 <lilac> SamB_XP_: the word 'drink' occurs only once in the film, and it's Jonny 5 saying "That's a container. Drinking glass'
10:54:31 <SamB_XP_> ooh, Google Calander has labs now?
10:54:51 <SamB_XP_> lilac: well, one robot said "Your ______, Dr. Mariner."
10:55:20 <SamB_XP_> and Dr. Mariner said something like. "Ah. Shaken, but not stirred. Just the way I like it."
10:55:55 <jfoutz> imdb calls him Howard Marner
10:56:23 <SamB_XP_> jfoutz: well, the robot pronounced it like "Mariner" ...
10:56:30 <SamB_XP_> afaict
10:56:39 * jfoutz grins. just for help with grepping.
10:56:54 <SamB_XP_> ah!
10:57:18 <SamB_XP_> but I think I've decided the ______ had "cocktail" in it.
10:58:13 <mux> @pl \x y -> f x
10:58:13 <lambdabot> const . f
10:58:25 <mux> oooh.
10:59:28 <mux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9051#a9051
10:59:33 <mux> comments anyone?
11:00:44 <mux> the ' variants also return the list of the elements that were not chosen for each combination
11:00:49 <lilac> SamB_XP_: ok, my previous source was rubbish. :)
11:00:58 <sohum> :t go
11:00:59 <lambdabot> Not in scope: `go'
11:01:08 <sohum> oh, wait, woops
11:01:12 <sohum> I can't read code
11:01:14 <mux> hahah
11:01:26 <lilac> SamB_XP_: "Glass. Ice. Gin. Tonic. A squeeze of lime."
11:01:36 <SamB_XP_> lilac: yeah, I couldn't think how one of those robots could construe "Marner" to sound like "Mariner"
11:01:53 <SamB_XP_> oh, lime, not lemon?
11:01:58 <SamB_XP_> whatever ;-)
11:02:13 <mux> point-free style with two parameters really looks odd
11:02:26 <mux> (const . f) when you _know_ const gets called first
11:02:34 <mux> and think it should be (f . const)
11:02:36 <ray> crazy
11:02:39 <mux> at least it does this to me.
11:02:40 <jmcarthur_work> actually, (.) gets called first
11:02:43 <SamB_XP_> hehehe
11:02:45 <mux> right :-P
11:03:07 <ray> (.) can't be a function, something so useful has to be a keyword
11:03:18 <mux> ray: it is a function
11:03:42 <mux> (.) f g x = f (g x) -- that's how it is defined
11:03:48 <roconnor> @src (.)
11:03:49 <lambdabot> (f . g) x = f (g x)
11:03:52 <burp> :t forever . bracket
11:03:53 <lambdabot> Not in scope: `bracket'
11:03:54 <ray> i know that :)
11:04:25 <mux> roconnor: oh, btw, is the infix style in the definition of a function standard haskell98 or some extension?
11:04:47 <SamB_XP_> mux: which?
11:04:54 <SamB_XP_> you mean (f . g) x = f (g x)
11:04:59 <mux> yes
11:05:04 <Orclev> hmm... how would I convert a Word8 into a CInt?
11:05:05 <SamB_XP_> I think it's standard Haskell 98 that hugs doesn't implement
11:05:15 <mux> oh, that would epxlain a lot
11:05:18 <SamB_XP_> see the hugs manual for confirmation
11:05:32 <mauke> Orclev: fromIntegral
11:05:34 <roconnor> mux: using . for heirarchical module names is the extension
11:05:50 <Orclev> :t fromIntegral
11:05:51 <mux> yeah, I know that
11:05:51 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:05:53 <SamB_XP_> roconnor: that's hardly relevant to the question!
11:06:06 <roconnor> that definition doesn't work in hugs?!
11:06:20 <ray> silly hugs
11:06:23 <SamB_XP_> roconnor: I may be confused
11:06:36 <ray> i'm almost positive it's h98
11:06:38 <roconnor> that would be really really broken IMHO
11:06:40 * benmachine personally defines it as f . g = \x -> f (g x)
11:06:49 <SamB_XP_> but something of the sort was listed in the "broken stuff" section of the Hugs manual
11:06:56 <SamB_XP_> whatever it's actually called
11:07:03 <roconnor> benmachine: monorphismrestriction
11:07:13 <roconnor> oh wat
11:07:15 <roconnor> nevermind
11:07:15 <mauke> what
11:07:15 <jmcarthur_work> nope
11:07:21 <jmcarthur_work> no type class
11:07:29 <SamB_XP_> roconnor: even if that was applicable, a typesig would fix that
11:07:32 <mauke> arguments
11:07:48 <mux> The MR hits! The MR kicks! The MR hits! Hugs dies...--More--
11:07:56 <Vanadium> Hah
11:08:02 <benmachine> it wouldn't monomorphism anyway because it's a function binding
11:08:04 <Vanadium> Do you want your monads identified? (ynq)
11:08:05 <jfoutz> @quote adventure
11:08:06 <lambdabot> BMeph says: <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
11:08:10 * benmachine lags off into the sunset
11:08:19 <roconnor> benmachine: ya my bad.  I didn't see the parameters for some reason
11:08:42 <SamB_XP_> http://cvs.haskell.org/Hugs/pages/hugsman/diffs.html says, hmm...
11:08:42 <roconnor> @quote adventure
11:08:43 <lambdabot> BMeph says: <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
11:08:43 <lilac> apparently DDC will not even support "f . g = \x -> f (g x)" -- now THAT's broken ;-)
11:08:53 <roconnor> :)
11:09:06 <mux> You have killed 37629894 lambdas during your journey.--More--
11:09:08 <lilac> take lambda
11:09:35 <etpace_> @src (.)
11:09:35 <lambdabot> (f . g) x = f (g x)
11:09:37 <lilac> It is dark. You are likely to be trapped inside a Monad
11:10:03 <mux> You are in a closed room without windows.  There is only one door.  You have a monadic key, but it is broken.  It lacks a monad transformer.
11:10:08 <SamB_XP_> ... nothing ?
11:10:14 <mauke> http://arcanux.org/lambdacats/io-monad.jpg
11:11:02 <lilac> mux: it is a monad lacking a (monad transformer lacking a (state, a reader and a (GADT lacking a type annotation)))
11:11:10 <mux> hahhaha
11:11:32 <SamB_XP_> hmm, perhaps http://cvs.haskell.org/Hugs/pages/users_guide/haskell98.html#BUGS-HASKELL98 is more up-to-date
11:11:33 <mux> reminds me of a previous ICFP programming contest
11:11:34 <lilac> you may want to SWITCH your GOGGLES
11:12:04 <mux> erik naggum would hve hated me for using XML goggles instead of S-exp ones
11:12:19 <ray> @. yow lilac
11:12:19 <lambdabot> Plugin `compose' failed with: Unknown command: "lilac"
11:12:53 <dixie> what is this? I'm getting it on GHC 6.10.4 & lambdabot on FreeBSD: Main: caught (and ignoring) too few bytes. Failed reading at byte position 8
11:13:01 <roconnor> “Did you mean the orange-red V-9247-KRE,
11:13:02 <roconnor> the celadon V-9247-KRE, the green-yellow V-
11:13:04 <roconnor> 9247-KRE or the pale-brown V-9247-KRE?”
11:13:19 <SamB_XP_> huh, I didn't know class method types weren't allowed to place additional constraints on the class parameters ...
11:13:20 <mux> yeha, that was it
11:13:38 <jmcarthur_work> SamB_XP_, huh?
11:13:38 <Orclev> gah, anyone know anything about the haskell bindings to the X11 libraries?
11:13:47 <jmcarthur_work> i thought there were allowed
11:13:48 <mux> my brain somehow exploded at the time they used similar names with different colors
11:13:51 <jmcarthur_work> *they
11:13:52 <mux> that was, like, the final blow
11:14:00 <SamB_XP_> Relaxation of type classes
11:14:00 <SamB_XP_>     Contrary to the the Report (4.3.1), Hugs allows the types of the member functions of a class C a to impose further constraints on a, as in
11:14:00 <SamB_XP_>     class Foo a where
11:14:00 <SamB_XP_>         op :: Num a => a -> a -> a
11:14:00 <SamB_XP_> Relaxation of type classes
11:14:06 <SamB_XP_>     Contrary to the the Report (4.3.1), Hugs allows the types of the member functions of a class C a to impose further constraints on a, as in
11:14:09 <SamB_XP_>     class Foo a where
11:14:11 <SamB_XP_>         op :: Num a => a -> a -> a
11:14:13 <SamB_XP_> whoops
11:14:28 <jmcarthur_work> afaik ghc allows that too
11:14:34 <SamB_XP_> yeah
11:14:34 <ray> that's probably a bug in h98
11:14:45 <SamB_XP_> 'kay
11:14:53 <SamB_XP_> somebody better report it if it's still in there?
11:15:12 <SamB_XP_> we want them to fix it for Haskell' and all ;-)
11:15:32 <SamB_XP_> and I think they might still be doing bugfixes in Haskell98, actually ...
11:15:35 <ray> yeah, so when it comes out in 2030 we'll be good
11:15:44 <SamB_XP_> er, actually, I meant H2010
11:15:54 <jmcarthur_work> haskell standards are meant to become yearly, aren't they?
11:15:55 <ray> oh, that'll be out in 2015
11:16:11 <SamB_XP_> jmcarthur: some of them!
11:16:22 <SamB_XP_> ray: don't be such a pessimist
11:16:23 <lilac> it'll be nice having so many to choose from
11:16:29 <SamB_XP_> it'll be out by xmas 2011
11:16:39 <jmcarthur_work> wait, do you mean to say that these are forks from the efforts of haskell'?
11:16:39 <ray> choose haskell unboxed
11:16:46 <ray> they're not
11:16:57 <SamB_XP_> ooh... I gots one ...
11:17:13 <SamB> Haskell♮
11:17:20 <SamB_XP_> huh
11:17:22 <jmcarthur_work> haha
11:17:27 <lilac> that looks like a splotch
11:17:31 <SamB_XP_> I guess the natural symbol isn't too well supported ...
11:17:39 <SamB_XP_> we'll have to get that fixed first :-(
11:17:58 <ray> i can see it
11:18:03 <jmcarthur_work> looks okay here
11:18:07 <SamB_XP_> I can't see it here
11:18:11 <lilac> ah, with a 48pt font i can tell what that is ;-)
11:18:17 <ray> that's because you have no fonts probably
11:18:22 <idnar> it looks fine here
11:18:24 <jmcarthur_work> xchat, inconsolata 7pt
11:18:29 <SamB_XP_> and I saw *some sort of blur* on the computer I *typed* it on
11:20:06 * SamB installs inconsolata so he can try it
11:23:49 <lispy> works fine in irssi for me
11:24:44 <SamB> darn it, how do I get xchat to reload the font list?
11:25:16 <SamB> lispy: ... you know, the fact that it's irssi has ~nothing to do with whether or not it works
11:25:33 <SamB> that is to say, irssi doesn't render characters ;-)
11:25:34 <Orclev> I think I've just set the record for the ugliest haskell code that violates the most best practices rules
11:25:50 <SamB> Orclev: revive the IOHCC?
11:25:52 <Orclev> but it compiles! :P
11:26:18 <kau> hello!
11:26:49 <sam__> hi kau
11:27:00 <Orclev> heh, it's a proof of concept built on top of the XLib bindings... lots of nastyness going back and forth between C and haskell
11:27:26 <Vanadium> SamB: irssi can do some amount of character set manipulation, no?
11:27:32 <Vanadium> re: /set term_charset or whatever it was
11:27:53 <kau> i'm searching dimension-aware vectors, like a position vector or speed vector, that statically check like in dimensional...
11:27:54 <SamB> well, I mean, irssi doesn't have to touch the glyphs or fonts themselves
11:31:25 <ezyang> What do you do if you find yourself wanting multiple writer monads? WriterT WriterT?
11:32:05 <SamB> ezyang: probably wrap them up somehow
11:32:43 <SamB> and create a class about what the more-used one is actually *for*
11:32:56 <jethr0> is there a way to specify a constructor with full path? i.e. Data.Maybe.Maybe.Just?
11:33:10 <SamB> jethr0: sure!
11:33:13 <benmachine> @unmtl WriterT w Writer a
11:33:13 <lambdabot> err: `Writer (a, w)' is not applied to enough arguments, giving `/\A. (A, a, w)'
11:33:24 <benmachine> @unmtl WriterT w (Writer x) a
11:33:24 <lambdabot> (a, w, x)
11:33:26 <SamB> Data.Maybe.Just should work?
11:33:33 <jethr0> k, i'll try that
11:33:33 <SamB> if not that, then Prelude.Just
11:35:02 <jmcarthur_work> ezyang, use a pair
11:35:18 <SamB> jmcarthur: that sounds like it could get really clumbsy really fast :-(
11:35:21 <jmcarthur_work> oh that is fail
11:35:24 <jmcarthur_work> nevermind
11:35:33 <jmcarthur_work> you can't tell one value without telling another
11:35:48 <SamB> jmcarthur: well, you could tell (mempty, foo)
11:35:50 <SamB> etc.
11:35:54 <jmcarthur_work> ah, yeah
11:35:55 <SamB> but ... painful!
11:36:08 <jmcarthur_work> or even define tellFst and tellSnd
11:36:13 <SamB> hard to refactor
11:36:16 <jmcarthur_work> i would consider that a low lever detail anyway
11:36:17 <Saizan> kau: there was someone implementing them on this channel some weeks ago, maybe i can find the logs
11:36:20 <jmcarthur_work> it should be abstracted
11:36:24 <jmcarthur_work> *low level
11:36:27 <SamB> exactly what I said ;-)
11:36:33 <jmcarthur_work> yeah..
11:37:14 <SamB> when you've just got one Writer or WriterT, abstracting may be overkill, it's the best way forward when you find you want a second ;-)
11:37:22 <SamB> +but
11:37:43 <ezyang> The reason I ask is that I need one WriterT right now to write to stdout
11:37:54 <ezyang> And I definitely have in mind another WriterT for writing to stderr
11:37:56 <SamB> ezyang: that sounds a bit low-level as well?
11:38:02 <SamB> hmm.
11:38:26 <Raevel> goi
11:38:26 <ezyang> The other choice is to dip back into the IO monad
11:38:33 <SamB> if you're just writing to stdout and stderr, might I suggest that you use a Monoid that ships off Eithers?
11:38:36 <ezyang> Or specialize my monads depending on what actions I'm doing
11:38:39 <jethr0> @paste
11:38:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:38:54 <SamB> like, you know, DList (Either String String)
11:39:03 <SamB> ezyang: what things are you sending to stdout and stderr?
11:39:16 <ezyang> stderr is mostly logging messages and warnings
11:39:17 <SamB> and you do want the output to be as-you-compute, right?
11:39:22 <ezyang> yes
11:39:31 <jmcarthur_work> i would consider MonadPrompt
11:39:33 <ezyang> stdout would be "the user asked me to print so and so info to the screen)
11:39:36 <burp> :t undefined
11:39:37 <lambdabot> forall a. a
11:39:38 <ezyang> ok, looking at it
11:39:55 <SamB> I definately think you'll need some sort of list of Eithers as your result data
11:39:55 <ezyang> not in hoogle?
11:39:56 <SamB> then
11:40:04 <jmcarthur_work> ?hackage MonadPrompt
11:40:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadPrompt
11:40:19 <Saizan> kau: it was desp , but the url to the code gives 404 :)
11:40:20 <SamB> since you don't want to first print all the warnings/errors, *then* print the user-requested output
11:40:27 <SamB> or the other way 'round either!
11:40:40 <ezyang> right-o
11:41:58 <jethr0> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9052#a9052
11:42:02 <jmcarthur_work> monadprompt basically lets you define a language with an interpreter such that you can use the language at the bottom of a monad stack and it gets interpreted at the top of the stack
11:42:11 <jethr0> any ideas why this doesn't work namespace-wise?
11:42:23 <jethr0> probably a really dumb mistake on my part,          again
11:42:34 <jmcarthur_work> you named it Gtk
11:42:45 <jmcarthur_work> oh wait
11:42:51 <jmcarthur_work> you didn't import that module
11:42:51 <jethr0> huh? Gtk.Key also didn't work
11:43:05 <jmcarthur_work> import Graphics.UI.Gtk.Gdk.Events
11:43:06 <jethr0> i thought you could specify path without importing...
11:43:12 <jethr0> k, i'll try that
11:43:14 <jmcarthur_work> afaik you have to import
11:44:20 <Saizan> the module name is given by its header
11:44:30 <desp> kau, Saizan: http://varsztat.com/~desp/physics/
11:44:32 <Saizan> the path is just a compiler convention to find it
11:44:47 <ezyang> Hm, is prompt just a typeclass?
11:45:16 <Saizan> desp: ah, nice
11:45:17 <desp> kau: this is experimental code for a re-implementation of my ICFP solution.  Not finished yet.
11:45:23 <jethr0> Saizan: i don't quite see what you mean
11:45:35 <kau> desp, Saizan: thanks
11:45:42 <desp> kau: perhaps it'll be useful to you; there may be more suitable libraries on Hackage.
11:46:04 <kau> i'll check it out
11:46:26 <jmcarthur_work> ezyang, a simple example http://paste.lisp.org/display/53766
11:47:29 <ezyang> Ah, do I need the GADTs extension?
11:47:31 <Saizan> jethr0: when you write a module you specify module Foo.Bar.Baz where at its top, the fact that it happens to be in Foo/Bar/Baz.hs or Foo.Bar.Baz.hs is another issue
11:47:53 <jethr0> ahh
11:48:13 <jmcarthur_work> ezyang, depends. often you will need it though
11:48:54 <ezyang> Ok. Will look at this later.
11:48:58 <ezyang> have to run; cyall
11:50:32 <Orclev> I don't suppose by some miracle Spencer Janssen would happen to be around?
11:51:25 <Saizan> preflex: seen sjanssen
11:51:26 <preflex>  sjanssen was last seen on #haskell 23 hours, 38 minutes and 58 seconds ago, saying: "reverse $ sort list" is slow
11:52:14 <Saizan> you missed him by almost a day :)
11:52:28 <ray> he's still sorting and reversing a list
11:52:28 <Orclev> yeah, seems like my usual luck
11:52:32 <Orclev> lol
11:52:50 <ray> it really is slow, try again next week
11:54:56 <jethr0> *wuhu*, i managed to get a segmentation fault from a ghc binary...
11:55:08 <jethr0> most likely in gtk library though ;(
11:55:46 <doubleth1nk_work> main = unsafeCoerce# "OMGLOL" :: IO ()
11:56:33 <jethr0> wut?
12:11:54 <mux> oh wow, I'm discovering the indexed mode of Data.Map
12:12:28 <jmcarthur_work> indexed mode?
12:12:52 <mux> Int indexes
12:12:57 <jmcarthur_work> Data.IntMap
12:13:11 <jmcarthur_work> optimized!
12:13:19 <mux> no
12:13:32 <mux> this is more for when you want to also refer to the i-th element
12:13:38 <mux> that can be handy
12:13:39 <jmcarthur_work> aha
12:14:09 <jmcarthur_work> sounds like an abstraction leak, but i guess it is no worse than the Ord constraint
12:14:22 <jmcarthur_work> might as well have indexed mode if you require Ord
12:15:02 <mux> yeah, it's exactly the same in the end, you have no more constraints than before
12:15:38 <jmcarthur_work> huh?
12:15:50 <jmcarthur_work> Data.Map could exist without Ord
12:16:00 <jmcarthur_work> it would just be possibly not so efficient
12:16:05 <jmcarthur_work> different internal structure
12:16:14 <jmcarthur_work> still would require at least Eq for querying and stuff
12:16:22 <jmcarthur_work> but the structure itself wouldn't necessarily need it
12:16:26 <mux> I'm saying that when you have an Ord constraint, you add no more constraints by providing Int indexes..
12:16:31 <jmcarthur_work> right
12:16:38 <jmcarthur_work> okay i see what you meant now
12:17:37 <Orclev> alright, I'm trying to use the X11 libs to send an event, and the type for the event I'm trying to send wants the payload in [CInt], but the payload is [Word8]... I can convert it using fromIntegral, but I don't think it's actually going to package it properly doing that...
12:18:21 <Orclev> I'm looking at the source for the X11 bindings currently, but my haskell isn't good enough to figure anything out from that
12:19:26 <Orclev> I think this ( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9053#a9053 ) is the relevent piece of code
12:25:27 <Saizan> Orclev: you're converting a Word8 to a CInt with fromIntegral?
12:25:37 <Saizan> Orclev: it should work fine, a CInt is larger
12:27:06 <aavogt> > maxBound :: CInt
12:27:07 <lambdabot>   Not in scope: type constructor or class `CInt'
12:27:44 <Orclev> Saizan: yes, but the thing I'm concerned about is the other side is expecting the message as [Word8]
12:29:48 <aavogt> @check \x -> x == ((`asTypeOf` (undefined::Word8)) . fromIntegral . (`asTypeOf` (undefined :: Int)) . fromIntegral $ x)
12:29:49 <lambdabot>   "OK, passed 500 tests."
12:30:19 <aavogt> > all (\x -> x == ((`asTypeOf` (undefined::Word8)) . fromIntegral . (`asTypeOf` (undefined :: Int)) . fromIntegral $ x)) [minBound .. maxBound]
12:30:20 <lambdabot>   True
12:31:10 <aavogt> Orclev: ^^ the roundtrip is lossless from Word8 -> Int -> Word8 (but maybe check with CInt)
12:31:53 <Orclev> for the event I'm sending, you specify a format, and a pointer to the data... near as I can tell the Graphics.X11.Xlib.Extras module hard codes the format to 32 and treats the input as [CInt], but the call I'm making expects the format to be 8 and the payload to be [Word8]
12:32:40 <Orclev> but I don't know enough about the hsc stuff to know for sure...
12:33:27 <Saizan> isn't format taken as argument?
12:33:35 <Orclev> no, not from the haskell side
12:33:36 * Saizan doesn't know anything about the X11 protocol
12:34:18 <Orclev> there's some logic in the code that reads in the C structs that reads the format and parses the data appropriately, but I can't find anything similar in the code that writes the structs back out
12:36:41 <Orclev> this is what reads it in: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9054#a9054
12:38:54 <Orclev> ah, I think I may have figured out what I'm doing wrong... has to do with the way I'm converting a ClientMessageEvent into a XEventPtr
12:39:24 <kmc> i have a question about the spineless tagless G-machine paper, if anyone here could help me interpret some things
12:40:10 <Lemmih> kmc: Ask and we'll see.
12:42:57 <kmc> okay, i'm reading the version 2.5 paper from 1992
12:43:38 <kmc> pg. 61, section 9.4.1, saving the environment of a case expression's alternatives until continuation
12:44:50 <kmc> they suggest saving those free variables on the stack, and while i agree it's possible it seems like a huge pain in the ass
12:45:43 <kmc> because somewhere in the scrutinee there might be an application and it will try to reclaim some stack space (section 9.2.2)
12:46:17 <kmc> and basically i am not smart enough to get all of the bookkeeping right
12:46:36 <kmc> so i'm wondering if it's a terrible idea to save those free variables in a heap-allocated closure instead
12:47:13 <kmc> it will probably be slower and stress the gc more, but i'm wondering if it's a terrible idea even in the context of a toy compiler generating not very fast code
12:47:48 <kmc> and also more generally why they don't handle the free variables of a case expression's arms uniformly with the free variables of a lambda form
12:53:12 <Lemmih> Hm, I can't help you there, sorry.
12:55:38 <Orclev> is there anyone that could explain the usage of allocaXEvent? I can't figure out what it wants as the first argument
12:57:24 <jethr0> can anyone else access "http://community.haskell.org/~ndm/derive/"?
12:57:52 <Baughn> Nope, down.
12:58:02 <jethr0> weird
12:58:05 <LordOfTheNoobs> jethr0: negatron
12:58:18 <jethr0> and there i thought it was evil china toying with me again ;)
12:59:27 <dons> Igloo: code.haskell.org is down
12:59:33 <dons> and igloo is at the pub
12:59:52 <Orclev> I'm going to go poke through the source code for xmonad, maybe that can help me figure out how I'm supposed to be doing this
13:00:58 <dons> Orclev: what kind of app are you writing?
13:01:46 <Orclev> dons: well, right now it's just the proof of concept... I'm trying to use the X11 API of skype to send a message to skype... I'm nearly there now, but actually assembling a valid ClientMessageEvent is tripping me up
13:02:14 <dons> ok, cool.
13:02:17 <dons> yes, look at how xmonad does it
13:15:18 <lispy> dons: beer comes first, I can't fault him ;)
13:17:24 <hackagebot> binary-protocol 1.0 - Monad to ease implementing a binary network protocol. (GregoryCrosswhite)
13:28:48 <mle> hm ... @ binary-protocol
13:28:53 <mle> why not use parsec?
13:29:19 <mle> oh nevermind, that's just IO not even parsing.
13:29:42 <mle> parseMarker = try $ (many1 $ byte 0xff) *> byteMatch 0xc0 0xc0
13:29:59 <kmc> :t (*>)
13:30:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:30:15 <kmc> :t (<*>)
13:30:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:30:25 <mle> kmc: Parsec3 has Control.Applicative, like in real world haskell
13:32:32 <burp> :t liftM and
13:32:32 <mle> This is using a bytestring of Word8's instead of chars... which I find is a little awkward because of Pos stuff, but I just ignore line and always update column and it works for errors about byte-offsets into the file
13:32:33 <lambdabot> forall (m :: * -> *). (Monad m) => m [Bool] -> m Bool
13:33:09 <burp> @hoogle [m Bool] -> m Bool
13:33:09 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
13:33:09 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
13:33:09 <lambdabot> Data.IntMap unions :: [IntMap a] -> IntMap a
13:33:30 <kmc> :t liftM all sequence
13:33:31 <lispy> :t sequence
13:33:31 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
13:33:31 <lambdabot>       Expected type: [a1 -> a] -> a1 -> Bool
13:33:31 <lambdabot>       Inferred type: [a1 -> a] -> a1 -> [a]
13:33:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:33:48 <kmc> :t liftM all . sequence
13:33:50 <lambdabot>     Couldn't match expected type `a -> Bool'
13:33:50 <lambdabot>            against inferred type `[a1]'
13:33:50 <lambdabot>       Expected type: m (a -> Bool)
13:34:02 <lispy> :t sequence <$> all
13:34:03 <lambdabot>     Couldn't match expected type `[m a]'
13:34:03 <lambdabot>            against inferred type `[a1] -> Bool'
13:34:03 <lambdabot>     Probable cause: `all' is applied to too few arguments
13:34:24 <lispy> oh
13:34:43 <lispy> :t all <$> (sequence .)
13:34:44 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m [a]'
13:34:44 <lambdabot>     In the first argument of `(.)', namely `sequence'
13:34:44 <lambdabot>     In the second argument of `(<$>)', namely `(sequence .)'
13:34:53 <kmc> :t liftM and . sequence
13:34:55 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
13:35:00 <lispy> :t \x -> all <$> (sequence x)
13:35:01 <lambdabot>     Couldn't match expected type `a -> Bool'
13:35:01 <lambdabot>            against inferred type `[a1]'
13:35:01 <lambdabot>       Expected type: f (a -> Bool)
13:35:07 <kmc> grr, i always make that mistake
13:35:09 <burp> thanks kmc ;)
13:35:09 <lispy> heh, I still didn't get right
13:35:25 <kmc> all takes a predicate
13:35:31 <kmc> unlike in python
13:35:33 <kmc> @src and
13:35:33 <lambdabot> and   =  foldr (&&) True
13:35:42 <kmc> which confuses me every time
13:36:08 <lispy> :t and <$> (sequence .)
13:36:09 <lambdabot>     Couldn't match expected type `[Bool]'
13:36:10 <lambdabot>            against inferred type `a1 -> m [a]'
13:36:10 <lambdabot>     Probable cause: `.' is applied to too few arguments
13:36:31 <lispy> So much for golfing
13:36:33 <lispy> (for me)
13:36:47 <lispy> If I keep going I'll just spam you guys to no end
13:36:51 <kmc> @djinn (Monad m) => [m Bool] -> m Bool
13:36:51 <lambdabot> Error: Undefined type []
13:37:13 <burp> good guess ;)
13:37:29 <lispy> I chicked with @pl and lambdabot says I meant: (and <$>) . seqquence
13:37:52 <burp> > liftM and $ sequence [return True, return False]
13:37:53 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Bool.Bool))
13:37:53 <lambdabot>    arising from a use of ...
13:37:56 <mauke> you were almost right
13:37:58 <lispy> ?djinn (Monad m) => List (m Bool) -> m Bool
13:37:59 <lambdabot> Error: Undefined type List
13:38:09 <kmc> @djinn-add data List a = Cons a (List a) | Nil
13:38:09 <lambdabot> Error: Recursive types are not allowed: List
13:38:14 <kmc> foo
13:38:27 <kmc> some theorem prover you are, djinn
13:39:11 <lispy> kmc: you get what you pay for
13:39:22 * lispy notes the symbal crash
13:39:23 <kmc> @djinn (Monad m) => m (m a) -> m a
13:39:24 <lambdabot> Error: Class not found: Monad
13:39:37 <lispy> ?djinn m (m a) -> m a
13:39:37 <lambdabot> -- f cannot be realized.
13:39:57 <kmc> @djinn-add class Monad m where { return :: a -> m a; join :: m (m a) -> m a }
13:39:57 <lambdabot> Cannot parse command
13:40:03 <lispy> ?djinn Maybe (Maybe a) -> Maybe a
13:40:03 <lambdabot> f a =
13:40:04 <lambdabot>     case a of
13:40:04 <lambdabot>     Nothing -> Nothing
13:40:04 <lambdabot>     Just b -> b
13:40:25 <kmc> @djinn Maybe (a -> Not a)
13:40:25 <lambdabot> f = Nothing
13:40:37 <kmc> @djinn a -> Maybe (Not a)
13:40:37 <lambdabot> f _ = Nothing
13:40:51 <kmc> Maybe is the most useless type logically :)
13:41:09 <lispy> yeah, well it is in debates too
13:41:42 <lispy> ?djinn Either (Maybe a) (Maybe b) -> b
13:41:43 <lambdabot> -- f cannot be realized.
13:42:23 <mauke> http://cgi.4chan.org/r/src/1252096802009.jpg
13:42:34 <kmc> @djinn (Maybe a) -> (Maybe b) -> (Not a -> Not b -> Void) -> Either a b
13:42:34 <lambdabot> -- f cannot be realized.
13:42:41 <kmc> that's not constructive, right?
13:51:11 <FunctorSalad> path[l]: that TEAMSEL problem does seem hard... if a1...an are the players, it boils down to choosing n/2 players such that the sum of the chosen players is as close to half the sum as possible, but n-choose-n/2 does grow exponentially IIRC
13:52:01 <FunctorSalad> I might be missing some property that makes it easy though
13:52:54 <travisbrady> I just got a new mac, anyone have thoughts on where to dl/install ghc from? macports? haskell.org binaries?
13:55:11 <trzkril> travisbrady: i went with the haskell.org binaries, worked fine and i never used macports anyway
13:57:38 <travisbrady> trzkril: thank you, i suppose I'll use those
13:59:15 <dschoepe> Is it considered bad style to use both monadic and applicative style for writing parsers in one module?
14:01:10 <dcoutts> dschoepe: nope, that's fine
14:01:22 <dschoepe> dcoutts: Thanks.
14:01:33 <pantsd_pcf> Did anyone else do Google Code Jam in Haskell? I'm wondering what other people's solutions looked like
14:03:59 <Phyx-> hmm.. haven't seen much monadic style usage in parsers though
14:05:26 <atreus_> I think that Parsec is mostly monadic, though?
14:05:35 <Vanadium> It is also applicative
14:05:43 <Vanadium> Pft, Parsec is deprecated, use Parsimony instead
14:06:08 <path[l]> FunctorSalad: ah, by hard do you mean like np hard?
14:06:28 <roconnor> isn't everything monadic also applicative?
14:06:30 <Phyx-> @cabal info parsimony
14:06:30 <lambdabot>   bzzt.
14:06:37 <FunctorSalad> path[l]: don't know, but I-don't-see-an-polynomial-algorithm-hard ;)
14:06:42 <Phyx-> @package info parsimony
14:06:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/info parsimony
14:06:46 <FunctorSalad> *a
14:06:55 <c_wraith> roconnor: mathematically, yes.  in terms of code, no
14:06:57 <Vanadium> roconnor: Mathematically, but not techefb
14:07:14 <path[l]> FunctorSalad:  Im fairly sure that you DO have to consider all possible subsets of size n/2. So yeah that becomes nc(n/2) combinations so .... umm that grows like greater than polynomial I guess
14:07:20 <roconnor> stupid techefb
14:07:21 <atreus_> Thanks, I hadn't actually heard of Parsimony before
14:07:34 <Vanadium> I meant to type out 'technically'
14:07:43 <roconnor> stupid technically
14:07:53 <path[l]> FunctorSalad: btw having seen that, do you feel using a diffarray instead of an IntMap will make a big difference?
14:08:28 <FunctorSalad> path[l]: don't know about the performance characteristics of those sorry
14:08:38 <hackagebot> HStringTemplate 0.6.2 - StringTemplate implementation in Haskell. (SterlingClover)
14:08:52 <FunctorSalad> path[l]: I'll tell you if I find a good solution ;)
14:09:00 <path[l]> oh ok, well but the basic idea is clear I guess. Instead of using a proper immutable structure, cheat and find a mutable one =p
14:09:05 <path[l]> hehe ok
14:09:07 <kmc> c_wraith, do you mean the instance "(Monad m) => Applicative m" doesn't exist? or that code in monadic style might use operators that don't exist for applicative?
14:10:09 <heatsink> My code's heap usage keeps rising with time.  Heap retainer profiling indicates that the biggest culprit is the value-supply library, which a lot of my code uses to produce unique IDs.
14:10:46 <c_wraith> kmc, the former
14:11:05 <dschoepe> Vanadium: what advantages does parsimony have over parsec?
14:11:16 <jacobian> ok, I'd like to get a kind of funny overload, maybe someone can help me with it.  I need a class, or a number of classes that allow the following.
14:11:22 <heatsink> Can I do something about that, other than writing my own value supply code so I can control strictness?
14:11:24 <jacobian> I want to pun a function `meet`
14:11:31 <jacobian> such that it has the signatures:
14:11:51 <jacobian> S -> R -> R, R -> S -> R, S -> S -> S, R -> R -> R
14:12:15 <Vanadium> It is by the guy who is responsible for monadlib <:]
14:13:08 <kmc> c_wraith, what is the obstacle to writing that instance
14:13:12 <aavogt> jacobian: you need to write a multiparameter typeclass: class HasMeet x y z where meet :: x -> y -> z
14:14:00 <kmc> jacobian, you might want the fundep x y -> z also
14:14:08 <jacobian> ok
14:14:15 <aavogt> but using that function will likely require that you specify many type signatures
14:14:16 <kmc> it holds and will help type inference of application of meet
14:14:29 <kmc> or, use associated types instead :)
14:15:11 <aavogt> kmc: fundeps let you specify that two parmeters uniquely identify a third one?
14:15:27 <kmc> i believe so
14:16:07 <heatsink> aavogt: yes
14:16:45 <aavogt> nice, I've only seen them used like    | a -> b, c -> d
14:16:47 <tommd> dcoutts: "cabal: Distribution/Client/Dependency/TopDown.hs:170:37-73: Non-exhaustive patterns in lambda"  I trust you're aware of this issue when 'cabal install base' is run.
14:17:26 <dschoepe> Vanadium: parsec-3.0.0 also seems to support ByteStrings, so is the support for UTF8 the main(only?) advantage?
14:18:05 <Vanadium> dschoepe: In all honesty I only brought up parsimony because I was wondering myself
14:18:18 <dcoutts> tommd: vaguely, I'm not sure it's actually got a ticket
14:18:35 <dschoepe> Vanadium: ah, okay. so hopefully someone else here will shed some light on this.
14:18:46 <tommd> dcoutts: Ive suddenly got to run, but I'll give it a ticket later.
14:18:51 <dcoutts> tommd: but we're not going to do much more than improve the error message. I don't think we expect to handle the crazy self-deps of base.
14:19:02 <dcoutts> at least not at the moment
14:19:02 <tommd> right
14:20:08 <dcoutts> dschoepe: parsec 2 does String which is already Unicode
14:21:29 <aavogt> dcoutts: I get an irrefutable pattern match failure when I try to use Distribution.Simple.GHC.getInstalledPackages
14:21:48 <aavogt> getInstalledPackages verbose GlobalPackageDB emptyProgramConfiguration -- what I tried
14:21:49 <dschoepe> dcoutts: Ah, okay, thanks. I only asked because utf8-support was mentioned on the parsimony hackage page as an advantage on the parsimony hackage page.
14:22:30 <dons> yav: ^^^
14:23:00 <yav> dons: what am i looking at?
14:23:13 <kmc> jacobian, the verison with associated type synonyms would look something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9055#a9055
14:23:33 <aavogt> The error is "Exception: Distribution/Simple/GHC.hs:390:4-47: Irrefutable pattern failed for pattern Data.Maybe.Just ghcProg", I certainly do have ghc-pkg in my $PATH
14:23:58 <kmc> it's a newer extension but also more explicit than fundeps
14:24:29 <Saizan> aavogt: the error might be nicer, but the problem is that you can't pass it an emptyProgramConfiguration
14:24:32 <yav> dschoepe: the nice thing about parsimony is that you can do the UTF-8 stuff directly on bytestring, without a String in the middle
14:25:13 <dschoepe> yav: ah, thanks
14:25:23 <Saizan> aavogt: but something like (addKnownPrograms [ghcProgram,ghcPkgProgram] emptyProgramConfiguration) instead
14:25:37 <jacobian> thanks all
14:26:35 <aavogt> Saizan: that gives the same error
14:27:12 <Saizan> weird
14:27:28 <Saizan> oh, sorry
14:27:36 <Saizan> pc <- configureAllKnownPrograms minBound (addKnownPrograms [Cabal.ghcProgram,Cabal.ghcPkgProgram] emptyProgramConfiguration) ix <- getInstalledPackages minBound [GlobalPackageDB, UserPackageDB] pc
14:27:59 <Saizan> ..it got mangled, but you've to configure them first.
14:28:32 <Saizan> which looks like a bug in getInstalledPackages, mmh
14:29:10 <dcoutts> aavogt: right, emptyProgramConfiguration will cause that, though it shouldn't cause an irrefutable pattern match, it should be a more graceful failure.
14:29:25 <jacobian> is the associated type way better or the fundep way?  I'm sure there are subtle differences that I'll only appreciate later :)
14:29:32 <dcoutts> aavogt: try defaultProgramConfiguration
14:29:54 <aavogt> Saizan: it works when I use configureAllKnownPrograms
14:30:07 <dcoutts> oh yes, that too
14:30:24 <dcoutts> not the worlds nicest API I guess
14:31:02 <dcoutts> the design issue is if it should configure on demand, or try and do all configuration up front
14:31:17 <aavogt> dcoutts: defaultProgramConfiguration seems to be the same as emptyProgramConfiguration
14:31:38 <Saizan> if getInstalledPackages used requireProgram rather than lookupProgram then it'd work
14:31:44 <dcoutts> dschoepe: that might be an advantage over parsing bytestring directly, which is not Unicode
14:31:51 <dcoutts> Saizan: right
14:32:14 <dcoutts> Saizan: really it wants to be a monad with the ProgramConfiguration as a state
14:34:37 <dcoutts> Saizan: btw, it's a pity you couldn't make it to the Haskell Symposium, there's lots of stuff you'd be interested in + many informal discussions
14:34:47 <dcoutts> there should be videos of the talks soonish
14:35:14 <Saizan> dcoutts: yeah, or in a dep. framework you can keep every ConfiguredProgram as its own target and avoid the explicit database
14:35:16 <dcoutts> and CUFP today, and the Haskell Implementer's Workshop tomorrow
14:35:25 <dcoutts> Saizan: right
14:35:53 <dcoutts> Saizan: that would certainly be better
14:48:59 <pantsd_pcf> I've been reading http://www.haskell.org/haskellwiki/Memoization , the memoFix example uses a function called "memoize" but I can't seem to find this
14:55:55 <monochrom> It only says you can write it yourself using ideas in that article and the cited articles.
14:56:29 <pantsd_pcf> ah
14:56:51 <pantsd_pcf> The way I read 2.1 was as actual code :p
14:59:11 <Saizan> pantsd_pcf: see memocombinators or MemoTrie on hackage for implementations
15:07:56 <SamB_XP> re: that H98 weirdness:
15:09:17 <SamB_XP> The type of the top-level class method v_i is:v_i :: forall u,w. (C u, cx_i) =>t_i
15:09:17 <SamB_XP> The t_i must mention u; it may mention type variables w other than u, in which case the type of v_i is polymorphic in both u and w. The cx_i may constrain only w; in particular, the cx_i may not constrain u
15:09:45 <SamB_XP> from 4.3.1 in http://www.haskell.org/onlinereport/decls.html, just like http://cvs.haskell.org/Hugs/pages/users_guide/haskell98.html#BUGS-HASKELL98 said ...
15:12:03 <pantsd_pcf> Saizan: thanks :)
15:16:10 <danzat> If I have a function definition when in one of the statements I do "add x y = add y x" and then add more definitions of "add" after it, will they be evaluated? (I hope the question was clear enough)
15:16:25 <Vanadium> no.
15:16:52 <jacobian> is there a switch to ghci to get it to do a lot of experimental stuff like multiparameter type classes etc. without having to type in all the switches?
15:16:59 <aavogt> > let add x y = add y x in add 1 2
15:17:04 <lambdabot>   mueval-core: Prelude.read: no parse
15:17:05 <lambdabot>  mueval: ExitFailure 1
15:17:16 <aavogt> > let add x y = add y x; add z w = z+w in add 1 2
15:17:21 <lambdabot>   mueval-core: Prelude.read: no parse
15:17:21 <lambdabot>  mueval: ExitFailure 1
15:18:45 <aavogt> jacobian: there is -fglasgow-exts (not recomended), but you can also use {-# LANGUAGE MultiParamTypeClasses, xyzextension #-} at the top of your source files
15:19:14 <danzat> aavogt, so, for all the rules preceding the commutativity rule, I need to be explicit. Is there any way around it?
15:20:31 <kmc> danzat, rules are  checked in order.  you can put the commutivity rule at the bottom
15:20:59 <kmc> but then it will infinite-loop if neither x y nor y x matches
15:21:39 <g-jaman> hoi iedereen
15:21:42 <g-jaman> alles ok??
15:22:04 <kmc> i might write one function of type a -> a -> Maybe b, and a wrapper that tries both orders before throwing an error
15:22:10 <aavogt> @seen lambdabot
15:22:10 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
15:22:10 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-iphone, #haskell-in-depth, #haskell-freebsd, #
15:22:10 <lambdabot> interplanetarylazers, #learnanycomputerlanguage, #uscs2009, #macosx, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #bfpg, #
15:22:10 <lambdabot> novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
15:22:19 <g-jaman> bij wie kan ik terecht voor vragen??
15:22:27 <benmachine> @seen lunabot
15:22:27 <lambdabot> Last time I saw lunabot was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #bfpg, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc,
15:22:27 <lambdabot> #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-iphone, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #
15:22:27 <lambdabot> haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #interplanetarylazers, #jhc, #jtiger, #kata, #learnanycomputerlanguage, #macosx, #macosxdev, #
15:22:27 <lambdabot> novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #uscs2009, #xmonad and #yi 9d 13h 26m 52s ago, and .
15:22:35 <benmachine> o_O
15:22:38 <kmc> is there a way to catch pattern-match failure for a function of monadic return type (as opposed to a bind within a do)
15:23:48 <Saizan> as any other pattern match failure exception you can catch it in the IO monad with Control.Exception.catch
15:24:06 <Saizan> but you've to make sure to force enough of the value under the scope of the catch
15:24:24 <danzat> kmc, take a look at this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3511#a3511 if I put the commutativity rule at the end, it won't actually work, because there's a more general rule preceding it
15:25:47 <aavogt> danzat: you have to express the commutativity in a different way
15:26:41 <aavogt> danzat: are Negative, Sum, Const all constructors for the same data type?
15:26:50 <danzat> aarong, yes
15:27:14 <aavogt> you could write add with the type:    add :: Expression -> Expression -> [Expression]
15:27:34 <aavogt> where the result has two options (one for each order)
15:27:41 <danzat> data Symbolic = Var String | Const Float | Negative Symbolic | Sum [Symbolic] | Product [Symbolic] | Inverse Symbolic
15:29:06 <kmc> danzat, then i'd do the two-function approach i described
15:29:13 <aavogt> @type commutes f x y = [f x y,f y x]
15:29:15 <lambdabot> parse error on input `='
15:29:17 <dons> bos: did you know haskell-hexpat haskell-hexpat-pickle haskell-hstringtemplate haskell-idna haskell-monoids haskell-numerals haskell-string-combinators haskell-stringprep all use Data.Text
15:29:34 <aavogt> @type let commutes f x y = [f x y,f y x] in commutes
15:29:35 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t -> [t1]
15:30:33 <danzat> kmc, I'm sorry, I don't quite understand
15:30:46 <jacobian> hmmm, is there anything I can do if the system is underdetermined to help it pick the best instantiation of types other than putting them in by hand?
15:30:56 <sioraioc_> dons: that's neat
15:31:00 <kmc> you make the function you have now, but without the commutivity rule, and have it return Maybe Symbolic
15:31:15 <kmc> either Just v if it matches, or Nothing otherwise
15:31:33 <Saizan> jacobian: it depends on your meaning of best
15:31:48 <danzat> kmc, like _add::Symbolic->Symbolic->Maybe Symbolic, and then use _add to define add?
15:31:54 <Beelsebob> is the correct way to build ghc on OS 10.6 to stick -opta -m32 -optl -m32 in the ghc script's args?
15:31:55 <Saizan> kmc: but the function as it is now already has a case that matches any input
15:31:56 <kmc> yes
15:32:05 <kmc> right, i'd move that final case out to the wrapper
15:32:19 <danzat> kmc, hmm, great, thanks for the help
15:32:23 <kmc> the semantics here is "match a specific case for x,y, else try commuting, else go with the default"
15:32:24 <Saizan> kmc: no, i'm talking about the add x y = Sum [x,y]
15:32:35 <Saizan> oh, i see now
15:32:37 <kmc> Saizan, yes, i mean that _add should not have that case
15:33:03 <Saizan> sorry :)
15:33:19 <kmc> 'sall good
15:33:39 <danzat> in _add, I have to add a fail rule in the end, right?
15:34:10 <kmc> yeah, _add _ _ = Nothing
15:48:04 <danzat> kmc, Can you look at this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3512#a3512 I get an error compiling it
15:48:27 <Phyx-> what's the error?
15:49:05 <danzat> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3513#a3513
15:49:43 <Phyx-> @type isNothing
15:49:44 <lambdabot> forall a. Maybe a -> Bool
15:49:47 <Phyx-> right
15:49:58 <Phyx-> danzat: put parentesize around the (_add x y)
15:50:06 <danzat> oh
15:50:08 <danzat> silly me :)
15:52:55 <Saizan> that won't work as expected though
15:53:09 <desp> Beelsebob: yes.
15:53:14 <danzat> yes
15:53:16 <danzat> I see
15:53:17 <desp> Beelsebob: also, ghci
15:53:30 <desp> Beelsebob: also, don't build it, just install the binary, and modify the scripts.
15:54:05 <danzat> I need to check for both _add x y and _add y x, and then if both return Nothing, I need to return Sum [x, y]
15:54:20 <Beelsebob> desp: oh? I thought the latest snapshot had the bug fixed anyway?
15:54:31 <desp> Probably, but the binary works fine.
15:54:38 * Beelsebob nods
15:54:48 <Beelsebob> 6.11 has features I want anyway
15:54:51 <desp> Ah.
15:54:52 <Beelsebob> like dynamic linking support
15:55:35 <Saizan> danzat: or more cleanly: "add x y = fromMaybe (Sum [x,y]) (_add x y `mplus` _add y x)"
15:55:55 <kmc> :t fromMaybe
15:55:56 <lambdabot> forall a. a -> Maybe a -> a
15:56:00 <Phyx-> lol
15:56:10 <Phyx-> i was just about to suggest something similair
15:56:12 <Phyx->  fromMaybe (fromJust $ _add x y) (_add y x)
15:56:30 <danzat> Saizan, what does the mplus operator do?
15:56:39 <Saizan> ?src Maybe mplus
15:56:39 <lambdabot> Nothing `mplus` ys = ys
15:56:39 <lambdabot> xs      `mplus` ys = xs
15:56:42 <monochrom> fromJust is very unsuitable for this purpose.
15:56:56 <kmc> fromJust is generally bad
15:57:39 <kmc> danzat, the short answer is the code Saizan/lambda bot just showed
15:58:01 <danzat> kmc, I'm still digesting it
15:58:40 <Phyx-> danzat: basically, it says if the first argument is Nothing, return the second argument, else if the first argument isn't nothing return it
15:58:41 <danzat> ok, i got it
15:58:42 <kmc> the long answer is that mplus generalizes beyond Maybe... look up the MonadPlus typeclass if you're interested
15:59:22 <danzat> kmc, I am interested, where can I look it up?
15:59:43 <kmc> http://en.wikibooks.org/wiki/Haskell/MonadPlus
16:00:30 <guenni> > 4 + 5
16:00:31 <lambdabot>   9
16:00:33 <Phyx-> really... does every typeclass in haskell have a law...
16:00:50 <monochrom> Yes.
16:00:57 <kmc> what are the laws for Show?
16:01:06 <burp> guenni: are you sure?
16:01:07 <burp> > 4 + 5
16:01:08 <Phyx-> monad laws i can understand, but why would MonadPlus have a law...
16:01:08 <lambdabot>   Ambiguous occurrence `+'
16:01:08 <lambdabot>  It could refer to either `GHC.Num.+', imported fr...
16:01:11 <burp> damn
16:01:18 <kmc> Phyx-, you want it to be a monoid
16:01:22 <burp> @unlet 4 + 5
16:01:23 <lambdabot>   Parse error
16:01:29 <monochrom> Don't you want mplus to have an associative law?
16:01:29 <burp> @undefine 4 + 5
16:01:46 <burp> thought I could trick it via private message definition :P
16:01:58 <guenni> burp:  actualy I had wanted to private chat with lambdabot to look up a signature
16:02:19 <guenni> burp: sry for the spam :)
16:02:34 <mmorrow> class A a where asdf :: a -> String -- INVARIANT: the String returned must be an english adjective, and evoke feeling of glee
16:02:36 <Saizan> Phyx-: if they don't have laws how can you write code that's polymorphic in that type class? you wouldn't be able to give a semantic to your code
16:02:41 * glguy casts summon
16:02:45 <burp> guenni: no spam ;)
16:03:35 <Phyx-> Saizan: but if the laws aren't set in stone, (like the wiki suggests about some MonadPlus laws) then the problem still exists though
16:03:53 <mmorrow> instance A Int where asdf _ = "spicy" -- WRONG! "spicy" does not evoke glee.
16:03:57 <Orclev> I'm beginning to think I'm not going to be able to really understand haskell without taking a few more years of comp sci and/or some high level maths
16:04:16 <kmc> also danzat i found this document especially helpful when learning monads: http://www.haskell.org/all_about_monads/html/index.html
16:04:36 <monochrom> Stones are for the 19th century. Here and now laws are enforced by community.
16:04:41 <kmc> Orclev, what part don't you understand?
16:04:57 <Phyx-> monochrom: or in this case, ghc devs :P
16:05:15 <kmc> i'm not sure taking courses is a good way to learn haskell
16:05:34 <guenni> burp: how can I lookup a function when I only have the signature?
16:05:40 <Phyx-> guenni: hoogle
16:05:41 <burp> guenni: @hoogle
16:05:45 <monochrom> If you upload a strange monad instance to hackage, if someone else finds it, you can be sure there will be a long thread on haskell-cafe condemning it.
16:05:47 <Orclev> kmc: that's part of the problem... specific instances of things I can generally work out... but invariably I'll try to do something and I'll go to find the documentation only to discover half of it is dedicated to the theoretical underpinnings of some function or other based on x obscure branch of math
16:05:49 <guenni> thx
16:05:50 <Phyx-> @google hoogle
16:05:51 <lambdabot> http://www.haskell.org/hoogle/
16:05:51 <lambdabot> Title: Hoogle
16:05:55 <burp> @hoogle Int -> Int
16:05:55 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
16:05:55 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
16:05:55 <lambdabot> Test.QuickCheck configSize :: Config -> Int -> Int
16:06:00 <glguy> monochrom: strange? unlawful?
16:06:21 <Phyx-> monochrom: even if you document and give a valid reason for it?
16:06:35 <kmc> Orclev, to be honest i haven't found the category theory that helpful yet
16:06:49 <kmc> and i've been programming in haskell for 4 years or so
16:07:35 <monochrom> valid reason is highly unlikely. even if you manage to do it, there will still be a long thread arguing over it. people will urge you to make your own typeclass rather than re-use monad.
16:07:49 * Twey has been for about two, and knows bugger all about category theory
16:08:21 <kmc> Orclev, logic is more important perhaps.  i appreciate knowing about the curry-howard isomorphism, though i'm not sure that has much practical bearing on my code either
16:08:35 <Phyx-> monochrom: i suppose...
16:08:39 <Saizan> category theory is in no way required, but you can find some results from it to apply to your haskell code
16:08:45 <ray> orclev: the more school you take, the more your brain will be ruined and the less able to learn *things* you will be
16:09:10 <Orclev> see, I've never heard of curry-howard isomorphism for instance
16:09:15 <Phyx-> ray: how so?
16:09:37 <Phyx-> @package bit
16:09:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bit
16:09:40 <kmc> Orclev, it says that types are logical statements, and programs are proofs of those statements
16:09:47 <kmc> fun stuff
16:09:52 <Phyx-> hmm, does that just append a url to whatever you give it
16:10:04 <Twey> Probably
16:10:07 <kmc> @package solve-the-halting-problem
16:10:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/solve-the-halting-problem
16:10:13 <Twey> Yep.
16:10:27 * Phyx- would have expected it to search hackage
16:10:35 <ray> it doesn't even use the good url
16:10:51 <Twey> @package Solve the &#!{%*ing halting + problem
16:10:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Solve the &#!{%*ing halting + problem
16:10:57 <Twey> Doesn't even do escaping
16:10:58 <Phyx-> heresy!
16:11:00 <monochrom> haha
16:11:06 <ray> saizan: category theory is easy to learn if you can understand it via examples from haskell, actually
16:11:15 <ray> so i'd learn haskell first
16:11:24 <Cale> Is it really?
16:11:49 <ray> i suck at algebraic topology
16:12:00 <Saizan> ray: i didn't advocate any particular order of learning in my statement :)
16:12:13 <Cale> Algebraic topology is where I learned most of my basic category theory first.
16:12:21 <monochrom> From concrete to abstract. From example to general. Category theory is easiest after you have seen a million seemingly unrelated examples. This is why math majors have an advantage, they have seen that much.
16:12:46 <ray> bums have a disadvantage :(
16:12:57 <kmc> bums and math majors have some similarities
16:13:07 <Cale> ehehe
16:13:25 <Orclev> too much abstraction gives me a headache
16:13:27 <ray> as a bum, it's difficult to learn algebraic topology
16:13:45 <Cale> Though, there is an approach to learning category theory which needs very few examples and which is quite workable.
16:13:57 <Cale> You can actually get most of the examples from categories themselves.
16:14:08 <Saizan> Orclev: your brain will hurt more from the functional paradigm and lazy evaluation than the abstractions :)
16:14:14 <Cale> It's a little harder to motivate that way, but doable.
16:14:22 <Saizan> Orclev: but brain explosions are good :)
16:14:26 <Orclev> Saizan: oh no, lazy eval is easy to understand
16:14:40 <Cale> I thought so too.
16:14:50 <burp> easy to understand but it's hard to use its power
16:14:51 <ray> non-strict evaluation is easy to understand anyway
16:14:55 <Cale> Lazy evaluation seemed much more natural to me than the other way.
16:15:36 <ray> strict evaluation seems more natural for *computers* to me, but i'm sure those are just the von neumann blinders
16:15:39 <Saizan> Orclev: do you understand how "let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs" works yet?
16:15:43 <Cale> Anyway, to category theory, if you take the approach to categories that group theory takes to groups, there's not much needed in terms of prerequisites.
16:15:58 <SamB> I find lazy evaluation a bit tricky to debug ...
16:16:10 <SamB> well, sometimes
16:16:29 <SamB> a Writer/WriterT can help a lot ;-)
16:16:29 <Cale> It's just that many mathematicians have this view of category theory as metamathematics, which clouds the issue.
16:16:46 <SamB> I don't see how it clouds the issue
16:16:59 <Cale> and indeed a lot of category theory was constructed for metamathematical reasons in the first place
16:17:11 <SamB> but I also don't see why they don't think something having "meta" prepended makes it better ;-)
16:17:13 <ray> i don't see cat theory as metamathematics
16:17:49 <Orclev> Saizan: yeah, it's jus combining adjacent values in the list
16:17:59 <monochrom> Yes that's hard to motivate. Many programmers want very real-world motivations. They don't even accept "just curious" "just because you can" motivations. Strangely enough, they motivate copying of software by "just because you can".
16:18:28 <Twey> Isn't metamathematics just… more mathematics?
16:18:32 <SamB> monochrom: well, I assume they usually also motivate it by "because the software is actually interesting"
16:18:41 <SamB> Twey: one hopes!
16:18:42 <Twey> You don't hear anyone calling indices ‘metamultiplication’.
16:18:49 <SamB> wha?
16:18:56 <benmachine> I think I might start now
16:19:00 <Saizan> Orclev: ah, nice, it took me a while to grok it properly :)
16:19:07 <Twey> Or, for that matter, multiplication ‘meta-adding’
16:19:16 <ray> lol
16:19:42 <Twey> Hmm, that would make tetration meta-meta-meta-meta-counting
16:19:48 <Twey> Cool
16:19:50 <ray> of course not, multiplication's just another way to make a monoid on the integers
16:19:59 <Twey> Haha
16:20:05 <Orclev> ray: and my brain explodes
16:20:14 <Twey> :þ
16:20:15 <Vanadium> You are just making shit up now
16:20:20 <mmorrow> i thought tetration was something you did with a filter and a beaker in high-school chemistry lab
16:20:31 <SamB> mmorrow: titration, I think
16:20:37 <mmorrow> ah, right
16:20:38 <SamB> @dict-all titration
16:20:39 <lambdabot> Unknown command, try @list
16:20:40 <mmorrow> :)
16:20:43 <SamB> @all-dict titration
16:20:46 <lambdabot> *** "Titration" gcide "The Collaborative International Dictionary of English v.0.48"
16:20:46 <lambdabot> Titration \Ti*tra"tion\, n. (Chem.)
16:20:46 <lambdabot>    The act or process of titrating; a substance obtained by
16:20:46 <lambdabot>    titrating.
16:20:46 <lambdabot>    [1913 Webster]
16:20:48 <lambdabot> [8 @more lines]
16:20:52 <mmorrow> helpful
16:20:52 <Twey> I don't think so.
16:20:56 <SamB> @all-dict titrating
16:20:56 <Twey> @all-dict tetration
16:20:57 <lambdabot> *** "Titrating" gcide "The Collaborative International Dictionary of English v.0.48"
16:20:57 <lambdabot> Titrate \Ti"trate\, v. t. [imp. & p. p. {Titrated}; p. pr. & vb.
16:20:57 <lambdabot>    n. {Titrating}.] [F. titrer, from titre standard, title. See
16:20:57 <lambdabot>    {Title}, n.] (Chem.)
16:20:58 <lambdabot>    To analyse, or determine the strength of, by means of
16:21:00 <lambdabot> [3 @more lines]
16:21:02 <lambdabot> No match for "tetration".
16:21:06 <Twey> ☹
16:21:08 <Twey> @all-dict tetrate
16:21:09 <lambdabot> No match for "tetrate".
16:21:12 <Twey> Truly?  Huh.
16:21:23 <Twey> http://en.wikipedia.org/wiki/Tetration
16:21:25 <Twey> WP likes me.
16:21:29 <c_wraith> @all-dict tetris
16:21:29 <lambdabot> No match for "tetris".
16:21:33 <SamB> !!!
16:21:42 <SamB> you'd think that'd be in FOLDOC at least!
16:21:58 <Twey> Yeah.
16:22:29 <SamB> with something like "You must be kidding -- you already know what Tetris is!"
16:22:43 <Orclev> FOLDOC?
16:23:29 <SamB> @vera foldoc
16:23:29 <lambdabot> *** "foldoc" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:23:30 <lambdabot> FOLDOC
16:23:30 <lambdabot>      Free OnLine Dictionary Of Computing (WWW, UK)
16:23:30 <lambdabot>  
16:23:47 <Orclev> ah
16:24:05 <SamB> @vera dd
16:24:06 <lambdabot> *** "dd" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:24:06 <lambdabot> DD
16:24:06 <lambdabot>      Dansk Dataforening (org., Denmark)
16:24:06 <lambdabot>  
16:24:06 <lambdabot> *** "dd" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:24:08 <lambdabot> [11 @more lines]
16:24:11 <SamB> @more
16:24:12 <lambdabot> DD
16:24:12 <lambdabot>      Data Dictionary (SA, CASE, DB)
16:24:14 <lambdabot>  
16:24:16 <SamB> @more
16:24:16 <lambdabot> *** "dd" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:24:16 <dafra> hi, i am trying to use haskell-src, failing to match toplevel functions definitions
16:24:18 <lambdabot> DD
16:24:20 <lambdabot> [6 @more lines]
16:24:22 <lambdabot>      Depacketization Delay
16:24:24 <lambdabot>  
16:24:26 <lambdabot> *** "dd" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
16:24:28 <lambdabot> DD
16:24:30 <lambdabot>      Double Density [disks] (FDD)
16:24:32 <lambdabot> Plugin `more' failed with: thread killed
16:24:34 <SamB> dafra: not haskell-src-exts?
16:24:54 <dafra> SamB: yes, *-exts
16:25:18 <dafra> func x = x is fine, but func = id is not
16:25:26 <SamB> okay, could you give a more detailed description of what you're doing and how it fails ?
16:25:39 <c_wraith> dafra, that really sounds like the monomorphism restriction
16:25:45 <dafra> i match only patterns, not curried functions
16:26:30 <SamB> dafra: have you tried displaying the unmatched data in a last-ditch case ?
16:27:16 <dafra> how to display something that i dont match ?
16:27:18 <mmorrow> this is the beauty of Show
16:27:32 <Vanadium> fuck monads ._.
16:27:38 <dafra> this doesn(t work either : main = parseMainProgram
16:27:42 <mmorrow> also, the fast that Show is valid haskell syntax means you can parse it and prettyprint it
16:28:20 <ezyang> Vanadium: ?
16:28:34 <Vanadium> So do I use monadlib or mtl?
16:28:47 <Vanadium> I am not sure I can tell the difference, but reading monadlib made me feel stupid, so it is probably the right choice.
16:28:49 <ezyang> Who is your audience?
16:29:04 <mmorrow> dafra: have you looked at the AST datatypes?
16:29:08 <Vanadium> Myself, mostly
16:29:18 <dafra> I hadnt noticed the Show instance :)
16:29:24 <mmorrow> dafra: there is a distinction between a function bind and a value bind
16:29:25 <dafra> easier to debug now
16:29:51 <dafra> where are value binds in haskell-src-exts ?
16:30:15 <ezyang> Ok, I think I understand MonadPrompt. Neato
16:30:27 <Orclev> what's the best way to debug haskell? ghci? or is there something specifically for debuging?
16:30:35 <thoughtpolice> ghci has a debugger now
16:30:38 <ezyang> Orclev: What kind of debugging?
16:31:05 <mmorrow> dafra: i don't remember off the top of my head, looking..
16:31:06 <Orclev> ezyang: walking through execution and checking the return values for some functions
16:31:28 <dafra> mmorrow: there are types everywhere, but no values
16:31:35 <Orclev> or I guess more accurately, checking what's being passed as an arg to some functions
16:32:02 <mmorrow> dafra: it's FunBind and PatBind
16:32:15 <mmorrow> dafra: "main = foo" would be a PatBind
16:32:16 <ezyang> Orclev: Yeah, ghci has debugging
16:32:32 <dafra> mmorrow; thanks, i had tried only the other one
16:32:55 <dafra> "main = foo" doesnt look like a pattern to me though
16:33:05 <dafra> more like a value
16:33:48 <Cale> Orclev: use ghci to inspect the results of functions... it has a debugger of sorts, but I don't use it
16:33:56 <SamB> dafra: it's a degenerate pattern
16:34:19 <SamB> that is, "main" is
16:34:56 <Cale> Orclev: Mostly I try to fix bugs by splitting up the functionality of my code into smaller pieces which are easily understood.
16:35:37 <Cale> If there's a bug, then chances are there's a definition which is too large or complex to understand properly in isolation.
16:35:40 <dafra> mmorrow: thanks, PatBinds is what I was looking for
16:36:06 <dafra> mmorrow++
16:36:16 <Cale> Sometimes it can be difficult to split things up and it can take insight to do it properly, but the end result is typically good.
16:36:21 <SamB> Cale: or worse -- it could be a comnglomeration of many small things that are all interdependant!
16:36:32 <dafra> how to promote someone ?
16:36:41 <Cale> dafra: That works.
16:36:55 <SamB> @karma mmorrow
16:36:55 <lambdabot> mmorrow has a karma of 5
16:36:55 <Cale> (though lambdabot can be bad at remembering karma)
16:36:59 <SamB> yeah really
16:37:02 <SamB> @karma
16:37:02 <lambdabot> You have a karma of 1
16:37:04 <SamB> heh
16:37:10 <SamB> I used to have a lot more than that ;-)
16:37:12 <Zao> @karma C
16:37:12 <lambdabot> C has a karma of 1
16:37:21 <dafra> @karma
16:37:21 <lambdabot> You have a karma of 0
16:37:24 <Cale> mmorrow probably would have a karma in the 100's if not for lambdabot forgetting :)
16:37:29 <Cale> @karma
16:37:29 <lambdabot> You have a karma of 24
16:37:44 <dafra> @karma dons
16:37:44 <lambdabot> dons has a karma of 10
16:37:47 <sjanssen> we should go through the #haskell logs and reconstruct karma
16:37:56 <aavogt> Cale++
16:38:02 <sjanssen> dafra: if dons has 10, we know there's a big problewm
16:38:02 <dafra> Cale more popular than dons !
16:38:04 <sjanssen> @karma
16:38:04 <lambdabot> You have a karma of 4
16:38:39 <mmorrow> dafra: in "main = foo", "main" is the trivial pattern ;)
16:39:08 <mmorrow> "[x,y] = [0,1]" is valid at the top-level in a module actually
16:39:17 <dafra> yes, I realize that even 0 or True is a pattern
16:39:42 <Cale> Another good idea for debugging is to use quickcheck for testing.
16:39:45 <mmorrow> well it depends where they are..
16:39:57 <Cale> There are multiple benefits when you do that.
16:40:21 <ezyang> @karma
16:40:21 <lambdabot> You have a karma of 0
16:40:23 <aavogt> > let f x y = case x of y -> True; _ -> False in [f 0 0,f 1 0]
16:40:24 <lambdabot>   [True,True]
16:40:25 <Cale> One is that you're forced to write down algebraic properties that you expect your code to satisfy, which gets you thinking in the right way to begin with.
16:40:45 <mmorrow> > let f x y = case x of y -> True; _ -> _ in [f 0 0,f 1 0]
16:40:46 <lambdabot>   Pattern syntax in expression context: _
16:40:56 <ezyang> What is the data ... where ... syntax for?
16:41:10 <mmorrow> GADTs
16:41:19 <Cale> Another is that when quickcheck finds counterexamples, it has a nice way (in the newer versions) of shrinking the counterexamples, so you get a simple example on which the function fails to work correctly.
16:41:21 <ezyang> ahh
16:41:32 <ezyang> @url GADTs
16:41:32 <lambdabot> I know nothing about gadts.
16:41:35 <ezyang> :-(
16:42:10 <aavogt> > let y = 0; f x = case x of y -> True; _ -> False in [f 0,f 1]
16:42:11 <lambdabot>   [True,True]
16:43:00 <SamB> Cale: how the heck does it do that?
16:43:02 <SamB> is there a paper?
16:43:26 <Cale> SamB: hmm...
16:43:56 <SamB> seems like, if nothing else, that kind of thing would at least rate a Pearl?
16:43:58 <Cale> SamB: I don't really understand what it does either. I should look into that.
16:44:03 <Cale> Yeah.
16:44:04 <dibblego> it's effectively a multi-way tree that QC traverses down to shrink the counter-example (requires a type-class implementation for the shrinking type)
16:44:44 <aavogt> is there ever a case when using 'case' that the RHS can use variables as if they were litterals?
16:44:46 <mmorrow> personally, i'm baffled by how to use QuickCheck (version 2) "advanced" features
16:46:00 <mmorrow> > let y = 0; f x = case x of x | x==y -> True | otherwise -> False in [f 0,f 1]
16:46:01 <lambdabot>   [True,False]
16:46:30 <aavogt> > let f x = case x of 0 -> True; _ -> False in [f 0,f 1]
16:46:32 <lambdabot>   [True,False]
16:46:39 <mmorrow> > let y = 0; f x = case x of _ | x==y -> True | otherwise -> False in [f 0,f 1]
16:46:40 <lambdabot>   [True,False]
16:47:53 <mmorrow> pattern matching'll only ever bind a variable, rather than test for equality with it if it happens to be an already-bound name
16:49:37 <dafra> parsing with haskell-src-exts works like a charm. can i read the symbol table ?
16:49:51 <dafra> id like to distinguish local variables from toplevel ones
16:52:00 <mmorrow> dafra: you need to implement that part yourself
16:55:05 <mmorrow> dafra: you'd just need to implem freevars for Exp/Stmt/any-other-type-reachable-from-Exp
16:55:34 <aavogt> @type uncurry (<$)
16:55:34 <heatsink> My program has a space leak, and heap retainer profiling says that a large fraction of the data is being retained by my unique ID supply.  I'm using a tree of unsafePerformIO nodes (package value-supply) to supply IDs.  Any suggestions on how to get rid of that leak?
16:55:35 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a, f b) -> f a
16:55:49 <mmorrow> dafra: "just" ;)
16:56:03 <dafra> mmorrow: thx
16:57:14 <lispy> heatsink: hey
16:57:20 <heatsink> heya lispy
16:57:35 <lispy> heatsink: why does your unique ID supply need unsafePerformIO?
16:57:37 <ksf> dafra, further down the compiler pipeline you would get that info for free, so, depending on what you want to do it might be wise to just plug into the compiler.
16:57:53 <lispy> heatsink: have you seen MonadUnique?
16:58:10 <mmorrow> ksf: ? he's only using haskell-src-exts
16:59:03 <lispy> heatsink: anyway, it's good that you figured out the retainers.  But yeah, why are they retaining it
16:59:08 <ksf> ...that's the point, free variables should be explicit in core.
16:59:20 <lispy> heatsink: I don't really know the answer to that without more digging
16:59:24 <ksf> (at least if the implementation works like the papers describing it)
17:00:43 <lispy> heatsink: from reading the ghc docs I get the feeling retainer profiling is not trivial to do correctly
17:00:44 <heatsink> lispy: The unsafePerformIO is to allow lazy evaluation of code that depends on unique identifiers.  I basically reinvented MonadUnique, though I call it "Supplies a m"
17:00:48 <mmorrow> ksf: he's not using a haskell compiler though, only haskell-src-exts
17:01:20 <mmorrow> ksf: (and core doesn't necessarily reflect the source-level code either)
17:01:22 <lispy> heatsink: would unsafeInterleaveIO have been a better choice?
17:01:39 <lispy> heatsink: Why do you need IO?
17:01:47 <ksf> mmorrow, I _did_ say "depending on what you want to do"...
17:02:24 <mmorrow> ksf: also, how would be get the ghc-core ast? hack a custom ghc-api thingy? :)
17:02:27 <mmorrow> s/be/he/
17:02:44 <heatsink> lispy: It does use unsafeInterleaveIO, actually, not unsafeperformio...
17:03:29 <lispy> heatsink: but, why do you need any IO at all?
17:03:41 <heatsink> It's for generating a tree of values where every tree node has a distinct value, but values aren't assigned unless evaluation is forced.
17:04:15 <heatsink> If it were a list, then unique ID generation would be totally ordered.
17:04:20 <lispy> heatsink: wouldn't monad unique do the same thing?
17:04:34 <heatsink> But because it's a tree, it's not totally ordered, allowing more lazy evaluation.
17:04:47 <heatsink> This isn't something I invented, it's in the library I'm using.
17:05:14 <lispy> Do you know what type of data is consuming your heap?
17:05:39 <ksf> mmorrow, http://www.haskell.org/sitewiki/images/f/f0/TMR-Issue12.pdf , first paper.
17:05:41 <heatsink> It's varied, but a significant fraction of it is value supply objects.
17:06:43 <heatsink> I don't think that's the sole cause of the space leak, but it's definitely part of what's being leaked.
17:06:46 <mmorrow> ksf: so he would have to hack a custom ghc-api thingy ;)
17:07:37 <heatsink> As for why I want lazy evaluation, part of my code involves nondeterministic choice.  It's not doing things lazily at the moment, but I intend to fix that.
17:08:48 <heatsink> lispy: In the heap description profile, the object on top is a value-spuply object.  Next is (:), then two GHC.IOBase objects, then another value supply object.
17:09:50 <heatsink> It looks like I should take the time to write my own value supply implementation.
17:12:02 <Vanadium> Why are TMR papers releases as they are instead of just being wiki articles?
17:12:22 <Vanadium> With, say, actual links in the middle of the text and all that jazz people invented in the past couple of decades
17:12:42 <ezyang> Hey all, for MonadPrompt, if I want to use it with IO, does it have to be at the inside of the monad stack? And if not, how could I make that work?
17:13:18 <dafra> i m back. so ghc api may be a solution
17:13:34 <mmorrow> dafra: what are you trying to achieve?
17:14:06 <dafra> mmorrow: measure dependencies between toplevel functions (who uses who)
17:14:26 <dafra> mmorrow: like OOP guys do for class dependencies
17:14:31 <mmorrow> dafra: don't use the ghc-api. you just need a few freeVars functions
17:15:11 <ezyang> I guess it's not obvious to me what the difference between MaybeT IO a and IO (Maybe a) is (assuming the existence of MaybeT transformer)
17:15:17 <dafra> freeVars ?
17:16:13 <codolio> ezyang: MaybeT IO a lets you use Maybe-like operations. Like, it has a Maybe-like MonadPlus instance (or should, but the library doesn't provide it).
17:16:43 <mmorrow> dafra: Exp -> Set QName
17:17:05 <codolio> IO (Maybe a) has a MonadPlus instance involving IO exceptions, but that's true of any IO a.
17:17:09 <mmorrow> dafra: Stmt -> Set QName, ...    _ -> Set QName, where "_" is any type reachable from Exp
17:17:16 <ksf> dafra, recurse into the syntax, collecting all variables, then, on your way out, filter out everything that's bound by a let or similar.
17:17:32 <dafra> mmorrow: i see
17:18:01 <ksf> what you should be left with are the free variables of the top-level definition, with lexical scope treated correctly.
17:18:37 * ksf can't help but think of plt-scheme
17:19:03 <ksf> ...it displayed pointer to every mention of a symbol if you mousehovered over it.
17:19:22 <dolio> ezyang: In other words, I suppose, IO (Maybe a) isn't a monad stack. The monad in question is IO, and the computation returns Maybe a.
17:19:36 <dafra> ksf: notepad++ does that too
17:19:38 <dolio> Whereas with MaybeT IO a, the monad is (MaybeT IO).
17:19:59 <ksf> sounds like a prospective leksah feature, to mee.
17:20:08 <dafra> ksf just highlites actualy :)
17:20:14 <ksf> dafra, also respecting scope?
17:20:43 <ksf> that is, let id = "123" in serialize id "bar" shouldn't point to the definition of id x = x ...
17:20:46 <dolio> And so on. StateT s (ReaderT r (MaybeT IO)) is a monad. With IO (Maybe (Reader r (State s a))), It's an IO computation returning a Maybe computation returning ...
17:20:48 <dafra> ksf: nope, text only, it barely knows what a word is...
17:22:11 <heatsink> lispy: did I adequately explain why unsafeinterleaveio?
17:28:46 <solidsnack> Is type constructor composition possible in Haskell?
17:29:15 <bd_> what do you mean by that?
17:29:15 <SamB> not very well ...
17:29:28 <solidsnack> :kind (,)
17:29:37 <solidsnack> lambdabot: kind (,)
17:29:50 <solidsnack> hmm
17:29:55 <mmorrow> @bot
17:29:55 <lambdabot> :)
17:30:04 <mmorrow> ruhroh
17:30:07 <heatsink> Do you mean like (\a -> Maybe (Maybe a)) :: * -> *
17:30:12 <ray> :k (->)
17:30:13 <lambdabot> ?? -> ? -> *
17:30:15 <mmorrow> has lunabot crashed and burned?
17:30:20 <solidsnack> I mean like, compose [] and (,) to get the assoc list type constructor
17:30:23 <ray> , hello?
17:30:42 <heatsink> solidsnack, you can't do that, but you can do something similar with newtype.
17:30:54 <solidsnack> yuck
17:31:01 <dolio> solidsnack: There are libraries that define things like 'newtype (f `O` g) a = O (f (g a))'
17:31:03 <solidsnack> thanks for letting me know, though
17:31:16 <ray> yeah type-level programming isn't all it could be
17:31:27 <solidsnack> I want to define an instance for assoc lists
17:31:42 <solidsnack> So I guess I need to change the typeclass to be more repetitive, basically.
17:32:00 <mmorrow> @bot
17:32:00 <lambdabot> :)
17:32:00 <lunabot>  :o
17:32:01 <ezyang> Why is there a runPromptM but not runPromptTM?
17:32:25 <ksf> >  (pure . (,)) 1 2
17:32:26 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (a, b))
17:32:26 <lambdabot>    arising from a use...
17:32:40 <ksf> >  (pure . (,)) 1 2 :: [(Int,Int)]
17:32:41 <lambdabot>   Couldn't match expected type `[(GHC.Types.Int, GHC.Types.Int)]'
17:32:42 <ray> solidsnack: it'd have the same kind either way wouldn't it?
17:32:47 <ray> or, wait
17:32:48 <ksf> uh.
17:32:50 <ksf> pl fail.
17:33:06 <solidsnack> ray: Yes but then clients would need to wrap all their assoc lists.
17:33:11 <ray> it expects * -> * -> *
17:33:15 <mmorrow> @pl \x -> x x
17:33:15 <lambdabot> join id
17:33:23 <ksf> anyway, constructors are curried, just like any other function.
17:33:28 <ray> yeah, that does suck
17:33:42 <ray> :k [] (,)
17:33:43 <ksf> >  ((pure .) . (,)) 1 2 :: [(Int,Int)]
17:33:43 <lambdabot>     `(,)' is not applied to enough type arguments
17:33:43 <lambdabot>     Expected kind `*', but `(,)' has kind `* -> * -> *'
17:33:44 <lambdabot>   [(1,2)]
17:33:54 <ksf> >  ((pure .)  (,)) 1 2 :: [(Int,Int)]
17:33:56 <lambdabot>   Couldn't match expected type `[(GHC.Types.Int, GHC.Types.Int)]'
17:34:01 <ksf> >  ((pure .)  (,)) 1 2
17:34:02 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (a, b))
17:34:02 <lambdabot>    arising from a use...
17:34:14 <ksf> :t  ((pure .) . (,))
17:34:15 <lambdabot> forall (f :: * -> *) a a1. (Applicative f) => a1 -> a -> f (a1, a)
17:34:34 <mmorrow> @pl \a b -> g (f a b)
17:34:34 <lambdabot> (g .) . f
17:34:39 <solidsnack> Instead, I need to rewrite the class so it looks like this:        instance C (Data.Map.Map k v) k v where...         instance C [(k,v)] k v where...
17:34:49 <ksf> >  (((pure .) . (,)) 1 2 ) :: [(Int, Int)]
17:34:50 <lambdabot>   [(1,2)]
17:34:53 <ksf> ha!
17:35:42 <ksf> solidsnack, are you sure you want to use an assoclist?
17:35:42 <mmorrow> @pl \a b c d e -> g (f a b c d e)
17:35:43 <lambdabot> ((((g .) .) .) .) . f
17:35:46 <ksf> we've got maps.
17:36:01 <ksf> (well, that take an assoclist to construct them...)
17:36:29 <mmorrow> not necessarily
17:36:42 <solidsnack> ksf: Yes, I know there are maps. There are also ByteString tries and finite maps and on and on...
17:36:45 <ksf> you can monoid your data in, too, yes.
17:36:47 <mmorrow> you can fold over another structure and build the map as you go
17:37:06 <solidsnack> So the point of the class is to have one operator to lookup from all of them.
17:37:29 <ksf> solidsnack, have a look at edison.
17:37:49 <ksf> http://hackage.haskell.org/package/EdisonAPI
17:38:11 <ksf> ...and there's also a load of structures implemented for it: http://hackage.haskell.org/package/EdisonCore
17:42:08 <jeffwheeler> Say, I want a 64-bit GHC on my Windows machine. Can I download the 32-bit exe, and build a 64-bit version from that?
17:42:12 <solidsnack> ksf: So this is the problem, actually.
17:42:51 <solidsnack> Does the Edison API allow me to define lookup for `[(k,v)]`, though? I think not.
17:43:18 <ksf> with TypeSynonymInstances that should be possible.
17:43:27 <gwern> 'Organizing functional code for parallel execution or, foldl and foldr considered slightly harmful'
17:43:31 <gwern> auugh
17:44:22 <solidsnack> ksf: No, the type synonym has to be fully applied.
17:44:56 <solidsnack> As far as I know, there's no way to treat [(,)] as a type constructor of kind * -> * -> *
17:45:34 <mmorrow> solidsnack: if you make your class like that, then it'll be problematic for Map
17:45:35 <solidsnack> ksf: More generally, Edison has no way to accomodate monomorphic containers like ByteString trie.
17:45:43 <mmorrow>  since you need an Ord constraint on the key
17:46:00 <SamB> solidsnack: I think the only APIs that let you do that fail to constrain map to map between things of the same sort ...
17:46:08 <mmorrow> pretty much any way you do it, there's one festering eyesore or another
17:46:16 <mmorrow> so pick your poison :)
17:46:35 <solidsnack> Yeah, well.
17:47:23 <solidsnack> SamB: It makes it possible to write instances that fail to constrain it, yeah.
17:48:00 <SamB> where by "same sort", I just mean the sort of constraints you'd *expect*
17:48:10 <solidsnack> mmorrow: Well, it's not as bad as that.
17:48:36 <solidsnack> SamB: Not sure I understand you, actually.
17:48:41 <SamB> solidsnack: well, I couldn't figure out how to design an API that would admit both Array and [(a,b)] without having that as a fundamental non-constraint :-(
17:49:18 <solidsnack> SamB: Having what, exactly, as a non-constraint?
17:49:45 <dolio> gwern: So, what, "use our parallelized recursion combinators instead of the usual ones"?
17:49:51 <SamB> solidsnack: well, for instance, you could do a map between an Array and a [(a,b)]
17:49:56 <gwern> dolio: presumably
17:50:04 <gwern> or maybe 'use fortress instead of haskell'
17:50:29 <solidsnack> mmorrow: So basically, the choice is between instances that are "right" and relatively straightforward substitution of one implementation for another.
17:50:42 <dolio> Yawn.
17:52:30 <solidsnack> It seems desirable to me that I should be able to replace `Data.Map.Map ByteString Int` with `Data.Trie.Trie Int` and not have to change any of the code that does a lookup on these structures.
17:53:20 <solidsnack> SamB: What are you talking about? I don't understand at all. I thought we were talking about collections APIs, with things like `lookup`, for example.
17:53:29 <dolio> How does an Edison-like API not allow for ByteString trie?
17:53:34 <SamB> maybe my API was too simple :-(
17:53:55 <solidsnack> dolio: `Data.Trie.Trie` has only one type parameter.
17:53:59 <SamB> but I used just about every feature!
17:54:03 <dancor> @hoogle runInteractiveProcess
17:54:03 <lambdabot> System.Process runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
17:54:18 <solidsnack> SamB: What API?
17:54:18 <dolio> As does the m parameter of the Edison FiniteMap class.
17:54:18 <mmorrow> solidsnack: exactly, that's where the problems come in. (the general siutation of) being able to interchange (Map k a) and (IntMap a)
17:54:29 <dancor> http://haskell.org/hoogle/?hoogle=runInteractiveProcess has no results, wtf
17:54:34 <SamB> solidsnack: I sent it to the libraries@ list a long time ago ...
17:54:36 <dolio> With a functional dependency from the map to its keys (which is also a paramtere to the class).
17:55:12 <solidsnack> dolio: Aha, you are right.
17:55:13 <dolio> class (Whatever) => FiniteMap m k | m -> k where { lookup :: k -> m a -> Maybe a ; ... }
17:55:31 <dolio> You can also do it with associated types.
17:55:53 <solidsnack> Oh?
17:56:05 <solidsnack> Okay, let me think about it.
17:56:27 <solidsnack> Maybe I can wrap the ByteString trie for Edison and then I'll be happy.
17:56:45 <dolio> class FiniteMap m where type Key m :: * ; lookup :: Key m -> m a -> Maybe a ; ... }
17:56:48 <mmorrow> solidsnack: here's a variation i tried the other day (that works for Map/IntMap situation) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3514#a3514
17:57:03 <mmorrow> solidsnack: but for one reason or another it bothered me, so i scrapped it
17:57:40 <solidsnack> mmorrow: It's good to see it, though.
17:57:48 <solidsnack> Thanks.
17:57:50 <dolio> Or you could build the class around the key, if you only want one type of map per key (which I guess it doubtful if you're considering switching out maps for other maps).
17:57:52 <mmorrow> solidsnack: :)
17:58:59 <ksf> mhhh can you implement the dining philosophers in frp?
17:59:30 <mmorrow> dolio: heh, totally that's exactly what i tried
17:59:43 <solidsnack> Thanks guys. Got to go.
18:00:06 <ksf> more importantly, how could you stop them from deadlocking, given the primitives?
18:01:14 <dolio> Can you implement dining philosophers using Model-View-Controller?
18:02:15 <SamB> I don't want to implement that. I want to implement dining proof assistant users ;-)
18:03:02 <ksf> inside the computation of the model, certainly. Also if you allow for an dependency cycle between more than one mvc.
18:03:36 <Phyx-> hmm 3am... code more or sleep..
18:03:50 <ksf> Phyx-, dream of coding.
18:04:35 <Phyx-> did that once, woke up and had to hastily write down everything i dreamed
18:05:15 <ksf> you might also see yourself analysing a deadlock between you and your program...
18:05:49 <Phyx-> i actually solve quite a few coding problems in my sleep
18:06:17 <SamB> Phyx-: by forgetting your stupid ideas from the night before?
18:06:35 <SamB> what language did you dream in?
18:06:41 <SamB> what library did you dream?
18:06:53 <Phyx-> well, at the time, it was java
18:06:53 <heatsink> lispy, yup, not using the tree thing got rid of my space leak.
18:06:57 <Phyx-> a program we were working on
18:06:59 <Phyx-> was deadlocking
18:07:11 <SamB> ah. Java.
18:07:12 <Phyx-> and i actually dreamt off the solution
18:07:16 <Phyx-> of*
18:07:25 <SamB> that might explain how you could do anything worthwhile in your sleep ...
18:07:36 <Phyx-> what i have with haskell is, like now, when i'm in a half sleepy state
18:07:47 <Phyx-> i would make code that runs and works fine
18:07:50 <SamB> ... me, I don't think I have the attention span to dream up a solution to a programming problem
18:07:51 <heatsink> Phyx-, Hmm, was it sound or unsound sleep?
18:07:56 <Phyx-> but in the morning, i'd have no idea how it works...
18:07:56 <SamB> at least not when I'm asleep ;-)
18:08:28 <Phyx-> heatsink: sound
18:08:44 <Phyx-> i always sleep soundly. not even a nuke could wake me
18:09:09 <heatsink> That's nice.  When problem solving creeps into my dreams, I don't sleep as well.
18:09:42 <heatsink> There's someone who works near me who sleeps soundly.  He has three alarm clocks.
18:09:46 <dolio> My point is that FRP, like MVC, is a way of structuring parts of your GUI (or whatever interactive) system, but it has nothing inherently to do with concurrency or locking or whatever. So can you have a library that both has some kind of concurrency, and could be described as functional reactive programming? Probably.
18:09:53 <SamB> Phyx-: so you didn't prove anything absurd?
18:09:54 <Phyx-> i have trouble then at times falling alseep, but once i do i'm gone
18:10:26 <ksf> the dining philosophers don't have to do anything with concurrency or locking, either.
18:10:35 <ManateeLazyCat> Saizan: Yesterday you said, you can use `Map Tag Type` to implement Binary instance of typeclass. Example for "data Foo = forall a . FooClass => Foo a", i need write "forall a . FooClass a => Map Tag a", right?
18:10:48 <ksf> they're about cyclic dependencies.
18:11:09 <Phyx-> SamB: no, atleast not yet anyway, but i have alot of code i've never looked at again, since it's well.... a mystery to me, but it works..
18:11:12 <Phyx-> lol
18:11:28 <SamB> Phyx-: in your sleep
18:11:35 <dolio> But it's not like FRP is some concrete set of primitives. It's more like a design principle.
18:11:39 <SamB> otherwise, I think it would have to be said that it was unsound sleep ;-)
18:11:57 <ksf> well ok.
18:12:07 <ksf> but then it's quite easy to make e.g. reactive deadlock.
18:12:13 <Phyx-> ksf: how so? isn't a deadlock by definition a cycle in your dependency graph?
18:12:27 <ksf> (or whatever makes it stop consuming any events, whatsoever)
18:13:05 <ksf> Phyx-, exactly, and dependencies have nothing to do with concurrency and/or locking.
18:13:15 <ksf> ...locking is a possible way out, and concurrency is...
18:13:24 <ksf> ...well, non-existant on uniprocessors, anyway.
18:13:37 <ManateeLazyCat> dolio: For works Haskelll GUI, i just use gtk2hs, now haven't mature Functional GUI in Haskell.
18:13:53 <Phyx-> right, ok. I see the point you're trying to make. Although don't most literature use the dining filosophy problem to explain deadlocks?
18:14:13 <ksf> ...yes, because that what they're about.
18:14:24 <SubStack> uses hopengl for that stuff
18:14:36 <SubStack> or happstack right now
18:14:54 <ksf> that they're independent processes is not necessary for the deadlock to occur, though.
18:15:11 * Phyx- is going to bed, 3.15am is not to time to be writing audio encoders
18:15:35 <Phyx-> ksf: well, i never said that part, lol
18:15:36 <ksf> f x = x, given blackhole detection and not throwing the appropriate execption is quite the same thing.
18:15:40 <SubStack> or it's the perfect time to write audio encoders
18:15:42 <ksf> er f x = f x
18:16:34 <SubStack> or anything fun for that matter
18:16:48 <ksf> (as in "hey, who knows, f x could change and then I might be able to continue")
18:17:29 <Phyx-> but that's neither a deadlock, and neither a cyclic dependency
18:17:31 <glguy> if only we had a general algorithm to determine when a program would never terminate
18:17:38 <Phyx-> since the execution of f can always proceed
18:17:43 <Phyx-> it just won't ever terminate
18:18:02 <ksf> well, it's a thunk waiting for itself.
18:18:13 <ksf> I'm assuming proper laziness here.
18:18:15 <glguy> its a fresh application each time
18:18:36 <glguy> would you be assuming proper memoization?
18:18:48 * SamB_XP chuckles
18:19:20 <ksf> I might centainly assume a pc that's smarter than me.
18:19:26 <Phyx-> ksf: it's tail recursive isn't it? it wouldn't really have a thunk in this case no? or atleast not a waiting one
18:19:50 <ksf> operational knick-knack.
18:19:51 <glguy> it would be pretty great if it was able to optimize down to a "jump to self"
18:20:23 <dolio> GHC isn't sufficiently smart for that.
18:20:43 <dolio> Just like 'fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2)' doesn't take linear time.
18:21:18 <dolio> Despite the fact that that'd be cool.
18:21:41 <glguy> You thought that you Haskell program's time and space complexity were hard to reason about before?
18:21:42 <dolio> (If you don't mind potentially massive memory overhead.)
18:21:50 <glguy> Introducing "-Omagic"
18:22:03 <dolio> Yeah, that's what got me about the discussion about this on -cafe recently.
18:22:17 <ksf> ...well, you can use of of those gazillion memoisation packages.
18:22:21 <heatsink> glguy: Requires internet connection, and works best between 8am and 6pm indian time
18:22:34 <dolio> Someone was talking about how you could do that kind of memoization, and have the GC clear it out when memory got too full...
18:22:57 <dolio> But people already complain that -O2 changes the asymptotic complexity of their algorithms due to strictness analyiss and such.
18:23:00 <PetRat> I want to install qtHaskell for Windows XP... I think I need to install MinGW (or whatever it's called.. the "minimum GNU Windows" system) to build both Qt and to build qtHaskell. Does that sound right?
18:23:12 <glguy> dolio: and not always for the better!
18:23:32 <dolio> How are they going to like when their algorithms vary between O(n) and O(2^n) depending on how much memory is in use elsewhere in the program and such?
18:23:43 <dolio> It's not the type of thing you could ever depend on.
18:24:31 <glguy> could you approximate that GC hijack for memoization with some weak references?
18:24:51 <dolio> Maybe. Lots of unsafePerformIO magic.
18:25:28 <PetRat> (bump) I want to install qtHaskell for Windows XP... I think I need to install MinGW (or whatever it's called.. the "minimum GNU Windows" system) to build both Qt and to build qtHaskell. Does that sound right?
18:25:43 <glguy> You have to wait longer than 2 minutes to bump
18:25:49 <glguy> (bump) You have to wait longer than 2 minutes to bump
18:27:03 <PetRat> Okay let me ask a more basic question: anyone here familiar with building software from source on Windows such as Qt and qtHaskell?
18:27:43 <mmorrow> PetRat: don't you need MinGW to build ghc from source on windoze anyways?
18:28:09 <PetRat> mmorrow: I downloaded a Windows binary of GHC.
18:28:55 <mmorrow> PetRat: well, clearly :)
18:29:12 <mmorrow> PetRat: to answer your question, yes that does sound right.
18:29:15 <PetRat> Another question (unrelated): taking of union of two maps is O(n+m) in the average (or possibly worst) case. However, if all the keys in one map are smaller than all the keys in the other map, what speed is it?
18:29:36 <SamB> PetRat: presumably just a rebalance ...
18:29:38 <mmorrow> it depends on the structure implementing the map
18:29:45 <mmorrow> IntMap is best case O(1)
18:29:57 <mmorrow> for union
18:30:05 <Cale> O(n+m) is the worst case, btw.
18:30:27 <mmorrow> is it little-o for the lower-bound?
18:30:44 <PetRat> A rebalance is an O(1) operation?
18:30:52 <mmorrow> IntMap never needs rebalancing
18:31:20 <PetRat> mmorrow: how about Data.Map?
18:31:20 <Cale> It's possibly worth noting that O(n+m) is the same thing as O(max(n,m))
18:31:30 <mmorrow> PetRat: Data.Map does need to be rebalanced
18:31:31 <lpsmith> mmorrow:   http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3510    <-- it's pretty lame,  but I managed to confuse somebody with it earlier today :-P
18:31:55 <lpsmith> Can anybody guess what the program does without running it?  :-)
18:32:21 * mmorrow thinks
18:32:23 <hackagebot> modsplit 0.2.1 - Haskell source splitter driven by special comments. (DmitryGolubovsky)
18:33:17 <Cale> Of course it runs forever printing Hello World!
18:33:45 <lpsmith> ding ding ding ding :)
18:34:14 <mmorrow> yeah, due to (>>) messing with yoar mindz
18:34:16 <Cale> stupidloop captures the current continuation and runs it infinitely many times.
18:34:30 <ezyang> I... can't figure out this infinite type error
18:34:37 <Cale> and the current continuation where it's used in main is just  lift (putStr "Hello World!\n")
18:35:57 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9056#a9056 Any ideas?
18:36:27 <dolio> Can you paste the error below that?
18:36:39 <ezyang> Sure
18:37:06 <ezyang> done
18:38:03 <Cale> hmm... runPromptM :: (Monad m) => (forall a. p a -> m a) -> Prompt p r -> m r
18:38:12 <dolio> Well, I think the type of the 'runPromptM ...' stuff is (IO something)...
18:38:18 <ezyang> oooh, wrong one!
18:38:21 <ezyang> I want runPromptT
18:38:40 <ezyang> um, no
18:38:42 <dolio> So "liftM fromError (runPromptM ...)" would be IO (IO something-else)
18:38:49 <ezyang> I do want runPromptM
18:38:50 <ezyang> Ok
18:38:53 <lpsmith> heh... sometimes I find it useful to replace parts of the expression with undefined
18:38:54 <Cale> runCommand :: Environment -> CommandMonad a -> IO (IO a)
18:38:59 <ezyang> So... I need to do a =<<
18:39:07 <Cale> yeah
18:39:13 <Cale> instead of liftM
18:39:15 <ezyang> Hm Couldn't match expected type `a -> b' against inferred type `IO a1'     In the first argument of `(=<<)', namely `fromError'
18:39:22 <ezyang> operator precedence wonkiness?
18:39:29 <Cale> Delete the type signature and see what's inferred.
18:39:31 <ezyang> whoo
18:39:42 <Cale> don't use so many $'s too ;)
18:39:51 <dolio> $ is looser than =<<.
18:40:09 <ezyang> dolio: Ok
18:40:19 <dolio> So if you do 'fromError =<< runPromptM $ ...' it parses as '(fromError =<< runPromptM) ...'.
18:40:21 <ezyang> Cale: aww, but I like mah pipelines :-)
18:40:25 <ezyang> dolio: Savvy
18:40:31 <ezyang> It typechecks
18:40:34 <Cale> ezyang: You should use (.) in place of every ($) that you can
18:40:55 <dolio> You could write it as: 'fromError <=< runPromptM handleIO . runErrorT $ runReaderT m env' probably.
18:41:01 <Cale> If you have more than one $ in a row, all but the last of them can always be replaced with (.)
18:41:32 <Cale> :) I like that version.
18:41:32 <ezyang> Cale: Ooh, nice one
18:41:43 <ezyang> Interesting
18:41:57 <Cale> <=< doesn't see enough use
18:42:09 <Cale> It's probably the nicest way to define monads in the first place
18:42:26 <ezyang> attempting to twist mind to see how that works
18:42:45 <dolio> (<=<) is kleisli composition. So that's still a composition pipeline.
18:42:50 <ezyang> Ok, (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
18:42:55 <ray> <=<'s type must be satisfied, and it has to be the operation of a monoid
18:42:55 <ezyang> so, a is actually still a monad
18:42:59 <ezyang> but it'll be ok
18:43:01 <lpsmith> where is the Prompt monad defined?
18:43:07 <Cale> Control.Monad.Prompt
18:43:12 <ezyang> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.2/doc/html/Control-Monad-Prompt.html#v%3ArunPromptT
18:43:47 <ManateeLazyCat> ezyang: runCommand m = liftM fromError . runPromptM handleIO . runErrorT . runReaderT m
18:44:45 <Cale> ManateeLazyCat: Are you sure that doesn't suffer from the same problem his code had originally?
18:45:00 <ezyang> ManateeLazyCat: Doesn't work
18:45:18 <ezyang> Like, I know it won't, because liftM/fmap is not /strong/ enough to do the right thing
18:45:18 <ManateeLazyCat> ezyang: Change argument sequence of runCommand
18:45:25 <ManateeLazyCat> runCommand :: CommandMonad a -> Environment -> IO a
18:46:50 <Cale> ManateeLazyCat: Did you try it?
18:46:54 <ManateeLazyCat> Cale: I just use hlint improve code format, don't care what's it. :)
18:47:03 <Cale> ManateeLazyCat: I think it'll have the same type error that the original code did
18:47:30 <ManateeLazyCat> Cale: I haven't test it, just use hlint transform it. :)
18:49:53 <ghostman> chickimicki, my ip is 78.43.171.29
18:50:34 <Cale> ghostman: ?
18:50:44 <ghostman> harrharr
18:50:50 <aavogt> @vixe what's your ip?
18:50:50 <lambdabot> Maybe you meant: vixen vixen-off vixen-on
18:54:04 <ghostman> chickimicki, my ip is 78.43.171.29
18:54:50 <lpsmith> ezyang:  what's the the Response monad?
18:55:05 <Cale> lpsmith: Probably not a monad
18:55:17 <lpsmith> oh
18:55:19 <lpsmith> :)
18:56:01 <lpsmith> right...
18:59:54 <ezyang> I'm not concentrating hard enough
18:59:58 <Cale> It's a datatype (GADT) explaining what commands there would be in the given prompt monad (using prompt :: p a -> Prompt p a). handleIO interprets those commands as IO actions, and then runPromptM handleIO will turn the whole Prompt computation into an IO action
18:59:59 <ezyang> and having difficulty resolving these type errors
19:00:11 <ezyang> liftP . prompt (Echo (show m)) >> return m
19:00:19 <ezyang> Why does it not work?
19:00:29 <Cale> Why liftP?
19:00:49 <ezyang> I was permuting between lift and liftP
19:01:01 <ezyang> As I said, not thinking clearly enough
19:01:11 <ezyang> I need some sort of monad
19:01:29 <ezyang> prompt should give me a monad
19:01:44 <ezyang> but since I'm using a transformer, it's the wrong monad
19:02:01 <ezyang> so prompt (Echo (show m)) >> return m gives me: No instance for (MonadPrompt...)
19:02:11 <lpsmith> ezyang:  start replacing parts of thaat function with undefined,  or bot, or anything that has type :: forall a. a.
19:02:22 <lpsmith> eventually you'll fix the type error
19:02:32 <ezyang> lpsmith: "thaat function"?
19:03:07 <lpsmith> your runCommand function
19:03:32 <lpsmith> of course, it's not a real solution,  but that will hopefully give you some insight into where the type error is
19:03:34 <ezyang> Oh, this is a different function
19:03:41 <ezyang> but ok, I'll try doing that
19:03:54 <ezyang> Ok, lift has the correct end type, it seems
19:03:59 <ghostman> chickimicki, my ip is 78.43.171.29
19:04:45 <ezyang> Huh...
19:04:52 <ezyang> Maybe MonadPrompt doesn't have a MonadTrans instance
19:05:21 <ezyang> Well, of course it doesn't, it's not being used as a transformer
19:05:27 <ghostman> chickimicki, my ip is 78.43.171.29
19:06:03 <ezyang> Maybe... I have to do two lifts?
19:06:45 <ezyang> whoa, that was it!
19:07:29 <ezyang> That's laaaame though
19:07:59 <dancor> i'm lazily pulling lines ls out of a fifo, and i want to do an action on each line, then filter the list, and print it.  but i lose the laziness at the doAct step if i do:  mapM_ print . myFilter =<< mapM doAct ls
19:08:05 <ezyang> I thought lift magicaly unwrapped as many monads as it needed
19:08:10 <ezyang> I guess typewise that doesn't actually make sense
19:08:31 <dancor> ezyang: i think that's why there are different lift's (like liftIO will pull up the right amount)
19:08:45 <lpsmith> ezyang:  it can,  depends on the instance definitions.
19:08:46 <dancor> (if you only have one IO monad in your stack)
19:09:00 <ezyang> There's no IO monad in the stack
19:09:04 <SamB> dancor: let me know if you ever figure out how to get an IOT
19:09:16 <ezyang> lpsmith: How so?
19:09:19 <ezyang> (not obvious to me at all)
19:09:23 <dancor> SamB: what does IOT stand for
19:09:30 <lpsmith> But honestly,  I'm not a big fan of monad transformers, so I don't use lift all that much
19:09:34 <Twey> IO Transformer, dancor
19:09:41 <SamB> dancor: it's what you'd need to get another IO in your stack ;-)
19:09:55 <dancor> oh, a little jokesie
19:10:01 <Twey> The -T suffix is conventional for monad transformers
19:10:03 <Twey> Heh
19:10:15 <ezyang> also, mtl should be able to automatically determine how much lifting was necessary, I thought...
19:10:16 <Twey> ‘Hah!  I have *two* real worlds at my disposal!’
19:10:34 <SamB> Twey: isn't there a primitive for that?
19:10:48 <ezyang> OHHH
19:10:49 <BMeph> Laziness is the Art of doing as much work as necessary, and then Stopping. ;)
19:11:00 <ezyang> That's why it's like, "Need typeclass"
19:11:04 <ezyang> "instance"
19:11:06 <dancor> i should have used liftST in my non-illuminating-anyway example
19:11:10 <dancor> i guess
19:11:12 <ezyang> maybe I can define it and make this amazing and bubbly
19:11:22 <Twey> SamB: Hahaha
19:11:48 <ezyang> Although... I don't really know where to start
19:12:01 <ezyang> Does mtl use black magic to make typeclasses and instances do the right thing?
19:12:31 <SamB_XP_> ezyang: no!
19:12:40 <SamB_XP_> it just uses O(n^2) instances
19:13:13 <ezyang> omg
19:13:27 <ezyang> does it, at least, use template Haskell or something?
19:13:51 <dancor> i guess there is no lazy mapM that i would need to do what i want
19:19:39 <ezyang> whoo, I win!
19:19:44 <ezyang> instance (MonadPrompt p m, Error e) => MonadPrompt p (ReaderT r (ErrorT e m)) where     prompt = lift . lift . prompt
19:19:54 <ezyang> I guess I can actually clean this up a little
19:20:28 <ezyang> Also, I had to enable three language extensions to get that to work
19:21:02 <ezyang> Ok, less generic version works better
19:26:59 <arw_> crontab -l
19:27:08 <PetRat> (on Windows) In building qtHaskell, I get "Setup.hs: At least the following dependcies are missing:OpenGL -any". I assume I need to install OpenGL. Anyone know if I need to install the source, or just a dll?
19:27:09 <arw_> ah, sorry. wrong window in focus :)
19:30:27 <aavogt> PetRat: there must be some instructions for installing hopengl on windows... perhaps you already have the dlls?
19:31:03 <PetRat> aavogt: I'm working from this: http://qthaskell.berlios.de/doc/userguide/general.html
19:31:08 <orbitz> *sigh* cannot get a reasonable version of haskell installed on my work machine
19:31:17 <PetRat> I don't see a mention of hopengl.
19:32:09 <aavogt> PetRat: earlier versions of ghc (pre 6.10 iirc) came with the OpenGL haskell binding
19:32:17 <ezyang> I have code that runs with runghc, but not with ghc. How do I make it compile it with ghc?
19:32:46 <ezyang> aha, --make!
19:32:50 <PetRat> aavogt: does that mean I need an earlier version to use qtHaskell? or is there a way to install OpenGL now?
19:33:04 <aavogt> ?hackage OpenGL
19:33:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenGL
19:33:20 <PetRat> aavogt: ah, so I can use cabal?
19:34:25 <aavogt> yeah, but you may have to deal with the C library dependencies yourself (either the dlls, or the .h header files)
19:34:46 <SamB_XP_> 'specially if you need glut
19:35:08 <PetRat> aavogt: perhaps I should just switch to ghc 6.8? I don't have much experience building apps on Windows, so that might be the easiest route.
19:36:21 <aavogt> that could work
19:39:58 <ezyang> What is the standard way of implementing contextual options in GetOpt?
19:46:35 <ezyang> scratch that previous question
19:47:14 <ezyang> Does it make sense to take some monad stack (let's say ReaderT + ErrorT + Prompt) and somehow extract one submonad for a particular computation?
19:47:19 <ezyang> Or not worth the trouble?
19:48:48 <T-Cell> Can someone tell me if there is a way to graph in ghci?
19:50:14 <aavogt> ?hackage gnuplot
19:50:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gnuplot
19:50:42 <arsenm> T-Cell: also try the Chart library
19:54:56 <sclv_>  /msg
19:55:59 <dolio> ezyang: What do you mean by that?
19:56:44 <ezyang> dolio: So, one of the great things of not staying in the IO monad all the time is that you get to narrow down the side effects any particular computation can have
19:57:12 <ezyang> Well, a common pattern in applications is to have some sort of "AppMonad", which is a stack of all the monads that you deemed useful to most command dispatchers
19:57:24 <ezyang> But sometimes these dispatchers don't need all of the monadic functinality
19:57:27 <ezyang> *functionality
19:58:29 <aavogt> ezyang: why not just use contexts like:   (MonadIO m,MonadReader xyz m) => ...
19:58:34 <dolio> Well, mtl handles that by having classes for the functionality.
19:59:56 <dolio> You can try lifting stuff like 'FooT Bar a' into 'FooT (BarT Baz) a', but that sort of thing is more difficult in a transformer approach.
20:00:04 <ezyang> aavogt: Oh hey, that's pretty elegant!
20:00:13 <dolio> It'd probably be better handld by a coproduct treatment of monads.
20:00:33 <ezyang> dolio: Yeah... does such an implementation exist?
20:01:26 <dolio> No, although I used Prompt to fiddle with breaking up IO into a bunch of monads you could use as coproducts.
20:01:59 <ezyang> Prompt... sort of gets that kind of mechanism
20:02:05 <ezyang> I guess I don't understand it's implementation well enough
20:02:25 <mmorrow> T-Cell: here's a module i had stashed away somewhere that you just reminded me of, maybe it'd be useful for this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9058#a9058
20:02:25 <dolio> The problem I see with monad coproducts is that you need a master monad with all of the functionality already defined to extract all the submonads to.
20:02:34 <mmorrow> T-Cell: (it's for plotutils)
20:02:45 <dolio> So they don't really serve the same function as monad transformers.
20:03:29 <SamB> s/master/monster/
20:04:30 <dolio> So even if you have a bunch of mini IO SpecificFunction monads, and work with coproducts of those, you need the existing monolithic IO to extract it all to.
20:06:10 <dolio> And for stuff like (State s :+: State t), you need to extract to State (s,t) or something, otherwise you lose all updates to the s state when you switch to computations on the t state, and vice versa.
20:06:39 <dolio> If you try to extract to Identity or something, which doesn't inherently track state.
20:07:18 <ezyang> Ew
20:07:58 <SamB> dolio: ... so wouldn't your theorem prover just reject that extraction then ?
20:09:07 <dolio> Huh?
20:09:43 * SamB_XP_ 's been writing a lot of Coq lately ;-)
20:10:11 <dolio> Monad coproducts some with something that looks like: extract : (forall a. l a -> m a) -> (forall a. r a -> m a) -> (l :+: r) a -> m a
20:10:15 <Axman6> how is Coq pronounced anyway?
20:10:29 <Axman6> is it cock? or something strange?
20:10:37 <SamB_XP_> cock -- means rooster
20:10:41 <SamB_XP_> hence the logo
20:10:54 <Axman6> ah, i see. i've never looked into it
20:10:56 <dolio> Which explains how to extract each of the coproducted monads into the extraction monad.
20:11:26 <dolio> So, if you extract some State monads into Identity, because you just want the results...
20:11:39 <dolio> Identity has no way to track the state changes itself.
20:12:00 <dolio> But the way coproducts work, you sometimes need to extract from the l monad to get a value to feed into the r monad.
20:12:40 <SamB> It ... doesn't sound as if they work ;-)
20:12:46 <dolio> And when that happens, you lose the state from l. And the only thing that can be done is start over with the initial state if you ever go back to l.
20:13:10 <dolio> So if you want to maintain state over multiple switches, you need to extract to a monad that can already track s *and* t states.
20:14:32 <dolio> And monad coproducts don't help you define that monad that does so, but monad transformers do exactly that.
20:15:47 <SamB> sooo ... coproducts of monads sound roughly useless ;-)
20:16:19 <dolio> Or, coproducts let you specify the monad, but not in a way that you can get stuff out of it.
20:17:20 <dolio> Well, they might not be useless, but they don't do the same thing as transformers, certainly.
20:17:40 <SamB> I'm not saying I much like what transformers do :-(
20:17:51 <dolio> You can, after all, interpret all monads into a sufficiently powerful delimited continuation + IO magic monad.
20:17:54 <T-Cell> mmarrow, when I run plotutils I get someting saying: Left "fd:7: hClose: resource vanished (Broken pipe)" ..what does this mean?
20:18:01 <SamB> but at least they build their own damn monad!
20:18:34 <SamB> T-Cell: maybe you are missing a unix tool or maybe it isn't working right?
20:18:36 <dolio> So you could write down your computations in a coproduct format (which might be a nice way to write them down), and then inject them into a master monad.
20:18:43 <T-Cell> hmm
20:18:49 <SamB> s/master/monster/
20:18:54 <arw_> T-Cell: is gnuplot installed and working?
20:19:22 <arw_> T-Cell: you can check by calling 'gnuplot' in a shell and trying e.g. 'plot sin(x)'
20:19:30 <dolio> It's kind of like monadic reflection, I guess.
20:25:15 <T-Cell> arw_ thanks, I just reinstalled ubuntu and it seems I lost gnuplot in the processes
20:28:22 <roconnor> losing gnuplot is probably for the best :P
20:28:35 <FunctorSalad> @tell path[l] http://arxiv.org/abs/cs/9903011
20:28:35 <lambdabot> Consider it noted.
20:28:40 <roconnor> oh wait, never mind me
20:29:03 <arw_> there is much worse than gnuplot, and not much that could be considered better.
20:29:22 <arw_> just try out http://root.cern.ch
20:37:27 <Axman6> arw_: root looks pretty cool :o
20:39:06 <arw_> Axman6: it would be, if it wasn't mostly interpreted c++
20:39:35 <Axman6> 0.)
20:39:39 <Axman6> o.O even
20:40:38 <arw_> Axman6: its some kind of mutant created by mad particle physicists of a plotting tool, a generalized class library, some particle physics libs and the unbelievable ugliness that is cint (the c++ interpreter)
20:41:05 <Axman6> >_<
20:41:12 <arw_> Axman6: the plotting tools are what everybody uses, and parts of the class library.
20:53:28 <mmorrow> T-Cell: that plotutils module uses "graph" (and if you uncomment the "spline | graph" part, "spline" too)
20:53:48 <mmorrow> T-Cell: which would be in the "plotutils" pkg most likely
20:54:22 <ezyang> There's gotta be a better way of doing this: handleIO GetLine = catchJust (guard . isEOFError) (return . Just =<< getLine) (const (return Nothing))
20:54:31 <mmorrow> :o
20:59:17 <mmorrow> T-Cell: this is a handy helper fun
20:59:20 <mmorrow> let graph f xs = zip xs (fmap f xs)
20:59:30 <ezyang> I just can't think of it
20:59:31 <mmorrow> e.g. ghci> plotutils emptyPlotConf $ graph sin (take 100 (iterate (+0.1) 0))
21:02:00 <mmorrow> plotutils emptyPlotConf $ graph (\x -> x * sin x) (take 400 (iterate (+0.1) 0)) -- oooh, aahhh
21:02:21 <ezyang> well, the first bit can be done as Just <$> getLine ^_^
21:02:51 <aavogt> @type catchJust
21:02:52 <lambdabot> Not in scope: `catchJust'
21:03:47 <ksf> and you can write const . return $ Nothing
21:04:05 <ezyang> sure
21:04:11 <ksf> if you then line up the opening parens, it actually looks quite fine.
21:04:19 <aavogt> @ty isEOF
21:04:21 <lambdabot> Not in scope: `isEOF'
21:04:27 <aavogt> @ty System.IO.isEOF
21:04:29 <lambdabot> IO Bool
21:04:54 <ezyang> This code is really bothering me: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9059#a9059
21:05:21 <ezyang> It's not quite obvious to me what I should do to it :-(
21:06:08 <ksf> don't give action and handle names.
21:06:39 <ksf> ...and don't bleeding use exceptions for control flow.
21:06:49 <ksf> they're for _abnormal_ situations.
21:06:54 <Zao> Exceptional, even.
21:07:27 <ezyang> ksf: So... I guess I want a new algebraic datatype?
21:07:29 <sohum> hm. how does haskell parse '-5'? is '-' a function, or is it part of the parsing code for numbers?
21:08:03 <ksf> well, you want to think less sequentially.
21:08:22 <ksf> it's a number.
21:08:36 <ksf> ...that's why (-5) 3 won't give you a 2.
21:08:50 <ksf> er wait.
21:08:53 <ksf> > -4
21:08:54 <lambdabot>   -4
21:08:57 <ksf> > -4 +2
21:08:58 <lambdabot>   -2
21:09:06 <ksf> > (-4) 2
21:09:07 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
21:09:07 <lambdabot>    arising from a use of syntactic n...
21:09:12 <ksf> > (+4) 2
21:09:13 <lambdabot>   6
21:10:16 <ezyang> ksf: What's the non-sequential technique for short-circuit execution?
21:10:39 <ezyang> (esp. when further steps of computation require previous results)
21:10:47 <ksf> you've got laziness, everything is short-circuit.
21:10:53 <sohum> right, so it doesn't violate the seeming impossibility of having prefix operators that don't start with letters
21:11:03 <ksf> ...if you don't explitiely sequence stuff.
21:11:22 <ezyang> Hm.
21:11:40 <ezyang> Well, I am in a monad...
21:12:06 <ksf> you're always in a monad, namely the IO one.
21:12:17 <ksf> ...that doesn't mean that you need to mention, or use it.
21:12:26 <ezyang> ok, lessee
21:14:51 <ezyang> So, procedurally, I want to retrieve a member and check their dues status.  Thinking in types, the return type is NeedsCollect (they haven't paid dues) | NeedsCreate (we couldn't find the member) | NeedsNothing.
21:15:06 <ezyang> I need to write a function that does this, I guess
21:16:00 <ksf> why do you need to create people?
21:16:16 <ksf> ...they can't have any dues when they don't exist, do they?
21:16:23 <ezyang> Because we have a very lax membership policy and anyone can show up and then have to pay dues
21:17:19 <ksf> well, that aside, if you handle that outside, you can just bog the funtion down to Member -> Amount
21:17:21 <ezyang> The use model is that I get a list of people who are at the meeting, and I run this program on those names to figure out if they need to be added to the db, or have dues collected from them
21:17:30 <ezyang> ksf: sure.
21:18:00 <ezyang> It's the outside bit that's bugging me
21:18:06 <SamB_XP> ezyang: what about spelling?
21:18:13 <ksf> divide+conquer: make your program easier by not handling everything at once.
21:18:16 <SamB_XP> and/or legibility?
21:18:36 <ezyang> SamB_XP: We have... special situations that make this work :-)
21:18:58 <ezyang> ksf: Ok, so let's treat that as Member -> Bool. I already have that function implemented
21:19:01 <SamB_XP> you all go by names like "Agent K"?
21:19:21 <ezyang> We have unique usernames, which I'm using as a primary key
21:19:30 <ezyang> If you don't have a username, we use your email address
21:19:30 <ksf> and then there's http://hledger.org/
21:20:03 <ezyang> I could have implemented this with grep/sed/awk/uniq/sort/etc
21:20:14 <ezyang> It's primarily an educational project for me and Haskell :-)
21:20:23 <ksf> every accountant would kill you for doing that.
21:20:25 <ezyang> which also happens to have some utility
21:20:33 <ezyang> :-P
21:21:51 <ezyang> anyway...
21:22:12 * ksf really recommends using hledger and just tossing together a task-specific frontend.
21:22:32 <ksf> ...as you can be sure that the accounting is right, then, no matter how buggy your program is.
21:22:33 <slehuito> Hi there! I have a small question regarding name qualification.
21:22:53 <slehuito> I have a program starting with directive "import Data.Text as T"
21:23:26 <ksf> ...you've got everything accessible without qualifier, with Data.Text as qualifier and with T as qualifier.
21:23:29 <ezyang> ksf: we don't actually do any accounting
21:23:43 <ksf> ezyang, you should.
21:23:49 <slehuito> When I use "length" unqualified, I get a compilation error from ghc, stating that there is an "ambiguous occurrence of 'length'"
21:24:08 <ksf> right, 'cos there's one in the prelude.
21:24:18 <slehuito> I'm surprised, since I would have thought that 'length' of Data.Text
21:24:45 <ksf> nah the prelude is imported implititely, unless you use -XNoImplicitPrelude
21:24:49 <slehuito> should not be reachable except with prefix 'T' (and, of course, full prefix 'Data.Text')...
21:24:53 <Asztal> importing it with an alias doesn't hide the names from it - you need import qualified for that.
21:24:58 <ksf> you can do import Prelude hiding (length)
21:25:11 <ksf> slehuito, then you'd have to use import qualified Data.Text as T
21:25:38 <ezyang> ksf: I can add a ledger backend later
21:25:38 <slehuito> @ksf: I cannot hide it, because I need both 'T.length' and 'Prelude.length'
21:25:39 <lambdabot> Unknown command, try @list
21:25:57 <ezyang> one of the conscious decisions I made going into this was to avoid, as much as possible, pre-built components
21:26:10 <ksf> ...well, use qualified, or import Prelude as P and use T.length and P.length
21:26:14 <ezyang> (obviously I'm using loads of modules, but ledger is in something of a different league)
21:26:20 <ksf> it's a matter of taste and module.
21:26:44 <slehuito> OK, thanks, I just forgot the "qualified" (which I put in my introductory sentence, so I had this in my radar somewhere anywya;-)
21:27:03 <T-Cell> mmarrow: I keep getting Left "fd:10: hClose: resource vanished (Broken pipe)" ..?
21:27:44 <mmorrow> T-Cell: what does "$ which graph" say?
21:27:51 <ksf> T-Cell, you're trying to close down a handle that has already been closed from the outside?
21:27:58 <mmorrow> T-Cell: also, what OS are you on?
21:28:23 <mmorrow> T-Cell: (and are you running this in ghci? or in a program with `main'?)
21:29:11 <mmorrow> T-Cell: i'm guessing you just don't have the "graph" program
21:29:41 <mmorrow> (in which case you could just use you package manager to install "plotutils")
21:30:28 <T-Cell> let graph f xs = zip xs (fmap f xs) in plotutils emptyPlotConf $ graph sin (take 100 (iterate (+0.1) 0))
21:30:35 <T-Cell> I'm using Ubuntu
21:30:41 <T-Cell> and ghci
21:31:57 <mmorrow> T-Cell: i mean run in bash "which graph"
21:32:19 <mmorrow> it's calling /usr/bin/graph (or wherever your graph prog is)
21:32:38 <mmorrow> http://www.gnu.org/software/plotutils/
21:33:16 <mmorrow> T-Cell: do you have /usr/bin/graph ?
21:34:22 <mmorrow> (one fedora) i'd do "sudo yum install -y plotutils"
21:34:29 <mmorrow> if i didn't have it..
21:34:43 <mmorrow> s/one/on/
21:35:30 <mjs22> On ubuntu it would be "sudo apt-get install plotutils"
21:36:20 <ksf> on gentoo it'd be emerge plotutils, and you wouldn't end up compiling it manually because your distro ships with a ten year old version.
21:37:00 <SamB_XP> ksf: which distro does ?
21:37:10 <SamB_XP> oldstable?
21:37:12 <mmorrow> :o
21:37:20 <ksf> ...compared to gentoo, every single one...
21:37:37 <mmorrow> ksf: what version does gentoo have?
21:37:38 <SamB_XP> *ten years*?
21:37:45 <ksf> 2.5.1
21:37:49 <T-Cell> mmarrow, my system wasn't up-to-date. It works now! Thanks a lot for your help
21:37:51 <ksf> flagged stable.
21:37:51 <SamB_XP> gentoo has the 2020 version or something ?
21:37:55 <mmorrow> [m@monire ~]$ graph --version
21:37:55 <mmorrow> graph (GNU plotutils) 2.5
21:38:04 <mmorrow> T-Cell: great! :)
21:38:11 <ksf> 2.5 is masked
21:38:23 <ezyang> Made a little more palatable: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9059#a9060
21:38:54 <ezyang> maybe you'll agree that the exceptional case is... exceptional!
21:39:34 * ksf still thinks a report generation function should only work on existing members.
21:41:06 <ksf> like this: give the program a list of present people, get a list of dues from disk, partition the present-people list in known and unknown, for the known ones, attach their dues.
21:41:32 <ezyang> ksf: Hmm, that's an interesting approach
21:41:39 <Gwern-away> http://www.reddit.com/r/AskReddit/comments/9hhyi/building_a_compass_belt/ <-- any hardware folks around who feel like dispensing some free advice?
21:41:39 <ksf> finally, and that's a whole different program, actually, take that list of people, get a list of dues from disk, and increase the due for everyone present.
21:42:04 <ksf> ...or rather do the latter before the former.
21:42:59 <ezyang> ksf: Well, this approach requires you to have read in all the people first (unless Haskell's laziness makes this not actually the case ^_^)
21:43:57 <ksf> so what?
21:44:16 * ezyang shrugs 
21:44:34 <ksf> unless we're talking about more than 1000 people, you don't even have to start to worry about reading in too many of them
21:44:55 <ezyang> Yeah, it's a specious performance concern
21:45:28 <ksf> ...and, at least if you've got a flat file, you're going to access the whole of it anyway, to find zlumba mgabe.
21:45:44 * ezyang nods 
21:45:54 <ezyang> Let's see how many lines of code I can chop off approaching it that way
21:46:41 <mmorrow> ksf: omg zlumba mgabe emails me all the time!
21:47:27 <mmorrow> ksf: he's always got some multi-million dollar stash he's gotta move asap
21:47:37 <ksf> well, just send back an offer to transfer $1 billion if he sends a thousand dollar...
21:48:07 <slehuito> I want to parse an UTF-8 encoded file.
21:48:07 <slehuito> Warning: I'm not very familiar with all haskell libraries, nor with hackage documentation, nor with hoogle, so I may have missed obvious APIs!
21:48:07 <slehuito> A sequence of 'Data.Text.ICU.Converter.open', 'Data.ByteString.Char8.read' and 'Data.Text.ICU.Converter.toUnicode' provides me with a 'Data.Text' value representing the contents of my file.
21:48:07 <slehuito> Then I'm ready to parse it, and thought parsec would be a good choice.
21:48:08 <slehuito> But I don't know how to use parsec with 'Data.Text', other than converting it back to 'String'.
21:48:10 <slehuito> Is this the way to go, or I am missing something obvious?
21:48:10 <SamB_XP> just make him pay his dues!
21:48:35 <ksf> string is utf-8
21:49:05 <ezyang> Ach hans! This looks like a... I don't know what this looks like?
21:49:10 <ezyang> It's a reduce of some sort?
21:49:23 <ksf> ...and a Char8 isn't the same as a Char, a Char is a unicode codepoint.
21:49:32 <ezyang> Oh I'm stupid
21:49:39 <kmc> ksf, how can both things you said be true
21:49:49 <ksf> ugh.
21:49:58 <ksf> by generously glossing over details.
21:50:04 <kmc> okay :)
21:50:46 <slehuito> ksf: 'string is utf-8': I'm OK with that, but that only means that converting back 'Data.Text' is "easy", not that I can get rid of it completely
21:51:02 <kmc> slehuito, you can use parsec to parse any type; instead of using Parsec.Char you'll have to define your own primitive parsers off Parsec.Prim
21:51:10 <ksf> parsec is parametrized over its input stream, isn't it?
21:51:11 <slehuito> I meant converting back 'Data.Text' to 'String'
21:51:11 <kmc> or hopefully find someone who's already done so
21:51:25 <Zao> slehuito: There's functions for that.
21:51:55 <Zao> http://hackage.haskell.org/packages/archive/text/0.4/doc/html/Data-Text-Encoding.html
21:52:10 <Zao> Erm, Data.Text.unpack
21:52:16 <slehuito> zao: I warned that I was not comfortable in finding the suitable functions through hackage docs + hoogle ;-)
21:52:28 <Zao> http://hackage.haskell.org/packages/archive/text/0.4/doc/html/Data-Text.html
21:52:50 <ksf> yep sure: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#t%3AStream
21:53:14 <kmc> it would seem that Char is already unicode and thus it's not meaningful to talk about the utf encoding used in String
21:53:38 <ksf> kmc, exactly.
21:53:45 <kmc> but i don't understand this stuff well enough
21:54:00 <ksf> but It should get serialized as utf-8.
21:54:10 <kmc> ksf, does that depend on locale settings?
21:54:10 <Zao> Char is an unicode codepoint.
21:54:14 <kmc> that's what i'm not clear on
21:54:18 <ksf> there's more to unicode than a bigger alphabet, anyway.
21:54:49 <ksf> kmc, no idea. I've got utf-8 shells...
21:55:52 <ksf> slehuito, you can implement parsec's "uncons" with text's "head" and "tail"
21:56:01 <slehuito> ksf: Is 'Data.Text' an already exisiting instance of parsec's 'Stream'?
21:56:03 <ksf> should be a straightforward instance.
21:56:07 <ksf> nope.
21:56:45 <ksf> ...well, you're going to need null, too.
21:57:31 <ksf> ...and note that Data.Text actually uses Char as its token type.
21:59:22 <slehuito> ksf: "'Data.Text' uses 'Char'": I know that, and realise that my question might have been simplified much, concentrating on 'Data.Text' and parsec. I apologize for bandwidth waste.
22:00:50 <ksf> instance (Monad m) => Stream Text m Char where uncons s = if null s then return Nothing  else return (Just (head s) (tail s))
22:00:54 <ksf> no bother.
22:01:36 <centrinia> If a module does not expose a function that I want to use, how can I use that function from GHCi?
22:01:39 <slehuito> Again, not being familiar with haskell libraries, I'm not sure which function I should implement to make Data.Text an instance of parsec's Stream
22:02:21 <ksf> centrinia, by being an evil hax0r and editz0ring the source.
22:02:35 <centrinia> Is there anything else that I can do? :(
22:03:03 <SamB_XP> centrinia: by deleting the .o file and loading it with a *?
22:03:49 <slehuito> ksf: you mean "return (Just ((head s),(tail s)))" [I think you forgot the ","]
22:03:49 <slehuito> This is getting about as ugly as Lisp code;-)
22:04:01 <Twey> return . Just $ (head s, tail s)
22:04:04 <ksf> slehuito, yes, that's a tuple there.
22:04:09 <Twey> return $ Just (head s, tail s)
22:04:14 <kmc> :t (\ (s) -> (Just ((,) (head s) (tail s))))
22:04:15 <lambdabot> forall a. [a] -> Maybe (a, [a])
22:04:44 <ksf> @pl return (Just ((head s),(tail s)))
22:04:44 <lambdabot> return (Just (head s, tail s))
22:04:57 <ksf> @pl \s -> return (Just ((head s),(tail s)))
22:04:57 <lambdabot> return . Just . liftM2 (,) head tail
22:05:07 <Twey> return . Just . splitAt 1
22:05:34 <ksf> Twey, that's a type mismatch.
22:05:36 <centrinia> @pl \s -> case s of { [] -> Nothing; (x:xs) -> Just (x,xs) }
22:05:36 <lambdabot> (line 1, column 17):
22:05:36 <lambdabot> unexpected "{"
22:05:36 <lambdabot> expecting variable, "(", operator or end of input
22:05:54 <centrinia> @pl \s -> case s of [] -> Nothing; (x:xs) -> Just (x,xs)
22:05:55 <lambdabot> (line 1, column 20):
22:05:55 <lambdabot> unexpected ">" or "-"
22:05:55 <lambdabot> expecting variable, "(", operator or end of input
22:06:38 <ksf> @pl \s -> (case s of [] -> Nothing; (x:xs) -> Just (x,xs))
22:06:38 <lambdabot> (line 1, column 21):
22:06:38 <lambdabot> unexpected ">"
22:06:38 <lambdabot> expecting variable, "(", operator or ")"
22:06:50 <SamB_XP> guys, I don't think @pl supports case
22:06:52 <centrinia> :t \s -> case s of { [] -> Nothing; (x:xs) -> Just (x,xs) }
22:06:53 <lambdabot> forall t. [t] -> Maybe (t, [t])
22:07:04 <centrinia> Damn, :(
22:07:38 <ksf> ...and you can't match on : as Data.Text isn't a list.
22:07:59 <ksf> ...if it were, there'd already be an instance.
22:08:28 <centrinia> Oh.
22:09:05 <Twey> ksf: Really?
22:09:18 <Twey> :t \s -> return (Just ((head s),(tail s)))
22:09:19 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m (Maybe (a, [a]))
22:09:23 <Twey> Ah
22:09:27 <Twey> ([a], [a])
22:09:30 <ksf> http://hackage.haskell.org/packages/archive/text/0.4/doc/html/Data-Text.html
22:09:30 <Twey> Damn
22:09:55 <Twey> return . Just . first head . splitAt 1
22:10:52 <ksf> arrows. again.
22:11:17 <ksf> using them as fmap for tuples is... abuse.
22:11:31 <Twey> Aw, c'mon
22:11:37 <Twey> It's practically the only practical use they ever see
22:11:40 <Twey> Let them have their fun :þ
22:12:43 <ksf> exactly. it's desecration of corpses.
22:13:20 <slehuito> I'm trying to make the Stream's instance.
22:13:38 <Twey> And hey, I'm not writing ‘(\(a, b) -> (a, f b))’ every time when I can just write ‘first f’.
22:13:47 <slehuito> From hackage, I see that Stream is defined in 'Text.Parsec.Prim'
22:14:08 <slehuito> But when I import that, ghc can't find module...
22:14:29 <Twey> You need a newer version of Parsec, I think.
22:14:45 <SamB_XP> parsec3
22:14:47 <Twey> Grab it with cabal-install.
22:14:57 <Twey> (or your OS's package manager)
22:16:39 <ksf> ...heck parsec3 is dated march 2008, shouldn't it be default by now?
22:17:19 <Gwern-away> too slow
22:17:26 <Gwern-away> might as well ask why qc 2 isn't default
22:17:34 <Gwern-away> THESE THINGS ARE MYSTERIES
22:18:35 <SamB_XP> ksf: well, I heard it broke lots of things ...
22:18:46 <SamB_XP> some talk has been talked about should maybe the package name be changed ?
22:18:57 <ksf> those things aren't mysteries. real mysteries look like that: a package depends by virtue of its dependencies on both quickcheck 1 and 2, how did the author ever get it to compile before uploading it?
22:19:18 <slehuito> I have parsec 2.1.0.1
22:19:26 <SamB_XP> ksf: is there some kind of ... conflict there ?
22:19:44 <slehuito> And it doesn't seem to have the Stream typeclass...
22:19:50 <SamB_XP> as long is it doesn't actually import them both or mix their types/classes ;-)
22:20:05 <ksf> yep, parsec2 works on lists only.
22:20:25 <slehuito> is this why parsec3 is "too slow"?
22:20:30 <Twey> ksf: I think people compile it by hand and forget to test the Cabal.  ;)
22:20:50 <ksf> parsec isn't slow.
22:20:55 <SamB_XP> and unfortunately hackage doesn't check that things actually build :-(
22:21:02 <Twey> Was that meant for Parsec3?
22:21:11 <slehuito> I don't know, I just read that 2 minutes ago! ;-)
22:21:13 * Twey demands elucidation from Gwern-away.
22:21:20 <ksf> ...while it's not primarily designed to be fast, it's designed not to be slow.
22:21:30 <Twey> Aye.
22:21:45 <Twey> As a result, it is reasonably speedy.
22:22:10 <ksf> if you are in desperate need for speed, chances are that you hand-write your parser, anyway.
22:22:39 <ksf> ...and then there's packrat libraries, and polyparse, and...
22:23:15 * ksf would love parsec to have polyparse's killer feature.
22:23:33 <ksf> ...writing parsers that depend on their own output.
22:23:34 <slehuito> No, I'm not in absolute need of extreme speed. Just wanted to know about Gwern-away's comment
22:24:06 <ksf> I guess he meant that somehow, people are slow to pick up the new version.
22:25:03 <slehuito> Ah, OK!
22:25:47 <slehuito> I'm certainly one of these slow guys (given the small time I can afford on using haskell...)
22:29:55 <slehuito> ksf: an example of unquestionable superiority of having a parser that depends on its own output (apart from antique Fortran variable name syntax that starts with its own length)?
22:31:02 <Gwern-away> SamB_XP: hackage can't check things build - too many FFI bindings too many platforms
22:31:06 <ksf> parsing ebml, where the semantic value of an element that isn't in the bypestream is the value it had at its last occurence in the bytestream.
22:32:06 <Gwern-away> at least, it can't check any more than it doe, and certainly can't reject based on build failures
22:33:47 <SamB_XP> Gwern-away: actually, it royally sucks at building
22:33:56 <ksf> ebml is fun, anyway.
22:33:57 <SamB_XP> way more than cabal-install, from what I hear ...
22:34:02 <Gwern-away> how so?
22:34:08 <ksf> I should finish my library some time.
22:34:15 <Gwern-away> I don't see any cases where it could do much better, except haddock failures
22:34:33 <Gwern-away> iirc if haddock errors even when configure & build/link work, hackage records it as a build failure
22:35:30 <SamB_XP> Gwern-away: I heard it picked package versions in an even dumber way than cabal-install
22:35:43 * Gwern-away doesn't know about that
22:37:19 <SamB_XP> well, you aren't here, so I'm not sure why I should care what you think ;-)
22:37:34 <ksf> portage supports changes in the dependency graph without changing the version number, btw.
22:37:46 <ksf> the gentoo guys make use of it quite a lot.
22:38:27 <Gwern-away> SamB_XP: that's prejudice!
22:38:41 <Gwern-away> those of us who are departed are deserving of respect! anything else is just lifist
22:38:41 <SamB_XP> gwern: actually, it's more of a joke!
22:39:06 <Gwern-away> we - we're *jokes*?
22:39:16 * Gwern-away departs in a huff. you'll be hearing from my lawyer
22:39:42 <SamB_XP> as long as he's away during the trial!
23:02:29 <|Steve|> I'm going to guess that http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf is not the final version of Wadler's paper.
23:03:55 <SamB_XP> why's that?
23:04:19 <|Steve|> It's rife with errors and at one points $Id$ has been expanded by cvs.
23:05:15 <SamB_XP> hmm, likely!
23:05:16 <|Steve|> Here Id : baastad.tex,v1.1.1.11996/02/2915 : 17 : 01wadlerExp is an unspecified type of identifiers.
23:05:32 <SamB_XP> ewww!
23:06:10 <SamB_XP> you know, $Id$ doesn't even render to anything that looks all that meaningful ...
23:06:21 <|Steve|> It's typeset like that because keywords like $Id$ get expanded to $Id: stuff$ and then TeX interprets it all as math mode.
23:06:32 <SamB_XP> yeah, I know ;-)
23:06:40 <Cale> Probably since it was published in a Springer journal, they didn't let him publish the final version on his website or something?
23:07:02 <|Steve|> Does Springer get the copyright?
23:07:03 <SamB_XP> he should never publish with Springer :-(
23:07:12 <SamB_XP> |Steve|: springer is very grabby :-(
23:07:16 <|Steve|> ah
23:07:33 <|Steve|> Well, the errors were really bugging me but then I got to that and I'm sort of stunned.
23:07:51 <Twey> Haha.
23:07:54 <Cale> I'm not sure about the details, but they have a rather expensive for-profit site where you can get the papers.
23:08:04 <|Steve|> I'm sure I have access.
23:08:41 <Cale> I think universities should wise up and realise that the publishing companies are obsolete already.
23:09:23 <SamB_XP> I think the writers should stop publishing with Springer :-(
23:09:27 <|Steve|> I dunno about that. I was reading the proceedings of Crypto'09 and they look a whole lot better than other conference proceedings.
23:10:55 <|Steve|> Presumably I have access to http://www.springer.com/computer/iacr+reading+room?SGWID=0-40753-0-0-0 since by attending Crypto, I joined the IACR.
23:13:11 <dancor> runInteractiveProcess can leave the process running after the main program exits?
23:14:57 <periodic> What's the idiom for doing a bunch of IO Bool tests, e.g. file exists stuff?  I feel like there should be a way to string that stuff together.
23:15:29 <kmc> :t (liftM and) . sequence
23:15:30 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
23:15:54 <|Steve|> :t sequence
23:15:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:15:55 <periodic> kmc, hehe, thanks.
23:16:04 <|Steve|> Ah.
23:16:17 <periodic> I never ran into sequence before.
23:16:32 <periodic> but it does just what I've always wanted.
23:24:53 <kmc> periodic, you're lucky, we were playing with this earlier :)
23:24:58 <kmc> also of note:
23:25:01 <kmc> :t sequence_
23:25:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
23:27:49 <|Steve|> Is that just sequence_ xs = do sequence xs; return ()?
23:27:56 <|Steve|> @src sequence_
23:27:56 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
23:28:12 <kmc> |Steve|, it doesn't build the list as it goes, so it's more efficient
23:28:32 <|Steve|> That looks backward to me.
23:29:06 <roconnor> > foldr (:) [] [a,b,c]
23:29:07 <lambdabot>   [a,b,c]
23:29:17 <Axman6> kmc: there's a good chance the list wouldn't be built with the first one i think
23:29:33 <roconnor> Axman6: it does :(
23:29:39 <Axman6> :(
23:30:00 <roconnor> or at least something stupid does
23:30:10 <|Steve|> > foldl (flip (:)) [] [a,b,c]
23:30:11 <lambdabot>   [c,b,a]
23:30:35 <|Steve|> Right, okay. That makes sense to me. Now foldr doesn't seem so backward. =)
23:30:55 <kmc> a rewrite rule for "sequence xs >> m => sequence_ xs >> m" would be valid, yes?
23:31:00 <kmc> i don't know if ghc has this rule
23:31:35 <roconnor> @src reverse
23:31:35 <lambdabot> reverse = foldl (flip (:)) []
23:32:05 <mrsolo> what is the name of that project that bundle ghc with few cabal projects?
23:32:36 <Twey> haskell-platform?
23:33:00 <mrsolo> thanks
23:46:04 <FunctorSalad> can ghc be trusted to discard all assertions with -O2? ;)
