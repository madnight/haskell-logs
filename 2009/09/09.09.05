00:14:54 <_Jordan_> Stupid question: I'd like to make all instances of a typeclass I made be monad instances... is that possible?
00:16:55 <ivanm> _Jordan_: you mean for your class Foo, you want to specify that only monads can be instances of Foo?
00:17:08 <ivanm> or automagically make all instances of Foo instances of Monad?
00:17:28 <ivanm> The former is easy; the latter AFAIK is not possible :(
00:17:46 <_Jordan_> the latter is what I wanted :\
00:22:11 <Saizan> _Jordan_: what you can do is write returnDefault bindDefault using your Foo class so that the instances will be simply instance Monad T where return = returnDefault; (>>=) = bindDefault
00:23:04 <ski> periodic : note that using `liftM and . sequence' on `[IO Bool]' will execute all actions, then call `and' on the resulting `[Bool]
00:23:31 <ski> ' rather than stopping to perform actions whenever any action return `False'
00:23:54 <periodic> ski: I was thinking about that.  In the past I've basically created an opperator that stops if it's left argument evaluates to IO False and executes the right only if the left is IO True
00:25:31 <periodic> I think I actually had something like IO Bool -> IO a -> IO (Maybe a)
00:25:39 <periodic> but that seems sort of specific.
00:25:57 <periodic> It ended up not being necessary for this project anyway.
00:27:33 <kmc> @pl let rep m = do { x <- m; when x $ rep m } in rep
00:27:33 <lambdabot> (line 1, column 16):
00:27:33 <lambdabot> unexpected "{"
00:27:33 <lambdabot> expecting variable, "(", operator, ";" or "in"
00:28:22 <periodic> :t when
00:28:23 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
00:28:24 <kmc> @pl fix (\rep m -> do { x <- m; when x $ rep m })
00:28:25 <lambdabot> (line 1, column 19):
00:28:25 <lambdabot> unexpected "{"
00:28:25 <lambdabot> expecting variable, "(", operator or ")"
00:29:23 <kmc> @pl fix (\rep m -> m >>= ((flip when) $ rep m))
00:29:23 <lambdabot> fix (ap (>>=) . (flip when .))
00:29:26 <_Jordan_> Saizan: in other words, I'd make each instance of Foo also an instance of Monad manually (albeit with only a couple lines of code)?
00:29:41 <kmc> wait, what's wrong with "instance (Foo a) => Monad a"
00:29:47 <kmc> it's not haskell 98, but GHC will let you do it
00:29:55 <periodic> Anyway, thanks for thinking about it.  I'm going to go to bed.  Happy hacking.
00:30:09 <_Jordan_> kmc: odd, thought I tried that and it whined
00:31:14 <Saizan> _Jordan_: yes
00:31:51 <Saizan> kmc: it overlaps with any other Monad instance
00:32:19 <|Steve|> I want to compute some values in an array, but it is easiest if I can change the elements of the array during this computation until I arrive at the final array that I want to be my output. It looks like runSTArray is what I want to use. Is there an example of that somewhere?
00:35:13 <|Steve|> Do I use newArray to create the array and then readArray/writeArray to update the values and then at the end use runSTArray?
00:36:13 <kmc> Saizan, you're right, it makes ghc unhappy about all monads in general :/
00:37:10 <Saizan> instance resolution never takes the context in consideration when deciding which instance to pick, it only checks it afterwards
00:37:47 <Saizan> that's to keep sane semantics for separate compilation
00:38:07 <kmc> grr separate compilation
00:38:32 <ski> |Steve| : i think so, yes
00:38:59 <|Steve|> ski: Okay, thanks. I'll give this a shot.
00:40:41 <ski> periodic : we have talked a bit in the paste about having a new class with a member of type `Branching f => f (a0 -> b) -> f (a1 -> b) -> f (Either a0 a1) -> f b' (alternatively `Branching f => f Bool -> f a -> f a -> f a') ..
00:41:34 <FunctorSalad> path[l]: yay, third place apparently http://www.codechef.com/problems/TEAMSEL
00:41:53 <FunctorSalad> but I kinda cheated, I read up the idea for the algorithm in a paper ;)
00:42:55 <FunctorSalad> path[l]: (and it's pure)
00:45:02 <dancor> it seems like ^C handling is a real mess in haskell
00:45:36 <ksf> wtf 0.3 secs?
00:45:41 <ksf> I don't believe that.
00:46:22 <FunctorSalad> path[l]: it seems one can only see the source for one's own submissions, so I pasted it here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9065
00:46:49 <dancor> or rather, System.Process is
00:47:16 <FunctorSalad> ksf: why not? if mildly optimized haskell runs in 2.01
00:48:36 <ski> @type either
00:48:37 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:48:38 <ski> @type liftM3 either
00:48:39 <lambdabot> forall a c b (m :: * -> *). (Monad m) => m (a -> c) -> m (b -> c) -> m (Either a b) -> m c
00:48:40 <ski> @type \f g -> fmap (either ((`liftA` f) . flip ($)) ((`liftA` g) . flip ($)))
00:48:41 <lambdabot> forall a (f :: * -> *) b b1 (f1 :: * -> *). (Applicative f, Functor f1) => f (a -> b1) -> f (b -> b1) -> f1 (Either a b) -> f1 (f b1)
00:50:31 * dancor tearfully switches to python for this command wrapper script
00:52:03 <ksf> are there any contstraints on libraries used?
00:53:25 <FunctorSalad> ksf: only ghc 6.6.1 builtin it seems
00:53:32 <ksf> oh.
00:53:39 <ksf> ...that'd explain the 2 seconds.
00:53:52 <Twey> dancor: HSH!
00:54:31 <ksf> ...even plain haskell is fine for shell stuff
00:55:02 <Saizan> we don't have the best API for signal handling..
00:55:02 <FunctorSalad> ksf: what do you mean? that ghc 6.6.1 is significantly slower?
00:57:10 <ksf> yep.
00:57:18 <Saizan> FunctorSalad: they implemented pointer tagging and new strictness analysis in 6.8 iirc, btw s/Map Int/IntMap/ should be an easy and effective optimization
00:57:40 <ksf> intmap is in 6.6, though.
00:58:08 <kmc> _Jordan_, Saizan, you can create a datatype to wrap values of your Foo class, and declare the wrapper class as a monad
00:58:46 <Saizan> kmc: yeah, like Control.Applicative does for Monad => Applicative, but i don't find that particulary nice to use
00:58:59 <kmc> yeah
00:59:14 <FunctorSalad> Saizan: it doesn't run correctly with IntMap. *rollseyes&
00:59:33 <Saizan> weird.
00:59:47 <kmc> wrapper type i meanht
00:59:55 <Saizan> FunctorSalad: what happens?
01:00:08 <dancor> Twey: oh maybe.  i don't know if that's lazy enough with output.  maybe i could also try installing a sigINT handler to hack around my gripes with System.Process
01:00:53 <dancor> or i could get lazy output with HSH a more explicit way
01:01:00 <dancor> instead of hGetContents blackmagic
01:01:28 <FunctorSalad> Saizan: hmm I think I misreplaced "fst . Map.findMax" with IntMap.findMax
01:01:33 <ksf> intersperse "" ?
01:01:40 <FunctorSalad> the latter just returns the value rather than the key it seems
01:01:44 <ksf> > intersperse "" "foo"
01:01:45 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
01:01:55 <ksf> > intersperse "" ["foo","bar"]
01:01:56 <lambdabot>   ["foo","","bar"]
01:02:04 <ksf> ah.
01:02:09 <ksf> empty lines.
01:02:13 <ksf> wicked bastard.
01:03:13 <FunctorSalad> (and IntMap.findMax isn't in 6.6.1 according to the doc)
01:03:39 <quile> anyone here who can help with an OSX question?
01:03:58 <Twey> Is it a Haskell OS X question?
01:04:10 <jethr0> is there a way to get ghc to output more compiler errors in one go. this piecemeal approach is getting rather old after a while
01:04:12 <quile> yeah, trying to get it working on OSX, having trouble with readline
01:04:53 <quile> Twey: is there a better place to ask a question about that?
01:04:57 <dancor> if you have forked threads then System.Exit doesn't actually work?
01:05:06 <Twey> No no, here's fine.
01:05:17 <Twey> Unless it's just that you can't get readline installed
01:05:17 * dancor explodes
01:05:23 <trzkril> quile: which ghc package are you installing?
01:05:24 <Twey> In which case I recommend ##macosx
01:05:25 <Saizan> dancor: you've to call it from main
01:05:49 <Twey> If it's actually GHC doing something weird, here's good, or #ghc.
01:05:50 <quile> i installed the osx "all-in-one" package from haskell.org for 6.10.4
01:06:20 <quile> it seems to work fine, but then when I try to install something with cabal, it yacks about readline
01:06:29 <Axman6> Twey: -#
01:06:33 <dancor> Saizan: is there a way to do it from a sigINT handler?
01:06:43 <Axman6> quile: do you have macports installed?
01:06:43 <quile> "configure: error: readline not found, so this package cannot be built"
01:06:47 <Twey> Axman6: Really?  You guys are Apple-approved?
01:06:52 <quile> yeah i just installed it
01:06:52 <Axman6> nope
01:06:58 <quile> then i did sudo port install readline
01:07:00 <Twey> Oh, well then.  :Ã¾
01:07:03 <quile> and it went off and built everything
01:07:04 <Axman6> but, it's #macosx nonetheless :)
01:07:12 <Twey> Right-ho.
01:07:30 <quile> but i still get the same error
01:07:34 <Axman6> quile: you might need to give the paths to readline
01:07:42 <quile> so i tried
01:07:52 <Axman6> with --extra-lib-dirs and --extra-include-dirs
01:07:58 <Saizan> quile: which package are you trying to install, btw?
01:08:01 <quile> i tried that, same thing
01:08:14 <Saizan> dancor: yes
01:08:14 <quile> Saizan: the twitter API bindings
01:08:46 <quile> ps. i'm on leopard, and have the xcode tools installed
01:09:08 <quile> sorry if i'm asking dopey questions... pretty new to the whole haskell thing
01:09:24 <Axman6> quile: are you in Leopard or Snow Leopard?
01:09:25 <Saizan> dancor: you use myThreadId, and use its result in the signal handler with throwTo
01:09:36 <quile> Axman6: leopard
01:09:47 <Axman6> good, ghc compiles fine on leopard :P
01:09:49 <mjs22> quile: what package are you trying to install with cabal?  I'd be curious to see what my system says.
01:09:56 <Axman6> you should be able to just use macports to install ghc
01:10:10 <Saizan> Axman6: ghc is already installed apparently
01:10:23 <Saizan> Axman6: ghc doesn't use readline anymore
01:10:31 <Axman6> yeah, but macports will install other things that are needed hopefully.
01:10:41 <Axman6> but yeah, probably not readline since it's not needed
01:10:41 <quile> mjs22: twitter
01:11:05 <quile> so would you guys recommend installing ghc from scratch using macports?
01:11:10 <Saizan> dancor: myThreadId should be called from the main thread, to clarify
01:11:21 <quile> i tried to keep it simple by using the pre-built one from haskell.org
01:11:29 <Axman6> quile: nah, you should be ok
01:12:01 <mjs22> quile: you shouldn't need to install from scratch with macports.  I haven't ever used macports and have been generally satisfied with the GHC installer from haskell.org.
01:12:08 <dancor> @hoogle ExitException
01:12:08 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
01:12:23 <quile> mjs22: ok, that's good to hear
01:12:31 <quile> but i'm still stuck... :(
01:12:41 <Saizan> quile: if you're sure readline is installed with its header files then the problem is making cabal find it
01:13:07 <quile> Saizan:  well it's in /opt/local/include and /opt/local/lib
01:13:13 <Saizan>     --extra-include-dirs=PATH      A list of directories to search for header
01:13:14 <Saizan>     --extra-lib-dirs=PATH          A list of directories to search for external
01:13:38 <Saizan> try using those two cabal install's options
01:14:08 <Saizan> and or -v3 to see how the check for the existence of the lib is failing
01:14:12 <quile> Saizan: yeah i did, same problem
01:14:14 <quile> :(
01:14:20 <Saizan> quile: -v3 then
01:14:24 <quile> ok lemme try that
01:14:56 * ksf once figured that the easiest way to end a multithreaded program is to have the main thread block on a tvar.
01:15:04 <dancor> Saizan: ty that worked
01:15:14 <Saizan> dancor: np
01:16:44 <quile> http://pastebin.org/15138
01:16:48 <quile> those are my errors
01:17:01 <FunctorSalad> ksf: ah didn't notice you meant me... empty lines, yes ;)
01:17:08 <quile> am i missing something obvious?
01:17:19 <mjs22> quile: I can reproduce that on one of my machines.  I'm trying to figure out how to fix it. :-)
01:17:29 <quile> mjs22: awesome!
01:17:34 <quile> i mean, damn!
01:17:35 <FunctorSalad> (they're mandatory)
01:17:37 <quile> :)
01:17:37 <ksf> don't we have haskelline for such cases?
01:18:05 <Axman6> ksf: TVar or MVar?
01:18:19 <Saizan> quile: it seems your version of readline is missing a "rl_begin_undo_group" function
01:18:27 <ksf> mvar I guess.
01:18:38 <quile> Saizan: i just installed it from macports directly
01:18:45 <quile> maybe versionitis?
01:18:47 <ksf> a TVar might just be overkill, but won't hurt either.
01:19:53 <ksf> quile, well, you _do_ have readline installed, it says so, but it's lacking a symbol.
01:20:25 <quile> yeah i see that; it's most likely a version issue
01:20:29 <quile> weird
01:20:48 <quile> i think i might have hit the wall on it for tonight....it's late here
01:20:57 <mjs22> yeah - if you untar the tarball for readline and give configure the --with-readline-includes and --with-readline-libraries options, the missing symbol is found.  so it's a matter of giving cabal the right arguments to pass on to configure...
01:21:29 <mjs22> the extra-include-dirs and extra-lib-dirs options do nothing
01:21:36 <mjs22> (in this case)
01:21:43 <Saizan> damn configure files
01:21:44 <quile> yeah that's what i found too
01:22:06 <artagnon> Just for kicks, I tried to do the qualification problems in Google Codejam 2009 in Haskell. Fortunately, I just about managed to qualify :p This is the solution to Problem A: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3515#a3515 -- I want to know if my code is extra long and complicated.
01:22:50 <quile> ok, so i should use cabal to install readline then?
01:22:50 <quile> just untar and use configure with those opts?
01:22:50 <quile> ( i mean, i should NOT use cabal to install readline then?)
01:22:51 <artagnon> The problems can be found on the Google Codejam 2009 website: code.google.com/codejam
01:23:00 <quile> mjs22 ^?
01:23:24 <mjs22> quile: not sure.  i'm digging around to see if it can be done the "right way".  :-)
01:23:32 <quile> ah cool
01:23:48 <mjs22> (this has been an issue I've hit before -- I've been meaning to figure it out for myself anyways for a while)
01:23:59 <quile> i need to take off :(
01:24:13 <quile> sorry, i know it's uncool to ask a question and then bust out...!
01:24:23 <Saizan> --configure-option=
01:24:27 <quile> i really appreciate the help
01:25:09 <mjs22> no problem
01:25:57 <Saizan> quile: cabal install readline --configure-option=--with-readline-includes=... --configure-option=--with-readline-libraries=...
01:26:02 <quile> dudes, it worked!
01:26:09 <Saizan> cool :)
01:26:12 <quile> hahahahaha i just tried that.... thank you guys so much
01:26:19 <quile> i can go to bed now :)
01:26:25 <mjs22> :)
01:26:26 <mjs22> cool
01:26:30 <Saizan> night :)
01:26:35 <quile> huge heap of thanks for the help
01:26:39 <quile> cheers!
01:26:52 <mjs22> i need to write that trick down myself.  that will fix a problem I've been having with another cabal package lately... :-)
01:29:00 <Saizan> i wonder why the enviroment variables are not sufficient in this case
01:34:23 <artagnon> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3515#a3517 is my solution to GCJ (Google CodeJam) 2009 qualification round problem A. How can I improve it (mainly on the simplicity scale)?
01:35:11 <Saizan> what should it do?
01:44:14 <Gwern-away> wait, how did I just upvote my own comment on reddit?
01:44:25 <Gwern-away> it's from a year ago...
01:44:48 <Gwern-away> hax! maybe I can boost my comment karma by upvoting everything more than a year old!
01:49:24 <Axman6> :)
01:50:33 * Gwern-away finds that getting to the page of comments more than a year old will take more than a few seconds, and gives up
01:50:37 <dolio> That sounds like a good use of your time.
01:58:05 <ksf> are there recordings of the icfp talks?
01:59:07 <jethr0> Gwern-away: were you so impressed with your comment that you just had to upvote?
01:59:19 <Gwern-away> jethr0: I was; I didn't even notice the nick
01:59:41 <jethr0> someone on the same wavelength as you, i guess ^_^
01:59:57 <Gwern-away> in every way possible
02:03:43 <dancor> every wave possible (groan-away)
02:09:22 <sohum> @pl \x y -> x . (y+)
02:09:22 <lambdabot> (. (+)) . (.)
02:12:47 <sohum> @pl \x y -> (x+) . y
02:12:47 <lambdabot> (.) . (+)
02:18:51 <ManateeLazyCat> @seen Saizan
02:18:51 <lambdabot> Saizan is in ##logic, #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan speak 43m 40s ago.
02:20:36 <|Steve|> \x y ->(x+) . y ==> \x y -> (.) (x+) y ==> \x -> (.) (x+) ==> \x -> (.) ((+) x) ==> \x -> ((.) . (+)) x ==> (.) . (+)
02:27:44 <dancor> i'm seeing weird behavior in lazily grabbing output from a haskell script vs a bash script doing the same thing: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=3518#a3518
02:28:26 <mauke> buffering
02:29:48 <ksf> I'm rather surprised that the shell script lags the string
02:29:50 <dancor> mauke: ah, ok.  i need to "hFlush stdout" after each line
02:30:06 <mauke> or change stdout's buffering mode
02:30:13 <ksf> oh wait it's the other way round.
02:30:28 <dancor> i had tried (hSetBuffering pOut NoBuffering) but i guess that's not how it works
02:30:29 <ksf> hSetBuffering stdout NoBuffering
02:30:42 <mauke> not NoBuffering :-(
02:30:55 <ksf> what else?
02:31:13 <mauke> LineBuffering
02:31:17 <ksf> Line's the default, and a small fixed-size buffer will be ignored.
02:31:17 <Geralt> Hi, why can't I write 5 * -3? Shouldn't unary minus take precedence?
02:31:25 <mauke> it's not the default
02:31:38 <|Steve|> > 5 * -3
02:31:39 <lambdabot>   Precedence parsing error
02:31:39 <lambdabot>      cannot mix `GHC.Num.*' [infixl 7] and prefix ...
02:31:43 <ksf> only for stdin?
02:31:46 <mauke> ksf: no
02:31:56 <|Steve|> > -3 * 5
02:31:57 <lambdabot>   -15
02:32:03 <dancor> if it were the default my thing would have worked
02:32:06 <dancor> heh
02:32:21 <ksf> there's no such thing as a unary minus.
02:32:22 <mauke> dancor: buffering behavior of stdout depends on whether it's connected to a terminal
02:32:25 <ksf> :t (-)
02:32:27 <lambdabot> forall a. (Num a) => a -> a -> a
02:32:32 <ksf> see, it's binary.
02:32:40 <mauke> > - (2 + 2)  -- ksf
02:32:41 <lambdabot>   -4
02:32:41 <Geralt> ksf: ok, thanks
02:32:53 <mauke> yes, there is, and it's hacked into the language syntax
02:33:03 <Geralt> so -3 * 5 is actually -(3 * 5)?
02:33:08 <mauke> dancor: if it's a terminal, it uses line buffering; otherwise, block buffering
02:33:16 <dancor> ah
02:33:34 <ksf> mauke, that's even more evil than I was aware of.
02:33:54 <ksf> I thought that hack was limited to parsing numeric literals.
02:34:01 <mauke> no, it's a "real" operator
02:34:27 <lilac> unary - is weird and has the wrong precedence
02:34:51 <mauke> my preferred solution: get rid of unary minus; rename "negate" to "neg"; add special syntax for negative literals, possibly -42
02:34:57 <dolio> > let f n = -n in f 5
02:34:58 <lambdabot>   -5
02:35:05 * ksf just ends up writing (-3) all the time.
02:35:43 <ksf> mauke, ack.
02:35:58 <ksf> if people don't want to use "neg", they can write 0 - ...
02:36:07 <Phyx-_> whoops
02:36:28 * Phyx- <3 services
02:37:03 <Saizan> ManateeLazyCat: pong
02:37:34 <dolio> There are probably some people who'd fight against that particular negative literal notation.
02:37:45 <dolio> Since 'x-1' becomes different than 'x - 1'.
02:38:02 <mauke> I consider that a good thing
02:38:04 <dolio> Or 'x -1' does, depending on how you handle things.
02:38:11 <lilac> dolio: it's not without precedent -- X.y is different from X . y
02:38:31 <mauke> because another change I'd like would be to allow - in identifiers
02:38:37 <dolio> I know, and some people aren't thrilled with that, either.
02:38:39 <Saizan> maybe we should just import the operator system from agda
02:38:42 <mauke> lisp-style-baby
02:38:54 <ManateeLazyCat> Saizan: Yesterday, you said can use `Map Tag Type` to implement Binary instance of typeclass, today i failed. For type "data Foo = forall a . FooClass a => Foo a", i need write "forall a . FooClass a => Map Tag a" ?
02:38:55 <ksf> maybe we should switch to sexprs
02:39:02 <ksf> lisp people don't bikeshed syntax.
02:39:04 <dolio> I do like - in identifiers.
02:39:06 <mauke> ksf: denied
02:39:48 <ksf> and we aren't even talking about comment, yet!
02:39:52 <lilac> ksf: maybe we should all write in core ;-)
02:40:01 <Saizan> ManateeLazyCat: no, you need a data FooDict = forall a. FooClass a => FooDict, Map Tag FooDict
02:40:25 <dolio> Just because some people can live with crappy syntax doesn't mean you can turn a community into such people by adopting the syntax. :)
02:40:41 <dancor> ksf: what does bikeshed mean; to overemphasize the trivial?  or the opposite?
02:41:05 <lilac> dancor: the opposite being to underemphasize the important?
02:41:10 <dancor> yes...
02:41:34 <dancor> i feel like i'm bikeshedding right now
02:41:37 <dancor> one way or another
02:42:06 <lilac> it's not so much about emphasis as about committee-mindedness
02:42:24 <ManateeLazyCat> Saizan: FooDict?
02:42:47 <dolio> "Bikeshed" is a reference to a parable where there's some proposal for a nuclear power plant or something, and the people on the committee approve the power plant as is, because they don't understand anything about it, but argue over what color to paint a bikeshed outside, because they can understand that.
02:42:56 <dancor> so lisp people do not "waste time on committees considering syntax"
02:43:22 <lilac> dancor: http://www.bikeshed.com/
02:43:29 <mauke> http://www.google.de/search?q=bikeshed
02:43:43 <dancor> mauke: you got me!
02:43:44 <lilac> dancor: lisp psople do not waste time arguing about what colour the parentheses should be
02:43:48 <Saizan> ManateeLazyCat: yes, it's like your Foo existential type, but it doesn't contain a value
02:44:34 <Saizan> ManateeLazyCat: it's a proof that there's a type that's member of FooClass, in a sense
02:47:37 <dancor> i was thinking today about how i don't really like non-infix functions that are intended to be used infix and named as such
02:47:56 <ManateeLazyCat> Saizan: But, Ghc will got error about FooDict: At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
02:48:14 <ManateeLazyCat> Saizan: If don't use forall'd type, why write it?
02:48:18 <|Steve|> dancor: Like `div`?
02:48:44 <dancor> |Steve|: i guess so.  i was dealing with slices on `isPrefixOf` when it hit me.
02:49:21 <benmachine> div 6 3 does what I expect
02:49:25 <dancor> div isn't so much named in a infix-specific way
02:49:26 <dancor> ya
02:49:30 <benmachine> isPrefixOf foo bar doesn't
02:49:39 <|Steve|> ah
02:49:46 <benmachine> it annoys me too
02:49:55 <benmachine> but what can be done?
02:50:16 <benmachine> you could do startswith = flip isPrefixOf but that seems redundant
02:50:34 <benmachine> (the idea then being that startswith "foo" is String -> Bool)
02:50:40 <dancor> well there could be a mandate to stop doing it in the future
02:50:54 <dancor> after a bikeshed committee ruled on the efficacy of such a mandate
02:51:02 <benmachine> what would you call the function though
02:54:57 * ksf is perfectly willing to drop unary minus alltogether, including as a prefix of a number literal
02:55:07 <dancor> hasPrefix?
02:55:12 <ksf> there's alway 0-42, and I'm fine with that.
02:56:04 <trzkril> ksf: it seems a bit odd two show negative numbers using a non-constructor function
02:56:29 <dancor> ya i heard show is supposed to make haskell code
02:56:43 <trzkril> or even worse: show them in a form that cannot be read
02:56:58 <ksf> using show to serialize is an abdomination, anyway.
02:57:28 <Jafet> ksf, -0.0 != 0-0.0
02:57:45 * ManateeLazyCat pasted "" at http://paste2.org/get/414265
02:57:46 <ManateeLazyCat> Saizan: For above code, how to implement `Map Tag Type` ? I can implement Tag, but don't know how to write `Type` to pass ghc.
02:57:46 <dancor> speaking of abomination
02:58:46 <ksf> ...maybe I'm just not too much of a mathematican to care about that.
03:00:29 <benmachine> in mathematics it's true, but not in IEEE
03:00:51 <benmachine> I mean in mathematics 0 - 0 == -0
03:01:07 <benmachine> but computers have negative zeroes
03:01:11 <Jafet> I suppose ieeeDouble-neg0 = -1.0 / (2.0 * 1.79769e+308)
03:01:21 <Zao> benmachine: Depending on type and moon phase.
03:01:26 <dolio> > 0 - 0 :: Double
03:01:27 <lambdabot>   0.0
03:01:40 <Jafet> Even integers in some languages are allowed to be -0 (sign-magnitude).
03:01:43 <Axman6> > (-0.0)
03:01:44 <lambdabot>   -0.0
03:01:51 <Jafet> Not sure if that is allowed by haskell.
03:02:00 <dolio> > isNegativeZero (0 - 0)
03:02:01 <lambdabot>   False
03:02:04 <benmachine> > unsafeCoerce (-1) :: Double
03:02:05 <lambdabot>   Not in scope: `unsafeCoerce'
03:02:08 <benmachine> :(
03:02:12 <Jafet> > isNegativeZero undefined
03:02:13 <lambdabot>   * Exception: Prelude.undefined
03:02:21 <Jafet> > isNegativeZero -0
03:02:22 <Zao> You don't have -0 in 2's complement, just 1's complement.
03:02:22 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
03:02:22 <lambdabot>    arising from the lite...
03:02:28 <Zao> And IEEE floats, of course.
03:02:36 <Jafet> Blah
03:02:51 <benmachine> Prelude Unsafe.Coerce> unsafeCoerce (minBound :: Int) :: Float
03:02:51 <benmachine> -0.0
03:03:11 <ksf> negative numbers are unimportant, anyway.
03:03:17 <Jafet> Haha
03:03:23 <ksf> did you ever see a sun with a negative number of planets?
03:03:31 <ksf> it's pure nonsense.
03:03:46 <dancor> ksfinitist
03:03:52 <Saizan_> ManateeLazyCat: give me a minute
03:04:09 <Zao> ksf: Zero is for the weak too.
03:04:15 <Zao> I mean, if you have nothing to count, just don't count it.
03:04:23 <sohum> and clearly, the complex plane is completely irrelevant as well
03:04:27 <ManateeLazyCat> Saizan_: Ok, thanks!
03:04:42 * benmachine declines to make an aviation joke
03:04:48 <ksf> zero is relevant, as you might actually just be denoting a container which could contain something.
03:05:00 <ksf> an empty box is distinct from no box.
03:05:06 <sohum> I mean, they /call/ it "imaginary numbers"!
03:05:10 <Jafet> Nonsense. Just use Maybe!
03:05:12 <ksf> ...not so much as in what you can take out of it, but still.
03:05:13 * Axman6 prefers the plain plane
03:05:20 <sohum> how important can it be if it's imaginary?
03:05:45 <dancor> god invented the octonions, the rest is manmade
03:05:49 <ksf> it's for people who like to swallow funny pills and flap their wings.
03:06:07 <ksf> ...and write long papers with many, many greek variables.
03:07:27 <sohum> sometimes, I've heard that they even use /roman/ variables
03:07:29 <Saizan_> ManateeLazyCat: the isntances of PageViewState are StringViewState and DiredViewState, right?
03:07:48 <EnglishGent> how about hebrew variables? or chinese ones?!
03:07:49 <EnglishGent> :)
03:07:55 <ksf> runes!
03:08:01 <Jafet> Latin!
03:08:01 <ManateeLazyCat> Saizan_: Yep.
03:08:16 <Jafet> Latin runes, the bane of mankind
03:08:23 <sohum> oh gods, chinese variables
03:08:37 <sohum> would that even be possible?
03:08:44 <EnglishGent> btw... (serious question) - is there somewhere I can get the source code for the standard prelude & libraries from? I am _not_ interested in the GHC source
03:08:51 <ksf> runes would really work well for sets of numbers, they look so uppercase.
03:09:02 <EnglishGent> I'm still learning the language - and I'd like to see if for the purposes of increasing my understanding :)
03:09:22 <ksf> the source is linked from the haddocks.
03:09:35 <EnglishGent> sohum - I dont see why not.. of course one would need unicode...
03:09:38 <ksf> ...which is probably the best way to browse the source, anyway.
03:09:56 <sohum> EnglishGent: well, not in a technical sense. In a readability/understandability sense
03:10:07 * ksf would be surprised if ghc couldn't cope with chinese variables, right now.
03:10:19 <benmachine> sohum: makes about as much sense as using aleph
03:10:41 <benmachine> ksf: the might be the wrong character class for use in variable names, though
03:10:57 <sohum> benmachine: oy! you will not say bad things about aleph!
03:11:02 <EnglishGent> ah - it's in the Haskell report as well :)
03:11:33 <benmachine> sohum: they both make lots of sense :P
03:11:50 <sohum> heh
03:12:10 <ManateeLazyCat> EnglishGent: Looking for Chinese people?
03:12:12 <ksf> > isAlpha 'ç§'
03:12:13 <lambdabot>   True
03:12:16 <ksf> see?
03:12:19 <benmachine> neat
03:12:34 <ksf> dunno what I wrote, though.
03:12:43 <benmachine> heh
03:12:48 <EnglishGent> I know a couple ManateeLazyCat :)
03:13:04 <ksf> possibly some dirty word if it's not used in the same context as in the wikipedia page...
03:13:06 <ManateeLazyCat> EnglishGent: I'm Chinese. :)
03:13:15 <EnglishGent> (though none of them currently use Haskell... one is just about to start a comp-sci degree though)
03:13:19 <Saizan_> ManateeLazyCat: something like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9066#a9066
03:13:22 <EnglishGent> oh - pleased to meet you ManateeLazyCat :)
03:13:41 <ManateeLazyCat> EnglishGent: å¾é«å´è®¤è¯ä½ . :)
03:13:44 <Saizan_> ManateeLazyCat: i actually have a type implemented you can use as a decent tag
03:14:20 <EnglishGent> I'm sorry - but I dont know what that means ManateeLazyCat :|
03:14:31 <ManateeLazyCat> Saizan_: Thanks, i looking your code.
03:14:43 <ManateeLazyCat> EnglishGent: It's mean: Nice to meet you. :)
03:14:50 <EnglishGent> likewise :D
03:15:07 <Saizan_> ManateeLazyCat: http://code.haskell.org/hbuild/Data/TypeId.hs
03:20:35 <Saizan_> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9066#a9067 <- using Data.TypeId, i also fixed a few typos
03:22:08 <ManateeLazyCat> Saizan_: Thanks, i read those.
03:23:05 <Saizan_> feel free to copy the Data.TypeId.hs module, even if i should get around to package this up as a library
03:23:44 <hackagebot> palindromes 0.1 - Finding palindromes in strings (JohanJeuring)
03:24:09 <ManateeLazyCat> Saizan_: I just use Int for test, i will make PageViewState instance deriving Typeable for unique Tag id.
03:24:59 <Saizan_> ManateeLazyCat: yeah, the problem is that TypeRep is not directly serializable nor an instance of Ord, TypeId implements that
03:26:25 <ManateeLazyCat> Saizan_: En, maybe TypeRep and Map is the problem i occur.
03:37:45 <Saizan_> ManateeLazyCat: you could use [(TypeRep,Exists PageViewStateDict)] and Data.List.lookup, it's O(n) but for small dictionaries it shouldn't matter
03:41:30 <ManateeLazyCat> Saizan_: I got "Malformed constructor result type: PageViewState s" when compile "Dict :: PageViewState s => PageViewState s"
03:44:45 <ManateeLazyCat> Saizan_: I can send you my project source code for test.
03:50:52 <ManateeLazyCat> Saizan_: You use PageViewStatDict to wrap insinstance constructor, then pick those constructor in `get` method of Binary.
03:51:28 <ManateeLazyCat> right?
03:52:44 <ManateeLazyCat> Saizan_: Nevermind, now i know how to write Type, please let me finish left work. Thanks for your time! :)
03:54:52 <Saizan_> ManateeLazyCat: ah, yeah, that was a typo on my part, it should be Dict :: PageViewState s => PageViewStateDict s
04:03:03 <mux> @pl \as bs -> f (x:as) bs
04:03:04 <lambdabot> f . (x :)
04:03:15 <mux> @pl \as bs -> f as (x:bs)
04:03:16 <lambdabot> (. (x :)) . f
04:04:36 <ManateeLazyCat> Saizan_: Oh yes! Works! Thanks you so much. You teach me a lots. ;-)
04:08:00 <|Steve|> The first is straightforward. The second... \as bs -> f as ((x:) bs) ==> \as bs -> (f as . (x:)) bs ==> \as -> f as . (x:) ==> \as -> (.) (f as) (x:) ==> \as -> flip (.) (x:) (f as) ==> \as -> ((flip (.) (x:)) . f) as ==> (flip (.) (x:)) . f ==> (. (x:)) . f
04:08:42 * ManateeLazyCat Saizan_ is a briliant Haskell star! 
04:10:23 <dixie> good morning.
04:11:07 <Axman6> evening dixie
04:12:03 <dixie> wrrrr
04:12:17 <gwern> Oh! I feel it. I feel the cosmos. The Saizan star came pointlessly back.
04:12:37 * ivanm idly wave's in dixie's general direction
04:18:15 <kashyap> Hi wonderful Haskellers :) ... I recently worked on building a diagraming utility in Haskell (to learn Haskell among other things) .... I wrote the program to generate png file using bytestring but looks like stArray would be better....can someone suggest a good resource to pick up starray
04:19:19 <Axman6> kashyap: have you used the ST monad before?
04:19:40 <kashyap> no Axman6 .. I have not
04:19:46 <Axman6> ok, sec
04:20:21 <Axman6> check out some of the examples on http://www.haskell.org/haskellwiki/Monad/ST
04:20:51 <Axman6> basically, it lets you write code with updatable variables, but from outside the monad, it's totally pure
04:20:58 <Saizan_> ManateeLazyCat: nice :)
04:21:11 <kashyap> cool ... thanks Axman
04:21:14 <kashyap> I'll check it out
04:21:19 <kashyap> signing out
04:21:25 <Axman6> hmm, i wrote those examples... they're not very good
04:21:38 <Axman6> kashyap: stick around and ask questions :)
04:21:58 <kashyap> will sure do .... will be back soon
04:38:54 <narasim_7> Hello... i am stuck with Chapter 10 of Real World haskell. I read up to the point where functors  but it seems to get complicated after that....any words of advice on how to go about studying this chapter....
04:39:24 <Axman6> what are you having problems with?
04:39:29 <Jafet> "Be strong, padawan"
04:41:46 <narasim_7> Axman6: after this point "Writing a functor instance for Parse" ...do u suggest reading monads chapter and coming back here.?
04:42:27 <Axman6> i can't remember if i've read that part. what's the Parse datatype look like?
04:43:03 <narasim_7> newtype Parse a = Parse {       runParse :: ParseState -> Either String (a, ParseState)     }
04:44:10 <Axman6> hmm, i have a feeling that showing you the answer then explaining it might be more helpful. would you like me to?
04:44:47 <narasim_7> Axman6: ok..
04:45:02 <Axman6> ok... no guarantees this will be right though :P
04:45:52 <ksf> functors are way easier than applicative functors are way easier than monads, which are trivial. you just have to unlearn that misassumption that you don't understand them.
04:46:09 <Axman6> fmap f (Parse p) = \x -> case p x of {Right (a,ps) -> Right (f a, ps); x -> x}
04:46:16 <Axman6> uh
04:46:36 <Axman6> the x -> x should probably be some other variable (like y -> y)
04:47:16 <Axman6> narasim_7: does that code make sense to you? i can put it on hpaste, and make it well formatted if you like
04:47:27 <narasim_7> ksf: ok..will give it a try again... going through some more articles and then coming back to this chapter again..hopefully i wll get it better ..thanks
04:47:34 <ksf> narasim_7, do you understand map, as in lists?
04:48:45 <ksf> the point is that you can do the same thing to arrays, to trees, and so on: changing the elements, but keeping the structure intact.
04:49:03 <ksf> ...and that's exactly what functors are about.
04:49:07 <narasim_7> Axman6: putting it in hpaste with a short explanation would help..i will anyway work on it and come back to u ..thanks
04:49:20 <narasim_7> ksf: map yes... i see..
04:49:44 <narasim_7> ksf: the datatype Parse is the one that , i guess made fmap complex for me
04:49:47 <Axman6> narasim_7: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9069#a9069
04:50:04 <Axman6> take a look at that, and see if you can make sense of it first
04:50:12 <narasim_7> Axman6: ok..
04:51:36 <ksf> the idea is to let the fmap instance change the a in "Parse a" to anything you want.
04:51:54 <narasim_7> Axman6: give me some 10 minutes..i will get back to u :)
04:52:01 <narasim_7> ksf: ok...
04:52:04 <Axman6> narasim_7: sure thing :)
04:52:24 <ksf> ...so your fmap takes the data structure apart and constructs it again, replacing the original a with the given function applied to it.
04:52:38 <Axman6> narasim_7: firstly though, do you understand what fmap is supposed to do? (in general, not just in this case)
04:55:08 <narasim_7> Axman6: yes ..
04:55:46 <Axman6> narasim_7: can you explain it? (being able to put ideas down in words is very useful for making sure you understand the ideas)
04:56:41 * ManateeLazyCat Bla, bla, bla, Happy in Haskell everyday ... :)
04:58:17 <narasim_7> Axman6: ok..something like ,if I have a container like data type like Maybe or [a] i can use the existing function that acts on "a" to be used on the container
04:58:39 <narasim_7> this function will modify the values of "a" in the container..
04:59:09 <Axman6> yep. it takes a function of type a -> b, and something of the form f a and turns it into something of type f b
04:59:16 <narasim_7> Axman6: this is the idea i had, from ksf's explanation i thought it was ok..
04:59:25 <ksf> :t fmap
04:59:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:59:33 <ksf> ...that proves your point.
04:59:47 <Axman6> for clarity: fmap :: (Functor f) => (a -> b) -> f a -> f b
05:00:33 <Axman6> narasim_7: oh and that code i gave you was slightly wrong, i should be instance Functor Parse where... not instance Functor (Parse a) where...
05:00:44 <ksf> ...instanced to your parser, that'd be (a -> b) -> Parser a -> Parser b
05:00:54 <philed> > 1 + 1
05:00:55 <lambdabot>   2
05:01:29 <philed> My lambdabot just responds with Terminated whenever I try to evaluate anything. Is there a compatibility issue with the latest version of GHC?
05:02:06 <narasim_7> Coming to Parse data type..its a function...and thats where using fmap for it made me confused...
05:02:08 * ksf long ago noticed that it's not a good idea to use a local lambdabot as evaluator.
05:02:18 <ksf> ...there's ghci for that, and lambdabot for @pl.
05:03:24 <philed> ksf: I'm trying to use it in an IRC channel.
05:04:05 <ksf> that function is called p in Axman6's code, and it gets applied... while \x -> and so on constructs a new one.
05:04:30 <ksf> Axman6, you _could_ have been mean and used (-> a) there...
05:04:46 <Axman6> eh?
05:05:05 <ksf> :t intOfDigit
05:05:06 <lambdabot> Not in scope: `intOfDigit'
05:05:16 <ksf> :t digitToInt
05:05:18 <lambdabot> Char -> Int
05:05:19 <Axman6> :t digitToInt
05:05:20 <lambdabot> Char -> Int
05:05:22 <Axman6> yeah
05:05:28 <ksf> :t fromIntegral `fmap` digitToInt
05:05:30 <lambdabot> forall b. (Num b) => Char -> b
05:05:42 <ksf> ...as function application is a functor like any other.
05:06:22 <ksf> but even that's not all of the fun that's to be had there.
05:06:24 <Axman6> ah yeah
05:06:35 <ksf> you see, that fmap above is equivalent to
05:06:41 <ksf> :t fromIntegral . digitToInt
05:06:42 <lambdabot> forall b. (Num b) => Char -> b
05:06:54 <ksf> which, ultimatively, means that map == (.)
05:07:12 <Axman6> i was thinking i could have just written the instance as: fmap f (Parse p) = \x -> fmap (\(a,ps) -> (f a,ps)) (p x)
05:07:22 <birdspider> hi, can someone explain me http://pastebin.org/15154 (sqrt $ length "foobar")
05:07:23 <ksf> they just specialized the former to lists and the latter to functions as not to confuse newbies, but I love to do that.
05:07:41 <narasim_7> ksf: ok..i see... yep..i get that :)
05:08:41 <Axman6> birdspider: sqrt takes something that is a Fractional
05:08:57 <Axman6> :t sqrt
05:08:58 <lambdabot> forall a. (Floating a) => a -> a
05:09:01 <narasim_7> ksf: Axman6 .. thanks for the explanations .. i will continue working on the remainder of the chapter.. and i should probably save this chat :)
05:09:04 <Axman6> oh, FLoating, sorry
05:09:15 <Axman6> birdspider: what type does length return?
05:09:19 <ksf> > sqrt . fromIntegral . length $ "foobar"
05:09:20 <lambdabot>   2.449489742783178
05:11:17 * ksf thinks he once saw an integer square root on the cafe, but is neither sure nor feeling like googling.
05:14:06 <birdspider> Axman6, ah ok thx, it is clear now
05:14:16 <Axman6> :)
05:14:28 <ksf> http://en.wikipedia.org/wiki/Integer_square_root
05:14:45 * ksf sets it on his to-be-implemented-on-the-type-level list
05:14:51 <Axman6> heh
05:15:37 <ksf> hey I don't even need division.
05:15:52 <ksf> uh sure I do.
05:16:56 <ksf> ...it's quite strange to define an _integer_ square root using fractions...
05:37:38 <FunctorSalad> "<ksf> ...it's quite strange to define an _integer_ square root using fractions..." why?
05:40:11 <burp> has anyone written a FFI to blowfish encryption here?
05:42:54 <ksf> ...do you want the argument where I'm using peano numbers to implement them, or bitching about having to do it on a micro without division?
05:43:35 <narasim_7> I am going through the fmap instance of Parse...Is this understanding correct?.. "fmap allows more control over how a function is applied to a type.Since functions also have type like data. I can choose have fmap instance of function type and control how other functions can be composed with my function"
05:43:57 <ksf> http://www.embedded.com/98/9802fe2.htm gives a possible answer, though.
05:44:44 <ksf> ...but the final algorithm won't work with peanos, either, as peanos don't use bases
05:44:51 <ksf> (or have an infinite base, or whatever)
05:45:36 <FunctorSalad> ksf: IIRC you can divide with newton iteration too
05:45:39 <FunctorSalad> ;)
05:50:10 <ksf> there's another problem, first.
05:50:17 <ksf> how do I get ghc to accept
05:50:21 <ksf> type instance Mul n (Succ m) = n `Add` (n `Mul` m)
05:50:31 <ksf> without going UndecidableInstances?
05:50:48 <Saizan_> you don't
05:51:37 <Saizan_> maybe if those were data instances..
05:52:03 <ksf> yep.
05:52:10 <dolio> You need total type families for that.
05:52:15 <dolio> And those haven't been made yet.
05:54:09 <dolio> At least, I think those'd be lax enough in their termination conditions.
05:54:28 <dolio> Now I'm not 100% sure.
05:55:19 <ksf> ...now I need to figure out how to actually use that code.
05:55:45 <ksf> all my other stuff is in type funs, and I can use undefined :: F X
05:56:01 <FunctorSalad> undeified
05:56:06 <ksf> (and Show instances for the base types)
05:56:50 <FunctorSalad> why are you using type-level programming for embedded stuff anyway? (not criticism)
05:57:35 <ksf> ...no I'm not doing embedded stuff.
05:58:03 <ksf> (though I did once earn my money writing games for java devices that don't have floats)
05:59:10 <jethr0> FunctorSalad: because all the computation is already done when the code hits the embedded device ;)
05:59:13 <ksf> ...what use is a data family that can _construct_ the computation for me, but not evaluate?
05:59:23 <ManateeLazyCat> Saizan_: What's the best place to do: "M.insert (typeIdOf StringViewState) Exists (Dict :: PageViewStateDict StringViewState) tagmap" ?
06:00:31 <Saizan_> ManateeLazyCat: you need parentheses around "Exists (Dict :: PageViewStateDict StringViewState)" there
06:00:45 <Saizan_> ManateeLazyCat: however that depends from your overall design
06:02:01 <ksf> *Type> b:: Mul Four Three
06:02:01 <ksf> 12
06:02:03 <ManateeLazyCat> Saizan_: I plan do above action when StringViewState loading.... Just do once...
06:02:14 <ManateeLazyCat> s/once/one times
06:02:39 * ksf hopes he can enable and disable undecidable instances on a definition-by-definition basis...
06:03:21 <Saizan_> ManateeLazyCat: yeah, the question is which part of your code should know which are the possible types to deserialize
06:04:59 <Saizan_> ManateeLazyCat: in my use case the tagmap is incrementally populated at runtime for example
06:07:02 <ManateeLazyCat> Saizan_: I want do insert action in Binary instance of StringViewState.
06:07:43 <ManateeLazyCat> Saizan_: instance Binary StringViewState where put (StringVieState s) = do ... Insert action ....
06:07:54 <Saizan_> ManateeLazyCat: that doesn't look feasible
06:08:19 <ManateeLazyCat> Saizan_: I failed just now.....
06:09:35 <Saizan_> ManateeLazyCat: do you have the code that interfaces with the deserialization somewhere public?
06:10:12 <burp> http://paste.railsbox.eu/show/lzdmXltQYfM8bLG0i2eJ/ <- can someone give me a hint how I can use this struct with hsc2hs/FFI?
06:13:42 <mmorrow> love 3-level deep nested foldl's :)
06:14:02 <ManateeLazyCat> Saizan_: I have below interface: class Typeable a => PageView a where pageViewState :: a -> IO PageViewRebootState "
06:17:27 <ManateeLazyCat> Saizan_: I do insert actoin in PageViewState instance of StringViewState....
06:17:31 <burp> data BlowfishCTX = BlowfishCTX { p :: [Word64], s :: [[Word64]] }
06:18:47 <ManateeLazyCat> Saizan_: But it will do again when instance method execute,  i just want do insert action one times.
06:19:53 <ManateeLazyCat> Saizan_: And i don't want write all PageViewState insance in one module for centralised control.
06:22:10 <ManateeLazyCat> Saizan_: Looks, i still need a centralised module to insert new tag/type for Binary.
06:30:29 * ksf tries to use an equality restraint in a type instance kind of like an pattern guard, but fears that won't work, at all.
06:32:33 <Saizan_> ManateeLazyCat: yeah, if you don't have anywhere else to put this initialization you'll end up needing that
06:33:02 <ksf> ouch. you can't even use equality constraints anywhere else than in contexts.
06:33:41 <Lemmih> burp: Perhaps you shouldn't marshal the struct into Haskell land.
06:33:44 <jjohnsson> I'm trying to implement a simple Runge-Kutta ODE solver. I create the resulting function by using take 1000 (getFunction (startvalue)), and getFunction is recursively implemented using the ode stepper, adding each step into a list (y : next y). This gives me a stack overflow when I take too many. Can somebody help? I'm really new at this.
06:34:03 <ManateeLazyCat> Saizan_: Bad, i really hate central control model for extension.
06:34:47 <burp> Lemmih: instead use mallocArray or something?
06:35:09 <burp> mallocArray 16 :: IO (Ptr Word64)
06:35:10 <Lemmih> burp: You could keep the entire struct in C land.
06:36:27 <ManateeLazyCat> Saizan_: I think about this way: when ghc compile module, change tagmap when scan speical sentance in some module. Example, StringVewState in StringView.hs, i write something in StringView.hs to make ghc do `insert` action to tagmap, then tagmap's value will initialization after compile complete.
06:37:06 <Saizan_> ManateeLazyCat: where do you create StringViewState values if not by deserializing?
06:38:15 * ManateeLazyCat pasted "PageView class" at http://paste2.org/get/414755
06:38:19 <ManateeLazyCat> Saizan_: Above
06:38:43 <jjohnsson> my getFunction is defined as getFunction :: (Floating a) => (a,a) -> [(a,a)]
06:38:43 <jjohnsson> getFunction (t,y) = (t,y) : getFunction (stepRK f h (t,y))
06:38:47 <Saizan_> that's the interface, you're not creting the values there
06:38:55 <MyCatVerbs> jjohnsson: care to hpaste, please? Probably you are just building up a too-deep thunk when you recurse. The fix will be to use seq to force the intermediate values while recursing.
06:38:58 <Saizan_> *creating
06:39:35 <jjohnsson> MyCatVerbs: how does hpaste work?
06:39:39 <MyCatVerbs> @where hpaste
06:39:40 <lambdabot> http://hpaste.org/
06:40:01 <jjohnsson> MyCatVerbs: thanks.
06:40:10 <MyCatVerbs> jjohnsson: It's just a normal pastebin. Better to use that than to dump large amounts of text into IRC.
06:40:15 <ManateeLazyCat> Saizan_: StringViewState in PageView interface that implement in StringView. I will create StringView in Page.
06:40:32 <MyCatVerbs> jjohnsson: I think you've already given enough information to fix your problem anyway, though. You just need to force the intermediate steps.
06:40:33 * ManateeLazyCat pasted "Page" at http://paste2.org/get/414760
06:40:48 <ManateeLazyCat> Saizan_: http://paste2.org/get/414760 is Page.
06:41:06 <MyCatVerbs> jjohnsson: At the moment, you're building up this huge thunk: getFunction pair = stepRK f h (stepRK f h (stepRK f h ... pair)))
06:41:17 <ManateeLazyCat> Saizan_: StringView is instance of PageView in data Page
06:41:36 <ManateeLazyCat> Saizan_: Have a little complicated.
06:41:46 <jjohnsson> MyCatVerbs: I guessed so. I just don't know what to do about it. will the documentation for seq help me? googling now.
06:42:20 <MyCatVerbs> jjohnsson: so the n'th list element has had (stepRK f h) applied to it n times. If you try to evaluate an element a few thousand into the list then the runtime stack will overflow doing the nested (stepRK f h) calls.
06:42:23 <Saizan_> ManateeLazyCat: do you have a repository so i can see the whole thing?
06:42:49 <MyCatVerbs> jjohnsson: The fix is relatively easy: just force the evaluation of the intermediate results. Like so:
06:42:59 <ManateeLazyCat> Saizan_: BTW, i can do insert action when StringViewState, but problem is there have many StringViewState, but just need insert tag/type one times.
06:43:09 <jjohnsson> MyCatVerbs: by the way, is using take and an "infinite" list function the "haskell way" to do what I'm doing?
06:43:14 <ManateeLazyCat> Saizan_: No, if you want, i can send you all source code of my project.
06:43:21 <MyCatVerbs> jjohnsson: getFunction (t,y) = t `seq` y `seq` ( (t,y) : getFunction (stepRK f h (t,y) )
06:43:22 <jjohnsson> MyCatVerbs: sorry, I'm interrupting.
06:43:56 <MyCatVerbs> jjohnsson: Nothing to apologise for. And yes, infinite lists are perfectly idiomatic in Haskell.
06:44:19 <MyCatVerbs> If you need a prefix of an infinite list, then you should indeed use take.
06:44:19 <ManateeLazyCat> s/when StringViewState/when StringViewState create.
06:45:15 <MyCatVerbs> If you're finding yourself writing (head (take 1000 list)), then you probably want to know about the (!!) function, which has type [a] -> Int -> a. (head (take n list)) is equivalent to (list !! n).
06:45:17 <jjohnsson> MyCatVerbs: thanks, that did it! :) now to read up a bit on when to use seq.
06:45:30 <Saizan_> ManateeLazyCat: you could check if the map already contains that tag and avoid reinserting if so
06:45:42 <Saizan_> ManateeLazyCat: it shouldn't be so inefficient
06:46:15 <MyCatVerbs> jjohnsson: I'd say "check the Haskell wiki page on stack overflows" but haskell.org seems to be dead.
06:46:25 <jjohnsson> MyCatVerbs: ok, that is useful, but in the end I want the whole function. at least right now.
06:46:47 <ManateeLazyCat> Saizan_: If i have 100 StringViewState object, i need check it 100 times even it don't need check after first insert.
06:46:50 <ManateeLazyCat> ?
06:47:43 <MyCatVerbs> jjohnsson: http://209.85.229.132/search?q=cache:http://haskell.org/haskellwiki/Stack_overflow&hl=en&client=firefox-a&rls=org.mozilla:en-US:official&hs=YhG&oe=US-ASCII&strip=1
06:47:47 <MyCatVerbs> jjohnsson: http://209.85.229.132/search?q=cache:http://www.haskell.org/haskellwiki/Performance/Accumulating_parameter&hl=en&client=firefox-a&rls=org.mozilla:en-US:official&hs=xhG&oe=US-ASCII&strip=1 too.
06:48:05 <MyCatVerbs> Sorry that the links are atrocious, but I figure Google's cache will be more useful to you than the dead site right now.
06:48:22 <Saizan_> ManateeLazyCat: heh, i guess so, maybe the idea of having some kind of preprocessor makes sense
06:48:32 <jjohnsson> MyCatVerbs: thanks!
06:49:19 <ManateeLazyCat> Saizan_: I can initialization tagmap value when compile?
06:51:34 <ManateeLazyCat> Saizan_: Just tell GHC, cache initialization tagmap value when compile insert, initialization tagmap value after compile complete? This preproceesor process can implement with GHC?
06:51:50 <greap> How would you get lines from a lazily read text file?
06:52:08 <Saizan_> ManateeLazyCat: if you create a preprocessor that finds PageViewState instances and creates a new module that exports the right tagmap it should work
06:52:29 <Saizan_> ManateeLazyCat: it's not anything ghc will do automatically for you
06:54:07 <ManateeLazyCat> Saizan_: "Preprocessor to finds PageViewState instance" is hard to implement?
06:54:16 <ManateeLazyCat> Saizan_: Any hint?
06:55:25 <MyCatVerbs> greap: contents <- hGetContents ; return (lines contents)
06:55:39 <MyCatVerbs> Er, hGetContents handle.
06:55:54 <MyCatVerbs> greap: or more compactly, (fmap lines (hGetContents handle)).
06:56:24 <SamB_XP> hmm, greap sounds like a golem (chimera?) of a datastructure...
06:56:37 * SamB_XP isn't sure he's got the right fantasy words ;-)
06:56:51 <Saizan_> ManateeLazyCat: you can use haskell-src-exts to parse the modules, though the problem is that it won't work well if the instances are defined in different packages for example
06:57:35 <MyCatVerbs> greap: But beware that hGetContents is reasonably dangerous, depending on what you need to do. It is very easy to leak file descriptors (handles only get properly closed when the string is completely consumed, which is awkward to guarantee!).
06:57:44 <Saizan_> ManateeLazyCat: the problem is more or less that haskell modules don't have inizialitations functions
06:57:56 <MyCatVerbs> greap: using hGetContents on a handle also means that you can't do anything useful whatsoever with that file handle thereafter.
06:58:13 <Saizan_> ManateeLazyCat: you need to analyze the tradeoffs, i'm not sure what's the best way to do something like this
06:58:19 <burp> haskell.org down?
06:58:46 <MyCatVerbs> greap: But for short scripts, reading config files, or anything else where you read some small constant number of files, it's usually fine.
06:58:55 <Saizan_> ManateeLazyCat: in my case i just pay the price of checking everytime if the tag has been already inserted, i'll need to check if it's too costly
06:59:17 <MyCatVerbs> burp: near as I can tell, yes. You can still get most of the content off Google's cache, fortunately.
06:59:28 <MyCatVerbs> (It's just infuriatingly awkward to do so.)
07:01:09 <Axman6> how nice. i just took this FFI example of how to make haskell using C and the FFI, and extended it so that the C used Apple's Grand Central Dispatch, without needing to change the haskell code at all
07:02:04 <ManateeLazyCat> Saizan_: BTW, i found in TypeId.hs, you use Data.DeriveTH, it generate deriving code when compile?
07:02:22 <Saizan_> ManateeLazyCat: yes, it generates the Binary instance for Rep
07:02:27 <Saizan_> ManateeLazyCat: it's in the derive package
07:02:59 <ManateeLazyCat> $(derive makeBinary ''Rep) is tell ghc generate code when compile?
07:03:19 <Saizan_> ManateeLazyCat: yes, it's using TemplateHaskell
07:05:49 <hackagebot> fclabels 0.4.1 - First class accessor labels. (SebastiaanVisser)
07:08:14 <greap> MyCatVerbs: So ByteString.Lazy is completely the wrong track?
07:10:56 <MyCatVerbs> greap: Nono, that may well be fine, depending on what you're doing.
07:11:38 <olsner> hmm, with TypeSynonymInstances, if the type synonym involves a forall and a context, it seems I get a type error rather than having the context propagate to the instances (which would've been convenient)
07:11:50 <MyCatVerbs> It's often quite a good idea to use ByteStrings for all IO, and then convert to other formats internally as necesarry.
07:12:42 <sclv> so here's a type family issue i don't really understand: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8973
07:13:37 <MyCatVerbs> Though if you're processing text (as opposed to just passing lumps of it around without caring what's in them much) then you'd probably be better off using a real text string type, like String or Data.Text.
07:13:51 <sclv> anyone have advice on if that should work or not?
07:14:40 <int-e> sclv: it should not work. you can't infer a from Bar a.
07:14:53 <greap> MyCatVerbs: I was only going for ByteString.Lazy becuse it mentioned that it was lazy.
07:14:55 <int-e> sclv: you could have Bar Int = Bar Double = Bool
07:15:15 <greap> MyCatVerbs: Are the other file functions just implicitly lazy?
07:15:19 <sclv> where am I trying to infer a from Bar a?
07:15:33 <int-e> sclv: in deciding which version of func2 to use.
07:15:41 <sclv> ah.
07:15:52 <sclv> but the code works without the type signature.
07:16:07 <int-e> nope. you can't /use/ gah
07:16:09 <sclv> also, i can't seem to give an inline type signature to func2 to force an instance.
07:16:17 <int-e> you can't use func2, in fact. at all.
07:16:28 <MyCatVerbs> greap: hGetContents and getContents are lazy; the actions of the same names in Data.ByteString.Lazy are lazy too; the rest (hGetLine, hGetChar and so on) are strict, safe and predictable.
07:16:39 <sclv> so the error is that the compiler should really reject it to begin with?
07:17:03 <int-e> it would be helpful if it rejected func2, yes.
07:17:47 <sclv> hmm... this has to do with type families being non-injective, right?
07:17:51 <int-e> sclv: now for solutions - one way is to use data families instead of the type families, for Bar and Baz. (or at least one of them)
07:17:58 <int-e> sclv: right
07:18:15 <int-e> sclv: that means you can have Bar a = Bar a1, but a /= a1.
07:19:27 <int-e> sclv: another way is to somehow "imprint" func2 with the type a - a common way being to add a dummy argument:  func2 :: a -> Bar a -> Baz a.
07:20:37 <sclv> hmm... that seems more pleasant.
07:20:57 <int-e> (oh, maybe I should write  Bar a ~ Bar a1  instead of  Bar a = Bar a1  to make the connection to the inferred type for  gah  clearer)
07:25:32 <olsner> and (Bar a ~ Bar a1) here means that the instance of Foo for a and a1 have chosen the same representation for Bar?
07:26:40 <Saizan_> olsner: yes
07:28:19 <olsner> re type families, what's the point of allowing a type class to say "data" - isn't it always better to use 'type' and let specific instances make the type synonym refer to a 'data' type if it wants to?
07:29:28 <Saizan_> the injectivity, maybe :)
07:30:08 <Saizan_> if Bar were a data family you could infer a ~ a1 from Bar a ~ Bar a1
07:30:12 <olsner> ah, if you say 'data' you know that no two instances have the same type?
07:30:24 <Saizan_> exactly
07:30:30 <sclv> int-e: thanks much for the advice
07:31:35 <olsner> is it possible to use newtypes instead of data?
07:31:41 <Saizan_> yes
07:31:55 <Saizan_> you can instantiate a data family with a newtype
07:32:01 <olsner> ah, sweet
07:39:12 * ManateeLazyCat Haskell explore my head everyday, but it's a really nice experience ...
07:40:25 <purplepenguins> :t all
07:40:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:40:39 <purplepenguins> :t any
07:40:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:40:44 <Athas> If I use the GHC parallelisation mechanisms to massively thread my code (say, hundreds of threads), will this generally result in a major performance regression on typical four- or eight-core chips?
07:41:23 <Axman6> nope
07:41:31 <SamB_XP> Athas: well, why are you splitting off the threads?
07:41:35 <Axman6> haskell threads aren't OS threads
07:41:38 <SamB_XP> just because it makes it easier to write ?
07:41:58 <SamB_XP> if so, that sounds fine as long as you have enough RAM
07:42:28 <Athas> SamB_XP: partially.  In general, because I want to see how it works and get used to that style of programming.
07:42:30 <Axman6> Athas: also, are you talking about parallelism or concurrency?
07:42:38 <Athas> Axman6: I am aware, but even userspace threads have some overhead.
07:43:05 <Phyx-> test
07:43:10 <Phyx-> ? 7
07:43:13 <Axman6> Athas: if you're talking about parallelism, then it's unlikely to slow things down, and will probably speed things up (unless you make it too parallel).
07:43:17 <Phyx-> > 7 + 9
07:43:18 <lambdabot>   16
07:43:19 <Axman6> test: failed
07:44:14 <Axman6> so Athas, which one are you taking about? parallelism, or concurrency?
07:45:18 <Athas> Axman6: sorry, parallelism.
07:46:34 <Athas> Well, it's a little more ambiguous, let me clarify:  can I write a very parallel GHC program that does not have very high overhead when run on not-very parallel machines?
07:47:04 <forgot> why do function names have to start with a lower case?
07:47:27 <Jafet> forgot, because they have to.
07:47:34 <Lemmih> forgot: Because that's the law.
07:47:44 <danopia> forgot, i forgot why
07:47:48 <Jafet> (Uppercase names denote types)
07:47:58 <forgot> oo ok
07:48:02 <olsner> (and type constructors)
07:48:06 <Athas> I like that rule.  I wouldn't have thought that before I tried it, though.
07:48:23 <SamB_XP> forgot: I guess the idea is to make it easier to tell if it's an equational function or just a data constructor at a glance?
07:48:27 <Jafet> I think it is a terrible rule, but then haskell does not offer much by way of syntax
07:48:30 <Makoryu> Athas: Haskell's parallelism primitives don't directly correspond to actual system threads, so the GHC runtime can determine how many real threads it should use to deploy a parallel program
07:48:53 <SamB_XP> just think how much dumber the syntax highlighting would be without the rule!
07:49:27 <Jafet> Ah, so it lets you use inferior editors to write haskell
07:49:31 <Athas> Makoryu: I am aware, but surely there is still an overhead for the user-space threads?  Is GHC very intelligent about managing it?
07:49:52 <SamB_XP> Athas: as long as your threads don't get stuck too often, your performance shouldn't suffer much for using a non-1000-core CPU ;-)
07:49:52 <Makoryu> Jafet: Would you rather we had to deal with the C situation, where any given identifier can be a type name, and you can't tell which is which without parsing the whole file and any relevant headers?
07:50:47 <SamB_XP> where by "get stuck", I mean "wait on a synchronization variable"
07:50:49 <Makoryu> Athas: I've heard that it is, yes. Haskell threads are very lightweight, and any Haskell thread can be dispatched to any OS thread, IIRC
07:50:55 <Jafet> A haskell editor should do that anyway, Makoryu
07:51:06 <Makoryu> Athas: I haven't taken advantage of this much, so don't quote me on that...
07:51:09 <Athas> Thanks, I'll probably end up doing some trivial benchmarks.
07:51:10 <Jafet> Otherwise it is just a text editor that decorates syntax
07:51:31 <Athas> I'll be taking a course on "extreme" multiprogramming, and I thought it'd be fun to convert the Python/CSP programs to Haskell and see how they work.
07:51:32 <SamB_XP> Athas: the main issues are (a) will they fit in RAM? and (b) how often do they need context-switch?
07:51:36 <SamB_XP> afaik
07:51:46 <SamB_XP> and actually (b) might not be much of an issue, not sure
07:59:19 <idnar> Makoryu: I thought you had to tell the runtime how many real threads to use
07:59:45 <jjohnsson> MyCatVerbs: you don't happen to have any nice pointers regarding the heap going enormous as well? :) the stack overflow is gone, and the speed is nice, but for a test where a function consisting of a 20 million element Double vector is created, it uses â700 MiB. I think that disproportionately huge.
08:03:22 <MyCatVerbs> jjohnsson: what are you storing your Doubles in? Haskell data types can have quite a bit of overhead.
08:03:30 <MyCatVerbs> Particularly on amd64.
08:03:34 <Makoryu> idnar: Do you? Hrm, that's really unfortunate
08:03:46 <idnar> Makoryu: as a command-line option, or whatever
08:03:57 <Makoryu> idnar: Yeah, probably a +RTS option
08:04:26 <MyCatVerbs> jjohnsson: IIRC, [Double] costs 40 bytes on amd64 (24 on i386) per element.
08:04:53 <jjohnsson> MyCatVerbs: the doubles are stored in a list of tuples. right now I'm investigating the influence of having lots of local "variables" inside a "let" in my stepper function.
08:04:56 <MyCatVerbs> jjohnsson: You may want to use some form of unboxed immutable arrays instead. I would recommend the uvector library.
08:05:00 <jjohnsson> I'm on an intel 32-bit proc.
08:05:15 <MyCatVerbs> jjohnsson: ah, the tuple constructor adds another 24/12 bytes of overhead too.
08:05:16 <Makoryu> jjohnsson: Oooh, boxed tuples
08:05:17 <jjohnsson> oh, I mean on an intel 64-bit proc, but compiling to 32. I think.
08:05:46 <jjohnsson> MyCatVerbs: ok, I'll check that out.
08:05:57 <MyCatVerbs> jjohnsson: The difference is how long a pointer is. Haskell data type overhead consists of a lot of pointers.
08:06:09 <Makoryu> jjohnsson: A common trick to reduce memory usage is to employ unboxed tuples, which are annotated using the MagicHash extension
08:06:26 <Lemmih> Makoryu: It's not that common.
08:06:43 <MyCatVerbs> Makoryu: er, unboxed tuples can't be sotred, only passed around, IIRC.
08:06:54 <MyCatVerbs> Using strict datatypes instead of lazy ones would help.
08:07:27 <MyCatVerbs> Using unboxed arrays, such as those provided by the uvector library or by Data.Array.Unboxed helps more.
08:08:47 <jjohnsson> So, I will have a number of state variables, each as a function of time. Should I pass them as a list of unboxed arrays when I'm iterating?
08:10:13 <jjohnsson> I mean, will that be good, performance wise?
08:10:32 <Botje> depends, what are you going to do with them?
08:11:16 <Saizan_> jjohnsson: to investigate memory issues you should start with the ghc heap profiling features
08:11:22 <Saizan_> ?google ghc profiling
08:11:23 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
08:11:23 <lambdabot> Title: Chapterï¿½5.ï¿½Profiling
08:12:20 <jjohnsson> What I want, in the end, are the state variables as functions of time, i.e. a number of vectors. I start out with state variables at the initial condition, then use an ode stepper to calculate the rest of the state variable values.
08:12:54 <jjohnsson> Saizan_: thanks, I'll look into that as well. lots of things to know about, obviously. :)
08:14:10 <Saizan_> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-compiler-options.html , http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html these are the most important bits
08:15:15 <dbbddbdb> dons: [RWH] [possible bug] Hi!  There is an unfinished phrase in http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html Â«That residual string will\nÂ»
08:18:12 <jjohnsson> does anyone know where to set the ghc flags for cabal?
08:18:47 <jjohnsson> it doesn't seem to use the alias I set for bash.
08:21:59 <jjohnsson> ok, my brain can't take anymore right now. :) thanks for all your help!
08:23:12 <Philonous1> Regarding STM, I fail to see how atomic transactions improve performance under heavy load (compared to traditional locking). Don't transactions get restarted constantly  when they compete for a resource? Is there even any guarantee that any one transaction will ever be able to actually commit their changes and not permanently be invalidated by faster transactions?
08:23:52 <Axman6> no. they get restarted when one of the variables they reference is modified
08:24:05 <sclv> Philonous1: livelock can be prevented depending on your restart strategy.
08:24:20 <Axman6> so, if something has failed, then it will sit there until it's possible that the thing that failed might not fail now
08:24:48 <Philonous1> Axman6: But if you have a flurry of short transactions, longer transactions will just starve, won't they?
08:24:49 <sclv> also, atomic transactions are a specification -- implementations can have lots of different operational characteristics.
08:25:06 <Axman6> Philonous1: probably. so keep them short and sweet ;)
08:25:33 <Lemmih> Philonous1: Yes, that's a well known issue.
08:26:57 <jethr0> how do i write that i don't care what state is being used? "fn :: forall b . StateT b IO Int"?
08:27:02 <Philonous1> Also, restarting transactions annuls all their previous computations, thus possibly wasting a lot of resources?
08:27:06 <jethr0> i'm currently getting an error for that
08:27:12 <lpsmith> STM case study versus traditional locking:  http://lambda-the-ultimate.org/node/3592
08:27:33 <Lemmih> Philonous1: Yes.
08:27:52 <Lemmih> Philonous1: Correctness is usually worth it.
08:28:10 <Lemmih> jethr0: StateT s IO Int.
08:28:39 <Botje> yeah. the forall part is implicit.
08:28:41 <SamB_XP> Philonous1: yeah, so whatever you can do to shift the restart as soon as possible, I guess you should do?
08:29:06 <jethr0> k, so lowercase types are always interpreted as "type variables?
08:29:36 <SamB_XP> jethr0: yeah
08:29:57 <kyagrd> jethr0: except for certain GHC keywords such as forall
08:30:19 <jethr0> and one more question. I'd like to structure my modules into subdirectories and use A.B.C. What would be the best way to import a module that lies in the directory above?
08:30:19 <SamB_XP> :t id :: forall -> forall
08:30:20 <lambdabot> parse error on input `->'
08:30:27 <SamB_XP> true ;-)
08:30:36 <Philonous1> I see. So STMs performance characteristics are yet again hard to reason about.
08:30:36 <SamB_XP> jethr0: you always have to use full paths
08:30:50 <jethr0> full paths?
08:31:01 <SamB_XP> you can't use relative imports like in Python
08:31:06 <SamB_XP> which is a good thing, really ...
08:31:30 <kyagrd> SamB_XP: well python is not a compiled language
08:31:50 <SamB_XP> ... because for the longest time, Python had no way to specify that an import was to be considered as absolute
08:31:51 <kyagrd> relative import is meaningful when the source script is the only way to import things
08:32:22 <SamB_XP> you just had to rely on there not being a sibling with the same name as any toplevel module you needed!
08:32:43 <jethr0> SamB_XP: not sure we are talking about the same thing. let's say i have a module A in director "Server". and a module "Common" in the "father directory" of "Server". Is there a way to include "Common" from module "A"?
08:34:14 <SamB_XP> jethr0: sure
08:34:18 <jethr0> how?
08:34:41 <SamB_XP> well, is the mother directory the root of your source tree?
08:35:19 <jethr0> is the root the directory i call GHC in or the directory where the Main module is???
08:35:28 <SamB_XP> jethr0: should be both
08:35:38 <SamB_XP> well, at least the latter
08:35:53 <SamB_XP> I would be sitting in there in ghci myself ...
08:36:17 <SamB_XP> ... anyway, if Common is in that directory, you just "import Common"
08:36:23 <jethr0> k, so everything is relative to the module containing "main", right?
08:36:41 <SamB_XP> jethr0: basically, yeah
08:37:08 <SamB_XP> and if you have a Server/B.hs, and you want to import that from Server/A.hs, you do "import Server.B"
08:37:20 <jethr0> not sure i like it. but it's easy enough to use, for now
08:37:43 <SamB_XP> I admit it does result in a lot of typing and/or copy+paste
08:37:48 <kyagrd> by the way one of the serious outdated error message of GHC is the pointer to the URL in the --help message
08:38:13 <SamB_XP> kyagrd: that's not an error message exactly, is it ?
08:38:20 <SamB_XP> patches welcome, too ;-)
08:38:26 <kyagrd> Oh, the help message I mean
08:38:46 <kyagrd> ghc --help gives users pointers to documentation http://www.haskell.org/ghc/documentation.html
08:38:53 <kyagrd> which do not exist
08:39:01 <SamB_XP> huh
08:39:12 <SamB_XP> maybe it should just tell them to google it ;-P
08:39:27 <kyagrd> I hope it gets fixed in ghc 6.12.x but I don't know if there is a ticket at all.
08:40:57 <burp> Ptr CUChar <- how can I peek data into this?
08:43:31 <Axman6> don't you poke data into things?
08:43:57 <burp> um yes ;)
08:44:03 <SamB_irssi> kyagrd: now, what should the URL be?
08:46:06 <kyagrd> SamB_irssi: latest doc is http://www.haskell.org/ghc/docs/latest/html/ but for each version it has something like http://www.haskell.org/ghc/docs/6.10.4/html/
08:46:08 <PetRat_> I'm trying to build qtHaskell on windows xp. I got it to work on one machine. Trying on a second machine. It gets all the way to compiling the examples, but when I run an example, I get an error message that says "the procedure entry point <long identifier> could not be located in the dll QtCore4.dll.
08:46:45 <PetRat_> What may be the issue here is that I had an older version of Qt installed (binaries/libraries only) before I installed and built the latest Qt from source.
08:47:37 <PetRat_> Does anyone know how a Windows program locates the dll? Is there a path variable? Is it in the registry?
08:48:06 <Jafet> Black magic
08:48:13 <SamB_irssi> kyagrd: so probably it should say http://www.haskell.org/ghc/docs/
08:48:22 <SamB_irssi> what did you say it says now ?
08:48:28 <Jafet> Actually I lied; the program directory is checked, then some system directories, then the black magic
08:48:56 <kyagrd> SamB_irssi: that's not user friendly since it just displays directories
08:48:59 <PetRat_> Jafet: what system directories? does installing Qt copy the dlls to these directories?
08:49:17 <Jafet> Have fun finding that out...
08:49:28 <burp> well, how do I poke data into "Ptr CUChar" then, I think there is missing a really good FFI tutorial
08:49:33 <SamB_irssi> kyagrd: oh
08:49:49 <PetRat_> I would uninstall and reinstall, but the older version of Qt didn't provide an uninstall link.
08:49:55 <burp> there are several examples that are too simple for real world, and the other stuff is already too complicated
08:49:59 <jethr0> burp: i think there's some FFI documentation around
08:50:03 <kyagrd> ghc --help in ghc 6.10.4 (and I think it is same for any 6.10.x) points to http://www.haskell.org/ghc/documentation.html which is obsolete
08:50:29 <Jafet> petrat, http://msdn.microsoft.com/en-us/library/ms682586(VS.85).aspx
08:51:41 <jethr0> not answering your question directly, but a decent introduction: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
08:52:08 <kyagrd> SamB_irssi: GHC source should have its version number so it wouldn't be hard to generate http://www.haskell.org/ghc/docs/[some version no.]/html/ for the --help message
08:52:26 <burp> jethr0: ok
08:52:31 <SamB_irssi> kyagrd: hmm, well, this is actually in a help file, and plus that wouldn't work very well for the HEAD :-(
08:52:37 <SamB_irssi> er, I mean, a text file.
08:53:21 <SamB_irssi> see ./ghc/driver/{ghc,ghci}-usage.txt in the GHC repository ...
08:53:37 <kyagrd> SamB_irssi: didn't know that was static!
08:53:52 <Phyx-> burp: http://therning.org/magnus/archives/315 and http://gamr7.com/blog/?p=66 were really usefull for me to understand how FFI works
08:53:52 <kyagrd> plain text file ....
08:55:15 <kyagrd> SamB_irssi: well, HEAD does not have its documentation on line on the ghc hompeage, since ghc hompage only has documentations for release versions
08:55:24 <SamB_irssi> kyagrd: true ...
08:55:30 <SamB_irssi> but it'd be nice to have it point at a
08:55:35 <SamB_irssi> URL that exists!
08:55:56 <burp> Phyx-: thanks, didn't know the latter one
08:56:00 <Phyx-> that's a luxury SamB_irssi :P
08:56:12 <SamB_irssi> kyagrd: we could point it at http://haskell.org/haskellwiki/GHC
08:56:19 <jethr0> burp: does "poke (p :: Ptr CUChar) (fromIntegral . Char.ord 'c')" work?
08:56:32 <jethr0> s/'c'/$ 'c'/
08:56:35 <SamB_irssi> well, probably add a www.
08:57:12 <jethr0> not sure how to get a CUChar, but my guess would be "casting" it from Data.Char.
08:57:19 <kyagrd> SamB_irssi: the wiki page only has linkes to the latest release
08:58:03 <kyagrd> SamB_irssi: So, it would be more accurate to just point to the hompage http://www.haskell.org/ghc and let the user find links to their release version download page for now.
08:58:03 <SamB_irssi> kyagrd: well, it seems nicer than http://www.haskell.org/ghc/download.html :-(
08:58:56 <burp> jethr0: yup, at least it compiles for now :)
08:59:41 <jethr0> the Char.ord might not be necessary, as Char is already integral, i think
09:00:19 <jethr0> and the ":: Ptr CUChar" was just for readability...
09:00:56 <SamB_irssi> kyagrd: okay, going with the stupid URL for now in the hopes that they'll put together a better page ...
09:01:04 <SamB_irssi> ... and change the URLs to match
09:03:32 <Axman6> > fromIntegral 'c'
09:03:33 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
09:03:33 <lambdabot>    arising from a use of...
09:04:47 <jethr0> hmm
09:05:34 <jethr0> makes sense, otherwise it wouldn't be closed. and 'a' + 'c' is also questionable ;)
09:11:43 <burp> and multiple chars?
09:11:55 <burp> ok pokeArray :)
09:13:00 <olsner> jethr0: it's an enum though, so you can use to/fromEnum (but that's exactly the same as ord and chr)
09:13:41 <jethr0> pokeArray
09:14:08 <jethr0> pokeArray ptr listOfElems
09:14:27 <jethr0> olsner: i think that's what i mis-remembered, thx
09:14:37 <SamB_irssi> kyagrd: okay, I sent a patch to cvs-ghc@haskell.org
09:14:50 <SamB_irssi> oh, he's gone
09:15:06 <burp> :t fromEnum
09:15:08 <lambdabot> forall a. (Enum a) => a -> Int
09:15:10 <burp> but it's still just Int
09:15:23 <EnglishGent> hi all
09:15:24 <burp> so fromIntegral is necessary
09:16:09 * EnglishGent is confused .. how does return know what type of Monad to return? I can do 'return 34' at the repl - and it's happy to do so
09:16:23 <olsner> it would've made sense to use Integer or integral in fromEnum I think ... no reason to limit enum values to an arbitrary word size
09:16:25 <Berengal> EnglishGent, at the repl it defaults to IO
09:16:29 <EnglishGent> ah!
09:16:32 <EnglishGent> ty :)
09:16:39 <Berengal> ... I think... or Identity
09:16:55 <Berengal> They're mostly the same if you're only using generic monadic functions anyway
09:17:14 <Saizan_> IO
09:17:19 <olsner> EnglishGent: in general "return 42" is in any monad (or all monads), and the usage decides which particular Monad you end up with
09:18:04 * EnglishGent has figured out basic monads (the practical use thereof) & is now wading through 'All About Monads' & trying to understand them more deeply :)
09:20:57 <artagnon> To solve Project Euler #31 (problem outline: form 2 pounds using any number of coins of lower denominations given a list of possible coins of lower denominations), I wrote this function: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3519#a3519 -- It works fine, but I want suggestions for improvements.
09:21:39 <artagnon> So denomCombs 200 [200, 100, 50, 20, 10, 5, 2, 1] works fine.
09:21:43 <EnglishGent> btw - is there a way to ask hoogle what types are instances of some class? how about what types are *just* instances of some class (i.e. instances of that class, but not of any subclasses) ?
09:21:44 <EnglishGent> :)
09:23:14 <Botje> "length xs == 0 " -> "null xs"
09:23:29 <artagnon> Right, changed.
09:23:34 <artagnon> anything else?
09:23:48 <artagnon> structurally, it's a double recursion in my head.
09:23:52 <Botje> and if xs is [], calling denomCombs ... xs will just go to the first case of denomCombs immediately
09:24:03 <Botje> so you might as well not call denomCombs there :)
09:24:43 <artagnon> Botje: oh right :p
09:25:29 <artagnon> New revision with these changes: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3519#a3520
09:25:32 <burp> yay my ffi stuff works!
09:25:44 <Botje> most people will write remaining `div` x as well, but that's a matter of aesthetics :)
09:25:52 <Botje> (esthetics?)
09:26:10 <artagnon> how does ghc implement it? Iteratively I hope... not using a huge recursive call stack I hope?
09:26:24 <Botje> ghc doesn't use call stacks.
09:26:34 <Botje> evaluation in haskell is graph reduction.
09:26:35 <artagnon> Botje: Then?
09:26:43 <artagnon> oh.
09:26:52 <artagnon> and where can I read about how that works?
09:27:06 <Athas> It's almost the same in practice.
09:27:24 <Botje> i found SimonPJ's book to be good in explaining that.
09:27:34 <Botje> @where ifp
09:27:34 <lambdabot> I know nothing about ifp.
09:27:36 <Botje> nope.
09:27:37 <artagnon> What? Typical call stack recursion and graph reduction?
09:27:44 <Botje> google for "implementation of functional programming languages"
09:27:57 <artagnon> Botje: oh right, I downloaded a paper on that. Reading.
09:28:49 <Botje> as for evaluation .. this is a tree computation, and you're walking it depth first
09:29:28 <Botje> i'm a bit too frazzled to examine it more in detail though
09:29:34 <Botje> still writing a research proposal :/
09:29:35 <artagnon> Botje: oh it's SimonPJ's. I just haven't got down to reading it yet.
09:30:05 <Botje> let me check my solution for #31
09:30:16 <artagnon> ok. So structurally, there isn't a better solution for #31 in Haskell, correct?
09:30:26 <artagnon> ok, sure
09:31:23 <Botje> there, i've annotated mine
09:32:02 <artagnon> b'cos this seems like a pattern. I used the same pattern to solve Google CodeJam 2009 qualification problem A: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3522#a3522
09:32:27 <artagnon> Botje: hey, yours looks MUCH better! :/
09:33:04 * artagnon analyzes what's wrong with his head
09:33:18 <Botje> mine is _shorter_
09:33:24 <Botje> i wouldn't say better :)
09:34:53 <artagnon> have a look at GCJ Problem A too... It looks like I've used the same pattern again for Problem C.
09:35:18 <artagnon> And I'm tempted to use the pattern for every problem I'm encountering now
09:35:44 <Botje> maybe i'll do that tonight.. I still have to reach my quota for today if I _ever_ want to get this thing done :)
09:36:51 <artagnon> ok, np.
09:37:26 <artagnon> btw, there was a link posted sometime back by someone that explains folds beatifully... foldl and foldr: I can't find that link again. Any clue what it might be?
09:37:54 <Vanadium> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29 ?
09:38:03 <Botje> http://www.haskell.org/haskellwiki/Fold # this one?
09:38:23 <skorpan> what is the proper name?  fold or reduce?
09:38:54 <Botje> i'd say fold(l|r)
09:39:26 <skorpan> well, so would i, but that's just because haskell names it that way :)
09:39:26 <artagnon> eh, no. It was someone's personal blog.
09:39:53 <artagnon> Just the difference between foldl and foldr.
09:39:55 <artagnon> damn
09:40:02 * artagnon searches through this web history
09:40:33 <skorpan> artagnon: do post the link if you find it
09:40:35 <Botje> i'd use reduce if the operation you're folding is symmetric
09:40:44 <Botje> but foldl|r if it's not
09:40:59 <artagnon> skorpan: Sure.
09:41:26 <artagnon> Botje: oh, ok. I've never actually used reduce before.
09:41:35 * artagnon looks at reduce
09:41:39 <Botje> reduce is just lispish for foldr ;)
09:41:59 <artagnon> oh :p
09:42:05 <artagnon> I love Common Lisp :D
09:45:28 <EnglishGent> hi artagnon
09:45:30 <EnglishGent> :)
09:46:03 <artagnon> Hi.
09:48:02 <carletes> Hi! I'm having troubles with Emac's haskell-mode. 'C-c C-=' does not seem to work for me: Emacs complains that 'C-c = is undefined'. Any clues?
09:49:15 <EnglishGent> hello carletes
09:49:44 * EnglishGent looks at his .emacs
09:50:08 <EnglishGent> which version of haskell mode are you using?
09:50:41 <jethr0> what happened to the Sudoku site on haskell? there's like a million solutions now *gasp*
09:51:17 <carletes> I just grabbed it from CVS. The first entry in the  ChangeLog is from 2009-02-02
09:51:25 <Phillemann> I've got an exception/threads problem, hope someone can help: http://codepad.org/BMEoSyei
09:54:07 <carletes> Regarding the 'C-c = is undefined': If I type Ctrl-c and then '=' (instead of Ctrl-c, and then Ctrl-=), I get the same message...
09:55:32 <skorpan> carletes: are you by any chance using emacs from a terminal?
09:55:38 <skorpan> terminals don't understand C-=
09:56:51 <EnglishGent> what does C-h C-c C-c C-= say?
09:56:55 <carletes> Yep, I'm doing a 'xterm -bg black -fg white -e "emacs -nw --no-splash"'.
09:57:39 * mux wonders if he should release all this to hackage : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9079#a9079
09:57:50 <mux> could it be useful besides when doing project euler? :-)
09:59:02 <carletes> C-h C-c gives me a view of the GNU GPL text, and then C-c C-=- gives me the usual 'C-c = is undefined'
09:59:34 <carletes> skorpan: Any ideas on how to overcome the terminal issue?
09:59:48 <trzkril> carletes: don
09:59:52 <skorpan> carletes: use emacs from a window
10:00:03 <EnglishGent> why not just run 'emacs >/dev/null 2>&1 &' & use emacs as an application
10:00:05 <skorpan> okay "window" was a bad choice of word.. use GUI emacs
10:00:08 <trzkril> carletes: don't put poor emacs in a little box ;)
10:00:54 <EnglishGent> emacs is a pretty good operating system... if only it had a decent text editor....
10:00:54 <skorpan> carletes: but of course you could see what command C-c C-= is bound to and just make a new keybinding to the same command
10:00:54 <EnglishGent> :)
10:01:01 <skorpan> EnglishGent: that's original
10:01:26 <skorpan> doesn't even make any sense (viper-mode)
10:01:31 <EnglishGent> :|
10:01:39 <EnglishGent> actually I like emacs skorpan - a lot :)
10:01:44 <carletes> trzkril: It must be the subconscious vi user in me, putting emacs in a box ;-)
10:01:57 * EnglishGent does wish for a better extension language than elisp though :|
10:02:09 <EnglishGent> mind you emacs-cl helps a lot there
10:02:13 <jethr0> what's wrong with "newtype BM = BM {runBM :: StateT MapType [a]} deriving (Functor, Monad, MonadState MapType)"
10:02:28 <jethr0> it says "Expected kind `* -> *', but `[a]' has kind `*'"
10:04:27 <jethr0> ahh, "[] a"
10:05:37 <carletes> skorpan, trzkril, EnglishGent: Just installed xemacs and C-c C-= works perfectly --- thanks for your help!
10:06:02 <skorpan> carletes: no problem, just remember that xemacs and emacs are two completely different applications ;P
10:06:04 <trzkril> carletes: uhm
10:06:08 <EnglishGent> a pleasure carletes - but be careful - there are subtle differences between xemacs & gnu-emacs
10:06:42 <EnglishGent> if it's doing the job for you fine - just letting you know in case you run into problems in the future :)
10:07:24 <carletes> Oops --- it's not xemacs, it seems: Just Emacs 22.1.1 with the GTK+ thingies.
10:07:36 <EnglishGent> ah - well then you should be fine :)
10:07:40 <skorpan> emacs 23.1 was released a while back
10:07:41 <ray> xemacs does not mean x11 emacs!!!!!!!!!!!!!!!!!!!!!
10:07:48 <carletes> Yeah, the vi subconscious, definitely ;-)
10:07:54 <ray> i can't put enought exclamation points on that
10:08:00 <ray> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
10:08:07 * Beelsebob ponders if ghc's parallelism stuff could be written to rely on grand central on OS X
10:08:08 <ray> > fix ('!':)
10:08:09 <ziman> > repeat '!'
10:08:09 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
10:08:10 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
10:08:18 <ziman> save yourself typing ;)
10:08:20 <skorpan> > fix ('!':)
10:08:21 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
10:08:23 <EnglishGent> yeah - but a lot of people (understandably) make that mistake ray - I did way back when I was first learning emacs
10:08:34 <ray> it's an easy mistake
10:08:38 <ray> hence the exclamation points
10:09:08 <EnglishGent> they should have called xemacs something different - xemacs vs emacs is like coke vs pepsi
10:09:38 <ray> emacs x
10:10:35 <EnglishGent> oh also (and I think the source of the decent text editor joke) - could we please have saner default keybindings? I know them now - but newbie friendly they are _not_
10:11:03 <Twey> EnglishGent: http://xahlee.org/emacs/ergonomic_emacs_keybinding.html
10:11:12 <Twey> I use these in all my applications now.
10:11:12 <EnglishGent> hi Twey :)
10:11:17 <Twey> Hey there
10:11:53 <EnglishGent> I've actually inducted a few more into the cult of emacs ... but I do have to warn them to persevere... I'm proud to notice they are now preaching the gospel to others though :D
10:13:26 <EnglishGent> ooh - looks interesting Twey - ta! :)
10:14:24 <Raevel> problem is not all other apps can be configured like that :-(
10:14:40 <Raevel> also i use dvorak
10:15:16 <Twey> Raevel: The layout is about position, not mnemonics, so it translates to any keyboard layout
10:15:20 * EnglishGent finds that an increasing amount of the stuff he uses winds up becoming part of emacs - actually the only 2 notable exceptions now are my web browser & my irc client
10:15:24 <Twey> Dvorak and Colemak versions are provided, too
10:15:27 <EnglishGent> and I'm planning to switch to erc soon :)
10:15:35 <Twey> (I'm a Dvorak-user, too)
10:15:43 * EnglishGent already made steps in that direction
10:15:49 <Twey> EnglishGent: I keep meaning to switch to erc, but every time I try, something stops me
10:15:53 <coco> Hi, what's the point of ReaderT?
10:16:01 * EnglishGent envies the Dvorak users :|
10:16:02 <coco> (Why not just use Reader?)
10:16:19 <Twey> Most recently, I can't figure out how to make the damn thing stop displaying my prompt in reverse-video teal, which is completely unreadable to me.
10:16:30 <Twey> coco: Well, sometimes you want to combine it with another monad.
10:16:37 <EnglishGent> what's stopped you Twey? (curious as to difficulties you've encountered)
10:16:39 <Twey> Maybe, maybe.  :Ã¾
10:16:46 <Raevel> i used erc for a while
10:16:51 <kmc> yay dvorak
10:16:56 <Raevel> as soon as a server times out emacs freezes
10:17:08 <Twey> Ew
10:17:16 <jethr0> coco, very light bindings. look at the "all about monads" example for an interpreter
10:17:33 <coco> jethr0: bindings?
10:18:05 <coco> jethr0: it doesn't mention ReaderT
10:18:14 <jethr0> http://www.haskell.org/all_about_monads/html/readermonad.html#example
10:18:21 <coco> Twey: yes, but why not just nest it?
10:18:37 <sjanssen> coco: ReaderT is a monad transformer, monad transformers let you compose monads
10:18:39 <coco> Twey: the other monad transformers actually give back something different than the nested type
10:18:40 <jethr0> ReaderT is the transformer version of the reader monad. i.e for stacking reader on top of other monads
10:19:09 <coco> I know about monad transformers. my point is that ReaderT isn't different from Reader
10:19:18 <coco> but StateT is different from State
10:19:28 <sjanssen> coco: the kind and instances are different
10:20:39 <sjanssen>     m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
10:20:43 <EnglishGent> Raevel :|
10:20:48 <EnglishGent> we need a multi-threaded emacs
10:20:50 <sjanssen>     m >>= k  = ReaderT $ \r -> do
10:20:50 <sjanssen>         a <- runReaderT m r
10:20:50 <sjanssen>         runReaderT (k a) r
10:21:21 <EnglishGent> instance Monad Emacs ....
10:21:22 <EnglishGent> :)
10:21:36 <Beelsebob> hands up who's compiled ghc on Snow Leopard?
10:21:53 <coco> ReaderT r m a  =  r -> m a
10:22:01 <coco> Reader r a  =  r -> a
10:22:31 <coco> therefore ReaderT r m a = Reader r (m a)
10:22:57 <coco> the same doesn't work with other monad transformers
10:23:51 <Beelsebob> bugger
10:23:57 <glguy> Beelsebob: I'm using the one compiled for Leopard
10:24:10 <Beelsebob> glguy: with the random options added to the script?
10:24:17 <glguy> yeah :(
10:24:29 <Beelsebob> glguy: yeh, the issue I have atm is that I want 6.11 to gain dynamic linking support
10:24:47 <Beelsebob> and I get back to the old errors when it starts the stage1 inplace compilation
10:24:49 <glguy> OS X support in GHC is second-class
10:24:56 <kmc> coco, maybe you have another type parametrized over monad transformers
10:25:07 <kmc> it seems for consistency it should exist even if just as an alias
10:25:14 <Beelsebob> is the correct response to make the same change to the inplace/bin/ghc-stage1 script and run make again?
10:25:45 <sjanssen> coco: try writing the ReaderT instance with the Reader type
10:27:59 <kmc> is there any support for type aliases in a let or where clause?
10:28:08 <Beelsebob> glguy: yeh :(
10:28:17 <Beelsebob> glguy: I suspect only because ghc-central don't have macs though
10:29:17 <sjanssen> kmc: no
10:31:02 <dumael> Beelsebob: are you compiling ghc with the defaults on SL?
10:31:27 <Beelsebob> dumael: I'm compiling it with -optc-m32 -opta-m32 -optl-m32  added to /usr/bin/ghc, do I need to add them as configure options too?
10:32:49 <dumael> you may do. gcc on SL compiles to 64bit by default. the setup of OSX on x86 is to presume it's 32bit.
10:34:23 <thoughtpolice> Beelsebob: Igloo has a mac
10:34:28 <thoughtpolice> Beelsebob: so does ChilliX
10:34:39 <Beelsebob> oh?
10:34:48 * Beelsebob wonders why the OS X builds always seem to lag
10:34:56 <thoughtpolice> Beelsebob: fwiw, my name is on the GHC trac ticket for osx64 bit support
10:35:04 <Beelsebob> \o/
10:35:17 <thoughtpolice> but I recently acquired a full-time job *and* school, and neither unfortunately intersects with haskell though :(
10:35:24 <Beelsebob> yep
10:35:26 <Beelsebob> :(
10:35:30 <thoughtpolice> but /me is pushing haskell at work
10:35:38 <thoughtpolice> 2 of my other coworkers are quite familiar
10:35:41 <thoughtpolice> bought RWH etc.
10:35:47 <Beelsebob> I'm seriously contemplating getting to know ghc if only to try and see what happens if you use grand central to organise threading
10:35:49 <thoughtpolice> and there are only 6 of us :)
10:35:57 * thoughtpolice plans domination
10:36:05 <Beelsebob> hehe, a cunning plan
10:36:06 <Beelsebob> >.>
10:36:14 * EnglishGent wonders if thoughtpolice has perfected his evil laugh yet :)
10:36:50 <thoughtpolice> i don't have a evil cat yet :/
10:39:06 <Beelsebob> thoughtpolice: you could always hire me, and I'll push Haskell in your workplace too
10:39:07 <Beelsebob> >.>
10:39:52 * EnglishGent gets thoughtpolice an evil cat :)
10:40:27 * EnglishGent is sick of working in Java, VB, etc... I'd much rather do commercial work in Lisp/Haskell/etc :|
10:41:26 <sjanssen> Beelsebob: grand central doesn't seem very applicable to GHC
10:41:51 <kmc> @hoogle (a -> b -> (a,c)) -> a -> [b] -> [c]
10:41:52 <lambdabot> No results found
10:42:46 <kmc> :t scanr
10:42:47 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
10:43:00 <Beelsebob> sjanssen: oh?  I would have expected it to be ideal reading bits about it... it seems to roughly equate to "oh hai, create a spark here and do it on another processor if you can"
10:43:10 <kmc> @djinn (a -> b -> (a,c)) -> a -> [b] -> [c]
10:43:10 <lambdabot> Error: Undefined type []
10:44:19 <glguy> How does cabal install happy work?
10:44:26 <glguy> I thought that it needed to be bootstrapped..
10:44:48 <sjanssen> glguy: presumably the generated Haskell is shipped in the tarball
10:45:15 <glguy> oh, maybe me past experience was via darcs
10:45:22 <sjanssen> Beelsebob: GHC already has abstractions for this
10:45:52 <glguy> sjanssen: Grand Central let's you manage threads for the whole compute
10:46:01 <glguy> rather than trying to make decisions in isolation for one program
10:46:12 <sjanssen> Beelsebob: sparks have interesting GC implications, do you think a C oriented API will work?
10:46:59 <Beelsebob> sjanssen: no idea, this is why I'm half tempted to stare at the code for a long time and see
10:47:04 <Beelsebob> (but only half tempted)
10:53:39 <kmc> anyone know the function i'm looking for above?
10:53:53 <kmc> a sort of stateful map
10:54:03 <mauke> :t mapAccumL
10:54:04 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:54:50 <dumael> Beelsebob: OpenCL is a lot, lot more interesting than Grand Central.
10:54:52 <kmc> mauke, thanks!
10:55:55 <Beelsebob> dumael: I thought that, until I started reading about grand central â but that's partly because I'm looking at it from the "I want to use that in my C/Obj-C code" side
11:00:50 <kmc> @src mapAccumL
11:00:50 <lambdabot> mapAccumL _ s []        =  (s, [])
11:00:50 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
11:00:50 <lambdabot>    where (s', y ) = f s x
11:00:50 <lambdabot>          (s'',ys) = mapAccumL f s' xs
11:00:51 <kmc> @src mapAccumR
11:00:51 <lambdabot> Source not found. Where did you learn to type?
11:06:15 <sbahra> What's up #Haskell?
11:10:30 <EnglishGent> hello sbahra :)
11:11:25 <ManateeLazyCat> EnglishGent: Hello
11:14:56 <Twey> Wey-aye, sbahra
11:16:20 <HugoDaniel1> hello
11:16:34 <HugoDaniel1> i really like the "scrap your boilerplate code" papers :)
11:17:22 <tew88> HugoDaniel1: URL?
11:17:58 <HugoDaniel1> http://www.cs.vu.nl/boilerplate/
11:23:10 <jethr0> yes, and quite a bit of progress has been made since those papers were written...
11:23:28 <HugoDaniel1> jethr0: where can i read about it ?
11:23:30 <jethr0> it's incredible what is possible within haskell's oh-so-strict type system
11:23:42 <HugoDaniel1> yes, indeed
11:23:47 <HugoDaniel1> dynamics were quite a suprise
11:24:04 <HugoDaniel1> i got to these papers because i was trying to understand what the heck is Data.Typeable for :P
11:24:06 <jethr0> HugoDaniel1: let me check
11:24:09 <HugoDaniel1> i still havent figured it out
11:24:16 <kmc> :t typeOf
11:24:17 <lambdabot> forall a. (Typeable a) => a -> TypeRep
11:24:24 <kmc> > typeOf chr
11:24:25 <lambdabot>   Int -> Char
11:24:32 <kmc> :t typeOf chr
11:24:33 <lambdabot> TypeRep
11:24:36 <HugoDaniel1> i use it
11:24:44 <HugoDaniel1> to find out what types my existential types are
11:25:10 <Vanadium> > typeOf undefined
11:25:11 <HugoDaniel1> and check if certain data constructors are present (by converting them to strings)
11:25:11 <lambdabot>   Add a type signature
11:25:25 <HugoDaniel1> but i find it awkward that i have to define a class of Typeable :/
11:25:33 <ManateeLazyCat> HugoDaniel1: You can use Typeable implement OOP inherit with Haskell style.
11:25:35 <mauke> you can just derive it
11:25:40 <jethr0> there's different approaches. uniplate was an alternative to SYB, but to be honest i can't find the relevant material right now
11:25:55 <Saizan> there's also the more recent multirec
11:25:56 <HugoDaniel1> mauke: ohh, nice :D
11:26:13 <ManateeLazyCat> HugoDaniel1: You just deriving Typeable with instance of class.
11:26:16 <HugoDaniel1> multirec
11:26:17 <HugoDaniel1> sounds cool
11:26:59 <kmc> i don't suppose there's a monadic equivalent of mapAccumL?
11:28:06 <Saizan> mapAccumL is mapM in the State monad
11:28:06 <BMeph> @go uniplate
11:28:07 <lambdabot> http://community.haskell.org/~ndm/uniplate/
11:28:07 <lambdabot> Title: Neil Mitchell - Uniplate
11:28:17 <ManateeLazyCat> HugoDaniel1: If you write "class Typeable a => Foo a where", then you can define common methods in Foo class, if you want implement SPEICAL methods in instance of Foo, you can use `cast` to implement it, similar OOP inherit, but more clear, and more Haskell style.
11:28:27 <BMeph> Ah, Haskell's own "red-headed stepchil;d". ;)
11:28:30 <Saizan> kmc: so you could use the StateT transformer
11:28:59 <ManateeLazyCat> HugoDaniel1: And for instance of Foo, you just add "deriving Typeable" after data define.
11:29:06 <kmc> Saizan, good suggestion
11:30:32 <sbahra> Hi Twey
11:30:36 <sbahra> and EnglishGent
11:31:06 <mmorrow> @type \f s xs -> runState (mapM f xs) s
11:31:07 <lambdabot> forall a s b. (a -> State s b) -> s -> [a] -> ([b], s)
11:31:14 <mmorrow> @type mapAccumL
11:31:15 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:32:45 <mmorrow> @type \f -> State (\x acc -> uncurry (flip (,)) (f acc x))
11:32:46 <lambdabot>     The lambda expression `\ x acc -> uncurry (flip (,)) (f acc x)'
11:32:46 <lambdabot>     has two arguments,
11:32:46 <lambdabot>     but its type `s -> (a, s)' has only one
11:33:04 <copumpkin> :o
11:33:06 <coco> Where is it said that an applied monad transformer returns a monad? (in terms of typeclasses)
11:34:07 <mmorrow> @type \f -> (\x -> State (\acc -> uncurry (flip (,)) (f acc x)))
11:34:08 <lambdabot> forall t b a. (a -> t -> (a, b)) -> t -> State a b
11:34:14 <coco> I'm looking for 'instance (MonadTrans t, Monad m) => Monad m'
11:34:23 <kmc> coco, i think those are per-transformer
11:34:28 <coco> sorry
11:34:36 <coco> I meant 'instance (MonadTrans t, Monad m) => Monad (t m)'
11:34:40 <kmc> not sure tbh
11:35:15 <sclv> coco: that instance doesn't exist in the standard mtl.
11:35:29 <mmorrow> @type \f -> uncurry (flip (,)) . runState . mapM (\x -> State (\acc -> uncurry (flip (,)) (f acc x)))
11:35:30 <lambdabot>     Couldn't match expected type `(a, b)'
11:35:30 <lambdabot>            against inferred type `a1 -> ([b1], a1)'
11:35:30 <lambdabot>     In the second argument of `(.)', namely
11:35:34 <coco> so the do-notation treats monad transformer as an extra case?
11:35:36 <sclv> (i don't think)
11:35:39 <sclv> coco: no.
11:35:47 <sclv> i mean there's a per-transformer declaration.
11:35:52 <kmc> coco, no, there is an instance like "instance (Monad m) => Monad (StateT s m)"
11:36:09 <kmc> which is nice and H98
11:36:17 <coco> ahh, I see, thanks
11:36:19 <coco> why is that?
11:36:25 <coco> I mean, why not do it in the general case?
11:36:29 <Makoryu> coco: Dude, do-notation always unsugars to the same operators (>>= etc.)
11:36:38 <Makoryu> coco: It's the operators that are overloaded
11:36:40 <mmorrow> @type [mapAccumL, \f s xs -> uncurry (flip (,)) (runState (mapM (\x -> State (\acc -> uncurry (flip (,)) (f acc x))) xs) s)]
11:36:41 <sclv> because there isn't always a simple way to write the general case.
11:36:41 <lambdabot> forall y b a. [(b -> a -> (b, y)) -> b -> [a] -> (b, [y])]
11:36:44 <coco> Makoryu: ok
11:36:45 <mmorrow> epic
11:36:59 <coco> so what's wrong with 'instance (MonadTrans t, Monad m) => Monad (t m)'?
11:37:14 <kmc> coco,  how do you implement return and (>>=) in that instance?
11:37:21 <coco> :)
11:37:34 <sclv> look at the instances that exist and you'll see the pattern.
11:38:02 <ManateeLazyCat> Saizan: If i write Show/Read instance for "data Foo = forall a . FooClass a => Foo a", it can redure instance of FooClass automatically ?
11:38:20 <sclv> in each case you need to run the specific transformer for bind, and then run the internal monad, but it needs to happen slightly differently.
11:38:32 <sclv> there are other models of doing monad transformers where more general instances can be used
11:38:50 <Saizan> ManateeLazyCat: redure? however Show/Read has the exact same problems as Binary
11:39:11 <ManateeLazyCat> Saizan: Oh, bad.
11:39:21 <kmc> ManateeLazyCat, you can write a Show instance for Foo. if the code for your instance happens to use "show" on the wrapped value, it'll need a (Show a) => constraint
11:40:07 <ManateeLazyCat> Saizan: If so, Binary is simpler and faster.
11:40:55 <ManateeLazyCat> kmc: No, you haven't understand what's i mean.
11:41:20 <ManateeLazyCat> kmc: I know how to write Show for instance of FooClass.
11:42:40 <ManateeLazyCat> kmc: Question is if i write Show instance for instance of FooClass, i need some centralised control all instance of FooClass for match exactly.
11:43:20 <ManateeLazyCat> kmc: And centralised control id bad to extension.
11:44:56 <kmc> i don't understand.  is this perhaps a problem on the Read side, where you need to take a generic FooClass value and specialize it down?
11:44:57 <Philonous1> @tell ski Here's the junction code, if you're still interested. I cleaned it up somewhat and added a monad interface: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9083#a9083
11:44:57 <lambdabot> Consider it noted.
11:46:17 <ManateeLazyCat> kmc: Yep, i need handle special value.
11:49:13 <kmc> ManateeLazyCat, seems impossible to avoid having a list of all the FooClass types somewhere.  you need to check each parser / tag / whatever in turn
11:50:23 <ManateeLazyCat> kmc: Yes, i have use `Map Tag Type` for list all the FooClass types in one module, and it can work, but this pointer a centralised control model.
11:51:58 <ManateeLazyCat> kmc: So I need modified this centralised module whatever i add new types.
11:52:04 <kmc> ManateeLazyCat, maybe Template Haskell can help
11:52:35 <kmc> i don't know if TH allows you to compile-time introspect on the list of instance declarations
11:53:05 <mmorrow> it doesn't, but you can get that info easy enough with the ghc-api
11:53:20 <mmorrow> (the only thing is that the answer depends on which modules happen to be in scope)
11:54:12 <ManateeLazyCat> kmc: I talk with Saizan before, the only solution is do some preprocessor in compile-time that scan all instance of FooClass then export `Map Tag Type` in single module.
11:56:21 <mmorrow> ManateeLazyCat: that sounds like the cleanest solution to me
11:56:52 <mmorrow> ManateeLazyCat: (assuming that you're not already linked to ghc, in which case you may have other options)
11:57:29 <ManateeLazyCat> mmorrow: Those instance is split in many files, not in single files.
11:57:50 <mmorrow> ManateeLazyCat: with haskell-src-exts, some code that scans a module and pulls out all the instances of FooClass should be pretty easy
11:58:51 <ManateeLazyCat> mmorrow: Looks now i need build road when i want drive car, maybe this is space car that too new to old road. So i need build new road..... :)
11:59:09 <mmorrow> ManateeLazyCat: awesome :)
11:59:57 <mulletron> in ghci your default syntax is do notation, so I can write a let binding thats in the scope of subsequent lines, but when I try to do this in hugs it gives me a syntax error, is there a way to do this in hugs?
12:03:36 * ManateeLazyCat I will ask in here when i occur problem with haskell-src-exts
12:06:20 <EnglishGent> hello again ManateeLazyCat :)
12:06:27 <ManateeLazyCat> EnglishGent: Hello
12:06:40 <ManateeLazyCat> EnglishGent: Now i have time, you have time? :)
12:09:35 <EnglishGent> wb artagnon :)
12:09:47 <artagnon> :)
12:09:56 <artagnon> bloody browser's crashing :|
12:14:42 <stanv> dons:
12:21:16 <EnglishGent> yes ManateeLazyCat :)
12:21:55 <Elly> a lazy cat will eventually be fine too
12:27:29 <mmorrow> ManateeLazyCat: here's a repo with an example of how to extract instance info from a haskell module with haskell-src-exts http://moonpatio.com/repos/hs-instances/
12:28:39 * ManateeLazyCat Emacs crash again, i really hate it, even i love it so much before.
12:28:48 <ManateeLazyCat> mmorrow: Thanks, i will look it.
12:29:35 <mmorrow> ManateeLazyCat: (it's using the other program `hstidy' to then parse the Show output of the instance info, and then parse it again to prettyprint it..)
12:30:11 <mmorrow> but hs_instances.hs is the relevant part (although hstidy.hs is super handy :)
12:30:41 <ManateeLazyCat> mmorrow: I think my problem simple than that, In fact, it just do something Template work.
12:31:02 * ManateeLazyCat pasted "template work" at http://paste2.org/get/415070
12:31:04 <ManateeLazyCat> mmorrow: Above
12:32:02 <mmorrow> ManateeLazyCat: you could transform that info that hs_instances.hs extract into template-haskell syntax, or just transform it into whatever datatype you'll be using for the "instance dictionaries" in each and then prettyprint *that*
12:32:29 <mmorrow> *.. for the "instance dictionaries" in each _module_ and then...
12:33:17 <mmorrow> oh perfect, yeah you could just spit out that exact code from hs_instances.hs instead
12:33:25 <kmc> can i declare a record field to be anonymous, so there's no warning about unused fields?
12:34:22 <mmorrow> just filter the instance info inside hs_instances.hs to only pick up the classes you're interested in, then generate a (Map TypeId (Exists PageViewStateDict)) and prettyprint it
12:35:11 <mmorrow> ManateeLazyCat: this is the relevant type constructor from haskell-src-exts http://hackage.haskell.org/packages/archive/haskell-src-exts/1.1.4/doc/html/Language-Haskell-Exts-Syntax.html#v%3AInstDecl
12:35:52 <kmc> :t intercalate
12:35:53 <lambdabot> forall a. [a] -> [[a]] -> [a]
12:35:59 <jjohnsson> does anyone have pointer to how to create the contents of an Array recursively, i.e. using a function on an element to create the next element? None of the examples I've found match what I want to do, and I can't figure it out myself, it seems.
12:35:59 <thaldyron> kmc: I don't think so, you can only switch the warnings off globally with -fno-warn-missing-fields
12:36:07 <kmc> thaldyron, thanks
12:36:28 <mmorrow> ManateeLazyCat: (you could also use template-haskell, but you'd still be using the same idea/code, just adding the translate-to-TH part on the end)
12:37:40 <ManateeLazyCat> mmorrow: Thanks for your url, i will looking it deeply. :)
12:37:43 <sjanssen> jjohnsson: you could use listArray and iterate?
12:37:49 <mmorrow> ManateeLazyCat: no problem :)
12:38:44 <sjanssen> > listArray (1, 26) (iterate succ 'a')
12:38:45 <lambdabot>   array (1,26) [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h...
12:38:56 <sjanssen> jjohnsson: ^^^ something like that?
12:39:40 <jjohnsson> sjanssen: that looks like what I want. and it gives me an Array type?
12:39:46 <sjanssen> jjohnsson: yep
12:40:42 <jjohnsson> sjanssen: thanks a lot. trying.
12:40:47 <byorgey_> jjohnsson: you can even do things that explicitly do indexing into the array to compute other elements.  it's a great way to do dynamic programming without having to worry about the order in which the elements get computed.
12:41:48 <byorgey_> > let arr = array (1,26) ((1,'a') : [ (i,e) | i <- [2..26], let e = arr ! (i `div` 2) ] in arr
12:41:49 <lambdabot>   <no location info>: parse error on input `in'
12:41:57 <byorgey_> > let arr = array (1,26) ((1,'a') : [ (i,e) | i <- [2..26], let e = arr ! (i `div` 2) ]) in arr
12:41:58 <lambdabot>   array (1,26) [(1,'a'),(2,'a'),(3,'a'),(4,'a'),(5,'a'),(6,'a'),(7,'a'),(8,'a...
12:42:15 <byorgey_> not a very interesting example, perhaps, but that's the idea =)
12:43:21 <byorgey_> lazy evaluation will take care of evaluating the elements in a suitable order.
12:43:35 <sjanssen> this trick won't work with unboxed arrays, however
12:43:47 <jjohnsson> byorgey_: sorry, I don't quite get the point. I'm quite new to this and am trying to parse this strange syntax and function names. :)
12:43:55 <byorgey> sjanssen: true.
12:45:02 <jjohnsson> I got the advice to use unboxed arrays today, since I was concerned about memory consumption. I will need the contents of the whole array anyway for my purposes, so it's no big loss. however, I didn't manage to convert my code from lists to Arrays yet; working on that.
12:45:46 <byorgey> ah, ok, if you need unboxed arrays, then you can't do what I wrote anyway.
12:46:19 <Lemmih> > let fibs = array (1,100) ((1,1):(2,1):[ (n, fibs!(n-2) + fibs!(n-1)) | n <- [3..100]]) in fibs
12:46:22 <lambdabot>   array (1,100) [(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34),(10...
12:46:29 <byorgey> but if the pattern of the elements is regular, like in sjanssen's example, you can compute a list of the elements first (using whatever sorts of recursive methods you want), and then convert to an array with the 'listArray' or 'array' functions.
12:49:03 <jjohnsson> byorgey: I'm planning to use quite large array structures later on, so I'm concerned that method would require too much memory. I'm doing an experiment trying to rewrite my Matlab code, lots of fun. :)
12:49:19 <lispy> has anyone tried scion yet? I'm going to set it up now...
12:50:01 <byorgey> jjohnsson: I don't think it would necessarily require a lot of memory.  Remember, because of laziness, it's likely that only a small part of the list will ever be in memory at once.
12:50:25 <byorgey> jjohnsson: it wouldn't construct the whole list in memory before using it to create the array.
12:50:57 <jjohnsson> byorgey: ok, see what you mean.
12:51:18 <lispy> jjohnsson: often times haskell is so different than other programming languages that a direct translation yield code that is slow or memory inefficient
12:51:44 <lispy> jjohnsson: sometimes it's better to describe the high level problem and ask people here how to get started
12:51:53 <lispy> (maybe that's what you're doing, I just showed up :)
12:52:17 <jjohnsson> lispy: I'm aware of that, I'm not trying a literal translation. but in a test today, using normal lists, memory consumption was huge. I need my programs to be usable as well.
12:52:28 <lispy> cool
12:52:45 <lispy> jjohnsson: did you dig in and discover why the lists were eating up memory?
12:55:02 <lispy> heatsink: sorry I disappeared yesterday. Did you make progress on your heap issues?
12:55:33 <jjohnsson> lispy: I asked here, and was told it was due to lots of boxing. I put my time-value pair in a tuple (t,y), and put tuples in a list. apparently that becomes 52 bytes per element, as opposed to 16, for doubles.
12:56:00 <lispy> interesting
12:56:56 <lispy> jjohnsson: well, you could make the tuples be unboxed doubles and then you only pay extra for each list cons.  In some cases the list can be optimized away
12:57:18 <lispy> But, yeah, arrays can do similar stuff
12:57:51 <heatsink> lispy, yes.  I replaced the value supply code.  That reduced space usage by about 2/3 and now space usage peaks well before the end of the program.
12:58:42 <lispy> heatsink: how did you change the value supply code? (last I heard you were investigating unsafeInterleaveIO issues and the unique name supply)
12:58:44 <jjohnsson> I will try the arrays. my Matlab matrices sometimes are a few hundred megabytes in memory; I don't really want to multiply that with anything too large.
12:59:55 <thaldyron> in the DEFUN tutorial today, dons was mentioning some papers about integrating database transactions into STM. Does anyone know any references on this?
13:00:02 <heatsink> The unsafeInterleaveIO code was something I got from hackage.
13:00:39 <lispy> thaldyron: dons recently posted a parallel haskell reading list.  I wonder if the reference would be there
13:01:34 <heatsink> I replaced it with an MVar holding a counter.  There are IO and unsafePerformIO non-IO routines to get a fresh value, and these are exposed through a monad type class.
13:02:13 <thaldyron> lispy: hmm, I don't think so, I've already (briefly) looked into most of these papers
13:02:16 <lispy> heatsink: interesting, yeah an MVar makes sense
13:02:45 <lispy> thaldyron: okay, I don't really know then, sorry
13:04:54 <lispy> hmm..having scion issues
13:05:03 <heatsink> Scion?
13:05:18 <lispy> http://hackage.haskell.org/package/scion-0.1.0.2
13:05:29 <lispy> it's an editor independent haskell-mode
13:05:36 <lispy> it uses GHC API
13:05:59 <lispy> I think I see the problem...when I launch emacs it doesn't have the same path as my shell
13:06:14 <heatsink> huh, interesting thing to make a library.
13:06:35 <lispy> I guess emacs/vim communicate with it in a client-server fashion
13:07:27 <Philonous> I just notice how to "cheat" the system: For data structures where there is no useful meaning of "join" you can just separate the structure from the data at the type level, wrap it in an existential type and still get to define a monad instance.
13:10:09 <lispy> ah, my problem with scion is that my emacs doesn't ship the json library
13:10:47 <byorgey> Philonous: I don't quite follow.
13:10:53 <heatsink> I should try yi, I just haven't felt the motivation to install all its dependences.
13:10:57 <benny99> hi -- I simply want to print a list of lists of numbers in binary base -- how could I do that ?
13:11:04 <byorgey> heatsink: just 'cabal install yi'!
13:11:21 <byorgey> no one should be worrying about installing dependencies in this day and age.
13:11:28 <lispy> hm...this blog claims emacs has shipped with json since feb '08
13:11:33 <heatsink> What is the cabal program?  I thought Cabal was a library.
13:11:48 <byorgey> heatsink: 'cabal' is the executable provided by the 'cabal-install' package
13:11:59 <lispy> heatsink: cabal-install provides a binary named cabal that can be used like a package manager and installer tool
13:12:00 <Botje> map (filter (`elem` "01") . show) ? *ducks*
13:12:22 <byorgey> heatsink: go to Hackage, download the cabal-install package, and run the 'bootstrap' script
13:12:34 <Botje> benny99: Look at Numeric.ShowIntAtBase
13:12:38 <byorgey> unless you are on Windows, but there might be a windows installer script too, I'm not sure.
13:12:45 <benny99> Botje, thanks :)
13:13:01 * lispy downloads a (hopefully) newer version of carbon emacs
13:13:01 <Botje> although .. it looks strange
13:14:09 <Botje> > Numeric.showIntAtBase 2 ("01"!!) 42
13:14:10 <lambdabot>   Overlapping instances for GHC.Show.Show
13:14:10 <lambdabot>                              (GHC.B...
13:14:26 <mauke> missing ""
13:14:28 <mmorrow> Philonous: sounds neat, minimal example?
13:14:35 <Botje> ah, yeah.
13:14:36 <mauke> also intToDigit
13:16:17 <mmorrow> jjohnsson: if you're manipulating matrices in the 100s of megabytes, i'd use hmatrix (which uses lapack, blas, gsl)
13:17:01 <heatsink> byorgey, thanks
13:17:13 <mmorrow> jjohnsson: you can also do in-place stuff too (in various ways), but i'm not current on the hmatrix api
13:19:19 <jjohnsson> mmorrow: I mostly store data in these matrices, and weight columns together. no advanced matrix algebra. but if they are as easy as arrays (well, I still haven't figured them out...) maybe I should switch to that.
13:20:14 <Philonous> mmorrow: I'm trying to distill it out of my code
13:20:22 <mmorrow> jjohnsson: i'd definitely recommend hmatrix
13:20:28 <jjohnsson> mmorrow: now that I think of it, I will multiply these matrices with vectors at times.
13:20:53 <benny99> > (Numeric.showIntAtBase 2 intToDigit 17) ""
13:20:54 <lambdabot>   "10001"
13:21:07 <jjohnsson> mmorrow: ok, thanks for your help.
13:21:17 <mmorrow> jjohnsson: np
13:21:21 <benny99> mauke, Botje, thanks -- though is it supposed to be used that way ?
13:21:56 <mmorrow> jjohnsson: the tutorial pdf here is a good intro http://www.hmatrix.googlepages.com/
13:22:10 <jjohnsson> mmorrow: just found it, reading now. :)
13:23:38 <benny99> mmorrow, thanks :o)
13:24:07 <mauke> benny99: too many parens
13:24:17 <mauke> > showIntAtBase 2 intToDigit 17 ""
13:24:18 <lambdabot>   "10001"
13:24:31 <lispy> scion is not doing what I expect at all
13:24:48 <dschoepe> @index showIntAtBase
13:24:48 <lambdabot> Numeric
13:24:58 <dschoepe> @hoogle showIntAtBase
13:24:59 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
13:26:21 <stanv> hello, mod4Mask is Super_L. What is mod for Super_R ?
13:26:52 <Philonous> mmorrow, laz0r: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9088#a9088 -- I hope that makes the point cleat. Of course of you want to do anything meyningful with your newly created "monad" at all, you have to include it as a constraint in the existential type
13:27:00 <xaep> stanv: use xmodmap, Luke
13:27:24 <stanv> xaep: :)
13:29:26 <benny99> mauke, of course, forgot to delete that
13:29:27 <lispy> I type C-c C-. and it says, GoTo Definiton: foo (down in the minibuffer), but I can't seem to make it actually do that action
13:29:31 <lispy> pressing enter does nothing, for instances
13:29:48 <gwern> what about the goggles?
13:30:17 <lispy> gwern: was that directed at me?
13:30:22 <mmorrow> Phillemann: ah, so every (>>=) you just add another level to (Foo m (Foo m (... (Foo m a))) (?)
13:30:30 <gwern> lispy: yes -_- you were supposed to reply 'THEY DO NOTHING'
13:30:42 * heatsink got the joke
13:31:02 <mmorrow> Philonous_: i meant
13:31:04 <lispy> gwern: wait, is that a goonies 2 reference?
13:31:10 <gwern> :( no, simpsons
13:31:13 <lispy> ah
13:31:28 <mmorrow> Philonous: no underscore
13:32:18 <mmorrow> gwern: vonderboy?
13:32:47 <stanv> xaep: I want mod5Mask
13:32:48 <gwern> mmorrow: fallout boy, you mean
13:32:54 <mmorrow> gwern: doh!
13:33:27 <gwern> good rainier accent tho
13:33:44 <mmorrow> hehe
13:35:45 <xaep> stanv: xmodmap -e 'clear mod5'; xmodmap -e 'add mod5 = Super_R'
13:35:48 <mmorrow> gwern: heh http://www.videosift.com/video/Classic-Simpsons-The-goggles-do-nothing
13:36:11 <gwern> a good episode
13:36:31 <gwern> that clip seriously lacks context tho
13:38:03 <stanv> xaep: I don't want redifine mod5 or mod3... is it possible directly use Super_R in xmonad.hs ?
13:38:22 <stanv> without touch xmodmap
13:39:09 <stanv> xaep: i can't found where mod4Mask is defined in xmonad sources: xmonad-0.8.1/ > grep -rni mod4Mask .
13:39:55 <gwern> because it isn't there
13:39:56 <gwern> in x11
13:43:52 <lispy> is this the right place to get haskell-mode? http://www.iro.umontreal.ca/~monnier/elisp/
13:43:58 <lispy> the last release was in 2007?
13:44:29 <gwern> I'm sure there's been a release since
13:44:41 <lispy> do you know where?
13:44:59 <gwern> for example, ubuntu packages 2.4.1
13:45:06 <gwern> er. 2.4-1
13:46:09 <xaep> gwern: that's 2.4, which was released in 2007
13:46:30 <gwern> look at the cvs maybe
13:46:51 <stanv> xaep: ti ze razgovarivaesh po russki
14:09:10 <Polarina> Hello.
14:09:18 <heatsink> Hello.
14:09:55 <Polarina> Is there a simple tutorial to learn Haskell for those with a lot of experience in procedural languages?
14:09:56 <heatsink> Wesnoth?  The game?
14:10:22 <Polarina> Yes, it's a game.
14:10:57 <heatsink> Learn You a Haskell is well recommended.
14:10:58 <xaep> Polarina: http://www.haskell.org/~pairwise/intro/intro.html
14:11:00 <heatsink> @lyah
14:11:00 <lambdabot> Unknown command, try @list
14:11:17 <heatsink> @where lyah
14:11:18 <lambdabot> www.learnyouahaskell.com
14:11:30 <Polarina> Thanks.
14:11:38 <heatsink> Either of those.
14:12:12 * benny99 says bye
14:18:22 <heatsink> So... what does that slash-separated string that appears in place of a hostname in join messages mean?
14:18:39 <mauke> depends on the string
14:18:39 <heatsink> on irc I mean
14:18:53 <mauke> also depends on the server
14:19:48 <Twey> heatsink: It's a hostmask.
14:19:52 <Cale> heatsink: It's an arbitrary string which freenode grants to various users.
14:20:01 <heatsink> Ah.
14:20:15 <heatsink> Seems to follow the pattern project/role/username
14:20:18 <Twey> There's no fixed format, but on Freenode it's usually formatted as âproject/[group/]userâ
14:20:34 <lispy> I think scion is not ready for use yet
14:20:36 <Twey> Where âprojectâ can also be âunaffiliatedâ
14:20:45 <mauke> gateway/shell/blinkenshell.org/x-iyxzfuiwuvkdyvfg
14:21:18 <Twey> Oh, aye â there are also gateway masks
14:21:22 <Twey> And supporter masks
14:21:44 <heatsink> mauke: does your unguessable username reduce the chance of hack attemps?
14:22:12 <mauke> I don't think mauke is unguessable
14:22:31 <heatsink> x-iyxzfuiwuvkdyvfg
14:22:43 <mauke> that's neither mine nor a username
14:22:48 <heatsink> oh
14:22:50 <Twey> Heh.
14:23:05 <dschoepe> heatsink: they are called cloaks and hide the hostname. that prevents e.g. DoS attacks.
14:23:44 <heatsink> ah, ok
14:23:48 <Twey> Er, cloaks, right.
14:24:08 <Twey> They're also used as a form of visual identification.
14:24:39 <Polarina> I am reading http://www.haskell.org/~pairwise/intro/section1.html and it lost me when it introduced the fibonacci code. The rest of that part doesn't explain it.
14:25:04 <Twey> Yeah.  Don't use that.
14:25:12 <Twey> http://book.realworldhaskell.org/read/
14:25:25 <Alpounet> Hi !
14:25:32 <Twey> 'allo
14:25:47 <Badger> @where lyah
14:25:47 <lambdabot> www.learnyouahaskell.com
14:26:18 <Twey> âHaskell for C Programmersâ nearly scared me away from Haskell for good when I was learning.  :Ã¾
14:26:24 <Twey> Thankfully we have much better resources, now.
14:26:28 <Badger> heh
14:26:41 <Alpounet> Do anyone know how we can "exchange" stuffs with pure hardware stuffs ?
14:26:49 <Polarina> Twey: :)
14:26:53 <heatsink> Polarina, writing a good haskell tutorial is surprisingly hard.  Fortunately, some people have done the hard work.
14:27:02 <hackagebot> storablevector 0.2.4 - Fast, packed, strict storable arrays with a list interface like ByteString (HenningThielemann)
14:27:04 <hackagebot> numeric-prelude 0.1.2 - An experimental alternative hierarchy of numeric type classes (HenningThielemann)
14:27:35 <heatsink> Alpounet: That's kind of vague.  Do you mean like purchasing with cash instead of a credit card?
14:28:02 <Alpounet> Not really... Yeah sorry, I'm being vague. I'd like to switch the power on of some sort of "interruptor".
14:28:10 <Alpounet> I'd love doing it in Haskell !
14:29:50 <Twey> Alpounet: What sort of âinterruptorâ, exactly?
14:30:54 <jfoutz> Alpounet: what is the hardware?
14:31:31 <Alpounet> Twey, don't know yet. I can buy it with regard to the easiness of manipulating it from the computer. The goal would be to put the "interruptor" between usual electrical stuffs (coffee machine ? :-p) and an elecitricity source.
14:32:18 <Twey> Well, you can certainly do it
14:33:04 <jfoutz> @where atom
14:33:04 <lambdabot> I know nothing about atom.
14:33:11 <Twey> How exactly you would depends on what you want to do with it and the system with which you're interfacing with it, though.
14:33:29 <Twey> AIUI, UNIX-based systems would simply represent such a device as a file.
14:34:02 <birkenfeld> what do I answer somebody who says "if Haskell is purely functional, why isn't import a function?"
14:35:00 <sioraiocht> birkenfeld: It's not something executed and evaluated, it's used during compilation
14:35:29 <birkenfeld> sioraiocht: might work :)
14:35:38 <BMeph> birkenfeld: "It's not that kind of 'purity'." :)
14:36:03 <birkenfeld> sometimes it's hard to express what is dead obvious to yourself
14:36:21 <Twey> = isn't a function, either.
14:36:52 <jethr0> PURELY functional programs tend to get boring pretty quickly (i.e. not output or other signs of life) ^_^
14:37:32 <Alpounet> Twey, I'm running Linux, so it'd certainly be the case.
14:37:50 <Alpounet> But I'd have to choose something with a driver already written for.
14:37:56 <jfoutz> Alpounet: i've never done any of it, but this might get you started. http://blog.sw17ch.com/wordpress/?p=84 http://hackage.haskell.org/package/atom
14:38:21 <Alpounet> jfoutz, thanks for the links ! I'll take a look at that.
14:38:31 <Twey> Alpounet: Well, not necessarily.  I don't see why a generic driver couldn't be found that simply passes input and output to/from the device through a file.
14:38:44 <jfoutz> Alpounet: also, not haskell but might help with hardware. http://www.faqs.org/docs/Linux-mini/Coffee.html
14:38:51 <Twey> It sounds like all you need are âonâ and âoffâ commands.
14:38:57 <Alpounet> Twey, exactly !
14:39:24 <Alpounet> jfoutz, yeah, I'll see that too. But I can call anything from Haskell, so my program would be written in Haskell :-)
14:40:07 <dixie> @run 1+1
14:40:09 <lambdabot>   2
14:40:14 <mmorrow> jethr0: purity and functional have nothing do do with each other
14:41:02 <mmorrow> although i don't want to imagine having to program in a non-functional pure language
14:41:24 <Twey> I think it would be quite a lot like programming in IO.
14:41:41 <jethr0> assembly is pretty non-functional pure.
14:41:47 <Philonous_> mmorrow: Yes exactly, >>= is in this case equal to fmap. But you are not limited to that. Maybe you sometimes want to change structurs completely. From List to Tree for example.
14:41:47 <mmorrow> Twey: no refs!
14:42:39 <Baughn> Twey: No Control.Monad
14:42:42 <Baughn> Except built-in stuff
14:42:53 <mmorrow> jethr0: hmm, if you use an infinite number of virtual registers and have procedures with formal params i guess
14:42:57 <Baughn> No passing functions around, of course no currying..
14:43:33 <jethr0> i was thinking of "no expressions, only assignment" pure
14:43:49 <mmorrow> jethr0: ah, hmm
14:43:57 <Baughn> At this point, might as well call it programming in GCC SSA form
14:44:04 * mmorrow tries to grok that
14:44:16 <mmorrow> Baughn: right, basically ssa
14:44:40 <BMeph> Mmmm....SAC! ;p
14:45:01 <mmorrow> jethr0: what about "mov $1,%rax; mov $2,%rax" ?
14:46:00 <jethr0> what about it? looks quite assembly-ish to me
14:46:23 <mmorrow> jethr0: i'm trying to grok your definition of pure
14:46:38 <dixie> try { mov $1,%rax } catch(IOException e) { add e,%cpi }
14:46:39 <mmorrow> jethr0: s/definition/what you had in mind/
14:46:44 <jethr0> hehe
14:46:54 <mmorrow> :o
14:49:01 <heatsink> I guess Excel is non-functional and pure.
14:49:21 <jethr0> i find excel extremely functional (apart from anything to do with vba)
14:49:30 <jethr0> that part is pure evil ;)
14:50:33 <mmorrow> btw, if anyone is trying to grok what SSA is about, this is the most lucid explanation of it i've seen (imo, since it shows an equivalence too) www.cs.princeton.edu/~appel/papers/ssafun.ps
14:50:42 <heatsink> But spreadsheets rarely have user-defined functions.  It's mostly just dataflow programming.
14:50:51 <mmorrow> after that, i was like "oh, ok"
14:51:04 <heatsink> Yeah, that's a good paper.
14:52:15 <hackagebot> pureMD5 1.0.0.2 - MD5 implementations that should become part of a ByteString Crypto package. (ThomasDuBuisson)
14:54:35 <Cale> Excel is a 0th order functional programming language :)
14:54:53 <jjohnsson> laziness is really strange. now, time to sleep.
14:55:11 <jethr0> what's with the ordering?
14:55:26 * gwern wonders if I should volunteer for the HWN
14:55:41 <tommd> Is Brent getting out of the business?
14:55:45 <gwern> apparently
14:56:17 <jethr0> isn't either lambda calculus or lisp's eval-apply loop 0th order functional PL?
14:56:23 <tommd> Humm... Hell must have frozen over - which is odd as I would have expected it be in the Northern Hemisphere.
14:56:44 <mmorrow> Philonous_: i was thinking you could also accumulate (fmap . (fmap . (.... (fmap . id)))) as you `join', so you can have the (Foo m (.... a)) along with a ((a -> b) -> (Foo m (... a) -> Foo m (... b)) in the existential box
14:56:59 <gwern> tommd: you could volunteer! :)
14:57:14 <gwern> but I don't blame byorgey - 4 hours a week is about 200 hours a year
14:57:16 <Philonous_> mmorrow: Sure!
14:57:19 <gwern> quite an investment
14:57:33 <gwern> I think it could be automated more, but still
14:57:39 * BMeph would love to see a ZigZag(TM) implementation in Haskell. Probably wouldn't love to write one, though. ;)
14:57:44 <Philonous_> mmorrow: Actually, you already have this via the monad instance
14:57:55 <mmorrow> Philonous_: err, i meant s/join/>>=/, but you know what i mean
14:58:04 <Philonous_> mmorrow: Errr, I meant Functor
14:58:05 <mmorrow> Philonous_: oh?>
14:58:12 <mmorrow> ohh, right
14:58:36 <byorgey> it definitely could still be automated more.
14:59:04 <byorgey> actually, I already have a volunteer
14:59:08 <Philonous_> mmorrow: But you can make it foldable, for instance. I did something similar so my junctions have a monadic interface
14:59:22 <gwern> byorgey: for example, seems to me like the 'blog posts' section could basically be a line editor which sucked down the haskell/proggit rss feed - the human simply pages through it occasionally clicking delete
14:59:41 <byorgey> gwern: that's exactly what it is.
14:59:51 <byorgey> basically.
14:59:56 <gwern> oh
15:00:01 <gwern> then where are the 4 hours going?
15:00:05 <byorgey> mostly reading.
15:00:17 <gwern> reading?
15:00:20 <BMeph> byorgey: Looking for "good" quotes? ;)
15:00:33 <byorgey> reading through the mailing lists.
15:01:01 <gwern> hm. tagsoup might be able to handle the archive pages of -cafe...
15:01:09 <byorgey> it could be done faster but I can't separate out the time I spend actually reading things because I want to read them, as opposed to just looking for things for the HWN.
15:01:16 <gwern> @quote understand.both
15:01:16 <lambdabot> benmachine says: ho hum. I understand both your positions. but i don't understand mine, now :(
15:01:22 <gwern> @quote agda
15:01:22 <lambdabot> No quotes match.
15:01:22 <dixie> I think 4 hours is good unit for doing one task. I don't like higher granulation...
15:01:28 <byorgey> gwern: yup, I use tagsoup to grab stuff from gmane
15:01:38 <gwern> @rememer ksf agda is actually a secret mindwar-weapon of the illuminati, who want to wrack your nerves with excessively big symbol sets requiring a keyboard with 10 modifier keys. just like APL.
15:01:38 <lambdabot> It is forever etched in my memory.
15:01:45 <gwern> @quote dead.fish
15:01:45 <benmachine> :\/
15:01:46 <lambdabot> No quotes match. You untyped fool!
15:01:58 <gwern> @remember Axman6 does anyone else think that C++ looks like a dead fish? (C++<)
15:01:59 <lambdabot> Done.
15:02:07 <gwern> @quote Copenhagen
15:02:07 <lambdabot> No quotes match. Wrong!  You cheating scum!
15:02:14 <gwern> @remember Cale The difference between Many Worlds and Copenhagen is a garbage collector ;)
15:02:15 <lambdabot> I will remember.
15:02:19 <idnar> @quote multiple
15:02:19 <lambdabot> ghc says: Multiple default declarations
15:02:21 <gwern> @quote dragon
15:02:21 <lambdabot> apfelmus says: Lambda Fu, form 72 - three way dragon zip: 'averages3 xs = zipWith3 avg xs (drop 1 xs) (drop 2 xs); where avg a b c = (a+b+c) / 3'
15:02:24 <idnar> @quote multiple
15:02:24 <lambdabot> ghc says: Multiple default declarations
15:02:25 <gwern> @flush
15:05:40 <tommd> @quote distributed
15:05:40 <lambdabot> TomMD says: c.h.o should move to ARM... then a distributed system would be needed.
15:06:26 <tommd> @users
15:06:26 <lambdabot> Maximum users seen in #haskell: 658, currently: 568 (86.3%), active: 21 (3.7%)
15:06:43 <tommd> Humm, we just need to flip some of the digits around.
15:06:46 <Polarina> lambdabot: I am active too!
15:06:53 <Alpounet> Twey, jfoutz, thank you very much for your answers, it's actually much of help !
15:07:03 <mmorrow> @users
15:07:04 <lambdabot> Maximum users seen in #haskell: 658, currently: 568 (86.3%), active: 22 (3.9%)
15:07:16 <gwern> @ask Cale any chance you could push a patch updating the lambdabot state?
15:07:16 <lambdabot> Consider it noted.
15:07:41 <tommd> lambdabot should be moved to Happstack ;-)
15:08:52 <mmorrow> sqlite is nice
15:09:23 <mmorrow> you could even mmap a .db, and operate on it in memory, with your updates being written to disk COW!!@
15:10:24 <gwern> tommd: to do that would rewrite lambdabot
15:10:26 <gwern> feel free
15:14:07 * benmachine is using infix fmaps and deciding between (.), (<$>), and just plain old `fmap`
15:14:09 <BMeph> But first, please - a tutorial! ;)
15:15:29 <Polarina> Book? Who needs books? Use the Internet!
15:15:32 <Polarina> BMeph: http://book.realworldhaskell.org/read/
15:17:05 <Badger> benmachine: (<$>) because it is prettiest
15:17:13 <BMeph> Polarina: No, re-writing lambadbot to work with Happstack as a tutorial. Besides, who were you directing "Who needs books?" at? :)
15:17:29 * BMeph likes using '|>' for fmap...
15:17:45 <Polarina> BMeph: You, actually. :P
15:17:54 <mmorrow> @uesers
15:17:54 <lambdabot> Maximum users seen in #haskell: 658, currently: 562 (85.4%), active: 20 (3.6%)
15:17:56 <benmachine> Badger: you are probably right actually
15:18:49 <Badger> BMeph: why |>?
15:18:54 <Badger> benmachine: woo
15:20:05 <dons> hey all, here's slides from my 3.5 hr tutorial session today, on parallel haskell, http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
15:20:22 <mmorrow> using `fmap' for (.) is like saying "d00d" instead of "sir", and using (<$>) instead of `fmap' is like saying "tubular" instead of "neato"
15:20:25 <|Steve|> @pl \x y -> (f x y) && (g x y)
15:20:25 <lambdabot> ap (ap . ((&&) .) . f) g
15:20:30 <jungehexe> hallo, beiing a newbie i have a problem with haskell i nee a function which gets some input, writes it in file and returns the input back
15:20:32 <copumpkin> :o
15:20:47 <byorgey> chr1s, sebas_: the fclabels library looks great!  simple and elegant.
15:20:48 <copumpkin> |Steve|: I bet there's a better way to do that
15:21:03 <|Steve|> I think not doing it points-free is the way to go here.
15:21:03 <redline6561> Is there a straightforward way to parse an integer from a string?
15:21:06 <byorgey> jungehexe: what have you tried so far?
15:21:10 <copumpkin> redline6561: read
15:21:15 <copumpkin> > read "123" :: Int
15:21:16 <lambdabot>   123
15:21:59 <jungehexe> :byorgey i tried smth like writing:: a -> a
15:22:07 <jethr0> > reads "123asdf" :: [(Int, String)]
15:22:09 <lambdabot>   [(123,"asdf")]
15:22:11 <redline6561> copumpkin: Thanks. I'm having some problems with that because it's being passed ((!!) xs 6)
15:22:23 <Heffalump> byorgey: is it better than the other first class labels library?
15:22:26 <mmorrow> dons: is anyone taking video of any parts of the HIW?
15:22:28 <Heffalump> The duplication seems unfortunate
15:22:35 <jungehexe> byorgey: writing a  = do
15:22:36 <Heffalump> mmorrow: Malcolm Wallace videoed it all
15:22:41 <mmorrow> Heffalump: woo!
15:22:59 <byorgey> @remember mmorrow using `fmap' for (.) is like saying "d00d" instead of "sir", and using (<$>) instead of `fmap' is like saying "tubular" instead of "neato"
15:22:59 <lambdabot> It is stored.
15:23:08 * mmorrow really means it when he says next year
15:23:15 <jethr0> jungehexe: have you ever programmed in any other languages?
15:23:29 <byorgey> Heffalump: which one?  Data.Accessor or the new Lenses library?
15:23:42 <jungehexe> jethr0: yeah
15:24:13 <jethr0> jungehexe: this page describes a lot of IO functions for haskell: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
15:24:27 <byorgey> Heffalump: I haven't actually used them enough to give a good comparison.  I just like what I see in fclabels.
15:25:13 <mmorrow> does anyone know where ICFP is going to be held next year?
15:25:45 <jethr0> withFile, getLine, hPutStr might be good places to start.
15:26:04 <jethr0> jungehexe: how come you are using haskell for this?
15:26:36 <mmorrow> oh snap, it's in baltimore, maryland in 2010
15:27:05 <jungehexe> jethr0: because i have to
15:27:08 <jungehexe> uni
15:28:01 <byorgey> mmorrow: yup, and in Japan the year after that
15:28:06 <jethr0> ahh. do you have any idea where to start?
15:28:09 <Heffalump> byorgey: Data.Accessor
15:28:12 <jungehexe> i just do'nt see any other way how can i save some values generated in runtime for the certain time and return them when asked
15:28:31 <Heffalump> byorgey: it just seems like an obvious thing where the benefits of a single library would far outweigh the benefits of diversity
15:28:58 <jethr0> jungehexe: in ghci try: "getLine >>= putStrLn"
15:29:16 <byorgey> Heffalump: I agree, but this is the usual path, isn't it?  people experiment with different things and eventually approaches are merged or one approach emerges as the clear winner.
15:29:26 <jethr0> this fetches one line of input from stdin and passes it to "putStrLn". the whole thing is in the IO monad.
15:29:31 <byorgey> the idea of functional references is still relatively new.
15:29:59 <jethr0> another way to write it would be "getLine >>= \line -> putStrLn line"
15:30:20 <Heffalump> byorgey: I guess so. Is it new? It's always struck me as completely obvious (in the sense that I first thought of it years ago)
15:30:24 <jethr0> or "do {line <- getLine; putStrLn line}"
15:30:40 <Heffalump> I'm not really sure there's much useful design space either, aside from syntax.
15:31:14 <jungehexe> but would it work if i call it later from other function?
15:31:15 <jungehexe> really
15:31:21 <jungehexe> i mean so it works
15:32:05 <byorgey> Heffalump: well, maybe the idea isn't new, but there haven't been Haskell libraries to support it for very long.
15:32:14 <jethr0> do you already have some code? you could paste it:
15:32:17 <jethr0> @paste
15:32:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:32:29 <jungehexe> moment
15:32:36 <jethr0> what kind of function would you like to call from?
15:32:39 <byorgey> anyway, someone should try all 3 of the libraries out and post a careful comparison
15:32:40 <jungehexe> i'm also newbie for irc
15:32:56 <byorgey> and a possible roadmap for merging their best features into a single standard library.
15:32:58 <jethr0> i meant paste it at above url
15:33:11 <jungehexe> ok
15:35:51 <Heffalump> byorgey: yeah, I guess so
15:40:06 <byorgey> Heffalump: it seems the main things distinguishing fclabel is an elegant, really first-class treatment of accessors (including a Category instance), as well as a neat way to define updateable views, which the other libraries don't have.
15:41:20 <byorgey> Data.Accessor seems the most mature at the moment, and has support for dealing with Maps and IntMaps as if they were labeled records, but I think that could easily be added to fclabels
15:41:39 <byorgey> and the new Labels library ONLY works in the context of a State monad so that seems a bit handicapping.
15:41:44 <Heffalump> ah yes
15:41:57 * Heffalump withdraws his claims that there isn't much of a design space
15:42:03 <byorgey> hehe
15:42:27 <byorgey> at least, there's enough of a design space that the best design isn't immediately obvious.
15:46:57 <mmorrow> this is my lens-generator module http://moonpatio.com/repos/MkLenses.hs
15:47:20 <mmorrow> which along with
15:47:23 <mmorrow> focus :: (a -> (o, b -> c)) -> (o -> b) -> (a -> c)
15:47:23 <mmorrow> focus lens f x = let (a,k) = lens x in (k . f) a
15:47:43 <mmorrow> is enough for me
15:48:37 <mmorrow> well, just for the lowest-level of lens-ness that is ;)
15:49:03 <mmorrow> (usually use those *L functions in some state-like monad)
15:51:00 <mmorrow> mapFoo = modify . focus fooL
15:51:30 <mmorrow> mapFooGooBar = modify . focus barL . focus gooL . focus fooL
15:52:10 <Polarina> I have this function declaration "add a b = a + b". How do I force a and b to be of type Double?
15:52:21 <mauke> add :: Double -> Double -> Double
15:52:23 <mmorrow> (data Bar = {... goo :: Goo .. }; data Goo = {... foo :: Foo ... }; data Foo { ... foo :: a ... })
15:52:49 <Lemmih> Polarina: Or: add a b = a + b :: Double
15:52:59 <Polarina> Lemmih: Ok, thanks
15:53:18 <byorgey> more generally you can say  add :: Num a => a -> a -> a  and it will work for any Num type, including Double
15:53:23 <ksf> ...but giving the whole signature is usually good style, anyway.
15:54:08 <ksf> while type signature inside functions are usually only used when there's absolutely no other way to make the code compile.
15:54:24 <ksf> (i.e. the code is ambiguous)
15:55:00 <ksf> Polarina, you can disable the monomorphism restriction, too, that was what you were hitting, weren't you?
15:55:09 <Polarina> ksf: What?
15:55:48 <Polarina> No, I am just learning.
15:56:12 <ksf> ...well, it should have fired with your example, saying that the type is too general and demanding a type signature.
15:56:27 <Polarina> ksf: ?
15:56:32 <mauke> ksf: what?
15:56:47 <mauke> the MR never says that some type is too general
15:57:09 <mauke> hmm, or maybe it does and I've never hit that case
15:57:15 <Lemmih> ksf: It should?
15:58:39 <Polarina> Now I have "add a = (fst a) + (snd a)". How do I force a to be (Integer, Integer) and return Integer?
15:58:56 <mauke> add :: (Integer, Integer) -> Integer
15:59:03 <mmorrow> @type
15:59:04 <lambdabot> on the commandline:
15:59:04 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
15:59:04 <lambdabot> <no location info>: not an expression: `'
15:59:06 <byorgey> Polarina: why do you need to force anything?
15:59:08 <mmorrow> @type \a b -> a + b
15:59:09 <lambdabot> forall a. (Num a) => a -> a -> a
15:59:14 <mmorrow> @type \a b -> a + (b::Double)
15:59:15 <lambdabot> Double -> Double -> Double
15:59:19 <byorgey> Polarina: if you just type in that function, GHC can infer a type for you.
15:59:19 <Polarina> byorgey: Just trying to figure how to make things work.
15:59:42 <byorgey> it will work without forcing anything.
15:59:47 <mmorrow> @type \a -> fst a + (snd a::Integer)
15:59:48 <lambdabot> (Integer, Integer) -> Integer
15:59:52 <Polarina> I know. I just want to know how to force something.
15:59:53 <byorgey> although writing a type signature is a good idea.
16:00:00 <byorgey> ok.
16:00:13 <mmorrow> Polarina: giving a type sig is "forcing"
16:00:15 <Lemmih> Polarina: 'Restrict' is a better term.
16:00:19 <mmorrow> yeah
16:00:21 <mmorrow> restrict
16:00:28 <Warrigal> @pl \a -> fst a + snd a
16:00:29 <lambdabot> uncurry (+)
16:00:32 <Polarina> Lemmih: Thanks.
16:00:50 <Warrigal> I was hoping it wouldn't say that. pl, it appears, is smart.
16:00:59 <mmorrow> > return 42 :: [Integer]
16:01:01 <lambdabot>   [42]
16:01:03 <mmorrow> > return 42 :: Maybe Double
16:01:04 <Warrigal> @unpl uncurry (+)
16:01:04 <lambdabot> uncurry (+)
16:01:04 <lambdabot>   Just 42.0
16:01:08 <mmorrow> > return 42 :: IO Int
16:01:10 <lambdabot>   <IO Int>
16:01:12 <Warrigal> unpl is not as smart.
16:01:23 <Polarina> mmorrow: What is that "Maybe"?
16:01:32 <mmorrow> @src Maybe
16:01:33 <lambdabot> data Maybe a = Nothing | Just a
16:01:44 <mmorrow> , (Just 42, Nothing)
16:01:54 <Polarina> ?
16:01:55 <mmorrow> > [Just 42, Nothing] {- i meant -}
16:01:56 <lambdabot>   [Just 42,Nothing]
16:02:00 <mmorrow> @bot
16:02:00 <lambdabot> :)
16:02:05 <byorgey> Polarina: essentially, it creates a nullable type.
16:02:13 <Polarina> What is a nullable type?
16:02:19 <mmorrow> > maybe 0 length (Just [0..9])
16:02:20 <lambdabot>   10
16:02:20 <byorgey> Polarina: a value of type 'Maybe Int', for example, might be Nothing, or it might be Just n, where n is an Int
16:02:24 <mmorrow> > maybe 0 length Nothing
16:02:25 <lambdabot>   0
16:02:42 <Phyx-> Polarina: It's usually used to denote a function that can Fail, e.g. It either has a value (Just <value>) or it failed (Nothing)
16:02:54 <Phyx-> or rather, denote a computation that can fail
16:02:57 <mmorrow> \p -> if p==nullPtr then Nothing else Just p
16:03:00 <Warrigal> @hoogle [a] -> Maybe a
16:03:00 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
16:03:01 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
16:03:01 <lambdabot> Prelude head :: [a] -> a
16:03:16 <Polarina> Ah, thanks.
16:03:18 <byorgey> > find (==3) [1,2,4,3]
16:03:19 <lambdabot>   Just 3
16:03:22 <byorgey> > find (==3) [1,2,4]
16:03:23 <lambdabot>   Nothing
16:03:59 <Polarina> And how to check for Nothing? ==Nothing  ?
16:04:21 <byorgey> ==Nothing works, or you can use pattern-matching (better)
16:04:26 <byorgey> like   foo Nothing = ...
16:04:30 <byorgey> foo (Just x) = ...
16:04:32 <mmorrow> > fmap (maybe True (const False)) [Nothing, Just]
16:04:33 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
16:04:36 <mmorrow> > fmap (maybe True (const False)) [Nothing, Just 0]
16:04:37 <lambdabot>   [True,False]
16:04:40 <Polarina> byorgey: Wait, what?
16:04:42 <benmachine> > Just id == Nothing
16:04:43 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
16:04:43 <lambdabot>    arising from a use of `GHC.Cla...
16:04:57 <byorgey> Polarina: do you know about defining a function by pattern-matching?
16:05:05 <Polarina> byorgey: No.
16:05:08 <mmorrow> Polarina: the `maybe' function makes using Maybe tolerable
16:05:13 <mmorrow> that and fmap
16:05:26 <lilac> and fromMaybe
16:05:27 <Phyx-> mmorrow: and the Monad instance on it
16:05:29 <mauke> case x of Nothing -> ...; Just v -> ...
16:05:31 <Petrosian> And catMaybes
16:05:31 * Polarina is confused.
16:05:43 <byorgey> geez, guys, I think all that is a bit much for Polarina right now =)
16:05:43 <Cale> I actually pattern match more often than using 'maybe'
16:05:43 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
16:05:57 <Phyx-> Polarina: i think you need to go read some beginner tutorials on haskell. try the real world haskell
16:05:59 <byorgey> Polarina: you can define a function by giving several cases
16:06:06 <mmorrow> > let go Nothing = []; go (Just x) = [x,x] in fmap go [Nothing, Just 9, Just 29, Nothing]
16:06:08 <lambdabot>   [[],[9,9],[29,29],[]]
16:06:08 <byorgey> Polarina: for example:
16:06:09 <Polarina> Phyx-: I am reading it.
16:06:09 <Phyx-> @google real world haskell book online
16:06:10 <lambdabot> http://book.realworldhaskell.org/read/
16:06:10 <lambdabot> Title: Real World Haskell
16:06:15 <redline6561> I have a Map where the values are Ints. How can I take the 5 largest k-v pairs?
16:06:17 <byorgey> fib 0 = 1
16:06:20 <Phyx-> @google real world haskell book pattern matching
16:06:21 <lambdabot> http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
16:06:21 <lambdabot> Title: Chapter 5. Writing a library: working with JSON data
16:06:22 <byorgey> fib 1 = 1
16:06:27 <byorgey> fib n = fib (n-1) + fib (n-2)
16:06:43 <lilac> redline6561: largest in what sense? you want the largest 5 values?
16:06:56 <Cale> redline6561: Largest 5 keys?
16:06:56 <redline6561> Yes. The 5 largest integers.
16:07:02 <mmorrow> > let map _ [] = []; map f (x : xs) = f x : map f xs in map (\x -> x*2) [0..9]
16:07:03 <redline6561> Which are the values.
16:07:03 <lambdabot>   [0,2,4,6,8,10,12,14,16,18]
16:07:14 <Polarina> byorgey: You need "fib 0 = 0" too or that won't work...
16:07:14 <dons> gwern: do you want to be the HWN editor? :)
16:07:26 <redline6561> Cale: Largest 5 values. The keys are strings. Values are ints.
16:07:27 <mauke> <byorgey> fib 0 = 1
16:07:36 <redline6561> lilac: Yes.
16:07:38 <byorgey> Polarina: yes indeed.  I wrote fib 0 = 1  above, but other people said stuff in between
16:07:43 <Phyx-> > fmap (join (*)) (Just 5)
16:07:44 * BMeph wants to see a tutorial that does Stirling numbers instead of fibonacci
16:07:44 <lambdabot>   Just 25
16:07:46 <Polarina> byorgey: Ah.
16:07:46 <lilac> redline6561: apply toList, then sortBy ((comparing`on`snd) . flip), then take 5.
16:07:47 <ksf> me thinks fclabels look nicer.
16:07:58 <byorgey> Polarina: but you're right, that was a typo, I should have said   fib 0 = 0 =)
16:07:59 <ksf> ...mostly because of monads.
16:08:00 <redline6561> lilac: Thanks.
16:08:06 <Polarina> byorgey: :D
16:08:08 <Cale> redline6561: take 5 . sortBy (flip compare) . elems
16:08:20 <byorgey> Polarina: so, that function does pattern-matching on its argument
16:08:22 <redline6561> Cale: Thanks.
16:08:30 <Cale> Or yeah,  take 5 . sortBy (comparing snd) . toList
16:08:30 <lilac> redline6561: or what cale said if you don't want the keys ;-)
16:08:32 <Phyx-> @type elems
16:08:33 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
16:08:39 <byorgey> Polarina: the first case is used only if the argument is 0, the second case is used if it's 1, and the third case is used otherwise
16:08:42 <Cale> elems :: Map k a -> [a]
16:08:48 <Phyx-> ah, ok
16:08:50 <byorgey> Polarina: since the pattern 'n' matches any argument
16:08:52 <lilac> flip (comparing snd)
16:09:08 <redline6561> lilac: Good to know.
16:09:08 <byorgey> not that 'n' is special, I mean just giving a name will match any argument.
16:09:15 <Phyx-> Cale: but, didn't he want the k,v pair? wouldn't that just give him the values?
16:09:17 <byorgey> Polarina: does that make sense?
16:09:22 <Polarina> byorgey: Yes.
16:09:31 <Cale> Phyx-: It would. I'm not sure what he wanted.
16:09:38 <Cale> Phyx-: I gave both versions.
16:09:50 <byorgey> Polarina: so, if you had a function of type  Maybe Int -> Int, you could define it using pattern-matching similarly.
16:10:05 * Phyx- scrolls up
16:10:07 <byorgey> Polarina: you just have to know that a value of type 'Maybe Int' can look like 'Nothing' or like 'Just n'.  so:
16:10:16 <byorgey> unMaybe Nothing = 0
16:10:19 <byorgey> unMaybe (Just n) = n
16:10:21 <byorgey> for example
16:10:22 <Phyx-> Cale: ah, missed the second one
16:10:45 <dibblego> I have used s/0/mzero quite a lot
16:11:04 <Polarina> byorgey: Why that "Just"?
16:11:39 <Phyx-> Polarina: because you're pattern matching on the constructors
16:11:45 <Phyx-> Maybe is defined as
16:11:47 <Phyx-> @src Maybe
16:11:47 <lambdabot> data Maybe a = Nothing | Just a
16:11:53 <Cale> (and lilac covered the other pretty well too)
16:11:53 <Phyx-> so it has two constructors
16:11:54 <byorgey> Polarina: because otherwise there is no way to tell the difference between something of type  Int and something of type Maybe Int.
16:12:26 <Polarina> Ah.
16:13:21 * Phyx- scratches head and goes, eh.. maybe i missunderstood the question.. and goes back to his encoder
16:14:41 <redline6561> It's a port of some Common Lisp code. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9094#a9094
16:15:04 <BMeph> So, is there a library that "encodes" dense sets by Enum instancing, and trees of "enumFromTo"? :)
16:15:23 <BMeph> (If that even makes sense...)
16:15:49 <byorgey> Polarina: anyway, feel free to keep asking questions in here =)
16:16:12 <byorgey> sometimes it's like drinking from a fire hose, but hopefully it is still helpful ;)
16:16:47 <byorgey> the trick is to point the fire hose slightly away from you and just get a bit of water from the side
16:17:48 <BMeph> ...or, run alongside the stream really fast, and sip every now-and-then. ;)
16:27:14 <redline6561> Cale: what do I need to import for "comparing"?
16:27:27 <mauke> @index comparing
16:27:27 <lambdabot> bzzt
16:27:30 <mauke> @hoogle comparing
16:27:31 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
16:27:31 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
16:27:55 <redline6561> mauke: Didn't know lambdabot could do that. Neat. Thanks.
16:28:06 <hackagebot> hsql-odbc 1.7.1 -  (NickRudnick)
16:28:33 <mauke> redline6561: http://www.haskell.org/hoogle/
16:33:43 <gwern> dons: byorgey says he already has a volunteer so it seems there's no need for me
16:39:05 <Cale> redline6561: Data.Ord
16:43:17 <redline6561> Cale: Thanks. I pasted the lisp code I'm trying to port here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9094#a9094
16:43:17 <redline6561> I'm getting hung up thinking of how to port load-calls on line 39. Any advice?
16:45:43 * Cale looks
16:46:08 <mmorrow> Cale: this is interesting (i was just trying working out what (operationally) is going on with long chains of (.))
16:46:14 <mmorrow> , time (foldr (.) id (replicate 400000 (\(!x)->x+1)) 1)
16:46:17 <lunabot>  (1.123828,400001)
16:46:19 <mmorrow> , time (foldl' (.) id (replicate 400000 (\(!x)->x+1)) 1)
16:46:21 <lunabot>  (0.6628999999999999,400001)
16:46:22 <mmorrow> , time (foldl (.) id (replicate 400000 (\(!x)->x+1)) 1)
16:46:25 <lunabot>  (0.732889,400001)
16:46:56 <Cale> Hmm, I'd expect foldr to do better generally...
16:46:56 <mmorrow> but with foldl, you can't have a later function bail out or something ..
16:48:02 <mmorrow> Cale: i think before anything happens the list of (.) has to be reduced fully anyways, in which case the foldl(') is faster since it's able to process the (.) chain into an evaluated object faster
16:48:08 <Cale> redline6561: The goal is to load each of the files in the given path and read the first 23 lines from them?
16:48:25 <Phyx-> is time a standard haskell function?
16:48:30 <Cale> mmorrow: That's not true at all.
16:48:36 * mmorrow wishes he could vacuum partial applications
16:48:55 <Phyx-> @time
16:48:59 <lambdabot> Local time for Phyx- is Sun Sep  6 01:48:26 2009
16:49:00 <mmorrow> Cale: i think it depends on the functions in the pipeline
16:49:07 <lilac> > foldr (.) id (repeat (const 42)) 123
16:49:07 <Phyx-> @type time
16:49:08 <lambdabot>   42
16:49:08 <lambdabot> Not in scope: `time'
16:49:13 <mmorrow> err, this is the confusing part
16:49:14 <Phyx-> guess not
16:49:16 <Cale> mmorrow: foldr (.) id [f,g,h] x = (f . foldr (.) id [g,h]) x = f (foldr (.) id [g,h] x)
16:49:17 <redline6561> Cale: Nope. It skips the first 23 lines. After that, it reads every line and sends it to parse-call. The tricky part is that parse-call ends the evaluation when it encounters a line that starts with "Totals".
16:49:22 <Cale> mmorrow: Control then passes to f
16:49:24 <mauke> @time
16:49:27 <lambdabot> Local time for mauke is just silly. I mean, has anyone really been far even as decided to use even go want to do look more like?
16:49:33 <redline6561> Cale: And returns from load-calls.
16:49:58 <Cale> mmorrow: oh, of course, with the specific functions you're using, foldl' turns out better, because they're all strict
16:49:59 <mmorrow> in "time (foldl' (.) id (replicate 400000 (\(!x)->x+1)) 1)" though, the /last/ (+1) in the list is ... ohhh
16:50:59 <Cale> redline6561: Well, shouldn't be too hard explicitly passing filehandles around.
16:51:06 <mmorrow> so the situation is, since (+) is strict in /both/ args, then foldl' is faster because the topmost (+) forces the entire chain in order to get any result, and since the foldl' has already done half the work to do that (by forcing all the (.)'s), it's faster in that case
16:51:17 <mmorrow> analogously to (+) and foldl'
16:51:31 <mauke> lilac: my kung-fu is too powerful!
16:51:34 <Cale> redline6561: But that's probably not the approach I'd take. I'd probably just readFile and then drop 23 . lines
16:51:35 <mmorrow> but if that's not the case (analogously to (++) and foldr), then the opposite
16:51:37 <mmorrow> (i think)
16:52:15 <redline6561> Cale: Good point. How can I get it to return on the first line that starts with "Totals".
16:52:25 <mmorrow> , time (length (foldr (.) id (replicate 400000 (():)) [()]))
16:52:27 <lunabot>  (3.3995e-2,400001)
16:52:32 <mmorrow> , time (length (foldl' (.) id (replicate 400000 (():)) [()]))
16:52:34 <lunabot>  (0.141979,400001)
16:52:38 <mmorrow> yay
16:52:42 <Cale> redline6561: just takeWhile (not . isPrefixOf "Totals) on the list of lines
16:52:46 <Cale> er
16:52:48 <Cale> missed a "
16:53:28 * mmorrow goes back to collapsing his tree of functions with this knowledge
16:53:36 <Cale> redline6561: readFile is lazy about reading the file, so it won't eat more than you use. Be cautious of that if you have to later modify the file -- it might not be the best strategy in that case.
16:53:48 <mmorrow> (data a :=> b = E (a->b) | forall o. L (o->b)  (a:=>o) | forall o. R (o:=>b) (a->o) | forall o. T (o:=>b) (a:=>o))
16:54:40 <mmorrow> i was trying to figure out if there's one "best" direction to fold these in
16:54:53 <mmorrow> but i guess it depends on the strictness of the contained functions
16:55:43 <mmorrow> ("best" as in, whether the fold function should re-associate things)
16:56:05 <redline6561> Cale: That looks great. Will not need to modify any of the files. Thanks so much.
16:57:23 <mmorrow> , time ((foldl' (.) id (replicate 400000 (():)) `seq` ())
16:57:24 <lunabot>  luna: parse error (possibly incorrect indentation)
16:57:30 <mmorrow> , time ((foldl' (.) id (replicate 400000 (():) `seq` ())
16:57:30 <lunabot>  luna: parse error (possibly incorrect indentation)
16:57:57 <BMeph> What's '(():)' supposed to do? :)
16:58:03 <mmorrow> aha!
16:58:07 <mmorrow> , time (foldr (.) id (replicate 400000 (():)) `seq` ())
16:58:09 <lunabot>  (0.0,())
16:58:11 <mmorrow> , time (foldl' (.) id (replicate 400000 (():)) `seq` ())
16:58:13 <lunabot>  (7.8988e-2,())
16:58:35 <mmorrow> so if the work isn't going to be done anyways, foldl' is a loss (otherwise it's a win)
16:58:56 <BMeph> Never mind, got it. :)
16:59:00 <mmorrow> err, something like that
16:59:12 <mmorrow> BMeph: oh, missed that
16:59:32 <mmorrow> BMeph: just debris from an earlier expression ;)
17:00:21 <skorpan> ():[]
17:00:23 <skorpan> > ():[]
17:00:24 <lambdabot>   [()]
17:00:32 <skorpan> > fix (():)
17:00:33 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:00:36 <mmorrow> it was supposed to be (+1) for []..
17:00:53 <skorpan> > fix (():(fix (():)))
17:00:54 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[()]'
17:01:34 <BMeph> , time (foldr (.) id (replicate 400000 succ) 1)
17:01:37 <lunabot>  (0.621906,400001)
17:01:58 <codolio> What?
17:02:04 <mmorrow> , time (foldl' (.) id (replicate 400000 succ) 1)
17:02:06 <lunabot>  (0.319953,400001)
17:02:20 <BMeph> , time (foldl (.) id (replicate 400000 succ) 1)
17:02:21 <codolio> Geeze.
17:02:22 <lunabot>  (0.358945,400001)
17:02:33 <mmorrow> , time (foldr (.) id (replicate 400000 (():)) [()])
17:02:35 <lunabot>  (0.0,[(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
17:02:38 <mmorrow> , time (length (foldr (.) id (replicate 400000 (():)) [()]))
17:02:41 <lunabot>  (3.3995e-2,400001)
17:02:44 <mmorrow> , time (length (foldl' (.) id (replicate 400000 (():)) [()]))
17:02:46 <lunabot>  (0.141978,400001)
17:03:15 <mmorrow> codolio: this is the coolest one i think:
17:03:23 <mmorrow> , time (foldr (.) id (replicate 400000 (():)) `seq` ())
17:03:25 <lunabot>  (0.0,())
17:03:26 <mmorrow> , time (foldl' (.) id (replicate 400000 (():)) `seq` ())
17:03:28 <lunabot>  (7.6989e-2,())
17:03:55 <mmorrow> , time (foldl' (.) id (replicate 800000 (():)) `seq` ())
17:03:58 <lunabot>  (0.418935,())
17:03:59 <mmorrow> , time (foldr (.) id (replicate 800000 (():)) `seq` ())
17:04:01 <lunabot>  (0.0,())
17:04:10 <codolio> Well of course the foldr version takes no time.
17:05:42 <mmorrow> i think it's interesting seeing how (.) has a tangible cost
17:05:51 <BMeph> Isn't "just enough" of the foldr done to assure that it can evaluate, then it goes on.
17:06:02 <BMeph> Er, s/./?/ :)
17:06:14 <codolio> Right.
17:06:21 <mmorrow> (i mean, of course it does, but it's kind of fuzzy exactly what it is, since it's always masked by some other cost)
17:06:52 <codolio> How are you measuring the cost of (.) here?
17:07:03 <mmorrow> time-wise
17:07:14 <mmorrow> , time (foldl' (.) id (replicate 800000 (():)) `seq` ())
17:07:16 <lunabot>  (0.415937,())
17:07:35 <mmorrow> , time (foldl' (+) 0 [1..800000])
17:07:37 <lunabot>  (0.144978,320000400000)
17:07:42 <codolio> Oh, there's no [].
17:07:54 <mmorrow> :)
17:08:52 <codolio> , [$ty| time |]
17:08:55 <lunabot>  forall a . a -> (Double, a)
17:09:13 <ezyang> Is (a,b) an instance of cat?
17:09:15 <mmorrow> it's one of the functions from the timeit pkg, unsafePerformIO'ed
17:09:32 <codolio> Yeah, yeah. You and your unsafe stuff.
17:09:48 <mmorrow> codolio: the bot is my convenient excuse ;)
17:09:52 <BMeph> Why would there be a []? The function's 'forced' to be constructed, but it's never used. ;)
17:10:29 <Polarina> In http://codepad.org/qUJdsu7D - what is that "null xs"?
17:10:49 <mauke> @src null
17:10:50 <lambdabot> null []     = True
17:10:50 <lambdabot> null (_:_)  = False
17:11:08 <mauke> a function call
17:11:09 <Axman6> ezyang: an instance of what?
17:11:11 <BMeph> Polarina: 'null' is a function that tells you whether or not its argument is an empty list. :)
17:11:13 <codolio> I was thinking the foldl' was fully applied, but it isn't.
17:11:17 <ezyang> Axman6: Category
17:11:24 <Polarina> BMeph: Ok, and the "||"?
17:11:34 <mmorrow> codolio: when i'm smote by a lightning bolt from vishnu, you can say "i told ya so"
17:11:41 <Axman6> Polarina: || is or
17:11:47 <Axman6> > True || False
17:11:49 <lambdabot>   True
17:11:49 <BMeph> Polarina: Logical "Or". :)
17:11:50 <codolio> Pairs are not a category.
17:11:55 <Axman6> > False || False
17:11:56 <lambdabot>   False
17:12:03 <Polarina> Ah.
17:12:05 <ezyang> codolio: Ok
17:12:19 <codolio> What would the identity pair be, for instance?
17:12:24 <Makoryu> > True || undefined
17:12:26 <lambdabot>   True
17:12:31 <Makoryu> > undefined || True
17:12:32 <lambdabot>   * Exception: Prelude.undefined
17:12:37 <mmorrow> (id,id)
17:12:49 <codolio> id :: (a, b)
17:12:50 <BMeph> Axman6: Thank you, you just solidified an objection I had to John Edwards' stuff. :)
17:13:03 <Axman6> eh? o.O
17:13:19 <mmorrow> id :: (a** Exceptio<<looSegmentation fault.
17:13:27 <Makoryu> Polarina: (||) in Haskell is exactly like (||) in C/Java/etc.... In fact, it's notable for being one of the few lazily evaluated constructs in such languages
17:14:27 <BMeph> Makoryu: You mean, Haskell's version not only works the same way, but has a non-nutty reason for _why_ it works that way. ;)
17:14:55 <Makoryu> BMeph: I was gonna let that go unsaid so people could work it out for themselves ;)
17:15:26 <codolio> ezyang: I should say, pairs are not morphisms for a category with haskell types as objects. There are categories with pairs of types as objects and pairs of morphisms as morphisms (the product category), but that's not how the Category class goes.
17:17:32 <hackagebot> synthesizer-core 0.2.1 - Audio signal processing coded in Haskell: Low level part (HenningThielemann)
17:17:33 <Polarina> What type is "Integral"?
17:17:40 <mauke> Polarina: none, it's a class
17:17:49 <Axman6> @instances Integral
17:17:50 <lambdabot> Int, Integer
17:18:02 <Axman6> @instances-importing Data.Word Integral
17:18:03 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
17:18:14 <Polarina> mauke: And what does that class do?
17:18:20 <Polarina> Ah.
17:18:22 <Axman6> @src Integral
17:18:22 <lambdabot> class  (Real a, Enum a) => Integral a  where
17:18:22 <lambdabot>     quot, rem, div, mod :: a -> a -> a
17:18:22 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
17:18:22 <lambdabot>     toInteger           :: a -> Integer
17:19:04 <Axman6> > quotRem 10 3
17:19:05 <lambdabot>   (3,1)
17:19:34 <Axman6> > toInteger (123 :: Word8)
17:19:35 <lambdabot>   123
17:28:59 <mc__> I'm the head of the I.T. department, trust me, if you type "google" into "google" you can break the internet xd
17:29:16 <Elly> define "break the internet"
17:29:19 <Polarina> Hmm.. Haskell doesn't appear to me much different from the procedural languages. There's just a certain "aspect" of it you need to drop and adopt from...
17:29:28 <Makoryu> mc__: My precious java googles!
17:30:42 <Philonous_> Polarina: Well, real programmers can write Fortran code in any language.
17:30:51 <mc__> Makoryu: haven't seen that episode yet :)
17:31:06 <Makoryu> mc__: I'm sure I have no idea what you're talking about
17:32:09 <mc__> Makoryu: oh alright, then check out "The I.T. Crowd" you can find it on tv.blinkx.com , it is great, since you're in this channel I'm quite sure you'll enjoy it
17:32:33 <Makoryu> I'll give it a shot, I guess
17:35:47 <mc__> hm funny i just wanted to join #c
17:35:54 <mc__> but I'm banned
17:35:57 <mc__> I wonder why
17:36:06 <Nafai> The IT Crowd is hilarious
17:36:15 <Axman6> Polarina: it really is quite different, and you'd do well to not try and rewrite yoyr imperatice code in haskell
17:36:16 <Nafai> Too bad I can't get it legitimately here in the US
17:36:23 <Makoryu> mc__: Nicks with double underscores are b& from ##C
17:36:26 <mc__> probably because the last time i wanted to join #c I too was drunk :D
17:36:34 <mc__> Nafai: yeah its great
17:36:36 <Botje> Nafai: i thought they were going to port it to the US?
17:36:43 <mc__> Makoryu: oh I see
17:36:48 <Nafai> I've heard such, but haven't seen anything more
17:36:53 <Polarina> Axman6: It is different. That "aspect" is the core of procedural languages, the rest stays the same or similar. :)
17:37:05 <Polarina> Axman6: I can't really explain that "aspect".
17:37:09 <Axman6> heh
17:37:48 <Polarina> :D
17:37:55 <Polarina> Anyway, Haskell's awesomely cool.
17:38:16 <Axman6> oh yes
17:39:13 <Philonous_> It lacks a decent type system, though.
17:39:29 <Polarina> Philonous_: Looks decent enough for me.
17:39:33 <Axman6> Philonous_: ha
17:40:20 <BMeph> It can't be that good, it doesn't let you have pointers! <ducks>
17:40:32 <Cale> I think that in consideration of more powerful type systems, the importance of type inference really has to be seriously considered.
17:40:37 <Philonous_> BMeph: Actually, it does.
17:40:38 <Cale> Also, Haskell does have pointers.
17:40:51 <Cale> And polymorphic malloc and free :)
17:41:27 <Polarina> Cale: What?
17:41:36 <Cale> Polarina: What what?
17:41:43 <BMeph> It makes you work too hard to get a Seg fault from it, so I don't trust it's doing things right... ;p
17:41:44 <Polarina> Cale: Are you fooling around with us? :P
17:41:48 <Axman6> what what warrttt?
17:41:50 <Cale> Polarina: Absolutely not.
17:41:55 <Axman6> </warcraft3>
17:41:59 <Polarina> Cale: Please explain then. :)
17:42:06 <Cale> Polarina: About the pointers?
17:42:07 <Philonous_> Cale.: To quite C.T. McBride: "Pragmatically, there is no reason why extensions of the type system which break type inference should preclude the use of type inference for `old' programs which sit within the sublanguage where inference remains possible.  If the machine is smart enough to figure out a program's type, by all means let it.  But if not, we must be able to say what me mean.  "
17:42:11 <Philonous_> quote*
17:42:12 <Axman6> Polarina: heh, Cale is the only one really speaking the truth at the moment :P
17:42:13 <Badger> Axman6: WartCraft?
17:43:00 <Axman6> Spot rocking the boat
17:43:05 <Axman6> Stop*
17:43:08 <Cale> Philonous_: Right, but preserving type inference for that fragment for which type inference works, and making type inference work well with extensions of the type system is (as far as I know), the direction of a lot of research still.
17:43:19 <Axman6> you're making me sea sick
17:43:55 <Cale> Polarina: See Foreign.Ptr and Foreign.Storable
17:44:27 <Cale> Also, Foreign.Marshal.Alloc
17:44:33 <Polarina> o.O
17:44:36 <Cale> :t Foreign.Marshal.Alloc.malloc
17:44:37 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO (GHC.Ptr.Ptr a)
17:44:51 <Axman6> Polarina: if you're new to haskell, you shoudl ignore all this however ;)
17:45:07 <Axman6> @instances-importing Foreign.Storable.Storable
17:45:08 <lambdabot> Bool, Char, Double, Float, Int
17:45:10 <Cale> Polarina: This sort of thing is necessary for interfacing with C libraries.
17:45:16 <mmorrow> Polarina: http://moonpatio.com/repos/ohhai.hs
17:45:18 <Polarina> Cale: Ah.
17:45:32 <Cale> Polarina: You can import and call any function in any C library.
17:45:45 <mmorrow> and you can arbitrarily manipulate memory
17:46:01 <Polarina> I think I would prefer to write a C code to make an Haskell interface instead. :P
17:46:18 <Cale> Nah, it's pretty nice really.
17:46:26 <Cale> Haskell makes a good C :)
17:46:30 <Polarina> :)
17:48:10 <mmorrow> Polarina: there's a runtime assembler package (only for x86 :(
17:48:38 <Axman6> harpy?
17:48:42 <mmorrow> yeah
17:48:58 <ksf> :t alloca
17:48:59 <lambdabot> Not in scope: `alloca'
17:49:07 <ksf> :t Foreign.Ptr.alloca
17:49:08 <lambdabot> Not in scope: `Foreign.Ptr.alloca'
17:49:11 <Polarina> All right, I am off to bed. Good night. :)
17:49:14 <Axman6> hmm, it'd be nice if there was something like that for LLVM (i know about the LLVM bindings, but i don't think they're the same)
17:49:15 <ksf> @hoogle alloca
17:49:16 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
17:49:16 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
17:49:16 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
17:49:38 <ezyang> Suppose I have a string "foo \"bar baz\" boo" and I want to get ["foo", "bar baz", "boo"] out of it; is there any built-in that does this?
17:50:22 <mmorrow> ezyang: no, but that should be fairly painless
17:51:03 <ezyang> Well, it sounds parsec level
17:51:14 <ksf> > readLitChar "foo \"bar baz\" boo"
17:51:16 <lambdabot>   [('f',"oo \"bar baz\" boo")]
17:51:26 <mmorrow> depending on whether you can additionally have arbitrarily nested \"\\\\\"\\\" stuff, a by-hand manual parser maybe be the easiest (and fastest)
17:51:42 <ksf> > lexLitChar "foo \"bar baz\" boo"
17:51:43 <lambdabot>   [("f","oo \"bar baz\" boo")]
17:51:55 <ksf> > lexLitChar "\"bar baz\" boo"
17:51:56 <lambdabot>   [("\"","bar baz\" boo")]
17:52:15 <ksf> well, you're going to have to fold over it manually, but the grunt work is done.
17:52:42 <mcfoobar> may someone recomend a channel for beeing drunk besides #c
17:52:47 <ManateeLazyCat> mmorrow: I try to compile http://moonpatio.com/repos/hs-instances/ , and i can't found Language.Haskell.Meta , which package including it?
17:52:52 <ezyang> I'm trying to figure out what that did...
17:52:56 <ksf> mcfoobar, #haskell-blah
17:52:56 <mmorrow> ezyang: here's a by-hand csv parser that's lightning fast e.g. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724
17:52:57 <mcfoobar> which is the best channel for being drunk I now tw
17:53:08 <Makoryu> mcfoobar: I seem to recall #lisp, #scheme, and #phpc being okay for it
17:53:09 <mmorrow> ManateeLazyCat: oh, it's in haskell-src-meta
17:53:16 <ManateeLazyCat> Thanks
17:53:19 <Makoryu> mcfoobar: But then, it depends on how you like to troll
17:53:21 <Axman6> mcfoobar: #windows
17:53:24 <mmorrow> ManateeLazyCat: welcome
17:53:36 <mcfoobar> ksf: Makoryu Axman6  thank you sirs
17:53:41 <mcfoobar> I dont like to troll
17:53:52 <mcfoobar> I just enjoy havin a (maybe silly) conversation
17:53:57 <Makoryu> mcfoobar: Then why are you looking for channels to be drunk in? :p
17:54:10 <Badger> maybe he's a jolly drunk!
17:54:12 <ksf> if you go to #haskell-blah and just post your coctail recepies people will love you.
17:54:13 <mcfoobar> Makoryu: oh you now, back in the old days
17:54:16 <ezyang> Ok, maybe I can make this problem statement a little simpler
17:54:20 <mcfoobar> there were a lot of drunk people in #c
17:54:29 <mcfoobar> talking about ponies
17:54:49 <mmorrow> @hackage pony
17:54:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pony
17:55:00 <ezyang> I have "\"foo bar\" other random garbage" and I want to get ("foo bar", "other random garbage")
17:55:02 <Makoryu> mcfoobar: Well now there's mainly just Zhivago, who steamrolls anyone whose C knowledge is not of a professional quality
17:55:13 <ezyang> Where foo bar is from a show "foo bar"
17:55:17 <mcfoobar> Makoryu: I'll definetly try #lisp cause there are some really nice people there
17:55:20 <ezyang> I imagine this'll be even simpler
17:55:21 <ManateeLazyCat> mmorrow: How to use your hstidy?
17:55:32 <mcfoobar> havent been there in a while
17:55:39 <mmorrow> ManateeLazyCat: it has a -h output, but basically:
17:55:53 <ksf> we need a bugfix for pony, btw, it's a unicorn.
17:56:10 <mmorrow> cat EXPRESSION.txt | hstidy -e
17:56:18 <mmorrow> cat PATTERN.txt | hstidy -p
17:56:31 <mmorrow> cat TYPE.txt | hstidy -t # err, i think there's a -t ?
17:56:38 <mmorrow> and no flag means a module
17:56:49 <mmorrow> ManateeLazyCat: for example
17:56:55 <ksf> while that might be regarded as a feature, there are serious compability problems with unicorns and iron, even worse with magnets.
17:58:15 <mmorrow> ManateeLazyCat:
17:58:17 <mmorrow> $ hstidy -e < $(dirname $(which ghc))/../lib/ghc*/package.conf
17:58:34 <mmorrow> parse package.conf (it's a haskell expression), and prettyprints it nicely formatted
17:58:41 <hackagebot> agum 2.1 - Unification and Matching in an Abelian Group (JohnRamsdell)
17:58:45 <mmorrow>  it's also nice to pipe into HsColour
17:58:55 <mmorrow>  hstidy -e | HsColour -tty | less -r
17:59:48 <mmorrow> ManateeLazyCat: so *any* type that's an instance of Show, you can do
18:00:02 <mmorrow> ghci> writeFile "asdf.hs" (show myHugeThing)
18:00:15 <mmorrow> then "$ hstidy -e < asdf.hs | HsColour -tty | less -r"
18:00:18 <Kaidelong> for a minute there I thought you guys were talking about unicon
18:00:27 <mmorrow> @hackage unicorn
18:00:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unicorn
18:00:37 <mmorrow> :) (not really :(
18:00:54 <mcfoobar> there is a unicorn package?
18:01:00 <Botje> there should be.
18:01:12 <mcfoobar> I dont care what it does
18:01:14 <mcfoobar> I want to install it
18:01:18 <mcfoobar> someone should make one
18:01:19 <mcfoobar> NOW
18:01:21 <mmorrow> i think the pony one is really like a ponycorn or something
18:01:33 <mcfoobar> ponycorn?
18:01:34 <mmorrow> BUT I WANT ONE NOWWWWW, DADDDDYYYY
18:01:57 <mmorrow> mcfoobar: there really is a pony package. you'll have to install it to see what i mean ;)
18:02:46 <mcfoobar> don't need a pony package
18:02:59 <mcfoobar> saying/writing the word pony alone is enough
18:03:06 <mcfoobar> already makes my heart fell warm
18:03:10 <mmorrow> you're missing out.
18:03:18 <Botje> but is it pink?!
18:03:35 <mmorrow> ooh, can i name it muffles!?!
18:04:04 <mcfoobar> what does muffles mean?
18:04:20 <mmorrow> hah, it's just what came out
18:04:29 <mcfoobar> ah sorry I meant: "what is the meaning of muffles"
18:04:34 <mcfoobar> bad germanism
18:04:39 <mmorrow> :o
18:04:48 <Nafai> mcfoobar: The first was fine.
18:05:01 <Nafai> mcfoobar: Probably more idiomatic, even :)
18:05:04 <kw317_> Charlie the unicorn ;-)
18:05:14 <Botje> the latter is more dramatic.
18:05:19 <mcfoobar> Nafai: really?
18:05:20 <ManateeLazyCat> mmorrow: I just interested how to pick speical instance information for generate template Haskell when compile-time. Find hstidy did same thing.
18:05:23 <Botje> WHAT IS THE MEANING OF .. MUFFLES!
18:05:24 <cygnus> If I want to export a public API from my modules but I still want to expose my low-level API for testing purposes (only), what's the best way to go about this?
18:05:25 <mmorrow> mcfoobar: ah, yeah the first one was more idiomatic
18:05:25 <wdonnelly> that pony package doesn't help much if you want to add unicorn-ponies to your own project
18:05:34 <Nafai> mcfoobar: At least to this American :)
18:05:37 <wdonnelly> where's the module for me to import?
18:05:51 <mcfoobar> I learnt at two shools in austria that "what does x mean" is NOT english
18:06:02 <Nafai> Weird
18:06:07 <mcfoobar> several different teacher told me so
18:06:15 <Kaidelong> you eastern kingdom people are crazy!
18:06:21 <Kaidelong> is fine english
18:06:30 <Nafai> I wonder how un-idiomatic the little German I've learnt is then :)
18:06:45 <Philonous_> I really like McBrides rant : "The point of treating type-level programming as programming is to _improve_ static behaviour: the static language should resemble the dynamic language, but without the criminal tendencies.  "
18:07:01 <Nafai> Philonous_: Ooo...where is this?
18:07:09 <Philonous_> http://www.mail-archive.com/haskell@haskell.org/msg10622.html
18:07:15 <mmorrow> ManateeLazyCat: so there are two programs. hstidy and hs_instance. hs_instances.hs is the one you'd want to start from to pull [(ClassName,ClassContext,InstanceType)] out of modules in order to then use that to build the haskell code for a (Map _ _)
18:07:46 <mcfoobar> Nafai:  well, say something and I'll tell you
18:07:59 <Nafai> mcfoobar: Unfortunately, it's been years and I can't remember much :)
18:09:33 <mcfoobar> Nafai: well don't bother, german isn't a great language anyways
18:09:51 <Kaidelong> all foreign languages are huge pains
18:09:55 <mcfoobar> even though it sounds funny when some german words/phrases are mixed into english xD
18:10:03 <mcfoobar> Kaidelong: german is my native tongue
18:10:11 <ksf> mcfoobar, no, it isn't.
18:10:17 <kw317_> Kaidelong: not really, some languages are quite easy
18:10:20 <lispy> cygnus: hi
18:10:27 <cygnus> lispy: yo
18:10:44 <ksf> that'd be like an american who claims being a native english speaker.
18:10:46 <mcfoobar> even though my english is far from good, I sometimes feel like I can express myself better in english then in german
18:11:02 <Kaidelong> kw317 if you're talking things like Afrikaans, Esperanto, Filipino or Vietnamese you'll have a hard time finding an institution that teaches it as a general education requirement
18:11:04 <mcfoobar> ksf: hehe :)
18:11:20 <Kaidelong> if you're talking about spanish or italian, I disagree
18:11:21 <mcfoobar> ksf: well , you know, I'm from a part of austria where we really speak german
18:11:47 <ksf> .oO a tourist center?
18:11:55 <mcfoobar> no, upper austria
18:12:02 <mcfoobar> that part that is close to germany
18:12:12 <ksf> higher than 2500metres, that is?
18:12:16 <mcfoobar> we have many dialects in austria, I understand most germans better than austrias
18:12:31 <mcfoobar> about  500 meters height here
18:12:47 <mcfoobar> and no, I dont see a mountain if I look out of the window
18:13:06 * ksf is actually living on one.
18:13:16 <ksf> ...10 m above the elbe.
18:13:49 <mmorrow> ManateeLazyCat: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3525#a3525
18:14:37 <mmorrow> ManateeLazyCat: (gotta run, but) then you'd take that data apart, pull out what you need, then build the haskell syntax for a (Map .. ..)
18:14:50 <ksf> but it wouldn't be right to blame southerners for their inability to speak german, anyway. The reasons are purely geological, after all: they don't have as wide a horizon.
18:15:11 <ManateeLazyCat> mmorrow: Looks very nice.
18:15:38 <mcfoobar> ksf: so you're from germany?
18:16:04 <ksf> in the broadest sense of the word, yes.
18:16:10 <Adamant> ksf: glad to see you know we only speak American here
18:16:37 <Adamant> none of that silly English stuff
18:16:50 <ksf> that is, I'm a Holstein with a birth sin: I was born in Hamburg.
18:17:23 <mcfoobar> ksf: okay, so about the german thing, in the part of austria I'm from we speak like the bavarians, but  I had the disabilty to do so, so I spoke the longest time of my life only "hochdeutsch" xD
18:17:55 <Adamant> ksf: who has Holstein now, ze Germans or the Danish?
18:18:35 <ksf> we're currently part-wise occupied by the preussians and danish, though the preussians occupy a bigger part.
18:18:45 <ksf> ...the danish only got north schleswig
18:18:49 <Adamant> ah
18:18:50 <mcfoobar> hehe
18:19:00 <Adamant> looking for independence eh
18:19:15 <mcfoobar> nothing makes me laugh like good old irc, you guys are great xD
18:19:22 <Adamant> :P
18:20:38 <ksf> well, at least south schleswig and holstein combined form a proper constitutional state, although we're not independent.
18:22:00 <ksf> how deep did we fall!
18:22:10 <ksf> ...we once invaded what's now called england.
18:22:36 <Adamant> was German ever taught widely abroad, besides as a foreign language option?
18:22:46 <ksf> (...where "invasion" doesn't mean slaughtering people but just looking way better than the native guys and thus getting all the girls)
18:23:19 <Makoryu> ksf: You mean the Angles and the Saxons? :p
18:23:22 <Peaker> Ausria?
18:23:23 <Adamant> it's on my list of languages to learn, I was wondering if there was any widespread speaking of German like what happened with Russian under the Soviets
18:24:37 <ksf> ...or english under the british.
18:24:57 <Adamant> right
18:25:02 <mcfoobar> Adamant:  well in austria we spoke german even before the 3rd reich xD
18:25:21 <Adamant> mcfoobar: well you guys were competing to lead Germany, it's just that Prussia won
18:25:32 <Makoryu> OR DID IT
18:25:35 <Axman6> hmm, i seem to have found myself in #languageandwarhistory
18:25:37 <Adamant> then Austria sort of won but not really
18:25:38 <Adamant> :P
18:25:40 <mcfoobar> at least we lead the 3rd reich xD
18:25:42 <Adamant> I'll quit
18:26:09 <ksf> yep, austrians are still wishing beethoven, goehte and schiller to be austrian and hitler to be german.
18:26:36 <mcfoobar> hehe
18:27:10 <mcfoobar> we're just hard trying to get the rest of the world to belive so
18:27:18 <mcfoobar> we dont care, its just about the tourism you know
18:27:41 <Nafai> Yay beethoven
18:27:43 <ksf> and austria lost its biggest asset, there, too: hungarian saussages.
18:28:06 <mcfoobar> austrias biggest asset is the schnitzel
18:28:46 <mcfoobar> have you guys ever eaten a good schnitzel? I turned vegetarian a few weeks ago but a schnitzel is really a great thing to eat
18:29:41 * ksf prefers steakburgers, like burgers were intended to be since their conception.
18:30:14 <ksf> (someone around hamburg had a steak an a bun, and decided it'd be a good idea not to burn his fingers)
18:30:20 <mcfoobar> eating animals is bad anyway
18:30:27 <mcfoobar> though they taste great
18:32:36 <SamB_XP> it's got to be better than eating eggplants!
18:32:44 * SamB_XP had eggplant for supper :-(
18:36:32 <SamB_XP> are you folks krauts?
18:37:10 <ksf> are you a hotdog?
18:37:42 <Lycurgus> yello
18:38:12 <SamB_XP> someone in -blah was asking if the krauts were still monopolizing the channel ;-P
18:38:38 <Vanadium> The krauts are all asleep, I would wager
18:39:20 <ksf> Vanadium, you are contradicting yourself.
18:39:40 <Vanadium> Or should be anyway
18:43:14 <mcfoobar> SamB_XP: well I'm a upper austrian
18:43:21 <mcfoobar> I ate kraut last week
18:43:29 <mcfoobar> does that make me a kraut?
19:18:41 <lispy> good evening
19:18:54 <mcfoobar> good evening Liskni_si
19:18:59 <mcfoobar> sry, I meant lispy
19:19:19 <mcfoobar> damm auto-complete, you should put those who spoke last at top
19:19:21 <lispy> anyone want to work on a cool new feature for darcs?  I see that hg has Bonjour support for sharing patches and discovering other hg users.  Bring that to darcs!
19:19:58 <mcfoobar> want: yes, can do: dont know xD
19:20:21 <lispy> if hg can do it, so can we :)
19:20:25 * Peaker is a git user
19:20:37 * dancor same (sorry to rain on parade)
19:21:05 * ksf rarely uses rcs
19:21:11 <mcfoobar> well, I'm on osx but I've only used darcs a while ago, I'm not familiar with the internals
19:21:12 <dancor> ksf: !
19:21:14 <Peaker> ksf: seriously?
19:21:21 <mcfoobar> and I'm a novice haskell pogrammer
19:21:23 <ksf> ...I tend to make backups before going on to refactor big stuff.
19:21:43 <dancor> adding things to darcs is kind of still more lucrative to me than adding things to git
19:22:02 <ksf> you know, cvs was basically the only rcs available when I started coding, and that one is a pain.
19:22:23 <dancor> ksf: rcs changed my life for the infinite better
19:22:29 <lispy> likewise
19:22:47 <dancor> even seeing what i've changed since my last checkpoint commit
19:22:50 <dancor> is worth a lot
19:22:50 <lispy> ksf: darcs is easy to pickup/learn for casual vcs users
19:23:07 <lispy> ksf: (I'm biased as a darcs dev, just so you know)
19:23:10 <ksf> I _know_ how to use git, it just doesn't fit into my workflow.
19:23:17 <mcfoobar> yeah thats true, darcs is really easy and offers some great features
19:23:33 <mcfoobar> though I prefer git now, I too state that darcs is really goo
19:23:34 <mcfoobar> d
19:23:36 <kmc> ksf, why not, it fits with a lot of workflows
19:23:51 * Axman6 won't use git because linus wrote it
19:23:55 <Axman6> what a jerk
19:24:04 <lispy> mcfoobar: are there specific things that would make darcs appeal more than git?
19:24:13 <lispy> mcfoobar: things that we could add/change?
19:24:54 <mcfoobar> lispy: well, at first I have to say that I'm a novice sw-dev so you proablaby should not give  to much on my word
19:25:02 <mcfoobar> cause I might be an idiot as well
19:25:08 <ksf> lispy, a gui.
19:25:09 <lispy> heh
19:25:22 <mcfoobar> but in my opinion git generally performs a lot faster
19:25:22 <copumpkin> moo
19:25:24 <lispy> ksf: which platform are you on?
19:25:27 <ksf> linux
19:25:35 <mcfoobar> an is especially better at resolving conflicts
19:25:55 <mcfoobar> i have the feeling that darcs often presented me conflicts while git could solve them automatically
19:25:57 <lispy> mcfoobar: thanks
19:26:08 <ksf> ...even if it's just to learn the ropes of the command line interface while seeing what you're doing.
19:26:35 <lispy> mcfoobar: hmm..that last bit may be inaccurate.  Or perhaps in the darcs-2 format repos you'd experience that less...Not sure.
19:26:47 <kmc> ksf, i rarely use the gui for manipulating git, but it's essential for viewing history i think
19:27:06 <ksf> and then there's of course the big topic of language-aware diffing.
19:27:13 <kmc> (and by gui i include a sufficiently good visual representation whether it's X or terminal based)
19:27:17 <ksf> ...not only whitespace awareness, but say alpha renames.
19:27:21 <lispy> there have been various attemps to make a GUI for darcs.  For some reason they never get maintained
19:27:32 <ksf> but we need better refactoring support, anyway.
19:27:45 <ksf> kmc, ack.
19:28:06 <mcfoobar> lispy: well I stopped using darcs about a good year ago
19:28:23 <ksf> ...and leksah needs an integrated yi.
19:28:27 <Peaker> Axman6: that's a silly reason not to use software
19:28:30 <mcfoobar> things may have changed since than, and anyways it is just my personal "feeling"
19:28:37 <ksf> that would speed up the development of both considerably.
19:28:45 <lispy> mcfoobar: FWIW, performance will improve a lot in 2.4 and beyond.  I'm really hoping we catch up to git, but who knows :)
19:28:45 <Axman6> i don't like encouraging linus
19:29:05 <Peaker> Axman6: heh
19:29:41 <mcfoobar> lispy: well it will be hard to catch up with c code, but performance probably isn't the most important thing
19:29:51 <ksf> urks.
19:29:55 <lispy> mcfoobar: why will it be hard to catch up to c code?
19:30:12 <lispy> ?faq Can Haskell be faster than C?
19:30:12 <lambdabot> The answer is: Yes! Haskell can do that.
19:30:13 <ksf> why do I have to enable gtk2hs' _gnome_ use flag to get gtksourceview?
19:30:27 <mcfoobar> well as most benchmarks suggest haskell can come near to c performance
19:30:40 <mcfoobar> but only if you basically write c in haskell
19:30:41 <Axman6> mcfoobar: haskell can be very fast, often slightly slower than C, sometimes faster
19:31:01 <dancor> i think it's very hard to make haskell competitive with c in general
19:31:17 <mcfoobar> Axman6: yeah, but not with beautiful code I think, I might be wrong thoug
19:31:18 <lispy> mcfoobar: the reason darcs is slow is actually because of the way it processes data and the algorithm.  It has highly optimized parsing, it just parses way more than it should.
19:31:20 <ksf> haskell _is_ competitive to c.
19:31:31 <kmc> grr
19:31:36 <kmc> "ghc is competitive to gcc"
19:31:42 <kmc> sorry, this is a new pet peeve of mine
19:31:42 <ksf> yep.
19:31:53 <dancor> http://shootout.alioth.debian.org/u64q/shapes.php
19:31:58 <Axman6> mcfoobar: http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/
19:32:05 <Twey> GHCi is obviously competitive with Ch.
19:32:05 <kmc> to contribute something more worthwhile than semantic gripes:
19:32:10 <ksf> add loop unrolling, and ghc might produce faster code than gcc for a lot of programs.
19:32:15 <kmc> has anyone fed GHC via-c into Intel's C compiler recently?
19:32:16 <mcfoobar> Axman6: well that is probably very interesting
19:32:28 <Axman6> mcfoobar: just read it
19:32:35 <mcfoobar> well
19:32:37 <lispy> kmc: I don't think it could handle it.  GHC emits code with gcc-isms
19:32:39 <mcfoobar> you know
19:32:42 <kmc> a lot of people i know feel that icc is vastly superior to gcc
19:32:43 <Axman6> you'll see that by using better algorithms, you can make code faster than C
19:32:54 <kmc> icc supports some of the gcc-isms, and probably has equivalent constructs for others
19:32:56 <dancor> but you can use the same algorithms in c
19:33:02 <kmc> it'd be an interesting project, i think
19:33:02 <mcfoobar> I'm just drinking my 6th beer, and I had 2 whiskeys and 2 tequilas at a bar
19:33:07 <mcfoobar> so nah xD
19:33:07 <arw_> lispy: icc does gcc-isms, for example for linux-kernel-support.
19:33:16 <lispy> ah, I see
19:33:18 <ksf> the c backend should actually be intended for portability.
19:33:23 <Makoryu> dancor: Frequently at the cost of having your C code actually be readable.
19:33:46 <ksf> ...they should just abandon any performance hacks with the new codegen and produce 100% ansi c.
19:33:47 <dancor> Makoryu: but i also think optimizing haskell to that extent frequently becomes extremely nonidiomatic
19:33:49 <Makoryu> dancor: When you're using C as a back end language, there's absolutely no concern as to maintainability
19:34:02 <lispy> I would love to have a shootout comparing vcs performance
19:34:12 <lispy> sadly, not enough hours in the day to make it
19:34:14 <kmc> ksf, there are a few really essential hacks.
19:34:15 <ksf> ...which has the nice property that you can ship ghc compiled to c to bootstrap itself.
19:34:30 <kmc> i'd support an ANSI C mode plus a gcc mode, and maybe others
19:34:44 <kmc> not sure if it already works this way
19:34:44 <Makoryu> lispy: So send out a call to arms, and get others to do it for you
19:34:46 <mcfoobar> has ghc got an llvm backend?
19:34:51 <Makoryu> lispy: I'm sure people would be into that
19:34:53 <dancor> i think it will always be true that you have to be much better at haskell to make really fast haskell programs than is true for c
19:34:58 <kmc> also, there are other backends... yeah, what mcfoobar said ;P
19:34:59 <lispy> Makoryu: thank you for volunteering ;)
19:34:59 <arw_> kmc: question is, would the gcc mode give any speed benefit?
19:35:09 <ksf> the yhc (iirc) guys argued against using llvm for haskell
19:35:10 <Makoryu> mcfoobar: Simply by the fact that it can compile via clang, yes
19:35:20 <lispy> Makoryu: joking aside, where would I send it?
19:35:23 <kmc> arw_, over ANSI C? definitely
19:35:23 <Makoryu> (OR CAN IT?)
19:35:25 <ksf> ...or was it lhc?
19:35:40 <Makoryu> lispy: Oh, you could probably get redditors to do it
19:35:41 <mcfoobar> dancor:  I'm not sure
19:35:50 <mcfoobar> if you do not know C well
19:35:51 <ksf> is speed important if you only use the c backend to bootstrap the compiler on systems without ghc installed?
19:35:56 <kmc> register globals, direct tail-calls, fomit-frame-pointer, and the evil mangler
19:35:57 <mcfoobar> your programm can become slome very fast
19:36:05 <mcfoobar> s/slome/slow
19:36:10 <kmc> (the last of course depends on ghc-specific code, as well as gcc support)
19:36:14 <lispy> kmc: IIRC evil mangler is no more?
19:36:18 <kmc> maybe
19:36:27 <Makoryu> dancor: On the other hand, even if that's true, you have to be a lot better at C to make safe C programs than safe Haskell programs
19:36:27 <dancor> i'm talking in the have-used-it-for-two-years range
19:36:28 <kmc> i'm reading old papers
19:36:34 <dancor> Makoryu: agreed
19:36:42 <Makoryu> dancor: And those take forever to write....
19:36:46 <Peaker> you ought to be "good at C" anyway :)
19:36:46 <ksf> stalin ships like that: a .scm file, and a c file that is compiled from the scm.
19:36:51 <dancor> Peaker: right
19:37:06 <Peaker> everyone ought to know C well, IMO (At least until some better language fills that niche)
19:37:17 <mcfoobar> asm
19:37:36 <Makoryu> Peaker: I would love to see another language replace C>
19:37:44 <dancor> maybe BitC
19:37:47 <Makoryu> An imperative, non-GCed, non-OO language
19:38:05 <arw_> Peaker: nack. i know many people who shouldn't ever have known c, because they program c-isms in other languages then.
19:38:06 <ksf> ...statically typed.
19:38:08 <mcfoobar> why not GCed`?
19:38:18 <ksf> something like a strict haskell might work well
19:38:22 <Makoryu> mcfoobar: Real-time performance reasons
19:38:29 <Makoryu> ksf: That's the idea behind BitC, isn't it?
19:38:37 <ksf> yep but bitc is dead
19:38:43 <ksf> ...and timber has a gc
19:38:54 <mcfoobar> well a good gc shouldn't actually hurt performance
19:39:00 <dancor> bitc is dead?
19:39:01 <kmc> Makoryu, why leave out OO when you can get a lot of it as sugar compiling to the same output?
19:39:04 <Peaker> dancor: bitC is apparently dead
19:39:06 <ksf> but gc works, as long as you're not gooing _extremely_ low level or low end.
19:39:19 <arw_> mcfoobar: it shouldn't hurt, but you can't guarantee it, thats the problem.
19:39:25 <ksf> kmc, because of c++.
19:39:27 <Peaker> arw_: I disagree. Knowing C doesn't mean you write C in every language.. especially if you learn it after other languages
19:39:30 <Makoryu> kmc: I think forcing everything to be OO-friendly is unscientific and ultimately destructive.
19:39:31 <mcfoobar> kmc: well, with c++ the RTTI is one of the major reasons why c++ is slower then c
19:39:38 <ksf> ...and because oo gets way too many things wrong.
19:39:40 <kmc> ksf, ??? c++ is the only way to implement OO?
19:39:43 <Peaker> mcfoobar: A good GC hurts some aspects of performance by amortizing memory management times
19:39:45 <ksf> nope.
19:39:46 <kmc> urgh
19:39:52 <mcfoobar> c++ ist not really OO at all
19:40:18 <ksf> plain and simple typeclasses are more than enough.
19:40:26 <Makoryu> Peaker: Of course, even with explicit memory management you have to make sure your allocator is friendly with your particular memory management needs
19:40:29 <Peaker> mcfoobar: It is also harder to get guarantees about memory management with GC than without (in C, if you use strict memory pools for various allocations, rather than malloc, your leaks can be contained, and you have more mm guarantees, for example)
19:40:30 <Twey> mcfoobar: OO doesn't exist
19:40:41 <kmc> mcfoobar, that's what i mean... lightweight OO without things like RTTI and virtual methods
19:40:41 <Peaker> Makoryu: IME, people who care write their own allocators
19:40:45 <Makoryu> Using the standard malloc() for everything is *also* unscientific and ultimately destructive
19:40:47 <mcfoobar> arw_: Peaker well in theory a GC could improvce performance by reducing fragmentation
19:40:48 <kmc> (though people use virtual methods in C quite often as well)
19:40:50 <arw_> Peaker: well, of course 'many people' is not the same as 'all people'. but then i think most of those people shouldn't ever have learned anything about oop, too.
19:40:53 <Makoryu> Peaker: Yes! They can.
19:41:06 <ksf> ...in fact, a static-memory, strict version of haskell would be cool as a sublanguage.
19:41:08 <mcfoobar> kmc: objective-c?
19:41:17 <ksf> e.g. to implement the whole of the rts.
19:41:20 <Peaker> arw_: I think people who "write C in every language" are people who only ever really learned C
19:41:22 <mcfoobar> Twey: you're a zen-buddhist I suppose?
19:41:25 <dancor> ksf: strict haskell is a contradiction of terms
19:41:26 <Twey> http://apocalisp.wordpress.com/category/philosophy/epistemology/
19:41:28 <Peaker> arw_: and then got "exposed" to some other languages without learning them
19:41:32 <arw_> mcfoobar: performance is not the issue. real-time means that you can guarantee things like "this function will never take more than 200ms".
19:41:37 <Twey> mcfoobar: Heh.
19:41:41 <kmc> mcfoobar, never used it. thought it's all dynamic dispatch
19:41:45 <arw_> mcfoobar: and thats very hard to do with a gc.
19:41:50 <Makoryu> dancor: Sure, it would be more ML than Haskell, at least in the semantics department
19:41:52 <Peaker> arw_: that's "hard real time"
19:41:58 <Peaker> arw_: soft real time doesn't mean much, iirc :)
19:41:59 <kmc> arw_, or 50 us :)
19:42:03 <ksf> arw_, it's trivial when you can guarantee that the gc won't run.
19:42:22 <Peaker> mcfoobar: GC amortizes. That's not good for hard real-time-ness
19:42:23 <mcfoobar> arw_: oh i see, well at least python offers ways to temporally  disably the gc
19:42:23 <kmc> Makoryu, ML with typeclasses and Haskell syntax is a major improvement over ML :)
19:42:32 <arw_> ksf: yes, but you can only guarantee that if there is enough freed memory.
19:42:38 <Peaker> kmc: and purity
19:43:00 <ksf> ...and by continuously doing gc runs during idle time you should be able to do that.
19:43:02 <dancor> changing just the syntax of ml to haskell is trifling
19:43:04 <mcfoobar> Twey: or what did you mean by "there is no OO" ?
19:43:08 <arw_> mcfoobar: the java-vm does, too. but its not possible to permanently disable it, because all of your memory would get eaten up.
19:43:15 <Twey> mcfoobar: 03:41:33 < Twey> http://apocalisp.wordpress.com/category/philosophy/epistemology/
19:43:22 <ksf> if everything else fails, you can reserve some static memory for that function
19:43:27 <Makoryu> kmc: I wholeheartedly agree :p
19:43:37 <Makoryu> kmc: I'd like to see a C with Haskell's type system.
19:43:43 <Peaker> also, C is not just great for controlling memory management, but you have to rely far less on the optimizer. When you want to guarantee a code path is cheap, its pretty easy to do so
19:43:54 <mcfoobar> arw_: of course, but maybe only parts of your programm need to run in real time
19:44:00 <dancor> Makoryu: reviving bitc is the best way to do that right?
19:44:03 <Peaker> mcfoobar: not necessarily
19:44:03 <Makoryu> Peaker: Yeah, that makes C a good back end language
19:44:06 <kmc> lispy, i thought the point of EM was to glue infotables to their entry code, so there's one less indirect in the common case.  if there's now a fancy way to do this in GCC directly, i'm interested
19:44:13 <Peaker> Makoryu: For a compiler?
19:44:17 <Makoryu> dancor: Well, not exactly
19:44:18 <mcfoobar> than you can simply achieve that by temporally  disabing the gv
19:44:19 <arw_> Peaker: soft realtime means, that its ok to miss a certain percentage of those time-limits. and of course missing those time-limits won't be life-threatening. like in playing audio or something.
19:44:21 <Makoryu> Peaker: Yes.
19:44:36 <kmc> a big problem in C is the amount of casting and aliasing you can do, which really hurts optimization
19:44:43 <mcfoobar> besides, for java there some specialed realtime vm's from, for example frm bea weblogic
19:44:50 <Peaker> Makoryu: its also good (well, it sucks, but no alternative exists that I know of) when you are competing over <20% performance differences, trying to get operations to run in as few microseconds as possible, etc
19:45:02 <|Steve|> What does import qualified do?
19:45:04 <arw_> mcfoobar: if there are real-time and non-real-time parts you usually separate them into different programs.
19:45:21 <mcfoobar> Peaker:  what not necessarily?
19:45:31 <Peaker> Makoryu: And when you really want to *know* that there are no leaks (much easier to test/verify on a C program that uses its own allocators than a Haskell program, for example. Though of course, verifying correctness becomes harder
19:45:40 <arw_> mcfoobar: because a screwup in the non-real-time part won't cause problems in the real-time part then. usually that separation is also a requirement.
19:45:43 <ksf> |Steve|, it doesn't mix namespaces.
19:45:44 <Peaker> mcfoobar: Because sometimes almost all of your code has to be "realtime"
19:45:55 <dancor> |Steve|: like how do you use it?  http://www.haskell.org/tutorial/modules.html
19:46:01 <ksf> ...that is, you have to fully qualify everything you want to use from that module.
19:46:13 <mcfoobar> okay, well than maybe haskell isn't suited for realtime programms
19:46:13 <|Steve|> I see.
19:46:19 <ksf> it's usually used in cases like import qualified Data.Map as M
19:46:24 <Peaker> Makoryu: lambdabot, for example, has to be restarted once in a while because of some leaks
19:46:24 <mcfoobar> but the problem is not with gc pe se as java demonstrates
19:46:31 <ksf> ...as that module clashes a lot with the prelude.
19:46:39 <|Steve|> How does import Data.Map as M differ from import qualified Data.Map as M?
19:46:42 <kmc> |Steve|, you can also use "as" without qualified, in which case you get to use your "as" name to disambiguate where there are conflicts
19:46:51 <Makoryu> Peaker: Yeah. That's why I want a new C, rather than a new Haskell.
19:46:55 <Gracenotes> |Steve|: unqualified, it is also imported into the global namespace
19:46:57 <ksf> the former still mixes namespaces.
19:46:58 <kmc> |Steve|, in the former you can use Data.Map names unqualified, as long as there is no confilct
19:47:04 <mcfoobar> you guys now what, i have been drunk in bars taling about politics, and drunk at parties
19:47:05 <Makoryu> Haskell is a great Haskell, but not exactly the best C
19:47:06 <|Steve|> Gotcha, okay.
19:47:06 <Peaker> |Steve|: All modules you import are *also* imported Qualified.  If you use "qualified' then they don't mess up your namespace in addition
19:47:10 <mcfoobar> but being drunk here is more fun xD
19:47:13 <arw_> mcfoobar: java is also not suited for hard realtime. the only kind java does is the soft kind.
19:47:27 <mcfoobar> so, prost!(cheers in austrian german xD)
19:47:31 <Gracenotes> in the case of a conflict, the qualified name will work too. And in any case, the fully qualified name (Data.Map.blah) will always work. I think.
19:47:34 <kmc> mcfoobar, :D
19:47:36 <Peaker> I wish "qualified' was Haskell's default
19:47:41 <mcfoobar> arw_: yeah thats true
19:47:45 <Peaker> Though maybe it would be nice if "." wasn't ambiguous
19:48:15 <Gracenotes> map (Just.negate) [1,2,3]  :o
19:48:19 <mcfoobar> for  hard realtime you need a speciaized os anyways so probably the programing language does not really matte
19:48:28 <mcfoobar> cause you have to use what is avaible there
19:48:35 <|Steve|> @pl \x -> f y x (g x x)
19:48:35 <lambdabot> f y `ap` join g
19:48:55 <|Steve|> Heh, that's totally unreadable to me.
19:48:57 <Makoryu> Ooh, it uses infix notation now!
19:49:07 <Makoryu> |Steve|: Hmm, you new to Haskell?
19:49:08 <arw_> mcfoobar: correct. usually the os is just some library plus some interrupt handlers.
19:49:10 <Makoryu> @src ap
19:49:10 <lambdabot> ap = liftM2 id
19:49:25 <mcfoobar> lispy: have you already found someone to work on the bonjour integration with darcs?
19:49:28 <|Steve|> Makoryu: Not really new, no. I just don't use it often.
19:49:40 <Gracenotes> |Steve|: I'd tend to use the ap equivalent, <*>, so it looks like f y <*> join g. But that still looks daunting if you're not familiar with the classes -_-
19:49:46 <|Steve|> I can never recall what ap does and liftM2 id doesn't really tell me much.
19:49:50 <mcfoobar> so #haskell
19:49:50 <sohum> :t <*>
19:49:51 <lambdabot> parse error on input `<*>'
19:49:52 <Makoryu> :t ap
19:49:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:49:56 <kmc> @src liftM2
19:49:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:49:56 <sohum> :t (<*>)
19:49:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:50:00 <mcfoobar> do you have a favourite whiskey?
19:50:02 <ksf> in practice, though, you can get java not to stutter when you need constant fps.
19:50:18 * kmc hands lambdabot a glass of whiskey
19:50:25 <Makoryu> :t \x y -> id x y
19:50:26 <lambdabot> forall t t1. (t -> t1) -> t -> t1
19:50:29 <|Steve|> I've never used Applicative, for example.
19:50:30 <kmc> mcfoobar, i prefer to mix my haskell with experimental hallucinogens
19:50:39 <ksf> ...allocating everything you can statically, and running the gc every frame, so that objects allocated by library calls don't pile up.
19:50:55 <mcfoobar> kmc: well i tried hallucinogens
19:51:05 <Gracenotes> kmc: functional alcoholic, eh?
19:51:05 <mcfoobar> but never mixed it with haskell
19:51:12 <mcfoobar> might be an intersting experience
19:51:12 <Gracenotes> sorry. I just love that pun.
19:51:14 <|Steve|> :t join
19:51:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:51:18 <kmc> (there was sort of an uncanny overlap between the two interest groups at my school)
19:51:28 <Makoryu> |Steve|: join f x = f x x
19:51:29 <kmc> Gracenotes, :D
19:51:37 <Makoryu> |Steve|: ....At least for functions.
19:52:35 <|Steve|> Makoryu: That's not at all obvious to me from the type signature.
19:52:58 <kmc> |Steve|, do you know about the ((->) r) monad?
19:53:02 <|Steve|> I do not.
19:53:06 <Makoryu> |Steve|: Me either. It would help if we had memorized the ((->) r) monad :p
19:53:14 <kmc> well,  ((->) r) is a monad :)
19:53:34 <Makoryu> :t \f x -> join f x
19:53:34 <|Steve|> :t (->)
19:53:35 <lambdabot> parse error on input `->'
19:53:36 <lambdabot> forall t a. (Monad ((->) t)) => (t -> t -> a) -> t -> a
19:53:36 <kmc> meaning, (r -> a) is a type like (Maybe a), just a little different because of the infix
19:54:14 <Makoryu> :t \a b -> ap a b
19:54:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:54:20 <Makoryu> Dangit
19:54:47 <copumpkin> :t ap
19:54:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:54:52 <copumpkin> zomg!
19:54:58 <lispy> wait, wait
19:54:59 <copumpkin> Makoryu needs moar reduction
19:55:02 <lispy> ?pl \a b -> ap a b
19:55:02 <lambdabot> ap
19:55:19 <Makoryu> @pl \f x -> join f x
19:55:19 <lambdabot> join
19:55:23 <lispy> ?unpl ap
19:55:23 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
19:55:33 <lispy> unpl does undo too?
19:55:36 <lispy> ?undo pl
19:55:37 <lambdabot> pl
19:55:40 <lispy> ?undo ap
19:55:40 <lambdabot> ap
19:55:42 <lispy> hmm
19:56:03 <lispy> ?unpl >=>
19:56:03 <lambdabot> (>=>)
19:56:04 <ksf> cabal fails to install leksah, right now.
19:56:33 <Makoryu> @do (\d e -> d >>= \b -> e >>= \a -> return (b a))
19:56:33 <lambdabot> (\d e -> d >>= \b -> e >>= \a -> return (b a)) not available
19:56:37 <ksf> ...the problem is regex-base == 0.72.0.2, which clashes with the >= constraints on regex-posic and regex-compat
19:56:37 <Makoryu> FINE
19:57:15 <SubStack> serializing functions is hard
19:57:36 <SubStack> I understand why it should be hard.
19:57:36 <arw_> .oO( not in scheme )
19:57:43 <kmc> SubStack, yhc claims to do it iirc
19:58:02 <SubStack> I have read of those claims.
19:58:04 <Makoryu> :t let ap d e = do { b <- d; a <- e; return (b a) } in ap
19:58:05 <lambdabot> forall (m :: * -> *) t b. (Monad m) => m (t -> b) -> m t -> m b
19:58:22 <Makoryu> :t ap
19:58:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:59:58 <SubStack> if only it were just a little less hard...
20:00:55 <SubStack> ffi might do what I want
20:01:24 <SubStack> so long as I'm careful about updating the program
20:02:06 * ksf doesn't feel like hacking .cabal files right now and gets leksah-head from darcs...
20:43:15 <karlw> I'm having trouble installing the Haskell platform. I get an error saying that Setup ``doesn't exist or cannot be run'' for mtl after I run ``make install''
20:44:39 <|Steve|> Bah, I'm getting an ambiguous occurrence of !. It could be Array.!, Map.!, or UArray.!.
20:45:44 <ksf> hmmm leksah-head has an option that claim to enable yi, but it doesnt' seem to do anything.
20:45:52 <ksf> ...I don't even get an error, that is.
20:46:31 * ksf thinks |Steve| is using too many data structures in one place
20:48:09 <|Steve|> Only Data.{Array,Bits,List,Maybe,IntMap} and Data.Array.{IArray,Unboxed,ST} .
20:51:49 <|Steve|> Now it's complaining that I'm applying sequence_ to too many arguments. Is this not valid? do sequence (do x <- xs; ...stuff with x producing a list); foo?
20:51:53 <|Steve|> er, sequence_
20:52:46 <|Steve|> A ha, adding an explicit semicolon after the parenthesized do statement seemed to fix that problem.
20:55:38 <ksf> well, do uses layout.
20:56:12 <|Steve|> foo was lined up with sequence_, not with (do ...).
20:56:15 <ksf> it's considered good style to either use do, _and_ use layout, or use explicit >>='s if you don't want to use layout.
20:56:51 <kmc> or other combinators
20:56:58 <ksf> you don't need to lineup with do, but stuff that belongs to a do has to be lined up.
20:57:47 <|Steve|> Nothing was lined up with do. It was do sequence_ (...) and then lined up with sequence_ was foo.
20:58:43 <|Steve|> @type newArray
20:58:44 <lambdabot> Not in scope: `newArray'
21:06:41 * ksf thinks cabal should automagically re-configure with the old settings if you change the .cabal file and hit cabal build.
21:22:08 <|Steve|> "Could not deduce (MArray (STArray s) (Maybe (IM.IntMap Int)) Maybe) from the context ()" What does that mean?
21:25:24 <lispy> |Steve|: it means that the type class inference failed
21:26:04 <lispy> |Steve|: some how there is no type class context (the context ())
21:26:21 <lispy> But, then i don't really know which class that would even be using those all look like types...
21:27:32 <|Steve|> The problem comes from my use of a function defined in a where clause. When I pull it out, ghc gives me the type (MArray a (Maybe (IM.IntMap a1)) Maybe, Num a1, MArray a (Maybe (IM.IntMap a1)) t) => a Int (Maybe (IM.IntMap a1)) -> Int -> t ()
21:27:56 <|Steve|> I have no idea at all if that is correct. =(
21:28:16 <lispy> |Steve|: I'd have to see the code to help
21:28:53 <|Steve|> No worries. I think I'm going to grab some food instead of dealing with this more.
21:28:53 <redline6561> Quick question, Does anyone see an indentation problem between lines 20-26 of this paste? (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9094#a9107) GHC is complaining about 26 in particular...
21:28:57 <mle> What's the right way to convert between different kinds of bytestrings?
21:29:32 <mle> i.e. if I have a bytestring.lazy of word8's and I need to suddenly interpret part of it as potentially utf8 characters?
21:29:42 <araujo> anybody knows what SNS development means?
21:30:00 <lispy> redline6561: it's a syntax problem in this case
21:30:11 <redline6561> lispy: What should I have?
21:30:32 <lispy> redline6561: let's start with the type of loadCalls
21:30:48 <lispy> redline6561: is it pure or monadic?
21:31:00 <lispy> redline6561: that readFile you do looks monadic
21:31:06 <lispy> :t readFile
21:31:07 <lambdabot> FilePath -> IO String
21:31:26 <redline6561> lispy: yes. it takes a csv filepath, reads the file and insert certain values into a map
21:31:46 <mcfoobar> lispy: ping
21:31:51 <Axman6> :t lines
21:31:52 <lambdabot> String -> [String]
21:32:06 <Axman6> :t lines (readFile "foo")
21:32:07 <lambdabot>     Couldn't match expected type `String'
21:32:07 <lambdabot>            against inferred type `IO String'
21:32:07 <lambdabot>     In the first argument of `lines', namely `(readFile "foo")'
21:32:15 <lispy> let strs = lines (readFile file), that's probably supposed to be do strs <- lines `fmap` (readFile file)
21:32:16 <redline6561> lispy: the program as a whole should do this for every csv file in the directory it's run in, do some calculations on the map and then spit out results
21:32:18 <lispy> mcfoobar: hi
21:32:37 <Axman6> redline6561: have you used IO in haskell before?
21:33:03 <redline6561> Axman6: once. 6 months ago. I've forgotten. :( Sorry.
21:33:21 <lispy> mcfoobar: did you have something you want to talk about?
21:33:22 <Axman6> well, you can't do lines (readFile file)
21:33:22 <mcfoobar> lispy: hi, have you already found someonw woking  on  bonjour support for darcs?
21:33:51 <redline6561> Axman6: I understand. Thanks for your help. When I get caught in the mazes I'll come back with more questions. :)
21:33:56 <lispy> mcfoobar: oh, no we haven't.  I mentioned it recently on the darcs-user mailing list and one person suggested using the Giver library instead, but no one has started on it yet
21:35:00 <lispy> mcfoobar: http://lists.osuosl.org/pipermail/darcs-users/2009-September/021160.html
21:35:06 <Axman6> redline6561: map (\(x, y) -> printf "%s whom you spoke to for %d minutes.\n" x y) results doesn't make any sense either
21:35:17 <mcfoobar> lispy:  well, wenn I'm sober I'll have a look at it
21:35:22 <Axman6> mapM_ would however
21:35:25 <Axman6> :t mapM_
21:35:26 <lispy> mcfoobar: great!
21:35:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:35:28 <mcfoobar> maybe i can help dunnon
21:36:05 <redline6561> Axman6: Thanks. Just got to this myself.
21:36:08 <Axman6> mcfoobar: you know, 100% of the time i've spent talking to you, you haven't been sober
21:36:34 <Axman6> redline6561: are you using tabs or spacer btw? (should should be using spaces)
21:37:15 <mcfoobar> Axman6: haha, you made me laugh again xD
21:37:28 <lispy> Axman6: that's certainly true, but the bigger problem is that he's mixing IO with non-IO and the syntax of let is incorrect given that mix
21:37:29 <redline6561> Axman6: Tabs in emacs-haskell-mode. But I'm running 2.4 not CVS. Can I just mark all and indent?
21:37:43 <mcfoobar> can you remember any talking between us which did not happen today or yesterday=
21:38:04 <mcfoobar> lispy: oh and for you to not be afaid
21:38:14 <mcfoobar> im only rarely NOT sober
21:38:15 <redline6561> Axman6: Also, I think my (hopefully) last issue is in analyze. Does that function look correct to you?
21:40:20 <SubStack> No results found for "calling haskell from haskell".
21:40:32 <SubStack> yet
21:41:03 <Axman6> :(
21:41:13 <Axman6> why don't they make it easy for us? :(
21:41:22 <SubStack> Axman6: I know right?
21:41:40 <Twey> Haha
21:42:45 <Axman6> is anyone else annoyed that googling for "some specific string" doesn't actually work anymore? it's the exact same as without the quotes
21:43:07 <mle> yes.
21:43:17 <SubStack> I hate how the suggestions completely get in the way
21:43:30 <mle> suggestions?
21:43:48 <Axman6> BOYCOT GOOGLE!
21:43:54 <mle> ...what suggestions?
21:44:00 <Axman6> i couldn't do that, i love it too much :(
21:44:09 <jethr0> i hate how i search for *program -option* and funnily get really "bad" search results ;)
21:44:11 <SubStack> mle: the "did you mean" bits
21:44:35 <mle> SubStack: those are a nice idea.  I just hate when it says, 'did you mean ...' and That search returns nothing also.
21:45:05 <SubStack> I almost never want what the "did you mean" part says
21:45:14 <SubStack> probably because I tend to search for very specific things
21:45:22 <Axman6> you know what i fucking hate most? the fact that when i go to their help center, it says it doesn't support my language! "This Help Center isn't currently available in your language. However, you can select another language from the "Change Language" drop-down menu at the bottom of the page."
21:45:39 <Axman6> i speak fucking english ffs, i have even removed all the other languages from my computer
21:45:48 <Hunner> Axman6: my googling with quotes works
21:45:59 <Axman6> but no, en-au isn't english
21:46:11 <Twey> Axman6: English is so last decade.
21:46:19 <Twey> You want support now, you have to learn Mandarin.
21:46:28 <mcfoobar> Axman6: that is not true
21:46:38 <SubStack> is English turing complete?
21:46:43 <mcfoobar> i have talked to you years ago in #debian
21:46:47 <mcfoobar> when i was sober
21:46:55 <Axman6> mcfoobar: orly?
21:47:08 <mcfoobar> you probably cant remeber that, and i probably had the nick mc__
21:47:17 <Axman6> 'cause... i've never been in #debian, and i quite dispise linux ;)
21:47:32 <mcfoobar> really?
21:47:34 <Axman6> yes
21:47:46 <Axman6> maybe not dispise, but certainly dislike
21:47:55 <mcfoobar> hm funny
21:48:19 <mcfoobar> than I thought for years that two persons are one
21:48:36 <mcfoobar> Axman6: anyways we still have talked sober I tthink
21:48:40 <mcfoobar> you nick is familiar to e
21:48:42 <mcfoobar> d
21:48:45 <mcfoobar> me
21:48:54 <Axman6> yeah mc__ looks familliar
21:49:06 <lispy> mcfoobar: re: sober, heh
21:49:20 <mcfoobar> wb lispy
21:49:34 <mcfoobar> lispy: well if there is anything you want to ask you can
21:49:43 <mcfoobar> I'm only a a little drunk
21:49:46 <mcfoobar> and mainly sober
21:49:49 <Axman6> SubStack: well, we can describe any computer language currently existing in english can't we?
21:50:23 <Axman6> and describe how it works?
21:50:44 <SubStack> possibly
21:54:37 <Twey> SubStack: English is not a computer language
21:54:59 <Twey> Its inherent ambiguity makes that a nonsensical question
21:55:19 <arw_> you can describe a turing machine in english...
21:55:46 <SubStack> not well
21:55:52 <arw_> the only thing making it a little difficult is amiguity, but you can take that away by prefixing your 'english code' with some definitons.
21:55:57 <kmc> so some people have worked on how to modify english to be semantically precise
21:55:58 <wdonnelly> the question "is language X turing-complete?" basically just means "can we describe all processes computable on a turing machine, in language X?"
21:56:01 <kmc> you can learn about it in school, in fact
21:56:03 <kapil> arw_: but is the description semantically unambiguous?
21:56:04 <kmc> it's called "math" :P
21:56:53 <arw_> kapil: it can be. many people learn math that way :)
21:57:54 <arw_> the only real problem is a different one.
21:58:37 <arw_> 'english' depends on a very sophisticated interpreter, and its not really well defined what that interpreter must be.
21:58:57 <arw_> a human as interpreter will of course work, but with machines...
21:59:00 <kmc> arw_, it's easy to make one though
21:59:04 <Makoryu> English is actually less easily parsed than Perl.
21:59:36 <arw_> kmc: given a girlfriend, yes :)
21:59:49 <kmc> arw_, neither necessary nor sufficient
22:00:01 <Makoryu> http://www.reddit.com/r/programming/comments/9hqos/askprogit_what_tools_do_you_use_for_your/ <- Whoooaaaaaaaa
22:00:11 <Gracenotes> Makoryu: but we all know C++ is more difficult to parse than English :P
22:00:42 <Makoryu> Gracenotes: Computationally speaking, no it isn't :p
22:01:02 <Gracenotes> hush with your Chomsky hierarchy, C++ is teh most difficult language evar
22:01:40 <arw_> Chomsky++
22:02:01 <arw_> the class where only c++ is in.
22:02:53 <Cale> Gracenotes: What about perl? It's impossible to parse :)
22:03:04 <kmc> http://www.kheafield.com/code/compile/
22:04:20 <Berengal> Does english grammar depend on the semantics of the words?
22:04:37 <Berengal> Because if not, then it's possible to parse, unlike perl
22:04:47 <arw_> Berengal: for some words it does.
22:04:58 <Berengal> arw_, such as?
22:05:01 <Cale> Berengal: There was a really long discussion about that in ##English just now.
22:05:09 <Berengal> Huh
22:05:15 <Axman6> @check \x -> x > 0 || div (div x 2) 2 == div x 4
22:05:16 <lambdabot>   "OK, passed 500 tests."
22:05:23 <arw_> Berengal: gender of 'moon' or 'sun' comes to mind.
22:05:24 <Cale> Berengal: There are issues with whether adjectives really exist grammatically :)
22:05:43 <Cale> arw_: Gender?
22:05:52 <arw_> Berengal: the sun, she shines bright vs. the sun, he shines bright vs. the sun, it shines bright.
22:05:56 <Gracenotes> It makes sense to me that, to an extent, the semantics can be treated as syntax if it fits into regular patterns and affects grammaticality directly
22:06:00 <jethr0> Axman6: why >0?
22:06:25 <Gracenotes> "the sun, he shines bright" is a valid English sentence
22:06:26 <Berengal> arw_, does that affect the grammar though?
22:06:26 <Axman6> the problem i'm doing used it. it wasn't necessary though
22:06:37 <Cale> arw_: I would take those all to be grammatically correct (with roughly the same meaning, but the 'he' and 'she' versions personify the sun.
22:06:44 <Cale> )
22:06:48 <lispy> Axman6: that's not really the right way to give a constraint to quickcheck
22:07:01 <Axman6> i know
22:07:05 <Axman6> but it's quick
22:07:08 <jethr0> ==>
22:07:10 <Axman6> anyway, bbiab
22:07:30 <lispy> ?check \x -> x > 0 ==> x == 4
22:07:31 <lambdabot>   Not in scope: `==>'Precedence parsing error
22:07:31 <lambdabot>      cannot mix `GHC.Classes.>'...
22:07:42 <lispy> not sure how you use that here though :)
22:07:44 <arw_> Berengal: if not all of those are correct, the grammar of the sentence depends on the semantics (here grammatical gender) of the word 'sun'.
22:07:46 <Gracenotes> and then there's the gerund, to X vs. Xing, not all are valid in various situations, but I'm sure one could classify them appropriately.. eh
22:08:47 <lispy> You can verb anything if you just word it.
22:08:52 <Berengal> arw_, I'd say they're all correct, at least if we use a definition of grammar not unlike the CS one
22:09:02 <lispy> oh, misquote...
22:09:22 <lispy> I think the original may have been, "you can wordify anything if you just verb it!"
22:09:25 <arw_> Berengal: that is exactly our problem. if you use a CS-like grammar its of course very easy.
22:09:36 <Petrosian> There's also relics from Old English that still lurk in Modern English too
22:09:39 <Gracenotes> Cale: so ##English actually has serious discussions? color me somewhat surprised..
22:09:39 <arw_> Berengal: but natural languages have much more complex forms of grammar
22:09:43 <Petrosian> Like declensions such as "Whom"
22:09:52 <Berengal> arw_, but perl isn't, even with CS-like grammars
22:10:08 <Petrosian> And "thou" as well, I suppose
22:10:33 <arw_> Berengal: if you go high enough in the chomsky hierarchy it gets hard, of course.
22:11:34 <Berengal> Oh well, I'm not going to parse english nor perl anytime soon anyway
22:13:21 <sshc> Hi, what are some simple programs or exercises I (a beginner, can make?
22:13:36 <Berengal> sshc, how beginner?
22:14:42 <sshc> Berengal: I'm not sure how I can be more specific
22:14:43 <Makoryu> Petrosian: Thou/thee is exactly the same issue as who/whom, which is the same issue as he/him
22:14:54 <Petrosian> Makoryu: I know.
22:15:02 <Berengal> sshc, have you programmed before, how long have you been doing haskell etc.
22:15:04 <Petrosian> It was an example of declining pronouns.
22:15:19 <Petrosian> I mentioned "Thou" as it doesn't really seem to be in common usage
22:15:21 <Berengal> (I'm just asking this to stall for time)
22:15:27 <Petrosian> Or even maybe considered "Modern" English.
22:16:29 <arw_> ah. now i remember the example.
22:16:50 <sshc> Berengal: I've started studying Haskell about a month or two ago.  I'm experienced with C.
22:17:05 <Berengal> sshc, I assume you know about project euler?
22:17:24 <arw_> "he helped his brother jack off a horse" <- depending on the meaning of 'jack' here, you need slightly different grammar (capitalization in that instance).
22:18:22 <arw_> but in spoken language, there is not always a noticable difference.
22:19:14 <Berengal> sshc, other things I can think off of the top of my head is: write grep, write a parser combinator library from scratch (good for learning monads), write a two-player game-of-life with GUI (make up the rules yourself)
22:19:22 <arw_> and depending on the nature of the difference in meaning, this makes your natural language undecidable, at least for certain sentences.
22:20:32 <sshc> Berengal: those are good suggestions.  thanks
22:20:34 <Berengal> sshc, L-system interpreter, with graphics, make up your own simple irc-like protocol and write a server and a client. solve sudoku
22:20:46 <wdonnelly> sshc: H-99 (http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems) is a pretty great set of problems, too
22:20:56 <wdonnelly> it starts off with very basic list operations
22:21:05 <raadad> guys
22:21:09 <wdonnelly> and then gradually gets fancier
22:21:11 <raadad> i keep getting stack overflow
22:21:12 <raadad> i type
22:21:23 <raadad> let fac n = n * fac (n-1)
22:21:26 <raadad> fac 2
22:21:30 <Gracenotes> arw_: not undecidable.. ambiguous :)
22:21:39 <wdonnelly> raadad: you need a base case
22:21:40 <Berengal> raadad, you need a base case
22:21:47 <raadad> err?
22:21:59 <Berengal> raadad, fac 0 = 1
22:21:59 <wdonnelly> it will keep decreasing n forever
22:22:12 <wdonnelly> and eventually run out of stack space
22:22:38 <Gracenotes> to define them both in a let statement, use a semicolon
22:22:39 <Stinger> fac 0 = 0 * fac (-1)
22:22:46 <Cale> raadad: fac 2 = 2 * fac (2-1) = 2 * ((2-1) * fac ((2-1)-1)) = 2 * ((2-1) * (((2-1)-1) * fac (((2-1)-1)-1))) ...
22:23:07 <arw_> Gracenotes: in this case, thats the same. you cant decide if the sentence is gramatically correct without knowing the meaning of the word 'jack' in that sentence.
22:23:33 <Axman6> @check \x -> ((div x 2) <= 2) == (x <= 4)
22:23:34 <lambdabot>   "Falsifiable, after 13 tests:\n5\n"
22:23:37 <Cale> raadad: It will never stop, and the multiplications which are waiting to pattern match their second parameter are building up on the stack.
22:23:51 <Gracenotes> arw_: hm. I'd say it's correct if it can be described by the grammar, in 1 or more ways. 0 ways means it's not grammatical
22:23:52 <arw_> Gracenotes: and to get the meaning out of the context you have to solve some undecidable problem (here because there is no context, in the real world because many human problems are undecidable).
22:24:02 <raadad> im using ghci
22:24:08 <wdonnelly> > let fac 0 = 1; fac n = n * fac (n - 1) in fac 2
22:24:08 <raadad> is there anyway to end line
22:24:09 <lambdabot>   2
22:24:14 <Berengal> raadad, it's called an infinite recursion
22:24:22 <wdonnelly> > let fac n = n * fac (n - 1) in fac 2
22:24:23 <raadad> i know that now
22:24:24 <lambdabot>   * Exception: stack overflow
22:24:34 <Cale> raadad: It's more comfortable if you put new definitions in a file. If you edit the file, just type :r in ghci to reload it.
22:24:35 <raadad> thanx guys
22:24:39 <Berengal> > let fac n = if n <= 0 then 1 else n * fac (n-1) in fac 5
22:24:40 <lambdabot>   120
22:26:05 <raadad> wen i try to load mudles
22:26:09 <Gracenotes> the way it would be, is that of many branches you can take that describe "jack" in that case, only the branches that make grammatical sense would be taken.. or somethin
22:26:12 <raadad> it says error on input
22:26:18 <raadad> my module has this code
22:26:23 <centrinia> > let fac n = foldr (*) 1 [1..n] in fac 5
22:26:25 <lambdabot>   120
22:26:37 <raadad> module Test ; maxlist x = foldr max (head x) x
22:26:45 <arw_> Gracenotes: yes. and computing the path that would make sense is the hard part.
22:26:46 <raadad> the ; means i pressed enter,
22:27:02 <raadad> is that how i write things to a text file
22:27:27 <Cale> raadad: hmm... just "error on input"?
22:27:56 <raadad> 'maxlist'
22:28:05 <centrinia> > let maxlist = foldr1 max in maxlist [1,2,300,4]
22:28:06 <Cale> raadad: right, you forgot the 'where'
22:28:06 <lambdabot>   300
22:28:12 <Cale> module Test where
22:28:13 <centrinia> > let maxlist = foldr1 max in maxlist []
22:28:14 <lambdabot>   * Exception: Prelude.foldr1: empty list
22:28:41 <raadad> you guys are awsome
22:28:46 <raadad> :D
22:28:49 <raadad> thanks alot
22:29:10 <Cale> raadad: Also, note that you can replace that with foldr1 if you're going to have it fail on an empty list anyway.
22:29:27 <Cale> (then you don't have to give a replacement for the empty list)
22:29:47 <Cale> That is,  maxlist xs = foldr1 max xs
22:30:57 <Gracenotes> arw_: interestingly, http://www.link.cs.cmu.edu/link/submit-sentence-4.html notices the different with capitalization :)
22:31:32 <Gracenotes> it does have a database of English words behind the scenes, though (which would be allowable in a parser, so long as the database is finite)
22:32:12 <Gracenotes> (not exactly precise though)
22:32:31 <centrinia> It doesn't accurately parse "Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo." :(
22:32:33 <arw_> Gracenotes: such a database is also necessary. you need to know which words are possible for subjects, verbs and objects just to get the ordering right.
22:32:59 <Gracenotes> centrinia: uh, do you have the capitalization right there?
22:33:18 <centrinia> Gracenotes, yes.
22:33:19 <Axman6> @check \x -> ((div x y) <= z) == (x <= y*z+1)
22:33:20 <copumpkin> centrinia: is that you on twitter?
22:33:20 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary SimpleReflect.Expr)
22:33:20 <lambdabot>    arising f...
22:33:31 <Axman6> @check \x y z -> ((div x y) <= z) == (x <= y*z+1)
22:33:32 <lambdabot>   "Falsifiable, after 0 tests:\n0\n1\n-1\n"
22:33:45 <cocentrinia> copumpkin: No.
22:33:51 <copumpkin> :O
22:33:55 <Axman6> @check \x y z -> z > 0 ==> ((div x y) <= z) == (x <= y*z+1)
22:33:56 <lambdabot>   Not in scope: `==>'Precedence parsing error
22:33:57 <lambdabot>      cannot mix `GHC.Classes.>'...
22:33:58 <cocentrinia> That is my opposite.
22:33:58 <Gracenotes> oh, right, it uses a subordinate clause, not a direct VP at first
22:34:04 <Gracenotes> hence the capitalization
22:34:04 <Axman6> @check \x y z -> z > 0 ==> (((div x y) <= z) == (x <= y*z+1))
22:34:05 <lambdabot>   Not in scope: `==>'
22:34:10 <Axman6> argh
22:34:23 <Axman6> @check \x y z -> z > 0 || (((div x y) <= z) == (x <= y*z+1))
22:34:24 <lambdabot>   "* Exception: divide by zero
22:34:32 <Gracenotes> arw_: a generative approach is much more interesting than a parsing one, imho, but doesn't tend to be as useful irl
22:34:36 <Axman6> @check \x y z -> z > 0  && y /= 0 || (((div x y) <= z) == (x <= y*z+1))
22:34:37 <lambdabot>   "* Exception: divide by zero
22:34:43 <Axman6> ...
22:35:00 <Axman6> @check \x y z -> z > 0 || y /= 0 || (((div x y) <= z) == (x <= y*z+1))
22:35:02 <lambdabot>   "* Exception: divide by zero
22:35:47 <Stinger> you want all && dont you?
22:35:50 <wdonnelly> centrinia: it correctly parses "police police police police police police police police", though
22:36:21 <Gracenotes> what is a "police police" here?
22:36:30 <wdonnelly> a policeman who polices the police
22:36:39 <Gracenotes> eh. -.- well, I suppose that'd work
22:37:03 <Axman6> bleh. what i really need to do it get "x `div` 2 > 1 && x `div` 4 <= 1
22:37:06 <Axman6> into a nice form
22:37:07 <Axman6> *
22:37:19 <copumpkin> cocentrinia: aha, I see
22:38:17 <copumpkin> cocentrinia: there are lots of other haskellers on twitter too
22:39:14 <cocentrinia> Maybe we can make a microblogging service with Haskell. :)
22:39:30 <Gracenotes> you can only send a message if it typechecks
22:39:53 <arw_> hrhr. grammar checking microblogging with types and hookers!
22:41:56 <cocentrinia> Hmm, it can parse, "How much wood would a wood chuck chuck if a wood chuck could chuck wood?"
22:44:28 <copumpkin> :o
22:45:51 <copumpkin> it'd be nice if the haskell platform could be just haskell.org/platform
22:46:03 <copumpkin> would make the URL easier to give out to people
22:46:06 <ray> you know what would be nice? if the haskell platform WORKED
22:46:25 <copumpkin> it doesn't work?
22:46:52 <ray> well, i was just sorta throwing that out there, but now that you mention it it didn't work last time i tried to install it on luniax
22:48:29 <raadad> guys
22:48:45 <raadad> let a = map (+) [1,2,3,4]
22:48:49 <raadad> wat is wrong there
22:48:58 <ray> :t (+)
22:48:59 <lambdabot> forall a. (Num a) => a -> a -> a
22:49:01 <ray> :t map
22:49:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:49:05 <Cale> raadad: nothing, but a will be a list of functions
22:49:28 <ray> b in map becomes the (a -> a) from (+)
22:49:36 <ray> but [1,2,3,4] is not a list of functions
22:49:44 <purplepenguins> is there a nice way to apply a list of functions to a variable?
22:49:46 <Cale> map (+) [1,2,3,4] = [(1+), (2+), (3+), (4+)]
22:49:54 <cocentrinia> > let a = map (+) [1,2,3,4]; b = map (`id` 100) a in b
22:49:55 <lambdabot>   [101,102,103,104]
22:50:00 <Cale> purplepenguins: Either use sequence or another map
22:50:07 <purplepenguins> :t sequence
22:50:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:50:09 <copumpkin> > sequence (map (+) [1,2,3,4]) 5
22:50:10 <lambdabot>   [6,7,8,9]
22:50:17 <raadad> a simple map function would be?
22:50:20 <ray> if you want to add those numbers together, you don't want map
22:50:22 <Cale> > map ($ 5) (map (+) [1..4])
22:50:23 <lambdabot>   [6,7,8,9]
22:50:33 <ray> > foldr (+) 0 [1,2,3,4]
22:50:33 <copumpkin> > map (+5) [1..4]
22:50:34 <lambdabot>   10
22:50:35 <lambdabot>   [6,7,8,9]
22:50:35 <Cale> > map (\x -> x^2 + x + 1) [1..10]
22:50:37 <lambdabot>   [3,7,13,21,31,43,57,73,91,111]
22:50:49 <raadad> awsome
22:50:51 <raadad> thanx again
22:50:52 <Berengal> Anyone know who's the new WHN editor?
22:50:56 <purplepenguins> > map ($ 1) [(+ 5),(+ 3)]
22:50:56 <cocentrinia> That's prime material!
22:50:57 <lambdabot>   [6,4]
22:51:00 <copumpkin> Berengal: byorgey does
22:51:02 <purplepenguins> ah cool
22:51:22 <Cale> > map (\x -> x^2 + x + 41) [1..10]
22:51:23 <lambdabot>   [43,47,53,61,71,83,97,113,131,151]
22:51:34 <Berengal> copumpkin, oh, good, or there'd probably be a mess
22:53:34 <cocentrinia> > foldr (\x y -> x^2+x+41:y) [] [1..10]
22:53:35 <lambdabot>   [43,47,53,61,71,83,97,113,131,151]
22:54:51 <Gracenotes> rdlof
22:54:59 <Cale> > let isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5..]; in all (\x -> isPrime (x^2 - x + 41)) [0..40]
22:55:00 <lambdabot>   True
22:55:07 <pantsd_pcf> Anyone have an example using Data.MemoCombinators (specifically mem2 / mem3 )?
22:55:32 <copumpkin> wasn't there someone who thought that formula would only generate primes? it seems a bit silly :P
22:55:50 <copumpkin> I vaguely remember reading about it a while back
22:56:32 <ray> > 2:[3,5..]
22:56:33 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
22:56:35 <ray> generates primes
22:56:38 <ray> :P
22:56:42 <copumpkin> lol
22:56:51 <Berengal> [2..] generates primes too...
22:56:52 <Cale> 9 is in there though, you should do something about that...
22:56:55 <arw_> it even generates all primes!
22:57:07 <ray> since 9 is in there, it must be prime
22:57:20 <arw_> 9 is a glitch in measurement.
22:57:25 <Cale> > filter (/= 9) (2:[3,5..])
22:57:25 <Gracenotes> *matrix
22:57:26 <lambdabot>   [2,3,5,7,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
22:57:30 <Cale> fixed ;)
22:57:34 <purplepenguins> 15 isn't prime
22:57:43 <ray> yes it is
22:57:45 <Cale> Oh, we'd better fix that...
22:57:46 <ray> it's in the list of primes
22:57:54 <ray> stop sieving out perfectly good primes :(
22:57:59 <Cale> > filter (`notElem` [9,15]) (2:[3,5..])
22:58:01 <lambdabot>   [2,3,5,7,11,13,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,...
22:58:08 <ray> they were primes until you got here
22:58:09 <Cale> hehe
22:58:21 <ray> you are depleting a scarce resource
22:58:34 <Berengal> We could just define primes to be "some number", then we wouldn't have to waste all this CPU power looking for them...
22:58:52 <Cale> Problem: devise an alternative definition of addition and multiplication which makes Z into a ring and such that the primes are 2 : [3,5..]
22:59:07 <copumpkin> :o
22:59:12 <Cale> (not that hard, really ;)
22:59:23 <cocentrinia> > let sieve (p:ps) = p:sieve (filter ((/= 0). (`mod` p)) ps) in sieve [2..]
22:59:24 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
22:59:37 <copumpkin> cocentrinia: needs moar fix
23:00:16 <cocentrinia> > let sieve (p:ps) = p:sieve (filter ((/= 0). (`mod` p)) ps); primes = sieve [2..]; isprime = const True in map isprime primes
23:00:17 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
23:00:27 <cocentrinia> They are all primes.
23:00:35 <Berengal> > fix ((`ap` tail) . (. head) . liftM2 (.) (:) . (. (filter . ((0 /=) .) . flip mod)) . (.)) [2..]
23:00:36 <copumpkin> nice! :P
23:00:36 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:00:52 <cocentrinia> Berengal: That's pointless.
23:00:53 <copumpkin> @pl couldn't have said it better
23:00:53 <lambdabot> couldn't have said it better
23:00:56 <Gracenotes> Berengal: that is lovely hand-crafted code! *cough*
23:01:11 * Berengal takes a bow
23:01:30 <cocentrinia> @unpl fix ((`ap` tail) . (. head) . liftM2 (.) (:) . (. (filter . ((0 /=) .) . flip mod)) . (.))
23:01:30 <lambdabot> fix (\ v -> (\ an -> ((:) >>= \ d -> (\ ar s -> v (filter (\ au -> 0 /= mod au ar) s)) >>= \ c -> return (\ j -> d (c j))) (head an)) >>= \ aw -> tail >>= \ av -> return (aw av))
23:01:34 <Cale> > let isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5..]; in findIndex (not . isPrime) [44546738095860*x + 56211383760397 | x <- [0..]]
23:01:39 <lambdabot>   mueval-core: Prelude.read: no parse
23:01:39 <lambdabot>  mueval: ExitFailure 1
23:02:06 <cocentrinia> >  [44546738095860*x + 56211383760397 | x <- [0..]]
23:02:08 <lambdabot>   [56211383760397,100758121856257,145304859952117,189851598047977,23439833614...
23:02:40 <Berengal> Ooo, magic numbers
23:02:43 <Cale> Ah, that isPrime might be a little slow for that :)
23:02:53 <Cale> The first 23 are all supposed to be prime.
23:02:56 <purplepenguins> > let primes = 2:3:filter isPrime candidates; isPrime n = all (\i -> mod n i /= 0) (takeWhile (\i -> i^2 <= n) primes); candidates = do n <- [1..]; [6*n-1..6*n+1] in take 20 primes
23:02:57 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
23:04:31 <Cale> > let isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5..] in findIndex (not . isPrime) [30*x^2 - 810*x + 2753 | x <- [3..]]
23:04:32 <lambdabot>   Just 22
23:05:00 <Cale> > let isPrime n | n < 0 = isPrime (-n); isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5..] in findIndex (not . isPrime) [30*x^2 - 810*x + 2753 | x <- [3..]]
23:05:01 <lambdabot>   Just 3
23:05:05 <Cale> errr...
23:07:32 <Cale> oh, duh :)
23:07:40 <Cale> > let isPrime n | n < 0 = isPrime (-n); isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5..] in findIndex (not . isPrime) [36*x^2 - 810*x + 2753 | x <- [0..]]
23:07:42 <lambdabot>   Just 45
23:07:46 <Cale> There we go :)
23:07:55 <Cale> Works better when you get the polynomial right :)
23:08:02 <Jafet> > map ((41 +) . ((-) =<< join (*))) [1..40]
23:08:03 <lambdabot>   [41,43,47,53,61,71,83,97,113,131,151,173,197,223,251,281,313,347,383,421,46...
23:08:47 <purplepenguins> what's special about tha polynomial
23:08:54 <|Steve|> @pl \x -> x-2
23:08:54 <lambdabot> subtract 2
23:09:09 <Cale> I believe it's the best known prime-generating quadratic.
23:09:13 <cocentrinia> > let expmod m a 0 = 1; expmod m a e = ((if e `mod` 2 == 0 then 1 else a) * expmod m (a^2 `mod` m) (e `div` 2)) `mod` m;  fermat xs n = all (\x -> expmod n x (n-1) == 1) xs in filter (fermat [1..50]) [1000000..]
23:09:15 <lambdabot>   [1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121,1000133,10...
23:09:23 <purplepenguins> okay
23:10:21 <cocentrinia> > let expmod m a 0 = 1; expmod m a e = ((if e `mod` 2 == 0 then 1 else a) * expmod m (a^2 `mod` m) (e `div` 2)) `mod` m;  fermat xs n = all (\x -> expmod n x (n-1) == 1) xs; isPrime = fermat [2..50] in findIndex (not . isPrime)  [30*x^2 - 810*x + 2753 | x <- [3..]]
23:10:23 <lambdabot>   * Exception: stack overflow
23:10:47 <elbar> > [36*x^2-810*x+2753 | x <- [0..10]]
23:10:49 <lambdabot>   [2753,1979,1277,647,89,-397,-811,-1153,-1423,-1621,-1747]
23:10:52 <purplepenguins> :t findIndex
23:10:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
23:11:05 <Cale> Oh, this is interesting, apparently, x^12 + 488669 *doesn't* produce a prime until x = 616980.
23:11:32 <cocentrinia> > let expmod m a 0 = 1; expmod m a e = ((if e `mod` 2 == 0 then 1 else a) * expmod m (a^2 `mod` m) (e `div` 2)) `mod` m;  fermat xs n = all (\x -> expmod n x (n-1) == 1) xs; isPrime = fermat [2..50] in findIndex (not . isPrime)  [x^12+488669 | x <- [616980..]]
23:11:34 <lambdabot>   Just 1
23:11:56 <copumpkin> x^2 + 0 doesn't produce a prime, ever!
23:11:59 <cocentrinia> It doesn't even produce a prime at x=616981. :(
23:12:01 <Cale> ehehe
23:12:09 <copumpkin> well, I guess if you feed it a prime, it will
23:12:09 <copumpkin> :)
23:12:15 <Gracenotes> Cale: .. eh.. from 0 all the way up?
23:12:26 <Cale> Gracenotes: yeah
23:12:37 <cocentrinia> > let expmod m a 0 = 1; expmod m a e = ((if e `mod` 2 == 0 then 1 else a) * expmod m (a^2 `mod` m) (e `div` 2)) `mod` m;  fermat xs n = all (\x -> expmod n x (n-1) == 1) xs; isPrime = fermat [2..50] in filter isPrime [2..]
23:12:39 <lambdabot>   [53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,...
23:13:11 <Cale> copumpkin: No, you were right the first time...
23:13:19 <Cale> copumpkin: Even if p is prime, p^2 won't be.
23:13:33 <Gracenotes> > let factor n = filter ((==0).mod n) [1..n] in factor 488669
23:13:34 <lambdabot>   [1,107,4567,488669]
23:13:45 <copumpkin> Cale: well, I meant a prime root, but that would be taking the domain to reals which would be kinda missing the point :)
23:13:45 <cocentrinia> If x=sqrt(2) then x^2+0 will produce a prime!
23:14:08 <Gracenotes> I suppose it has a synergy thingy with twelfth powers
23:14:13 <Cale> Well, yeah, then you'll produce every positive number that way.
23:14:19 <copumpkin> ooh Gracenotes said synergy
23:16:30 <Gracenotes> > let factor n = filter ((==0).mod n) [1..n] in findIndices null $ map (factor . (488669-)) [1..]
23:16:32 <lambdabot>   [488668,488669,488670,488671,488672,488673,488674,488675,488676,488677,4886...
23:16:45 <Axman6> @check \x y -> x < 0 || (div x 2 < y) == (x < 2*y)
23:16:46 <lambdabot>   "OK, passed 500 tests."
23:17:14 <sohum> @pl \x y -> g ((f x) + (f y))
23:17:14 <lambdabot> (g .) . (. f) . (+) . f
23:17:18 <cocentrinia> > let rho' n f (x,y) = let x' = f x `mod` n; y' = (f . f $ y) `mod` n; d = gcd (abs $ x'-y') n in if d == 1 then rho' n f (x',y') else d in rho' (2^257+1) (\x -> x^2+7) (2,2)
23:17:19 <lambdabot>   3
23:17:23 <Gracenotes> oh, yeah, that gets negative, [1..n] doesn't work.. eh.. /me must be doing something weird
23:17:29 <cocentrinia> > let rho' n f (x,y) = let x' = f x `mod` n; y' = (f . f $ y) `mod` n; d = gcd (abs $ x'-y') n in if d == 1 then rho' n f (x',y') else d in rho' ((2^257+1) `div` 3) (\x -> x^2+7) (2,2)
23:17:34 <lambdabot>   mueval-core: Prelude.read: no parse
23:17:34 <lambdabot>  mueval: ExitFailure 1
23:17:47 <Gracenotes> oh, and it wouldn't be null; 1 is always a facto
23:17:49 <Gracenotes> r
23:18:06 <cocentrinia> > let rho' n f (x,y) = let x' = f x `mod` n; y' = (f . f $ y) `mod` n; d = gcd (abs $ x'-y') n in if d == 1 then rho' n f (x',y') else d in rho' (488673) (\x -> x^2+7) (2,2)
23:18:06 <sohum> @pl \x y -> g $ ((+) `on` f) x y
23:18:07 <lambdabot> (g .) . ((+) `on` f)
23:18:07 <lambdabot>   9
23:18:15 <cocentrinia> > let rho' n f (x,y) = let x' = f x `mod` n; y' = (f . f $ y) `mod` n; d = gcd (abs $ x'-y') n in if d == 1 then rho' n f (x',y') else d in rho' (488677) (\x -> x^2+7) (2,2)
23:18:17 <lambdabot>   7
23:18:19 <Gracenotes> no wonder why it was so fast
23:18:52 <sohum> @src on
23:18:52 <lambdabot> (*) `on` f = \x y -> f x * f y
23:19:10 <sohum> @haddock on
23:19:10 <lambdabot> Unknown command, try @list
23:19:36 <sohum> @hoogle on
23:19:37 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
23:19:37 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
23:19:37 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
23:19:41 <Gracenotes> > ((++) `on` show) 1 2
23:19:42 <lambdabot>   "12"
23:20:06 <cocentrinia> > let rho' n f (x,y) = let x' = f x `mod` n; y' = (f . f $ y) `mod` n; d = gcd (abs $ x'-y') n in if d == 1 then rho' n f (x',y') else d; factor n = rho' n (\x -> x^2+7) (2,2) in takeWhile (>1) $ iterate (\n -> n `div` factor n) 488677
23:20:07 <lambdabot>   [488677,69811,9973]
23:20:18 <cocentrinia> > let rho' n f (x,y) = let x' = f x `mod` n; y' = (f . f $ y) `mod` n; d = gcd (abs $ x'-y') n in if d == 1 then rho' n f (x',y') else d; factor n = rho' n (\x -> x^2+7) (2,2) in takeWhile (>1) $ iterate (\n -> n `div` factor n) 488678
23:20:19 <lambdabot>   [488678,244339]
23:20:34 <Gracenotes> numbers.. O_O
23:20:39 <cocentrinia> > let rho' n f (x,y) = let x' = f x `mod` n; y' = (f . f $ y) `mod` n; d = gcd (abs $ x'-y') n in if d == 1 then rho' n f (x',y') else d; factor n = rho' n (\x -> x^2+7) (2,2) in takeWhile (>1) $ iterate (\n -> n `div` factor n) (2^67+1)
23:20:45 <lambdabot>   mueval-core: Prelude.read: no parse
23:20:45 <lambdabot>  mueval: ExitFailure 1
23:44:49 <lispy> hi
23:50:09 <dons> my slides from two talks this week aree up now, http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
23:50:21 <dons> and http://donsbot.wordpress.com/2009/09/05/the-haskell-platform-status-report-haskell-symposium-2009/
23:50:30 <dons> enjoy.
23:53:50 <ezyang> I cooked up a little scratchpad for Haskell wisdom I've picked up from #haskell and other places http://ezyang.com/haskell.html
23:53:56 <BMeph> Sir, yes Sir! ;)
23:53:58 <ezyang> Doubtless some of the advice is not actually that good.
23:56:08 <dons> ezyang: looks good!
23:57:58 <ezyang> Thanks! :-)
