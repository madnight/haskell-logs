00:07:20 <dibblego> is LYAH written using DocBook?
00:09:20 <shachaf> dibblego: I thought it was TeX.
00:09:35 <shachaf> Oh, um, I was thinking of YAHT.
00:09:49 <shachaf> Acronyms. Never mind.
00:21:55 <sergio1> Hello! I'm contemplating using Literate Haskell. However, somewhere in a corner of my brain seems to sit that there were some Haskell tools (but which?: debugger, coverage...) that didn't work with lhs. Anybody here aware of that?
00:25:39 <quicksilver> sergio1: c2hs or hsc2hs or something?
00:26:34 * ksf recommends c2hs
00:37:03 <hackagebot> statistics 0.1 - A library of statistical types, data, and functions. (BryanOSullivan)
00:37:35 <periodic> Is there a good way to short circuit a fold other than just returning your accumulator unchanged?  Will the compiler correctly optimize that if you have a very long list and want to return near the beginning?
00:39:07 <periodic> e.g. minimum hamming distance between a string and strings in a list of strings, where if you get a match early there's no need to compute the rest.
00:40:08 <quicksilver> not really to do with optimisation, periodic
00:40:14 <quicksilver> just non-strict semantics
00:40:32 <quicksilver> foldr (&&) [False,undefined]
00:40:37 <quicksilver> > foldr (&&) True [False,undefined]
00:40:39 <lambdabot>   False
00:40:46 <periodic> well, theoretically, even if it wasn't strict, in a fold it would have to check against each to be sure, right?
00:40:51 <quicksilver> if your function doesn't inspect its right argument.
00:41:00 <quicksilver> then the fold short-circuits.
00:41:01 <periodic> aahh...
00:41:02 <periodic> hrm.
00:41:04 <periodic> I see.
00:41:17 <periodic> Awesome. :D
00:41:25 <periodic> laziness wins again.
00:42:00 <Saizan> note that foldl doesn't have this nice property
00:42:30 <periodic> I've ben warned against foldl.
00:42:33 <periodic> *been
00:45:22 <quicksilver> if you write out a right fold, you get (a # (b # (c # (d # ....... ))))
00:45:40 <quicksilver> so if somewhere down that chain, the # chooses not to inspect its right argument
00:45:52 <quicksilver> then that whole nest of ( ...) to the right just never gets evaluated.
00:46:14 <quicksilver> left folds can still short circuit to avoid evaluating *elements* but they can't avoid evaluating the spine of the list
00:46:22 <quicksilver> which is much less useful in practice.
00:47:30 <periodic> Yeah, I think I'm going to have to go back to that part in RWH that explains it, and maybe write it out on a few of my own things to get a better intuition of how these folds build their thunks.
00:47:57 <periodic> But that does make sense.  Thanks for the explanation.w
00:48:09 <periodic> oops, tried to end that sentence with ":w"
00:48:30 <periodic> That's what I get for tabbing back and forth with Vim.
00:48:41 <quicksilver> :wq!ESCESCESCAlt-QCtrlAltDelete
00:49:18 <doserj> > foldl (flip (&&)) True [undefined, False]
00:49:20 <lambdabot>   False
00:49:49 <ksf> shouldn't fold be defined to foldr, to aid those lisp people?
00:51:11 <quicksilver> doserj: exactly :)
00:52:15 <Saizan> ksf: the lisp people would be more used to foldl' i imagine
00:57:20 <Peaker> #haskell is smaller than it was a few months ago, no? :-(
01:00:30 <ray> @users
01:00:31 <lambdabot> Unknown command, try @list
01:00:34 <ray> yes
01:00:45 <ray> it's missing one users command
01:01:46 <ray> ksf: aid lisp people?!
01:02:17 <jungehexe> Moin all/me wakes up
01:03:42 <DarkUnicorn> hey jungehexe. from germany?
01:04:09 <jungehexe> i have a problem with keeping a part of infinite stream on demand and need some help
01:04:15 <jungehexe> jeah
01:04:42 <jungehexe> darkUnicorn: you too?
01:05:04 <DarkUnicorn> jungehexe: yes. kiel, germany here :)
01:05:19 <jungehexe> cool,
01:05:28 <dm``> Does foldr use a lot of stack space, though?
01:05:36 <Saizan> jungehexe: what is the problem, more concretely?
01:05:41 <dm``> while foldl can traverse long lists in constant space?
01:05:42 <jungehexe> DarkUnicorn: than you have to understand smth in reactive systems
01:05:49 <jungehexe> DarkUnicorn: ;)
01:05:55 <jungehexe> DarkUnicorn: no/
01:06:01 <arw_> dm``: only the strict version can do that.
01:06:11 <Saizan> dm``: it uses O(n) stack space if the folding function is strict on the right argument
01:06:26 <det> dm``, foldr in Haskell is like foldl in a strict language
01:06:28 <Saizan> dm``: otherwise foldr works in constant space too
01:06:30 <dm``> Which uses O(n)?
01:06:46 <dm``> Wait, how does foldr work in O(1) space?
01:06:57 <Saizan> it = foldr in that sentence
01:06:58 <det> because when you have a list, you really dont have a list
01:07:06 <det> in the sense that you would in Ocaml
01:07:09 <jungehexe> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9175#a9176 here is the code which doesn't work and i  tried to formulate problem in comments
01:07:18 <Saizan> ?src foldr
01:07:18 <lambdabot> foldr f z []     = z
01:07:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:07:34 <Saizan> dm``: the recursion is not followed immediately
01:07:42 <dm``> So let's say you want to sum a very large list of integers.
01:07:47 <Saizan> only if "f" demands it
01:07:49 <dm``> foldl' would be the one to use, right?
01:07:52 <DarkUnicorn> jungehexe: no, why do you think that?
01:07:53 <Saizan> right
01:07:53 <det> no
01:07:55 <det> foldr
01:08:07 <Saizan> det: foldr will get you a stack overflow
01:08:34 <Saizan> because (+) is strict in both arguments
01:08:38 <jungehexe> DarkUnicorn: heard smth that reactive systems are associated with Kiel
01:08:40 <dm``> But if you think you might short-circuit, then foldr is the fold of choice.
01:08:57 <Saizan> yeah or if "f" is productive
01:09:09 <dm``> what does productive mean?
01:09:10 <det> oh
01:09:10 <DarkUnicorn> jungehexe: right, but thats another working group. i'm more into software design
01:09:22 <det> what is the syntax for a range of numbers in Haskell ?
01:09:31 <Saizan> i.e. it can produce result without consuming all the input
01:09:35 <int-e> > [1..5]
01:09:37 <lambdabot>   [1,2,3,4,5]
01:09:37 <periodic> det [start..finish]
01:09:47 <int-e> > [1,4..10]
01:09:49 <lambdabot>   [1,4,7,10]
01:09:57 <Saizan> dm``: for example (++), in fact concat xs = foldr (++) [] xs
01:09:58 <jungehexe> DarkUnicorn: pity, i need smone who could help me with reactive
01:10:12 <periodic> > [-1..-10]
01:10:13 <lambdabot>   Not in scope: `..-'
01:10:21 <periodic> > [-1..(-10)]
01:10:23 <lambdabot>   []
01:10:41 <periodic> > [-1,-2..(-10)]
01:10:42 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
01:10:45 <int-e> > [-1,-2.. -10]
01:10:47 <dm``> But foldr for ++ is different.  That's because ++ has to copy its left-hand argument, so you want the long string on the right.
01:10:47 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
01:10:49 <jungehexe> Saizan: i ve posted a link with a description, as it too large to put in caht
01:10:55 <jungehexe> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9175#a9176
01:11:03 <periodic> int-e: figured it out fast enough. :D
01:11:17 <int-e> periodic: still, a space is enough in this case
01:11:33 <dm``> same reason you want shows instead of show
01:11:59 <Saizan> dm``: but it still doesn't use O(n) stack because (++) is lazy in its right argumnt
01:12:19 <dm``> That I don't understand.
01:12:34 <dm``> If I have a list ["a", "b", "c", "d"]
01:12:43 <ray> > take 10 $ [0] ++ [1..]
01:12:43 <dm``> and I run foldr (++)
01:12:44 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
01:12:46 <Saizan> > "abcd" ++ undefined
01:12:48 <lambdabot>   "abcd* Exception: Prelude.undefined
01:13:00 <ray> lazy in its right argument.
01:13:03 <nimred> hello #haskell
01:13:11 <Saizan> see? it produced "abcd" before forcing the undefined
01:13:42 <nimred> what's wrong when installing xmonad-contrib : http://xmonad.pastebin.com/m9a84463
01:13:49 <nimred> from cabal
01:13:50 <dm``> Oh, so what you are saying is that foldr (++) ["a", ...] doesn't actually produce the folded list.
01:14:16 <dm``> It produces it as I consume it, and therefore could use constance space, as long as I didn't, say, scan the output string while keeping a pointer to the head.
01:14:39 <Saizan> so foldr (++) [] ["a","b","c"] = (++) "a" (foldr (++) [] ["b","c"]) = a : (++) [] (foldr (++) [] ["b","c"]) = a : (foldr (++) [] ["b","c"]) = ...
01:14:59 <Saizan> dm``: it'll still use constant stack space
01:15:26 <Saizan> dm``: but yeah, it will use linear space to store the list
01:15:37 <jungehexe> i'm being not noticed :(
01:15:37 <DarkUnicorn> jungehexe: sorry, can't help you there...
01:15:58 <jungehexe> DarkUnicorn: i see, it'S prettyspecific, the field
01:16:31 <dm``> > foldr (:) [] [1..10]
01:16:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
01:16:36 <jungehexe> and i just got stuck with no idas
01:16:40 <Saizan> nimred: you need to install pkg-config from your distro package manager
01:16:57 <Saizan> jungehexe: i'm reading :)
01:17:06 <DarkUnicorn> jungehexe: isn't that always the case with front line research? :)
01:17:14 <ray> dm``: that replaces all the (:)s in the list with (:)s, and the [] with a []
01:17:15 <ray> :)
01:17:26 <dm``> In constant space?
01:17:49 <nlogax> ..no one can hear you scream
01:17:51 <dm``> stack space?
01:18:03 <ray> yeah, constant stack
01:18:23 <nimred> Saizan it didn'e change anything :/
01:18:57 <dm``> Well, I guess the point is that "foldr (:) [] [1..10]" uses O(1) space, but that when lambdabot goes to print the expression, that is what causes the evaluation that uses O(n) space.
01:19:14 <ray> that's just traversing the list though
01:20:04 <dm``> So foldr if you might short-circuit or have a lazy string.  foldl' if you are strict, or know you are going to need to produce a short summary value from the whole list.  And what is foldl without the ' good for?
01:20:11 <saynte> I remember a while ago I was trying to see if I could get anything else out of the language shootout performance numbers, and I think I got a couple good results. Is there anyone in particular to give them to for critique/review and submission?
01:20:29 <jungehexe> Saizan: Thanks.
01:20:36 <ray> not really good for any situations
01:20:49 <Saizan> jungehexe: what do you mean by "it doesn't work properly" ?
01:20:51 <ray> it tends to not be what you want
01:21:23 <nimred> Saizan any idea ?
01:21:43 <jungehexe> Saizan: well,  given the following input
01:21:46 <Saizan> nimred: you get the same exact error message?
01:21:50 <jungehexe> -s_holdM [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16][True,True,True,False,False,False,False,False,True,True,False,False,False,False,False,False,True,True,True,False,False,False,False][True,False,False,False,False,False,False,False,True,False,False,False,False,False,False,False,True,False,False,False,False,False,False]
01:22:02 <jungehexe> i want the following output
01:22:47 <nimred> Saizan yes i do --> http://haskell.pastebin.com/m2bff22d9
01:23:15 <hackagebot> flower 0.1.2 - Analyze 454 flowgrams (.SFF files) (KetilMalde)
01:23:20 <Saizan> dm``: foldl is good for e.g. reverse, where the added strictness wouldn't help
01:23:34 <jungehexe> [1,2,3,1,2,3,1,2, 9,10,9,10,9,10,9,10, ]
01:23:46 <doserj> nimred: that's not the same error message. you have to install libxft using your distro's package manager
01:23:59 <ray> yeah left folds turn the list inside out
01:24:05 <ray> right folds match the structure of the list
01:24:26 <ray> this means foldr (:) [] is id, but foldl (:) [] is reverse
01:24:26 <nimred> doserj it already is installed :
01:24:27 <nimred> i A libxft2                                                                                                                          - FreeType-based font drawing library for X
01:24:31 <Saizan> @wiki Stack overflow
01:24:31 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
01:24:39 <Saizan> dm``: have you read that? ^^^
01:24:58 <jungehexe> but i get only a first parat of it till i try to get the new part memorised
01:26:15 <doserj> nimred: is there also a libxft package? (not libxft2)
01:26:40 <doserj> (or libxft1)
01:26:58 * ksf wanted to comlpain that xhb doesn't include xft, but not sees that that'd be nonsensical.
01:27:07 <Saizan> jungehexe: your merge doesn't handle empty lists.
01:27:22 <nimred> doserj installing libxft2-dev solved. thanks guys :)
01:27:30 <dm``> Will check the stack overflow link.  Thanks for elucidating the folds a bit...
01:27:32 <Saizan> jungehexe: and if you use finite lists as input you'll eventually get to an empty list in the recursion
01:28:02 <doserj> nimred: ah. I thought cabal had better error messages for this case...
01:28:30 <Saizan> mh, it should i think
01:28:35 <jungehexe> :Saizan i know, that is not a problem
01:29:04 <jungehexe> i have infinite lists as input
01:29:26 <quicksilver> jungehexe: it is precisely the problem.
01:29:34 <quicksilver> jungehexe: because when you test it with that commented out test
01:29:41 <quicksilver> you get the "inexhaustive cases" error
01:30:02 <quicksilver> [1,1,2,3,1,1,2,3,2,1,4,5,1,2,3,2,3,1,4,6,7,8,5*** Exception:...
01:30:27 <dm``> @src concat
01:30:27 <lambdabot> concat = foldr (++) []
01:30:35 <Saizan> is the output up to there what you wanted?
01:31:06 <jungehexe> quicksilver: yeah, i get it, but why it has to be a problem, when i only check whether the function produces correct data
01:31:25 <quicksilver> I'm afraid I don't understand the question you just asked.
01:31:45 <quicksilver> it is a problem because you are running 'merge' on finite lists and therefore when you get to the end of the list, you get an error
01:31:46 <jungehexe> Saisan: the output ist correct till i try memorise a new part, in this case it
01:31:56 <jungehexe> is 9, 10
01:32:31 <Saizan> what do you mean by memorise?
01:32:41 <jungehexe> keep repeating
01:33:17 <quicksilver> I understand the purpose of the parameter 'record' - to filter so you only see some values
01:33:27 <quicksilver> I don't think I understand what you're trying to do with the parameter 'new'
01:34:14 <jungehexe> new has to show it's time to forget the previous valuse and record new ones
01:34:32 <jungehexe> and repeat them til new new comes
01:34:53 <quicksilver> you seem to be using 'record' in two ways
01:35:00 <quicksilver> firstly you're using it as a parameter to 'when', to filter the input
01:35:04 <quicksilver> I think I understand that part
01:35:11 <quicksilver> but then you are also using it as a parameter to 'merge'
01:35:18 <quicksilver> to choose between input and ls
01:35:40 <quicksilver> you call merge twice - once using 'new' as the choosing list, and once using 'record' as the choosing list. Why?
01:37:18 * jungehexe thinking
01:38:10 <Saizan> nimred: which version of cabal-install are you using, btw? (you can check with cabal --version)
01:40:25 <jungehexe> quicksilver: you right merge is a false idea there
01:40:58 <quicksilver> if you can show a simple case (less than 16 elements please) of input + the output you want it may be easier to help you ;)
01:41:29 <jungehexe> ok
01:41:32 <quicksilver> e.g, what is the output supposed to be with [1..6],[T,T,F,F,F,T] [T,F,F,T,F,F]
01:41:51 <jungehexe> no
01:42:12 <jungehexe> although
01:42:13 <jungehexe> ok
01:42:53 <jungehexe> the output has to be [1, 2,1,2,1,6]
01:43:36 <jungehexe> although in new T can appear only at thesame moment as Thel line of T'S begins in record
01:43:54 <nimred> Saizan :
01:43:55 <nimred> [~]->> cabal --version                                                                                                                                                                                                                                                                                                  10:43
01:44:00 <nimred> cabal-install version 0.6.2
01:44:02 <jungehexe> [1..6],[T,T,F,F,F,T] [T,F,F,F,F,T]
01:44:03 <nimred> using version 1.6.0.2 of the Cabal library
01:44:20 <jungehexe> [1, 2,1,2,1,6]
01:44:26 <jungehexe> as output
01:44:51 <Saizan> nimred: thanks
01:45:06 <jungehexe> [1..8],[T,T,F,F,F,T,F,F] [T,F,F,F,F,T,F,F] has to give
01:45:14 <jungehexe> [1, 2,1,2,1,6,6,6]
01:46:37 <Saizan> so consecutive T in records mark a sequence that has to be repeated until another T in new?
01:46:50 * ksf doesn't pay attention, but thinks that you should translate those lists of bools into something 4-valued, and use that to mess with the input list.
01:47:24 <jungehexe> Saizan: yes
01:47:37 <Saizan> if T in new can appear only at the start of a sequence of T in record, then new is a bit redundant though
01:48:09 <jungehexe> if i could think on going whthout it
01:48:19 <jungehexe> i can leave with out it
01:49:14 <quicksilver> ksf: in fact, if T in the second is only permitted when there is T in the first, it's only 3-valued
01:49:23 <ksf> you won't be able to distinguish [T,T,T,T] [T,F,T,F] from [T,T,T,T] [T,F,F,F]
01:49:29 <quicksilver> somethine like data Process = Keep | Drop | Restart
01:49:37 <jungehexe> i can leave with out it
01:49:55 <jungehexe> i meant live
01:50:17 <ksf> ...but yeah, the key to seeing through this is using something less confusing than booleans.
01:50:22 <Saizan> jungehexe: is an input like [1..4] [T,T,T,T] [T,F,T,F] valid?
01:50:55 <Saizan> and direct recursion maybe
01:51:10 <jungehexe> Saizan:  well
01:51:15 <jungehexe> good question
01:51:29 <jungehexe> i think yes
01:51:52 <jungehexe> becauseit's a special case
01:52:25 <Saizan> ok, so you need new
01:53:09 <jungehexe>  weeeel i could restict he usage so that it's no a legal case, but it would restrict the functionality
01:53:26 <jungehexe> on miment i  i'll be back in a minute
01:53:41 <ksf> data Filter = Pass | Record | Playback
01:54:14 <ksf> ...where Record and Pass yield the same elements, but Record buffers them for later playback.
01:54:24 <jungehexe> did i miss smth
01:54:56 <jungehexe> i had to leave as my client hang on, no showin me what i type
01:55:06 <ksf> data Filter = Pass | Record | Playback
01:55:33 <Saizan> jungehexe: the idea is to combine the list of booleans into a single list of a more meaningful datatype like Filter above
01:55:52 <Saizan> jungehexe: and then recurse over it and the input list in parallel
01:56:41 <ksf> (and drop those confusing bool-lists alltogether, if that works with the other functions)
01:57:21 <jungehexe> Saizan: ksf: could you please give an example of such data list
01:58:12 <jungehexe> as i don't quite get the idea
01:58:13 <ksf> your example would be [1..8] [Record, Record, Playback, Playback, Playback, Record, Playback]
01:58:36 <jungehexe> ok
01:58:59 <ksf> ...add another Playback at the end.
01:59:03 <Saizan> ksf: how would [1..4] [T,T,T,T] [T,F,T,F] be then?
01:59:44 <ksf> Record Playback Record Playback?
01:59:48 <ksf> I'm not completely sure.
01:59:54 <ksf> that'd be 1 1 3 3
02:00:22 <Saizan> the output should be 1,2,3,4 i think
02:00:34 <jungehexe> yes
02:00:34 <ksf> somehow Pass is missing from those examples.
02:00:43 <jungehexe> Saizan: you right
02:01:07 <jungehexe> and pity the output of such Filte would be wrong
02:01:32 * ksf admits he's not used to have state expressed implicitely in a list of bools.
02:01:54 <jungehexe> well ksf, i even didn't dream about havin pass in
02:02:23 <jungehexe> bools are easy to evaluate
02:02:31 <jungehexe> and such Filter not
02:02:37 <Saizan> i think you want StartRecord | StopRecord | Nothing
02:03:04 <ksf> ...but using two bools for a three-valued state means that you have to deal with invalid input.
02:03:12 <Saizan> mh, but you need to read from the future for that
02:03:49 <jungehexe> then i need  StartR|StopR| StartPlayb|StopPlayb| Nothing
02:04:15 <Saizan> StartRecord | KeepRecording | Playback
02:04:48 <ksf> ...StopPlayb and StartR seem to be the same.
02:04:55 <Saizan> you can't get 5 different stater out of 2 booleans :)
02:05:05 <jungehexe> mm i think wiht last one i can live
02:05:58 <ksf> ...the other possibilty is Record | StartPlayback | KeepPlayingBack
02:06:19 <ksf> or, actually, Record | Playback | Change
02:06:31 <ksf> err ... | KeepDoing
02:07:20 <Saizan> yeah, but then KeepDoing needs past information determine its meaning
02:07:26 <Saizan> *to
02:07:55 <jungehexe> i can keep last information for i step
02:08:12 <ksf> ...but that could introduce lag.
02:08:31 <ksf> which might be problematic in an frp setting.
02:08:32 <jungehexe> fby :: Str a -> Str a -> Str a fby (x:_) ys = x : ys
02:08:47 <jungehexe> fby :: Str a -> Str a -> Str a; fby (x:_) ys = x : ys
02:12:24 <jungehexe> but even if i introduce such a filter
02:12:31 <jungehexe> how would it help
02:13:08 <jungehexe> i mean my hear gets stuck on thinkig about code using such filter
02:13:34 <jungehexe> my head - maj, i'm missing buttons
02:22:06 <jungehexe> so
02:23:09 <pozic> How are keyword arguments done in practice in Haskell? I know about Oleg's hacks, but I don't think anyone uses them.
02:25:51 <RayNbow> > cis pi + 1
02:25:53 <lambdabot>   0.0 :+ 1.2246467991473532e-16
02:26:27 <elbar> > pi
02:26:29 <lambdabot>   3.141592653589793
02:29:19 <zenzike> i wonder if lambdabot fails gracefully ...
02:29:26 <zenzike> > let x = x in x
02:29:39 <zenzike> > pi
02:29:41 <lambdabot>   3.141592653589793
02:29:41 <lambdabot>   thread killed
02:29:44 <zenzike> aha
02:30:30 <RayNbow> > cis pi + 1 :: Complex CReal
02:30:33 <lambdabot>   0.0 :+ 0.0
02:31:07 <purplepenguins> @type pi
02:31:09 <lambdabot> forall a. (Floating a) => a
02:36:26 <Saizan> pozic: you take a record as input
02:36:27 <quicksilver> pozic: custom data type, IMO.
02:36:50 <quicksilver> one of a variety of possible schemes
02:37:06 <quicksilver> fooble [ Bar := 3, Baz "hip" := Just 1.5 ]
02:37:14 <quicksilver> is a nice open extensible one
02:38:44 <quicksilver> does depend on context.
02:39:41 <purplepenguins> you make up new data types a lot
02:41:19 <quicksilver> yes, new data types are how we help the type checker help us.
02:42:51 <RayNbow> hmm, there is a numbers package and a Numbers package on hackage...
02:43:43 <quicksilver> I know. Annyoing isn't it?
02:43:49 <Saizan> uhm, i've a solution for the above s_holdM problem, but i'm not sure if it's reactive style enough, and if i'm doing someone else homeworks by showing it :)
02:46:02 <jungehexe> Saizan: yeah
02:46:37 <jungehexe> well it's my homework in some sence - i need it for my pong game
02:46:50 <jungehexe> and pong game i need for my uni
02:47:43 <jungehexe> and i've got stuck :( as i am not reactive thinking enough
02:48:41 <jungehexe> Saizan: so could you show it please and save my doul
02:48:43 <Saizan> well, here's what i got http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9175#a9188
02:48:45 <jungehexe> soul i mean
02:49:58 <Saizan> but don't expect this channel to give you solutions like these in the future :) (assuming that's a valid solution in your settings)
02:50:13 <Saizan> s/these/this/
02:51:06 <|Steve|> Cheating is saving your soul?
02:53:29 <lilac> pozic: i've seen this a few times: data FooArgs { thing1 :: Maybe Int, thing2 :: Bool }; defaultFooArgs = FooArgs { thing1 = Nothing, thing2 = False }
02:54:07 <lilac> pozic: then 'foo :: FooArgs -> FooResult', and you call foo like this: 'foo (defaultFooArgs { thing1 = Just 42 })'
02:54:47 <quicksilver> or if you make 'thing1' a lense instead
02:55:05 <quicksilver> then just foo (thing1 =:= Just 42)
02:55:19 <quicksilver> where foo has the responsibility of applying the function to the default arg set
02:55:35 <quicksilver> (operator name made-up though)
02:55:55 <lilac> how does that work with multiple args? do you pass a list of such things?
02:56:12 <quicksilver> a composition
02:56:26 <jungehexe> Saizan: i don't know why, but it hangs by me
02:56:28 <lilac> how amusing ;-)
02:56:30 <jungehexe> on runtime
02:56:32 <quicksilver> thing1 =:= Just 42 . thing2 =:= True
02:56:43 <quicksilver> although sometimes it's more attractive to pass a list
02:56:45 * quicksilver shrugs
02:56:47 <quicksilver> the design space is large
02:56:53 <quicksilver> standard solutions have not yet emerged :)
02:57:01 <jungehexe> and why do you say about not expecticg? actually it was sort of cry for help
02:57:08 <quicksilver> there are good solutions which are strongly type checked and don't have too much syntactic noise
02:57:32 * lilac is just glad we didn't end up with an evil variadic typeclass hack
02:57:50 <Saizan> jungehexe: on which input does it hang?
03:03:35 <pozic> It seems that essentially, you make every function into a one-argument function containing a record with both the required arguments as the optional arguments.
03:03:36 <jungehexe> ou, no it was my mistake, it really works.
03:04:31 <quicksilver> pozic: well it doesn't have to be a record, but yes.
03:04:42 <Saizan> jungehexe: do you understand how it works?
03:04:47 <quicksilver> pozic: you make every function into a one-argument function containing some data type which represents the arguments.
03:04:58 <jungehexe> Saizan: thank you a lot. I was sitting on this certain case for already two weeks.
03:05:04 <lilac> pozic: also, you don't /need/ to put the required arguments into the record
03:05:06 <jungehexe> Saizan: i do
03:05:37 <lilac> pozic: it may be better if you don't, since that way callers won't forget to provide them
03:05:55 <lilac> as quicksilver says, the design space is rather large.
03:06:00 <jungehexe> that's my problem i can understand the code pretty good, but i am bad in splitting a problem in small er ones as you did
03:06:49 <Saizan> jungehexe: it takes practice, i guess
03:07:34 <jungehexe> that' what i really lack
03:07:48 <jungehexe> i had just a short 1 semester course in reactive
03:07:54 <jungehexe> and haskell
03:08:02 <jungehexe> the rest in uni was java
03:08:36 <lilac> you were taught FRP at uni? that's so cool :)
03:08:47 <jungehexe> Saizan:  i can show in my work that this part of code wrote you
03:09:04 <jungehexe> if you tell me how to reference you there
03:09:36 <jungehexe> lilac: only one short course, which no one of my costudents like
03:09:40 <Saizan> jungehexe: there's no need to, but thanks :)
03:10:01 <DarkUnicorn> jungehexe: what kind of work do you write?
03:10:08 <quicksilver> odd.
03:10:18 <quicksilver> there is either something wrong with the course or something wrong with your costudents then :)
03:10:28 <quicksilver> because reactive should be a very interesting subject for a course.
03:10:42 <jungehexe> modelling and implementing control and dataflow in haskell
03:10:46 <jungehexe> that's my work
03:10:56 <greap> Are there any high level database abstraction libraries for haskell similar to ruby's datamapper?
03:11:26 <jungehexe> Saizan: why not?
03:11:34 <DarkUnicorn> jungehexe: sounds interesting
03:12:20 <quicksilver> greap: haskelldb is supposed to be slightly high level but I don't think it's very mature
03:12:23 <jungehexe> quicksilver: well, it's rather me beeing no typical for my uni
03:13:04 <jungehexe> DarkUnicorn: i thought so too, till i got stuck with saving streams on demand
03:14:19 <DarkUnicorn> jungehexe: you'll figure it out eventually :)
03:24:57 <Le-Chuck_ITA> cale, FunctorSalad_, yesterday I came here to ask for help showing properties of adjunction, in particular fâ™¯â™­=f. I now did the proof but used a fact that I ... er, didn't know, but perhaps it's obvious from the definitions?
03:25:19 <Le-Chuck_ITA> I used that (gÂ°f)â™¯ = gâ™¯Â°Ff
03:25:37 <Jafet> Heh, real sharps today
03:25:50 <Le-Chuck_ITA> Jafet: yeah, I learn how to cut and paste :)
03:28:11 <|Steve|> What do the sharps and flats mean?
03:28:14 <Le-Chuck_ITA> Now this ultimately leads to the obvious fâ™¯=ÎµÂ°Ff
03:28:41 <ivanm> did someone remove lambdabot's @users plugin or something?
03:28:48 <quicksilver> @bot
03:28:48 <lunabot>  :o
03:28:48 <lambdabot> :)
03:28:51 <quicksilver> @loseres
03:28:51 <lambdabot> Unknown command, try @list
03:28:54 <quicksilver> @users
03:28:54 <lambdabot> Unknown command, try @list
03:28:55 <ivanm> or is this a "fake" lambdabot?
03:29:10 <benmachine> I know @seen was removed
03:29:17 <ivanm> >_>
03:29:19 <ivanm> how come?
03:29:22 <Saizan> the seen plugin was removed since it's broken
03:29:25 <|Steve|> @seen dons
03:29:25 <lambdabot> Unknown command, try @list
03:29:28 <benmachine> > 2
03:29:30 <lambdabot>   2
03:29:32 <quicksilver> and causes memory leaks I think
03:29:36 <benmachine> everything else seems fine
03:29:36 <Le-Chuck_ITA> |Steve|: whenever F and U are adjoints and f : a -> Ub, then fâ™¯ is the unique arrow from Fa -> b and similarly for g : Fa -> b, gâ™­ is the unique a -> Ub
03:29:41 <ivanm> :o
03:29:48 <Saizan>  @users was from the same plugin
03:29:52 <quicksilver> ah
03:29:54 <ivanm> so it was the cause for lambdabot continually crashing? :o
03:29:57 <quicksilver> that's a sad loss then
03:29:58 <|Steve|> Le-Chuck_ITA: Adjoint functors?
03:30:08 <Le-Chuck_ITA> Yes |Steve|
03:30:22 <ivanm> you sure it wasn't just that there were too many users on the various channels lambdabot was signed on to? :p
03:30:27 <Le-Chuck_ITA> But looking at that with daylight, perhaps it's just the pretty obvious property that I was lacking yesterday
03:30:38 <quicksilver> ivanm: yes, we're sure.
03:30:38 <Saizan> ivanm: the serialization of the state was unreliable
03:30:58 <ivanm> ahhh
03:31:11 <Saizan> ivanm: if you want to send a patch to fix the seen plugin, however..
03:31:16 <ivanm> heh
03:31:24 * ivanm has too many projects he's working on atm :(
03:31:51 <|Steve|> Le-Chuck_ITA: Hmm, I'd have to think about it, but 3:30am is not the time. It's time for sleep.
03:32:02 <Le-Chuck_ITA> |Steve|: thanks anyway :)
03:32:10 <Le-Chuck_ITA> I have daylight here
03:33:45 <Saizan> preflex_: users
03:35:14 <Saizan> uhm, anyone with a clear understanding of the management of state for lambdabot's plugins?
03:37:07 <quicksilver> Saizan: No one.
03:37:16 <quicksilver> Saizan: and I don't just mean I don't. I mean "No one" ;)
03:37:29 <ivanm> how about a partial, or even a _slight_ understanding?
03:37:42 <ivanm> quicksilver: not even the person who originally wrote it? or did it mutate over time?
03:38:19 <Saizan> it probably mutated.
03:39:12 <quicksilver> I don't actually know who wrote that stuff.
03:39:21 <quicksilver> dons was involved in some early version wasn't he?
03:40:51 <Saizan> it seems every plugin is responsible for writing out its own state to disk and i'm afraid that doesn't mix well with sigTERM or other non-@quit termination
03:41:19 <quicksilver> that's why gwern likes to type @flush after each time he @remembers a new quote
03:41:25 <yaxu> an irc bot that no-one understands the workings of has to be a fine precursor to artificial intelligence
03:41:31 <ivanm> heh
03:41:43 <ivanm> @remember yaxu [about lambdabot] an irc bot that no-one understands the workings of has to be a fine precursor to artificial intelligence
03:41:43 <lambdabot> Nice!
03:41:50 <quicksilver> @flush
03:41:50 <lambdabot> Not enough privileges
03:41:56 <quicksilver> haha :)
03:41:57 <ivanm> heh
03:42:13 <quicksilver> Saizan: surely it's not beyond the wit of man to handle SIGTERM and call @flush? :)
03:42:30 <quicksilver> Saizan: and add a timer to @flush every N minutes
03:42:51 <pozic> Probably how an AI initially works will be understood; how it will work when it has been operating for a few years will be completely impossible to understand for the simple reason that it has crossed the human intelligence boundary.
03:42:57 <ivanm> quicksilver: the latter would probably be at least a good short-term solution
03:43:06 <benmachine> so I darcs got lambdabot and it said
03:43:06 <benmachine> Warning: CRC errors found. These are probably harmless but should be repaired.
03:43:12 <benmachine> See 'darcs gzcrcs --help' for more information.
03:43:24 <benmachine> and then I did darcs gzcrcs --check and it didn't complain
03:43:26 <benmachine> red herring?
03:44:00 <opqdonut> gzcrcs, gotta love
03:44:11 <ivanm> benmachine: you did --check, not --help!
03:44:11 <Saizan> quicksilver: yeah, the question is how much i need to dive into lambdabot's code to see if something like that it's done already :)
03:44:15 <ivanm> now the world will _end_!!!!
03:44:37 <benmachine> ivanm: :(!
03:44:58 <Saizan> benmachine: i think darcs fixes the errors while getting
03:45:04 <benmachine> ah ok
03:45:21 <int-e> benmachine: The upstream repository probably has that problem - but your local copy got converted to hashed format, rewriting all patches from scratch, and fixing the problem.
03:45:44 * Saizan wonders if it's sensible to run darcs gzcrcs --check on code.haskell.org
03:46:06 <benmachine> lambdabot's code confuses me a little
03:46:09 <benmachine>     ld = fromMaybe (error "no dynamic loading") Nothing
03:46:41 <Saizan> that's from when plugins could be loaded dynamically without restarting the bot
03:47:13 <benmachine> but they can't anymore so that weird snippet remains
03:47:36 <benmachine> or can they
03:47:48 <Saizan> the can't, i think
03:49:46 * benmachine looks at a pair of imports that seems to be repeated three times consecutively
03:49:56 * Saizan is tempted to use happstack-state
03:50:32 * benmachine wishes firefox would open things as text even if it didn't know what they were
03:51:15 <Botje> benmachine: oh, believe me, it does.
03:51:16 <ivanm> benmachine: there's the "Open As" extension IIRC
03:51:35 <Botje> i'm looking at you, multi-megabyte .run files that get sent as text/plain.
03:51:41 <benmachine> heh
03:52:12 <quicksilver> benmachine: that bug has been open in firefox for about 8 years
03:52:14 <Saizan> oh, there's moduleSerialize!
03:52:22 <quicksilver> benmachine: it makes me despair about the project being able to acheive anything at all
03:52:48 <benmachine> quicksilver: :( but isn't that always the way?
03:53:55 <benmachine> any project sufficiently large accumulates little things that the developers hope nobody really notices
03:54:18 <lilac> i wish firefox would use an appropriate platform-specific 'open with' dialog rather than asking me to find a ****ing binary somewhere in my file system
03:54:47 <benmachine> what would you have it do, give you every binary in your PATH to choose from?
03:55:00 <benmachine> or maybe a text box would work
03:55:07 <lilac> benmachine: i would have it usae an appropriate platform-specific 'open with' dialog
03:55:16 <lilac> such as the standard Windows one, or the standard KDE one.
03:55:25 <benmachine> lilac: oh, I see what you mean
04:03:24 <dons> who was asking about plugins?
04:03:31 <dons> yes, the lambdabot design is described in 'plugging haskell in'
04:03:33 <dons> 2004 or so
04:03:50 <dons> i hope to revisit hotswapping with ghc-api sometime soon
04:04:38 <Vq> dons: i did
04:05:18 <Vq> dons: it was a few years ago though, so im not sure exactly what i was asking about
04:07:50 <quicksilver> dons: a bunch of us were pondering lamdbabot failings
04:07:57 <quicksilver> dons: and wondering who (if anyone) understands the code now :)
04:08:09 <Saizan> especially how it deals with serializing the state
04:08:27 <FunctorSalad_> McBride: "The â€˜Pâ€™ in â€˜PFixâ€™ is silent, and similarly for â€˜PInâ€™, â€˜pfoldâ€™, and â€˜punfoldâ€™ â€” no unintended."
04:08:36 <Saizan> since the seen plugin seems to try to do it by itself, while there's a moduleSerialize
04:10:06 <dons> i wrote about 90% of it, so i think i'm the main person. sjanssen and gwern have looked at it too.
04:10:14 <dons> thomas yaeger understood most of it at one point.
04:15:42 <Saizan_> FunctorSalad_: haha, from where?:D
04:16:27 <FunctorSalad_> Saizan_: http://strictlypositive.org/slicing-jpgs/
04:21:03 <FunctorSalad_> "A bifunctor is just a functor from a product category. \\ \\ What do you mean you don't have product categories? "
04:24:32 <Alpounet> what's the problem with lambdabot last days ?
04:24:59 <SamB_XP> Alpounet: maybe the usual?
04:28:08 <Alpounet> that's to say ?
04:29:00 <SamB_XP> Alpounet: memory leaks ... or something ?
04:33:05 <quicksilver> @bot
04:33:05 <lunabot>  :o
04:33:05 <lambdabot> :)
04:33:12 <quicksilver> Alpounet: the problem yesterday was mmorrow broke it
04:33:19 <quicksilver> that's the only problem I'm aware of.
04:33:29 <quicksilver> dons: we were bemoaning the death of @users in particular
04:33:40 <quicksilver> dons: and wondering how hard it would be to fix enough of @seen to fix it.
04:35:12 <Le-Chuck_ITA> Still, speaking of adjunction, I now proved that if the inclusion functor of a full subcategory has a right adjoint, then the inclusion preserves *and reflects* colimits. This observation is present in Mitchell's book, but not in McLane and other books, is there a mistake there?
04:35:40 * dons wants to know what was wrong with it.
04:35:59 * benmachine is trying to get lambdabot's haddock building and not doing very well
04:36:01 <quicksilver> dons: well in general terms it leaked.
04:36:07 <quicksilver> dons: in specific terms, I never managed to work it out
04:36:11 <dons> ah
04:36:15 <dons> k, that's fine.
04:36:21 <quicksilver> dons: (I spent an hour or two looking at it and suggested some strictness annotations but they didn't solve it)
04:36:34 <quicksilver> IIRC Saizan_ also took a look
04:36:38 <quicksilver> this was months ago, last year I think
04:36:53 <dons> yeah, i know this bug. never looked very hard for it
04:39:15 <kalven> o_O
04:39:28 <Saizan_> also, seen stopped being able to [de]serialize the state properly at some point, and it took down lambdabot with it when the parsing failed
04:39:44 <Saizan_> that has probably been introduced with the use of Binary
04:42:32 <dons> hmm. no. it was fine for years with binary
04:42:39 <dons> but it just hasn't been maintained for a loong time
04:43:05 <Saizan_> well, this bug is years old :)
04:43:20 <dons> lambdabot's 8 years old :)
04:43:32 <quicksilver> happy birthday lambdabot!
04:43:49 <Saizan_> i thought Binary was younger than that
04:43:56 <SamB_XP> Saizan_: so, you're saying lambdabot can't just forget about the seen db when it gets corrupted?
04:43:59 <dons> it is!
04:44:03 <dons> but     the bug is even younger
04:44:22 <Saizan_> SamB_XP: it could, if it checked for it
04:44:38 <Saizan_> SamB_XP: but that's not the easiest thing to do if you're parsing with Binary
04:44:49 <Saizan_> you can rnf inside a catch i guess
04:45:14 <ksf> maybe we should set her up with happstack, wait for the baby and then let her enjoy her retirement...
04:45:47 <Saizan_> also, i don't understand why the Seen plugin uses moduleInit and moduleExit to deal with the state instead of moduleSerialize
04:45:47 <ksf> at least wrt. state, me thinks.
04:46:24 <Saizan_> ksf: i thought about that too
04:47:24 <Saizan_> we'd need to write some tools to inspect an happstack managed state from outside the process though, to merge quotes into the repo etc..
04:49:49 <ksf> happstack-data should know about concurrent processes, shouldn't it?
04:49:55 <ksf> ...given multi-master and all.
04:50:40 <ksf> anyway, as long as you don't want to write into lambdabot's memory while she's conscious, things should be fine.
04:51:26 <ksf> we don't want her to suddenly become shizophrenic and think she's nixon, now do we?
04:51:47 <ksf> @vixen what do you think about communists?
04:51:48 <lambdabot> Solutions are not the answer.
04:51:57 <SamB_XP> ksf: you have to admit, that would be fun!
04:52:01 <Saizan_> i'm not even talking about concurrent, just an externally/human readable format for the plugins that need it
04:52:20 <Saizan_> and it's not something hard, i imagine
04:52:45 <ksf> well... read the data in, with the same code lambdabot uses, then use the show instances...
04:56:13 <ksf> ...and sandbox every single plugin, by itself.
04:56:22 <ksf> that is, generalize mueval.
04:57:12 <Saizan_> a different process for every command?
04:57:32 <Saizan_> s/command/command invocation/
04:57:42 <Saizan_> uhm, it looks like we should write it in erlang then :)
04:58:15 <ksf> http://en.wikipedia.org/wiki/The_Physicists  <--- read.
04:58:21 <quicksilver> you have to use a different process for every command
04:58:27 <ksf> (the play, not just the article)
04:58:34 <quicksilver> that's the only reliable sandbox we have
04:59:18 <ksf> (it's full of spoilers)
04:59:28 <ksf> actually, they should make a movie out of it.
05:00:22 <Saizan_> you could keep a process alive for every plugin and have the central one restart it if it's not responding
05:03:20 <ketil> Hi!  I was looking for some fun graphics to candy up a talk I'm giving, and I looked at the language game née shootout.
05:03:49 <ketil> Unfortunately, the Haskell contributions have been optimized and tweak back and front, so I don't think they represent idiomatic haskell anymore.
05:04:02 <ksf> ...where you stumbled across the haskell logo and were so impressed that you came over here?
05:04:27 <ketil> My main problem is that they are really verbose, but I think nice Haskell is terser than e.g. Perl or Python.
05:04:32 <SamB> ksf: apparantly he wanted Haskell graphics ?
05:04:43 <ketil> ksf, yeah, sure.  Where is the ticket office? :-)
05:05:08 <SamB> isn't there a "mostly idiomatic Haskell" shootout entry?
05:05:12 <ksf> got a link to that shootout?
05:05:24 <SamB> @go programming language shootout
05:05:24 <lambdabot> Maybe you meant: google googleit do
05:05:32 <ketil> SamB, yes.  But now I want better Haskell submissions - hm, maybe.  I only found 'Haskell GHC' there.
05:05:39 <ksf> ...you don't mean the debian one, do you?
05:05:48 <SamB> ksf: what else ?
05:06:03 <ketil> Java has a bunch (-Xint, -server, etc), and Python has a separate Python 3, so it should be possible.  And is desirable, IMO.
05:06:08 <ksf> ...'cos ketil mentioned games and graphics
05:06:13 <SamB> ketil: even if we wanted idiomatic Haskell, they won't let us use Arrays of Bool ...
05:06:21 <ksf> ah. graphics. graphs.
05:08:10 <ksf> arrays of bools?
05:08:17 <ksf> don't tell me they get bit-packed.
05:08:20 <ketil> SamB - no?  But, okay, rules are rules - no way around that.  But I think the otherwise brilliant scatterplots send the wrong message.  And the source code is...well, not idiomatic is a nice way to put it :-)
05:08:33 <ketil> ksf, of course, what else would be the point :-)
05:08:44 <ksf> zomfg
05:08:49 <ksf> why did noone tell me?
05:09:19 <ketil> ksf, (depending on your compiler blah blah - but GHC used to do it, and it used to be a huge win in many cases)
05:09:26 <ksf> ...so, what's their argument?
05:09:34 <SamB> ksf: cheating or something!
05:09:44 <ksf> where's the difference to bitmasking an array of say Word64?
05:09:46 <ketil> ksf, probably that it's unfair to the more pedestrian languages, where you have to do this manually.
05:10:08 <ksf> YOU CAN DO IT AS A LIBRARY IN HASKELL!
05:11:28 <benmachine> pretty much any language can represent bit packs
05:11:38 <ksf> so, to write ideomatic code, we have to have sufficiently smart opponents...
05:11:55 <ksf> well, but not with the same interface as arrays.
05:12:58 <Jafet> ksf, why not?
05:13:53 * ksf can't think of a way in C
05:14:03 <ksf> the macro processor isn't powerful enough.
05:14:12 <Jafet> (Fun fact: C++ decided vector <bool> would require use of packing optimization, which broke their own vector <> interface.)
05:14:13 <benmachine> well with C it's ugly
05:14:20 <benmachine> but that's C for you >_>
05:14:22 <ksf> ...or, rather, you won't get it to use square brackets.
05:14:39 <benmachine> vectorGetBit(vector *v, int i);
05:14:40 <benmachine> etc.
05:14:43 * Jafet wonders how C crept into all this
05:14:59 * ksf is trying to find that paper about mapping trees to lists to arrays to binary trees to whatever.
05:15:12 <ksf> ...in general, a framework to represent everything as everything.
05:15:12 <benmachine> Jafet: because apparently haskell's bool arrays are too good for the shootout :P
05:15:19 <Jafet> Oh, my.
05:15:39 <ksf> benmachine, you can't fold over that.
05:15:55 <Jafet> ksf, tcl!
05:16:16 <ksf> ...and, tbh, mapping neg over an Array Bool is'nt quite as effective as doing the same thing byte-wise.
05:17:17 <benmachine> ksf: you can fold over it, it's just really awkward and verbose
05:17:24 <benmachine> due to C
05:21:01 <ksf> hell there's just too many papers about data structures.
05:23:43 <ksf> ...no, not the boom hierarchy, but that's close.
05:30:19 <benmachine> are there any Functors that don't implement either pure or return?
05:31:02 <benmachine> oh apparently Map doesn't
05:31:42 <benmachine> that sort of makes sense I suppose
05:33:51 <ksf> that bit-packing is obviously implemented in the stdlib, not in the compiler
05:34:04 <ziman> benmachine, also (,) a
05:34:17 <ziman> (afaik)
05:34:55 <benmachine> yeah that too
05:35:01 <benmachine> odd though
05:35:16 <benmachine> (,) a could implement <*> without much trouble I'd have thought
05:35:17 <benmachine> but not pure
05:35:30 <doserj> (,) a needs a Monoid a constraint. Data.Map k would need a (Enum k, Bounded k) constraint
05:36:25 <opqdonut> ah, return x = (mzero,x) ?
05:36:38 <benmachine> mempty, I'd have thought
05:36:41 <doserj> yes
05:36:43 <opqdonut> gah
05:36:44 <opqdonut> yes
05:36:45 <hackagebot> liboleg 2009.9.1 - A collection of Oleg Kiselyov's Haskell modules (2009-2008) (DonaldStewart)
05:36:48 <opqdonut> stupid names
05:36:52 <benmachine> heh
05:36:54 <opqdonut> heh, liboleg
05:36:54 <benmachine> indeed
05:37:11 <opqdonut> (,) is also almost an Arrow
05:37:15 <Vq> 09 to 08?
05:37:34 <benmachine> you could have return x = (undefined, x)
05:37:42 <benmachine> not sure why you'd want such a thing though
05:38:20 <opqdonut> that's not really fair
05:38:29 <benmachine> probably not, no
05:38:34 <opqdonut> but again, having a and b be pointed types solves this
05:38:51 * benmachine does instance Monad ((,) a) where (>>=) = undefined
05:38:52 <benmachine> woo.
05:39:36 <dons> blackdog: gonna put your slides online?
05:40:47 <hackagebot> semiring 0.1.1 - Semirings, ring-like structures used for dynamic programming applications (SashaRush)
05:41:06 <FunctorSalad_> SamB: arrays of bools were explicitly banninated?
05:43:00 * doserj just learned a new word
05:43:22 <lilac> benmachine: yeah, there are a few things which have <$> and <*> but not pure. i think the argument against having a typeclass for Applicative - Pointed is that it's hard to give any laws for it
05:43:23 * Vq just got confused by a new word
05:43:57 <gwern> hard to give any laws? then how did anyone come up with applicative?
05:44:22 <lilac> gwern: by using pure
05:44:39 <gwern> ?
05:44:50 <doserj> every applicative law mentions pure
05:44:53 <FunctorSalad_> I didn't quite get the above shootout conversation... so they can to bit operations in C, but using Array of Bools in haskell is banned or what?
05:45:42 <ksf> ...well... you could just copy the right part of the array package and claim it's not a language feature...
05:46:24 <FunctorSalad_> how does Array accomplish this? rewrite rules?
05:46:35 <FunctorSalad_> (the packed bits optimisation)
05:46:36 <burp> um, Crypto: Codec.Utils has some strange behaviour
05:46:37 <ksf> no, just plain and simple index mangling.
05:46:46 <burp> > fromOctets 256 [1,2,3] :: Word64    results in 66051
05:46:48 <ksf> ...and bitmasking, of course.
05:46:48 <lambdabot>   <no location info>: parse error on input `in'
05:46:56 <burp> but > listFromOctets [1,2,3] :: [Word64] results in [197121]
05:47:05 <burp> which is just fromOctets 256 [3,2,1], so reversed
05:47:23 <FunctorSalad_> ksf: I meant how it accomplished specializing to the opt. version if the type param is Bool
05:47:28 <gwern> the shootout, I think, hurts minimalist languages. on the other hand, scheme vs python has arguably shown that maybe such languages should be hurt lest people try to use them
05:47:32 <ksf> burp, your machine's endianess is reversed?
05:47:50 <ksf> Instance UArray Bool where...
05:48:26 <burp> no, usual intel
05:48:34 <ksf> well that's it.
05:48:45 <ksf> x86's endianess has been fucked up from the start.
05:48:53 <ksf> little-endian is evil.
05:48:57 <doserj> instance IArray (UArray Bool) where ..., rather
05:49:58 <FunctorSalad_> ok, thought "Array Bool"
05:50:10 <doserj> err, instance IArray UArray Bool where ..., actually
05:51:51 <doserj> it's a mulitparam type-class, exactly to enable specializations for specific element types
05:52:57 <FunctorSalad_> nice
05:59:43 <DrSyzygy> Random observation. Thank you dons for pointing out the combo haskellwiki.vim and w3m.
05:59:56 * DrSyzygy is enjoying editing his lecture notes quite a bit more in vim than in Firefox.
06:08:01 <lilac> re <$> and <*>. i think we'd want at a minimum that fs <*> (g <$> xs) == ((.g) <$> fs) <*> xs
06:08:25 <lilac> but i suspect that's a free theorem anyway
06:11:09 <lilac> also fs <*> (gs <*> xs) == (fs <*> (flip (.) <$> gs)) <*> xs.
06:12:26 <lilac> actually, RHS should be "(((.) <$> fs) <*> gs) <*> xs" i think.
06:12:56 <byorgey> DrSyzygy: you're putting your lecture notes on the haskellwiki?
06:14:06 <byorgey> ah, http://haskell.org/haskellwiki/User:Michiexile/MATH198
06:14:11 <byorgey> DrSyzygy++
06:14:34 <doserj> lilac: the second is the composition law for applicatives, yes
06:15:51 <doserj> also written as fs <*> (gs <*> xs) == pure (.) <*> fs <*> gs <*> xs
06:16:21 <lilac> doserj: right, but in a world without pure we can't write it that way
06:16:48 <doserj> yep
06:17:14 <lilac> can we deduce the first one from the second somehow? it looks like that should be possible
06:17:51 <lilac> if we had 'pure' we could substitute gs = pure g
06:20:50 <doserj> lilac: using the interchange law, you can, I guess. fs <*> pure g = ($ g) <$> fs
06:22:11 <lilac> doserj: that's not a valid deduction in this new system, though
06:22:25 <lilac> (since there /is/ no interchange law)
06:22:29 <doserj> :)
06:23:08 <doserj> if you don't have any law for pure on the right side of <*>, it is going to be difficult
06:23:12 <lilac> i think what we want to say is that any pure-free laws which can be deduced from the applicative laws should hold
06:24:21 <dolio> What are the structures that have (<*>) but not pure?
06:24:34 <doserj> Data.Map
06:24:38 <lilac> Data.Map k and (,) a were the two examples from before
06:24:43 <benmachine> Data.Map could do but I don't think it does
06:24:54 <benmachine> and I looked at (,) and couldn't get a <*> that was actually useful
06:25:15 <lilac> there're two for (,) a: (a,f) <*> (b,x) = {(a,f x), (b,f x)}
06:25:35 <benmachine> yeah, neither of them are much use :P
06:25:47 <lilac> yep. Map could be handy though, i imagine
06:25:49 <doserj> (a,f) <*> (b,x) = (mappend a b, f x)
06:26:02 <quicksilver> lilac: it's called intersectionWith ;)
06:26:10 <quicksilver> :t Data.Map.intersectionWith ($)
06:26:12 <lambdabot> forall b b1 k. (Ord k) => M.Map k (b -> b1) -> M.Map k b -> M.Map k b1
06:26:21 <lilac> quicksilver: nice :)
06:26:29 <quicksilver> intersectionWith is the single best function in the whole haskell standard library.
06:27:00 <quicksilver> sum $ intersectionWith (*) -- calculate total prices from line prices + line quantities
06:27:08 <ivanm> quicksilver: is it? I've never heard of it...
06:27:13 <ivanm> @index intersectionWith
06:27:13 <lambdabot> Data.IntMap, Data.Map
06:27:14 <quicksilver> intersectionWith (-) -- reduce stock by line quantities
06:27:31 <ivanm> @hoogle intersectionWith
06:27:31 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
06:27:31 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
06:27:31 <lambdabot> Data.IntMap intersectionWithKey :: (Key -> a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
06:27:49 <benmachine> quicksilver: why do you have separate maps for all these quantities?
06:28:08 <Alpounet> quicksilver, similar to zipWith right ?
06:28:14 <Alpounet> but for maps.
06:28:40 <quicksilver> benmachine: because that is the natural way to store them?
06:29:06 <quicksilver> benmachine: how else would you store {apples => $0.50, oranges => $1.50, cherries => $0.75}
06:29:17 <quicksilver> or an order {apples => 4}
06:29:46 <dolio> You can make a wrapper around Map that yields a pure for that applicative, unless I'm missing something.
06:29:58 <dolio> pure a is a map where a is stored at every key.
06:30:03 <benmachine> quicksilver: I mean, you have {apples => 4, oranges => 5} and {apples => Â£2, oranges => Â£3} instead of {apples => (4, Â£2), oranges => (5, Â£3)}
06:30:19 <quicksilver> benmachine: because a price list is totally different from an order
06:30:28 <quicksilver> benmachine: note that I am *only* buying apples
06:30:47 <quicksilver> why should I list "0" next to the 912,456 products I am not buying?
06:30:56 <quicksilver> that would make a very unwieldly shopping troller implementation.
06:30:58 <benmachine> quicksilver: I suppose so
06:31:30 <CalJohn> @type (=<<)
06:31:31 <benmachine> but it just seemed odd to me that you have duplicated keys in your stock tracker and price lookup
06:31:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
06:31:54 <CalJohn> @type (>>=)
06:31:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:32:08 <DrSyzygy> byorgey: The availability of my lecture notes has throughout been one of the very most requested features of this course.
06:32:19 <DrSyzygy> byorgey: And at least 3 ppl have suggested the haskell wiki as a good place to put them.
06:32:30 <DrSyzygy> So yeah, I'm developing my course on the haskell wiki.
06:32:35 <lilac> benmachine: the keys could be just that -- unique keys, rather than product names. the point still holds.
06:33:18 <gwern> DrSyzygy: hm. does your university allow that?
06:33:30 <DrSyzygy> gwern: Good question. At one point I should find out.
06:33:31 <gwern> some universities claim copyright on student or lecture work, such as lecture notes
06:33:35 * lilac ponders whether there are any other interesting cases of almost-Applicative
06:33:47 <gwern> which, or other claims, would be inconsistent with hawiki's license
06:33:48 <quicksilver> benmachine: much better that way than listing exhaustively everythign I'm not buying ;)
06:34:22 <ivanm> DrSyzygy: especially since IIRC, everything on the wiki is CCA...
06:34:44 * DrSyzygy wants CC for my work anyway... Just have to figure out who I need to file what paperwork with to make THAT happen...
06:35:06 <dolio> lilac: The (,) example is just the (,) w applicative with the First monoid, too.
06:35:10 <gwern> ivanm: or something like that; not sure our simple permissive license is *exactly* the same as CC-BY-SA
06:35:14 <gwern> or CC-SA
06:35:22 <ivanm> gwern: yeah, something like that
06:35:43 <dolio> So I'm not sure either of those are compelling.
06:35:55 <lilac> dolio: yeah, that's true. it's not very interesting anyway :)
06:36:09 <benmachine> if you require w to be a Monoid then you get a pure anyway
06:36:57 <lilac> dolio: i guess for any such structure s, data AddPure s a = Pure a | Impure (s a) is a real Applicative
06:37:27 <dolio> Yeah, I think so.
06:41:03 * DrSyzygy sends off an email to his supervisor checking for more info.
06:41:59 <ksf> the simple permissive license isn't cc-by-sa at all.
06:42:09 <ksf> it's public domain, spelled out.
06:42:12 <quicksilver> lilac: how do you define (Impure x) <*> (Pure y) ?
06:42:28 <quicksilver> (without knowing the internals of the structure s)
06:42:32 <ksf> ... +disclaimer.
06:42:58 <ksf> ...which is a thing only nescessary in a judicative system as fucked up as the usa's one.
06:43:03 <dolio> Impure x <*> Pure y = Impure (($y) <$> x)
06:43:26 <ksf> "do not dry pets in microwave"
06:43:27 <jfoutz> DrSyzygy: wow. that's really cool.
06:43:39 <quicksilver> dolio: ah, right.
06:43:42 <DrSyzygy> HAH! I found the university copyright policy!
06:43:47 <quicksilver> dolio: fmap ftw.
06:43:47 <DrSyzygy> >> In accord with academic tradition, except to the extent set forth in this policy, Stanford does not claim ownership to pedagogical, scholarly, or artistic works, regardless of their form of expression. Such works include those of students created in the course of their education, such as dissertations, papers and articles.
06:44:19 <DrSyzygy> And they also include "textbooks" in things they don't claim copyright to!
06:44:45 <quicksilver> yup
06:44:48 <ksf> ...and what's "except to the extent set forth"?
06:44:57 <quicksilver> traditionally professors are allowed to make about $3.50 from publishing textbooks
06:45:00 <quicksilver> based on their lecture notes
06:45:23 <quicksilver> I know one professor who made enough profit from his textbook to buy an entire bottle of wine
06:45:28 <quicksilver> that's an isolated case, though.
06:45:53 <DrSyzygy> It is that if I work from specific allocation of university funds on this (I'm not), or I work under direction from the University for a specific University purpose (I'm not).
06:46:51 <DrSyzygy> http://rph.stanford.edu/5-2.html if anyone wants to slog through it. It seems to me that I'm free to write whatever I want wherever I want, though.
06:47:17 <DrSyzygy> Since it is a pedagogical work that's produced without specific allocation of university funds for its creation.
06:47:29 <ivanm> DrSyzygy: better to be safe than sorry though...
06:47:44 <Jafet> Asking for permission is the best way to get a no
06:47:46 <DrSyzygy> Yeah. And I've sent off the question to my supervisor already.
06:47:52 * ksf doesn't get how they could ever claim copyright on stuff that they especially contracted you to do, anyway.
06:48:34 * jfoutz suspects they would call that work for hire.
06:49:09 <ksf> ...but then I know of an american company which, out of thin air, mentioned that everything on company pc's was their property.
06:49:17 <ksf> I tended to disagree, which I told them
06:49:36 <ksf> (stopping just a fraction of an inch before the term "theft")
06:50:06 <DrSyzygy> My position at Stanford is a postdoctoral researched, funded by the navy to do research on topological data analysis. My funding and my position allows for some extent of "extracurricular activities", and my teaching is one of these. Hence, I'm cool with the ONR, since it's part of what they expect I do on the side anyway, and I'm cool with theUniversity, since I'm not appropriating ANY University funds, much less specifically directed Un
06:50:10 <ksf> ...like my collection of oggs and the one or other gpl program I wrote.
06:50:54 <ivanm> ksf: if it's on the PCs, they own it?
06:51:02 <jfoutz> ksf: interesting tactic. i would have had them clarify in writing that they owned windows.
06:51:03 * ivanm thinks Bill Gates would disagree...
06:51:06 <ksf> ...they shut us down before the situation was cleared.
06:51:17 <ksf> jfoutz, well, I mentioned that.
06:51:24 <jfoutz> :)
06:51:32 <ivanm> dammit, looks like I was 1) too slow, and 2) too vague :(
06:51:58 <ksf> I was worried about _my_ property, though.
06:52:04 <ksf> to hell with M$.
06:52:21 * DrSyzygy goes back to editing his lecture notes.
06:52:28 <jfoutz> well, if you get them to cave on the one they *know* they'll lose, it's much easier to have the my property fight.
06:53:15 <ksf> you know, they didn't actually _try_ to take my oggs and/or sell my fretboard calculator.
06:53:34 <medfly> about the profit from books - I heard of a person (also, a professor, but the book is probably not from his lecture notes) who published a book, he gets like $1 or so from each book sold, he just happened to have sold a million copies.
06:53:47 <Pthing> stewart
06:54:02 <ivanm> Pthing: the maths book?
06:54:04 <medfly> $3.5 seems pretty high :)
06:54:08 <Pthing> the very same
06:54:19 <Pthing> he built a ludicrously oversized house from the proceeds
06:54:20 <ivanm> if he only gets $1, then the publishers are definitely charging a pretty penny
06:54:28 <ivanm> seeing as how stewart isn't that great a book
06:54:36 <Pthing> it is not great
06:54:39 <Pthing> but it *is* popular
06:54:40 <Pthing> result
06:54:40 <Pthing> http://castingoutnines.wordpress.com/2009/04/06/where-the-money-for-your-calculus-book-goes/
06:54:48 * ivanm knows a lot of people who wished we had kreyszig rather than stewart as our first year text
06:55:25 <medfly> "Prof. Stewart for building his dream home, for which he apparently saved up money for 60 years."
06:55:46 <ksf> 150 dollars?
06:55:48 <ksf> wtf?
06:56:57 <quicksilver> medfly: I meant 3.5 in total, not per book ;)
06:57:21 <ivanm> $120 down under
06:59:07 <sinelaw> hi, looking at an example from The Implementation of Functional Programming Languages
06:59:24 <medfly> oh, okay.
06:59:26 <sinelaw> why are these two different in terms of lazy pattern matching:
06:59:55 <sinelaw> tack x xs:xss = (x : xs) : xss
07:00:12 <sinelaw> vs.  tack x xss = (x : hd xss) : tl xss
07:00:15 <ksf> just for a comparison, that's the one we used: http://www.amazon.de/Mathematik-Ingenieure-Naturwissenschaftler-Naturwissenschaft-%C3%9Cbungsaufgaben/dp/3834805459/ref=sr_1_1?ie=UTF8&s=books&qid=1252418366&sr=8-1
07:00:20 <ksf> ... 29 euros.
07:00:27 <ivanm> sinelaw: latter fails if xss is empty
07:00:28 <Twey> The former is invalid, sinelaw
07:00:48 <ksf> (and it's 29 euros everywhere, books and mags etc. have fixed prices in germany)
07:00:48 <ivanm> Twey: why? looks OK to me...
07:00:56 <Twey> tack x xs : xss means tack ((x xs) : xss)
07:01:01 <ivanm> @type \ x (xs:xss) -> (x:xs) : xss
07:01:02 <lambdabot> forall a. a -> [[a]] -> [[a]]
07:01:15 <ivanm> Twey: well, bracketing, yeah
07:01:15 <Twey> But of course â€˜xâ€™ can never be a constructor, so you can't match on it
07:01:42 <sinelaw> ok, so tack x (xs:xss)
07:03:11 <quicksilver> what would you call a feature where you could match on a variable constructor without knowing what it was? Higher-order pattern matching?
07:03:19 <sinelaw> so what's the difference
07:03:29 <Twey> quicksilver: Variable patterns?
07:03:30 <ivanm> sinelaw: I already said it, look above ;-)
07:03:44 <sinelaw> ah missed that
07:04:13 <jfoutz> quicksilver: prolog?
07:04:25 <quicksilver> possibly so, yes.
07:04:35 <Berengal> quicksilver, first-class patterns
07:06:36 <sinelaw> ivanm, but also the second one does
07:06:45 <sinelaw> only not in the pattern matching stage
07:06:46 <ivanm> latter == second one...
07:06:52 <sinelaw> i meant the other one :)
07:06:59 <ivanm> heh
07:07:12 <ivanm> well, I assumed there was an empty case you just didn't type in..
07:07:44 <ivanm> the efficiency of the two is slightly different, with the second one having to deconstruct the list twice...
07:08:07 <Twey> Berengal: Nah
07:08:25 <Twey> Berengal: They're not first-class â€” you still can't pass them around and operate on them
07:08:56 <sinelaw> i think the difference lies in the case of infinite lists, no?
07:10:04 <ivanm> sinelaw: ummm.... I don't think it will make a difference then...
07:10:42 <ivanm> > let tack x (xs:xss) = (x:xs) : xss in take 10 $ tack (-1) [1..]
07:10:43 <sinelaw> well the first one needs to evaluate the first element of the list
07:10:44 <lambdabot>   No instance for (GHC.Enum.Enum [a])
07:10:44 <lambdabot>    arising from the arithmetic sequence...
07:10:44 <ivanm> gah
07:10:58 <ivanm> sinelaw: hmmm.... not infinite lists, undefined lists
07:10:59 <sinelaw> while pattern matching
07:11:19 <benmachine> sinelaw: not exactly
07:11:24 <ivanm> sinelaw: if you never ask for the result of the second one, it will happily take undefined for xss
07:11:25 <RayNbow> > let tack x xss = (x:head xss) : tail xss   in head $ head $ tack 3 []
07:11:26 <ivanm> but the first one won't
07:11:27 <lambdabot>   3
07:11:31 <RayNbow> > let tack x (xs:xss) = (x:xs) : xss         in head $ head $ tack 3 []
07:11:33 <lambdabot>   * Exception: <interactive>:1:141-170: Non-exhaustive patterns in function t...
07:11:35 <benmachine> it needs to evaluate the list sufficiently to work out there is a first element
07:11:44 <sinelaw> RayNbow, yeah that's it
07:12:37 <benmachine> > let tack x ~(xs:xss) = (x:xs) : xss in head . head $ tack 3 []
07:12:39 <lambdabot>   3
07:12:54 <ksf> additionally, there's no argument that's evaluated, anywhere.
07:13:15 <ksf> tack is completely oblivious of anything but ":"s
07:13:41 <sinelaw> ok, got it
07:13:58 <benmachine> hmm
07:14:14 <benmachine> > let tack x ~(xs:xss) = (x:xs) : xss in null $ tack undefined undefined
07:14:16 <lambdabot>   False
07:14:17 <ksf> (in fact, if it wasn't oblivious obout it, it couldn't have a [[a]] type)
07:14:46 <jeffersonheard> So...  am I right in thinking arrows will solve my problem here?  I have a partitioned list ([a],[a]), and I want to apply one function to the left side and one to the right side, then another function on the pair to combine the two.
07:14:57 <ksf> there's nothing you can do to values if you only see forall a . a as type.
07:15:25 <ksf> :t first
07:15:27 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:15:36 <ksf> :t second
07:15:37 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
07:15:42 <ksf> :t uncurry
07:15:44 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:16:10 <jeffersonheard> uncurry f . first g . second h, then?
07:16:39 <ksf> :t uncurry (++) . first toUpper . second toLower
07:16:41 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
07:16:41 <lambdabot>       Expected type: ([a], [a])
07:16:41 <lambdabot>       Inferred type: (Char, Char)
07:16:53 <ksf> :t uncurry (++) . first (map toUpper) . second (map toLower)
07:16:55 <lambdabot> ([Char], [Char]) -> [Char]
07:17:08 <quicksilver> f *** g is the conventional way to write first f . second g
07:17:29 <ksf> > (uncurry (++) . first (map toUpper) . second (map toLower)) ("Foo","Bar")
07:17:31 <lambdabot>   "FOObar"
07:17:50 * ksf thinks *** is obfuscation.
07:17:57 <quicksilver> > uncurry (++) . (map toUpper *** map toLower) $ ("Foo","Bar")
07:17:59 <lambdabot>   "FOObar"
07:18:01 <ksf> that is, I'd have to look it up.
07:18:05 <jeffersonheard> so, quicksilver: uncurry f . (g *** h)  . partition $ a?
07:18:15 <quicksilver> I see *** and &&& used much more often than first and second
07:18:16 <quicksilver> YMMV.
07:18:32 <quicksilver> I never see any of them used on interesting arrows.
07:18:35 <ksf> :t &&&
07:18:36 <lambdabot> parse error on input `&&&'
07:18:39 <jeffersonheard> ksf, I see it as sort of like the OCaml way of specifying tuples
07:18:39 <quicksilver> in fact, I never see interesting arrows used.
07:18:40 <jeffersonheard> Or, I can think of it that way, anyway
07:18:41 <ksf> :t (&&&)
07:18:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:18:49 <ksf> well I never used arrows as such.
07:18:54 <quicksilver> > length &&& reverse $ "foo"
07:18:57 <lambdabot>   (3,"oof")
07:19:01 <ksf> :t (***)
07:19:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:19:14 <quicksilver> (an example is worth 1000 words)
07:19:20 <ksf> indeed.
07:19:23 <quicksilver> althoguh that information is in the type, just the prefix 'a' is slightly hard to read.
07:19:25 <jeffersonheard> quicksilver, indeed
07:19:29 <lispy> I always forget the difference between &&& and ***
07:19:56 <ksf> one is an unfold, the other a map.
07:19:56 <quicksilver> lispy: I used to, but I made myself engrave their types on my thigh with a compass point each time I got it wrong
07:19:58 <lispy> > length *** reverse $ "foo"
07:20:00 <lambdabot>   Couldn't match expected type `([a], [a1])'
07:20:02 <roconnor> what are the duals to &&& and *** ?
07:20:05 <quicksilver> lispy: I learnt after a few weeks.
07:20:09 <dolio> f &&& g is <f , g> from category theory, f *** g is f x g.
07:20:10 <lispy> quicksilver: heeh
07:20:26 <dolio> At least, I think that's how you usually see them.
07:20:29 <jeffersonheard> what's the arity of (***)?
07:20:36 <roconnor> @type (|||)
07:20:37 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
07:20:41 <roconnor> @type (+++)
07:20:43 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
07:20:43 <quicksilver> jeffersonheard: at least 2
07:20:47 <jeffersonheard> k
07:20:53 <quicksilver> jeffersonheard: (if your arrow type is in fact a function, it could be more)
07:20:54 <lispy> :t (***)
07:20:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:20:56 <dolio> f +++ g is f + g, and f ||| g is [f , g]
07:21:04 <quicksilver> and the arrow type here was ->
07:21:10 <quicksilver> so the actual arity was at least 3
07:21:15 <lispy> :t (&&&)
07:21:16 <quicksilver> arity and polymorphism don't mix.
07:21:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:22:00 <lispy> aritymorphism
07:23:00 <jeffersonheard> alright.  that seems to work, thanks.  I have this pattern pop up really quite often, actually.  split list, apply different functions to both sides, recombine
07:23:55 <Axman6> http://selectricity.org/quickvote/sevenlanguages/results excellent news :)
07:24:49 <lispy> Axman6: is that currently slashdotted?
07:24:58 <Axman6> no idea
07:24:59 <lispy> it looks like it may never load
07:25:28 <Axman6> i don't read slashdot (mainly because mail seems to think its emails are spam)
07:25:51 <lispy> Axman6: I just meant the general effect, does /. still exist?
07:26:06 <Axman6> i believe it does, yes
07:26:15 <Makoryu> lispy: Slashdot is the new hangout of Groklaw escapees
07:28:11 <lispy> So, I guess you would often use (+++) after you use (***)?
07:28:25 <Axman6> :t (+++)
07:28:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
07:29:05 <opqdonut> :t (***)
07:29:06 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:29:15 <lispy> :t \x y u v -> u +++ v (x *** y)
07:29:16 <lambdabot> forall (a :: * -> * -> *) b c (a1 :: * -> * -> *) b1 c1 b' c' b'1 c'1. (Arrow a1, ArrowChoice a) => a1 b1 c1 -> a1 b' c' -> a b c -> (a1 (b1, b') (c1, c') -> a b'1 c'1) -> a (Either b b'1) (Either c
07:29:16 <lambdabot> c'1)
07:29:31 <opqdonut> urgh
07:30:05 <benmachine> > pred +++ succ $ Left 4
07:30:07 <lambdabot>   Left 3
07:30:11 <benmachine> > pred +++ succ $ right 4
07:30:13 <benmachine> oops
07:30:14 <lambdabot>   No instance for (Control.Arrow.ArrowChoice Data.Either.Either)
07:30:14 <lambdabot>    arising f...
07:30:18 <benmachine> > pred +++ succ $ Right 4
07:30:20 <lambdabot>   Right 5
07:30:22 <benmachine> woo
07:34:08 <yaxu> oh weird, I just typed this into ghci: writeFile "<tab>
07:34:30 <yaxu> and it showed the contents of my home directory
07:34:42 <yaxu> something very clever is happening there
07:35:17 <lilac> sadly not. it seems to do that after " regardless of context or current directory
07:35:32 <yaxu> oh, fair enough!
07:36:47 <opqdonut> heh
07:38:17 <RayNbow> hmm, pressing tab,y in ghci = bad idea :p
07:40:57 <DrSyzygy> How so?
07:41:23 <benmachine> you can press q to cancel
07:42:02 <yaxu> usually I assume the cleverest basis of every haskell phenomenon, a kind of inverse occam's razor
07:42:09 <lilac> RayNbow: works fine here :)
07:42:17 <quicksilver> that sounds like just default readline behaviour
07:42:31 <quicksilver> ...in the absence of any special completion defintion, use filenames
07:43:04 <RayNbow> lilac: it works fine here too... but... too much output :p
07:43:26 <lilac> RayNbow: only one screenful here. maybe you have more stuff imported :)
07:43:36 <DrSyzygy> yaxu: Did I point you towards http://haskell.org/haskellwiki/User:Michiexile/MATH198
07:43:37 <RayNbow> "Display all 474 possibilities? (y or n)"
07:43:43 <RayNbow> no imports
07:44:00 <lilac> i get 472 :)
07:44:17 <byorgey> DrSyzygy: I will be sure to try to follow along with the course notes =)
07:44:25 <byorgey> DrSyzygy: I know the stuff at the beginning of the course but not at the end.
07:44:26 <RayNbow> about 5 screens here
07:44:28 <DrSyzygy> byorgey: That's the idea of putting them there. :-P
07:44:32 <RayNbow> lilac: hmm, which ghci version?
07:44:37 <byorgey> right, thank you =)
07:44:37 <RayNbow> <-- 6.10.3
07:44:43 <DrSyzygy> byorgey: The stuff at the end may still fluctuate wildly as I actually give my lectures. :-p
07:44:53 <RayNbow> ah wait
07:44:57 <byorgey> well, fair enough, that sounds pretty normal
07:44:58 <RayNbow> I was using ghci-haskeline
07:45:06 <RayNbow> that one gives 2 more possibilities
07:45:07 <DrSyzygy> I'd like to reach the bananas and topoi, but those are among the very first to go if I have to axe things.
07:45:09 <yaxu> DrSyzygy: no, what's that?
07:45:17 <DrSyzygy> yaxu: My teaching project for the fall.
07:45:50 <yaxu> DrSyzygy: aha, now I know your real name, I have power over you!
07:45:53 <RayNbow> (pasting text in ghci is broken in 6.10.3/Win32)
07:46:13 <DrSyzygy> byorgey: Could I ask you to glance over sections 1 and 2 in the first lecture and see if they're intelligeble?
07:46:23 <DrSyzygy> yaxu: I've known YOUR real name for quite a while now.
07:46:38 <byorgey> DrSyzygy: sure, let me go look
07:46:42 <yaxu> DrSyzygy: so you think
07:46:45 <yaxu> :)
07:46:54 <byorgey> ..."I am not left-handed either!"
07:46:57 <DrSyzygy> Well ... yeah ...
07:47:40 * DrSyzygy wonders whether using di.fm's Goa/PsyTrance channel as lecture-planning-music makes the lectures better or worse...
07:47:55 * yaxu is planning his london HUG talk
07:48:04 <yaxu> without any headphones :(
07:48:18 <lilac> RayNbow: also 6.10.3. :-/
07:48:20 <DrSyzygy> yaxu: You can compensate for the lack of headphones with a sufficiently large stereo system.
07:48:58 <yaxu> not in this lab
07:49:00 <sohum> so if ghci is running the main for a set of files, can I ask it to reload any changed files silently, without stopping the main process?
07:49:14 <yaxu> http://docs.google.com/present/view?id=ah2x4mkf2fx_112gwnffpck # slides in progress, comments very welcome
07:49:15 * DrSyzygy needs to go find his faculty host before it gets too late, and then call the Stanford teacher responsible for this year's haskell stuff once it gets late enough.
07:49:52 <lilac> yaxu: i think that only works if DrSyzygy's real name is Rumplestiltskin
07:50:34 <yaxu> heh
07:51:28 <dlewissandy> Is there anyone online that has experiece setting up Darc to push to a mounted cifs drive?
07:51:55 <opqdonut> if it's mounted what's the problem?
07:52:56 <dlewissandy> I keep getting an error that "tentative_pristine-0: rename: already exists"
07:53:09 <yaxu> sohum: does this look useful http://hackage.haskell.org/package/plugins
07:54:25 <dlewissandy> when I push to a local repository everything is fine, but when I push to the CIFS drive I get that error
07:55:00 <opqdonut> seems like the _darcs dir might be a bit broken
07:55:23 <sohum> yaxu: kinda. it seems like they're focusing on extending rather than replacing code, but I'm sure that isn't a difficult barrier
07:55:48 <yaxu> sohum: there's also http://www.haskell.org/haskellwiki/GHC/As_a_library
07:56:28 <yaxu> and this http://hackage.haskell.org/package/hint
07:56:33 <sohum> yaxu: I guess the question I'm really asking is, does lambdabot have to go down and be brought up every time a bug is fixed in him?
07:56:49 <Jafet> Rewrite it in erlang!
07:56:56 <benmachine> I think lambdabot is a her
07:57:03 <sohum> *her, then
07:57:50 <quicksilver> sohum: theoretically no, in practice yes.
07:58:24 <quicksilver> sohum: if I was trying to implement hotboot in lambdabot I'd be inclined to take the route of saving out file descriptors to a file and re-execing self.
07:58:37 <quicksilver> sohum: lambdabot is compiled not interpreted, by the way.
07:59:22 <yaxu> sohum: this paper might be interesting http://www.cse.unsw.edu.au/~dons/papers/SC05.html
07:59:40 <quicksilver> that was about reloading changed plugins
07:59:44 <quicksilver> not the whole application
07:59:46 <idnar> alternatively, just put the bot behind an IRC proxy
07:59:53 <quicksilver> admittedly, that's a hairline distinction.
08:00:06 <quicksilver> lambdabot doesn't do that dynamic loading stuff any more :(
08:00:20 <sohum> yaxu: yea, that paper was linked from hs-plugins
08:00:27 <sohum> quicksilver: hmmm, fair enough
08:00:36 <sohum> idnar: that's ... suprisingly elegant.
08:00:58 <byorgey> yaxu: is there a typo in slide 19? the third example mentions {x, y, ...} but the code has [ ]
08:01:18 <sohum> idnar: stuff like uptime, if it was important, wouldn't behave properly, which means you'd have to maintain some state anyway...
08:01:27 <yaxu> byorgey: yes, thanks
08:01:34 <sohum> quicksilver: "saving out file descriptors"?
08:01:46 <byorgey> yaxu: also, the output looks like it was produced by {orange red blue, green purple WHITE black}  instead of ...green purple RED black
08:01:50 <idnar> sohum: well, it would give you the uptime of the "engine", not the IRC client ;)
08:01:52 <sohum> > putStrLn
08:01:54 <lambdabot>   Overlapping instances for GHC.Show.Show
08:01:54 <lambdabot>                              (GHC.B...
08:02:14 <quicksilver> sohum: save out the state of your file descriptions (in LB's case, basically its socket) and re-exec yourself with the new code
08:02:25 <quicksilver> sohum: that's quite a common hot-upgrade path for network servers
08:02:35 <yaxu> byorgey: ah yes, that's actually beige
08:02:47 <byorgey> yaxu: this is really cool!  do you plan to release this stuff as a library or libraries?
08:02:49 <sohum> just read about lambdabot's catchall instance of Show
08:03:22 <yaxu> byorgey: yes for sure
08:03:26 <sohum> quicksilver: huh. reexecuting yourself with something like Hint or GHC as a library, I take it
08:03:31 <yaxu> before I present it
08:03:45 <byorgey> yaxu: cool, I'd love to play around with it
08:03:45 <yaxu> (next week)
08:05:36 <quicksilver> sohum: no, just compiling yourself and re-execing the compiled executable
08:05:53 <quicksilver> sohum: (or the administrator compiles the new version out of band and then instructs the bot to re-exec the new executable)
08:06:24 <quicksilver> sohum: with the plugins-style dynamic loading you can reload (compiled) modules but I don't know what that does with things like thunsk and closures
08:06:28 <quicksilver> dons: ping?
08:06:41 <sohum> quicksilver: doesn't that... break something? if the bot is executing a version of the bot which is executing a version of the bot which is....
08:07:14 <quicksilver> no.
08:07:20 <quicksilver> exec replaces the current image
08:07:25 <quicksilver> you kill yourself and replace yourself
08:07:30 <sohum> :t exec
08:07:31 <lambdabot> Not in scope: `exec'
08:07:32 <quicksilver> it's a unix thing.
08:07:35 <sohum> oh
08:09:06 <Elly> quicksilver: huh, that had not occured to me as a way of doing updates
08:09:17 <sohum> quicksilver: that is actually really cool
08:10:17 <benmachine> isn't it possible to exec and keep your file descriptors as they are?
08:10:42 <benmachine> unset FD_CLOEXEC or whatever it is
08:11:01 <elbar> xmonad seems to have no problems with compiling and restarting itself
08:11:11 <byorgey> yaxu: where are you giving the talk?
08:11:53 <jokerGTA> hi guys can Integer type be negative number
08:11:56 <yaxu> byorgey: city university, london: http://www.londonhug.net/
08:12:01 <byorgey> jokerGTA: yes
08:12:05 <byorgey> > (-5) :: Integer
08:12:08 <lambdabot>   -5
08:12:12 <byorgey> jokerGTA: sometimes you need parens though.
08:12:38 <sohum> ok, now that that's solved
08:12:43 <byorgey> yaxu: ah, cool.  A bit far for me to travel though... =)
08:12:58 <jokerGTA> because i have this signature myFunction :: [Integer] -> Integer -> Integer
08:13:14 <jokerGTA> which works when I say for exampl    [1,2,3,4] 5
08:13:27 <jokerGTA> but gives error when [1,2,3,4] -5
08:13:31 <byorgey> jokerGTA: right, you need parens around (-5)
08:13:40 <byorgey> jokerGTA: it is being parsed as [1,2,3,4] - 5
08:13:43 <jokerGTA> oh ok
08:14:07 <jokerGTA> thanks
08:14:09 <byorgey> jokerGTA: this is an ugly, shameful corner of Haskell syntax =(
08:14:30 <jokerGTA> :)....yeah i am so new to this..and learning is very steep:
08:14:32 <jokerGTA> 0:)
08:15:02 <byorgey> Indeed. It's a shame it's made steeper by silly things like this.
08:16:24 <mux> is it possible to write a function signature to have a function taking only types for which there is an MArray instance, to use STUArray ?
08:16:32 <jokerGTA> yeah i think it reads that minus as a function if there is no brackets and thats why it gives error..at least now i think that the case
08:16:41 <byorgey> jokerGTA: right.
08:16:56 <mux> since the MArray instance takes the (ST s) monad as a parameter, I'd have to define it too, but then it conflicts with the existential of runST
08:17:19 <byorgey> mux: maybe you need to use Rank2Types and wrap it in a forall s. ?
08:17:34 <byorgey> that's just off the top of my head, I'm not entirely clear on what you're trying ti do
08:17:35 <mux> byorgey: I've tried unsuccessfully, not sure if I did it right though
08:18:01 <mux> byorgey: well, there's a function of type (ideally) Integral a => a -> a -> [a]
08:18:10 <mux> I'd like to restrict the a so that I can use STUArray's
08:18:29 <jmcarthur_work> hmm... i think maybe the first step in more widespread use of monadLib and other mtl alternative is convincing the authors of libraries not expose anything in their interfaces relying on a particular transformer library. don't make an exposed type an instance of MonadReader. make a new type class with the proper abstractions for that type instead, etc.
08:18:44 <mux> this means having something like forall s a. (MArray (STUArray a) a (ST s), Integral a) => ...
08:19:00 <mux> jmcarthur_work: monadLib still lacks MonadError btw
08:20:08 <jmcarthur_work> mux, i don't use MonadError all that much. i guess ExceptionM must not be a suitable alternative?
08:20:13 <mux> monads-tf has it, but then I have no idea how is monadLib supposed to be better than mtl, mtl-tf and/or monads-tf
08:20:19 <jmcarthur_work> or AbortM
08:20:25 <mux> jmcarthur_work: mmm, maybe it is, I should look ;-)
08:20:42 <mux> we have too much monad libs right now
08:20:50 <jmcarthur_work> i don't think we do
08:21:03 <jmcarthur_work> as i said earlier, i just think we need to stop exposing them in our libraries
08:21:19 <jmcarthur_work> it should be fine to use two libraries that use two different transformer libraries
08:21:30 <jmcarthur_work> as long as that usage is internal only
08:22:00 <mux> mtl, mmtl, mtl-tf, monads-tf, monadLib, transformers, mtlx
08:22:19 <mux> ghc-mtl !
08:22:28 <mux> I dare say this is too much
08:23:08 <mux> oh, monads-fd too :-P
08:23:27 <jmcarthur_work> i think to choose a winner out of these when none of them are widely used would be a premature decision
08:23:36 <jmcarthur_work> (none of them except mtl, i mean)
08:23:55 <quicksilver> Elly: it's common among MUD servers and, I suspect all kinds of similar programs
08:23:59 <mux> which gives rise to data-accessor-monadLib, data-accessor-monads-fd, data-accessor-monads-tf, data-accessor-mtl, daca-accessor-transformers
08:24:07 <quicksilver> Elly: of course it requries you to be able to serialise *all* your important state
08:24:11 <Elly> you have to serialize and reload your state across the exec though
08:24:14 <mux> jmcarthur_work: maybe it is premature, but I'm just saying at some point a choice needs to be made
08:24:16 <Elly> well, MUD servers have a DB for that anyway
08:24:21 <quicksilver> Elly: but, frankly, that's a very good idea in a reliable program
08:24:28 <quicksilver> Elly: being able to checkpoint is good.
08:24:30 <jmcarthur_work> mux, i still don't think so, if we practice some discipline
08:24:45 <quicksilver> lambdabot, in particular, can do that part by design.
08:24:49 <jmcarthur_work> it's an implementation detail
08:25:00 <mux> jmcarthur_work: put yourself in the shoes of the data-accessor guys, or any other code that needs to be adapted to work with the N libraries together
08:25:14 <mux> it is no longer an implementation detail when you need to write N backends of something
08:25:23 <jmcarthur_work> mux, well, i see that, but cases like that are few
08:25:29 <mux> it is only an implementation detail for the guy just using monads in his code
08:25:45 <jmcarthur_work> and the data accessor guys shouldn't have to support *every* transformer lib
08:25:46 <quicksilver> mux: that's a good question.
08:25:47 <mux> jmcarthur_work: well, that must be taken into account
08:25:57 <sohum> is there a simple way to get a program to expose a ghci-style interface?
08:26:06 <sohum> *a haskell compiled program
08:26:25 <jmcarthur_work> if i want to use transformer library X, which data accessor doesn't support, it's not that hard to add support for it, afaik
08:26:31 <quicksilver> mux: about (CanBeSTUArrayElt a) => a -> a -> [a]
08:26:52 <ksf> sohum, haskelline.
08:26:56 <mux> quicksilver: it seems I'm stumbling against another type-system limitation here :-)
08:27:18 <ksf> ...but that won't enable you to execute haskell, of course.
08:27:20 <mux> quicksilver: uvector provides a nice UA type-class, I'd need something similar for STUArray's
08:27:27 <ksf> ...for that, you'd need libghc.
08:27:36 <hackagebot> york-lava 0.1 - A library for circuit description. (MatthewNaylor)
08:27:38 <hackagebot> dbmigrations 0.1.1 - An implementation of relational database "migrations" (JonathanDaugherty)
08:27:40 <mux> or I can just write it myself and add all those instances by hand
08:27:44 <ksf> at that point, you can equally well just take ghci and hack your stuff into it.
08:28:20 <quicksilver> mux: strange though it seems I think the correct type is (IArray UArray a) => a -> a -> [a]
08:28:24 <sohum> ksf: no equivalent of eval?
08:28:43 <mux> quicksilver: I'm using STUArray
08:29:09 <jmcarthur_work> ?hackage dbmigrations
08:29:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dbmigrations
08:29:30 <mux> quicksilver: it would be easy with UArray
08:29:41 <sohum> ksf: no, wait, of course there is. there's an implementation of eval in lambdabot
08:30:00 <mux> quicksilver: i'd only need FlexibleContexts that is
08:30:56 <ksf> sohum, that's mueval.
08:31:22 <mux> dons: are you around?
08:31:33 <ksf> http://hackage.haskell.org/package/mueval
08:31:46 <mux> I think the UA type-class from uvector should be extracted somewhere and be in its own package so that other stuff can use
08:32:04 <sohum> ksf: shiny
08:32:31 <quicksilver> mux: that is the right constraint
08:32:35 <quicksilver> mux: look at the type of runSTUArray
08:32:47 <quicksilver> mux: well, it's a right constraint, anyway ;)
08:32:52 <quicksilver> @hoogle runSTUArray
08:32:52 <lambdabot> Data.Array.ST runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
08:32:55 <mux> quicksilver: but my problem is that it doesn't work :-)
08:32:59 <ksf> sohum, be warned, though, ghc is a quite heavy-weight dependency to carry around.
08:33:06 <mux> quicksilver: eh?
08:33:10 <quicksilver> look at that type.
08:33:17 <mux> I see it
08:33:23 <lpjhjdh> I'd like my cabal build to execute happy and alex, can I do this easily or do I need to run some commands from Setup.lhs?
08:33:35 <quicksilver> It runs an ST action, and produces a UArray
08:33:43 <mux> quicksilver: it doesn't help me since I need to use runST
08:33:45 <quicksilver> so all you need is the IArray UArray constraint to get your answer
08:34:17 <ksf> lpjhjdh, it _should_ do that automatically, provided every file got the right extension and your exposed-modules or whatever mentions the generated files.
08:34:27 <sohum> ksf: hm..., fair enough
08:34:34 <ksf> ...at least that's how it works with c2hs.
08:35:18 <lpjhjdh> ksf: ah, so just add to extra-source-files with the .y and .x?
08:35:34 <mux> quicksilver: do you see my problem?
08:36:01 <ksf> extra-source-files should only matter for cabal sdist
08:36:16 <lpjhjdh> ksf: great, thanks
08:36:35 <lispy> ?hackage mage
08:36:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mage
08:37:37 * lispy wonders if anyone here has ever tried mage
08:37:42 <lpjhjdh> ksf: oh, so I should always pre-generate the lexer and parser?
08:37:43 <PeakerWork> if your ST computation has multiple results, one of which is an STArray, can you get them all out without re-computing the ST computation?
08:38:24 <lpjhjdh> ksf: this is my first cabal file so I'm pretty ignorant as to how things work
08:38:27 <PeakerWork> how do I get:  ST s (STUArray s i e, something_else) -> (UArray i e, something_else)  ?
08:38:44 <mux> PeakerWork: you can't with runSTUArray
08:39:21 <mux> you need to use runST and freeze
08:39:38 <mux> the type of runSTUArray just does not permit it
08:39:43 <PeakerWork> its just a hypothetical question. There's something that bothers me about runSTUArray, and I'm trying to see what. I think it is this :)
08:42:08 <Twey> How's that bothersome?  If you could modify STArrays outside their ST context, ST would be pointless.
08:42:15 <PeakerWork> maybe it should have been instead: freeze :: STArray s i e -> ST s (UArray i e) ?
08:42:26 <Twey> :t freeze
08:42:27 <lambdabot> Not in scope: `freeze'
08:42:48 <PeakerWork> Twey: no no, what bothers me is that runSTUArray seems to limit you to output only an array from the entire ST computation, and not other outputs
08:42:57 <benmachine> . id pl \x -> x
08:43:00 <benmachine> er
08:43:02 <benmachine> @. id pl \x -> x
08:43:03 <lambdabot>  id
08:43:05 <mux> it's not a problem since you can use runST for more generic computations
08:43:08 <Twey> PeakerWork: But why don't you just use runST and freeze, as mux suggested?
08:43:09 <mux> however my problem is real :-P
08:43:10 <benmachine> @. id src liftM
08:43:12 <Twey> Yes
08:43:21 <benmachine> nothing :(
08:43:27 <Twey> AFAICT, runSTUArray = runST
08:43:29 * benmachine can't get @src to compose with other things
08:43:30 <Twey> Er
08:43:33 <Twey> = runST . freeze
08:43:47 <PeakerWork> @hoogle freeze
08:43:47 <lambdabot> Data.Array.Base freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
08:43:47 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
08:43:47 <lambdabot> Data.Array.Base freezeSTUArray :: Ix i => STUArray s i e -> ST s (UArray i e)
08:43:53 <Twey> @. id (src liftM)
08:43:53 <lambdabot> Plugin `compose' failed with: Unknown command: "(src"
08:43:57 <Twey> Hmph
08:44:11 <mux> Twey: it uses unsafeFreeze internally, but that's an implementation detail
08:44:22 <PeakerWork> Twey: oh! I thought that function didn't exist, so I tried to come up with my own type as a solution.. glad to find its identical to the existing one :)
08:44:23 * mux has to leave anyways. &
08:44:23 <Twey> Aye
08:44:23 <benmachine> @hoogle unsafe
08:44:24 <lambdabot> module Data.ByteString.Unsafe
08:44:24 <lambdabot> module System.IO.Unsafe
08:44:24 <lambdabot> Language.Haskell.TH Unsafe :: Safety
08:45:13 <lispy> Unsafe.Safety?
08:45:23 <lispy> ?quote  unsafePerformSex
08:45:23 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
08:48:43 <benmachine> @pl liftM
08:48:43 <lambdabot> fmap
08:48:46 * benmachine hms
08:48:54 <opqdonut> :D
08:49:32 <Axman6> :liftM
08:49:35 <Axman6> :t liftM
08:49:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:49:55 <Axman6> :o
08:50:54 <lispy> Hmm...So lambdabot could potentially give fmap when liftM is required?
08:51:19 <lispy> ?pl liftM (+)
08:51:20 <lambdabot> fmap (+)
08:51:28 <lispy> That changes the type...
08:51:37 <Twey> :t liftM
08:51:38 <PeakerWork> Twey: runSTUArray uses unsafeFreeze rather than freeze to safely avoid copying
08:51:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:51:39 <Twey> :t fmap
08:51:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:51:42 <byorgey> yes, but in practice, there are no instances of Monad which aren't also instances of Functor.
08:51:42 <opqdonut> well it only makes it more general
08:51:50 <byorgey> and there shouldn't be.
08:51:52 <opqdonut> ah, good point byorgey
08:52:12 <yottis> the fmap/<$>/<*> functions always make more sense than liftM* to me when i try to think about what they actually do
08:52:43 <lispy> :t f <$> a <*> b <*>
08:52:45 <lambdabot> parse error (possibly incorrect indentation)
08:53:04 <opqdonut> lambdabot doesn't have infixapplicatives iirc
08:53:05 <lispy> :t f <$> a <*> b <*> c
08:53:07 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
08:53:07 <lambdabot>     In the second argument of `(<$>)', namely `a'
08:53:07 <lambdabot>     In the first argument of `(<*>)', namely `f <$> a'
08:53:20 <opqdonut> oh
08:53:26 <opqdonut> you probably want \f a b c ->
08:53:28 <opqdonut> or something
08:53:30 <opqdonut> or ?f
08:53:41 <lispy> I was thinking that <$> followed by <*>'s made for liftM*
08:53:46 <lispy> :t f
08:53:48 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
08:53:50 <byorgey> it does
08:53:53 <PeakerWork> yottis: liftAn -- lift a pure function of n args into an applicative, why less sense? :)
08:53:57 <lispy> Some of the single variables are already defined :)
08:54:07 <byorgey> :t \f a b c -> f <$> a <*> b <*> c
08:54:08 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
08:54:14 <byorgey> :t liftA3
08:54:15 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
08:54:18 <opqdonut> lispy: yes i know, that is the problem exactly
08:54:48 <byorgey> how is that a problem?
08:54:51 <yottis> dunno, makes it seem less of a chain somehow
08:55:08 <yottis> i know it's the same thing but my brain just parses it quicker
08:55:21 <opqdonut> byorgey: the problem that caused the error earlier
08:55:31 <opqdonut> or who were you talking to?
08:55:53 <byorgey> opqdonut: the fact that single letter names are defined as of type Expr didn't cause the error
08:56:00 <byorgey> it just means you sometimes get unexpected error messages.
08:56:20 <lispy> byorgey: then what was the error I got?
08:56:29 <opqdonut> well sure, if they weren't defined the error would've been about them not being defined
08:56:31 <byorgey> lispy: which one?
08:56:36 <benmachine> lispy: a is probably of the wrong type
08:56:36 <byorgey> opqdonut: right.
08:56:44 <benmachine> lispy: what were you expecting to see?
08:56:49 <lispy> :t \a -> f <$> a <*> b <*> c
08:56:51 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
08:56:51 <lambdabot>     In the second argument of `(<*>)', namely `b'
08:56:51 <lambdabot>     In the first argument of `(<*>)', namely `f <$> a <*> b'
08:56:57 <lispy> :t \a b c -> f <$> a <*> b <*> c
08:56:59 <lambdabot> forall a a1 a2 b (f :: * -> *). (Show a, Show a1, Show a2, SimpleReflect.FromExpr b, Applicative f) => f a -> f a1 -> f a2 -> f b
08:57:27 <lispy> > (\a b c -> f <$> a <*> b <*> c) (Just 1) (Just 2) (Just 3)
08:57:29 <lambdabot>   Add a type signature
08:57:33 <lispy> > (\a b c -> f <$> a <*> b <*> c) (Just 1) (Just 2) (Just 3) :: Expr
08:57:34 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
08:57:47 <byorgey> try  Maybe Expr
08:57:52 <lispy> > (\a b c -> f <$> a <*> b <*> c) (Just 1) (Just 2) (Just 3) :: Maybe Expr
08:57:54 <lambdabot>   Just (f 1 2 3)
08:57:57 <benmachine> woo
08:58:22 <lispy> I think that Expr is one of the really killer features of lambdabot
08:58:30 <benmachine> > (\a b c -> f <$> a <*> b <*> c) (Just a) (Just b) (Just c)
08:58:32 <lambdabot>   Add a type signature
08:58:37 <benmachine> > (\a b c -> f <$> a <*> b <*> c) (Just a) (Just b) (Just c) :: Maybe Expr
08:58:38 <lambdabot>   Just (f a b c)
08:58:40 <lispy> > foldr f (return ()) [a,b,c,d]
08:58:42 <lambdabot>   No instances for (GHC.Show.Show (m ()),
08:58:42 <lambdabot>                    SimpleReflect.Fr...
08:58:55 <lispy> > foldr f (return ()) [(), (), ()]
08:58:56 <lambdabot>   No instances for (GHC.Show.Show (m ()),
08:58:57 <lambdabot>                    SimpleReflect.Fr...
08:59:05 <byorgey> why the 'return' ?
08:59:17 <lispy> ?src sequence_
08:59:17 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
08:59:29 <byorgey> ah
09:00:01 <lispy> But, sometimes the error from lambdabot confuses m :)
09:00:03 <lispy> er, me
09:00:15 <byorgey> It seems to confuse m, as well.
09:00:18 <lispy> Like, what is it really erroring on
09:00:36 <byorgey> yeah, the error messages are rarely obvious.
09:00:55 <benmachine> :t foldr
09:00:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:00:57 <lispy> cehcking in /msg lambdabot it has an issue with f
09:01:06 <lispy> it can't figure out m either
09:01:41 <lispy> > foldr f (return ()) (Just ()) :: Maybe Expr
09:01:43 <lambdabot>   Couldn't match expected type `[a]'
09:01:51 <lispy> > foldr f (return ()) (Just ()) :: [Expr]
09:01:53 <lambdabot>   Couldn't match expected type `[a]'
09:01:58 <benmachine> so foldr with a return () is :: (a -> m () -> m ()) -> m () -> [a] -> m ()
09:02:07 <copumpkin> lispy: I think you want Data.Foldable's foldr?
09:02:07 <lispy> > foldr f (return ()) (Just ()) :: Maybe ()
09:02:09 <lambdabot>   Couldn't match expected type `[a]'
09:02:20 * benmachine giggles at kenpp's quit error
09:02:27 <copumpkin> > Data.Foldable.foldr f (return ()) (Just ())
09:02:29 <lambdabot>   No instances for (GHC.Show.Show (m ()),
09:02:29 <lambdabot>                    SimpleReflect.Fr...
09:02:35 <copumpkin> > Data.Foldable.foldr f (return ()) (Just ()) :: Maybe ()
09:02:36 <lambdabot>   No instance for (SimpleReflect.FromExpr (Data.Maybe.Maybe ()))
09:02:36 <lambdabot>    arising f...
09:02:41 <copumpkin> boo :)
09:02:57 <lispy> :t f
09:02:59 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:03:03 <benmachine> > foldr f (Just ()) [Just (), Just ()]
09:03:04 <lambdabot>   No instance for (SimpleReflect.FromExpr (Data.Maybe.Maybe ()))
09:03:04 <lambdabot>    arising f...
09:03:11 <lispy> ?instances SimpleReflect.FromExpr
09:03:12 <lambdabot> Couldn't find class `SimpleReflect.FromExpr'. Try @instances-importing
09:03:13 * benmachine shrugs
09:03:37 <lispy> > foldr f (return ()) [Just ()] :: Maybe ()
09:03:39 <lambdabot>   No instance for (SimpleReflect.FromExpr (Data.Maybe.Maybe ()))
09:03:39 <lambdabot>    arising f...
09:04:04 <lispy> ah well
09:08:17 <lispy> anyone looking for project ideas?
09:08:57 <lilac> i have too many project ideas already :)
09:09:18 <lispy> I keep having this idea for a shootout like website but it compares vcs
09:10:01 <benmachine> ls
09:10:02 <pozic> lispy: do you have anything which is practical and will make millions? ;)
09:10:04 <benmachine> wups
09:10:04 <rio> @pl \x -> ((x:l):(map (y:) $ i2 ys x))
09:10:10 <lambdabot> liftM2 (:) (: l) (map (y :) . i2 ys)
09:10:16 <lispy> You'd have a zoo of repositories, and a bunch of common workflows and then it would benchmark the time, RAM, and diskusage of each vcs along with the command set (as a sort of qualitative assesment of the usability)
09:10:41 <lispy> benmachine: in another channel when you do that the bot there responds by giving the directory listing :)
09:10:52 <benmachine> heheh
09:10:56 <lispy> benmachine: but it always slips in some 'embarrasing' files with your nick as the username
09:11:05 <Twey> Haha
09:11:08 <benmachine> that sounds like fun
09:11:09 <Twey> What channel is that?
09:11:18 <lispy> #orlug
09:11:22 <lispy> it's a oregon linux user group
09:11:26 <Twey> Ah â˜º
09:11:41 <lispy> oh it seems the bot is no longer running :(
09:11:48 <lispy> it was named GiR after invader zim
09:13:04 <wabash> Hello. I have a multicore/parallel question. What's the preferred way to have a haskell program deal with parallel stuff? Is there a convenient way to use the actor model like there is in Erlang?
09:14:10 <lilac> wabash: there are lots of ways, and different ways are appropriate for different scenarios.
09:14:30 <wabash> lilac: Ok, i see.
09:14:34 <wabash> Is the actor model included?
09:14:57 <lilac> wabash: i read a book on erlang and it didn't really click. i don't know :)
09:15:28 <wabash> lilac: What are some of theways then that parallel can be implemented?
09:15:31 <lilac> you can certainly have multiple threads with easy message passing between them
09:16:10 <lpsmith> lispy:   benchmarking vcs's would be interesting, especially if you do a good job at it.    (That's not trivial,  for sure.)
09:16:12 <benmachine> is the difference between parallelism and concurrency important here
09:16:24 <quicksilver> the "actor" model is about structuring a program as a series of distinct components each of which only takes actions in response to messages
09:16:25 <lilac> benmachine: good question. :)
09:16:27 <lispy> lpsmith: yeah, I think you could learn a lot from the programming language shootout
09:16:28 <quicksilver> (agreed?)
09:16:42 <lilac> wabash: do you want determinism?
09:16:54 <lpsmith> lispy:   I'd be especially interested in "get" performance,  like darcs get or git pull.
09:16:54 <quicksilver> in Haskell, you'd do that as a bunch of threads each of which was reading from a Chan
09:17:00 <ksf> wabash, have a look at http://www.cs.kent.ac.uk/projects/ofa/chp/
09:17:08 <lpsmith> Darcs's performance actually seems pretty good these days,  other than darcs get :-P
09:17:12 <quicksilver> on which its messages appear (and it has reference to the other threads it wants to send messages to)
09:17:28 <ksf> ...which will serve your synchronous, asynchronous and abstraction needs.
09:17:36 <quicksilver> that would give you somethign quite a lot like Erlang but with types.
09:17:36 <djahandarie> darcs get makes me cringe
09:18:02 <lispy> lpsmith: darcs has done (and is will do a lot more) catching up...but yeah it would be nice to have comparisons.  No more "is slower" but quantified things and realizations that it has caught up is my secret goal :)
09:18:10 <wabash> lilac:  don't know re determinism really.
09:18:15 <lpsmith> (darcs get is slow over a network anyway :-P)
09:18:18 <quicksilver> lispy, lpsmith : the thing about benchmarking (as in speed) vcses is that speed only matters when it matters
09:18:29 <wabash> ksf, lilac. Haskell has real threads? (unlike OCaml?)
09:18:37 <quicksilver> I use bzr because I like its UI and its underlying data model
09:18:40 <djahandarie> lpsmith, yeah, try it over a hidden tor service now
09:18:41 <quicksilver> it happens to be fast enough for me
09:18:52 <quicksilver> possibly it would be too slow for a different person
09:18:53 <lilac> wabash: Haskell has very very lightweight threads, and OS threads
09:18:53 <ksf> haskell has "real" semi-peremptive threads multiplexed on real os processes.
09:18:53 <lpsmith> quicksilver:  I daresay speed matters :-)
09:18:57 <djahandarie> It took forever. T_T
09:19:01 <lpsmith> I look forward to a git pull
09:19:10 <wabash> ksf, ok I see.
09:19:12 <lpsmith> I hate a bzr or darcs analogs.
09:19:21 <wabash> This means that they should be an order of mag better than Ruby, OCaml., etc.
09:19:29 <quicksilver> lpsmith: not to me, in this case. I know git is faster but I still don't switch, because bzr's speed doesn't matter to me.
09:19:47 <quicksilver> lpsmith: "all"?
09:20:02 <djahandarie> Why don't we just lock dons in a room with darcs?
09:20:06 <djahandarie> It'll get faster that way
09:20:09 <ksf> they're nearly as light-weight as coroutines but are properly scheduled.
09:20:11 <lpsmith> Err,  I hate the bzr and darcs analogs.
09:20:21 <ksf> ...you can't preempt them at any point, though.
09:20:22 <lispy> djahandarie: heh
09:20:38 <lilac> wabash: in terms of parallelization / concurrency features, there's par, forkIO/MVar/Chan, STM/TMVar and probably others
09:21:02 <lpsmith> darcs get seems much snappier than bzr when you only have a few patches to get,  even if the repository is big
09:21:07 <lpsmith> but the initial checkout sucks.
09:21:21 <ksf> (and note that haskell happily passes a thunk instead of a value from one thread to another, so you've got to pay a bit attention so that your work actually gets done in different threads)
09:21:27 <lilac> wabash: "par" is about maybe running a pure computation on another thread for easy, deterministic parallelization
09:21:45 <lpsmith> quicksilver:  "all"??
09:21:47 <ksf> there's also data parallel haskell, at least in a few weeks.
09:21:58 <ksf> (when ghc 6.12 comes out)
09:22:18 <lpsmith> ksf:  like Oz's dataflow concurrency,  I'm guessing?
09:22:19 <lilac> forkIO, MVar etc. are nice wrappers around oldschool primitive events-and-mutexes style concurrency
09:22:34 <lpsmith> ksf:  or something a bit different?
09:22:49 <ksf> Oz's dataflow seems to be rather frp-like.
09:23:04 <ksf> (I love that example where they open a window and then update stuff)
09:23:28 <lilac> if you're thinking about using forkIO for serious concurrency, i'd suggest looking at STM first; it's similar in some ways and guaranteed to be deadlock-free
09:23:40 <ksf> you can do similar things without much boilerplate, though.
09:23:57 <ksf> you can deadlock stm.
09:24:03 <ksf> it's easy if you try.
09:24:40 <ksf> ...stm just makes it impossible to get into a total mess with locks.
09:24:59 <lilac> ksf: last time this was hashed out here, as i recall it ended with "you can deadlock STM for some value of 'deadlock' and not for another value"
09:25:27 <ksf> ...yep. you're only left with the interesting deadlocks :)
09:25:54 <lilac> i think it's rosier if you never explicitly retry
09:25:58 <lispy> starvation is a real concern with STM but that's only in certain concurrency patterns
09:25:58 <ksf> I'd seriously recommend chp. there's a couple of centuries theory behind it.
09:27:02 <djahandarie> It also has a nice PDF document. >.>
09:27:09 <lilac> centuries? how far back are you tracing its roots? :)
09:27:33 <wabash> ksf, lilac, thank you.
09:27:41 <djahandarie> BACK TO THE DARK AGES OF ADDITION
09:27:57 <ksf> http://web.comlab.ox.ac.uk/oucl/work/bill.roscoe/publications/68b.pdf   is a good and deep introduction into all the theory.
09:28:11 <ksf> ...including how to prove absence of deadlock in csp.
09:28:16 <lilac> "as long as there has been communication, there has been the theory of CHP" :)
09:28:43 <ksf> wait cent==10.
09:28:45 <lpsmith> Can you deadlock STM in the form of livelock?
09:28:57 * djahandarie just read livelock as livestock
09:29:03 <ksf> 1985 to 2009 is centuries.
09:29:10 <quicksilver> lpsmith: I was trying to parse your sentence
09:29:16 * ksf can't think of a way right now.
09:29:19 <byorgey> ksf: no, cent = 100
09:29:26 <ksf> you'd certainly have to engineer it.
09:29:28 <quicksilver> lpsmith: bzr and darcs have very very diferent models, so as far as I'm concerned they are hardly comparable.
09:29:34 <ksf> a. decuries, then.
09:29:41 <byorgey> usually known as "decades" =)
09:29:52 <lpsmith> quicksilver: true enough,  but you can compare performance :-)
09:30:00 <ksf> psst. my vocabulary is perfect.
09:30:01 <quicksilver> lpsmith: but as I keep saying I don't care about that
09:30:07 <ksf> ...even after the second beer.
09:30:07 <quicksilver> I'd only care if bzr was actually too slow
09:30:12 <quicksilver> it isn't. it's a perfectly useful tool
09:30:29 <quicksilver> the difference between a commnad taking 800ms and 80ms just isn't interesting to me
09:30:41 <lilac> ksf: but after your second beer everyone else's vocab gets worse?
09:30:42 <quicksilver> the difference between 1 hour and 800ms is, of course.
09:31:22 * lilac cares about the difference between 10ps and 100ps
09:31:23 <ksf> th sm t b abbrev all t tim, y.
09:31:33 * byorgey performs binary search on quicksilver to find the magical length of time that is minimally interesting
09:31:40 <rio> @pl \f -> f g h
09:31:40 <lambdabot> flip ($ g) h
09:31:43 <lispy> heh
09:31:47 <rio> :S
09:32:29 <lpsmith> I think the distinction between 80ms and 800ms is interesting;  that's a noticable pause versus one that's imperceptable.
09:32:43 <lpsmith> To a human,  80ms is instantaneous,  800ms is not
09:33:37 <lpsmith> besides,  one round trip over the internet is often 500ms or more.
09:33:43 <c_wraith> In some contexts, 80ms of unexpected lag is unbelievable.
09:33:48 <c_wraith> Just ask a gamer. :)
09:34:30 <ksf> what you see in a fps is heuristic, anyways.
09:34:37 <ksf> there's no lag for the round-trip.
09:34:46 <lpsmith> lol,  never been a very good gamer.   Although I did pioneer wasd and mouselook with the original quake (I'm probably not the only one though)  and when I had that and others didn't,  I definitely had an edge.
09:34:49 <ksf> ...and with an rts, you don't notice a lag of 2 secs.
09:34:50 <c_wraith> (In a fighting game, having it suddenly pause for 80 ms would through your timing *way* off)
09:35:24 <c_wraith> (And in rhythm games, a sudden pause of 10ms is easily noticeable)
09:35:53 <ksf> ...with rythms, every action is pre-computed, anyway.
09:36:12 <c_wraith> Yes, you can't react to that small of a change.  But you certainly feel it.
09:36:19 <ksf> a musician easily plays notes that have a faster succession than the lag from brain to fingers.
09:36:25 <ksf> ...same goes for touch-typing.
09:36:26 <c_wraith> (or at least, you can't react immediately)
09:36:56 <c_wraith> Anyway.  In most contexts, 80ms is nothing.
09:37:06 <ksf> humans percieve up to 2 secs as one moment, depending on the sense we're talking about.
09:43:28 <quicksilver> lpsmith: I'm not suggesting they are equivlent in all contexts
09:43:46 <quicksilver> lpsmith: I suggesting they are very specific context of 'what quicksilver cares about in his vcs'
10:00:22 <dons> simon marlow on the new io library for haskell, http://www.scribd.com/doc/19537350/A-Wander-Through-GHCs-New-IO-Library
10:01:49 <Lemmih> dons: Is there a PDF?
10:02:28 <Lemmih> Ah, there's a pptx.
10:02:48 <Hunner> ick
10:03:15 <dons> there's no .pdf.
10:03:23 <dons> so this time scribd is a win. since you can download the .pdf from it.
10:04:07 <Lemmih> dons: Do you have a URL for that? Flash doesn't work on my box.
10:04:21 <dons> hmm. i think it downloads from flash. let's see.
10:04:31 <dons> looking...
10:04:42 <dons> http://www.scribd.com/document_downloads/19537350?extension=pdf
10:04:45 <lispy> You can get a pdf from the site
10:04:59 <lispy> But you need an account (or openid) then you have to click through 2 pages of ads
10:04:59 <dons> you have  to login though?
10:05:02 <lispy> (I know, because I just did it)
10:05:08 <Lemmih> Sigh.
10:05:17 * dons notes there are no ads once you login
10:05:29 <dons> but it is best presented embedded with a pdf link in a blog
10:05:31 <dons> no ads then
10:05:34 <dons> and a good ui
10:05:44 <dons> however, that's for simon marlow's blog
10:06:15 <dons> this talk is pretty important. it is the end of utf8-string :)
10:06:19 <Adamant> you can make up a login and not have to go through the email check
10:06:20 <lispy> oh no, this pdf has some obscured text
10:06:21 <Adamant> for scribd
10:06:41 <lispy> page 3 for instance
10:06:53 <dons> yeah, .pptx boo
10:06:59 <lispy> dons: the end huh?
10:07:08 <dons> Lemmih: http://www.galois.com/~dons/talks/simon-marlow-new-io-layer.pdf
10:07:17 <lispy> dons: I wonder how we'll handle that transition in darcs.  I guess we'll have to check for 6.12 vs. older
10:07:22 <Lemmih> dons: Wonderful.
10:07:27 <dons> yes, we need to start testing
10:08:05 <lispy> I'm going to forward the galois link to darcs-users, thanks
10:08:25 <dons> oh page 3 is the 'death to utf8-string' one. i think that didn't get rendered in .pdf
10:08:57 <dons> now you can attach a handle to anything that implements the type class
10:09:13 <dons> in-memory bytestring handles...
10:09:52 <dons> all packages that use utf8-string after readFile will break, I think.
10:10:03 <dons> (i.e. they'll double-encode)
10:10:07 <dons> so we need to check that...
10:15:05 <DrSyzygy> dons: Thanks for your blog post about the haskellwiki vim mode!!
10:15:47 <dons> ah
10:15:51 <dons> that was a while ago :)
10:18:15 <lilac> gah, the text disappears behind the boxes and images on both the PDF one and the website ;-(
10:19:11 <dons> boo on .pptx
10:19:23 <RayNbow> what's wrong with .pptx? :p
10:20:24 <Red_Tide> hey I am relatively new to programming and my math sucks is it reasonable to start with haskell?
10:20:46 <opqdonut> not as such, no
10:20:57 <opqdonut> you just have to be willing to learn and hard-working
10:20:59 <opqdonut> or brilliant
10:21:27 <RayNbow> ah...
10:21:37 <Red_Tide> So Haskell is pretty unapproachable for the nascent noob coder?
10:22:13 <RayNbow> dons: the only problem I have with .pptx is when the webserver doesn't set the right MIME type in the HTTP headers :p
10:22:21 <c_wraith> Red Tide:  I wouldn't say that.
10:22:24 <benmachine> Red_Tide: I think it's worth a try; haskell is significantly different from most other programming languages anyway
10:22:35 <sinelaw> Red_Tide, for the unapproachable noob coder
10:22:54 <benmachine> some people have even suggested that knowing other languages first puts you at a disadvantage
10:23:06 <benmachine> although I don't think I'd agree with them
10:23:18 <sinelaw> neither do i, it gives you perspective
10:23:26 <dons> opqdonut: that's not so useful.
10:23:31 <c_wraith> Haskell culture does have a very mathematical bent, though.
10:23:41 <dons> Red_Tide: haskell is used to teach beginning programming at a number of universities
10:23:58 <dons> there are several good textbooks (such as "Craft of Functional Programming" and "Programming in Haskell") for beginners
10:23:58 <c_wraith> If you're not mathematically inclined, the community might be sort of opaque to you at times.
10:24:09 * benmachine agrees with c_wraith
10:24:13 <c_wraith> dons:  say hi to josh from us. :)
10:24:17 * benmachine hugs his maths
10:24:22 <Red_Tide> I am not Mathematically inclined yet but I am willing to change
10:24:45 <benmachine> Red_Tide: well, it can't hurt to try
10:24:56 <orbitz> wooot my RWH copy came today!
10:25:02 <cygnus> dons: do you always get up at 5 AM? :)
10:25:11 <dons> i'm in london. it is 6pm
10:25:13 <dons> or so.
10:25:14 <cygnus> Ohh.
10:25:21 <benmachine> hi5
10:25:21 <tibbe> dons: how's the visa issue?
10:25:23 <c_wraith> Oh.  Then nevermind. :)
10:25:35 <dons> tibbe: good! now just chillin' in the city for a few days
10:25:45 <tibbe> dons:nice
10:26:07 <dons> tibbe: done any benchmarks on hyena?
10:26:18 <tibbe> dons: not for a while
10:26:23 <tibbe> dons: but I intend to
10:26:23 <dons> i was playing with it on the train. i'm wondering if it is a good base for a teachable highly concurrent server
10:26:36 <cygnus> dons: I was just confused by the timestamp on the build error e-mail you sent me. :)
10:26:39 <dons> something that would compete with mochiweb or similar in erlang
10:26:42 <tibbe> dons: the current hyena looks very different from the last release
10:26:44 <dons> cygnus: ahaha
10:26:50 <benmachine> hmm, I think default implementations for class methods should be extended somehow
10:26:52 <dons> oh, in github? that's what i'm using i think
10:26:57 <tibbe> dons: 1300 req/s last time I measure without reall optimizing
10:27:03 <dons> ok.
10:27:05 <tibbe> dons: on my laptop ;)
10:27:12 <tibbe> dons: so you cant peek ;)
10:27:36 <lispy> hi cygnus
10:27:40 <dons> for super simple stuff on my laptop, little 70 line servers can get up to 10k pretty easily. i think we got 16k/ sec for a very low level one
10:27:41 <benmachine> firstly, that subclasses should be able to have default implementations of superclass methods
10:27:42 <cygnus> lispy: hey
10:27:42 <sinelaw> I'm reading SPJ's The Implementation of Functional Programming Languages. it's from 1987. Is there any major breakthrough since then that I should know about?
10:28:00 <dons> just handing back helloworld, statically
10:28:01 <Red_Tide> Ok I gather some of the more complex stuff in Haskell requires an understanding of set theory and category theory but realistically to do more basic stuff like play around in Xmonad what level of Mathematical knowledge would be required?
10:28:10 <dons> Red_Tide: no, that's not really true
10:28:16 <benmachine> but also, it is possible that one method can be implemented by either of two other methods
10:28:22 <dons> anymore than you need to understand separation logic to learn C.
10:28:33 <benmachine> currently you'd have to 'pick' which of the two is 'easier'
10:28:34 <dons> just because we have a theory, doesn't mean the implementation /is/ the theory
10:28:43 <orbitz> Red_Tide: stuff in haskell are named after fancy mathematical stuff but you don't really need to know that to use it IME
10:28:56 <benmachine> I think it helps sometimes though
10:29:00 <dons> and our theory is relatively simple compared to say, the theory of C or Python, for which there is no real model.
10:29:20 <benmachine> you could just learn lots of maths so that it would become a moot question :P
10:29:21 <tibbe> dons: so 10k is usually a good goal for a high performance web server on real stuff, benchmark with Apache bench or something like that
10:29:30 <c_wraith> Just don't get discouraged when people in here start talking about coalgebras and stuff.  It's not necessary to understand it all to use the language. :)
10:29:35 <dons> yeah. will do. probably i'll just work on hyena.
10:29:45 <dons> try to get that into a state we can all be proud of.
10:29:53 <orbitz> dons: you're an animal
10:30:02 <tibbe> dons: I'll try to get the latest version on github this week
10:30:06 <tibbe> dons: just need some tests
10:30:09 <Nafai> What's hyena?
10:30:16 <lispy> dons: and then use hyena + bonjour inside of darcs for ad-hoc patch sharing on LANs?
10:30:32 <dons> tibbe: that'd be great, you need help on such a big undertaking
10:30:40 <dons> lispy: huh, interesting idea.
10:30:41 <tibbe> dons: true
10:30:48 <tibbe> Nafai: my web app server
10:30:58 <lispy> dons: hg does this and when I learned about it, I've been searching for an implementor
10:31:04 <dons> :)
10:31:04 <c_wraith> tibbe:  is it named in parallel with Mongrel?
10:31:11 <lispy> dons: think code sprints and hackathons made dead simple
10:31:17 <dons> yeah, like mongrel but more wild and more threads
10:31:18 <tibbe> c_wraith: yes, a hyena is a meaner dog than a mongrel ;)
10:31:32 <Nafai> tibbe: Oh, nice. :)
10:31:36 <lispy> hyenas are not dogs, IIRC
10:31:43 <sinelaw> How different is Miranda from Haskell?
10:31:44 <dons> we need to get it into a good placce and put up some benchmarks
10:31:47 <tibbe> c_wraith: mongrel was part of the inspiration (i.e. something simple that works)
10:31:53 <dons> oh, wow. sinelaw about 20 years different
10:31:55 <tibbe> dons: yes
10:31:56 <dons> that's a really big question
10:32:04 <dons> sinelaw: miranda stopped development in about 1992.
10:32:06 <Nafai> tibbe: URL?
10:32:15 <orbitz> what about Clean and Haskell?
10:32:18 <dons> haskell since then has had sooo much happen.
10:32:27 <dons> Clean is like a haskell circa 1995 with uniqueness types
10:32:37 <tibbe> @hackage hyena
10:32:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hyena
10:32:43 <tibbe> Nafai: ^
10:32:54 <tibbe> Nafai: the dev version is quite different though, in parts
10:33:00 <Adamant> Clean is still pretty darn fast though, right?
10:33:04 <dons> there's no serious competitor to haskell in the purely functional space.
10:33:10 <EnglishGent> how do uniqueness types compare to monads in practice? (I know their mathematically equivalent)
10:33:18 <dons> unknown. no one uses Clean.
10:33:47 <orbitz> haha
10:33:54 <dons> EnglishGent: they're not equivalent. monads are a richer abstraction. uniqueness is a separate issue
10:34:12 <Adamant> dons: well, I thought I remembered you using Clean's speed as a benchmark for where ghc should go
10:34:20 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=clean&box=1
10:34:21 <EnglishGent> oh - that's interesting .. I thought they were
10:34:26 <dons> haskell is faster than clean on more benchmarks now
10:34:31 <dons> Adamant: yes, a few years ago
10:34:32 <Nafai> tibbe: Thanks
10:34:44 <dons> it is slower on 2 benchmarks, faster on 6.
10:34:49 <Nafai> Is Clean still actively developed?
10:34:54 <Adamant> dons: ah, so it's pulling up alongside
10:35:11 <dons> i think it would be crazy to use clean, given the haskell toolset, libraries and community. only for research purposes.
10:35:14 <Red_Tide> Ok gonna have a look at some of those begginner textbooks thanks for your assistance gentleman
10:35:36 <dons> clean has a smaller memory footprint. there's your uniqueness types
10:36:22 <orbitz> the smaller footprint is direct resutl of uniqueness types?
10:36:43 <dons> sure helps you avoid allocating new buffers :)
10:36:57 <dons> and the shootout programs are written with lots of uniqueness tags
10:37:30 <tibbe> dons: I guess we're seeing similar benefits from using fusion?
10:38:16 <dons> essentially the same, yep. but uniqueness is more comprehensive -- they can use it in more places
10:38:34 <dons> fusion gives you some uniqueness guarantees, which the libraries exploit
10:38:56 * dons notes a bunch of intel guys retweeting the multicore talk...
10:39:18 <orbitz> awesome
10:39:27 <orbitz> i wish i had audio fro taht atlk, the slides arent' enough
10:39:54 <lilac> would it be problematic to add uniqueness typing to haskell?
10:40:05 <lilac> i vaguely recall linear implicit params going in that direction
10:40:06 * tibbe reviews his hyena repo, checking for things to fix
10:43:18 <dons> so everyone should be out there writing parallel haskell programs this week, and cleaning up the competition.
10:43:21 <dons> keep the ball rolling
10:43:34 <Polarina> Parallel haskell?
10:43:56 <EnglishGent> paskell?! (sorry)
10:44:08 <EnglishGent> :)
10:44:13 <orbitz> AHHHH
10:44:36 <dons> Polarina: http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/  we've just had a half day tutorial on this stuff, and its getting lots of coverage on the interwebs
10:44:37 <benmachine> haskallel
10:45:26 <paper_cc> Can anyone explain why this program performs so bad? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9192#a9192 -- I don't understand why iterateRoots gets called about 10^6 times instead of 320
10:45:30 <Vulpyne> How smart is GHC regarding bytestring literals? I have quite a few ByteString.pack "literal"s in my code.
10:45:41 <dons> Vulpyne: you can look at the rewrite rules.
10:45:47 <dons> they should fire a pack/packAddress rule
10:45:53 <dons> that builds the bytestring statically
10:46:02 <dons> ghc -O2 -ddump-simpl-stats
10:46:13 <Vulpyne> Ah, good. So B.pack "blah" in two different locations of the code would be collapsed into one static thing?
10:46:56 <dons> oh, quite possibly not.
10:47:01 <dons> but  the pack will get called at compile time
10:47:42 <Vulpyne> Just once?
10:48:04 <dons> check the core. i doubt it will be shared
10:48:21 <Vulpyne> So what I should do is make toplevel functions with the B.pack "whatever"?
10:48:28 <dons> btw, i also posted my slides from a few months ago on stream fusion, http://www.reddit.com/r/programming/comments/9iigc/stream_fusion_for_haskell_arrays/
10:48:38 <dons> these haven't ever been public, but describe the uvector library
10:48:53 <dons> Vulpyne: yeah, float out hte strings somehow , if you care about them being shared
10:49:23 <sinelaw> ok, i'm just readnig SPJ's book on implementing fp. languages (it uses a subset of miranda as an example)
10:49:41 <Vulpyne> It may not matter. As they say "premature optimization is the root of all evil" but I feel icky to know it's going to have to pack the string multiple times.
10:49:41 <sinelaw> and want to know what the major differences are compared to Haskell
10:49:52 <Vulpyne> Thanks for the informations.
10:49:54 * benmachine thinks the arguments to openFile should be swapped
10:50:39 <nlogax> hmm, shouldn't like half of the programs in the thread-ring benchmark on shootout, be sorted under "interesting alternative programs"?
10:50:43 <nlogax> including ghc?
10:50:52 <lpjhjdh> when I'm building with cabal I get "Type constructor `Exception' used as a class", how do I hide the old exception stuff?
10:51:21 <dcoutts> lpjhjdh: sounds like you want to use base 4, but you're currently using base 3
10:51:37 <dons> dcoutts: can you send me the slides from the implementors talk?
10:51:39 <dons> hackage/cabal et al
10:51:54 <EnglishGent> why benmachine? (arguments)
10:51:55 <lpjhjdh> dcoutts: thanks, looks like I missed > 4 in my base spec :p
10:51:58 * EnglishGent curious :)
10:52:02 <dcoutts> dons: ah yes, I should post those
10:52:39 <dcoutts> dons: for some reason I have a bad reaction to scribd, so I'll have to make sure they're posted somewhere usable too :-)
10:52:51 <benmachine> EnglishGent: because you can then make openFileRead = openFile ReadMode
10:53:03 <dons> i like them embedded like this, with a .pdf link, http://donsbot.wordpress.com/2009/09/07/stream-fusion-for-haskell-arrays/
10:53:09 <benmachine> I can't imagine a situation where you'd want to partialy apply openFile with a filename
10:53:26 <dons> i.e. not actually linked to scribd. but embedded in a regular html page.
10:53:54 <dcoutts> dons: looks like a link to me
10:53:55 <Saizan> lpjhjdh: >= 4 && < 5, or just == 4.*
10:54:14 <dcoutts> dons: ah yes, I remember why I don't use scribd, it needs some later version of flash or something
10:54:40 <lpjhjdh> Saizan: thanks, don't have < 5, I'll add it
10:54:43 <dcoutts> dons: I'll posts pdfs on my blog, feel free to put them on scribd too if you're making a collection there
10:54:48 <dons> ok. great.
10:54:53 <Saizan> the new IO slides got a bit mangled in the conversion to .pdf :\
10:55:10 <dons> yeah, i'm not sure how things like .pptx should be shared
10:55:24 <nlogax> http://github.com/facebook/lex-pass/tree/master i guess that is what the facebook people were talking about at CUFP?
10:55:36 <dons> oh
10:55:39 <dcoutts> dons: did JaffaCake do the conversion using MS Office? perhaps OO.o would do a better job at the pdf conversion
10:55:50 <dons> nlogax: it must be!
10:55:58 <dons> dcoutts: no, it doesn't render them properly
10:56:03 <lispy> I suspect the problem is that each slide got its own page instead of each transition
10:56:15 <lispy> This should be a configurable option during export
10:56:17 <nlogax> i played around with it today, could probably get some use out of it :)
10:56:26 <nlogax> though i was secretly wishing for something more..
10:56:30 <dons> nlogax: awesome for finding that
10:56:33 <nlogax> like writing haskell that compiles down to php
10:56:35 <nlogax> :P
10:56:41 <dons> seems like Language.PHP would be a killer app in that area
10:57:43 <lpsmith> Who here uses leksah?
11:00:08 <lispy> Not I; but I've had some luck with Scion + Emacs
11:01:22 <MarcWeber> nlogax: .. Bad idea. That would be terrible slow wouldn't it? Then you can write a brainfuck apaceh extension and use that.
11:05:35 <ziman> @index showHex
11:05:35 <lambdabot> Numeric
11:06:46 <kolmodin> tibbe: assume binary read would have this type: data Read a = Done a | Cont (ByteString -> Read a) | Error String. then we could no longer return values lazily
11:06:59 <kolmodin> tibbe: or did you think of another type?
11:08:04 <tibbe> kolmodin: that seems reasonable
11:08:15 <kolmodin> tibbe: so we could no longer parse in constant space
11:08:17 * tibbe wishes we had strictness annotations in types
11:08:26 <tibbe> kolmodin: how come?
11:08:47 <kolmodin> in the case of Cont it doesn't return any results, it wants more data
11:08:52 <kolmodin> it could be a lot of data
11:09:01 <kolmodin> before it returns Done
11:09:17 <tibbe> kolmodin: but the same goes for the current implementation right?
11:09:34 <c_wraith> it also doesn't need to keep the data all in memory.  Depends on what type of data it's parsing.
11:09:34 <tibbe> kolmodin: i.e. what happens if you stick an undefined somewhere in the end of your lazy bytestring?
11:10:05 <tibbe> kolmodin: touching "a" would surely force the whole input?
11:10:33 <tibbe> kolmodin: in any case you absolutely don't want to hold on to the input if it's e.g. backed by a file as you'll leak file descriptors
11:12:01 <kolmodin> tibbe: the type of 'runGet' is     Get a -> ByteString -> a
11:12:20 <tibbe> kolmodin: is bind for the monad lazy?
11:12:33 <tibbe> kolmodin: I really need to read the code again, was a while since
11:12:42 <kolmodin> tibbe: as far as I remember, yes
11:12:56 <tibbe> kolmodin: you should be able to test using undefined
11:13:14 <kolmodin> tibbe: we should separate the errors from each other. sticking a undefined into the end of your lazy bytestring is another issue
11:13:34 * tibbe is tired, feeling a bit slow
11:13:39 <tibbe> kolmodin: which errors? :)
11:13:54 <kolmodin> errors/issues :)
11:14:23 <tibbe> kolmodin: ok
11:14:51 <tibbe> kolmodin: so if you parse lazily you risk leaking resources in case the lazy bytestring is backed by a file
11:15:14 <tibbe> kolmodin: whether the parsing itself is lazy atm I don't know
11:15:25 <kolmodin> tibbe: yes
11:16:06 <kolmodin> tibbe: I recall it's lazy
11:16:10 <kolmodin> I think...
11:16:11 <tibbe> kolmodin: ok
11:16:24 <tibbe> kolmodin: I would have to stare at it for a while to decide :)
11:16:39 <kolmodin> m >>= k   = Get (\s -> let (a, s') = unGet m s in unGet (k a) s')
11:16:41 <tibbe> kolmodin: try decoding a list an access the head
11:17:24 <nlogax> http://shootout.alioth.debian.org/u32q/benchmark.php?test=regexdna&lang=all&sort=elapsed seeing JS implementations at #2 and #3 was not what i expected :o
11:18:17 <kolmodin> tibbe: and?
11:18:26 <tibbe> kolmodin: if it works it's lazy ;)
11:18:37 <Heffalump> why can't we lazily manage FDs too?
11:18:52 <tibbe> Heffalump: you mean let the GC manage them?
11:19:02 <kolmodin> tibbe: why wouldn't accessing decoded lists work otherwise? I don't follow
11:19:26 <Heffalump> tibbe: that, and let them be temporarily recycled (but I guess that could only work when they are on files)
11:19:30 <tibbe> kolmodin: so if Get is lazy in the input then you should be able to get a partial result without forcing the input
11:20:06 <tibbe> Heffalump: so you would have to make the GC sensitive to file descriptor exhaustion so that it runs at that point
11:20:19 <kolmodin> tibbe: surely I would have to do something with the input first
11:20:19 <Heffalump> yep
11:20:28 <kolmodin> I'll drop something from the end, or something
11:20:40 * tibbe suggested 'head' :)
11:21:16 <kolmodin> you mean init?
11:21:31 <tibbe> kolmodin: I mean head (decode myStr :: [a])
11:22:03 <tibbe> kolmodin: where myStr has enough data to decode the first element but will error out if more is requested
11:22:58 <tibbe> kolmodin: but I think you're right in that it's lazy
11:23:17 <tibbe> kolmodin: sorry, I'm too tired to actually check myself
11:25:03 <dons> so facebook really has written Language.PHP
11:25:21 <dons> dancor: you've submitted patches. is this likely to end up as language-php on hackage?
11:25:36 <c_wraith> wait.  they're generating PHP from haskell?
11:25:37 * cygnus twitches
11:25:43 <Adamant> sweet!
11:25:43 <dons> manipulating.
11:25:52 <Heffalump> c_wraith: we generate Excel from Haskell at work..
11:25:57 <Adamant> this might make PHP more tolerable
11:26:11 * cygnus seriously doubts it.
11:26:40 <dons> its more like php-sed than say, Heffalump's Paradise
11:26:52 <Adamant> ah
11:27:05 <Heffalump> the clear evidence of Paradise is that you can't fix broken semantics just by generating from Haskell :-)
11:27:07 <dons> but you do write AST transformers, unlike sed.
11:27:14 <dons> Heffalump: hehehe
11:27:30 <kolmodin> tibbe: Prelude.head (decode $ Data.ByteString.Lazy.pack [0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0]) :: Int
11:27:31 <dons> excel is not a standardised vm :)
11:27:57 <kolmodin> tibbe: a list containing one int64, but states it has two
11:28:04 <nlogax> i would love to be able to write php at a safe distance
11:28:08 <tibbe> kolmodin: so that works?
11:28:16 <nlogax> but i think it might be easier to just change jobs
11:28:17 <dons> we have a great javascript analysis library. this seems like a start for php
11:28:28 <dons> for C we have a full parser and codegen. for python and shell a parser
11:29:24 <kolmodin> tibbe: no, it fails
11:29:29 <dons> nlogax: so how did you find this lib? you went looking?
11:29:37 <tibbe> kolmodin: so it's strict?
11:29:59 <nlogax> dons: yeah, was just browsing http://github.com/facebook/
11:30:13 <Adamant> dons: did they ever integrate harpy into the standard libs? the one that does asm?
11:30:23 <dons> people use llvm more these days
11:30:26 <kolmodin> tibbe: at least within the same bytestring chuck, yes
11:30:28 <dons> you can jit llvm and jit to harpy.
11:30:34 <dons> nlogax: good thinking
11:30:44 <tibbe> kolmodin: hmm
11:30:58 * dons wonders if this means we can add facebook to the industry page, with a link to their code and cufp talk
11:30:59 <triyo> I'm new to haskell and I downloaded the haskell platform for mac and I am running snow leopard. I tried installing the compiler and the Mac installer doesn't show me the install button. (Install button stays grayed out.) Am I missing something?
11:31:00 <tibbe> kolmodin: could you make that two chunks somehow?
11:31:01 <dons> Heffalump: thoughts?
11:31:14 <dons> triyo: hmm.
11:31:22 <dons> triyo: it doesn't work on snow leopard, iirc.
11:31:25 <kolmodin> tibbe: I have code for this in a few test functions to binary that I never comitted
11:31:29 <Adamant> lots of fun getting Haskell going on Snow Leopard right now
11:31:30 <dons> and that is indicated by a blank install button
11:31:41 <Heffalump> dons: don't see why not, might be polite to check with them
11:31:45 <tibbe> kolmodin: some strictness tests in the library would be good
11:32:06 <kolmodin> tibbe: that's what I wrote. to make sure it doesn't force lazy chunks
11:32:15 <tibbe> kolmodin: ok
11:32:16 <dons> Heffalump: good idea
11:32:17 <kolmodin> tibbe: since we've had that bug twice
11:32:21 <tibbe> kolmodin: so it's chunk strict then?
11:32:26 <triyo> dons: hmm so I am out of luck for the time being?
11:32:43 <tibbe> kolmodin: or perhaps the list instance is strict?
11:32:43 <kolmodin> tibbe: could be... I can't remember.. :/
11:33:13 <kolmodin> right, they could have made it less lazy to get around stack overflows that I've been hearing about
11:34:18 <tibbe> dons: so I'm checking what needs doing before the rewrite of hyena is done, not too much, cleaning up the bytestring parser is the biggest thing
11:34:32 <tibbe> dons: basically optimizing a continuation based bytestring parser
11:34:37 <tibbe> dons: and writing tests
11:34:37 <kolmodin> +1 for naming a strictness test library "chasingbottoms"
11:34:45 <tibbe> kolmodin: yeah!
11:35:02 <kolmodin> :D
11:35:05 <dons> triyo: for the platform, yes.
11:35:08 <tibbe> dons: I guess I could push to github without the optimizations
11:35:12 <dons> you'll need to install ghc with the snow leopard patches
11:35:33 <dons> tibbe: if i was tibbe, i'd push, so that you can get dons hacking on the code
11:35:48 <tibbe> dons: gah!
11:35:50 <dons> since i'm keen, but i have a large workload, and a short holiday :)
11:35:56 <tibbe> dons: fine
11:36:02 <tibbe> dons: I could push to a separate repo
11:36:07 <tibbe> dons: it's a bit of a mess though!
11:36:09 <dons> yeah, that'd work too
11:36:13 <dons> just something   that runs
11:36:22 <kolmodin> :)
11:36:29 <dolio> dons: You should release an updated uvector. :)
11:36:42 <clanehin> Used -xc to get a stack trace, and it's in one of those _a6pP functions.  Troubleness.
11:37:08 <dolio> Oh, wait, 1.0.4 has memcpy.
11:37:39 <dolio> I may have to release a new uvector-algorithms...
11:37:45 <tibbe> dons: ok, let me make sure that it runs and upload somewhere
11:37:52 <tibbe> dons: and a few mins to document the code
11:38:19 <dons> dolio: quite so. bos' is using it now
11:38:26 <dons> dolio: i think most of the patches are in now.
11:38:32 <infrared> anyone here successfully install haskell under freebsd? for `make install` i'm getting: Unkown modifer '$', with a couple lines referencing the Makefile
11:38:38 <dons> dolio: if you want to check for anything that is missing, i'll apply it.
11:38:42 <dons> infrared: oh, you need gmake
11:38:45 <dons> export MAKE=gmake
11:39:01 <infrared> thanks dons :)
11:39:25 * dons thinks this was a good ICFP/CUFP/HS/HIM/DEFUN for the Haskell community
11:39:30 <dons> lots of good resources
11:39:56 <dolio> dons: For some reason I was under the impression that it was going to be 0.1.1, so I've been sitting on my updates.
11:40:05 * kolmodin much enjoyed last week
11:40:19 <dons> dolio: hmm. i /think/ everything in the darcs repo on code.haskell.org is on hackage now
11:41:18 <dolio> Oh, I'm even more wrong. Apparently my uvector-algorithms.cabal says I was expecting uvector-0.2. :)
11:41:41 <dons> oops
11:41:56 <dons> dolio: i will apply your patches. send them if you have them.
11:42:14 * dons should take a week off every 6 months just to apply darcs patches.
11:42:30 <dolio> dons: uvector-algorithms compiles fine, so you must already have all the patches I was depending on.
11:42:52 <dons> sweeet!
11:42:52 <copumpkin> dons: I'll find me a 6.10.1 to test my latest patches on and then send them to you
11:43:03 <dons> dolio: makes sense: bos is using it for the new uber-benchmark package
11:43:21 <dons> copumpkin: yeah, yours were much bigger. i'd love to see them
11:43:42 <copumpkin> yeah, I'm pretty sure they worked but I feel uncomfortable sending something untested and now the testsuite is broken
11:43:56 <copumpkin> maybe I'll just fix up the test suite as a workaround for the current GHC bug
11:44:10 <dons> that'd be good
11:45:05 <dons> anyone see something interesting about   this link: http://www.planeterlang.org/en/planet/article/Impressed_with_Haskells_concurrency/
11:45:19 <dons> yay orbitz :)
11:47:52 <dino-> hm, kind words about Haskell's concurrency abilities on what's presumably an erlang-biased site
11:48:33 <dons> now to get hyena out and benchmarked. serving up stuff fast is a good argument
11:48:47 * tibbe is hackety hacking on it right now
11:49:09 <tibbe> making some more tea to boost productivity
11:49:34 * Heffalump is looking forward to criterion
11:50:15 * tibbe is too
11:50:54 <Saizan_> criterion?
11:51:09 <copumpkin> @seen edwardk
11:51:09 * kolmodin too
11:51:09 <lambdabot> Unknown command, try @list
11:51:14 <copumpkin> preflex: seen edwardk
11:51:15 <preflex>  edwardk was last seen on #haskell 5 days, 3 hours, 41 minutes and 7 seconds ago, saying: then importing bluetileutils will bring in bluetile which will bring in the functionality that bluetileutils used to provide
11:51:27 <dons> bos' uber-benchmarking suite is called criterion or criterium
11:51:42 <dons> criterium would make sense :)
11:52:00 <burp> hm, shiftL value 1 does the same on little and big endian
11:52:09 <burp> -- double the value
11:52:17 <EnglishGent> hi :)
11:52:17 <burp> is this the way it should behave?
11:52:28 <mauke> burp: yes
11:52:36 <copumpkin> burp: don't confuse byte order with bit order
11:52:59 <burp> copumpkin: oh yes :|
11:55:07 <tibbe> dons: I thought it was criteria
11:56:37 <dons> no one knows!
12:01:26 <dons> it'd be a good idea to send the facebook guys some nice patches. a welcoming community might be a clever strategic play :)
12:01:50 <tibbe> dons: indeed
12:02:17 * tibbe wishes there were 373 hours in a day
12:03:09 * dons imagines tools for static analysis and manipulating of php would be a killer app
12:05:08 <tibbe> dons: if the tool could find some bugs for them I imagine they be very happy
12:09:41 <hackagebot> uvector-algorithms 0.2 - Efficient algorithms for uvector unboxed arrays (DanDoel)
12:11:11 <etpace_> > let binary = sum . snd . mapAccumR (\acc x -> (acc*2, read [x] * acc)) 1 in binary "1101100"
12:11:13 <lambdabot>   108
12:11:23 <etpace_> is there a better way to go from binary string -> dec?
12:11:35 <tibbe> dons: ugh, UAE is a really terrible class name :/
12:12:05 <Saizan_> > foldl' (\acc x -> 2*acc + x) 0 . map digitToInt $ "1101100"
12:12:07 <lambdabot>   108
12:12:10 <Baughn> etpace_: There's a function specifically for parsing base-N numbers, but for the life of me I can't remember what it's called..
12:12:14 <Baughn> Oh. digitToInt.
12:12:23 <Baughn> ..no, that's not quite it either
12:12:35 <benmachine> does anyone know where I can find  examples of Data.Accessor in use
12:12:39 <copumpkin> tibbe: lol
12:12:43 <Saizan_> there's readSomething in Numeric
12:13:14 <tibbe> copumpkin: although it accurately reflects the sound I make when reading it in code ;)
12:14:05 <Cale> dons: It seems that when you(?) converted Simon Marlow's talk on the new IO system into PDF and put it on Scribd, lots of bits of text were cut off...
12:17:35 <ray> i also noticed this
12:18:44 <Saizan_> yeah, but you can open the .pptx in openoffice and move the boxes to see all the text
12:19:18 <Phyx-> hm
12:19:28 <ray> that doesn't seem like a good excuse :)
12:19:35 <Baughn> Interestingly, I see ~20% performance improvement on multithreaded haskell programs using the brain-fuck scheduleer instead of linux' default one
12:19:51 <Phyx-> does the native pdf save functionaly of ppt 2007 also do that Cale?
12:19:54 <Baughn> I'll do more scientific benchmarks once it works on my laptop, but you may want to give it a look
12:19:56 <ray> well, what do you expect from *linux*
12:20:04 <ray> try comparing it to sched_ule or something
12:20:38 <Cale> Phyx-: I'm not on windows. I'm reading the presentation in OpenOffice... it looks screwed up (differently), but I can access any bits of text which are cut off anyway.
12:21:05 <Phyx-> Cale: send me a link, i'll convert it
12:21:17 <dons> Cale: actually, all tools seems to do this. openoffice, scribd.
12:21:26 <dons> the original .pptx is there, if someone can extract it properly
12:21:38 <Phyx-> dons: i can give it a try
12:22:53 <Cale> The new IO library looks good :)
12:23:22 <tibbe> Cale: yes, could use a little bit of further refactoring though
12:23:56 <tibbe> Cale: I want to get ByteStrings in at some place as Ptr Word8 is a pita to work with
12:25:16 <tibbe> only in Haskell can you stare at the same line of code for an hour
12:25:16 <Cale> tibbe: Yeah, that would probably be a good idea.
12:25:22 <Cale> tibbe: ehehe
12:25:39 <tibbe> Cale: but since we don't want a base -> bytestring dependency I'm not sure where it should go in
12:26:28 <Cale> Well, for a start, is there an easy way at least to convert between (Ptr Word8,Int) and ByteString?
12:27:57 <copumpkin> @hoogle fromForeignPtr
12:27:57 <lambdabot> Data.ByteString.Internal fromForeignPtr :: ForeignPtr Word8 -> Int -> Int -> ByteString
12:29:45 <Cale> I think that ByteString is kind of essential at the moment for binary I/O. It's a little surprising that it's not part of the base library, though I can also understand the desire to keep it separate.
12:31:21 <tibbe> Cale: yes, I think ByteString (plus a Unicode string type) is needed to write an I/O library in the first place
12:31:36 <tibbe> Cale: otherwise you need to write everything in terms of Ptr Word8/Char
12:31:54 <tibbe> Cale: and Char doesn't really have a defined encoding
12:32:16 <tibbe> Cale: there was talk of having a ByteArray (wrapping ByteArray#) type at the lower levels though
12:32:22 <tibbe> Cale: and a MutableByteArray
12:35:35 <huntse> Baughn: mingo would certainly be interested if you have a simple benchmark you can show bfs being faster than cfs (the default scheduler)
12:36:54 <Baughn> huntse: Yeah. First, I need to get the various problems fixed, but I'll make sure to make one.
12:37:34 <huntse> Baughn: I'm guessing you know the history, if not, look at lwn.net.
12:38:12 <huntse> ...and have actual numbers to hand or be wearing your flame-proof pants.
12:39:05 <Baughn> huntse: I've been following it on gmane.org. The consensus I'm gathering seems to be "neither scheduler works very well", but bfs at least has the excuse of being new.
12:40:36 <huntse> Baughn: So what happened last time round was the Con Kollivas scheduler was on the verge of being merged but there was a lot of handwaving, which annoyed people, and there was a general refusal to accept that there might even be the slightest problem to the new one.
12:41:07 <huntse> ...so when the problems arose, there was a massive flamewar and Con threw his toys and went off in a huff.
12:41:14 <Baughn> Whee
12:42:25 <huntse> The annoying thing was there is actual room for improvement but it is a hard problem.  So mingo's scheduler won because he is serious about actually improving problems he sees.  Hence my statement. If you have a fairly simple benchmark with numbers which shows the regression I expect he would love to see it.
12:42:56 * huntse gotta go now.
12:42:58 <lilac> what library would people recommend for parsing a binary file format (no backtracking required)? i'm thinking parsec, but it seems slightly ... overkill
12:43:53 <jmcarthur_work> if it's very simple maybe just the binary package?
12:44:08 <jmcarthur_work> parsec probably wouldn't be bad
12:44:50 <copumpkin> parsec is dead
12:44:52 <copumpkin> long live parsimony!
12:44:55 <copumpkin> (apparently)
12:45:22 <lpsmith> is parsimony faster than parsec?
12:45:48 <Vanadium> @faq Can Haskell run parsimony faster than parsec?
12:45:48 <lambdabot> The answer is: Yes! Haskell can do that.
12:46:11 <Lemmih> Why doesn't parsimony follow the established module hierarchy?
12:46:35 <lilac> what does parsimony provide that's not in parsec3?
12:46:46 <copumpkin> lilac: I was wondering too, doesn't seem to be much
12:46:52 <copumpkin> it's the same author too
12:47:31 <gwern> I really don't understand social networking sites sometimes: http://news.ycombinator.com/threads?id=gwern why is my latest comment almost a majority of my lifetime score, when I wouldn't rate it as much better than several others?
12:48:17 <FunctorSalad_> gwern: I think one big factor is simply exposure
12:48:37 <gwern> but I'm sure that many of my comments were on more popular posts
12:49:13 <Geralt> Hi, I'm just beginning with haskell and I'm wondering if it's possible to put a range in a pattern like testFunc :: (Integral a) => a -> String   testFunc (0..5) = "0 to 5"    testFunc x = "Not in 0 to 5"?
12:49:18 <FunctorSalad_> it's also how popular the post you're replying to is (at least on reddit, where the whole tree is hidden for a negative posting)
12:49:57 <burp> @hoogle [Word8] -> ByteString
12:49:57 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
12:49:58 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
12:49:58 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
12:50:10 <burp> @hoogle ByteString -> [Word8]
12:50:10 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
12:50:10 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
12:50:10 <lambdabot> Data.ByteString head :: ByteString -> Word8
12:50:12 <gwern> FunctorSalad_: hm. that wouldn't apply here, I don't think any of my comments save 1 could possibly be hidden like that
12:50:55 <Petrosian> Geralt: It isn't
12:51:10 <ray> geralt: use a guard
12:51:10 <Raevel> Geralt: testFunc n | n `elem` [0..5] = "0 to 5" | otherwise = "Not in 0 to 5" is close
12:51:12 <Petrosian> At least, not to my knowledge
12:53:03 <Geralt> Raevel: thanks for clearing that, but I didn't learn that syntax yet
12:54:17 <ray> a guard is a boolean expression that has to be true for you to continue to the RHS
12:54:57 <ray> focus group time: should XYZ company become a haskell business?
12:55:15 <Heffalump> ray: unlikely.
12:55:36 <ray> that's not the result i'm trying to get from this focus group, so you're kicked out
12:56:01 <gwern> but that's cherrypicking your data!
12:56:08 <gwern> that's not statistically valid
12:56:50 <ray> yes it is
12:56:59 <ray> i want a representative sample, he's not representing what i want
12:57:38 <gwern> but how do you know your representative sample wouldn't yield results like him? in which case you'd be rejected his representin'
12:57:41 <gwern> foo
12:57:53 <ray> because i already know the result of my focus group
12:57:53 <Lemmih> Breaking news: 100% of people believing in X believe in X.
12:58:03 <ray> the focus group is just a formality
12:58:26 <gwern> Lemmih: 'it's raining outside, but I don't believe it is.'
13:02:38 <burp> > chr 8364
13:02:41 <lambdabot>   '\8364'
13:02:48 <burp> how can I get the symbol for it?
13:02:58 <benmachine> > text . chr $ 8364
13:02:59 <lambdabot>   Couldn't match expected type `GHC.Base.String'
13:03:03 <benmachine> oya
13:03:07 <benmachine> > text . return . chr $ 8364
13:03:09 <lambdabot>   â‚¬
13:03:28 <burp> @hoogle text
13:03:29 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
13:03:29 <lambdabot> Text.XHtml.Transitional text :: String -> HtmlAttr
13:03:29 <lambdabot> Language.Haskell.TH.PprLib text :: String -> Doc
13:03:33 <copumpkin> pure > return
13:03:38 <copumpkin> or point, even better
13:03:42 <benmachine> :t point
13:03:44 <lambdabot> Not in scope: `point'
13:03:49 <copumpkin> , point
13:03:50 <lunabot>  luna: No instance for (GHC.Show.Show (a -> f a))
13:03:52 <burp> where is text?
13:03:57 <copumpkin> , point 5 :: [Int]
13:03:59 <lunabot>  [5]
13:04:39 <benmachine> , point 0 :: (e, Int)
13:04:40 <lunabot>  luna: Could not deduce (Control.Functor.Pointed.Pointed ((,) e))
13:04:46 <benmachine> oic
13:05:00 * benmachine doesn't have a Control.Functor
13:05:09 <burp> :t text
13:05:10 <lambdabot> String -> Doc
13:05:28 <benmachine> @index text
13:05:28 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
13:05:30 <burp> Doc.. well
13:05:35 <burp> (myEncrypt "Umlaut: ü ö ä €" "foo") >>= (\x -> myDecrypt x "foo") , -> Just "Umlaut: \252 \246 \228 \8364"
13:05:50 <copumpkin> benmachine: it's in category-extras
13:06:07 <benmachine> oh ok
13:06:24 <burp> basically I use base64 unpack, and utf8 bytestring fromString to convert the string with utf8 characters into [Word8]
13:06:59 <burp> and the other way round I get "Umlaut: \252 \246 \228 \8364" this without the symbols
13:07:05 <rntz> in ghci, when I do ":m +Control.Monad.State", it complains that Control.Monad.State is found in multiple packages, namely: monads-fd-0.0.0.0 mtl-1.1.0.2
13:07:16 <rntz> how do I fix this? I do not, AFAICT, have the monads-fd library installed.
13:07:33 <Raevel> i have this problem too
13:07:38 <burp> one way would be to remove monads-fd ;)
13:07:38 <benmachine> rntz: you can use ghc-pkg hide
13:08:07 <Raevel> -hide-package monads-fd-0.0.0.0 to ghci is also an option
13:08:16 <benmachine> or on a single compile you can select one by doing ghc -hide-package
13:08:32 <rntz> benmachine: thanks.
13:11:47 <burp> > render . text $ "Umlaut: \252 \246 \228 \8364"
13:11:49 <lambdabot>   "Umlaut: \252 \246 \228 \8364"
13:12:12 <burp> > text $ "Umlaut: \252 \246 \228 \8364"
13:12:14 <lambdabot>   Umlaut: Ã¼ Ã¶ Ã¤ â‚¬
13:16:06 <deech`> Hi all, are there adequate libraries available in Haskell to  write a server process sends out email at some specified time?
13:18:00 <jfoutz> @where happstack.util.mail
13:18:00 <lambdabot> I know nothing about happstack.util.mail.
13:18:07 <jfoutz> hmm.
13:19:18 <deech`> jfoutz: No happstack.util.mail in the official docs either
13:19:20 <meanburrito920_> what does a bang in front of a type signify?
13:19:38 <deech`> meanburrito920_: That is should be evaluated immediately, and not lazily.
13:19:47 <meanburrito920_> ah. k
13:20:20 <meanburrito920_> why would a type need to be evaluated immediately?
13:20:46 <bringert> @seen dons
13:20:46 <lambdabot> Unknown command, try @list
13:21:09 <benmachine> meanburrito920_: if it is in front of a type in a data declaration, it means the relevant field will be evaluated non-lazily
13:22:02 <meanburrito920_> ah
13:22:24 <deech`> meanburrito920_: Because sometimes you don't need to hold off on the computation. For example, a type that holds two coordinates, type Coordinate = Double Double , can be modified to ' type Coordinate = !Double !Double'
13:23:10 <meanburrito920_> I'm a bit confused as to how that is advantageous though...
13:23:42 <deech`> meanburrito920_: In regular lazy evaluation everything is a "thunk" until evaluated.
13:24:05 <benmachine> deech`: that type declaration looks a bit odd :P
13:24:15 <deech`> meanburrito920_: holding onto "thunks" is more expensive than evaluating them.
13:24:30 <deech`> benmachine: I didn't test it, is the syntax off?
13:24:50 <meanburrito920_> deech: ah, so it's a performance thing mainly?
13:25:01 <benmachine> meanburrito920_: almost entirely a performance thing
13:25:12 <meanburrito920_> ok, that makes a lot more sense :)
13:25:15 <arw_> meanburrito920_: imagine you want to sum up the first 999999 primes. you could search for all those primes first and them sum them up.
13:25:18 <jmcarthur_work> meanburrito920_, say we have data Vector a = Vector a a a. if we have a very large list of Vectors and take the sum, each component of the resulting Vector is just a very large chain of thunks until we force it. this could lead to a "stack overflow"
13:25:26 <benmachine> deech`: um, I think so, since Double Double isn't a type
13:25:36 <arw_> that is, build a list of all the primes, which takes up lots of space, then rum the sum.
13:25:42 <arw_> that would be the lazy version.
13:25:53 <tibbe> anyone knows if John Lato hangs out here?
13:25:58 <benmachine> meanburrito920_: if you've ever looked at seq or foldl' they exist for similar reasons
13:26:04 <jmcarthur_work> meanburrito920_, but if we have data Vector a = Vector !a !a !a instead, it's better. the sum is computed as we go (assuming an -O2 or fold' version of sum)
13:26:29 <arw_> or you could search for the primes and immediately add them to an accumulator. that would be the much faster, strict version which also wouldn't eat up your memory
13:27:40 <jmcarthur_work> there is an interesting dual nature between lazy and strict data structures as they interact with lazy and strict algorithms which i have never really been able to express properly
13:28:21 <jmcarthur_work> if you use lazy structures in strict algorithms, you might end up with large chains of thunks. if you use strict structures in lazy algorithms, you might end up with large chains of thunks
13:28:38 <jmcarthur_work> i don't think that expressed it properly or exactly
13:28:54 <deech`> jfoutz: I found a happstack.util.cron that does something a regularly specified intervals.
13:29:51 <jmcarthur_work> i think it boils down to that a lazy structure must be used in "productive" algorithms and a strict structure must be used in "terminating" algorithms
13:30:00 <deech`> jmcarthur_work: How about 'why write a check (lazy) when you can pay cash (strict)'?
13:31:14 <jfoutz> deech`: sorry work got a little... demanding. this is what i was looking for http://hackage.haskell.org/packages/archive/happstack-util/0.3.2/doc/html/Happstack-Util-Mail.html
13:31:21 <jmcarthur_work> deech, i'm not sure if/how that captures what i mean
13:31:33 <eoeas> Hi peoplez, if in GHCi I type > :info whatever, and get whatever :: a -> a -> a. what does a -> a -> a mean ??
13:31:46 <jfoutz> :t (*)
13:31:47 <lambdabot> forall a. (Num a) => a -> a -> a
13:31:56 <jfoutz> >2*3
13:32:04 <jfoutz> > 2*3
13:32:06 <lambdabot>   6
13:32:56 <eoeas> jfoutz: was that answer directed to me?
13:33:02 <jfoutz> eoeas: it's a function, that requires something of type a, and then another think of type a and it returns something if type a
13:33:22 <jfoutz> if i could spell, i would be dangerous. sorry about that.
13:33:34 <eoeas> jfoutz: but what do the "->" stand for ??
13:33:35 <jfoutz> eoeas: it's a function, that requires something of type a, and then another thing of type a and it returns something of type a
13:33:50 <jfoutz> eoeas: take a look at "id"
13:33:52 <jfoutz> :t id
13:33:54 <lambdabot> forall a. a -> a
13:34:14 <jfoutz> it's simpler with 1 argument
13:34:21 <jfoutz> > id 1
13:34:23 <ray> dons: do you have any idea why reddit peanut gallery hates scribd so much?
13:34:23 <lambdabot>   1
13:34:33 <jfoutz> > id "a"
13:34:35 <lambdabot>   "a"
13:34:36 <ray> > negate `id` 1
13:34:37 <lambdabot>   -1
13:35:18 <deech`> jmcarthur_work: A check is like a thunk, it can be redeemed for cash.
13:35:33 <jfoutz> eoeas: i think the -> stands for application
13:35:52 <eoeas> jfoutz: So the "a" means argument and the "->" from .. ?
13:36:02 <deech`> jmcarthur_work: forget it, that was bad. Thought I had something there.
13:36:04 <eoeas> means
13:36:20 <lispy> ray: IMO, their interface is a bit annoying with the fixed size viewing panel and what are they using, flash?
13:36:31 <jfoutz> eoeas: a means there is something of type 'a'
13:36:42 <ray> i think it's much less annoying than a pdf
13:36:44 <lispy> ray: I can see how the peanut gallery would be whiny
13:36:52 <lispy> ah, I greatly prefer a PDF :)
13:36:59 <ray> in your browser?
13:37:09 <jmcarthur_work> deech, it's an okay analogy, i think, just not very applicable to what i was trying to say ;)
13:37:12 <lispy> no, I don't view pdfs in my browser
13:37:24 <lispy> ray: that has a tendency to crash the browser
13:37:31 <jfoutz> :t (*2)
13:37:33 <lambdabot> forall a. (Num a) => a -> a
13:37:48 <jfoutz> eoeas: something of type a, that must be in class Num
13:37:50 <ray> well i didn't mean anything that bad, it's just a bit annoying to use the pdf viewer
13:37:57 <jfoutz> :t ord
13:37:58 <lambdabot> Char -> Int
13:38:00 <ray> you should really stop using whatever browser that is
13:38:11 <jfoutz> > ord 'a'
13:38:12 <lambdabot>   97
13:38:19 <jfoutz> :t chr
13:38:21 <lambdabot> Int -> Char
13:38:29 <jfoutz> > chr 97
13:38:30 <lambdabot>   'a'
13:38:51 <eoeas> jfoutz:  so..     show :: a -> String     , means of type a of type String ??
13:39:28 <jfoutz> eoeas: well, let's see
13:39:31 <jfoutz> :t show
13:39:32 <lambdabot> forall a. (Show a) => a -> String
13:39:47 <jfoutz> show "hello"
13:39:50 <lispy> ray: I tend to use FF.  Maybe recent versions don't get locked up anymore, I doubt I've tried since 1.x.  I would like to start using Chrome but it's still windows only :)
13:39:51 <jfoutz> > show "hello"
13:39:53 <lambdabot>   "\"hello\""
13:40:14 <jfoutz> so, string works... but it dosn't seem to require a string on the left. the argument to the function
13:40:20 <jfoutz> > show 1
13:40:23 <lambdabot>   "1"
13:40:25 <ray> hmm, i don't think i can help you
13:40:43 <ray> i haven't used firefox since 1.x either
13:40:51 <ray> except used, not used with pdf plugins
13:40:56 <lilac> is there a way to get Data.Binary.Get to not use an exception if it runs out of bytes? (an alternative run function or similar)
13:41:27 <jfoutz> eoeas: see, a -> String, you could read it as something of any type to something of type string.
13:41:52 <jfoutz> eoeas: where * requires a num.
13:41:59 <jfoutz> > 2 * 2
13:42:01 <lambdabot>   4
13:42:06 <jfoutz> > 2.0 *2.0
13:42:08 <lambdabot>   4.0
13:42:15 <jfoutz> > 2 == 2.0
13:42:16 <lambdabot>   True
13:42:19 <jfoutz> hmm.
13:42:27 <jfoutz> > 2::Int == 2.0
13:42:27 <benmachine> :t 2
13:42:29 <lambdabot> forall t. (Num t) => t
13:42:30 <lambdabot>   <no location info>: parse error on input `2.0'
13:42:37 <benmachine> (2 :: Int) == 2.0
13:42:43 <benmachine> > (2 :: Int) == 2.0
13:42:45 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
13:42:45 <lambdabot>    arising from the lit...
13:43:00 <benmachine> numeric literal parsing is weird
13:43:11 * jfoutz nods.
13:44:14 <jfoutz> eoeas: tell me about (+2). what type do you guess it is, and what do you get with :t ?
13:44:30 <ray> benmachine: unary minus is even worse
13:44:33 <eoeas> jfoutz: Integer
13:44:56 <jfoutz> ah... ok.
13:45:16 <jfoutz> how about + ? the operator, like 1 + 2
13:46:02 <benmachine> (+2) is a function >_>
13:46:11 <Cale> > (+2) 5
13:46:13 <lambdabot>   7
13:46:14 <jfoutz> yeah. i chose a bad example.
13:46:15 <eoeas> jfoutz: infix
13:46:29 <jfoutz> :t (+)
13:46:30 <lambdabot> forall a. (Num a) => a -> a -> a
13:47:00 <jfoutz> so, yes, plus is infix.
13:47:14 <jfoutz> but plus takes one argument that is a number
13:47:25 <jfoutz> and then, it takes another argument that is also a number
13:47:33 <jfoutz> and then it gives you a new number back
13:47:49 <Twey> :t plus
13:47:50 <lambdabot> Not in scope: `plus'
13:47:56 <Twey> Lies â˜¹
13:47:58 <eoeas> jfoutz: I see
13:47:58 <jfoutz> so we can gather up the arguemts with ( and )
13:48:04 <jfoutz> :t (1+)
13:48:06 <lambdabot> forall t. (Num t) => t -> t
13:48:08 <lilac> @hoogle Read a => ByteString -> a
13:48:08 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:48:08 <lambdabot> Prelude id :: a -> a
13:48:08 <lambdabot> Data.Function id :: a -> a
13:48:27 <jfoutz> so 1+ only needs 1 more number to give you an answer
13:48:36 <jfoutz> > (1+) 2
13:48:39 <lambdabot>   3
13:48:53 * jfoutz hopes that helps
13:48:58 <eoeas> jfoutz: so if a stands for type a, what does t stand for ?
13:48:58 <jokerGTA> kmc hello:)
13:49:28 <eoeas> jfoutz: e.g. i sometimes see t, t1
13:49:33 <Cale> eoeas: a and t are both okay as type variables. It doesn't matter what name you use for type variables as long as they start with a lowercase letter.
13:49:35 <jfoutz> eoeas: it's a variable, like x, but for a type rather than a function
13:49:41 <elliottt> anyone familiar with the ghc build process here?
13:49:49 <Vanadium> what if i use trademarked terms as type variable names
13:49:55 <Cale> :t map
13:49:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:49:58 <elliottt> i'm having some trouble installing a 6.11 snapshot, and i can't really understand the error i'm getting :)
13:50:07 <jokerGTA> can anyone explain this pattern binding
13:50:14 <Cale> It doesn't matter that 'a' is 'a' and 'b' is 'b', but it matters that they are different.
13:50:18 <jokerGTA> (x:y:z:rest) = [1..]
13:50:37 <Vanadium> jokerGTA: A list where the first element is x, the second is y, the third is z, and all the others are bound to the list rest
13:50:40 <jfoutz> see how, (\x y -> x + y), and (\a b -> a + b) are the same? the x,y,a,b don't really matter, just the position
13:50:41 <Cale> jokerGTA: That binds the first three elements of the list to x, y, and z respectively, and the remainder of the list to rest
13:50:56 <Cale> > let (x:y:z:rest) = [1..] in (x,y,z,rest)
13:50:58 <lambdabot>   (1,2,3,[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:51:01 <eoeas> jfoutz: Cale: I getchya
13:51:05 <Vanadium> jokerGTA: (:) is the "make me a list where the first element is the first thing and the other elements are the second thing"
13:51:13 <ray> constructor
13:51:16 <jokerGTA> oh ok
13:51:19 <Vanadium> jokerGTA: So you read that as (x:(y:(z:rest)))
13:51:29 <benmachine> can I tell ghci to look in a given directory to find Modulename.hs
13:51:38 <grust> G'evening all.
13:51:39 * benmachine tries -I and -L to no avail
13:51:43 <benmachine> *tried
13:51:47 <Vanadium> cd :>
13:51:47 <jokerGTA> i am reading about pattern bidning thats where this example is from.its so confusin
13:51:49 <benmachine> evening grust
13:52:55 <Cale> jokerGTA: Basically, you just match the parts of the structure of the value on the right of the = with the pattern on the left.
13:53:20 <benmachine> oh it is -i
13:53:28 <jokerGTA> does it get easier to understand patterns?:)
13:53:38 <Cale> jokerGTA: It might help to remember that every list in Haskell is either the empty list [], or it is a list constructed by adding an element x to the beginning of another list xs, written as x:xs
13:54:01 <Vanadium> jokerGTA: Well, at one point you have understood all patterns.
13:54:05 <Vanadium> From then on it is rather easy.
13:54:08 <Twey> (data [] a = [] | a : ([] a))â€¦
13:54:14 <Cale> : associates to the right, so when you write x:y:z:xs, you mean x:(y:(z:xs)) and not ((x:y):z):xs
13:55:06 <jokerGTA> when you do it like that i cant help but think that all the function in haskell end up being few lines of code
13:55:32 <Cale> jokerGTA: That's mostly correct.
13:55:41 <Cale> jokerGTA: But I don't know what you're referring to.
13:56:33 <jokerGTA> well i dont know now.,..from top of my head...like in java or c you would have functions and the execute step by step....so not many functions i worked with in java and c end up being one line or 2
13:56:41 <jokerGTA> usually they bigger with lots of line of code
13:56:56 <jokerGTA> some functions would be 1 or 2 lines but mostly update functions
13:57:48 <Phyx-> :t fmap <*>
13:57:49 <lambdabot> parse error (possibly incorrect indentation)
13:58:06 <ray> :t (fmap <*>)
13:58:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => ((a -> b) -> f a) -> (a -> b) -> f b
13:58:20 <Vanadium> jokerGTA: Yes, functions end up being a single expression, and many functions are very short ones.
13:58:43 <jokerGTA> can you assign variable inside the haskell function
13:58:49 <Vanadium> jokerGTA: But on one hand, we have stuff like if/then/else, nested let-bindings and case expressions to make our expressions more complicated
13:58:51 <jokerGTA> like in java i would say int i =3;
13:58:58 <lilac> does the Binary instance for Double read/write in IEEE754?
13:59:05 <lilac> looks like it doesn't :(
13:59:10 <Vanadium> and on the other we can use the "do" syntactic sugar to do the whole "hey look we can pretend to be imperative" thing
13:59:12 <jokerGTA> is it usualy done to assign variables like that
13:59:26 <Phyx-> :t fmap (<*>)
13:59:28 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Functor f1) => f1 (f (a -> b)) -> f1 (f a -> f b)
13:59:34 <Vanadium> jokerGTA: We do not have that kind of variables
13:59:47 <Twey> jokerGTA: We have â€˜letâ€™
13:59:50 <Twey> > let i = 3 in i
13:59:52 <lambdabot>   3
14:00:09 * lilac finds the data-binary-ieee754 library and is overjoyed
14:00:10 <jokerGTA> cool
14:00:19 <Twey> Patterns are much more common, though you'll see some â€˜letâ€™s around.
14:00:35 <Twey> You should be aware that it doesn't exactly work like imperative assignment, though.
14:00:48 <Twey> > let i = 3 in let i = i + 1 in i
14:00:50 <Vanadium> let just gives a value a new name. If there was already a value with that name, it does not so much overwrite the value as hide the old name.
14:01:01 <jokerGTA> oh i see..
14:01:03 <Twey> That's infinitely recursive
14:01:03 <lambdabot>   thread killed
14:01:10 <Vanadium> Twey: I do not thingk "let i = i + 1" ever does what you want
14:01:13 <Vanadium> think*
14:01:13 <Twey> It will keep building a bigger and bigger number by adding 1 to itself :Ã¾
14:01:22 <Twey> Vanadium: Quite.
14:01:29 <Vanadium> Oh, that was the point. I thought you were getting at hiding the outer i.
14:01:36 <Twey> Unless you want an unevaluatable infinity.  :Ã¾
14:01:51 <jokerGTA> lol
14:01:53 <Vanadium> jokerGTA: There is the whole mutable references in the ST or IO monads but they are not as important as variables are in java
14:02:14 <Phyx-> :t fmap (<*>) id
14:02:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:02:23 <Phyx-> that type signature looks familiar...
14:02:24 <Vanadium> and I probably just lost like ten points of karma for acknowledging their existence
14:02:25 <lilac> > let i = 1 + i in i > (42 :: Natural)
14:02:27 <lambdabot>   True
14:02:36 <jokerGTA> thanks guys
14:02:42 <Phyx-> @hoogle f (a -> b) -> f a -> f b
14:02:43 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
14:02:43 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
14:02:43 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
14:02:48 <ray> @karma- 10 vanadium
14:02:48 <lambdabot> 10's karma lowered to -1.
14:02:49 <Phyx-> hah
14:02:50 <Phyx-> LOL
14:02:53 <Phyx-> no wonder
14:03:04 <ray> BRAIN EXPLOSION TIME
14:04:13 <Phyx-> hm.. was there really a need for <**> ? isn't that just flip <*>
14:04:25 <Heffalump> no, it runs the effects in a different order (IIRC)
14:04:25 <Phyx-> @src (<**>)
14:04:26 <lambdabot> (<**>) = liftA2 (flip ($))
14:04:51 <Phyx-> @src (<*>)
14:04:51 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:05:09 <Phyx-> No... i call myself a computer scientist
14:05:32 <MrBlueSky> Anyone here know if Haskell is generally faster than java or not?
14:05:55 <c_wraith> It's easy to write slow code in any language.
14:05:55 <MrBlueSky> Benchmark-wise.
14:06:10 <Vanadium> MrBlueSky: Check the language shootout game
14:06:13 <roconnor> MrBlueSky: are you asking about GHC?
14:06:23 <MrBlueSky> Yeah.
14:06:24 <benmachine> > let i = i + 1 in i > (70 :: Natural)
14:06:31 <Vanadium> Basically, give me a haskell program and I can find a slower java program...
14:06:34 <Phyx-> Vanadium: never liked that game.... they run c# on mono...
14:06:39 <lambdabot>   thread killed
14:06:42 <benmachine> :(
14:06:54 <Phyx-> you can always make a slower program
14:06:59 <roconnor> MrBlueSky: I'd say yes, but I think in #java they might say no.
14:07:01 <Vanadium> Phyx-: Well, if ms got around to posting a version of their code that compiles on linux, I am sure they would not oppose to using their implementation
14:07:05 <c_wraith> there are no bounds to artifical stupidity
14:07:29 <MrBlueSky> but generally they are both around at least the same in speed?
14:07:48 <Vanadium> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=java&box=1 should answer your question
14:07:50 <Vq> Vanadium: haven't they heard of wine? :o)
14:07:52 <Vanadium> but I am not sure how to read it
14:08:02 <c_wraith> MrBlueSky: Performance should not be the factor you use to choose one or the other
14:08:14 <roconnor> MrBlueSky: depends on if the JIT and runtime profiling can make up for themselves.
14:08:31 <roconnor> c_wraith: good observation.
14:08:53 <Vanadium> Performance might very well be the factor that decides a bet made over lunch
14:09:20 <Vanadium> Vq: That sounds vaguely complicated
14:09:38 <Vanadium> Vq: In that case, C# is going to lose all benchmarks not run on a 386 compatible machine I suspect
14:10:12 <roconnor> Vanadium: oh, interesting,  Java appears generally a little faster.
14:10:16 <Vq> Vanadium: that could be of interest as well
14:16:13 <lilac> @hoogle Monad m => m a -> (a -> Bool) -> m [a]
14:16:13 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
14:16:13 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
14:16:13 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
14:19:26 <ray> :t guard
14:19:28 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:20:07 <ray> i'm guessing you want some kind of filterM thing
14:20:27 <ziman> :t untilM
14:20:29 <lambdabot> Not in scope: `untilM'
14:21:34 <dancor> 14:08 < roconnor> c_wraith: good observation.
14:21:34 <dancor> 14:08 < Vanadium> Performance might very well be the factor that decides a bet
14:21:34 <dancor>                   made over lunch
14:21:34 <dancor> 14:09 -!- darq [n=darq@173-141.dsl.iskon.hr] has joined #haskell
14:21:34 <dancor> 14:09 < Vanadium> Vq: That sounds vaguely complicated
14:21:35 <dancor> 14:09 < Vanadium> Vq: In that case, C# is going to lose all benchmarks not run
14:21:37 <dancor>                   on a 386 compatible machine I suspect
14:21:39 <dancor> 14:09 -!- komar_ [n=komar@antikvar.static.corbina.ru] has quit ["WeeChat
14:21:41 <dancor>           0.2.6.3-ohshi"]
14:21:43 <dancor> 14:09 -!- pcprogrammer [n=pcprogra@122.170.30.14] has quit [Read error: 60
14:21:45 <dancor>           (Operation tim[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[34~[3
14:21:51 <dancor> [32~000000000 X[d
14:21:54 <dancor>  BXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
14:21:55 <jmcarthur_work> ...
14:21:58 <copumpkin> dancor: nice
14:22:00 <c_wraith> ...  did he just cat something to his terminal?
14:22:00 <dancor> LLLLLLLLLLL66______________________________________________________________________________________________LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
14:22:06 <dancor> 14:10 -!- mreggen [n=mreggen@cm-84.215.28.167.getinternet.no] has joined
14:22:08 <dancor>           #haskell
14:22:09 <copumpkin> @where ops
14:22:10 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:22:10 <dancor> 14:10 < roconnor> Vanadium: oh, interesting,  Java appears generally a little
14:22:12 <dancor>                   faster.
14:22:13 --- mode: ChanServ set +o mauke
14:22:21 <ray> probably an irssi user
14:22:25 <jmcarthur_work> woops
14:22:54 <xaep> ray: why irssi? it's pretty hard to hit Ctrl-K occasionally
14:23:01 <ray> my hand's always slipping over irssi, so i make sure to always copy single characters
14:23:13 --- mode: mauke set -o mauke
14:23:13 <lispy> loooks like a run-away paste in X
14:23:23 <lispy> I've done that before
14:23:36 <lispy> used to happen a lot on an old thinkpad I had where the mouse would go berserk
14:23:47 <jmcarthur_work> i love how it just degenerated into a bunch of nonsense
14:23:58 <ray> looks like escape sequences
14:24:04 <mauke> xaep: <dancor> 14:09 -!- komar_ [n=komar@antikvar.static.corbina.ru] has quit
14:24:06 <skorpan> looks like shit
14:24:17 <mauke> that format looks like irssi
14:24:20 * benmachine uses ctrl-shift-c to copy
14:24:22 <benmachine> am I a heathen
14:24:24 <xaep> mauke: ah ok
14:24:46 <ray> all irssi users should know how to use /server purge for those embarassing paste mishaps
14:24:55 <Vanadium> ray: Oh?
14:25:06 * benmachine is in: all irssi users
14:25:15 <Vanadium> Neat
14:25:15 <ray> that's all you do, /server purge
14:25:15 <benmachine> what does /server purge do
14:25:20 <andrewsw> ray: do tell
14:25:21 <xaep> mauke: but, anyways, I wonder how anyone can paste such piece of crap _accidentally_
14:25:26 <benmachine> how does it work?
14:25:31 <ray> it purges whatever's in your queue to be sent to the server
14:25:34 <ray> that's all
14:25:36 <benmachine> oh
14:25:42 <benmachine> I thought queuing was done by the server
14:25:46 <ray> no
14:25:51 <ray> well, it's complicated
14:25:58 <benmachine> I'm pretty sure the server does SOME queuing
14:26:05 <jmcarthur_work> or dropping
14:26:07 <benmachine> I remember when I was making bots and testing their flood protection
14:26:11 <ray> yeah, but irssi si what's throttling you
14:26:18 <xaep> so, kids, don't do /server purge
14:26:21 <benmachine> and they delayed their messages, and I was like, I didn't code this
14:26:22 <jmcarthur_work> i think the client does the queuing to prevent being dropped
14:26:25 <ray> no, *do* do /server purge
14:26:32 <Phyx-> 23:21:21 < jmcarthur_work> ...
14:26:32 <Phyx-> 23:21:23 < copumpkin> dancor: nice
14:26:32 <Phyx-> 23:21:25 < c_wraith> ...  did he just cat something to his terminal?
14:26:34 <Phyx-> haahahahah
14:26:36 <ray> if you ever accidentally flood
14:26:49 <benmachine> mm
14:26:55 <benmachine> that is useful
14:27:03 <benmachine> @help karma
14:27:04 <lambdabot> karma <polynick>. Return a person's karma value
14:27:05 <ray> without the irssi throttling you'd just fill up your queue and the server would boot you off
14:27:07 <benmachine> ic
14:27:08 <ray> excess flood
14:27:18 <Vanadium> irc101
14:27:21 <andrewsw> so if you catch it, you can purge it before irssi deques it all to the server... right?
14:27:26 <ray> yeah
14:27:27 <benmachine> ray: well when I tried I found it remarkable difficult to get excess flood
14:27:37 <Badger> If this is true, then ray is awesome
14:27:40 <ray> you can turn off irssi throttling if you're crazy
14:27:57 <benmachine> Badger: I know right
14:28:06 <benmachine> ray++ etc.
14:28:13 <Vanadium> @karma+ ray
14:28:14 <lambdabot> ray's karma raised to 4.
14:28:15 <Vanadium> :toot:
14:29:16 <mauke> preflex: karma ray
14:29:16 <preflex>  ray: 6
14:30:45 <benmachine> @karma ray
14:30:45 <lambdabot> ray has a karma of 4
14:30:49 <benmachine> oh
14:31:14 * benmachine tried PMing to reconcile the numbers but to no avail
14:31:25 <ray> but just to be safe, i always keep a single character in my paste buffer
14:31:32 <ray> to avoid the situation in the first place
14:31:43 <Phyx-> ray: would that still work if you have a server saved as "purge"
14:31:44 <Phyx-> lol
14:31:58 <ray> i assume it would
14:32:11 <Phyx->  /SERVER PURGE [<target>]
14:32:12 <Phyx-> ah
14:33:25 * Phyx- needs something to do
14:33:28 <ray> i think it used to just be /server purge without the argument, which was ugly
14:33:44 <ray> you needed to be in a window of the server tag you wanted to purge
14:35:24 <Phyx-> development of irssi is rather stale... then again.. the irc protocol hasn't changed in ages
14:35:37 <Phyx-> do wish they added encryption build in the client though
14:35:58 <skorpan> the IRC protocol is the same as 21 years ago, isn't it?
14:36:44 <Phyx-> yeah, but certain servers have modified it to their needs
14:37:02 <skorpan> that's like microsoft modify their browsers to their needs ;P
14:38:04 <ray> irssi can do ssl
14:38:11 <ray> freenode can't :P
14:38:43 <ray> irc's a mess. i know too much and i'm not even an irc developer (thank god)
14:51:51 <Phyx-> skorpan: lol
14:52:06 <Phyx-> ray: hmm, i thought irssi could do ssl
14:52:09 <Phyx-> oh
14:52:10 <Phyx-> sorry
14:52:13 <Phyx-> read you wrong
14:53:53 <Phyx-> i was refering to those encryption some channels have using things like Diffie-Hellman key exchange
14:54:02 <pacopil> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
14:55:05 <RayNbow> I don't get it... why the hell do ppl even try to spam a channel like #haskell
14:55:15 <ray> because it is one of the largest on freenode
14:55:21 <Phyx-> because of the same reason why people spam emails
14:55:31 <Phyx-> just 1% needs to click and it's worth it
14:55:58 <idnar> I highly doubt there's anything near a 1% clickthrough rate for spam email
14:56:04 <idnar> maybe a 0.00001% rate :P
14:56:15 <jmcarthur_work> you would be surprised
14:56:54 <idnar> if every person in the world clicks through one spam email per day, that's still probably less than 0.01%
14:57:46 <jmcarthur_work> that assumes that all the spam in each inbox is from different sources
14:57:51 <idnar> RayNbow: they're probably not targetting #haskell specifically, they're just hitting random channels, or the largest channels, or trying to hit all channels
14:57:54 <c_wraith> idnar: You're underestimating how stupid 1% of the population is.
14:57:58 <jmcarthur_work> and that number is still low
14:58:19 <idnar> c_wraith: I think you're underestimating how much spam gets sent
14:58:25 <jmcarthur_work> that would mean every single person in the world gets 10000 spam emails a day
14:58:33 <jmcarthur_work> sounds just a little high to me
14:58:35 <idnar> anyway, I may have misinterpreted the original statistic
14:58:42 <c_wraith> There are well-documented cases of people who click through every piece of spam they get
14:58:43 <RayNbow> idnar: too bad it's hard to counter this spam without inconveniencing good users
14:58:45 <c_wraith> and buy a fair amount of it
14:58:51 <c_wraith> it makes me want to cry
14:58:58 <idnar> and of course, most people in the world don't have email
14:59:09 <jmcarthur_work> right
14:59:33 * RayNbow once tried +R as a measurement on a different channel/server...
14:59:46 <RayNbow> but sometimes the regulars forgot to identify
14:59:47 <c_wraith> I'd say "having access to email" is independent from "ability to judge whether buying stuff from spam is a good idea"
15:00:36 <idnar> anyhow, my point was mostly just that there is so much spam being sent that people couldn't click on all of it even if they tried
15:00:37 <jfoutz> storm network was 12.5M emails per sale.
15:03:40 <eu-prleu-peupeu> helloooo
15:04:27 <jmcarthur_work> idnar, which is exactly why there is so much :(
15:05:04 <Phyx-> i wonder how many people bought viagra via spam
15:05:16 <jmcarthur_work> jfoutz, that's a crazy number
15:05:36 <eu-prleu-peupeu> phyx, i did
15:05:43 <Phyx-> :O
15:05:53 <Phyx-> did you actually receive it?
15:06:00 <eu-prleu-peupeu> not directly, but through the site they presented
15:06:02 <eu-prleu-peupeu> yes, offcourse
15:06:10 <Phyx-> lol
15:06:12 <eu-prleu-peupeu> and i even found out about other pills more powerfull than viagra
15:06:18 <eu-prleu-peupeu> viagra is for beginers
15:06:22 <Phyx-> isn't that risky...
15:06:25 <dons> as off topic as always, i see, eu-prleu-peupeu
15:06:34 <eu-prleu-peupeu> viagra is like scheme...
15:06:47 <eu-prleu-peupeu> :D
15:06:49 <eu-prleu-peupeu> hey dons
15:07:04 <eu-prleu-peupeu> next year ill be at the icfp
15:07:06 <jfoutz> jmcarthur_work: I was trying to find the original paper. I guess uc berkely and uc san diego took over part of the network. (thanks google) i believe it. i worked at a small isp for a while, we would get 5k mails/minute.
15:07:07 <copumpkin> o.O
15:07:09 <eu-prleu-peupeu> presenting cool papers about haskell
15:07:13 <copumpkin> eu-prleu-peupeu: trolling in person?
15:07:23 <eu-prleu-peupeu> i dont troll
15:07:23 <Phyx-> hahaha
15:07:24 <eu-prleu-peupeu> i am
15:07:55 <eu-prleu-peupeu> ill ask dons to sign my copy of the real world haskell
15:08:07 <copumpkin> have you read it?
15:08:21 <Phyx-> dons wrote it?
15:08:23 <eu-prleu-peupeu> not yet
15:08:26 * Phyx- has read his
15:08:31 <copumpkin> Phyx-: yep
15:08:44 <copumpkin> along with bos and CosmicRay
15:08:44 <hackagebot> tagchup 0.4 - alternative package for processing of tag soups (HenningThielemann)
15:08:46 <hackagebot> wraxml 0.4.3 - Lazy wrapper to HaXML, HXT, TagSoup via custom XML tree structure (HenningThielemann)
15:08:47 <Phyx-> :O
15:09:09 <eu-prleu-peupeu> how long does it take to read all of the real world haskell, doing all of the execises ?
15:09:12 <eu-prleu-peupeu> what is the record ?
15:09:15 <eu-prleu-peupeu> 1 month ?
15:09:23 <jmcarthur_work> try it and see
15:09:38 <eu-prleu-peupeu> ok
15:09:42 <Phyx-> took me a week to read through it, but didn't make all the exercises
15:09:57 <quantax> I suppose "cabal test" should do the same as "runhaskell Setup.hs test" -- i.e. run the runTests hook
15:10:05 <quantax> but it doesn't
15:10:22 <quantax> cabal test doesn't do anything
15:10:23 <dons> Phyx-: a week? wow.
15:10:28 <dons> it took 18 months to write
15:10:40 <eu-prleu-peupeu> http://www.google.com/trends?q=haskell
15:10:52 <lispy> dons: how does that compare to the time to write a PhD thesis? ;)
15:10:56 <eu-prleu-peupeu> most the stuff that shows there is about places and persons called haskell
15:11:07 <dons> lispy: that takes 6 years
15:11:12 <lispy> :)
15:11:15 <cwraith> ghost c_wraith
15:11:16 <quantax> but runhaskell Setup.hs test does what it is supposed to do?
15:11:20 <cwraith> bah. :(
15:11:25 <copumpkin> eu-prleu-peupeu: your point being?
15:11:30 <dons> cwraith is a ghost
15:11:32 <Phyx-> dons: lol, It was easy to read, could understand most things in one go, so saved on repitition
15:11:37 <cwraith> At least I didn't put my password in that line, either. :)
15:11:44 <dons> Phyx-: ok. time to upload your apps and libs to hackage now :)
15:11:44 <eu-prleu-peupeu> http://www.google.com/trends?q=haskell%2C+c%2B%2B&ctab=0&geo=all&date=all&sort=0
15:11:59 <eu-prleu-peupeu> my point being that
15:12:03 <eu-prleu-peupeu> once haskell is known
15:12:11 <eu-prleu-peupeu> all those places will become just a small noise
15:12:14 <eu-prleu-peupeu> see
15:12:15 <eu-prleu-peupeu> :)
15:12:15 * Phyx- actually does have a few apps/libs but would need to clean the code up before publishing
15:12:18 <Phyx-> lol
15:12:25 <quantax> am I missing something, or doesn't cabal-install support the runTests hook yet?
15:12:36 <eu-prleu-peupeu> if we could generate enough queries in google to be at least as known as c++, it wouldn't matter
15:12:47 <eu-prleu-peupeu> so, just fire up your curl bots :)
15:13:25 <copumpkin> avoid success at all costs!
15:13:48 <Makoryu> Hasn't the growth of this channel leveled off in the past year or so?
15:14:05 <copumpkin> it spiked earlier this year
15:14:09 <copumpkin> just shy of 700 people
15:14:11 <Makoryu> I seem to recall it hitting 800 people at some point, but now it's consistently under 600
15:14:13 <Makoryu> Ah
15:15:18 <dolio> Haskell is dying! We need more hype!
15:15:24 <copumpkin> > fix $ scanl ((+) <=< ((+) <=< (+))) 1
15:15:26 <Phyx-> :O
15:15:27 <lambdabot>   [1,4,16,64,256,1024,4096,16384,65536,262144,1048576,4194304,16777216,671088...
15:15:38 <copumpkin> > fix $ scanl ((+) <=< (+) <=< (+)) 1
15:15:40 <lambdabot>   [1,4,16,64,256,1024,4096,16384,65536,262144,1048576,4194304,16777216,671088...
15:15:43 <Phyx-> dolio: lol, is it becoming a lost art? :P
15:15:46 <eu-prleu-peupeu> hype doesn't make it live
15:15:54 <copumpkin> > fix $ scanl ((+) <=< (*) <=< (+)) 1
15:15:56 <lambdabot>   [1,3,21,903,1631721,5325028475403,56711856527710922180500221,64324693416393...
15:16:22 <copumpkin> > fix $ scanl ((+) <=< (*) <=< (+)) x
15:16:24 <lambdabot>   [x,(x + x) * x + x,((x + x) * x + x + ((x + x) * x + x)) * ((x + x) * x + x...
15:16:39 <Phyx-> o.O
15:16:45 <copumpkin> wut
15:17:03 <Phyx-> just wondering why it printed the literal x
15:17:10 <copumpkin> because I gave it the literal x
15:17:16 <Phyx-> eh
15:17:20 <copumpkin> > f x
15:17:22 <lambdabot>   Add a type signature
15:17:24 <copumpkin> > f x :: Expr
15:17:26 <Phyx-> > x
15:17:27 <lambdabot>   f x
15:17:29 <lambdabot>   x
15:17:33 <copumpkin> > x + y
15:17:34 <Phyx-> :t x
15:17:36 <lambdabot> Expr
15:17:37 <lambdabot>   x + y
15:17:38 <Phyx-> ah
15:17:41 <Phyx-> that explains it
15:18:03 <copumpkin> > fix $ scanl ((+) <=< (*) <=< (*)) 1
15:18:05 <lambdabot>   [1,2,10,1010,1030302010,1093688489093570254240903010,1308220420050293140207...
15:18:14 <copumpkin> that one grows pretty quickly
15:18:45 <jmcarthur_work> huh that's a neat way to do sequences
15:19:30 <Phyx-> wonder if you can produce a look-and-see sequence like that
15:19:37 <eu-prleu-peupeu> i really like the =<< operator
15:19:40 <ray> yeah
15:19:41 <eu-prleu-peupeu> its so sweet
15:19:48 <ray> it's more natural than >>=
15:19:50 <jmcarthur_work> <=< is event sweeter
15:19:53 <Phyx-> look-and-say*
15:19:53 <jmcarthur_work> *even
15:20:03 <eu-prleu-peupeu> i dont know the <=< operator
15:20:03 <ray> <=< is probably the best overall
15:20:08 <ray> :t (<=<)
15:20:09 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
15:20:16 <eu-prleu-peupeu> that is too much for my head
15:20:22 <ray> kleisli arrow composition
15:20:23 <jmcarthur_work> it's monadic composition
15:20:23 <eu-prleu-peupeu> i dont know how to read those things
15:20:29 <jmcarthur_work> yeah, that, specifically
15:20:37 <copumpkin> add some parens around the last two terms and it might be clearer
15:20:41 <ray> it's the same as (.)
15:20:46 <Phyx-> copumpkin: can you generate http://en.wikipedia.org/wiki/Look-and-say_sequence using that?
15:20:47 <copumpkin> .M
15:20:49 <ray> but instead of composing functions it composes kleisli arrows
15:20:54 <dolio> Monad laws are nice with (<=<).
15:20:59 <eu-prleu-peupeu> in practice what does it do ?
15:21:11 <copumpkin> Phyx-: hrm
15:21:18 <ray> monad laws are just associativity and identity with (<=<)
15:21:23 <jmcarthur_work> it composes kleisli arrows
15:21:24 <dolio> f <=< return = f = return <=< f   f <=< (g <=< h) = (f <=< g) <=< h
15:21:30 <jmcarthur_work> that's what it does in practice ;)
15:21:32 <jfoutz> :t (.)
15:21:34 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:21:36 <ray> kleisli arrows are functions like a -> m b
15:21:37 <jfoutz> :t (>=>)
15:21:41 <ray> for some monad m
15:21:44 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:21:48 <eu-prleu-peupeu> im only good at coding haskell through the advanced technique of copy paste
15:21:51 <ray> jfoutz: <=<
15:21:56 <jmcarthur_work> jfoutz, <=<
15:21:58 <jmcarthur_work> beat me
15:21:58 * jfoutz blushes
15:22:00 <eu-prleu-peupeu> can i get a simple example of its use ?
15:22:09 <jmcarthur_work> :t putStrLn <=< getLine
15:22:12 <jmcarthur_work> wrong
15:22:13 <jmcarthur_work> oops
15:22:20 <lambdabot>     Couldn't match expected type `a -> IO String'
15:22:22 <lambdabot>            against inferred type `IO String'
15:22:24 <lambdabot>     In the second argument of `(<=<)', namely `getLine'
15:22:27 <jmcarthur_work> :t putStrLn <=< readFile
15:22:27 <eu-prleu-peupeu> fail
15:22:28 <lambdabot> FilePath -> IO ()
15:22:31 <jmcarthur_work> there
15:22:44 <jmcarthur_work> :t readFile
15:22:45 <lambdabot> FilePath -> IO String
15:22:49 <jmcarthur_work> :t putStrLn
15:22:51 <lambdabot> String -> IO ()
15:22:52 <eu-prleu-peupeu> why does it work with readFile, and doesn't with getLine ?
15:22:58 <Phyx-> :y (<-<)
15:23:01 <jmcarthur_work> because it has to take a function
15:23:02 <Phyx-> :t (<-<)
15:23:02 <ray> getLine's just IO String
15:23:03 <lambdabot> Not in scope: `<-<'
15:23:06 <eu-prleu-peupeu> jmcarthur_work: but thats the same as =<< ?
15:23:06 <jmcarthur_work> not just an action like i tried
15:23:09 <jmcarthur_work> nope
15:23:11 <ray> you;d want \_ -> getLine
15:23:12 <Makoryu> :t let foo = id; bar = zipWith foo in foo
15:23:14 <lambdabot> forall a. a -> a
15:23:22 <eu-prleu-peupeu> :t putStrLn =<< readFile
15:23:23 <lambdabot>     Couldn't match expected type `IO String'
15:23:23 <lambdabot>            against inferred type `FilePath -> IO String'
15:23:23 <lambdabot>     In the second argument of `(=<<)', namely `readFile'
15:23:35 <jmcarthur_work> :t putStrLn =<< readFile "foo.txt"
15:23:36 <lambdabot> IO ()
15:23:43 <ray> if you think of <=< as like ., =<< is like $
15:23:46 <jmcarthur_work> :t (putStrLn <=< readFile) "foo.txt"
15:23:47 <lambdabot> IO ()
15:23:50 <eu-prleu-peupeu> ah
15:23:51 <eu-prleu-peupeu> nice
15:23:53 <eu-prleu-peupeu> i see
15:23:55 <lispy> Has anyone applied data flow analysis to type checking?
15:23:59 <eu-prleu-peupeu> now im going to rock in haskell
15:24:09 <dixie> hehe, IO orgy
15:24:11 <lispy> I could see it as a compromise (say, heuristic) approach to dependent typing
15:24:33 <jmcarthur_work> lispy, not sure what you mean
15:24:47 <lispy> jmcarthur_work: I'm not 100% sure either, I'm sort of sounding the idea out
15:24:56 <jmcarthur_work> time to go
15:25:11 <lispy> I read a paper once where the author said it would be nice if the type errors in GHC could use some data flow analysis to pin point the erorr better
15:25:16 <copumpkin> Phyx-: @let lookandsay :: Integer -> Integer; lookandsay = read . concatMap (uncurry (++) . (show . length &&& pure . head)) . group . show in lookandsay 21
15:25:27 <eu-prleu-peupeu> what is a anamorphism ?
15:25:40 <copumpkin> @let lookandsay :: Integer -> Integer; lookandsay = read . concatMap (uncurry (++) . (show . length &&& pure . head)) . group . show in lookandsay 21
15:25:40 <lambdabot>   Parse error: KW_In
15:25:46 <copumpkin> ah
15:25:53 <eu-prleu-peupeu> :t anamorphism
15:25:54 <lambdabot> Not in scope: `anamorphism'
15:26:03 <Badger> copumpkin: wrong let
15:26:05 <Phyx-> copumpkin: ah, i have it another way, almost similair though
15:26:12 <copumpkin> @let lookandsay = (read :: String -> Integer) . concatMap (uncurry (++) . (show . length &&& pure . head)) . group . show in lookandsay 21
15:26:12 <lambdabot>   Parse error: KW_In
15:26:17 <Phyx-> but i think very inefficient
15:26:18 <Phyx-> lol
15:26:22 <copumpkin> oh whooops
15:26:28 <copumpkin> Phyx-: @let lookandsay :: Integer -> Integer; lookandsay = read . concatMap (uncurry (++) . (show . length &&& pure . head)) . group . show
15:26:30 <copumpkin> bah
15:26:37 <Badger> you'll get there!
15:26:38 <copumpkin> @let lookandsay :: Integer -> Integer; lookandsay = read . concatMap (uncurry (++) . (show . length &&& pure . head)) . group . show
15:26:40 <lambdabot>  Defined.
15:26:41 * copumpkin gets there
15:26:43 <Phyx-> copumpkin: i have http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9193#a9193
15:26:43 <Badger> huzzah!
15:26:48 <Badger> @ty lookandsay
15:26:48 <copumpkin> > iterate lookandsay 1
15:26:50 <lambdabot> Integer -> Integer
15:26:52 <lambdabot>   [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,132113111231...
15:26:53 <Badger> er
15:26:54 <Badger> duh.
15:27:18 <ray> nice
15:27:18 <copumpkin> Phyx-: not inefficient
15:27:37 <Badger> > lookandsay 123
15:27:41 <lambdabot>   111213
15:27:50 <Phyx-> :t lookandsay
15:27:53 <copumpkin> > fix $ scanl (const lookandsay) 1
15:27:58 <lambdabot> Integer -> Integer
15:28:00 <Phyx-> did lambdabot die
15:28:00 <lambdabot>   [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,132113111231...
15:28:04 <Phyx-> oh, it's just slow
15:28:15 <ray> eu-prleu-peupeu: an anamorphism produces a structure from a value
15:28:25 <ray> like the stuff copumpkin is doing
15:28:29 <Phyx-> am i missing something here.. if the signature is Integer -> Integer, why is it outputting a list?
15:28:37 <lispy> Phyx-: scanl
15:28:39 <lispy> :t scanl
15:28:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
15:28:41 <copumpkin> Phyx-: I used iterate on it the first time
15:28:50 * Phyx- looks up
15:28:53 <copumpkin> and fix $ scanl (const f) x === iterate f x
15:28:55 <benmachine> pure . head = take 1
15:29:04 <Phyx-> oh right, i missed the iterate
15:29:07 <Crusty84> Hi everybody. Anybody here with any knowledge of wxHaskell?
15:29:17 * Phyx- goes to dissect the code
15:29:32 <lispy> fix $ scanl (const f) x == interate f x, huh?  Never thought about that
15:29:41 <shachaf> Crusty84: Surely there is; but I suspect that if you asked a specific question you would be more successful.
15:29:41 <eu-prleu-peupeu> Ray, so its a function ?
15:29:42 <copumpkin> lispy: might not be exactly the same actually
15:30:08 <benmachine> > lookandsay 22
15:30:09 <eu-prleu-peupeu> and a catamorphism ?
15:30:10 <lambdabot>   22
15:30:16 <copumpkin> @check \f x -> (fix $ scanl (const f) x) == iterate f x)
15:30:17 <lambdabot>  Unbalanced parentheses
15:30:21 <ray> eu-prleu-peupeu: it's a concept
15:30:25 <copumpkin> @check \f x -> (fix $ scanl (const f) x) == iterate f x
15:30:26 <ray> a catamorphism's the opposite
15:30:27 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
15:30:27 <lambdabot>    arising from a use of `...
15:30:27 <ray> like a fold
15:30:35 <copumpkin> damn
15:30:40 <eu-prleu-peupeu> oh
15:30:45 <copumpkin> benmachine found a fix point!
15:30:46 <eu-prleu-peupeu> and a map is anamorphism ?
15:30:50 <Phyx-> thanks copumpkin :), I really should remember Arrow.. i keep forgetting it exists
15:30:51 <ray> a map is neither
15:30:52 <eu-prleu-peupeu> produces a list from a list
15:30:53 <benmachine> I'm so excitd
15:30:54 <Crusty84> Well i was looking into wxHaskell and the class WxcClassTypes, raises some questions. Why are there all kinds of types with a T in front of it? What is there use?
15:31:03 <eu-prleu-peupeu> map is just morphine ?
15:31:09 <eu-prleu-peupeu> morphism
15:31:21 <ray> in haskell we think of map as being a functor
15:31:24 <Crusty84> The TEvtHandler is for example never used...
15:31:25 <ray> well, i do
15:31:32 <eu-prleu-peupeu> hmm
15:31:39 <ray> lifting a function to a function on a functor
15:31:41 <eu-prleu-peupeu>  i thought functors were containers
15:31:55 <eu-prleu-peupeu> ok
15:32:16 * benmachine ponders if it is the only fixpoint
15:32:20 <copumpkin> eu-prleu-peupeu: nope
15:32:30 <eu-prleu-peupeu> so what are functors exactly ?
15:32:33 <robdaemon> hi all, can I ask a question about syntax that I've come across reading Learn You a Haskell?
15:32:36 <copumpkin> > filter ((==) =<< lookandsay) [1..100]
15:32:37 <ray> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
15:32:39 <Botje> sure
15:32:40 <lambdabot>   [22]
15:32:43 <ray> the banana paper's good
15:33:10 <benmachine> copumpkin: well, it's not hard to guess there are none others under 100 >_>
15:33:14 <copumpkin> :P
15:33:14 <robdaemon> okay...  I'm doing the Syntax in Functions chapter, and I've decided to make bmiTell use the calcBmi function
15:33:16 <copumpkin> > filter ((==) =<< lookandsay) [1..1000]
15:33:19 <benmachine> I can't see any others at all
15:33:19 <lambdabot>   [22]
15:33:27 <copumpkin> > filter ((==) =<< lookandsay) [1..10000]
15:33:28 <robdaemon> calcBmi is defined as: calcBmi :: (RealFloat a) => [(a, a)] -> [a]
15:33:32 <lambdabot>   [22]
15:33:33 <benmachine> but I thought I remembered there being one
15:33:43 <benmachine> > drop 1000 $ iterate lookandsay 1
15:33:44 <copumpkin> prove there are no others!
15:33:46 <robdaemon> In my where clause in bmiTell, I've put:
15:33:53 <ray> eu-prleu-peupeu: in category theory, a functor is a morphism between categories
15:33:55 <robdaemon> where bmi =	calcBmi	[(weight, height)]
15:33:59 <lambdabot>   thread killed
15:34:11 <Botje> robdaemon: can you put your code on hpaste? (hpaste.org) That way it's easier to discuss
15:34:11 <benmachine> copumpkin: it's probably not that hard
15:34:18 <copumpkin> benmachine: yeah, probably not
15:34:19 <robdaemon> Oh, sure
15:34:19 <ray> in haskell, it's a polymorphic type where you can lift a function (a -> b) to a function (f a -> f b)
15:34:48 <benmachine> oh, I suppose there might be loops, even if not fixed points
15:34:55 <benmachine> proving THAT sounds more difficult
15:35:12 <robdaemon> link: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9194#a9194
15:35:18 <eu-prleu-peupeu> morphism = something that "morphs" (changes) ?
15:35:44 <Botje> robdaemon: okay. so what's your question?
15:36:00 <copumpkin> eu-prleu-peupeu: an "edge" in the graph
15:36:11 <robdaemon>     Could not deduce (Fractional [a]) from the context (RealFloat a)
15:36:11 <robdaemon>       arising from the literal `18.5' at test.hs:32:35-38
15:36:27 <copumpkin> robdaemon: you accidentally worked on the list rather than the values inside it
15:36:40 <copumpkin> I mean, you accidentally the entire list
15:36:53 <eu-prleu-peupeu> bah
15:36:58 <copumpkin> eu-prleu-peupeu: ?
15:37:10 <eu-prleu-peupeu> i hate the feeling "i should have studied maths to understand haskell"
15:37:17 <copumpkin> eu-prleu-peupeu: you don't
15:37:22 <robdaemon> hrm
15:37:31 <eu-prleu-peupeu> but i do
15:37:32 <copumpkin> eu-prleu-peupeu: but computers are mathematical
15:37:34 <lispy> math is really just the study of logical thought
15:37:41 <eu-prleu-peupeu> yeh right...
15:37:47 <lispy> so if you study haskell you are studying math
15:37:51 <ray> actually, i only know stuff about category theory via haskell
15:37:56 <Botje> robdaemon: you're comparing bmi against skinny, normal, fat
15:38:02 <robdaemon> oh
15:38:02 <lispy> but no more than if you study some other programming language that requires logical though
15:38:04 <ray> this is why edwardk is cool
15:38:06 <eu-prleu-peupeu> so what is a morphism ?
15:38:12 <Botje> robdaemon: but bmi is of type [a]
15:38:13 <sioraiocht> eu-prleu-peupeu: in category theory?
15:38:25 <robdaemon> I was attempting to make bmi = the return value of calcBmi
15:38:37 <Botje> robdaemon: it is. but calcBmi has [a] as return type
15:38:38 <ray> basically just an arrow between two things in a category
15:38:43 <ray> it's vague on purpose
15:38:48 <Botje> and you can't compare numbers and lists
15:38:50 <ray> categories are very general
15:38:57 <Botje> why does calcBmi return a list?
15:38:59 <sioraiocht> eu-prleu-peupeu: a morphism a mapping from one structure to another
15:39:02 <copumpkin> eu-prleu-peupeu: I told you
15:39:08 <purplepenguins> a morphism of sets is a mapping
15:39:12 <sioraiocht> that preserves some relationship(s)
15:39:13 <eu-prleu-peupeu> well, i want to know what is a functor, and someone told me that a functor is a morphism between categories
15:39:15 <purplepenguins> that relates elements to other elements
15:39:27 <copumpkin> eu-prleu-peupeu: do you know what a category is?
15:39:29 <eu-prleu-peupeu> so what is a morphism and what are categories ?
15:39:39 <eu-prleu-peupeu> no
15:39:44 <sioraiocht> eu-prleu-peupeu: you might want to start by reading up on category theory
15:39:48 <kmc> eu-prleu-peupeu, did you check wikipedia
15:39:57 <sjanssen> the GHC 6.12 IO library looks seriously nice, even if it didn't have proper Unicode built in
15:40:00 <sioraiocht> eu-prleu-peupeu: in terms of functors, do youw ant to know the haskell version or the category version?
15:40:12 <ray> the haskell version is just the typeclass Functor
15:40:25 <eu-prleu-peupeu> yes, the <*> and ap
15:40:31 <ray> no, fmap
15:40:32 <purplepenguins> the haskell version of a functor is hard to relate to the category functor if you don't understand the nature of the type system
15:40:38 <sioraiocht> eu-prleu-peupeu: that's applicative functors
15:40:40 <sjanssen> one FAQ for Haskell is an emulated Handle that just reads from a string -- we can now do this
15:40:44 <ray> @src Functor
15:40:44 <lambdabot> class  Functor f  where
15:40:44 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:40:46 <eu-prleu-peupeu> so those are different ? :P
15:40:50 <ray> yeah, they are
15:40:56 <ray> well, one is a superset of the other
15:40:57 <robdaemon> Botje: That's a good question.
15:41:02 <robdaemon> I'll experiment more.
15:41:05 <purplepenguins> a functor is an arrow that is between two categories
15:41:06 <eu-prleu-peupeu> oh
15:41:12 <eu-prleu-peupeu> arrow ?
15:41:21 <eu-prleu-peupeu> and arrow is a pair, right ?
15:41:21 <copumpkin> another word for moprhism
15:41:22 <Botje> if you replace calcBmi with the bmi function you declare in the where on line 3, it'll work
15:41:24 <purplepenguins> an arrow is just a one-directional association in general
15:41:28 <sjanssen> Handles that transparently use epoll while providing the same UI?  No problem!
15:41:34 <purplepenguins> also called a morphism
15:41:34 <Botje> (and remove the [] on line 11, of course)
15:41:41 <eu-prleu-peupeu> the way i see it, arrows are pairs, and functors are containers :P
15:41:51 <purplepenguins> morphisms are different things in different categories
15:41:54 <sioraiocht> eu-prleu-peupeu: a functor is basically a data type, and a function fmap that lets you lift functions to that type
15:42:02 <copumpkin> eu-prleu-peupeu: a minute ago you didn't know what they are, and now you have a way of seeing it?
15:42:06 <purplepenguins> in the category of sets, morphisms are just set mappings
15:42:15 <eu-prleu-peupeu> i dont know what they are
15:42:19 <purplepenguins> in the category of groups, morphisms are homomorphisms
15:42:19 <eu-prleu-peupeu> but i know fmap
15:42:25 <eu-prleu-peupeu> and the first and second and *** functions
15:42:35 <copumpkin> > fmap (+1) (*5) 5
15:42:39 <lambdabot>   26
15:42:39 <eu-prleu-peupeu> homomorphisms is gay morphisms ?
15:42:47 <purplepenguins> ...no
15:42:51 <ray> lol, no
15:42:53 <sioraiocht> eu-prleu-peupeu: are you an idiot?
15:43:04 <purplepenguins> homomorphisms are mappings that preserve algebraic structure
15:43:12 <purplepenguins> basically, if G,H are groups
15:43:38 <purplepenguins> a mapping f : G -> H is a homomorphism if for all a,b in G, f(a)*f(b) = f(a*b)
15:43:46 <eu-prleu-peupeu> ah
15:43:51 <eu-prleu-peupeu> i remember that one from algebra
15:43:59 <eu-prleu-peupeu> i think
15:44:06 <copumpkin> it's a pretty common concept
15:44:42 <eu-prleu-peupeu> ok, so what are functors exactly ? morphisms of categories
15:44:43 <purplepenguins> there is a categorical notion of equivalences and compositions of morphisms
15:44:56 <robdaemon> Ahh, okay...  so I modified calcBmi to not take a list or return a list
15:44:56 <medfly> homo- is a prefix meaning "same"..
15:44:59 <eu-prleu-peupeu> which means, categories = structures, and morphism = functions that changes structores
15:45:01 <purplepenguins> which the former would be equivalent to isomorphisms in the category of groups
15:45:02 <robdaemon> that makes sense
15:45:10 <purplepenguins> and composition usually means function composition
15:45:17 <sioraiocht> eu-prleu-peupeu: they map something an arrow or an object from one category to another
15:45:31 <eu-prleu-peupeu> what is an arrow ?
15:45:35 <eu-prleu-peupeu> -> ?
15:45:35 <copumpkin> ...
15:45:37 <copumpkin> a morphism
15:45:44 <eu-prleu-peupeu> grrrrr
15:45:47 <sioraiocht> sorry, shouldn't have mixed vocab
15:45:52 <copumpkin> we use those interchangeably
15:45:57 <Botje> grin
15:45:57 <copumpkin> (I said so earlier :P)
15:46:00 <robdaemon> Botje: thank you :)
15:46:04 <purplepenguins> an arrow is just a one-directional association of two objects in a category
15:46:09 <Botje> robdaemon: no problem. have fun!
15:46:19 <purplepenguins> a functor would be an arrow in a category where the objects themselves are categories
15:46:25 <eu-prleu-peupeu> then why do arrows work with pairs ?
15:46:35 <eu-prleu-peupeu> and not any king of category holding two objects ?
15:46:40 <copumpkin> eu-prleu-peupeu: don't mix up Control.Arrow with general CT arrows
15:46:42 <robdaemon> I'm learning and enjoying it so far.  It's just a bit of a shift from thinking in Java
15:46:48 <eu-prleu-peupeu> ah ok
15:46:53 <purplepenguins> oh, forgot to mention that morphisms can be between an object and itself
15:47:07 <beutdeuce> It has been a while ;)
15:47:17 <purplepenguins> in sets there always exists some variety of identity morphism for every element
15:47:31 <ray> that's important for haskell functors, because they're really endofunctors on Hask
15:47:32 <eu-prleu-peupeu> ish
15:47:42 <eu-prleu-peupeu> these things are really very bad
15:47:46 <purplepenguins> Hask is the haskell category
15:47:50 <copumpkin> o.O
15:48:00 <jfoutz> copumpkin: you helped me with a phantom type the other day... i ended up not using that, but i learned sooooo much. thank you again.
15:48:09 <eu-prleu-peupeu> i bet the ghc developers dont care about these things
15:48:10 <sioraiocht> purplepenguins: the category of haskell types and haskell functions?
15:48:11 <copumpkin> jfoutz: no problem :)
15:48:16 <purplepenguins> yes
15:48:16 <Cale> It's required of a category that identity morphisms exist.
15:48:19 <copumpkin> eu-prleu-peupeu: how much do you bet?
15:48:24 <Botje> robdaemon: thinking in haskell is much more fun :)
15:48:38 <purplepenguins> depending on how you define categories the identity morphisms might be defined to exist
15:48:41 <ray> wonderful head explosions
15:48:47 <purplepenguins> though you can define a category without objects
15:48:48 <sioraiocht> eu-prleu-peupeu: I'll bet you about 5,000,000 dollars
15:48:49 <eu-prleu-peupeu> they care about hardcore assembly stuff, inlining functions, and keepping everything cache aligned
15:48:50 <robdaemon> Botje: And I haven't written a single "if (a != null) { ... }" yet! :)
15:48:54 <purplepenguins> by denoting an object by its identity morphism
15:48:58 <Botje> grin :)
15:49:01 <copumpkin> eu-prleu-peupeu: not only
15:49:02 <purplepenguins> replacing A with id_A
15:49:17 <purplepenguins> kind of like a pointfree style
15:49:47 <copumpkin> eu-prleu-peupeu: your assumption seems to be that because it sounds mathematical, it could have no "practical value"
15:50:05 <Vanadium> pft, ghc generates C, who cares about hardcore assembly
15:50:07 <eu-prleu-peupeu> copumpkin: isnt it always like that ?
15:50:14 <Cale> Basically, the objects in a category are really only there to remind you which arrows will compose with each other.
15:50:18 <copumpkin> Vanadium: that's getting phased out
15:50:23 <ray> actually it turns out that the more abstract you are, the more practical value you can get with a single theorem
15:50:25 <copumpkin> Vanadium: except as a bootstrapping mechanism
15:50:29 <ray> it's like running in parallel
15:50:43 <Cale> A category with only one object will have that any pair of arrows compose, and the definition reduces to the definition of a monoid.
15:50:50 <sioraiocht> Vanadium: ghc very often generates assembly
15:50:57 <eu-prleu-peupeu> i bet real world haskell doesnt speak about these useless stuff
15:51:05 <badsheepy> p
15:51:09 <badsheepy> uhm,oops
15:51:17 <Vanadium> yes real world haskell does not speak about assembly
15:51:17 <copumpkin> eu-prleu-peupeu: see, you call it useless after about 3 minutes of knowing it
15:51:28 <eu-prleu-peupeu> i dont know it
15:51:31 <idnar> man, I really need to learn category theory
15:51:37 <Cale> A category where there is at most one arrow between any pair of objects will have that the composition is determined entirely by the domain and codomain of the given arrow. Such a category is the same thing as what is called a preorder.
15:52:03 <eu-prleu-peupeu> i haven't understood what are arrows, and functors, and morphins, and categories and... all i wanted to know is what is a functor
15:52:09 <eu-prleu-peupeu> im glad i didn't ask what is a monad :P
15:52:20 <eu-prleu-peupeu> or what is haskell...
15:52:22 <eu-prleu-peupeu> or what is life
15:52:23 <copumpkin> eu-prleu-peupeu: how about "something on which fmap makes sense"?
15:52:31 <Cale> eu-prleu-peupeu: The reason that category theory is useful for programmers to know is that it contains a rich library of abstractions which can be put to use in library design as well as understanding the semantics of programs.
15:52:32 <copumpkin> eu-prleu-peupeu: if you don't care, don't ask :P
15:52:32 <ray> the simplest answer is @src Functor
15:52:38 <sioraiocht> eu-prleu-peupeu: I find that the categorical definition of a monad is unhelpful in understanding their usefulness in haskell
15:53:08 <Cale> eu-prleu-peupeu: Of course, in the end, you can forget that category theory had anything to do with it, but we tend to keep the names around.
15:53:25 <Cale> eu-prleu-peupeu: It's not necessary to know any category theory to understand what a monad is in the context of Haskell.
15:53:37 <eu-prleu-peupeu> ok
15:53:39 * sioraiocht doesn't really know that much about category theory monads
15:53:52 <purplepenguins> it is probably very wise to understand what a monad does, and why its useful, in a programming context, than trying to understand it mathematically
15:54:15 <purplepenguins> a monad is a monoid in the category of endofunctors of a given category
15:54:28 <sioraiocht> purplepenguins: huh, never thought of it that way
15:54:30 <purplepenguins> this is a hard concept to grasp
15:54:33 <copumpkin> lol
15:54:39 <copumpkin> not sure that'll help him ;)
15:54:40 <Cale> It can enrich your sense of what monads are about to understand the more general mathematical definition, but yeah, if you're only interested in programming, there are better things you could spend your time learning.
15:54:43 <Botje> *boom*
15:54:44 <purplepenguins> i'm not really sure i understand it
15:54:44 <kmc> i want a function like zipWith but taking the cartesian product instead of pointwise
15:54:54 <kmc> is that in the standard lib somewhere?
15:54:57 <Botje> kmc: like <*> ?
15:54:57 <purplepenguins> but i'm only halfway through Categories for the Working Mathematician
15:55:00 <copumpkin> http://en.wikipedia.org/wiki/Monoid_(category_theory)
15:55:00 <sioraiocht> kmc: zip?
15:55:02 <sioraiocht> :t zip
15:55:04 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
15:55:04 <Cale> I understand it, it's actually not that bad, but you should work up to it.
15:55:20 <kmc> is pointwise
15:55:21 <sioraiocht> kmc: oh sorry, you said cartesian product, my mistake
15:55:23 <purplepenguins> it's probably the most difficult textbook I've ever tried to read
15:55:29 <sioraiocht> kmc: yeah, ignore me, it's late
15:55:33 <ray> we need categories for the working haskeller
15:55:35 <copumpkin> purplepenguins: you should try awodey
15:55:42 <Botje> > (+) <$> [1,2] <*> [10,20]
15:55:44 <purplepenguins> i've been told awodey is better
15:55:45 <benmachine> > (+) <$> [a,b] <*> [c,d]
15:55:45 <lambdabot>   [11,21,12,22]
15:55:48 <lambdabot>   [a + c,a + d,b + c,b + d]
15:55:50 <sioraiocht> ray: algebra of programming is a pretty good book
15:55:52 <Cale> Start by understanding what a monoidal category is, and then what a monoid object in a monoidal category is, and then look at how the endofunctors on a category form a monoidal category.
15:55:54 <Botje> kmc: ^^
15:55:57 <copumpkin> purplepenguins: it comes with the Cale (R) stamp of approval
15:56:07 <Cale> Yeah, I love Awodey's book.
15:56:20 <kmc> thanks
15:56:32 <purplepenguins> i don't have it in ebook form though
15:56:38 <Cale> purplepenguins: Would you like it?
15:56:43 <eu-prleu-peupeu> is there any good refence i could read up on this ?
15:56:47 <Botje> kmc: or you can say liftM2 (+) [1,2] [10,20]
15:56:53 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
15:57:11 <copumpkin> eu-prleu-peupeu: ^^
15:57:21 <Crusty84> Can anybody tell me what the exclamation mark is doing over here: Object  !(Ptr a)
15:57:24 <jfoutz> yoink.
15:57:27 <ray> if you just want haskell-relevant stuf you can read the typeclassopedia
15:57:33 <Cale> Crusty84: Is that in a data declaration?
15:57:37 <Botje> Crusty84: strictness
15:57:37 <Crusty84> yes it is
15:57:38 <kmc> Crusty84, it's a strict field probably
15:57:41 <sioraiocht> Crusty84: it makes the field strict
15:57:43 <copumpkin> Crusty84: making it stricter than a dominatrix in a dark dungeon
15:57:57 <Crusty84> haha @ copumpkin
15:57:57 <ray> @quote quadraphonic
15:57:58 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
15:58:07 <Cale> Crusty84: It means that when a value of type Object is pattern matched against, the Ptr a value will be evaluated prior to the matching.
15:58:16 <purplepenguins> Cale: thanks bunches
15:58:45 <ray> cale's bandwidth must be gone by now
15:59:24 <purplepenguins> getting 5 kibbies
15:59:32 <Cale> I'm sending at around 134 KB/s total.
15:59:34 <purplepenguins> it'll take a little bit but i can wait
15:59:38 <Botje> grin :)
15:59:43 <purplepenguins> oh, jumped up a bit
15:59:47 <purplepenguins> and down
15:59:52 <purplepenguins> my internet is not great
15:59:59 <Crusty84> Is it then logical to say Object ! (SomeContainerType a) where the containertype just contains an integer?
16:00:22 <Phyx-> @pl \a -> [head a]
16:00:22 <lambdabot> return . head
16:00:31 <Phyx-> course
16:00:36 <Cale> Crusty84: You can do that, but unless the container type is itself strict, that won't necessarily force the integer itself to be evaluated
16:00:44 <Cale> and now everyone seems to be done? :)
16:00:51 <Phyx-> @pl (\x->show (length x) ++ [head x])
16:00:52 <lambdabot> ap ((++) . show . length) (return . head)
16:00:53 * ray is :)
16:01:21 <purplepenguins> so a monad is an endofunctor on Hask?
16:01:23 <copumpkin> Phyx-: still playing with show and tell?
16:01:27 <Cale> purplepenguins: Right.
16:01:27 <Botje> .. high on category theory?
16:01:33 <purplepenguins> err, a monoid of endofunctors on Hask
16:01:42 <Cale> purplepenguins: No, just one :)
16:01:44 <copumpkin> purplepenguins: it's also just a functor
16:01:50 <Phyx-> copumpkin: yeah, don't really have anything better to do at 1am
16:01:52 <Cale> Well... a monoid object in the category of endofunctors
16:02:01 <purplepenguins> yes
16:02:08 <purplepenguins> for a given category of course
16:02:15 <Cale> So it's one endofunctor which has some particular natural transformations
16:02:20 <purplepenguins> but in haskell's case, it's endofuntors on Hask
16:02:37 <Cale> Specifically, it has a natural transformation 1 -> M which is the "identity element"
16:02:55 <purplepenguins> okay
16:02:55 <Cale> and M * M -> M which is the "multiplication", and * in this case is composition
16:03:03 <purplepenguins> 1 is the identity endofunctor?
16:03:05 <Cale> yeah
16:03:10 <purplepenguins> ah
16:03:22 <Cale> So in Haskell, the type of that natural transformation is a -> M a
16:03:33 <Cale> so you can probably guess what the 'identity' becomes :)
16:03:39 <purplepenguins> when you start throwing types into the mix i get really confused
16:04:00 <Cale> In Set, 1 is (any) one element set, and M is the monoid, and the operation * is Cartesian product
16:04:14 <Cale> and these become the data for a monoid
16:04:29 <Cale> With the function 1 -> M picking out the identity element of the monoid M
16:04:37 <purplepenguins> in Monad, the exquivalent of 1 -> M is return right?
16:04:41 <Cale> (a function 1 -> M is the same thing as an element of M)
16:04:45 <Cale> yeah
16:05:05 <purplepenguins> but how does >>= relate to the monoidal operation
16:05:14 <Cale> Well, first look at M^2 -> M
16:05:22 <Cale> which is,  M (M a) -> M a
16:05:29 <Cale> :t join
16:05:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:05:35 <purplepenguins> ah
16:05:54 <purplepenguins> so return/join make Monad into a Monoid
16:05:57 <Cale> and along with the required function on arrows in order to be a functor in the first place
16:05:58 <Cale> :t fmap
16:06:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:06:07 <purplepenguins> ah
16:06:13 <Cale> We can define  x >>= f = join (fmap f x)
16:06:15 <mauke> :t (join .) . fmap
16:06:18 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
16:06:30 <purplepenguins> so a Functor is an endofunctor and Monad is an endofunctor with monoidal bits
16:06:37 <Phyx-> gn all
16:06:39 <purplepenguins> ?
16:06:44 <copumpkin> is there not a scanl' ?
16:06:49 <Cale> purplepenguins: Yeah, better to say a monoid *object* so it's clear that you don't just mean a monoid in Set.
16:06:56 <Cale> (or in Hask)
16:07:01 <purplepenguins> yes
16:07:03 <unexpected1> I am trying to get a Haskell program running. I have installed hugs on my system (ubuntu), but i am not able to run the code. The program is not mine. So, well, it's not really glorious, but is someone willing to help me decipher the error message(s)?
16:07:04 <Cale> purplepenguins: yeah
16:07:10 <purplepenguins> but there are a lot of different monoids
16:07:21 <purplepenguins> there is a monoid object in Set, there is the category Monoid
16:07:42 <mauke> unexpected1: what's the first error?
16:07:45 <ray> there is the typeclass Monoid
16:08:03 <Cale> Yeah, there's a definition of what a monoid means for each category which has a monoidal operation on its objects (typically Cartesian product in Set, (,) in Hask, and composition in the category of endofunctors)
16:08:11 <purplepenguins> monoids don't depend so much on what objects are involved as much as how they behave, namely having something like an identity and a closed binary object
16:08:13 <Makoryu> unexpected1: Hugs is a bit obsolete... I think the last release was 8 years ago. If your program uses any GHC extensions, or imports any libraries that Hugs doesn't support, it won't work in Hugs
16:08:22 <purplepenguins> which would correspond to the original monoid as a set
16:08:35 <copumpkin> Makoryu: it was just 3 years ago I think :P
16:08:36 <Cale> and then for a given type of monoids in a category we can talk about those as being a category and morphisms between monoid objects.
16:08:37 <purplepenguins> err, closed binary operation
16:09:15 <Cale> Hugs isn't totally obsolete, but if you want to do real programming, you need GHC.
16:09:19 <Makoryu> copumpkin: Was it? See, I just don't know these things :p
16:10:09 <purplepenguins> a one-object category is a monoid, with the identity morphism the identity and composition as the binary operation
16:10:12 <unexpected1> mauke: ok, the first message ist "Can't find imported module "Interact"".
16:10:34 <Cale> purplepenguins: Right, that definition is equivalent to the definition of a normal monoid in Set.
16:10:50 <purplepenguins> yes
16:10:50 <Cale> (if you restrict the number of morphisms in the category just to be a set)
16:10:57 <mauke> unexpected1: ok, did you install that module?
16:11:38 <unexpected1> i found in a oldlib directory. so i added this folder to the lib search path
16:11:43 <RayNbow> mauke: I noticed you improved the #1 Haskell find-cycle code golfing solution :)
16:11:51 <mauke> yes :-)
16:12:14 <purplepenguins> i started trying to learn category theory again after reading john baez's article on n-Category cafe about n-categories
16:12:31 <unexpected1> so, i guess that works. now i get "Unknown primitive reference "primShowIOError""
16:13:03 <beutdeuce> How would I be able to read a file line by line into a list of strings, each string being a line?
16:13:16 <orgthingy> Cale: \o/
16:13:19 <Cale> In a somewhat circular way, we can recognise what a monoid object in the category of categories is, and it turns out to be a (strict) monoidal category.
16:13:25 <mauke> fmap lines (readFile "x")
16:13:50 <purplepenguins> hmm
16:14:05 <unexpected1> (actually my question is: is this a real program error or is there a problem with my hugs installation (a library not found, etc)?
16:14:06 <purplepenguins> how is that?
16:14:28 <Cale> Well, have you already looked at the definition of a monoidal category?
16:15:22 <purplepenguins> isn't that what we just talked about?
16:15:29 <Cale> A (strict) monoidal category is a category which has a specified bifunctor, which I'll call *: C x C -> C, and an object I called the unit object or identity object
16:15:37 <purplepenguins> ah
16:15:46 <Cale> such that * is associative, and I is the identity for it
16:15:54 <purplepenguins> what is the unit category in a monoidal category
16:16:20 <Cale> In the monoidal category of categories?
16:16:32 <purplepenguins> yes
16:16:38 <Cale> It's just the category with one object and the one identity morphism
16:16:43 <purplepenguins> okay
16:16:57 <beutdeuce> mauke: ty
16:17:41 <purplepenguins> so the bifunctor multiplication (*), would take C * I = I * C = C for any category C in the monoid?
16:17:57 <Cale> in the category Cat
16:18:00 <c_wraith> That's commutativity, not associativity
16:18:06 <purplepenguins> okay
16:18:11 <Cale> c_wraith: It's neither, it's the identity law
16:18:19 <c_wraith> Oh, it is the identify
16:18:22 <c_wraith> rr.  identity
16:18:29 * c_wraith has been playing too much nethack
16:18:34 <Cale> hehe :)
16:18:53 <purplepenguins> there is no such thign as too much nethack
16:19:16 <Cale> Note that we're sort of ignoring the fact that these are actually a bit different and they're really only the same up to natural isomorphism
16:19:53 <Cale> There are some additional annoying details to handle that, but you can read the wikipedia page to see about them. They're not all that important for our level of detail here.
16:19:55 <purplepenguins> yes
16:21:17 <purplepenguins> it appears that i have awodey now
16:21:28 <Cale> In the category of categories, we take the monoidal operation to be the product of categories, and the identity to be that one-object one-arrow category
16:21:48 <Cale> and then we can ask what a monoid object in Cat is
16:21:49 <purplepenguins> i'm liking the first paragraph of the preface "category theory for the rest of us"
16:22:08 <Cale> yeah, it's written not to have many prerequisites, which makes it good for CS people :)
16:22:46 <purplepenguins> i have the prerequisites for Mac Lane but not the patience
16:23:05 <Cale> A monoid object in Cat will be a category C together with an arrow (functor) 1 -> C for the identity
16:23:18 <Cale> An arrow 1 -> C really just picks an object of C
16:23:38 <purplepenguins> yeah
16:23:45 <Cale> and then a functor C x C -> C for the multiplication
16:24:22 <Cale> and it's supposed to be associative and have that object picked by 1 -> C as an identity
16:24:44 <Cale> and so it turns into the very definition of a (strict) monoidal category
16:24:56 <copumpkin> does the --constraint flag do anything to GHC?
16:25:03 <purplepenguins> ah, i see
16:25:25 <c_wraith> > mempty::Int
16:25:28 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
16:25:29 <lambdabot>    arising from a use of...
16:25:34 <copumpkin> > mempty :: Sum Int
16:25:38 <lambdabot>   Sum {getSum = 0}
16:25:53 <c_wraith> Not surprising that there's no instance for Int
16:26:04 <c_wraith> As there are at least two possible instances that make sense.
16:26:04 <copumpkin> > mempty :: Product Int
16:26:08 <lambdabot>   Product {getProduct = 1}
16:26:16 <c_wraith> Yes, those two. :)
16:27:05 <dolio> There are more, strictly speaking.
16:27:22 <copumpkin> (1, lcm)
16:27:26 <purplepenguins> because Z is a monoid under both addition and multiplication
16:27:32 <purplepenguins> and probably many more
16:27:51 <c_wraith> I did say "at least", as I figured there were many other ways to make it work.
16:27:55 <dolio> (min, 2^32-1) (max, -2^32) (if you're on a 32-bit machine)
16:28:10 <purplepenguins> being a ring guarantees that it'll be a monoid under two different operations
16:28:20 <purplepenguins> well, technically ring with unit
16:28:34 <purplepenguins> but i can't think of any rings without unit myself
16:28:51 <copumpkin> you can make N into a distributive lattice with lcm and gcd too
16:29:18 <purplepenguins> which one is a lattice
16:29:44 <c_wraith> as I understand it, an n-dimensional grid.
16:30:00 <c_wraith> My understanding is probably somewhat incomplete
16:30:16 <copumpkin> you can just see it like another algebraic structure
16:30:38 <purplepenguins> ah, it's a poset with joins and meets
16:30:41 <c_wraith> Hmm.  each prime would be an axis in that structure, wouldn't it?
16:30:44 <copumpkin> you have two semilattices and absorbtion between them
16:31:37 <kmc> @pl \f xs map (map f) xs
16:31:37 <lambdabot> (line 1, column 16):
16:31:37 <lambdabot> unexpected "f"
16:31:37 <lambdabot> expecting operator or ")"
16:31:41 <kmc> @pl \f xs -> map (map f) xs
16:31:41 <lambdabot> map . map
16:32:00 <purplepenguins> basically, a set with two binary operations that satisfy commutativity, associativity and these absorbtion laws
16:32:39 <copumpkin> and idempotency
16:32:48 <purplepenguins> idempotency, yes
16:32:56 <purplepenguins> though it's derivable from the other ones
16:33:13 <c_wraith> :t let s = foldr (+) in s . fmap s
16:33:13 <copumpkin> I guess from the absorbtion
16:33:14 <lambdabot> forall a (f :: * -> *). (Num (f ([a] -> a)), Num a, Functor f) => f a -> [f ([a] -> a)] -> f ([a] -> a)
16:33:46 <purplepenguins> Z is a lattice under lcm and gcd
16:34:02 <lilac> @hoogle (a -> m b) -> (c -> m d) -> (a, b) -> (m c, m d)
16:34:02 <lambdabot> No results found
16:34:18 <lilac> @type \f g -> f *** g
16:34:20 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:34:30 <lilac> @hoogle (a -> m b) -> (c -> m d) -> (a, b) -> m (c, d)
16:34:31 <lambdabot> No results found
16:34:33 <lilac> :(
16:35:38 <copumpkin> :t \f g (x, y) -> liftM2 (,) (f x) (g y)
16:35:40 <lambdabot> forall t t1 a1 a2 (m :: * -> *). (Monad m) => (t -> m a1) -> (t1 -> m a2) -> (t, t1) -> m (a1, a2)
16:35:59 <copumpkin> @pl \f g (x, y) -> liftM2 (,) (f x) (g y)
16:36:00 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . liftM2 (,)) .)
16:36:02 <copumpkin> :P
16:36:23 <lilac> lovely :)
16:36:25 <copumpkin> :t \f g -> uncurry (liftM2 (,)) (f *** g)
16:36:27 <lambdabot>     No instance for (Arrow (,))
16:36:27 <lambdabot>       arising from a use of `***' at <interactive>:1:30-36
16:36:27 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
16:36:30 <copumpkin> :t \f g -> uncurry (liftM2 (,)) . (f *** g)
16:36:32 <lambdabot> forall a1 a2 (m :: * -> *) b b'. (Monad m) => (b -> m a1) -> (b' -> m a2) -> (b, b') -> m (a1, a2)
16:36:51 <purplepenguins> sometimes pointless style is a bit less clear
16:36:52 <copumpkin> :t (uncurry (liftM2 (,)) .) . (***)
16:36:54 <lambdabot>     No instance for (Arrow (,))
16:36:54 <lambdabot>       arising from a use of `***' at <interactive>:1:27-31
16:36:54 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
16:36:58 <copumpkin> damn :P
16:37:14 <copumpkin> :t ((uncurry (liftM2 (,)) .) .) . (***)
16:37:16 <lambdabot> forall a1 a2 (m :: * -> *) b b'. (Monad m) => (b -> m a1) -> (b' -> m a2) -> (b, b') -> m (a1, a2)
16:37:21 <copumpkin> how's that for clarity ;)
16:39:07 <lilac> yummy.
16:39:31 <lilac> i'm going with 'fmapPairM f g (a,b) = liftM2 (,) (f a) (g b)' though.
16:40:22 <copumpkin> bimapM :o
16:40:29 <copumpkin> @hoogle bimap
16:40:30 <lambdabot> package bimap
16:40:33 <copumpkin> meh
16:41:39 <benmachine> lilac: isn't that what the Kleisli Arrow instance is for?
16:42:03 <kmc> > let m = 140; d = 0.04; f c = null $ dropWhile ((<= 2) . magnitude) $ take m $ iterate (\z -> z^2 + c) 0 in (d^2) * genericLength (filter f (map (:+) [-2,-2+d..1-d] <*> [-1,-1+d..1-d]))
16:42:08 <benmachine> although, your thing would probably end up being shorter in any case
16:42:22 <lambdabot>   1.5328000000000002
16:42:39 <benmachine> :t \f g -> runKleisli $ Kleisli f *** Kleisli g
16:42:41 <lambdabot> forall (m :: * -> *) b c b' c'. (Monad m) => (b -> m c) -> (b' -> m c') -> (b, b') -> m (c, c')
16:43:34 <benmachine> newtype wrappers make everything twice as verbose
16:43:59 * jfoutz boggles
16:44:19 <copumpkin> @type (runKleisli .) . ((***) `on` Kleisli)
16:44:21 <lambdabot> forall b c (m :: * -> *). (Monad m) => (b -> m c) -> (b -> m c) -> (b, b) -> m (c, c)
16:44:25 <copumpkin> that's cuter
16:44:33 <copumpkin> oh but it forces them to be the same type
16:44:33 <purplepenguins> what is this Kleisli?
16:45:08 <benmachine> purplepenguins: newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}
16:45:13 <benmachine> in Control.Arrow
16:45:34 <benmachine> it exists for the purposes of
16:45:35 <benmachine> instance (Monad m) => Arrow (Kleisli m)
16:45:37 <benmachine> and friends
16:45:45 <copumpkin> purplepenguins: basically a way for them to use their composition operator as <=<
16:45:58 <benmachine> oh yeah
16:46:15 <benmachine> :t \f g -> runKleisli $ Kleisli f . Kleisli g
16:46:17 <lambdabot>     Couldn't match expected type `b -> c'
16:46:17 <lambdabot>            against inferred type `Kleisli m a b1'
16:46:17 <lambdabot>     In the first argument of `(.)', namely `Kleisli f'
16:46:22 <benmachine> wups
16:46:50 <copumpkin> <<<
16:46:52 <benmachine> :t \f g -> runKleisli $ Kleisli f Control.Arrow.. Kleisli g
16:46:54 <lambdabot> Not in scope: `Control.Arrow..'
16:46:57 <benmachine> :(
16:47:03 <benmachine> :t \f g -> runKleisli $ Kleisli f Control.Category.. Kleisli g
16:47:05 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => (b1 -> m b) -> (a -> m b1) -> a -> m b
16:47:07 <benmachine> woo
16:47:12 <copumpkin> lol
16:47:34 <purplepenguins> hmm
16:47:58 <purplepenguins> doesn't mean anything to me, but understanding arrows would help
16:48:08 <copumpkin> it's the same type signature as <=<
16:48:12 <benmachine> I didn't know about arrows until basically this morning and now I do
16:48:13 <benmachine> err
16:48:14 <benmachine> well
16:48:20 <benmachine> I still don't really know what they are *for*
16:48:32 <CalJohn> @hoogle until
16:48:32 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
16:48:34 <benmachine> but I know what the relevant classes/instances/types are
16:48:34 <copumpkin> for mindblowing functions like loop
16:49:03 <benmachine> I think I saw loop and thought that is clever and then forgot it
16:49:15 <copumpkin> :t loop
16:49:17 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
16:49:41 <purplepenguins> @src loop
16:49:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:49:45 <copumpkin> it's a method
16:49:54 <purplepenguins> oh, how unlucky
16:49:56 <jfoutz> could you use it in a sentence?
16:50:13 <copumpkin> I have yet to do anything non-contrived with it
16:50:35 <CalJohn> @hoogle untilM
16:50:35 <lambdabot> No results found
16:51:23 <jfoutz> oh. wow.
16:51:25 <jfoutz> instance ArrowLoop (->) where loop f b = let (c,d) = f (b,d) in c
16:51:41 <copumpkin> it's like a fix
16:51:46 <copumpkin> but a little more confusing
16:51:58 <benmachine> because we decided that fix wasn't confusing enough
16:52:01 <jfoutz> yeah. cause there's this extra thing.
16:52:04 <benmachine> > fix f
16:52:05 <copumpkin> it's perfect for blowing newbies' minds
16:52:07 <lambdabot>   Add a type signature
16:52:11 <benmachine> > fix f :: Expr
16:52:17 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
16:52:21 <benmachine> heeehee
16:52:31 <copumpkin> > loop (f *** g) :: Expr
16:52:35 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
16:52:39 <copumpkin> aw
16:52:39 <purplepenguins> i'm still trying to understand data Mu f = In (f (Mu f))
16:52:48 <copumpkin> purplepenguins: that's basically fix for types
16:53:52 <purplepenguins> yes, i can imagine what it would do, but i can't imagine how you'd use something like that
16:54:02 <purplepenguins> :t fix
16:54:04 <lambdabot> forall a. (a -> a) -> a
16:54:15 <copumpkin> purplepenguins: for making infinite types!
16:54:23 <purplepenguins> maybe
16:54:24 <Berengal> purplepenguins, you get peano numbers from Mu Maybe
16:54:33 <benmachine> > let x = [x] in x
16:54:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
16:54:53 <copumpkin> type Stream a = Mu ((,) a)
16:55:06 <purplepenguins> :t (,)
16:55:08 <lambdabot> forall a b. a -> b -> (a, b)
16:55:12 <copumpkin> :k (,)
16:55:14 <lambdabot> * -> * -> *
16:55:17 <purplepenguins> ah, just the cartesian product
16:55:25 <copumpkin> yep
16:55:47 <copumpkin> it's essentially giving you a (a, (a, (a, (a, (a, (a, ...
16:55:54 <purplepenguins> > fix (,)
16:55:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> (a, b)
16:56:06 <dm3> What's the best way to execute a list of IO operations until one succeeds.  Something like MonadPlus, only where mzero is allowed to have side effects, so that "mzero `mplus` x" isn't exactly identical to x.
16:56:33 <Berengal> dm3, how do you know if a computation succeeds without running it?
16:56:59 <dm3> No, I want to run them.  Like I have a list of files to try opening, and I want to return a handle for the first file that exists.
16:57:02 <kmc> dm3, does IO's mplus not already do that?
16:57:13 <copumpkin> IO is a MonadPlus?
16:57:15 <dm3> Is there an IO mplus?  Where is it defined?
16:57:17 <kmc> i guess not
16:57:23 <kmc> but, if it were it'd have that, no?
16:57:38 <benmachine> if it were it wouldn't obey the laws
16:57:41 <benmachine> I think
16:57:44 <dm3> Yes, a sort of cheating IO mplus would be perfect.
16:57:44 <sjanssen> dm3: I'd probably use Control.Exception.Catch
16:58:00 <Berengal> benmachine, which laws? The MonadPlus laws aren't entirely agreed upon
16:58:25 <sjanssen> or onException if you don't need the result of the computation
16:58:33 <benmachine> Berengal: technicality >_>
16:58:40 <dm3> So hoogle claims there's no "MonadPlus IO" instance, at least here:  http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#t%3AMonadPlus
16:59:46 <dm3> sjanssen:  catch you mean to throw success as well as failure?
17:00:26 <dm3> I mean I can obviously do this with a tail-recursive loop and a bunch of checking, it just feels weird because I've been able to do similar things so much more simply using msum or <|> or whatever.
17:00:50 <Berengal> instance MonadPlus IO where mempty = throw Something; mplus mx my = mx `catch` const my
17:01:15 <sjanssen> dm3: no, I mean you catch failing computations and execute the next one
17:02:24 * benmachine would just be boring and do thing [] = error "everything failed"; thing (x:xs) = if fails x then thing xs else hooray
17:04:44 <dm3> benmachine: Yeah, that's what I will do.  I vaguely recall reading in some documentation that there is some instance of something for the IO monad that doesn't obay the laws and sort of did what I wanted, but that's obviously very vague and I can't figure out what it was I read.
17:04:52 <sjanssen> orElse x y = catch x (\(e :: SomeException) -> unblock y)
17:05:10 <sjanssen> foldr orElse (fail "nothing works")
17:05:37 <dm3> sjanssen:  Actually, I like that.
17:06:23 <dm3> unblock because a catch handler is implicitly blocked?
17:06:38 <sjanssen> I think it might be, don't remember off the top of my head
17:09:50 <Berengal> They do
17:10:14 <Berengal> Prelude Control.Exception> throw NonTermination `Control.Exception.catch` (\(e::SomeException) -> blocked)
17:10:14 <Berengal> True
17:19:25 <dm3> sjanssen's idea seems to work, though there's probably some way to make it even shorter.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9197
17:19:37 <JoshRosen> I'm trying to write a program to play a card game and the State monad seems to be a natural fit for some parts of the code (e.g. playing cards and updating the internal game state to reflect the play).
17:19:44 <JoshRosen> But one aspect of the State monad is confusing me.
17:19:53 <JoshRosen> How does runState work?
17:20:08 <c_wraith> :t runState
17:20:09 <dm3> You give it the monad and the initial state.
17:20:09 <lambdabot> forall s a. State s a -> s -> (a, s)
17:20:26 <c_wraith> It returns a pair of "calculated value, finish state"
17:20:28 <dm3> It returns the result of your computation, and whatever state the computation left the monad in.
17:20:29 <JoshRosen> Well, yeah, I understand how it's used.
17:20:43 <JoshRosen> But I don't understand how it's implemented.
17:20:54 <Berengal> @src runState
17:20:54 <lambdabot> Source not found.
17:20:55 <dm3> It's just an accessor method.
17:20:58 <Berengal> @src State
17:20:59 <lambdabot> Source not found. Where did you learn to type?
17:21:02 <JoshRosen> runState doesn't appear to be a function.
17:21:02 <JoshRosen> Right.
17:21:02 <Berengal> Hmm
17:21:07 <dm3> It just returns an element of the StateT structure.
17:21:21 <Berengal> State s a = State {runState :: s -> (a, s)}
17:21:25 <dm3> Like saying:  data Foo = Foo { blah :: Int }
17:21:43 <dm3> Now I can say: blah (foo::Foo)
17:21:47 <dm3> and I get back the int.
17:22:11 <JoshRosen> Yeah, I get accessor methods.  Where does the data that runState accesses get put into the StateT structure>
17:22:26 <dm3> The StateT structure doesn't contain any data.
17:22:50 <dm3> It only contains computations that, given state, somehow access and/or modify the state to produce a result.
17:23:03 <dm3> Think of it analogously to the IO monad.
17:23:14 <dm3> getChar doesn't include the state of the stdin file buffer.
17:23:33 <dm3> It just does something to that buffer when you execute getChar by binding it to some action that is hooked into main.
17:24:25 <JoshRosen> So a thing of type State is a thing that doesn't something to a state when given a state.
17:24:29 <JoshRosen> A function from States to States?
17:24:45 <dm3> Exactly, and that also produces a result.
17:25:25 <dm3> So when you hook a bunch of actions together that are in the state monad with a >> b >> c >> d >> e, you are just threading the state through a bunch of functions.
17:25:48 <dm3> But you need a start state, which is why runstate takes two arguments:  the thing to execute, and the initial state.
17:27:17 <JoshRosen> So, when I write "runState myStateFunction initialState", the "runState myStateFunction" part returns a function of type s -> (a, s) that was part of myStateFunction?
17:27:26 <JoshRosen> And then initialState is an argument to that function?
17:27:40 <dm3> Yup.
17:28:33 <kmc> how strict are strict fields? if my datatype has a field of type !String, is every element in the list WHNF, or just the head?
17:28:46 <dm3> runState really doesn't do anything, except unpack the data structure and give you a function that was in there.  Fundamentally, a (State Int) is a function that takes a state and returns the state, result pair.
17:28:54 <Vanadium> WHNF for lists means just the head, as far as I know
17:29:07 <Vanadium> > head $! [1..]
17:29:10 <lambdabot>   1
17:29:19 <dm3> There's no way to force deep evaluation of data structures.
17:29:22 <kmc> Vanadium, but is the meaning of a '!' field that it's orced to WHNF
17:29:26 <kmc> dm3, isn't there a typeclass
17:29:27 <kmc> NFData?
17:29:28 <dm3> But there's a library that can do it for particular ones.
17:29:49 <Vanadium> kmc: As far as I can tell, it is
17:29:59 <kmc> okay, that makes sense
17:30:32 <Vanadium> I mean, otherwise the NFData guys would just implement rnf in terms of strict fields
17:31:11 <Stefa2> hi, (undefined, undefined) is something else than undefined, right?
17:31:20 <dm3> Correct.
17:31:25 <dm3> > (undefined, undefined)
17:31:27 <tromp> quite different
17:31:28 <lambdabot>   (* Exception: Prelude.undefined
17:31:36 <kmc> > case undefined of (_,_) -> 3
17:31:39 <dm3> Notice it printed "(" before the exception.
17:31:40 <lambdabot>   * Exception: Prelude.undefined
17:31:42 <Stefa2> so, if I have a function fst and want to know if it's strict ...
17:31:43 <kmc> > case (undefined, undefined) of (_,_) -> 3
17:31:46 <lambdabot>   3
17:32:13 <Stefa2> do I have to test if fst undefined reduces to undefined
17:32:33 <Stefa2> or do I have to test if fst (test, undefined) reduces to undefined?
17:32:51 <Berengal> Strictness is defined as f _|_ = _|_
17:33:06 <Stefa2> so fst is strict?
17:33:14 <Berengal> Yes
17:33:25 <kmc> @src fst
17:33:25 <lambdabot> fst (x,_) =  x
17:33:25 <Stefa2> ty
17:33:31 <Berengal> It's also strict in the first element of the pair
17:33:35 <Berengal> Not just the pair itself
17:33:46 <Berengal> fst (_|_, _) = _|_
17:34:02 <kmc> > fst (3, undefined)
17:34:04 <Stefa2> ok, but that's not required for strictness, right?
17:34:06 <lambdabot>   3
17:34:17 <Stefa2> I'm so picky because of a test :)
17:34:29 <Berengal> No, strictness just means that undefined input yields undefined output
17:34:29 <kmc> > head [3, undefined]
17:34:33 <lambdabot>   3
17:34:58 <Stefa2> but a tuple with undefined content doesn't matter, because it's a tuple
17:35:25 <Berengal> It's still a tuple, even if the contents are undefined
17:35:50 <kmc> is it correct to say that _|_ is neither WHNF nor reducible to WHNF?
17:36:21 <Stefa2> whnf?
17:36:31 <kmc> or can we not talk about _|_ as a \-expression, but only actual \-expressions that may be divergent
17:36:39 <kmc> Stefa2, weak head normal form
17:36:50 <kmc> meaning, the outermost thing is something other than an application
17:37:05 <dm3> Someone just pointed me to this page, which was pretty useful on whnf:  http://haskell.org/haskellwiki/Stack_overflow
17:37:42 <Berengal> kmc, or the application of a constructor
17:37:47 <kmc> \x -> ((\y -> y) x) is WHNF but not HNF.  it reduces to \x -> x but that reduction is not applying to the outside
17:37:53 <Stefa2> but Berengal, than I have another -personal, logical- problem
17:38:04 <kmc> Berengal, sorry, i was thinking of ctor apps as different from function apps
17:38:06 <kmc> too much STG machine
17:38:22 <Stefa2> if fst is strict, because ( undefined, ... ) is not the same as undefined
17:38:22 * Berengal lives in a LC world
17:38:34 <kmc> that's not why fst is strict
17:38:43 <Berengal> Stefa2, fst is strict because fst _|_ = _|_
17:38:51 <Stefa2> yes
17:38:54 <Stefa2> if I curry it, it won't be strict afterwards
17:39:15 <Stefa2> because than, I could write fst a undefined = a
17:39:16 <dm3> But curry is strict.
17:39:18 <kmc> > curry fst 3 undefined
17:39:21 <lambdabot>   3
17:39:56 <dm3> oh, sorry, I guess I meant uncurry is strict.
17:40:08 <Berengal> Stefa2, technically, it won't be strict if you curry it, but it'll be strict in its first argument.
17:40:10 <kmc> > curry fst undefined 3
17:40:13 <lambdabot>   * Exception: Prelude.undefined
17:40:21 <kmc> Berengal, i don't think so
17:40:22 <dm3> curry produces something defined
17:40:23 <Stefa2> Berengal: exactly
17:40:25 <kmc> > case curry fst undefined 3 of _ -> 3
17:40:29 <lambdabot>   3
17:40:40 <Stefa2> so curring can change strictness?
17:40:40 <kmc> id is not strict
17:40:48 <Berengal> kmc, yes it is
17:40:58 <kmc> hmm
17:41:00 <kmc> okay, it is
17:41:03 <Berengal> id _|_ = _|_
17:41:08 <Berengal> That much should be plain :P
17:41:16 <kmc> but, id does not cause evaluation to occur, ever
17:41:21 <kmc> so i guess these concepts are distinct
17:41:25 <lispy> > take 1 $ id [1..]
17:41:29 <lambdabot>   [1]
17:41:39 <lispy> Berengal: so, I don't think id is strict
17:41:46 <Stefa2> > take 1 $! id [1..]
17:41:50 <lambdabot>   [1]
17:41:54 <Berengal> lispy, [1..] /= _|_
17:41:57 <kmc> fst is strict, and an application (fst x) must evaluate x to whnf.  id is strict, but an application (id x) never evaluates x to whnf
17:42:00 <kmc> is that fair to say?
17:42:01 <Berengal> take 1 $ id undefined
17:42:09 <Berengal> > take 1 $ id undefined
17:42:12 <lambdabot>   * Exception: Prelude.undefined
17:42:15 <lispy> > const 1 $ id undefined
17:42:18 <lambdabot>   1
17:43:02 <Berengal> lispy, const is entirely unstrict about it's second argument
17:43:22 <lispy> Well, how can we test the strictness of id then?
17:43:30 <dolio> id _|_ = _|_
17:43:35 <lispy> lambdabot is in a read eval print loop
17:43:37 <dolio> That is the definition of strictness.
17:43:48 <kmc> lispy, seq?
17:43:50 <dm3> > const 1 $ head undefined
17:43:51 <lispy> So if we print id foo, we demand foo
17:43:54 <lambdabot>   1
17:43:57 <kmc> > (id undefined) `seq` 3
17:44:00 <lambdabot>   * Exception: Prelude.undefined
17:44:36 <lispy> Okay, I guess that makes sense to me then
17:44:39 <kmc> in STG, forcing only occurs by a case expression, and fst would have a case expression but not id
17:44:53 <Berengal> strictness doesn't mean evaluation
17:45:01 <Berengal> It means evaluation only if the result is required
17:45:14 <lispy> okay, makes sense
17:45:23 <Berengal> > length [undefined `seq` 1, 2, 3, undefined]
17:45:26 <lambdabot>   4
17:45:43 <dolio> If anything demands the result of id, then it demands the argument of id, because they're the same thing.
17:46:50 <Makoryu> > length . take 20 $ cycle undefined
17:46:53 <lambdabot>   * Exception: Prelude.undefined
17:46:59 <Makoryu> > length . take 20 $ repeat undefined
17:47:02 <lambdabot>   20
17:47:26 <lispy> > length $ replicate 10 undefined
17:47:30 <lambdabot>   10
17:47:57 <lispy> > fix undefined
17:48:01 <lambdabot>   * Exception: Prelude.undefined
17:48:25 <Berengal> > fix error
17:48:29 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
17:49:04 <Berengal> I wonder about the level of undefinedness of fix error...
17:49:06 <Stefa2> ok, I got some beginners questions left: Bird wrote, that data Angle = MkAngle Float has some disadvantages against newtype Angle = MkAngle Float
17:49:38 <Berengal> Stefa2, newtypes will be unboxed
17:49:47 <Stefa2> like not isomorph, boxing
17:50:08 <Berengal> They're entirely in the mind of the compiler. Datatypes, however, have their own runtime box for putting stuff in
17:50:13 <Stefa2> yes, why should I use data at all if newtype is better? :)
17:50:27 <Berengal> You can only have one thing in a newtype
17:50:37 <Berengal> Only one constructor with one value
17:50:39 <Stefa2> ahh allright
17:50:51 <Stefa2> ok, last beginners question for tonight
17:51:00 <Berengal> Because when you're passing around a MkAngle Float, all that's passed around at runtime is Float
17:51:24 <Stefa2> foldl is tailrecusrive, but foldr may terminate when foldl doesn't right?
17:51:42 <Berengal> Yes
17:52:07 <Stefa2> newtype Float, is a float without derived functions, isn't it?
17:52:10 <dolio> foldl never terminates on infinite lists.
17:52:41 <Stefa2> k, because of the  (() ) starting at the end ...
17:53:22 <dolio> Well, it always calls itself directly.
17:53:39 <dolio> foldl f z (x:xs) = foldl f (f z x) xs
17:53:54 <dolio> So if xs is infinite, that's obviously never going to stop.
17:54:04 <Stefa2> k
17:54:08 <Stefa2> thank you guys
17:54:17 <purplepenguins> but a right fold on an infinite list isn't going to work either is it
17:54:29 <Stefa2> purplepenguins: it may work
17:54:38 <dolio> foldr f z (x:xs) = f x (foldr f z xs), so if f never looks at its second argument, the recursive call doesn't happen.
17:54:50 <Berengal> foldl stops recursing when it's reached the end of the list. foldr also stops recursing when it's reached the end of the list, but because foldr's accumulator holds the accumulated result of the /future/ computations, not the past like foldl, it can decide to not use them and stop early
17:54:50 <purplepenguins> @src foldr
17:54:50 <lambdabot> foldr f z []     = z
17:54:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:54:51 <Stefa2> if lazy eval stops
17:55:04 <purplepenguins> yes
17:55:34 <Berengal> > foldr (\n a -> if n == 10 then a else n + a) 0 [1..]
17:55:41 <lambdabot>   * Exception: stack overflow
17:55:43 <purplepenguins> it will still fail when trying to evaluate the accumulated result fully
17:56:06 <Berengal> Oops
17:56:19 <Berengal> > foldr (\n a -> if n == 10 then 0 else n + a) 0 [1..]
17:56:23 <lambdabot>   45
17:59:21 <lispy> It's interesting too because I don't know how you could define reverse interms of foldr (due to the type) and we know reverse has to traverse the list
17:59:41 <lispy> > foldl (flip (:)) [] [1..4]
17:59:45 <lambdabot>   [4,3,2,1]
17:59:49 <lispy> > foldr (flip (:)) [] [1..4]
17:59:51 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
18:00:34 <lispy> > scanl (flip(:)) [] [a,b,c,d]
18:00:37 <lambdabot>   [[],[a],[b,a],[c,b,a],[d,c,b,a]]
18:01:06 <lispy> ?free scanl
18:01:08 <lambdabot> (forall x. f . h x = k (f x) . g) => $map f . scanl h y = scanl k (f y) . $map g
18:06:32 <Stefa2> oh, what does the $ sign do again?
18:06:44 <purplepenguins> @src ($)
18:06:44 <lambdabot> f $ x = f x
18:06:57 <canvon> > foldr (flip (++) . (:[])) [] [1..4]
18:06:57 <purplepenguins> it's function application of a sort
18:07:01 <lambdabot>   [4,3,2,1]
18:07:03 <inimino> lispy: you would use ++, right?
18:07:04 <ivanm> purplepenguins: not of a sort
18:07:07 <canvon> (..the inefficiency, I know.. ;) )
18:07:08 <ivanm> it _is_ function application
18:07:14 <purplepenguins> well, it is function application
18:07:20 <inimino> lispy: like that â†‘ :)
18:07:38 <lispy> inimino: interesting
18:07:43 <purplepenguins> but it forces you to evaluate the right side first
18:07:49 <lispy> Isn't (++) strict in the first argument?
18:07:57 <ivanm> Stefa2: it's normally used when finishing off a bunch of function compositions
18:08:03 <purplepenguins> it allows you to remove the need for a lot of parentheses
18:08:04 <Makoryu> > const 1 $ undefined
18:08:07 <lambdabot>   1
18:08:09 <ivanm> e.g. f . g . h $ x == f (g (h x))
18:08:14 <Stefa2> ok, so normally functions bind first, with $ the right side is eval first ?
18:08:15 <lispy> which gets us back to what Berengal was saying about a foldr that terminates can't be strict in one argument (but which did he say...)
18:08:16 <Makoryu> purplepenguins: It does no such thing!
18:08:20 <ivanm> purplepenguins: no evaluation at all!
18:08:31 <ivanm> Stefa2: no
18:08:46 <sohum> @info ($)
18:08:46 <lambdabot> ($)
18:08:49 <purplepenguins> err, right, no evaluation
18:08:54 <Makoryu> Stefa2: All it does is allow you to write "foo (bar baz)" as "foo $ bar baz"
18:09:03 <inimino> lispy: well, reverse on infinite lists can't terminate no matter how you implement it
18:09:10 <sohum> um. how do you get lambda bot to output infix info?
18:09:21 <leimy> http://www.plan9movie.com/
18:09:22 <purplepenguins> it just makes things clearer
18:09:26 <Makoryu> Stefa2: There's no difference in evaluation order..... There is, however, a similar operator ($!) that does change the evaluation
18:09:32 <ivanm> @info ($)
18:09:32 <lambdabot> ($)
18:09:34 <Makoryu> @src ($)
18:09:35 <lambdabot> f $ x = f x
18:09:36 <ivanm> :info ($)
18:09:38 <lispy> inimino: right, so it's interesting that abusing foldr to implement it still gets you a non-terminating one.  I just lke that that the concepts go full circle
18:09:39 <Makoryu> Bah
18:09:48 <ivanm> sohum: :i in ghci...
18:09:58 <sohum> ivanm: heh
18:10:03 <inimino> lispy: ah, I see, yes :)
18:10:15 <purplepenguins> you can always add $ inbetween a function and what you're applying to it but if there is one there you might not be able to remove it
18:10:33 <purplepenguins> > map (^2) $ map (+3) [1..10]
18:10:37 <lambdabot>   [16,25,36,49,64,81,100,121,144,169]
18:10:52 <purplepenguins> > map (^2) map (+3) [1..10]
18:10:55 <lambdabot>   Couldn't match expected type `[a]'
18:11:30 <lispy> > map ((^2) &&& (+3)) [1..10] -- I bet this doesn't type check, so how would you actually do it
18:11:33 <lambdabot>   [(1,4),(4,5),(9,6),(16,7),(25,8),(36,9),(49,10),(64,11),(81,12),(100,13)]
18:11:38 <lispy> oh, nevermind...
18:11:48 <Stefa2> so it would be (f g) x  but with $ f (g(x)) ?
18:11:50 <purplepenguins> the $ basically tells map that "everything after me is going to be the next argument of the previous function"
18:12:22 <Stefa2> ok, so like braces around the rest?
18:12:47 <lispy> kind of, but the precedence that it has is suboptimal
18:12:51 <purplepenguins> but without it, map sees four things which doesn't fit its type
18:12:54 <sohum> Stefa2: pretty much, that's how I had it introduced to me
18:13:23 <sohum> lispy: suboptimal how?
18:13:41 <lispy> I forget the example, but there are cases where infixl would be more intuitive
18:14:34 <ivanm> lispy: why didn't you think it would type-check?
18:14:46 <ivanm> because of which Integral, etc. instance it would use?
18:15:57 <lispy> ivanm: a) I wasn't sure if I wanted *** or &&& and then I wasn't sure if map would accept it
18:16:06 <lispy> (er, that was a and b)
18:16:14 <ivanm> heh, about to say...
18:16:21 <ivanm> lispy: why wouldn't map accept it though?
18:16:49 * lispy shrugs
18:17:38 <lispy> I'm tried and I just thought it might not, clearly it does so how can I sensibly argue that it shouldn't? :)
18:17:51 <sohum> that's one of the things I really like about haskell. when you have an abstraction, that abstracction goes all the way
18:17:56 <sohum> ok, so question
18:17:58 <ivanm> lispy: you're "tried"? :p
18:18:05 <ivanm> I guess that goes to show you "tried" you are :p
18:18:09 <lispy> heh
18:18:26 <sohum> lot of people complain about Monad transformer stacks not being commutative and suchlike
18:18:33 <lispy> ivanm: nah, I just mean lisp is old hat ;)
18:19:05 <sohum> is that still an issue with the Arrow generalisation?
18:19:25 <Cale> sohum: yes
18:20:22 <Cale> sohum: But one nice thing about applicative functors is that the composition of applicative functors is applicative. (Though commutativity would be too much to ask)
18:20:49 <sohum> Cale: big... words... brain... hurty
18:21:19 <Cale> sohum: Control.Applicative
18:21:33 <sohum> Cale: :P
18:21:42 <Cale> sohum: Applicative is not as rich an interface as Monad though.
18:21:52 <c_wraith> :t (<*>) <*> (<*>)
18:21:53 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
18:21:54 <lambdabot>     Probable cause: `<*>' is applied to too few arguments
18:21:54 <lambdabot>     In the second argument of `(<*>)', namely `(<*>)'
18:21:59 <c_wraith> haha. :)
18:22:03 <Cale> So while more things belong to it, there's less you get from it.
18:22:54 <kmc> someone should do a "useful haskell combinator or japanese emoticon" quiz
18:22:56 <canvon> :t <*> `on` <*>
18:22:58 <lambdabot> parse error on input `<*>'
18:23:07 <canvon> :t (<*>) `on` (<*>)
18:23:08 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
18:23:09 <lambdabot>       Expected type: f (a -> b)
18:23:09 <lambdabot>       Inferred type: f a
18:25:20 <Cale> :tï¼ˆã®ï¼¿ã®ï¼‰
18:25:47 <leimy> Cale: Way to go you broke it! :-)
18:25:57 <kmc> :t (.) $ (.)
18:25:59 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
18:26:43 <kmc> :t on
18:26:43 <purplepenguins> :t (.) <$> (.)
18:26:45 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:26:45 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:28:26 <sohum> :t (.) `on` (.)
18:28:27 <lambdabot> forall c a. (c -> c) -> (c -> c) -> (a -> c) -> a -> c
18:28:37 <sohum> that's ... impressive
18:28:59 * Cale tries to remember teh pig operator.
18:29:26 <Cale> @quote pig
18:29:26 <lambdabot> dolio says: Perhaps he's an epigram guy and frowns on Turing completeness.
18:29:54 <sohum> ((.) `on` (.)) (+1) (+2) floor 5.4
18:30:02 <Cale> I think it involved combining some operator in parens in between <* and *>
18:30:09 <sohum> > ((.) `on` (.)) (+1) (+2) floor 5.4
18:30:12 <kmc> if i hpasted some code using Control.Parallel.Strategies, would someone here be willing to give advice on improving it?
18:30:13 <lambdabot>   8
18:30:15 <copumpkin> <^(.)^> ?
18:30:20 <copumpkin> for the infix applicative?
18:30:23 <Cale> Oh, right, there's that one :)
18:30:51 <copumpkin> or maybe the bespectacled bat <^(.).(.)^> ?
18:31:03 <sohum> are those... actual operators?
18:32:39 <copumpkin> well sort of :)
18:35:07 <purplepenguins> you could define them
18:35:20 <deech> Hi all, I have a methodology question. Do Haskell developers generally start off writing a program by coding some unit tests?
18:36:28 <dibblego> sometimes we start off by writing type signatures
18:36:45 <sohum> filling in the body with undefined
18:37:39 <deech> And does unit testing take place after the program is complete?
18:38:04 <c_wraith> the assumption that unit testing even takes place is quite large
18:38:05 <c_wraith> :)
18:38:05 <sohum> deech: look up quickcheck
18:38:37 <dibblego> deech, static checking achieves the task better, but to the extent that it doesn't, testing takes place, often after
18:39:02 <inimino> some languages require more testing than others
18:39:12 * Nafai thinks it is awesome Facebook uses Haskell internally
18:39:32 <deech> sohum: I did. It seems as though all the QuickCheck examples I've seen are for testing pure functions. But most of the functions I write end up being in the IO Monad.
18:39:44 <kmc> deech, what are you writing?
18:39:57 <dibblego> deech, you probably need to redesign your programs
18:39:59 <deech> kmc: a web-app.
18:40:31 <deech> kmc: essentially a Sqlite web -interface.
18:40:42 <kmc> deech, even an IO-heavy program is usually some kind of read -> process -> write pipeline
18:40:53 <kmc> often the bulk is in "process" and can be made pure
18:41:10 <kmc> and even "read" and "write" have pure components like "parse" and "format"
18:41:40 <kmc> if your program is a thin generalized wrapper on sqlite, perhaps this is not the case
18:42:25 <deech> kmc: You're right. I think my design is bad. I'm not good enough with Haskell yet.
18:42:39 <deech> kmc: Hard to get out of imperative world.
18:43:23 <sohum> deech: cooome to the daaaaark side! we have cake!
18:43:36 <kmc> deech, if you'd like to share some code, we can provide advice
18:44:32 <deech> sohum: I'm there! I'm just trying to eat it without getting it all over myself.
18:45:03 <sohum> deech: heh. like kmc said, feel free to poke us with code
18:45:34 <deech> kmc: I have a 1000-line program, when I can break it up into askable chunks I will definitely take you up on that!
18:47:24 <deech> In the meantime I'm learning a lot from HLint
18:48:47 <sohum> hlint is shiny!
18:48:58 <sohum> but! it's not always correctness-preserving
18:49:22 <sohum> that is, the suggested code does not always do exactly what the old code did
18:50:34 <lispy> sohum: I think those are considered bugs
18:50:47 <lispy> eg., ndm wants it to be correctness preserving
18:50:59 <sohum> lispy: mm, clearly
18:51:09 <sohum> lispy: it's just not there yet
18:51:32 <kmc> btw, Control.Parallel.Strategies is wonderful
18:52:49 <kmc> with zero thought or effort i went from using 1 core to ~ 1.5
18:53:11 <kmc> now i'm trying to figure out the best way to get the other 0.5
18:58:28 <kmc> what's the best way to get something like an IOUArray of Complex?
18:58:40 <copumpkin> I'd use MUArr
18:58:44 <copumpkin> @hackage uvector
18:58:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uvector
18:59:45 <kmc> thanks
19:03:02 <hackagebot> HCodecs 0.1 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files. (GeorgeGiorgidze)
19:11:33 <dibblego> is there a function to return a directory under getTemporaryDirectory that is guaranteed not to exist (like mktemp)?
19:12:41 <ivanm> dibblego: TheColonial wants to know why you aren't in #bfpg ...
19:12:52 <dibblego> because I am not cool enough
19:13:20 <TheColonial> lol
19:13:27 <copumpkin> what's bfpg?
19:13:36 <dibblego> Brisbane Functional Programming Group
19:13:37 <ivanm> Brisbane Functional Programming Group
19:13:39 <ivanm> gah
19:42:10 <roconnor> I don't suppose I can actually write an alligator eggs iPhone app with Haskell can I?
19:42:40 <ivanm> roconnor: depends... can you get any alligator egs?
19:42:51 <ivanm> :p
19:43:01 <roconnor> :)
19:43:10 <sw17ch> i don't suppose any one has heard of a bug with GHC that causes really weird linker bugs based on the module path?
19:43:25 <sw17ch> if i move the problem module up a directory, it seems to work
19:44:20 <ivanm> sw17ch: well, there was that weird bug were long module paths made those modules slower...
19:44:26 <ivanm> (has that bug been fixed, by the way?)
19:45:48 <roconnor> ivanm: rumour has it that the long module name bug is fixed, but I'm not sure.
19:46:11 <sw17ch> ivanm: this is weird... i can run it interpreted in the directory
19:46:27 <ivanm> roconnor: so there goes that potential optimisation? :p
19:46:28 <sw17ch> but if i do configure/build/install and try and link against it, i get a few page full of linker erros
19:46:32 <sw17ch> it's pure haskell, no FFI code
19:46:39 <sw17ch> though i am using a few extensions
19:46:49 <sw17ch> it appears to choke on the syb package, even though i don't use it
19:47:46 <ivanm> sw17ch: check if "ghc-pkg check" says anything
19:48:02 <ivanm> I've had some problems with syb in the past due to upgrading it, then finding out that it came with ghc and some packages complained
19:49:00 <sw17ch> i have some happstack issues, but the only one that seems like it could be related is rts
19:49:05 <sw17ch> though, i don't know what rts is
19:51:17 <sw17ch> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9198#a9198
19:51:19 <sw17ch> here's the insanity
19:53:15 <sw17ch> wow, actually, now that i look at it
19:53:23 <sw17ch> ghc-pkg check tells me _everything_ is broken
19:53:26 <sw17ch> D:
19:53:39 <sw17ch> but ghc-pkg list doesn't show nearly that many issues
19:53:44 <sw17ch> actually, none
19:54:29 <sjanssen> sw17ch: the most likely issue is that you forgot some modules in the .cabal file for gator-0.0.1
19:54:50 <ezyang> I think I'm going to teach a class modeled off of the Typeclassopedia article
19:54:56 <ezyang> But I'm going to stop at Monads.
19:55:00 <ezyang> Good idea? Bad idea?
19:55:01 <sw17ch> sjanssen: actually, that might be it...
19:56:03 <copumpkin> ezyang: you mean not cover arrows?
19:56:20 <ezyang> Nope. :-D
19:56:26 <ezyang> Mostly because I don't understand 'em
19:57:03 <copumpkin> I think that'd be fine, although they aren't that much more complicated
19:57:25 <sw17ch> sjanssen: that seems to have fixed it... thanks
19:57:28 <ezyang> I mean, I can work out the definitions
19:57:34 <sw17ch> sjanssen: forgot the "Other Modules" section
19:57:34 <ezyang> But I have developed any of the intuitions
19:57:35 <sw17ch> :(
19:58:01 <sjanssen> sw17ch: very common error, I wish Cabal or GHC could give a more sensible error or warning
19:59:11 <sw17ch> sjanssen, agreed. now that i think about it, i've been caught by this more than once
19:59:23 <copumpkin> woot, ezyang on twitter!
20:00:06 <ezyang> wait wait
20:00:14 * ezyang doesn't have anything interesting there! no really! 
20:00:21 * copumpkin follows anyway
20:00:28 <copumpkin> haskellers on twitter = autofollow :P
20:00:39 <ezyang> whoo
20:00:39 <copumpkin> unless you really don't want me to :P
20:01:10 <ezyang> Followed!
20:01:23 <sw17ch> my tweets generally are boring
20:01:26 <sw17ch> and non-haskell related
20:01:28 <sw17ch> but some times they are
20:01:33 <sw17ch> but don't mean too much :(
20:01:39 * copumpkin follows sw17ch too
20:01:53 * sw17ch follows copumpkin
20:02:10 <aavogt> @src interact
20:02:10 <lambdabot> interact f = do s <- getContents; putStr (f s)
20:02:49 <sw17ch> i'm writing a boolean gate EDSL
20:02:51 <copumpkin> zomg a mmorrow
20:02:51 <sw17ch> it's fun :)
20:03:43 <mmorrow> oh hai
20:05:04 <sw17ch> i know things like this exist already, but it's so fun to do it yourself :P
20:06:20 <ivanm> if anyone else here uses my graphviz library and wants any changes/improvements/bug-fixes for the next release, speak now or forever hold your peace!
20:06:22 <ivanm> ;-)
20:07:15 <copumpkin> I need moar awesomeness
20:07:29 <ivanm> define "awesomeness"
20:07:42 <ivanm> and see if I have sufficient awesomeness in the darcs repo already :p
20:07:58 <copumpkin> your AQ is about 9
20:08:02 <sw17ch> ivanm: i need an AI to look at my codez and give me graphs of the stuff i want
20:08:03 <copumpkin> I require at least 9.5
20:08:11 <sw17ch> i want it to infer what i want
20:08:13 <sw17ch> :)
20:08:45 <ivanm> copumpkin: "AQ"?
20:08:54 <mmorrow> awesomeness quotient?
20:08:59 <ivanm> sw17ch: patches accepted ;-)
20:09:02 <ivanm> mmorrow: ahhh...
20:09:13 <aavogt> > \x -> x / awesomeness
20:09:17 <lambdabot>   Not in scope: `awesomeness'
20:09:21 <ivanm> heh
20:09:39 <sw17ch> now i need a meta-AI that will make patches with the AI that i want...
20:09:47 <aavogt> > \awesomeness -> x / awesomeness
20:09:49 <lambdabot>   Overlapping instances for GHC.Show.Show
20:09:49 <lambdabot>                              (Simpl...
20:09:58 <hausu> can i catch an error in parsec without using try (providing a pparser to clean up more junk until a clean point on consumed input)
20:10:00 <ivanm> aavogt: I think that should be: \ x -> x / maxBound :: Awesomeness -> ???
20:10:24 <aavogt> heh
20:10:33 <aavogt> > x / y
20:10:36 <forgot> in this code: http://codepad.org/f9PGRNCd what does "x<-xs" do?
20:10:37 <lambdabot>   x / y
20:10:49 <ivanm> aavogt: how about: \ x -> x % maxBound :: Awesomeness -> Ratio Awesomeness
20:11:12 <ivanm> forgot: it does the map statement for ever x in the list xs
20:11:32 <ivanm> forgot: do you know list comprehensions?
20:11:57 <forgot> yes; but i'm confused that using a 'do' does not result in some kind of monad
20:11:59 <ivanm> s/ever/every/
20:12:00 <sw17ch> has any one played with the new lenses package on hackag eyet?
20:12:12 <ivanm> forgot: it is a monad... the monad instance for lists is like a big list comprehension
20:12:40 <forgot> ivanm what is the equivalent without the 'do'?
20:12:43 <aavogt> @type let perms [] = [[]]; perms xs = concatMap (\x -> map (x:) (perms $ delete x xs)) xs   in perms "hello"
20:12:45 <lambdabot> [[Char]]
20:12:52 <aavogt> > let perms [] = [[]]; perms xs = concatMap (\x -> map (x:) (perms $ delete x xs)) xs   in perms "hello"
20:12:56 <lambdabot>   ["hello","helol","hello","helol","heoll","heoll","hlelo","hleol","hlleo","h...
20:13:15 <copumpkin> ezyang: have you seen the massive list of haskellers on twitter?
20:13:25 <ivanm> well, you can't actually do it as one list comprehension... it's more of a "meta-comprehension"
20:13:36 <ezyang> no...
20:13:48 <aavogt> heh, it looks broken since you can't tell the ls apart
20:13:56 <ivanm> > let perms xs = concat [ map (x:) (perms $ delete x xs) | x <- xs ]
20:13:59 <lambdabot>   not an expression: `let perms xs = concat [ map (x:) (perms $ delete x xs) ...
20:14:01 <ivanm> > let perms xs = concat [ map (x:) (perms $ delete x xs) | x <- xs ] in perms "abc"
20:14:04 <lambdabot>   []
20:14:19 <ivanm> gah
20:14:19 <copumpkin> , permutations "abc"
20:14:21 <lunabot>  ["abc","bac","cba","bca","cab","acb"]
20:14:21 <forgot> ok then what value does x have after 'x<-xs'?
20:14:25 <aavogt> base case?
20:14:32 <mmorrow> sw17ch: how did the interrupt-a-foreign-call thing ever turn out?
20:14:32 <ivanm> forgot: for each x in xs...
20:14:47 <ivanm> aavogt: agghhhh
20:14:49 <Makoryu> @src permutations
20:14:49 <lambdabot> Source not found. My mind is going. I can feel it.
20:14:55 <Makoryu> WAKKA WAKKA WAKKA
20:14:56 <ivanm> > let perms [] = [[]]; perms xs = concat [ map (x:) (perms $ delete x xs) | x <- xs ] in perms "abc"
20:15:00 <lambdabot>   ["abc","acb","bac","bca","cab","cba"]
20:15:22 * ivanm prefers the concatMap definition as given by aavogt though
20:15:30 <mmorrow> > (\xs -> replicateM (length xs) xs) "abc"
20:15:33 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
20:15:42 <mmorrow> err
20:15:54 <mmorrow> combinations i guess
20:16:00 <sw17ch> mmorrow, i ended up switching to polling using epoll in the foreign call
20:16:01 <ivanm> mmorrow: isn't that bad because of the double traversal (even assuming it produced the correct results)?
20:16:07 <sw17ch> and returning control to the haskell runtime every 0.5 seconds
20:16:18 <mmorrow> ivanm: probably
20:16:20 <ivanm> oh, wait, doing delete results in that anyway
20:16:22 <sw17ch> mmorrow, in other words, i died a little inside
20:16:28 <mmorrow> sw17ch: ooh
20:16:28 <ivanm> we need a single-pass permutation function! ;-)
20:16:31 <mmorrow> sw17ch: heh
20:16:45 <sw17ch> mmorrow, i'm sure there's a more elegant solution with signals, but i shuddered
20:16:55 <ivanm> sw17ch: died a little more every 0.5 seconds? :p
20:17:22 <sw17ch> mmorrow, i also still have an issue where ordering calls to threadDelay 0 can deadlock the system even though it should just terminate
20:17:26 <sw17ch> the RTS spins forever...
20:17:26 <mmorrow> sw17ch: signals and elegant in the same sentence is questionable
20:17:36 <mmorrow> :o
20:17:43 <sw17ch> mmorrow, yeah, it was pretty bad
20:17:57 <sw17ch> i could stick a single threadDelay 0 in somewhere, and it would never return from the delay
20:18:05 <forgot> if x<-xs is just another way of doing a list comprehension, how does the list automatically get concat'ed?
20:18:12 <sw17ch> if i moved it above the previous line, it would terminate
20:18:15 <mmorrow> sw17ch: wow, i wonder what's happening
20:18:18 <aavogt> > select "hello"
20:18:19 <sw17ch> mmorrow, no idea
20:18:21 <lambdabot>   Not in scope: `select'
20:18:31 <sw17ch> mmorrow, i haven't touched it in a bit
20:18:43 <sw17ch> mmorrow, i keep meaning to look into it, but it was really REALLY hard to get a smaller example for
20:18:48 <sw17ch> and i'm not sure what was causing it
20:19:11 <sw17ch> mmorrow,  because reordering the order in which  i threw signals to threads also impacted whether the threadDelay caused hang or not
20:19:12 <sw17ch> :\
20:19:19 <mmorrow> sw17ch: love when completely inexplicable things happen..
20:19:24 <aavogt> @let select [] = []; select (x:xs) = (x,xs):map (second (x:)) (select xs)
20:19:26 <lambdabot>  Defined.
20:20:28 * mmorrow tries to imagine the tangled domino trail that's behind this deadlock
20:20:41 <copumpkin> that select function is handy
20:20:49 <copumpkin> I'd call it selections though
20:21:11 <aavogt> copumpkin: its suggestions like that which keep it out of the libraries!
20:21:19 <copumpkin> lol
20:21:31 <sw17ch> mmorrow, i *think* it has something to do with the underlying signal handler
20:21:36 <sw17ch> that controls scheduling
20:21:46 <sw17ch> at least, that's what i gathered from strace
20:22:02 <sw17ch> but it made me mad, and i finally got something working, and i wasn't able to reduce the problem
20:22:08 <sw17ch> so i committed and dropped it for a while
20:22:20 <ivanm> > select [1..4]
20:22:25 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
20:22:50 <mmorrow> sw17ch: yeah, signals on top of the signal handling that the rts is doing i've found to be sketchy at best. e.g. one time i tried to catch SIGSEGV in haskell code, and the prog just immediately died with "too many signals"
20:23:03 <ivanm> aavogt: hmmm...
20:23:22 <sw17ch> mmorrow, but again, i'm using epoll on the FFI side, but no signals elsewhere
20:23:23 <sw17ch> http://github.com/sw17ch/Scurry/tree/8e393293e071a96337f19324d18d2b56bdd5806e
20:23:29 <sw17ch> that branch exhibits the problem
20:23:31 <sw17ch> i mean, that commit
20:23:34 <sw17ch> not branch, silly me
20:24:47 <sw17ch> mmorrow, somewhere in this file should you feel inclined to hunt for it :P http://github.com/sw17ch/Scurry/blob/8e393293e071a96337f19324d18d2b56bdd5806e/src/Scurry/Application.hs
20:25:00 <mmorrow> hehe, "-- Murderous rampage time..."
20:26:00 <aavogt> > let perms xs = do (c,cs) <- select xs; f <- [(c:),(++c)]; map f (perms cs) in perms "hello"
20:26:03 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
20:26:22 <aavogt> > let perms xs = do (c,cs) <- select xs; f <- [(c:),(++[c])]; map f (perms cs) in perms "hello"
20:26:25 <lambdabot>   []
20:26:49 <copumpkin> :t divides
20:26:51 <lambdabot> Not in scope: `divides'
20:27:04 <copumpkin> @let n `divides` m = m `mod` n == 0
20:27:08 <lambdabot>  Defined.
20:27:18 <copumpkin> > nubBy (flip divides) [2..]
20:27:24 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
20:27:31 <aavogt> @let (|) = divides
20:27:32 <lambdabot>   Parse error: Bar
20:27:38 <ivanm> aavogt: base case! :p
20:27:53 <aavogt> > let perms [] = [[]]; perms xs = do (c,cs) <- select xs; f <- [(c:),(++[c])]; map f (perms cs) in perms "hello"
20:27:57 <lambdabot>   ["hello","hello","helol","helol","helol","helol","hello","hello","helol","h...
20:28:08 <aavogt> > let perms [] = [[]]; perms xs = do (c,cs) <- select xs; f <- [(c:),(++[c])]; map f (perms cs) in perms "abc"
20:28:14 <lambdabot>   ["abc","abc","acb","acb","acb","acb","abc","abc","bca","bca","cba","cba","c...
20:28:37 <aavogt> > let perms [] = [[]]; perms xs = do (c,cs) <- select xs; map (c:) (perms cs) in perms "abc"
20:28:41 <lambdabot>   ["abc","acb","bac","bca","cab","cba"]
20:28:53 <aavogt> > let perms [] = [[]]; perms xs = do (c,cs) <- select xs; map (c:) (perms cs) in perms "abcde"
20:28:57 <lambdabot>   ["abcde","abced","abdce","abdec","abecd","abedc","acbde","acbed","acdbe","a...
20:29:12 <ivanm> let perms [] = [[]]; perms xs = do (c,cs) <- select xs; map (c:) (perms cs) in length (perms "abcde")
20:29:19 <ivanm> > let perms [] = [[]]; perms xs = do (c,cs) <- select xs; map (c:) (perms cs) in length (perms "abcde")
20:29:23 <lambdabot>   120
20:29:26 <ivanm> \o/
20:29:49 <aavogt> @let test_perms [] = [[]]; perms xs = do (c,cs) <- select xs; map (c:) (perms cs)
20:29:51 <lambdabot>  Defined.
20:29:55 <heatsink> Are there examples of how set-theoretic paradoxes such as T :: T in type systems lead to demonstrably bad behavior such as unsafeCoerce :: a -> b ?
20:30:19 <aavogt> @check \x -> test_perms x == (permutations x :: [Bool])
20:30:21 <lambdabot>   Not in scope: `test_perms'
20:30:43 <aavogt> @let test_perms [] = [[]]; test_perms xs = do (c,cs) <- select xs; map (c:) (test_perms cs)
20:30:45 <lambdabot>  <local>:6:0:
20:30:45 <lambdabot>      Multiple declarations of `L.test_perms'
20:30:45 <lambdabot>      Declared at: ...
20:30:52 <aavogt> @unlet test_perms
20:30:52 <lambdabot>   Parse error: SemiColon
20:31:25 <aavogt> bah, I hate it when I rename functions, and miss some occurences of the old name
20:31:39 <aavogt> @unlet
20:31:40 <lambdabot>  Defined.
20:31:49 <eoeas> Hi, can somebody elaborate why this tuple:   [(True, []), (False, [['a']])]   is   [(Bool, [[Char]])] and not  :: [(Bool, [a]), (Bool,[[Char]])] ??
20:31:52 <aavogt> really?!
20:32:13 <copumpkin> eoeas: because lists are homogeneous
20:32:27 <copumpkin> every element in a list must be of the same type
20:32:30 <aavogt> eoeas: the second type is more general
20:33:07 <aavogt> a function that accepts the second type can take that sample list, but not the other way around
20:33:45 <aavogt> > select "abc"
20:33:49 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ab")]
20:34:51 <copumpkin> eoeas: another answer is that [x, y] isn't a valid type
20:34:59 <copumpkin> [a] is the only valid form
20:35:29 <Makoryu> eoeas: Any type you see the type [x], read it as "list of x"
20:35:39 <copumpkin> [x] is actually sugar for [] x
20:35:46 <eoeas> copumpkin: but thats allow in a tuple, (x,y,z)
20:35:48 <copumpkin> (in typeland)
20:35:48 <eoeas> ed
20:36:09 <copumpkin> yep, and lists aren't tuples :)
20:36:23 <aavogt> copumpkin: a bit inconsistent with valueland, no?
20:36:50 <eoeas> copumpkin: Ahh, oversaw the most outer []'s
20:36:57 <copumpkin> aavogt: yep
20:36:57 <Makoryu> eoeas: A list can hold any number of items (and that number can be zero) as long as they're the same type
20:37:01 <Makoryu> eoeas: Ah :p
20:37:06 <heatsink> eoeas: Although (x,y,z) and (w,x,y,z) look similar, they are different types.  Different in the same way that [x] and Maybe x are different.
20:37:22 <aavogt> but I guess we can ignore those inconsistencies, since they are convenient :)
20:37:42 <eoeas> heatsink: something like a type signature/fingerprint, right ??
20:38:38 <lpsmith> I'm having a weird issue with cabal install
20:39:00 <lpsmith> I just noticed that for whatever reason,  it's compiling everything twice before it installs it
20:39:03 <eoeas> *phew* brain was overheating, thanks people
20:39:07 <copumpkin> lpsmith: you have profiling enabled?
20:39:25 <copumpkin> lpsmith: it compiles everything twice for me because I enabled profiling in my config
20:39:54 <lpsmith> hmm,  library-profiling defaults to False
20:40:03 <heatsink> eoeas, I was actually talking about tuple types, not tuple values.
20:40:17 <lpsmith> copumpkin:  I don't think so?
20:40:36 <copumpkin> does your second compile make .something_o files?
20:40:37 <heatsink> eoeas: Types are like functions, in the sense that you apply a type constructor to arguments.  "Maybe" is a different constructor from "List", and (,) is different from (,,).
20:40:59 <sshc> Hi, in Haskell, what is a standard way to beep?
20:41:11 <heatsink> lpsmith, is it compiling o files and p_o files?
20:41:20 <heatsink> oh
20:41:31 <SamB> sshc: you could emit an alert character on the terminal?
20:41:36 <copumpkin> it might not be p_, but I'd hope that the second compile produces a second way
20:41:38 <SamB> that *might* beep
20:41:40 <aavogt> @check test_perms [] = [[]]; test_perms xs = do (c,cs) <- select xs; map (c:) (test_perms cs); in \x -> test_perms x == permutations (x::[Bool])
20:41:40 <lambdabot>   Parse error at "=" (column 15)
20:41:43 <SamB> then again, it might ding or flash ;-)
20:41:47 <kmc> sshc, you'll need an applicative categorical beep hylofunctor morphism
20:41:48 <aavogt> @check let test_perms [] = [[]]; test_perms xs = do (c,cs) <- select xs; map (c:) (test_perms cs); in \x -> test_perms x == permutations (x::[Bool])
20:41:51 <lambdabot>   Not in scope: `select'
20:41:54 <copumpkin> kmc: lol
20:41:55 <heatsink> kmc: haha
20:42:05 <copumpkin> mmm a hylofunctor :o
20:42:06 <eoeas> heatsink: Yeah, that's what I meant, a tuple type is unique (it's value types and positioning) .. ??
20:42:21 <SamB> kmc: or, you could just emit a type error so contrived, it causes the *user* to beep!
20:42:23 <heatsink> eoeas, yeah
20:42:53 <aavogt> @hackage heep
20:42:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/heep
20:43:07 <eoeas> heatsink: cool
20:43:14 <aavogt> but that doesn't exist
20:43:52 <lpsmith> No,  it's producing a .o and .a files,  but that shouldn't require compiling everything twice, should it?
20:44:02 <copumpkin> hrm, nope
20:44:35 <orbitz> does GHC come with a simple GUI API?  Like Hudak uses in hi sbook?
20:44:36 <SamB_XP> lpsmith: building a program and a library?
20:44:41 <SamB_XP> from the same sources?
20:45:01 <copumpkin> oh my god, my procrastination machine is down
20:45:05 <copumpkin> reddit :(
20:45:19 * copumpkin hugs news.ycombinator.com close
20:45:37 <heatsink> lpsmith, there are two final outputs (for ghc and ghci), but only the final link should run twice
20:45:48 <ivanm> copumpkin: looks like you're right! http://downforeveryoneorjustme.com/reddit.com
20:46:02 <ivanm> or not... proggit just loaded...
20:46:02 <heatsink> There's a website for that?!
20:46:17 <SamB_XP> heatsink: yeah
20:46:25 <SamB_XP> it doesn't actually check with everyone
20:46:32 <SamB_XP> but it does give you at least a second opinion
20:47:08 <aavogt> orbitz: there is a wrapper for ghci (in wxhaskell I think) that gives ghci some buttons to press...
20:48:16 <aavogt> like this: http://code.google.com/p/winghci/
20:48:26 <orbitz> aavogt: i mostly just want to draw lines and color pixels
20:48:38 <orbitz> Hudak uses some trivial windowing toolkit
20:48:52 <aavogt> oh, you can use gtk2hs
20:49:05 * Makoryu sighs
20:49:15 <Makoryu> "Let's just use gtk2hs!"
20:49:30 <aavogt> that package has a package called soegtk which should be the same as that book uses
20:50:09 <aavogt> http://www.haskell.org/gtk2hs/docs/current/Graphics-SOE-Gtk.html
20:51:00 <aavogt> Makoryu: why not if it has an api that's the same as that book uses?
20:51:22 <orbitz> is using that API a bad idea?
20:51:31 <Makoryu> Ignore me, I'm bitter
20:51:33 <lpsmith> hmm, this behavior only seems to manifest itself with certain packages,  like pandoc.  And Darcs
20:51:36 <orbitz> I mostly want to visually implement soem cellular automota, so I don't need anything too fancy
20:51:40 <lpsmith> And darcs takes a minute to compile :-(
20:51:59 <SamB_XP> lpsmith: that's a sad thing ?
20:52:09 <SamB_XP> that sounds pretty sweet to me
20:52:11 <copumpkin> lpsmith: not just packages that have an executable and a binary?
20:52:16 <copumpkin> I mean, an executable and a library
20:52:34 <hausu> orbitz: tried http://vis.renci.org/jeff/hieroglyph/ ?
20:52:47 <orbitz> hausu: checking
20:52:52 <lpsmith> that might have something to do with it, but there is definitely recompilation that shouldn't be necessary
20:53:31 <lpsmith> SamB_XP:  it takes a bit longer than a minute,  I was using the idiom, not being literal.
20:53:42 <SamB_XP> the idiom is "forever"
20:53:45 <SamB_XP> not "a minute"
20:54:38 <copumpkin> lol
20:54:57 <lpsmith> Whatever  :-)
20:55:20 <orbitz> you know, it took me like a year
20:55:26 <lpsmith> But some compilers are quite a bit snappier than GHC,  which admittedly is a lot better than it used to be :-)
20:55:31 <orbitz> but i finally get what people mean whenthey say "programmable semi colon"
20:55:41 <kmc> :D
20:55:45 <lpsmith> yay!
20:56:09 <SamB_XP> orbitz: now you'll be wishing other programming languages had them ;-)
20:56:18 <SamB_XP> though I would honestly not recommend trying it in Coq ;-)
20:56:25 <orbitz> i think the confusing part is nobody writes haskell code with semi colons! :)
20:56:46 <SamB_XP> oh, some people do
20:56:51 <SamB_XP> mostly for papers, though
20:57:22 <orbitz> is there anything Haskell can't do better?
20:57:30 <orbitz> (than everyone else)
20:57:36 <hausu> refactor PHP? no wait...
20:57:42 <aavogt> @faq is there anything Haskell can't do better?
20:57:43 <lambdabot> The answer is: Yes! Haskell can do that.
20:58:18 <heatsink> @faq can Haskell do something it can't do?
20:58:18 <lambdabot> The answer is: Yes! Haskell can do that.
20:58:33 <SamB_XP> @faq is haskell inconsistant?
20:58:33 <lambdabot> The answer is: Yes! Haskell can do that.
20:59:22 <blackdog> @faq is haskell making my ghc tests fail?
20:59:22 <lambdabot> The answer is: Yes! Haskell can do that.
20:59:29 * blackdog sighs
20:59:42 <Adamant> @faq does Haskell spread rabies?
20:59:42 <lambdabot> The answer is: Yes! Haskell can do that.
21:00:18 <Adamant> @faq does Haskell frighten old ladies?
21:00:19 <lambdabot> The answer is: Yes! Haskell can do that.
21:00:20 <blackdog> there should be something in lambdabot to reply "stop screwing around and get back to work" if it gets called too often :)
21:00:29 <Adamant> wow I've almost got a song going :P
21:00:43 <blackdog> @faq can haskell kick it?
21:00:43 <lambdabot> The answer is: Yes! Haskell can do that.
21:00:48 <blackdog> oh so close
21:00:56 <SamB_XP> @does haskell like Maybes?
21:00:56 <lambdabot> haskell like Maybes? not available
21:01:08 <SamB_XP> @faq does haskell like Maybes?
21:01:08 <lambdabot> The answer is: Yes! Haskell can do that.
21:01:16 <SamB_XP> @vixen does haskell like Maybes?
21:01:16 <lambdabot> I'm glad I'm not Brezhnev. Being the Russian leader in the Kremlin. You never know if someone's tape recording what you say.
21:01:46 <Adamant> best Nixon quote ever
21:02:05 <SamB_XP> is *that* what that is?
21:02:13 <SamB_XP> is it a from a tape recording ;-P ?
21:02:47 <kmc> zipWith (\i xs -> map ((,) i) $ zipWith const [0..] xs) [0..]
21:02:49 <kmc> feels clunky
21:02:57 <ivanm> SamB_XP: whilst he was in the white house having a private conversation?
21:03:02 <Adamant> I would guess it's a pre-Presidential Nixon, but if it's from the tapes even better
21:03:05 <kmc> the idea is to replace every element of a 2-level nested list with its pair index
21:03:09 <SamB_XP> ivanm: quite!
21:03:23 <Adamant> Nixon knew the tapes were installed
21:03:35 <Adamant> so I doubt he would say that around the tapes
21:03:43 <Adamant> but you never know
21:04:00 <ivanm> Adamant: he knew they were installed, but did he know _where_ they were installed? ;-)
21:04:09 <Adamant> ivanm: :P
21:06:40 <kmc> :t map . map
21:06:42 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
21:06:59 <kmc> :t sequence . sequence
21:07:01 <lambdabot> forall a. [[a]] -> [[a]]
21:07:22 <Cale> :t \xs -> [[(m,n) | (n,y) <- zip [0..] ys] | (m,ys) <- zip [0..] xs]
21:07:24 <lambdabot> forall t t1 b. (Num t, Enum t, Num t1, Enum t1) => [[b]] -> [[(t, t1)]]
21:07:30 <kmc> :t sequence . map sequence
21:07:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
21:18:21 <kmc> if i forkIO a bunch of times, what's the easiest way to wait for all the threads to finish?
21:18:50 <aavogt> @type mapM sequence
21:18:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
21:18:54 <ezyang> I wrote some exercises for Functor/Pointed/Applicative.  People should test solve them! http://ezyang.com/haskell.html#Exercises
21:19:29 <ivanm> kmc: IIRC (never having done so myself), you should have a flag or something in an MVar
21:19:52 <aavogt> ezyang: "What is the type of fmap fmap fmap?" is worth a lol
21:20:09 * copumpkin loves fmap fmap fmap
21:20:12 <kmc> so there's no straight-up "wait" function?
21:20:35 <aavogt> > "What is the type of: " ++ cycle "fmap `fmap`"
21:20:36 <ivanm> @type fmap fmap fmap
21:20:38 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:20:40 <lambdabot>   "What is the type of: fmap `fmap`fmap `fmap`fmap `fmap`fmap `fmap`fmap `fma...
21:20:42 <ivanm> aavogt: happy now? ;-)
21:20:50 <aavogt> > "What is the type of: " ++ cycle "fmap`fmap`"
21:20:53 <lambdabot>   "What is the type of: fmap`fmap`fmap`fmap`fmap`fmap`fmap`fmap`fmap`fmap`fma...
21:20:56 <copumpkin> kmc: I vaguely remember something
21:21:17 <ivanm> kmc: not that I know of, but I'm probably not the best person to ask ;-)
21:22:02 <ezyang> :-)
21:22:11 <aavogt> kmc: you can do something with the ThreadIdS...
21:22:20 <ezyang> But it's a super-good exercise in following types
21:22:25 <ezyang> which is why I put it in
21:22:34 <aavogt> I remember there being a haskell wiki article on that sort of thing
21:23:03 <aavogt> @hoogle ThreadId -> IO Bool
21:23:03 <lambdabot> Control.Concurrent.MVar tryPutMVar :: MVar a -> a -> IO Bool
21:23:04 <lambdabot> Control.Concurrent.Chan isEmptyChan :: Chan a -> IO Bool
21:23:04 <lambdabot> Control.Concurrent.MVar isEmptyMVar :: MVar a -> IO Bool
21:23:10 <kmc> so they mostly use mvars
21:23:15 <Makoryu> :t fmap <$> fmap <$> fmap <$> fmap
21:23:17 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
21:23:54 <ezyang> ooh, nice
21:24:12 <ezyang> :t fmap fmap
21:24:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
21:24:33 <ezyang> I guess you don't lose generality beyond the third fmap if you use <$>
21:24:53 <purplepenguins> :t fmap fmap fmap fmap
21:24:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
21:25:16 <aavogt> usually, some of the fmapS end up being for the  (r ->) instance
21:25:32 <aavogt> so it's clearer to use (.) instead
21:27:16 <ezyang> I think it's generally poor to use the function's instance of functor/monad
21:27:59 <ezyang> Any comments on the other exercises?
21:33:54 <mmorrow> , ppDoc <$> fmaps 8
21:33:57 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
21:35:55 * ivanm has found a bug in haddock! :o
21:36:45 <ivanm> when having the -- * style mark-up in an export list for section headers, if you have a 'foo' in one of them then foo and the rest of the line is no longer part of the overall link...
21:36:50 <pikhq> :t fmaps
21:36:52 <lambdabot> Not in scope: `fmaps'
21:37:05 <aavogt> , [$ty| fmaps |]
21:37:08 <lunabot>  Int -> ExpQ
21:37:36 <pikhq> Ah.
21:38:09 <aavogt> , [$ty| $(fmaps 5) |]
21:38:12 <lunabot>  forall a b c a a a a . (Functor a, Functor a, Functor a, Functor a, Funct...
21:38:12 <lunabot>                                                                           ...
21:38:12 <lunabot>                                                                           ...
21:38:47 <mmorrow> , $(fmaps 8) (*2) (nesty $(nat 7) (:[]) 42)
21:38:50 <lunabot>  [[[[[[[[84]]]]]]]]
21:39:01 <mmorrow> , $(nat 7)
21:39:04 <lunabot>  N (N (N (N (N (N (N Z))))))
21:39:06 <mmorrow> , (nesty $(nat 7) (:[]) 42)
21:39:08 <lunabot>  [[[[[[[[42]]]]]]]]
21:39:29 <ivanm> who maintains haddock? waern?
21:39:34 <mmorrow> i think so
21:39:58 <ivanm> @seen waern
21:39:58 <lambdabot> Unknown command, try @list
21:40:02 <ivanm> bugger, forgot
21:40:07 <ivanm> ,seen waern
21:40:08 <lunabot>  luna: Not in scope: `seen'
21:40:15 <ivanm> preflex: seen waern
21:40:15 <preflex>  waern was last seen on #haskell 13 days, 8 hours, 58 minutes and 22 seconds ago, saying: pastorn: tja
21:40:21 <mmorrow> aavogt: the function that lunabot uses to get types from the ghc-api has a weird bug
21:40:22 <ivanm> hmmm...
21:40:30 <ivanm> well, at least one bot understood what I meant! ;_
21:40:31 <ivanm> ;-)
21:40:41 <mmorrow> aavogt: (forall a b c a a a ...)
21:40:52 <mmorrow> aavogt: dunno wtf is happening..
21:42:04 <aavogt> mmorrow: its using hint, or the ghc-api directly?
21:42:06 <ezyang> sleepy time now
21:42:08 <ezyang> bye all
21:42:24 <mmorrow> aavogt: ghc-api directly
21:42:41 <mmorrow> aavogt: with some additional hackery on top
21:44:17 <mmorrow> aavogt: this is the cleaned-up version of it (the bot's using the original version, which is a mess, but in the case of the ty QQ uses the same function)  http://moonpatio.com/repos/lunabot/
21:46:10 <aavogt> , ppDoc <$> fmaps 5
21:46:12 <lunabot>  fmap . (fmap . (fmap . (fmap . fmap)))
21:46:44 <mmorrow> here's fmaps too http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1302
21:47:26 <mmorrow> , ppDoc <$> fmaps (negate 100000)
21:47:28 <lunabot>  id
21:48:27 <mmorrow> , ppDoc <$> foldr (|.|) [|id|] (replicate 4 [|show|])
21:48:28 <lunabot>  show . (show . (show . (show . id)))
21:52:21 <aavogt> @hoogle renameT
21:52:21 <lambdabot> No results found
21:52:46 <mmorrow> aavogt: ugh, that one is pretty hideous :), but could (should) be wrapped up nicelly
21:52:55 * mmorrow loo
21:53:00 <mmorrow> oh, actually it's in haskell-src-meta
21:53:27 <mmorrow> http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.5/doc/html/Language-Haskell-Meta-Utils.html
21:53:50 <mmorrow> lunabot uses it with `myNames'
21:54:10 <mmorrow> (but it's not renameT that's butchering the tysigs wrt [$ty|)
21:54:12 <aavogt> mmorrow: there is a definition for it in Luna.Bot.Lib.Eval, but that whole section isn't being used?
21:54:31 <mmorrow> aavogt: ah, yeah that's the same code as in hasskell-src-meta
21:54:59 <mmorrow> aavogt: that lunabot repo is a cleaned up version of the original stuff (which the bot is *still* using)
21:55:17 <aavogt> , [$ty | return |]
21:55:18 <lunabot>  luna: parse error on input `|]'
21:55:29 <aavogt> , [ty| return |]
21:55:30 <lunabot>  luna: parse error on input `|]'
21:55:32 <mmorrow> it only happens on some stuff, which is odd too
21:55:37 <aavogt> , [$ty| return |]
21:55:39 <lunabot>  forall a b . Monad a => b -> a b
21:55:45 <mmorrow> , [$ty| either Left Right |]
21:55:48 <lunabot>  forall a b . Either b a -> Either b a
21:55:51 <mmorrow> , [$ty| either Right Left |]
21:55:54 <lunabot>  forall a a . Either a a -> Either a a
21:55:54 <aavogt> , [$ty| (return,return) |]
21:55:55 <mmorrow> !!
21:55:57 <lunabot>  forall a b a b . (Monad a, Monad a) => (b -> a b, b -> a b)
21:56:02 <mmorrow> ooh.
21:56:05 <mmorrow> err
21:56:16 <mmorrow> , typ "(return,return)"
21:56:19 <lunabot>  "forall a (m :: * -> *) a (m :: * -> *).\n(GHC.Base.Monad m, GHC.Base.Mon...
21:56:35 <mmorrow> yeah, i dunno wtf is going on
21:56:46 <mmorrow> (typ is pre-renameT)
21:57:30 <mmorrow> , [$ty| let x = return in (x,x)"
21:57:31 <lunabot>  luna: lexical error in string/character literal at end of input
21:57:34 <mmorrow> , [$ty| let x = return in (x,x)|]
21:57:37 <lunabot>  forall a a b . Monad b => (a -> b a, a -> b a)
21:58:13 <dancor> it's ok to repeat things in forall?
21:58:14 <mmorrow> it may be something to do with unsafePerformIO as well (interacting badly with the ghc unique name generation)
21:58:27 <aavogt> mmorrow: in #xmonad, there's xmonadbot which only has a #type command, which uses hint. It manages (return,return) well.
21:58:43 <mmorrow> dancor: no, it's a bug in the ghc-api and/or lunabot
21:58:51 <sbahra> @seen ddarius
21:58:52 <lambdabot> Unknown command, try @list
21:59:05 <sbahra> preflex, seen ddarious
21:59:05 <preflex>  Sorry, I haven't seen ddarious
21:59:08 <aavogt> mmorrow: I suspect the unsafePerformIO
21:59:08 <sbahra> preflex, seen ddarius
21:59:09 <preflex>  ddarius was last seen on #haskell 103 days, 3 hours, 36 minutes and 18 seconds ago, saying: parsec2 is faster and what most libraries expect.
21:59:13 <mmorrow> aavogt: right, so does ghci (and it uses the same function iirc)
21:59:50 <mmorrow> aavogt: so i don't know what's going on. (also, lunabot has it's own version (modified) of parts of the ghc-api, so the interaction with everything is definitely non-trivial)
22:00:35 <mmorrow> hmm, or actually maybe hint and ghci are using a /diffferent/ function
22:01:11 <mmorrow> because now that i think about it i seem to remember verifying that it was the particular ghc-api function with the bug, by trying it independent of lunabot
22:01:33 <aavogt> hint is supposed to use the ghc-api
22:01:56 <mmorrow> aavogt: http://moonpatio.com/docs/ghc/InteractiveEval.html#v%3AexprType
22:02:14 <mmorrow> aavogt: there are more than one way to get the type of an expression, starting from a String
22:03:05 <mmorrow> exprType expr = withSession $ \hsc_env -> do ty <- hscTcExpr hsc_env expr; return $ tidyType emptyTidyEnv ty
22:03:45 <mmorrow> ooh.
22:03:52 <mmorrow> lunabot's not doing tidyType
22:04:08 <mmorrow> bingo (i hope)
22:04:43 <mmorrow> so it may be that those "equal" tyvars only print as though their equiv
22:04:48 <mmorrow> and really aren't
22:05:00 <mmorrow> (which tidyType (i'm guessing) makes explicit)
22:05:05 * mmorrow tries that
22:07:28 <eoeas> Does anyone know why the construct ":" operator is not listed in: http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98/List.html   ??
22:08:05 <aavogt> @docs Data.List
22:08:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
22:08:49 <aavogt> @docs GHC.Types
22:08:49 <lambdabot> GHC.Types not available
22:08:52 <copumpkin> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/ghc-prim/src/GHC-Types.html#Char
22:09:47 <_Jordan_> really stupid newbie question: where does GHC look when I do import Some.Module?
22:10:24 <aavogt> eoeas: you can use :i (short for :info) in ghci with any name in scope to get the name of the module that defines it
22:10:40 <absentia> re
22:11:18 <aavogt> _Jordan_: Some/Module.{lhs,hs,chs}
22:11:46 <aavogt> and also in any libraries already installed with ghc
22:12:38 <mmorrow> , typ "(return,return)"
22:12:41 <lunabot>  "forall a (m :: * -> *) a1 (m1 :: * -> *).\n(GHC.Base.Monad m, GHC.Base.M...
22:12:44 <copumpkin> :o
22:12:44 <mmorrow> woo
22:12:48 <_Jordan_> aavogt: is there a way I can get it to look other places too (say, my .cabal path)? Or should I copy the library to my project's dir?
22:12:49 <copumpkin> fancy
22:13:03 <mmorrow> now to get rid of the hackish renaming in [$ty|
22:13:43 <absentia> note:  I haven't looked.. asking here first...  can I use/access Qt (trolltech/UI) from Haskell?  Has anyone done this -- how do you like it? etc.
22:14:09 <aavogt> _Jordan_: if cabal installed the package that provides Some.Module correctly, you shouldn't have to do anything for it to be found
22:14:13 <eoeas> aavogt: Thanks. Do you know under which section in http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html it is located ??
22:14:22 <aavogt> eoeas: it
22:14:25 <mmorrow> , [$ty| either Right Left |]
22:14:25 <aavogt> 's not there
22:14:28 <lunabot>  forall a1 a . Either a a1 -> Either a1 a
22:14:38 <mmorrow> aavogt: yay! :)
22:15:29 <mmorrow> , [$tyQ| either Right Left |]
22:15:31 <lunabot>  ForallT [a1,a] [] (AppT (AppT ArrowT (AppT (AppT (ConT Either) (VarT a)) ...
22:15:48 <aavogt> eoeas: check the link to GHC.Types that copumpkin pasted for the actual definition
22:16:07 <Makoryu> absentia: I've never heard of a Qt binding, which is probably something to do with the fact that Qt is written in Sepples, and Haskell <=> Sepples bindings are not enjoyable to write
22:16:39 <absentia> Sepples?  it's written in C++?
22:17:01 <eoeas> aavogt: copumpkin: Cheers
22:17:02 <Makoryu> Yes.
22:17:13 <absentia> what is sepples?
22:17:26 <absentia> a pronunciation of c++?
22:17:30 * absentia slaps his forehead.
22:17:31 <Makoryu> absentia: Precisely.
22:17:38 <jml> never heard that one before.
22:17:43 <absentia> ditto.
22:18:01 <absentia> I've used pewl for perl...  and jabba for java ... but sepples... gonna have to remember that.
22:18:33 <aavogt> there seems to be a qtHaskell out there
22:18:44 <mauke> (also, C++0x = sepplesox)
22:18:58 <absentia> ya, I didn't look.  not a big deal.. I first need to get into haskell more first.
22:19:00 <aavogt> but the gtk bindings seem to be more mature
22:19:09 <Gracenotes> mauke: I approve of that pronunciation
22:19:13 <absentia> sepplesux!
22:19:49 <Gracenotes> Haskell aside, surely C++0x is the best purely fictional programming language
22:19:56 <absentia> gtk makes the hair on the back of my next stand up... although, moc is pretty close to that.
22:20:20 <absentia> Haskell is fictional as well as functional?
22:20:27 <kscaldef> does anyone know a particular fast way to find out if a number is palindromic?  I've tried using unfoldr and mapAccumL/R with divMod to generate lists of digits, but they all seem substantially slower than using show to convert the number to a string and checking if that's a palindrome
22:20:35 <absentia> I just wish is was fast  (ooops, sorry)
22:20:43 <absentia>  s/is/it/
22:20:48 <eoeas> Are the differences between GHC 6.8 and 6.10 compiler improvements or the Haskell language i.e new Haskell functions/operators ??
22:20:50 <Makoryu> Gracenotes: I almost didn't see what you did there.
22:21:39 <Makoryu> eoeas: Some of the libraries and extensions have changed, but the core language is still Haskell 98 and the Prelude should be exactly the same.
22:21:47 <Gracenotes> kscaldef: show for integers is surprisingly faster. For example. (length . show) is much better than any divmodding with 10 that I've seen
22:22:01 <Gracenotes> for counting digits, the latter is
22:22:05 <mmorrow> eoeas: they're both improvements to the compiler itself and improvements to the runtime system
22:22:12 <absentia> log?
22:22:17 <copumpkin> there's an even faster way if my patch ever gets accepted into GHC
22:22:18 <mmorrow> eoeas: which are pretty tightly coupled in the case of haskell
22:22:37 <Gracenotes> log.. maybe, but it runs into precision problems
22:22:50 <absentia> really?
22:23:07 <copumpkin> Gracenotes: gmp has a sizeinbase function that I added a binding to in ghc
22:23:12 <ivanm> copumpkin: patch for what?
22:23:15 <Vanadium> Can anyone link to a basic example of using Parsimony?
22:23:15 <absentia> you're only going one way, so you can simply truncate
22:23:19 <mmorrow> eoeas: (coupled in the sense that the compiler has to generate code with full knowledge of how the runtime system works, and the runtime system has to work with full knowledge of the code the compiler generates)
22:23:20 <Vanadium> I am being a bit too stupid right now
22:23:23 <kscaldef> log for computing length, you mean?
22:23:27 <ivanm> copumpkin: oh... don't forget, dcoutts is stripping out GMP usage...
22:23:27 <absentia> yes
22:23:37 <copumpkin> ivanm: I did a lot of that, and it's already been done :P
22:23:48 <copumpkin> ivanm: although none of my changes are actually in GHC :)
22:23:57 <kscaldef> not really helpful for my original question, though
22:24:06 <absentia> I am not sure how that would work on a very large Integer though.
22:24:08 <copumpkin> kscaldef: yes, a string is the fastest way that I can think of
22:24:13 <ivanm> copumpkin: to the extent that dcoutts is doing (in that GMP can be replaced)?
22:24:43 <copumpkin> ivanm: yeah, integer-gmp is a library now, and can be replaced by integer-simple for example
22:24:54 <aavogt> ivanm: Integer is going to be implemented in Haskell?
22:24:54 <copumpkin> but I added some more bindings to integer-gmp I should say
22:24:58 <absentia> I guess counting digit/chars is the same as log anyway.
22:25:07 <copumpkin> aavogt: integer-simple is in haskell
22:25:39 <ivanm> aavogt: for those people who want a BSD-only GHC
22:25:44 <ivanm> but it will be sloooooooooow
22:25:54 <aavogt> coming to a ghc-6.12 near you?
22:25:54 <Gracenotes> there was a thread on haskell-cafe a few weeks ago about counting the digits in a number. the discussion *came from* one about precision with logBase
22:25:59 <Pseudonym> @let choose n k = if (k < 0 || k > n) then 0 else product [n-k+1..n] `div` product [1..k]
22:26:01 <lambdabot>  Defined.
22:26:05 <eoeas> I c
22:26:09 <ivanm> aavogt: not sure if it will be in 6.12...
22:26:13 <Pseudonym> @let encode max [] = 0
22:26:14 <Gracenotes> I think some efficient algorithms were mentioned later in that thread
22:26:15 <lambdabot>  Defined.
22:26:15 <Pseudonym> @let encode max (n:ns) = choose (max-n-1) (genericLength ns + 1) + encode max ns
22:26:17 <lambdabot>  Defined.
22:26:31 <Pseudonym> > choose 10 2
22:26:35 <lambdabot>   45
22:26:42 <Pseudonym> > encode 10 [8,9]
22:26:45 <Gracenotes> copumpkin: for GMP's digit-counting-in-base routine, would it work for S# or I#?
22:26:47 <lambdabot>   0
22:26:50 <Pseudonym> > encode 10 [7,9]
22:26:54 <lambdabot>   1
22:26:56 <Pseudonym> > encode 10 [7,8]
22:27:01 <lambdabot>   2
22:27:02 <Pseudonym> > encode 10 [0,1]
22:27:03 <copumpkin> Gracenotes: only J#
22:27:07 <lambdabot>   44
22:27:12 <Pseudonym> This is definitely function of the day.
22:27:16 <Pseudonym> For me, anyway.
22:27:23 <copumpkin> Gracenotes: you could either write your own simple int log for the S# case, or upconvert
22:27:31 <copumpkin> it'd still be a lot faster than show, I'd bet
22:29:52 <eoeas> Makoryu: The reason I was wondering about 6.8 and 6.10 is that I'm programming on 6.8.2, however the online reference is 6.10, reason to worry ??
22:30:13 <Nereid_> you can get docs for 6.8.2 too
22:30:18 <shachaf> eoeas: Probably not significantly, but you should upgrade to 6.10 if you can.
22:30:58 <Nereid_> @src encode
22:30:58 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:31:04 <Nereid_> @hoogle encode
22:31:04 <lambdabot> package Encode
22:31:05 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
22:31:05 <lambdabot> package bencode
22:31:11 <Nereid_> this doesn't help any
22:31:12 <Nereid_> :P
22:31:20 <eoeas> Nereid_: Any links? shachaf: Can't find a .deb file for 6.10
22:31:38 <Nereid_> eoeas: http://www.haskell.org/ghc/docs/
22:31:59 <eoeas> Nereid_: Thnx
22:32:33 <Pseudonym> Nereid: Consider a bitmap B[0..n-1].
22:32:47 <Pseudonym> Let the number of bits that are set be k.
22:32:57 <Nereid_> ok
22:33:00 <Pseudonym> There are choose n k possible bitmaps, correct?
22:33:07 <Nereid_> yes
22:33:39 <Pseudonym> encode takes a bitmap (represented as a sorted list of bits which are set), and returns a number in the range [0..choose n k].
22:33:57 <Pseudonym> Which is the index of that bitmap in the set of bitmaps with k bits set.  In lexicographic order.
22:33:57 <Nereid_> ah
22:34:22 <Pseudonym> Or, to put it another way, it's an entropy encoding of the bitmap.
22:34:26 <Nereid_> well, [0..choose n k - 1]
22:34:38 <Pseudonym> Yes.
22:35:02 <Nereid_> but
22:35:05 <Nereid_> how useful is it? :)
22:35:10 <Pseudonym> Very, as it turns out.
22:35:14 <Pseudonym> Because it's entropy coded.
22:35:23 <Nereid_> if you know the number of set bits.
22:35:26 <Pseudonym> Right.
22:35:33 <Pseudonym> But there are plenty of circumstances where you do.
22:35:51 <Nereid_> such as?
22:36:04 <Pseudonym> I came across it when investigating succinct data structures.
22:36:35 <Pseudonym> OK, an example is when you need to store the number of set bits for other reasons.
22:37:16 <Nereid_> hmmm
22:37:19 <Pseudonym> For example, consider an inverted index.
22:37:36 <Nereid_> ok
22:37:42 <Pseudonym> You have some collection of documents [0..d-1], and a collection of words [0..w-1] which appear in those documents.
22:37:49 <Pseudonym> And you want to look up the documents by word.
22:37:56 <Pseudonym> Like the index in the back of a book.
22:38:10 <Pseudonym> You might want tos tore the number of occurrences of a word for computing statistics.
22:38:15 <Nereid_> I peeked at the wikipedia page for "inverted index", so
22:38:15 <Nereid_> ok
22:38:23 <Nereid_> ahh I see.
22:39:09 <Pseudonym> Another example is that you might know the number of set bits for other reasons.
22:39:44 <Pseudonym> Like, if you're representing a binary tree, and n is the number of elements in the tree, then there are n internal nodes and n leaf nodes.
22:40:19 <Pseudonym> So a succinct representation of the tree might mark each node with a bitmap with 2n bits, n of which are set.
22:40:31 <Pseudonym> Then you know which nodes are leaves and which are internal nodes.
22:40:48 <Optimo> #haskell getting popular...
22:41:05 <copumpkin> Optimo: :o
22:41:25 <Pseudonym> Anyway, writing decode is left as an exercise.
22:41:36 <Nereid_> hmmm
22:42:03 * absentia is new to [#]Haskell
22:42:11 <Optimo> ohai absentia
22:42:24 <Optimo> welcome to the hell of a thousand monads
22:42:50 <Makoryu> <Optimo> NO EXCEPTIONS
22:42:52 <absentia> I am looking for a language that allows me to get more done in less tie with fewer chances for (silly) bugs (and classes of bugs) -- but I would still like the language to be fast/efficient (as compared to c and c++)
22:43:09 <Nereid_> absentia: haskell sounds about right :)
22:43:14 <absentia> lolohai!
22:43:37 <Optimo> good call
22:43:48 <absentia> well, I took a wrong turn into scala ... but that just made me get (more) serious about haskell.. and I just havn't been able to motivate myself to get into lisp... i've tried and tried.
22:44:21 <Nereid_> I don't find lisp attractive
22:44:22 <absentia> don't laugh -- my fav language is Objective-C
22:45:01 * copumpkin laffs
22:45:05 <absentia> ner: I find it... intriguing.  I always hear that it's great for the things that I listed above... plus, it can do some functional...
22:45:30 <ivanm> @wn laff
22:45:34 <lambdabot> No match for "laff".
22:45:42 <Gracenotes> Haskell's syntax is refreshing. particularly after reading code in ML dialects
22:46:09 * copumpkin laffs at ivanm's unwordification
22:46:14 <absentia> hey, Obj-C gives me everything... I need.  low level, fast (efficient), dynamic... mega lib compat/bindings...  f'n brain dead easy/simple ... few issues. really.
22:46:34 <copumpkin> you need low level?
22:46:50 <copumpkin> most people don't need low level, it just hapens to be the only way to get speed for most languages
22:46:54 <Optimo> objective-J +
22:46:56 <Gracenotes> absentia: what platform?
22:47:12 * ski doesn't find the abstract syntax of SML and O'Caml that different from Haskell's
22:47:15 <absentia> iPhone.. ie: the only issue is damn manual mem management...
22:47:20 <Gracenotes> or, so to speak, development environment
22:47:22 <Optimo> obj-J is a low entry wall
22:47:59 <kosmikus> ski: you're programming in abstract syntax?
22:48:20 <ski> kosmikus : no. but often thinking in terms of it
22:48:50 <ski> (but there is something to say for a nice concrete syntax, as well)
22:49:28 <absentia> ya, I  like stack machines..  forth, etc.
22:49:45 <absentia> I just can't see ever doing day to day in forth.
22:49:57 <Pseudonym> @let decode max 0 x = []
22:49:57 <Pseudonym> @let decode max k x = let (n,cnk) = head [ (n,cnk) | n <- [0..max-k], let { cnk = choose (max - n - 1) k }, cnk <= x ] in n : decode max (k-1) (x-cnk)
22:49:58 <lambdabot>  Defined.
22:50:00 <lambdabot>  Defined.
22:50:07 <Pseudonym> > encode 10 [3,6]
22:50:13 <lambdabot>   18
22:50:13 <ski> (i guess i mean to say that i've heard people describe ML's (presumably O'Caml's ?) syntax as "ugly", and i don't really see that .. maybe a little clunky at times, but not ugly)
22:50:14 <Pseudonym> > decode 10 2 18
22:50:19 <lambdabot>   [3,6]
22:50:25 <ivanm> ski: concrete syntax... is that as in how to make something using cement, gravel, etc.? :p
22:50:59 <absentia> ski:  I don't like meaningful whitespace... but whatever....
22:51:43 <Nereid_> I don't mind it if it's done nicely
22:51:48 <kosmikus> ski: I think Haskell's syntax is nicer, but ML/Ocaml are still ok.
22:51:51 <Nereid_> I dont quite understand haskell's layout stuff
22:51:56 <Nereid_> I quite like python.
22:52:12 <kosmikus> ski: only thing I really dislike is postfix notation for type constructors
22:52:36 <ski> ivanm (: concrete syntax is how the abstract syntax is actually presented graphically/textually. like a rectangular grid of glyphs, or things like LabView, e.g.
22:52:44 <ski> (but i presume you knew that)
22:52:49 <absentia> I have gotten use to highlight+right-click and Re-Indent selection in xcode.  I've always been a gcc/emacs/tcsh dev, but for the iphone, I do like xcode.. people say it sucks and they hate it... but it seems better than eclipse -- although when checking out the latest android (cupcake) -- eclipse seems much improved over the last time I saw it -- but, my god is it bloated.
22:53:21 <ski> absentia : what is "meaningful whitespace" ? the application operator in haskell ? the composition operator in forth ?
22:53:30 <Nereid_> lol
22:53:48 <absentia> ner:  ya, I was referring to python... haskell seems more like lisp -- where indentation just keeps growing... python seems to have indentation gotchas due to the imperative steps...
22:53:55 <ski> (kosmikus : ok. that is slightly bothersome)
22:54:02 <Nereid_> "meaningful indentation" more like :P
22:54:04 <copumpkin> absentia: the good thing is that you can have no indentation if you really want!
22:54:04 <absentia> ski:   whitespace = variable scope
22:54:36 <absentia> copum: ?
22:54:51 <kmc> haskell's layout syntax is specified as a self-contained transformation to layout-free syntax, which uses braces and semicolons
22:54:56 <kmc> and is always available
22:55:13 <absentia> kmc: oh... ya... yuck.  it's at least readable with indentation.
22:55:15 * ski woukdn't usually call the scoping and nesting a part of the meaning (proper) .. rather one could say it describes the structure into which the meaning is filled
22:55:35 <kmc> it's important to have that alternative, which python doesn't
22:55:43 <kmc> and as a result some constructs like lambda are crippled
22:55:45 <absentia> kmc: agreed.
22:55:52 <mmorrow> kosmikus: ugh, yeah poostfix type constructors are ugly
22:57:00 <Makoryu> Pooostfix
22:57:30 <absentia> hey, I use that for my smtpd :-)
22:57:35 <mmorrow> it's like you're screaming as you fall off a building: "noooooooooo poooooooooooooooooooooosti<SPLAT>"
22:57:56 <mmorrow> *oostfi<SPLAT>"
22:58:01 <Nereid_> kmc: but braces and semicolons are uglier :P
22:58:04 * mmorrow just can't type
22:58:13 * ski finds it interesting that `unit cont list ref' still associates as `((unit cont) list) ref', though :)
22:58:44 <absentia> I don't.  I thinkthat association is what I'd assume.
22:59:09 <mmorrow> dolio: found the bug in lunabot's [$ty|, thanks to some prodding by aavogt
22:59:10 <absentia> ski: do you know forth?
22:59:22 <ski> absentia : in haskell, that would be `Ref (List (Cont Unit))', though ..
22:59:28 <mmorrow> dolio: lunabot wasn't using `tidyType'.. doh!
22:59:47 <ski> absentia : not really. i have played a little bit with it, and know the basics. but i wouldn't say i know it
22:59:57 <Nereid_> likewise here.
23:00:00 <mmorrow> dolio: so the tyvars that were printing as the same aren't really the same, and tidyType makes that explicit in the rep that gets printed
23:00:01 <Nereid_> well
23:00:04 <Nereid_> I haven't played with it
23:00:07 <Nereid_> but I get the idea.
23:00:18 <absentia> ditto.  but its like that --  blah blah blah blah BEWM . where BEWM does something with the results of blah blah blah.
23:00:46 <ski> mmorrow : nice !
23:00:49 <absentia>  swap/bury etc.
23:00:57 <mmorrow> , [$ty| either Right Left |]
23:00:59 <ski> absentia : not really
23:01:00 <lunabot>  forall a1 a . Either a a1 -> Either a1 a
23:01:11 <Nereid_> absentia: but _everything_ is postfix in forth, no?
23:01:18 <ski> Nereid_ : no
23:01:18 <absentia> ner: exactly.
23:01:31 <Nereid_> ski: no?
23:01:32 <ski> forth is a concatenative language. that is distict from having postfix operators
23:01:46 <absentia> unless you consider a single operator as not postfix.
23:01:53 <ski> with postfix operators, you can't express `5 dup *'
23:02:10 <ski> with stack-transforming concatenation, you can
23:02:30 <ski> (i.e. you "concatenate" by composing stack-transformers)
23:02:40 <Gracenotes> pointfree
23:02:55 <Nereid_> my point was, whenever you use something, it only acts on whatever was written before it
23:02:59 <Nereid_> thus, postfix
23:03:02 <Gracenotes> the points that are being connected are the functions, not the contents of the stack
23:03:03 <Nereid_> not postfix operators
23:03:30 <Gracenotes> er. or, I should say, the points that do not exist but are being connected anyway.  ...  meh.
23:03:39 <Nereid_> in my mind anyway. I guess you call that concatenative
23:04:09 <Gracenotes> s/connected/concatenated/
23:04:31 <absentia> http://www.spy.org/tmp/dragon.fs
23:04:47 <Gracenotes> also, quotations seems to be somewhat common in concatenative languages, but not merely a postfix feature
23:16:03 <Nereid_> I like pie
23:16:03 <Gracenotes> zork was originally written in forth, iirc
23:16:03 * absentia hasn't looked into the zmachine...
23:16:03 <generic> anyone here know how to execute "system commands" in haskell?
23:16:03 <generic> System.system :: String -> IO ExitCode
23:16:03 <generic> ^is that right?
23:16:03 <dazza_> wheres the code bucket thing?
23:16:03 <dibblego> System.Cmd
23:16:03 <dibblego> @where hpaste
23:16:03 <lambdabot> http://hpaste.org/
23:16:03 <Gracenotes> try it and see.. there is also POSIX stuff for unix
23:16:03 <generic> dibblego: is String an actual string?
23:16:03 <copumpkin> what's an actual string?
23:16:03 <generic> System.system :: "stuff -> IO ExitCode
23:16:03 <dibblego> generic, in as much as String is an actual String, sure
23:16:03 <generic> ^"stuff"
23:16:03 <dibblego> @hoogle system
23:16:03 <lambdabot> System.Cmd system :: String -> IO ExitCode
23:16:03 <lambdabot> module Distribution.System
23:16:03 <lambdabot> package system-inotify
23:16:03 <Gracenotes> mrowl
23:16:03 <generic> yeah that doesnt really help
23:16:03 <dibblego> what does help? what is a not-actual String?
23:16:03 <generic> look
23:16:03 <generic> System.system :: "stuff" -> IO ExitCode
23:16:03 <generic> ^would that work?
23:16:03 <dibblego> that's not legal syntax, so no
23:16:03 <generic> what would work?
23:16:03 <mmorrow> system "cat /dev/urandom | od"
23:16:03 <dibblego> let code = system "ls" -- this would work
23:16:03 <generic> could I this:
23:16:03 <mmorrow> generic: do you have ghci?
23:16:03 <generic> command = "reallycoolcmd" system command
23:16:03 <generic> mmorrow: no so I cant try i
23:16:03 <generic> mmorrow: and I cant get it right now
23:16:03 <mmorrow> generic: what are you using to compile haskell code?
23:16:03 <generic> mmorrow: Im not
23:16:03 <generic> but I will be later
23:16:03 <mmorrow> generic: so you're using #haskell as your compiler then? :)
23:16:03 <generic> and/or debugger yes
23:16:03 <mmorrow> @type command = "reallycoolcmd" system command
23:16:03 <lambdabot> parse error on input `='
23:16:03 <mmorrow> @type let command = "reallycoolcmd" in system command
23:16:03 <lambdabot> Not in scope: `system'
23:16:03 <dibblego> @type let code = system "ls" in code
23:16:03 <lambdabot> Not in scope: `system'
23:16:03 <mmorrow> @type let command = "reallycoolcmd" in System.Cmd.system command
23:16:03 <lambdabot> IO GHC.IOBase.ExitCode
23:16:03 <dibblego> @type let code = System.Cmd.system "ls" in code
23:16:03 <lambdabot> IO GHC.IOBase.ExitCode
23:16:03 <generic> hmm
23:16:03 <mmorrow> @type System.Cmd.system "reallycoolcmd"
23:16:03 <lambdabot> IO GHC.IOBase.ExitCode
23:16:03 <mmorrow> @type mapM System.Cmd.system ["halt","ls","date","reallycoolcmd"]
23:16:03 <lambdabot> IO [GHC.IOBase.ExitCode]
23:16:03 <generic> is the "type" an actualy haskell keyword or is that a bot cmd
23:16:03 <mmorrow> @vixen oh hai
23:16:03 <lambdabot> You know, it's a funny thing, every one of the bastards that are out for legalizing marijuana is Jewish. What the Christ is the matter with the Jews, Bob? What is the matter with them? I suppose it
23:16:03 <lambdabot> is because most of them are psychiatrists.
23:16:03 <mmorrow> :p
23:16:03 <mmorrow> s/:p/:o/
23:16:03 <mmorrow> is vixen nixon now?
23:16:03 <mmorrow> generic: anyways, yes @type is a bot cmd
23:16:03 <generic> thx
23:16:03 <mmorrow> generic: in ghci it'd be ":type" or just ":t"
23:16:28 <Makoryu> generic: Just for what little consistency we can have between ghci and the bot, you can also use :t here
23:16:30 <Makoryu> :t True
23:16:32 <lambdabot> Bool
23:16:43 <Makoryu> :t fmap Just
23:16:45 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (Maybe a)
23:17:18 <ski> > run $ lit 5 . dup . times
23:17:20 <ski> > run $ lit 3 . lit 4 . dup . times . swap . dup . times . plus . squareRoot
23:17:25 <lambdabot>   25
23:17:25 <lambdabot>   5.0
23:17:31 <absentia> nice.
23:17:39 <mmorrow> @type run
23:17:41 <lambdabot> forall o. ((o -> o) -> o) -> o
23:17:44 <mmorrow> heh
23:18:00 <absentia> ha!
23:18:05 <mmorrow> `o' is such a great tyvar
23:18:08 <ski> mmorrow : that should have been `(forall o. (a -> o) -> o) -> a', but it wouldn't let be use rank-2
23:18:09 <Makoryu> Ooooooo
23:18:11 <absentia> a little specific there.
23:18:15 <mmorrow> ski: grr
23:18:21 <ski> s/be/me/
23:18:35 <ski> @type swap
23:18:37 <lambdabot> forall b a o. (b -> a -> o) -> a -> b -> o
23:18:38 <ski> @type dup
23:18:40 <lambdabot> forall a o. (a -> a -> o) -> a -> o
23:19:42 <ski> in `(a -> a -> o) -> (a -> o)' the right-hand side `a -> o' is the input stack, `a' being the (type of) the top item and `o' is (or can here be thought of as) the rest of the input stack
23:20:01 <ski> the left-hand side is then the (type of the) output stack
23:20:07 <ski> this corresponds to
23:20:31 <ski>   dup ( a -- a a )
23:20:36 <ski>   swap ( a b -- b a )
23:20:50 <ski>   rot ( c b a -- b a c )
23:20:53 <ski> @type rot
23:20:55 <lambdabot> forall c a b o. (c -> a -> b -> o) -> a -> b -> c -> o
23:21:21 <ski> (actually, for `swap' that should be `( b a -- a b )' if we want to use the same variable names)
23:21:34 <|Steve|> ` and ' are really not matching quotes.
23:21:40 <ski> ty
23:22:12 <Zao> |Steve|: Which makes them nice for not confusing them with syntax.
23:22:22 <Zao> |Steve|: And if you do LaTeX, ``lol''
23:22:41 <|Steve|> Zao: I'm not TeX.
23:22:52 <absentia> still better than that \203 or whatever MS absolutely insists on using.
23:23:06 <Zao> absentia: Yes, because MS has a global standard on silly quoting?
23:23:14 <|Steve|> http://www.asciiartfarts.com/20070214.html
23:25:06 <absentia> exactly.
23:25:47 <Zao> If by "MS" you mean Office, then that's the fault of the Office team.
23:25:57 <eoeas> In Haskell, is the list of reserved words and operators also known as the language primitives ??
23:26:57 <copumpkin> I really wish I knew who the 808140 user on reddit and slashdot is
23:27:07 <copumpkin> (he's a haskell user)
23:27:32 <Adamant> sshhh. he's hiding.
23:29:36 <fffej> if I have a function foo of type String -> Int -> IO (String) and I want to make an infinite list by appending [(foo x y) (foo (foo x y))] and so on - how'd I do that?  I'm confused because I want to feed the output of foo (IO String) into foo, but I don't know how :(
23:30:30 <nornagon> fffej: that doesn't quite make sense
23:30:54 <nornagon> do you mean [(foo x y), (foo x (foo x y)] and so on?
23:30:55 <copumpkin> sounds like you want mapM to me
23:30:59 <fffej> nornagon: yeah, that's what the compiler says too :)
23:31:08 <nornagon> you need more arguments to foo :P
23:31:14 <ksf> why don't we have a javascript engine written in haskell?
23:31:28 <ski> Nereid_ : i would say the lisps are prefix languages, and haskell is to a large extent. ihmo postfix is what you get if you do more or less the same, except you say the operator/function is the last thing in every combination/application. cf. prefix vs. postfix traversals of trees
23:31:31 <fffej> I'll look up mapM and have a go at using that
23:31:32 <nornagon> ksf: because we have several really kickass ones written in C++?
23:31:40 <nornagon> fffej: check out foldM too
23:31:45 <|Steve|> fffej: the output of foo x y is IO String which you're trying to pass to foo.
23:31:54 <ksf> yeah but they ain't written in haskell.
23:32:02 <|Steve|> But foo takes two arguments, neither of which are IO String.
23:32:37 <nornagon> ksf: they sure are a lot faster than they could be when written in hs ;P
23:32:47 <fffej> |Steve| I'm confused how I move from the IO world and back again without all my code looking yucky
23:33:01 * ksf wouldn't take bets on that.
23:33:02 <|Steve|> You can't get values out of the IO monad.
23:33:08 <nornagon> there's just so much opti effort that's gone into v8 and javascriptcore that it's going to be a huge effort to match speed
23:33:18 <ski> fffej : maybe you want to use `unsafeInterleaveIO' to write a lazy monadic version of `iterate' for `IO' ?
23:33:28 <ksf> edsl'ing javascript and then compiling it with -O2 seems to be a promising idea.
23:33:40 <fffej> ski: yeah, but isn't "unsafeInterleaveIO" basically saying, I don't understand monads? :)
23:33:53 <fffej> (which I clearly don't!)
23:34:16 <ksf> unsafeInterleaveIO is saying "I want IO to be less strict and don't care about when stuff gets executed"
23:34:19 <ski> i'm not sure if that is really what you want. but it seems one could do what you described with it
23:34:52 <ski> (otherwise, you will never be done constructing the list, so you can never start to use the elements of it elsewhere)
23:35:06 <ksf> fffej, have a look at http://haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
23:35:17 <ksf> ...try to do it without unsafeInterleaveIO
23:35:18 <ski> another option that might fit into your situation is to use threads and pass the "elements" on a `Chan'
23:36:00 <fffej> thanks all - I'll investigate some of thee
23:36:04 <ski> ksf : that wouldn't work, right ?
23:36:22 <ski> @index Chan
23:36:23 <lambdabot> Control.Concurrent.Chan, Control.Concurrent
23:37:01 <ksf> ski, that's the point, it wouldn't even work if k is lazy in its first argument, as IO's bind is strict in its first.
23:37:33 <ksf> ...with unsafeInterleaveIO, stuff only blows if k is strict, which is unevitable, as IO's bind is strict.
23:38:21 * ksf thinks fixIO is the perfect example of how IO works.
23:38:28 <ski>   k :: String -> Int -> IO String  -- here ?
23:38:35 <ksf> k is a -> m a
23:38:46 <ksf> fixIO :: (a -> m a) -> m a
23:38:54 <ski> ok
23:38:56 <ksf> er s/m/IO
23:38:59 <|Steve|> What about iterateM f x = do y <- f x; return y:iterateM f y?
23:39:02 <ksf> that'd be mfix...
23:39:25 <ski> |Steve| : in "strict" monads, that doesn't terminate
23:39:58 <fffej> is it the laziness that is making my problem hard?
23:40:01 <|Steve|> @src ,fox
23:40:01 <lambdabot> Source not found. Wrong!  You cheating scum!
23:40:06 <|Steve|> @src mfix
23:40:06 <lambdabot> Source not found. You type like i drive.
23:40:14 <|Steve|> (off by one on the keyboard. =)
23:40:21 <generic> o.0
23:40:26 <ski> (assuming you wanted s/return y:iterateM f y/liftM (y:) (iterateM f y)/)
23:41:28 <ski> @src IO mfix
23:41:29 <lambdabot> mfix = fixIO
23:41:32 <ski> @src Maybe mfix
23:41:32 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
23:41:45 <ski> @type mfix
23:41:47 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:42:03 <ski> (it is a class member of `MonadFix')
23:43:04 <ski> fffej : at least i am not sure of what problem you want to solve
23:43:48 <fffej> ski: I'm trying to use markov chains to generate a stream of random text.  I have a map containing some data and want to select the values, based on the key (at random, which is why I've got an IO string)
23:44:38 <fffej> ski: so my function generates the next word based on the previous one, but because I've used "randomR" to select an element, I've ended up with IO(String) being the return value.  If it wasn't IO(String) I'd use iterate
23:44:48 <ski> if you want to lazily do `IO'-effects, such that only when examining the result list (step-by-step) will the `IO'-effects of your `foo :: String -> Int -> IO String' actually be performed (step-by-step), then `unsafeInterleaveIO' should do the trick
23:45:15 <ski> oh
23:45:22 <ski> @type randomRs
23:45:24 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
23:45:35 <ski> that function might be useful in your case
23:45:59 <ski> it generates an infinite list of random values, from a bound and a starting seed
23:46:38 <ski> you could possibly write a (non-`IO') recursive function that passes down the infinite list as an argument, stripping off one element at a time
23:46:41 <fffej> ski: aha, so I can pass that infinite list along and use it as the source of randoms in my functions?
23:47:17 <ski> or if you don't know before-hand how many random values you need at each step, then pass around the random seeds directly (instances of `RandomGen') above
23:47:44 <fffej> ski: thanks for the help, I'll give it a go!
23:47:45 <ski> fffej : so then, you only need to use `IO' at one place to initialize the random number generator
23:47:58 <ski> the recursive function itself need not be in `IO'
23:48:17 <ski> @type random
23:48:19 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
23:48:47 <ski> that one takes a generator and produces a random value and a new generator to use in the next step
23:49:31 <ski> @type newStdGen
23:49:33 <lambdabot> IO StdGen
23:49:48 <ski> can be used as the initial step, to obtain a generator to start from
23:58:43 <Gertm> how far off is haskell prime and how much will it differ from the 98 version?
23:59:58 <Cale> Gertm: I'm not sure how far off it is. The goal is, from what I understand, just to standardise things which are already implemented in GHC.
