01:01:03 <copumpkin> hlist is handy but the API is rather ugly in my opinion
01:08:56 <ivanm> what's hlist?
01:10:05 <Baughn> ivanm: An attempt at creating a new record syntax, apparently
01:10:07 <dibblego> heterogeneous list
01:10:14 <ivanm> ahhh
01:35:57 <Phyx-> hmmm anyone know an encryption algorithm that outputs fixed 8 byte length output?
01:36:14 * earthy does not understand the question
01:36:26 <elbar> des
01:36:26 <koala_man> sounds more like a hashing algorithm
01:37:40 <Phyx-> well, I kinda forgot my password to a microsoft .MIG file. and i'm attempting to reverse engineer it and retreive my password. But as far as i can tell, the password is stored in 8 bytes
01:37:56 <earthy> elbar: DES is a 64-bit block cipher, which would fit with 8 byte blocks, but 'fixed 8 byt length output' sounds weird.
01:38:34 <Phyx-> i seriously doubt microsoft would be using DES though
01:38:55 <elbar> to complicated for the i think ;)
01:39:05 <det> by "recover" do you meam crack using a word list ?
01:39:08 <elbar> prolly a simple 64 bit xor
01:39:10 <jsoffer> Phyx-: pigeonhole principle says that any encryption algorithm can output fixed 8 byte length output, as long as the input is short enough.
01:39:16 <koala_man> if it's 8 bytes, it's probably a stupid custom algorithm
01:39:24 <earthy> um. um. whoa. :)
01:39:36 <Phyx-> det: I have what i think is the password, i just don't remember the case i think, so it would be more a permutation attack
01:40:01 <koala_man> Phyx-: what's a .mig file anyways?
01:40:03 <Phyx-> i entered the password at like 4am, forgot it :|
01:40:22 <Phyx-> koala_man: it's the format used by the windows easy transfer wizard
01:40:54 <Phyx-> koala_man: well, that's exactly my fear, that it's a custom algorithm
01:40:56 <koala_man> Phyx-: why is the password stored at all? isn't the file encrypted? can you replace the password field and thus change the password?
01:41:06 <Cale> https://mollyrocket.com/11235 hehehe
01:41:24 <det> Phyx-, cant you just manually type the password a bunch of times? :-)
01:41:49 <Phyx-> koala_man: well, no, since the content in the file is encrypted using the password, if i replaced it with some kind of injection, it still wouldn't allow me to decrypt the content
01:41:54 <Phyx-> det: it's like a 25char password!
01:42:05 <ivanm> Cale: lol
01:42:11 <Phyx-> i've been thinking of maybe just automating the gui though
01:42:17 <koala_man> Phyx-: maybe you're looking at the IV rather than the password then
01:42:19 <det> Phyx-, is it 8 bytes binary, or encoded in hex or something
01:43:33 <det> I would be surprised if MS stored a password in 8 bytes unsalted
01:44:29 <Phyx-> it's 8 bytes hex
01:45:18 <Phyx-> but i'm wondering if the format changed between vista dn windows 7... since the part i attributed to image header has a byte different in the files generated in win7 and vista
01:45:35 <Cale> Huh... if I ask Wolfram Alpha for "Pluto density / Moon density" I get 0.6, and if I ask it for "1/(Pluto density / Moon density)", I get 2.
01:46:09 <Phyx-> rounded up maybe?
01:46:26 <det> try 1.0/... ?
01:46:34 <ivanm> Cale: this is better: http://chrishecker.com/Kurt_G%C3%B6del_is_Laughing_His_Ass_Off_Right_Now
01:46:38 <ivanm> (linked off the other one)
01:46:58 <koala_man> Phyx-: apparently there's an internal ms migrecover tool floating around that you can invoke from a cli with the password. if you don't have too many passwords to try, maybe that'll help
01:46:59 <Cale> det: That seems to have worked.
01:47:05 <Cale> det: very strange.
01:47:29 <Cale> It gives 1.672 as the result then.
01:47:47 <dolio> > 1/1.672
01:47:48 <lambdabot>   0.5980861244019139
01:47:48 <det> it probably thinks you want an integer result when all your literals are integers ?
01:48:07 <ivanm> det: it must be using python then...
01:48:08 <ivanm> ;-)
01:48:12 <Phyx-> koala_man: yeah, guess i have no choice, i really need my calendar back
01:48:32 * ivanm had heaps of problems explaining to students that you need to add ".0" to a number to get proper division
01:48:37 <ivanm> s/add/append/
01:48:59 <dolio> "Stephen Wolfram is the creator of Mathematica and is widely regarded as the most important innovator in scientific and technical computing today." <-- The book really says that?
01:49:15 <Phyx-> ivanm: isn't the backend just mathematica itself?
01:49:39 <Cale> det: Doesn't seem as simple as that... adding 1 instead of taking 1/... gives 1.6
01:49:44 <ivanm> Phyx-: of alpha? apparently...
01:49:59 <ivanm> dolio: one of my professors recommended I read NKOS
01:50:01 <ivanm> so I did
01:50:20 <ivanm> and skipped most of it because it was full of "This is great, everyone else is wrong, we should only consider cellular automata and nothing else"
01:50:26 <ivanm> oh, and apparently he even stole that idea
01:50:45 <ivanm> (the talk page for stephen wolfram on wikipedia even has a claim that he stole mathematica...)
01:51:00 <dolio> Oh, yeah, I've heard that.
01:51:00 <Phyx-> hehe
01:51:30 <dolio> Or, more accurately, he worked on it in college with several other people, and then out-maneuvered them when it came to privatizing it.
01:52:10 <Cale> https://mollyrocket.com/11173 -- this one is also pretty funny :)
01:52:27 <ivanm> feynman thought wolfram was brilliant? :o
01:52:45 <ivanm> if this is true, then I no longer know what to think about feynman... :(
01:53:35 <Phyx-> so.. It's a good thing i didn't buy wolfram's book then?
01:54:19 <ivanm> Phyx-: yup
01:54:27 <ivanm> did you waste your money on his software?
01:54:29 <Cale> It's available online if you're interested.
01:54:39 <Phyx-> ivanm: nah, free license from uni
01:54:48 <ivanm> Cale: so are a great many other books... legality is an issue of course :p
01:54:51 <Cale> Mathematica is actually pretty cool, but paying for mathematica is not as cool.
01:54:58 <RayNbow> hmm...
01:55:01 <Phyx-> Cale: yeah, i've read it online, or a few pages
01:55:08 <Phyx-> ivanm: no, it's on wolfram's own site
01:55:09 * ivanm tried mathematica a few times; couldn't get the hang of the interface, and didn't like the syntax
01:55:16 <ivanm> Phyx-: heh
01:55:23 <Phyx-> yeah, the syntax is a odd one
01:55:25 <ivanm> does the online version have grandiose claims in the intro?
01:55:29 <Phyx-> but once you get used to it, it's pretty handy
01:55:35 <Cale> http://www.wolframscience.com/nksonline/toc.html
01:55:52 <Cale> I always thought the syntax was not so bad.
01:55:59 <dolio> That response to the query "how to program" is pretty amazing.
01:56:06 <Phyx-> the only stickler for me, is how to define a function
01:56:16 <Phyx-> f[_x]=x*x is a bit odd
01:56:20 <Cale> f[x_]
01:56:25 <ivanm> what does the underscore denote?
01:56:29 <RayNbow> @let plutoMeanDensity = 2.03    -- g/cm3
01:56:29 <RayNbow> @let moonMeanDensity = 3.346    -- g/cm3
01:56:29 <RayNbow> > plutoMeanDensity / moonMeanDensity
01:56:30 <lambdabot>   Not in scope: `plutoMeanDensity'Not in scope: `moonMeanDensity'
01:56:30 <lambdabot>  Defined.
01:56:31 <lambdabot>  Defined.
01:56:41 <Cale> It denotes that it's a pattern and not the literal x
01:57:06 <RayNbow> wait... it tried to evaluate the Haskell expression before the definitions?
01:57:15 <dolio> Incidentally, Xah Lee is quite enamored with mathematica, and thinks it's an example of a language with all the good points of lisp, without the bad (as I recall).
01:57:29 <RayNbow> > plutoMeanDensity / moonMeanDensity
01:57:30 <Phyx-> ah right, it's x_ , lol i had _x
01:57:31 <lambdabot>   0.606694560669456
01:57:51 <Cale> One fun way to get memoisation in mathematica is to write f[x_] := f[x] = ...
01:58:46 <Phyx-> Cale: btw, in mathematica 6 they seem to have removed WalkD and RunD, know what the alternatives are? (deriviations)
01:59:01 <det> Xah Lee thinks Mathematica is great and Jon Harrop thinks it is terrible... It's like clash of the trolls
01:59:06 <jsoffer> @let foo = 42
01:59:07 <lambdabot>  Defined.
01:59:13 <jsoffer> > foo
01:59:13 <lambdabot>   42
01:59:16 <Cale> Phyx-: I'm not sure I ever used those... what were they?
01:59:54 <dolio> det: I seem to recall Lee offering to port any benchmark to mathematica and prove that it can perform was well as OCaml or something.
02:00:04 <dolio> Good times.
02:00:13 <Phyx-> Cale: both calculate the derivation of the given formula, except runD would only give answers, and WalkD would also give the intermediate steps it wook and the rules it applied
02:00:40 <Cale> Phyx-: hum, I've never heard of that.
02:01:04 <jsoffer> @let bar = 5 -- bar
02:01:05 <lambdabot>  Defined.
02:01:35 <Cale> http://documents.wolfram.com/mathematica/Demos/Notebooks/Step-by-StepDifferentiation.html
02:01:39 <ray> more evidence that the word "troll" should just stop being used: someone called xah lee a troll, when he is clearly a crank
02:02:29 <Cale> Phyx-: Seems like they're defined specifically in that notebook.
02:02:31 <Phyx-> Cale: yeah, but like the top banner states "THIS IS DOCUMENTATION FOR AN OBSOLETE PRODUCT."
02:02:39 <det> Ya, I dont really think either is a true troll
02:02:41 <ivanm> Cale: so pattern matching for x in mathematica is equivalent to the haskell [y] | y == x ?
02:02:48 <det> and I agree with a lot of the things that Jon says
02:03:00 <ivanm> det: doesn't harrop like mathematica because it's apparently written in ocaml?
02:03:03 <ray> i think harrop just has a terrible communication style
02:03:15 <det> ivanm, No, he thinks it is too slow for practical work
02:03:20 <Cale> ivanm: no brackets in the Haskell version
02:03:20 <ivanm> ahhh
02:03:23 <dolio> ivanm: No, he rewrote mathematica in OCaml over a weekend.
02:03:29 <ivanm> Cale: oh, it wasn't a list?
02:03:33 <ivanm> dolio: ahhh
02:03:47 <ivanm> det: and because he can't any money selling mathematica books? :p
02:03:47 <Cale> ivanm: Right, square brackets denote function application
02:03:51 <ivanm> *nod*
02:03:52 <ray> to be a troll, they'd have to, at a minimum, not believe what they were saying
02:04:00 <Cale> ivanm: Lists are denoted by curly braces, and parens are used only for grouping.
02:04:00 <ray> i think they both believe all of it
02:04:05 <ivanm> Cale: just to be different from every other language on the planet?
02:04:17 <ivanm> ray: so they're fanatics?
02:04:26 <Cale> ivanm: Mathematica looks like how lisp was supposed to look.
02:04:27 <ray> possibly
02:04:39 <ivanm> Cale: :o
02:04:53 <Cale> ivanm: It uses M-expressions which were described in some of the original papers on lisp.
02:05:00 <det> ray, I think Jon is sometimes dishonest
02:05:31 <Cale> ivanm: But then the lisp programmers decided that they liked programming directly in S-expressions, and M-expressions went away.
02:05:36 <ivanm> Cale: *nod*
02:06:54 <ray> the consultancy-promotion thing probably complicates matters
02:07:25 <ray> haskell syntax should call itself h-expressions
02:07:41 <ivanm> heh
02:07:54 <ray> take that, lisp
02:08:19 <dolio> There's no l-expression, though.
02:08:51 <ray> or maybe something-expressions should be reserved for haskell expressions with no infix operators
02:13:26 * ksf wonders how to load a plain and simple bitmap into xrender
02:22:07 <Raevel> have you seen http://www.cs.chalmers.se/~koen/Lava/
02:22:20 <etpace> Hmm, I'm trying to wrap DateTime with a 'workday' and Event {start :: Workday, end :: Workday}, so that if I have a workday 9am-5pm, and I create an event for 5 hours at 4pm, it would create two events of 4pm -> 5pm, 9am -> 1pm, but I can't think of a way to do this
02:23:21 <Raevel> so, afterwards there will be now way of nowing how long the event is?
02:23:27 <Raevel> knowing*
02:24:15 <etpace> well, you could diffmins the start and end of each event and add them
02:26:49 <Raevel> if there is not enough room in the current workday, get the next one, subtract hours, iterate if hours still remain
02:27:15 <etpace> hmm, thanks
02:27:16 <Raevel> of course, that can be reduced to just one arithmetic expression
02:27:49 <Raevel> gtg
02:34:48 <pozic> On this page, the only piece of creativity is saying that combining an Exit computation with a Continue computation produces e. That should take a few lines at most. http://www.haskell.org/haskellwiki/New_monads/MonadExit Is anything in Haskell' going to fix that?
02:37:57 <quicksilver> what's your point, pozic? You think MonadExit should be in the new prelude?
02:38:43 <quicksilver> it used fundeps so that's unlikely.
02:39:24 <PeakerWork> @src MonadExit
02:39:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:39:32 <dolio> Exit is Either without the Error stuff.
02:39:47 <PeakerWork> dolio: MaybeT?
02:40:00 <dolio> The T is ErrorT.
02:40:06 <quicksilver> follow the link pozic gave to see it.
02:40:52 <quicksilver> it's Either with a different interpretation - a normal return value means 'incomplete computation' and an exit value means 'stop now we're done'
02:42:07 <dolio> Due to fail in Monad, Either's instance is restricted to parameters in an Error class, so that you can always throw using a string.
02:42:48 <quicksilver> dolio: even that issue aside there is a different intended interpretation.
02:43:03 <quicksilver> dolio: the type of 'runExit' exemplifies it, I guess
02:43:14 <dolio> Ah.
02:43:17 <quicksilver> runExitT :: Monad m => ExitT e m a -> m e
02:43:27 <quicksilver> runErrorT :: Monad m => ErrorT e m a -> m (Either e a)
02:44:04 <quicksilver> the "Left" - which they call "Exit" - doesn't mean "somethign when wrong" it means "succesful completion"
02:44:27 <quicksilver> and not exiting is considered a programming error ;)
02:44:33 <dolio> Well, "Left" doesn't mean something's wrong, either. :)
02:45:07 <PeakerWork> quicksilver: reminds of Python's else clause on loops
02:45:07 <pozic> quicksilver: no, the problem is all the boiler plate code.
02:45:50 <PeakerWork> quicksilver: for x in something: { if good(x): break } else: raise Error("Found no good!")
02:46:13 <PeakerWork> (else only runs if no break)
02:47:00 <ksf> are there some standard functions to marshal a char* into a [Word8] or an array, or do I have to reinvent the wheel?
02:47:21 <PeakerWork> @hoogle CString -> [Word8]
02:47:21 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
02:47:21 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
02:47:21 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
02:48:35 <ziman> Data.ByteString.Internal, maybe?
02:48:40 <ksf> ouch.
02:48:50 <ksf> nevermind, standard functions aren't going to work, anyway.
02:48:51 <PeakerWork> ksf: Data.ByteString.packCString
02:48:56 <PeakerWork> @hoogle ByteString -> [Word8]
02:48:56 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
02:48:56 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
02:48:56 <lambdabot> Data.ByteString head :: ByteString -> Word8
02:49:02 <ksf> ...I've got a pitch here that may be negative.
02:49:20 <PeakerWork> @type Data.ByteString.unpack `fmap` Data.ByteString.packCString
02:49:21 <lambdabot>     Couldn't match expected type `BSC.ByteString'
02:49:21 <lambdabot>            against inferred type `IO BSC.ByteString'
02:49:21 <lambdabot>       Expected type: Foreign.C.String.CString -> BSC.ByteString
02:49:51 * ksf doesn't want to use strings
02:50:03 <ksf> I've got bitmap data here.
02:50:57 <ziman> bytestrings are designated for binary stuff, afaik
02:51:09 <PeakerWork> what module is BSC?
02:51:30 <ziman> ByteString.Char8?
02:51:35 <PeakerWork> ksf: ByteString is just an unboxed array of Word8, or a lazy list of such
02:51:44 <PeakerWork> @type ByteString.Char8.pack
02:51:45 <lambdabot> Couldn't find qualified module.
02:52:00 <ziman> Data.ByteString.Char8, that is
02:52:43 <PeakerWork> @type Data.ByteString.Char8.pack
02:52:43 <lambdabot> String -> BSC.ByteString
02:52:56 <PeakerWork> @type (BSC.unpack `fmap`) . BSC.packCString
02:52:57 <lambdabot> Foreign.C.String.CString -> IO [Char]
02:53:10 <PeakerWork> how do you unpack a Char8 bytestring into [Word8]
02:54:36 <PeakerWork> Why is BS.Char8 a different type, rather than just a different set of functions?
02:56:04 <ksf>     let line rp = mapM (peekByteOff rp) [0..w]
02:56:04 <ksf>     buf' <- concat <$> mapM (\y -> line (buf `plusPtr` (y*pitch))) [0..h]
02:56:20 * ksf just hopes it won't segfault and moves onto other tasks
02:56:37 <ivanm> :o this guy claims C++ is type-safe: http://www.johndcook.com/blog/2009/09/15/linus-torvalds-cpp/
02:56:45 <ksf> PeakerWork, the point is that I've got a 2d-array where rows may be aligned to some boundary.
02:56:51 <ziman> maybe `map Data.Bytestring>internal.c2w . unpack'
02:56:52 <ksf> ...and they may be in backwards order
02:58:55 <quicksilver> pozic: no, there are no proposals to reduce that.
02:59:00 <quicksilver> pozic: please make one, if you have one.
02:59:16 <ksf> huh. linux is really better off without c++ coders that write books about constructors and destructors...
02:59:30 <quicksilver> PeakerWork: it's not really a different type it just pretends to be
02:59:52 <ivanm> quicksilver: have you ever come across the problem when using ghci through emacs of "lexical error in string/character literal at character '\EOT'" from long inputs?
03:00:28 <quicksilver> yes.
03:00:45 <ivanm> any idea how to fix it?
03:00:54 <quicksilver> when it happened to me, it was because the pty implementation on my OS was chopping off lines at some maximum length
03:01:03 <quicksilver> IIRC it was 1024 bytes but it might have been something else.
03:01:11 <quicksilver> the solution is to switch to a better OS.
03:01:29 <ivanm> oh, I don't think that's my problem here...
03:01:29 <mlesniak> quicksilver, simple one ;)
03:01:30 <ivanm> AFAICT, the problem is meant to be with comint-mode used by inferior-haskell
03:01:51 <ivanm> (derived from looking here: http://hackage.haskell.org/trac/ghc/ticket/3256)
03:03:06 <ksf> yay!
03:03:25 <ksf> It didn't segfault.
03:03:32 <quicksilver> ah, looks different to my one, yes :)
03:03:43 <PeakerWork> quicksilver: it seems to hinder rather than aid
03:03:55 <PeakerWork> quicksilver: I can't see how to convert Data.ByteString.Char8.ByteString -> [Word8], for example
03:04:20 <quicksilver> PeakerWork: use the unpack routing from the non-Char8 version
03:04:28 <quicksilver> PeakerWork: (but why do you have the wrong type anyway?)
03:04:44 <ivanm> it must be an emacs issue, because the same commands definitely work when running ghci in a term
03:04:50 <PeakerWork> @type Data.ByteString.packCString
03:04:51 <lambdabot> Foreign.C.String.CString -> IO BSC.ByteString
03:04:56 <PeakerWork> quicksilver: because of this
03:05:05 <ivanm> (and I spent _ages_ trying to work out where I had an EOT in the String I was trying to pass in...)
03:05:25 <PeakerWork> @type (Data.ByteString.unpack `fmap`) . Data.ByteString.packCString
03:05:26 <lambdabot> Foreign.C.String.CString -> IO [Word8]
03:05:39 <PeakerWork> quicksilver: oh, I thought that was not possible, I made a different type error before
03:05:43 <quicksilver> ;)
03:16:40 <sinelaw> A question about transforming definitions (pattern matchings) into cases: why do we need fatbar? can't we use let?
03:17:18 <pozic> GHC cannot construct the following infinite type. Still, I have the feeling that I do want to have that type: http://paste.debian.net/46664/ Is there a way to construct that type?
03:17:44 <dolio> Wow.
03:18:13 <pozic> dolio: ?
03:18:30 <dolio> You can manually wrap infinite types.
03:18:45 <pozic> You mean like newtype Inf = Inf Inf
03:18:51 <dolio> e = F e becomes 'newtype Wrap = Wrap (F Wrap)'
03:19:20 <dolio> That's one hell of an infinite type, though.
03:19:43 <pozic> Ok, I will try that. This is the first time that I have to do that. Is that simply the way things are? That sometimes you really need an infinite type?
03:20:07 <dolio> Yes, it's possible.
03:20:30 <pozic> If I rewrite it without infinite types, I have to inline my StateT.
03:20:49 <pozic> Or in general, it will be impossible to compose with other *Ts.
03:20:53 <dolio> Storing escape continuations in a data structure is one of the situations where that comes up.
03:21:08 <pozic> dolio: ok, great. I thought I was going crazy.
03:21:08 <dolio> Which is what it sort of looks like you're doing.
03:21:38 <dolio> Or, storing escape continuations in a data structure that's referenced in the type of the escape continuation.
03:22:12 <pozic> Well, I will try to construct this infinite type.
03:22:36 <PeakerWork> sinelaw: maybe #ghc will know better?
03:22:50 <sinelaw> i'll try
03:22:58 <quicksilver> pozic: well, lists are an infinite type
03:23:12 <quicksilver> pozic: l = Nil | Cons a l
03:23:35 <quicksilver> pozic: infinite types aren't relaly unusual, it's just you have to name them in H-M type inference
03:23:36 <dolio> Yeah, any recursive type would be infinite if you tried to build it directly from sums and products.
03:23:55 <pozic> quicksilver: hmm, yes. So, it's just implicit infinite types that are "bad"?
03:24:00 <quicksilver> yes
03:24:07 <quicksilver> it's really just a limitation of the type inference.
03:24:20 <quicksilver> it's possible to infer this kind of types - it's called equirecursive inference, I think/
03:24:24 <quicksilver> ocaml has an option for it.
03:24:41 <quicksilver> it has the surprising property that almost everything you can write down, succesfully type checks with some weird type
03:24:44 <dolio> Infinite types typically show up when you make typos, though, so it's practically useful to disallow them by default.
03:24:47 <quicksilver> so the type checker becomes unhelpful :)
03:25:10 <pozic> quicksilver: but you can still inspect the type later and see that it is a weird type, no?
03:25:13 <quicksilver> there is a great mailing list posting which I can never find where someone shows 9 possible typoes and each of them infers an (ever mor complex) infinite type.
03:25:16 <quicksilver> agreed.
03:25:27 <pozic> quicksilver: Andrew Bromage
03:25:32 <pozic> quicksilver: saw it yesterday
03:25:47 <quicksilver> good :)
03:25:53 <pozic> http://www.nabble.com/There's-nothing-wrong-with-infinite-types!-td7713737.html
03:26:53 <quicksilver> not actually the one I meant, because the one I meant displayed the types in ocaml -rectypes, but certainly that general idea.
03:27:56 <sinelaw> PeakerWork, ghc uses let, not fatbar.
03:29:01 <PeakerWork> sinelaw: ah
03:31:01 <Cale> sinelaw: er, what do you mean by 'let' here?
03:31:32 <Cale> sinelaw: 'let' doesn't ever cause evaluation to occur, 'case' does
03:31:41 <Cale> and I'm not sure what fatbar is :)
03:32:01 <sinelaw> Cale, as in SLPJ's book, chapter 5 (by Wadler). brb 10 minutes.
03:32:06 <Cale> ah
03:41:31 <ivanm> Cale: with the stuff I was asking you yesterday about handles... would you know any reason why it would be bad to just have a function that was "blah -> IO String", and then just did writeFile on that String? (even if the String is binary image data)
03:42:24 <dobblego> Kleisli IO blah String
03:42:54 <ivanm> Kleisli?
03:43:03 <ivanm> @hoogle Kleisli
03:43:03 <lambdabot> Control.Arrow newtype Kleisli m a b
03:43:03 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
03:43:03 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
03:43:19 <Cale> ivanm: If it's binary image data, you're better off using ByteString
03:43:19 <dobblego> just making a passing comment; I've no idea what you're talking aboot :)
03:43:28 <Cale> ivanm: Apart from that, it should be okay.
03:43:33 * ivanm has no idea what Kliesli is, dobblego's use of it in the scalaz.http stuff shown last night to the contrary
03:43:44 <ivanm> Cale: I need String output as well, which is why I'm asking
03:43:46 <pozic> It appears that my first infinite type works. I am so happy right now :) Thanks, dolio, quicksilver.
03:44:12 <ivanm> IIRC, that's the reason I was using Handle stuff in the first place (someone said I should since I wanted to file and to String as well)
03:44:25 <ivanm> dobblego: heh
03:44:26 <Cale> ivanm: Very very soon, the readFile/openFile/etc. for String will do text decoding on the file that you've read.
03:44:40 <ivanm> which means?
03:44:45 <ivanm> I don't need openFile...
03:44:52 <quicksilver> ;)
03:44:59 <ivanm> just writing files, and reading String output
03:45:07 <Cale> ah
03:45:34 <Cale> Well, if the set of Chars corresponds to a string of bytes, and you're writing...
03:45:40 <quicksilver> ivanm: Kleisli IO Blah String is just "Blah -> IO String"
03:45:48 <quicksilver> ivanm: that's all you need to understand :)
03:45:51 <Cale> hmm, well, it'll be UTF-8 encoded by default, so I think some bytes won't be okay
03:45:52 <ivanm> quicksilver: ahhhh
03:45:55 <ksf> @seen aslatter
03:45:55 <lambdabot> Unknown command, try @list
03:46:03 <ksf> @botsmack
03:46:03 <lambdabot> :)
03:46:03 <lunabot>  :o
03:46:11 <ksf> preflex, seen aslatter
03:46:11 <preflex>  Sorry, I haven't seen aslatter
03:46:15 <ksf> preflex, seen alatter
03:46:15 <preflex>  Sorry, I haven't seen alatter
03:47:10 <Cale> ivanm: So: don't use writeFile for writing binary data. Either use openBinaryFile and hPutStr, or use Data.ByteString
03:47:53 <ivanm> Cale: yes, but I need the ability to have it become IO String as well
03:47:55 <ksf> grrr xhb just dies on me, not giving an error
03:47:58 <ivanm> for internal parsing purposes
03:48:09 <ivanm> http://hackage.haskell.org/packages/archive/graphviz/2999.5.0.0/doc/html/src/Data-GraphViz-Commands.html#graphvizWithHandle <-- the function I'm wanting to fix/re-write
03:48:13 <ksf> ...and I've got no idea what I'm doing wrong.
03:48:28 <ksf> ...only that it doesn't die if I don't do what I'm attempting to do.
03:48:34 <quicksilver> Cale: there will be a writeBinaryFile won't there?
03:48:58 <Cale> quicksilver: I don't know. Possibly?
03:49:17 <Cale> Seems natural that it should exist, except that String isn't really appropriate for binary data.
03:52:27 <quicksilver> Cale: well maybe it could have some other type :)
03:52:33 <quicksilver> Cale: perhaps even bytestring...
03:52:49 <quicksilver> or perhaps [Word8]
04:01:30 <PeakerWork> http://www.e-pig.org/downloads/epigram-notes.pdf  Can someone help with the notation here?  Page 2 has  [ s / x ]T     what does that mean?
04:02:03 <sinelaw> PeakerWork, that means expression T with s replacing x
04:02:27 <PeakerWork> sinelaw: thanks
04:02:28 <sinelaw> something like, if is T x = ..., then [s/x]T = T s
04:03:10 <sinelaw> at least that's what i think it means :P
04:04:46 <ivanm> dobblego: any suggestions on how I can improve this function (the problem is that the handles sometimes get closed before they've finished being used, and the a `seq` bit isn't good enough to prevent that): http://hackage.haskell.org/packages/archive/graphviz/2999.5.0.0/doc/html/src/Data-GraphViz-Commands.html#graphvizWithHandle
04:05:53 <PeakerWork> sinelaw: it makes sense
04:08:20 <Phyx-> dcoutts: btw, the windows installer you gave me yesterday, lacks the glade package
04:11:20 <ksf> xcb is seriously underdocumented.
04:14:52 <Saizan> ivanm: that means f uses lazy I/O, so it should be f's responsability to not return before it has read the thing
04:15:05 <ivanm> Saizan: right
04:15:27 <ivanm> but is there a better way to right that function so that I don't have to worry about lazy I/O or even do away with handles?
04:16:02 <Saizan> maybe readProcess
04:16:09 <ivanm> @hoogle readProcess
04:16:09 <lambdabot> No results found
04:16:12 <ivanm> :(
04:16:30 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html#v%3AreadProcess
04:16:48 <Saizan> or readProcessWithExitCode which is just after it
04:16:56 <Saizan> it will read the output strictly
04:17:39 <ivanm> problem with readProcess is that one of the usages of graphvizWithHandle is to write an image...
04:17:47 <ivanm> *write an image to file
04:18:12 <ivanm> and Cale, etc. were saying before that using String for that is what is commonly known as _bad_
04:18:42 <sinelaw> PeakerWork, ok i have a package of GHC from darcs, including my warning. it's 99M
04:18:46 <ivanm> maybe use waitForProcess?
04:26:30 <Phyx-> hmm anyone know a simple language for like specifying rules?
04:26:35 <Phyx-> or constraints
04:27:04 <mlesniak> Before I look through all games on hackage: Anyone knows a game which uses OpenGL, is designed well and its source code comprehensible?
04:27:19 <mlesniak> (or any other interactive OpenGL application)
04:27:29 <Zao> As it's Haskell, I'd doubt that there's anything satisfying the last requirement :P
04:27:37 <mlesniak> *laughs*
04:27:54 <mlesniak> Zao, ok, at least let's say documented :D
04:28:25 <Zao> I can tell you, my GL xtris implementation does _not_ qualify for the latter two.
04:29:17 <mlesniak> Hmmm, that helps, too :) One less on the list to look at :P
04:29:39 <kosmikus> mlesniak: I wanted astrds to fill that gap, but I'm not sure if it's quite there yet.
04:30:26 <kosmikus> mlesniak: anyway, if you have a look, please let me know what you think.
04:30:30 <mlesniak> kosmikus, Hmmm, will take a look at it
04:30:43 <Jafet> Computer games, pushing new boundaries in the field of accessible haskell
04:30:49 <quicksilver> mlesniak: do you know opengl outside of haskell?
04:31:40 <Saizan> ivanm: look at readProcess's source code, and rewrite it with ByteString ?
04:32:01 <tobier> hi all, I need some help with IO:
04:32:07 <mlesniak> quicksilver, not really, this is why I'd like to see some examples, been through some of the opengl tutorials on the wiki but would like some real-world examples
04:33:30 <tobier> I want to take input from STDIN one line at the time, run them through a certain function I have, and continue until I reach EOF. When I reach EOF, I want to return all those lines in a list
04:33:42 <ivanm> Saizan: but I _also_ need String output for parsing purposes...
04:34:27 <mlesniak> tobier, maybe take a look at interact
04:34:54 <tobier> mlesniak: will it allow me "accumulate" my returns, so to speak :P
04:35:51 <mlesniak> tobier, not directly, thought you'd like to read from stdin, sorry.
04:36:09 <tobier> well, let me clarify in more detail
04:36:19 <fbru02> tobier : sounds like state monad ?
04:38:05 <tobier> I take two lines from stdin, and then I run them through a function that returns a datatype, lets call it Foo, so I want to go through the whole input I get from STDIN and return these types in a list
04:38:33 <tobier> that is, IO [Foo], and when I reach EOF I just want to halt the function there
04:39:09 <tobier> my problem is, I don't really know how to "accumulate" the Foo's in a list
04:39:47 <quicksilver> recursion
04:39:48 <tobier> so basically, when I reach EOF I just want that list back, so I can extract these Foo's from it in another function
04:39:59 <quicksilver> pass the list so far as a parameter to yourself and call yourself
04:40:13 <fbru02> quicksilver is right
04:40:43 <quicksilver> getFoos sofar = do ... do some processins, make a foo .. ; getFoos (newfoo : sofar)
04:40:54 <tobier> well I want to function to have the type :: IO [Foo]
04:41:11 <tobier> *return type
04:41:15 <tobier> will that do it?
04:41:22 <quicksilver> well you'll need a case which stops ;)
04:41:27 <quicksilver> the stopping case will look like:
04:41:46 <quicksilver> if (end of file) then (return sofar) else (....)
04:42:17 <tobier> right right, I think I got confused with STDIN
04:42:31 <quicksilver> getFoos sofar = if (eof) then (return sofar) else do ..... processing ... getFoos (newfoo : sofar)
04:42:52 <tobier> I defined my function as: function = do {.. some stuff return (lines processing); function;}
04:43:05 <tobier> I just need a paramter, that was easy :)
04:43:23 <tobier> I'm going to try it out, thank you guys
04:44:16 <Saizan> ivanm: i'd just avoid lazy IO in f then, it's not that hard!
04:45:43 <fbru02> what was 1 !! n meant ? go from 1 to n ?
04:46:34 <Raevel> @src (!!)
04:46:34 <lambdabot> xs     !! n | n < 0 = undefined
04:46:34 <lambdabot> []     !! _         = undefined
04:46:34 <lambdabot> (x:_)  !! 0         = x
04:46:34 <lambdabot> (_:xs) !! n         = xs !! (n-1)
04:47:18 <quicksilver> "1 !! n" is probably nonsense it treats 1 as a list.
04:47:36 <quicksilver> SIGN UP HERE! JOIN QUICKSILVER'S CAMPAIGN TO GET @SRC REMOVED FROM LAMBDABOT.
04:47:41 <fbru02> oh i see thanks
04:48:50 <Saizan> quicksilver: but, but.. what if i want to show the source of, say, foldr? or sequence?
04:48:56 <osfameron> I'd sign up to a campaign to make lambdabot's responses to failed @src requests less snide
04:49:23 <Gracenotes> having 2^53 NaN values seems like a bit of a waste, doesn't it?
04:49:33 <Gracenotes> for doubles :x
04:49:35 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9422#a9422
04:49:43 <ksf> ...well, if I can't display it with xhb...
04:49:54 <Saizan> Gracenotes: that way you can claim they are all different to each other
04:50:29 <quicksilver> Saizan: paste a link to the annotated prelude source.
04:50:44 <Gracenotes> there are 2^53 values... AND THEY'RE ALL NOT A NUMBER! :O
04:50:54 <quicksilver> Saizan: actually I don't dispute taht @src is occasionally genuinely useful. But in practice the noise massively outweighs the signal.
04:50:55 <wjt> @src zomg
04:50:55 <lambdabot> Source not found. Maybe you made a typo?
04:51:05 <quicksilver> Saizan: I'd be happy if, for example, only cale was allowed to us it :)
04:51:09 <Gracenotes> actually, make that 2^53-2
04:51:56 * ksf signs
04:52:08 <ksf> ...but only if you admire my lambda.
04:52:24 <ksf> and comfort me for not getting any errors from xhb.
04:53:27 <Saizan> quicksilver: if it responded with a link, and the database was up to date with hackage it could actually become useful in general
04:53:53 <quicksilver> Saizan: different purpose to the current intention, but yes that would be nice.
04:55:22 <tobier> quicksilver: it works now, thanks for your help :) I don't know why but for some reason I believed passing on a paramter would interfer with reading from STDIN :S
04:55:50 <tobier> I can blame it on that I started with haskell IO today :P
04:58:11 <ksf> wtfbbq I can't even use hieroglyph's image support as the image primitive works on a file.
04:58:24 <ksf> I am _not_ going to put glyph data in /tmp.
05:06:17 * tibbe stares at the Data.Binary.Put monad wondering how it can be so efficient. GHC magic.
05:11:23 <Saizan> @vote remove@src yes
05:11:23 <lambdabot> voted on "yes"
05:11:28 <psykotic> http://www.reddit.com/r/programming/comments/9ky2z/a_very_fun_talk_about_commutative_monads_and/c0d7t7i
05:25:06 <Badger> @help vote
05:25:06 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
05:26:17 <Badger> @poll-show remove@src
05:26:17 <lambdabot> ["no","yes"]
05:26:34 <Badger> oh no
05:26:38 <Badger> @poll-result remove@src
05:26:38 <lambdabot> Poll results for remove@src (Open): no=0, yes=1
05:26:46 <Taejo> @hoogle (k -> a -> (k', a')) -> Map k a -> Map k' a'
05:26:46 <lambdabot> No results found
05:26:55 <Taejo> @hoogle ((k, a) -> (k', a')) -> Map k a -> Map k' a'
05:26:55 <lambdabot> No results found
05:29:56 <benmachine> Saizan: why remove@src?
05:30:18 <benmachine> oh
05:30:24 * benmachine scrolls up further
05:39:19 <psykotic> p.s. it would be nice if hpaste had a literate haskell mode
05:40:30 <ivanm> Saizan: any wiki references or something on how to non-lazify IO?
05:41:25 <benmachine> @vote remove@src no
05:41:25 <lambdabot> voted on "no"
05:41:27 <PeakerWork> I dislike lhs mode.. an extra character in a line of human text is less noisy, IMO, than an extra symbol in a line written with symbolic notations
05:41:30 * benmachine would prefer reform@src
05:41:52 <PeakerWork> Also if you use {- and -} comment mode, then it doesn't save anything, even when you have more comments than code
05:43:20 <Raevel> is it possible to clear the list of modules in the ghci prompt?
05:45:39 <opqdonut> Raevel: just ":m"
05:46:07 <Raevel> why thank you
05:46:23 <opqdonut> why indeed thank me
05:46:32 <psykotic> PeakerWork: i have a custom preprocessing mode for ghc that just takes two leading spaces in place of the >
05:46:32 <opqdonut> :P
05:46:41 <psykotic> since i indent anyway, this is my ideal
05:46:42 <Raevel> oh it also unloads the modules?
05:46:55 <Lauralondon> hi!
05:47:13 <opqdonut> Raevel: what did you mean by "clear the list"?
05:47:20 <opqdonut> just not see it?
05:48:04 <Raevel> yep
05:48:21 <Raevel> too many modules loaded so my terminal behaves strangely
05:48:21 <Lauralondon> i have a list and i want to get the init elements of ot, bit i have a problem, and it's yhan when i have a list with just one element, init returns me []. Which function can i use in that cas?
05:49:42 <Raevel> Lauralondon: what result do you want in that case?
05:50:54 <Taejo> is the source for Data.Map at http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/src/Data-Map.html the code GHC actually uses? does that mean no rewrite rules?
05:53:17 <Lauralondon> Raevel , for example if i have [x], i wani it to return me x
05:53:54 <dschoepe> Lauralondon: but for [1,2,3] you want [2,3]? That's not possible, since 1 and e.g. [2,3] have different types
05:55:23 <Lauralondon> no, if i have [1,2,3] i want it to return me [1,2]
05:55:39 <Lauralondon> but the problem is when i have a list with just one element
05:56:00 <Lauralondon> because it returns me  []
05:56:01 <dschoepe> well, you could have it return [x] in this case, but not x.
05:56:03 <Lauralondon> not the element
05:56:15 <dschoepe> the return value would still have to be a list.
05:56:17 <Lauralondon> yes, u are right
05:56:18 <Axman6> Lauralondon: so what type do you expect this function to have?
05:56:38 <Axman6> f :: [a] -> a? or f :: [a] -> [a]?
05:56:49 <Lauralondon> [a]->[a]
05:56:58 <dschoepe> > let f [x] = [x]; f xs = init xs in (f [1],f [1..3])
05:56:58 <lambdabot>   ([1],[1,2])
05:57:08 <dschoepe> like that?
05:57:12 <Axman6> and what should be returned from f [1]?
05:57:18 <Axman6> 1? [1]? or []?
05:57:32 <Lauralondon> Axman it should return me [1]
05:58:01 <Taejo> would it be faster to do to use "M.fold f a . M.mapWithKey nextStates $ prev" or "foldl' f a . map (uncurry nextStates) $ M.toList prev" (where M is Data.Map)?
05:58:12 <Axman6> > let f xs = if null (init xs) then xs else init xs
05:58:12 <lambdabot>   not an expression: `let f xs = if null (init xs) then xs else init xs'
05:58:20 <Axman6> > let f xs = if null (init xs) then xs else init xs in f [1]
05:58:21 <lambdabot>   [1]
05:58:25 <Axman6> > let f xs = if null (init xs) then xs else init xs in f [1,1]
05:58:26 <lambdabot>   [1]
05:58:29 <Axman6> > let f xs = if null (init xs) then xs else init xs in f []
05:58:30 <lambdabot>   * Exception: Prelude.init: empty list
05:58:32 <Axman6> :(
05:58:46 <Axman6> > let f xs = if null xs || null (init xs) then xs else init xs in f []
05:58:47 <lambdabot>   []
05:58:50 <Axman6> > let f xs = if null xs || null (init xs) then xs else init xs in f [1]
05:58:51 <lambdabot>   [1]
05:58:55 <Axman6> > let f xs = if null xs || null (init xs) then xs else init xs in f [1,2]
05:58:56 <lambdabot>   [1]
05:58:59 <Axman6> how's that?
05:59:34 <Lauralondon> i'm gonna try ^.^
06:00:08 <benmachine> null xs || null (init xs) == null (drop 1 xs)
06:00:24 <Taejo> > tail []
06:00:25 <lambdabot>   * Exception: Prelude.tail: empty list
06:00:28 <Taejo> > drop 1 []
06:00:29 <lambdabot>   []
06:00:56 <Axman6> good call benmachine
06:01:25 <benmachine> :)
06:03:23 <Lauralondon> thank you guys!
06:04:01 <ManateeLazyCat> Hi all.
06:04:06 <benmachine> hi
06:04:43 <ManateeLazyCat> I try to implement Haskell banding for VTE C library, and occur some trouble.
06:05:11 <ManateeLazyCat> "terminalNew = makeNewObject mkTerminal $ liftM (castPtr :: Ptr Widget -> Ptr Terminal) $ {#call unsafe terminal_new#}", this declare got "Couldn't match expected type `Widget' against inferred type `()'" error.
06:05:44 <ManateeLazyCat> GHC said, C function `vte_terminal_new` just return 'IO (Ptr ())'.
06:06:03 <porges> are the template haskell docs lying about pattern splicing not being implemented? they say that quotation isn't implemented, but it is :/
06:06:04 <ManateeLazyCat> But in .c file, It return GtkWidget*
06:07:12 * ManateeLazyCat pasted "Vte.chs" at http://paste2.org/get/426998
06:07:13 <ManateeLazyCat> Above is complete .chs file for VTE binding, anyone help me about this error?
06:07:16 <bastl> what does this error mean? "unknown symbol `astviewzm0zi1_Pathszuastview_lvl8_closure"
06:07:48 <Saizan> preflex: zdec astviewzm0zi1_Pathszuastview_lvl8_closure
06:07:49 <preflex>  astview-0.1_Paths_astview_lvl8_closure
06:08:30 <Saizan> bastl: are you using --make? did you recompile astview but not one of the packages that depend on it?
06:08:32 <int-e> bastl: typically, you forgot --make (or -package astview) while compiling your program with ghc
06:08:38 <bastl> i load some functions in a module via hint, these functions in turn use functions and types that i also use in the main program (which launches the interpreter). Is that a problem ?
06:08:43 <Saizan> or maybe you've a stale .hi
06:08:43 <ManateeLazyCat> I find some widget in gtk2hs have same format for binding, why mine can't pass compile?
06:08:45 <int-e> oh
06:09:01 <bastl> everything cabalized well.
06:09:10 <int-e> but the -package info must be passed to hint, too, I think
06:09:10 <bastl> stale .hi !?
06:09:32 <bastl> that sounds reasonyble. Does hint create a .hi ?
06:14:04 <Saizan> bastl: if it does it's put next to the .hs file, i think
06:14:47 * int-e underestimated hint.
06:14:58 <bastl> preflex: zdec astviewzm0zi1_Pathszuastview_lvl8_closure
06:14:58 <preflex>  astview-0.1_Paths_astview_lvl8_closure
06:15:06 <bastl> int-e: hint isnt aware of packages ...
06:15:29 <Saizan> hint automatically loads the packages like ghci does, afaiu
06:15:32 <bastl> Saizan: does this mean, the "Paths_astview" module is the problem =
06:15:33 <bastl> ?
06:15:35 <ivanm> malcolmw: you around?
06:16:16 <Saizan> bastl: it means that it expects the astview library to expose that symbol
06:16:54 <bastl> Paths_astview is a module. the suffix i dont understand
06:17:12 <Saizan> bastl: every compilation of a package can produce a library that exposes different C-level symbols
06:17:32 <Saizan> the suffix is generated by the compiler
06:17:40 <int-e> bastl: lvl8_closure is a symbol generated by ghc
06:18:17 * ManateeLazyCat Badly, too few people work on c2hs... and documents is so little.... explore it self....
06:24:12 <Tobsan> @src reverse
06:24:13 <lambdabot> reverse = foldl (flip (:)) []
06:25:15 <eevar2> @src foldl1
06:25:15 <lambdabot> foldl1 f (x:xs) = foldl f x xs
06:25:15 <lambdabot> foldl1 _ []     = undefined
06:26:23 <eevar2> @src foldl
06:26:23 <lambdabot> foldl f z []     = z
06:26:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:30:32 <Taejo> :t max `on` fst
06:30:32 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> a
06:31:50 * benmachine is somewhat surpsied there isn't a maxBy
06:31:52 <saml> > max `on` fst $ (1,2) (-1,2)
06:31:52 <lambdabot>   Precedence parsing error
06:31:52 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
06:32:02 <rovar> I have a simple function: between u v = (min v . max u)
06:32:03 <benmachine> that is annoying about on
06:32:17 <Taejo> benmachine: that's what I'm looking for
06:32:23 <Taejo> maxBy, I mean
06:32:24 <rovar> and I'm trying to call:   let paddleS = paddle (WX.pointX ( between 30 50 mpos ) )
06:32:36 <saml> > max 1 2
06:32:36 <lambdabot>   2
06:32:43 <Axman6> :t max
06:32:44 <lambdabot> forall a. (Ord a) => a -> a -> a
06:32:46 <benmachine> Taejo: it might exist and I just don't know about it
06:32:47 <rovar> it doesn't like it, but when I call it in ghci, it works
06:32:55 <Axman6> > max (1,2) (3,4)
06:32:56 <lambdabot>   (3,4)
06:33:02 <Axman6> > max (1,2) (3,-1000000)
06:33:02 <lambdabot>   (3,-1000000)
06:33:16 <Taejo> benmachine: can't find it on hoogle
06:33:36 <Taejo> Axman6: I don't want an Ord constraint on the second element of the tuple
06:33:39 <saml> > max (2,-1) (0, -100)
06:33:40 <lambdabot>   (2,-1)
06:33:44 <Axman6> ah
06:33:59 <HaskellPro> could someone tell me why this function doesn't work:
06:34:04 <HaskellPro> deckHelp :: Integer -> Integer
06:34:04 <HaskellPro> deckHelp 10  = 10
06:34:05 <HaskellPro> deckHelp n   = n deckHelp (n+1)
06:34:19 <saml> because n is Integer
06:34:24 <saml> not a Integer -> Integer
06:34:53 <saml> > let deckHelp 10 = 10; deckHelp n = n + deckHelp (n + 1)  in deckHelp 3
06:34:54 <lambdabot>   52
06:34:55 <trez> HaskellPro: recursion-step seems to be missing a +
06:35:06 <saml> or *
06:35:13 <trez> mm :)
06:35:51 <saml> > let x.y = x * (1/y)  in 3 . 4
06:35:51 <lambdabot>   0.75
06:35:59 <saml> > let x.y = x + (1/y)  in 3 . 4
06:36:00 <lambdabot>   3.25
06:41:43 <saml> > let x.y = x * (1.0/y)  in 3 . 4
06:41:44 <lambdabot>   0.75
06:42:28 <saml> given a natural number, how can I make it into fractional part?   n ==> 0.n
06:42:42 <saml> 123 ==> 0.123
06:43:13 <benmachine> you need to know the number of digits it has, I suppose
06:43:31 <benmachine> there are various ways of doing that
06:43:35 <benmachine> the most cheating would be
06:43:44 <benmachine> read . ("0." ++) . show
06:43:49 <Axman6> > let foo n = read ("0." ++ show n) :: Double -> Double in foo 123
06:43:50 <lambdabot>   No instance for (GHC.Read.Read
06:43:50 <lambdabot>                     (GHC.Types.Double -> GHC...
06:44:08 <Axman6> > let foo n = read ("0." ++ show n) in foo 123 :: Double
06:44:09 <lambdabot>   0.123
06:44:23 <int-e> > head . takeWhile (>=1) . iterate (/10) . fromIntegral $ 1
06:44:24 <lambdabot>   1.0
06:44:30 <Axman6> > let foo n = read ("0." ++ show n) in foo 12345678901234567890 :: Double
06:44:30 <lambdabot>   0.12345678901234568
06:44:51 <int-e> > head . dropWhile (>=1) . iterate (/10) . fromIntegral $ 123
06:44:52 <lambdabot>   0.123
06:45:06 <int-e> less cheating, but still ugly.
06:46:17 <Axman6> possibly more error prone though
06:46:29 <benmachine> the other option is n / 10 ** ndigits n
06:47:13 <benmachine> ndigits left as an exercise to the reader
06:47:24 <Axman6> :t (**)
06:47:25 <lambdabot> forall a. (Floating a) => a -> a -> a
06:47:55 <Axman6> > let foo n = n / (10 ^ (length . show $ n)) in foo 123
06:47:56 <lambdabot>   1.23e-3
06:48:07 <Axman6> :t let foo n = n / (10 ^ (length . show $ n)) in foo 123
06:48:08 <lambdabot> forall t. (Fractional t) => t
06:48:14 <Axman6> > let foo n = n / (10 ^ (length . show $ n)) in foo 123 :: Double
06:48:15 <lambdabot>   1.23e-3
06:48:19 <Axman6> >_<
06:48:26 <ksf> morale of the day: sdl is way better than xhb in case you just want to have your stuff displayed.
06:49:16 <saml> sfml is better than sdl
06:49:37 <saml> because it's french like ocaml
06:49:51 <ksf> ...any haskell bindings?
06:50:05 <saml> ah no.
06:50:25 <ManateeLazyCat> ksf: Are you have experience of c2hs? I remember you did it before....
06:50:54 <ksf> see, I don't mind messing with raw pixel data, but after a day and a half of trying to get xrender blit said plain raw pixel data, I'm a bit icky when it comes to usability.
06:51:02 <ksf> ManateeLazyCat, some, yes.
06:51:17 <HaskellPro> how can i make this work
06:51:19 <HaskellPro> deckHelp :: Integer -> Rank
06:51:19 <HaskellPro> deckHelp 10  = (Numeric 10)
06:51:19 <HaskellPro> deckHelp n   = (Numeric n) + deckHelp (n+1)
06:51:33 <HaskellPro> without the +
06:51:44 <ManateeLazyCat> ksf: I occur some trouble when i binding to VTE C library. I want ask you some questions.
06:51:51 <ksf> go aheid
06:52:14 <ivanm> HaskellPro: going by your nick, you don't help for such a trivial task ;-)
06:52:18 <Axman6> HaskellPro: that entirerly depends on what it's supposed to do ;)
06:52:28 <ivanm> (besides, since we have no idea what Rank is...)
06:52:57 <HaskellPro> i want to return (Numeric 1) (Numeric 2) etc
06:53:12 <Axman6> ...
06:53:22 <Axman6> well, that just doesn't make any sense
06:53:36 <Axman6> you can return a list if you like
06:53:38 <trzkril> looks like cards, rank, deck, what about color?~
06:54:45 <Saizan> HaskellN00b: can you give some pairs of expected inputs and outputs for that function?
06:55:25 <ManateeLazyCat> ksf: In http://paste2.org/get/426998 is my complete Vte.hs file.
06:56:02 <ManateeLazyCat> ksf: I have function "terminalNew :: IO Terminal"
06:56:05 <ManateeLazyCat> terminalNew = makeNewObject mkTerminal $ liftM (castPtr :: Ptr Widget -> Ptr Terminal) $ {#call unsafe terminal_new#}
06:56:15 * ksf has never seen call hooks before
06:56:33 <ManateeLazyCat> ksf: terminal_new is C function.
06:56:44 <ManateeLazyCat> ksf: It return GtkWidget*
06:57:37 <ManateeLazyCat> ksf: So for function `terminalNew` in .chs file, {# call unsafe terminal_new #} should return `IO (Ptr Widget)` ?
06:57:39 <ManateeLazyCat> right?
06:58:10 <ManateeLazyCat> ksf: GHC report it just return `IO (Ptr ())`, is i missing something?
06:58:24 <ksf> get hooks do the same.
06:58:37 <ksf> c2hs inserts a Ptr () type annotation there.
06:58:42 <ksf> I bet the same happens here.
06:58:54 * ManateeLazyCat First time binding C library.
06:59:10 <ksf> ...you can safely cast the pointers, though (for the C meaning of "safe")
06:59:54 <ksf> I've never used call hooks personally, only fun hooks.
06:59:59 <bastl> I still have a problem with hint: my Main-program declares a type, my dynamically loaded function should return that type. the module i load dynamically has to import the module containing the type, as my main-module has to. But at runtime the module with the type is not found.
07:00:01 <benmachine> is that the "not safe at all" meaning
07:00:10 <bastl> I tried two workarounds:
07:00:14 <Rotaerk> are you saying call hooks aren't fun?!
07:00:16 <ksf> ...they're more convenient, especially if you have to marshal a lot.
07:00:26 <ksf> no, call hooks aren't fun hooks.
07:00:31 <bastl> 1) declare a library in cabal which exposes the module. No luck.
07:00:32 <ksf> even though they call funs.
07:00:54 <Saizan> bastl: why No luck?
07:00:54 <bastl> 2) deploy a new package just for this type. Works but is very ugly ...
07:01:01 <HaskellN00b> goodbye cruel world
07:01:06 <bastl> GhcError: Module not found.
07:01:16 <Saizan> ah, i understood 1 as if it were 2
07:01:18 <ksf> benmachine, it's the "of course it's sensible to allow code to modify itself"
07:01:21 <ksf> ...sense.
07:01:26 <ManateeLazyCat> ksf: Yes, i know different between {#call and {#fun
07:01:35 <bastl> Saizan: can i tell hint about the modules that come with the compiled binary ?
07:01:57 <Saizan> bastl: no, i don't think so
07:02:01 <ksf> fun hooks would generate the right type for the Ptr
07:02:23 <ksf> ...I guess you're going to have to live with the castPtr wart or complain with the authors.
07:02:39 <bastl> so 2) seems to be the only option. Bu i dont understand why it cannot reuse the module/type in the interpreter ...
07:02:59 <sergio1> Hi there!
07:02:59 <sergio1> What am I doing wrong?
07:02:59 <sergio1> > Prelude> :t (\x -> x)
07:02:59 <sergio1> > (\x -> x) :: t -> t
07:02:59 <sergio1> > Prelude> func = (\x -> x)
07:03:00 <sergio1> >
07:03:00 <lambdabot>   <no location info>: parse error on input `:'
07:03:00 <lambdabot>   <no location info>: parse error on input `='
07:03:00 <lambdabot>   {()->()}
07:03:02 <sergio1> > <interactive>:1:5: parse error on input `='
07:03:02 <lambdabot>   <no location info>: parse error on input `<'
07:03:04 <Taejo> @pl \k v -> (v, [k])
07:03:04 <lambdabot> flip (,) . return
07:03:18 <ksf> sergio1, that's obvious.
07:03:21 <bastl> sergio: pasting to an irc-channel !?
07:03:23 <ksf> you're not using a pastebin.
07:03:43 <ksf> and you're confusing lambdabot with all your >s
07:04:18 <Saizan> bastl: without an associated .hi file it doesn't know how to link to them, also there might be some problems with relocation etc. i don't know the details myself, but you could try asking on the ghc-users@ mailing list
07:04:21 <sergio1> Yes, I'm pasting, but I was not asking about what lambdabot would be doing with my input, rather what ghci did with it;-)
07:04:29 <aavogt> hi, does hsmagick work for anybody?
07:04:42 <ksf> ...but in general, ghci just doesn't take top-level definitions.
07:04:47 <sergio1> More specifically, the definition of 'func' makes it unhappy
07:04:51 <ksf> it's all a big do-block.
07:05:02 <saml> sergio1, you can use let func = (\x -> x)
07:05:07 <ksf> > let func = (\x -> x) in func 1
07:05:08 <lambdabot>   1
07:05:17 <saml> > let let = (\x -> x) in let 1
07:05:18 <lambdabot>   <no location info>: parse error on input `='
07:05:23 <saml> so let is a keyword
07:05:31 <Saizan> sergio1: you should put definitions in an .hs file and load it with :load
07:05:54 <ManateeLazyCat> ksf: Sorry, later reply.
07:06:06 <sergio1> Ah, thanks (I'm just trying to reduce a concrete problem I have into a few lines of ghci, but did it wrong, sorry).
07:06:24 <ManateeLazyCat> ksf: Because for binding Gtk library, i need castPtr to change pointer type safely
07:06:27 <aavogt> this is how hsmagick fails: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9424#a9424
07:06:29 <sergio1> BTW, if I want to paste a ghci session on IRC, how should I proceed?
07:06:40 <Saizan> @hpaste
07:06:40 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:06:49 <Saizan> you can use that site ^^
07:07:01 <ManateeLazyCat> ksf: In Gtk library, terminal_new return VteTerminal, but it still pointer of GtkWidget*
07:07:38 <ManateeLazyCat> ksf: So i need transform GtkWidget pointer to VteTerminal pointer by castPtr.
07:08:04 <ksf> iirc there already are up- and downcast functions in the gtk2hs bindings
07:08:56 <ManateeLazyCat> ksf: So how do you write terminal_new binding? Just read my type significance for transform.
07:09:48 <ksf> transform?
07:10:27 <ksf> ...tbh, I don't have any idea about how gtk2hs uses c2hs.
07:10:50 <ManateeLazyCat> ksf: BTW, i think we need add `unsafe` after `{# call ... ` if function return `IO Foo`. I always add `unsafe` for fucntion binding that return IO Monad.
07:11:10 <ksf> "safe" means "can't enter the haskell rts"
07:11:39 <ManateeLazyCat> ksf: Can you explain rts?
07:11:47 <ManateeLazyCat> In details.
07:11:50 <ksf> run-time system.
07:12:06 <ManateeLazyCat> ksf: Example?
07:12:46 <ksf> ...it's just that haskell needs to safe more state before calling a ffi function that may re-enter... a mainloop that calls haskell-functions as its event callbacks, for example.
07:14:23 <ManateeLazyCat> ksf: I see, looks i misunderstand `unsafe` in c2hs.
07:14:45 <ksf> it's documented in the ffi addendum.
07:15:12 <jmcarthur_work> man, working on a new standard library is almost like designing a new language
07:15:26 <jmcarthur_work> i think i'm getting carried away and nobody else will like it :P
07:15:32 <ksf> are we going to have (.) = fmap?
07:15:36 <jmcarthur_work> heck no
07:15:47 <ksf> meh.
07:16:02 <jmcarthur_work> i liked that when i first saw it, but i like (.) as category composition better
07:16:18 <Saizan> let it be both.
07:17:06 <jmcarthur_work> there is a readily available operator for fmap already
07:17:46 <ivanm> Saizan: (from before) any wiki references or something on how to non-lazify IO?
07:17:57 <ivanm> as in, I'm not sure what's lazy IO and what isn't, etc.
07:18:06 <wmealing> gday guys, probably a simple question..  http://dpaste.com/94369/ Ive tried a few different ways to convert the type.. but nothing seems to be working.. what should I be doing ?
07:18:25 <jmcarthur_work> which is another thing i have changed a bit (some might say arbitrarily, but i think i could explain it)
07:18:39 <jmcarthur_work> but it would be bikeshedding i suppose
07:19:00 <Saizan> ivanm: don't use unsafeInterleaveIO, (System.IO|Data.Bytestring.Lazy).hGetContents
07:19:01 <jmcarthur_work> so i either automcatically win or i automatically lose
07:19:23 <ivanm> Saizan: bugger, I'm using hGetContents :(
07:19:29 <ivanm> anything that's non-lazy with the same type?
07:19:38 <ivanm> @hoogle Handle -> IO String
07:19:38 <lambdabot> System.IO hGetContents :: Handle -> IO String
07:19:38 <lambdabot> System.IO hGetLine :: Handle -> IO String
07:19:38 <lambdabot> System.IO hShow :: Handle -> IO String
07:20:00 <sergio1> Sorry, not sure how to use hpaste :-(
07:20:00 <sergio1> Hope that ** will not confuse lambdabot!
07:20:00 <sergio1> I need a function with type:
07:20:00 <sergio1> ** [a] -> Data.Map.Map a b -> [a,b]
07:20:00 <sergio1> The idea is to grab some info in the map (typicaly with Data.Map.lookup)
07:20:01 <sergio1> on elements, keeping only the "good ones" together the map info.
07:20:03 <sergio1> It's not hard to do it the tedious way, but I was looking for some
07:20:05 <sergio1> code jewel here;-)
07:20:07 <sergio1> Something in the line of zipping the input list with its lookup on the map:
07:20:09 <sergio1> ** let func l m = zip l (map (flip Data.Map.lookup m) l)
07:20:11 <sergio1> But, of course, type is wrong, since it is
07:20:13 <sergio1> ** [a] -> Data.Map.Map a b -> [(a,Maybe b)]
07:20:13 --- mode: ChanServ set +o Saizan
07:20:15 <sergio1> What I would need is a lifter of Maybe of type (a,Maybe b) -> Maybe (a,b)
07:20:17 <sergio1> I then could just 'catMaybes' on 'func' and I'd be done.
07:20:17 --- mode: Saizan set +b *!*=slehuito@*.w86-195.abo.wanadoo.fr
07:20:42 <Saizan> sergio1: don't flood the channel with lengthy text, anything above 3 lines is too much to paste in-channel
07:20:54 <Botje> sergio1: http://hpaste.org/fastcgi/hpaste.fcgi/new
07:21:05 <wmealing> @hoogle Data.ByteString.Lazy.Internal.ByteString -> String
07:21:05 <lambdabot> Parse error:
07:21:06 <lambdabot>   --count=20 "Data.ByteString.Lazy.Internal.ByteString -> String"
07:21:06 <lambdabot>                  ^
07:21:07 --- mode: Saizan set -b *!*=slehuito@*.w86-195.abo.wanadoo.fr
07:21:07 <Botje> you can put your question and GHCI transcript in the big box there, and hit save
07:21:17 <Botje> lambdabot will announce your paste so we can read it
07:21:18 * wmealing thinks
07:21:36 <Saizan> wmealing: Data.ByteString.Lazy.Char8.unpack
07:21:39 <ivanm> Botje: lambdabot does paste announces again? :o
07:21:51 <Saizan> no, it doesn't
07:21:55 <Botje> ah, no it doesn't.
07:22:13 <Botje> sergio1: then you'll have to paste the url you get back here, so we can read it.
07:22:39 <Saizan> ivanm: a simple way is to use Data.ByteString.hGetContents and Data.ByteString.Char8.unpack
07:23:08 <ivanm> Saizan: use bytestring just for strictness?
07:23:15 <Saizan> ivanm: yes
07:23:24 <ivanm> *sigh*
07:23:32 --- mode: Saizan set -o Saizan
07:23:43 <ivanm> OK, in that case, if I'm using bytestring anyway, are bytestrings suitable for binary (e.g. image) data?
07:23:53 <Saizan> sure
07:23:55 <ivanm> for writing to file?
07:24:36 <wmealing> Saizan: i'll keep trying, thankyou
07:24:59 <Saizan> yes, though if the file is very large you'll use a lot of memory
07:25:19 <Saizan> a lot = the size of the file
07:25:23 <ivanm> hmmmm....
07:25:28 <ivanm> any way of mitigating that?
07:25:38 <Saizan> lazy io?:)
07:25:42 <jmcarthur_work> ivanm, lazy or strictly incremental io
07:25:48 <ivanm> Saizan: great :s
07:25:58 <jmcarthur_work> ivanm, you could either use handles explicitly or try something like iteratees
07:26:02 <ivanm> first you tell me not to use lazy IO; then you tell me that I might want/need lazy IO
07:26:07 <ivanm> jmcarthur_work: I am, that's my problem :p
07:26:09 <Saizan> ivanm: you could just make sure to force the whole result of 'f' inside it
07:26:17 <ivanm> Saizan: inside what?
07:26:22 <ivanm> and that's what I'm trying to do!
07:26:23 <Saizan> ivanm: inside 'f'
07:26:26 <ivanm> ahhh
07:26:26 <jmcarthur_work> ivanm, which? how is it giving you problems?
07:26:33 <ivanm> how do I force hGetContents?
07:26:47 <ivanm> jmcarthur_work: http://hackage.haskell.org/packages/archive/graphviz/2999.5.0.0/doc/html/src/Data-GraphViz-Commands.html#graphvizWithHandle
07:27:17 <ivanm> (note that I've since deleted the seq line, because it doesn't work if f :: Handle -> IO String for example)
07:27:18 <Saizan> ivanm: i didn't mean to force hGetContents but to force what you do with it, however you can just run "rnf" on the given string
07:27:29 <ivanm> and that should do it?
07:27:44 <Saizan> yes, if you make sure to strictly evaluate the result of rnf
07:28:20 <ivanm> so s <- hGetContents; rnf s `seq` return s ?
07:28:24 <Saizan> like f handle = do output <- hGetContents handle; evaluate (rnf output); return output
07:28:29 <Saizan> yes, that too
07:28:34 <ivanm> @hoogle evaluate
07:28:34 <lambdabot> Control.Exception evaluate :: a -> IO a
07:28:34 <lambdabot> Control.OldException evaluate :: a -> IO a
07:28:34 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
07:28:39 <ivanm> ahhh
07:28:47 <ivanm> evaluate forces evaluation I take it?
07:29:00 * ManateeLazyCat I think i need ask c2hs/gtk2hs question in Haskell-Cafe.
07:29:04 <Saizan> it's similar to (return $!)
07:29:07 <ManateeLazyCat> Saizan: BTW, you read my source code?
07:29:17 <ManateeLazyCat> Saizan: Any suggestions?
07:29:29 <Saizan> ManateeLazyCat: ah, no, i didn't
07:30:26 <jmcarthur_work> ivanm, you are using a handle, but with lazy io actions :P
07:30:34 <ivanm> jmcarthur_work: yeah :s
07:30:35 <jmcarthur_work> ivanm, you could just not use hGetContents
07:30:46 <ManateeLazyCat> Saizan: Haven't understand TH and c2hs completely, TH can help me improve code, c2hs can help me binding vte.
07:30:50 <ivanm> jmcarthur_work: I need a Handle -> IO String function elsewhere
07:31:25 <jmcarthur_work> ivanm, i just mean you could interleave the io with the program logic a bit
07:31:34 <jmcarthur_work> ivanm, or use iteratees if you wish to learn it
07:31:43 <jmcarthur_work> ivanm, admittedly, though, hGetContents *is* easier
07:32:15 <Saizan> even a strict version of hGetContents might be enough for a lot of use cases
07:32:23 <Saizan> but there isn't one in the standard libs
07:32:57 <ivanm> jmcarthur_work: here is where I'm using hGetContents: http://hackage.haskell.org/packages/archive/graphviz/2999.5.0.0/doc/html/src/Data-GraphViz.html#dotAttributes
07:33:55 <Saizan> ivanm: there's not point in doing the:
07:33:56 <Saizan> let res = fromJust output length res `seq` return ()
07:34:12 <Saizan> after graphvizWithHandle
07:34:24 <Saizan> you should do that in the action you pass to it
07:34:42 <ivanm> Saizan: you mean the seq bit?
07:34:56 <Saizan> yes
07:35:24 <ManateeLazyCat> Saizan: If i want storage instance of typeclass, i always need another type to wrap this instance, right?
07:35:32 <Saizan> graphvizWithHandle command dot DotOutput (\h -> do s <- hGetContents h; length s `seq` return s)
07:35:41 <Saizan> or s/length/rnf/
07:35:46 <jmcarthur_work> i would like to amend my comment that hGetContents is easier. it's only superficially easier. as soon as you have to start forcing it, it's no longer as easy as it was
07:36:05 * trez gillar pojkar
07:36:15 <jmcarthur_work> it can be handy, but once you start threading this stuff throughout the program it might be time to change things a bit
07:36:18 <ivanm> Saizan: so I should replace hGetContents with the hGetContents+rnf and drop the seq?
07:36:21 <jmcarthur_work> but that's just personal opinion
07:36:31 <ivanm> right
07:37:00 <ivanm> jmcarthur_work: thing is, I half-inherited that mess...
07:37:12 <ivanm> and I'm lary of changing too much of it :p
07:37:57 <Saizan> ivanm: yeah
07:38:18 <Saizan> ivanm: the seq will be in the function you replace hGetContents with
07:38:28 <ivanm> right
07:40:04 <ivanm> @ask malcolmw do you know of any way in polyparse I can have it automagically ignore all "\\<newline>" everywhere without explicitly telling it in everything I parse?
07:40:04 <lambdabot> Consider it noted.
07:41:38 <Saizan> you could filter them out at the start
07:41:55 <Saizan> but i think polyparse has a parser that works on ByteString
07:42:22 <ivanm> Saizan: of the entire String?
07:43:19 <Saizan> ivanm: yes
07:43:25 <Saizan> s/but/btw/
07:43:45 <ivanm> heh
07:44:40 <ivanm> hmmmmm..... not sure how to apply a filter to the entire string in that way easily, since filter would work on chars, (and hence can't do \\{\n\r,\n,\r}
07:44:59 <ivanm> as for working on ByteStrings... *shrug* I have operations working on the Char level
07:45:07 <ivanm> not sure how well that would convert to ByteStrings
07:47:30 <ManateeLazyCat> Where i can find *MANY* Template Haskell code for different situation?
07:47:30 <Saizan> the polyparse interface let you work with Chars anyway, iirc
07:48:05 <ivanm> Saizan: yes, which is what I'm using ;-)
07:48:21 <gwern> ManateeLazyCat: you can't
07:48:31 <gwern> ManateeLazyCat: TH is poorly documented and people avoid it
07:48:45 <ManateeLazyCat> gwern: Avoid it? No.
07:49:01 <ManateeLazyCat> gwern: Template is very useful for some situation.
07:49:16 <gwern> sure, otherwise we'd've burned it with fire by now
07:49:36 <Saizan> ivanm: i mean that the one that uses ByteString will offer a Char-based API, so it wouldn't be different.
07:49:38 <ManateeLazyCat> gwern: Just too few resource for use it practice.
07:50:09 <ivanm> Saizan: polyparse is Parser t a
07:50:16 <ivanm> with operations happening on individual t values
07:50:17 <gwern> > ((90 * 100)/85, (100*100)/93.5)
07:50:18 <lambdabot>   (105.88235294117646,106.95187165775401)
07:50:26 <ManateeLazyCat> gwern: Example for map 'Binary instance` of typeclass.
07:50:29 <ivanm> thus, if I want to test for a Char, I need t == Char
07:51:42 <ManateeLazyCat> gwern: Just can't understand how to use TH build `Map Foo` with exist `Foo`....
07:53:25 <Saizan> ivanm: i was sure there was a version that took ByteString as stream instead of [t]
07:53:43 <ivanm> You can use ByteString I think
07:53:52 <ivanm> you just can't do operations on Chars anymore, that's all
07:54:01 <ivanm> you do operations on ByteString (I think)
07:54:03 <Saizan> no, you can't
07:54:17 <Saizan> well, you can have [ByteString], but that's another point.
07:57:36 <ksf> afaik polyparse isn't parametrized over the uncons type, yet.
07:57:57 <ksf> but then, iirc, hacking up the source to support it should'nt be hard.
07:58:16 <ksf> parsec can do that
07:58:16 * ivanm should hit the sack, anyway
07:58:24 <ksf> >=3.0, that is.
07:58:26 <ivanm> ksf: well, this library was already using polyparse
07:58:48 <ivanm> and I didn't feel like _completely_ rewriting parsing support, especially since I've never done any parsing before I worked on this library :s
07:58:57 <bastl> cabal haddock --executables produces documentation for all modules Main depends on.
07:59:29 <bastl> cabal haddock --executables --hyperlink-with-source only generates source for main  (but links to the dependent modules)
07:59:40 <ksf> ...especially if the library uses some of polyparse's more exotic features, like taking the fixed point of a parser.
07:59:50 <dcoutts> bastl: sounds like a bug
07:59:52 <ivanm> ksf: no, nothing like that
08:00:04 <ivanm> (didn't even know that was possible...)
08:00:15 <bastl> hmm
08:00:30 <ksf> it's possible with lazy polyparse
08:00:35 <dcoutts> bastl: if you could report that, that'd be good
08:00:50 <bastl> dcouuts: to cabal or haddock !?
08:00:59 <dcoutts> bastl: cabal
08:01:13 <Saizan> be sure to add the output of cabal --version
08:01:28 <dcoutts> bastl: haddock is not involved in the generation of the sources
08:01:33 <ManateeLazyCat> dcoutts: I occur some problem when binding to VTE library, http://paste2.org/get/426998 have complete Vte.chs file, i got "Couldn't match expected type `Widget' against inferred type `()'" error with binding function `terminalNew`.
08:01:55 <bastl> but it knows about it: it generates the html "src" linsk !?
08:01:58 <bastl> anyway...
08:02:02 <dcoutts> bastl: yes
08:02:13 <ManateeLazyCat> dcoutts: terminal_new return `GtkWidget*`, so is `IO (Ptr Widget)', right?
08:02:22 <dcoutts> bastl: cabal calls haddock with something like --src-links=%blah/%blah
08:02:22 <ksf> imo haddock should do source generation, too.
08:02:31 <ksf> ...so that it can insert hyperrefs.
08:02:38 <ManateeLazyCat> dcoutts: Why GHC report it is `IO (Ptr ())' ?
08:02:42 <ksf> (and do syntax hightlightening)
08:03:08 <Saizan> ksf: syntax highlightening is done by hscolour
08:03:10 <dcoutts> ManateeLazyCat: because you've not told c2hs of the mapping between C types and Haskell types
08:03:36 <dcoutts> ManateeLazyCat: are you building this in the context of c2hs or independently?
08:03:43 <dcoutts> erm
08:03:45 <dcoutts> gtk2hs
08:04:21 <dcoutts> ManateeLazyCat: the gtk .chs modules define the relationship between the C and Haskell types, so if you {# import #} them then you'll get the mappings too
08:04:21 <ManateeLazyCat> dcoutts: I just use c2hs compile Vte.chs file, never merge in gtk2hs.
08:04:28 <jmcarthur_work> ksf, i have never used a lazy parser combinator library. how does polyparse do error handling when parsing lazily?
08:04:40 <dcoutts> ManateeLazyCat: ok, then you might need to add the mapping directly
08:04:58 <dcoutts> ManateeLazyCat: see the c2hs user guide on the 'pointer' construct
08:06:01 <ManateeLazyCat> dcoutts: I wrote "{#pointer *Terminal foreign newtype#}" can't work?
08:06:22 <dcoutts> ManateeLazyCat: sure, but that's for the Terminal type, not GtkWidget
08:06:23 <Raevel> woot, the scion compilation inside emacs is sweet
08:06:44 <ksf> jmcarthur_work, you can either error out with exceptions, which is of course bad in any case, or report errors as part of the parse result.
08:07:08 <ksf> ...you get a state monad, too, that's another possibility.
08:07:14 <alc> ivanm: since \n or \r alone is to be filtered, you dont have to check if they are concatenated.  a simple filter will do, no?
08:07:17 <ManateeLazyCat> dcoutts: I see, you mean, i need put this Vte.chs in gtk2hs directory with {# import ... }, then gtk.chs will mapping below GtkWidget, GtkObject?
08:07:35 <jmcarthur_work> ksf, but i assume the only way to keep it lazy is to not try to read the error first?
08:07:54 <ivanm> alc: I don't want to remove _all_ of them ;-)
08:08:01 <ivanm> just the ones directly after a \\
08:08:19 <ManateeLazyCat> Raevel: How about use scion in Emacs? Correct and fully?
08:08:29 <ksf> ...well you're going to get the error. what you absolutely shouldn't do is analyzing the part of the structure that you're supposed to generate, as that makes the fixpoint not terminate.
08:08:38 * ManateeLazyCat I plan to integrate scion with my editor for Haskell code completion.
08:09:20 <alc> ivanm: o i c. how about using regexp then. :p
08:09:26 <Raevel> ManateeLazyCat: i'm not sure what you mean?
08:09:30 <jmcarthur_work> ksf, looks like maybe i should play around with it and see. i don't really knows polyparse's model right now
08:09:36 <jmcarthur_work> *know
08:11:31 <ManateeLazyCat> Raevel: scion is provide Haskell code completion analysis feature, isn't?
08:12:02 <dcoutts> ManateeLazyCat: that's one option, the other is to define the mapping locally.
08:13:15 <Raevel> i havent looked at the code completion yet
08:16:11 <bastl> where can I learn about scion and vim integration ?
08:17:46 <Raevel> @src liftIO
08:17:46 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:18:26 <quicksilver> bastl: from nominolo|uni , or from the fragments of docs in the repo, I believe :)
08:18:43 <kangas> I am defining func :: [(a,b)] -> ([a],[b]) with func [] = [] but this gives me Couldn't match expected type `([a], [b])' [] = [].  I've been googling the error message with no luck.  Anyone got any pointers?  I am trying to accomplish a base case for a recursive function, which simply returns empty list when there are no tuples left in the list.
08:18:48 <bastl> thanks. already found http://github.com/nominolo/scion/blob/master/README.markdown
08:20:19 <quicksilver> kangas: that function returns a pair ([a],[b])
08:20:22 <quicksilver> kangas: [] is a list.
08:20:31 <quicksilver> kangas: so [] is not a valid return value for it
08:20:43 <kangas> quicksilver, True.  Thanks.
08:27:29 <alc> > "hello" =~ "h" :: Bool
08:27:30 <lambdabot>   True
08:29:32 <ManateeLazyCat> dcoutts: If i need mapping Terminal with low-level Type, example type `Terminal`'s class hierarchy is : GObject -> Object -> Widget -> Terminal , which .chs module need {# import #} ?
08:29:49 <ManateeLazyCat> dcoutts: Can you explain more detail?
08:30:18 * ManateeLazyCat Poorly document about c2hs and gtk2hs.
08:33:22 <alc> > let f [] = []; f ('\\':'\r':'\n':x) = f x; f ('\\':'\n':x) = f x; f ('\\':'\r':x) = f x; f (x:xs) = x : f xs in f "hello\nworld\\\rhello\r\nhaskell\\\nrox\\\r"
08:33:22 <lambdabot>   "hello\nworldhello\r\nhaskellrox"
08:37:44 <alc> > let f [] = []; f ('\\':'\r':'\n':x) = f x; f ('\\':'\n':x) = f x; f ('\\':'\r':x) = f x; f (x:xs) = x : f xs in f "a\r\nb\\\r\n"
08:37:45 <lambdabot>   "a\r\nb"
08:37:49 <dcoutts> ManateeLazyCat: look at the types.chs module in gtk2hs, it defines all the mappings, you can either do the same or import it
08:40:25 <ManateeLazyCat> dcoutts: Just wrote "import Graphics.UI.Gtk.Types" can't work? Why need add {# import #} ?
08:40:50 <porges> oh wow, just discovered GHC.Prim.Any
08:41:00 <ManateeLazyCat> dcoutts: If just "import Graphics.UI.Gtk.Types", i have did it, can't work.
08:41:31 <psykotic> porges: hey, did my reply make more sense of your question?
08:41:39 <porges> yup :)
08:41:55 <ManateeLazyCat> dcoutts: Above is my Vte.chs file
08:41:59 * ManateeLazyCat pasted "Vte.chs" at http://paste2.org/get/427073
08:42:12 <ManateeLazyCat> dcoutts:                           ^^
08:42:29 <psykotic> the first time i noticed that (m a, a -> m b) ~= (m b, b -> m a) was a wide ranging generalization of bayes's theorem, i pretty much pissed my pants :)
08:43:27 <ManateeLazyCat> dcoutts: I found Entry.chs have same format with my Vte.chs, except {#import Graphics.UI.Gtk.Types#} and {#import Graphics.UI.Gtk.Signals#}
08:44:27 * ManateeLazyCat {# import #} need same version of c2hs, recompile gtk2hs ......
08:44:37 <sergio1> I'm building a string of ca. 600 chars with lots of calls to ++
08:44:39 <dcoutts> ManateeLazyCat: right, that's what c2hs uses to import the .chi files which contain the type mappings
08:44:48 <malcolmw> ivanm: maybe run two layered parsers.  e.g. let (Right s, []) = runParser strippedNL input in runParser realWork s
08:44:54 <sergio1> I get the following message while executing:
08:44:56 <sergio1> C stack overflow in generated code
08:45:17 <malcolmw> ivanm: where strippedNL = (do '\\' <- next; '\\' <- next; '\n' <- next; strippedNL) `onFail` next
08:45:32 <sergio1> Is this due to strings specifically, or is this just too many thunks roaming around?
08:45:33 <malcolmw> ivanm: or something like that
08:46:03 <sergio1> I.e. not enough strictness
08:46:13 <ksf> do we have fixed-point types?
08:46:17 <jmcarthur_work> sergio1, that looks like an uncommon error to me
08:46:23 <jmcarthur_work> sergio1, could you hpaste the code?
08:46:39 <ManateeLazyCat> dcoutts: Thanks for your help, i will re-test Vte.chs after recompile gtk2hs, even c2hs need same version.
08:46:52 <alc> > let f s = subRegex (mkRegex "\\\\(\r|\n|\r\n)") s "" in map f ["\r", "\n", "\r\n", "\\\r", "\\\n", "\\\r\n"]
08:46:53 <lambdabot>   Not in scope: `subRegex'Not in scope: `mkRegex'
08:46:54 <sergio1> jmcarthur: I'm not sure I can do it right now, but I'll try to isolate
08:47:04 <ksf> ...otoh, I could just go ahead and use double, it's not like haskell could be expected to ever run on a thing that can't do floating point...
08:47:25 <dcoutts> ManateeLazyCat: I think it'd be easier to just copy out the type mappings, it's only a few lines
08:47:31 <jmcarthur_work> sergio1, good. "C stack overflow" sounds like some sort of compiler or runtime error more than your error, to me. maybe somebody else would know better though
08:49:04 <ksf> ...it takes some time for the default stack to blow.
08:49:07 <alc> , let f s = subRegex (mkRegex "\\\\(\r|\n|\r\n)") s "" in map f ["\r", "\n", "\r\n", "\\\r", "\\\n", "\\\r\n"]
08:49:10 <lunabot>  luna: Not in scope: `subRegex'
08:50:39 <quicksilver> "generated code
08:50:47 <quicksilver> that's a strange errro message indeed.
08:51:07 <Tobsan> Anybody in here who has some experience in working with sound in general, and OpenAL in particular?
08:51:47 <psykotic> tobsan: yes to both but not in haskell
08:51:52 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/2989
08:52:02 <quicksilver> odd though, dons and igloo though that was normal
08:52:06 <psykotic> though i've mostly used openal for relatively simple stuff that didn't really need any of the fancy 3d sound support
08:52:09 <quicksilver> I'm sure that's an unusual error message.
08:52:23 <Tobsan> psykotic: we don't want 3d support either :-)
08:52:41 <Tobsan> however, when looking at the openAL bindings for haskell, we can't seem to find a way to create a "Source"
08:53:06 <psykotic> sorry, like i said i haven't used it in haskell. wish i could help.
08:53:10 <jmcarthur_work> well, i've never seen it before
08:53:19 <jmcarthur_work> and it's not obvious how to fix it
08:53:24 <jmcarthur_work> from the text
08:53:27 <quicksilver> I think it must be if you manage to make a really tight recursive
08:53:30 <quicksilver> recursion
08:53:39 <quicksilver> which is all unboxed and doesn't touch the haskells stack or something.
08:53:44 <Tobsan> psykotic: alright :)
08:54:57 <psykotic> btw i ended up scrapping openal, sdl's sound support was much easier and did everything i wanted
08:55:23 <Tobsan> hmm, okay
08:55:26 <psykotic> most of the time all you need is simple mixing and maybe file format loading (for which sdl_sound does the trick)
08:55:41 <psykotic> openal's architecture is a bit overkill for most apps, imo
08:56:43 <psykotic> it's probably also more likely that the sdl bindings for haskell for in better shape than the openal ones. though i haven't used those either :)
08:57:44 <Tobsan> well, both seem alright. However sdl seems easier
08:58:16 <psykotic> sdl is awesome in general. it gets out of the way and lets you get at things with minimal fuzz
08:58:33 <psykotic> it only uses the minimal abstractions it needs to achieve its goals
09:09:46 <sergio1> Re: 'C stack overflow' error message
09:10:12 <sergio1> I've pasted (or at least I've tried) a simplified program that still exhibits the problem
09:10:25 <sergio1> it (hopefully) is there: http://moonpatio.com/fastcgi/hpaste.fcgi/raw?id=3624
09:10:50 <sergio1> I ran it through 'ghc' (didn't try 'ghci')
09:11:21 <sergio1> The error arises when I 'putStrLn' the string I've built from small pieces
09:13:35 <quicksilver> sergio1: the definition of newPrefCmd is recursive
09:14:32 <quicksilver> perhas you meant oneMoreCmd not newPrefCmd just before the ++ on line 74
09:24:40 * ksf doesn't get freetype's api
09:25:49 <ksf> I've got no Idea how I am supposed to do proper hinting, if every glyph is rasterized to the same pixel grid but the distance between two glyphs knows of subpixels.
09:27:04 <quicksilver> ksf: proper hinting is thoughtcrime
09:27:54 <ksf> it doesn't even have to look proper, but it just plain sucks if glyphs visibly dance at a height of say 10 pixels
09:28:45 <ksf> ...even the custom rasterizer callback-thingie works with integer pixels.
09:29:28 <wmealing> if someone has a few minutes for a newbie.. i'm getting more than a little frustrated with this.
09:30:09 <ksf> otoh, I should just do kerning, maybe the font uses that to correct stuff...
09:30:09 <burp> anyone using haskelldb here? I'm trying to insert data into a table without specifing the column "id", which is automatically set by the database -- it seems I have to specify all fields to insert something
09:31:03 <defun> Is, Word, Word32, etc. a "basic" Haskell type like Int, or Float, or Char?
09:31:06 <ksf> If everything else fails, I can still raster the pixels at say eight times the resolution and then downsample
09:31:19 <ksf> ...but I guess that fucks up hinting.
09:31:22 <int-e> defun: yes.
09:31:30 <defun> thanks.
09:31:40 <int-e> @src Word32
09:31:40 <lambdabot> Source not found.
09:31:54 <defun> @src Word
09:31:54 <lambdabot> Source not found. stty: unknown mode: doofus
09:32:11 <defun> bummer
09:32:24 <int-e> defun: in the same sense as Int is ... with ghc, data Int = I# Int# where Int# is a primitive type, an unboxed Int.
09:32:38 <int-e> (I# is just an awkwardly named constructor)
09:33:05 <defun> Int#, however is implemented on the compiler/runtime level, not the library level, correct?
09:33:16 <int-e> yes
09:33:20 <defun> ok.
09:33:33 <defun> So anything with '#' is compiler level?
09:33:45 <jmcarthur_work> unboxed
09:33:48 <ksf> # is just a naming convention
09:33:51 <int-e> no.
09:33:54 <ksf> ...for primitive values.
09:33:59 <int-e> (what ksf said, right)
09:34:07 <defun> I see.
09:34:28 <ksf> all primitives happen to be named that way, but otherwise it's just a normal character.
09:34:43 <gio1234> what flatten has to do?
09:34:48 <defun> So I'll never find something like MyHighLevelDataTypes# ?
09:35:06 <int-e> ghc has an extension (MagicHash) that allows # to be used in identifiers. its use is somewhat similar to that of @ in (La)TeX.
09:35:06 <defun> oh i see.
09:35:06 <ksf> if you want to define one, go ahead and use -XMagicHash
09:36:12 <ksf> one could use it to name a function "heck usually you don't want to call this but if you really want to I'm nice enough to just have you enable a compiler flag instead of hack the source"
09:36:47 <defun> What is the diff between an unboxed type and a 'vanilla' type?
09:36:59 <quicksilver> although it's probably nicer to put such functions in My.Module.Internals
09:37:10 <quicksilver> rather than (ab)use a GHC-specific extension.
09:37:12 <ksf> a unboxed type doesn't have a data constructor.
09:37:21 <int-e> unboxed types don't have convergent bottoms.
09:37:28 <int-e> hehe.
09:37:31 <ksf> ...which means that it cannot be forced piece-wise.
09:37:40 <Vanadium> Convergent?
09:37:44 <defun> What would be the point of these properties? What are the benefits.
09:37:49 <quicksilver> defun: an unboxed type is *actually* a value, not a pointer to a value.
09:37:49 <int-e> terminating.
09:38:01 <defun> Hmmm...
09:38:01 <quicksilver> clumsily put, I'm afraid.
09:38:06 <ksf> ...or an unboxed pointer to a value.
09:38:15 <int-e> (what I said is really about strictness)
09:38:21 <quicksilver> but the basic idea is it removes a layer of indirection
09:38:33 <quicksilver> it is therefore (a) faster and (b) more memory efficient
09:38:38 <ksf> ...and thus a layer of laziness.
09:38:48 <ksf> or c) blows your stack
09:38:54 <quicksilver> unboxed values can be stored directly in machine registers.
09:39:05 <ksf> or d) slower as you calculate a lot of useless stuff
09:39:08 <quicksilver> with a boxed value, at best, it is the *pointer* that ends up in a register.
09:39:29 <ksf> (ghc does automagic transparent unboxing, though)
09:39:40 <ksf> "transparent" in the same-semantics sense.
09:39:54 <defun> A bit over my head. But I think I get. Used for primitives, and for performance, I guess?
09:39:58 <etpace> Has anyohne here used tagsoup? Is there a better way to extract the text between a tag than: innerText $ takeWhile (≠ TagClose "div") $ head $ partitions (~== "<div class=dditd>") tags
09:40:04 <etpace> it seems a bit verbose
09:40:07 <ksf> ...due to strictness analysing and much other stuff I don't really konw much about.
09:40:08 <Philippa> defun: yep, exactly
09:40:30 <defun> Philippa, all: thanks.
09:49:23 <ksf> http://freetype.sourceforge.net/freetype2/docs/reference/ft2-glyph_management.html#FT_Glyph_To_Bitmap
09:49:26 <ksf> there it is...
09:51:25 <ksf> I guess it won't even be a performance problem to hint each glyph 1000 times, as long as say word boundaries are kept at integer pixels so rastered words can be reused.
09:51:57 <ksf> ...also, there's a max. of 16 different raster possibilities for each glyph, actually.
09:52:25 <ksf> ...16*16 if you take the y axis into account, but I choose not to.
09:52:33 <ksf> I've just missed the simpsons.
09:56:55 <gio1234> hi
10:01:17 <ManateeLazyCat> gio1234: Hi
10:02:02 <weirdo> hey
10:02:09 <weirdo> is a variable just a zero-argument function?
10:03:24 <ksf> there's no such thing as variables.
10:03:44 <ksf> there's only bindings
10:04:08 <quicksilver> weirdo: I'd probably call that a value.
10:04:19 <Philippa> weirdo: variables are just names
10:04:25 <weirdo> :-)
10:04:27 <Philippa> ksf: variables are what values are bound to, smartass
10:04:37 <ksf> ...either to a value, or to a one-argument function (which might happen to return another one-argument function that returns another one-argument function etc)
10:04:49 <ksf> nope.
10:04:54 <ksf> IORefs are variables.
10:04:58 <quicksilver> ksf: nope.
10:04:59 <ksf> as they are _variable_
10:05:01 <Philippa> ksf: I can haz currying isomorphism?
10:05:06 <quicksilver> ksf: Philippa is right, and you are wrong.
10:05:07 <Makoryu> Variables don't. Constants aren't.
10:05:13 <ksf> ...other things are bindings.
10:05:17 <quicksilver> ksf: the use of variables is not about mutability.
10:05:20 <ksf> other names for thingies.
10:05:39 <inimino> f x = 2 * x -- x is a variable
10:05:46 <greap> Hi guys. In HXT, how do you get a collection of transformed elements, eg. To return a list of lists of hrefs in paragraphs.
10:05:53 <greap> ?
10:05:59 <Philippa> (it's sensible enough to talk about n-ary functions, and the curried version is the 'default' rather than the tupled - nullary doesn't really make sense unless you're being mildly daft about a specific monad or something though, there's a reason we coined 'computation', 'action' etc)
10:06:04 <ksf> nope it's a binding. resolved when f is given an argument.
10:06:21 <ksf> _x_does_not_change_between_invocation.
10:06:28 <quicksilver> ksf: you can make up your own language if you like.
10:06:31 <Philippa> ksf: they're variables, in exactly the same sense variables in algebra are. Binding is the process of mapping variables to values.
10:06:33 <ksf> which means that everything that can use it, always sees the same thing.
10:06:49 <quicksilver> ksf: in the language we speak, in (\x -> x), 'x' is a variable.
10:06:50 <ksf> not having variables but bindings is the very thing referential transparency is about.
10:07:03 <Philippa> they are, however, immutable variables
10:07:06 <quicksilver> in the expression "x*2"  is a free variable
10:07:08 <inimino> no :)
10:07:26 <quicksilver> in the expression \x -> x*2, x is a bound variable
10:07:33 <ksf> immutable variables, like dynamic constants?
10:07:37 <quicksilver> this is the standard mathematical meaning of variable.
10:07:43 <greap> my question is way more interesting :)
10:07:56 <quicksilver> mutability is a distraction, that's all.
10:07:57 <Philippa> greap: 'fraid I don't know HXT
10:08:33 <greap> Philippa: Doh.
10:09:18 <Philippa> ksf: this meaning of variable predates things like the turing machine and general hardware computers, btw
10:09:29 <ksf> "immutable variable" is a contradiction in terms just like "alcohol-free beer"
10:09:30 <Philippa> and was applicable when the lambda calculus was defined
10:09:55 <ksf> were'nt monads called "three-valued thingies" back then?
10:10:13 <quicksilver> ksf: in "x*2", x is a variable in the sense that we don't know what it is
10:10:17 <quicksilver> it might vary from case to case.
10:10:18 <ksf> it's never too late to clean up the language.
10:10:20 <Philippa> x=y+2, y=10 <- x never changes, but it's still a variable
10:10:30 <ksf> quicksilver, that's why it's called an "unknown"
10:10:31 <Philippa> ksf: binding is /still/ the wrong term for it
10:10:34 <quicksilver> that's the reason that english word is used.
10:10:36 <ksf> (at least in german)
10:10:51 <quicksilver> ksf: I presume the correct translate of that german word is, then, 'variable'.
10:10:52 <Philippa> ksf: welcome to English, it's not German
10:10:57 <quicksilver> I'm not going to argue about this any more.
10:11:11 <quicksilver> mathematical usage is what it is.
10:11:13 <quicksilver> it makes sense to me, though.
10:11:18 * ksf doesn't care for math
10:11:24 <Philippa> x varies with its context
10:11:39 <Philippa> which may or may not involve, say, computation
10:12:03 <Philippa> ksf: too bad, you're using it every time you write haskell code. Haskell is a mathematical entity
10:12:38 <ksf> ...which is infinitely more useful than the millionth digit of non-existing numbers like pi.
10:12:51 <sleepynate> !
10:12:57 <sleepynate> she's a witch!
10:12:58 <Philippa> aw, look at the little computational supremacist
10:13:02 <ksf> there is a _constructive proof_ for the existence of haskell, after all.
10:13:07 * sleepynate rabblerabblerabble
10:13:10 <ksf> it's called GHC!
10:13:25 <Makoryu> Haskell was a sound stage on Mars!
10:13:30 <Makoryu> Wake up, sheeple!
10:13:40 <Makoryu> It's the purely fictional programming language!
10:13:56 <sleepynate> listen.. everyone knows package rhubarb provides pi.
10:14:22 <sleepynate> therefore, it must exist.
10:14:47 <ksf> there is nothing in a finite universe that provides pi, except your own or you mathematical model's delusions about so-called infinity.
10:14:54 <Jafet> > pi
10:14:54 <lambdabot>   3.141592653589793
10:15:21 <Philippa> like, say, being able to calculate the nth digit for any nat n being significant
10:15:26 <Berengal> So pi is exactly 3.141592653589793. Proof by lambdabot
10:15:34 <burp> > pi :: CReal
10:15:35 <lambdabot>   3.1415926535897932384626433832795028841972
10:15:41 <burp> this is the _real_ pi ;)
10:15:48 <sleepynate> there is nothing in a finite universe that provides haskell iehter.. it's just an idea :)
10:15:51 <ksf> heresy! infidels!
10:15:52 <Philippa> if you're happy to let the nth digit function count as a mathematical entity, there is a constructive entity that can reasonably be called pi
10:16:43 <ksf> see, sheeple, the value of pi depends on radius and grid size.
10:17:01 <ksf> er grid resolution.
10:17:01 <Philippa> anyway, this is almost as bad as watching some lunix kiddie try to tell me that only a compiler that targets machine code is a compiler and only .o files or similar are object code...
10:17:06 <Berengal> The value of pi depends on the curvature of the plane
10:17:11 <ziman> unless you have a good RNG ;)
10:17:19 * jfoutz wonders how you get radiuses and grids without math
10:17:43 <sinelaw> The value of pi depends on its definition
10:17:49 <Berengal> jfoutz, you fake them with pencils
10:17:50 * ksf throws hazelnuts at jfoutz, forming a filled circle around him as they rebound.
10:17:52 <Philippa> sinelaw: thus making pi a variable?
10:17:56 <Berengal> And gridded paper
10:18:13 <Philippa> hi psyk, you're watching the aftermath of an imperative fanboi trying to redefine 'variable' :-)
10:18:35 <sinelaw> Philippa, there is only one common definition (or it's equivalents), no it doesn't vary much.
10:18:39 <ksf> I am _not_ an imperative fanboy.
10:18:47 <sinelaw> that was an imperative statement
10:18:52 <ksf> I just respect the halting problem as the wonder it is.
10:19:04 <Vanadium> sinelaw: So the definition of variable is not, in fact, variable?
10:19:14 <sleepynate> pi = A/r*r
10:19:18 <ksf> wander ye not beyond the realms of computability!
10:19:19 <sleepynate> there. done.
10:19:31 <sleepynate> pi exists
10:19:39 <sleepynate> and sounds kind of like a pirate.
10:19:53 <ziman> pirrational :)
10:19:59 <Philippa> ksf: where computability was ultimately defined fully by rooting it in terms of a physical, imperative process (hi Turing!), so hey
10:20:00 <sleepynate> AWFUL
10:20:06 <sleepynate> +5 internets, ziman
10:20:16 <Berengal> I just ordered a pi from the local pizza shop
10:20:31 <Philippa> sinelaw: there's stuff like the pi calculus to deal with though, where pi is basically syntax ala lambda in the lambda calculus
10:20:33 <Vanadium> Berengal: The best kind of constructive proof
10:20:58 * ksf fears he's beyond the balmer peak
10:21:10 <jfoutz> hahaha
10:21:11 <Berengal> Vanadium, tastiest, at least, unless people start doing proofs on marzipan
10:21:20 <Philippa> sinelaw: everything's meaning depends on the language you interpret it in, including that language itself, cue various realisations as goedel meets reality
10:21:27 <Philippa> (solipsism = least fixed point?)
10:24:29 <Twey> ksf! ksf! ksf! ksf! ksfksfksfksfksfksfksf!!!
10:24:31 <Neriooz> If you want to ask for help with haskell programming problems, is this the right place?
10:24:50 <sleepynate> Neriooz: probably
10:24:52 <Twey> Oh wait, that's Ballmer.
10:25:03 <sleepynate> Neriooz: here, or jupiter
10:25:12 <Twey> I'm undecided whether the Ballmer should be a unit of insanity or baldness.
10:25:40 <Neriooz> okey, well im trying to program a card game
10:25:52 <ksf> 1 balmer is a state-dependent unit translatable into percentage of blood in your alcohol.
10:25:54 <Neriooz> and i want to post a deck of Cards
10:25:58 <sleepynate> ahahah,, qotd Tw	
10:26:17 <Neriooz> my plan is using <+ to put together hands to form a fulldeck
10:26:20 <Berengal> Yay, pi
10:26:36 <Neriooz> like this + (highCards Jack Hearts)
10:26:36 <Neriooz> <+ (smallCards 10 Hearts))
10:26:38 <ksf> It's the only influence M$ ever had and ever will have on jargon, so let them have it.
10:26:45 <Twey> ksf: Ah.  :þ
10:26:54 <Neriooz> but the problem is if i linebreak the code wont work
10:26:55 <holmak> don't forget BSOD
10:27:08 <Neriooz> but if i have a one long line it works
10:27:18 <Neriooz> but as soon as i try to divide it fucks up
10:27:35 <Neriooz> nvm -.-
10:27:39 <Neriooz> got it working
10:27:48 <Berengal> Neriooz, Haskell is indentation based
10:28:04 <Neriooz> forgot to put a small lite space after a linebreak -.-
10:28:07 <aavogt> > [ (b,n) | b <- [False,True], [7..10]]
10:28:08 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
10:28:08 <lambdabot>         against inferred type ...
10:28:20 <aavogt> > [ (b,n) | b <- [False,True], n <- [7..10]]
10:28:21 <lambdabot>   [(False,7),(False,8),(False,9),(False,10),(True,7),(True,8),(True,9),(True,...
10:28:30 <Neriooz> well thanks for your time, got it working :)
10:28:40 <saml> np
10:28:48 <holmak> good luck!
10:31:48 * wmealing wishes he could remember the name of the guy who was working on the clutter bindings.
10:33:57 <b0ef> right, I'm totally lost and this seems so simple;)
10:34:14 <holmak> code troubles?
10:34:21 <wmealing> that.. did it.
10:34:26 <b0ef> http://www.esben-stien.name/fibonacci.hs
10:34:46 <b0ef> I'm missing something fundamental here, I guess;)
10:34:56 <wraith> what's the problem?
10:34:58 <holmak> b0ef: you do not need to use do-notation, since this code is not IO
10:35:18 <b0ef> holmak: well, it is supposed to write out something, later
10:35:19 <arsenm> wmealing: I'm sort of started working on them, but I haven't really gotten too far on them yet
10:35:33 <b0ef> holmak: that's why I have the commented lines at the bottom
10:35:51 <wraith> more certainly, the return type of fib is not a monadic type
10:35:53 <holmak> b0ef: you can only do IO from functions that return "IO something"
10:36:00 <wraith> so do-notation is flat-out wrong
10:36:12 <wmealing> arsenm:  did you go by another nick .. or was I just that tired ?
10:36:19 <holmak> you probably want to have your main function call fib and do the printing there
10:36:40 <arsenm> wmealing: no, unless somebody else is doing that too
10:36:45 <holmak> and leave fib as a pure function, which means no do-notation
10:37:06 <wmealing> arsenm:  were you talking to me about it,  and we talked about the license ?
10:37:18 <wmealing> being, lgpl, etc ?
10:37:29 <holmak> b0ef: does that make sense to you?
10:37:32 <arsenm> wmealing: no. so I guess that's someone else. hmmm....
10:37:46 * ksf wants a memo-map with automagic pruning as things age
10:38:00 <wmealing> arsenm: either way.. keep going .. i really am keen to see it happen
10:38:16 <c_wraith> Hmm.  looking at what you're trying to do, specifically, you might want to change the return type to IO a
10:38:16 <arsenm> wmealing: maybe I should find this person. I'm probably not the most competent person to do it though
10:38:29 <c_wraith> Given that you want to produce output for each recursion level
10:38:53 <c_wraith> @src IO return
10:38:54 <lambdabot> return x    = returnIO x
10:39:05 <wmealing> his name started with M, or so I thought
10:39:08 <b0ef> holmak: hmm, no;), but as it is now, is what is preventing it from working, using "do", even if I don't use IO right now?
10:39:20 <b0ef> s/is what/what/
10:39:24 <wmealing> Makoryu <-- may have been him.. but not sure.
10:39:28 <c_wraith> b0ef:  It doesn't work because "do" notation requires the return type be monadic.
10:39:28 <holmak> b0ef: do you know what monads are?
10:39:37 <Makoryu> Eh?
10:39:44 <Makoryu> wmealing: What's up?
10:39:54 <wmealing> Makoryu:  was I talking to you about clutter ?
10:39:58 <Makoryu> Yep
10:40:03 <Makoryu> I haven't done anything yet!
10:40:10 <wmealing> Makoryu:  arsenm  is also interested.
10:40:14 <wmealing> he's done a little
10:40:14 <Makoryu> Awesome
10:40:23 <arsenm> Makoryu: I sort of started working on some, but I only sort of know what I'm doing
10:40:26 <b0ef> no;), but I'll read up on that, but just one more thing..!. You say leave it as a pure function, but if it's supposed to call itself, how can I use IO in every recursion level then?
10:40:38 <Makoryu> arsenm: I have *no idea* what I'm doing, so that's fine with me :p
10:40:40 <arsenm> Makoryu: currently I can make stages appear with colored rectangles and that's about it
10:40:47 <c_wraith> b0ef: you can't.  to do that, make it an IO action
10:40:51 <ksf> b0ef, like you would do with a pure function.
10:41:01 <holmak> b0ef: well, if you want to print every time, then you have to make it an IO function
10:41:02 <arsenm> Makoryu: I'll be back later if you want to talk about it
10:41:18 <Makoryu> arsenm: Sure. I might be around, I guess
10:41:24 <Makoryu> Gonna check out Boston Haskell
10:41:24 * ksf didn't look at the source but bets that you actually want to use Debug.Trace
10:41:34 <b0ef> holmak: well, it's supposed to print a tree of the recursion, printing the results for each recursion
10:41:49 <holmak> c_wraith: if you want to help b0ef, ill leave it to you. He doesn't need two people saying the same thing to him
10:42:04 <c_wraith> ksf: it only should use that if he's printing debug information, rather than intentionally producing the call tree as output.
10:42:05 <ksf> b0ef, for debugging purposes or as "real" output?
10:42:44 <b0ef> ksf: well, for real output, to create a "nice" way to show what's happening at each recursion..
10:43:31 <wmealing> Makoryu:  looking forward to this, going to rock !
10:43:47 <c_wraith> A writer monad would be better for that, but it's probably beyond what you want to deal with at the moment.
10:43:48 <Makoryu> wmealing: Don't get too excited just yet :p
10:43:51 * ksf would either use Debug.Trace or the Writer monad, it depends.
10:44:01 <b0ef> ksf: like printing out what recursion level we're at and the value of the calculation
10:44:21 <ksf> that sounds like debugging/development information to me
10:44:32 <c_wraith> ksf: unless it's homework. :)
10:44:41 <b0ef> that's what it is..
10:44:47 <ksf> if you don't want to have it in the version you ship to customers, use trace.
10:45:04 <LPhas> dons: you may like to know that i installed xmonad in my archlinux ( from package! with pacman! ) and it created /home/dons.
10:45:28 <ksf> ...homework usually isn't what you'd want to ship to customers, so I'd use Debug.trace
10:45:32 <dons> LPhas: i doubt it...
10:45:32 <b0ef> right, but it's supposed to be in the function, I think; it's pretty basic level..
10:45:40 <dons> LPhas: are you trolling me?
10:45:44 <ksf> as in "in a real app, this isn't interesting"
10:45:49 <LPhas> dons: no i'm not
10:45:50 <b0ef> right
10:46:03 <LPhas> dons: i don't know if they has fixed now
10:46:07 <dons> LPhas: there are thousands of users, we would have had major complaints if this was the case.
10:46:31 <LPhas> dons: are you the mantainer of this package?
10:46:36 <dons> LPhas: no
10:46:54 <dons> http://repos.archlinux.org/viewvc.cgi/xmonad/repos/community-i686/?root=community
10:46:56 <b0ef> so I think I'm supposed to place the IO inside the fib function itself
10:46:58 <ksf> LPhas, if it can do that, your permissions are awesomely broken.
10:47:08 <LPhas> dons: mmh. i don't know. i made ls ../ and i found /home/dons
10:47:27 <dons> LPhas: I honestly don't believe that the Arch Linux xmonad package is the cause of this.
10:47:32 <LPhas> dons: so either you hacked my system or... :p
10:47:38 <dons> the only thing i could imagine is that you downloaded some bogus config file
10:47:59 <LPhas> dons: never changed default xmonad configuration
10:48:00 <dons> LPhas: so come back to me with evidence the arch package is responsible and I'll eat my hat with sauce on.
10:48:16 <ksf> users should'nt be able to create a dir in /home (please check that), so it had to be root doing that.
10:48:18 <LPhas> dons: but it could happened like an year ago
10:48:31 <ksf> LPhas, ls -l
10:48:56 <c_wraith> b0ef: Is your specific assignment available somewhere?  It'd be nice to see exactly what it asks of you.
10:48:57 <LPhas> ksf: pacman should launched with root's rights
10:48:58 <dons> LPhas: easy. remove /home/dons; pacman -S xmonad; tell me what you see.
10:49:21 <b0ef> c_wraith: yes, one moment
10:49:32 <ksf> ...pacman shouldn't allow writes to /home.
10:49:45 <ksf> well then your distro is broken, not your permissions...
10:50:18 <LPhas> dons: server is death
10:50:20 <dons> its not the distro, since the distro package doesn't do this.
10:50:25 * dons walks off
10:50:35 <LPhas> dead
10:51:53 <b0ef> c_wraith: http://www.esben-stien.name/INF121-1.pdf
10:52:05 <b0ef> c_wraith: it's assignment C
10:54:10 <c_wraith> b0ef:  "calling fib n should return or print a string.."  Given that, I'd change the return type to (a, String)
10:54:22 <c_wraith> Then you don't need to worry about IO inside of the calls
10:55:00 <dschoepe> or rather (a,[String])
10:55:40 <b0ef> c_wraith: hmm, right
10:56:12 <b0ef> I'll try a little more then, thanks
10:56:13 <c_wraith> That's something that always confuses me about Writer [] a...
10:56:20 <c_wraith> concatenation in [] isn't efficient
10:56:35 <jmcarthur_work> DList ftw!
10:56:46 <c_wraith> You'd think that there would be a type with efficient concatenation that's used all over the place
10:56:53 <jmcarthur_work> c_wraith, DList :)
10:57:19 <tommd> yes, dlist is a great package!
10:57:27 <c_wraith> I mean, instead of [b] in Writer monad examples. :)
10:57:48 <jmcarthur_work> DList is a common Monoid to use with Writer
10:58:24 <c_wraith> I'm sure in practice it is.  But examples seem to just use List a lot, which is disturbing to me.
11:00:32 <jmcarthur_work> i think Writer is underrepresented in beginner tutorials anyway
11:00:48 <benmachine> I've never used Writer :(
11:00:54 <copumpkin> aw
11:02:06 <copumpkin> > getSum . execWriter $ replicateM 5 (tell (Sum 5))
11:02:07 <lambdabot>   25
11:02:37 <c_wraith> Where are Sum and Product defined?
11:02:38 <aavogt> @index replicateM
11:02:39 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:02:48 <aavogt> c_wraith: Data.Monoid
11:02:49 <jmcarthur_work> c_wraith, Data.Monoid
11:02:52 <c_wraith> Ah.  Thanks.
11:02:53 <jmcarthur_work> ah, i lose
11:02:59 <c_wraith> To both of you. :)
11:03:04 <aavogt> @quote stereo
11:03:04 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
11:03:22 <jmcarthur_work> metastereo? O_o
11:03:23 <benmachine> is Writer completely useless with forever?
11:03:29 <jmcarthur_work> no
11:03:37 <benmachine> @unmtl MaybeT Writer a
11:03:37 <lambdabot> err: `Writer (Maybe a)' is not applied to enough arguments, giving `/\A. (A, Maybe a)'
11:03:42 <lament> @quote haskell
11:03:42 <lambdabot> DanaXu says: Program errors are common in software systems, including those that are constructed from advanced programming languages, such as Haskell
11:03:43 <benmachine> @unmtl MaybeT Writer w a
11:03:43 <lambdabot> (a, Maybe w)
11:03:43 <c_wraith> It has a function that lets you get the current written monoid
11:03:58 <jmcarthur_work> if the monoid is lazy or might stop changing
11:03:59 <c_wraith> So you *could* get some value out of it with forever
11:04:21 <aavogt> > execWriter $ forever (tell [1])
11:04:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:04:27 <copumpkin> > getAny . execWriter $ forever (tell (Any True))
11:04:28 <lambdabot>   True
11:04:30 <jmcarthur_work> :t Data.DList.fromList
11:04:30 <lambdabot> Couldn't find qualified module.
11:04:32 <jmcarthur_work> :(
11:04:34 <ksf> @quote monad
11:04:34 <lambdabot> Philippa says: hey, if the guy wants a monadectomy that's his choice
11:04:56 <copumpkin> > getAll . execWriter $ forever (tell (All False))
11:04:57 <lambdabot>   False
11:06:14 <ksf> @quote lazy
11:06:14 <lambdabot> malig says: quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes. at least it disallows time travel
11:06:36 <sinelaw> @quote ksf
11:06:36 <lambdabot> ksf says: Confusion is the first step to enlightenment
11:06:55 <ksf> @quote sinelaw
11:06:55 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
11:07:10 <sinelaw> It always ends in an insult.
11:07:25 <c_wraith> > 3::Natural < getSum . execWriter $ forever (tell (Sum 1))
11:07:25 <lambdabot>   <no location info>: parse error on input `.'
11:07:28 <ksf> @remember sinelaw It always ends in an insult.
11:07:28 <lambdabot> Nice!
11:07:30 <ksf> there you go
11:07:42 <c_wraith> > 3::Natural < (getSum . execWriter $ forever (tell (Sum 1)))
11:07:42 <lambdabot>   <no location info>: parse error on input `.'
11:07:54 <sinelaw> i should have said "with" :)
11:08:06 <sinelaw> back to work!!
11:08:18 <c_wraith> ok, what am I doing wrong there, syntactically?
11:08:19 <copumpkin> > (3::Natural) < (getSum . execWriter $ forever (tell (Sum 1)))
11:08:20 <lambdabot>   True
11:08:29 * copumpkin muahahahahahahas evilly
11:08:41 <c_wraith> Oh.  I was going to guess that, but I felt like actually learning something instead of throwing around random parens
11:08:42 <c_wraith> :)
11:08:44 <dons> http://donsbot.wordpress.com/2009/09/16/data-binary-performance-improvments-for-haskell-binary-parsing/
11:08:44 <aavogt> :t Sum
11:08:45 <lambdabot> forall a. a -> Sum a
11:08:51 <dons> new Data.Binary release
11:09:00 <aavogt> :t getSum
11:09:01 <lambdabot> forall a. Sum a -> a
11:09:05 * Badger locks copumpkin up
11:09:09 <dons> tommd: relevant to your interests
11:09:10 <copumpkin> :(
11:09:17 <ksf> @quote copumpkin
11:09:17 <lambdabot> No quotes match. Just what do you think you're doing Dave?
11:09:17 <Badger> no evil genii please
11:09:22 <ksf> @quote pumpkin
11:09:22 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
11:11:12 <jmcarthur_work> that one is nasty
11:11:14 <ziman> :D
11:11:28 <jmcarthur_work> 2 unnatural transformations, i'd say
11:11:48 <ksf> @quote jmcarthur
11:11:48 <lambdabot> No quotes match. That's something I cannot allow to happen.
11:11:54 <ksf> @quote jmcarthur_work
11:11:54 <lambdabot> No quotes match.
11:11:58 <jmcarthur_work> @quote geezusfreeek
11:11:58 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
11:12:00 <jmcarthur_work> @quote geezusfreeek
11:12:00 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
11:12:08 <jmcarthur_work> i thought there were more :(
11:12:15 <aavogt> > getSum . fmap show $ Sum 1 `mappend` Sum 2
11:12:16 <lambdabot>   No instance for (GHC.Base.Functor Data.Monoid.Sum)
11:12:16 <lambdabot>    arising from a use of...
11:12:17 <lament> @quote Smerdyakov
11:12:17 <lambdabot> No quotes match. There are some things that I just don't know.
11:12:29 <ksf> @quote lambdabot
11:12:29 <lambdabot> lambdabot says: I know nothing about love.
11:12:40 <b0ef> foo :: (String s, Num a) => a -> a -> s
11:12:41 <Badger> :'(
11:12:43 <ksf> @vixen that's too sad.
11:12:43 <lambdabot> you are soooo interesting
11:12:45 <b0ef> this is not legal?
11:12:48 <copumpkin> jmcarthur_work: I think it forgot some... I used to have more too
11:12:57 <jmcarthur_work> i think so too
11:13:01 <ksf> b0ef, string is a type, not a class.
11:13:14 <ksf> foo :: (Num a) => a -> a -> String
11:13:29 <jmcarthur_work> "jmcarthur: #haskell: Overwhelmingly helpful."
11:13:43 <jmcarthur_work> "lilac: class Monad m where / return and Kleisli compose / must form a monoid <lilac> that's my new monad tutorial haiku <jmcarthur> i think that is the best monad tutorial i have ever read"
11:13:56 <b0ef> ksf: ah
11:14:27 <b0ef> ksf: thanks
11:17:10 <c_wraith> @src Sum
11:17:10 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:17:17 <c_wraith> @src Data.List.Sum
11:17:17 <lambdabot> Source not found. I am sorry.
11:17:42 <camio> @src Data.Monoid.Sum
11:17:42 <lambdabot> Source not found. Maybe you made a typo?
11:20:28 <jmcarthur_work> newtype Sum a = Sum { getSum :: a }, i think
11:24:18 <sleepynate> hey gaiz... what's the best way to do a char/string conversion?
11:24:24 <sleepynate> i'm looking to do something like...
11:24:29 <sleepynate> > foldl1 (+) [ read(head(show x))::Int | x <- [1..20] ]
11:24:30 <lambdabot>   Couldn't match expected type `GHC.Base.String'
11:24:30 <lambdabot>         against inferred typ...
11:24:35 <sleepynate> add up the digits in a string
11:24:58 <b0ef> c_wraith: , but if the function returns a string, am I supposed to use read in each recursion to convert it again?
11:25:17 <mauke> sum . map digitToInt . show
11:25:22 <c_wraith> b0ef:  have it return a pair: (a, String)
11:25:30 <sleepynate> well i feel like a dumbass
11:25:36 <sleepynate> thanks mauke ;)
11:26:03 <b0ef> c_wraith: hmm, yeah, I'll try; thanks
11:26:26 <sleepynate> um
11:26:30 <sleepynate> ><
11:26:42 <copumpkin> wut
11:26:49 <sleepynate> nope nvm
11:26:52 <sleepynate> :)
11:27:04 <jmcarthur_work> i love working with fixpointed data structures
11:27:25 <jmcarthur_work> it's so much cleaner than writing your primitives with explicit recursion
11:27:29 <copumpkin> lol
11:27:43 <copumpkin> I quite like it too, but the newtypes get in the way
11:28:01 <jmcarthur_work> i like the fixpoint package way of doing it
11:28:34 <jmcarthur_work> uses type families to convert a normal structure to an "inner representation" and back
11:28:47 <copumpkin> @hackage fixpoint
11:28:47 <lambdabot> http://hackage.haskell.org/package/fixpoint
11:29:35 <copumpkin> oh that is quite pretty
11:29:43 <jmcarthur_work> i've been using it a lot. i love it
11:30:20 <jmcarthur_work> it lacks some obvious features though
11:30:31 <copumpkin> like what?
11:30:31 <jmcarthur_work> like some rewrite rules, extra morphisms, etc.
11:30:34 <copumpkin> ah
11:30:43 <copumpkin> yeah, we need a zygohistomorphic prepromorphism
11:30:50 <copumpkin> or at least a histomorphism :P
11:31:05 <jmcarthur_work> at least it has the most important basics
11:31:33 <copumpkin> he's got a little chunk of commented-out stuff at the bottom
11:32:20 <jmcarthur_work> i saw it but ignored it
11:32:30 <jmcarthur_work> hmm... looks interesting
11:32:53 <idnar> uhm, what's a fixpointed data structure?
11:33:23 <jmcarthur_work> idnar, you know how you can express a recusive function with fix? it's basically the same with a Fix newtype wrapper
11:33:35 <jmcarthur_work> for structures, that is
11:34:11 <jmcarthur_work> so Fix Maybe is like [], for example
11:34:40 <jmcarthur_work> Fix Id would be a stream
11:35:03 <mauke> fix id is bottom
11:35:08 <c_wraith> There's an Id type?
11:35:15 <copumpkin> Identity
11:35:17 <mauke> @src Identity
11:35:17 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
11:35:18 <jmcarthur_work> it's a functor
11:35:42 <Saizan> Fix Id is the empty type if they are both newtypes
11:35:59 <jmcarthur_work> woops, right
11:35:59 <copumpkin> Cofree Identity then?
11:36:02 <Saizan> Fix ((,) a) is a stream
11:36:03 <jmcarthur_work> yeah
11:36:15 <Saizan> or Cofree Identity, yeah
11:36:21 <jmcarthur_work> i was thinking cofree
11:36:52 <jmcarthur_work> and i was also typing up another example that should have been cofree ratehr than fix
11:37:22 <copumpkin> well Fix Maybe works as a list, Cofree Maybe is a non-empty list
11:37:26 <copumpkin> right?
11:37:33 <jmcarthur_work> hmm
11:37:36 <lilac> is this the same as the Mu we've had in \b for a while?
11:37:40 <jmcarthur_work> i guess so
11:37:49 <copumpkin> lilac: yeah
11:38:08 <Vanadium> How do I install the profiling-enabled versions of packages with cabal?
11:38:24 <copumpkin> jmcarthur_work: http://hackage.haskell.org/packages/archive/category-extras/0.2/doc/html/Control-Recursion.html actually looks quite similar to fixpoint :)
11:38:30 <Asztal> Fix Maybe is a list that doesn't actually contain values, though
11:38:30 <dcoutts> Vanadium: -p or edit your ~/.cabal/config
11:38:38 <Asztal> it's just a number, really
11:38:44 <lilac> Fix Maybe is isomorphic to Nat
11:38:56 <copumpkin> lilac: oh true
11:39:02 <jmcarthur_work> copumpkin, woah, *old* category-extras
11:39:15 <copumpkin> jmcarthur_work: yep, quite a bit easier to pick up :P
11:39:16 <jmcarthur_work> man i was mixing my fix and cofree up all over the place
11:39:35 <lilac> Fix ((,) a `O` Maybe) is a list i think
11:39:43 <lilac> no, that's a non-empty list...
11:39:53 <jmcarthur_work> that looks like cofree :)
11:39:54 <lilac> Fix (Maybe `O` (,) a)
11:39:55 <jfoutz> so after the bananas lenses envelopes and parbed wire paper, where do you find all the things in category extras?
11:39:55 <copumpkin> or data List a b = Nil | Cons a b
11:40:20 <copumpkin> type [] a = Fix (List a), right?
11:40:35 <lilac> copumpkin: sure
11:40:42 <jmcarthur_work> right
11:40:43 * copumpkin renames Mu to Moo
11:40:49 <copumpkin> type [] a = Moo (List a)
11:41:12 <jmcarthur_work> Fix (Maybe :. (,) a)
11:41:29 <copumpkin> :O
11:43:18 * copumpkin has decided to become l33ter by writing all his haskell using category-extras
11:43:36 <copumpkin> and its recursion schemes, and data combinators
11:43:58 <jfoutz> no next paper? just go figure it out at this point?
11:44:16 <copumpkin> ?
11:44:23 <copumpkin> oh
11:44:31 * jfoutz whines
11:44:38 <copumpkin> I'm not sure, I just poke around category-extras when I'm feeling adventurous
11:45:06 <jfoutz> i see.
11:45:51 <copumpkin> instance Adjunction ((,) a) ((->) a) where
11:45:51 <copumpkin>   unit t = \x -> (x,t)
11:45:51 <copumpkin>   counit (x,f) = f x
11:46:04 <jfoutz> where did you pick up the term "histomorphism"
11:46:19 <copumpkin> jfoutz: by talking to edwardk :P
11:46:39 <copumpkin> jfoutz: http://comonad.com/reader/2009/recursion-schemes/
11:46:57 <jfoutz> hrm. i get the feeling there's a big library of stuff out there i'm missing... but maybe i'm imagining that.
11:46:58 <copumpkin> jfoutz: apparently there used to be more but he lost his blog and the other stuff is lost :(
11:47:03 <copumpkin> that was before my time though :/
11:47:16 <jfoutz> oh. uhg.
11:47:45 <jfoutz> oh, that's cool!
11:47:56 <jfoutz> the site... not the crash.
11:48:02 <copumpkin> Given functors f and g, Adjunction f g implies Monad (g `'O'` f) and Comonad (f `'O'` g). is cool
11:49:52 <maltem> Is 'O' meta-syntax for composition of types?
11:50:28 <copumpkin> newtype (O f g) a = Comp { deComp :: f (g a) }
11:50:37 <copumpkin> (yep)
11:52:00 <copumpkin> not a fan of the big O myself :P
11:53:29 <maltem> wrapped in a newtype, it still looks useful somehow
11:53:42 <Wooga> why last [1..] counting through infinity instead of just sayint that it is infinity?
11:53:49 <maltem> (nearly a haiku)
11:53:51 <Wooga> in case there is a few of them?
11:53:58 <copumpkin> Wooga: how would it know?
11:53:59 <Wooga> lik in [1,1..1*3] ?
11:54:33 <Wooga> copumpkin: hm, isn't there any checks for infinity lists?
11:54:40 <jfoutz> > ['a'..]
11:54:40 <copumpkin> how would there be?
11:54:41 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
11:54:53 <jfoutz> > length ['a'..]
11:54:53 <lambdabot>   1114015
11:54:54 <Wooga> ['a'..] is not inifinity
11:55:07 <jfoutz> how many would there be?
11:55:07 <Makoryu> Wooga: That's because Char is bounded
11:55:09 <Wooga> yet supposed to be
11:55:19 <copumpkin> Wooga: how would haskell check?
11:55:23 <copumpkin> Wooga: and why is it supposed to be?
11:55:34 <c_wraith> > maxbound::Int
11:55:35 <lambdabot>   Not in scope: `maxbound'
11:55:39 <c_wraith> > maxBound::Int
11:55:40 <lambdabot>   9223372036854775807
11:55:46 <c_wraith> > maxBound::Integer
11:55:47 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
11:55:47 <lambdabot>    arising...
11:56:25 <jmcarthur_work> i didn't really take category-extras seriously until i realized it actually could be useful for *discovering* useful abstractions
11:56:49 <jmcarthur_work> "oh man, these form an adjunction? awesome!"
11:56:55 <Wooga> copumpkin: maybe with sum speshul flag magick, marking infinity lists in internals
11:57:05 <copumpkin> @type fix (ap Data.Traversable.sequence)
11:57:06 <lambdabot> forall (t :: * -> *) a. (Data.Traversable.Traversable t) => t (t a -> a) -> t a
11:57:10 <Wooga> making lazy a bit more lazy
11:57:16 <mauke> Wooga: how do the internals know that the list is infinite?
11:57:16 <jmcarthur_work> more lazy how?
11:57:53 <Twey> Wooga: Infinite lists are not magic, and the full structure of the list is not known until evaluation.
11:58:05 <copumpkin> they're sort of implicit functions
11:58:18 <Wooga> mauke: by the syntax of course, if list was clearly defined as inifinte one, it is possible
11:58:19 <Twey> *Everything* is sort of an implicit function
11:58:27 <sleepynate> jmcarthur_work: by adding a sun-hat and a mint julip.
11:58:35 <Twey> Hahaha.
11:58:37 <sleepynate> everything seems more lazy that way.
11:59:09 <jmcarthur_work> Wooga, even in the few cases that it may be possible, what is the purpose?
11:59:16 <copumpkin> for my definition of loeb above, how can I get it to work for any functor?
11:59:21 <mauke> Wooga: what syntax?
11:59:34 <mauke> there is no syntax for infinite lists
12:00:29 <Wooga> mauke: when you write [1..], you can tell it is tend to infinity
12:00:31 <copumpkin> @let loeb = fix (ap Data.Traversable.sequence)
12:00:31 <lambdabot>  Defined.
12:00:34 <copumpkin> > loeb [ (!!5), const 3, liftM2 (+) (!!0) (!!1), (*2) . (!!2), length, const 17]
12:00:35 <lambdabot>   [17,3,20,40,6,17]
12:01:00 <mauke> Wooga: no, you can't
12:01:01 <Wooga> jmcarthur_work: well, maybe there is not particular use of such thing, but it is should looks nice
12:01:07 <jfoutz> :t [1..]
12:01:08 <lambdabot> forall t. (Num t, Enum t) => [t]
12:01:22 <mauke> > length ([1..] :: Word8)
12:01:22 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
12:01:23 <lambdabot>         against inferred type...
12:01:26 <mauke> > length ([1..] :: [Word8])
12:01:27 <lambdabot>   255
12:01:42 <Wooga> oh...
12:01:45 <copumpkin> if you had sized vectors, you could prove that your list will be infinite or finite
12:01:53 <Wooga> so there is no real infinity of world of limited memory
12:02:02 <copumpkin> Wooga: there is actually
12:02:33 <copumpkin> last [1..] should run in constant memory
12:02:41 <copumpkin> until the end of the universe
12:02:42 <mauke> copumpkin: no
12:02:44 <c_wraith> copumpkin: no
12:02:44 <copumpkin> no?
12:02:53 <c_wraith> Integer takes more space as the numbers increase
12:02:59 <copumpkin> fine
12:03:01 <mauke> > repeat 1
12:03:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:03:03 <copumpkin> last [1,1..]
12:03:08 <mauke> ^ infinite list in constant memory
12:03:11 <copumpkin> c_wraith: that was clearly not the point though ;)
12:03:21 <copumpkin> (and mauke)
12:03:22 <c_wraith> Yeah, but sometimes you have to be pedantic. :)
12:03:50 <copumpkin> then we should stop saying Integers are arbitrary precision at all :P
12:03:58 <copumpkin> they only work up to about 2^37 bits or something like that
12:03:59 <jmcarthur_work> they aren't
12:04:05 <copumpkin> even if you have more memory than that
12:04:23 <c_wraith> that's tragic ;(
12:04:36 <copumpkin> yep
12:04:46 <jmcarthur_work> we should obviously have newtype Integer = Integer [Int]
12:05:02 <copumpkin> that's more or less integer-simple's representation
12:05:25 <jmcarthur_work> actually, data Integer = Integer Bool [Word]
12:05:30 <jmcarthur_work> less redundant
12:05:34 <c_wraith> So, this means we could declare instance Bounded Integer where ...  :)
12:05:49 <copumpkin> damn right
12:06:12 <jmcarthur_work> maxBound :: Integer    ==>   out of memory
12:06:46 <copumpkin> depends on your computer
12:06:48 * mauke almost googles for most-positive-bignum
12:06:49 <copumpkin> :)
12:06:59 <jmcarthur_work> > 2^37
12:06:59 <lambdabot>   137438953472
12:07:14 * mauke actually does it
12:07:16 <jmcarthur_work> 137 Gb
12:07:17 <mauke> http://jwz.livejournal.com/854482.html
12:07:24 <copumpkin> 128 GB
12:07:29 <copumpkin> GiB
12:07:32 <copumpkin> ;)
12:08:06 <copumpkin> wow, that color scheme is painful
12:08:09 * copumpkin uses readability
12:08:25 <copumpkin> ahh
12:08:31 <Twey> Arrgh, eye-burn
12:08:51 <copumpkin> readability ftw
12:08:58 <copumpkin> http://lab.arc90.com/experiments/readability/
12:09:10 <fxr> hah banned from #lisp again
12:09:22 <copumpkin> fxr: trolling?
12:09:25 <jmcarthur_work> i bet they hate a lot of haskellers
12:09:29 <fxr> life is funny, especially when you say the truth.
12:09:45 * jmcarthur_work joins lisp to see what's what
12:10:13 * copumpkin founds #lithp
12:10:17 <fxr> copumpkin: nope I'm just trying to get some ideas for an eval bot or some kind of collab ool.
12:10:27 <Twey> Hahaha, that hurts
12:10:28 <blackdog> Twey: really? I kinda like green on black
12:10:37 <Twey> blackdog: It's lovely until you look away.
12:10:43 <jmcarthur_work> "<sykopomp> rude people jumping in the lion's den." right before copumpkin joined :P
12:10:57 <fxr> :( I'm not rude
12:11:08 <blackdog> you've got more green receptors in your eyes, according to my very clever neuroscientist girlfriend - you can read green on black in very low light conditions
12:11:29 <c_wraith> there's a reason 16-bit color puts RGB at 565
12:11:33 <jmcarthur_work> a read a study that showed that green on yellow is the easiest to read
12:11:42 <c_wraith> You're certainly more sensitive to variations in shade of green
12:11:43 <jmcarthur_work> *i read
12:11:58 <Twey> blackdog: I have?  Cool!
12:12:13 <flux> wouldn't white on black however still reflect the most light in any case?
12:12:39 <c_wraith> but we're talking about computer screens.  that's emitted, not reflected.  unless you're using e-paper.
12:13:00 <copumpkin> color e-paper :o
12:13:26 <c_wraith> color e-paper is theoretically possible.
12:13:36 <c_wraith> Might even be practially possible in the next 20 years
12:13:39 <c_wraith> that'd be neat. :)
12:14:20 <c_wraith> I had a thought recently for e-paper bumper stickers, seeing how fast political bumper stickers go out of date.
12:14:30 <plumenator> I tried creating a hierarchical module as suggested in "learn you a haskell" by putting sub modules in a directory, but I got this error: "    Could not find module `Geometry.Sphere':
12:14:33 <c_wraith> With e-paper, you could always update them for your cause/candidate of choice!
12:14:37 <plumenator>       Use -v to see a list of the files searched for.
12:14:37 <plumenator> Failed, modules loaded: none."
12:14:44 <plumenator> Opps, should have use the paste box
12:14:47 <blackdog> c_wraith: half the point of a bumper sticker is commitment, though. admittedly not a very high commitment.
12:14:52 <flux> what's the definition for e-paper anyway?
12:14:57 <Botje> plumenator: did you put Sphere.hs in a directory called Geometry?
12:15:05 <copumpkin> wow
12:15:06 <plumenator> I did
12:15:07 <Botje> that's where ghc is looking.
12:15:09 <copumpkin> data Coreader r a = Coreader r a  is really exciting
12:15:19 * Botje eyes copumpkin 
12:15:22 <copumpkin> runCoreader (Coreader r a) = (r,a)
12:15:53 <c_wraith> copumpkin: on that note, I'm going to lunch
12:15:57 <thoughtpolice> copumpkin: so, I'm about to have to run off to class, but we should find some time to sit in #ghc and talk to them about our plans to work on/eventually maintain a 64bit SL port or somesuch
12:16:05 <copumpkin> thoughtpolice: yay, sure thing
12:16:16 <plumenator> I know, I even ran it with -v, it looked like it was looking for the .hi file, I then compile sphere.hs, but it still gives the same error.
12:16:22 <thoughtpolice> copumpkin: and also find plenty of time to bug Igloo/JaffaCake etc. :)
12:16:27 <srush> why doesn't Data.Map have a Data instance
12:16:30 <jmcarthur_work> copumpkin, forms an ajdunction with Reader too
12:16:36 <copumpkin> thoughtpolice: I think they're about ready to strangle me, it's your turn! :P
12:16:41 <jmcarthur_work> *adjunction
12:16:44 <srush> or I guess it has one but it doesn't seem to work
12:16:47 <copumpkin> jmcarthur_work: yeah, that's where I found it, was curious what it was :)
12:17:02 <thoughtpolice> copumpkin: we should also probably find a good time when we know we're both available to brainstorm & hack
12:17:05 <lilac> @hoogle MonadPlus m => Bool -> String -> m ()
12:17:05 <lambdabot> Language.Haskell.TH.Syntax qReport :: Quasi m => Bool -> String -> m ()
12:17:05 <lambdabot> Language.Haskell.TH report :: Bool -> String -> Q ()
12:17:05 <lambdabot> Language.Haskell.TH.Syntax report :: Bool -> String -> Q ()
12:17:08 <Botje> weird :(
12:17:37 <lilac> is there a standard 'assert True s = return (); assert False s = fail s' ?
12:17:38 <copumpkin> thoughtpolice: sounds good :) my schedule is generally pretty flexible and we're almost in the same time zone, so just let me know when you're free
12:17:49 <mauke> @src guard
12:17:49 <lambdabot> guard True  =  return ()
12:17:49 <lambdabot> guard False =  mzero
12:17:53 <thoughtpolice> copumpkin: what time is it for you right now?
12:17:58 <jmcarthur_work> copumpkin, i've toyed with that exact adjunction as a relationship between events and behaviors in frp before, but i didn't really discover anything out of that venture iirc
12:17:59 <copumpkin> thoughtpolice: 3:17pm
12:18:20 <thoughtpolice> copumpkin: k. the main thing is that I need to tell you when I have time, because school + job means I need a schedule :P
12:18:23 <copumpkin> @localtime thoughtpolice
12:18:24 <lambdabot> Local time for thoughtpolice is Wed Sep 16 21:18:23 2009
12:18:27 <lilac> mauke: mzero does not provide a custom message :-/
12:18:37 <jmcarthur_work> since behaviors are like readers of time and event occurrences are like coreaders of time
12:18:45 <copumpkin> thoughtpolice: whoa, wrong localtime?
12:18:51 <thoughtpolice> copumpkin: this IRC account is on Lemmih's box in sweden
12:18:55 <copumpkin> thoughtpolice: lol ok
12:18:56 <mauke> lilac: fail doesn't either, assuming you're in [] or Maybe
12:19:08 <lilac> mauke: i'm not. i'm in a MonadPlus which has decent error handling
12:19:24 <lilac> mauke: imagine that i'm using Parsec, perhaps :)
12:19:24 <thoughtpolice> copumpkin: because it's always online so I just screen my irssi session and connect from anywhere :P
12:19:31 <copumpkin> ah :)
12:19:51 <copumpkin> zomg, awesome operator
12:19:51 <copumpkin> (>>$<<) :: Bizap p q => p (a -> c) (b -> c) -> q a b -> c
12:20:10 <burp> >>>$$$<<<
12:20:17 <jmcarthur_work> >>>>$$$$<<<<
12:20:21 <lilac> burp: isn't that a spam combinator?
12:20:37 <mcnster> hi.  my math is very rusty.  how to i write "the twelfth root of 2" in haskell?
12:20:53 <aavogt> > 2 ** (1/12)
12:20:54 <lambdabot>   1.0594630943592953
12:21:10 <fxr> anyone used postmaster for some kind of postfix filter stuff?
12:21:28 <mcnster> sweet.  thanks aavogt :)
12:21:35 <srush> it looks like Data.Map just throws a runtime error Norep
12:21:49 <copumpkin> mcnster: working with music eh :P
12:21:51 <srush> is there a standard way of getting around this?
12:21:59 <lilac> mauke: on reflection perhaps i'm looking for some kind of exception monad typeclass rather than just using 'fail'?
12:22:07 <mcnster> copumpkin: :)
12:22:34 * Cale decides that mcnster must be doing something with music.
12:22:46 <lorph> is there a haskell ide with autocomplete
12:23:01 <aavogt> hmm, that's not a very common temparment though?
12:23:09 * mcnster Cale is correct :)
12:23:09 <lament> it's the most common one
12:23:18 <Cale> aavogt: It's the most common temperament today.
12:23:18 <b0ef> c_wraith: I'm totally at loss;) - is it something like this you mean? - http://www.esben-stien.name/fibonacci.hs
12:23:31 <Cale> aavogt: It makes all the keys sound equally bad ;)
12:23:37 <jmcarthur_work> Cale, good catch!
12:23:38 <lilac> Cale: depends which instrument you're playing
12:24:14 <burp> http://www.esben-stien.name/fibonacci.hs <- wow this is horrible ;)
12:24:31 <lament> lilac: it's the most common in use, regardless of the instrument (mainly because pianos and guitars are the most popular)
12:24:32 <copumpkin> aw
12:24:55 <lilac> lament: pianos are usually well-tempered not even-tempered, i thought?
12:24:56 <copumpkin> b0ef: I think you want Writer
12:25:01 <lament> lilac: even
12:25:04 <lament> i mean equal
12:25:34 <jmcarthur_work> oh i credited Cale with something copumpkin said first
12:26:34 <b0ef> copumpkin: I'll try to check out Writer, then; thanks
12:26:43 <Cale> jmcarthur_work: Oh, heh, I didn't notice that either somehow. Sorry copumpkin! :)
12:26:48 <lilac> lament: do you have a source on that?
12:27:09 <copumpkin> oh, I didn't even notice :) thanks!
12:27:12 * copumpkin beams
12:27:12 <b0ef> burp: yeah, I know; I just don't get it;)
12:27:26 <b0ef> I want my c back;)
12:27:32 <copumpkin> b0ef: to understand Writer, you must first understand Monoid
12:27:45 <copumpkin> b0ef: DO U NO HO MONOID R FORMED?
12:27:46 <jmcarthur_work> but Monoid is easy, so don't worry
12:27:58 <b0ef> well, we never had any monoid in class, yet, so I don't think he has meant us to use that..
12:28:10 <copumpkin> YOU NEED TO DO WAY INSTAIN ASSOCIATIVE OPERATION
12:28:59 <Cale> lilac: As far as I know, well-tempered pianos have been largely out of style for quite some time. They sound lovely on their own, but you can't really play them along with other instruments, and music can't be transposed freely into any key you'd like on a well-tempered piano.
12:29:08 <lilac> lament: also i don't think pianos and guitars necessarily outweigh all the wind instruments, nor oriental string instruments
12:29:12 <Cale> (because every key sounds different)
12:29:50 <lilac> Cale: i could certainly believe that to be the case :) but i like to correct my knowledge with facts i can cite ;-)
12:31:01 <copumpkin> I'd be interested in hearing Bach's Well-Tempered Clavier on an actual on
12:31:01 <copumpkin> e
12:31:46 <Cale> copumpkin: I remember seeing a Perimeter Institute talk where a guy brought... I think it was 3 pianos on stage.
12:32:19 <Cale> copumpkin: and discussed the physics of tunings as well as performing some pieces on the different pianos so that you could hear the difference :)
12:32:29 <copumpkin> interesting
12:32:31 <copumpkin> is that online?
12:32:40 <Cale> I don't know.
12:32:49 <Cale> I saw it on TV, I think.
12:33:01 <copumpkin> ah
12:33:06 <jmcarthur_work> hmm... now you guys got me thinking about music and music theory. thanks a lot
12:33:28 <copumpkin> music is fun!
12:33:41 <copumpkin> someone should apply CT to music
12:34:02 <blackdog> lorph: emacs with hippie-expand and flymake make a decent simulacrum
12:34:02 <jmcarthur_work> hmm.... i thought that had already been done a little
12:34:13 <blackdog> lorph: flymake's sort of a bear to set up, though.
12:35:29 <jmcarthur_work> hmm, guess not
12:39:51 <aavogt> how does one go about handling unix signals in haskell program?
12:41:29 <blackh> aavogt: What signal do you want to handle?
12:41:57 <aavogt> C-c
12:42:06 <aavogt> I want to clean up before exiting
12:42:49 <blackh> aavogt: Well, you can do it nicely if you write some C.  I can tell you what to do.  I have no idea whether anyone has done it before.
12:43:53 <copumpkin> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/unix/System-Posix-Signals.html ?
12:44:02 <copumpkin> or http://darcs.haskell.org/~simonmar/unix/System-Posix-Signals.html#4 ?
12:44:20 <copumpkin> (the latter doesn't exist yet apparently, except in that branch)
12:44:21 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/2451
12:47:58 <dino-> aavogt: I've done things like that. You can handle signals like sigint etc
12:48:24 <copumpkin> you could even add simple multiple handlers of a single signal
12:48:29 <copumpkin> on top of the existing api
12:48:36 <copumpkin> you wouldn't be able to define precedence easily though
12:50:32 <dino-> iirc System.Posix.Signals
12:50:39 <aavogt> thanks
12:51:24 <Sclytrack> You must all have really big brains, especially being able to use such a complex language like haskell
12:51:59 <ksf> b0ef, the two dead-simple examples of a monoid are the natural numbers under + with 0 as identity, and the natural numbers under * with 1 as identity. then there's strings under concatenation with the empty string as identity, and copumkin's mother.
12:52:02 <dino-> I've done some signal stuff to be able to stop a daemon in this project: http://ui3.info/d/proj/uacpid.html
12:52:15 <dino-> In particular, the main source file: http://ui3.info/darcs/uacpid/src/main.hs
12:52:45 <dino-> aavogt: ^^
12:52:53 <blackh> Scyltrack: Blah blah blah monoid blah blah endo-functor, etc, etc, etc
12:53:18 <blackh> Scyltrack: You'll pick it up.
12:53:50 <Sclytrack> In another life perhaps :-)
12:54:07 <dino-> blackh: You guys have no signal handling on that iPhone OSX for gaming? I'm shocked!
12:55:20 <blackh> Scyltrack: I promise you, Haskell is not difficult - it's just different.
12:55:36 <blackh> dino-: Bah! Who needs it?
12:55:38 <roconnor> It's programming that is difficult.
12:55:49 <blackdog> blackh: yeah, the learning curve isn't that steep, it just doesn't ever plateau
12:55:58 <copumpkin> Sclytrack: the language itself is not complicated, it's just capable of expressing very abstract things. And we happen to take advantage of that
12:56:04 <blackh> blackdog: That's it, exactly!
12:56:37 <blackdog> which is kind of a bummer in a way - if i'd put the same amount of time into ruby, i could call myself an expert by now, rather than just an enthusiastic amateur:)
12:56:59 <copumpkin> there just isn't much depth to ruby
12:57:01 <copumpkin> in my experience
12:57:07 <copumpkin> you can do crazy metaprogramming things
12:57:10 <copumpkin> and then you're pretty much done
12:57:15 <blackh> blackdog: If I'd put the same amount of effort into Ruby, I would be writing code about 1/3rd of the speed
12:57:38 <blackdog> 1/3rd? you must be a hell of a ruby programmer
12:57:57 <blackh> I say a 1/3rd, but really I mean 1/30000th
12:57:59 <copumpkin> :)
12:58:11 <blackdog> i pulled some stats from the benchmark game for a talk on my Ruby/Haskell bridge - one of them was 317 times slower
12:58:13 <aavogt> ruby has a FFI though?
12:58:20 <blackdog> aavogt: yeah.
12:59:01 <blackdog> it has an FFI to Haskell now too <plugplugplug>
12:59:26 * copumpkin plugplugplugs blackdog too
12:59:37 * copumpkin already tweeted it once, maybe I'll do it again soon
12:59:38 <blackdog> thank you. i think.
12:59:53 <fbru02> blackdog ah you are the one of the project that first worked with jhc and now with ghc ?
12:59:54 <copumpkin> oh, I see that sounds rather rude out of context
13:00:38 <Twey> Hahaha.
13:01:11 <blackdog> copumpkin: really? I missed that tweet, and i've been fairly assidously watching twitter
13:01:20 <blackdog> fbru02: yeah, that's my baby
13:01:25 <blackdog> my ugly, hairy baby.
13:01:36 <fbru02> blackdog: i have to try it one day seems cool
13:01:38 <Twey> blackdog: Did you settle on a name?
13:01:53 <copumpkin> blackdog: http://twitter.com/copumpkin/status/3275514745 a while ago :) when you just started
13:02:12 <Twey> Ooh!
13:02:26 <blackdog> copumpkin: aw, cheers. i don't think it did anything at all back then :)
13:02:27 <Twey> You stuck with my suggestion
13:02:36 * Twey named blackdog's baby!  *pride*
13:02:40 <blackdog> Hubris? yeah :)
13:02:47 <Cale> http://hackage.haskell.org/packages/archive/chp/1.3.1/doc/html/Control-Concurrent-CHP-Monad.html#t%3APoisonable -- awesome
13:02:48 <copumpkin> blackdog: yeah, I realized that after tweeting it but liked the idea so I decided not to retract the tweet :P
13:02:55 <copumpkin> I sent all of 221 people to your repo!
13:03:08 <copumpkin> ack, poison
13:03:19 <blackdog> I'd come up with the name before and rejected it, but when it came up again i figure it was unavoidable
13:03:20 <Cale> This CHP library is really extensive.
13:04:04 * copumpkin hasn't really looked at it yet
13:04:11 * copumpkin looks at it
13:04:15 <jmcarthur_work> yeah it look really cool
13:04:23 <Twey> Yeah, I like the look of CHP a lot.
13:04:43 <blackdog> fbru02: beta testers + hackers always welcome, but you need to have GHC HEAD to get it going atm.
13:05:08 <fbru02> blackdog: 6.10 or 6.12  ?
13:05:13 <copumpkin> 11
13:05:14 <blackdog> 6.12
13:05:23 <blackdog> heh. well, yes. 11.
13:08:29 <copumpkin> oh so <-> in CHP is like amb, but in a different monad?
13:08:39 <msteele_> I'm playing around with CHP as we speak.  It's been nice to work with so far.
13:09:04 <jmcarthur_work> copumpkin, that is my impression
13:09:08 <c_wraith> I don't even live in california, and I can't read that as anything but California Highway Patrol
13:10:36 <Cale> copumpkin: Seems that way. x <-> y is the same as alt [x,y], and alt picks the first available action (or an arbitrary one if more than one is available) and runs it.
13:10:39 <msteele_> What is amb?  I don't see it in hackage or hoogle.
13:10:47 <jmcarthur_work> msteele_, look for unamb
13:10:47 <copumpkin> @hackage unamb
13:10:48 <lambdabot> http://hackage.haskell.org/package/unamb
13:11:15 <jmcarthur_work> msteele_, and look to lub for something more general
13:11:18 <Cale> It's not *quite* like the amb from that library
13:11:35 <jmcarthur_work> not really. i think <-> leaves something on one of the channels?
13:11:36 <Cale> It's a bit more like orElse from STM
13:11:46 <jmcarthur_work> *might leave something
13:11:57 <jmcarthur_work> if both channels have something
13:12:05 <copumpkin> @type fix (ap sequence)
13:12:06 <lambdabot> forall a. [[a] -> a] -> [a]
13:12:21 <copumpkin> does anyone know how I could make that work with an arbitrary functor again, without writing loeb the traditional way?
13:12:21 <Cale> (<->) :: CHP a -> CHP a -> CHP a
13:12:52 <aavogt> :t fix (ap Data.Traversable.sequenceA)
13:12:53 <lambdabot> forall (t :: * -> *) a. (Data.Traversable.Traversable t) => t (t a -> a) -> t a
13:13:03 <copumpkin> oh, so it's ((return . unsafePerformIO) .) . liftA2 (amb)
13:13:05 <copumpkin> or something like that
13:13:11 <msteele_> <-> chooses whichever argument that's not waiting on a communication.
13:13:12 <copumpkin> aavogt: yeah, I had that, but that's still more restrictive than jus tFunctor
13:14:30 <c_wraith> copumpkin: Using ap implies that you can't write it without at least Applicative
13:14:41 <copumpkin> c_wraith: I'm using ap on the function monad
13:14:53 <c_wraith> Oh.  Ok, that clears things up
13:14:54 <Cale> :t fix (fmap . flip id =<<)
13:14:55 <lambdabot> forall (f :: * -> *) c. (Functor f) => f (f c -> c) -> f c
13:15:07 <Cale> hmm
13:15:19 <copumpkin> Cale: yeah, that's what I started with, but was wondering if I could do it more succinctly without restricting the type too much
13:15:42 <aavogt> :t (fmap . flip id =<<)
13:15:43 <lambdabot> forall (f :: * -> *) a c. (Functor f) => (f (a -> c) -> a) -> f (a -> c) -> f c
13:15:54 <Cale> Kind of an ugly section that.
13:21:15 <lorph> is there a haskell ide with autocomplete?
13:22:48 <copumpkin> autocomplete is fairly hard
13:23:07 <mauke> it's trivial if you do it stupidly :-)
13:23:26 <copumpkin> lol ok
13:24:04 <blackdog> lorph: did you see my comment/
13:24:10 <Cale> lorph: There are not so many Haskell IDEs. Most people get along with a text editor and ghci.
13:24:27 <blackdog> lorph: emacs with hippie-expand and flymake make a decent simulacrum
13:25:01 <blackdog> mauke: a dumb expander and then a checker work surprisingly well
13:25:46 <blackdog> also, i want to know why the FP group in Sydney gets 20-30 people reliably and the NY one seems to average 4...
13:26:11 <aavogt> blackdog: unsw?
13:26:18 <benmachine> vim can autocomplete I just don't know how to do it
13:26:19 <Cale> blackdog: They use Haskell in the university curriculums there, don't they?
13:26:24 <mauke> benmachine: ctrl-p
13:26:38 <blackdog> aavogt: they're maybe a quarter of the people there
13:26:46 <lorph> blackdog: no i didn't see you rcomment
13:27:03 <benmachine> mauke: wow, I thought it was more complicated than that, thanks :)
13:27:04 <lorph> it would be nice to have ghci style autocomplete in an ide
13:27:07 <blackdog> Cale: yeah. but we're ten times smaller in population...
13:27:18 <Sclytrack> lambdabots don't scare me
13:27:34 <aavogt> @slap Sclytrack
13:27:34 <lambdabot> go slap Sclytrack yourself
13:27:34 <lorph> I tried eclipsefp and leksah, and they both didn't h ave autocomplete
13:27:40 <aavogt> heh
13:28:06 <blackdog> lorph: it's a combination problem. first you have to choose a language, and then an editor/IDE - the market for the combination is much, much smaller.
13:28:07 <Cale> :t fix (ap (flip fmap) . (flip id .))
13:28:08 <lambdabot> forall (f :: * -> *) c. (Functor f) => f (f c -> c) -> f c
13:28:14 <copumpkin> zomg
13:28:16 * blackdog uses market in its loosest possible sense
13:28:18 <Cale> (that one's by hand...)
13:28:35 <lorph> so I take it there's no such thing?
13:28:37 <copumpkin> I guess (flip id .) is a bit like ($ x)
13:28:54 <Cale> yeah
13:29:14 <|Steve|> :t flip id
13:29:15 <lambdabot> forall b c. b -> (b -> c) -> c
13:29:16 <blackdog> lorph: not with the polish that you want. you can put it together out of smaller pieces if you don't mind getting your hands dirty. scion looks like it might be evolving that way.
13:29:42 <copumpkin> it would be funny if (->) were associative
13:29:53 <ksf> chp is the perfect bland of evil IO and pure and elegant concurrency
13:29:59 <ksf> not entirely unlike frp
13:31:25 <ksf> I'm still trying to find something in channels that's isomorphic to a function call / map lookup, thoug.h
13:31:46 <copumpkin> how do you mean?
13:32:41 <ksf> frankly, I don't really know, because I can't really imagine the code that uses it.
13:33:09 <Berengal> New GHC release soon. Almost feels like christmas
13:33:12 <ksf> the problem I'm thinking about is a glyph cache.
13:33:56 <ksf> ...in general, anything IO that you might want to cache. you've got some key to lookup it with, some internal knowledge to generate stuff, and some measure to throw away memoized data if it gets stale.
13:34:48 <sshc> Berengal: what's new in this release?
13:35:18 <copumpkin> sshc: new parallel speedups, plenty of bugfixes, live tracing, and so on
13:35:54 <aavogt> (tuple,) sections?
13:35:54 <Berengal> sshc, bunch of socks, some dvds, chocolate
13:35:57 * ksf isn't sure whether that fits within the paradigm, at all.
13:36:01 <Preben> Hi guys, have installed ghci 6.8.2 on ubuntu, when im trying to load my program im getting this message - Could not find module `test.sh' - what to do?
13:36:19 <copumpkin> aavogt: oh yeah :)
13:36:28 <ksf> Preben, do you mean test.hs?
13:37:40 <Preben> ksf what do you mean? im trying to load my program "test.hs"  and getting this from the prelude <command line>:
13:37:40 <Preben>     Could not find module `test.sh':
13:37:40 <Preben>       Use -v to see a list of the files searched for.
13:37:40 <Preben> Failed, modules loaded: none
13:38:08 <Berengal> Preben, use :load
13:38:11 <c_wraith> try using :load test
13:38:25 <mauke> test.sh? that looks wrong
13:38:26 <Mion> Preben: well, .sh and .hs is not the same
13:38:35 <Preben> i am
13:38:38 <c_wraith> Don't supply an extension at all, if you're using :load
13:39:13 <Preben> omg didnt realice, :P the file was named .sh not hs
13:39:14 <Berengal> :load handles extensions just fine, as long as you're not typoing ;)
13:39:17 <Preben> :P
13:42:02 <Cale> Preben: also, at some point in the near future, consider upgrading to 6.10 or 6.12 (which is coming out rather soon)... Ubuntu is always really far behind with their Haskell packages.
13:42:40 <Preben> Cale, I will thanks for the info
13:43:14 <benmachine> s/Haskell //
13:43:16 <benmachine> <_<
13:43:47 <Cale> 6.8.2 came out in 2007...
13:48:13 <blackdog> Cale: I suppose that's more the norm for non-research languages. An awful lot of people still use perl 5.8
13:49:08 <ksf> is "reasearch language" the new term that's en vogue for languages that aren't dead ends?
13:49:24 <Cale> ksf: Well...
13:49:36 <fxr> perl is a chaos
13:49:36 <wchogg> Heh...I think it just means "language about which papers are published"
13:50:46 <Cale> It's pretty safe to say that a language is probably a dead end if it doesn't have researchers of some sort working on it.
13:51:06 <blackdog> ksf: ah, not entirely fair. obscurity was a deliberate strategy for a while.
13:51:15 <|Steve|> Is C dead?
13:51:27 <tommd> Nope
13:51:31 <Cale> C is dead in the sense that it basically cannot change in any fundamental way.
13:51:37 <|Steve|> People don't write papers on it.
13:51:41 <|Steve|> Yeah, that's a good thing.
13:51:42 <tommd> Oh, well certainly from that stand point.
13:52:00 <ksf> c compiler technology won't make any major moves anymore, either
13:52:09 <Cale> Languages stop being interesting to me when that happens to them.
13:52:13 <ksf> ...or at least not at a speed that you could build a doctorate on.
13:52:29 <quicksilver> Cale: blocks is a fairly substantial new feature
13:52:37 <tommd> "Bit Patterns in C" Yeah, thats no masters paper.
13:53:13 <Cale> quicksilver: I suppose that's true. I'm not sure if it's really okay to say that it's C though.
13:54:05 <jmcarthur_work> not until it's standardize
13:54:11 <quicksilver> Cale: too early to tell, of course.
13:54:12 <jmcarthur_work> d
13:54:27 <quicksilver> Cale: but if it does well, it stands a fighting chance of being standardised
13:54:32 <jmcarthur_work> or at least integrated into more compilers/runtimes
13:54:41 <quicksilver> (I would guess, not with any particular knowledge of how these things work)
13:54:42 <Cale> That would certainly be cool. How first-class are blocks?
13:54:47 <blackdog> it's interesting to see Haskell gain a bit of traction in the "real world". I think the pattern up to now is for features from the more academic languages to slowly filter into the more commonly used ones, but it's getting to the point that there are fewer reasons not to use languages like Haskell directly.
13:54:54 <quicksilver> I've only read siracusa's description of them :)
13:55:21 <blackdog> quicksilver: ah, yes. the blog post that required multiple cups of coffee
13:55:21 <jmcarthur_work> blackdog, i wish it would happen faster
13:55:33 <Cale> blackdog: I want Haskell to perpetually remain on the boundary between practicality and research.
13:55:44 <blackdog> jmcarthur_work: patience, patience. if it anneals too fast you'll end up with a brittle blade.
13:55:53 <Cale> I hope that it doesn't gain widespread adoption, because that would mean death.
13:56:00 <jmcarthur_work> blackdog, i also agree with cale, hypocritically
13:56:00 <quicksilver> Cale: http://arstechnica.com/apple/reviews/2009/08/mac-os-x-10-6.ars/10#blocks
13:56:11 <quicksilver> blackdog: well, more of a magazine article than a blog post, but yes.
13:56:17 <wchogg> Cale : oh the ossification is inevitable
13:56:21 <jmcarthur_work> Cale, i think there exist potential replacements for researchy things though
13:56:40 <ksf> I guess if you do basic maintenance, haskell is a quite stable moving target
13:56:53 <blackdog> i thought it might end up that haskell98 would be the worksafe version, but the extensions are too nice to resist.
13:56:53 <jmcarthur_work> agda seems like a somewhat natural step up from haskell, for example
13:57:16 <jmcarthur_work> in terms of power
13:57:27 <ksf> ...in that the advantages of switching to a new version greatly outweigh the work nescessary to fix bitrot
13:57:46 <copumpkin> Cale: I already find some of the standard library to be rather stuck in a rather ugly state due to excessive adoption
13:57:48 * quicksilver has never really felt that.
13:57:52 * copumpkin votes to kick everyone out of #haskell, including himself
13:57:56 <jmcarthur_work> copumpkin, yes, that!
13:57:56 <quicksilver> I stuck on 6.6. until a few months ago.
13:58:05 <quicksilver> I only upgraded to 6.8 then :)
13:58:22 * copumpkin writes his own base package
13:58:43 <jmcarthur_work> copumpkin, you know i'm already attempting that, right? :)
13:58:52 <copumpkin> jmcarthur_work: mine will be better than yours!
13:58:59 <Alpounet> heh
13:59:00 <jmcarthur_work> i'm trying to make it a fairly collaborative effort
13:59:06 <copumpkin> eww, collaboration!!
13:59:09 <copumpkin> (sign me up)
13:59:18 <jmcarthur_work> of course, nobody will jump in into they see some work already done
13:59:20 <copumpkin> my approach has been rather radical so far though :)
13:59:27 <Cale> copumpkin: I agree about that, and I wonder what we can do about it. We already have the vicious cycle of not wanting to change what's standardised in the implementation, and not wanting to standardise what's unimplemented.
13:59:27 <jmcarthur_work> copumpkin, mine too
13:59:31 <dons> Cale: there's still a lot of research done on Java
13:59:51 <copumpkin> jmcarthur_work: how radical? mine is very radical!
13:59:51 <jmcarthur_work> copumpkin, i will grant commit access to the repo to whoever wants it... want it?
13:59:53 <dons> so i think there's scope to grow more mainstream before things ossify
13:59:54 <blackdog> dons: that'd be in compiler and JIT optimisation though, right?
14:00:03 <dons> runtime, compiler, type system.
14:00:04 <Cale> dons: Well, Java has admittedly changed a bit since I last used it.
14:00:05 <dons> not the syntax
14:00:10 <jmcarthur_work> copumpkin, so far this is what i have http://patch-tag.com/r/alt-stdlib/snapshot/current/content/pretty
14:00:13 <copumpkin> jmcarthur_work: sure, or even just reading the repo (I don't know where it is)
14:00:13 <Cale> dons: It even has parametric polymorphism now.
14:00:15 <copumpkin> ah :)
14:00:15 <etpace> It might be that i'm still too bad, but I think Data.Time could be improved a bit, it seems a bit unnecessarily hard
14:00:16 <blackdog> all of the new features like generics have been pretty well tested in other languages
14:00:16 <dons> we need an agile compiler team :)
14:00:19 <jmcarthur_work> copumpkin, it's nto much and very unstable and exploratory so far
14:00:21 <dons> and researchers willing to commit things into ghc
14:00:45 <dons> i wouldn't be worried about ghc being too mainstream, until we see ICFP papers about haskell decrease
14:00:52 <copumpkin> jmcarthur_work: ooh, you're going the category-extras general categorical structures way
14:00:54 <travisbrady> I'm using the Haskell irc bot source from the wiki and getting this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9432#a9432
14:00:54 <dons> which isn't happening. haskell's only increasing its share of the research market
14:00:59 <jmcarthur_work> copumpkin, yup :)
14:01:01 <Cale> dons: We need a plan for breaking things without people getting too upset about the fact that we're doing it.
14:01:13 <dons> yeah, the libraries stuff is part of that
14:01:25 <dons> move 'stable maintainance' bizness to the HP team, not SPJ
14:01:30 <copumpkin> jmcarthur_work: my algebra is more radical though :P it needs much cleaning up though
14:01:37 <jmcarthur_work> copumpkin, public repo?
14:01:49 <copumpkin> jmcarthur_work: it's sitting in a paste right now I think
14:02:00 <Cale> I like this idea that we have a haskell98 package which people can use when they want to retain Haskell 98 library compatibility. We should use that idea more.
14:02:07 <jmcarthur_work> copumpkin, my philosophy in this approach is to not worry about backward compatibility at all and explore new territory if it needs exploring
14:02:17 <copumpkin> jmcarthur_work: yay, definitely what I want :)
14:02:29 <jmcarthur_work> copumpkin, have a patch-tag account?
14:02:32 <copumpkin> yep
14:02:35 <copumpkin> pumpkin iirc
14:02:46 <jmcarthur_work> kk
14:03:17 <jmcarthur_work> copumpkin, you're in
14:03:19 <copumpkin> #alt-stdlib ? or something
14:03:24 * Cale wishes that byorgey's species package was not dependent on packages written by Henning Thielemann.
14:03:29 <jmcarthur_work> sure, we'll do that
14:03:39 <copumpkin> Cale: same :)
14:03:54 <jmcarthur_work> anybody else interested in joining the project/planning?
14:04:50 <aavogt> there was some hackage library that provided   head :: [a] -> a  that said which line number hit the [] case.  Does anybody remember what that one was called?
14:05:13 * Cale looks
14:05:29 <Cale> jmcarthur_work: cool, I would be happy to try contributing :)
14:05:33 <ksf> @hoogle head
14:05:33 <lambdabot> Prelude head :: [a] -> a
14:05:33 <lambdabot> Data.ByteString head :: ByteString -> Word8
14:05:33 <lambdabot> Data.List head :: [a] -> a
14:05:35 <dons> aavogt: loch?
14:05:41 <poe> http://www.cse.unsw.edu.au/~dons/loch.html
14:05:41 <dons> aavogt: safe?
14:06:05 <blackdog> aavogt: partial functions are still evil even when informative
14:06:37 <Alpounet> jmcarthur, what's the precise aim ?
14:06:52 <aavogt> that's it. Thanks!
14:07:04 * quicksilver finds partial functions to be necessary.
14:07:08 <jfoutz> jmcarthur_work: i'm a big ol' noob, but i'd like to help
14:07:13 <jmcarthur_work> Alpounet, currently, exploratory. the idea so far is to work with general, high level combinators as much as possible
14:07:14 * Cale always sees this definition of the Category typeclass and wonders what it really corresponds to from a category theoretic perspective...
14:07:22 <aavogt> blackdog: yes they are. I'm trying to find out which one of 5 heads in one function are causing the problem
14:07:37 <quicksilver> haskell is not expressive enough to conveniently model everythign in total types.
14:07:38 <Cale> I don't think it's as simple as just being a category enriched over Hask...
14:07:41 * blackdog goes white, faints,  falls over, dies
14:07:59 <jmcarthur_work> Cale, yeah, i'm a little weirded by that too
14:08:06 <blackdog> quicksilver: yeah, but head is egregious
14:08:13 <Cale> Your composition has to be a natural transformation in each of the three types involved
14:08:33 <benmachine> aavogt: replace two of them with fromJust . listToMaybe
14:08:44 * blackdog is sure glad this channel isn't logged for out-of-context quoting later.
14:08:57 <benmachine> what *is* it logged for, then?
14:09:01 <Cale> It is logged though.
14:09:09 <copumpkin> Cale: #alt-stdlib :D
14:09:14 <burp> 600 loggers in here ;)
14:09:18 <blackdog> Cale: yeah. self-mocking.
14:09:48 <Alpounet> jmcarthur_work, for any kind of things one should expect of a SL ?
14:10:05 <jmcarthur_work> Alpounet, eventually planning to go for a full standard library, yeah
14:10:19 <Alpounet> what about its distribution ?
14:10:32 <Alpounet> it would be "hidden" by official SL
14:10:38 <Alpounet> +the
14:10:44 * lilac looks at his interpreter. what do you mean, partial functions are evil? :)
14:11:12 <jmcarthur_work> Alpounet, the idea is to just use -hide-package base for it
14:11:33 <jmcarthur_work> jfoutz, #alt-stdlib if you are still interested
14:11:42 <Alpounet> let's chat about it there.
14:12:54 <wchogg> Cale:  The categorical semantics of typeclasses in general is rather unclear to me, so I'm not sure if one could give an interpretation that simple.
14:13:40 <quicksilver> blackdog: well, head is OK to use if you *know* the list isn't empty. Although I admit I use it seldom.
14:13:56 <quicksilver> blackdog: map head . group is the canonical example
14:14:12 <quicksilver> blackdog: group never produces empty lists, so map head . group is provably safe.
14:14:37 <Cale> wchogg: Well, we sort of have a categorical semantics of parametric polymorphism
14:14:43 <quicksilver> > map head . group $ [1,1,2,2,3,4,4,4,4,5]
14:14:44 <lambdabot>   [1,2,3,4,5]
14:15:02 <|Steve|> > group [1,1,2,2,3,4,4,4,4,5]
14:15:03 <lambdabot>   [[1,1],[2,2],[3],[4,4,4,4],[5]]
14:15:17 <|Steve|> Ah.
14:15:19 <ray> > group []
14:15:19 <lambdabot>   []
14:15:26 <Badger> hm
14:15:28 <Badger> @src group
14:15:28 <lambdabot> group = groupBy (==)
14:15:32 <|Steve|> heh
14:15:33 <Badger> @src groupBy
14:15:33 <lambdabot> groupBy _  []       =  []
14:15:33 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
14:15:33 <lambdabot>     where (ys,zs) = span (eq x) xs
14:15:59 <lilac> @type map (fst . head &&& map snd) . groupBy ((==) `on` fst)
14:16:00 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [(a, [b])]
14:16:05 <wchogg> Cale:  Right, but my gut tells me qualified types aren't a trivial extension of the semantics of F_\omega.
14:16:27 <ray> > map head . group $ [] -- :)
14:16:28 <lambdabot>   []
14:16:47 <quicksilver> ray: that's fine.
14:16:49 <Cale> wchogg: Well, we can do the dictionary translation on the level of semantics too, I think :)
14:16:55 <quicksilver> ray: [] does not contain any lists.
14:17:02 <quicksilver> ray: [] contains no lists, not any empty ones :)
14:17:06 <|Steve|> > map (\xxs@(x:xs) -> (x,length xxs)) $ group [1,1,1,2,2,3,3,3,4,4,4,5]
14:17:07 <lambdabot>   [(1,3),(2,2),(3,3),(4,3),(5,1)]
14:17:24 <blackdog> quicksilver: yeah, that's true. it's usally a bad smell, though.
14:17:30 <ray> group can still produce an empty list
14:17:33 <ray> just saying
14:17:34 <travisbrady> can anyone give me a hand with this one? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9432
14:17:40 <quicksilver> > map (head &&& length) . group $ [1,1,1,2,2,3,3,3,4,4,4,5]
14:17:41 <lambdabot>   [(1,3),(2,2),(3,3),(4,3),(5,1)]
14:17:56 <blackdog> i am occasionally guilty of using fromJust without adequate proof... :)
14:18:07 <|Steve|> :t (&&&)
14:18:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:18:23 <wchogg> Cale : Ya read Jacobs' book on type theory?
14:18:26 <ray> i just use patterns. i like pointless and all, but -
14:18:39 <|Steve|> That totally doesn't clean anything up for me as to what &&& does.
14:18:43 <Cale> wchogg: nope, is it good?
14:19:11 <|Steve|> What is the a there?
14:19:14 <|Steve|> :t (|||)
14:19:15 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
14:19:19 <ksf> http://hackage.haskell.org/packages/archive/numeric-prelude/0.1.2/doc/html/Number-FixedPoint.html
14:19:20 <ksf> cool
14:19:21 <c_wraith> > ((+1) &&& (*2)) 5
14:19:22 <lambdabot>   (6,10)
14:19:23 <ray> :t (&&&) :: (b -> c) -> (b -> c') -> (b -> (c,c'))
14:19:24 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
14:19:34 <c_wraith> |Steve|: does that example explain it better?
14:19:35 <ray> |steve|: ^
14:19:45 <|Steve|> c_wraith: Yeah.
14:19:50 <ray> a is an Arrow :)
14:19:56 <wchogg> Cale:  from what I understand so far :-p.  I'm still wrestling with it to be honest.  Hope to teach a seminar from in the not crazy future.  I was just wondering if you'd already digested the fibrations machinery of doing logic on a type theory.
14:19:59 <ray> hence Arrow a =>
14:20:05 <|Steve|> Sure, I saw that.
14:20:17 <|Steve|> But is an Arrow just like an arrow in CT?
14:20:20 <benmachine> most of the time you use Arrows you are just using a function
14:20:20 <c_wraith> @instances Arrow
14:20:21 <lambdabot> (->), Kleisli m
14:20:37 <|Steve|> Okay
14:20:47 <|Steve|> @instances ArrowChoice
14:20:48 <lambdabot> (->), Kleisli m
14:21:14 <Cale> |Steve|: Hughes' Arrows are not very much like category theory arrows, though they can be explained as a special type of arrow in a special type of category.
14:21:25 <Cale> (but then, most things can...)
14:21:40 <quicksilver> Cale: well, they compose like them
14:21:47 <quicksilver> Cale: that is a little bit like :)
14:21:52 <Cale> Right, and it's not as bad as it sounds.
14:21:58 <Cale> There was a good paper...
14:22:00 * Cale finds
14:22:12 <ksf> ...but they don't do what I want.
14:22:27 <ray> like most things in category theory, those arrows are much more vague
14:22:56 <Cale> http://www.cs.ru.nl/~heunen/publications/2006/arrows/arrows.pdf
14:23:42 <wchogg> Huh, never read that paper <om nom nom>
14:23:53 <Cale> Arrows are monoid objects too!
14:24:13 <|Steve|> Ah, in C^op x C -> C.
14:27:43 <copumpkin> is there an official procedure for getting a trac on trac.haskell.org?
14:35:13 <quicksilver> Cale: I have several times wanted an Arrow with the opposite of pure.
14:35:23 <tommd> copumpkin: http://community.haskell.org/admin/
14:35:30 <tommd> Request a project.
14:35:48 <quicksilver> Cale: An arrow which has composition (a ~> b) -> (b ~> c) -> (a ~> c) and "interpretation" :: (a ~> b) -> (a -> b)
14:35:50 <tommd> ... then produce massive amounts of quality code for the community.
14:36:34 <tommd> copumpkin: so... what is the project?
14:36:52 <copumpkin> tommd: oh, #alt-stdlib :)
14:40:20 <dons> tomlok: will binary 'get' performance have an effect on sha or puremd5 perf?
14:40:23 <dons> tommd
14:40:24 <dons> grr
14:40:56 <Tordek_> why can't I do map show ([1,'a'] :: (Show a) => [a]) ?
14:41:30 <Botje> because lists can only contain one type
14:41:39 <Twey> Tordek_: Because then, what is ‘a’?
14:42:05 <Tordek_> hmm, that was amusing. I realized it just as soon as I hit enter >_>
14:42:21 <copumpkin> > map show ([1, 'a'] :: [forall a. Show a => a]) -- you seem to want this
14:42:21 <lambdabot>   Cannot match a monotype with `forall a. (GHC.Show.Show a) => a'
14:42:29 <copumpkin> unfortunately we're not allowed to do that :)
14:42:49 <copumpkin> you can with an additional wrapper though
14:42:51 <Tordek_> what's forall for?
14:43:12 <copumpkin> Tordek_: to say that any type that is an instance of Show can go in there
14:43:19 <copumpkin> in practice, you'd write a wrapper
14:43:28 <copumpkin> data Showable = forall a. Showable a
14:43:39 <copumpkin> then you could do [Showable 1, Showable 'a']
14:43:44 <copumpkin> and write a Show instance for Showable
14:44:07 <benmachine> wouldn't you have to restrict Showable to, like, showable things?
14:44:20 <copumpkin> oh yeah :)
14:44:57 <Botje> instance Show a where show _ = "cookies!"
14:45:05 <copumpkin> lol
14:45:30 * fxr perpares to write hspamd, a replacement for amavisd-new.
14:45:45 <mauke> type Showable = String
14:46:27 <copumpkin> lol
14:46:54 <mauke> xShowable = show
14:47:45 <mauke> I've written yes(1) in Hasperl: http://scsys.co.uk:8002/33917
14:48:38 <benmachine> mauke: waaaat
14:49:16 <burp> lol
14:49:38 * benmachine cries
14:51:35 <mauke> it's beautiful
14:52:31 <sleepynate> congrats
14:53:09 <arw_> its a strange mixture between "marry me" and "my eyes are bleeding"
14:53:56 <Twey>     for (; $xs; $xs = $xs->[1]) {
14:53:58 <Young-goon> hi, does someone know why this code doesn't compile ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3625#a3625
14:54:06 <Twey> — while ($xs = $xs->[1])?
14:54:12 <mauke> Twey: no
14:54:12 <Tordek> am I the only one to point out it isn't actually yes?
14:54:13 <Zao> Young-goon: The compiler probably does.
14:54:24 <Twey> Oh, no, do … while
14:54:30 <mauke> Twey: no
14:54:33 <Young-goon> Zao, it's a joke ?
14:54:37 <Zao> As in (the errors would be nice to see)
14:54:51 <mauke> Tordek: why, because it takes no arguments?
14:54:58 <Tordek> 'xactly
14:55:04 <Twey> mauke: What's the difference?
14:55:06 <mauke> meh, just a toy
14:55:28 <mauke> Twey: for (; B; C) { D } is equivalent to while (B) { D } continue { C }
14:55:30 <benmachine> mauke: see if you can get something that gcc will compile as well :P
14:55:45 <mauke> Twey: it has to test the condition first or it'll fail for empty lists
14:55:46 <Zao> Young-goon: Your else is too far to the left.
14:55:49 <Young-goon> my compile output is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3626#a3626
14:56:04 <Young-goon> Zao, it's emacs which indent like this
14:56:07 <mauke> Twey: and you can't perform the = first or it'll skip an element
14:56:12 <Young-goon> and from memory it was correct
14:56:16 <Zao> Young-goon: The else must apparently be at least one level deeper than the if.
14:56:28 <mauke> test.hs:11:2: parse error (possibly incorrect indentation)
14:56:37 <mauke> doesn't look correct to me
14:56:53 <Zao> Young-goon: Same goes for the `then' too.
14:57:10 <Twey> mauke: Ahh, I see.
14:57:11 <Zao> But as it's on the end of the if line, it's not affected currently.
14:57:13 <Twey> 'kay.
14:58:15 <Zao> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3625#a3627
14:58:50 <Zao> Your indentation mode may not be awesome enough to do Haskell properly.
15:00:01 <Young-goon> Zao, what is strange is that this indentation is correct, i use it in another place in my code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3625#a3628
15:00:43 <mauke> Young-goon: that's not part of a do-block
15:00:54 <Zao> Young-goon: The rules are something along the lines of "then and else must be one indentation level more than the corresponding if"
15:01:11 <Zao> Which your second paste satisfies.
15:01:17 <Young-goon> mauke, it's work differently in a do block ?
15:01:24 <mauke> yes
15:01:32 <mauke> because that's where indentation actually matters
15:01:39 <Zao> Oh, missed `a' there.
15:01:44 <Young-goon> Zao, not in the definition of a, else is on the same column than the if
15:01:51 * Zao defers to mauke.
15:02:01 <Young-goon> and when i used haskell-mode in emacs it used to work fine
15:02:48 <Young-goon> mauke, is there a way to use emacs indentation with do block
15:02:56 <mauke> no idea
15:04:59 <c_wraith> emacs-mode indents if statements wrong inside do blocks...
15:05:06 <c_wraith> best to just not use if statements
15:05:27 <edwardk> jfoutz: re where you do find the stuff in category-extras? It depends on the stuff, it is kind of a laundry list of categorical ideas I've seen that translate into Haskell. Skim the stuff on comonad.com and you'll find most of the links though.
15:05:29 <Zao> c_wraith: Or not use Emacs :3
15:05:44 <jfoutz> edwardk: thanks!
15:06:06 <edwardk> If you have any particular questions feel free to ask
15:06:32 <Young-goon> Zao, is there good haskell editor other emacs which handle indentation for me ?
15:06:33 <jfoutz> actually...
15:07:01 <jfoutz> edwardk: are either of these well known things? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=9437#a9437
15:07:52 <Young-goon> c_wraith, there is something strange, you said that emacs is wrong, byt why exactly same identation works outside do bloc and notinside
15:07:56 <edwardk> minzip being a zip that takes only the common elements of both lists, and max zip extending one or the other?
15:08:14 <jfoutz> edwardk: yeah, but over any foldable.
15:08:36 <edwardk> the foldable here isn't adding anything really, since it is isomorphic to a list via the traversal
15:08:44 <c_wraith> Young-goon: Because emacs just uses the non-do-block rules all the time.  But inside of a do block, the rules for if-then-else change
15:09:04 <edwardk> (complexity wise that is)
15:09:08 <jfoutz> edwardk: hmm. ok.
15:09:20 <edwardk> since you discard all the other structure by folding
15:09:23 <Young-goon> c_wraith,  why does they change ? what is the reason ?
15:09:43 <edwardk> have you looked at Control.Functor.Zip ? that covers something like minzip
15:10:34 <jfoutz> i haven't. is it must be in category extras?
15:10:43 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Functor-Zip.html
15:12:07 <edwardk> though i don't limit it to foldables, and as a result have to make it monomorphic, in the type it zips, if you basically trundle through, applying the traversal from foldable to get a list and convert from a list into an arbitrary applicative you can get your zip out of fzipWith
15:12:29 <edwardk> er not monomorphic, but i mean i lock the functors in and out to all have the same type.
15:13:01 <jfoutz> yeah, i wasn't sure if i was being silly or not.
15:13:21 <edwardk> jfoutz: http://comonad.com/reader/2008/zipping-and-unzipping-functors/ talks about it and http://comonad.com/reader/2008/cozipping/ talks about the fact that the dual operation is actually weaker in haskell.
15:13:47 <edwardk> and ties cozipping back to the halting problem, etc.
15:14:41 <dolio> What's cozipping? f (Either a b) -> Either (f a) (f b)?
15:15:24 <edwardk> You might also find http://comonad.com/reader/2008/deriving-strength-from-laziness/ useful
15:15:46 <edwardk> class Functor f => Cozip f where    cozip :: f (Either a b) -> Either (f a) (f b) -- yeah
15:16:19 <copumpkin> hmm, how does that work?
15:16:21 <edwardk> the weaker notion of costrength i think is more useful, and similarly limiting.
15:16:25 <dolio> Yeah, that's not a very sensible type.
15:17:05 <edwardk> dolio: not if there is only at most one slot that uses the argument type.
15:17:06 <dolio> Costrength says "Either the functor has all Rights, or it has one Left" (or vice versa, depending on how you take the type.
15:17:15 <dancor> so this is a specific form of something that you could do with (everywhere)?
15:17:25 <dolio> Cozip says "Either the functor has all Rights or all Lefts".
15:17:52 <dolio> edwardk: Yeah, that's the significantly more limited variety of types, though.
15:17:53 <edwardk> costrength lets you ask if it has any Lefts, and if so it'll give you one. otherwise as proof of the fact that it has none, it can take all the Rights and strip the right constructor.
15:18:53 <mauke> benmachine: be careful what you wish for
15:18:58 <mauke> benmachine: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9438#a9438
15:20:14 <dancor> > everywhere (mkT (++ "_")) (Right "a" :: Either String String)
15:20:15 <lambdabot>   Right "a__"
15:20:17 <dancor> hm
15:20:24 <dolio> For instance, if your language has call/cc, all functor are costrong.
15:20:26 <edwardk> the f (Either a b) -> Either (f a) (f b) -- type is way more restrictive, because you can only have at most one 'hole' that is plugged with the argument of f, and it has to be determinable, etc.
15:20:28 <dolio> But they don't cozip.
15:20:30 <dancor> > everywhere (mkT (++ "_")) "a"
15:20:31 <lambdabot>   "a__"
15:20:31 <edwardk> dolio: yeah
15:20:49 <dancor> > everywhere (mkT (+ 1)) 1
15:20:49 <lambdabot>   2
15:21:02 <edwardk> dolio: kata has call/cc mainly for that reason =)
15:21:06 <dolio> :)
15:21:10 <dancor> i wonder why String's get double-treatment
15:21:23 <edwardk> i should get going or i'll be late for the BAHUG.
15:21:27 <dancor> bc it's []:... i guess
15:21:41 <dancor> oops i meant 'a':[]
15:21:58 <dancor> > everywhere (mkT (++ "_")) "ab"
15:21:59 <lambdabot>   "ab___"
15:22:09 <dolio> Of course, there are other ways to cozip, conceivably.
15:22:26 <skorpan> syb is madness
15:22:37 <dancor> sybarta
15:22:41 <skorpan> > everywhere (mkT (+2)) [1..10]
15:22:41 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
15:22:42 <dolio> You could check whether you get to a Left or Right first, and then attempt to prune away all the opposites.
15:23:05 <mauke> what, no comments? I'm kind of disappointed
15:23:30 <skorpan> > everything (mkQ (\x -> x `mod` 3 == 0)) [1..10]
15:23:30 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
15:23:30 <lambdabot>         against inferred ...
15:23:36 <stevan> hi, is there a way to tell cabal to link things statically (use -static -optl-static) when installing a package? thanks.
15:24:25 <skorpan> what's wrong in "everything (mkQ (\x -> x `mod` 3 == 0)) [1..10]"?
15:24:27 <benmachine> mauke: <3
15:25:22 <lilac> mauke: omgwtf nice :)
15:25:27 <dcoutts> stevan: have you tried telling it to use -static and -optl-static ?
15:25:44 <dcoutts> or rather telling it to tell ghc to use those flags
15:26:30 <skorpan> what's wrong in "everything (mkQ (\x y -> x `mod` 3 == 0)) [1..10]"?
15:26:34 <skorpan> oops
15:26:39 <skorpan> > everything (mkQ (\x y -> x `mod` 3 == 0)) [1..10]
15:26:40 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
15:26:40 <lambdabot>         against inferred ...
15:26:44 <skorpan> :\
15:29:44 <benmachine> mauke: it's fun to load it in vim and toggle the filetype between the three different valid highlight styles :P
15:30:22 <benmachine> actually for the perl one it just gets confused
15:30:55 <mauke> benmachine: http://www.vim.org/scripts/script.php?script_id=2300
15:31:02 <benmachine> which is fair enough because so do I >_>
15:31:22 <Saizan> ?type mkQ
15:31:22 <lambdabot> forall r b a. (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
15:31:25 <stevan> dcoutts: i did cabal install --help, but couldn't find any flag to do just that?
15:31:49 <Saizan> :t everything
15:31:50 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
15:32:01 <dcoutts> stevan: cabal lets you pass extra flags to any program it calls.
15:32:01 <jfoutz> edwardk: those are good articles. i'd started from appending strings, i guess i never really got away from the list abstraction now that i think about it.
15:32:17 <dcoutts> stevan: see in the --help output the --$PROG-option(s) flags
15:33:05 <stevan> ah, thanks
15:33:09 <Saizan> > everything (++) (mkQ [] (\x -> guard (x `mod` 3 == 0) >> return x)) [1..10]
15:33:10 <lambdabot>   [3,6,9]
15:33:20 <edwardk> jfoutz: i'm going to head out the door so i'm not late to my own talk. =)
15:33:23 <edwardk> later man
15:33:31 <jfoutz> :)
15:35:25 <Phyx-> dcoutts: got my earlier message about the gtk2hs installer you gave me?
15:35:35 <dcoutts> Phyx-: I didn't
15:36:08 <Phyx-> dcoutts: ah, well, i was saying, the installer seems to be missing the glad package
15:36:24 <dcoutts> Phyx-: yes, it's a minimal build
15:36:32 <Phyx-> oh, ok
15:37:21 <dcoutts> I did say is was a minimal build :-)  I didn't call out glade explicitly
15:37:46 <dcoutts> I probably should have, since it's the most used extra one
15:38:01 <Phyx-> lol, I could have done without cairo, but glade is one i use :P
15:38:57 <Phyx-> btw, in .1 there was a finalizer change right, that's the reason that the installer did a version check. any reason why the installer still does it? shouldn't it work on all 9.10.x higher than 9.10.2?
15:39:02 <Phyx-> or did something change again?
15:39:22 <dcoutts> Phyx-: ghc binary libs are not compatible between versions, that's always how it's been
15:39:28 <dcoutts> nothing special this time
15:39:46 <dcoutts> though yes there's also a finaliser change
15:39:57 <Phyx-> again? lol
15:40:14 <dcoutts> no, as you said, it was between 6.10.1 and .2
15:40:43 <Phyx-> ah ok. Well it's ok, I guess i'll just wait for the finished installer. since building it is now fun :|
15:40:51 <dcoutts> Phyx-: if the installer didn't check then ghc would check instead, but you'd be more annoyed having got that far :-)
15:42:06 <Phyx-> dcoutts: lol, yeah, i once tried to share packages between .3 and .2 , didn't work out so well :P
15:43:43 <Phyx-> dcoutts: was just gonna finish this game http://www.cs.uu.nl/wiki/pub/Afp/UnstableAPI/screenshot.png and maybe put it on hackage
15:44:06 <dcoutts> cool :-)
15:45:06 <Phyx-> it's almost done, just have a deadlock to fix, and finish drawing some paths on screen
15:50:17 <iago> please, some references about closed kinds/type-level functions?
15:50:24 <iago> I don't find too much googling
15:52:08 <copumpkin> iago: closed kinds?
15:52:15 <copumpkin> iago: type functions are just type families
15:52:34 <copumpkin> or more indirectly, multiparameter typeclasses
15:52:49 <iago> copumpkin, * is a kind, but with data declarations you can define new members of *, a closed kind has a fixed number of types (members)
15:52:58 <iago> type families are *open* type-level functions
15:53:47 <iago> I see this example in some paper: kind Nat = Z | S Nat
15:53:58 <iago> defining the kind Nat, with just two members
15:54:19 <iago> well, infinite members, but a fixed number of ways to build members :P
15:54:40 <kmc> heh, datakinds
15:54:55 <iago> yep
15:55:05 <kmc> i'm told she has those
15:55:18 <iago> but I only found small examples in papers about type families, talking about the possibility of closed type-level functions
15:57:01 <RyanT50001> where can i find the stuff on :$ and similar operators?
15:57:08 <RyanT50001> i'm having a hard time searching for it
15:57:19 <kmc> RyanT50001, where is :$ from?
15:57:24 <kmc> that's a type constructor iirc
15:57:28 <RyanT50001> yeah
15:57:38 <RyanT50001> i have no idea where it's from :-/
15:57:45 <kmc> @kind (:$)
15:57:46 <lambdabot> Not in scope: type constructor or class `:$'
15:57:47 <RyanT50001> that's why i'm asking here
15:57:49 <dolio> @hoogle (:$)
15:57:49 <lambdabot> No results found
15:57:55 <kmc> where did you find it, then?
15:57:55 <RyanT50001> i just remember having seen it discussed
15:58:22 <RyanT50001> i think it was just like $ but for types
15:58:34 <RyanT50001> though that was just based on what i inferred from context
16:07:23 <Philonous> newtype Klar
16:07:32 <Philonous> Sorry, wrong window
16:08:44 <lilac> don't leave us waiting! newtype Klar = ...?
16:10:24 <sleepynate> i know, my heart is sinking by the moment
16:10:45 <coco> is there no factorial function in one of the libraries?
16:10:56 <coco> what about binomial coefficients?
16:14:14 <kmc> coco, how could we choose among http://www.willamette.edu/~fruehr/haskell/evolution.html
16:15:20 <aavogt> @hoogle binomial
16:15:20 <lambdabot> No results found
16:16:09 <aavogt> @hackage combinat
16:16:09 <lambdabot> http://hackage.haskell.org/package/combinat
16:23:19 <kmc> @djinn (a -> a) -> a -> a
16:23:20 <lambdabot> f a = a
16:23:59 <kmc> djinn's favorite number is one
16:24:19 <SamB> isn't that more of a zero ?
16:24:38 <mauke> @djinn (a -> b) -> a -> b
16:24:39 <lambdabot> f a = a
16:24:41 <kmc> it's the church numeral for one
16:24:50 <SamB> oh, right ...
16:24:55 <SamB> what's zero again ?
16:25:00 <skorpan> 0
16:25:01 <kmc> \f x -> x
16:25:04 <SamB> oh, ... f a = id ?
16:25:12 <mauke> 0 = false
16:25:25 <SamB> mauke: huh?
16:25:28 <mauke> it's easy to remember because it's C!
16:25:44 <SamB> so what's *0 in church numerals?
16:25:53 <mauke> true = const; false = flip const = const id
16:26:08 <kmc> :t let church 0 = \f x -> x; church n = \f x -> church (n-1) f (f x) in church 5
16:26:09 <lambdabot> forall t. (t -> t) -> t -> t
16:26:12 <kmc> :t let church 0 = \f x -> x; church n = \f x -> church (n-1) f (f x) in church
16:26:12 <lambdabot> forall t t1. (Num t) => t -> (t1 -> t1) -> t1 -> t1
16:26:34 <SamB> > let church 0 = \f x -> x; church n = \f x -> church (n-1) f (f x) in church 10 f x
16:26:35 <lambdabot>   f (f (f (f (f (f (f (f (f (f x)))))))))
16:26:44 <SamB> > let church 0 = \f x -> x; church n = \f x -> church (n-1) f (f x) in church 10 f
16:26:45 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:26:45 <lambdabot>    `GHC.Show.Show t'
16:26:45 <lambdabot>      a...
16:27:02 <SamB> > let church 0 = \f x -> x; church n = \f x -> church (n-1) f (f x) in church 10 f :: Expr -> Expr
16:27:02 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
16:27:02 <lambdabot>    arising from...
16:27:27 <SamB> aww
16:27:44 <sleepynate> are you trying to get lambdabot to say fffffffuuuuuuuu ?
16:28:09 <SamB> no!
16:28:15 <sleepynate>  :)
16:28:21 <SamB> just trying to get it to use a more functional output form ;-)
16:28:36 <sleepynate> aww
16:32:01 <Axman6> > text (repeat 7 'F' ++ repeat 12'U')
16:32:02 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> [GHC.Types.Char]'
16:32:02 <lambdabot>         a...
16:32:07 <Axman6> > text (repeat 7 'F' ++ repeat 12 'U')
16:32:08 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> [GHC.Types.Char]'
16:32:08 <lambdabot>         a...
16:32:19 <copumpkin> replicate
16:32:23 <Axman6> > text (replicate 7 'F' ++ replicate 12 'U')
16:32:23 <lambdabot>   FFFFFFFUUUUUUUUUUUU
16:32:41 <Axman6> yeah, i always mix them up.
16:33:14 <lilac> me too :)
16:33:40 <aavogt> @hoogle m a -> m ()
16:33:41 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
16:33:41 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
16:33:41 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
16:51:29 <fhsanches> Hi. I would like to "plot" a tree in a GUI (possibly GTK), anyone here could give me a few pointers, please?
16:53:24 <Axman6> fhsanches: it's rather quiet in here atm, so stick around and hopefully someone will know
16:53:55 <fhsanches> Axman6: Ok, thanks
16:54:57 <kmc> fhsanches, that's a very general question
16:55:01 <kmc> where are you stuck?
16:56:05 <fhsanches> kmc, I don't know where to start, or, which widget(s) I should use
16:56:31 <kmc> fhsanches, so you're thinking about the GUI part versus, say, how to represent the tree, or how to choose a coordinate for each point?
16:57:17 <fhsanches> kmc, I don't know how to represent the tree
16:58:40 <aavogt> you mean like the gtk treeview? Or something more like the graphs/trees that graphviz can make?
16:59:17 <kmc> fhsanches, by "represent the tree" I mean something that has nothing to do with the GUI library you choose
17:00:28 <fhsanches> aavogt: Graphviz-like
17:01:07 <kmc> i don't know much about GTK in haskell.  i've used OpenGL and, while it's an imperative interface, it's a clean imperative interface in what is actually a fine imperative language
17:01:20 <fhsanches> kmc, sorry for misunderstanding the question. My prgram is already generating and manipulating the trees, I just want to draw them in a GUI
17:01:26 <kmc> cool
17:01:40 <kmc> do you already have coordinates for every line you want to draw?
17:01:56 <fhsanches> kmc, no, not yet
17:02:07 <fhsanches> the tree si actually a representation of source code
17:02:17 <kmc> i think it's a pretty hard problem in general to come up with a nice layout for a graph
17:02:22 <kmc> a tree might be an easier special case
17:02:28 <kmc> but i'd still let graphviz do the work for me
17:03:01 <fhsanches> ok, I'll take a look at it. thanks
17:03:10 <kmc> so it's easy to enumerate coordinates for the balanced binary tree of height n
17:03:21 <kmc> and if your tree is relatively balanced, using a subset of those is okay
17:03:35 <kmc> if it's binary, that is
17:03:50 <kmc> if your tree has high degrees then maybe you want to stagger the nodes on a given level, so it doesn't get really wide
17:03:55 <fhsanches> since it's a representation of source code, I have no garantees on it. but I'll take a try
17:04:05 <fhsanches> umh, I see
17:04:51 <sereven> fhsanches: I think ivanm, graphviz haskell bindings maintainer, has interest in this/has done some work on it, so if you get a chance might chat with him
17:05:50 <yitz> @seen ivanm
17:05:50 <lambdabot> Unknown command, try @list
17:05:59 <yitz> huh?
17:06:08 <benmachine> seen plugin was disabled
17:06:10 <fhsanches> sereven: thanks for the advice, but that's not really necessary
17:06:16 <copumpkin> preflex: seen ivanm
17:06:16 <preflex>  ivanm was last seen 8 minutes and 12 seconds ago, saying: <private message>
17:06:17 <benmachine> I think preflex does a seen but I don't remember how
17:06:21 <benmachine> oh like that
17:06:23 <copumpkin> whoa
17:06:29 <yitz> why?
17:06:35 <copumpkin> mauke: that's an odd thing for preflex to remember :P
17:06:38 <benmachine> because it memory leaked, or something
17:06:52 <copumpkin> yitz: just because it never saved its state correctly, so half the time it was wrong, I think
17:06:58 <yitz> if so, it's been memory leaking for a long time
17:07:04 <benmachine> oh, maybe that instead
17:07:10 <yitz> copumpkin: it usually seemed pretty accurate
17:07:15 <benmachine> well
17:07:24 <benmachine> I'm sure whoever disabled it had a good reason
17:07:28 <benmachine> whatever it was
17:07:29 <copumpkin> in my experience it would often say it last saw someone when it parted from 500 channels 3 months ago
17:08:33 <yitz> when someone was around recently, it seemed to get it right. any other response means "not around now", I don't care exactly what the numbers are then (usually).
17:09:04 <yitz> how long has it been like this?
17:09:30 <yitz> @vixen why was your seen plugin disabled?
17:09:31 <lambdabot> why anything?
17:09:33 <copumpkin> several days
17:10:00 <lament> @vixen who's your favourite computer scientist?
17:10:00 <lambdabot> i dunno, who?
17:10:07 <tinloaf_> hey guys. i'm new to haskell and trying to get that I/O stuff working. i'm getting this error when compiling:
17:10:09 <tinloaf_> http://pastebin.com/m166e4eef
17:10:12 <yitz> preflex: seen mauke
17:10:13 <preflex>  mauke was last seen on #haskell 44 minutes and 20 seconds ago, saying: true = const; false = flip const = const id
17:10:13 <SamB_XP> @vixen turing ?
17:10:13 <lambdabot> isn't it obvious?
17:10:18 <SamB_XP> @vixen turing
17:10:18 <lambdabot> Bollox!
17:10:28 <benmachine> charming.
17:10:28 <tommd> @vixen SPJ - say it's SPJ
17:10:28 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
17:10:54 <tinloaf_> this is the code: http://pastebin.com/m61d28a41
17:10:57 <lament> @vixen haskell curry?
17:10:57 <lambdabot> Ooh, functional programmers are so hot!
17:11:08 <tinloaf_> how the heck am i getting a list of IOs there?
17:11:13 <lament> yup, this is the vixen we all know and love
17:11:23 <Saizan> tinloaf_: you want mapM
17:11:23 <SamB_XP> lambdabot: uh, behind is not quite the right word ;-P
17:11:28 <benmachine> tinloaf_: what's processInput? pasting the code would be nice
17:11:33 <Saizan> tinloaf_: instead of map
17:11:35 <benmachine> but you probably do want mapM yeah
17:11:43 <benmachine> :t mapM
17:11:43 <pikhq> tinloaf_: You probably want mapM or fmap or <$>.
17:11:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:11:46 <benmachine> :t mapM_
17:11:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
17:11:59 <pikhq> (in this case likely interchangable)
17:11:59 <Saizan> tinloaf_: you're getting a list of IO () because map produces a list
17:12:06 <Saizan> ?type map
17:12:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:12:25 <tinloaf_> Saizan: ahh, ok.. so its the "return value" for main that is complaining
17:12:26 <tinloaf_> right?
17:12:39 <tinloaf_> i was wondering where i's expecting an IO()
17:12:44 <Saizan> yes
17:12:45 <Cale> tinloaf_: Probably, if not the processInput line as well.
17:12:50 <yitz> we need a lambdabot news blog
17:12:56 <tinloaf_> looks great
17:13:00 <pikhq> tinloaf_: Actually, it's expecting an IO t.
17:13:06 <pikhq> It's *getting* an [IO ()].
17:13:12 <yitz> to keep up with all the latest modifications
17:13:12 <Cale> tinloaf_:  hPtrStr socket :: String -> IO ()
17:13:15 <SamB_XP> yitz: question ... who's going to program her to blog ?
17:13:18 <tinloaf_> pikhq: yeah, I was not thinking of what main wants to return
17:13:28 <Cale> tinloaf_: So map (hPutStr socket) :: [String] -> [IO ()]
17:13:42 <benmachine> @vixen what are you doing, in 160 characters or fewer?
17:13:42 <lambdabot> just chattin
17:13:45 <tinloaf_> Cale: yeah, i made the mistake to forget that main wants to return an IO()
17:13:46 <benmachine> worksforme
17:14:14 <tinloaf_> and I just noticed that emacs gives me the signaturs of the functions i'm using in the minibuffer. cool stuff
17:14:15 <yitz> SamB_XP: I'm afraid the people who make the changes would have to write the entries. lambdabot isn't very good at self analysis yet.
17:14:25 <yitz> @vixen what's wrong with you?
17:14:25 <lambdabot> let's don't talk about that
17:14:30 <yitz> see?
17:14:34 <benmachine> @vixen are you good at self-analysis?
17:14:35 <lambdabot> thanks, i do my best to be good
17:14:35 <SamB_XP> smart
17:14:42 <SamB_XP> she's like, uh, a real girl!
17:14:51 <SamB_XP> except she should've slapped someone
17:14:57 <benmachine> are you volunteering
17:14:57 <tommd> @slap SamB_XP
17:14:57 <SamB_XP> like shapr, for instance
17:14:57 * lambdabot moulds SamB_XP into a delicous cookie, and places it in her oven
17:15:09 <lament> that's hot
17:15:10 <benmachine> is that a euphemism
17:15:14 <SamB_XP> what? I have to be a baby now?
17:15:14 <kmc> mhm
17:15:26 <kmc> @vixen can you give live birth to human children?
17:15:26 <lambdabot> i sure can
17:15:28 <lament> @vixen what the hell is "oven"
17:15:28 <lambdabot> what's wrong?
17:15:39 <kmc> @nixon
17:15:39 <lambdabot> I reject the cynical view that politics is a dirty business.
17:15:42 <benmachine> @vixen can you give birth to live human children?
17:15:43 <lambdabot> i sure can
17:15:46 <benmachine> ic
17:15:52 <benmachine> phrasing = important
17:16:05 <jaredj> i have a constant list of strings with 11 members, expected to grow up to maybe 20.
17:16:23 <Axman6Be> hmm, so Haiku is quite nice
17:16:35 <jaredj> if i want to find out if a string is a member of that list, is it worth it to make it a set? or should i just keep it a list and use isInfixOf?
17:16:35 <Cale> Axman6Be: yeah, it does look good.
17:16:45 <Saizan> what's haiku?
17:16:47 <kmc> jaredj, i usually use a set for aesthetics
17:16:49 <kmc> and because it's no harder
17:16:51 <Cale> Saizan: New BeOS.
17:16:56 * Axman6Be awaits GHC port for Haiku
17:16:57 <jaredj> kthx
17:17:01 <kmc> also, isInfixOf is not the list membership function
17:17:05 <jaredj> wha
17:17:10 <yitz> jaredj: I would leave it a list
17:17:13 <kmc> :t isInfixOf
17:17:14 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
17:17:14 <kmc> :t elem
17:17:15 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:17:21 <jaredj> oops
17:17:22 <kmc> isInfixOf will look for substrings
17:17:29 <jaredj> right
17:17:31 <kmc> if that's what you want, the set gets much bigger and maybe it's not a good idea
17:17:33 <tommd> > "hello" `elem` ["hi", "yo", "piss off", "hello"]
17:17:33 <aavogt> @src isInfixOf
17:17:33 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
17:17:33 <lambdabot>   True
17:17:42 <kmc> ha nice formal parameters :)
17:17:47 <Axman6Be> Saizan: After BeOS died, some people got together and write Haiku, basically s clone of BeOD, with binary and source compatibility. boots in 4 seconds :o
17:17:50 <jaredj> i tend to use those :)
17:18:13 <jaredj> i still have beos 4.0
17:18:15 <Makoryu> Axman6Be: 4 seconds? o_o
17:18:17 <benmachine> > x == x
17:18:18 <lambdabot>   True
17:18:20 <kmc> jaredj, the ultimate answer to any performance-related "is it worth it" question is to profile
17:18:20 <Axman6Be> 4 seoncds
17:18:22 <benmachine> > x == undefined
17:18:23 <lambdabot>   Ambiguous occurrence `undefined'
17:18:23 <lambdabot>  It could refer to either `L.undefined', d...
17:18:27 <Makoryu> Axman6Be: Daaaayyum
17:18:27 <benmachine> wat
17:18:31 <jaredj> kmc: yeh. don't care yet
17:18:36 <benmachine> who redefined undefined
17:18:38 <Saizan> @undefine
17:18:46 <Saizan> > x == undefined
17:18:47 <lambdabot>   * Exception: Prelude.undefined
17:18:48 <kmc> > let undefined = undefined in x == undefined
17:18:52 <lambdabot>   mueval-core: Time limit exceeded
17:18:53 <Axman6> http://arstechnica.com/open-source/news/2009/09/hands-on-with-haiku-back-to-the-future-of-beos.ars?utm_source=rss&utm_medium=rss&utm_campaign=rss for more info on Haiku
17:19:02 <kmc> cool mueval gives a decent error now
17:19:13 <kmc> @vixen are you new and improved?
17:19:13 <lambdabot> i truely am
17:19:20 <yitz> kmc: no, profiling is only worth it if there is reason to believe that it will really make a difference to overall performance of the app
17:19:30 <yitz> kmc: otherwise, K.I.S.S.
17:19:33 <Saizan> ghc got smarter at preempting threads, it seems
17:19:38 <Axman6> oh had URL announcing been turned off in \bot?
17:19:41 <Axman6> has*
17:19:47 <kmc> yitz, i think it's simple enough to profile everything with automatic cost centers
17:19:58 <kmc> of course if there's no performance problem to begin with, why bother
17:19:59 <yitz> kmc: eh
17:20:10 <kmc> but i don't usually narrow it down before profiling ,because you can be surprised
17:20:13 <kmc> especially in a lazy language
17:20:16 * Axman6 tests lambdabot ...
17:20:19 <Axman6> http://www.macada.org/macada/Downloads.html
17:20:20 <kmc> @bot
17:20:21 <lambdabot> :)
17:20:21 <lunabot>  :o
17:20:24 <Axman6> hoorah
17:20:28 <yitz> lists are nice. if it ain't broke, don't fix it.
17:20:40 <kmc> yitz, yes.  profiling is how you tell if it's broke ;)
17:21:06 <Vanadium> Speaking of profiling
17:21:11 <Cale> Lists are in fact the ideal datastructure if what you're doing is iterating linearly over the members.
17:21:12 <Vanadium> dcoutts: Thanks for your answer from way earlier
17:21:25 <yitz> kmc: no, just run the program. if it works - it ain't broke. or let quickcheck run it, I guess.
17:21:31 <kmc> Cale, i want a proof over the universe of all possible recursive types ;)
17:21:40 <kmc> well correctness is a whole different thing
17:22:21 <Cale> kmc: Well, you can't do better than O(1) unamortised per element.
17:22:22 <yitz> kmc: correctness is easier with lists, because they're simpler. if there's no noticeable delay when you run the program, why start profiling?
17:22:47 <kmc> yitz, i agree.  but i mean that once you notice that there is a delay, you should not prejudge your idea of where the delay comes from
17:23:29 <Saizan> you should also not write blatantly inefficient code just because your inputs don't get large
17:23:42 <yitz> kmc: your brain is also sometimes easier to use than profiling
17:23:46 <kmc> Saizan, i agree but only because it makes me sad to see such code
17:24:28 <yitz> Saizan: you should not write blatantly obfuscated code just because it would be more efficient in a non-existent use case
17:25:17 <Saizan> yitz: agreed :)
17:25:19 <kmc> i think prepending "Set.fromList" to a constant list is not so obfuscated :)
17:25:27 <Saizan> the two statements are not contradictory
17:25:33 <yitz> Saizan: and I agree with your mantra as well :)
17:25:41 <kmc> yay everyone wins :)
17:25:51 <yitz> @vixen do you agree?
17:25:51 <lambdabot> i do occassionally, i guess
17:25:57 <kmc> @vixen are you a winner?
17:25:57 <lambdabot> yes, i am
17:26:00 <kmc> @nixon are you a winner?
17:26:00 <lambdabot> Scrubbing floors and emptying bedpans has as much dignity as the Presidency.
17:26:34 <aavogt> @nixoen
17:26:34 <lambdabot> Always remember that others may hate you but those who hate you don't win unless you hate them. And then you destroy yourself.
17:26:40 <aavogt> @nixeon
17:26:40 <lambdabot> Voters quickly forget what a man says.
17:26:58 <aavogt> @vixon
17:26:58 <lambdabot> Maybe you meant: nixon vixen
17:27:11 <Cale> In the early days of Haskell, lists were too popular, but now since we have Data.Set and Data.Map, etc., lists are just popular enough. They're still really popular, but it's for a good reason now.
17:27:15 <kmc> @nixon give peace a chance
17:27:15 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
17:27:31 <kmc> is there a good way to define fold over a set?
17:27:35 <Cale> (the reason is that linear recursion is common)
17:27:37 <kmc> one which disallows caring about the order of elements?
17:27:59 <Cale> kmc: insist that the operation comes from a good Monoid instance.
17:28:23 <copumpkin> a Commutative monoid?
17:28:28 <Cale> Well... for a Set you might want commutative monoid, yeah.
17:28:46 <Cale> But just agreeing that the elements will be sorted also works.
17:28:56 <kmc> but we have no way to enforce typeclass laws
17:28:58 <Cale> The more important thing is that you don't care about the association.
17:29:06 <kmc> is there any work in that direction or is the answer just "use agda"
17:29:10 <Cale> Because the part of the set that you really can't see is the tree structure.
17:29:28 <Cale> kmc: You need a much more powerful typesystem to do it comfortably, yeah.
17:29:47 <Cale> kmc: You technically *can* do it in Haskell, but it's tremendously annoying.
17:29:51 <SamB_XP> kmc: agda has classes now ?
17:29:55 <copumpkin> nope
17:30:06 <SamB_XP> Cale: Haskell doesn't even have truly dependant types!
17:30:15 <copumpkin> you can prove the entire thing at the type level
17:30:32 <yitz> kmc: not always true. once your algorithm starts getting more complex, stuff that would have been nicely compositional and point-free with lists can get messy if you've moved to Set. And by then it might be too late to go back.
17:30:35 <Cale> (well, Haskell + extensions)
17:31:02 <SamB_XP> copumpkin: how so?
17:31:04 <copumpkin> yitz: notably using Monad functions :(
17:31:16 <SamB_XP> copumpkin: if you need another level, you're just plain out of levels!
17:31:34 <kmc> yitz, isn't there either an existing or easily defined points-free set combinator for every list combinator that doesn't care about order?
17:31:37 <copumpkin> SamB_XP: kindclasses!
17:31:38 <kmc> that seems like almost a theorem
17:31:44 <Saizan> "type-level, it's a whole other level"?
17:31:59 <kmc> SamB_XP, classes are just implicit parameters ;P
17:32:25 <SamB_XP> kmc: they work better with proof search tactics!
17:33:22 <kmc> does she have kindclasses yet? ;)
17:33:32 <copumpkin> nope
17:33:32 <kmc> @vixen what do you think of she?
17:33:32 <lambdabot> i don't know, what?
17:33:39 <yitz> kmc: it's not always straightforward. e.g., if you do a zip, you care about order locally so that things will match up right.
17:33:42 <SamB_XP> @vixen what do you think of her?
17:33:42 <lambdabot> i dunno...
17:33:51 <copumpkin> she also only translates data constructors to the type level
17:37:01 <copumpkin> kroo: :O
17:37:25 <kmc> yitz, don't construct parallel lists when you want to map a tupleifier instead
17:37:39 <Vanadium> @pl \a b -> a + f b
17:37:40 <lambdabot> (. f) . (+)
17:37:46 <kroo> wassup pumpkin? :)
17:38:28 <copumpkin> kroo: I'm enjoying my haskell! what brings you here?
17:38:44 <kroo> copumpkin: I'm learning me some haskell
17:38:47 <copumpkin> yay
17:38:56 <kroo> for great good :)
17:39:23 <copumpkin> hah
17:39:31 <kroo> (the proggit folks convinced me)
17:39:50 <copumpkin> sweet
17:40:22 <kroo> mhmm, this type system is kicking some ass
17:40:42 <kroo> tho the IO stuff feels clunky to me :/
17:40:57 <SamB_XP> kroo: man, if you think *this* type system kicks ass, you should see Coq's ;-)
17:41:13 <Vanadium> I have a thing where I do sum (map f xs) and now I replaced it with an obvious foldl' and my program runs 30% faster, but is way less legible. Is there a way I can keep it fast and make it legible again?~
17:41:21 <copumpkin> kroo: I don't think IO is particularly beautiful, but it's a decent solution for now in my opinion
17:41:41 <kmc> kroo, it is clunky at first.  i think once you know it well, it's no worse than any other imperative language
17:41:42 <SamB_XP> Vanadium: you could extract that into a "sum'" function
17:41:55 <kmc> consider: you can pass imperative code to functions, return it from functions, and store it in datastructures
17:41:56 <kroo> kmc: thats what I've heard
17:42:04 <kmc> you can write your own control-flow
17:42:14 <kmc> and it generalizes beyond IO
17:42:21 <kmc> anyway i'm glad you're learning haskell :)
17:42:25 <kroo> yeah, that part is nice :)
17:42:27 <copumpkin> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
17:43:25 <Vanadium> SamB_XP: But why is sum . map f so much slower in the first place? :(
17:43:26 <Pseudonym> To be fair, I'm not sure that the IO library was well thought-out.
17:43:33 <Pseudonym> I think that people were just impressed that IO worked at all.
17:43:36 <copumpkin> Pseudonym: sin bin :P
17:43:39 <Vanadium> Am I being bitten by laziness?
17:43:46 <SamB_XP> Vanadium: yeah
17:43:56 <copumpkin> Vanadium: foldl' (+) 0 :P
17:43:56 <Pseudonym> copumpkin: Things have gotten a lot better in the last couple of months.
17:44:08 <Pseudonym> The new library is pretty nice.
17:44:13 <yitz> Vanadium: did you try -O2 ?
17:44:18 <Vanadium> yitz: No
17:44:34 <copumpkin> that's the only way sum is usable
17:44:38 <SamB_XP> because sum is foldl (+) 0
17:44:45 <dancor> why do ppl hate IO?  any IO type is going to be IO a = RealWorld -> (RealWorld, a), right?
17:44:47 <Vanadium> -O2 does not make a difference
17:44:54 <SamB_XP> dancor: eh ?
17:44:56 <Pseudonym> dancor: No.
17:45:04 <copumpkin> dancor: it's a sin bin
17:45:04 <dancor> Pseudonym: what could it be like instead
17:45:05 <SamB_XP> that's just one way to trick the compiler into doing it right ...
17:45:14 <copumpkin> dancor: the rest of your program can be thought of in the same way :P
17:45:15 <Pseudonym> HBC's IO type looked something like this:
17:45:22 <SamB_XP> dancor: we haven't figured out how to go without a sin bin :-(
17:45:38 <Pseudonym> Err...
17:45:40 <Pseudonym> Can't remember.
17:45:48 <Pseudonym> But basically, HBC's IO was a "script".
17:45:54 <copumpkin> with an ADT?
17:45:55 <Pseudonym> And the RTS was an interpreter for that script.
17:45:57 <Pseudonym> Yes.
17:46:11 <yitz> clean uses "uniqueness types"
17:46:12 <Pseudonym> I can't remember how it worked without existential types.
17:46:21 <Pseudonym> (Because existential types is how I'd do it today.)
17:46:21 <dancor> so the program does nothing except produce the script?
17:46:23 <Vanadium> copumpkin: foldl' (+) 0 $ map ... is still slower than doing the mapping myself, which I find quite unintuitive :\
17:46:24 <Pseudonym> Right.
17:46:27 <kroo> Pseudonym: newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:46:28 <dancor> that's cool
17:46:35 <kroo> (according to google)
17:46:41 <Pseudonym> The only problem with that is it doesn't work nicely with FFI.
17:46:42 <Vanadium> I had hoped ghc -O2 would be clever enough to do that sort of thing
17:46:42 <copumpkin> @src IO
17:46:42 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:46:43 <kroo> not quite sure I know what that actually means :)
17:46:43 <SamB_XP> @src IO
17:46:43 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:46:57 <SamB_XP> kroo: that's good
17:46:58 <Pseudonym> kroo: Remove the hashes.
17:47:00 <SamB_XP> you shouldn't
17:47:06 <Pseudonym> And it would make more sense.
17:47:20 <SamB_XP> that's some gobbledygook they kooked up to trick GHC into doing the right thing
17:47:29 <kroo> ahahah
17:47:33 <kroo> gocha
17:47:34 <Pseudonym> You don't need to know what the hashes mean.  They're for performance.
17:48:01 <kmc> they are pretty important at the type level though
17:48:13 <kmc> i mean you can't just pretend an unboxed tuple is a boxed tuple but faster
17:48:18 <Pseudonym> I've been programming Haskell for close to 16 years, and I've only ever used a hashed types in anger twice.
17:48:23 <kmc> :D
17:48:32 <SamB_XP> the "State# a" is a nothing that keeps GHC from optimizing any of this stuff out
17:48:32 <Pseudonym> Admittedly, I'm not a GHC or library dev.
17:48:38 <SamB_XP> or doing it in the wrong order
17:49:13 <Vanadium> SamB_XP: Does it prevent ghc from doing stuff twice?
17:49:16 <Pseudonym> Actually, maybe it was only once.
17:49:30 <Pseudonym> Vanadium: What prevents GHC from doing stuff twice is that you don't get to look inside the IO type.
17:49:32 <SamB_XP> Vanadium: mostly
17:49:55 <SamB_XP> Vanadium: occosianally you get that with one of the variants of unsafePerformIO
17:50:05 <Vanadium> Yeah, okay, but that is cheating.
17:50:12 <Pseudonym> Yes, unsafePerformIO is always cheating.
17:50:25 <SamB_XP> and since the stuff is supposed to be idempotent, it shouldn't be an issue
17:50:33 <Vanadium> I used unsafeInterleaveIO today and I am not sure I did the right thing
17:50:47 <yitz> Vanadium: you didn't
17:50:52 <dancor> hah
17:50:54 <yitz> probably
17:51:00 <SamB_XP> Pseudonym: it's not cheating if it's just for accessing basically pure FFI stuff when you need to marshall stuff across ...
17:51:03 <Vanadium> Let's see
17:51:11 <dancor> if you used readFile today then you used unsafePerformIO today
17:51:28 <yitz> dancor: yeah, unfortunately. :(
17:51:51 <Vanadium> Taking out unsafeInterleaveIO makes my program slower, oh no
17:51:53 <SamB_XP> dancor: it depends what module you imported it from
17:51:55 <Pseudonym> So don't use readFile.
17:51:57 <kmc> dancor, unsafePerformIO is just a special case of using the IO value constructor, which is all over the standard library...
17:52:14 <SamB_XP> kmc: since when ?
17:52:23 <SamB_XP> most of the library is supposed to work on more than one compiler ...
17:53:00 <kmc> maybe by standard library you and i mean different things
17:53:15 <kmc> but on every platform i know of, standard IO primitives are implemented in haskell, in terms of non-standard ones
17:53:21 <kmc> and GHC does this by pattern matching and constructing with IO
17:53:24 <dancor> surely the meaning is ..standardized
17:53:32 <kmc> yes
17:54:16 <SamB_XP> kmc: oh, yes, that part is the compiler-specific, icky bit
17:54:53 <kmc> in ghc this is true even of primitive arithmetic
17:55:00 <kmc> imo it's nicer than having the user-visible functions be magical
17:55:20 <kmc> when i implemented languages in school, how to handle primitives was always a tricky design point
17:56:13 <Pseudonym> kmc, have you heard of the Maxine VM?
17:56:17 <kmc> no
17:56:23 <Pseudonym> It's a JVM.
17:56:24 <kmc> looking
17:57:29 <Pseudonym> It's the first Java VM I'm aware of where the primitives, including object field access, are all written in Java.
17:57:41 <kmc> cool
17:58:00 <Pseudonym> There is, of course, a slight bootstrapping issue.
17:58:10 <kmc> well, the world has no shortage of other java implementations
17:58:16 <Pseudonym> Exactly.
17:59:16 <kmc> some people on reddit were arguing about "compiled languages" and were seemingly oblivious to the separation of language and implementation
17:59:18 <kmc> it made me sad
18:00:08 <Pseudonym> 1) All serious interpreted languages compile to an intermediate form.
18:00:18 <kmc> there's no such thing as an interpreted language
18:00:23 <kmc> or a compiled language
18:00:26 <Pseudonym> Yes, there is.
18:00:34 <kmc> explain?
18:00:35 <Pseudonym> 8-bit microcomputer BASIC
18:00:51 <copumpkin> the interpreter is your CPU!
18:00:52 <Pseudonym> Unless you think lexical analysis counts as "compilation".
18:01:00 <Pseudonym> Which is a debatable point.
18:01:02 <kmc> what i mean is, implementations are interpreted or compiled
18:01:04 <kmc> not languages
18:01:08 <Pseudonym> Right.
18:01:19 <Pseudonym> Well, there are some languages which essentially can't be compiled down to machine language.
18:01:24 <kmc> so there is no such thing as an "interpreted language".  the phrase is a type error
18:01:25 <Pseudonym> In the sense that it would be impractical to do so.
18:01:41 <dancor> and some languages have only one main implementation so the point will often be academic then
18:01:53 <kmc> dancor, no popular language though
18:01:53 <Pseudonym> There comes a point for some highly dynamic language where compiling it would be slower than just running it.
18:01:55 <kmc> maybe ruby?
18:02:06 <Pseudonym> Ruby, probably,.
18:02:12 <Pseudonym> I don't know it well enough.
18:02:17 <kmc> Pseudonym, i'm not convinced you can draw the line between "interpreter with lots of partial evaluation" and "compiler with lots of runtime support" cleanly enough
18:02:26 <Pseudonym> I agree.
18:02:26 <erikc> Pseudonym: V8, Factor and Unladen Swalloe dispute that point :)
18:02:30 <kmc> i mean a compiler *is* a partially applied interpreter
18:02:51 <Pseudonym> My point #2 is that, by the way, is that the majority of CPUs in non-embedded computers are themselves interpreters.
18:02:55 <kmc> yes
18:03:19 <kmc> and even digital logic is an interpreter running on physics
18:03:27 <kmc> and physics is an interpreter running on we don't know what
18:03:32 <copumpkin> GOD'S LAW!
18:03:54 <Vanadium> Are we not all glad that the word of god is typesafe
18:04:20 <Pseudonym> kmc: Uhm... maybe.
18:04:33 <Pseudonym> I'd say "emulator" rather than "interpreter".
18:04:43 <dancor> wave-particle duality is the most intense form of coercion i know
18:06:01 <Vanadium> Do I have to build with -threaded to gain something from sprinkling par through all my code?
18:06:43 <Makoryu> Vanadium: I believe so.
18:07:14 <blackh> Vanadium: Yes, and you have to run it with +RTS -N2 (or however many cores you have)
18:07:39 <Vanadium> The +RTS thing seems to actually make an observable difference in runtime :s
18:08:04 <dancor> i guess emulators and interpreters are the same in some sense
18:08:14 <Vanadium> Oh, I did it wrong.
18:08:27 <SamB_XP> dancor: an emulator is a certain kind of interpreter, yeah
18:09:02 <dancor> what is something you can do and be called an interpreter that you cannot do and be called an emulator
18:10:09 <SamB_XP> well, usually you only get to call a thing an emulator if it is acting like a fairly believable computing device -- typically an obsolete one ;-)
18:10:16 <kmc> Vanadium, you may also want to up the heap size
18:10:22 <Pseudonym> Like, oh, digital logic.
18:10:25 <kmc> +RTS -H800M -N2 -sstderr
18:10:27 <kmc> or so
18:10:29 <SamB_XP> Pseudonym: right.
18:10:34 <SamB_XP> NOT!
18:10:37 <kmc> emulators are a type of interpreter
18:10:40 <Pseudonym> :-)
18:10:42 <ray> a C interpreter would be an emulator for a generic von neumann machine
18:10:58 <kmc> a specific generic von neumann machine, called C
18:11:13 <SamB_XP> and for some reason we also have a distinction between emulators and simulators ...
18:11:14 <Pseudonym> There's a fuzzy line here, but an interpreter implements a language, and an emulator implements a machine.
18:11:16 <yitz> many dynamic languages have an "exec" function. compiling them isn't very practical.
18:11:21 <Pseudonym> That's my intuition, anyway.
18:11:24 <kmc> SamB_XP, simulators capture properties below the ISA
18:11:26 <SamB_XP> yes, there *is* a funny line
18:11:33 <kmc> simulate an hardware implementation / emulate a software language
18:11:49 <Pseudonym> kmc, I don't think you need to simulate a hardware implementation.
18:11:53 <SamB_XP> for example, Z-machine implementations are called interpreters
18:11:54 <kmc> Pseudonym, languages are machines; machines are languages (or implementations of languages)
18:11:57 <Pseudonym> Necessarily.
18:12:12 <kmc> any language with operational semantics is *definitely* a machine
18:12:14 <Pseudonym> kmc: Right, so a regular expression interpreter is a deterministic finite automaton emulator.
18:12:22 <SamB_XP> Pseudonym: well, certainly that qualifies as a simulator
18:12:41 <SamB_XP> I guess typically simulators are missing major components of the system being simulated ;-)
18:12:41 <kmc> sure, but it's also a DFA interpreter or a RE emulator
18:12:47 <kmc> there's just no point drawing that distinction
18:13:13 <kmc> if you really want to make a distinction, make it between denotational and operational semantics
18:13:26 <SamB_XP> or I could put it this way:
18:13:29 <Pseudonym> The distinction is really about how high or low level the machine being implemented is.
18:13:43 <kmc> is the untyped lambda calculus high or low level?
18:13:58 <SamB_XP> if I can't use it to play a game, it's not an emulator ...
18:14:08 <SamB_XP> ... well, that doesn't work for z-machine ...
18:14:20 <kmc> i have this exciting game
18:14:23 <kmc> it's called beta reduction
18:14:25 <kmc> want to play?
18:14:34 <SamB_XP> kmc: I was thinking more like spacewar
18:14:36 <kmc> :)
18:15:06 <dancor> an interesting game; you can only win by not interpreting.
18:15:22 <SamB_XP> dancor: if someone throws an omega at you, sure
18:15:23 <kmc> dancor, in the untyped calculus you may never win, yet never lose
18:15:41 <kmc> i like my languages like i like my women: strongly normalizing
18:15:57 <SamB_XP> kmc: where do you get a woman who does that ?
18:16:07 <dancor> functional programming means never having to say goodbye to previous states of your computation
18:16:10 <copumpkin> Cale: any chance of getting lambdabot in #osx64ghc?
18:16:13 <kmc> @vixen are you strongly normalizing?
18:16:13 <lambdabot> i truely am
18:16:20 <Pseudonym> @vixen Are you confluent?
18:16:20 <lambdabot> first you tell me.
18:16:29 <Pseudonym> @vixen Are you metacircular?
18:16:29 <lambdabot> isn't it obvious?
18:16:32 <SamB_XP> dancor: so *that's* what happened to all of my RAM!
18:16:39 <SamB_XP> mozilla is secretly a functional program!
18:17:04 <dancor> it certainly secretes a lot of memory
18:17:08 <Pseudonym> @faq Is Haskell just a glorified "yes man"?
18:17:08 <lambdabot> The answer is: Yes! Haskell can do that.
18:18:30 <Cale> copumpkin: sure
18:18:38 <Cale> lambdabot: @join #osx64ghc
18:18:40 <dancor> haskell is what happens when you hide beauty and arcanity inside of each other
18:18:43 <Cale> copumpkin: permanent?
18:18:57 <copumpkin> Cale: probably not, thanks :)
18:21:09 <cagonto> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
18:22:07 <blackh> I keep telling these people, they're wasting their breath.  Haskell has the best boxing around.
18:22:40 <SamB_XP> blackh: I thought we wanted more *unboxing*
18:24:18 * BMeph is just waiting for the paper titled, "Unboxing: The Stripper that strips herself!"... ;\
18:25:55 <dibblego> what's the verb form of monomorphic?
18:26:05 <kmc> specialize
18:26:14 <kmc> type-apply
18:26:14 <copumpkin> monomorphize!
18:26:17 <SamB_XP> wow, english is crazy!
18:26:23 <copumpkin> monomorphizicatify
18:26:34 <dibblego> that'll do, thanks :)
18:26:41 <dibblego> you plonkers
18:26:47 <copumpkin> damn, /me was going to use the pumping lemma
18:26:50 <dolio> There's also "instantiate".
18:28:38 <Vanadium> Are there strict tuples somewhere in the prelude or something?
18:28:46 <dolio> No.
18:28:51 <copumpkin> GHC.Prim or Types iirc
18:28:56 <dolio> There's strict tuples in uvector.
18:28:58 <copumpkin> oh wait, those are unboxed tuples
18:29:06 <SamB_XP> copumpkin: they aren't listed there, I think
18:29:12 <Vanadium> I was kind of going for strictness in the hopes that the compiler would go and unbox them.
18:29:15 <SamB_XP> I don't know how they could be
18:29:18 <Vanadium> Maybe I misunderstood
18:29:29 <copumpkin> SamB_XP: good point
18:29:35 <copumpkin> it's a language extension I'm thinking of :)
18:29:39 <Vanadium> But replacing a pair with a data S a b = S !a !b made everything faster~
18:29:40 <Makoryu> Vanadium: There's -XUnboxStrictSomething, I believe
18:29:49 <aavogt> -funbox
18:29:50 <copumpkin> -funbox-strict-fields
18:29:58 <SamB_XP> they are *soo* primitive they don't even have data definition forms!
18:30:16 <dolio> They're so primitive they can't be used as arguments to functions.
18:30:30 <aavogt> -funsafe-...
18:32:53 <SamB_XP> -funsafe-coffee-comonad
18:33:02 * Pseudonym drinks some ffee
18:33:21 <Cale> @undefine
18:33:31 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes
18:33:32 <dolio> Oh no!
18:33:32 <lambdabot>  Defined.
18:33:34 <dolio> @type swap
18:33:35 <lambdabot> Not in scope: `swap'
18:33:37 <Cale> @let factors 1 = []; factors n = p : factors (n `div` p) where p = head (filter (\p -> n `mod` p == 0) primes)
18:33:38 <lambdabot>  Defined.
18:33:43 <Cale> @let numDivisors = product . map ((+1) . length) . group . factors
18:33:43 <lambdabot>  Defined.
18:33:47 <Cale> @let josephus = sieve 2 [1..] where sieve n (x:xs) = x : sieve (n+1) [u | (i,u) <- zip [0..] xs, i `mod` n /= 0]
18:33:47 <lambdabot>  Defined.
18:33:51 <Cale> @let diffJosephus = zipWith (-) (tail josephus) josephus
18:33:52 <lambdabot>  Defined.
18:33:56 <Cale> @let lost = [head [k | k <- [3*n+1..], 2*numDivisors ((k - n) `div` 3) == m] | (n,m) <- zip [1..] diffJosephus]
18:33:56 <lambdabot>  Defined.
18:34:01 <Cale> > take 6 lost
18:34:02 <lambdabot>   [4,8,15,16,23,42]
18:34:04 <Vanadium> It appears bang patterns make my code faster. What do they do again?
18:34:14 <dolio> Josephus, eh?
18:34:15 <SamB_XP> strictify
18:34:16 <Cale> Vanadium: Force evaluation of the given variable.
18:34:24 <Cale> Vanadium: (when pattern matching)
18:34:42 <Makoryu> Vanadium: f !x = foo ≈ f x = x `seq` foo
18:34:55 <Vanadium> To whnf?
18:34:58 <Cale> yeah
18:35:20 <Vanadium> So if the arguments end up being thunks that have already been evaluated that far, there should be no difference?
18:35:22 <BMeph> Too many "half-line" wonders get left out, 'cause they're so easy to whip up...I should give some a home. :)
18:35:28 <Cale> You generally shouldn't sprinkle them around too much, but apply them carefully when you know it's an issue.
18:35:32 <Cale> yeah
18:35:34 <Vanadium> Or is it magically faster because it can omit boxing?
18:35:50 <Cale> It won't make a difference when the parameters are already evaluated
18:36:08 <Vanadium> Strange
18:36:14 <SamB_XP> Vanadium: it will make a difference when GHC wouldn't have been able to figure that out on it's on, certainly ;-)
18:36:20 <Cale> In particular, if you already have another pattern or guard before that which would have forced them to be evaluated, it shouldn't make any difference.
18:37:39 <BMeph> Cale: What, no (nub.).gcd? ;p
18:38:23 <Cale> This one is a good bit faster, though I'm not sure it matters.
18:38:37 <copumpkin> > foldr1 lcm [1..10]
18:38:38 <lambdabot>   2520
18:40:23 <BMeph> Cale: To which "this one" were you referring? :)
18:40:46 <Cale> BMeph: The implementation of primes I used.
18:41:06 <Cale> Of course, there are much better ones too.
18:41:34 <Cale> But this one is easy enough to remember and I like the mutual recursion :)
18:43:52 <BMeph> Cale: We need a tidy O'Neill-Approved implementation. ;)
18:44:38 <enolan> Does the GHCI debugger not work with threads?
18:45:13 <SamB_XP> enolan: you mean, it actually *works* ?
18:45:17 <SamB_XP> how novel
18:45:49 <enolan> Huh? Most of ghc works in my experience.
18:46:03 <SamB_XP> I meant, for the *debugger* to work
18:46:32 <Cale> BMeph: Bird's thing would work well if we had a merge function in Data.List
18:46:50 <enolan> This is the first time it's not worked for me.
18:46:52 <Cale> Well... ordered list subtraction would also be needed.
18:47:24 <copumpkin> Data.Ordlist!
18:47:25 <enolan> "*** Ignoring breakpoint" :(
18:48:25 <Cale> @let (x:xs) `minus` (y:ys) = case compare x y of LT -> x : (xs `minus` (y:ys)); EQ -> xs `minus` ys; GT -> (x:xs) `minus` ys
18:48:26 <lambdabot>  Defined.
18:50:54 <Cale> @let (x:xs) `ordMerge` ys = x : (xs `merge` ys) where (x:xs) `merge` (y:ys) = case compare x y of LT -> x : (xs `merge` (y:ys)); EQ -> x : (xs `merge` ys); GT -> y : ((x:xs) `merge` ys)
18:50:55 <copumpkin> :t minus
18:50:55 <lambdabot>  Defined.
18:50:55 <lambdabot> forall t. (Ord t) => [t] -> [t] -> [t]
18:50:58 <copumpkin> :t times
18:50:59 <lambdabot> forall a. Int -> (a -> a) -> a -> a
18:51:21 <Cale> @let union = foldr ordMerge []
18:51:21 <lambdabot>  Defined.
18:52:01 <copumpkin> I don't think that union will work for a sieve, will it?
18:52:09 <copumpkin> I thought I tried that recently
18:52:30 <Cale> @let primes = 2 : ([3,5..] `minus` composites) where composites = union [map (p*) [p..] | p <- primes]
18:52:31 <lambdabot>  <local>:11:0:
18:52:31 <lambdabot>      Multiple declarations of `L.primes'
18:52:31 <lambdabot>      Declared at: <lo...
18:52:34 <Cale> ugh
18:52:41 <Cale> @undefine
18:52:47 <Cale> @let (x:xs) `minus` (y:ys) = case compare x y of LT -> x : (xs `minus` (y:ys)); EQ -> xs `minus` ys; GT -> (x:xs) `minus` ys
18:52:47 <lambdabot>  Defined.
18:52:51 <Cale> @let (x:xs) `ordMerge` ys = x : (xs `merge` ys) where (x:xs) `merge` (y:ys) = case compare x y of LT -> x : (xs `merge` (y:ys)); EQ -> x : (xs `merge` ys); GT -> y : ((x:xs) `merge` ys)
18:52:52 <lambdabot>  Defined.
18:52:56 <Cale> @let union = foldr ordMerge []
18:52:56 <lambdabot>  Defined.
18:53:03 <Cale> @let primes = 2 : ([3,5..] `minus` composites) where composites = union [map (p*) [p..] | p <- primes]
18:53:03 <lambdabot>  <local>:4:61:
18:53:03 <lambdabot>      Ambiguous occurrence `union'
18:53:03 <lambdabot>      It could refer to eithe...
18:53:11 <Cale> @let primes = 2 : ([3,5..] `minus` composites) where composites = L.union [map (p*) [p..] | p <- primes]
18:53:12 <lambdabot>  Defined.
18:53:15 <Cale> > primes
18:53:16 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:53:21 <copumpkin> ah, nice
18:53:59 <copumpkin> > nubBy (flip divides) -- is shorter but a lot less efficient :P
18:54:00 <lambdabot>   * Exception: divide by zero
18:54:03 <Cale> That primes is apparently asymptotically only off from the real sieve by a factor of log (log n), and has a good enough constant factor that it beats the real sieve for all practical sizes.
18:54:03 <copumpkin> bah :)
18:54:10 <copumpkin> > nubBy (flip divides) [2..] -- is shorter but a lot less efficient :P
18:54:11 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:54:26 <copumpkin> Cale: that smallcheck show instance for functions can be confusing sometimes :)
18:54:35 <Cale> copumpkin: ehehe
18:55:00 <Axman6> > primes !! 10000
18:55:02 <lambdabot>   104743
18:55:13 <Cale> > primes !! 100000
18:55:17 <lambdabot>   mueval-core: Time limit exceeded
18:55:29 <Cale> > [1..] !! 100000
18:55:30 <lambdabot>   100001
18:55:33 <BMeph> Cale: Why not throw in [p,p+2..] vice just [p..]? :)
18:55:42 <Cale> hmm
18:56:33 <ivanm> anyone have any ideas how I can write a parser (in polyparse if it makes a difference) that I can use to parse the inside of /* ... */ style C comments?
19:10:44 <m4ik3ru> Howdy.
19:11:03 <m4ik3ru> I have a problem with my code that may or may not be serious.
19:11:28 <m4ik3ru> I'm sure the question was designed to make the code run like this, but I'm a little...worried.
19:11:40 <m4ik3ru> And it may be my environment.
19:11:52 <m4ik3ru> Haven't tried any others...maybe I should do that first.
19:11:55 <m4ik3ru> But anywho.
19:11:59 <m4ik3ru> Anyone listening?
19:12:05 <jfoutz> yeah.
19:12:10 <m4ik3ru> Good.
19:12:27 <m4ik3ru> So I'm thinking this may be a space complexity problem.
19:12:42 <jfoutz> have you profiled it?
19:12:47 <m4ik3ru> I have to write a function that calculates an infinite list of perfect numbers.
19:12:51 <m4ik3ru> ...Don't know what that means.
19:13:01 <m4ik3ru> The profiled part.
19:13:12 <m4ik3ru> I know what perfect numbers and an infinite list are :)
19:13:18 <jfoutz> :)
19:13:50 <m4ik3ru> I have two functions defined, factors and perfect.
19:13:55 <jfoutz> no worries. i don't remember the profile options off the top of my head, but it's probably not that bad.
19:14:06 <m4ik3ru> Factors computes the factors of a number (obviously)
19:14:17 <m4ik3ru> And perfect constructs the list.
19:14:22 <m4ik3ru> Code is a follows.
19:14:34 <m4ik3ru> factors :: Int -> [Int] / factors n = [x | x <- [1..n], n `mod` x == 0] / perfect :: [Int] / perfect = [p | p <- [1..], (sum (factors p) - p) == p]
19:14:39 <m4ik3ru> sorry.
19:14:42 <m4ik3ru> Let me try that again
19:14:45 <m4ik3ru> factors :: Int -> [Int]
19:14:46 <jfoutz> uh wait
19:14:47 <m4ik3ru> factors n = [x | x <- [1..n], n `mod` x == 0]
19:14:48 <copumpkin> > any odd perfects -- you could answer a hard question with that code!
19:14:49 <lambdabot>   Not in scope: `perfects'
19:14:49 <m4ik3ru> perfect :: [Int]
19:14:50 <copumpkin> :P
19:14:51 <m4ik3ru> perfect = [p | p <- [1..], (sum (factors p) - p) == p]
19:14:57 <jfoutz> paste here:
19:14:59 <jfoutz> http://www.hpaste.org/
19:15:06 <jfoutz> *sigh*
19:15:19 <jfoutz> but no worries.
19:15:36 <m4ik3ru> I pasted it there, sorry )
19:15:40 <m4ik3ru> *:)
19:15:45 <m4ik3ru> more like :*)
19:15:50 <m4ik3ru> *blush*
19:15:57 * jfoutz shrugs.
19:16:10 <m4ik3ru> It computes the first three numbers without a hitch.
19:16:24 <m4ik3ru> 6,28,426...
19:16:44 <m4ik3ru> I waited for about a minute and a half to get 8128 and Ctrl-c'ed it.
19:17:11 <SamB_XP> m4ik3ru: I had no idea there *was* an infinite number of perfect numbers
19:17:22 <m4ik3ru> I'm in msys, but I'm thinking it's calling the ghci from my Windows path and not the one in msys
19:17:31 <kmc> you can write an infinite list with finitely many elements
19:17:36 <m4ik3ru> Not even sure I installed to the msys environment properly...
19:17:38 <kmc> (infinite in the sense that last xs = _|_)
19:17:49 <SamB_XP> m4ik3ru: you have *two* ghc's installed ???
19:18:09 <BMeph> Now THAT's dedication! ;)
19:18:39 <m4ik3ru> No, I couldn't get the one to install properly in the msys environment, but I got the windows binary to work, and since it was added to my path in Windows and for some reason msys checks that, it runs that one.
19:18:43 <m4ik3ru> I think...
19:19:01 <m4ik3ru> Haven't gotten into how to check from where ghci is running in msys
19:19:04 <dolio> _|_ is 'infinite' by that definition.
19:19:29 <SamB_XP> it might be tricky to use a spins-forever _|_
19:19:30 <kmc> by "infinite list" i mean "list with no nil"
19:19:35 <SamB_XP> rather than a more catastrophic one
19:19:50 <kmc> doesn't generalize to other types. _|_ :: [a] is an infinite list though
19:20:14 <m4ik3ru> I can telnet into the school's linux environment, tunnel the file in and try it there.
19:20:24 <kmc> telnet?
19:20:32 <mmorrow> s/telnet/ssh/ !
19:20:34 <kmc> is your school's linux environment in the mid 80's?
19:20:40 <m4ik3ru> haven't done that yet, just wanted to see if there were any obvious problems I'm missing.
19:20:45 <m4ik3ru> SSH, really :)
19:20:47 <SamB_XP> kmc: I didn't know telnet had time-travel support
19:20:51 <SamB_XP> how can I get that for SSH ?
19:21:06 <m4ik3ru> I suppose I'm misspeaking...
19:21:25 <Vanadium> Is there a more idiomatic way to express \x -> rnf x `par x?
19:21:33 <jfoutz> m4ik3ru: well... there's a bunch of tricks, one option might be to just consider primes as factors rather than every number.
19:21:38 <kmc> @pl \x -> rnf x `par` x
19:21:39 <lambdabot> par =<< rnf
19:21:57 <m4ik3ru> jfoutz: Will perfect number only have prime factors?
19:22:39 <jfoutz> m4ik3ru: hmm. good point.
19:24:13 <BMeph> rnf . join par? :)
19:24:36 <m4ik3ru> Same problem on the school's system.
19:24:39 <m4ik3ru> Curses.
19:24:45 <m4ik3ru> I suppose it's the nature of the problem.
19:25:13 <m4ik3ru> I'm very new to Haskell, not to mention funcitonal programming.
19:25:18 <m4ik3ru> ...if you couldn't already tell :)
19:25:19 <SamB_XP> m4ik3ru: look, your teacher never said the program had to actually get to the end of the list, right?
19:25:42 <m4ik3ru> Using a list comprehension, define the infinite list of all perfect numbers. Name and type to use:
19:25:42 <m4ik3ru> perfect :: [Int]
19:25:43 <lionheart> ctcp version
19:25:57 <m4ik3ru> So it does just say define.
19:26:08 <lionheart> ctcp amuck ping
19:26:12 <jfoutz> m4ik3ru: i think you're done as far as homework goes.
19:26:16 <m4ik3ru> Heh.
19:26:22 <m4ik3ru> I suppose.
19:26:25 <m4ik3ru> Anyway.
19:26:33 <m4ik3ru> On to bigger and better things, then.
19:26:42 <m4ik3ru> Like, the next 5 problems :)
19:26:51 <m4ik3ru> Thanks for your help.
19:26:57 <Guest26267> Hello. Does anybody know to find package and module of a function if I know only its name? Something like hoogle but so that it works across all packages?
19:27:13 <Axman6> hayoo?
19:27:16 <wmealing> arsenm: ping. Did you/was there ever any data/conversation flow in regards to clutter ?
19:27:17 <Axman6> @where hayoo
19:27:17 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
19:27:17 <kmc> google
19:27:29 <jfoutz> m4ik3ru: there are some speedups. you only have to look at n/2 for factors.
19:27:57 <Guest26267> oh. thank you.
19:28:04 <jfoutz> m4ik3ru: if you only consider primes, you look at even fewer elements, but will need a second pass to reconstruct the composite factors.
19:28:27 <m4ik3ru> jfoutz: Why only n/2 factors?
19:29:03 <jfoutz> well... if you're looking at 100, could it be divisible by anything bigger than 50?
19:29:28 <m4ik3ru> true...
19:29:31 <jfoutz> :)
19:29:42 <m4ik3ru> let me try to implement that then.
19:30:25 <jfoutz> m4ik3ru: do it after you finish the other problems.
19:30:56 <m4ik3ru> jfoutz: Good point :) though this isn't due until Sunday... NO!  Musn't get sidetracked.
19:31:07 * jfoutz was very good at not completing homework because of screwing around for hours on stuff like this :)
19:33:23 <m4ik3ru> jfoutz: Okay, I'm sorry, I did it anyway, but it didn't provide for any observable time increase.
19:33:37 <m4ik3ru> jfoutz: I had to use `div` instead of /, for some reason...
19:33:48 <m4ik3ru> jfoutz: But for real!  I'm moving on!
19:34:08 <jfoutz> hmm.
19:34:18 <jfoutz> well, thanks for letting me know.
19:34:29 <m4ik3ru> :)
19:34:44 <arsenm> wmealing: not really. I'm still going to be working on it when I have time
19:49:54 <Philonous> jfoutz: looking at 100, I see it is divisible by 100, which is > 50 ;)
19:55:17 <jfoutz> hrm.
19:55:22 <m4ik3ru> Philonous: but I know that already, and don't need it for the perfect number calculation
19:55:38 <jfoutz> so 5 is perfect?
19:55:45 <copumpkin> nope
19:55:59 <m4ik3ru> Philonous: in my code, i remove the -p from the sum(factors p-p)==p statement
19:56:00 <jfoutz> oh. right 5 + 1 = 6
19:56:18 <m4ik3ru> 6, 28, 496 and 8128 are as far as I've gotten.
19:56:30 <m4ik3ru> I waited for over 5 minutes, still no 5th perfect number.
19:56:47 <m4ik3ru> When I have more time, I'll actually wait and see what it is :D
19:57:01 <copumpkin> it's quite large
19:57:03 <jfoutz> i still think if you do the prime thing you'll get a big boost.
19:57:04 <Philonous> jfoutz: You leave the number itself out, otherwise there wouldn't be any perfect numbers (since 1+p > p )
19:57:18 <m4ik3ru> jfoutz: I don't understand what you mean
19:57:21 <jfoutz> Philonous: yeah. i was going to harras you about that.
19:57:45 <jfoutz> m4ik3ru: if you only check the primes, you'll save a lot of divisions.
19:58:00 <m4ik3ru> jfoutz: check the prime factors?
19:58:10 <jfoutz> yeah.
19:58:31 <m4ik3ru> but ALL of a numbers factors have to add up to that number for it to be perfect.
19:58:41 <jfoutz> once you have a list of prime factors, you can get a list of the composites by checking all the combinations of all the primes.
19:59:08 <jfoutz> actually, you can probably put a bound on that as well.
19:59:13 <copumpkin> it's divisors
19:59:14 * jfoutz shrugs
19:59:32 <copumpkin> both it's divisors and its divisors works there
19:59:52 <jfoutz> :)
20:00:20 <m4ik3ru> ...
20:04:33 <jfoutz> hmm. i guess permutations of infinite lists of primes is probably more complex than just doing the division directly
20:05:54 <m4ik3ru> cha.  i wrote a friendly note to the prof in the comments about the inefficiencies of the algorithm, in case he found a way to implement it much faster than i did, which is probable :)
20:06:34 <BMeph> [6,28,496,8128,33550336]
20:07:54 <copumpkin> omg there are only 5 perfect numbers!
20:08:10 <copumpkin> none of them odd! the question is answered!
20:08:59 <BMeph> Yes, copumpkin, There are only five numbers in "the first five perfect numbbers"...but I think we kind-of knew that already. ;p
20:09:03 <dolio> Those damn incompetent mathematicians would have figured that out by now if they weren't so lazy.
20:10:09 <dolio> Just like how they're too lazy to prove their axioms.
20:10:41 <BMeph> *numbers
20:10:45 * copumpkin just needs one axiom in his logic
20:11:02 <dolio> "Just" one?
20:11:21 <copumpkin> :(
20:11:23 <dolio> You need to get on the 0-axiom natural deduction bandwagon.
20:11:37 * jfoutz guesses copumpkin axiom is copumpkin is always right.
20:11:44 <copumpkin> jfoutz: genius!
20:12:17 <copumpkin> it also kinda proves itself
20:12:39 <copumpkin> since I accept the axiom, that means it's correct
20:13:36 <jmcarthur> is it consistent or is it complete?
20:13:38 <Draconx> I suppose it's consistent as long as you never, ever make two contradictory statements.
20:14:08 <copumpkin> Draconx: I would never make two contradictory statements
20:14:19 <jfoutz> it would be impossible.
20:14:30 <copumpkin> because then I would be wrong, and I'm always right
20:14:33 <jmcarthur> aha, so you are incapable of expressing two contradictory statements!
20:14:45 <jmcarthur> your system is obviously flawed
20:14:48 <copumpkin> I never said I was all-powerful, just always right
20:15:24 * copumpkin decides on himself as the new benevolent dictator of Haskell'
20:15:32 <copumpkin> since it's the right decision ;)
20:15:49 <jmcarthur> can you decide whether a computation in this system halts?
20:16:03 <copumpkin> Nope
20:16:09 <jmcarthur> so far so good
20:16:51 <copumpkin> :)
20:18:39 <SamB_XP> copumpkin: are you for life?
20:19:17 <copumpkin> You mean "pro-life"?
20:19:35 <SamB_XP> well, you know how Guido is BDFL?
20:19:37 <jfoutz> dictator.
20:19:39 <copumpkin> oh ok :)
20:19:42 <SamB_XP> I was wondering if you were going to be one too
20:19:53 <SamB_XP> but yes, that stupid joke did occur to me ...
20:20:05 <copumpkin> oh, I'll be BD until it's no longer right for me to be it
20:20:19 <SamB_XP> so can we call you the melonking ?
20:20:26 <copumpkin> sure
20:20:53 <jmcarthur> i'm not following what BDFL stands for
20:21:05 <jmcarthur> oh nevermind
20:21:14 <jmcarthur> benevolent dictator for life
20:22:06 * copumpkin is not a fan of guido
20:22:43 <shapr> copumpkin: Python > C/Java imho
20:22:48 <shapr> At least, less trouble.
20:23:28 <copumpkin> his hairstyle gets on my nerves: http://www.thebigbags.com/wp-content/uploads/2009/02/guido.jpg
20:23:42 <copumpkin> shapr: yeah, definitely less trouble
20:23:52 <SamB_XP> copumpkin: somehow it's never bothered me
20:24:03 * SamB_XP suspects he's never *seen* a photo of guido
20:24:19 <copumpkin> I just posted one!
20:24:40 <dolio> Hah, what?
20:24:52 <m4ik3ru> Unrelated: I have a terrible sinus infection that is spiralling downard into a cold.
20:25:12 <m4ik3ru> I need to do homework, but I have to be up a 5 for Army PT.
20:25:16 <copumpkin> this is the true guido, actually: http://en.wikipedia.org/wiki/File:Guido_van_Rossum_OSCON_2006.jpg
20:25:22 <copumpkin> Army PT?
20:25:43 <m4ik3ru> I'm planning on taking a Sudafed PE Sinus + Allergy, two ibuprofen, a Benadryl, and a shot of rum
20:25:47 <m4ik3ru> Thoughts?
20:25:59 <m4ik3ru> copumpkin: Army Physical Training.
20:26:06 <copumpkin> sounds rough
20:26:20 <m4ik3ru> The cocktail or the pt?
20:26:26 <copumpkin> both
20:26:29 <m4ik3ru> Heh.
20:26:54 <medfly> ??
20:26:56 <m4ik3ru> Well, i'm in charge of creating the pt plan for my squad, so really, we get to do whatever i want.
20:27:11 <m4ik3ru> but i still have to be up there at 5:30
20:27:13 <m4ik3ru> blegh
20:27:15 <copumpkin> ah :) we should probably take this to #haskell-blah before someone yells at us
20:27:19 <medfly> go to sleep now?
20:27:20 <m4ik3ru> heh.
20:27:22 <jfoutz> you should all enjoy the rum.
20:27:26 <m4ik3ru> i need to code!
20:27:38 <m4ik3ru> can't sleep, must code.
20:27:42 <medfly> how come you NEED to code but you have to wake up at 5am to do some physical training?
20:27:46 <m4ik3ru> i'm skipping merge sort for now.
20:27:49 <medfly> what kind of job is that?
20:28:00 <m4ik3ru> well, i don't need to code.
20:28:04 <copumpkin> m4ik3ru: merge sort is pretty simple to write!
20:28:05 <m4ik3ru> it's not due until sunday
20:28:19 <m4ik3ru> really?  i've implemented it in c++ before.
20:28:23 <medfly> combat programmers?
20:28:31 <m4ik3ru> i looked up some examples online, seems tough.
20:28:39 <m4ik3ru> medfly: i'm still in school, but one day, yes.
20:28:51 <medfly> you have a squad?
20:28:54 <copumpkin> m4ik3ru: just write the merge function and you'll be halfway there :)
20:28:55 <SamB_XP> medfly: apparantly they like engineers who can fight?
20:28:59 <m4ik3ru> medfly: only for pt
20:29:08 <jfoutz> i think mergesort is the only nlogn sort i can write without looking stuff up.
20:29:12 <copumpkin> ddarius is in the armed forces too, afair
20:29:15 <copumpkin> but he's stopped coming
20:29:25 <m4ik3ru> copumpkin: i think i have it: merge (x:xs) (y:ys) = if x > y then x : merge (xs) (y:ys) else y : merge (x:xs) (ys)
20:29:41 <m4ik3ru> that's backwards though, i just realized
20:30:00 <m4ik3ru> merge (x:xs) (y:ys) = if x < y then x : merge (xs) (y:ys) else y : merge (x:xs) (ys)
20:30:55 * copumpkin half wants agda's with "construct" for writing merge
20:32:23 <m4ik3ru> i don't yet understand the concept of splitting a list in two in haskell
20:32:38 <m4ik3ru> i have merge written, and i know that somewhere the lists have to split
20:32:59 <m4ik3ru> the only constructs i've ever worked with look like (x:xs) and xs for lists
20:33:16 <m4ik3ru> by the way, is the letter 's' necessary for list constructs?
20:33:31 <jfoutz> no, it's just a name.
20:33:47 <m4ik3ru> so i could do (a:ab)
20:34:01 <jfoutz> > let (foo:bar) = [1,2] in (foo,bar)
20:34:01 <lambdabot>   (1,[2])
20:34:11 <TheColonial> m4ik3ru, it's just an unwritten "standard".. you'll find many haskell coders do it.
20:34:16 <m4ik3ru> ah
20:34:39 <jfoutz> x and the rest of the xs
20:34:52 <m4ik3ru> i got that little pun ')
20:34:58 <m4ik3ru> ;) rather
20:35:31 <clank> can you define a data type like "all intervals of integers with positive length"?
20:36:12 <copumpkin> clank: not really, except by using tricks
20:36:27 <A1kmm> Hi, does anyone know the cleanest way to make a transformation like  the following: (Monad m, Monad m1) => (a -> m b) -> (m1 a -> m (m1 b))
20:36:39 <chexxor> Hey guys (and girls?)
20:37:10 <copumpkin> :t Data.Traversable.sequence
20:37:10 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
20:37:12 <A1kmm> e.g. I have a function String -> IO [String], and I want to transform it to Maybe String -> IO (Maybe [String])
20:37:19 <copumpkin> A1kmm: ^
20:38:42 <kmc> trix and hax
20:38:50 <A1kmm> copumpkin: ah thanks, I didn't know Maybe was Traversable.
20:38:56 <A1kmm> but it seems it is.
20:39:21 <copumpkin> A1kmm: it doesn't directly give you what you need but it should only be a step away... need any more help or did you get it?
20:41:14 <copumpkin> :t let wrangle = (Data.Traversable.sequence .) . fmap in wrangle
20:41:15 <lambdabot> forall a (m :: * -> *) a1 (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m a1) -> t a -> m (t a1)
20:42:08 <A1kmm> Ah... was trying to work that out.
20:42:18 <copumpkin> sorry :)
20:43:04 <dolio> @type Data.Traversable.traverse :: (Traversable t, Applicative m) => (a -> m b) -> t a -> m (t b)
20:43:05 <lambdabot>     Not in scope: type constructor or class `Traversable'
20:43:12 <dolio> @type Data.Traversable.traverse
20:43:13 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:43:13 <copumpkin> :o
20:43:26 <copumpkin> that's even prettier! I've never seen that one :)
20:43:34 <dolio> @type Data.Traversable.mapM
20:43:34 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
20:43:41 <copumpkin> oh!
20:43:52 * copumpkin needs to explore Traversable more :)
20:44:27 * copumpkin traverses the docs
20:44:30 <jokerGTA> guys how do you change rational numbers as    8%2  into integer such as 4
20:44:43 <copumpkin> jokerGTA: what if it isn't an integer?
20:44:54 <kmc> > toInteger (8 % 2)
20:44:55 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t))
20:44:55 <lambdabot>    arising from a us...
20:45:00 <dolio> > round (8%2)
20:45:01 <lambdabot>   4
20:45:06 <copumpkin> > truncate $ 9%2
20:45:06 <lambdabot>   4
20:45:20 <dolio> floor, ceiling
20:45:23 <jokerGTA> i did this     toInteger 8%2
20:45:30 <jokerGTA> and it didnt do anything
20:45:32 <copumpkin> jokerGTA: wrong precedence first of all
20:45:32 <jokerGTA> when i call it
20:45:40 <jokerGTA> it returns 8%2 again
20:45:41 <copumpkin> that's (toInteger 8) % 2
20:47:24 <jokerGTA> ok thank you
20:47:35 <copumpkin> it's kroo again!
20:48:25 <kmc> > 8 % 2
20:48:25 <lambdabot>   4 % 1
20:48:43 <copumpkin> > numer (8%2)
20:48:44 <lambdabot>   Not in scope: `numer'
20:48:49 <copumpkin> > numerator (8%2)
20:48:50 <lambdabot>   4
20:49:17 <kroo> 've gotta set #haskell to not join automatically :)
20:49:46 <copumpkin> why?!?! #haskell's the best channel on freenode
20:50:05 <kmc> true that
20:50:14 <kmc> haskell is so scary that we have to be extra nice to noobs
20:50:23 <copumpkin> hah
20:50:25 <kmc> whereas in #python they assume you're an idiot straight away
20:50:31 <m4ik3ru> You got that right.
20:50:44 <m4ik3ru> Case in point: can ANYONE figure out what I'm trying to do here:
20:50:45 <copumpkin> ORLY?
20:50:54 <m4ik3ru> concatenate (map (toUpper) (filter ((length xs) `mod` 2 == 1)))
20:50:58 <copumpkin> concat
20:51:02 <kmc> heh, looks like scheme
20:51:03 <m4ik3ru> close
20:51:10 <kmc> (toUpper) is a wee bit redundant
20:51:21 <m4ik3ru> meaning?
20:51:22 <kmc> you don't need the parens
20:51:29 <m4ik3ru> oh
20:51:38 <copumpkin> you're finding all the strings of odd length, making them uppercase, and sticking them together, duh ;)
20:51:48 <copumpkin> `mod` 2 == 1 === odd
20:51:52 <m4ik3ru> trying to
20:51:58 <kmc> isn't points-free style great
20:51:58 <copumpkin> except the real function name is concat
20:52:00 <dobblego> concat/map ... (>>=), `mod` 2 == 1 ... odd
20:52:20 <m4ik3ru> i defined a function using foldl
20:52:24 <kmc> also where is xs bound?
20:52:34 <copumpkin> :t toUpper =<< filter (odd . length)
20:52:35 <lambdabot>     Couldn't match expected type `m b' against inferred type `Char'
20:52:35 <lambdabot>     In the first argument of `(=<<)', namely `toUpper'
20:52:35 <lambdabot>     In the expression: toUpper =<< filter (odd . length)
20:52:38 <m4ik3ru> concatenateAndUpcaseOddLengthStrings xs =
20:52:42 <copumpkin> :t toUpper <=< filter (odd . length)
20:52:43 <lambdabot>     Couldn't match expected type `m c' against inferred type `Char'
20:52:43 <lambdabot>     In the first argument of `(<=<)', namely `toUpper'
20:52:43 <lambdabot>     In the expression: toUpper <=< filter (odd . length)
20:52:45 <m4ik3ru> there :)
20:52:46 <copumpkin> bah :)
20:53:03 <m4ik3ru> i *have* to use the function names he provides
20:53:09 <copumpkin> lame
20:53:15 <kmc> > let f = concatMap toUpper . filter (\xs -> (length xs `mod` 2) == 1) in f ["foo", "bar", "quux"]
20:53:16 <lambdabot>   Couldn't match expected type `[b]'
20:53:16 <lambdabot>         against inferred type `GHC.Types...
20:53:19 <kmc> grr
20:53:41 <kmc> concatenateAndUpcaseOddLengthStringsAndThenBecomeAJavaProgrammer xs =
20:53:59 <copumpkin> @type map toUpper <=< filter (odd . length)
20:54:00 <lambdabot> [[Char]] -> [Char]
20:54:03 <copumpkin> there
20:54:16 <kmc> @type (<=<)
20:54:17 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
20:54:26 <jfoutz> sometimes copumpkin frightens me.
20:54:28 <kmc> oh right backwards thingy
20:54:28 <copumpkin> > map toUpper <=< filter (odd . length) $ ["kmc", "lambdabot", "m4ik3ru", "copumpkin"]
20:54:29 <lambdabot>   "KMCLAMBDABOTM4IK3RUCOPUMPKIN"
20:54:36 <copumpkin> damn
20:54:38 <dobblego> kleisli composition
20:54:58 <copumpkin> jfoutz: it's just partially applied =<< really
20:55:12 <m4ik3ru> you guys are flying so high over my head right now...
20:55:17 <m4ik3ru> maybe that's good, maybe that's bad.
20:55:19 <copumpkin> m4ik3ru: sorry :P
20:55:30 <copumpkin> m4ik3ru: the problem with your code is that you need to map toUpper tice
20:55:31 <m4ik3ru> no big, it's entertaining at least, and i do learn a lot
20:55:33 <copumpkin> twice
20:55:44 <copumpkin> :t map toUpper
20:55:45 <lambdabot> [Char] -> [Char]
20:55:49 <copumpkin> you have [[Char]]
20:55:59 <copumpkin> you can always map toUpper after concatenating though
20:56:07 <m4ik3ru> yeah
20:56:13 <m4ik3ru> i'll probably do that
20:56:44 <jfoutz> :t filter (odd . length)  ["abc","asdf","a"]
20:56:45 <lambdabot> [[Char]]
20:56:51 <jfoutz> > filter (odd . length)  ["abc","asdf","a"]
20:56:51 <lambdabot>   ["abc","a"]
20:57:14 <copumpkin> > toUpper <$> join . filter (odd . length) $ ["abc","asdf","a"]
20:57:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:57:15 <lambdabot>         against inferred type...
20:57:32 <copumpkin> meh, I don't like the precedences there
20:57:39 <copumpkin> > toUpper <$> (join . filter (odd . length)) $ ["abc","asdf","a"]
20:57:39 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:57:39 <lambdabot>         against inferred type...
20:57:43 <m4ik3ru> concatenateAndUpcaseOddLengthStrings xs = map toUpper (concatenate (filter (length xs `mod` 2 == 1)))
20:57:43 <copumpkin> or not
20:57:54 <m4ik3ru> doesn't like something there.
20:57:55 <jfoutz> > concatMap toUpper $ filter (odd . length)  ["abc","asdf","a"]
20:57:55 <lambdabot>   Couldn't match expected type `[b]'
20:57:56 <lambdabot>         against inferred type `GHC.Types...
20:57:59 <m4ik3ru> crap.
20:58:13 <m4ik3ru> this should be some silly nested arguments!
20:59:18 <copumpkin> :t let foo xs = map toUpper (concatenate (filter (length xs `mod` 2 == 1))) in foo
20:59:18 <lambdabot> Not in scope: `concatenate'
20:59:24 <copumpkin> :t let foo xs = map toUpper (concat (filter (length xs `mod` 2 == 1))) in foo
20:59:24 <lambdabot>     Couldn't match expected type `a -> Bool'
20:59:24 <lambdabot>            against inferred type `Bool'
20:59:24 <lambdabot>     In the first argument of `filter', namely
20:59:26 <jmcarthur> > concatMap (map toUpper) $ filter (odd . length) ["abc","asdf","a"]
20:59:27 <lambdabot>   "ABCA"
20:59:50 <copumpkin> :t let foo xs = map toUpper (concat (filter (\x -> length x `mod` 2 == 1))) in foo
20:59:51 <lambdabot>     Couldn't match expected type `[[Char]]'
20:59:51 <lambdabot>            against inferred type `[[a]] -> [[a]]'
20:59:51 <lambdabot>     In the first argument of `concat', namely
21:00:18 <jfoutz> concatmap is not what i thought it was.
21:00:19 <copumpkin> :t let foo xs = map toUpper (concat (filter (\x -> length x `mod` 2 == 1) xs)) in foo
21:00:19 <lambdabot> [[Char]] -> [Char]
21:00:38 <jmcarthur> jfoutz: concat . map
21:00:45 <jmcarthur> @concatMap
21:00:45 <lambdabot> Unknown command, try @list
21:00:48 <copumpkin> slightly more efficiently though
21:00:49 <jmcarthur> @src concatMap
21:00:49 <lambdabot> concatMap f = foldr ((++) . f) []
21:01:11 <dobblego> concatMap f x = concat (map f x)
21:01:41 <copumpkin> (concat .) . map
21:01:58 <copumpkin> nothing better than composition sections in the evening
21:02:12 <dobblego> @type fmap fmap fmap concat map
21:02:13 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
21:02:14 <m4ik3ru> does x always equal head xs
21:02:30 <jmcarthur> result concat . map
21:02:32 <copumpkin> m4ik3ru: if you pattern match such that it does
21:02:36 <m4ik3ru> not unless you construct the list like (x:xs), right?
21:02:37 <jmcarthur> where result = (.)
21:02:45 <copumpkin> it would have to be xs@(x:_)
21:02:51 <m4ik3ru> blegh.
21:03:03 <m4ik3ru> my cocktail is kicking in, i need to sleeeeeeep.
21:03:10 <m4ik3ru> you all have been extremely helpful though :)
21:03:11 <copumpkin> you're taking the list apart with (x : xs)
21:03:19 <copumpkin> you're saying x is the head of the list and xs is the tail
21:03:40 <copumpkin> put together, they make the original list
21:03:56 <m4ik3ru> ah.
21:04:03 <kmc> m4ik3ru, nothing wrong with drunk haskell
21:04:19 <m4ik3ru> i still have to get up at 5, though
21:04:44 <m4ik3ru> there is a problem with not sleeping if you have a sinus infection that's deteriorating into a cold and you have to get up and run in the morning
21:04:53 <kmc> damn, that sucks
21:05:02 <m4ik3ru> hehehe :) such is life.
21:05:06 <m4ik3ru> i
21:05:14 <m4ik3ru> i'll see y'all tomorrow, most likely
21:05:46 <sereven> Is there some other name for f (i, mx) = mx >>= \x -> return (i, x) :: (Monad m) => (t, m a) -> m (t, a)? looks almost like sequenceA, not sure if applicative will be enought yet, probably
21:06:31 <copumpkin> sereven: strength
21:06:42 <copumpkin> :t uncurry (fmap . (,))
21:06:43 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
21:07:05 <sereven> hmm, don't want base 4, but maybe can steal the definition
21:07:12 <copumpkin> sereven: it's not even in base 4 :)
21:07:20 <copumpkin> @hackage category-extras
21:07:20 <lambdabot> http://hackage.haskell.org/package/category-extras
21:07:43 <sereven> copumpkin: isn't it from... yeah, doesn't that package require base 4, actually can't use extra package here anyway
21:07:55 <copumpkin> yeah, that's a massive package for just that function
21:08:08 <copumpkin> it's short enough to just define when you use it (that's what I usually do)
21:08:09 <sereven> that darn strength just keeps coming up all over these days.
21:08:23 <sereven> what would Prelude.mapM strength be?
21:08:36 <copumpkin> @let strength = uncurry (fmap . (,))
21:08:37 <sereven> that's probably what I really need here
21:08:37 <lambdabot>  Defined.
21:08:42 <copumpkin> :t mapM strength
21:08:43 <lambdabot> forall a1 (m :: * -> *) a. (Functor m, Monad m) => [(a1, m a)] -> m [(a1, a)]
21:09:23 <sereven> hehe, maybe I'll call it wrangle in honor of whomever earlier
21:09:37 <copumpkin> hah, that's a disposable name I stole from mmorrow
21:09:47 <sereven> detwist
21:12:02 <copumpkin> :)
21:18:07 <mmorrow> heh, wrangle
21:22:36 <RyanT50002> i'm getting: "*** Exception: j: openFile: does not exist (No such file or directory)" when i try to use Network.Browser, and also whenever i use Cabal
21:22:44 <RyanT50002> how would i go about tracking this down?
21:24:10 <RyanT50002> (running GHC 6.10.4 on Ubuntu amd64)
21:25:55 <dons> RyanT50002: that's a bit mysterious
21:26:19 <RyanT50002> dons: i get this every time i use the cabal command line utility without first deleting ~/.cabal/config
21:26:46 <RyanT50002> as far as i can tell, i've got the most up-to-date version of every library Network.Browser depends on
21:26:58 <RyanT50002> it's loading base-3.0.3.1, but that's the only thing it's loading that isn't max-version
21:27:01 <dcoutts> RyanT50002: nobody has worked out what's causing that
21:27:06 <kmc> try creating a file named 'j' and see what happens
21:27:15 <RyanT50002> the letter is different every time
21:27:18 <kmc> or, strace the program
21:27:18 <dcoutts> it's a random unprintable character
21:27:30 <mmorrow> weird
21:27:32 <dcoutts> it's pretty hard to track down or reproduce
21:27:45 <dcoutts> recompiling often makes it go away
21:27:48 <RyanT50002> hm
21:28:02 <RyanT50002> alright, i'll give that a shot
21:28:10 <RyanT50002> is there any way to make exceptions generally give you more information?
21:28:26 <RyanT50002> i guess everything would have to be compiled for debug
21:28:28 <dcoutts> RyanT50002: not without recompiling or relinking
21:28:36 <RyanT50002> yeah, makes sense
21:28:41 <cloudhead> any reason why this list comprehension is slow? [ [x,y,z] | x <- [1..1000], y <- [x..1000], z <- [y..1000], x^2 + y^2 == z^2 ]
21:28:51 <dcoutts> RyanT50002: roll on dynamic libs :-)
21:28:59 <RyanT50002> lol
21:29:15 <dcoutts> LD_PRELOAD=libHSrts.so ./foo +RTS -debug blah -RTS
21:29:21 <dcoutts> LD_PRELOAD=libHSrts_debug.so ./foo +RTS -debug blah -RTS
21:29:22 <RyanT50002> could it depend on whether i'm using the "-n" build from the download page?
21:29:24 <kmc> cloudhead, it runs one billion times?
21:29:30 <jmcarthur> cloudhead: could be that it's doing a billion tests
21:29:32 <kmc> oh heh, not quite
21:29:34 <RyanT50002> ah, ok
21:29:42 <kmc> but order-of
21:29:51 <copumpkin> cloudhead: there are much better ways of generating pythagorean triples
21:29:52 <dcoutts> RyanT50002: I've tried with some people and while they could reproduce it with the original binary, they could not make another version from source that exhibited the same problem.
21:30:09 <cloudhead> kmc, jmcarthur: but it takes a couple seconds even to find the first pair, which is [3,4,5]
21:30:23 <copumpkin> cloudhead: that's because it's iterating 3 millions times before it does that
21:30:28 <RyanT50002> dcoutts: i installed from http://haskell.org/ghc/dist/6.10.4/ghc-6.10.4-x86_64-unknown-linux-n.tar.bz2
21:30:31 <kmc> because it runs through [1,1,1], ... [1,1,1000], [1,2,1], ...
21:30:39 <cloudhead> ah I see
21:30:42 <kmc> cloudhead, there are *much* better ways of generating pythagorean triples
21:30:50 <kmc> also why are you putting them into a list of length 3?
21:30:52 <dcoutts> RyanT50002: I think that is a common trait so far
21:31:03 <cloudhead> I'm sure there are! I'll have to figure it out
21:31:11 <cloudhead> kmc: as opposed to a tuple?
21:31:14 <kmc> sure
21:31:29 <cloudhead> cause I can use sum on it
21:31:34 <kmc> ah
21:31:40 <cloudhead> are tuples faster?
21:31:47 <kmc> i would not worry about that
21:32:01 <kmc> that is a legitimate reason to use a list, though you could also just write x+y+z in the comprehension
21:32:10 <medfly> you can start by using only squares of numbers
21:32:14 <cloudhead> right
21:32:27 <kmc> once you know x and y, you know what z would have to be
21:32:51 <cloudhead> yea, I'm gonna try something like that next
21:33:02 <copumpkin> @let times = ((appEndo . mconcat . map Endo) .) . replicate
21:33:03 <lambdabot>  Defined.
21:33:04 <cloudhead> I just thought I could get away with this : >
21:33:24 <copumpkin> > 5 `times` (+5) $ 1
21:33:25 <lambdabot>   26
21:33:42 <kmc> .) .
21:34:29 <copumpkin> > (times 5 . times 5 . times 5 $ (+1)) 1
21:34:30 <lambdabot>   126
21:35:57 <Gracenotes> @type times
21:35:58 <lambdabot> forall a. Int -> (a -> a) -> a -> a
21:36:22 <Gracenotes> oh. a la lambda calculus.
21:36:28 <mmorrow> > foldr (.) (+1) (fmap times [1..10]) 1
21:36:29 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
21:36:29 <lambdabot>    arising from the literal `1' at <...
21:36:45 <mmorrow> > foldr (.) (. (+)) (fmap times [1..10]) 1 1
21:36:46 <lambdabot>   No instance for (GHC.Num.Num ((a -> a) -> a))
21:36:46 <lambdabot>    arising from the literal `...
21:36:55 <mmorrow> grr
21:37:12 <mmorrow> > foldr (.) id (fmap times [1..10]) (+1) 1
21:37:13 <lambdabot>   * Exception: stack overflow
21:37:55 <copumpkin> hah
21:40:00 <jmcarthur> huh, times is the same as converting Ints to Church numerals
21:41:07 <|Steve|> :t times
21:41:08 <lambdabot> forall a. Int -> (a -> a) -> a -> a
21:41:29 <copumpkin> @let twice = times 2
21:41:30 <lambdabot>  Defined.
21:41:33 <copumpkin> @let thrice = times 3
21:41:34 <lambdabot>  Defined.
21:41:35 <jmcarthur> > times 5 (+1) 0
21:41:36 <lambdabot>   5
21:41:38 <Gracenotes> last (replicate n f)
21:41:54 <copumpkin> Gracenotes: you want iterateN ? :P
21:42:07 <Gracenotes> I mean, iterate n f
21:42:13 <Gracenotes> the other one would be foldr (.) id (replicate n f)
21:42:22 <Gracenotes> copumpkin: well, that's what it is
21:42:43 <copumpkin> iterate keeps all iterations around
21:43:41 <mmorrow> @let ntimes n = foldr (.) id . replicate n
21:43:42 <lambdabot>  Defined.
21:44:00 <Gracenotes> iterate brings all the iterations to the yard
21:44:02 <copumpkin> what's what I used to have, but I was feeling fancy this last time :)
21:44:55 <Gracenotes> mconcat for lists is essentially foldr mappend, and mappend for Endo is essentially (.) :o
21:45:02 <copumpkin> yep
21:45:28 <copumpkin> mconcat is always foldr mappend
21:45:34 <copumpkin> (mempty)
21:45:45 <mmorrow> by default
21:45:53 <copumpkin> oh it's a method?
21:45:59 <mmorrow> yeah
21:46:15 * copumpkin isn't sure how he feels about those optimization methods
21:46:19 <mmorrow> like, if mappend is (+) or union or something, you'd want foldl'
21:46:49 <Gracenotes> override teim
21:47:38 <Gracenotes> which Map/Set/etc. do. Instead of using foldl', however, they use unions, which effectively is defined as foldl' union
21:47:51 <Gracenotes> I think they make their own foldl? for some reason.
21:48:23 <mmorrow> they have a fold to fold over the Map/Set, but since mconcat is :: [a] -> a, they'd use foldl'
21:48:33 <Gracenotes> I don't think they'd import Data.List just for foldl'
21:48:52 <mmorrow> oh, i see what you mean. either way, foldl' is foldl'
22:02:11 <cagonto> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
22:07:50 <ivanm> can someone please ban cagonto from coming on here every now and again to promote this online boxing game of his?
22:09:43 <copumpkin> is it always cagonto? I thought it was always someone different who just did /list and looked for the most populated channels
22:10:34 <Smokey`> sadly with all the online irc clients now days, and web based proxies - it's hard to block people from advertising on irc... :(
22:13:33 <ivanm> the nick sounds familiar
22:13:33 <ivanm> copumpkin: looks the same as the person 4 hours before...
22:13:33 <copumpkin> Smokey`: I'm still reasonably sure we could kill most of it by just setting +p or +s on the channel :)
22:13:33 <copumpkin> so it doesn't show up in /list
22:13:33 <ivanm> ahhh, it was pacopil the other day, with a similar looking host mask...
22:13:33 <ivanm> copumpkin: what do they do?
22:13:33 <copumpkin> ivanm: prevent us from showing up on /list
22:13:33 <ivanm> so people think it's an empty channel?
22:13:39 <ivanm> and hopefully think it's not worth spamming here?
22:13:48 <copumpkin> it just doesn't appear at all
22:13:53 <copumpkin> if you know to come here, you can join
22:13:59 <copumpkin> but you won't find us on the channel listing
22:14:00 <ivanm> ahhh
22:14:24 <copumpkin> it'd also stop all the "WUT IZ PROGRAMING! LERN ME C++ KTHX" people
22:14:42 <copumpkin> or a few of them, maybe :)
22:15:08 <inimino> no it wouldn't ;)
22:15:57 <kmc> it will send more beginners to #haskell-in-depth
22:16:15 <copumpkin> we can hide that one too :P
22:16:15 <ivanm> true
22:16:27 <ivanm> copumpkin: then we can hide that big pink elephant in the corner...
22:16:33 <copumpkin> yep
22:16:46 <copumpkin> elephants are meant to be hidden anyway
22:24:26 <clayjar> I've just started to skim about Haskell... and read that compiler isn't very optimized (from some website in a complaint tone), is this true? I am very interested in learning this language, which is purported to be a computer language that is not as "broken" as others, at least in theoretical sense. What do you think about its compiler optimization?
22:24:44 <copumpkin> clayjar: out of curiosity, what website?
22:25:23 <kmc> clayjar, there are several haskell compilers
22:25:29 <clayjar> I can't remember exactly, but it was a website that pretty much assumed that about the compiler, along with the fact that it doesn't have as many libraries as other languages more popularly used for website development.
22:25:30 <kmc> ghc is very sophisticated, and is what most people use
22:25:31 <Smokey`> clayjar: the compiler is optimized, most of the core libraries and types used though - aren't built for raw performance... (you have to know what types to use, how they work internally, for each circumstance)
22:25:44 <Smokey`> s/the compiler/ghc/
22:25:50 <kmc> there is no "the compiler" for any popular language
22:25:53 <kmc> thanks :)
22:26:06 <Smokey`> ghc is all that matters as far as I'm concerned, with haskell ;)
22:26:07 <Axman6> clayjar: GHC is a very good optimising compiler, sometimes producing cocde faster than C
22:26:38 <clayjar> I've installed ghc recently and I look forward to compiling a working program on it soon for some revelation.
22:27:19 <clayjar> Let me try to recall that website, brb.
22:27:49 <kmc> clayjar, it is much easier to optimize haskell than most languages, because values are immutable by default
22:28:13 <kmc> this also gets you parallel evaluation on multiple cores with very little programmer effort
22:28:19 <kmc> though that topic is still very bleeding-edge
22:29:30 <clayjar> Yes, that's (multicore programming) is one of the reasons I'm interested in learning this language.  I think that's the future of programming, since the processors aren't getting any faster.
22:30:13 <Smokey`> mmm I've read some of the advances haskell has made there (mostly microsoft work that I read...) - curious how people are still pushing for heavy parallel programming on an inheritently serial and in-order processing architecture... though I do understand the desire to want it, with multi-core processes becoming the norm now days (would hate to lose performance)
22:30:37 <Smokey`> I only say that though, coming from a background in parallel programming on wide simd architectures (mainly GPUs and other DSPs)
22:30:43 <clayjar> This isn't the same article, but touches on a similar topic: http://www.algorithm.com.au/blog/files/36ca9a664954e680edb64d260d763252-350.php
22:31:06 <kmc> clayjar, that article is 5 years old
22:31:11 * Smokey` wishes he had more time to 'toy' around in Haskell
22:32:07 <copumpkin> clayjar: you'll find that most claims of haskell/ghc being slow are either old or stem from people with ulterior motives for doing so. GHC is pretty good for speed now and is only getting better
22:32:21 <clayjar> Oh, tx for pointing that out, I will start checking the dates on these articles I'm coming across more carefully. I became aware of Haskell only recently.
22:32:22 <Smokey`> would love to rewrite my old ray tracer in haskell, latest GHC, etc - see how I could improve it...  (previously it was about 40-50 times slower than my C++ version, despite using unboxed arrays, strict evaluation, identical algorithms to the C version, etc)
22:32:24 <kmc> there have been massive improvements since then
22:33:19 <clayjar> I guess you'd say that Haskell is stable enough to be used in commercial settings (specifically, in healthcare), right?
22:33:40 <kmc> well, the language is perfectly stable -- it's just a spec
22:33:48 <kmc> do you mean the ghc implementation?
22:34:11 <clayjar> Let's say one is trying to build a patient portal (cf. webmd.com), why would someone choose Haskell over .NET or J2EE platform?
22:34:27 <kmc> i wouldn't, because you have to hire smarter programmers
22:34:43 <Smokey`> if they wanted to just 'get the job done', they wouldn't choose haskell :P  it'd take longer (depending on your programmers), and cost more :P
22:34:55 <clayjar> Sorry, if my understanding of Haskell is greatly limited. As I already said, I only became aware of Haskell recently, and barely installed ghc few days ago..
22:34:57 <copumpkin> it wouldn't necessarily take longer
22:35:00 <kmc> haskell is good for when you can afford to hire really good people, and want the job done very well and quickly
22:35:04 <copumpkin> it would definitely take longer if they had to learn haskell first
22:35:31 <kmc> it's the "good, fast" choice among "good, fast, cheap", even though all the software is of course free
22:36:34 <clayjar> Being somewhat of an idealist, I'm very excited about learning Haskell, since it seems to be one of more ideal languages, but I guess I've jumped into this chat room to sort of weigh it horizontally...
22:36:54 <kmc> clayjar, learning haskell will improve your code in most languages you use
22:36:54 <Smokey`> copumpkin: well, learning haskell takes years... :P  I did 1 year of solid haskell at uni, and in my own time, and then i've tinkered with it and read up on things over the past 2-3 years... I still don't understand a LOT about haskell (Monads still confuse me at times too)
22:37:00 <kmc> i think that's good enough reason to do it
22:37:08 <copumpkin> clayjar: it is a very ideal language, but are you willing to spend a significant amount of time to get your developers (and yourself) to learn the language?
22:37:25 <copumpkin> clayjar: it's very unlike anything people are likely to be exposed to, and is thus not the kind of thing you want to learn as you go
22:37:56 <kmc> i also think it's funny that people complain about Haskell's performance in a world where Python, Ruby, and PHP are incredibly popular
22:38:10 <kmc> without any compilers, let alone an optimizing compiler
22:38:23 <copumpkin> haskell's so much higher-level than those yet so much faster :D
22:38:29 <Smokey`> kmc: people who complain about performance in haskell, are generally C/C++/Ada/Fortran/etc users... not web devs :P
22:38:54 <Smokey`> and then, on top of that - those people who do complain, generally just haven't done their research
22:39:01 <kmc> but regardless, it shows there is a huge domain where even massively inefficient implementations are successful
22:39:14 <copumpkin> well, people who aren't used to lazy evaluation can get caught by nasty space leaks and get very slow programs because of it
22:39:21 <Smokey`> successful in areas where performance isn't critical, productivity is :P
22:39:25 <clayjar> Well, idealism rarely joins the quick-and-dirty crowd. ;-)
22:39:52 <Smokey`> mind you, python can compile into code which runs near C/C++ speeds...
22:39:56 <Smokey`> can't speak for ruby/php, wouldn't have a clue
22:39:56 <kmc> how's that?
22:40:13 <kmc> also again, there is no such thing as "C++ speed"
22:40:16 <kmc> there is g++ speed
22:40:24 <Smokey`> kmc: fine, native speed.
22:40:34 <copumpkin> there is g++ + your own optimization skills speed
22:40:37 <Smokey`> my point is in the end the same instructions get executed, roughly
22:40:41 <kmc> okay
22:40:49 <Smokey`> for roughly similar code
22:40:51 <copumpkin> Smokey`: what python is that?
22:41:03 <kmc> because i can tell you that g++ and icpc do not produce the same speed code from the same C++ source :)
22:41:10 <Smokey`> copumpkin: CPython 'can' do it, but IronPython + Mono is much much better, especially if you use AOT
22:41:18 <clayjar> I think Smokey assumes, as people normally do, that C/C++ compilers are one of the most optimized compilers out there in terms of language to machine code ratio.  Anyway...
22:41:54 <kmc> clayjar, doesn't that ratio have more to do with how high-level the source language is?
22:41:57 <Smokey`> clayjar: C compilers tend to be, yes.   C++ definately not, but it depends on the complexity of the code and what language features you use.
22:41:59 <kmc> i'm confused by what it would measure
22:42:03 <copumpkin> Smokey`: any benchmarks that show it? I've heard of pypy doing quite well, but never of it approaching those speeds. It seems like it'd need to do massive analysis at compile time to get rid of the types
22:42:39 <clayjar> kmc, not necessarily, I think with right algorithms and optimization, you can have very optimized ratio, depending on the architecture and the syntactical structure of the language at hand.
22:42:48 <Smokey`> copumpkin: hmm, I got my info from a blog (guessing it would've been on reddit or an ironpython blog somewhere).  It's the same story with most .NET languages, mono, and AOT
22:42:49 <kmc> there are some dynamically typed languages with fast compiled implementations
22:43:03 <copumpkin> lua, I guess
22:43:09 <copumpkin> actually lua isn't compiled
22:43:26 <Smokey`> lua source can be compiled though... again, mono :P
22:43:30 <kmc> some lisps
22:43:36 <kmc> erlang
22:43:38 <copumpkin> ah, and stalin scheme
22:44:01 <copumpkin> that's the only time I've heard of a compiled dynamic language being at (optimized) c-like speeds
22:44:04 <clayjar> For example, I would consider JVM to be a hindrance to optimization, so I don't get persuaded by Java enthusiasts very often.
22:44:19 <kmc> clayjar, why? it's just an intermediate code representation.  every compiler has one
22:44:38 <kmc> and there are also statically typed languages with implementations that keep types through to runtime, like the tagged ML implementations
22:44:44 <kmc> though you still don't need nearly as many check
22:44:47 <pikhq> Hmm. C doesn't actually seem all that (compiler) optimizable. It just doesn't hand enough information to the compiler to do that much to it. It just seems very allowing of hand-optimization.
22:44:58 <copumpkin> pikhq: it definitely isn't, but humans can optimize it a lot
22:45:00 <copumpkin> yep
22:45:08 <kmc> agreed, C compilers have to be very conservative because of all the awful pointer tricks you can do
22:45:22 <copumpkin> writing more restrict in your code helps the compiler a fair amount
22:45:51 <pikhq> It's amazing that C compilers can do anything at all to it, really.
22:45:54 <lament> pikhq: you can't optimize what's rilly fast to begin with
22:45:55 <kmc> how many people use restrict?
22:45:58 * Smokey` smirks
22:46:07 <copumpkin> kmc: not as many as should be using it
22:46:10 <kmc> i've never seen it used at work and we write high performance realtime C++
22:46:10 <clayjar> It's a natural progression from a given hardware architecture.  I think if we had a different configuration of registers and bus widths and processing schemes, I think we would be working with very different set of languages.
22:46:12 <copumpkin> lament: sure you can
22:46:30 <bd_> kmc: C++ doesn't have restrict :)
22:46:32 <pikhq> lament: GCC does it.
22:46:34 <clayjar> Fortunately, we have a language like Haskell that didn't start out with an assembler.
22:46:38 <kmc> oh
22:46:45 <lament> clayjar: that's why haskell's so damn fast
22:47:13 <Smokey`> does GHC still compile Haskell to C as an intermediate compilation step?
22:47:18 <copumpkin> it has that option
22:47:27 <copumpkin> but they're trying to get rid of it except for unregistered builds
22:47:44 <copumpkin> it isn't the default on the tier-1 platforms though
22:47:55 <Smokey`> so they've got a pure Haskell -> AST -> instructions compiler now?
22:48:08 <copumpkin> it goes through a lot more steps than that, but yep
22:48:12 <Smokey`> nice :)
22:48:29 <kmc> Smokey`, the passes are roughly Haskell -> Core -> STG machine -> C-- (maybe?) -> assembly
22:48:33 <kmc> with optimizations in Core and STG
22:49:25 <clayjar> It'd a cool feat if someone actually did a direct translation from Haskell to gas code.
22:49:34 <kmc> not sure what you identify by "Haskell -> AST", the parser?
22:49:44 <kmc> each of those intermediate languages is an AST of some kind
22:49:48 <copumpkin> clayjar: directly?
22:49:59 <kmc> i don't know what "directly" means.  in one fold?
22:50:05 <pikhq> clayjar: ... Nobody does anything like that. I mean, nobody.
22:50:06 <clayjar> LOL.. I guess the abstraction would drive people nuts for at least a hundred years.
22:50:12 <pikhq> Because it would be absurd.
22:50:27 <clayjar> Another words, absurd is the right word for it.
22:50:33 <copumpkin> clayjar: most compilers peel it off bit by bit, converting to a slightly lower-level representation
22:50:35 <Smokey`> kmc: my 'AST' stage was a generalization of the stages inbetween parsing/tokenizing, and compiling into the desired instruction set.
22:50:48 <kmc> ah that's most of the compiler :)
22:50:50 <copumpkin> I think IR is a common name for that
22:51:01 <copumpkin> maybe not though :)
22:51:07 <Smokey`> yup, I didn't care how it was done - I was just curious if it still used C in there somewhere
22:51:38 <clayjar> Well, I'm not sure if anyone remembers, but GeoWorks had a framework that translated most of high-level calls directly to machine code, but those were the simpler days.
22:51:43 <kmc> C is 90% of the way to a perfectly fine backend language
22:52:07 <kmc> and imo there's not much point to each compiler writer implementing their own arch-specific instruction output and register allocator
22:52:19 <kmc> these days it is probably better to use LLVM or C--
22:52:20 <copumpkin> clayjar: it's a lot easier to do away with many of the intermediate representations if your language directly mirrors the underlying machine
22:52:32 <copumpkin> that is, most imperative languages :)
22:53:05 <Smokey`> LLVM is pretty nice :)
22:53:19 <clayjar> copumpkin, point well taken.
22:53:30 <kmc> one of those things that's both a solved problem and a pain to solve yourself :)
22:53:35 <copumpkin> Smokey`: someone's working on an LLVM backend for GHC
22:53:56 <Smokey`> copumpkin: that doesn't surprise me :)  everyone's working on LLVM backends for most compilers now days :)
22:54:05 <copumpkin> yep
22:54:13 <kmc> maybe they should have called it LLL
22:54:24 <copumpkin> but GHC will be super awesome and amazing once we get supero + llvm backend (I hope by 6.14)
22:54:29 <kmc> seems like "VM" would scare off people who don't understand that every language is a VM, and that it doesn't imply anything about implementation
22:54:37 <kmc> supero?
22:54:40 <Axman6> there are some problems using LLVM in GHC though
22:55:01 <copumpkin> Axman6: yeah, but many can be fixed apparently
22:55:05 <Axman6> yeah
22:55:09 <Axman6> i hope they are too
22:55:19 <copumpkin> kmc: the supercompilation for haskell thing that ndm worked on
22:55:19 <clayjar> I'd prefer to help to make the bridge shorter between the language itself and the architecture ... if I have time that is.  But it sounds like an interesting domain to be working in.
22:55:29 <copumpkin> clayjar: why?
22:55:35 <copumpkin> I mean, why make it shorter?
22:55:46 <SubStack> cpu support for lists ^_^
22:55:58 <kmc> clayjar, the way to do that is to design chips that are more suited to lazy functional languages :)
22:56:10 * Smokey` cringes
22:56:14 <Axman6> register level lists!
22:56:17 <copumpkin> reduceron!
22:56:24 <clayjar> copumpkin, in the long run (probably within 10 years), the issue of optimization will be the hot issue again, and I'd prefer this ideal language to be at the top rather than at the bottom.
22:56:25 <Smokey`> you guys make me cry sometimes :P
22:56:52 <copumpkin> http://www.cs.york.ac.uk/fp/reduceron/
22:57:02 <Axman6> type List a = Cons (Reg# a) (Reg# a) (Reg# a) (Reg# a) (Reg# a) (Reg# a) (Reg# a) (Reg# a) (Reg# a)  (List a)
22:57:08 <Axman6> >_>
22:57:11 <copumpkin> "The Reduceron is a simple machine, and executes core Haskell almost directly. The translator from Yhc.Core to Reduceron bytecode and the FPGA machine are both implemented in Haskell, the latter using Lava."
22:57:37 <Axman6> :o
22:57:56 <Smokey`> that's not too surprising, you can do anything with an FPGA
22:58:06 <clayjar> I think parallel programming is the key in near future, and Haskell seems to be the language for it, and I think it's better to be fit like an Olympian than be a local winner.
22:58:11 <Smokey`> the real question is how much does it cost you to get your engineers to create a heavily optimized and cost effective asic out of it
22:58:12 <Axman6> FPGA make me a pony?
22:58:36 <kmc> cabal install pony
22:58:40 <Axman6> clayjar: well, there's plenty of work being done into making haskell's Parallel stuff extremely efficient
22:58:43 <psykotic> sudo make me a sandwich
22:58:47 <CalJohn> i think parallel programming probably will require some changes to haskell
22:58:50 <Axman6> no... dman it >_<
22:58:57 <psykotic> you can do anything with an FPGA if you don't care about speed
22:59:03 <Axman6> CalJohn: how so? o.O
22:59:15 <psykotic> the design parameters for FPGAs vs ASICs are totally different
22:59:30 <CalJohn> the slides from guy steele's talk at ICFP is relevant
22:59:56 <clayjar> Thanks for all your inputs, guys, it's been a pleasure conversing with you. Take care.
23:00:00 <Smokey`> clayjar: Haskell is great for parallel programming of purely indenendent scalar processors... but as soon as you hit real hardware limitations where you can't fit an instruction scheduler for every individual processor, and you start grouping scalar processors with common instruction processors and schedulers - Haskell is less suited imo
23:00:09 <Axman6> can you give any examples of what would need changing CalJohn?
23:00:13 <copumpkin> clayjar: come back soon!
23:00:14 <Smokey`> not to say haskell couldn't be well suited
23:00:20 * psykotic thinks it's telling that all the people raving about how reconfiguring FPGAs will solve everything are people with no hardware experience
23:00:46 <CalJohn> Axman6: well, guy steele has a good idea that explicitly directional folds are not so nice for parallelism
23:00:58 <psykotic> caljohn: that's an old idea, his own in fact.
23:01:07 <psykotic> read the old blelloch-steele papers from 15+ years ago
23:01:13 <Axman6> heh
23:01:14 <CalJohn> well, i am not sure so up to date, then
23:01:29 <psykotic> i'm serious though, those papers are awesome
23:01:39 <copumpkin> CalJohn: that's not a language issue though...
23:01:41 <psykotic> shows you how you can do crazy things with folds and scans if you only think a bit out of the box
23:01:52 <CalJohn> no, it's not really a language issue
23:01:55 <Axman6> psykotic: got a link?
23:01:56 <psykotic> one of my favorite examples in their papers is ray tracing on a landscape.
23:02:02 <CalJohn> but it would be nice to encode associativity in types
23:02:13 <CalJohn> i'm not sure how to do that atm
23:02:19 <copumpkin> CalJohn: well, there's already edwark's monoids package that does that and more
23:02:23 <Axman6> can't you do that already?
23:02:29 * Axman6 is probably wrong
23:02:31 <CalJohn> copumpkin: i will look at that
23:02:31 <psykotic> basically the f you pass to the scan/fold update the maximum 'horizon' angle seen so far along a given ray
23:02:35 <copumpkin> it doesn't encode the associativity in the type but you have a typeclass saying you're associative :)
23:02:52 <psykotic> it's like the classic 'wave surfing' algorithm for terrain rendering
23:03:23 <psykotic> Axman6: can't remember the names but if you look at old papers by guy blelloch with 'prefix sum' in the title, you should be good
23:03:36 <Axman6> righto
23:04:01 <psykotic> blelloch is also the guy who invented the nested data parallelism ideas that chak, peyton jones, etc have been investigating
23:04:04 <CalJohn> copumpkin: so you can say a function is associative?
23:04:31 <Axman6> psykotic: http://www.cs.cmu.edu/afs/cs.cmu.edu/project/scandal/public/papers/CMU-CS-90-190.html look right?
23:04:33 <copumpkin> CalJohn: you make your type an instance of Monoid and make mappend your binary function
23:04:44 <psykotic> Axman6: yep, that's one of the good ones
23:04:52 <Axman6> excellent
23:04:59 <copumpkin> CalJohn: you really only need semigroup but the haskell standard library doesn't have a typeclass for that
23:05:00 <Axman6> been needing something to read for a while :)
23:05:42 <psykotic> once you breathe prefix sums/scans, a good paper to blow your mind is ralf hinze's an algebra of scans
23:06:09 <psykotic> then you'll see how all the adder circuits you learn in a graduate class on computer arithmetic are trivial special cases of scan homomorphisms
23:06:15 <copumpkin> (http://www.comlab.ox.ac.uk/people/ralf.hinze/publications/MPC2004.pdf)
23:06:25 <copumpkin> thanks :)
23:06:56 <copumpkin> does he mean scans in the scanl/r sense?
23:07:13 <psykotic> yes
23:07:23 <nvoorhies> Smokey`: what limitations are you thinking of that would keep you from just taking the area and coherency hit and staying scalar + ungrouped?
23:07:24 <psykotic> the cool thing is that even scans can be parallelized
23:07:28 <psykotic> even though they seem super sequential
23:07:47 <Axman6> hmm, when i go on holidays, i should implement that DCT FFI example code to use OpenCL
23:07:48 <psykotic> unlike reduction, you can't do a simple binary split because you need all the intermediate sums
23:07:52 <copumpkin> psykotic: interesting... what kind of structure is needed for that?
23:07:57 <psykotic> read the paper :)
23:08:01 <copumpkin> fine! :P
23:08:09 * copumpkin hrrmpfs
23:08:14 <Axman6> psykotic: yeah, that does sound interesting :)
23:08:18 <psykotic> the basic idea is to recursively scan both halves but instead of just returning the scan result, you also return the fold result (i.e. last scan element)
23:08:22 <psykotic> you do the two halves in parallel
23:08:37 <copumpkin> oh yeah, I think dph does that doesn't it?
23:08:49 <psykotic> then you take the fold result from the left result and apply commutativity to map the curried operation applied to that fold result over the right scan result
23:08:58 <psykotic> right probably
23:08:59 <CalJohn> what is a scan?
23:09:05 <copumpkin> > scanl1 (+) [1,3..]
23:09:06 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
23:09:13 <copumpkin> it's like a fold but keeps the intermediate steps around
23:09:14 <CalJohn> @type scanl1
23:09:14 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
23:09:19 <psykotic> (that would be the simplest way of parallelizing scan. it has the disadvantage that, in circuit terms, it has n/2 fan-out)
23:09:22 <Axman6> @src scanl
23:09:22 <lambdabot> scanl f q ls = q : case ls of
23:09:22 <lambdabot>     []   -> []
23:09:22 <lambdabot>     x:xs -> scanl f (f q x) xs
23:10:00 <CalJohn> @type scanl
23:10:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:10:01 <copumpkin> CalJohn: you can see scanl1 f xs as map (foldl1 f) (inits xs)
23:10:05 <psykotic> it's just a version of foldr that stores off all the intermediate fold results
23:10:16 <copumpkin> CalJohn: but a lot more efficient
23:10:22 <Smokey`> nvoorhies: various parallel-oriented dsps achieve high simd lane widths by grouping many processors with the same instruction scheduler and a common cache, parallel haskell as it stands now assumes every 'thread' can run radically different functions with no performance overhead if I'm not mistaken (which is true... if each processor is completely scalar, and doesn't share scheduling and cache circuitry with any other processor, like a conventional x86
23:10:24 <copumpkin> scanr is the same thing for foldr
23:10:42 <thoughtpolice> psykotic: googling for blelloch+steele lead me to this, seems neat: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch39.html
23:10:45 <psykotic> a neat application is maximum subsum
23:11:02 <Smokey`> *archieve high scalar processor density ... by approaching processor design in a simd manner, eg: by grouping...
23:11:04 <copumpkin> zomg a thoughtpolice
23:11:08 <psykotic> once you have the prefix sums of a given array, you can easily compute all segment sums by subtracting prefix sums
23:11:11 <psykotic> etc
23:11:20 <psykotic> another cool application is nested-data-parallel quicksort
23:11:41 <psykotic> although a lot of these applications require in-place versions of these operations applied to arrays to make performance sense
23:11:43 <Smokey`> anyway I'm out of my depth here, I can really only speak for the chipsets I've had personal experience with (which isn't much, and a small portion of those I can't talk about anyway)
23:11:46 <psykotic> that's why DPH is all about special arrays
23:11:54 <copumpkin> yeah
23:12:32 <psykotic> thoughtpolice: i actually learned about all this stuff when i was at nvidia working on cuda stuff.
23:12:52 <psykotic> it was kind of neat that i could read haskell papers (like the hinze one) and make an honest claim that it was relevant to work :)
23:13:15 <Smokey`> psykotic: you worked on CUDA for nvidia? nice =)
23:13:34 <psykotic> i was working in R&D but did a bunch of cuda stuff
23:13:38 <psykotic> also plain graphics stuff
23:13:43 * Smokey` nods
23:13:54 <nvoorhies> Smokey`: Yeah.  I kinda wonder whether the loss in mem access coherency becomes a bigger factor than the area hit quickly, also.  In either case, I wonder whether it's just a fundamental problem in that a lot of the parallel computation out there likely just doesn't have much locality in either the data or code space
23:14:48 <Axman6> psykotic: got any thoughts on OpenCL?
23:14:52 <nvoorhies> Like the reasons it's nearly impossible to make a fast hardware raytracer: it's just incoherent and memory bandwidth gets big
23:14:53 <Smokey`> nvoorhies: well, i think more to the point - parallel programming architectures out there specifically target either data parallel programming... which haskell's parallel programming extensions aren't suited for :)
23:15:00 <Smokey`> Axman6: compared to CUDA, OpenCL is evil ;)
23:15:05 <Axman6> heh
23:15:10 <psykotic> Axman6: all i know is what we worked closely with them.
23:15:21 <Axman6> yeah
23:15:26 <psykotic> nvidia would rather not have to spend so much effort on software
23:15:28 <Axman6> it's based heavily on CUDA i believe
23:15:32 <psykotic> cuda was basically needed because no-one would do it first
23:15:35 <Smokey`> Axman6: having personal experience with both... OpenCL is far FAR less practical to develop production ready software for.
23:15:50 <psykotic> it's kind of like with cg
23:15:56 <psykotic> they needed to do cg because there was nothing else out there
23:16:05 <Axman6> Smokey`: assuming your [production ready software will only ever run on machines using nVidia GPU's
23:16:15 <psykotic> and then they basically gave the rights to the design to microsoft and microsoft did hlsl, which is within spitting distance of cg for that reason
23:16:31 <nvoorhies> when I read the opencl spec the only thing substantive that was different from cuda that I could find was that kernels weren't implicitly serialized by default, and there were hints for cpu implementations that you could add
23:16:33 <psykotic> i'm sure they'd be happy if it ends up being the same story with opencl
23:17:22 <Axman6> nvoorhies: i think the important difference is that it's possible to take the same source code, and compile it for CPUs, GPUs and various other chips
23:17:22 <Smokey`> Axman6: we're only targeting ATI chips with OpenCL - and we've already had to write 3 different implementations of each algorithm to target different cards... I'd hate to think what we'd be doing if we were going to support intel as well (which we might... *sighs*).  CUDA is the same, admittedly - we have 2 implementations of most kernels.
23:17:26 <psykotic> nvoorhies: yeah, it's pretty close, with cpu concessions as you said.
23:17:27 <copumpkin> is it possible to statically compile gpu code?
23:17:34 <psykotic> copumpkin: what do you mean?
23:17:38 <nvoorhies> opencl's like cuda in that it's  pretty close reflection of the current nvidia gpu architectures
23:18:03 <psykotic> there's a simulator. i know there's been work on a multi-threaded cpu simulator and apparently the perf was really good.
23:18:17 <Axman6> Smokey`: sure, but it's a new thing. wait for the GPU maunfacturers to get to a point where you do only need one kernel for any of their chips
23:18:25 <psykotic> which is not surprising. because good performance in cuda means keeping things in local shared memory, and when you run on a cpu that means it's automatically nice and coherent with cache
23:18:27 <copumpkin> psykotic: don't CUDA programs get compiled at runtime of the "host" programs? or maybe I just misunderstood, I've never actually used it
23:18:28 <nvoorhies> Axman6: yeah, it basically does that by having the cpu side of things pretend you're working with a gpu memory hierarchy though.  I bet the code you end up writing is almost exactly the same
23:18:39 <psykotic> copumpkin: right, that's true.
23:18:45 <psykotic> you compile ahead of time to bytecode
23:18:48 <Smokey`> Axman6: that's never going to happen, all architectures are different - between companies, and card generations.
23:18:50 <psykotic> but the bytecode is then compiled to hw-specific microcode
23:18:54 <copumpkin> yeah
23:18:58 <psykotic> (bytecode is called ptx)
23:19:16 <psykotic> i don't think that will change.
23:19:19 <copumpkin> so it's not possible to keep the actual raw program that the GPU will run on disk somewhere?
23:19:25 <psykotic> the microcode is way too hw specific
23:19:28 <copumpkin> I see
23:19:33 <psykotic> it's a whole can of worms
23:19:37 <Axman6> Smokey`: i thought the point of OpenCL was that it abstracted away those differences, and left the compiler to produce the right code when it reaches the machine
23:19:42 <copumpkin> what kind of latency does the runtime compilation introduce?
23:19:51 <psykotic> you have the same situation with hlsl assembly vs hw-specific microcode in dx
23:19:52 <Smokey`> Axman6: nVidia you have different hardware capabilities, and memory subsystems, and with GT300 scheduling systems - with ATI you have different caching capabilities, scheduling strategies, and thread grouping mechanisms between cards...  I don't see this changing, each hardware iteration is an attempt to improve the architecture, inherently changing it.
23:19:52 <copumpkin> I guess it's a one-off cost
23:20:06 <psykotic> copumpkin: you run cuda for heavy computations, so it's negligible :)
23:20:12 <copumpkin> yeah :)
23:20:14 <psykotic> there's way more overhead in general driver bookkeeping
23:20:21 <Smokey`> Axman6: sort of... but you still have to take into account physical restrictions and speed differences between different language features on each card.
23:20:33 <Smokey`> Axman6: OpenCL is no different from CUDA in that sense...
23:20:35 <copumpkin> psykotic: maybe we'll get matrix zippers on the GPU! ;)
23:20:36 <Axman6> i guess
23:20:46 <stanv> hello, is it possible to write definition fakeEq:: Int -> Int -> Boo; fakeEq x x = True fakeEq _ _ = False  ???
23:20:56 <Axman6> Smokey`: no
23:20:57 <copumpkin> stanv: nope
23:21:00 <nvoorhies> not to mention the bug fixes that go in each gpu
23:21:01 <Axman6> ih, stanv*
23:21:15 <copumpkin> stanv: that kind of pattern has a name that I can't remember right now
23:21:25 <psykotic> overlapping
23:21:30 * Axman6 likes that things like f x x work in erlang
23:21:31 <copumpkin> there was some other name too
23:21:35 <psykotic> i keep making the mistake of writing that, because it's so mathematically natural
23:21:38 <copumpkin> haskell supports it for type functions, but not value functions
23:21:53 <copumpkin> or I should say haskell + ghc extensions :P
23:21:59 <Smokey`> Axman6: ultimately speaking though, you can write a 'single' kernel which runs 'okay' on all platforms... but when you're pushing for every last microsecond of performance out of individual cards, that's not feasible.
23:22:19 <Axman6> Smokey`: well yeah, i don't think that's ever going to change either
23:22:34 <psykotic> anyway, worse than opencl is directx 11 compute shaders
23:22:40 <Axman6> if you want the best speed from some hardware, you have to code with the specifics of the hardware in mind
23:22:48 <psykotic> there's so much standard microsoft bells and whistles that only get in the way
23:22:50 <stanv> :( no way ?
23:22:52 <Smokey`> DX isn't even an option for any company I've worked for anyway, heh
23:22:59 <psykotic> like they decided to superimpose some weird kind of type system on top of everything
23:23:00 <Axman6> stanv: no way
23:23:17 <psykotic> it's kind of like going from C to pascal
23:23:20 <psykotic> in the bad way
23:23:22 <nvoorhies> psykotic: hahaha, that sounds like it would get hideous fast
23:23:22 <copumpkin> psykotic: but type systems are beautiful! I want higher kinds in my GPU
23:23:41 <copumpkin> :P
23:23:41 * Axman6 likes Ada a lot, and it's very pascal like, so doesn't know how to take that
23:23:56 <psykotic> Axman6: basically the architecture requires low level thinking.
23:24:07 <psykotic> you might not like that, but it's kind of silly to pretend otherwise but slapping some pseudo-type system on top
23:24:20 <copumpkin> like gpugen or a DPH frontend? :P
23:24:22 <psykotic> the solution is a higher level language, not some fucked up add on to a low level language
23:24:26 <copumpkin> ah, ok :)
23:24:36 <Smokey`> psykotic++ :)
23:25:03 <nvoorhies> psykotic: when were you at nvidia?
23:25:45 <psykotic> nvoorhies: oh, you are THE voorhies :)
23:25:57 <psykotic> i was in ashu's group
23:26:00 <nvoorhies> nah, the other one
23:26:06 <psykotic> 2 years, until a few months ago
23:26:21 * Smokey` wonders who stole psykotic's talent
23:26:27 <nvoorhies> ah, cool, I was there from 2004-2008
23:26:58 <psykotic> architecture?
23:27:21 <nvoorhies> yeah, working on the front end for the last half of that, more or less
23:27:48 <psykotic> some of the older architecture guys crack me up
23:27:57 <psykotic> i had to deal a bunch with john nicholls and danskin
23:28:02 <nvoorhies> so you probably had to deal with ugly header files my software generated
23:28:57 <psykotic> Smokey`:  are you saying i'm talentless now?
23:29:01 <psykotic> Smokey`: long time, no see, btw.
23:29:08 <nvoorhies> nicholls was always kinda bitter that nvidia was realtively oblivious to the kinda problems CPUs run into and it always felt like he was worried we were runnign full tilt into a wall
23:29:12 <Smokey`> psykotic: no, I'm wondering who plucked you from nVidia :P
23:29:24 <psykotic> oh, i decided to quit and go traveling for a year
23:29:31 <Smokey`> psykotic: very long time... though I've been idling here in #Haskell for 3 years now :P
23:29:34 <psykotic> after the financials went down hill, it wasn't very fun
23:29:41 <psykotic> company changed completely
23:29:50 <Smokey`> psykotic: oh, that's no good :(
23:29:59 <zbrown> Is there a way to determine which type constructor created a particular type bound to a name?
23:30:22 <nvoorhies> psykotic: awesome.  I've been travelling and learning haskell and various other stuff for the last year
23:30:23 <psykotic> zbrown: an early phase of the compiler eliminates type synonyms, unfortunately.
23:30:30 <psykotic> if that's what you mean
23:30:35 <zbrown> psykotic: hmmm ok
23:30:37 <ivanm> zbrown: create a pattern matching function?
23:30:38 <copumpkin> zbrown: you can write a type function for it
23:30:56 <copumpkin> zbrown: but you need to write out the types individually
23:30:58 <ivanm> e.g. isFoo Foo{} = True; isFoo Bar{} = False; isFoo Baz{} = False
23:31:02 <ivanm> it's rather hacky though
23:31:07 <zbrown> ivanm: that seems to be a good idea howeer it occurs to me that I may be attacking my problem incorrectly
23:31:09 <copumpkin> ivanm: I think he's asking for the type level
23:31:11 <copumpkin> oh
23:31:15 <ivanm> (well, you can simplify it by having isFoo _ = False ... )
23:31:21 <ivanm> copumpkin: :D
23:31:52 <copumpkin> zbrown: type level or value level? :P
23:32:07 <zbrown> ummm value level I suspect
23:32:10 <copumpkin> oh ok
23:32:19 <zbrown> its a value thats already cretaed and I wanted to know what constructor made it
23:32:25 <copumpkin> you said type constructor so I was confused :)
23:32:32 <zbrown> however I think I'm thinking about the problem the wrong way in order to solve it in Haskell
23:33:39 <psykotic> nvoorhies: that's cool. it's good to get the nose away from the grindstone every once in a while and recalibrate your perspective.
23:34:33 <psykotic> nvoorhies: i was working on kepler and there was only two modes, 'let's relax and throw ideas around' and 'holy fuck, we have to cut scope and ship now', it wasn't very conducive to lateral design thinking.
23:35:27 <nvoorhies> yeah, I can't remember a time when it wasn't like that though.
23:35:31 <psykotic> hehe
23:35:35 <psykotic> that's what you get with 6 month product cycles
23:35:51 <psykotic> otoh i liked it more than the game industry in terms of product cycles
23:36:19 <psykotic> the payoff in games was bigger but so were 2+ years of hard-ass work to ship something
23:36:56 <nvoorhies> There were a bunch of cool things for the front end that got cut because it needed to keep around some data and there wasn't room for a couple registers or whatever, and then some other requirement forces the registers to go in anyways, but there was no time to put cool feature X back in even if it'd make peoples lives much nicer.
23:37:01 <psykotic> it's funny how even at a huge company like nvidia, there are a few people that make everything come together, though
23:37:12 <psykotic> in this case sean treichler and dan wexler, who were like machines
23:37:13 <Smokey`> 'product cycles', 'deadlines', 'ship now'? ;)  I'm pretty lucky where I am, R&D programmer, slow but steady progress is enough to keep the higher powers happy...
23:37:28 <nvoorhies> Sean's almost frightening
23:38:18 <nvoorhies> I think Architecture had a somewhat slower cycle, sorta/kinda.  It'd be more like 2-3 years, with the first 4 months being cool ideas and coding and the rest testing the living hell out of the thing, basically
23:38:26 <nvoorhies> with breaks from the testing to put out fires
23:38:45 <Axman6> sounds fun
23:38:51 <psykotic> because i was in devtech, i was doing the longer term stuff involving architecture but also had shorter term firefighting that resonated with the 6 month cycle, so it mixed things up
23:39:14 <nvoorhies> It was kinda neat if you were interested in seeing people do formal verification type work
23:39:15 * copumpkin hates c++, he added a perfectly innocent instance var to this huge class he inherited, added one line to a function to update that var, and now the program crashes
23:39:38 <psykotic> nvoorhies: i never saw any of that unfortunately. i tried to suck up as much hardware knowledge while i was there, and that was probably my biggest takeaway from the experience there.
23:40:12 <okie> psykotic: what kinds of things do you think people raving about fpgas don't understand about hardware?
23:40:21 <psykotic> okie: that they think hardware means fast.
23:40:31 <psykotic> it's a ridiculous notion.
23:40:56 <psykotic> building special hardware doesn't necessarily make things faster, especially when you consider economies of scale for general purpose chips
23:41:02 <nvoorhies> Most of the real formal stuff happens in verilog-space, since there's no undefined behavior in the language when coupled with a platform + tools and such.  But the c++-ey stuff had touches of it
23:41:16 <psykotic> gpus are kind of extreme and that's because of domain specific features, not because 'it's hardware'
23:41:27 <nvoorhies> I think a lot of people don't realize how hot and slow and inefficient fpgas are
23:41:31 <psykotic> yeah.
23:41:46 <psykotic> especially when they try to do things on an fpga that you can do almost as well in terms of utilization with a normal cpu
23:42:02 <psykotic> and then you have to seriously exploit the way fpgas are physically organized to get any kind of decent utilization
23:42:10 <psykotic> so it's not a case of 'porting' to an asic as some seem to think
23:42:27 <okie> when i think about fpga's, i think about the possibilities of creating better dataflow shapes for algorithms
23:42:46 <psykotic> the dataflow shape has to fit the fpga's physical layout to get really good utilization
23:42:58 <psykotic> they have a very specific structure
23:43:04 <nvoorhies> yeah.  There's good reasons that hardware emulation machines have been switching to lots of little ASIC processors and simulating circuits in software in parallel
23:43:35 <psykotic> nvoorhies: i did like those huge fpga sim machines arch has
23:43:51 <nvoorhies> those tings are monsters
23:44:30 <psykotic> okie: the serious proposals for reconfigurable fpga-based computing has 'computation tiles' that are shaped specifically based on fpga capabilities.
23:44:46 <psykotic> okie: that's nice if you have algorithms that can fit it but it's like a demented structural circuit layout language, almost.
23:45:11 <psykotic> as in, it's probably easier to just lay out gates directly if that's what you're doing.
23:45:54 <psykotic> i still haven't seen any of those proposals materialize into impressive real world applications
23:46:03 <psykotic> and fpgas have been around for a damn long time now
23:46:31 <nvoorhies> there's a line where you have the time to twist things to match the dataflow shape of an fpga and engough parallelism to make it a win over just doing things in software on a fast cpu, but it's waaaay more work than most people would assume
23:46:37 <psykotic> yeah
23:46:48 <psykotic> i see some people have success with dsp-like applications
23:46:55 <psykotic> where you can slightly win over off the shelf dsps
23:47:21 <nvoorhies> You have a definite advantage if you're someone like cisco that can bend the arm of a fpga manufacturer to make the fpga structure really well suited to the kind of things you want to do
23:47:27 <psykotic> but the upfront design investment is way higher than with a dsp, so it only makes sense when you have economies of scale there for that specific product
23:47:30 <psykotic> right
23:47:57 <psykotic> fpgas are ridiculous for anything resembling general purpose cpu work though
23:48:10 <psykotic> when i see people synth cpu code and run it on an fpga, i want to hit them
23:48:11 <nvoorhies> so it ends up being a niche where you're low-volume, but high price, but high parallelism
23:49:02 <psykotic> regarding fpga -> asic shift, i remember talking to the physx guys when we bought them
23:49:14 <nvoorhies> I wish it wasn't like that though.  Being able to roll your own asic equivalent for any task would be super cool
23:49:15 <psykotic> they apparently tried to prototype on an fpga and of course that basically turned out to be useless
23:49:19 <psykotic> it would be!
23:49:28 <psykotic> and that's why the meme that fpgas will fix everything is so immortal
23:49:51 <dons> these guys are doing dsp and crypto on fpgas, with a haskell toolchain, http://www.signalicorp.com/
23:49:53 <nvoorhies> Yeah, it's up there with ray tracing taking over graphics or lisp being the end all of languages
23:50:09 <psykotic> dons: crypto and dsp are two of the possible sweet spots for fpgas, yeah
23:50:31 <psykotic> they are super specific in their requirements, though
23:50:43 <copumpkin> you wouldn't want to do asymmetric crypto with them would you?
23:50:45 <Smokey`> as naive as this sounds, I maintain ray tracing will take over the graphics industry :P
23:50:53 <Smokey`> I've been saying that for years though...
23:50:58 <dons> copumpkin: prob. not.
23:51:02 <nvoorhies> I wonder how much of a feedback loop they get with fpgas being good at crypto -> crypto algorithms mapping well to fpgas -> rinse, repeat
23:51:06 <copumpkin> Smokey`: don't worry, "will" is quite flexible ;)
23:51:13 <okie> nvoorhies: what is it about these things that grab onto people? for all of them, it's often the brightest people who believe in them
23:51:18 <copumpkin> Smokey`: nobody will ever be able to prove you wrong :)
23:51:56 <psykotic> the daniel pohl guy from intel is hilarious
23:52:13 <nvoorhies> okie: I think it's generally a theme where there's one or two problems that keep this nice elegant solution from being what people "really use".
23:52:17 <psykotic> i went to his gdc talk 2 years ago, it was so awful that you thought it was parody
23:52:57 <psykotic> his whole scanline vs ray tracing comparison was predicated on the idea that with scanline rendering you would have quality vs performance compromises but with ray tracing you would always do it 'the right way'
23:53:10 <psykotic> i think that pretty much branded him as an irrelevant academic to everyone in the room
23:53:14 <nvoorhies> okie: so if you've got the some mix of optimism and naivete, you think that the barrier will fall down once someone figures out the missing piece.  And if you're cynical you think it's never going to happen
23:53:36 <okie> nvoorhies: i think the ray tracing thing may be of a different nature than the reconfigurable computing and lisp thing
23:53:53 <psykotic> ray tracing is great for some things
23:54:03 <psykotic> but if you ever do primary rays with ray tracing then you are an idiot
23:54:04 <nvoorhies> Yeah, I wouldn't doubt it.  There's some common threads in there though, I think
23:54:30 <psykotic> basically cycles will always be at a premium
23:54:37 <psykotic> i don't think that's going to change in the foreseeable future
23:54:37 <Smokey`> psykotic: we use ray racing for primary rays at work, over rasterization :P
23:54:48 <psykotic> Smokey`: for real time work?
23:54:51 <Smokey`> psykotic: but only because it was simpler to write a ray traciner in CUDA, than a rasterizer.
23:54:54 <Smokey`> psykotic: yes.
23:54:56 <psykotic> haha
23:54:58 <psykotic> okay fair enough
23:55:12 <psykotic> simon green wrote this cool stochastic rasterizer a few years ago, it's probably in the sdk
23:55:17 <Smokey`> OpenGL<->CUDA interop was killing us, and we only render a ~500poly mesh (texturing only, no lighting) at 320x240-640x480, so ray tracing was the easiest solution
23:55:26 <nvoorhies> yikes
23:55:29 <psykotic> so you get motion blur by stochastically sampling along the trajectory
23:55:38 <psykotic> not very useful but neat
23:55:46 <okie> i think that the fpgas and lisp thing may exist because of their ability to embody more levels of abstraction
23:55:50 <Smokey`> actually OpenGL and CUDA together, in general, is death...
23:56:00 <psykotic> dx interop is worse, dude
23:56:00 <Smokey`> context switches, weird performance irregularities, and again, interop... ugh
23:56:04 <psykotic> as far as i know it still isn't fixed
23:56:09 <Smokey`> no, it's not.
23:56:15 <Smokey`> hence we went for ray tracing in cuda :P
23:56:19 <psykotic> dx10 interop only came in about a year ago
23:56:21 <nvoorhies> okie: yeah, abstraction is a big portion of what goes into making a solution elegant and "beautiful", at least to me
23:56:57 <psykotic> simplicity and so on aren't that relevant in what drives gaming graphics
23:57:08 <psykotic> especially now that programming is a smaller and smaller part of the total effort of making a game
23:57:11 * dons has a broken brain. always writes 'performance' when he means to write 'perform'
23:57:19 <psykotic> if you can whip your engine programmers into assembly programming everything, if need be, they'll do it
23:57:21 <psykotic> it makes business sense
23:57:46 <nvoorhies> OpenGL and CUDA interop being crappy is really a travesty though
23:57:49 <psykotic> yup
23:57:54 <psykotic> part of the problem is now the software/driver layer
23:58:02 <psykotic> it's the way context switching between compute and graphics is in the g80 arch
23:58:08 <Smokey`> nvoorhies: it is... I'm still not sure what internal barrier there is stopping CUDA from directly accessing OpenGL's buffers...
23:58:11 <psykotic> with fermi they're supposed to have something finer grained
23:59:11 <Smokey`> I mean, how hard is it to pass us a memory address, seriously?
23:59:35 <psykotic> it has to do with the way framebuffer is laid out
23:59:38 <nvoorhies> Smokey`: there's problems in that a lot of the GL state is reused by CUDA, so you can't have both in the pipeline simultaneously or they'll stomp on eachothers registers, potentially
23:59:39 <psykotic> it's insanely complicated
