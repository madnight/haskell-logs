00:00:24 <ray> i'm sure it's a visible wall really
00:00:28 <ray> or something
00:00:38 <blackdog> kmc: in C-land, "implementation-defined" means "monkeys may fly out of any orifice"
00:00:38 <kmc> you could write a fully spec-conforming C implementation that transforms to CPS and heap-allocates closures
00:01:06 <kmc> err, activation frames
00:01:06 <|Steve|> kmc: And that would be the implementation.
00:01:12 <kmc> |Steve|, but it has no stack
00:01:12 <|Steve|> Hence, implementation-defined.
00:01:14 <kmc> notional or actual
00:01:14 <eoeas> ray: true, choosing the right tutorial, motivation
00:01:28 <kmc> in that case there is nothing either in the C language or in the implementation that is a stack
00:01:33 <|Steve|> I didn't mean the stack was implementation defined. I meant function calls, local variables, etc.
00:01:46 <pikhq> "Function calls" do not exist in assembly.
00:01:49 <kmc> sure, but that's not what pikhq meant i'd guess
00:01:52 <pikhq> Nor do "local variables".
00:01:57 <|Steve|> jump and link?
00:02:12 <|Steve|> Or in x86, call.
00:02:23 <nvoorhies> shhhh
00:02:25 <pikhq> You have the ability to push and pop from a stack and the ability to read and write to things on that stack.
00:03:11 <mle> |Steve|: enter, on 286+, heh
00:03:12 <kmc> the single C construct "function call" is implemented by various bits of assembly besides the "call" instruction
00:03:28 <kmc> mle, i haven't seen gcc generate enter on x86, and i don't know why
00:03:30 <|Steve|> mle: enter and leave are for manipulating the frame pointer, not for making function calls.
00:03:31 <kmc> it does generate leave sometimes
00:03:50 <mle> kmc: because gcc uses a different ABI generally
00:03:56 <mle> and enter is Slow traditionally
00:04:00 <kmc> you'd have a better case on some risc architectures where register windowing is also part of the call instruction
00:04:08 <|Steve|> If you compile with -fomit-framepointer, then gcc won't use enter/leave and it leave %ebp free to use as another register.
00:04:44 <kmc> mle, the instruction is slow so compilers don't use it so intel doesn't optimize it so the instruction is slow :)
00:04:47 <mle> yeah, but debugging is rather awful without that frame pointer.
00:04:59 <kmc> solution: write code that is bug-free the first time
00:05:00 <|Steve|> Yes, yes it is.
00:05:18 <mle> kmc: sure, but some of us are paid to debug /other/ people's code.
00:05:32 <kmc> that sounds terrible
00:05:45 <|Steve|> But enter is basically push %ebp; movl %esp,%ebp; and then a subtract of the stack pointer for local variable space (usually).
00:06:08 <ksf> well, my experience shows that you can tredemously save time by just re-writing all their code.
00:06:22 <|Steve|> leave is basically movl %ebp,%esp; pop %ebp.
00:06:36 <|Steve|> Hey, I get paid to disassemble people's code.
00:06:41 <Quadre_> Here is my question for you guys. And no, I am not trying to troll or flame by asking this. What is the advantage of always writing in a purely functional paradigm?
00:06:53 <kmc> Quadre_, equational reasoning
00:07:00 <|Steve|> Quadre_: It's kinda fun.
00:07:08 <ksf> most stuff is functional anyway, so it makes no sense to introduce side-effects.
00:07:11 <Quadre_> |Steve|: That doesn't count.
00:07:19 <kmc> if you have somewhere a definition of "f = g", then anywhere you see f, you can mentally substitute g when thinking about the program
00:07:21 <mle> it may not count, but it's true
00:07:35 <kmc> without worrying about duplicating or eliminating side effects
00:07:42 <Quadre_> mle: It can be fun when you're doing little things I guess.
00:07:48 <ksf> most of the remaining stuff is nearly-pure, that is side-effects are completely local (as in: don't use global variables)
00:07:53 <kmc> Quadre_, i don't agree that one should "always" write in a pure functional style
00:08:01 <kmc> i think haskell has good tools for dealing with impure things
00:08:07 <ksf> for the rest, there's the IO Monad.
00:08:42 <|Steve|> Quadre_: I'm still trying to work out how to do things like dynamic programming well in Haskell.
00:08:56 <kmc> |Steve|, a lazy array?
00:08:59 <eoeas> Could it be that a 686 CPU uses more processing power to run a 386 compiled binary than a 686 optized binary ??
00:09:03 <pikhq> Quadre_: Writing things in a pure functional style makes it much easier to think about the program.
00:09:13 <Quadre_> pikhq: Does it?
00:09:18 <kmc> eoeas, that's not expected?
00:09:42 <ksf> Quadre_, after a short while of acustoming, definitely.
00:09:50 <eoeas> kmc: is that a question?
00:09:51 <pikhq> Yes. You don't have to worry about some other chunk of code doing anything other than what it evaluates to.
00:09:52 <|Steve|> kmc: That's what I was thinking. I tried a bunch of changes to the array using //, but that was slow. I tried using STArray, but even that seems slow to.
00:10:17 <ksf> ...pure functional code doesn't require you to keep as much state in mind as sequential code.
00:10:22 <pikhq> You can call some function f and, without knowing what it does *at all*, you know it can only evaluate to some value.
00:10:26 <kmc> eoeas, i would expect that the 686-optimized code runs faster than the 386 code that's less specialized
00:10:38 <BMeph> kmc: Is that a vicious instruction cycle? ;p
00:10:42 <kmc> isn't that the point of the optimizations?
00:11:03 <badsheepy> i sortof think people think statefully until trained not to :o
00:11:22 <pikhq> badsheepy: True, but once trained not to, it's much easier to actually think about things.
00:11:49 <badsheepy> perhaps
00:12:00 <kmc> Quadre_, there are also important, uncommon features in Haskell not related to the lack of side effects
00:12:00 <Quadrescence> My problem is: most computers have state as their foundation.
00:12:10 <kmc> not sure what your background etc. is, but it's worth pointing out
00:12:24 <ksf> ...you "only" have to care about whether the types match up, not whether you've incremented some variable at some point.
00:12:45 <pikhq> Yes, and almost all programming languages are at least trying to make it so you don't actually think about the computer you have in front of you.
00:12:46 <kmc> ksf, well, the function can still be incorrect even if the types match
00:13:07 <blackdog> |Steve|: i did a quick dynamic programming exercise for the euler competition
00:13:09 <blackdog> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3529#a3529
00:13:09 <pikhq> Instead, you think about some imaginary machine that is nicer to work with that, oh, by the way, the computer in front of you can pretend to be.
00:13:16 <blackdog> worked out quite nicely
00:13:31 <ksf> ...that's the reason for the quotes. of course there's a difference between toUpper and toLower, but such things tend to be easier to spot than your usual imperative cause of a but.
00:13:33 <eoeas> kmc: It's just that i'm running mainly 386 binaries (ubuntu) on Intel Core Duo 2Ghz , but things seem slow :-/
00:13:34 <ksf> *bug
00:13:51 <Nereid_> eoeas: that wouldn't be the cause of the slowness
00:14:03 <Quadrescence> pikhq: And what do you suppose the advantages and disadvantages are to this?
00:14:19 <dibblego> Quadrescence, in C, both f and g are pure functions -- which is called first in this code: function(f(x), g(y));
00:14:20 <ksf> Quadrescence, do you tend to code in assembly?
00:14:23 <|Steve|> Heh, Collatz?
00:14:24 <eoeas> Nereid_: Thought so, just wanna rule out the odds
00:14:26 <ksf> opcodes? binary instructions?
00:14:35 <Quadrescence> ksf: No.
00:14:36 <kmc> eoeas, it will make a bit of a difference but i'd look elsewhere first
00:14:48 <blackdog> |Steve|: yeah. trivial, i know, but it's an interesting contrast to the C version
00:14:54 <ksf> ...because it's nice to work with an imaginary machine, instead of manually flipping bits.
00:14:55 <kmc> in the end most user-perceptible system slowness is not for CPU-bound reasons
00:15:17 <Quadrescence> dibblego: Depends on the machine.
00:15:22 <Nereid> whoops! laptop battery died
00:15:31 <Quadrescence> dibblego: Compiler, etc.
00:15:36 <dibblego> Quadrescence, more importantly, does it matter?
00:15:53 <Quadrescence> dibblego: If they're pure, no.
00:16:08 <johnfn> hi guys, total haskell noob here. im trying to compile a basic hello world program. i have test.hs with the contents "module Main where main = putStrLn "Hello world", but when i go ghc -O test.hs, nothing shows up. why might this be?
00:16:08 <dibblego> Quadrescence, so there you have it, the advantage
00:16:18 <Quadrescence> dibblego: If it doesn't matter, why is it an advantage?
00:16:24 <ksf> johnfn, ghc --make test.hs
00:16:25 <dibblego> johnfn, run ./a.out
00:16:26 <Quadrescence> The C compiler could choose any it wants.
00:16:34 <Quadrescence> Or both.
00:16:43 <dibblego> Quadrescence, because you, the programmer, needn't concern yourself with that fact as you read that code
00:16:55 <dibblego> no it can't, the C compiler doesn't know if f and g are pure
00:17:04 <dibblego> unless you have an effect system, in which case, it is not C, it's Haskell
00:17:05 <Quadrescence> dibblego: Why can't a C compiler know that?
00:17:19 <|Steve|> Which is faster: sequence_ [f n | n<-[a..b]] or making f recursive and stopping once it hits b?
00:17:23 <johnfn> aha, making it into an exe and then running that works, thanks
00:17:27 <Quadrescence> I think if a human could perceive it, so could a machine.
00:17:28 <dibblego> it might for certain values of f and g, but not for any
00:17:36 <|Steve|> Using DFA, a compiler can tell if some things are pure.
00:17:43 <ksf> Quadrescence, figuring that out from C code is undecidable, in the general case.
00:17:47 <dibblego> Quadrescence, that's the point, a human tries and fails all the time -- it's non-trivial
00:17:50 <|Steve|> gcc has an extension that let's you declare a function to be pure.
00:17:52 <ksf> ...in the more common case, takes half an eternity.
00:17:52 <pikhq> Quadrescence: The advantages? You don't think in assembly. The disadvantages? You can't change each and every single instruction.
00:18:15 <Quadrescence> Fortran has explicit PURE declarations
00:18:18 <Quadrescence> as well as ELEMENTAL.
00:18:29 <Quadrescence> (which means it can be applied to arrays as well)
00:18:31 <pikhq> Instead, you write a program for something else and it works without you thinking about silly stuff like managing your stack frames and register allocation.
00:18:36 <kmc> Quadrescence, how much successful software is written in assembly
00:18:48 <ksf> transport tycoon.
00:18:49 <Quadrescence> kmc: Presumably a lot.
00:18:58 <ksf> ...and it's a darn fine program, modulo the pathfinder.
00:19:11 <dibblego> Quadrescence, yes, but while the compiler does not enforce it, then you haven't gained anything in readability
00:19:14 <Nereid> isn't purity necessary for lazy evaulation to make sense?
00:19:15 <pikhq> Quadrescence: Hardly any software in the past... Two, three decades? has been written in pure assembly.
00:19:18 <|Steve|> (Actually, gcc as two different ones depending on if it touches global memory or not.)
00:19:21 <ksf> Nereid, yes.
00:19:26 <kmc> Quadrescence, how do you presume that?
00:19:33 <Nereid> well there's another reason for you
00:19:40 <arw_> kmc: lots of embedded software, and embedded stuff makes up 95% of the cpus sold...
00:19:42 <ksf> ...that's also the historical accident that made haskell take no compromises wrt. purity
00:19:55 <|Steve|> Heh, for my last paper, I had to invent an assembly language and then write an exploit in it.
00:19:55 <Quadrescence> kmc: Console games, embedded stuff, compiler writing, minuetOS
00:20:03 <Nereid> ksf: accident?
00:20:16 <kmc> menuetOS?
00:20:19 <pikhq> Quadrescence: Wrong on two accounts, semi-wrong on a third.
00:20:20 <Quadrescence> Yes
00:20:23 <kmc> that's sort of weak
00:20:25 <Quadrescence> pikhq: No, not wrong.
00:20:30 <ksf> well as I heard people were tempted to abandon purity quite a lot times, for dirty IO reasons.
00:20:36 <kmc> Quadrescence, console games haven't been written in assembly for perhaps 15 years
00:20:42 <pikhq> kmc: Longer.
00:20:47 <ksf> having decided on sticking to laziness, though, they had to stay pure.
00:20:50 <Quadrescence> kmc: Okay, did we put a time frame on this?
00:20:53 <|Steve|> Uh, even embedded stuff from decades ago are compiled for the most part.
00:21:02 <ksf> there's a fun paper about haskell's history
00:21:07 <kmc> sorry, i meant currently written
00:21:09 <kmc> that was unclear
00:21:12 <pikhq> Console games these days are written in C, C++, and sometimes even C#.
00:21:20 <kmc> as in, now that we have these fancy languages, should we throw them away
00:21:40 <pikhq> Embedded stuff is only written in assembly if by "embedded" you mean "microcontroller" -- and even then, C works decently.
00:21:43 <Quadrescence> Okay, currently written. None in assembly, no. There's a reason C was invented.
00:21:53 <kmc> pikhq, i write AVR code in C++ :)
00:22:08 <ksf> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/  that's the one.
00:22:14 <pikhq> And compiler writing? Hardly anything other than the final code generator even knows what assembly *is*.
00:22:23 <pikhq> Much less "is written in it".
00:22:24 <ksf> "embedded" stuff even gets written in java.
00:22:25 <Quadrescence> pikhq: Of course.
00:22:27 <kmc> and it's best to leave code generation to someone else unless you are a masochist
00:22:41 <ksf> doing j2me I cursed sun for inventing that beast, but then, it worked.
00:22:59 <pikhq> ksf: Because of things like microcontrollers that implement the JVM... Crazy stuff.
00:23:09 <ksf> well, handsets.
00:23:11 <Nereid> crazy indeed
00:23:21 <BMeph> So, doesn't anyone want to discuss, oh, I don't know,... Haskell? ;)
00:23:26 <Nereid> ksf: thanks
00:23:29 <Quadrescence> But, I don't even know why we are talking about ASM. Being impure doesn't mean ASM.
00:23:34 <ksf> arms even have limited hardware support for implementing jvms.
00:23:50 <pikhq> Quadrescence: Because you said "computers are based in state".
00:23:57 <Quadrescence> pikhq: Indeed.
00:23:58 <kmc> Quadrescence, you were asking what the advantages and disadvantages of abstracting the bare machine were
00:24:07 <pikhq> ... And the fact is, *nobody cares about what computers actually do these days*.
00:24:12 <ksf> Quadrescence, being pure doesn't mean that you can't do state.
00:24:19 <Quadrescence> pikhq: Certainly many care!
00:24:31 <Quadrescence> pikhq: People just don't care about writing the ASM by hand.
00:24:53 <|Steve|> pikhq: There are some computer architects in my office who might disagree. =)
00:25:02 <pikhq> ... In not writing assembly by hand, they cease to care what computers actually do.
00:25:10 <Quadrescence> pikhq: No.
00:25:11 <pikhq> |Steve|: ... I should specify. *Programmers* don't care.
00:25:28 <Quadrescence> pikhq: Using C as an example. You can have a pretty good idea what the machine will do with C code.
00:25:36 <pikhq> Quadrescence: You care about a specific instance of the hypothetical C machine.
00:25:48 <Quadrescence> pikhq: Which is nearly isomorphic to my machine
00:25:56 <|Steve|> That's not really very true either. The Apple performance-optimization mailing list is full of people who care about what the computer is doing.
00:25:57 <pikhq> Generally, that instance for which sizeof(int) = 4, sizeof(void*) = 4, and char is 8 bytes.
00:26:02 <sjanssen> what's this discussion even about?  Is it on topic?
00:26:02 <ksf> c forces you to use a certain stack layout.
00:26:09 <Quadrescence> ksf: That is incorrect
00:26:12 <dibblego> Quadrescence, I just gave you a very simple example where that was not true
00:26:16 <Quadrescence> ksf: a C stack isn't even required.
00:26:24 <pikhq> sjanssen: How abstraction makes it easiewr to think about programs.
00:26:28 <eevar2> back on topic ;) -- can I run haskell on the JVM? ;)
00:26:32 <pikhq> sjanssen: Specifically, pure functional programming.
00:26:40 <|Steve|> pikhq: char can't be 8 bytes in C.
00:26:42 <ksf> ...if you completely cease to use functions, maybe.
00:26:49 <pikhq> |Steve|: s/bytes/bits/
00:26:58 <sjanssen> eevar2: there have been efforts, but I don't think there are any truly finished ones
00:26:58 <|Steve|> You have 1 = sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long).
00:26:59 <|Steve|> Ah.
00:27:00 <pikhq> And char can well be 8 bytes. It just can't be sizeof(char) = 8.
00:27:08 <BMeph> eevar2: The answer is: Yes! Haskell can do that!
00:27:14 <pikhq> sizeof does not necessarily result in a number of bytes. :P
00:27:25 <pikhq> sjanssen: It got here because Quadrescence claimed that "computers are based in state".
00:27:52 <pikhq> And so we started discussing how programmers no longer even care about what computers do for the most part.
00:28:32 <hackagebot> vhdl 0.1.1 - VHDL AST and pretty printer (ChristiaanBaaij)
00:29:04 * ksf only cares about assembly when it's a tight loop
00:29:08 <BMeph> pikhq: To be pedantic: We care about what they do, but almost no one cares precisely how it's done. :)
00:29:22 <pikhq> BMeph: ... Well, yes.
00:29:36 <Martijn_> Yay for abstraction!
00:29:39 <pikhq> ksf: And even that's more caring than most give these days.
00:29:42 <BMeph> Anyway, back to this "Haskell" thing... :)
00:29:53 <kmc> i had a haskell question
00:29:58 <kmc> and it's a maths question too!
00:29:59 <BMeph> Yay!
00:30:08 <kmc> so, Hask is a category
00:30:13 <pikhq> We're in the age of people using high-level languages compiled to a VM which is itself implemented in a high-level language. :)
00:30:14 * BMeph nods
00:30:15 <kmc> the objects are Haskell types
00:30:24 <kmc> and the morphisms are *values* of  function type?
00:30:28 <kmc> or function types themselves?
00:31:03 <ksf> pikhq, which is presumably because most coders don't even come close to the point where optimizing a tight loop would make an observalbe difference. you wouldn't believe the big O's I've seen in other peoples code.
00:31:23 <pikhq> ksf: Quite.
00:31:32 <ksf> ...or, put differently, I don't want to add to your pain.
00:31:33 <pikhq> O(n!!n) anywhere?
00:31:34 <dolio> Morphisms are functions.
00:31:38 <Nereid> kmc: values
00:31:42 <kmc> cool
00:32:03 <ksf> I've seen O(infinity), based on the properties of the system's randgen.
00:32:09 <pikhq> o.O
00:32:11 <kmc> so i had this vague notion that types are "higher level" than values, but i am now revising this
00:32:17 <kmc> values prove types, and values are morphisms on types
00:32:24 <|Steve|> That's a vacuous statement, by the way.
00:32:26 <kmc> so it seems more that values are about types than types are about values
00:32:31 <poe> Types are functions' domains
00:32:51 <ksf> ...generating maps, tossing those away where certain properties don't hold.
00:33:06 <Quadrescence> poe: And codomains
00:33:21 <ksf> as with bogosort, you have to have some pretty decent knowledge about the distribution properties of your randgen to prove termination.
00:33:33 <arw_> one can always exchange the dots and the arrows and call it co-something...
00:33:56 <ksf> ...which is just way over my head. it's just so much faster and simpler not to generate any invalid maps, in the first place.
00:33:59 <Quadrescence> arw_: Codomain as in range.
00:34:13 <idnar> ksf: I prefer quantum bogosort :)
00:34:55 <Nereid> Quadrescence: for some definitions of range.
00:35:25 <Quadrescence> Nereid: Hence my use of codomain, as a clearer term.
00:35:31 <Nereid> indeed.
00:36:20 <|Steve|> Every time I see "bogosort," I think "buy one get one sort" as in buy one, get one free.
00:36:28 <sjanssen> ksf: I prefer deterministic bogosort variants
00:36:52 <Quadrescence> |Steve|: Haha
00:36:57 <Martijn_> :r
00:36:58 <ksf> bogosort as in bogomips as in bogosity.
00:36:59 <Martijn_> doh
00:37:08 <ksf> quantum bogosity, to be exact.
00:37:14 <Quadrescence> bozosort
00:37:50 <ksf> http://catb.org/jargon/html/Q/quantum-bogodynamics.html
00:38:02 <dolio> Types are higher level than values, in a manner of speaking.
00:38:24 <kmc> dolio, would you also say that propositions are higher level than proofs
00:38:29 <kmc> i suppose they're less detail-focused
00:38:52 <|Steve|> I'm reminded of the time we had the students write mergesort in scheme and some of them wanted to use the sort function (which is either builtin or in some library). They couldn't see why that was problematic. I eventually had to say, "Look, you just can't use sort!" Not that that is relevant, but there you are.
00:39:22 <dolio> Types may contain many values.
00:39:32 <dolio> Propositions may be proved by many proofs.
00:39:35 <Quadrescence> Haha, Haskell does not have dependent types
00:40:05 <Nereid> there's an extension for that
00:40:19 <ksf> huh?
00:40:20 <kmc> Nereid, Agda? :)
00:40:22 <sjanssen> Quadrescence: your point?
00:40:31 <ksf> haskell doesn't cross the :: from values to types.
00:40:39 <|Steve|> It should have Liquid types.
00:41:06 <kmc> Quadrescence, it's true, though there are lots of ways to fake it
00:41:10 <ksf> (which doesn't mean that you can't do much stuff that dependent type evangelist use to convert people)
00:41:25 <kmc> |Steve|, liquid types?
00:41:40 <arw_> uhm. aren't values just elements and types are sets? how are elements higher or lower in level than sets?
00:41:55 <|Steve|> Just a way to infer dependent types or something.
00:42:17 <ksf> http://pho.ucsd.edu/liquid/  ?
00:42:37 <tessier> Is it possible and relatively easy to implement a meta-circular evaluator in Haskell? That seems to be one of the things that make Lisp special.
00:42:50 <kmc> tessier, a haskell interpreter written in haskell?
00:42:51 <|Steve|> ksf: Yeah, that.
00:42:52 <ksf> arw_, in the same sense that a city is a higher order of abstraction as your house.
00:43:01 <tessier> kmc: Basically, yes.
00:43:13 <kmc> tessier, it's not too easy, because haskell is a hard language to implement
00:43:18 <poe> arw_: I agree
00:43:19 <Martijn_> Does it make sense that if I have "type F a = forall f. Functor f => f a", I cannot write this as "type F = forall f. Functor f => f" ?
00:43:19 <ksf> haskell is a bugger to parse.
00:43:20 <kmc> even though haskell is a good language  for implementingh languages
00:43:41 <ksf> it's easier to just link ghc into your program.
00:43:41 <kmc> you have to write a fairly complicated typechecker / type-inference engine for one
00:44:01 <kmc> tessier, a scheme interpreter in haskell is a good exercise
00:44:13 <ksf> writing a scheme in haskell is quite trivial, though.
00:44:17 <ksf> there's even a tutorial
00:44:21 <dolio> Values are classified by types, types are classified by kinds, etc. So there's a sort of hierarchy. So types are "higher" in that sense.
00:44:23 <kmc> ksf, it's not trivial
00:44:25 <kmc> but it is easy
00:44:33 <tessier> kmc: That's what I was wondering..Haskell and DSLs etc. If Haskell is a good language for implementing languages why isn't it a good language for implementing Haskell?
00:44:37 <kmc> tessier, it is
00:44:38 <ksf> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
00:44:42 <kmc> it's just haskell is hard to implement
00:44:46 <kmc> regardless of what language you use to do so
00:44:46 <ksf> ...well, compared to doing it in scheme, that is.
00:44:50 <arw_> ksf: so basically you take "is element of" to be the same relation as "is lower leven than". sounds reasonable.
00:45:01 <kmc> tessier, GHC, the premier haskell compiler, is written in haskell
00:45:26 <tessier> kmc: Really? I had always assumed it was written in C. Presumably they bootstrapped in C at some point right? But now it is self-hosting?
00:45:59 <Nereid> it still needs a C compiler
00:46:00 <mle> usually when people say scheme is trivial, it means they aren't implementing full tail recursion and call/cc
00:46:00 <ksf> bootstrapping via c is broken atm iirc.
00:46:12 <kmc> tessier, there were other haskell implementations
00:46:17 <kmc> like Hugs, an interpreter
00:46:17 <BMeph> tessier: The first Haskell compiler was written in LML. ;)
00:46:28 <tessier> Nereid: Oh, right. I read that it generates C for gcc or something like that.
00:46:47 <kmc> "bootstraping via C" in the GHC context means something very different from "implementing haskell in C"
00:47:00 <sjanssen> tessier: it usually generates ASM directly nowadays
00:47:00 <mle> mostly it's using the system linker now
00:47:02 <ksf> ...well, a simple lambda evaluator is about 10 lines of code.
00:47:04 <mle> there's a dire.. yes
00:47:09 <Axman6> tessier: it used to
00:47:23 <ksf> ...with gratious comments.
00:47:27 <Axman6> tessier: but not it uses its own native code generator
00:47:35 <dolio> The runtime system is written in C and C--.
00:47:38 <Axman6> which is often faster than the C version
00:47:58 <tessier> sjanssen: Generates ASM? So...what if I want to port it to ARM or MIPS or something? I have to write a new code generator in Haskell for ghc?
00:48:00 <mle> it still uses the system linker though
00:48:06 <kmc> tessier, you can use -fvia-C until you do
00:48:11 <tessier> ah
00:48:13 <kmc> in which case it outputs C
00:48:13 <tessier> Interesting.
00:48:23 <ksf> there should really be a c-like haskell dialect that one could use to implement e.g. the rts.
00:48:24 <blackdog> Axman6: I thought the latest performance advice was to use via-C...
00:48:24 <kmc> which runs a little slower, because C is not great as a portable assembler
00:48:37 <ksf> ...that is, strict and non-gc'ed. something like a better ml.
00:48:44 <mle> ksf: a la LIL or scheme48's pre-scheme?
00:48:54 <tessier> kmc: I thought C was an awesome portable assembler which is why C is so popular and UNIX was ported all over the place?
00:48:56 <ksf> I've heard of neither.
00:49:06 <ksf> I guess timber comes close, but it's gc'ed.
00:49:07 <mmorrow> bitc goes for something like this
00:49:14 <kmc> tessier, it's the triumph of mediocrity, partially
00:49:21 <tessier> kmc: heh
00:49:24 <kmc> and also GHC wants to do some very specific things that can't be expressed in C
00:49:28 <mle> ksf: LIL is lisp implementation language; a sexp-based imperative language used to write the runtime for some of the lisp machines.
00:49:28 <blackdog> tessier: read Worse is Better?
00:49:30 <kmc> like jumps between procedures
00:49:30 <arw_> tessier: well, not really awesome, but much better than the rest.
00:49:30 <sjanssen> blackdog: that's a bit outdated.  -fvia-c is only rarely a win, and is sometimes a loss
00:49:34 <ksf> but such a language won't ever win against c if it isn't used in production.
00:49:41 <kmc> and stuffing a data struct directly before a function in memory
00:49:42 <ksf> ...which is where implementing the rts in it comes in.
00:49:42 <mmorrow> tessier: C has hue restrictions of what control flow you can  express
00:49:45 <tessier> blackdog: I think I have but I don't recall at the moment. I'll look it up.
00:49:56 <mle> ksf: pre-scheme is a scheme-like language that compiles to C used to implement the scheme48 runtime
00:50:00 <ksf> additional points for re-using most of a haskell implementation, e.g. the type checker.
00:50:18 <tessier> mmorrow: And assembly doesn't? Hard to imagine.
00:50:29 <blackdog> tessier: it's an interesting look at why what FP types would consider superior environments lost out to C and Unix
00:50:30 <kmc> tessier, C lacks tail calls
00:50:43 <mle> ksf: I liked T's approach; they implemented the runtime and GC in the language itself.  The running garbage collector was able to safely copy /itself/.  Silly, but a great party trick.
00:50:43 <mmorrow> tessier: does C have a inter-"procedural" goto ?
00:50:53 <mmorrow> tessier: functions have to return, etc
00:51:04 <mmorrow> tessier: there's the implicit assumption of a single stack
00:51:05 <blackdog> mmorrow: setjmp/longjmp?
00:51:11 <tessier> mmorrow: Indeed. I see.
00:51:15 <mmorrow> blackdog: that's only up-stack
00:51:21 <kmc> and slow and unsafe
00:51:35 <tessier> I always thought that with the ability to scribble on the stack or in memory in pretty much any way you want that could be overcome.
00:51:44 <kmc> tessier, not portably
00:51:55 <mle> tessier: if you're going to do that, just write assembly and be done with it
00:51:59 <tessier> Not portably, that is true.
00:53:02 <ksf> chicken scheme (iirc) just treats the stack as a nursery: allocate as you go, and if you hit the top of the stack, figure out what part of the stack you still need, copy it to the heap, then resume execution, overwriting the old stack.
00:53:31 <kmc> tessier, if you're interested in how one might compile haskell efficiently, i can recommend a paper or two, and others here can recommend many more
00:54:02 <ksf> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
00:54:07 <ksf> ...that's the most important one.
00:55:01 <ksf> there's of course new work that has been done since 1992, but it's still the foundation.
00:55:09 <dons> multicore haskell on reddit, http://www.reddit.com/r/programming/comments/9i15h/multicore_programming_in_haskell_now/
00:55:37 <ksf> isn't multicore on haskell old news?
00:55:39 <dons> (this got some ridiculous thousands of hits yesterday from ycombinator)
00:56:00 <dons> ksf: well, a whole bunch of new stuff got anounced in the last couple of days
00:56:14 <dons> threadscope, spark/t4 performance, dph vectorizer
00:56:44 <ksf> ...dph on sse?
00:58:57 <tessier> ksf: Thanks for the info. I still have SO much to learn. I'm just on Python right now. Next will be scheme. Then on to Haskell. I feel like I need to warm up my functional programming chops before really getting into Haskell.
00:59:01 <Nereid> so when's 6.12 being released?
00:59:12 <dons> a couple of weeks.
00:59:20 <Nereid> excellent
00:59:24 <Nereid> tessier: why scheme first?
00:59:37 <tessier> I've read the first few chapters of Learn Yourself a Haskell and I have RWH here on my shelf. But I've got to learn a few other things before I really "get it" it seems.
00:59:38 <ksf> tessier, well, reading how haskell maps onto stock hardware might help you bridge the gap.
00:59:54 <kmc> i enjoyed reading the STG machine paper before i had any chance of implementing it
00:59:57 <kmc> but ymmv
01:00:10 <tessier> I've already got half a dozen tabs open thanks to programming.reddit.com and now you guys are piling more onto my reading list.
01:00:23 <tessier> I've got SICP on my shelf too, unread.
01:00:37 <mle> ksf: yeah, that paper made things much clearer for me also
01:00:38 <tessier> SO much to do. Oh, and I have a 9 to 5 job and bills to pay and a wife to do pointless things for. :)
01:00:51 <Nereid> so save your time and start with haskell ;-)
01:00:55 <arw_> don't worry, everybody has that problem.
01:01:07 <arw_> so much to do, so little time.
01:01:20 <tessier> Spineless Tagless G-machine seems like something I read about being for sale on a porn site.
01:01:40 <tessier> I think Sybian makes it or something.
01:02:28 <kmc> haha
01:03:19 <tessier> Yeah, I crack me up. :)
01:03:50 <blackdog> dons: just went through your tute. you are making it harder and harder to contemplate switching to ocaml :)
01:04:00 <dons> yeah, i should hope so.
01:04:11 <dons> no libraries, no parallelism, few support tools, no community support :)
01:04:21 <blackdog> dons: possible employment, though:)
01:04:35 <tessier> I really like the concept of being purely functional, type enforcment promoting correctness, ADT, multi-core parallelization, etc. etc.
01:04:37 <dons> there were far far more haskell corps. at CUFP than ocaml this year
01:04:40 <dons> the show of hands was amazing
01:04:55 <dons> more than even the erlang companies. there were gasps in the audience
01:04:58 <dons> can't wait to see the video
01:05:03 <blackdog> dons: sure, in generaly. got a specific job interview in mind...
01:05:08 <kmc> dons, how does one find these companies
01:05:09 <blackdog> s/generaly/general
01:05:13 <dons> well, if it pays the bills, do it.
01:05:14 <tessier> Hopefully one of the haskell web frameworks will reach a django level of maturity.
01:05:15 <kmc> i know about galois and bluespec and some banks
01:05:33 <dons> kmc: well, you come to cufp and see if you get recruited, or you look at the industry page on haskell.org
01:05:43 <dons> the industry page is about 1/2 the companies i know of.
01:05:58 <dons> but seems like people just use haskell now without saying their company has switched
01:06:02 <dons> i.e. its just another tool
01:06:12 <kmc> that's a good sign i suppose
01:06:26 <tessier> Lindows used Haskell. That was impressive. Too bad their product sucked and their CEO was a douchebag (whom I know/knew personally).
01:06:51 <dons> http://haskell.org/haskellwiki/Haskell_in_industry
01:06:53 <kmc> fun fact: #haskell is logged permanently to a public website
01:07:01 <dons> that's right.
01:07:02 <Axman6> heh
01:07:06 <tessier> Fun fact: Michael Robertson is a douchebag.
01:07:15 <Nereid> lol
01:07:37 <kmc> dons, thanks... i've seen that page but it keeps growing :)
01:08:07 <Nereid> tessier: yep, Linspire is on that list
01:23:24 <mle> I think linspire is defunct now
01:23:29 <mle> or at least the haskell stuff?
01:24:20 <mle> and freespire seems to be an ubuntu-with-goodies?
01:28:40 <dons> linspire is defunct, yep. the haskell team left.
01:28:48 <dons> they do flash games on facebook, from haskell now, iirc
01:28:48 <Nereid> whoops, I got "dependent types" mixed up with "associated types"
01:29:32 <tessier> mle: Yes, it is defunct.
01:30:08 <tessier> When they talk about the "PC loser-ing" problem in "Worse is better" does PC mean program counter?
01:32:02 <tessier> I'm familiar with assembly and how system calls are implemented etc but I'm not quite understanding this problem.
01:32:33 <Elly> basically, what they mean is this:
01:32:49 <Elly> when you do a system call, you trap into the kernel, and the value of the PC when you were in user space is saved
01:32:58 <Elly> (if you are familiar with x86, the PC is called "eip" there)
01:33:26 <Elly> the idea of "PC losering" is that if you take an interrupt in kernel mode, you force the PC back to the value it had when you entered user mode
01:33:39 <Elly> (which is the instruction after the syscall instruction - i.e., you perform a return to user space)
01:33:50 <Elly> but you set a flag for userspace indicating that the syscall failed and they should retry it
01:34:40 <dons> a nice read, erlang guy on haskell, http://orbitz-erlang.blogspot.com/2009/09/impressed-with-haskells-concurrency.html
01:34:44 <Elly> (this is the old EINTR value of errno)
01:34:46 <tessier> Elly: Apparently that is but one way to implement it, right?
01:34:53 <Elly> tessier: correct
01:35:01 <tessier> And not the right way according to the MIT guy (RMS?)
01:35:05 <Elly> indeed
01:35:11 <tessier> I could smell him.
01:35:12 <Elly> it is now widely considered a frumious hack to do it that way
01:35:29 <mmorrow> what're we implementing and what the right way to do it?
01:35:32 <Elly> the "correct" way is to be preemptible in kernel mode by way of proper locking
01:35:35 <mmorrow> implementing syscalls?
01:35:38 <Elly> mmorrow: kernel preemption
01:35:44 <mmorrow> ah, ok
01:35:57 <Elly> the 'simplest' way is to not be preemptible in kernel mode, but that doesn't work for SMP systems
01:36:13 <Elly> the 'correct' way is locking :P
01:36:15 <tessier> Elly: The MIT way is frumious? Is frumious a good thing or bad thing? dictionary.com says frumious is cromulent although I'm not sure what it means in this context.
01:36:43 <Elly> no
01:36:54 <Elly> the way that involves losering is frumious
01:37:27 <Elly> frumious means 'undesirable', as from Lewis Carroll's "The Jabberwocky"
01:37:33 <Elly> c.f. "shun the frumious Bandersnatch"
01:37:52 <tessier> UN*X does losering (signals an error which userland code must check for) and this is frumious which is bad. Got it.
01:37:59 <Elly> yes
01:38:04 <Elly> it complicates userland to make the kernel simpler
01:38:14 <Elly> arguably that is the right thing to do, but it does not scale to SMP systems
01:38:23 <tessier> Why not?
01:38:55 <Elly> so
01:39:04 <Elly> the goal of the losering is to avoid ever being preempted in kernel mode
01:39:15 <Elly> which means you do not need to do any locking, since there can be no concurrent use of any data structure, right?
01:39:29 <Elly> but on an SMP system, even without preemption in kernel mode, there can still be one person in kernel mode per CPU
01:39:42 <Elly> which means you have concurrent accesses *anyway*, so you are required to do locking
01:39:55 <Elly> at which point disabling actual preemption in kernel mode has no upside
01:41:05 <Elly> (you can dodge this with an even worse design called AMP, for asymmetric multiprocessing, where only one CPU is ever in kernel mode, but that turns out to run... a bit slowly, to say the least.)
01:41:18 <mylh> hi all haskell lovers. Sorry for interrupting any existing chats but does anyone has expirience with locales in haskell?
01:42:23 <wmealing_> tessier, the error being EAGAIN to userspace ?
01:42:54 <Elly> no
01:43:01 <Elly> EAGAIN means "Try that later"
01:43:10 <Elly> you want EINTR, which means "I got interrupted doing that; try again now."
01:43:29 <wmealing_> why should userspace ever get EAGAIN then ?
01:43:41 <wmealing_> shouldnt a kernel just queue the event ?
01:44:07 <wmealing_> wait, i'm expecting sanity.. my mistake
01:44:08 <Elly> if userspace asked for a nonblocking read, say
01:44:15 <dons> mylh: there's the locale library, and the new IO system picks up the locale
01:44:19 <dons> in ghc 6.12
01:44:19 <Elly> the kernel *should* return EAGAIN if there is no input to be read
01:44:32 <Elly> in that case the EAGAIN means "There's no value to read now; try again later"
01:44:47 <wmealing_> ok
01:44:52 <Elly> some people think nonblocking I/O is itself a hack, but... :P
01:45:13 <ski> tessier : see also <http://en.wikipedia.org/wiki/PCLSRing>
01:45:40 <wmealing_> thanks for the info elly.
01:45:44 <Peaker> Elly: Nah, its alright, relatively to other interfaces. Though I'd swap the return codes of (-1, EAGAIN) and 0 (EOF) such that EOF is a -1,errno=EOF, and EAGAIN is just 0. Much simpler
01:45:59 <mylh> hey, dons ) But the latest ghc is 6.10... is there a way of dealing with locale in this version?
01:46:16 <Peaker> Elly: its silly that "currently no data" is an error, but EOF is just an in-band 0 byte message, especially as truncation to any non-zero value is just truncation
01:46:48 <tessier> Peaker: I think it is reasonable to use the error mechanism to signal such things. Otherwise you have to invent a whole new mechanism.
01:47:36 <dons> mylh: you want to use locale to format numbers?
01:47:52 <dons> i'd ask on haskell-cafe@. lots of people there are used to locales
01:48:32 <mylh> dons: yes, i'm trying to print double numbers in russian locale, we use , inseted of . as decimal separator
01:48:49 <dons> yes, definitely ask on haskell-cafe@haskell.org
01:49:46 <mylh> i've searched through haskell-cafe archive but could't find any mentioning of number formatting :(
01:50:14 <Alpounet> You should ask directly, and wait for an answer :)
01:50:41 <Alpounet> I'm pretty sure some C functions have been exported in Haskell somewhere, to handle locales-related stuffs.
01:51:49 <dons> mylh: i don't think it has ever been asked!
01:51:52 <mylh> Alpounet: yeah :) I'm trying to set locale with System.Locale.SetLocale but it seems to have no effect
01:51:55 <dons> that's why i think you should ask directly
01:52:04 <Peaker> tessier: well, 1 byte available now, and 0 bytes available now seem to me to naturally map to result strings of such lengths. EOF should be an out-of-band indication
01:52:49 <mylh> I really don't want to bother all that serious people in haskell-cafe with my silly question :(
01:53:11 <Elly> Peaker: so... there's a technicality about the contract of read()
01:53:42 <Elly> Peaker: read() 'always' blocks (there's no way to ask for a "non-blocking read"); if you have asked for a read() on a non-blocking socket that would block, arguably your syscall is in error
01:53:51 <ski> tessier : see espessially the ITS solution of changing the state of the user process to continue the tail-recursive loop from where it got interrupted (more details in the external link) :)
01:53:55 <Elly> which IMO makes EAGAIN (aka EWOULDBLOCK, on Linux) legitimate
01:54:04 <ski> s/espessially/especially/
01:54:12 <Peaker> Elly: well, that's just a play on words :)
01:54:19 <Elly> no it isn't
01:54:33 <Elly> if you have a nonblocking socket, and you request a blocking read with no data available to read, you are doing it wrong
01:54:43 <Elly> "Go back to select(2), do not pass go", etc
01:55:04 <Peaker> Elly: Nah, you might want to read everything that's available on the socket when select indicates some data is available, and not just the next chunk
01:55:51 <Elly> there's no "everything that's available" read
01:56:15 <Peaker> Elly: just loop around read until it returns EAGAIN after select returns (or if the results were swapped, until it returned 0 bytes)
01:56:17 <Elly> if you do read(..., 1024, buf) on a socket with 500 bytes ready, you'll get back 500 bytes
01:56:34 <Elly> but you never need to do that
01:56:52 <Elly> loop around the entire { select(); read(); }
01:57:09 <Peaker> Elly: that incurs more overhead per read
01:57:21 <Elly> not meaningfully
01:57:35 <Elly> select()ing with a socket in the set that already has data is not too bad
01:57:49 <ski> Elly : wouldn't a "read what's available, but at most `n' octets" be a non-blocking read ?
01:57:53 <Elly> anyway, we are kind of idly speculating at this point
01:57:56 <Peaker> Elly: it depends on how many mechanisms your mainloop goes through between select and read. It may be O(logN) of some big N - number of handles registered on select, etc
01:57:57 <Elly> ski: no, not at all
01:58:07 <ski> why ?
01:58:09 <Elly> ski: it blocks until there is any data available
01:58:25 <Elly> if there are 0 bytes in the buffer, it will block :P
01:58:37 <Peaker> Elly: anyway, regardless of the rationale behind the weird way non-blocking I/O ended up, it could be nice if those results were swapped
01:58:43 <ski> the point was that it should get data, if any was available (in some buffer), otherwise it should not wait for the data to arrive
01:58:52 <Elly> ski: yes, that's what O_NONBLOCK is for
01:59:06 <Elly> if you don't specify O_NONBLOCK, then you *do* wait for there to be some data to read
01:59:20 * ski doesn't really know very much about the lower level details of unix ..
01:59:32 <ski> Elly : ok
01:59:44 * Elly has written a bunch of unixish kernels in her time :P
02:00:30 <Peaker> Elly: cool, why unixish though? There are nicer concepts out there :)
02:00:53 <Elly> I have written non-unixish ones too
02:01:00 <Elly> I am curious what models you have in mind when you say that
02:02:06 * ski wonders whether haskell `Handle's with underlying `fd's set them to `O_NONBLOCK' in threaded mode
02:02:44 <Zeiris> Are executables built by GHC self-contained, or do they require runtime libraries?
02:03:00 <Elly> ski: there is a smarter way to do that on linux, which is using the posix aio layer
02:03:06 <Elly> ghc may well do that instead, I do not know
02:03:12 <Elly> (aio = asynchronous I/O)
02:03:31 <quicksil1er> no, it doesn't.
02:03:35 <quicksil1er> ghc uses select()
02:03:43 <quicksil1er> (on unix-like OSes)
02:03:44 <Elly> not epoll?
02:03:46 <kmc> Zeiris, i believe the runtime is statically  linked in
02:03:51 <quicksil1er> correct. not epoll.
02:03:54 <Elly> aw :(
02:04:13 <Elly> more portable, but ugh :P
02:04:21 <quicksilver> you know what they say
02:04:26 <quicksilver> "patches welcome" ;)
02:04:47 <ski> Elly : someone on #scheme recently opined that the sane thing to do is to set all `fd's to `O_NONBLOCK' and implement scheme-thread-friendly blocking on ports / sockets above that
02:05:02 <Peaker> Elly: heard of EROS-OS?
02:05:03 <quicksilver> although I think there has been various experimental bits and bobs for a better IO manager, just nothing finished yet
02:05:09 <Elly> Peaker: yes I have
02:05:10 <Peaker> Elly: why have you written kernels? Fun or profit?
02:05:20 <Peaker> Elly: Well, EROS-OS's model is far nicer than the Unixish model
02:05:24 <Elly> Peaker: fun, and profit after I graduate :)
02:05:27 <ski> (otherwise one scheme thread performing a low-level blocking system call would block all the other innocent scheme threads)
02:05:41 <Elly> Peaker: I do not think they can be compared to each other
02:05:45 <Peaker> Elly: why not?
02:05:59 <kmc> Zeiris, are you on *nix?
02:06:06 <Elly> because EROS just doesn't provide the same kind of interface as Unix does
02:06:12 <Zeiris> kmc: I was thinking of Windows distributions to end lusers. :)
02:06:16 <kmc> ah
02:06:19 <kmc> can't help you there, sorry
02:06:30 <Elly> EROS provides capabilities, scheduling, and synchronous IPC
02:06:52 <Elly> it makes no decisions about things which are fundamental to the Unix model (i.e., unified heirarchical namespace, asynchronous signals, etc.)
02:07:34 <Peaker> Elly: it makes decisions: A) Get rid of global namespace B) Signal stuff through IPC capabilities.   I think the nicest improvements are orthogonal persistence and the (partial) "statelessness" of the kernel
02:07:34 <Elly> so EROS cannot be said to have a different model from Unix in the same way that the Linux driver layer doesn't have a different model from Unix - it is an apples-to-oranges comparison
02:07:47 <Elly> Unix systems do not necessarily have a global namespace
02:07:57 <Elly> and in fact, I believe no currently-deployed unix has one global namespace
02:08:21 <Peaker> Elly: the global namespace of pids is one
02:08:25 <Elly> signaling through IPC capabilities is fine, but not incompatible with a unixy model (also, Windows has it, in the form of HPROCESSes)
02:08:31 <Peaker> Elly: the global namespace of API's and unix sockets is another
02:08:34 <Elly> pid namespacing exists in linux now
02:08:36 <Peaker> Elly: de-facto, people don't use chroot that much, so / is another
02:08:42 <Elly> "global namespace of APIs" is unclear as a term
02:08:53 <Elly> unix sockets live in the filesystem, which is not a global namespace because of chroot
02:09:22 <Peaker> Elly: They do? I seem to remember unix sockets (Not referring to fifo files, but AF_UNIX sockets) use non-file-based addressing
02:09:28 <Elly> they absolutely do
02:09:48 <Peaker> Elly: OK, then there are the system V communication primitives which are global. Also all the "non-globality" you're talking about is off by default :)
02:09:50 <Elly> man 7 unix
02:10:19 <Elly> the semaphore stuff is, in fact, a nasty hack
02:10:23 <Elly> and is one global namespace
02:10:34 <Elly> as is the msg stuff and all that
02:10:49 <Elly> but none of those are intrinstic to unices in general
02:11:05 <Peaker> Elly: Well, in virtually all *nix installations / is a global namespace, as well as the pid namespace
02:11:14 <Elly> IMO, the things that distinguish unices are: unified heirarchial namespace (i.e., all objects are present in it), and fork()/exec()/wait()/exit() as primitives
02:11:33 <Elly> Peaker: indeed, but there are some where it isn't, so it can't be a defining feature of unices
02:11:47 <Peaker> Elly: well, have you seen what EROS-OS has in place of fork?
02:12:33 <Elly> no, I have not
02:14:06 <Peaker> Elly: in EROS-OS the user-space allocates all of the required resources for the new process and hands them to a single syscall "convert these resources to a process", which is really nice because it prevents forkbombs/etc.  This is consistent with all EROS-OS syscalls -- they are provided with resources by user space, so DoS is less likely/possible
02:14:27 <Elly> what does "convert these resources into a process" actually do?
02:14:56 <Elly> and yes, I've seen other OSes that do it that way
02:14:59 <Peaker> Elly: basically add it to a linked list of scheduled processes, and write the page tables from the provided address space (on given pages), iirc
02:15:18 <Elly> I think it is relatively common when writing highly reliable OSes to allocate all memory in user space, so quotas can be enforced strictly and the kernel can't fail to allocate memory
02:15:25 <Peaker> Elly: also, the process is exposed to its creator as an actual modifiable data structure (with slots it created for scheduler, address space, registers, etc) so a "debugger" needs no special kernel API. Just modify those in the structure
02:15:31 <Elly> (also, having no dynamic allocation in kernel -> hard realtime is a lot easier)
02:15:48 <Peaker> Elly: After reading about EROS-OS years ago I was wondering why people are still implementing/working with unixes
02:17:27 <Elly> because Unixes already exist
02:17:30 <Peaker> Elly: So anyway, I think Unix and EROS-OS conceptually are very comparable, in the sense that EROS has a better persistence model, better security model, a better kernel allocation model, etc :-)
02:18:06 <Peaker> Elly: Though I myself have lost interest in trying to implement such a kernel, because my current belief is that kernels (ring0/etc) are not necessary
02:18:13 <Elly> erm
02:18:18 <Elly> you are going to need some code in ring 0
02:18:23 <Elly> unless you are on some truly bizarre hardware
02:18:52 <Elly> at least on x86en, you can only switch page tables in ring 0
02:19:09 <Alpounet> is lambdabot broken?
02:19:19 <Peaker> Elly: I'd like all code to be in ring0, and to use language-level protections
02:19:24 <Peaker> Elly: in one single address space
02:19:43 <Elly> oh, Singularity-style
02:19:45 <ksf> we're going to be graph-reducing in hardware on fpgas soon, anyway.
02:19:55 <Peaker> Elly: Singularity seemed to be a promising implementation of that idea back then, but then they added multiple address spaces again which defeats the point
02:20:14 <Elly> yeah, you can do that
02:20:34 <Elly> the downside, of course, is that you can't run C programs on your new kernel, and C is still the lowest common denominator
02:20:53 <Peaker> Elly: So something like GHC's rts would be a kernel in a sense (just doing scheduling and memory management), though drivers and other features would just be ordinary libraries
02:21:21 <Peaker> Elly: I think the iPhone and OSX show that legacy code is overrated :)   Give people a good platform and it will fill the voids in notime :)
02:21:28 <ksf> there's house, isnt' there?
02:21:48 <Elly> there's also a truly horrifying thing called bootperl
02:21:54 <Kaidelong> the managed operating system?
02:21:56 <Peaker> ksf: I don't think House strives to eliminate CPU-level protections
02:21:59 <Elly> which is conceptually similar, minus any hope of safety :P
02:22:05 <quicksilver> Peaker: OSX contains around 10 million lines of legacy code, I imagine.
02:22:18 <quicksilver> Peaker: it's an unholy union of NeXTStep and BSD4
02:22:22 <ksf> we'd need to conquer the desktop before pwning the os market, though.
02:22:25 <Peaker> quicksilver: Well, it modified the API's significantly, and people rewrote their programs for them
02:22:29 <quicksilver> Peaker: iPhone OS is only slightly better.
02:22:36 <Kaidelong> well a managed operating system is a good idea
02:22:38 <ksf> ...and we don't even manage to write a tk in haskell.
02:22:43 <Peaker> quicksilver: rewrote->ported
02:22:45 <Kaidelong> I was quite impressed by the papers behind Singularity
02:23:00 <Kaidelong> although it did more than just that
02:23:04 <Elly> Peaker: I have yet to see a language in which there is a good fast implementation of zlib, openssl, or sqlite (or something similar)
02:23:17 <Elly> those are C libraries that people use often
02:24:30 <Peaker> Elly: You could still do FFI, if you limit it to calling "trusted" low-level code
02:24:35 <Elly> egh
02:24:45 <Elly> you don't want openssl and zlib and sqlite to be "trusted low-level code"
02:24:48 <Peaker> Elly: though I think if necessary, zlib/et-al would be fast in Haskell, for example
02:24:53 <Elly> those belong firmly in the realm of "library"
02:25:10 <Elly> I wonder how a haskell zlib or a haskell openssl would stack up against the C one
02:25:33 <Peaker> Elly: written in a certain style, it would probably fare very well
02:26:26 <Alpounet> what kind of style ?
02:26:28 <Elly> someone should produce a haskell implementation of md5
02:26:33 <Elly> I am really curious about this now
02:26:38 <Elly> md5 is relatively simple to write in C
02:26:49 <Alpounet> http://www.comlab.ox.ac.uk/people/ian.lynagh/md5/
02:27:00 <Alpounet> well : http://www.google.com/search?ie=UTF-8&oe=UTF-8&sourceid=navclient&gfns=1&q=haskell+md5
02:27:08 <Zeiris> Most such algorithms are tailored to run on assembler. How well canHaskell support that?
02:27:32 <Elly> algorithms are not tailored for assembly language
02:27:42 <ksf> some are.
02:27:51 <Elly> assembly implementations of crypto algorithms happen to be pretty damn fast, though :P
02:28:16 <ksf> e.g. sfmt
02:28:19 <Peaker> Elly: If you write stuff with recursions that have accumulators, it seems to relatively straightforwardly turn into C loops. That's what I gather from dons' blog posts about computing the average of a list in Haskell
02:29:03 <ksf> what about a low-level haskell?
02:29:05 <Kaidelong> link to the blog please?
02:29:19 <Elly> at least on my system, `md5sum` appears not to use openssl's optimized md5
02:29:21 <dschoepe> Elly: I think that compiled C might be faster than writing assembly by hand, since the compiler knows more about how to exploit cpu features like pipelining etc.
02:30:26 <Elly> dschoepe: only in the presence of insufficiently smart programmers :)
02:30:29 <quicksilver> dschoepe: that only depends how good you are at assembly writing.
02:30:43 <Peaker> Kaidelong: http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/
02:30:49 <Kaidelong> Well I heard that OCaml and Scheme's compilers can sometimes emit programs that look like they were done by hand
02:30:54 <blackdog> Elly: we're all insufficiently smart for something
02:30:58 <quicksilver> dschoepe: but in general modern compilers are quite smart about loop unrolling and branch prediction and pipelining but absolutely shit at vectorising.
02:31:01 <Elly> blackdog: ...yes?
02:31:10 <Kaidelong> but i don't really know about much at this level of abstraction
02:31:14 <quicksilver> dschoepe: so hand written vectorised code can do some things much better.
02:31:19 <Elly> blackdog: that has nothing to do with whether the openssl crypto stuff was optimized by someone who is sufficiently smart for that, though
02:31:59 <dschoepe> quicksilver: ah, thanks. didn't know that.
02:32:16 <blackdog> Elly: perhaps. I think we're moving in the direction of everybody being insufficently smart for raw assembler, in the same sense that we're insufficiently smart to solve the Travelling salesman problem
02:32:43 <blackdog> assembler on serious multicore is non-trivial, for instance
02:33:00 <badsheepy> we solved the travelling salesman problem - ebay :p
02:33:08 * Elly has written concurrent assembly before :)
02:33:24 <blackdog> badsheepy: heh. don't change the route, change the territory...
02:33:46 <Elly> oh, it's late
02:33:49 * Elly -> bed
02:35:01 <blackdog> Elly: concurrency != parallelism
02:43:24 <RayNbow> mauke, have you seen http://golf.shinh.org/reveal.rb?find+minimum+cyclic+parts/notogawa/1251293404&hs ?
02:44:21 <badsheepy> i cant get used to haskellers seeming fondness for single letter variable names
02:44:29 <blackdog> y?
02:45:13 <ksf> can anyone point me to an example that uses gadts in a non-trivial way?
02:45:13 <badsheepy> because i get so far as a sentence like 'This is the kind of code we want to write.' and realise i have no idea what that code he just wrote did :o
02:45:15 <Zeiris> I know, eh?
02:45:18 <Zeiris> Itdrives me N U T S
02:45:25 <ksf> that is, is something more interesting than an evaluator?
02:45:47 * ksf finds it hard to understand stuff before he knows how to abuse it.
02:46:09 * blackdog is sad his extremely silly joke was ignored :/
02:46:26 <ksf> ...I guess it's important to know the capabilities of the system so I have a bounded design space.
02:46:30 <blackdog> badsheepy: of course, once you go pointfree, you don't have any variable names at all :)
02:46:49 <blackdog> (are you reading RWH, by any chance?)
02:46:58 <badsheepy> no
02:47:13 <badsheepy> well, technically yes, but i have been for ages, i just havent actually looked at it in like 2 months :o
02:47:42 <Saizan> short variable names help because they take less space in your brain's L1 cache :)
02:48:04 <Saizan> and most haskell functions fit there
02:49:12 <badsheepy> i dont have at all enough practice or experience with haskell to dispute that
02:49:19 <badsheepy> but when i do, i will :D
02:49:25 * ksf actually assumes his brain works more like an fpga
02:49:37 <ksf> ...involving much self-modifying code.
02:49:45 <blackdog> Saizan: it's a funny effect, actually - i've noticed that when i come back to refactor haskell with some new nugget of knowledge, enough drops away that i'll start inlining stuff and dropping comments again because they seem unnecessary
02:50:05 <blackdog> whereas when i have to write java, every stupid variable seems to need a javadoc
02:50:34 <Saizan> @quote true.haskell.form
02:50:47 <Saizan> @bot -- ?
02:50:47 <lunabot>  :o
02:50:51 <Saizan> aww
02:50:52 <ksf> most importantly, coding java requires a dual-screen setup, as not to have identifiers break lines.
02:51:39 <blackdog> (learning Applicative was a big step. the verbosity of my IO code was always sort of embarrassing until then)
02:51:59 <ksf> by the time javac has finished reading in the first identifier of the program, usual haskell implementations already solved the halting problem.
02:52:04 <ksf> in the type system.
02:52:14 <Saizan> twice.
02:54:49 <Zeiris> It would still be nice if variable names were longer.
02:56:09 <ksf> so, how exactly would you write (x:xs), then?
02:56:25 <Nereid_> ksf: (GADTs) anything in http://www.iai.uni-bonn.de/~ralf/publications/With.pdf ?
02:56:34 <RayNbow> ksf: (h:t) if you're coming from Prolog? :p
02:56:37 <Zeiris> x:xs is neat enough for my liking. But fold could use three letter names to better suggest what they are.
02:56:53 <wmealing_> I'm wondering the best way to get some kind of haskell mentoring, asking dumb questions to the irc channel seems stupid, and my questions are rarely time important.
02:56:59 <ksf> Zeiris, fld?
02:57:14 <ksf> we're not using dos anymore.
02:57:35 <Zeiris> I meant in the arguments.
02:57:38 <ksf> ...where filenames were forbidden to use vowels, out of space reasons.
02:57:42 <ksf> @src fold
02:57:45 <Zeiris> Function names are decent. Arguments like a b c are :(
02:57:46 <RayNbow> @botsmack
02:57:46 <lunabot>  :o
02:57:47 <ksf> @src foldl
02:57:57 * RayNbow pokes lambdabot
02:58:07 <Nereid_> ,src foldl
02:58:08 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
02:58:21 <ksf> why? it's a single list it's reducing.
02:58:35 <RayNbow> Paging doctor Cale, paging doctor Cale... lambdabot needs immediate CPR :p
02:58:40 <ksf> Nereid_, didn't I read that, already?
02:58:45 <Nereid_> probably
02:58:47 <blackdog> wmealing_: beginners@haskell.org?
02:58:50 <ksf> ...whatever. seems I gotta re-read it.
02:59:00 <wmealing_> blackdog, didnt know about it.. thanks
02:59:07 <Zeiris> I can tell you like extreme brevity, and can figure out what it means from the type signature. I, don't and can't :)
02:59:18 <idnar> Zeiris: I'm not sure how it would help for fold
02:59:23 <ksf> if you end up having (x:xs) , (y:ys) and (z:zs), then, yes, one could start thinking of better names.
02:59:34 <idnar> descriptive names are only helpful when there's something to describe
02:59:48 <idnar> the arguments to foldl/r are arbitrary values
02:59:51 <ksf> idnar is right.
03:00:04 <quicksilver> it's more than that
03:00:14 <quicksilver> there is something to describe, but it's already all described by the type.
03:00:22 <idnar> well, yeah, besides that
03:00:26 <quicksilver> You could say: "foldr binary initial list"
03:00:33 <quicksilver> that would be 'meaning' names
03:00:47 <quicksilver> but IMO that just duplicates the description the type gives.
03:00:53 <Nereid_> except possibly "initial"
03:00:57 <idnar> I find that harder to read, because the longer names have more "pull"
03:01:12 <quicksilver> but the right solution surely is to read the documentation for foldr
03:01:16 <quicksilver> not its source :)
03:01:17 <idnar> they look like they're significant, but they're really not
03:02:13 <RayNbow> btw, what does z stand for in the definition of foldr/l? zero?
03:02:38 <ksf> wrt to GADTs, there's also http://lambda-the-ultimate.org/node/1293
03:03:27 * ksf would have called it v, short for value
03:03:56 <RayNbow> hmm, I think I'd prefer z then :p
03:04:06 <ksf> which unravels the REAL reason for short names:
03:04:11 <ksf> reduced bikeshedding.
03:04:25 <ksf> if noone knows what those names mean, noone complains about them.
03:05:00 <Zeiris> Still think it reduces readability and increases time needed to 'get' code.
03:05:05 <ksf> we should write (x:xen), anyway.
03:05:13 <idnar> ksf: haha
03:05:34 <blackdog> (x:andeveryoneelsewhobrokemyheart) ?
03:05:46 <idnar> Zeiris: when I first started reading Haskell, I also thought "wow, all these cryptic 1-letter names are really confusing"
03:05:51 * RayNbow tracerts ksf
03:05:56 <RayNbow> ah, German :p
03:05:58 <Zeiris> What makes them not?
03:06:00 <idnar> Zeiris: but I changed my mind after a little while, since I found that it actually improved things a lot more
03:06:18 <idnar> I think it's a combination of two factors
03:06:38 <sioraiocht> idnar: are you referring type signatures, or using things like "x" and "xs" for names?
03:06:53 <idnar> 1) Haskell code tends to be a lot more generic than languages with reallyLongSpecificNames
03:06:54 <Zeiris> I'm allabout type signatures.
03:07:04 <yitz> @vixen what color should we paint the bikeshed?
03:07:09 <idnar> 2) Haskell type signatures are a lot more expressive, so you don't have to shoehorn type information into the name
03:07:20 <quicksilver> as a perl programmer, I was quite happy with short meaningless variable names. The most common variable names in perl programs are $_ and @_
03:07:23 <yitz> @bots
03:07:23 <lunabot>  :o
03:07:32 <idnar> sioraiocht: things like "x" and "xs"; I've never seen anyone complain about type variables not being expressive enough :P
03:07:43 <ksf> ...using something else than "a" and "b" in type sigs has its merits.
03:07:44 <sioraiocht> idnar: okay, heh
03:07:49 <Zeiris> idnar: yeah, I can see that making sense. Still wonder why you can't have both for 2)
03:08:02 <ksf> we've got Map k v, just for a start.
03:08:13 <quicksilver> ksf: but only when there is information to convey
03:08:16 <quicksilver> @type map
03:08:20 <blackdog> quicksilver: to be fair, you generally don't refer to them specifically
03:08:23 <ksf> yep.
03:08:29 <blackdog> chomp, rather than chomp($_)
03:08:32 <idnar> Zeiris: now that I've been reading Haskell code for longer, I find "foldr f z xs" a lot easier to read than "foldr binary initial list"
03:08:35 <quicksilver> map :: (a -> b) -> [a] -> [b]
03:08:41 <quicksilver> blackdog: which makes the name even shorter ;)
03:08:47 <quicksilver> blackdog: 0-letter variable names ftw.
03:09:01 <blackdog> quicksilver: point-free perl
03:09:14 <ksf> for one, you can be absolutely certain that something called f, g or h is a function.
03:09:15 <badsheepy> foldr is rather an extreme case of abstraction where it makes sense
03:09:20 <idnar> Zeiris: it's a lot easier to "skip over" insignificant names when they're short
03:09:27 <badsheepy> when i mentioned single lettervariables it wascause i was looking at this:
03:09:27 <badsheepy>         (s, l) = foldl' k (0, 0) [n .. m]
03:09:28 <badsheepy>         k (s, l) a = (s+a, l+1)
03:09:43 <badsheepy> what in gods name is a tired brain supposed to make of that obfuscated nonsense :P
03:09:43 <ksf> "binary" could be the binary representation of konrad zuses original design documents.
03:09:46 <ksf> who knows?
03:09:50 <yitz> ksf: h can be a Handle
03:09:56 <ksf> that's hd.
03:10:00 <ksf> ...or hdl
03:10:11 <yitz> nah, waste of keystrokes. h.
03:10:27 <ksf> well go for it, but not if you've got f and g in the function.
03:10:49 <ksf> (which is unlikely, considering that handles are awfully monadic)
03:10:51 <idnar> badsheepy: obviously that code needs more abstraction ;)
03:10:56 <yitz> ksf: true. and then sometimes you end up with f'', f''', ...
03:11:35 <badsheepy> waiting is. one day i shall grok! :D
03:11:43 <yitz> ,seen lambdabot
03:11:44 <lunabot>  luna: Not in scope: `seen'
03:12:14 <ksf> preflex, seen lambdabot
03:12:15 <preflex>  lambdabot was last seen on #haskell 4 hours, 39 minutes and 47 seconds ago, saying: optimization suspended, use @pl-resume to continue.
03:12:22 <ksf> @pl-resume
03:12:30 <Saizan> don't!
03:13:34 <ksf> she should just say "Nah that's too complex for me. Do it yourself."
03:14:40 <yitz> she's not saying anything now.
03:14:43 <Saizan> i guess someone inserted a non-productive loop into the simplifier
03:15:08 <Saizan> and the timeout doesn't work because the threads are not preemptive enough..
03:15:23 <sioraiocht> boo
03:16:28 <Saizan> ..or something.
03:17:24 <EnglishGent> hi - can someone help me with a cabal problem please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9148#a9148
03:17:36 <EnglishGent> it does work installing some packages (I've successfully installed a few)
03:17:51 <EnglishGent> but HDBC doesnt want to install - and I need database connectivity :|
03:18:13 <ksf> takusen?
03:18:22 <hackagebot> flower 0.1.1 - Analyze 454 flowgrams (.SFF files) (KetilMalde)
03:18:33 <mmorrow_> @bot
03:18:33 <lunabot>  :o
03:18:36 * EnglishGent only started using cabal yesterday - and really doesnt know it properly yet :|
03:18:36 <ksf> you want to change that contraint on time to old-time
03:18:45 <mmorrow_> grr
03:18:51 <ksf> ...considering that hunit wants base <4
03:18:55 * mmorrow_ extracts @unmtl then
03:19:05 <ksf> hdbc seems to be unmaintained.
03:19:39 <EnglishGent> thanks for the advice ksf - but I'm sorry - I have no idea how to do what you just suggested
03:19:51 * EnglishGent is looking at the database chapter from 'real world haskell'
03:19:52 <Saizan> hdbc is maintained
03:20:01 <mmorrow> oh gah, i always forget about rwbarton's `oldtype'
03:20:08 <ksf> ...using cabal-fetch to get the packages, untarring them, editing the .cabal files, then installing them manually.
03:20:20 <Saizan> EnglishGent: which version of ghc are you using?
03:20:21 <ksf> ...but I guess you want to use another database layer.
03:20:36 <mmorrow> , oldtype [t| forall o r a. ContT o (Reader r) a |]
03:20:37 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Type'
03:20:40 <EnglishGent> The Glorious Glasgow Haskell Compilation System, version 6.8.2
03:20:40 <EnglishGent> :)
03:20:45 <mmorrow> , [$ty| oldtype |]
03:20:48 <lunabot>  Type -> Q ((Type, [] Dec))
03:20:49 <yitz> mmorrow: why are you checking for lambdabot? the logs seem to show that you are the one who killed it.
03:20:55 <mmorrow> yitz: heh
03:20:57 <ksf> now that's a fossil.
03:21:16 <Saizan> EnglishGent: ok, that's the problem, that version of hdbc wants 6.10.1 at least
03:21:55 <mmorrow> yitz: rlimits are complicated things i guess ;)
03:21:56 <yitz> mmorrow: was it the djinn loop, or @pl of fixed point, do you think?
03:22:10 <EnglishGent> ok... I was just using the one debian provided
03:22:17 <Martijn_> What's the protocol for asking a question you asked earlier but was not answered? Do I just ask again? :-)
03:22:17 <mmorrow> , [$pl| (\x -> x x) (\x -> x x) |]
03:22:19 * EnglishGent does a dist-upgrade & sees it that helps
03:22:19 <EnglishGent> :)
03:22:22 <yitz> or perhaps the two were the deadly combination
03:22:23 <lunabot>  Killed.
03:22:31 <mmorrow> yitz: the "one-two punch"
03:22:36 <mmorrow> KO!!@
03:22:39 <mmorrow> :)
03:23:01 <yitz> a poisonous brew
03:23:20 <EnglishGent> thanks for your help all :)
03:23:35 <Martijn_> I'll just ask again then :-)
03:23:38 <Martijn_> Does it make sense that if I have "type F a = forall f. Functor f => f a", I cannot write this as "type F = forall f. Functor f => f" ?
03:23:43 <Saizan> EnglishGent: actually, i'm sligthly wrong :)
03:23:50 <int-e> @where lambdabot
03:23:56 <mmorrow> , $(lift =<< oldtype =<< [t|forall o r a. ContT o (Reader r) a|])
03:23:58 <lunabot>  (ForallT [o_1627418495,r_1627418496,a_1627418497] [] (AppT (AppT ArrowT (...
03:24:09 <yitz> int-e: at the hospital currently
03:24:42 <Saizan> EnglishGent: cabal install hdbc --constraint="time == 1.1.3" should work with your compiler
03:25:10 <mmorrow> , ppDoc $(lift . fst =<< oldtype =<< [t|forall o r a. ContT o (Reader r) a|])
03:25:12 <lunabot>  forall o_0 r_1 a_2 . (a_2 -> r_1 -> o_0) -> r_1 -> o_0
03:25:20 <mmorrow> , [$ty| renameT |]
03:25:22 <lunabot>  [] ((Name, Name)) ->
03:25:22 <lunabot>  [] Name -> Type -> (Type, [] ((Name, Name)), [] Name)
03:25:24 <Saizan> yitz: which were the last commands given to lambdabot?
03:25:50 <yitz> Saizan: the following two:
03:25:51 <mmorrow> Saizan: a cmd that looped @djinn, then @pl (\x->x x)(\x->x x)..
03:25:59 <anan> http://www.thaiadpoint.com/tap8.1/bin/redir.php?p=2018&l=1336&u_id=363435
03:26:02 * mmorrow slowly sidesteps away
03:26:07 <Saizan> you can loop djinn?
03:26:10 <yitz> <mmorrow> @djinn J (J a (J b a)) a -> J b (J (J (J a b) a) b)
03:26:14 <mmorrow> Saizan: oh yesh
03:26:19 <yitz> <lambdabot> No output from Djinn; installed?
03:26:31 <Saizan> ah, that's ok
03:26:38 <yitz> <mmorrow> @pl (\x -> x x) (\x -> x x)
03:26:39 <int-e> what is J?
03:26:39 <mmorrow> i've been meaning to check that with a local djinn though
03:26:45 <mmorrow> (a -> b) -> a
03:26:49 <yitz> <lambdabot> ap id id (ap id id)
03:27:02 <yitz> <lambdabot> optimization suspended, use @pl-resume to continue.
03:27:12 <yitz> and that was the last we heard from the poor bot
03:27:15 <mmorrow> <lambdabot> iiiii''mmmmmmmmmmmmmmmm melllllllllllllllllllllllltttttttttttiiiiiiiiinggggggggggggg
03:27:36 <Saizan> i wonder if that's really the cause
03:27:44 <int-e> maybe some private message?
03:27:46 <elbar> <lambdabot> Will i dream?
03:28:05 <mmorrow> Saizan: lb doesn't seem to control @pl (or any runaway plugins) very well
03:28:07 <int-e> daisy daisy?
03:28:36 <int-e> but @pl is supposed to keep itself in check.
03:28:39 <Saizan> mmorrow: but optimization suspended is a sign that @pl didn't run away at that point
03:28:57 <yitz> it could be just the djinn loop
03:29:01 <Saizan> djinn might have run away not-really-killed
03:29:05 <mmorrow> Saizan: yeah, although the @djinn no output could mean that it's still spinning away..
03:29:17 <mmorrow> yeah
03:29:20 <yitz> eating up all memory
03:29:29 <mmorrow> all cpus pegged at 101%
03:30:00 <mmorrow> someone in teh datacenter cooking an egg on the server case
03:30:09 <yitz> yeah, there's always that
03:30:36 <yitz> wait, is the data center in LA?
03:30:53 <lilac> lambdabot is just bitter after being asked silly questions
03:30:56 <yitz> near the Wilson Observatory, perhaps?
03:31:22 <mmorrow> yitz: i'd bet my bottom dollar
03:32:19 <Botje> "GHC: we crank it up to 101%"
03:32:35 <yitz> "...and then crash"
03:33:41 <Saizan> mmorrow: when http://hackage.haskell.org/trac/ghc/ticket/2954 is fulfilled we can kill those runaways!
03:34:11 <yitz> I see that freenode thinks lambdabot is still around
03:34:36 <mmorrow> just tried that in a local djinn... it certainly loops
03:35:23 <mmorrow> Saizan: i thought that got fixed?
03:35:57 <mmorrow> Saizan: anyways, it'd always be trivial to write a custom popen C function
03:36:06 <maxote> hi guys, what is used djinn for?
03:36:19 <yitz> maxote: crashing lambdabot, for one thing
03:36:25 <mmorrow> "Djinn is a program that generates Haskell code from a type.
03:36:26 <mmorrow> Given a type the program will deduce an expression of this type,
03:36:26 <mmorrow> if one exists.  If the Djinn says the type is not realizable it is
03:36:26 <mmorrow> because there is no (total) expression of the given type."
03:36:31 <Saizan> mmorrow: the question is if lambdabot wants to be portable to windows or not
03:37:19 <mmorrow> Saizan: just #ifdef WINDOZE \n proceed with horror #else use the code that works #endif
03:37:48 <yitz> format c:
03:37:50 <mmorrow> there's already a lot of that in the rts..
03:38:44 <maxote> morrow, one type only?
03:39:31 <maxote> what can Djinn deduce the type Int ?
03:39:39 * jethr0 is having trouble with networking...
03:40:12 <Nick2> http://www.thaiadpoint.com/tap8.1/bin/redir.php?p=2018&l=1336&u_id=363435
03:40:15 <maxote> is not Djinn forgetting the alphabet of types for deduction?
03:40:22 <jethr0> i implemented my game (bomberman) using tcp networking and channels. and currently having server and client running on the same machine (even same process)
03:41:07 <jethr0> under linux performance is ok, but under windows either the networking or the channels are EXTREMELY choppy (going toward 1 second delay)
03:41:11 <jethr0> any ideas?
03:41:34 <quicksilver> maybe windows sucks? ;)
03:41:40 <mmorrow> maxote: e.g.
03:41:45 <quicksilver> did you compile with -threaded?
03:41:50 <mmorrow> Djinn> ? f :: ((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
03:41:50 <mmorrow> f a b = a (\ c _ -> b c) b
03:41:52 <mmorrow> (callCC)
03:41:56 <jethr0> i don't think this has (yet) to do with tcp overhead, since it's over localhost with low latency and no collisions...
03:42:16 <jethr0> quicksilver: actually i didn't. what does that do? use system processes for forkIO?
03:42:25 <quicksilver> no, it uses a different RTS
03:42:26 <quicksilver> do it ;)
03:42:31 <jethr0> k, thx, i'll try that
03:42:44 <quicksilver> I expect under windows something blocks which doens't block under linux
03:42:51 <quicksilver> -threaded makes fewer things block.
03:42:56 <jethr0> i was thinking maybe it is window size of tcp...
03:43:17 <jethr0> why the hell isn't there a reliable protocol without windowing *argh*
03:43:30 <quicksilver> don't think windowing will cause 1 second delays.
03:43:39 <quicksilver> you could be sure to hFlush after each send though
03:43:43 <quicksilver> to make sure nothing's being buffered
03:43:47 <flux> jethr0, atleast on linux you want to disable packet coalescing
03:43:55 <jethr0> the other interesting thing is: under linux the client (mostly opengl) has lower frames and 90% cpu usage.
03:43:56 <flux> jethr0, I don't know if that can be done on windows
03:44:06 <quicksilver> flux: is that necessary if you flush expicitly?
03:44:09 <jethr0> under windows much faster frames and ca. 20% cpu usage
03:44:16 <flux> quicksilver, how do you flush a socket?
03:44:20 <Saizan> if you waitForProcess on a pid of a process that has already completed you get an exception?
03:44:22 <jethr0> even given that cpu usage is a bad metric, this seems a huge difference
03:44:31 <quicksilver> flux: hFlush?
03:44:43 <quicksilver> jethr0: well, windows generally has better graphics drivers
03:44:44 <jethr0> i flush the socket on every write.
03:44:48 <flux> quicksilver, well, what does it use then? because I don't know of a socket-level operation to flush sockets
03:44:52 <jethr0> question is how that translates into the tcp stack
03:44:53 <quicksilver> jethr0: is it the same graphics card on both machines?
03:45:01 <jethr0> same machine
03:45:08 <jethr0> but obviously different drivers
03:45:11 <quicksilver> yeah, probably better windows driver then.
03:45:31 <koala_man> jethr0: do you have dri enabled and working on linux?
03:45:37 <jethr0> the gl is so low-level though (only textured quads) that i hadn't expected that to make a difference
03:45:44 <jethr0> koala_man: let me check
03:45:48 <flux> quicksilver, I mean operation like setsockopt to set the flag TCP_NODELAY to the socket
03:45:51 <jethr0> probably not
03:45:51 <koala_man> glxinfo will say
03:45:57 <quicksilver> flux: you're probably right
03:46:21 <quicksilver> flux: I thought there was some equivalent of flush for TCP
03:46:44 <Ferdirand> there's the push flag
03:47:03 <jethr0> that's weird "OpenGL renderer string: Mesa DRI Intel(R) 945GME GEM 20090326 2009Q1 RC2 x86/MMX/SSE2". looks like software (mesa) at first, but i have glx...
03:47:22 <quicksilver> jethr0: no, mesa doesn't mean it's software
03:47:27 <quicksilver> jethr0: DRI means it's hardware.
03:47:40 <jethr0> this whole graphics thing touches only slightly on my (presumed) network issue
03:47:41 <quicksilver> or, it should do
03:48:00 <flux> jethr0, do you have a limit on the number of frames per second?
03:48:04 <jethr0> flux: ok, let me look into the TCP_NODELAY flag
03:48:20 <jethr0> Ferdirand: where do i find the push flag?
03:48:21 <quicksilver> well try recompiling with -threaded first
03:48:24 <quicksilver> that might fix it :)
03:48:37 <flux> jethr0, because likely you want to top out at 60 or so
03:48:43 <jethr0> flux: yes, limiting at 60 frames. i was speaking of top performance (i.e. no limit)
03:49:05 <flux> jethr0, I don't think it's unexpected that the CPU-usage is high if you don't limit the amount of work
03:49:31 <Nick2> http://www.thaiadpoint.com/tap8.1/bin/redir.php?p=2018&l=1336&u_id=363435
03:49:47 <jethr0> sorry, mixing my messages. CPU usage is high at 60fps on linux (90%) and low at 60fps on windows (20%). but this might have to do with opengl
03:50:04 <jethr0> since under linux most time is spent in opengl (ca. 60%)
03:50:11 <arw_> software rendering?
03:50:21 <arw_> what does 'glxinfo' say?
03:50:49 <jethr0> couldn't profile under windows so far, because i get sth. like "process exited twice. should you be using a different FFI call instead?"
03:50:57 <jethr0> this comes from one of the libraries, i presume
03:51:15 <jethr0> "OpenGL renderer string: Mesa DRI Intel(R) 945GME GEM 20090326 2009Q1 RC2 x86/MMX/SSE2"
03:51:20 <jethr0> and it has glx
03:51:45 <quicksilver> you are looking for "direct rendering: yes", or similar
03:51:47 <arw_> hm, looks like hardware rendering. maybe the driver just sucks.
03:52:35 <jethr0> i mean it's a netbook, so i don't expect too much from it ;). but opengl seems to be at least adequate in other places.
03:52:40 <arw_> software would say something like "Mesa GLX indirect" there. but yes, you should also look at the direct rendering parameter
03:52:46 <quicksilver> there is probably one specific thing you're doing which is hitting a slow path in the linux intel driver.
03:53:13 <jethr0> hmm, as i said. the only thing i am using is mipmap textured quads. and double buffering
03:53:15 <jethr0> nothing fancy
03:53:30 <quicksilver> power of 2 texture sizes?
03:54:03 <jethr0> no, that's why i am presumably using mipmaps. i am a total newbie to opengl... seemed like such a hassle to do the power of 2 thingey ;)
03:54:43 <quicksilver> the linux drivers probably don't optimise non-power-of-two textures well.
03:54:48 <quicksilver> that would be my guess.
03:54:50 <jethr0> hmm
03:55:33 <quicksilver> I believe non-POT is a significant penalty on all but the most advanced and modern cards anyway
03:55:42 <quicksilver> and should be avoided if you're mipmapping
03:56:39 <jethr0> grr, the alternative is so much bittwiddling... i will definitely look into this. the issue on windows definitely stems from the networking/channel part, though ^_^
03:57:29 <jethr0> ok, i'll look into "-threaded", "TCP_NODELAY" and tcp push for now... any other ideas for "streamlining" network latency apart from using UDP?
03:57:46 <jethr0> is there a reliability layer for UDP in hackage somewhere, maybe?
03:59:04 <mmorrow> Saizan: err, actually you wouldn't even need to write a C version... just explicitly send a SIGKILL
03:59:22 <mmorrow> Saizan: and if on windows, just have the current behavior
04:00:15 <mmorrow> Saizan: who has write access to lambdabot anyways? Cale, gwern, _ ?
04:00:42 <Saizan> mmorrow: Cale pulls and runs it, gwern has push access to the repo
04:01:39 * mmorrow makes a note to harass gwern about this :)
04:02:40 <Saizan> mmorrow: well, i might fix it and send a patch, though, do you see what's the point of the catch on waitForProcess? http://code.haskell.org/lambdabot/lambdabot-utils/Lambdabot/Process.hs
04:02:56 * mmorrow looks
04:03:06 <Saizan> mmorrow: is it just a silly way to return even if the process ended in a loop?
04:03:23 <mmorrow> i remember we went over this before (which was how we originally found out that it wasn't sending SIGKILL)
04:03:30 <jethr0> i assume "Network.Socket" is unix-only? or is that covered by windows quasi-posix?
04:03:32 <mmorrow> but i don't recall what conclusions we came to
04:03:35 * mmorrow looks
04:03:51 <Saizan> mmorrow: yeah, but i don't see a terminateProcess anywhere either
04:04:54 <mmorrow> Saizan: hah, yeah it doesn't even make any attempt to kill it :)
04:05:01 <mmorrow> nor does it set any rlimits..
04:05:14 <Saizan> mmorrow: i think gwern fixed the terminateProcess issue in mueval
04:05:30 <Saizan> mmorrow: which leaves it open on the other processes run by lambdabot..
04:05:51 <mmorrow> ah, i see. so then any non-mueval plugin that goes nuts is unimpeded
04:05:56 <mmorrow> yeah, geez
04:06:20 <Saizan> remember that the main lambdabot loop sends a killThread after a timeout
04:06:22 <mmorrow> so that djinn query is still spinning then.. heh
04:06:32 <mmorrow> Saizan: ah, ok
04:06:57 <Saizan> so the waitProcess is interrupted by that killThread, the catch returns ExitSuccess, and the process is out there spinning :)
04:07:00 <mmorrow> Saizan: so then that's where we should send an explicit SIGKILL (if on a posix system)
04:07:10 <mmorrow> Saizan: heh
04:07:15 <Saizan> yeah, in the waitProcess catch
04:07:40 <mmorrow> right
04:08:04 <Saizan> we might also need some block/unblock to prevent the killThread to insert itself between runInteractiveProcess and waitForProcess
04:09:11 <benmachine> you can set rlimits on cpu time can't you?
04:09:19 <benmachine> wouldn't that be sufficient?
04:09:54 <mmorrow> yes, although can you set rlimits on a proc from another proc?
04:10:19 <mmorrow> err, well this would best be done at the C level..
04:10:29 <Saizan> haskell's rlimits binding tended to cause random segfaults though.
04:10:32 <mmorrow> in which case you can set the rilimits in the child after you fork
04:10:52 <mmorrow> Saizan: hmm
04:12:10 <mmorrow> Saizan: are you sure those segfaults aren't a side-effect of exceeding some rlimit though?
04:12:11 <Saizan> it didn't work on all arches/distros, not sure way
04:12:14 <Saizan> *why
04:12:25 <jethr0> i know this is hardly haskell relevant, but...
04:12:42 <Saizan> mmorrow: it segfaulted when evaluating (), iirc
04:12:43 <mmorrow> ohh, right. i remember that there was some bug a while ago
04:12:44 <jethr0> is there a way to monitor a tcp socket? or even inject latency?
04:12:52 <mmorrow> can't remember what though (or whether it got fixed)
04:14:30 <benmachine> jethr0: monitor for what?
04:14:55 <Saizan> mmorrow: oh, lambdabot already depends on unix
04:15:04 <mmorrow> Saizan: ah, nice
04:18:04 <jethr0> benmachine: monitor for traffic volume, latency, just generally get a feel for the chunkyness ;)
04:18:23 <jethr0> i.e. whether it's a continuous stream or bursts of large packets
04:20:01 <benmachine> some names that come to mind are tcpdump and ntop
04:20:06 <benmachine> don't know if they are what you want though
04:21:22 <jethr0> hmm, that's one way of doing it. i wanted to inject latency for testing, but i guess this goes beyond a haskell question ;)
04:23:18 <jethr0> stupid TCP, what i really need is something between UDP and TCP (like a slim reliability layer on top of UDP)...
04:24:18 <jethr0> like a slimmed down raknet
04:27:22 <EnglishGent> jethr0 - have you seen Beep? http://beepcore.org/
04:27:42 <EnglishGent> a lightweight build-your-own-protocol system :)
04:28:53 <jethr0> EnglishGent: looks really cool. if i can at all prevent it, i'd try not to get stuck in another FFI-library-wrapping-session ;)
04:30:27 <Saizan> @version
04:31:30 <EnglishGent> :)
04:33:33 <jethr0> enet seems viable. i'll have look around. i hope it is at least a tcp issue i am having and not sth else... ;(
04:33:56 <jethr0> i may try pure udp first to see if it brings any speedup/fluency under windows
04:55:48 <mmorrow> Saizan: here's the C side of a popen w/ rlimit-setting incorporated into it http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3530#a3530
04:56:51 <mmorrow> Saizan: just need an wrapper .hs that FFI imports proc_rlim (w/ will be more than completely on account of having to build (struct rlimit)'s)
04:57:10 <mmorrow> *..(which will be more than completely _trivial_ on accou..
05:07:05 <mmorrow> Saizan: oops, i'm returning the wrong pid from proc_rlim..
05:07:44 <mmorrow> oh crap, i actually have the cases in the switch backwards..
05:07:58 <mmorrow> err, now i'
05:08:01 <mmorrow> m confused
05:08:06 * mmorrow readstfm for fork()
05:09:08 <mmorrow> ok, just am returning the wrong pid
05:10:15 <mmorrow> Saizan: ok http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3530#a3531
05:10:22 <jethr0> how much of an overhead do channels have? i am thinking of using 4 channels per client with <10 clients. is that going to be an issue?
05:11:10 <Gwern-away> channels aren't that bad. slower of course than doing mvars manually
05:11:20 <Gwern-away> I wouldn't put them in your tight loop tho...
05:11:30 <mmorrow> although Chan's are made of MVars..
05:11:30 <Saizan> mmorrow: btw, it seems terminateProcess is sufficient for djinn
05:11:37 <mmorrow> Saizan: nice
05:12:01 <mmorrow> Saizan: i guess it would only matter if the child proc was ignoring SIGTERM
05:12:20 <mmorrow> (or was hopelessly locked up)
05:12:26 <Saizan> i need another bracketOnError to avoid leaking the threads that consume stdout and stdin
05:12:45 <Saizan> but then it should be fine
05:12:47 <quicksilver> yes, on buggy OSes (i.e. all of them!) it's possible for processes to get into a non-killable state even without ignoring TERM
05:12:48 <jethr0> gwern-away: hmm, so what kind of overhead are we talking about? microseconds or milliseconds ;)
05:12:56 <quicksilver> jethr0: micro
05:12:56 * Gwern-away has never benchmarked it
05:13:14 <jethr0> i'm doing channel writes ca. 10-60 times per second...
05:13:25 <quicksilver> linux sometimes manages to get un-SIGKILL-able processes too
05:13:27 <quicksilver> very annoying.
05:13:33 <Gwern-away> but the spread of concurrency techniques, from the grpah in the stm papers I vaguely remember, is pretty wide
05:13:37 <jethr0> good old zombies
05:14:09 <mmorrow> quicksilver: :o
05:14:15 <mmorrow> quicksilver: un-SIGKILL-able?!
05:14:20 * ve sometimes gets a whole zombie OS (Linux) where nothing is killable
05:14:24 <jethr0> hmm, so i might use an "MVar (Sequence a)" or "MVar (DList a)" instead if performance becomes an issue?
05:14:32 <mmorrow> oh zombies, right
05:14:36 <Axman6> jethr0: MVars are _very_ fast
05:15:01 <jethr0> i'll think about it. using channels was very comfortable/convenient though ;)
05:15:24 <mmorrow> jethr0: Chan's are made of MVars..
05:15:27 <Vanadium> Channels are just a disturbingly recursive pile of mvars, no?
05:15:30 <jethr0> Axman6: would you say that channels are NOT _very_ fast?
05:15:44 <Axman6> i'd say they're quite fast too
05:15:53 <Axman6> they are just MVar chains after all
05:15:54 <jethr0> mmorrow: i know, infinite stream of mvars, hehe
05:16:07 <jethr0> nested
05:16:17 <RayNbow> preflex, seen mauke
05:16:18 <preflex>  mauke was last seen on #haskell 10 hours, 59 minutes and 31 seconds ago, saying: > let f _ = [] in f ()
05:16:55 <mmorrow> jethr0: one thing about the current Chan implem, is that isEmptyChan will /block/ if there's already a thread waiting on a readChan
05:17:07 <mmorrow> jethr0: which (imo) is bad!
05:17:14 <Vanadium> unGetChan will block, too
05:17:17 <Vanadium> That was rather irritating
05:17:45 <mmorrow> this is my re-implem of Chan that doesn't have that problem http://moonpatio.com/repos/vacuum/src/GHC/Vacuum/Q.hs fwiw
05:17:56 <jethr0> hmm, i am currently mis-using channels i think. i want to get everything that is currently in the channel so i do (pseudocode):
05:17:59 <mmorrow> (also, it has a non-blocking read function)
05:18:26 <mmorrow> drainQ is handy too
05:18:41 <jethr0> items <- while (not empty) (readChan c)
05:18:53 <jethr0> drainQ?
05:18:59 <mmorrow> in that Q module
05:19:02 <jethr0> ah
05:19:10 <mmorrow> also has a takeWhileQ :: (a -> Bool) -> Q a -> IO [a]
05:19:21 <jethr0> hehe
05:19:26 <mmorrow> :)
05:19:56 <jethr0> isEmpty blocking when another thread is already blocking seems like a major semantic bug to me
05:20:05 <mmorrow> jethr0: totally, me too
05:20:31 <jethr0> that could lead to nasty behavior. i may actually have run into that day before yesterday
05:20:36 <mmorrow> jethr0: and the thing about the Chan module is, that behavior is inherent in how Chan is built
05:20:40 <jethr0> i had an inexplicably block isEmptyChan
05:20:47 <mmorrow> so it can't be fixed without scrapping that implem
05:20:58 <mmorrow> (and Q is my attempt at that)
05:21:46 <Vanadium> Does no one even care that unGetChan is blocking too :V
05:22:00 <mmorrow> Vanadium: heh
05:22:16 <Saizan> mmorrow: this is how i'd rewrite Lambdabot.Process.popen http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9149#a9149 , have i missed anything?
05:22:21 <mmorrow> i don't think i've ever actually used unGetChan
05:22:35 <mmorrow> but just made a note to add that to Q
05:23:03 <Vanadium> I had a couple of threads blocking on a Chan (Maybe ...) and wanted to terminate them all, so I sent Nothing and had each thread check for that, unGet it and then terminate
05:23:22 <Vanadium> except the unGetChan would block so I had to use writeChan which made no difference and made me feel stupid :'(
05:23:30 <jethr0> Vanadium: i kinda do, just haven't used that yet.
05:24:13 <Vanadium> I am bad at concurrency~
05:24:21 <mmorrow> Saizan: nice
05:24:25 <jethr0> Vanadium: only worked because the channel was empty, though
05:25:01 <jethr0> Vanadium: you can't possibly be worse than me at concurrency. so much programming experience, but none when it comes to concurrency ;(
05:25:05 <mmorrow> Saizan: so assuming terminateProcess is fixed and sends SIGKILL, then that solves the problem completely, right?
05:25:20 <mmorrow> ("that" := your change + SIGKILL)
05:26:16 <Saizan> mmorrow: it seems they are going to add a killProcess to send SIGKILL, but yeah
05:26:26 <mmorrow> right, nice
05:26:41 <Saizan> and it already seems to stop a looping @djinn
05:26:41 <mmorrow> yeah, it seems like that solves the problem to me too
05:27:31 <Philonous> Is there a deb package for ghc 6.10.4?
05:27:42 <mmorrow> the only thing i guess that could happen would be that lambdabot gets killed before it kills the child, and then the child remains spinning
05:28:13 <Saizan> mmorrow: killed as in another process killing it?
05:28:18 <mmorrow> which rlimits would additionally protect against (but that's kindof being paranoid.. :)
05:28:22 <mmorrow> Saizan: yeah
05:28:37 <mmorrow> or just "$ killall -9 lambdabot"
05:29:13 <Saizan> we should install a signal handler for that, sigh
05:29:27 <Saizan> exceptions and concurrency don't mix!
05:29:29 <mmorrow> but if you get a SIGKILL it's game over
05:29:43 <mmorrow> no chance to even see it coming
05:30:24 <Saizan> i wonder if my popen could get stuck on those killThreads
05:31:22 <lilac> Philonous: there's one in the ubuntu karmic repo, not sure about debian unstable
05:32:06 <Philonous> lilac: Thanks, an ubuntu package is what I need.
05:47:00 <FunctorSalad> *anachronistic salad* mmorrow: chuck norris can ignore SIGKILL and...
05:48:18 <mmorrow> heh
05:48:34 <mmorrow> i think it would be best as:
05:48:43 <mmorrow> "Chuck Norris can ignore SIGKILL."
05:49:09 <mmorrow> or s/can ignore/ignores/
05:49:13 <Gwern-away> Chuck Norris is the universe's SIGKILL
05:49:27 <FunctorSalad> is there some more contemporary "badass entity" meme?
05:49:34 <Axman6> just no one's written the universes's kill command yet
05:49:34 <arw_> Chuck Norris is the default handler for SIGKILL
05:49:39 <mmorrow> heh
05:49:46 <idnar> haha
05:50:54 <mmorrow> there should be a SIGNORRIS
05:50:54 <arw_> Redshift means, stars move away from us at speed. They are afraid of Chuck Norris.
05:54:10 <FunctorSalad> someone did try to revive the ninja meme with s/ninja/ring homomorphisms/, but I think it didn't catch on.
05:55:10 <idnar> are ring homomorphisms the throwing weapon of choice for mathematics ninjas?
05:58:28 <Axman6> they throw d/dx. that shit'll fuck you up
06:01:12 <absentia> hey -- not trying to start a language war or anything...  I'm really honestly interested for my own edification -- but can anyone give me some good reasons or any compelling reason to learn haskell?
06:02:01 <mmorrow> absentia: it'll make you a better programmer
06:02:14 <PeakerWork> absentia: It has some of the most interesting ways to describe many programs. Especially the imperative subset of Haskell is very interesting, but it also has many unique innovations in the pure part
06:02:15 <arw_> well. _the_ reason for learning haskell is that haskell is very different from almost every other language out there.
06:02:27 <Axman6> absentia: because it is excellent for concurrent and parallel code
06:02:47 <absentia> got that one... also -- it's supposed to be "modern" and be (well) designed.. also, it's good to learn new languages now and then... and it's functional.
06:02:56 <PeakerWork> does anyone know if hxt can work on XML streams, or if not, what can?
06:03:09 <PeakerWork> I guess the XML SAX bindings can, but they're quite low-level
06:03:30 <absentia> ax:  ya, I like that parallel (and concurrent) part.. but can't you get that with  pure separation and message passing? etc.
06:03:31 <FunctorSalad> PeakerWork: the imperative one? interesting, I didn't know the "world's finest imperative language" quip was serious. but I don't think the imperative subset is bad, either
06:03:46 <absentia> what's the world's finest imperative planguage?
06:03:51 <PeakerWork> absentia: Haskell :)
06:04:03 <PeakerWork> FunctorSalad: The fact I can add "yield" as a short library to Haskell is amazing, IMO :)
06:04:05 <arw_> fortran77
06:04:14 <PeakerWork> FunctorSalad: (And not as an ugly syntactic/type-unsafe macro, the lisp way)
06:04:19 <absentia> What's the best online tutorial for a newbie to haskell and functional programming (I'm almost done with real world haskell)
06:04:26 <ksf> @where lyah
06:04:29 <ksf> @where rwh
06:04:32 <ksf> @botsmack
06:04:33 <lunabot>  :o
06:04:48 <ksf> http://learnyouahaskell.com/
06:04:53 <absentia> I read that one...
06:05:05 <FunctorSalad> PeakerWork: essentially, moving around IO actions with pure code?
06:05:11 <ksf> http://book.realworldhaskell.org/read/
06:05:18 <absentia> I'm almost done with that one.
06:05:25 <ksf> mhhh.
06:05:28 <FunctorSalad> (whatever 'pure' means in that context, but you can put them in lists etc. anyway)
06:05:34 <ksf> then you should go typeclassopedia.
06:05:38 <absentia> ok, hanks
06:05:41 <absentia> thanks.
06:05:51 <ksf> ...and maybe start to read papers.
06:06:00 <absentia> I'm going to try to start writing some programs.
06:07:07 <ksf> you can also have a look at xmonad, which comes with a hell a lot of documentation
06:07:45 <ksf> http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
06:08:00 <absentia> looking
06:09:38 <Axman6> ksf: how nice. thanks for the link
06:09:44 <mmorrow> , let swap = uncurry (flip (,)) in time (rnf (fmap swap (zip [0..] [1..10000000])))
06:09:48 <lunabot>  (1.8587179999999999,())
06:09:54 <PeakerWork> FunctorSalad: no no, basically an abstraction around ContT
06:09:57 <mmorrow> , let swap (a,b) = (b,a) in time (rnf (fmap swap (zip [0..] [1..10000000])))
06:10:03 <lunabot>  Killed.
06:10:05 <mmorrow> :o
06:10:14 <mmorrow> , let swap = (\(a,b) -> (b,a)) in time (rnf (fmap swap (zip [0..] [1..10000000])))
06:10:20 <lunabot>  Killed.
06:10:25 <mmorrow> , let swap ~(a,b) = (b,a) in time (rnf (fmap swap (zip [0..] [1..10000000])))
06:10:25 <PeakerWork> FunctorSalad: basically coroutines, interlacing actions from the caller and called in any monad. Its really fun to use ListT with ContT there, btw
06:10:31 <lunabot>  Killed.
06:10:36 <mmorrow> innnteresting
06:10:47 * mmorrow uses uncurry (flip (,))
06:11:12 <ksf> Axman6, feel free to document the rest of the stuff.
06:11:29 <absentia> ooh, my turn, my turn -->  time , let swap ~(a,b) => (b,a) rpolnot fmap unswap redcurry [hot [1..100000000]]
06:11:35 <ksf> I guess the authors won't mind if they hit the 10% code / 90% docs mark.
06:12:02 <dschoepe> mmorrow: does luna/lambabot use -O2 for compilation? perhaps this difference goes away with optimization?
06:12:05 <FunctorSalad> PeakerWork: ok, I have yet to use or really understand ContT  :(
06:12:07 <mmorrow> PeakerWork: ooh, i've got a better Coroutines module now (yesterday) http://moonpatio.com/repos/Scheduler.hs
06:12:30 <mmorrow> dschoepe: good point. yeah, lunabot's going via bytecode
06:12:32 <Gwern-away> dschoepe: mueval turns on optimizations, iirc, but dunno if that corresponds to -)2 or -O
06:12:58 <dschoepe> ah, okay.
06:13:04 <Baughn> "It is however recommended that library users avoid using Hermes in a manner that depends on insecure nodes not being compromised, if such compromise could affect their programs' correctness." <-- I'm getting good at this "understatement" thing
06:13:32 <mmorrow> dschoepe: although i've recently coincidently learned how to walk it through all the -O2 optims with the ghc-api, which lunabot's using. i should have lunabot do that too and see if there's a change
06:13:46 <ksf> mmorrow, http://hackage.haskell.org/packages/archive/Coroutine/0.1.0.0/doc/html/Control-Coroutine.html ?
06:13:51 * mmorrow does that (will take 4 minutes)
06:15:50 <mmorrow> ksf: hmm, not sure at first glance. that Scheduler module is actually cooperative multi-tasking (w/ the ability to change the scheduling strategy)
06:16:21 <mmorrow> it's currently just doing round-robin (and using a list for a queue)
06:17:08 <mmorrow> had to use unsafeCoerce for stupid reasons, but no trace of the unsafeCoerce leaks outside of {scheduler,yield,done}
06:17:27 <mmorrow> (and it's safe)
06:18:01 <mmorrow> it could be avoided if the Task's were made to just return ()..
06:18:23 <mmorrow> (in which case they'd be expected to do useful things via IO)
06:18:45 <quicksilver> mmorrow: someone really should file a trac for that isEmptyChan issue
06:19:10 <quicksilver> I wrote my own chan once to get a non-blocking peek, or something.
06:19:38 <mmorrow> quicksilver: yeah, good point. the only solution too, unless i'm mistaken (which i'm pretty sure i'm not), is to use a different datatype for Chan
06:20:03 <mmorrow> quicksilver: totally, the lack of a non-blocking read too is annoying
06:20:27 <Baughn> PeakerWork: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9150#a9150 <- I believe you were curious what I was doing.. this is not FRP, but still useful. ;)
06:20:28 <ksf> control.coroutine doesn't seem to do any scheduling except at synchronisation points, at all.
06:20:42 <quicksilver> mmorrow: further more, someone should write up something explaining the 'safe' ways to use MVar/Chan
06:20:44 <ksf> (which might be a good idea or not)
06:20:54 <quicksilver> mmorrow: it's common sense, ish, but it would be nice to formalise it.
06:21:17 <quicksilver> mmorrow: (where by safe, I mean something rather fuzzy, but roughly 'doesn't block when you're not expecting it')
06:21:24 <mmorrow> quicksilver: hmm, what do you mean by "safe"? (as in, given the current implem, and "safe" := won't block?)
06:21:30 <roconnor> mmorrow: do you only unsafeCoerce from and to the same types?
06:21:35 <mmorrow> ah, one step ahead of me..
06:21:52 <mmorrow> roconnor: yes
06:22:03 <quicksilver> mmorrow: for example, all the non-atomic operations like modifyMVar can be considered atomic given appropriate discipline.
06:22:12 <mmorrow> roconnor: well actually i unsafeCoerce between two different types, but one of those is a lie
06:22:19 <roconnor> mmorrow: that isn't safe
06:22:22 <roconnor> AFAIK
06:22:22 <thaldyron> Can someone tell me why the program here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3532#a3532 uses 130MB?
06:22:30 <quicksilver> mmorrow: modifyMVar is atomic w.r.t. readMVar, but is not atomic w.r.t. takeMVar
06:22:34 <mmorrow> roconnor: but i only unsafeCoerce to put it somewhere, then re-coerce before it's used
06:22:36 <quicksilver> or do I mean 'put'
06:22:38 <quicksilver> something like that ;)
06:22:41 <mmorrow> roconnor: it is in this case
06:22:41 <roconnor> mmorrow: that still isn't safe
06:23:17 <roconnor> speaking as someone who has extracted coq code using tonnes of unsafeCoerce and having it crash in GHC.
06:23:42 <roconnor> mmorrow: what is the type where you put it?  GHC.Any?
06:24:03 <mmorrow> roconnor: no. the lie is this:
06:24:21 * mmorrow opens that module to refresh his memory
06:24:41 <mmorrow> type S o = Label (M o) (Maybe ())
06:24:41 <mmorrow> newtype Cxt o a = Cxt {unCxt::Label (M o) (Maybe (Either (Task o a) a))}
06:24:41 <mmorrow> newtype Task o a = Task {unTask::Either (M o a) (Cxt o a)}
06:24:50 <mmorrow> so "S" is really:
06:24:58 <mmorrow> Label (M o) (Maybe (Either (Task o a) a
06:25:03 <mmorrow> which is unwrapped Cxt
06:25:16 <mmorrow> if the `a' is in S, then it can't be a monad
06:25:18 <jethr0> *wuhu*, using "setSocketOption NoDelay 1" and "ghc -threaded" resolved the windows issue. thx guys
06:25:22 <ehamberg> i get the following error when i import Control.Monad.State. How do I solve this? (which is the "default"?)
06:25:24 <mmorrow> and "do" notation is lost
06:25:25 <ehamberg> Could not find module `Control.Monad.State': it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
06:25:29 <arw_> how do i ask cabal for the package i need to install to get 'Data.Array.Vector'?
06:26:01 <jethr0> only thing is that now "System.Exit" doesn't seem to kill the child processes...
06:26:06 <ksf> ehamberg, most likely you want to hide monads-fd
06:26:15 <roconnor> mmorrow: that seems unsafe.  Nothing stops the compiler from doing type based optimizations based on the fact that something is of type ().
06:26:22 <mmorrow> roconnor: yeah
06:26:28 <ehamberg> arw_: "cabal list vector"?
06:26:36 <roconnor> and GHC will do such optimizations
06:26:51 <mmorrow> roconnor: although to be honest, things are so knotted that it's not exactly clear wtf the "correct" type even should be
06:27:11 <mmorrow> roconnor: but since they'd be ADTs regardless, it's safe
06:27:15 <ehamberg> ksf: thanks.
06:27:17 <byorgey> arw_: unfortunately, there isn't a way to do that yet.  Fortunately, I happen to know that the package you want is probably uvector.
06:27:19 <cdiem> Hello, the following code: http://nopaste.info/bcbcad3a98.html keeps giving me "SimpleGraphics.hs:9:19: The last statement in a 'do' construct must be an expression. How can I fix it?
06:27:22 <gometz> how do i make a power function that works like this n^k = (n^2)^k/2 when the numbers are even in comparison to n^k = n * (n^(k-1)) which is the regular one
06:27:38 <mmorrow> roconnor: but yeah, i'd use Any if i intended to ever use that module seriously (which i may intend at some point)
06:27:49 <ksf> cdiem, by putting an expression into the last statement...
06:27:51 <roconnor> mmorrow: wtf?  Have you been listening to me? :D
06:28:04 <dcoutts> arw_: there is no module name -> package lookup at the moment, you might like to file a ticket for that feature request
06:28:05 <mmorrow> roconnor: which part?
06:28:10 <thaldyron> arw_: you can ask hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html
06:28:11 <ksf> oh.
06:28:13 <cdiem> cool :)
06:28:17 <mmorrow> roconnor: oh, you said "unsafe" :)
06:28:19 <quicksilver> cdiem: indentation wrong on line 10
06:28:19 <ksf> it's choking on your if-then-else.
06:28:21 <byorgey> cdiem: 'drawInWindow' and 'spaceClose' are indented one space too far to the right
06:28:21 <jethr0> cdiem: try indenting "drawInWindow" and "spaceClose" one space less
06:28:22 <roconnor> mmorrow: the part where I said it wasn't safe, and how I've done the same thing and had GHC crash.
06:28:22 <mmorrow> roconnor: try to segfault it
06:28:35 <byorgey> right, also lines 10 and 11 have wrong indentation
06:28:36 <arw_> ehamberg: byorgey, dcoutts, thaldyron thanks.
06:28:41 <cdiem> byorgey: Thanks a lot
06:28:44 <quicksilver> cdiem: and line 11 is even worse than 10 ;)
06:28:46 <mmorrow> roconnor: rules are, you can't touch the internals of any of the types nor the internals of done/yield/schedule
06:28:47 <jethr0> also, you could change "runGraphics (\n do" to "runGraphics $ do"
06:28:53 <jethr0> and get rid of the closing paren
06:29:04 <roconnor> mmorrow: do I get to modify GHC?
06:29:08 <cdiem> thanks, quicksilver :)
06:29:11 <mmorrow> roconnor: heh
06:29:20 <byorgey> cdiem: the rule is, the first thing following 'do' determines the indentation for that block
06:29:23 <roconnor> to throw in my own optimizations?
06:29:28 <ksf> ...but that's line 14.
06:29:29 <byorgey> cdiem: everything else in the do-block must be aligned underneath that
06:29:51 <Philonous> I wonder, if I want to dive into the world of dependent types, should I rather learn ATS or Agda?
06:30:01 <mmorrow> roconnor: echo -ne '#!/bin/sh\necho "Segmentation fault";exit 1" > ghc && chmod 755 ghc
06:30:20 <byorgey> Philonous: Agda is more similar to Haskell, I think.
06:30:25 <roconnor> the only safe use of unsafeCoerce I've seen was to cast one polymorphic variable to another polymorphic variable when it was known that the two variables must be equal.
06:30:40 <ksf> roconnor, there's more.
06:30:44 <cdiem> thanks; had no idea
06:30:48 <mmorrow> roconnor: yes, there are more
06:30:53 <cdiem> fixing it :)
06:30:59 <ksf> e.g. unsafeCoerce :: Fload -> Word32
06:31:10 <byorgey> Fload?
06:31:13 <maltem> Wait, ATS isn't a full-blown dependent types language, or is my memory mistaken?
06:31:13 <Philonous> byorgey: ATS is more ML-ish?
06:31:17 <ksf> the other one I know about is a _really_ dirty hack
06:31:32 <roconnor> there might be more, but mmorrow's code isn't an example (AFAIU).
06:31:54 <ksf> ...it's instance MonadFix STM where mfix = unsafeCoerce fixIO
06:32:02 <Philonous> maltem: according to the ATS site "In particular, both dependent types and linear types are available in ATS"
06:32:10 <byorgey> Philonous: yes
06:32:46 <Philonous> I don't know. Maybe I should learn myself some ML
06:32:52 <roconnor> ksf: hmm, unsafeCoercing across newtype definitions *might* be safe.  I'm not certain.  It certainly would be useful though.
06:33:20 <ksf> ...well I can say that it works.
06:33:26 <dolio> What's possible with the dependent types in ATS isn't that different than what's technically possible with lots of GHC extensions.
06:33:33 <ksf> STM and IO are both ST's.
06:33:41 <roconnor> ksf: oh, you've used it in one or two cases, so it must work all the time then?
06:33:49 <maltem> Philonous, ah ok, then I presumably had had a false expression by looking at code examples
06:34:01 <dolio> The type language in ATS is nicer to work with, of course.
06:34:11 <quicksilver> unsafeCoerce has no specification
06:34:17 <quicksilver> so what are we trying to do?
06:34:23 <quicksilver> guess or reason or describe GHC?
06:34:23 <lilac> roconnor: unsafeCoerce is safe for converting an existential to a specific type, once you know what type it really is
06:34:31 <ksf> nah, I was thinking about how to deal with STM's lacking monadfix, already considered refactoring my code, thought of the hack, and was surprised it worked.
06:34:55 <roconnor> lilac: that would be a safe use, not too far difference from my polymorphic variable example.
06:35:23 <Philonous> dolio: So do you suggest going for Agda instead?
06:35:28 <roconnor> ksf: just because something worked in one run, doesn't actually mean it is safe.
06:36:01 <ksf> sure as hell it's unsafe.
06:36:14 <mmorrow> roconnor: the only way you can segfault with unsafeCoerce is if you trick the flow of execution to enter a function as if it was a constructor
06:36:16 <dolio> Philonous: It depends what you want to do. If you want to write real programs that perform well, but prove some stuff about them, ATS is on a short list.
06:36:28 <roconnor> quicksilver: I think we are trying to give a spec to unsafeCoerce that is consistent with the behaviour of GHC.
06:36:29 <ksf> ...injecting the side-effects of one monad into the other.
06:36:35 <ksf> semantically it's a nightmare.
06:36:47 <ksf> ...operationally things are quite likely to work just fine.
06:36:53 <mmorrow> quicksilver: yeah, assuming knowledge of ghc implementation details
06:37:05 <roconnor> mmorrow: so why does my extraced Coq code segfault (only with -O2) ?
06:37:21 <mmorrow> roconnor: Coq must be Doing It Wrong(TM)
06:37:35 <mmorrow> roconnor: but really though, i'd be interested to see the segfaulting code
06:37:43 <roconnor> mmorrow: right, the provably correct code must be wrong.
06:37:53 <byorgey> roconnor: but that is IMPOSSIBLE, your code has been PROVEN CORRECT!!  ;)
06:38:06 <ksf> roconnor, because ghc is assuming the code it compiles was generated by a dumb enough proofer so it makes certain assumptions?
06:38:14 <mmorrow> roconnor: it's wrong because Coq is making an incorrect assumption about the implementation of the language it's extracting to
06:38:39 <roconnor> mmorrow: ya, and the assumption was that it was safe to coerce to and from ().
06:38:50 <roconnor> mmorrow: which is your assumption
06:38:55 <roconnor> mmorrow: which is why your code isn't safe.
06:39:06 <mmorrow> roconnor: what is the intermediate type?
06:39:12 <mmorrow> forall a. a?
06:39:15 <roconnor> no
06:39:17 <mmorrow> i'm not making that assumption
06:39:17 <roconnor> ()
06:39:23 <mmorrow> then unsafeCoerce is id
06:39:33 <mmorrow> there has to be some intermediate type here
06:39:34 <quicksilver> unsafeCoerce is not safe for converting existentials by the way
06:39:42 <quicksilver> not if there is a class context
06:39:44 <quicksilver> (AFAIK)
06:39:51 <quicksilver> but it *is* safe for newtypes
06:39:55 <roconnor> type S o = Label (M o) (Maybe ())newtype Cxt o a = Cxt {unCxt::Label (M o) (Maybe (Either (Task o a) a))}
06:40:01 <roconnor> type S o = Label (M o) (Maybe ())
06:40:02 <roconnor> newtype Cxt o a = Cxt {unCxt::Label (M o) (Maybe (Either (Task o a) a))}
06:40:12 <lilac> quicksilver: isn't that how Data.Dynamic works?
06:40:18 <quicksilver> no
06:40:25 <quicksilver> it unsafeCoerces the actual type
06:40:30 <quicksilver> not the existential around it
06:40:35 <Saizan> and uses GHC.Any inside
06:40:36 <mmorrow> Label (M o) (Maybe ()) ----> Label (M o) (Maybe (Either (Task o a) a)
06:40:37 <mmorrow> then
06:40:38 <roconnor> are you unsafeCoercing from Label (M o) (Maybe ()) to Label (M o) (Maybe (Either (Task o a) a))
06:40:44 <ksf> mhhh just use Ptr instead of hacking around with ()?
06:40:46 <mmorrow> Label (M o) (Maybe ()) <----- Label (M o) (Maybe (Either (Task o a) a)
06:40:57 <lilac> quicksilver: right, that's what i meant!
06:41:06 <roconnor> mmorrow: so Either is the intermediate type?
06:41:18 <quicksilver> GHC doe some optimisations on types with small numbers of constructors
06:41:21 <mmorrow> roconnor: that's the top-level, yes
06:41:26 <lilac> unsafeCoercing a box to the type of the value in the box obviously is unlikely to work
06:41:27 <quicksilver> so that's why I'd worry about ()
06:41:36 <roconnor> mmorrow: how is that any more safe than using () as an intermediate type!
06:41:43 <mmorrow> sigh
06:41:44 <lilac> mmorrow: it's pretty easy to get unsafeCoerce to segfault
06:41:44 <mmorrow> :)
06:42:21 <quicksilver> having said that I think that mmorrow's usage probably is safe
06:42:33 <quicksilver> but I certainly don't know for sure
06:42:34 <mmorrow> either way, using Any would clear up any ambiguity
06:42:42 <jethr0> is there a way to reexport qualified imports? i hate doing "import qualified Data.Map as Map" in every one of my modules, again and again
06:42:48 <mmorrow> quicksilver: yeah, neither do i ;) i just like arguing with roconnor
06:42:56 <mmorrow> roconnor: ;)
06:43:07 <quicksilver> jethr0: no.
06:43:11 <jethr0> oh ;(
06:43:22 <quicksilver> jethr0: (yes, it's annoying)
06:43:29 <ksf> why do you need to import map in every of your modules, anyway?
06:43:38 <roconnor> quicksilver: whatever unsafeCoerce's specification ought to be, I'm pretty sure mmorrow's code doesn't satisify it.
06:43:39 <lilac> i'd be extremely dubious of any code which actually /uses/ a value at a coerced type different from the type it was constructed at
06:43:58 <roconnor> mmorrow's code **might** be safe in GHC 6.10 in particular.
06:44:00 <quicksilver> lilac: it doesnt use it.
06:44:04 <roconnor> if he is very lucky
06:44:05 <jethr0> ksf: i need it in many
06:44:11 <quicksilver> lilac: it coerces away the rubbish to make a Monad instance possible
06:44:22 <quicksilver> lilac: and then coerces the rubbish back in when it wants it back
06:44:26 <quicksilver> if I understood correctly :)
06:44:29 <ksf> ...that's what I dare to doubt.
06:44:30 * lilac reads back
06:44:31 <jethr0> because i am using a Map for world state storage and do a lot of Map.insert and Map.delete on it
06:44:56 <ksf> you could do a Foo.WorldStorage module and re-export what you need.
06:45:01 <ksf> ...plus some boilerplate.
06:45:34 <mmorrow> roconnor: Anyfied http://moonpatio.com/repos/Scheduler.hs
06:45:38 <jethr0> ksf, true. would have been easier to just have "Map." imported in the whole project. doesn't hurt after all
06:45:39 <ksf> which has the additional benefit of you being able to change worldstorage's implementation while keeping the rest of your code the same.
06:45:43 <roconnor> but we have already established that GHC does type based optimizations, so lying about the type, even temporarily, is unsafe.
06:45:44 <quicksilver> jethr0: well, the general suggestion is you make your own primitives like "addThisToTheWorld" and "getThatFromTheWorld"
06:45:57 <quicksilver> jethr0: to hide behind an abstraction layer the fact you are *actually* using map
06:46:03 <jethr0> quicksilver: yes, and i've done that to a degree. maybe i'm gonna do it more
06:46:06 <quicksilver> jethr0: because other modules shouldn't depend on implementation details.
06:46:17 <quicksilver> but yes, Map is so generaly useful you will still import it in loads of places :)
06:46:18 <jethr0> yes
06:46:43 <quicksilver> after all, almost every perl module will use a hash and almost every python module will use a dictionary
06:46:45 <mmorrow> roconnor: there's a distinction too whether or not you're ever using the data at the lied-about type or not
06:46:51 <quicksilver> associated collections are just handy things.
06:46:59 <roconnor> mmorrow: But you are coericing from Any, to a specific type, and then back to Any?
06:47:10 <quicksilver> roconnor: GHC's implementation says that every normal type is a pointer
06:47:19 <mmorrow> roconnor: i'm coercing from the correct type, to Any, then back to the correct type
06:47:22 <quicksilver> it is therefor safe, in GHC to unsafeCoerce to any other normal type
06:47:25 <quicksilver> and then back again
06:47:30 <quicksilver> the pointer is still tehre and still valid.
06:47:38 <etpace_> How can I find out what kind a typeclass expects?
06:47:39 <quicksilver> where "normal" type means, roughly, boxed type.
06:47:43 <roconnor> mmorrow: that seems inconsistent with what you said before.
06:47:47 <mmorrow> roconnor: i just need the unsafeCoerce to store that Lbl in the monad's state
06:47:56 <mmorrow> roconnor: how so?
06:47:59 <ksf> etpace_, ghci?
06:48:06 <ksf> :k, in particular.
06:48:08 <roconnor> mmorrow: you said you were not coercing to a unit type.
06:48:15 <roconnor> then you replaced the unit type with Any
06:48:23 <roconnor> and now you are saying you are coercing to an Any type.
06:48:26 <etpace_> :k Show doesn't seem to work
06:48:36 <mmorrow> roconnor: i replaced the part of the S type that was the lie with Any
06:48:38 <jethr0> :k Show
06:48:59 <jethr0> :t Show
06:49:01 <ksf> dunno, it was a guess.
06:49:01 <quicksilver> :i Show
06:49:12 <quicksilver> Show is not a value nor a type, it has neither type nor kind.
06:49:12 <roconnor> quicksilver: are function types normal types?
06:49:13 <jethr0> > "lambdabot?"
06:49:16 <quicksilver> roconnor: yes.
06:49:23 <roconnor> quicksilver: then you are wrong.
06:49:34 <quicksilver> roconnor: I am surprised.
06:49:38 <mmorrow> hehe
06:49:45 <tavelram> :t show
06:49:52 <quicksilver> roconnor: that is the basic principle on how polymorphism works in GHC
06:49:56 <quicksilver> uniform representation.
06:50:03 <quicksilver> roconnor: what is the counter example?
06:50:15 * lilac doesn't understand mmorrow's problem, nor mmorrow's code ;-)
06:50:18 <roconnor> quicksilver: Again, I've extracted coq-code, which coerces to and from () to get around the insufficent type system, and it segfaults when compiled with -O2
06:50:39 <mmorrow> roconnor: paste said code
06:50:41 <ksf> too much unboxing?
06:50:46 <lilac> what is Label?
06:50:48 <roconnor> quicksilver: the extraced code does not create any fancy unboxed types or anything.
06:51:02 <flux> coq can extract haskell code these days, or has it doen that for some time now?
06:51:04 <mmorrow> lilac: it's
06:51:08 <mmorrow> , src ''Label
06:51:10 <lunabot>  newtype Label m a = Lab ((a, Label m a) -> m ())
06:51:21 <sergio1> Hi! Nube question: Is it possible to write the following function without a lambda?
06:51:21 <sergio1> > pairWith p1 = (\e -> (p1,e))
06:51:33 <lilac> sergio1: pairWith p1 = (,) p1
06:51:35 <mmorrow> where the `m' is Cont-ish
06:51:37 <ksf> pairWith p1 e = (p1, e)
06:51:48 <ksf> or, more succinctly, pairWith = (,)
06:52:04 <ksf> ...all three are equivalent.
06:52:10 <mmorrow> lilac: Label just lets you grab the `k' in (callCC (\k -> ..)) and stick it somewhere that can escape from the callCC
06:52:10 <etpace_> Can somebody explain why ghc doesn't like things such as instance Foo String where? Why does it dislike String?
06:52:16 <lilac> in GHC 6.12, i think you can write 'pairWith p1 = (p1,)' as an extension
06:52:18 <mmorrow> and then resume later
06:52:23 <Vanadium> etpace_: String is a type alias for [Char]
06:52:24 <byorgey> etpace_: String is a type synonym
06:52:26 <ksf> etpace_, it's a type synonym.
06:52:32 <Vanadium> ... synomym. Yeah. SORRY.
06:52:42 <thaldyron> etpace_: but there's a flag for allowing type synonym instances
06:52:45 <Saizan> quicksilver: see the comment after type Obj = Any http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Dynamic.html
06:52:47 <byorgey> etpace_: you can allow it with {-# LANGUAGE FlexibleInstances #-} I think.
06:52:50 <roconnor> mmorrow: looking for said code
06:52:57 <ksf> -XTypeSynonymInstances
06:52:59 <byorgey> or is there a specific TypeSynonymInstances flag?  I forget.
06:53:07 <ksf> you could also try [Char]
06:53:21 <sergio1> lilac: I tried this, but it didn't work (but I'm in GHC 6.10)
06:53:22 <ksf> ...but then you might need FlexibleInstances.
06:53:28 <ksf> maybe you need both.
06:53:37 <ksf> just do what you're told (by ghc)
06:54:19 <etpace_> so it would accept [Char]?
06:54:36 <lilac> [Char] would need FlexibleInstances i think
06:54:41 <ksf> experiment trumps study.
06:55:07 <lilac> since IIRC normally you can only give instances for T a1 a2 ... where ai are variables
06:55:17 <sergio1> If I want all pairs of a list, I can use list comprehension, like so:
06:55:17 <sergio1> > Allpairs l = [(i,j) | i <- l, j <- l]
06:55:17 <sergio1> Now, if order does not matter, I would make do with "couples", i.e. I only want to compute the upper (or lower) triangle in the square grid of pairs (neglecting infine lists).
06:55:17 <sergio1> I came up with this, which works (or seems to, at least), but does not satisfy me, because it doesn't seem very haskellish (no higher-order)
06:55:18 <sergio1> [As you can see, this is where I have the (anonymous) function "pairWith" I asked a few minutes ago]
06:55:20 <sergio1> > couples [] = []
06:55:22 <sergio1> > couples (x:xs) = (map (\e -> (x,e)) xs) ++ couples xs
06:56:05 <jethr0> do you know if it is ok under windows to call "withSocketsDo" several times?
06:56:47 <quicksilver> Saizan: interesting.
06:57:13 <lilac> sergio1: something like: "concat . zipWith (map . (,)) l (tails l)" might do what you want
06:57:59 <quicksilver> Saizan: I wonder if it would be safe to use (exists a . a) ?
06:58:00 <lilac> sergio1: the idea being to pair up the nth element of the list with the nth-and-subsequent elements
06:58:04 <quicksilver> Saizan: presumably it would.
06:58:45 <PeakerWork> Baughn: if its not FRP, how could it possibly be useful? :-)
06:58:59 <PeakerWork> Baughn: (kidding, of course)
06:59:06 <RayNbow> couples xs = [(a,b) | (a:ys) <- tails xs, b <- ys] -- sergio1?
06:59:18 <quicksilver> Saizan: I also wonder why Dynamic isnt' simply an existential bounded over Typeable
06:59:50 <jethr0> > (\xs -> [(xs!!idx,j) | idx <- [0..(length xs)-1], j <- drop (idx+1) xs]) [1,2,3,4]
06:59:55 * roconnor sighs as he can't get it to segfault now.
07:00:02 <roconnor> there goes my whole point
07:00:03 <mmorrow> quicksilver: i think it may be because the Dyn implem pre-dates support for existential support in ghc?
07:00:13 <quicksilver> mmorrow: perhaps.
07:00:21 <lilac> roconnor: that's the risk with optimization-dependent segfaults. :)
07:00:26 <mmorrow> roconnor: heh
07:00:31 <jethr0> sergio1: this is a horrible implementation. but you could just use the fact that you only need to look at elements after-or-equal the first element for the second
07:00:32 <lilac> roconnor: have you tried adding/removing -fvia-C?
07:00:41 <roconnor> lilac: I've upgraded GHC, and a million things since I last did this
07:00:42 <jethr0> sergio1: mine (above) is horrible, that is
07:00:53 <PeakerWork> @hoogle set
07:00:58 <lilac> roconnor: have you tried turning it off and on again?
07:01:01 <PeakerWork> @src Dynamic
07:01:25 <roconnor> I will have to look at this again a bit later
07:01:33 <sergio1> RayNbow: Now, that feels haskellish! ;-)
07:01:35 <roconnor> I still claim it is unsafe!!
07:01:37 <roconnor> :D
07:01:49 <roconnor> unsafeCoerce is unsafe!
07:01:54 <RayNbow> sergio1: tails is your friend :)
07:02:40 <sergio1> For me, it's slightly easier to grasp than lilac's version which is even more haskellish!
07:03:28 <PeakerWork> mmorrow: I think the monad instance can be written a bit more nicely, using inM/inM2
07:04:12 <maltem> sergio1, fwiw, to my humble mind, there's nothing wrong with your original version either
07:04:41 <jethr0> how stupid that qualified imports can create a cycle...
07:04:56 <PeakerWork> what's up with lambdabot?
07:05:01 <sergio1> maltem: Except that recursion is explicit...
07:05:01 <jethr0> gone
07:05:02 <roconnor> how stupid is it that GHC can't handle cyclic imports?
07:05:05 <RayNbow> PeakerWork: it's dead again
07:05:30 <jethr0> roconnor: exactly. what's the big deal anyway. can't it just do an implicit "ifndef modulename; define modulename; endif"?
07:05:31 <PeakerWork> roconnor: at least it encourages layering software :)
07:06:39 <jethr0> i retract my comment. i had inadvertantly named my module also "Network" *face-palm*
07:12:45 <maltem> jethr0, I'd rather wonder why it cannot generate those hs-boot files itself
07:12:53 <jethr0> hs-boot?
07:13:11 <maltem> The existing, working, workaround for cyclic imports
07:13:23 <jethr0> ah
07:13:37 <maltem> I think there's a manual section on it somewhere
07:14:38 <Phyx-> well, I think it's because you would rarely need cyclic dependencies, most would say if you do need it, it's bad design
07:15:42 <maltem> maybe - I'd rather have compiler warnings instead of more source files, though
07:16:00 <jethr0> hmm, it can be somewhat annoying to either a) use type variables throughout or b) collect all "data" types in a Common.hs
07:16:11 <Saizan> maltem: they can't be inferred in general
07:16:26 <jethr0> but in principle i agree that good design will often not lead to cyclic module deps
07:16:30 <Saizan> maltem: there's a long discussion about this on the ghc trac
07:17:07 <maltem> Saizan: thanks, I'll have a look when I got enough time and interest ;)
07:17:14 <jethr0> is it possible to annotate only a single function argument?
07:17:29 <jethr0> like "function a (b::Int) c = 5+b"?
07:17:43 <mmorrow> quicksilver, roconnor: here's Data.Dynamic with existentials http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9151
07:17:43 <maltem> jethr0: there's an extension for that
07:17:56 <maltem> jethr0: I don't know, PatternSignatures or something
07:18:20 <mmorrow> PeakerWork: the Monad instance for M?
07:18:23 <jethr0> maltem: thx
07:18:31 <mmorrow> PeakerWork: (what is inM(2)?)
07:18:45 <mmorrow> PeakerWork: yeah, newtype wrapping is annoying..
07:18:50 <Cale> maltem: Heh, we could have an ad like the iphone ads "There's an app for that" -> "There's an extension for that"
07:19:06 <maltem> jehtr0: I suppose it can be considered a miss in the Haskell report
07:19:23 <sergio1> lilac: that should be: concat $ zipWith (map . (,)) l (tails l)
07:19:39 <RayNbow> @bot
07:19:39 <lunabot>  :o
07:19:51 <roconnor> :P
07:19:51 <RayNbow> Cale, could you perform CPR on lambdabot? :)
07:19:54 <maltem> Cale, heh, reminiscent of the @faq line
07:20:09 <sergio1> And it's still slightly off w.r.t. what I want (I don't want diagonal)
07:20:15 <jethr0> is there a page with all the available ghc extensions. i'm right now looking in the manual, but it's large...
07:20:15 <lilac> sergio1: yes, i was anticipating doing 'concat . zipWith (flip(map.(,))) <*> tails' but i decided that would have been unfriendly
07:20:16 <sergio1> That should then be:
07:20:26 <sergio1> > concat $ zipWith (map . (,)) l (tail (tails l))
07:21:03 <lilac> , let l = [1,2,3,4] in concat $ zipWith (map . (,)) l (drop 1 (tails l))
07:21:04 <lunabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
07:21:05 <sergio1> lilac: unfriendly, that is! ;-)
07:21:06 <jethr0> damn, there is many of those extensions
07:21:10 <mmorrow> quicksilver, roconnor: i'm not sure if existentials are kosher for Dynamic actually, on account of `dynApply'
07:21:24 <jethr0> lilac: that doesn't include the diagonal
07:21:29 <rovar> wow
07:21:34 <lilac> jethr0: sergio1 doesn't want the diagonal
07:21:39 <jethr0> ah, k
07:21:45 <Saizan> Cale: can you check if lambdabot is stuck because of a looping djinn?
07:21:56 <doserj> jethr0: http://hackage.haskell.org/packages/archive/Cabal/1.6.0.3/doc/html/Language-Haskell-Extension.html ?
07:21:57 <rovar> I just tried to sign up on github, and got this warning message upon entering a private key: Key is already taken. All keys must be unique.
07:22:01 <Saizan> Cale: and pull my patch for popen from the repo
07:22:04 <yaxu> I'm trying to "cabal install chart" but it fails to find the 'cairo' and 'gtk' packages, which indeed aren't listed in hackage as far as I can tell
07:22:08 <jethr0> thx
07:22:22 <Cale> It's apparently trying to log in, but isn't managing to.
07:22:37 <Saizan> yaxu: http://www.haskell.org/gtk2hs/download/
07:22:42 <jethr0> is there a way to enable an extension for all modules of a "project" apart from passing it to ghc on the command line?
07:23:15 <jethr0> cale: shouldn't such processes fork off and return asynchronously when done?
07:23:37 <Cale> jethr0: huh?
07:24:05 <Saizan> jethr0: put it in the extensions: field in the .cabal file
07:24:05 <yaxu> Saizan: thanks
07:24:16 <Cale> jethr0: Lambdabot is just run in a simple loop in a shellscript so that it restarts if anything causes it to die. Just saves me the trouble of logging in, it's nothing sophisticated.
07:24:18 <jethr0> lambdabot, trying to log in, stuck? maybe i wasn't quite on the same page
07:24:28 <jethr0> ah, k
07:25:13 <Saizan> mh, so maybe it wasn't a looping djinn the problem
07:25:25 <Cale> and *of course* the seen state is messed up
07:25:32 <Cale> But I'm not sure if that's all.
07:25:57 <Saizan> we could just remove the seen plugin at this point..
07:26:08 <Cale> good idea.
07:26:41 <mmorrow> preflex has a good seen too
07:26:49 <mmorrow> s/good/better/
07:26:50 <Saizan> btw, which version of ghc is there on that machine?
07:26:58 <mmorrow> preflex: see preflex
07:27:11 <mmorrow> :(
07:27:22 <Saizan> heh
07:27:22 <Cale> I'll check once this build is done
07:27:22 <mmorrow> preflex: seen Saizan
07:27:23 <preflex>  Saizan was last seen on #haskell 1 second ago, saying: heh
07:27:29 <mmorrow> preflex: seen preflex
07:27:30 <preflex>  what
07:27:34 <Cale> It's at least 6.10.x
07:27:48 <Cale> preflex: seen what
07:27:48 <preflex>  Sorry, I haven't seen what
07:28:00 <mmorrow> preflex: seen lambdabot
07:28:01 <preflex>  lambdabot was last seen on #haskell 8 hours, 55 minutes and 34 seconds ago, saying: optimization suspended, use @pl-resume to continue.
07:28:05 <mmorrow> heh
07:28:20 <bla123> preflex: seen anyone
07:28:20 <preflex>  Sorry, I haven't seen anyone
07:28:22 <jethr0> heh
07:28:56 <jethr0> not sure PatternSignatures will allow me to write "fun a (b :: Int) c = ..." though
07:29:24 <Saizan> try :)
07:29:47 <jethr0> is there a wildcard type? can i write sth like "fun :: _ -> Int -> _ -> Int"?
07:30:15 <Vanadium> As opposed to a -> Int -> b -> Int?
07:30:17 <jethr0> nope
07:30:23 <jethr0> up
07:30:23 <jethr0> ups
07:30:26 <jethr0> hehe
07:30:30 <Saizan> jethr0: no, you can't
07:30:45 <dolio> UHC lets you write partial type signatures, as I recall.
07:30:57 <jethr0> Vanadium: now i feel silly. i just have never used "a" in a place that had a definite type
07:31:39 <Saizan> you can't use 'a' to mean some unspecified but fixed type
07:32:01 <jethr0> oh, why not?
07:32:07 <Saizan> if you use 'a' you must be polymorphic in that argument
07:32:33 <Saizan> because foo :: a -> Bar really means foo :: forall a. a -> Bar
07:32:54 <Vanadium> I figured he was going to do something like f _ v _ = v
07:32:59 <Saizan> so foo must work for all 'a'
07:33:37 <jethr0> i have to give a type for one argument but can't be bothered to write out the (long) types of the other arguments
07:33:49 <jethr0> which ghc is quite capable of determining itself
07:34:11 <Saizan> right, there's no good solution for that, except PatternSignatures i guess
07:34:28 <jethr0> Saizan: do you know how to use PatternSignatures in this context?
07:34:46 <Saizan> "fun a (b :: Int) c = ..." <- have you tried this?
07:34:58 <jethr0> in ghci it didn't work
07:35:10 <jethr0> parse error in input "="
07:35:22 <Saizan> well, in ghci you can't define functions like that alltogher
07:35:35 <Saizan> you must use "let foo a (b :: Int) c = .."
07:35:37 <jethr0> i'll try with compiled code
07:35:41 <Saizan> it's like being in a do-block
07:36:40 <jethr0> cool, worked
07:36:47 <jethr0> Warning: -XPatternSignatures is deprecated: use -XScopedTypeVariables or pragma {-# LANGUAGE ScopedTypeVariables#-} instead
07:36:49 <jethr0> though
07:37:11 <dolio> ScopedTypeVariables really makes no sense for that.
07:37:59 <jethr0> weird, so one is deprecated and its "successor" does a completely different thing ;)
07:38:00 <Saizan> sense is overrated
07:38:27 <Saizan> the successor includes the old behaviour, but has a weird name :)
07:38:53 <jethr0> works with ScopedTypeVariables, though
07:41:20 <roconnor> quicksilver: http://www.haskell.org/pipermail/glasgow-haskell-users/2006-October/011311.html
07:41:33 <roconnor> ``
07:41:35 <roconnor> you should be careful not to cast a
07:41:36 <roconnor> function value to a non-function type (except a polymorphic type), because the
07:41:38 <roconnor> two have incompatible representations when it comes to seq and case.
07:42:46 <roconnor> ah, no wonder I wasn't segfaulting
07:43:02 <roconnor> I was using my patched code replacing () with (()->())
07:44:02 <lilac> jethr0: oleg has a trick. f | False = unknown :: a -> Int -> b -> Int | otherwise = \a b c -> ...
07:44:39 <Le-Chuck_ITA> Heya all! I am looking for the "obvious" proof that in adjunctions, (f#)b equals to  f, that is how do I get an isomorphism of homsets from the unit
07:44:54 <jethr0> lilac: oh cool, i've seen this before but had completely forgotten about it
07:45:05 <Le-Chuck_ITA> It seems obvious for everybody and sorry for the incursion in the haskell channel but it seems the only channel where somebody speaks about categories sometimes :)
07:45:14 <lilac> jethr0: i've been meaning to file an enhancement against GHC for something similar...
07:45:49 <lilac> jethr0: "f ~:: a -> Int -> b -> Int" where ~:: means "is approximately of type", and doesn't add implicit foralls.
07:45:57 <Cale> Le-Chuck_ITA: I don't understand that notation...
07:46:28 <Cale> Le-Chuck_ITA: What is f# and what is b?
07:47:42 <Le-Chuck_ITA> Cale: I start from an universal arrow n: a -> UFa where U is right and F left adjoint, then for all f : a -> Ub we have f# : Fa -> b such that Uf#  n = f
07:48:49 <Le-Chuck_ITA> and similarly for each g: Fa -> b we have g^b : a -> Ub but b is not a good symbol, it is the "flat" that I don't have on the keyboard
07:49:21 <lilac> 
07:49:22 <Le-Chuck_ITA> now # and b must define an isomorphism of the two homsets a-> Ub and Fa -> b but I can't actually prove that it's an iso
07:49:33 <lilac> hmm, no, not that one ;-)
07:49:36 <Le-Chuck_ITA> liliac that's the sharp or did I confuse the terms?
07:49:43 <lilac> that's the natural :)
07:51:25 <quicksilver> roconnor: thanks
07:52:20 <quicksilver> roconnor: good question : http://www.haskell.org/pipermail/glasgow-haskell-users/2006-October/011327.html
07:52:21 <Cale> I would normally just use Phi(g)
07:52:26 <quicksilver> roconnor: (which no one answers :P)
07:52:31 <Cale> (as far as notation goes)
07:52:38 <FunctorSalad> Le-Chuck_ITA: you use the uniqueness in the universal property
07:53:10 <Cale> Yeah, isn't sharp already required to be a bijection?
07:53:25 <Cale> You just want the inverse function don't you?
07:53:28 <FunctorSalad> if you start with an adjunction, yes. but he starts with the univ. prop
07:53:51 <Cale> ah, okay
07:53:58 <FunctorSalad> hmm OTOH he seems to have "flat" already
07:55:02 <FunctorSalad> Le-Chuck_ITA: you only need one universal property, not both, btw
07:55:28 <FunctorSalad> (but there must be a universal morphism for each "a", in your notation)
07:55:56 <Le-Chuck_ITA> I will first derive b from #, thing that I did not do
07:56:40 <Cale> brb
07:57:08 <FunctorSalad> Le-Chuck_ITA: given f: a -> Ub, assume you have both g0 and g1 such that U gi . n = f
07:57:51 <FunctorSalad> or wait, in that direction there is nothing to show since it's unique by assumption ;)
07:58:14 <FunctorSalad> you just need to show that # is surjective
08:00:06 <PeakerWork> mmorrow: inM is something I picked up from conal:  inM f = M . f . unM ;   and inM2 f = inM f . unM
08:00:12 <Le-Chuck_ITA> FunctorSalad: that's another way to state the same headache :)
08:00:29 <PeakerWork> mmorrow: then, you can use (<*>) = inM2 (<*>) for example, and fmap = inM fmap
08:00:38 <PeakerWork> mmorrow: not sure about bind though
08:00:42 <FunctorSalad> so you have g:Fa -> b, show that (U g . n)# = g
08:02:55 <jethr0> is there a good way to pass a constructor to match? like "match cstr x = case x of {cstr{} -> True; _ -> False}"
08:03:12 <jethr0> or do i have to write "isCstr" functions? i guess SYB has a solution for this...
08:03:26 <lilac> jethr0: isCstr is what i'd do.
08:04:15 <lilac> jethr0: with ViewPatterns: match cstr (cstr -> True) = True; match _ _ = False
08:04:16 <FunctorSalad> Le-Chuck_ITA: I agree it is extremely confusing even though it is a "self-proving theorem"
08:04:22 <lilac> jethr0: of course, in that case, it's just match = id, but...
08:05:03 <FunctorSalad> (you just use uniqueness for that last identity, again)
08:05:08 <jethr0> are ViewPatterns already in GHC?
08:05:38 <lilac> yep. {-# LANGUAGE ViewPatterns #-} iirc
08:05:44 <iabal> jethr0: yep
08:05:54 <jethr0> cool, i've wanted to try them out for a while
08:07:09 <FunctorSalad> Le-Chuck_ITA: so given this g, you insert f := (U g . n) into the assumption. you get that there is a unique solution to "U ___ . n = f". but g itself is that solution, so f# = g
08:07:47 <FunctorSalad> it's ridiculous but I need to rethink that every time ;)
08:09:07 <Le-Chuck_ITA> FunctorSalad: got the first part for now, and yes, I looked at this many times, but I never looked at every possible detail.
08:09:10 <hackagebot> cpphs 1.9 - A liberalised re-implementation of cpp, the C pre-processor. (MalcolmWallace)
08:09:52 <lilac> what does it mean when cabal says "base-4.0.0.0 was excluded because of the top level dependency base -any" and what can i do about it?
08:11:40 <bla123> ghc's type checker doesn't want to play my multiparamtypeclasses-game: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9152#a9152
08:12:49 <Saizan> bla123: unless you use functional dependencies, all the type parameters of a class must appear in the type signature of all the methods
08:13:18 <quicksilver> bla123: in particular, because the signature for "op" doesn't include any mentions of 'k'
08:13:23 <Cale> bla123: The k type parameter in the class declaration isn't used by any of the methods, so there's no way that the typechecker could ever tell that it can apply an instance.
08:13:25 <quicksilver> bla123: GHC has no way to see what 'k' you want.
08:13:42 <quicksilver> Saizan: I believe he doesn't want fundeps. the whole point of this game is to make two instances for the same type
08:13:48 <bla123> that's why i introduced the k parameter
08:14:01 <quicksilver> bla123: you could add a k paramter to 'op' just like you did to 'calc'
08:14:02 <bla123> i thought i could force the right instance of Monoid with it
08:14:08 <lilac> bla123: GHC knows that it has a 'Monoid k a' in scope, but it doesn't know that 'k' is the same one you're using in 'op'.
08:14:10 <Cale> bla123: Better to wrap the type with a newtype to select the instance.
08:14:15 <Saizan> quicksilver: i added it for correctness :)
08:14:37 <quicksilver> bla123: (and to ident as well)
08:15:00 <bla123> ghci derives a different type for calc
08:15:19 <bla123> why des ist reject (Monoid k a) => k -> ...
08:15:25 <quicksilver> because
08:15:35 <quicksilver> it doesn't know to use that k
08:15:43 <quicksilver> just making a paramter doesn't make it use it for 'op' and 'ident'
08:15:44 <lilac> bla123: it doesn't know that k is the same one that is used in 'op'.
08:15:57 <bla123> ah, i see
08:16:20 <lilac> bla123: op uses 'Monoid x a' for some x. you're giving it 'Monoid k a' for some specific k. it doesn't know that k and x are supposed to be the same
08:16:21 <bla123> but without an explicit type signature, it compiles (though it cannot be used)
08:17:18 <lilac> i would have thought you'd get an error in the class definition to be honet
08:17:18 <Cale> bla123: There's no way that it can prove that they're the same. You might be able to get away with using the scoped type variables extension and putting an explicit type signature on op
08:17:29 <quicksilver> no
08:17:33 <quicksilver> because op doesn't mention k ;)
08:17:35 <Cale> No, the class definition is fine, it's just silly.
08:18:07 <lilac> Cale: it looks like 'ident' and 'op' cannot be called. ever.
08:18:30 <quicksilver> I think class definitions which have methods you can't use should be illegal
08:18:43 <quicksilver> class Foo a where { foo :: Int } -- useless, should be rejected
08:18:49 <bla123> could they be called with an explicit type signature on every use?
08:18:53 <quicksilver> no.
08:19:07 <quicksilver> because the type signature does not mention k
08:19:13 <bla123> ok - i tried it and couldn't find one that works ;)
08:19:29 <bla123> i meant with a type signature that explicitly mentions k
08:19:41 <quicksilver> if you change the sigs of op and ident to mention k
08:19:46 <quicksilver> then you ca
08:19:47 <quicksilver> n
08:19:52 <bla123> but i don't see a way to write a valid type signature with that
08:19:57 <bla123> ok
08:20:38 <bla123> i think that solved my problem, thnaks Cale, quicksilver, lilac
08:20:49 <mmorrow> PeakerWork: ah nice
08:20:51 <lilac> hmm. ident' :: forall k. Monoid k a => k -> a; ident' k = (op :: Monoid k a -> k -> a)
08:20:59 <Cale> bla123: The usual trick is actually not that way, but to define newtypes to select instances.
08:21:18 <Cale> bla123: It's a little cleaner than passing extra parameters, typically.
08:21:20 <quicksilver> cale: "The ti must mention u"
08:21:20 <bla123> Cale: but then you have to box/unbox it all the time, right?
08:21:36 <quicksilver> Cale: so, actually, class Foo a where { foo : Int } is illegal haskell98
08:21:50 <quicksilver> there a sane MPTC implementation should have rejected bla123's code, IMO.
08:21:52 <Cale> bla123: Well... usually less than you have to pass an extra parameter.
08:22:24 <Cale> quicksilver: I suppose that's a reasonable point.
08:22:42 <Cale> quicksilver: It would be good to prevent people from defining unusable interfaces :)
08:23:00 <quicksilver> GHC correctly rejects class Foo a where { x :: Int }
08:23:15 <quicksilver> with the error "...mentions none of the type variables of the class Foo a
08:23:27 <Cale> bla123: Also, if it's a newtype, that runtime cost is typically nothing.
08:23:30 <bla123> well, i'd like to have interfaces with sth design by contract-like
08:23:39 <doserj> ghc requires *one* variable to be used, not all...
08:23:51 <Cale> bla123: (I say typically because if you have to map the wrapper/unwrapper over a list, then it's similar to map id)
08:23:56 <bla123> Cale: ok ... and it has the benefit that i can make it an instance of even more type classes
08:23:57 <quicksilver> doserj: but it should require all (in the absence of fundeps)
08:24:07 * doserj nods
08:24:39 <quicksilver> with fundeps it should require some set which determines them all
08:24:42 <Cale> bla123: and that you don't have to design the class initially to account for the parametrisation.
08:25:18 <Cale> Le-Chuck_ITA: So, did you get things sorted out?
08:25:19 <doserj> quicksilver: I guess ghc hq found that non-trivial enough not to do it...
08:25:45 <quicksilver> Cale: .... unless it fuses in which case it's free again
08:25:53 <quicksilver> doserj: it could at least do the easy correct thing for the no-fundep case
08:26:03 <quicksilver> doserj: especially since that case will be more common when people use ATs instead
08:26:39 <doserj> quicksilver: with ATs the notion of "used" is clearer than with fundeps
08:26:52 * quicksilver nods
08:27:15 <Cale> It seems that if there's a translation between MPTCs with fundeps and ATs, then there ought to be a way to lift things that we know about ATs to things we know about MPTCs.
08:27:16 <Saizan> even in the fundep case there's a standard textbook algorithm to determine if a set of variables is a "key" (in the relational databases sense)
08:27:37 <dolio> quicksilver: Seems unlikely that it'd be fused, since newtypes don't get erased from the language until after rewrite rules are done, no?
08:27:37 <lilac> weird. given 'newtype M k a = Monoid k a => M a', 'M ident :: (Monoid k a, Monoid k1 a) => M k1 a'
08:27:56 <lilac> i would have thought GHC could see the two ks were the same in that case
08:28:24 <quicksilver> dolio: that doesn't matter though
08:28:28 <Cale> Only the newtype needs the parameter...
08:28:36 <quicksilver> dolio: it would get fused to map (f . unBar)
08:28:38 <copumpkin> lambdabot is dead :(
08:28:39 <Cale> The class doesn't need it...
08:28:42 <quicksilver> dolio: ...and in that context, unBar is free
08:28:49 <dolio> Ah, true.
08:28:54 <Le-Chuck_ITA> Cale: almost: I know that (Ug  na)# = g, so defining gb = (Ug  na) I get my isomorphism. But it remains to prove that id# is couniversal and the definition of gb commutes on that sidde
08:29:30 <quicksilver> dolio: one case of interest, typically, is "inBar f = Bar . f . unBar" and "map (inBar g)"
08:29:45 <quicksilver> although tat's prefused anyway
08:29:50 <dolio> Yeah.
08:29:51 * quicksilver grins stupidly
08:30:08 <dolio> I guess you're unlikely to have a 'map Foo l' that isn't fused like that.
08:31:08 <Warrigal> > lines "foo\nbar"
08:31:17 <Warrigal> Ominous.
08:31:30 <Warrigal> Is that ["foo","bar"] or ["foo\n","bar"]?
08:31:45 <Saizan> , lines "foo\nbar"
08:31:46 <lunabot>  ["foo","bar"]
08:32:08 <Warrigal> , unlines ["foo","bar"]
08:32:09 <lunabot>  "foo\nbar\n"
08:32:15 <Warrigal> And there is a trailing newline there.
08:32:24 <Vanadium> Why is there no generic function that you can get lines out of by applying '\n'
08:32:45 <Saizan> Vanadium: Data.List.Split
08:32:49 <lilac> is it not possible to install lambdabot on ghc6.8 any more? (do i need to install an earlier version?)
08:33:52 <Saizan> lilac: you need to revert (possibly manually) the patch about using base-4, at least
08:35:04 <Saizan> or add a package that reexports base-3's Control.Exception as Control.OldException
08:35:22 <lilac> aha, lambdabot-4.2.2 seems to get further than lambdabot-4.2.2.1
08:42:31 <roconnor> mmorrow, quicksilver : okay, got segfaulting code now
08:42:41 <roconnor> @paste
08:42:54 <roconnor> http://hpaste.org/new
08:43:12 <quicksilver> ;)
08:44:20 <mmorrow> ghci> rnf (unsafeCoerce id :: Either (Maybe Int) ())
08:44:20 <mmorrow> Segmentation fault
08:45:19 <quicksilver> that's actually *using* the value though
08:45:31 <quicksilver> weren't we looking for a case where it segfaults even when you don't use it?
08:45:40 <mmorrow> hmm
08:45:47 * mmorrow tries to think how to do that
08:45:47 <quicksilver> or at least, you coerce it back again and then use it
08:46:02 <roconnor> Paste validation failed
08:46:03 <roconnor>    1. content must not be longer than 30000 chacters.
08:46:16 <copumpkin> aw
08:46:19 <quicksilver> yow
08:46:24 <quicksilver> not a very minimal example then roconnor ? ;)
08:46:41 <roconnor> mmorrow: that is not the sort of segfault I'm getting
08:46:52 <roconnor> $ runhaskell betaetared_main.hs 4 5
08:46:54 <roconnor> 625
08:47:00 <roconnor> $ ./betaetared_main 4 5
08:47:01 <roconnor> Segmentation fault
08:47:41 <roconnor> meh, I can't be bothered to make a smaller counter example.  Maybe I can use another paste site
08:48:20 <roconnor> hmm
08:48:27 <roconnor> my content shouldn't be more that 30000 characters
08:48:37 <roconnor> it's like 20000 characters
08:49:51 <roconnor> oh, it is 30008 characters
08:49:54 <roconnor> damn
08:50:03 <roconnor> let me cut out my test cases
08:50:17 <mmorrow> or just 8 blank lines..
08:51:15 <xci> roconnor does not use blank lines
08:51:31 <xci> waste of bytes
08:51:40 <roconnor> still not happy
08:51:54 * Le-Chuck_ITA bangs his head against the wall, making everybody in the office turn their heads
08:52:02 <lpsmith> you could give your test cases in a second paste :-P
08:53:35 <roconnor> mmorrow, quicksilver: http://pastesite.com/10257
08:53:39 <mmorrow> roconnor: this one accepts 60,000 chars and uses the same db (note: i wouldn't rely on this to exist after 5 minutes from now) http://hpaste.org/fastcgi/hpaste.test.fcgi/
08:54:53 <mmorrow> umm
08:54:58 <mmorrow> , let __ = 4 in __
08:54:59 <lunabot>  4
08:55:01 <mmorrow> heh
08:55:21 <roconnor> anyhow, if you replace all occurance of () with (() ->()) then I believe it won't segfault.
08:55:42 <roconnor> (because () is only used with unsafeCoerce)
08:56:16 <roconnor> (coq source code would make it's own unit type if it wanted to use a unit type)
08:57:36 <quicksilver> roconnor: is 625 the right answer?
08:57:41 <roconnor> > 4^5
08:57:47 <roconnor> , 4^5
08:57:48 <lunabot>  1024
08:57:53 <roconnor> , 5^4
08:57:54 * quicksilver nods
08:57:55 <lunabot>  625
08:57:57 <roconnor> er
08:57:59 <roconnor> yes?
08:58:07 <quicksilver> so it gets the right answer interpreted and segfaults compiled
08:58:08 <roconnor> maybe
08:58:09 <quicksilver> that's quite interesting :)
08:58:16 <roconnor> unless the right answer is 1024
08:58:19 <roconnor> :P
08:58:21 <quicksilver> ;)
08:58:28 <quicksilver> 50% chance then.
08:58:29 <copumpkin> sounds like something the ghc trac might be interested in :P
08:58:37 <quicksilver> copumpkin: it's documented though
08:58:44 <quicksilver> FSOV "documented"
08:58:48 <copumpkin> how so?
08:58:53 <mmorrow> Program received signal SIGSEGV, Segmentation fault.
08:58:53 <mmorrow> 0x0000000000465511 in stg_ap_ppp_fast ()
08:58:54 <quicksilver> "mentioined in a mailing list posting from SPJ"
08:58:58 <roconnor> it's known that you cannot coerce between function types and data types
08:59:02 <ray> @bot
08:59:02 <lunabot>  :o
08:59:03 <quicksilver> if the problem is what roconnor thinks it is.
08:59:07 <copumpkin> quicksilver: ah
08:59:09 <Saizan> in a comment inside Data/Dynamic.hs too
08:59:22 <roconnor> I'm not sure that sort of coercion is going on here, but it seems quite likely.
08:59:23 <quicksilver> ah well that's definitely documented then ;)
08:59:28 <copumpkin> quicksilver: still worth making a ticket about in case the almighty SPJ is a little less than almighty and slightly forgetful
08:59:49 <quicksilver>  /kick copumpkin heresy
08:59:53 <copumpkin> onoes
09:00:22 * sunglassedcopump whistles and reads a newspaper suspiciously
09:00:26 <roconnor> Now it is true that mmorrow's code isn't doing such function to data coercions.
09:00:51 <roconnor> however, who knows when GHC will change its internal represenations, breaking mmorrow's assumption.
09:01:24 <hackagebot> chp 1.3.0 - An implementation of concurrency ideas from Communicating Sequential Processes (NeilBrown)
09:01:44 <roconnor> now it is true that there is no official spec for unsafeCoerce
09:02:15 <roconnor> but I'm pretty sure we can carve out some safe area, like unsafeCoerce :: Int -> Int is actually safe to use.
09:02:28 <lpsmith> I'm not quite getting why this is a bug...  I mean, it's not difficult to write haskell code that behaves very differently when interpreted,  compiled,  or compiled with optimizations,  if you use unsafe* functions.
09:02:46 <lpsmith> But I'm all ears :-)
09:02:52 <quicksilver> roconnor: I think if in "Foo a", "a" is phantom, then unsafeCoerce :: Foo a -> Foo b should be safe.
09:02:58 <roconnor> maybe adding that unsafeCoerce across newType boundaries is safe.  This would be a very legit thing to want to do.
09:03:19 <roconnor> so we don't have to do (map (unwrap)) which does a cast in O(n) time.
09:03:36 <roconnor> quicksilver: I think I agree.
09:04:21 <roconnor> But I can't imagine a spec that would make mmorrow (or my coq code)'s use of unsafeCoerce safe.
09:04:50 <quicksilver> roconnor: I think the spec which makes them safe is the following:
09:04:52 <roconnor> Though I do think that using GHC.Any, might be safe enough.
09:05:24 <quicksilver> "If, by other rules you have deduced that unsafeCoerce :: a -> b is safe, then (unsafeCoerce :: a -> c) followed by some time later (unsafeCoerce :: c -> b) is safe.
09:05:41 <quicksilver> the ability to fact unsafe coercions by an arbitrary intermediate
09:05:48 <quicksilver> as long as you don't *USE* the intermediate
09:05:55 <quicksilver> ...e.g. don't don't don't call seq on it ;)
09:06:08 <quicksilver> s/fact/factor/
09:06:12 <Saizan> is the coq code calling seq on it?
09:06:17 <roconnor> quicksilver: that would be a nice spec, but obviously isn't what GHC does now.  And there are probably practical reasons for not wanting that.  You'd disable many optimizations making Haskell as bad as OCaml.
09:06:42 <quicksilver> roconnor: would you though? haskell already keeps representation uniform so that polymorphic functions work
09:06:50 <quicksilver> roconnor: am I not just plugging into this unformity
09:06:56 <roconnor> Saizan: nope.  Coq extraction doesn't generate any seqs
09:07:17 <quicksilver> "all boxed types are just represented by a pointer; as long as I never dereference the pointer, it doesn't matter what structure it poitns to"
09:07:23 <roconnor> quicksilver: do you litterally mean polymorphic variables?
09:07:45 <quicksilver> roconnor: I mean that functons like map :: (a -> b) -> [a] -> [b] are only compiled once
09:07:50 <quicksilver> roconnor: and yet, they work at all types
09:07:59 <quicksilver> roconnor: because GHC uses a uniform representation of all (boxed) types.
09:08:34 <Saizan> quicksilver: but it does something special for arguments known to be functions, it seems
09:09:13 <Saizan> otherwise there wouldn't be any comment in Data.Dynamic
09:09:13 <quicksilver> Saizan: in a sense it does and in a sense it doesn't.
09:09:17 <sunglassedcopump> doesn't it just mark it as having a different closure type?
09:09:32 <quicksilver> Saizan: you can pass a list of 'known functions' to "map"
09:09:35 <roconnor> quicksilver: if your c is some specif type, such as (), then GHC may want to do some type-based transformations based on that knowledge.
09:09:54 <roconnor> that it cannot do with your spec because that thing may not really have type ().
09:09:55 <quicksilver> Saizan: ...even though the code is compiled not believing they are known fnctions.
09:10:14 <quicksilver> roconnor: agreed. But I'm pretty sure GHC doesn't do many such optimisations at all
09:10:24 <roconnor> quicksilver: did you see my paste?
09:10:29 <Saizan> ,,but it does
09:10:29 <quicksilver> roconnor: the only one I can think of is spec-constr, and that only applies if you case the value.
09:10:30 <lunabot>  luna: parse error on input `but'
09:10:31 <roconnor> see the segfault?
09:10:37 <jethr0> is there an example of a UDP data transfer with haskell somewhere?
09:10:43 <quicksilver> roconnor: yes, I did, and I don't know exactly why it happens
09:10:50 <quicksilver> I'm not denying that it does
09:10:53 <roconnor> ok
09:10:53 <quicksilver> btu I am wondering why.
09:11:02 <quicksilver> Saizan: it should always be safe to use "generalised apply"
09:11:07 <quicksilver> Saizan: (although potenitally slower)
09:11:23 <quicksilver> Saizan: I thought it was always safe to lose the knowledge that something is a function
09:11:24 <roconnor> well, my understanding is the GHC does such transforms, but that is simply based on observing what has happend with my code.
09:11:29 <roconnor> perhaps there is some other explaination.
09:11:36 <quicksilver> roconnor: no, I agree with your reasoning.
09:11:42 <quicksilver> roconnor: I just wonder what they are :)
09:11:48 <quicksilver> I said "GHC doesn't do *many* such"
09:11:50 <quicksilver> not *any* ;)
09:11:54 <roconnor> oh and also replacing () with (()->()) prevents the segfault.
09:12:41 <roconnor> sorry, I read many as any
09:12:51 <Saizan> quicksilver: i guess by strictness analysis ghc can try to evaluate the value before it's coerced back into a function
09:12:53 <quicksilver> I thought you might have done.
09:13:06 <Saizan> quicksilver: and get into problems thinking it's a data
09:13:08 <roconnor> anyhow I need to go eat now.
09:13:10 <quicksilver> Saizan: but it shouldn't conclude that the parameter is strict
09:13:16 <quicksilver> Saizan: ...if we never use it.
09:13:16 <roconnor> let me know if you come to any conclusions
09:13:21 <quicksilver> Saizan: (except to unsafeCoerce back)
09:13:29 <quicksilver> Saizan: ...which was my proposed side condition.
09:13:50 <Saizan> quicksilver: if unsafeCoerce is strict and we use it on this value, then we're strict on the value
09:14:02 <quicksilver> unsafeCoerce isn't strict, is it?
09:14:16 <quicksilver> yes, it is.
09:14:17 <quicksilver> hmm.
09:14:23 <Saizan> i'd imagine it's as strict as id
09:14:34 <quicksilver> maybe if unsafeCoerce should be explicitly marked as non-strict
09:14:38 <quicksilver> maybe that would fix it? ;)
09:16:27 <jokerGTA> kmc are you there
09:17:24 <Saizan> we need a Simon for these discussions :)
09:18:38 <quicksilver> roconnor: I do agree that in future we might expect GHC to do more type-specific optimisations
09:18:46 <quicksilver> roconnor: ...so we might expect this to get less safe, not more.
09:19:17 <Tobsan> do you guys know how a Haskell programmer makes searching algorithms work faster?
09:20:00 <Tobsan> I suppose not; by seq-ing!
09:20:31 <jokerGTA> can i ask question please
09:20:56 <Tobsan> jokerGTA: go ahead!
09:21:07 <copumpkin> jokerGTA: you already used up your one-question-per-day quota, sorry
09:21:13 <copumpkin> :)
09:21:18 <jokerGTA> i saw examaple of this online and trying to undersatnd what and why it does it
09:21:23 <jokerGTA> hahaha
09:21:29 <jokerGTA> cool copumpkin:)
09:21:30 <jokerGTA> haha
09:21:48 <jokerGTA> [2..(sqrt)9]
09:21:58 <jokerGTA> returns [2.0,3.0]
09:22:18 <jokerGTA> [2..9] is same as [2,3,4,5,6,7,8,9]
09:22:34 <Vanadium> But sqrt 9 is clearly 3.0
09:22:34 <Saizan> , (sqrt) 9
09:22:35 <lunabot>  3.0
09:22:40 <quicksilver> sqrt makes it default to Double, not Int
09:22:40 <Saizan> , sqrt 9
09:22:41 <jokerGTA> i am cinfused by this function call inside the list
09:22:41 <lunabot>  3.0
09:22:48 <Vanadium> so [2.. sqrt 9] is the same as [2..3]
09:22:57 <quicksilver> the brackets are in a confusing place
09:23:01 <copumpkin> or [2..3.0]
09:23:03 <Petrosian> jokerGTA: read it as [2 .. (sqrt 9)]
09:23:05 <Vanadium> yesyes
09:23:05 <quicksilver> the effect is [ (2) .. (sqrt 9) ]
09:23:21 <jokerGTA> oh ok so basically  result is list of [2.0,3.0]
09:23:27 <jokerGTA> yeah ok i see that
09:23:48 <Le-Chuck_ITA> Cale: FunctorSalad how do I show that id# is a co-universal morphism. I think I am just tired but can't figure this out
09:23:57 <jokerGTA> thanks guys
09:25:12 <roconnor> "If, by other rules you have deduced that unsafeCoerce :: a -> b is safe, then (unsafeCoerce :: a -> GHC.Any) followed by some time later (unsafeCoerce :: GHC.Any -> b) is safe.
09:27:27 <mux> hello guys, I'm trying to write a generalized array class, which would automatically select unboxed arrays depending on the type of the elements in the array, similarly to how GMap selects an appropriate Map type depending on the type of the keys
09:27:27 <quicksilver> roconnor: that seems a safer approximation but it also offends me.
09:27:33 <mux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9155#a9155
09:27:52 <quicksilver> roconnor: I don't like special casing a GHC Prim ;)
09:27:58 <mux> that works to some extent, but it won't let me add an instance for any value since it would conflict with the instance for Int
09:28:00 <quicksilver> roconnor: maybe we can use (exists a . a)
09:28:05 <mux> even if I use overlapping instances
09:28:11 <mux> am I doing something wrong?
09:28:12 <FunctorSalad> Le-Chuck_ITA: hmm the way I'm familiar with, you show that (universal morphism for every object) <=> adjunction, with "adjunction" being obviously symmetric up to duality
09:28:37 <quicksilver> mux: yes. You can't do that.
09:28:43 <FunctorSalad> (an adjunction being defined as the natural iso of homsets here)
09:28:50 <quicksilver> mux: typeclasses don't permit specialization in that sense
09:28:54 <mux> quicksilver: simply, completely cannot do that?
09:29:06 <quicksilver> mux: there are tricks to solve what you're trying to solve
09:29:08 <mux> I'm confused as to how it works for GMap -- or does it?
09:29:13 <quicksilver> mux: but overlapping in that naive way is not wise
09:29:27 <thaldyron> Is it normal that printing 1 line of static debug info increases memory usage by 100%? That's what I get when running the toy program here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3532#a3533
09:29:45 <jokerGTA> copumpkin you still there??
09:30:26 <mux> quicksilver: how does GMap does it? or maybe GMap doesn't have a catch-all instance?
09:31:42 <jokerGTA> can anyone explain this function please
09:31:50 <Le-Chuck_ITA> FunctorSalad: will try a bit more in the metro and otherwise bang my head on the walls for the whole night :) Thanks a lot, your hint was precious.
09:32:10 <jokerGTA> proper_divisors n = [d | d <- [1 .. floor (n/2)], mod n d == 0]
09:32:37 <Lemmih> thaldyron: A thread can't be GCed as long as its ThreadId is around. Try computing the lenth of the tids before 'waitForAll'.
09:32:57 <FunctorSalad> Lemmih: you can show it directly too, but I mean usually you prove that equivalence anyway ;)
09:33:06 <FunctorSalad> (the universal morphism <=> adjunction one)
09:33:30 <mux> also, I was a bit surprised by the syntax of associated types; it seems weird to have to wrap the desired type into a constructor and use this constructor throughout the instance; I was expecting to just give the type directly
09:33:41 <mux> but maybe that would be associated type synonyms
09:34:04 <Lemmih> FunctorSalad: Wrong nick.
09:34:23 <jokerGTA> can anyone help me with something please
09:34:28 <FunctorSalad> Lemmih: right ;) Le-Chuck_ITA
09:34:32 <Zao> jokerGTA: Depends.
09:34:47 <Lemmih> jokerGTA: Don't ask to ask. Just ask your question.
09:34:53 <Zao> Lemmih: He already did.
09:34:56 <jokerGTA> Could you walk me trought this function  proper_divisors n = [d | d <- [1 .. floor (n/2)], mod n d == 0]
09:35:04 <thaldyron> Lemmih: Should "waitForAll tchan $! length tids" do the trick?
09:35:18 <Le-Chuck_ITA> FunctorSalad: I really need to understand the proof directly, it's the only way to properly understand adjunctions for me, even if I already use those I want to get rid of that "magical" feeling! Thanks a lot, I am now getting home
09:35:22 <Lemmih> thaldyron: It's the '  print ("Spawned # of threads: ",length tids)
09:35:26 <Zao> jokerGTA: It's a one-argument function that returns the result of a list comprehension.
09:35:32 <Lemmih> thaldyron: ' that's problematic.
09:36:00 <jokerGTA> what does d | d...do
09:36:07 <Le-Chuck_ITA> bye all
09:36:09 <Zao> jokerGTA: [x | x <- [1..10], even x]
09:36:17 <thaldyron> Lemmih: ups, I actually wanted to remove that print line anyway since it's not the one causing the memory blowup
09:36:42 <Zao> jokerGTA: It's a list comprehension, where it loops through all combinations of the lists to the right of the |, applies any predicates (like even), filtering out any elements that are false.
09:36:43 <jokerGTA> i knoeven numbers gets put into the x?
09:37:05 <Lemmih> thaldyron: It looks like that's the only change between the two programs.
09:37:21 <jokerGTA> what do you mean loops trough all combinations of the list
09:37:26 <roconnor> quicksilver: unsafeCoerce is already a GHC Prim =)
09:37:37 <Zao> > [x * y; x <- [1..3]; y <- [10..12]]
09:37:38 <jokerGTA> it can be only one combination which is 1..floor (n/2)
09:37:50 <Zao> Hrm, typo.
09:37:56 <Cale> jokerGTA: Basically, the 'even x' filters the list of choices for those where 'even x' is true.
09:37:59 <Zao> Who ate lambdabot?
09:38:05 <Cale> I did, sorry about that.
09:38:13 <copumpkin> om nom nom nom
09:38:33 <Zao> jokerGTA: 1..floor (n/2) gives the sequence of numbers from 1 to floor (n/2).
09:38:48 <Zao> Filtering out anything that does not satisfy mod n d == 0.
09:39:10 <Zao> That is, filtering out anything that doesn't divide it evenly.
09:39:49 <jokerGTA> oh ok but what function actually does the filtering
09:40:04 <jokerGTA> i mean what function gets rid of numbers that are not divisible
09:40:52 <Cale> jokerGTA: The definition of list comprehensions does... I suppose you can attribute it to concatMap
09:40:56 <Zao> The list comprehension.
09:41:19 <Zao> It does two things. It generates the combinations of all the lists, and applies predicates.
09:42:01 <jokerGTA> what part actually adds these elements to the new list which will be returned
09:42:27 <Cale> Here's how list comprehensions are defined:
09:42:38 <Cale> [ <expr> | True ] = [ <expr> ]
09:43:36 <Cale> [ <expr> | b, <gens> ] = if b then [ <expr> | <gens> ] else []
09:43:52 <jokerGTA> whats <gens>
09:44:08 <Cale> Some other sequence of generators and boolean expressions.
09:44:21 <jokerGTA> ok Cale
09:44:31 <jokerGTA> thanks..i guess ill have to play with this function again
09:44:55 <thaldyron> Lemmih: ah.. I didn't know hpaste saves the old version when you modify it. Anyway, the problematic line is the print in line 32. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3532#a3534  When it's commented out the program uses 20MB instead of 70MB...
09:44:57 <Cale> [ <expr> | p <- xs, <gens> ] = let ok p = [ <expr> | <gens> ]; ok _ = [] in concatMap ok xs
09:45:42 <Deewiant> ok p overlaps with ok _
09:45:43 <jokerGTA> thats even more complicated...at least it looks like it
09:45:50 <jokerGTA> :)
09:45:52 <Cale> Deewiant: p is any pattern
09:46:20 <Deewiant> Oh right, true
09:46:22 <Zao> You can have comprehensions like   [ x * 3 | x <- [42, 3, 5]]
09:46:28 <Cale> (so if p doesn't match one of the list elements in xs, that list element is skipped, effectively)
09:46:39 <Cale> > [ x*3 | x <- [42, 3, 5]]
09:46:42 <lambdabot>   [126,9,15]
09:46:46 <jokerGTA> ok zao what would be result of that function you just typed
09:46:51 <Cale> ^^ that
09:47:23 <Cale> You read it as "The list of x*3 where x is selected from [42,3,5]"
09:47:52 <jokerGTA> ok thank you guys..i am totally new to functional
09:50:13 <Lemmih> thaldyron: Does not printing out 'i' help?
09:52:56 <thaldyron> Lemmih: no, memory consumption stays more less the same ~69MB
10:00:14 <FunctorSalad> is this statement from the ghc user's guide still accurate?
10:00:20 <FunctorSalad> "The native code-generator is designed to be quick, not mind-bogglingly clever. Better to let GCC have a go, as it tries much harder on register allocation, etc."
10:00:43 <FunctorSalad> (I don't remember seeing -fvia-C being used in benchmarks recently)
10:00:45 <sjanssen> FunctorSalad: it is less true now
10:00:51 <FunctorSalad> (but I'm no expert)
10:04:50 <quicksilver> FunctorSalad: GHC now has a reasonable register allocator but due to some architectural choices it doesn't have many regs to work with on x86
10:05:01 <quicksilver> FunctorSalad: it apparently does much better on x86_64
10:05:13 <quicksilver> (which has many more general purpose registers)
10:06:24 <FunctorSalad> ok :)
10:11:45 <orbitz> dons: you are quick!
10:11:51 <hackagebot> WebBits-Html 1.0 - JavaScript analysis tools (ArjunGuha)
10:12:54 <hackagebot> JsContracts 0.5 - Design-by-contract for JavaScript (ArjunGuha)
10:15:24 <quicksilver> mux: (yes, you are using data not type)
10:16:12 <Lemmih> thaldyron_: It may just be the overhead of doing showing a string and printing it to stdout.
10:16:14 <quicksilver> mux: to understand why overlapping instances are unwise, consider a function which is *polymorphic* in e.
10:16:17 <ehamberg> is there a standard function for shuffling a list?
10:17:05 <quicksilver> mux: suppose that function calls 'array' to create a GArray. When compiling, GHC will look for a polymorphic instance of GIArray i e, and it will find one.
10:17:19 <Lemmih> ehamberg: http://hackage.haskell.org/package/random-shuffle
10:17:42 <azm> what means 5 /=5 ?
10:17:47 <quicksilver> mux: so, that function will be compiled using the polymorphic instance.
10:18:10 <quicksilver> mux: that menas that function will never select the specific instance for Int, even if it happened to get called using Ints.
10:18:17 <FunctorSalad> azm: 5 is not equal to 5?
10:18:32 <azm> ah,thanks
10:18:32 <quicksilver> mux: basically overlapping instances break in the presence of polymorphic functions.
10:19:05 <ehamberg> Lemmih: thanks, i'll have a look.
10:22:20 <jethr0> > 5 /= 5
10:22:21 <lambdabot>   False
10:22:47 <benmachine> > () == undefined
10:22:48 <lambdabot>   * Exception: Prelude.undefined
10:22:55 <benmachine> > () `mappend` undefined
10:22:56 <lambdabot>   ()
10:23:03 * benmachine finds this vaguely interesting
10:23:22 <quicksilver> the Monoid instance for () is not standard though
10:23:22 <jethr0> :t () `mappend` undefined
10:23:24 <lambdabot> ()
10:23:30 <quicksilver> although I can understand why you might want it
10:26:01 <c_wraith> () seems like kind of an identify monoid.  Not totally meaningless.  The fact that it doesn't evaluate its arguments is just an optimization.
10:26:47 <FunctorSalad> what is nonstandard about that?
10:27:01 <FunctorSalad> nevermind I see
10:27:09 <dolio> e * a is supposed to be a for monoids, though.
10:27:24 <dolio> So () `mappend` undefined should be undefined, if you want to get technical.
10:27:55 <FunctorSalad> maybe it's a monoid in the right category still ;)
10:28:20 <dolio> Of course, if you think Fast and Loose Reasoning is Morally Correct, then it's fine.
10:29:56 <FunctorSalad> bringing in CPOs isn't that outrageous for haskell, is it? ;)
10:32:31 <mmorrow> roconnor, quicksilver: i just hacked a quicky prog that uses haskell-src-exts to instrument a .hs (the added instrumentation uses vacuum and misc..), and the result's pretty neat. here's it on roconnor's prog:   http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3536
10:33:29 <mmorrow> (this started out as trying to pinpoint the segfault (which now ghc seems to catch ("PAP entered!") with the instrumentation added, not sure why))
10:36:01 <dolio> Well, problem solved, no more segfault. :)
10:36:13 <dolio> Just instrument all your extracted code.
10:36:28 <hackagebot> PortMidi 0.1.1 - A binding for PortMedia/PortMidi (PaulLiu)
10:36:43 <mmorrow> dolio: heh
10:37:46 <mmorrow> hmm, maybe it should wrap each param in ==> let x_ = unsafePerformIO (print stuff) `seq` x in .... subst x_ for x ....
10:38:11 <mmorrow> since then it'd more reflect the original code (even after ghc moves stuff around)
10:38:42 <mmorrow> and it's print when it's forced, rather than when the function ap that it's a param of is forced (which i think is what's happening now)
10:38:46 * copumpkin doesn't understand why let primes = minus [2..] $ foldr1 merge (map (\x -> map (x*) [2..]) primes) doesn't work as a sieve of eratosthenes
10:38:52 <mmorrow> *and it'll print when ...
10:39:05 <copumpkin> it never produces anything
10:39:16 <copumpkin> where minus and merge are from data-ordlist
10:40:09 <dolio> copumpkin: What does minus do? Does it know that the lists are sorted?
10:40:13 <copumpkin> yep
10:40:23 <copumpkin> set subtraction
10:40:44 <dolio> foldr1 merge may never terminate, then.
10:40:56 <dolio> That's probably the problem.
10:41:15 <copumpkin> oh good point
10:41:33 <copumpkin> hrm
10:42:11 <dolio> I'm not sure there's a good way to merge an infinite number of arbitrary lists.
10:42:27 <copumpkin> but they're sorted too
10:42:36 <dolio> I'm not sure that's enough.
10:43:01 <copumpkin> it seems like it should be able to start producing elements immediately
10:43:07 <copumpkin> unlike something like an intersection
10:43:10 <mmorrow> merge (repeat [1..] ++ [[0]])
10:43:12 <mmorrow> ?
10:43:23 <copumpkin> the assumption is that it is sorted
10:43:33 <copumpkin> the algorithms are only correct when the lists are sorted
10:43:33 <mmorrow> sorted in the horizontal direction?
10:43:35 <dolio> I'd look into diagonalization.
10:43:38 <dolio> That might work.
10:43:56 <mmorrow> , [$ty| diagonal |]
10:43:59 <lunabot>  forall a . [] ([] a) -> [] a
10:44:20 <copumpkin> what's that from?
10:44:26 <copumpkin> omega?
10:44:27 <mmorrow> , diagonal (fmap (\n->[n..]) [0..])
10:44:28 <lunabot>  [0,1,1,2,2,2,3,3,3,3,4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,...
10:44:31 <mmorrow> copumpkin: yeah
10:44:36 <dolio> Obviously if (x:xs) and (y:ys) are sorted, then x*y is the lowest of the products.
10:44:36 <mmorrow> , 'diagonal
10:44:37 <lunabot>  Control.Monad.Omega.diagonal
10:46:04 <copumpkin> hmm, still doesn't work
10:46:12 <copumpkin> oh maybe it does
10:46:43 <copumpkin> unfortunately it doesn't produce an ascending list
10:47:08 <dolio> , diagonal ((*) <*> [1..] <*> [2,6..])
10:47:09 <lunabot>  luna: Couldn't match expected type `[a2 -> a1 -> [a]]'
10:47:15 <dolio> , diagonal ((*) <R> [1..] <*> [2,6..])
10:47:16 <lunabot>  luna: Not in scope: data constructor `R'
10:47:18 <dolio> , diagonal ((*) <$> [1..] <*> [2,6..])
10:47:19 <lunabot>  luna: No instance for (GHC.Num.Num [a])
10:48:05 <copumpkin> , diagonal $ (*) <*> [1..] <*> [2,6..]
10:48:06 <lunabot>  luna: Couldn't match expected type `[a2 -> a1 -> [a]]'
10:48:12 <dolio> , diagonal [ [ x * y | y <- [2,6..] ] | x <- [1..] ]
10:48:13 <copumpkin> oh whoops
10:48:13 <lunabot>  [2,6,4,10,12,6,14,20,18,8,18,28,30,24,10,22,36,42,40,30,12,26,44,54,56,50...
10:48:29 <mmorrow> , let ascent y [] = [y]; ascent y (x:xs) | x < y = x : ascent y xs | otherwise = y : ascent x : xs in (ascent . diagonal) (repeat [0..])
10:48:30 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = [t] -> [t]
10:48:38 <mmorrow> , let ascent y [] = [y]; ascent y (x:xs) | x < y = x : ascent y xs | otherwise = y : ascent x xs in (ascent . diagonal) (repeat [0..])
10:48:39 <lunabot>  luna: No instance for (GHC.Show.Show ([[a]] -> [[a]]))
10:49:23 <copumpkin> I still can't see why merge isn't able to produce list elements without looking at everything
10:49:24 <mmorrow> , let ascent [] = []; ascent (x:xs) = let go y [] = [y]; go y (x:xs) | x < y = x : go y xs | otherwise = y : go x xs in go x xs in (ascent . diagonal) (repeat [0..])
10:49:25 <lunabot>  [0,0,1,1,0,2,2,1,0,3,3,2,1,0,4,4,3,2,1,0,5,5,4,3,2,1,0,6,6,5,4,3,2,1,0,7,...
10:49:28 <mmorrow> grr
10:49:45 <mmorrow> err, i guess that's impossible
10:50:04 <mmorrow> copumpkin: yeah, i think it can't without seeing everything
10:50:14 <copumpkin> mmorrow: why?
10:50:17 <copumpkin> oh
10:50:41 <copumpkin> because it needs to see if there's as smaller element somewhere before producing the next larger one I gues
10:50:45 <mmorrow> yeah
10:50:50 <copumpkin> bah :)
10:50:53 <mmorrow> grrr
10:51:34 <lpsmith> actually, there is a way to merge an infinite number of sorted lists,  assuming the smallest element of each list is also ascending.
10:51:56 <copumpkin> mr data-ordlist!
10:52:13 <mmorrow> yeah, if they're sorted both vertically and horizontally
10:52:32 <lpsmith> merges = foldr (\(x:xs) ys -> x : merge xs ys)  []
10:52:41 <lpsmith> I think that works
10:52:56 <kmc> can cabal-install play nice with the debian package managerV
10:52:59 <lpsmith> There is a way to do it with foldl as well, but its slow.
10:53:01 <kmc> *?
10:53:28 <lpsmith> :-)
10:53:45 <Saizan> kmc: define "play nice"
10:54:40 <lpsmith> but in general,  I think that dolio is right... you can't merge an infinite number of sorted lists without a few additional assumptions
10:54:41 <Saizan> there's a cabal2debian if you want to make .deb from cabal packages, not sure how automated it is
10:54:49 <kmc> okay
10:54:53 <copumpkin> minus [2..] $ merges (map (\x -> map (x*) [2..]) [2..])
10:54:54 <copumpkin> yay
10:55:00 <copumpkin> that works, but the recursive version doesn't
10:58:59 <jungehex`> jethr0:
10:59:33 <kmc> is there a reason not to run ghc HEAD for experimenting (not production stuff)?
11:00:50 <lpsmith> The problem with the original "foldr1 merge"  is that merge is that it's strict in it's second argument,   i.e.   merge [1,2] undefined == undefined
11:00:55 <dolio> It's a mild pain to build GHC yourself.
11:01:12 <lpsmith> kmc:  depends on how adventuresome you want to be.
11:01:15 <dolio> And it might be broken.
11:02:15 <copumpkin> lpsmith: yeah :/
11:02:35 <kmc> well, i have 6.10.4
11:02:41 <kmc> which should suffice to build HEAD i imagine
11:02:58 <kmc> how broken might it
11:02:59 <kmc> be
11:03:57 <lpsmith> kmc:  is there something specific in HEAD that you know you want,  or wish to play with?
11:04:53 <kmc> so dons's multicore slides said that some things worked better in HEAD
11:04:57 <kmc> and i'm always up for an adventure :)
11:05:48 <lpsmith> then go for it :-)
11:06:51 <lpsmith> (actually merge is strict in both arguments,  but the first argument doesn't matter for that particular application...)
11:07:29 <copumpkin> it has to though :/
11:09:04 <lpsmith> Actually, I think you can go asymptotically faster than merges...
11:09:45 <lpsmith> probably by some kind of adaptation of mergesort
11:10:28 <kmc> (which btw are excellent slides)
11:20:22 <Cale> Hmm... for preorders, a functor G: C -> D is a right adjoint functor if for each Y in D, the set of elements greater than Y in the image of G has a minimum element (up to order equivalence).
11:22:18 <Vargsvans> why do i get the error "non-exhaustive function" in this function: power2 n k |k > 1 = n * n * power2 n (div k 2)
11:22:38 <copumpkin> you don't have an otherwise
11:22:40 <Cale> Vargsvans: Is that your whole definition?
11:22:46 <copumpkin> what if k <= 1?
11:22:53 <Vargsvans> power2 :: Integer -> Integer -> Integer
11:22:53 <Vargsvans> power2 n 0 = 1
11:22:53 <Vargsvans> power2 n k |k > 1 = n * n * power2 n (div k 2)
11:22:59 <copumpkin> oh, it can't reason about that
11:23:08 <benmachine> what if k = 1
11:23:13 <skorpan> i smell n+k patterns coming right up
11:23:15 <Cale> Vargsvans: The k = 1 case isn't handled
11:23:32 <skorpan> actually, no, i don't
11:23:39 <Vargsvans> ok then maybe im diong this the wrong way
11:23:43 <Cale> That's a strange function...
11:23:47 <benmachine> n+k patterns weren't in my tutorial
11:23:52 <skorpan> n+k patterns are awful
11:23:58 <benmachine> that is probably why
11:24:50 <Cale> Vargsvans: Don't you mean (k-2) rather than (div k 2) ?
11:24:55 <Vargsvans> im trying to make a power function that uses less computing steps for even numbers
11:25:24 <lpsmith> I kind of like n+k patterns...
11:25:28 <Cale> If you want to divide the exponent, you'll want to square the whole thing, not multiply by n^2
11:25:36 <copumpkin> I'd like them more if they weren't so special
11:25:47 <kmc> aren't they a special case of view patterns?
11:25:55 <Cale> What you have there is similar to writing n^k = n*n*n^(k/2) which makes little sense :)
11:26:11 <copumpkin> they' particularly bother me because they magically don't work for negative numbers
11:26:41 <FunctorSalad> > let f ((-1)+1) = 1 in 0
11:26:42 <lambdabot>   <no location info>: Parse error in pattern
11:26:53 <FunctorSalad> > let f ((-1)+1) = 1 in f 0
11:26:54 <lambdabot>   <no location info>: Parse error in pattern
11:27:23 <Vargsvans> i want it to do this: (n^2)^(k/2)
11:28:00 <FunctorSalad> you're computing k^(2^n) or something
11:28:14 <Cale> Vargsvans: right, then that would be  power2 (n*n) (div k 2)  wouldn't it?
11:28:21 <FunctorSalad> no nevermind
11:28:35 <Cale> Vargsvans: also, make sure to check that k is even
11:28:42 <tavelram> Vargsvans, homework?
11:29:24 <copumpkin> Vargsvans: I'd avoid the guard altogether
11:30:28 <Vargsvans> Cale, but if i put it like: power2 n k |k > 0 = power2 (n*n) (div k 2)
11:30:57 <Cale> That's still quite wrong...
11:32:12 <Cale> You shouldn't have to test that k > 0, first of all, since if k was 0, another case would have matched. (Negative exponents should fail anyway.)
11:32:55 <Cale> Also, n^k = (n*n)^(k `div` 2) only if k is actually divisible by 2.
11:33:08 <Vargsvans> yes
11:33:48 <Cale> So you should use the guard to ensure that k is even.
11:34:08 <copumpkin> @src even
11:34:09 <lambdabot> even n = n `rem` 2 == 0
11:35:13 <Cale> In the case where n is not even, you just do the usual thing and multiply by n.
11:36:11 <Vargsvans> yeah, but how do i get this (n^2)^(k/2) to work
11:36:41 <Cale> ?
11:36:46 <Cale> I'm not sure what you're asking.
11:36:53 <Vargsvans> power2 n k | even n = power2 (n*n) (div k 2)
11:37:17 <Cale> er, sorry, when *k* is not even, you multiply by n
11:37:34 <Cale> (I did say k in the other cases :)
11:42:12 <Vargsvans> Cale, like this: power2 n k | even n = power2 (n*n) (div k 2)  | otherwise = n * power2 n (k-1) ?
11:42:43 <Vargsvans> power2 n k | even k = power2 (n*n) (div k 2)  | otherwise = n * power2 n (k-1)
11:45:07 <jfoutz> > map (`div` 2) [1..10]
11:45:07 <lambdabot>   [0,1,1,2,2,3,3,4,4,5]
11:46:25 <jfoutz> :t on
11:46:26 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:47:35 <Cale> Vargsvans: yeah, along with a case to handle k = 0
11:47:42 <tavelram> =1
11:47:50 <Cale> 0 is better :)
11:47:54 <tavelram> is it? :p
11:47:57 <jethr0> @seen jungehexe
11:47:57 <lambdabot> Unknown command, try @list
11:48:06 <Cale> n^0 = 1 for all n
11:48:23 <jethr0> and 0^n = 0 for all n ;)
11:48:27 <Cale> Nope.
11:48:33 <jethr0> hehe
11:48:39 <Cale> 0^n = 0 for all n > 0
11:48:47 <tavelram> Cale, but he will do *0 in the recursion...
11:48:47 <jfoutz> > 0^ (-1)
11:48:48 <lambdabot>   * Exception: Negative exponent
11:49:06 <Cale> tavelram: huh?
11:49:08 <benmachine> 0^0 == ??
11:49:14 <dolio> 1
11:49:24 <Cale> > let power2 n 0 = 1; power2 n k | even k = power2 (n*n) (div k 2)  | otherwise = n * power2 n (k-1) in power2 5 3
11:49:24 <philed> The number of maps from the empty set to itself.
11:49:25 <lambdabot>   125
11:49:33 <Cale> > let power2 n 0 = 1; power2 n k | even k = power2 (n*n) (div k 2)  | otherwise = n * power2 n (k-1) in power2 0 0
11:49:35 <lambdabot>   1
11:49:40 <Cale> > 0^0
11:49:41 <lambdabot>   1
11:49:46 <Cale> > 0**0
11:49:47 <lambdabot>   1.0
11:49:52 <tavelram> there you go :)
11:49:55 <benmachine> that is cheating
11:50:01 <Cale> cheating?
11:50:12 <benmachine> I am not sure why but it is
11:50:29 <tavelram> Cale, sorry, missread what you said :p
11:50:29 <benmachine> well, I seem to recall reading that 0^0 was undefined but I can't work out why now
11:50:39 <tavelram> thought you meant basecase =0 :p
11:50:43 <benmachine> perhaps because it is 0^1/0^1
11:50:54 <Cale> n^m in general is the number of functions from a set of size m to a set of size n. Since there is exactly one function from the empty set to itself 0^0 should be 1.
11:51:11 <Cale> Only silly people leave 0^0 undefined.
11:51:14 <benmachine> k
11:51:17 <Cale> The natural thing to define it as is 1.
11:51:19 <jethr0> benmachine: i think there was an issue of x^0 lim x->0 vs. 0^x lim x->0
11:51:29 <jethr0> obviously they diverge
11:51:29 <benmachine> is ^ different from ** then
11:51:45 <Vanadium> :t ^
11:51:46 <Vanadium> :t **
11:51:46 <lambdabot> parse error on input `^'
11:51:47 <lambdabot> parse error on input `**'
11:51:54 <Vanadium> nah
11:52:02 <benmachine> :P
11:52:02 <jfoutz> :t (^)
11:52:03 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
11:52:07 <jfoutz> :t (**)
11:52:08 <lambdabot> forall a. (Floating a) => a -> a -> a
11:52:30 <Cale> There are three types of exponentiation in the Prelude, corresponding to three separate definitions in mathematics.
11:52:42 <benmachine> ah okay
11:52:56 <benmachine> I was talking about mathematical exponentiation all the time
11:53:01 <benmachine> but I suppose that is ambiguous
11:54:11 <Peaker> What's a nice way to convert (a, Maybe b) into Maybe (a, b) ?
11:54:33 <Peaker> I find:  \(x, y) -> fmap ((,) x) y      somewhat ugly
11:54:45 <Peaker> well, I'm hoping there's something cuter :)
11:54:50 <Cale> There's the definition of repeated multiplication (^) which only works for nonnegative integer exponents, but any type of base at all. There's the definition (^^) which allows negative integer exponents as well, but that requires a fractional base. Then there's (**) which allows an arbitrary floating point exponent, but requires a floating point base type.
11:55:44 <arjanb> @pl \(x, y) -> fmap ((,) x) y
11:55:44 <lambdabot> uncurry (fmap . (,))
11:55:53 <jethr0> hehe
11:55:56 <benmachine> :t \x -> (x,)
11:55:57 <lambdabot> parse error on input `)'
11:55:59 <benmachine> :(
11:56:01 <Peaker> @pl \x y -> fmap ((,) x) y
11:56:01 <lambdabot> fmap . (,)
11:56:12 <Peaker> tuple sections were added to some ghc, according to reddit
11:56:32 <Peaker> I guess I can use that, somewhat unreadable tho :)
11:56:43 <Cale> The (**) definition roughly corresponds to the definition of exponentiation on the reals where a^b = exp(log(a) * b) for positive reals a.
11:57:08 <benmachine> how do you define exp and log without a definition for (**)
11:57:15 <benmachine> oh presumably in terms of calculus
11:57:20 <Cale> exp(x) = sum over k >= 0 of x^k / k!
11:57:40 <benmachine> oh or that
11:57:56 <Cale> log(x) is the inverse function, or else  log(x) = integral from 1 to x of 1/t dt.
11:58:20 <benmachine> clever!
11:58:39 <Peaker> @pl (\x -> ((,) x . fst) `fmap` iLogBase 10 x)
11:58:39 <lambdabot> ap (fmap . (. fst) . (,)) (iLogBase 10)
11:59:23 <Cale> You can't actually rightfully define things like x^(sqrt(2)) or the logarithm without a bit of calculus, which is why it's so stupid that they introduce logarithms before calculus in most highschool courses.
12:01:37 <Cale> The exp(x) definition I have is a bit hard to motivate as an initial definition that doesn't look like you pulled it out of thin air, but it's possible to work naturally toward the definition of log from properties that you'd like more general exponentiation to have.
12:04:17 <dolio> The argument against defining 0^0 as I recall is that you can use the above finessing to say 0^0 = e^(0*log 0), and that exponent isn't defined, either.
12:04:38 <Cale> dolio: You can't say that, because that definition doesn't apply when a = 0
12:04:52 <Raevel> http://en.wikipedia.org/wiki/0%5E0#Zero_to_the_zero_power
12:04:53 <Cale> (and 0 obviously is not in the domain of log)
12:04:53 <dolio> But, of course, 0^0 = 1 is useful.
12:05:19 <Cale> The definition for a = 0 is separate.
12:05:35 <Cale> As is the definition for negative values of a
12:06:22 <Cale> (the definition for negative values of a requires the exponent to be rational with odd denominator)
12:08:01 <Cale> As far as I can tell, the only reason that people end up thinking it should be undefined is that they can't tell the difference between 'undefined' and 'indeterminate form', where the latter is just a sort of mnemonic to help remember discontinuities of various common functions.
12:10:37 <philed> Cale: In my experience, a number of people seem to believe that there is a mathematical law which says that the limit of a function must exist for it to be defined at a point.
12:11:09 <Cale> That is ridiculous.
12:11:32 <philed> Cale: I know. It would mean that f(x) = 1 for x rational and f(x) = 0 for x irrational doesn't exist.
12:11:45 <Cale> The whole point of limits is to avoid talking about the value of a function at a given point where it may not even be defined.
12:12:30 <philed> Cale: Then again, if you are an intuitionist, all functions are continuous.
12:12:38 <Cale> That is, the point of "limit as x -> a of f(x)" is that it has nothing to say about f(a).
12:12:46 <dolio> That'd be rather odd, since I distinctly recall discussing (in high school calculus) functions that have a limit at a particular point, but the limit isn't the value at that point.
12:13:08 <EnglishGent> hi all :)
12:13:10 <Cale> dolio: Right, like the function f(0) = 1, and f(x) = 0 otherwise.
12:13:33 <dolio> Sure. Or take any continuous function and redefine it at any particular point.
12:13:35 <Cale> The limit as x -> 0 of f(x) is 0, but f(0) = 1. So f is not continuous.
12:13:39 <Cale> Right.
12:13:40 <EnglishGent> um.. why does that follow philed (intutionist)
12:13:49 * EnglishGent reading stuff on screen
12:14:04 <hackagebot> uu-parsinglib 2.2.1 - New version of the Utrecht University parser combinator library (DoaitseSwierstra)
12:14:57 <Cale> I also particularly like the function which for rational values p/q with gcd(p,q) = 1, f(p/q) = 1/q, and for irrational values x, f(x) = 0.
12:15:20 <Cale> This function is continuous at every irrational, and discontinuous at every rational.
12:15:26 <EnglishGent> worse - it seems to me we can at least talk about f(x) :: Real -> Real = -1 if x is irration, +1 if x is rational
12:15:28 <periodic> Hrm, if I want to match against the contents of a variable in a case statement, I get a "Pattern match(es) are overlapped" error when I use _.  Is there a reason this is bad?
12:15:37 <philed> EnglishGent: For intuitionistic real analysis, real numbers are functions which generate decimal expansions. You cannot define a discontinuity on this model, because you don't have excluded middle of point equality.
12:15:44 <Cale> EnglishGent: Right, that's discontinuous everywhere.
12:16:25 <Cale> periodic: That tends to mean that your other cases handle everything else, I think...
12:16:39 <philed> dolio: It's odd, but it's all I can infer from the argument that 0^0 is undefined because of some property of its limits. It seems they believe limits are the ultimate decider of well-definedness.
12:17:13 <Cale> Actually, looking at limits there is still a fairly good argument that 0^0 should be 1.
12:17:20 <philed> EnglishGent: For instance, you cannot tell whether an arbitrary function which seems to be generating 0.999... will in fact be 1.
12:17:26 <dolio> Yeah, I don't disagree that some people think that. I just don't know where they'd get it.
12:17:27 <Draconx> People who think 0^0 is undefined must have never tried to evaluate a polynomial at 0.
12:17:29 <EnglishGent> I'm not sure I follow that philed... what do you mean by 'excluded middle of point equality' ?
12:18:00 <Peaker> periodic: it probably means a previous pattern will catch everything a subsequent will, so the subsequent will never get a chance to run
12:18:21 <Cale> The limit as (x,y) -> (0,0) of x^y doesn't exist, but if you approach along any curve which is not tangential to the y axis at (0,0), then the result is 1.
12:18:58 <periodic> Peaker: Basically, I have a trinary variable and I want to match whether it is 0, or if it matches the contents of another variable (which is 1 or 2), and then have a fallthrough if it doesn't match (whichever of 1 and 2 the variable is not)
12:19:12 <philed> EnglishGent: The law, p = q or p != q doesn't hold in general for real numbers. If you wanted to define a function which jumps, you'd need that. For instance, suppose you want to define f(x) = 0 for x < 1 and f(x) = 1 for x >= 1. Intuitionistically, f maps procedures which generate decimal expansions to procedures which generate decimal expansions. But you cannot tell whether an arbitrary procedure which appears to be gener
12:19:12 <philed> ating 0.999... ends up generating a 0.9 recurring or not, so you don't know how to map it.
12:19:43 <philed> Hope that made sense.
12:19:43 <Peaker> periodic: can you paste the code somewhere?
12:20:23 <EnglishGent> somewhat... are you restricting discussion to computable functions?
12:20:34 <Cale> EnglishGent: effectively, yeah
12:20:35 <Cale> Another way to look at it is that open sets of real numbers are those sets of real numbers which if you keep improving the precision of your measuring instrument, you can eventually tell for certain that a point lies inside that set.
12:20:37 * EnglishGent can see how it holds then
12:21:49 <Cale> (Imagine that your measuring instrument places an interval of radius epsilon around the point, and successively shrinks that until the interval lies entirely inside the set.)
12:21:50 <philed> EnglishGent: An intuitionist has to, so yes.
12:22:35 <EnglishGent> may I ask a somewhat tangential question of people here? how would you suggest maths should be taught?
12:22:50 <EnglishGent> it seems to be that a functional language should be taught as part of math class
12:22:52 <philed> EnglishGent: Starting with the simply typed lambda calculus :P
12:22:58 <periodic> Peaker: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9157#a9157
12:23:06 <EnglishGent> oh - I would have started with Peano arithmetic :P
12:23:07 <EnglishGent> :)
12:23:18 <Cale> EnglishGent: I don't really think I'd use functional programming as part of elementary mathematics classes.
12:23:26 <Cale> EnglishGent: However, I would scrap the entire elementary and highschool curriculum.
12:23:40 <Cale> They're garbage and have essentially nothing to do with mathematics.
12:23:45 <EnglishGent> Cale - I dont know how far down you could go, but I was thinking of something like Logo
12:23:55 <Cale> If you're not proving theorems, you're not doing mathematics, as far as I'm concerned.
12:23:57 <EnglishGent> Haskell would be too much of a stretch I agree
12:24:04 <Cale> Students should be proving theorems -- even if simple ones.
12:24:11 <philed> I wish I had been introduced to some proof when I was doing maths. Going back to Euclidean geometry might be a good idea.
12:24:15 <philed> (at school)
12:24:29 <periodic> Peaker: It's coloring a graph.  I'm trying to have it color the node if uncolored, return unchanged if it is already collored correctly, or bail if we got a conflict (it's a graph known to be two-colorable)
12:24:30 <Cale> Don't get me wrong, I think functional programming is a lovely thing to teach. Just... not the way I'd teach mathematics.
12:24:32 <EnglishGent> also agreed Cale - it seems to me what school calls 'maths' is really 'computation'
12:24:47 <Peaker> periodic: "c" catches everything that's left from previous patterns
12:24:51 <EnglishGent> i.e. here's a procedure you follow - dont ask why, just follow it
12:24:52 <Peaker> periodic: nothing is left for "_" to catch
12:25:10 <Lycurgus> which school system is referred to?
12:25:22 <Peaker> periodic: "c" and "_" catch the exact same set of values, its just that "_" happens to discard what it catches
12:25:27 <benmachine> there was proof in some of my classes but it was generally an added bonus, and sometimes skipped
12:25:37 <Berengal> Cale, mathematics is an art. I'm just not sure children could do it without a lot of practice
12:25:53 <EnglishGent> well I can only talk with knowledge about the English one - but in my opinion the syllabus we followed was lousy
12:25:54 <Berengal> There should be proofs in elementary school though
12:26:00 <Cale> The highschool mathematics curriculum gives one many inappropriate conclusions about mathematics: the first one which I think is the major wrong thing is the idea that mathematics is somehow not a human construction.
12:26:02 <EnglishGent> basic concepts where never introduced
12:26:04 <lpjhjdh> is there an elegant way of making alex join multiple newlines into a single token?
12:26:10 <Peaker> periodic: btw: Do you want suggestions for potential improvements of that code?
12:26:16 <Cale> The second very big wrong thing is that mathematics is mostly about numbers.
12:26:17 <lpjhjdh> I wanted to say something like @join_nl = $nl @join_nl | $nl
12:26:18 <EnglishGent> the distinction between identity & equation for example was never even mentioned
12:26:38 <EnglishGent> we used theorems (like Pythagoras) - without *ever* seeing a proof
12:26:40 <EnglishGent> etc :|
12:26:40 <dolio> Clearly Cale is one of those out-of-touch New Mathers.
12:26:52 <periodic> Peaker: oh... duh...
12:26:56 <periodic> Peaker: I see.
12:26:59 <SamB> how is the new math different from ... normal ... math ?
12:27:01 * Lycurgus remembers new math when it was actually new.
12:27:08 <periodic> Peaker: how would I match in three cases against a variable then?
12:27:26 <copumpkin> there's an IB HL math option that offers some vaguely abstract stuff
12:27:29 <Cale> I don't want to teach new mathematics. I want to teach contemporary mathematics.
12:27:32 <Lycurgus> (about 45 years ago)
12:27:34 <copumpkin> I enjoyed it
12:27:39 <periodic> Peaker: c gets bound to the value the case is matching against, right?
12:27:39 <copumpkin> but it was pretty basic stuff
12:28:16 <tristes_tigres> Why this code from the article "Fun with type functions version 2" does not work ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3539
12:28:31 <EnglishGent> Cale - did you hear about the experiment in teaching Conway did? the one with Phd pupils & high school students all in the same class?
12:28:41 * EnglishGent thought that was a very interesting idea :)
12:28:45 <Lycurgus> ( http://en.wikipedia.org/wiki/New_math )
12:28:58 <copumpkin> PhD pupils and high-school students?
12:29:07 <jmcarthur> lucky high school students
12:29:22 <Saizan> tristes_tigres: you need ScopedTypeVariables
12:29:35 <tristes_tigres> lucky phd students ! picked up some teenage HS girls
12:29:45 <tristes_tigres> Saizan: thanks
12:29:49 <Saizan> tristes_tigres: and instance forall n. (Nat n) => Nat (Succ n) where .. maybe
12:29:57 <Peaker> periodic: I think I understand your mistake in that code: "c" doesn't match *against* c, it catches *everything* and names it "c", shadowing the "c" argument
12:30:06 <Peaker> periodic: what you probably want is: case .. of Unknown -> ... ; other -> if other == c then g else error " ... "
12:30:06 <copumpkin> why are the tigers sad?
12:30:52 <Cale> I think that in order to do curriculum change, it really has to be a systemic change. You can't just redesign the curriculum and let existing teachers teach it. Teaching mathematics properly requires that you have decent teachers who actually understand the material properly themselves.
12:30:59 <tristes_tigres> Saizan: -XScopedTypeVariables makes it work
12:31:10 <tristes_tigres> copumpkin: make a guess
12:31:21 <Cale> I also don't think the current level of standardisation results in anything which I'd like to call teaching.
12:31:45 <copumpkin> tristes_tigres: hrm :)
12:31:53 <Cale> Things are far too standardised. Without freedom to teach the way they want to, teachers cannot teach.
12:31:54 <EnglishGent> hi copumpkin
12:31:54 <dolio> Anyhow "math isn't about numbers" seems like one of the points where people would go nuts.
12:32:02 <copumpkin> hi EnglishGent
12:32:03 <Cale> dolio: Well, it's not.
12:32:06 * tristes_tigres thinks the number of students who get math is going to remain the same regardless of the teachers and programs
12:32:07 <dolio> I know.
12:32:21 <EnglishGent> and yes - he broke the class into groups - each containing one math Phd, a couple of undergrads & half a dozen high school students (it was an experiment in teaching)
12:32:22 <copumpkin> tristes_tigres: however, people might not have such a bad idea of what it is
12:32:38 <EnglishGent> and then went through various concepts in abstract geometry
12:32:49 <Cale> dolio: Sure, numbers are important structures in mathematics, but I wouldn't mind giving them up entirely in the highschool curriculum in exchange for a course where students would actually learn to apply logic to abstract situations.
12:32:59 <tristes_tigres> copumpkin: little knowledge is a dangerous thing
12:33:01 <EnglishGent> there's a paper he wrote on it online somewhere :)
12:33:03 <dons> @seen ndm
12:33:04 <lambdabot> Unknown command, try @list
12:33:07 <copumpkin> is there a formal definition of number somewhere, by the way?
12:33:07 <dons> wtf?
12:33:16 <copumpkin> dons: I think it was killed for being useless :P
12:33:19 <copumpkin> preflex: seen ndm
12:33:19 <preflex>  ndm was last seen on #haskell 121 days, 9 hours, 15 minutes and 2 seconds ago, saying: plus with current compiler technology, it would be slower
12:33:26 <dons> whoa
12:33:30 <Cale> dons: killed the plugin, since it was broken and useless. Use preflex.
12:33:35 <tristes_tigres> @vixen19 what about new math ?
12:33:36 <lambdabot> Unknown command, try @list
12:33:38 <shachaf> Ooh, mathematics education discussion.
12:33:42 * shachaf scrolls up.
12:33:42 <dons> ok.
12:33:43 <EnglishGent> I'd guess something on which you can define division? (i.e. ruling out any algebra beyond the Octonions)
12:33:49 <dons> btw, did you know they run lambdabot at facebook
12:33:49 * EnglishGent first stab at a definiton
12:33:50 <EnglishGent> :)
12:33:52 <dons> on the internal channel
12:33:57 <dons> with extra plugins
12:33:57 <copumpkin> dons: ooh
12:34:04 <copumpkin> dons: can they contribute back their changes?
12:34:07 <EnglishGent> hi shachaf :)
12:34:18 <Cale> One thing which I heard a lot when I was in highschool in my mathematics courses was the question "Why are we doing this?" and I think it's a very good question given the material that they try to teach.
12:34:41 * benmachine quite enjoyed his maths education
12:34:45 <EnglishGent> btw... should we perhaps move this conversation to haskell-blah? (just a suggestion)
12:34:50 <tristes_tigres> @vixen what about new math ?
12:34:50 <lambdabot> This is a great day for France!
12:34:56 <copumpkin> or haskell-in-depth!
12:35:02 <Cale> The only thing that mathematics could hope to offer students at that level would be a good sense of logic, which was something that our mathematics curriculum was essentially devoid of.
12:35:05 <EnglishGent> I think math educations is a very interesting subject - but I'm not sure how haskellish it is :)
12:35:31 <copumpkin> EnglishGent: this channel is often #compsci, which is a subtopic of #math
12:35:33 <copumpkin> :P
12:35:53 <Peaker> dons: cool! what plugins?
12:36:04 <Peaker> dons: its a stark contrast to their use of PHP :)
12:36:32 <copumpkin> they do a lot of functional stuff don't they, behind the scenes?
12:37:24 <roconnor> math is compsci!
12:37:39 <copumpkin> fine, fine :)
12:37:53 * roconnor is just opinionated
12:38:04 * copumpkin tends to not be
12:38:17 <copumpkin> zomg to boldly write a split infinitive
12:38:17 <tristes_tigres> saizan: why the code works without foralln.(Num n) => ... , I wonder
12:38:45 <Cale> roconnor: Making statements like that can get you labelled...
12:38:49 <dons> they use haskell at facebook to parse and manipulation php
12:38:55 <dons> which is a good use, imo
12:39:00 <roconnor> Cale: as a ...
12:39:16 <roconnor> communisit? or the other one
12:39:17 <etpace_> they use haskell to write php so they don't have to?
12:39:34 <roconnor> s/isit/ist/
12:39:35 * tristes_tigres thinks Haskell needs a major completed project in it to prove to people that it is useable
12:39:47 <Saizan> tristes_tigres: i guess only the ghc manual can clarify :)
12:40:04 <nlogax> dons: can i read about that somewhere?
12:40:09 <Cale> roconnor: Crank? :)
12:40:10 * roconnor I'd be happy if haskell was simply used for all minor projects.
12:40:17 <tristes_tigres> Saizan: it does not
12:40:27 <roconnor> Cale: I was thinking constructivist.
12:40:54 <roconnor> oh boy, I obviously need to get some tea before typing further.
12:41:19 <dons> nlogax: we'll have to wait for the CUFP videos
12:41:36 <dons> tristes_tigres: we have lots of major completed complicated projects
12:41:39 <tristes_tigres> roconnor: There at present isn't a good answer to the charge that Haskell is an academic plaything
12:41:39 <nlogax> dons: i see :)
12:41:53 <Heffalump> tristes_tigres: help out with darcs?
12:41:55 <Peaker> dons: I'm not sure why you'd want PHP anywhere in your toolchain :)
12:41:56 <dons> tristes_tigres: http://www.galois.com/blog/2009/04/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/
12:42:13 <tristes_tigres> Hefalump: I think it is doomed and unnecessary
12:42:15 * dons thinks galois should have done a 10th anniversary keynote at cufp
12:42:18 <dons> maybe next yar
12:42:26 <alinp> hi
12:42:32 <dons> have launchbury give it as chief scientist
12:42:37 <Heffalump> tristes_tigres: fair enough :-)
12:42:50 <alinp> does Haskell have a mechanism for hot code swapping ?
12:42:58 <Heffalump> most people who have used both it and git a lot seem to think that it's much more usable in UI terms
12:42:58 <tristes_tigres> dons: so they do proprietary stuff in it. Doesn't give an example I am looking for.
12:42:59 <dons> yeah. the runtime supports it.
12:43:07 <dons> there's a couple of libraries (3?) that let you do that
12:43:17 <dons> tristes_tigres: so you want open source only?
12:43:26 <dons> tristes_tigres: something like pugs or ghc or xmonad or pandoc or gitit?
12:43:36 <dons> haxml is pretty big.
12:43:43 * dons wonders what the largest open source haskell project is.
12:43:56 <trofi> ghc?
12:43:57 <dons> pugs is ~20k?
12:43:59 <alinp> thanks dons
12:44:00 <dons> darcs is ~20k
12:44:03 <dons> ghc is ~150k
12:44:04 <tristes_tigres> dons: pugs would be it, but it seems going nowere
12:44:20 <dons> its failing for non-technical reasons, sadly
12:44:38 <dons> social aspects are almost more important than technical aspects to success.
12:44:39 <Botje> at least rakudo is doing pretty well
12:44:53 <Botje> we might even see a perl 6 implementation before 2012 :)
12:46:42 <tristes_tigres> dons: I am looking for a major project having use outside Haskell community. So that rules out darcs and ghc
12:46:42 <Heffalump> darcs has some use outside it, and would have more if it worked better
12:46:42 <Heffalump> even though to some extent it has missed its opportunity
12:46:43 <tristes_tigres> dons: Yeah yeah yeah. So will the Haskell join the graveyard of the great computer technologies who perished for social reasons ?
12:46:43 <dons> no, i don't  think so.
12:46:43 <dons> we have lots of social haskellers out there now
12:46:43 <dons> more outreach is required though
12:46:43 <copumpkin> tristes_tigres: check out all the hakellers on twitter!
12:46:43 <copumpkin> we need very aesthetic haskellers to make our websites prettier btw!
12:46:43 <dons> spj is still our benevolent dictator , in a sense, which is key
12:46:43 <tristes_tigres> Heffalump: there are alternatives with order of magnitude more developers and users. Darcs has no chance
12:46:43 <dons> pugs lost theirs
12:47:14 <copumpkin> dons: by the way, I was thinking about the platform, wouldn't it be nice if it were haskell.org/platform? it'd be so easier to give out and remember
12:47:14 <lpsmith> Definitely not.   Haskell is well established,  and rather influential,  but whether or not Haskell will break through to the mainstream is unclear :-)
12:47:14 <Heffalump> tristes_tigres: with some improvements, darcs is better than those alternatives.
12:47:14 <dons> dcoutts: can you send me the slides from the hackage talk?
12:47:14 <lpsmith> But it's definitely not going to perish anytime soon, if ever
12:47:14 <dons> dcoutts: i'll put them online
12:47:14 <Nafai> dons: Did Audrey move on to something else?
12:47:15 <jmcarthur> i think haskell definitely has the potential to become "mainstream," whatever that means
12:47:22 <dons> lpsmith: i should hope not. we're spending too much time and money on it.
12:48:11 <dons> http://qa.debian.org/popcon-graph.php?packages=xmonad%2C+darcs%2C+hpodder%2C+pandoc%2C+ghc6&show_installed=on&want_legend=on&want_ticks=on&from_date=&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
12:53:02 --- mode: irc.freenode.net set +o ChanServ
12:53:08 <EnglishGent> eep!
12:53:08 <FunctorSalad> @bot
12:53:08 <EnglishGent> hi FunctorSalad :)
12:53:08 <FunctorSalad> I think the bot passed out :(
12:53:09 <jmcarthur> we're in the fake #haskell!
12:53:09 <FunctorSalad> hi EnglishGent
12:53:09 <lunabot>  :o
12:53:18 <Saizan> wow
12:54:05 <copumpkin> @botsmack
12:54:11 <lunabot>  :o
12:54:12 <EnglishGent> okay... who's code was using unsafe side-effects? :D
12:54:12 <lpsmith> lol
12:54:13 * roconnor used unsafeCoerce
12:54:14 * Saizan looks at lunabot 
12:54:32 <copumpkin> mmorrow decided :o was cuter than :)
12:57:48 <lpsmith> sending data over a network is inherently a rather pernicious effect :-)
12:59:31 <lpsmith> Cale:  or moar statistics!   http://www.ted.com/talks/arthur_benjamin_s_formula_for_changing_math_education.html
13:00:40 <Cale> I don't mind probability theory, and I think it's important for people to know it, but statistical modelling gets into something which belongs in a science course and not a mathematics course.
13:00:53 <Cale> (again, something that I'd love to see taught, but not mathematics)
13:02:28 <Cale> I think an important philosophical point to convey about mathematics is that it's fundamentally not constrained by our observations of the world around us. It's only constrained by what we can imagine.
13:02:56 <Cale> When we use mathematics to model our observations of the world around us, we're doing science.
13:04:09 --- mode: irc.freenode.net set +o ChanServ
13:05:39 <Cale> oy, netsplits
13:09:54 --- mode: irc.freenode.net set +o ChanServ
13:11:22 <maltem> Oops, did a server just break away and come back?
13:11:22 <Saizan> something like that, yeah
13:11:22 <Lycurgus> ginormous netsplit
13:11:22 <Lycurgus> not just this channel
13:11:22 <roconnor> I got a message from the overlords about the netsplit
13:11:22 <roconnor> [15:52] [Notice] -christel- [Global Notice] Hi all, one of our american hubs appear to be having some issues presently, we're looking into it and hopefully will have things back to normal shortly. It may be slightly noisy should we need to re-hub
13:11:23 <jethr0> huh?
13:11:23 <lambdabot> :)
13:11:24 <copumpkin> this was a pretty epic netsplit
13:11:25 <hackagebot> palindromes 0.1.1 - Finding palindromes in strings (JohanJeuring)
13:11:27 <dooof> no strange things
13:11:28 * roconnor is becoming more convinced that 2^(2^N) is countable.
13:11:41 <RayNbow> roconnor: start counting! :p
13:11:41 <roconnor> const 1, const 0
13:11:42 <jethr0> roconnor: with N integer why wouldn't it be?
13:11:43 <roconnor> \f -> f 1
13:11:44 <ziman> roconnor, what convinces you? :)
13:11:45 <roconnor> jethr0: er, sorry.  I mean N is the natural numbers (or integers) and 2^X is (X -> bool)
13:11:45 <Heffalump> is 2^N countable?
13:11:45 <opqdonut> no
13:11:46 <jethr0> with N integer there is an easy mapping from integers to 2^N, no?
13:11:46 <roconnor> ziman: that finding an injection from X -> 2^X seems to require that X have a decidable equality, and the fact that I think that with bar induction one can prove that 2^(2^N) is countable.
13:11:56 <roconnor> Heffalump: nope
13:13:36 <opqdonut> 2
13:13:36 <opqdonut> gah
13:13:36 <opqdonut> 2^(2
13:13:37 <jungehex`> reading:: Str Bool -> IO String
13:13:37 <jungehex`> reading (True:movie)  = readFile "output"
13:13:37 <jungehex`> reading (_:movie) = reading movie
13:13:37 <roconnor> At least I'm pretty sure that cantor's argument is constructive.  I think I may have even proven it in Coq before.
13:13:37 <opqdonut> gah
13:13:37 <opqdonut> my return key is oversensitive
13:13:38 <jethr0> jungehex`: hi
13:13:41 <idnar> opqdonut: maybe you should... return it
13:13:41 <jethr0> sorry, my internet connection has been going down quite frequently
13:13:41 * idnar puts his sunglasses on
13:13:41 <jungehex`> jethr0: hi
13:13:41 <opqdonut> i was about to say: 2^(2^N) is (N->bool)->bool right?
13:13:41 <opqdonut> thanks idnar
13:13:41 <jethr0> yesterday i was without electricity for the better part of the day
13:13:42 <jungehex`> jethr0: that's sad
13:13:46 <roconnor> opqdonut: that's right.  So we should think of -> as continuous functions rather than set functions.
13:13:46 <opqdonut> ah, now i see
13:13:59 <opqdonut> so thus 2^ doesn't always produce a larger cardinality
13:13:59 <opqdonut> as it "normally" does
13:14:06 <jungehex`> i'm still trying to write a fanction which reads file on demand
13:14:17 <jungehex`> and vice a versa
13:14:17 <roconnor> opqdonut: it seems that way, but I haven't really thought about the topology of function spaces much.
13:14:26 <roconnor> even in topology class.
13:14:28 <jungehex`> but it compiules and doesn't work :(
13:14:34 <jethr0> hehe, any progress on your end? would you like to paste your current code and tell me what's working?
13:14:47 <jungehex`> of course :)
13:15:04 <roconnor> opqdonut: this is part of my quest to better understand Escardo's seemingly impossible functions.
13:17:40 <jungehex`> it compiles, but i get the empty window
13:17:41 <roconnor> FunctorSalad: possibly.  It is certainly decidable for this aledged surjection, particularly because you have used 2^ instead of Omega^.
13:17:41 --- mode: irc.freenode.net set +o ChanServ
13:17:44 <Cale> This is getting ridiculous.
13:17:56 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
13:17:56 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
13:17:56 --- names: list (clog te_ klugez_ Botje_ woggle Baughn @ChanServ mokus malouin gereedy poe ricky26 koala_man xian quarks glasser` Ytinasni blackdog det StoneToad dumael CrazyAzrael1 piroko jajamana mapreduce __marius__ Vanadium rntz Blub\0 levitation[A] ponzao___ Crito Foolean byorgey lunabot alexbobp huntse kniu usercard XGas jorizma yaxu LeCamarade|Away phyrex1an1 skorpan arjanb trofi noisetonepause Alucard_Not_Orca Athas perspectival trin_cz meanburrito920_)
13:17:56 --- names: list (pr benmachine talumees iblechbot enolan copumpkin |Steve| Trafalgard _SamB_ paul424 _phil3801 GreatPatham canvon felipe_ Gertm ath Mitar flux pcc1 neurocyte Badger gbacon SimonRC dixie lanaer nlogax dcolish flori greap hackagebot mornfall cjay OnionKnight birkenfeld harlekin Taggnostr boyscared Guest70389 sjanssen burp Raevel poucet TML jims And[y] keseldude_ Schmidt Jaak Milo- luis joga tomlok Lemmih Megant elliottt Hunner PHO__ mattam)
13:17:56 --- names: list (nwf netcat liyang sbok etpace_ djahandarie aarong dilinger int-e encryptio eevar_ Cthulhon kadoban jlouis Deewiant raimo_ ibid dons jlaire miasma tarbo_ yottis StarFire brad_larsen LeoD wjt younder stalker_ tmoertel_work_ t g0ju Draconx mauke Eelis fxr jahgru MyCatVerbs jdavis jfredett_ qm13 dufflebu1k nasloc__ nathanic opqdonut xci authentic PetRat caligula_ dancor xinming cognominal thomastc djinni tavelram dsfox1 glguy wdonnelly nominolo|uni)
13:17:56 --- names: list (pinp Gabbie rovar deiga ``w1zard sebbe1991 kolmodin jmillikin zax_ DekuNut sad0ur eno kmc M| aluink jbauman Warrigal Bleadof drbean wmealing_ agemo rey_ Partizan_ QtPlaty[HireMe] Saizan EnglishGent FunctorSalad s76_ jrib ttt-- Dessous themroc- ClaudiusMaximus Necoro m4thrick a-s twanvl_ magicman mjrosenb thoughtpolice blackh juhp hiratar_away ToRA_ vili Peaker peddie CESSMASTER andrewsw-afk doubleth1nk_work Heffalump qz CalJohn ibt bd_)
13:17:56 --- names: list (icee cmeme qebab idnar electrog1ek laz0r wolverian galdor Elly epmf lilac nablaa Laney Annie|Home davidL hellige sunnavy mux ennen purplepenguins roconnor arsenm rgrinberg dooof deavid vav Phyx- jmcarthur hrehf selbram boscop Tomas DeSoVoDaMu dibblego gnuvince xaep carlocci Jag_ willb1 astrolabe jperras loupgaroublond BfrOv3rfl0w waern_ Knight_Lord ulfdoz goszne jaredj triplez lhnz lpsmith lpjhjdh hsuh shintah paolino kpreid longh_ jethr0)
13:17:56 --- names: list (Philippa lambdabot der_eq Nebasuke Nanar eidan RayNbow dschoepe periodic sciolizer dm`` kar-1 badsheepy Tobsan quicksilver Gracenotes bryno thetallguy2 PsiOmega ArneB hiredman mlh Pistahh kw317 pragma_ tromp wormwood ray koninkje_away Twey taruti dreixel TimMc bran mikem` ertai PeakerWork aempirei skaar jnwhiteh ziman anji maskd endojelly nothingmuch _br_ profmakx RageOfThou ujihisa Berengal arjanoosting_ arjanoosting Vargsvans saccade)
13:17:56 --- names: list (Axman6 arnihermann desu Paks brx ingy jvoorhis Vq yahooooo Aisling Zao aavogt noj kosmikus anders^^ wuncidunci sebas_ impl eelco_ integral Colours arw_ Optimo sshc drhodes Khisanth necrobious McManiaC Igloo maciej` gOcOOl jaj krif orbitz dmwit trzkril pantsd_pcf trez wagle_home pardus Polarina zsol jungehex` fnordus Nshag reqamst thingwath ehamberg mm_freak lefant ido nornagon dqd Ferdirand Beelsebob mikm_ alinp slash_ rgr komar_ Raku^)
13:17:56 --- names: list (dolio dfdf gogonkt mak__ tumdum crem |Jedai| johnfn smorg BMeph hesselink raadad2 pikhq m-i-l-a-n stanv yango Arnar Stephan202 tltstc Baconizer mun dionoea joed Shurique dogmaT syntaxglitch Hong_MinHee karld p_l jeffersonheard Nereid olsner smg Sisu defn mercury^ edwinb erg Boney equanimity BrianHV gdsx daed_ mrd regulate webframp marmolak lispy andrewz triyo dubhrosa_t Stefa1 mmorrow_ ivant ahf luite osfameron Nereid_ portnov DEVOKUN)
13:17:56 --- names: list (Apocalisp sully JaffaCake otulp _Jordan_ kapil Jacolyte karihre_ lament whoppix shepheb jvogel Counter-Strike thirsteh Nafai frederik solrize mike-burns kaol mle tkr AndyP loop chr1s Gilly jfoutz pettter Poeir Adamant tew88 Azstal bla123 k3ph maltem iago igorgue andyjgill LouisJB1 sramsay tomh- pd philed noteventime NinZine paulvisschers sbahra Pewpewarrows ksandstr ben_w_ Taejo dm` fbru02 malcolmw Schmallon danvet ski Gwern-away shachaf)
13:17:56 --- names: list (otto_s_ sclv__ aik__ preflex kfunc dcoutts Azkar alexsuraci Twigathy Lycurgus Dunearhp gbeshers jrockway danopia jml mfp dfranke AnMaster SubStack dfeuer araujo Valodim guerby dr4wd3 alip glith cods J11 koeien Liskni_si kalven SeaPrior maxote suiside dino- majoh matthew-_ Jiten daf michie1 allbery_b)
13:17:58 <FunctorSalad> roconnor: oh true
13:19:40 <Cale> These netsplits are rendering IRC completely unusable...
13:19:49 <ziman> FunctorSalad, what was please your question? I got much join-flood here and I can't find it in the scrollback
13:19:57 <Elly> it is a pretty impressive amount of network instability, even from freenode
13:19:57 <harlekin> > show id
13:19:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:19:58 <lambdabot>    arising from a use of `...
13:21:01 <dons> "re-hubbing nearing completion"
13:25:25 <maltem> You people are showing joins/leaves in your IRC client?
13:26:14 <roconnor> presumably 2^(2^N) isn't compact?
13:26:20 <FunctorSalad> ziman: "roconnor: hmm constructivity of cantor, doesn't that depend on whether x  f(x) is decidable for the alleged surjection f : N -> 2^N"
13:26:35 <ziman> FunctorSalad, ah, thanks
13:26:37 <roconnor> ziman: "FunctorSalad: possibly.  It is certainly decidable for this aledged surjection, particularly because you have used 2^ instead of Omega^."
13:26:38 <dons> dcoutts: also, can you send me the slides for our icfp talk on stream fusion?
13:27:12 <sjanssen> dons: speaking of slides, when you post them on your blog, can you give a vanilla PDF link as well?
13:27:31 <HugoDaniel> hi
13:27:40 <HugoDaniel> has anyone worked with Dyre ?
13:27:47 <Cale> maltem: I do, since it's usually useful.
13:27:53 <sjanssen> Flash really sucks on Linux, I personally prefer my PDF reader to scribd
13:28:14 <HugoDaniel> talking about scribd
13:28:17 <ziman> 22:28:06 Ignoring JOINS PARTS QUITS MODES from #haskell
13:28:18 <HugoDaniel> have you seen this: http://donsbot.wordpress.com/2009/09/07/stream-fusion-for-haskell-arrays/ ?
13:28:19 <ziman> cool :)
13:28:40 <HugoDaniel> its preatty hardcore stuff, wish i could have been there
13:28:44 <sjanssen> HugoDaniel: actually yes, that was the blog post that caused me to whine about scribd :)
13:28:51 <roconnor> ziman: how do I do that?
13:29:09 <sjanssen> HugoDaniel: I haven't worked with dyre, but I'm familiar with the system that inspired it
13:29:21 <ziman> roconnor, in irssi it is: /ignore #haskell-blah MODES JOINS PARTS QUITS
13:29:38 * roconnor tries it anyways
13:29:50 <HugoDaniel> ill hpaste my code
13:29:52 <HugoDaniel> w8
13:30:02 <dons> sjanssen: yes, i have done so in all cases :)
13:30:12 <dons> and included them in the synopsis for the scrib page.
13:30:35 <dons> also, these are like 10x more popular than posting the .pdf slides, going by the hit rate, so i encourage people interested in doing outreach to post them on scribd too
13:30:45 <roconnor> ah well
13:30:54 <tythontemple> http://www.tythontemple.com Check out the newest mmo Star War The Old Republic!
13:31:02 <sjanssen> dons: how do I get to that?
13:31:13 <HugoDaniel> here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9162#a9162 dyre stresses, can someone give me a hand ?
13:31:22 <sjanssen> dons: nevermind, found it
13:31:26 <dons> yeah
13:31:41 <dons> i'll make a big bold (PDF) link at the top next time
13:31:48 <dons> actually, i'll do it now
13:31:55 <sjanssen> dons: yeah, that would definitely be the best of both worlds
13:32:48 <dons> how's that, http://donsbot.wordpress.com/2009/09/07/stream-fusion-for-haskell-arrays/
13:33:56 <dons> btw, sjanssen , you might also be interested in http://www.scribd.com/doc/19503176/The-Design-and-Implementation-of-xmonad
13:33:56 <dons> :p
13:33:56 <sjanssen> dons: yeah, that's good
13:33:56 <orbitz> dons: you are quick sir
13:34:23 <maltem> Cale: personally I find them to disturb no matter if netsplits happen or not, thus my amazement
13:36:05 <sjanssen> dons: if scribd seems to be more popular, maybe we should update the link on xmonad.org?
13:36:21 <dons> yeah, i think so.
13:36:32 <hackagebot> hlint 1.6.8 - Source code suggestions (NeilMitchell)
13:36:40 <dons> we can embed them in the blog too, directly
13:36:46 <Peaker> I don't see why freenode can't have redundant linking so there are never any netsplits..
13:37:11 <orbitz> any matrue web frameworks in haskell?
13:38:30 <HugoDaniel> what does the '#' do ?
13:38:36 <dons> orbitz: happstack is quite mature now.
13:38:45 <dons> and also popular. in the top 10 haskell apps
13:38:52 * dons loves having the numbers
13:39:00 <copumpkin> HugoDaniel: where? not much, usually, other than indicate low-levelness :P
13:39:05 <HugoDaniel> in data BUArr e = BUArr !Int !Int ByteArray# ...
13:39:11 <HugoDaniel> in the dons slides
13:39:13 <orbitz> dons: excellent
13:39:17 <HugoDaniel> i cant understand most of the stuff in there :)
13:39:27 <copumpkin> HugoDaniel: ah, then it's the aforementioned low-levelness :P
13:39:37 <HugoDaniel> ah
13:39:38 <orbitz> dons: is happstack the successor to happs?
13:40:04 <Saizan> orbitz: yes
13:40:19 <dons> yes. new project leads, new pragmatic focus
13:41:00 <Saizan> @hackage happstack
13:41:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happstack
13:41:16 <Saizan> oh, they are still at 0.3
13:41:33 <HugoDaniel> a new version is going to be released soon
13:41:33 <dons> right, they restarted counting from 0.0
13:41:44 <HugoDaniel> and its going to rock :)
13:41:55 <dons> HAppS got to 0.9.3.1
13:42:03 <dons> and then got renamed happstack-0.0
13:42:22 <dons> so its really at 1.2.5.1
13:44:28 <ziman> are most functions in 2^(2^N) non-continuous then?
13:45:08 <roconnor> that would appear to be the conclusion
13:45:35 <SamB> could you remind me what 2^(2^N) means in this context?
13:45:49 <roconnor> I'm not absolutely sure that 2^(2^N) is countable for ^ being continuous, but I'm moderately sure.
13:46:16 <roconnor> I took ziman to be using the set theoretic ^
13:46:21 <roconnor> from his comment
13:46:41 <roconnor> perhaps for clarity we should use ^ for set theoretic and -> for continuous for this conversation
13:47:01 <roconnor> for the remainder of this conversation
13:47:05 <SamB> yeah, well, I guess I more-or-less figured, but I forgot what set-theoretic ^ is ;-)
13:47:20 <SamB> it's just a funky function arrow ?
13:47:31 <dolio> a^b is functions from b to a.
13:48:10 <SamB> and 2 is isomorphic with Bool, yes?
13:48:26 <ziman> yes
13:48:42 <copumpkin> > genericLength [1..] > (3 :: Natural) -- EnglishGent
13:48:44 <lambdabot>   True
13:49:01 <roconnor> 2 is Bool, yes.
13:49:30 <copumpkin> > foldr (*) 1 [2..] > (3 :: Natural)
13:49:31 <SamB> so ... where does this "continuous" thing come in ?
13:49:32 <lambdabot>   * Exception: stack overflow
13:49:34 <copumpkin> aw
13:49:38 <roconnor> so reformulating my claim:  (N -> 2) -> 2 is countable.
13:49:40 <copumpkin> > foldr (+) 1 [2..] > (3 :: Natural)
13:49:41 <lambdabot>   True
13:49:59 <roconnor> SamB: are you asking what the topology is?
13:50:30 <SamB> roconnor: perhaps!
13:50:45 <SamB> or maybe just "what is topology" ;-)
13:50:54 <SamB> is there some blog entry I can read ?
13:51:06 <copumpkin> topologyblog.org
13:51:18 <copumpkin> almost, http://ldtopology.wordpress.com/
13:51:23 <SamB> address not found?
13:51:31 <roconnor> SamB: the topologies are the the Scott topologies.  2 and N have the discreate topology, which makes continuous functions the same as the set theoretic functions.
13:52:10 <Cale> hmmm
13:52:16 <roconnor> SamB: Do you know about domains? bottoms and partial values and stuff for our types?
13:52:47 <SamB> roconnor: mostly
13:52:50 <roconnor> SamB: and how some partial values are more partial than others (they are partially ordered)?
13:52:51 <Cale> Shouldn't the topology on N really have open sets being the computable subsets of N?
13:53:08 <Cale> Er, or the semidecidable ones, really.
13:54:03 <roconnor> SamB: so continuous functions are functions that preserve this partial ordering. (and they also have to preserve limits of upwards chains, IIRC).
13:54:54 <jungehex`> hi all, i need som help concerning reactive framework
13:55:11 <roconnor> Cale: possibly.  I'm not certain.
13:55:37 <SamB> roconnor: hmm.
13:55:40 <jungehex`> how can i keep some part of a stream selected on demand and reproduce it on demand
13:55:45 <SamB> that's a bit tricky to wrap my head around ...
13:55:56 <roconnor> Cale: I'm definitely not assuming that for this converstation.
13:56:18 <roconnor> SamB: all functions we write in pure haskell are continuous
13:56:25 <igorGTA> not in the scope 'add'....
13:56:30 <SamB> roconnor: ah, that's nice!
13:56:40 <SamB> that makes it easier to wrap my head around ;-)
13:56:47 <Cale> You want the computable functions to be the continuous ones, right?
13:57:13 <roconnor> Cale: I'm just talking about the continuous functions.  The computable ones are even more restricted.
13:57:23 <Cale> oh, okay :)
13:59:24 <jethr0> @seen conal
13:59:25 <lambdabot> Unknown command, try @list
13:59:36 <SamB> so ... can we write in Haskell functions that aren't computable ?
14:00:21 <jethr0> have any of you ever implemented a record/replay functionality in reactive/FRP/yampa?
14:03:54 <jokerGTA> why when i am have [prelude at the prompt i get error when using add 1 3.......<interactive>not in the scope 'add'
14:04:01 <jokerGTA> why there is nobody chatting here
14:04:01 <jokerGTA> lol
14:04:13 <copumpkin> because of the damn netsplits :(
14:04:20 <copumpkin> really annoying
14:04:27 <lpsmith> add is not a predefined word
14:04:45 <jethr0> jokerGTA, "add" is not defined in the prelude
14:04:54 <jethr0> either do "(+) 1 3"
14:05:17 <jethr0> or define add as "let add a b = (+) a b"
14:05:21 <jokerGTA> why when i use add 1 2 i get not in scope error
14:05:25 <ziman> SamB, no, there are no algorithms for non-computable functions
14:05:27 <Botje> .. patient fellow, that.
14:05:39 <Peaker> jethr0: no-one has implemented Reactive fully yet :( (It doesn't yet seem to work properly)
14:06:02 <roconnor> SamB: so f ( _|_ ) = True, f (True) = _|_ is discontinuous and cannot be written in pure Haskell.
14:06:05 <jethr0> i tried helping "jungehexe" with a problem she has with SOE reactive toolkit
14:06:29 <SamB> roconnor: it's also partial ;-)
14:06:31 <jethr0> she wants to do recording/playback within the reactive function "Str Env -> Str Graphic".
14:06:41 <Botje> jokerGTA: because there's no function "add" in the prelude.
14:06:48 <roconnor> SamB: that too
14:06:55 <Botje> jokerGTA: you need to define it yourself, as jethr0 said
14:06:56 <SamB> roconnor: and I think it's uncomputable ;-)
14:06:58 <jokerGTA> oh ok Botje..i though add is built in function
14:07:00 <jethr0> i'm sure it's possible with some nice arrow/stream bending magic, but it seemed too difficult for my humble frp understanding
14:07:03 <roconnor> SamB: so f ( _|_ ) = True, f (True) = False is discontinuous and cannot be written in pure Haskell.
14:07:03 <dolio> You can't write it period, really.
14:07:08 <Botje> (+) is built in, add isn't :)
14:07:08 <jokerGTA> ok i will do that then
14:07:11 <dolio> Since you can only catch certain bottoms, even with IO.
14:07:15 <jokerGTA> oh ok :)..thanks
14:07:22 <ziman> roconnor, cannot be written in /pure/ Haskell? Is there other Haskell it could be written in?
14:07:23 <jokerGTA> thanks botje
14:07:31 <SamB> dolio: yeah, I just said it's uncomputable ;-)
14:07:42 <SamB> ziman: haskell with some kind of halting oracle?
14:07:51 <jethr0> Botje: i seem to be ignored today. maybe a one-way netsplit ^_^
14:07:55 <roconnor> ziman: well catch loop expections, and you can do strange things in the IO monad.
14:08:27 <BMeph> roconnor: Sorry to be beating the dead horse (blame the netsplits, if you like). Iwas wnodering, did you see CCShan's analysis of Escardo's stuff?
14:08:28 <Botje> jethr0: i wouldn't know, i have JOINS PARTS QUITS turned off.
14:08:38 <roconnor> BMeph: I don't think so
14:08:42 <blackh> jethr0: I haven't done record/replay in Yampa
14:08:43 <Botje> jethr0: but yes, there's days where i feel ignored too. have a cookie from me :)
14:08:44 <SamB> roconnor: yeah, but telling _|_ from True requires a halting oracle ;-)
14:08:46 <roconnor> BMeph: that might be helpful.
14:09:04 <jethr0> me usually too. but for the big netsplit spectacles chatzilla turns it back on again ;)
14:09:13 <jethr0> thx
14:09:32 <roconnor> SamB: catching loop exceptions is like a partial halting oracle.  It can see some representatives of _|_.
14:09:41 <SamB> roconnor: I know ;-)
14:09:44 <Peaker> SamB: or a computer vastly bigger than the one you're computing on :)
14:09:44 <roconnor> (obviously they must be computable in some sense).
14:09:58 <Phyx-> Botje: can i have a cookie too? :P
14:10:02 <Peaker> SamB: exploiting its finiteness
14:10:02 <SamB> Peaker: well, okay ;-)
14:10:08 <SamB> Yeah, I got that
14:10:11 <Botje> Phyx-: sure, have a lambda cookie :)
14:10:20 <SamB> that's assuming the computer is actually a finite state machine ;-)
14:10:29 <SamB> who knows for sure if they actually are ?
14:10:30 <Phyx-> :)
14:10:37 <Peaker> its difficult to build infinite machines in a universe we don't even know is infinite :)
14:10:39 <BMeph> roconnor: "For your consideration": http://conway.rutgers.edu/~ccshan/wiki/blog/posts/StreamPEval/
14:11:17 <roconnor> SamB: and all that loop expection stuff is safely inside IO, so it doesn't really bother.  I just put the "pure haskell" to be safe from possible objections.  I'm not sure that the "pure" is really needed.
14:13:25 <BMeph> "Pure" has many different meanings in the CS world... :)
14:13:36 <jethr0> Peaker: i've never really bought into the whole "that's more possible outcomes than there are particles in the universe"-argument. who knows what lurks in sub-space, higher dimensions, quantum worlds, ...
14:13:56 <jethr0> the finiteness of our 4-dimensional universe really only says so much
14:14:10 <jethr0> of the perceivable 4 dimensions, that is
14:14:12 <roconnor> Peaker: since I'm talking about denotations of haskell code, I'm assuming we are working with an ideal computing machine with infinite memory.
14:14:22 <roconnor> er
14:14:26 <roconnor> I'm not even assuming that
14:14:37 <roconnor> I'm not even talking about computing at all :D
14:15:25 <dolio> If we were talking about computing, it'd be obvious that (N -> Bool) -> Bool is countable.
14:15:31 <dolio> And so is (N -> Bool).
14:16:43 <ziman> ...because there are only countably many computable functions?
14:16:49 <dolio> Yes.
14:17:15 <jethr0> countable(Bool) && countable(N->Bool) => countable((N->Bool)->Bool)
14:17:42 <jethr0> countable(Bool) && countable(N) => countable(N->Bool)
14:18:13 <roconnor> dolio: but since haskell function F :: (N -> Bool) -> Bool doesn't have access to the intenstional code of its parameter f, thinking that (N -> Bool) is countable isn't helpful when programming.
14:18:53 <Cale> jethr0: Typically what is meant is that the number of outcomes is larger than the estimated number of particles in the part of the universe we've observed, which is somewhere between 10^72 and 10^87.
14:19:14 <Cale> jethr0: It's really not hard at all for combinatorial growth to exceed that.
14:19:20 <jethr0> who said countability was helpful for programming ;). countable infinite sets will likely be a pain to work with completely programming-wise
14:19:21 <dolio> Well, it may not be helpful, but it'd be obvious. :)
14:19:38 <roconnor> Cale: what about exceeding 2^(10^87) ?
14:19:45 <jethr0> Cale: yes, but so? i find that to be comparing apples and oranges
14:20:09 <HugoDaniel> hmm
14:20:10 <jethr0> even taking quantum computation with just a few qubits will make HUGE combinatorical calculations possible
14:20:18 <HugoDaniel> some crazy idea about dyre come to me...
14:20:42 <HugoDaniel> is it possible to use continuations in order to continue execution right where recompilation was triggered ? :P
14:21:08 <HugoDaniel> through some magic use of serialization or something like that :/
14:21:08 <roconnor> So when programming in haskell I thin it is helpful to think of N as countable, (N -> 2) as uncountable and (N -> 2) -> 2 as countable.
14:21:22 <Cale> jethr0: But... not really all of them. It's rather hard to say what computations quantum computers can do better than classical ones. We only know of a few specific problems where they do better.
14:21:51 <Saizan> HugoDaniel: ghc doesn't offer any way to serialize arbitrary functions
14:22:23 <Cale> There's no easy way to take a combinatorial problem in exptime and turn it into an efficient quantum computation.
14:22:25 <HugoDaniel> even with the use of continuations ?
14:22:39 <Cale> (at least that we know of)
14:22:56 <HugoDaniel> oh well, it was just a stupid idea that came to mind :/
14:23:02 <jethr0> still, comparing particles with combinatorial outcomes seems moot.
14:23:48 <roconnor> heh, if GHC could (purely) serialize functions, then it would be helpful to think of (N -> 2) as countable.
14:23:57 <Saizan> HugoDaniel: it's a quite interesting idea, but we'd have to implement it in ghc :)
14:24:18 <roconnor> I suppose (N -> 2) -> IO Integer would be a reasonable (non-pure) serialization function.
14:24:22 <jethr0> you mean "fun :: Integer -> Integer; fun _ = 2"?
14:24:29 <Cale> jethr0: It's just a way to get a handle on the size of the numbers involved.
14:24:47 <copumpkin> naturals to bool?
14:24:47 <HugoDaniel> oh allright :)
14:24:57 <HugoDaniel> maybe if i get good at haskell, someday i can help out in ghc
14:25:11 <jethr0> k, it's only that my handle on the particles in the universe isn't that well calibrated
14:25:11 <Cale> jethr0: If the numbers involved are larger than the number of particles in the universe, then it means they're large enough that you can't reach them by counting normal physical objects :)
14:25:15 <roconnor> copumpkin: yes, since that is what I have been talking about.  I'm just merging two distinct threads of conversation.
14:25:30 <roconnor> probably foolishly
14:25:32 <copumpkin> roconnor: oh, I was reponding to jethr0 :)
14:25:36 <jethr0> Cale: exactly, for me not too helpful though
14:25:44 <copumpkin> roconnor: in a not-very-self-confident manner
14:26:03 <jethr0> 2 == Bool?
14:26:16 <ziman> the threads begin to blend :)
14:26:30 <Saizan> yes
14:26:38 <roconnor> 2 == Bool
14:26:40 <Tony[`]> Anyone wanna flood me with some articles on understanding monads?
14:26:41 <copumpkin> quick, forkIO them
14:26:55 <copumpkin> Tony[`]: nah, monad tutorials all suck, sorry :)
14:27:00 <Tony[`]> :P
14:27:09 <byorgey> @where typeclassopedia
14:27:09 <lambdabot> Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
14:27:12 <jethr0> Tony[`]: there are too many. you'd be overflooded
14:27:16 <jethr0> @where lyah
14:27:16 <lambdabot> www.learnyouahaskell.com
14:27:19 <byorgey> Tony[`]: that has lots of references if you want to be flooded =)
14:27:25 <jethr0> @where rwh
14:27:25 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
14:27:28 <Tony[`]> byorgey: thanks :)
14:27:37 <Saizan> @wiki Monads as computation
14:27:38 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
14:28:01 <Tony[`]> I expected no less from you guys, thanks very much
14:28:38 <jethr0> we could go on, and on, and on, ++ cycle "and on, "
14:30:02 <HugoDaniel> i like the "overloaded ';'" concept about monads
14:30:13 <Tony[`]> Hugo, explanation?
14:30:35 <jethr0> Tony[`] favors a very terse dialog style ;)
14:30:52 <Tony[`]> <3
14:31:34 <HugoDaniel> Tony[`]: i dont know how to explain it without explaining monads, but since im not better than the tuts, i wont :/
14:32:29 <ezyang> Tony[`]: The basic idea is that do notation unsugared has a bunch of >>=s at the end of statements
14:32:43 <ezyang> These are the place "semicolons" normally would go, and they can have arbitrary semantics
14:32:57 <Tony[`]> Ah alright
14:32:57 <HugoDaniel> Tony[`]: the tutorial that made me understand monads was this: http://www.haskell.org/all_about_monads/html/index.html
14:33:17 <Tony[`]> Thanks again :0
14:33:20 <Tony[`]> :)
14:33:42 <jethr0> even though that green-on-green style may have looked better in its day...
14:34:48 <jethr0> hehe, "(>>=) can have arbitrary semantics". not sure the holy laws agree with you there *g*
14:35:19 <ezyang> jethr0: hahaha, righto
14:35:43 <jmcarthur> yeah, arbitrary would mean that you can't really reason about it
14:36:08 <jethr0> holy monad scripture speaketh of the laws that are not meant to be broken
14:36:26 <HugoDaniel> Tony[`]: you should look into functors first, i guess it will help
14:36:32 <roconnor> (N -> N) -> 2 might be uncountable
14:37:30 <ezyang> Today's Haskell refactoring exercise: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9166#a9166
14:37:30 * jethr0 doesn't see how combining countable types with functions could ever produce something uncountable...
14:37:46 <ezyang> I guess I want a state monad or something
14:37:51 <jethr0> can't you just build a huge table (n->n) and use the diagonality approach to show its isomorphism with N?
14:37:52 <copumpkin> jethr0: a powerset has strictly higher cardinality than the "base"? or something like that
14:39:31 <roconnor> jethr0: (N -> 2) is uncountable because there is a function (N -> (N -> 2)) -> (N -> 2) that takes any (continuous) surjection candidate and produces an output that isn't in the image of the candidate surjection function
14:39:42 <copumpkin> ...or that :)
14:39:49 <roconnor> (remember by -> I always mean continuous function)
14:39:54 * ezyang goes "aggggh math!" 
14:40:10 <roconnor> copumpkin: (N -> 2) -> 2 is countable.
14:40:18 <jethr0> hmm
14:40:25 <bla123> what does (N -> 2) mean?
14:40:28 <copumpkin> yep
14:40:44 <roconnor> (N -> 2) == Natural -> Bool, and -> means continuous function.
14:41:39 <bla123> so (N -> 2) is countable, but (N -> N) is not?
14:41:55 <Tony[`]> of course, bla123
14:41:55 <roconnor> both N -> 2 and N -> N are uncountable
14:42:01 <Tony[`]> (random guess :P)
14:42:17 <roconnor> but (N -> 2) -> 2 is countable
14:42:24 <copumpkin> hrm
14:42:38 <roconnor> construction an injection from X to (X -> 2) naively requires using decidable equality on X
14:42:39 <ezyang> I guess what I don't understand is how we're talking about the countability of functions
14:43:18 <jethr0> (0->True, ((1->True, ...) | (1->False, ...)) | (0->False, ((1->True, ...) | (1->False, ...))
14:43:28 <ezyang> Ahhh
14:43:47 <roconnor> good point, I guess by countablility I mean a bijection with N where the two functions are continuous
14:43:50 <jethr0> at first glance that looks countable to me. but then again my maths has always been slightly weak
14:43:58 <roconnor> maybe I should use a different word.
14:43:59 <bd_> ezyang: countability of the _set_ of continuous functions of a given domain/range even
14:44:59 <copumpkin> I enumerate some functions in that dumb library I put up on hackage :P
14:45:14 <roconnor> jethr0: I think you end up with so many ... that you lose countability :D
14:45:30 <jethr0> well, it's a binary tree
14:45:38 <bla123> is there an easy relationship between 2^N and (N -> N)? (except that both are uncountable)
14:45:44 <roconnor> and there are an uncountable number of paths through a binary tree
14:45:58 <jethr0> at first glance again (n->n) seems far less complex than the rational numbers
14:46:05 <jethr0> and those are countable too
14:46:09 <copumpkin> jethr0: really?
14:46:13 <copumpkin> why less complex?
14:46:23 <jethr0> sorry, meant (n->2)
14:46:32 <copumpkin> n -> 2 === Map Natural Bool
14:46:37 <ezyang> I thought rational numbers weren't countable?
14:46:40 <copumpkin> they are
14:46:45 <roconnor> jethr0: 2 -> N are like the rationals
14:46:53 <ezyang> oh, irrational numbers were the uncountable ones
14:46:57 <copumpkin> yep
14:47:16 <jethr0> hmm
14:47:37 <roconnor> 2 -> N ~~ N*N ~~ N
14:48:58 <jethr0> weird, (n->n) is almost the sum of all permutations of rational numbers (maybe) (it's getting late)
14:49:22 <bla123> when we talk about the countability of functions, are two different functions that behave the same counted as 1?
14:49:38 <jethr0> roconnor is this a description of (n->2), or am i mistaken?
14:49:41 <jethr0> (0->True, ((1->True, ...) | (1->False, ...)) | (0->False, ((1->True, ...) | (1->False, ...))
14:49:51 <copumpkin> bla123: that's how I'd do it (and did it)
14:49:59 <roconnor> jethr0: that is not an unreasonable description.
14:50:09 <Tony[`]> so.. raise your hand if you were a math major? :)
14:50:15 <roconnor> jethr0:   2 -> N  are paths through a binary tree
14:50:22 * |Steve| raises hand.
14:50:27 <roconnor> and there are an uncountable number of paths
14:50:43 <copumpkin> N -> 2?
14:50:45 * jethr0 is a CS major, which involved a LOT of maths
14:50:48 <philed> The number of paths through infinite binary trees is exactly 2^N.
14:50:51 <roconnor> bla123: yes
14:50:58 * copumpkin was a CS major
14:50:58 <philed> That's the cardinality of the reals.
14:51:09 <jethr0> always a little over my head, especially category theory ;)
14:51:20 <Tony[`]> what uni, jethr0?
14:51:27 <jethr0> karlsruhe, germany
14:51:35 <roconnor> jethr0:   N -> 2  are paths through a binary tree
14:51:41 <roconnor> copumpkin: thanks for the corrections
14:51:49 <|Steve|> jethr0: That's a surprise. Most CS majors at both schools I've attended were very light on the math, at least until graduate school.
14:51:53 <copumpkin> sorry for not targeting it :)
14:52:23 <jethr0> |Steve|: really? we did sth like a full bachelor (vordiplom) in maths together with all the maths students.
14:52:24 <Tony[`]> Steve, how about you, if I may ask? (what uni)
14:52:37 <jethr0> it was pretty intense. unfortunately i wasn't ever on top of it and have long forgotten most
14:52:54 <roconnor> because both N and 2 have a discrete topologies, all functions between N and 2 are continuous
14:53:00 <|Steve|> Tony[`]: I tend to let people figure that out for themselves.
14:53:05 <Tony[`]> :P
14:53:07 <roconnor> so N -> 2 == 2^N
14:53:24 <|Steve|> 2^N is the set of maps from N to {0,1}.
14:53:51 <|Steve|> At least if you identify the emptyset as 0 and for each natural number n > 0 with {0,1,...,n}.
14:53:53 <ezyang> Oh, is ^ just -> backwards?
14:54:21 <copumpkin> ezyang: not quite, but think of functions from Ordering to Bool
14:54:21 <roconnor> for this conversation, I'm using ^ to be set-theorict functions and -> to mean continuous functions.
14:54:45 <copumpkin> @src Ordering
14:54:45 <lambdabot> data Ordering = LT | EQ | GT
14:54:52 <jokerGTA> guys is there built in function that returns index of element in the list
14:55:01 <|Steve|> @type findIndex
14:55:01 <copumpkin> ezyang: how many (total) functions are there from Ordering to Bool?
14:55:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
14:55:17 <yitz> @type index
14:55:18 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
14:55:23 <yitz> oh
14:55:24 <copumpkin> ezyang: you can play with some of this stuff in my enumerable package if you're interested
14:55:48 <ezyang> copumpkin: Infinitely many! (not actually a good answer)
14:55:54 <|Steve|> ezyang: 8.
14:56:02 <copumpkin> ezyang: I'm talking about equality "as viewed from the outside"
14:56:14 <ezyang> Oh wait, ordering is not Ord
14:56:26 <HugoDaniel> oh, # means unboxed
14:56:33 <copumpkin> HugoDaniel: not necessarily
14:56:37 <copumpkin> but usually
14:57:05 <ezyang> Ok, right, it's the permutations of all inputs and all outputs
14:57:14 <|Steve|> Not really.
14:57:33 <|Steve|> For each element in the domain, it can be mapped to any element in the codomain.
14:57:48 <|Steve|> So since you have 3 elements in the domain and 2 elements in the codomain, you have 2*2*2 = 8.
14:58:01 <ezyang> Ah.
14:58:08 <copumpkin> Prelude Data.Enumerable Data.Ord> length (enumerate :: [Ordering -> Bool])
14:58:09 <copumpkin> 8
14:58:30 <jokerGTA> copumpkin...you there:)
14:58:40 <ezyang> Ok, that's exponential
14:58:43 <ezyang> Aha! Carrot!
14:58:48 <copumpkin> jokerGTA: yep
14:59:16 <jokerGTA> i was wondering if there is built in function that returns index of given element of the list
14:59:36 <Botje> not built-in, but easily constructed
14:59:41 <|Steve|> What?
14:59:43 <copumpkin> @index elemIndex
14:59:44 <lambdabot> Data.List
14:59:47 <copumpkin> @index findIndex
14:59:48 <lambdabot> Data.List, Data.Map
14:59:54 <copumpkin> :t elemIndex
14:59:55 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
14:59:56 <bd_> @hoogle Eq a => a -> [a] -> Int
14:59:56 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
14:59:56 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
14:59:56 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
14:59:56 <|Steve|> > findIndex 5 [1..10]
14:59:58 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
14:59:58 <lambdabot>    arising from the lite...
15:00:13 <copumpkin> > elemIndex 5 [4..100]
15:00:14 <lambdabot>   Just 1
15:00:19 <copumpkin> > elemIndex 5 [1..3]
15:00:20 <lambdabot>   Nothing
15:00:53 <|Steve|> Oh, I needed (5==) for findIndex.
15:01:16 <|Steve|> > findIndex (5==) [1,3..]
15:01:17 <lambdabot>   Just 2
15:02:32 <jokerGTA> how do you get 2 out of "just 2"
15:02:39 <jokerGTA> how to extract it
15:02:46 <Botje> use pattern matching
15:02:50 <|Steve|> > fromJust (Just 5)
15:02:52 <lambdabot>   5
15:02:58 <jokerGTA> ok
15:03:11 <copumpkin> don't use fromJust
15:03:12 <Philonous> > fromJust Nothing -- caveat
15:03:13 <lambdabot>   * Exception: Maybe.fromJust: Nothing
15:03:25 <jokerGTA> is there any site that list all the functions avaiable beside haskell.org....thast site kind of confusing for me
15:03:43 <copumpkin> hoogle, if you know what to look for
15:03:44 <Philonous> Dont pull the 2 out of Maybe, push your algorithm into it. (use fmap)
15:03:44 <|Steve|> Why not? fromJust is a perfectly good function if you know it'll be a Just.
15:03:50 <bd_> http://www.haskell.org/ghc/docs/latest/html/libraries/ if you're just browsing
15:04:43 <jokerGTA> fromJust gives error when you use it on fromJust (Just 5)
15:04:44 <angrep> i'm currently reading through Real World Haskell... any other recommended tomes of knowledge for a beginner with some functional programming experience?
15:05:00 <jethr0> typeclassopedia
15:05:04 <yitz> > fromJust (Just 5)
15:05:05 <lambdabot>   5
15:05:12 <|Steve|> jokerGTA: Works for me.
15:05:39 <|Steve|> @src fromJust
15:05:39 <lambdabot> fromJust Nothing  = undefined
15:05:39 <lambdabot> fromJust (Just x) = x
15:05:39 <jethr0> practical common lisp was pretty cool, even if it goes in the opposite direction of haskell ^_^
15:06:17 <jokerGTA> ifor me it says not in scope 'fromJust"
15:07:02 <jethr0> import Data.Maybe (fromJust)
15:07:16 <jethr0> also note that fromJust is one of those evil partial functions
15:07:52 <jokerGTA> yeah it works now
15:07:53 <jethr0> it's "better" to use for example "maybe"
15:07:58 <jethr0> :type maybe
15:08:31 <jethr0> preflex: :type maybe
15:08:40 <copumpkin> or fromMaybe
15:08:49 <jethr0> no luck with the ladies tonight
15:09:08 <mauke> :t maybe
15:09:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:09:23 <jethr0> :t fromMaybe
15:09:24 <lambdabot> forall a. a -> Maybe a -> a
15:09:56 <PetRat_> I'm trying to understand qtHaskell. I have a question---it looks like there are types that basically wrap something in a constructor, and types that wrap that in a constructor, and on and on. You can see some examples here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9167#a9167
15:09:57 <jethr0> > fromMaybe 0 (Just 1)
15:09:58 <lambdabot>   1
15:10:12 <PetRat_> What I'm wondering is if this is a way of handling hierarchies of subclasses.
15:10:16 <jethr0> > maybe 0 id $ Just 1)
15:10:17 <lambdabot>   <no location info>: parse error on input `)'
15:10:18 <jethr0> > maybe 0 id $ Just 1
15:10:19 <lambdabot>   1
15:10:21 <PetRat_> (as they exist in Qt)
15:12:52 <Nereid_> so FileManip fails to build: http://dpaste.com/90774/
15:13:10 <Philonous> "data CQObject a" is not a shorthand. It actually means the empty datatype (i.e. only _|_ "bottom" is member of it)
15:13:18 <Nereid_> ghc 6.10.4, etc
15:13:31 <Tony[`]> where is fromJust found?
15:13:39 <|Steve|> Data.Maybe
15:14:24 <PetRat_> Philonous: thanks. is the 'a' (as in CQObject a) a type variable? What does it need a type variable?
15:14:52 <jethr0> @hoogle fromJust
15:14:52 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
15:15:04 <jokerGTA> can someone look what i did with this function for returning the index
15:15:07 <jokerGTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9168#a9168
15:16:23 <blackh> jokerGTA: length a == 0 will evaluate the whole list.  null a is better.
15:16:25 <Philonous> Yes, a in this case is a type variable. Thoug I don't know why it needs it (as I don't know qtHaskell). But I'd quess this construct is used to make some stuff type safe
15:16:42 <Nereid_> jokerGTA: aside from what blackh said, you'll have a type error, since you're comparing an Integer and an Int
15:17:18 <Nereid_> you'll have to convert one to the other using something like fromInteger or fromIntegral
15:17:30 <benmachine> or toInteger
15:17:41 <PetRat_> Philonous: do you think all this typery is a matter of implementing hierarchies of classes as they exist in Qt? I guess it makes it type-safe? For example, in Qt an object can be a QMenuBar, which is a subclass of QWidget, which is a subclass of QObject. So it is all three.
15:17:45 <jokerGTA> what if i do this...
15:17:47 <jokerGTA> find :: [Int] -> Int -> Int
15:18:00 <blackh> jokerGTA: Another way to write this is... find a b = fromMaybe (error "Empty list") (findIndex (b ==) a)
15:18:01 <Nereid_> why restrict to Int anyway?
15:18:04 <Nereid_> you chould just have
15:18:23 <Nereid_> find :: (Eq a) => [a] -> a -> Int
15:18:30 <blackh> Actually that's wrong. :)
15:19:11 <benmachine> what's wrong
15:19:19 <blackh> find a b = fromMaybe (error "not found") (findIndex (b ==) a)   <-- better
15:20:22 <Nereid_> it's probably better to use something like find :: [Int] -> Int -> Maybe Int instead
15:20:37 <copumpkin> Nereid_: and that's what's in Data.List, flipped, and more general :P
15:20:51 <Nereid_> yeah
15:20:53 <Philonous> PetRat_:  I honestly don't know. Some of it seems to be. But your code fragment leaves me puzzled tbh.
15:21:31 <Nereid_> jokerGTA: so if you're using that for something practical, use Data.List.elemIndex
15:21:59 <jokerGTA> all i need is to give function a list and number..and i want to get back index of given number
15:22:02 <PetRat_> Philonous: thanks.I will carry on then with my attempt to understand or use this. If I follow the numerous examples that comes with qtHaskell, in one sense I don't need to understand it. Just do the same thing.
15:22:35 <_-jn> Hello! I would like some guidance, if I want to read and write to tables in a MS SQL Server 2005 data base (tcp connection), is Takusen the way to go?
15:23:08 <ezyang> Can this be automatically derived? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9169#a9169
15:23:51 <Nereid_> ezyang: yes, replace data with newtype and use the GeneralizedNewtypeDeriving extension
15:24:33 <ezyang> savvy
15:25:01 <Nereid_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9169#a9170
15:25:02 <Nereid_> :)
15:25:27 <ezyang> oh, sweet
15:25:49 <ezyang> I didn't know newtype supported named fields
15:26:07 <Nereid_> sure it does :)
15:26:14 <Nereid_> as long as it's 1 field
15:26:33 <ezyang> Haha, kind of not so useful, I s'pose :-)
15:27:03 <Nereid_> well, newtype's purpose is exactly for wrapping other types
15:27:18 <ezyang> Yes.
15:27:28 <Philonous> ezyang: Actually it is. newtype Foo a = Foo {unFoo :: a} automatically gives you the unwrapper unFoo :: Foo a -> a
15:27:29 <ezyang> 'tis true
15:27:38 <BMeph> _-jn: Hmm, sorry, I don't do db stuff in Haskell yet. Keep asking, and someone may help
15:28:10 <hackagebot> usb-id-database 0.2 - A database of USB identifiers (RoelVanDijk)
15:30:03 <jethr0> usb?
15:30:11 <jethr0> why would that be haskell-specific?
15:31:21 <Nereid_> doesn't have to be haskell-specific
15:33:18 <jethr0> i'm not complaining
15:33:28 <Nereid_> :)
15:35:17 <jokerGTA> blackh you still there
15:35:32 <Nereid_> jokerGTA: what do you need?
15:35:35 <blackh> jokerGTA: Yes
15:35:39 <Nereid_> :)
15:35:44 <jokerGTA> i wrote it again and still gives parametars errorsd
15:35:47 <jokerGTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9171#a9171
15:36:23 <blackh> jokerGTA: You want  | null a = error ...
15:36:37 <Nereid_> and a few other things
15:37:09 <Nereid_> maybe you do want to error on an empty list, but I think it would make more sense to return Nothing
15:37:27 <Nereid_> so the empty list isn't a special case
15:37:32 <jokerGTA> ot gives me this error"cpuldnt match expected type 'Int->Bool' agaainst inferred type Int
15:37:50 <Nereid_> look at the type of elemIndex
15:37:52 <Nereid_> :t elemIndex
15:37:53 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
15:37:56 <jokerGTA> ok
15:38:07 <Nereid_> the first argument has to be an Int
15:38:12 <Nereid_> and you're giving it an Int->Bool
15:38:27 <jokerGTA> yeah but that why i put elemIndex inside the function fromJust which should return int
15:38:45 <Nereid_> but you're specifying that find returns Maybe Int
15:39:17 <jokerGTA> yeah it was same kinf of error when i had only Int for return type
15:39:25 <jokerGTA> thats why i changed it to Maybe Int to see iof it will work
15:39:29 <Philonous> jokerGTA: Your getting a Maybe Int, pull the Int out of it and then wrap it in Maybe again? (At least that's what the type of your functions suggests)
15:40:00 <Nereid_> jokerGTA: you know what Maybe is for, right?
15:40:06 <jokerGTA> does fromJust returns Int?
15:40:21 <jokerGTA> no i dont
15:40:31 <ezyang> Yes.
15:40:59 <jokerGTA> fromJust   (elemIndex (b ==) a)
15:41:05 <jokerGTA> then this should be correct then
15:41:14 <Nereid_> ok let's look at the types
15:41:16 <jokerGTA> find :: [Int] -> Int -> Int
15:41:16 <Nereid_> a :: [Int]
15:41:22 <Nereid_> (b==) :: Int -> Bool
15:41:39 <Nereid_> elemIndex :: Int -> [Int] -> Int in this case
15:41:50 <Nereid_> so the first argument to elemIndex has to be an int
15:42:03 <Elly> Eq a => a -> [a] -> Int!
15:42:09 <Elly> (without the ! :P)
15:42:22 <Nereid_> in general yes
15:42:27 <benmachine> enthusiastic integer
15:42:28 <Nereid_> but instantiating a = Int
15:43:43 <Nereid_> jokerGTA: are you writing this function to use it for something practical, or is it an exercise?
15:44:15 <jokerGTA> exercise
15:44:17 <Nereid_> ok
15:44:17 <Nereid_> :)
15:44:32 <jokerGTA> just to return index for the given element
15:44:45 <Nereid_> ok
15:44:58 <Nereid_> you should try writing it without using any functions like findIndex and elemIndex
15:45:16 <jokerGTA> i started with haskell 2 days ago...lol...
15:45:19 <Nereid_> :)
15:45:29 <Nereid_> what I mean is
15:45:43 <Nereid_> just write it recursively
15:45:53 <Nereid_> pattern matching on the list
15:45:59 <Nereid_> anyway, the purpose of Maybe is:
15:46:16 <Philonous> I think it is fine to do this as an exercise, but try writing it again recursively and / or with a fold afterwards ;)
15:46:41 <Nereid_> Philonous: but what he wants is flip elemIndex
15:46:41 <jokerGTA> yeah i might have to try to do that
15:46:43 <Nereid_> :P
15:46:47 <Nereid_> so
15:46:48 <Nereid_> Maybe
15:46:53 <Nereid_> contains either a value
15:46:54 <Nereid_> or Nothing
15:47:00 <jokerGTA> ok......,.,
15:47:08 <Nereid_> so you might want to write a function that might return a value
15:47:11 <Nereid_> but sometimes it doesn't
15:47:27 <Nereid_> so for example
15:47:43 <Nereid_> if your list is [0, 1, 2]
15:47:53 <Nereid_> and you want the index of 1, you'll want to return 1
15:47:59 <Nereid_> but if you want the index of, say, 5
15:48:06 <Nereid_> you don't return a value
15:48:08 <Nereid_> since 5 isn't in the list
15:48:19 <Nereid_> Maybe lets you do that nicely
15:48:30 <Nereid_> so in the second case, you return Nothing
15:48:35 <jokerGTA> yeah but actually i want to give function an element and return index of that element
15:48:38 <Nereid_> in the first case, you return (Just 1)
15:48:44 <Nereid_> yes
15:49:05 <Nereid_> maybe that specific list was confusing, so
15:49:10 <Nereid_> say your list is
15:49:13 <Nereid_> ['a', 'b', 'c']
15:49:19 <philed> Nereid_ I don't want to have to pattern-match everytime I pull an element from a list.
15:49:30 <Nereid_> philed: ?
15:49:38 <jokerGTA> i dont want pattern matching as well since i  am not familiar with it
15:50:02 <Nereid_> philed: he's writing elemIndex, as an exercise
15:50:10 <Nereid_> jokerGTA: well
15:50:14 <Nereid_> you should get familiar with it :)
15:50:18 <jokerGTA> :)
15:51:01 <philed> Nereid: Sorry, I just thought you were suggesting returning a Maybe from elemIndex.
15:51:28 <jokerGTA> ill play with it a little see how i do
15:51:32 <Nereid_> ok
15:52:01 <Cale> > case Just 7 of Nothing -> 0; Just x -> x^2
15:52:02 <lambdabot>   49
15:52:09 <Cale> > case Nothing of Nothing -> 0; Just x -> x^2
15:52:11 <lambdabot>   0
15:52:52 <lispy> > fmap (^2) (Just 7)
15:52:53 <lambdabot>   Just 49
15:52:58 <BMeph> Does anyone know the answer to _-jn's question? :)
15:53:00 <lispy> > fmap (^2) Nothing
15:53:01 <lambdabot>   Nothing
15:53:21 <Nereid_> (^2) <$> Nothing
15:53:25 <Nereid_> > (^2) <$> Nothing
15:53:25 <Nereid_> :-)
15:53:26 <lambdabot>   Nothing
15:54:42 <lispy> BMeph: I've never tried, but HDBC should be able to provide low level DB access.
15:55:11 <dons> dcoutts: how do we stop people depending on a minor version of something? http://hackage.haskell.org/package/TrieMap-0.0.1.2
15:55:34 <BMeph> lispy: Hey, I just wanted to be sure he got an answer. Maybe you should tell him? ;)
15:55:35 <ezyang> "the secret to writing any program in Haskell is to make a blog post about how your program can't be written in Haskell and wait a few days. A friendly British grad student will post a comment with the solution."
15:55:40 <philed> let primes p = p : filter (\n -> n `rem` p > 0) (primes (p + 1)) in take 10 $ primes 2
15:55:41 <Nereid_> dons: shoot them :-)
15:55:42 <philed> > let primes p = p : filter (\n -> n `rem` p > 0) (primes (p + 1)) in take 10 $ primes 2
15:55:44 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
15:55:48 <dons> elliottt: let yav know he has a user! http://hackage.haskell.org/package/usb-id-database-0.2
15:55:53 <philed> I couldn't get that to work on my lambabot.
15:56:00 <philed> *lambdabot
15:57:48 <BMeph> pjiled: I don't blame her. I wouldn't run that either. ;p
15:57:56 <Nereid_> FileManip still doesn't build :)
15:58:45 <philed> BMeph: It's a clich I wanted to show off in a random IRC channel.
15:59:32 <lispy> philed: what failed?
15:59:41 <lispy> philed: was there an error message?
16:00:01 <copumpkin> > nubBy (\x y -> x `mod` y == 0) [2..]
16:00:04 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:00:36 <lispy> ?pl \x y -> x `mod` y == 0
16:00:36 <lambdabot> flip flip 0 . ((==) .) . mod
16:00:55 <benmachine> copumpkin: I am impressed
16:01:00 <copumpkin> @let x `divides` y = y `mod` x == 0
16:01:01 <philed> lispy: To be honest, I couldn't get the eval to work. It just kept coming back with Terminated. Not sure why.
16:01:02 <lambdabot>  Defined.
16:01:05 <BMeph> :t ((==0).).mod
16:01:07 <lambdabot> forall a. (Integral a) => a -> a -> Bool
16:01:09 <copumpkin> > nubBy divides [2..]
16:01:12 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
16:01:16 <copumpkin> oh whoops :)
16:01:34 <copumpkin> @undef
16:01:39 <copumpkin> benmachine: :)
16:02:07 <copumpkin> > nubBy (flip divides) [2..]
16:02:12 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:02:14 <copumpkin> there, isn't that pretty?
16:02:21 <copumpkin> pity it's not efficient, but at least it's pretty
16:02:26 <philed> H'okay. That's pretty sweet.
16:02:26 <pikhq> > nubBy(((==0).).mod)[2..]
16:02:28 <benmachine> that's the main thing :P
16:02:28 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:02:34 <BMeph> > let oerjanPrime = nubBy (((>1).).gcd) [2..] in oerjanPrime
16:02:36 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:02:37 <Nereid_> > nubBy (flip divides) [1..]
16:02:51 <philed> You crazy Haskellers.
16:02:52 <lambdabot>   thread killed
16:02:55 <Nereid_> :-)
16:02:58 <benmachine> heh
16:03:19 <BMeph> > nubBy (((>1).).gcd) [1..] --Superior!
16:03:20 <pikhq> BMeph: Oh, that's actually an Oerjan original?]
16:03:22 <lambdabot>   [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,1...
16:03:29 <BMeph> ...or not. :)
16:03:29 <pikhq> Somehow, that does not surprise me in the slightest.
16:03:30 <copumpkin> BMeph: 1 is not a prime!
16:03:36 <Nereid_> indeed
16:03:38 <lispy> > fix $ \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs) -- one of my favorite 1 liners
16:03:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:03:49 <copumpkin> lispy: that can be golfed even further!
16:04:04 <RayNbow> > [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103]
16:04:07 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:04:11 <Nereid_> lol
16:04:20 <copumpkin> > fix ((0:) . scanl (+) 1)
16:04:31 <BMeph> pikhq: No, it isn't. I just saw oerjan use it here first. He said someone else put it up (maybe sorear?). :)
16:04:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:04:41 <pikhq> BMeph: Ah. Fair enough.
16:04:47 <pikhq> Still a nice bit of code.
16:05:18 <lispy> copumpkin: oh hrm...is that scanl version implicitly memoized too?
16:05:26 <lispy> :t scanl
16:05:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:05:30 <BMeph> pikhq: That's why it's in my Util file. :)
16:05:32 <copumpkin> lispy: yep!
16:05:43 <copumpkin> lispy: oh wait, how do you mean?
16:05:49 <copumpkin> it's no less efficient
16:05:58 <pikhq> BMeph: :)
16:06:00 <lispy> copumpkin: well the zipWith version can reuse the previous computations
16:06:02 <copumpkin> (as far as I know, at least)
16:06:06 <lispy> copumpkin: because they are stored in the list
16:06:13 <lispy> ?src scanl
16:06:13 <lambdabot> scanl f q ls = q : case ls of
16:06:13 <lambdabot>     []   -> []
16:06:13 <lambdabot>     x:xs -> scanl f (f q x) xs
16:06:14 <copumpkin> yep, same with the scanl one
16:06:17 <RayNbow> ?src fix
16:06:17 <lambdabot> fix f = let x = f x in x
16:06:51 <philed> ?src scanl
16:06:51 <lambdabot> scanl f q ls = q : case ls of
16:06:52 <lambdabot>     []   -> []
16:06:52 <lambdabot>     x:xs -> scanl f (f q x) xs
16:07:12 <BMeph> pikhq: I also have oleg's version, using lists of Bools. It's interesting...and very Scheme-looking. :)
16:07:14 <lispy> > fix $ scanl (+) 1
16:07:16 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
16:07:27 * copumpkin loves scanl
16:08:08 <shachaf> > let fibs = 1 : scanl (+) 1 fibs in fibs -- fix only makes it more confusing
16:08:09 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:08:53 <Nereid_> > let fibs = 0 : scanl (+) 1 fibs in fibs
16:08:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:09:03 <Nereid_> better :)
16:09:05 <copumpkin> shachaf: not really
16:09:10 <lispy> > scanl (+) 1 [0,0,0,0]
16:09:12 <lambdabot>   [1,1,1,1,1]
16:09:18 <copumpkin> > scanl1 (+) [1,3..]
16:09:20 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:09:24 <lispy> > scanl (+) 1 [1,1,1,1]
16:09:26 <lambdabot>   [1,2,3,4,5]
16:09:48 <copumpkin> > scanl1 (+) [a,b,c,d,e]
16:09:50 <lambdabot>   [a,a + b,a + b + c,a + b + c + d,a + b + c + d + e]
16:10:56 <lispy> oh right, good use of Expr
16:11:04 <shachaf> > scanl (+) z [a,b,c]
16:11:06 <lambdabot>   [z,z + a,z + a + b,z + a + b + c]
16:11:16 <benmachine> > scanl f z [a,b,c]
16:11:18 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
16:11:24 <dons> blackdog: why not show the core of xmonad?
16:11:34 <dons> real window manager. core functions a couple of lines long.
16:11:38 <lispy> > fix ((a:) . scanl (+) b)
16:11:41 <lambdabot>   [a,b,b + a,b + a + b,b + a + b + (b + a),b + a + b + (b + a) + (b + a + b),...
16:12:06 <Nereid_> > fix (f . scanl g b)
16:12:08 <dons> blackdog: slide 36, http://www.scribd.com/doc/19503176/The-Design-and-Implementation-of-xmonad
16:12:08 <lambdabot>   No instance for (SimpleReflect.FromExpr [b])
16:12:08 <lambdabot>    arising from a use of `Simp...
16:12:24 <Nereid_> moo
16:13:09 <copumpkin> > fix (((1 :+ 0) :) . scanl (+) (0 :+ 1))
16:13:12 <lambdabot>   [1.0 :+ 0.0,0.0 :+ 1.0,1.0 :+ 1.0,1.0 :+ 2.0,2.0 :+ 3.0,3.0 :+ 5.0,5.0 :+ 8...
16:13:18 <gurraman> worked like a charm! thanks! :)
16:13:28 <copumpkin> surprise!
16:14:16 <Nereid_> copumpkin: Fibonacci spiral? :)
16:14:53 <shachaf> dons: Hmm, is there some issue with /msgs?
16:15:23 <lispy> on freenode you can only send a /msg if you are identified, IIRC
16:15:44 <Gracenotes> meeoooow
16:15:44 <benmachine> no, but some people will only receive them if you are identified
16:15:47 <benmachine> I believe it is a usermode
16:16:04 <SamB> I think the default is for people to only recieve your /msgs if you are identified
16:16:18 <Gracenotes> benmachine: yes, +E
16:16:34 <benmachine> Gracenotes: does that turn it on or off?
16:16:41 <SamB> and they have to set a usermode to recieve /msgs from unidentified users
16:16:58 <Gracenotes> +E is blocking. it should be temporary, for the most part...
16:17:08 <Gracenotes> in its usage that is
16:17:55 <Gracenotes> except, as you said, I don't think you send if you're not identified. so it seems unnecessary
16:18:33 <jfoutz> :t (:+)
16:18:35 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
16:18:46 <Gracenotes> actually, experimenting.. this no longer seems to be the case
16:18:59 <Nereid_> > (0 :+ 1)^2
16:19:00 <lambdabot>   (-1.0) :+ 0.0
16:19:18 <Nereid_> > exp (0 :+ pi)
16:19:21 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
16:19:24 <blackdog> dons: ah, thanks. wasn't watching irc
16:19:29 <Nereid_> close enough :)
16:21:42 <Gracenotes> Complex CReal does it fine
16:22:07 <Gracenotes> fo' cereal
16:22:56 <philed> lol
16:24:18 <lispy> ?hoogle Complex a
16:24:18 <lambdabot> Did you mean: :: Complex a /count=20
16:24:19 <lambdabot> package storable-complex
16:24:46 <lispy> ?hoogle Complex a -> a
16:24:46 <lambdabot> Data.Complex imagPart :: RealFloat a => Complex a -> a
16:24:46 <lambdabot> Data.Complex magnitude :: RealFloat a => Complex a -> a
16:24:46 <lambdabot> Data.Complex phase :: RealFloat a => Complex a -> a
16:25:07 <lispy> > realPart (1.0 :+ 2.0)
16:25:09 <lambdabot>   1.0
16:25:18 <lispy> > phase (1.0 :+ 2.0)
16:25:19 <lambdabot>   1.1071487177940904
16:25:20 <blackdog> dons: the ideal would be something that's sensibly embeddable in ruby
16:25:40 <blackdog> i'm trying to sell them on the idea that it makes sense to use haskell for heavy lifting in web apps
16:25:47 <blackdog> with a ruby skin
16:26:07 <lispy> blackdog: how do they embedd Haskell in ruby?
16:26:13 <blackdog> my predictive app would not be a terrible example, but it doesn't compile under jhc
16:26:26 <blackdog> lispy: I'm glad you asked! They use Hubris, my ruby-haskell bridge!
16:26:26 <blackdog> :)
16:26:56 <lispy> blackdog: does it call the Haskell like a shared lib or sockets or ?
16:27:27 <blackdog> lispy: shared lib
16:27:36 <blackdog> which is why i started with jhc
16:27:53 <blackdog> but i've finally managed to build GHC with all the right switches now
16:28:06 <blackdog> so fingers crossed
16:28:57 <gurraman> ... and xmonad just works when you unplug your monitor. beautiful.
16:29:07 <lispy> blackdog: hmm...so you're not just bringing the RTS into the ruby process, you're bringing the compiler with you?
16:29:37 <blackdog> lispy: yep.
16:29:54 <blackdog> at the moment, all compilation of haskell code is done at runtime
16:30:03 <blackdog> but adding a cache for dynamic libraries shouldn't be too difficult
16:30:06 <BMeph> Hey, if Twitter can use Scala on the back end and ruby in front, surely we can use Haskell on a back end. :)
16:30:11 <lispy> I wanted to do this with GHC at a past job.  They had the python interpreter embedded.  I wanted to embedd GHC, but I never got any traction to do it :)
16:30:33 <lispy> BMeph: wait, twitter uses scala?
16:30:48 <BMeph> lispy: What, you didn't know? :)
16:31:38 <lispy> BMeph: I had no idea, but I don't use twitter so maybe I never looked in to it
16:31:47 <blackdog> lispy: it makes sense, really. i mean, obviously i'd like to see a strong, capable, feature-complete haskell web framework as much as the next guy, but as it stands, the python/perl/ruby frameworks are more mature
16:32:09 <benmachine> hey so has anyone put ghc on a phone yet?
16:32:12 <blackdog> lispy: and as a cynical marketing ploy, it's a good way to slip haskell in the back door, rather than trying for a frontal assault
16:32:26 <blackdog> benmachine: jhc runs on the iPhone, IIRC
16:32:33 <lispy> blackdog: I think python/perl/ruby are more accessible to the people who do web programming. (That's not a value judgement against those people, just an observation)
16:32:46 <Nereid_> blackdog: how good is happstack compared to those?
16:33:25 <philed> I haven't looked at Scala. As I understand, they have roughly favoured concessions to Java. No currying for instance.
16:33:27 <blackdog> Nereid_: 'good' is a value judgment. happstack is a very opinionated framework... it might even be the right way
16:33:46 <lispy> philed: scala is pretty conceptually deep
16:33:49 <blackdog> but there are a heap of mature frameworks in other languages that people know how to use already, productively
16:34:07 <BMeph> lispy: Frankly, since most reports on it came out around the first of April, I'm surprised anyone took it seriously. :)
16:34:09 <blackdog> it's not realistic to expect them to switch right away to a completely new system
16:34:15 <lispy> philed: it's a cool language; I've had issues with the implementation though (and heard those issues are fixed now)
16:34:20 <blackdog> just because they have some small performance problem somewhere
16:34:21 <philed> lispy: Could you elaborate? I'm totally up for trying it.
16:35:01 <lispy> philed: well, Scala has some of the more recent OOP ideas built in.  You can do mixins for example.  But, it also has a rich type system and pattern matching.
16:35:19 <kmc> i like scala's implicit parameters as a way to generalize typeclasses and make them less special
16:35:34 <lispy> philed: Scala also has support for explicitly lazy calculations
16:35:59 <kmc> i don't much like the syntax, but it might grow on me if i used it
16:36:20 <blackdog> lispy: yeah, but it's the frameworks that make them more accessible, i think.
16:36:29 <blackdog> and the libraries
16:36:38 <lispy> philed: and it has source level linking with Java and of course bytecode level
16:36:39 <philed> lispy: Sorry, I've never managed to find a reasonable definition of mixins. Could you give an example?
16:36:47 <kmc> also, function arguments are complicated -- you can have zero or more argument-lists, each with zero or more arguments
16:37:07 <kmc> though as a nice side effect, properties / data members are equivalent to functions with no argument-lists
16:37:42 <lispy> philed: heh, I used mixins once in a project for a class when I was learning scala but I've kinda forgotten too.  I think it was something about subtituting parts of a class heirarchy to get re-use and composibility
16:38:39 <philed> lispy: But the other advances in the type system: as I understand, it has upper and lower bound constraints. Anything else?
16:38:41 <lispy> philed: I still have the source and my project write up if you want to look it over
16:39:21 <lispy> philed: this is a darcs repo: darcs get http://projects.codersbase.com/repos/darcssim/
16:39:40 <lispy> philed: if you don't have darcs you can still browse the contents via the http
16:40:00 <philed> lispy: Cheers. I'll take a look. I'm quite keen on these languages aimed at the JVM and .NET. I'm using F# quite a bit at the moment.
16:40:20 <philed> I've got darcs.
16:40:55 <chaosape> howdy wondering if someone could tell me if something is possible?  I am clearly missing something -- http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=9172
16:44:37 <copumpkin> instance HasProperty Int
16:44:41 <copumpkin> instance HasProperty Double
16:44:50 <copumpkin> oh whoop
16:44:54 <copumpkin> Handler1 Int
16:46:42 <BMeph> Short answer: Type classes are open. :)
16:47:40 <lispy> BMeph: you can close them
16:48:02 <lispy> class Hidden a where  <-- don't expose this from your module
16:48:16 <lispy> class Hidden a => MyClosedTypeClass a where
16:48:36 <lispy> Then you only provide instances to Hidden for things that are allowed to be in your closed type class
16:52:34 <chaosape>  lispy; attempting grok.
16:57:53 <lispy> chaosape: I just looked at your hpaste and I have no idea what you're trying to do :)
16:58:04 <benmachine> all this time I thought lambdabot had an @info command and I finally worked out
16:58:12 <benmachine> it thought I was misspelling @undo
16:59:57 <chaosape> lispy: i want to have a propagating type class where intermediate calls don't know what return value is, they are just marshalling calls down different control flow paths ... sorry if that is a poor explanation ...
17:06:19 <kmc> anyone know how to apply this patch: http://int-e.home.tlink.de/haskell/network-ghc-6.11.dpatch
17:07:21 <Nereid_> by hand ;-)
17:07:23 <shachaf> kmc: With darcs?
17:07:52 <lispy> .dpatch is a darcs patch
17:08:08 <kmc> aha, that is good to know
17:08:09 <kmc> thank you
17:08:12 <lispy> cd ghc; darcs apply network-ghc-6.11.dpatch
17:08:46 <Nereid_> darcs would have been my next guess
17:09:26 <lispy> whoa, they need to tag the repository more often...that patch is mostly context
17:10:00 <lispy> actually, hmmm. there is a tag in that context
17:11:18 <blackdog> gott in himmel. i have dylibs working with ghc!
17:11:26 * blackdog is excited by the smallest things...
17:13:46 <burp> hm, [a,b,c,d, e,f,g,h, i,j,k,l] -> [d,c,b,a, h,g,f,e, l,k,j,i] -- how would you reverse each 4item-blocks?
17:13:51 <burp> some recursive take and reverse?
17:14:12 <Nereid_> are you guaranteed that length is a multiple of 4?
17:14:24 <Nereid_> well
17:14:32 <burp> let's say yes
17:14:44 <Nereid_> f [] = []; f (a:b:c:d:xs) = d:c:b:a:f xs
17:14:45 <Nereid_> ;-)
17:15:11 <burp> ow..
17:15:25 <dolio> f (a:b:c:d:xs) = d:c:b:a:f xs ; f l = reverse l
17:15:45 <dolio> That works even if it's not a multiple of 4.
17:16:12 <burp> hm right.. nice ones ;)
17:16:20 <Nereid_> to not tie it with 4 you're probably good with some splitAts and reverses
17:17:29 <olsner> perhaps something like... f [] = []; f xs = reverse (take 4 xs) ++ f (drop 4 xs)
17:17:49 <olsner> but it's probably objectively worse than pattern-matching (if nothing else, it seems to be longer)
17:17:55 <burp> olsner: hm yup, thats kind of thing I thought of
17:17:55 <lispy> it would be kinda nice to have a mapBlock :: Int -> (a -> b) -> [a] -> [b]
17:18:15 <lispy> Oh, not quite tat
17:18:50 <lispy> Well, what I want would require dependent types
17:18:55 <olsner> more like this? Int -> ([a] -> [b]) -> [a] -> [b]
17:19:17 <olsner> dependent types :>
17:19:19 <lispy> olsner: yes, that would work without the dependent types
17:20:05 <lispy> I realy want the the Int to go away and have the ([a] -> [b]) part contain that info
17:20:28 <lispy> (a -> a -> a -> [b]) would imply the Int is 3
17:23:49 <Nereid_> what about a foldBlock? :-)
17:24:05 <Nereid_> well I mean foldrBlock etc
17:24:30 <Nereid_> would that even make sense? :(
17:24:47 <lispy> have you seen the faking dependent types for zip paper?
17:24:58 <Nereid_> not I
17:25:27 <lispy> it's cool
17:25:36 <lispy> they simulate dependent types for the case of zip
17:25:38 <lispy> :t zip
17:25:40 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
17:25:41 <pacopil> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
17:25:41 <lispy> :t zip3
17:25:43 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
17:26:23 <Nereid_> if we had a splitEvery :: Int -> [a] -> [[a]]
17:26:27 <burp> Nereid: foldblock sounds nice
17:26:47 <lispy> http://www.brics.dk/RS/01/10/BRICS-RS-01-10.ps.gz  <-- that's the one. It's a fun read
17:26:56 <Nereid_> you could have mapBlock n f l = concat . map f $ splitEvery n l
17:27:05 <Nereid_> well, concat . map f = concatMap f
17:27:08 <lispy> Well, I think you probably want [[b]] in the output
17:27:15 <lispy> let the caller decide if they want to concat
17:27:22 <Nereid_> maybe
17:27:29 <Nereid_> but then
17:27:36 <Nereid_> just provide splitEvery
17:27:42 <Nereid_> everything else is trivial :)
17:28:30 <lispy> also, you could really be using lists of tuples and standard map :)
17:28:40 <lispy> where tuple means anything isomorphic to tuples
17:29:03 <lispy> that way the sizing gets to be part of the type and you get back some safety
17:29:20 <lispy> I gotta run
17:29:22 <Nereid_> :)bye
17:30:21 <BMeph> @hoogle splitEvery
17:30:21 <lambdabot> No results found
17:30:28 <BMeph> Aww.
17:30:59 <Nereid_> easy enough to define though
17:31:49 <BMeph> Anyway, There's splitEvery in the 'split' package. But yes, it's easy enough to define. I made one up called "fracture." :)
17:32:11 <Nereid_> what does that do?
17:32:24 <burp> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v%3AsplitEvery
17:32:27 <burp> wow.. split's heaven
17:32:32 <burp> so many splitters
17:33:01 <Nereid_> hmm
17:33:19 <Nereid_> my implementation of splitEvery returns [] if n = 0 and l is empty
17:33:34 <BMeph> Except I use 'fracture :: [Int] -> [a] -> [[a]]'
17:33:36 <Nereid_> let's see what split's does
17:33:46 <Nereid_> ahh, more general./
17:33:46 <Nereid_> :)
17:34:03 <BMeph> Nereid_: If l is empty, how could it return anything else? :)
17:34:25 <Nereid_> yeah but splitEvery 0 l returns (repeat []) if l is nonempty
17:34:45 <Nereid_> and [] if l is empty
17:34:51 <Nereid_> I just checked, the one in the split package does so too
17:35:01 <BMeph> Nereid_: Oh, 'fracture' is my own write-up, it isn't in the split package. Well, there's an equivalent, I'm sure, it just isn't called by that name. :)
17:35:19 <Nereid_> I assume your fracture is related by splitEvery = fracture . repeat
17:35:51 <BMeph> Nereid_: Right. Around here, though, we name that 'chunk'. :)
17:37:09 <BMeph> Nereid_: I've been looking at some of the NDP/DPH papers, and it (fracture) seemed like a useful helper function. :)
17:37:34 <cygnus> Is there an operator like <$> for composition? something to replace fmap f . g.
17:37:49 <Nereid_> BMeph: ah
17:38:01 <Nereid_> parallelize on chunks?
17:38:02 <Nereid_> :)
17:40:49 <Beelsebob> cygnus: (fmap . fmap)
17:40:56 <Beelsebob> (not really neater though)
17:41:10 <Beelsebob> (in this case at least)
17:42:15 <Nereid_> or fmap fmap fmap
17:42:15 <Nereid_> :-)
17:42:19 <Nereid_> since fmap is (.) on functions
17:42:35 <dolio> @type fmap fmap fmap
17:42:37 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:44:39 <jokerGTA> guys how do you cast Integer to Int
17:44:43 <jokerGTA> http://www.haskell.org/ghc/docs/latest/html/libraries/integer/GHC-Integer.html#t%3AInteger
17:44:47 <jokerGTA> i couldnt find it there
17:44:54 <dolio> fromIntegral
17:45:12 <Nereid_> or fromInteger
17:45:23 <jokerGTA> ok cool thanks
17:45:33 <jokerGTA> how come on that link it doesnt show that function[
17:45:55 <Nereid_> fromInteger is a function defined in the Num class
17:46:00 <Nereid_> of which Int is an instance
17:46:05 <Nereid_> so look for Num and it'll be there.
17:46:08 <dolio> Some folks will tell you not to use fromInteger, as it's intended to be a behind-the-scenes, implementation sort of method.
17:46:18 <Beelsebob> @hoogle Int -> Integer
17:46:18 <lambdabot> Prelude toEnum :: Enum a => Int -> a
17:46:18 <lambdabot> Data.Bits bit :: Bits a => Int -> a
17:46:18 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
17:46:27 <jokerGTA> oh ok.....cool.....thank you so much
17:46:28 <Beelsebob> ah bugger, hoogle doesn't find taht easily
17:46:29 <dibblego> how might one pronounce the ((->) t) monad?
17:46:39 <Draconx> Beelsebob, well, you have the arguments reversed.
17:46:40 <dolio> Whereas fromIntegral is for general use. And they should optimize to be the same.
17:46:46 <Beelsebob> dibblego: the "function from t" monad
17:47:15 <chessguy> 'evening ya'all
17:47:17 <dolio> Environment.
17:47:23 <Beelsebob> Draconx: it's still an instance of (Integral a, Num b) => a -> b
17:47:30 <dibblego> ta
17:47:39 <Draconx> @hoogle Integer -> Int
17:47:40 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
17:47:40 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
17:47:40 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
17:47:44 <jokerGTA> am i looking for these classes on wrong page
17:47:47 <jokerGTA> this is where i am now
17:47:50 <jokerGTA> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
17:47:59 <Beelsebob> jokerGTA: haskell.org/hoogle is a good start
17:48:12 <chessguy> easiest way to tell if every member of a (finite) list is the same value? (e.g. f [1,1,1,1] = True; f [1,1,1,2] = False)
17:48:19 <Nereid_> jokerGTA: most of the stuff you need is probably in the Prelude
17:48:23 <Beelsebob> though fromIntegral is rather a long way down its results
17:48:29 <Nereid_> chessguy: fold
17:48:30 <Nereid_> :)
17:48:58 <jokerGTA> yeah i founf it on hoogle..cool...
17:49:02 <jokerGTA> thanks so much gus
17:49:55 <blackdog> chessguy: all (==(head l)) l? although it's broken for empty
17:50:13 <Nereid_> better idea, hang on
17:50:31 <dolio> @type and . ap (zipWith (==)) (drop 1)
17:50:33 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:51:03 <Nereid_> > and . ap (zipWith (==)) (drop 1) $ [1,1,1]
17:51:05 <lambdabot>   True
17:51:06 <Nereid_> > and . ap (zipWith (==)) (drop 1) $ [1,1,2]
17:51:08 <lambdabot>   False
17:51:09 <Nereid_> > and . ap (zipWith (==)) (drop 1) $ []
17:51:11 <lambdabot>   True
17:51:12 <Nereid_> clever
17:51:28 <Nereid_> ah I see.
17:51:31 <dolio> I'm a point-free machine.
17:51:31 <GreatPatham> Given the default definition: m >> k           =  m >>= \_ -> k,  I was trying to understand if this really implies that m must be known before m >> k can be calculated. I'm new to Haskell, so bear with me here...
17:51:43 <GreatPatham> If I think of monads in a container-centric way, It seems that \_ -> k is is saying that it doesn't care about the *values* in the container, but >> may still (must still?) depend on the *shape* of the container.  And *that* is why sequencing is assured.
17:51:44 <Nereid_> @unpl and . ap (zipWith (==)) (drop 1)
17:51:44 <lambdabot> (\ c -> and (((zipWith (==)) >>= \ e -> (drop 1) >>= \ d -> return (e d)) c))
17:51:48 <Nereid_> oh dear
17:51:53 <GreatPatham> Am I on the right track?
17:52:21 <chessguy> allMatch [] = False; allMatch (x:xs) = all (==x) xs -- seems simple enough
17:52:22 <Nereid_> GreatPatham: I think so.
17:52:47 <shachaf> GreatPatham: Yes -- though keep in mind that there isn't always a "value in the container".
17:52:50 <Nereid_> Nothing >> _ = Nothing, for example
17:52:50 <dolio> GreatPatham: Sort of depends on the monad.
17:52:51 <shachaf> Or sometimes there's more than one.
17:53:00 <pikhq> GreatPatham: Except that that's not the "default" definition of m >> k.
17:53:08 <pikhq> That is *the* definition of m >> k.
17:53:12 <dolio> In the reader monad, m >> k = k.
17:53:19 <shachaf> pikhq: Actually, it is the default, isn't it?
17:53:21 <shachaf> @src Monad
17:53:22 <lambdabot> class  Monad m  where
17:53:22 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
17:53:22 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
17:53:22 <lambdabot>     return      :: a -> m a
17:53:22 <lambdabot>     fail        :: String -> m a
17:53:22 <dolio> > (undefined >> (+1)) 5
17:53:24 <Nereid_> pikhq: not true, (>>) is defined in the class
17:53:24 <lambdabot>   6
17:53:26 <GreatPatham> Yeah, I kind of convinced myself by looking at the List  and Maybe monads
17:53:33 <pikhq> Nereid_: Oh.
17:53:38 <pikhq> ... That seems quite silly.
17:53:42 <shachaf> GreatPatham: Looking at the State monad might be helpful.
17:53:47 <Nereid_> room for optimization perhaps
17:53:50 <shachaf> pikhq: As silly as having both (==) and (/=) in Eq.
17:53:51 <pikhq> I guess.
17:54:07 <Nereid_> or anything but compare in Ord. :)
17:54:11 <Nereid_> or (<=)
17:54:24 <pikhq> My point?
17:54:26 <pikhq> :P
17:54:31 <Nereid_> no idea
17:54:41 <shachaf> GreatPatham: "Monads as computations" might be a more helpful analogy, I think.
17:55:06 <dibblego> GreatPatham, http://code.google.com/p/monad-tutorial/ (work in progress)
17:55:10 <GreatPatham> I am still studying the State monad.  There it looks like the threading of the state is what ensures the order of computation
17:55:10 <Nereid_> yeah I guess thinking about State would be good.
17:55:43 <shachaf> GreatPatham: My advice for figuring out the State monad is implementing it yourself.
17:55:52 <shachaf> GreatPatham: Rather than trying to understand the existing definitions.
17:56:03 <Nereid_> >> ignores the value of the first one, but still keeps the change in state
17:56:12 <Nereid_> modify f >> modify g = modify (g . f)
17:56:14 <GreatPatham> dibblego: Thanks for the link
17:56:20 <kmc> start with implementing the Maybe monad, if you haven't done that one
17:56:36 <copumpkin> the Maybe a type!
17:56:54 <GreatPatham> I am quite comfortable with Maybe and List, and I am closing in on State
17:56:56 <kmc> @djinn Maybe a
17:56:57 <lambdabot> f = Nothing
17:57:06 <kmc> for all propositions P, P is maybe true!
17:57:07 * shachaf wishes again that IRC had a built-in Obby-like editor.
17:57:09 <kmc> remarkable
17:57:19 <Nereid_> lol
17:57:25 <copumpkin> Maybe is so many things other than Monad
17:57:29 <copumpkin> seems sad to box it in
17:57:37 <shachaf> @Djinn Maybe (Not a)
17:57:37 <lambdabot> f = Nothing
17:57:45 <Nereid_> :i Not
17:57:50 <Nereid_> asdf
17:57:51 <Nereid_> @src Not
17:57:51 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:57:54 <Nereid_> well what
17:58:00 <kmc> type Void; type Not a = a -> Void
17:58:01 <copumpkin> type Not a = a -> Void
17:58:02 <kmc> i think
17:58:15 <Nereid_> data Void?
17:58:20 <kmc> err yes
17:58:21 <kmc> sorry
17:58:21 <copumpkin> yeah, but you can't really write it
17:58:27 <Nereid_> ok
17:59:18 <Nereid_> not without whatever that extension is called anyway
17:59:25 <copumpkin> EmptyDataDecls
17:59:26 <Nereid_> Empt
17:59:27 <Nereid_> yeah
17:59:28 <Nereid_> :P
17:59:29 <copumpkin> but I meant you can't really write an empty type
17:59:43 <copumpkin> you can write a newtype with a single element in it
17:59:46 <Nereid_> you can if you don't count bottom
17:59:49 <Nereid_> :(
18:00:10 <copumpkin> yeah, but bottom will refuse to not be counted!
18:00:10 <kmc> and all this curry-howard business is unsound if you include bottom
18:00:16 <shachaf> _|_--
18:00:29 <Nereid_> death to bottom!
18:00:30 <Nereid_> :(
18:00:31 <GreatPatham> I wonder if there is any meaningful monad in which the default definition of >> does not guarantee sequencing of computation?
18:00:46 <shachaf> GreatPatham: What does "sequencing" mean?
18:01:08 <Nereid_> GreatPatham: Identity monad?
18:01:14 <shachaf> GreatPatham: By the way, the reason pikhq objected to the word "default" is that any other implementation has to be have identically. It's only there for optimization.
18:01:15 <Nereid_> oh, meaningful
18:01:31 <kmc> GreatPatham, there are many cases where the RHS of >> doesn't get evaluated ever
18:01:44 <Nereid_> kmc: but what about the LHS?
18:01:45 <GreatPatham> that, in the expression m >> k, the value of m must be computed before the full expression can be evaluated
18:01:49 <Nereid_> that's the question.
18:01:58 <shachaf> There's also Reader/(r ->) for "non-commutative" monads.
18:02:02 <shachaf> If that's what you're asking.
18:02:13 <Nereid_> hmm, Reader might do it
18:02:22 <kmc> GreatPatham, by "computed" what do you mean?
18:02:25 <Nereid_> ask >> k = k, no?
18:02:30 <kmc> evaluated to weak head normal form?
18:02:47 <shachaf> > do { x <- id; y <- (+1); return (x,y) } $ 5
18:02:49 <lambdabot>   (5,6)
18:02:51 <kmc> most monads will evaluate m to WHNF because they need to pattern-match out the monad type's constructor
18:03:11 <Nereid_> kmc: non-strict in the first argument?
18:03:32 <kmc> > error "foo" >> return () :: Maybe ()
18:03:32 <shachaf> GreatPatham: In that, things can be evaluated in any order.
18:03:34 <lambdabot>   * Exception: foo
18:03:35 <Nereid_> or strict, depending on the question
18:03:41 <GreatPatham> shachaf: I'm not sure I understood your remark about any other implementation of >>  ??
18:03:44 <Nereid_> undefined >> return () :: Reader ()
18:03:48 <Nereid_> > undefined >> return () :: Reader ()
18:03:50 <lambdabot>   `Control.Monad.Reader.Reader ()' is not applied to enough type arguments
18:03:50 <lambdabot>  E...
18:03:53 <Nereid_> err
18:03:53 <kmc> > return $ error "foo" >> return () :: Maybe ()
18:03:55 <lambdabot>   Couldn't match expected type `()' against inferred type `m ()'
18:03:57 <Nereid_> > undefined >> return () :: Reader a ()
18:03:59 <lambdabot>   No instance for (GHC.Show.Show (Control.Monad.Reader.Reader a ()))
18:03:59 <lambdabot>    arisi...
18:04:07 <Nereid_> err
18:04:14 <shachaf> GreatPatham: It's the "default" implementation, but it's also the "only" implementation.
18:04:23 <dino-> In Parsec, I'm having difficulty doing what would be the ? in regexp. I have strings like "A.  "  "B.  " ... but some dirty data is missing the period.  In regexp I may do this like so with the ? "[ABCD]\.?\s"
18:04:25 <shachaf> GreatPatham: If you ever override it, it's only an optimization.
18:04:30 <Nereid_> > runReader (undefined >> return () :: Reader a ())
18:04:32 <lambdabot>   Overlapping instances for GHC.Show.Show (r -> ())
18:04:32 <lambdabot>    arising from a use of ...
18:04:32 <kmc> GreatPatham, monads don't add any strictness beyond the normal haskell semantics of the (>>=) and return you see defined.
18:04:35 <kmc> because that's all they are
18:04:36 <Nereid_> doh what
18:04:41 <Nereid_> I'lls top
18:04:48 <dino-> Confused about how to do that with parsec
18:04:48 <kmc> > (return $ error "foo") >> return () :: Maybe ()
18:04:48 <shachaf> > (undefined >> return ()) 1
18:04:51 <lambdabot>   Just ()
18:04:51 <lambdabot>   ()
18:05:06 <shachaf> kmc: But that's return.
18:05:08 <Nereid_> > runReader (undefined >> return () :: Reader () ()) ()
18:05:09 <lambdabot>   ()
18:05:12 <Nereid_> there
18:05:14 <shachaf> > (undefinde >> return ()) :: Maybe ()
18:05:14 <kmc> so there, (>>) evaluated its left argument to WHNF (to match the Just ctor) but not to HNF (which would hit bottom)
18:05:16 <lambdabot>   Not in scope: `undefinde'
18:05:22 <shachaf> > (undefined >> return ()) :: Maybe ()
18:05:24 <lambdabot>   * Exception: Prelude.undefined
18:05:33 <kmc> shachaf, yes
18:05:36 <Nereid_> GreatPatham: so Reader is your nontrivial monad like that
18:05:39 <shachaf> Nereid_: Why use Reader instead of (r ->)?
18:05:44 <Nereid_> whatever :P
18:05:53 <GreatPatham> Nereid_:  I think you are right---I think that in the Identity monad m need not be known before m >> k can be computed
18:06:00 <Nereid_> > (undefined >> return () :: () -> ()) ()
18:06:02 <lambdabot>   ()
18:06:32 <Nereid_> GreatPatham: likewise for Reader a and (->) a
18:06:34 <kmc> conceptually, Maybe only needs to run the computation far enough to see whether it succeeded or failed
18:06:37 <dolio> > runIdentity (undefined >> return 5)
18:06:38 <lambdabot>   5
18:06:41 <kmc> it won't go further, if there's more to be done
18:06:44 <GreatPatham> Because the Identity monad is (I believe) isomorphic to ordinary function composition, and in this context >> is throwing away the argument
18:06:49 <Nereid_> > undefined >> return ()
18:06:51 <lambdabot>   No instance for (GHC.Show.Show (m ()))
18:06:51 <lambdabot>    arising from a use of `M350509199...
18:06:58 <ksf> I've got a monoid spanning two types in its domain, resulting in a value in one of those types.
18:07:03 <centrinia> :t runIdentity
18:07:04 <pikhq> > (undefined >>= \_->return () :: () -> ()) ()
18:07:05 <lambdabot> forall a. Identity a -> a
18:07:06 <lambdabot>   ()
18:07:09 <ksf> do we have a typeclass for that or do I need to roll my own?
18:07:23 <ManateeLazyCat> I got name of data Foo with "Foo", how to use Template Haskell generate expression [Foo] ?
18:07:27 <Nereid_> ksf: how do you mean?
18:07:39 <copumpkin> ksf: the monoid instance for (a,b)?
18:07:54 <shachaf> GreatPatham: Composition?
18:08:32 <kmc> application, i think
18:08:37 <shachaf> GreatPatham: Ah, you mean (>>=) in Identity? Wouldn't it be application?
18:08:43 <Nereid_> yeah
18:08:45 <ksf> copumpkin, rather Either.
18:08:48 <shachaf> GreatPatham: By the way, have a look at join/fmap/return sometime.
18:09:13 <ksf> I can't represent aggregates in one of these types.
18:09:26 <ksf> (in fact, one type is the aggregation type for the other)
18:09:58 <GreatPatham> Really interesting info!
18:10:31 <ksf> So I need a mappend :: a -> b -> a , mappend :: b -> a -> a, and mappend :: a -> a -> a
18:10:52 <Nereid_> ksf: what about b -> b -> something?
18:11:24 <ksf> I thought about that, but I'd loose the ability to say Foo <+> Bar <+> Baz
18:11:27 <centrinia> bothzero :: forall a b. Monoid a, Monoid b => (a,b); bothzero = (mzero,mzero)
18:11:59 <GreatPatham> By the way, I was thinking of composition in the monoid, and its connection to application as the monad operator---But I may be getting out of my depth here.  I'm still trying to come up to speed.
18:12:07 <centrinia> I can't think of anything analogous to bothzero for Either. :(
18:12:42 <shachaf> GreatPatham: In the monoid?
18:13:05 <ksf> well I can convert every "b" to an "a" and every "a" to a list of "b"s
18:13:32 <kmc> GreatPatham, what do you mean by composition in the monoid
18:14:45 <ksf> well I _could_ hack something up with TH that gives me data Foo = Foo|Bar|Baz | Set [Foo], but a) that's uncreative, b) it's not reusable, at all.
18:15:30 <ksf> well, ok, other question:
18:15:38 <ksf> what's my monoid called, properly?
18:15:41 <GreatPatham> f: a -> Mb   g: b -> Mc  then f >=> g is the Kleisli composition operator, which is basically ordinary composition in the Identity monad---I *think*
18:16:02 <Cale> GreatPatham: yes
18:16:04 <centrinia> How would you implement: mappend :: Monoid a, Monoid b => Either a b -> Either a b -> Either a b ?
18:16:17 <GreatPatham> Whew! ;^)
18:16:26 <dmwit> centrinia: Sounds suspicious.
18:16:33 <Cale> GreatPatham: Saying that <=< gives the composition of a category with return giving the identity is another way to state the monad axioms.
18:16:37 <ksf> ...either prefer the left or the right value.
18:16:44 <centrinia> dmwit, it is very suspicious.
18:17:01 <ksf> "left" meaning "first argument", not "Left"
18:17:11 <ksf> ...though you could do that, too.
18:17:28 <GreatPatham> Yes, and one that I found more natural, for some reason.
18:17:31 <Nereid_> well if you want a -> b -> a and b -> a -> a
18:17:35 <Cale> GreatPatham: Of course, a monoid is just a category with only one object -- that is, a category where any two arrows will compose with each other.
18:17:36 <Nereid_> then you'd want to prefer the Left value
18:17:40 <dmwit> centrinia: There are enough (likely valid) implementations that I question even creating the instance in the first place...
18:17:53 <copumpkin> centrinia: if you get two Lefts or two Rights, you spit out the same side with mappend, and otherwise spit out a mempty :P
18:18:34 <Nereid_> but what's mempty?
18:18:34 <dmwit> mempty itself is either Left or Right biased
18:18:37 <Cale> GreatPatham: The usual axioms in mathematics involve join and return (along with fmap), and can be seen as a generalisation (and then respecialisation) of the monoid axioms
18:18:56 <copumpkin> yeah, you'd just pick Left mempty or something :P
18:19:24 <centrinia> mempty is the identity element
18:19:34 <copumpkin> hey, hey, laws are open to interpretation
18:19:54 <copumpkin> I hereby call it a monoidish
18:20:09 <kmc> fauxnoid
18:20:31 <Cale> Let's rename categories to monoidoids.
18:20:33 <Nereid_> lol
18:20:36 <centrinia> copumpkin: mappend = const . const $ mempty
18:20:46 <dmwit> copumpkin: I worry about associativity with your definition.
18:20:51 <Nereid_> I think it would make sense to have mappend prefer Left, and mempty = Left mempty
18:20:54 <copumpkin> call it a "dioid that isn't that idempotent semiring dioid thingy"
18:21:24 <GreatPatham> Well, I think I got my question answered, and a lot of additional food for thought---Thanks to all!
18:21:42 <dmwit> copumpkin: consider (Left + Left) + Right vs. Left + (Left + Right), where mempty is Left-biased...
18:21:43 <Cale> Or we could call them diodes, "just to piss off the electrical engineers"
18:21:49 <Nereid_> Z2-graded monoid isn't quite it
18:21:56 <copumpkin> dmwit: I wasn't really serious about that instance :P
18:22:09 <dmwit> ok =)
18:22:28 <copumpkin> :)
18:22:47 <cjb> 'ello.  We're thinking about working on code together at the next Boston Haskell meeting, was wondering if anyone has suggestions for code they'd like to see or thinks would be didactic to write.
18:23:27 <dmwit> Heya, cjb!  Long time no see!
18:24:07 <cjb> howdy howdy.
18:24:18 <dmwit> There's always the haskell-proposals subreddit.
18:24:34 <Nereid_> ok, now that a different set of people are here...
18:24:43 <Nereid_> I'm getting this error when building FileManip: http://hackage.haskell.org/packages/archive/FileManip/0.3/logs/failure/ghc-6.10
18:24:45 <cjb> dmwit: huh, where's that?
18:25:08 <Cale> Nereid_: Ah, new vs. old exception library.
18:25:20 <Nereid_> how to fix it?
18:25:31 <dmwit> one sec
18:25:56 <Cale> Nereid_: There are two ways: one is to update it to use the new exception library, the other is to import Control.OldException (iirc)
18:26:04 <dmwit> http://www.reddit.com/r/haskell_proposals/
18:26:17 <cjb> dmwit: cool!  hadn't known about that.
18:26:17 <Nereid_> in either case I'd have to make manual changes to FileManip, then?
18:26:21 <Cale> yeah
18:26:24 <Nereid_> oh dear :(
18:26:28 <Nereid_> well, let's try that
18:32:16 <Nereid_> Cale: builds now, albeit with a bunch of warnings
18:33:50 <Gracenotes> all in all, you're just another brick in the -Wall
18:35:09 <monochrom> @remember Gracenotes all in all, you're just another brick in the -Wall
18:35:09 <lambdabot> Good to know.
18:35:25 <Nereid_> sed -i 's/Control\.Exception/Control.OldException/' *.hs
18:35:26 <Nereid_> :-)
18:37:04 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9173#a9173
18:37:10 <ksf> how do I get sempty to work?
18:38:03 <dolio> c needs to determine a and b.
18:38:36 <dolio> Or you add dummy parameters.
18:38:59 <ksf> yep, but then I need fundep conflics.
18:39:36 <ksf> er get fundep conflicts
18:40:29 <ksf> ...I could introduce an explicit empty type.
18:41:19 <dolio> If all your things are collection-like, you could make a class like that.
18:41:59 <ksf> ...well, the point of the class is to pair up a collection with a type, and treat them the same.
18:42:06 <dolio> class Collection c e | c -> e where empty :: c ; cons :: e -> c -> c ; snoc :: c -> e -> c ; combine :: c -> c -> c
18:43:02 <dolio> I suppose that's sequence-like, strictly, due to the cons and snoc.
18:44:10 <dolio> Since not all collections have two places to add elements.
18:44:52 <ksf> > Foo `sappend` Bar `sappend` Empty `sappend` Baz `sappend` Empty
18:44:52 <ksf> [Foo,Bar,Baz]
18:44:53 <ksf> works.
18:44:54 <lambdabot>   Not in scope: data constructor `Foo'Not in scope: data constructor `Bar'Not...
18:45:14 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9173#a9174
18:45:15 <chessguy> @hoogle sort
18:45:16 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
18:45:16 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
18:45:16 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
18:45:45 <ksf> oh, Empty Empty [Flag] is missing.
18:45:46 <roconnor> @free sortBy
18:45:48 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
18:46:13 <chessguy> @hoogle sortBy
18:46:14 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
18:46:14 <monochrom> c->e is right and orthodox.
18:47:00 <chessguy> that ordering stuff seems like such crap to me
18:47:10 <blackdog> is there a more succinct way of sorting by the second element of a tuple than 'sortBy ((_,a) (_,b) -> compare a b) list' ?
18:47:52 <ksf> :t second compare
18:47:54 <lambdabot> forall b d. (Ord b) => (d, b) -> (d, b -> Ordering)
18:48:04 <roconnor> @type sortBy (comparing `on` snd)
18:48:06 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
18:48:06 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
18:48:06 <lambdabot>     In the first argument of `on', namely `comparing'
18:48:13 <jungehexe> s_holdM:: Str a -> Str Bool ->Str Bool ->Str a
18:48:13 <jungehexe> s_holdM input record new = ls
18:48:13 <jungehexe>     where zs = merge input record ls
18:48:13 <jungehexe>           ls = merge ks new zs
18:48:16 <jungehexe>           ks = when  input record
18:48:22 <kmc> blackdog, i sometimes use sortKey f = sortBy (\a b -> compare (f a) (f b)), but i don't know if there's something like it in the std lib
18:48:23 <roconnor> @type sortBy (comparing  snd)
18:48:25 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
18:48:33 <kmc> ah, comparing, yes
18:48:36 <kmc> :t comparing
18:48:37 <roconnor> blackdog: sortBy (comparing  snd)
18:48:37 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
18:49:36 <jungehexe> i have a prob with keeping parts of stream in reactive system, could some one help me
18:49:49 <ksf> monochrom, there's gonna be c -> e, but not for the collapsing class.
18:50:06 <blackdog> roconnor: ah, beautiful
18:50:08 <blackdog> thanks
18:50:37 <blackdog> just about small enough to fit on a slide
18:50:57 <blackdog> (yes, having had a go at Don for tiny unrealistic examples, i'm going to do exactly the same thing. oh well.)
18:51:01 <ksf> jungehexe, we could, maybe, if you told us about your problem.
18:51:55 <jungehexe> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9175#a9175
18:52:18 <jungehexe> i have a prob withthe function holdM
18:53:05 <jungehexe> it has to keep and repeat parts of stream it gets but it works fine only on first iteration
18:53:22 <BMeph> jungehexe: Do you know when to foldM? ;p -- Sorry, I couldn't resist.
18:53:36 <jungehexe> the whole thing is meant to be used in reactive frame
18:53:55 <jungehexe> when to foldM?
18:54:22 <Nereid_> it's a joke :P
18:54:29 <jungehexe> sorry i am just a student and some time to ignorant
18:54:38 <jungehexe> too ignorant
18:54:40 <Nereid_> signified by the ";p"
18:55:19 <jungehexe>  :)
18:56:57 <jungehexe> i just get lost with the idea how should i "renew the saved part of stream"
18:58:39 <blackdog> hey, anyone here use the Beamer slide software? Trying to typeset Haskell code in it...
18:59:50 <BMeph> jungehexe: Where are any parts of the stream kept? I see many places where parts are discarded, but not any repeated places. :)
19:00:09 <jungehexe> ww [03:52]
19:00:09 <jungehexe>   [03:52]
19:00:09 <jungehexe>   [03:52]
19:00:09 <jungehexe>  
19:00:32 <jungehexe> BMeph: when i test it i get
19:00:53 <jungehexe>  
19:00:53 <jungehexe> *Lusterel> s_holdM [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16][True,True,True,False,False,False,False,False,True,True,False,False,False,False,False,False,True,True,True,False,False,False,False][False,False,False,False,False,False,False,False,True,False,False,False,False,False,False,False,True,False,False,False,False,False,False]
19:00:53 <jungehexe> [1,2,3,1,2,3,1,2,1,4,5,3,1,2,1,4,2,5,6,7,8,3,1*** Exception: /home/kira/DA/Work/pong_game/Lusterel.hs:(182,0)-(183,48): Non-exhaustive patterns in function merge
19:01:45 <jungehexe> so the first part works, the first 3 selected values are repeated as long as control streams are false
19:02:34 <jungehexe> but when the "replacement" has to occure it merges with the previous value
19:10:57 <jungehexe> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9175#a9176
19:11:29 <jokerGTA> does anyone have few for some guidance
19:11:42 <kmc> jokerGTA, sure, just ask
19:11:49 <BMeph> jungehexe: Ah, so 'ks' copies the repeats, and 'ls' re-inserts 'ks' into the stream when there's a 'break' in the stream from the original.
19:11:52 <jokerGTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9177#a9177
19:11:54 <jungehexe> conal: i was said you are an expert in reactive freamwork
19:12:38 <jokerGTA> first function receives list and some integer (lets say number 2)
19:12:42 <jungehexe> BMeph: it reinserts when controlling stream is false
19:12:56 <kmc> jokerGTA, why are you using guards instead of writing patterns to match empty and non-empty lists separately?
19:13:12 <jokerGTA> because at this stage i dont know any better:)
19:13:45 <Makoryu> > zipWith id [words, lines, (:[])] "He will ride forever\n'Neath the streets of Boston"
19:13:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:13:48 <jokerGTA> what i am trying to do is this.....
19:13:53 <monochrom> "th" is absent.
19:14:02 <Makoryu> > zipWith id [words, lines, map (:[])] "He will ride forever\n'Neath the streets of Boston"
19:14:03 <jokerGTA> is list is [2,5,6] and integer passed is 2
19:14:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:14:08 <BMeph> jungehexe: What about changing 'when input' to 'when ls'? :)
19:14:10 <jokerGTA> i want o calculate this
19:14:20 <Makoryu> :t [words, lines, map (:[])]
19:14:22 <lambdabot> [String -> [String]]
19:14:26 <conal> jungehexe: do you mean reactive programming in general?  or FRP?  or the "reactive" library on hackage?
19:14:31 <Makoryu> Oh duh
19:14:37 <jokerGTA> lets call that integer passed r
19:14:44 <jokerGTA> so i want to calculate this
19:15:00 <Makoryu> > zipWith id [words, lines, map (:[])] $ repeat "He will ride forever\n'Neath the streets of Boston"
19:15:01 <lambdabot>   [["He","will","ride","forever","'Neath","the","streets","of","Boston"],["He...
19:15:08 <jokerGTA> 2*2^0+5*2^1+6*2^2
19:15:14 <Makoryu> > map length . zipWith id [words, lines, map (:[])] $ repeat "He will ride forever\n'Neath the streets of Boston"
19:15:15 <lambdabot>   [9,2,49]
19:15:19 <jokerGTA> because 0 1 2 powers are indices in the list
19:15:41 <jungehexe> BMeph: it hangs on
19:15:47 <Makoryu> @let explode = map (:[])
19:15:49 <lambdabot>  Defined.
19:15:53 <jokerGTA> 2*r^0+5*r^1+6*r^2
19:16:12 <badsheepy> could anyone possibly attempt to explain to me why mycode stack overflows:
19:16:15 <BMeph> jungehexe: The only problems I see are that you never say what to do if any of your 'streams' end. :)
19:16:18 <badsheepy> gah, lost the paste
19:16:18 <badsheepy> hehe
19:16:21 <monochrom> > zipWith (\a e -> a*2^e) [2,5,6] [0..]
19:16:23 <lambdabot>   [2,10,24]
19:16:29 <badsheepy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9178#a9178
19:16:30 <jokerGTA> in my function when i use map i dont know how to refer to each number in the list
19:16:34 <jokerGTA> otherwise          = map (myFunction xs th r) xs
19:16:35 <jungehexe> BMeth: streams are infinite
19:16:41 <jokerGTA> you see where i used th
19:16:51 <monochrom> Then sum up. All in all, sum (zipWith (\a e -> a*2^e) [2,5,6] [0..])
19:16:59 <monochrom> > sum (zipWith (\a e -> a*2^e) [2,5,6] [0..])
19:17:01 <lambdabot>   36
19:17:05 <kmc> jokerGTA, look at monochrom's code
19:17:08 <badsheepy> its a euler project problem, so dont look if you dont want to see (failed) solutions :o
19:17:13 <jokerGTA> ok let me see/.....
19:17:20 <monochrom> There is a faster way.
19:17:23 <jungehexe> i think i mean reactive in general
19:17:25 <kmc> zipWith is like map, but takes two lists, and pairs them up before feeding it to your function
19:17:39 <jungehexe> because i'm using lusterel lib of my prof
19:17:45 <ksf> jungehexe, he is, but he won't ever admit it.
19:18:02 <monochrom> A faster way is based on Horner's rule.
19:18:19 <jokerGTA> i dont have 2 lists
19:18:21 <jungehexe> ksf: how could one than attrract his attention/
19:18:25 <jokerGTA> i only take one list as parametar
19:18:26 <kmc> you do.  one is the list of indices
19:18:29 <kmc> [0..]
19:18:36 <monochrom> [0..] is provided by code.
19:18:47 <kmc> <jokerGTA> 2*r^0+5*r^1+6*r^2
19:18:49 <kmc> what i see there is
19:18:56 <kmc> (2,0), (5,1), (6,2)
19:19:07 <BMeph> jungehexe: Streams are infinite; your examples aren't. :)
19:19:08 <jokerGTA> yeah thats what i want to have
19:19:09 <kmc> hence why we're zipping two lists
19:19:11 <ray> what i see there is "clowns to the left of me, jokers to the right"
19:19:13 <jokerGTA> but i dont have that actual list
19:19:23 <kmc> > zip [2,5,1] [0..]
19:19:25 <lambdabot>   [(2,0),(5,1),(1,2)]
19:19:35 <kmc> jokerGTA, right, so we have to make it
19:19:43 <kmc> so in particular we could do
19:19:52 <jokerGTA> how do we make it..like this [0..]?
19:20:08 <kmc> > sum (map (\(a,e) -> a*2^e) (zip [2,5,6] [0..]))
19:20:10 <lambdabot>   36
19:20:13 <jungehexe> BMeph, that's why they are examples
19:20:16 <monochrom> > sum (zipWith (\x y -> x*r^y) [a,b,c] [0..]) :: Expr
19:20:17 <lambdabot>   0 + a * 1 + b * r + c * (r * r)
19:20:18 <kmc> do you see how that code works
19:20:57 <jokerGTA> no not now...i have to study it
19:21:05 <jokerGTA> whats (a,e)?
19:21:07 <kmc> the idea here is, instead of indexing your input awkwardly, first transform it to what you wish it were
19:21:09 <monochrom> Oh, I don't need Horner's rule for the faster way.
19:21:09 <kmc> jokerGTA, that's a tuple
19:21:11 <kmc> > (1,2)
19:21:13 <lambdabot>   (1,2)
19:21:13 <ksf> conal, did you stumble across http://www.cs.kent.ac.uk/projects/ofa/chp/ , yet? parts of it, especially http://hackage.haskell.org/packages/archive/chp/1.3.0/doc/html/Control-Concurrent-CHP-Common.html , remind me of parts of reactive, thugh it's a process calculus. which then made me wonder how frp deals with deadlocks etc.
19:21:16 <kmc> two values paired together
19:21:23 <kmc> ("pair" means "two-element tuple")
19:21:35 <kmc> jokerGTA, it may help to work inside out
19:21:39 <jokerGTA> so we make list of indices right?
19:21:41 <kmc> do you understand [0..]
19:21:47 <jokerGTA> yes thats out indices
19:21:50 <jokerGTA> that we make
19:21:51 <monochrom> I just need a faster way to produce [1, r, r^2, r^3, ...]
19:21:52 <kmc> > [0..]
19:21:54 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:21:55 <jokerGTA> function didnt receive indices
19:21:59 <kmc> yeah
19:22:01 <jokerGTA> ok
19:22:02 <kmc> so what about
19:22:03 <jokerGTA> i get that
19:22:10 <kmc> > zip [2,5,6] [0..]
19:22:12 <lambdabot>   [(2,0),(5,1),(6,2)]
19:22:17 <jokerGTA> ok
19:22:20 <jokerGTA> i see that too
19:22:24 <kmc> coo
19:22:39 <kmc> what about the function: \(a,e) -> a*2^e)
19:22:47 <jokerGTA> no i am lost on that one
19:22:53 <kmc> do you know the lambda syntax
19:22:58 <jokerGTA> no
19:23:07 <Makoryu> I wonder what kind of type hackery would be required to get a proper vararg map/zipWith function.
19:23:11 <kmc> so, "\x -> e" is a function that takes argument x and returns e
19:23:12 <jokerGTA> i mean i see what it does
19:23:18 <copumpkin> Makoryu: proper how?
19:23:19 <kmc> this function doesn't have a name, because it doesn't need to
19:23:20 <BMeph> monoc: 'iterate (*r) 1'? :)
19:23:22 <jokerGTA> it raised first elemnt of the tuple
19:23:28 <kmc> in fact "f x = y" is shorthand for "f = \x -> y"
19:23:41 <copumpkin> Makoryu: my type-sized "matrix transpose" might meet that requirement :P
19:24:26 <BMeph> @go Indira dependent
19:24:26 <lambdabot> Maybe you meant: google googleit do
19:24:30 <Makoryu> copumpkin: I dread seeing its definition :p
19:24:34 <jokerGTA> yeah i kind of see what it is doing  kmc
19:24:35 <copumpkin> Makoryu: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890#a8890
19:24:43 <BMeph> @google Indira dependent
19:24:45 <lambdabot> http://www.thehindu.com/fline/fl1809/18090740.htm
19:24:45 <lambdabot> Title: The Indira enigma
19:24:57 * BMeph sighs
19:25:03 <kmc> jokerGTA, it's as if you'd written "f (a,e) = a * 2^e", then used f in place of that expression
19:25:10 <BMeph> @help googleit
19:25:10 <lambdabot> letmegooglethatforyou.
19:25:14 <kmc> but there's no point naming a function you're going to use in only one place
19:25:16 <copumpkin> conal: by the way, that paste includes an instance of the various vector-space classes for statically-sized vectors using she
19:25:21 <kmc> so we write it in-line, using the lambda syntax
19:25:41 * Makoryu looks at copumpkin's link and goes mad from the revelation
19:25:44 <kmc> ('\' looks a small bit like the greek letter lambda)
19:25:48 <monochrom> jokerGTA, kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9177#a9179  if desired
19:26:04 <kyagrd> Well unary integers are jolly hard to read (not for humans). It woudl be nice if there were syntactic sugar
19:26:23 <BMeph> @google Indrika dependent
19:26:25 <lambdabot> http://citeseer.ist.psu.edu/708957.html
19:26:40 <kmc> jokerGTA, it's important to write patterns like monochrom pasted
19:26:46 <kmc> a special case for [] and a general case
19:26:52 <monochrom> "length blah == 0" is slow.
19:26:57 <jokerGTA> where can i get tutorial on patterns
19:27:22 <monochrom> All tutorials do patterns early on.
19:27:29 <copumpkin> Makoryu: it's actually pretty easy using she
19:27:39 <copumpkin> Makoryu: but you need to be a little aware of the machinery going on behind the scenes
19:27:50 <Makoryu> copumpkin: Yeah I knew you were working on a she-based prelude :p
19:27:56 <monochrom> > iterate (r *) 1
19:27:58 <lambdabot>   [1,r * 1,r * (r * 1),r * (r * (r * 1)),r * (r * (r * (r * 1))),r * (r * (r ...
19:28:02 <monochrom> Neat.
19:28:09 <Cale> jokerGTA: http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html gives an overview of a good part of the basic syntax
19:28:24 <Cale> (for the whole language, not just patterns)
19:28:24 <ksf> ugh I'm enabling UndecidableInstances, yet again.
19:28:25 <copumpkin> Makoryu: yeah, I'm writing an epic algebra library now to give myself a strong set of typeclasses to go preludey on
19:28:27 <jokerGTA> pattern matching..is that how that topic os called is i search on google
19:28:32 <copumpkin> ksf: it's not that bad! :D
19:28:43 <kmc> jokerGTA, it should be covered by any haskell tutorial
19:28:59 <kmc> e.g. http://www.haskell.org/tutorial/patterns.html
19:29:10 <jmcarthur> yay undecidable instances
19:29:23 <jokerGTA> ok thanks kmc..greatly appreciated
19:29:36 <monochrom> I have also pasted a faster way.
19:29:37 <kmc> the patterns you choose for a function will depend on the task.  what's important is that, when you have conditional behavior, you try to make it part of patterns rather than using a guard, if/else, or some other construct
19:29:41 * heatsink still reads 'epic' as a superlative of 'awesome'
19:29:48 <kmc> this has various advantages which i can explain if you like
19:29:51 <copumpkin> heatsink: how about monic?
19:29:52 <BMeph> Makoryu: My last link discusses your topic (the whole map/zipWith thing). :)
19:29:56 <jokerGTA> yes please
19:30:11 <ksf> heatsink, what about "epic fail"?
19:30:12 <heatsink> monic monday?
19:30:14 <kmc> so for one, speed, as monochrom mentioned: length will walk through the whole list, then return an int which compares to 0
19:30:19 <ksf> ...it works with "epic win", though.
19:30:24 <kmc> whereas, the pattern [] will fail to match as soon as it sees the list has an element
19:30:36 <heatsink> lolcategory theory
19:30:39 <kmc> and the pattern (x:xs) will only look at one element before suceeding
19:30:41 <Makoryu> BMeph: It's disappeared from my scrollback x_x
19:30:54 <kmc> that pattern matches any list of at least one element.  'x' gets bound to the first element in the list, and 'xs' to the rest
19:30:59 * heatsink doesn't know the terminology all that well
19:31:05 <ksf> ...(x:xs) doesn't look at an element before succeeding.
19:31:05 * BMeph reads 'epic' as the dual of 'monic,' even when it's meant in the slang sense.
19:31:10 <ksf> it just looks at the constructor.
19:31:14 <kmc> ksf, fine ;P
19:31:16 <copumpkin> > genericLength [1..] > (0 :: Natural)
19:31:18 <lambdabot>   True
19:31:36 <copumpkin> I doubt that's much slower than not . null
19:31:42 <kmc> another important reason is to avoid the use of functions like "head" and "tail" than can fail when passed invalid inputs, like an empty list in this case
19:31:51 <kmc> > head []
19:31:53 <lambdabot>   * Exception: Prelude.head: empty list
19:31:57 <BMeph> @google Indrika dependent
19:31:58 <lambdabot> http://citeseer.ist.psu.edu/708957.html
19:32:01 <BMeph> Makoryu: ^^
19:32:03 <copumpkin> head :: Vec {S n} x -> x
19:32:09 <copumpkin> much safer :D
19:32:12 <badsheepy> excuse me for asking again, but in case it was lost in the scroll.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9178#a9178
19:32:17 <jmcarthur> i think i suffer from a problem. whenever i have a project to work on, i decide that none of the existing abstractions i could work with are good enough and i have to devise better ones before i can actually start the intended project
19:32:22 <kmc> if you use a guard to check for non-emptiness, then use head, the compiler has no way to ensure you did the check right
19:32:25 <badsheepy> is there anyone who could explain to me why that stack overflows?
19:32:30 <heatsink> copumpkin, dependent type, what language is that?
19:32:37 <copumpkin> heatsink: haskell
19:32:37 <kmc> whereas when you pattern-match a non-empty list like (x:xs), it's correct by construction
19:32:41 <kmc> looks like she :)
19:32:44 <jmcarthur> sheskell
19:32:49 <copumpkin> fine, fine
19:32:56 <jokerGTA> ok...thanks kmc..i have to read about this
19:33:02 <jokerGTA> appreciate it
19:33:03 <kmc> jokerGTA, enjoy :)
19:33:10 <jokerGTA> lol..thanks:)
19:33:11 * heatsink reads the logs for context
19:33:24 <jmcarthur> @where she
19:33:24 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
19:33:29 <jmcarthur> heatsink: ^^
19:33:38 <heatsink> thx
19:34:01 <copumpkin> heatsink: you can see an example of it in the paste I posted earlier
19:34:20 <copumpkin> which is just an expanded version of an example that conor included in the distribution
19:35:16 <copumpkin> I actually got the induction function in there working after tweeting a question to conor
19:35:26 <copumpkin> it's a really easy fix
19:36:01 <BMeph> badsheepy: Your code makes my eyes bleed and my heart weep. No offense, though, I'm just saying... ;p
19:36:18 <badsheepy> hehe
19:36:37 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890#a9181 there, fixed induction
19:37:16 <badsheepy> dont get me wrong, i know itshouldnt be like that :p
19:37:22 <badsheepy> im just curious as to why it overflows :)
19:38:16 <badsheepy> although.. what would you change :D
19:38:47 <badsheepy> my entire haskell knowledge at this point is doing euler project things, cause i got bored reading the books by about page 3 :o
19:38:50 <TheColonial> kmc, can you show me which you think is the better of these two solutions to joker's problem? I'm not cluey enough to know which would be considered better.
19:38:54 <heatsink> badsheepy, if you make 'drop' evaluate each list element as it goes, then it doesn't overflow.
19:39:03 <kmc> TheColonial, i can render my $0.02
19:39:08 <TheColonial> calculate xs r = zipWith (*) xs $ map (r^) [0..]
19:39:09 <TheColonial> calculate xs r = zipWith (\x y -> x*r^y) xs [0..]
19:39:11 <heatsink> So 'iterate next' is probably building nested, unevaluated thunks, then recursing down 999999 times to evaluate the element from the head of the list so it can evaluate later elements.
19:39:22 <TheColonial> I'm more interested in the perf implications (if any)
19:39:34 <hackagebot> semiring 0.1 - Semirings, ring-like structures used for dynamic programming applications (SashaRush)
19:39:35 <badsheepy> oh i see!
19:39:37 <badsheepy> thankyou :)
19:39:52 <copumpkin> @hackage semiring
19:39:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/semiring
19:40:00 <kmc> TheColonial, I'm not too sure about performance... ghc has optimizations to combine maps and folds, and i wouldn't be surprised to see zips also
19:40:22 <kmc> > let r = 2 in map (r^) [0..]
19:40:23 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
19:40:53 <kmc> > let r = 2 in iterate (*r) 1
19:40:54 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
19:41:02 <kmc> i'd guess the latter is faster
19:41:22 <TheColonial> yeah that'd be my guess too.. but it'd be just a guess :)
19:41:34 <TheColonial> purely because it "seems" to do less :D
19:41:44 <kmc> i meant of the subexpressions i pasted
19:42:02 <kmc> i think the latter of yours is faster on a naive implementation
19:42:18 <copumpkin> how about
19:42:25 <BMeph> TheColonial: I'd use the first one you pasted, but with kmc's iterate instead of the map. :)
19:42:35 <copumpkin> > fix $ scanl (+) 1
19:42:37 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
19:42:38 * TheColonial heads to see what iterate does
19:42:39 <copumpkin> :P
19:42:43 <kmc> :t iterate
19:42:44 <lambdabot> forall a. (a -> a) -> a -> [a]
19:42:50 <TheColonial> ah ha... i see.
19:42:54 <kmc> @src iterate
19:42:54 <lambdabot> iterate f x =  x : iterate f (f x)
19:43:03 <BMeph> > fix $ scanl (+) 3
19:43:04 <TheColonial> :t fix
19:43:06 <lambdabot> forall a. (a -> a) -> a
19:43:06 <lambdabot>   [3,6,12,24,48,96,192,384,768,1536,3072,6144,12288,24576,49152,98304,196608,...
19:43:08 <kmc> > iterate f x
19:43:10 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
19:43:19 <copumpkin> > fix $ scanl (+) x
19:43:21 <lambdabot>   [x,x + x,x + x + (x + x),x + x + (x + x) + (x + x + (x + x)),x + x + (x + x...
19:43:27 <TheColonial> man i wish i knew more of this stuff :P
19:43:44 <heatsink> :t x
19:43:45 <lambdabot> Expr
19:43:56 <TheColonial> copumpkin, so that works for 2, but what about other numbers?
19:44:03 * TheColonial is an idiot
19:44:07 <TheColonial> and should read more of the text ;)
19:44:43 <copumpkin> > fix $ scanl ((+) <=< (+)) 1
19:44:47 <lambdabot>   [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14...
19:44:47 * copumpkin whistles
19:45:00 <kmc> :t (+) <=< (+)
19:45:02 <lambdabot> forall b. (Num b) => b -> b -> b
19:45:06 * copumpkin whistles harder
19:45:17 <kmc> > let f = (+) <=< (+) in f 3 2
19:45:17 <TheColonial> so why would iterate be better than map?
19:45:18 <lambdabot>   7
19:45:27 <kmc> TheColonial, your exponent "starts over" from 1 every time
19:45:43 <kmc> iterate just builds from the previous expression
19:45:44 <copumpkin> TheColonial: the iterate can build off the shoulders of giants
19:45:47 <BMeph> TheColonial: Not the iterate/map, but the (*) vs. (^). :)
19:46:03 <TheColonial> ahhhh i see
19:46:09 <TheColonial> the penny drops.
19:46:23 <TheColonial> took a while. sorry about that.
19:46:30 <BMeph> TheColonial: Plus, the other points kmc and copumpkin mentioned. :)
19:46:36 <johnfn> alright, haskell baffles me. why does round ( sqrt ( 5)) work, but let num =2.5, then round (sqrt ( num)) fail?
19:46:38 <copumpkin>  no problem
19:46:48 <kmc> > round $ sqrt 5
19:46:49 <lambdabot>   2
19:46:55 <kmc> > round $ sqrt 2.5
19:46:57 <lambdabot>   2
19:47:00 <kmc> > sqrt 2.5
19:47:01 <lambdabot>   1.5811388300841898
19:47:05 <copumpkin> > round . sqrt $ 5
19:47:07 <lambdabot>   2
19:47:12 <copumpkin> > round . sqrt $ 2.5
19:47:14 <lambdabot>   2
19:47:16 <kmc> johnfn, how does it fail
19:47:24 <BMeph> johnfn: Obviously, you're Hiding something... ;)
19:47:24 <kmc> the square root of 2.5 rounds to 2
19:47:30 <copumpkin> johnfn: remember that we don't know your definitions of work ad fail :)
19:47:39 <johnfn> i just mean it throws out a few errors
19:47:41 <TheColonial> > round( sqrt( 5))
19:47:43 <lambdabot>   2
19:47:50 <BMeph> kmc: Rounds *UP. ;)
19:47:54 <copumpkin> johnfn: we also don't know what you mean by "a few errors" :P
19:47:58 <johnfn> haha
19:48:01 <johnfn> fair enough
19:48:14 <heatsink> > let num = 2.5 in round (sqrt num)
19:48:17 <lambdabot>   2
19:48:20 <johnfn> no instance for (floating integer) arising from a use of sqrt at (location)
19:48:30 <BMeph> johnfn: hpaste is your friend. Well, hpaste is Our friend, but still... ;)
19:48:39 <BMeph> @hpaste
19:48:39 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:48:42 <Gracenotes> are you sure you didn't do "let num = 5" or something?
19:48:55 <Gracenotes> if you do that, it makes it into an integer, and it can't be used with sqrt
19:48:55 <kmc> > sqrt (5 :: Integer)
19:48:57 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Internals.Integer)
19:48:57 <lambdabot>    arisi...
19:49:00 <Gracenotes> however, let num = 5.0 would work
19:49:06 <johnfn> aah
19:49:08 <kmc> johnfn, Haskell has no implicit numerical conversions
19:49:10 <kmc> :t fromIntegral
19:49:12 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:49:18 <BMeph> > let num = 5 in round (sqrt num)
19:49:19 <johnfn> well then why does sqrt 5 work?
19:49:20 <lambdabot>   2
19:49:28 <johnfn> does it auto consider all numbers to be floats?
19:49:33 <kmc> johnfn, the literal 5 has polymorphic type
19:49:34 <kmc> :t 5
19:49:36 <lambdabot> forall t. (Num t) => t
19:49:47 <kmc> :t let z = 5 in sqrt z
19:49:49 <lambdabot> forall a. (Floating a) => a
19:49:57 <johnfn> aaaah
19:49:59 <kmc> johnfn, it sees that you're using it with sqrt and adds an extra constraint on the type
19:50:06 <johnfn> that makes a lot more sense
19:50:09 <johnfn> thanks :D
19:50:10 <Gracenotes> johnfn: you've run into something called the monomorphism restriction :/
19:50:12 <Makoryu> johnfn: He lied. It does have implicit conversions for literals only
19:50:21 <Makoryu> johnfn: Just not for general purpose use
19:50:34 <BMeph> > let num = succ 4 in round (sqrt num)
19:50:35 <lambdabot>   2
19:50:37 <kmc> Makoryu, that's not an implicit conversion
19:50:50 <Gracenotes> well, there's no conversion. A "5" must have a specific type, whether "Integer" or "Num a => a".
19:51:28 <Gracenotes> the difference is that Integer is very specific, but Num a => a can later be specified to a particular type, whether Integer, Float, or Double, so long as it's a Num
19:51:35 <BMeph> Gracenotes: '(Num a) => a' isn't technically a specific type.... ;)
19:51:42 <kmc> whee
19:51:52 <Gracenotes> well, yeah, for most values of "specific" :P but it is a type
19:52:09 * ksf thinks of classes as sets of types.
19:52:14 <kmc> the point is, two monomorphic types are not compatible unless they are the same
19:52:46 <johnfn> that makes perfect sense actaully
19:52:50 <heatsink> johnfn: ghc will convert numeric values to a default type if they're still polymorphic after typechecking.  In interpreter, this happens after each line of code.  In compiler, this happens once per file.
19:52:53 * BMeph hums the Pink Panther theme: Pedant, pedant... pedant-pedant-pedant, pedant, pedannnnnnt! Peda-pe-pedant!
19:52:59 <Gracenotes> but.. anyway.. if you do let x = 5, ghci has a tendency to set it to the specific Integer type, because letting it just be Num a => a would be performance-inefficient in certain corner cases :/
19:53:04 <heatsink> > let num = 4
19:53:05 <lambdabot>   not an expression: `let num = 4'
19:53:13 <heatsink> @let num = 4
19:53:14 <lambdabot>  Defined.
19:53:21 <heatsink> > sqrt num
19:53:22 <lambdabot>   2.0
19:53:47 <Gracenotes> lambdabot doesn't have the same problems with monomorphism restriction, then.. is it switched off?
19:53:48 <heatsink> huh, does lambdabot not default?
19:54:08 <canvon> :t num
19:54:10 <lambdabot> forall t. (Num t) => t
19:54:16 * ksf thinks @let is distinct from the usual let.
19:54:22 <ksf> ...that is, lambdabot isn't ghci.
19:54:31 <BMeph> Wi---cked! :)
19:54:33 <ksf> it's not running everything inside a do-block.
19:54:36 <copumpkin> lambdabot does have MR turned off afair
19:55:07 <canvon> Prelude> let num = 4
19:55:07 <canvon> Prelude> :t num
19:55:08 <canvon> num :: Integer
19:55:16 <canvon> (for context)
19:55:19 * ksf imagines @let's get compiled into a module, and every > line imports that.
19:55:21 <Gracenotes> @let num2 = xxx
19:55:22 <lambdabot>  <local>:4:7: Not in scope: `xxx'
19:55:36 <Gracenotes> hm. so it's not simply textual substitution..
19:58:16 <robdaemon> Hi all, long time Java dev learning Haskell
19:58:45 <kmc> hi
19:58:52 <ksf> robdaemon, congratulations!
19:59:04 <ksf> ...my condolences for working with java. I know the pain.
19:59:19 <robdaemon> I'm really tired of checking for null and Spring xml configuration files :)
20:00:48 <robdaemon> Which leads to my first Haskell related question - Trying to compile gtk2hs from darcs on Mac OS Snow Leopard.  I get this error during compile: invalid character '_' in mnemonic
20:00:51 <Makoryu> robdaemon: Welcome to the foldr!
20:00:57 <Makoryu> robdaemon: Oh god
20:01:02 <robdaemon> Followed by: FATAL:Symbol L_gtk_misc_get_type$stub already defined.
20:01:11 <Gracenotes> D:
20:01:24 <robdaemon> I sense this isn't a new question
20:01:29 <robdaemon> Google isn't helping much :)
20:01:31 <Makoryu> robdaemon: I gave up on compiling gtk2hs even before SL broke everything
20:01:53 * ksf recommends switching to gentoo
20:02:17 <robdaemon> I was attempting to compile yi with the gtk frontend, but I'm tempted to give up and just use plain emacs :)
20:02:32 <robdaemon> ksf: I'm an Ubuntu man for my Linux needs, personally :)
20:02:42 <robdaemon> Used gentoo for years though
20:02:44 <Makoryu> ksf: I would dual boot (preferably with... well, not Gentoo) but I've heard Linux is a huge pain to install on a BootCamped volume
20:02:50 <Makoryu> s/volume/device/
20:02:58 <copumpkin> http://www.reddit.com/r/haskell/comments/9i8e1/parsimony_is_a_generalized_and_simplified_version/ anyone have any idea about my question there?
20:03:18 <robdaemon> Makoryu: It was at first, but the biggest problem is the hardware support is... quirky.
20:03:19 <kmc> robdaemon, if your main goal is to learn haskell, i'd set this aside for now
20:03:24 <Gracenotes> well, "gtk_misc_get_type" seems to be a function in the Gtk source
20:03:28 <sjanssen> copumpkin: I've wondered the same thing myself
20:03:34 <Gracenotes> returning GtkType
20:03:56 <ksf> well, dual-boot never worked properly for me on this machine. That is, windoze just plainly refused to boot when loaded via grub. it _did_ attempt to start, but failed to find its disk (the only pata one, so the only one it can see, anyway)
20:03:56 <robdaemon> kmc: yeah, that's what I was thinking, but I thought I'd try here before giving up on that part.
20:04:06 <copumpkin> sjanssen: it seems to be a new name for a minor cleanup, which alone isn't too bad, but it happens to overlap with the name of a (in my opinion) much more interesting upcoming framework from edwardk
20:04:27 <kmc> robdaemon, sorry you've run into linker bs early on
20:04:31 <copumpkin> but I guess there's no guidelines on naming in hackage
20:04:37 <robdaemon> I've started reading the Real World Haskell book, but is there something else you reccommend?
20:04:40 <sjanssen> copumpkin: guess he should have uploaded sooner?
20:04:46 <copumpkin> sjanssen: guess so :)
20:04:46 <robdaemon> kmc: Reminds me of my old C days :)
20:04:52 <kmc> robdaemon, the Gentle Introduction to Haskell is classic
20:04:54 <ksf> robdaemon, learn you a haskell, and the typeclassopedia.
20:04:55 <kmc> but, err, not so gentle
20:05:06 <robdaemon> hahaha
20:05:17 <Axman6> robdaemon: i recommend learn you a haskell, then RWH
20:05:17 <ksf> also, http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
20:05:20 <robdaemon> Learn you a Haskell seems pretty fun
20:05:35 <ksf> (for a more real world example than what real world haskell gives you)
20:05:43 <kmc> robdaemon, mind if i give unsolicited advice
20:05:50 <Makoryu> ksf: Oh man, how have I not heard of this?
20:05:57 <robdaemon> kmc: please do - that's one of the reasons I'm here
20:06:16 <ksf> Makoryu, you ignored the zipper hype?
20:06:18 <kmc> robdaemon, if you want to do IO early on, learn it, but if you want to reason about monads in general, don't use the IO monad as a source of intuition
20:06:29 <kmc> it's an unusual one
20:06:35 <robdaemon> Everyone I work with has drank the Java kool-aid, so to speak, so I have few places to ask
20:06:41 <ksf> ...otoh, fixIO tells you volumes about monads.
20:06:51 <kmc> :t fixIO
20:06:53 <lambdabot> Not in scope: `fixIO'
20:07:05 <Axman6> robdaemon: avoid IO as logng as possible basically :P
20:07:06 <robdaemon> kmc: ahh, okay.  I'm sure I will be doing IO.  My day job tends to do web stuff, so I gravitate towards that as a starting place
20:07:26 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
20:07:27 <robdaemon> Java's IO classes are hardly intuitive too :)
20:07:31 <Makoryu> robdaemon: As a former Java kool-aid drinker myself (spoilers: that aftertaste is a trace of cyanide) I assure you, this is the best place to come for Haskell advice, solicited or not
20:07:36 <ksf> fixIO :: (a -> IO a) -> IO a
20:08:06 <kmc> ksf, its implementation looks quite IO-specific
20:08:14 <robdaemon> so far, this is a great introduction to the Haskell community.  Thanks all :)
20:08:17 <ksf> ...well, it _is_ mfix for IO.
20:08:25 <Axman6> ...... does fixIO find non termination? o.O
20:08:28 <Gracenotes> heck, there is a published paper about the semantics of fixIO -_-
20:08:36 <ksf> Axman6, yep, it does.
20:08:46 <kmc> sure, but is IO representative of MonadFix any more that it is of Monad ?
20:08:55 <Axman6> robdaemon: vertainly the most friendly and helpful community i've ever been a part of on the web
20:08:55 <kmc> i'm not sure tbh, i haven't used mfix much
20:08:55 <ksf> if k is strict in it's first argument, stuff blows.
20:09:09 <robdaemon> not to mention I kind of missed irc :)
20:09:14 <p_l> robdaemon: Java IO classes make me wonder how the hell people manage to get anything done :D
20:09:21 <kmc> robdaemon, be sure to get an interactive haskell environment you like, like GHCi
20:09:22 <Axman6> heh
20:09:27 <kmc> and also come here and play with lambdabot
20:09:30 <ksf> you can't have k being strict in its first argument when the monad's bind is strict in its first.
20:09:37 <Axman6> or just hack everything in lambdabot ...
20:09:38 <robdaemon> yeah, I have ghc 6.10.4 and the Haskell Platform installed
20:09:41 <Gwern-away> @vixen do you like being played with?
20:09:41 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
20:09:47 <kmc> > let fibs = 1 : 1 : zipWith (+) fibs $ tail fibs
20:09:49 <lambdabot>   not an expression: `let fibs = 1 : 1 : zipWith (+) fibs $ tail fibs'
20:09:51 <ksf> @vixen, do you mind robdaemon playing with you?
20:09:51 <lambdabot> Unknown command, try @list
20:09:51 <kmc> > let fibs = 1 : 1 : zipWith (+) fibs $ tail fibs in fibs
20:09:53 <lambdabot>   Couldn't match expected type `[t]'
20:09:58 <kmc> gaah
20:10:07 <Gracenotes> p_l: it's quite simple, you just take a FileOutputStream and OutputStreamReader in a BufferedReader, with UTF-8 there somewhere
20:10:08 <ksf> @vixen  do you mind robdaemon playing with you?
20:10:08 <lambdabot> I believe in the battle-whether it's the battle of a campaign or the battle of this office, which is a continuing battle.
20:10:16 <Gracenotes> ..
20:10:23 <Makoryu> > text . map chr $ [72,101,121,32,114,111,98,100,97,101,109,111,110,44,32,99,104,101,99,107,32,116,104,105,115,32,111,117,116]
20:10:25 <lambdabot>   Hey robdaemon, check this out
20:10:31 <Axman6> heh
20:10:33 <kmc> :t text
20:10:34 <lambdabot> String -> Doc
20:10:35 <sjanssen> Gwern-away: whoa, what happened to vixen?
20:10:42 * Gwern-away has no idea
20:10:46 <Axman6> @vixen hey sexy
20:10:46 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
20:10:48 <sjanssen> @vixen haskell
20:10:49 <lambdabot> I've never canceled a subscription to a newspaper because of bad cartoons or editorials. If that were the case, I wouldn't have any newspapers or magazines to read.
20:10:51 <ksf> ok. that assured two things: a) lambdabot isn't lesbian, b) she's not an easy prey.
20:10:51 <Gracenotes> vixen is still there, no?
20:10:57 <sjanssen> autocorrected to @nixon
20:11:00 <sjanssen> @nixon
20:11:00 <lambdabot> You know, it's a funny thing, every one of the bastards that are out for legalizing marijuana is Jewish. What the Christ is the matter with the Jews, Bob? What is the matter with them? I suppose it
20:11:00 <lambdabot> is because most of them are psychiatrists.
20:11:09 <kmc> wow, lambdabot has gotten controversial
20:11:11 <Makoryu> What the hell
20:11:12 <Axman6> :(
20:11:19 <kmc> @nixon
20:11:19 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
20:11:21 <kmc> @nixon
20:11:21 <lambdabot> You know, it's a funny thing, every one of the bastards that are out for legalizing marijuana is Jewish. What the Christ is the matter with the Jews, Bob? What is the matter with them? I suppose it
20:11:22 <blackdog> hm, i didn't put that one in...
20:11:22 <lambdabot> is because most of them are psychiatrists.
20:11:23 <Gwern-away> I didn't even know lambdabot had a nixon!
20:11:23 <Gracenotes> wait.. why it no talk like valley girl? it must have said a bad word.
20:11:25 <heatsink> ah! now it makes sense.
20:11:29 <robdaemon> lambabot seems to be quite opinionated :)
20:11:30 <blackdog> oh, @nixon :) that's cute
20:11:34 <p_l> Gracenotes: somehow I prefer (with-open-file #p"..." :type 'some-utf-8) ;-)
20:11:35 <kmc> he he
20:11:40 <Gwern-away> I wonder if this is Saizan's doing...
20:11:54 <Makoryu> I suspect someone's been talking to lambdabot behind closed doors....
20:11:58 <Gracenotes> Nixon? like, Richard Nixon quotes?
20:12:02 <sjanssen> Gwern-away: @nixon is old.  @vixen disappearing is new
20:12:08 <kmc> @vixen where are the tapes?
20:12:09 <lambdabot> I can take it. The tougher it gets, the cooler I get.
20:12:51 <blackdog> vixen was useful recently... was applying for a job at jane st, and i submitted the code (after cleaning it up a bit)
20:13:14 <Gwern-away> and you didn't contribute back your cleanups?
20:13:16 <Gwern-away> you dog
20:13:22 <blackdog> well, not yet :)
20:13:37 <Gracenotes> here is some vixen for your enjoyment. "Why is magenta on blues clues a boy while blue is a girl? what has this world come to and what is wrong with the government, blues clues should be stopped while its ahead!!"
20:13:38 <kmc> blackdog, did it work?
20:13:39 <ksf> why, what's their buiseness? sms scams?
20:13:45 <sjanssen> Gwern-away: this is from months ago, but I think the @redo -> @do change is a bit silly
20:14:01 <blackdog> kmc: they're flying me from sydney to ny, so i guess so :)
20:14:07 <kmc> blackdog, congrats
20:14:09 <robdaemon> okay i'm lost..  what's vixen ?
20:14:13 <kmc> and good luck
20:14:18 <Gwern-away> maybe jane street's standards are much lower than I thought
20:14:19 <kyagrd> is it possible to configure cabal so that I can upgrade to the most recent version that builds on my distribution of the compiler version?
20:14:21 <blackdog> ksf: nah, finance firm. do all their stuff in ocaml
20:14:23 <kmc> robdaemon, a chatter bot mode for lambdabot
20:14:26 <ksf> @vixen tell us about yourself.
20:14:26 <lambdabot> Voters quickly forget what a man says.
20:14:29 <kmc> one of the less useful things it does
20:14:29 <sjanssen> robdaemon: a plugin for the IRC bot lambdabot that talks like a valley girl
20:14:47 <robdaemon> like, oh my god ;)  I lived in the valley for years
20:14:49 <Gracenotes> so we'd go "@vixen asl", and the bot would go "19/f/California"
20:14:50 <copumpkin> that doesn't sound very, like, vallerygirl to me
20:14:57 <kmc> which appears to have been replaced with the ghost of one Richard Milhous Nixon
20:14:58 <copumpkin> it's, like totally not valley girl
20:15:00 <blackdog> Gwern-away: well, it was just a code sample. you want enough to check someone's style
20:15:22 <Gwern-away> blackdog: you did have a real resume besides vixen I hope :)
20:15:22 <robdaemon> I just opened the lambdabot wiki page :)
20:15:27 <Gracenotes> and if you asked "where do you go to school", it would say "I'm a softmore at UCLA"
20:15:36 <blackdog> Gwern-away: heh, yes.
20:15:58 <blackdog> getting an interview solely on the strength of a chatbot would have been cool, though :)
20:16:53 <blackdog> i still wonder if they ran it... i changed some of the data in the default install so that if they asked her about Ocaml, it said they should definitely hire her friend mark...
20:17:01 <Gwern-away> heh
20:17:24 <Gracenotes> robdaemon: the original purpose of the bot was to pass the Turing Test for guys looking to cyber, and then post logs of it online
20:17:24 <Gwern-away> lb ain't the easiest thing to install and run without cabal-install, so I doubt they did any more than read it
20:18:07 <robdaemon> Gracenotes: now that's awesome
20:18:10 <blackdog> Gwern-away: it has multiple front ends. the easiest one to install is basically 'interact'
20:18:14 <robdaemon> so is the > commands to lambabot
20:18:53 <blackdog> robdaemon: i swiped the regular expressions from the original vixenlove and turned it into a data-driven app. it's only a page of code or so.
20:19:01 <robdaemon> I did briefly look into OCaml but the syntax creeped me out ;)
20:19:10 <ksf> how do I get hold of an instance decl in TH?
20:19:39 <Makoryu> robdaemon: Heh, OCaml's syntax is charmingly clunky. Kind of like a stick shift diesel truck to Haskell's Prius
20:19:55 <Gwern-away> some people say, I have a problem; I know, I'll fix it with template haskell...
20:20:11 <sjanssen> Gwern-away: well, nobody has touched Modules.hs in more than a year, so the repository lambdabot runs from isn't the same as upstream
20:20:12 <Makoryu> *CLUNKCLUNKGRIIIIIINGWHRRWHRRRKACHUNK*
20:20:14 <blackdog> now they have $undecidable_number problems
20:20:18 <Gwern-away> blackdog: well, that does make sense
20:20:46 <robdaemon> I kept thinking, so when do I ;; or ;;; or not at all?
20:20:51 <deech``> Has anyone here successfully installed Haskore? And if you have how much of a pain was it. I am thinking about using it in a Hackfest where Windows, Mac and Linux users have to install it.
20:20:59 <heatsink> ksf: last I heard (which was a couple years ago) you can't look up a type's instances in TH.
20:21:16 <Gwern-away> deech``: I'd ask henning how well haskore runs right now
20:21:29 <kmc> robdaemon, > is for evaluating expressions
20:21:30 <Gwern-away> deech``: he was holding off on various ghc/cabal upgrades/updates because of issues
20:21:34 <ksf> deech``, imagine impaling yourself on a ship mast wrapped with red-glowing, barbed wire.
20:21:45 <robdaemon> kmc: yeah I did the > map (+1) [1..10]
20:21:45 <kmc> :t will give you a type (as in ghci)
20:21:47 <lambdabot> parse error on input `type'
20:21:50 <robdaemon> awesome
20:21:55 <kmc> and there are a bunch more
20:22:03 <kmc> for example it can generate functions from types alone:
20:22:06 <kmc> @djinn (a -> b) -> a -> b
20:22:06 <lambdabot> f a = a
20:22:07 <CalJohn> @let x = 1
20:22:08 <lambdabot>  Defined.
20:22:10 <deech``> ksf: So you're saying "bad idea", did I read that correctly? :)
20:22:20 <ksf> well, I managed to do it.
20:22:21 <kmc> @djinn (a -> b) -> (b -> c) -> a -> c
20:22:21 <lambdabot> f a b c = b (a c)
20:22:22 <ksf> but it's no fun.
20:22:28 <Gracenotes> '>' is for lambdabot only
20:22:34 <ksf> but then that was two years ago or such.
20:22:34 <blackdog> deech``: nah, that's a standard friday night for ksf
20:22:46 <CalJohn> i think the rule with lambdabot is that it's basically ghci except that you're not allowed anything in IO m
20:23:00 <deech``> Ah, now I understand why ksf likes Haskell.
20:23:01 <Gwern-away> @remember deech`` deech``> Has anyone here successfully installed Haskore? And if you have how much of a pain was it. ksf> deech``, imagine impaling yourself on a ship mast wrapped with red-glowing, barbed wire.
20:23:01 <lambdabot> Nice!
20:23:09 <Gwern-away> CalJohn: or which takes longer than 5 seconds!
20:23:16 <robdaemon> CalJohn: makes sense...  sandboxing
20:23:17 <kmc> @quote pain
20:23:18 <lambdabot> quicksilver says: making the compiler writer's job painful is one of the main duties of a language designer.
20:23:21 <kmc> @quote pain
20:23:21 <lambdabot> quicksilver says: making the compiler writer's job painful is one of the main duties of a language designer.
20:23:24 <ksf> lambdabot is basically mueval...
20:23:28 <kmc> @quote Haskore
20:23:29 <lambdabot> deech`` says: deech``> Has anyone here successfully installed Haskore? And if you have how much of a pain was it. ksf> deech``, imagine impaling yourself on a ship mast wrapped with red-glowing,
20:23:29 <lambdabot> barbed wire.
20:23:33 <Gwern-away> @flush
20:23:34 <lambdabot> Not enough privileges
20:23:44 <gwern> @flush
20:23:46 <blackdog> Gwern-away: actually, how do you get access to the lambdabot extensions? i should really put the changes back in
20:23:51 <Gracenotes> mrowl
20:23:57 <gwern> blackdog: extensions?
20:24:17 <gwern> @nixon you sexy dog!
20:24:17 <lambdabot> Your boys will be home for Christmas.
20:24:18 <blackdog> gwern: vixen sources
20:24:28 <gwern> blackdog: I assume its in the lb repo
20:24:29 <gwern> @version
20:24:30 <lambdabot> lambdabot 4.2.2.1
20:24:30 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:24:46 <blackdog> righto, cheers.
20:27:19 <robdaemon> Okay, I'm sure I'll be back tomorrow.  Thanks for the hints and starting points, all!!
20:30:17 <ksf> wtf. so the way to go is c header -> c2hs -> haskell file -> haskell-src to parse instance decls -> haskell file
20:30:46 <ksf> ...I might just consider hacking c2hs, then.
20:31:18 <ksf> ...using plain and simple TH wouldn't mess with the build system, at least.
20:32:24 <heatsink> I've used hsc, but avoided c2hs.
20:32:44 <thoughtpolice> why?
20:33:09 <heatsink> Large C headers, only small parts marshaled.
20:33:13 <ksf> c2hs is great for all that marshalling.
20:33:43 <ksf> ...but, sadly, enum hooks won't generate the code I want.
20:34:16 <ksf> (restricting C enums to Int is actually an abdomination)
20:34:20 <heatsink> Oh, my other reason for using hsc was C++.
20:36:07 <heatsink> Enums implicitly convert to int in C...
20:36:22 <kmc> sad but true
20:39:04 <blackdog> gwern: ha, someone's already celaned it up to basically what i've got here. funny :)
20:43:50 <luis> Hello. What book would you recommend to learn Haskell?
20:44:16 <hausu> TAPL PFDS HSoE RWH
20:44:23 <kmc> naked lunch
20:44:31 <Makoryu> luis: LYAH and RWH
20:44:34 <Makoryu> @where LYAH
20:44:34 <lambdabot> www.learnyouahaskell.com
20:44:39 <Makoryu> @where RWH
20:44:40 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
20:44:49 <luis> Thanks.
20:44:56 * Makoryu salutes
20:45:18 <hausu> wouldnt LYaH be more appropriate. is @where case sensitive?
20:45:30 <Makoryu> hausu: I suspect it isn't
20:45:35 <Makoryu> @where lYaH
20:45:35 <lambdabot> www.learnyouahaskell.com
20:45:40 <sbahra> PFDs HSoE?
20:45:46 <Makoryu> @where hsoe
20:45:47 <lambdabot> Haskell School of Expression.
20:45:48 <araujo> luis, real world haskell , introduction to functional programming with haskell
20:45:49 <sbahra> luis, if you're new to functional programming...
20:46:06 <sbahra> luis, I really recommend  "Haskell: The Craft of Functional Programming" by Simon Thompson
20:46:21 <Makoryu> @where PFDS
20:46:21 <gwern> wish TAPL was online
20:46:21 <lambdabot> I know nothing about pfds.
20:46:29 <kmc> gwern, you can probably torrent it
20:46:34 <hausu> PFDS has a PS version, his thesis
20:46:37 <kmc> if you don't mind being a terrible criminal and such
20:46:38 <kyagrd> Graham Hutton's "Programming in Haskell" is a very  nice introductory material explaining almost everything from first principles.
20:46:45 <gwern> kmc: oh, I don't
20:47:09 <blackdog> ixnay on the iracypay in the annelchay, fellas.
20:47:18 <hausu> tapl addendum with all the GHC typesystem addons would be nice
20:47:43 <kmc> there's a sequel to tapl
20:48:06 <SamB_XP> hausu: we were actually hoping for Haskell Report addendums and/or appendices for same
20:48:07 <heatsink> @where attapl
20:48:07 <lambdabot> I know nothing about attapl.
20:48:15 <Axman6> hausu: GHC or haskell?
20:48:22 <kyagrd> @google attpl
20:48:23 <lambdabot> No Result Found.
20:48:25 <kyagrd> @google atttpl
20:48:25 <lambdabot> No Result Found.
20:48:36 <heatsink> @google attapl
20:48:37 <lambdabot> http://www.cis.upenn.edu/~bcpierce/attapl/
20:48:37 <lambdabot> Title: Types and Programming Languages
20:48:40 <jaredj> @djinn [(k,a)] -> Data.Map.Map k [a]
20:48:41 <lambdabot> Error: Undefined type []
20:48:42 <hausu> Axman6: havent messed with jhc/nhc/yhc/hugs much to know waht they suport
20:48:47 <kyagrd> ah my finger twisted
20:48:55 <kmc> @djinn [(k,v)] -> k -> Maybe v
20:48:55 <lambdabot> Error: Undefined type []
20:49:15 <Axman6> djinn does't know about recursive types
20:49:18 <kmc> hausu, mostly a subset of GHC's extensions
20:49:18 <kyagrd> hausu: there's one more now UHC
20:50:00 <hausu> oi. what about Clean compiler. i heard someone was porting that?
20:50:02 <jaredj> @human [(k,v)] -> Data.Map.Map k [a]
20:50:02 <lambdabot> Unknown command, try @list
20:50:37 <jaredj> @human [(k,v)] -> Data.Map.Map k [v]
20:50:37 <lambdabot> Unknown command, try @list
20:50:56 <jfoutz> if i have data T a = E | B (T a) a (T a), and f e b (B l a r) = b (f e b l) a (f e b r), is f anything special? cause, it's real handy. i just wonder if it has a name?
20:51:05 <jaredj> Is Map the right type if the value is going to be a list?
20:51:11 <jaredj> like i want to make a hashtable
20:51:19 <jaredj> but 'hash' is an implementation detail
20:51:39 <kmc> feb blar bfebl a febr
20:51:43 <jaredj> and i don't see a fromXXX in Data.Map that already does what i want
20:51:44 <SamB_XP> Data.Map is almost always the right type
20:51:45 <jfoutz> maybe i should hpaste that :)
20:51:46 <heatsink> jfoutz, it looks like a catamorphism, a generalization of 'fold' to recursive data structures other than lists.
20:52:00 <kyagrd> @hoogle hash
20:52:01 <lambdabot> package Hashell
20:52:01 <lambdabot> Data.HashTable hashInt :: Int -> Int32
20:52:01 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
20:52:12 <SamB_XP> or, rather, Data.Map.Map
20:52:21 <jfoutz> heatsink: thank you, i'll have to go read about that.
20:52:25 <jaredj> yes yes, when i said 'hashtable' i was using, say, ruby parlance
20:52:38 <jaredj> aight, thanks SamB_XP
20:52:45 <kmc> jaredj, if you just want an associative container, and your keys are ordered, it's a good choice
20:52:51 <kmc> if you actually need O(1) lookup, that's harder
20:52:52 <heatsink> jfoutz, probably the paper to read is the Bananas, Lenses, and Barbed Wire paper
20:53:22 <ksf> log n < 64, for all usable n, anyway.
20:53:30 <ksf> so O(log n) is actually O(1)
20:53:33 <SamB_XP> jaredj: sometimes IntMap is preferable, but Data.HashTable is apparently really slow so don't use that ;-)
20:53:43 <kmc> ksf, there are a finite number of bits in the universe...
20:53:45 <SamB_XP> (also, the interface is painful ;-)
20:53:47 <jaredj> kmc: associative is all i need. but Data.Map.fromAscList overwrites all (k,v) with (k,later_v) rather than making a list of [v,later_v]
20:53:59 <kyagrd> There is Data.Hash in some cabal package
20:54:02 <jaredj> that's what set me asking if i had the right type
20:54:04 <heatsink> jfoutz: Heh, you basically invented the foldTree example on wikipedia :)
20:54:05 <kmc> jaredj, then you want a Map key [value]
20:54:11 <kmc> and you can use insertWith (i think it's called)
20:54:14 <kmc> :t M.insertWith
20:54:15 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
20:54:20 <jfoutz> heatsink: thanks, i'll check that out. yeah, i was just reading that :)
20:54:36 <jfoutz> heatsink: since you mentioned the name...
20:54:42 <jfoutz> neat.
20:54:54 <jaredj> kmc: ok thanks. i didn't see any [] and despaired
20:54:55 <kyagrd> Well you have to define your own Hashable class instance for your own data type though
20:55:11 <jaredj> :t (:)
20:55:12 <lambdabot> forall a. a -> [a] -> [a]
20:55:18 <jaredj> :d
20:55:20 <kmc> :t M.insertWith (++) . return
20:55:22 <lambdabot> forall a a1 (m :: * -> *). (Ord (m a1), Monad m) => a1 -> [a] -> M.Map (m a1) [a] -> M.Map (m a1) [a]
20:55:26 <SamB_XP> jfoutz: looks like a catamorphism ;-)
20:55:32 <ksf> hashes are overrated, and tries underused.
20:55:36 <kmc> :t M.insertWith (++) . (:[])
20:55:38 <lambdabot> forall a a1. (Ord a1) => a1 -> [a] -> M.Map [a1] [a] -> M.Map [a1] [a]
20:55:47 <kmc> hmm i fail
20:55:50 <jaredj> :)
20:55:51 <jfoutz> SamB_XP: yeah! this is really neat.
20:55:51 <kyagrd> @google hash-data
20:55:52 <lambdabot> http://en.wikipedia.org/wiki/Hash_function
20:55:52 <lambdabot> Title: Hash function - Wikipedia, the free encyclopedia
20:55:53 <SamB_XP> oh, someone siad that already
20:55:54 <ksf> as long as you don't have a perfect hash, you're going to do bucket lookup, after all.
20:55:57 <kyagrd> @google hash-data cabal
20:55:58 <SamB_XP> but it really does ;-)
20:55:58 <lambdabot> http://books.google.com/books?id=i0W9NBmxewQC&pg=PA4&lpg=PA4&dq=hash-data+cabal&source=bl&ots=_9IAkpI2AH&sig=MzUU65QSzCKiUhKvWSZYDn80Hfs
20:56:01 <kyagrd> ah .
20:56:06 <ksf> ...and perfect hashes suck at insertion.
20:56:14 <kmc> ksf, there are a lot of apps that will be unhappy if you make the inner loop 64 times slower
20:56:37 <kmc> "O(1)" or not
20:57:34 <ksf> ...and even a perfect hash has a lookup complexity of O(keylen)
20:57:53 <SamB_XP> ksf: at least
20:58:01 <ksf> the best you can do is use interfaces, and then try some sensible configurations of data structures.
20:59:10 <ksf> http://theory.stanford.edu/~amitp/GameProgramming/ has some very decent thoughts about what combination of data structures best to use for a specific problem.
20:59:29 <kscaldef> *Main> maximum [1..1000000]
20:59:29 <kscaldef> *** Exception: stack overflow
20:59:31 <kscaldef> why?
20:59:38 <kmc> @src maximum
20:59:38 <lambdabot> maximum [] = undefined
20:59:39 <lambdabot> maximum xs = foldl1 max xs
21:00:14 <ksf> @src foldl1
21:00:14 <lambdabot> foldl1 f (x:xs) = foldl f x xs
21:00:14 <lambdabot> foldl1 _ []     = undefined
21:00:15 <kmc> > let f xs = foldl' max 0 xs in f  [1..1000000]
21:00:18 <lambdabot>   1000000
21:00:18 <ksf> @src foldl
21:00:18 <lambdabot> foldl f z []     = z
21:00:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:00:20 <kscaldef> so, it's not hard to write a maximum that runs in constant space
21:00:21 <kyagrd> It's a shame that there isn't a off the shelf hash map library in Haskell (maybe there is but not advertised?)
21:00:30 <kmc> kscaldef, looks like a laziness issue
21:00:48 <kscaldef> I don't understand why the standard version doesn't
21:01:05 <kyagrd> In general idiomatic interfaces to basic and widely used data structures and algorithms
21:01:09 <ksf> non-strict foldl has to unroll its argument list.
21:01:13 <SamB_XP> kscaldef: apparantly, so that you can do this ...
21:01:23 <kyagrd> is a problem in may functional langauges (list is not the only data structure!!)
21:01:24 <SamB_XP> > maximum [1..] :: Natural
21:01:25 <mle> kyagrd: can't use Data.Map (tree) ?
21:01:31 <kmc> kyagrd, haskell has much more than lists
21:01:39 <SamB_XP> kscaldef: except the standard doesn't define Natural
21:01:39 <lambdabot>   thread killed
21:01:41 <kmc> but some structures like hash maps are not well suited to functional programming
21:01:43 <monochrom> hash map is overrated and overspecified. 99% of the time you just want associative map. well Data.Map does that.
21:01:44 <kmc> that said, the library should exist
21:01:52 <SamB_XP> and you clearly can't print that anyway
21:02:02 <kscaldef> SamB_XP: I'm having a somewhat hard time figuring out why I would want to do that...
21:02:11 <kscaldef> I mean, it's nice that it doesn't immediately inf. loop
21:02:15 <SamB_XP> > (maximum [1..]) > 100000000000000000000 :: Natural
21:02:40 <kscaldef> hmm...
21:02:47 * ksf doubts lambdabot has enough ram for that.
21:02:58 <SamB_XP> ksf: it should run in constant space
21:03:04 <SamB_XP> shouldn't it ?
21:03:18 <ksf> aren't naturals peanos?
21:03:19 <monochrom> Data.Map has better asymptotic complexity than hashing.
21:03:22 <kscaldef> SamB_XP: no, since I already showed that maximum [1..1000000] failes
21:03:22 <kyagrd> You want two differrent kinds of associative maps, one is log n lookup with possibley often insert and update (or in functional term calcuate new map), and the other is once create and lookup a lot of times
21:03:32 <ksf> ...constructing them already takes gigabytes.
21:03:42 <kscaldef> > maximum [1..1000000]
21:03:42 <kyagrd> They do need different implementations for each specialized use
21:03:48 <SamB_XP> oh, wait, it has to keep around one to do the iteration ...
21:03:58 <lambdabot>   thread killed
21:04:08 <monochrom> Data.Map is O(1) iff hashing is O(1).
21:04:12 <kyagrd> And!! they should have a common idiomaitic interfaces, and there hasn't been very much work on this after edision.
21:04:14 <SamB_XP> > (maximum [1..]) > 100000 :: Natural
21:04:17 <mle> kyagrd: a perfect-hash system is a very different problem.
21:04:19 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
21:04:28 <SamB_XP> > (maximum [1..]) > (100000 :: Natural
21:04:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:04:33 <SamB_XP> > (maximum [1..]) > (100000 :: Natural)
21:04:39 <kyagrd> mle: I'm not spepcifically talking about perfect hash
21:04:49 <lambdabot>   thread killed
21:05:49 <monochrom> Even better, Data.Map worst case is O(1) iff hashing best case is O(1). We already know what happens to hashing worst case.
21:08:17 <monochrom> Perhaps combining a hashing function with an IntMap gives a good constant multiplier in the complexity.
21:08:36 <monochrom> IntMap uses trie, it's the best thing since array.
21:08:58 <mle> kyagrd: so go write a library that does what you want?
21:09:17 <mle> kyagrd: there are some excellent books out describing the complications of pure-functional data structures.
21:09:26 <kmc> i do agree that we should have something like this in hackage
21:09:41 <kmc> even if it is just hashStableName and IntMap
21:09:41 <kyagrd> So, Data.Map is really like a hash_map in C++ STL?
21:09:51 <kyagrd> (in performance)
21:09:53 <kmc> kyagrd, no such thing :)
21:09:54 <monochrom> So-called hash map is just hashing function + array + collision handling anyway. So just snatch out the evil array and put in the benevolent trie.
21:10:38 <kyagrd> So, trie based implementations are generally better than C++ STL hash_map implementations, is that right?
21:10:48 <kmc> kyagrd, why don't you test it and find out
21:10:53 <kyagrd> I hope there is some table or asymptotic results
21:10:56 <kmc> nothing is universally better than anything else
21:11:03 <kmc> (except PHP.  everything is universally better than PHP)
21:11:04 <kyagrd> I don't want to find out unless I am an algorhtim guy
21:11:23 <SamB_XP> kmc: tried ASP pre .NET?
21:11:28 <kmc> no
21:11:35 <SamB_XP> that could possibly be worse, no?
21:11:40 <kmc> if so, i'm impressed
21:11:59 <SamB_XP> doesn't it involve vbscript?
21:15:54 <kyagrd> SamB_XP: vbscript might be worse than PHP but vbscript is rather a client side script (which is very non-portable)
21:16:24 <kmc> iirc SamB_XP is correct that old ASP used VBScript on the server side
21:16:26 <kyagrd> so, doesn't directly compare to PHP although they are universally worse than anyting in their own universe
21:16:43 <SamB_XP> kyagrd: I was under the impression that it was the default scripting language of ASP pre-ASP.NET
21:17:32 <kyagrd> SamB_XP: even so vbscript and ASP runs on IIS and PHP usually runs with Apache so actually pretty non-overlapping tech
21:17:56 <SamB_XP> kyagrd: IIS can run PHP too, I'm sure ...
21:18:10 <kmc> i don't see how this means you can't compare the languages
21:18:12 <kyagrd> SamB_XP: oh well, but who actually does that? :)
21:18:15 <kmc> or why we care ;P
21:18:47 <SamB_XP> and anyway, the you could easily have a choice of either server ...
21:18:58 <SamB_XP> even each on an OS of choice!
21:23:13 <fis> hi crowd -
21:23:37 <fis> struggling with cabal and dynamic libs that rely on other dynamic libs.
21:23:43 <fis> anybody curious?
21:26:31 <kyagrd> I just looked up the documentation and both Data.Map O(log n)
21:27:55 <kyagrd> Is this just worst case but usually O(1) or something close in most lucky cases?  Or do we have to look something that is more like a C++ STL hash_map if there arn't that much updates (or incrementall builds of the mapping)
21:28:55 <kyagrd> I mean O(log n) insertion and member lookup time for Data.Map
21:29:04 <kmc> kyagrd, Data.Map.Map is implemented as a balanced binary tree
21:29:29 <kmc> so O(log n) is the "average" as well as worst case, for most definitions of average
21:29:40 <jfoutz> kyagrd: since my computer only has 4gig of ram, i usually label it bounded by O(32) and call it a day. but i'm a horrible slacker.
21:29:44 <kyagrd> right so there isn't something on hackage with a faster lookup (at least average)?
21:30:00 <kmc> kyagrd, i looked briefly and couldn't find it
21:30:14 <jfoutz> @where DiffArray
21:30:15 <lambdabot> I know nothing about diffarray.
21:30:24 <jfoutz> @hoogle DiffArray
21:30:25 <kmc> there are libraries for read-only perfect hashing
21:30:25 <lambdabot> Data.Array.Diff type DiffArray = IOToDiffArray IOArray
21:30:25 <lambdabot> Data.Array.Diff data IOToDiffArray a i e
21:30:25 <lambdabot> Data.Array.Diff newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
21:30:33 <jfoutz> those are quick
21:30:52 <kmc> kyagrd, do you have an application in mind where O(log n) is unacceptable
21:31:12 <kyagrd> Ah, I was just forgetting that functinal arrays were just trees :-)
21:31:20 <kmc> kyagrd, ?
21:31:28 <kmc> haskell has various array types and none of them are trees
21:31:32 <kmc> they have O(1) indexing
21:31:34 <Cale> kyagrd: Data.Array doesn't give you a tree...
21:31:40 <roconnor> how are hash_maps O(1)?? I thought they were O(n).
21:31:49 <Nereid_> roconnor: they're O(1).
21:31:54 <kmc> but are not associative (= handling sparse keys)
21:31:56 <jfoutz> ammortized O(1)
21:32:00 <kmc> Nereid, not quite, you can have collisions
21:32:09 <Axman6> roconnor: constant hash time, constant lookup time based on hash
21:32:11 <kmc> jfoutz, how do you amortize the hash time
21:32:12 <dm``> O(1) expected
21:32:16 <Nereid_> practically O(1).
21:32:18 <dm``> O(n) worst-case (for hash)
21:32:18 <kmc> i think it's just "a little above O(1)"
21:32:22 <Cale> and they're not even O(1) expected either
21:32:26 <Cale> O(log n)
21:32:30 <kmc> esp. if you use fancy hashing that adapts to collisions
21:32:31 <roconnor> dm``: thank you
21:32:31 <Nereid_> no...
21:32:40 <kyagrd> all hashing data constructurs rely on luck (that your input is lilkey to have not so much collision, or you come up with a hash function that manages to do that)
21:32:44 <Nereid_> regular Maps are O(log n)
21:32:47 <kyagrd> data structures i mean
21:32:51 <Cale> Because any function with n possible results takes at least O(log n) time to compute.
21:32:55 <Cale> It's unavoidable.
21:32:58 <p_l> roconnor: I guess you could call hashtables/maps as equivalent of array[hashfunc(key)] ;-)
21:32:59 <Nereid_> no...
21:33:12 <roconnor> p_l: but you have to deal with collisions
21:33:16 <roconnor> in the worst case
21:33:16 <kmc> kyagrd, i think in the spirit of "no premature optimization" it is fine to start with Data.Map for nearly any app
21:33:23 <kmc> and think harder if profiling reveals a bottleneck there
21:33:26 <p_l> roconnor: that's why it's not exactly O(1), but close enough
21:33:28 <kmc> i do agree that a uniform interface would be nice
21:33:35 <SamB_XP> Cale: is that a physical law?
21:33:45 <Cale> SamB_XP: Almost.
21:33:46 <roconnor> p_l: pfft.
21:33:49 <ksf> binary heaps, anyone?
21:34:09 <Nereid_> Cale: there exist O(n) sorts
21:34:12 <ksf> I guess you're better of with a vanilla Map in 99% of the cases, anyway.
21:34:15 <Nereid_> more restricted, though
21:34:18 <Cale> Nereid_: sure...
21:34:20 <Nereid_> radix sort, for instance
21:34:22 <Nereid_> .
21:34:27 <jfoutz> kmc: oh. hehe. i should read before i type.
21:34:28 <Nereid_> I guess that's kind of irrelevant.
21:34:33 <p_l> roconnor: exact complexity depends on hash function and data
21:34:34 <roconnor> shove 2^128 items into a hash map and see how well it performs.
21:34:47 <Nereid_> roconnor: shove that many items into _anything_
21:34:47 <Nereid_> :P
21:34:57 <SamB_XP> roconnor: right!
21:34:59 <Cale> If you have a function which has n distinct elements in its range, then it absolutely *must* examine at least O(log n) bits of its input.
21:35:07 <kmc> yeah the "sorting takes Ohm(n log n)" is for comparison sorting
21:35:09 <roconnor> Nereid_: shove it into a Map and it takes 128 steps to look up.
21:35:13 <p_l> roconnor: I believe you would run out of address space even on AS/400, and that's something
21:35:14 <kmc> Cale's point is more basic
21:35:19 <SamB_XP> roconnor: you give me a computer that can even do that, and, well, I'll give you a million dollars
21:35:24 <dm``> There exist O(n) sorts only when you have n elements numbered 1..n (radix sort).
21:35:27 <Nereid_> roconnor: my problem is in the shoving it in part
21:35:28 <roconnor> SamB_XP: :)
21:35:51 <SamB_XP> and of course you'd be stupid to take me up on this deal ;-)
21:36:08 <Cale> and assuming that only a constant number of bits of the input can be examined at a time, that gives that it must take at least O(log n) time to compute
21:36:12 <ksf> Cale, depends on sparsity, and your machine. that's why array indexing is said to be O(1)...
21:36:14 <Makoryu> Nereid_: I read "Perl" into that sentence
21:36:18 <roconnor> SamB_XP: I have a computer that is made of sand. :D
21:36:32 <kmc> arithmetic is not O(1)! wake up sheeple!
21:36:33 <Cale> ksf: Yeah, even array indexing is not really O(1).
21:36:33 <SamB_XP> roconnor: aren't most of them ?
21:36:45 <roconnor> good point
21:36:55 <kyagrd> kmc: I don't have an application but I am quite sure that there is an application for hash_map. Otherwise people woudln't be so crazy buliding that library. Intel has even more sophisticated ones with optimized custom block allocator and also considering a spin locks for multithreading
21:37:01 <Nereid_> Cale: it depends on what you mean by O(1)
21:37:01 <dm``> Generally the advantage of a hash table over a binary tree is that 1) hash tables are much easier to implement, and 2) the constant factors (i.e., stuff that doesn't show up in big-O notation) are better.
21:37:15 <Cale> ksf: If you actually looked at the hardware implementation of memory and tried to scale it, as you added more and more memory, that would fail.
21:37:19 <ksf> you can slice of an n from the complexity of virtually every algorithm if you move stuff to the hardware.
21:37:24 <kmc> kyagrd, i agree that the library should exist.  haskell should try to do everything well, even "un-haskelly" datastructures
21:37:25 <dm``> So the amortized analysis kind of loses the point.
21:37:25 <Nereid_> or rather, it depends on what you mean by 1
21:37:29 <kmc> but i think it doesn't matter much
21:37:32 <Cale> In fact, it would be a good deal worse than O(log n)
21:37:36 <kmc> to most users, in practice
21:37:48 <dm``> There are lots of hidden log factors in hash functions, though.
21:37:53 <Cale> Once you take practical considerations into account.
21:38:19 <kmc> kyagrd, i've used hash_map for very latency-sensitive applications, but in that case you'd be nuts to use a garbage-collected language anyway
21:38:31 <ksf> Data.Map, IntMap and bytestring-trie should cover about 99.9999% of the cases efficiently.
21:38:43 <dm``> The real question is how much slower is Data.Map in Haskell than hash_map in C++.  And if the answer to that is a lot, then the question is can we do better in Haskell.
21:38:46 <ksf> _plus_ we've got perfectHash.
21:38:54 <Cale> Basically, we ignore logarithmic factors all the time, and asymptotically, they don't really mean a whole lot. It's more practical just to deal with them as part of the constant factor.
21:39:02 <ksf> dm``, the real answer is: depends on usage.
21:39:05 <kmc> dm``, hash_map isn't even standard C++ let alone a standard implementation
21:39:06 <p_l> kmc: I heard of some cases where they used GC'd languages for realtime systems, though GHC might not necessarily fit :)
21:39:06 <SamB_XP> dm`: I think it's way faster
21:39:14 <ksf> most likely, also on the moon phase.
21:39:24 <kmc> p_l, hard realtime?
21:39:31 <SamB_XP> do you have any idea how long the type error messages take to print out in STL programs?
21:39:38 <kyagrd> kmc: boost library is kind of a de fact standard, just as real world haskell programmers cannot live without hackage libraries
21:39:51 <Cale> dm``: Does C++'s hash_map let you construct a new hash_map which has every element of the old one plus another without touching the original in O(log n) space and time?
21:39:59 <dm``> Agreed.  I don't use hash_map, but I use my own hand-coded hash functions in C and C++, and they are very fast.  I haven't used Haskell in a performance-critical situation yet, but will be interested to see what happens when I do.
21:40:05 <Nereid_> Cale: if array access is O(log n) or worse, what is, say, binary tree access?
21:40:06 <p_l> kmc: I'd say it probably depends on how much latency you can have - at some point you just have to get down to specially generated assembly :)
21:40:25 <dm``> Cale:  No, but that's the point, that the code you are writing in C++ is very different.
21:40:33 <kmc> p_l, oh sure, but there's a big meaty space in between where you still want a relatively high level language, but can't afford stalls due to GC
21:40:33 <kyagrd> Cale: definitely not and hashtable aren't usually expected to be so
21:40:38 <SamB_XP> Nereid: O(log^2 n) ?
21:40:43 <Cale> kyagrd: right.
21:41:10 <ksf> ...even O(2^log n) works fine, as n is always smaller than 64.
21:41:29 <SamB_XP> ksf: don't you mean log n is always smaller than 64?
21:41:35 <ksf> er yes.
21:41:43 <Nereid_> the "log n because of number of bits" is irrelevant practically unless you're using some sort of bignum thing for your indices (which is weird in the first place)
21:41:53 <SamB_XP> ksf: and 2^64 is a really damn long time
21:42:06 <ksf> heck it's O(1)
21:42:08 <jfoutz> still O(1) :p
21:42:17 <kmc> O(size of universe) = O(1)
21:42:23 <Cale> Nereid_: Same goes for trees though. The log n for the number of elements doesn't matter unless you have some sort of bignum number of elements :)
21:42:25 <SamB_XP> kmc: not necessarily
21:42:36 <p_l> kmc: I know that LispWorks sells a separate "custom order only" realtime implementation of Common Lisp, though probably not exactly standard-compliant. Other known way was usage of DSLs :)
21:42:57 <Nereid_> trees are slower than arrays by a factor of log n in any case
21:42:59 <dm``> In C++, I predominantly use hash tables and red-black trees.  The red-black trees are definitely slower than the hash tables.  I can't imagine Haskell's maps are faster than my C red-black tree implementation.  But Haskell maps have the added burden of needing to support updates that create entirely new trees.
21:43:00 <jmcarthur> a pointer dereference *does* use a tree
21:43:03 <Cale> Nereid_: For lookup, yes.
21:43:09 <Nereid_> that's what I  meant.
21:43:15 <kmc> p_l, interesting
21:43:19 <ksf> Nereid_, usually, you have sparse indices.
21:43:37 <ksf> resizing arrays can be a pain, too.
21:43:40 <Nereid_> the point of hash maps is practically O(1) insertion and lookup
21:43:42 <kmc> in finance there is a lot of very latency-sensitive code... some people use Java with loads of hacks; many use C++
21:43:53 <Cale> dm``: The entirely new trees thing is what makes the operations fast :)
21:43:54 <p_l> kmc: Erlang/OTP is also used in realtime conditions
21:43:56 <Nereid_> collisions are rare if you use a good hash function have enough free space in the hash table
21:43:59 <ksf> hash maps _don't_ have O(1) insertion and lookup.
21:44:03 <kmc> Jane St. uses OCaml and i believe they've tweaked their implementation to largely avoid GC
21:44:04 <Nereid_> I said practically.
21:44:10 <ksf> ...their arrays have.
21:44:24 <Cale> dm``: When you create a new tree, you share any subtrees which the new tree has in common with the old one.
21:44:33 <ksf> whether you hash your key or traverse a tree based on that tree doesn't really matter.
21:44:52 <ksf> ...with the difference that trees don't collide.
21:44:57 <Cale> dm``: and so, for example, updating an element only requires constructing as many nodes as the path from the element to the root
21:45:00 <dm``> Cale:  correct in the sense that if I had to copy my tree each time in C++, that would be O(n).  But often I'm using maps in a tail-recursive function call or something where I don't really care that I'm creating a new map, I just have to because of the particular semantics of Haskell.
21:45:24 <Cale> dm``: The operations on maps are designed to make that fast.
21:45:28 <p_l> kmc: ITA Software said that they simply avoid creating garbage, thus no need for GC to run :)
21:45:34 <kmc> dm``, DiffArray is good in that use case.  Does Map do something similar?
21:45:34 <Cale> dm``: The trees share structure with one another.
21:45:36 <kmc> aha
21:46:15 <p_l> kmc: that, plus some hacks for certain datastructures that they wanted to have direct control over (like giant, mmaped "database")
22:00:30 <ksf> , length dict
22:00:33 <lunabot>  479830
22:00:40 <ksf> that's a giant, mmaped database.
22:00:45 <ksf> , dict
22:00:47 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
22:01:34 <jfoutz> , drop 100000 dict
22:01:36 <lunabot>  ["debitumenize","debituminization","debituminize","deblai","deblaterate",...
22:01:48 <jfoutz> , last dict
22:01:50 <lunabot>  "ZZZ"
22:02:11 <ksf> , sort dict
22:02:15 <lunabot>  ["&c","'d","'em","'ll","'m","'mid","'midst","'mongst","'prentice","'re","...
22:02:59 <ksf> ...and we're not even working on the original bytestrings.
22:03:16 <jfoutz> , last $ sort dict
22:03:22 <lunabot>  Killed.
22:03:26 <jfoutz> hehehe
22:04:54 <kmc> > filter ("hask" `isInfixOf`) dict
22:04:57 <lambdabot>   Not in scope: `dict'
22:05:04 <kmc> , filter ("hask" `isInfixOf`) dict
22:05:08 <lunabot>  ["Burushaski","Chaska","hask","haskard","haskness","haskwort","hasky","Kh...
22:05:27 <ksf> unlining is done with bytestrings, though.
22:05:58 <ski> , filter ("hask" `isPrefixOf`) dict
22:05:58 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
22:06:01 <lunabot>  ["hask","haskard","haskness","haskwort","hasky"]
22:06:04 <ski> @messages
22:06:05 <lambdabot> Philonous1 said 2d 10h 21m 6s ago: Here's the junction code, if you're still interested. I cleaned it up somewhat and added a monad interface: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9083#
22:06:05 <lambdabot> a9083
22:06:07 <kmc> , filter ((== 1) . length) dict
22:06:11 <lunabot>  Killed.
22:06:59 <kmc> , filter (\x -> case x of { [_] -> True; _ -> False }) dict
22:07:01 * ski thought he had already got that message
22:07:02 <lunabot>  ["2","A","a","B","b","C","c","D","d","E","e","F","f","G","g","H","h","I",...
22:07:17 <kmc> , concat $ filter (\x -> case x of { [_] -> True; _ -> False }) dict
22:07:18 <hackagebot> dbmigrations 0.1 - An implementation of relational database "migrations" (JonathanDaugherty)
22:07:20 <lunabot>  "2AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"
22:07:56 <kmc> , concat $ filter (\x -> case x of { [_,_] -> True; _ -> False }) dict
22:08:00 <lunabot>  "2D3D3M4H-aA.a'a-a.A1a1A4A5AAaaABAbabACAcacADAdadAEaeAFAfafAGAgagAHAhahAI...
22:08:47 <ski> , filter (\word -> elem (reverse word) dict) dict
22:08:52 <lunabot>  Killed.
22:09:10 <kmc> , filter (\x -> x == (reverse x)) dict
22:09:11 <ski> , filter (\word -> word == reverse word) dict
22:09:14 <lunabot>  ["2","A","a","AA","aa","AAA","aaa","AAAA","AAAAAA","ABA","aba","abba","ac...
22:09:16 <lunabot>  ["2","A","a","AA","aa","AAA","aaa","AAAA","AAAAAA","ABA","aba","abba","ac...
22:09:22 <ski> (:
22:09:30 <kmc> , last $ sortBy (comparing length) $ filter (\x -> x == (reverse x)) dict
22:09:33 <lunabot>  luna: Not in scope: `comparing'
22:10:01 <kmc> , last $ sortBy (\a b -> compare (length a) (length b)) $ filter (\x -> x == (reverse x)) dict
22:10:05 <lunabot>  "tat-tat-tat"
22:10:16 <ski> , 'dict
22:10:17 <lunabot>  Luna.Words.dict
22:10:49 <kmc> , last $ sortBy (\a b -> compare (length a) (length b)) $ filter (all isAlpha) $ filter (\x -> x == (reverse x)) dict
22:10:53 <lunabot>  "kinnikinnik"
22:11:11 <ray> =o
22:11:20 <kmc> lunabot has TH?
22:11:32 <ksf> @wn kinnikinnik
22:11:35 <ray> lunabot has some TH
22:11:35 <lambdabot> No match for "kinnikinnik".
22:11:47 <ski> , [$ty| False |]
22:11:50 <lunabot>  Bool
22:13:02 <kmc> ski, is that a quasiquote?
22:13:09 <kmc> i don't remember regular TH quotes looking like that
22:13:15 <kmc> , ty
22:13:16 <lunabot>  luna: No instance for (GHC.Show.Show
22:13:21 <ski> , help
22:13:23 <lunabot>  type of an expression:      , [$ty| \x -> x |]
22:13:23 <lunabot>  get info for a type/class:  , src ''Monad
22:13:23 <lunabot>  get info for a var/con:     , src 'fix
22:13:23 <kmc> , typeOf ty
22:13:25 <lunabot>  Language.Haskell.TH.Quote.QuasiQuoter
22:13:30 <kmc> aha!
22:13:38 <kmc> , typeOf src
22:13:39 <lunabot>  luna: No instance for (Data.Typeable.Typeable
22:13:49 <ski> , [$ty| ty |]
22:13:50 <kmc> , [$ty| src ]
22:13:52 <lunabot>  luna: lexical error in string/character literal at end of input
22:13:52 <lunabot>  QuasiQuoter
22:13:57 <kmc> , [$ty| src |]
22:13:57 <ski> , [$ty| src |]
22:13:59 <lunabot>  Name -> Doc
22:14:00 <lunabot>  Name -> Doc
22:14:06 <kmc> ah, clever
22:14:26 <kmc> is this a distinct codebase from lambdabot
22:14:41 <ski> yes
22:14:57 <ski> , intercalate " " $ filter (\x -> case x of { [_,_] -> True; _ -> False }) dict
22:15:00 <lunabot>  "2D 3D 3M 4H -a A. a' a- a. A1 a1 A4 A5 AA aa AB Ab ab AC Ac ac AD Ad ad ...
22:16:47 <kmc> ,src 'src
22:16:50 <lunabot>  src :: Name -> Doc
22:16:55 <kmc> , src 'map
22:16:57 <ksf> , src ''Monad
22:16:58 <lunabot>  map :: forall a b . (a -> b) -> [a] -> [b]
22:17:00 <lunabot>  class Monad m where
22:17:00 <lunabot>          (>>=) :: forall b a . m a -> (a -> m b) -> m b
22:17:00 <lunabot>          (>>) :: forall b a . m a -> m b -> m b
22:17:15 <kmc> no return?
22:17:20 <kmc> , src 'return
22:17:22 <lunabot>  Class op from Monad: return :: forall m . Monad m => forall a . a ->
22:17:22 <lunabot>                                                                  m a
22:18:35 <kmc> , src ''[]
22:18:37 <lunabot>  data [] a = [] | a `(:)` ([a])
22:19:05 <kmc> , src ''IO
22:19:08 <lunabot>  newtype IO a = IO (State# RealWorld -> (#,#) (State# RealWorld) a)
22:19:25 <ksf> so how do I get instance Monad IO?
22:19:56 <kmc> what is (#,#)? type of unboxed 2-tuples?
22:21:01 <inbuninbu> question for you guys... i've been writing an assembler, and have run into the following problem... i can do what i need to do in do-style notation, but would like a nice way to clean it up... so for example...
22:21:46 <kmc> inbuninbu, do you have a code paste
22:21:46 <inbuninbu> i've got one instruction that takes a memory address: b = string "b">>space>>liftM (b'.read) (many1 digit)
22:21:57 <inbuninbu> this works great
22:22:28 <inbuninbu> but when i get to more complicated instructions, i need to use sepBy to separate arguments with commas
22:23:07 <kmc> inbuninbu, Parsec's sepBy?
22:23:17 <inbuninbu> kmc: yes, it's parsec
22:23:38 <inbuninbu> i've looked at liftA, and related functions... but i'm stuck with a list when using sepBy... and (<*>) doesn't seem applicable either
22:24:29 <inbuninbu> i can get around it with do notation like so:
22:24:31 <inbuninbu> bc = do
22:24:31 <inbuninbu>   string "bc"
22:24:31 <inbuninbu>   space
22:24:31 <inbuninbu>   bo <- iLit
22:24:32 <inbuninbu>   char ','
22:24:32 <inbuninbu>   bi <- iLit
22:24:34 <inbuninbu>   char ','
22:24:36 <inbuninbu>   ta <- iLit
22:24:38 <inbuninbu>   return $ bc' bo bi ta
22:24:42 <ksf> ouch.
22:24:43 <kmc> @paste
22:24:43 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:24:44 <ksf> @where hpaste
22:24:45 <lambdabot> http://hpaste.org/
22:24:57 <inbuninbu> ah right, thanks
22:25:17 <kmc> inbuninbu, you should be able to abstract that yourself, even if it's not ready-made in Parsec or Control.Applicative
22:26:06 <inbuninbu> kmc: ok, thanks, guess i'll poke at it some more :-)
22:27:13 <kmc> inbuninbu, you want to parse a fixed-size comma-separated list?
22:27:24 <inbuninbu> kmc: yes
22:27:28 <kmc> sepBy isn't really the right tool for that, I think
22:27:47 <inbuninbu> *light bulb goes on*
22:28:16 <inbuninbu> kmc: thanks... is seems obvious now :-)
22:28:56 <kmc> heh, sorry i'm not sure what the right tool is
22:29:03 <ksf> [bo, bi, ta] <- sepBy ',' iLit?
22:29:17 <ksf> if it's more than three, the pattern match, and thus the parser, is going to fail.
22:29:36 <kmc> it depends, do you want to fail if it's longer, or just not consume the rest?
22:30:15 <inbuninbu> kmc: i think the answer is a custom combinator of some kind
22:30:24 <ksf> ...the second one would be bo:bi:ta:rest, and then pushing the rest back into the stream, which is, in general, dirty.
22:31:41 <ksf> (parsers shouldn't carry any state imnsho, anyway)
22:31:56 <ksf> it's always cleaner just to do multiple passes.
22:32:51 <ski> (ksf : yes, `(# State# RealWorld , a #)' is the type of unboxed pairs of values of type `State# RealWorld' respectively `a')
22:33:08 <kmc> ksf, how so? what about f n p = sequence (p : replicate (n-1) (char ',' >> p))
22:33:11 <ksf> kmc, you meant.
22:33:37 * ksf doesn't see any gets or puts there.
22:33:42 <kmc> ski, ah, (#,#) is a tycon?
22:33:47 <ski> @kind (# GHC.Base.State# GHC.Base.RealWorld , Bool #)
22:33:49 <lambdabot> (#)
22:33:53 <ksf> ...just like (,)
22:33:58 <kmc> @kind (#,#)
22:33:59 <lambdabot> ? -> ? -> (#)
22:34:03 <ski> @kind (# , #) (GHC.Base.State# GHC.Base.RealWorld) Bool
22:34:05 <lambdabot> (#)
22:34:05 <kmc> yeah
22:34:10 <ski> kmc : yes
22:34:12 <kmc> makes sense, thanks
22:34:30 <ski> @kind (# , #)
22:34:32 <lambdabot> ? -> ? -> (#)
22:34:45 <ski> .. *nod*
22:34:57 <kmc> and yes, it can be clearest to have an intermediate program rep before you check arity of built-ins
22:36:04 <ksf> ...note that you can parametrize parsec over both token type and stream type.
22:36:38 <ksf> so, in a second pass, you can match on a thing like Stmt Op [Arg]
22:37:16 <ksf> ...maybe enriching your built-in Op-dictionary with macro definitons beforehand.
22:37:56 <ksf> ...and not getting anything done because #haskell keeps on feature creeping your program.
22:38:17 <ski> `bc' doesn't always take the same number of arguments ?
22:38:47 <ksf> nah, but other statements might.
22:39:26 <ksf> and writing a parser for any statement, and then another pass that checks what's parsed based on an op table is cleaner than writing a gazillion parsers.
22:39:58 <inbuninbu> bc takes the same number of arguments; all the ops do, as this is (risc) assembly
22:40:01 <ksf> ...it limits you in ad-hockery regarding syntax, but you can also see that as a feature.
22:40:11 <kmc> my f above works but feels hackish
22:40:20 <kmc> is there a function like map that skips the first elem
22:40:27 <ksf> inbuninbu, do also all your macros take the same number of arguments?
22:41:04 <kmc> ksf, i don't agree that it's cleaner, if you make a single combinatior "nArgParser" and just map it over your op table
22:41:07 <inbuninbu> ksf: it's not supporting macros at all... not thinking quite that far ahead :-)
22:41:31 <ksf> but... but... macros are an essential part of every assembler!
22:41:42 <ksf> nasm's macros are even turing-complete...
22:41:42 <kmc> just preprocess with M4 :)
22:41:53 <kmc> or, make your asm syntax a haskell EDSL
22:42:23 <inbuninbu> i ended up with this for now: bc = string "bc">>space>>op3 bc' iLit iLit iLit
22:42:31 <ski>   bc = bc' $> string "bc" <* space <*> iLit <* comma <*> iLit <* comma <*> iLit  -- hm .. something like this, maybe ?
22:42:35 <kmc> inbuninbu, you can abstract further
22:42:44 <ksf> > let foo f (x:xs) = x:map f xs in foo (+2) [1..8]
22:42:46 <lambdabot>   [1,4,5,6,7,8,9,10]
22:42:58 <kmc> ksf, is that foo built in anywhere
22:43:12 <ksf> I don't think so.
22:43:40 * ski still feels like the `Applicative' operators are not named appropriately
22:44:02 <inbuninbu> ski: ah! i missed <* entirely somehow
22:44:55 <ski> inbuninbu : you need to check whether the predecence and fixity of the operators in that is "right", though .. i can't remember off-hand whether they are
22:45:55 <inbuninbu> ski: thanks!
22:49:32 <ski> inbuninbu : you could further shorten `foo <* comma <*> bar' to a new operator .. maybe `foo &<*> bar' .. and maybe shorten `foo <* space <*> bar' to maybe `foo ~<*> bar'
22:50:07 <ski> (those operator names aren't very thought through .. you can probably invent better-looking ones yourself)
22:50:23 <SubStack> ><*> -- fishy
22:56:20 <kyagrd> So there's going to be left fishy and right fishy ... interesting
22:58:29 <Twey> Do we have a spaceship operator yet?
23:01:18 <Makoryu> :t (<=>)
23:01:19 <lambdabot> Not in scope: `<=>'
23:01:22 <Makoryu> Hmmm
23:01:30 <ray> we have kleisli rocketships
23:01:48 <Makoryu> @src Ord
23:01:48 <lambdabot> class  (Eq a) => Ord a  where
23:01:49 <lambdabot>     compare      :: a -> a -> Ordering
23:01:49 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
23:01:49 <lambdabot>     max, min         :: a -> a -> a
23:02:04 <Makoryu> @let (<=>) = compare -- Viola!
23:02:06 <lambdabot>  Defined.
23:02:09 * Makoryu plays a fiddle
23:02:15 <ray> world's tiniest viola
23:04:57 <Nereid_> @src (<=>)
23:04:57 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:05:02 <Nereid_> ok then
23:05:07 <Nereid_> > 1 <=> 2
23:05:11 <lambdabot>   LT
23:05:46 <Twey> Actually, I think (<=>) = signum
23:05:58 <Twey> In Perl, at least
23:08:18 <Twey> Er
23:08:38 <Makoryu> :t fromEnum . compare
23:08:40 <lambdabot> forall a. (Enum (a -> Ordering), Ord a) => a -> Int
23:08:45 <Twey> (signum .) . subtract
23:08:48 <Twey> :t (signum .) . subtract
23:08:50 <lambdabot> forall a. (Num a) => a -> a -> a
23:09:11 <Makoryu> > let (<=>) = fromEnum . compare in 5 <=> 4
23:09:14 <lambdabot>   Couldn't match expected type `t1 -> t'
23:09:19 <Twey> > (signum .) . subtract) 1 $ 2
23:09:21 <lambdabot>   <no location info>: parse error on input `)'
23:09:31 <Twey> > ((signum .) . subtract) 1 2
23:09:31 <Makoryu> Ohhhhhh
23:09:33 <lambdabot>   1
23:09:47 <Makoryu> > let (<=>) = (fromEnum .) . compare in 5 <=> 4
23:09:49 <Twey> Hm
23:09:49 <lambdabot>   2
23:09:51 <Twey> > ((signum .) . subtract) 2 1
23:09:53 <lambdabot>   -1
23:09:58 <Twey> That's backwards
23:10:12 <Makoryu> > let (<=>) = (- 1) . (fromEnum .) . compare in 5 <=> 4
23:10:15 <lambdabot>   No instance for (GHC.Num.Num ((a -> GHC.Types.Int) -> t -> a1))
23:10:15 <Twey> Makoryu: Ordering has three elements
23:10:15 <lambdabot>    arising ...
23:10:24 <Twey> > ((signum .) . flip subtract) 2 1
23:10:26 <Makoryu> Twey: Yep
23:10:27 <lambdabot>   1
23:10:31 <Twey> > ((signum .) . flip subtract) 1 2
23:10:33 <lambdabot>   -1
23:10:36 <Twey> There we go
23:10:38 <Twey> > ((signum .) . flip subtract) 1 1
23:10:40 <lambdabot>   0
23:10:53 <Makoryu> Bah...
23:11:18 <Twey> Makoryu: So fromEnum will cause 0, 1, 2 instead of -1, 0, 1
23:11:36 <Makoryu> @let x <=> y = case compare x y of LT -> -1; EQ -> 0; GT -> 1
23:11:37 <lambdabot>  <local>:7:2:
23:11:37 <lambdabot>      Multiple declarations of `L.<=>'
23:11:37 <lambdabot>      Declared at: <local>...
23:11:41 <Makoryu> @unlet
23:11:42 <Makoryu> @let x <=> y = case compare x y of LT -> -1; EQ -> 0; GT -> 1
23:11:42 <lambdabot>  Defined.
23:11:43 <Twey> Haha
23:11:43 <lambdabot>  <local>:8:2:
23:11:43 <lambdabot>      Multiple declarations of `L.<=>'
23:11:43 <lambdabot>      Declared at: <local>...
23:11:48 <Makoryu> >:|
23:12:03 <Twey> @undef
23:12:11 <Makoryu> @let x <=> y = case compare x y of LT -> -1; EQ -> 0; GT -> 1
23:12:12 <Twey> Damn, I always forget this command
23:12:13 <lambdabot>  Defined.
23:12:15 <Twey> Oh
23:12:18 <Twey> It was @undef.
23:12:31 <Makoryu> > 2 <=> 5
23:12:33 <lambdabot>   -1
23:12:36 <Makoryu> > 2 <=> 1
23:12:38 <lispy> ?instances ORD
23:12:39 <lambdabot> Couldn't find class `ORD'. Try @instances-importing
23:12:39 <lambdabot>   1
23:12:44 <Makoryu> > 2 <=> 2
23:12:46 <lambdabot>   0
23:12:47 <lispy> :t LT
23:12:49 <lambdabot> Ordering
23:12:51 <Twey> @undef
23:12:54 <lispy> ?instances Ordering
23:12:56 <lambdabot> Couldn't find class `Ordering'. Try @instances-importing
23:13:02 <Twey> @let (<=>) = (signum .) . flip subtract
23:13:03 <lispy> ?instances-importing Ordering
23:13:04 <lambdabot>  Defined.
23:13:05 <lambdabot> Couldn't find class `Ordering'. Try @instances-importing
23:14:29 <lispy> > let x <=> y = fromEnum (compare x y) - 1 in 1 <=> 2
23:14:31 <lambdabot>   -1
23:14:45 <lispy> > let x <=> y = fromEnum (compare x y) - 1 in 1 <=> 1
23:14:48 <lambdabot>   0
23:14:51 <lispy> > let x <=> y = fromEnum (compare x y) - 1 in 1 <=> 0
23:14:54 <lambdabot>   1
23:15:12 <lispy> ?pl \x y -> fromEnum (compare x y) - 1
23:15:12 <lambdabot> flip flip 1 . (((-) . fromEnum) .) . compare
23:17:55 <Twey> Eh what?
23:17:59 <Twey> flip flip 1?
23:18:07 <Makoryu> \O_o/
23:18:27 <ray> :t flip flip 1
23:18:28 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
23:18:32 <ray> prepare to have your mind blown
23:18:46 <ray> :t flip flip
23:18:47 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
23:19:05 <Twey> ((pred . fromEnum) .) . compare, surely
23:19:09 <Twey> ray: Woah!
23:19:17 <Twey> :
23:19:38 * ray shields himself from flying bits of brain
23:20:07 <Makoryu> :t flip flip id flip id id flip flip
23:20:09 <lambdabot> forall b a c. b -> (a -> b -> c) -> a -> c
23:20:13 <ray> i don't think pl is smart enough to convert - 1 into pred
23:20:24 <ray> that would require a specific rule at least
23:20:46 <Makoryu> :t flip flip flip
23:20:47 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
23:21:09 <ray> :t flip fmap flip fmap flip fmap flip
23:21:10 <lambdabot> forall a c (f :: * -> *) a1 b c1. (Functor f) => (a -> (f (a1 -> b -> c1) -> f (b -> a1 -> c1)) -> c) -> a -> c
23:21:40 <Makoryu> :t flip . (fmap flip `fmap` flip fmap)
23:21:42 <lambdabot> forall b a c a1. (a -> a1) -> b -> (a1 -> b -> c) -> a -> c
23:23:21 <ksf> Foreign.C.Set> (Foo `sappend` Bar)
23:23:21 <ksf> BitSet 6
23:23:30 <ksf> Foreign.C.Set> foo (Foo `sappend` Bar)
23:23:30 <ksf> [Foo,Bar,FooBar]
23:24:46 <ksf> it's a gazillion instances (including supposedly undecidable ones), but treating elements as sets works.
23:26:56 <ksf> ah, I forgot
23:26:58 <ksf> Foreign.C.Set> :t Foo
23:26:58 <ksf> Foo :: Flag
23:31:48 <Nereid_> anyone here use lhs2TeX much? I'm trying to display the operator <|> inline and want to write |<|>|, but that gets parsed in an undesirable way.
23:41:05 <Nereid_> aha
23:41:07 * copumpkin yawns
23:41:09 <Nereid_> I'm supposed to write |<||>|
23:41:23 <Phyx-> *yawn* morning
23:41:34 <Nereid_> *yawn* almost bedtime
23:41:34 <Nereid_> :P
23:41:55 <inbuninbu> ski,ksf,kmc: thanks for your help... i got it all the way down to: bc = mnem "bc">>bc'<$>iLit<.>iLit<.>iLit
23:41:55 * Phyx- was rudely woken up by the painter doing maintenence work outside
23:45:34 <reskljgjil> http://www.thaiadpoint.com/tap8.1/bin/redir.php?p=2022&l=1341&u_id=363435
23:46:55 <copumpkin> @where ops
23:46:55 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
23:47:05 --- mode: ChanServ set +o dibblego
23:47:17 --- kick: reskljgjil was kicked by dibblego (dibblego)
23:47:26 --- mode: dibblego set +b *!*n=78910@*.revip.asianet.co.th
23:47:30 <copumpkin> :)
23:47:30 --- kick: reskljgjil was kicked by dibblego (dibblego)
23:48:28 <Phyx-> ?
23:48:44 <Phyx-> ah
23:49:23 * Phyx- wonders what it means when UPS says your package has experience an exception... sounds code to me for "we lost it"
23:50:22 <purplepenguins> an exception?
23:51:27 --- mode: dibblego set -o dibblego
23:52:47 <Phyx-> purplepenguins: that's what it says
23:53:07 <purplepenguins> like on their package tracking site?
23:53:08 <Phyx-> quite literally says "Your package has experience an exception"
23:53:13 <purplepenguins> hahaha
23:53:30 <Phyx-> and then under that "UPS INTERNAL ACTIVITY"
23:53:35 <purplepenguins> "no route to host"
23:54:02 <ski> inbuninbu : using a little more space there would not be dangerous :)
23:54:09 <Phyx-> i'm calling for a refund! i payed for next day shipping!
23:54:18 <Phyx-> or rather, next day delivery
23:54:51 <wmealing_> Phyx-,  usually it means its been damaged, they can't read the handwriting, or for some reason it can't make it where it needs to go right now.
23:54:56 <wmealing_> ie, flood/fire/act of god.
23:55:41 <Phyx-> wmealing_: but it hasn't even left the shipping center..
23:56:14 <Phyx-> wmealing_: i would think they would call me if something was up?
23:56:15 <ski> force majeure
23:56:35 <wmealing_> Phyx-, did you put a return address on it ?
23:56:45 <wmealing_> with a PH# ?
23:56:54 <Phyx-> wmealing_: PH#?
23:57:11 <Phyx-> oh, phone number
23:57:13 <Phyx-> yes, i did
23:57:37 <Phyx-> for both sender and receiver
