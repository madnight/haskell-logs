00:00:11 <Beelsebob> and not many of them in the first itteration
00:00:16 <Gertm> I see
00:00:18 <Beelsebob> just the ones that *really* deffinately do work
00:00:54 <Cale> Gertm: So from a user standpoint, it's a little bit boring. It's more interesting for people who want books, or want to use features for a program they don't want to have to maintain.
00:01:24 <Gertm> So I don't need to worry about it?
00:01:39 <Cale> Probably the GHC user's guide is more interesting for now :)
00:01:39 <Gertm> I just don't want to learn an 'old' version just to have to unlearn stuff later.
00:01:51 <Cale> Oh, don't worry too much in that regard.
00:02:00 <Cale> Things which might go away are pretty limited.
00:02:14 <Cale> The monomorphism restriction, probably.
00:02:23 <Cale> Maybe n+k patterns will go away.
00:02:35 <Gertm> The what now? Nvm, I'll make sure I get the basics first.
00:03:03 <Cale> It's just an annoying type system rule which is a misfeature and never should have been included in Haskell 98.
00:03:09 <int-e> is anything going to happen about unary minus?
00:03:15 <Cale> int-e: I hope not.
00:03:25 <Cale> I think unary minus is perfect as it is.
00:03:25 <dazza_> how do i know if i need to make an ad-hoc polymorphic function or a parametric one?
00:03:40 <Cale> dazza_: ad-hoc?
00:03:45 <Beelsebob> Gertm: both of the things he mentioned there are just very minor details that probably won't bite you until you know the language well enough to be looking at haskell prime anyway
00:03:46 <Cale> dazza_: What language?
00:03:52 <dazza_> HSKL
00:04:14 <int-e> Well, I'd like -1 to be fromInteger (-1) rather than negate (fromInteger 1).
00:04:31 <Cale> int-e: hmm...
00:04:43 <Gertm> Beelsebob: ok :) I just wanna write apps in a functional way, no crazy stuff here.
00:04:45 <Cale> int-e: That's an interesting point. I wonder how much that affects things.
00:05:06 <Gracenotes> int-e: what, you got any really weird num instances? -_-
00:05:13 <Beelsebob> Gertm: you'll have no problems by learning H98 then :)
00:05:19 <Cale> Haskell doesn't have ad-hoc polymorphism. Perhaps you're thinking of typeclasses?
00:05:25 <dazza_> e.g a function to sticking something on the end of a list. (doesnt matter what type).
00:05:37 <Cale> dazza_: That would be parametric polymorphism
00:05:44 <Cale> [a] -> a -> [a]
00:06:02 <dazza_> i was thinking a -> [a] -> [a]
00:06:05 <Cale> You don't care at all what type of elements the list has.
00:06:08 <Cale> Yeah, same thing :)
00:06:13 <int-e> Gracenotes: not really, it's an optimization issue, not a semantical issue.
00:06:22 <ray> :t flip
00:06:24 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
00:06:27 <Cale> (well, not really the same thing, but...)
00:06:38 <ray> isomorphic?
00:06:42 <int-e> Gracenotes: with a few small exceptions
00:07:05 <int-e> > -2147483648 :: Int
00:07:05 <Gracenotes> typeclasses can have both inclusion polymorphism and parametric polymorphism, in different aspects.. they are rather neat..
00:07:09 <dazza_> but this dont work.. glue a list = (list:a)
00:07:10 <lambdabot>   -2147483648
00:07:24 <int-e> that works, but it really involves two overflows to get there.
00:07:31 <Cale> dazza_: right...
00:07:33 <Gracenotes> 3:[2,1] -> [3,2,1]
00:07:42 <int-e> hmm. should be Int32 :)
00:07:58 <Cale> dazza_: That doesn't add it to the end of the list, it treats 'list' as the element to stick on to 'a'
00:08:09 <Gracenotes> imagine the list going off to the right, and the beginning being to the left.
00:08:16 <Peaker> @hoogle Buffer
00:08:16 <lambdabot> System.IO data BufferMode
00:08:16 <lambdabot> System.IO BlockBuffering :: Maybe Int -> BufferMode
00:08:16 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
00:08:27 <Cale> glue a [] = [a]; glue a (x:xs) = x : (glue a xs)
00:09:01 <Gertm> Another question: Is it my impression, or is Haskell harder to 'learn by doing'? Cos I honestly don't have a clue where to start writing my little app.
00:09:20 <Cale> Gertm: It's more like learning your first programming language :)
00:09:24 <Peaker> Gertm: Learning by doing is the only real way of learning :)
00:09:41 <Cale> Gertm: It's not bad to learn by doing, but it helps to read things and ask questions too :)
00:10:01 <Gertm> When I learned lisp, I quickly had something useful running. Can't do that now. Haskell does fascinate me a lot more though.. Must persevere!
00:10:02 <dazza_> dude i have been using it for 2 months , and i can do a few things.... 2 months ago i didnt know what sum[1..10] was
00:10:05 <Cale> Gertm: Starting with very simple things is a good plan.
00:10:19 <Peaker> Gertm: what are you trying to write?
00:10:32 <Gertm> Peaker: my new hello world app: a twitter client
00:11:02 <Cale> Gertm: Well, there are some packages on Hackage which can help, depending on where you want to start from.
00:11:34 <Peaker> Gertm: well, doing web client stuff is horrid in any language...
00:11:44 <Cale> (Including a twitter api, though you might be more interested in doing it from http upward)
00:11:46 <Gertm> Cale: Well I guess I want to start from  scratch, but use libs for json and http access
00:12:53 <dazza_> thanks Cale.
00:13:23 <Cale> http://hackage.haskell.org/package/HTTP -- this package is decent for making HTTP requests, and scales to fairly complicated things rather well.
00:15:01 <ski> > iterateSR (State (randomR (0,999))) `runReader` mkStdGen 72259417435 :: [Int]
00:15:05 <lambdabot>   [957,707,834,485,880,726,834,719,71,331,693,587,147,142,382,207,412,244,702...
00:15:13 <Gertm> thanks Cale
00:15:51 <Cale> There are also a couple of JSON libraries... I'm not really all that familiar with any of them, but I've played around with 'json' a bit, and it seemed okay.
00:17:44 <Cale> Gertm: Have you learned how basic I/O works in Haskell?
00:17:47 <absentia> I wrote my own JSON parser in C++ .. for the learning experience.  I want to do the same with Haskell.. when I get better with the language.
00:19:09 <wmealing_> Quick question, would the haskell in osx  have sqlite support ?
00:19:42 <nlogax> isn't json a subset of yaml, so you can use yaml libs as well?
00:19:44 <Gertm> Cale: I can read/write a file, I get how stuff like return and <- work, so I guess so.
00:19:48 <wmealing_> alternatively, is there something else i should be using ?
00:19:59 <Cale> wmealing_: There are sqlite bindings which ought to be cross platform, but I don't have an OSX machine.
00:20:22 <|Steve|> OS X, not OSX.
00:20:38 * wmealing_ isnt big on apple branding.
00:20:57 * dazza_ just ate granny smith ... xD
00:21:08 <|Steve|> Not a grannysmith?
00:21:20 <Stinger> a GrannySmith (TM)
00:21:26 <nlogax> ohh, shiny
00:22:11 <ksf> do we have unicode bytestrings, by now?
00:22:49 <Cale> |Steve|: It's their fault for using an acronym in the first place. If they wanted me to write the space, they should have called it Operating System Ten, or whatever. :)
00:22:53 <Stinger> isnt that somewhat of an oxymoron?
00:22:59 <wmealing_> Cale, noticed people talking about building it on windows, i thought there might have been another package i should have installed.
00:23:11 <|Steve|> It's not an acronym.
00:23:20 <Cale> |Steve|: OS is an acronym.
00:23:39 <|Steve|> It's an initialism.
00:23:50 <Cale> |Steve|: and since X is a number which is part of the name, it's natural to write it without a space there.
00:23:51 <wmealing_> I'm sorry i brought it up
00:24:02 <quicksilver> Cale: OSX is actually pronounced as four words
00:24:21 <|Steve|> Oh es ten is four words?
00:24:22 <Stinger> "that bsd rip off"?
00:24:25 <Cale> wmealing_: You'll need the C library, naturally.
00:24:38 <Stinger> *ducks*
00:25:10 <Cale> wmealing_: (since it's a binding)
00:25:22 <dazza_> C is a terrible name for a language.
00:25:23 <wmealing_> Cale, yep.
00:25:30 <Cale> wmealing_: But if that works, you should be fine.
00:25:44 <|Steve|> dazza_: Would "3" be better?
00:26:03 <dazza_> I was thinking anything longer than char x = 'c'
00:26:06 <wmealing_> Cale, i'll attempt to build it tonight, just thought someone might be able to save me time/effort/sanity
00:26:08 <dazza_> C even
00:26:21 * Cale resolves to pronounce OSX as "ossix" from now on, just to irritate Apple fans ;)
00:26:31 <Elly> that irritates apple fans?
00:26:34 <wmealing_> i say it like os sex... but thats just me.
00:26:48 <Elly> all the apple fans I know say that
00:26:50 * Hunner thinks they prefer "Oh Ess Ten"
00:26:57 <Elly> just like nobody says 'SCSI' as 'Ess Cee Ess Eye'
00:27:04 <wmealing_> i actually say it like that.
00:27:10 <abbe> Oh! Sex
00:27:11 <generic> me too
00:27:17 <Stinger> same
00:27:19 <wmealing_> scussie, sounds too much like  "excuseme"
00:27:21 <Cale> "scuzzy"
00:27:37 <dazza_> i just call it scussy but i prefer sas pronounced sas because it sounds sassu
00:27:39 <Stinger> I say lots of words funny, cause I read them before I heard them and it stuck
00:27:43 <wmealing_> me too
00:27:45 <absentia> ok
00:27:46 <absentia> gimme sec
00:27:52 <dibblego> OS is not an acronym, it's an initialism
00:28:03 <Adamant> "OS Ten" is correct, but everyone who's not an Apple addict says "OS Echkks"
00:28:04 * Pseudonym hugs dibblego, he knows the difference
00:28:22 <ksf> mhhh http://hackage.haskell.org/package/compact-string
00:28:43 <ksf> http://hackage.haskell.org/package/text
00:28:53 <|Steve|> dibblego: <|Steve|> It's an initialism.
00:28:59 * Pseudonym wonders if compact-string supports entropy-compressed strings
00:29:03 <dibblego> missed it
00:29:05 <wmealing_> for us uninformed peasants, what is the difference between initialism and an acronym ?
00:29:19 <|Steve|> An acronym is pronounced as a word. E.g., laser.
00:29:31 <Pseudonym> And an initialism isn't, e.g. GHC.
00:29:46 <Pseudonym> Hugs = acronym, GHC = initialism.
00:29:47 <Hunner> so is "TLA" an initializm or an acronym?
00:29:56 <|Steve|> initialism.
00:29:57 <Hunner> :D
00:30:08 <wmealing_> so the definition depends if you speak it , or spell it.
00:30:21 <Cale> That seems like a pointless distinction to me.
00:30:24 <Pseudonym> It's if you pronounce it as if it were a word.
00:30:26 <generic> GNU is an acronym
00:30:36 <generic> actually it can be both
00:30:46 <Pseudonym> Cale: The distinction is important, because an acronym is part-way to being a full-fledged word.
00:30:47 <nlogax> SQL? :)
00:30:53 <generic> nlogax: yeah
00:30:57 <Pseudonym> Physicists talk about a "lasing medium".
00:31:16 <wmealing_> well, i've learned something today.
00:31:16 <dancor> http://en.wikipedia.org/wiki/Acronym#Nomenclature
00:31:24 <ivanm> Pseudonym: so if you say "ors" for OS, it _is_ an acronym? ;-)
00:31:24 * Hunner always says Ess Que Ell
00:31:31 * nlogax too
00:31:37 * ivanm three
00:31:38 <generic> now we have to event a new word to accomodate for acronym/intialism words :/
00:31:49 <int-e> abbreviation
00:31:55 <Pseudonym> ivanm: I pronounce "IBM" as "throat-warbler-mangrove", so that could be an acronym.
00:32:08 <nlogax> took me a while before i even knew what that sequel thing was. not at all obvious when you don't speak english :)
00:32:19 <generic> int-e: you just ruined all my fun :(
00:32:26 <int-e> INTERCAL is the best acronym of them all.
00:32:31 <Cale> I consider an initialism as being a type of acronym.
00:32:49 <ivanm> Pseudonym: heh
00:32:54 <Pseudonym> Cale, most people consider it to be the other way around.
00:33:01 <Pseudonym> Or that they are both types of abbreviation.
00:33:07 <|Steve|> Mostly because it is the other way around.
00:33:23 <dancor> @unpl (.) . (.)
00:33:23 <lambdabot> (\ i b c f -> i (b c f))
00:33:26 <Pseudonym> "Initialism" isn't a standard term, IIRC.
00:33:30 <saynte> I prefer to just not use the word initialism, because I like being understood.
00:33:43 <int-e> ("Compiler Language With No Pronounceable Acronym", which is, for obvious reasons, abbreviated "INTERCAL".)
00:33:59 <dancor> are the variables not a b c d because of some internal optimization?
00:34:14 <nlogax> int-e: :D
00:34:15 <Cale> saynte: yeah.
00:34:20 <int-e> dancor: yes.
00:34:24 <Pseudonym> The key point is that an acronym is a word that also happens to be an abbreviation.
00:34:32 <dancor> @unpl (.) . (.) . (.)
00:34:32 <lambdabot> (\ l b c f i -> l (b c f i))
00:34:33 <Pseudonym> If it's not a word, it's not an acronym.
00:34:44 <int-e> @unpl (.)
00:34:45 <lambdabot> (\ a b c -> a (b c))
00:34:47 <dancor> @unpl (.) . (.) . (.) . (.)
00:34:47 <lambdabot> (\ o b c f i l -> o (b c f i l))
00:34:56 <Cale> Pseudonym: but initialisms are words
00:35:04 <dancor> @unpl (.) . (.) . (.) . (.) . (.)
00:35:04 <lambdabot> (\ r b c f i l o -> r (b c f i l o))
00:35:05 <generic> @unpl (.)(.)
00:35:05 <lambdabot> (\ b c e f -> b c (e f))
00:35:08 <Cale> (as far as I'm concerned)
00:35:13 <generic> be3bbz
00:35:19 <dancor> is there a faster way for me to get past z
00:35:20 <int-e> with 5 dots, you use a b c, d e f, g h i, j k l, and m n o.
00:35:24 <tessier> lex-pass allows you to automate changes to a php codebase, by writing
00:35:25 <Cale> They're just words which happen to be pronounced in a particularly systematic way :)
00:35:25 <tessier> abstract-syntax-tree transformers in haskell.
00:35:31 <tessier> Bwahahaha...that's just priceless!
00:35:37 <dibblego> XML is not a word. radar is a word. XML is an initialism. Radar is an acronym
00:35:38 <dancor> tessier: uh huh
00:35:41 <tessier> I'm going to start advocating this to all of my PHP using friends.
00:35:46 <Cale> dibblego: XML is a word.
00:35:59 <dibblego> it can't be, because it's an initialism :)
00:36:04 <int-e> a word is a sequence of letters.
00:36:17 <int-e> a finite one. sorry.
00:36:19 <dancor> i'm rewriting the parser so that it includes the lexing instead of doing that with php
00:36:24 <tessier> XML is a perfectly cromulent acronym.
00:36:33 <Stinger> hah
00:36:33 <saynte> I prefer to call it "10 ML"
00:36:45 <Stinger> not 10 1000 50?
00:36:51 <Pseudonym> saynte: Or to put it another way, two teaspoons?
00:36:55 * tessier wonders if XML is a valid Roman numeral
00:36:55 <saynte> No no, it's a version of ML, that's obvious!
00:36:56 <dancor> because then i can mod the language more easily
00:37:05 <Cale> Not 1040?
00:37:07 <int-e> Oh it's a malformed 1040.
00:37:11 <saynte> Pseudonym, just blew my mind man.
00:37:13 <generic> wow can we get off the pronounciation?
00:37:23 <dancor> @unpl (.) . (.) . (.) . (.) . (.) . (.)
00:37:23 <lambdabot> (\ u b c f i l o r -> u (b c f i l o r))
00:37:26 <dancor> @unpl (.) . (.) . (.) . (.) . (.) . (.) . (.)
00:37:27 <lambdabot> (\ x b c f i l o r u -> x (b c f i l o r u))
00:37:29 <dancor> @unpl (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)
00:37:30 <lambdabot> (\ aa b c f i l o r u x -> aa (b c f i l o r u x))
00:37:31 <dancor> yay
00:37:35 <int-e> generic: we got off that and right into numerology. not sure which one is better :)
00:37:37 <generic> o.0
00:37:42 * Cale puts "word" into the OED search box and clicks the "Find Word" button.
00:38:04 <generic> -.
00:38:10 <generic> ^-.-
00:38:14 <Cale> It's like they're *reading my mind*!
00:38:16 <dancor> what is the shortest thing you can put into @unpl to get a var over z out
00:38:20 <Pseudonym> Cale: So what you're saying is that what I call an initialism is a type of word that breaks the normal rules of pronunciation.
00:38:30 <Cale> Pseudonym: yes.
00:38:38 <dancor> @unpl \ aa -> aa
00:38:38 <lambdabot> \ aa -> aa
00:38:42 <Cale> Pseudonym: As if there are actually rules of pronunciation :P
00:38:46 <Pseudonym> Well, there are.
00:38:52 <|Steve|> Why are you redefining words?
00:38:54 <Pseudonym> For example, there is one syllable per vowel sound.
00:38:57 <int-e> @unpl (
00:38:57 <lambdabot> Unbalanced parentheses
00:38:59 <Beelsebob> @unpl (fmap (fmap (fmap (fmap (fmap (fmap (fmap fmap fmap) fmap) fmap) fmap) fmap) fmap) fmap)
00:38:59 <lambdabot> (fmap (fmap (fmap (fmap (fmap (fmap (fmap fmap fmap) fmap) fmap) fmap) fmap) fmap) fmap)
00:39:00 <dancor> @unpl \ a z -> a z
00:39:00 <lambdabot> \ a z -> a z
00:39:03 <Stinger> @unpl fix ((.) . (.))
00:39:03 <lambdabot> fix (\ i b c f -> i (b c f))
00:39:09 <int-e> @unpl \a a a -> a a a
00:39:09 <lambdabot> \ a a a -> a a a
00:39:20 <quicksilver> In my experience the word 'initialism' is used exclusively by pedants and only ever occurs in really boring conversations where someone corrects someone else who said acronym. I therefore propose that initialism, as a word, is a solely negative entity and we should expunge it.
00:39:20 <Peaker> @unpl fix
00:39:20 <lambdabot> fix
00:39:30 <dancor> @unpl f.f where f = ((.).(.))
00:39:30 <lambdabot>  Parse error at "where" (column 5)
00:39:43 <Beelsebob> quicksilver: heh, nice argument
00:39:45 <Pseudonym> Except that it has a positive connotation, quicksilver.
00:39:49 <Peaker> quicksilver: you just said the I word!
00:39:59 <Beelsebob> Peaker: now you said it
00:40:00 <dancor> In
00:40:04 <Peaker> Beelsebob: I took care not to
00:40:05 <Beelsebob> argh! now I said it!
00:40:09 <Beelsebob> I said it again
00:40:11 <Pseudonym> It refers to a nonzero set of linguistic units.
00:40:12 <Beelsebob> >.>
00:40:22 <ivanm> @forget initialism
00:40:23 <lambdabot> Incorrect arguments to quote
00:40:24 <ivanm> ;-)
00:40:31 <Pseudonym> non-null, I guess
00:40:35 <dancor> let's talk about the meaning of bikeshed again
00:40:45 <Pseudonym> In what sense do you mean "semantics"?
00:40:59 <Stinger> what confusion was there about what bikeshed meant?
00:41:04 <dibblego> In my experience, aversion to what is correct nomenclature only ever occurs because of negative reasons, I therefore propose we all harden up and accept it
00:41:05 <Beelsebob> dancor: bikeshed: an obstruction big enough to kiss behind
00:41:14 <dancor> dirty!
00:41:14 <tessier> "Newbies talk about syntax, professional programmers talk about semantics..."
00:42:22 * Hunner thinks there is a difference between professional programmers and who you meant to refer to
00:42:23 <Stinger> academics talk about obscure category theory constructions *ducks*
00:42:27 <Pseudonym> So, lexical syntax of comments.  Good or bad?
00:42:29 * Hunner argues semantics
00:42:53 <saynte> I don't like cats.
00:43:03 <Beelsebob> Hunner: I hate that phrase "you're just arguing semantics"
00:43:13 <Beelsebob> ... yes... that's the *interesting* bit of the conversation
00:43:29 <Beelsebob> why would I have an argument, if not trying to find out what you mean
00:43:40 <Hunner> Beelsebob: but it solves so many problems, or at least brings up where the tension is being created if in fact it truely is semantics
00:43:41 <Cale> Beelsebob: Well, sometimes an argument is meant to be more than about what the words used to carry the argument about mean individually.
00:44:31 <Pseudonym> Many arguments do hinge on semantics, though, in the sense that the disagreement rests entirely on different senses of words.
00:44:39 <Beelsebob> Cale: yeh, what I mean is that the phrase is inaccurate... people mean that you're being petty when they say it, not that you're arguing about the meaning of the discussion
00:45:12 <Hunner> Beelsebob: In fact, I think most of the world considers argueing to occur with both parties referring to the same thing.
00:45:22 <shachaf> Beelsebob: Stop arguing semantics.
00:45:32 <Beelsebob> :P
00:46:00 <Cale> Pseudonym: Like earlier, when we didn't agree on what the word 'word' meant.
00:46:14 <dancor> > length "(.).(.).(.).(.).(.).(.).(.).(.)"
00:46:16 <Beelsebob> lol, I want to hear the competing definitions now
00:46:17 <lambdabot>   31
00:46:22 <Pseudonym> A word is 64 bits on my machine.
00:46:24 <Beelsebob> dancor: wow, you have 31 boobies!
00:46:32 <dancor> i demand a recount
00:47:21 <ski> 6
00:47:24 <dancor> @unpl (((((((.).).).).).).)
00:47:25 <lambdabot> (\ i l o r u x aa b c -> i l o r u x aa (b c))
00:47:26 * int-e suggests watching http://www.youtube.com/watch?v=kQFKtI6gn9Y instead of arguing.
00:47:31 <Cale> > length "let x = (.).(.).(.).(.) in x.x"
00:47:33 <dancor> > length "(((((((.).).).).).).)"
00:47:35 <lambdabot>   30
00:47:37 <lambdabot>   21
00:47:40 <dancor> owned
00:47:42 <dancor> in real time!
00:49:04 <Cale> dancor: hm?
00:51:21 <Pseudonym> Fare well.
00:52:14 <dancor> it's a joke about 21 < 30
00:53:20 <dancor> in my one-man contest to minimize the length of an @unpl input the produces an implicit variable beyond z
00:56:49 <Stinger> #unpl let x = (.) in x
00:56:53 <Stinger> @unpl let x = (.) in x
00:56:54 <lambdabot> let { x a b c = a (b c)} in x
00:57:18 <mmorrow> @. pl unpl let x = (.) in x
00:57:18 <lambdabot> (line 1, column 5):
00:57:18 <lambdabot> unexpected "{"
00:57:18 <lambdabot> expecting "()", natural, identifier or "in"
00:57:26 <Stinger> @unpl let x = (.).(.) in x.x.x.x
00:57:26 <lambdabot> let { x i b c f = i (b c f)} in (\ l -> x (x (x (x l))))
00:57:49 <dancor> code golf lambda edition
00:58:26 <dancor> code golf "You're not just limited to Perl either - PHP, Python and Ruby are all available too."
00:59:03 <dancor> i feel so free with that kind of choice of similar languages
00:59:48 <mmorrow> @@  @pl @run (text . filter (not.(`elem`"{}"))) (@show @(unpl let x = (.) in x))
00:59:51 <lambdabot>  (.)
01:02:25 <mmorrow> @unpl let x = x in x
01:02:26 <lambdabot> let { x = x} in x
01:02:37 <mmorrow> @pl let x = x in x
01:02:37 <lambdabot> fix id
01:02:42 <mmorrow> heh, nice
01:02:57 <mmorrow> @unpl fix id
01:02:58 <lambdabot> fix (\ a -> a)
01:08:19 <Peaker>  @unpl doesn't know "fix" :(
01:11:02 <purplepenguins> @pl \a \b -> gcd a b == 1
01:11:03 <lambdabot> (line 1, column 4):
01:11:03 <lambdabot> unexpected "\\"
01:11:03 <lambdabot> expecting operator, pattern or "->"
01:11:15 <purplepenguins> @pl \a b -> gcd a b == 1
01:11:16 <lambdabot> flip flip 1 . ((==) .) . gcd
01:11:36 <ray> flip flip 1 should be its own combinator
01:12:54 <doserj> > let f = ((==1) .) . gcd in f 3 5
01:12:58 <lambdabot>   True
01:15:23 <Nereid_> @pl \a b c -> f (g a b c)
01:15:23 <lambdabot> ((f .) .) . g
01:19:21 <Nereid_> hmm, that generalizes sort of neatly
01:19:34 <Nereid_> @unpl \f g -> f . g
01:19:34 <lambdabot> \ f g c -> f (g c)
01:19:46 <Nereid_> @unpl \f g -> ((.)) f . g
01:19:46 <lambdabot> \ f g h c -> f (g h c)
01:19:51 <Nereid_> @unpl \f g -> ((.) . (.)) f . g
01:19:51 <lambdabot> \ f g k c h -> f (g k c h)
01:19:56 <Nereid_> @unpl \f g -> ((.) . (.) . (.)) f . g
01:19:57 <lambdabot> \ f g n c h k -> f (g n c h k)
01:20:43 <Nereid_> @unpl \f g -> ((.) . (.) . (.) . (.)) f . g
01:20:43 <lambdabot> \ f g q c h k n -> f (g q c h k n)
01:20:55 <Nereid_> bye
01:21:33 <Nereid_> @unpl \f g -> (id) f . g
01:21:34 <lambdabot> \ f g d -> f (g d)
01:22:00 <ray> @. pl unpl fmap.fmap
01:22:00 <Nereid_> or even
01:22:00 <lambdabot> fmap . fmap
01:22:08 <Nereid_> @. pl unpl fmap fmap fmap
01:22:08 <lambdabot> fmap fmap fmap
01:22:48 <Nereid_> or
01:22:49 <Nereid_> ohhh
01:22:58 <Nereid_> @unpl ((.) . (.) . (.))
01:22:58 <lambdabot> (\ l b c f i -> l (b c f i))
01:23:03 <Nereid_> etc
01:23:42 <Nereid_> even nicer.
01:23:50 <ksf> shouldn't <$> have lower fixity than *> ?
01:24:07 <Nereid_> and of course, composing zero (.)s is id, which is just application
01:25:08 <Nereid_> ksf: then which fixity should <*> have? that of <$>, or that of *> ?
01:25:49 <Nereid_> probably <$>
01:26:05 <ksf> in between?
01:26:10 <Nereid_> possibly
01:26:21 <Nereid_> but if <*> has lower fixity than <$>
01:26:38 <ksf> the point is that singleLineComment = Comment <$> (string "//" *> (many $ noneOf lineTerminators)) has two parens too much.
01:26:41 <ski> ksf : thinking of `foo <$> bar *> baz' ?
01:26:44 <Nereid_> then f <$> x <*> y would parse like f <$> (x <*> y), and not behave like liftA2 f x y
01:27:26 <opqdonut> i think they both behave in an application-like manner on purpose
01:27:37 * ksf somehow expects <$> to behave like $, that is "bracket to the end of the expression"
01:27:46 <ski> this goes back to the debate of whether `$' should be left- or right- associative, i guess
01:27:50 <ksf> ...I know that's not what $ does, but it just works that way.
01:28:01 <Nereid_> wait
01:28:03 <Nereid_> wait.
01:28:08 * ski is on the "left" side
01:28:15 <Nereid_> lower = less tightly binding
01:28:18 <Nereid_> I got it mixed up. :(
01:28:41 <ksf> though >> should be "end of the exrpession", too.
01:29:03 <ksf> (but then I guess I could use applicative just a bit more)
01:29:08 <Nereid_> ok I'm really gone, bye
01:30:15 <ksf> ...and I don't want many to give me a [Char], but a Text.
01:31:52 <ksf> gragh.
01:32:05 <ksf> manyAccum could really use a monoid instead of list interface.
02:22:56 <ivanm> is "type parameter" the correct term for the 'a' in "Maybe a" ?
02:26:32 <Saizan_> that's what i've always seen used
02:29:05 <quicksilver> "type variable" ?
02:29:28 * ksf finally decided that parsec's "try" is a bad thing.
02:30:10 <ksf> ...the point is that you can't easily tell whether stuff gets consumed or not while combining parsers.
02:30:23 <Saizan_> yeah, type parameter refers to how the 'a' is used in Maybe a, type variable is independent instead
02:30:30 <ksf> e.g. many anyChar vs. string "foo"
02:31:13 <ivanm> Saizan_, quicksilver: *nod*
02:31:37 <ksf> one says "Maybe is parametrized over a" with "data Maybe a = Nothing | Just a", though.
02:31:45 <quicksilver> ksf: yes, non-composability sucks.
02:32:02 <ivanm> so if I want to say that my datatype now allows a custom ID value rather than being a fixed Int value, "type variable" would be the correct phrase?
02:32:33 <ksf> ...it's in fact virtually the only kind of bug you get while doing the half-banana job of converting BHNF into parsec.
02:32:51 <ksf> ...or whatever is the right term.
02:32:57 <Saizan_> i'd use type parameter there
02:32:59 <ksf> I never cared for LAR and stuff.
02:32:59 <dazza_> is there a prelude sort functon?
02:33:06 <ivanm> heh, so I was right the first time
02:33:07 <ksf> :t sort
02:33:11 <lambdabot> forall a. (Ord a) => [a] -> [a]
02:33:12 <benmachine> @index sort
02:33:12 <lambdabot> Data.List
02:33:13 <ksf> @hoogle sort
02:33:14 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
02:33:14 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
02:33:14 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
02:33:30 <ksf> , sort dict
02:33:32 <ivanm> sort your bytestrings out! :p
02:33:35 <lunabot>  ["&c","'d","'em","'ll","'m","'mid","'midst","'mongst","'prentice","'re","...
02:33:47 <ksf> @src sort
02:33:47 <lambdabot> sort = sortBy compare
02:33:54 <ksf> @src sortBy
02:33:54 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
02:34:03 <ksf> insertion sort?
02:34:04 <ivanm> , show dict
02:34:06 <lunabot>  "[\"1080\",\"10-point\",\"10th\",\"11-point\",\"12-point\",\"16-point\",\...
02:34:10 <Saizan_> that's not the definition in the standard libraries
02:34:11 <ivanm> heh
02:34:16 <ivanm> what is dict?
02:34:17 <ksf> ...I hope the libs use mergesort...
02:34:17 <Saizan_> it's just the haskell report definition
02:34:22 <Saizan_> they do
02:34:27 <ksf> /usr/share/dict
02:34:30 <dazza_> what file is sort in? Data.List?
02:34:31 <ivanm> ahhh
02:34:38 <ksf> bytestring-mmaped into lunabot.
02:34:46 <ivanm> hmmm.... what kind of a word is "'ll" ?
02:34:53 <benmachine> dazza_: yeah (if I'm being picky it's not a file it's a module)
02:34:53 <mmorrow> (/usr/share/dict/words)
02:34:57 <mmorrow> ;)
02:35:00 <ivanm> heh
02:35:16 <Saizan_> @source Data.List
02:35:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
02:35:22 <ksf> files and modules.
02:35:27 <mmorrow> , rnf dict `seq` ()
02:35:31 <lunabot>  ()
02:35:38 <benmachine> well Data.List isn't a file, Data/List.hs is :P
02:35:38 <mmorrow> , length dict
02:35:40 <lunabot>  479830
02:35:48 <ksf> why can't I have a file Foo/Bar.Baz and have it be "module Foo.Bar.Baz"?
02:36:03 <ksf> also, wat about "module relative Baz"?
02:36:07 <mmorrow> ksf: because ghc would asplode
02:36:14 <ksf> ...java does the same.
02:36:16 <dazza_> take . away.
02:36:18 <mmorrow> brains splattered all over the wall
02:36:20 <dazza_> . means directory
02:36:22 <mmorrow> it wouldn't be pretty
02:36:41 <benmachine> mmorrow: ghc's brains?
02:36:50 <ksf> that'd be olegs.
02:36:55 <ksf> ghc is implemented in oleg.
02:36:56 <mmorrow> benmachine: splattered all over teh wall, yes
02:36:58 <mmorrow> :)
02:43:26 <etpace_> :t guard
02:43:28 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
02:44:13 <ksf> hmmm is there a magic vim command that lets me layout a list to fit into 80 columns?
02:44:22 <ksf> currently, it's spread over umpteen lines.
02:45:14 <hackagebot> graphviz 2999.5.0.0 - GraphViz bindings for Haskell. (IvanMiljenovic)
02:45:53 <lilac> ksf: gg079l^VG$d
02:46:05 <lilac> that might not do what you want ;-)
02:46:15 <jungehexe> morning
02:46:18 <ksf> ...otoh, I think I'd rather leave them as they are.
02:46:26 <mmorrow> ksf: i use hstidy
02:46:32 <mmorrow> for that kind of thing
02:46:59 <ksf> block-layout makes spotting things as ""int" is a prefix of "interface" so it bleeding shouldn't be matched first" easier
02:47:04 <ksf> er harder.
02:47:04 <mmorrow> ksf: http://moonpatio.com/repos/derive-gadt/tools/hstidy.hs
02:47:23 <mmorrow> especially nice with formatting output of `show'
02:47:27 <ksf> ...my syntax is so clean you could eat off it.
02:47:52 <mmorrow> yum
02:48:01 <benmachine> I can imagine using something like :s/(.{70,}) /\1^M/
02:48:20 <benmachine> but that is a. cheating b. unreliable and c. you still have to do it once every line
02:48:41 <benmachine> oh hey :s/(.{,80}) /\1^M/ would make more sense
02:48:46 <benmachine> where ^M is ctrl-v ctrl-m
02:50:23 <benmachine> :s/\v(.{,80})( |$)/\1^M/g try that maybe
02:50:39 <benmachine> well, that seems to work if it's already all on one line
02:50:46 <benmachine> which I think you could achieve with something like umm
02:51:02 <benmachine> shift-J?
02:51:34 <benmachine> ksf: ^ all those things
02:52:01 <benmachine> J is join lines apparently
02:52:02 <benmachine> who knew
02:52:08 <benmachine> a lot of people
02:52:29 <benmachine> but I wasn't one of them until I accidentally pressed caps lock and then tried to go downwards
02:52:43 <Botje> benmachine: you could just restrict vim itself to 80 cols
02:53:00 <benmachine> how?
02:53:04 <Botje> :set textwidth 80
02:53:08 <benmachine> oh
02:53:09 <benmachine> k
02:53:16 <Botje> err
02:53:18 <Botje> :set textwidth=80
02:53:22 * benmachine helps
02:53:27 <benmachine> looks nice, thanks
02:53:30 <Botje> possibly followed by a q (format) command
02:54:33 <SamB_XP> benmachine: no, Botje helps, *you* are helped
02:54:49 <benmachine> I :help
02:54:57 <benmachine> and sometimes I do help!
02:54:57 <SamB_XP> :-P
02:55:03 <benmachine> maybe I was making a general statement
02:55:11 <benmachine> just to remind everyone
02:55:12 <SamB_XP> right!
02:55:30 <SamB_XP> I think lambdabot is the only one who forgot :-P
02:56:46 * benmachine finally learns what recording mode does
02:59:27 * ivanm didn't forget, because he never knew that in the first place...
02:59:29 <ivanm> ;-)
02:59:39 <lilac> the format command is gq in normal mode btw
02:59:48 <lilac> normal? visual? hmm
03:00:24 <benmachine> gq{motion}
03:00:31 <lilac> v_gq
03:00:57 * lilac looks down and gets an uneasy feeling that he's not actually in #vim
03:01:06 <SamB_XP> lilac: heh
03:01:18 <lilac> hey everyone, let's write a fibonacci function!
03:01:23 <benmachine> :D
03:01:25 <SamB_XP> lol
03:01:30 <SamB_XP> lilac: no nead
03:01:32 <SamB_XP> er. need
03:01:36 <lilac> > fix((0:).(1:).ap(zipWith(+))tail)
03:01:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:01:43 * lilac feels much better now
03:01:46 <SamB_XP> we let the Evolution page do it for us a zillion times already
03:02:11 <SamB_XP> lol
03:02:14 <ivanm> what was that really cool one that someone (dons?) posted once involving scanl and fix show ?
03:02:40 <SamB_XP> woah, that does sound cool
03:02:47 <benmachine> > fix show
03:02:51 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
03:03:09 <ivanm> > map length . group . sort $ fix show
03:03:13 <ivanm> ^^ something like that...
03:03:24 <SamB_XP> ivanm: that can't be it ;-)
03:03:24 <lambdabot>   thread killed
03:03:26 <ivanm> come on lambdabot... you can do it!
03:03:28 <benmachine> you can't sort it that doesn't work
03:03:37 <ivanm> oh, right, just group
03:03:41 <ivanm> > map length . group $ fix show
03:03:52 <lilac> isn't that just powers of 2?
03:03:56 <benmachine> minus 1
03:03:56 <lambdabot>   thread killed
03:03:57 <benmachine> iirc
03:04:01 <ksf> what's the reverse of J?
03:04:09 <ksf> ...er, well...
03:04:22 <lilac> [1,1,3,1,7,1,15,1,...]?
03:04:53 <benmachine> > map length . group . take 100 $ fix show
03:05:10 <lambdabot>   [1,1,1,3,1,7,1,15,1,31,1,37]
03:05:15 <ivanm> yeah, that's not it... but I'm pretty sure someone once posted it to -cafe to lighten the mood or something in a thread that was barrelling along towards a flame war...
03:05:19 <benmachine> how dull
03:05:23 <benmachine> oic
03:05:23 <ksf> :s/, /\r,/g
03:05:26 <ksf> ...\r!
03:05:38 <benmachine> ksf: I use ctrl-v ctrl-m
03:05:44 <benmachine> or ctrl-v enter
03:05:58 <benmachine> but maybe \r works too for some surreal reason
03:06:26 <ksf> ...well, \n inserted funny \@ characters.
03:07:00 <lilac> ksf: yeah, vim switches over newline and null for obscure reasons
03:07:08 <dazza_> > [x > fst(xs) | x <- take 1 [1,5], xs <- drop 1 [1,5]]
03:07:09 <ksf> ...and wtf does file tell me that my source is java?
03:08:04 <lambdabot>   thread killed
03:08:08 <dazza_> Fail
03:08:29 <benmachine> dazza_: fst operates on tuples?
03:08:39 <lilac> ksf: yeah, vim switches over haskell and java for obscure reasons
03:08:46 <benmachine> and, take 1 returns a list
03:09:03 <benmachine> hmm no a list is right
03:09:11 <dazza_> so how to take the first item in (x:xs) of xs
03:09:18 <lilac> head
03:09:20 <benmachine> xs is a singleton though
03:09:25 <benmachine> yes head
03:09:32 <benmachine> xs is 5
03:09:38 <benmachine> not [5]
03:09:39 <lilac> xs is [x]
03:09:49 <benmachine> 'tisn't
03:09:50 * lilac is fail
03:09:54 <dazza_> xs is [5] not (5)
03:10:05 <benmachine> well it is in (x:xs)
03:10:08 <lilac> simultaneous and distinct thinko and typo ;)
03:10:22 <benmachine> xs <- drop 1 [1,5] makes xs become 5
03:10:26 <benmachine> due to <-
03:10:53 * quicksilver things dazza_ doesn't really want a list comprehension at all.
03:11:08 <lilac> > [x > xs | x <- take 1 [1,5], xs <- drop 1 [1,5]]
03:11:21 <Stefa1> > scanl (*) 1 [1..5]
03:11:25 <benmachine> > text "I'm still alive"
03:11:27 <lilac> @bot
03:11:28 <lunabot>  :o
03:11:31 <benmachine> eep.
03:11:42 <Stefa1> @src scanl
03:11:50 <benmachine> @please wake up
03:11:56 <quicksilver> , let (x:xs) = [1,5] in x > head xs
03:11:57 <lunabot>  False
03:12:05 <lilac> @so you see you can't be dead Neo, because i love you
03:12:08 <quicksilver> ^^ I think that, maybe, is what dazza_ wanted?
03:12:20 <dazza_> i got what i needed now.
03:12:24 <Stefa1> >:t scanl
03:12:32 <Stefa1> :(
03:12:32 <etpace_> > fix ((1:) . scanl (+) 0)
03:12:39 <benmachine> , let (x:y:_) = [1,5] in x > y
03:12:40 <dazza_> isgreater (x:xs) = x > head(xs)
03:12:40 <lunabot>  False
03:12:41 <lilac> is ">:t" angry type-of?
03:12:50 <lambdabot> :)
03:12:50 <lambdabot> scanl f q ls = q : case ls of
03:12:50 <lambdabot>     []   -> []
03:12:50 <lambdabot>     x:xs -> scanl f (f q x) xs
03:12:50 <lambdabot> Not enough privileges
03:12:51 <Stefa1> :p
03:12:52 <lambdabot> you see you can't be dead Neo, because i love you not available
03:13:00 <lambdabot>   [False]
03:13:00 <lambdabot>   [1,1,2,6,24,120]
03:13:00 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
03:13:00 <lambdabot>   I'm still alive
03:13:02 <lilac> dazza_: isgreater (x:y:xs) = x > y
03:13:04 <benmachine> lolwat
03:13:21 <etpace_> , fix ((1:) . scanl (+) 1)
03:13:22 <lunabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:13:32 <Beelsebob> @please wake up
03:13:32 <lambdabot> Not enough privileges
03:13:40 <benmachine> heh
03:13:42 <lilac> @so , 1 + 1
03:13:42 <lambdabot> , 1 + 1 not available
03:13:43 <lunabot>  luna: Not in scope: `available'
03:13:46 <lilac> yay
03:14:01 <lilac> @please op me
03:14:01 <lambdabot> Not enough privileges
03:14:38 <benmachine> @so , let available = True in
03:14:38 <lambdabot> , let available = True in not available
03:14:39 <lunabot>  False
03:15:12 <ivanm> @slap lilac
03:15:12 <lambdabot> go slap lilac yourself
03:15:16 <lilac> @so , text "hello" --
03:15:16 <lambdabot> , text "hello" -- not available
03:15:17 <lunabot>  luna: parse error (possibly incorrect indentation)
03:16:30 * benmachine has an idea
03:17:37 <vurlssi> @so ACTION does silly things
03:17:38 <lambdabot> ACTION does silly things not available
03:17:46 <benmachine> hm, nearly
03:18:45 <quicksilver> @help so
03:18:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:18:48 <quicksilver> @so
03:18:48 <lambdabot>  not available
03:18:51 <quicksilver> what is it?
03:18:54 <benmachine> no idea
03:18:58 <benmachine> discovered by chance
03:19:13 <benmachine> oh
03:19:16 <benmachine> @so fix
03:19:17 <lambdabot> fix not available
03:19:24 <benmachine> oh wait
03:19:29 <benmachine> @so Data.List
03:19:29 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
03:19:32 <benmachine> there we go
03:19:38 <benmachine> [urce]
03:20:29 <quicksilver> ah
03:21:29 <benmachine> @ghc
03:21:30 <lambdabot> ghc says: Unable to mmap( MAP_FIXED ) for Jump Islands
03:21:57 <dons> dcoutts: http://www.scribd.com/doc/19563536/The-Birth-of-the-Industrial-Haskell-Group-CUFP-2009
03:22:15 <dons> dcoutts: to embed in wordpress, [scribd id=19563536 key=key-1j646z265fvm0dp24uak]
03:24:50 <lilac> @docs foo
03:24:51 <lambdabot> foo not available
03:26:28 <lilac> @ghc unsafeCoerce
03:26:28 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
03:26:44 <SamB> seriously?
03:27:10 <lilac> @ghc 28
03:27:10 <lambdabot> ghc says: strange object 28
03:28:16 <lilac> ok, so now i want to make some kind of puzzle game where all the text is ghc error messages
03:29:01 <FunctorSalad> @help ghc
03:29:02 <lambdabot> ghc. Choice quotes from GHC.
03:29:25 <pozic> dons: why do you use scribd? If someone wants to download the PDF, they have to register.
03:31:21 <dons> because the slides can be embedded in a blog and viewed with minimal overhead
03:31:46 <dons> meaning == more readers, particularly those who don't like .pdf
03:32:45 <pozic> dons: ok, and doing both is not worth the trouble for you?
03:34:52 <RayNbow> pozic: if you open a scribd page, there is a Document Information section
03:35:07 <RayNbow> dons has posted pdf links there
03:35:23 <pozic> RayNbow: ah, great.
03:35:43 <RayNbow> or at least on the scribds I saw so far
03:35:43 <mmorrow> @ghc infinite kind
03:35:44 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
03:35:52 <SamB> maybe he should put those PDF links in the blog posts as well ;-)
03:36:09 <mmorrow> i didn't even think it's possible to get that error msg
03:36:30 <SamB> some people just loathe scribd so much they will never see those links
03:38:13 <RayNbow> SamB: that might be because it used to be a CPU hog
03:38:37 * RayNbow has just tested a scribd page on an old laptop... CPU usage seems to be lower nowadays
03:38:52 <SamB> RayNbow: no, I'm pretty sure it's because it keeps turning up in their google results when they wanted either a real webpage or a PDF ...
03:39:30 <pozic> Evince seems to start PDFs instantly here, so I don't mind PDF. On Windows, it might be different.
03:39:34 <RayNbow> SamB: ah, that too
03:40:06 <pozic> The concept of using a "webapp" for something which already works perfectly is foreign to me.
03:41:14 <RayNbow> pozic: on my newer laptop, Adobe launches pretty fast, so I don't mind pdfs either
03:41:51 <pozic> RayNbow: uncached?
03:42:01 <RayNbow> hmm...
03:42:16 * RayNbow tries...
03:42:19 <RayNbow> about 3 seconds
03:42:29 * RayNbow has just rebooted after installing updates
03:42:47 <RayNbow> but usually I never shutdown my laptop
03:42:53 * RayNbow prefers hibernation :p
03:43:20 * pozic prefers that too. Too bad Ubuntu decided to break that out of nothing. It used to work fine.
03:43:31 <dons> pozic: i always post the original .pdf or whatever document
03:44:19 <SamB> pozic: well, if scribd has a widget, that could of course be useful for embedding in blog posts
03:44:55 <dazza_> how the hell do you find and take the longest sorted list from a list?
03:45:32 <pozic> dazza_: I doubt that's the real question. :)
03:45:41 <dazza_> i mean from an unsorted list.
03:45:53 <pozic> dazza_: you forgot to add the qualifier in O(f(n)) time with some nice f.
03:45:54 <dazza_> how the hell do you find and take the longest sorted list from an unsorted list?
03:46:02 <pozic> dazza_: asking questions is hard.
03:46:03 <SamB> though nowhere near as much better for that than just linking a PDF as flash-based video sites are relative to AVI files ;-)
03:46:13 <Zao> dazza_: Your client seems to inject profanity into your messages.
03:46:20 <dazza_> sorry.
03:46:40 <pozic> SamB: +1
03:46:42 <SamB> I mean, AVI files have that whole "okay, now where do I get *that* codec" thing ;-)
03:47:13 <pozic> SamB: er -1. You prefer Flash to AVI?!?!
03:47:48 <RayNbow> er... people still use AVI? :p
03:48:06 <RayNbow> can't we move on and use mkv and mp4? :p
03:48:30 <SamB> pozic: well, it has advantages
03:48:51 <idnar> RayNbow: for the things it is possible to use AVI for, why not use it?
03:48:58 <SamB> and youtube, at least, offers a non-flv download of each video, does it not?
03:49:08 <pozic> By AVI I thought you meant some downloadable video, instead of AVI specifically.
03:49:21 <pozic> SamB: no, but youtube-dl does.
03:49:22 <idnar> SamB: not that I know of
03:49:26 <Cale> Hmm... that's interesting. I'm reading slides from a Japanese talk about Haskell, and one of the slides has a diagram on it with names of programming languages scattered about, and I immediately recognised it, because I remember making an extremely similar diagram for someone here... :)
03:49:29 <idnar> youtube-dl just downloads the flv
03:49:35 <dazza_> Well what I want to do is take a list of integers and return the longest sorted sequence of the list as a smaller list
03:49:36 <SamB> yeah, I basically meant "video container X"
03:49:45 <ivanm> Cale: sure it's not your diagram? ;-)
03:49:53 <Cale> (It's a rough scatter plot of languages where the axes are OO-ness and FP-ness)
03:49:53 <pozic> idnar: yes, and you can play it with mplayer, so who cares?
03:49:56 <idnar> Google Videos used to provide a non-flv download for some videos, but I think that got lost when it was folded into Youtube, although ICBW
03:50:06 <SamB> where said container most likely allows files in codecs you don't have ;-)
03:50:14 <Cale> It's not directly my diagram, the font is different at least.
03:50:17 <SamB> idnar: hmm?
03:50:28 <ivanm> Cale: heh
03:50:30 <jaj> youtube-dl --get-url "$1" | xargs mplayer
03:50:33 <jaj> idnar: -b
03:50:59 <jaj> --best or -b downloads the .mp4
03:51:06 <RayNbow> idnar: well, if you can use AVI, sure, use it... but certain codecs cannot be used in AVI (well, you can use h264 in AVI, but it's hacky)
03:51:37 <SamB> well, okay, even if they don't offer non-.flv, mplayer can still play .flv, right ?
03:51:52 <koala_man> yes
03:51:55 <jaj> SamB: they do offer non-flv and mplayer can play flv
03:52:25 <SamB> jaj: where do you click to find it?
03:52:34 <SamB> on, say, http://www.youtube.com/watch?v=9fohXBj2UEI ?
03:52:45 <jaj> to find the .flv?
03:52:53 <SamB> the non-flv
03:52:56 <jaj> I just use youtube-dl
03:53:05 <SamB> heh
03:53:20 * RayNbow uses keepvid for generating download links
03:53:26 <SamB> oh, is that what the "HQ" button plays?
03:53:57 <RayNbow> http://keepvid.com/save-video.mp4?http%3A%2F%2Fv8.lscache2.c.youtube.com%2Fvideoplayback%3Fip%3D0.0.0.0%26sparams%3Did%252Cexpire%252Cip%252Cipbits%252Citag%252Cburst%252Cfactor%26itag%3D18%26ipbits%3D0%26signature%3D46A59BAB7A85AD5CF294D26CF95D496C06CE8451.0AABA16729F3AE976432C5A1DA8927C15544C315%26sver%3D3%26expire%3D1252515600%26key%3Dyt1%26factor%3D1.25%26burst%3D40%26id%3Df5fa215c18f65042 <-- MP4, 40.8 MB
03:54:02 <RayNbow> ah crap, long link...
03:54:08 <ivanm> SamB: I would have that that HQ would just be a better quality flv...
03:54:12 <ivanm> RayNbow: heh
03:54:20 <SamB> dunno
03:54:40 <jaj> http://www.pastebin.org/16406 first url is .flv, second one is .mp4
03:54:41 <SamB> but why would youtube-dl be able to grab something you can't access using the website ?
03:55:11 <jaj> SamB: you have to parse the js to retrieve the url
03:55:40 <SamB> jaj: still, I'm assuming it must be in the javascript for a reason
03:55:45 <jaj> you can read youtube-dl it's a simple python scripty
03:55:54 <SamB> the javascript must use it at some point, no?
03:56:47 <jaj> well they generate a temporary hash which is part of the url IIRC
03:57:15 <Jafet> youtube-dl does only what the javascript code would have done to retrieve the video data.
03:57:18 <Jafet> (It is lazy!)
03:57:48 <SamB> so, I guess flash can play .mp4 nowadays?
03:58:03 <Jafet> Flash is not a media player
03:58:07 <jaj> you get the .mp4 inside the flash player when you click the HQ button
03:58:29 <pozic> Why does threadDelay have such a specification? Why doesn't it do the sane thing and say that the thread will be scheduled promptly?
03:58:34 <Jafet> (Why the hell are we talking about this here?)
03:59:17 <jaj> http://www.openbsd.org/cgi-bin/cvsweb/ports/net/yt/files/yt.lua?rev=1.24 this lua script does the same as the python script but is easier to understand
03:59:31 <SamB> Jafet: er, tangent from scribd ;-)
03:59:54 <dons> dcoutts' slides on the birth of the industrial haskell group, http://www.reddit.com/r/programming/comments/9irn5/the_birth_of_the_industrial_haskell_group_cufp/
04:00:25 <SamB> Jafet: and Flash provides a media-playing API of some kind to Flash programs
04:00:29 <pozic> The birth of dcoutts. ................ The start of the universe.
04:00:38 <koala_man> pozic: it's probably hard for haskell to control the scheduling of other unrelated processes?
04:01:22 <pozic> koala_man: you mean that it cannot make guarantees about the OS it is running on?
04:01:42 <pozic> koala_man: then it should say: depending on the OS it might do this or that.
04:01:56 <SamB> pozic: also, the RTS' own schedular is only invoked either (a) after a certain amount of allocation or (b) when a thread blocks on something
04:02:17 <pozic> SamB: right, I think it is referring to that and that's a huge bug, imho.
04:02:28 <SamB> pozic: yeah, it is rather a bug
04:02:42 <pozic> SamB: computation and allocation are not the same and they both take up time.
04:02:50 <SamB> opinions differ on how huge, I think, but it's a tricky one to squash afaict
04:02:57 <SamB> you've seen the ticket lately?
04:03:03 <pozic> No
04:03:10 <SamB> feel free to chime in on how you think it should be solved ;-)
04:03:13 <pozic> I have seen it befor, though.
04:03:16 <pozic> before*
04:03:54 <pozic> The correct solution is probably too slow, that is, the naive solution I have in my mind right now.
04:04:30 <lefant> hi
04:04:42 <lefant> i am trying to solve the SBANK problem on spoj.pl
04:04:42 <SamB> pozic: that's why I say it's not easy to solve ;-)
04:04:43 <lefant> https://www.spoj.pl/problems/SBANK/
04:04:56 <lefant> but it says it is too slow
04:05:01 <lefant> i have tried a lot of stuff
04:05:10 <lefant> so i wonder if someone has any hints
04:05:14 <lefant> code is here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3542#a3542
04:05:16 <n8dawg> hi all, this is my first time on Haskell IRC
04:05:33 <n8dawg> I had a question about functional data structures
04:05:43 <koala_man> pozic: it does say that
04:06:39 <n8dawg> basically I need to build some code in Java, but I'd like to write it in a functional way
04:07:06 <koala_man> have you looked at scala?
04:07:09 <n8dawg> I need a list which supports fast prepend and append operations
04:07:24 <n8dawg> well the code is to run in the browser using GWT
04:07:30 <n8dawg> so unfortunately that rules out scala
04:07:30 <koala_man> ah
04:07:50 <n8dawg> so is there a good reference on functional data structures?
04:07:58 <pozic> koala_man: what's the bug nr?
04:08:16 <Cale> n8dawg: There's Okasaki's book and thesis
04:08:31 <pozic> n8dawg: Data.Sequence does that.
04:08:40 <pozic> n8dawg: no reason why you cannot implement that in Scala.
04:08:44 <Cale> n8dawg: For a fast sequence structure, finger trees are really cool (and are what's behind Data.Sequence)
04:09:12 <pozic> n8dawg: splay trees also work, but they have a nastier interface.
04:09:18 <n8dawg> interesting
04:09:18 <dibblego> n8dawg, that doesn't rule out Scala and a fast prepend/append list is available in Scalaz
04:09:33 <n8dawg> i can;'t use scal as i'm writing for the browser in GWT
04:09:45 <dibblego> that doesn't follow
04:10:08 <n8dawg> The GWT compiles Java code to JavaScript so it runs in the browser
04:10:13 <n8dawg> that limits me to Java code
04:10:21 <koala_man> pozic: I mean I read "not guaranteed" as "might or might not, depending"
04:10:28 <dibblego> Scala -> bytecode -> Java -> Javascript :)
04:10:53 <dibblego> Functional Java has dons' DList iirc
04:10:57 <pozic> koala_man: I don't like a language with cross-your-fingers semantics.
04:11:41 <dazza_> > let list = [5,3,7,12,13,15,9,12,7] in [a | a <- takeWhile ((head list) > (head (tail list))) list]
04:11:45 <lambdabot>   Couldn't match expected type `t -> GHC.Bool.Bool'
04:11:49 <pozic> If an API function can be implemented with x = x, then it is a bad API function.
04:11:52 <n8dawg> dibblego: Unfortunately it doesn't work like that, it compiles java source not bytecode.
04:12:04 <koala_man> pozic: you don't cross your fingers. if it matters, you assume the worst
04:12:11 <dibblego> n8dawg, that's what I meant, you can "compile" bytecode to source code quite easily
04:12:34 <pozic> koala_man: right, so, there is no way to do threadDelay, unless you change the RTS yourself, at which point it is PozicHaskell, and not Haskell.
04:12:48 <Cale> n8dawg: Another approach is to do various things where you store the front of the list in forward-order, and the end of the list in reverse order, and try to balance them when they get too far out of balance.
04:13:05 <Cale> (there are different approaches to when to do the balancing)
04:13:26 <dibblego> Functional Java has a finger tree but not DList -- should change that
04:13:43 <n8dawg> whats the diff between a finger tree and a DList?
04:13:43 <Cale> http://hackage.haskell.org/package/queuelike -- you might look at some of the source code for these.
04:14:05 <dibblego> different algorithmic of operations
04:14:10 <dibblego> *algorithmic complexity
04:14:14 <Cale> DList is just for fast concatenation...
04:14:40 <n8dawg> well basically I will want to have fast operations for the following
04:15:09 <n8dawg> remove n first, remove n last, add to front, add to back
04:15:11 <Cale> Basically, difference lists mean replacing lists with functions that add elements to the beginning of lists, and then composition of those functions (which is constant time) is concatenation.
04:15:40 <Cale> and when you're done concatenating, you apply the whole thing to an empty list to get back to a normal list
04:16:13 <koala_man> pozic: unless you have rt scheduling, yes. making everything rt by default isn't fun
04:17:49 <kowey> I'm looking for a Haskeller who can whip up a nice CSS/design for a patch tracker
04:17:54 <n8dawg> sounds like I need to go and investigate finger trees and dlists as my two best candidates :)
04:18:10 <Yoric> hi
04:18:11 <Cale> Finger trees are a funny sort of variation on a 2-3 tree, and can be adapted to provide many different fast data structures: sequences, maps, priority queues, interval trees, etc.
04:18:18 <lefant> to summarize my SBANK problem: one has to count how many times individual unique lines of input appear and output a sorted count. there are up to 500.000 lines total. i am reading them in as a lazy bytestring and after splitting the lines i fold them into a data.map with the line as the key using data.map.interactwith'. it takes around 5 seconds on my machine, but is still too slow for spoj. i really don't see where i could still go faster... -
04:18:31 <lefant> i would really welcome any further hints
04:18:41 <Yoric> Quick question: is there a way to (de)serialize a function?
04:18:53 <Cale> n8dawg: But it sounds like you just want a functional queue
04:18:55 <quicksilver> Yoric: quick answer is no
04:19:08 <Yoric> quicksilver, ok, that's what I suspected.
04:19:17 * Yoric was wondering how to (de)serialize closures.
04:19:33 <Cale> n8dawg: If you had an implementation of finger trees, I would recommend using that, but given that you don't, and that you're going to use Java... I'm not sure that would be my own first approach.
04:19:41 <lilac> Cale: does a fingertree have to be based on a 2-3 tree? i thought 2-3 fingertrees were a certain sort of fingertree
04:20:02 <MarcWeber> Yoric: Which use case? You have to store the data explicitely
04:20:21 <Yoric> MarcWeber, no use case yet.
04:20:27 <Yoric> Just wondering idly.
04:21:04 <Cale> lilac: Well, I suppose it doesn't have to be a 2-3 tree, but that's the only variety that the paper described.
04:22:40 <lilac> Cale: hmm. i wonder if there'd be any compelling advantage to other types of trees (i'd guess not, but...)
04:22:45 <Cale> lilac: The important thing is that you take some measure to lift up the ends of the tree so that operations on either end become fast.
04:23:27 <lilac> right. i guess i was wondering, does it make sense to have, for instance, red-black fingertrees?
04:23:28 <Cale> lilac: and you make extensive use of the monoid laws in that to ensure that things don't go wrong with the indexing information when you rearrange things that way
04:23:34 <Cale> I wonder...
04:26:13 <Alpounet> Hi.
04:27:01 <Cale> hello
04:27:07 <sinelaw_> Yo
04:27:19 <quicksilver> Cale: by the by, I don't really like that description of the difference between dlists and (++).  OK, so (.) is 'constant time', but that's because it doesn't really do anything, just builds up a structure.
04:27:46 <quicksilver> Cale: in that sense it's not very different from the non-strict implementation of (++) which just builds a thunk for later forcing.
04:27:58 <Cale> ?
04:28:01 <quicksilver> Cale: eventually the actual concatenation *does* occur, either way.
04:28:11 <quicksilver> and that's where the difference between Dlists and raw (++) appears
04:28:14 <Cale> ... there's a real difference in cost though
04:28:19 <quicksilver> after all, dlists still call (++) to do the work
04:28:23 <quicksilver> yes, there is a real difference
04:28:31 <quicksilver> I just object to that characterisation of the difference.
04:28:37 <Cale> (.) is constant time because the composition of functions is always always constant time.
04:28:44 <quicksilver> but you still call (++) in the end.
04:28:49 <quicksilver> the call to (++) isn't actually saved.
04:28:55 <Cale> Huh?
04:28:57 <ziman> i'd say the difference is that (.) allows you to append to the structure as well as prepend to it in the same O(1) manner; the resulting data will always need to be recomposed in O(n)
04:29:00 <Cale> No... not necessarily.
04:29:13 <Cale> There's a lot of consing...
04:29:29 <quicksilver> DList xs is just a section of (++))
04:29:36 <quicksilver> it still uses (++) to do the work.
04:29:40 <Cale> what?
04:29:52 <Cale> Most of the functions won't have (++) in them.
04:30:04 <Cale> Unless you're explicitly calling (++) somewhere...
04:30:10 <Cale> I don't see where you'd do that though.
04:30:32 <Cale> It's all functions of the form (x:) and composites of those.
04:31:13 <quicksilver> fromList    = DL . (++)
04:31:27 <Cale> Right, that's O(n)
04:31:32 <Cale> Because of the (++)
04:31:36 <quicksilver> you only get everything of the form (x:) if you build up one char at a time.
04:31:42 <mmorrow> , let wrap xs=(xs++);unwrap k=k[];app=(.) in time ((length.unwrap)((foldr (\x xs -> xs . (x:)) (wrap[]) [0..1000000])))
04:31:43 <Cale> xs ++ ys takes O(length xs) steps to evaluate fully
04:31:45 <lunabot>  (1.682744,1000001)
04:31:49 <quicksilver> no, its O(n) because it gives you n characters
04:31:54 <quicksilver> what else could it possibly be?
04:31:55 <mmorrow> , let wrap xs=(xs++);unwrap k=k[];app=(.) in time ((length.unwrap)((foldl' (\xs x -> xs . (x:)) (wrap[]) [0..1000000])))
04:31:59 <lunabot>  (1.883713,1000001)
04:32:01 <Cale> quicksilver: hm?
04:32:03 <quicksilver> you can't cons n characters onto a list in O(1)
04:32:05 * mmorrow already had those in his lunabot /msg history..
04:32:33 <quicksilver> you only get lots of thunks with (:) if in you happen to build up your DLists character by character
04:32:54 <Cale> quicksilver: consider something like...
04:33:35 <Cale> inorder' Leaf = id; inorder' (Branch x l r) = l . (x:) . r; inorder t = inorder' t []
04:33:50 <mmorrow> , let wrap xs=(xs++);unwrap k=k[];app=(.) in unwrap (foldr (\x xs -> xs . (x:)) (wrap[]) [0..4])
04:33:51 <lunabot>  [4,3,2,1,0]
04:34:01 <Cale> This is what I usually think of when I think of the difference list trick.
04:34:12 <quicksilver> I don't think that's typical.
04:34:13 <Cale> I don't use the actual DList library, because it's silly.
04:34:23 <quicksilver> you are choosing to cons one char at a time.
04:34:27 <Cale> hm?
04:34:28 <quicksilver> that's fine, but I don't think it's typical.
04:34:40 <quicksilver> if we're discussing DList vs. (++) we should discuss strings
04:34:47 <Cale> Well, even if you replace the (x:) with (xs++)
04:34:49 <quicksilver> because that's what (++) is about.
04:34:55 <quicksilver> yes, *exactly*
04:34:58 <Cale> It only has a cost equal to the length of xs
04:34:59 <quicksilver> and now my argument applies
04:35:07 <quicksilver> at the end of the day the actual work is all done by (++)
04:35:21 <quicksilver> what DList actually does it magically re-associate your (++) to the right
04:35:22 <Cale> Which is the same as (x1:) . (x2:) . ... . (xn:)
04:35:28 <quicksilver> so you don't waste time.
04:35:32 <quicksilver> that's the real trick.
04:35:39 <Cale> ?
04:35:44 <Cale> I don't understand that view.
04:35:50 <quicksilver> the real trick is using the fact that (.) is associative to automatically re-associate (++) to the right.
04:36:12 <mmorrow> , foldr (\x xs -> xs ++ [x]) [] [0..4]
04:36:13 <lunabot>  [4,3,2,1,0]
04:36:15 <mmorrow> , let wrap xs=(xs++);unwrap k=k[];app=(.) in unwrap (foldr (\x xs -> xs . (x:)) (wrap[]) [0..4])
04:36:16 <Cale> I don't see it that way at all.
04:36:17 <lunabot>  [4,3,2,1,0]
04:36:39 <mmorrow> that's how i see it too. the (.) just serves to associate it so it's not O(n^2)
04:37:09 <quicksilver> Cale: suppose you have a tree with 10 strings in.
04:37:15 <Cale> I don't see that (++) really has much of anything to do with it, except to convert [a] into [a] -> [a]
04:37:26 <quicksilver> whichever method you use - a naive tree fold over (++), or a dlist
04:37:31 <quicksilver> the actual work is still done by (++)
04:37:37 <quicksilver> (or something identical to (++))
04:37:48 <mmorrow> , let wrap xs=(xs++);unwrap k=k[];app=(.) in unwrap (foldr (\x xs -> xs `app` wrap[x]) (wrap[]) [0..4])
04:37:50 <lunabot>  [4,3,2,1,0]
04:37:54 <mmorrow> is how i should've written it
04:38:02 <quicksilver> the trick with composing functions first just gets the (++) shape correct.
04:38:35 <quicksilver> consider, if you've taken the other section of (++)
04:38:42 <quicksilver> if you'd written (++xs)
04:38:45 <Cale> Well, I suppose you can look at it this way. I think it's more complicated to analyse like that than my way.
04:38:46 <quicksilver> everything would be precisely *wrong*
04:38:51 <quicksilver> and you get pessimal behaviour.
04:39:02 <Cale> (:) is constant time, (.) is constant time. Do n of either of them, and it's linear in n.
04:39:07 <quicksilver> (that may be the first time I've ever used that word)
04:39:15 <quicksilver> yes, but you didn't say that.
04:39:18 <quicksilver> you didn't mention (:)
04:39:25 <quicksilver> you just said that (.) is constant time
04:39:29 <quicksilver> I say (.) is beside the point
04:39:34 <quicksilver> because it doesn't actually do the useful work!
04:39:38 <quicksilver> in fact, it's an overhead
04:39:42 <Cale> (.) *is* your concatenation operation.
04:39:45 <quicksilver> (I've often wondered how serious the overhead of (.) is)
04:39:50 <quicksilver> no it's not.
04:39:53 <Cale> Yes it is.
04:39:55 <quicksilver> (:) is doing the actual work.
04:40:00 <quicksilver> but you can't use (:) on two strings.
04:40:04 <Cale> But that's a bad way to think of it
04:40:08 <quicksilver> so you have to break down one string into a bunch of (:)
04:40:11 <quicksilver> ..and that's work.
04:40:21 <Cale> type DList a = [a] -> [a]
04:40:32 <Cale> (.) :: DList a -> DList a -> DList a
04:40:38 <quicksilver> (that work is precisely the definitoin of (++). (++) is the work required to break down the string on the left into a bunch of (.))
04:40:48 <quicksilver> yes, but that doesn't do anything!
04:40:59 <quicksilver> just (.)'ing a bunch of Dlists together doesn't do any useful work at all.
04:41:07 <Cale> It does! It constructs a new function which is the composite.
04:41:11 <quicksilver> the useful work is done when you apply that function to [].
04:41:22 <quicksilver> ..that's when the complexity-measured work actually occurs.
04:41:30 <quicksilver> and that actual work is done by (++) - or by (:) if you insist.
04:41:31 <quicksilver> not by (.)
04:41:33 <mmorrow> [a,b,c,d] ---->  ([a]++) . ([b]++) . ([c]++) . ([d]++)
04:41:40 <mmorrow> err
04:41:41 <Vanadium> Can we just all unsafeperformio on ioarrays already, gawrsh
04:41:48 <mmorrow> [a,b,c,d] ---->  ([d]++) . ([c]++) . ([b]++) . ([a]++)
04:41:49 <mmorrow> :)
04:42:10 <ziman> i think the first one was correct :)
04:42:17 <Cale> (.) here turns [a] -> [a] into a monoid with id as the identity. This monoid is free with respect to the elements of the form (x:)
04:42:17 <mmorrow> it's reverse though
04:42:25 <mmorrow> i meant
04:42:30 <mmorrow> , let wrap xs=(xs++);unwrap k=k[];app=(.) in unwrap (foldr (\x xs -> xs `app` wrap[x]) (wrap[]) [0..4])
04:42:31 <lunabot>  [4,3,2,1,0]
04:42:33 <Cale> (but as a whole is not a free monoid)
04:42:34 <mmorrow> , foldr (\x xs -> xs ++ [x]) [] [0..4]
04:42:35 <lunabot>  [4,3,2,1,0]
04:42:58 <Botje> > ([a]++) . ([b]++) . ([c]++) . ([d]++) $ []
04:43:02 <lambdabot>   [a,b,c,d]
04:43:17 <mmorrow> > ([d]++) . ([c]++) . ([b]++) . ([a]++) $ []
04:43:20 <Botje> phew. thought i was going crazy :)
04:43:22 <lambdabot>   [d,c,b,a]
04:44:10 <Cale> The way I think of it is that you're replacing lists of type [a] with those functions of the form [a] -> [a] which are generated by elements of the form (x:)
04:44:31 <Cale> Concatenation in this free monoid is accomplished by composing functions
04:44:48 <Cale> and the identity function is the identity with respect to composition, of course
04:44:55 <mmorrow> but you have to turn it back into a list eventually
04:45:16 <mmorrow> at which time it turns back into (++), only associated how you'd want it
04:45:20 <Cale> huh?
04:45:28 <Cale> I didn't mention (++) at all
04:45:35 <mmorrow> but i did :)
04:45:41 <Cale> So read what I wrote.
04:45:43 <mmorrow> i just mean for DList
04:45:54 <quicksilver> Cale: "replacing lists of type [a] with those functions of the form [a] -> [a] which are generated by elements of the form (x:)"
04:45:59 <mmorrow> suppose you want to do `reverse'
04:46:01 <quicksilver> Cale: that's not a magic, O(0) operation.
04:46:08 <quicksilver> Cale: that is a specific, expensive operation.
04:46:11 <mmorrow> @type reverse
04:46:11 <quicksilver> I call it (++)
04:46:13 <lambdabot> forall a. [a] -> [a]
04:46:20 <mmorrow> so you can't return a DList
04:46:28 <quicksilver> you don't ahve to call it (++) if you dont want, but you are essentially re-inventing (++).
04:46:29 <mmorrow> even if you use one internally
04:46:32 <|Steve|> O(0)?
04:46:33 <Cale> quicksilver: You're not applying it to existing lists. You're replacing the lists which occur in your algorithm with functions of this type.
04:46:42 <quicksilver> you *are* applying it to existing lists.
04:46:47 <quicksilver> "foo" ++ "bar" ++ "baz
04:46:52 <quicksilver> ^^ fix that to use DLists
04:46:55 <Cale> quicksilver: That is, I'm describing this as a transformation on code.
04:46:55 <quicksilver> the lists are already there.
04:46:58 * mmorrow is assuming we're round-tripping here from [a] to [a]
04:46:59 <quicksilver> you can't.
04:47:03 <quicksilver> the strings are in the API
04:47:09 <quicksilver> you are not permitted to change my API from using Strings.
04:47:25 <quicksilver> flatten :: Tree String -> String
04:47:36 <quicksilver> you can implement that using DLists but you can't change the type sig.
04:47:59 <Cale> quicksilver: Well, sure, you can use (++) for that.
04:48:04 <Cale> quicksilver: But I think that's separate.
04:48:07 * quicksilver shrugs
04:48:14 <Cale> It's a separate cost analysis.
04:48:17 <quicksilver> I think it's germane to the comparison "why is DLists better than (++)"
04:48:31 <quicksilver> I don't think the fair comparison involves changing the target function's type.
04:48:53 <quicksilver> and in particular I think "because (.) is O(1)" is not a good explanation ;)
04:49:06 <|Steve|> Ugh. "snoc"
04:49:13 <Cale> You'll pay an O(n) cost for each string of length n in the tree, and then you'll pay an O(1) cost for each composition that you do at each branch node.
04:49:22 <quicksilver> a better explanation is about how it avoids the problems of nested (++) traversing the LHS multiple times.
04:49:39 <quicksilver> Cale: agreed. THat's a good explanation.
04:49:59 <quicksilver> Cale: because "O(n) cost for each string" is precisely the same cost as using (++) directly
04:50:05 <quicksilver> ....as long as you associated it correctly.
04:50:12 <quicksilver> which is what I and I think mmorrow are trying to say.
04:50:27 <Cale> quicksilver: Sure. I just think that's a strange way to do the analysis. We agree about the result.
04:50:47 <Cale> There *is* a cost associated to all the concatenations.
04:51:03 <Cale> Proportional to the number of branch nodes in the tree.
04:51:15 <Cale> (exactly two times that number, in my inorder traversal)
04:51:47 <Cale> It's just that that's linear in the size of the tree, so it's acceptable :)
04:52:44 <Cale> The inorder which I'm comparing mine to is:
04:52:57 <dazza_> any ideas as to whats wrong here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9210#a9210
04:52:59 <Cale> inorder Leaf = []; inorder (Branch x l r) = l ++ [x] ++ r
04:53:53 <quicksilver> as you say, I do understand.
04:54:17 <quicksilver> I think the point about the cost of (.) being not quite the key issue is that in the case we're comparing to there are no compositions
04:54:20 <quicksilver> so (.) is an 'extra cost'
04:54:26 <Lemmih> dazza_: Did you mean 'x' instead of 'head xs'?
04:54:26 <Cale> dazza_: Let's look at what happens to breaksort [1]
04:54:30 <Saizan_> it seems more like one side is thinking about Tree String -> String and the other about Tree a -> [a]
04:54:50 <quicksilver> Saizan_: Tree a -> [a] -> [a], indeed
04:54:54 <Cale> breaksort [1] = breaksort (1:[]) = [ a | a <- takeWhile (< (head [])) (1:[])] : isgreater []
04:55:00 <quicksilver> Saizan_: but I told Cale that was cheating ;)
04:55:12 <quicksilver> or Tree [a] -> [a] -> [a] perhaps.
04:55:13 <dazza_> Lemmih I want to compare the head of the tail with the head.
04:55:17 <Saizan_> quicksilver: yeah, but it's more like you need an extra concat for Tree String -> String
04:55:45 <opqdonut> isn't that difference list solution just a nice way to state the accumulator version: "inorder (Branch x l r) ls = inorder l (x : inorder r ls); inorder Leaf ls = ls"
04:55:49 <Cale> quicksilver: Another way to do your Tree String -> String is to apply my inorder and then just use a normal concat
04:55:50 <Lemmih> dazza_: As Cale pointed out, the tail may not have a head.
04:56:16 <Cale> dazza_: The head of an empty list is a failure.
04:56:20 <dazza_> so how do I stop it? have another pattern
04:56:48 <Cale> dazza_: yeah, don't use the 'head' function
04:57:12 <Cale> dazza_: Pattern match it so that you can more easily tell when you're missing a pattern.
04:57:19 <Saizan_> opqdonut: i wouldn't call that "accumulator version" not in the same sense of accumulator as in foldl at least
04:57:30 <dazza_> what to use instead of head?
04:57:43 <dazza_> !! 0?
04:57:51 <Cale> dazza_: Pattern match
04:57:59 <Cale> !! is worse still
04:58:18 <Cale> breaksort (x:y:xs) = [a | a <- takeWhile (< y) (x:y:xs)] : isgreater (y:xs)
04:58:24 <dazza_> bare with me i am a noob
04:58:29 <Cale> However, this is strange.
04:58:49 <Cale> takeWhile (< y) (x:y:xs)  obviously will only ever have 0 or 1 element
04:59:01 <Cale> are you sure this is what you want?
04:59:18 <Cale> (when it sees the y, well, y < y is False.
04:59:20 <Cale> )
04:59:26 <dazza_> i need to break this list, into a list of smaller lists..
05:00:38 <Cale> each of which is sorted?
05:00:56 <dazza_> yes
05:01:15 <Botje> Cale: is that one of the laws Ord requires?
05:02:10 <Cale> Botje: Normally, I would hope that exactly one of [x < y, x == y, x > y] is true.
05:02:29 <Botje> I wonder how that works with NaN's..
05:02:37 <MyCatVerbs> And that (>) and (>=) are transitive.
05:02:38 * Botje pushes on his "figure that out" queue
05:02:39 <Cale> Botje: Leave Float out of it, it's a mess.
05:02:46 <MyCatVerbs> Botje: it doesn't. All comparisons with NaN return False.
05:02:53 <Botje> ah. that was my issue. thanks :)
05:03:52 <MyCatVerbs> (\x -> not (x == x)) is (unless your compiler 'cleverly' optimises it away) one way of writing an isNaN function. :)
05:04:19 <Cale> dazza_: Start by writing a function which will split a list into just two parts: the largest possible sorted piece at the beginning, and the rest
05:04:34 <Cale> dazza_: That should be a little easier to think about to start with
05:05:07 <Botje> > (\x -> x == x) (1/0)
05:05:10 <dazza_> I only need to return the largest possible sorted bit
05:05:11 <lambdabot>   True
05:05:13 <dazza_> thats all i am after
05:05:29 <Cale> > (\x -> x == x) (0/0)
05:05:33 <lambdabot>   False
05:05:45 <Botje> heh.
05:06:15 <Botje> > filter (\x -> x == x) $ map (/0) [0..]
05:06:19 <lambdabot>   [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,In...
05:06:39 <Botje> that .. kind of .. makes sense
05:06:51 <Botje> enough playing around, back to serious stuffs now :)
05:07:37 <MyCatVerbs> Botje: and if you write it in point-free form, it's pleasingly confusing.
05:08:49 <MyCatVerbs> Because of how people go through the stages of, "Right, what does the join function do again?" "Oh right, feed the argument in twice." "Wait, join (==)? How could that ever make sense? Might as well replace that with const (const True)." "Wait, what? Why did that cause everything to stop working? Aaaaaaa my head hurts!"
05:09:41 <ski> > map (graph (not . join (==)) . (/0)) [-3 .. 3]
05:09:45 <lambdabot>   [(-Infinity,False),(-Infinity,False),(-Infinity,False),(NaN,True),(Infinity...
05:10:17 <MyCatVerbs> graph f x = (x,f x)?
05:10:38 <ski>   graph :: Arrow ar => ar a b -> ar a (a,b)
05:10:39 <ski>   graph f = arr id &&& f
05:10:52 <ski> @src (->) &&&
05:10:53 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:10:53 <MyCatVerbs> Ahh. Or, arr.
05:11:15 <ski>   (f &&& g) x = (f x,g x)
05:11:21 <MyCatVerbs> Yes, and (&&&) for (->) is (f &&& g) x = (f x,g x).
05:12:00 <MyCatVerbs> Why's it called "graph"?
05:13:19 <Botje> because you can abuse it to rapidly "graph" a function, i guess :)
05:13:20 <ski> the graph of a function from `a' to `b' is the corresponding binary relation between `a' and `b' .. sometimes framed instead as a subset of the cartesian product of `a' and `b'
05:14:01 <ski> this subset here is represented as an injective function from some domain (here `a') to the cartesian product of `a' and `b'
05:14:10 <mmorrow> Cale: this is what i was picturing (not that i think it needs clarifying per se, just like the diagram syntax ;) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3543#a3543
05:14:12 <ski> cf.
05:14:17 <ski> @type cograph
05:14:19 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar a b -> ar (Either a b) b
05:14:45 <lilac> i think the traditional explanation of why DList is good (that it reassociates ++ to the right) doesn't really work.
05:14:53 <lilac> consider:  head (foldr (.) id (replicate 2000000 ("foo"++)) "")
05:14:57 <mmorrow> Cale: and i think what you're picturing is the dual (or something like that), hence our opposite views
05:15:02 <lilac> change that foldr to a foldl and you get massive performance problems.
05:15:37 <Cale> mmorrow: well, that's close, but I wouldn't have used (++) to turn a one-element list into a function
05:16:00 <mmorrow> ugh, my (g . r' . f) doesn't work :(
05:16:08 <Cale> r' = foldr (\x xs -> xs . (x:)) id
05:16:18 <mmorrow> Cale: right, but i'm emphasizing the (++)
05:16:34 <mmorrow> err, better said, i don't know about (:)
05:16:36 <int-e> lilac: but it can still produce the whole list in linear time (if memory allows) instead of quadratic time as in foldl (++) [] (replicate 2000000 "foo")
05:17:21 <MyCatVerbs> ski: ah, thank you.
05:17:50 <lilac> int-e: right. but foldr is still O(n) faster
05:17:54 <ski> MyCatVerbs : btw, a cograph of a function is more or less the same as a "table" that associates inputs with outputs
05:18:08 <MyCatVerbs> > map (cograph chr) [Right 'c', Left 66]
05:18:12 <lambdabot>   "cB"
05:18:48 <mmorrow> int-e: the dual being    foldl (\xs x -> x : xs) []   and   g . foldl (\xs x -> (x:) . xs) id
05:19:10 <mmorrow> ahhh, that's what i'm missing (post/pre composition by either f or g)
05:19:15 <mmorrow> or something
05:19:32 <lilac> int-e: finding the first element has gone from quadratic (well, stack overflow) to linear for foldl but has gone from constant to constant for foldr
05:19:33 <ski> (MyCatVerbs : really, you tag inputs with `Left', outputs with `Right', say that if `y = f x' then `Left x' and `Right y' is in the same equivalent class, defining an equivalence relation by reflexive-symmetric-transitive closure ..)
05:19:37 <Saizan_> lilac: with foldl you've to build all the compositions traversing all the 2000000 elements, with foldr you don't, so it's not exactly a fair comparison, however the association of (.)s matters too in general
05:19:40 <MyCatVerbs> ski: Oh. I was expecting something like the inverse function - a mapping from output values to input values, as you'd get from reversing the arrows in the Set category.
05:20:06 <lilac> Saizan_: sure. my point is more that right-associating the uses of (.) can still make an asympotic difference
05:20:28 <lilac> Saizan_: and the point of DList is "you don't need to right-associate the uses of concatenation any more"
05:20:30 <ski> (and that equivalence relation corresponds to the surjection from the disjoint sum of `a' and `b' to `b')
05:20:34 <int-e> lilac: yes, but the problem is evaluating all the (.) now, instead of all the (++) - (++) indeed got reassociated to the right as claimed.
05:21:20 <int-e> lilac: point taken. associativity still makes a difference, it's just much smaller, especially if you consume the whole result.
05:21:24 <ski> MyCatVerbs : at least "Sets for Mathematics" and "Toposes, Triples and Theories" mention both `graph's and `cograph's in this sense, if you're interested
05:22:00 <Saizan_> lilac: i guess the rationale is that in practice (.) is used asymptotically less times than the elements in the resulting list, making its association irrelevant
05:22:26 <lilac> int-e: right. the problem is fundamental. if you have n left-associative applications between yourself and the head of the list, the time to find the head of the list is at least O(n).
05:22:28 <MyCatVerbs> ski: Oh cool, the latter's freely available online. Thank you.
05:22:45 <Cale> lilac: can it?
05:23:04 * MyCatVerbs  mathematicians and computer scientists who put PDFs up when their books go out of print.
05:23:33 <Cale> lilac: oh, in terms of how long you have to wait for the first element, sure, the association of (.)'s matters
05:23:33 <lilac> Cale: ambiguous parse, please rephrase :)
05:24:05 <Cale> But assuming you do the whole computation every time, I think the association of the (.)'s can't have an asymptotic effect.
05:24:35 <Cale> It doesn't take longer to compose functions which are larger or smaller.
05:24:43 <lilac> Cale: if you're demanding the whole list then it doesn't matter
05:24:49 <lilac> (at least, as far as i can work out)
05:25:56 <Cale> yeah
05:26:08 <lilac> in any case, my point was simply that DList is not a panacea for list performance problems caused by left associativity, even though it helps in lots of cases
05:27:03 <Cale> I like that it's the right associated (.) which is best :)
05:29:35 <lilac> in any case, it seems to me that it's actually not (.) which is reassociating the (++). it's the fact that you're taking left sections.
05:33:01 <lilac> (you can equally well make a DList which uses right sections, and makes all list building quadratic rather than linear)
05:33:25 <Cale> I suppose it makes sense to say that the (++)'s are right associated if you go and evaluate all the (.)'s first.
05:34:26 <lilac> toDumbList xs = (++xs); mappendDumbList xs ys = ys . xs; fromDumbList xs = xs []
05:34:33 <mmorrow> ok, fixed (the asymmetry since foldr is defined on lists) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3543#a3544
05:34:44 <lilac> ^^ still using (.) but it's now associating all the ++s to the left.
05:35:01 <mmorrow> (needed the pre-composition by g)
05:35:06 <Gracenotes> both dumb and naive? you'd wonder how that function'd survive in the real world!
05:35:08 <mmorrow> (of r')
05:36:25 <benmachine> @free ord
05:36:28 <lambdabot> ord = ord
05:36:31 <benmachine> woo theorems
05:38:12 <mmorrow> and the dual (w/ the complexities reversed) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3543#a3545
05:38:37 <mmorrow> (i think)
05:40:22 <mmorrow> i guess there're more than one way you could "dualize" that, but haskell forces the list-centric view (or something)
05:40:37 <mmorrow> thus that choice of "dual"
05:41:01 <Gracenotes> hmm.. the forecast says rain at 9 AM, but it's 8:40 and I don't see any rain. perhaps it will start falling at 9 on the dot
05:41:26 <ski> "opposite" ?
05:42:46 <mmorrow> argh, that doesn't typecheck
05:43:08 <Gracenotes> everyone says different things D: who can I trust
05:43:12 <opqdonut> mmorrow: the forecast?
05:43:13 <Gracenotes> whom
05:43:24 <opqdonut> :P
05:43:32 <lilac> Gracenotes: where?
05:44:59 <Gracenotes> various websites.. ah well.. I suppose I'll go for a quick bike ride anyway
05:45:18 <quicksilver> @vixen if Gracenotes goes for a bike ride, will it rain?
05:45:18 <lambdabot> A man is not finished when he is defeated. He is finished when he quits.
05:45:21 <mmorrow> oh, n/m. it does
05:45:30 <quicksilver> Gracenotes: there you go. There's your answer.
05:45:37 <mmorrow> apparently vixen is channeling nixon today
05:46:42 <Gracenotes> I have the vixen datafile here, but I'm too lazy to find out the first regex that matches
05:46:55 <mmorrow> ski: hmm. it's dual in the sense that it's folding in the opposite way, but not dual in the sense that we're not instead of round-tripping from/to `ml' we're round-tripping from/to `mf'
05:47:08 <mmorrow> ski: so i guess more of "opposite" or something, yeah
05:50:27 <mmorrow> opqdonut: typechecking forecasts is a sure fire way to tell if they're correct
05:50:52 <ski> mmorrow : yes, like "opposite group"
05:51:32 <ski> (iiuyc)
05:51:33 <mmorrow> ski: ah yeah, totally
05:51:57 <mmorrow> err, maybe
05:52:01 <mmorrow> i dunno :)
05:53:25 * quicksilver wonders if edwark's super monoid framework contains a trick for choosing whichever of (foo`mappend`) or (`mappend`foo) is more efficient permiting a generalised DList to do the right thing.
05:54:11 * ski notes that an "anti-homomorphism" from a group `g0' to a group `g1' is a homormorphism from `g0' to the opposite group of `g1' (or, equivalently from the opposite group of `g0' to `g1'); cf. "contravariant functor" and "opposite category"
05:54:37 <ski> s/edwark/edwardk/
05:54:52 <quicksilver> thank you.
05:55:05 <ski> (.. oh, he's not actually "present" atm)
05:55:13 <quicksilver> hence tab completion failing
05:55:17 <quicksilver> hence me haivng to type it by hand
05:55:19 <quicksilver> and failing :)
05:55:20 <ski> (:
05:57:01 <pozic> How do I get a profile from a program that doesn't terminate?
05:57:42 <dons> pozic: kill it
05:58:10 <pozic> dons: Just C-c doesn't work.
05:58:40 <pozic> dons: it does end the program, but no profile is being created.
05:59:11 <dons> which ghc are you using?
05:59:15 <dons> this was fixed in  the 6.10.x series, iirc
05:59:21 <dons> so you do get a prof log on ^C
05:59:48 <pozic> dons: 6.10.2
05:59:48 <codolio> , [$ty| either Right Left |]
05:59:51 <lunabot>  forall a1 a . Either a a1 -> Either a1 a
06:00:30 <codolio> mmorrow: So it contained the information, but however you were printing it (Show?) didn't display it?
06:02:23 <mmorrow> dolio: yeah exactly, without `tidyType' it was printing two tyvars that have some internal unique in them the same
06:02:46 <mmorrow> , [$ty|either Right Left|]
06:02:49 <lunabot>  forall a1 a . Either a a1 -> Either a1 a
06:03:36 <mmorrow> *..that have two different values of some internal unique in them the same
06:04:04 <ski> (so it wasn't acounting for the coloring in the showing ..)
06:04:15 <mmorrow> right
06:06:43 <Lanjiao> A problem:
06:06:45 <Lanjiao> Given that: data D ... = C1 x y| C2 ... | C3 ..| Cn ...
06:06:46 <Lanjiao> At runtime we have (d :: D), and want some different operations on d depending on different constructions, other than writing some tedious code like
06:06:48 <Lanjiao> case x of
06:06:49 <Lanjiao> C1 .. -> ..
06:06:51 <Lanjiao> C2 .. -> ...
06:06:53 <Lanjiao> ...
06:06:55 <Lanjiao> or
06:06:57 <Lanjiao> f (C1 ...) =...
06:06:58 <Lanjiao> f (C2 ...) =...
06:07:00 <Lanjiao> Do we have some clean way? like macro in LISP or C.
06:07:25 <Botje> Lanjiao: that depends on the operations you want to do.
06:07:40 <n8dawg> what does snoc mean?
06:07:40 <Botje> do you want to do the same thing to each case? do you want to change some but not others?
06:07:49 <ski> > reverse "snoc"
06:07:50 <Botje> n8dawg: it's consing at the end
06:07:52 <lambdabot>   "cons"
06:07:59 <Botje> so adding one element to the end of a sequence
06:08:05 <n8dawg> ah thanks
06:08:23 <Botje> Lanjiao: perhaps you want to take a look at uniplate and SYB
06:08:24 <n8dawg> i get it cons reversed
06:09:09 <Lanjiao> data Tree = Add Tree Tree
06:09:11 <Lanjiao>           | Sub Tree Tree
06:09:13 <Lanjiao>           | Mul Tree Tree
06:09:15 <Lanjiao>           | Div Tree Tree
06:09:17 <Lanjiao>           | ........
06:09:18 <Lanjiao> I want to just swap the children, like
06:09:20 <Lanjiao> f (Add t1 t2) = Add t2 t1
06:09:22 <Lanjiao> .......
06:09:23 <Botje> Lanjiao: please don't paste in the channel.
06:09:31 <ski> @hpaste
06:09:31 <Lanjiao> if there are many constructors, it's tedious
06:09:31 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:09:51 <Botje> but no, you can't do that generally, i'm afraid.
06:10:01 <Botje> you'll have to resort to Template Haskell or somesuch.
06:10:03 <Lanjiao> ok, sorry
06:10:03 <dolio> Uniplate or SYB are the answer to that sort of question, as Botje said.
06:10:06 <ski>   data Tree = BinOp Tree BinOp Tree | ...
06:10:19 <ski>   data BinOp = Add | Sub | Mul | Div | ...
06:10:28 <copumpkin> ski++
06:14:16 <CalJohn> HSCurses doesn't seem to have a wrapper for napms() (the ncurses sleep proceedure).  Is there something else I can use for the same effect?
06:14:56 <benmachine> threadDelay?
06:15:58 <CalJohn> @hoogle threadDelay
06:15:59 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
06:16:18 <benmachine> I think it's in microseconds
06:17:32 <CalJohn> @hoogle Char -> Word32
06:17:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:17:33 <lambdabot> Prelude read :: Read a => String -> a
06:17:33 <lambdabot> Text.Read read :: Read a => String -> a
06:17:35 <Lanjiao> Botje, dolio: thanks, seems uniplate is what i'm looking for.
06:18:06 <CalJohn> is there a better way to turn a Char into a Word32?
06:18:31 <Saizan_> ?type fromIntegral . ord
06:18:33 <lambdabot> forall b. (Num b) => Char -> b
06:18:56 <CalJohn> thanks
06:21:06 <Vanadium> @hayoo Char -> Word32
06:21:07 <lambdabot> Unknown command, try @list
06:21:09 <Vanadium> :[
06:24:22 <lilac> fromIntegral . fromEnum if you don't want to improt Data.Char
06:25:18 * benmachine is playing with $ as infixl and thinks it is pretty cool
06:25:37 <gwern> benmachine: no! stop1 there's still time before you turn into Cale!
06:25:49 <benmachine> :O
06:25:56 <benmachine> how much time and how can I reduce it
06:26:08 <Vanadium> It is cool?
06:26:27 <gwern> benmachine: meditate deepply on the definitions in the Caleskell prelude
06:26:37 <gwern> also, the typeclassopedia and edwardk's category packages
06:26:54 <doserj> benmachine: did you ever define (.) = fmap? If not, there is still hope for you.
06:27:18 <Vanadium> Caleskell? :|
06:27:25 <Arnar_> hey all
06:27:43 <Arnar_> I'm having some problems building the haskell platform .. notably fgl
06:28:36 <gwern> Vanadium: for a while, Cale was using @let to build up a series of definitions redefining parts of Haskell
06:28:39 <Arnar> it lcaims not to find Control.Monad.State (which I find quite strange)
06:28:45 <Arnar> claims*
06:28:50 <gwern> we scrapped it because it was confusing newbies when > did one thing and ghci quite another
06:29:08 <Vanadium> gwern: Is there an archived version somewhere?
06:29:18 <gwern> don't think so
06:29:21 <benmachine> aw
06:29:43 <doserj> Arnar: ghc-pke hide <one of the mentioned packages>
06:29:52 <benmachine> doserj: yeah but I've decided that <$> is better, and . has that Arrow thing anyway
06:30:37 <doserj> Arnar: or you have to tell us exactly what the error msg says
06:32:09 <Cale> gwern: not @let
06:32:22 <Cale> gwern: that's also not why it was scrapped
06:32:44 <Arnar> doserj: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3546#a3546
06:32:47 <Cale> gwern: It was scrapped because the ghc api (or at least hint) doesn't do import ... hiding
06:33:19 <Cale> The changes to the prelude definitions were really minor, only a couple lines
06:33:28 <Cale> One was redefining (.) as fmap
06:33:38 <Cale> another was (++) became mappend
06:33:47 <Cale> That was about it
06:34:16 <Cale> I don't think I touched the associativity of ($) in it... but maybe.
06:34:21 <doserj> Arnar: did you configure to install profiling libraries recently? if so, you may have to reinstall mtl.
06:34:40 <benmachine> the idea for infixl $ was relayed to me by Badger from Twey iirc
06:34:47 <Arnar> doserj: perhaps, I'm following http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html?success&dsq=16211767#comment-16211767
06:35:02 <Arnar> it suggested installing ghc6-prof
06:35:05 <Arnar> w/apt
06:35:50 <Twey> Hmm, what was the name of that inline debugger?
06:35:50 <Twey> Hat?
06:36:34 <doserj> Arnar: I guess you had ghc-6.8 installed before?
06:36:40 <Arnar> yes
06:36:57 <Arnar> I hate packaging systems
06:37:01 <doserj> Arnar: try to purge that before re-installing ghc-6.10
06:37:25 <Arnar> I apt-get installed ghc6-mtl-prof and now things seem to be building..
06:37:53 <gwern> Cale: I remember scrapping it beforehand...
06:38:07 <Arnar> doserj: but thanks though..
06:38:12 <Cale> gwern: nope
06:38:32 <Cale> gwern: It was there right up until we switched to hint.
06:38:45 <Cale> I never wanted to get rid of it.
06:42:52 <gwern> I did
06:51:56 <WebDragon> what's the best way to find out if a float is a natural number (3.0, 5.0..)?
06:51:57 <Saizan_> Cale: if we pass "-n" to mueval's invocation we can control all that it's in scope by the imports in L.hs (making the show for functions defined in the show package work again, incidentally), i'm going to send a patch for that, then i guess we can have an alternative command/prefix with the alternative definitions in scope by using another file
06:54:48 <EnglishGent> hi :)
06:55:06 <bastl> hello, can i pipe a package.cabal-file to cabal-install?
06:55:26 <Petrosian> WebDragon: Probably not the best way, but one solution: \x -> fromInteger (floor x) == x
06:56:07 <benmachine> suppose one has a class (A f) => B f where, would there be any problems with allowing people to put default implementations of the methods of A in the body of B?
06:57:16 <Eelis> benmachine: you mean they'd forgo declaring an A instance for their type altogether?
06:57:28 <benmachine> Eelis: potentially
06:57:41 <Eelis> sounds nasty
06:57:49 <benmachine> why?
06:58:12 <Gilly> WebDragon: well, floats are not exact but you can try abs (fromIntegral (round x) - x) < epsilon where epsilon is some small positive number :P
06:58:29 <benmachine> they *could* declare an instace for A but it wouldn't be necessary because the work already done in declaring B is sufficient to create one
06:58:35 <ski> benmachine : consider `B0' and `B1' subclasses of `A', each of them d
06:58:42 <benmachine> d
06:59:04 <lilac> benmachine: are you thinking of something like 'class Functor f => Applicative f where fmap f xs = pure f <*> xs; ...'?
06:59:10 <ski> ^Hproviding a default instance for `A', and then `C' being a subclass of `B0' as well as `B1'
06:59:11 <benmachine> lilac: yeah basically
06:59:26 <benmachine> ski: don't do that, then >_>
06:59:30 <Saizan_> bastl: no, but it'd be nice to make that and (url|path)_to_tarballs work
06:59:33 <Eelis> benmachine: i'd just find it confusing to read.
06:59:39 <ski> benmachine : which default instance to use for instance of `C' ?
06:59:46 <benmachine> I see your point
06:59:47 <dolio> Let's use C++! :)
06:59:56 * benmachine euthanises dolio 
06:59:59 <lilac> benmachine: i think the class alias stuff is a nicer solution for that problem
07:00:09 <benmachine> lilac: I'm not sure it doesn't lead to the same problems
07:00:10 <ski> benmachine : one could possibly statically disallow this situation, but allow this otherwise
07:00:25 <lilac> benmachine: it means that you know exactly which classes you're providing an instance for
07:00:40 <benmachine> lilac: hmm, ok
07:01:11 <ski> lilac : i suspect superclasses or class aliases have to be combined with this more flexible kind of defaults ..
07:01:21 <WebDragon> Gilly: what am i doing wrong here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9216#a9216
07:01:33 <bastl> Saizan. Hmm. i'm playing around with a number of grammars for the bnfc-parser-generator and look for a nice build system. the cabal-files will all be the same, only the name of the grammar (and thus the modules) changes.
07:01:33 <lilac> ski: i thought the class alias stuff included addign defaults to the aliases, but i might be wrong
07:01:49 <kbrd> Gilly: what am i doing wrong here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9216#a9216
07:02:05 <benmachine> there was also something else that bothered me
07:02:20 <bastl> can i use flags to replace arbitrary strings the the cabal file?
07:02:31 <benmachine> in the Arrow class, you can define first either in terms of second or in terms of ***, but only one of those definitions can be default
07:02:31 <bastl> -the
07:02:32 <quicksilver> lilac: it's a footnote to JohnMeacham's proposal
07:02:34 <lilac> ski: yep, the proposal says that aliases are allowed to provide defaults
07:02:40 <ski> > abs (3.3 - fromIntegral (round 3.3)) < 2
07:02:44 <lambdabot>   True
07:02:45 <ski> > abs (3.0 - fromIntegral (round 3.0)) < 2
07:02:49 <lambdabot>   True
07:03:06 <lilac> http://repetae.net/recent/out/classalias.html <- this is where i'm looking but i note a ML post which says it's not the latest version
07:03:08 <quicksilver> lilac: ah no I'm wrong.
07:03:11 <Gilly> kbrd: epsilon is not small enough
07:03:14 <quicksilver> lilac: it's a core part of the proposal
07:03:21 <quicksilver> lilac: the footnote just mentions it is usefl :)
07:03:37 <kbrd> > abs (fromIntegral (round 3.3) - 3.3) < .02
07:03:41 <lambdabot>   <no location info>: parse error on input `.'
07:03:47 <kbrd> > abs (fromIntegral (round 3.3) - 3.3) < 0.02
07:03:51 <lambdabot>   False
07:03:53 <quicksilver> lilac: someone tried to implement the proposal and found it wasn't parseable though :)
07:03:55 <dcoutts> bastl: what are you trying to do exactly?
07:03:59 <kbrd> Gilly: thanks
07:04:07 <ski> kbrd : you are checking whether `3.3' (respectively `3.0') has distance to nearest integer less than two, no ?
07:04:09 <lilac> quicksilver: that's unfortunate. do you know what the problems were?
07:04:38 * lilac wonders about (=) as a type operator
07:04:39 <kbrd> ski: no i'm checking if 3.3 is an even number
07:04:43 <Gilly> kbrd: if you use 0.02 then every number within distance of 0.02 from an integer counts as an integer
07:04:46 <kbrd> ski: i mean natural
07:04:51 <dolio> benmachine: I think fancier default mechanisms like that would be nice, although I haven't thought about how much trouble they'd be to implement.
07:04:51 <lilac> can't possibly be that :)
07:05:08 <kbrd> ah i better use a smaller epsilon then
07:05:11 <dolio> benmachine: Like, multiple, explicitly specified sets of minimal definitions for a class.
07:05:41 <dolio> benmachine: Plus one set of defaults for each minimal definition set.
07:05:49 <benmachine> that would be nice
07:06:15 <benmachine> I suppose all I really want is to get rid of liftM and return
07:06:33 <lilac> quicksilver: urg, i hadn't noticed this syntax: class alias Num a = Eq a => (Additive a, Multiplicative a)
07:06:36 <dolio> Well, that's pretty easy already.
07:06:44 <benmachine> without making a class model that requires you to do four instance declarations for every Monad
07:06:54 <lilac> "class Eq a => Num a = (Additive a, Multiplicative a)" seems much more natural and easier to parse :)
07:06:55 <quicksilver> lilac: no. Was it Saizan_ perhaps?
07:07:36 <dolio> You forgot Show. :)
07:07:49 <benmachine> heh
07:08:00 <dolio> Num is a trainwreck.
07:08:04 <bastl> dcoutts: I want  simple build system for a number of  grammars like  "mygrammar/mygrammar.bnf". The parser generator generates different modules (lexer, parser, syntax) in a package "Langauge.Mygrammar" and a Makefile to build them with ghc. Now I simply want a template for mygrammar.cabal . First i thought about "sed template.cabal | cabal install". Now i look for other options ...
07:08:21 <Gracenotes> so I went for a bikeride, for about an hour and 15 minutes. It didn't rain.
07:08:25 <ski> (lilac : or `class Eq a => Num a <=> (Additive a, Multiplicative a)' (possibly with brackets around the equivalence))
07:08:30 <Gracenotes> rawr, forecast
07:08:37 <Botje> were you hoping for rain? :)
07:08:56 <benmachine> dolio: I think as trainwrecks go you can do worse
07:09:08 <ski> (lilac : apart from the obvious fact that the `=>' should be reversed, of course)
07:09:20 <dolio> Yeah, probably.
07:09:22 <dcoutts> bastl: so you can make a .cabal file for the generated modules
07:09:24 * ski ponders that
07:09:31 <lilac> the placement of the context looks problematic... given 'class Num a = (', the ( could be start-of-context or start-of-aliases
07:09:41 <Gracenotes> Botje: it said rain! I was (thankfully) cheated
07:09:46 <dcoutts> bastl: or are you looking for more automation?
07:09:52 <bastl> you mean let the parser-generate generate the cabal file?
07:10:10 <bastl> just something simple for me and my students working on the grammars.
07:10:20 <lilac> ski: urgh! 'class Num a where instance Eq a; ...'
07:10:23 <bastl> *p-generator
07:10:30 <dcoutts> bastl: I guess typically you'll want more than just the generated modules in the package, eg the code that uses the grammar
07:10:33 <ski> lilac : what about that ?
07:10:41 <dcoutts> bastl: the simplest thing is just ghc --make of course
07:10:47 <lilac> ski: i greatly prefer it to reversing the => :)
07:11:06 <bastl> dcoutts: no, i want grammar -> package.
07:11:21 <lilac> but i'm also quite happy with the => as it is :)
07:11:35 <dcoutts> bastl: ah, just the grammar on its own, in a package of its own, and then you'd have the client code us that package?
07:11:41 <ski> lilac : i'm pondering whether reversing the `=>' would be correct in this case
07:11:42 <dcoutts> us/use
07:12:08 <bastl> yes. but im only thinking about the build for a number of very similar packages.
07:12:15 <dcoutts> bastl: in that case having your tool generate a .cabal file seems like a reasonable approach
07:12:18 <kbrd> anyone know what's wrong here? having trouble mixing floats and ints :P http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9217#a9217
07:12:30 <ski> there seems to possibly be a confusion (in my mind) between antecedents and presuppositions, here
07:13:48 <bastl> dcouts: ok, true. but i dont want to patch that thing again. im looking for a quicker solution ...
07:14:05 <ski> `class Eq a => Num a where ...' could be interpreted to mean that whenever `Num a' holds, `Eq a' holds. (the `Eq a <= Num a' interpretation)
07:14:10 <doserj> kbrd: you need to fromIntegral the arguments of pythsum
07:14:47 <ski> `class Eq a => Num a where ...' could alternatively be interpreted to mean that `Num a' is only well-formed when `Eq a' actually holds
07:15:11 <dcoutts> bastl: so what do you have to work with that you could transform into a .cabal file?
07:15:20 <bastl> dcoutts: how about Distribution.Simple.defaultMainNoRead and create the PacakgeDescription my self?
07:15:44 <dcoutts> bastl: yes you can do that
07:15:52 <ski> (.. and then in case `Eq a' holds, `Num a' is defined to be equivalent to `...')
07:16:23 <bastl> i think, ill try that. are there examples for more complex Setup.hs files doing things like this??
07:16:36 <dcoutts> bastl: not many, I don't know of any using defaultMainNoRead
07:16:53 <bastl> cool :-)
07:17:15 <dcoutts> bastl: technically it would not be a cabal package, since it lacks a .cabal file
07:17:32 <dcoutts> though the runghc Setup configure; build; install would work
07:17:38 <dcoutts> but cabal install would not
07:17:49 <ski> lilac : there may still possibly be a point to the `class Eq a => Num a where ...' notation. i need to think on this. ty for the prejudice-shattering :)
07:18:11 <benmachine> ski: => in mathematics means "is sufficient for", right?
07:18:20 <quicksilver> the "point" about class Foo a => Bar a where x :: y
07:18:25 <bastl> oh, but there should be a way to make a cabal file from a PackageDescription ?
07:18:32 <quicksilver> is that it is very much like attaching a (Foo a =>) context to 'x'
07:18:36 <ski> in mathematics, `=>' usually means "implies"
07:18:37 <quicksilver> (and all the other methods of Bar)
07:18:41 <bastl> so i could write the Description to disk?
07:18:53 <quicksilver> so it's like "left-factoring" a context up from 'all methods' to the class declaration itself.
07:18:55 <dcoutts> bastl: sadly not
07:18:58 <bastl> ok
07:19:09 <quicksilver> This is not an attempt to defend the practicem but that's how/why it looks like that imo.
07:19:15 <ski> quicksilver : yes, but i didn't realize before that this could be connected to presuppositions (vs. assumptions)
07:19:20 <bastl> ok, first i have to dive into PackageDescription ...
07:19:24 <dcoutts> bastl: the pretty printer is borked
07:19:26 <bastl> thx so long
07:19:33 <dcoutts> bastl: there's PackageDescription and GenericPackageDescription
07:19:43 <dcoutts> one being the resolved form of the other
07:19:45 <benmachine> I think the uses of => in haskell are different from those in maths
07:19:46 <dcoutts> conditionals etc
07:20:40 <ski> benmachine : `=>' in `instance Eq a => Eq [a]' appears to faithfully admit the "implies" interpretation
07:21:01 <benmachine> ski: oh, true
07:22:39 <ski> (for any type `a', `a' being an instance of `Eq' implies `[a]' being an instance of `Eq'; the (constructive) proof (in terms of dictionary passing) is the function transforming an `Eq a' dictionary into an `Eq [a]' dictionary, for any type `a')
07:23:31 <Arnar> when you guys use cabal.. do you generall install --global or --user ?
07:23:42 <benmachine> mine defaults to global
07:23:46 <benmachine> although I can't remember why
07:23:50 <dcoutts> Arnar: I use the default, which is user
07:23:59 <benmachine> yeah I changed my default
07:24:00 <Arnar> I keep messing things up if I use user
07:24:15 <Arnar> dcoutts: do you have ~/.cabal/../bin in your path then?
07:24:18 <dcoutts> Arnar: it's easier cleaning up the mess when it's user rather than global :-)
07:24:22 <mux> dons: cheers for liboleg :)
07:24:29 <Arnar> dcoutts: I can imagine :)
07:24:53 <dcoutts> Arnar: no, I set symlink-bindir in the ~/.cabal/config
07:25:05 <dcoutts> Arnar: so it makes symlinks in ~/bin, which is on by $PATH
07:25:11 <dcoutts> by/my
07:25:11 <doserj> ski: that's the wrong reading of instance Eq a => Eq [a]. Eq a is not only sufficient for Eq [a], it is also necessary.
07:25:15 <merus> http://blog.wolfram.com/2009/09/09/999/ <-- Wolfram sucks his own cock some more
07:25:16 <Arnar> dcoutts: aha.. allright
07:25:21 <merus> wow wrong channel
07:25:22 <merus> sorry
07:25:26 <Arnar> dcoutts: thanks
07:25:56 <Arnar> dcoutts: simlink-bindir: True or simlink-bindir: ~/bin ?
07:26:01 <ski> doserj : .. *provided* we don't allow overlapping instances, yes
07:26:13 <dcoutts> Arnar: the path, sadly it doesn't grok "~" yet
07:26:22 <Arnar> dcoutts: ok thx
07:26:50 <ski> doserj : also, even if that language is not enabled, i don't think GHC allows going from an `Eq [a]' constraint to an `Eq a' constraint
07:26:56 <Arnar> and I presume this goes in the root of the config file.. not under "install-dirs user"
07:27:01 <Arnar> just based on the example config..
07:27:12 <eblond> hello everyone
07:27:13 <dolio> ski: Correct, it does not.
07:27:21 <eblond> (new Haskell user)
07:27:30 <ski> (doserj : someone tried something similar with `instance (Show a,Show b) => Show (a,b)' recently, and couldn't get GHC to accept it)
07:27:40 <Axman6> g'day eblond
07:27:47 <bastl> dcoutts: Creating (=declaring) a PackageDescription in haskell-syntax seems not to be very hard. Why is there a specific syntax for cabal files?
07:27:56 <ski> afternoon, eblond
07:28:11 <eblond> hi everyone
07:28:16 <dcoutts> bastl: the fact that .cabal files are not turing complete is a feature, not a bug
07:28:38 <bastl> :-)
07:28:47 <Axman6> but if things aren't turing complete, how can they be useful? :O
07:28:50 <ski> doserj : .. hm, i wonder whether this would be related to the "open-world interpretation" of the instances ?
07:28:54 <dcoutts> bastl: it's also much easier to handle forwards / back compatability
07:29:10 <ski> eblond : if you have any questions, ask away
07:29:17 <bastl> i see
07:29:21 <eblond> glad you aked ski :-)
07:29:23 <dooof> what's the status of opengl 3+ bindings in haskell?
07:29:31 * ski didn't ask :)
07:29:36 <dcoutts> dooof: available from hackage now
07:30:04 <dooof> dcoutts: nice! I'd hate having to resort to some other language.
07:30:06 <eblond> actually I'm trying to parse a datetime, but it's not as straightforward as I expected
07:30:10 <doserj> @type \(x:xs) ys -> xs == ys -- that goes from Eq [a] to Eq a
07:30:12 <lambdabot> forall t. (Eq t) => [t] -> [t] -> Bool
07:30:37 <ski> doserj : nope, that's the other direction :)
07:30:58 <dolio> doserj: You can't write "f :: Eq [a] => a -> a -> Bool ; f x y = x == y"
07:31:00 <doserj> then I am confused about what you were saying
07:31:31 <dolio> It can't conclude Eq a given Eq [a].
07:31:32 <pozic> cabal install parsec;ghci RET and then import Text.Parsec returns that Text.Parsec cannot be found. Why does that happen? The module exists according to Hackage.
07:31:43 <jfoutz> hmm
07:32:07 <pozic> Text.ParserCombinators.Parsec exists however according to ghc-6.10.4.
07:32:08 <dcoutts> pozic: that's not the right module name
07:32:29 <pozic> dcoutts: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec.html
07:32:32 <doserj> dolio: ah
07:32:34 <pozic> dcoutts: it isn't?
07:32:39 <dcoutts> pozic: you're looking at a different version there
07:32:56 <ski> doserj : the example i was mentioning was <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8419>
07:32:56 <dooof> dcoutts: do you have a link for that? I'm only finding version 2.1
07:33:47 <dcoutts> dooof: oh, sorry, I'm wrong. The maintainer has been talking about GL3 but yes the released one is still GL2.1
07:33:59 <dcoutts> dooof: perhaps check the dev version
07:34:28 <pozic> dcoutts: ok, I see what you mean.
07:34:28 <dooof> dcoutts: aw! I will.
07:35:02 <dcoutts> pozic: the confusing thing is that parsec 2.x is the default version, but hackage shows you the latest one
07:35:46 <pozic> dcoutts: arg. Why?
07:35:52 <pozic> dcoutts: that's just insanity.
07:36:11 <dcoutts> pozic: because hackage doesn't yet respect the settings for which versions are the default
07:36:14 <aavogt> dolio: assuming that we didn't already have an instance for the other way, we could have this:  instance Eq [a] => Eq a where (==) = on (==) (:[])
07:36:42 <benmachine> dcoutts: what does default version mean?
07:36:51 <aavogt> but that one seems to be quite overlapping?
07:36:59 <dolio> That's sort of true, but yeah, it has problems.
07:37:10 <dcoutts> benmachine: the one you get if you "cabal install foo" without specifying any constraint
07:37:16 <benmachine> ah
07:37:22 <dolio> Because you can't define any other instances, so you just get Eq a requries Eq [a] requires Eq [[a]] ...
07:37:46 <dcoutts> benmachine: the purpose is to let maintainers have a recommended as well as a latest/testing version on hackage simultaniously
07:38:27 <dolio> An instance like that probably requires UndecidableInstances to be enabled.
07:38:30 <pozic> dcoutts: and why does this default field exist to begin with?
07:38:42 <pozic> dcoutts: it seems to only complicate the system for little to no value.,
07:38:59 <benmachine> dcoutts: I see
07:39:04 <benmachine> that makes sense I suppose
07:39:08 * benmachine installs parsec 3.0.0
07:39:21 <dcoutts> pozic: it's there for two reasons, one is to hack badly specified deps, the other is to let people have eg haxml-1.13 and 1.19 on hackage at the same time
07:39:34 <aavogt> so you could restrict equality on lists for those nested x layers deep, with the appropriate extensions enabled
07:40:23 <dcoutts> pozic: http://hackage.haskell.org/packages/archive/preferred-versions
07:40:59 <aavogt> but the type errors you'd get when going beyond that number would probably be the (usually) unhelpful 'add an instance for'
07:41:11 <dcoutts> pozic: the hacky aspect has been used successfully to stop most of hackage breaking when we added base 4
07:41:53 <pozic> dcoutts: why not just wrote a preprocessor for the cabal files?
07:42:03 <ski> @type on (==) (:[])
07:42:05 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:42:20 <dcoutts> pozic: the issue is where the info comes from
07:42:29 <ski> aavogt : ok. what about inverting `instance (Eq a,Eq b) => Eq (a,b)', then ?
07:42:47 <pozic> dcoutts: I mean for the hack for base-4.
07:43:05 <dcoutts> pozic: we cannot alter existing tarballs, though we have been considering allowing an updated .cabal file outside of the tarball
07:43:27 <dolio> (==) `on` dup
07:44:23 <pozic> dcoutts: how do you mean "cannot alter"?
07:44:29 <ski> @type (==) `on` join (,)
07:44:31 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:44:42 <pozic> dcoutts: you mean that you don't want to alter it?
07:44:45 <dcoutts> pozic: the tarballs already on hackage, we cannot alter them.
07:44:54 <dcoutts> pozic: it is essential that we do not alter them
07:45:08 <ski> dolio : that's `Eq (a,a) => Eq a', sure ..
07:45:23 <pozic> dcoutts: why is that essential? If you provably make them specify dependencies better, I see no problem.
07:45:28 <dolio> If you have Eq (a,b) you have Eq (a,a).
07:45:28 <ski> .. but `Eq (a,b) => Eq a' ?
07:45:41 <ski> dolio : how ?
07:45:46 <dolio> Set b = a.
07:45:51 <hackagebot> bindings-levmar 0.1 - A binding to the C levmar (Levenberg-Marquardt) library (BasVanDijk)
07:45:53 <hackagebot> levmar 0.1 - An implementation of the Levenberg-Marquardt algorithm (BasVanDijk)
07:45:58 <dcoutts> pozic: hackage then becomes useless as a pristine upstream archive, everyone would have to start taking snapshots
07:45:58 <ski> (note that `a' and `b' are specific types here, possibly skolems)
07:46:30 <dcoutts> pozic: distros need to know that the sha1 sums of the tarballs are stable, it's just one of the basics of sane software distribution
07:46:31 <aavogt> @wn skolem
07:46:34 <lambdabot> No match for "skolem".
07:46:54 <eblond> ok nevermind mind, found it
07:47:02 <pozic> dcoutts: oh, well, it's useless to discuss it further now, since it has already been done. Thank you, for the information.
07:47:17 <ski> dolio : assuming `data EqDict a = MkEqDict {eq :: a -> a -> Bool}' define an operation of type `forall a b. EqDict (a,b) -> EqDict a' (with the intended semantics)
07:47:50 <dolio> Yeah, that's a little harder.
07:47:55 <dcoutts> pozic: we can make it better though, eg make it easier for maintainers to adjust the preferred version, and to make hackage show the preferred version
07:48:17 <dolio> Presumably you can't rely on (a, undefined) to do the right thing.
07:48:22 <ski> dolio : those `a' and `b' in the argument type `EqDict (a,b)' there are arbitrary/rigid/skolems .. you can't just unify them, since they might be different, the caller provides them however seen fit
07:48:27 <dcoutts> pozic: similarly to keep a separate copy of the .cabal file to fix deps later, that distros and tools can use at their option (ie so we don't change the tarball)
07:48:32 <tavelram> is it possible to "overload" cons and nil?
07:48:46 <ski> > (True,undefined) == (True,undefined)
07:48:51 <lambdabot>   * Exception: Prelude.undefined
07:48:52 <pozic> dcoutts: and you can make cabal install display: Installing preferred version FOO of package BAR. Other available versions are: ........
07:49:33 <dcoutts> pozic: right, could do, the issue is how best to present the info
07:49:53 <ski> dolio : this is what was needed for <forgotten nick-name>s paste <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8419>
07:50:33 <ski> tavelram : you can make a type class with members `cons' and `nil' ..
07:50:56 <pozic> dcoutts: if you are talking about human readable vs machine readable, you should just provide two different interfaces. If you are just talking about the human interface, I would just see how other systems do it, and if there is no such system implement something which I would find acceptable for myself until someone complains about it :)
07:52:09 <dcoutts> pozic: eg gentoo doesn't tell you that there are later unsable versions by default, it just installs the latest default, but on the website and in the tools its clearer which versions are stable/unstable
07:52:27 <jeffheard_home> interesting.  I can't seem to find a function out there already with the signature (a->m b) -> (a-> m c) -> a -> m c
07:52:52 <doserj> you mean (>=>)?
07:53:13 <benmachine> no that'd be b -> m c
07:53:28 <benmachine> jeffheard_home: um, flip const?
07:53:30 <benmachine> :P
07:53:31 <doserj> I was assuming that was a typo
07:53:33 <jeffheard_home> doserj: not kliesi composition
07:53:45 <jeffheard_home> :t flip const
07:53:47 <lambdabot> forall a b. b -> a -> a
07:53:54 <mux> @pl \f g x = f x >> g x
07:53:55 <lambdabot> (line 1, column 8):
07:53:55 <lambdabot> unexpected "="
07:53:55 <lambdabot> expecting pattern or "->"
07:53:56 <aavogt> @type on (*>) id
07:53:58 <lambdabot> forall (f :: * -> *) a. (Applicative f) => f a -> f a -> f a
07:54:01 <mux> @pl \f g x -> f x >> g x
07:54:01 <lambdabot> liftM2 (>>)
07:54:03 <jeffheard_home> Ah, I don't think that does what I want it to though
07:54:05 <mux> ah.
07:54:17 <mux> :t liftM2 (>>)
07:54:19 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
07:54:41 <Botje> hooray for the reader monad!
07:54:44 <mux> :t \f g x -> f x >> g x
07:54:45 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (t -> m b) -> t -> m b
07:55:15 <jeffheard_home> basic idea is I want functionality like mapM_ but compositional instead of having to use a list
07:55:41 <opqdonut> huh?
07:55:59 <jeffheard_home> like: (putStrLn `f` putStrLn) $ "foo" => "foo\nfoo\n"
07:56:09 <aavogt> > liftA2 (*>) "hello" "there"
07:56:13 <lambdabot>   Couldn't match expected type `f a'
07:56:14 <opqdonut> yeah, what mux wrote
07:56:37 <opqdonut> that's just once (r->)-lifted (>>)
07:56:42 <dolio> ski: That's a weird error message, but it's also a weird set of instances.
07:56:45 <jeffheard_home> exactly what mux wrote.  i know how to write it, I was just surprised there wasn't something out there already idiomatic
07:56:50 <jeffheard_home> in control.monad or control.arrow
07:57:01 <ski> dolio : the annotation ?
07:57:11 <mux> I've had that feeling gazillions of times with haskell (why isn't this already defined?)
07:57:15 <dolio> ski: I was thinking the middle one.
07:57:29 <mux> probably because there are so many convenient stuff already defined, so you get used to it
07:57:32 <jeffheard_home> does such a composition have a name already in category theory?
07:57:36 <dolio> I'd expect the problem to be that it can't deduce Show (F a1) and Show (F b).
07:57:45 <ski> (oh, right, there were two annotations)
07:58:14 <pozic> dons: I upgraded ghc to 6.10.4 and it still doesn't leave a profile after C-c C-c.
07:58:30 <Philonous> jeffheard_home: That's basically the idea behind the reader monad. So maybe you want ReaderT?
07:58:54 <jeffheard_home> Philonous: I'll look into it.
07:58:57 <dolio> ski: Also, A is a valid constructor in the second instance, and B is, presumably, valid in the first.
07:59:10 <jeffheard_home> Philonus: are there examples out there of how to use it?
07:59:39 <dolio> The last annotation gets A in the second.
08:00:12 <ski> dolio : yes, that you can't deduce `Show (F a)' and `Show (F b)' from `Show (a,b)' (possibly using `forall a. Show a => Show (F a)' recursively)
08:00:47 <pozic> dons: it does create a Foo.prof file; it's just empty.
08:00:48 <ski> iirc, the last annotation "worked", using overlapping instances
08:00:57 <Philonous> > runReader (asks (:[]) ) 4
08:01:01 <lambdabot>   [4]
08:01:13 <jeffheard_home> ha yes
08:01:16 <jeffheard_home> that's exactly what I want
08:02:03 <tavelram> ski, well yeah, but I mean the syntax : and []...
08:02:42 <ski> dolio : ok, see `zong_sharo' at <http://tunes.org/~nef/logs/haskell/09.08.22>. that's the OP
08:03:09 <dolio> Well, I mean, if you have "(Show a, Show b)" and you're doing "Show (F (a, b))", if a = (c,d), then you're recursively using Show (F (c,d)) which requires "(Show c, Show d)" which you can't deduce from Show (c,d) = Show a. Maybe that's the error (same for b).
08:03:11 <ski> tavelram : ok. then, no, i don't think so
08:03:35 <tavelram> ok
08:03:47 <dolio> The type variables in the error message aren't what I'd expect, though.
08:03:55 <doserj> [] is special syntax. (:) should be possible though (but only as a constructor)
08:04:34 <ski> dolio : the basic error is that GHC doesn't allow to go (for all `a',`b') from `Show (a,b)' to `Show a' (as well as `Show b')
08:05:17 <ski>   show :: forall a. Show a => a -> String
08:05:23 <doserj> hmm. apparently, it is not...
08:05:56 <ski> we want to construct `instance Show a => Show (F a)', i.e. logically `forall a. Show a => Show (F a)'
08:06:03 <ski> so we want
08:06:14 <ski>   show :: forall a. Show a => F a -> String
08:06:41 <ski>   forall a. Show a => (show :: F a -> String)
08:06:56 <ski> taking the first equation, we get
08:07:36 <ski>   forall a. Show a => (show (A a :: F a) :: String = "A " ++ show a)
08:08:10 <ski>   forall a. Show a => (show (A (a :: a)) :: String = "A " ++ show a)
08:08:38 <ski> and the `show a' now works out because we have the constraint `Show a' "in scope"
08:08:47 <ski> the other equation
08:09:29 <ski>   forall a. Show a => (show (B b c :: F a) :: String = "B (" ++ show b ++ ") (" ++ show c ++ ")")  -- renamed slightly
08:09:46 <bastl> I dont find the library-function to uppercase the first letter in a string (and dont want to do it myself). is there something in the libraries ??
08:10:08 <ski> `B b c :: F a' means that `a' is `(b,c)', so we actually have
08:10:08 <bastl> (i know about toUpper :: Char -> Char)
08:10:26 <ski>   forall b c. Show (b,c) => (show (B b c :: F (b,c)) :: String = "B (" ++ show b ++ ") (" ++ show c ++ ")")
08:10:45 <aavogt> > 'z':map toUpper "omg"
08:10:46 <ski>   forall b c. Show (b,c) => (show (B (b :: F b) (c :: F c)) :: String = "B (" ++ show b ++ ") (" ++ show c ++ ")")
08:10:49 <lambdabot>   "zOMG"
08:11:44 <arw_> > let toUpperFirst (s:r) = toUpper s : r in toUpperFirst "foobar"
08:11:48 <lambdabot>   "Foobar"
08:12:00 <ski> now `show b' requires `Show (F b)' (and `show c' requires `Show (F c)'), but we've only got `Show (b,c)' (and the recursive assumption `forall a. Show a => Show (F a)')
08:12:29 <ski> so if we could get `forall b c. Show (b,c) => (Show b,Show c)', this would work
08:12:33 <arw_> not really sure if there is a library function for that.
08:12:38 <Taejo_> @pl many x = optional (x :- many x)
08:12:38 <lambdabot> many = fix ((optional .) . ap (:-))
08:12:52 <aavogt> > (:).tail<*>toUpper.head $ "hello"
08:12:57 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
08:12:58 * ski wonders whether anyone listened :)
08:13:02 <aavogt> > fmap(:).tail<*>toUpper.head $ "hello"
08:13:06 <lambdabot>   Couldn't match expected type `a -> b'
08:13:11 <dolio> I did.
08:13:42 <ski> (the error "Could not deduce (Show a1) from the context (a ~ (a1, b))" is about specifically this)
08:13:44 <bastl> hmm. so many chars make the code hard to read. toUpperFirst ::String -> String would be nicer
08:13:59 <hackagebot> levmar-chart 0.1 - Plots the results of the Levenberg-Marquardt algorithm in a chart (RoelVanDijk)
08:14:09 <bastl> anyhow. takes to long, i use arw_s prop.
08:14:21 <dolio> Oh, was the error in the middle one just copied from the first one?
08:14:26 <dolio> That'd make more sense.
08:15:17 <ski> if we had `forall b c. Show (b,c) => (Show b,Show c)', then for coherence(/consistence ?) we should really require that the other direction `forall b c. (Show b,Show c) => Show (b,c)' is the inverse of the former
08:15:50 <ski> .. and that rules out overlapping instances (at least as long as we can't prove they are semantically equivalent)
08:17:10 <dolio> Yeah, the error for the middle involves incoherent instances.
08:20:34 <ski> dolio : i don't see (or recall) atm why the first annotation didn't go through with overlapping instances .. but even if it had, the second instance is partial in that it doesn't handle the possible `A' case (presumably the `B' case is never passed to the first instance, because of best match with overlapping instances)
08:21:01 <hackagebot> usb-id-database 0.2.1 - A database of USB identifiers (RoelVanDijk)
08:21:05 <ski> oh .. now i think i see
08:21:32 <dolio> ski: I don't really understand incoherent instances, but apparently it needs them.
08:22:23 <ski> (.. X crashed momentarily)
08:22:27 <dolio> I guess when it does "(Show a, Show b) => Show (F (a,b))" it can't do analysis on a and b to figure out if it needs to recursively call itself (which wouldn't work for the same reason as the original single instance) or if it should call the A instance.
08:22:47 <bastl> dcoutts: cabal doesant find my source files. what field of PackageDescription are needed for that ?
08:23:01 <dolio> That is, it can't do case analysis on a to see if a ~ (b,c) or not.
08:23:10 <dolio> So it always uses the A instance, which is wrong.
08:23:25 <dcoutts> bastl: it looks in '.' by default, and expects the standard naming convention, Foo.Bar living in Foo/Bar.(l)hs
08:23:57 <bastl> but what field? dataDir, dataFiles?
08:24:00 <dcoutts> bastl: you can tell it to look elsewhere, eg "src/" by listing the dirs in hs-src-dirs field, or the corresponding record member in PackageDescription
08:24:19 <dcoutts> bastl: look in the BuildInfo record
08:24:21 <eblond> bye everyone
08:24:37 <benmachine> hs-source-dirs
08:24:51 <ski> dolio : .. at least, i think the problem (or *a* problem, at least) in the first annotation is that we've dispensed with the `forall a. Show a => Show (F a)' instance (the one we we're trying to define recursively, before), so we can't use that to go from `Show b' and `Show c' into `Show (F b)' and `Show (F c)' anymore
08:25:27 <bastl> oh, i used emptyBuildInfo :-/ because the type is quite big. what fields in there are mandatory?
08:25:28 <ski> dolio : in the second annotation, we handle the `A' case in the second instance, so that it's not partial
08:25:37 <dolio> Or, it uses the A instance when used on an "F a", where a is a type variable, and the B instance when used on "F (b,c)".
08:27:00 <dolio> ski: Well, that's actually what it does use, I think, due to incoherent instances.
08:27:03 <hackagebot> CCA 0.1 - preprocessor and library for Causal Communtative Arrows (CCA) (PaulLiu)
08:27:20 <ski> dolio : well, we can't do case analysis on the type `a' to see whether it is of form `(b,c)' .. but we can do case analysis on *values* of type `F a', and in case it's the `B' constructor, then we know `a' is `(b,c)'
08:27:37 <ski> so it seems that would work out in this case, anyway
08:27:40 <dolio> The signature "(Show a, Show b) => Show (F (a,b))" treats a and b as opaque variables, so IncoherentInstances picks the "Show a => Show (F a)" instance for them.
08:28:07 <ski> (dolio : i'm not sure incoherent-instances is needed for the second annotation)
08:28:32 <dolio> No, not the second (I haven't tried that one), the first, though.
08:28:59 <ski> dolio : but anyway, i think what you're saying is related to a problem the second annotation still has (i gather)
08:29:06 <ski> namely, consider
08:29:11 <Taejo> :( why no Applicative and Alternative instances for Data.Sequence?
08:29:37 <dolio> My understanding of incoherent instances isn't very good.
08:29:39 <ski> @type \a b abs -> (a,b) `elem` abs
08:29:41 <lambdabot> forall t t1. (Eq t, Eq t1) => t -> t1 -> [(t, t1)] -> Bool
08:29:54 <dolio> Although I think Oleg uses it to get skolemized, polymorphic type reps.
08:30:10 <dolio> Which tells you a bit about what it's doing, I guess.
08:30:16 <ski> dolio : *why* do we get a constraint `(Eq t, Eq t1)' instead of `Eq (t,t1)', here ?
08:30:29 <ski> @type elem
08:30:31 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
08:31:02 <dolio> ski: Because it can recognize that (Eq t, Eq t') is sufficient for (Eq (t,t')).
08:31:11 <quicksilver> ski: because it's already found the instance for Eq (a,b)
08:31:22 <ski> dolio : the type system here *assumes* that the only way to get `Eq (t,t1)' is from `(Eq t, Eq t1)', so it simplifies the constraint
08:31:24 <quicksilver> ski: so it applies that one and computes the new constraint.
08:31:29 <quicksilver> right.
08:31:43 <quicksilver> that's a valid assumption, under the original design of typeclasses.
08:32:41 <Taejo> I seem to remember there being an operator for infix applicative, but can't remember what it was.
08:32:43 <ski> but what if i defined an overlapping instance `instance Eq (Bool,Int) where (False,_) == (False,_) = True; (True,a0) == (True,a1) = a0 == a1; _ == _ = False' (e.g.) ?
08:33:29 <ski> then using this instance `Eq (Bool,Int)' directly is *not* the same as applying `forall a b. (Eq a,Eq b) => Eq (a,b)' on `Eq Bool' and `Eq Int'
08:33:30 <quicksilver> ski: this is an example of why overlapping instances don't work.
08:33:37 <ski> exactly
08:33:50 <quicksilver> ski: overlapping instances don't work because in a "polymorphic context" the general instance will always be taken.
08:34:02 <quicksilver> instance overlap is in some loose sense "incompatible with" polymorphic compilation.
08:34:03 <lilac> Taejo: (<^), (^>)
08:34:15 <ski> this aspect of the type system already *assumes* you don't have overlapping instances (with differing semantics)
08:34:23 * quicksilver nods
08:34:24 <quicksilver> right
08:34:30 <Taejo> @hoogle (<^)
08:34:31 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
08:34:35 <quicksilver> you don't need recursive class contexts to show that
08:34:38 <Taejo> :-|
08:34:45 <quicksilver> you can show it with the simplest possible typeclasses.
08:35:02 <quicksilver> class Frob a where Frob :: a -> String;
08:35:16 <quicksilver> make a polymorphic instance for [a] and an overlapping one for [Int]
08:35:20 <lilac> Taejo: there's an infixapplicative package on hackage or sth
08:35:26 <ski> if the type system only inferred `forall t t1. Eq (t, t1) => t -> t1 -> [(t, t1)] -> Bool' for `\a b abs -> elem (a,b) abs' (at least assuming we have enabled OverlappingInstances), then this problem wouldn't appear
08:35:36 <Taejo> lilac: ok. doesn't seem worth the trouble
08:36:01 <quicksilver> and then look at bar :: a -> a -> String; bar x y = frob [x,y]
08:36:05 <benmachine> :t (<*>)
08:36:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:36:13 <ski> (imo, s/recursive/implied/)
08:36:14 <lilac> Taejo: yeah, liftA2 (*~*) is readable enough
08:36:26 <quicksilver> when compiling 'bar' the compiler can't *possibly* use the specific instance for [Int]
08:36:34 <quicksilver> because a may well not be Int.
08:36:41 <quicksilver> it would have to either (a) notice that and auto-specialise
08:36:51 <quicksilver> or (b) [which is what it does] pick the polymorphic one
08:37:09 <quicksilver> ski: yes, but then all kinds of functions pick up contexts
08:37:11 <bastl> dcoutts: wanna look at this? It still doesnt find the sources ... :-/ http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3547#a3547
08:37:19 <quicksilver> whereas the current scheme collapses contexts eagerly
08:37:31 <quicksilver> your scheme would have all contexts build up until the "end"
08:37:40 <ski> yes, i suppose so
08:37:58 <quicksilver> do we want the expression "foo = show 'c'" to pick up a (Show Char => ) constraint?
08:38:03 <ski> (ok, now i get your example)
08:38:04 <quicksilver> because that's logically the same idea
08:38:13 <ski> *nod*
08:38:22 <quicksilver> of course you could choose to only do it when there is at least one variable
08:38:36 <quicksilver> I was just giving the most extreme example.
08:39:24 <quicksilver> ski: my conclusion from all of this is that re-engineer the system to be a bit more like logic programming and a bit less like tpeclasses is a substantial change :)
08:39:37 <quicksilver> ski: I don't feel qualified to work out the cost-benefit though
08:39:44 <ski> i wonder how the instance system would change if we added inequality constraints
08:40:24 <lilac> if we delay instance matching, and use MPTCs, can we end up needing equality constraints?
08:41:32 <dolio> quicksilver: It doesn't actually pick the polymorphic one. It generates an error.
08:41:33 <DrTeggy> G'day all.
08:41:45 <dolio> It only picks the polymorphic one if you enable IncoherentInstances.
08:42:04 <ski> quicksilver,dolio : i suppose part of my point here is that this constraint simplification implicitly assumes `forall a b. Eq (a,b) => (Eq a,Eq b)' .. so the question then is why this isn't used in e.g. the example on hpaste earlier ?
08:42:54 <lilac> you mean in the class head?
08:43:15 <dolio> It doesn't assume Eq (a,b) => (Eq a, Eq b), does it? It assumes (Eq a, Eq b) => Eq (a,b).
08:43:19 <dolio> Which it does.
08:44:44 <dolio> I suppose it goes the other way, too...
08:44:46 <dcoutts> bastl: where are the actual files? (relative to ./ )
08:45:12 <bastl> dcoutts: in "."
08:45:24 <dcoutts> bastl: gimme an example of a file it is not finding, and where it lives exactly, relative to your pwd
08:45:26 <bastl> Language.Java.Absjava e.g.
08:45:26 <Vanadium> How is the syntactic ambiguity between the operator (.) and hierarchic module syntax handled?
08:45:30 <bastl> *+hs
08:45:42 <dcoutts> bastl: so the file is named "Language.Java.Absjava.hs" ?
08:46:00 <bastl> sorry no: Language/Java/Absjava.hs
08:46:33 <bastl> ah, so it looks for a file "Language.Java.Absjava" !?
08:46:55 <bastl> thats not there of course. is "ModuleName.simple" wrong ?
08:47:03 <bastl> (i mean my usage)
08:47:40 <quicksilver> dolio: yes, right, overlappinginstances as GHC implements them tries to check at compile time you're not doing anything stupid
08:47:56 <quicksilver> dolio: however, if you play complicated games with module visibility and so on you can make it do wrong things.
08:48:29 <dcoutts> bastl: no, it'll look for ./Language/Java/Absjava.hs
08:48:30 <bastl> dcoutts: ModuleName is a bit under-documented ..
08:48:44 <dolio> quicksilver: I seem to recall being able to get incoherent-instances behavior via overlapping + existentials, too.
08:48:56 <dolio> But I don't have an example off hand.
08:48:59 <dcoutts> bastl: oh, but simple is wrong for your usage
08:49:20 <bastl> ?
08:49:45 <dcoutts> use ModuleName.fromString
08:50:46 <dcoutts> bastl: ModuleName.simple is deprecated
08:51:52 <dcoutts> bastl: ah, that's not in 1.6, you'll have to use the Text class to parse it
08:51:59 * ski restarts X yet again ..
08:52:14 <dcoutts> bastl: the ModuleName.simple does not accept names with '.' in
08:52:20 <lilac> Vanadium: badly :) if there's no whitespace between a CapitalizedWord and a . then it's a module name thingy
08:52:24 <lilac> Vanadium: for instance:
08:52:32 <lilac> > [False..True]
08:52:34 <bastl> i can as well put "/" in it ...
08:52:36 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
08:52:43 <bastl> since i construct it on my own
08:52:44 <lilac> > [False .. True]
08:52:47 <lambdabot>   [False,True]
08:52:56 <Makoryu> > [ True .. False ]
08:53:00 <lambdabot>   []
08:53:12 <eyeris> Could someone explain this installation error to me? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9221#a9221
08:53:13 <dcoutts> bastl: you can't put '/' in as that's not valid syntax for a module name.
08:53:31 <ski> dolio,lilac : thinking about `instance ... => P (...)' as a Prolog clause, it only tells that `...' is *one* possible way to satisfy `P (...)'
08:53:38 <bastl> ok, so how can i create a ModuleName in a simple way?
08:54:07 <dcoutts> bastl: fromJust . simpleParse
08:54:21 <ski> but since we want unique solution (so we can avoid explicitly specifying and passing around instances), we need to assume that this generates the only solution
08:55:11 <ski> (i.e. we're doing more or less a "closed-world assumption" wrt uniqueness)
08:55:53 <dolio> Yes, and one of the rules is that polymorphic instances preclude any others of the same form.
08:55:54 <dcoutts> bastl: in Cabal-1.8 there's a ModuleName.fromString that short-cuts the parsing for internal cases where we can reasonably assume the syntax is right
08:56:48 <ski> so if we assume that the only possibly way that we could have `Eq (a,b)' is by constructing that from `(Eq a,Eq b)' (by the aforementioned instance), then we can safely (i.e. without invalidating possibly valid programs) replace the constraint `Eq (a,b)' in a type signature with the `(Eq a,Eq b)' constraint
08:57:19 <bastl> why is there no simple constructore "ModuleName [String]" ?
08:57:26 <ski> .. as still know we'll still get every solution (one or zero)
08:57:31 <ski> s/as/and/
08:57:37 <dcoutts> bastl: because it'd let you construct invalid module names
08:57:45 <bastl> i see
08:57:53 <lilac> ski: yeah, if we assume no overlapping instances, then instance X => Y means X <=> Y
08:58:02 <bastl> but i can do the same when using strings !?
08:58:09 <dcoutts> bastl: it's checked
08:58:14 <bastl> ah not, the parser checks for errors
08:58:17 <bastl> i see
08:58:20 <ski> lilac : right
08:58:26 <bastl> ok thx once more
08:58:36 <dcoutts> bastl: sorry for the confusing api :-)
08:58:46 <dolio> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9223#a9223
08:58:47 <lilac> ski: arguably if an instance is 'overlap-ok', we shouldn't reduce it to the instance's context
08:58:55 <dcoutts> bastl: in 1.8 the 'simple' is marked deprecated and there's the new fromString
08:59:02 <ski> so why doesn't the type system take advantage of this, in instance resolution such as in <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8419> ?
08:59:20 <EnglishGent> @hoogle tagsoup
08:59:21 <lambdabot> package tagsoup
08:59:37 <bastl> dcoutts: understandable, when there are few users. in fact, it quite well documented.
08:59:45 <ski> lilac : that might be one way out .. (i've pondered something similar for LP)
09:00:01 <bastl> (but of course i stumbled at the only place which wasnt :-) )
09:00:22 <lilac> ski: the problem in 9223 is simply that you have no show for your existential b, isn't it?
09:00:30 <dcoutts> bastl: :-)
09:00:36 <lilac> ski: no wait...
09:00:58 <ski> lilac : afaics, it is that we can't go from `Show (a,b)' to `(Show a,Show b)'
09:01:01 <dcoutts> bastl: the module is now documented in Cabal-1.8
09:01:10 <lilac> ski: right, sorry, misread :)
09:01:20 <lilac> ski: (thoguht it was B :: F a -> F b -> F a)
09:01:37 <ski> i.e. we have no way to "take apart" any instance `Show (a,b)' into its constituent instances `Show a',`Show b'
09:01:57 <hackagebot> PortMidi 0.1.2 - A binding for PortMedia/PortMidi (PaulLiu)
09:02:02 <lilac> ski: operationally that makes sense, though
09:02:34 <ski> if we affirm that we want `(Show a,Show b) <=> Show (a,b)', then one might possibly represent an instance of the right-hand side as just a pair of the two instances in the left-hand side
09:02:39 <ski> so that we can project back
09:02:43 <lilac> the dicts for Show a and Show b might have been inlined into the Show (a, b) dict
09:02:57 <hackagebot> hecc 0.1 - Elliptic Curve Cryptography for Haskell (MarcelFourne)
09:03:12 <lilac> ski: this is why it's => not <=> i guess :)
09:03:16 <ski> whenever we want to actually use `Show (a,b)' we can apply the `instance (Show a,Show b) => Show (a,b) where show (a,b) = ...' implementation at that point
09:03:51 <bastl> dcoutts: cool it works now :-) This is quite powerful. One could do a lot of things using haskell (instead of make,bash etcpp)
09:03:54 <ski> so it seems that one could probably implement this ..
09:04:05 <lilac> ski: operationally, a dict-passing implementation needs a uniform representation of 'Show a' for all a.
09:05:33 <lilac> ski: suppose Show a is implemented as: 'data ShowDict a = ShowDict { show :: a -> String }'
09:05:58 <lilac> how is GHC to take a ShowDict (a, b) apart and get a ShowDict a?
09:05:58 <ski> lilac : what if that representation is `exists x. (EqDict x,x -> a -> String)', where `EqDict' has a constructor `EqDict :: forall a b. EqDict a -> EqDict b -> EqDict (a,b)' (and no other constructor with a pair type in the result type) ?
09:06:28 <ski> er
09:06:57 <ski> `(EqDict a,EqDict a -> a -> String)', that should be, actually
09:07:35 <lilac> what's this EqDict thing about?
09:08:01 <ski> then if we by other means discover that `a' there actually is the type `(b,c)', then since we know `EqDict' has no other constructor which could construct `EqDict (b,c)' than `PairDict' (sorry, the constructor before should be named `PairDict')
09:08:33 <lilac> why should the ShowDict type know anything about pairs?
09:08:50 <ski> then we can pattern-match on the first component of the pair, of type `EqDict (b,c)' and extract `EqDict a' and `EqDict b'
09:09:08 <lilac> ski: open-world assumption... you can't have a constructor per instance.
09:09:26 <ski> lilac : this would have to be something a bit similar to GADTs in that the result type parameters doesn't have to be type variables
09:09:43 <ski> .. but it would probably require `EqDict' to be an open type, as you say
09:09:48 <quicksilver> dolio: cute
09:09:54 <quicksilver> dolio: that wasn't even difficult ;)
09:10:12 <lilac> ski: so you're adding something akin to Typeable to the dict too then?
09:10:43 <jethr0> Binary gives me a ByteString.Lazy, whereas Network.Socket.ByteString expectsa ByteString. is there a better way than doing:
09:10:44 <ski> i was not thinking about `Typable', and i'm not sure that would help anyway
09:10:56 <lilac> ski: how else are you going to do an 'open type'?
09:11:18 <jethr0> "BS.concat . LBS.toChunks" and "LBS.fromChunks . (:[])"?
09:11:25 <lilac> (where you can recover the original value if you know the type)?
09:11:27 <ski> i was thinking of having `EqDict' be an open type (which doesn't exists in haskell atm (unless `data family' can be used for this purpose, hmm ..))
09:11:43 <jethr0> these two solution create a lot of allocated memory, that is really unnecessary
09:11:47 <ski> lilac : .. sorry, which original value ?
09:12:11 <Saizan> jethr0: no, there isn't, and in fact the conversions are costly
09:12:11 <lilac> the original Show a and Show b dicts
09:12:16 <Lemmih> jethr0: Send the lazy bytestring in chunks?
09:12:18 <ski> ok
09:12:38 <ski> (somehow `ShowDict' got transformed into `EqDict' above, btw ..)
09:12:58 <lilac> ski: i think the problem is i haven't the slightest understanding of how you're trying to implement instance-passing
09:13:02 <quicksilver> ski: then there must be an instance Show a => Eq a ;)
09:13:02 <jethr0> Lemmih: what do you mean?
09:13:15 <ski> quicksilver ;)
09:13:19 <bastl> at all: in my main-action, I want to delegate to a special "mymain :: IO ()". How could i remove the head of "getArgs" before and pass only the tail to mymain ??
09:13:31 <Lemmih> jethr0: mapM_ send . toChunks
09:13:35 <quicksilver> jethr0: instead of calling "send (BS.concat . LBS.toChunks)"
09:13:39 <jethr0> Saizan: isn't that a bit of a design flaw then?
09:13:42 <ski> lilac : ok. (trying to clear up my thoughts a bit)
09:13:45 <quicksilver> jethr0: just call mapM_ send (LBS.toChunks bs)
09:13:48 <quicksilver> ah, Lemmih said :)
09:13:59 <quicksilver> and don't worry about the other direction.
09:14:01 <ski> (.. renaming things for better clarity)
09:14:05 <jethr0> Lemmih: ok, and that prevents allocating all that unnecessary memory?
09:14:06 <quicksilver> LBS.fromChunks . (:[]) is a trivial cost.
09:14:19 <bastl> ah, System.withArgs
09:14:24 <Twey> @seen Apocalisp
09:14:24 <lambdabot> Unknown command, try @list
09:14:30 <Twey> What happened to @seen?
09:14:30 <Lemmih> jethr0: It should.
09:14:48 <lilac> ski: in my mind the key issues are 1) that Show (a,b) needs the same representation as Show (Maybe a) and Show Int, in order to be usable in polymorphic contexts with a module-at-a-time compiler
09:14:50 <ski> lilac : we want a type for dictionaries for `Show a', for any `a' .. let's call that `ShowDict a'
09:14:52 <benmachine> Twey: it got disabled, I think it was memory-leaking or something
09:15:08 <jethr0> Lemmih: ok, for TCP this works, but for UDP (where i am sending complete datagrams) this is not really an ideal solution, if any
09:15:11 <lilac> ski: and 2) a Show (a,b) representation need not contain a Show a or Show b representation (they can, and often should, be inlined)
09:16:03 <lilac> ski: ok. so we desugar "foo :: Show a => F a -> String" into "foo :: ShowDict a -> F a -> String"
09:16:28 <ski> yes
09:16:34 <ski> now, i define `data ShowDict a = MkSD {showInst :: ShowInst a,show :: ShowInst a -> a -> String}'
09:16:51 <jethr0> in the "Network" doc it says "For really fast I/O, it might be worth looking at the hGetBuf and hPutBuf family of functions in System.IO. "
09:16:56 <ski> or maybe we should rename to
09:17:03 <jethr0> is that a viable alternative to network-bytestring?
09:17:12 <quicksilver> jethr0: I doubt it's better
09:17:15 <ski>   data ShowDict a = MkSD {showInst :: ShowInst a,getShow :: ShowInst a -> a -> String}
09:17:20 <quicksilver> it probably performs similarly
09:17:26 <quicksilver> but bytestring has fusion and stuff
09:17:29 <quicksilver> which Ptrs do not.
09:17:31 <ski> the definition of `show' now is
09:17:44 <Twey> benmachine: Huh.
09:17:50 <ski>   show :: forall a. ShowDict a -> a -> String
09:18:04 <jethr0> well, then i am still stuck with not being able to send UDP datagrams from Binary...
09:18:14 <ski>   show dict = getShow dict (showInst dict)
09:18:28 <ski> lilac : ok, so far ?
09:18:37 <lilac> ski: looking good so far
09:18:43 <jethr0> since "mapM_ send toChunks" is not very datagram compatible (unless i let bytestring-lazy vs. bytestring dictate my packet format
09:18:48 <ski> (the generalization to multiple members of the class should be evident~)
09:19:04 <lilac> (it's more complex than the 'traditional' way but i'm waiting for the payoff...)
09:19:12 <jethr0> ;(
09:19:31 * ski ponders
09:19:55 <ski> (as you might suspect, i'm trying to think this through as i go ..)
09:19:58 <quicksilver> jethr0: the basic problem here is insurmountable, I think.
09:19:59 <Lemmih> jethr0: Poke the network-bytestring maintainer and ask him to add support for lazy bytestrings.
09:20:02 * EnglishGent wonders what it is that ski ponders
09:20:04 <jethr0> i could use socketToHandle and write to that with ByteString.Lazy.hPutStr...
09:20:10 <dolio> @brain
09:20:11 <EnglishGent> :)
09:20:11 <lambdabot> I think so, Brain, but Lederhosen won't stretch that far.
09:20:19 <quicksilver> Lemmih: I don't think you can avoid this problem.
09:20:30 <quicksilver> Lemmih: if you have a lazy bytestring (some chunks) and you want to send it as one datagram
09:20:36 <quicksilver> Lemmih: you will have to pay the cost of one copy.
09:20:38 <ski> EnglishGent : how to implement `instance (Show a,Show b) <=> Show (a,b) where show (a,b) = ...'
09:20:48 <Lemmih> quicksilver: Aren't we just trying to avoid an intermediate bytestring before copying it over to the OS buffer?
09:20:52 <quicksilver> Lemmih: that copy might as well be BS.concat
09:21:18 <quicksilver> Lemmih: I don't think so. network-bytestring can give the OS a direct pointer to its bytestring.
09:21:21 <jethr0> when i use BS.concat, that single call will contribute 20% of memory usage of my whole game
09:21:23 <EnglishGent> concatenate the results?
09:21:38 <quicksilver> (as long as it is contiguous, which only strict bytestrings are)
09:21:50 <ski> EnglishGent : note the `<=>'. the `<=' direction is what i'm pondering
09:21:58 <EnglishGent> actually - that's a newbie question I dont know the answer to ... could one provide a default for something like that - and override in specific cases?
09:22:01 <quicksilver> Lemmih: the OS may copy it again, or it may not, but either way that's outside our control :)
09:22:19 <EnglishGent> in effect saying 'unless I say otherwise concat the results'
09:22:23 * jethr0 doesn't understand why conversion from lazy to strict produces any intermediate structure at all. can't you just force rnf of the lazy bytestring?
09:22:34 <quicksilver> jethr0: lazy is a list of chunks
09:22:40 <quicksilver> jethr0: strict is just one big chunk
09:22:45 <quicksilver> jethr0: you have to copy.
09:23:19 <Lemmih> jethr0: Perhaps the strict binary library could help.
09:23:40 <quicksilver> jethr0: a lazy bytestring is not contiguous in memory, whilst a strict one is.
09:23:52 <jethr0> hmm, still seems ridiculous to have such diametrically different concepts without automatic free conversion functions.
09:24:04 <ski> lilac : the idea was to both have to cake and eat it. i.e. to both be able to extract `show :: (a,b) -> String' from `ShowDict (a,b)', but also to still have `ShowDict a' and `ShowDict b' stored so they can be accessed, if needed
09:24:04 <quicksilver> how can their be a free conversion function?
09:24:12 <wmealing> just wondering, anyone here use eclipse with haskell ?
09:24:19 <quicksilver> how do you expect to turn non-contiguous data into contiguous for free?
09:24:25 <int-e> jethr0: they are different data structures
09:24:25 <quicksilver> surely that's a definite copy?
09:24:26 <jethr0> quicksilver: ok, i get that, but for many functions shouldn't care about contiguousness. basically it's a performance tweak to rely on the contiguousness.
09:24:36 <quicksilver> many functions don't care about it.
09:24:41 <quicksilver> but UDP send does!
09:24:45 * ski thinks that possibly this idea doesn't work out, at least not without changing it somehow
09:24:54 <quicksilver> or at least, UDP send has to assemble it all into a contiguous location at some point.
09:25:03 <int-e> conversion from strict to lazy is essentially free. (fromChunks . ([]:) or so)
09:25:06 <ski> anyway, if we instantiate `a' above to `(a,b)' in the definition of `ShowDict' we get
09:25:08 <jethr0> quicksilver: actually, all functions in BS care about it, because they require a strict/lazy bytestring to begin with, no?
09:25:30 <int-e> but the other direction obviously needs to copy the whole string, nothing can be shared.
09:25:30 <quicksilver> well yes. They deal with the internals
09:25:32 <ski>   data ShowDict (a,b) = MkSD {showInst :: ShowInst (a,b),getShow :: ShowInst (a,b) -> (a,b) -> String}
09:25:35 <quicksilver> so they have to know what they have.
09:25:43 <jethr0> can't i have a bytestring lazy that contains exactly one chunk?
09:25:54 <jethr0> [chunk]
09:25:56 <quicksilver> yes.
09:25:59 <int-e> (the trivial case of a single-chunk lazy bytestring aside, and I believe that case is actually optimized)
09:26:03 <quicksilver> that's what you get from fromChunks . (:[])
09:26:18 <jethr0> can i tell bytestring.lazy to generate just one chunk?
09:26:20 <ski> so the `getShow :: ShowInst (a,b) -> (a,b) -> String' looks good .. this should correspond to the `..a.b..' code in `instance ... where show (a,b) = ..a.b..'
09:26:37 <jethr0> yes, but i get my bytestring from Binary, which probably generates many chunks to begin with
09:26:49 <int-e> right, it would.
09:27:06 <EnglishGent> ski - thinking about your question... it seems to me that (Show a, Show b) => Show (a,b) -- but not necessairly the other way round
09:27:09 <ski> i.e. it is given the two `Show a',`Show b' instance dictionaries inside the argument `ShowInst (a,b)', as i wanted
09:27:30 <ski> EnglishGent : we're assuming overlapping instances are disallowed
09:27:31 <quicksilver> I thought the Put monad generated rather large chunks by default
09:27:44 <quicksilver> like, 64K or something?
09:28:03 <quicksilver> isn't that almost the entire point the Put monad exists, to generate large chunks
09:28:04 <EnglishGent> I can imagine writing a function implementing show (a,b) - even where either a is not an instance of Show, or b is not an instance of Show (but not both)
09:28:17 <quicksilver> (where a naive ByteString outputter would generate a concat of lots of small ones)
09:28:56 <ski> so the question then is, how do we extract `ShowDict a' and `ShowDict b' from `ShowInst (a,b)' ?
09:28:58 <int-e> Also Put on strict bytestrings would have horrible characteristics - you'd have to find the length before creating any data, if you want to avoid copying the data (to grow a buffer) anyway.
09:29:31 <ski> i can see how we can extract `ShowInst a' and `ShowInst b' from `ShowInst (a,b)', assuming `ShowInst' is a different type from `ShowDict'
09:29:55 <ski> if `ShowDict' and `ShowInst' was the same type, then in
09:29:59 <ski>   data ShowDict (a,b) = MkSD {showInst :: ShowInst (a,b),getShow :: ShowInst (a,b) -> (a,b) -> String}
09:30:28 <ski> .. hm !?
09:30:47 <ski> ok, let's assume we have a constructor
09:31:28 <ski>   MkShowPairInst :: forall a b. (ShowDict a,ShowDict b) -> ShowInst (a,b)
09:31:57 <ski> (and also assume that no other constructor for `ShowInst' has a result type of form `ShowInst (..,..)')
09:32:58 <ski> this means that if we are given an `ShowDict (a,b)', then the `showInst' field of that has type `ShowInst (a,b)' and therefore must be of the `MkShowPairInst' constructor form
09:33:27 <ski> .. so we can then extract `(ShowDict a,ShowDict b)' from that field, as wanted
09:33:50 <int-e> but in reality you'll have mkShowPairInst :: forall a b. (ShowDict a,ShowDict b) -> ShowDict (a, b), wouldn't you?
09:33:51 <ski> that implements `forall a b. Show (a,b) => (Show a,Show b)'
09:34:03 <quicksilver> jethr0, Lemmih : yes, 32K chunks; it uses Data.Binary.Builder
09:34:31 <ski> int-e : why lower case `m' in `mkShowPairInst' ?
09:34:35 <ski> it should be a constructor
09:34:47 <lilac> ski: what i thought you were doing at first was something more like: data ShowDict a = ShowDict { show :: a -> String; otherStuff :: OtherStuffFor a }, with OtherStuffFor a being a type family
09:34:55 <jpcooper> hello
09:35:03 <int-e> ski: to make it a function.
09:35:09 <jpcooper> could anyone tell me why IO (Just "caught") isn't returned from: catch (return $ fromJust Nothing) (const . return $ Just "caught") ?
09:35:12 <ski> lilac : it might be that `ShowInst' can be a type family .. i don't know
09:35:14 <lilac> ski: with "data instance OtherStuffFor (a, b) = (ShowDict a, ShowDict b)"
09:35:16 <int-e> ski: I changed the result type to.
09:35:18 <int-e> too
09:35:31 <lilac> ski: you don't need to pass ShowInst to getShow, AFAICS
09:35:33 <ski> lilac : i'm just trying to determine under what conditions in the types this might work
09:35:35 <dolio> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9226#a9226
09:35:51 <int-e> ski: also I have only glanced at the discussion, I'm probably heading into the wrong direction.
09:36:28 <ksf> strange.
09:36:29 <ski> (it's probably more of a monologue/rambling on my part than a discussion, atm)
09:36:40 <ksf> ecmascript doesn't seem to know integral types.
09:36:44 <ksf> double is all it knows.
09:37:21 <jpcooper> anyone?
09:37:41 <ski> lilac : for i while i thought i would have to make `ShowInst' and `ShowDict' equal .. and that would break the idea, since it can't both be the specific record type above, *and* a variant type (with one constructor for each instance)
09:37:44 <int-e> jethr0: you could also send the bunch of chunks in sequence yourself, couldn't you? (hmm, he's gone.)
09:37:58 <EnglishGent> hi jpcooper
09:37:58 <ski> but it seems it might work to make the two types mutually recursive
09:38:04 <jpcooper> hello EnglishGent
09:38:06 <lilac> ski: if you change class Show to: 'class Show a where data family ShowStuff a :: *; showStuff :: ShowStuff a; show :: a -> String' then you can do 'instance (Show a, Show b) => Show (a, b) where data instance ShowStuff (a, b) = ShowStuffPair (a -> String, b -> String); showStuff = (show, show); ...'
09:38:20 <Lemmih> jpcooper: You're not forcing the exeption.
09:38:49 <Lemmih> jpcooper: Try: (evaluate $ fromJust Nothing)
09:38:52 <lilac> ski: the compiler could in principle automate that transformation i think
09:39:02 <jpcooper> @hoogle evaluate
09:39:02 <lambdabot> Control.Exception evaluate :: a -> IO a
09:39:02 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
09:39:12 <jpcooper> thanks
09:39:17 <Lemmih> jpcooper: And make sure you're using the 'catch' from Control.Exception.
09:39:23 <jpcooper> oh
09:40:23 <ski> lilac : where `ShowStuffPair' is defined, how ?
09:40:28 <int-e> lilac: right, at the cost of a bigger Show dictionary.
09:40:48 <ski> .. oh, `data instance'
09:40:57 * ski was thinking `type instance'
09:42:31 <jethr0> sry, seems i was disconnected for a while
09:42:36 <jethr0> hmm, ok, i understand the situation. thank you very much for your help.
09:42:43 <jethr0> i'm not entirely happy with libraries "forcing" me into either bytestring.lazy/strict and another library depending on the exact opposite. i think in the long run this will become a bit annoying
09:42:44 <ski> lilac : what if `a' itself there happens to be a pair type `(a0,a1)', then you should also store `ShowStuff a' somewhere (to simulate the `Show a0' and `Show a1' instances)
09:42:47 <ski> ?
09:42:55 <quicksilver> jethr0: yes, I 100% agree that is annoying
09:43:04 <jethr0> there should probably be a library-default for the majority of cases
09:43:11 <quicksilver> jethr0: I was only explaining why you couldn't expect a zero-cost copy from one to the other.
09:43:12 <jethr0> or automatically derived lift-like functions that bridge the divide for all those BS-functions that don't care whether arg. is lazy or not
09:43:16 <jethr0> maybe have a ByteString.Common with all the functions that can work with either, or sth.
09:43:35 <quicksilver> I think network-bytestring should work with both types
09:43:42 <quicksilver> I understand why binary only works with one.
09:43:45 <jethr0> yes, and i was thinking that many functions could force the rnf of a lazy stream to some extent
09:44:21 <quicksilver> I suspect the network-bytestring author was mainly thinking of streaming and thus TCP
09:44:23 <jethr0> maybe not, just venting really
09:44:28 <quicksilver> where lazy is definitely the natural choice
09:44:49 <int-e> out of curiousity, is there writev support for lazy bytestrings?
09:44:54 <quicksilver> int-e: no.
09:44:59 <quicksilver> (Im' pretty sure)
09:45:02 <jethr0> on another note, i just benchmarked "threadDelay" on windows and it is pretty appaling
09:45:03 <int-e> ok
09:45:05 <lilac> int-e: yes, at the cost of a bigger Show dictionary. we want it to contain more information, so that seems almost unavoidable ;)
09:45:18 <jethr0> i am using for frame rate limiting and the results are pretty bad.
09:45:41 <quicksilver> int-e: although someone was working on something related.
09:45:53 <quicksilver> jethr0: threaded RTS or non-threaded? what does 'appaling' mean?
09:46:36 <jethr0> i get a huge std. deviation from threadDelay (and not only that it takes longer, but also that it seems to pause much shorter than told)
09:46:36 <jethr0> writev?
09:46:37 <jethr0> bad. not sure how to spell that ;)
09:46:46 <lilac> int-e: i don't suppose it's normal for a program to spend much memory on typeclass dictionaries anyway so i don't think it's likely to matter
09:46:47 <ski> dolio : if you add a member of type `ShowDict a' to that class, then your class appears to correspond to my `ShowDict' type, and your `ShowDict' type appears to correspond to my `ShowInst' type
09:46:49 <jethr0> i benchmarked it for threaded, because with non-threaded my program runs rather choppily
09:46:51 <quicksilver> int-e: maybe I'm wrong
09:46:52 <jethr0> under windows
09:46:53 <quicksilver> int-e: "network-bytestring [1] includes a FFI wrapper for iovecs that might be
09:46:54 <quicksilver> useful to look at. "
09:46:57 <quicksilver> int-e: maybe it does.
09:47:08 <int-e> quicksilver: it just seems like a neat idea, for a rather small niche, although the match isn't perfect.
09:47:14 <quicksilver> jethr0: please be more precise. Huge? 10ms? 20ms? 100ms?
09:47:21 <int-e> quicksilver: ok. thanks
09:47:39 <quicksilver> int-e: but you can't use iovec with UDP, I don't think?
09:47:54 <jethr0> DELAY 	-threaded 	  EXPLICIT GC - mean: 93.87, stdDev: 39.19
09:47:54 <jethr0> DELAY 	-threaded 	NOEXPLICIT GC - mean: 74.84, stdDev: 29.71
09:47:54 <jethr0> BUSY 	-threaded 	  EXPLICIT GC - mean: 62.60, stdDev: 6.99
09:47:58 <jethr0> BUSY 	-threaded 	NOEXPLICIT GC - mean: 62.59, stdDev: 7.60
09:47:58 <jethr0> YIELD 	-threaded 	  EXPLICIT GC - mean: 62.51, stdDev: 6.76
09:47:59 <jethr0> YIELD 	-threaded 	NOEXPLICIT GC - mean: 62.70, stdDev: 8.70
09:48:04 <jethr0> this is average framerate (fps) and std deviation on windows
09:48:10 <jethr0> target framerate is 60
09:48:26 <int-e> lilac: right. the only case where it would actually hurt is single-element dictionaries (which are stored like newtypes, without an extra indirection for a tuple)
09:48:31 <quicksilver> sounds like standard low-resolution windows timer.
09:48:49 <ski> dolio : hm .. and i assume `data instance ShowDict (a,b) = ..a.b..' guarrantee that there can be no more constructors with result type matching `ShowDict (..,..)' than those mentioned in `..a.b..' there .. which sounds like whati wanted :) thanks
09:48:51 <quicksilver> the windows timer only has an accuracy of 1/50 Hz or something doesn't it?
09:48:53 <jethr0> DELAY = threadDelay, BUSY = busy waiting, YIELD = busy waiting with yield
09:49:14 <jkr> Hello
09:49:16 <jethr0> the documentation says that the delay can be longer than given, but shouldn't be shorter
09:49:21 <int-e> lilac: and, of course, configuration-like code, which would suddenly have to keep all intermediate dictionaries around, which might normally be garbage-collected.
09:49:26 <jethr0> but it is often also shorter...
09:49:38 <jkr> Is there a way to operate on both elements of a tuple in pointfree syntax?
09:50:00 <ski> (having a member of type `ShowDict (..,..)' ought to mean that your `dpToPd :: ShowDict (a,b) -> (ShowDict a, ShowDict b)' conversion can be implicit on implicit class dictionaries, i think ..)
09:50:04 <quicksilver> jethr0: I thik in the past I've used GLUT's timercallback which is more accurate
09:50:07 <jethr0> quicksilver: is there an alternative to threadDelay? can't be that windows has NO high-resolution timer...
09:50:18 <quicksilver> jethr0: other GUI libraries typically also contain highresolution timer callbacks
09:50:27 <ski> (i.e. effectively to go from `Show (a,b)' to `Show a' and `Show b')
09:50:32 <jkr> I'm trying to do someting lie this: (length . fst, length . snd) . somethingThatReturnsATuple
09:50:58 <int-e> lilac: (by configuration-like code I mean code building a pseudo-ADTs of phantom types with corresponding type class instances, like type level natural numbers, data Z; data Succ a)
09:51:02 <travisbrady> what's the idiomatic way to sort a map by the values descending?
09:51:18 <jethr0> i am writing a cross-toolkit game and thus am using only functionality that exists in all toolkits or use standard haskell functions
09:51:47 <Botje> travisbrady: sortBy (compare `on` snd) . assocs ?
09:51:52 <jethr0> i'll have a look, if SDL, GLUT, GLFW all have timers and how to use them for delay
09:51:55 <Botje> oh, descending.
09:51:57 <quicksilver> > (length . fst &&& length . snd) ("foo","bar")
09:52:01 <lambdabot>   (3,3)
09:52:02 <quicksilver> jkr: ^^
09:52:02 <Botje> travisbrady: sortBy (flip compare `on` snd) . assocs ?
09:52:19 <quicksilver> jkr: although (length *** length) ("foo","bar") is more natural
09:52:24 <Lemmih> > (length *** length) ("foo", "bar")
09:52:27 <lambdabot>   (3,3)
09:53:12 <quicksilver> jkr: there are also RTS options to tune various things
09:53:18 <int-e> @type join(***)length
09:53:20 <lambdabot> forall a. ([a], [a]) -> (Int, Int)
09:53:21 <quicksilver> jkr: that was for jethr0
09:53:31 <quicksilver> jethr0: there are also RTS options to tune various things although I don't *think* that's your problem here
09:53:36 <quicksilver> jethr0: -C0 and things.
09:53:44 <travisbrady> @type assocs
09:53:46 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
09:53:46 <jethr0> quicksilver: k, i'll look into that
09:53:46 <quicksilver> jethr0: I think you're better off seeking a high resolution timer though :)
09:53:54 <travisbrady> Botje: thanks
09:54:18 <jethr0> i had just hoped that there would be such a timer/delay in haskell w/o toolkit dependencies somewhere ;(
09:54:48 <jethr0> thx quicksilver, so the threadDelay under windows is a known issue then. maybe we should add a comment about it in the documentation
09:56:12 <lispy|web> is lambdabot down?
09:56:17 <lilac> @bot
09:56:17 <lambdabot> :)
09:56:17 <lunabot>  :o
09:56:20 <lispy|web> hmm
09:56:36 <lispy|web> The server running lambdabot is refusing any connections for me
09:56:42 <lispy|web> web or ssh
09:57:37 <ksf> sheesh. girls need some privacy, too.
09:58:06 <lispy|web> Cale: ping?
09:58:40 <Twey> ksf: Hehe
09:59:19 <ksf> @vixen can I have your phone number?
09:59:19 <lambdabot> I've never canceled a subscription to a newspaper because of bad cartoons or editorials. If that were the case, I wouldn't have any newspapers or magazines to read.
09:59:34 <Twey> Heh
09:59:39 <ksf> @vixen am I supposed to understand the context?
09:59:39 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
09:59:40 <lispy|web> that's a good one
10:00:19 <ksf> @vixen why are you refusing connections from lispy?
10:00:19 <lambdabot> I believe in the battle-whether it's the battle of a campaign or the battle of this office, which is a continuing battle.
10:00:38 <ksf> now that says all.
10:00:52 <lament> that's not vixen...
10:01:02 <lament> what happened to vixen we all know and have a crush on?
10:01:09 * DrSyzygy snickers. "There's a special place we put people who implement fmap for (PFix b) as a pfold: it's called Oxford."
10:01:19 <Botje> O_o
10:01:33 <lilac> DrSyzygy: i rather liked that line :)
10:01:37 <lament> @vixen Who's your favourite computer scientist, is it Haskell Curry?
10:01:38 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
10:01:40 <DrSyzygy> I find it hilarious.
10:01:41 <lament> :(
10:02:05 <ksf> seems she's confusing herself with nixon.
10:02:07 <ziman> @nixon tell me something!
10:02:07 <lambdabot> I reject the cynical view that politics is a dirty business.
10:02:13 <ksf> a lobotomy might help.
10:02:41 <lament> that's... serious, isn't it?
10:05:18 <ksf> oh, that wonderful balmer-peak.
10:05:34 <ksf> you know where it is as soon as you've drank one sip of beer too much.
10:05:47 <ziman> in that case you know where it /was/ :)
10:06:07 <ksf> shhh. artistic freedom.
10:06:32 <ksf> the reader has to be coerced into believing you actually can hit it right on, only to be lead to catharsis half a sentence later.
10:07:01 <travisbrady> I've hoogled but can't find how to ByteString-ify an Int, is it just pack . show ?
10:07:18 <ksf> travisbrady, exactly.
10:07:25 <ziman> or you can use Data.Binary
10:07:34 <ksf> I was just about to say that.
10:07:48 <ziman> you still can, this is #haskell ;)
10:08:37 <dons> travisbrady: what format ?
10:08:51 <dons> pack (show x) or encode x (in binary form).
10:09:07 <dons> the bytestring-show package
10:09:32 <travisbrady> dons: just ascii, i'm basically writing a few simple log analysis tools I'd normally do w/ Python
10:12:53 <lilac> travisbrady: you'll want pack from Data.ByteString[.Lazy].Char8 iirc
10:13:01 <lilac> there are at least two other bytestring packs which don't do what you want
10:13:07 <dons> pack (show x)
10:13:18 <dons> lilac: ?
10:13:35 <lilac> dons: Data.ByteString has pack :: [Word8] -> ByteString last time i looked
10:13:49 <dons> oh, 'doesn't do what you want' == doesn't take the argument you want to give it.
10:14:02 <lilac> right :) i could have been clearer
10:14:30 <lilac> incidentally, why does bytestring have lots of functions with the same name? it forces me to write nice code with qualified imports! :)
10:16:40 <dolio> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9226#a9227 is probably a little more like what you'd want going on.
10:17:48 <dolio> Although I blew the Char version of showList.
10:17:53 * dolio goes to get some lunch.
10:18:18 <ski> dolio : yes, i think so
10:18:45 <ski> (i just noticed that yout earlier `ShowDict' was directly recursive, which wasn't quite what i was thinking about)
10:19:40 <ski> dolio : your `Hax' looks like my `ShowInst'
10:19:59 <yrlnry> Why do I get the error "invalid type signature" when I do    class Comonad m where  v >== f :: m a1 -> (m a1 -> a) -> a
10:20:34 <ski> dolio : you can write `dpToPd :: ShowDict (a,b) -> (ShowDict a , ShowDict b)'
10:20:51 <ski> but can you go from  Show' (a,b)  to  Show' a  and  Show' b  ?
10:20:58 <lilac> yrlnry: that's not how you give a type signature :)
10:21:03 <ski> maybe one attempt would be
10:21:11 <lilac> yrlnry: (>==) :: m a1 -> (m a1 -> a) -> a
10:21:33 <lilac> yrlnry: if it were legal, that would be annotating a type on the expression (v >== f)
10:21:49 <lilac> (and actually that is legal in a number of other contexts, but not this one)
10:21:56 <yrlnry> Oh, whoops.  Thanks.
10:22:05 <ski>   dpToPd_cps :: forall a b o. ((Show' a,Show' b) => o) -> (Show' (a,b) => o)  -- would this type signature be allowed ?
10:22:06 <lilac> no problem :)
10:23:19 <ski> yrlnry : what does `forall a1 a. m a1 -> (m a1 -> a) -> a' has to do with a comonad `m' ?
10:23:48 <lilac> indeed, >== looks like flip id
10:24:10 <ski> yrlnry : maybe you're looking for `(=>>) :: Comonad w => w a -> (w a -> b) -> w b' ?
10:24:56 <DrSyzygy> Is [] a comonad, btw?
10:25:00 <DrSyzygy> In an obvious way?
10:25:10 <ski> no
10:25:12 <quicksilver> no, what would extract be>?
10:25:16 <lilac> head
10:25:17 <lilac> :)
10:25:21 <ski> not total
10:25:23 <DrSyzygy> But head requires non-empty lists.
10:25:25 <quicksilver> often the quickest way to check :)
10:25:27 <quicksilver> exactly.
10:25:33 <DrSyzygy> So we'll need (a,[a]) to get the comonad structure.
10:25:45 <lilac> or an infinite list
10:25:46 <ziman> is an infinite list a comonad?
10:25:47 <ski> iirc, that forms a comonad, yes
10:25:59 <quicksilver> typically we require all methods to be total and all laws to apply only to the total fragment of haskell
10:26:24 <quicksilver> (a,[a]) is not an interesting comonad
10:26:26 <yrlnry> Yes, i meant it to be m a -> (m a -> b) -> m b.
10:26:29 <quicksilver> it's the same comonad as (a,b)
10:26:34 <yrlnry> As I'm sure you know.
10:26:43 <quicksilver> the [a] part isn't doing anything fun that I can see.
10:26:49 <lilac> iirc streams form a comonad too, with  xs =>> f = f <$> tails xs
10:27:10 <lilac> iow cojoin = tails, extract = head
10:27:19 * ski tries to remember whether the comonadic operations were defined in the same way for the causal and the anti-causal comonad
10:28:11 * DrSyzygy was trying to build (a,[a]) to be something that could be given the structure of non-empty lists.
10:28:26 <quicksilver> DrSyzygy: yes, I understood that :)
10:28:34 <DrSyzygy> Still not anything interesting?
10:28:45 <quicksilver> DrSyzygy: but I don't think you'll find an interesting definition of cojoin
10:28:54 <lilac> does tails still work?
10:29:05 <ski>   data Causal a = [a] :> a
10:29:13 <quicksilver> tyhe only think cojoin can do is duplicate the already-distinguished element
10:29:15 <benmachine> :>
10:29:29 <quicksilver> lilac: what about extract = head, cojoin = repeat (going back to streams)
10:29:48 <quicksilver> lilac: that's a really boring one but it satisfies the first law.
10:29:58 <quicksilver> and the second, as far as I can see.
10:30:19 <lilac> fmap head . repeat != id
10:30:31 <quicksilver> oh. duh.
10:30:33 <quicksilver> thanks :)
10:31:10 <lilac> repeat and diag
10:31:37 <ski>   cojoin as0@(as :> a) = loop as a :> as0 where loop [] a0 = []; loop as1@(a1:as) a0 = loop as a1 :> as1
10:31:51 <lilac> (random brain output there, but i think i read you could form a comonad from them somehow)
10:32:09 <quicksilver> lilac: surely that's a monad :)
10:32:32 <ski> (for infinite streams, yes)
10:32:32 <lilac> right. what you said. duh, thanks ;-)
10:33:05 <ski>  extract .  cojoin = id
10:35:07 <ski>      fmap extract (join ([a1,...,an] :> a0))
10:35:11 <ski>   =  fmap extract (loop [a1,...,an] a0) :> extract ([a1,...,an] :> a0)
10:36:07 <ski> hm
10:36:14 <lilac> ski: is that a pointed list comonad?
10:36:25 <ski> i seem to recall so
10:36:30 <ski> i'm trying to check the laws
10:36:43 <lilac> i think i've seen ti before somewhere. possibly sigfpe
10:37:01 <ski> yes .. or the uustale/vene papers
10:38:10 <ski>   split as0@([     ] :> a0) = [] :> as0
10:38:33 <ski>   split as0@((a1:as) :> a0) = split (as :> a1) :> as0
10:38:37 <ski> that's better
10:38:56 <ray> [                                 ]
10:38:56 <lilac> i don't think cojoin . cojoin == fmap cojoin . cojoin
10:38:56 <ski>   extract (as :> a0) = a0  -- obviously
10:39:30 <lilac> actually, yes i do ;)
10:39:54 <ski> (.. or bah, probably need to convert `:>' into `:' while returning ..)
10:43:06 <pen1234> http://www.thaiadpoint.com/tap8.1/bin/redir.php?p=274&l=188&u_id=363435
10:45:33 <benmachine> is the Writer monad useful in persistent processes?
10:45:53 * benmachine is thinking of making a RWS that doesn't have the W
10:47:13 <Lemmih> pen1234: eh?
10:48:34 --- mode: ChanServ set +o Lemmih
10:48:45 --- kick: pen1234 was kicked by Lemmih (Lemmih)
10:49:09 --- mode: Lemmih set +b *!*n=19736@*.revip.asianet.co.th
10:49:10 --- kick: pen1234 was kicked by Lemmih (Lemmih)
10:49:27 --- mode: Lemmih set -o Lemmih
10:50:22 <lilac> @check \ys -> let uncons (x:xs) = (x,xs); cojoin (x,xs) = uncons . init . map uncons $ liftM2 (zipWith (++)) tails inits (x:xs); f <$> (x,xs) = (f x, map f xs) in (cojoin $ cojoin ys) == (cojoin <$> cojoin (ys :: (Int,[Int])))
10:50:26 <lambdabot>   mueval-core: Time limit exceeded
10:58:25 <EnglishGent> is Map a datatype or a type class? I'm looking at the hackage page - and it says 'instances' & lists a bunch which implies a type class -- but also says 'data Map k b' - which implies the former
10:58:32 * EnglishGent confused :|
10:58:46 <mauke> Map is a type
10:59:03 <ben> EnglishGent: It is an instance of other things, maybe
10:59:29 <Saizan> "instances" lists the classes Map is an instance of
11:00:20 <EnglishGent> ah! thanks Saizan :)
11:00:28 <EnglishGent> thanks mauke, ben :)
11:05:03 <FunctorSalad> EnglishGent: there's an attempt to make a typeclass IIRC in the "gmap" package and in some other package ;)
11:06:32 <FunctorSalad> http://hackage.haskell.org/packages/archive/gmap/0.1/doc/html/Data-GMap.html#t%3AMap
11:08:12 <FunctorSalad> this one has a lot of classes... http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison.html
11:08:25 <tommd> A classy library you say?
11:08:54 <tommd> yeah, I never did become an Edison fan, despite two brief flirtations.
11:10:22 <lilac> there's also the tries stuff, which has a typeclass for map-like things
11:10:56 <copumpkin> I do wish we had typeclasses for all the overlapping things
11:11:05 <copumpkin> rather than all those libraries you have to import qualified
11:12:21 <FunctorSalad> were people unable to agree on an official class for this or has it just not been discussed? or has it been concluded to be undesirable?
11:12:46 <FunctorSalad> (some think typeclasses should be used sparingly after all)
11:14:09 <dm``> Does ord return UTF-32?
11:14:34 <dm``> or fromEnum?
11:14:46 <lilac> Char is a unicode codepoint
11:14:59 <lilac> and ord and fromEnum tell you which one :)
11:15:01 <FunctorSalad> > fmap ord ""
11:15:04 <lambdabot>   [8747,8853,8600,8866]
11:15:58 <dm``> But what is the Integer I get back?  Is it UTF-32?  Is ord always lossless, in the sense that chr.ord is always id?
11:17:11 <ray> lilac said exactly what it is
11:17:15 <ray> a codepoint
11:17:40 <dm``> The unicode glossary uses the word code point all over the place, but doesn't define it.  I think it's one of those things that supposed to be so obvious no one tells you what it means.
11:18:09 <burp> the code for a symbol :>
11:18:17 <ray> a code point's just a code point
11:18:39 <mlesniak> Does emacs have some special advantages for Haskell? Currently I use vim but if there are compelling reasons to switch I'd think about it.
11:18:42 <dm``> A code point is an arbitrary precision number?  A 32-bit number?
11:18:46 <ray> no
11:18:49 <burp> :t ord
11:18:51 <lambdabot> Char -> Int
11:19:11 <ray> a code point's like a platonic ideal
11:19:21 <dm``> mlesniac:  I use haskell-mode in emacs.  It is okay, but I find it forces all of my code to the right hand side of the buffer, and it's very hard to keep my lines under 80 characters.
11:19:29 <ray> this is U+whatever, some character
11:19:31 <burp> its not encoding specific
11:19:33 <lament> mlesniak: it has a smartish indentation mode, better than vim
11:19:41 <lament> and i think some ghc interaction?
11:19:49 <trzkril> mlesniak: the haskell-inferior stuff is nice, don't know if there is something like that for vim
11:19:51 <mlesniak> lament, Hmm, that sounds quite interesting
11:20:06 <ray> you are not at the encoding level, you're floating around in abstract land
11:20:07 <lament> but vim also has ghc interaction
11:20:14 <FunctorSalad> mlesniak: you can even keep much of the vi keybindings with viper-mode...
11:20:24 <ray> your chosen ncoding is a way to represent a code point in bits
11:20:27 <ray> encoding
11:20:34 <mlesniak> FunctorSalad, that's quite good :w
11:20:35 <mlesniak> ;-)
11:20:36 <dm``> An Int might be as small as 30 bits, right?  Does this mean there will never be more than 2^30 code points?
11:20:40 <FunctorSalad> (me myself I never used vi but started viper-mode to save my hands...)
11:20:47 <StefanK> what's so good / special about a functor?
11:20:47 <HugoDaniel> today i had to quickly work out a tool to convert some data from one format to another
11:20:50 <HugoDaniel> and i did it in haskell
11:20:54 <ray> don't think about ints
11:21:08 <mlesniak> HugoDaniel, write a blog post about this, sounds intersting
11:21:12 <lilac> dm``: yes, the maximum codepoint is 1114111 iirc
11:21:12 <lament> FunctorSalad: only an emacs user could come up with such a horrible idea. I tried vimode. It's only more confusing because it's kinda the same but often different.
11:21:13 <HugoDaniel> i happen to do a common pattern when developing haskell
11:21:29 <HugoDaniel> i was wondering about better ways to do it
11:21:30 <HugoDaniel> so
11:21:31 <lament> FunctorSalad: some things work, other things don't, constant frustration
11:21:37 <FunctorSalad> lament: there are several customization options though
11:21:54 <ray> there are 17 planes as it happens
11:22:20 <FunctorSalad> 17 outer planes
11:22:22 <ray> but if you think about representations in memory then you're wrong
11:22:30 <dm``> 1114111 < 2^{21}, so is UTF-32 just the 32-bit number encoding the code point?
11:22:33 <ray> that's not what code points are
11:22:36 <HugoDaniel> i usually do this (in ghci): let i = fmap bla (readFile fname), and then i do this: fmap bla2 (fmap bla3 (fmap (bla4 . bla5) i)))))...
11:22:38 <ray> yes
11:22:45 <copumpkin> StefanK: that's an odd way to phrase it
11:22:50 <HugoDaniel> how can i do this better ?
11:23:13 <copumpkin> StefanK: it factors out common patterns of behavior (also known as abstraction) and thus allows you to work more generically
11:23:19 <ski> mlesniak : <http://www.vim.org/scripts/script.php?script_id=2356> might be useful
11:23:24 <ski> @where shim
11:23:24 <lambdabot> http://mapcar.org/haskell/shim/ http://mawercer.de/~publicrepos/shim/
11:23:44 <mlesniak> ski, thanks
11:23:49 <lilac> dm``: right, UTF-32 == UCS-4 and is a wasteful representation for all practical purposes :)
11:23:58 <Lemmih> HugoDaniel: inp <- readFile fname?
11:24:09 <burp> well, you have the advantage of a fixed character size
11:24:22 * ski has no idea how useful that is, though ..
11:24:40 <Alpounet> Just installed xmonad... I'm gonna run it :-)
11:24:50 <dm``> I just need to write some code that encodes a string in a filename.  So to iterate over the caracters, UTF-32 is just fine.
11:24:51 <doubleth1nk_work> Alpounet: xmonad is great!
11:24:58 <doubleth1nk_work> has served me well on my laptops, desktops and my PS3 :)
11:25:20 <lilac> dm``: be warned, GHC's support for unicode IO pre-6.12 leaves something to be desired
11:25:25 <mlesniak> Alpounet, Whenever I run xmonad I miss those nice frames of my theme, but when I have the metacity running i miss xmonad...
11:25:28 <ray> you should probably use what the filesystem uses, though
11:25:55 <ray> ghc did some bad stuff like pretend Chars were Word8s, i hear
11:25:58 <Alpounet> mlesniak, I should enjoy :)
11:26:08 <ray> very bad stuff
11:26:24 <dm``> File system (Unix) uses ASCII, with '/' and '\0' disallowed, as well as file names starting with '.'.
11:26:50 <dm``> Actually, file system allows bytes >= 128, but it makes it kind of a pain to browse.
11:26:59 <HugoDaniel> Lemmih: how ?
11:26:59 <Saizan> is there a release for 6.12 already?
11:27:17 <dm``> But I guess I could do UTF-8 encoding, and just escape '/' and '\0'.  What's the best function for UTF8 encoding?
11:27:30 <Lemmih> HugoDaniel: 'inp <- readFile fname', then 'bla inp'.
11:27:30 <lilac> @hoogle utf8
11:27:31 <lambdabot> package utf8-light
11:27:31 <lambdabot> package utf8-string
11:27:31 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
11:27:34 <ray> the utf8-string library
11:28:19 <dm``> Okay, thanks for the pointers on this.  I'll check out utf8-string.
11:28:21 <ray> well, utf-8 never gives you null bytes except for the actual NUL
11:28:38 <dm``> Right, everything under 128 is a 1-byte UTF8 encoding.
11:29:00 <ray> no, i mean none of the extra bytes for larger things will be 00000000
11:29:10 <ray> they have at least the high bit set
11:29:32 <HugoDaniel> allright, thanks Lemmih :D
11:29:48 <dm``> Exactly.  Meaning if you see a byte that happens to be < 128, then you no that byte is encoding an ASCII character, no matter what came before it.
11:30:15 <ray> more convenient than utf32 where you'd have 0 bytes everywhere
11:30:22 <burp> > Data.ByteString.UTF8.decode ''
11:30:25 <lambdabot>   Not in scope: `Data.ByteString.UTF8.decode'
11:30:33 <burp> '' is expensive.. it takes 3 bytes ;)
11:32:36 <StefanK> what's so great about functors?
11:32:37 <dm``> Wait, this is confusing, because FilePath is a String.
11:32:52 <dm``> How does the system generate file names from Strings?
11:33:43 <StefanK> how does it help me, if I know a function is a functor?
11:34:25 <dm``> A functor has kind * -> *.  A function has kind *.
11:35:05 <StefanK> ?
11:35:26 <StefanK> I've read sth about map (f .g ) = map f . map g
11:35:26 <ben> StefanK: Functions are never functors
11:35:32 <StefanK> oh, ok
11:35:47 <ben> ... wait, that came out wrong
11:35:48 <ben> Nevermind me
11:35:58 <StefanK> ok
11:36:45 <dm``> I kind of found the name "Functor" confusing, as to me it seems more like "Functee".  The point being that a Functor is something you can apply a function to with fmap.
11:36:52 <StefanK> I've read 2 rules about functors ... but they're not helping me at all. What's the use to know that sth is a functor?
11:37:21 <StefanK> > :t fmap
11:37:23 <dm``> It means you can apply a function to it.
11:37:24 <lambdabot>   <no location info>: parse error on input `:'
11:37:35 <c_wraith> @src Functor
11:37:35 <lambdabot> class  Functor f  where
11:37:35 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
11:37:51 <c_wraith> Something being a functor means you can call fmap.  That's it. :)
11:37:53 <dm``> So if Tree is a functor, and f :: Int -> Int, then you can apply f to a Tree of Ints.
11:38:35 <StefanK> so, a functor is a function which takes another function as an arg?
11:38:52 <dm``> No, a Fuctor is a type constructor of kind * -> *.
11:39:23 <c_wraith> @instances Functor
11:39:24 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:39:27 <dm``> Meaning [] (list constructor) is a functor, because you supply another type to get a type:  [Int] is a list of int.
11:39:28 <jeffersonheard> Here's a new one.  Skinning this thing I'm working on to the bare bones, I find that the sequence of computations I'm performing is irrelevant, however none can execute concurrently
11:39:41 <jeffersonheard> Has anyone ever tried to express such semantics before?
11:39:42 <c_wraith> > fmap (+1) [1..5]
11:39:45 <lambdabot>   [2,3,4,5,6]
11:39:46 <byorgey> StefanK: data structures can be functors, it doesn't make sense to say that a function is a functor.
11:39:55 <byorgey> basically.
11:39:57 <c_wraith> > fmap (+1) (Just 5)
11:40:01 <lambdabot>   Just 6
11:40:02 <ben> (->) r is a functor, so whatever
11:40:10 <byorgey> if a data structure is a functor it means you can apply a function uniformly to every element of the data structure.
11:40:16 <ben> > fmap (+1) (+1) 1
11:40:20 <lambdabot>   3
11:40:21 <byorgey> ben: right, that's why I said 'basically'. =)
11:40:35 <cygnus> > fmap (*5) Just 6
11:40:38 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
11:40:38 <lambdabot>    arising from the lite...
11:40:45 <cygnus> hah.
11:40:50 <copumpkin> > fmap (*5) $ Just 6
11:40:52 <cygnus> > (*5) (Just 6)
11:40:52 <byorgey> cygnus: needs parens =)
11:40:54 <dm``> IO is a functor, too, because you can say something like "fmap ord getChar"
11:40:55 <lambdabot>   Just 30
11:40:55 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
11:40:55 <lambdabot>    arising from the lite...
11:41:34 <cygnus> whoops, I just left out fmap.
11:41:35 <cygnus> hah.
11:41:48 <ben> So who do I need to bribe to get a prelude in which (.) = fmap
11:41:54 <ray> yourself
11:41:55 <jeffersonheard> This kind of semantics is fairly important, though, because it's the essence of regions in machine code where instructions can be reordered
11:41:57 <ray> step 1: write it
11:41:58 <c_wraith> Yeah.  A structure being a functor just means that you can use fmap to apply a function to whatever's inside it.  It's not a particularly strong constraint, but it is useful.
11:42:02 <ray> step 2: no implicit prelude
11:42:15 <ben> ray: I was under the impression someone else already took care of step 1
11:42:28 <ray> oh plenty of people have
11:42:37 <jeffersonheard> ben: import Prelude hiding (.)
11:42:44 <jeffersonheard> (.) = fmap
11:42:59 <dm``> Watch out for the monomorphism restriction.
11:43:06 <dm``> You will need to declare the type of (.) as well.
11:43:14 <jeffersonheard> yeah
11:43:19 <jeffersonheard> what dm`` said
11:44:00 <StefanK> fmap        :: (a -> b) -> f a -> f b     I'm having troubles with f a, which I've never seen ... it means a function taking a as argument, now takes b?
11:44:33 <c_wraith> :t fmap
11:44:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:44:38 <noteventime> StefanK: f is some type
11:44:51 <byorgey> StefanK: f is a type constructor, such as  'Maybe' or '[]' (list)
11:44:53 <c_wraith> f is a type variable indicating an instance of Functor
11:45:01 <dm``> StefanK: f a means that f is of kind "* -> *"
11:45:10 <byorgey> for example, if f = Maybe, we have  fmap :: (a -> b) -> Maybe a -> Maybe b
11:45:57 <dm``> StefanK:  http://www.haskell.org/tutorial/classes.html
11:46:30 <noteventime> @hoogle f a -> (a - > b) -> f b
11:46:30 <lambdabot> Parse error:
11:46:30 <lambdabot>   --count=20 "f a -> (a - > b) -> f b"
11:46:30 <lambdabot>                        ^
11:46:41 <noteventime> @hoogle (Functor f) => f a -> (a - > b) -> f b
11:46:41 <lambdabot> Parse error:
11:46:41 <lambdabot>   --count=20 "(Functor f) => f a -> (a - > b) -> f b"
11:46:41 <lambdabot>                                       ^
11:46:48 <ben> ... ideally I build myself a new Functor whose fmap is called (.)...
11:47:03 <dm``> Wow, can you hoogle based on type signature?
11:47:32 <ray> ben: you have map and (.) as methods, defined by default to be each other
11:47:40 <noteventime> dm``: It's what I usually use hoogle for :)
11:47:55 <StefanK> hmm, I think the Maybe example is hopefully enough for my test tomorrow :p
11:47:57 <dm``> And it doesn't matter what letters you use?
11:48:07 <dm``> @hoogle (Functor f) => f a -> (a -> b) -> f b
11:48:08 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:48:08 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
11:48:08 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
11:48:11 <noteventime> Not that I know, no
11:48:12 <ray> @hoggle t -> t1 -> t
11:48:13 <lambdabot> Prelude const :: a -> b -> a
11:48:13 <lambdabot> Data.Function const :: a -> b -> a
11:48:13 <lambdabot> Control.Parallel par :: a -> b -> b
11:48:26 <ray> you don't even need to spell hoogle correctlty
11:48:28 <dm``> @hoogle (Functor a) => a f -> (f -> g) -> a g
11:48:29 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:48:29 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
11:48:29 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
11:48:42 <ray> @hoggle drong -> not cat
11:48:43 <ben> :|
11:48:43 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
11:48:43 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
11:48:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:48:44 <dm``> Awesome!
11:49:17 <ray> note that i said map and not fmap, because why should lists get the good name
11:49:57 <dm``> @hoogle Char -> Int
11:49:57 <lambdabot> Data.Char digitToInt :: Char -> Int
11:49:57 <lambdabot> Data.Char ord :: Char -> Int
11:49:57 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
11:50:04 <ben> ray: Exactly
11:50:04 <copumpkin> @djinn drong -> Not cat
11:50:05 <lambdabot> -- f cannot be realized.
11:50:12 <copumpkin> ray: sorry
11:51:05 <ray> f = id
11:51:16 * ray smacks djinn
11:53:14 <dm``> @src withCAString
11:53:14 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:53:52 <dm``> So I'm trying to figure out what withCstring is going to do to my filepaths when then have non-ascii characters in them.
11:54:01 <dm``> @src castCharToCChar
11:54:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:54:32 <ray> quite possibly the wrong thing
11:55:43 <dm``> castCharToCChar:  "Convert a Haskell character to a C character. This function is only safe on the first 256 characters."
11:55:43 <dm``>  
11:56:58 <dm``> Gross.  So what I could to is convert to UTF8, then re-encode my string as a String (array of chars).  That works today, but if the next version of the library does the right thing, suddenly all my file names will change.
11:57:29 <dm``> I think I'll just roll my own thing and use ord, then escape everything > 128.
11:57:42 <dm``> Basically produce a 7-bit encoding.
12:01:50 <burp> dm`: what about this http://hackage.haskell.org/packages/archive/utf8-string/0.3.5/doc/html/Data-ByteString-UTF8.html
12:03:38 <burp> fromString $ " " -> "\195\188\195\182\195\164 \226\130\172"
12:11:04 <CalJohn_> ghc isn't finding my installation of gtk2hs in /usr/local/lib, what is a good way to fix this?
12:11:30 <dcoutts> CalJohn_: did you re-install ghc since you installed gtk2hs?
12:11:49 <dcoutts> gtk2hs should register itself with ghc automagically when gtk2hs installs
12:13:06 <CalJohn_> Well, I don't know.  I can "make uninstall" in gtk2hs's source directory, and that "make install", if you think that would help?
12:13:39 <dcoutts> CalJohn_: just make install should do, uninstalling isn't necessary and I don't trust it to work :-)
12:14:40 <CalJohn_> dcoutts: still getting the error " Could not find module `Media.Streaming.GStreamer':"
12:14:56 <CalJohn_> :(
12:15:05 <dcoutts> CalJohn_: does ghc-pkg list gtk report that it is registered?
12:15:24 <dcoutts> CalJohn_: and presumably ghc-pkg list gstreamer says it's not registered
12:16:07 <dcoutts> if gtk is registered but gstreamer is not, then it's probably because you didn't select gstreamer support when you configured gtk2hs
12:16:28 <dcoutts> re-run gtk2hs's ./configure and look at which components it says it's going to install
12:16:51 <dcoutts> it'll install all the ones where it can find the appropriate headers etc
12:16:57 <CalJohn_> ok, so gstreamer is not registered
12:17:08 <CalJohn_> i will ./configure again
12:17:18 <dcoutts> so if it says it's not going to build gstreamer, then check you've got the gstreamer dev system packages installed
12:17:54 <dcoutts> you can force it using ./configure --enable-gstreamer (iirc) and it'll fail if it cannot find the gstreamer headers
12:18:27 <CalJohn_> yeah, I've just forced it, and if it fails, i expect it will be time to hunt down gstreamer-dev
12:24:06 <Veinor> @pl \x -> cos x + sin x
12:24:07 <lambdabot> liftM2 (+) cos sin
12:24:15 <Veinor> @pl \x -> cos x + sin x + tan x
12:24:15 <lambdabot> ap ((+) . liftM2 (+) cos sin) tan
12:25:44 <Veinor> ... why does the former work?
12:25:48 <Veinor> @unpl (+) cos sin
12:25:49 <lambdabot> cos + sin
12:26:17 <Veinor> @unpl liftM2 (+) cos sin
12:26:18 <lambdabot> (cos >>= \ b -> sin >>= \ a -> return (b + a))
12:26:21 <Veinor> Hmm.
12:26:25 <ray> @unpl liftM3 (+) cos sin tan
12:26:25 <lambdabot> liftM3 (+) cos sin tan
12:26:41 <ray> it doesn't know about that one
12:27:12 <Veinor> THis must be related to that -> monad I've heard so much about.
12:32:39 <jeffersonheard> Looking at Arrows, when they say arr "lifts a function into an arrow", is this the same as fmap?  Can arr = fmap?
12:33:24 <FunctorSalad> jeffersonheard: for arrows coming from a monad it's more like arr = (return .)
12:33:35 <FunctorSalad> (Kleisli arrows)
12:33:47 <jeffersonheard> was that a period or a dot?
12:33:54 <jeffersonheard> did you end a sentence or compose a function?
12:33:56 <jeffersonheard> rather
12:33:59 <ray> compose a function
12:34:00 <FunctorSalad> compose :)
12:34:17 <jeffersonheard> *chuckle*.  Thanks
12:35:02 <ray> :t arr
12:35:04 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
12:35:28 <ray> i prefer Arrow (~>) => (a -> b) -> (a ~> b)
12:35:46 <jeffersonheard> Oh, and for those of you who missed ICFP, you also missed this:  http://www.flickr.com/photos/jefferson-heard/3902168670/sizes/l/
12:36:09 <ray> haskell castle
12:36:43 <byorgey> jeffersonheard: oh, were you there?  what a shame, I must have missed meeting you.
12:37:06 <jeffersonheard> Gave a talk at CUFP and then attended the implementer's workshop
12:37:17 <Twey> ray: I like the idea of that, but I find the difference between -> and ~> small enough to require close examination.
12:37:19 <jeffersonheard> wasn't there for the whole conference
12:37:26 <Twey> It's easy to overlook.
12:37:51 <deech`> Hi all, is Text.JSON the best library to use for constructing fairly complex json messages?
12:37:59 <ray> get a better font then~
12:38:36 <jeffersonheard> ahhh, ray...  suddenly that makes things so much clearer.
12:38:51 <jeffersonheard> as in I can now see why regular functions are arrows
12:38:56 <jeffersonheard> my day is done
12:39:21 <dons> deech`: yeah, that's my opinion
12:39:23 <jeffersonheard> must now come to terms with the fact that I understand arrows
12:39:46 <byorgey> jeffersonheard: ah, that would be why, I only stayed through the Haskell symposium and then left
12:39:50 <byorgey> so I guess we missed each other =)
12:40:03 <ray> jeffersonheard: oops, sorry
12:40:30 <jeffersonheard> sorry to hear it, byorgey
12:41:56 <deech`> I'm having trouble writing code that creating a JSON message based on the following template : [{<some letter> : [{id : <some id>, name : <some name>},...]},...]
12:47:19 <PeakerWork> ray: "arr" sucks, shouldn't exist
12:47:31 <PeakerWork> ray: should have been conal's "Deep Arrow" instead, probably
12:47:47 <ray> arr seems a bit arrbitrary
12:49:08 <PeakerWork> arr requires all arrows to be at least as powerful as Haskell functions
12:49:11 <byorgey> what is a pirate's favorite Haskell type class?
12:49:21 <copumpkin> ARRow!
12:49:25 <byorgey> =D
12:49:34 <ray> GrogGen
12:49:58 <byorgey> (the other acceptable answer is "ARRbitrary")
12:50:05 <copumpkin> lol
12:50:48 <ben> pARRsec?
12:50:56 <ben> A whole package of favourite types
12:56:44 <jmcarthur_work> would be nice if arr was at least in some separate type class
12:57:00 <jmcarthur_work> as if we don't have enough Arrow type classes as it is
12:57:18 <copumpkin> class Pirate a where arr :: (b -> c) -> a b c
12:57:32 <jmcarthur_work> perfect
12:57:44 <copumpkin> to be even cooler, it should be class Pirate a where arr :: a (b c) (a b c) :P
12:57:53 <copumpkin> I mean
12:57:57 <copumpkin> a (b -> c) (a b c)
12:58:31 <jmcarthur_work> a (b c d) (e c d)
12:58:40 <copumpkin> ooh
12:58:44 <copumpkin> super duper abstract
12:58:57 <dolio> No, you don't want a (b -> c) (a b c0.
12:59:06 <benmachine> so, I hear Parsec has a darcs repository
12:59:08 <copumpkin> (I was just kidding :P)
12:59:08 <benmachine> but I can't find it
12:59:17 <benmachine> can anyone offer some insight?
12:59:51 <benmachine> I found something on darcs.haskell.org but that seemed to be version 2.1.0.1
12:59:53 <benmachine> i.e. old
13:01:01 <benmachine> oh hello
13:01:05 <benmachine> http://code.haskell.org/parsec3/
13:01:07 <benmachine> never mind
13:01:22 <copumpkin> it's parsimony now!
13:01:27 <PeakerWork> I think very rarely does one parse actually Turing Complete languages. I think monadic parsers are useful for that.  For context-free grammars we usually parse, we'd want arrow-based (or maybe Applicative? I'm not sure) parsers.  Not sure if they can parse context-sensitive/etc.  I don't like using parsec on regular/context-free grammars :-(
13:01:29 <dolio> It is?
13:01:49 <Saizan_> foo :: a (b -> c) (a b c) is stronger, since arr f = constA f >>> foo
13:01:54 <PeakerWork> I should say Turing Complete grammars there
13:02:05 <Saizan_> parsimony uses parsec3, i think
13:02:57 <dolio> a (b -> c) (a b c) is making a mistake about what the second -> is in "(b -> c) -> a b c".
13:03:06 <copumpkin> parsimony appeared to be a renaming of parsec3, with utf8 support (it's by same author too)
13:03:35 <copumpkin> dolio: true, so maybe d (b -> c) (a b c) ?
13:03:40 <Saizan_> oh, i thought parsimony was edwardk's stuff with monoids
13:03:44 <copumpkin> Saizan_: it was...
13:03:48 <copumpkin> :P
13:04:04 <Saizan_> but someone took the name first?
13:04:07 <copumpkin> yep
13:04:08 <benmachine> PeakerWork: looks like Parsec 3 has Applicative instances
13:04:18 <copumpkin> benmachine: yes, but you get no benefit for using them
13:04:46 <PeakerWork> benmachine: but also Monad
13:05:57 <pikhq> copumpkin: Yeah, but not having an Applicative instance for a monad, IMO, is a bug.
13:06:30 <Saizan_> say that to Control.Monad.Writer
13:06:36 <Gracenotes> don't you get a free one? :P
13:06:40 <pikhq> Saizan_: A bug, I say!
13:06:47 <Gracenotes> there are several Applicative instances for lists
13:06:50 <dolio> For instance, if you're modelling category theory, composition still has a type: (b ~> c) -> (a ~> b) -> (a ~> c).
13:07:08 <pikhq> Gracenotes: In a sane world where the monads are a subset of the applicative functors, sure.
13:07:17 <Gracenotes> hence ap
13:07:32 <Gracenotes> hm, I suppose you could make a ZipList monad too, but it would be somewhat useless...
13:07:57 <Saizan_> there's the Stream monad, which is for infinite ziplists, so to speak
13:07:59 <dolio> Because you're encoding the logic into the normal functions-and-types of the host language.
13:08:19 <dolio> And composition is an operation on that level. And so is arr.
13:09:00 <Saizan_> how'd you represent arr in CT?
13:09:24 <Saizan_> maybe represent is not the right word
13:09:36 <copumpkin> in the \textbf{Pirat} category
13:09:42 <dolio> Arrows are apparently related to Freyd categories.
13:09:48 <dolio> But I don't know what those are.
13:10:03 <copumpkin> I prefer Grylld categories myself
13:13:19 <newsham> does cabal (binary) not come with the ghc installer?
13:14:05 <dcoutts> newsham: no, it comes with the Haskell Platform
13:14:28 <newsham> i dont have one of those :)
13:15:26 <dcoutts> newsham: the cabal-install tarball also has a bootstrap script
13:15:59 <newsham> *nod* grabbed it, found it, also cabal.exe link.
13:16:20 <newsham> $ ./cabal.exe install caball-install
13:16:25 <newsham> hrmm.. why doesnt that work? :)
13:16:32 <dolio> Another example is more categorical functors, where you have: map : (c a b) -> d (f a) (f b)
13:17:37 <dcoutts> newsham: did you cabal update first? didn't it prompt you to do that?
13:17:55 <newsham> doing update now.  thank you
13:18:04 <dolio> Because "f is a functor" means "for all morphisms 'f : c a b' there is a morphism 'map f : d (f a) (f b)' such that ...".
13:18:14 <newsham> and we're off.. sweet.
13:18:51 <dolio> And the -> is encoding the 'forall ... there is a ...' part.
13:18:56 <sinelaw> dolio, isn't that fmap?
13:19:06 <dcoutts> newsham: did it not prompt you that you needed to update? it should do, lemme know if the message was poor
13:19:46 <newsham> dcoutts: i got a longish error message that I didnt fully inspect. and its off my scroll now, so I cant see it anymore :(
13:19:50 <newsham> sorry
13:20:01 <dolio> Making it "map : e (c a b) (d (f a) (f b))" would be like encoding your logical in category theory (which you've probably encoded in the type theory you're using), and then using that framework to encode category theory.
13:20:34 <dolio> sinelaw: I'm ethically opposed to map being specialized to lists. :)
13:20:43 <newsham> but perhaps would be useful to add to the "windows quickstart" section of readme the possibility of "fetch cabal.exe from [url].  run "cabal.exe update" followed by "cabal.exe install cabal-install" ?
13:20:57 <newsham> (although its a bit redundant, thast what i wanted to do at least)
13:21:38 <sinelaw> dolio, fmap is specialized to lists?
13:21:42 <dcoutts> newsham: the README already says that
13:22:19 <sinelaw> @type fmap
13:22:19 <dolio> sinelaw: I mean what is now fmap should be named map instead.
13:22:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:22:29 <newsham> the README says "for windows we provide a pre-compiled rpogram..... download it and put it in your path..."
13:22:38 <sinelaw> ah, I agree.
13:22:52 <newsham> *shrug*
13:23:03 <dcoutts> newsham: and the next line says "The next thing to do is to get the latest list of packages with cabal update"
13:23:19 <dcoutts> newsham: of course it's not useful in the README because the Windows users do not read that
13:23:42 <dcoutts> since it's in the tarball which is not the bit they get
13:23:46 <newsham> dcoutts: hmm.  not in the one i just downloaded
13:23:49 <dolio> sinelaw: It was named that way in Haskell 1.4, but in 1998 people went monomorphism crazy.
13:24:23 <newsham> but if its in the latest README, good enough :)
13:24:42 <sinelaw> I hereby declare a new language, called Myskell, where map is actually fmap.
13:24:54 <sinelaw> problem solved? :)
13:25:06 <PeakerWork> yeah, but only in Myskell :)
13:25:10 <dcoutts> newsham: you're right, it got added since the last release
13:25:10 <newsham> sine: isnt it called caleskell?
13:25:12 <sinelaw> So start using it!
13:26:17 <PeakerWork> dolio: How does monomorphism relate to fmap vs map? I thought monomorphic is only when you have (Blah a => a)
13:26:23 * jmcarthur_work read Myskell as MYSQL
13:26:23 <sinelaw> btw, PeakerWork i just found out i have only a few weeks to write my perliminary report, which turns out to be 25% of the project
13:26:24 <ray> import Caleskell
13:26:54 <dolio> PeakerWork: map is now typed as (a -> b) -> [a] -> [b], so it's monomorphic in the functor.
13:27:02 <ray> peakerwork: monomorphic is specific types, polymorphic is type variables
13:27:03 <sinelaw> jmcarthur_work, is Mysmell better?
13:27:07 <dolio> PeakerWork: map used to be Functor f => (a -> b) -> f a -> f b.
13:27:30 <PeakerWork> dolio: what does "monomorphic" mean  here?
13:27:39 <copumpkin> opposite of polymorphic
13:27:39 <PeakerWork> oh, ok
13:27:43 <dolio> (++) used to be what is now mplus (I think that's right), for instance, too.
13:27:50 <sinelaw> dolio, it used to be that? and they regressed to only lists? weird
13:28:00 <PeakerWork> dolio: all for newbie appeal (that doesn't really exist with it anyway) ?
13:28:01 <ray> they took out monad comprehensions too
13:28:01 <copumpkin> sinelaw: in the great monomorphic revolution
13:28:17 <ray> counter-revolution desperately needed
13:28:18 <dolio> PeakerWork: Yeah. I think the primary argument was to avoid scary type errors.
13:28:19 <PeakerWork> sinelaw: yeah, many things were broken for some odd reason
13:28:24 <jmcarthur_work> why do we have mplus and not fplus? :(
13:28:26 <PeakerWork> dolio: :-(
13:28:37 <PeakerWork> dolio: and also the proper Monad vs Monad-with-fail
13:28:44 <ray> jmcarthur_work: because Monoid f a
13:28:57 <dolio> fail was slightly different.
13:29:13 <sinelaw> sound's like Pol Pot
13:29:20 <sinelaw> *sounds
13:29:52 <dolio> Haskell used to have a notion of "unfailable patterns" for patterns that could only be refuted by bottom. Tuples (and any single-constructor product type) were unfailable.
13:30:19 <dolio> And if "pat" was unfailable, then 'do pat <- m ; ...' didn't need mplus.
13:30:26 <dolio> MonadPlus, even.
13:30:31 <dolio> Actually it was MonadZero back then.
13:31:07 <dolio> But they wanted to get rid of the idea of unfailable patterns, but not have to use MonadPlus for tuple matching, either.
13:31:13 <dolio> So fail got added.
13:31:15 <copumpkin> :(
13:31:29 <copumpkin> "the sad sad history of haskell, as told by dolio"
13:32:13 <Heffalump> it's kind of weird for adding a constructor to change a type constraint
13:32:31 <Heffalump> and having to use MonadPlus for tuple matching would really suck
13:32:56 <dolio> I don't really understand why they wanted to get rid of unfailable patterns.
13:33:30 <sinelaw> PeakerWork, can you point me to examples that compare and show FRP's advantage over traditional methods?
13:33:40 <PeakerWork> dolio: yuck! it sounds like it was better designed before
13:33:43 <sinelaw> (or perhaps, someone else here)
13:34:08 <sinelaw> though i can probably google them. so only if you have something in mind
13:34:15 <dolio> PeakerWork: Yeah, the 98 standard has a few weird decisions.
13:34:26 <PeakerWork> sinelaw: I really like Conal's Fran examples (compare those to traditional code to do the same). Also, his Phooey examples are nice.  When we sit, I can design "Pyun" with you to show you how well it compares
13:34:40 <sinelaw> dolio, they figured the world will end in 2 years, so why bother
13:34:47 <dolio> Heh.
13:35:34 <sinelaw> and it really did - and then it was restarted in the exact same state
13:35:38 <jmcarthur_work> dolio, are unfailable patterns different from lazy patterns?
13:35:53 <dolio> jmcarthur_work: Yes.
13:35:53 <PeakerWork> sinelaw: the world was rebooted?
13:36:29 <jokerGTA> can anyone help me with something
13:36:41 <jokerGTA> when i work with list i can do this [1..n]
13:36:53 <jokerGTA> which is list from 1 until n (whatever n might be
13:37:15 <sinelaw> Yes, but thanks to orthogonal persistence we are all still here. Except for a few that fell through the checkpoint interval. (ok, i'll go back to work)
13:37:26 <jokerGTA> but how can i do this [1..n] to include negative numbers as well
13:37:40 <Saizan> if you've newtype N = N { unN :: T }  \f -> N . f . unN is usually called onN or inN ?
13:37:52 <sinelaw> jokerGTA, you mean 1, -1, 2, -2, .. n?
13:38:02 <ray> > [-1,-2.. -10]
13:38:05 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
13:38:09 <dolio> jmcarthur_work: Basically, a pattern is unfailable if there is exactly one case. That still fails if you give it bottom, though, but failing on bottom isn't a problem for monadic pattern matching, because it's not like you can identify a bottom (IO magic excepted) and use a notion of failure in the monad instead of just blowing up.
13:38:10 <jokerGTA> for ecample if n =5
13:38:25 <jokerGTA> --5,--4,-3,-2,-1,0,1,2,3,4,5
13:38:31 <dolio> jmcarthur_work: Irrefutable patterns succeed even if you give them bottom, by contrast.
13:38:38 <jokerGTA> {-n,n]
13:38:40 <jokerGTA> ?
13:38:48 <jokerGTA> [-n,n]
13:39:04 <PeakerWork> Saizan: inN afaik
13:39:05 <sinelaw> > [-5..5]
13:39:09 <lambdabot>   [-5,-4,-3,-2,-1,0,1,2,3,4,5]
13:39:16 <jokerGTA> yes labda
13:39:25 <jokerGTA> [-n..n] would work??
13:39:25 <sinelaw> jokerGTA, he's a bot :)
13:39:27 <sinelaw> yes
13:39:29 <Badger> @botsnack
13:39:29 <lunabot>  :o
13:39:29 <lambdabot> :)
13:39:33 <jokerGTA> who is bot??
13:39:34 <jokerGTA> lol
13:39:36 <jokerGTA> that funny
13:39:37 <jokerGTA> hahaha
13:39:46 <jokerGTA> where you guys from
13:39:48 <ray> @lunabotsnack
13:39:48 <lambdabot> Unknown command, try @list
13:40:09 <ray> bad bot, stealing snacks
13:40:09 <sinelaw> we're from Haskell
13:40:18 <jokerGTA> cool
13:40:21 <jokerGTA> nice country:)
13:40:25 <Badger> A magical land.
13:41:06 <dolio> jmcarthur_work: So "do (a,b) <- m ; ..." can work in just Monad, because either m results in a bottom, in which case you have no choice but to blow up, or it's definitely of the form (a, b), so there's no monadic failure case.
13:41:20 * benmachine unsafePerformBadger
13:41:29 <dolio> jmcarthur_work: Whereas "do Just a <- m ; ..." needs to fail in the monad if m results in a Nothing.
13:41:35 <PeakerWork> dolio: which is great. As well as having a separate MonadZero for the failable case
13:41:37 <benmachine> dolio: taht sounds entirely sensible
13:41:42 <jokerGTA> the problem with this [-n..n] is that includes zero and that gives me "exceprion divides by zero
13:41:52 <HugoDaniel> @faq can haskell do a supersonic wave filter ?
13:41:52 <lambdabot> The answer is: Yes! Haskell can do that.
13:42:09 <PeakerWork> > filter (/=0) [-5..5]
13:42:13 <lambdabot>   [-5,-4,-3,-2,-1,1,2,3,4,5]
13:42:29 <benmachine> jokerGTA: you probably have to do something like [x | x <- [-n .. n], x /= 0] or delete 0 [-n .. n]
13:42:29 <Badger> benmachine: * Exception: Badgers.
13:42:46 <benmachine> Badger: oh shi
13:42:50 <jokerGTA> i already have one expression aafter [-n..n]
13:43:27 <Vanadium> @instances Monad
13:43:28 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:43:38 <jokerGTA> n = [d | d <- [-n..n], n `mod` d == 0]
13:43:46 <copumpkin> @hoogle RWS
13:43:46 <lambdabot> module Control.Monad.RWS
13:43:47 <lambdabot> Control.Monad.RWS.Lazy newtype RWS r w s a
13:43:47 <lambdabot> Control.Monad.RWS.Lazy RWS :: r -> s -> (a, s, w) -> RWS r w s a
13:44:14 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html nice docs
13:45:25 <jokerGTA> this worked .....n = [d | d <- (delete 0 [-n..n]), n `mod` d == 0]
13:46:26 <sinelaw> Don't you love FP? this is cool.
13:46:27 <sinelaw> > let quicksort (a:as) = (quicksort [x | x <- as , x < a]) ++ [a] ++ (quicksort [x | x<-as , x >= a]); quicksort [] = [] in quicksort [5,3,7,1,9,4,8,3,7]
13:46:31 <lambdabot>   [1,3,3,4,5,7,7,8,9]
13:47:22 <linkerman> http://maffiozo.hu/rablas.php?rablo=GfBalage89
13:47:26 <copumpkin> @where ops
13:47:27 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:47:30 <sinelaw> 1 line as compared to 7 lines here: http://en.wikipedia.org/wiki/Quicksort#Algorithm
13:47:34 --- mode: ChanServ set +o dcoutts
13:47:51 <copumpkin> meh
13:47:54 --- mode: ChanServ set -o dcoutts
13:48:04 <copumpkin> we could set this channel to be +s
13:48:08 <copumpkin> that'd stop these guys
13:48:46 <copumpkin> or +p, maybe
13:49:19 <ville> +r or +R usually does the trick
13:49:28 <sinelaw> BTW, in that quicksort implementation i typed, will haskell know to iterate the list only once to create the two sub-lists?
13:49:45 <sinelaw> (i have two list comprehensions on the same list)
13:49:51 <copumpkin> ville: but many people don't want to register, but the spammers are clearly just doing a /list, sorting by nubmer of people, and joining the top n channels
13:50:00 <dolio> No.
13:50:06 <dolio> You could probably use partition, though.
13:50:09 <dolio> @type partition
13:50:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:50:13 <Botje> I just sent a mail to abuse@ and postmaster@<that domain>
13:50:14 <sinelaw> ah, yes
13:50:18 <Botje> Let's see if they do something about it. :)
13:50:22 <PeakerWork> sinelaw: also look at conal's "More Beautiful folds"
13:50:36 <ville> copumpkin: we're +R now on ##C++ and didn't get any spam
13:50:52 <copumpkin> ville: sure, but you're keeping out more people that way
13:50:55 <HugoDaniel> i dont find this think of spam so much intrusive
13:50:57 <copumpkin> I don't usually bother identifying
13:51:09 <sinelaw> dolio, haskell should know that multiple list comprehensions on the same list can be collapsed into a partition...though hard to implement such a transformation in the general case
13:51:15 <HugoDaniel> just my personal opinion :P
13:51:38 <ville> Fair enough - my client takes care of it anyway.
13:51:53 <copumpkin> mine would too, I guess I could set it up, but I'm sure many poeple in here aren't identified
13:52:24 <copumpkin> @pl \(x, y) z -> x ++ z ++ y
13:52:25 <lambdabot> uncurry ((. flip (++)) . (.) . (++))
13:52:54 <Botje> euch, that's hairy
13:52:55 <sinelaw> Just as I thought!
13:53:01 <sinelaw> heh, not.
13:53:09 <copumpkin> @pl \z (x, y) -> x ++ z ++ y
13:53:10 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (++)) . (++)
13:53:12 <copumpkin> :P
13:53:37 <sinelaw> @pl \z (x,y) -> x++[z]++y
13:53:37 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (++)) . (:)
13:53:42 <sinelaw> @pl \(x,y) z -> x++[z]++y
13:53:42 <lambdabot> uncurry ((. flip (:)) . (.) . (++))
13:55:28 <PeakerWork> \x z y -> x ++ [z] ++ y     =    (id ~> (:[]) ~> id ~> id) concat
13:56:44 <copumpkin> which ~> is that?
13:56:45 <sinelaw> why the last id?
13:57:06 <sinelaw> wait, i don't know what ~> is :) (arrow? but what does it do)
13:57:28 <PeakerWork> copumpkin: (f ~> g) x = f >>> x >>> g
13:57:33 <copumpkin> oh :)
13:57:44 <sinelaw> PeakerWork, remind me about >>>
13:57:45 <PeakerWork> its also infixr 2
13:57:52 <copumpkin> sinelaw: it's flip (.) in most cases
13:58:18 <PeakerWork> @let (f ~> g) x = f >>> x >>> g
13:58:19 <lambdabot>  Defined.
13:58:22 <PeakerWork> @undef
13:58:27 <PeakerWork> @let infixr ~> 2 ; (f ~> g) x = f >>> x >>> g
13:58:27 <lambdabot>   Parse error: IntTok 2
13:58:32 <PeakerWork> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
13:58:33 <lambdabot>  Defined.
13:58:37 <PeakerWork> @type (~>)
13:58:38 <lambdabot> forall (cat :: * -> * -> *) a b b1 c. (Control.Category.Category cat) => cat a b -> cat b1 c -> cat b b1 -> cat a c
13:58:52 <Badger> a family of cats
13:58:54 <copumpkin> meow
13:59:01 <PeakerWork> @type (id ~> (:[]) ~> id ~> id) concat
13:59:03 <lambdabot>     Couldn't match expected type `[a] -> a1 -> b1'
13:59:03 <lambdabot>            against inferred type `[a2]'
13:59:03 <lambdabot>     In the first argument of `(id ~> (: []) ~> id ~> id)', namely
13:59:06 <copumpkin> onoes
13:59:17 <PeakerWork> oh, right, need to listify them too
13:59:29 <PeakerWork> @type (length ~> length ~> id) compare
13:59:30 <lambdabot> forall a a1. [a] -> [a1] -> Ordering
13:59:51 <copumpkin> @type comparing length
13:59:53 <lambdabot> forall a. [a] -> [a] -> Ordering
13:59:57 <copumpkin> aha
14:00:01 <copumpkin> neat
14:00:13 <jokerGTA> does Integer includes negative numbers.....my assumption is that it does
14:00:19 <copumpkin> it does
14:00:19 <benmachine> yes
14:00:22 <sinelaw> PeakerWork, so, (f ~> g) x y does: g (x (f y)) ?
14:01:00 <jokerGTA> because my function works when number passed is positive..but gives error when passed number is negative
14:01:09 <benmachine> > mod 5 (-2)
14:01:13 <lambdabot>   -1
14:01:46 <RayNbow> sinelaw: it does
14:01:57 <PeakerWork> sinelaw: I think so, yes
14:02:26 <jokerGTA> No instance for (Num (Integer -> Integer))
14:02:29 <PeakerWork> sinelaw: f ~> g ~> h ~> i       can be seen as an "editor" of a function (a -> b -> c -> d)  that applies "f" to the "a" part, "g" to the "b" part, and so on
14:02:30 <RayNbow> (f ~> g) is a function editor that applies f to the argument and g to the result
14:02:35 <RayNbow> or what Peaker says :p
14:02:36 <jokerGTA>  arising from a use of `-' at <interactive>:1:0-31
14:02:53 <jmcarthur__work> :t \f g x -> f >=> x >=> g
14:02:55 <lambdabot> forall a (m :: * -> *) b b1 c. (Monad m) => (a -> m b) -> (b1 -> m c) -> (b -> m b1) -> a -> m c
14:03:03 <sinelaw> ok
14:03:09 <sinelaw> nice way to explain it
14:03:31 <PeakerWork> @type (length ~> head ~> id) compare
14:03:33 <lambdabot> forall a. [a] -> [Int] -> Ordering
14:03:35 <PeakerWork> sinelaw: what does that do?
14:04:19 <copumpkin> that's neat
14:04:32 <copumpkin> PeakerWork: what's that from again?
14:04:48 <PeakerWork> copumpkin: I forget where its from :(
14:04:52 <jmcarthur__work> i think i saw this stuff on somebody's blog somewhere
14:05:00 <PeakerWork> hard to search ~>
14:05:39 <Badger> @hoogle (~>)
14:05:40 <lambdabot> No results found
14:05:48 <Badger> @src (~>)
14:05:49 <lambdabot> Source not found. :(
14:06:00 <copumpkin> conal maybe?
14:06:08 <sinelaw> PeakerWork, compares the length of one list to the first element of another?
14:06:19 <jmcarthur__work> ? http://matt.immute.net/content/pointless-fun
14:06:55 <RayNbow> @where (~>)
14:06:55 <lambdabot> I know nothing about (~>).
14:07:20 <sinelaw> > ((length ~> head ~> id) compare) [1,2,3] [3,54]
14:07:25 <lambdabot>   EQ
14:07:29 <sinelaw> woohoo.
14:07:33 <jmcarthur_work> yeah i think what i just linked to is it
14:07:42 <jmcarthur_work> a bit different though
14:07:49 <RayNbow> @where (~>)
14:07:49 <lambdabot> http://matt.immute.net/content/pointless-fun
14:07:50 <jmcarthur_work> from what we are doing
14:07:52 <PeakerWork> sinelaw: yeah
14:07:55 <jokerGTA> why would throw error on perfectly valid data type
14:08:48 <jmcarthur_work> jokerGTA, must not be perfectly valid
14:09:10 <jokerGTA> works when i put it in the bracket
14:09:11 <jokerGTA> lol
14:09:35 <PeakerWork> jokerGTA: what's funny?
14:09:54 <jokerGTA> because i didnt realize that i have to put negative number in the brackets
14:09:58 <jmcarthur_work> lol = new age punctuation
14:10:14 <sinelaw> Peaker, I still don't get this <PeakerWork> \x z y -> x ++ [z] ++ y     =    (id ~> (:[]) ~> id ~> id) concat
14:10:17 <sinelaw> concat only takes one argument
14:10:27 <sinelaw> but you have three arrows
14:10:56 <PeakerWork> sinelaw: I was wrong there
14:11:01 <PeakerWork> sinelaw: forgot to listify :)
14:11:41 <sinelaw> (id ~> (:[]) ~> id ~> concat)
14:11:57 <sinelaw> > (id ~> (:[]) ~> id ~> concat) [1,2] 3 [4,5]
14:11:59 <lambdabot>   Couldn't match expected type `a -> [a1] -> a2 -> [[a3]]'
14:12:01 <PeakerWork> @type let listify3 x y z = [x,y,z] in (id ~> (:[]) ~> id ~> concat) listify
14:12:02 <lambdabot>     Couldn't match expected type `a -> [[a1]]'
14:12:02 <lambdabot>            against inferred type `[r]'
14:12:02 <lambdabot>     In the first argument of `(id ~> (: []) ~> id ~> concat)', namely
14:12:16 <PeakerWork> @type let listify3 x y z = [x,y,z] in (id ~> (:[]) ~> id ~> concat) listify3
14:12:17 <lambdabot> forall a. [a] -> a -> [a] -> [a]
14:12:34 <sinelaw> > (id ~> (:[]) ~> id ~> concat id->id->id) [1,2] 3 [4,5]
14:12:38 <lambdabot>   <no location info>: parse error on input `->'
14:12:40 <hackagebot> CCA 0.1.1 - preprocessor and library for Causal Commutative Arrows (CCA) (PaulLiu)
14:12:44 <PeakerWork> > let listify3 x y z = [x,y,z] in (id ~> (:[]) ~> id ~> concat) listify3 [1,2,3] 4 [5,6,7]
14:12:48 <lambdabot>   [1,2,3,4,5,6,7]
14:12:49 <sinelaw> > ((id ~> (:[]) ~> id ~> concat) id.id.id) [1,2] 3 [4,5]
14:12:52 <lambdabot>   Couldn't match expected type `[a] -> a1 -> [[a2]]'
14:12:59 <PeakerWork> sinelaw: id.id.id = id
14:13:03 <sinelaw> heh oops
14:13:37 <jmcarthur_work> :t fix (id.)
14:13:39 <lambdabot> forall b a. a -> b
14:14:02 <PeakerWork> @type (id.)
14:14:03 <lambdabot> forall b a. (a -> b) -> a -> b
14:14:11 <sinelaw> > (:[]) ~> ((id ~> (:[]) ~> id) concat) [1,2] 3 [4,5]
14:14:15 <lambdabot>   Couldn't match expected type `[a] -> t -> b1 -> c'
14:14:46 <PeakerWork> sinelaw: you were right about concat, it takes 1 arg, can't apply an editor of 3 args to it
14:15:22 <PeakerWork> sinelaw: the x ~> y  thing independently applies x and y, you can't use it to listify, I don't think
14:18:55 <sinelaw> PeakerWork, i guess \x y z -> x ++ [z] ++ y is simplest :)
14:19:38 <jmcarthur_work> @pl \x y z -> x ++ [z] ++ y
14:19:38 <lambdabot> (. flip (:)) . (.) . (++)
14:19:43 <jmcarthur_work> perfect!
14:23:16 <sinelaw> :P
14:24:14 <nlogax> the little guy in there looks so happy
14:47:01 <leimy_> If I'm importing a module, how is it that i get access to a data types constructors?
14:47:11 <leimy_> I'm missing something simple here I think.
14:47:22 <skorpan> import Hello (Type(..))
14:47:30 <skorpan> that'll import the type Type with all of its constructors
14:48:03 <leimy_> ooh
14:48:06 <leimy_> damn
14:48:06 <leimy_> yep
14:48:07 <leimy_> missed that
14:48:57 <leimy_> skorpan: Otherwise they won't be imported by default?  Meaning I can't stick that in the "export" syntax?
14:50:13 <skorpan> if you use just "import Hello" they will be imported (if they are exported from Hello of course), if you use "import Hello (Type)" you won't get the constructors afaik
14:50:22 <leimy_> Ah
14:50:23 <leimy_> ok.
14:56:59 <Gracenotes> :.x
14:57:00 <hackagebot> data-reify 0.5 - Reify a recursive data structure into an explicit graph. (AndyGill)
14:59:36 <byorgey> data-reify is totally ninja.
15:00:20 <PeakerWork> damn linkers for caring about link order :-(
15:00:48 <Gracenotes> hm.. perhaps I do need mutable state for this web app... it might get unpretty otherwise :(
15:01:47 <Gracenotes> I'm not cheating on you, Haskell, I promise <3
15:02:37 <jmcarthur_work> MUTABLE STATE NOOOOOOOOO
15:02:45 <jmcarthur_work> you have learned nothing
15:02:52 <copumpkin> I only use immutable state
15:03:14 <c_wraith> immutable state is handy
15:06:22 <Gracenotes> with the DAG thing, again. Perhaps I'm not thinking outside of the box enough, but for a DAG, how would one go about making a subgraph with a node A, a node B, and all nodes that have both A and B as ancestors. it's not pretty..
15:07:11 <jmcarthur_work> Gracenotes, what is it that you are doing?
15:08:14 <Gracenotes> and it gets even more complicated if for this structure: { A -> C, C -> D, A -> B, B -> D}, you want to include all four nodes, vs. just including A, B, and C (assuming A and B are the two selected)
15:10:41 <Gracenotes> I mean, just including A, B, and D. C might not be included in this scheme because it only has A, not B, as an ancestor. The problem with just assuming you can select whole subgraphs at a time is that a node in the subgraph might be linked from elsewhere, like node C in the example above
15:11:03 <Gracenotes> perhaps I should read the graph chapters in my Introduction to Algorithms book..
15:12:46 <Gracenotes> hm. maybe I abandoned my recursive data structure and just went with an IntMap [Int], it would be much easier. yeah, probably that.
15:13:31 <Gracenotes> maybe I should, I mean.
15:16:44 <Gracenotes> it would have to be recursive in the foldl sense, though, not foldr
15:17:46 <jmcarthur_work> Gracenotes, have you considered a graph library like fgl?
15:19:29 <jmcarthur_work> fgl's interface could be nicer, but it's far nicer than reinventing the wheel
15:19:52 <Gracenotes> I don't think it would be that much more useful than I'm using.. just more sophisticated
15:20:26 <Gracenotes> more formal, even
15:20:36 <jmcarthur_work> all its Gr type is is a collection of labelled nodes and edges
15:21:40 <jmcarthur_work> with some IntMaps, iirc
15:23:49 <Gracenotes> I do have everything in an IntMap [Int] before making it into a recursive data structure.. it is perhaps not strictly necessary, but it's still kinda cool.
15:24:20 <jmcarthur_work> oh, you are knot tying?
15:24:31 <jmcarthur_work> err
15:24:37 <jmcarthur_work> guess you don't do that with DAGs
15:25:59 <Gracenotes> jmcarthur_work: typing the knot works nicely. but unfortunately, for most tree-modifying structural recursion algorithms, running into the same node twice is a bit of a problem..
15:26:06 <Gracenotes> uh. tying.
15:26:07 <jmcarthur_work> right
15:28:35 <Gracenotes> unless you want to build it bottom-up every time
15:29:37 <Gracenotes> which would only be possible, in many cases, after a preliminary data-gathering phase
15:29:37 <jmcarthur_work> IntMap is the best for graphs you intend to modify, i think
15:32:28 <Gracenotes> I can't think of many advantages of IntMap over mutable graphs, though :X
15:33:50 <Cale> Gracenotes: Over what representation of mutable graphs?
15:34:28 <Cale> Gracenotes: One advantage is that it's about as fast as a mutable structure without the need to destroy old versions of the graph when you make a change.
15:34:40 <Vanadium> Cale: I have heard a Caleskell prelude spoken of in hushs and whispers, is there any such thing in existence?
15:34:44 <Gracenotes> hm.. I suppose IntMaps do provide fast lookup of nodes by ID.. which a Node-based mutable graph might not provide..
15:34:46 <Cale> Vanadium: No.
15:35:18 <ray> import Caleskell was a joke
15:35:29 <ray> you can write your own, it's not hard
15:35:32 <Cale> Vanadium: People are just referring to the two definitions that I included in lambdabot for a time: (.) = fmap and (++) = mappend
15:35:41 <Vanadium> right
15:35:46 <ray> and possible left-associative $
15:35:47 <jokerGTA> guys can anyone help me with this expresion
15:36:04 <Cale> There are lots of other changes I'd like to make to the Prelude, but it's more work.
15:36:05 <Vanadium> Both of those seem rather reasonable and I hoped there were more insights there~
15:36:25 <Cale> jokerGTA: probably
15:36:34 <ray> vanadium: there is stuff on haskellwiki
15:36:38 <Gracenotes> one might expect that a mutable IntMap might perform faster than an immutable IntMap, though. even so.. how do you go about comparing the overhead that each data structure necessarily requires...
15:36:46 <jokerGTA> [  x | x <-  (myFunction(head xs)),  (chooseFrom (xs x)) = 0 ]
15:37:39 <Cale> That = probably wants to be ==
15:37:40 <jokerGTA> myFunction grabs head of the list and returns all the dividers of that number
15:37:45 <Gracenotes> the compiler can assume nice things about immutable data structures, but can that be enough..
15:38:02 <Cale> also, 'head' is a little suspicious
15:38:15 <Cale> Are you certain that xs is nonempty?
15:38:26 <jmcarthur_work> IntMaps are pretty fast. i'd be surprised if there is much advantage that a mutable version can provide. probably only a very small constant time improvement
15:38:37 <jokerGTA> now from that list just returned i want to choose only number that satisfied this condition chooseFrom (xs x)) = 0  xs is list and x is number from that list that i want to test
15:38:46 <jmcarthur_work> at the rather large cost of requiring it to be used imperatively
15:38:57 <jokerGTA> == didnt work as well
15:39:03 <jokerGTA> that function returns integer
15:39:18 <jokerGTA> i am looking for number when pluged in that function returns zero
15:39:19 <ray> jmcarthur_work: but hash tables are slow, therefore you should use ocaml
15:39:24 <Cale> jokerGTA: xs is a function?
15:39:37 <jokerGTA> xs is a list
15:39:38 <Cale> jokerGTA: (of course it can't be both a function and a list)
15:39:44 <Cale> jokerGTA: (xs x) is ill-typed then
15:40:07 <jokerGTA> chooseFrom function takes List and Integer as parametars
15:40:10 <jmcarthur_work> i think hash tables are overused in most communities. they have their uses, but i've not needed one in a long time
15:40:35 <Cale> jokerGTA: But that's passing it one parameter
15:40:39 <jmcarthur_work> ray, i think you mean F# now ;)
15:40:49 <ray> yeah, something like that
15:40:52 <Cale> jokerGTA: Which is apparently the result of applying the function xs to the value x
15:40:55 <jmcarthur_work> if you are referring to harrop
15:41:00 <PeakerWork> jmcarthur_work: the Harrop troll uses "OMG Haskell doesn't have hash tables" as a means of scaring people away from Haskell.  Supposedly, they perform much better than search trees in practice. I haven't benchmarked myself
15:41:03 <jokerGTA> xs is not a function
15:41:06 <jokerGTA> its a list
15:41:08 <Cale> jokerGTA: Perhaps you meant to write chooseFrom xs x
15:41:14 <ray> yes, it was a harrop joke
15:41:26 <ray> it comes to mind every time someone mentions IntMap
15:41:28 <Cale> jokerGTA: (xs x) means "apply the function xs to the value x"
15:41:35 <jmcarthur_work> PeakerWork, well, it's true that in a lot of cases they do in fact perform better than search trees
15:42:05 <jokerGTA> i am  confused about this
15:42:11 <jmcarthur_work> typically this benchmark is with String keys or something
15:42:26 <jmcarthur_work> i think some hash table implementations even beat a lot of tries
15:42:43 <jokerGTA> this part x <-  (myFunction(head xs)) will take that first element of the list and return all the dividers of that number
15:42:44 <ray> impressive
15:43:07 <jokerGTA> now from that list i need some numbers
15:43:10 <Gracenotes> the main thing I worry about it garbage collection overhead with IntMaps. not much is being garbage collected, but what does it take to find the nodes that actually are..?
15:43:38 <jokerGTA> i have function that takes list and integer as parametars does some calc and returns integer
15:44:08 <dm``> What about Data.HashTable?  Haskell may not have pure hash tables, but it does at least have hash tables.  Since other languages don't have pure anything, the lack of a pure hash table shouldn't scare people away form haskell.
15:44:27 <Cale> dm``: Don't use Data.HashTable
15:44:29 <jmcarthur_work> Data.HashTable sucks, frankly
15:44:37 <Cale> It's only there for historical reasons.
15:44:38 <dm``> Sucks for correctness or performance?
15:44:43 <jokerGTA> but i need only numbers from first list that when plugged into Choose from return zero
15:44:43 <jmcarthur_work> latter
15:45:02 <ray> harrop tries to jump from Data.HashTable sucks to haskell sucks
15:45:30 <Cale> Performance. It's worse than using Data.Map in many cases, and scales more poorly.
15:45:35 <copumpkin> clojure has a persistenthashmap apparently
15:45:41 <dm``> Is there some reason something like Data.HashTable couldn't be implemented efficiently?
15:45:42 <copumpkin> maybe we could get one of those into haskellland
15:45:59 <copumpkin> dm``: difficulties GC'ing mutable arrays
15:46:01 <Cale> dm``: No, just that everyone likes trees better :)
15:47:38 <defun> What would be the feasibility of applying darcs's patch-theory to unix package management? Has anyone tried this already?
15:47:59 <dons> huh
15:48:13 <dons> so commutative packages?
15:48:14 <jmcarthur_work> defun, different from nix, i assume?
15:48:22 <jmcarthur_work> ah hmm
15:48:26 <jmcarthur_work> that's interesting indeed
15:48:33 <defun> well, yes.
15:48:41 <jmcarthur_work> partially commutative packages
15:49:00 <defun> Like regular pkg management but with darcs' patch theory as basis.
15:49:27 * cygnus talked a little bit with lispy about doing that with dbmigrations, too
15:49:42 <jmcarthur_work> btw, i think i should note that darcs patches look like a trace monoid, which is a rather well studied theory of partially commutative monoids, but could find nothing relating the two ideas with google
15:49:54 <jmcarthur_work> now that this has been logged, i imagine that will change :)
15:50:59 <defun> Would a patch-theory based pkg manager offer any substantial benefits to 'vanilla' pkg management (aside from the fact that it would be written in haskell :)
15:51:14 <jmcarthur_work> in fact, i bet a lot of concurrency formalizations might apply to patch theory
15:52:17 <jmcarthur_work> defun, maybe if you want to maintain similar sets of packages on more than one machine?
15:52:28 <defun> ah
15:52:38 <defun> that would be handy
15:53:18 <jmcarthur_work> but even slightly different ones, of course, like A might have some packages that B doesn't have, but as long as they do not conflict you can still sync other installed packages between the two
15:53:26 <defun> anyway, I think it could work. Especially since sequential patches correspond to packages with dependencies and stuff.
15:53:45 <defun> I wonder if cabal would ever adopt something like what I am proposing...
15:53:57 <jmcarthur_work> also would be cool to look at patch theory applied to build systems, maybe
15:54:12 <defun> that would be sweet
15:54:21 <jmcarthur_work> i have no idea what merit that would have
15:54:29 <jmcarthur_work> only that it could be be represented
15:54:42 <defun> aside from a build system in haskell?
15:54:46 <defun> not a clue.
15:54:56 <defun> less headaches?
15:55:17 <jmcarthur_work> well, it's not like the dependencies of a build system are changed all that frequently
15:55:37 <jmcarthur_work> i don't even know what a "conflict" would look like
15:55:54 <jmcarthur_work> besides reversing the order of dependencies, i guess
15:56:01 <dcoutts> defn: at the moment we're trying to steal ideas from Nix
15:56:12 <dcoutts> oops, nick completion
15:56:16 <dcoutts> defun: ^^
15:56:20 <defun> dcoutts: talking about cabal?
15:56:23 <dcoutts> yes
15:56:28 <defun> hmm.
15:56:29 <jmcarthur_work> ooh nice
15:56:31 <dons> dcoutts is gonig to put slides up :)
15:56:36 <defun> Yay!
15:56:39 <defun> I love slides.
15:56:42 <jmcarthur_work> nix is worth stealing from
15:56:48 <jmcarthur_work> especially since they first stole from us ;)
15:57:28 <defun> How is Nix different from i.e. Cabal or Pacman (or insert your favourite pkg manager here)
15:57:38 <defun> It's written in C?
15:57:44 <jmcarthur_work> purely functional
15:57:50 <jmcarthur_work> not implementation, interface
15:57:51 <dcoutts> defun: it's the ideas that distinguish it, not the implementation language
15:57:58 <defun> I see.
15:58:26 <mauke> also, s/i\.e/e.g/
15:58:39 <defun> I went to school with a guy who was working a pkg manager in Haskell called Nyx, which was also purely functional.
15:58:49 <dcoutts> it uses a persistent (ie non-destructive) package store and it obsessively tracks all dependencies of packages
15:58:49 <defun> I don't think he ever got around
15:58:53 <defun> to finishing it.
15:59:13 <Gracenotes> ;.
15:59:23 <dcoutts> defun: one of the key ideas is you can install a new instance of a package without touching any existing packages, ie you don't break stuff
15:59:42 <Gracenotes> dcoutts: eh. how does it do with circular dependencies?
15:59:48 <defun> And it links stuff to /bin /usr/bin automatically?
15:59:55 <Gracenotes> I assume it won't add them
16:00:11 <dcoutts> Gracenotes: I'm not sure
16:00:22 <dcoutts> defun: there is no /usr/bin in NixOS :-)
16:00:27 <mle> Gracenotes: could do it by requiring there be none; though that gets really tedious to package
16:00:28 <defun> ?!
16:00:29 <lambdabot> Maybe you meant: . ? @ v
16:00:39 <dcoutts> defun: NixOS has /bin/sh and that's it
16:00:41 <defun> Than what do they use?
16:00:44 <mle> Gracenotes: alternatively you could require circular sets be installed in an atomic set
16:00:44 <defun> ah
16:01:06 <dcoutts> everything that goes into constructing the package is tracked as part of the identifier of the package
16:01:18 <defun> Do they support large packages like X.Org, Gtk+, etc,
16:01:22 <dcoutts> yep
16:01:24 <defun> Do they support XMonad
16:01:28 <dcoutts> defun: yes
16:01:51 <dcoutts> defun: the point is, /usr/bin is an imperative mutable system of package management.
16:02:11 <defun> english?
16:02:11 <dcoutts> defun: there can only be one /usr/bin/foobar at once, if you want a new instance then it overwrites the old one
16:02:22 <defun> hmm
16:02:23 <StefanK> if I have data A = A1 | ... | An and data B the same, how many values does type P =(A,B) has? is it (a+1) * (b+1) +1 OR (a+1) + (b+1) +1
16:02:28 <c_wraith> How well does the system interact with software not packaged for it?
16:02:43 <copumpkin> StefanK: so you're counting _|_?
16:03:02 <StefanK> yes :)
16:03:08 <StefanK> my professor does
16:03:08 <copumpkin> I'd assume the former then
16:03:24 <defun> googling for nix now.
16:03:32 <defun> thanks.
16:03:38 <StefanK> k
16:03:42 <StefanK> thanks
16:03:46 <dcoutts> defun: but if I install /pkgstore/YQQJ6c5MmqQ/bin/foobar then that doesn't break an existing /pkgstore/NRjzSGkCY9M/bin/foobar
16:03:52 <Saizan> it's Either A B that's the latter
16:04:28 <defun> so it's safe. And I take it Cabal isn't like this?
16:04:36 <defun> It should be simple to implement
16:04:36 <Saizan> dcoutts: how does sh resolves foobar, though?
16:04:53 <dcoutts> defun: right, Cabal currently is a traditional imperative package manager
16:05:00 <dcoutts> Saizan: using the $PATH
16:05:03 <dcoutts> as usual
16:05:28 <newsham> i'm getting less data from bytestring than I would expect:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9231#a9231
16:05:32 <newsham> am I doing something wrong?
16:05:34 <Saizan> so you've a big PATH with an entry for each package?
16:06:07 <dcoutts> Saizan: I'm not sure which Nix does exactly, but you could make an environment by setting the $PATH, or you could do it by making a profile bin dir containing symlinks.
16:06:21 <newsham> (this is ghc 6.10.4 on winxp, fresh cabal install of binary)
16:06:43 <jmcarthur_work> newsham, does the file contain unicode characters?
16:06:49 <dino-> newsham has discovered darkmatterstring
16:07:02 <jmcarthur_work> oh, *less* than expected
16:07:04 <jmcarthur_work> nevermind
16:07:21 <newsham> jmc: possibly.  i want to treat the file as raw sequence of bytes.
16:07:25 <newsham> possibly I shouldnt use .Char8 ?
16:07:43 <dcoutts> newsham: I'm not sure what's going on there, it looks dodgy
16:07:45 <jmcarthur_work> i think it still would not explain why you are getting less
16:07:59 <newsham> ahh, without .Char8 I get the full length.
16:08:04 <newsham> I didnt realize .Char8 was doing clever stuff
16:08:15 <dancor> newsham: it must truncate unicode
16:08:16 <jmcarthur_work> i wasn't aware that it would...
16:08:18 <jmcarthur_work> huh
16:08:27 <jmcarthur_work> well that makes me wary
16:08:34 <mauke> newsham: what are the bytes around where it cut off?
16:08:36 <c_wraith> that sounds like horrible semantics.
16:08:40 <Saizan> truncate unicode?
16:08:40 <jmcarthur_work> ... that just doesn't seem right to me
16:08:48 <Saizan> never happened to me
16:09:06 <newsham> 65 64 1a 00 00 00 68 00 00    cuts off at the 1a I think
16:09:26 <CalJohn_> In gtk2hs, I am trying to set the an property on an object, but I don't understand the type signature of objectSetAttribute.  What does the quark do?  Why the maybe?
16:09:28 <mauke> huhu
16:09:32 <CalJohn_> @type objectSetAttribute
16:09:34 <lambdabot> Not in scope: `objectSetAttribute'
16:09:42 <mauke> newsham: it opened the file in text mode and interpreted ^Z as EOF
16:09:44 <CalJohn_> well, it's objectSetAttribute :: GObjectClass o => Quark -> o -> Maybe a -> IO ()
16:10:03 <newsham> ahh.. windows EOF marker.. lovely
16:10:17 <Vanadium> If I remember correctly, the quark is an interned string identifying the property in the first place
16:10:18 <jmcarthur_work> oh!
16:10:20 <CalJohn_> I'm assuming that objectSetAttr. is the same as g_object_set()
16:10:27 <Vanadium> and the maybe is probably because you can unset properties
16:10:40 <Vanadium> possibly representing NULL pointers?
16:11:18 <CalJohn_> oh, so the "name" of the property is quarkFromString "name"?
16:11:20 <dcoutts> CalJohn_: each widget has its own set of attributes, the Quark stuff is low level stuff that you almost certainly do not want.
16:12:05 <CalJohn_> dcoutts: ok, so I should look for the right high level function to use
16:12:20 <dcoutts> CalJohn_: http://haskell.org/gtk2hs/documentation/#hello_world
16:12:29 <dcoutts> CalJohn_: see the syntax for setting attributes ^^
16:12:41 <newsham> thanks guys.
16:12:46 <newsham> #haskell++
16:13:15 * jmcarthur_work eyes Data.ByteString.Lazy.Char8 suspiciously
16:13:24 <CalJohn_> ahhh, i had forgotten about that syntax
16:16:18 <Twey> It's not syntax
16:16:23 <Twey> Just an IO action
16:16:27 <CalJohn_> yes, it's not technically syntax
16:17:48 <CalJohn_> I'm trying to set the location field on a gstreamer source element...still haven't found it
16:18:58 <Twey> From which library are you getting the gstreamer widget?
16:19:20 <CalJohn_> gtk2hs
16:19:39 <Twey> I thought gtk2hs only provided GTK bindings
16:20:00 <CalJohn_> Media.Streaming.GStreamer ?
16:20:00 <dcoutts> it's expanded to lots of gnome stuff too
16:20:30 <hackagebot> parsec 3.0.1 - Monadic parser combinators (DerekElkins)
16:20:42 <Twey> I can't find anything gstreamer-related in Graphics.UI.Gtk
16:20:47 <copumpkin> @hackage parsec
16:20:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
16:21:32 <CalJohn_> Twey: it's in Media.Streaming.GStreamer
16:22:11 <monadic_kid> if anyone is interested: http://www.reddit.com/r/programming/comments/9izg4/23_lazyfoo_sdl_tutorials_in_haskell/
16:24:18 <Twey> Hm I don't have this module.
16:24:27 <Twey> monadic_kid: Oh, someone else did that, did they?
16:24:34 <monadic_kid> i did it
16:24:38 <Twey> Ah 
16:24:44 <Twey> That was on my project list
16:24:47 * Twey scratches it off.
16:25:11 <monadic_kid> still doing it but stop for a bit
16:25:32 <Twey> Can't you find anywhere better to host it than MediaFire?
16:25:59 <monadic_kid> i don't, what would be better?
16:26:21 <copumpkin> preflex: seen ddarius
16:26:21 <preflex>  ddarius was last seen on #haskell 103 days, 22 hours, 3 minutes and 30 seconds ago, saying: parsec2 is faster and what most libraries expect.
16:26:58 <Twey> monadic_kid: Just direct HTTP or FTP on a server somewhere so downloaders don't have to go through the MediaFire interface crud to download it
16:27:20 <Twey> Probably someone here will have a few megabytes to spare for a Haskell project
16:27:49 <monadic_kid> i don't know, I have webspace but I need to sort it out first
16:27:55 * sclv__ idly gripes that ghc still doesn't have type equality as a type level primitive and that you can't do it with type families and generally wonders if this is in the pipeline
16:28:13 <sclv__> (type equality as a type level function that is, not as equality constraints)
16:29:14 <Twey> sclv__: It doesn't?
16:29:33 <Twey> :t (+)
16:29:35 <lambdabot> forall a. (Num a) => a -> a -> a
16:29:46 <Twey> :t (1 :: Int) + (1 :: Integer)
16:29:48 <lambdabot>     Couldn't match expected type `Int' against inferred type `Integer'
16:29:48 <lambdabot>     In the second argument of `(+)', namely `(1 :: Integer)'
16:29:48 <lambdabot>     In the expression: (1 :: Int) + (1 :: Integer)
16:29:56 <Twey> Type equality
16:30:09 <sclv__> twey: I mean like type family TyEq x y
16:30:20 <sclv__> type instance TyEx x x = HTrue
16:30:30 <sclv__> type instance TyEq x y = HFalse
16:31:09 <sclv__> you can do this with fundeps, but you can't make it play well with type families
16:31:17 <Twey> Hmn
16:31:25 <Cale> monadic_kid: You could ask for an account on code.haskell.org here: http://community.haskell.org/admin/
16:32:55 <monadic_kid> i'll just sort out my own webspace tomorrow i think
16:34:04 <sclv__> monadic_kid: don't forget patch-tag for easy darcs repo hosting
16:34:14 <blackdog> or github, if you're that way inclined
16:37:21 <monadic_kid> yeah maybe
16:46:27 <monadic_kid> sleep
16:47:23 <copumpkin> edwardk: you abandoned your channel!
16:48:33 <edwardk> copumpkin: hah, my mistake =)
16:50:34 <Gracenotes> no, it doesn't count as abandonment if edwardk's sockpuppets are still here, surely :!
16:50:43 * Gracenotes looks around suspiciously
16:50:43 <edwardk> heh
16:51:13 * edwardk puts his sockpuppets away. I wasn't aware you could see those.
17:14:44 <monochrom> from Taiwan!
18:16:13 <Philonous> I like agdas mixfix operators. Is there any chance that those will ever go into haskell?
18:16:55 <dolio> I wouldn't hold your breath.
18:17:32 <lispy|web> Philonous: you mean like if_then_else_ :: Bool -> a -> a  ?
18:17:41 <lispy|web> er Bool -> a -> a -> a
18:17:47 <Philonous> lispy|web: Yes
18:18:03 <lispy|web> I think you could pretty seriously abuse that feature, but otherwise it would be very, very nice
18:18:22 <copumpkin> it would hinder golfing attempts
18:18:27 <copumpkin> since you must put spaces around operators
18:18:42 <Philonous> copumpkin: You should do that anyway
18:18:46 <dolio> The big problem with Agda's operators are that [a] [a ] [ a] and [ a ] are all different.
18:18:52 <dolio> For instance.
18:18:59 <lispy|web> dolio: o rly?
18:19:08 <lispy|web> That is pretty evil
18:19:45 <Philonous> Well, we could uphold the rule that alphanumeric and special characters would always be treated as different symbols. That defuses this problem
18:19:53 <dolio> (a, b) is different than (a,b) is different than (a , b)...
18:20:29 <lispy|web> ?users
18:20:29 <lambdabot> Unknown command, try @list
18:20:40 <lispy|web> ?list
18:20:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:20:52 <dolio> [a] is all one identifier. [a ] is some interaction of "[a" and "]", etc.
18:21:01 <lispy|web> ?seen
18:21:01 <lambdabot> Unknown command, try @list
18:21:07 <lispy|web> huh, was that module removed?
18:21:10 <lispy|web> Cale: ping
18:21:16 <lispy|web> , seen Cale
18:21:16 <Cale> pong
18:21:17 <lunabot>  luna: Not in scope: `seen'
18:21:24 <lispy|web> Cale: did you get my email :(
18:21:28 <Cale> lispy|web: yeah
18:21:33 <inimino> @seen inimino
18:21:34 <lambdabot> Unknown command, try @list
18:21:34 <chaosape> Wondering if doing this is possible without scoping the variable on line 13 ( http://codepad.org/ahbsVEfV )?
18:21:37 <inimino> huh
18:21:56 <lispy|web> Cale: can you log into olive?
18:22:00 <dolio> > (\ (   ) -> 5) ()
18:22:01 <Philonous> dolio: But this has nothing to do with mixfix operators. I don't think mixing of alphanumeric and special characters in operator names should be allowed
18:22:03 <lambdabot>   5
18:22:07 <Cale> lispy|web: Nope. Immediate connection closed.
18:22:12 <lispy|web> Cale: and also, were you running a freeciv server on olive?
18:22:15 <Cale> no
18:22:21 <lispy|web> Okay
18:22:28 <lispy|web> Then I think the machine was compromised
18:22:39 <Cale> I was only running lambdabot and a script to kill any random mueval instances which might run away.
18:22:46 <lispy|web> Right
18:23:01 <lispy|web> It's frustrating because that machine was running apache, ssh, and it had a firewall
18:23:09 <dolio> Philonous: Is if_then_else_ not an operator, then? Or are operators either all alphanumeric or all not?
18:23:13 <lispy|web> So I don't really know how someone would have gotten in
18:23:30 <Cale> Did it have the ssh key vulnerability?
18:23:43 <aavogt> chaosape: use functional dependencies for the class:  class D a b | a -> b where ...
18:23:54 <lispy|web> Cale: we did a fresh install of debian after that was patched
18:23:56 <dolio> I guess mixfix is desirable even if only for stuff like _?_:_
18:24:01 <Cale> hmm
18:24:06 <lispy|web> Cale: so I don't think it should have been exploitable that way
18:24:20 <aavogt> it depends on what other instances you want to allow
18:24:27 <lispy|web> it's possible imap was on there but it should have been behind the firewall
18:24:34 <Philonous> dolio: the latter. Maybe one could even relax that rule and Allow !_#_foo_bar, but not #foo_bar!
18:24:35 <Cale> I'm getting a 404 when I go to http://codersbase.com/
18:24:42 <Cale> Was there once a website there?
18:24:50 <lispy|web> Cale: yeah, some vhosts give 404 and others give directory lists
18:25:00 <lispy|web> Yes, that should redirect to blog.codersbase.com
18:25:08 <chaosape> aavogt: ack.
18:25:14 <lispy|web> I guess some apache stuff could have gotten hacked
18:25:17 <lispy|web> like php
18:25:25 <Cale> Yeah, that seems likely.
18:25:35 <McManiaC> hey, i wrote a darcs patch, and it finally shows up when i do "darcs changes --last 1" - but how can i put this whole patch into a file which i can send to mailinglist X?
18:25:40 <Cale> Maybe something like an injection attack?
18:25:47 <aavogt> McManiaC: darcs send
18:25:59 <dolio> Philonous: That might be a sweet spot. Although I have made wacky operators that mix symbols and letters right next to one another.
18:26:14 <lispy|web> McManiaC: if your postfix is properly configure just, darcs send, if not, darcs send -O, and it will create a file that you can attach in your mail client
18:26:30 <McManiaC> ah thx!
18:26:33 <lispy|web> McManiaC: sorry, I didn't mean postfix.  I meant, sendmail
18:26:40 <Philonous> dolio: That's not allowed in haskell, is it?
18:26:48 <Cale> lispy|web: You might be able to call up your hosting provider and get things fixed?
18:26:51 <Philonous> dolio: Or do you mean in agda?
18:27:11 <lispy|web> McManiaC: but if your sendmail is misconfigured it will still accept the email so darcs can't give an error in that case.  So be sure to make sure it works before you assume it will send :)
18:27:32 <lispy|web> Cale: My hosting provider has been unreachable since this happened
18:27:36 <McManiaC> i'll just use -o :)
18:27:44 <lispy|web> McManiaC: -o is different than -O
18:27:55 <McManiaC> whats the difference?
18:27:59 <lispy|web> McManiaC: -o requires a file name, -O names it for you based on the first patch name in the bundle
18:28:14 <McManiaC> ah cool
18:28:17 <dolio> Philonous: In agda.
18:28:32 <lispy|web> McManiaC: you can also configure darcs to call your mail client, check http://darcs.net/manual for details
18:28:44 <lispy|web> McManiaC: it can do things like call thunderbird
18:28:52 <McManiaC> cool :)
18:28:58 <Philonous> Btw. does haskell allows UTF8 characters in operator names?
18:29:07 <lispy|web> Cale: but, more specifically, do you have anything in mind for moving lambdabot?
18:29:22 <lispy|web> does anyone here have a server who can host lambdabot at least for a while?
18:29:44 <aavogt> @botsnack
18:29:44 <lunabot>  :o
18:29:44 <lambdabot> :)
18:30:01 <SamB_XP_> lispy: you could run it on my debian box ... you know, the one that keeps rebooting for no real reason ;-P
18:30:29 <lispy|web> SamB_XP_: heh
18:30:36 <idnar> heh
18:31:14 <lispy|web> If lambdabot were less resource intensive I could setup a virtual linux instance, at say, linode and put her there
18:31:24 <lispy|web> I would happily donate the $20/mo
18:31:26 <chaosape> aavogt: Thanks a bunch! Now that it compiles, I am going to go understand what I just did! ;^)
18:31:28 <copumpkin> I already run an instance on my slice
18:31:36 <lispy|web> But, lambdabot needs a fair bit of ram in my experience
18:31:38 <copumpkin> I used to join it here when lambdabot died
18:31:38 <dolio> Philonous: data x__x (a : Set) (P : a  Set) : Set where _,_ : (x : a) (w : P x)  x a  P x
18:31:45 <lispy|web> and that costs a bit on typical virtual machines
18:31:49 <copumpkin> but my lambdabot has always been buggier than the official one
18:31:52 <copumpkin> not sure why
18:33:10 <lispy|web> I wonder if we should send a message to Haskell-Cafe
18:33:46 <SamB_XP_> lispy|web: or you could send it to haskell@
18:34:10 <lispy|web> Does GHC have issues with Xen still?  I recall several years ago people sending in darcs bug reports due to GHC on some sort of virtual linux
18:34:26 <copumpkin> I've done a lot of work with it in a xen instance, so I'd guess not
18:34:33 <copumpkin> at least on 6.8 and 6.10
18:35:02 <lispy|web> good, good
18:35:14 <lispy|web> I think Cale tends to run lambdabot on recent GHCs
18:35:18 <lispy|web> ?version
18:35:18 <lambdabot> lambdabot 4.2.2.1
18:35:18 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:35:28 <lispy|web> guess she doesn't say anymore
18:36:15 <lispy|web> the cheapest linode has 360MB of RAM
18:36:25 <lispy|web> I doubt we can keep lambdabot happy with that little memory
18:36:42 <lispy|web> Depends on how well the swap works I guess :)
18:36:54 <lispy|web> Cale: I'd be willing to set something like that up, what do you think?
18:36:58 <lispy|web> Is it worth a try...
18:50:10 * monochrom downloads and tries out the latest released ghc
18:50:57 <monochrom> Err, I guess that will wait. I suddenly remember another thing to do.
18:53:44 <lispy|web> Cale: okay, I got impatient and order a linode :)
18:58:09 <aconbere> Where can I find the definition of <-
18:58:26 <CalJohn_> aconbere: <- is not a function, it's syntax
18:59:00 <Makoryu> aconbere: In which context? In do notation, it's sugar for a combination of (>>=) and (\ ... -> ...)
18:59:01 <aconbere> CalJohn_: do you know where I could learn more about it's function as syntax?
18:59:12 <Makoryu> @undo foo <- bar
18:59:12 <lambdabot>  Parse error at "<-" (column 5)
18:59:17 <aconbere> Makoryu: I was thinking inside do notation
18:59:20 <Makoryu> @undo do foo <- bar
18:59:20 <lambdabot>  Parse error at end of input
18:59:25 <Makoryu> Oh right
18:59:28 <Makoryu> @undo do foo <- bar; bazx
18:59:28 <lambdabot> bar >>= \ foo -> bazx
18:59:33 <CalJohn_> if you're trying to learn what do notation does, it's probably best to start with one of the monad tutorials.  learn about >>=, >> and return first :)
19:00:10 <CalJohn_> @type (>>=)
19:00:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:00:12 <CalJohn_> @type (>>)
19:00:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:00:18 <CalJohn_> @type return
19:00:19 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:15:39 <defun> what is the diference between xlib and the xserver? Would it be possible to rewrite xlib in haskell (COMPLETELY theoretical, I assure you), and still build a GUI app in haskell using said lib that "seamlessly" interacts with other X software over a network. In other words is Xlib coupled to the xserver?
19:16:04 <SamB_XP_> defun: Xlib is indeed not necessary
19:16:15 <defun> thanks
19:16:22 <SamB_XP_> I believe there is, for example, a pure-python X client library
19:16:37 <defun> So it's all about the protocol?
19:16:51 <ray> if you want to speak the nasty icky disgusting protocol yourself, you can
19:16:52 <SamB_XP_> mostly
19:16:56 <SamB_XP_> yeah
19:17:21 <SamB_XP_> I mean, there's some logic in Xlib too ;-)
19:17:27 <defun> thanks.
19:18:07 <defun> how does XCB compare to Xlib? Does Xmonad use Xlib to do it's thing?
19:18:56 <defun> *its
19:19:08 <SamB_XP_> actually, I think XHB might *be* a reimplementation of XCB?
19:19:17 <SamB_XP_> @go XHB haskell X
19:19:18 <lambdabot> Maybe you meant: google googleit do
19:19:23 <SamB_XP_> @google XHB haskell X
19:19:25 <lambdabot> http://hackage.haskell.org/package/xhb
19:19:25 <lambdabot> Title: HackageDB: xhb-0.3.2009.6.28
19:19:56 <defun> now that's cool.
19:20:43 <defun> So one can theoretically build a Haskell gui toolkit from scratch, using all of haskell's declarative goodness? (yes, I hate gtk2hs)
19:20:55 <Makoryu> defun: That would be pretty awesome
19:21:12 <defun> That would be /perfect/
19:21:18 <SamB_XP_> defun: sure -- in theory. but you're not going to escape having to deal in IO!
19:21:30 <lispy|web> Hmm...linking cabal-install is taking ages
19:21:41 <Makoryu> defun: Of course, if you made it X11-only, I'd have to suck your liver out through a straw
19:21:48 <SamB_XP_> most such efforts seem doomed to be mothballed with the papers from which they spawned :-(
19:21:49 <defun> lol
19:22:07 <defun> papers? research papers?
19:22:19 <SamB_XP_> yeah
19:22:34 <SamB_XP_> or maybe the papers were spawned from the systems -- either way ...
19:22:42 <Makoryu> defun: ...Hell, you could make gtk2hs one of the backend options for it
19:23:22 <PetRat> I'm learning qtHaskell. I ran into the problem of needing state in my application. One of the qtHaskell examples provided by the author uses IORef. Is this a typical way of adding state to the IO monad?
19:25:02 <defun> Makoryu: as far as IO goes, there'd be the possibility of lifting 'pure' animations into the monad and making 'impure' things monads by default (like a text-box or something). I'm brainstorming, though.
19:25:41 <defun> SamB_XP: that was supposed to be a response to you
19:25:45 <defun> sorry
19:27:35 <defun> input is essentially done through keyboard and mouse. We could use lifting combinators such as `onMouseHover` and `onMouseLeftClick` to combine animations concisely as monads/arrows/whatever.
19:27:52 <defun> i think
19:28:12 <defun> either way, it would be fun to have an all-out extensible haskell toolkit.
19:29:50 <PetRat> I'm learning qtHaskell. I ran into the problem of needing state in my application. One of the qtHaskell examples provided by the author uses IORef. Is this a typical way of adding state to the IO monad?
19:30:03 <kmc> yes
19:31:30 <PetRat> kmc: I'm probably not phrasing this right but---at first I was dismayed to think "but those guys are global variables, are there only global variables in Haskell?"--- then I noticed that there is something similar to static and member variables in the idea of partial application with an IORef as one argument.
19:31:51 <kmc> they're not global
19:32:01 <kmc> the reference itself is a value which is scoped the same way as any other variable
19:32:18 <kmc> it's like passing around refs in C++, or pointers (but without all the safety issues)
19:33:07 <PetRat> kmc: but they can't be associated with a widget the way a subclassed object would (if I were writing Qt GUIs in C++)_
19:33:43 <kmc> PetRat, you can put IORefs into datastructures to encapsulate and group them
19:33:54 <kmc> and you can also capture them into closures, as you pointed out
19:34:11 <PetRat> kmc: Okay, I will keep exploring this. I see what you are saying.
19:34:36 <dm``> Also check out MVars, especially is you will be using threads.
19:35:12 <kmc> and ST, for the case where you *only* want vars and not IO
19:35:20 <kmc> (not directly relevant but good to know)
19:35:33 <dm``> How is ST different from StateT?
19:35:37 <kmc> totally
19:35:41 <PetRat> kmc and dm, yeah for the moment I'm just trying to get a GUI app running.
19:35:48 <PetRat> Threads are not needed.
19:36:02 <kmc> StateT is the transformer version of State, which is implemented purely in haskell and simply threads state by passing it around to functions
19:36:27 <kmc> ST gives true mutable cells with the same performance as IORefs
19:36:31 <dm``> Am familiar with StateT, so maybe I should have asked what ST is...
19:36:48 <kmc> except that (through clever use of rank-2 types) a ST computation can be made pure again
19:37:00 <kmc> the type system ensures that you haven't let stateful indeterminism leak out
19:37:26 <dm``> The haddock on ST (which I'm just looking at) is not very good at giving the big picture...
19:37:34 <kmc> dm``, do you know how IORefs work?
19:37:44 <SamB_XP_> dm``: maybe you should read a paper ?
19:37:46 <dm``> Yes, have used IORefs, StateT, and MVars, but not ST.
19:37:55 <kmc> dm``, STRefs are like IORefs
19:38:03 <kmc> (ST s a) is like (IO a)
19:38:07 <heatsink> runST is like running an IO computation, except that its effects affect the ST's own mini-world
19:38:07 <dm``> how do they get rid of the IO?
19:38:22 <kmc> the type variable 's' stays uninstantiated
19:38:24 <SamB_XP_> dm``: oh, they use a fake world
19:38:29 <SamB_XP_> instead of the realworld ;-)
19:38:31 <kmc> hence runST :: (forall s. ST s a) -> a
19:38:49 <kmc> which is very different from forall s. (ST s a -> a)
19:39:06 <lispy|web> my attempt to build cabal-install has gotten stuck in ld
19:39:15 <lispy|web> like 80% memory usage, less than 1% CPU usage
19:39:19 <lispy|web> anyone else seen this?
19:39:35 <kmc> the types of your STRefs are "tagged" with that uninstantiated var 's', which will not unify with the var from any other "thread" of ST-ful computation
19:39:53 <kmc> thus ensuring that the pocket universes do not interact
19:40:04 <dm``> Okay will have to think about ST.  Any good papers, or is haddock and source the best place?
19:40:10 <SamB_XP_> lispy|web: that typically happen(s|ed) whenever I link(|ed) a Haskell program ;-)
19:40:19 <kmc> dm``, i think if you're familiar with IORefs, you can jump right in
19:40:42 <SamB_XP_> dm``: I believe the Haddock references a paper at the top?
19:40:47 <kmc> just substitute "ST" for "IO", and note that this safe function runST exists, whereas the IO equivalent is the much-despised unsafePerformIO
19:40:53 <dm``> http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-ST.html
19:40:59 <dm``> Don't see a paper.
19:41:02 <kmc> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html#v%3ArunST
19:41:21 <lispy|web> SamB_XP_: and what do you do about it?
19:41:43 <kmc> dm``, look at Control.Monad.ST and Data.STRef
19:41:45 <dm``> ah, that's better.  References a PLDI paper.  Guess I got an old version from hoogle or something.
19:41:49 <dm``> Thanks, I'll look at those.
19:41:54 <kmc> you were looking at the ST-monad arrays
19:42:01 <kmc> which are also useful, but less primitive
19:42:05 <SamB_XP_> lispy|web: wish GNU ld would FOAD
19:42:33 <lispy|web> SamB_XP_: okay, but is there anything I can do to make it go faster?  does it help to restart it?  What is gnu ld so memory intensive?
19:42:41 <lispy|web> is it time to rewrite ld in haskell?
19:43:17 <SamB_XP_> lispy: the problem is related to having libs built with -fsplit-objs, I believe
19:43:27 <SamB_XP_> ld doesn't like that very much :-(
19:43:53 <dm``> :t RealWorld
19:43:55 <lambdabot> Not in scope: data constructor `RealWorld'
19:44:01 <erikc> what does -fsplit-objs do?
19:44:10 <_nickel> hey guys, still at the beginning stages of learning haskell and I have a question: If I defined the following class how do I remove the ambiguity during use? http://gist.github.com/184258
19:44:19 <SamB_XP_> erikc: put more-or-less every function into it's own .o file
19:44:37 <_nickel> code and ghci output at the link
19:44:55 <lispy|web> SamB_XP_: this is frustrating
19:45:01 <lispy|web> SamB_XP_: would more ram help?
19:45:07 <SamB_XP_> probably
19:45:07 <lispy|web> or do I need faster disk IO or what?
19:45:17 <SamB_XP_> I think it's RAM that would help
19:45:19 <erikc> lispy|web: what platform?
19:45:33 <lispy|web> debian lenny inside a Xen virtual machine
19:45:40 <lispy|web> only like 360MB of physical ram
19:45:49 <SamB_XP_> do you have top(1) set up to display not only the CPU usage view but also the memory usage view ?
19:45:51 <heatsink> _nickel: Hide the definition of (==) from the prelude
19:45:59 <heatsink> _nickel: import Prelude hiding((==))
19:46:17 <_nickel> heatsink: perfect I'll try that
19:46:48 <lispy|web> SamB_XP_: I believe so
19:47:02 <lispy|web> SamB_XP_: 410MB VIRT and 275 MB RSS
19:47:09 <lispy|web> er RES not RSS
19:47:10 <heatsink> _nickel: Oh, you're using the definition of ==, so you have to import it qualified
19:47:19 <SamB_XP_> lispy: I mean, mine is split to show two panes
19:47:22 <heatsink> _nickel: import qualified Prelude
19:47:31 <heatsink> _nickel: you can use both import statements together
19:47:56 <SamB_XP_> #1 and #4, I think
19:49:16 <lispy|web> SamB_XP_: is there a way to turn off -fsplit-obs
19:49:52 <SamB_XP_> lispy: it's presumably too late for that -- the libGHC*.a where it hurts you are already built
19:55:30 <lispy|web> SamB_XP_: what if I build ghc?
19:55:43 <lispy|web> a friend of mine has a lenny box that he said I could borrow if it would help
19:55:50 <SamB_XP_> lispy: yes, it is possible to turn it off
19:55:56 <SamB_XP_> but I don't know how
19:56:12 <lispy|web> This is anoying :)
19:56:26 <SamB_XP_> I forgot *AND* they rewrote the build system since I knew
19:56:47 <SamB_XP_> Igloo would hopefully know ?
19:56:51 <SamB_XP_> or someone in #ghc
19:57:03 <SamB_XP_> how to disable -fsplit-objs for GHC library build
19:58:46 <lispy|web> I see a ticket about this in trac, but no resolution
19:58:56 <lispy|web> http://hackage.haskell.org/trac/ghc/ticket/3016
20:02:59 <dm``> Okay, I think I get it... newSTRef is like newIORef, and the weird forall s prevents you from returning an STRef or passing one into a nested invocation of runST.
20:03:24 <kmc> Yup
20:03:52 <kmc> dm``, do you understand the forall type syntax? it's an extension
20:04:19 <dm``> Cool.  Thanks.  Yes, I sort of understand it--for instance I used it with the new Exception stuff--but maybe haven't totally internalized it.
20:04:54 <kmc> in normal haskell there is an implicit 'forall' for each type variable, at the left of the type and scoping over the whole thing
20:05:23 <kmc> such a type is "rank 1"
20:05:43 <kmc> if we have a rank-n type on the left side of ->, that's rank n+1
20:06:17 <dm``> Which "->"-- you mean for types or kinds.
20:06:22 <kmc> types
20:06:34 <kmc> (there are no kind variables, hence no kind quantification)
20:06:36 <kmc> so the type of runST is rank-2
20:07:21 <kmc> instead of *promising* that the runST works for any s, we *require* that its argument work for all s
20:07:55 <dm``> And each invocation of runST uses a different type s, ensuring all of the STRefs are incompatible?
20:08:06 <kmc> the alternation between promises and obligations is what type theorists call "contravariance"
20:08:15 <SamB_XP_> dm``: well, you can't tell that they don't ;-)
20:08:33 <kmc> basically
20:09:09 <kmc> you'll note that no *values* of type s are involved in using the ST monad
20:09:20 <kmc> and luckily so, because the only value in (forall s. s) is bottom
20:10:39 <_nickel> heatsink: can you explain whats happening when I use both import statements (sorry the wife occupied me for a moment)
20:11:48 <dm``> Well, I think I get it.  Thanks for explaining.
20:12:34 <kmc> :)
20:13:15 <dm``> Last questions: id is of rank 1?  is "const 5" rank 1 or 2?
20:13:22 <kmc> :t const 5
20:13:24 <lambdabot> forall t b. (Num t) => b -> t
20:13:33 <kmc> rank 1, the forall is outside everything
20:13:39 <kmc> any type in Haskell 98 is rank 1
20:14:09 <copumpkin> :t let f :: (forall a. a -> a) -> a; f x = x x in f id 5
20:14:11 <lambdabot>     Couldn't match expected type `a1' against inferred type `a -> a'
20:14:11 <lambdabot>       `a1' is a rigid type variable bound by
20:14:11 <lambdabot>            the type signature for `f' at <interactive>:1:31
20:14:33 <kmc> in h98, foralls (which are never written) promise generality, whereas an explicit forall to the left of -> is a demand from the user for generality
20:15:22 <copumpkin> I remember reading that inference in rank2 polymorphism is decidable, but higher than 2 you lose that
20:15:40 <kmc> that'd make sense, ghc supports rank-2 and rank-n as separate extension flags
20:15:43 <kmc> i always wondered why
20:16:04 <copumpkin> I was wondering if anyone had any citations on that
20:16:09 <kmc> dm``, copumpkin has a good point; with higher-rank types, sometimes type inference will not infer the most general type
20:16:25 <kmc> so watch out for that, and if you're getting bizarre type errors, write an explicit signature
20:16:31 <copumpkin> I think http://en.wikipedia.org/wiki/Type_polymorphism covers it
20:16:32 <kmc> (not bad advice in general)
20:16:40 <copumpkin> :)
20:20:43 <ray> rank 999 types
20:21:39 <shachaf> Is there a reason type inference won't do it? Is it not possible in general?
20:22:08 <lispy|web> how do I build ghc without -fsplit-objs?  I can't find that flag metioned in the source tar ball
20:22:10 <ray> that page makes the claim that it's not decidable in general for ranks above 2
20:22:45 <ray> so with RankNTypes you should probably provide type signatures
20:22:48 <canvon> :t let f :: (forall a. a -> a) -> a -> a; f x = x in f id 5
20:22:50 <lambdabot> forall t. (Num t) => t
20:22:57 <kmc> "For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC's type inference will assume that x's type has no foralls in it. "
20:23:14 <kmc> ghc manual 7.8.4.2
20:25:07 <orbitz> what is my best bet for representing a 2d array of values?
20:25:17 <copumpkin> what would be needed to add higher-rank type parameters too?
20:25:17 <kmc> orbitz, what properties do you need
20:25:30 <copumpkin> something like a -> [forall b. b]
20:25:32 <copumpkin> :P
20:25:57 <ray> list of bottoms
20:26:05 <orbitz> kmc: i'm implementign cellular automota, so i want to be abel to query value and easily update surroundign values
20:26:11 <copumpkin> ray: yep
20:26:36 <ray> :t (fix (undefined:)) :: [forall a. a]
20:26:38 <lambdabot>     Cannot match a monotype with `forall a. a'
20:26:38 <lambdabot>       Expected type: [forall a. a]
20:26:38 <lambdabot>       Inferred type: [a]
20:26:54 <kmc> orbitz, do you want to mutate values in-place, or pass around successively newer copies of the array, each one immutable?
20:26:59 <Makoryu> :t fix (undefined:)
20:27:01 <lambdabot> forall a. [a]
20:27:15 <canvon> > let f :: a -> [forall b. b]; f _ = [error "foo"] in head (f 1)
20:27:18 <lambdabot>   * Exception: foo
20:27:19 <kmc> the former will require your code live inside some or another monad
20:27:25 <orbitz> kmc: i don't hav ea preference
20:27:26 <ray> there we go
20:27:32 <orbitz> kmc: at this point: whichever is easier
20:27:34 <kmc> orbitz, how important is speed
20:27:52 <orbitz> kmc: at this point, not very (displaying to user)
20:27:57 <kmc> okay
20:28:07 <kmc> well your display code might be in the IO monad anyway, but you can still do pure updates
20:28:13 <kmc> let's start there, i think it will be easier
20:28:28 <orbitz> ok
20:28:31 <kmc> so you'll probably want: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html
20:28:46 <lispy|web> SamB_XP_: so if this is a dynamic option I should be able to disable it
20:28:52 <orbitz> kmc: so my use case right now is: i'll upate a value at point (x, y), if that value goes over some value, i'll be modifying it + it's surounding 4 elements
20:28:56 <lispy|web> SamB_XP_: do I really need to rebuild GHC?
20:28:57 <kmc> that describes an interface for immutable arrays with pure-functional update (by returning the new array, not modifying in place)
20:29:23 <orbitz> kmc: cool thanks
20:29:27 <kmc> types implementing that interface include Array, DiffArray, UArray, and DiffUArray
20:29:27 <SamB_XP_> lispy|web: you need it disabled when the libraries are compiled
20:29:34 <kmc> the latter two are unboxed
20:29:38 <kmc> and strict
20:29:39 <Tony[`]> So guys, if I wanted to do a sieve approach to finding primes, generally mutable arrays make best sense to me coming from the imperative world. The functional alternative with comparable performance, or some sort of stateful approach to doing so w/ monads?
20:29:44 <lispy|web> SamB_XP_: okay, so if I set can_split = "NO" that should do it?
20:29:54 <SamB_XP_> lispy|web: at present, your libraries have a shitload of .o files in them
20:29:57 <lispy|web> an_split :: Bool can_split = cSplitObjs == "YES"
20:30:19 <SamB_XP_> lispy|web: guess so!
20:30:28 <copumpkin> Tony[`]: I have a one-liner sieve, but probably not what you're after ;)
20:31:06 <SamB_XP_> er, but isn't more a command line flag you want to make sure GHC is passed when building the libs ?
20:32:52 <kmc> copumpkin, ghci accepts [forall a. a] with -XRankNTypes -XImpredicativeTypes
20:32:55 <Tony[`]> copumpkin: I'm just curious what a very functional approach to a highly performant prime-finder looks like
20:33:04 <copumpkin> kmc: ah, I see :)
20:33:15 <copumpkin> Tony[`]: have you read o'neill's paper?
20:33:17 <ray> impredicative, nice
20:33:21 <Tony[`]> because i could do something like nubBy (flip divides) [2..]
20:33:21 <Tony[`]> no
20:33:27 <Tony[`]> but that's not quick at all
20:33:39 <kmc> i don't understand what impredicative types are
20:33:57 <Tony[`]> types that can't be use as predicates? :P
20:34:08 <kmc> "This means that you can call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types."
20:34:15 <kmc> to me the former sounds like rank->1 types
20:34:39 <copumpkin> Tony[`]: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
20:35:05 <Tony[`]> copumpkin: MUCH appreciated :)
20:35:06 <Tony[`]> thank you
20:35:28 <lispy|web> SamB_XP_: I found ./mk/build.mk.sample any idea what I do with this after I customize it?
20:36:37 <lispy|web> I think I got it
20:36:49 <lispy|web> I put want in ./mk/build.mk
20:36:51 <lispy|web> then run ./boot
20:37:02 <lispy|web> followed by ./configure and make
20:42:10 <lispy|web> Cale: if you're following along, then hopefully by the time you try logging in I'll have this ghc madness solved :)
20:43:20 <lispy|web> SamB_XP_: do you know if default 'make && make install' for ghc gives you profiled copies of libraries?
20:43:32 <orbitz> kmc: I had some problems constructing Data.Array.IArray in ghci, is that normal?
20:43:38 <SamB_XP_> lispy: I'm not sure
20:44:54 <m4ik3ru> Howdy :)
20:45:03 <SamB_XP_> howdy!
20:45:14 <SamB_XP_> @slap it
20:45:14 <lambdabot> I'd rather not; it looks rather dangerous.
20:45:22 <m4ik3ru> Hah :)
20:45:29 <m4ik3ru> Ok, so, a little disclaimer:
20:45:36 <canvon> > listArray (1, 10) [1..10] :: Array Int Int
20:45:40 <lambdabot>   array (1,10) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
20:46:27 <canvon> orbitz: perhaps you got a "Ambiguous type variables" error? IArray is only an abstract interface, you have to specify the concrete type you're going to use. like I just did with ":: Array Int Int"
20:46:28 <Veinor> What's @slap?
20:46:30 <m4ik3ru> This IS a homework problem.  I DO NOT want you to solve it for me.  I have done a large portion of the assignment by myself and with the help of others here.  I just need to understand how lists of lists work and how to access elements within, etc...
20:46:46 <m4ik3ru> That being said:
20:46:58 <orbitz> canvon: sounds bou right
20:47:15 <SamB_XP_> m4ik3ru: good of you to be clear on that -- some of us a are a bit overenthusiastic ;-P
20:47:25 <m4ik3ru> I'm implementing a function of the type powerSet::[a] -> [[a]]
20:48:06 <m4ik3ru> I've already implemented take, map, filter, and concat from the basic functions
20:48:24 <m4ik3ru> i've done mathematical union, intersection and subset.
20:48:36 <m4ik3ru> And I don't know where to start on this one.
20:48:53 <SamB_XP_> darn!
20:49:00 <SamB_XP_> I almost gave it away ;-)
20:49:04 <m4ik3ru> I'm assuming the use of  : instead of ++ since I want to go TO a list a lists and not FROM a list of lists.
20:49:31 <m4ik3ru> Can I access directly the elements of a list of the form (x:xs)?
20:49:41 <m4ik3ru> Don't know if that would help me...
20:49:42 <kmc> m4ik3ru, yes, by matching that pattern
20:50:02 <kmc> to do this you should only need (:) in its pattern and expression forms
20:50:08 <m4ik3ru> I accessed them recursively before, but only as the head (x) and tail (xs)
20:50:11 <kmc> maybe ++ as well
20:50:22 <kmc> but nothing like (!!), i don't think
20:50:29 <SamB_XP_> kmc: indeed
20:51:00 <kmc> now we will all join #haskell-minus-m4ik3ru and play lambdabot golf to get a solution which is only 3 characters long
20:51:25 <m4ik3ru> ...
20:51:28 <SamB_XP_> kmc: you can't do that without cheating
20:51:29 <kmc> :)
20:51:33 <m4ik3ru> I feel I am being patronized...
20:51:45 <kmc> m4ik3ru, sorry, that's not my intention
20:51:45 <SamB_XP_> m4ik3ru: he's exhagerating slightly
20:51:55 <kmc> i'm more making fun of the sport
20:52:06 <SamB_XP_> it's just that this was one of our favorite functions to golf, I think ;-)
20:52:14 <m4ik3ru> Golfing?
20:52:30 <SamB_XP_> try to write really short code to do it
20:52:47 <m4ik3ru> Ah :)
20:53:32 <SamB_XP_> but 3 characters is only room for one application, and even then only if the variables are only one letter each
20:54:05 <deech> Hi all, Haskell's list expansions, for example [1,3 .. 7] => [1,3,5,7], is pretty cool. Is there any way I can redefine the rule that produces the list? So for example, [1,4,.. 32] => [1,4,9,16,32]
20:54:47 <kmc> deech, you can define your own numerical type, and give its instance for the typeclass Enum
20:55:08 <SamB_XP_> deech: don't you mean 16,25,36 ?
20:56:10 <deech> SamB_XP_: Oops! I switched to powers of 2 in the end.
20:56:15 <heatsink> deech: The list expansion is really just a function call
20:56:20 <heatsink> > enumFromThenTo 1 3 7
20:56:23 <lambdabot>   [1,3,5,7]
20:56:25 <kmc> you could use newtype plus ghc's newtype deriving to automate a bunch of the work
20:56:36 <Berengal> Defining a new type just to get ranges seems like a bad idea. A better idea would be to just make and call the functions directly
20:56:49 <Berengal> The Right Thing is probably a list comprehension
20:56:57 <SamB_XP_> > map (^2) [1..]
20:57:01 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
20:57:14 <dolio> > scanl1 (+) [1,3..]
20:57:18 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
20:57:28 <SamB_XP_> dolio: woah, neat
20:57:57 <SamB_XP_> > scanl' 0 (+) [1,3..]
20:57:57 <deech> dolio: mind blown. Didn't know you could do that. Can you explain?
20:58:00 <lambdabot>   Not in scope: `scanl''
20:58:07 <SamB_XP_> > scanl 0 (+) [1,3..]
20:58:11 <lambdabot>   Add a type signature
20:58:16 <SamB_XP_> > scanl (+) 0 [1,3..]
20:58:20 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
20:58:32 <SamB_XP_> > tail $ scanl (+) 0 [1,3..]
20:58:36 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
20:58:39 <dolio> I'm not sure what you want me to explain. The sum of the first n odd numbers is a perfect square.
20:59:00 <deech> dolio: Wow I didn't know that!
20:59:08 <Berengal> scanl is nifty
20:59:28 <Berengal> Sometimes it gets too little use
20:59:48 <Berengal> Sometimes I think *
21:00:12 <Veinor> scanl is like foldl but it builds up partials, right?
21:00:30 <SamB_XP_> Veinor: doesn't it look like that ?
21:00:40 <Gracenotes> deech: imagine, like, a 1-by-1 square, then 2-by-2, then 3-by-3, and so on. To make the next biggest square from the current one, the next layer needs two more units than the last
21:00:56 <dolio> Yeah. foldl f z (x:xs) = foldl f (f z x) xs, scanl f z (x:xs) = z : scanl f (f z x) xs.
21:01:14 <Veinor> also, why is scanr's order the way it is?
21:01:37 <Gracenotes> it's the same as foldr
21:02:13 <Veinor> Eh, true.
21:02:14 <Gracenotes> it also has an accumulator function order which is opposite of foldl
21:03:55 <Gracenotes> if you write out, say, foldr/l (+) 0 [x,y,z], it seems to look nicer with each respective order
21:04:18 <m4ik3ru> I haven't thought hard enough about this one yet.  I shall continue to sift and come back at a later date.
21:05:28 <ray> english speakers read from left to right so foldl seems more natural but this is just an illusion, it is foldr that is natural
21:05:29 <copumpkin> deech: that fact is often used as an introduction to induction
21:05:41 * copumpkin finds writing left to right rather unnatural
21:06:11 <ray> foldr just uses the spine of the list, foldl turns the list inside out
21:06:56 <ksf> there's foldl' and foldr. everything else is a performance problem.
21:07:16 * copumpkin never really did get the justification for sum and product being written in terms of foldl
21:07:24 <copumpkin> foldr I could understand
21:07:35 <ksf> mconcat is written in foldr
21:07:40 <dolio> foldl' doesn't exist in the report.
21:07:50 <ray> yeah, but why not foldr?
21:07:55 <Makoryu> copumpkin: Well, sum and product are commutative, so it doesn't matter, really, does it?
21:08:10 <copumpkin> Makoryu: except that foldl is forced to traverse the entire list
21:08:20 <copumpkin> so things like
21:08:30 <copumpkin> > foldr1 (+) [1..] > (3 :: Natural)
21:08:34 <lambdabot>   True
21:08:37 <copumpkin> > sum [1..] > (3 :: Natural)
21:08:40 <dolio> foldr doesn't even give you the possibility of optimizing when the addition operator is strict and you have badass strictness analysis.
21:08:45 <ray> it is associativity that matters, because one is 1+(2+(3)) and one is ((1)+2)+3
21:08:52 <lambdabot>   thread killed
21:08:57 <Gracenotes> a huge difference, in the context of modeling primitive recursive functions as folds, is if there's an accumulator or not. foldl uses an accumulator that changes with every element of the list. foldr.. really just has an element to put at the end, if there is one
21:09:20 <ray> foldr just deconstructs the list, folding away as it goes
21:09:24 <Gracenotes> it is quite natural, though; structural recursion for lists
21:09:37 <ray> yes, structural recursion is the word
21:10:00 <copumpkin> the bird is the word
21:10:07 <SamB_XP_> bananas!
21:10:08 <ksf> maybe it should be called "mapSpine"
21:10:12 <ray> one thing that's cool is reverse = foldl (:) []
21:10:19 <mmorrow> , foldl' (flip (:)) [0..9]
21:10:20 <SamB_XP_> hmm. would it be unsmart of me to eat another banana?
21:10:20 <lunabot>  luna: No instance for (GHC.Show.Show ([b] -> [b]))
21:10:21 <mmorrow> heh
21:10:26 <mmorrow> , foldl' (flip (:)) [] [0..9]
21:10:27 <lunabot>  [9,8,7,6,5,4,3,2,1,0]
21:10:43 <mmorrow> SamB_XP_: no
21:10:49 <Gracenotes> it turns out that is really quite efficient, both memory-wise and time-wise
21:11:01 <mmorrow> eating nanas?
21:11:44 <mmorrow> , time (head (foldl' (flip (:)) [] [0..10000000]))
21:11:49 <lunabot>  Killed.
21:11:52 <Gracenotes> I find that some obscure folds become much clearer when converted to primitive recursive functions (fold source substitution)
21:11:52 <mmorrow> , time (head (foldl' (flip (:)) [] [0..100000]))
21:11:53 <ray> booooooooooooooooom
21:11:54 <lunabot>  (1.5998e-2,100000)
21:11:58 <mmorrow> , time (head (foldl (flip (:)) [] [0..100000]))
21:12:01 <lunabot>  (1.7997e-2,100000)
21:12:04 <mmorrow> , time (head (foldl (flip (:)) [] [0..1000000]))
21:12:07 <lunabot>  (0.44593299999999997,1000000)
21:12:08 <mmorrow> , time (head (foldl' (flip (:)) [] [0..1000000]))
21:12:11 <lunabot>  (0.169974,1000000)
21:12:46 <mmorrow> , time (last (foldl (flip (:)) [] [0..1000000]))
21:12:49 <lunabot>  (0.580911,0)
21:12:51 <mmorrow> , time (last (foldl' (flip (:)) [] [0..1000000]))
21:12:53 <lunabot>  (0.180973,0)
21:13:29 <mmorrow> i wonder if there's some way to get mem-usage too
21:13:33 <ray> , time $ foldr (:) [] [0..1000000]
21:13:35 <lunabot>  (0.0,[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
21:13:42 <copumpkin> mmorrow: yep, remember we found that counter?
21:13:50 <ray> tee hee
21:13:51 <copumpkin> I'm pretty sure it was with you
21:13:54 <mmorrow> copumpkin: for a single expression though
21:13:57 <mmorrow> or something
21:14:08 <mgaines12> can somebody help me with an assignment? its pretty simple but im new to programming
21:14:16 <copumpkin> mmorrow: well, if you can be sure you've got nothing else going on, just look before and after?
21:14:18 <Veinor> mgaines12: ask and we'll see what we can do :D
21:14:28 <copumpkin> mmorrow: I think that's all ghci does with :set +s
21:14:44 <mmorrow> copumpkin: oh right, i forgot about +s.. been off for so long
21:15:39 <mgaines12> need a program that lets a user enter the name of an item, the quantity of it, how many will fit into a box. Then it must display the name, number of full boxes, and how many are left over
21:16:27 <Veinor> What're you having problems with?
21:17:22 <mgaines12> how do i start off?
21:17:35 <ksf> anywhere.
21:17:35 <tommd> mgaines12: is there a requirement to use a particular language?  There usually is and it is rare that Haskell is the first language to learn.
21:17:44 <Veinor> And yeah, is there any particular language?
21:17:45 <ksf> the problem is quite flat.
21:18:24 <mgaines12> c++
21:18:42 <tommd> mgaines12: Then you are in the wrong channel - ask in a c++ channel.
21:18:43 <ksf> my condolences.
21:18:55 <mgaines12> using microsoft visual c++ express edition
21:19:03 <Veinor> Yeah, this is a haskell-oriented channel.
21:19:04 <tommd> Owch
21:19:11 <ksf> you should appeal to the court of human rights.
21:19:30 <tommd> Or just change universities.
21:19:50 <mgaines12> i cant understand this shit
21:20:21 <ksf> mgaines12, ever did long division in school?
21:20:36 <copumpkin> mgaines12: you have joined a channel for avid fans of a TV show, and are asking about programming
21:20:51 <purplepenguins> which tv show are we avid fans of again?
21:20:53 <copumpkin> mgaines12: chances are we aren't too eager or able to help you :)
21:21:00 <mmorrow> lassie?
21:21:04 <copumpkin> yay lassie
21:21:06 <purplepenguins> i hate lassie
21:21:09 <mmorrow> heh
21:21:16 <mgaines12> i hate penguins
21:21:24 <mgaines12> and pumpkins
21:21:31 <purplepenguins> so much hate
21:21:31 <mmorrow> oh noes
21:21:38 <purplepenguins> you must be a c++ programmer
21:21:45 <mgaines12> far from it
21:21:46 <copumpkin> lol
21:21:57 <ksf> but it's already affecting your brain.
21:22:03 <mgaines12> thats the weed
21:22:15 <Veinor> The worst I ever saw was someone coming into #nethack asking for help with nmap or some shit.
21:22:58 <copumpkin> mgaines12: anyway, if you feel like bitching about c++, we'll happily help you with that, but I doubt you'll get much productive help in here :)
21:23:00 <kmc> ahahaha
21:23:09 <kmc> i know some stuff about c++
21:23:11 * kmc is shamed to admit
21:23:14 <Veinor> I think he was black-hat too.
21:23:37 <mgaines12> can you at least tell me how to calculate the variables. i mean like how show it
21:23:48 <mmorrow> mgaines12: ask in #c
21:23:57 <ksf> c++ is a brainfuck dialect limited to angle brackets.
21:24:04 <purplepenguins> lol
21:24:13 <copumpkin> mgaines12: we'll also happily help you solve the problem in the language this channel is dedicated to
21:24:38 <copumpkin> or at least try!
21:25:22 <mgaines12> pumpkin....please stop talking. everything you say about whatever fucking show this room is about i really dont give a shit about
21:25:36 <SamB_XP_> show?
21:25:40 <mmorrow> mgaines12: we've told you the solution. ask in #c.
21:25:46 <SamB_XP_> this room is about a programming language!
21:25:47 <Veinor> ksf: Haha
21:25:48 <copumpkin> SamB_XP_: I told him we liked a tv show :)
21:25:53 <SamB_XP_> mmorrow: that's a solution?
21:26:01 <mmorrow> SamB_XP_: for mgaines, yes
21:26:02 <Makoryu> C++ is made out of spare parts. Sure, it worked great when all you were building was a human-sized replica of Mechagodzilla, but now you're trying to make a bridge and all of the duct tape and melted shoe soles has turned out to be a *bit* too wobbly. Meanwhile, we're over here with our Haskell helicopter, saying "I dunno what you were *trying* to make, but it's definitely not a bridge"
21:26:03 <copumpkin> mgaines12: yeah, pumpkin is an asshole isn't he
21:26:05 --- mode: ChanServ set -v mgaines12
21:26:05 <SamB_XP_> I thought that was more a problem -P
21:26:23 <purplepenguins> hmm
21:26:31 <purplepenguins> chanserv doesn't like expletives?
21:26:44 <mgaines12> a solution for pumpkins mental problem involves a gun and a bullet, possibly razor blades
21:26:46 <Veinor> I don't think -v makes a difference if they never had v to begin with.
21:26:51 <Veinor> Just saying.
21:26:58 <Veinor> Wait, does freenode use unreal?
21:27:09 <purplepenguins> this channel doesn't require voice does it?
21:27:10 <ray> headdesk
21:27:16 <Makoryu> mgaines12: You are in the wrong channel
21:27:17 <Veinor> Nah, it's not +m
21:27:22 <Cale> mgaines12: Could you be polite here, or do you need to be shown the way out?
21:27:22 <Makoryu> mgaines12: /join ##c++
21:27:29 <copumpkin> mgaines12: the basic point is that you're asking the wrong people, so I've tried suggesting you go elsewhere. You ignored that, so I got a little humorous. Stop being unpleasant please now :)
21:27:34 <Veinor> If it did nobody could talk. Unless there are secret IRCops in here.
21:27:46 <purplepenguins> i still read IRCops as IRC cops
21:27:55 <ksf> purplepenguins, that's the intent.
21:27:56 <Veinor> So do I.
21:27:57 <purplepenguins> but it's about the same difference
21:28:12 <mjs22> what an odd quit message for a character like that...
21:28:16 <Veinor> Indeed.
21:28:19 <purplepenguins> hah
21:28:21 * copumpkin shrugs
21:28:30 <purplepenguins> some people have really strange part messages
21:28:32 <Makoryu> I wonder if he was using a Jesus-powered IRC client
21:28:41 <Veinor> I don't even know what my /quit message is. I never /quit.
21:28:43 <Makoryu> I think there's a Chick tract talking about them
21:28:45 <copumpkin> omg orbitz is from ##c++
21:28:51 <Cale> It was powered by burning Jesuses.
21:29:02 <copumpkin> Jesi?
21:29:11 <purplepenguins> for example, people asking very basic high chool math questions, saying he was in high school, having a joke about VAX administration in his part message
21:29:20 <ksf> Jesuxen.
21:29:39 <SamB_XP_> copumpkin: noo!
21:29:47 <SamB_XP_> orbitz, she be from ##c!
21:30:16 <SamB_XP_> purplepenguins: maybe he had a very obsolete highschool ?
21:30:26 <SamB_XP_> or maybe he just had it set to fortune(1)
21:30:34 <purplepenguins> that is probable
21:30:38 <mmorrow> @fortune
21:30:39 <lambdabot> marriage, n.:
21:30:39 <lambdabot> 	An old, established institution, entered into by two people deeply
21:30:39 <lambdabot> 	in love and desiring to make a committment to each other expressing
21:30:39 <lambdabot> 	that love.  In short, committment to an institution.
21:30:44 <ksf> he could have been visiting an americat highschool.
21:30:53 <ray> or maybe he's one of those punk kids who thinks he's a vax administrator
21:31:05 <purplepenguins> american highschools don't use VAX anymore
21:31:13 <mmorrow> heh
21:31:15 <purplepenguins> and haven't for a long time
21:31:31 <SamB_XP_> purplepenguins: I was assuming that was why he was asking a basic math question ;-)
21:31:42 <copumpkin> that @wn definition could be controversial!
21:31:49 <copumpkin> what's VAX?
21:31:53 <ksf> if you ask nietsche, marriage is a mutual lease contract of sexual organs.
21:32:10 <ray> if you ask nietzche, THEN YOU'RE ALREADY WRONG
21:32:15 <copumpkin> Nietzche is dead
21:32:19 <copumpkin> -God
21:32:25 <SamB_XP_> @all-dict vax
21:32:28 <purplepenguins> VAX was a computer that DEC used to make in the 80's, i don't know much about it
21:32:28 <lambdabot> *** "vax" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:32:28 <lambdabot> VAX
21:32:28 <lambdabot>      Virtual Address eXtension (DEC, VAX)
21:32:28 <lambdabot>  
21:32:28 <lambdabot> *** "VAX" jargon "Jargon File (4.3.1, 29 Jun 2001)"
21:32:30 <lambdabot> [63 @more lines]
21:32:40 <SamB_XP_> @more
21:32:40 <lambdabot> VAX /vaks/ n. 1. [from Virtual Address eXtension] The most successful
21:32:40 <lambdabot>    minicomputer design in industry history, possibly excepting its
21:32:40 <lambdabot>    immediate ancestor, the PDP-11. Between its release in 1978 and its
21:32:40 <lambdabot>    eclipse by {killer micro}s after about 1986, the VAX was probably the
21:32:40 <lambdabot>    hacker's favorite machine of them all, esp. after the 1982 release of
21:32:42 <lambdabot> [58 @more lines]
21:32:44 <SamB_XP_> @more
21:32:44 <lambdabot>    4.2 BSD Unix (see {BSD}). Esp. noted for its large,
21:32:46 <lambdabot>    assembler-programmer-friendly instruction set -- an asset that became a
21:32:48 <lambdabot>    liability after the RISC revolution. 2. A major brand of vacuum cleaner
21:32:50 <lambdabot>    in Britain. Cited here because its sales pitch, "Nothing sucks like a
21:32:52 <lambdabot>    VAX!" became a sort of battle-cry of RISC partisans. It is even
21:32:54 <groberts> Can someone help me debug this really simple script that I'm messing something up with? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3551#a3551
21:32:54 <lambdabot> [53 @more lines]
21:33:09 <copumpkin> groberts: I like your eff function
21:33:25 <copumpkin> groberts: however you claim it returns a list of float
21:33:30 <copumpkin> and you say eff [] = 0.0
21:33:36 <SamB_XP_> @devil marraige
21:33:36 <lambdabot> No match for "marraige".
21:33:49 <groberts> copumpkin, thanks, that was dumb
21:33:49 <SamB_XP_> @devil marriage
21:33:50 <lambdabot> *** "MARRIAGE" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
21:33:50 <lambdabot> MARRIAGE, n.  The state or condition of a community consisting of a
21:33:50 <lambdabot> master, a mistress and two slaves, making in all, two.
21:33:50 <lambdabot>  
21:34:04 <copumpkin> groberts: so you know how to fix it?
21:34:12 <SamB_XP_> @devil slavery
21:34:12 <lambdabot> No match for "slavery".
21:34:14 <SamB_XP_> @devil slave
21:34:15 <lambdabot> No match for "slave".
21:34:17 <SamB_XP_> @devil master
21:34:18 <lambdabot> No match for "master".
21:34:20 <SamB_XP_> @devil lord
21:34:21 <lambdabot> *** "LORD" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
21:34:21 <lambdabot> LORD, n.  In American society, an English tourist above the state of a
21:34:21 <lambdabot> costermonger, as, lord 'Aberdasher, Lord Hartisan and so forth.  The
21:34:21 <lambdabot> traveling Briton of lesser degree is addressed as "Sir," as, Sir 'Arry
21:34:21 <lambdabot> Donkiboi, or 'Amstead 'Eath.  The word "Lord" is sometimes used, also,
21:34:23 <lambdabot> [45 @more lines]
21:34:28 <SamB_XP_> @more
21:34:28 <lambdabot> as a title of the Supreme Being; but this is thought to be rather
21:34:28 <lambdabot> flattery than true reverence.
21:34:29 <lambdabot>  
21:34:31 <lambdabot>     Miss Sallie Ann Splurge, of her own accord,
21:34:33 <lambdabot>     Wedded a wandering English lord --
21:34:35 <lambdabot> [40 @more lines]
21:34:36 <SamB_XP_> @more
21:34:37 <lambdabot>     Wedded and took him to dwell with her "paw,"
21:34:39 <lambdabot>     A parent who throve by the practice of Draw.
21:34:39 <groberts> copumpkin, I made it eff [] = []
21:34:41 <lambdabot>     Lord Cadde I don't hesitate to declare
21:34:43 <lambdabot>     Unworthy the father-in-legal care
21:34:45 <lambdabot>     Of that elderly sport, notwithstanding the truth
21:34:47 <lambdabot> [35 @more lines]
21:34:53 <SamB_XP_> @more
21:34:53 <lambdabot>     That Cadde had renounced all the follies of youth;
21:34:54 <lambdabot>     For, sad to relate, he'd arrived at the stage
21:34:54 <lambdabot>     Of existence that's marked by the vices of age.
21:34:55 <copumpkin> groberts: cool :)
21:34:55 <lambdabot>     Among them, cupidity caused him to urge
21:34:57 <lambdabot>     Repeated demands on the pocket of Splurge,
21:34:59 <lambdabot> [30 @more lines]
21:35:09 <ray> :t let f [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] = [] in f
21:35:13 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 a. [t] -> [t1] -> [t2] -> [t3] -> [t4] -> [t5] -> [t6] -> [t7] -> [t8] -> [t9] -> [t10] -> [t11] -> [t12] -
21:35:13 <lambdabot> > [t13] -> [t14] -> [t15] -> [t16] -> [t17] -> [t18] -> [t19] -> [t20] -> [t21] -> [t22] -> [t23] -> [a]
21:35:16 <copumpkin> lol
21:35:19 <ksf> groberts, you still have an incomplete pattern, though.
21:35:56 <ksf> ...you should erase that [] case and use eff _ = [], instead, as a bottom case.
21:36:12 <groberts> ksf, that makes sense
21:37:05 <copumpkin> lol that mgaines12 guy is bugging me in PM now
21:37:10 <groberts> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3551#a3552 <- I still have the problem listed in the revision
21:37:36 <ksf> groberts, fromIntegral is what you're looking for.
21:38:07 <ksf> otoh, you could just leave out all annotations, it should default to Double for everything, then.
21:38:26 <ksf> :t fromIntegral
21:38:27 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:39:01 <ksf> > (fromIntegral 2^3)::Double
21:39:06 <lambdabot>   8.0
21:39:22 <ksf> :t 2^3
21:39:24 <lambdabot> forall t. (Num t) => t
21:39:28 <ksf> ouch.
21:39:39 <ksf> I thought (^) is integral-only?
21:39:53 <Veinor> copumpkin: /ignore mgaines12!*@* ?
21:39:56 <Veinor> also tell us what he's saying :D
21:39:57 <groberts> ksf, so I want to put all the arguments through fromIntegral?
21:40:10 <ksf> I don't know that.
21:40:15 <monochrom> @quote fromIntegral
21:40:15 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
21:40:20 <mmorrow> copumpkin: tell him that possibly #fortran may be of help, or #cobol
21:40:24 <ksf> you might want calc to take Floats (or doubles)
21:40:26 <copumpkin> :)
21:40:31 <Veinor> ksf: Args have to be integral-inly, but you can obviously cast the result to Double
21:40:39 <Veinor> ooh, tell him #cobol on irc.synirc.net can help
21:40:52 <copumpkin> ooh cobol ftw
21:40:54 <ksf> huh?
21:40:59 <ksf> why do args have to be integrals?
21:41:19 <groberts> ksf, what I a using fromIntegral on?
21:41:25 <Veinor> Because it returns an integer. It's shorthand for iterated multiplication, basically.
21:41:29 <ksf> :t (x y z -> (y/x) - ((z/x) + (15/x)))
21:41:31 <Veinor> For floating exponent, you want **
21:41:31 <lambdabot>     Pattern syntax in expression context:
21:41:31 <lambdabot>         x y z -> (y / x) - ((z / x) + (15 / x))
21:41:41 <ksf> :t (\x y z -> (y/x) - ((z/x) + (15/x)))
21:41:43 <lambdabot> forall a. (Fractional a) => a -> a -> a -> a
21:41:47 <ksf> groberts, x,y, and z.
21:41:51 <Veinor> :t (^)
21:41:53 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
21:41:56 <groberts> ksf, thats what I was asking
21:41:57 <Veinor> :t (**)
21:41:59 <lambdabot> forall a. (Floating a) => a -> a -> a
21:42:08 <Veinor> Er, I guess a can be a general num.
21:42:08 <monochrom> fromIntegral y / fromIntegral x - ((fromIntegral z / fromIntegral x) + (15 / fromIntegral x))
21:42:20 <mmorrow> see! concise and elegant!
21:42:25 <Veinor> :D
21:42:42 <copumpkin> hah, he sent a chatterbot to pm me
21:42:46 <copumpkin> rather amusing way of trolling :)
21:43:17 <ksf> copumpkin, are you sure that he's not just failing the turing test, all by himself?
21:43:17 <Veinor> chatterbot? Like, a markov chain chatter bot?
21:43:21 <Veinor> Haha
21:44:41 <ksf> @vixen what do you do to trolls?
21:44:41 <lambdabot> A man is not finished when he is defeated. He is finished when he quits.
21:44:51 <ksf> right on.
21:45:15 <groberts> so my code now looks like http://moonpatio.com/fastcgi/hpaste.fcgi/new?id=3551 , and I'm not understanding that compiler error at all
21:45:38 <ksf> er, you don't have a main function.
21:45:41 <ksf> that's what it says.
21:45:50 <groberts> k
21:45:55 <ksf> oh. overlapped patterns.
21:46:06 <ksf> the _ is a catch-all, it has to go under the other one.
21:46:15 <ksf> ...patterns are tried in order.
21:46:28 <groberts> ksf, ya, again noob mistake
21:46:35 <monochrom> Heh
21:47:37 <ksf> :t [4,35,10,48,88,25,75,115,35,24,63,15,48]
21:47:39 <lambdabot> forall t. (Num t) => [t]
21:51:25 <Veinor> @pl \x -> sin x + cos x
21:51:25 <lambdabot> liftM2 (+) sin cos
21:51:33 <Veinor> Now can anybody do that without monads? :<
21:52:21 <groberts> ksf, thanks for your help, it worked
21:53:18 <Cale> Veinor: You could get away with applicative stuff...
21:53:41 <Cale> :t (+) <$> sin <*> cos
21:53:42 <lambdabot> forall a. (Floating a) => a -> a
21:54:06 <Veinor> Hm.
21:54:11 <copumpkin> or just liftA2 instead of liftM2
21:54:17 <Cale> Indeed.
21:54:31 <Cale> But... this is the sort of thing which lambda is for.
21:54:56 <Veinor> Right.
21:55:00 <CalJohn_> Hm, trying to use parsec to parse http requests, which are of the format "<String>: <Value><Newline>"*.  I'm trying to think of a good way to do this, any suggestions?
21:55:03 <Veinor> Wait. Are you ezlang. :|
21:55:32 <Veinor> or possibly allberry.
21:55:37 <SamB_XP_> Veinor: who are those ?
21:55:50 <SamB_XP_> I'm pretty sure this is CalJohn ...
21:55:53 <Veinor> People. Anyway, what are <$> and <*>
21:56:18 <CalJohn_> SamB_XP_: tab completion is your enemy
21:56:25 <copumpkin> Veinor: ezyang? that's someone's nick. allbery_b is also someone's nick :)
21:56:49 <SamB_XP_> CalJohn_: why do you say that ?
21:56:53 <Veinor> Oh, cool.
21:56:57 <SamB_XP_> I specifically inteneded to type that name!
21:57:17 <CalJohn_> didn't you mean to highlight Cal-e?
21:57:26 <CalJohn_> nevermind, i have no idea what is going on in this channel now
21:57:39 <CalJohn_> and it's not because it's too theoretical, for once
21:57:44 <allbery_b> heh
21:57:44 <ksf> CalJohn_, happstack? any other web framework?
21:57:47 <Veinor> So now I just need to know what <$> and <*> do :D
21:57:54 <allbery_b> (this discussion started out on MIT zephyr)
21:57:55 <SamB_XP_> well, I'm not sure what Veinor was asking about
21:58:08 <CalJohn_> ksf: it's really not very web, just this once parser
21:58:12 <allbery_b> <-- is allbery@ANDREW
21:58:25 <Veinor> Oh hey. :D
21:58:29 <SamB_XP_> allbery_b: what the heck is zephyr?
21:58:33 <Veinor> phurst here.
21:58:42 <SamB_XP_> or MIT ?
21:59:10 <allbery_b> semi-obsolete messaging system which has the dubious advantage of using Kerberos for authentication. jabber is modeled on it
21:59:33 <CalJohn_> MIT is this place where they used to do scheme...
21:59:40 <ksf> many ((many1 $ noneOf ":") >> char ':' >> (many noneOf "\cr") >> string "\r\n")
21:59:40 <allbery_b> many universities use zephyr and are cross-linked with each other
21:59:50 <ksf> ...you just have to get the values outta that.
22:00:05 <ksf> (and check with the rfc wrt. allowed characters)
22:00:08 <SamB_XP_> CalJohn_: was kidding about the MIT bit ;-P
22:00:15 <Cale> CalJohn_: Used to?
22:00:16 <CalJohn_> SamB_XP_: so was I :p
22:00:18 <ksf> s/cr/\r/
22:00:21 <CalJohn_> Cale: they stopped
22:00:25 <Cale> Did not.
22:00:39 <CalJohn_> well, i mean, they took SICP off the curriculum
22:00:44 <Cale> CalJohn_: It's just not the first course anymore.
22:00:46 <SamB_XP_> they what ?
22:00:55 <CalJohn_> oh, what course is it now?
22:01:03 <ksf> oh, and nesting many's can give you awesome endless loops.
22:01:07 <lispy|web> Cale: I'm making progress on a working able server with GHC but now haddock is being a memory pig :(
22:01:13 <ksf> ...using many1 is usuall the solution.
22:01:51 <Cale> It's the same course that it was, just moved, as I understand it.
22:03:37 <ksf> they observed that american high-school education has declined even further, and had to introduce a rehabilitation course.
22:03:57 <Veinor> Haha
22:04:23 <SamB_XP_> ksf: is that really the case, or are you guessing and/or haha-only-serious ?
22:05:00 * ksf guesses it's all of what you say
22:05:50 <Veinor> I think he's being haha-only-serious a little bit.
22:06:14 <ksf> or they're getting into money trouble.
22:06:52 <ksf> in wedel the first semester is traditionally used to filter people out. rigirously.
22:07:28 <ksf> ...they could do that later, charging money in the meantime.
22:14:24 <dazza_> How do i get takeWhile to stop once it has taken a particular value.
22:14:39 <copumpkin> it already does?
22:14:48 <copumpkin> > takeWhile (<10) [1,3..]
22:14:52 <lambdabot>   [1,3,5,7,9]
22:15:27 <Veinor> > takeWhile (/= 10) [1..]
22:15:31 <lambdabot>   [1,2,3,4,5,6,7,8,9]
22:15:34 <Veinor> Like that?
22:16:40 <dolio> If I'm reading his question right, he wants 10 to be in that list.
22:16:42 <dazza_> no because i want to>> let list = [5,3,7,12,15,9,12,7] takeWhile (<= 15) list but I want it to stop after it takes the 15
22:17:11 <dolio> You need additional state to do that, so takeWhile won't work.
22:17:12 <Veinor> So you want it to exclude elements that are not <=15 and stop as soon as it hits a 15?
22:17:25 <Veinor> so f [1,3,19,3,15,2,6] would return [1,3,3,15] ?
22:17:39 <dazza_> yes.
22:17:45 <allbery_b> > takeWhile (<=15) [5,3,7,12,15,9,12,7]
22:17:49 <lambdabot>   [5,3,7,12,15,9,12,7]
22:17:56 <allbery_b> hm, right.
22:17:56 <dazza_> infact i want it to take 15 as many time as 15 appears.. then stop.
22:18:31 <badsheepy> isnt that filter
22:18:42 <dolio> Well, there's no way for it to know when there are no more 15s in the list without looking ahead.
22:18:42 <mle> so take some stream of numbers, filter anything >15, and then accept one or more fifteens, then stop?
22:18:44 <dmwit> :t State
22:18:46 <lambdabot> forall s a. (s -> (a, s)) -> State s a
22:18:51 <dmwit> :t break
22:18:52 <allbery_b> > takeWhile (/= 15) $ reverse [5,3,7,12,15,9,12,7]
22:18:53 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:18:56 <lambdabot>   [7,12,9]
22:19:01 <dmwit> :t runState
22:19:03 <lambdabot> forall s a. State s a -> s -> (a, s)
22:19:12 <allbery_b> ok, I'm not thinking clearly tonight
22:19:21 <mle> Get any more complicated and I'd say whip out parsec...
22:19:45 <dmwit> > runState (liftM2 (,) (State (break (==15))) (State (break (/=15)))) [5,3,7,12,15,9,12,7]
22:19:46 <dazza_> > takeWhile (<=15) [5,3,7,12,15,15,9,12,7] I want to take both 15's even
22:19:48 <lambdabot>   <no location info>:
22:19:48 <lambdabot>      lexical error in string/character literal at chara...
22:19:50 <lambdabot>   (([5,3,7,12],[15]),[9,12,7])
22:20:03 <dmwit> I'm winning...
22:20:19 <allbery_b> actually...
22:20:34 <dazza_> yeh, so filter function?
22:20:41 <dazza_> higher order..
22:20:43 <dmwit> > evalState (do { x <- State (break (==15)); y <- State (break (/=15)); return (x ++ y) }) [5,3,7,12,15,15,9,12,7]
22:20:47 <lambdabot>   [5,3,7,12,15,15]
22:20:55 <allbery_b> > concat $ inits $ groupBy (== 15) [5,3,7,12,15,9,12,7]
22:20:59 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
22:21:09 <allbery_b> doh
22:21:26 <dmwit> Whoever suggested State, you're a twisted genius.
22:22:04 <dazza_> what module is that in?
22:22:10 <dmwit> Control.Monad.State
22:22:21 <dmwit> And if you *actually* write the function that way, I will personally hunt you down.
22:22:35 <dazza_> no I wont be using state
22:22:58 <dazza_> there must be another way...................
22:23:05 <dazza_> more code..
22:23:11 <dmwit> Sure, the usual way is just with pattern matching.
22:24:20 <dmwit> > let last15 xs = as ++ cs where {(as, bs) = break (==15) xs; (cs, ds) = span (==15) bs} in last15 [5,3,7,12,15,15,9,12,7]
22:24:24 <lambdabot>   [5,3,7,12,15,15]
22:25:27 <dmwit> > let takeUntilIncluding p xs = as ++ cs where {(as, bs) = break p xs; (cs, ds) = span p bs} in takeUntilIncluding (==15) [5,3,7,12,15,15,9,12,7]
22:25:30 <lambdabot>   [5,3,7,12,15,15]
22:25:40 <dmwit> It's a bit of a weird function, though.  What are you doing with it?
22:26:14 <Veinor> @pl \xs = as ++ cs where {(as, bs) = break (==15) xs; (cs, ds) = span (==15) bs}
22:26:14 <lambdabot> (line 1, column 5):
22:26:14 <lambdabot> unexpected "="
22:26:14 <lambdabot> expecting operator, pattern or "->"
22:26:19 <Veinor> Whoops.
22:26:28 <dmwit> I don't think ?pl does where clauses.
22:26:41 <dmwit> Even if you had gotten the right syntax for lambdas there. ;-)
22:27:32 <allbery_b> > concat $ init $ groupBy (\a b -> a /= 15 && b /= 15) [5,3,7,12,15, 6, 12, 15, 9,12,7]
22:27:36 <lambdabot>   [5,3,7,12,15,6,12,15]
22:27:49 <allbery_b> was close...
22:27:57 <dazza_> I am making a list into sequencial numbers. e.g. [5,3,7,12,15,15,9,12,7] = [[5],[3,7,12,15,15],[9,12],[7]]
22:28:12 <dmwit> allbery_b: I think instead of concat . init you just want head.
22:28:28 <dmwit> allbery_b: But even then it won't keep multiple copies of 15.
22:28:47 <allbery_b> mm, no. head gets me the first sublist, I want all but the last sublist, concatenated
22:29:07 <allbery_b> (one sublist for each run ending in a 15, followed by a sublist which is the rest of the original)
22:29:19 <dazza_> i got a paste bucket.
22:29:41 <dazza_> 15 is not a magic number
22:29:42 <dmwit> > groupBy ((&&) `on` (/=15)) [5,3,7,12,15,15,15,12,6,15]
22:29:46 <lambdabot>   [[5,3,7,12],[15],[15],[15],[12,6],[15]]
22:29:58 <allbery_b> > groupBy (<) [5,3,7,12,15, 6, 12, 15, 9,12,7]
22:30:02 <lambdabot>   [[5],[3,7,12,15,6,12,15,9,12,7]]
22:30:04 <dmwit> allbery_b: I think your method is just flawed. =P
22:30:11 <eoeas> Hi, under which grouping in: http://www.haskell.org/ghc/docs/6.8.2/html/libraries/index.html would I find references for flow controls i.e "if", "else", etc. I tried "ghci> :type if" and "ghci> (if)", which both returned a parse error.
22:30:11 <allbery_b> hm, that was wrong
22:30:27 <allbery_b> eoeas: they're builtins
22:30:29 <dmwit> eoeas: if/then/else is syntax, not a function.
22:30:32 <allbery_b> check the online report
22:30:47 <eoeas> I see
22:30:55 <dmwit> (unfortunately)
22:31:26 <allbery_b> dmwit: what's wrong with my example?
22:31:32 <eoeas> So where can I get info on Built-ins?
22:31:46 <dmwit> ?where report
22:31:46 <lambdabot> http://www.haskell.org/onlinereport/
22:31:48 <dmwit> eoeas: there
22:32:04 <dmwit> eoeas: There's really not much info to give, though.
22:32:09 <allbery_b> >  groupBy (\a b -> a /= 15 && b /= 15) [5,3,7,12,15, 6, 12, 15, 9,12,7]
22:32:09 <dmwit> eoeas: What are you wondering about?
22:32:12 <lambdabot>   [[5,3,7,12],[15],[6,12],[15],[9,12,7]]
22:32:29 <dm`> @src groupBy
22:32:29 <lambdabot> groupBy _  []       =  []
22:32:29 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
22:32:29 <lambdabot>     where (ys,zs) = span (eq x) xs
22:32:48 <dm`> See, it just curries one x into eq
22:32:54 <eoeas> dmwit: Just experimenting whilst reading a tutorial
22:33:50 <dmwit> allbery_b: (\a b -> ...) === ((&&) `on` (/=15)) -- ;-)
22:34:02 <eoeas> dmwit: What is the equivalent of "else if" in Haskell ??
22:34:05 <dazza_> shove a +1 in there on the next greatist no.
22:34:16 <allbery_b> that's no "just flawed", that's a styleistic issue
22:34:59 <dmwit> eoeas: "else if"
22:35:36 <eoeas> dmwit: :-( Doh!
22:35:40 <dmwit> allbery_b: No, no, changing to point-free wasn't the flaw I meant.
22:35:44 <eoeas> dmwit: Thnx
22:35:55 <dmwit> allbery_b: I just meant that groupBy isn't going to be a reasonable way to attack this problem.
22:35:57 <Veinor> I hate how != is /= in Haskell. :(
22:36:15 <dmwit> I hate how people get stuck on such arbitrary syntax differences as != vs /=.
22:36:33 <Veinor> I can get used to it, it just annoys me how it's different from every other programming language.
22:36:44 <dmwit> yeah
22:36:54 <dmwit> But then... why should it be != in every other language?
22:36:59 <allbery_b> not every other. doesn't ada do the same tyhing?
22:37:00 <Veinor> 'not equals'
22:37:11 <dmwit> ! is not 'not' in my world
22:37:14 <dmwit> ~, maybe
22:37:34 <Veinor> so ! != 'not'? :D
22:37:59 <dolio> There's also <>
22:38:05 <dmwit> let (=) = (/=) in ...
22:38:11 <Veinor> dmwit: Haha.
22:38:38 <Veinor> Although if you're going that route you might as wellgo let () = (/=) in
22:38:44 <dmwit> yeah
22:38:45 <dmwit> much better
22:40:08 <dazza_> this is wot that does ..
22:40:15 <dazza_> >let list = [5,3,7,12,13,15,9,12,7] in groupBy (\a b -> a /= (next list) && b /= (next list)) list where next [] = 0; next [x] = x; next (x:xs) = if x < head xs then next xs else x
22:40:27 <Veinor> Well that's readable.
22:40:47 <allbery_b> Veinor: in Haskell, ! means "strict" or "access" (the latter, think Forth)
22:41:02 <Veinor> Yeah, yeah.
22:41:27 <hackagebot> progress 1.0 - Simple progress tracking & projection library (MariusEriksen)
22:42:13 <dmwit> dazza_: That doesn't look like it type-checks to my naive eyes.
22:42:38 <dmwit> > let list = [5,3,7,12,13,15,9,12,7] in groupBy (\a b -> a /= (next list) && b /= (next list)) list where next [] = 0; next [x] = x; next (x:xs) = if x < head xs then next xs else x
22:42:41 <lambdabot>   <no location info>: parse error on input `where'
22:42:54 <dmwit> Oh, I see why that typechecks.
22:43:03 <dmwit> uh
22:43:09 <dmwit> That is a very, very strange function.
22:43:35 <dazza_> it doesnt even do what i want it to do
22:43:42 <adu> what function?
22:43:57 <dmwit> > let list = [5,3,7,12,13,15,9,12,7]; next [] = 0; next [x] = x; next (x:y:zs) = if x < y then next (y:zs) else x in next list
22:44:01 <lambdabot>   5
22:44:03 <adu> dazza_: i guess it doesn't "function" that way ... lol
22:44:10 <dmwit> dazza_: No, I shouldn't expect it does.  It would be weird indeed to want what that function does. =)
22:44:21 <dazza_> yes the function WORKS but it doesnt WORK the way I Intended.
22:44:35 <copumpkin> dazza_: so you want to take all values up until the _last_ occurrence of the one you're looking for?
22:45:17 <dmwit> > reverse . dropWhile (/=15) . reverse $ [1,12,15,12,12,15,12]
22:45:20 <lambdabot>   [1,12,15,12,12,15]
22:45:25 <copumpkin> hah, I was just about to suggest that :)
22:45:26 <dazza_> yes but the one i am looking for resolved to next [] = 0; next [x] = x; next (x:y:zs) = if x < y then next (y:zs) else x
22:45:50 <dazza_> then next is called on the rest of that list. SO i go and dropWhile on the rest
22:45:56 <dazza_> with the same call
22:46:16 <dmwit> > let next = fst . head . dropWhile (uncurry (<)) . ap zip tail in next [5,3,7,12,13,15,9,12,7]
22:46:17 <dazza_> then use recursion
22:46:20 <lambdabot>   5
22:46:45 <dmwit> > let next = head . (++[0]) . map fst . dropWhile (uncurry (<)) . ap zip tail in next [5,3,7,12,13,15,9,12,7]
22:46:49 <lambdabot>   5
22:47:07 <dmwit> > let next = head . (++[0]) . map fst . dropWhile (uncurry (<)) . ap zip tail in next [5,6,7,12,13,15,9,12,7]
22:47:10 <lambdabot>   15
22:47:43 <dmwit> Never write a readable pattern-match when an unreadable point-free chain will do.
22:50:51 <dazza_> i writing pattern match because i can read it nicely, just copy/pasted it into here ..
22:51:13 <eoeas> dmwit: In the examples you gave above, what does the " . " stand for ??
22:51:27 <copumpkin> function composition
22:51:28 <dmwit> eoeas: It's function composition.
22:51:30 <dmwit> ?src (.)
22:51:30 <lambdabot> (f . g) x = f (g x)
22:51:51 <dmwit> dazza_: Yes, my "improvement" was mostly tongue-in-cheek.
22:51:59 <eoeas> I see
22:52:23 <dmwit> > ap f g x :: Expr
22:52:26 <lambdabot>   Add a type signature
22:52:41 <dmwit> > ap (f :: Expr -> Expr -> Expr) g x
22:52:45 <lambdabot>   f x (g x)
22:53:10 <dmwit> It would be cool if lambdabot gave just a *bit* more of GHC's beautiful error messages.
22:53:36 <copumpkin> > join (f :: Expr -> Expr -> Expr) x
22:53:39 <lispy|web> dmwit: it does in private chat
22:53:41 <lambdabot>   f x x
22:53:43 <copumpkin> neat!
22:53:47 <lispy|web> dmwit: it gives the full thing, IIRC
22:54:12 <dmwit> lispy|web: Hmm, it doesn't seem to here.
22:54:18 <lispy|web> ah
22:54:25 <lispy|web> maybe it depends on the error then
22:54:33 <copumpkin> > loop (f :: (Expr, Expr) -> (Expr, Expr))
22:54:34 <dmwit> ok
22:54:37 <lambdabot>   No instance for (SimpleReflect.FromExpr
22:54:37 <lambdabot>                     (SimpleReflect....
22:54:40 <copumpkin> damn :)
22:54:51 <copumpkin> not sure what I'd expect it to show there, anyway
22:54:56 <dmwit> > loop (f *** g :: (Expr, Expr) -> (Expr, Expr))
22:54:59 <lambdabot>   Overlapping instances for GHC.Show.Show
22:54:59 <lambdabot>                              (Simpl...
22:55:02 <dmwit> aw
22:55:06 <dmwit> :t loop
22:55:08 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
22:55:16 <copumpkin> > loop (f *** g :: (Expr, Expr) -> (Expr, Expr)) (x, y)
22:55:20 <lambdabot>   Couldn't match expected type `(SimpleReflect.Expr,
22:55:22 <dmwit> no no
22:55:25 <dmwit> > loop (f *** g :: (Expr, Expr) -> (Expr, Expr)) x
22:55:29 <lambdabot>   f x
22:55:32 <copumpkin> aha!
22:55:33 <copumpkin> nice :)
22:55:45 <copumpkin> unfortunately that doesn't reveal loops loopiness
22:55:47 <copumpkin> loop's
22:55:54 <dmwit> yeah =(
22:56:09 <dmwit> semantics!  yay
22:56:12 <copumpkin> New paper: "A simplereflect that reveals loop's loopiness!"
22:59:03 <copumpkin> metric spaces are a subset of normed spaces, right?
22:59:26 <ivanm> copumpkin: as opposed to imperial spaces? :p
22:59:38 <dmwit> err
22:59:43 <Cale> copumpkin: Other way around.
22:59:49 <dmwit> I think a norm is more restrictive than a metric.
22:59:52 <dmwit> yeah, what Cale said
23:00:12 <copumpkin> ah, I see, yeah
23:00:14 <Cale> normed vector spaces are all metric spaces, but not all metric spaces are normed vector spaces
23:00:36 <Cale> When you have a normed vector space, you can turn it into a metric space by d(x,y) = ||x-y||
23:00:55 <copumpkin> I see
23:01:54 <copumpkin> so the additional property of the norm is scalar multiplication?
23:01:58 <copumpkin> or "preserving" it?
23:03:09 <Cale> yeah
23:04:24 <Cale> and metric spaces which arise from normed vector spaces have a lot of symmetry -- the neighbourhoods of any point are translations of neighbourhoods of 0
23:05:26 <Cale> So it "looks the same" everywhere.
23:06:06 <copumpkin> I see
23:06:54 <lispy|web> Cale: looks like that server is good to go.  I'm able to cabal install darcs (and I install cabal globally)
23:07:12 <Cale> cool
23:07:20 <Cale> I'll get things set up soon :)
23:07:31 <lispy|web> Good.  The server is probably going down tomorrow
23:07:38 <Cale> oh?
23:07:51 <lispy|web> yeah, I think that's when my friend Ben is going to grab it from the data center.
23:08:30 <Cale> Ah, the one which lambdabot is already running on.
23:09:57 <lispy|web> Cale: yeah
23:10:23 <lispy|web> Cale: I'm not sure when I'll be able to get a copy of the data from current server.  sorry about that
23:10:40 <lispy|web> Cale: but very likely Ben will be able to make a backup
23:11:46 <Cale> It would be convenient, as there are various changes I'd made to the local mueval and such.
23:13:21 <CalJohn_> @hoogle all
23:13:22 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
23:13:22 <lambdabot> Data.ByteString all :: (Word8 -> Bool) -> ByteString -> Bool
23:13:22 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
23:13:25 <lispy|web> Yeah, sorry about that.  I wish I knew why we can't connect
23:15:21 <Cale> lispy|web: Hehe, if only I'd imported unsafePerformIO ;)
23:15:38 <lispy|web> Cale: hehe
23:15:43 <mmorrow>  $10 bounty on rooting lambdabot!
23:17:40 <SubStack> is that redeemable in beer equivalence?
23:17:42 <PetRat> I'm trying to use an if statement to choose between two monads and write one with do notation, but I don't think it's syntactically valid. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9246#a9246
23:17:46 <mmorrow> @type $(Language.Haskell.TH.Syntax.runIO (readFile "/etc/password") >>= Language.Haskell.TH.Lib.varE . Language.Haskell.TH.Syntax.mkName)
23:17:48 <lambdabot> parse error on input `$'
23:18:25 <mmorrow> @type Language.Haskell.TH.Syntax.runIO (readFile "/etc/password") >>= Language.Haskell.TH.Lib.varE . Language.Haskell.TH.Syntax.mkName
23:18:27 <lambdabot> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
23:18:42 <mmorrow> @type [|1|]
23:18:44 <lambdabot> parse error on input `|'
23:18:48 <mmorrow> grr
23:19:14 <SubStack> a do can follow a then
23:19:56 <SubStack> > if True then do { return "yep" } else return "nope"
23:20:00 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
23:20:00 <lambdabot>    arising from a use ...
23:20:06 <SubStack> pesky thing
23:21:07 <PetRat> SubStack: thanks. I was getting a parse error but turns out it was incorrecct indentation.
23:26:15 <mmorrow> SubStack: yes, redeemable in beer equivalence
23:26:55 <SubStack> excellent
23:27:54 <mmorrow> unfortunately i can't think of a any way via ">", and @type has TH turned off, so i'm stumped
23:28:23 <mmorrow> s/root/execute arbitrary code as lambdabot's user/
23:29:23 <mmorrow> s/arbitrary code/just run a single shell cmd/
23:29:41 <copumpkin> mmorrow: how about @let or @check?
23:29:55 <copumpkin> not sure if their environments differ
23:31:05 <mmorrow> @check \x -> [|5|] `seq` True
23:31:05 <lambdabot>   Parse error at "|5|]" (column 8)
23:31:11 <mmorrow> @check \x -> [|5|]
23:31:11 <lambdabot>   Parse error at "|5|]" (column 8)
23:31:15 <copumpkin> aw
23:31:19 <mmorrow> :(
23:31:30 <Quadrescence> Um...
23:31:34 <Quadrescence> http://img193.imageshack.us/img193/3338/haskelll.png
23:31:39 <mmorrow> @let asdf = [|5|]
23:31:40 <lambdabot>   Parse error: Bar
23:31:57 <copumpkin> Quadrescence: lol nice
23:32:02 <ivanm> @slam Quadrescence
23:32:03 <lambdabot> I won't; I want to go get some cookies instead.
23:32:06 <mmorrow> haha
23:32:20 <Quadrescence> ivanm: Take that, ivan monad
23:32:42 <Quadrescence> ivanM_ =<< beeHive
23:32:59 <PetRat> I'm wondering if there is a better way to write this: to check cases of values (not of patterns), the function guard notation is very convenient, so I put a local function in the middle of a do-block. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9247#a9247
23:34:46 <PetRat> A related question is-- what techniques are available for running through a list of cases (of values, not patterns) that don't result in stair-stepping (like if-then-else would). I can think of function guard notation. Anything else?
23:35:56 <copumpkin> is Hask a CCC?
23:36:25 <harlekin> @ty get
23:36:25 <Quadrescence> Do each of the `C's mean "Cock? If so, yes.
23:36:27 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
23:36:45 <Quadrescence> s/k/k\"/
23:36:53 <harlekin> @pl get >>= (render::(MonadState s m) => a -> m s)
23:36:54 <lambdabot> (line 1, column 40):
23:36:54 <lambdabot> unexpected ">"
23:36:54 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
23:36:56 <mmorrow> PetRat: PetRat there's this way with case  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9247#a9248
23:36:57 <copumpkin> the requirements seem to be that there's a product ((,) ?), an exponential ((->) ?), and a terminal object (??)
23:37:11 <mmorrow> PetRat: which is handy in certain situations
23:38:18 <mmorrow> PetRat: (and you could also do a useful pattern match in place of the "_" there, as well as have more than on arms in the case, each of which having many different guards)
23:38:23 <PetRat> mmorrow: ah so you can put guards on patterns in case. Is that how you would word it?
23:38:28 <mmorrow> right
23:39:23 <mmorrow> and if a pattern matches, but none of its guards do, you'll move on to the next pattern (so they don't need to be exhaustive/you're not committed at that point yet)
23:39:27 <copumpkin> I guess a terminal object for Hask would be ()?
23:39:50 <mmorrow> @type const ()
23:39:52 <lambdabot> forall b. b -> ()
23:40:37 <PetRat> mmorrow: so can you give several identical patterns without the compiler complaining of overlapping patterns?
23:41:06 <mmorrow> PetRat: well, if they're identical you'd probably just merge them into the same one
23:41:56 <mmorrow> PetRat: i mean like      case x of Just ([x],_) | x==4 -> ..; Just (_,[_,_]) -> ...; Nothing -> ...
23:42:17 <mmorrow> ; _ -> ...
23:43:14 <PetRat> mmorrow: you suggested that if no guards match, it would go onto the next matching pattern. I'm trying to visualize when another pattern would match. Of course a final _ would.
23:43:47 <mmorrow> PetRat: in that last example, suppose `x' is
23:44:00 <mmorrow> Just ([5],[6,7])
23:44:03 <PetRat> mmorrow: In your example something could match all three potentially... I guess it's the use of _ which makes all this possible.
23:44:14 <mmorrow> PetRat: right
23:44:36 <copumpkin> http://en.wikipedia.org/wiki/N-category_number
23:44:58 <PetRat> mmorrow: thanks for the help. I have to go to bed. Best to everyone.
23:45:08 <mmorrow> PetRat: no problem, night
23:49:28 <bastl> hi, is there a haskell-package that has similar functionality as "make" (targets, timestamps, dependencies). hmake and cabal dont fit.
23:50:56 <ivanm> why would you want such a thing?
23:51:03 <ivanm> and how is cabal not good enough?
23:51:27 <mmorrow> ivanm: cabal can't do make-ish stuff
23:51:57 <mmorrow> foo.pdf: foo.tex\n\tpdflatex $< -o $@
23:52:44 <mmorrow> ivanm: s/can't/doesn't/
23:53:01 <ivanm> define "make-ish"
23:53:03 <blackdog> bastl: so what's wrong with mae :)
23:53:05 <blackdog> make
23:53:42 <mmorrow> ivanm: the ability to make arbitrary rules/targets with dependencies, and run arbitrary shell commands to build each one
23:53:44 <blackdog> (i've been using rake to keep my stuff up to date, but that's because all the tests are in ruby anyway)
23:54:19 <ivanm> mmorrow: so he wants a glorified shell script?
23:55:11 <mmorrow> ivanm: make also tracks dependencies and knows whether targets are out of date w.r.t. their deps, as well as building targets that depends on other targets and so on in the correct order
23:55:22 <mmorrow> it can also do it in parallel
23:55:33 <ivanm> ahhh
23:57:23 <blackdog> bastl: why is it important that it be in haskell?
23:58:05 <bastl> blackdog: I write my custom build-thing (a wrapper around cabal)
23:58:31 <bastl> now i want to do make-like things and dont want to fiddle around with timestamps and dependencies myself
23:59:00 <ivanm> there's roundy's replacement for cabal...
23:59:02 <ivanm> not sure what it can do
23:59:07 <blackdog> franchise?
