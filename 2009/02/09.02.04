00:01:29 <dolio> I'd get rid of the class. It doesn't have any functions in it, does it?
00:01:34 <vegai> I wish there was a simple way to define a toplevel value to be evaluated on compile time...
00:01:54 <Taejo> dolio: how do you do type-level arithmetic without classes?
00:02:16 <vegai> like foobar :: Meta Integer; foobar = 1+2  would be equivalent to foobar :: Integer; foobar = 3
00:02:27 <dolio> type family m :+: n :: * ; type instance Zero :+: n = n ; type instance (Succ m) :+: n = Succ (m :+: n)
00:02:34 <vegai> or s/Meta/Macro/ ?
00:02:58 <Taejo> dolio: is "type family" in GHC 6.8?
00:03:00 <vegai> could a Macro be built with Quasi?
00:03:20 <dolio> Taejo: You've got the TypeFamilies flag enabled. :)
00:03:27 <vegai> I suppose foobar = someFunction (1+2) would suffice as well
00:03:37 <dolio> It's the machinery underlying associated types.
00:04:04 <Taejo> dolio: true
00:04:13 <dolio> vegai: GHC can probably do something that simple in its optimizer.
00:04:24 <dolio> For more complicated constants, you'd have to use template haskell.
00:04:44 <Taejo> urgh, vim doesn't highlight "type family"
00:04:48 <dolio> Taejo: They don't work perfectly in 6.8, but I think for this use they're good enough.
00:05:00 <vegai> yes, my actual use would include building big lists, possibly with (++)
00:05:28 <dolio> Yeah. I'm not sure if it folds such constants or not.
00:06:14 <dolio> You have an example of what you'd want to do?
00:06:22 <Taejo> wouldn't it be fairly difficult to tell if they were infinite in some cases? (Rice's theorem bites again)
00:06:23 <dolio> Like [1..50] ++ [100..200]?
00:06:50 <dolio> That probably isn't turned into a literal at compile time.
00:07:16 <vegai> something like this rather
00:07:42 <vegai> (zip ["FOO", "BAR"] (repeat 1)) ++ (zip ["BAZ", "ZAB"] (repeat 2))
00:07:46 <dolio> Of course, turning that into a literal is probably worse than fusing it together into a loop.
00:07:58 <vegai> where 1 and 2 would be functions, actually
00:08:10 <vegai> so, building a sort of dispatch table
00:08:22 <dolio> Yeah, I doubt that gets simplified.
00:08:45 <vegai> s/sort of // :)
00:09:02 <vegai> aye...
00:09:56 <vegai> Quasi is a nice thing, but it could a layer for some simple things like this
00:10:04 <vegai> could use*
00:10:18 <Taejo> dolio: if I use type families instead of classes for Pred as well as :+:, what would the type of safeHead be?
00:11:25 <vegai> and then there's the memoization question again. If I open up the dispatch table above and use Map.fromList on it...
00:11:39 <vegai> ... is that Map built only once or every time I use it?
00:12:14 <dolio> Taejo: You probably can't do that without a class.
00:12:33 <dolio> Since the class would be a predicate on the type specifying that it has a predecessor.
00:13:19 <dolio> It'd be simpler if you didn't have Infinity.
00:14:14 <Taejo> dolio: in other words, Infinity is what makes it interesting :)
00:14:20 <Taejo> why would it be simpler?
00:15:13 <dolio> If there weren't Infinity, it'd be safeHead :: SafeList (Succ n) a -> a
00:15:25 <x6a616e> @src fromList
00:15:25 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:15:41 <x6a616e> @src Data.Map.fromList
00:15:41 <lambdabot> Source not found. You untyped fool!
00:15:48 <Taejo> dolio: oh, right
00:16:29 <Taejo> ok, I've gone back to a NonZero typeclass, so safeHead :: NonZero n => SafeList n x -> x
00:16:44 <dolio> Yeah.
00:17:03 <dolio> That definition of :+: isn't complete, either.
00:17:23 <dolio> I'm not sure if you can put an "n :+: Infinity" case in. That might be overlapping.
00:17:30 <Taejo> yeah, I took it out
00:17:36 <dolio> Assuming you want n :+: Infinity = Infinity.
00:17:47 <dolio> Instead of "Succ (Succ (... Infinity))"
00:17:59 <Taejo> nah, I allow Succ Infinity
00:18:28 <Taejo> the list has length Infinity iff it is an Unfold
00:18:41 <Taejo> and length (Succ n) iff it is a Cons
00:18:49 <dolio> Ah, true.
00:19:14 <dolio> Making it otherwise would require a different constructor.
00:20:19 <jre2> @src threadDelay
00:20:19 <lambdabot> Source not found. Take a stress pill and think things over.
00:21:26 <dsrogers> is there an example based haskell cheat sheet anywhere?
00:21:46 <Taejo> dolio: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1185#a1189
00:22:21 <chrisdone> dsrogers: there is, it was posted to reddit a while ago. try that
00:24:13 <dsrogers> hmm... not exactly easy to find...
00:26:10 <Taejo> dsrogers: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CheatSheet
00:28:00 <dsrogers> thanks
00:28:09 <dolio> Taejo: Zero :+: n = n, not Zero.
00:28:33 <Taejo> d'oh
00:28:35 <Taejo> thanks
00:28:47 <Taejo> sweet, it compiles
00:31:05 <Taejo> dolio: seems to be working, thanks for your help
00:31:12 <dolio> No problem.
00:31:25 <Taejo> now let's see if I can do concat :)
00:34:29 <mathijs> is a series of actions in the IO monad always executed strict? so an action finishes before the next one starts?
00:34:59 <Taejo> mathijs: unless specifically stated otherwise, yes
00:35:35 <Taejo> there is a function called unsafeInterleaveIO which allows you to create lazy IO, and some standard functions (getContents, readFile), use it
00:35:39 <dsrogers> is it possible to partially apply a class method?  If so, what does the type signature look like?
00:35:54 <Deewiant> ?ty (+) 1
00:35:55 <lambdabot> forall t. (Num t) => t -> t
00:36:06 <mathijs> Taejo: ok, I was indeed wondering about getContents
00:38:08 <mathijs> so this unsafeInterleaveIO function somehow decorates a normal string with the taint of IO, but doesn't show it?
00:38:36 <Taejo> :t unsafeInterleaveIO
00:38:37 <lambdabot> Not in scope: `unsafeInterleaveIO'
00:38:43 <Taejo> :t System.Unsafe.unsafeInterleaveIO
00:38:45 <lambdabot> Couldn't find qualified module.
00:38:48 <Taejo> :t System.IO.Unsafe.unsafeInterleaveIO
00:38:49 <lambdabot> forall a. IO a -> IO a
00:39:05 <Taejo> so no... at the type-level, it does nothing
00:39:21 <Taejo> all it changes is when the action gets executed
00:39:48 <mathijs> Taejo: well it hides IO somehow and lets an IO String act as normal string right?
00:40:29 <Taejo> mathijs: hmm... not really... not sure how to explain it
00:40:44 <mathijs> I mean if I need the next character it starts IO'ing in the background.
00:41:52 <mathijs> it just attaches some code to the lazy string that will jump into IO whenever it wants?
00:42:29 <Taejo> mathijs: right. but then it returns it in the IO monad
00:42:45 <mathijs> on the fly whenever it needs to
00:42:54 <Taejo> I think the definition is unsafeInterleaveIO = return . unsafePerformIO
00:43:02 <Taejo> @src unsafeInterleaveIO
00:43:02 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
00:43:12 <Taejo> oh, never mind, not so simple
00:43:29 <redditbot> #haskell is a busy place
00:43:29 <redditbot> Installing IPPrint, Haskell pretty-printing library
00:44:23 <mathijs> nah, I won't understand monadic stuff anyway... just learning :)  I just need a way to think about my code, so the on-the-fly returning to IO covers it I think.
00:46:10 <Taejo> dolio: it turns out having m :+: Infinity /= Infinity means I can't write concatt (at least, I don't see how)
00:47:04 <dolio> What type does concat have?
00:47:13 <Taejo> dolio: concatt :: SafeList n (SafeList m x) -> SafeList (n :*: m) x
00:47:24 <mathijs> Taejo: but it feels a bit like metaprogramming. I'm a ruby programmer, and in ruby I attach special behaviors to normal objects (like strings) all the time. maybe this is not so much 'attaching', but when concidering the flow of the final program, it's just like the string's nextchar/iterate function has been hacked to do something else before returning.
00:47:33 <edbond> how can I insert putStrLn to function for debug? I need to know how much times function was called.
00:48:41 <ksf> edbond, have a look at Debug.Trace
00:48:44 <ksf> :t trace
00:48:45 <lambdabot> Not in scope: `trace'
00:48:53 <ksf> :t Debug.Trace.trace
00:48:54 <lambdabot> forall a. String -> a -> a
00:49:19 <ksf> > trace "foo" (1+2+3)
00:49:20 <lambdabot>   Not in scope: `trace'
00:49:27 <ksf> > Debug.Trace.trace "foo" (1+2+3)
00:49:28 <lambdabot>   /tmp/1163907228605105484:70:44: Not in scope: `Debug.Trace.trace'
00:49:37 <ksf> well it won't let me.
00:50:57 <edbond> ksf: thanks. I'll take a look
00:51:32 <pejo> mathijs, if you do have those hidden side effects it is impossible to reason about your code
00:52:03 <mathijs> pejo: so getContents is a hack?
00:52:28 <Taejo> mathijs: it certainly has its problems
00:53:10 <ksf> it's using one of the less-evil unsafe* functions, if you mean that.
00:53:46 <edbond> I guess I should enclose trace in some do block?
00:54:07 <dolio> Taejo: What's your definition of :*:?
00:54:12 <ksf> nah, you just pass it your string, and then the rest of your function.
00:54:25 <ksf> it passes through it's second argument unchanged.
00:54:45 <Taejo> type family m :*: n; type instance Zero :*: n = Zero; type instance Infinity :*: n = Infinity; type instance Succ m :*: n = n :+: (m :*: n)
00:55:19 <mathijs> say I put getContents inside handle. at first the contents can be read, so they are feeded into a pure function that processes it. Then suddenly the file gets inaccessible... will the exception handler trigger at that point? what about the data that was already processed?
00:55:40 <dolio> Does that actually work? I thought families like that got rejected.
00:56:02 <Taejo> dolio: well, I had to allow undecidable instances
00:56:08 <dolio> Ah, okay.
00:56:28 <dolio> That does have a problem with Infinity :*: Zero = Infinity.
00:56:53 <Taejo> true, I can expand the definition a little
00:57:51 <dolio> Anyhow, I tried expanding the definition of :+: so that m :+: Infinity = Infinity, but it has some non-trivial consequences.
00:58:00 <sbahra> @users
00:58:00 <lambdabot> Maximum users seen in #haskell: 678, currently: 634 (93.5%), active: 15 (2.4%)
00:58:26 <Taejo> dolio: I need to get some sleep -- maybe I'll work on this tomorrow
01:24:58 <ksf> did we kill #haskell by introducing #haskell-in-depth? there's an awful lot of silence in both.
01:25:22 <ksf> come on, ask me what an IO is!
01:25:23 <osfameron> I never saw that
01:25:39 <osfameron> the vanilla #haskell always seems fairly in depth already
01:26:04 <hugo___> hola cariño
01:29:26 <cizra> ksf: What's an IO?
01:29:47 <vegai> io io f'thagn
01:31:46 <ksf> :t IO
01:31:47 <lambdabot> Not in scope: data constructor `IO'
01:31:52 <ksf> :k IO
01:31:53 <lambdabot> * -> *
01:32:01 <ksf> :t IO (>>)
01:32:02 <lambdabot> Not in scope: data constructor `IO'
01:32:12 <ksf> anyway, it's a warm, fuzzy thing.
01:33:40 <__vikrant__> :t fix f = f fix
01:33:41 <lambdabot> parse error on input `='
01:34:07 <__vikrant__> :t readFile
01:34:08 <lambdabot> FilePath -> IO String
01:57:28 <int80_h> @users
01:57:28 <lambdabot> Maximum users seen in #haskell: 678, currently: 636 (93.8%), active: 9 (1.4%)
01:58:03 <int80_h> I wonder how the number of active users is arrived at
01:59:10 <hugo___> :hmm
01:59:19 <alexeevg> A wild guess - a number of users who spoke in the last X minutes
01:59:22 <hugo___> probably those who said something in the last minuts
01:59:34 <alexeevg> stereo is still here, hehe
01:59:40 <int80_h> yeah, obviously. but what is X
01:59:48 <int80_h> it could be arbitary
01:59:48 <hugo___> 30 mins ?
01:59:51 <alexeevg> only the source knows for sure
02:00:05 <hugo___> i would go for 30 mins
02:00:12 <hugo___> ftw!
02:01:03 <alexeevg> @users
02:01:04 <lambdabot> Maximum users seen in #haskell: 678, currently: 633 (93.4%), active: 8 (1.3%)
02:01:23 <elbar> @users
02:01:23 <lambdabot> Maximum users seen in #haskell: 678, currently: 633 (93.4%), active: 9 (1.4%)
02:08:16 <mornfall> ... :)
02:10:29 <int80_h> what does this expand to, using parens? tail . filter odd $ [1..100]
02:16:23 <thorkilnaur> int80_h, (tail . (filter odd)) $ [1..100] I'd say
02:17:07 <int80_h> I mean, what does it look like w/out $. From what I've seen you're either using parens or $
02:17:33 <int80_h> and right now I'm just moving $ about until my code compiles, don't really understand it
02:18:04 <blackh> int80_h: tail (filter odd [1..100])
02:18:07 <mornfall> int80_h: It's function application.
02:18:18 <mornfall> Low priority one, even.
02:18:28 <mornfall> Whereas " " (space) is high-priority function application.
02:18:33 <blackh> int80_h: tail . filter odd $ [1..100] is equivalent to tail $ filter odd $ [1..100]
02:19:21 <int80_h> huh
02:19:42 <mornfall> foo bar blah -> (foo bar) blah
02:19:47 <mornfall> foo $ bar blah -> foo (bar blah)
02:20:15 <alexeevg> int80_h: FWIW, $ is not a part of syntax, it's a library function
02:20:17 <blackh> int80_h: tail . filter odd $ [1..100] === (tail . filter odd) [1..100]
02:20:29 <mornfall> @type ($)
02:20:30 <lambdabot> forall a b. (a -> b) -> a -> b
02:20:32 <int80_h> ah so foo bar $ blah -> foo bar (blah)
02:20:44 <alexeevg> int80_h: one can easily define infix operators in Haskell
02:21:01 <mornfall> @src ($)
02:21:01 <lambdabot> f $ x = f x
02:21:05 <mornfall> : - )
02:21:22 <alexeevg> it's only the precedence of ($) that makes it useful, is doesn't do anything really
02:21:39 <Workybob> nah, $ is useful in other contexts
02:22:08 <Workybob> map ($ 5) [(2+), (3+) (69 *)] -- for example
02:22:40 <alexeevg> Workybob: good point
02:22:43 <int80_h> Workybob, what does it do there?
02:22:52 <int80_h> oh I see
02:23:03 <Workybob> > map ($ 5) [(2+), (3+) (69 *)] -- this
02:23:04 <lambdabot>       No instance for (Num (a -> a))
02:23:04 <lambdabot>        arising from the literal `3' at <...
02:23:07 <Workybob> o.O
02:23:29 <int80_h> 2+5,3+5,69*5
02:23:32 <int80_h> right?
02:23:32 * Workybob wonders what happened there
02:23:35 <Workybob> indeed
02:23:41 <Workybob> but what's the type error on about
02:23:49 <blackh> Workybob: Missing comma
02:23:53 <Workybob> oh, cheers
02:24:00 <Workybob> > map ($ 5) [(2+), (3+), (69 *)] -- this
02:24:02 <lambdabot>   [7,8,345]
02:24:18 <blackh> Workybob: I like that!
02:24:34 <int80_h> thanks, I just learned something new about haskell
02:24:39 <Workybob> :)
02:24:56 <Workybob> > zipWith ($) [(2+), (3*)] [6,10]
02:24:57 <lambdabot>   [8,30]
02:25:08 <sauf_> hi, how I know what Prelude imports from Data.Char (before I call :m +Data.Char) in ghci ?
02:25:25 <alexeevg>  > zipWith id [(2+), (3*)] [6,10]
02:25:40 <Workybob> sauf_: you look at the prelude's export list
02:26:03 <sauf_> Workybob: how ?
02:26:11 <alexeevg> I wonder why lambdabot ignores me
02:26:13 <Workybob> look at its source
02:26:26 <Workybob> @bot
02:26:26 <lambdabot> :)
02:26:27 <lunabot>  :)
02:26:30 <sauf_> Workybob: Prelude.hs ?
02:26:30 <Workybob> > zipWith id [(2+),(3*)] [6,10]
02:26:31 <lambdabot>   [8,30]
02:26:34 <Workybob> wierd
02:26:39 <Workybob> that is odd alexeevg
02:26:46 <alexeevg> Workybob: nothing weird
02:26:50 <alexeevg> id f = f
02:26:55 <alexeevg> id f x = f x
02:26:56 <Workybob> no, the wierd thing was \bot ignoring you
02:27:03 <thorkilnaur> > 2+2
02:27:04 <lambdabot>   4
02:27:06 <alexeevg> ah, that's true
02:27:07 <thorkilnaur>  > 2+2
02:27:42 <thorkilnaur> alexeevg, So try without the blank at the beginning of the line
02:27:55 <alexeevg> thorkilnaur: thanks
02:28:07 <int80_h> @typezipWith3
02:28:07 <lambdabot> Unknown command, try @list
02:28:10 <alexeevg> the blank is not so apparent in the my current font
02:28:11 <int80_h> @type zipWith3
02:28:12 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
02:28:35 <elbar>  > 3 + 5
02:29:53 <sauf_> Workybob: I don't have Prelude.hs. How can I read Prelude.hi ?
02:30:11 <alexeevg> sauf_: you can't
02:30:34 <alexeevg> you can view ghc source tree online
02:31:06 <int80_h> alexeevg: if would call once in awhile ...;)
02:31:15 <sauf_> alexeevg: I think I read smt about converting *.hi in readable format ...
02:31:17 <int80_h> oops, my joke has bad timing
02:31:25 <int80_h> n/m
02:32:26 * alexeevg knows nothing about that, sorry
02:33:44 <blackh> sauf_: http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/Prelude.html   <- Source code of Prelude
02:34:58 <sauf_> alexeevg:  that's it : ghc --show-iface /usr/lib/ghc/imports/Prelude.hi
02:35:02 <sauf_> thx
02:35:15 <alexeevg> it seems that Hugs' Prelude sources are more appropriate for educational purposes
02:35:24 <sauf_> http://www.haskell.org/ghc/docs/latest/html/users_guide/modes.html
02:35:54 <blackh> sauf_: That's handy
02:36:34 <sauf_> blackh: yes except I don't get all the 1 1 1 ...
02:38:15 <thorkilnaur> sauf_, In hugs, you can say :find length - this gets you into the Prelude.hs source where length is defined
02:38:24 <alexeevg> sauf_: thanks
02:39:02 <blackh> I've got the command-line hoogle installed. I find that very useful.
02:40:52 <sauf_> thorkilnaur: I've never used Hugs. Do you prefer it ?
02:47:20 <thorkilnaur> sauf_, For some work, yes, because it compiles fast and is easy to start working with. I started using Haskell some years back on slow machines and GHC(i) was quite slow then. Nowadays, it is perhaps mostly a matter of habit
02:53:57 <sauf_> thorkilnaur: I find Ghc easy to start working with and without optimisation Ghc compiles fast I think. However, I'm a little confused with the transformation "OPTIONS -fWhatever" of 6.6 -> "LANGUAGE Whatever" of 6.10. Is it better with Hugs ?
02:59:10 <alexeevg> sauf_: LANGUAGE pragmas are supposed to be more portable than OPTIONS. hugs seems to support it
03:04:25 <sauf_> alexeevg: what a pity such documentation on the internet weren't aware of this ... Do you a good place where I can learn about the relation OPTION/LANGUAGE ?
03:05:05 <gordongecko> do you unittest or prove?
03:05:06 <sauf_> s/such/so much
03:05:16 <alexeevg> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
03:05:32 <tom`> how do I generate random numbers with a normal distribution in haskell?
03:05:45 <tom`> I maybe need to define my own RandomGen?
03:06:41 <Axman6> :t let f = f in f
03:06:42 <lambdabot> forall t. t
03:06:45 <ksf> If the ones it haskell ships with don't have the distribution you need, I would gess so.
03:06:48 <arjanb> tom`: have you looked on hackage? i'm sure there's some library for that
03:08:56 <thorkilnaur> sauf_, Generally, I don't use any options with Hugs, so I am not really familiar with that area.
03:09:23 <sauf_> alexeevg: thx but where can I know for example the equivalent OPTIONS for "LANGUAGE TypeSynonymInstances" ?
03:10:10 <alexeevg> sauf_: -fglasgow-exts is one-option-to-turn-em-all on
03:10:50 <sauf_> alexeevg: ok ! :) thx
03:11:11 <cizra> (an unmistakable sign of a frenchman…)
03:11:23 <cizra> (placing spaces in typographically weird places)
03:14:00 <sauf_> cizra:   which     places do you     talk about       ?
03:14:29 <cizra> sauf_: The spaces before punctuation. Like this .
03:14:55 <tom`> arjanb: thanks, I'll check that out
03:16:29 <sauf_> cizra:  ok, sorry :)
03:17:30 <cizra> sauf_: Um, why? Nothing wrong with being a frenchman!
03:18:00 <Axman6> heh
03:18:27 <tom`> Ok, so I found the dsp package on hackage but I try to build it and I get "    Could not find module `Data.Array':
03:18:28 <tom`>       it is a member of package array-0.1.0.0, which is hidden"
03:19:16 <sauf_> cizra:  in French, we have to "begin ? sequel" because "?" is a 'double' sign. I'm sorry because it's an English channel.
03:19:44 <sauf_> s/sequel/Sequel
03:20:40 <Axman6> hmm, interesting, even mutableByteArray#s have state passing
03:21:54 <cizra> sauf_: Do you mean because the "?" applies to both sentences?
03:22:46 <Axman6> tom`: have you installed the extra ghc packages?
03:23:14 <sauf_> cizra: no because it's made of 2 signs :"." and the other one. ":" i 'double' too for example
03:23:29 <sauf_> s/i/is
03:24:06 <cizra> sauf_: Oh. Interesting. And that's the reason?
03:24:11 <cknapp> Hmm... that's an interesting rule.
03:24:21 <sauf_> cizra: ";" is 'double' but "," is 'simple'
03:24:56 <sauf_> cizra: this is why there is a pace before and after in these cases
03:25:04 <sauf_> s/pace/space
03:25:31 <sauf_> (my s key is almost dead)
03:26:49 <cizra> sauf_: OK, enlightening. Thanks.
03:35:24 <_Jordan_> in Data.Map.unionWith, is the combining function passed (new_val old_val) or (old_val new_val)?
03:35:59 <Workybob> I doubt it's passed either
03:36:06 <Workybob> I wouldn't want to apply my new value to my old value
03:37:07 <_Jordan_> sorry, I probably shouldn't have used parens, or added commas, or something
03:37:19 <Workybob> alo, which do you define to be the "old" and "new" value?
03:37:25 <Workybob> a union is a symetric operation
03:38:11 <Workybob> a useful answer though: x `unionWith f` y will pass values in x as the first parameter to f, and values in y as the second parameter
03:39:42 <_Jordan_> alright, thanks! Sorry for my lack of understanding
03:40:17 <_Jordan_> I guess the example in Hoogle threw me off by calling the values "new" and "old"
03:40:50 <Workybob> 'Union with a combining function. The implementation uses the efficient hedge-union algorithm.> unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), '
03:40:57 <Workybob> I don't see any "new" or "old" mentioned
03:41:07 <_Jordan_> in unionWithKey :)
03:41:26 <Workybob> oh yeh – that needs slapped
03:41:40 * Workybob goes and opens a bug report
03:41:43 <hackage> Uploaded to hackage: UrlDisp 0.1.7
03:44:18 <Axman6> could someone take a look at http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1191#a1191 and tell me if they can see why they aren't the same? they should produce the same result in either their return type, or the STRef vvar, but my numbers are wrong with the second
03:44:37 <Axman6> oh, the first even
03:45:56 <Axman6> oh and if you're wondering, things like *. are functions that work on 3D vectors. the side with the . is the vector, and without is a scaler
03:48:40 <Workybob> Axman6: import Data.VectorSpace
03:49:03 <Axman6> why?
03:49:13 <Workybob> ^*, ^+. etc are all things that operate on vector spaces, affine spaces, additive groups etc, in general
03:49:32 <Axman6> how fast are they?
03:50:03 <Workybob> they're in the AdditiveGroup/VectorSpace/AffineSpace classes, so if they're not fast enough define your own
03:50:17 <Workybob> having said that, I guess you don't want class dictionary overhead
03:50:55 <Axman6> probably not. i'm using data Vec3 = V !Double !Double !Double
03:51:32 <Workybob> I decided TM was too much fail btw
03:51:50 <Axman6> i heard. i don't think you've learnt enough about it to make that judgement
03:51:53 <Workybob> it has one feature which is nice, but is too buggy to justify it
03:52:00 <Axman6> which is?
03:52:08 <Workybob> tab completion of structures
03:52:16 <Workybob> but I had to spend a day to get that to work sensibly
03:52:18 <Axman6> how is it buggy? :S
03:52:27 <Workybob> because the language they use to describe it is too inflexible
03:52:36 <Axman6> well you were probably doing it wrong
03:52:52 <Axman6> it's something that does requite some knowledge to use properly
03:52:56 <Workybob> no, I spoke to the guys in there and they basically went "oh wow, we would never have guessed someone would want to do that"
03:53:15 <Workybob> you'll need to write a script to generate the snippit rather than our language
03:53:29 <Workybob> and then there weren't enough environment variables provided to do it in a script
03:54:09 <Axman6> what exactly did you want to do?
03:54:17 <Workybob> so I had to use an undocumented secret feature to get it to work at all
03:54:43 <Workybob> when you type case<tab> to get the branches it adds to line up under the s in case – whether the case is the first thing on the line or not
03:55:04 <Workybob> i.e. treat the beginning of the word case as the current indent level
03:55:16 <Workybob> not the begging of the non-whitespace on the line
03:55:31 <Axman6> well, you understand that implementing that isn't trivial right?
03:55:50 <Workybob> I don't see why that's non-trivial, no
03:55:57 <Axman6> ...
03:56:07 <Workybob> that's a case of "check the column that the tab-trigger starts in, and use it"
03:56:11 <Axman6> if you knew more about how TM worked, you probably would
03:56:36 <Workybob> I don't want to have to understand how my text editor works to do simple things
03:56:42 <Workybob> that defeats the point of the text editor
03:56:52 <Axman6> it's not simple
03:56:59 <Workybob> yes, yes it is
03:57:12 <Axman6> ok, you write a text editor that does it then
03:57:17 <Workybob> "line things up with the start of the tab trigger" is not a complex concept
03:57:36 <Workybob> I told you already – I intend to write *many* text editors at the same time
03:57:40 <Workybob> when I get time for that project
04:03:09 <bastl> i get a runtime error "Non-exhaustive patterns". Is there a way to show the value that didnt match?
04:03:53 <Axman6> bastl: use -Wall
04:04:04 <Axman6> it should show you where you have patterns not matched
04:04:06 <Workybob> bastl: f x y z = error "No pattern match for f " ++ show x ++ " " ++ show y ++ " " ++ show z
04:04:21 <Workybob> also, yeh -Wall -Werror
04:05:41 <bastl> -Wall as argument to ghc --make ? that didnt change anything
04:06:36 <lilac> bastl: GHC should give you warnings about non-exhaustive patterns at compile time if you give -Wall
04:06:52 <foxy> anyone interested in discussing dependent types in GHC?
04:07:02 <Workybob> bastl: {-# OPTIONS_GHC -Wall -Werror #-} at the top of your source file
04:07:18 <foxy> or polymorphic dynamic types?
04:07:34 <Axman6> Workybob: man, i'm so cut! i shaved some more time of my n-bodies thing, got it down to 41 seconds! ... but... it gets the wrong result
04:07:50 <blackh> foxy: Sure, why not!
04:08:07 <lilac> foxy: i'm interested in GHC supporting dependent types, but not really sure how to add them cleanly to Haskell :)
04:08:17 <Workybob> foxy: don't statement to statement – just statement
04:08:20 <Workybob> :P
04:08:46 <SamB_XP> "state to state", ITYM
04:08:55 <Workybob> yeh, that's better
04:08:56 <lilac> Workybob: don't verb infinitive, just verb?
04:09:04 <Workybob> :D
04:09:17 <idnar> YO DAWG WE HERD YOU LIKE STATEMENTS
04:10:25 <lilac> > fix (\xs -> "YO DAWG WE HERD YOU LIKE RECURSION SO WE PUT A " ++ show xs ++ " IN YOUR " ++ show xs ++ " SO YOU CAN " ++ show xs ++ " WHILE YOU " ++ show xs)
04:10:26 <lambdabot>   "YO DAWG WE HERD YOU LIKE RECURSION SO WE PUT A \"YO DAWG WE HERD YOU LIKE ...
04:10:27 <uccus_> should there be a wiki page on (constructive) criticisms of the language? not having dependent types should _not_ be included
04:11:12 <SamB_XP> lilac: you've gone a little overboard, methinks
04:13:46 <SAMAC34DE> Text some woman for chat?
04:14:19 <SamB_XP> @vixen do you like SAMAC34DE ?
04:14:19 <lambdabot> yah, i like
04:14:52 <Axman6> SAMAC34DE: lambdabot is always up for it
04:14:56 <Axman6> such a whore
04:15:06 <Workybob> @bf .......>+++>+>>>>+<<<++++++++>
04:15:06 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
04:16:30 <blackh> > map (chr . pred . ord) "TBNBD45EF;!Xibu(t!ifs!obnf@"
04:16:31 <lambdabot>   "SAMAC34DE: What's her name?"
04:16:34 <blackh> Damn - too late.
04:17:27 <Axman6> blackh: text . map would have been even better :)
04:17:57 <Thunder> @src text
04:17:58 <lambdabot> Source not found. :(
04:18:02 <jeffz`> @index evaluate
04:18:03 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
04:19:54 <blackh> Axman6: I like this concept. There must be all sorts of tricks you can play on "visitors". :)
04:22:21 <Axman6> gah, i can;t figure how these two pieces are different in their behaviour!
04:22:39 <SamB_XP> two pieces ?
04:23:09 <Axman6> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1191#a1192
04:23:21 <Axman6> i get slightly different numerical results
04:23:44 <daf> http://www.unsafecoerce.com:8080/fastcgi/hpaste.fcgi/view?id=1193#a1193 — what am I missing here?
04:26:43 <Axman6> SamB_XP: reckon you could take a look?
04:28:56 <SamB_XP> you aren't building with the GCC flag -ffast-math, are you ?
04:29:19 <marcot> Is there a library for running commands in GHCi?
04:29:32 <SamB_XP> marcot: not precisely
04:29:34 <marcot> Actually, what I'd like to have is the list of all names exported by a module..
04:29:40 <marcot> It doens't need to be via GHCi.
04:29:42 <SamB_XP> there is the ghc library ...
04:30:09 <SamB_XP> (it is GHC, but as a library)
04:30:38 <marcot> SamB_XP: ok, thanks, I'll take a look.
04:32:12 <marcot> SamB_XP: I can't find a package name ghc in hackage.
04:32:29 <SamB_XP> marcot: that's true!
04:33:03 <SamB_XP> it's not exactly cabalized :-P
04:33:22 <SamB_XP> @go ghc as library
04:33:24 <lambdabot> http://www.haskell.org/haskellwiki/GHC/As_a_library
04:33:24 <lambdabot> Title: GHC/As a library - HaskellWiki
04:33:34 <marcot> SamB_XP:
04:33:36 <marcot> thanks
04:33:37 <SamB_XP> there is a link to the haddock on that page
04:33:59 <Ferdirand> Hello all, I'm curious: what are lifted/unlifted kinds ?
04:34:31 <SamB_XP> well, lifted kinds are kinds of types that have _|_
04:34:40 <SamB_XP> (are you familiar with _|_ ?)
04:37:10 <Ferdirand> define familiar...  i though all types had bottom
04:37:20 <Axman6> SamB_XP: nope, i'm using -fexcess-precision though
04:37:36 <Axman6> and that shouldn't matter, i get the same results in ghci without compilation
04:37:46 <SamB_XP> Axman6: oh :-(
04:38:00 <SamB_XP> Ferdirand: all standard types do!
04:38:46 <SamB_XP> but GHC has primitive types (both boxed and unboxed) that don't
04:38:49 <Ferdirand> SamB_XP: ok. so, did I open a Pandora's box of sorts ?
04:39:01 <bastl> finally got my tree flattening working. could someone have a look at my ugly code? perhaps lilac? http://haskell.pastebin.com/m5ff1b441
04:39:24 <SamB_XP> Ferdirand: no, you just asked about something that turns out to be an extension
04:39:44 <SamB_XP> @google GHC unlifted types
04:39:45 <lambdabot> No Result Found.
04:39:49 <SamB_XP> @google GHC unlifted
04:39:49 <lambdabot> No Result Found.
04:39:53 <SamB_XP> @google GHC unboxed
04:39:58 <lambdabot> http://hackage.haskell.org/packages/archive/ArrayRef/0.1.2/doc/html/GHC-Unboxed.html
04:39:58 <lambdabot> Title: GHC.Unboxed
04:40:03 <SamB_XP> hmm.
04:40:08 <SamB_XP> that's not exactly what I had in mind!
04:40:12 <SamB_XP> @google GHC unboxed types
04:40:13 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
04:40:13 <lambdabot> Title: 8.2.�Unboxed types and primitive operations
04:40:22 <SamB_XP> ah, that's a bit more relevant ;-)
04:40:32 <bastl> BTW: is there a way to let lambdabot "source" something from a pastebin !?
04:40:33 <Ferdirand> Makes sense. Thanks :)
04:41:12 <SamB_XP> Ferdirand: GHC isn't the only implementation that has unboxed or unlifted types, of course ;-)
04:41:41 <SamB_XP> LHC has 'em too, at least
04:41:43 <hackage> Uploaded to hackage: HaXml 1.19.6
04:42:07 <SamB_XP> but it doesn't exactly have a user manual at this point ;-)
04:42:07 <malcolmw> so does hbc
04:42:07 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
04:42:09 <Thunder> bastl: Why do you not use the constructors directly in the Tree?
04:42:44 <bastl> Thunder: because i have many diverse constructors and want to deal with them uniformly
04:42:47 <SamB_XP> of course, they each have different ones ;-)
04:43:48 <bastl> Thunder: consider an AST of java vs an AST of XML. then do some tree matching between them.
04:44:36 <Thunder> bastl: That seems not impossible to me. Existential qualification might help to keep the Tree type typable.
04:45:51 <Thunder> @type Data.Tree.Node
04:45:52 <lambdabot> forall a. a -> Forest a -> Tree a
04:45:53 <bastl> Thunder: im quite a noob in haskell and FP. what do you mean by existential qualification ?
04:46:28 <Thunder> @type Data.Tree.Node (:)
04:46:29 <lambdabot> forall a. Forest (a -> [a] -> [a]) -> Tree (a -> [a] -> [a])
04:46:49 <SamB_XP> hmm, they don't exactly go through the extensions documentation and refactor it to use functions from libraries when they become available, do they ?
04:47:03 <SamB_XP> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
04:47:08 <bastl> Thunder: as far as i can see all nodes have the same type, isnt it?
04:48:20 <Thunder> bastl: Yes, a limitation of Data.Tree. Define you own Tree type
04:48:52 <bastl> whoops
04:49:52 <Baughn> Has anyone looked at updating haskell-mode for 6.10? I tried, but I can't wrap my head around the elisp.
04:51:25 <Thunder> bastl: I'm thinking of data Tree a b = Node (a -> b) [Tree a]
04:52:56 <bastl> Thunder: and what should (a->b) be then? Any function, i guess. but can I "use" constructors as ordinary functions in haskell !?
04:53:14 <Thunder> Because that's impossible: Tree a = exists b . Node ([b] -> a) [Tree b]
04:53:21 <blackh> Axman6: I've been working on shootout recently, too.  I sped up k-nucleotide. I thought about having a go at regex-dna.
04:53:50 <Axman6> blackh: sounds good :)
04:54:16 <Thunder> So you are not able to do anything with the subtree content beside flatten it to the parent type.
04:54:45 <bastl> Thunder: now im confused.
04:55:23 <bastl> so the bs are parameters to the constructors which have the form [b] -> a to construct an "a" right?
04:56:15 <bastl> and exists b. means "there is a b, s.t. ...". does that work in a data definition in haskell ?
04:56:43 <Thunder> Yes. This way you can combine different types for each Subtree
04:57:00 <bastl> Thunder: are there examples or textbooks on that topic?
04:57:10 <SamB> it means there is a value for the type variable b such that the type of the value is ...
04:57:23 <bastl> SamB ah.
04:57:29 <Thunder> bastel: http://www.haskell.org/haskellwiki/Existential_type
04:57:56 <bastl> are there textbooks on that, perhaps relating it with alg. specification techniques ?
04:58:10 <bastl> (that would make my supervisor happy ;-) )
04:59:11 <Thunder> You may read more on http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
05:01:26 <alexeevg> bastl: http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf is excellent intro on more-or-less advanced topics in types
05:03:02 <ray> idea: cartoon documentation for Prelude functions
05:03:17 <bastl> thanks Thunder and alexeevg. looks helpful
05:03:50 <methos> bastl: i can recommend that paper too, think thats a famous one
05:04:30 <bastl> quite old, 1985 ...
05:06:00 <SamB> bastl: some things don't change!
05:06:46 <alexeevg> bastl: nevertheless, the presentation is very smooth, and you'll get up to speed on existential types, higher rank types (if my memory serves me, they are covered there) quicker. "On Understanding Types..." + GHC manual is enough to get a working knowledge of these things unless you're going to implement advanced typecheckers yourself
05:07:54 <alexeevg> bastl: moreover, very little ideas in modern type systems are brand new, I guess
05:33:18 <Cheshire> looks like all the conversation got sucked out of here
05:35:44 <ivanm> Cheshire: oh, you expected _conversation_...
05:35:45 <alexeevg> looks like people are afraid to say something too advanced here or something not-so-advanced on #haskell-in-depth
05:35:47 <ivanm> silly me ;-)
05:36:24 <Cheshire> I need to make a parser for this language
05:36:36 <shukhov> i've already backed up my #haskell-in-depth buffer with "it's trivial..."
05:36:52 <ivanm> Cheshire: for haskell?
05:36:57 <ivanm> what's wrong with the ones we've already got?
05:37:08 <Cheshire> in haskell, what I'm parser is simpler
05:37:20 <ivanm> (though I sometimes wish haskell-src{,-exts} kept comments...)
05:38:33 <Cheshire> What I want to parse*
05:39:59 <gordongecko> is it possibel to write a real quicksort in haskell using mutable arrays?
05:40:05 <Cale> gordongecko: yes
05:40:46 <ivanm> @faq is it possible to write a real quicksort in Haskell?
05:40:46 <lambdabot> The answer is: Yes! Haskell can do that.
05:40:49 <liwp> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
05:40:49 <ivanm> ;-)
05:40:58 <Cale> Though it's a bit odd to say that the version with immutable lists isn't "real". I would say the actual distinction is really "in-place" vs. "not in-place".
05:41:05 <Axman6> gordongecko: check the ST monad page on the wiki, there's a lnk to one
05:41:07 <Axman6> link*
05:41:29 <PeakerWork> http://tinyurl.com/cx6gnb
05:42:11 <PeakerWork> gordongecko: LetMeGoogleThatForYou is funny, I hope its not offensive :-)
05:42:24 <Cheshire> Is there any magic haskell code that will make a parser and pretty printer at the same time?
05:42:39 <PeakerWork> Cheshire: Look for "Pickler combinators"
05:42:42 <Cale> Cheshire: There are some libraries of that sort...
05:42:47 <Cale> yes, those :)
05:42:50 <liwp> peakerwork: I think it's brilliant
05:42:53 <PeakerWork> Cheshire: There's a paper, I'm not aware of an actual cabal library ot so
05:42:53 <Cheshire> You can't do this with Pickler combinators
05:43:05 <PeakerWork> Cheshire: why not?
05:43:15 <Cale> Cheshire: Isn't it more or less the same thing?
05:45:29 <inbuninbu> i'm trying to parse a binary file... and there's something i'm not getting... so i'm using withBinaryFile, and i understand you give it a function. but the type of function has to be 'IO r'...
05:45:38 <orgthingy> hello, can anybody explain why isnt haskell as popular as C or c++ yet?
05:45:57 <lstor> I have a file with newline separated names. I want to read those names into a list, so that each element in the list corresponds to one line (one name) in the file. Is there an easy way? If yes, how? If not, I'll just add list syntax to it using gawk and paste it in ghci :)
05:46:12 <lstor> orgthingy: Because the world isn't made of mathematicians, sadly.
05:46:15 <mopped> @src cons'cps
05:46:15 <lambdabot> Source not found. It can only be attributed to human error.
05:47:15 <Cheshire> @let cons'cps x xs k = k (x:xs)
05:47:16 <lambdabot>  <local>:5:0:
05:47:16 <lambdabot>      Warning: Pattern match(es) are overlapped
05:47:16 <lambdabot>               In...
05:47:23 <Toxaris> > lines "first\nsecond\nthird" -- lstor you can use the lines function for the "parsing" part
05:47:24 <lambdabot>   ["first","second","third"]
05:47:28 <inbuninbu> so i guess i'm asking what the function i need to pass it should look like
05:47:41 <orgthingy> lstor : valid reason :P
05:48:07 <Toxaris> lstor: you can easily but somewhat-dangerously read a file with readFile
05:48:15 <alexeevg> lstor: lines `fmap` readFile "names.txt"
05:48:17 <mopped> map'cps f'cps (x:xs) k = f'cps x $ \f'x -> cons'cps f'x (map'cps f'cps xs k) $ \consd -> k consd
05:48:20 <mopped> how does that look?
05:49:07 <paulvisschers> Is there a way of using cabal-install for removing packages?
05:49:13 <lstor> Great, thanks all of you, I'll get to work on that and come back if something fails. I've heard that this is a helpful channel, and so far my experience is that that is true ;)
05:49:25 <Toxaris> mopped: that's not CPS because you use the result of (map'cps f'cps xs k) in a call to cons'cps instead of directly returning it
05:49:52 <mopped> hmm ok
05:50:07 <lstor> orgthingy: Second, I guess most programmers haven't even heard about it. And when they do, recursion and the "unfamiliarity" is too discouraging.
05:50:11 <mopped> How do I deal with that then? I'm not sure how I deal with recursive calls in CPS
05:50:28 <paulvisschers> Or is there another way of doing that easily?
05:50:38 <lilac> paulvisschers: i believe not. you can unregister with ghc-pkg, then delete the directory inside .cabal
05:50:40 <orgthingy> lstor : aye
05:50:53 <orgthingy> I myself dont know haskell, i knew it by chance from a friend of mine
05:50:54 <alexeevg> mopped: as usual, call itself i tail position and pass a continuation
05:51:01 <orgthingy> but it looks interesting
05:51:02 <paulvisschers> lilac: Ok thanks
05:51:03 <alexeevg> iN tail position
05:51:07 <orgthingy> ill learn it after my c education
05:51:14 <lstor> orgthingy: My situation is the same. But what I have seen so far is pure beauty and elegance :)
05:52:23 <Cheshire> mopped, the key is that   cons x  is a function that takes  xs  into x:xs
05:52:28 <orgthingy> lstor : and, some simply dont like static typing
05:52:37 <orgthingy> dynamic, like ruby or others, are liked a lot
05:53:58 <lstor> orgthingy: True. I guess those are the people who like 30-line qsort implementations and bugs in their programs too...
05:54:19 <arw> orgthingy: i hated static typing before i knew haskell. haskell is the first language with static typing which doesn't always step on your toes.
05:54:39 <arw> orgthingy: mostly because of typeclasses and type inference.
05:54:57 <orgthingy> C has "Weak" static typing, so i dunno if it's as static-as-haskell
05:54:59 <orgthingy> i see
05:55:08 <sbahra> arw, that is surprising. :)
05:55:17 <arw> why?
05:55:35 <sbahra> arw, what languages were you dealing with before Haskell?
05:55:50 <arw> java, c, perl, c++, pascal.
05:55:58 <sbahra> arw, how does C static typing step on your toes?
05:55:59 <methos> type inference is in c#3.0, will be in c++0x und there is "a tiny little bit" in Java :)
05:56:13 <methos> see "var", "auto" etc
05:56:13 <idnar> I concur with arw
05:56:27 <idnar> static typing in C-derivatives basically just makes you type more
05:56:30 <arw> sbahra: it doesn't, but thanks to stuff like void* c isn't really statically typed if you want to get around it.
05:56:31 <mopped> I don't really follow Cheshire, I can try cons'cps f'x $ \cons'f'x -> cons'f'x (map'cps f'cps xs k) $ .., but i'm still recursively calling
05:56:38 <lilac> methos: c++0x doesn't really have full type inference.
05:56:54 <alexeevg> mopped: let mapcps f [] k = k []; mapcps f (x:xs) k = f x $ \y -> mapcps f xs $ \ys -> k (y:ys)
05:57:00 <lilac> methos: it'll infer the type of a variable from the type of its initializer, but nothing more
05:57:01 <sbahra> arw, (void *) is an opaque type.
05:57:02 <Cheshire> mopped, so it's like:   k (cons (f x) (map f xs))
05:57:03 <methos> at least on a variable decl level, where it sucked most :)
05:57:18 <lilac> methos: i'm not saying it's not a giant leap forwards :)
05:57:23 <methos> ^^
05:57:27 <methos> but you are right
05:57:59 <Cheshire> mopped, let f'x = f x in let cons'f'x = cons f'x in let map'f'xs = map f xs in let result = cons'f'x map'f'xs in k result
05:58:19 <mopped> f'cps x $ \x -> map'cps f'cps xs $ \xs -> cons x xs $ \consd -> k consd?
05:58:19 <Cheshire> mopped, except instead of using let, use lambda & continuations
05:58:44 <lilac> methos: also, i thought 'var' in c#3.0 was a variant type (dynamically checked) rather than an inferred type?
05:59:18 <idnar> lilac: no, it just infers the type from the RHS, as far as I know
05:59:19 <Toxaris> mapped: short example: "f x = f (g x)" becomes "f' x k = g' x (\y -> f y k)" for a suitable g'. Note how the intermediate result of (g x) has been namend y, and how the order of f g has been reversed to g' f'. Furthermore, since f never returns, f' never calls k.
05:59:23 <lilac> methos: iiuc, c#'s lambdas have type inference but var does not
05:59:42 <arw> sbahra: most languages step on your toes by requiring an awful amount of attention to declaring and using the right types or the right hierarchy of types.
05:59:44 <idnar> ie. var x = 5; is the same as int x = 5; or whatever
06:00:06 <sbahra> arw, I don't mind that, it helps with the design process.
06:00:23 <sbahra> arw, type inference is nice, for sure.
06:01:06 <arw> sbahra: i.e. in object oriented languages you always have to pay attention to the proper parent classes, so that when you pass a reference around you can pass a reference to the parent class.
06:02:03 <sbahra> Yes, with OO languages it becomes annoying for sure.
06:02:14 <arw> sbahra: which leads to infinite uglyness down the way. most oo proponents will just tell you "well, it was badly designed, you should have made it more extensible".
06:02:21 <osfameron> huh?
06:02:29 <osfameron> why should you have to worry about your parent classes?
06:02:31 <sbahra> But this isn't a static typing issue, IMHO.
06:02:35 <Philonous> I wonder where's the difference between forall a. (a->a) -> ( Bool, Char) and (forall a. a->a) -> (Bool,Char) ?
06:02:53 <Toxaris> arw: not the other way around: you can pass references to arbitrary subclasses instead of a reference to a parent class
06:03:18 <Toxaris> arw: which is worse, because you statically know your parent class, but you don't know that much about your subclasses
06:03:25 <Saizan> is anyone using haddock0.9 ? and can point me to a library that doesn't make it crash?
06:04:10 <arw> Toxaris: this is what i meant. i guess i was a little unprecise.
06:04:24 <mopped> Toxaris: can you elaborate a bit more on g'?
06:04:31 <lilac> idnar: yes, sorry, looks like i was misrecalling.
06:04:36 <orgthingy> bye!
06:05:26 <Toxaris> Philonous: in the former, the caller decides upon a, passes a function (a -> a) (for that single a), and gets a (Bool, Char). In the latter, the caller passes a function (forall a . a -> a). The called function can call this function with whatever a's it likes, and eventually returns a (Bool, Char) to the caller.
06:06:12 <Philonous> Ah, so with the former I fix an a even though the function might be more general?
06:07:03 <Toxaris> Philonous: which means that the former is not very interesting, because the callled function can not use the first parameter (because it does not know a, it cannot do anything interesting with it), and the latter is not very interesting, because there are not many functions of type (forall a . a -> a). Basically just id.
06:07:34 <Toxaris> Philonous: every caller can chose a different a in the former
06:08:23 <Toxaris> Philonous: a function is more general if the caller can chose types, then it can be called in more different contextes, because the respective caller can chose a good type
06:11:04 <Toxaris> mopped: well, g' is just g in CPS. So if g is "g x = x + 1", then g' is "g' x k = k (x + 1)". (assuming that + is primitive and it is allowed to call it in direct style)
06:11:30 <Toxaris> mopped: in your example, you get g' passed in (it corresponds to f'cps)
06:12:13 <Philonous> > (\f -> (f "abc" , f True)) id
06:12:14 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Char]'
06:12:36 <Cheshire> > let f = id in (f "abc" , f True)
06:12:37 <lambdabot>   ("abc",True)
06:13:11 <Axman6> :t (\f -> (f "abc" , f True))
06:13:12 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[Char]'
06:13:12 <lambdabot>       Expected type: Bool -> t
06:13:12 <lambdabot>       Inferred type: [Char] -> t1
06:13:22 <Axman6> how odd
06:13:49 <Axman6> > 51.657 - 47.215s
06:13:49 <lambdabot>       No instance for (Fractional (Expr -> t))
06:13:49 <lambdabot>        arising from the litera...
06:13:54 <Axman6> > 51.657 - 47.215
06:13:55 <lambdabot>   4.441999999999993
06:15:03 <Philonous> > (\f -> (f (1::Int), f (1::Float))) (*2)
06:15:04 <lambdabot>   Couldn't match expected type `Float' against inferred type `Int'
06:15:30 <Philonous> :t (*2)
06:15:31 <lambdabot> forall a. (Num a) => a -> a
06:16:25 <Toxaris> Axman6, Philonous: since the type inference cannot know which type you want (nested forall or outer forall), it always choses to put the foralls at the beginning of the type. That means that type inference does not work if you need the more complicated types with nested foralls
06:16:31 <Axman6> > 77.367 - 47.215
06:16:32 <lambdabot>   30.152
06:16:36 <alexeevg> >let foo :: (forall a . a -> a) -> (String, Bool); foo f = (f "abc" , f True); in foo id
06:17:09 <Toxaris> > let foo :: (forall a . a -> a) -> (String, Bool); foo f = (f "abc" , f True) in foo id
06:17:10 <lambdabot>   ("abc",True)
06:17:28 <doserj> > (\(f::forall a. Num a => a -> a) -> (f (1::Int), f (1::Float))) (*2)
06:17:29 <lambdabot>   (2,2.0)
06:17:37 <Axman6> Toxaris: yeah, i'd just never though about the idea, and it surprised me a little
06:18:24 <Toxaris> I guess thats the reason why nested foralls were not allowed in Haskell 98, because they don't work well with type inference
06:18:44 <Toxaris> (but maybe there are other implementation problems I don't know about)
06:18:48 <SamB> heck, Haskell 98 had no foralls
06:19:20 <Axman6> Toxaris: well they're necessary for lovely things like ST
06:19:22 <SamB> (on account of not supporting types that needed them anywhere but the far left, where they were implicit)
06:20:07 <Toxaris> I consider ST a lovely hack :)
06:20:12 <edwardk> you can't infer them in general (though there are limited cases for which you can) but you can propagate the annotations when they are provided, which is why ghc picked them up when it picked up a nicer bidirectional type inference/checking algorithm
06:20:37 <Axman6> Toxaris: you're not alled to dis ST, it's pure!!!
06:20:41 <Axman6> PURE!!!!!
06:20:44 <Axman6> :o
06:21:02 <SamB> Axman6: pure and imperative at the same time, yes
06:21:06 <SamB> that part is nice enough
06:21:09 <SamB> but the types!
06:21:16 <edwardk> axman6: or at least it seems to be so to an outside observer.
06:21:17 <alexeevg> everything in haskell is pure
06:21:34 <Axman6> SamB: what's wrong with them?
06:21:36 <SamB> yes but the wonderful thing is that runST is pure, too
06:21:37 <Toxaris> Axman6: my problem with ST is that you have to pass the dummy state around explicitly *in the type signatures*
06:21:42 <SamB> Axman6: they, er, are wierd
06:21:43 <edwardk> nah i've seen some pretty dirty haskell one-liners
06:21:55 <alexeevg> as Conal Elliot likes to put it, the real difference is between something that has nice denotational semantics and smth that doesn't
06:21:56 <Toxaris> Axman6: which forces you to write type signatures at all
06:22:03 * Axman6 doesn't bother with type sigs in his ST stuff
06:22:35 <SamB> alexeevg: well, the semantics are fine!
06:22:40 <SamB> it's the types
06:22:40 <Axman6> > 100 - 100 * 47.215/77.367
06:22:41 <lambdabot>   38.97268861400856
06:22:43 <Toxaris> Axman6: but of course, its nice that one can express this in pure Haskell, but it would be even nicer if it would have a even nicer API
06:23:05 <alexeevg> SamB: what are the denotational semantics of ST?
06:23:06 * Toxaris looks at stuff from a language design perspective, searching for areas to improve :) 
06:23:07 <Axman6> what's not nice about the API?
06:24:00 <SamB> alexeevg: well, you could implement it with, oh, a Data.Map or something, with keys stuffed into STRefs
06:24:06 <Axman6> Toxaris: i'm writing quite a bit in ST atm, and none of it needs type sigs
06:24:18 <augustss> @pl \ (a,b) -> (f a, f b)
06:24:18 <lambdabot> f *** f
06:24:27 <Toxaris> Axman6: you need type sigs if you write functions which take ST actions and compose them
06:24:37 <Toxaris> Axman6: IIRC.
06:24:40 <bastl> Im again stuck in OO thinking (Typeclass Data.Data is not a Type). Can someone explain why the following doesnt work, or yet better give a workaround? http://haskell.pastebin.com/m6eb18fbc
06:25:25 <alexeevg> SamB: hmm. I think Conal would object to this, but I have no arguments except it doesn't seem nice
06:26:49 <Toxaris> bastl: can you show the exact error message?
06:27:24 <alexeevg> of course you can implement ST on top of maps + Data.Dynamic or usafeCoerce, but I think the point is - really pure interfaces are based on some algebra, with laws allowing equational reasoning
06:27:45 <SamB> alexeevg: oh, I forgot that bit
06:28:11 <SamB> well, in a semantics you can use a similar strategy without calling on Data.Dynamic -- just call it an environment ;-)
06:28:17 <SamB> or a heap, or something
06:29:19 <bastl> there was a failure, parse :: FilePath -> IO Something, with Something in Data. http://haskell.pastebin.com/m79dc966f
06:29:40 <SamB> is there a way to get happy to put type signatures on EVERYTHING it defines ?
06:30:26 <Toxaris> alexeevg: so you want to proof things like "(newSTRef x >>= readSTRef) == return x"?
06:31:30 <alexeevg> Toxaris: sort of
06:31:57 <Workybob> alexeevg: I don't think conal would object – merely point out that you have no semantics to go on – no where do you have written down "these are the semantics of ST"
06:32:15 <Workybob> in any way other than "here's an implementation that we claim implements what was in our head"
06:32:16 <SamB> Toxaris: hmm. can you do that with my proposed semantics ?
06:32:18 <Toxaris> bastl: the problem is that the type inferencer tries to find a type for program, and cannot decide between ProgramFile and Module. you have to explicitly annotate that you want (forall a. Data a => a) as type for program.
06:33:22 <Toxaris> bastl: but I don't know whether or how that works
06:34:10 <alexeevg> Workybob: as SamB pointed out, one can give denotational semantics of side-effecting procedures as functions on store, but I don't think Conal would call it compositional etc
06:34:20 <mopped> map'cps f'cps (x:xs) k = f'cps x $ \f'x -> map'cps f'cps xs $ \f'xs -> cons'cps f'x f'xs k
06:34:24 <mopped> is that better?
06:34:35 <SamB> alexeevg: hmm, no, not really
06:34:42 <SamB> ST isn not for composition
06:34:47 <SamB> er.
06:34:55 <SamB> ST is not for very compositional things
06:35:24 <SamB> it is for imperative algorithms you haven't managed to beat functionally
06:35:46 <SamB> when you still want referential transparency and all that
06:36:06 <SamB> > runST (return 1)
06:36:07 <lambdabot>   /tmp/7924683798585754633:70:36: Not in scope: `runST'
06:36:07 <Workybob> alexeevg: well no, it by very definition isn't compositiona/
06:36:11 <SamB> hmm...
06:36:15 <Toxaris> ST is for imperative sub-algorithms, which are to be reused in a functional algorithm
06:36:17 <alexeevg> SamB: exactly. So we're back at the statement - "technically, ST is pure, as everything in Haskell, but it doesn't mean anything really"
06:36:17 <SamB> why doesn't lambdabot let you do that ?
06:36:17 <Workybob> that's why we like referential transparency
06:36:33 <idnar> @hoogle runST
06:36:33 <lambdabot> Control.Monad.ST runST :: ST s a -> a
06:36:33 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
06:36:33 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
06:36:38 <SamB> alexeevg: well, compare runST with unsafePerformIO
06:36:40 <idnar> > Control.Monad.ST.runST (return 1)
06:36:41 <lambdabot>   /tmp/6250325414482327596:70:36:
06:36:41 <lambdabot>      Not in scope: `Control.Monad.ST.runST'
06:36:45 <alexeevg> it's imperative in look and feel
06:36:45 <idnar> > ST.runST (return 1)
06:36:46 <lambdabot>       Failed to load interface for `ST':
06:36:46 <lambdabot>        Use -v to see a list of the f...
06:36:48 <idnar> meh
06:37:02 <SamB> they have identical operational semantics in GHC
06:37:03 <Axman6> > runST (return 1)
06:37:04 <lambdabot>   /tmp/38899975917456349:70:36: Not in scope: `runST'
06:37:13 <SamB> and yet one is pure, the other not
06:37:46 <Workybob> ohhhh, SamB – thank you
06:37:59 <Toxaris> mopped: yes thats CPS!
06:38:00 <Workybob> you've just put together exactly why I'm uneasy about IO
06:38:06 <Toxaris> mopped: you also need a base case, of course
06:38:09 <Workybob> it *isn't* referentially transparent
06:38:13 <Workybob> unsafePerformIO *is*
06:38:20 <SamB> Workybob: no, no
06:38:24 <SamB> the other way round
06:38:29 <Workybob> unsafePerformIO is just performing a *different* action each time
06:38:35 <SamB> unsafePerformIO isn't
06:38:40 <SamB> runST is
06:39:03 <Toxaris> Workybob: but if unsafePerformIO is a function, it is not allowed to perform a different action if given the same argument
06:39:06 <Axman6> Workybob: unsafePerformIO (readFile "foo") should in theory give the same result, whether foo chages or not i think
06:39:13 <Workybob> Toxaris: exactly
06:39:18 <Workybob> so it *must* be given a different argument
06:39:20 <SamB> Axman6: what theory ?
06:39:31 <Axman6> my theory!
06:39:32 <Workybob> as we just discovered – runST and unsafePerformIO are the same thing
06:39:37 <Workybob> runST is pure
06:39:41 <mopped> yeah, i've got .. [] k = k [], but how can you give me a sample input? It works when say f'cps is (\x k -> k (x + 1)) and k is id, but what other (form) of functions can k be?
06:39:42 <SamB> I said operationally!
06:39:42 <Workybob> therefore unsafePerformIO is too
06:39:52 <Axman6> well IO can be implemented using ST, woth a few extensions
06:39:54 <Workybob> therefore unsafePerformIO is given a different (implicit) argument
06:39:57 <Workybob> (the world)
06:39:58 <alexeevg> Workybob: you missed the word "operationally"
06:40:02 <SamB> the same operations at differently-restricted types
06:40:20 <SamB> why did I even say that ...
06:40:25 <mlesniak> What is the simplest way to convert from String -> [Int]. I just found (map $ read . (:[]) :: String -> [Int]) "123" but I'm curious if there's a shorter way
06:40:30 <Toxaris> mopped: you have to provide an initial continuation somewhere, e.g. in the main function of your program, or wherever you start using CPS.
06:40:35 <alexeevg> runST is unsafePerformIO with phantom types stuffed on top of it to make it safe
06:40:37 <SamB> oh, yeah, to point out what's better about ST than IO
06:40:42 <Toxaris> mopped: very often, one uses id as the initial continuation
06:41:06 <gordongecko> whats so great about parsec? i heard it is to slow. is it for soing complex parsing?
06:41:19 <gordongecko> could someone point to a simple example that shows its power?
06:41:21 <SamB> gordongecko: eh, it's not that great
06:41:39 <asgaroth> mlesniak: map digitToInt "123"
06:41:40 <SamB> I used to think it's parse error messages were the shit ...
06:41:43 <hackage> Uploaded to hackage: bitset 1.0
06:41:57 <mopped> can you elaborate a bit? you've kinda lost me
06:42:00 <mlesniak> asgaroth: Ah, thanks, sometimes the simplest functions are the worst to find :D
06:42:15 <asgaroth> mlesniak: searching for types helps:
06:42:22 <asgaroth> @hoogle String -> [Int]
06:42:22 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
06:42:22 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
06:42:22 <lambdabot> Prelude fail :: Monad m => String -> m a
06:42:37 <mlesniak> asgaroth: Did it, did not found anything I thought was correct ;)
06:42:42 <asgaroth> @hoogle Char -> Int
06:42:42 <lambdabot> Data.Char digitToInt :: Char -> Int
06:42:42 <lambdabot> Data.Char ord :: Char -> Int
06:42:42 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
06:42:54 <mlesniak> asgaroth: And did not think about char -> int ;)
06:43:04 <Toxaris> mopped: in CPS, you pass the continuation around as k, sometimes changing it.
06:43:18 <Toxaris> mopped: but the operation system is not written in CPS, nor is ghci. So at some point you have to invent a k.
06:43:32 <Axman6> > foldl (\acc d -> acc*10+digitToInt d) "12346"
06:43:33 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
06:43:36 <Toxaris> mopped: it is called the initial continuation, and most of the time, you use id.
06:43:39 <Axman6> > foldl (\acc d -> acc*10+digitToInt d) 0 "12346"
06:43:40 <lambdabot>   12346
06:44:17 <mendoza> PUSH! http://www.lostworlds.lv/go.php?1139712455 (THIS IS THE BEST GAME IN THE WORLD))
06:44:21 <mendoza> PUSH! http://www.lostworlds.lv/go.php?1139712455 (THIS IS THE BEST GAME IN THE WORLD))
06:44:27 --- mode: ChanServ set +o Saizan
06:44:30 --- mode: Saizan set +b *!*n=mendoza@89.254.131.*
06:44:31 --- kick: mendoza was kicked by Saizan (Saizan)
06:44:41 --- mode: Saizan set -o Saizan
06:44:45 <Axman6> > foldr ((:) . digitToInt) [] "123"
06:44:46 <lambdabot>   [1,2,3]
06:45:02 <Axman6> mlesniak: how's that? ^^
06:45:08 <Axman6> > foldr ((:) . digitToInt) [] "123asd"
06:45:09 <lambdabot>   [1,2,3,10,* Exception: Char.digitToInt: not a digit 's'
06:45:13 <idnar> Axman6: what's wrong with map?
06:45:16 <Toxaris> mopped: but you can use whatever you want. e.g. (map'cps (\x k -> k (x + 1)) [1, 2, 3] show) should give "[2, 3, 4]"
06:45:18 <mlesniak> Axman6: Using folds is nice but map is more obvious ;)
06:45:26 <asgaroth> well, foldr ((:) . foo) [] === map foo
06:45:28 <mopped> When I convert something into CPS, how do I know when to call the continuation? How did I know I should call it after consing the two items together, as opposed to have finishedm apping the whole list
06:45:28 <Axman6> ha, yes, so it is
06:45:48 <Toxaris> mopped: because it should be equivalent to (show (map (\x -> x + 1) [1, 2, 3]).
06:45:53 <geezusfreeek> ski_, sorry i missed your question before i went to bed
06:46:15 <geezusfreeek> ski_, last night i was working on pure haskell cooperative threads
06:46:44 <Toxaris> mopped: there is a nice algorithm to convert into CPS which can be performed by hand. I'm searching for a reference.
06:48:13 <Cheshire> mopped, you don't really call continuations, you throw values into them
06:49:00 <mopped> ok
06:51:19 <Cheshire> (and don't except the values to come back)
06:51:50 <lstor> How can I get something out of a monad? I have IO [String], and I need to get [String]. I can only find out how to go the other way...
06:52:08 <Botje> you can't
06:52:12 <edwardk> istor the short answer is that you don't.
06:52:26 <Axman6> lstor: you don't get stuff out of IO once it's in it (without magic). you need an IO tutorial i think
06:52:29 <Botje> you can use a do block to temporarily unwrap the IO [String] into a [String]
06:52:37 <Botje> but you are forced to re-wrap it at the end
06:52:41 <Axman6> lstor: http://axman6.homeip.net/blog/axmans-haskell-io-tutorial.html might help
06:52:44 <Axman6> </plug>
06:52:50 <edwardk> istor the long answer is that there are ways for when you really really need to, but if you have to ask the question, odds are you are doing something wrong. =)
06:53:02 <Axman6> edwardk: it's an l, not an i :P
06:53:47 <mopped> how would filter'cps work then? as it uses a predicate, would it need to be p'cps? or something like filter'cps p (x:xs) k | p x = filter'cps p xs $ \xs -> cons'cps x xs k; | otherwise = filter'cps p xs k; and then the basecase of k []?
06:53:52 <edwardk> axman: bah, if i'm not going to capitalize the first word in the sentence, why would I capitalize his name? ;)
06:53:57 <edbond> can you suggest optimizations for this? http://haskell.pastebin.com/m2e8bc997
06:54:02 <Toxaris> mopped: ok the reference is: Olivier Danvy, Three Steps for the CPS Transformation, 1991
06:54:08 <Axman6> edwardk: it's an L, not an I then ;)
06:54:10 <mopped> thanks
06:54:28 <Toxaris> mopped: but it seems to be quite technical. I can explain the short version.
06:54:30 <sbahra> edwardk, how is that project of yours coming along (JIT)?
06:54:46 <alexeevg> yeah, Danvy is an expert in everything related to continuations
06:54:52 <mopped> that would be helpful Toxaris
06:54:56 <bartiosze> Hi, folks. Do you think that 'The Functional Approach to Programming" by Guy Cousineau and Michel Mauny may be a good book to start with Haskell? The code inside is in Caml, but is it worth trying it with Haskell?
06:54:56 <edwardk> sbahra: hey, not too bad. i haven't been able to really work on it for about 3 weeks now though.
06:54:58 <Axman6> edbond: you only need to check form 2 to √n to see if a number's prime
06:55:24 <doserj> edbond: and you only need to check against other prime numbers
06:55:25 <edwardk> sbahra: the interpreter/tracing half of it is now pretty solid. i need to do a lot of work on the code emitter side though
06:55:41 <Axman6> and yes, only other primes needs to be checked
06:55:57 <Toxaris> mopped: you start with a direct style expression, e.g. "cons (f x) (map f xs)". Thats the body of a regular map implementation. Note that the recursion makes no difference at all.
06:56:17 <bastl> still dont get it. i cleaned up my code. how can i get ghc to accept this? http://haskell.pastebin.com/m7b2e403a
06:56:19 <Axman6> but checking up to the sqrt of x saves more than just checking primes up to x (checking only primes up to sqrt x is even better :)
06:57:21 <Toxaris> mopped: first step, you name all intermediate results using let: "let a = f x; b = map f xs; c = cons a b in c"
06:57:34 <lstor> edwardk, Botje, Axman6: I might very well be doing something wrong:P I read in a list of names from a file, so I have IO [String]. Then I tried to do: let leftover = filter (`elem` assigned) all   to try to filter the list. (I think I have to work on the predicate, but that's not the point)
06:57:36 <alexeevg> bartiosze: I know nothing about this book but I find learning an ML dialect before Haskell a good approach
06:57:38 <Toxaris> mopped: (if you have deeper nested expression, you have nested lets at this step).
06:57:47 <mopped> ok
06:58:14 <Axman6> lstor: did you check out my tutorial?
06:58:16 <lstor> Where 'assigned' and 'all' are lists of names (i.e. IO [String])
06:58:28 <doserj> bastl: define a datatype that represents the possible results from parse. data ParsedFile = ParsedProgram ProgramFile | ParsedModule Module
06:58:32 <Axman6> :t elem
06:58:33 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:58:50 <geezusfreeek> bastl, as far as types are concerned, you are thinking like an OO programmer, which is backwards from haskell. in haskell, polymorphic types are bound by the _caller_ of a function, to the return type of your parse function has to be able to return whatever type the caller wants as long as it is of the type class Data. the problem is that your function attempts to return one of two _different_ possible types
06:58:58 <edwardk> istor: work inside the io monad. something like do x <- howeverYouReadTheFile; return (filter ...)
06:59:15 <lstor> Axman6: Yes, I'm reading :) I'm just trying to decide if it will help me now, or if I am going about it all wrong.
06:59:15 <geezusfreeek> bastl, using a data type instead of a type class as doserj says would be the right way to do what you seem to want to do
06:59:15 <edwardk> istor: the result will be an IO action
06:59:19 <Toxaris> mopped: second step, you linearize the lets in your intended evaluation order: "let a = f x in let b = map f xs in let c = cons a b in c"
06:59:33 <Toxaris> mopped: if your lets after the first step are nested, you have to do more in the second step.
06:59:33 <Axman6> lstor: probably the later, but it's easy to fix
06:59:40 <Axman6> i must go to bed though, so g'night all
06:59:48 <lstor> Axman6: Thanks for the help, good night :)
07:00:04 <lstor> edwardk: All right, I'll try that. Thanks  :)
07:00:06 <edwardk> istor: another tool that you may find useful is fmap.
07:00:16 <edwardk> istor: which is basically what that just did ;)
07:01:05 <Axman6> http://ss.frim.nl/==983 heh
07:01:15 <Axman6> not sure what it's a graph of, but... it's awesome
07:01:34 <mopped> ok
07:02:03 <geezusfreeek> Axman6, looks like somebody is either compiling python to llvm or using a dsl in python to generate llvm
07:02:14 <Toxaris> mopped: now, you replace "let a = b in c" by "b (\a -> c), and rename top-level identifiers so that the cps-versions of other functions are called
07:02:23 <geezusfreeek> and that is pretty awesome
07:02:24 <edwardk> @src liftM
07:02:24 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:02:38 <Axman6> yeah, definitely looks like a python to native compiler using llvm
07:03:08 <edwardk> liftM is a valid default definition for fmap for a monad. so you can see basically the same behavior i just described boxed up for you in a nice function.
07:03:22 <geezusfreeek> > 0.03/29.2
07:03:24 <lambdabot>   1.0273972602739725e-3
07:03:42 <geezusfreeek> > 29.2/0.03 -- woops
07:03:43 <lambdabot>   973.3333333333334
07:03:45 <Toxaris> mopped: now you get: "f' x (\a -> map f xs (\b -> cons a b (\c -> c k)))" note that in the very end, I replaced the "in c" with "in k c"
07:04:26 <Toxaris> mopped: now you eta-reduce the end of the expression from "cons a b (\c -> c k)" to "cons a b k"
07:04:30 <Toxaris> mopped: and you are done.
07:05:00 <Toxaris> no its not really eta-reduction.
07:05:26 <bastl> doserj: thanks alt. that worked like a charm and i have finally an idea how to overcome my OO thinking :-)
07:05:31 <zachk> 666 users in here muhahahahhaha >:E
07:05:33 <bastl> *alot
07:05:37 <mopped> I was about to ask what eta-reduction was ;)
07:05:40 <Toxaris> mopped: yes it is, because it should be "\c -> k c" which is reduced to "k"
07:05:47 <edwardk> nah perspectival quit. ;)
07:06:06 <Toxaris> mopped: eta reduction is just a technical term which means that "\x -> f x" can be replaced by "f"
07:06:36 <bastl> still i have to enumerate all possible types. it be nicer to be able to do it whith every type in a specific typeclass
07:06:41 <mopped> ok thanks, thats a nice algrothim
07:07:08 <Toxaris> mopped: steps one and three are totally mechanical, but in step three, you have to decide upon the evaluation order
07:07:32 <bartiosze> alexeevg ok, thanks.
07:07:42 <geezusfreeek> bastl, if you want it to work just like you are used to in OO it can be done with a GHC extension, but i think it might be more constructive for you to get used to doing things the functional way first
07:08:10 <Toxaris> mopped: note that a variant of this algorithm can be used to convert into monadic form, by replacing "let a = b in c" by "b >>= a -> c" in the third step
07:09:29 <geezusfreeek> bastl, to do what you are more used to, use the ExistentialQuantification extension and define data Parsed = forall a . Data a => Parsed a
07:10:11 <geezusfreeek> bastl, then, since the type of a is hidden behind Parsed, the caller cannot know anything about the type besides that it is an instance of Data
07:10:30 <geezusfreeek> bastl, but again, i highly recommend forgetting this exists for now
07:11:18 <alexeevg> forget that existential types exist!
07:11:27 <geezusfreeek> ^ (for now)
07:11:29 <knapr> give me a Functor!
07:11:54 <bastl> i like the functional way of doing it like doserj showed. but i run again and again against that wall "programming against interfaces" when writing my code
07:12:03 <alexeevg> polymorphic types polymorph
07:12:44 <dolio> Converting to monadic style gets you CPS 'for free' with the CPS monad, too. :)
07:15:29 <doserj> bastl: there is also a way without any GHC extension. instead of returning the parsed data, return a "dictionary", or "interface" of functions that operates on that data.
07:17:43 <asgaroth> Is it just me or is the wikibooks article on cps not very clear? Can anyone perhaps suggest better material?
07:18:04 <bastl> doserj: also a very nice idea. any example? i cant fully imagine it.
07:18:34 <alexeevg> asgaroth: "Definitional Interpreters" by Reynolds may be not the fastest, but a very nice way to get your head around CPS
07:18:36 <Cheshire> asgaroth, I just updated it yesterday
07:18:53 <alexeevg> PLAI is good too
07:19:18 <Cheshire> asgaroth, were you referring to this? http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
07:19:47 <qed> callcc
07:19:50 * qed bangs head against the wall
07:19:58 <qed> call with current continuation makes my brain hurt
07:20:10 <asgaroth> Cheshire: yes. the callCC section seems a bit unclear to me, but perhaps I just need to read it again.
07:20:20 <Cheshire> asgaroth, ok I haven't updated the cwcc section
07:20:29 <qed> asgaroth: it's really a difficult thing to understand tbh
07:20:33 <qed> but thats just my opinion
07:20:42 <Cheshire> asgaroth, we should improve this article
07:21:12 <doserj> bastl: think of the functions that you want to apply to your parse result. (Like the methods of the class Data). Then return a tuple of these functions, partially applied to the parsed data.
07:21:54 <asgaroth> Okay, I'll try to get my head around the concept a bit longer first, so my complaint might be premature.
07:22:09 <Cheshire> asgaroth, the article is rubbish...
07:22:23 <Cheshire> asgaroth, I hope my bit in Starting Simple is ok but the rest needs rewritten too
07:22:33 <Toxaris> dolio: I would say that the Cont monad gives you continuations, but not CPS. Cont is about direct style, enriched with call/cc.
07:22:42 <asgaroth> Yes, the starting examples are fine, callCC is where it got worse
07:23:04 <Cheshire> Toxaris, check the Starting Simple section...
07:23:12 <Cheshire> Toxaris, the Cont monad is exactly the same as CPS
07:23:28 <dolio> I don't really follow.
07:23:49 <Cheshire> compare pythagoras'cont with pythagoras'cps
07:23:56 <dolio> If you do a monadic style conversion, and then inline the definitions for Cont, you'll get the same thing you came up with doing a CPS transform.
07:24:45 <dolio> At least, I'm relatively sure.
07:24:59 <dolio> Modulo newtype wrappers, of course.
07:25:11 <Toxaris> dolio: my definition (which is directly stolen from Olivier) of CPS includes "all calls are tail calls", which is not true for a Cont program before inlining the Cont stuff
07:25:39 <Cheshire> Toxaris, did you see it here ? http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
07:25:59 <Toxaris> Cheshire: see what?
07:26:21 <alexeevg> dolio: I guess Toxaris point is that CPS is the implementation technique for Cont monad, if Cont type constructor was abstract, Cont monad could be implemented directly in Haskell RTS
07:26:21 <Cheshire> Toxaris, compare pythagoras'cps with pythagoras'cont
07:26:29 <Cheshire> if you restrict use of cont monad to:    <name> <- <function> <variable> ...; ...; return <name>  then it's exactly equivalent to CPS
07:26:50 <alexeevg> and writing code in CPS is different from writing in Cont monad
07:27:07 <Cheshire> alexeevg, but it's not
07:27:08 <Toxaris> Cheshire: but if you desguar do, you find that only the >>= calls are tail cails
07:27:39 <knapr> why isnt there short syntax for Data.Maps ?
07:28:00 <alexeevg> Cheshire: what exactly is not?
07:28:00 <Toxaris> there is no different from a programming perspective (its "programming with continuations"), but from my POV, its not "programming in CPS", because continuation passing *style* means a specific source code format.
07:28:04 <knapr> {"hello": 1, "transfer": 12}
07:28:49 <knapr> not is not not not
07:28:58 <DukeDave> /j #ghc
07:29:01 <knapr> therefore not is not (not not)
07:29:14 <dolio> fromList [("hello", 1), ("transfer", 12)]
07:31:16 <Toxaris> e.g. if you want to do another source code transformation which needs CPS to begin with, you need real CPS, not something equivalent after inlining and partial beta reduction
07:32:52 <Axman6> heh, from Gofer: undefined | False      = undefined
07:33:01 <Cheshire> Toxaris, how do you describe the relation of Cont and CPS though?
07:33:10 <Axman6> > let undefined' | False      = undefined' in undefined'
07:33:11 <lambdabot>   * Exception: /tmp/5204137910320780369:71:36-71: Non-exhaustive patterns in ...
07:33:25 <Cheshire> @hackage cc-delcont
07:33:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cc-delcont
07:33:53 <dolio> The appeal of converting to monadic style first would be to make the steps simpler to digest.
07:34:15 <dolio> First you convert to monadic style which specifies the ordering of operations...
07:34:54 <dolio> cons (f x) (map f xs) ==> f x >>= \y -> map f xs >>= \ys -> return (cons y ys) -- or something like that.
07:35:29 <Toxaris> dolio: yeah that makes sense, especially since we cannot express ordering of operations with lets in Haskell. on the other hand, we cannot do that in monadic style, either, because it depends on the strictness of the respective >>=.
07:35:36 <dolio> Then you use the definition of return and (>>=) to fill in the details of what CPS actually is.
07:36:18 <mopped> Can anyone reccomend a book for the introduction into the foundations of programming/multiple paradigms? Ideally something accessible like sipser's theory of computation for somebody pre-uni
07:36:54 <Cheshire> if you go to Cont via CPS:   cons (f x) (map f xs)  ==>  f x $ \f'x -> map f xs $ \map'f'xs -> cons f'x map'f'xs _  ==>  do f'x <- f x; map'f'xs <- map f xs; cons f'x map'f'xs
07:37:09 <zachk> mopped: if you want a good haskell book that starts out easy (and ends beyond my ability) get a copy of "programming in haskell"
07:37:09 <dolio> That's the way Dybvig, Sabry and Peyton-Jones explain the delimited CPS transform in their paper on the subject.
07:37:16 <dolio> For instance.
07:37:35 <Cheshire> mopped, CTM
07:37:49 <Toxaris> dolio: on yet another hand, Olivier Danvy uses a combine operation in his technical report cited above to explain his three-step algorithm, and different choices for combine yield direct style or CPS, and I guess that his combine is just your >>= here.
07:38:03 <mopped> CTM?
07:38:13 <Cheshire> @go CTM book
07:38:15 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
07:38:15 <lambdabot> Title: Concepts, Techniques, and Models of Computer Programming
07:38:20 <Toxaris> dolio: with >>= from Ident or Cont.
07:38:54 <mopped> thanks
07:39:32 <dolio> Toxaris: What paper?
07:39:58 <dolio> He has quite a few on CPS. :)
07:40:09 <Toxaris> dolio: Olivier Danvy, Three Steps for the CPS Transformation, 1991
07:40:25 <DukeDave> In ghci is there a way to open the definition of a function in your editor? (By entering only the function name)
07:41:13 <Saizan> open?
07:41:41 <matthew-_> mathsy people, or at least people with more formal clue than me. Which is just about everyone. Paper says: "Submitted in part ful¯lment of the requirements for the degree of
07:41:44 <matthew-_> Doctor of Philosophy in Computing of the University of London and
07:41:54 <matthew-_> that would be the wrong paste
07:41:54 <matthew-_> sorry
07:42:21 <DukeDave> Saizan: Open the file containing the definition
07:43:07 <matthew-_> "Recursive types are required to be contractive, containing no subexpressions of the form \mu X.\mu X_1. ... .\mu X_n . X"
07:43:19 <matthew-_> now, I understand what that means, but why would it be the case?
07:43:21 <Saizan> DukeDave: ah, i don't think so then
07:43:29 <conal> DukeDave: do you have a preferred editor?  maybe what you want is covered by emacs or vi packages.
07:43:33 <redditbot> Happstack 0.1 Released (one day early!)
07:44:23 <conal> odd that ghci doesn't have this feature.  ":i" shows that it knows source locations
07:46:17 <zachk> dukedave: i do not think so :-/
07:47:34 <dolio> Toxaris: Anyhow, of course in general (>>=) doesn't guarantee order of evaluation for every monad. But, it does give you some sort of ordering, the meaning of which may be monad dependent.
07:47:47 <dolio> And in the case of CPS, it is sort of an evaluation order.
07:48:04 <DukeDave> Ah, I'm sure there used to be (still is?) such a feature in hugs
07:48:22 <DukeDave> conal: Yeah that was my escape plan, I'll investigate now
07:49:36 <dolio> In fact, that's actually led me to like programming with continuations in monadic style somewhat more than the usual direct style.
07:49:36 <Cheshire> matthew-_, what context
07:49:59 <Toxaris> dolio: which kind of "direct style" do you mean?
07:50:03 <alexeevg> anyway one can argue that CPS-transform is different from CPS itself, and Cont monad is a way to get CPS transform automatically and write in sort of direct style
07:50:30 <Toxaris> dolio: I agree with alexeevg, Cont is like direct style, while explicit continuation passing is CPS
07:50:32 <Cheshire> I'm amazed that it's so difficult to pin down the relation between CPS and Cont
07:50:37 <matthew-_> Cheshire: well it's pi like
07:50:42 <dolio> Because the ordering of expressions is explicit, unlike in something like "let x = callcc foo in bar (callcc baz) (quux (callcc quuux))
07:50:48 <matthew-_> Cheshire: but a typing for pi
07:51:06 <Cheshire> "pi"?
07:51:16 <matthew-_> calculus
07:51:49 <matthew-_> Cheshire: later on they're talking about expanding the recursions and they state: "Because we assume recursive types are contractive, the expansion terminates"
07:51:58 <alexeevg> dolio: in every language that supports direct style ordering is explicit as well because of eager evaluation
07:52:07 <matthew-_> which kinda makes me think they're requiring it to be total
07:52:18 <dolio> alexeevg: I know. But it isn't as obvious from the way the code is written.
07:53:05 <Toxaris> dolio: if you use more combinators then >>= and return, you move nearer to applicative style again, but I see what you say.
07:53:14 <alexeevg> dolio, can we agree that monadic style in Haskell is the closest analog to direct style in Scheme?
07:53:34 <Cheshire> alexeevg, well the effect of continuations can reveal which order i.e. scheme is evaluation the parameters in (p1 p2 p3 ...)
07:54:02 <dolio> Yes, although as Toxaris says using applicative combinators is probably close.
07:54:05 <dolio> Closer, even.
07:54:28 <dolio> Really, I don't mind the order of evaluation of parameters thing. The one that gets me is let expressions.
07:55:47 <dolio> Because inlining the expression changes what happens.
07:55:57 <leimy> let expressions are lambdas in disguise right? :-)
07:55:58 <dolio> Or, could.
07:56:47 <alexeevg> leimy: sort of, but very different in language with type inference
07:57:03 <dolio> But, due to the monadic types and required combinators, you can inline monadic style expressions using continuations freely.
07:57:05 <leimy> Yeah I figured they're not exactly equivalent
07:57:27 <dolio> (Or CSE.)
07:57:44 <alexeevg> you can think of them as sugar on top of lambdas in Scheme, but in Haskell they are different, only let-bound values can be polymorphic
07:57:51 <alexeevg> I mean, in Haskell-98
07:59:12 <dolio> You could model rank-1 lets with lambdas with rank-2 types.
07:59:14 <dolio> And so on.
08:02:12 <alexeevg> dolio: losing type inference, yes
08:02:56 <dolio> Actually, rank-2 is allegedly decidable.
08:03:15 <dolio> Rank-3 and above are not.
08:04:47 <dolio> Anyhow, if what you're doing is turning lets into lambdas, you could do inference, and generate rank-2 lambdas from the lets (and only the lets).
08:05:35 <alexeevg> nice :)
08:08:55 <uccus> hpaste is down?
08:09:53 <uccus> quick question: I have a predicate like palindrome = x == reverse x
08:10:01 <uccus> why doesn't this work?
08:10:17 <uccus> answer = [x * y | x <- [1..999], y <- [1..999], palindrome (show x)]
08:10:26 <uccus> its giving me everything
08:10:27 <PeakerWork> uccus: what's "x" in palindrome?
08:10:42 <Cheshire> uccus, you probably just made a mistake
08:10:42 <uccus> oh palindrome x = x == reverse x
08:10:55 <Cheshire> uccus, like writing x instead (x * y) or something
08:11:13 <uccus> sheesh don't think so
08:11:30 <Cheshire> what were you trying to compute?
08:11:40 <wjt> > take 10 [(x,y) | x <- [1..999], y <- [1.999]]
08:11:40 <uccus> euler problem 4 :p
08:11:41 <lambdabot>   [(1,1.999),(2,1.999),(3,1.999),(4,1.999),(5,1.999),(6,1.999),(7,1.999),(8,1...
08:11:46 <wjt> > take 10 [(x,y) | x <- [1..999], y <- [1..999]]
08:11:47 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
08:11:51 <Cheshire> I don't know what that is
08:12:02 <uccus> project euler problem 4
08:12:09 <Cheshire> I don't know what that is..
08:12:42 <uccus> that online competition thingie... okay anyway, the question is, I can get the generators to work, but the predicate (palindrome) doesn't seem to filter anything
08:12:52 <uccus> take 10 [(x,y) | x <- [1..999], y <- [1..999], x == y]
08:12:53 <wjt> uccus: are you sure it's giving you *all* the numbers? See above that you'll get the first 999 values of y before x becomes 2, so you'll get ~10,000 values (because all one-digit values of x are palindromes) before you get to any that fail the guard
08:12:57 <Gracenotes> @hoogle [a] -> [([a], [a])]
08:12:57 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
08:12:57 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
08:12:57 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
08:12:58 <dolio> uccus: Because you should have written "palindromw (show (x*y))" instead?
08:13:03 <Cheshire> uccus, what are you trying to compute?
08:13:06 <uccus> ? take 10 [(x,y) | x <- [1..999], y <- [1..999], x == y]
08:13:21 <uccus> > take 10 [(x,y) | x <- [1..999], y <- [1..999], x == y]
08:13:22 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
08:13:40 <uccus> aargh must be a stupid stupid mistake somewhere... :(
08:13:41 <Gracenotes> uccus: that does checks for every possible combination of x and y
08:13:54 <Cheshire> uccus, that's what I said but then you said it wasn't a mistake
08:14:02 <uccus> hahaha sorry :p
08:14:21 <Cheshire> uccus, The important question is:  what are you trying to compute?
08:14:33 <uccus> head of that list
08:14:47 <Cheshire> ok I don't know what 'that list' is
08:14:56 <uccus> the highest number that is a palindrome that is the product of two 3-digit numbers
08:14:59 <Cairnarvon> http://projecteuler.net/index.php?section=problems&id=4
08:15:01 <Gracenotes> finding the highest palindromic product of a number from 1 to 999 with another number from 1 to 000
08:15:03 <Cheshire> uccus, aha!
08:15:06 <Gracenotes> er, 999. product euler
08:15:12 <Cheshire> uccus, THAT is what I was trying to extract from you
08:15:20 <uccus> I understand
08:15:27 <Cheshire> uccus, so the product x * y should be a palindrome
08:15:38 <Cheshire> uccus, maybe you wrote x instead (x * y) or something
08:15:39 <uccus> err thanks
08:15:49 <uccus> precisely [dies of shame]
08:15:58 <Cheshire> uccus,but yous hould also do [100.999]
08:16:00 <Cheshire> uccus,but yous hould also do [100..999] ***
08:16:08 <Gracenotes> uccus: also, you might find the following function useful :)
08:16:10 <Gracenotes> @type maximum
08:16:12 <lambdabot> forall a. (Ord a) => [a] -> a
08:16:15 <uccus> yes I suppose
08:16:20 <Cheshire> uccus, or even better,
08:16:22 <uccus> yes I've already done it
08:16:32 <Cheshire> [999,998..100]
08:17:14 <Cheshire> > head (do x <- [99,98..10]; y <- [x,x-1..10]; return (x,y))
08:17:16 <lambdabot>   (99,99)
08:17:17 <uccus> I tried that for some reason it didn't go through (again, must be something silly I did) so I defined list n = n: (list (n-1)) and it works
08:17:21 <Cheshire> > (do x <- [99,98..10]; y <- [x,x-1..10]; return (x,y))
08:17:22 <lambdabot>   [(99,99),(99,98),(99,97),(99,96),(99,95),(99,94),(99,93),(99,92),(99,91),(9...
08:17:36 <Cheshire> > (do x <- [9,8..1]; y <- [x,x-1..1]; return (x,y))
08:17:38 <lambdabot>   [(9,9),(9,8),(9,7),(9,6),(9,5),(9,4),(9,3),(9,2),(9,1),(8,8),(8,7),(8,6),(8...
08:17:55 <uccus> what about [(x, y) | x <- [9, 8 .. 1], y <- [9, 8, .. 1]]
08:18:03 <uccus> > [(x, y) | x <- [9, 8 .. 1], y <- [9, 8, .. 1]]
08:18:04 <lambdabot>   <no location info>: parse error on input `..'
08:18:07 <SamB_irssi> @pl (\ctor -> zip (ctorFields ctor) (ctorTypes ctor))
08:18:07 <lambdabot> liftM2 zip ctorFields ctorTypes
08:18:13 <uccus> yep that's what I got
08:18:19 <SamB_irssi> @pl concatMap (\ctor -> zip (ctorFields ctor) (ctorTypes ctor)) foo
08:18:19 <lambdabot> liftM2 zip ctorFields ctorTypes =<< foo
08:18:47 <Cheshire> uccus, y <- [x, x-1 .. 1]
08:19:05 <uccus> yeah, inside a list comprehension, it should work?
08:19:07 <sbahra> You are misreading the problem uccus.
08:19:21 <uccus> really?
08:19:22 <Cheshire> uccus, yes
08:19:25 <sbahra> I think so. :)
08:19:28 <SamB_irssi> @pl nub $ concatMap (\ctor -> zip (ctorFields ctor) (ctorTypes ctor)) foo
08:19:28 <lambdabot> nub (liftM2 zip ctorFields ctorTypes =<< foo)
08:19:28 <Cheshire> uccus, except I don't really use list comprehensions
08:19:29 <uccus> >  [(x, y) | x <- [9, 8 .. 1], y <- [9, 8, .. 1]]
08:19:30 <lambdabot>   <no location info>: parse error on input `..'
08:19:38 <Cheshire> uccus, try y <- [x, x-1 .. 1]
08:19:38 <sbahra> > let palindrome x = reverse x == x in maximum [x * y | x <- [100 .. 999], y <- [100 ..999], palindrome $ show (x * y)]
08:19:41 <lambdabot>   906609
08:19:42 <uccus> okay... do notation will do
08:20:37 <sbahra> uccus, you're looking for the largest palindrome that is the product of any 2 3-digit numbers.
08:21:06 <uccus> I see what you mean... the head will have 999 as a product
08:21:17 <sbahra> Ah, Cheshire already pointed this out.
08:21:27 <uccus> must use maximum... thanks goes to both of you
08:21:38 <Gracenotes> :\
08:21:47 <sbahra> uccus, if you want to learn Haskell, might be helpful to write your own version of maximum.
08:22:29 <uccus> umm yeah I suppose to learn haskell I might as well try to do it completely differently
08:22:35 <sbahra> Cheshire, why don't you use list comprehensions?
08:22:58 <Cheshire> less expressive
08:23:08 <sbahra> But sometimes just enough.
08:23:19 <uccus> even with the added goodies in GHC 6.10?
08:23:33 <mm_freak> is the unfoldr function the most general anamorphism on haskell lists?
08:24:19 <dolio> Yes. It's the universal one.
08:25:02 <Gracenotes> there was an unfoldl written a few days ago. It did use reverse a few times, though :)
08:26:21 <dolio> unfoldl f = go [] where go l s = case f s of Nothing -> l ; Just (e,s') -> go (e:l) s'?
08:26:49 <uccus> @sbahra: would myMax = foldl1 max -- do?
08:26:50 <lambdabot> Unknown command, try @list
08:27:00 <uccus> sbahra: would myMax = foldl1 max -- do?
08:27:43 <sbahra> uccus, if you write your own foldl1, why not? :-P
08:28:59 <lilac> > let unfoldl f a = go (f a) [] where go Nothing = id; go (Just (x, a)) = go (f a) . (x:) in unfoldl (\n -> if n > 10 then Nothing else Just (n, n+1)) 0
08:29:01 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
08:29:42 <dolio> I'm not sure about that definition, though. It's not guarded corecursion.
08:29:48 <dolio> At least, in that form.
08:29:50 <Toxaris> uccus: whats the point of the y?
08:30:01 <lilac> > let unfoldl f = go [] where go l s = case f s of Nothing -> l ; Just (e,s') -> go (e:l) s' in unfoldl (\n -> if n > 10 then Nothing else Just (n, n+1)) 0
08:30:02 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
08:30:08 <uccus> which y?
08:30:09 <Toxaris> uccus: hmm sorry, I was somewhere back in time :)
08:30:17 <Cheshire> :t let unfoldWhich f o = let go Nothing l = l ; go (Left (x,y)) l = x : go (f y) l ; go (Right (x,y)) l = go (f y) (x : l) in go (f o) [] in unfoldWhich
08:30:18 <lambdabot>     Couldn't match expected type `Maybe t'
08:30:18 <lambdabot>            against inferred type `Either a b'
08:30:18 <lambdabot>     In the pattern: Left (x, y)
08:30:33 <Cheshire> :t let unfoldWhich f o = let go Nothing l = l ; go (Just (Left (x,y))) l = x : go (f y) l ; go (Just (Right (x,y))) l = go (f y) (x : l) in go (f o) [] in unfoldWhich
08:30:34 <lambdabot> forall t t1. (t -> Maybe (Either (t1, t) (t1, t))) -> t -> [t1]
08:30:34 <dolio> I mean, obviously it's not productive.
08:31:03 <dolio> > let unfoldl f a = go (f a) [] where go Nothing = id; go (Just (x, a)) = go (f a) . (x:) in unfoldl (\x -> Just (x, x+1)) 1
08:31:21 <lambdabot>   thread killed
08:31:49 <dolio> So it's not definable in a total type theory.
08:31:51 <uccus> no worries, but foldl1 is easy. fold1 _  [] = error "Oops"; fold1 _ [x] = x; fold1 f (x:xs) = f x (fold1 f xs)
08:31:57 <lilac> > let unfoldlr b f a = go (f a) [] where go Nothing = id; go (Just (x, a)) = if b then go (f a) . (x:) else (x:) . go (f a); f = (\n -> if n > 10 then Nothing else Just (n, n+1)) in (foldlr True f 0, foldlr False f 0)
08:32:20 <Cheshire> uccus, isn't that foldr1 ?
08:32:39 <uccus> for max there shouldn't be any difference :)
08:34:14 <Ferdirand> if you disregard performance, that is
08:34:30 <lilac> dolio: given that unfoldl is reverse unfoldr, and unfoldr produces codata, that's hardly a surprise :)
08:35:09 <mm_freak> thanks
08:35:41 <asgaroth> I have a question about this algorithm: http://haskell.org/haskellwiki/The_Knights_Tour#Using_Continuations Is my understanding correct that it is much faster because it (, among other things) sorts the list of successors by the count of successors each one if them has?
08:35:58 <asgaroth> *of them
08:36:02 <mm_freak> myUnfold :: (a -> Bool) -> (a -> a) -> a -> [a]
08:36:29 <mm_freak> myUnfold p f x = if p x then x : myUnfold p f (f x) else []
08:36:36 <mm_freak> that's just as general as unfoldr, isn't it?
08:37:31 <Toxaris> mm_freak: is that: myUnfold p f = takeWhile p . iterate f
08:37:47 <mm_freak> Toxaris: indeed
08:38:36 <mm_freak> hmm, unfoldr is more general
08:38:41 <Cale> Perhaps there ought to be a map as well.
08:39:04 <Cale> and then they are roughly equivalent.
08:39:38 <mm_freak> myUnfoldr p m f = map m . takeWhile p . iterate f
08:39:45 <mm_freak> like so?
08:39:48 <Cale> yeah
08:40:08 <Cale> There are some things which are easy with one and awkward with the other though.
08:41:04 <Cale> I find most of the times I really want to use unfoldr fit this map/takeWhile/iterate pattern better.
08:41:23 <Cale> But implementing the normal unfoldr in terms of it is awkward.
08:41:38 <Cale> Whereas going the other way is a bit easier.
08:41:44 <mm_freak> hmm
08:42:00 <mm_freak> i'm interested only in the possibility
08:42:27 <JenniferB2> Holy shit.. 670 people in haskell chat room ? what is it used for ? taking a class now, but truly surprised! Does anyone like it ?
08:42:32 <hasky> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1197#a1197 , hello, can somebody explain me the smaller and bigger.. and whats that "<-"
08:42:33 <lilac> unfoldr f = map (fst . fromJust . f) . myUnfold (isJust . f) (snd . fromJust . f)
08:42:58 <lilac> myUnfold p f = unfold (\x -> if p x then Just (f x) else Nothing)
08:43:02 <opqdonut> JenniferB2: it's a programming language, used by programmers :)
08:43:12 <JenniferB2> I know!
08:43:13 <Tobsan> JenniferB2: yes, everyone likes haskell!
08:43:27 <lilac> JenniferB2: at least, (almost?) everyone in here likes it
08:43:33 <redditbot> More n-bodies speedups - Data.Random
08:43:33 <redditbot> koweycode: practical quickcheck (wanted)
08:43:33 <redditbot> Seeking advice on software licensing
08:43:40 <mm_freak> lilac: with the map being outside of the myUnfold, it's not really defined in terms of myUnfold
08:43:43 <Toxaris> JenniferB2: Haskell is a programming language, see haskell.org. Its great because it allows you to write better, safer and more beautiful programs with less typing and more thinking.
08:43:43 <Tobsan> JenniferB2: are you taking the class at chalmers?
08:43:58 <JenniferB2> LTH
08:44:03 <maltem> hasky: you'd want to look up "list comprehensions"
08:44:04 <Tobsan> oh i see
08:44:04 <mm_freak> as Cale pointed out, this is going to be awkward
08:44:05 <JenniferB2> funktions programmering :)
08:44:41 <JenniferB2> Tobsan, I've heard it's the first class in chalmers .. is that really true ?
08:45:22 <Tobsan> JenniferB2: yes.
08:45:26 <Toxaris> hasky: [y | y <- xs, y < x] means: return the list of all y, with y contained in xs, and y < x
08:45:34 <JenniferB2> before java ?
08:45:35 <lilac> mm_freak: true, you can define map in terms of unfoldr and foldr, but not in terms of unfoldr and myUnfold (i htink)
08:45:39 <Tobsan> JenniferB2: yes
08:45:44 <mm_freak> in fact, i have no idea how to implement unfoldr in terms of myUnfold…  somehow i'd need to tear apart the unfolding function into predicate and iteration
08:45:48 <JenniferB2> damn, so hardcore
08:46:04 <Toxaris> hasky: so for example, [y | y <- [5, 4, 1, 2, 9, 0], y < 2] would return [1, 2, 0].
08:46:09 <Tobsan> JenniferB2: well nobody have ever coded haskell before, so everyone is at the same level
08:46:14 <alexeevg> JenniferB2: learning Haskell before Java may be easier
08:46:18 <jacobian> Has anyone heard of a term calculus that includes an operator that does termination recognition?
08:46:19 <lambdabot>   thread killed
08:46:23 <JenniferB2> well, I guess that is good point
08:46:25 <asgaroth> That's a bit sadistic, since being forced to use java after learning haskell is torture
08:46:29 <Cale> JenniferB2: It is by far my favourite programming language
08:46:39 <beelsebob> @bot
08:46:40 <lunabot>  :)
08:46:45 <athos> :)
08:46:46 <athos> hehe
08:46:46 <beelsebob> lambdabot died again then?
08:46:54 <lilac> mm_freak: map f = unfoldr (\k -> case k of x:xs -> Just (f x, xs); [] -> Nothing)
08:46:57 <Cale> JenniferB2: It has a good blend of theoretical purity and practical aspects
08:47:12 <lilac> mm_freak: i /think/ you can do that case analysis with a foldr
08:47:27 <mm_freak> haskell is my favorite language, too, but i'm not too antipathetic to other languages, as long as they allow closures
08:47:38 <mm_freak> however, the average programmer doesn't understand my code =)
08:47:50 <Cale> First class functions are more important than closures to me ;)
08:48:07 * Cale is a terminology nitpick about that ;)
08:48:14 <JenniferB2> Hmm, interesting..  but many languages are functional nowadays.. and haskell seems so messy and complex to me.. but I just started so I should say too much.. but not really happy about it
08:48:27 <lstor> JenniferB2: You will be :)
08:48:32 <beelsebob> JenniferB2: your opinion will change
08:48:34 <lilac> mm_freak: something like: \ifNull -> foldr (\x (_,xs) -> ((x,xs), x:xs)) (ifNull, [])
08:48:41 <Toxaris> Cale: so c is ok, since pointers to functions are not different from pointers to data?
08:48:43 <JenniferB2> is it used in the enterprise world ?
08:48:46 <beelsebob> Haskell is one of the cleanest and least complex languages out ther
08:48:47 <beelsebob> there*
08:48:59 <Cheshire> Jennifer82, yeah some aspects are horrible -- mostly it is very simple and uniform though (other than some odd design desicions)
08:49:00 <asgaroth> JenniferB2: yep, see the Haskell in the industry page on haskell.org
08:49:01 <ik> "haskell is hard until you realize that it isn't"
08:49:11 <Cale> Toxaris: No, functions are not properly first class in C.
08:49:24 <mm_freak> lilac: i think, map f = myUnfold null head tail []
08:49:41 <mm_freak> oh well
08:49:46 <mm_freak> lilac: i think, map f = myUnfold (not . null) head tail []
08:49:47 <mm_freak> =)
08:50:17 <Cale> Toxaris: The thing which I'm nitpicking about is not the fact that functions capture the values of variables in lexical scope when constructed, but that "closure" is the name of an implementation mechanism for this behaviour, and not the behaviour itself.
08:50:23 <lilac> mm_freak: i think you should use 'f' somewhere in the definition of 'map' :)
08:50:34 <jpcooper> is there a function to insert into a list only if the element doesn't already exist?
08:50:40 <mm_freak> lol
08:50:48 <lilac> @type (?myUnfold :: (a -> Bool) -> (a -> a) -> a -> [a]) (not . null) head tail []
08:50:51 <sanity-_> a question has been bugging me for a while about Haskell: when Haskell represents graphs, is the internal representation efficient?  does Haskell have some way to refer to a variable with a pointer?  if not, how can a graph be represented efficiently?
08:50:56 <mm_freak> lilac: i think, map f = myUnfold (not . null) (f . head) tail
08:51:03 <mm_freak> =)
08:51:07 <MyCatVerbs> jpcooper: IIRC yes. In the Prelude there're a couple of functions that use lists like sets.
08:51:09 <lilac> mm_freak: f . head is not a -> a
08:51:11 <mm_freak> the [] was superfluous
08:51:12 <Cale> sanity-_: A Data.Map from vertices to sets of vertices is good.
08:51:13 <Toxaris> sanity-_: in Haskell, all values are referred to via pointers
08:51:26 <mm_freak> lilac: it's a -> b, just as supposed
08:51:32 <rwbarton> > "abcde" `union` "d"
08:51:33 <sanity-_> Toxaris: right, but can multiple pointers point to the same value?
08:51:36 <lilac> mm_freak: myUnfold :: (a -> Bool) -> (a -> a) -> a -> [a]
08:51:37 <jpcooper> MyCatVerbs, I couldn't find one in Data.List
08:51:39 <Toxaris> sanity-_: yes.
08:51:44 <rwbarton> , "abcdddeee" `union` "d"
08:51:46 <lunabot>  "abcdddeee"
08:51:47 <sanity-_> Toxaris: how?
08:51:50 <rwbarton> , "abcdddeee" `union` "h"
08:51:51 <lunabot>  "abcdddeeeh"
08:51:54 <Cale> sanity-_: There are tricks to making cyclic data structures, but that's a red herring solution.
08:51:57 <Toxaris> sanity-_: let x = 42 in (x, x) -- only one 42 here
08:51:58 <rwbarton> jpcooper: ^^
08:52:05 <mm_freak> lilac: myUnfold p m f = map m . takeWhile p . iterate f
08:52:16 <mm_freak> :t \p m f -> map m . takeWhile p . iterate f
08:52:18 <Cale> sanity-_: For a practical graph representation, you want to explicitly represent the adjacency structure.
08:52:30 <lilac> mm_freak: that's obviously equivalent though
08:52:31 <jpcooper> rwbarton, I'd rather not have to put the element in a list
08:52:32 <MyCatVerbs> jpcooper: you might be able to use Data.List.union.
08:52:32 <mm_freak> hey lambdabot, you there?
08:52:39 <sanity-_> Cale: right, but without pointers can it be navigated efficiently?
08:52:41 <jpcooper> I guess I'll do that though
08:52:41 <Toxaris> sanity-_: the problem is that you cannot distinguish (let x = 42 in (x, x)) from (42, 42)
08:52:44 <Cale> sanity-_: yes
08:52:46 <MyCatVerbs> jpcooper: just wrap the other argument in a single-element list.
08:52:56 <Cale> sanity-_: Data.Map provides an efficient implementation of finite maps.
08:53:00 <mm_freak> lilac: it's not
08:53:10 <Cale> sanity-_: You can use one of those to map vertices to their sets of neighbours.
08:53:12 <jpcooper> MyCatVerbs, I thought of this but was wondering of a nicer way. I will use this
08:53:12 <mm_freak> \p m f -> map m . takeWhile p . iterate f :: (a -> Bool) -> (a -> b) -> (a -> a) -> a -> [b]
08:53:12 <sanity-_> Cale: you'd need to do a map lookup every time you traversed a vertex, right?
08:53:20 <Cale> sanity-_: yes, but those are efficient.
08:53:23 <lilac> mm_freak: (a -> a), (a -> Bool), (a -> b)   versus   (a -> Maybe (b, a)) ?
08:53:43 <MyCatVerbs> jpcooper: personally I'd just define the recursive thing myself. Also, if you're using lists as sets, please bear in mind that they're not necessarily going to be efficient for large numbers of elements. I presume you already know about Data.Set?
08:53:49 <Cheshire> sanity-_, I represent a graph like this:  f A = [B,C,D]; f B = [A,C]; f ...
08:53:53 <sanity-_> Cale: well, relatively so, not as efficient as traversing pointers in an OO language
08:53:54 <lilac> mm_freak: every triple of the former form gives rise to a function of the latter form
08:53:56 <jpcooper> MyCatVerbs, I didn't
08:53:59 <jpcooper> thanks
08:54:01 <Cale> sanity-_: Depends.
08:54:02 <mm_freak> lilac: i'm trying to find an alternative to unfoldr, which is equivalently general
08:54:16 <Cheshire> sanity-_, it's very useful for some algorithms
08:54:24 <lilac> mm_freak: then your unfold is "obviously" at least as general
08:54:30 <mm_freak> to prove myUnfold to be as general, i'm trying to define unfoldr in terms of it
08:54:39 <MyCatVerbs> jpcooper: ah! Data.Set defines a Set type. You can make Sets of anything that you can sort lists of. Decent time complexity bounds - pretty much everything's logarithmic. :)
08:54:46 <mm_freak> lilac: yeah, i'm very sure about that, but i'd like to prove it =)
08:54:53 <Cheshire> sanity-_, other times maybe you would use a mutable array of bits or whatever..
08:55:09 <jpcooper> MyCatVerbs, I'll do this if I need more speed
08:55:10 <Cale> sanity-_: Note that this representation gives you a persistent structure. When you, say, add a vertex to the graph, you can do so in logarithmic time, and still keep hold of the old version of the graph.
08:55:10 <Toxaris> sanity-_: sometimes, you can use arrays instead of Data.Map
08:55:20 <lilac> mm_freak: unfoldr f = map (fst . fromJust . f) . myUnfold (isJust . f) (snd . fromJust . f)
08:55:25 <sanity-_> Cale: i see
08:55:32 <lilac> mm_freak: except the map is now inside the unfoldr so it's
08:55:45 <lilac> mm_freak: unfoldr f = myUnfold (fst . fromJust . f) (isJust . f) (snd . fromJust . f)
08:56:05 <JenniferB2> any nice articles I can read on the benefits with haskell ?
08:56:14 <JenniferB2> or what functional programming is ?
08:56:15 <sanity-_> Cale: i guess I was wondering if Haskell had any direct way to represent cyclic datastructures, and it seems like they are "emulated" using maps - is that fair to say?
08:56:51 <Cale> sanity-_: Typically, yes. We have mutable arrays as well, but the philosophy of programming in Haskell tends to de-emphasise mutation.
08:56:54 <lilac> @type \f -> ?myUnfold (fst . fromJust . f) (isJust . f) (snd . fromJust . f) `asTypeOf` unfoldr f
08:57:04 <sanity-_> Cale: I understand, many thanks
08:57:24 <Cale> JenniferB2: Well, there's lots on the web...
08:57:33 <mm_freak> lilac:
08:57:34 <mm_freak> :t myUnfoldr
08:57:34 <mm_freak> myUnfoldr :: (b -> Maybe (Bool, b)) -> b -> [Bool]
08:57:38 <Cheshire> sanity-_, haskell lets you make cyclic data structures, that is not necessarily the best way to represent cyclic data structures thouh
08:57:43 <Cale> @where whyfp
08:57:48 <Cale> hmm...
08:57:51 <Cale> oh right...
08:57:52 <sanity-_> Cheshire: how?
08:58:05 <Cale> ah, I can't log in to lambdabot's machine again.
08:58:06 <pejo> JenniferB2, there's "why functional programming matters".
08:58:10 <Cale> JenniferB2: http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
08:58:13 <Cheshire> let object = (object,object) in object  gives you  #1=(#1#,#1#)
08:58:35 <Cale> http://www.haskell.org/haskellwiki/Why_Haskell_matters
08:58:45 <Cheshire> (which is a type error I suppose, but that's besides the point)
08:58:50 <mm_freak> @botsnack
08:58:51 <lunabot>  :)
08:58:52 <sanity-_> Cheshire: ok, but I'm not sure how you'd implement a cyclic graph with that
08:59:07 <mm_freak> , 1+1
08:59:09 <lunabot>  2
08:59:09 <Cale> JenniferB2: I'm not sure if that's exactly the sort of thing you're looking for...
08:59:11 <Cheshire> sanity-_, like everyone has already said several times: You wouldn't since it's not a useful representation
08:59:39 <lilac> @type \f -> ?myUnfold (fst . fromJust . f) (isJust . f) (snd . fromJust . f) `asTypeOf` unfoldr f
08:59:39 <Cale> > let ones = 1 : ones in ones
08:59:42 <lilac> forall a b. (?myUnfold::(b -> a) -> (b -> Bool) -> (b -> b) -> b -> [a]) => (b -> Maybe (a, b)) -> b -> [a]
08:59:48 <lilac> mm_freak: ^^ success?
08:59:58 <sanity-_> Cheshire: ok, I just thought you said that "haskell lets you make cyclic data structures"
08:59:59 <Cale> grumble... can someone bring up another lambdabot?
09:00:03 <jpcooper> I've got an infinite list made of asynchronous IO operations. Is there any way in which I can make the fold wait until the list is not empty?
09:00:08 <JenniferB2> I am looking for an article that sells me functional programmering
09:00:15 <Cheshire> sanity-_, I did say that, then I showed you how to do it
09:00:16 <jpcooper> or could someone recommend some common strategies for infinite IO lists and left fold?
09:00:21 <Cale> > let ones = 1 : ones in ones
09:00:22 <pumpkinbot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:00:31 <lilac> mm_freak: i think i'm missing the point of what you're trying to do here to be honest :)
09:00:33 <Cale> sanity-_: ^^ this list exists in constant space
09:00:35 <JenniferB2> But I think some of the ones you sent is pretty good
09:00:50 <PeakerWork> Cale: in GHC, particularly
09:00:56 <mm_freak> lilac: prove that myUnfold is just as general as unfoldr =)
09:00:59 <sanity-_> cale: ok, I think I see
09:01:13 <mm_freak> the easiest way is to implement unfoldr in terms of myUnfold
09:01:17 <Cale> sanity-_: By mutual recursion, you can define arbitrary graph structures.
09:01:20 <lilac> mm_freak: and which one is the myUnfold that you're talking about right now? i've seen 3 different type signatures
09:01:27 <sanity-_> cale: understood
09:01:45 <mm_freak> lilac: myUnfold p m f = map m . takeWhile p . iterate f
09:01:51 <Cale> sanity-_: However, it's impossible to normally distinguish them from infinite structures, so, that tends to be awkward.
09:01:54 <mm_freak> the others were not general enough
09:02:19 <Cale> sanity-_: It becomes tricky to know when algorithms should stop, unless you store vertex labels or something.
09:02:25 <PeakerWork> > let repeat x = 1 : repeat x in repeat 1 -- ghc will use O(N) space for this.   > let repeat x = rep ; rep = x:rep in repeat 1 -- O(1) for this
09:02:26 <pumpkinbot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:02:34 <lilac> @type \f -> ?myUnfold (isJust . f) (fst . fromJust . f) (snd . fromJust . f) `asTypeOf` unfoldr f
09:02:35 <pumpkinbot> forall a b. (?myUnfold::(b -> Bool) -> (b -> a) -> (b -> b) -> b -> [a]) => (b -> Maybe (a, b)) -> b -> [a]
09:02:48 <lilac> mm_freak: ^^ like that?
09:02:57 <Cale> sanity-_: And many transformations can turn them into truly infinite structures with little warning, so it takes some finesse to use properly.
09:03:24 <MyCatVerbs> jpcooper: oh BTW, next time you're after a function in Haskell, might I recommend you try this very awesome thing that Neill Mitchell wrote called Hoogle? http://www.haskell.org/hoogle/?hoogle=%28Eq+a%29+%3D%3E+a+-%3E+%5Ba%5D+-%3E+%5Ba%5D <- for the win!
09:03:33 <drhodes> JenniferB2: a good sell can be found at software engineering radio, (seradio.com (I think)) Simon Peyton-Jones has a ~40min conversation - very convincing.
09:03:37 <mm_freak> lilac: ah, at least the type fits =)
09:03:39 <MyCatVerbs> *Neil, even.
09:03:40 <jpcooper> MyCatVerbs, oh yes, I'd forgotten about that
09:03:44 <Cale> (of course, infinite structures aren't really so bad, because only the part you use will be constructed)
09:03:50 <Toxaris> lilac: can you do a operationally equivalent version (i.e. applying f only once to generate 1 element)
09:04:05 <mm_freak> lilac: and it works
09:04:11 <mm_freak> lilac: many thanks
09:04:20 <lilac> @check \f -> (\p m f = map m . takeWhile p . iterate f) (isJust . f) (fst . fromJust . f) (snd . fromJust . f) == unfoldr f
09:04:21 <pumpkinbot>   Parse error at "=" (column 15)
09:04:28 <lilac> @check \f -> (\p m f -> map m . takeWhile p . iterate f) (isJust . f) (fst . fromJust . f) (snd . fromJust . f) == unfoldr f
09:04:29 <pumpkinbot>       Overlapping instances for Show (b -> Maybe (a, b))
09:04:29 <pumpkinbot>        arising from ...
09:04:33 <lilac> :(
09:04:40 <drhodes> JenniferB2: http://www.se-radio.net/podcast/2008-08/episode-108-simon-peyton-jones-functional-programming-and-haskell
09:06:46 <mm_freak> lilac: you seem to have left out the asTypeOf part
09:07:10 <mm_freak> @src asTypeOf
09:07:11 <pumpkinbot> asTypeOf = const
09:07:17 <mm_freak> hmm
09:07:28 <lilac> mm_freak: that was just to make lambdabot assert their types matched :)
09:07:41 <mm_freak> ah, ok
09:07:59 <mm_freak> is it magic?  because with asTypeOf = const, this obviously doesn't work =)
09:08:12 <lilac> mm_freak: asTypeOf :: a -> a -> a; asTypeOf = const
09:08:18 <hellige> @ty const
09:08:19 <pumpkinbot> forall a b. a -> b -> a
09:08:20 <mm_freak> ah, yeah
09:08:22 <hellige> :)
09:14:11 <lilac> @type let myUnfold p m f = map m . takeWhile p . iterate f in \f x -> myUnfold isJust (fst . fromJust) (f . snd . fromJust) (f x)
09:14:12 <pumpkinbot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
09:14:45 <lilac> > let myUnfold p m f = map m . takeWhile p . iterate f in (\f x -> myUnfold isJust (fst . fromJust) (f . snd . fromJust) (f x)) (\n -> if n > 10 then Nothing else Just (n, n+1)) 0
09:14:46 <pumpkinbot>   [0,1,2,3,4,5,6,7,8,9,10]
09:14:51 <kyagrd> Can someone familliar with QuickCheck help me?
09:15:00 <lilac> Toxaris: there's an operationally equivalent version for you :)
09:15:30 <kyagrd> In the quickcheck manual there's an example of generating binary trees contstraining their size.
09:15:46 <lilac> unfoldr f x = myUnfold isJust (fst . fromJust) (f . snd . fromJust) (f x)
09:15:55 <opqdonut> a
09:15:57 <opqdonut> -a
09:16:02 <kyagrd> Is there an example something like when it is defined using lists such as
09:16:09 <lilac> opqdonut: "" to you too
09:16:16 <opqdonut>  
09:16:17 <opqdonut> indeed
09:16:49 <kyagrd> I'm having some trouble writing QuickCheck generators for "data Tree a = Node a [Tree]"
09:17:05 <mm_freak> @pl \f x -> f x x
09:17:05 <pumpkinbot> join
09:17:41 <lilac> kyagrd: do a <- arbitrary; xs <- arbitrary; return $ Node a xs
09:17:59 <lilac> (arbitrary :: Gen a => Gen (Tree a))
09:17:59 <kyagrd> lilac: I'm trying to write a sized version.
09:18:00 <Cheshire> does this 'arbitrary' diagonalize?
09:18:14 <lilac> kyagrd: hmm, that's a little more interesting :)
09:18:17 <roconnor> lilac: kyagrd needs to use sized
09:18:35 <roconnor> oops
09:18:38 <roconnor> too slow
09:18:42 <kyagrd> Using arbitrary over list argument kind of blows up the size too much
09:18:58 <DukeDave> Are there any cabal people around?
09:19:20 <kyagrd> There should be a standard way of doing this I hope sombody might have documented
09:19:32 <Toxaris> lilac: yeah cool. I was missing the fact that unfoldr applies f before returning the first result, while iterate does not. thanks.
09:19:38 <DukeDave> Oh noes, hpaste is down
09:19:46 <kyagrd> ahhhh
09:21:07 <DukeDave> Cabal fail: http://pastebin.com/m4492ea9d
09:21:29 <Toxaris> kygard: what about generating an arbitrary n of size s, then generating n arbitrary trees of size (s / n)?
09:21:49 <lilac> kyagrd: you could do something like: sized $ \n -> do a <- arbitrary; xs <- case n of {0 -> []; _ -> resize (n-1) arbitrary}; return (Node a xs)
09:22:02 <lilac> (using the size as a depth limit)
09:22:55 * lilac thinks the node count would grow as the factorial of the size using that method
09:23:01 <kyagrd> lilac: thanks ... I didn't thought of resize
09:23:11 <kyagrd> I'll try it out
09:23:25 <lilac> you may want to shrink the size faster, depending on your requirements
09:23:38 <roconnor> @hoogle resize
09:23:38 <pumpkinbot> Test.QuickCheck resize :: Int -> Gen a -> Gen a
09:23:38 <pumpkinbot> Text.XHtml.Frameset noresize :: HtmlAttr
09:23:38 <pumpkinbot> Text.XHtml.Transitional noresize :: HtmlAttr
09:23:42 <roconnor> @hoogle size
09:23:42 <pumpkinbot> Data.IntMap size :: IntMap a -> Int
09:23:42 <pumpkinbot> Data.IntSet size :: IntSet -> Int
09:23:42 <pumpkinbot> Data.Map size :: Map k a -> Int
09:23:48 <roconnor> @hoogle+
09:23:48 <pumpkinbot> Data.Set size :: Set a -> Int
09:23:48 <pumpkinbot> Text.XHtml.Frameset size :: String -> HtmlAttr
09:23:48 <pumpkinbot> Text.XHtml.Strict size :: String -> HtmlAttr
09:23:51 <roconnor> @hoogle+
09:23:52 <pumpkinbot> Text.XHtml.Transitional size :: String -> HtmlAttr
09:23:52 <pumpkinbot> Test.QuickCheck sized :: (Int -> Gen a) -> Gen a
09:23:52 <pumpkinbot> Foreign.Storable sizeOf :: Storable a => a -> Int
09:23:52 <lilac> @hoogle sized
09:23:53 <beelsebob> lilac: \n -> Node <$> arbitrary <*> case n of {0 -> []; resize (n-1) arbitrary}
09:23:54 <pumpkinbot> Test.QuickCheck sized :: (Int -> Gen a) -> Gen a
09:24:00 <roconnor> oh right
09:24:28 <lilac> beelsebob: i'd be inclined to use liftA2
09:24:50 <kyagrd> ahhhh those combinators again :)
09:24:59 <beelsebob> ahhhhh?
09:25:11 <beelsebob> oh no, it's an applicative, and I can't imagine that there's sequence involved?
09:27:13 <Toxaris> lilac: would you're arbitrary produce unbalanced trees?
09:27:19 <Toxaris> s/you're/your
09:28:52 <jnwhiteh> Can you have multiple patterns in a lambda function?
09:29:00 <pchiusano> @src negate
09:29:00 <pumpkinbot> negate x = 0 - x
09:29:07 <opqdonut> jnwhiteh: only by using case
09:29:14 <pchiusano> :t negate
09:29:16 <pumpkinbot> forall a. (Num a) => a -> a
09:29:17 <jnwhiteh> opqdonut: thanks
09:29:25 <opqdonut> there's a couple of proposed extensions for multi-pattern lambda
09:29:26 <opqdonut> s
09:29:30 <opqdonut> but no real consensus
09:29:34 <lilac> Toxaris: no. arbitrary on lists produces ones of length == size
09:29:38 <opqdonut> and no implementations afaik
09:30:00 <lilac> so on level i (from the bottom), each node has i children
09:30:15 <lilac> the 'case' is in fact redundant :-/
09:30:38 <Toxaris> I think one should "distribute" the size along the children
09:30:50 <Toxaris> so that the overall structure grows lineary with the size
09:31:01 <Toxaris> see also quickcheck manual, which proposes square root of the size for matrices
09:31:19 <Toxaris> *but* I think my idea of using (size / number of children) is wrong, because the children should not be even-sized
09:31:25 <pchiusano> has lambdabot been renamed pumpkinbot?
09:31:44 <kyagrd> "data Tree a = Node a [Tree]" for this kind of data type resizing by (n-1) is even not enough I had to do (n `div` 2) to get a reasonable 100 runs
09:32:17 <Toxaris> instead, we need distribute :: Int -> Int -> [Int], with length (distribute n x) == n and sum (distribute n x) == x
09:32:30 <Toxaris> oh, and it should be in Gen, of course
09:34:08 <pchiusano> jnwhiteh: you can always just have the body of the lambda be a case expression
09:35:56 <Toxaris> then one could do:   arbitrary = do n <- arbitrary; sizes <- sized (\s -> distribute n s); xs = mapM (\s -> resize s arbitrary) sizes
09:37:55 <Toxaris> kyagrd: the quickcheck manual section about binary trees uses (n `div` 2), by the way
09:39:06 <lilac> Toxaris: that's pretty simple. generate n random numbers from 0 to 1, and then scale them so the sum is x. if you get all 0s, try again ;-)
09:39:19 <ozy`> > map (`div` 0) [1..]
09:39:20 <pumpkinbot>   mueval: Prelude.read: no parse
09:39:20 <pumpkinbot>  mueval: [*** Exception: divide by zero
09:40:07 <conal> apfelmus: i just stumbled on your web site (http://apfelmus.nfshost.com/), which you mention is managed via pandoc & make.  nice!
09:41:14 <conal> apfelmus: how do you manage the consistent sidebar throughout?
09:41:22 <pumpkin> yay nearlyfreespeech!
09:41:25 <apfelmus> conal: hehe, yes it's quite nice
09:41:37 <apfelmus> conal: pandoc -B header.html
09:41:37 <conal> apfelmus: and how.  really elegant!
09:41:49 <apfelmus> conal: thanks :)
09:41:58 <conal> apfelmus: oh!  pandoc is so cool :)
09:42:37 <apfelmus> conal: yes, you can include arbitrary html before and after the main content
09:42:47 <roconnor> what is pandoc?
09:42:54 <apfelmus> @where pandoc
09:42:54 <pumpkinbot> http://sophos.berkeley.edu/macfarlane/pandoc/
09:43:15 <drhodes> pumpkin: when reading the terms and conditions to nearlyfreespeach, literally, a single tear dropped from my eye.
09:43:33 <pumpkin> in a good way?
09:43:44 <drhodes> yeah, they got a good thing.
09:44:27 <pumpkin> I like them a lot... have started using them less since I got my slice from slicehost (that's what pumpkinbot sits on) but they're still awesome
09:44:44 <Badger> ?botsnack
09:44:44 <pumpkinbot> :)
09:45:07 <apfelmus> wadler once mentioned nfs on his block, as they support as cgi scripting language
09:45:12 <apfelmus> *blog
09:45:21 <apfelmus> *support haskell
09:45:23 <conal> pumpkin: .org or .net ?
09:45:28 <pumpkin> net
09:45:44 <conal> thx
09:45:57 <pumpkin> :)
09:48:22 <BONUS> i use NFS for LYAH
09:48:33 <BONUS> i can't recommend them enough
09:48:46 <pchiusano> I have a question - is it possible to write a Num instance that works for any Num a => Applicative a
09:49:09 <conal> pchiusano: you can write the instance, but it'll overlap everything.
09:49:09 <ray> pumpkinbot .NET
09:49:11 <pumpkin> with flexible instances, I think, but it won't behave the way you want it probably
09:49:17 <mauke> pchiusano: http://mauke.ath.cx/stuff/haskell/fun.hs
09:49:54 <conal> pchiusano: i have such a thing ready for #include'ing, because i use that pattern so much.  i've been meaning to package & release but forgot.  now you've reminded me.
09:50:01 <pumpkin> ray? :o
09:50:17 <ray> it must be in F# or something
09:50:25 <conal> pchiusano: oh wait.  i misread.  or maybe you miswrote.
09:50:52 <conal> pchiusano: maybe you really mean: instance (Num a, Applicative f) => Num (f a) where ...
09:54:33 <pumpkin> ray: it's in haskell :P
09:55:23 <ray> haskell .NET
09:55:26 <ray> *nods*
09:55:54 <jkff> Hi people. Can you help me diagnose a memory leak? I'm running this program http://pastebin.com/d669580df giving it an archived 1Gb logfile, and it consumes about 1Gb RAM, although it seems to me that it should process the file lazily, and I can't find any place where the file contents might have been retained (heap profiling shows that byte arrays occupy the space).
09:57:09 <jkff> I tried retainer profiling but it only tells me that everything is retained by MAIN. I tried biographical profiling but "-hc -hbdrag,void" segfaults on my system.
09:58:24 <jkff> I even used S.copy to isolate matching parts of regexes. Also, the number of values in the Data.Map being generated is rather small, only a few tens of thousands.
09:59:08 <pchiusano> conal - yeah, I am not sure what I mean - i just notice myself creating a lot of types M a, where if a is a Num, I can make M a also a Num
09:59:09 <int-e> jkff: it looks like you're storing the whole file in the intermediate Data.Map (uid_modelMap)
09:59:13 <jkff> Also, when I don't use the groupMap function and simply decompress the file and do L.unlines etc., the thing runs in constant space
09:59:39 <jkff> int-e: Nope, the map is rather small, and the total length of strings in it is rather small, too. Only a small fraction of lines in the file match that regex.
09:59:45 <pchiusano> and it usually just involves lifting the operators, etc
09:59:55 <apfelmus> jkff: use a strict pair with foldl' ??
10:00:43 <apfelmus> I'm not sure, but I'd bet that the y in (x,y) isn't forced soon enough?
10:00:49 <jkff> apfelmus: Aaaargh! Thank you, I'll try it. My laziness-fu sucks.
10:01:26 <apfelmus> jkff: there's a package with Data.Strict.Pair or something, I think
10:02:27 <int-e> @type catMaybes . map
10:02:28 <pumpkinbot>     Couldn't match expected type `[Maybe a]'
10:02:28 <pumpkinbot>            against inferred type `[a1] -> [b]'
10:02:28 <pumpkinbot>     Probable cause: `map' is applied to too few arguments
10:02:48 <int-e> @type (catMaybes .) . map
10:02:49 <pumpkinbot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
10:02:58 <cads> hey, I've found this really old ruby code where I made a higher order function called takecat, to which you'd pass a number x, a function that takes numbers and returns strings, f, and an optional delimiter, defaulting to space. It was the equivalent of   takecat n f = (f 1) ++ fold (\s, x -> s ++ ' ' ++ f(x)) "" [2..n], and essentially called the string generating function n times and concatenated the results.
10:03:04 <cads> http://pastie.org/379457
10:03:16 <apfelmus> @hoogle Data.Strict
10:03:16 <pumpkinbot> module Data.STRef.Strict
10:03:16 <pumpkinbot> package strict
10:03:16 <pumpkinbot> package strict-concurrency
10:03:18 <jkff> apfelmus: Unfortunately, making everything in groupMap strict didn't help.
10:03:21 <cads> that is the code... please don't lose your lunches at the cutesiness
10:03:39 <apfelmus> jkff: So I lost that bet. ;)
10:03:39 <jkff> (I did groupMap xys = foldl' (\m (x,y) -> x `seq` y `seq` M.insertWith' (\[y] ys -> y `seq` ys `seq` (y:ys)) x [y] m) ...)
10:03:58 <apfelmus> jkff: it's usually a better idea to use a strict pair.
10:04:05 <apfelmus> jkff: no need to mess with seq
10:04:16 <lilac> cads: yowzer, that's /very/ cutesy
10:04:16 <apfelmus> so, either bang patterns
10:04:27 <apfelmus> jkff: \m (!x,!y) -> ...
10:05:04 <ray> cads: i think i'm getting diabetes!
10:05:11 <lilac> cads: it's like an injection of liquified love hearts straight into the eyeballs
10:05:14 <apfelmus> jkff: or Data.Strict.Tuple from the strict package
10:05:48 <cads> i was wondering if my takecat function could be better expressed in another way, essentially it's "generate n strings, paste them together *hey, you guys are supposed to be impartial god of the language, not peopel afraid of cooties :D
10:05:53 <jkff> apfelmus: Yeah. However, the leak remains :(
10:05:55 <rwbarton> jkff: if the number of elements being inserted into the map is small-ish, you shouldn't need any strictness annotations at all
10:05:56 <cads> ... what was I saying...
10:06:06 <cads> lol, yeah, sorry
10:06:16 <cads> ... I am a dork...
10:06:26 <pchiusano> typeclass question: http://pastie.org/379646
10:06:38 <rwbarton> jkff: anyways, it may be easiest to just write a loop that reads one line strictly at a time
10:07:30 <cads> anyways, it's just got to generate n strings, and then concatenate them with delimiters between the strings, and not before or after the group
10:07:54 <cads> actually I think I just thought of how to better do it with a fold
10:08:40 <apfelmus> cads: maybe intersperse from the Prelude can help?
10:09:00 <jkff> rwbarton: It's not exactly small-ish, about 100000, but not big enough to consume 1Gb. However, it's anyways not the map that occupies space, it's the input bytestring.
10:09:08 <rwbarton> jkff: if you use String IO rather than ByteStrings what happens?
10:09:43 <lilac> @hoogle RandomGen g => g -> [a] -> a
10:09:43 <pumpkinbot> Data.List genericIndex :: Integral a => [b] -> a -> b
10:09:43 <pumpkinbot> Control.Parallel par :: a -> b -> b
10:09:43 <pumpkinbot> Control.Parallel pseq :: a -> b -> b
10:10:24 <jkff> rwbarton: That's a good suggestion to try, but I'll first try it without 'decompress' on an already decompressed file.
10:10:34 <pumpkin> what happened to lambdabot?
10:10:49 <jkff> Same thing.
10:11:31 <roconnor> pumpkin: probably gone because the language it is written in can't control memory use.
10:11:38 <pumpkin> lol
10:11:42 <Cheshire> lambdabot(s) should become self aware
10:11:57 <mauke> preflex: seen lambdabot
10:11:58 <preflex>  lambdabot was last seen on #haskell 1 hour, 25 minutes and 38 seconds ago, saying:   thread killed
10:11:59 <Cheshire> that way they can work together to ensure there is exactly one of them in each channel
10:12:16 <ddarius> While the rest are taking over the world.
10:12:31 <Cheshire> ddarius, :p
10:13:04 <pumpkin> so someone joined pumpkinbot to this channel before lambdabot died! maybe it was offended and left voluntarily
10:14:00 <lilac> i think there is a world market for about 5 lambdabots
10:14:06 <lilac> maybe 10
10:14:10 <conal> lilac: hah!
10:14:17 <jkff> When I feed the program a huge program-generated bytestring (concat of a 100mln-replicated "Hello world") instead of a file, it runs in constant space. This suggests that groupMap is not the problem.
10:14:43 <cads> doh, what I came up with was a better version of the same: takecat f n = fold (\x,y -> x ++ ' ' ++ y) (f 1) [2..n]   . apfelmus: so it would be something like  takecat f n =  concat $ intersperse " " (map f [1..n])
10:14:47 <ddarius> lilac: You might be surprised at how many lambdabots there are and not just extra ones in here.
10:14:57 <cads> I own a lambdabot
10:15:09 * lilac also owns a lambdabot
10:15:55 <rwbarton> jkff: Same thing for String IO?
10:16:00 <apfelmus> cads: Yup. There's also  intercalate  from Data.List
10:16:00 <pumpkin> lambdabots are people too!
10:16:07 <pumpkin> don't own them, pwn them
10:16:26 <lilac> ddarius: i was parodying a quote from (someone important at IBM) "there is a world market for about 5 computers"
10:16:26 <apfelmus> cads: intercalate x xs = concat . intersperse x xs
10:17:10 <jkff> rwbarton: Oh, I was mistaken. When I concatenated that string the other way, it ran out of memory again, despite no IO occuring at all.
10:18:08 <cads> is there a version of fold such that  fold f a ls  = fold' f (f^-1(a)):ls
10:19:04 <cads> ... or rather fold' f x:xs = fold f (f x) xs
10:19:31 <apfelmus> cads: Hm? The types don't match. What do you want to do?
10:19:36 <apfelmus> cads: foldr1 maybe?
10:19:46 <ehird> How can I export Haskell functions to, e.g. C?
10:20:00 <mauke> @where ffi
10:20:00 <pumpkinbot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:20:14 <tromp_> @hoogle on
10:20:15 <pumpkinbot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:20:15 <pumpkinbot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
10:20:15 <pumpkinbot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
10:20:28 <cads> @type foldr
10:20:29 <pumpkinbot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:20:29 <jkff> Well, well. Seems like Oleg was *really* right about lazy IO being harmful and I'll have to rewrite zlib to consume iteratees and use them in the program.
10:20:56 <ehird> mauke: wrong way around
10:20:58 <ehird> that's C->Haskell
10:21:02 <apfelmus> jkff: I'm not sure whether this solves your problem.
10:21:13 <apfelmus> ehird: foreign export ccall
10:21:16 <mauke> ehird: read again
10:21:22 <ehird> huh, okay
10:21:23 <ehird> thanks
10:21:46 <apfelmus> jkff: Switching to something else before understanding what's going on usually doesn't help either. ;)
10:22:20 <edwardk> lazy IO is a pain in the ass. we need a lazy file system to go with it
10:22:41 <apfelmus> edwardk: Put differently, the file system is at fault. ;0
10:22:43 <apfelmus> *;)
10:22:52 <apfelmus> Oberon does have a lazy file system, I think.
10:22:54 <jkff> Can it be that in the line "uid_modelMap <- (process . decompress) `fmap` L.readFile f", some of the mentioned closures (fmap?) is holding a reference to the result of "L.readFile f" during the evaluation of "process"? Sounds like crap, but..
10:23:00 <edwardk> the leaky abstraction
10:23:04 <cads> apfelmus: I was thinking of a kind of simplified fold :: forall a. (a -> a -> a) -> [a] -> a
10:23:13 <mauke> :t foldl1
10:23:14 <pumpkinbot> forall a. (a -> a -> a) -> [a] -> a
10:23:22 <apfelmus> :t foldr1
10:23:23 <pumpkinbot> forall a. (a -> a -> a) -> [a] -> a
10:23:40 <apfelmus> jkff: Unlikely.
10:23:41 <cads> :)
10:23:54 <mauke> @hoogle (a -> a -> a) -> [a] -> a
10:23:55 <pumpkinbot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
10:23:55 <pumpkinbot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
10:23:55 <pumpkinbot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
10:24:04 <edwardk> the reality is that getContents has a pleasant fiction for its type that doesn't model the reality that you might manipulate the file system in the meantime.
10:24:14 <conal> yes to lazy functional file systems.
10:24:22 <cads> apfelmus, mauke, wow!
10:24:32 <conal> (with garbage collection)
10:24:33 <cads> you can search by type signature!
10:24:49 <rwbarton> jkff: I suspect you need to force the applications of S.copy
10:24:55 <apfelmus> jkff: You say that it works on a file with hundres of Hello world\n lines?
10:25:00 <edwardk> conal: we're getting closer these days, lots of things supporting snapshotting, etc.
10:25:03 <mauke> http://haskell.org/hoogle/
10:25:05 <rwbarton> jkff: otherwise there will be references to entire chunks and not just the bits you want
10:25:21 <conal> edwardk: yeah.  nix also.  exciting convergence!
10:25:29 <jkff> rwbarton: Now, *that* sounds cool! If you're right, [invents an extreme form of praise and respect]
10:25:49 <cads> apfelmus: thanks for reminding me the importance of reasoning about types explicitly, when you pointed out my function was mismatched, and mauke, that hoogle search is brilliant!
10:25:53 <conal> edwardk: and we could replace content mutation with (immutable) reactive values.
10:25:55 <apfelmus> jkff: That's what the  seq  on (x,y) was supposed to do...
10:26:16 <apfelmus> edwardk: I've heard that Oberon by Niklaus Worth has such a file system.
10:26:21 <apfelmus> *Wirth
10:26:32 <rwbarton> apfelmus: oh, so it is.
10:26:35 <apfelmus> cads: anytime :)
10:26:38 * rwbarton can't read code without type signatures
10:27:06 <jkff> rwbarton: YOU'RE A MAGICIAN. I don't usually write in caps, but that is the case.
10:27:38 <edwardk> apfelmus: i suppose the approximation of a file system by objects used by eros, etc. also fits that model.
10:27:38 <rwbarton> woo!
10:27:47 <apfelmus> jkff: Werid, what random seq did the trick now?
10:27:58 <apfelmus> *weird
10:28:07 <apfelmus> edwardk: yeah
10:28:13 <jkff> The 'S.copy yandexuid' was holding a reference to yandexuid, which was a substring of a chunk of that huge lazy bytestring.
10:28:29 <jkff> I forced the S.copy, and it stopped holding that freaking reference.
10:28:40 <apfelmus> jkff: Yeah. That's what  y `seq` x `seq` etc. in foldl' should have prevented?
10:28:56 <Gracenotes> seq infixl..?
10:29:01 <mauke> (void)(int)((int (*)(const char *, ...))printf)((const char *)"Hello, world!\n");
10:29:11 <Gracenotes> infixr
10:29:13 <cads> cadr: a brother!
10:29:26 <lilac> cads == cadr ++?
10:29:29 <newsham> mauke: heh
10:29:40 <apfelmus> jkff: I'm still confused, where did you force it?
10:29:55 <cadr> cads: I'm not aware of the 'cads' function :)
10:30:05 <jkff> apfelmus: One moment, I'm going to test it on a real big logfile and see if rwbarton is actually a magician ;)
10:30:25 <cadr> cads: but yeah, we'll go with brother
10:30:30 <cads> i used to be named cadsmack in reference to autocad skills that I could smack one about with.. but then I learned about the negative connotations of "smack"
10:30:34 <rwbarton> jkff: I'm curious what you did and how it's different from just writing -> x `seq` y `seq` M.insertWith' ...
10:30:38 * edwardk things c(a|d)+r is slumming. pshaw. we only have head and tail here, brother. ;)
10:30:52 <edwardk> er thinks
10:30:53 <mauke> (a|d) better written as [ad]
10:30:55 <apfelmus> jkff, rwbarton: aye :)
10:30:57 <cadr> ha!
10:31:03 <edwardk> mauke: fair enough
10:31:20 <cadr> cads: I could see autocad being addictive...
10:31:20 <lilac> cr = id?
10:31:31 <jkff> Hmmm. A real big logfile crashed it still.
10:31:32 * Gracenotes uses caddaddadaaddaaaddr
10:31:38 <ddarius> (a|d)+ better written as (a|d)(a|d)*
10:31:43 <mauke> lilac: heh, lisp should totally have that
10:31:52 <jkff> ...Or not. It stabilized at 650Mb residence
10:32:04 <Gracenotes> cr (x:xs) = x:xs
10:32:04 <mauke> ddarius: how boring (and regular)
10:32:07 <jkff> While processing 500Gb of logs in 8 threads.
10:32:20 <cads> conal: have you seen any reading about such filesystems? Then again, if something awesome like that existed it would probably be licensed such that linux could not benefit, a
10:32:23 <jkff> I did this:
10:32:24 <jkff> uidAndModel :: S.ByteString -> Maybe (S.ByteString, S.ByteString)
10:32:24 <jkff> uidAndModel s = do
10:32:24 <jkff>     [_,modelid,yandexuid] <- match ourRegex s []
10:32:24 <jkff>     let (uid',modelid') = (S.copy yandexuid, S.copy modelid)
10:32:24 <jkff>     uid' `seq` modelid' `seq` return (uid', modelid')
10:32:27 <cads> 'la ZFS
10:32:29 <cads> ..
10:32:58 <cadr> cadr is hardly slumming - am beating my head against haskell as hard as I can, and it isn't all going in
10:33:02 <apfelmus> jkff: Weird.
10:33:16 <apfelmus> jkff: In any case, that's better done with a strict pair anyway.
10:33:18 <conal> cads: no, i haven't.  let's make one for linux.
10:33:34 <rwbarton> In effect this is a strict Maybe as well.
10:33:41 <pumpkin> MaybeS
10:33:41 <rwbarton> But I don't see how that could matter at the moment.
10:34:03 <cads> conal, as long as it can do everything ZFS can, on top of being functional... that file system gives me and a bunch of people I know serious OS envy
10:34:19 <apfelmus> jkff: (S.copy yandexuid) :!: (S.copy modelid)
10:34:34 <edwardk> cadr: no worries. happy to help with the stuffing in of the odds and ends.
10:34:37 <apfelmus> jkff: import Data.Strict after  cabal install strict  of course
10:34:44 <jkff> The thing is that I had to force not just the pairs in groupMap, but the inner contents of the second element of the pair (it was a list of sad thunks holding references to the big string, and evaluating the very list didn't help, of course. I had to evaluate its elements)
10:35:13 <conal> cads: is zfs open, as a possible basis?
10:35:24 <cads> so, end to end data verification with some crazy tree-hashes... but sadly conal I'm not anywhere near that field or level of skill
10:35:29 <apfelmus> jkff: yes, but that's what foldl' (... \(x,!y) -> ) should have done already...
10:35:38 <roconnor> @where pandoc
10:35:38 <pumpkinbot> http://sophos.berkeley.edu/macfarlane/pandoc/
10:35:39 <jkff> Nope. The y is a list
10:35:39 <rwbarton> jkff: does it also work if you insert "x `seq` y `seq`" before M.insertWith'?  Is that what you tried before
10:35:43 <edwardk> conal: there are various associated patents that may make derivatives of it hard to build
10:35:44 <cadr> General question: I have some code I wrote (simple tetris) and I wanted opinions on it (how I could improve it).  What would be the best avenue for that?  Mailing list?
10:35:53 <jkff> So, the list was evaluated, but its elements weren't
10:36:02 <cads> conal, zfs is open under the solaris license I believe.. but I don't know.. edwardk, it is not open?
10:36:17 <mmorrow> cads: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/halfs
10:36:17 <edwardk> cadr: @hpaste if its self-contained. if you have a darcs repo somewhere it might work
10:36:58 <yitz> @bots
10:36:58 <pumpkinbot> :)
10:36:58 <lunabot>  :)
10:37:00 <jkff> So, all in all, rwbarton, you *are* a magician :) Thank you very much. Your deed will help me spread Haskell among my colleages, after speeding up some log processing by a factor of 8 :)
10:37:02 <edwardk> cads: at last check there were some patents that sun held that could be used as a minefield, they agreed not to use it against the open source implementation or some such.
10:37:03 <yitz> oh not again
10:37:04 <cadr> It's several files.  Any suggestions as to where to stick the repo/code?
10:37:10 <pumpkin> conal: yeah, it's open, but is not compatible with the GPL
10:37:16 <mmorrow> i had halfs working at one point with 6.6 via http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HFuse
10:37:35 <conal> oh well.  maybe we start with the lazy functional semantics and interface, see where we get, and then look for a more robust underlying implementation.
10:37:36 <edwardk> cadr: there i can't help. maybe someone else here has a suggestion
10:38:04 <rwbarton> jkff: I'm curious now whether it works if you change most of the body of groupMap to use M.fromListWith.
10:38:08 <pumpkin> http://en.wikipedia.org/wiki/Common_Development_and_Distribution_License
10:38:27 <jkff> rwbarton: It was initially a fromListWith, and I rewrote it after found nothing like fromListWith'
10:38:28 <cads> edwardk: my understanding is that it's open enough to be used outside the linux kernel as a FUSE daemon, or in bsd, but that the solaris license contradicts the gnu license in such a way that it cannot be brought into the linux kernel
10:38:31 <conal> pumpkin: what's the gpl issue?  i'm just starting to learn about license issues.
10:38:57 <rwbarton> jkff: but your operation is (++), and big thunks like [a] ++ ([b] ++ ([c] ++ ...)) are ok
10:39:05 <jkff> Oh well, now it's a good time to go home in a happy mood. Bye to everyone!
10:39:05 <rwbarton> > concatMap (:[]) [1..]
10:39:06 <pumpkinbot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:39:22 <edwardk> sun has 56 patents on zfs at last check
10:39:24 <jkff> (rwbarton: They are not if elements of [x] keep references to chunks of a multi-Gb bytestring)
10:39:50 <edwardk> http://kerneltrap.org/node/8066 as a starting point
10:39:53 <pumpkin> conal: not too sure, but everyone was making a lot of noise about it a few months back
10:40:22 * cads wonders how hard it would be to patch the ZFS code into linux, and whether certain people with a 
10:40:40 <cads> "fuck-all" attitude have decided to maintain their own personal copies
10:41:02 <cads> ... damn return key and chicken-slippery fingers
10:41:19 <mmorrow> eewwwww, chicken grease on the keybd!
10:41:25 <edwardk> actually i don't care about compatibility with zfs. i'm just annoyed that the minefield exists to keep anyone else from doing anything else even remotely like it
10:41:33 <conal> Chicken-Oriented Programming
10:41:39 <Feuerbach> (20:38) < pumpkin> http://en.wikipedia.org/wiki/Common_Development_and_Distribution_License
10:41:40 <mmorrow> COP
10:41:44 <hackage> Uploaded to hackage: fclabels 0.1
10:42:03 <conal> This code brought to you by the Colonel
10:42:12 <ray> ZFS is open enough to be included in BSD
10:43:00 <newsham> colonel hacking?
10:43:05 <pumpkin> yeah, we have it in mac os
10:43:09 <cads> newsham nooooo!
10:43:12 <roconnor> *L* ``We need a pause action of type (Coroutine m ()). But how should it work? I did not really try to understand why it works, but by looking at the types, I came up with this ...
10:43:24 <cads> that was terrible!
10:43:28 <yitz> edwardk: reiserfs was remotely like it, it's prior art. but reiser is in prison of course...
10:43:34 <redditbot> Pausable IO actions for better GUI responsiveness
10:43:41 <edwardk> ray: because the bsd license is lightweight enough that it doesn't put any burden that the cddl can't comply with. alas the gpl is not so forgiving
10:43:42 <cads> mmorrow: that file system deserves further reading
10:43:43 <newsham> μ-colonel
10:43:53 <cads> the gpl is a pain the ass
10:43:53 <pumpkin> the "deep philosophical question" seems to be, "is it freeer to force people to be free, or to let them choose to not be free"
10:44:13 <roconnor> Haskell is awesome because even their programmers don't know how their functions work.
10:44:36 <edwardk> yitz: overturning one patent will cost you typically $50k of non-recoupable attorney fees if its cut and dried. overturning 56 of them against Sun who has a clearly vested interest in fighting tooth and nail on all of them?
10:44:38 <roconnor> ``pause = CoroutineT (return (Left (CoroutineT (return (Right ())))))
10:44:44 <Gracenotes> roconnor: I think this is because the "-" key can be somewhat inconvenient to access
10:44:44 <roconnor> ``
10:44:47 <cads> There have been allegations to the end that the author of the CDDL expressly set out to make a license incompatible with GPL.
10:44:49 <roconnor> ``Yes, it sounds like some dance step instructions (read the second line out aloud!), but it works somehow.
10:44:55 <ray> edwardk: "alas the gpl" is right :(
10:45:04 <yitz> edwardk: yeah. groan.
10:45:08 <Gracenotes> --would you rather use this for comments or //this?
10:45:18 <ray> -- this definitely
10:45:30 <edwardk> cads: i'll admit i've explictly licensed stuff under apache to avoid its use in gpl projects before.
10:45:38 <asgaroth> Just to check whether I correctly understood this: callCC is mainly used to provide more control over when the continuation is called/a shortcut to exit the argument function, right?
10:45:41 <edwardk> or to at least force a dialog when people want to use it in such settings
10:45:44 <Gracenotes> fair enough :/ Still, comments don't abound in that much code
10:45:48 <yitz> Gracenotes: {- why do you ask? -}
10:45:48 <pumpkin> I prefer BSD over GPL, myself
10:45:50 <newsham> gracenote: i dont see that it matters so much.  (or # or /* or (* or ...)
10:46:06 <Gracenotes> yitz: eek, I always mess up the closing bracket of those
10:46:10 <roconnor> asgaroth: it can be used for more than a shortcut to exit.
10:46:36 <edwardk> i generally write code under BSD when I just want someone to use it, read it, or understand it no matter what. when i want to make money off it i get a lot more conflicted.
10:46:42 <cads> edwardk: I don't see why that would stop anyone other than those looking to make money with your software
10:47:33 <Gracenotes> newsham: I have yet to find a good theory of why it's easy so easy to write Haskell code without commenting :P it could just be me though
10:47:46 <Gracenotes> although not always easy to read it later
10:47:49 <SamB_irssi> cads: those who might want to use their own software to make money?
10:47:56 <asgaroth> roconnor: For example to have direct access to the continuation, right? Could you give some other examples?
10:47:58 <mmorrow> cads: yeah, i've briefly peeked at the code for halfs, looks interesting
10:48:05 <newsham> gracenote: ken thompson was content to write C and asm without commenting
10:48:29 <SamB_irssi> newsham: well, they also say he used ed(1)
10:48:38 <roconnor> asgaroth: I can't.  I was pondering the issue yesterday.  Somehere here probably can.
10:48:43 <cads> I think there is a community of suppressed freedom pirates that don't get to touch a lot of open software because it's otherwise licensed in such a way that makes it hard for the community as a whole to will free support towards it
10:49:13 <newsham> samb: used?  he wrote it.
10:49:23 * SamB_irssi boggles at term "freedom pirates"
10:49:33 <SamB_irssi> newsham: I meant even after better ones were written!
10:49:34 <edwardk> arrr
10:49:43 * SamB_irssi goes to class
10:49:56 <yitz> @arr
10:49:56 <pumpkinbot> I'll keel haul ya fer that!
10:49:59 <cads> rather, the idea is that I could put zfs in the kernel if I felt like it, and distribute patches if I chose, and that would all be free and lovely, but I could end up sued, so I'm not going to do it, or if I am, I better do it alone; I can't expect any help
10:51:03 <psnively> Hi guys.
10:51:44 <cads> I realize the importance of software as a money supplying medium.. and the importance of cash in this society.. I still think there are those of us that don't really give a fuck about it though, and would like to see software developed for its own sake
10:52:41 <cads> and then my argument is rendered meaningless by the fact that we wouldn't be where we are today if not for massive amounts of money pumped into otherwise free projects! :D
10:52:55 <cads> so life is sad for a freedom pirate.
10:53:15 <guenni> what happend to lambdabot?
10:53:33 <pumpkin> cads: it's not like the CDDL isn't "free", it just isn't GPL-compatible (and I have issues calling the GPL free)
10:53:50 <skorpan> i'm trying to figure out a nice way to get test data for the paradise benchmark. any ideas? i have the company datatypes bw.
10:53:51 <lilac> cads: can't you distribute GPL-licensed patches to the kernel, and patches to zfs with a compatible license, and let people combine them at their own risk?
10:53:51 <skorpan> btw*
10:54:36 <cads> lilac: I think so, in principle
10:54:55 <cads> I mean, anything is possible, you'd just get sued or end up in jail
10:55:23 <lilac> cads: i meant, without violating anyone's copyright
10:55:49 <edwardk> the gpl mostly just annoys me off because it effectively trumps bsd. a gpl fork of bsd code 'wins'. i don't care so much about closed source forks. i can't see the beautiful extensions they wrote so they don't bother me.
10:55:58 <edwardk> s/off//
10:56:13 <cads> a loophole like that would be interesting to find out, for sure, lilac
10:56:55 <Feuerbach> lilac: if they are made for GPLed Linux Kernel, they are derivative work (INAL)
10:57:09 <cads> I was wondering, how is it that GHC can use the GMP bignum library (which is gpl'ed), and still make code that can be closed source?
10:57:26 <mmorrow> edwardk: (i'm not sure if you're serious) but is not a gpl fork better than a closed source fork because you can see the code at all?!?
10:57:53 <lilac> Feuerbach: sure, but if you write (1) patches for linux kernel to support some abstract interface, and (2) patches for zfs to support the same abstract interface, then at no point do you make such a combined work (let alone /distribute/ it)
10:58:08 <pumpkin> lilac: sounds like fuse
10:58:12 <pumpkin> :P
10:58:18 <mauke> cads: gmp is lpgl
10:58:27 <cads> ah
10:58:41 <cads> so it could not be used in ghc if ghc were closed?
10:59:08 <cads> mmorrow: it's like with zfs: we see this beautiful piece of software and the vast majority of us can do nothing but cry, because we don't have the ability to implement something like it, even though we see the code.
10:59:30 <cads> mmorrow: at least if we did not see the code we would not be broken of spirit :D
10:59:34 <mmorrow> hehe
11:00:07 <shteou> cads: You can link to a lgpl library I think, so long as it is dynamically... and you can keep your app closed source, commercial w/e
11:00:11 <shteou> I think ;f
11:00:23 <leimy> cads: You can link to LGPL programs "dynamically" and not have to be open sourced at all... best bet is to ask your favorite lawyer.
11:00:48 <shteou> Doppleganger!
11:01:06 <mmorrow> until someone includes a "feature" in the dynlinker that just deletes all closed code linking to lgpl pkgs :):)
11:01:21 <pumpkin> lol
11:01:22 * cads is going to move to sealand and code software drawing on a mix of illicit gpl, bsd, pirated commercial libraries, and decompiled shiiiiz... I will release under the General Pirate License
11:01:31 <pumpkin> @arr
11:01:31 <pumpkinbot> Drink up, me 'earties
11:01:48 <cads> @arr
11:01:48 <pumpkinbot> Smartly me lass
11:01:53 <mmorrow> wear arrrrrgyle socks too!
11:02:45 <cads> i'll saw off me own leg and poke an eye out on a sharpe barnacle, I will
11:03:12 * cads dons a pegged leg and eyepatch, and takes a swig of rrrrum
11:03:56 <guenni> is there a way to turn something that is not monadic into a monad?
11:04:08 <cads> ... i can't get sued just for saying this kind of stuff can I?
11:04:14 <Badger> yes
11:04:40 * Badger files a lawsuit
11:04:41 <lament> guenni: what do you want to do?
11:04:43 <mmorrow> cads: better start paddlin' yer way to sea!
11:05:01 <guenni> lament: insert into a Map
11:05:20 <guenni> I wonder if I can turn that into a monad
11:05:49 <pumpkin> a Map monad?
11:05:56 <pumpkin> it's possible to make Set into one
11:06:00 <pumpkin> but you need to use restricted monads
11:06:04 <guenni> pumpkin: sorta
11:06:18 <cads> guenni: you may do that, you need to define a proper unit and bind function
11:06:18 <pumpkin> @hackage rmonad
11:06:18 <pumpkinbot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
11:06:19 <guenni> pumpkin: what's that?
11:06:23 <rwbarton> guenni: are you looking for a state monad maybe?
11:06:25 <lament> guenni: Monad is a type class. You can make any type into a monad by providing the appropriate functions
11:06:59 <Gracenotes> hm... a set monad is basically a list monad with an "eliminate duplicates" guard
11:07:06 <Gracenotes> at least, I'd think it would be
11:07:06 <pumpkin> lament: except to provide meaningful definitions you need to find a way to get return :: a -> m a  to ignore the fact that all Map's types use (Ord a) =>
11:07:26 <Saizan> pumpkin: well, not for the values
11:07:35 <pumpkin> no, but for the keys :P
11:07:51 <edwardk> mmorrow: well, its complicated. in the closed source fork case if it grows big enough, odds are i'll get brought in as a consultant or something to help out eventually. Its happened to me before, and I'll see financial gain. in the gpl fork case their is no real incentive to share it back or for their to be a financial windfall. the only obligations there are moral.
11:07:54 <pumpkin> I'm not sure how making Map into a monad would work
11:08:06 <edwardk> er for there
11:09:04 <guenni> guess I need to give this some more thought ...
11:09:22 <guenni> rwbarton: I am?
11:09:28 <edwardk> pumpkin: use a monoid to combine keys from each map elementwise.
11:09:35 <pumpkin> guenni: how would return/bind work?
11:09:57 <guenni> pumpkin: oh guys I so don't know
11:10:10 <pumpkin> edwardk: hmm, that's just another restriction though
11:10:53 <pumpkin> but I think I see what you're saying
11:10:57 <edwardk> return yields a map with the mempty key. bind iterates over the original map mappending the original key to the one output by the monadic action
11:10:59 <Cheshire> type Set = []
11:11:04 <Cheshire> Set monad is the same as []
11:11:06 <Cheshire> :)
11:11:53 <Gracenotes> well, except for idempotence...
11:11:59 <pumpkin> Cheshire: except that it has a better underlying representation
11:12:03 <guenni> but bottom line is it could be done?
11:12:16 <Cheshire> the difference for me is conceptual
11:12:21 <Cheshire> the implementation is the same
11:12:37 <rwbarton> runSet = nub
11:12:37 <Cheshire> [a,b,c] == [b,a,c] :: Set
11:12:44 <Cheshire> [a,b,c] /= [b,a,c] :: []
11:12:48 <Saizan> guenni: the bottom line is that you've to decide a semantic for it
11:12:50 <mmorrow> edwardk: true on the consultant case, but i still don't see how the gpl fork would be disagreeable, since whoever forked it probably wasn't deciding between gpl and not paying you or closed and paying you, and wrt sharing it back isn't the gpl licensed code "shared back" moreso than the closed code since you can at least view the ideas therein (in neither case could it be incorporated back into the bsd project)?
11:12:53 <Gracenotes> Cheshire: unfortunately, not enforcing idempotence on a set-as-list can yield duplicate calculations
11:13:00 <Saizan> guenni: edwardk described a possible one and its implementation
11:13:08 <Gracenotes> which has performance consequences, of course
11:13:29 <leimy> wow 677 peeps
11:13:33 <pumpkin> @usesr
11:13:33 <pumpkinbot> Maximum users seen in #haskell: 678, currently: 676 (99.7%), active: 25 (3.7%)
11:13:43 <pumpkin> that's crazy
11:13:43 <guenni> Saizan: I missed that
11:13:43 <leimy> Hmmm I don't see that many
11:13:47 <pumpkin> let's hit 700 today
11:14:04 <Peaker> pumpkin: spread the word, quickly!
11:14:04 <pumpkin> ?
11:14:09 <pumpkin> oh yeah!
11:14:11 <pumpkin> let's spam
11:14:12 <pumpkin> :D
11:14:13 <mmorrow> > replicateM 22 @bot
11:14:14 <pumpkinbot>   mueval: Prelude.read: no parse
11:14:15 <leimy> naked chicks in #haskell
11:14:16 <leimy> !
11:14:29 <smtms> where? where?
11:14:39 <rwbarton> @vixen what are you wearing?
11:14:39 <pumpkinbot> nothin but my ol tank top and a pair of shorts :)
11:14:40 <edwardk> mmorrow: the problem is the gpl one can take off, build a dev community and leave my original app that needed it to be bsd licensed due to whatever other set of constraints i have behind.
11:14:48 <Cheshire> lol
11:15:06 <pumpkin> @vixen a/s/l
11:15:06 <pumpkinbot> 19/f/California
11:15:20 <edwardk> rwbarton: hah i parsed that as vixey and thought, wow that was forward ;)
11:15:23 <pumpkin> @vixen mmm I speak California too, wanna hang out sometime?
11:15:23 <pumpkinbot> is that really what you want to know?
11:15:53 <rwbarton> edwardk: yeah I make the same mistake sometimes :)
11:15:59 <dolio> @remember xahlee Dear Jon idiot, No, Ocaml doesn't have linked list. Looook: [1;2;3] That's a sequence of 3 numbers, separated by semicolon, then bracketed by square brackets.
11:15:59 <pumpkinbot> It is stored.
11:16:11 <edwardk> @vixey would probably start spouting category theory
11:16:11 <pumpkinbot> Hmmm
11:16:20 <ehird> dolio: lol, xahlee
11:16:26 <mmorrow> true, but i still don't see how that's not the case with some company taking your code, possibly adding to it, and turning it into some huge moneymaker for them, leaving your original app to be bsd licensed due to whatever other set of constraints you have behind.
11:16:51 <Gracenotes> @vixen Would vixey start spouting category theory?
11:16:51 <pumpkinbot> is that really what you want to know?
11:16:55 <mmorrow> (other than the possibility of them hiring you as a consultant, which isn't guaranteed)
11:16:57 <ehird> can I make ghc not link with gmp? (Sacrificing Integer and the like, naturally.)
11:17:09 <rwbarton> @let vixey = "i did it using gadts"
11:17:10 <edwardk> mmorrow: a company's capacity to build a community around something tends to be bounded ;)
11:17:10 <pumpkinbot>  Defined.
11:17:11 <Saizan> guenni: here's the code for that http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=746#a746
11:17:14 <pumpkin> dolio: not sure getting pumpkinbot to remember things is vert useful :/
11:17:32 <pumpkin> where did vixey go?
11:17:34 <mmorrow> edwardk: sure, i was thinking s/community/financial gain/
11:17:46 <dolio> Oops.
11:17:47 <pumpkinbot> dolio: You have 1 new message. '/msg pumpkinbot @messages' to read it.
11:17:51 <Saizan> guenni: oh, sorry it's not a monad there :)
11:17:56 <dolio> @messages
11:17:56 <pumpkinbot> vixey said 3m 25d 6h 54m 32s ago: \neg actually also works I just noticed
11:18:10 <dolio> Man, seriously? Again?
11:18:16 <edwardk> mmorrow: yes, but with the smaller community ceiling, there is a greater likelihood to contribute pieces they want maintained back to the original community.
11:18:36 <guenni> is there a sample of a monadic algo and a non-monadic version of the algo in rwh?
11:19:13 <mmorrow> edwardk: perhaps. i can see your argument, though. i think we just have different views. :)
11:20:17 <edwardk> mmorrow: i mostly just get annoyed that the gpl effectively infects my ability to put something out there under terms that are compatible with everyone. the BSD license is basically a sucker's license as a result. ;)
11:20:36 <mmorrow> edwardk: what do you think about those projects that license under gpl, with the option of payment for a license for proprietary use?
11:21:09 <mmorrow> edwardk: yeah, i agree with you there (that that's the case)
11:21:54 <guenni> Saizan: thx
11:22:16 <ozy`> programmers need to eat too
11:22:25 <mmorrow> it seems to me that if you have some code that you want to "protect" and/or make money off of, a bsd license isn't one you'd use
11:22:50 <edwardk> the consequence is that to end run around the GPL you have to be big enough and organized enough that the changes you can make fit under Coase's ceiling. i.e. be Google. if you buy everyone that you want to have use your tools you never distribute
11:22:55 <Peaker> General question (For GHC operational semantics): If you represent a huge or infinite data structure lazily, and slowly your program uses more and more of it, it will evaluate more and more of the structure into memory and never get rid of the still reachable parts that you no longer use.. Is this a wrong analysis? Is there a good solution?
11:22:56 <koeien> i hate it when BSD-developers complain about people that fork their code under GPL
11:23:02 <edwardk> so its the second order consequences that get me
11:23:39 <edwardk> mmorrow: i'm actually thinking about trying that approach with my current jit
11:24:00 <mmorrow> edwardk: oh cool. a jit for what?
11:24:02 <Peaker> koeien: Hey, it would be cool if someone set up bsd2gpl.org that auto-creates and maintains a github or its own git fork of every BSD project to GPL automatically :)  Make it easy for people to submit new patches that go into the GPL one
11:24:16 <koeien> Peaker: hehe
11:24:20 <edwardk> mmorrow: er x86-64 assembly to x86-64 assembly
11:24:24 <Peaker> koeien: it would pull new changes into the GPL one, but the vice versa would not be possible
11:24:47 <mmorrow> edwardk: hmm, for optimization? "security auditing"?
11:25:06 <mmorrow> virtualization?
11:25:15 <koninkje> a fabulous idea, though I think it's bitrot quickly (bsd/source changes clashing with gpl/new changes)
11:25:24 <edwardk> mmorrow: its an opt-in tracing jit, constant folds references into .rodata segments, polyinline caches virtual function calls, etc.
11:25:36 <mmorrow> edwardk: interesting
11:25:54 <Peaker> koninkje: if there's active GPL development, then they might take over, and if not its not likely to clash
11:26:00 <mmorrow> edwardk: what lang did you write it in?
11:26:03 <cads> Peaker: the 2gpl part means "to General Pirate License."
11:26:08 <edwardk> mmorrow: 250-400% speedups on things like visitor patterns traversals due to polyinline caching. can trace right into standard libraries, etc.
11:26:29 <mmorrow> edwardk: sweet
11:26:32 <edwardk> mmorrow: its written in pretty heavily templated c++
11:26:34 <Peaker> cads: "bsd2gpl.org -- Help GPL take over the world"
11:26:46 <koninkje> Peaker: if there's active development, then sure. I was just saying for the auto-bot part with intermittent gpl patches
11:26:57 <cads> people won't know that it's the pirate license they're working for
11:27:01 <koninkje> Peaker: Though if there was a project-agnostic maintinence crew...
11:27:16 <Peaker> koninkje: :-)
11:27:31 <Peaker> koninkje: it could also revert conflicting patches in the assumption that fixes of same bugs are similar, as a default if no maintainer
11:27:50 <cads> edwardk: isn't it possible to make a license that says "no offense, you can use this code wherever you want, but this license has to stay on it, this means no GPL forks"
11:27:52 * koninkje uses BSD as the "just put my name on it" license, not for 'real' F/OSS
11:28:12 <edwardk> cads: sure, i used to use apache for that. ;)
11:28:14 <koeien> mmorrow: what do you think of AGPL ?
11:28:32 <edwardk> cads: not sure that its still incompatible since gpl3 though
11:29:20 <skorpan> is there any way to load hs files in ghci which contain #ifndef and such?
11:29:24 <koninkje> Peaker: you mean revert the gpl patch or the bsd? I'd say to revert the gpl (flagging it for being looked at). Though there's the issue of bigfix vs upgrades...
11:29:35 <Peaker> koninkje: yeah that's what I meant
11:29:40 <edwardk> skorpan: run them through cpp manually? =)
11:29:51 <cads> wait, I've got it.. to prevent gpl stealing your project community, the perfect solution is releasing under GP.... NOOOOOOO!!!!
11:30:09 <trofi> ms eula
11:30:14 <koeien> you could create a license completely similar to gpl, with a different name
11:30:19 <koeien> and it would be incompatible, no?
11:30:21 <mmorrow> koeien: hmm, i'm actually not familiar with it
11:30:23 <edwardk> cads: i've more or less accepted that it happens, it just shapes what i develop.
11:30:25 <koninkje> cads: Apache2.0 + gpl3 works fine, but not with lesser versions of either
11:30:43 <mmorrow> oh, n/m
11:30:45 <koninkje> edwardk: ^
11:30:48 <kaol> koninkje: like CDDL
11:30:50 <koeien> mmorrow: basically you have to share code for websites as well
11:30:54 <kaol> eh, koeien
11:30:57 <conal> koninkje: what's Apache2.0 like?
11:31:00 <koninkje> Apache2.0 + Lgplv3 is also fine
11:31:07 <edwardk> koeien: nah, it needs to have some clause that trips up linkage. just add something like. and whenevr you install it you have to say "Ooompah" and all of a sudden you're gpl incompatble. ;)
11:31:09 <mmorrow> koeien: i misread you :) i'm not sure how i feel about it. i've never used it myself
11:31:26 <koninkje> conal: I haven't looksed at it, only the community's compatibility judgements
11:31:29 <koeien> mmorrow: GPL seems kinda pointfree for web stuff
11:31:43 <cads> can I simply copy the GPL and replace the G with my first name, Max?
11:31:45 <edwardk> koninkje: thats what i thought. damn. now i need a new license to use when i'm on an anti-RMS kick. ;)
11:32:04 <Cheshire> pointfree ??
11:32:08 <koeien> pointless ;)
11:32:08 <dancor> if i'm using Either is it reasonable to put the more "likely" one first
11:32:10 <conal> heh
11:32:15 <mmorrow> koeien: heh
11:32:21 <cads> what we need is the conal license, and the mmorrow and the edwardk licenses.
11:32:29 * mmorrow read that as "totally awesome and leet"
11:32:33 <edwardk> cads: sure, but the license would be compatible with the GPL. the conflict doesn't come from the name it comes from the terms. the GPL requires that the code be distributable under certain conditions.
11:32:36 <conal> dancor: you might get more mileage putting the less likely first.  see Applicative.
11:32:36 <dancor> seems the opposite of the way Either String a has String -> (less likely) error
11:32:36 <koninkje> dancor: If you want to use the monad instance, it makes more sence to use Right for the more common one
11:32:43 <skorpan> #ifdef __GLASGOW_HASKELL__ <- will this be true in GHC?
11:32:44 <dancor> ok
11:32:48 <conal> dancor: more simply, see Functor
11:32:53 <dancor> tx
11:33:01 <koninkje> dancor: because Monad (Either a) treats a as the "error" type
11:33:09 <Cheshire> dancor, you can partially apply Either into Either a but you can't partially apply it into \t -> Either t a
11:33:23 <mmorrow> @pl \a d e b x z y -> g (a b)  c (f x y z) (k d)
11:33:24 <koninkje> skorpan: Yes, though with differing values per version
11:33:24 <pumpkinbot> (const .) . (. k) . flip . ((flip . ((flip . (flip .)) .)) .) . flip flip (flip . f) . (((.) . (.) . (.)) .) . flip flip c . (g .)
11:33:50 <dancor> mmorrow: wow that's amazingly less concise
11:33:54 <mmorrow> hehe
11:33:56 <mml`> it doesn't seem to be possible to use '\ ->' to make an anonymous nullary function.  is there some other nice short syntax?
11:34:03 <cads> mmorrow: does that pointless function converter also simplify the result to any possible extent?
11:34:09 <koeien> mml`: \() -> ...
11:34:16 <mmorrow> cads: i don't think so
11:34:17 <koeien> mml`: is that what you mean?
11:34:25 <Cheshire> mml`, what's a nullary function?
11:34:32 <mmorrow> it seems there are also some special cases hardcoded in. for instance:
11:34:33 <mux> > \_ -> 1
11:34:33 <dancor> cads: i think it like tries to optimize it until it gets bored
11:34:34 <pumpkinbot>       Overlapping instances for Show (t1 -> t)
11:34:34 <pumpkinbot>        arising from a use of `...
11:34:45 <mux> I don't see much use for this though
11:34:51 * mmorrow has to remember
11:34:56 <mml`> well, ok, the concept of a nullary function doesn't amke much sense in a pure functional language
11:35:03 <mml`> it's a constant really, now that i think of it
11:35:03 <pumpkin> :)
11:35:07 <Cheshire> mml`, especially that it's lazy yes
11:35:09 <conal> mmorrow: hm.  that's a funny inconsistency i hadn't noticed before.
11:35:12 <koeien> mml`: it's more due to laziness
11:35:14 <koninkje> mml`: depends what you mean by "nullary function" technically, no such beast in Haskell. But with laziness, any expression essentially counts as one
11:35:18 <Cheshire> @pl 1 + 1
11:35:18 <pumpkinbot> 2
11:35:22 <rwbarton> mml`: a nullary function in Haskell is just a value, so the syntax is '', the empty string :)
11:35:25 <Cheshire> @pl reverse "foo"
11:35:25 <pumpkinbot> reverse "foo"
11:35:31 <Cheshire> @pl 1 + 1 + reverse "foo"
11:35:31 <pumpkinbot> 2 + reverse "foo"
11:35:39 <mml`> rwbarton: that is elegantly brief :)
11:36:12 <conal> rwbarton: yet it's an odd exception that 0-ary curried functions cannot use the same notation as (k+1)-ary curried functions.
11:36:14 <beelsebob> > fmap fmap fmap sequence fmap pure [1,2,3,4,5] :: Maybe [Int]
11:36:15 <pumpkinbot>   Just [1,2,3,4,5]
11:36:20 <beelsebob> >.>
11:36:31 <koninkje> mml`: If you need nullary functions for certain obscure things like preventing caching (a rare but occasional desire) then just use some ::()->a
11:36:38 <rwbarton> conal: I suppose so.
11:36:42 <rwbarton> > \ -> 1
11:36:43 <pumpkinbot>   mueval: Prelude.read: no parse
11:36:47 <kau> hello
11:36:49 <mmorrow> ok i got it, so
11:36:57 <Cheshire> > (\_-> x)()
11:36:59 <pumpkinbot>   x
11:37:04 <mmorrow> @type flip ((join .) . fmap)
11:37:06 <pumpkinbot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
11:37:06 <mml`> koninkje: it was more a syntactic curiosity that \ -> did not work
11:37:07 <mmorrow> @type (join .) . flip fmap
11:37:08 <pumpkinbot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
11:37:11 <mmorrow> @pl flip ((join .) . fmap)
11:37:11 <pumpkinbot> (>>=)
11:37:16 <mmorrow> @pl (join .) . flip fmap
11:37:16 <pumpkinbot> (join .) . flip fmap
11:37:32 <koninkje_away> mml`: ah
11:37:35 <Cheshire> @pl head (x:xs)
11:37:35 <pumpkinbot> x
11:37:37 <mmorrow> so it's not actually deducing that the first is (>>=), i think it's just a hard-coded case
11:37:39 <Cheshire> @pl tail (x:xs)
11:37:40 <pumpkinbot> xs
11:37:55 <Cheshire> @pl (\list -> head list + tail list) (3:4)
11:37:55 <pumpkinbot> 7
11:38:10 <rwbarton> conal: there are actually a lot of exceptions like that if you look for them.
11:38:12 <rwbarton> > case 3 of { }
11:38:13 <pumpkinbot>   mueval: Prelude.read: no parse
11:38:21 <conal> rwbarton: :p
11:38:22 <Cheshire> @pl is a programming language
11:38:22 <pumpkinbot> is a programming language
11:38:41 <rwbarton> you can't write a function definition with zero cases
11:38:59 <cads> edwardk: I will search for a solution for the license conundrum... maybe by the time I can understand the legal aspects I'll have software I'll want to protect with my decidedly anarchistic ideals, and it will be time to create a personalized license. From an idealistic perspective I'd like to release things under something like the bsd license, but that seems too easy to take advantage of. At the same time, I would not want to inconvenien
11:38:59 <cads> ce GPL users who don't really have a say in what the GPL is.. I don't know if a license made specifically un-usurp-able by the GPL will have to do that though.
11:38:59 <conal> rwbarton: one that bugged me for a while was lack of curried constraints: Foo a => Bar b => ...
11:39:08 <conal> rwbarton: i think that one got fixed.
11:39:40 <rwbarton> :t let x :: Num a => Ord a => a; x = 3 in x
11:39:42 <pumpkinbot> parse error on input `=>'
11:39:57 <rwbarton> works in 6.11
11:40:12 <conal> cads: i'd love to hear what you come up with and your distilled insights along the way.  perhaps as a comment to http://conal.net/blog/posts/seeking-advice-on-software-licensing/
11:40:57 <Gracenotes> @pl \bool1 bool2 a b -> (bool1 bool2 (\c d -> d)) a b
11:40:57 <pumpkinbot> flip flip (const id)
11:41:32 <Gracenotes> @pl \bool1 bool2 a b -> (bool1 (\c d -> c) bool2) a b
11:41:33 <pumpkinbot> ($ const)
11:41:45 <Gracenotes> @unpl flip flip (const id)
11:41:45 <pumpkinbot> (\ c f -> c f (\ _ h -> h))
11:42:00 <Gracenotes> @unpl ($ const)
11:42:00 <pumpkinbot> (\ b -> b (\ a _ -> a))
11:42:14 <Gracenotes> hm, interestingish..
11:42:44 <cads> in general, in a monad m a, bind takes a function from the monad's base type a into another monad, m b, and uses it to map a monad value m a into the monad m b. It does this in a way that is more complicated than extracting the value a then applying (a->m b) on it, right?
11:43:19 <rwbarton> cads: what do you mean "extracting the value a"?
11:43:49 <cads> err, rather, ...more complicated than simply copying out the value a
11:44:33 <rwbarton> cads: the type m a might "contain" many values of type a, or none, or be something else altogether (m = Cont)
11:44:38 <cads> I am not a little fuzzy about what form the value a takes while it's in the monad m a
11:44:54 <cads> ahah
11:44:57 <rwbarton> That's entirely dependent on m
11:45:11 <edwardk> cads: in general i just suck it up and write stuff as bsd licensed or lgpl with a linking exception.
11:45:19 <Gracenotes> cads: sometimes the function might not ever be called. e.g. for a Maybe monad that turns up Nothing
11:45:27 <cads> rwbarton:  to use a hiltonism, "that's hot" :)
11:45:53 <skorpan> when i import a module of mine which has #ifdef stuff in the .hs file but has been compiled, it still seems to load the .hs file. is there any way to force it to load the compiled module?
11:46:02 <ozy`> :t \x -> case x of {}
11:46:03 <pumpkinbot> parse error on input `}'
11:46:59 <mathijs> Hi all, is there some work underway to get ghc use some mathematical/logical rules? I mean 'filter (\x -> x^2 < 100)' will execute faster when ghc translates it to 'filter (\x -> x < 10)'. Also x `mod` 2 just needs to check the last bit of a number. And 'filter (<100) $ quicksort xs' can be improved to 'takeWhile (<100) $ quicksort xs' if ghc somehow recognizes that 'quicksort xs' is ordered. Al these optimizations would be possible at compile-t
11:47:09 <rwbarton> cads: for example if m = [] then there are several values of type a in the m a argument.  You can apply the a -> m b function to each, but then you need a way of turning all that stuff into a single list of b's.
11:47:22 <Cheshire> mathijs, why do you just repeat the same thing every day?
11:47:31 <Cale> mathijs: no.
11:47:54 <drhodes> is there a nice cmd line way of searching hackage?
11:48:06 <Cale> mathijs: you can however used RULES pragmas to add specific transformations
11:48:12 <Cale> use*
11:48:28 <conal> mathijs: and careful with negative numbers.
11:48:32 <mathijs> Cheshire: sorry for that. I normally get nice & clear responses in here, and people seem to know almost everything. I never got a response to this question, so I thought I'd ask it every now & then.
11:48:40 <edwardk> mathijs: first problem your first simplification fails, you'd need to take the absolute value of x. the quicksort example would be a good use for RULES though
11:48:48 <Gracenotes> > (\x -> x^2 < 100) (-3092)
11:48:49 <pumpkinbot>   False
11:48:53 <Gracenotes> > (\x -> x < 10) (-3092)
11:48:54 <pumpkinbot>   True
11:49:28 <mathijs> Cale, edwardk: cool. I'll look into that.
11:49:33 <conal> mathijs: i'm sorry to hear it took you a few tries to get an answer.  i'm glad you persisted.
11:49:53 <cads> conal, edwardk, really I'd love nothing more than to find out that you can release software under a "fuck you, copyrights" license that'll prevent your code from being stolen due to bad legal juju, but requires you to publish under an anonymized to avoid same legal juju... I have a feeling that I have a contradiction in terms that makes the whole idea just a paranoiac flight of fancy. Conal, I'll look for a reasonable license, too :)
11:49:57 <conal> mathijs: and i'd suggest RULES also.
11:50:03 <edwardk> mathijs: plus, you also have to be careful in those cases that you know what Num instance you are working with. you can get some pretty radical answers for those in other instances.
11:50:18 <mathijs> conal: no problem :)  If I was in a hurry, I would have tried a mailing list or something.
11:50:29 <conal> mathijs: :)
11:50:37 <Olathe> @bot
11:50:38 <pumpkinbot> :)
11:50:38 <lunabot>  :)
11:50:40 <edwardk> mathijs: finally, some Num's don't permit a lot of algebraic simplification. For instance you can do VERY few things to floats and safely preserve all of the corner cases.
11:51:23 <Cale> mathijs: One problem with applying mathematical rules is that very few mathematical rules actually apply to things like floating point numbers, and code which is polymorphic could happen to use Float/Double.
11:51:23 <mathijs> edwardk: I'm afraid of floats anyway :)  since I ran into [0.1,0.3..1]
11:51:31 <Cale> (at least, in terms of arithmetic)
11:51:38 <edwardk> > [0.1, 0.3..1]
11:51:40 <pumpkinbot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
11:52:03 <cads> rwbarton: what I was wondering is how do we keep track of our bind functions, if we have a bind from monad m a to m b, one from m a to m a, m a to m c, and so on... is it simple type inferrence based on the type b in the (a -> m b) function we give to bind?
11:52:07 <conal> edwardk: the float case can also be looked at from another perspective: the original (pre-transformed) program might be incorrect as well.
11:52:21 <bastl> how can i obtain the path where my program resides? the binary lies next to the glade file using a relative path to the glade file means i cannot start the program from elsewhere ...
11:52:38 <conal> edwardk: i.e., we might be looking for an equivalent float program, or another program that approximates the same ideal real computation.
11:52:54 <rwbarton> cads: it's a single polymorphic function no matter what the "value" type is.
11:52:56 <rwbarton> @src Monad
11:52:57 <mathijs> ok, but maybe some logic stuff might fit into RULES... I'll just experiment with it. The thing is... maybe it's better to just think about the code instead of letting the compiler clean up.
11:52:57 <pumpkinbot> class  Monad m  where
11:52:57 <pumpkinbot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:52:57 <pumpkinbot>     (>>)        :: forall a b. m a -> m b -> m b
11:52:57 <pumpkinbot>     return      :: a -> m a
11:52:57 <pumpkinbot>     fail        :: String -> m a
11:53:01 <ozy`> are Doubles arbitrary-precision?
11:53:09 <rwbarton> cads: notice how m is a parameter of the class but a and b are not
11:53:12 <Gracenotes> no
11:53:18 <Cale> ozy`: No, they're basically IEEE double precision.
11:53:20 <int-e> . o O ( their precision is quite arbitrary )
11:53:32 <ozy`> Cale: yeah that's what I thought
11:54:03 <ozy`> are arbitrary-precision numbers exposed as a type in Base?
11:54:19 <ozy`> they're not in Prelude at all, right?
11:54:22 <Olathe> @where CReal
11:54:22 <pumpkinbot> I know nothing about creal.
11:54:25 <Olathe> Bah.
11:54:28 <edwardk> conal: or it may be performing an exact sequence of instructions for correctness sake. if i spot a + (b - a) `div` 2, i might be tempted to rewrite it to (a + b) `div` 2, but then screw up binary searches when dealing with more than 2 billion entries. ;)
11:54:31 <ozy`> @hoogle CReal
11:54:31 <pumpkinbot> No results found
11:54:32 <Olathe> @where lambdabot
11:54:32 <pumpkinbot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:54:45 <Gracenotes> it's from the numbers package iirc
11:54:52 <mathijs> ozy`: even with arbitrary-precision numbers it might be impossible to represent base10 floats.
11:54:57 <bastl> how can i print the path where the compiled binary resides?
11:55:13 <edwardk> conal: in general i just assume i can't reorder squat unless i can prove it ;)
11:55:24 <Cheshire> bastl, isn't "." sufficient?
11:55:24 <koeien> bastl: i don't know if this is possible in general
11:55:25 <conal> edwardk: yeah!  i'd like to get these different semantics clarified, so we don't have to guess about them based merely on code.
11:55:26 <ozy`> mathijs: then they're not really arbitrary precision, are they?
11:55:32 <roconnor> @hackage numbers
11:55:33 <pumpkinbot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
11:55:36 <roconnor> ozy`: ^^
11:56:12 <conal> edwardk: in other words, what the code means, not just what code it is equivalent to.
11:56:39 <bastl> a
11:56:40 <mathijs> ozy`: well if they 'loop' infinately behind the decimal separator the precision doesn't help much.
11:56:44 <Gracenotes> ozy`: can you represent 0.1 as an arbitrary precision binary float?
11:57:07 <sauf_> > [0.1,0.3..1]::[CReal]
11:57:08 <pumpkinbot>   [0.1,0.3,0.5,0.7,0.9]
11:57:10 <edwardk> as conal whips out his golden hammer with "denotational semantics" scrawled on the side. ;)
11:57:21 <ozy`> I should amend my stuff or something
11:57:23 * Badger flees!
11:57:37 <ozy`> I'm really asking about arbitrary-precision base 10 numbers
11:57:55 <Cheshire> ozy`, base is just about the presentation of a number
11:58:07 <Gracenotes> sauf_: that's to do with the showCReal method, I think
11:58:08 <mathijs> sauf_: that's interresting. is there a reason not to use CReal's instead of floats?
11:58:28 <sauf_> slower, I think
11:58:33 <rwbarton> > [0.1,0.3..1.01] :: [CReal]
11:58:35 <pumpkinbot>   [0.1,0.3,0.5,0.7,0.9]
11:58:43 <roconnor> ozy`: what is the question?
11:59:07 <cads> rwbarton: does that mean that one bind function in a concrete instance of Monad can take, for _any_ b, a function of type (a -> m b) and apply it?
11:59:13 <ozy`> Cheshire, roconnor... never mind >_>
11:59:18 * roconnor thinks Float and Double shouldn't be part of Enum.
11:59:29 <augustss> ozy`: arbitrary-precision decimal is not a good way to represent real numbers.  (if by arbitrary-precision decimal you mean an arbitrary long list of decimals)
11:59:40 <rwbarton> cads: yes, precisely.  It has to be polymorphic in b.  (And a, as well.)
11:59:48 <Peaker> @type (>>=)
11:59:49 <pumpkinbot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:00:04 <Peaker> cads: This is what (>>=) already does for all monads, no?  (forall b. ....)
12:00:14 <roconnor> augustss, ozy` it might not be a good way, but it has been done in the BigFloat package.
12:00:34 <roconnor> augustss: er, not your big float
12:00:44 <ozy`> augustss: right, the best thing to do is to handle real-number comparisons in a more intelligent way. still, they're useful once every couple of years :p
12:00:48 <ozy`> roconnor: gotcha
12:00:48 <augustss> roconnor: I think it's a good idea if you know how many digits you want beforehand
12:01:19 <cads> Peaker: I'm still on bind and unit and lift - styled babyfood... the haskell formalism using existential types and classes and do notation is a bit beyond me
12:01:26 <augustss> ozy`: real numbers cannot be compared (and always terminate)
12:01:31 <cads> but I think it's sinking in
12:01:34 <Gracenotes> > do { x <- [1..3]; y <- [1..3]; xy <- return (x,y); return (xy,xy) }
12:01:35 <pumpkinbot>   [((1,1),(1,1)),((1,2),(1,2)),((1,3),(1,3)),((2,1),(2,1)),((2,2),(2,2)),((2,...
12:01:36 <Cheshire> > exp pi (exp 1) < (exp (exp 1) pi :: CReal)
12:01:37 <pumpkinbot>       No instance for (Floating (t -> CReal))
12:01:37 <pumpkinbot>        arising from a use of `p...
12:01:40 <rwbarton> ozy`: Data.Fixed has arbitrary (but fixed per-type) precision decimal representation.
12:01:48 <ozy`> augustss: I guess if you do know how many digits you need, you can back it with an integer type and go from there
12:02:05 <Peaker> cads: ah. Well, I meant to say that bind (>>=) always takes a function from a to any b at all
12:02:05 <Cheshire> > pi**exp 1 < (exp 1**pi :: CReal)
12:02:06 <pumpkinbot>   True
12:02:08 <ozy`> @hackage Data.Fixed
12:02:08 <pumpkinbot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Data.Fixed
12:02:12 <roconnor> ozy` augustss: this is the big float I was refering to: http://medialab.freaknet.org/bignum/
12:02:17 <Cheshire> > (pi**exp 1, (exp 1**pi :: CReal))
12:02:18 <rwbarton> ozy`: it's in base
12:02:19 <pumpkinbot>   (22.45915771836104,23.1406926327792690057290863679485473802661)
12:02:23 <ozy`> gotcha
12:02:27 <Gracenotes> > do { x <- [1..3]; y <- [1..3]; let { xy = (x,y) }; return (xy,xy) }
12:02:28 <pumpkinbot>   [((1,1),(1,1)),((1,2),(1,2)),((1,3),(1,3)),((2,1),(2,1)),((2,2),(2,2)),((2,...
12:02:48 <roconnor> Cheshire: those numbers are quite different
12:02:51 <roconnor> oh
12:02:54 <Gracenotes> hm. I guess the let is preferred to the pointless binding
12:02:56 <roconnor> different expressions :P
12:03:15 <cads> rwbarton, Peaker, I thank you for the lessons: I must meditate on these things :D
12:03:44 <Peaker> cads: after it sinks in, you realize how simple it all really is :)
12:03:52 <Cheshire> roconnor, Can you make a haskell library from your proofs?
12:03:52 <tromp_> if anyone here is up for a mathematical challenge, see http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/February2009.html
12:03:59 <Gracenotes> was the motivation of using "exp 1" instead of "e" due to the fact that e might be commonly used?
12:04:13 <cads> it's time to stop playing with mah-nads informally in pen and paper, and write some haskell code, at long last
12:04:56 <ozy`> Gracenotes: probably. you can always write "e = exp 1" in a module where you need it though
12:04:58 <Cheshire> and programs
12:05:16 <roconnor> Cheshire: in theory
12:05:25 <augustss> Gracenotes: and you dont need e that often
12:05:36 <Gracenotes> yeah
12:05:40 <Cheshire> roconnor, still it's broken with the unsafeCoerce stuff?
12:05:41 <augustss> Gracenotes: you usually want e**x
12:06:12 <Gracenotes> I'm surprised about how nice Haskell is as a math prompt :)
12:06:20 <Gracenotes> well, except for matrix support
12:06:32 <augustss> Gracenotes: add some :)
12:06:35 <Gracenotes> there is a matrix package though
12:07:09 <ozy`> proper matrix support really demands dependent typing
12:07:20 <Cheshire> ozy`, why does it?
12:08:01 <ozy`> Cheshire: because that's the only sensible way to get the benefits of static typing with a matrix type
12:08:15 <Cheshire> ozy`, but I am wondering why
12:08:17 <koeien> Cheshire: because you can get a compile time error for incompatible dimensions
12:08:36 <Cheshire> koeien, you can already do that in haskell
12:08:41 <Gracenotes> well, one can make an array of (Int,Int)
12:08:41 <koeien> it is not always possible though
12:08:49 <Cheshire> when is it not possible?
12:08:58 <augustss> Cheshire: the Haskell array function has type  array :: (Ix i) => (i,i) -> ... -> Array i a
12:08:59 <koeien> if you depend on user input
12:09:00 <roconnor> Gracenotes: diff (\x->x**x)  x
12:09:17 <augustss> Cheshire: But the type of the array should really reflect the size
12:09:19 <Gracenotes> roconnor: eek :X
12:09:43 <roconnor> Cheshire: I think the unsafeCoerce stuff is still broken.
12:09:44 <Cheshire> augustss, I've seen a Matrix :: * -> * -> * -> * somewhere, which has got element type as well as dimensions
12:09:49 <Gracenotes> augustss: having different types fo 2x2 and 3x3, for instance?
12:09:52 <roconnor> > diff (\x->x**x)  x
12:09:53 <pumpkinbot>   mueval: Prelude.read: no parse
12:09:54 <Gracenotes> *for
12:09:59 <roconnor> damn
12:10:02 <roconnor> no lambdabot
12:10:08 <augustss> Gracenotes: all dimensions will have different types
12:10:08 <ozy`> Gracenotes: exactly
12:10:11 <Cheshire> ozy`, do you have any concrete example of when it is not possible?
12:10:15 <rwbarton> , diff (\x->x**x) 5
12:10:16 <lunabot>  luna: Not in scope: `diff'
12:10:26 <ozy`> Cheshire: I didn't say it was impossible... just inconvenient.
12:10:48 <Cheshire> ok I misinterpret "demands"
12:10:52 <augustss> Cheshire: you can make the size part of the Array (Matrix) type.  But then you can no longer create array of varying size in a convenient way
12:10:53 <Cheshire> as "requires"
12:10:54 <dancor> i don't see why this applies to matrices in particular
12:11:04 <arcatan> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022590.html why does this work?
12:11:04 <dancor> there isn't ListLen2 ListLen3 etc
12:11:16 <mathijs> I read the info about RULES and it seems to be in the direction of my original question. One thing though... will RULES always apply? (acting as a highly advanced on-the-fly search-and-replace)? or will the compiler just use/try them to see if they produce shorter/faster code?
12:11:16 <ozy`> Cheshire: in this case, matrices don't always get what they need ;)
12:11:21 <augustss> > deriv (\ x -> x**x) x
12:11:22 <pumpkinbot>   (1 * recip x * x + log x * 1) * exp (log x * x)
12:11:30 <roconnor> oh right
12:11:31 <roconnor> deriv
12:11:40 <augustss> > deriv (join (**)) x
12:11:41 <pumpkinbot>   (1 * recip x * x + log x * 1) * exp (log x * x)
12:11:52 <dancor> @src deriv
12:11:53 <pumpkinbot> Source not found. I've seen penguins that can type better than that.
12:11:53 <Cheshire> arcatan, you have to pull !! out
12:11:57 <dancor> :t deriv
12:11:59 <pumpkinbot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
12:12:07 <Gracenotes> > deriv (\x -> x*x/x) x
12:12:08 <pumpkinbot>   (1 * x + x * 1) * recip x + x * x * negate (1 * recip x * recip x)
12:12:19 <Gracenotes> a lovely formula, of course ;)
12:12:44 <arcatan> Cheshire: i mean.. there isn't any explicit memoization, so where does the memoization happen?
12:12:52 <ozy`> I don't think lists should ever be fixed-length... that defeats the purpose of lists. there should be a nicer N-dimensional vector type, though
12:13:26 <dancor> ozy`: fine vector
12:13:54 <Gracenotes> are the benefits for having sizes-as-types checking if, say, a multiplication can be done at compile time?
12:14:02 <ozy`> Gracenotes: yes
12:14:09 <ozy`> that's one such benefit
12:14:22 <Gracenotes> of course, in addition to having a 2by2 type, you might have to have a, say, nby2 type
12:14:29 <augustss> Gracenotes: you can avoid runtime errors
12:14:34 <rwbarton> arcatan: would it be clearer if it was written  memoized_fib = (x !!) where x = map fib' [0..] ; fib' 0 = 0 ; ... ?
12:14:38 <Gracenotes> which can be multiplied with a 2bym
12:14:38 <Cheshire> that sounds more like staging than expressive types
12:14:54 <dancor> don't you need to trade-off certain things to have fully-checked compile-time dependent type checking?
12:14:55 <Cheshire> Gracenotes ^
12:15:01 <Gracenotes> however, you shouldn't be able to do 2bym times nby2
12:15:05 <rwbarton> Gracenotes: another benefit is that you could write 1 for the identity matrix, and its dimensions would be inferred for you
12:15:09 <edwardk> Gracenotes: re the haskell as a mathematics console. hrmm i wonder what one could do with a ghci texmacs interface and some sugar for matrices
12:15:15 <Cheshire> dancor, what do you mean?
12:15:20 <dancor> doesn't your lang have to be total or something
12:15:43 <Gracenotes> hm.
12:15:44 <augustss> dancor: the trade-off is that type checking gets more difficult, so sometimes you have to provide proofs yourself to help the typechecker
12:15:51 <dancor> augustss: yeah
12:15:56 <dancor> that's a _big_ tradeoff imho
12:16:02 <dancor> for just doing practical coding
12:16:05 <edwardk> i seem to recall the protocol for texmacs is pretty straightforward
12:16:21 <Gracenotes> most matrix libraries I've seen don't require that sort of rigorousness :)
12:16:32 <augustss> dancor: but you'd only have to do it when you do something that is out of the ordinary
12:16:34 <Cheshire> dancor, How difficult is it to prove something?
12:16:39 <Gracenotes> it's more garbage in-garbage out
12:16:56 <edwardk> gracenotes: i'm just thinking a more mathematica like ghci experience
12:17:00 <arcatan> rwbarton: hmm, yeah
12:17:17 <augustss> I think most matrix like type checking can be done with just some decision proceduers
12:17:19 <Gracenotes> ah, I see
12:17:19 <dancor> Cheshire: first prove there's an answer to that question
12:17:29 <Cheshire> dancor, *sigh*
12:17:39 <pumpkin> edwardk: I'd like that
12:17:51 <Cheshire> augustss, I guess that is what DML does
12:18:03 <Gracenotes> as a sort of GHCI extension, if that's possible
12:18:07 <augustss> Cheshire: yes
12:18:32 <rwbarton> arcatan: (x !!) is really just (!!) x, so what I wrote is equivalent to the version in the post
12:18:39 <edwardk> hrmm. it might just work as a small plugin for texmacs and a couple of haskell libraries
12:19:05 <rwbarton> arcatan: (in particular (x !!) is *not* (\y -> x !! y), operationally speaking, when x is a complicated formula)
12:19:12 <lament> I'm getting an error "lexical error at character 'i'" at the first #if. Is it ok to have an #if in a .hs file? Shouldn't it be hsc?
12:19:28 <Gracenotes> edwardk: we might not get as sophisticated an integration suite as Mathematica's, though :P
12:19:43 <edwardk> add the embedded postscript rendering support they have and one of the existing imaging libraries and you might be able to scribble out quick charts and stuff
12:19:45 <augustss> lament: you need -XCPP
12:20:09 <rwbarton> edwardk: have you looked at SAGE?  I haven't... but it seems like it wants to live in a dependently-type language
12:20:11 <edwardk> Gracenotes: i'm looking for something on par with its support for yacas or octave or something
12:20:42 <lament> augustss: thanks
12:20:47 <kau> hello, where is lambdabot?
12:21:11 <Gracenotes> edwardk: lots of symbolic support, then :)
12:21:13 <pumpkin> kau: not sure :)
12:21:17 <edwardk> rwbarton: a while ago. long ago i was obsessed with rich text programming languages.
12:21:44 <kau> on strike?
12:22:37 <pumpkin> kau: maybe
12:22:41 <pumpkin> it was tired of fixing id
12:22:54 <kau> does pumpkinbot supports let statements?
12:23:03 <kau> > let a=1
12:23:03 <pumpkin> pumpkinbot is lambdabot
12:23:03 <pumpkinbot>   mueval: Prelude.read: no parse
12:23:10 <pumpkin> that isn't valid in lambdabot either :P
12:23:14 <pumpkin> > let a=1 in a
12:23:15 <pumpkinbot>   1
12:23:26 <kau> hu ok
12:23:31 <pumpkin> @let a_prime = 5
12:23:32 <pumpkinbot>  Defined.
12:23:40 <kau> ok thanks!
12:23:42 <pumpkin> if you @let a, it'll conflict with the simplereflect a
12:23:56 <sauf_> edwardk: I kwow that Sage undertands Python and javasript in order to access octave, scipy, numpy, pari-gp ... and finally to look like mathematica
12:25:28 <Gracenotes> > let e' = e in let e = exp 1 in (e, e')
12:25:29 <pumpkinbot>   (2.718281828459045,e)
12:25:31 <augustss> > let (++) + ((+) + 1) = (+) in 1 + 2
12:25:32 <pumpkinbot>   1
12:25:47 <Gracenotes> > let e' = e; e = exp 1 in (e, e')
12:25:48 <pumpkinbot>   (2.718281828459045,2.718281828459045)
12:26:17 <kau> i came across a function that doesn't terminate (or crashes ghci.exe, or do stack overflow depending on the system) and i can't figure out why
12:26:24 <kau> @let ls = map ((+)1 . sum) (inits ls)
12:26:25 <pumpkinbot>  <local>:4:0:
12:26:25 <pumpkinbot>      Multiple declarations of `L.ls'
12:26:25 <pumpkinbot>      Declared at: <local>:...
12:26:33 <sauf_> edwardk: (the LateX rendering is beautiful on Firefox)
12:26:35 <kau> @let lmy = map ((+)1 . sum) (inits my)
12:26:35 <pumpkinbot>  <local>:4:30: Not in scope: `my'
12:26:40 <kau> @let lmy = map ((+)1 . sum) (inits lmy)
12:26:41 <pumpkinbot>  Defined.
12:26:56 <Cale> kau: That's an infinite loop.
12:27:07 <Cale> er...
12:27:09 <Cale> > lmy
12:27:14 <kau> why?
12:27:24 <pumpkinbot>   thread killed
12:27:27 <kau> the first value of inits is allways []
12:27:38 <rwbarton> @src inits
12:27:38 <pumpkinbot> inits []     =  [[]]
12:27:38 <pumpkinbot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
12:27:49 <Cale> > inits undefined
12:27:50 <pumpkinbot>   mueval: Prelude.read: no parse
12:27:50 <pumpkinbot>  mueval: *** Exception: Prelude.undefined
12:27:51 <rwbarton> yes, but the library authors made it strict
12:28:05 <rwbarton> Ironically because they were too lazy :)
12:28:06 <lament> augustss: thanks
12:28:12 <kau> oupss
12:28:19 <kau> too bad
12:28:25 <Cale> That is somewhat unfortunate, yeah...
12:28:29 <kau> is there a lazy version?
12:28:36 <rwbarton> > let inits' x = [] : case x of [] -> []; (y:ys) -> map (y:) inits' ys
12:28:37 <pumpkinbot>   mueval: Prelude.read: no parse
12:28:38 <rwbarton> @let inits' x = [] : case x of [] -> []; (y:ys) -> map (y:) inits' ys
12:28:39 <pumpkinbot>  Couldn't match expected type `[[t]]'
12:28:45 <Gracenotes> :x
12:28:46 <rwbarton> @let inits' x = [] : case x of [] -> []; (y:ys) -> map (y:) (inits' ys)
12:28:47 <pumpkinbot>  Defined.
12:28:48 <edwardk> sauf: my old rich text obsession took the form of writing the editor inside firefox using mathml and lots of xul to glue it together. finally gave up because of bugs in mathml rendering on macs that they apparently had/have no intention of fixing
12:28:54 <augustss> inits need to be changed
12:28:54 <rwbarton> > inits' (3:4:undefined)
12:28:58 <pumpkinbot>   mueval: Prelude.read: no parse
12:29:00 <pumpkinbot>  mueval: [[],[3],[3,4]*** Exception: Prelude...
12:29:08 <rwbarton> There.
12:29:10 <kau> oh great
12:29:30 <kau> @let lmy = map ((+)1 . sum) (inits' lmy)
12:29:31 <pumpkinbot>  <local>:6:0:
12:29:31 <pumpkinbot>      Multiple declarations of `L.lmy'
12:29:31 <pumpkinbot>      Declared at: <local>...
12:29:47 <kau> how to redeclare?
12:30:05 <dancor> @help let
12:30:05 <pumpkinbot> let <x> = <e>. Add a binding
12:30:13 <sauf_> edwardk: you can test Sage online but I think you have to have it on your computer to get Latex working
12:30:13 <int-e> > fix (map ((+)1 . sum) . inits')
12:30:14 <pumpkinbot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
12:30:26 <edwardk> hrmm it looks like it wouldn't be that bad to modify tmPython. http://dkbza.org/tmPython.html
12:30:30 <int-e> > fix (scanl (+) 1)
12:30:31 <pumpkinbot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
12:30:42 <int-e> > fix ((0:) . scanl (+) 1)
12:30:43 <sauf_> edwardk: I will give you the link in a moment...
12:30:43 <pumpkinbot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:30:43 <dancor> @undefine lmy
12:30:46 <edwardk> (which is the same thing that the texmacs sage plugin is based on)
12:31:00 <dancor> @let lmy = map ((+)1 . sum) (inits' lmy)
12:31:00 <pumpkinbot>  <local>:1:24: Not in scope: `inits''
12:31:06 <kau> @src fix
12:31:06 <pumpkinbot> fix f = let x = f x in x
12:31:10 <cads> conal, what kind of work in 3d rendering are you doing?
12:31:18 <edwardk> sauf: i've poked around at it back in the day. i'm just thinking it'd be nice to be able to do more from the ghci commandline.
12:31:25 <edwardk> sauf: hence my thought process
12:31:41 <sauf_> here it is :
12:31:42 <sauf_> http://www.sagenb.org/
12:31:43 <kau> @src scanl
12:31:43 <pumpkinbot> scanl f q ls = q : case ls of
12:31:43 <pumpkinbot>     []   -> []
12:31:43 <pumpkinbot>     x:xs -> scanl f (f q x) xs
12:31:44 <bastl> can it be that if i use "s" immediatly after s <- readFile "somePath", that "s" is not fully populated !?
12:32:06 <int-e> > scanl (flip (:)) [] [1..4]
12:32:07 <pumpkinbot>   [[],[1],[2,1],[3,2,1],[4,3,2,1]]
12:32:48 <dolio> > scanr (:) [] [1..4]
12:32:49 <pumpkinbot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
12:33:20 <rwbarton> @src tails
12:33:20 <pumpkinbot> tails []         = [[]]
12:33:20 <pumpkinbot> tails xxs@(_:xs) = xxs : tails xs
12:33:24 <rwbarton> > tails [1..4]
12:33:25 <pumpkinbot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
12:33:39 <sauf_> edwardk: I think Haskell could be very helpful too in that direction. But it may be long until what is done in Sage can be reached ...
12:33:45 <mrd> what happened to lambdabot?
12:33:54 <Badger> @seen lambdabot
12:33:55 <pumpkinbot> I saw lambdabot leaving #haskell and #haskell.it 3h 25m 55s ago, and .
12:34:04 <byorgey> bastl: well, readFile is lazy.
12:34:24 <byorgey> bastl: so technically, immediately after  s <- readFile "somePath", s is just a thunk, and the file hasn't been read at all.
12:34:48 <byorgey> bastl: so don't try to do anything crazy like overwrite "somePath" =)
12:34:51 * dancor uses a readFileStrict usually bc readFile is such a pain
12:35:09 <Cheshire> byorgey, how strange! I wonder if that's a design decision
12:35:18 <byorgey> Cheshire: it is, indeed.
12:35:18 * rwbarton uses readFile usually because readFile is so awesome
12:35:29 <Cheshire> byorgey, it seems to violate purity
12:35:29 <sauf_> edwardk: we need real mathematicians without whom the math structure would be lame
12:35:57 <byorgey> Cheshire: it means that you can process an entire file without having the whole thing in memory at once, but without having to manually write code to process it in buffered chunks.
12:35:59 <bastl> i just parse somePath, but _my_ parser fails (whereas the the same file parses correctly with the demoparser that comes with bnfc)
12:36:22 <byorgey> Cheshire: well, it does lead to some rather strange situations, sometimes.  there are those who argue that it's a horrible idea.
12:36:43 <byorgey> Cheshire: personally, I think it's great, but then again, I never do any programs that do serious I/O.
12:37:24 <bastl> the demo parser does something like readfile f >>= parse
12:38:04 <byorgey> bastl: that should work fine.  if 'parse' needs the whole file, the whole file will be read.
12:38:12 <byorgey> bastl: sounds more like a bug in your parser.
12:38:26 <bastl> strange
12:38:40 <thoughtpolice> lazy IO can be tremendously useful sometimes for e.g. uzing a bytestring to quickly load a huge file or something. it's arguable that iteratees are better and lazy IO of this manner is a complete theoretical monstrosity, but, sometimes it is useful.
12:39:07 <byorgey> oh, there's no question that lazy IO is a theoretical monstrosity =)
12:39:16 <Cheshire> most "pragmatic" stuff has got better simpler solutions but there is some theoretical monostroty is mainstream use
12:39:18 <thoughtpolice> iteratee's are really just a way to process stuff in buffered chunks
12:39:31 <thoughtpolice> s/'s/s/
12:39:46 <byorgey> Cheshire: right.  it's interesting, though, because Haskell *usually* picks the theoretical over the pragmatic.
12:40:21 <thoughtpolice> we stick to the guns: purity and laziness. :)
12:40:27 <Cheshire> I think pragamism is usually just an excuse.. and not /actual/ pragmatism
12:40:35 <mmorrow> even when they conflict?
12:40:35 <skorpan> can i tell runghc or ghci to give *.hs lower precedence in the search order?
12:40:47 <mmorrow> (don't answer that :)
12:41:00 <skorpan> i'm confused. was that for me?
12:41:05 <mmorrow> no, @thoughtpolice
12:41:07 <byorgey> mmorrow: that's exactly why IO is problematic =)
12:41:31 <mmorrow> indeed
12:41:44 <hackage> Uploaded to hackage: HDBC-odbc 2.1.0.0
12:41:44 <hackage> Uploaded to hackage: HDBC-postgresql 2.1.0.0
12:41:44 <hackage> Uploaded to hackage: HDBC-sqlite3 2.1.0.0
12:41:44 <hackage> Uploaded to hackage: HDBC 2.1.0
12:42:00 <thoughtpolice> either way I don't hate readFile or anything
12:42:13 <monochrom> IO is not problematic if you make it eager. This has no conflict with non-IO being lazy. Think of IO as the triggerer of evaluations.
12:42:14 <mmorrow> readFile's nice in ghci for sure
12:42:21 <conal> IO is imperative programming.
12:42:40 <Cheshire> conal, lazy imperative programming (due to this readFile buisness)
12:42:56 <dancor> yeah i think IO should be strict by default
12:43:03 <conal> it's nice to manipulate imperative computations as first class things.  and the semantics are just as problematic as they are in other languages.
12:43:09 <dancor> currently readFile is lazy for String and strict for ByteString
12:43:14 <dancor> that is _not_ straight-forward
12:43:20 <conal> fortuntately, the functional stuff is mostly shielded
12:43:23 <mmorrow> conal: i'm confused, do you mean that all interaction with the outside world is necessarily imperative programming?
12:43:34 <rwbarton> dancor: it's strict for strict ByteString and lazy for lazy ByteString
12:43:37 <bastl> :-)
12:43:47 <rwbarton> (I don't know if that's any more or less "straightforward")
12:43:50 <dancor> hm
12:43:51 <conal> mmorrow: i don't think so.  thx for asking.
12:43:54 <dancor> it might be moreso
12:43:54 <mmorrow> or that it just is this way currently because we haven't thought of a better way?
12:44:06 <mmorrow> conal: :)
12:44:07 <conal> mmorrow: the latter
12:44:12 <mmorrow> me too
12:44:40 <conal> mmorrow: i think there was a lot of creativity in examining functional models of interaction until monadic IO was invented.
12:44:52 <rwbarton> 'interact' is interacting with the outside world, and it's not imperative programming
12:44:55 <monochrom> Interaction is message passing is not imperative programming.
12:44:55 <conal> mmorrow: which was convenient enough to tolerate.
12:44:59 <rwbarton> Granted, it's not a very general form of interaction
12:45:18 <mmorrow> conal: hmm, interesting. what would be a lead for more info on this?
12:45:24 <conal> rwbarton: interact can be nicely generalized.  see TV.
12:45:38 <conal> mmorrow: on pre-monadic creative thinking?
12:45:41 <mmorrow> yes
12:46:07 <conal> mmorrow: probably the first imperative monadic papers would give some pointers.
12:46:12 <mmorrow> i noticed in the gopher prelude (that dons uploaded to hackage the other day) they've got an alternative to monadic IO
12:46:21 <mmorrow> conal: ah, good idea
12:46:29 <augustss> conal: indeed, there was a lot of IO thinking going on before monads.  no real solutions, though
12:47:01 <conal> augustss: i agree.  we hadn't gotten there.  my disappointment is that after monadic IO, i don't see the search continuing.
12:47:31 <vegai> is monadic IO very innovative, either?
12:47:39 <augustss> conal: as you said, we got something tolerable
12:47:48 <vegai> it's pretty much the old stuff, albeit better isolated
12:47:49 <conal> augustss: the adequate is the enemy of the great.
12:48:13 <Peaker> "perfect is the enemy of good enough"
12:48:19 <Peaker> (and vice versa)
12:48:26 <mmorrow> oops, i meant "gofer"
12:48:27 <mmorrow> http://hackage.haskell.org/packages/archive/gofer-prelude/2.30.2/doc/html/Prelude-Gofer.html#t%3ARequest
12:48:37 <Cheshire> conal, I thought conal was looking for a better solution to IO? :p
12:48:38 <conal> vegai: IO was a clever/innovative way to embrace imperative programming rather than finding an alternative.
12:48:38 <Peaker> vegai: if its better than the old stuff, surely that's innovative? :)
12:48:41 <dancor> is it true that any IO is going to be manipulating some World?  if so and IO just acts like a magic State monad for that, then i'm not sure how much different/better things can get?
12:48:49 <edwardk> sauf: i'm mostly looking to just be able to plot a few functions from haskell, not reinvent a computer algebra system. my ambitions in that direction have been tabled for years ;)
12:48:50 <mmorrow> (for a second there i thought it had disappeared off of hackage, and suspected a monadic conspiracy)
12:48:52 <conal> Cheshire: you bet i am!
12:48:58 <Cheshire> great!
12:49:10 <drhodes> is there a number theory package with isPrimes?
12:49:22 <Peaker> conal: and a good thing it is -- allowing many people to get work done while better solutions are being seeked :)
12:49:41 <Peaker> a great temporary workaround :)
12:49:55 <tromp_> @let lmy = 1 : map ((+)1 . sum) (inits lmy)
12:49:56 <pumpkinbot>  Defined.
12:49:57 <conal> Peaker: agreed.  as long as someone remembers what the original dream of FP is.
12:50:45 <baaba> > lmy
12:50:47 <pumpkinbot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
12:51:16 <ehird> lament is having this error when he builds an hSDL program, "/Users/hercules/trunk/SDL-1.2/./src/main/win32/SDL_win32_main.c:246:0: undefined reference to `SDL_main", and he refuses to ask you guys, so I'm asking you for him :-P
12:51:17 <sauf_> edwardk: ok :) To plot, I've thought about OpenGL. What do you think ?
12:51:27 <Peaker> conal: yeah.. though IO might be useful as the (internal/implementation) adaptation layer to an imperative world, even in a successful result frp world
12:51:50 <edwardk> sauf: well, in the context of the texmacs thing i was mostly just considering generating quicky inline postscript snippets.
12:52:49 <conal> Peaker: yep.  as a hidden part of the RTS, like the other imperative machinery that supports pure functional (IO-free) programs.
12:52:55 <skorpan> if i'm hacking on Data.Generics, how do i make sure my test program doesn't include the globally installed Data.Generics but only from my designated folder?
12:53:02 <sauf_> edwardk: sorry. I know nothing about *macs constellation !
12:53:37 <edwardk> sauf: context would be something like http://dkbza.org/tmPython.html
12:53:48 <edwardk> replace python] with ghci> ;)
12:54:49 <augustss> conal: I want to write the whole RTS in Haskell (some of it very imperative, of course).  I think it's a shortcoming of ghc that it has so much C.
12:54:54 <ehird> edwardk: reminds me of mathematica
12:55:06 <ehird> augustss: I agree
12:55:14 <edwardk> ehird: yeah, well, iirc mathematica was one of the first texmacs plugins
12:55:14 <conal> augustss: cool!  even the gc?
12:55:26 * ehird is working on a project that involves making haskell go All The Way Down to a degree
12:55:29 <edwardk> er had one of
12:55:35 <ehird> so obviously I support the complete expurgation of C :-)
12:55:37 <mmorrow> augustss: me too!!
12:55:42 <sauf_> edwardk: indeed, it looks nice
12:55:50 <augustss> conal: why not?  there should be a well defined subset that does no allocation.  Like Modula-3 has.
12:56:05 <ehird> augustss: can't you just do that by using ! and # everywhere?
12:56:07 <dolio> The lhc guys were talking about writing the GC in E, or whatever the intermediate language is.
12:56:13 <ehird> very carefully
12:56:18 <mmorrow> yes! i've thought about that and think it would be sooo cool.
12:56:20 <augustss> ehird: But I need guarantees
12:56:34 <ehird> augustss: Yeah... My project involves writing a memory allocator in Haskell...
12:56:41 <ehird> (That haskell itself uses)
12:56:46 <ehird> That will, be, um, fun/impossible
12:56:53 <edwardk> augustss: so in the end you need something that desugars to no let bindings and no partial applications?
12:57:34 * dancor wonders what is the most stages a self-hosting compiler has ever used
12:57:36 <augustss> edwardk: well, exactly what's allowed I'm not sure.
12:57:44 <ehird> the memory allocator will probably be the hardest part of this project
12:58:05 <ehird> I'm not sure it's _possible_ to make ghc generate cons-free code
12:58:29 <mmorrow> ehird:i don't think this allocation-free haskell could be produced by ghc
12:58:34 <augustss> ehird: well, I didn't say it was going to be possible without some language changes.
12:58:42 <ehird> mmorrow: Well doggammit if I don't give it a darn good try.
12:58:46 <augustss> s/ehird/mmorrow/
12:59:04 <ehird> I could do like the evil mangler: Mangle ghc's output to not cons.
12:59:04 <mmorrow> yeah, i'm all for doing what's necessary
12:59:09 <ehird> But, religious reasons and all that.
12:59:11 <ehird> :P
12:59:51 <dolio> You can't just mangle arbitrary haskell code like that.
13:00:45 <dolio> Any more than you could take C code that calls malloc arbitrarily and turns it into something where everything is statically allocated.
13:06:33 <noZone> "i η π", yum yum.
13:07:26 <bastl> s <- readFile "blah";parse s; fails, whereas s <- readFile; putStrLn s; parse s works fine. can someone explain that?
13:07:57 <dolio> What's the error?
13:08:04 <cads> oh thank god I'm almost caught up with the conversation
13:08:11 <bastl> the file is not fully consumed, the parse faiuls
13:08:39 <bastl> if i put a putStr inbetween, it works
13:08:44 <ozy`> bastl: putStrLn evaluates the entire string
13:09:15 <bastl> so whats wrong with te rest? wait ill put it into a pastebin
13:09:18 <ozy`> you'll wanna deepSeq s or something
13:10:27 * cads wonders just how much work has gone into mathematica's symbolics engines
13:10:32 <bastl> http://haskell.pastebin.com/m72ca9fbd
13:10:57 <cads> wolfram and co have been working on it since the early eighties, no?
13:11:35 <mmorrow> cads: i've heard that juts the integral code is 1 million+ lines
13:11:41 <mmorrow> (of C/C++)
13:11:45 <mmorrow> *just
13:11:56 <ozy`> bastl: I'm pretty sure you're being bitten by lazy evaluation.
13:11:58 <dolio> Well, if you ask some people, you can rewrite it in a weekend in OCaml.
13:12:04 <mmorrow> heh
13:12:22 <Cheshire> it's odd
13:12:29 <ozy`> @hoogle deepSeq
13:12:29 <pumpkinbot> No results found
13:12:29 <Cheshire> lambda prologs higher order unification is in C too
13:12:36 <Cheshire> and Charity is written in C
13:12:37 <bastl> ozy`: how can i avoid that? or track the error down?
13:12:44 <Cheshire> why?
13:12:56 <ozy`> bastl: evaluate the entire string before you use it
13:13:14 <mmorrow> Cheshire: i can't see any other reason than that the author wanted to
13:13:17 <cads> mmorrow: I don't see why haskell wouldn't attract maths programmers who would rather implement symbolic integration in haskell than something else, except that it's one of those problems that's no longer very interesting to mathematicians, and very exhausting to actually implement
13:13:19 <bastl> any other way besides putStrLn ?
13:13:25 <ozy`> bastl: deepSeq
13:13:33 <ozy`> I don't remember what module it's in though
13:14:01 <bastl> hoogle doesnt know it
13:14:11 <bastl> :t deepSeq
13:14:12 <edwardk> mmorrow: to be fair the integral stuff touches almost everything else they do, since its effectively heuristic search over an impossibly large problem space and it has to work over pretty much any other primitive they add
13:14:12 <pumpkinbot> Not in scope: `deepSeq'
13:14:14 <cads> I for one would love a system like mathematica, except faithfully typed.
13:14:55 <Cheshire> cads, depedent types to the rescue :p
13:15:00 <gokhan> slm ben geldim
13:15:04 <Cheshire> cads, stuff like  f : R^n -> R
13:15:10 <mmorrow> cads: i have a book on symbolic integration i got at one point. it's both tedium and abstract math rolled into a hellish package. so i think part of it is that there aren't many people that both know the math involved _AND_ that like implementing tedious things
13:15:14 <edwardk> cads: well, start writing agda modules ;)
13:15:20 <ozy`> :t rnf
13:15:22 <pumpkinbot> forall a. (NFData a) => a -> Done
13:15:26 <ozy`> there we go
13:15:37 <mmorrow> edwardk: yeah, i'd love to peek at some of the stuff that's in that code
13:15:41 <ozy`> I think I misremembered the name. dunno where I got "deepSeq" from
13:15:53 <bastl> ozy: thats for my?
13:15:55 <bastl> *me
13:15:59 <ozy`> bastl: yep
13:16:21 <bastl> :src rnf
13:16:22 <ozy`> > [1..100000] `rnf` "this should take a while"
13:16:22 <sauf_> Cheshire: R must be difficult to code with Haskell
13:16:23 <pumpkinbot>   Couldn't match expected type `[Char] -> t'
13:16:43 <edwardk> mmorrow: i'd rather have access to the understanding and motivations behind the individual snippets of code. i think the source code itself is largely an artifact. the thought process would be interesting though
13:16:50 <bastl> @src rnf
13:16:50 <pumpkinbot> Source not found. Maybe if you used more than just two fingers...
13:17:10 <ozy`> > rnf [1..100000] `seq` "this should take a while"
13:17:12 <pumpkinbot>   "this should take a while"
13:17:15 <mmorrow> edwardk: yes exactly, that's a better way to say it
13:17:22 <dolio> Heh.
13:17:32 <dolio> 100,000 isn't very big.
13:17:40 <cads> edwardk: wolfram has a book or two I think
13:17:58 <cads> I'm not talking about a new kind of science.. back before he went batty
13:18:26 <cads> basically what we need is a bunch of out of work postdocs
13:19:10 <dolio> @brain
13:19:10 <pumpkinbot> I think so, Brain, but don't you need a swimming pool to play Marco Polo?
13:19:14 <edwardk> cads: heh. ANKOS was an interesting read, but it had to be taken with a truckload of salt
13:19:18 <bastl> @hoogle rnf
13:19:18 <pumpkinbot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
13:20:00 <cads> I wonder how much of the framework of a symbolic math system could be reduced by automated means inside a dependently typed proof assistance system
13:20:13 <bastl> ozy: so rnf is just a kind of eager composition or so?
13:20:33 <Cheshire> cads, IIRC that's what depedent types are _for_
13:20:33 <cads> note that having such a system underneath things would also make your whole mathematica clone a lot more general
13:20:34 <bastl> how do i use it with io actions ?
13:20:46 <Cheshire> cads, (before us programmers got interested in them)
13:20:57 <edwardk> cads: sure, but it'd likely be a hell of a lot slower ;)
13:21:09 <cads> ah
13:21:16 <Cheshire> why would it be slower?
13:21:30 <Cheshire> just because of curent implementation techniques or something more fundamental?
13:21:32 <mmorrow> here's that symbolic integration book i have, http://www.amazon.com/Symbolic-Integration-Transcendental-Computation-Mathematics/dp/3540214933/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1233782364&sr=8-1
13:21:37 <cads> I think the proofs could compile to quick code
13:21:38 <edwardk> cheshire: have you ever done arithmetic in your average computer algebra system? ;)
13:21:50 <Cheshire> yeah it's fast
13:22:00 <Peaker> conal: Yay, I finished converting my (Draw a) monad to an Image monoid. I also needed a size, and at first tempted to put into image, but realized I cannot really define it well semantically, so decided widgets instead yield an infinite image and a size, separately
13:22:08 <cads> in the end it's a bunch of advanced group(representation) theory
13:22:19 <edwardk> cheshire: have you ever done it in your average theorem prover? =)
13:22:57 <Cheshire> edwardk, if it means adding peano numerals yeah.. if it means the same data structures and algorithms a CAS has.. no
13:23:24 <Cheshire> edwardk, just trying to type check 100000 crashes the system :p
13:23:29 <cads> edwardk: could the system be formalized in a proof system and then generate C code?
13:23:29 <conal> Peaker: :)  most people don't notice that problem.  yay for semantic design.
13:23:49 <Cheshire> cads, (this has been done except ocaml instead of C)
13:23:58 <Peaker> conal: I couldn't reconcile finite images with (move :: Position -> Image -> Image)
13:24:20 <edwardk> cheshire: just because peano arithmetic can model the naturals doesn't mean its the most efficient way. usually theorem provers tend to have fairly minimalist sets of primitives, keeps the type theory clean. so even if you want to work with machine integers you have to model them with a ton of bloat
13:24:25 <conal> Peaker: no?  did you just have size but not offset?
13:24:48 <edwardk> cads: yeah coq can generate Haskell/Ocaml.
13:24:57 <Cheshire> edwardk, yeah true, I don't think it's insurmountable though
13:25:04 <osfameron> @src groupBy
13:25:04 <pumpkinbot> groupBy _  []       =  []
13:25:04 <pumpkinbot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
13:25:04 <pumpkinbot>     where (ys,zs) = span (eq x) xs
13:25:11 <osfameron> @src span
13:25:11 <pumpkinbot> Source not found. I feel much better now.
13:25:17 <Peaker> conal: I had both, but what's the size of an image that sits at some rect somewhere in space, and another that sits in a completely different rect in space?  Does it make an image with a rect big enough to be around both? That's yucky :)
13:25:24 <skorpan> how do i manually compile Data.Generics without cabal? ghc --make Data/Generics.hs doesn't understand #ifndef and stuff.
13:25:29 <edwardk> Cheshire: its not. its just that i don't know of a decent base theorem prover on which to build the desired behavior.
13:25:31 <Peaker> conal: and another -> `mappend`
13:25:42 <Cheshire> edwardk, honestly I don't think one exists yet
13:25:47 <leimy> @users
13:25:47 <pumpkinbot> Maximum users seen in #haskell: 692, currently: 686 (99.1%), active: 25 (3.6%)
13:26:09 <ozy`> #HASKELL IS SO PUMPED UP YOU GUYS
13:26:14 <ozy`> HRUUUUUUUGGGHHHHH
13:26:15 <conal> Peaker: yeah.  there are other problems as well with bounding boxes as part of the semantics.  consider the formal properties of rotation.
13:26:15 <dolio> Epigram2, of course.
13:26:18 * ozy` breaks a table
13:26:26 <skorpan> oh, the -cpp flag
13:26:26 <Peaker> conal: ouch! :-)
13:26:46 <Peaker> conal: yeah, I just have (text, rect, move) for now. Its enough for my widget set :)
13:26:54 <edwardk> cads: re proofs and efficient code. unfortunately the easiest things to prove are usually not the most efficient algorithms. ;)
13:26:58 <conal> Peaker: and yet these problems creep into most designs, because they don't consider semantics carefully,
13:27:02 <cads> edwardk: we're just trying to automate some of the tedium out of the whole task of coming up with our representation of transcendant functions and differential/integral operators on whatever structures those entail... at the same time it doesn't have to be god, because most integral don't have a solution in terms of even special functions
13:27:33 <conal> Peaker: subtly bad designs get past programmers and land on users.
13:28:08 <cads> uuugh, I just realized about all the special functions that are described by integrals that otherwise have no other closed form solution!
13:28:22 <Cheshire> cads, you're actually implementing Risch?
13:28:32 <leimy> If I could convince people to think about the concepts or ways in which software was supposed to be used BEFORE we design solutions... I'd be a happier person
13:28:34 <cads> and our engine would have to be able to return solutions integrals in terms of those!
13:28:39 <leimy> yet these days I'm happy to have a job.
13:29:00 <edwardk> cads: i'll admit i'm too much of a hack mathematician to do much more than a basic symbolic integrator. (i tried once and burned out)
13:29:07 <cads> Cheshire: that sounds like an intriguing task
13:30:10 <cads> edwardk: I've got aspirations towards meaningful proof carrying code but I too think I'm not good enough a mathematician
13:30:58 <cads> edwardk: wolfram didn't do it all alone though, I think he had grad students :D
13:31:25 <cads> luscious female japanese grad students
13:31:34 <edwardk> cads: i'd say he has a lot of phds working for him, not just grad students ;)
13:32:02 <cadr> Ok, back to my much earlier question: would anyone mind looking at some code I wrote (simple tetris game) and giving me any feedback they feel like?
13:32:16 <cadr> the darcs repo is here:  http://patch-tag.com/publicrepos/fallingblocks
13:32:17 <cads> edwardk: I'm talking about in the early eighties, or before, when he was a professor doing his work on symbolic computation.. he really did innovate.. then he started a company
13:32:38 <cadr> (keeping in mind that I'm pretty new at haskell)
13:32:40 <leimy> cadr: if it works... why not on Hackage?
13:33:19 <cadr> leimy: Mainly because it isn't that far along
13:33:32 <leimy> makes sense :-)
13:33:52 <Saizan> ?seen dcoutts
13:33:52 <pumpkinbot> dcoutts is in #haskell-in-depth and #haskell. I don't know when dcoutts last spoke.
13:34:03 <edwardk> cadr: skimming.
13:34:10 <cadr> edwardk: thanks!
13:34:29 <edwardk> cadr: minor style nit, no need for the defensive parenthesis around the type of the m parameter of your Board datatype
13:34:57 <cadr> edwardk: good to know
13:35:48 <edwardk> cadr: if i'm going to flood you with little things maybe we should move to #haskell-overflow
13:36:03 <cadr> edwardk: Works for me
13:36:52 <mauke> @src transpose
13:36:52 <pumpkinbot> transpose []             = []
13:36:52 <pumpkinbot> transpose ([]   : xss)   = transpose xss
13:36:52 <pumpkinbot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:38:38 <Peaker> conal: I am thinking about how to add a scroller.. Semantically, its probably just a crop :: Image -> Rect -> Image   or something like that.  The real challenge is thinking up a way to find a nice implementation for it (you can tell me if that part bores you :-)
13:39:35 <Cheshire> Peaker, Why is scroller an Image rather than something you can interact with?
13:39:59 <Gracenotes> [h | (h:t) <- xss]... in other words, map head xss :/
13:40:08 <mauke> Gracenotes: no, not the same
13:40:12 <Peaker> Cheshire: A scroller is a widget you interact with, I meant it will be based on this one operation
13:40:26 <Gracenotes> oh, yeah, empty list
13:40:40 <conal> Peaker: i bet the scroller and cropping are more simply kept completely independent notions.
13:40:43 <skorpan> how would i go about replacing Data.Generics with my own modules in one specific program only?
13:41:09 <Cheshire> Image -> Rect -> Image seems like presentation more than semantics to me..
13:41:12 <Cheshire> is what I really meant
13:41:14 <conal> Peaker: cropping is about viewing through a window, and is done whether or not you scroll, right?  scrolling can simply be translation.
13:41:16 <Peaker> conal: Yeah, of course, there's a "Scroller widget" that is based on this "crop" operation
13:41:30 <Peaker> conal: Ah, that's what you mean, yeah, cool :-)
13:41:36 <Gracenotes> eh. There should probably be a better way to do mapping with pattern matching. a sort of filterMap >_>
13:41:40 <conal> Peaker: how about have scroller just move, but not crop?
13:41:44 <hackage> Uploaded to hackage: lui 0.0.3
13:41:44 <hackage> Uploaded to hackage: haskgame 0.0.4
13:41:48 <Peaker> conal: "move" (translate) already exists
13:41:49 <conal> Peaker: s/but/and/
13:42:00 <dancor> how do you deal with array indexing expr[expr] with parsec buildExpressionParser
13:42:13 <conal> Peaker: what does scrolling have to do with cropping?
13:42:15 <dancor> treat [ as an infix and hack ] in somehow?
13:42:23 <conal> Peaker: i see what it has to do with moving
13:42:25 <Cheshire> dancor, no you don't have to treat []'s as ops
13:42:36 <Cheshire> dancor, you can deal with []'s just like the example handles ()'s
13:42:48 <conal> Peaker: oh -- i bet you simply have one widget that's doing two functions.
13:42:51 <conal> Peaker: separate them.
13:43:45 <Peaker> conal: I was a bit confused, I don't crop images - I crop the widget rectangular image output (which is the widget's  Image and Size output)
13:44:07 <glguy> ski_, is this what you were looking at earlier? http://okmij.org/ftp/Haskell/ShiftResetGenuine.hs
13:44:27 <Peaker> conal: if you decide that all widgets are always cropped to available space, then scrolling has nothing to do with cropping. But if you decide that widgets are only ever cropped if you can scroll to the cropped contents, then the 2 are connected (Though I agree separating them semantically may still have merit, even if they are often used together)
13:44:33 <conal> Peaker: which has nothing to do with scrolling functionality, right?
13:44:46 * conal reads...
13:45:50 <dancor> Cheshire: ah right.  i'll do some kind of "look for possible [..] at the end" in my expr parser
13:46:00 <conal> Peaker: "... if you decide that widgets are only ever cropped if you can scroll to the cropped contents".  i have no idea why you'd want to tie these two notions together.   for the user or the semantic model.
13:46:18 <Peaker> conal: for the user -- to make sure that all information is available
13:46:38 <Peaker> conal: not for the semantic model, I agree
13:46:49 <conal> Peaker: i see formal semantic simplicity & orthogonality and user-based design as leading to exactly the same conclusions.
13:47:10 <conal> Peaker: in this case, i'm asking about the user viewpoint.  i don't get it.
13:48:19 <Peaker> conal: Well, widgets are meant to allow the user to edit models, or perhaps "interact" with models.  What usefulness would cropping the widget image be in any case, except one where its done to save screen-space, and the user is somehow allowed to be presented the cropped information?
13:49:02 <Cheshire> btw if you are talking about the semantics of these widgets, semantics interpreted to where/what?
13:49:13 <conal> Peaker: that question helps me see where you're coming from.
13:49:38 <conal> Peaker: see http://conal.net/blog/posts/designing-for-the-future/
13:50:13 <dancor> precedence is annoying tho
13:50:13 <conal> Peaker: i think you're saying the following:
13:50:45 <conal> Peaker: you have a limited view of what your users might want to do, and so you plan to impose that limit on them.
13:51:05 <Peaker> conal: consider me convinced :-)
13:51:16 <conal> Peaker: oh!  that was easier than i expected.
13:51:18 <roconnor> adding polymorphism to data structures to allow them to be annotated is totally awsome
13:51:31 <conal> Cheshire: i'm not sure i understand your question.
13:51:45 <conal> Cheshire: the bit about "interpreted to where/what"
13:52:07 <Peaker> conal: so I still need to support cropping widget output images -- and while the design/semantics are clear, I think its going to be pretty challenging to implement this efficiently for large widget hierarchies/images
13:52:14 <conal> Cheshire: are you asking what kind of semantic framework we're working in?
13:52:16 <Cheshire> conal, well if I was to give semantics to untyped lambda calculus in terms of haskell, I could use a domain like D = Lam (D -> D)
13:52:31 <Cheshire> conal, but for UI widgets... what is the equivalent of 'D'?
13:52:34 <conal> Cheshire: we're talking about semantics of types.
13:52:52 <conal> Cheshire: Peaker has a specific model in mind.
13:54:03 <Peaker> conal: cropping is a separate operation, I think this means that image croppings are indeed necessary (i.e: crop :: Size -> Image -> Image)
13:54:10 <conal> Peaker: have you seen how i crop infinite images in Pan?
13:54:13 <dancor> actually i'm going to try making "[expr]" a postfix operator to get precedence
13:54:24 <Cheshire> mm I don't really see it
13:54:25 <Peaker> conal: (contrary to what I said before, only cropping widget output (Image, Size) and never images)
13:54:28 <conal> Peaker: btw, there is a *much* nicer model for cropping than that one.
13:54:48 <Peaker> conal: I haven't seen how, no, would love to hear
13:55:15 <conal> Peaker: http://conal.net/Pan/papers.htm
13:55:51 <conal> Peaker: crop :: Image Bool -> Image a -> Image a
13:56:25 <TryNiX> for someone coming from java and planning to learn a functional programming language, would you guys suggest Haskell or Lisp, or both? and if both, what order of learning?
13:56:28 <Peaker> conal: that's indeed nicer, but I'm afraid if I let you know what I think now, you'd be angry with me :-)
13:56:45 <conal> lol
13:56:45 <BONUS> haha, guess what we would suggest :)
13:57:10 <TryNiX> if someone knows both :P
13:57:12 <Axman6> TryNiX: haskell, you'll be less tempted to use imperative nonsense ;)
13:57:39 <Cheshire> TryNiX, I programmed in lisp for maybe a year or so before I started to use Haskell
13:57:48 <Peaker> conal: I can't think of a way to implement this reasonably efficiently over SDL -- but I'm happy to suspend disbelief, can we try to figure that out?
13:57:51 <pejo> TryNix, with a java background you'll be amazed at what Haskell's typesystem can do. (And can't do).
13:57:59 <Apocalisp> Haskell will help you understand LISP properly ;)
13:58:26 <Cheshire> I'm weary, I think Haskell is good at making you snooty/look down on other languages
13:58:36 <Nafai> pejo: No kidding
13:58:42 <conal> Peaker: yes, let's.  i'm interested also.  my general/simple Pan semantics are applicable.  the implementation isn't.
13:59:11 <cads> anyone know if there's been work done on getting haskell to work together with lisp?
13:59:15 <TryNiX> any recommended book, to that matter :)
13:59:18 <conal> Peaker: i like implementation questions when the semantics is clear.  and when the implementation questions are "and" rather than "but".
13:59:26 <Cheshire> TryNiX, book for what?
13:59:33 <TryNiX> Cheshire, learning Haskell
13:59:41 <CakeProphet> Cheshire:  I agree, but I still love Perl and Python.
13:59:42 <athos> how do i tell cabal install, that i want yi with both vty and gtk frontend?
13:59:45 <Nafai> cads: Someone wrote Liskell
13:59:45 <Cheshire> cads, togther how? You can embed eithers important features in either
13:59:46 <Axman6> @where RWH
13:59:46 <pumpkinbot> is http://www.realworldhaskell.org/blog/
13:59:52 <Axman6> TryNiX: ^^
13:59:55 <Cheshire> TryNiX, Learn yuo a haskell
13:59:58 <Apocalisp> @where HSOE
13:59:58 <pumpkinbot> Haskell School of Expression.
14:00:03 <Nafai> cads: http://liskell.org/
14:00:03 <pbuetow> TryNiX, i am learning haskell too at the moment, and i am reading the yet another haskell tutorial pdf file for a start
14:00:07 <Cheshire> TryNiX, which is some online tutorial
14:00:21 <Cheshire> ?where LYAH
14:00:21 <pumpkinbot> www.learnyouahaskell.com
14:00:22 <Peaker> conal: btw, have you heard the idea that came up to convert: type Image a => Position -> a ; to something like:  type Image a (~>) = Arrow (~>) => Position ~> a  ?
14:00:32 <TryNiX> why is there a bug photo on the cover of that book =p
14:00:48 <cads> I know there's a lispy flavor of haskell, but I'm talking about being able to code in a dialect of lisp such as a clojure when you want dynamic stuff with ease of metaprogramming, and haskell when you'll benefit from a type system
14:00:49 <conal> Peaker: have you seen antyony courtney's Haven?  he used the same semantic model as pan's.
14:00:57 <Axman6> those beetles are very very powerful, just like haskell ;)
14:01:01 <Cheshire> Peaker, conal, can you elucidate a bit on what you are thinking about semants in terms of ? seems interesting but not sure I follow
14:01:05 <BONUS> TryNiX: that's just an imprint of a bug, someone used the book to squash the bug, so to speak
14:01:05 <TryNiX> pbuetow, think I'll do that as well :D
14:01:06 <pejo> cads, have you looked at template haksell?
14:01:08 <BONUS> :]
14:01:10 <cads> .. and have the code interoperate blisfully
14:01:21 <TryNiX> BONUS, haha so haskell has no bugs? :P
14:01:30 <Actium> that beetle is scary
14:01:34 <pbuetow> TryNiX, it is a nice pdf. and the exercises are not too hard for beginner, but you have to think too
14:01:34 <mauke> haskell has stronger and better bugs!
14:01:43 <BONUS> haha yeah
14:01:43 <conal> Peaker: i remember a discussion with someone a year or two ago about generalizing from (->) to Arrow.  it sounded very nice.
14:01:53 <BONUS> whereas other languages have bugs, haskell has type errors
14:01:59 <pbuetow> TryNiX, i am at page 80 from 192 atm ;)
14:02:02 <cads> pejo: I have not gotten into any haskell extensions yet. I am learning clojure for to learn a lisp
14:02:09 <TryNiX> pbuetow,  nice ur fast :D
14:02:11 <BONUS> if you don't get any type errors at compile time, chances are you're cool
14:02:14 <Cheshire> cads, :/ clojure is a lisp now ?
14:02:24 <pbuetow> TryNiX, i started last week :)
14:02:28 <conal> Cheshire: Image = R2 -> a .  Peaker also has a model for UIs.
14:02:29 <Axman6> i thought it was
14:02:33 <Peaker> conal: Except the "arr" that ruins it :-(
14:02:42 <Axman6> @arr
14:02:42 <pumpkinbot> Har de har har!
14:02:45 <Axman6> @arr
14:02:45 <pumpkinbot> Yeh scurvy dog...
14:02:45 <Apocalisp> @yarr
14:02:45 <pumpkinbot> Keelhaul the swabs!
14:02:46 <cads> yeah, clojure started out a lisp
14:02:47 <conal> Peaker: yeah.  it's a standard exception.
14:02:52 <TryNiX> pbuetow, hehe cool :D
14:02:55 <cads> I think?
14:02:58 <conal> Peaker: arr appears to have been a mistake.
14:03:00 <Peaker> conal: I think almost all useful arrows can't implement "arr"
14:03:32 <Peaker> conal: "arr" is ok if its in a separate type-class
14:03:39 <pbuetow> TryNiX, i ve done lots with java/perl/c/c++ before, but haskell i only studied for 2 weeks at the university, about 7 years ago
14:03:42 <conal> Peaker: agreed.
14:03:47 <Axman6> you know, since i learnt java, i haven't felt the least bit interested in using it again, even though i've spent twice as long using it now
14:03:50 <mmorrow> clojure does do TCO on account of it not being possible with the JVM
14:03:54 <mmorrow> *doesNT
14:04:08 <conal> Peaker: maybe Category is enough in this case.
14:04:08 <Peaker> conal: someone suggested forcing type-classes to always have one method, heh
14:04:11 <Cheshire> conal, so you are sort of designing things in terms of an idealised/infinite computer language?
14:04:28 <conal> Cheshire: yeah: Haskell.
14:04:33 <Cheshire> haha
14:04:36 <TryNiX> pbuetow, I still need to cover C and Perl -_-
14:04:38 <conal> :)
14:05:06 <cads> BONUS, I disagree in that I find it easy to write a bug even if my types are right and the program executes :D
14:05:08 <pbuetow> TryNiX, hehe lot's to do
14:05:12 <Peaker> conal: hmm.. on second thought, if the input type is hard-coded to be of Position type, few of the arrow composition functions are actually usable.. its probably a bad idea
14:05:12 <Cheshire> conal, by infinite I mean like Takeutis description of infinite mind.. maybe it's not a common notion
14:05:14 <conal> Cheshire: have you seen Pan?  it's all done very directly via this idea model.
14:05:23 <Cheshire> yes Pan is awesome
14:05:34 <mmorrow> yeah, pan is sweet
14:05:46 <Axman6> Pan's labyrinth is also sweet
14:05:47 <hiredman> mmorrow: it has other mechanisms for doing functional constant space calls
14:05:52 <conal> Cheshire: Takeutis ref?
14:05:55 <Peaker> conal: but just making sure "Image" is an abstract type with hidden constructors is good enough.. finding the right type classes can be done later
14:05:57 <Cheshire> that's one thing that shifted my paradaigm
14:06:03 <mmorrow> hiredman: cool. like what?
14:06:14 <hiredman> recur and trampoline
14:06:18 <conal> Peaker: agreed.  don't expose the function rep.
14:06:18 <mmorrow> oh yeah
14:06:23 <TryNiX> pbuetow, would you say my priorities are screwed if i go from java -> haskell -> c -> python? :P
14:06:31 <mmorrow> unfortunately trampolines aren't very efficient..
14:06:39 <Twey> TryNiX: Yes.
14:06:44 <mmorrow> (compared to jmp)
14:06:57 <Axman6> TryNiX: haskell -> C is what i'll be doing. but lose the other two ;)
14:06:57 <Peaker> conal: do you know the implementation Haven uses?
14:06:58 <mmorrow> but they work nonetheless :)
14:06:58 <pbuetow> TryNiX, haskell and c are very different
14:07:23 <conal> Peaker: here's a cool trick: whatever representation we give, define a semantic function that maps to the function type.  then we have a complete specification of correctness of the image implementation.
14:07:26 <Twey> TryNiX: http://www.dynamicdrive.com/forums/showpost.php?p=164524&postcount=1337
14:07:44 <conal> Peaker: haven uses java2d, i think.  antony posted a link just a few days ago.
14:07:52 <conal> Peaker: in that long thread on UI semantics.
14:08:01 <conal> Peaker: the one ksf started.
14:08:02 <hiredman> mmorrow: well, I have only every ended up using trampoline once, mostly just using recur
14:08:08 <Peaker> conal: Ah, I haven't read cafe in the last while
14:08:09 * jeffwheeler wonders whether any of the CSS ideas on haskell-cafe could be done in Yi.
14:08:24 <mmorrow> hiredman: i'm not familiar with "recur". what's the idea behind that?
14:08:24 <TryNiX> Twey, interesting, especially with Scheme at the forefront :) thanks for the link
14:08:32 <Peaker> conal: Are the java2d primitives similar to the SDL ones?
14:08:46 <pbuetow> TryNiX, but i felt like a beginner in programming after starting haskell last week.
14:08:54 <TryNiX> pbuetow, hahaha I best :P
14:08:57 <conal> Peaker: i don't know.  what are sdl's like?
14:09:10 <pbuetow> TryNiX, although i ve lot's of experience in other languages ;)
14:09:14 <mmorrow> for instance, i don't believe this is possible to do without tailcalls:
14:09:15 <mmorrow> mutual f g a = f a (\b -> g b (\a -> mutual f g a))
14:09:26 <hiredman> mmorrow: recur is like a recursive self call in a function, accept instead of calling itsself it calls recur
14:09:35 <Cheshire> conal, here's a passage  The first time I met Takeuti I asked him what set theory was really about. "We are trying to get exact description of thoughts of infinite mind," he said. And then he laughed, as if filled with happiness by this impossible task.
14:09:36 <pejo> conal, did you say the function type gives a complete specification of correctness of the image implementation?
14:09:44 <Peaker> conal: SDL has "Surfaces" which are rectangular pixel arrays of a finite size.  Each pixel is either RGB or RGBA (with transparency channel, which may be key to the operation you described above)
14:09:51 <Cheshire> conal, just the idea of an Image being a function from R^2 reminds me of this
14:10:00 <Peaker> conal: Surfaces can be blitted into each other
14:10:20 <hiredman> mmorrow: my haskell is, well, *non-existent*
14:10:26 <conal> Cheshire: that's lovely!  and resonates very much with me.
14:10:26 <mmorrow> hiredman: :)
14:10:31 <Cheshire> conal, do you think this is a close resemblance or I am still missing the point? :)
14:10:35 <Peaker> conal: blitting is in-place, and in IO
14:10:47 <Peaker> conal: Text rendering returns a new surface with an alpha channel
14:11:02 <Peaker> conal: You can also fill a rectangular area in a surface with some color, in-place
14:11:03 <TryNiX> the only question that I always have in mind is, when should I say "ok I know enough about this language, now I should move to next one and start learning about it!"
14:11:19 <conal> Cheshire: the ideal view of images is very practical.  it's much more nicely composable than the traditional digital concept.
14:11:37 <drhodes> > 123.00 == (truncate 123.00)
14:11:38 <pumpkinbot>   Add a type signature
14:11:51 <Axman6> :t truncate
14:11:51 <conal> Cheshire: yes i do.  and i love living right on the edge of impossibility.
14:11:52 <pumpkinbot> forall a b. (Integral b, RealFrac a) => a -> b
14:11:58 <CakeProphet> TryNiX:  when you can break the language in every way the designer didn't want you to... that's when you should move on, I think.
14:12:03 <Axman6> @instances Integral
14:12:04 <pumpkinbot> Int, Integer
14:12:09 <Axman6> @instances RealFrac
14:12:09 <pumpkinbot> Double, Float
14:12:20 <Axman6> drhodes: not gonna happen
14:12:34 <TryNiX> CakeProphet, interesting perspective! But somehow it feels right lol
14:12:50 <Cheshire> mmorrow, it looks like CPS btw
14:12:53 <conal> Cheshire: i'm working on the third piece of a complete puzzle now.  the first two were in Pan: infinite and continuous rather than finite & discrete.  the third is to generate color values that are *exactly* correct, rather than quantized & approximate.
14:12:56 <Peaker> conal: blitting takes a dest surface, pos and source surface, rect.     rect filling takes a surface and a rect
14:13:19 <drhodes> ok Axman6 thanks
14:13:38 <conal> Peaker: that's all rastery stuff.  if that's what you want, then maybe the pan implementation would fit fine.
14:13:41 <cads> hiredman: I was wondering about possible benefits that may come about from learning both haskell and clojure (or lisp in general), at the same time. And whether it may be useful to use the two languages together in practice. Is this absurd?
14:13:54 <conal> Peaker: i expected you to want to use geometric operations in the implementation.
14:14:12 <Peaker> conal: well, I don't want to go through pixel data myself
14:14:20 <hiredman> cads: I dunno
14:14:34 <CakeProphet> Cheshire:  with some langagues it's faster than others. The first language I learned was Python and within a year and a half I had learned pretty much everything about it.
14:14:40 <CakeProphet> maybe even a year.
14:14:46 <hiredman> cads: you could use erlang as a bridge :P, I think both can pretend to be erlang nodes
14:14:52 <CakeProphet> and consequently, I learned tons of ways to do voodoo.
14:15:12 <conal> Cheshire: the trick i really enjoy is to do *all* composition in this ideal and composition-friendly realm, and then cleverly implement it finitely.
14:15:33 <conal> Cheshire: whois Cheshire ?  /whois won't tell me
14:15:48 <cads> hiredman... that does feel a bit absurd :D
14:16:02 <hiredman> cads: I think haskell has covered a lot of the functional bases, and most cool functional stuff is demonstrated in haskell in various pdfs around
14:16:09 <Peaker> conal: Pan probably does go through the pixel arrays, right?
14:16:15 <Axman6> @tell CyberGarp if you're still around, i'd be happy to talk about n-bodies thing. i'll be around in about 2 hours (going back to sleep, woke up way too early) [9:15AM Australian easter time]
14:16:15 <pumpkinbot> Consider it noted.
14:16:18 <conal> Peaker: when?
14:16:33 <Peaker> conal: when creating an actual rendered finite image?
14:16:38 <hiredman> so if you go deep into the functional stuff then you have to try and translate haskell → clojure
14:16:49 <conal> Peaker: yes, that's when it does.
14:17:10 <Peaker> conal: yeah, I hope to be able to avoid that, and let the "optimized" C code or GLU code used by SDL to do that for me
14:17:14 <conal> Peaker: it does reconstruction at the input, and sampling at the output.  in-between, everything is infinite & continuous.
14:17:22 <Peaker> conal: s/GLU/GPU
14:17:37 <cads> hiredman: clojure on the other hand feels easier to just code in, where in haskell I have to break out pen and paper still
14:17:38 * BMeph_ admires Twey's avatar of the quintuple ice-cream cones
14:17:46 <Peaker> conal: yeah, I understand, but I want SDL to do the sampling
14:17:53 <Peaker> s/but/and
14:17:53 <conal> Peaker: okay, now i'm back on track with you.  so the rastery aspects of SDL will be peripheral.
14:17:59 <Twey> BMeph: :-D
14:18:40 <conal> Peaker: i got a good ways into implementing a architecture last year that may work well for you.
14:19:02 <czShadoW> @src digitToInt
14:19:02 <pumpkinbot> Source not found. Do you think like you type?
14:19:03 <Peaker> conal: cool, what is the general outline?
14:19:13 <conal> Peaker: it can do HW-accelerated rendering and yet still be infinite & continuous.
14:19:45 <conal> Peaker: infinite 2D multi-res zippers of video memory chunks.
14:20:07 <Peaker> conal: you could say I'm also infinite&continuous with HW-accelerated rendering, but that's because I only have move/rect/text :-)   So its also important to mention what compositions you have
14:20:16 <conal> Peaker: that's what i was doing before i got side-tracked back onto FRP
14:20:38 <drhodes> > dropWhile isDigit (show 123.000000) == ".0" -- Double ends in all zeroes
14:20:39 <pumpkinbot>   True
14:20:39 <Peaker> conal: sounds cool.. how did you handle cropping?
14:20:46 <hiredman> cads: and ♥ lisp
14:20:52 <cads> hiredman: it feels simple and clean, whereas haskell feels like this grand cathedral that has been ground to ineffable holiness and horrible perversion throughout the ages.. it's got a lot of history and arguably scars.. I actually feel like I'm blaspheming, so i'll stop!
14:21:47 <Peaker> cads: Do you separate your feelings about syntax and about the language semantics?  Haskell syntax is a bit dirty, but the semantics are pretty clean (at least up to seq and friends)
14:21:47 <conal> Peaker: cropping same as usual: culling by bounding boxes
14:22:12 <conal> cads: up to seq & friends *and* IO
14:22:38 <CakeProphet> I just realized why everyone and their grandmother has a Lisp dialect... it's easy to parse.
14:22:46 <conal> CakeProphet: yeah!
14:23:07 <conal> "read my lisp: no new syntaxes"
14:23:09 <cads> Peaker: I still consider myself extremely novice in programming in general
14:23:27 <cads> as such I don't really have a good feeling for all the possible semantics to be had
14:23:33 <Peaker> conal: ah, that sounds good. I am afraid that it might not fit my case, because the purpose of cropping is not just altering the image output, its also avoiding looking through the many images that may have been composed
14:23:35 <cads> just a few neat tricks I know here and there
14:23:50 <Peaker> conal: that's a nice one :-)
14:24:04 * CakeProphet has grown fond of Haskell's syntax.
14:24:16 <conal> Peaker: i don't see a conflict between your two uses of crop.
14:24:29 <Gracenotes> CakeProphet: but the unary (-) poisons your love!
14:24:30 <conal> Peaker: sometimes cropping is a semantic no-op.  then we call it "optimization".
14:24:32 <Peaker> conal: It sounds like culling may save a lot of pixel-related work but it will still go through all of the O(shape-count) shapes
14:24:44 <CakeProphet> I once thought minimal syntax was the key to a clean and powerful language.
14:24:50 <conal> Peaker: that's where *hierarchical* bounding boxes help
14:24:51 <CakeProphet> but... meh, now it doesn't matter so much
14:24:53 <Peaker> conal: sorry for using "but" so much, I am not noticing that :)
14:25:09 <conal> Peaker: nice catch!
14:25:39 <CakeProphet> Gracenotes:  aye.
14:25:45 <jre2> I'm using SDL to draw pixels to the screen with fillRect.  Is there a sane way to select color besides using mapRGB to generate a Pixel object with respect to the surface you're drawing to each time you push a pixel (it seems bad if I'm doing this 1000s of times).
14:26:55 <CakeProphet> Gracenotes: but to get better positional recognition of function application you'd need to ditch partial application semantics... I'm not sure if it's worth that.
14:27:02 <cads> jre2, why not store it in some state?
14:27:18 <conal> Peaker: "and" fits even there, since pixel & geometry perf are additive, not subtractive.  maybe that's a helpful model of "and" vs "but".
14:27:28 <jre2> cads: store all the colors?
14:27:41 <cads> as an array, sure?
14:28:17 <cads> or are you having to evaluate a function for the color of each pixel?
14:28:22 <Peaker> conal: Well, I already thought of hierarchial cropping as a solution.. last time I thought it up, I thought it was problematic, and now I think I see that it should work :)
14:28:27 <conal> e.g., "all but this one" doesn't mean "all and this one".
14:29:03 <Peaker> conal: I think I usually use "but" to just indicate that the two parts of my sentence support opposing conclusions
14:29:20 <conal> Peaker: yeah!  that's what it means to me also.
14:29:37 <Peaker> conal: note the word "support", and not "prove" or such -- it leaves the options open :)
14:29:53 <conal> Peaker: and it's exactly why i get discouraged when i hear you or me or anyone say things like: here's a nice semantics but we have to deal with this practical issue".
14:29:55 <jre2> cads: yes, I'm selectively drawing 4x4 pixel boxes at different locations with different colors (it's a visualizer for a lot of data)
14:30:28 <conal> Peaker: replace "but" with "and" in that sentence, and i'm energized & excited.
14:30:31 <Peaker> conal: When I hear that - I see an oppurtunity to show how solving the practical issue doesn't destroy the nice semantics, rather than being demotivated :)
14:31:00 <conal> Peaker: oh -- then i bet you get confused about my reactions.
14:31:27 <Peaker> conal: heh, yes, I was very confused at first, but I think I learned how to communicate with you :)
14:31:56 <CakeProphet> lambdabot should have a emoticon counter.
14:32:14 <CakeProphet> you'd type in @emocount and it would tell you how many emoticons have been used in the past hour, day, etc
14:32:15 <Peaker> @:) Peaker
14:32:15 <pumpkinbot> Maybe you meant: . ? @ bf ft id pl rc v wn
14:32:23 <CakeProphet> maybe filter them by person too
14:32:30 <CakeProphet> (and emoticon)
14:32:30 <monochrom> Is :[] an emoticon it will count?
14:32:53 <CakeProphet> hmmm
14:32:55 <mmorrow> > :[]
14:32:56 <pumpkinbot>   mueval: Prelude.read: no parse
14:33:00 <mmorrow> no
14:33:03 <mmorrow> :)
14:33:22 <conal> does anyone else have a reaction to share to "but" vs "and" in a context like "nice theory but ..."?
14:33:49 <conal> e.g., "nice theory but there's a problem"
14:33:57 <mmorrow> yes, when i run into that i get the overwhelming urge to rewrite the thing that's causing the fundamental problem
14:34:15 <mmorrow> (which admittedly puts me on rather extensive side-trips on the way to my goal)
14:34:25 <jre2> what's with all the lambdabot replacements?
14:34:38 <CakeProphet> > foldl1 (.) (replicate 10 (:[])) "chomp chomp chomp chomp chomp"
14:34:39 <pumpkinbot>       Occurs check: cannot construct the infinite type: b = [b]
14:34:39 <pumpkinbot>        Expect...
14:34:48 <mmorrow> jre2: pumpkinbot is a lambdabot
14:34:57 <mmorrow> i think lambdabot is dead for the moment
14:35:14 <roconnor> can I use view patterns in lambdas?
14:35:18 <pao> writing a FFI is tedious becouse of it's FFI? :-)
14:35:38 <mmorrow> roconnor: i just found out yesterday that you can do this:
14:35:50 <roconnor> ooh
14:35:55 <conal> thanks mmorrow.  other "and"/"but" reactions, anyone?
14:36:01 <roconnor> it's like gettin a where clause in a lambda for free
14:36:16 <Peaker> conal: My native language is Hebrew, maybe things are a little different there
14:36:28 <CakeProphet> hmmm... what are view patterns now?
14:36:29 <mmorrow> , (\xs | x:y:_ <- xs -> x | [] <- xs -> 42) [3,2,0]
14:36:30 <lunabot>  luna: parse error on input `|'
14:36:32 <mmorrow> crap
14:36:38 * mmorrow re-looks up the syntax
14:37:02 <mmorrow> (maybe pattern guards don't work there, that's an  assumption i'm making beyond what i read)
14:37:06 <conal> Peaker: maybe, and yet you nailed it with "I think I usually use 'but' to just indicate that the two parts of my sentence support opposing conclusions"
14:37:23 <CakeProphet> heh, | is taking a lot of contextual meanings.
14:37:34 <Peaker> conal: yeah, I mean the connotations/emotions it raises
14:37:51 <Peaker> conal: so how do you create the hierarchial bounding boxes, if your semantic operation is   Image Bool -> Image a -> Image a?
14:38:20 <Peaker> conal: I can see ways of doing that if Image is not a Functor :-)
14:38:32 <conal> Peaker: functor interferes?
14:39:15 <Peaker> conal: only because this way is crazy and would really only support Image Bool and Image Color, or something of this sort
14:39:39 <conal> Peaker: i think my strong negative emotional reaction to "but" is because i hear it as anti-creative, just as i hear "obvious".  and creativity is so important to me.
14:40:07 <conal> Peaker: monoid types?
14:40:21 <conal> Peaker: i.e., having identity elements
14:40:53 <conal> hence my post http://conal.net/blog/posts/fostering-creativity-by-relinquishing-the-obvious/
14:41:16 <Peaker> conal: I thought of something that defeats the purpose, along the lines of having crop seem to have the powerful type, but actually the only things that make Image Bool are rect areas and thus you can just fake the powerful crop type signature while only providing the ugly crop, heh
14:41:55 <conal> Peaker: eep -- i don't think you'll like that design.
14:42:05 <conal> Peaker: polymorphic image functions are really nice
14:42:14 <Peaker> conal: I was half-kidding, and the lack of Functor instance emphasizes how silly it is
14:42:33 <conal> Peaker: what lack?  Image is indeed a Functor.
14:42:43 <Peaker> conal: I meant in the ugly suggestion above
14:42:46 <conal> Peaker: and Applicative and Comonad.  all *very* useful properties.
14:43:56 <Peaker> conal: so while I see how a hierarchy of bounding boxes work, I am not sure how you actually get to create them from the crop operation you defined
14:43:57 <mmorrow> roconnor: hmm, i just found the comment in ghc i was thinking of, and it says you can do:
14:43:58 <mmorrow> (\x | even x -> 0 | odd x -> 1)
14:44:06 <mmorrow> but i can't seem to find the flag to turn it on
14:44:07 * loadquo is intrigued by the talk of functional images
14:44:11 <mmorrow> , (\x | even x -> 0 | odd x -> 1)
14:44:12 <lunabot>  luna: parse error on input `|'
14:44:15 <mmorrow> > (\x | even x -> 0 | odd x -> 1)
14:44:15 <pumpkinbot>   mueval: Prelude.read: no parse
14:44:30 <conal> Peaker: oh -- because of its generality.
14:44:42 <Peaker> conal: yeah
14:44:46 <conal> Peaker: taking arbitrary regions (bool images) instead of boxes, e.g.,.
14:44:48 <dolio> I've never heard of a flag to do that.
14:44:54 <dolio> Maybe a Haskell' proposal.
14:45:15 <Peaker> conal: exactly
14:45:23 <mmorrow> the error message in the code to desugar TH [||]'s calls that "Guarded labmdas" in its error msg
14:45:40 <mmorrow> grep "Guarded lambda" in http://moonpatio.com:8080/repos/LIBS/Language/ghc/compiler/deSugar/DsMeta.hs
14:45:52 <mmorrow> the comment is right above that that says you can do this
14:46:12 <dolio> Huh...
14:46:43 <mmorrow> dolio: yeah, maybe that hasn't been / just never was implem
14:46:50 <mmorrow> but the comment remains ?
14:46:56 <dolio> May have been taken out.
14:46:59 <conal> Peaker: don't use a region as your bounding box operand.  use something like a box.  the semantics is the identity function on the image, but the domain is restricted to images that are transparent outside of that box.
14:47:06 <mmorrow> dolio: ah yeah, that too
14:47:11 <conal> Peaker: that's how i think of it, anyway.
14:47:15 <dolio> Although I don't know why you'd take out something nice like that.
14:47:28 <mmorrow> dolio: totally! i got all excited when i saw it yesterday
14:47:34 <mmorrow> (but never got around to trying it)
14:47:45 <dolio> Then again, monad comprehensions were removed.
14:47:48 <mmorrow> , [|(\x | even x -> 0 | odd x -> 1)|]
14:47:49 <lunabot>  luna: parse error on input `|'
14:47:50 <conal> Peaker: in other words, the bbox doesn't mean 'crop' -- it means 'already cropped'
14:47:58 <mmorrow> dolio: such a shame
14:48:00 <Cheshire> and even since, nobody has understood monads
14:48:05 <Peaker> conal: but how do you know to create it?
14:48:51 <conal> Peaker: various possibilities.  one is completely manual.  useful for infinitely recursive imagery or geometry.
14:48:58 <mmorrow> hmm, i guess the fact that that ghc code compiles means that the HsSyn HsPat type *has* the ability to represent this
14:49:09 <mmorrow> so i guess that makes it just a matter of adding it to the parser
14:49:12 <conal> Peaker: another is via hierarchically bounding boxes in geometry that is getting rendered into an image.
14:49:38 <conal> Peaker: you can also build the bounding boxes recursively, bottom-up.
14:49:45 <Peaker> conal: "completely manual" means you somehow know that its transparent outside that box, right?
14:49:54 <conal> Peaker: but that doesn't work nicely for fractal-like stuff.
14:50:01 <conal> Peaker: yeah, that's what i mean.
14:50:22 <Peaker> conal: the only guys that know that in my case, afaik, are the users of the image semantics, not the implementation
14:50:35 <Peaker> conal: And I don't want to expose them to the concept of bounding boxes
14:51:19 <conal> Peaker: perhaps the purely bottom-up approach then, and no infinite geometry.
14:51:45 <conal> Peaker: since the bbox stuff will be strict.
14:52:51 <conal> Peaker: for lazy infinite, i don't know how to avoid some kind of inductive argument.  hence human intervention, or some form of theorem proving.
14:53:20 <Peaker> conal: that does seem to mean that if I have a huge widget hierarchy that I'm scrolling through (consider a big document viewer), that I have to go through the whole thing (computing sizes) just to build the bounding boxes -- in which case I might as well just compute a bounding box for each nested/composed image separately?
14:53:55 <mmorrow> hehe, here's rwbarton's brainfuck to (x86) machine code (via harpy) to ELF .o (via hax) compiler http://moonpatio.com/repos/brain/
14:54:03 <mmorrow> (just in case anyone forgot about it ;)
14:54:32 <conal> Peaker: yeah -- iiuc, you mean doing the same work, but eagerly or lazily (and uncached).
14:54:47 <Peaker> conal: Yeah, caching seems difficult here
14:54:50 <conal> Peaker: during construction or during pre-rendr analysis
14:55:01 <conal> Peaker: with bottom-up, caching is easy
14:55:21 <conal> Peaker: you just include a Maybe BBox as part of the representation.
14:55:26 <Peaker> conal: Construction is re-done from scratch for every new model, which means, after every little change -- not sure how to memoize there without leaking
14:56:55 <Peaker> conal: I think that since image composition is not the focus of my interest in this project, I will go with a compromise (that I find decent, if not the prettiest) that can be improved later, of having the limited crop operation, which is actually a bounding box, rather than the powerful Image semantics.  My semantics are still simple and composable, just less powerful
14:57:26 <hugo___1> hello
14:57:43 <conal> Peaker: use Reactive & you'll get memoization.
14:57:48 <conal> Peaker: i mean caching.
14:57:58 * loadquo is thinking about painting "mouse click" functions on a virtual canvas to handle arbitrarily shaped things click on
14:58:04 <HugoDaniel> is there a reactive SDL adaptor ?
14:58:05 <conal> Peaker: because Reactive only recomputes things that change.
14:58:30 <conal> HugoDaniel: not that i know of.  there was one a while ago, but it got abandoned when we couldn't get sdl working with windows.
14:58:39 <HugoDaniel> hmm ok
14:58:41 <HugoDaniel> ill work on it then
14:59:21 <Peaker> conal: that would mean changing the semantics we talked about, of   type Widget model = model -> (Image, Map Event model)
14:59:30 <Peaker> (simplified a bit for clarity)
14:59:43 <loadquo> * things to click on
14:59:46 <HugoDaniel> im not a big fan of glut, and the sdl guys are planning opengl 3 context support for the upcoming version 1.3, still this year
15:01:15 <Peaker> conal: if my model is represented as some hierarchy of Behaviors and/or Events, and widgets show those, there's no problem. I think when the widgets want to edit them, then the widget and model components are dependent on each other, and that's not very pretty
15:01:34 <conal> Peaker: before you go with such a restricted crop, look at the Haven slides.  general crop lets you eliminate & simplify some other things nicely.  it adds simplicity & orthogonality (and thus generality).
15:03:03 <conal> Peaker: maybe not pretty.  or maybe we don't yet know how to express them elegantly yet.  only way i know to find out is to try.
15:04:34 <leimy> @users
15:04:35 <pumpkinbot> Maximum users seen in #haskell: 692, currently: 671 (97.0%), active: 13 (1.9%)
15:04:41 <leimy> damn
15:04:45 <leimy> almost made 700
15:05:01 <conal> Peaker: btw, what's your driving motivation with this project?
15:05:25 <Peaker> conal: My vision of how awesome an AST editor based on this kind of widget set can be :)
15:06:02 <ehird> sheesh, I come back and peaker's still on about it :D
15:06:06 <Peaker> conal: and the longer-range vision of how an AST editor that evaluates the code as you edit it can be united with the user's desktop interface, and various othe ideas
15:06:40 <conal> Peaker: oh yeah.  nice!  thanks for the reminder. :)
15:06:53 <Peaker> conal: the widget set is just necessary to write the code editor, because I believe that wx, Qt, Gtk, and the rest are just hopelessly broken on both the UI and semantic side
15:07:22 <HugoDaniel> AST = abstract syntax tree ?
15:07:22 <conal> Peaker: amen!  now i'm excited about your project.
15:07:42 <Peaker> conal: :-)
15:07:54 <HugoDaniel> AST & Reactive... what an explosive mix
15:08:24 * Cheshire hopes brain exploding
15:08:34 <Peaker> HugoDaniel: AST = Abstract Syntax Tree, yes. But the "tree" part is actually a lie, because code is really a graph, and its encoded as a tree to accomodate the limitations of text encodings
15:09:01 <HugoDaniel> okey
15:09:27 <Peaker> You could say the graph is encoded as a tree first, by using names and namespace rules, and then that is encoded to text via an AST.  I want to edit not the AST, but the ASG - I don't want to have namespaces and names
15:09:39 <conal> Peaker: i've probably mentioned that i'd love to have Reactive run a compiler.  source code & object code are time-varying values.  expose the inner components of the compiler and connect them with Reactive combinators: incremental dynamic compilation
15:09:47 <Peaker> (names can be a useful presentational tool to lay the graph out on screen, though)
15:09:47 <HugoDaniel> im starting out with reactive... hope i can catch up with it fast
15:10:26 <Peaker> conal: yeah, that'd be awesome, but I am pretty sure that either requires using Reactives instead of Behaviors, or having a Monad instance for Behaviors
15:11:03 <Peaker> conal: Surely you'd want to generate behaviors dynamically, from compiled code or what not
15:11:12 <Peaker> conal: sorry for the "but" there :-)
15:11:35 <Peaker> conal: it'd actually be awesome either way
15:11:37 <conal> Peaker: maybe for livecoding.  perhaps not otherwise.
15:12:49 <conal> Peaker: for livecoding, we'd want a behavior to change (via recompilation) *and* we'd want to "join" the various behaviors into one.
15:13:12 <Peaker> conal: yeah
15:13:17 <sm> how do I pretty print (just ascii) a record, for easier debugging ?
15:13:40 <conal> Peaker: funny: it took you a while to learn about my "but" reaction, and it took me a while to learn that you don't mean "but" anti-creatively.
15:14:25 <ddarius> conal: You were too focused on syntax rather than semantis.
15:15:24 <conal> ddarius: i was focused on semantics, but i had a different semantic function from peaker's.
15:15:34 <sm> also, could someone remove hpaste.org from the topic till it's up ?
15:16:27 <drhodes> sm, are you getting unicode funk, or you just need a textual representation?  you know about deriving (Show)?
15:16:36 <conal> in that we never react to what people say, only to the interpretations we apply.
15:17:19 <drhodes> "your personality is my reflection"
15:17:20 <sm> hi drhodes, yes I can show easily, but a large record dumped that way is hard to read (by a human)
15:17:49 <sm> I'd like to lay it out in the style of eg python's pprint, and I don't understand the prettyprint package quickly, so looking for a how-to
15:18:15 <drhodes> ohhhh. yeah I don't know, sorry.
15:18:30 <sm> thx
15:19:14 <conal> drhodes: and often my shadow.
15:19:52 <drhodes> ok here's the taproot quote to Art "And my personality is my reflection"
15:20:23 <CakeProphet> :t replace
15:20:24 <pumpkinbot> Not in scope: `replace'
15:22:41 <Peaker> conal: btw, you can "cabal install lui"
15:22:57 <Peaker> conal: there's a weird example in there
15:23:22 <CakeProphet> > let replaceWith _ _ [] = []; replaceWith p f (x:xs) = (if p x then f x else x) : replaceWith p f xs in replaceWith (=='e') (const 'u')
15:23:23 <pumpkinbot>       Overlapping instances for Show ([Char] -> [Char])
15:23:23 <pumpkinbot>        arising from a...
15:23:27 <CakeProphet> > let replaceWith _ _ [] = []; replaceWith p f (x:xs) = (if p x then f x else x) : replaceWith p f xs in replaceWith (=='e') (const 'u') "Hello, World!"
15:23:28 <pumpkinbot>   "Hullo, World!"
15:24:33 <conal> Peaker: i'll try.
15:24:44 <CakeProphet> @let filterMap _ _ [] = []; filterMap p f (x:xs) = (if p x then f x else x) : replaceWith p f xs
15:24:45 <pumpkinbot>  <local>:4:73: Not in scope: `replaceWith'
15:24:55 <CakeProphet> @let filterMap _ _ [] = []; filterMap p f (x:xs) = (if p x then f x else x) : filterMap p f xs
15:24:56 <pumpkinbot>  Defined.
15:25:09 <Peaker> conal: cool, let me know
15:25:27 <conal> Peaker: (slow internet here ...)
15:25:30 <Gracenotes> filterMap p f xs = map p . filter f xs
15:25:39 <pumpkin> thoughtpolice: did you get a chance to work on the objc stuff?
15:25:43 <Gracenotes> s/\./$/
15:25:55 <Peaker> conal: if you have SDL and SDL-ttf already, its probably a few kilobytes
15:25:57 <ehird> pumpkin: Crazy, i was just thinking about objc bindings
15:26:01 <CakeProphet> @let replaceElem o n = filterMap (==o) (const n)
15:26:02 <pumpkinbot>  Defined.
15:26:04 <Gracenotes> it's performance-efficient due to laziness
15:26:16 <CakeProphet> > replaceElem 'e' 'u' "Hello, World!"
15:26:17 <pumpkinbot>   "Hullo, World!"
15:26:25 <pumpkin> ehird: :D
15:26:49 <CakeProphet> does the standard lib already have a full-fledged replace function?
15:26:49 <Gracenotes> CakeProphet: I've had to use filterMap before, and map . filter works great :D
15:26:54 <ehird> pumpkin: Not an issue; any code other than my own is inferior and must eventually be replaced, so that's no obstacle.
15:27:04 <CakeProphet> Gracenotes:  map . filter is different from my implementation.
15:27:08 <ddarius> map
15:27:21 <loadquo> Peaker: At some point in the future I'll want to implement something like the following. An updating image with millions of rectangles, clicking on the each rectangle would bring up a different dialog box. Also I want to be able to zoom in, and display different things at different levels of zoom.
15:27:35 <loadquo> Sound doable, in the long term?
15:27:37 <CakeProphet> ...is there a particular reason for the choice of seperating map and fmap?
15:27:48 <Gracenotes> CakeProphet: oh... then it's not really a filterMap :)
15:27:54 <ehird> CakeProphet: and map and (.)
15:27:56 <ehird> err fmap
15:27:56 <ddarius> CakeProphet: Not much of one.
15:27:59 <ehird> we should just have .
15:28:03 <ehird> succ . [1,2,3]
15:28:03 <BMeph_> Gracenotes: Except filter removes elements from a list.
15:28:06 <conal> Peaker: i guess i don't have sdl yet.  checking on size.  we're bandwidth-limited here with our satellite-based internet, which so far is the only game in the woods.
15:28:12 <ehird> > let (.) = fmap in succ . [1,2,3]
15:28:13 <pumpkinbot>   [2,3,4]
15:28:15 <CakeProphet> ddarius:  I suppose the type signature of map is easier to understand for newcomers.
15:28:15 <Gracenotes> it doesn't filter anything. Just replaces
15:28:21 <ehird> Caleskell had (.) = fmap
15:28:42 <ddarius> CakeProphet: That's about it.
15:28:47 <Gracenotes> BMeph_: yes. And that's why calling his function filterMap is probably not a good idea ;)
15:28:52 <conal> is lambdabot (.) now function composition?  category composition?
15:28:58 <conal> @type (.)
15:29:00 <pumpkinbot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:29:00 <Peaker> loadquo: sounds so to me.. not sure about performance relating to actual numbers
15:29:32 <ehird> conal: unfortunately, caleskell was murdered.
15:29:35 <ehird> in an act of blind conformance.
15:29:55 <ehird> Shed a tear.
15:30:13 <BMeph_> Although, calling it "mapFilter" is kind of sexy - you're filtering the map over the list, not the list itself. :)
15:30:15 <CakeProphet> :t isInfixOf
15:30:16 <pumpkinbot> forall a. (Eq a) => [a] -> [a] -> Bool
15:30:22 <CakeProphet> > isInfixOf "lol "lololol"
15:30:23 <pumpkinbot>       lexical error in string/character literal at character '\n'
15:30:30 <CakeProphet> > isInfixOf "lol""lololol"
15:30:32 <pumpkinbot>   True
15:30:54 <BMeph_> @let contains = flip isInfixOf
15:30:54 <pumpkinbot>  <local>:6:16:
15:30:54 <pumpkinbot>      Ambiguous type variable `a' in the constraint:
15:30:54 <pumpkinbot>        `Eq...
15:31:01 <ehird> > isInfixOf "green" "purplegreen"
15:31:02 <pumpkinbot>   True
15:31:04 <ehird> > isInfixOf "green" "purplegreenle"
15:31:05 <pumpkinbot>   True
15:31:14 * Gracenotes paints #haskell purplegreenle
15:32:24 <ehird> Gracenotes: It's the best colour!
15:32:31 <Olathe> @src isInfixOf
15:32:31 <pumpkinbot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
15:32:31 <ehird> All the advantages of purple, green, and le!
15:32:33 <Gracenotes> goes without saying
15:32:53 <dolio> Better than grue?
15:32:56 <conal> Peaker: do you now which libsdl-dev i want?  e.g., libsdl-gfx1.2-dev ?  also, which sdl-ttf ?
15:33:31 <Olathe> > get
15:33:32 <pumpkinbot>       No instance for (Show (m s))
15:33:32 <pumpkinbot>        arising from a use of `show' at <in...
15:33:43 <CakeProphet> :t span
15:33:44 <pumpkinbot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:33:48 <ehird> dolio: Grue is not a colour. :P
15:33:54 <ehird> :T get
15:33:59 <ehird> oh, state
15:34:02 <Peaker> conal: I think just libsdl-ttf2.0-dev and libsdl1.2-dev
15:34:10 * loadquo goes to download lui
15:34:13 <dolio> Are you sure?
15:34:25 <Gracenotes> grue may or may not be a color
15:34:33 <Gracenotes> we have yet to examine it
15:35:03 <tromp_> u have yet to examine the dictionary?
15:35:08 <BMeph_> Grue is a monster. ;p
15:35:11 <dolio> Grue is a 'color' from a thought experiment that's supposed to convince you that the problem of induction is an actual problem.
15:35:24 <dolio> Or something like that.
15:35:51 <tromp_> hmm, i remember a grue in some online MUD
15:35:54 <Gracenotes> bleen too
15:35:59 <dolio> There's also bleen, apparently.
15:36:00 <conal> Peaker: i'll add it to my download-when-in-civilization list
15:36:02 <Gracenotes> tromp_: Zork! :)
15:36:09 <Peaker> conal: heh, ok, cool
15:36:14 <Gracenotes> I won that game a few years back
15:36:19 <Gracenotes> darn thief.
15:36:29 <Olathe> Killing the thief is easy with save files.
15:36:43 <Gracenotes> yeah, I had those, thankfully
15:38:57 <CakeProphet> > let replace o n [] = []; replace o n list@(x:xs) = if o `isPrefixOf`list then (n ++ replace o n (drop (length o) list) else x : replace o n xs in replace "Hello" "Take over the"
15:38:58 <pumpkinbot>   mueval: Prelude.read: no parse
15:38:58 <CakeProphet> ...
15:39:47 <Gracenotes> your parens
15:40:03 <CakeProphet> > let replace o n [] = []; replace o n list@(x:xs) = if o `isPrefixOf`list then n ++ replace o n (drop (length o) list) else x : replace o n xs in replace "Hello" "Take over the" "Hello, World!"
15:40:04 <pumpkinbot>   "Take over the, World!"
15:40:05 <CakeProphet> silly parens
15:40:28 <Olathe> (before, during, after)
15:40:54 <Gracenotes> yeah, parens, always telling you when to go to bed and to clean your room
15:42:42 <Olathe> > let zomg xs = head . filter isPrefixOf xs . tails in zomg "Hello" "...Hello..."
15:42:43 <pumpkinbot>   Couldn't match expected type `Bool'
15:42:51 <Olathe> > let zomg xs = head . filter (isPrefixOf xs) . tails in zomg "Hello" "...Hello..."
15:42:52 <pumpkinbot>   "Hello..."
15:43:11 <Olathe> Hmm...
15:43:20 <CakeProphet> ah
15:44:02 <Axman6> @pl \f g h x -> f (g x) (h x)
15:44:02 <pumpkinbot> liftM2
15:44:08 <Axman6> ah, handeh
15:44:36 <Olathe> > let zomg xs ys = zipWith map (map splitAt [0..]) ys in zomg "Hello" "...Hello..."
15:44:37 <pumpkinbot>   Couldn't match expected type `[[a]]' against inferred type `Char'
15:44:52 <conal> Axman6: aka liftA2
15:45:07 <conal> i wish @pl would use Applicative over Monad when possible.
15:45:15 <dcoutts> @seen Saizan
15:45:15 <pumpkinbot> Saizan is in #haskell-in-depth, #haskell and #haskell.it. I last heard Saizan speak 2h 11m 23s ago.
15:45:30 <ddarius> conal: Make a patch.
15:45:32 <conal> since Applicative suggests more powerful & simple generalizations.
15:45:59 <conal> ddarius: oh, good idea.  thanks.  lambdabot repo?
15:46:06 <ddarius> @version
15:46:06 <pumpkinbot> lambdabot 4.2.2
15:46:06 <pumpkinbot> darcs get http://code.haskell.org/lambdabot
15:46:19 <conal> :)
15:46:30 <Gracenotes> hm... similar to bind... lemmethink
15:46:33 <Gracenotes> @pl \f g x -> f (g x ) x
15:46:34 <pumpkinbot> flip flip id . liftM2
15:46:43 <Gracenotes> @pl \f g x -> f x (g x)
15:46:46 <pumpkinbot> ap
15:46:48 * conal adds to download-when-in-civilization list
15:46:59 <conal> :p
15:47:01 <Saizan> dcoutts: hi, i was thinking that the happstack team could take advantage of cabal-install's build-reports to get reports from more platforms
15:47:08 <Gracenotes> @src (->) >>=
15:47:08 <pumpkinbot> Source not found. That's something I cannot allow to happen.
15:47:15 <conal> Gracenotes: the famous S combinator.
15:47:20 <Gracenotes> yes...
15:47:33 <dolio> @type flip flip id . liftM2
15:47:34 <dcoutts> Saizan: right yes, you should be able to set up a hackage server
15:47:35 <pumpkinbot> forall a1 a2 r. (a1 -> a2 -> r) -> (a2 -> a1) -> a2 -> r
15:47:35 <pumpkinbot> dcoutts: You have 1 new message. '/msg pumpkinbot @messages' to read it.
15:47:39 <dolio> @type ap . flip
15:47:41 <pumpkinbot> forall a b c. (a -> b -> c) -> (b -> a) -> b -> c
15:47:58 * dolio beats @pl
15:48:06 <Gracenotes> @type (>>=)
15:48:07 <pumpkinbot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:48:27 <conal> flip f <*> g
15:48:37 <Gracenotes> (x -> a) -> (a -> x -> b) -> (x -> b)
15:49:08 <Gracenotes> flipping... (a -> x -> b) -> (x -> a) -> x -> b
15:49:12 <CakeProphet> > [id, (+3), (-3)] <*> [2,3,4]
15:49:13 <pumpkinbot>       No instance for (Num (a -> a))
15:49:13 <pumpkinbot>        arising from a use of `negate' at...
15:49:21 <jeffwheeler> I want to write a quasi-quoter to parse something like [$keys|C-M-k] --- something really simple --- but I'm a bit overwhelmed by all this Template Haskell stuff.
15:49:24 <CakeProphet> > [id, (+3), (subtract 3)] <*> [2,3,4]
15:49:26 <pumpkinbot>   [2,3,4,5,6,7,-1,0,1]
15:49:32 <jeffwheeler> Should I even be looking at TH, or just quasi-quoting stuff, or what?
15:49:36 <jeffwheeler> I'm not really sure what I'm talking about.
15:49:59 <mmorrow> jeffwheeler: it's real easy. what do you want  [$keys|C-M-k] to produce?
15:50:11 <mmorrow> you can create anything of any type
15:50:18 <Gracenotes> ah, so that might be why @pl apparently prefers =<< to >>= in the function ap monad
15:50:30 <jeffwheeler> mmorrow: something like KeyEvent Key [Modifier] or something
15:51:01 <ddarius> Gracenotes: @pl is completely arbitrary.
15:51:03 <mmorrow> bear in mind that you can have it splice to /different/ types depending on the input too
15:51:09 <jeffwheeler> Given that I've already defined a Key = KASCII Char (among other things) and Modifier = MCtrl, etc.
15:51:37 <mmorrow> ok, so    data KeyEvent = KeyEvent Key Modifier    then?
15:51:41 <pumpkin> Gracenotes: I prefer =<< too, but I'm just as arbitrary :P
15:51:50 <jeffwheeler> mmorrow: yep.
15:52:05 <mmorrow> cool, lemme think about it for a sec then i'll paste something
15:52:12 <jeffwheeler> mmorrow: sweet, thank you very much.
15:52:17 <mmorrow> :) no
15:52:18 <CakeProphet> > 'e' <$ "Hello, World!
15:52:18 <mmorrow> np
15:52:19 <pumpkinbot>       lexical error in string/character literal at character '\n'
15:52:25 <CakeProphet> > 'e' <$ "Hello, World!"
15:52:26 <pumpkinbot>   "eeeeeeeeeeeee"
15:52:35 <Gracenotes> ddarius: when does it choose one over the other, though?
15:52:47 <dskippy> Does anyone know if there is a well-defined process for building a Haskell program into a shared-object and allowing other languages to link to it as if it were written in C, using their own FFI? I have read a bit about it. Mostly old blog posts that look like they were delving into uncharted territory.
15:52:52 <ddarius> Gracenotes: Not arbitrary that way, arbitrary in the rules/primitives it uses.
15:52:56 <Gracenotes> certain rules contain >>= and other rules contain <<=, I suppose?
15:53:05 <jeffwheeler> > do { a <- "Hello, World!" ; return e }
15:53:06 <pumpkinbot>  Terminated
15:53:09 <Gracenotes> er, =<<
15:53:10 <jeffwheeler> > do { a <- "Hello, World!" ; return 'e }
15:53:11 <pumpkinbot>       lexical error in string/character literal at character ' '
15:53:11 <jeffwheeler> ack
15:53:14 <jeffwheeler> > do { a <- "Hello, World!" ; return 'e' }
15:53:15 <pumpkinbot>   "eeeeeeeeeeeee"
15:53:19 <dskippy> Anyone know if state of this has become more formalized any maybe supported by compilers?
15:53:30 <geezusfreeek> dskippy, yes, just look up GHC's FFI
15:53:34 * EmielRegis http://img84.imageshack.us/img84/5995/1233712192187gj0.jpg
15:53:47 <geezusfreeek> dskippy, you can call C from haskell and call haskell from C
15:53:59 <roconnor> > perm [1,2,3]
15:54:00 <pumpkinbot>   mueval: Prelude.read: no parse
15:54:07 <roconnor> > permute [1,2,3]
15:54:08 <pumpkinbot>   mueval: Prelude.read: no parse
15:54:10 <CakeProphet> > pure 3 :: [Int]
15:54:11 <pumpkinbot>   [3]
15:54:13 <dskippy> geezusfreeek: Hmm, I did. I found a lot of stuff on how call c from haskell but didn't see the opposite.
15:54:26 <dskippy> I'll read it really thoroughly now though if you say it's there.
15:54:26 <roconnor> @hoogle perm
15:54:27 <pumpkinbot> module Text.Parsec.Perm
15:54:27 <pumpkinbot> module Text.ParserCombinators.Parsec.Perm
15:54:27 <pumpkinbot> System.IO.Error permissionErrorType :: IOErrorType
15:54:32 <roconnor> @hoogle permute
15:54:32 <pumpkinbot> Text.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
15:54:32 <pumpkinbot> Text.ParserCombinators.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
15:54:32 <pumpkinbot> System.Console.GetOpt Permute :: ArgOrder a
15:54:47 <geezusfreeek> dskippy, http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Calling_Haskell_from_C
15:55:06 <mmorrow> jeffwheeler: oh, those are the yi types, right?
15:55:08 <dskippy> Thanks!
15:55:22 <jeffwheeler> mmorrow: well, "inspired" by Yi.
15:55:33 <geezusfreeek> actually that looks wrong
15:55:33 <mmorrow> cool, ok thinking
15:55:34 <jeffwheeler> mmorrow: I'm writing my own thing, with much of the core very similar to Yi.
15:55:42 <geezusfreeek> i have refered to a different source before. lemme try to find it
15:56:14 <BMeph_> roconnor: permutations
15:56:26 <roconnor> > permutations [1,2,3]
15:56:27 <pumpkinbot>   mueval: Prelude.read: no parse
15:56:35 <roconnor> @hoogle permutations
15:56:35 <pumpkinbot> No results found
15:56:46 <yitz> it's new, this bot doesn't know about it yet
15:56:50 <ddarius> :t permutations
15:56:51 <pumpkinbot> Not in scope: `permutations'
15:56:58 <BMeph_> , permutations [1,2,3]
15:57:00 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
15:57:01 <CakeProphet> :t (+3) <$> (subtract 3)
15:57:02 <geezusfreeek> dskippy, here we go: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#ffi-library
15:57:02 <pumpkinbot> forall a. (Num a) => a -> a
15:57:13 <CakeProphet> (+3) <$> (subtract 3) 5
15:57:16 <roconnor> , permutations [1..]
15:57:18 <lunabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
15:57:23 <CakeProphet> > (+3) <$> (subtract 3) 5
15:57:24 <pumpkinbot>       No instance for (Num (f a))
15:57:24 <pumpkinbot>        arising from the literal `3' at <int...
15:57:33 <BMeph_> I guess p-bot is still 6.8.x; pity. :\
15:57:36 <roconnor> , tail (permutations [1..])
15:57:38 <lunabot>  [[2,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
15:57:48 <yitz> preflex: > permutations [1,2,3]
15:58:01 <yitz> preflex list
15:58:02 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
15:58:20 <yitz> oh, i forgot, preflex is in C
15:58:28 <CakeProphet> > (+3) <*> (subtract 3) 5
15:58:29 <pumpkinbot>       Overlapping instances for Show ((a -> b) -> b)
15:58:29 <pumpkinbot>        arising from a us...
15:58:37 <CakeProphet> :t (+3) <*> (subtract 3) 5
15:58:38 <pumpkinbot> forall a b. (Num ((a -> b) -> a), Num (a -> b)) => (a -> b) -> b
15:58:57 <BMeph_> > (+3) <*> (subtract 3) $ 5
15:58:58 <pumpkinbot>       Occurs check: cannot construct the infinite type: a = a -> b
15:58:58 <pumpkinbot>      Proba...
15:59:02 <CakeProphet> ...applicative always confuses me
15:59:33 <BMeph_> > (+3) <$> (subtract 3) $ 5
15:59:35 <pumpkinbot>   5
15:59:56 <BMeph_> > (+3) <$> (*5) <$>(subtract 3) $ 5
15:59:57 <pumpkinbot>   13
16:00:01 <dolio> > (+) <*> subtract 3 $ 5
16:00:03 <pumpkinbot>   7
16:00:29 <drhodes> :t <*>
16:00:30 <pumpkinbot> parse error on input `<*>'
16:00:59 <drhodes> :t (<*>)
16:01:01 <pumpkinbot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:01:44 <skorpan> :t (+) <*> subtract 3 $ 5
16:01:45 <pumpkinbot> forall a. (Num a) => a
16:01:52 <skorpan> :t (+) <*> subtract 3
16:01:54 <pumpkinbot> forall a. (Num a) => a -> a
16:02:08 <skorpan> okay, i'll never figure that one out
16:02:23 <Gracenotes> that should be 0, no?
16:02:33 <ddarius> No
16:02:34 <skorpan> what? no, i meant the expression
16:02:41 <Gracenotes> hm...
16:02:57 <skorpan> :t subtract
16:02:58 <pumpkinbot> forall a. (Num a) => a -> a -> a
16:03:01 <Olathe> > ((+) <*> subtract 3) x y
16:03:02 <pumpkinbot>   Couldn't match expected type `t -> t1' against inferred type `Expr'
16:03:06 <Olathe> Lies.
16:03:17 <Olathe> > ((+) <*> subtract 3) x
16:03:18 <pumpkinbot>   x + (x - 3)
16:03:21 <ddarius> (+) <*> subtract 3 $ 5 === 5 + subtract 3
16:03:26 <ddarius> (+) <*> subtract 3 $ 5 === 5 + subtract 3 5
16:03:48 <yitz> === ?
16:03:57 <Gracenotes> :t (,) <*> length
16:03:58 <pumpkinbot> forall a. [a] -> ([a], Int)
16:04:05 <yitz> @hoogle (===)
16:04:05 <pumpkinbot> No results found
16:04:17 <drhodes> yitz: I think that's "defined"
16:04:18 <roconnor> @type random
16:04:19 <pumpkinbot> forall g a. (RandomGen g, Random a) => g -> (a, g)
16:04:28 <Gracenotes> :t (,) >>= length
16:04:29 <pumpkinbot>     Couldn't match expected type `b -> (a, b)'
16:04:29 <pumpkinbot>            against inferred type `[a1]'
16:04:29 <pumpkinbot>     Probable cause: `length' is applied to too many arguments
16:04:41 <yitz> oh
16:04:42 <Olathe> > f >>= g
16:04:43 <pumpkinbot>       No instance for (Show (m b))
16:04:43 <pumpkinbot>        arising from a use of `show' at <in...
16:04:47 <roconnor> @type randomIO
16:04:47 <Olathe> > (f >>= g) x
16:04:48 <pumpkinbot> forall a. (Random a) => IO a
16:04:48 <pumpkinbot>   Add a type signature
16:04:53 <Olathe> > (f >>= g) x :: Expr
16:04:54 <pumpkinbot>   Add a type signature
16:04:58 <roconnor> @type randomRIO
16:05:00 <Olathe> :(
16:05:00 <pumpkinbot> forall a. (Random a) => (a, a) -> IO a
16:05:22 <Olathe> > (f >>= g) x y :: Expr
16:05:23 <pumpkinbot>   Add a type signature
16:05:44 <Axman6> :t x
16:05:45 <pumpkinbot> Expr
16:05:47 <Gracenotes> ah
16:05:56 <Gracenotes> :t length >>= (,)
16:05:57 <pumpkinbot> forall a. [a] -> (Int, [a])
16:05:57 <Olathe> > (f >>= g) (x :: Expr)
16:05:58 <pumpkinbot>   Add a type signature
16:06:01 <Olathe> :(
16:06:08 <Gracenotes> I confused the argument order
16:06:14 <travisbrady> which syllable does one stress in the word 'applicative'?
16:06:19 <dolio> > ((f :: Expr -> Expr) >>= g) x y :: Expr
16:06:21 <pumpkinbot>   g (f x) x y
16:06:26 <Axman6> :t (?f >>= ?g) x
16:06:27 <pumpkinbot> forall a b. (?g::a -> Expr -> b, ?f::Expr -> a) => b
16:06:48 <noZone> My first corecursive function, "coPrimes": http://haskell.pastebin.com/m78eedd4f
16:06:59 <Gracenotes> that's interesting. <*> and >>= apply the arguments in a different order, for (->)
16:07:01 <Olathe> @pl \a -> (a, f a)
16:07:01 <pumpkinbot> ap (,) f
16:07:06 <Olathe> @pl \a -> (f a, a)
16:07:06 <pumpkinbot> (,) =<< f
16:07:06 <Axman6> travisbrady: 'ic' i think
16:07:18 <Axman6> appLICative
16:07:21 <travisbrady> Axman6: thank you, that's what i'd guessed
16:08:00 <CakeProphet> > length >>= (,) [1..10]
16:08:01 <Olathe> > (f x, g x)
16:08:01 <pumpkinbot>   Couldn't match expected type `[a] -> b'
16:08:02 <pumpkinbot>   Add a type signature
16:08:07 <Gracenotes> how about a Haskell pronunciation contest? :) First word: Haskell
16:08:08 <CakeProphet> > length >>= (,) $ [1..10]
16:08:08 <Olathe> > (f x, g x) :: (Expr, Expr)
16:08:09 <pumpkinbot>   (10,[1,2,3,4,5,6,7,8,9,10])
16:08:09 <pumpkinbot>  Terminated
16:08:20 <Axman6> Gracenotes: Haskell
16:08:22 <Axman6> yes!
16:08:34 <Gracenotes> success!
16:08:47 <CakeProphet> > length >>= id $ [1..10]
16:08:48 <pumpkinbot>   Couldn't match expected type `[a] -> b' against inferred type `Int'
16:09:02 <Gracenotes> @src join
16:09:02 <pumpkinbot> join x =  x >>= id
16:09:23 <dolio> @pl ap . flip
16:09:23 <pumpkinbot> ap . flip
16:09:36 <roconnor> @type readLn
16:09:37 <pumpkinbot> forall a. (Read a) => IO a
16:09:39 <Gracenotes> > (*) >>= id $ 10
16:09:40 <pumpkinbot>   100
16:09:55 <roconnor> @type getLine
16:09:56 <pumpkinbot> IO String
16:10:16 <roconnor> @type reads
16:10:18 <pumpkinbot> forall a. (Read a) => String -> [(a, String)]
16:10:20 <Axman6> @unpl ap . flip
16:10:20 <pumpkinbot> (\ f k -> (\ b c -> f c b) >>= \ h -> k >>= \ g -> return (h g))
16:10:21 <dolio> > id >>= (*) $ 10
16:10:22 <pumpkinbot>   100
16:10:27 <Axman6> o.O
16:10:33 <Gracenotes> .-.
16:10:57 <Gracenotes> the function application monad doesn't seem particularly monadic. But the types fit, at least, and so do the laws
16:10:59 <roconnor> @type maybe
16:11:00 <pumpkinbot> forall b a. b -> (a -> b) -> Maybe a -> b
16:11:26 <Gracenotes> at least in the "monads as containers" sense
16:11:40 <ddarius> Moral of the story: Monads aren't containers.
16:11:45 <Gracenotes> :)
16:12:00 <CakeProphet> @pl (\f g x -> g (f x) x)
16:12:00 <pumpkinbot> flip flip id . (ap .) . flip (.)
16:12:08 <Gracenotes> :t (id >>=)
16:12:10 <pumpkinbot> forall a b. (a -> a -> b) -> a -> b
16:12:24 <Gracenotes> :t (>>= id)
16:12:25 <pumpkinbot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
16:12:41 <mmorrow> jeffwheeler: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1198#a1198
16:12:49 <roconnor> @type readsLn
16:12:50 <pumpkinbot> Not in scope: `readsLn'
16:12:53 <Gracenotes> huh. same thing. I guess if the function monad were a MonadPlus, id would be zero
16:12:58 <CakeProphet> > length >>= drop $ [1..10]
16:12:59 <pumpkinbot>  Terminated
16:13:06 <Gracenotes> @instances MonadPlus
16:13:06 <pumpkinbot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:13:36 <mmorrow> jeffwheeler: so if you do     (\x -> [| x |])  that means that the type of `x' must be an instance of `Lift'
16:13:38 <jeffwheeler> mmorrow: sweet, thanks a ton; I'll take a look now.
16:13:52 <roconnor> >do let {False = True} [7]
16:13:55 <roconnor> > do let {False = True} [7]
16:13:56 <pumpkinbot>       The last statement in a 'do' construct must be an expression
16:14:02 <roconnor> > do let {False = True}; [7]
16:14:03 <pumpkinbot>   [7]
16:14:13 <mmorrow> jeffwheeler: i just did a quicky bootleg parser, but the TH boilerplate is there
16:14:37 <roconnor> > do let {Just r = Nothing}; [r]
16:14:38 <jeffwheeler> mmorrow: I understand; I really appreciate the help.
16:14:38 <pumpkinbot>   mueval: Prelude.read: no parse
16:14:38 <pumpkinbot>  mueval: [*** Exception: /tmp/16653727739313...
16:14:48 <mmorrow> it should be straightforward how to extend it, but if you need any help i'd be happy to :)
16:14:50 <mmorrow> np
16:14:52 <roconnor> > (do let {Just r = Nothing}; [r]) :: [Integer]
16:14:53 <pumpkinbot>   mueval: Prelude.read: no parse
16:14:53 <pumpkinbot>  mueval: [*** Exception: /tmp/79892326214305...
16:14:54 <newsham> > id >>= (,) $ 10
16:14:55 <pumpkinbot>   (10,10)
16:15:03 <mmorrow> (happy to help that is ;)
16:15:11 <newsham> > (+1) >>= (,) $ 10
16:15:13 <pumpkinbot>   (11,10)
16:15:25 <Axman6> , (\x -> [| x |]) 10
16:15:27 <lunabot>  LitE (IntegerL 10)
16:15:33 <CakeProphet> > length >>= drop $ [1..4]
16:15:34 <Axman6> , (\x -> [| x |]) 10.0
16:15:35 <pumpkinbot>   []
16:15:35 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
16:15:48 <Axman6> , (\x -> [| x |]) (10.0 :: Double)
16:15:49 <lunabot>  luna: No instance for (Language.Haskell.TH.Syntax.Lift GHC.Types.Double)
16:16:12 <mmorrow> , (\x -> [| x :: Int |]) 10.0
16:16:13 <lunabot>  luna: No instance for (GHC.Real.Fractional GHC.Types.Int)
16:16:20 <CakeProphet> > repeat <*> take $ 5
16:16:21 <mmorrow> , (\x -> [| x :: Int |]) 10
16:16:21 <pumpkinbot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
16:16:22 <lunabot>  SigE (LitE (IntegerL 10)) (ConT Int)
16:16:43 <CakeProphet> :t repeat <*> take
16:16:45 <pumpkinbot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
16:16:45 <pumpkinbot>     Probable cause: `repeat' is applied to too many arguments
16:16:45 <pumpkinbot>     In the first argument of `(<*>)', namely `repeat'
16:16:47 <Axman6> , (\x -> [| x + x * x |]) 10
16:16:48 <lunabot>  InfixE (Just (LitE (IntegerL 10))) (VarE +) (Just (InfixE (Just (LitE (In...
16:16:49 <mmorrow> , (\x -> [| x |]) (10::Int)
16:16:50 <lunabot>  LitE (IntegerL 10)
16:17:00 <Gracenotes> does lambdabot create files in /tmp/randomnumber, execute them, and then report the result...?
16:17:24 <CakeProphet> :t pure take <*> repeat
16:17:25 <pumpkinbot>     Couldn't match expected type `Int' against inferred type `[a]'
16:17:25 <pumpkinbot>       Expected type: a -> Int
16:17:25 <pumpkinbot>       Inferred type: a -> [a]
16:17:31 <mmorrow> , (\x -> [|x|]) (unQ[|\x -> x|])
16:17:33 <lunabot>  AppE (AppE (ConE LamE) (ListE [AppE (ConE VarP) (AppE (AppE (ConE Name) (...
16:17:40 <mmorrow> double meta!
16:17:41 <CakeProphet> :t pure take <*> length
16:17:42 <pumpkinbot> forall a a1. [a1] -> [a] -> [a]
16:18:03 <CakeProphet> :t pure take <*> length $ [1..10] [1..100]
16:18:04 <pumpkinbot>     Couldn't match expected type `t -> [a]'
16:18:04 <pumpkinbot>            against inferred type `[a1]'
16:18:04 <pumpkinbot>     In the second argument of `($)', namely `[1 .. 10] ([1 .. 100])'
16:18:36 <CakeProphet> :t pure take <*> length $ [1..10] $ [1..100]
16:18:37 <pumpkinbot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
16:18:37 <pumpkinbot>     In the first argument of `($)', namely `[1 .. 10]'
16:18:37 <pumpkinbot>     In the second argument of `($)', namely `[1 .. 10] $ [1 .. 100]'
16:18:41 <CakeProphet> ...
16:19:00 <Axman6> > sum $ take 1000000 $ zipWith (/) (iterate negate 4) [1,3..]
16:19:00 <CakeProphet> :t (pure take <*> length) [1..10]  [1..100]
16:19:02 <pumpkinbot> forall a. (Enum a, Num a) => [a]
16:19:05 <pumpkinbot>   mueval: Prelude.read: no parse
16:19:05 <pumpkinbot>  mueval: *** Exception: stack overflow
16:19:11 <CakeProphet> > (pure take <*> length) [1..10]  [1..100]
16:19:13 <pumpkinbot>   [1,2,3,4,5,6,7,8,9,10]
16:19:19 <CakeProphet> wooo
16:19:30 <jml> oh no, they've stopped using english in #haskell
16:19:39 <Axman6> > sum $ take 100000 $ zipWith (/) (iterate negate 4) [1,3..]
16:19:40 <pumpkinbot>   3.1415826535897198
16:19:49 <CakeProphet> I find Haskell sufficient enough to communicate.
16:19:55 <CakeProphet> > (pure take <*> length) [1..5]  [1..100]
16:19:57 <stevengrady> There are no humans left, just bots talking
16:19:57 <pumpkinbot>   [1,2,3,4,5]
16:19:57 <elly> Axman6: what?
16:20:04 <dolio> > zipWith (const id) [1..10] [1..100]
16:20:05 <pumpkinbot>   [1,2,3,4,5,6,7,8,9,10]
16:20:06 <CakeProphet> ...I just made const for lists.
16:20:12 <Axman6> elly: ? it's pi
16:20:16 <augustss_> We are all bots
16:20:17 <elly> yes, but why?
16:20:27 <elly> I mean why does that yield pi
16:20:29 <Axman6> something on planet haskell... why not?
16:20:38 <elly> no, I mean mathematically speaking :P
16:20:42 <Twey> Hahaha
16:20:50 <Axman6> no idea, it's the Gregory-Leibniz series http://en.wikipedia.org/wiki/Leibniz_formula_for_pi
16:21:22 <augustss_> 4 * atan 1
16:21:50 <stevengrady> The confusing thing is that it should be 3.1415 _9_ 26535...
16:22:01 <stevengrady> the 8 also appears in Real World Haskell.  I assumed it was a typo, but I guess not..
16:22:02 <augustss_> And you get the series from the Taylor series for stan
16:22:30 <roconnor> @paste
16:22:30 <pumpkinbot> Haskell pastebin: http://hpaste.org/new
16:22:33 <dolio> > head . drop 1000000 $ zipWith (/) (iterate negate 4) [1,3..]
16:22:35 <pumpkinbot>   mueval: Prelude.read: no parse
16:22:35 <pumpkinbot>  mueval: *** Exception: stack overflow
16:22:38 <augustss_> It's a really bad way to compute pi
16:22:47 <pumpkin> aw
16:22:56 <CakeProphet> so is (*)   flip (>>=)  ?
16:22:56 <Axman6> augustss_: heh. yep
16:22:58 <CakeProphet> for functions.
16:23:05 <dolio> > head . drop 1000000 $ zipWith (/) (cycle [4,-4]) [1,3..]
16:23:07 <pumpkinbot>   mueval: Prelude.read: no parse
16:23:07 <pumpkinbot>  mueval: *** Exception: stack overflow
16:23:08 <pumpkin> CakeProphet: ?
16:23:10 <dolio> Bah.
16:23:12 <CakeProphet> er... <*>
16:23:12 <Gracenotes> CakeProphet: <*>?
16:23:15 <stevengrady> Im' not surprised that it's wrong (it's only an approximation), but the 8 digits _after_ the wrong one are correct
16:23:15 <CakeProphet> yes.
16:23:59 <augustss_> That must me some fluke
16:24:13 <Gracenotes> for functions, (<*>) f g x = f x (g x)
16:24:23 <Axman6> > sum $ take 12345 $ zipWith (/) (iterate negate 4) [1,3..]
16:24:24 <Gracenotes> and f >>= k = \ r -> k (f r) r
16:24:25 <pumpkinbot>   3.1416736580448883
16:24:26 <dolio> > sum . take 1500000 $ zipWith (/) (iterate negate 4) [1,3..]
16:24:28 <Gracenotes> from the GHC/MTL source
16:24:32 <pumpkinbot>   mueval: Prelude.read: no parse
16:24:32 <pumpkinbot>  mueval: *** Exception: stack overflow
16:24:36 <Gracenotes> CakeProphet: so, I suppose it effectively is
16:24:48 <Gracenotes> something like it, anyway
16:25:16 <CakeProphet> hmmm... kind of reminds me of arrows.
16:26:01 <dolio> > 4 / (1000000 * 2 - 1)
16:26:02 <pumpkinbot>   2.0000010000005e-6
16:26:20 <Gracenotes> CakeProphet: compare, a b c -> b (a c) c ... b a c ->b c (a c)
16:26:25 <olivierp> Hi all! What could make GHC reject the exact type signature that it infers itself if none is given?
16:26:53 <Twey> Er, a contradictory usage?
16:27:20 <olivierp> Twey: what do you mean?
16:27:28 <augustss_> Olivierp: a weirdness. Has to do with ambigous type variables. Very annoying.
16:27:40 <Axman6> olivierp: does it have a forall in it?
16:27:51 <olivierp> Axman6: no
16:28:00 <olivierp> reply' :: (J.Assign b b1, Typeable b) =>
16:28:00 <olivierp>           b1 -> t -> SyncChan t1 -> Solution ()
16:28:04 <newsham> > 4 * atan 1
16:28:05 <pumpkinbot>   3.141592653589793
16:28:14 <Axman6> hmm, i find it odd seeing my own posts in my planet haskell RSS feed
16:28:33 <augustss_> Olivierp: multiparameter type classes are usually to blame
16:28:34 <Axman6> > 4 * atan 1 :: CReal
16:28:35 <pumpkinbot>   3.1415926535897932384626433832795028841972
16:28:45 <CakeProphet> > pi :: CReal
16:28:46 <pumpkinbot>   3.1415926535897932384626433832795028841972
16:28:49 <newsham> atan 1 = 1/1 - 1/3 + 1/5 - 1/7 ...
16:28:50 <olivierp> augustss_: where can I read more about ambiguous type variables?
16:28:55 <Gracenotes> > pi in CReal uses an atan formula
16:28:56 <pumpkinbot>   mueval: Prelude.read: no parse
16:28:57 <Gracenotes> er.
16:29:01 <Gracenotes> sorry, pumpkinbot
16:29:17 <CakeProphet> ...did someone redefine pi?
16:29:31 <augustss_> Olivierp: there is an open trac bug about it.
16:29:55 <newsham> ?src pi
16:29:55 <pumpkinbot> Source not found. Sorry about this, I know it's a bit silly.
16:30:19 <Gracenotes> @src CReal pi
16:30:19 <pumpkinbot> Source not found. My brain just exploded
16:30:31 <Gracenotes> pi is defined in each Floating instance
16:30:35 <newsham> Leibniz_formula_for_pi is taylor series for arctan(1)
16:31:01 <Axman6> > atan 0
16:31:02 <pumpkinbot>   0.0
16:31:07 <Axman6> > atan pi
16:31:08 <pumpkinbot>   1.2626272556789118
16:31:15 <ddarius> > tan pi
16:31:16 <pumpkinbot>   -1.2246467991473532e-16
16:31:17 <Axman6> > atan (pi/2)
16:31:18 <pumpkinbot>   1.0038848218538872
16:31:19 <augustss_> newsham: as I just said :)
16:31:25 <ddarius> > tan (pi/4)
16:31:26 <pumpkinbot>   0.9999999999999999
16:31:33 <Axman6> > atan (pi/4)
16:31:34 <pumpkinbot>   0.6657737500283538
16:31:46 <Axman6> > tan (pi/4) :: CReal
16:31:47 <pumpkinbot>   1.0
16:31:49 <newsham> augustss: i missed that, sorry.
16:31:54 <Axman6> CReal++
16:32:00 <CakeProphet> > atan (pi/4) == 1.0    -- ;)
16:32:01 <pumpkinbot>   False
16:32:17 <CakeProphet> lies.
16:32:17 <Gracenotes> atan (pi/4) doesn't mean too much mathematically
16:32:31 <newsham> > tan (pi/4)
16:32:31 <Axman6> > atan (4/pi)
16:32:32 <pumpkinbot>   0.9999999999999999
16:32:32 <pumpkinbot>  Terminated
16:32:37 <Axman6> > atan (4/pi)
16:32:39 <pumpkinbot>   0.9050225767665427
16:32:43 <Axman6> o.O
16:32:51 <Axman6> > atan (4/pi) :: CReal
16:32:52 <pumpkinbot>   0.9050225767665427556408039831275762329043
16:32:55 <Gracenotes> atan pi/4 is kinda like sin(sqrt(2)), or something
16:33:08 <ddarius> > atan (pi/4) == (1.0 :: CReal) -- CakeProphet
16:33:09 <pumpkinbot>   False
16:33:22 <olivierp> augustss_, Axman6: thanks. looks like I have more work to do...
16:33:22 <Gracenotes> well, not exactly. But it doesn't /seem/ significant
16:33:53 <mmorrow> jeffwheeler: i just realized that there is a "make-sense" way to do the pattern-context quoter http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1198#a1199
16:34:00 <Axman6> > tan (pi/4) == (1.0 :: CReal)
16:34:01 <pumpkinbot>   True
16:34:25 <mmorrow> jeffwheeler: which would rock for long case stmts of key sequences -> actions
16:34:42 <CakeProphet> > tan (pi/4)
16:34:43 <pumpkinbot>   0.9999999999999999
16:34:51 <CakeProphet> .....srsly?
16:34:55 <pumpkin> and 0.9999... is 1
16:34:57 <pumpkin> so that's good
16:34:57 <CakeProphet> I didn't know it would account for that.
16:35:01 <newsham> > tan (pi/4) == 1
16:35:03 <pumpkinbot>   False
16:35:04 <chrisdone> hi
16:35:12 <CakeProphet> just a CReal thing then?
16:35:15 <ddarius> > tan (pi/4) :: CReal
16:35:16 <pumpkinbot>   1.0
16:35:27 <jeffwheeler> mmorrow: wait, what?
16:35:32 <dolio> > tan (pi/4) == (1 :: CReal)
16:35:34 <pumpkinbot>   True
16:35:37 <mmorrow> (i used the `parsePat' function from haskell-src-meta, but if that dep is a problem/pain in your case you could do the translation by hand)
16:35:40 <CakeProphet> ddarius:  what causes that to happen?
16:35:56 <ddarius> CakeProphet: What to happen?
16:36:11 <CakeProphet> 0.999999 to change to 1.0 when it's CReal.
16:36:12 <mmorrow> jeffwheeler: what what?
16:36:15 <jeffwheeler> mmorrow: oh, I can do that. :)
16:36:29 <newsham> x=0.99999...;  10x-x = 9.999... - 0.999...; 9x = 9; x = 1
16:36:33 <jeffwheeler> mmorrow: I was planning on using a list of (Event, Action) type things, if that makes sense.
16:36:34 <Axman6> CakeProphet: CReal is more exact
16:36:34 <ddarius> CakeProphet: Doubles aren't arbitrary precision, CReal is.
16:36:35 <Gracenotes> in Python, math.tan(math.pi/4) yields 0.99999999999999989 too
16:36:44 <Gracenotes> well, there's an 8 there.
16:36:46 <jeffwheeler> mmorrow: although I'm not really sure what that means in relation to what you just told me.
16:36:47 <chrisdone> mmorrow: btw, I tried the latest liskel but it doesn't support half the faetues laid out in the paper and the compile errors are teh suck right now soi 'll try it again when therp does more updates
16:37:08 <mmorrow> jeffwheeler: oh, so you were gonna use `lookup' of the [(Event, Action)] ?
16:37:21 <sm> dons, thanks for rss2irc. I just sent two patch emails, the second is about a feed-fetching problem and might have got corrupted/lost, maybe you can let me know
16:37:23 <jeffwheeler> mmorrow: I haven't really thought that far ahead. :P
16:37:26 <mmorrow> chrisdone: oh cool, i haven't tried it yet
16:37:37 <jeffwheeler> mmorrow: but perhaps something like that, yes.
16:38:45 <olivierp> Could someone explain why the 'wrapper' method in the example here can never be called? http://hackage.haskell.org/trac/ghc/ticket/2885
16:39:21 <CakeProphet> :t unsafePtrEq
16:39:22 <pumpkinbot> Not in scope: `unsafePtrEq'
16:39:28 <CakeProphet> ...what's it called?
16:39:47 <dolio> , [$ty| reallyUnsafePtrEquality |]
16:39:51 <lunabot>  forall a . a -> a -> Bool
16:40:13 <CakeProphet> > let g = f; in reallyUnsafePtrEquality f g
16:40:14 <pumpkinbot>   mueval: Prelude.read: no parse
16:40:19 <Axman6> , reallyUnsafePointerEquality 10 (2*5)
16:40:21 <CakeProphet> > let g = f  in reallyUnsafePtrEquality f g
16:40:21 <lunabot>  luna: Not in scope: `reallyUnsafePointerEquality'
16:40:22 <pumpkinbot>   mueval: Prelude.read: no parse
16:40:31 <Axman6> , reallyUnsafePtrEquality 10 (2*5)
16:40:33 <lunabot>  False
16:40:38 <Gracenotes> reallyUnsafe? What's the worst that could happen?
16:40:39 <Axman6> , reallyUnsafePtrEquality 10 10
16:40:41 <lunabot>  False
16:40:41 <Gracenotes> segfault?
16:40:43 <CakeProphet> , let g = f  in reallyUnsafePtrEquality f g
16:40:44 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
16:40:57 <Axman6> , reallyUnsafePtrEquality 10 $! 10
16:40:59 <lunabot>  False
16:41:08 <Gracenotes> , let a = 5 in reallyUnsafePtrEquality a a
16:41:10 <lunabot>  True
16:41:17 <mmorrow> jeffwheeler: something like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1198#a1200
16:41:24 <CakeProphet> , let g = id  in reallyUnsafePtrEquality id g
16:41:26 <lunabot>  True
16:41:27 <Axman6> , reallyUnsafePtrEquality reallyUnsafePtrEquality reallyUnsafePtrEquality
16:41:29 <lunabot>  True
16:41:34 <Axman6> heh
16:41:34 <mmorrow> jeffwheeler: (is what i had in mind)
16:41:35 <Gracenotes> >_<
16:41:46 <jeffwheeler> mmorrow: ah, that'd work great too. :)
16:41:54 <mmorrow> jeffwheeler: but yeah, a [(Event, Action)] would work too
16:42:05 <ehird> what's reallyUnsafePointerEquality
16:42:08 <CakeProphet> hmmm... time to find unpredictable behavior in this "really unsafe" pointer equality.
16:42:14 <ehird> lunabot: src reallyUnsafePointerEquality
16:42:33 <mmorrow> jeffwheeler: this QQ is a nice instance of one where the existing TH Pat datatype is enough to get a useful pattern-context behavior
16:42:35 <Axman6> , id === id
16:42:36 <lunabot>  luna: Not in scope: `==='
16:42:40 <Axman6> , id ==== id
16:42:41 <lunabot>  luna: Not in scope: `===='
16:42:44 <mmorrow> .==.
16:42:52 <jeffwheeler> mmorrow: I first thought of [(Event, Action)] in the case that I, at some point, got enough motivation to implement the nicer, more extensible hierarchical version that Yi has.
16:42:55 <mmorrow> , id .==. id
16:42:57 <lunabot>  True
16:42:57 <Axman6> hmm, mmorrow, lunabot is yours right?
16:43:00 <mmorrow> yes
16:43:00 <Axman6> ah that's right
16:43:15 <CakeProphet> ...maybe an optimization will make .==. no longer do what you would think?
16:43:18 <jeffwheeler> @src (.==.)
16:43:18 <pumpkinbot> Source not found. Sorry about this, I know it's a bit silly.
16:43:18 <Axman6> , .==. .==. .==.
16:43:19 <lunabot>  luna: parse error on input `.==.'
16:43:20 <Gracenotes> again, how is it really unsafe?
16:43:33 <Gracenotes> besides, er, referential transparency
16:43:41 <mmorrow> , (.==.) .==. (.==.)
16:43:43 <lunabot>  True
16:43:56 <baaba> isn't that sufficient to be deemed "unsafe"?
16:43:57 <jeffwheeler> , :t (.==.)
16:43:58 <lunabot>  luna: Couldn't match expected type `(a1 -> a1 -> GHC.Bool.Bool) -> [a]'
16:44:02 <CakeProphet> Gracenotes:  I'd say it's just unpredictable. Haskell can be compiled a number of different ways... so it's not consistent between implementations.
16:44:28 <CakeProphet> I don't think it's "dangerous" though.
16:44:36 <mmorrow> Gracenotes: it depends on the underlying rep, eg the type of heap object underlying something depends on how evaluated it is, etc
16:44:41 <CakeProphet> it won't kill you.
16:45:03 <mmorrow> and if there are multiple threads, you can't know if something is getting evaluated behind your back
16:45:05 <dolio> , let x = 10 ; y = id x in reallyUnsafePtrEquality x y
16:45:07 <lunabot>  False
16:45:15 <dolio> , let x = 10 ; y = id x in y `seq` reallyUnsafePtrEquality x y
16:45:17 <lunabot>  False
16:45:30 <Gracenotes> it does show some interesting things about GHC's memory model, though
16:45:33 <Axman6> , let x = 2*5 in (x .==.) $! x
16:45:35 <lunabot>  False
16:45:39 <mmorrow> , closureType 42
16:45:41 <lunabot>  AP
16:45:47 <dolio> , let x = 10 ; y = id x in case y of e@(10) -> reallyUnsafePtrEquality x e
16:45:49 <lunabot>  False
16:45:53 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
16:45:55 <lunabot>  [AP,Constr]
16:46:05 <yitz> CakeProphet: if reallyUnsafePtrEquality x y then launchMissiles else putStr "Hi, Mom."
16:46:12 <Gracenotes> , let a = 5; b = 5; c = a in (a .==. b, b .==. c, a .==. c)
16:46:14 <lunabot>  (False,False,True)
16:46:57 <CakeProphet> > let x = [1,2,3,4,5] in (tail x) .==. (tail x)
16:46:58 <pumpkinbot>   mueval: Prelude.read: no parse
16:47:05 <mmorrow> , let x = 1 + 1 in [isFullyEvaluated x, x `seq` isFullyEvaluated x]
16:47:07 <lunabot>  [False,True]
16:47:08 <dolio> , let x = 10 ; y = id x in case y of e@(10) -> reallyUnsafePtrEquality y e
16:47:10 <lunabot>  True
16:47:23 <mmorrow> heh
16:47:36 <Gracenotes> >_>
16:47:40 <Axman6> , let x = 10# in isFullyEvaluated x
16:47:41 <lunabot>  luna: parse error on input `in'
16:47:44 <Axman6> lame
16:47:52 <CakeProphet> , let x = [1,2,3,4,5] in (tail x) .==. (tail x)
16:47:54 <lunabot>  False
16:47:54 <mmorrow> bytecode doesn't do unlifted things
16:47:58 <CakeProphet> ...oh my
16:47:58 <Axman6> mmorrow: where's the -XMagicHash!
16:48:00 <CakeProphet> interesting
16:48:14 <dolio> , let x = 1 + 1 in [x `seq` isFullyEvaluated x, isFullyEvaluated x]
16:48:16 <lunabot>  [True,False]
16:48:26 <mmorrow> Axman6: that won't change that byecode can't do a 1#
16:48:28 <Axman6> o.O
16:48:40 <Gracenotes> , let a = a in a .==. a
16:48:41 <CakeProphet> , let x = [1,2,3,4,5] in (head x) .==. (head x)
16:48:42 <Axman6> mmorrow: what do you mean?
16:48:42 <lunabot>  True
16:48:43 <lunabot>  False
16:48:50 <SamB> Axman6: it CAN'T
16:48:53 <Gracenotes> , let a = undefined in a .==. a
16:48:53 <CakeProphet> , let x = [1,2,3,4,5] in (head x) .==. (head x)
16:48:55 <mmorrow> Axman6: try to do use a 1# in ghci
16:48:55 <lunabot>  True
16:48:55 <lunabot>  False
16:48:57 <ddarius> , let x = [1,2,3,4,5]; y = tail x; z = tail x in (y .==. z, y `seq` z `seq` y .==. z)
16:48:59 <CakeProphet> ...
16:48:59 <lunabot>  (False,True)
16:49:05 <SamB> it might be unboxed, and not unlifted, that the bytecode can't do
16:49:17 <mmorrow> SamB: hmm, true
16:49:31 <Axman6> fair enough
16:50:47 <mmorrow> you can use the 1# over the course of defining a function, you just can't return one to byecode, or try to print it (which is returning it)
16:51:02 <Gracenotes> > (:)
16:51:03 <pumpkinbot>       Overlapping instances for Show (a -> [a] -> [a])
16:51:03 <pumpkinbot>        arising from a ...
16:51:41 <mmorrow> byTecode
16:51:47 <dolio> Prelude GHC.Exts> I# 1# ==> 1
16:51:49 <CakeProphet> , let x = [1..]; y = const x 2 in zipWith (.==.) x y
16:51:51 <lunabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,Tr...
16:51:59 <mmorrow> dolio: yes, exactly
16:52:27 <mmorrow> tag a = I# (dataToTag# a)
16:52:56 <mmorrow> is fun
16:53:15 <dolio> @type print
16:53:16 <pumpkinbot> forall a. (Show a) => a -> IO ()
16:53:29 <CakeProphet> , x = "lolcache?"; y = "lolcache?" in x .==. y
16:53:30 <lunabot>  luna: parse error on input `='
16:53:33 <dolio> Of course you can't print it.
16:53:38 <dolio> That a :: *.
16:53:39 <CakeProphet> , let x = "lolcache?"; y = "lolcache?" in x .==. y
16:53:41 <lunabot>  False
16:53:58 <mmorrow> dolio: erm, i meant returning it to a bytecode
16:54:15 <CakeProphet> , let x = [1..]; y = id  x in zipWith (.==.) x y
16:54:15 <Gracenotes> CakeProphet: interestingly, that would be True in java...
16:54:17 <lunabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,Tr...
16:54:18 <mmorrow> yeah you're right you can't print it
16:54:26 <CakeProphet> hmmm
16:54:34 <CakeProphet> , let x = [1..]; y = id  x in x .==. y
16:54:36 <lunabot>  False
16:54:42 <CakeProphet> that's odd
16:54:56 <kerlo> > concat [[x `div` 2 + 1..x] | x <- [1..]]
16:54:57 <pumpkinbot>   [1,2,2,3,3,4,3,4,5,4,5,6,4,5,6,7,5,6,7,8,5,6,7,8,9,6,7,8,9,10,6,7,8,9,10,11...
16:54:57 <CakeProphet> the pointers to the elements are equal but the lists themselves aren't.
16:54:58 <roconnor> Has anyone used \foo -> (fieldN foo, \x->foo{fieldN=x})  before  or anything of type (a -> (b,b->a))  ?
16:55:02 <roconnor> is this a lens?
16:55:11 <Gracenotes> , let a = "somelist"; b = a; c = a in b .==. c
16:55:13 <CakeProphet> does Haskell even use pointers to integers?
16:55:13 <lunabot>  True
16:55:24 <Gracenotes> , let a = [1..8]; b = a; c = a in b .==. c
16:55:26 <lunabot>  True
16:55:46 <CakeProphet> , let x = [1..]; y = const x 2 in x .==. y
16:55:48 <lunabot>  False
16:56:02 <Gracenotes> , let a = 1:2:3:4:5:undefined; b = a; c = a in b .==. c
16:56:04 <lunabot>  True
16:56:12 <Gracenotes> heh
16:56:16 <roconnor> @where lens
16:56:16 <pumpkinbot> I know nothing about lens.
16:56:20 <roconnor> @where lenses
16:56:20 <pumpkinbot> I know nothing about lenses.
16:56:26 <CakeProphet> @where sprockets.
16:56:26 <pumpkinbot> I know nothing about sprockets..
16:56:32 <dolio> , let x = [1..] y = const x 2 in case y of l@(_:_) -> l .==. x
16:56:33 <lunabot>  luna: parse error on input `='
16:56:33 <shapr> @go banana lens barbed wire
16:56:34 <pumpkinbot> http://etymon.blogspot.com/2004/08/bananas-lenses-envelopes-and-barbed.html
16:56:34 <pumpkinbot> Title: Etymon: Bananas, Lenses, Envelopes, and Barbed Wire.
16:56:35 <mmorrow> dolio: whoa, i'm wrong
16:56:42 <mmorrow> ghci> let f n = n +# 1#
16:56:44 <mmorrow> works
16:56:44 <dolio> , let x = [1..] ; y = const x 2 in case y of l@(_:_) -> l .==. x
16:56:47 <lunabot>  False
16:57:00 <mmorrow> i guess it's just unboxed tuples that bytecode can't do then
16:57:16 <roconnor> hmm
16:57:21 <roconnor> that's not it
16:57:32 <roconnor> the type (a -> (b,b->a))  seems very familiear
16:57:54 <roconnor> @hoogle (a -> (b,b->a))
16:57:55 <pumpkinbot> No results found
16:58:03 <mmorrow> looks like a lens to me
16:58:07 <dolio> Yes, that's a lens/functional reference.
16:58:32 <roconnor> dolio: but different from banana lenses, right?
16:58:44 <mmorrow> aren't those the cata brackets?
16:58:49 <roconnor> exactly
16:58:53 <dolio> Yeah. Lenses in that paper are one of the foomorphishm.
16:58:54 <roconnor> where is the lens reference?
16:58:57 <dolio> I can never remember which is which.
16:59:25 * mmorrow thinks the barbed wire brackets are ugly
16:59:26 <ddarius> Lenses are apomorphisms
16:59:29 <ddarius> er ana
16:59:38 <ddarius> (apo would be the dual to para)
16:59:47 <roconnor> focus people
16:59:51 <mmorrow> heh
16:59:52 <roconnor> a -> (b,b->a)
17:00:23 <stepcut> I am getting this error when I run, runhaskel Setup.hs haddock:
17:00:25 <stepcut> Failed to load interface for `Data.Generics.SYB.WithClass.Instances':
17:00:25 <stepcut>   no package matching syb-with-class-0.4 was found
17:00:48 <stepcut> which is true, because I upgrade to syb-with-class-0.5.1. I have no idea why it is looking for 0.4 at all
17:01:27 <Saizan> stepcut: do you have to configure again, maybe?
17:01:34 <Saizan> err, re-configure
17:01:40 <stepcut> Saizan: no I tried that
17:02:01 <dolio> roconnor: I'm not sure there's a reference. Just random blog posts and mailing list threads.
17:02:02 <roconnor> what's the paper on lenses called?
17:02:06 <roconnor> oh
17:02:14 <mmorrow> dolio: yeah, that's what i came up with too
17:02:18 <Saizan> stepcut: my second guess is old .hi files
17:02:24 <mmorrow> i thought there was a paper though
17:02:26 <ddarius> roconnor: There's more than one.
17:02:33 <roconnor> anyone
17:02:38 <roconnor> any paper
17:02:38 <mmorrow> there's that one language "Boomerang"
17:02:42 <stepcut> Saizan: yeah, but how do I figure out which old .hi
17:02:45 <mmorrow> (or something like that)
17:02:46 <roconnor> hmm
17:02:59 <ddarius> mmorrow: That's what it is (was?) called.
17:03:02 <dolio> Yeah. What was the name of that? Something derogatory about types.
17:03:08 <Saizan> stepcut: under dist/build i mean
17:03:08 <mmorrow> http://www.seas.upenn.edu/~harmony/
17:03:11 <loadquo> Roconnor > http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125 ?
17:03:20 <mmorrow> yeah looks like it's "Boomerang"
17:03:31 <stepcut> Saizan: no, I did clean as well
17:03:38 <mmorrow> http://www.cis.upenn.edu/~bcpierce/papers/boomerang.pdf
17:03:44 <roconnor> loadquo: the other lenses
17:03:46 <roconnor> :)
17:04:01 <ddarius> roconnor: You should get paper hits for "Functional References" too.
17:04:21 <roconnor> really?
17:04:30 <ddarius> @google "Functional References"
17:04:31 <pumpkinbot> No Result Found.
17:04:38 <roconnor> ah
17:04:46 <stepcut> ah, apparently it was something in my local package config
17:05:07 <mmorrow> this looks interesting http://www.cis.upenn.edu/~jnfoster/papers/quotient-lenses.pdf
17:05:22 <dolio> Oh, right, "Types Considered Harmful?" I guess that should have been easy to guess.
17:06:05 <ddarius> roconnor: http://www.springerlink.com/index/r5g9f70fllv5akeh.pdf
17:06:10 <ddarius> Crap hold on.
17:06:13 <roconnor> ooh
17:06:19 <mmorrow> dolio: heh
17:06:27 <roconnor> it seems like there might be hackage packages for this stuff
17:06:41 <ddarius> ftp://ftp.cs.kun.nl/pub/Clean/papers/2004/eves2004-FFormsCompRefs.pdf
17:06:48 <ddarius> roconnor: There is (are?)
17:07:17 <mmorrow> http://lambda-the-ultimate.org/node/2828
17:07:26 <mmorrow> "Types Considered Harmful"
17:07:27 <dolio> 28 megabytes for a 33 page PDF.
17:07:37 <mmorrow> someone didn't use pdfopt
17:07:45 <dolio> It's full of images.
17:07:47 <mmorrow> (or used a crapload of images)
17:07:50 <mmorrow> heh
17:08:34 <dolio> And powerpoint backgrounds.
17:08:47 <roconnor> @go "functional reference" site:hackage.haskell.org/cgi-bin/hackage-scripts/package
17:08:47 <pumpkinbot> No Result Found.
17:08:54 <roconnor> how am I going to find this
17:08:56 <mmorrow> dolio: ooh, shiny
17:09:07 <roconnor> @go "Lens" site:hackage.haskell.org/cgi-bin/hackage-scripts/package
17:09:08 <pumpkinbot> No Result Found.
17:11:34 <mmorrow> well i was half right about _#  in ghci:
17:11:38 <mmorrow> ghci> let x = 1#
17:11:38 <mmorrow> Top level: GHCi can't bind a variable of unlifted type: x :: Int#
17:12:28 <roconnor> bah, I'll just write my own
17:13:04 <mmorrow> iirc there was code for them in the early Category package
17:13:13 <mmorrow> (before it was added to base)
17:14:56 <kerm|t> I've been running some stats on #haskell logs, and  lemmih, sjanssen, byorgey, dcoutts, and dons, to be the 5 most useful people in here, by how much and by how many people thank them, over volume of text they've said.
17:16:00 <elly> that's unsurprising
17:16:21 <pumpkin> kerm|t: you should put your stats up somewhere!
17:17:08 <roconnor> @djinn (a -> (b,b ->a)) -> ((b -> c) -> b -> (b,d)) -> ((a -> c) -> a -> (a,d))
17:17:08 <pumpkinbot> f a b c d =
17:17:08 <pumpkinbot>     case a d of
17:17:08 <pumpkinbot>     (e, f) -> (f e,
17:17:08 <pumpkinbot>                case b (\ _ -> c d) e of
17:17:08 <pumpkinbot>                (_, g) -> g)
17:18:12 <kerm|t> pumpkin: ok, http://home.oth.net/haskell_usefulness-20090205_formula.txt
17:18:56 <kerm|t> sorry, 404
17:19:00 <mmorrow> @djinn (d -> o) -> (a -> (b, b -> (c, c -> (d, d -> o))))
17:19:00 <pumpkinbot> -- f cannot be realized.
17:19:18 <kerm|t> fixed
17:19:49 <mmorrow> @djinn (a -> (b, b -> (c, c -> (d, d -> o)))) -> (d -> o) -> a -> o
17:19:49 <pumpkinbot> f a b c =
17:19:49 <pumpkinbot>     case a c of
17:19:49 <pumpkinbot>     (d, e) -> case e d of
17:19:49 <pumpkinbot>               (f, g) -> case g f of
17:19:49 <pumpkinbot>                         (h, _) -> b h
17:22:04 <pumpkin> > let ('') = 5 in ''
17:22:05 <pumpkinbot>       lexical error in string/character literal at character '\''
17:23:43 <Saizan> kerm|t: nice, though there are some nicks that refer to the same person :)
17:23:50 <SamB> what do you call the two things involved in an application ?
17:23:53 <mmorrow> , (let tup a b = (TupleT 2 `AppT` a) `AppT` b; a .-> b = (ArrowT `AppT` a) `AppT` b in do a:b:ns <- replicateM 5 (newName "a"); return (foldr (\a b -> tup a (a .-> b)) (a .-> b) ns))
17:23:54 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Type'
17:24:16 <mmorrow> , (let tup a b = (TupleT 2 `AppT` a) `AppT` b; a .-> b = (ArrowT `AppT` a) `AppT` b in do a:b:ns <- fmap VarT `fmap` replicateM 5 (newName "a"); return (foldr (\a b -> tup a (a .-> b)) (a .-> b) ns))
17:24:17 <lunabot>  AppT (AppT (TupleT 2) (VarT a_2)) (AppT (AppT ArrowT (VarT a_2)) (AppT (A...
17:24:23 <mmorrow> , ppDoc `fmap` (let tup a b = (TupleT 2 `AppT` a) `AppT` b; a .-> b = (ArrowT `AppT` a) `AppT` b in do a:b:ns <- fmap VarT `fmap` replicateM 5 (newName "a"); return (foldr (\a b -> tup a (a .-> b)) (a .-> b) ns))
17:24:24 <lunabot>  (a_0, a_0 -> (a_1, a_1 -> (a_2, a_2 -> a_3 -> a_4)))
17:24:29 <SamB> mmorrow: what do you call the arguments to AppT ?
17:24:30 <mmorrow> grrr
17:24:40 <mmorrow> , src 'AppT
17:24:42 <lunabot>  data Type = ... | AppT Type Type | ...
17:24:42 <lunabot>  infixl 9
17:24:57 <mmorrow> , src 'appT
17:24:59 <lunabot>  appT :: TypeQ -> TypeQ -> TypeQ
17:25:06 <SamB> no, I mean, I want a word in the english language to use for each of the two ;-P
17:25:17 <mmorrow> um, Type ?
17:25:33 <dolio> The function and the value?
17:25:58 <mmorrow> , src 'AppE
17:25:59 <SamB> dolio: but ... this is type-level
17:26:01 <lunabot>  data Exp = ... | AppE Exp Exp | ...
17:26:01 <lunabot>  infixl 9
17:26:07 <mmorrow> it's no different really
17:26:12 <SamB> , src appT
17:26:13 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
17:26:18 <mmorrow> , 'appT
17:26:20 <lunabot>  Language.Haskell.TH.Lib.appT
17:26:23 <mmorrow> , src 'appT
17:26:26 <lunabot>  appT :: TypeQ -> TypeQ -> TypeQ
17:26:29 <mmorrow> , src 'appE
17:26:32 <lunabot>  appE :: ExpQ -> ExpQ -> ExpQ
17:26:43 <SamB> how does that qualify as source ?
17:26:51 <mmorrow> heh, s/src/info/
17:27:06 <mmorrow> , $(lift =<< reify 'appT)
17:27:08 <lunabot>  VarI Language.Haskell.TH.Lib.appT (AppT (AppT ArrowT (ConT Language.Haske...
17:27:12 <mmorrow> , ppDoc $(lift =<< reify 'appT)
17:27:14 <lunabot>  appT :: TypeQ -> TypeQ -> TypeQ
17:27:20 <mmorrow> et voila
17:27:26 <roconnor> @hackage data-accessor
17:27:26 <pumpkinbot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
17:27:46 <rgr> anyone know if a haskell-mode will make it into emacs 23?
17:30:09 <roconnor> this package is making me totally rethink my design
17:30:14 <roconnor> \o/
17:30:25 <jeffz`> rgr, suppose that would depend if the maintainer has submitted it to the emacs project?
17:34:56 <roconnor> I don't suppose that when f and g are functors then /\ a -> Lens (f a) (g a) is a functor ...
17:35:12 <gwern> off hand, does anyone know whether cabal strips binaries by default these days?
17:35:54 <ddarius> Presumably Lens isn't functorial in either argument.
17:36:32 <roconnor> ddarius: but what about both arguments
17:36:57 <roconnor> I mean, if f is a record parameterized by a, and g is a field parameterized by a
17:36:59 <ddarius> roconnor: If it was functorial in both, it would be functorial in each.
17:37:13 <roconnor> then then the entire lens is parameterized by a
17:37:51 <ddarius> What's the definition of Lens?
17:38:07 <roconnor> Lens a b = a -> (b,b->a)
17:38:28 <ski_> invariant in both arguments
17:38:52 <ddarius> Okay, so Lens is not a functor in either argument (or at least only a functor from a discrete category)
17:39:09 <roconnor> but what I say about records and fields makes sense (to me)
17:40:07 <ddarius> (Hmm, possibly you could make it make sense as a functor-like thing from a groupoid?)
17:40:08 <dolio> A type being parameterizd doesn't necessarily make it a functor.
17:40:09 <ski_> (roconnor : can you make your example more concrete ?)
17:40:57 * ddarius doesn't understand ski's parentheses convention.
17:41:06 <roconnor> data Foo a = Foo {bar :: [a]; baz :: Maybe a}
17:41:40 <roconnor> barLens = \foo -> (bar foo,\x->foo{bar=x})
17:42:03 <roconnor> barLens :: Lens (Foo a) [a]
17:42:17 <roconnor> Foo and [a] are functors in the obvious way
17:43:35 <roconnor> hmm
17:43:49 <roconnor> Perhaps what I'm saying doesn't make sense
17:44:35 <roconnor> ya
17:45:02 <dolio> You have an "[a] -> Foo a" and an "a -> b", how do you make a "[b] -> Foo b"?
17:45:34 <roconnor> dolio: I was about to write fmap f barLens === barLens
17:45:36 <mmorrow> instance Functor (Lens b) where fmap f k = \a -> let (b, z) = k a in (b, \b -> f (z b))
17:45:43 <mmorrow> ?
17:45:53 <roconnor> dolio: which obviously indicates what I was thinking doesn't make sense
17:45:54 <mmorrow> oops
17:46:04 * SamB decided to call them "function" and "argument"
17:46:18 <SamB> ... even though they are at the type level
17:46:33 <Axman6> hardcore
17:46:34 <roconnor> I need to think some more to understand parametric Lenses.
17:46:42 <dolio> roconnor: It might be an exponential functor: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Exponential.html
17:46:51 <mmorrow> i think you need to do:
17:46:52 <SamB> roconnor: that sounds like some kind of 3d-graphics thing ;-P
17:47:01 <dolio> (In fact, I'd say it probably is.)
17:47:02 <mmorrow> type Lens b a = a -> (b -> a)
17:47:09 <mmorrow> to get a Functor (Lens b)
17:47:20 <mmorrow> errr
17:47:27 <mmorrow> type Lens b a = a -> (b, b -> a)
17:47:43 <mmorrow> then you can do
17:47:47 <mmorrow> instance Functor (Lens b) where fmap f k = \a -> let (b, z) = k a in (b, \b -> f (z b))
17:49:16 <dolio> mmorrow: That doesn't look type correct.
17:49:25 <mmorrow> i haven't tried it, but i think it is
17:49:28 * mmorrow tries
17:49:57 <SamB> > TemplateHaskell
17:49:58 <pumpkinbot>       Not in scope: data constructor `TemplateHaskell'
17:50:09 <SamB> , TemplateHaskell
17:50:10 <lunabot>  luna: Not in scope: data constructor `TemplateHaskell'
17:50:12 <ddarius> mmorrow: It isn't.
17:50:13 <SamB> aww.
17:51:07 <mmorrow> crap
17:51:29 <mmorrow> oh yeah, the incoming one..
17:51:35 <ddarius> Aye.
17:51:53 <ddarius> Curse theory for being correct.
17:51:55 <ddarius> (enough)
17:52:17 <SamB> is there a handy way to snag the Extensions from a cabal configuration ...
17:52:28 <ddarius> Use some Perl...
17:52:35 <mmorrow> yeah, it looks like it's neither a Functor or a CoFunctor, because either way you try you're screwed
17:52:48 * ddarius thinks there's a handier way than that but just wanted to suggest perl.
17:54:26 <ddarius> mmorrow: Basically, the theory is the positive occurences of 'a' need covariant functors (i.e. the arrows to go one way) and the negative occurences need contravariant functors (the arrows going the other way) and arrows don't go both ways in general.
17:54:41 <mmorrow> yes
17:54:45 * ski_ cringes at `CoFunctor'
17:54:50 <mmorrow> that's where the "screwed" comes in
17:55:08 <mmorrow> ski_: me too, but unfortunately it's necessary in haskell
17:55:32 <ski_> mmorrow : why would bad naming be necessary in haskell ?
17:56:01 <chrisdone> > max 1 1
17:56:02 <pumpkinbot>   1
17:56:07 <chrisdone> this function is idempotent
17:56:14 <mmorrow> class CoFunctor g where cofmap :: (a -> b) -> (g b -> g a)
17:56:46 <mmorrow> is it the name itself you're talking about? or cofmap?
17:57:02 <Saizan> the name
17:57:23 <ski_> `class ContraFunctor f where contramap :: (a -> b) -> f b -> f a' seems to be in `category-extras'
17:57:24 <ddarius> I don't really like CoFunctor either
17:57:41 <mmorrow> yuk, "contra" is ugly :)
17:57:52 <ski_> (better than the other)
17:57:56 <dolio> Ugly is better than wrong.
17:57:59 <mmorrow> nuuh!
17:58:05 <Saizan> but in covariant vs. contravariant, what is Co? :)
17:58:26 <ski_> Saizan : it's not the same `co' as in `coproduct', et.c.
17:58:26 <mmorrow> by your logic then, Functor should be CoFunctor
17:58:42 <mmorrow> yes it is!
17:58:44 <ddarius> The typical solution to this problem in category theory is to split the positive and negative occurrences into two variables and this is essentially what ExpFunctor encodes.
17:58:47 <ski_> `covariant functor' =/= `cofunctor'
17:58:50 <ddarius> This leads to dinatural transformations.
17:59:09 <mmorrow> ski_: exactly
17:59:11 <SamB> @hoogle IO LocalBuildInfo
17:59:12 <pumpkinbot> Did you mean: :: IO LocalBuildInfo /count=20
17:59:12 <pumpkinbot> No results found
17:59:32 <dolio> Cofunctor isn't a good name for either of them.
17:59:42 <ski_> (i.e. the `co' in `covariant' doesn't have anything (at least directly) to do with dualizing)
17:59:44 <dolio> Because it implies that it's some categorical dual of a functor.
17:59:49 <dolio> Like product and coproduct.
17:59:54 <ski_> *nod*
18:00:20 * ddarius sort of got around this by defining a class Functor' arr arr' f where fmap' :: arr a b -> arr' (f a) (f b)
18:00:31 <mmorrow> but a contravariant functor maps a *category* to its *dual* (assuming it's an iso)
18:00:59 <ddarius> There aren't too many contravariant isos.
18:01:20 <mmorrow> algebra and geometry for one
18:02:00 <mmorrow> well, i'm really talking about an adjunction here
18:02:10 <ski_> i think `opposite category' is a better naming for that
18:02:29 <mmorrow> but then should coproduct be called opposite product?
18:02:39 <ddarius> Anyway, a contravariant functor is a covariant functor from (or to) the opposite category.
18:02:57 <mmorrow> ddarius: 6 or a half dozen
18:03:16 <ski_> `dual' is involved when there's a concept that's defined generically over a category. then the `dual' concept is defined by instantiating that category to an opposite category
18:03:38 <ddarius> mmorrow: "contravariant functor" is simply a shorthand.
18:04:03 <mmorrow> anyways, i'm biased to short names so this is really what's at the heart of my preference here
18:05:58 <mmorrow> i'm all for this suggestion
18:05:59 <mmorrow> class Functor' arr arr' f where fmap' :: arr a b -> arr' (f a) (f b)
18:06:53 <ozy`> > 0/0
18:06:54 <pumpkinbot>   NaN
18:07:01 <ozy`> > 0.0 / 0.0
18:07:03 <pumpkinbot>   NaN
18:08:31 <mmorrow> ski_: but "instantiatiating" is really mapping that category to its dual, and in doing so "_" maps to "co_"
18:09:57 <ozy`> > 0 `div` 0
18:09:58 <pumpkinbot>   mueval: Prelude.read: no parse
18:09:58 <pumpkinbot>  mueval: *** Exception: divide by zero
18:10:04 <mmorrow> but this is just arguing about terminology
18:10:18 <ski_> mmorrow : no, instatiation as if instantiating `id :: forall a. a -> a' into `id :: forall a. (a -> b) -> (a -> b)' (rough example)
18:10:33 <mmorrow> i don't view it that way
18:10:42 <mmorrow> everything is a map
18:11:34 <roconnor> I think what I want is a rank-2 lens
18:11:37 <ski_> the `product' concept is defined over any category `C'. now consider that concept when we instantiate `C' to some category `D^op'
18:11:48 <roconnor> if my lens has type forall a. Lens (f a) (g a)
18:11:56 <ski_> then, (generalizing over `D') we get the `coproduct' concept
18:12:01 <mmorrow> i would call that "providing a mapping from C to D^op"
18:12:17 <roconnor> then I can access a (g x) from an (f x) no matter what x is used, and it is accessed in the same way.
18:12:24 <mmorrow> because "instantiating" isn't a defined concept in category theory, but a functor is
18:12:25 <ski_> there's no mapping (i.e. functor) from `C' to `D^op' involved
18:12:41 <ski_> `C' is just a generic name for *any* category
18:13:00 <mmorrow> well then C was D^op all along
18:13:21 <ddarius> mmorrow: A contravariant functor is not a dual notion to a covariant functor, it is a special case of a covariant functor, just as a bifunctor is just a special case of a covariant functor.
18:13:35 <mmorrow> all i'm saying is that "instantating" isn't a defined concept within category theory
18:13:41 <mmorrow> *instantiating
18:13:46 <ski_> no, because the original concept was defined on any category `C' (not just any category of the form `D^op' (ignore for the moment that any category can be rewritten in that form))
18:13:48 <ddarius> There is only one notion of "functor"
18:13:58 <mmorrow> ddarius: every functor is a functor
18:14:00 <mmorrow> yes
18:14:19 <mmorrow> which is why it's unfortunate how class Functor is defined
18:14:41 <dolio> It's only unfortunate if you want to accurately model category theory.
18:14:46 <mmorrow> wuh
18:14:52 <dolio> Instead of actually getting things done.
18:14:56 <mmorrow> ohhh
18:15:01 <mmorrow> n/m i misread you
18:15:20 <cschneid> what's the easiest to work with web framework in haskell?  For really basic stuff (attach this url to this handler function).
18:15:50 <ski_> mmorrow : `instantiating' is a general (meta-)concept for handling universal definitions
18:17:02 <mmorrow> ski_: ok, all i'm saying is that it's not used very much in mathematics. perhaps in logic, but i'm not very familiar there
18:18:07 <ski_> mmorrow : possibly the word `instantiation' is not used much in math .. however, i'd wager that the idea is used mostly all of the time
18:18:54 <ddarius> ski_: You need to "wager" that?
18:19:03 <mmorrow> perhaps, but i wouldn't refer to that idea as instantiation :)
18:19:08 <ski_> hehe. figure of speak
18:19:20 <mmorrow> heh
18:19:45 * mmorrow eats food
18:19:57 <ddarius> ski_: Just to be clear, I understand it; my point (if you didn't get it) is that you should be able to be much more definitive about your reply.
18:20:17 <maurer> If I checked out ghc with git, does anyone know if there's a way to get the extra libraries and nofib?
18:20:35 <maurer> (./sync-all doesn't seem to support --extra or --nofib, and ./darcs-all doesn't work in the git version)
18:20:35 <ddarius> Pretty much every time you here "let x be" or "set x to" in a proof, it's an example of instantiation.
18:20:42 <ddarius> s/here/hear
18:20:52 <sbahra> Anyone here use empty pagestyle with lhs2TeX?
18:21:00 <sbahra> For some reason page numbers are still being generated.
18:21:14 <ski_> (ddarius : ok, point taken)
18:21:53 <dcoutts> gwern: yes, executables are striped by default upon installation
18:21:59 * ski_ 's tired brain refused to invent any examples at this late hour
18:22:53 <chrisdone> @users
18:22:53 <pumpkinbot> Maximum users seen in #haskell: 692, currently: 639 (92.3%), active: 15 (2.3%)
18:23:55 <SubStack> woo
18:24:14 * SubStack tries to get glsl working with glut haskell bindings
18:24:38 <SubStack> since my particle system is slowsville
18:24:48 <ddarius> ski_: Pick any non-trivial proof (and most trivial ones too)
18:25:15 <ski_> yes
18:25:42 <Saizan> btw, instantiation looks very similar to function application and so forall is similar to a lambda, so why it isn't one? i guess there are cases where the similarity breaks?
18:26:16 <ddarius> Saizan: It is notated by lambda at the term level usually.
18:26:56 <Saizan> yeah, but only there
18:27:24 <ski_> Saizan : rather `forall' is similar to `implication', you mean ?
18:27:39 <mxc> i know that its technically inappropriate, but i'm willing to wager that #haskell would provide better f# help than #fsharp, so anyone mind an f# question?
18:28:01 <ddarius> mxc: Unless it's pretty generic, I doubt you'll get terribly much response here.
18:28:17 <ski_> mxc : is it related to the object system ?
18:29:13 <mxc> question is actualyl a vs2008 question, but i can't seem to figure out how to use code in File.fs in Program.fs
18:29:14 <mvanier> I have a question: why does "do { n <- [1..10]; True <- return (n > 5); return n }" return [6,7,8,9,10] but "[1..10] >>= \n -> return (n > 5) >>= \True -> return n" give a non-exhaustive pattern match error?
18:29:37 <mxc> real basic and feel bad asking, and violating the purity of #haskell..
18:29:48 <sjanssen> @undo "do { n <- [1..10]; True <- return (n > 5);  return n }
18:29:48 <pumpkinbot>  Improperly terminated string at ""do" (column 1)
18:29:56 <sjanssen> @undo do { n <- [1..10]; True <- return (n > 5);  return n }
18:29:56 <pumpkinbot> [1 .. 10] >>= \ n -> return (n > 5) >>= \ a -> case a of { True -> return n; _ -> fail ""}
18:30:13 <ski_> mxc : possibly you need yo look up docs on the module system ?
18:30:14 <sjanssen> mvanier: your translation from do syntax is not quite right, see above
18:30:27 <ddarius> (Actually, you can factor the adjunction that characterizes exponentials, the "right" factor being related to the adjunction characterizing universal quantification.)
18:30:32 <mxc> its not that, i think its getting the compiler arguments right
18:30:32 <idnar> mvanier: you just discovered the dirty secret of the Monad typeclass :P
18:30:41 <mxc> the module system i feel good on
18:30:43 <mvanier> Dirty secret?
18:31:13 <Saizan> ski_: i know that A -> B translates to forall _:A.B and vice versa, but when you've forall a. a -> a you can kind of apply that to e.g Int and get Int -> Int
18:31:17 <Axman6> :t filterM
18:31:18 <pumpkinbot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:31:39 <roconnor> what is the GADT Options pragma?
18:31:48 <ddarius> Someone said GADTs the other day.
18:31:57 <ski_> Saizan : yes, that's dependent application
18:32:42 <ddarius> Incidentally, that "forall" is a different "forall" though it's more similar to the one usually used in mathematics.
18:32:45 <SamB_XP> roconnor: you mean {-# LANGUAGE GADTs #-} ?
18:32:51 * roconnor writes his first GADT
18:32:55 <roconnor> in haskell
18:33:01 * SubStack read GADTs as GOATs
18:33:06 <roconnor> SamB_XP: yes
18:33:06 <SamB_XP> remember, Language.Haskell.Extensions
18:33:25 <sjanssen> the extension names are rather inconsistent
18:33:31 <gwern> dcoutts: 'k. just checking
18:33:34 <ddarius> There's a compiler flag that will dump all the supported "languages"
18:33:40 <roconnor> is there a wiki page with all the know LANGUAGE extensions?
18:33:46 <sjanssen> GADTs vs. MultiParamTypeClasses
18:33:47 <ski_> (given `f : forall (a : *). a -> a' and `Int : *', you get `f [Int] : (\(a : *). a -> a) Int', i.e. `f [Int] : Int -> Int')
18:33:57 <roconnor> sjanssen: vs ?
18:34:01 <roconnor> oh
18:34:02 <roconnor> right
18:34:05 <ddarius> sjanssen: So how is the LANGUAGE pragma namespace going to be controlled?  (/me brings up an issue that won't actually be a problem any time soon)
18:34:06 <roconnor> in their names
18:34:08 <sjanssen> roconnor: all the extensions are listed in haddock
18:34:11 <mxc> ok
18:34:15 <mxc> i feel much less stupid
18:34:19 <sjanssen> ddarius: this is a fair question
18:34:30 <roconnor> ddarius: qualified names \o/
18:34:34 <SamB_XP> sjanssen: what about the Unknown one ?
18:34:48 <SamB_XP> roconnor: silly
18:34:48 <dolio> roconnor: ghc --supported-languages
18:34:50 <SamB_XP> you can't DO that
18:34:52 <mxc> if anyone is curious, the (very convoluted) way you change the compilation order to solve my problem is given here: http://cs.hubfs.net/forums/post/4366.aspx
18:34:52 <roconnor> :P
18:35:05 <dolio> Unless you want to know the ones for Hugs and such, too.
18:35:14 <roconnor> dolio: that's pretty useful
18:35:22 <sjanssen> ddarius: probably the extension names should be ratified by the Haskell' committee
18:35:28 <roconnor> dolio: nah
18:35:39 <SamB_XP> dolio: that's a pretty obscure way to do :b Language.Haskell.Extensions!
18:35:41 <sjanssen> and hopefully they can make an effort to come up with consistent names
18:35:48 <roconnor> dolio: when I write libs I want them as portable as reasonable, but for applications I don't care so much.
18:35:50 <ddarius> sjanssen: That's the obvious solution for current ones, but what about future ones?
18:35:51 <Saizan> ski_: yeah, the process of going from (forall (a : *). a -> a) : *  to  (\(a : *). a -> a) : * -> * never explictly occurred to me
18:35:59 <SamB_XP> sjanssen: I think they should be ratified by the Cabal maintainers
18:36:15 <sjanssen> SamB_XP: that's a good idea also
18:36:38 <SamB_XP> with the added bonus that we already do it that way afaict
18:36:50 <dolio> SamB_XP: :b Language.Haskell.Extensions doesn't tell you which ones GHC supports.
18:36:55 <Saizan> ski_: so my question might be, why do we need both forms?
18:37:01 <ski_> mxc : doesn't vs2008 for f# has any kind of compilation unit management system which computes a compilation order from module dependencies for you ?
18:37:06 <dcoutts> SamB_XP, sjanssen: we don't really care what they're called but they need to be registered so that they can be used in .cabal files
18:37:54 <sjanssen> dcoutts: yeah, I think it seems more like a language standardization issue than a packaging issue
18:37:59 <mxc> ski_ i would have assumed so, but as far as i could find in the docs and google, that seems to be the only way.  pretty bizarre.  i still dont beleive that there isn't a better way, but can't find it
18:38:00 <ski_> Saizan : `forall (a : *). a -> a' is more or less the same as `pi (\(a : *). a -> a)', where `pi : (* -> *) -> *', here
18:38:07 <dcoutts> dolio: ghc --supported-languages lists them all
18:38:34 <sjanssen> ddarius: how about we prefix new language extensions with the compiler's name until they're ratified by Haskell'
18:38:46 <dolio> dcoutts: Isn't that what I said?
18:38:57 <ddarius> sjanssen: That's one possibility.
18:39:16 <dcoutts> dolio: ok, sorry, I wasn't paying attention
18:40:19 <dcoutts> sjanssen: I don't see that that's necessary. I think compilers can make up whatever names the like. The registry in Language.Haskell.Extensions is so that we do not get name clashes and to let other compilers implement the same extensions
18:40:43 <dcoutts> sjanssen: Haskell' can choose to include existing extensions or revised variants
18:40:56 <sjanssen> dcoutts: well, there is the potential race condition where two compilers come up with the same name for different extensions
18:41:03 <sjanssen> dcoutts: but the issue is largely theoretical
18:41:28 <dcoutts> sjanssen: and whichever registers it first in Language.Haskell.Extensions wins :-)
18:41:44 <geezusfreeek> mutex(Language.Haskell.Extensions)
18:42:11 <sjanssen> dcoutts: oh, so you do want the Cabal maintainers to manage extension names :)
18:42:46 <dcoutts> sjanssen: we're happy to apply the patches
18:46:50 <ski_> geezusfreeek : ok .. you might possibly be interested to look at something like that which i used `ContT' for .. but i must leave at the moment
18:48:41 <drhodes> is there a haskell web browser?
18:49:14 <sjanssen> drhodes: there was an ancient web browser in Haskell, but the name escapes me
18:49:37 <ddarius> @google scurry haskell web browser
18:49:38 <pumpkinbot> No Result Found.
18:49:58 <ddarius> Nope not scurry that's something else.
18:50:14 <perlmonkey2> Lemmih: heh, you beaut.  I hope kermt showed you this: http://home.oth.net/haskell_usefulness-20090205_formula.txt
18:51:19 <ski_> see the bottom of <http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/demoform.htm>
18:51:21 <sjanssen> http://www.cs.chalmers.se/~hallgren/wwwbrowser.html
18:51:36 <ski_> (er, s/htm/html/)
18:51:44 <drhodes> shouldn't take more than a weekend to implement firefox in haskell.. right... ?
18:51:51 <roconnor> hmm
18:52:03 <roconnor> the wiki documenation for GADTs isn't so great
18:52:12 <sjanssen> ski_: ooh, do you think it still works?
18:52:14 <mmorrow> scurry??
18:52:35 <mmorrow> funny name
18:53:00 <roconnor> anyone have any pointers about how GADTs interact with case statements?
18:53:03 <ski_> sjanssen : istr it worked the one time i tried, which was several years ago ..
18:53:17 <mmorrow> roconnor: i think badly
18:53:41 <roconnor> I though the whole point of GADTs was to allow different branches of case statements to have different types
18:54:02 <mmorrow> roconnor: i usually make a function and pattern match in its arg list whenever i need a case stmt for gadts
18:54:22 <sjanssen> ski_: I suppose I'll poke a hole in my firewall and try
18:54:34 <roconnor> mmorrow: I tried that originally, and it didn't work
18:54:36 <roconnor> hmm
18:54:37 <mmorrow> roconnor: i think that's the problem, since haskell case doesn't work that way
18:54:47 <mmorrow> roconnor: did you give it a type sig?
18:54:53 <ski_> roconnor : GADTs allow the indexed types of the type of the inspected-upon value to be different types in the different branches
18:55:06 <roconnor> mmorrow: ah
18:55:08 <roconnor> type sig
18:55:22 <ski_> roconnor : if the result type of the branches include one of those indexed types, then the result type can also be differing
18:55:25 <roconnor> this could be tricky
18:55:40 <roconnor> oh maybe it will be fine
18:55:41 <roconnor> let's see
18:56:07 <roconnor> nope
18:56:09 <roconnor> still not happy
18:56:13 <ski_> (sjanssen : i'm not sure whether those programs anylonger can be started on the web-server in question ..)
18:56:43 <roconnor> where can I paste?
18:56:49 <ski_> @where hpaste2
18:56:49 <pumpkinbot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
18:56:50 <mmorrow> moonpatio.com
18:57:06 <rovar> pastie.caboo.se
18:58:42 <mmorrow> roconnor: (did you make a new _top-level_ function? this seems to be the only place that ghc doesn't give you hell with GADTs)
18:59:04 <roconnor> not top level
18:59:13 <mmorrow> ah yeah, i meant top-level
18:59:23 <roconnor> I'll try that
18:59:40 <mmorrow> (with a type sig of course)
18:59:54 * ski_ never thought matching-equations vs. `case', or top-level vs. local would be significant ..
19:00:12 <mmorrow> ski_: me neither. i think it's just an artifact of the current implementation
19:00:31 <ski_> (hm, though maybe type signature accounts for the `case' vs. .. case)
19:00:56 <roconnor> mmorrow: still no good
19:01:05 <roconnor> I'm making a simple example to paste
19:01:10 <mmorrow> hmm, are you sure what you're trying to do is actually valid?
19:01:13 <mmorrow> cool
19:01:55 <mmorrow> i've had to use unsafeCoerce actually once for a situation where i knew the GADT inference was obviously failing (incorrectly)
19:02:03 <roconnor> mmorrow: fairly sure
19:02:03 <Saizan> top-level only matters if you'd otherwise have to use ScopedTypeVars
19:02:14 <sjanssen> ski_: it works!
19:02:17 <sjanssen> X11 is so cool
19:02:23 <roconnor> I'm fairly sure what I'm _trying_ to do is valid
19:02:25 <ski_> sjanssen : nice !
19:02:28 <roconnor> :)
19:02:43 <mmorrow> roconnor: use unsafeCoerce and see if you segfault (a surefire way to find out :)
19:02:45 <roconnor> crap
19:02:46 <shachaf> > "I am the #haskell bot at the moment."
19:02:47 <pumpkinbot>   "I am the #haskell bot at the moment."
19:02:51 <roconnor> my simple example worked
19:02:56 * mmorrow was only half serious about that
19:04:23 <shapr> @yow !
19:04:23 <pumpkinbot> Couldn't find fortune file
19:04:25 <shapr> doh
19:05:09 <igorgue> hi, in ghci is there a way to set default settings at startup (like the editor)
19:05:24 <igorgue> like a .vimrc :)
19:05:26 <mmorrow> igorgue: you can put them in $HOME/.ghci
19:05:41 <igorgue> mmorrow: thanks, let me see
19:05:44 <mmorrow> like:
19:05:52 <mmorrow> :set -XTemplateHaskell
19:05:54 <mmorrow> ...
19:05:55 <roconnor> hmm
19:05:56 <igorgue> :set editor blabla
19:05:58 <igorgue> ok cool
19:06:20 <roconnor> mmorrow: forgot to add GADTs to this module
19:06:25 <roconnor> doh
19:06:25 <mmorrow> haha
19:06:29 <mmorrow> :)
19:06:49 <igorgue> mmorrow: works, thanks
19:06:55 <mmorrow> igorgue: cool
19:08:19 <roconnor> is it common to use Rank2Types with GADTs?
19:09:48 <ddarius> I never use GADTs but I can see it being common.
19:10:35 <ddarius> Certainly if you are doing advanced type things you usually end up needing higher ranked types.
19:11:36 <roconnor> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1201#a1201
19:11:53 <roconnor> I use rank2 polymorphism for the field type
19:12:46 <roconnor> before my code was simply Test -> Bool
19:12:57 <roconnor> but now I want to return more information in some cases
19:13:02 <roconnor> hence the GADTs
19:13:20 <roconnor> but because of the extra type parameter, I think I need to quantify over it.
19:15:37 <gwern> every so often I stand back, and I think - 'man, how strange is it that haskell is such a practically useful language?'
19:15:43 <gwern> it comes as a real shock sometimes
19:16:43 <roconnor> gwern: what makes you think it is practical?
19:16:54 <sjanssen> http://xs.to/xs.php?h=xs136&d=09063&f=2009-02-04-210702_960x768_scrot680.png screen shot of WWWBrowser
19:17:24 <gwern> roconnor: probably using it for practical problems
19:18:56 <bhurt> Anyone got any advice on what I might have done to cause ghc to blow it's stack?  I have a file that used to compile fairly quickly (a few seconds)- I made some changes, and now it takes for ever and consumes unlimited stack space.  This is ghc 6.8.2 (ubuntu intrepid)
19:19:54 <gwern> hm. perhaps you're using an extension? I've seen infinite-compile loops under 6.8 when I used some extensions but didn't declare it
19:20:20 <bhurt>  Quite possibly.
19:20:34 <enoksrd> @src groupBy
19:20:34 <pumpkinbot> groupBy _  []       =  []
19:20:34 <pumpkinbot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
19:20:34 <pumpkinbot>     where (ys,zs) = span (eq x) xs
19:20:41 <bhurt> Thanks.
19:21:43 <roconnor> fun new error messeges!
19:21:45 <roconnor> priority  not in scope because it has a wobbly type (solution: add a type annotation)
19:22:14 <N-Dex> Hi everyone, newbie to haskell here.  I bring up ghci and type in inc n = n+1 to the Prelude> prompt and get:
19:22:14 <N-Dex> <interactive>:1:6: parse error on input `='
19:22:14 <N-Dex> WTF!?!?
19:22:34 <enoksrd> N-Dex: let inc n = n + 1
19:23:08 <bhurt> gwern: Bingo.  That was the problem.  Thanks!
19:23:10 <N-Dex>  enoksrd: aaahh, thx!
19:23:16 <gwern> N-Dex: the ghci prompt is not the same as the toplevel in a module
19:23:43 <mae_> how can you check at compile time for the existence of a library function
19:23:47 <gwern> N-Dex: the ghci prompt is, if you follow, inside the 'main' function
19:23:56 <mae_> i.e. Network.Socket.getNameInfo
19:24:20 <gwern> bhurt: thought it might be. it certainly perplexed me when I ran into it
19:24:40 <gwern> mae_: presumably the check == the type-checker bailing with 'unknown function'
19:31:55 <dibblego> @hoogle (Applicative f) => [f a] -> f [a]
19:31:55 <pumpkinbot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
19:31:55 <pumpkinbot> Prelude sequence :: Monad m => [m a] -> m [a]
19:31:55 <pumpkinbot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:32:40 <dibblego> @src sequenceA
19:32:40 <pumpkinbot> Source not found. Do you think like you type?
19:32:54 <dibblego> @type traverse id
19:32:55 <pumpkinbot> Not in scope: `traverse'
19:33:04 <dibblego> @type Data.Traversable.traverse id
19:33:05 <pumpkinbot> forall (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => t (f b) -> f (t b)
19:33:22 <dibblego> thought so, thanks pumpkinbot :)
19:34:56 <jvoorhis> hello
19:35:58 <Gracenotes> hi, jvoorhis
19:36:34 <BMeph> jvoorhis: Nice mask... ;p
19:36:44 <jvoorhis> BMeph: pardon?
19:37:48 <BMeph> jvoorhis: Just appreciating the name. :)
19:37:59 <jvoorhis> it's Dutch!
19:39:01 <jvoorhis> so i've decided i've read too much about haskell for someone who's never really written any (aside from a couple exercises)
19:39:14 <jvoorhis> so i wrote a silly ls clone
19:39:16 <BMeph> jvoorhis: It's also reminiscent of a semi-legendary horror movie series character. :)
19:39:46 <jvoorhis> BMeph: i get that about once a month ;) but it's Jermey
19:39:48 <jvoorhis> gah
19:39:49 <jvoorhis> Jeremy
19:40:06 <BMeph> jvoorhis: Heh-heh. :)
19:40:13 <jvoorhis> anyways, if anyone is interested, can you give me some pointers on my trivial first program? :)
19:40:18 <gwern> jvoorhis: ls isn't silly. given all its many arguments and options, it's actually fairly non-trivial
19:40:23 <jvoorhis> http://gist.github.com/58533
19:40:28 <gwern> good way to learn the GetOpt libs, certainly
19:40:32 <jvoorhis> gwern: *my* ls is trivial!
19:40:56 <gwern> (one of my update-and-cabalization failures was in fact a full ls clone - which taught me respect)
19:41:00 <SamB> jvoorhis: well, think of it as an opportunity to improve your program ;-)
19:41:16 <SamB> gwern: update-and-cabalize, I think
19:41:28 <gwern> jvoorhis: I bet I could write 100 trivial lss
19:41:30 <jvoorhis> learning the option parser would be a good next step
19:41:43 <gwern> SamB: no, I'm using update as a noun, not a verb
19:41:59 <roconnor> > Just () `mplus` Just ()
19:42:01 <pumpkinbot>   Just ()
19:42:04 <roconnor> > Just () `mplus` Nothing
19:42:05 <pumpkinbot>   Just ()
19:42:08 <SamB> hmm. maybe that works.
19:42:10 <roconnor> > Nothing `mplus` Nothing
19:42:11 <pumpkinbot>   Nothing
19:42:15 <roconnor> > Nothing `mplus` Just ()
19:42:17 <pumpkinbot>   Just ()
19:42:22 <roconnor> works for me
19:42:29 <idnar> > Just () `mappend` Nothing
19:42:30 <pumpkinbot>   Just ()
19:42:48 <roconnor> > Nothing `mappend` Just ()
19:42:50 <pumpkinbot>   Just ()
19:42:51 <idnar> > Just [5] `mplus` Just [6]
19:42:53 <pumpkinbot>   Just [5]
19:42:55 <idnar> > Just [5] `mappend` Just [6]
19:42:56 <pumpkinbot>   Just [5,6]
19:42:57 <roconnor> crap
19:43:03 <roconnor> @type mappend
19:43:04 <pumpkinbot> forall a. (Monoid a) => a -> a -> a
19:43:11 <roconnor> @type mplus
19:43:12 <pumpkinbot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
19:47:19 <glguy> jvoorhis, and $ map ($ a) ps --> all ($ a) ps
19:47:55 <jvoorhis> glguy: thanks! i thought that was ugly too
19:48:57 <jvoorhis> @type all
19:48:58 <pumpkinbot> forall a. (a -> Bool) -> [a] -> Bool
19:51:09 <dibblego> does Map.union/Map.empty form a monoid?
19:52:20 <jvoorhis> dibblego: i think that meets the requirements
19:52:27 <idnar> except you can't actually define an instance
19:52:47 <SamB> idnar: can't you?
19:52:55 <SamB> Monoid isn't a constructor class !
19:53:04 <idnar> oh, hmm
19:53:13 <idnar> good point
19:53:48 <idnar> instance (Ord k) => Monoid (Map k v)
19:54:24 <idnar> oh hey, that's already defined in Data.Map
19:54:39 <dibblego> heh ta
19:55:01 <idnar> > Data.Map.fromList [(1,2)] `mappend` Data.MapfromList [(3,4)]
19:55:03 <pumpkinbot>       Failed to load interface for `Data':
19:55:03 <pumpkinbot>        Use -v to see a list of the...
19:55:04 <idnar> > Data.Map.fromList [(1,2)] `mappend` Data.Map.fromList [(3,4)]
19:55:05 <pumpkinbot>   mueval: Prelude.read: no parse
19:55:09 <idnar> bah
19:55:20 <idnar> > M.fromList
19:55:21 <pumpkinbot>       Overlapping instances for Show ([(k, a)] -> M.Map k a)
19:55:21 <pumpkinbot>        arising f...
19:55:28 <idnar> > M.fromList [(1,2)] `mappend` M.fromList [(3,4)]
19:55:29 <pumpkinbot>   mueval: Prelude.read: no parse
19:55:47 <idnar> > M.fromList [(1,2)]
19:55:48 <pumpkinbot>   mueval: Prelude.read: no parse
19:56:05 <idnar> whaat
19:56:18 <dino-> So I'm writing some code that may fail. I get started with ErrorT. Write my function..
19:56:24 <idnar> , M.fromList [(1,2)] `mappend` M.fromList [(3,4)]
19:56:25 <lunabot>  luna: Not in scope: `M.fromList'
19:56:33 <idnar> , Data.Map.fromList [(1,2)] `mappend` Data.Map.fromList [(3,4)]
19:56:34 <lunabot>  luna: Not in scope: `Data.Map.fromList'
19:56:41 <dibblego> Prelude Data.Map Data.Monoid> fromList [(1,2)] `mappend` fromList [(3,4),(5, 6)]
19:56:42 <dibblego> fromList [(1,2),(3,4),(5,6)]
19:56:44 <dino-> But I don't need to wrap anything, so use Identity.
19:57:24 <dino-> And then when I type this "throwError ()" I realize I just invented Maybe
19:57:50 <idnar> dino-: hee hee
19:58:23 <dino-> Which, btw, is not an instance, with ()
20:02:58 <the_unmaker> can haskell help with HR at my job?
20:03:00 <the_unmaker> :)
20:03:13 <idnar> @faq can haskell help with HR at my job?
20:03:13 <pumpkinbot> The answer is: Yes! Haskell can do that.
20:03:33 <BMeph> the_unmaker: The pumpkinbot has Spoken. ;p
20:03:51 <roconnor> hah
20:03:55 <roconnor> ghc says ``My brain just exploded.
20:04:54 <Taejo> am I evil if I'm too lazy to build my own library from scratch, and just did "cabal install hmm"?
20:05:12 <the_unmaker> check something out of the library
20:05:34 <idnar> @quote exploded
20:05:34 <pumpkinbot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
20:05:44 <idnar> @quote ghc
20:05:44 <pumpkinbot> ghc says: scavenge: unimplemented/strange closure type
20:06:41 <the_unmaker> function delete boss
20:06:44 <the_unmaker> :)
20:13:40 <roconnor> \o/ My GADT enabled code does what it was doing before.
20:13:50 <roconnor> now i can start to take advantage of it
20:14:11 <conal> roconnor: hurray GADTs!  what's your code about?
20:14:27 <roconnor> I'm implementing a turn based game
20:15:41 <conal> with GADTs.  nifty.
20:16:26 <roconnor> I'm pretending I have a dependently typed programming language.
20:17:11 <conal> roconnor: neat.  what's your use of dependent types?
20:17:19 * conal likes dependent types 
20:17:27 <shapr> me too!
20:17:51 <roconnor> let see.
20:17:59 <roconnor> I have a list of systems
20:18:52 <roconnor> and a bunch of predicates on those systems
20:19:16 <roconnor> given a predicate I was parititioning the systems
20:19:33 <roconnor> but now I want more information than true or false
20:19:58 <roconnor> depending on the predicate I want the system to return a priority if true
20:20:17 <roconnor> so I can sort the systems satisfying the predicate
20:20:28 <roconnor> and take the top elements
20:21:04 <roconnor> but each different predicate has a different _type_ for sorting with
20:21:16 <roconnor> so here is the dependency
20:22:19 <roconnor> it's a bit unusualy
20:22:20 * Taejo loves Haskell's succinctness (ngramify n = map (take n) . tails)
20:22:28 <roconnor> because the systems don't have the sorting type
20:22:32 <roconnor> the predicates do
20:22:52 <roconnor> so each system has to give an appropriate sorting key for each predicate it sastifies
20:23:54 <BMeph> @quote darcs
20:23:54 <pumpkinbot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
20:23:56 <conal> Taejo: also ngramify n = (fmap.fmap) (take n) tails
20:24:06 <conal> Taejo: via semantic editor combinator magic
20:24:23 <Taejo> conal: isn't that *less* succinct?
20:24:50 <conal> Taejo: it's perhaps more illuminating
20:24:59 <Taejo> conal: You know fmapping makes you grow hair on your keyboard, right? :)
20:25:11 <pumpkin> lol
20:25:16 <conal> Taejo: often SECs make things more succinct.  not this time.
20:25:23 <conal> :)
20:25:41 <conal> roconnor: wild.  i hope you blog about it.
20:26:10 <Taejo> conal: I blame the SEC for the current economic climate
20:26:20 <conal> Taejo: :)
20:26:23 <Taejo> but seriously, I do think SECs are cool
20:26:41 <conal> i always try SECs on things now and then often throw out the result.  in this case i probably would.
20:27:18 <conal> i like that it says to direct take n to the content of the content of tails
20:27:26 <conal> or s/content/inside/
20:27:41 <conal> sometimes i get an aha in the process.  sometimes not.
20:28:55 <conal> Taejo: oh -- hi max!  i got curious and /whois'd you.
20:29:05 <conal> Taejo: how'd you get your nick?
20:29:35 <Taejo> looked up "contrast" in an English-Korean dictionary, and failed to check the Korean-English side :)
20:29:39 <conal> "great ancestor" according to wikipedia
20:29:52 <Taejo> yeah, that was the failure
20:30:08 <conal> failure?
20:30:41 <Taejo> failure to check the meaning... I ended up with a rather more boastful nick than I intended
20:31:11 <idnar> conal: why not "ngramify n = fmap fmap fmap (take n) tails" while you're about it? :P
20:31:13 <conal> lucky guy.  simultaneously boastful & modest
20:32:34 <conal> idnar: have you read the SEC posts?  if you replace fmap with result, first & second, you get something that generalizes very nicely to arrows.  the basis of the theory of "Tangible functional programming"
20:32:38 <dino-> Cautiously boastomistic.
20:32:45 <roconnor> @type map fst . sortBy (comparing snd)
20:32:47 <pumpkinbot> forall a b. (Ord b) => [(a, b)] -> [a]
20:32:57 <roconnor> this must be a common function
20:33:04 <Taejo> dino-: nice
20:33:29 <saml> hey. i generate random background color (0x000000 through 0xFFFFFF).  how can I get darker color for the text? so that it'll be readable
20:33:30 <Fujisan> Twey
20:33:35 <Fujisan> come on now...
20:33:36 <roconnor> @hoogle comparing
20:33:36 <pumpkinbot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:33:36 <pumpkinbot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:33:42 <saml> > 0x344593 - 0xAAAAAA
20:33:43 <Fujisan>  reach out and touch somebodies hand make this world a better place if you can...
20:33:44 <pumpkinbot>   -7759127
20:33:58 <saml> so i can't just subtract 0xAAAAAA
20:34:15 <Taejo> > hex -7759127
20:34:16 <pumpkinbot>   mueval: Prelude.read: no parse
20:34:23 <Taejo> > hex (-7759127)
20:34:24 <pumpkinbot>   mueval: Prelude.read: no parse
20:34:30 <conal> idnar: while i don't know of a similar generalization of fmap fmap fmap
20:34:56 <Fujisan> Twey
20:35:17 <Taejo> conal: I know you think mappend should be written (++). Do you think fmap should be written (.)?
20:35:23 <rwbarton> saml: multiply the background color by, say, 0.5
20:35:40 <Taejo> > let (.) = fmap in (+1) . [1, 2, 3]
20:35:41 <pumpkinbot>   [2,3,4]
20:35:48 <SamB_XP> Taejo: semantic tits ?
20:35:52 <dino-> saml: Or maybe not 'darker' so much as 'contrasting'
20:35:55 <conal> Taejo: i would prefer (++) for mappend, but i wouldn't prefer (.) for fmap.
20:35:57 <idnar> SamB_XP: hahaha
20:35:58 <Taejo> SamB_XP: (.)(.)
20:36:07 <Taejo> :t (.) (.)
20:36:08 <pumpkinbot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
20:36:13 <conal> Taejo: because i like the Category generalization of (.) better than the Functor generalization.
20:36:35 <saml> rwbarton, that is more like complimentary color i ithink.. for red background, it gives hurting green
20:36:46 <conal> Taejo: and the history of use of (.) for category theory.
20:37:00 <pumpkin> thoughtpolice: you around?
20:37:15 <saml> i'll just generate random number (0x000000 through 0x333333)
20:37:26 <saml> > [0x000000 .. 0x333333]
20:37:26 <conal> Taejo: if we had postfix, we could maybe use something similar to the standard CT notation for fmap.
20:37:27 <pumpkinbot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:37:30 <rwbarton> saml: oh, I see
20:37:40 <Taejo> conal: I wasn't serious, but actually I quite like the look of (+1) . [1, 2, 3]
20:37:55 <rwbarton> saml: you need to split into separate red green and blue bytes, then multiply each by 0.5 and combine them again
20:38:06 <conal> Taejo: i do too, because list *are* functions.
20:38:19 <Taejo> conal: the standard notation for fmap is postfix? I've only seen Ff for (fmap_F f)
20:38:19 <conal> Taejo: so the function-composition reading works.
20:38:30 <chessguy_work> errr, lists are functions?
20:38:37 <conal> chessguy_work: think about it
20:38:47 <Fujisan> Twey
20:38:48 <BMeph> Taejo: It's faintly Dana-esque. :)
20:38:58 <Taejo> BMeph: huh?
20:39:07 <chessguy> conal, thinking.....
20:39:11 <conal> :)
20:39:24 <conal> chessguy: i mean semantically & intuitively.  not an encoding.
20:39:45 <chessguy> hrm
20:39:47 <BMeph> Taejo: Sorry, but if I said it was Scott-ish, I might have been mis-understood... ;)
20:39:56 <Taejo> chessguy: perhaps start with infinite lists
20:40:09 <roconnor> how do I write let expressions with guards?
20:40:15 <the_unmaker> bur[p
20:40:33 <conal> Taejo: agreed.
20:40:38 <chessguy> what are the inputs and outputs?
20:41:04 <roconnor> how do I write let expressions with guards?
20:41:06 <roconnor> oops
20:41:07 <roconnor> sorry
20:41:11 <Taejo> chessguy: well, we want (+1) . [1..] == [2..]
20:41:19 <dino-> Do you mean something about in the sense that [1, 2, 3] is (1 : (2 : (3 : []))) ?
20:41:27 <Taejo> dino-: no
20:41:56 <dino-> No, that would be the (:) function. Not the list itself.
20:42:28 <Taejo> we mean there is some b such that there is an isomorphism :: Stream a -> (b -> a)
20:42:28 <chessguy> well, [1..] == iterate (+1) 1
20:42:57 <chessguy> > iterate (+1) 1
20:42:58 <pumpkinbot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:43:00 <Taejo> where Stream a is the same as [a] but without finite lists
20:43:14 <Taejo> chessguy: think memoization
20:43:35 <johannh> roconnor: no idea, but hi!
20:43:44 <conal> chessguy: also think: what is a function?
20:44:01 <roconnor> hi
20:44:14 * roconnor doesn't know the layout rules for case
20:44:28 <chessguy> a function is a black box into which you put in an input, and get back and output. and for every input you put in, every time you put that input in, you get the same output
20:44:51 <conal> chessguy: yeah :)
20:45:04 <chessguy> ...
20:45:28 <conal> chessguy: and so is a list.  you put something in and you get something out.  what do you put in, and what do you get out?
20:45:35 <roconnor> damned escaping existential quantified variables
20:45:39 <roconnor> I've got you trapped now!
20:45:40 <chessguy> oh
20:45:43 <chessguy> i'm an idiot
20:46:01 <chessguy> ok, i'm with you now
20:46:08 <thetallguy> I know!  Garbage?
20:46:29 <thetallguy> in and out, that is.
20:46:39 <chessguy> so finite lists are partial functions?
20:46:59 <conal> chessguy: sometimes old perspectives fight new ones in our heads.  and after a while, they reconcile and become friends.
20:47:05 <conal> chessguy: yeah :)
20:48:17 <Taejo> hmm... as usual, bottom gets in the way here ... as partial functions, [1,2] is the same as [1,2] ++ repeat undefined, so we don't actually have an isomorphism :(
20:48:54 <conal> yeah.  finite lists are a bit more informative.
20:48:58 <geezusfreeek> > [1,2] ++ repeat undefined
20:49:00 <pumpkinbot>   mueval: Prelude.read: no parse
20:49:00 <pumpkinbot>  mueval: [1,2,*** Exception: Prelude.undefined
20:50:12 <cads> god mathematica's pretty prenting is so goddamn pretty!
20:50:45 <cads> I tried typestting a function by hand rather than doing the syntax and it was _beautiful_!
20:51:19 <conal> hurray for pretty math \o/
20:52:27 <chessguy> hey conal, i'd really like to pick your brain a bit on how to find (or even know you've found) a good semantic model for something
20:52:47 <cads> Is there such a graphical system involving a pallete of characters and type setting templates for subscripts and possibly other things, which I could use to format haskell code?
20:53:01 <chessguy> i know that's a really vague question, and maybe more suited for #haskell-in-depth, too
20:53:14 <conal> chessguy: i'd be happy to try.
20:53:58 <roconnor> hmm
20:55:06 <geezusfreeek> @unmtl ContT r (State s) a
20:55:06 <pumpkinbot> (a -> s -> (r, s)) -> s -> (r, s)
20:55:21 <chessguy> conal, shall we take it to #in-depth?
20:55:25 <geezusfreeek> @unmtl StateT s (Cont r) a
20:55:25 <pumpkinbot> s -> (a -> s -> r) -> r
20:55:30 <cads> Could I urge you guys to use the main channel in times of low traffic? When I knew less and was quieter, I liked to try to grasp the conversation zinging over my head. I wonder if other newbies would benefit as well?
20:55:49 <conal> chessguy: i'd rather do it here.  i don't think #in-depth is logged yet.  and i doubt it'll take long.
20:55:56 <chessguy> ok
20:56:10 <BMeph> conal: In other words: (!!) == ($). ;)
20:56:34 <conal> BMeph: yes!  nice, huh?
20:56:42 <chessguy> conal, perhaps we should start by defining terms. how would you define a semantic model?
20:56:42 <BMeph> conal: :)
20:57:43 <conal> chessguy: i think my main tools are (a) my intuition about what things *are* (separate from how we might implement them), (b) asking myself "what design choices does Reality make" (WWRD), and (c) checking how simple/standard/universal the math looks.
20:58:19 <conal> chessguy: a semantic model is a mathy type.
20:58:35 <conal> chessguy: build up from (), numbers, (->), (,), and Either
20:58:47 <conal> numbers, functions, sums & products
20:59:17 <chessguy> not Maybe?
20:59:31 <conal> sure Maybe.  it's () `Either` a
20:59:31 <Taejo> chessguy: Maybe ~= Either ()
20:59:36 <conal> :)
20:59:40 <chessguy> ah, right
21:00:03 <conal> chessguy: in the same way, you can carefull add in a few others if you like, e.g., lists & finite maps.
21:00:13 <chessguy> so it's sort of a subset of haskell
21:00:31 <conal> chessguy: yes.
21:00:47 <conal> chessguy: definitely nothing imperative: IO, STM, ...
21:00:56 <chessguy> what's the power in using a subset of haskell
21:01:07 <conal> chessguy: because those types do not have any simple & precise model.
21:01:10 <chessguy> i mean, type constructors?
21:01:11 <BMeph> chessguy: Clarity of Vision. ;)
21:01:17 <chessguy> type classes?
21:01:36 <conal> chessguy: type classes are orthogonal.  they package interfaces & laws.
21:01:58 <chessguy> algebraic data types?
21:02:00 <rwbarton> Does anyone know whether there was a performance bug in ghc 6.10.1 (compared to 6.8.2, and fixed in HEAD) affecting the pidigits shootout entry?
21:02:06 <conal> chessguy: type classes are important in the design.  if my model is a monoid, i give it extra points, etc.
21:02:16 <conal> chessguy: ADTs are sums of products
21:02:21 <BMeph> conal: I pictured "Cop-in-a-Box", when imagining "packaging laws". ;)
21:02:34 <conal> BMeph: :)
21:02:49 <conal> chessguy: however, ADTs will probably lead you astray.
21:02:56 <chessguy> conal, why is that?
21:03:06 <conal> chessguy: unless you have a totally clear simple *meaning* for them.
21:03:23 <conal> chessguy: they're more representation-y and less meaning-y
21:04:14 <conal> e.g., think of lists as sequences, not as conses.
21:05:01 <chessguy> makes sense
21:05:26 <roconnor> I have a predicate on predicates.
21:05:28 <roconnor> weee
21:06:16 <cjs> Is there any way to profile individual threads, or at least get their CPU usage?
21:06:16 <pumpkinbot> cjs: You have 1 new message. '/msg pumpkinbot @messages' to read it.
21:06:20 <conal> chessguy: so it's not really that you're modeling thing in terms of a haskell subset.  it's more like there's a subset of haskell that corresponds to a nice, well-understood & universal set of math ideas.
21:06:52 <roconnor> does this mean I need to hug Yoneda?
21:07:05 <conal> :)
21:07:23 <chessguy> conal, so if you're modeling a Foo, you ask things like "what could it mean to add two Foos together?" ?
21:08:35 <conal> chessguy: first i'd ask what's a Foo?  then i'd ask what does it mean to add those meanings together.
21:08:38 <ddarius> roconnor: No, you need to hug, at least, second order logic.
21:08:45 <conal> chessguy: and that's what addition on Foo must mean.
21:09:02 <conal> chessguy: that's what i've been calling type class morphisms.  in this case the type class is Num.
21:09:42 <byorgey> roconnor: hehe, awesome =)
21:09:45 <chessguy> what does it mean to ask what something "is" in this context?
21:09:56 <geezusfreeek> i wish we had Ring, Field, etc. instead of Num
21:10:09 <chessguy> you mean what it is, in a mathematical sense?
21:10:19 <Pseudonym> @go numeric-prelude
21:10:20 <pumpkinbot> No Result Found.
21:10:26 <conal> chessguy: you've zerod in on the central creative question.
21:10:30 <conal> zeroed
21:10:34 <ddarius> I don't think @google works with pumpkinbot at all.
21:10:46 <geezusfreeek> @google pumpkinbot
21:10:46 <pumpkinbot> No Result Found.
21:10:49 <Pseudonym> I like "zerod".  It sounds like a lesser-known mathematical object.
21:10:49 <Taejo> geezusfreeek: yeah, that thread on haskell-cafe today made me realise how crazy the numeric stuff is
21:11:05 <geezusfreeek> oh i didn't even know there was a thread about it today
21:11:08 <geezusfreeek> haven't checked
21:11:17 <conal> chessguy: i don't know how to answer that question directly.  it's a sort of platonic thing i believe in.
21:11:33 <conal> chessguy: i can give you examples, and you can see if you resonate.
21:11:50 <chessguy> conal, i'm up for that if you are
21:12:13 <geezusfreeek> i just saw conal and chessguy taking about Num in the context of semantics and i was noting that algebraic abstractions would probably be easier and more meaningful than Num in most cases
21:12:14 <Pseudonym> Is this #haskell or #haskell-in-depth?
21:12:30 <conal> chessguy: oh hey.  luke palmer blogged about an example a while back as "semantic design".
21:12:35 <conal> chessguy: check it out.
21:12:53 <conal> geezusfreeek: agreed.
21:12:55 <Pseudonym> http://lukepalmer.wordpress.com/2008/07/18/semantic-design/
21:13:14 <conal> Pseudonym: thx
21:14:20 <cads> geezusfreeek, taejo, Are there experimental frameworks for implementing rings and fields?
21:14:21 <chessguy> conal, strange, i don't know how i missed this
21:15:12 <geezusfreeek> cads, Pseudonym attempted to bring up a link to the numeric prelude, which has promise
21:15:18 <chessguy> "...I view math mostly as a tool for talking with precision" -- i like this very much, been saying this for a few years now
21:15:32 <conal> chessguy: i like luke's description of the seminar.  it was a lot of fun.  people came up with more ideas than i expected, including a neat one i hadn't thought of myself.
21:15:40 <geezusfreeek> cads, but unfortunately the haskell spec isn't very friendly to alternatives to Num, from what i've seen
21:15:49 <geezusfreeek> at least as far as syntactic sugar and the like goes
21:15:50 <rwbarton> cads: I just use Num and Fractional respectively; they're pretty good approximations if you ignore some bizarre class methods
21:16:19 <jvoorhis> conal: does reactive require ghc >= 6.10 ?
21:16:41 <conal> jvoorhis: oh, probably by now.  i'm often on the bleeding edge.
21:16:46 <Pseudonym> The only problem I can see is that a more refined Num-like series of classes might interact badly with defaulting.
21:17:06 <geezusfreeek> i really don't care about defaulting, personally
21:17:07 <Pseudonym> defaulting is kinda evil, though.
21:17:12 <conal> jvoorhis: the new unamb requires a not-yet-released ghc.
21:17:14 <Pseudonym> Necessary evil, but evil nonetheless.
21:17:14 <conal> @wiki unamb
21:17:14 <pumpkinbot> http://www.haskell.org/haskellwiki/unamb
21:17:18 <jvoorhis> oh!
21:17:33 <conal> jvoorhis: containing fixes to the concurrency RTS
21:17:36 <jvoorhis> and here i am, updating perl so i can update ghc
21:17:47 <conal> jvoorhis: revealed while debugging reactive, which uses unamb.
21:17:54 <chessguy> conal, so in a semantic domain, you whould be able to take two objects, combine them somehow, and get another object of the same type
21:18:07 <rwbarton> conal: Damn, I only have ghc-6.11.20090107. :)
21:18:14 <chessguy> @src Monoid
21:18:14 <pumpkinbot> class Monoid a where
21:18:14 <pumpkinbot>     mempty  :: a
21:18:14 <pumpkinbot>     mappend :: a -> a -> a
21:18:14 <pumpkinbot>     mconcat :: [a] -> a
21:18:18 <chessguy> :)
21:18:30 <Fujisan> does Twey talk here a lot i am making a documentary about his life
21:18:37 <Fujisan> so i need some information
21:18:38 <conal> rwbarton: oops.  i don't quite know when those RTS fixes went into HEAD
21:18:52 <conal> Fujisan: seriously?
21:19:02 <Fujisan> http://homes.esat.kuleuven.be/~athomas/macatkul/fotos/IMG_2482.jpg <-- is this code correct?
21:19:09 <Pseudonym> Is Twey famous or something?
21:19:20 <conal> maybe he's an ascended master
21:19:21 <Fujisan> pseudo-famous yes
21:19:26 --- mode: ChanServ set +o Pseudonym
21:19:30 <Fujisan> :<
21:19:31 <Fujisan> bye
21:19:36 <Fujisan> i guess
21:19:39 <Fujisan> Pseudonym
21:19:45 <Fujisan> thanks
21:19:52 <conal> hey, Fujisan.  no intent to offend.
21:20:01 <conal> Fujisan: we tend to joke around here.
21:20:09 <Fujisan> really
21:20:19 <Fujisan> my jokes get me banned usually
21:20:28 --- kick: Fujisan was kicked by Pseudonym (Pseudonym)
21:21:00 <Twey> Pseudonym: Why do you ask?
21:21:34 <Pseudonym> Gor some reason, I lagged out in the middle of that.
21:21:36 <conal> Pseudonym: what's the story?
21:21:51 <Pseudonym> Sorry, what story?
21:22:04 <conal> Pseudonym: you kicked Fujisan
21:22:10 <Twey> Oh
21:22:14 <Twey> He was whining, huh
21:22:19 <Pseudonym> Trolling.
21:22:20 <chessguy> conal, this is really interesting
21:22:25 <conal> Twey: who is this Fujisan guy?
21:22:28 <Olathe> He was trolling, as you can see by the picture he linked.
21:22:29 <conal> chessguy: :) !
21:22:31 <Twey> Yeah, he does that.  I just kicked him from #japanese for much the same reason.
21:22:42 <Twey> Olathe: I have him on ignore, he was spamming me with PMs.
21:22:43 <conal> Olathe: oh, thanks.  i didn't look.
21:22:46 <Olathe> Ahh.
21:22:48 <conal> Pseudonym: thanks for the kick
21:22:51 --- mode: ChanServ set +o Pseudonym
21:23:13 <chessguy> conal, so in that case he was really focused on defining the object in question in a mathematical sense
21:24:16 <conal> chessguy: i set the question of "what is an image?"  is that what you meant?
21:24:41 <chessguy> conal, yes, all his answers are somewhat mathematical
21:24:49 <conal> chessguy: as luke said, math is a language for answering precisely
21:25:25 <conal> chessguy: "what is an image?  okay, now what *precisely*?"
21:25:25 <ksf> knowledge of symbols tends to increase confusion.
21:25:25 <roconnor> so what do you guys think: is the "yield" function for coroutines supposed to return a value or not?
21:25:45 <Taejo> :t readFile
21:25:46 <pumpkinbot> FilePath -> IO String
21:25:47 <conal> chessguy: the intuitive part is very important, and precision easily interferes.
21:25:48 <Taejo> roconnor: yess
21:25:52 <ksf> zomg, I'm on a ultranaturalist trip again.
21:26:02 <ddarius> roconnor: I believe it depends on what kind of coroutines you want.
21:26:02 <chessguy> conal, so it could be helpful, when trying to think about what something _is_, to think about what mathematical properties it has
21:26:04 <conal> chessguy: intuition & precision are generate & test
21:26:07 <Olathe> Ooh ! Unamb looks nice :)
21:26:13 <roconnor> ddarius: no sitting on the fence :)
21:26:17 <Riastradh> roconnor, it must return control, at the very least.  Whether it returns a meaningful value is separate from the control structure.
21:26:33 <conal> Olathe: thanks!  i'm very excited about it as a new dimension in modular functional programming, aside laziness.
21:26:52 <Pseudonym> Hmm, bug in my macros somewhere.
21:27:00 <roconnor> Riastradh: it seems like a non trivial difference to me
21:27:02 <Pseudonym> Every time I /kb, my IRC client gobbles up all of memory.
21:27:14 <roconnor> Riastradh: is it easy to implement one in the other?
21:27:23 <roconnor> both ways I mean?
21:27:25 <conal> chessguy: ("would it be helpful...") maybe, but i'm doubtful.  for instance, then answer i'm looking for is not "it's a monoid!"
21:27:39 <Taejo> conal: wouldn't you say it enhances laziness, rather than being apart from it
21:28:10 <Riastradh> roconnor, do you want to pass information from one coroutine to next?  If so, then you could pass an argument to `yield', and the last invocation of `yield' in the next coroutine would return that argument.  If not, then `yield' would take no arguments and, er, yield unit, so to speak.
21:28:16 <conal> Taejo: so far i see laziness and unamb as independent.  maybe you see a connection i haven't.
21:28:22 <Pseudonym> chessguy: In a sense, these "mathematical properties" are what define an object.
21:28:29 <chessguy> conal, mm, that's not exactly what i mean. but observing any obvious ways to combine two objects and get another one could be useful perhaps
21:28:46 <Pseudonym> Conceptually, a rank-2 tensor is a matrix.  But it's one that transforms in a certain way.
21:28:48 <conal> chessguy: oh.  yeah, for sure.
21:29:10 <Pseudonym> The transformation rule is what defines a tensor.
21:29:12 <Pseudonym> In a sense.
21:29:18 <roconnor> Riastradh: I guess my question is, If I claim my language supports coroutines, does this mean yield has to be able to return a value?
21:29:29 <conal> chessguy: and examining the operations is critical at some point.  because every operation must be definable solely in terms of the semantic model.
21:29:32 <roconnor> its a question about the word "coroutine"
21:29:37 <roconnor> and what it means
21:29:40 <Taejo> conal: hmm, to me it's intuitively related to laziness, but I'll have to think about why
21:29:56 <conal> Taejo: that'd be great.  please let me know what bubbles up.
21:30:09 <chessguy> conal, so you think it makes more sense to look at the properties first, and then define the operations in terms of those properties
21:30:26 <conal> chessguy: "properties"?
21:30:47 <chessguy> conal, facts about it
21:30:58 <chessguy> that can perhaps be expressed mathematically
21:31:25 <roconnor> oooh
21:31:41 <roconnor> maybe yield was supposed to call another coroutine, passing parameters
21:31:47 <dsrogers> hmm... if I'm declaring a typeclass with a method that I want to be able to return a Bool in any monad, can I do that?
21:31:54 <dsrogers> (I think I can)
21:31:56 <conal> chessguy: i think in my flow, the properties come in after i have a sense of what the model is.  not sure.  there's probably a lot of back & forth.
21:32:19 <byorgey> dsrogers: sure.
21:32:20 <ddarius> roconnor: You might find this interesting: http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf
21:32:43 <pumpkin> anyone know of any good low-level hardware channels? I need to ask some ACPI questions
21:32:43 <byorgey> dsrogers: but maybe you could give an example of exactly what you'd like to do?  I want to make sure I understand what you're asking.
21:32:44 <dsrogers> anyways, when I do what I think works, and I try to create an instance, ghc complains that "m" is contrained to type Monad, and the inferred type was IO
21:32:50 <dsrogers> sure.
21:33:18 <dsrogers> class Authenticator domain credentials where
21:33:30 <byorgey> dsrogers: ah, I think I know what's wrong.  if you have a type like  (Monad m) => foo ... -> m Bool
21:33:36 <dsrogers> valid :: (Monad m) => domain -> credentials -> m Bool
21:33:37 <dsrogers> yes.
21:33:47 <byorgey> then a function of that type must be able to return *any* sort of monad.
21:33:54 <dsrogers> ah.
21:33:57 <byorgey> the function doesn't get to choose which monad, the *caller* chooses.
21:34:18 <byorgey> what you want can be done with existential types.  if it's really what you want.
21:34:21 <dsrogers> ah, I've declared a covarient return...
21:34:24 <jvoorhis> does this look familiar to anyone?
21:34:25 <jvoorhis> ~/ghc-6.11.20090204 % make # => grep: packages: No such file or directory
21:34:35 <jvoorhis> (google was less than helpful)
21:34:59 <dsrogers> is that the only option I have?
21:35:38 <dsrogers> eg. is there some way to achieve something similar?
21:35:39 <byorgey> dsrogers: the other option is to put the 'm' as another parameter to your type class.
21:35:44 <dsrogers> ah
21:35:55 <byorgey> i.e.  class Authenticator domain credentials m where ...
21:36:05 <byorgey> then for each instance you can say which type of monad it will use.
21:36:52 <chessguy> conal, ok, perhaps i'll meditate a bit on these things. thanks for the fascinating discussion
21:36:55 <byorgey> that sounds like the better option to me.  as long as each instance always uses the same monad.
21:36:57 <dsrogers> hmm...  very different behaviors though.  Some domains can check credentials in any monad (say static data) but something like SQL /must/ be in the IO monad...
21:37:09 <Taejo> is there any reason why "putStr <$> readFile foo" isn't doing what I think it should (I think it should print the contents of file foo, but it does nothing)
21:37:27 <sjanssen> Taejo: that has type IO (IO ())
21:37:36 <Taejo> sjanssen: lol, thanks
21:37:41 <sjanssen> Taejo: you want to use join or =<<
21:37:48 <Taejo> yep
21:37:50 <dancor> why does ghc allow main :: IO (IO ()) and hang
21:37:52 <conal> chessguy: my pleasure :)  semantic design sort of emerged for me, and i'm only recently getting more conscious of it.
21:37:57 <byorgey> dsrogers: as long as it's 'any monad' vs. 'one particular monad' (and not 'one of these two') it's fine, because you can say  'instance Authenticator Blah Foo m where ...'
21:38:01 <dsrogers> byorgey: where can I read about existential typing.
21:38:34 <chessguy> conal, any tips on what/where to read up on it to gain more experience/understanding?
21:38:34 <dsrogers> I see.
21:38:44 <dsrogers> ahh.
21:38:45 <dsrogers> ...
21:38:45 <dsrogers> ok
21:39:17 <Taejo> chessguy: conal's blog
21:39:29 <chessguy> Taejo, well, that much is obvious :)
21:39:32 <dsrogers> so you can leave a type partially constrained in the instance declaration...
21:39:34 <conal> chessguy: i have no idea about sources to read (other than Taejo's suggestion).  if you find any, please tell me.
21:39:42 <byorgey> dsrogers: right.
21:39:59 <cads> conal, chessguy, awesome discussion
21:40:01 <sjanssen> dancor: main can have type forall a. IO a
21:40:10 <conal> chessguy: as for tips, i'd say practice.  look at your chess code (or whatever) and ask yourself what each type means.
21:40:16 <conal> cads: thanks! :)
21:40:18 <byorgey> dsrogers: so for authenticators that can check credentials in any monad, you just leave the 'm' unconstrained
21:40:19 <dsrogers> and existential types would be needed when you need a specific list?
21:40:19 <sjanssen> dancor: re: the hanging, it probably has something to do with what you've written in main
21:40:35 <chessguy> conal, several people in the comments of that blog entry mention Behavior-driven Design and Domain-Driven Design. are you a fan of these?
21:40:37 <conal> chessguy: live in the question "what does it mean?"
21:40:41 <byorgey> dsrogers: I think that would be the only solution, yes.
21:40:49 <dancor> sjanssen: i think it's a bug.  at the very least extremely mean to noobs
21:41:16 <ozy`> is it possible to implement an interpreter for a stateful language in haskell that optimizes tail calls?
21:41:22 <dancor> i might buy   main :: (Show a) => IO a  or something
21:41:25 <sjanssen> dancor: can you paste the code?  Most likely the hang is some mistake that you've made
21:41:25 <conal> chessguy: i've looked a bit at those methodologies.  i don't think i got much out of them before my eyes crossed.  i like simple & precise.
21:41:36 <chessguy> conal, fair enough
21:41:37 <byorgey> dsrogers: where to read about existential types is a good question.  you can start with the ghc manual, but it doesn't exactly have a lot of examples.
21:41:42 <sjanssen> dancor: Show a would be silly -- do you really want GHC to print out () after every program?
21:41:52 <dsrogers> ok, I've don't what you asked, but now I get ll of the type variables in the constraint `Monad m'
21:41:52 <dsrogers>     are already in scope (at least one must be universally quantified here
21:42:01 <conal> chessguy: please don't read much into my reaction.  i'm not always patient enough to get it.
21:42:02 <byorgey> dsrogers: another good place to look would be to search the archives of haskell-cafe, there have been several enlightening threads about existentials.
21:42:02 <dsrogers> s/ll/All
21:42:15 <dsrogers> byorgey: thanks, I'll do that.
21:42:29 <chessguy> conal, ok, i'm off to dream about composable semantic models :)
21:42:30 <byorgey> dsrogers: hmm... can you paste the code somewhere?
21:42:34 <dsrogers> yes
21:42:51 <conal> chessguy: sweet dreams :)
21:43:08 <dsrogers> where did hpaste go?
21:43:15 <byorgey> @where hpaste2
21:43:15 <pumpkinbot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
21:43:28 <dancor> sjanssen: then maybe  main :: (RetVal r) => IO r  with () and Int instances
21:43:31 <byorgey> to the big pastebin in the sky
21:43:39 <dancor> the point is that it's overly magical right now
21:43:45 <sjanssen> dancor: seems to complicated
21:43:57 <Taejo> Haskellers, your ideas fascinate me and I should like to subscribe to your newsletter.
21:44:04 <sjanssen> dancor: it isn't magical at all -- "main must be an IO type" is the only constraint, this is very simple
21:44:18 <byorgey> @where hwn
21:44:18 <pumpkinbot> http://sequence.complete.org/
21:44:22 <byorgey> Taejo: ^^^
21:44:27 <byorgey> =)
21:44:54 <dsrogers> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1202
21:45:06 <Taejo> byorgey: =) ... not only do I subscribe to it, but I've been *in* it at least once
21:45:12 <the_unmaker> fastCGI!!!!
21:45:15 <the_unmaker> its pisser!
21:45:24 <conal> i'd also like to see main's type changed, to allow haskell programs to be composable.
21:45:31 <byorgey> Taejo: ah, indeed =)
21:45:32 <ddarius> dancor: You can tell from the type that the only thing main does with the "result" of a program is discard it.
21:45:37 <dsrogers> there is a lot of noise in there though the big you want is around line 20
21:45:46 <dsrogers> it's possible line 20 will do it all by itself.
21:45:54 <dancor> wait IO Int doesn't even become an exit code?  in that case, i think it's odd that we have main :: IO a even tho lookup recently became :: Maybe instead of :: m
21:46:06 <Taejo> byorgey: the "your ideas fascinate me" phrase is a meme that I thought particularly apposite here
21:46:06 <dancor> should be :: IO () seems like to me
21:46:20 <byorgey> dsrogers: line 20?  there's nothing on line 20...
21:46:32 <dsrogers> 23
21:46:33 <byorgey> Taejo: oh, I see.  sorry, I wasn't familiar with that meme =)
21:46:35 <sjanssen> dancor: that'd mean you have to add "return ()" boilerplate in some cases
21:46:47 <dsrogers> the class declaration is what ghc is complaining about.
21:46:48 <Taejo> byorgey: no problem
21:46:53 <dancor> sjanssen: yeah and ppl need boilerplate in some cases for the lookup change
21:47:06 <dancor> i guess a lot fewer cases..
21:47:09 <byorgey> dsrogers: ah, move the (Monad m) =>  to the  previous line
21:47:17 <byorgey> dsrogers: sorry, I described it incorrectly
21:47:18 <dsrogers> ahh.
21:47:30 <dsrogers> m is already too specific...
21:47:38 <byorgey> dsrogers: it should be  class (Monad m) => Authenticator domain authtoken m where ...
21:47:40 <dsrogers> because it's not universally quantified in the call...
21:47:43 <dsrogers> *class
21:48:15 <byorgey> dsrogers: ?
21:48:31 <byorgey> does it work now?
21:48:34 <dsrogers> yes
21:48:55 <byorgey> great =)
21:49:01 <dsrogers> thank you.
21:49:08 <byorgey> you're welcome.
21:49:22 <dsrogers> you really have to understand type inference to understand type inference error messages, it seems :-)
21:49:47 <byorgey> dsrogers: it certainly doesn't hurt =)
21:50:13 <byorgey> dsrogers: I must admit I don't even really understand that error message you got, which is why I had to look at the code to figure out what was wrong =)
21:51:10 <dsrogers> I think it means that without the universal quantification in the class declaration (eg the Monad m => part) the "m" is already specifically in scope.
21:51:35 <dsrogers> so you're not allowed to universally quantify it in the function type signature, since that is a contradiction.
21:52:01 <byorgey> dsrogers: yeah, something like that...
21:53:29 <Taejo> is there a way to set what getArgs returns in ghci?
21:53:52 <Taejo> i.e., I want to call "main" from  ghci, but main expects getArgs not to return []
21:54:36 <dancor> Taejo: i think you would want to make like main = mainOnArgs =<< getArgs
21:54:46 <rwbarton> Taejo: :set args foo
21:55:00 * dancor knows nothing
21:55:48 <Taejo> dancor, rwbarton: thanks
21:56:30 <nanothief> @paste
21:56:30 <pumpkinbot> Haskell pastebin: http://hpaste.org/new
21:56:50 <byorgey> @where hpaste2
21:56:50 <pumpkinbot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
21:56:56 <byorgey> nanothief: use that instead ^^^
21:57:13 <nanothief> byorgey, that was the one I was looking for :)
21:57:18 <byorgey> =)
21:57:29 <nanothief> could the topic be changed to reflect this?
21:57:52 <ozy`> can love bloom on the battlefield? can an interpreter written in haskell translate tail calls in the interpreted language into haskell tail calls?
21:58:59 <ddarius> ozy`: You'd have to go out of your way for that not to happen.
22:01:02 <ozy`> ddarius: hmm, all right
22:03:47 <nanothief> with the code: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1203#a1203 , I'm not sure why I am getting an ambiguous type variable. Can anyone help?
22:04:12 <Gracenotes> @hoogle Bool -> Bool -> Bool
22:04:13 <pumpkinbot> Prelude (&&) :: Bool -> Bool -> Bool
22:04:13 <pumpkinbot> Prelude (||) :: Bool -> Bool -> Bool
22:04:13 <pumpkinbot> Data.Bool (&&) :: Bool -> Bool -> Bool
22:06:27 <rwbarton> nanothief: because the type of the intermediate result in testSingleArbitrary >=> print doesn't have anything to do with the type of the second parameter
22:06:56 <rwbarton> nanothief: You could use asTypeOf somehow to force those types to be the same
22:07:51 <rwbarton> nanothief: generate size stdgen arbitrary `asTypeOf` x where x is a name for that second parameter
22:08:24 <nanothief> rwbarton, ok will try that out
22:08:54 <thomashartman1> does the live hackage currently run on happs or is that something planned for the future?
22:10:51 <nanothief> rwbarton, yes that fixed the problem. Although, is there a better way to "pass" a type to a function other that having an unused parameter?
22:11:27 <dsrogers> when exploring types in ghci is there a way to insert a fake variable of a specific type just so I can see what the results of type checking would be?
22:11:37 <rwbarton> nanothief: There are other ways.  It's unclear which is "best".
22:12:00 <rwbarton> dsrogers: you could use  undefined :: whatever
22:12:05 <rwbarton> dsrogers: there's also implicit parameters
22:12:07 <rwbarton> :t ?f ?x
22:12:08 <pumpkinbot> forall t t1. (?x::t, ?f::t -> t1) => t1
22:13:19 <dsrogers> that doesn't parse in my ghci
22:13:33 <rwbarton> Oh right, you need to :set -XImplicitParameters
22:15:48 <dsrogers> that doesn't work either.
22:15:58 <dsrogers> it gives me usage...
22:16:33 <rwbarton> Ugh, -XImplicitParams
22:16:41 <Trinithis> >
22:16:47 <thomashartman1>  when I try to bootstrap install cabal install I get "Setup: At least the following dependencies are missing:"
22:16:47 <thomashartman1> zlib >=0.4 && <0.6
22:16:47 <Trinithis> > bring up bot
22:16:48 <pumpkinbot>   mueval: Prelude.read: no parse
22:18:04 <dsrogers> thanks!
22:18:27 <dsrogers> what does (->) mean in a type constraint "Authenticator domain authtoken ((->) a)"?
22:18:32 <thomashrtman1> sorry my blurdy super-sensitive touchpad keeps closing xfce on me
22:18:35 <mauke> function
22:18:56 <thomashrtman1> anyways, how do I satisfy the zlib dep for bootstrap install cabal install?
22:19:04 <dsrogers> function?
22:19:07 <thomashrtman1> on ubuntu hardy, if anybody knows?
22:20:05 <dsrogers> oic.
22:20:29 <rwbarton> thomashrtman1: it should have tried to install the zlib package automatically (if you're talking about bootstrap.sh).  Maybe you're missing the zlib development headers?
22:20:43 <sm> zlib1g-dev package I believe
22:21:12 <thomashrtman1> sm: thks, I'll try that, but odd that I don't remember it popping up as an option with apt-cache search ^zlib
22:22:11 <cjs> How do I turn a Fractional into, say a Double?
22:22:15 <thomashrtman1> sm: it was there, I just missed it
22:22:39 <sm> aha
22:22:43 <mauke> @hoogle Fractional a => a -> Double
22:22:44 <pumpkinbot> Prelude recip :: Fractional a => a -> a
22:22:44 <pumpkinbot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
22:22:44 <pumpkinbot> Prelude (/) :: Fractional a => a -> a -> a
22:22:50 <mauke> hah
22:23:00 <cjs> Yeah, exactly.
22:23:01 <Taejo> :t toRational
22:23:03 <pumpkinbot> forall a. (Real a) => a -> Rational
22:23:30 <Taejo> cjs: how would you like complex numbers to be turned into doubles?
22:23:35 <byorgey> dsrogers: (->) is a type constructor that takes two argumets but is normally written infix, just like (+) is a function taking two arguments normally written infix.
22:24:12 <byorgey> so ((->) a) is a type constructor that creates function types whose domain is a.
22:24:15 <cjs> Oh, duh. diffTime is a Num, anyway.
22:24:26 <dsrogers> thanks
22:24:27 <byorgey> that is,  ((->) a) b  is the same as  a -> b.
22:25:06 <cjs> Hm, no that doesn't help. I must be really stupid today. All I want is to break down a DiffTime into the seconds portion and the fractional portion.
22:26:41 <mauke> :t realToFrac
22:26:42 <pumpkinbot> forall a b. (Fractional b, Real a) => a -> b
22:27:17 <cjs> It's already a Fractional.
22:27:25 <mauke> and a Real
22:27:31 <cjs> The issue seems to be that it's a Real, and a Fractional, but not a RealFrac.
22:27:43 <rwbarton> :t floor
22:27:44 <pumpkinbot> forall a b. (Integral b, RealFrac a) => a -> b
22:28:37 <rwbarton> @src Real
22:28:38 <pumpkinbot> class  (Num a, Ord a) => Real a  where
22:28:38 <pumpkinbot>     toRational      ::  a -> Rational
22:30:14 <mauke> whee, works
22:34:43 <thoughtpolice>  @seen pumpkin
22:34:51 <pumpkin> hi!
22:35:03 <thoughtpolice> pumpkin: you ping'd?
22:35:45 <pumpkin> I was wondering about your objc thing and ehird and I have been speaking about similar stuff in #hobjc :)
22:39:33 <thoughtpolice> pumpkin: hm yeah, I've been thinking about it a little too
22:40:04 <pumpkin> yeah, you said you might give it a go this past weekend
22:40:08 <pumpkin> was wondering if you'd had a chance
22:40:31 <thoughtpolice> oi, not really. school and all. :(
22:40:39 <thoughtpolice> i haven't been very active with lhc either
22:41:09 <pumpkin> aw :)
22:41:21 <pumpkin> anyway, feel free to come join us in #hobjc
22:41:30 <pumpkin> trying to get some interest together to start a new objc project
22:41:42 <thoughtpolice> yeah, something cabal-install-able would be nice
22:41:43 <pumpkin> I know erikc was also interested in this stuff
22:49:09 <mofmog> python pattern matching gives only gives you a taste of what haskell offers
22:49:26 * mofmog is writing python code that pushes its unpacking abilities TO THE MAX!
22:55:37 <ddarius> mofmog: Try Prolog or better lambdaProlog.
22:55:51 <idnar> python only has "pattern matching" on tuples / lists
23:01:34 <Taejo> idnar: actually, any iterable
23:02:38 <idnar> Taejo: oh, well, yeah
23:03:14 <Taejo> @src foldl'
23:03:14 <pumpkinbot> foldl' f a []     = a
23:03:14 <pumpkinbot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:09:36 <jekor> Has anyone successfully compiled GHC 6.10 on Gentoo (amd64)? It somehow crashes my machine each time. Is there a binary I can get somewhere. I'd really like to have HLint, which seems to require it.
23:12:05 <mmorrow> jekor: why is it crashing? using too much mem or something?
23:12:41 <jekor> I don't know. I'm not around to watch it and when I get back my computer is completely hung.
23:13:00 <jekor> It's very strange. Never had something like it before.
23:13:09 <mmorrow> hmm, weird.
23:13:23 <mmorrow> how much memory do you have?
23:13:27 <jekor> 4GB
23:13:30 <mmorrow> hehe
23:13:33 <Taejo> I feel so sure that deepSeq was cabalised somewhere
23:13:58 <mmorrow> jekor: i dunno then, out of mem was all i could think of
23:14:20 <jekor> No problem. It's just strange to not be able to find a binary package of either HLint or GHC 6.10 anywhere.
23:14:21 <mmorrow> do you happen to know the last bit of output it spit out before it hung?
23:14:33 <jekor> Unfortunately, no. The video signal goes as well.
23:14:37 <mmorrow> jekor: oh, you can get a binary from ghc's website
23:14:50 <jekor> Ah. I was going to check that and forgot. Thanks.
23:14:54 <mmorrow> http://haskell.org/ghc/download_ghc_6_10_1.html
23:15:09 <mmorrow> not sure about HLint
23:16:10 <jekor> Cool. Having 6.10 would also allow me to test my program against it for the future.
23:30:06 <Taejo> hackage has a logfloat package "which may be useful for HMMs", and an HMM package which doesn't use it
23:30:10 <Taejo> I should fix that
23:39:48 <dsrogers> why does "do { return Just True }" have a type of a -> Maybe a?
23:39:57 <dsrogers> shouldn't it just be a Maybe Bool?
23:40:23 <dsrogers> > do { return Just True } $ False
23:40:24 <pumpkinbot>   Just False
23:40:31 <idnar> dsrogers: I think you want return (Just True)
23:40:38 <dsrogers> ahhh
23:40:52 <idnar> @type return Just
23:40:53 <pumpkinbot> forall a (m :: * -> *). (Monad m) => m (a -> Maybe a)
23:40:54 <idnar> @type return Just True
23:40:55 <pumpkinbot> forall a. a -> Maybe a
23:41:03 <dsrogers> I see.
23:41:06 <dsrogers> thanks
23:41:14 <idnar> @type return (Just True)
23:41:15 <pumpkinbot> forall (m :: * -> *). (Monad m) => m (Maybe Bool)
23:41:21 <mmorrow> @type return Just
23:41:22 <pumpkinbot> forall a (m :: * -> *). (Monad m) => m (a -> Maybe a)
23:41:44 <pumpkin> @type return Just True
23:41:45 <pumpkinbot> forall a. a -> Maybe a
23:41:47 <mmorrow> @type return Just ?f
23:41:49 <pumpkinbot> forall a t. (Monad ((->) t), ?f::t) => a -> Maybe a
23:42:01 <Gracenotes> ah.
23:42:46 <mmorrow> implicit params are so great for that
23:43:13 <dsrogers> thanks everyone.
23:43:15 <dsrogers> goodnight!
23:43:56 <Gracenotes> > (return Just True) "lolol"
23:43:58 <pumpkinbot>   Just "lolol"
23:44:47 <Gracenotes> really odd.
23:44:52 <idnar> Gracenotes: return is const
23:45:07 <idnar> Gracenotes: in the (->)r monad
23:45:34 <Gracenotes> yes... it might be late, but I'm missing how it infers the function application monad
23:46:11 <idnar> Gracenotes: well, you're doing function application, what other monad could it be? :P
23:46:38 <Gracenotes> (return Just) True "lolol", perhaps, but... huh.
23:46:54 <Gracenotes> GHC is much smarter than I am
23:46:54 <idnar> (return Just True) is ((return Just) True)
23:46:59 <Gracenotes> yeah
23:47:22 <idnar> so (return Just) must be a function of some type
23:47:49 <Workybob> s/return/pure/
23:47:55 <Gracenotes> oh, yeah, I think I see it.
23:48:21 <pumpkin> I see
23:48:24 <Workybob> > fmap fmap fmap sequence fmap pure [1,2,3]
23:48:25 <pumpkinbot>       No instance for (Show (m [a]))
23:48:25 <pumpkinbot>        arising from a use of `show' at <...
23:48:28 <Gracenotes> :X
23:48:32 <Workybob> > fmap fmap fmap sequence fmap pure [1,2,3] :: Maybe [Int]
23:48:33 <pumpkinbot>   Just [1,2,3]
23:48:36 <idnar> heh
23:49:02 <Workybob> no, it's not just pure – it's mapA
23:49:09 <Workybob> (just mapA pure == pure)
23:49:16 <Gracenotes> as was mentioned earlier, >>= and <*> are interesting in how similar they are
23:49:33 <Workybob> well, =<< and <*> are more similar
23:49:41 <Gracenotes> yeah
23:49:46 <idnar> @type (=<<)
23:49:48 <pumpkinbot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
23:49:49 <idnar> @type (<*>)
23:49:50 <pumpkinbot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:50:10 <dibblego> @type ap
23:50:11 <pumpkinbot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:50:13 <Gracenotes> one of them applies the function to the function applied to second param; the other one applies the function to the function applied to first param
23:50:17 <Gracenotes> +the
23:51:16 <Workybob> @src ap
23:51:16 <pumpkinbot> ap = liftM2 id
23:51:22 <Workybob> that's exactly how similar they are ;)
23:53:11 <Gracenotes> indeed... how it stretches the brain, which wants to contract into some nice peaceful sleep... good night :)
23:54:40 <Gracenotes> I'll work through it tomorrow :) for some reason Readers are more intuitive, though they're just wrapped
23:55:29 <BMeph> I prefer to think of it as one uses 'return f', and the other uses 'return . f', for some mythical f :: a -> b. :)
23:56:04 <idnar> I only find Readers easier because I can read the types more easily
23:56:17 <BMeph> idnar: Ditto. :)
23:56:20 <Gracenotes> I think that might be half the battle
23:56:46 <Gracenotes> replacing m with x -> and removing and adding parens
23:57:01 <Gracenotes> or whatever variable's used
23:59:17 <pumpkin> > fmap (+1) (+2) 5
23:59:19 <pumpkinbot>   8
23:59:38 <pumpkin> I love that
23:59:40 <erikc> ddarius: any suggestions on what to read to be able to grok lambdaprolog? the suggested handbook of logic http://tinyurl.com/dmwd9b is out of my price range :)
23:59:47 <idnar> > fmap (+1) (+2) (+3) 5
23:59:48 <pumpkinbot>       No instance for (Num (a -> a))
23:59:48 <pumpkinbot>        arising from the literal `1' at <...
