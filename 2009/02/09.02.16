00:01:24 <p_l> you can have lots of fun by specifying certain kind of files
00:03:10 <Eridius> hrm, someone is attempting to do for Haskell what Why did for Ruby... http://learnyouahaskell.com/
00:03:24 <pumpkin> Eridius: that's BONUS :)
00:03:32 <pumpkin> and people recommend that all the time
00:03:38 <Eridius> never ran across it before
00:03:40 <Eridius> it just popped up in google
00:03:54 * Eridius is looking for this info because he's hoping to get someone else hooked on playing around with Haskell
00:04:34 <Eridius> I really wish I actually had something to *do* with Haskell, but unfortunately all of my time goes towards Cocoa projects, and HOC is far too unwieldy to replace Obj-C with Haskell
00:05:18 <Eridius> anybody know who maintains Hoogle? I really wish they'd fix their anchors
00:05:27 <Eridius> either hoogle or the haskell.org docs needs changing
00:13:27 <shortc|desk> http://rosettacode.org/wiki/Tasks_not_implemented_in_OCaml
00:13:32 <shortc|desk> doh
00:13:38 <shortc|desk> http://rosettacode.org/wiki/Tasks_not_implemented_in_Haskell
00:13:40 <shortc|desk> There. :-)
00:13:43 <Eridius> heh
00:25:09 <Axman6> shortc|desk: huh, what's that for?
00:25:39 <shortc|desk> Axman6: I run a site called Rosetta Code.  That's a list of all the tasks on the site that haven't yet been provided implementations in Haskell.
00:25:59 <Axman6> hmm, well the array one i could probably dpo
00:26:02 <Axman6> do*
00:26:28 <shortc|desk> The idea behind Rosetta Code is to present solutions to the same task in as many different languages as possible, to demonstrate how languages are similar and different, and to aid a person with a grounding in one language in learning another.
00:29:37 <olsner_> > foldr (||) False (True:repeat False)
00:29:39 <lambdabot>   True
00:29:45 <olsner_> > foldl (||) False (True:repeat False)
00:29:57 <lambdabot>   mueval: Prelude.read: no parse
00:42:33 <hackage> Uploaded to hackage: Yogurt 0.3
00:48:10 <redditbot> Random Permutations and Sorting
00:48:16 <ivanm> do I dare ask what kind of package Yogurt is meant to be?
00:49:12 <cizra> Yogurt? It's a MUD client.
00:49:15 <ricky_clarkson> Low fat.
00:49:43 <opqdonut> MUDs and low fat don't really go hand in hand in my experience ;)
01:07:24 <CTA> Heyy
01:07:51 <CTA> OFFTOPIC - Which Eminem song is it where it goes "Oops there goes gravity back to reality"?
01:08:47 <opqdonut> :D
01:12:02 <pumpkin> @query lambdabot
01:12:02 <lambdabot> Unknown command, try @list
01:12:08 <pumpkin> @hoogle "Oops there goes gravity back to reality"
01:12:08 <lambdabot> Parse error:
01:12:08 <lambdabot>   --count=20 ""Oops there goes gravity back to reality""
01:12:08 <lambdabot>              ^
01:12:12 <pumpkin> @google "Oops there goes gravity back to reality"
01:12:13 <lambdabot> No Result Found.
01:12:16 <pumpkin> boo
01:12:23 <CTA> It don't matter, it's loose yourself
01:12:33 <CTA> Btw are sockets "horrible" with Haskell?
01:13:14 <pumpkin> not really
01:13:30 <pumpkin> I don't consider them particularly horrible elsewhere though
01:13:31 <CTA> :)
01:13:37 <CTA> ah
01:13:41 <CTA> Horrible I mean like C++
01:25:39 <HugoDaniel> hi there
01:26:39 <HugoDaniel> i have a list [a, b, c, b, c, b, c, d, e, f, e, f, e, f, g, h, i, h,i, h, i ...] and i want to zip it into a list of tuples so i can easily access the information there
01:26:42 <HugoDaniel> how do i do it ?
01:27:03 <Axman6> shortc|desk: i added an array implementation thing btw
01:27:20 <Axman6> HugoDaniel: what do you mean?
01:28:14 <HugoDaniel> Axman6: i would like to have [(a, [(b,c)]), (d, [(e,f)]), (g, [(h,i)])]
01:28:31 <Axman6> o.O
01:28:43 <HugoDaniel> or something like that :/
01:28:45 <quicksilver> I don't see how you could posisble get that info out of that list.
01:28:52 <HugoDaniel> hmm
01:28:57 <HugoDaniel> it is easy
01:28:58 <Axman6> me either
01:29:03 <quicksilver> why (a,[(b,c)]) and not [(a,b),(c,b)] ?
01:29:11 <Axman6> it can be done... but seems very wasteful
01:30:08 <HugoDaniel> well, it works like this ["name", "offer1", "pricevalue1", "offer2", "pricevalue2", "offer3", "pricevalue3", "name2", "offer1", "pricevalue1"...]
01:30:23 <HugoDaniel> whenever two strings without digits appear
01:30:34 <pumpkin> HugoDaniel: you can't
01:30:37 <Axman6> you'd do uch better to use a specific datatype i think
01:30:40 <pumpkin> those have different type
01:30:43 <HugoDaniel> i know the first one is a name, and the second one is the offer
01:30:56 <HugoDaniel> pumpkin: no, it is all strings, i can get the digits with the "isdigit" function
01:31:01 <pumpkin> oh, I see
01:31:03 <Thunder> Hugo: "name2" is a "string without digits"?
01:31:04 <pumpkin> sorry  :)
01:31:06 <HugoDaniel> yes
01:31:08 <HugoDaniel> nos
01:31:18 <HugoDaniel> oops, Thunder yes
01:31:27 <HugoDaniel> and offerN is also a string without digits
01:31:31 <pumpkin> HugoDaniel: explicit recursion seems like your best bet here :P
01:31:34 <quicksilver> sure, that's not very hard to do.
01:31:43 <quicksilver> but I wonder if getting it in a list in the first place is a good idea ;)
01:31:47 <quicksilver> where did it come from?
01:31:51 <Thunder> Hugo: I see. Very interesting metric
01:31:59 <HugoDaniel> it came from a dom tree that was parsed
01:32:05 <Axman6> i was thinking the same thing
01:32:13 <pumpkin> HugoDaniel: why not put it straight into a useful format
01:32:18 <Thunder> Hugo: Then parse the dom tree into a better structure
01:32:20 <pumpkin> rather than flattening it like that?
01:32:24 <HugoDaniel> i just dumped all the nodes of interest inside a list, and then applied a series of filters
01:32:27 <quicksilver> if you passed a DOM tree then you definitely shouldn't throw away all that strucutre and make it a list.
01:32:33 <quicksilver> keep the structure and use it
01:32:36 <quicksilver> for make something of a useful shape.
01:33:02 <HugoDaniel> it is hard
01:34:12 <quicksilver> no it's not, it's easy.
01:34:18 <HugoDaniel> im using xpath
01:34:26 <HugoDaniel> for the parse
01:34:31 <HugoDaniel> thats why a list is preferable
01:34:44 <HugoDaniel> because it cames out as a list already
01:35:40 <HugoDaniel> or else i will be reading the dom tree loads of times, which is really awful as efficiency matters
01:35:47 <Axman6> sounds to me like you're doing something wrong
01:36:10 <HugoDaniel> Axman6: i know :) i just dont have the time to do it right
01:36:15 <daf> HugoDaniel: if you want efficiency, explicit recursion with SAX is probably faster
01:36:16 * lispy notes that his middle name is "Youredoingitwrong."
01:36:23 <daf> if you build a DOM tree, I think you've already lost
01:36:50 <HugoDaniel> hehehe, its a point of view daf
01:36:51 <daf> (as in, building the DOM tree is more expensive than reading it)
01:37:12 <HugoDaniel> well, im using hxt with xpath, so i suppose it builds the dom tree
01:37:21 <HugoDaniel> the point is in using xpath
01:37:55 <HugoDaniel> because the parse string can come from a configuration file
01:38:08 <HugoDaniel> which will help keeping the hands free from touching the code in the future
01:38:19 <HugoDaniel> anyway, this was not my decision
01:38:24 <HugoDaniel> so :P
01:38:38 <HugoDaniel> now i have a list and i need to "parse" it
01:38:46 <pumpkin> explicit recursion
01:38:57 <pumpkin> check if the head matches your condition and keep an accumulator
01:39:21 <HugoDaniel> okey
01:39:39 <Thunder> Hugo: Are the names of the configuration option in your list known beforehand?
01:40:08 <HugoDaniel> no
01:40:14 <HugoDaniel> the names are not known
01:40:35 <HugoDaniel> i just know that the name comes whenever a string without digits appears in the next list position
01:41:00 <quicksilver> you don't need to use explicit recursion at all
01:41:08 <quicksilver> you can do something like
01:41:39 <quicksilver> filter (all isAlpha . head) . tails
01:42:33 <hackage> Uploaded to hackage: hslibsvm 2.88.0.1
01:42:57 <lispy> I wonder if that's a typo?
01:43:02 <lispy> svm should be svn?
01:43:13 <opqdonut> :P
01:43:27 <aleator_> hope not.. :)
01:43:36 <aleator_> I'd like haskell svm..
01:43:42 <quicksilver> >  filter (all isAlpha . head) . filter (not.null) .  tails $ ["a","1","2","b","3","c","4","5","6","7"]
01:43:44 <lambdabot>   [["a","1","2","b","3","c","4","5","6","7"],["b","3","c","4","5","6","7"],["...
01:43:56 <quicksilver> ^^ all initial segments beginning with an all-alpha
01:44:07 <quicksilver> (haven't bothered to trim off the tail but you can do this later)
01:44:21 <pejo> Does anyone have an idea where the at sign might end up on a UK mac?
01:44:46 <daf> pejo: isn't it on ' as usual?
01:45:19 <quicksilver> pejo: shift-2
01:45:44 <pejo> quicksilver, many thanks!
01:46:03 <pejo> Perhaps that should have been: @quicksilver.
01:46:29 <quicksilver> this ain't twitter :P
01:47:55 <pao> what do old time darcs users / haskell experts think about git?
01:48:00 <opqdonut> git rules
01:48:20 <pao> opqdonut: do you qualify as old time darcs user? :-)
01:48:33 <opqdonut> well darcs was the first dvcs i used
01:48:42 <pao> opqdonut: ok... you qualify :-)
01:48:43 <opqdonut> couple of years ago
01:48:48 <opqdonut> nowadays i'm a git user
01:49:02 <lispy> pao: I haven't really used git much, but it seems fine even if a bit clunky in the UI.  Also, I've heard the C code they use is a bit...er, ugly even for C code.
01:49:17 <opqdonut> it's not ugly, it's torvaldish ;)
01:49:26 <daf> darcs wins hands down on user interface quality
01:49:30 <fasta> Git has UI tools. Darcs hasn't AFAIK.
01:49:37 <lispy> I've heard tale of gotos floating around inside there and what not.  Never bothered to check though.
01:49:40 <fasta> GUI*
01:49:43 <daf> but after using git for a while, darcs does feel inflexible
01:49:50 <Thunder> @where hpastetwo
01:49:50 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
01:49:51 <opqdonut> git is the unix of dvcs's, just a bunch of tools that scale really well
01:49:54 <Eridius> pao: I started on darcs, but moved to git fairly fast
01:50:03 <opqdonut> darcs strongly forces certain use patterns
01:50:15 <opqdonut> personally i find branch=repo a bit ugly
01:50:37 <mathijs> I love git. been working with it for about a year professionally. it's perfect for local branching/merging and it's FAST. UI tools aren't needed. well I do use maGit in emacs since about a week.
01:50:47 <Thunder> Hugo: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1408#a1408
01:50:53 <mathijs> darcs is slow
01:50:55 <pumpkin> I love git too, especially now that github is around :)
01:51:15 <opqdonut> mathijs: gitk is great, tho
01:51:17 <opqdonut> for browsing
01:51:37 <opqdonut> but yeah, the command line suffices for all "actions"
01:51:39 <mathijs> opqdonut: sorry forgot to mention, off course I use gitk.
01:51:45 <pao> I'd like to move from hg to git, but I see that a large parte of the haskell community is still hooked with darcs... I really cannot affort to master 3 DVCS...
01:51:54 <opqdonut> and rebase -i and the other interactive versions are gggggreat
01:52:00 <opqdonut> when fixing complex fuckups
01:52:05 <pumpkin> pao: luckily git is a lot closer to hg than to darcs
01:52:19 <pumpkin> pao: it should be a pretty smooth transition
01:52:23 <daf> well, they're only fuckups in git
01:52:36 <daf> in other vcses, you'd just commit new patchjes instead of modifyuing old ones
01:52:52 <daf> once you have the ability to modify history, though, it's quite tempting
01:52:53 <pao> pumpkin: the question is... is the haskell community slowly converging to git as well? ghc seems to have decided on the topic...
01:53:02 <pumpkin> pao: how so?
01:53:12 <pumpkin> pao: I've seen several projects on hackage with git repos
01:53:23 <pumpkin> but darcs is still more common :)
01:53:24 <daf> pao: I don't think it's at all clear
01:53:46 <daf> aside from anything else, darcs development has picked up again recently
01:53:50 <pumpkin> I don't think the community as a whole needs to settle on a single one
01:53:59 <quicksilver> I don't think the community will converge to git, no.
01:54:15 <opqdonut> i think the world will converge on git
01:54:22 <Thunder> I'm an old darcs user and come from rcs via csv. I do not like newer systems like git, Microsoft Teamwork or *I forgot the name* ...
01:54:30 <opqdonut> but it's nice to see darcs being developed again
01:54:36 <quicksilver> GHC is a *huge* project so it exercised precisely darcs 1's weak points; or git's strong points.
01:54:48 <quicksilver> personaly I prefer bzr's UI, but that is a question of taste
01:54:52 <quicksilver> (and what you're used to)
01:54:56 <opqdonut> yeah, for small and one man projects darcs is really nice
01:55:06 <opqdonut> i mean the ui is somehow so jeevish and polite :)
01:55:51 <pao> the nasty thing is that while csv / svn was almost the "standard" a couple of years ago in the open source community... now you need to master at least svn + hg + git + darcs ... :-)
01:56:17 <daf> git-svn helps
01:56:18 <opqdonut> nah
01:56:27 <opqdonut> git+svn is all that's necessary really
01:56:34 <opqdonut> i personally have bumped into only on hg project
01:56:37 <Thunder> My primary UI is the command line. I can't click very well. darcs offers an instant and movable repository.
01:56:51 <opqdonut> well so does git, and so does hg :)
01:57:03 <Thunder> svn was the name of the other control system I do not like.
01:57:07 <Eridius> every time I try to use a darcs project I get frustrated at darcs's lack of commands and confusing interface
01:57:09 * wli runs into svn, hg, git, darcs, and bk (yes, bk still).
01:57:23 <daf> wli: yikes
01:57:29 <HugoDaniel> i use only svn, and i like it
01:57:31 <pejo> wli, inside some billion dollar corporation?
01:58:12 <wli> Actually the billion dollar corporations have their own internal revision control, which Linux groups tend not to touch.
01:58:20 <wli> e.g. CMVC at IBM
01:58:23 <C-Keen> Eridius: what is the frustrating part for you>
01:58:32 <quicksilver> Thunder: just for clarity, when I said 'UI' I did not mean GUI.
01:58:40 <wli> Other places use ClearCase et al.
01:58:52 <quicksilver> Thunder: I would rather remove my own eyes using a wooden spoon soaked in acid than use a GUI for revision control.
01:58:56 <Thunder> quicksilver: UI as User Interface (not skin)
01:58:59 <Eridius> C-Keen: well, for example I wanted to identify to someone else what commit I built from, and the only way I could see how to do that was to ask for `darcs whatchanged` and read the message from the top item.
01:59:08 <quicksilver> Thunder: the UI I was referring to was a command line, yes.
01:59:39 <quicksilver> HugoDaniel: SVN is not a valid comparison, it doesn't even solve the problem under discussion ;)
01:59:46 <HugoDaniel> :D
01:59:57 <pao> I think the minimum required set for an haskell opensource contributor wannabe would be svn (easy) + darcs + git
02:00:10 <C-Keen> Eridius: darcs whatsnew is equivalent to svn stat
02:00:10 <daf> why SVN?
02:00:14 <Thunder> Hugo: Does my solution match your needs?
02:00:15 <pumpkin> pao: I haven't seen any haskell projects on svn
02:00:31 <C-Keen> Eridius: darcs changes --last=1 would give you the last applied patch in time
02:00:42 <pao> well, let's drop svn...
02:00:52 <C-Keen> Eridius: neither one is sufficient to identify your repository state uniquely
02:00:56 * Thunder throws svn away. *done*
02:01:25 <quicksilver> I don't really believe in darcs patchsets, which is I think what Eridius is referring to.
02:01:26 <opqdonut> C-Keen: one of the reasons why git is so nice: content-based hashes
02:01:34 <Eridius> err yeah, I meant changes, not whatchanged. But my point was I can't uniquely identify my commit
02:01:42 <C-Keen> opqdonut: yes, I agree
02:01:45 <quicksilver> I like well defined tree states - commits, revisions, versions.
02:01:56 <quicksilver> Even when your revision tree has become a graph
02:01:59 <Thunder> darcs is missing intelligence in detecting patches. That's my problem.
02:02:01 <C-Keen> Eridius: That is indeed a problem, which is going to be adressed
02:02:02 <Eridius> I also couldn't go back in time and say "when did this change occur". i.e. the equivalent of `git log -Sfoo`
02:02:08 <quicksilver> I prefer to think of it as a tree with merge points.
02:02:16 <pumpkin> I find it somewhat  disturbing that ghc produces an executable that's 3.4 MB, and that running bzip2 on it reduces it to 700kb
02:02:32 <C-Keen> Eridius: what darcs won't ever do is provide a history based view of a repository
02:02:39 <pejo> pumpkin, did you strip it?
02:02:46 <pao> pumpkin: did you try strip?
02:02:48 <pumpkin> yeah :P that's after stripping :)
02:02:52 <HugoDaniel> oh Thunder, yes, thanks a lot :D i was coding it by my own, and didn't realize that you had done it :D
02:02:53 <HugoDaniel> great
02:02:56 <C-Keen> Eridius: darcs is doing a change based repository approach
02:02:58 <HugoDaniel> thanks man :D
02:03:25 <Eridius> C-Keen: right, but I couldn't say "what patch made this change?"
02:04:06 <C-Keen> Eridius: darcs annotate does this
02:04:57 <Eridius> C-Keen: no, I don't want annotation. I want to search all the patches and say "tell me the patch that introduced a diff that contained the following text"
02:06:13 <pao> @google darcs git
02:06:15 <lambdabot> http://wiki.darcs.net/DarcsWiki/DarcsGit
02:06:15 <lambdabot> Title: DarcsGit - DarcsWiki
02:06:16 <C-Keen> Eridius: oh, ok. That's not what I understood by 'this change'
02:06:29 <C-Keen> darcsgit is dead
02:07:09 <pao> my profile google search gives as the first result: "How I stopped missing Darcs and started loving Git" :-)
02:07:14 <pao> *profiled
02:07:16 <C-Keen> Eridius: with darcs annotate it is somewhat the other way around, you would say which patch changed this line
02:07:30 <Eridius> yeah, just like git annotate or svn blame
02:07:38 <C-Keen> Eridius: to grep for diffs I would use darcs changes -v | grep
02:07:45 <Eridius> eww
02:08:00 <C-Keen> with some pattern matching to just use relevant patches
02:09:18 <C-Keen> Eridius: I have never had to use this though.
02:09:27 <Eridius> heh
02:09:28 <C-Keen> Eridius: I see that it might be valuable
02:10:39 <koeien> i get "ghc: could not execute: trhsx
02:10:41 <X-Scale> Is there some CVS/DCVS well established theory developed ?
02:10:44 <koeien> ". what is the source of this error?
02:10:47 <C-Keen> Eridius: what's your use case for this? I am really interested in people's workflow with dvcs'
02:10:51 <koeien> (trhsx is in my PATH)
02:11:04 <pao> which darcs repo format do you usually use?
02:11:31 <Eridius> C-Keen: well, for example I checked out the code for yi and the Cocoa frontend wouldn't build. I guessed that the type of a particular method had changed, but I didn't know how to use the new type
02:11:43 <C-Keen> X-Scale: there are a couple of theories and scientific work going on. Check the darcs wiki for links
02:11:48 <Eridius> so I wanted to find any patches that had made similar changes in other frontends by searching for patches including that method name
02:11:58 <Eridius> hoping to find a patch where another frontend jumped from using the old type to the new type
02:12:17 <HugoDaniel> how do i convert from String to Double ?
02:12:26 <Eridius> readDouble?
02:12:29 <HugoDaniel> ah okey
02:12:30 <HugoDaniel> thanks
02:12:30 <Eridius> or whatever it's called
02:12:31 <X-Scale> Thanks, C-Keen.
02:12:32 <C-Keen> :t fromEnum
02:12:33 <Eridius> that's just a guess
02:12:34 <lispy> ?hoogle String -> Double
02:12:35 <lambdabot> forall a. (Enum a) => a -> Int
02:12:35 <lambdabot> Prelude read :: Read a => String -> a
02:12:35 <lambdabot> Text.Read read :: Read a => String -> a
02:12:35 <lambdabot> Prelude error :: String -> a
02:12:41 <HugoDaniel> yes read
02:12:50 <pao> > read "1.0"  :: Double
02:12:52 <lambdabot>   1.0
02:13:20 <C-Keen> Eridius: ah, I see. Thanks!
02:13:59 <CTA> Will Haskell be hard to learn if you can remember very little of programming? (talking about myself in summer 2010)
02:14:25 <Eridius> CTA: learning a language is more about your mindset and not so much about how much you already know
02:14:30 <CTA> I mean like.. It looks very complicated
02:14:40 <pejo> CTA, some universities teach it as first programming course, and their students seem to be doing fine.
02:14:49 <C-Keen> CTA: programming itself has nothing to do with a particular language
02:14:57 <Eridius> pejo: seriously? that's awesome
02:15:11 <Eridius> I was happy when WPI switched to using Scheme as their introductory language
02:15:17 <koeien> pejo: OTOH, people at my uni complain a lot about FP / Haskell :) the course is considered way too hard
02:15:51 <pejo> koeien, they say the same thing about the math too, I hear.
02:15:51 <CTA> Yeah, just i'm stopping programming 'til I leave school so I can focus on GCSEs and things, then when it's summer i'll get a book on Haskell or something and then hopfully get a course @ college - uk
02:15:55 <pao> CTA: having no previous "standard" programming knowledge can help
02:16:18 <koeien> pejo: yes. also about math courses, but only <40% passes FP here the first time
02:16:47 <pejo> Eridius, I think it's more common in europe, scheme seems to have a stronghold in the US.
02:16:49 <CTA> I wish to take: Math, Further Math, CS, and a programming class of what i'm learning at that time
02:17:29 <C-Keen> Eridius: it has been a while since I last pulled from yi, wow a lot changed
02:17:33 <Eridius> heh
02:17:44 <Eridius> I was testing it out, but the Cocoa frontend is not really being maintained, so it's not particularly usable
02:18:01 <Eridius> I tried building gtk2hs but I was running into issues with it not recording the proper lib paths so I couldn't actually use it :/
02:18:27 <CTA> Haskell looks very complicated but when I learn it I think it'll be cool to write code like that =D
02:19:22 <C-Keen> CTA: there is only one way to find out: Just do it. Real World Haskell has some great things to learn
02:19:34 <ricky_clarkson> CTA: If you like maths, Haskell will probably appeal to you.
02:19:39 <C-Keen> Eridius: what was the name of the method you were looking for?
02:19:54 <Eridius> C-Keen: I don't remember anymore. Someone else fixed the Cocoa frontend for me
02:20:00 <CTA> Has Haskell got an IDE/ a compiler to make nice GUIs?
02:20:10 <yitz> CTA: did anyone mention "learn you a haskell"?
02:20:30 <CTA> nope?
02:20:37 <yitz> @where lyah
02:20:38 <lambdabot> www.learnyouahaskell.com
02:20:41 <CTA> Btw i'm not learning haskell yet, this will be in a year
02:21:10 <yitz> CTA: we're trying to distract you away from your programme and get you started now :)
02:21:15 <C-Keen> CTA: there are some GUI ideas, starting from gtk2hs which will load a gui definition from glade for example or grapefruit and such
02:21:32 <yitz> also wxHaskell
02:21:54 <yitz> the Reactive stuff is exciting, but still in development
02:22:32 <CTA> haha, i've came from loads of diffo languages, just the thing, about 10 days ago i just bought a c# book for £21 :/
02:22:33 <yitz> ide's - in truth most people use emacs or vi
02:23:09 <yitz> CTA: though there is an eclipse plugin, and something for MSVS. not sure how up-to-date those two are though.
02:23:45 <yitz> CTA: there's also yi, an editor written in Haskell. still in development, but already usable (i've heard)
02:24:46 <CTA> is haskell "good" for hardware stuff?
02:25:07 <yitz> CTA: ha, good. it's mind-expanding to know a number of lanuages. you'll find haskell is quite different though.
02:25:55 <CTA> I know, Haskell is like o.O to me, i've only used C based languages
02:26:02 <yitz> CTA: you can hack up your haskell to have pretty good control of the machine code it gets compiled to, if that's what you mean
02:27:27 <CTA> kinda, I mean like, if an USB were to be plugged in it might say, USB-blah recoginised
02:27:27 <yitz> CTA: haskell is also used in industry to *design* hardware. but actual firmware is still almost exclusively written in C these days.
02:27:41 <CTA> kk
02:27:48 <mathijs> Hi all, I saw HaskellDB released a new (ghc 6.10.1 compatible) version. I've been wanting to try it out for some time. One of the programs that's included (DBDirect) doesn't install by default so I want to do it by hand. Problem is... it doesn't have a Main module or main function.
02:27:50 <yitz> CTA: that's an OS thing
02:28:10 <CTA> can you write an os completely in haskell?
02:28:17 <lispy> ?go house haskell
02:28:18 <lambdabot> http://programatica.cs.pdx.edu/House/
02:28:18 <lambdabot> Title: House
02:28:19 <yitz> CTA: you can call the OS API C function from haskell
02:28:30 <lispy> CTA: Check out house
02:28:46 <yitz> @go house haskell
02:28:46 <lambdabot> http://programatica.cs.pdx.edu/House/
02:28:46 <lambdabot> Title: House
02:28:57 <C-Keen> CTA: now write your first haskell program!
02:29:27 <CTA> I can write hello world (h)
02:29:45 <CTA> let main = putStrLn "Hello, world!"          ... main
02:29:50 <C-Keen> ok, next..
02:29:54 <CTA> haha lols..
02:29:57 <mathijs> CTA: in the end, you could even replace the os C library with a pure haskell one, but really low-level stuff like a kernel is better off in C because of raw performance, and having to be tuned to the hardware instead of some higher-level types.
02:30:13 <Raynes> You wouldn't use 'let' in a source file.
02:30:28 <CTA> let a = [0,2] let b = [4,6] let c = a ++ b            ... c
02:30:37 <yitz> > "Hello, world!" -- CTA
02:30:39 <lambdabot>   "Hello, world!"
02:31:15 <dblhelix> yitz: the House website is down?
02:31:59 <mathijs> dblhelix: it works here
02:32:11 <CTA> same her
02:32:13 <koeien> can I get base>=4 on ghc-6.8.3 ?
02:32:31 <dblhelix> mathijs, yitz, CTA: ah, it was just a little slow then
02:32:47 <yitz> mathijs: of course, if the hardware is a totally non-standard platform, like one of those 60-core things, then you might as well write the low-level API in a functional language also
02:32:56 <dblhelix> I guess it's hard to keep up with my pace at the beginnen of yet another work week :-)
02:32:59 <mathijs> but does anyone know how to make a binary out of a module that doesn't have main?
02:33:17 <yitz> mathijs: the --main-is option
02:33:26 <mathijs> yitz: cool, thanks
02:34:14 <dblhelix> mathijs: you can turn it into a library, for example
02:34:24 <quicksilver> I wonder if that's realy what mathijs wants to do
02:34:30 <quicksilver> doesn't DBDirect have a .cabal file?
02:34:33 <mathijs>  unrecognised flags: --main-is
02:35:12 <mathijs> ah... -main-is
02:35:35 <CTA> anyone here created an irc bot with haskell?
02:36:07 <dblhelix> CTA: lambdabot is implemented in Haskell
02:36:08 <koeien> yes
02:36:13 <koeien> CTA: i did as well
02:36:29 <pumpkin_> lambdabot wrote herself
02:36:35 <koeien> but lambdabot is way cooler
02:36:42 <mathijs> quicksilver: well, I'm a bit stuck :)
02:37:33 <CTA> can isee source pls?
02:37:40 <koeien> eh yeah sure
02:37:46 <mathijs> quicksilver: there's not a cabal file for DBDirect itself, just for haskelldb at full. I got it from hackage
02:38:24 <quicksilver> mathijs: does DBDirect have no instructions at all on how to build it?
02:39:06 <quicksilver> google searches suggest it should just be installed when you install haskelldb automatically
02:39:07 <koeien> CTA: http://huygens.functor.nl/~jochem/Bot.hs
02:39:10 <mathijs> nope, on the website (outdated) it mentions it doesn't get installed by default, but it should get built. All I find in the build directory (after building/installing) is the .o file
02:39:40 <mathijs> quicksilver: it's not in my ~/.cabal/bin
02:40:37 <pejo> koeien, base  4 is ghc 6.10+
02:41:00 <CTA> the file opens in ghci but i see no code,
02:41:02 <koeien> pejo: ah thanks, pity
02:41:21 <koeien> CTA: i discourage you from running it without changing some stuff, such as the channel name and the bot name
02:41:23 <CTA> Could not find module `Network.IRC'
02:41:35 <koeien> CTA: you need the 'irc' module, cabal install irc
02:42:03 <CTA> it doesn't matter, i'll be going on l4d soon
02:42:14 <Raynes> ._.
02:43:12 <koeien> CTA: beware, this code is not nice or recommended :)
02:43:50 <yitz> , "I am also a Haskell bot"
02:43:52 <lunabot>  "I am also a Haskell bot"
02:44:18 <Ralith> koeien: that's a lot of language extensions
02:44:47 <koeien> Ralith: yeah i started with code by somebody else, probably you need just a few or none at all
02:45:10 <CTA> how would i create games with haskell? hopengl?
02:45:22 <Ralith> also possibly some gratuitous IO
02:45:38 <Ralith> CTA: that is one library which certainly might be useful in the development of some games.
02:45:47 <koeien> Ralith: in fact, the code was using happstack before
02:45:53 <koeien> Ralith: then you need a gazillion extensions
02:46:09 <Ralith> is the irc module in Network good?
02:46:12 <Ralith> er
02:46:12 <Ralith> in cabal
02:46:27 <koeien> Ralith: i more dislike the fact that there is a lot of stuff hardcoded :/
02:46:33 <Ralith> like what?
02:46:36 <koeien> Ralith: useable, but you need to add some stuff yourself
02:46:44 <Ralith> minimal is fine
02:47:04 <koeien> like responding to PING ... :)
02:47:05 <CTA> Is there not many Haskell courses at colleges? - UK
02:47:21 <Ralith> koeien: it's an IRC lib, not a framework.
02:47:23 <Ralith> what do you expect?
02:47:29 <Ralith> what's hardcoded?
02:47:38 <koeien> i expected the PONG to be implemented
02:47:56 <koeien> Ralith: in my code the channel & some other things are hardcoded
02:48:02 <Ralith> oh, in your code
02:48:03 <Ralith> 'kay
02:48:16 <Ralith> what I want from an IRC lib is little more than parsing and elegant datatypes
02:48:24 <pejo> CTA, york, oxford and nottingham definitely has them. It would be surprising if Edinburgh didn't.
02:48:40 <CTA> they hard to get into?
02:48:50 <koeien> Ralith: it works okay, it's nothing earth-shocking
02:48:51 <CTA> Im doing GCSEs atm and I'm not a really intelligent guy
02:48:56 <quicksilver> all good courses are hard to get into.
02:49:07 <quicksilver> If you're motivated enough to ask these questions now, you're already in the top 1% though
02:49:09 <CTA> I will be getting mostly Cs, with maybe a A and 2 B's
02:49:31 <koeien> Ralith: you need to add the PONG yourself though, otherwise you'll be disconnected
02:50:39 <CTA> would i not get in with them? ^^
02:50:48 <Ralith> koeien: of course
02:50:58 <Ralith> koeien: that's trivial
02:51:12 <koeien> Ralith: i patched the lib by 4 lines
02:51:15 <Ralith> but it's good that it doesn't hide it from you
02:51:18 <Ralith> patched to do what?
02:51:23 <koeien> to do PONG
02:51:26 <Ralith> -_-'
02:51:32 <koeien> in fact it was stepcut's code :/
02:51:40 <Ralith> that's not really the lib's job
02:51:57 <koeien> Ralith: no but it should be able to encode/decode that
02:52:07 <Ralith> encode/decode what?
02:52:10 <koeien> the PONG
02:52:16 <Ralith> PONGs are encoded?
02:52:24 <koeien> no
02:52:24 <CTA> byee
02:52:28 <ferret_0567> @type Maybe
02:52:30 <lambdabot> Not in scope: data constructor `Maybe'
02:52:30 <koeien> well, yeah
02:52:37 <ferret_0567> where do you get Maybe from?
02:52:40 <Ralith> @type Just 1
02:52:41 <lambdabot> forall t. (Num t) => Maybe t
02:52:48 <Ralith> @type Nothing
02:52:49 <lambdabot> forall a. Maybe a
02:52:51 <ferret_0567> Ralith: that's it?
02:53:04 <Ralith> koeien: go on
02:53:05 <Raynes> @srs Maybe
02:53:06 <lambdabot> data Maybe a = Nothing | Just a
02:53:06 <koeien> Ralith: there is some format, you could send "PONG :..." over the line or whatever is necessary, but i don't know what exactly
02:53:11 <Raynes> ferret_0567
02:53:21 <Ralith> koeien: afaik you just have to return the exact data the server sends
02:53:26 <yitz> hey, @srs works?
02:53:41 <Raynes> It just did.
02:53:46 <koeien> Ralith: so it's nice if you could use (encode $ pong server)
02:53:47 <ferret_0567> Raynes: what does srs mean?
02:53:48 <Raynes> And that was a typo even.
02:53:54 <Raynes> @src Maybe
02:53:55 <lambdabot> data Maybe a = Nothing | Just a
02:54:03 <Raynes> Apparently the same thing @src means.
02:54:25 <Ralith> handy.
02:54:25 <Cthulhon|> lambdabot has an internal spellchecker for a reason.
02:54:31 <Raynes> Cthulhon|: Neat.
02:54:37 <Ralith> oh shit it's Cthulhon|
02:54:46 <Cthulhon|> Three #bh people here. :)
02:54:51 <Raynes> <3
02:55:00 <Ralith> koeien: meh, still not the lib's job
02:55:03 <Ralith> can't you patternmach?
02:55:06 <koeien> Ralith: disagree
02:55:11 <ferret_0567> Raynes: do you have to define the type Maybe yourself or can you import it?
02:55:24 <koeien> Ralith: it encodes 'privmsg', 'join' and other stuff just fine
02:55:25 <Ralith> ferret_0567: it's defined in the prelude, iirc
02:55:29 <Raynes> It's imported automatically.
02:55:32 <ferret_0567> what is #bh?
02:55:44 <Raynes> ferret_0567: A channel on SynIRC.
02:55:45 <yitz> > let perhaps = maybe "I got nothing." (("I got Just " ++) . show) in perhaps $ Just 42
02:55:47 <Ralith> koeien: oh, you mean it offers functions or something to make those?
02:55:47 <lambdabot>   "I got Just 42"
02:55:54 <koeien> Ralith: yes
02:56:13 <Ralith> koeien: then I guess one for pong would be appropriate.
02:56:15 <koeien> Ralith: you get a String out of it that you have to send to the server
02:56:28 <Ralith> it took four lines, though?
02:56:42 <Ralith> I'd be surprised if it took more than a couple one line funcs
02:56:45 <koeien> no, stepcut's patch was two lines for that, and two lines for antoher function that i didn't use
02:56:52 <Ralith> ah.
02:56:54 <koeien> including the type sig
02:57:01 <Ralith> you got a link to his patch?
02:57:12 <koeien> let me grep
02:58:12 <Raynes> I've apparently somehow deleted my emacs configuration file.
02:58:23 <Raynes> This is NOT cool.
02:58:44 * lispy stores his .emacs in a darcs repo
02:59:03 <koeien> Ralith: i have it in my e-mail box
03:00:04 <koeien> Ralith: in fact it was six lines, two to export the function from the module as well ;)
03:00:05 <Ralith> koeien: want to paste it somewhere?
03:00:10 <Ralith> heh
03:01:02 <lispy> > let got = (("I got " ++) . show); perhaps = maybe got got in perhaps $ Just 42
03:01:04 <lambdabot>   Couldn't match expected type `a -> [Char]'
03:01:24 <koeien> Ralith: see, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1409#a1409
03:01:43 <dblhelix> first time I came across this: http://www.langpop.com/
03:01:49 <Ralith> ty
03:02:59 <Ralith> @src maybe
03:02:59 <lambdabot> maybe n _ Nothing  = n
03:02:59 <lambdabot> maybe _ f (Just x) = f x
03:04:22 <lispy> oh right
03:04:33 <lispy> the first param isn't a function on Nothing
03:04:53 <koeien> yeah, that could be, but is unnecessary
03:05:07 <koeien> it's hard to type that funciton in a sane way as well
03:05:17 * lispy nods
03:05:24 <lispy> We don't have dependent types
03:05:45 <koeien> you would be running around in circles :)
03:05:55 <dolio> > maybe "wut?" (("lol " ++) . show) $ Just 42
03:05:56 <lispy> But if we did, I would expect that the first param could be defined on the singleton type of Nothing
03:05:57 <lambdabot>   "lol 42"
03:06:11 <koeien> lispy: pointless :)
03:06:17 <koeien> but indeed, hypothetically
03:06:26 <Dirrk> Does anybody recommendations on the simplest/most efficient way to do binary I/O? The GHC libs seem to provide several ways of doing it (hGetArry, hGetBuf, maybe more)
03:06:49 <lispy> Dirrk: I hear that Data.Binary gets recommended a fair bit
03:06:58 <quicksilver> Dirrk: (1) Data.Bytestring (which has hPut and hGet or similar)
03:07:03 <lispy> Dirrk: and for some uses, Data.ByteString is really awesome
03:07:10 <quicksilver> Dirrk: (2) if you want something a little more structured, Data.Binary.
03:08:01 <Dirrk> But isn't Bytestring only sequential?
03:08:25 <quicksilver> well, depends what you're trying to do with it.
03:08:28 <ferret_0567> @src nullable
03:08:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:08:36 <ferret_0567> @src Nullable
03:08:36 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:08:37 <quicksilver> If you want to read a file RA then of course you don't use a ByteString for the entire file.
03:08:40 <ferret_0567> huh?
03:08:52 <ferret_0567> where is nullable hiding?
03:08:55 <Dirrk> quicksilver: Yes, file RA.
03:08:57 <quicksilver> instead you use a ByteString to read whichever bits you want.
03:09:07 <quicksilver> using hSeek and then hGet
03:09:18 <quicksilver> a ByteString is just a fast binary buffer.
03:09:32 <lispy> ?hoogle nullable
03:09:32 <lambdabot> No results found
03:09:34 <quicksilver> ferret_0567: @src is a very small, manually compiled list of prelude function, that's all.
03:09:44 <ferret_0567> quicksilver: ok
03:09:48 <quicksilver> ferret_0567_: I guess Nullable comes from some database library I haven't used.
03:09:50 <Dirrk> quicksilver: It's sector based, so variable length isn't important.
03:10:08 <quicksilver> Dirrk: As you wish.
03:10:17 <quicksilver> Dirrk: ByteString is a convenient way to read chunks of binary data.
03:10:20 <quicksilver> That's all I'm sayin.
03:10:23 <quicksilver> It's not clever.
03:10:27 <quicksilver> but it's fast and useful.
03:10:46 <ferret_0567> grr...then how do I get maybe to work?
03:10:58 <ferret_0567> simpleTree a b c = Node a (Node "left child"  (maybe b) (maybe c)) (Node "right child" (maybe b) (maybe c))
03:11:39 <ferret_0567> that doesn't work :(
03:12:32 * Dirrk is looking ar ByteString
03:13:10 <ferret_0567> how do I use maybe?
03:13:39 <Ralith> ferret_0567: what are you learning from?
03:13:49 <ferret_0567> Ralith: Real World Haskell
03:13:54 <Ralith> then reread it.
03:14:00 <Ralith> you've skipped some important bits.
03:14:11 <ferret_0567> Ralith: no I haven't
03:14:15 <Ralith> yes, you have.
03:14:15 <ferret_0567> Ralith: I read it all
03:14:25 <Ralith> well, skippped||forgotten
03:14:34 <Ralith> for example
03:14:39 <Ralith> maybe and Maybe are two very different things
03:14:49 <Ralith> (neither of them is what you want)
03:14:49 <Raynes> Maybe is a data type for one.
03:14:50 <MarcWeber> ?where hscolor
03:14:51 <lambdabot> I know nothing about hscolor.
03:14:56 <MarcWeber> ?where hscolour
03:14:57 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
03:15:41 <Dirrk> Possibly I'm stupid, but I don't see how to use it efficiently for what I want. What I want is basically: Read a chunk from a file, then map that to some word- or bit-based data structure.
03:15:59 <Dirrk> Still looks like readying a whole array of Word8 might be better.
03:16:23 <quicksilver> @hoogle hGet
03:16:24 <lambdabot> Data.ByteString hGet :: Handle -> Int -> IO ByteString
03:16:24 <lambdabot> Data.ByteString.Char8 hGet :: Handle -> Int -> IO ByteString
03:16:24 <lambdabot> Data.ByteString.Lazy hGet :: Handle -> Int -> IO ByteString
03:16:32 <quicksilver> Dirrk: use hGet to read a chunk from a file
03:16:39 <quicksilver> Dirrk: that's the only part I was claiming bytestring solves.
03:16:57 <quicksilver> Dirrk: a ByteString is an efficient array of Word8, effectively.
03:16:59 <Dirrk> quicksilver: And then I have to parse it. That's much simpler if it's already in an array...
03:17:13 <Dirrk> quicksilver: Yes, but without random access.
03:17:29 <quicksilver> without random access in the sense of "with random access", yes.
03:17:47 <ferret_0567> Ralith: so use Just a instead?
03:17:53 <Dirrk> And I need random access because the info I wanted is distributed all over the place :-)
03:17:56 <Ralith> ferret_0567: yes.
03:17:59 <quicksilver> Bytestring take and drop are O(1)
03:18:04 <quicksilver> so you have O(1) random access.
03:18:19 <ferret_0567> Ralith: is that appropriate for a value that may be missing?
03:18:19 <Ralith> @type Just 4
03:18:20 <lambdabot> forall t. (Num t) => Maybe t
03:18:28 <Ralith> ferret_0567: so I'm told.
03:18:28 <Dirrk> But not in "first I want to look at byte 16, and then at byte 4"
03:18:37 <quicksilver> Dirrk: yes, in every sense.
03:18:44 <Ralith> ferret_0567: depends on your circumstances, of course.
03:18:51 <Ralith> @type Just
03:18:53 <lambdabot> forall a. a -> Maybe a
03:18:54 <quicksilver> let byte16 = take 1 . drop 16 $ bs; byte 4 = take 1 . drop 4 $ bs
03:19:03 <quicksilver> Dirrk: like that, for example.
03:19:12 <quicksilver> although you might choose to have a wrapper around 'take n . drop m'
03:19:13 <Dirrk> quicksilver: You cannot tell me that's more efficient than (! 16).
03:19:25 <quicksilver> Dirrk: why can't I tell you that?
03:19:33 <Dirrk> Because I won't believe it :-)
03:19:35 <quicksilver> it has very similar efficiency.
03:19:42 <quicksilver> ByteString is designed for fast random access.
03:19:44 <Dirrk> asymptotically, maybe.
03:20:04 <quicksilver> I'd be surprised if you found arrays came out faster.
03:20:11 <quicksilver> I *know* you'll find arrays less convenient to work with.
03:20:14 <Dirrk> I didn't test.
03:20:20 <quicksilver> now, go prove me wrong if you like.
03:20:24 <Saizan> Dirrk: look at ByteString definition, it's effectively a pointer to a chunk of memory
03:20:35 <Dirrk> Saizan: Yes, I know.
03:20:55 <Dirrk> But I still can't believe the overhead in dealing with take/drop is equal to just accessing an immutable array.
03:21:05 <quicksilver> you're obsessing with syntax.
03:21:09 <Dirrk> And there is some overhead.
03:21:10 <quicksilver> take/drop will inline anyway.
03:21:22 <quicksilver> write (!) for bytestring and then forget about it
03:21:26 <quicksilver> then it looks just like arrays.
03:21:33 <ferret_0567> Couldn't match expected type `Tree [Char]' against inferred type `Maybe a'
03:21:59 <Dirrk> Sorry, I'm not convinced. Then why don't use arrays in the first place?
03:22:11 <ferret_0567> :(
03:22:25 <ferret_0567> why doesn't this work?
03:22:32 <Saizan> ferret_0567: every value in the tree must have the same type
03:22:53 <ferret_0567> Saizan: it does though, doesn't it?
03:23:02 <Saizan> ferret_0567: so if you use a value of type Maybe String in one place you can't use one of type String in another
03:23:12 <ferret_0567> Saizan: oh
03:23:48 <quicksilver> Dirrk: I use ByteString because of the convenience of hGet and hPut.
03:23:53 <quicksilver> Dirrk: by all means, go and use Arrays.
03:24:03 <quicksilver> Dirrk: I'm not paid a commission based on which library you choose.
03:24:06 <quicksilver> You make your call.
03:25:11 <Ralith> koeien: how do I feed that into darcs?
03:25:30 <koeien> Ralith: ah it's not a complete patch, just what you need to reconstruct it
03:25:39 <Ralith> koeien: I tried sending it to the standard input of 'darcs apply' but I keep getting bad bundle
03:25:42 <Ralith> oh
03:25:45 <Ralith> kk
03:25:54 <koeien> Ralith: i didn't have the repo
03:25:55 * Ralith had intended to maintain attribution and so on by way of darcs
03:26:10 <koeien> Ralith: if you /msg your e-mail address i can send it to you
03:27:02 <ferret_0567> Saizan: I try this and it still doesn't work:
03:27:26 <ferret_0567> simpleTree a b c = Just Node a ((Node "left child")  (Just b) (Just c))
03:27:38 <ferret_0567>                                ((Node "right child") (Just b) (Just c))
03:28:16 <quicksilver> 'Just' only takes one parameter
03:28:25 <quicksilver> so the whole thing after Just would have to be in parens (...)
03:28:30 <quicksilver> if that is indeed what you want.
03:28:34 <koeien> ferret_0567: extra parentheses after Just
03:29:50 <idnar> or you could use $
03:31:01 <Saizan_> ferret_0567_: how is your Tree type defined, btw?
03:31:15 <ferret_0567> forget the Just Node a. If I use ((Just Node ".."..)) then it still doesn't work
03:31:43 <ferret_0567> data Tree a = Node a (Tree a) (Tree a) | Empty deriving (Show)
03:31:56 <Dirrk> @hoogle createAndTrim
03:31:57 <lambdabot> Data.ByteString.Internal createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
03:31:57 <lambdabot> Data.ByteString.Internal createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
03:32:12 <Ralith> ferret_0567: that datatype doesn't refer to maybes anywhere
03:32:18 <Ralith> Maybes that is
03:32:33 <ferret_0567> Ralith: so I need to add maybes to the type
03:32:40 <ferret_0567> ?
03:32:54 <quicksilver> No, certainly not.
03:33:06 <quicksilver> I assumed you were trying to create something of type Node (Maybe String)
03:33:14 <quicksilver> ferret_0567: perhaps you can explain what you think you're trying to do.
03:33:21 <Saizan_> "Tree (Maybe String)"
03:33:57 <quicksilver> thanks Saizan_ ;)
03:33:58 <Saizan_> ferret_0567_: earlier by value in the tree i meant the field of type 'a'
03:34:02 <quicksilver> that is indeed what I meant to type.
03:35:21 <Saizan_> yeah :) (i'm always surprised by how we manage to insert a typo or slip a word in the crucial part of most exposition :)
03:35:34 <ferret_0567> I am trying to finish exercise 2 under Recursive Types in Chapter 3 of RWH
03:36:21 <ferret_0567> 2. Define a tree type that has only one constructor, like our Java example. Instead of the Empty constructor, use the Maybe type to refer to a node's children.
03:37:19 <quicksilver> ferret_0567: I am not personally convinced that you have absorbed enough of the information in that chapter to complete this exercise.
03:37:33 <quicksilver> it may well be worht a re-read
03:37:35 <yitz> Saizan: we never make typos
03:37:43 <yitz> Saizan: s/never/often/ oops
03:38:47 <Saizan_> ah, then you've to define a new tree type, "data SingleConstructorTree a = TheConstructor a ..."
03:39:27 <ferret_0567> I don't think I know what a constructor really means
03:40:02 <Ralith> koeien: forkIO in your bot is used to split off a new thread for every message received, right?
03:40:19 <cizra> ferret_0567: Constructor is a function that takes the component data chunks and spits out a composite object, sorta
03:40:22 <koeien> Ralith: no
03:40:45 <Ralith> koeien: oh, it's used to execute all those tasks in parallel?
03:40:51 <lispy> what is a prelude type with kind * -> * -> *.  I know Either is one example, what's another
03:40:55 <lispy> ?kind Monad
03:40:57 <lambdabot> Class `Monad' used as a type
03:41:03 <ferret_0567> cizra: oh wait, a Constructor is used when making a new List type
03:41:06 <lispy> ?kind []
03:41:08 <lambdabot> * -> *
03:41:11 <ski_> @kind (,)
03:41:13 <lambdabot> * -> * -> *
03:41:24 <ski_> also, `(->)' in haskell proper
03:41:35 <Ralith> @where forever
03:41:35 <lambdabot> I know nothing about forever.
03:41:48 <koeien> Ralith: there is a thread for reading messages from the server, one for writing to the server (using a Chan), and one for monitoring a FIFO file
03:41:52 <lispy> ski_: Yeah, I was going to use (->), but I started to wonder if putting parens around (->) would confuse my readers :)
03:42:09 <yitz> ferret_0567: a constructor is used when making any type, if you use data or newtype to define the type
03:42:09 <Ralith> koeien: and each one is launched by forkIO?
03:42:19 <ski_> lispy : what are you writing ?
03:42:26 <lispy> ski_: my thesis
03:42:30 <Ralith> not counting the fifo thread which seems to just be the main thread
03:42:31 <ski_> ah
03:42:47 <lispy> ski_: Not everyone on my committee knows haskell
03:42:55 <ski_> is the topic of it public ?
03:43:14 <lispy> ski_: yeah, I'm writing about some work I did on the darcs source
03:43:15 <quicksilver> useless trivia - there are no alphanumerical binary data constructors in the prelude
03:43:19 <yitz> lispy: people busy writing their thesis should not be allowed to host lambdabot on their servers
03:43:20 <Saizan_> ferret_0567_: e.g. in "data A = B Int String | C Bool" you're defining a new type A, with two data-constructors B and C
03:43:26 <Dirrk> @hoogle mallocForeignPtrBytes
03:43:27 <lambdabot> Foreign.ForeignPtr mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
03:43:28 <lispy> yitz: why?
03:43:37 <lispy> yitz: what is the connection :)
03:43:46 * SamB can't believe this was intentional: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=515556
03:44:03 <yitz> lispy: because they need to be allowed peace and quiet, not be bothered every time the bot has problems.
03:44:18 <pumpkin_> that's why Cale runs it! :P
03:44:30 <pumpkin_> (I assume)
03:44:31 <yitz> pumpkin: he runs it on lispy's server
03:44:34 <pumpkin_> yeah
03:44:38 <koeien> Ralith: yes
03:44:49 <pumpkin_> also, it's why pumpkinbot comes to hte rescue when neither Cale nor lispy are around :D
03:45:14 <yitz> pumpkinbot++
03:45:14 <ski_> lispy : regarding underlying theory ? or managing the source ?
03:45:19 <lispy> yitz: heeh, my day job bothers me far more than I get bugged about lambdabot :)
03:45:22 <pumpkin_> :)
03:45:42 <yitz> lispy: a day job too? wow, i'm impressed
03:46:08 <lispy> ski_: it's about how we exposed more stuff to the type system and got better type safety, type correct patch manipulations for example
03:46:17 <lispy> yitz: yeah, But, I'm going super slow on the school
03:46:33 <ski_> lispy : ah, i see
03:46:45 <lispy> I'm hoping to finish real soon now
03:46:45 <ski_> typeful programming in action
03:46:59 <lispy> I'm just revising some chapters and I'm going to give it to profs for feedback in the morning
03:47:09 <lispy> Hopefuly schedule my defense this week, etc
03:47:21 <lispy> (although it won't be for anoter month)
03:47:23 <daf> SamB: RMS tbh :)
03:47:25 <yitz> lispy: good luck!
03:47:30 <lispy> yitz: thanks :)
03:48:06 <lispy> ski_: Yeah, doing the related work section taught me a lot about dependent typing :)
03:48:17 <pumpkin_> byorgey: your typeclassopedia looks amazing, even as a draft
03:48:21 <lispy> ski_: I didn't even know what it was when we started this :)
03:48:29 <ski_> hehe
03:48:47 <SamB> daf: RMS what tbh
03:49:20 <daf> SamB: re that bug
03:49:36 <SamB> what does "tbh" mean in this context ?
03:50:06 <daf> SamB: the normal expansion; perhaps it's just an idiosyncratic usage
03:50:35 <SamB> "RMS to be honest" doesn't seem like a good answer to "I can't believe this was intentional", somehow
03:51:23 <SamB> oh well, at least he apparantly did get them to fix the colors for M-x customize on dark 8-color terminals
03:51:43 <SamB> so that I can now actually read the text entry fields
03:53:49 <Ralith> can HsOpenSSL be used for e.g. openssl network comms?
03:54:04 <blackh1> Ralith: It can - I just got it doing it.
03:54:15 <Ralith> awesome!
03:54:19 <Ralith> is it very hard?
03:54:28 <blackh1> No - quite easy.
03:54:34 <Ralith> :D
03:54:35 * SamB can't imagine what else HsOpenSSL would be intended for
03:54:43 <Ralith> general cryptography
03:55:15 <SamB> oh, you can abuse OpenSSL like that
03:55:16 <SamB> ?
03:55:18 <blackh1> Here's the general procedure: Make your 'main' look like this: main = withOpenSSL $ do  ......
03:55:23 <yitz> blackh1: really? that's great. I thought hsopenssl just exposed a few misc crypto functions. it's complete enough for that now?
03:55:30 <Ralith> blackh1: O.o
03:55:37 <SamB> blackh1: isn
03:55:44 <blackh1> yitz: Someone added it recently, I think
03:55:44 <SamB> 't there anything else you need to do ?
03:55:52 <yitz> awesome
03:56:03 <blackh1> Ralith: Then look at OpenSSL.Session...
03:56:41 <blackh1> Ralith: Here's my code:
03:56:52 <blackh1>       ctx <- Session.context
03:56:53 <blackh1>       ssl <- Session.connection ctx sock
03:56:53 <blackh1>       Session.connect ssl
03:56:54 <blackh1> Easy!
03:57:23 <Ralith> as well as withOpenSSL $ do ... etc?
03:57:27 <blackh1> If there's an error, it uses 'fail'
03:57:59 <blackh1> Ralith: "withOpenSSL" just calls the openssl init function that is required at the beginning of your program.
03:58:02 <Ralith> uses fail?
03:58:07 <Ralith> ah.
03:58:30 <blackh1> Ralith: Yes - so it throws an ioError and you can catch it with Prelude.catch
04:00:32 <blackh> Ralith: I am not sure, but to be on the safe side I would keep the ctx alive for the duration of your session.
04:01:47 <Ralith> :/
04:01:53 <Ralith> OpenSSL/PEM.hsc:113:46: Not in scope: type constructor or class `SomeException'
04:02:22 <blackh> Ralith: Ah yes. It's some cabal-related versioning thing. What I did was...
04:02:25 <jacobian> Is there an exception monad that takes a datatype of a finite disjunction of constructors as the tag for capturing the exception?
04:03:17 <blackh> I expanded the .tar.bz and then typed cabal configure / cabal build / cabal install. That seems to bypass some of cabal's logic and work. HsOpenSSL needs to be fixed really.
04:03:23 <ferret_0567> Saizan_: Your data-constructor explanation has allowed me to see what I believe to be what I am supposed to do
04:03:36 <ferret_0567> Saizan_: Define Tree a like this:
04:03:46 <ferret_0567> data Tree a = Node a (Just Tree a) (Just Tree a) deriving (Show)
04:03:58 <dcoutts> blackh: what logic did you need to bypass?
04:04:41 <ferret_0567> that is only one data constructor, right?
04:04:42 <Ralith> blackh: worked right up until 'install' tried to rebuild
04:04:46 <Ralith> how do I stop it from doing that?
04:05:00 <Ralith> it re-configured, too
04:05:01 <Ralith> wtf.
04:05:14 <blackh> dcoutts: I am guessing that the code is written assuming base version 4.0 but the .cabal file just says base >= 3.0 and cabal defaults to base == 3. Doing 'cabal build' bypasses this and just uses the latest base. This is what I *think* is going on but I may be wrong.
04:05:16 <SamB> jacobian: can't Either ?
04:05:28 <dcoutts> Ralith: "cabal install" is a "do everything" command. build deps, configure, build, install.
04:05:39 <ferret_0567> anybody?
04:05:43 <Ralith> dcoutts: ah; how do I only install?
04:05:55 <dcoutts> Ralith: cabal install --only
04:05:59 <SamB> heh
04:06:01 <Ralith> thanks!
04:06:01 <Ralith> :D
04:06:13 <Ralith> worked
04:06:16 <SamB> dcoutts: and this isn't one of your made up, "see #xxx" type commands ?
04:06:22 <ski_> ferret_0567 : yes
04:06:26 <ferret_0567> Why doesn't Just work in a type definition?
04:06:31 <dcoutts> Ralith: but it's not documented. We'd prefer to have a proper solution
04:06:35 <dcoutts> SamB: nope
04:06:46 <SamB> ferret_0567: just ain't no type constructor
04:06:54 <ski_> ferret_0567 : probably you haven't defined a type (constructor) `Just'
04:07:01 <ski_> maybe you wanted
04:07:05 <Ralith> dcoutts: of course.
04:07:19 <dcoutts> blackh: right, that would be the problem. In the next release of cabal-install, the two methods will be the same so it'll always pick base 3 unless you tell it to pick base 4.
04:07:19 <ski_>   data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a)) deriving Show
04:07:26 <ski_> ?
04:07:54 <dcoutts> Ralith: and you needed to do it for the same reason as blackh? to get it to pick base 4?
04:08:11 <dcoutts> Ralith, blackh: you can use cabal install --constraint='base>=4'
04:08:22 <ferret_0567> ski_: that doesn't work either
04:08:33 <SamB> dcoutts: hmm, personally I think that cabal was right to pick the base that doesn't work
04:08:39 <SamB> that's what I'd want it to do ;-P
04:08:42 <blackh> dcoutts: I am afraid to fix the package in case I become the maintainer. :)
04:08:45 <ferret_0567> ski_: I tried Node a (Just (Tree a)) (Just (Tree b)) too
04:08:50 <ski_> ferret_0567 : "doesn't work" meaning ?
04:09:01 <dcoutts> blackh: heh, you can still use the command line --constraint flag
04:09:08 <ski_> ferret_0567 : maybe it would be nice if you could tell what you're after ?
04:09:14 <ferret_0567> ski_: Couldn't match expected type `Maybe (Tree a)' against inferred type `Tree [Char]'
04:09:24 <Ralith> dcoutts, blackh: that wasn't the solution
04:09:31 <dcoutts> SamB: we don't have enough information to know that here. We're just guessing.
04:09:36 <SamB> dcoutts: because then it would show up the mistake in the .cabal
04:09:37 <ferret_0567> ski_: finish the first exercise 2 of Chapter 3 in RWH
04:09:46 <ski_> ferret_0567 : ok, then your use of the type mismatched the definition .. at least one of those two are wrong
04:10:16 <ski_> ferret_0567 : so maybe you could explain what the exercise here is ?
04:10:27 <dcoutts> SamB: the plan is to do this: http://hackage.haskell.org/trac/hackage/ticket/485
04:10:44 <blackh> Ralith: It's still in my terminal buffer.  I'll paste what I did.
04:10:55 <Ralith> blackh: I mean, install --only worked
04:10:59 <Ralith> but dcoutts's idea didn't
04:11:01 <SamB> dcoutts: not, of course, that cabal knows what version won't work
04:11:05 <dcoutts> SamB: so yes, we'd show up the mistake in the .cabal file. If they said >=3 but actually meant >=4 then it'd show up that mistake.
04:11:12 <blackh> Ralith: Jolly good.
04:11:20 <dcoutts> Ralith: what was the actual source of the problem then?
04:11:32 <dcoutts> Ralith: if not that picking base 4 was the right thing to do?
04:11:48 <Ralith> dcoutts: no idea, but running cabal configure && cabal build && cabal install --only made it work.
04:11:52 <Ralith> the error was:
04:12:00 <Ralith> [28 of 29] Compiling OpenSSL.PEM      ( dist/build/OpenSSL/PEM.hs, dist/build/OpenSSL/PEM.o )
04:12:03 <Ralith> OpenSSL/PEM.hsc:113:46: Not in scope: type constructor or class `SomeException'
04:12:14 <dcoutts> that's a base 3 vs 4 thing
04:12:25 <Ralith> well, your command still produced it
04:12:41 <dcoutts> Ralith: did it not rebuild anything then?
04:12:42 <blackh> dcoutts, Ralith: It definitely says "base >= 3"
04:12:44 <SamB> maybe that version of cabal/cabal-install ignores constraints on base given on the commandline or something ?
04:12:51 <Ralith> dcoutts: it built everything up until then
04:12:55 <dcoutts> SamB: oh! yes. :-)
04:13:08 <dcoutts> SamB: I forgot, I only made that work in the dev version.
04:13:14 <Ralith> ahh.
04:13:19 <dcoutts> Ralith: yes, that'll work in the next version, sorry.
04:13:56 * dcoutts is in the process of testing the next cabal-install release
04:14:00 <SamB> yeah, I remember recently seeing something about a change to make it not ignore base constraints ;-)
04:14:12 <Ralith> hand-edited cabal file fixed the problem too
04:14:13 <Ralith> so yeah
04:14:13 <dcoutts> I've build 900+ packages two ways to compare if I've broken anything :-)
04:14:43 <SamB> dcoutts: how many were broken already, but we just didn't know it ?
04:14:49 <ferret_0567> ski_: the exercise here is: 2.
04:14:53 <ferret_0567> Define a tree type that has only one constructor, like our Java example. Instead of the Empty constructor, use the Maybe type to refer to a node's children.
04:15:02 <ferret_0567> stupid newline...
04:15:18 <dcoutts> SamB: oh, for this test I don't really care how many break, I just want to make sure that the new release does not break any more.
04:15:23 <dcoutts> SamB: it's a regression test.
04:15:39 <SamB> dcoutts: I meant, things that you *appeared* to break
04:15:46 <SamB> but were actually errors in the packagee
04:15:51 <dcoutts> SamB: I've not compared the data yet
04:15:53 <SamB> s/ee/e/
04:15:57 <SamB> ahg
04:16:00 <SamB> er. ah
04:18:58 <ferret_0567> ski_: are you there?
04:19:59 <ErhardtMundt> hello
04:20:10 <ferret_0567> can anyone else help me?
04:20:34 <ivanm> ferret_0567: what are you trying to do?
04:20:55 <yitz> ferret_0567: have you done other exercises?
04:21:02 <ferret_0567> yitz: yes
04:21:33 <ski_> ferret_0567 : hm
04:21:39 <Saizan_> ferret_0567: when defining a type you've to specify types for the fields
04:21:49 <yitz> ferret_0567: you need to get how "data" works, and what the difference is between a type and a constructor. do feel you're getting there yet?
04:21:57 <Saizan_> ferret_0567: but "Just" doesn't build a type, it build a value
04:22:00 <ski_> ferret_0567 : i'm just wanting you to explain in own words what problem you want to solve
04:22:01 <Saizan_> > Just 'a'
04:22:03 <lambdabot>   Just 'a'
04:22:05 <ferret_0567> ivanm: finish the first exerise 2 of Chapter 3 in RWH, the exercise is: Define a tree type that has only one constructor, like our Java example. Instead of the Empty constructor, use the Maybe type to refer to a node's children.
04:22:49 <ivanm> ski_: you expect him to explain? :o
04:22:53 <ivanm> what a ridiculous notion!
04:23:09 <ivanm> what happened to spooning information directly to them (i.e. facts without understanding)?
04:23:10 <ivanm> ;-)
04:23:32 <ferret_0567> ski_: well then, I want to make a Tree type using the Maybe type that has only one constructor.
04:23:41 <ski_> i expected her/him to *attempt* explaining
04:23:52 <ski_> ok
04:23:55 <ferret_0567> ski_: I just did, see the above
04:24:05 <ski_> (i just saw, ye, ty)
04:24:13 <ski_> ok
04:24:38 <ErhardtMundt> hi to everyone
04:24:44 <Botje> hello ErhardtMundt !
04:24:46 <ferret_0567> yitz: no, what part of Ch3 do I need to re-read to get that?
04:25:02 <ErhardtMundt> i'm a newcomer
04:25:10 <ski_> so, how do you want to use the `Maybe' type here ?
04:25:11 <ErhardtMundt> i'd like to learn haskell
04:25:15 <ski_> for what purpose ?
04:25:15 * yitz looks at rwh...
04:25:23 <Botje> getting chicks!
04:25:23 <ferret_0567> @rwh
04:25:24 <lambdabot> Maybe you meant: rc run wn
04:25:27 <ski_> greetings ErhardtMundt
04:25:33 <ErhardtMundt> thanks ski_ :)
04:25:37 <ski_> @where rwh
04:25:37 <lambdabot> is http://www.realworldhaskell.org/blog/
04:25:42 <ski_> @where yaht
04:25:43 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
04:25:46 <ski_> @where lyah
04:25:46 <lambdabot> www.learnyouahaskell.com
04:26:01 <ivanm> we need a @where tutorials ...
04:26:04 <ErhardtMundt> ski_, i need a book to begin with
04:26:18 <ferret_0567> ErhardtMundt: try RWH then
04:26:19 <ski_> ErhardtMundt : try some of the links just above
04:26:20 <mads-> Haa :) Looks like I came just in time to see where the tutorials are :)
04:26:23 <ivanm> ErhardtMundt: real world haskell, Haskell School of Expression, Haskell: Craft of Functional PRogramming, etc.
04:26:32 <ivanm> ErhardtMundt: check the website, it links to quite a few
04:26:39 <ErhardtMundt> i can't try all of them at once :)
04:26:51 <ski_> just fork yourself
04:27:10 <ferret_0567> ski_: I wish I could fork myself...
04:27:21 <ferret_0567> ski_: too bad it's not really possible
04:27:25 <ski_> ferret_0567 : anyway, for what purpose do you want to use `Maybe' ?
04:28:01 <doserj> ErhardtMundt: http://www.haskell.org/haskellwiki/Meta-tutorial
04:28:46 <ErhardtMundt> thank you so much
04:28:51 <ErhardtMundt> you are very kind :)
04:29:14 <doserj> sadly, real world haskell is not mentioned in the meta-tutorial...
04:29:29 <ski_> maybe you'd like to add it, then ?
04:30:01 <ferret_0567> ski_: I want to use it for the case that I can have a value that is either nil or some other value
04:30:13 <yitz> ferret_0567: the first 75% or so of the chapter, up to "introducing local variables"
04:30:17 <SamB> doserj: a recent HWN gave information on how to get a hawiki account if you need that
04:30:21 <SamB> er. haskellwiki
04:30:33 <SamB> hawiki's been gone for a while now, hasn't it ?
04:30:49 <mads-> Using GHCi why doesn't "data Color = Red | Green | Blue" work?
04:30:56 <yitz> ferret_0567: if you know C, concentrate especially on the part that compares Haskell "data" declarations to C structs.
04:31:00 <SamB> mads-: put that in a file
04:31:12 <SamB> ghci can really only do expressions
04:31:14 <ferret_0567> yitz: I do not know C very well
04:31:15 <ski_> ferret_0567 : where `value' is an element of the tree ? or a sub-tree ? or ?
04:31:19 <SamB> at the prompt, I mean
04:31:20 <mads-> SamB : THanks
04:31:35 <yitz> ferret_0567: ok then, not those sections so much :)
04:31:36 <ErhardtMundt> i come from common lisp
04:31:39 <ferret_0567> ski_: yes
04:31:41 <ErhardtMundt> does it help?
04:31:49 <yitz> ferret_0567: do you know another programming language well?
04:32:02 <ferret_0567> yitz: no
04:32:24 <ski_> ferret_0567 : it would help if you clarified which of the alternatives you want
04:32:42 <yitz> ferret_0567: ah, ok. you know, the main target audience of RWH is people who already know how to program, but not in Haskell.
04:32:46 <Saizan_> ErhardtMundt: you know how to use parentheses the right way in haskell at least :) (i had lots of problems with that at first)
04:32:56 <ferret_0567> ski_: I want sub-tree ? or ?
04:33:07 * ski_ doesn't know
04:33:17 <mads-> What is the normal file extension for haskell files? hs?
04:33:21 <ski_> hmhm
04:33:26 <Saizan_> mads-: yes
04:33:39 <ski_> mads- : yes, or `lhs' for literate source
04:34:02 <ski_> ferret_0567 : ok, then it seems again that
04:34:10 <yitz> ferret_0567: personally, I think learning Haskell as a first programming language would produce better programmers faster. but unfortunately, I'm not sure if there is any good book for that.
04:34:17 <ErhardtMundt> Saizan_, :)
04:34:19 <ski_>   data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a))
04:34:22 <ski_> is what you want
04:34:43 <ski_> because inside a node, either you'll have a left sub-tree, or not
04:34:47 <ski_> the same for right-subtree
04:34:54 <ski_> however
04:34:59 <ski_> if
04:35:12 <ivanm> that's a really bad data structure to use if you want a balanced tree... :s
04:35:15 <ski_>   t0,t1 :: Tree Int
04:35:32 <ski_> (i.e. if `t0' and `t1' are both trees with elements of type `Int')
04:35:50 <ski_> then to combine this with an element (e.g. `42') into a node
04:35:56 <ski_> you should not do
04:36:03 <ski_>   Node 42 t0 t1
04:36:42 <ski_> since `t0' (and `t1') is not of type `Maybe (Tree a)' which is what `Node' wants, according to the type definition above of `Tree'
04:36:48 <ski_> what you want is
04:36:57 <ski_>   Node 42 (Just t0) (Just t1)
04:37:06 <yitz> ErhardtMundt: Haskell is a descendent of the ML family of languages. As a reaction to lisp, they a define a syntax that is the opposite extreme - you can write most programs with almost no parens at all, using operators like . and $.
04:37:15 <ski_> if you instead didn't want a right sub-tree at all here, you'd say instead
04:37:20 <mads-> Running a haskell file - is that done by using "GHCi [file]" or ?
04:37:20 <ski_>   Node 42 (Just t0) Nothing
04:37:25 <ski_> here
04:37:32 <ski_>   Nothing :: Maybe (Tree Int)
04:37:39 <ski_>   Just t0 :: Maybe (Tree Int)
04:37:57 <ski_> (the `::' is read "has type" .. not sure whether you know this)
04:38:06 <ski_> ferret_0567 : any comment ?
04:38:28 <ferret_0567> ski_: no, and I akready know that. Thanks for the explanation
04:38:49 <ferret_0567> err..already knew that
04:38:57 <Saizan_> mads-: "ghci file.hs" loads it in the interpreter, if in file.hs you've defined a main action you can execute that directly with "runghc file.hs"
04:39:11 <ski_> so, you must wrap trees with `Just' whenever you want to put them as subtrees inside a `Node ...' node
04:39:24 <mads-> Saizan_ thanks :)
04:40:17 <ski_> ferret_0567 : do you have any more problem/trouble, so far ?
04:42:08 <ferret_0567> ski_: a problem with the simpleTree function
04:42:41 <HugoDaniel> im having problems with the simplest example of hdbc :(
04:42:42 <HugoDaniel> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1410#a1410
04:42:44 <ferret_0567> Couldn't match expected type `Maybe (Tree a)' against inferred type
04:42:47 <HugoDaniel> can someone help me out plz ?
04:43:03 <ferret_0567> Couldn't match expected type `Maybe (Tree a)' against inferred type 'Tree [Char]'. Expression: Node a (Node "left child" b c) (Node "right child" b c)
04:43:57 <ski_> ferret_0567 : this is because you haven't wrapped the inner `Node ...' arguments to the outer `Node' in `Just'
04:44:03 <ski_> i.e. you want to write
04:44:11 <Saizan_> HugoDaniel: add a type annotation to that 1
04:44:32 <ski_>   Node a (Just (Node "left child" b c) (Just (Node "right child" b c))
04:44:33 <HugoDaniel> Saizan_: like i::Int ? :S
04:44:47 <Saizan_> HugoDaniel: yes
04:44:49 <ski_> you might want to wrap `b' and `c' with `Just' too .. not sure
04:45:07 <HugoDaniel> why doesn't it work automatically ?!
04:45:15 <HugoDaniel> wasn't it supposed to ?
04:45:34 <ski_> (it depends on whether `b',`c' are trees, i.e. of type `Tree String', or `Maybe' trees, i.e. of type `Maybe (Tree String)')
04:46:05 <ski_> ferret_0567 : does that make any sense ?
04:46:36 <Saizan_> HugoDaniel: there's too little context for the type checker to pick a type for you, there's nothing in that code that helps it to make a decision
04:46:52 <yitz> HugoDaniel: I suppose different Haskell types get mapped to different SQL types, so it needs to know the exact type. "1" without a type annotation is poolymorphic.
04:47:02 <ferret_0567> ski_: yes
04:47:11 <HugoDaniel> hmm but this is weird, because when i had a "SqlInt32" it complaints about the constructor not being present
04:47:25 <HugoDaniel> but it is
04:48:11 <ferret_0567> ski_: if Just only takes one argument, that is
04:48:29 <HugoDaniel> it compaints about the type constructor not being "in scope"
04:48:33 <HugoDaniel> very strange :S
04:48:53 <yitz> @hoogle SqlInt32
04:48:53 <lambdabot> No results found
04:48:58 <Saizan_> maybe SqlInt32 is a data-constructor?
04:49:04 <HugoDaniel> its in Database.HDBC.SqlValue
04:49:09 <HugoDaniel> yes, data constructor
04:49:13 <HugoDaniel> so i should use it the other way around
04:49:14 <HugoDaniel> okey
04:49:31 <HugoDaniel> then why is the function toSql necessary ? :S
04:50:12 <HugoDaniel> okey, so i changed the line to this: execute stmt [toSql (SqlInt32 1), toSql (SqlString "one")]
04:50:14 <yitz> what is the type of SqlInt32, and what is the type of toSql?
04:50:27 <HugoDaniel> and the error is the same as the hpaste
04:50:42 <HugoDaniel> toSql :: (Data.Convertible.Base.Convertible a SqlValue) => a -> SqlValue
04:50:58 <yitz> HugoDaniel: try toSql (1 :: Int)
04:51:27 <HugoDaniel> okey
04:51:29 <HugoDaniel> thanks yitz
04:51:32 <HugoDaniel> bahh
04:51:39 <HugoDaniel> i feel like completly dumb now :P
04:51:40 <ski_> ferret_0567 : yes, `Just' takes just one argument
04:51:43 <ski_> @type Just
04:51:44 <SamB> how come SqlInt32 doesn't implement Num ?
04:51:44 <lambdabot> forall a. a -> Maybe a
04:52:04 <ski_> (ignore the `forall a. ' there atm, if you like)
04:52:07 <Saizan_> SamB: it's not a type.
04:52:11 <SamB> ah
04:52:14 <yitz> SamB: here the problem is that it's not an instance of Convertible
04:52:33 <yitz> oh it's not a type. :)
04:52:37 <Saizan_> there isn't an instance Convertible SqlValue SqlValue
04:52:48 <Saizan_> which is understandable..
04:53:10 <yitz> HugoDaniel: don't worry about it. Haskell dumbs us all down - the type checker does all the thinking for us, and we get used to it. :)
04:53:27 <Saizan_> HugoDaniel: so, you either use toSql, but then you probably need to annotate the type of the argument, or you explicitly use the constructors of SqlValue
04:54:04 <yitz> Saizan_: sort of. the trivial identity instance does make some sense.
04:55:20 <Saizan_> yitz: tha's why i said understandable instead of right or obvious :)
04:56:37 <ferret_0567> ski_: yet another problem with simpleTree: it doesn't make [Char] into Tree [Char]
04:58:31 <ferret_0567> ski_: am I getting on your nerves yet?
04:59:40 <ski_> ferret_0567 : no, not at all .. i'm just slightly busy with things now and then
05:00:03 <ski_> what is the intended type of `simpleTree' ?
05:00:35 <ski_> i.e. what's the expected type of argument(s) and result
05:00:36 <ski_> ?
05:01:34 <ski_> is `simpleTree' supposed to change take an input of type `[Char]' (which is the same as `String'), and return something of type `Tree [Char]' ?
05:01:36 <ferret_0567> ski_: simpleTree :: [Char] -> Tree [Char] -> Tree [Char] -> Tree [Char]
05:01:42 <ski_> ok
05:01:46 <ferret_0567> ski_: yes
05:02:03 <ski_>   simpleTree :: String -> Tree String -> Tree String -> Tree String
05:02:08 <ski_> (is the same thing)
05:02:13 <ferret_0567> I knew that
05:02:20 <ferret_0567> String == [Char]
05:02:32 <ferret_0567> String is an alias for [Char]
05:02:48 <ski_> so, what is the error message, currently ?
05:04:21 <ferret_0567> ski_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1438#a1438
05:05:09 <ski_> ok
05:05:31 <ski_> you're passing `"2"' and `"3"' as the two latter arguments of `simpleTree'
05:05:42 <ferret_0567> yes
05:06:07 <ski_> those two arguments have type `String', but `simpleTree' doesn't want that, it wants things of type `Tree String' in those arguments
05:06:16 <ski_> so, maybe try instead
05:06:22 <ferret_0567> I know, but how do I convert?
05:06:28 <yitz> simpleTree "1" (Node "2" Nothing Nothing) (Node "3" Nothing Nothing)
05:06:35 <ski_> ^
05:06:51 <ski_> you might want to make a convenience function like
05:06:54 <ferret_0567> :( I don't want nothing
05:07:00 <ski_>   leaf a = Node a Nothing Nothing
05:07:03 <ski_> then you can do
05:07:14 <ski_>   simpleTree "1" (leaf "2") (leaf "3")
05:07:19 <ski_> you see why ?
05:07:26 <ferret_0567> ski_: yes
05:07:32 <lispy> > filter (Nothing==) ferret_0567
05:07:34 <lambdabot>   Not in scope: `ferret_0567'
05:07:43 <opqdonut> :D
05:07:56 <lispy> oh, that's wrong anyway
05:08:00 <ski_> (simple exercise, what is the type of `leaf' ? .. can you figure it out without asking your haskell implementation ?)
05:08:01 <lispy> > filter (Nothing/=) ferret_0567
05:08:03 <lambdabot>   Not in scope: `ferret_0567'
05:08:28 <yitz> > let ferret_0567 = [Just "getting going"] in filter (Nothing==) ferret_0567
05:08:30 <lambdabot>   []
05:08:50 <ski_> > [ferret_0567]
05:08:52 <lambdabot>   [ferret_0567]
05:08:53 * lispy wishes he had a big stapler
05:09:37 <yitz> lispy: don't print it, leave it as a pdf
05:10:02 <lispy> yitz: I can do a lot with it as PDF but at some points I just need to be able to write on it
05:10:04 <yitz> (but back it up)
05:10:12 <lispy> I do backup :)
05:10:22 <lispy> I have it in darcs and I push every patch to another machine
05:10:27 <lispy> which is in a different city, etc
05:11:52 <ksf> it'd be really cool if there'd be a small parsec lib for all the stuff Data.Binary.Get does.
05:11:58 <ferret_0567> sorry, I had to put my laptop in sleep mode, it was running out of juice :(
05:12:07 <ferret_0567> now it's plugged in xD
05:15:25 <quicksilver> ksf: in what way would that be cool?
05:16:09 <ksf> in the way that i could easily integrate it into a cascade of parsers that produce streams of more and more refined types.
05:16:21 <Eridius> ksf: you could *write* that library
05:16:38 <ksf> I think I'm going to, but all I need is getWord8 and getBytes.
05:17:16 <C-Keen>  is there way to get a mipsel ghci on debian without recompiling it myself?
05:20:35 <ferret_0567> shouldn't Maybe a allow Nothing as the value of a?
05:20:46 <ferret_0567> isn't that the whole point of Maybe?
05:20:48 <ksf> ferret_0567, nope.
05:21:02 <ksf> the whole point of Maybe a is being either Just a or Nothing
05:21:39 <ksf> :t Just Nothing
05:21:41 <lambdabot> forall a. Maybe (Maybe a)
05:21:49 <ksf> :t Just Just Nothing
05:21:51 <ferret_0567> ksf: it's too I can't set a to Nothing
05:21:51 <lambdabot>     Couldn't match expected type `Maybe a -> t'
05:21:51 <lambdabot>            against inferred type `Maybe (a1 -> Maybe a1)'
05:22:00 <ski_> > [Just 'a',Just 'b',Nothing,Just 'd']
05:22:02 <lambdabot>   [Just 'a',Just 'b',Nothing,Just 'd']
05:22:02 <ksf> :t Just (Just Nothing)
05:22:04 <lambdabot> forall a. Maybe (Maybe (Maybe a))
05:22:09 <ski_> > ['a','b',Nothing,'d']
05:22:11 <lambdabot>   Couldn't match expected type `Char' against inferred type `Maybe a'
05:22:23 <ksf> the type's called "Maybe", you can use that.
05:22:26 <ferret_0567> ksf: it's too bad, that is
05:23:07 <ski_> a value of type `Maybe Int' can either be `Nothing' or `Just n', for an integer `n'
05:23:27 <ski_> a value of type `Maybe (Maybe Int)' can either be `Nothing' or `Just Nothing' or `Just (Just n)', for an integer `n'
05:24:10 <ferret_0567> then how do I make it expicitely Nothing? Is this even possible?
05:24:35 <idnar> maybe you want () ?
05:24:41 <ski_> the point of `Maybe' it to add an additional `Nothing' alternative, by *changing* the type wanted from `a' into `Maybe a' .. for some type `a'
05:25:22 <ski_> and `Just' is needed to convert a value of type `a' into a "non-`Nothing'" (i.e. `Just') value of type `Maybe a'
05:25:23 <ksf> ferret_0567, types /= type constructors
05:25:33 <ski_> `Maybe' is a type (constructor)
05:25:35 <yitz> ferret_0567: Maybe a is the name of the type. Nothing is the name of a value of type Maybe - it can't appear in a type expression, only in a value expression
05:25:43 <ski_> `Nothing' and `Just' are data constructors
05:25:54 <ksf> errr... yes. i meant to say types /= constructors
05:26:02 <ferret_0567> yitz: ah
05:26:10 <ski_> data constructors are used to create values of the corresponding type (constructor)
05:26:15 <yitz> ferret_0567: a type expression appears to the right of ::, or in a data declaration
05:26:24 <ferret_0567> ski_: I know
05:26:35 <yitz> ferret_0567: a value expression is what defines what a function does
05:27:46 <ksf> byorgey++
05:27:50 <ksf> (typeclassopedia)
05:28:36 <yitz> ferret_0567: data declarations are type expressions, but the also contain the names of the data constructors that are being defined, one for each alternative separated by |. Other than that, data constructors cannot appear in type expressions.
05:28:45 <ksf> so the orthodox path is now lyah -> rwh -> tcop?
05:29:16 <yitz> @karma byorgey
05:29:16 <lambdabot> byorgey has a karma of 10
05:29:35 <yitz> @karma pumpkinbot
05:29:35 <lambdabot> pumpkinbot has a karma of 1
05:29:37 <quicksilver> ksf: -> write monad tutorial -> ? -> profit!
05:29:50 <quicksilver> if only we could work out what '?' was.
05:30:17 <yitz> quicksilver: ? = see /.
05:30:18 <ksf> write a haskell library?
05:30:20 <pejo> ksf,  "tcop"?
05:30:27 <ksf> typeclassopedia
05:30:57 <ksf> http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
05:31:23 <ferret_0567> excellent, I can now finish that exercise I've been working on!
05:31:31 <ferret_0567> Haskell is a lot more fun than C++
05:31:59 <ferret_0567> for me, anyways
05:32:01 <ksf> c++ can be quite nice if you leave out templates and don't try to interface it to a different language.
05:32:20 <ferret_0567> it was the exercises that got me down in C++
05:32:39 <ferret_0567> they were too hard, I don't know all of Algebra 1 yet...
05:33:01 <ksf> ...and as oo, in general, sucks, you can just get rid of the "++" and use what's left.
05:33:18 <ferret_0567> hahah, yeah
05:33:40 <ksf> (// comments and variable definitions anywhere without passing -std=c99, that is)
05:33:42 <ferret_0567> ksf: might as well use C then, no?
05:34:11 <lispy> ksf: templates are fun, that's the only way to make C++ behave in Haskell-ish ways :)
05:34:36 <ferret_0567> ksf: the ++ in C has std::cout though
05:34:48 <ksf> yeah, that's what I tried to tell myself while attempting to learn c++.
05:34:59 <ksf> in the end, I wasn't masochistic enough.
05:35:24 <ferret_0567> ksf: wouldn't you want to use that? (even though it's slower than printf)
05:35:43 <lispy> ksf: Modern C++ Design is a great book that gives you the tools of template wizardry though.  There is an open source library called loki that was made to go with the book.
05:36:10 <lispy> I might have the book title wrong actually
05:36:39 <lispy> ksf: http://en.wikipedia.org/wiki/Modern_C%2B%2B_Design
05:37:05 <ksf> I _can do_ template wizardry. But then, I'd rather smash my head repeatedly into a wall than counting <><<<>>>><><>>><>'s and working with nothing but integers.
05:37:44 <lispy> cool :)
05:37:45 <ksf> also, type inference comes in handy for template nestings > 0
05:37:51 <lispy> yeah it really does
05:39:18 <pejo> ksf, one could perhaps draw the conclusion that C++ is not OO the way it was meant to be.
05:39:53 <ksf> I heard that smalltalk is oo how it's meant to be, but never got around learning it.
05:40:11 <Eridius> message passing ftw
05:40:42 <Eridius> ksf: "I made up the term "object-oriented", and I can tlel you I did not have C++ in mind." -- Alan Kay
05:40:47 <Eridius> *tell
05:41:42 <ksf> most of my oop experience stems from java and c.
05:41:43 <quicksilver> the problems that C++ has with OO are one thing. Most of the problems of OO are inherent.
05:41:52 <yitz> lispy: c++ templates are only fun until you get your first error message
05:42:00 <ksf> c doesn't have them. you do inheritance manually.
05:42:33 <ksf> java can be painfully straight forward.
05:43:46 <lispy> yitz: sadly the same is true about most type hackery in haskell, IMO
05:44:23 <daf> Eridius: the quote goes on to say "I have many of the same feelings about Smalltalk" :P
05:45:04 <Eridius> daf: really? Then why did he say this: OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them.
05:46:04 <yitz> lispy: true, but orders of magnitude less. a single mistake in even the most basic c++ templatery will yield pages of inscrutable spaghetti.
05:46:16 <daf> Eridius: I don't know; ask him :)
05:46:30 <Eridius> daf: I mean, he helped design smalltalk
05:46:36 <daf> I know.
05:47:53 * Eridius is having trouble locating the part of the quote of which you spoke. I finally found a video link, but it's over an hour and with no reference to where the video the quote is supposed to show up :/
05:48:19 <daf> http://blog.moryton.net/2007/12/computer-revolution-hasnt-happened-yet.html
05:48:43 <Eridius> ooh, a transcript
05:50:22 <ferret_0567> yitz: lol inscrutable spaghetti
05:51:12 <Eridius> daf: in context, I don't think he's saying quite what you implied
05:51:28 <Eridius> but I'm having difficulty figuring out exactly what he was referring to when he said "many of the same feelings".
05:51:35 * Eridius should watch that section of the video
05:51:46 <daf> yeah, it is ambiguous
05:52:17 <daf> perhaps is saying that Smalltalk has more of the OO nature than C++ does
05:52:24 <daf> but that's still not what he had in mind
05:52:45 <ksf> for reasons not to use oop, see http://okmij.org/ftp/Computation/Subtyping/
05:53:36 <Eridius> daf: except according to his other quotes, Smalltalk is pretty much exactly what he had in mind
05:55:08 <coco`> hi
05:55:26 <coco`> is there a type class for partial orders?
05:59:22 <yitz> coco`: not a standard one, but it is easy to define one
06:02:50 <p_l> Baughn: Do you know what might happen if I call PTRACE_ATTACH in the same process as the one specified as target of trace? I recall you did some interesting stuff with that
06:05:02 <coco`> yitz: sure, it would just be cool if Ord was a subclass of that
06:05:24 <yitz> coco`: yep
06:17:24 <ikegami__> hello, in the last week end, I tackled Emacs for auto-complete.el
06:17:55 <ikegami__> and got better to write Haskell codes in Emacs
06:18:06 <ikegami__> Here is my works : http://madscientist.jp/~ikegami/diary/20090215.html#p01
06:18:36 <ikegami__> Comments are welcome; we can discuss on the EmacsWiki, too.
06:18:55 * lispy finally found a large stapler
06:19:17 <lispy> ikegami__: cool
06:19:23 <daf> ikegami__: nice!
06:19:25 <lispy> ikegami__++
06:19:34 <ikegami__> auto-complete.el IS cool.
06:20:06 <pao> ikegami__: what source of data do you use for the autocomplete candidates?
06:20:27 <ikegami__> pao: from the GHC web page.
06:20:51 <ikegami__> not automatic but by my hand
06:21:08 <pao> thanks
06:21:10 <ikegami__> took few hours
06:21:34 <pao> ikegami__: it would be nice to automatically gather all names in scope :-)
06:22:17 <ikegami__> exactly
06:22:26 <pao> ghci does it...
06:22:42 * pao wonders how difficult to take that info in vim ;-)
06:22:52 <ikegami__> but no information about pragmas, isn't it?
06:23:20 <pao> ikegami__: what do you mean about pragmas?
06:23:48 <ikegami__> I mean I don't know how to know LANGUAGE pragmas via ghci
06:24:02 <ikegami__> like ImpredicativeTypes
06:24:03 <pao> ikegami__: ah right... I guess so
06:24:56 <lispy> Didn't shim (also an emacs mode) use cabal files to figure that stuff out?
06:27:05 <yitz> pao: vim already has a sort of generalized auto complete that looks for nearby words.
06:27:21 <pao> yitz: yep, that's what I use...
06:27:30 <yitz> pao: it follows #include in C. I wonder how hard it is to teach it to follow haskell imports
06:28:17 <ikegami__> I'll continue to find out how to get keywords via ghci and web page /on the fly/; not embedded in .emacs by hand
06:28:20 <yitz> could the vim method be implemented in auto_complete.el? not as nice as the real way, but perhaps easier to implement
06:28:43 <pao> therehttp://www.haskell.org/haskellwiki/Tags
06:29:27 <pao> ikegami__: I would suggest reading some of the post by Claus Reinke.... http://www.haskell.org/pipermail/haskell-cafe/2007-September/032260.html
06:29:35 <pao> he is the "guru" of ghci "scripting"
06:30:07 <ikegami__> pao: thanks. reading just now.
06:30:35 <pao> or, otherwise, to look at hasktags (generates ctags and etags)
06:31:39 <ehird> does anyone know the issue with inferior-haskell?
06:31:48 <ikegami__> using hasktags is also nice. good advice.
06:36:20 <lispy> hasktags helps, but hasktags does some very not-right things
06:36:41 <lispy> For example, if you have types and functions that vary in name just by capitalization hasktags can get very confused
06:36:52 <inbuninbu> does anyone have any tips for reasoning about haskell performance, specifically memory usage and leaks?
06:36:56 <lispy> It also is not module aware so if a function name exists in several modules it gets confused
06:37:04 <inbuninbu> i tried profiling the code from here: http://www.haskell.org/haskellwiki/Implement_a_chat_server
06:37:27 <inbuninbu> and it seems to add a bit of memory allocation for each and every time a connection is made
06:37:41 <chessguy_work> byorgey++
06:37:45 <lispy> inbuninbu: the best way to optimize a haskell program is by emailing it to haskell-cafe with a detailed explanantion of what is too slow about it and what you've tried
06:37:51 <chessguy_work> byorgey, absolutely positively brilliant
06:37:55 <inbuninbu> i'm suspecting it's maybe the use of tail recursion?
06:38:02 <chessguy_work> (and i'm only on page 9)
06:38:38 <lispy> inbuninbu: oh right, tail recursion isn't as good in haskell as it is in an eager language. Sometimes it paradoxically leads to unevaluated thunks that are rather large
06:38:53 <inbuninbu> lispy: thanks, but i'm not trying to optimize anything in particular at the moment so much as trying to understand where memory leaks tend to come from
06:39:09 <inbuninbu> lispy: thanks, i'll try to avoid it then
06:39:26 <lispy> inbuninbu: do you use foldl or foldr?  If you have a foldl you can replace by foldl' and see if the performance improves (it usually does)
06:40:08 <lispy> inbuninbu: also, if you want to force the parameter of a function to be evaluated you can put a ! infront of it, foo !a b = ..., and that will force a to be evaluated a bit before the pattern match happens
06:41:24 <lispy> inbuninbu: also, have you tried using GHC's memory profiler?  It's pretty good.  The GHC manual explains its usage pretty adequately too.
06:41:42 <chessguy_work> @type (<$>)
06:41:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:42:10 <inbuninbu> lispy: not really. i'm just trying to think in terms of scalability, and looking at networking code. increasing the memory footprint for each connection would lead to huge problems for a server app that stays up all the time. but it's just the tail recursion i think. do you think using sequence inf or something would be preferable to loop over accepting connections?
06:42:16 <ferret_0567> -- file: ch03/GlobalVariable.hs
06:42:17 <ferret_0567> itemName = "Weighted Companion Cube"
06:42:18 <ferret_0567> lol
06:42:35 <ferret_0567> where is that from? I know. Do you?
06:42:36 <inbuninbu> lispy: i've just used -prof and -p thus far
06:42:49 <idnar> ferret_0567: Portal?
06:42:53 <ferret_0567> idnar: yep
06:42:57 <lispy> inbuninbu: sequence inf?
06:43:08 <chessguy_work> so here's what i don't get about <*>
06:43:11 <chessguy_work> @src Applicative
06:43:12 <lambdabot> class Functor f => Applicative f where
06:43:12 <lambdabot>     pure  :: a -> f a
06:43:12 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
06:43:22 <idnar> ferret_0567: http://greg.medding.net/blog/2008/02/29/harmless-companion-cube/
06:43:32 <chessguy_work> it seems really strange to me to already have a function inside a functor and what to do something with it
06:43:38 <inbuninbu> lispy: not sure, i haven't tried it, but i think there's a way to use sequence to run an action indefinitely
06:43:43 <lispy> inbuninbu: If you make a long running server application in Haskell one thing you need to watch for is that each iteration of your mainloop that you fully evaluate all the values you created, that way you avoid a certain type of space leak.
06:43:56 <lispy> inbuninbu: ah, there is forever
06:43:58 <lispy> :t forever
06:44:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
06:44:04 <lispy> ?src forever
06:44:05 <lambdabot> Source not found. Take a stress pill and think things over.
06:44:14 <lispy> forever io = io >> forever io
06:44:16 <chessguy_work> i clearly don't have the right intuition about under what circumstances a function would already be "in" an Applicatve
06:44:41 <ferret_0567> "The Companion Cube will not ever threaten to hurt you.". "We must warn you that the Companion Cube does not speak. If the Companion Cube starts speaking, please disregard anything it says and seek psychological help immediately.".
06:44:58 <lispy> ferret_0567: hehe, portal is a great game :)
06:45:01 <inbuninbu> lispy: thanks, it makes sense that they would have than convenience. while i'm on the topic actually.... is there an elegant way to do 'forever', but with a break condition?
06:45:36 <inbuninbu> lispy: for example, a simple ftp client that parses commands indefinitely, until it gets an EOF
06:45:52 <lispy> inbuninbu: Hmm...the short answer is "YES!".  The long answer is that there exists several rather different approaches to that each with different merits.
06:45:54 <ferret_0567> idnar: it's taking forever to loa
06:45:57 <ferret_0567> load
06:46:44 <lispy> inbuninbu: Oleg recently published a paper about left fold enumerators called iteratees that do exactly that using just simple Haskell98.  You can also use a Continuation monad.  Or you could just implement a "while" loop in Haskell :)
06:46:49 <lispy> ?hoogle while
06:46:49 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
06:46:49 <lambdabot> Data.ByteString dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
06:46:49 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
06:46:55 <lispy> ?hoogle until
06:46:56 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:47:01 <ski_> chessguy_work
06:47:10 <ski_>   foo :: A -> B -> C
06:47:15 <ski_>   fa :: f A
06:47:17 <inbuninbu> lispy: i've read about (but do not really understand) delimited continuations. ordinary continuations will do the trick?
06:47:19 <ski_>   fb :: f B
06:47:29 <ski_>   pure foo :: f (A -> B -> C)
06:47:41 <ski_>   pure foo <*> fa :: f (B -> C)
06:47:49 <ski_>   pure foo <*> fa <*> fb :: f C
06:47:58 <lispy> inbuninbu: I'm not a continuation expert by any means.  But, there are good tutorials on the Cont monad if you want to persue that.  I think you're better off using that approach last :)
06:48:28 <lilac> inbuninbu: i suspect that what you refer to as 'ordinary' continuations are in fact delimited continuations :)
06:48:55 <chessguy_work> ski_ so you would first use pure/fmap to get an unlifted function into the functor
06:49:11 <ski_> yes, that's the common use
06:49:13 <inbuninbu> lilac: ok, thanks. continuations are not exactly something i've figured out yet
06:49:13 <chessguy_work> well, pure/fmap/<$>
06:49:54 <lilac> i think a 'true' non-delimited continuation in haskell would be something like "type Cont a = forall b. (a -> b) -> b" or "type Cont a = (a -> Void) -> Void", but those types are useless.
06:50:06 <inbuninbu> lispy: can i ensure that everything is evaluated through simply making everything strict?
06:50:22 <lispy> while :: (a -> Bool) -> m a -> m (); while p m = do a <- m; if a then while p m else return (); somethig like that might meet your needs
06:50:32 <lispy> inbuninbu: Not exactly no.
06:50:47 <lilac> inbuninbu: "delimited" means that the continuation you grab is only for a part of the rest of your program (usu. the bit in the Cont monad) rather than the entirety of the rest of the program
06:51:07 <lispy> inbuninbu: for example, if you make a list parameter strict it just ensures that the list exists (is not undefined), but it doesn't force the elements of the list to be evaluated
06:51:08 <Saizan> inbuninbu: you can also just use exceptions
06:51:10 <asgaroth> Is there some guard-like construct without the need to define a function?
06:51:32 <doserj> chessguy_work: the point of Applicative is to generalise fmap to several arguments. Now, if you fmap (f :: a->(b->c)), you end up with a function (b->c) inside the functor.
06:51:34 <Toxaris_> asgaroth: case ... of
06:51:40 <lilac> all continuations are delimited in a sense (since they don't capture the entire state of the universe)
06:51:55 <Saizan> inbuninbu: like forever foo `catch` \e -> ..., where foo throws an exception when it wants to exit the loop
06:51:57 <Toxaris_> asgaroth: e.g. case () of () | firstGuard -> ... | secondGuard -> ...
06:51:59 <lilac> hmm, except perhaps quantum computations. :)
06:52:07 <asgaroth> Toxaris_: ah, thanks
06:52:08 <chessguy_work> @type fmap
06:52:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:52:32 <chessguy_work> @type (<$>)
06:52:33 <Toxaris_> lilac: how is (type Cont a = forall b . (a -> b) -> b) not useful?
06:52:33 <inbuninbu> Saizan: thanks, sounds like a good trick
06:52:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:52:45 <ski_> (continuations with false result types aren't delimited)
06:52:49 <chessguy_work> @type (<*>)
06:52:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:53:07 <Toxaris_> @type \f -> f 'x'
06:53:08 <lambdabot> forall t. (Char -> t) -> t
06:53:19 <inbuninbu> lilac: ok, i thought that 'regular' continuations were limited to a certain small block, but you can choose where to put the 'limit' for a delimited one
06:53:20 <ski_> Toxaris_ : (forall b . (a -> b) -> b)  ~=  a
06:53:43 <Toxaris_> ski_: of course, thats the point of the CPS transformation, isn't it?
06:54:24 <inbuninbu> lispy: is there a simple way to ensure that a given expression is fully evaluated?
06:55:06 <Saizan> Toxaris_: with that type you can't really do anything fancy with the continuation, afaiu
06:55:20 <lispy> inbuninbu: if you stick to Haskell 98 it just takes experience.  There are 'deep evaluation' libraries out there that can help you.  I forgot what it's called but I think the function you use is rnf
06:55:29 <lispy> DeepSeq maybe?
06:55:39 <Saizan> NFData
06:55:51 <Saizan> in Control.Parallel.Strategies
06:55:59 <doserj> @hoogle rnf
06:56:00 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
06:56:05 <drdozer> I have a pair of function types that return a value and a function of the other type
06:56:05 <inbuninbu> lispy: ok, thanks i'll look into it
06:56:09 <drdozer> is there a name for this kind of thing?
06:56:11 <Toxaris_> Saizan: yeah it doesn't allow cool control operators, but it has the general CPS benefits, most notably independency of evaluation order
06:56:26 <lilac> Toxaris_: yeah, oops. I meant 'newtype Cont a = forall b. Cont (a -> b) -> b'
06:56:31 <drdozer> newtype NodeWalk n e = NodeWalk { nodeWalk :: (n -> [(EdgeWalk n e, e)]) }
06:56:31 <drdozer> newtype EdgeWalk n e = EdgeWalk { edgeWalk :: (e -> [(NodeWalk n e, n)]) }
06:56:39 <lispy> inbuninbu: good luck.  It's a bit trickier than it ought to be, but I guess that's the price we pay for all the nice thing haskell gives us.
06:57:03 <Toxaris_> Saizan: and actually I guess it already allows call/cc
06:57:54 <Toxaris_> Saizan: but maybe you cannot use the result in a sensible way or something like that
06:58:56 <ski_> Toxaris_ : yes and no
06:59:13 <lispy> inbuninbu: also, don't forget to have people on haskell-cafe give you pointers about your code.  There are some really sharp people there who can explain this stuff much better than I can :)
06:59:23 <ski_> lilac : huh !?
06:59:59 <ski_> `forall b . (a -> b) -> b' does not allow `call-with-current-continuation'
07:00:00 <inbuninbu> lispy: definitely. i hear to really understand haskell you have to understand GHC. which is kinda scary and cool at the same time
07:00:04 <lispy> Oh yeah, I wouldn't expect lilac's to type check.  Either existential type escapes or inferred type is less polymorphic than expected
07:00:46 <ski_> lilac's `newtype Cont a = forall b. Cont (a -> b) -> b' parses as `newtype Cont a = forall b. (Cont (a -> b)) -> b'
07:00:52 <lispy> inbuninbu: hehe. Well, I say the best way to learn any language that is new to you is to try to write a compiler for it.
07:01:24 <lispy> ski_: so isn't the b existential and thus not allowed in the return type?
07:01:29 <Saizan> we miss an "ihc" btw
07:02:03 <ski_> lispy : there's no data constructor. it's invalid syntax
07:02:27 <chessguy_work> @remember byorgey _|_ ... is a party pooper
07:02:27 <lambdabot> I will never forget.
07:02:29 <inbuninbu> lispy: actually i tried writing a dummy language to learn parsec. getting to the AST worked quite well, but i don't know enough about compilers to take it further :-(
07:02:42 <ski_> Saizan : `i' for ?
07:02:51 <lispy> inbuninbu: cool. You might read scheme in 48 hours then.
07:03:13 <Saizan> ski_: inbuninbu ;)
07:03:42 <inbuninbu> i think i saw that actually. i'll have to take a closer look. never programmed in scheme though
07:03:47 <lispy> ski_: hmm..I guess it's just a rank-2 type signature then?
07:04:22 <ski_> `forall b. Cont (a -> b) -> b' is rank-1
07:04:32 <ski_> @kind forall b. Cont (a -> b) -> b
07:04:34 <lambdabot> Not in scope: type variable `a'
07:04:40 <ski_> @kind forall b. Cont (Int -> b) -> b
07:04:42 <lambdabot>     `Cont (Int -> b)' is not applied to enough type arguments
07:04:42 <lambdabot>     Expected kind `??', but `Cont (Int -> b)' has kind `* -> *'
07:04:42 <lambdabot>     In the type `Cont (Int -> b) -> b'
07:05:06 <ski_> (apart from that the standard `Cont' wants two arguments, of course)
07:05:11 <lispy> ski_: Well, having the "forall b ... -> b" increases the rank, right?
07:05:17 <ski_> no
07:05:30 <ski_> `(forall b. ..b..) -> ...' would
07:05:52 <lispy> I guess I'm not reading this signature correctly
07:06:08 <lispy> ski_: is b not an existentially quantified type here?
07:06:13 <ski_> forall b. ((Cont (a -> b)) -> b)
07:06:21 <ski_> enough brackets for you ?
07:06:26 <chessguy_work> hmm, byorgey says that >> is only included in the Monad typeclass so that particular monads can override it with a more efficient implementation than "x >>= \_ -> y". anybody got an example?
07:07:34 <lispy> ski_: I guess it's because, like you said before, there is no data constructor
07:07:34 <ski_> (also, do i need to mention that `newtype Cont a = forall b. Cont (a -> b) -> b' would be a recursive type definition, should it only have a data constructer added to it to make it valid ?)
07:07:42 <Saizan> he meant newtype Cont a = forall b. Cont ((a -> b) -> b) anyway, i suppose
07:07:57 <ski_> that's completely different
07:08:43 * lispy is ashamed that he still gets this existential stuff all messed up
07:09:56 <doserj> chessguy_work: Maybe?
07:10:04 <doserj> @src Maybe (>>)
07:10:04 <lambdabot> (Just _) >>  k      = k
07:10:04 <lambdabot> Nothing  >>  _      = Nothing
07:10:23 <doserj> instead of (Just x) >> k = const k x
07:10:29 <chessguy_work> doserj, oh, good call
07:11:01 <doserj> not that it makes much of a difference...
07:11:20 <ferret_0567> does defining a function named length' shadow length?
07:11:26 <opqdonut> no
07:11:46 <ferret_0567> so, my length' function  will be different than the length function?
07:12:02 <opqdonut> yes
07:12:03 <asgaroth> ferret_0567: yes, ' is just another character
07:12:14 <ferret_0567> ok then
07:15:59 <lispy> I love this quote: "It is a little-known fact that the first implementation of Darcs was actually in C++.  However, after working on it for a while, I had an essentially solid mass of bugs, which was very hard to track down." -- David Roundy, 2005
07:16:37 <sw17ch> @seen dons
07:16:38 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 12h 34m 8s ago.
07:16:57 <chessguy_work> @src ((->) r) >>=
07:16:58 <lambdabot> Source not found. You type like i drive.
07:16:59 <lispy> oh, what is #concatenative?
07:17:39 <chessguy_work> >>= in ((->) e) is just (.) ?
07:17:44 <ferret_0567> how do I define xs? or, better yet, where is the function definition for +?
07:17:58 <doserj> @src (->) (>>=)
07:17:58 <lambdabot> f >>= k = \ r -> k (f r) r
07:18:12 <daf> @src (+)
07:18:12 <lambdabot> Source not found.
07:18:15 <ferret_0567> I want to know how you can make a variable change like that
07:18:18 <sw17ch> @tell dons did you build this, and if so, do you know what program was used to build it? http://www.haskell.org/arrows/addA.png
07:18:19 <lambdabot> Consider it noted.
07:18:28 <ferret_0567> I mean, not xs, but (+=)
07:18:35 <chessguy_work> @pl (>>=) f k = \r -> k (f r) r
07:18:35 <lambdabot> (line 1, column 11):
07:18:35 <lambdabot> unexpected "="
07:18:35 <lambdabot> expecting variable, "(", operator or end of input
07:18:49 <lispy> ferret_0567: what are you referencing here?
07:18:51 <chessguy_work> @pl g f k = \r -> k (f r) r
07:18:51 <lambdabot> g = flip flip id . (ap .) . flip (.)
07:18:56 <ferret_0567> lispy: C
07:18:59 <lispy> ferret_0567: I don't recall seeing a (+=) function
07:19:07 <ferret_0567> lispy: I want to define it
07:19:19 <chessguy_work> @pl \r -> k (f r) r
07:19:20 <lambdabot> k =<< f
07:19:34 <daf> ferret_0567: functions in Haskell don't operate on variables, they act on values
07:19:37 <lispy> > let (+=) x y = x + y in 5 += 4
07:19:41 <lambdabot>   9
07:19:48 <ski_> > let x += y = logBase (sqrt y) x in 5 += 3
07:19:50 <lambdabot>   2.9299470414358546
07:19:51 <ferret_0567> daf: oh yeah, that's right
07:19:56 <daf> ferret_0567: you can't modify values, only create new ones
07:20:43 <ferret_0567> daf: so basically your telling me that += is useless?
07:20:51 <daf> it's meaningless
07:21:07 <ferret_0567> daf: or rather, (+=)
07:21:24 <ski_> @let x += y = logBase (sqrt y) x
07:21:27 <lambdabot>  Defined.
07:21:29 <ski_> @type (+=)
07:21:30 <lambdabot> forall a. (Floating a) => a -> a -> a
07:21:31 <lispy> if you wanted you could use an STRef or an IORef
07:21:42 <lispy> and then define += to work on those
07:21:48 <daf> that's true
07:21:48 <ski_> (or a lens)
07:22:14 <daf> but in most cases, you don't actually want +=
07:22:24 * lispy agrees with daf 
07:22:26 <daf> in most cases that you'd use += in an imperative language
07:22:55 <ferret_0567> I agree as well
07:23:07 <daf> everybody's happy
07:23:10 <drdozer> will ghc do sensible optimization things if you have (a,b,c) that you re-write to (a,b) to pass into a function?
07:23:13 <ski_> @where happy
07:23:14 <lambdabot> http://www.haskell.org/happy/
07:23:44 <drdozer> 'tuple prefixing' for want of a better word for it
07:26:20 <ksf> (,) is just a functor like every else, so yes.
07:26:31 <ksf> *other
07:26:34 <quicksilver> drdozer: The answer is probably no.
07:26:47 <quicksilver> drdozer: (a,b) is not an in-memory substructure of (a,b,c)
07:26:53 <quicksilver> although the 'a' and 'b' parts can be shared.
07:27:02 <quicksilver> I'm not sure what kind of 'sensible optimisations' you were thinking of.
07:27:12 <daf> that would be my guess
07:27:15 <Apocalisp> HList?
07:27:30 <sw17ch> can any one think of a way to document Haskell code with UML?
07:27:31 <drdozer> quicksilver: fine - I wasn't sure
07:27:35 <daf> I assume drdozer meant "avoid deconstructing and constructing"
07:27:46 <daf> it does seem unlikely
07:27:54 <quicksilver> GHC isn't very good at avoiding construction and deconstruction of tuples.
07:27:57 <drdozer> quicksilver: I was kind of assuming that (a,b,c) had the same 2 leading words that (a,b) does
07:28:17 <pejo> sw17ch, why?
07:28:24 <quicksilver> drdozer: (a,b,c) looks someting like "TAG for (,,); PTR to a; PTR to b; PTR to c;"
07:28:28 <sw17ch> manager trying to figure out what haskell does :)
07:28:31 <sw17ch> pejo: ^
07:28:43 <sw17ch> and i'm trying to think of a circumstance where UML would make sense to diagram haskell code
07:28:45 <sw17ch> and i can't think of any
07:28:45 <quicksilver> sw17ch: doesn't sound to hard.
07:28:58 <quicksilver> sw17ch: base the diagram around data types
07:29:07 <quicksilver> (where in C++ you'd be basing it around classes)
07:29:17 <drdozer> quicksilver: ah - ok - I was assuming that the tag got stripped out by the optimizer in some circumstances, leaving PTR to a; PTR to b; PTR to c
07:29:36 <sw17ch> quicksilver: yeah, but i keep thinking that the OO pressures of UML would give you certain impressions of the code that don't actually exist
07:29:43 <quicksilver> list functions which operate solely or primarily on one type inside the data type
07:30:00 <quicksilver> sw17ch: I doubt very much UML gives any such precise impressions to your manager :P
07:30:11 <sw17ch> quicksilver: you don't know my manager :)
07:30:14 <quicksilver> list functions which operate on two related types between them.
07:30:16 <quicksilver> etc.
07:30:28 <sw17ch> well, i'd have to give it a shot
07:30:29 <quicksilver> drdozer: yeah, the 'T' in 'STG' does stand for tagless, in fact.
07:30:36 <sw17ch> i guess i'm more wondering if any one has worked iwth UML and Haskell
07:30:38 <sw17ch> some how i doubt it ghouth
07:30:39 <sw17ch> though*
07:30:44 <quicksilver> drdozer: and now you're beyond my knowledges of GHC's implementation ;)
07:31:04 <drdozer> sw17ch: uml almost never (in my experience) gives any precise impression of *any* code - it is mainly a tool for keeping semi-cluefull management feeling involved with the sw design
07:31:26 <sw17ch> i'm more concerned about the method/public/private stuff... etc
07:31:30 <Apocalisp> Is there any graphical notation that would make sense for Haskell?
07:31:41 <sw17ch> and i don't see a good way of putting both typeclasses and data types into the diagram
07:31:41 <daf> I'm sure there is
07:31:48 <sw17ch> I think flow charts do
07:31:52 <Axman6> yeah
07:31:54 <loop> expression trees? =)
07:32:07 <sw17ch> process/io/decision
07:32:08 <drdozer> sw17ch: I recently read "model oriented design" - the kind of analysis in there (based around a fairly loose interpretation of UML) would work for haskell
07:32:12 <daf> I can believe that there are better notations that haven't been invented yet
07:32:26 <sw17ch> drdozer: link?
07:32:27 <drdozer> daf: that statement is axiomatically correct :D
07:32:33 <ski_> <http://homepages.mcs.vuw.ac.nz/~tk/fps/> "A Functional Pattern System for Object-Oriented Design" by Thomas Kühne might have some UML stuff (not sure)
07:32:41 <daf> drdozer: heh
07:32:43 <daf> drdozer: is it?
07:32:56 <daf> drdozer: couldn't it be true that the best notation has already been discovered?
07:33:07 <chrisdone> v
07:33:10 <pejo> drdozer, it sounds difficult for the garbage collector if there are no tags.
07:33:33 <quicksilver> UML gives a high-level overview of the components of a program
07:33:38 <quicksilver> I think it could still do that in Haskell
07:33:46 <quicksilver> (probably more than one possible concept mapping)
07:33:55 <quicksilver> sw17ch: good programs don't use typeclasses, so that's OK.
07:34:08 <sw17ch> quicksilver: yes, but i think you'd have to do a backfilp to make it all go together
07:34:41 <sw17ch> now, the larger question: is structure generation possible? UML -> Haskell Program Structure
07:34:55 <sw17ch> (i hate the idea, personally)
07:35:02 <drdozer> sw17ch: http://books.google.co.uk/books?id=7dlaMs0SECsC&dq=domain+driven+design&printsec=frontcover&source=bn&hl=en&ei=koeZSb_6HcmH-gbD-KSPCQ&sa=X&oi=book_result&resnum=4&ct=result
07:35:12 <daf> sw17ch: that implies that your manager would draw you a diagram
07:35:20 <daf> sw17ch: "I want it to look just like that!"
07:35:27 <sw17ch> daf: no, it's a different problem domain...
07:35:41 <daf> I don't follow
07:35:44 <drdozer> daf: any manager that says that deserves the useluess heap of non-functioning code-spageti he gets
07:36:05 <doserj> sw17ch: I wouldn't concentrate too much on the restrictions of the UML notations. If you want a diagram that represents certain relationships between certain haskell types, just draw some nice boxes and arrows between them.
07:36:14 * wjt throws his laptop against the wall
07:36:21 <sw17ch> requirements based software for safety critical aerospace application
07:36:22 <sw17ch> s
07:36:27 <drdozer> boxes and arrows are where it is at :D
07:36:30 <sw17ch> it's documentation to make the FAA happy
07:36:33 <Axman6> wjt: RRRRRAAAAAAAWWWWWWWWRRRRRRRRR!
07:36:50 <daf> wjt: all we need is a warehouse and large quantities of illegal substances
07:36:54 <chrisdone> quicksilver: good programs don't use typeclassesâ¢?
07:36:55 <ski_> drdozer : s/boxes/objects/, (and maybe s/arrows/morphisms/ if you prefer)
07:36:55 <Axman6> sw17ch: people worth making hapy i think
07:37:00 <sw17ch> quite
07:37:39 <ski_> commuting diagrams for management !
07:37:49 <wjt> daf: :D
07:37:52 <drdozer> ski_: something like that :D UML is horribly tied to the java/c++ view of single-type dispatch
07:38:27 <sw17ch> doserj: that was my thoguht. uml is pretty tightly tied to OO models
07:38:51 <pejo> sw17ch, aren't there real time constraints on safety critical things typically?
07:39:34 <sw17ch> pejo: yeah, but this is way off in a corner
07:39:37 <drdozer> some of the boys upstairs here do safety-critical, real-time code - tend to provide proofs, towers of commuting diagrams, that sort of thing, rather than UML
07:39:49 * sw17ch looks up commuting diagrams
07:40:02 <pejo> drdozer, 'here'?
07:40:19 <drdozer> pejo: the cs department of Newcastle University (UK)
07:40:37 * ferret_0567 hates that Vim uses tabs even when using the Haskell syntax file
07:41:07 <paper_cc> ferret_0567: it is changeable
07:41:09 <osfameron> ferret_0567: set it in your filetype.vim to expandTab
07:41:09 <daf> ferret_0567: autocmd FileType haskell setl tw=78 ts=4 sts=4 sw=4 et
07:41:26 <sw17ch> :help sts
07:41:27 <osfameron> heh a chorus of vim
07:41:30 <daf> ferret_0567: s/4/2/g if you prefer
07:45:33 <Axman6> :t const undefined
07:45:34 <lambdabot> forall a b. b -> a
07:45:49 <HugoDaniel> i want to execute a function for each element of a list, how do i do it ?
07:45:55 <HugoDaniel> the function outputs IO()
07:46:19 <rwbarton> :t mapM_
07:46:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:46:56 <HugoDaniel> sweet
07:47:03 <ski_> @type forM_
07:47:03 <HugoDaniel> thanks
07:47:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
07:47:18 <paper_cc> @src forM_
07:47:18 <ski_>   forM_ list $ \element -> do
07:47:18 <lambdabot> forM_ = flip mapM_
07:47:23 <ski_>     do stuff to element
07:47:33 <quicksilver> chrisdone: actually using typeclasses is fine. It's defining your own as part of a problem domain modelling exercise that is suspect.
07:47:48 <HugoDaniel> my list is like [(a,b)], and my function is like f :: a -> b -> IO(), how do i apply it ?
07:48:00 <HugoDaniel> i can think of a way, but its is a bit awkward :S
07:48:03 <quicksilver> chrisdone: if you're doing a java/UML style problem modelling exercise, you should design (in haskell) datatypes and functions, not typeclasses.
07:48:11 <paper_cc> @t uncurry
07:48:11 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:48:12 <ski_>   mapM_ (uncurry f) list
07:48:18 <paper_cc> :t uncurry
07:48:19 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:48:21 <quicksilver> HugoDaniel: forM_ list $ \(a,b) -> f a b
07:48:35 <HugoDaniel> hmm nice :D
07:48:37 <quicksilver> HugoDaniel: (ski's way works too, obviously, but maybe my way generalises more obviously)
07:48:39 <HugoDaniel> the pattern matching really rulz
07:48:53 <lilac> ski_: (sorry, was away) right, i meant 'newtype Cont a = forall b. Cont ((a -> b) -> b)'
07:48:58 <drdozer> quicksilver: my question about tuple optimizing is now rendered moot - to fit with legacy code, I don't get much choice about how the tuples are nested :D
07:49:15 <ski_> @arr
07:49:15 <lambdabot> Keelhaul the swabs!
07:49:16 <quicksilver> I find the pattern "forM_ list_of_tuples $ \(a,b,c) -> .... do stuff with a b and c ..." quite common in my programs
07:49:33 <quicksilver> drdozer: ah well, maybe it was premature optimization anyway.
07:49:42 <lilac> ski_: point being, that kinda gives you non-delimited continuations, but there's nothing you can do with them
07:50:04 <ski_> lilac : well, you can invoke them !
07:50:19 <HugoDaniel> forM_ is a nice name ahah :D
07:50:28 <HugoDaniel> it destroys the imperative "for" concept
07:50:48 <quicksilver> HugoDaniel: it's just sometimes more convenient to have the list first, before the action
07:50:52 <ski_> - Cont.callcc;
07:50:52 <ski_> val it = fn : ('a ?.cont -> 'a) -> 'a
07:50:54 <quicksilver> especially if the action is multiple lines of code
07:50:59 <paper_cc> HugoDaniel: why? it's simply imperative foreach
07:51:04 <quicksilver> forM_ list $ do .... several lines of code ...
07:51:16 <quicksilver> paper_cc: it's a bit cleverer than imperative. It's monadic.
07:51:29 <paper_cc> quicksilver: well, in IO =)
07:51:40 <quicksilver> yes, but forM_ isn't always in IO.
07:51:44 <quicksilver> that's why it's clever :)
07:52:00 <lilac> ski_: how? if you have 'let Cont f = my_cont in ...' then f :: exists b. (a -> b) -> b, so you'd need to provide a function g :: forall b. a -> b to give to f...
07:52:44 <HugoDaniel> hmm forM_ is like fmap shaped into a for, right ?
07:52:49 <HugoDaniel> thats why i said that
07:52:53 <HugoDaniel> but im not so sure
07:53:02 <paper_cc> @ty for
07:53:04 <lambdabot> Not in scope: `for'
07:53:14 <paper_cc> @ty fmap
07:53:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:53:18 <Saizan> ?src forM
07:53:19 <lambdabot> forM = flip mapM
07:53:23 <Saizan> ?src mapM
07:53:24 <lambdabot> mapM f as = sequence (map f as)
07:53:33 <paper_cc> @ty sequence . fmap
07:53:35 <lambdabot>     Couldn't match expected type `[m a]'
07:53:35 <lambdabot>            against inferred type `f a1 -> f b'
07:53:35 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
07:53:44 <ski_> lilac : probably we're talking about different things, atm
07:53:44 <paper_cc> @ty (sequence .) . fmap)
07:53:46 <lambdabot> parse error on input `)'
07:53:49 <pilkarn> how do I patternmatch against a list with 1 elem?
07:53:54 <paper_cc> @ty (sequence .) . fmap
07:53:56 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
07:54:14 <Axman6> pilkarn: [x]
07:54:17 <paper_cc> HugoDaniel: ^^ that's the relation with fmap
07:54:25 <ski_> (since i don't see where that `exists b. (a -> b) -> b' comes from .. except maybe your strange `Cont' definition attempt above)
07:54:45 <ski_> > (\[x] -> x) "a"
07:54:47 <lambdabot>   'a'
07:54:59 <ski_> @src mapM
07:54:59 <lambdabot> mapM f as = sequence (map f as)
07:55:09 * ski_ nods slowly
07:55:52 <HugoDaniel> paper_cc: ouch, i which i could have seen that :S
07:56:17 <HugoDaniel> ((sequence .) . fmap ) is quite ninja
07:56:25 <Thunder> @pl let mapM f as = sequence (map f as) in mapM
07:56:25 <lambdabot> (sequence .) . map
07:56:27 <quicksilver> well it looks funny like that, yes
07:56:38 <quicksilver> but if you see it as " mapM f as = sequence (fmap f as)"
07:56:44 <quicksilver> then that's more manageable
07:56:44 <lispy> .). always looks funny to me
07:56:49 <quicksilver> but just notice that's the "list fmap"
07:56:53 <quicksilver> not the fmap of your monad
07:57:10 <quicksilver> (so in particular, fmap for lists is map, which is how the normal definition is written)
07:58:11 * paper_cc is wondering if sequence can be defined on any foldable structure, not just on [a]
07:58:20 <pilkarn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1439#a1439 <- naive mergesort, can I improve it? (length is O(n) whic is obv bad, how can I avoid using it?)
07:59:21 <Saizan> ?type Data.Traversable.Sequence
07:59:21 <MyCatVerbs> paper_cc: genericSequence = sequence . Data.Foldable.foldr (:) []
07:59:22 <ski_> @type Data.Traversable.sequenceA
07:59:23 <lambdabot>     Not in scope: data constructor `Data.Traversable.Sequence'
07:59:24 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Traversable.Traversable t) => t (f a) -> f (t a)
07:59:29 <HugoDaniel> "Error in my_thread_global_end(): 2 threads didn't exit"  -> something tells me that things didn't quite go as aspected :P
07:59:37 <lispy> pilkarn: you could pass in the length of the list, and then write a wrapper around your code to pass in the original list length without the user knowing about it
08:00:07 <paper_cc> @src Data.Traversable.Traversable
08:00:07 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:00:15 <lispy> sort xs = mysort xs (length xs)
08:00:24 <pilkarn> talking to me?
08:00:25 <paper_cc> , src ''Data.Traversable.Traversable
08:00:28 <Saizan> or use a bottom-up mergesort?
08:00:30 <lispy> pilkarn: ya
08:00:30 <lunabot>  luna: Not in scope:
08:00:41 <Ogedei> is there a deep reason why n-tuple types couldn't be recursive, as in 'data Tuple a b = Tuple a b', with (,) being a regular right-associative operator, and (1, 2, 3) being equivalent to Tuple 1 (Tuple 2 3)?
08:00:44 <MyCatVerbs> paper_cc: heck, Data.Foldable defines sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f (). Applicative is a strictly "smaller" typeclass than Monad, in the sense that all Monads also have an Applicative instance.
08:00:56 <lispy> pilkarn: and if you defined mysort in a where block then only sort can call it, making it safe to do so
08:00:57 <MyCatVerbs> Ogedei: yes. I've whined about the same thing myself. :)
08:01:16 <pilkarn> lispy: you mean taking the length the fist time then decreasing it each step
08:01:23 <lispy> pilkarn: correct
08:01:24 <Ogedei> MyCatVerbs: so yes, there *is* a deep reason? (what is it?)
08:01:24 <Cheshire> Ogedei, you can already write (1, (2, (3, ())))
08:01:33 <paper_cc> MyCatVerbs: though you can have sequence on Applicative all right
08:01:35 <lispy> pilkarn: that's what you'd do in the imperative version, right?
08:01:45 <MyCatVerbs> Ogedei: the problem is that (a,b,c) and (a,(b,c)) have different sets of possible values.
08:02:29 <MyCatVerbs> Ogedei: (a,b,c) can be _|_ or (a,b,c). (a,(b,c)) can be _|_, (a,_|_), or (a,(b,c)). Laziness is sometimes a hair shirt. :)
08:02:32 <HugoDaniel> :D
08:02:33 <Ogedei> MyCatVerbs: yes, but they could harmlessly be 'defined' to be the same, if one was in the position to make up a new set of semantics for a language
08:02:48 <Saizan> Ogedei: you can define data Tuple a b = Tuple a !b and have them be isomorphic, but nested tuples won't give you O(1) random access
08:02:49 <Ogedei> MyCatVerbs: ah yes, laziness :P
08:03:08 <HugoDaniel> haskell is like the clint eastwood of programming languages... lean and mean
08:03:26 <chessguy> Saizan, i don't think anyone's askign for O(1) access, just heterogeous...ness. if that's a word.
08:03:27 <MyCatVerbs> Ogedei: again, same thought. Downside is it'd complicate things a little. But yes. Haskell is imperfect, and this is one of the ugly corner cases.
08:03:31 <Saizan> unless you require compilers to optimize the indirections when possible
08:03:36 <chessguy> heterogeneity?
08:03:39 <Ogedei> Saizan: good point. though I guess the compiler could cheat
08:04:03 * paper_cc tries to invent a name for a function with signature "a -> Vector3 a a a"
08:04:12 <Cheshire> triplicate
08:04:15 <chessguy> return'
08:04:26 <daf> Vector3
08:04:32 <MyCatVerbs> paper_cc: untoVector.
08:04:53 <paper_cc> Cheshire: well, actually it's (Vector v) => a -> v a
08:04:54 <MyCatVerbs> paper_cc: ...embiggen! :)
08:04:58 <chessguy> paper_cc, actually, you probably want an instance of some typeclass, in which case the name is already chosen for you
08:05:00 <lupsyn> hi all
08:05:09 <Cheshire> paper_cc, why didyo usay  a -> Vector3 a a a  then :p
08:05:17 <ferret_0567> how can I make sure that when a function starts out (i.e. it has a recursion level of 0) it gets a variable with a value of 0?
08:05:29 <chessguy> paper_cc, e.g., Pointed
08:05:38 <daf> ferret_0567: use a nested function
08:05:40 <paper_cc> Cheshire: I put laziness in my keyboard =)
08:05:43 <opqdonut> ferret_0567: you so something like: f x = f' x 0 where f' ....
08:05:47 <daf> f a = go 0 a
08:05:51 <paper_cc> chessguy: what's Pointed?
08:05:56 <daf>     where go n a = ...
08:05:57 <ferret_0567> daf: I am doing that
08:06:03 <ski_> paper_cc : are you having a prefered coordinate system ?
08:06:04 <lupsyn> i have the same problem : http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/1ea1927df5f2b58b
08:06:10 <lupsyn> can someone help me ?
08:06:29 <chessguy> paper_cc, http://www.cis.upenn.edu/~byorgey/papers/typeclassopedia-draft-090216.pdf
08:06:32 <lupsyn> i thought an evolution of
08:06:32 <lupsyn> Main> foldrq (\x y z q-> x+y+z+q) (\x-> if x== 0 then 1 else 0) q2 but obiuvlsy it's not correct
08:06:33 <MyCatVerbs> lupsyn: no, all our keyboards just wore out simultaneously. I'm having to type with my nose. ;)
08:07:19 <paper_cc> ski_: well, my vectors are just a representation of GPU registers, so I don't even have a notion of coordinate systems
08:07:32 <paper_cc> @index Pointed
08:07:33 <lambdabot> bzzt
08:07:55 <chessguy> paper_cc, it's defined in category-extras
08:08:11 <chessguy> class Functor f => Pointed f where pure :: a -> f a
08:08:32 <paper_cc> pure is a somewhat overused name :(
08:08:35 <ferret_0567> > recurse x = if x == 10 then x else recurse x+1
08:08:37 <lambdabot>   <no location info>: parse error on input `='
08:08:49 <ferret_0567> > recurse x = if x == 10 then x else recurse x+1; recurse 0
08:08:51 <lambdabot>   <no location info>: parse error on input `='
08:08:55 <doserj> paper_cc: diagonal? or diag?
08:09:11 <chessguy> > let recurse x = if x == 10 then x else recurse x + 1 in recurse 0
08:09:14 <lambdabot>   * Exception: stack overflow
08:09:14 <ferret_0567> oh
08:09:22 <ferret_0567> why does it overflow?
08:09:34 <doserj> > let recurse x = if x == 10 then x else recurse (x + 1) in recurse 0
08:09:35 <lambdabot>   10
08:09:38 <Thunder> Integer is not bounded
08:10:01 <chessguy> ooh, nasty bug
08:10:11 <ferret_0567> oh, you use the in keyword to give x a initial argument?
08:10:15 <pilkarn> splitAt is O(n/2) ?
08:10:15 <pilkarn> wait
08:10:15 <pilkarn> O(n-m)?
08:10:15 <pilkarn> or how do you say? O(n)?
08:10:16 <gnomnain> is there a function to change the n-th element of a list ? I can't find one
08:10:22 <opqdonut> no
08:10:30 <opqdonut> implementing one is easy tho
08:10:36 <quicksilver> gnomnain: well there are no functions to change anything; lists are immutable.
08:10:36 <MyCatVerbs> ferret_0567: the in keyword is there to seperate the definitions from the expression in a let expression.
08:10:40 <opqdonut> the real question is whether you should be using a list?
08:10:54 <quicksilver> gnomnain: but you can make a new list based on the old with one element different.
08:11:13 <skorpan> "Hughes and Swierstra (2003) show that the sequencing operator must be applicative (McBride and Paterson (2007)) to allow for online production of results." what does "applicative" mean here?
08:11:45 <quicksilver> skorpan: they mean that monad is too strong a constraint, I think.
08:11:57 <quicksilver> I'm not sure.
08:11:58 <chessguy> @type change n f xs = drop 2 xs ++ [f (xs !! n)]  ++ drop (n+1) xs
08:12:00 <lambdabot> parse error on input `='
08:12:06 <MyCatVerbs> ferret_0567: let { foo = "Hello, "; bar = "world!\n" } in { foo ++ bar } -- the curly braces and the semicolons are normally worked out from indentation, but spelling them out explicitly sometimes makes things more readable.
08:12:11 <chessguy> @type let change n f xs = drop 2 xs ++ [f (xs !! n)]  ++ drop (n+1) xs in change
08:12:13 <lambdabot> forall a. Int -> (a -> a) -> [a] -> [a]
08:12:17 <skorpan> oh, that it should be an instance of Applicative?
08:14:10 <paper_cc> can I declare a type synonym inside a typeclass to make signatures more readable?
08:14:33 <ski_> with type families, you can
08:14:34 <opqdonut> unfortunately not
08:14:40 <opqdonut> yeah, type families
08:14:49 <opqdonut> but they're quite a bit more powerful :)
08:14:59 <pilkarn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1439#a1440
08:15:19 <paper_cc> ski_: opqdonut: the problem is that I'm trying to avoid TypeFamilies while I can stick with FunctionalDependencies
08:15:32 <chessguy> @instances-importing Applicative
08:15:32 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
08:15:34 <pilkarn> can it be bettered again?
08:15:48 <chessguy> @instances Control.Applicative.Applicative
08:15:49 <lambdabot> ((,) a), ((->) a), IO, Maybe, []
08:16:12 <chessguy> @hoogle StateR
08:16:13 <lambdabot> No results found
08:16:38 <chessguy> what's up with the StateL/StateR instances of Applicative at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#3
08:16:59 <pilkarn> oh wait it is incorrect
08:17:03 * paper_cc has a binary assembly operation represented as (Program p c m, Arithmetic p v, Operand p v a, Operand p v b) => a -> b -> m (c v)
08:17:11 <paper_cc> am I on the completely wrong way?
08:17:13 <Cheshire> yukc
08:17:15 <Cheshire> that is horrible
08:17:32 <andre> @src permutations
08:17:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:17:41 <andre> @src permutations
08:17:42 <lambdabot> Source not found. stty: unknown mode: doofus
08:17:48 <Guest62843> @src permutations
08:17:49 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:17:55 <MyCatVerbs> paper_cc: you... might want to tone down the polymorphism there, just a little. :)
08:19:05 <paper_cc> MyCatVerbs: I'm trying, well, to represent NV_vertex_program4 and ARB_fragment_program in a similar way. Actually, it's an add operation inside an Arithmetic class
08:19:23 <andrela> > permutations [1..3]
08:19:25 <lambdabot>   Not in scope: `permutations'
08:19:44 <paper_cc> andrela: \bot doesn't have base-4.0.0.0 :P
08:19:49 <Cheshire> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
08:19:58 <paper_cc> , permutations [1..3]
08:19:59 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
08:20:07 <chessguy> Cheshire does have base-4 though :)
08:20:14 <paper_cc> as well as luna
08:20:16 <MyCatVerbs> paper_cc: Ah. What about defining a datatype that represents programs in either, then build functions to compile it to usable output?
08:20:44 <MyCatVerbs> paper_cc: your approach isn't necessarily wrong or anything, but your types are likely to get quite long quite quickly.
08:21:13 <ferret_0567> how do I use go?
08:21:15 <ferret_0567> @src go
08:21:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:21:20 <ferret_0567> lol
08:21:42 <chessguy> ferret_0567 go?
08:21:57 <pilkarn> is odd O(n) or O(1)? what si the diff between rem and mod?
08:22:10 <chessguy> @src odd
08:22:10 <lambdabot> odd = not . even
08:22:16 <Cheshire> @src even
08:22:16 <chessguy> @src even
08:22:16 <lambdabot> even n = n `rem` 2 == 0
08:22:16 <lambdabot> even n = n `rem` 2 == 0
08:22:27 <rwbarton> paper_cc: you'll never be able to call that function unless there is a functional dependency determining p
08:22:27 <chessguy> @src rem
08:22:28 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:22:33 * chessguy blinks
08:22:38 <MyCatVerbs> pilkarn: most of the numerical operations are O(1), unless explicitly noted not to be.
08:22:43 <rwbarton> , src 'rem
08:22:46 <lunabot>  Class op from Integral: rem :: forall a . Integral a => a -> a -> a
08:22:46 <lunabot>                          infixl 7 rem
08:22:50 <paper_cc> rwbarton: I have | p -> c
08:22:57 <paper_cc> and p -> m
08:23:08 <pilkarn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1439#a1442
08:23:30 <paper_cc> rwbarton: because one type of programs obviously needs one Expr and one BuilderState type
08:23:36 <rwbarton> paper_cc: but p isn't reachable from a -> b -> m (c v); there could be other instances Program p' c m, etc., and then which should be used?
08:23:38 <ferret_0567> chessguy: oh, nvm
08:25:33 <paper_cc> rwbarton: you're right :(
08:26:23 <MyCatVerbs> pilkarn: that looks sane enough. If you want a really fast merge sort, see the source code for Data.List (though that one is pretty complicated and abuses a lot of GHC's evil features for speed). You can find a slightly outdated version of it at http://www.haskell.org/ghc/docs/6.8.2/html/libraries/base/src/Data-List.html
08:26:31 <paper_cc> rwbarton: thanks =)
08:27:27 <MyCatVerbs> pilkarn: but when you calculate odd or even on an Int, all the machine needs to do is test the least significant bit of a machine integer.
08:31:55 <pilkarn> MyCatVerbs: thanks
08:32:19 <pilkarn> do you mean Int is faster than Integer?
08:33:08 <MyCatVerbs> pilkarn: yes. Ints overflow. Integers are implemented using libGMP - they can be arbitrarily long, and they grow when they get larger.
08:33:30 <Axman6> > 1234 ^ 10252 :: Int
08:33:32 <lambdabot>   0
08:33:36 <Axman6> > 1234 ^ 10252 :: Integer
08:33:38 <lambdabot>   145551677778466900933808261621316220374416091228648155785079245534797797611...
08:34:14 <MyCatVerbs> pilkarn: but Integers are pretty fast anyway. Unless your program is too slow, you usually want to use Integers over Ints in most places because then you never have to worry about overflow bugs. ^_^
08:35:26 <CTA> Hey
08:35:34 <ferret_0567> this nested function crap is BS
08:36:06 <ferret_0567> I want to set a value to 0 only on the first time a function is ran, before it starts to recurse
08:36:10 <ferret_0567> how would I do that?
08:36:41 <Axman6> > let mean xs = n / fromIntegral d where (n,d) = foldl' (\(acc, num) x -> (acc + x, num + 1)) ((0,0) :: Num a => (a,Int64)) xs in mean [1..1000000] :: Double
08:36:44 <MyCatVerbs> ferret_0567: give it 0 as an argument when you call it.
08:36:45 <lambdabot>   * Exception: stack overflow
08:36:57 <Axman6> lame :(
08:37:17 <ferret_0567> MyCatVerbs: that sucks!
08:37:44 <ferret_0567> @type length
08:37:46 <lambdabot> forall a. [a] -> Int
08:37:55 <ferret_0567> length doesn't suck like that...
08:38:11 <MyCatVerbs> @src length
08:38:12 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:38:13 <ski_> ferret_0567 : `foo x = bar 0 x where bar i x = ...'
08:38:21 <CTA> is there a compiler for haskell? not ghci?
08:38:27 <ski_> ghc
08:38:29 <ski_> hbc
08:38:31 <ski_> nhc
08:38:33 <ski_> jhc
08:38:34 <CTA> kk where i get that?
08:38:35 <ski_> yhc
08:38:36 <MyCatVerbs> lhc!
08:38:46 <z0d> thc
08:38:49 <MyCatVerbs> CTA: if you have ghci, you also have ghc. ghci is part of ghc. :)
08:39:08 <CTA> ahh
08:39:26 <Axman6> ghci _is_ ghc
08:39:28 <Axman6> it's ghc -i
08:39:37 <MyCatVerbs> CTA: to compile something with GHC, you need a module Main containing  main :: IO (). Then do ghc --make Main.hs, and it'll build and link an executable called Main. ^_^
08:39:47 <CTA> if i use GHC do i have to do Module Main Where -- or something?
08:40:04 <MyCatVerbs> CTA: yes. "module Main where" is the incantation you're after. :)
08:40:18 * wli uses ghc -main-is Foo.main rather often.
08:40:34 <CTA> i've just been typing straight into ghci -- let main = putStrLn "blah" .. main lol
08:40:42 <MyCatVerbs> CTA: if you don't like calling your main module "Main" all the time (I don't ^_^), you can call ghc with -main-is Foo.main, in order to use the "main" from module "Foo".
08:41:13 <wli> Or even ghc -main-is Foo.driver --make Foo.hs -o ./foo
08:41:34 <fasta> How come only 3 persons are interested in this?  http://hackage.haskell.org/trac/ghc/ticket/1409
08:42:02 <fasta> Add your email address so that hopefully it will be fixed soon.
08:42:04 <MyCatVerbs> Which comes in kinda handy when you want to do, ghc -main-is Foo.unit_test --make Foo.hs -o Foo_unit_test # :)
08:42:13 <Axman6> Milestone: _|_ heh
08:42:18 <quicksilver> fasta: recursive modules are stupid and no one needs them.
08:42:57 <Cheshire> quicksilver, a lot of people /use/ them -- I never could understand why though
08:43:05 <Cheshire> e.g. GHC
08:43:16 <CTA> I prefer != to /=
08:43:20 <MyCatVerbs> fasta: recursive modules aren't necessary unless you have circular dependencies. Almost invariably a circular dependency is a sign that you're attempting to seperate two things that're actually inseperable.
08:43:22 <fasta> quicksilver: and what if functionality A and B are such that A really depends on B and B really depends on A, but there is only a dependency for one function between them?
08:43:28 <CTA> (i know /= looks like mathematical symbol)
08:43:34 <Cheshire> CTA, no it doesn't
08:43:36 <Axman6> CTA: /= -> â 
08:43:38 <quicksilver> fasta: never happens. doesn't exist. you're describing a unicorn.
08:43:39 <Cheshire> > let (!=) = (/=) in 3 != 4
08:43:40 <lambdabot>   True
08:43:47 <quicksilver> I should apologise, I'm being flippant.
08:43:51 <Cheshire> CTA, ^ here is the good thing about using a _programming_ language
08:43:59 <quicksilver> but it really does seem to be a rare thing in practise
08:44:01 <MyCatVerbs> CTA: surprisingly enough, Haskell's syntax lets you get away with that. You can define (!=) = (/=), and then give a fixity for it.
08:44:02 <quicksilver> and it's so easy to solve
08:44:11 * wli may, at times, just want to avoid huge module files.
08:44:12 <quicksilver> just make them a single module
08:44:14 <fasta> quicksilver: I could pass an extra function to break the chain.
08:44:22 <quicksilver> or make some critical section a single module
08:44:25 <quicksilver> (which they both import)
08:44:27 <CTA> yeah Axman that's what I was referring to
08:44:33 <fasta> quicksilver: the idea is not to have 10000 lines in a source file.
08:44:36 <wli> In that case the mutually recursive modules make sense.
08:45:01 <Axman6> CTA: if you don't like it, just add (!=) = (/=) to evert file you use
08:45:05 <Axman6> every*
08:45:15 <MyCatVerbs> fasta: what if the problem you're attacking really is just that big?
08:45:29 <fasta> MyCatVerbs: with recursive modules, there would be no problem.
08:45:44 <CTA> I'll just use it, mays well get used to it
08:46:18 <MyCatVerbs> CTA: if you think that's fun, try Prolog. ;)
08:46:23 <fasta> There have been times were I could get away without using recursive modules, but here is is simply inherent to the problem (unless I do a hack like passing functions).
08:46:45 <quicksilver> fasta: it just appears to be such a rare problem that it doesn't rise the top of anyone's priority list.
08:46:58 <MyCatVerbs> fasta: why not pass functions? HOFs are a pretty good way of decomposing many problems.
08:47:05 <quicksilver> and it is presumably relatively substantial amount of work (to do the solution as outlined by Isaac)
08:47:07 <Cheshire> my guess is:  everyone wants rid of recursive modules but uses them anyway
08:47:08 <CTA> Prolog?
08:47:21 <ski_> yes
08:47:22 <Cheshire> Prolog uses \=
08:47:27 <Cheshire> C uses !=
08:47:29 <Cheshire> Haskell uses /=
08:47:35 <ski_> <>
08:47:38 <ski_> .ne.
08:47:39 <Cheshire> Coq uses <>
08:47:42 <MyCatVerbs> CTA: Prolog uses = for unification (not really the same as equality, but whatever) and \= for inequality.
08:47:44 <ski_> bne
08:47:46 <Cheshire> I don't know where .ne. is from
08:47:49 <fasta> Cheshire: that was my guess too, but if nobody puts their name on the list, nothing will happen for sure.
08:47:57 <Axman6> <> is fairly common actually
08:48:04 <ski_> (Cheshire : might be FORTRAN, iirc ..)
08:48:05 <Axman6> can't remember where i've seen it
08:48:34 <CTA> can't you define your own ops in haskell?
08:48:39 <MyCatVerbs> Lots of chips have assembly mnemonics of the form Branch-Not-Equal-to-Zero.
08:48:41 <Cheshire> CTA, I just showed you how a moment ago
08:48:46 <Axman6> CTA: huh?
08:48:51 <ski_> MyCatVerbs : i'd say `=' in prolog is equality ..
08:49:01 <Axman6> 'ops'? what's that? you mean functions?
08:49:07 <Cheshire> X = X. % this is the definition
08:49:09 <MyCatVerbs> CTA: you can, yes. Just define them like you would any other function.
08:49:21 <chessguy> what's up with the StateL/StateR instances of Applicative at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#3
08:49:40 <drhodes> :t (!=)
08:49:42 <lambdabot> Not in scope: `!='
08:49:54 <drhodes> @let (!=) = (/=)
08:49:58 <lambdabot>  Defined.
08:49:59 <MyCatVerbs> ski_: no, it's unification. Equality is merely a special case of unification, where there are not allowed to be unbound variables in any of the parts of the terms that are examined. :)
08:50:06 <drhodes> > 4 != 5
08:50:06 <silkarn> how do I hide a function form being exported?
08:50:08 <lambdabot>   True
08:50:29 <ferret_0567> this does not work:
08:50:29 <MyCatVerbs> silkarn: give an explicit export list in the module declaration.
08:50:30 <ferret_0567> length' (xs:x) = l 0 (xs:x) where l i (xs:x) = if x /= [] then let i = i + 1 else l i
08:50:31 <ski_> MyCatVerbs : semantically, `=' is equality. unification is the name for the operational way of implementing it
08:50:37 <Cheshire> MyCatVerbs, it's more philosophical than technical -- how do you view (=)/2
08:50:44 <paper_cc> silkarn: well, the only way is to define all other functions to be exported in the module declaration
08:50:45 <mm_freak> in untyped lambda calculus, if you write "f x y", and y is some diverging statement (i.e. bottom), but f ignores its second argument and converges, how is this handled?
08:50:54 <mm_freak> is lambda calculus lazy in this sense?
08:50:58 <ski_> (MyCatVerbs : and yes i know about (==)/2 in prolog)
08:51:00 <Cheshire> mm_freak, which evaluation strategy do you use
08:51:01 <MyCatVerbs> silkarn: module Foo (bar, baz, qux) where -- unfortunately there's no nice way to say "export everything but xyzzy", but oh well.
08:51:03 <quicksilver> Cheshire: I've never used one. But anecdotes aren't that useful.
08:51:06 <ferret_0567> > let length' (xs:x) = l 0 (xs:x) where l i (xs:x) = if x /= [] then let i = i + 1 else l i ; length' [1,2,3]
08:51:07 <lambdabot>   <no location info>: parse error on input `else'
08:51:14 <mm_freak> Cheshire: none, it's abstract lambda calculus
08:51:17 <Axman6> silkarn: module Mod (exported, functions, And, DataTypes, And', DataTypesWithconstructors(..)) where
08:51:32 <silkarn> how?
08:51:34 <Cheshire> quicksilver, but I mean most large haskell programs we have in the wild are using them
08:51:35 <Axman6> ferret_0567: xs:x?
08:51:39 <ehird> :t readS
08:51:41 <silkarn> export (merge, mergesort) doesnt work
08:51:41 <lambdabot> Not in scope: `readS'
08:51:43 <Cheshire> mm_freak, then there is no reduction
08:51:45 <quicksilver> Cheshire: is that true? I doubt that claim.
08:51:50 <Axman6> that's highly irregular
08:51:52 <MyCatVerbs> ski_: really? I don't. I've never made use of it. Why would I want to test equality when I could use a strictly-more-powerful unification operator instead? ;)
08:52:04 <ferret_0567> Axman6: yeah, so that I can check if x is the end of the list or not
08:52:05 <Cheshire> quicksilver, I can't think of more than GHC and Agda 2 at the moment
08:52:11 <CTA> what's haskell used for most? commercially, like games, antivirus..?
08:52:14 <mm_freak> Cheshire: i don't know which strategy beta-reduction uses
08:52:14 <Cheshire> I'm sure there are though..
08:52:15 <ferret_0567> Axman6: why is my way so bad?
08:52:22 <MyCatVerbs> silkarn: you put the list of things that you want to export in parentheses after the module name.
08:52:24 <mm_freak> in particular, whether it's lazy in this sense
08:52:34 <ski_> MyCatVerbs : you're claiming you don't know how (==)/2 operates in prolog ?
08:52:37 <Eridius> ferret_0567: because (xs:x) doesn't make x == the end of the list
08:52:42 <Cheshire> mm_freak, the point is that if you don't specify an evaluation strategy you ... can't say what the value of a term is..
08:52:46 <ferret_0567> Eridius: oh wait, yet
08:52:47 <silkarn> module MergeSort(merge, mergesort) where
08:52:47 <ferret_0567> yeah*
08:52:49 <Axman6> ferret_0567: well, the convention is x:xs, where you have an x, and a list of xs (an ex and a list of exes)
08:52:55 <silkarn>  but i cant still call sort_aux from the repl
08:53:14 <MyCatVerbs> silkarn: like, if I have a module Foo which needs to export bar and baz, but not qux, then I write module Foo (bar, baz) where...
08:53:16 <ferret_0567> Axman6: ok, I changed it around
08:53:18 <mm_freak> Cheshire: the "evaluation strategy" is beta-reduction
08:53:26 <Cheshire> mm_freak, wrong..
08:53:29 <silkarn> ah when i import from other file it is as it should
08:53:35 <Cheshire> I don't think you followed what I said
08:53:35 <ferret_0567> Axman6: it still does not work. How can I make it work?
08:53:50 <MyCatVerbs> silkarn: ah. If you load Foo.hs in the REPL by doing "ghci Foo.hs" then you're given access to *everything* in Foo.hs rather than only the stuff that's exported. It makes debugging less painful.
08:54:03 <Eridius> ferret_0567: your code isn't even syntactically valid
08:54:09 <mm_freak> Cheshire: i'm talking about abstract lambda calculus, not some concrete programming language
08:54:11 <ferret_0567> Eridius: why not?
08:54:16 <Axman6> ferret_0567: i noticed you're using let i = i + 1 in there... thats'a bad idea. the i on both sides of the = are the same i. that will cause an infinite loop
08:54:25 <MyCatVerbs> ski_: ...yes.
08:54:31 <mm_freak> Cheshire: and the way to "evaluate" a lambda expression is beta-reduction
08:54:33 <Eridius> ferret_0567: "let i = i + 1" is not a full statement
08:54:33 <doserj> chessguy: StateL and StateR are from Data.Traversable.  they are State Transformers, threading the state from left to right, or right to left, resp.
08:54:37 <Cheshire> mm_freak, no
08:54:37 <ferret_0567> Axman6: then use i = (i + 1)
08:54:42 <Axman6> > let i = i+1 in i :: Int8
08:54:45 <tehgeekmeister> my install of cabal isn't doing anything involving the hackage servers; all commands that involve it (update, installing a package i haven't downloaded yet) just exit immediately.  any idea what could cause this?
08:54:50 <rwbarton> mm_freak: there may be many beta reductions you can apply to an expression, which one do you pick to do first?
08:54:58 <lambdabot>   thread killed
08:55:00 <Axman6> ferret_0567: they're still the same i, it's a recursive definition
08:55:21 <dcoutts_> tehgeekmeister: does -v shed any light on the situation?
08:55:28 <ferret_0567> Eridius: then how do I make it valid?
08:55:34 <chessguy> doserj, as in StateT or do you mean Transformers in a less technical sense
08:55:38 <ziman> byorgey_, there's a little typo in the Typeclassopedia draft on page 40: "Uutsalu"
08:55:39 <mm_freak> rwbarton: i didn't know thatâ¦  i always thought that beta-reduction removes one layer of lambda abstraction at each step
08:55:46 <CTA> let a = putStrLn ""              ... what's that doing? creating a function named a?
08:55:47 <Eridius> ferret_0567: I'm not going to hand you code. You really should sit and figure out for yourself why your code is invalid
08:55:50 <Eridius> that will teach you so much more
08:55:55 <ferret_0567> alright
08:55:59 <mm_freak> given that i would _expect_ it to converge
08:56:03 <mm_freak> but i don't know
08:56:10 <ski_> MyCatVerbs : ok. so why don't you like calling (=)/2 "equality" ?
08:56:19 <doserj> chessguy: as in State Monad (not Monad Transformer)
08:56:22 <Axman6> CTA: yep
08:56:31 <Cheshire> mm_freak: dunno how to put it more clearly -- it converges if you define evaluation order to be lazy, it diverges if you use strict evalutaion
08:56:38 <tehgeekmeister> dcoutts_: for update -v gives no output, for install it gets to reading what packages are available, and exits saying the package isn't available.
08:56:48 <Cheshire> mm_freak: you seem to have some unwillingness to accept that -- why?
08:56:58 <CTA> When In GHCi is there a way to make a new line without ending "typing code?"
08:56:59 <rwbarton> mm_freak: what about, say, (\x. (\y. y) x) z; there are two different redexes you can expand first
08:57:12 <dcoutts_> tehgeekmeister: sorry, I should have said first time, try -v3
08:57:19 <mm_freak> Cheshire: no i don't, but i always thought that there is only one beta-reduction strategy
08:57:27 <dcoutts_> tehgeekmeister: and an hpaste would be interesting
08:57:41 <Axman6> CTA: one thing that may be worth remembering i haskell is that when you see an equals sign, you can replace whatever's on the left with whatever's on the right, so if you say f x = x^x^2, you can replace all occurences of f x with (x^x^2)
08:57:43 <chessguy> doserj, ok, thanks
08:57:43 <tehgeekmeister> dcoutts_: no output for update, and i'll hpaste it for the install attempt
08:57:54 <CTA> what's best: let main = do putStrLn "" ... let main = putStrLn ""?
08:58:17 <CTA> or are they the same?
08:58:21 <Axman6> if there's only one function, then let main = putS..
08:58:25 <tehgeekmeister> dcoutts_: http://tinyurl.com/ctgkr4
08:58:29 <Axman6> they're the same CTA
08:58:44 <MyCatVerbs> ski_: because it's more powerful than pointer equality. Admittedly it's still an equivalence relation, so I suppose it's *an* equality.
08:59:02 <CTA> so i've got ghci on this pc now, where do i find ghc?
08:59:17 <dcoutts_> tehgeekmeister: so that may simply be true. The fact that update fails is more suspicious.
08:59:25 <ski_> MyCatVerbs : yes, it *is* equality
08:59:26 <Axman6> CTA: the same place you found ghci...
08:59:37 <mm_freak> hmm
08:59:40 <ski_> (don't be deceived by var/1, et.c., though)
08:59:43 <CTA> i only have some web linkos and ghci
08:59:58 <mm_freak> my conclusion is that there are two lambda calculi:  one strict and one lazy
08:59:59 <tehgeekmeister> dcoutts_: well, i checked hackage; that package does exist.  i've tried it with a variety of packages.  update has NEVER succeeded, and so i think that i don't have an accurate list locally.
09:00:03 <ski_> (they are the works of ialdabaoth)
09:00:05 <paper_cc> CTA: in the Start menu? of course
09:00:08 <Axman6> CTA: how are you running ghci?
09:00:11 <dcoutts_> tehgeekmeister: right
09:00:24 <dcoutts_> tehgeekmeister: so cabal update -v3 does what?
09:00:33 <tehgeekmeister> dcoutts_: exits immediately with no output
09:00:57 <paper_cc> CTA: locate the directory the GHCi executable is in, the compiler itself should be in the same place
09:01:01 <Cheshire> mm_freak, these are called evaluation strategies
09:01:08 <dcoutts_> tehgeekmeister: and you've got at least one hackage server configured in your ~/.cabal/config file right?
09:01:10 <ski_> mm_freak : there's one (untyped) lambda calculus, with several possible reduction strategies attaching to it
09:01:18 <tehgeekmeister> dcoutts_: no?
09:01:36 <dcoutts_> tehgeekmeister: take a look, by default it configures one server
09:01:38 <mm_freak> hmm, ok
09:01:41 <mm_freak> thanks
09:01:52 <tehgeekmeister> dcoutts_: only line in there is "documentation: True
09:02:17 <dcoutts_> tehgeekmeister: that's the only line in the whole file?
09:02:23 <tehgeekmeister> dcoutts_: yeah
09:02:30 <ferret_0567> Eridius: oh wait, I get it: = means "means", so the English makes it perfectly clear to me: i = i + 1 is, in other words, i means i + 1
09:02:38 <dcoutts_> tehgeekmeister: sounds like you accidentally did echo "documentation: True" > ~/.cabal/config instead of >>
09:02:47 <Eridius> ferret_0567: ah, but only in the lexical block that the let statement covers
09:02:53 <Eridius> as in let i = i + 1 in some-statement-here
09:02:58 <Eridius> and you don't have that second half
09:03:00 <Axman6> anyone have any comments on http://axman6.homeip.net/blog/2009/02/astm-redundant-stmish-fun.html for me?
09:03:02 <ferret_0567> Eridius: just use i + 1 instead of i = i + 1 in the function
09:03:04 <Eridius> let i = i + 1, by itself, is only valid inside a do block
09:03:04 <dcoutts_> tehgeekmeister: not to worry. delete the config file, let it be recreated and then edit it to turn on docs again by default
09:03:05 <tehgeekmeister> dcoutts_: very possibly.  is there a default config i can download somewhere?
09:03:12 <tehgeekmeister> okay
09:03:27 <dcoutts_> tehgeekmeister: I'll make cabal update complain if there are no servers configured.
09:03:42 <HugoDaniel> how do i replace every '_' in a string for a space ?
09:04:06 <Eridius> ferret_0567: is there some reason you don't like the standard recursive definition of length?
09:04:08 <mm_freak> when one talks about "beta reduction" without specifying evaluation strategy, what is meant usually?
09:04:11 <tehgeekmeister> dcoutts_: it works now
09:04:20 <dcoutts_> tehgeekmeister: yay :-)
09:04:30 <ferret_0567> Eridius: no, it's just a RWH exercise
09:04:36 <Eridius> ferret_0567: also, regardless of how you "fix" your definition, you're still missing the base case of length' []
09:04:38 <Eridius> RWH?
09:04:46 <ferret_0567> Eridius: Real World Haskell
09:04:49 <ferret_0567> @where rwh
09:04:49 <lambdabot> is http://www.realworldhaskell.org/blog/
09:04:59 <Eridius> ah. what chapter?
09:05:08 <ferret_0567> Eridius: I actually have that in there
09:05:08 <doserj> > let f '_' = ' ' ; f x = x in map f "Hello_World" -- HugoDaniel
09:05:10 <lambdabot>   "Hello World"
09:05:31 <paper_cc> @where+ rwh http://www.realworldhaskell.org/blog/
09:05:31 <lambdabot> I will never forget.
09:05:49 <ferret_0567> @rwh
09:05:50 <lambdabot> Maybe you meant: rc run wn
09:06:06 <ferret_0567> rwh
09:06:08 <paper_cc> ferret_0567: just the stale "is" in the old entry
09:06:13 <Eridius> ferret_0567: what chapter is your exercise from?
09:06:18 <tehgeekmeister> has anyone here used missingpy?  is it relatively stable and bug free?
09:06:23 <ferret_0567> Eridius: Chapter 3
09:06:47 <Eridius> ferret_0567: ah, it basically says "write your own version of length"
09:06:55 <ski_> Eridius : `beta-reduction' is `(\x0. e1) e0  -->  e1 [x0 := e1]'
09:06:58 <HugoDaniel> thanks doserj
09:07:19 <ski_> hrm, s/Eridius/mm_freak/  ^
09:07:27 <ski_> (i have no idea how ..)
09:08:05 <ski_> mm_freak : the reduction strategy tell you which redices to reduce, and in which order, using the beta-rule
09:09:01 <mm_freak> ski_: ah, ok
09:12:04 <ferret_0567> > length' (x:xs) = l 0 (x:xs) where l i (x:xs) = if x /= [] then l (i + 1) (x:xs) else i ; length' [1,2,3]
09:12:06 <lambdabot>   <no location info>: parse error on input `='
09:12:22 <ferret_0567> what? it compiled on my PC
09:12:32 <mm_freak> ski_: don't you mean (\x0. e1) e0 â e1 [x0 := e1]?
09:12:38 <mm_freak> uhm
09:12:41 <mm_freak> ski_: don't you mean (\x0. e1) e0 â e1 [x0 := e0]?
09:12:42 <mm_freak> sorry
09:12:57 <Eridius> ferret_0567: prepend a let
09:12:58 <Axman6> ferret_0567: you want xs /= [], not x /= []
09:13:09 <ferret_0567> Axman6: oh yeah
09:13:10 <Eridius> also, that's going to be an infinite loop
09:13:18 <ferret_0567> amiri: it's the little things that get you
09:13:21 <Axman6> yeah, that too
09:13:24 <ferret_0567> err...Axman6
09:13:25 <Eridius> l (i + 1) xs, not l (i + 1) (x:xs)
09:13:44 <Eridius> also, you can ditch the xs /= [] test if you have a base case l acc [] = acc
09:13:45 <Axman6> heh, that was the first thing that jumped out at me, but i didn't say anything
09:13:53 * Axman6 is awake at 4:13AM...
09:14:32 <ski_> mm_freak : yes
09:14:37 <ferret_0567> > length' (x:xs) = l 0 (x:xs) where l i (x:xs) = if xs /= [] then l (i + 1) xs else i ; length' [1,2,3]
09:14:38 <lambdabot>   <no location info>: parse error on input `='
09:14:39 * ski_ is not really awake
09:14:51 <Axman6> @quote Helio
09:14:51 <lambdabot> Helio says: in theory, there is no difference between theory and practice, in practice, there is
09:15:00 <mm_freak> hehe
09:15:01 <ski_> @quote Hello
09:15:02 <lambdabot> Anonymous says: I'd love to explain to you how to write hello world in Haskell, but first let me introduce you to basic category theory.
09:15:11 <Eridius> haha
09:15:26 <mm_freak> ski_: and the evaluation strategy tells, how this [] binding is resolved?
09:15:33 <ski_> (when did i say that ?, i don't remember ..)
09:15:36 <ferret_0567> now my function seems correct
09:15:41 <ferret_0567> > let length' (x:xs) = l 0 (x:xs) where l i (x:xs) = if xs /= [] then l (i + 1) xs else i ; length' [1,2,3]
09:15:43 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:15:46 <ferret_0567> ???
09:15:57 <Eridius> ferret_0567: try replacing the ; with the word "in"
09:16:02 <Axman6> ferret_0567: replace ; with in
09:16:07 <ferret_0567> > let length' (x:xs) = l 0 (x:xs) where l i (x:xs) = if xs /= [] then l (i + 1) xs else i in length' [1,2,3]
09:16:09 <Axman6> dang, beaten again
09:16:09 <lambdabot>   2
09:16:11 <doserj> > let length' (x:xs) = l 0 (x:xs) ; l i (x:xs) = if xs /= [] then l (i + 1) xs else i in length' [1,2,3]
09:16:12 <lambdabot>   2
09:16:16 <Eridius> 2? hehe
09:16:28 <Axman6> oh, i see why
09:16:42 <Eridius> it's because he's testing the tail if it's [], and if it is, he's not even counting the head
09:16:43 <ferret_0567> remove the if?
09:16:51 <Axman6> ferret_0567: that definition is broken anyway, it will never match []
09:17:01 <ski_> mm_freak : no, the reduction strategy tells you which of `e' and `e0' to look for redices to reduce first, in `e e0' assuming `e' is not already `\x0. e1'
09:17:47 <Cheshire> we can specify evaluation contexts
09:17:57 <ski_> felleisen ftw !
09:18:39 <Cheshire> hmm
09:19:07 <rwbarton> ferret_0567: (x:xs) matches only nonempty lists, not every list
09:19:15 * Cheshire just forget how right after making the claim
09:19:43 <ferret_0567> rwbarton: oh yeah...
09:20:27 <Cheshire> E[t] ::= [t] | E[t] n  I suppose
09:20:40 <Cheshire> for lazy (repeated WHNF) reduction
09:20:59 <Cheshire> and then  E[t] ::= [t] | m E[t]   for strict evaluation
09:21:10 <Cheshire> (is this accurate?)
09:23:45 <pejo> Cheshire, how does that work on "e (\x.x)" in the strict case?
09:24:01 <tehgeekmeister> is there a way to write code that iterates thru a Map; i don't want any of the built in traversal functions, because it'll be easier and clearer code if I can do the iteration manually, and do all of this in the state monad.
09:24:26 <Cheshire> pejo, that term would be stuck since [(\x.x)] is already a value, and [e (\x.x)] is not a beta redex
09:24:45 <Cheshire> pejo, I could have made some mistakes or deviated from the normal presentation a bit here though..
09:24:53 <Saizan_> tehgeekmeister: toList ?
09:25:06 <tehgeekmeister> Saizan_: oh man i didn't think of that.
09:25:10 <tehgeekmeister> that's pretty simple.
09:25:12 <tehgeekmeister> =D
09:26:13 <ski_> (pejo : unless `e' is a meta-variable ..)
09:26:26 <Cheshire> hm I guess my definitionis wrong -- but I don't know how to correct it
09:27:10 <ski_> E[t] ::= [t] | E[t] M | V E[t]
09:27:14 <ski_> mayhaps ?
09:27:15 <Cheshire> ahhh
09:27:28 <Cheshire> that is better, making a distinction between values and terms
09:27:31 <ski_> (if you want left-to-right)
09:27:46 <pejo> ski, i used it for an arbitrary term that wasn't a value
09:27:49 <ski_> V ::= \x. M
09:28:06 <ski_> (pejo : i suspected that ..)
09:28:34 <tehgeekmeister> i can have nested patterns like ((k,v):xs), right?
09:28:47 <seliopou> tehgeekmeister, yes
09:29:37 <ferret_0567> rwbarton: how do I match a list with one item and the empty list right next to that?
09:30:15 <ferret_0567> using (x:[]) after (x:xs) gives me the pattern match(es) overlapped warning
09:30:20 <Twey> tehgeekmeister: Thing about Haskell: if you think you ought to be able to, you probably can
09:30:31 <Twey> (if you can't, it's in an extension)
09:30:33 <wjt> ferret_0567: that'll be because they overlap
09:30:46 <tehgeekmeister> Twey: unless you can't imagine a type for the resulting function.  and then i guess it might be template haskell.
09:30:49 <pilkarn>  can a tuple not be of length 3?
09:30:49 <wjt> ferret_0567: you should match [x] first
09:30:55 <Axman6> ferret_0567: in (x:xs), xs could equal []
09:30:56 <Twey> Heh, indeed
09:31:20 <ManateeLazyCat> Have a program can do something like this: *input string* => *all completion list* ? I mean use GHC
09:31:35 <Axman6> >  foldl (const . (+1)) 0 [1..100000]
09:31:37 <lambdabot>   100000
09:31:51 <ManateeLazyCat> I want develop a auto-completion interface for coding Haskell in Emacs.
09:31:53 <Axman6> >  foldl' (const . (+1)) 0 [1..10000000]
09:31:55 <tehgeekmeister> Twey: i want an analog of foo f n = map (map (map ... (map f))), where n is how deeply you nest it, but i'm not willing to mess with template haskell to get it yet
09:31:58 <lambdabot>   10000000
09:31:58 <ski_> > let f [] = 0; f (x:xs) = 1; f (x:[]) = 2 in f [3]
09:32:00 <lambdabot>   mueval: Prelude.read: no parse
09:32:00 <lambdabot>  mueval: UnknownError "GHC reported errors a...
09:32:18 <ferret_0567> Axman6: if xs could equal [], then why won't if /= [] then ... work?
09:32:19 <ski_> @slap lambdabot
09:32:20 <lambdabot> Come on, let's all slap lambdabot
09:32:20 <ManateeLazyCat> So i want to know have a program can get *completion symbol list*
09:32:54 <Axman6> ferret_0567: you should try and answer this exercise using patern matching only. don't use if, /=, == or anything like that
09:32:57 <newsham> ?let unlist n c [] = n; unlist n c (x:xs) = x `c` xs
09:32:59 <Cheshire> ManateeLazyCat: well GHC already has such a thing internally -- so I guess you just need to expose an interface to it
09:33:00 <lambdabot>  Defined.
09:33:24 <Axman6> newsham: that's just foldr no?
09:33:32 <newsham> not quite
09:33:41 <Axman6> oh, no, my bad
09:33:46 <Axman6> :t unlist
09:33:48 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
09:33:53 <ManateeLazyCat> Cheshire: GHC can *output* completion candidate list? I can do it in command-list?
09:34:07 <Cheshire> yes with tab
09:34:07 <newsham> > unlist Nothing (\x xs -> Just x) "test"
09:34:09 <lambdabot>   Just 't'
09:34:11 <Axman6> anyway, sleep time. night all
09:34:14 <newsham> > unlist Nothing (\x xs -> Just x) ""
09:34:16 <lambdabot>   Nothing
09:34:22 <Cheshire> len<tab> ~~> length
09:35:06 <ManateeLazyCat> Cheshire: TAB? I mean i *input string* => GHC => completion candidate list, don't type TAB. Any idea?
09:35:22 <Cheshire> I already told you
09:35:45 <Cheshire> ManateeLazyCat: my suggestion is open up GHC and add the feature
09:37:37 <ManateeLazyCat> Cheshire: I'm a newbie of Haskell, can you give me example, i know i can type TAB in ghci give completion.
09:37:50 <Cheshire> of?
09:39:40 <ManateeLazyCat> Cheshire: I mean not type TAB in GHCi, I want this: *input string* => *Program* => *completion list*, i want *Program* parse my input and give me *list*.
09:39:55 <Cheshire> no I don't understand you
09:40:15 <rwbarton> ManateeLazyCat: are you writing a program that uses readline?
09:40:32 <ManateeLazyCat> Cheshire: You mean i type TAB in GHCi?
09:41:38 <ManateeLazyCat> rwbarton: In Emacs, have a extension provide auto-completion UI, it need *list* for completion, so i want know have a program can *read string* and *output list*.
09:41:39 <rwbarton> ManateeLazyCat: oh wait, you want a command-line program that will complete symbols for you?
09:41:51 <ManateeLazyCat> rwbarton: Yep
09:42:24 <ManateeLazyCat> rwbarton: I just want this command-line, then i redirect to Emacs completion UI.
09:42:25 <rwbarton> ManateeLazyCat: how will that command-line program know what symbols are in scope in your program?
09:42:36 <hackage> Uploaded to hackage: pqueue-mtl 1.0.2
09:42:36 <hackage> Uploaded to hackage: stateful-mtl 1.0.2
09:42:38 <rwbarton> ManateeLazyCat: or in your ghci session?
09:43:22 <ManateeLazyCat> rwbarton: Now i just need simple for *keyword* and *module*
09:43:45 <ManateeLazyCat> rwbarton: Or exactly, i just need it can give me symbol define in GHC.
09:44:59 <ManateeLazyCat> rwbarton: I want *input-string* => *command-line-program* => *GHC API completion list*.
09:45:43 <ManateeLazyCat> rwbarton: Current, i just want to competition symbol that define in GHC API.
09:46:06 <rwbarton> By the GHC API do you mean the ghc package?
09:46:17 <ManateeLazyCat> rwbarton: Yep.
09:46:29 <ManateeLazyCat> rwbarton: Have a command-line can do that?
09:46:36 <ManateeLazyCat> command-line program
09:47:17 * ManateeLazyCat pasted "auto-complete-extension.el" at http://paste2.org/get/148286
09:47:39 <ManateeLazyCat> rwbarton: See above, now i write all completion symbol in file, i just want a program parse those symbol for me.
09:47:54 <pilkarn> ok Im trying to write quicksort in haskell and I did the standard innefficient 2-liner. Im having trouble with making a more efficient one. like traverse over the list once and filter them to the 2 lists rather than doing it twice.
09:47:54 <ManateeLazyCat> rwbarton: And hard code is ugly.
09:48:11 <pilkarn> can you use a listomcprehension to cons something to either of 2 alternatives?
09:48:13 <redditbot> The Typeclassopedia
09:48:13 <redditbot> The Universe of Discourse : Milo of Croton and the sometimes failure of inductive proofs
09:48:13 <redditbot> Announcing the launch of the Patch-Tag blog
09:48:13 <redditbot> ASTM: redundant STMish fun - Data.Random
09:48:13 <redditbot> XML parsing with Haskell
09:48:29 <int80_h> @hoogle rational
09:48:29 <lambdabot> Text.PrettyPrint.HughesPJ rational :: Rational -> Doc
09:48:30 <lambdabot> Language.Haskell.TH.PprLib rational :: Rational -> Doc
09:48:30 <lambdabot> Prelude type Rational = Ratio Integer
09:49:35 <pilkarn> what sit he easiest way to time a haskell program?
09:50:02 <ManateeLazyCat> rwbarton: GHC have a *interface* to generate completion symbol?
09:50:07 <int80_h> < Rational::1
09:50:08 <rwbarton> ManateeLazyCat: Sorry, I can't understand
09:50:17 <rwbarton> ManateeLazyCat: You might look at hoogle though
09:50:30 <rwbarton> ManateeLazyCat: it has a way to build a database of symbols from a package
09:50:34 <int80_h> > Rational::1
09:50:34 <lambdabot>   Not in scope: data constructor `Rational'
09:50:40 <int80_h> rational::1
09:50:44 <int80_h> > rational::1
09:50:45 <lambdabot>   Couldn't match expected type `Unit'
09:50:47 <ManateeLazyCat> rwbarton: Thanks!
09:50:52 <int80_h> int:1
09:50:59 <int80_h> > int::1
09:51:01 <lambdabot>   Couldn't match expected type `Unit'
09:51:08 <rwbarton> ManateeLazyCat: In fact, if you cabal install hoogle, there will be a file ~/.cabal/share/hoogle-4.0.0.5/ghc.hoo
09:51:23 <int80_h> > 1::int
09:51:24 <rwbarton> ManateeLazyCat: I don't know what the file format is, but you can probably figure it out from the Hoogle source
09:51:25 <lambdabot>       Could not deduce (Num int) from the context ()
09:51:25 <lambdabot>        arising from the ...
09:51:32 <int80_h> > 1::Int
09:51:34 <lambdabot>   1
09:51:42 <int80_h> > 1::Rational
09:51:44 <lambdabot>   1%1
09:51:50 <ManateeLazyCat> rwbarton: Ok, thank! :)
09:52:42 <int80_h> @type elem
09:52:44 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:53:09 <int80_h> @type mod
09:53:10 <lambdabot> forall a. (Integral a) => a -> a -> a
09:53:14 <rwbarton> ManateeLazyCat: you might also see what you can make of the output of hoogle --dump --data=.cabal/share/hoogle-4.0.0.5/ghc.hoo
09:53:54 <ManateeLazyCat> rwbarton: Hoogle is i want, thanks! I will try to parse it. :)
09:54:46 <int80_h> does the type of mod indicate that it cannot use Rationals for input?
09:56:07 <tehgeekmeister> is there some sort of an equivalent of negative infinity in haskell?  i need a number which is guaranteed to be lower than any number i compare it with, as an initial value for max for a fold.
09:56:17 <int80_h> Can mod use Rationals as input?
09:57:39 <doserj> > (-1/0::Double) < -100000000
09:57:40 <lambdabot>   True
09:57:52 <int80_h> anyone?
09:58:14 <doserj> int80_h: Rationals are not an instance of Integral, and cannot be sensibly made one
09:58:57 <idnar> @type fmod
09:58:59 <lambdabot> Not in scope: `fmod'
09:59:38 <int80_h> doserj: for reasons I wasn't clear on, I was advised to change my type definitions from Intergers to Rationals. But this is leading to problems like mod not being able to use Rationals
10:00:04 <ehird> @hoogle ExpQ -> a
10:00:05 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
10:00:05 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
10:00:05 <lambdabot> Language.Haskell.TH fromE :: ExpQ -> ExpQ
10:00:12 <int80_h> doserj: I'm trying to implement the miller-Rabin primality test, and I need to use very large numbers
10:00:21 <ehird> @hoogle a -> ExpQ
10:00:22 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
10:00:22 <lambdabot> Language.Haskell.TH.Syntax returnQ :: a -> Q a
10:00:22 <lambdabot> Language.Haskell.TH litE :: Lit -> ExpQ
10:00:49 <int80_h> it could be that using rationals was not the way to go, and there's another solution to my problem
10:01:38 <lilac> int80_h: what was your problem?
10:03:10 <rwbarton> int80_h: I'm not clear on why you'd want to use Rationals to implement Miller-Rabin either.
10:04:02 <int80_h> liac: My implementation is not efficient at all, and I need to be able to use large numbers. I've been away from this code for about a week, so I'm re-familiarizing myself with it
10:04:37 <Saizan_> Rational was suggested because he needed negative exponents
10:05:03 <int80_h> Saizan_ : oh yeah that was it. Sometimes I will need negative exponents
10:05:11 <int80_h> thanks Saizan_
10:05:12 <Saizan_> maybe you want to round the results back to Integer
10:05:37 <wli> It probably would've been better to implement your own exponentiation operator.
10:06:11 <int80_h> wli: hmm, I haven't gotten that far yet. Trying to take the language in chunks
10:06:21 <MyCatVerbs> You quite probably want to implement your own exponentiation anyway, because you don't want exponentiation, you want modulo exponentiation instead.
10:06:37 <int80_h> Okay, I'll earn how to do that
10:06:40 <int80_h> *learn
10:07:21 * rwbarton points out unhelpfully that (^) can be made to do efficient modular exponentiation
10:07:30 <wli> What you get with with negative exponents when working in modular rings is the multiplicative inverse in that integer ring implemented via the extended Euclidean algorithm to the negative of the power.
10:07:50 <rwbarton> I don't see where you need negative exponents though.
10:07:56 <MyCatVerbs> rwbarton: are you going to suggest a newtype and a Num instance for it, or something?
10:08:23 <rwbarton> MyCatVerbs: Not just one, but one for every modulus! :)
10:08:25 <lilac> int80_h: aren't you working in Zp anyway?
10:08:42 <lilac> in which case, Rational is definitely not what you want...
10:08:54 <int80_h> rwbarton: I'll need to consult my notes, but when I was working out my code by hand (for troubleshooting) I noticed in some instances the integers would turn out to be negative
10:09:00 <BMeph> int80_h: Use Word. ;p
10:09:05 * wli would avoid Num and just use a reader monad to deal with the modulus.
10:09:08 <MyCatVerbs> int80_h: the thing being that when you calculate (x^y `mod` m), it can sometimes make the calculations faster to impose the (`mod` m) during intermediate stages, rather than calculating (x^y) and then taking that mod m.
10:09:57 <MyCatVerbs> (Just because you end up with smaller numbers to work on, which gets significant roundabout RSA-key-ish integer sizes. ^^)
10:10:00 <int80_h> MyCatVerbs: you mean, make a list of the results of x^y, then do the mod operation?
10:11:28 <lilac> data Num = Num `Pow` Num | Num Int; instance Num Num where (^) = Pow; (a `Pow` b) `mod` k = (a `mod` k) `Pow` (b `mod` k)
10:11:30 <MyCatVerbs> int80_h: I mean instead of doing the exponentiation then taking the answer modulo m, take the intermediate values modulo m in the middle of the exponentiation in order to cut the lengths of the numbers you're working on.
10:11:31 <BMeph> int80_h: Maybe make a list of
10:11:44 <BMeph> int80_H: ...never mind.
10:11:48 <pilkarn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1448#a1448 , can I speed up/better the qucksort? I could use randomizing the pivot but I hate monads...
10:11:51 <MyCatVerbs> int80_h: for individual exponentiations modulo, nothing to do with lists thereof or anything.
10:12:21 <int80_h> MyCatVerbs: could you show an example of that?
10:12:45 <ehird> @djinn a -> ((a -> p) -> p) -> a -> p
10:12:46 <lambdabot> -- f cannot be realized.
10:13:02 <wli> pilkarn: Genuine quicksorts use arrays.
10:13:53 <lilac> pilkarn: quicksort is not possible on Haskell's []
10:15:07 <int80_h> MyCatVerbs: please? I don't need to see complete code, just an example of what that looks like. I'm not sure I really understand.
10:15:25 <MyCatVerbs> int80_h: I'm trying to work out how best to show it.
10:15:39 <int80_h> thanks :)
10:15:46 <pilkarn> lilac: ok but could I speed it up anyway?
10:15:58 <lilac> pilkarn: but whatever that sort's called, you can better write it as: 'quicksort [] = []; quicksort (x:xs) = filter (<x) xs ++ [x] ++ filter (>=x) xs
10:16:23 <pilkarn> and is mergesort possible on haskell-lists? anyway the Data.List uses a quicksort on [] but then it is not inplace sorted and not a real qsort?
10:16:53 <xxgodsmackxx321> http://tinyurl.com/cashcrate13 for free cash!
10:17:05 <pilkarn> lilac: as i ahve in quicksort2 but then I traverse the list 2 times rigth?
10:17:07 <MyCatVerbs> int80_h: Say, x=2^64, y=2^16, m=2^65 + 1. You'll want to calculate that as square(square(square(square(x)))) rather than actually multiplying an accumulator by x and decrementing y 2^16 times.
10:17:12 <pilkarn> thats what i wanted to avoid
10:17:14 <lilac> pilkarn: mergesort is possible on singly-linked lists, and consequently on []
10:18:09 <MyCatVerbs> int80_h: (er, my brain doesn't work. Sixteen applications of square, not 4. D'oh.)
10:18:12 <int80_h> MyCatVerbs: okay. I'm not sure how that helps me accomodate negative integers however.
10:18:23 <pilkarn> and my mergesort is a correct mergesort(and efficient enough)?
10:18:31 <MyCatVerbs> Where do you need negative powers for primality testing?
10:18:55 <pilkarn> so I need to use mutable arrays to not normal arrays?
10:18:56 <int80_h> MyCatVerbs: let me consult my notes for that
10:19:39 <koeien> if you want the multiplicative inverse of a number mod m, you'll have to use Euclid's algorithm
10:19:58 <koeien> (not sure whether that is the question, just jumping in :)
10:20:03 <lilac> pilkarn: i wouldn't use 'length' for the divide step, but other than that i think it's ok
10:20:30 <wli> let egcd' (u, v, w) (x, y, z) | abs w == 0 = (x, y, z) | abs w > abs z = egcd' (x, y, z) (u, v, w) | otherwise = let (q, r) = z `divMod` w in egcd' (x - q * u, y - q * v, z - q * w) (u, v, w) ; egcd m n = egcd' (1, 0, m) (0, 1, n)
10:20:43 <wli> int80_h: That should get you modular inverses.
10:21:17 <koeien> that may be correct :)
10:21:30 <pilkarn> lilac: i only do the first time...not every. how would you do if not to use length?
10:21:41 <lilac> pilkarn: divide [] = ([], []); divide [x] = ([x], []); divide (x:y:xs) = (x:) *** (y:) $ divide xs
10:21:52 <wli> int80_h: egcd m n == (a, b, c) where a * m + b * n = c and so when c == 1 you have that a is the inverse of m mod n and b is the inverse of n mod m.
10:22:14 <koeien> yep, mod m the a*m term vanishes
10:22:19 <pilkarn> *** ?
10:22:41 <wli> int80_h: if c /= 1 then m is not a unit mod n nor is n a unit mod m.
10:22:54 <lilac> pilkarn: that third case can be written perhaps more readably as: divide (x:y:zs) = let (xs, ys) = divide zs in (x:xs, y:ys)
10:23:16 <lilac> pilkarn: (f *** g) (a, b) = (f a, g b)
10:23:31 <BMeph> wli: Shouldn't the third member of the first tuple just be 'r'? :)
10:23:58 <BMeph> wli: I.e.,  egcd' (x - q * u, y - q * v, r) (u, v, w)
10:24:25 <wli> BMeph: That would be more efficient, yes.
10:25:07 <ManateeLazyCat> rwbarton: Hoogle is great for get competition list, thanks for your help! :)
10:25:07 <BMeph> wli: Okay, just making sure I wasn't totally lost. :)
10:25:30 <wli> > let egcd' (u, v, w) (x, y, z) | abs w == 0 = (x, y, z) | abs w > abs z = egcd' (x, y, z) (u, v, w) | otherwise = let (q, r) = z `divMod` w in egcd' (x - q * u, y - q * v, r) (u, v, w) ; egcd m n = egcd' (1, 0, m) (0, 1, n) ; inverse m n = let (a, b, c) = egcd m n in if abs c /= 1 then Nothing else Just $ a * signum c `mod` n in inverse 2 65537
10:25:31 <pilkarn> lilac: and that is the didive for mergesort? and it is faster than length+splitAt?
10:25:32 <lambdabot>   Just 32769
10:25:55 <lilac> pilkarn: try it and see. I'd guess it is, since it traverses the list less, but who knows...
10:26:32 <lilac> pilkarn: in any case, if you're prepared to use the ST monad, we can write a real quicksort on lists which goes via STArrays.
10:26:45 <pilkarn> state monad?
10:26:55 <wli> Actually, it should really return the gcd when it fails.
10:27:18 <koeien> yay for Either
10:27:26 <pilkarn> but anyway the quicksort is faster than quicksort2 right? it only traverses the list once, or am i doing something im not seeing?
10:27:32 <koeien> if you take it mod a prime you can be certain of an answer unless you take 0
10:28:00 <wli> koeien: The point is that he's trying to prove that the number used as a modulus is prime...
10:28:25 <koeien> wli: i missed that part :/ sorry. randomized primality testing i suppose?
10:28:28 <lilac> pilkarn: i'd guess that quicksort would be faster than quicksort2
10:29:21 <wli> I'd just write inverse m n = let (a, b, c) = egcd m n in if abs c /= 1 then Left $ abs c else Right $ a * signum c `mod` n for that.
10:29:58 <koeien> > (-2) `mod` 37
10:30:00 <lambdabot>   35
10:30:04 <koeien> ah! sane
10:30:21 <PeakerWork> > (-2) `rem` 37
10:30:23 <lambdabot>   -2
10:30:28 <wli> `rem` uses the other convention.
10:30:42 <PeakerWork> I remembered rem was the sane one, but apparently I was wrong :)
10:30:42 <koeien> i never know that in any language. i always test it out
10:30:53 <wli> > (-2) `mod` (-37)
10:30:55 <lambdabot>   -2
10:31:02 <BMeph> pilkarn: Remember: "Never calculate the length if you don't 'really' need it."
10:31:16 <wli> It can still get a bit hairy.
10:31:20 <koeien> PeakerWork: i really like the fact that it gives the same answer for (a+n) `mod` n
10:31:33 <koeien> wli: yeah negative division is scary :)
10:31:34 <PeakerWork> koeien: yeah, I agree about the sanity thing
10:32:33 <koeien> C gets this wrong imo
10:33:01 <PeakerWork> genericLength :: Nat is not as much of a problem as length, but I wonder if we can get a data-type with the nice properties of Nat but that does have hardware-accelerated operations when that's possible
10:33:42 <dnul> :t groupBy
10:33:43 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
10:33:58 <wli> Peaker: Integer with sign affairs adjusted and/or ripped out.
10:34:13 <lilac> PeakerWork: what do you mean by 'hardware-accelerated operations'? you want a lazy natural class which is fast if the number happens to be strict?
10:34:13 <kpreid> PeakerWork: data Nat' = Plus Int Nat' | Zero ?
10:34:18 <lilac> s/class/type/
10:34:27 <PeakerWork> lilac: yeah
10:34:35 <dnul> question , groupBy checks for consecutive equalitiy , is there a global groupBy like SQL ?
10:34:57 <BMeph> kpreid: Bad Haskeller! No lambdas for j00!
10:34:58 <dnul> maybe i can sort it first, then group
10:35:06 <lilac> PeakerWork: Nat with transparent path compression should be possible with only a little unsafePerformIO
10:35:24 <kpreid> BMeph: hm?
10:35:45 <pilkarn> something like quicksort small ++ [pivot] ++ quicksort big , can it be done faster?
10:35:54 <drhodes> is there a way do test if two functions have the same type? (type f) == (type g)
10:36:02 <BMeph> kpreid: "Plus Int Nat'"? Really, that's kind of icky-looking. :)
10:36:23 <wli> pilkarn: Use arrays.
10:36:31 <paper_cc> Trying to use GADTs as associated types crashes GHC (the 'impossible' happened: Maybe.fromJust: Nothing). Is this a known bug?
10:36:35 <PeakerWork> lilac: "path compression"?
10:36:43 <BMeph> lilac: It always starts "with only a little unsafePerformIO"... ;)
10:36:44 <glguy> drhodes, Do you mean with template Haskell?
10:36:48 <kpreid> BMeph: what, the stray sign bit?
10:36:50 <rwbarton> drhodes: what do you want to do with such a thing?
10:37:11 <wli> PeakerWork: Alternatively use newtype Nat = Nat (Word32, [Word32])
10:37:12 <drhodes> glguy: nah, I'm just goofin in ghci with a monad tutorial
10:37:18 <glguy> drhodes, need for such a thing rarely comes up in Haskell use
10:37:31 <rwbarton> PeakerWork: I think lilac means rewriting Plus a (Plus b x) to Plus (a + b) x
10:37:40 <glguy> drhodes, if you want to *make* them equal, you can use asTypeOf
10:37:43 <PeakerWork> rwbarton: ah
10:37:43 <glguy> :t asTypeOf
10:37:45 <lambdabot> forall a. a -> a -> a
10:37:51 <BMeph> kpreid: Using Int in a Nat(ural). Why not just use Word? That's what it's for, isn't it? Well, that, and Bit ops.
10:37:59 <PeakerWork> surely unsafePerformST or such then? :)
10:38:08 <kpreid> BMeph: Not used to working wth those types.
10:38:11 <kpreid> DIdn't think of it
10:38:27 * wli would use a reader monad for modular arithmetic.
10:39:31 <BMeph> kpreid: Yeah, I just copiy the rep for Integer, and substitute Word# for Int#. Unfortunately, all of the operations on Word#s convert them to Int# internally. :\
10:39:38 <BMeph> *copy
10:40:22 <BMeph> wli: Do you have an example of that? I assume the "environment" holds the modulus, right?
10:40:37 <pilkarn> what si the easiest way to time a haskell program?
10:40:41 <pilkarn> or a function?
10:40:53 <drhodes> glguy: that's neat, I've needed that function before and didn't know about it. Thanks
10:41:15 <BMeph> wli: Elegant solution for Nat, BTW. I might crib it somewhere...with attributions, of course. :)
10:41:30 <ziman> pilkarn, you can run the program: ./program +RTS -sstderr
10:41:32 <glguy> drhodes, it is just (\ x _ -> x) with a more restrictive type-signature.
10:41:40 <rwbarton> paper_cc: Yes, it is; it's fixed in ghc-HEAD
10:41:41 <ziman> pilkarn, this will print some stats to stderr, including the total runtime
10:42:20 <rovar> quick question, how can I have two modules in scope at the same time in ghci? I am trying to use BinaryDerive on my custom types, but it seems that only one module or the other is in scope
10:42:21 <wli> BMeph: Yeah, the environment holds the modulus. Divisibility errors (e.g. inversion failure) are throwError'd.
10:42:37 <hackage> Uploaded to hackage: Crypto 4.2.0
10:42:42 <wli> BMeph: I've written it a bunch of times and lost it when the machines vaporized out from under me.
10:43:18 <glguy> wli, nuked from orbit?
10:43:26 <BMeph> wli: Yikes! Have you considered Google Docs? :)
10:43:33 <wli> More humiliating than that.
10:43:35 <ziman> pilkarn, you might want to take look at the `Profiling and Optimization' chapter of RWH
10:43:37 <lilac> PeakerWork: it strikes me that fingertrees might do exactly what you want here
10:43:38 <pilkarn> im trying to mergesort 1million elem lsit and get a stack overflow
10:43:50 <lilac> PeakerWork: you have a monoidal structure and want cached evaluation of subresults
10:44:20 <PeakerWork> lilac: I think I read about finger trees twice, and since I haven't used them, I forgot after both times :)
10:44:21 <pilkarn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1448#a1449
10:44:23 <ziman> pilkarn, then your algorithm is too lazy and creates a large unevaluated thunk somewhere
10:44:23 <BMeph> rovar: Umm, import them both into a third module? :)
10:44:31 <rovar> meh
10:44:58 <cschneid> newbie question: is there something like "eval()" in haskell?  Does that even make sense in such a strict language?
10:45:22 <dons> pilkarn: you don't want to use the built in merge sort?
10:45:29 <dons> cschneid: sure it makes sense.
10:45:31 <PeakerWork> cschneid: when you say "strict", you mean "static" or "type-safe", I think
10:45:39 <dons> eval is just rather hard to statically typed
10:45:39 <cschneid> PeakerWork: right, not evaluation strict
10:45:41 <cschneid> sorry :)
10:45:53 <dons> pilkarn: the built in sort should do just fine.
10:45:58 <paper_cc> rwbarton: is there any way to replace my GHC 6.10.1 installation with 6.11-20090215 without rebuilding all packages?
10:46:07 <dons> paper_cc: nope
10:46:10 <cschneid> dons: right, figuring out eval's return is impossible (by definition?)
10:46:25 <drhodes> pilkarn: an easy way to time from bash, is to use $ time ./a.out, if that suffices.
10:46:45 <dons> :t System.Eval.Haskell.eval
10:46:47 <lambdabot> forall a. (Typeable a) => String -> [System.Eval.Utils.Import] -> IO (Maybe a)
10:46:56 <dons> the 'compiler' function
10:47:02 <dons> somewhat similar to
10:47:03 <dons> :t read
10:47:05 <lambdabot> forall a. (Read a) => String -> a
10:47:29 * cschneid should go back to real world haskell and finish that before asking questions :)
10:47:30 <PeakerWork> I think read should be (Read a) => String -> Maybe a
10:47:50 <dons> cschneid: no, its a very tough problem. and a good one to raise
10:48:00 <vincenz> byorgey_: Hmm
10:48:05 <cschneid> dons: I know I had a thought that'd require it, but I can't remember what
10:48:11 <vincenz> byorgey_: how do Functor and Applicative relate?
10:48:14 <redditbot> Ask Haskell.reddit â tail calls with lazy evaluation
10:48:14 <redditbot> 5th Haskell Hackathon, April 17-19, Utrecht
10:48:14 <redditbot> Arch Haskell News: Feb 16 2009 : video, grapefruit, gtk2hs, haskelldb
10:48:37 <cschneid> although the php style templating language is one.   (erb, jsp, etc)
10:48:48 <PeakerWork> vincenz: Applicative is a functor that can sequence computations together and combine their results
10:48:52 <cschneid> (web page generation that looks like html rather than looking like code)
10:50:25 <PeakerWork> I'd prefer liftA2 to be Applicative's operation, and rename it - "application" has little to do with "Applicative", fundamentally
10:51:47 <sw17ch> :t (<*>)
10:51:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:52:04 <sw17ch> > a <*> b
10:52:06 <lambdabot>   Couldn't match expected type `f (a -> b)'
10:52:19 <vincenz> PeakerWork: but does one subsume the other?
10:52:31 <sw17ch> :t liftA2
10:52:33 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:52:40 <vincenz> fmap f t = pure f <*> t
10:52:40 <PeakerWork> vincenz: Applicative subclasses Functor
10:52:40 <vincenz> ?
10:53:03 <PeakerWork> vincenz: with pure and <*> you can implement fmap, so Applicative expressiveness is a superset of Functor even without the subclassing
10:53:03 <vincenz> PeakerWork: subsume, not subclasses
10:53:10 <vincenz> Right, thanks :)
10:53:15 <rwbarton> vincenz: Yes, you can write <*> in terms of liftA2.  (Or even liftA2 (,).)
10:54:19 <PeakerWork> btw: if liftA1 is Functor's fundumental operation (fmap=liftA1=liftA) then its nicer to have liftA2 be Applicative's operation, it also makes it clearer what the fundumental difference between them is
10:54:47 <mathijs> small question: is there something like Debug.Trace.trace for timing? I have a function, and every time it gets called, I want to print a benchmark how long it took.
10:55:25 <rovar> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1414#a1414
10:55:31 <augustss> mathijs: that's a tricky thing to do
10:55:42 <rovar> BinaryDerive is causing me problems if anyone's got any tips.
10:55:42 <vincenz> rwbarton: erm, right but liftA2 is not really to the point :)
10:55:44 <augustss> mathijs: or at least to get right
10:55:53 <augustss> mathijs: because of lazy evaluation
10:55:55 <mathijs> augustss: so better to just use profiling?
10:55:57 <PeakerWork> vincenz: what do you mean?
10:56:07 <vincenz> PeakerWork: liftA2 is part of Applicative, no?
10:56:16 <vincenz> or rather, it presumes Applicative
10:56:29 <PeakerWork> vincenz: its just a normal function using Applicative
10:56:32 <vincenz> So telling me that liftA2 can be used to code <*> is a rather nop statement
10:56:33 <augustss> mathijs: if you make sure to have forced the entire return value before leaving the function, you can do it
10:56:55 <PeakerWork> vincenz: there are functions that use Applicative that cannot be used to implement <*>
10:57:04 <vincenz> augustss: couldn't you deepseq?
10:57:07 <mathijs> augustss: ok, so I'll just use `seq`
10:57:25 <BMeph> vincenz: I think PeakerWork means that he wants 'liftA2' to be the defining function for the Applicative class. PeakerWork, please correct me. :)
10:57:33 <PeakerWork> BMeph: yeah, I do
10:57:38 <augustss> mathijs: seq is only good enough for atomic data, otherwise you need some deepseq
10:57:41 <PeakerWork> BMeph: I think "Applicative" has little to do with function application
10:57:44 <vincenz> PeakerWork: I wasn't reacting to you, tho, I was reacting to rwbarton :)
10:57:59 <augustss> mathijs: I usually compare something to itself if i need a quick and dirty forcing
10:58:10 <vincenz> @quote+ augustss I usually compare something to itself if i need a  quick and dirty forcing
10:58:11 <lambdabot> No quotes match. Just try something else.
10:58:12 <mathijs> augustss: hehe that's a nice trick
10:58:16 <vincenz> @remember augustss I usually compare something to itself if i need a  quick and dirty forcing
10:58:16 <lambdabot> It is stored.
10:58:49 <maltem> PeakerWork: How has <*> little to do with function application?
10:58:54 <PeakerWork> BMeph: and if the classes had more suggestive names:  Applicative -> SequentiableFunctor or Sequentiable, Monad -> DynamicSequentiable    or something like that :)
10:59:04 <augustss> mathijs: System.TimeIt (package timeit) + unsafePerformIO should give you something you can insert for performance debugging
10:59:13 <PeakerWork> maltem: I think (<*>) is arbitrary and liftA2 is a less arbitrary choice for the class
10:59:15 <mathijs> augustss: thanks
10:59:40 <PeakerWork> maltem: and that the arbitrary operation that was used because it was expressive enough does not encapsulate the fundamental meaning of the class
10:59:51 <vincenz> :t liftA2
10:59:53 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:00:18 <augustss> mathijs: but it's worth some time to investigate profiling if you've not done that before
11:00:25 <rwbarton> rovar: I don't know what BinaryDerive is but I recommend using the derive package in its TH mode
11:00:26 <vincenz> aha
11:00:41 <vincenz> (<*>) = liftA2 ($)
11:00:44 <augustss> :t liftA42
11:00:46 <lambdabot> Not in scope: `liftA42'
11:00:53 <maltem> PeakerWork: That should be a matter of taste really?
11:01:05 <rovar> rwbarton:  BinaryDerive is the helper function to generate put/get instances for binary, it is found here http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html
11:01:23 <ddarius> dons: I think it's important to point out in the reddit thread, that regardless of the strictness of the accumulator, the code still gets compiled into a loop.  Tail call optimization is orthogonal to the build-up in the accumulating parameter and is necessary on it's own otherwise you'd get a stack overflow even with a strict accumulator (or none).
11:01:27 <rovar> what is TH mode?
11:01:52 <lilac> PeakerWork: sequencing is but one use of Applicative
11:02:04 <Saizan__> PeakerWork: all Applicative expressions can be rewritten in a "normal form" like f <$> a <*> b <*> c ..., that looks pretty fundamental to me
11:02:08 <PeakerWork> maltem: I think the importance of Applicative over Functor is the ability to sequence effects together and combine computations -- none of that is implied by "Applicative"
11:02:12 <dons> ddarius: oh, yes, good point. i always get hung up on the accumulator
11:02:17 <stepcut> is there an option I can pass to runhaskell so that it will ignore my local package index and only use the system-wide libraries?
11:02:18 <dons> ddarius: feel free to elaborate.
11:02:26 * vincenz thinks that <*> is a poor name, given the implementation is liftA2 ($)
11:02:30 <lilac> PeakerWork: Applicative /is/ a generalization of application
11:02:31 <dons> maybe we can point to a wiki page by the end...
11:02:34 <vincenz> it should've been <$>, and the other $>
11:02:54 <lilac> vincenz: that sounds pretty sensible to me
11:03:14 <PeakerWork> Saizan: well, that's ok - but the name Applicative still does not capture the meaning as well as it could, IMO
11:03:17 <rwbarton> rovar: You basically import Data.Derive.Binary and Data.DeriveTH and then write $( derive makeBinary ''Foo ) in your program
11:03:26 <BMeph> vincenz: It's also liftA2 id.
11:03:46 <ddarius> dons: I don't have a reddit account.
11:03:49 <maltem> PeakerWork: I'm in a mood to disagree  ;), so let me state that you're going to name the class after its usage, not after what its definition suggests
11:04:05 <vincenz> BMeph: true, but I like liftA2 ($) better, it more clearly specifies what it does
11:04:10 <PeakerWork> vincenz: I agree, f $> g <$> h  is nicer
11:04:33 <PeakerWork> maltem: the fact it allows for combining computations and sequencing effects is not just how its used, I think its its fundamental meaning
11:04:51 <pilkarn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1450#a1450 <- so how do I unlazy it?
11:05:21 <Saizan> i guess * was used because of liftA2 (,) :: (F a * F b) -> F (a * b)
11:06:33 <lilac> > let ($>) = fmap; (<$>) = (<*>); f <$ x = fmap ($x) f in (,,) $> [1,2,3] <$ 4 <$> [5,6]
11:06:35 <lambdabot>   [(1,4,5),(1,4,6),(2,4,5),(2,4,6),(3,4,5),(3,4,6)]
11:07:10 <tdanecker> hi, how could I type something like that:
11:07:15 <tdanecker> test :: Num a => (a -> a -> a) -> Integer -> Integer -> Double -> Double -> (Integer, Double)
11:07:17 <tdanecker> test op ix iy dx dy = (op ix iy, op dx dy)
11:07:38 <lilac> tdanecker: that's the wrong type
11:07:43 <vincenz> PeakerWork: out of curiousity, was that sarcasm? :)
11:07:46 <tdanecker> i know
11:07:51 <tdanecker> but what's the correct one?
11:07:56 <tdanecker> is there a correct one?
11:07:59 <lilac> tdanecker: test :: (forall a. Num a => a -> a -> a) -> Integer -> Integer -> Double -> Double -> (Integer, Double)
11:08:05 <PeakerWork> vincenz: No
11:08:15 <PeakerWork> vincenz: I had similar thoughts too
11:08:16 <lilac> tdanecker: but that'll need {-# LANGUAGE ExistantialQuantification #-} at least
11:08:29 <PeakerWork> vincenz: perhaps liftA2 can be $>> too
11:08:36 <rwbarton> I think Rank2Types would be the least. :)
11:08:37 <tdanecker> hmm
11:08:37 <pilkarn> it seems divide causes the stack overflow
11:08:57 <pilkarn> lilac: how can I seq annotate divide?
11:09:13 <PeakerWork> vincenz: I think someone ought to think up a good naming scheme for operators for Haskell' that makes enough sense that you can guess an operator name by what you want it to do and knowing some simple rules :)
11:09:16 <lilac> pilkarn: can you paste your source code?
11:09:23 <PeakerWork> vincenz: at least for fmap and friends
11:09:23 <vincenz> PeakerWork: I agree
11:09:27 <maltem> PeakerWork: Actually, as I come to think of it, many people seem to prefer to name things the way you do. E.g. imaginary numbers are called after the ability to imagine certain solutions to equations.
11:09:29 <wli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1451#a1451 <-- monadic modular arithmetic
11:09:29 <vincenz> fmap is a bad name
11:09:31 <vincenz> every time I see
11:09:32 <tdanecker> lilac: I was afraid so, but thx anyways
11:09:33 <pilkarn> i did
11:09:36 <vincenz> fmap fmap fmap, I think of fwap fwap fwap
11:09:40 <pilkarn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1450#a1450
11:09:45 <wli> vincenz: It used to e called just "map"
11:09:50 <pilkarn> take 5 $ fst $ divide [1..1000000]
11:09:50 <pilkarn> *** Exception: stack overflow
11:10:23 <ehird> how can I import a data type with the ffi?
11:10:25 <ehird> e.g. a struct
11:10:39 <mathijs> Cale: you there?
11:10:48 <BMeph> PeakerWork: That sounds like asking for trouble: especially that "knowing some simple rules" bit.
11:11:03 <pilkarn> shouldnt ghc --make -O2 Sort.hs create an .exe?
11:11:06 <lilac> > let divide [] = ([],[]); divide [x] = ([x],[]); divide (x:y:zs) = (x:) *** (y:) $ divide zs in take 5 . fst $ divide [1..]
11:11:08 <lambdabot>   [1,3,5,7,9]
11:11:18 <dons> pilkarn: if you define 'main'
11:11:33 <rovar> rwbarton:  I keep getting parse error on $, do I need to load ghci in a special manner?
11:11:43 <maltem> pilkarn: only if Sort.hs contains module Main
11:11:47 <rwbarton> rovar: oh and add {-# LANGUAGE TemplateHaskell #-} to the top of your file
11:11:53 <lilac> pilkarn: looks OK to me :-/
11:11:54 <BMeph> ehird: Last I've heard, structs FAIL. :\
11:11:59 <Cale> mathijs: Ohayou gozaimasu.
11:12:05 <ehird> BMeph: but but but bunnies :<
11:12:17 <BMeph> ehird: ...yeah. :\
11:12:19 <mathijs> Hi Cale :)
11:12:28 <Cale> hi
11:12:29 <rovar> that's what I was lookin for :)
11:13:02 * maltem is reminded of the one Japanese lesson he had once
11:13:03 <mathijs> I tried your inorder trick to get rid of (++) on qsort, but both algorithm on http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1415 are equally fast/slow
11:13:21 * BMeph tries to imagine how to say "Cale" nihongo-de: "Ke-u-ru", maybe?
11:13:24 <pilkarn> so can I only create exes named Main? cant I name it something else?
11:14:04 <mathijs> pilkarn: the exe is named the same as the file you try to compile. The file has to define a 'main' function though
11:14:07 <Cale> BMeph: ã±ã¼ã« perhaps
11:14:30 <cknapp> Can't you also give it an argument for what to name the output file?
11:14:57 <Cale> mathijs: That's interesting...
11:14:58 <mathijs> cknapp: that's possible to... -o I think
11:15:07 <cknapp> That's what I thought.
11:15:20 <ehird> how can I represent a pointer to anything with the ffi?
11:15:23 <ehird> that is, (void*)
11:15:23 <mathijs> Cale: well, not completely the same, but 0.3s difference on a test that took 22sec
11:15:26 <pilkarn> it did define a main
11:15:39 <Cale> mathijs: I suppose the time is dominated by partition.
11:15:52 <augustss_> pilkarn: There are two ways: either don't name your main module Main, or use the -main-is flag
11:16:22 <augustss_> pilkarn: by the first option I meant, don't name the file Main.hs
11:16:24 <Cale> mathijs: Are you printing the whole sorted list?
11:16:25 * wli is at a total loss to implement division for the arbitrary-precision naturals.
11:16:46 <pilkarn> i ahve Sort.hs which has main = do print 10, i compiel and i egt Sort.hs, Sort.o and Sort.hi but no exe and Main.exe is another old Main that doe ssomehting else
11:16:57 <ddarius> wli: Efficiently, I assume (?)
11:16:58 <mathijs> Cale: the strange thing is... compiled without optimization, the ++ version takes 22.2s and the other 21.8, but with -O2, the ++ version is _faster_ (8.9s vs 9.1s)
11:17:00 <augustss_> wli: what's your representation?
11:17:19 <wli> augustss: newtype Nat = Nat (Word32, [Word32])
11:17:28 <mathijs> Cale: nope, I don't output anything of it, just its length to make sure it completes it all
11:17:31 <augustss_> pilkarn: ghc -main-is Sort.main ...
11:17:43 <ddarius> If you don't particularly care about efficiency, you can use repeated subtraction.
11:17:46 <Cale> mathijs: Is that small difference statistically significant, I wonder.
11:17:56 <ddarius> You could use that as a reference implementation, if nothing else.
11:18:00 <mathijs> Cale: probable not
11:18:05 <Cale> mathijs: oh! You should ensure the elements get computed.
11:18:25 <mathijs> Cale: won't they get computed once I print the length?
11:18:28 <rovar> rwbarton: so how do I now execute makeBinary on a type?    my 1st guess   let f = makeBinary foo   doesn't seem to work
11:18:29 <Cale> I suppose they're going to be compared enough times...
11:18:38 <Cale> Yeah, length will probably do it...
11:18:39 <wli> ddarius: Trying to check the results for where any of the arbitrary precision affairs get used will take too long.
11:18:48 <augustss_> wli: look it up in Knuth volume 3.  But a I remember there is nothing incredibly clever available.
11:19:05 <rwbarton> rovar: put $( derive makeBinary ''Foo ) as a declaration in your program, it will get expanded to the Binary instance at compile time
11:19:06 <wli> I am separated from my books.
11:19:26 <mathijs> Cale: so you think partition is the expensive part, and replacing ++ by the thunking trick isn't noticable?
11:19:27 <pilkarn> ghc --make -O2 -main-is Sort.main Sort.hs -> C:\ghc\ghc-6.10.1/libHSrts.a(Main.o):Main.c:(.text+0x7): undefined reference to
11:19:27 <pilkarn> `__stginit_ZCMain'
11:19:41 <Cale> mathijs: Well, that would be the reasonable conclusion...
11:19:42 <augustss_> wli: use Newton-Raphson
11:19:44 <pilkarn> lilac: anyway did you look at divide? how can I add seq?
11:19:46 <Cale> Let me do some tests.
11:19:49 <maltem> pilkarn: Delete old object files and retry
11:19:53 <mathijs> Cale: wow, nice trick then! :P
11:19:59 <rovar> rwbarton: so it creates the Binary put/get instances?
11:20:13 <Cale> mathijs: ++ isn't always that bad.
11:20:14 <rwbarton> rovar: yes
11:20:21 <wli> I don't really know how to use Newton's method to implement it, either.
11:20:24 <rwbarton> rovar: you can compile with -ddump-splices (IIRC) to see what's happening
11:20:45 <lilac> pilkarn: divide doesn't stack overflow for me
11:20:50 <rwbarton> mathijs: Cale: the total cost of (++) should only be n log n here, right?
11:20:53 <mathijs> Cale: anyway, in my tests I had to increase the stack space
11:20:56 <rwbarton> assuming random input
11:20:57 <lilac> > let divide [] = ([],[]); divide [x] = ([x],[]); divide (x:y:zs) = (x:) *** (y:) $ divide zs in take 5 . fst $ divide [1..10000000]
11:20:59 <lambdabot>   [1,3,5,7,9]
11:21:08 <mathijs> rwbarton: it's random input
11:21:31 <augustss_> wli: It's the standard method for find roots to equations using Newton-Raphson.
11:21:32 <pilkarn> ah now it works
11:21:42 <mathijs> rwbarton: but still, by composing instead of ++'ing, it should be cheaper I hoped
11:21:48 <augustss_> wli: you can use wikipedia :)
11:21:48 <pilkarn> lilac: for [1000000,999999..0] ?
11:21:56 <wli> augustss: I've heard of it, but the expressions I get are wrong.
11:22:07 <rovar> rwbarton:  sweet:  let b = encode body   worked.
11:22:18 <augustss_> wli: you'll need multiplication and division by 2, if I remember right
11:22:21 <lilac> pilkarn: the contents of the list aren't going to make any difference, since divide ignores them
11:23:15 <pilkarn> hmm it does in ghci but not when compiled
11:23:36 <pilkarn> sure but i mean the nbr of elems
11:23:37 <rovar> rwbarton:  hot damn that's awesome. Haskell continues to impress the hell out of me.
11:23:51 <skorpan> are nested comments allowed in haskell?
11:23:53 <pilkarn> so whats the easiest way to time executiontime?
11:23:54 <rovar> c = decode b :: Body   works as expected
11:24:00 <skorpan> i.e. {- {- -} -}
11:24:22 <Apocalisp> skorpan: yes, they are
11:24:24 <rovar> pilkarn: if on posix:  time <my executable>
11:24:32 <mmorrow> , {- {- -} -} 42
11:24:32 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
11:24:33 <lunabot>  42
11:25:04 <Cale> rwbarton: yeah... I believe so.
11:25:29 <pilkarn> rover: vista
11:25:31 <mmorrow> rwbarton: sure i can do that
11:25:57 <mathijs> pilkarn: Microsoft Application Timer++ plugin for clippy :P
11:26:06 <lilac> pilkarn: i think the problem is your (***) is too strict
11:26:41 <lilac> pilkarn: either import (***) from Control.Arrow or define it as (f *** g) ~(a, b) = (f a, g b)
11:27:01 <Cale> Yeah, partitioning alone is 58% of the time, and 51% of the allocation for "quicksort".
11:27:23 <pilkarn> what does ~do?
11:27:25 <Cale> Oh, heh, and 30% of the time for my program was in main
11:27:30 <mmorrow> someone should do an ST quicksort
11:27:30 <Cale> (generating randoms)
11:27:44 <mathijs> Cale: ok, so that's about the same that I got.
11:27:47 <Cale> So 11% or so was left to the rest of quicksort.
11:27:52 <Gracenotes> mmorrow: STArray?
11:28:06 <mmorrow> well, i guess you'd still have to copy the initial list to an array
11:28:09 <mmorrow> Gracenotes: yes
11:28:16 <mathijs> Cale: but partitioning should be twice as fast as using filter right? (like most haskell quicksort demonstration use)
11:28:18 <mmorrow> Gracenotes: or even better and STUArray
11:28:22 <mmorrow> (if possible)
11:28:28 <Cale> mathijs: One would hope :)
11:28:31 <Gracenotes> that'd be nice, although not for any arbitrary ORd
11:28:35 <Gracenotes> *Ord
11:28:39 <Cale> mathijs: I don't think the compiler is quite *that* smart yet.
11:28:42 <mmorrow> (if possible ;)
11:29:25 <Gracenotes> it'd be pretty straightforward, methinks
11:29:33 <mmorrow> definitely
11:29:41 <mathijs> Cale: so the 11% didn't make that much of a difference
11:30:00 <paper_cc> can I install a development build of GHC on a system with libedit.so.2?
11:30:01 <pilkarn> Cale: hmm i was thinking about that
11:30:02 <Cale> In the 'qsort' version, qsort itself is down to 3.8% here, and partitioning takes 63% of the time.
11:30:20 <Cale> But, I'm not optimising when I profile.
11:30:21 <mathijs> Cale: ok, 11 down to 3.8 sounds ok
11:30:47 <Cale> GHC has RULES pragmas involving (++) and it's possible they are firing, I'll have to check :)
11:30:49 <sjanssen> mmorrow: augustss_ has a nice blog post with an array quicksort
11:30:54 <Gracenotes> @shootout
11:30:54 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
11:31:00 <mmorrow> sjanssen: oh nice
11:31:12 <mathijs> Cale: where can I find the default RULES ?
11:31:13 <mmorrow> sjanssen: ooh yeah, i remember now
11:31:19 <pilkarn> profiling, is that something i run with or compile with?
11:31:20 <mathijs> Cale: or turn them off
11:31:21 <pilkarn> http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/prof-time-options.html
11:31:34 <augustss_> wli: http://en.wikipedia.org/wiki/Division_(digital)
11:32:01 <lilac> pilkarn: ~ does lazy pattern matching (it means, 'assume this pattern matches, and produce an error when values within the pattern are forced if it turns out it didn't')
11:32:34 <wli> I'm having trouble translating the Newton affair into integer terms.
11:32:45 <Cale> Oh, curious, after optimisation, the quicksort with (++) ends up taking 38.7% of the time to partition's 32%. But it's hard to trust results of profiling after optimisation too much.
11:32:54 <mmorrow> http://augustss.blogspot.com/2007_08_01_archive.html
11:33:06 <augustss_> wli: yeah, it only works with certain intervals, I think
11:33:10 * Gracenotes is still bugged out about our pidigits performance.. :/
11:33:14 <mathijs> Cale: I used O2, that's maximum right?
11:33:14 <pilkarn> Cale: how do I profile time? not relative time but the exact execution time of the program
11:33:26 <augustss_> Gracenotes: fix the ghc bug :)
11:33:27 <Gracenotes> oh, has it gotten better?
11:33:48 <sjanssen> @where hpaste
11:33:48 <lambdabot> http://hpaste.org/
11:33:49 <Cale> mathijs: yeah
11:33:51 <sjanssen> @where hpaste2
11:33:51 <lambdabot> http://hpaste.org/
11:33:54 <mathijs> pilkarn: 'time ./MyProgram' on posix or cygwin
11:34:12 <pumpkin_> I can't believe that the typeclassopedia has had so many downvotes on reddit
11:34:14 <Gracenotes> augustss_: easy enough for you to say!
11:34:45 <augustss_> pumpkin: anything with FP and especially Haskell gets downvoted
11:34:57 <mmorrow> Gracenotes: dolio has a hackage pkg with a bunch of sorts using uvector, too
11:34:59 <pumpkin_> augustss_: this one seems more downvoted than usual
11:34:59 <wli> augustss: Mostly I've tried and failed to implement grade school -style division.
11:35:06 <mmorrow> , [$ty| sort |]
11:35:08 <lilac> pumpkin_: to be fair, the diagram is missing an arrow from ArrowChoice to ArrowApply
11:35:09 <lunabot>  forall a b . (UA b, Ord b) => MUArr b a -> ST a ()
11:35:10 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1415#a1416
11:35:20 <mmorrow> iirc that's heapsort
11:35:26 <pumpkin_> lilac: aha, I'm sure all 14 downvotes are because of that! shame on byorgey_
11:35:29 <pumpkin_> :)
11:35:42 <lilac> pumpkin_: there's also a sentence half way through that's unfinished
11:35:43 <Cale> So yeah, there's at least one rule related to (++) which is firing under optimisation.
11:35:51 <augustss_> pumpkin_: no, it's pretty normal
11:35:52 <Gracenotes> hm, this could easily use an STUArray: http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=ghc&id=3
11:35:54 <Cale> So it's possible the (++) goes away entirely anyway.
11:36:00 <michaelcdever>  there is a function for only getting the distinct elements in a list isnt there?
11:36:08 <mmorrow> nub
11:36:10 <Cale> I'll have to look at the libraries source code to see what the rule is.
11:36:14 <pilkarn> IS THERE NO WAY TO JUST TIME HOW LONG A PROGRAM TOOK TO EXECUTE?
11:36:15 <wli> augustss: I succeeded a couple of times early on, but at some point could no longer do it.
11:36:18 * Gracenotes tries it
11:36:25 <augustss_> wli: that should work
11:36:27 <Gracenotes> pilkarn: :set +s
11:36:30 <mathijs> Cale: is there a way to disable rules?
11:36:32 <Gracenotes> or, on Unix, time
11:36:34 <wli> michaelcdever: nub
11:36:35 <mmorrow> pilkarn: get a real OS ;)
11:36:46 <pilkarn> grace: where? when i compile or when i run? i use vista
11:36:52 <michaelcdever> thanks, was trying to remember the name of it
11:36:56 <Cale> mathijs: Turn optimisation off? :) Actually, there's possibly another way... I'll have to look.
11:37:04 <wli> michaelcdever: It's usually faster to do map head . group . sort if you have Ord and not just Eq.
11:37:16 <mathijs> Cale: ok, so RULES are just for optimization?
11:37:17 <Cale> ah  -fno-rewrite-rules
11:37:18 <augustss_> pilkarn: use System.Timeit.timeit
11:37:19 <Gracenotes> pilkarn: set +s is a ghci option.. for running, try download time from http://gnuwin32.sourceforge.net/
11:37:21 <pilkarn> mmorrow: i have, you tell it to get a decent wireless installtion system
11:37:22 <lilac> pumpkin_: "Also, note that although _ >> m = m would be a type-correct implementation of (>>), it"
11:37:26 <pilkarn> ^^ ubuntu
11:37:27 <augustss_> pilkarn: package timeit
11:37:29 <sjanssen> Cale: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1415#a1417 does this help?
11:37:32 <mmorrow> pilkarn: :)
11:37:36 <pumpkin_> lilac: yeah :) he does say it's a draft though
11:37:36 <Cale> mathijs: You could abuse them for more than that, but yeah, they're for rewriting the code.
11:37:37 <lilac> pumpkin_: i felt disappointed the way this paragraph ended :)
11:37:41 <Gracenotes> pilkarn: in fact, download everything else from http://gnuwin32.sourceforge.net/, you'll be glad you did
11:37:42 <pumpkin_> aw
11:37:44 <Gracenotes> ;)
11:38:04 <lilac> pumpkin_: also, why he be up n dissin 'fail'
11:38:06 <michaelcdever> wli thanks, im just doing it on a list of strings, but its a function that will be used very rarely so.. speed isn't all that important this time
11:38:27 <pumpkin_> lilac: cause it's missing an "epic" higher-order function, duh
11:38:30 <wli> michaelcdever: Lists of strings can use map head . group . sort
11:38:49 <Cale> sjanssen: What we're really wondering is why the (++) version is so efficient. (So that the (.) trick doesn't seem to buy much)
11:39:01 <sjanssen> hmm
11:39:09 <Cale> sjanssen: But I can try that version if you want.
11:40:02 <augustss_> Cale: which algorithm?
11:40:06 <sjanssen> "foldr/app"     [1] forall ys. foldr (:) ys = \xs -> xs ++ ys
11:40:22 <sjanssen> "++"    [~1] forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) y
11:40:29 <Cale> augustss_: we're comparing the implementations here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1415
11:40:50 <lilac> pumpkin_: epic :: (forall m :: * -> *, a :: *. String -> m a) -> String -> (String, m a)
11:40:50 <Cale> sjanssen: Ah, so as I suspected, it's fusing away the (++) anyway.
11:40:58 <lilac> pumpkin_: 'epic fail' is then an epic fail morphism
11:41:01 <pumpkin_> there we go!
11:41:11 <sjanssen> Cale: actually, no
11:41:19 <pumpkin_> lilac: you should propose that as an amendment to his article :)
11:41:25 <lilac> pumpkin_: (in the sense of being an epimorphism...)
11:41:47 <sjanssen> Cale: the "++" rule turns (++) into a fusible form, "foldr/app" turns it back into the non-fusible form
11:41:54 * lilac thinks 'epic' needs more work :/
11:41:59 <Cale> oh...
11:42:12 <Cale> right, yeah.
11:42:15 <augustss_> ++ in quicksort doesn't really matter that much.  It won't make it go quadratic.
11:42:37 <hackage> Uploaded to hackage: Hipmunk 0.2.1
11:43:09 <Cale> augustss_: that's true, though I'd still expect turning linear-time bits into constant time bits to produce *some* improvement.
11:44:02 <augustss_> function composition forces thunks to be built that will involve calling unknown functions, which is expensive
11:45:11 <sjanssen> Cale: do you get a speed-up if you write quicksort in the worker-wrapper style?
11:45:16 <augustss_> try an accumulating parameter instead
11:45:18 <sjanssen> this will allow GHC to inline and specialize it
11:45:51 <mathijs> sjanssen: worker-wrapper?
11:46:01 <augustss_> or maybe ghcs does eta expansion of . anyway
11:46:04 <chessguy> @src foldr
11:46:04 <lambdabot> foldr f z []     = z
11:46:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:46:10 <sjanssen> mathijs: function = go where go = ...
11:46:11 <Cale> (It's really mathijs' question, btw :)
11:46:15 <chessguy> @src foldl'
11:46:15 <lambdabot> foldl' f a []     = a
11:46:15 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:46:33 <chessguy> hm, i though t foldr was defined in worker/wrapper style on LB
11:46:38 <chessguy> @rc fldl
11:46:38 <lambdabot> Not enough privileges
11:46:45 <chessguy> @src foldl
11:46:45 <lambdabot> foldl f z []     = z
11:46:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:46:50 * chessguy shrugs
11:46:53 <Cale> chessguy: It is in GHC, I changed the definition in LB to the more readable one.
11:46:57 <mathijs> sjanssen: ah... like your partition variant
11:47:01 <chessguy> Cale, ah
11:47:04 <sjanssen> mathijs: exactly
11:47:43 <mathijs> sjanssen: qsort is in that style
11:47:59 <sjanssen> mathijs: but quicksort isn't
11:49:40 <mathijs> sjanssen: true, but I was trying the composition-style to see if it's faster. I noted it isn't faster (almost nothing), so 'improving' quicksort isn't gonna change that I think :)
11:49:43 <wli> I think where I bomb on implementing grade school division is figuring out digit-by-digit values.
11:50:30 <augustss_> mathijs: can you try the version I just added and see if it makes a difference?
11:50:46 <sjanssen> Cale, mathijs: what sort of data are you testing on?
11:51:39 <augustss_> wli: use regular division to guess, e.g., dividing the first 32 bits with the first 16 bits gives a good 16 bit guess
11:51:45 <mathijs> sjanssen: a random list of 1000000 integers between 0 and 1000000
11:52:19 <mathijs> augustss_: where can I find it?
11:52:24 <wli> Yeah, I get the guesses, but run out of steam trying to correct them.
11:52:31 <augustss_> mathijs: same hpaste as before
11:52:48 <augustss_> mathijs: moonpatio, I mean
11:52:51 <mathijs> augustss_: ah... got it :)
11:54:08 <wli> I have a pretty good idea of what I want to do, I just don't seem to be able to actually pull it off.
11:54:33 <mathijs> augustss_: not in scope a
11:54:42 <Gracenotes> hm. I wonder why http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=ghc&id=3 is taking 50-something seconds on my machine :/
11:55:00 <Gracenotes> I only have 2 cores, but still, really..
11:55:02 <augustss_> mathijs: oops, add an 'a' att the end of the second aqsort' equation
11:55:10 <mathijs> augustss_: thought so :)
11:55:36 <augustss_> mathijs: it's just an eta expansion of the version with .
11:57:41 <mathijs> augustss_: the optimized version (O2) is a little bit faster than the other 2, non-optimized still the same though
11:59:16 <augustss_> augustss_: well, my next suggestion for qsort is rather drastic and ugly :)
11:59:29 <mathijs> augustss_: won't the compiler be smart enough to do eta expansion itself in this case?
11:59:36 <dons> mm. sml should never beat us. sounds like the accepted algorithms have changed in that entry
11:59:43 <augustss_> mathijs: I don't know.  I'd hope so.
12:00:17 <dons> here's a demo of the haskell-hipmunk 2D physics library, http://archhaskell.wordpress.com/2009/02/16/hipmunk-2d-physics-for-haskell/
12:00:22 <dons> (video)
12:00:47 <jpcooper> @pl (\ (x : _) -> map (x :) rest)
12:00:48 <lambdabot> flip map rest . (:) . head
12:01:20 <mathijs> dons: accompanied by appollo 13 soundtrack? :P
12:01:26 <erikc> haha
12:01:34 <dons> no soundtrack... (?)
12:01:47 <dons> oh, i missed that movie
12:02:27 <mathijs> dons: no, not the movie, the sound just sounds like space-communication (distorted)
12:02:43 <mathijs> dons: it looks quite cool though
12:03:06 <dons> interesting, this one came up in reasonable quality too, mm, http://www.youtube.com/watch?v=UPiWY_pYAhs
12:03:11 <Gracenotes> would it be feasible to make a multi-threaded State monad?
12:03:24 <Gracenotes> one that would perhaps use an MVar, but not one you had to explicitly deal with
12:03:33 <ManateeLazyCat> How to use hoogle generate all *module* information, such as "GHC module"
12:04:10 <ManateeLazyCat> I have implement auto-complete Haskell *keyword* in Emacs, now i need all *GHC module list* for completion.
12:04:29 <Gracenotes> it seems most monads would not go well at all with several threads :)
12:04:54 <Gracenotes> an exception being Reader (via ReaderT)
12:05:05 <mathijs> augustss_: so what's your next suggestion? is it still good enough to look at? or would it look like ASM?
12:05:15 <ManateeLazyCat> hoogle support *regular expression search* ?
12:05:31 <wli> I imagine it'd only be useful when you can partition it into things you can access in parallel.
12:05:34 <MyCatVerbs> ManateeLazyCat: Hoogle doesn't AFAIK generate all that information by itself, but it takes that information as input.
12:06:08 <ManateeLazyCat> MyCatVerbs: Example I want got all module information list.
12:06:13 <MyCatVerbs> ManateeLazyCat: Hoogle doesn't have regular expression search, AFAIK. It's meant for searching by types or names rather than by wildcards on names.
12:06:22 <MyCatVerbs> (ndm may feel free to contradict me. ;)
12:06:24 * ManateeLazyCat pasted "module list" at http://paste2.org/get/148367
12:06:42 <ManateeLazyCat> MyCatVerbs: Above my module list,
12:06:51 <ManateeLazyCat> MyCatVerbs: But i hate *hard code* it.
12:07:06 <MyCatVerbs> Read it from an input file.
12:07:07 <ManateeLazyCat> MyCatVerbs: I want hoogle return all module list.
12:07:10 <augustss_> mathijs: the next step I'd do (and did many, many years ago) is to change partition.  Instead of building a pair of lists it has two accumulating parameters and when it reaches the end of the list it tail calls (some variation of) qsort to finish the sorting.
12:07:28 <ManateeLazyCat> MyCatVerbs: Input file? Sorry?
12:07:38 <Saizan> Gracenotes: you can use ReaderT (MVar s) IO and implement MonadState on it
12:07:55 <Gracenotes> oh, that sounds good
12:08:13 <MyCatVerbs> ManateeLazyCat: you need Haddock. Haddock has an option to generate the information that Hoogle uses.
12:08:14 <mathijs> augustss_: so that basically combines the partitioning and sorting?
12:08:32 <augustss_> mathijs: kinda
12:08:51 <sjanssen> augustss_: is the tail call strictly necessary?
12:09:09 <ManateeLazyCat> MyCatVerbs: Haddock can support all feature that hoogle can generate?
12:09:20 <rwbarton> ManateeLazyCat: Doesn't the 'hoogle --dump --data=.cabal/share/hoogle-4.0.0.5/ghc.hoo' output include a list of modules?  (under "== Modules ==" near the top)
12:09:26 <MyCatVerbs> ManateeLazyCat: Haddock generates the database that Hoogle needs to use.
12:09:27 <augustss_> sjanssen: nah, you can probably return the two lists as a pair
12:09:53 <augustss_> the sort will no longer be stable, of course, unless you play more tricks
12:10:16 <sjanssen> augustss_: I'm trying that trick now
12:10:21 <sjanssen> I will post results in a minute or so
12:10:43 <mathijs> augustss_: in that case I'll stick to this. the partition part is very clear, mixing it up with sorting itself feels bad. Optimizations are enough for now, and future ghc optimization features might speed it up further. No need to un-clearify the code I think :)
12:11:06 <augustss_> mathijs: Here's a version to try: http://www.augustsson.net/Darcs/Djinn/Djinn/Util/Sort.hs
12:11:27 <augustss_> As long as you don't mind running code that Galois has stolen from me.
12:12:22 <sjanssen> mathijs, Cale, augustss_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1452#a1453
12:12:41 <ManateeLazyCat> rwbarton: But i need *all modules*, not *match* part, have a way convert .hoo file to .txt file?
12:12:54 <sjanssen> accumulating parameter is faster than composition, which is faster than naive appending
12:13:45 <augustss_> sjanssen: sort +3, perhaps?
12:13:45 <rwbarton> ManateeLazyCat: I have no idea what you mean
12:13:59 <ManateeLazyCat> rwbarton: ghc.hoo have information i want, but if can convert it to .txt file, that be good.
12:14:10 <sjanssen> augustss_: oh, good idea
12:14:17 <rwbarton> ManateeLazyCat: it should be trivial to process the output of that hoogle command to get what you want, if the information is there.
12:15:13 <ErhardtMundt> hey, i have a problem here
12:15:28 <ManateeLazyCat> rwbarton: For auto-complete performance in Emacs, i need got *list* first, then i can just search list, and don't need generate list each tiem.
12:15:31 <ManateeLazyCat> each time
12:15:36 <ErhardtMundt> phase :: (Num a) => (a, a) -> a
12:15:36 <ErhardtMundt> <interactive>:1:0: Not in scope: `phase'
12:16:14 <roconnor> ((,)e) isn't a pointed functor
12:16:28 <FlightOfStairs> hello. I'm learning haskell at university - not done much so far. I need to make a random number and have found the random module. Can anyone show me how I might go about an IO Int into just an int to use in a function?
12:16:44 <FlightOfStairs> *making an IO int
12:16:45 <augustss_> roconnor: is it a stick in the eye?
12:17:03 <Cheshire> FlightOfStairs, if f :: Int -> String and i :: IO Int then    do r <- i ; print (f r)
12:17:14 <tehgeekmeister> are IntMap and IntSet significantly more efficient than Map and Set?
12:17:16 <ErhardtMundt> augustss_, can you help me?
12:17:21 <roconnor> augustss_: according to typeclassopedia, a pointed functor is a functor with a pure :: a -> f a function
12:17:23 <pumpkin_> tehgeekmeister: quite
12:17:30 <augustss_> ErhardtMundt: :m +Data.Complex
12:17:36 <FlightOfStairs> thanks
12:17:53 <tehgeekmeister> pumpkin_: okay, thanks
12:17:57 <ErhardtMundt> augustss_, i am just learning haskell
12:18:04 <Deewiant> ErhardtMundt: you can't paste declarations into GHCi
12:18:14 <Deewiant> it looks like you're trying to do that
12:18:16 <ErhardtMundt> and i tried to make some silly function
12:18:22 <augustss_> roconnor: yes, but I was just trying to make sense of the emoticon ((,)e)   :)
12:18:22 <ErhardtMundt> Deewiant, indeed
12:18:26 <Deewiant> ErhardtMundt: put it in a file
12:18:49 <ErhardtMundt> Deewiant, and what about 'let' function?
12:19:01 <augustss_> ErhardtMundt: ah, yes.  I just told you where you could find phase already :)
12:19:30 <Deewiant> ErhardtMundt: you can do "let phase :: Num a => (a, a) -> a; phase = ..." in GHCi but if you e.g. reload a file you're working on you'll lose all your old definitions
12:19:37 <dons> mathijs: oh, that's really weird -- i had my sound off
12:19:45 <dons> wtf is there an apollo sound track on my video!?
12:19:52 <mathijs> sjanssen: I'm getting compilation/linking errors
12:20:00 <ErhardtMundt> augustss_, yes, i got it, thanks anyway ;)
12:20:12 <ErhardtMundt> Deewiant, so let is for interactive use only?
12:20:13 <Deewiant> dons: it was your video? I just saw it, the sound makes it pretty painful to watch actually :-P
12:20:17 <dons> :(
12:20:19 <dons> fixing.
12:20:26 <augustss_> dons: you'd think the Apollo would need more than 2D physics...
12:20:28 <mathijs> sjanssen: can you run it again with higher numbers?
12:20:30 <dons> youtube bug, swapping in random sound tracks?
12:21:27 <Ralith> has anyone written some sort of wrapper to openssl that is as simple to use as connectTo?
12:21:31 <Deewiant> ErhardtMundt: no, it's just that the context in which your GHCi commands are executed (essentially a 'do' block in the IO monad, in case you're interested) happens to accept it
12:22:00 <roconnor> augustss_: :D
12:22:21 <sjanssen> mathijs: you probable need to install 'timeit' from hackage
12:22:28 <mathijs> sjanssen: did that
12:22:45 <ehird> anyone used c2hs? how can it be coerced into accepting c99-style comments?
12:22:50 <mathijs> qs.o: In function `rMi_info':
12:22:51 <Deewiant> ErhardtMundt: that is to say, 'let' does work in many other contexts as well.
12:22:51 <ErhardtMundt> Deewiant, the function 'let' is bound to GHC implementation or it's a standard function?
12:22:52 <mathijs> (.text+0x922): undefined reference to `parallelzm1zi1zi0zi0_ControlziParallelziStrategies_zdf3_closure'
12:23:01 <Deewiant> ErhardtMundt: it's not a function, it's a syntactic construct.
12:23:19 <augustss_> mathijs: -make
12:23:23 <Deewiant> augustss_: --make
12:23:30 <Ralith> ehird: regexps that convert c99-style into c89-style, perhaps?
12:23:33 <ErhardtMundt> Deewiant, what is the difference?
12:23:40 * augustss_ bashes the - key harder
12:23:42 <sjanssen> mathijs: are you compiling with --make?
12:23:43 <mathijs> augustss_: thanks, forgot that :)
12:23:43 <Deewiant> > let f x = x + 1 in f 3
12:23:46 <lambdabot>   4
12:23:55 <sjanssen> mathijs: also be sure to pass -O2
12:24:04 <Deewiant> ErhardtMundt: f is a function, 'let' and 'in' are syntax
12:24:10 <dons> this sound track thing is just bizarre
12:24:25 <mmorrow> preflex: zdec parallelzm1zi1zi0zi0_ControlziParallelziStrategies_zdf3_closure
12:24:26 <preflex>  parallel-1.1.0.0_Control.Parallel.Strategies_$f3_closure
12:24:32 <augustss_> dons: gives it all a spacy feel
12:24:35 <Deewiant> ErhardtMundt: (of course it's all syntax in some sense of the word, I'm not an expert in describing this stuff)
12:24:54 <augustss_> Deewiant: keyword
12:25:11 <Deewiant> augustss_: yeah, but that's not quite what I was going for
12:25:13 <ErhardtMundt> Deewiant, ok, i got it, now, may i find let only in GHC or it's in some Haskell standard?
12:25:22 <dons> its really weird. why did the videos all get a bizarre soundtrack
12:25:24 <Deewiant> ErhardtMundt: let is standard.
12:25:43 * Baughn wonders how to convince gcc to run on the gpu.. there are 32 idle cores, even if they're slow it's still better than nothing
12:25:52 <Deewiant> ErhardtMundt: GHC only accepts standard Haskell 98 by default, you have to pass it flags or have a pragma in your source code to make it accept something nonstandard
12:26:00 <rwbarton> But the fact that you can write "let x = 3" at the ghci top-level is not standard.  There's no standard for Haskell interpreter user interfaces.
12:26:13 <ErhardtMundt> Deewiant, last question (for now): is there any way to *dump* the functions i just defined interactively?
12:26:24 <Baughn> ErhardtMundt: Mind you, it'll usually conveniently tell you what extensions to use, if using one would legalize your program
12:26:25 <Deewiant> ErhardtMundt: I don't know.
12:26:32 <augustss_> ErhardtMundt: no
12:26:45 <rwbarton> ErhardtMundt: No, that's why you should define your functions in a file and load the file instead :)
12:26:45 <Ralith> ErhardtMundt: copy/paste!
12:26:51 <augustss_> ErhardtMundt: that's why you put them in a file.
12:26:59 <ErhardtMundt> okay
12:27:16 <Deewiant> ErhardtMundt: repeated application of the up arrow key, maybe? ;-)
12:27:30 <wli> I liked how hbi let you define data structures at the prompt.
12:27:33 <ErhardtMundt> and i'd prefer to write only standard programs
12:27:50 <ErhardtMundt> Deewiant, nah, just curiosity :)
12:28:05 <wli> ML repl's tend to let you do that as well.
12:28:07 <ErhardtMundt> thank you guys :D
12:28:22 <augustss_> It's amazing that as poor a user interface as ghci is, it is still popular.
12:28:33 <mmorrow> totally
12:28:37 <wli> I tried to figure out what was keeping ghci from doing it at one point and failed.
12:28:43 <mmorrow> it's all there is is why i think
12:28:44 <Deewiant> I don't use GHCi much.
12:28:58 <mmorrow> i use ghci all the time
12:29:01 <augustss_> Me neither
12:29:06 <ErhardtMundt> i'm using it only because i need to try what i read
12:29:07 <ErhardtMundt> :)
12:29:08 <Deewiant> But yeah, the most likely reason it's popular is that it's the only interpreter that supports the GHC extensions :-P
12:29:20 <mathijs> sjanssen: damn... OOMkiller kicked in :)
12:29:22 <mmorrow> Deewiant, augustss_: what do you use? nothing?
12:29:29 <augustss_> mmorrow: ghc
12:29:31 <mathijs> sjanssen: but I survived :P
12:29:42 <Deewiant> mmorrow: nothing or GHC
12:29:42 <ErhardtMundt> anyway, a readline-like behaviour would be appreciated
12:29:43 <ErhardtMundt> :D
12:29:50 <Baughn> augustss_: ghci is still a better user interface than /no/ ghci.. not to mention, it works better than python's interpreter
12:29:51 <wli> It'd be nice if the user interface were spruced up at some point.
12:29:54 <sjanssen> mathijs: yeah, I have to kill firefox before running trials :)
12:30:09 <mmorrow> augustss_: wow, i heavily use the interactive intderp at all times while programming
12:30:09 <Deewiant> mmorrow: what do you use GHCi for?
12:30:20 <Baughn> augustss_: Actually, I'm not aware of any interpreter that outdoes it for standard language. SLIME and DrScheme, sure, but those aren't "standard"
12:30:30 <augustss_> Baughn: it's better than nothing.  But considering that it's worse than the Haskell uis that came before is sad.
12:31:03 <CTA> Hey guys, I'm still looking for GHC.. I'm in my folder where the GHCi app is, and when I click on ghc.exe a command prompt opens and then just closes..
12:31:03 <Baughn> augustss_: Up until I read that last sentence, I had no idea such things ever existed. :/
12:31:29 <sjanssen> CTA: try clicking on ghci instead
12:31:30 <augustss_> Yale Haskell had a slick one.  hbi was similar to ghci, but allowed any top level declarations.
12:31:31 * ErhardtMundt is back to his studies
12:31:40 <mmorrow> Deewiant: :info, :type, to test/incrementally develop ideas, as a "super" sh, using haskell + db libs as a "super" sql shell, ....
12:31:48 <CTA> I want the GHC actually compiler though?
12:32:01 <sjanssen> CTA: then you'll need to call it from a command prompt
12:32:02 <Deewiant> I use the docs / hoogle for :type
12:32:09 <CTA> How?
12:32:10 <Deewiant> I don't really use :info at all
12:32:16 <wli> The ML repl's let you define modules at the prompt, among other things like types, signatures, etc.
12:32:27 <mmorrow> Deewiant: docs/hoogle can't tell you the type of an arbitrary expression
12:32:30 <augustss_> wli: as it should be
12:32:35 <sjanssen> CTA: I'm not really a Windows person, but something like "ghc --make foo.hs"
12:32:53 <Deewiant> mmorrow: I don't need that very often.
12:33:12 <CTA> not in scope ghc not in scope..
12:33:30 <mathijs> CTA: run ghc from the console
12:33:41 <CTA> I dont know how to
12:34:03 <Saizan> CTA: start menu -> run -> type cmd.exe and press enter
12:34:04 <mathijs> CTA: just open a terminal window (start -> run -> cmd I think)
12:34:07 <sjanssen> CTA: I think Real World Haskell can help you out
12:34:09 <BMeph> CTA: 1) Hit "Start"
12:34:12 <augustss_> CTA: open a DOS box, type 'ghc --make foo.hs'
12:34:15 <Deewiant> I do use GHCi for quick testing if I have a toplevel function I can't immediately integrate into a main function or a proper test case/property
12:34:17 <BMeph> CTA: 2) Hit "Run..."
12:34:31 <BMeph> ... 3) ????   4) PROFIT! ;p
12:34:56 <wli> I've never successfully patched ghc.
12:35:11 <augustss_> patched?
12:35:12 <pilkarn> so if i want to do 2d graphics in clojure, what is the easiest way?
12:35:16 <pilkarn> opengl?
12:35:19 <BMeph> CTA: Seriously, now, 3) type "cmd", then click "OK".
12:35:27 <pilkarn> what do i need to do open gl?
12:35:28 <pilkarn> glut?
12:35:49 * Twey blinks.
12:35:49 <CTA> so i have to have the file foo.hs created? just it says cannot find it
12:35:50 <BMeph> CTA: And yes, 4) PROFIT!
12:36:01 <ErhardtMundt> what's the syntax to load a source file? :m +test ?
12:36:19 <ErhardtMundt> assuming i am in the same folder test.hs is
12:36:34 <Twey> pilkarn: This is #haskell :-P
12:36:38 <augustss_> ErhardtMundt: :l mod.hs
12:36:45 <BMeph> CTA: Wait, you haven't written your program yet?
12:36:46 <ErhardtMundt> thanks augustss_
12:36:53 <augustss_> ErhardtMundt: And then just ':r' when you need to reload
12:37:41 <mathijs> CTA: just navigate the console prompt to the 'folder' that your foo.hs file is in (using cd)
12:37:56 <CTA> I mean, I don't know what to do, I mean like do I just write my code straight into ghci like i've being doing? or is there a compiler where i can write the code
12:38:30 <mathijs> CTA: you write your code in a text editor (like notepad), save it, and compile it
12:38:47 <monochrom> use your favourite editor to enter code into a file. then tell ghci to load it or tell ghc to compile it.
12:38:48 <CTA> ah
12:38:57 <Twey> CTA: Write your code into a file, then load it into GHCi with :l \path\to\yourfile.hs to play with it interactively, or compile it with ghc --make \path\to\yourfile.hs to compile it
12:39:03 <CTA> how do I tell cmd where my file is?
12:39:10 <pumpkin_> you use a path
12:39:13 <mathijs> where is it?
12:39:31 <monochrom> "it's on my computer"  <duck>
12:39:45 <mathijs> in 'briefcase' :)
12:40:03 <CTA> No, I mean how do I tell it what path it's in?
12:40:25 <Deewiant> cd <path>
12:40:40 <Deewiant> if path is on a different drive, change to drive with '<drive letter>:'
12:40:50 <mathijs> CTA: well, suppose you saved it in "My documents\My first Haskell Project" you have to cd "c:\Documents and Settings\CTA\My documents\My first Haskell Project"
12:40:50 <Deewiant> (without the <>'s)
12:41:31 <Deewiant> or quicker, cd "%USERPROFILE%\My Documents\My first Haskell Project"
12:41:32 <mathijs> CTA: I believe there's some shell extension for windows that lets you right click in a folder and select 'console from here'
12:41:47 <Deewiant> in Vista, shift-right-click
12:42:13 <tehgeekmeister> are functions defined in a let statement inside a do block of a function in the scope of functions defined in a where clause of the same function?
12:42:23 <Deewiant> tehgeekmeister: no.
12:42:31 <tehgeekmeister> ah man.
12:42:37 <hackage> Uploaded to hackage: TinyURL 0.1.0
12:42:38 <monochrom> Deewiant: sweet.
12:42:41 <andun> do cabal use the same package dbs as ghc-pkg?
12:42:53 <Deewiant> tehgeekmeister: just define them inside the where clause as well :-)
12:42:56 <Deewiant> monochrom: what?
12:43:07 <andun> i have mersenne-random-pure64 in ~/.ghc/.../package.conf, but cabal claims it's not installed
12:43:18 <monochrom> vista's shift-right-click
12:43:22 <tehgeekmeister> Deewiant: i can't define it exactly the same inside the where clause as outside.
12:43:41 <Deewiant> monochrom: yeah, one of the few good things to have come out of vista :-P
12:44:02 <CTA> 'C:\Users\Alan\Code\Haskell' is not recognized as an internal or external comman
12:44:02 <CTA> d,
12:44:02 <CTA> operable program or batch file.
12:44:13 <mathijs> Deewiant: -89071235986 + 1 still equals 89071235985
12:44:13 <Deewiant> CTA: you're missing the 'cd' in front
12:44:17 <tehgeekmeister> okay, are the functions in the where clause of a function operating in a certain monad in the same monad?
12:44:20 <tehgeekmeister> for example
12:44:24 <tehgeekmeister> i'm in the state monad
12:44:27 <Deewiant> no, they're not
12:44:34 <CTA> 2 mins ill try something..
12:44:36 <tehgeekmeister> can i do where foo = get >>= someFunction
12:44:37 <monochrom> i'm in the monad state
12:44:40 <Deewiant> tehgeekmeister: they're like toplevel declarations but only accessible from within that function, essentially
12:44:47 <tehgeekmeister> Deewiant: okay
12:44:48 <Deewiant> tehgeekmeister: oh, and they can access the toplevel function's parameters
12:44:56 <Deewiant> mathijs: yes, unfortunately :-/
12:44:57 <tehgeekmeister> that's good to know
12:44:58 <gueux> hi :-)
12:45:14 <gueux> is there a way to convert an IO String to a String?
12:45:28 <CTA> Right I've got it working lol..
12:45:37 <augustss_> andun: it's probably a confusion between global and user packages
12:45:41 <Cheshire> gueux, no
12:45:55 <augustss_> andun: I always use 'cabal install --global'
12:46:28 <andun> thanks, that worked.
12:46:31 <sjanssen> andun: are you passing --user to 'Setup configure'?
12:46:41 <andun> no
12:46:41 * sjanssen thinks --global is not great advice
12:46:48 <tdanecker> gueux: do { str <- iostring; str }
12:46:48 <CTA> :/ im confused
12:46:48 <andun> ah, so it refuses to use user packages :)
12:47:03 <augustss_> I wish cabal and cabal-install would use the same default for installing.  The current situation is quite broken.
12:47:07 <tdanecker> maybe
12:47:19 <jganetsk> tdanecker that's a type error
12:47:22 <sjanssen> andun: right, Cabal can't use user packages unless it knows you're installing to the user database
12:47:22 <andun> sjanssen: makes sense. but maybe it should've told me about it
12:47:29 <Baughn> sjanssen: Well, if you also use --root-cmd=sudo, I guess it should be fine
12:47:35 <monochrom> Eh? do { str <- iostring; str } can be simplified to iostring.
12:47:48 <augustss_> sjanssen: what's wrong with --global?
12:47:56 <Baughn> monochrom: Ah, no. That would be do { str <- iostring; return str }
12:47:57 <jganetsk> it has to be do { str <- iostring; return str } no?
12:47:58 <andun> sjanssen: the "no it doesn't exist" message wasn't very informative
12:48:03 <CTA> right, so i've set cd to my haskell folder, now running ghci.exe, now how do i run my code?
12:48:04 <monochrom> Oh! Oops.
12:48:05 * mmorrow only uses the global db
12:48:15 <redditbot> hipmunk: 2D physics for Haskell
12:48:15 <redditbot> the Patch-Tag blog
12:48:18 <sjanssen> Baughn, augustss_: I just think it's wiser to install your own packages in $HOME and your distribution's packages in /usr/
12:48:19 <andun> s/informative/useful/
12:48:24 <CTA> ghc make -- HelloWorld.hs gives me not in scopes
12:48:36 <Baughn> sjanssen: I agree. But --global without --root-cmd is just asking for trouble.
12:48:39 <monochrom> do { str <- iostring; str } can be simplified to join iostring.
12:48:43 <mmorrow> my global db is in /usr/local/ghc/ghc-whatever/...
12:48:49 <augustss_> sjanssen: it installs in /usr/local.  Which on non-broken systems is empty.
12:48:53 <Twey> CTA: That's ghc --make HelloWorld.hs
12:49:12 <Twey> And that probably signifies errors in your code
12:49:14 <Baughn> augustss_: Well, I've got my main ghc install in there, so..
12:49:18 <augustss_> sjanssen: or at least starts out empty until I install stuff there :)
12:49:23 <sjanssen> augustss_: true, but the meta-data will go in the global package data base
12:49:27 <CTA> I get not in scope ghc
12:49:35 <Twey> Uhm
12:49:39 <Twey> Are you in GHCi?
12:49:44 <CTA> yes
12:49:50 <Twey> OK
12:49:51 <augustss_> augustss_: the global db is also in /usr/local
12:49:57 <monochrom> We need remote desktop access to CTA's computer. :)
12:50:09 <CTA> I loaded cmd.exe made cd "c:\..haskell" then said ghci.exe
12:50:11 <Twey> CTA: First, put Haskell aside for a minute
12:50:14 <augustss_> why am i talking to myself?
12:50:22 <Twey> CTA: Then, read through http://www.bleepingcomputer.com/tutorials/tutorial76.html
12:50:25 <mmorrow> augustss_: it happens
12:50:39 <augustss_> mmorrow: probably because nobody else listens
12:50:44 <mmorrow> hehe
12:50:53 <andun> is there surch a thing as ./Setup.hs configure --hacking, which will just build/install the program in `pwd`?
12:51:10 <sjanssen> andun: there is 'Setup register --in-place'
12:51:22 <sjanssen> which you can do rather than installing
12:52:00 <andun> oh. (--inplace btw)
12:52:27 <CTA> Right I'll restart, will someone go through this with me step by step? I've already got a HelloWorld.hs file @ C:\Users\Alan\Code\Haskell
12:52:31 <CTA> so i open cmd?
12:52:43 <Twey> CTA: No, really
12:52:47 <Twey> CTA: Go through the tutorial
12:52:55 <Twey> CTA: You should generally be quite familiar with how to operate your computer before attempting to program it
12:53:11 <Twey> (er, that wasn't meant to sound as harsh as it came out, sorry)
12:53:22 <jganetsk> gueux, you want to convert from IO String to String... do you know why you are not allowed to do that?
12:53:28 <CTA> Now I've got it to C:\..Haskell, now do I load ghci.exe?
12:53:33 <mathijs> Twey: still true though :P
12:53:44 <andun> sjanssen: Setup install --inplace seems to be what i need
12:54:09 <mathijs> CTA: no, to compile you need ghc, ghci is just for playing around and testing bits & pieces
12:54:27 <CTA> so i now load ghc.exe?
12:54:33 <monochrom> ghc --make HelloWorld.hs
12:54:34 <andun> although ./dist/install/usr/local/bin/foo wasn't exactly pretty
12:55:01 <mathijs> CTA: you navigate cmd to the directory your file is in, and then type "ghc --make HelloWorld.hs"
12:55:02 <CTA> HelloWorld.hs:4:16: parse error (possibly incorrect indentation)
12:55:11 <Cheshire> CTA, oh that's a good sign
12:55:14 <gueux> jganetsk: I guess that in would allow board effects
12:55:17 <monochrom> Now you have to fix code.
12:55:20 <gueux> s/in/it/
12:55:23 <CTA> So now it works, but not my code lol?
12:55:38 <mathijs> CTA: ok, at least you are running the compiler on the file you created. that's good. Now fix your file to become valid Haskell code.
12:56:21 <gueux> in fact, my ultimate goal would be to ask a letter and a number to the user to interact with a game
12:56:25 <CTA> my file contains: let a = putStrLn
12:56:36 <monochrom> delete "let ".
12:57:07 <porges> was McBride being perverse when he defined <$> and <*>
12:57:11 <CTA> and now:  Could not find module `HelloWorld.Hs':
12:57:12 <jganetsk> gueux, you can: do { s <- iostring; ... }
12:57:17 <mathijs> CTA: change it to main = putStrLn "hello world!"
12:57:18 <opqdonut> porges: ?
12:57:20 <jganetsk> gueux, and put the rest of your code in ...
12:57:56 <CTA> Could not fine module?
12:58:20 <porges> opqdonut: surely they should be switched
12:58:21 <CTA> it works!
12:58:35 <mathijs> CTA: congrats
12:58:43 <monochrom> the haskell wiki has walk-through of how to use ghc and what to enter into source code file. why was it not followed?
12:59:01 <CTA> shouldn't it display hello world?
12:59:02 <CTA> C:\Users\Alan\Code\Haskell>ghc --make HelloWorld.hs
12:59:02 <CTA> [1 of 1] Compiling Main             ( HelloWorld.hs, HelloWorld.o )
12:59:02 <CTA> Linking HelloWorld.exe ...
12:59:07 <gueux> jganetsk: yes, but here s is a iostring
12:59:14 <porges> CTA you have to actually run the program
12:59:19 <porges> HelloWorld.exe
12:59:21 * monochrom feels hurt when the lives of all the authors of all the tutorials and documentations are lived in vain.
12:59:42 <CTA> LOL THANKS!
12:59:44 <jganetsk> gueux, that's do-notation, s is a String, not an IO String, do you know about do-notation and monads?
12:59:46 <mathijs> CTA: no, it compiled your program for you, that's what compilers (like ghc) are for. Now you have real executable program (HelloWorld.exe) which you can execute
12:59:47 <gueux> and I can't see how to convert an iostring to a letter and a number
13:00:37 <CTA> kk thanks alot bye
13:02:35 <Twey> Ah say that boy...
13:02:45 <gueux> jganetsk: so, I would be allowed to do a do {s <- iostring; s}
13:02:56 <gueux> and then to have a string
13:03:06 <mathijs> Twey: he'll master monads when windows 16 comes out
13:03:29 <gueux> but that does not work
13:03:35 <jganetsk> gueux... no, thaht line of code is a type error
13:04:11 <jganetsk> gueux, you can't take something out of an IO, you can only tell it how to go from one IO to another IO
13:04:19 <Gracenotes> unless iostring is an IO (IO String) ;)
13:04:27 <jganetsk> yes true
13:05:04 <gueux> but in my program, I use a couple (letter, number)
13:05:58 <tdanecker> gueux: i assume you have something like "a1", then you can use do { s <- iostring; let c = head s; i = read (tail s) in ... }
13:07:21 <monochrom> Two signs of civilizations: changing from icons to text, changing from repeatedly answering questions to writing down once and for all.  Two signs of dark ages: changing from text to icon such as Windows, changing from documentation to repeatedly answering questions such as #haskell and haskell-cafe.
13:08:23 <jganetsk> gueux, basically... you can get the s with do-notation, and the s will be string... but it can't escape the do block... it's not allowed
13:09:04 <gueux> tdanecker: with that code c is a char and i is a string, right?
13:09:38 <tdanecker> gueux: c is a Char and i could be an Integer
13:09:54 <mmorrow> , read "112358" :: Int
13:09:56 <lunabot>  112358
13:09:58 <mmorrow> , read "112358" :: Double
13:09:59 <lunabot>  112358.0
13:10:05 <mmorrow> , chr 42
13:10:06 <lunabot>  '*'
13:10:12 <mmorrow> , ord '*'
13:10:13 <lunabot>  42
13:10:18 <gueux> read is to powerful for me :-)
13:10:23 <mmorrow> , fromIntegral (42 :: Int) :: Double
13:10:25 <lunabot>  42.0
13:10:25 <gueux> s/to/too
13:10:40 <mmorrow> , reads "42" :: [(Int, String)]
13:10:41 <lunabot>  [(42,"")]
13:10:45 <mmorrow> , reads "asdfdsas42" :: [(Int, String)]
13:10:46 <lunabot>  []
13:11:48 <mmorrow> , let readM a = case reads a of [] -> Nothing; (a,_):_ -> Just a in fmap readM ["asdsas", "42sdsas"] :: [Int]
13:11:49 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
13:11:56 <mmorrow> , let readM a = case reads a of [] -> Nothing; (a,_):_ -> Just a in fmap readM ["asdsas", "42sdsas"] :: [Maybe Int]
13:11:57 <lunabot>  [Nothing,Just 42]
13:17:21 <gueux> ok
13:17:43 <gueux> and can I catch the exceptions? I mean if the user enters erqsdff2
13:17:47 <gueux> for example
13:18:10 <mmorrow> if you use readM, there is no exception
13:18:30 <mmorrow> , let readM a = case reads a of [] -> Nothing; (a,_):_ -> Just a in fmap readM "erqsdff2" :: Maybe Int
13:18:31 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
13:18:33 <ErhardtMundt> what does the 'RealFloat' typeclass contains?
13:18:38 <mmorrow> , let readM a = case reads a of [] -> Nothing; (a,_):_ -> Just a in readM "erqsdff2" :: Maybe Int
13:18:39 <lunabot>  Nothing
13:18:47 <mmorrow> @src RealFloat
13:18:47 <lambdabot> Source not found. I am sorry.
13:19:18 <mmorrow> ErhardtMundt: do ghci> :i RealFloat
13:19:28 <mmorrow> :i for :info
13:19:37 <mmorrow> you can do that on anything in-scope
13:20:21 <mmorrow> gueux: also, `maybe' makes working with Maybe simple
13:20:25 <mmorrow> @type maybe
13:20:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:20:31 <mmorrow> > readM
13:20:33 <lambdabot>   Not in scope: `readM'
13:20:42 <mmorrow> @let readM a = case reads a of [] -> Nothing; (a,_):_ -> Just a
13:20:46 <lambdabot>  Defined.
13:20:57 <mmorrow> > maybe 0 id (readM "asdsasd")
13:21:00 <lambdabot>   0
13:21:05 <mmorrow> > maybe 0 id (readM "asdsasd") :: Int
13:21:08 <lambdabot>   0
13:21:10 <mmorrow> > maybe 0 id (readM "99asdsasd") :: Int
13:21:12 <lambdabot>   99
13:21:32 <mmorrow> > maybe [] (replicate 10) (readM "99asdsasd") :: [Int]
13:21:34 <lambdabot>   [99,99,99,99,99,99,99,99,99,99]
13:22:12 <tehgeekmeister> can i count on the prelude's sortBy to be relatively efficient?
13:22:14 <mmorrow> > maybe (0,[]) (\n -> (n, show n)) (readM "99asdsasd") :: [Int]
13:22:16 <lambdabot>   Couldn't match expected type `[Int]'
13:22:22 <mmorrow> > maybe (0,[]) (\n -> (n, show n)) (readM "99asdsasd") :: (Int,String)
13:22:25 <lambdabot>   (99,"99")
13:22:31 <ErhardtMundt> mmorrow, thanks
13:22:33 <mmorrow> :)
13:22:57 <mmorrow> tehgeekmeister: yes
13:23:04 <mmorrow> tehgeekmeister: as efficient as it can be
13:23:08 <maltem> tehgeekmeister: It's mergesort, just as Data.List.sort is
13:23:18 <tehgeekmeister> okay
13:24:44 <gueux> mmorrow: ok
13:24:47 <gueux> thanks :-)
13:24:54 <mmorrow> np
13:26:24 <geezusfreeek> i remember seeing somewhere around here that a couple people have written monad transformer libraries using continuations for greater performance than mtl. does anybody know where i can find these?
13:27:18 <geezusfreeek> i just picked up some code that i was in the middle of unwrapping my mtl stack in and it's kind of crazy and i'd rather just avoid finishing it :)
13:27:48 <roconnor> byorgey says ``a common misconception is that monads have something to do with sequencing eï¬ects.
13:28:02 <roconnor> I maintain that sequencing effects is exactly what monads are about
13:28:25 <Heffalump> sequencing something, anyway
13:28:31 <roconnor> but i do agree that order of evalutation has very little to do with ordering of sequencing of effects.
13:28:39 <geezusfreeek> i would rather say that monads are about combining effects
13:28:47 <mmorrow> geezusfreeek: dolio wrote an 95% drop-in-replacement for mtl (i dunno where his repo is), and i have a minimal one with no transformers here:  http://moonpatio.com/repos/monad-cps/
13:28:50 <rwbarton> roconnor: I agree, but with the caveat that the claim is somewhat tautological.
13:28:57 <roconnor> geezusfreeek: combining effects ... in sequence!
13:29:16 <geezusfreeek> roconnor, using the word "sequence" means no more to me here than it does for monoids
13:29:17 <dolio> http://code.haskell.org/~dolio/
13:29:18 <rwbarton> monads are about sequencing effects in much the same way that lists are about sequencing elements.
13:29:31 <roconnor> rwbarton: oh?
13:29:33 <xcthulhu> roconnor - I always thought it was about an functor and two natural transformations...
13:29:35 <geezusfreeek> mmorrow, dolio: thanks
13:29:48 <roconnor> xcthulhu: does that really work for you?
13:30:17 <BMeph> geezusfreeek: Check out roconnor's blog. :)
13:30:55 <rwbarton> roconnor: because in this context an "effect" is by definition what's contained in the 'm' part of an 'm a', and "sequencing" is by definition (>>=)
13:31:01 <mmorrow> geezusfreeek: here's a benchmark that shows just how much faster the cps implem (for State at least, probably Writer as well) is  http://moonpatio.com/repos/MISC/state-bench/
13:31:07 <roconnor> geezusfreeek: http://r6.ca/blog/20071028T162529Z.html
13:31:45 <roconnor> geezusfreeek: I recently learned that Control.Monad.Codensity does this, so you might want to slap that on at the top of your monad stack
13:31:46 <xcthulhu> roconnor - Sure.  What a monad is, is just a mathematical contraption.  Arguing how to think of them correctly is like arguing how to think of topology correctly.
13:31:47 <mmorrow> geezusfreeek: on my laptop, StateCPS is over twice as fast as unboxed tuple State, which in turn beats mtl State.Strict
13:31:52 <roconnor> geezusfreeek: and see if that helps
13:31:59 <mmorrow> (mtl State.Lazy blows the stack)
13:32:17 <geezusfreeek> there are very few communities that i would consider *overly* helpful :)
13:32:30 <roconnor> mmorrow: oh, I'm not sure if this will help stack issues.  But it might.
13:32:50 <mmorrow> roconnor: i'm talking about that state benchmark i linked to
13:32:58 * mmorrow looks at roconnor's link
13:33:06 <rwbarton> Doesn't Codensity only work on free monads?
13:33:13 <roconnor> xcthulhu: true.  But I find it hard to find and apply monads without have one or more analogies at hand.
13:33:15 <geezusfreeek> roconnor, yes i had seen that. mysteriously nice
13:33:39 <xcthulhu> roconnor - Most abstract mathematics is the same way
13:34:00 <mmorrow> roconnor: cps writer is:
13:34:02 <mmorrow> newtype W w a = W {unW :: forall o. (a -> w -> o) -> o}
13:34:19 <mmorrow> W g >>= f = W (\k -> g (\a w -> unW (f a) (\a w' -> k a (w`mappend`w'))))
13:34:36 <mmorrow> put w = W (\k -> k () w)
13:35:10 <rwbarton> Hmm, seems I was remembering improveFree (which mysteriously made one of my test programs ~3x faster)
13:35:14 <geezusfreeek> anyway, i think i would say roughly that >>= does for effects what mappend does for values. there is a sequence only in the sense that the operation is not commutative
13:35:44 <mmorrow> geezusfreeek: that analogy would be more accurate with s/(>>=)/mplus/
13:36:01 <geezusfreeek> mmorrow, okay, i'll go for that
13:36:34 <rwbarton> geezusfreeek: exactly.  that's what I was trying to get at with my comment about lists above.
13:38:19 <olsner_> rwbarton: what's improveFree?
13:38:42 <geezusfreeek> mmorrow, actually i think i take back my agreement with that. i'd still rather think of >>= as a monoid over effects (plus the value passing)
13:39:11 <geezusfreeek> with return being analogous to mempty
13:39:28 <mmorrow> , return >>= return
13:39:29 <lunabot>  luna: No instance for (GHC.Show.Show (a -> m a))
13:39:34 <geezusfreeek> it's not a literal translation
13:39:36 <mmorrow> , return `plus` return
13:39:36 <lunabot>  luna: Not in scope: `plus'
13:39:59 <mmorrow> geezusfreeek: i hear you. it's analogous "at some level" i guess
13:40:07 <ddarius> If you use Kleisli composition, you get a monoid (for any fixed 'a').
13:40:13 <mmorrow> there we go
13:40:24 <mmorrow> @type return <=< return
13:40:26 <lambdabot> forall b (m :: * -> *). (Monad m) => b -> m b
13:40:29 <geezusfreeek> yes
13:40:33 <mmorrow> perfect
13:41:12 <roconnor> mmorrow: your cpsed writer doesn't look right
13:41:22 <mmorrow> roconnor: it is :)
13:41:39 <roconnor>  forall o. (a -> w -> o) -> o vs  forall o. (a -> (w,o)) -> (w,o)
13:41:49 <roconnor> well, they are probably isomorphic
13:41:57 <roconnor> why do I prefer one over the other?
13:42:22 <mmorrow> ghci> runW (put "42" >> put "HAI")
13:42:22 <mmorrow> ((),"42HAI")
13:42:36 <mmorrow> they're not iso
13:42:54 <mmorrow> the crucial part is to have the ability to not use a tuple
13:43:16 <roconnor> mmorrow: so my code could be faster still?
13:43:25 <mmorrow> i think
13:43:29 <seliopou> ((a, w) -> o) -> o and (a -> w -> o) -> o would be isomorphic
13:43:42 <seliopou> "isomorphic"
13:43:51 <roconnor> mmorrow: I still think they are isomorphic
13:44:05 <mmorrow> roconnor: what i i change my "runW" from
13:44:10 <mmorrow> runW (W g) = g (,)
13:44:12 <mmorrow> to
13:44:17 <mmorrow> runW (W g) = g const
13:44:19 <roconnor> mmorrow: I should revisit this blog post using GHC 6.8 and more careful comparision
13:45:08 <roconnor> @djinn ((a -> w -> o) -> o) -> (a -> (w,o)) -> (w,o))
13:45:08 <lambdabot> Cannot parse command
13:45:21 <roconnor> @djinn ((a -> w -> o) -> o) -> (a -> (w,o)) -> (w,o)
13:45:21 <lambdabot> -- f cannot be realized.
13:45:28 <roconnor> hmm
13:45:36 <mmorrow> @type curry
13:45:37 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:45:38 <rwbarton> I think in (a -> (w,o)) -> (w,o) you're going to have to use the Monoid structure of w and impose some restrictions on the value
13:45:38 <mmorrow> @type uncurry
13:45:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:46:07 <roconnor> @djinn (forall o. ((a -> w -> o) -> o)) -> (forall o. (a -> (w,o)) -> (w,o)))
13:46:07 <lambdabot> Cannot parse command
13:46:10 <roconnor> bah
13:46:15 <ddarius> I believe there is an adjunction as follows, every monoid induces a monad via the Writer monad so we have a functor W : Monoid -> Monad and every monad induces the monoid (m (), (>>) return) giving a functor ($()) : Monad -> Monoid and this, I believe, leads to an adjunction ($()) -| W.
13:46:24 <rwbarton> like f :: (a -> (w,o)) -> (w,o) must be equivariant for either the left or right action of w on itself
13:46:47 <dolio> (a,w) is isomorphic to (forall o. ((a, w) -> o) -> o) which is isomorphic to (forall o. (a -> w -> o) -> o).
13:46:49 <dolio> Sort of.
13:47:02 <mmorrow> yes
13:47:10 <dolio> And (a,w) is the writer monad.
13:47:30 <roconnor> (w,a) is isomorphic to forall o. (a -> (w,o)) -> (w,o)
13:47:41 <roconnor> by codensity
13:47:44 <ddarius> mmorrow's Writer is the -Church-encoding- of (a,w) not the CPS transform.
13:48:05 <roconnor> f a is isomorphic to forall o. (a -> f o) -> f o
13:49:14 <roconnor> although that iso requires f to be a monad
13:49:18 <roconnor> I guess I should say
13:49:29 <roconnor> m a is isomorphic to forall o. (a -> m o) -> m o for monads m
13:49:44 <roconnor> ddarius: intersting point.
13:49:53 <roconnor> ddarius: how do you define the CPS transform?
13:50:07 <ddarius> Crap, that was a poor wording.
13:50:09 <mmorrow> ddarius: it's the scott-encoding, which happens to coincide with the church encoding in this case
13:50:19 <Cheshire> lol
13:50:27 <mmorrow> :)
13:50:28 <ddarius> mmorrow: That's not even pedantry.
13:50:33 <mmorrow> haha
13:50:57 <ddarius> roconnor: I intended that it is not Cont (o,w) a
13:52:40 <roconnor> mmorrow: okay, your church-scott-writer-transform is nice, but how does it work with the MaybeT and StateT put on top?
13:52:43 <BMeph> Is there something on the wiki, or in someone's blog, dealing with doing memory-mapped info in Haskell?
13:53:17 <seliopou> memory-mapped info?
13:54:06 <rwbarton> roconnor: what does (\f -> first (join mappend) (f a)) :: forall o. (a -> (w, o)) -> (w, o) correspond to in (w, a)? for example
13:54:18 <Gracenotes> @instances MonadPlus
13:54:19 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
13:54:35 <djeik> I'm very sorry for asking a "fix my code" question, but I'm trying to compile a haskell program (written by Eelis) which depends on GHC.Read's "readEither", but this was apparently not part of the public interface, and was removed in GHC 6.10. I found a mailing list post saying "I'd recommend wrapping reads instead". How can I do that for this line of code?
13:54:38 <djeik> readTypedFile f = either (const $ fail $ "parsing \"" ++ f ++ "\"") return =<< readEither . readFile f
13:54:44 <djeik> the mailing list message is: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg15260.html
13:54:57 <roconnor> rwbarton:  first (join mappend) (return a)
13:54:58 <Gracenotes> @src IO mzero
13:54:58 <lambdabot> mzero       = ioError (userError "mzero")
13:55:04 <Gracenotes> eek.
13:55:11 <Gracenotes> really... eek :\
13:55:13 <rwbarton> roconnor: but that's equal to just return a
13:55:26 <rwbarton> roconnor: but  (\f -> first (join mappend) (f a))  is not equal to  (a >>=)
13:55:36 <roconnor> rwbarton: oh?
13:55:54 <rwbarton> wait
13:56:00 <BMeph> seliopou: If you prefer, s/info/data/
13:56:32 <SamB_irssi> gwern: is there a repository for "Typing Haskell in Haskell"?
13:56:42 <Gracenotes> @src IO mplus
13:56:43 <lambdabot> m `mplus` n = m `catch` \_ -> n
13:56:48 <seliopou> BMeph: ah, ok. just wasn't sure what you meant
13:56:57 <rwbarton> roconnor: I mean, it's not equal to ($ a)
13:56:59 <seliopou> BMeph what are you looking to do with that?
13:57:18 <Gracenotes> @src Either mzero
13:57:18 <lambdabot> mzero            = Left noMsg
13:57:25 <seliopou> (as should be clear I don't have any references, but I'm curious)
13:57:42 <roconnor> rwbarton: ($ a) and return a don't have the same type.
13:57:53 <rwbarton> roconnor: I know
13:58:10 <geezusfreeek> any chance of one of these cps mtl libraries hitting hackage any time soon?
13:58:20 <rwbarton> you claim  return a  <-->  ($ a)  right?
13:58:31 <rwbarton> but also  return a  <-->  (\f -> first (join mappend) (f a))
13:58:33 <BMeph> seliopou: Just looking to fill in some gaps in the Rosetta Code wiki. Specifically: http://rosettacode.org/wiki/Basic_bitmap_storage#OCaml
13:58:41 <ddarius> There's an embedding of a monad m into Cont (m r), not an isomorphism (at least not without restricting what we can do with Cont).  We can easily do continuationy stuff in Cont (m r) that has no correspondence to an action in m.
13:58:43 <roconnor> rwbarton: not in the writer monad.
13:59:17 <roconnor> rwbarton: hmm, perhaps using the monad functions here is confusing
13:59:24 <BMeph> Well, I was looking at OCaml's version, since I figured Haskell's would resemble it the most.
13:59:25 <rwbarton> roconnor: I'm not confused. :P
13:59:38 <roconnor> <rwbarton> roconnor: what does (\f -> first (join mappend) (f a)) :: forall o. (a -> (w, o)) -> (w, o) correspond to in (w, a)? for example
13:59:43 <rwbarton> forall o. (a -> m o) -> m o is just much bigger than m a.
13:59:46 <roconnor> (memtpy,a)
14:00:04 <rwbarton> right
14:00:29 <rwbarton> which in turn corresponds to  ($ a) :: forall o. (a -> m o) -> m o
14:00:29 <roconnor> rwbarton: I don't see what you are getting at.
14:00:38 <rwbarton> which is not the same as  (\f -> first (join mappend) (f a))
14:00:51 <roconnor> how is it different?
14:00:52 <rwbarton> I'm saying your "isomorphism" is only an embedding
14:00:55 <seliopou> BMeph: With the disclaimer that I haven't used this much, I'd suggest looking at the Storable type class
14:01:00 <mriou_> hi, I'm having some difficulties adding a ContT monad transformer to an existing transformer
14:01:08 <mriou_> I'm doing the following addition: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1420#a1420
14:01:14 <rwbarton> Because not every f :: a -> m o has the form f a = (mempty, ...)
14:01:29 <seliopou> Just make an ADT to represent the bitmap, make it an instance of storable, and then just read it from the C pointer
14:01:34 <mriou_> but keep on getting "the eta-reduction property does not hold"
14:01:39 <seliopou> At least that'd seem to work in theory
14:01:43 <mmorrow> roconnor: i'm not sure, but it'd be interesting to find out
14:01:55 <seliopou> note that I tried to this with GMP and always got segfaults, but that was probably my fault
14:01:56 <seliopou> :)
14:02:01 <roconnor> rwbarton: what makes you say that?
14:02:03 <Toxaris_> is there a specific reason why everyone is talking about monads and continuations lately? (blog post, paper, experimental results, library, ...)?
14:02:14 <Heffalump> mriou_: is that the full error?
14:02:15 <dolio> forall o. (a -> m o) -> m o is, I believe, IdentityT m a in my library.
14:02:33 <Heffalump> oh, it's complaining about the newtype deriving?
14:02:33 <seliopou> BMeph: is that helpful in the slightest?
14:02:33 <mriou_> mmh no sorry, let me paste the full thing
14:02:48 <SamB_irssi> oops
14:03:04 <mriou_> Heffalump: here is the full thing: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1421#a1421
14:03:13 * SamB_irssi thought he'd quit by accident just now ... but it was hours ago, on purpose, in a different screen window than he thought he was in ...
14:03:14 <mriou_> yes
14:03:15 <mmorrow> BMeph: oh yesh, you can mmap for sure. what do want to map? there's a bytestring-mmap, and there's also an "mmap" package on hackage
14:03:37 <mmorrow> but neither iirc allow you to specify the PROT_* options to give to mmap
14:03:46 <Heffalump> is writing the instances yourself a major hardship?
14:04:01 <mmorrow> so if for instance you want to use PROT_EXEC, you'll have to write your own c-binding
14:04:23 <mriou_> Heffalump: well, that would make the code significantly longer
14:04:25 <mmorrow> (although i have one for mmap among other things that i'm currently cleaning up and am gonna put on hackage)
14:04:29 <roconnor> rwbarton: okay I see what you are getting at
14:04:33 <roconnor> rwbarton: I'm a little slow
14:04:42 <comex> mmap + functional --> ???
14:04:45 <Heffalump> so I think it means it about eta-reduction
14:04:47 <mriou_> I just don't understand what exactly is the problem with the dreivation
14:04:53 <roconnor> rwbarton: by function to and from the codensity transform are not inverses of each other.
14:04:58 <rwbarton> roconnor: right
14:05:01 <roconnor> rwbarton: thanks for the lesson
14:05:01 <Heffalump> your first type can be eta-reduced (i.e. remove the 'a') if you strip out the newtype tag
14:05:05 <Heffalump> your second type can't be
14:05:20 <Heffalump> it also looks wrong to me, since it's missing an 'a' on the RHS
14:05:22 <Heffalump> did you miss that out?
14:05:36 <zaarg> wc
14:06:06 <mriou_> Heffalump: no, what do you mean on the RHS?
14:06:19 <Heffalump> of the type definition of Eval
14:06:29 <Heffalump>     runE :: ContT WyType (ReaderT WyEnv (ErrorT WyError IO)) ASTType
14:06:37 <Heffalump> that should have an 'a' in it somewhere, surely?
14:06:46 <mmorrow> <geezusfreeek> any chance of one of these cps mtl libraries hitting hackage any time soon?
14:06:53 * mmorrow subtly hints to dolio
14:06:54 <BMeph> seliopou: Very helpful, thanks, just a lot more info than I was planning on scarfing up for the exercise.
14:07:04 <mriou_> mmh yeah, I actually replaced it with the type I used most just to see
14:07:20 <mriou_> runE :: ContT a (ReaderT WyEnv (ErrorT WyError IO)) ASTType
14:07:30 <BMeph> mmorrow: I'm looking to fill in some of the examples for the Rosetta Code site.
14:07:32 <dolio> I didn't put it on hackage because there are already so many mtl alternatives.
14:07:36 <mmorrow> <Toxaris_> is there a specific reason why everyone is talking about monads and continuations lately? (blog post, paper, experimental results, library, ...)?
14:07:43 <roconnor> dolio: what your type for runIdentityT?
14:07:57 <blancolioni> good evening all
14:07:57 <mmorrow> Toxaris_: http://moonpatio.com/repos/MISC/state-bench/
14:08:34 <mriou_> Heffalump: so do you see a way I could insert ContT in that transformer without running into the derivation problem?
14:08:36 <mmorrow> Toxaris_: that benchmark completely and totally sold me
14:08:40 <dolio> Oh, never mind. I didn't do that for identity monads. I thought it was pointless.
14:08:47 <mriou_> I've tried a few combinations but can't find what would work
14:08:52 <Heffalump> mriou_: if it still fails, then no
14:09:00 <Toxaris_> obviously, CPS is faster because it needs no pattern matching
14:09:14 <Heffalump> well, not unless a can be the last parameter and ASTType be the first
14:09:17 <blancolioni> does anybody know if there's something special that needs to be done to install a ghc package in my user account?
14:09:24 <Heffalump> I'd have to think about what's actually going on to understand which is correct
14:09:38 <Heffalump> though my immediate suspicion would be that a should be the last parameter
14:09:40 <blancolioni> I have a situation where ghc-pkg lists it, but cabal doesn't pick it up
14:09:59 <mmorrow> Toxaris_: but ironically no std monad libs use such an "obviously" faster implem internally (which need not be visible from the outside)
14:10:35 <mriou_> maybe I should put ContT inside instead of outside
14:10:41 <Toxaris_> mmorrow: and no intermediate values. Its basically what Oleg does now and then when he presents a "final version" of some code on -cafe
14:10:51 <Heffalump> why can't you put a at the end?
14:10:53 <seliopou> Oh, BMeph, one more thing: Look into hsc2hs for maximum portability
14:10:56 <mmorrow> so every time we're using State, we're spending twice as much time waiting as we could be
14:11:15 <SamB_irssi> @ask gwern do you have a repository for typing haskell in haskell ?
14:11:15 <lambdabot> Consider it noted.
14:11:27 <mriou_> Heffalump: that would reverse the type for the continuation, I need ASTType -> WyType not the opposite
14:11:54 <z0d> Sorry for my ignorance, but what is Haskell cafe?
14:11:58 <Heffalump> ok, I'mnot really sure without thiking it through
14:12:12 <rwbarton> I always wonder with these CPS transforms, is there a trade-off involved?  Maybe a loss of sharing?
14:12:12 <seliopou> z0d, a mailing list
14:12:23 <z0d> seliopou: thanks
14:12:24 <mriou_> Heffalump: ok thanks, I'll try a few more things
14:12:29 <mmorrow> Toxaris_: people use this technique all the time. we just need to get it into the std monad libs, because judging by the current state of affairs, it would be crazy not to.
14:12:48 <Toxaris_> mmorrow: so can it be done for monad transformers?
14:12:53 <mmorrow> Toxaris_: sure
14:13:12 <mmorrow> Toxaris_: http://code.haskell.org/~dolio/cps-mtl/
14:15:12 <mmorrow> rwbarton: i can't think of a trade-off off the top of my head, but it'd be nice to nail down yes or no.
14:15:24 <Toxaris_> nice. does it work with monads which add additional continuations, e.g. MaybeT?
14:15:25 <athos> @seen byorgey_
14:15:25 <lambdabot> byorgey_ is in #haskell-overflow, #haskell-blah, #xmonad and #haskell. I don't know when byorgey_ last spoke.
14:18:03 <dolio> I should add a continuation passing Maybe, perhaps.
14:18:13 <mmorrow> yeah, that'd be nice
14:18:13 <dolio> What's a good name for that?
14:18:26 <Toxaris_> exit or abort
14:18:55 <mmorrow> Fail (but that's a rather loaded wrt monad)
14:19:10 <dolio> I'll go with Exit, I think.
14:19:18 <mmorrow> yeah, that's nice
14:19:20 <Toxaris_> from "exit continuation" in contrast to "current continuation", and "abort control operator" in direct style
14:19:29 <kerlo> Abort, Retry, Fail, Ignore...
14:20:09 <Toxaris_> The pattern (forall r, ... -> (... -> m r) -> m r) seems to be the key trick, to use m in two positions
14:21:15 <loadquo> @bots
14:21:16 <lunabot>  :)
14:21:16 <lambdabot> :)
14:22:20 <kerlo> @bot
14:22:20 <lunabot>  :)
14:22:20 <lambdabot> :)
14:22:38 <kerlo> The fact that the plural works makes the singular seem a bit of a misnomer.
14:22:40 <mmorrow> @botsandwich
14:22:40 <lunabot>  :)
14:22:41 <lambdabot> Unknown command, try @list
14:22:52 <mmorrow> @bo
14:22:52 <lambdabot> :)
14:22:55 <Deewiant> @b
14:22:55 <lambdabot> Maybe you meant: b52s babel bf bid botsnack brain bug . ? @ v
14:23:00 <Deewiant> @boot
14:23:01 <lambdabot> Unknown command, try @list
14:23:11 <kerlo> @botstack
14:23:11 <lunabot>  :)
14:23:12 <lambdabot> :)
14:23:28 <mmorrow> lunabot just special cases  ("bot"`isPrefixOf)
14:23:39 <Deewiant> @bottom
14:23:39 <lunabot>  :)
14:23:40 <lambdabot> Unknown command, try @list
14:23:44 <opqdonut> :)
14:24:25 <kerlo> opqdonut is now @botsnack-compliant.
14:24:57 <mmorrow> heh
14:25:17 <mmorrow> botsnack-compliance has a ince ring to it
14:25:21 <mmorrow> *nice
14:25:42 <Heffalump> not if you're the botsnack in question
14:25:52 <mmorrow> @vixen CAN HAS BOTSNACK-COMPLIANCE??!@
14:25:53 <lambdabot> no
14:25:55 <mmorrow> haha
14:26:47 <mmorrow> Heffalump: true
14:26:52 * Toxaris_ would try this benchmark @ home, but his OS is too stupid for the filenames :(
14:27:17 <mmorrow> Toxaris_: what benchmark?
14:27:21 <kerlo> @vixen Do you just answer "no" to every question?
14:27:22 <lambdabot> what was the question again?
14:27:33 <Toxaris_> mmorrow: http://moonpatio.com/repos/MISC/state-bench/  there is State.hs and a state.hs
14:27:44 <mmorrow> Toxaris_: ohh. i'll fix it.
14:33:33 <mmorrow> Toxaris_: ok, fixed.
14:34:48 <Ralith> anyone worked with sockets before?
14:35:03 <mmorrow> what's the question?
14:35:14 <Ralith> I'm running connect, and nothing's being thrown, but sIsConnected gives False.
14:36:13 <Ralith> why is this, and how do I fix it?
14:37:01 <Toxaris_> mmorrow: still doesn't work. darcs cannot apply the original windows-unfriendly patch, even if the problem is solved in a later patch
14:37:12 <kaol> FYI, ghc 6.10.1 will be in Debian unstable after the next dinstall run. Getting the libraries updated may take some days.
14:37:14 <Toxaris_> mmorrow: arguably a darcs-bug :)
14:37:39 * ddarius had a problem like that when checking out the old fptools CVS repository years ago.
14:38:16 <Heffalump> you can sometimes reorder the patches in the repo to work around it
14:38:24 <mmorrow> Ralith: hmm. so are you sure you ever were connected in the first place?
14:38:43 <Heffalump> are the two clashing files ever modified in the same patch?
14:38:45 <Ralith> mmorrow: what?
14:39:01 <Ralith> mmorrow: like I said, I ran connect, and a subsequent sIsConnected returns false.
14:39:22 <Ralith> mmorrow: I suppose it could have connected then instantly disconnected, but it seems more likely that it just never connected
14:40:07 <Toxaris_> its not that serious a problem (because wget will do for fetching the benchmark instead of darcs), but there are only two patches, and one of them creates all the files including the clash, so I don't see how reordering could help here
14:40:50 <Heffalump> no, it couldn't then
14:41:15 <mmorrow> Ralith: looking at the code for `connect', it looks like it will either connect successfully + set status to Connected, or throw an exception
14:41:37 <mmorrow> so i guess the only possibility is that it connected then immediately disconnected?
14:42:06 <mmorrow> Ralith: http://www.haskell.org/ghc/dist/current/docs/libraries/network/src/Network-Socket.html#connect
14:42:37 <hackage> Uploaded to hackage: pqueue-mtl 1.0.3
14:42:37 <hackage> Uploaded to hackage: stateful-mtl 1.0.3
14:43:03 <Ralith> mmorrow: well why would it be doing that?
14:43:14 <mmorrow> Ralith: i don't know. that's weird.
14:43:43 <mmorrow> is there ever a case where the C connect() returns non-"-1" but still fails to connect?
14:44:07 <zloog> Anyone know what can cause "Prelude> module main:Data.ByteString.Lazy is not loaded" to occur when in ghci?
14:44:13 <mmorrow> because if so, that's the only possibility i see here other the connect-and-instantly-disconnect thing
14:44:15 <Ralith> not afaik
14:44:18 <zloog> As a respone to :m Data.ByteString.Lazy
14:44:38 <mmorrow> Ralith: i'm out of ideas :(
14:44:45 <Ralith> anyone else?
14:45:34 <mmorrow> are you sure the remote machine isn't closing the connection immediately?
14:47:41 <mmorrow> <Toxaris_> mmorrow: still doesn't work. darcs cannot apply the original windows-unfriendly patch, even if the problem is solved in a later patch
14:47:44 <mmorrow> whoa, i just saw this
14:47:59 <mmorrow> i'll re-init the repo
14:48:11 <Ralith> mmorrow: yeah, I tested with nc -l on localhost
14:48:17 <redditbot> auto-complete.el for Haskell
14:48:33 <dcoutts> augustss_: if you always want to do global installs then set that in your ~/.cabal/config
14:49:04 <dcoutts> augustss_: the reason they're not the same is we could not easily change the default for runghc Setup.hs configure. That would have broken things.
14:49:23 <mmorrow> Toxaris_: done
14:49:59 <mmorrow> Ralith: hmm, possibly there's some bug you're discovering
14:50:16 <Ralith> here's my code
14:50:17 <Ralith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1456#a1456
14:50:53 <Ralith> I've verified that a plain connectTo works
14:52:02 <BMeph> zloog: Are there any other messages that GHCi is outputting?
14:52:13 <mmorrow> Ralith: ohhhh. ok, so you're rceating a new socket with every call to `sock'
14:52:17 <mmorrow> *recreating
14:52:26 <Ralith> oh.
14:52:27 <Ralith> yeah.
14:52:31 <mmorrow> :)
14:52:32 <Ralith> that would be a problem, I guess >_>
14:52:36 <Ralith> thanks
14:52:43 <mmorrow> no problem
14:53:18 <Toxaris_> mmorrow: cool thanks working now. there is a bug in clean.sh (should be state_unboxed instead of state, and adding *.exe and *.exe.manifest would be appropriate for me, but maybe annoying for others, cannot tell)
14:54:06 <mmorrow> Toxaris_: gah, i forgot to change the .sh's. cool, i'll do that too.
14:54:24 <Toxaris_> mmorrow: the results are very impressive, thanks for that benchmark, it rocks
14:54:49 <zloog> BMeph: not really. i'm trying to bootstrap cabal install after a fresh ubuntu install
14:55:08 <mmorrow> Toxaris_: totally. i was amazed when i first saw it.
14:56:01 <zloog> BMeph: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1458#a1458 the config/build/install for bytestrings package went through fine with no errors
14:56:17 <mmorrow> Toxaris_: ok, added state*.exe to clean.sh
14:56:24 <Toxaris_> mmorrow: I have a class about CPS with Danvy tomorrow. will tell him, and he will say, sure, that's what I wanted to talk about next week.
14:56:32 <mmorrow> Toxaris_: hehe
14:56:56 <Heffalump> is there an objection to just putting up statically linked cabal binaries for common platforms?
14:56:57 <BMeph> zloog: do ':m + Data.ByteString.Lazy' that should work fine. :)
14:57:19 <zloog> BMeph: Nope :(
14:57:24 <mmorrow> BMeph: are you still looking to use mmap?
14:57:28 <zloog> BMeph: same error
14:57:37 <Toxaris_> why does state_cps not run in constant stack space?
14:57:51 <dcoutts> Heffalump: nope, go ahead.
14:57:54 <mmorrow> Toxaris_: it doesn't ?
14:58:00 <Heffalump> where should they go?
14:58:16 <Toxaris_> mmorrow: If I add a 0 to the 400000 I get stack overflow
14:58:24 <Heffalump> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall ?
14:58:37 <ddarius> Toxaris_: Possible.  Part of the roots of the technique lay in Andrzej Filinski's work.
14:58:38 <dcoutts> Heffalump: you could link them from there certainly
14:58:43 <mmorrow> Toxaris_: interesting. i'm guessing that we can fix that with a bang somewhere
14:58:45 * mmorrow tries
14:58:47 <Heffalump> yeah, I meant a link
14:58:54 <BMeph> mmorow: Maybe later, I'll put up a naive version, and if I care to go back to it, I will. :)
14:58:54 <dcoutts> Heffalump: though you might want to hold on a few days
14:58:58 * Heffalump will do that tomorrow.
14:59:15 <dcoutts> Heffalump: I'm testing a release as we speak
14:59:38 * dcoutts notes the new release has a better bootstrap.sh
15:00:08 <mmorrow> Toxaris_: oh. add a 0 to the others too.
15:00:14 <mmorrow> Toxaris_: they all overflow
15:00:15 <ksf> Haskell programs don't exist.
15:00:32 <ksf> The longer you work on them, the shorter they become, therefore, they don't exist.
15:00:49 <Toxaris_> mmorrow: yeah I guessed that's because they are not cool. but state_cps is, so...?
15:00:57 <mmorrow> Toxaris_: heh
15:00:59 <seliopou> sorties paradox!
15:01:12 <mmorrow> Toxaris_: i think it's replicateM's fault
15:01:19 <luqui> ksf, I don't buy it.  To me that just means that any existent haskell program only has a finite amount of work behind it.
15:01:37 <Toxaris_> mmorrow: I just see no point where laziness can leak into a program which is basically in CPS
15:01:55 <Toxaris_> mmorrow: and which clearly has a constant continuation size, whatever that means
15:02:26 <mmorrow> Toxaris_: i think the overflow here is because replicateM will create the entire list before returning
15:02:28 <ksf> so, if you invest a finite amount of work on a program that starts at 0 lines, you make it n lines shorter, therefore, every haskell program occupies a negative number of bytes.
15:02:50 <mmorrow> , last `fmap` replicateM 4000000 :: Maybe Int
15:02:51 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe [GHC.Types.Int]'
15:03:09 <mmorrow> , last `fmap` replicateM 4000000 (return 42) :: Maybe Int
15:03:13 <lunabot>  Stack space overflow: current size 8388608 bytes.
15:03:13 <lunabot>  Use `+RTS -Ksize' to increase it.
15:03:23 <ManateeLazyCat> I use command "hoogle Control.Monad." got "unexpected "."  expecting "forall", "(", "[", "!", "--", "/" or end of input. Bad symbol", how to fix it?
15:03:23 <mmorrow> damn you replicateM!!
15:04:00 <dolio> cps-mtl updated.
15:04:06 <mmorrow> leeet
15:04:17 <ddarius> ManateeLazyCat: Don't put a period at the end.
15:04:55 <ManateeLazyCat> ddarius: I have develop completion Haskell code in Emacs, when i type "Control.Monad." I want got a *list* for competition.
15:05:07 <ManateeLazyCat> ddarius: Have another solution?
15:05:49 <ddarius> Strip the period at the end then.
15:05:51 <ManateeLazyCat> ddarius: But hoogle will occur a error when put a period at the end.
15:06:19 <Ralith> Anyone used HsOpenSSL here? I seem to have it working right up to the point of decryption; not sure how to do that.
15:07:02 <ManateeLazyCat> ddarius: Strip the period at the end i can't got *list* form hoogle.
15:07:09 <rwbarton> hoogle isn't designed to do completion
15:07:31 <ManateeLazyCat> ddarius: hoogle support  regexp?
15:07:35 <pumpkin> Ralith: I've done a fair amount of work with regular openssl, not sure how similar the API is though
15:07:40 <aflatter> .quakenet.org
15:08:19 <zloog> Anyone have an idea why http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1458#a1458 is happening after I do a build from hackage of the bytestring package?
15:08:26 <Ralith> pumpkin: I'm suspecting that I'll have to abandon the convenience func I've been using to use the SSL-specific code.
15:08:32 <zloog> Is there some kind of path i need to fiddle with?
15:08:55 <mmorrow> zloog: get out of that directoy
15:08:58 <mmorrow> *directory
15:09:13 <Ralith> pumpkin: what's the normal way to decrypt a bunch of data?
15:09:15 <Toxaris_> ManateeLazyCat: no regexps for hoogle. The cool thing about hoogle is that you can search for types, not just names. of course, that doesn't help you here.
15:09:19 <Ralith> received from the server
15:09:20 <mmorrow> ghci is getting confused since :load would also work from there
15:09:28 <Toxaris_> @hoogle Bool -> Bool -> Bool
15:09:28 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
15:09:28 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
15:09:28 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
15:09:38 <zloog> mmorrow: Thanks!, now I get a Could not find module `Data.ByteString.Lazy' error though
15:09:55 <dolio> Let me know if you find any oddities. I was typing pretty fast.
15:09:58 <mmorrow> oh, also add a '+' after :m
15:10:08 <pumpkin> Ralith: there are various ways to do it... the EVP api is probably easiest though
15:10:26 <ManateeLazyCat> ddarius: Too bad, if hoogle support period at the end, now i can completion Haskell code use UI in Emacs perfect.
15:10:33 <dolio> Specifically, you might want to make sure callCC works as you expect for ExitT.
15:10:47 <ManateeLazyCat> Toxaris_: In fact, i just want got name from hoogle, then i use regexp in Emacs for filter.
15:10:51 <Ralith> pumpkin: where do I get the key to decrypt with?
15:10:52 <mmorrow> zloog: actually, the '+' shouldn't make any diff. did you actually install it after building?
15:11:06 <pumpkin> Ralith: you talking specifically about SSL? or just symmetric ciphers in general?
15:11:16 <zloog> mmorrow: Yeah, thats why i think there has to be something about a path involved
15:11:17 <Toxaris_> ManateeLazyCat: so why not use regexp in emacs to get rid of the trailing dot, then hoogle, then use regep in emacs again to get completions?
15:11:27 <zloog> mmorrow: I did "sudo" the install command as well
15:11:39 <Ralith> pumpkin: SSL
15:11:42 <rwbarton> ManateeLazyCat: like I said, hoogle (the command-line program) isn't designed to do what you want.
15:11:51 <rwbarton> ManateeLazyCat: however you might find its databases useful.
15:12:29 <pumpkin> Ralith: ah, that's different... they have an IO abstraction called BIO, which allows you to take a file descriptor and slap an SSL context on top of it (it'll do the handshake for you) and then it will give you a BIO which you can read and write from like a regular stream
15:12:30 <mmorrow> zloog: maybe you installed it into a the wrong packagedb wrt where ghci looks for stuff
15:12:31 <ManateeLazyCat> rwbarton: No, i have implement Haskell code completion 99%, i use regexp in Emacs for filter various type data.
15:12:43 <ManateeLazyCat> Toxaris_: Thanks, i try.
15:13:05 <pumpkin> ManateeLazyCat: are you sure you really want to be doing code completion against an online search engine?
15:13:07 <rwbarton> ManateeLazyCat: What I'm saying is "hoogle Control.Monad" doesn't give you a list of modules Control.Monad.*
15:13:12 <zloog> mmorrow: Yea i think so, do you know where I have to go to start looking? I dont know much about the GHC package manager
15:13:17 <rwbarton> pumpkin: hoogle is a command-line program that has a local database
15:13:22 <ManateeLazyCat> pumpkin: Not online, is local
15:13:24 <pumpkin> ah, I see :)
15:13:28 <rwbarton> pumpkin: which happens to have a web interface as well :)
15:13:36 <pumpkin> I've only ever seen the online one, sorry :)
15:13:48 <Toxaris_> @hoogle Control.Monad
15:13:48 <lambdabot> module Control.Monad
15:13:48 <lambdabot> Control.Monad class Monad m
15:13:48 <lambdabot> Control.Monad.Instances class Monad m
15:14:12 <Ralith> pumpkin: HsOpenSSL seems to not expose that :/
15:14:42 <pumpkin> yeah, doesn't look like it provides ssl
15:14:49 <Ralith> huh?
15:14:49 <pumpkin> it looks like more of an interface to libcrypto
15:14:52 <Ralith> no
15:14:54 <Ralith> I've got a working connection
15:14:55 <ManateeLazyCat> Now have completion 99%, almost perfect, hold on.
15:15:02 <Ralith> it did the handshake
15:15:07 <pumpkin> oh .Session
15:15:08 <Ralith> and then I received a nice garbly pile of data
15:15:15 <pumpkin> how did you receive it?
15:15:18 <Ralith> reading directly from the socket
15:15:24 <pumpkin> oh, don't do that
15:15:25 <Ralith> (that is, reading from a handle created on the socket)
15:15:28 <pumpkin> oh
15:15:35 <Ralith> (not any kind of SSL handle)
15:15:40 <pumpkin> read :: SSL -> Int -> IO ByteString
15:15:42 <Ralith> (a standard I/O handle)
15:15:43 <mmorrow> zloog: maybe run "ghc-pkg bytestring" to see if it's seeing your new install
15:15:51 <Ralith> yeah, I saw that
15:16:02 <Ralith> was hoping for a manual decrypt so I could use the handle instead
15:16:06 <mmorrow> zloog: actually, that's odd that ghci didn't even see _any_ ByteString.Lazy
15:16:10 <rwbarton> zloog: just out of curiosity, what are you really trying to do?  Doesn't ghc come with its own ByteString?
15:16:11 <mmorrow> something might be borked
15:16:27 <zloog> Just trying to get cabal install to bootstrap
15:16:33 <pumpkin> Ralith: you really don't want to deal with that stuff yourself :P SSL supports a huge variety of negotiated ciphers
15:16:37 <zloog> and Ive done 3x full ubuntu reinstalls today :(
15:16:54 <Ralith> pumpkin: 'kay. Any way to manually wrap a handle around the provided read/write funcs, then?
15:17:18 <pumpkin> Ralith: not that I know of :/ it would be nice if the handle were a typeclass
15:17:34 <Ralith> indeed.
15:18:02 <Ralith> maybe if I can find the source of socketToHandle
15:18:04 <pumpkin> but I'm a haskell newbie so maybe someone else knows :)
15:18:42 <jml> pumpkin: there's something in RWH about handles and typeclasses
15:18:48 <mmorrow> Ralith: you can also get the Fd from a socket with `fdSocket'. maybe you can build the `SSL' (or whatever) with that
15:19:21 <pumpkin> mmorrow: I think the issue is to get a handle you can use standard IO functions on, that deals with the encrpytion/decryption for you
15:19:37 <Ralith> mmorrow: I'm not sure I follow; I've already got the SSL, now I'd like a nice standard handle.
15:19:42 <mmorrow> oh
15:19:44 <Ralith> like pumpkin said.
15:19:48 <mmorrow> what's an `SSL' made of?
15:19:52 <pumpkin> it's opaque
15:20:01 <rwbarton> zloog: you shouldn't need to upgrade bytestring for that, I'd think?
15:20:02 <pumpkin> it's probably sitting on top of openssl's BIO interface
15:20:09 <pumpkin> which is openssl's IO abstraction :P
15:20:31 <Ralith> mmorrow: I have: read :: SSL -> Int -> IO ByteString and write :: SSL -> ByteString -> IO ()
15:20:32 <mmorrow> well, you could use System.Posix.IO to create a pipe == (Fd, Fd)
15:20:40 <mmorrow> then do fdToHandle on each
15:20:45 <pumpkin> you still don't have an fd
15:20:46 <zloog> rwbarton: You know I've never seem haskell mess things up this bad. I bet the ubuntu ghc packages are borked
15:20:51 <Ralith> I can't get the BIO FD, I don't think
15:21:00 <mmorrow> then forkIO (or something) a thread to read from one, do the decrypt, then write to the other
15:21:04 <rwbarton> zloog: are you just running the bootstrap.sh script?  What's the first thing that goes wrong?
15:21:13 <monochrom> ubuntu ghc packages are very old.
15:21:25 <pumpkin> mmorrow: that's one option, but it sound slike a lot of work
15:21:26 <Ralith> mmorrow: the en/decrypt is done for me through the read/write funcs
15:21:40 <Ralith> given those two funcs, is there any way to construct a handle?
15:21:48 <zloog> rwbarton: Dunno I just brought that computer down for another reinstall
15:21:53 <mmorrow> heh, this sounds like any solution won't be particularly clean/easy/fun
15:21:58 <pumpkin> mmorrow: however, what he really needs is socketpair rather than pipe
15:22:03 <zloog> rwbarton: I'll see what does wrong in about 45 mins or so
15:22:05 <mmorrow> well, you can get that too
15:22:06 <pumpkin> Ralith: it should be possible with socketpair
15:22:10 <rwbarton> zloog: ok
15:22:12 <mmorrow> then socketToHandle
15:22:12 <pumpkin> Ralith: but probably a pain :)
15:22:17 <rwbarton> zloog: last time I tried this on debian testing it was trivial
15:22:20 <monochrom> If you mix ubuntu ghc packages (old) with hackage stuff (new), you will get version mismatch.
15:22:31 <mmorrow> (or just leave them as sockets..)
15:22:39 <Ralith> mmorrow: the problem is that socketToHandle circumvents the SSL
15:22:46 <Ralith> which means I get raw encrypted data
15:22:50 <pumpkin> Ralith: he's talking about writing your own middleman I think
15:22:56 <mmorrow> yes, exactly
15:22:56 <Ralith> ?
15:23:04 <pumpkin> Ralith: so your socketpair would make two connected sockets for you
15:23:04 <Ralith> I don't follow
15:23:21 <pumpkin> you take one of them and write a middleman on top of it that writes and reads to the SSL interface
15:23:24 <mmorrow> a thread that sits between the new socketpair and does the decryption
15:23:41 <Ralith> and then write to the second socket?
15:23:47 <mmorrow> exactly
15:23:49 <lupsyn> i have the same problem : http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/1ea1927df5f2b58b
15:23:55 <lupsyn> can someone help me ?
15:23:56 <pumpkin> Ralith: a pain, but possible :)
15:24:16 <Ralith> are you sure there's no way to just manuall construct a handle directly from read/write funcs?
15:24:19 <Ralith> manually*
15:24:34 <pumpkin> Ralith: you could make a reusable module that uses socketpair to do just that!
15:24:38 <pumpkin> I'm sure everyone would love it
15:24:38 <zloog> rwbarton: Thanks for your help, I might just make the jump to debian
15:24:51 <Ralith> possibly.
15:25:07 <pumpkin> Ralith: but as for existing stuff, I don't think there is an easier way
15:25:11 <Ralith> except that wouldn't be using socketpair so much as using a socket and two funcs
15:25:17 <Ralith> if I wanted it to be reusable
15:25:21 <Ralith> in that way
15:25:25 <pumpkin> well the socketpair is just giving you a bidirectional pipe
15:25:33 <Ralith> huh?
15:25:39 <Ralith> aren't sockets already bidirectional?
15:25:46 <pumpkin> yeah, but they have two sides :P
15:25:53 <Ralith> what?
15:26:19 <Ralith> where can I find the source for socketToHandle
15:26:31 <Ralith> in Network.Socket
15:26:46 <pumpkin> Ralith: it's almost certainly just using standard file descriptors, and not doing fancy stuff behind your back
15:26:47 <jeffz`> click the "Source" hyperlink
15:27:12 <monochrom> A socketpair gives you a phone line to the US president and a phone line to the Chinese president.
15:27:14 <mmorrow> (\rsock wsock -> let go = do chunk <- recv 4096 rsock; send 4096 wsock =<< decryptWithOpenSSL chunk in forkIO go)
15:27:41 <pumpkin> you'd probably want a select in there
15:27:46 <pumpkin> to be able to deal with both directions
15:27:55 <mmorrow> yeah, definitely something like that
15:28:09 <mmorrow> too bad the stdlibs don't have a select!
15:28:10 <pumpkin> Ralith: I wish I had a whiteboard :P
15:28:14 <pumpkin> mmorrow: really? :o
15:28:14 * Ralith is new to both sockets and haskell
15:28:19 <Ralith> this is a little confusing.
15:28:26 * mmorrow finishes his ffi c-utils pkg
15:28:28 <pumpkin> Ralith: I can expalin more in -overflow if you want
15:29:19 * loadquo is having fun with the typeclassopaedia
15:29:41 * Botje got halfway through before realizing he had some annoying deadlines
15:30:38 <loadquo> Although I can't see how to start implementing join with >>=
15:30:49 <loadquo> Maybe sleeping on it will help.
15:30:55 <lament> ohh, that join
15:31:04 * lament was confused
15:31:22 <Toxaris_> monochrom: so sockets are about political quantum entanglement
15:31:27 <lament> :t join
15:31:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:31:35 <ddarius> loadquo: You need join and fmap.
15:31:47 <ddarius> loadquo: Using both of those, it's just a matter of getting the type to work out.
15:31:53 <monochrom> No, you're the middleman between the two presidents. :)
15:32:14 <Toxaris_> oh I see. thats nice
15:33:29 <loadquo> ddarius, thanks I'll give it a go. This is not as clear as it could be -> An excellent exercise is to implement (>>=) in terms of fmap and join, and join in terms of (>>=)
15:33:41 <Gracenotes> anyone ever used a Maybe (Maybe a)?
15:34:08 <Gracenotes> (a being any type, polymorphic or not)
15:34:19 <Botje> Gracenotes: once, i think
15:34:20 <Toxaris_> yes, as temporary results e.g. from lookup
15:34:23 <ddarius> loadquo: The magic of Haskell and its type system is you don't really need to think at all to do this.
15:34:49 <loadquo> Ddarius: Actually I've implemented (>>=), I need to implement join
15:35:17 <Gracenotes> @type (>>=)
15:35:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:35:29 <andy6> hi all
15:35:30 <Botje> loadquo: the a and m b in (a -> m b) don't have to be different types.
15:35:31 <andy6> anyone here
15:35:46 <andy6> mai i ask someone a question please
15:35:48 <Botje> :t join
15:35:49 <andy6> may*
15:35:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:35:51 <loadquo> Botje, hmm.
15:36:02 <blackh> andy6: Hi there. Ask away.
15:36:17 <monochrom> Maybe (Maybe (Ask me you))
15:36:25 <andy6> i was just wondering if there is anyone who is an expert on programming
15:36:26 <Gracenotes> loadquo: here's a hint.. the "a" in >>='s type signature and the "a" in join's type signature don't have to be the same things
15:36:44 <andy6> in this room?
15:37:03 <Botje> andy6: "expert" is rather hard to define. What's your question?
15:37:28 <Toxaris_> actually, "programming" is rather hard to define, too
15:37:45 <monochrom> "anyone" is vague.
15:37:46 <Botje> loadquo: if you're still stuck, think away the (a -> m b) part of >>= and try to match it with join's
15:37:47 <loadquo> Gracenotes: I get that, I still don't see how to unwrap a layer of monadicity.
15:38:15 <Botje> if you do that, you get (>>=) :: m a -> m b
15:38:31 <blackh> I would hope I'm an expert in programming, because I don't do much else. :)
15:38:31 <ddarius> :t flip (>>=)
15:38:31 <Botje> versus join :: m (m a) -> m a
15:38:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
15:39:07 <monochrom> It is best to rename variables before matching.  join :: m (m x) -> m x.
15:39:10 <Botje> yeah
15:39:14 <Botje> i was typing that :p
15:39:21 * dolio thinks ddarius gave the best hint.
15:39:56 <andy6> ok well, I have this program called Paltalk and im not too sure if you have heard about it, its just a voice chat program where you can chat online and within that program you can only put 1 nick in 1 room, but i found a program which lets you 3 nicknames in 1 room, so i was wondering does anyone know how to put unlimited number of nicks in 1 room on a voice chat room, is anyone good at programming who knows how to do this?
15:40:02 <ErhardtMundt> bye guys
15:40:34 <andy6> Im looking for someone who is an expert on this
15:40:37 <loadquo> andy6, you probably want reverse engineers not haskell programmers.
15:40:38 <Botje> andy6: ... you probably want a freelance programmer site.
15:41:05 <monochrom> Install VMWare or VirtualBox or the like. If you want 100 nicks, run 100 virtual machines.
15:41:15 <Gracenotes> loadquo: by the way, if you want more fun figure-out-functions-based-on-types exercises, try http://blog.tmorris.net/20-intermediate-haskell-exercises/
15:41:28 <andy6> Botja and how do I find this please?
15:41:40 <Gracenotes> loadquo: they are indeed very fun :) recommended, etc.
15:41:40 <loadquo> Gracenotes: Thanks, bookmarked.
15:41:51 <jeffz`> andy6, the author of the program you're already using will probably be an expert.
15:42:34 <andy6> jeffs, but i wouldnt know who the author would be
15:43:16 <lchaplin> andy6: i run a ferelancer expert site within the open source
15:43:26 <lchaplin> freelancer*
15:44:27 <andy6> oh sounds good chaplin but do u know what i was talking about then?
15:44:45 <andy6> to put unlimited number of nicks in 1 room on a voice chat room, is anyone good at programming who knows how to do this?
15:45:18 <lchaplin> andy6: i bet there are several people who are good at this.
15:45:24 <ddarius> This doesn't sound related to Haskell programming.
15:45:46 <Cheshire> a ferelancer expert site within the open source ??
15:45:53 <dons> mmm
15:45:55 <lchaplin> Cheshire: right here.
15:46:00 --- mode: ChanServ set +o dons
15:46:01 <Cheshire> that is just a bunch of words
15:46:02 <lchaplin> i'd be interested, which programm it is, in which language it's programmed
15:46:08 <monochrom> I accidentally the word "community".
15:46:25 * loadquo solved the problem without real understanding in the end.
15:46:36 <ddarius> loadquo: That's the key.
15:46:49 <lchaplin> Cheshire: i run a open source oriented jobboard, you'll find only jobs that are OSS related there.
15:46:52 <monochrom> haha. (I agree.)
15:46:57 <pumpkin> mmorrow: thought of a possible problem with the relay+socketpair
15:47:14 <lchaplin> on the top of it, you can register and get placed, either as a freelancer or into a permament job
15:47:17 <mightybyte> Is there a way to dynamically add items to an enumerated type?
15:47:18 <andy6> chaplin, if I knew I would have told you what languaged it is in, but surely its someone who can program and build a software would know how to do this
15:47:33 <pumpkin> mmorrow: you can't select on the socket and the SSL (and selecting on the underlying socket for the SSL might not be correct)
15:47:43 <Botje> mightybyte: nope
15:47:48 <pumpkin> mmorrow: and SSL is not threadsafe
15:47:59 <pumpkin> mmorrow: so having one read thread and one write thread won't w or
15:48:00 <pumpkin> work
15:48:04 <andy6> all I need is to put unlimited number of nicks in a voice chat room
15:48:05 <andy6> thats all
15:48:20 <Botje> andy6: talk to whoever wrote paltalk.
15:48:59 <lupsyn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1459#a1462
15:49:17 <pumpkin> occurrencies? :)
15:49:19 <mightybyte> Botje: Ok.  That's too bad.  I like the type safety that enumerated types give, but I need to give my users the option of adding elements.  I guess I'll have to use a list and do my own parsing.
15:49:20 --- mode: ChanServ set -o dons
15:49:51 <rwbarton> mightybyte: right, it wouldn't be a type at all if you could do that.
15:50:01 <monochrom> Part of the safety is impossibility to dynamically add things.
15:50:26 <mightybyte> rwbarton: Is there a haskell idiom for this sort of thing...something I might not be aware of?
15:50:42 <andy6> botje, that is actually stupid, why would i talk to whoever wrote to paltalk when it has got nothing to do with paltalk, this is something that i want to know outside paltalk not within paltalk
15:50:43 * monochrom should start talking to himself.
15:51:05 <andy6> I am simply wondering if anyone in here would know how to program
15:51:09 <lchaplin> monochrom: it'll be at least somebody who not only listens, but understands you!
15:51:16 <ddarius> monochrom: That's what augustss does.
15:51:30 <Botje> andy6: go get teamspeak, skype, or that other voice chat program. this has nothing to do with programming.
15:51:34 <monochrom> monochrom: Yeah I'm inspired by augustss.
15:51:51 <mmorrow> pumpkin: oh yuk, sucky
15:52:10 <andy6> Botje, its called a crack or in other words a patchs, there is a way of doing this, what do you think this is called?
15:52:26 <Botje> sigh.
15:52:31 <zloog> rwbarton: Have you had to manualy install HTTP and network when doing the bootstrap? bootstrap fails there for me
15:52:31 <Botje> IHBT.
15:52:35 <andy6> there is a crack which lets you put 3 nicks in 1 room, but i want to it to be unlimited
15:52:40 * Botje wanders off to do something useful
15:52:44 <rwbarton> zloog: I don't think so, but I'm not sure.  How did it fail?
15:52:45 <monochrom> monochrom: It's called reverse engineering, and someone already suggested this half an hour ago.
15:52:47 <zloog> rwbarton: and I usualy have to manualy recurse through the dependences
15:52:57 <rwbarton> zloog: oh yeah
15:53:04 <rwbarton> zloog: I probably installed the native (Debian) packages
15:53:16 <Taral> ZOOG.
15:53:23 <Taral> hi everyone.
15:53:24 <andy6> mono, do you know what I am talking about here?
15:53:33 <rwbarton> zloog: e.g. libghc6-network-dev
15:53:41 <Botje> lupsyn: your howmanypixels function looks a lot like the foldrq one.
15:53:44 <monochrom> No.
15:53:58 <zloog> rwbarton: trying to get the hpaste up..
15:54:12 <zloog> rwbarton: would you recomend using the ubuntu provided network-dev then?
15:54:24 <rwbarton> zloog: yeah, try that
15:54:47 <Botje> lupsyn: for example, if you put in "\_ -> 1" as f, you get the same result for the C case.
15:55:10 <andy6> this room sounds stupid then
15:55:11 <zloog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1463#a1463 <-- All good till the very bottom. Im gonna try the package first then
15:55:19 <andy6> i mean the people in here dont know much about programming
15:55:21 <lupsyn> Botje i must do the occurrencies with foldrq
15:55:22 <Cheshire> andy6 you sound stupid
15:55:33 <luqui> this is productive...
15:55:35 <lupsyn> not the howManyPixels...
15:55:37 <Botje> andy6: go away, troll.
15:55:44 <dolio> @protontorpedo
15:55:44 <lambdabot> is haskell more powerful than perl? or scheme?
15:55:46 <monochrom> This room is stupid but at least it has 616 nicks, not just 1. <duck>
15:55:49 <ozy`> andy6: NO U
15:55:50 <Cheshire> luqui I askd you a q in coq
15:55:53 <andy6> cheshire yes I might be stupid because im in this room ffs
15:55:57 <Cheshire> lol
15:56:07 <Cheshire> andy6, pretty much covers it
15:56:20 <rwbarton> zloog: yeah, the "missing HTTP" failure is because HTTP didn't install because network was missing
15:56:32 <andy6> because this room makes others stupid and retarded, do you get the logic?
15:56:37 <Botje> sigh
15:56:40 <Botje> lunabot: ops
15:56:43 <Botje> no?
15:56:47 <monochrom> No, I don't get the logic. I'm stupid, remember?
15:56:49 <zloog> rwbarton:  <3 thanks so much for your help
15:56:50 <ozy`> @where ops
15:56:51 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
15:56:52 <dolio> @palomer
15:56:53 <lambdabot> That's a lie
15:56:55 <Botje> ah
15:57:01 <Botje> thanks, ozy`
15:57:03 <zloog> rwbarton: I'm gonna have to write myself a posit note with instructions for next time
15:57:07 <dcoutts> mm?
15:57:10 <allbery_b> hm?
15:57:12 <zloog> rwbarton: but it built fine this time
15:57:22 <Botje> andy6 the troll has been here long enough
15:57:25 <ozy`> andy6: this room is not really geared towards beginning programmers
15:57:28 <lupsyn> Botje : maybe you refer on howManypixels,don't you ?
15:57:37 <Botje> lupsyn: yes, i was referring to howmanypixels
15:57:42 --- mode: ChanServ set +o dcoutts
15:57:47 --- mode: ChanServ set +o allbery_b
15:57:51 <andy6> Botje, if your not good at programming, why the hell are u here?
15:58:05 <andy6> or anyone of you guys?
15:58:06 <allbery_b> that's enough, andy6
15:58:08 <dcoutts> andy6: please, we try to be civil here
15:58:11 <Botje> andy6: fuck off, troll.
15:58:20 <dcoutts> Botje: that's not helpful :-)
15:58:24 <Toxaris_> andy6: we have hacked ourself into IRC to enable voice chat in #haskel
15:58:26 <Cale> andy6: There are a lot of decent programmers here. What's the problem?
15:58:26 <lupsyn> Botje : foldrq (\x y z q-> 4* (x `max` y`max` z `max` q )) (\x->1)
15:58:29 <lchaplin> i'm here because i want to learn more about haskell :)
15:58:32 <Cheshire> Botje why are you so annoyed at this guy?
15:58:33 <monochrom> You know it's a troll because it went to the trouble of spending 10 minutes to build up the suspense.
15:58:44 <Botje> Cheshire: good question, actually.
15:58:45 <lupsyn> but i must resolve the occurencies problem with foldrq :)
15:58:45 <andy6> Botje, well its you who doesnt know about putting unlimited nicknames in 1 room
15:58:50 <Cheshire> it's just some kid lol
15:59:03 <Botje> guess it's because i want to help people but he keeps interspersing gibberish
15:59:05 <andy6> I am being civil
15:59:11 <allbery_b> hah
15:59:11 <lchaplin> andy6: begging and repeating won't get you any further with your programming problem.
15:59:21 <Botje> there we go
15:59:24 * Botje hums along
15:59:25 <geezusfreeek> andy6, perhaps you would get better results from a channel more specific to irc?
15:59:32 <andy6> but for some reason your just using potty language and ur exposing urself even more
15:59:37 <luqui> #Irc?
15:59:42 <andy6> are u just retarded or what?
15:59:51 --- mode: allbery_b set +b *!*n=andy@*.brnt.cable.ntl.com
15:59:59 <Botje> lupsyn: that sounds like a good start
16:00:01 <Cale> andy6: Uh, "unlimited nicknames in one room"? I'm not sure I understand your question. You're writing an IRC server?
16:00:30 <Cale> Well, whatever.
16:00:33 <Botje> i'm staring at your occurrencies function but i'm not finding a pattern
16:00:51 --- mode: allbery_b set -o allbery_b
16:01:04 <dolio> Cale: He wanted to hack some voice chat client to allow more than 3 nicknames in a room.
16:01:09 <allbery_b> that done, Botje you were being a bit OTT as well
16:01:22 <ryant5000> what does the haskell freelance market look like?
16:01:24 <dcoutts> Botje: for future reference, complain to the ops, tell us what's going on, why you're annoyed rather than making things hotter
16:01:29 <dolio> And you're not an expert programmer unless you know how to do that.
16:01:32 <lupsyn> Botje ...
16:01:38 <Botje> lupsyn: you could first determine the depth of the quadtree, then use that somehow
16:01:57 <Botje> dcoutts, allbery_b: yeah, sorry. Should have ignored him much sooner.
16:02:10 <ryant5000> is there anywhere i can go (aside from this chatroom) to find freelancers who work in haskell?
16:02:18 <dcoutts> Botje: we need help getting up to speed with the context some times
16:02:39 <lchaplin> ryant5000: it's not a haskell freelance market, it's a site where open source commited developers can register and be placed on open source projects or within companies that strongly use/support OSS
16:02:40 <Botje> yeah
16:02:57 --- mode: ChanServ set -o dcoutts
16:03:00 <Botje> i couldn't figure out a way to link the @where ops call to what happened
16:03:01 <allbery_b> (mind, I can be a hothead too, I understand. but it's preferable that people here behave like professionals)
16:03:25 <BMeph> andy6: Sorry, I accidentally the whole program. Is that okay?
16:03:29 <Botje> guess i just got mad at myself for being suckered into such an obvious troll
16:03:34 <dcoutts> Botje: you can join #haskell-ops and just tell us, or tell us directly in this channel
16:03:54 <Botje> okay, i'll do that next time. liftM2 (&&) thanks sorry :)
16:03:58 <dolio> BMeph: Dave's not here, man.
16:04:07 <dcoutts> Botje: thanks :-)
16:04:36 * monochrom wonders which monad is used there.
16:04:37 <ryant5000> lchaplin: sorry, i think i missed the first half of your comment - what's "it"?
16:04:47 <BMeph> Botje: Try my last response, if you feel the trolling to get too much. It'll make you smile a little. :)
16:04:59 <Botje> BMeph: ;)
16:05:14 <lchaplin> ryant5000: the site i'm running, i'll query you for more information about the site and not to bother other users here
16:05:32 <ryant5000> ah cool
16:07:26 <ksf> I need to match a bytestream than contains keys of various lengths (byte-aligned, though), and I don't want to do 8 matches in case the key happens to be 8 bytes long. What do I do?
16:08:00 <lupsyn> Botje : yep but i have some problem in lambda expr i tought a thing like his foldrq (\x y z q-> x+y+z+q) (\x-> if x== 0 then 1 else 0) but this isn't correct
16:09:33 <mriou_> hi, I'm hitting my head against the wall with a monad transformer and I can't quite figure it out
16:09:47 <mriou_> ideally I'd like something like this: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1425#a1425
16:10:21 <mriou_> which doesn't work, it's recursive and it can't be derived
16:10:43 <ksf> ideally, i'd like to have a trie that defines equality as isPrefixOf
16:10:53 <rwbarton> , src ''ContT
16:10:55 <lunabot>  newtype ContT i m a = C ((a -> m i) -> m i)
16:11:01 <Taral> my firewall doesn't let me connect to port 8080 :(
16:11:19 <rwbarton> mriou_: do you really want that second (Eval a)?
16:11:31 <mmorrow> Taral: the 8080 isn't needed for moonpatio.com
16:11:37 <Taral> Why isn't it newtype ContT i m a = C ((forall b. a -> m b) -> m i)?
16:11:42 <mriou_> rwbarton: I think I need it
16:12:07 <mriou_> I want Cont for continuations that would have the type signature (Eval a -> Eval a)
16:12:45 <Gracenotes> Cont confuses the hell out of me :/
16:13:14 <Taral> ,src ''ReaderT
16:13:16 <lunabot>  newtype ReaderT i m a = R (i -> m a)
16:13:35 <Taral> ,src ''ErrorT
16:13:36 <lunabot>  luna: Not in scope: type constructor or class `ErrorT'
16:13:45 <mriou_> Gracenotes: it seems to confuse me too :)
16:14:10 <Taral> O.o
16:14:17 <Taral> mriou_: Your syntax is wrong.
16:14:29 <Taral> ContT (Eval a) IO (Eval a) has too many args.
16:14:30 <mriou_> basically I had the monad defined by the ReaderT / ErrorT / IO stack, I just need to add ContT in the mix
16:15:22 <BMeph> ksf: You should use a trie. ;p
16:15:24 <mriou_> Taral: so what would be the correct syntax to define a ContT for a continuation (Eval a -> Eval a) ?
16:15:31 <Taral> mriou_: You can't constrain the return type of a monad.
16:15:59 <Taral> Continuations are X -> * where you get to define X.
16:16:09 <Taral> and * is irrelevant because they don't return.
16:16:28 <rwbarton> X is the eventual return type of your entire computation.
16:16:31 <rwbarton> @type runContT
16:16:33 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
16:16:39 <ksf> hmmm... looking at the source of bytestring-trie, I'm suspecting that it actually works like I want it to.
16:17:00 <mriou_> and I know the return type of my entire computation
16:17:09 <ksf> which'd be a bug that shouldn't be fixed.
16:17:27 <Ralith> @src maybe
16:17:28 <lambdabot> maybe n _ Nothing  = n
16:17:28 <lambdabot> maybe _ f (Just x) = f x
16:17:35 <mriou_> mmh maybe I'm confused
16:18:02 <Taral> mriou_: Remember that your monad has to thread through the entire computation, including intermediate results which can have other types.
16:18:26 <mriou_> Taral: yes
16:18:30 <Taral> Continuations allow you to escape and otherwise break the flow in specific ways.
16:18:35 <Taral> But they don't let you violate the typing.
16:18:44 * BMeph cyber-high-fives ksf
16:19:05 <chessguy> they also don't allow you to really examine the continuation function much
16:19:07 <gwern> SamB: there's only my local thih sources
16:19:08 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
16:19:12 <gwern> SamB: may be a repo or not
16:19:14 <gwern> @messages
16:19:15 <lambdabot> SamB_irssi asked 2h 7m 59s ago: do you have a repository for typing haskell in haskell ?
16:19:20 <mriou_> so assuming that I change it to be: ReaderT WyEnv (ErrorT WyError (ContT (Eval a) IO)) a
16:19:31 <Taral> That works.
16:19:56 <mriou_> but deriving still fails
16:20:00 <Ralith> what's the best way to dynamically load plugins in a haskell program?
16:20:22 <Taral> Because you end up with a toplevel of Eval (Eval (Eval ...))
16:20:32 <Taral> What does the toplevel look like?
16:20:35 <Nafai> Ralith: Here's one possibility: http://www.bluishcoder.co.nz/2008/11/dynamic-compilation-and-loading-of.html
16:20:39 <Taral> runEval :: ???
16:20:57 <rwbarton> mriou_: I had a similar experience to yours.  I didn't figure out what was wrong, but I eventually realized I really wanted the recursion in the ReaderT parameter, and newtype deriving accepted that.
16:21:14 <mriou_> newtype Eval a = E { runE :: ... }
16:21:18 <Ralith> Nafai: looks perfect, thanks
16:21:23 <Taral> What's the ...?
16:21:44 <Nafai> np
16:21:49 <Taral> or, more importantly, runE doesn't get you anything useful.
16:21:57 <Taral> It gets you a ReaderT etc. etc. etc.
16:22:10 <Taral> @type runReaderT
16:22:11 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
16:22:13 <mriou_> rwbarton: in my case the reader is really a different type (wyenv) I think
16:22:32 <mriou_> Taral: runE :: ReaderT WyEnv (ErrorT WyError (ContT (Eval a) IO)) a
16:22:35 <Taral> No.
16:22:47 <Taral> I mean I need a function runEval :: Eval ... -> IO ...
16:23:06 <Taral> Otherwise your Eval is not usable :)
16:23:14 <mriou_> let me hpaste the whole thing
16:23:17 <Taral> @type runContT
16:23:18 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
16:23:59 <mriou_> something like that: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1425#a1426
16:24:03 <rwbarton> mriou_: btw here is the code where I had a newtype similar to yours: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=749#a750 (the newtype is called R)
16:24:06 <SamB> gwern: ah
16:24:25 <SamB> gwern: well, I'd just about figured out that it wasn't published ;-P
16:24:42 <Taral> mriou_: That doesn't work. runContT needs another argument.
16:24:46 <rwbarton> mriou_: (in the end I decided my approach was totally wrong :P)
16:25:03 <Taral> And what's the type of runEval?
16:25:13 <ManateeLazyCat> rwbarton: I have implication 100% Haskell code completion with Completion UI in Emacs.
16:25:17 <mriou_> rwbarton: nice type definition though :)
16:25:53 <rwbarton> mriou_: yeah, and the code kind of half works even :)
16:25:56 <mriou_> Taral: but how the definition of runEval can impact the derivation of the Eval type
16:26:13 <rwbarton> , src ''MonadCont
16:26:14 <lunabot>  luna: Not in scope: type constructor or class `MonadCont'
16:26:15 <Taral> mriou_: Yes. I suspect you really want (Eval r a) with runEval :: Eval r r -> WyEnv -> IO r
16:26:52 <Ralith> Nafai: I get:
16:26:52 <Ralith>     Could not find module `DynFlags':
16:26:52 <Ralith>       it is a member of package ghc-6.10.1, which is hidden
16:27:14 <Nafai> Ralith: I didn't write that code, so I don't know :)
16:27:23 <Ralith> well, I thought you might have used it.
16:27:24 <mriou_> Taral: actually before I introduced continuations my runEval was runEval :: Eval a -> WyEnv -> IO (Either WyError a)
16:27:34 <Ralith> anyone know how to forcibly load a hidden module?
16:27:57 <Nafai> Ralith: Sorry
16:28:07 <Ralith> np
16:28:14 <rwbarton> Ralith: ghci -package ghc
16:28:28 <Taral> mriou_: Hm.
16:28:42 <Taral> Oh!
16:28:47 <Taral> Okay.
16:29:01 <Taral> So to add continuations, you have to track the continuation return type.
16:29:04 <Ralith> rwbarton: what's the compiletime equivalent of that?
16:29:07 <Taral> newtype Eval r a = ...
16:29:21 <Taral> Then runEval :: Eval r r -> WyEnv -> IO (Either WyError r)
16:29:26 <Ralith> same, it looks like
16:29:27 <Ralith> thanks
16:29:59 <mriou_> Taral: and then what would be runE? ReaderT WyEnv (ErrorT WyError (ContT r IO)) a ?
16:30:00 <Taral> Eval r a = E ( runE :: ReaderT WyEnv (ErrorT WyError (ContT r IO)) a
16:30:12 <mriou_> he he ok :)
16:30:22 <Taral> now the Eval is non-recursive and is thus eligible for newtype deriving.
16:30:37 <mriou_> Taral: got it
16:31:03 <Taral> The key is to realize that in the middle of the computation, callCC still needs to know what the eventual return type is so that it can construct the continuation type (r -> *)
16:31:12 <cads> hey, does lambdabot know when a person last spoke?
16:31:19 <Taral> The only place it can get it is from the monad type parameters.
16:31:26 <lament> !seen cads
16:31:43 <lament> @seen cads
16:31:44 <lambdabot> cads is in #haskell. I last heard cads speak 31s ago.
16:32:11 <mriou_> Taral: I see, I'll give it a try thanks a lot for the help!
16:32:33 <ozy`> can consyms be used as type names in addition to constructor names?
16:32:36 <mriou_> rwbarton: thanks for sharing your code too
16:35:31 <cads> @seen alc
16:35:32 <lambdabot> I saw alc leaving #xmonad, #perl6, #macosxdev and #haskell 14h 25m 47s ago, and .
16:36:29 <ManateeLazyCat> Nafai: Read message in #emacs,  i have test Haskell completion code completed. Enjoy!
16:36:39 <Nafai> YAY
16:37:07 <appletizer> @seen appletizer
16:37:07 <lambdabot> You are in #haskell and ##logic. I last heard you speak just now.
16:37:39 <mightybyte> The Pointed instance for ((->) e) would be pure = const, right?
16:37:46 <mauke> yes
16:38:03 <bos> @users
16:38:03 <lambdabot> Maximum users seen in #haskell: 666, currently: 612 (91.9%), active: 29 (4.7%)
16:38:05 <mightybyte> Ok, just making sure I'm understanding the concept.
16:38:27 <giant> anybody know anything about curry?
16:39:11 <nikn> giant: ahhhh curry is a poorly documented logic language that my teacher is making me learn :(
16:39:24 <Draconx|Laptop> giant, yeah, I just ate some.
16:39:50 <giant> this curry is not delicious
16:39:54 <ddarius> nikn: -functional- logic language
16:39:56 <ozy`> giant: I like the Thai kind best
16:41:59 <ehird> http://xahlee.org/UnixResource_dir/writ/lang_purity_cult_deception.html Ahahahaha xah lee is such a hilarious idiot
16:42:10 <lament> @quote xah
16:42:11 <lambdabot> No quotes match. Where did you learn to type?
16:42:13 <lament> @quote xahlee
16:42:14 <ehird> (includes tons of silly haskell bashing)
16:42:14 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
16:42:32 <mightybyte> @seen byorgey
16:42:32 <lambdabot> I saw byorgey leaving #haskell-overflow, #haskell-blah, #xmonad and #haskell 9h 3m 44s ago, and .
16:44:29 <lament> ehird: he's right, though, at least in that rant
16:44:46 <ehird> not really
16:45:06 <ehird> "blah i can't use these languages so they suck all the makers are evil conspirators haskell is just monads and crap woo php"
16:45:30 <lament> ehird: that's not what he says...
16:45:37 <ehird> did you _read_ it?
16:46:15 <lament> sure
16:46:34 <mightybyte> @pl g f (a,b) = (a,f b)
16:46:35 <lambdabot> g = (`ap` snd) . (. fst) . flip ((.) . (,))
16:46:40 <Botje> hmmm
16:46:45 <ehird> [00:46:31] <lament> ehird: you are so brainwashed.
16:46:46 <ehird> [00:46:34] <lament> ehird: you're part of the haskell cult.
16:46:46 <Botje> i want whatever drugs he's having
16:46:52 <ehird> --#esoteric
16:47:07 <pumpkin> :o
16:47:33 <nanothief> oooh theres a haskell cult? Where do I join?
16:47:36 <mightybyte> @pl g f (a,b) = (f a,b)
16:47:37 <lambdabot> g = (`ap` snd) . (. fst) . ((,) .)
16:47:57 <Botje> nanothief: just sign a lambda on this dotted line here >:)
16:47:58 <pumpkin> nanothief: I must first carve this lambda into your forehead
16:48:22 <mriou_> javascript and php a joy to use? the first 10mn maybe
16:48:45 <Peaker> mightybyte, you want first
16:48:53 <pumpkin> xah lee sounds silly
16:49:05 <Peaker> @type [\f (a,b) -> (f a, b), first]
16:49:07 <lambdabot> forall t t1 c. [(t -> c) -> (t, t1) -> (c, t1)]
16:49:19 <nikn> i love xah lee
16:49:21 <mightybyte> :t first
16:49:23 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:49:29 <Peaker> Cale's @type of list trick is cool
16:49:40 <ozy`> > first (+ 12) (2,2)
16:49:42 <lambdabot>   (14,2)
16:49:51 <ozy`> > second (+ 12) (2,2)
16:49:53 <lambdabot>   (2,14)
16:49:58 <ozy`> mightybyte: behold
16:50:05 <Peaker> > (first . second) (+12) ((1,2),3)
16:50:07 <lambdabot>   ((1,14),3)
16:50:12 <ozy`> > (3, 3) + (1, 2)
16:50:14 <lambdabot>       No instance for (Num (t, t1))
16:50:14 <lambdabot>        arising from a use of `+' at <inte...
16:50:33 <ozy`> well there should be.
16:50:46 <Peaker> @let onBoth=join (***)
16:50:48 <mightybyte> @hoogle first
16:50:50 <lambdabot>  Defined.
16:50:50 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
16:50:50 <lambdabot> Data.Monoid newtype First a
16:50:50 <lambdabot> Data.Monoid First :: Maybe a -> First a
16:50:56 <Peaker> @let both=join (***)
16:51:00 <lambdabot>  Defined.
16:51:02 <ozy`> :t both
16:51:04 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
16:51:15 <ozy`> :t both (+)
16:51:17 <lambdabot> forall a. (Num a) => (a, a) -> (a -> a, a -> a)
16:51:34 <mightybyte> Peaker: It's an arrow function?
16:51:43 <ozy`> :t foldlPw
16:51:45 <lambdabot> Not in scope: `foldlPw'
16:51:45 <Peaker> > uncurry (***) (both (+) (3, 3)) (1, 2)
16:51:47 <lambdabot>   (4,5)
16:51:53 <ozy`> Peaker: ahhhh
16:51:57 <Peaker> heh
16:52:04 <pumpkin> wow, xah lee's website is very personal
16:52:06 <Peaker> I'm getting good at this, my stuff's working on the first try :)
16:52:24 <Peaker> mightybyte, yeah, but for the function arrow just convert a b c to (b->c) in your mind :)
16:52:56 <gwern> SamB: turns out it was a darcs repo
16:52:56 <mightybyte> Peaker: Ahhh.  I'm in need of much better haskell-fu.
16:53:07 <Peaker> mightybyte, you can use infix type variable notation so it looks like:   (Arrow (~>)) => a~>b -> (b, b)~>(c,c)  which is easier to read
16:53:09 <gwern> SamB: it's only 236k, I could send you it
16:53:28 <Peaker> mightybyte, instead of the "a" type variable, there's a (~>) type variable and x~>y means the same as a x y
16:53:47 <SamB> gwern: okay
16:53:49 <Peaker> mightybyte, so just mechanically convert a b c    to (b->c)  before reading it
16:53:55 <Peaker> mightybyte, if Arrow a => ...
16:54:01 <SamB> naesten at gmail dot com
16:54:05 <mightybyte> I'm going through typeclassopedia.  I guess the Functor instance for ((,) e) is just second.
16:54:23 <ksf> ksf@solaris ebml % ./main edtd/ebml.edtd test.mkv
16:54:24 <ksf>     Just (Info "EBML")
16:54:24 <ksf>     Just (Info "DocType")
16:54:27 * ksf fetches a beer
16:54:29 <Peaker> mightybyte, Pretty much -- there's a minor difference but it won't bother you
16:54:30 <mightybyte> ...unfortunately, Arrows are discussed towards the end. :)
16:55:09 <mightybyte> Peaker: What's the minor difference?
16:55:14 <gwern> SamB: keep in mind this is the multiparam flavor of thih
16:55:23 <SamB> gwern: I know!
16:55:31 <gwern> jes' checkin'
16:55:35 <SamB> I wouldn't want the other one
16:55:50 <rwbarton> @src second
16:55:51 <lambdabot> Source not found.
16:55:56 <SamB> anyway, I imagine it's simpler to restrict it to SPTCs than vice-versa ;-P
16:55:56 <Peaker> mightybyte, strictness.. fmap id = id
16:56:00 <dolio> @src (->) second
16:56:00 <lambdabot> second f = id *** f
16:56:04 <rwbarton> > second id undefined
16:56:06 <lambdabot>   (* Exception: Prelude.undefined
16:56:12 <ozy`> there's got to be an easier way to define a Num instance for (,)
16:56:18 <Peaker> > fmap id undefined
16:56:20 <lambdabot>       No instance for (Show (f a))
16:56:20 <lambdabot>        arising from a use of `show' at <in...
16:56:21 <mightybyte> Peaker: Ahh
16:56:29 <mreh> what is the literal for a floating point zero?
16:56:35 <MacM> what exactly is the difference between where and let .. in? basicly a matter of taste or did i miss sth?
16:56:36 <mreh> @type 0
16:56:38 <lambdabot> forall t. (Num t) => t
16:56:45 <gwern> :t 0.0
16:56:47 <lambdabot> forall t. (Fractional t) => t
16:56:48 <ozy`> :t (0 :: Float)
16:56:49 <lambdabot> Float
16:56:51 <rwbarton> MacM: there are some small differences
16:56:57 <mreh> tah
16:56:58 <gwern> Fractional? the heck
16:57:06 <ozy`> mreh: literals are overloaded, after all
16:57:09 <rwbarton> MacM: let ... in ... is an expression, while where attaches to declarations
16:57:12 <ksf> it's basically a matter of syntactic mastery.
16:57:16 <mightybyte> Peaker: So second doesn't meat the strictness property?
16:57:23 <pumpkin> http://lol.whygitisbetterthanx.com/#cheap-local-branching
16:57:35 <mreh> ozy`: how do i force a float 0 then?
16:57:46 <mreh> :t 0.0
16:57:47 <lambdabot> forall t. (Fractional t) => t
16:57:52 <MacM> rwbarton: expression means i can use them anywhere in my code?
16:57:57 <mreh> :t div
16:57:59 <lambdabot> forall a. (Integral a) => a -> a -> a
16:58:24 <rwbarton> MacM: well, anywhere an expression is expected, which is most places :)
16:58:38 <rwbarton> MacM: You can use where to define things in guards  f x | p = y where p = ...
16:58:40 <MacM> rwbarton: yeah ;)
16:59:15 <dolio> pumpkin: Is that automatically translated from something else (I hope)?
16:59:30 <pumpkin> dolio: yeah :P english, I think
16:59:37 <luqui> :t 0 :: Float
16:59:38 <lambdabot> Float
16:59:49 <ksf> I've yet to see a git vs. darcs comparisons that take either one apart.
16:59:52 <Peaker> mightybyte, second id does not have to equal id.  fmap id does.  so fmap id (undefined::(Int,Int)) = undefined, whereas I think second id (undefined::(Int,Int)) = (undefined, undefined)
16:59:58 <ksf> s/a//
17:00:22 <Peaker> > fmap id (error "boo!")
17:00:24 <lambdabot>       No instance for (Show (f a))
17:00:24 <lambdabot>        arising from a use of `show' at <in...
17:00:28 <Peaker> > fmap id (error "boo!" :: (Int,Int))
17:00:30 <lambdabot>   * Exception: boo!
17:00:36 <Peaker> > second id (error "boo!" :: (Int,Int))
17:00:38 <lambdabot>   (* Exception: boo!
17:00:54 <mightybyte> Peaker: Ok.  That's subtle.
17:00:58 <Peaker> mightybyte, see? it was (undefined, undefined) so the show did show the "("
17:01:34 <Peaker> mightybyte, if Haskell didn't "lift" type products (if type products did not introduce new bottoms) we wouldn't have this subtle difference
17:01:35 <mreh> :t (0.0, 2 `div` 4)
17:01:38 <lambdabot> forall t t1. (Integral t1, Fractional t) => (t, t1)
17:01:42 <mreh> whaa?!
17:01:59 <mreh> oh
17:02:11 <mreh> :t 2 `div` 4
17:02:13 <lambdabot> forall t. (Integral t) => t
17:02:19 <luqui> Double is a fractional, Int is an Integral, so this sig is consistent with (Float, Int)
17:02:26 <mreh> yeah, i got it
17:02:36 <mightybyte> Peaker: That makes sense.  Although I think it will be awhile before I can really internalize all the implications there.
17:02:36 <loadquo> :t ((->)e)
17:02:38 <lambdabot> parse error on input `->'
17:02:40 <mreh> so why isnt 2 `div` 4 a fractional?
17:03:04 <pumpkin> :t div
17:03:06 <lambdabot> forall a. (Integral a) => a -> a -> a
17:03:11 <mreh> hmm
17:03:14 <ozy`> Peaker: what is lifting of type products? is this some kind of christian magic...?
17:03:17 <pumpkin> :t (/)
17:03:18 <mreh> :type `\`
17:03:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:03:25 <mreh> heh
17:03:29 <mreh> okay
17:03:55 <Peaker> ozy`, basically what "data" does and "newtype" doesn't
17:04:49 <Peaker> ozy`, data Blah = Blah Type1 Type2 Type3   -- Blah is a Type "product" of Type1, Type2, Type3.  Values of type Blah may not just be (Blah .. .. ..) where each .. can be "undefined" but also the entire value can be "undefined" -- but this is not actually necessary in a type product
17:05:14 <Peaker> ozy`, If the value itself can be undefined, then the type is lifted, I think (I am reverse engineering terminology from the newsgroup discussions :-)
17:05:14 <mightybyte> ozy': Lifting of type products = introduction of a new bottom (my paraphrase)
17:05:22 <Peaker> Yeah
17:05:40 <luqui> Peaker, yeah that's right.   "lift" means "add a bottom"
17:05:56 <Peaker> ozy`, For data Blah = Blah | Bleh -- it makes sense that Blah can be bottom, its a type sum and its unclear which constructor it is. If there's only one constructor then its unnecessary
17:06:08 <Peaker> s/newsgroup/mail-list
17:06:22 <Peaker> luqui, great, thanks.  If I RE terms wrongly, I may misunderstand whole discussions :)
17:06:28 <ksf> the mnemonic is easy: if you lift something, you can see its bottom side.
17:06:40 <luqui> nice =)
17:07:16 <Peaker> ozy`, but people don't like the idea that changing:  data Blah = Blah Type1 Type2  to   data Blah = Blah Type1 Type2 | Something -- introduces a new bottom
17:07:18 <mightybyte> Peaker: So would ((,) e) have a Pointed instance?
17:08:04 <Peaker> mightybyte, The class hierarchy is basically Functor => Pointed => Applicative => Monad (Maybe there are more in there).  Since ((,) e) is a Monad (at least if e is a Monoid) then ((,) e) must also be Pointed (at least if e is a Monoid)
17:08:06 <ksf> Haskell doesn't have blunt arrows, they're all pointed.
17:08:21 <idnar> that's disappointing
17:08:23 * idnar ducks
17:08:38 <Peaker> doh, I have work to do but #haskell is more interesting :-(
17:08:42 <jekor> Question about idiomatic usage. I have a type that's shuffled back and forth between a database. I'd like to also have a "not fully initialized" version of this type. Does it make sense to use a type = declaration and keep unused fields undefined (doesn't seem safe) or make the type with 2 type constructors (in which case I would have to pattern match in my functions?)?
17:08:44 <mightybyte> Peaker: Ok.  For a moment I was thinking it didn't have one.
17:08:48 <idnar> Peaker: I think it's Functor => Pointed => Applicative => Branchy => Monad now ;)
17:08:51 * mightybyte goes off to derive it.
17:09:02 <Peaker> idnar, hehe, Branchy is too arbitrary :-)
17:09:13 <dolio> What's a branchy?
17:09:56 <Peaker> mightybyte, it only needs a pure method on top of Functor, right?  The problem is generating a value of type (e) for ((,) e). so if its Monoid you have "mempty". But maybe you can also use a Zero class which can be a superclass of Monoid
17:10:04 <jekor> 2 data constructors, rather.
17:10:15 <Peaker> dolio, Its an Applicative with a choice
17:10:20 <idnar> dolio: Applicative + ifB :: (Branchy b) => b Bool -> b a -> b a -> b a
17:10:41 <Peaker> dolio, you get to look at the applicative's value to choose which effect to combine, but not for any other purpose
17:10:43 <mightybyte> Peaker: Yeah, I was trying to figure out where the default for e would come from.
17:10:55 <dolio> Ah.
17:11:13 <mightybyte> You could require "instance (Pointed e) => Pointed ((->) e)..."
17:11:23 <Peaker> mightybyte, That's why the instance for Monad is:  instance Monoid e => Monad ((,) e) where ... return = (mempty,) -- if sections of (,) were allowed :-)
17:11:56 <gwern> 'Ranjit Bhatnagar once told me the following story: A young boy, upon hearing the legend of Milo of Croton, determined to do the same. There was a calf in the barn, born that very morning, and the boy resolved to lift up the calf each day. As the calf grew, so would his strength, day by day, until the calf was grown and he was able to lift a bull.
17:12:00 <Peaker> mightybyte, that's overly restrictive -- e can have kind *, it doesn't need to be *->*
17:12:01 <gwern> "Did it work?" I asked.
17:12:04 <gwern> "No," said Ranjit. "A newborn calf already weighs like a hundred pounds."'
17:12:07 <ddarius> Peaker: You can just write (,) mempty (I might be missing some context?)
17:12:07 <gwern> base case fail :)
17:12:11 <gwern> http://blog.plover.com/misc/Milo.html
17:12:30 <ddarius> Moral of the story: Milo was a beast
17:12:35 <idnar> gwern: hahaha
17:12:47 <Peaker> ddarius, Heh, yeah, the missing sections are more annoying when you want flip (,) mempty
17:13:28 <mightybyte> Peaker: Hmmm, then it would seem that there is a relationship between Pointed and Monoid that is not pictured in byorgey's type class relationships diagram.
17:13:34 * gwern now feels silly - I've heard the story of milo many times, and I knew calves weighed *a lot*, but I never put the two together
17:14:22 <idnar> Peaker: (,) sections look pretty ugly anyhow
17:14:44 <idnar> but maybe that's just because I don't really think of (,) as an operator in the first place
17:14:47 <Peaker> idnar, I disagree, (,) is just an operator
17:14:51 <Peaker> heh
17:15:10 <mauke> > (1,)
17:15:12 <lambdabot>   <no location info>: parse error on input `)'
17:15:21 <idnar> Peaker: the thing is, you can squint at (,) and make it an operator, but (,,) just totally screws you over :P
17:15:23 <Peaker> mightybyte, its not between Pointed and Monoid in general, just between Pointed, (,) e, and Monoid in particular
17:15:29 <rwbarton> :t (,,)
17:15:31 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
17:15:32 <mauke> > let (?) = (,) in (1?)
17:15:33 <idnar> because it's not (foo ,, bar baz) :P
17:15:34 <lambdabot>       Overlapping instances for Show (b -> (t, b))
17:15:34 <lambdabot>        arising from a use ...
17:15:37 <Peaker> idnar, Well, (,,) shouldn't have existed in the first place
17:15:44 <Peaker> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
17:15:46 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
17:15:46 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
17:15:46 <lambdabot> t110 t111 t112 t113 t114 t115 t116 t117 t118 t119 t120 t121 t122 t123 t124 t125 t126. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -
17:15:46 <lambdabot> > x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 ->
17:15:48 <lambdabot> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 ->
17:15:51 <lambdabot> [5 @more lines]
17:16:04 <Peaker> heh sorry I thought it wouldn't exist
17:16:06 <idnar> er, I thought ghc only went up to 63 or something
17:16:14 <Peaker> only in instances
17:16:21 <Peaker> this is all pointing towards: "N-tuples were a mistake"
17:16:32 <dolio> It has arbitrarily large N-tuples.
17:16:45 <Peaker> It should have just built these tuples with 2-tuples
17:16:46 <dolio> Although it starts crashing at some point when you use them in certain ways.
17:16:59 <Peaker> No instances beyond 16-tuples I think
17:17:05 <idnar> dolio: oh boy
17:17:15 <rwbarton> It also crashes on (-1)-tuples.
17:17:29 <idnar> well
17:17:40 <idnar> anyone using tuples that big should probably be shot anyway
17:17:41 <SamB> and mine type-errors on 1-tuples
17:18:00 <idnar> uhm, how do you construct a (-1)-tuple or a 1-tuple?
17:18:13 <SamB> idnar: TH for 1-tuples at least
17:18:21 <SamB> it isn't supposed to happen
17:18:24 <idnar> ah
17:18:33 <rwbarton> yeah, TH for (-1)-tuples also
17:18:47 <porges> 1-tuple is a datatype data Id a = Id a
17:18:50 <SamB> well, I mean, the semantics hadn't been thought of until someone reported the issue ;-P
17:18:56 <porges> there is a hackage package for it :)
17:18:59 <rwbarton> There are a lot of things you can do with TH that crash ghc. :)
17:19:10 <idnar> porges: that's not a tuple :P
17:19:36 <idnar> how do you get a (-1)-tuple in TH?
17:19:46 <rwbarton> idnar: gimme a sec
17:19:49 <SamB> idnar: well, you can't use native 1-tuples because the syntax is already taken -- and how would you write the tycon anyway?
17:20:01 <SamB> or the regular con, unapplied, for that matter
17:20:06 <idnar> SamB: well, yes, I'm just saying
17:20:22 <SamB> , tupleT (-1)
17:20:23 <lunabot>  TupleT (-1)
17:20:38 <luqui> pythony (Int,)  -- gross
17:20:45 <rwbarton> , $( return $ SigE (VarE (mkName "undefined")) (TupleT (-1)) )
17:20:46 <lunabot>  luna: no output
17:20:57 <idnar> oh, right
17:21:03 <idnar> guess I need to learn more TH
17:21:03 <porges> luqui: and (Int,) should be a section on (,) :)
17:21:12 <luqui> yeah, it should be
17:21:26 <luqui> oh, I wish there were tuple sections
17:21:29 <ozy`> porges: that would be nice
17:21:31 <idnar> luqui: having a 1-tuple in Python usually means you're Doing It Wrong
17:21:39 <lament> s/1-//
17:21:49 <luqui> I don't really do python
17:21:53 <idnar> luqui: except in some cases, it's just that GvR already Did It Wrong :/
17:21:59 <luqui> what would a 1-tuple be used for?
17:22:06 <ksf> I don't use tuples except as return types.
17:22:06 <porges> luqui: it has another value
17:22:16 <luqui> I mean in python
17:22:18 <SamB> luqui: more ways to phail!
17:22:38 <luqui> an extra None, just like the extra _|_ in a haskell oneple?
17:22:40 <SamB> oh, in python, it would probably just comply with the expectations of some silly n-tuple using code
17:22:46 <ksf> tbh, fst and snd suck.
17:22:55 <shapr> ksf: Why?
17:22:58 <ksf> there should be general functions for those
17:23:05 <shapr> Huh?
17:23:10 <porges> ksf: cabal install nthable :D
17:23:20 <ksf> like s1o2, s2o2, s1o3, s2o3, s3o3...
17:23:27 <luqui> if I were to do it, all products would be binary and , would be right-associative
17:23:32 <shapr> ksf: You could TH it.
17:23:33 <ozy`> hmm, can TH be used to make "fake" dependent types for (e.g.) fixed-length, uniformly-typed list-ish structures??
17:23:36 <ozy`> -?
17:23:40 <porges> @hackage nthable
17:23:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nthable
17:24:08 <luqui> ozy`, depending on the level of reification you want
17:24:31 <dolio> ozy`: You don't need template haskell for that.
17:24:35 <ozy`> luqui: I'm thinking of Tim Sweeney's wish list... that was the one feature that isn't in haskell, IIRC
17:24:42 <ozy`> dolio: no?
17:24:59 <ksf> there's a lesson to be learned from cadddaaadddadaddadaaadddadaddaddaaadr.
17:25:23 <luqui> don't use complex untagged data structures?
17:25:28 <rwbarton> heh, [$lisp|cadddaaadddadaddadaaadddadaddaddaaadr|]
17:25:33 <idnar> abracdrabra?
17:26:11 <luqui> the same lesson is to be learned from fst . snd . snd . snd . fst . fst . fst . snd . snd . snd . fst . snd . fst . snd . snd . fst . snd . fst . fst . fst . snd . snd . snd . fst . snd . fst . snd . snd . fst . snd . snd .fst . fst . fst . snd
17:26:17 <ksf> ok, there's more than one lesson to be learned.
17:26:44 <SamB> ksf: use Integer for opcodes ?
17:26:54 <luqui> lol
17:27:26 <rwbarton> :t fst . snd . snd . snd . fst . fst . fst . snd . snd . snd . fst . snd . fst . snd . snd . fst . snd . fst . fst . fst . snd . snd . snd . fst . snd . fst . snd . snd . fst . snd . snd .fst . fst . fst . snd
17:27:28 <lambdabot> forall a b a1 a2 a3 b1 b2 b3 a4 a5 a6 b4 a7 b5 a8 a9 b6 a10 b7 b8 b9 a11 a12 a13 b10 a14 b11 a15 a16 b12 a17 a18 b13 b14 b15 a19. (a19, ((((a18, (a17, ((a16, (a15, ((a14, ((a13, (a12, (a11, ((((a10,
17:27:28 <lambdabot> ((a9, (a8, ((a7, ((a6, (a5, (a4, ((((a3, (a2, (a1, (a, b)))), b1), b2), b3)))), b4)), b5))), b6)), b7), b8), b9)))), b10)), b11))), b12))), b13), b14), b15)) -> a
17:28:36 * SamB thinks luqui wrote a script to convert that
17:28:40 <gwern> hm. this is strange
17:28:57 <SamB> gwern: what ?
17:28:58 <gwern> is there erally no bug report for 'ghc api users crash at runtime if they are compiled for profiling'?
17:29:16 <gwern> I've been running into that for so long I just assumed that there was one
17:29:19 <SamB> gwern: oh. I guess nobody was stupid enough to try it yet
17:29:25 <SamB> or not
17:29:39 <SamB> does it happen every time ?
17:29:42 <ddarius> "SamB: Master of Tact"
17:29:45 <gwern> like clockwork
17:29:52 <SamB> every app?
17:29:52 * gwern feels bad
17:30:03 <gwern> that I've tried
17:30:05 <BMeph> Well, 60% of the time... ;p
17:30:16 <SamB> even haddock ?
17:30:31 <gwern> never been foolish enough to install haddock with profiling
17:30:33 <gwern> lemme try
17:31:03 * SamB suspects it's the GHCi-ish bits that don't like profiling
17:32:13 <luqui> SamB, heh, no, I was going to do the first 10 or so then write an ellipsis, but I guess I got carried away
17:32:15 <gwern> interesting, haddock doesn't mind profiling
17:32:43 <lispy> Hmm...I get highlighted here a lot lately, but by the time I check the scroll back it's gone.
17:32:45 <SamB> gwern: ah, so it's probably just loading stuff dynamically that should fail with an error
17:32:51 <gwern> (this is why I never filed a bug report, couldn't be arsed to do a minimal case)
17:33:16 <gwern> lispy: solution: increase scrollback or save highlights. any irc client worth a damn can do both
17:33:18 <SamB> gwern: just say "anything that loads modules"
17:33:19 <lispy> Hi gwern.  How is it going?
17:33:41 <ozy`> lispy: what, do you have your client set to pick up /c[ad]+r/?
17:33:45 <gwern> lispy: well. I'm still working on gitit. the interwiki plugin is not going well, and john won't comment on why which is annoying
17:33:57 <SamB> well, I mean, even haddock loads modules -- but only if you use TH
17:34:09 <gwern> and he refuses to believe me that profiling + GHC API just don't mix
17:34:17 <lispy> heh
17:34:21 <lispy> gwern: have patience :)
17:34:42 <SamB> gwern: at least they mix SLIGHTLY better than GHCi and profiling
17:34:54 <gwern> SamB: that doesn't even compile?
17:35:20 <SamB> gwern: hmm.
17:35:38 <lispy> gwern: does gitit support darcs now?
17:35:55 <SamB> well, I think that's just because the build script is written to know that that's stupid
17:35:55 <lispy> darcsit?
17:36:00 <gwern> lispy: oh yes
17:36:04 <lispy> gwern: very cool!
17:36:09 <gwern> that's been done since like ~20 jan
17:36:12 <lispy> ah progress
17:36:18 <SamB> gwern: how about tla ?
17:36:37 <lispy> Is tla still a serious vcs?
17:36:44 <gwern> SamB: couldn't care less about tla; you want it, add it to filestore
17:36:46 <SamB> no I'm just jerking his chain
17:36:50 <SamB> or something
17:36:56 <SamB> I couldn't care less about TLA either
17:37:10 <SamB> which is to say that it is my current least-favorite VCS
17:37:15 <gwern> then we are agreed.
17:37:23 <SamB> I'd rather use tarballs than tla, really
17:39:38 <mmorrow> is it legal syntactically in C to have a function that return a function ptr?
17:39:55 <pumpkin> mmorrow: don't see why not
17:39:56 <ddarius> Why not?
17:40:02 <pumpkin> you could typedef it to make it prettier
17:40:07 <mmorrow> preflex: cdecl doesn't like it
17:40:08 <preflex>  trailing garbage
17:40:11 <mmorrow> (i'm writing a parser)
17:40:14 <kmeyer> mmorrow: yup, just fine
17:40:25 <mmorrow> how do you say it?
17:40:31 <mmorrow> preflex: cdecl (void*(*)(void*))f(void* x,void* y)
17:40:32 <preflex>  missing type
17:40:34 <ddarius> I'd highly recommend making a typedef.
17:40:38 <mmorrow> preflex: cdecl void*(*)(void*)f(void* x,void* y)
17:40:39 <preflex>  trailing garbage
17:40:44 <mmorrow> ddarius: it's for a parser
17:40:51 <mmorrow> i'm not actually doing it myself
17:41:11 <mmorrow> preflex: cdecl void*f(void* x,void* y)
17:41:12 <preflex>  f: function(x: pointer to void, y: pointer to void) returning pointer to void
17:41:27 <xmux> mmorow: signal() does exactly that
17:41:34 <pumpkin> is there a good solution to this problem? I have a unix account on my school's network, and some machines are 32-bit and others 64-bit. I installed ghc and cabal in my home dir as it was a pain to get the sysadmins to put it everywhere
17:41:35 <mauke> preflex: cdecl void *(*f(void *x, void *y))(void *)
17:41:35 <preflex>  f: function(x: pointer to void, y: pointer to void) returning pointer to function(pointer to void) returning pointer to void
17:41:38 <lispy> The syntax is a little non-obvious, IIRC.  But like othres have said, typedef it and they will come...er parse.
17:41:40 <mmorrow> ahhhh
17:41:44 <mmorrow> cool
17:41:54 <pumpkin> and now I have ghc and cabal (and its products) that only work on 64-bit machines
17:41:59 <SamB> mmorrow: is there some kind of issue with Language.C?
17:42:01 <pumpkin> is there an elegant way to keep them separate?
17:42:06 <ddarius> lispy: I didn't understand what he was saying before, but he's writing something that will parse (this part of) C.
17:42:16 <SamB> pumpkin: chroot ?
17:42:24 <sjanssen> pumpkin: you can keep separate bin32 and bin64 directories
17:42:29 * lispy goes to find a mouse
17:42:38 <pumpkin> sjanssen: and then switch on the arch in my startup script
17:42:38 <pumpkin> hmm
17:42:40 <xmux> The man page for signal() on OS X even has an example of the typedef you should write
17:42:42 <pumpkin> I guess
17:42:45 <pumpkin> *sigh* :P
17:42:53 <sjanssen> pumpkin: right
17:43:07 <pumpkin> linux needs mac os' fat binaries :P
17:43:20 <pumpkin> (and ghc needs to know how to produce them)
17:43:28 <rwbarton> pumpkin: your home directory isn't on an AFS file system is it?
17:43:28 <mauke> xmux: if it's like linux's, it's the wrong kind of typedef to use
17:43:32 <pumpkin> rwbarton: nfs
17:43:35 <ozy`> pumpkin: it will never happen
17:43:38 <pumpkin> ozy`: I know :)
17:43:44 <mauke> one of the cardinal rules is: you do not hide pointers behind typedefs
17:43:46 <mmorrow> SamB: i'm not a huge fan, since it rejects certain progs under whatever circumstances it checks for, it doesn't have valid Show instances, the AST is on the verbose side (wrt inspecting the prettyprinted _AST_ (not c code)), and it's kinda heavy-weight
17:43:53 <ozy`> pumpkin: you could try to get the haiku folks to implement it though ;)
17:44:16 <xmux> I think function pointers are an acceptable exception to that rule
17:44:25 <xmux> Since the syntax is generally so unweildly
17:44:26 <pumpkin> mmorrow: what are you writing?
17:44:39 <mmorrow> i'm just making a parser for function prototypes, structs, enums, unions, typedefs so i can autogenerate haskell code to import the via the ffi
17:44:45 <mauke> xmux: I disagree
17:44:48 <rwbarton> pumpkin: once you get the PATH issue sorted out ghc should keep its package configurations and libraries separate automatically
17:44:51 <pumpkin> mmorrow: whee, I was just talking about that with someone
17:44:59 <SamB> mmorrow: show instances ?
17:45:07 <mmorrow> pumpkin: yeah, i finally got fed up with doing all this by hand
17:45:09 <xmux> I agree with you in every other case though.  I don't like people that do that either (*cough* win32 *cough*)
17:45:17 <mauke> xmux: there's nothing wrong with typedef void sighandler_t(int); sighandler_t *signal(int, sighandler_t *);
17:45:39 <mmorrow> SamB: read . show /= id   for the language-c ast
17:45:43 <pumpkin> one thing I didn't like about language-c is that it doesn't seem very well suited to generating c, only parsing it
17:45:52 <mmorrow> yeah, that too
17:45:56 <xmux> oh, is that a correct definition?  Yeah, that's not nearly as bad as I thought it would look
17:45:59 <pumpkin> I was trying to generate a header the other day
17:46:10 <pumpkin> and it was a real nightmare filling all the declarations with bogus parser data
17:46:18 <Ralith> when using the GHC API to dynamically compile and load functions, how do you make it *re*load from source without restarting the entire program? Whenever I rerun the load functions, they source pointed at doesn't seem to actually recompile.
17:46:21 <SamB> mmorrow: ah, you should have said that Read and Show are not compatible
17:46:28 <SamB> or that there is no Read
17:46:31 <SamB> or something
17:46:31 <xmux> I've been programming in C for more than a decade and I still have no idea how to write function pointer declarations off of the top of my head
17:46:33 <gueux> I have a function of type String -> Bool; the cases [] and x:xs are treated
17:46:39 <mmorrow> SamB: in other words, show doesn't produce valid haskell code
17:46:54 <SamB> mmorrow: hey, that's a different problem
17:46:56 <gueux> but I have an error: Exception: Game.hs:56:0-55: Non-exhaustive patterns in function
17:46:56 <mmorrow> derived instances of show do
17:47:09 <mmorrow> thus enabling you to parse the show output as haskell code
17:47:14 <erikc> pumpkin: make a universal binary with the elf32/elf64 files and then use binfmt_misc to choose the right one :)
17:47:16 <mmorrow> with haskell-src-exts for instance
17:47:25 <mauke> xmux: you're doing it wrong :-)
17:47:27 <gueux> is it a problem with eof or something like that?
17:47:29 <mauke> gueux: compile with -Wall
17:47:30 <luqui> xmux, void (*foo)(int);  isn't it obvious that this declares a variable named foo?
17:48:03 <luqui> ... of type, umm... void (*)(int)
17:48:05 <xmux> luqui: Yes, I can read that, but I couldn't write it myself without a reference.  It's also the most trivial case
17:48:08 <mmorrow> SamB: yeah, there probably isn't a Read for the ast anyways
17:48:21 <SamB> mmorrow: I don't see a Show in the haddock at all
17:48:31 <mmorrow> SamB: heh
17:48:32 <SamB> so it doesn't seem like a big problem
17:48:37 <mmorrow> probably disappeared
17:48:38 <luqui> xmux, yeah.  how do you declare a const function pointer?! :-)
17:48:47 <luqui> void (*foo const)(int) ??
17:48:53 <SamB> i.e. you could request that deriving (Read,Show) be added to the AST types now
17:49:07 <SamB> or add it yourself
17:49:13 <mmorrow> SamB: that's not the only reason i'm not using it
17:49:16 <mmorrow> (and i have)
17:49:21 <mauke> luqui: no, that's obviously a syntax error
17:49:29 <xmux> luqui: heh, I guess I missed your initial sarcasm :)
17:49:32 <luqui> mauke, of course!
17:49:38 * gwern edits my little wiki with a short essay about working memory & the N-back game. gitit is much more pleasant to work with than mediawiki!
17:49:39 <mauke> luqui: "const" either appears as part of the base type (at the very beginning) or in "* const"
17:49:41 <chessguy> err
17:49:45 <chessguy> what?
17:49:57 <SamB> mmorrow: have you submitted tickets for all of your issues ?
17:49:58 <chessguy> for a second there i thought i was not in #haskell
17:50:27 <chessguy> gwern:  what's the N-back game?
17:50:28 <gwern> chessguy: was it nice where you were not?
17:50:29 <mauke> well, or in [const] (but that's C99)
17:50:48 <luqui> mauke, there are three consts on functions (two of them nonsense):  a const pointer to a function, a pointer to a const function, and a pointer to a function returning const
17:50:54 <luqui> is one of these not representable?
17:51:07 <gwern> chessguy: it's a little puzzle game that exercises working memory. it's interesting because it's one of the very few things which seems to boost working memory and thence g
17:51:21 * ksf thinks the show instance of word8 bytestrings should print hex.
17:51:26 <mauke> luqui: yes, the const function
17:51:37 <luqui> ok
17:51:37 <ksf> they're not char for a reason, after all.
17:51:41 <pumpkin> ksf: I agree
17:51:41 <mmorrow> SamB: my issue is with how the entire AST/lib is designed. i don't think a ticket for that will be well-recieved. (i'm not knocking/dissing the library at all. just saying what it's made to be good at isn't what i'm looking for)
17:51:45 <xmux> hmm, should const function prevent self modifying code? :)
17:51:47 <gwern> chessguy: the academic research on it is interesting. the latest paper, which drew me in, demonstrated brainchemistry changes from regular n-back playing. (dopamine receptor changes iirc)
17:51:50 <luqui> let that be a lesson to us: do *not* try to make types resemble their usage
17:52:00 <mauke> luqui: const arrays also don't exist
17:52:10 <mauke> (arrays have no mutable structure)
17:52:13 <luqui> mauke, good point
17:52:44 <SamB> mmorrow: well, surely you could still steal their parsing code ?
17:52:55 <ksf> it's hard enough not to get confused by endianess alone, there's no need to add escape code parsing and decimal->hex conversion.
17:53:04 <porges1>  > idnar: Peaker: I think it's Functor => Pointed => Applicative => Branchy => Monad
17:53:04 <ksf> s/hard/easy
17:53:14 * ksf hopes that was a freudian mistake.
17:53:15 <porges1> idnar: Should be Applicative => Pointed
17:53:22 <ddarius> All you do is write a converter from their AST to the AST you'd like.  No reason to rewrite the parsing code.
17:53:24 <mmorrow> SamB: heh. i think that would be harder than writing my own parser (for a very limited subset of the C lang)
17:53:34 * ksf is obviously too drunk to parse his own "not".
17:53:38 <rwbarton> mauke: what is  typedef void sighandler_t(int); sighandler_t * const foo;  ?
17:53:44 <Peaker> porges1, Doesn't Pointed only add "pure"?
17:53:59 <porges1> yeah but there are some things you can write applicative for you can't write pointed for
17:53:59 <ksf> it's Pointed => Functor
17:53:59 <SamB> mmorrow: what's it for, then ?
17:54:00 <mauke> rwbarton: foo: const pointer to sighandler_t
17:54:20 <rwbarton> mauke: oh right, how about const sighandler_t *foo; ?
17:54:32 <mauke> ooh, got me there
17:54:41 <rwbarton> can it be written without a typedef?
17:54:45 <mauke> no
17:54:51 <rwbarton> :o
17:54:59 <Peaker> porges, how can you implement both pure, <*> but not be able to implement pure?
17:55:08 <mauke> rwbarton: I don't know if that's legal :-)
17:55:13 <porges> I meant applicative as in<*> without pure
17:55:18 <porges> since pointed is split :)
17:55:29 <rwbarton> mauke: gcc -Wall didn't comment about it
17:55:39 <ksf> ...especially 'cos the <*> laws include pure.
17:55:39 <mauke> we'll see about that
17:55:55 <Ralith> anyone? how do I reload things, as GHCI seems to do with no issues?
17:56:09 <mauke> try.c:3: warning: ISO C forbids qualified function types
17:56:22 <rwbarton> ah
17:56:26 <ksf> -std=C99?
17:56:32 <ksf> never compile without that.
17:56:37 <gwern> Ralith: reload in what?
17:56:45 <mauke> preflex: ? cflags
17:56:45 <preflex>  -std=c89 -pedantic -Wall -W -Wno-missing-field-initializers -Wundef -Wendif-labels -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -O2
17:56:54 <Ralith> gwern: Haskell
17:56:56 <mmorrow> SamB: autogenerating haskell from c headers
17:57:17 <gwern> Ralith: I don't follow
17:57:22 <rwbarton> seems like -pedantic is the relevant option
17:57:26 <SamB> mmorrow: so ... uh ... why do you only need a subset then ?
17:57:26 <pumpkin> mmorrow: [$include| header.h |] ? :P
17:57:31 <dolio> So, -Wall misses a lot of -Ws?
17:57:34 <Ralith> gwern: I'm using GHC to build and load functions at runtime
17:57:39 <mauke> dolio: hell yes
17:57:45 <SamB> mmorrow: I'd expect a supperset!
17:57:46 <dolio> Nice.
17:57:47 <gwern> ah, so you're using the ghc api
17:57:50 <Ralith> gwern: when I repeat the procedure for an existing module, the functions do not appear to be rebuild even though the source has changed.
17:58:09 <Ralith> gwern: I want the functions to be updated based on the source, as happens when you :load in ghci.
17:58:18 <dolio> Shouldn't that be, like, -Wsome?
17:58:22 <gwern> Ralith: it's been a while since I've done any lowlevel ghc api stuff, but you could call reset and reload everything from file couldn't you?
17:58:28 <Ralith> call reset?
17:58:33 <mmorrow> pumpkin: i just want to handle function protos, structs, unions, enums, and typedefs
17:58:38 <Ralith> where's reset?
17:58:40 <mauke> gcc -Larry -Wall
17:58:45 <mmorrow> SamB: heh
17:58:46 <ksf> :r[eload]
17:58:51 <pumpkin> mmorrow: just saying something like that would be neat :)
17:59:04 <SamB> mmorrow: are you laughing at the typo or the idea ?
17:59:05 <gwern> ksf: no, he's in the ghc api and wants to mimick ghci
17:59:19 <mmorrow> pumpkin: oh, i just understood what that was supposed to mean.
17:59:22 <gwern> Ralith: whatever module supplies it I guess
17:59:25 <SamB> mmorrow: what about inlines ?
17:59:27 <ksf> well, that's where he can start do look to figure out how ghci does it.
17:59:33 <Ralith> gwern: any ideas?
17:59:34 <mmorrow> SamB: heh, i didn't even notice the type
17:59:37 <mmorrow> *typo
17:59:43 <mmorrow> (that was an accident)
17:59:58 <ksf> If in doubt, snarf some source.
18:00:01 <mmorrow> SamB: i don't care about inlines really
18:00:23 <gwern> ksf: the ghci source is really hard to follow for api tips; I've tried in the past
18:00:34 <gwern> Ralith: maybe you'd be better off using a wrapper like hin
18:00:35 <gwern> *hint
18:00:41 <SamB> gwern: no duh
18:00:48 <SamB> does GHCi even use the API ?
18:00:53 <Ralith> gwern: hint?
18:00:55 * SamB thought it used internals
18:00:56 <gwern> they really are much easier to understand than the raw ghc api, with its many gotchas
18:01:01 <gwern> Ralith: look on hackage
18:01:06 <gwern> SamB: pretty sure it uses the api
18:01:09 <Ralith> SamB: it seems to use the GHC API; I'm looking at the code
18:01:26 <SamB> I was pretty sure it was *in* the ghc package
18:01:59 <Ralith> it is
18:02:02 <Ralith> it still uses its API
18:02:05 <Axman6> gwern: do you have an example of gitit running somewhere?
18:02:07 <SamB> I could have just be overgeneralizing from python/libpython
18:02:12 <gwern> Axman6: only locally
18:02:22 <SamB> Ralith: is all of GHC exported by the API ?
18:02:27 <Ralith> SamB: what?
18:02:29 <Axman6> ok, interested in how it looks and acts
18:02:31 <Ralith> gwern: hint looks promising, thanks
18:02:36 <mmorrow> here's my entire C AST (note that i'm ignoring expressions (for now, possibly forever)) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1427#a1427
18:02:42 <Ralith> gwern: know where I can find docs?
18:02:44 <gwern> Axman6: although I run a fully distributed gitit wiki, so you could darcs pull my repo and have your own my-wiki :)
18:02:48 <gwern> Ralith: hackage
18:02:56 <Axman6> heh :)
18:03:02 <Ralith> gwern: not seeing them
18:03:03 <mmorrow> also, i left out _Complex and _Imaginary
18:03:11 <Ralith> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint
18:03:15 <Ralith> you see any docs there?
18:03:17 <SamB> Ralith: well, /usr/bin/python* just call the real main functions in libpython*.so
18:03:23 * gwern is serious, btw. install gitit, darcs pull my repo, and do gitit -f static/Config.hs and you have the exact same thing as I have
18:03:31 <Ralith> well, there's an example.
18:03:58 <gwern> hm, wonder if daneil forgot to upload ghc-mtl
18:04:49 <Ralith> gwern: seems to work; example runs.
18:05:19 <gwern> Ralith: well then build haddocks locally
18:05:48 <Ralith> haddocks?
18:05:49 <Ralith> what?
18:05:51 <Ralith> oh
18:05:51 <Ralith> yes
18:06:30 <ferret_0567> I'm curious: do any Haskell programmers even use KDE?
18:06:40 * mmorrow uses gnome
18:06:45 * SamB wants support for hackage building haddocks for executables too
18:06:52 <Axman6> does GTK work with KDE?
18:06:54 <SamB> ferret_0567: most likely!
18:06:58 <ksf> i've got a kde running alongside with xmodad.
18:06:59 <SamB> Axman6: of course
18:07:08 <ferret_0567> Axman6: yes
18:07:11 <luqui> xmonad+gnome here
18:07:13 <SamB> it works with win32, I think it works with KDE ;-P
18:07:17 <ksf> konsole is a hell of an xterm.
18:07:21 * Axman6 says away from the kde/gnome nonsense
18:07:26 <pumpkin> mac os ftw
18:07:34 * Axman6 tries to stay away from anything using X11 infact
18:07:50 <SamB> KDE just uses Qt for it's own stuff, you can run whatever mixture of desktop systems you want on Linux ...
18:07:58 <jeffz`> Axman6: is that because you're on a system that treats X11 as a second class citizen?
18:08:02 <luqui> Axman6, GNOME 4ever, KDE suxor!!! bring your flamethrower
18:08:04 * mmorrow occasionally turns on xmonad when he needs a break from the awesomeness of compiz and translucent every/anything
18:08:04 <SamB> well, as long as it's not really unfriendly to other systems ...
18:08:06 <ferret_0567> there is a new X server supporting Compositing only coming up
18:08:20 <Axman6> jeffz`: no, i try to avoid using it on all systems
18:08:26 <SamB> ferret_0567: what do you mean, only ?
18:08:27 <pumpkin> mmorrow: do you use jiggly windows?
18:08:28 <sjanssen> ferret_0567: oh?
18:08:34 * ksf uses xmonad+compmgr
18:08:35 <mmorrow> pumpkin: ahahahhaaa, oh yesh!
18:08:40 <pumpkin> jiggly windows ftw
18:08:42 <SamB> ksf: what's the point ?
18:08:46 <mmorrow> it's so freaky
18:08:52 <ksf> focus indication by translucency.
18:08:52 <mmorrow> i love it
18:09:01 <pumpkin> lol
18:09:22 <SamB> ksf: oh
18:09:26 <pumpkin> mmorrow: would what I said about an "include QQ" work btw?
18:09:29 <SamB> what do you see through the window ?
18:09:34 <rwbarton> ksf: I need to set that up, is it easy?
18:09:40 <pumpkin> mmorrow: one issue I can think of is name mapping
18:09:42 <ksf> depends.
18:09:47 <mmorrow> pumpkin: for sure that could work
18:09:57 <pumpkin> it would be pretty sweet
18:09:58 <ksf> there's already a function to do it, but it sucks for xinerama.
18:10:04 <mmorrow> pumpkin: yeah, you'd have to make some decisions about what it would mean (since it could mean anything)
18:10:10 <rwbarton> I only have one screen
18:10:24 <ferret_0567> SamB, sjanssen: http://www.phoronix.com/scan.php?page=article&item=xorg_wayland&num=1
18:10:36 <pumpkin> this computer has only one screen, but it's bigger than any of my other ones
18:10:37 <Axman6> i really wish i had a small thinkpad with Arch and Xmonad
18:11:06 * mmorrow has a small thinkpad
18:11:07 <sjanssen> ferret_0567: oh, that article is entirely false
18:11:09 <Ralith> ksf: got more info? I could use that.
18:11:22 <ferret_0567> sjanssen: huh? why?
18:11:36 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1428#a1428
18:11:42 * hiredman has a wind
18:11:53 <ksf> ...I didn't recompile xmonad for some time, though.
18:12:05 <mmorrow> (just fyi, the 8080 isn't necessary for hpaste2 on moonpatio.com)
18:12:07 <ksf> (switched to ghc 6.10 and didn't upgrade yet)
18:12:22 <mmorrow> i know some people have problems with 8080..
18:12:29 <sjanssen> ferret_0567: http://www.reddit.com/r/linux/comments/7b4dd/wayland_a_new_x_server_for_linux/c0662l6
18:12:36 <ksf> moon+down+enter->grab mouse, do rest
18:13:03 <sjanssen> ferret_0567: the main problem is that Wayland is in no way an X server
18:13:21 <ferret_0567> sjanssen: so? look at nailer's comment
18:14:24 <sjanssen> ferret_0567: I also haven't seen any indication that Wayland is being used to implement an X server
18:14:52 <cjb> sjanssen: you can run X on top of it, though
18:14:54 <ferret_0567> sjanssen: I am pretty sure somebody will implement an X server on top of it
18:15:08 <cjb> yes, there was a demo of just that at the last FUDCon
18:15:23 <sjanssen> cjb: is there an actual source for this?
18:15:26 <rwbarton> ksf: whoa awesome :)
18:15:32 <ksf> the important thing to notice is "borderWidth=0".
18:15:33 <ferret_0567> cjb: was the X server a separate program?
18:15:40 <ksf> everything else is a waste of screen estate.
18:16:03 <sjanssen> I'm just reacting to the shoddy Phoronix article from months ago.  If there is better information on Wayland, I'm definitely interested
18:16:18 <ddarius> ksf: Indeed.
18:16:46 <gwern> I've always wondered why anyone would attend something named 'FUDCon'
18:16:56 <cjb> sjanssen: http://alt.fedoraproject.org/pub/alt/videos/2009/FUDConF11/fudcon-f11-rm345-session4.ogg
18:17:06 <cjb> sjanssen: the author gives a long talk and demo in this session
18:17:10 <cjb> gwern: well, it's a joke
18:17:17 <gwern> cjb: it is?
18:17:31 <cjb> yes
18:17:42 <cjb> self-referential irony.  it's all the rage these days.
18:17:42 <gwern> 'k
18:17:46 <ferret_0567> crap, I have no way to play it, unless I install mplayer on my lapto
18:18:15 <idnar> you say that as though it were a bad thing
18:20:53 <Pseudonym> So, has Haskell saved anyone's life?
18:21:12 <SubStack> otherwise I was going to learn lisp, so maybe
18:21:32 <Pseudonym> I mean literally.
18:21:39 <gwern> well, after a few months of java, I had given up on life...
18:21:40 <inimino> are you writing code that runs in medical devices?
18:21:55 <SubStack> I really hope that no code runs on medical devices
18:22:04 <Pseudonym> No, but I am using it to help prepare a systematic review.
18:22:25 <Pseudonym> Text mine medical studies to find out what's relevant to the topic of the review.
18:22:45 <Pseudonym> (The review is on burns, and is being fast-tracked because of the bushfires in Victoria.)
18:22:58 <SubStack> neat
18:23:08 <Pseudonym> So it's a bit of a tenuous link, but I was curious how close Haskell has come to saving a life.
18:23:11 <idnar> fascinating
18:23:18 <inimino> yeah
18:23:42 <SubStack> Pseudonym: you could always be the first
18:23:47 <Pseudonym> Not yet. :-)
18:23:51 <Pseudonym> Like I said, tenuous link.
18:23:59 <Pseudonym> It was just a random thought.
18:24:13 <SubStack> better than many of the alternatives anyways
18:24:26 <inimino> well, if it helps you save lives...
18:24:33 <Pseudonym> Of course, Haskell has been used as a DSL compiler for safety-critical systems.
18:25:03 <SubStack> haskell inspires a sort of degree of competance thanks to its userbase as well
18:25:37 <pilkarn> can you do better than binary search?
18:25:54 <mauke> trinary search!
18:26:03 <Pseudonym> pilkarn: For what?
18:26:05 <SubStack> pilkarn: depends
18:26:18 <gwern> pilkarn: depends on how much prior informaton you have on the search items and a lot of stuff actually
18:26:37 <Pseudonym> There's a deep sense in which binary search is optimal under the circumstances.
18:26:44 <pilkarn> sorted Integer-array is all you know
18:26:45 <ddarius> @google cache oblivious search
18:26:45 * SubStack hashes mauke with a rusty monad
18:26:46 <lambdabot> http://en.wikipedia.org/wiki/Cache-oblivious_algorithm
18:26:48 <Pseudonym> The key part being "under the circumstances".
18:26:50 <mauke> linear search > binary search for n < 4
18:26:58 <inimino> "sorted"?
18:27:08 <gwern> mauke: you and your silly constants
18:27:14 <Pseudonym> The circumstances being binary comparisons.
18:27:15 <pilkarn> vector #(12 34 56 1202)
18:27:40 <Pseudonym> To find a place in an array of size N, you need to know a N-bit number.
18:27:47 * inimino misread the question as one about sorting...
18:27:53 <Pseudonym> Sorry, log N bit.
18:28:02 <Pseudonym> Each binary comparison gives you one bit of information.
18:28:13 <Pseudonym> Therefore, you need at least log N comparisons to discover the number.
18:28:44 <Pseudonym> You can't beat Shannon, Kolmogorov or Chaitin.
18:28:46 <pumpkin> pilkarn: if you have a bounded range and enough memory for the entire range, you can do it in time linear on the range, but that's not very interesting
18:29:01 <pumpkin> pilkarn: but in general if you don't know anything about your data, n log n is the best you can do
18:29:04 <Pseudonym> If you're going to do it in less time, you need to discover more than one bit of information per step.
18:29:15 <pumpkin> or have extra bits to start with
18:29:25 <Pseudonym> Sorting is the same.  You need to discover a permutation, which is a number between 1 and N!.
18:29:45 <Pseudonym> So if all you have is binary comparisons, you need to discover log N! =~ N log N bits of information.
18:29:47 <mauke> assume an even distribution of elements and split your range based on that guess instead of in the middle
18:36:11 <pumpkin> http://code.haskell.org/~dons/code/uvector/tests/notes the core here is beautiful
18:37:17 <pumpkin> @src Int
18:37:18 <lambdabot> data Int = I# Int#
18:38:39 <eltrkbrd> is haskell more suitable to learn as a first language than say python for an absolute beginner?
18:38:57 <pumpkin> it's no less suitable
18:38:57 <eltrkbrd> I'm not looking to learn python as a full time career but rather as a first language for being more empowered to develop and utilize applications including web apps and just better understanding language in general\
18:38:59 <sjanssen> cjb: hmm, this new gnome-panel replacement seems interesting
18:39:09 <eltrkbrd> *haskell
18:39:40 <Nafai> sjanssen: What program is this?
18:39:42 <pilkarn> eltrkbrd: I think they are both awesome languages to learn
18:39:59 <eltrkbrd> also, I'm not able to do calculus at the moment nor do I have a specialized knowledge in computer science...
18:40:04 <eltrkbrd> thanks pilkarn
18:40:30 <eltrkbrd> are there any great web application frameworks and beginners guides for Haskell?
18:40:42 <dolio> In general, you don't use calculus in computer science much.
18:40:43 <christian_> Haskell better than Ocaml?
18:40:59 <sjanssen> Nafai: a proto type mentioned in  http://alt.fedoraproject.org/pub/alt/videos/2009/FUDConF11/fudcon-f11-rm345-session4.ogg
18:41:00 <mauke> christian_: no, use Perl instead
18:41:01 <pumpkin> christian_: define better and we'll tell you
18:41:02 <dons> ?quote instance
18:41:02 <lambdabot> ghc says: Malformed context in instance header
18:41:09 <dons> ?quote instance Ord
18:41:09 <lambdabot> No quotes for this person. My mind is going. I can feel it.
18:41:31 <jeffz`> christian_, we wouldn't be using it if we didn't think so.
18:41:32 <Nafai> sjanssen: *looks*
18:41:33 <dons> christian_: it usually doesn't make sense to group languages by 'better'
18:41:35 <christian_> I searching for a computer language which stands for hundred years
18:41:42 <dons> uh oh.
18:41:56 <dons> a hard task!
18:42:01 <christian_> i know
18:42:02 <mauke> christian_: try Arc
18:42:09 <christian_> dont know
18:42:09 <nasturtiums> mauke: lol
18:42:17 <drhodes> is there a way from ghci to list all available modules?
18:42:25 <christian_> is it in the same genre as brainfuck or so?
18:42:32 <rwbarton> christian_: that language may well be COBOL
18:42:34 <mauke> drhodes: import <tab>
18:42:35 <dons> mm
18:42:35 <pumpkin> christian_: lol no
18:42:37 <inimino> depends who you ask
18:42:40 <drhodes> thanks mauke
18:42:40 <christian_> ah
18:42:51 <coco`> What is the shortest way to write a function of type [a] -> Maybe a that checks whether all the elements in a list are the same?
18:43:07 <christian_> can you do Oo Programming in haskell?
18:43:18 <Pseudonym> It depends what you mean by "OO".
18:43:18 <christian_> ocaml can
18:43:32 <christian_> classes inheritance etc
18:43:34 <pumpkin> christian_: OO is one way of doing things
18:43:38 <coco`> christian_: noone uses that feature in ocamcl
18:43:44 <sjanssen> @protontorpedo
18:43:45 <lambdabot> is haskell nicer than clisp?
18:43:45 <christian_> :(
18:44:00 <pumpkin> christian_: there are different ways to solve the same problems
18:44:04 <mauke> :t and . ap (zipWith (==)) tail
18:44:06 <lambdabot> forall a. (Eq a) => [a] -> Bool
18:44:12 <Pseudonym> In the Alan Kay sense, Haskell does OO very well.
18:44:14 <pumpkin> and OO is just one of the ways
18:44:15 <Pseudonym> Much like Erlang.
18:44:16 <Ralith> Is there a way to extract a value from an Either other than patternmatching?
18:44:21 <mauke> :t either
18:44:23 <pumpkin> Ralith: either
18:44:23 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:44:24 <Draconx|Laptop> coco`, you will have a very hard writing a function which both does that and has that has that type.
18:44:27 <Pseudonym> But by "OO", a lot of people mean C++/Java.
18:44:28 <Ralith> ah.
18:44:31 <Ralith> thanks
18:44:32 <christian_> yeah...but i like data and methods bounded
18:44:35 <Draconx|Laptop> coco`, s/very hard/very hard time/
18:44:40 <ksf> :t maybe
18:44:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:44:43 <christian_> to have a sort of overview
18:44:47 <Ralith> @src either
18:44:47 <lambdabot> either f _ (Left x)     =  f x
18:44:47 <lambdabot> either _ g (Right y)    =  g y
18:44:49 <christian_> in my programs
18:45:01 <rwbarton> christian_: that's fine, they go together in modules
18:45:06 <christian_> hm
18:45:06 <ksf> @hoogle Bool -> a -> Maybe a
18:45:07 <lambdabot> Control.Exception assert :: Bool -> a -> a
18:45:07 <lambdabot> Prelude asTypeOf :: a -> a -> a
18:45:07 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
18:45:09 <Pseudonym> christian_: In Java and C++, a lot of people say "object" but they mean "instantiable module".
18:45:10 <mauke> christian_: that's nice, until you need to add another operation
18:45:16 <Pseudonym> In that sense, Haskell does what you want.
18:45:21 <ksf> @hoogle a -> Bool -> Maybe a
18:45:22 <lambdabot> Control.Exception assert :: Bool -> a -> a
18:45:22 <lambdabot> Prelude const :: a -> b -> a
18:45:22 <lambdabot> Data.Function const :: a -> b -> a
18:45:30 <ksf> @hoogle a -> Bool -> (Maybe a)
18:45:31 <lambdabot> Control.Exception assert :: Bool -> a -> a
18:45:31 <lambdabot> Prelude const :: a -> b -> a
18:45:31 <lambdabot> Data.Function const :: a -> b -> a
18:45:40 <ksf> what's happening to the maybe?
18:45:50 <christian_> to whom is lambdabot telling
18:45:53 <Pseudonym> Haskell's module system isn't nearly as good as O'Caml's, though.
18:46:00 <christian_> aha
18:46:04 <christian_> i knew it..
18:46:12 <pumpkin> christian_: you knew what?
18:46:20 <christian_> but ocaml also doesnt have first class modules
18:46:21 <lambdabot> I speak, and those who need to hear do so.
18:46:23 <christian_> so i read
18:46:28 * wli really really super-duper wishes Haskell had a module system such as ocaml's.
18:46:31 <pumpkin> lol
18:46:39 <pumpkin> who's manning the bot today?
18:46:39 * Pseudonym agrees with wli
18:46:41 <mmorrow> _SML_'s module system++
18:46:42 <wli> Or better, if available.
18:46:58 <Pseudonym> Haskell's module system is really the biggest missing feature.
18:47:03 <mmorrow> totally
18:47:06 <christian_> isnt sml not just a subset of ocaml?
18:47:15 <dolio> Heh.
18:47:22 <christian_> i thought so
18:47:41 <Nafai> What's so nice about OCaml/SML's module system?
18:47:51 <mmorrow> christian_: consult the googlemachine
18:47:52 <christian_> i knew that ocaml has at least SOME advantage over haskell
18:48:00 <coco`> mauke: your function has a funny type
18:48:12 <coco`>  (Eq a, Monad ((->) [a])) => [a] -> Bool
18:48:23 <redditbot> Vote up if you appreciate dons for keeping Haskell Reddit filled with interesting posts!
18:48:30 <dons> hmm
18:48:30 <pumpkin> christian_: most languages have some advantages over the other languages, or there wouldn't be much point in creating a new one (disregarding time)
18:48:32 <ksf> @pl (\l -> let f p x = if p then Just x else Nothing in f ((and . ap (zipWith (==)) tail)l) (head l))
18:48:33 <lambdabot> flip (ap (flip . flip id . and . ap (zipWith (==)) tail) head) (flip flip Nothing . (. Just) . if')
18:48:35 <dolio> Nafai: You can locally open them, they can be parameterized by types and such, etc.
18:48:41 <rwbarton> dons: hey, did you get my rss2irc patch?
18:48:42 <christian_> thats right
18:48:43 <dons> christian_: the compiler is faster
18:48:43 <coco`> Draconx|Laptop: why is it hard?
18:48:45 <dons> rwbarton: yup
18:48:46 * Axman6 votes up
18:48:51 <ksf> (flip (ap (flip . flip id . and . ap (zipWith (==)) tail) head) (flip flip Nothing . (. Just) . if')) [1,1,1]
18:48:58 <christian_> sml has mlton, which is VERY fast
18:48:59 <dons> Axman6: did you look at the regex-dna shootout entry, btw?
18:49:00 <ksf> >(flip (ap (flip . flip id . and . ap (zipWith (==)) tail) head) (flip flip Nothing . (. Just) . if')) [1,1,1]
18:49:07 * luqui loves those flip flips
18:49:09 <Axman6> dons: what did you think of that AS
18:49:10 <ksf> > (flip (ap (flip . flip id . and . ap (zipWith (==)) tail) head) (flip flip Nothing . (. Just) . if')) [1,1,1]
18:49:12 <lambdabot>   Just 1
18:49:13 <dons> christian_: it's about the same as ghc, to a first approximation
18:49:17 <Axman6> ASTM thing i wrote btw?*
18:49:17 * Nafai reads about parameterized modules
18:49:19 <ksf> > (flip (ap (flip . flip id . and . ap (zipWith (==)) tail) head) (flip flip Nothing . (. Just) . if')) [1,1,2]
18:49:21 <lambdabot>   Nothing
18:49:21 <dons> both are essentially whole program optimizing compilers
18:49:23 <Pseudonym> :t flip flip
18:49:25 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
18:49:27 <christian_> ah
18:49:27 <ksf> coco`, satisfied?
18:49:38 <Axman6> dons: yeah i did, but i'm not all that familliar with the problem, so i'm not really sure what i was looking at
18:49:45 <dons> ah ok.
18:49:46 <Draconx|Laptop> coco`, because a function that has type "[a] -> a" has no information about how to compare elements of the list with each other.
18:49:50 <Pseudonym> ?free flipflip :: b -> (a -> b -> c) -> a -> c
18:49:51 <lambdabot> (forall y. h . k y = p (g y) . f) => h . flipflip x k = flipflip (f x) p . g
18:49:58 <coco`> same xs = case List.nub xs of { [x] -> Just x; _ -> Nothing }
18:49:58 <christian_> do you have a haskellbot here to play with?
18:50:03 <pumpkin> someone should set up a #haskell-shootout-aweomeification channel :P
18:50:04 <ksf> Draconx|Laptop, look at your scrollback, lambdabot just did it.
18:50:06 <coco`> ksf: I was hoping for something shorter
18:50:06 * BMeph agrees with mmorrow
18:50:15 <wli> I'd love to take a stab at language design but my programming abilities have declined too drastically to back it up with anything resembling code. I doubt I could ever write a compiler at all.
18:50:15 <Draconx|Laptop> coco`, er, [a] -> Maybe a.
18:50:18 <rwbarton> coco`: import Data.List :)
18:50:20 <lambdabot> I don't play. I work.
18:50:25 <tehgeekmeister> http://tinyurl.com/cafmf2 <== what does this error mean?
18:50:27 <christian_> cool
18:50:27 <ksf> well, it's shorter if you don't write it in pointless style.
18:50:29 <roconnor> > let (x,y) = ("let (x,y) = (",") in text (x++show x++\",\"++show y++y)") in text (x++show x++","++show y++y)
18:50:31 <lambdabot>   let (x,y) = ("let (x,y) = (",") in text (x++show x++\",\"++show y++y)") in ...
18:50:31 <Draconx|Laptop> :t (flip (ap (flip . flip id . and . ap (zipWith (==)) tail) head) (flip flip Nothing . (. Just) . if'))
18:50:32 <coco`> ok, sorry I meant Eq a => of course
18:50:33 <lambdabot> forall a. (Eq a) => [a] -> Maybe a
18:50:37 <pumpkin> @users
18:50:38 <lambdabot> Maximum users seen in #haskell: 666, currently: 610 (91.6%), active: 34 (5.6%)
18:50:39 <christian_> !weather NY
18:50:50 <tehgeekmeister> in general, what do functional dependency errors mean?  i'd like to learn that so i don't always have to ask in here.  =P
18:50:56 <christian_> hm
18:51:08 <rwbarton> > case nub [1..] of [x] -> Just x; _ -> Nothing
18:51:09 <Pseudonym> christian: For some reason, we find that eliminating lambdas is more useful than knowing the weather.
18:51:10 <lambdabot>   Nothing
18:51:26 <christian_> ok
18:51:29 <christian_> i agree
18:51:38 <mauke> tehgeekmeister: >>= return is redundant
18:52:01 <pumpkin> fmap/liftM ?
18:52:02 <mauke> tehgeekmeister: basically, it's complaining about conflicting return types in different branches of the function
18:52:15 <coco`> so this is the shortest...
18:52:22 <tehgeekmeister> mauke: so just get would return the state at that point?
18:52:28 <mauke> yes
18:52:32 <pumpkin> coco`: can't say it's the shortest until you prove it is :P
18:52:34 <coco`> what's if?
18:52:50 <coco`> how would you do that?
18:53:05 <rwbarton> tehgeekmeister: what's the type of makeFrequencyMap supposed to be?
18:53:09 <coco`> what's "if'" ?
18:53:11 <Axman6> coco`: what's if?
18:53:14 <christian_> well, i think i need objects to create a multiagent_platform in a functional language
18:53:15 <Axman6> og, if'
18:53:27 <rwbarton> tehgeekmeister: in general if you get a tricky type error it's almost always helpful to add more type signatures, especially top-level ones
18:53:29 <Axman6> > let if' p t f = if p then t else f
18:53:31 <lambdabot>   <no location info>: parse error on input `;'
18:53:43 <Axman6> > let if' p t f = if p then t else f in if' (even 2) "Yes" "no"
18:53:45 <lambdabot>   "Yes"
18:53:50 <tehgeekmeister> rwbarton: don't know what the type signature for something in the state monad in general is
18:54:10 <ksf> :t if'
18:54:12 <lambdabot> forall t. Bool -> t -> t -> t
18:54:12 <mauke> tehgeekmeister: replace get >>= return by return ()
18:54:25 <christian_> ok i am looking for an ocaml-channel...bye
18:54:45 <luqui> tehgeekmeister, State TypeOfState ReturnType
18:54:46 <tehgeekmeister> rwbarton: but in this case it should have state of type Data.Map.Map String Int
18:55:13 <luqui> tehgeekmeister, so State (Map String Int) something,   for a particular something
18:55:17 <tehgeekmeister> mauke: in the state monad return sets the value, correct?
18:55:27 <luqui> tehgeekmeister, no
18:55:38 <rwbarton> tehgeekmeister: if you don't want a state monad type, you can just use M.fromListWith
18:55:44 <rwbarton> tehgeekmeister: or a fold
18:55:56 <tehgeekmeister> rwbarton: i think a fold would be more convoluted here.
18:56:06 <rwbarton> tehgeekmeister: well, note your second case doesn't use xs at all
18:56:08 <tehgeekmeister> rwbarton: but maybe i just don't know how to write that particular fold very elegantly
18:56:13 <rwbarton> tehgeekmeister: I assume that's not what you intended :)
18:56:14 <tehgeekmeister> OH
18:56:56 <ksf> somehow, my hackish haskell tends to be more elegant than my carefully-designed haskell.
18:56:57 <tehgeekmeister> it works now.
18:57:19 <tehgeekmeister> *adds type signature anyway
18:57:20 <rwbarton> tehgeekmeister: now you can have ghci tell you the type
18:57:50 <Axman6> ksf: rename them and you'll be sweet ;)
18:58:32 <ksf> uhhh... there are no names, just dots, parens and lambdas.
18:59:49 <luqui> lambdas create names...
18:59:54 <tehgeekmeister> how do i put in an extension in the file again?  FlexibleContexts in this instance.
18:59:55 <Axman6> ksf: s/hackish/elegant/, s/elegant/hackish
19:00:15 <Axman6> {-# LANGUAGE BangPatterns #-}
19:00:21 <ksf> oh, that's a DEEP koan.
19:00:42 <wli> I've honestly never even learned what a bang pattern is.
19:00:43 <Twey> @let (a ?? b) p = if p then a else b
19:00:47 <lambdabot>  Defined.
19:00:56 <ddarius_> wli: Bang patterns have only recently been introduced.
19:01:15 <monochrom> Bang patterns are rather recent.
19:01:15 <wli> That may be why I never noticed them existing.
19:01:28 <Twey> "Yes" ?? "No" $ even 2
19:01:30 <tehgeekmeister> would these type errors not confuse me so much anymore if i read tapl?
19:01:31 <Twey> > "Yes" ?? "No" $ even 2
19:01:33 <christian_> is there any program written in haskell to show its strength?
19:01:33 <lambdabot>   "Yes"
19:01:36 <tehgeekmeister> i'm debating spending the money on it.
19:01:50 <Nafai> bang patterns are for strictness annotations, right?
19:01:50 <pumpkin> tehgeekmeister: a library is the other option
19:02:08 <sjanssen> Nafai: right
19:02:11 <Axman6> Nafai: yep
19:02:19 <Twey> Better than if'
19:02:19 <ksf> christian_, xmonad, darcs, ghc, thousands of libs, etc...
19:02:39 <christian_> is xmonad a windowmanager?
19:02:43 <ksf> it is.
19:02:51 <tehgeekmeister> pumpkin: not in any systems i have access to, apparently
19:03:00 <christian_> ok i will try...hope it is in the opsnsuse repository
19:03:05 <ksf> yi.
19:03:12 <pumpkin> tehgeekmeister: I mean a physical library to check out the book?
19:03:28 <tehgeekmeister> pumpkin: yes, none of the local library systems that i have access to have it.
19:03:34 <pumpkin> oh I see :)
19:03:41 <tehgeekmeister> pumpkin: the university ones do, but they won't let non-students check out at all.
19:03:48 <pumpkin> ah, that sucks
19:03:55 <ferret_0567> how does this look for a Haskell inspired PS1?: (chroot:[/]) :: # ->
19:04:00 <ray> filthy knowledge hoarders
19:04:11 <ray> twey: what a great operator
19:04:26 <wli> I had an inkling bang patterns might have something to do with strictness.
19:04:27 <Twey> ray: Thank chrisdone
19:04:32 <tehgeekmeister> yeah, university of washington has a really great library, but there's no way for me to check out from it as far as i've ever been able to find out.  =/
19:04:47 <ddarius> tehgeekmeister: Just steal then.
19:04:48 <Twey> ray: http://chrisdone.com/code/haskell/higherorder/Data/List/
19:05:17 <tehgeekmeister> ddarius: =P  i stopped doing that a while ago.  but i bet the book hasn't been checked out in ages...
19:05:19 <pumpkin> tehgeekmeister: my library lets community members get library cards to check out books... maybe you can get membership somehow?
19:05:39 <tehgeekmeister> pumpkin: they didn't have that a while ago, but i haven't checked;; worth looking into again.
19:05:42 <ddarius> tehgeekmeister: You can return it.
19:05:50 <tehgeekmeister> ddarius: oh!
19:05:52 <dolio> mmorrow: Is there a difference between SML and OCaml's module system?
19:05:56 <ksf> christian_, http://www.youtube.com/watch?v=EP0UgtZ9EDQ    http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
19:06:10 <christian_> are there any attemps to build an OS in a functional language?
19:06:13 <Elly> yes
19:06:14 <tehgeekmeister> of all places it's in the engineering library.
19:06:15 <Elly> House
19:06:19 <ddarius> tehgeekmeister: You can probably sweet talk a librarian into getting a card.
19:06:22 <monochrom> Bang pattern is the opposite of ~ pattern.  ãcase y of ~(x:xs) -> ...ã this postpones evaluation.  ãlet !(x:xs)=...ã this makes evaluation early.
19:06:33 <christian_> Is house an os?
19:06:38 <monochrom> (What is the opposite of "postpone"?)
19:06:44 <pumpkin> monochrom: prepone!
19:06:48 <ddarius> Also, Kinetic
19:06:48 <pumpkin> antepone?
19:06:48 <Riastradh> (`Expedite'?)
19:06:56 <christian_> thanx ksf
19:06:59 <Nafai> I had to use them the other day, per sjanssen's suggestion.  Though that seemed to be a bit against the grain to Haskell style though
19:07:10 <ray> no, expedite is a synonym for postpone
19:07:16 <ray> at least if you believe UPS
19:07:24 <ddarius> Back in the day there was KAOS, but that was in some predecessor to Haskell and I'm not sure what all it was trying to cover.
19:07:45 <christian_> ah
19:07:57 <monochrom> OMG "prepone" and "antepone" exist!
19:08:07 <monochrom> hahaha ray
19:08:09 <ddarius> @wn prepone
19:08:10 <lambdabot> No match for "prepone".
19:08:14 <Riastradh> ray, well, don't go all lexicographically postal on me, now!
19:08:14 <ddarius> @wn antepone
19:08:15 <lambdabot> No match for "antepone".
19:09:13 <Axman6> hmm, i can't seem to figure out how to use catch :(
19:09:25 <ddarius> Nafai: Where and when to introduce strictness (and implicitly laziness) is, in my opinion, one of the more significant contributions of Haskell practice.
19:09:36 <Nafai> But, I didn't know a way around my problem without making this variable strict
19:10:06 <Nafai> ddarius: I used it to get around a laziness issue, but perhaps there was a better way to write the code so it wasn't an issue
19:10:27 <Axman6> i'm using E.catch (return (f x) >> putMVar mvar True >> handler chan (f x)) (\_ -> putMVar mvar False >> handler chan x), but i'm getting the error "Ambiguous type variable `e' in the constraint: ... `E.Exception e' .. arising from a use of `E.catch' at ASTM.hs:(31,10)-(32,61)"
19:10:46 <Axman6> where (f x) might throw an exception
19:10:59 <rwbarton> return (f x) >> ...?
19:11:04 <Axman6> but, i don't know what exception
19:11:09 <luqui> Axman6, \(_::SomeException) -> ...
19:11:12 <Axman6> rwbarton: yeah, there's probably better ways to do that
19:11:15 <rwbarton> that doesn't do anything at all
19:11:41 <luqui> Axman6, (return (f x) >>) = id
19:11:46 <ddarius> Nafai: Unless you are using something like unsafePerformIO, using strictness annotations in the proper places is exactly what you're supposed to do.
19:11:50 <Axman6> rwbarton: well, i'm just trying to get f x to execute
19:11:56 <Axman6> hmm, seq would be better
19:11:57 <luqui> Axioplase, maybe you mean return $! f x
19:11:58 <rwbarton> Axman6: But it won't
19:12:03 <Nafai> ddarius: My issue was that I had decodeFile and encodeFile from Data.Binary in the same function for the same file and I had to make sure decodeFile was done first
19:12:03 <luqui> er, Axman6 ^
19:12:20 <monochrom> return (f x) >> blah  will not get f x executed. One of the monad laws require that.
19:12:25 <ddarius> Nafai: Ah, so it was a lazy IO problem.
19:12:27 <rwbarton> Axman6: I think it's best to use evaluate
19:12:30 <rwbarton> :t evaluate
19:12:32 <lambdabot> Not in scope: `evaluate'
19:12:36 <rwbarton> @hoogle evaluate
19:12:36 <lambdabot> Control.Exception evaluate :: a -> IO a
19:12:36 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
19:12:37 <Nafai> ddarius: Yeah
19:12:46 <Axman6> rwbarton: ah, yes, thanks
19:12:47 <monochrom> Control.Exception.evaluate
19:12:59 <monochrom> evaluate (f x) >> blah  will make things happen.
19:13:12 <ddarius> Nafai: That would fall under "using something like unsafePerformIO" and yes, lazy IO is, in my opinion, "against the grain of Haskell"
19:13:17 <mmorrow> dolio: i think ocaml has some oo stuff or something, but i'm actually not so sure they're really different (assuming SML with all extensions)
19:13:24 <pumpkin> oocaml
19:13:31 <pumpkin> oOoOoOcaml
19:13:37 <Axman6> so, is it not possible to catch all exceptions?
19:13:40 <rwbarton> More sensible to write something like do y <- evaluate (f x); putMVar mvar True; handler chan y
19:13:46 <dolio> mmorrow: The wikipedia article on OCaml doesn't even talk about the module system.
19:13:47 <mmorrow> dolio: augustss pointed me to this guy who's greatly simplified the SML module system
19:13:55 <Nafai> ddarius: This is the function: http://gist.github.com/64935
19:13:59 <mmorrow> he merges structures and signatures
19:14:03 <dolio> So I assume they're about the same.
19:14:09 <Nafai> ddarius: So what would I do instead?
19:14:18 <rwbarton> Axman6: yes, add a type signature SomeException to the argument of the exception handler
19:14:24 <mmorrow> this is the module system i've been refering to ever since i read about it ;)
19:14:26 <rwbarton> Axman6: sorry I drowned out luqui's response :)
19:14:28 * mmorrow finds the link
19:14:30 <ddarius> Nafai: Not use lazy IO (which you probably don't have too much of a choice about)
19:14:32 <dolio> mmorrow: Huh, really?
19:14:37 <mmorrow> oh yeah
19:14:38 * ksf would be willing to drop unsafePerformIO iff there's a cool way to do corecursion on handles, instead.
19:14:45 <Nafai> ddarius: Yeah, since it's the library doing the work
19:15:27 <ksf> I don't want to pollute all that pure code with IO just to have the program run in constant space.
19:15:37 <dolio> mmorrow: That's kind of odd. In my head I kind of think of them as dependent records, where the signature would be a type, and the structure would be a value of that type.
19:15:41 <mmorrow> dolio: description and links the paper(s) are on this page http://www.mpi-sws.org/~rossberg/mixml/
19:15:45 <monochrom> Oleg has cool I/O at http://okmij.org/ftp/Streams.html
19:15:56 <nasturtiums> anyone written any type of game in Haskell yet?
19:16:05 <mmorrow> dolio: they treat functors like lambdas
19:16:13 <mmorrow> so linking is just application!
19:16:16 <ksf> @hackage frag
19:16:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/frag
19:16:23 <ksf> what about an ego shooter?
19:16:28 <dolio> Yeah, that would be what they'd be in the dependent record view.
19:16:36 <rwbarton> nasturtiums: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
19:17:19 <dolio> Of course, dependent records wouldn't allow for circularly defined things.
19:17:31 <dolio> At least, not easily.
19:17:34 <luqui> dolio, why not?
19:17:44 <mmorrow> dolio: ooh, yeah MixML does mutually recursively defined modules
19:18:02 <Axman6> so, can i use catch to handle all possible exceptions a function might give?
19:18:10 <nasturtiums> ksf: thx
19:18:17 <nasturtiums> rwbarton: thx
19:18:30 <luqui> Axman6, yes we have told you how.  \(_::SomeException) -> ...
19:18:36 <luqui> on the exception handler
19:18:39 <dolio> luqui: Well, it depends on what you're doing, but in general, if you have 'record { foo, bar, baz, ... }' then bar's type can involve foo, and baz can involve foo and bar, and so on. But bar doesn't get to talk about baz, because it's not in scope yet.
19:19:05 <Axman6> luqui: oh, sorry, i thought SomeException was a specific exception, tanks :)
19:19:07 <Axman6> thanks too
19:19:22 <rwbarton> I was reading a paper comparing ML modules to Haskell type classes and it claimed that ML can infer a structure's (?) signature (?) from its value
19:19:28 <luqui> dolio, oh right, where record is a chain of sigma types?
19:19:47 <dolio> Yeah, exactly.
19:20:07 <rwbarton> and I didn't understand how it could tell what types were supposed to be types determined by the signature rather than constant types
19:21:32 <mmorrow> rwbarton: check out "MixML". it's way better than the current ML module system
19:21:42 <luqui> Axman6, oh, that's a good point.  SomeException is a poorly chosen name for expository purposes :-)
19:21:56 <Axman6> yeah
19:22:03 <Axman6> AllExceptions
19:22:03 <monochrom> SomeMoreException
19:22:06 <Axman6> might be better*
19:22:18 <monochrom> OhHereIsMoreExample
19:22:51 <mmorrow> and i read (don't remember where) that spj's "parameterized modules" idea is equivalent to functors (functor := functor in the regular ML module sys)
19:22:54 <Axman6> CanHasExceptionPls
19:24:11 <dolio> mmorrow: Have you read both of those papers? Is one just a more fleshed out version of the other, or does the second assume you've read the first?
19:24:26 <mmorrow> dolio: i've only looked at the extended version
19:24:45 <mmorrow> i've gotten through about 80% of it so far
19:25:03 <dolio> I guess they look about the same at the beginning, so it must just be more fleshed out.
19:25:16 <mmorrow> that was my guess
19:25:46 <mmorrow> or just has extra info..
19:25:59 <dolio> Yeah, either way.
19:26:34 <drhodes> woe is me. Codec.Wav.importFile "./myfile.wav" emits an error which I'm having hard time with.  Could someone please tell me if I'm doing something wrong?  http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=1430#a1430
19:26:41 <mmorrow> looks like dolio accidently the plug
19:26:59 <mmorrow> heh, i thought you just accidently the plug
19:27:08 * mmorrow hates when he does that
19:27:31 <dolio> My IRC connection drops relatively often.
19:27:34 <drhodes> ahem.. screen, <cough cough>
19:27:46 <dolio> Same with my instant messenger connections. I'm not really sure why.
19:27:56 <SamB> drhodes: where shall he run it?
19:28:04 <sjanssen> drhodes: :module +Data.Array.Diff
19:28:38 <sjanssen> drhodes: hmm, actually I don't think that's the problem
19:28:53 <rwbarton> drhodes: I think you need to specify the result type you want
19:28:58 <sjanssen> drhodes: you need to give a more specific type to the result of importFile
19:29:09 <drhodes> Oh. :: something
19:29:30 <coco`> my program says "divide by zero" and I have no idea where to start searching... can I get a stack trace?
19:30:04 <rwbarton> > (intersect `on` words) "drhodes: I think you need to specify the result type you want" "drhodes: you need to give a more specific type to the result of importFile"
19:30:05 <sjanssen> coco`: yes, you can use the ghci debugger
19:30:06 <lambdabot>   ["drhodes:","you","need","to","the","result","type","you"]
19:30:07 <jeffz`> coco`: in ghci, :set -fbreak-on-exception
19:30:16 <jeffz`> coco`: :trace foo
19:30:54 <coco`> thanks, I'll try
19:30:54 <alatter> unwords $ (intersect `on` words) "drhodes: I think you need to specify the result type you want" "drhodes: you need to give a more specific type to the result of importFile"
19:31:04 <alatter> > unwords $ (intersect `on` words) "drhodes: I think you need to specify the result type you want" "drhodes: you need to give a more specific type to the result of importFile"
19:31:07 <lambdabot>   "drhodes: you need to the result type you"
19:31:13 <alatter> hee hee hee
19:31:56 <drhodes> they set me up the answer thanks them I does, sjanssen, rwbarton.
19:33:12 <mmorrow> rwbarton: heh, intersect `on` words i'm stealing for sure
19:33:45 <tehgeekmeister> can main be in a state monad or something like that?  or StateT
19:34:00 <SamB> tehgeekmeister: no
19:34:05 <tehgeekmeister> okay
19:34:07 <luqui> tehgeekmeister, main = runStateT main' initialState
19:34:13 <tehgeekmeister> okay, that works
19:34:21 <mmorrow> main = runStateT main' _ ;   main' :: StateT s IO a = ...
19:34:23 <luqui> tehgeekmeister, er, I guess evalStateT probably
19:34:30 <mmorrow> luqui beat me
19:34:55 <tehgeekmeister> i just keep on wanting to simplify some of these gargantuan one liners i'm making
19:34:58 <SamB> what difference does it make ?
19:35:02 <mmorrow> i think main can be  IO <anything>
19:35:19 <tehgeekmeister> and storing a few variables could be useful
19:36:14 <harsha_v_> speaking of module systems, i've been using plt scheme's unit system which has first class modules and it's really nice, especially for something like frp
19:38:45 <luqui> tehgeekmeister, name your abstractions then!
19:39:23 <tehgeekmeister> luqui: the problem i'm running into is that everything depends on names bound by actions in main
19:39:39 <tehgeekmeister> luqui: or at least the ones i'm running into a problem with.  the other ones are all already their own functions.
19:40:11 <SamB> tehgeekmeister: create an environment record and use Reader/ReaderT ?
19:40:55 <JoshTriplett> OK.  I've read http://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/ .  I really *don't* want to use undecidable instances anyway.  But as far as I can tell I can't write a MonadReader instance for my monad transformer without undecidable instances.
19:40:58 <tehgeekmeister> SamB: was thinking StateT so I could update the environment, but yeah, that's basically my idea.  not sure it'd end up saving any space/effort, however
19:41:02 <SamB> (it works better than using repetetive gigantic parameter lists everywhere)
19:41:23 <SamB> tehgeekmeister: well, it depends on how/if you have any need to extend them
19:41:42 <tehgeekmeister> i just keep finding myself wanting to use name <- someExpression to bind an expression to a name in main, but that doesn't work if someExpression isn't an io action
19:41:50 <tehgeekmeister> oh!
19:41:56 <SamB> stick in a return ;-P
19:41:57 <tehgeekmeister> let something = somethingelse
19:42:02 <tehgeekmeister> that's simple
19:42:03 <SamB> or that
19:42:12 <tehgeekmeister> don't know why i didn't think of that.
19:42:12 <monochrom> "do let's"
19:42:13 <SamB> sometimes I do this
19:42:21 <sjanssen> JoshTriplett: what is your monad?
19:42:22 <SamB> x <- return $ foo x
19:43:00 <SamB> though I might have picked it up from John Meacham
19:43:17 <sjanssen> bleh
19:43:17 <JoshTriplett> sjanssen: FinishT.  It provides an "early return" mechanism, where you can call "finish" at any point to return the final value.
19:43:18 <luqui> JoshTriplett, you mean you want instance MonadFoo m => MonadReader m ?
19:43:35 <rwbarton> I think that rant is more against overlapping instances than undecidable instances
19:43:46 <SamB> JoshTriplett: oh, so like a very restricted continuation monad ?
19:43:57 <JoshTriplett> SamB: Right.  Continuations, with slightly less possible insanity. :)
19:44:06 <rwbarton> Sounds like Either
19:44:15 <JoshTriplett> SamB: Though I implemented it directly with Either rather than with a continuation.
19:44:17 <JoshTriplett> rwbarton: Yes. :)
19:44:20 <JoshTriplett> rwbarton: But in monad form.
19:44:53 <luqui> JoshTriplett, and if you do the codensity transformation on that Either, you'll basically get Cont back :-)
19:44:54 <rwbarton> Either e is a monad... *
19:45:02 <rwbarton> (* modulo fail)
19:45:23 <luqui> fail is for chumps
19:45:31 <JoshTriplett> rwbarton: I see no instance of Monad for Either.
19:45:35 <SamB> rwbarton: well, I guess he uses the Left for success
19:45:46 <sjanssen> JoshTriplett: it should be in Control.Monad.Instances
19:45:46 <SamB> @instances-importing Control.Monad.Instances Monad
19:45:47 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:45:56 <luqui> you know, -fno-implicit-prelude allows you to factor fail out into MonadFail, and the constraint is only added when fail can be called.  it's pretty cool, actually.
19:45:59 <JoshTriplett> SamB: Huh.  Useful.
19:46:11 <JoshTriplett> luqui: Oh, nice idea.
19:46:28 <SamB> luqui: MonadZero!
19:46:33 <JoshTriplett> luqui: So you only get MonadFail when you try to pattern-match in a monad, or explicitly call fail. :)
19:46:42 <JoshTriplett> sjanssen: Looking there...
19:46:44 <luqui> JoshTriplett, refutable pattern match even
19:46:52 <JoshTriplett> luqui: Right.
19:47:00 <luqui> irrefutable ones don't generate the constraint.  it's spiffy.
19:47:28 <Nafai> Is there another way of doing serialization other than Data.Binary that isn't Lazy IO?
19:47:47 <porges> luqui: you working on your own prelude?
19:48:07 <luqui> porges, uh... not... exactly.
19:48:17 <mmorrow> hehe, this is a funny comment (from random smlnj code file):
19:48:25 <JoshTriplett> SamB: And to answer your question, yes, Left and Right both mean "success", in a way.
19:48:33 <mmorrow> "...but I'm deathly afraid of merging it into the * InvokeGC code, because the GC handling code had taken me a long time to  * get right.  It is an angry slumbering power which will visit its  * horrible wraths on all who dares to disturb it."
19:48:37 <JoshTriplett> SamB: But Left means early return and Right means keep going.
19:49:33 <JoshTriplett> SamB, sjanssen: OK, I don't see the instance of Monad for Either in Control.Monad.Instances.
19:49:42 <JoshTriplett> Not in the docs, anyway.
19:49:45 * JoshTriplett checks ghci.
19:50:17 <JoshTriplett> Nope.  An instance of Functor, but no instance of Either.
19:50:25 <rwbarton> Control.Monad.Error
19:50:31 <JoshTriplett> Er, instance of Monad, rather.
19:50:36 <JoshTriplett> rwbarton: No, that does the wrong thing.  Tried it. :)
19:50:47 <JoshTriplett> rwbarton: Two problems with Control.Monad.Error.
19:50:50 <rwbarton> No, I mean that's where the Either intsance is
19:51:04 <sjanssen> JoshTriplett: you should probably stick with the newtype instance that you've got now, then
19:51:12 <mmorrow> does anyone know of an example where one would use the (a?) union-find algo?
19:51:27 <ddarius> mmorrow: Calculating dominators
19:51:35 <JoshTriplett> rwbarton: Not exactly.  It provides ErrorT,  but that doesn't work as desired.  First, it doesn't require that its final return type matches its error type.  Second, it requires an instance of Error, which winds up having to use fail.
19:51:38 <ddarius> mmorrow: For control flow graphs in compilers.
19:51:46 <mmorrow> ddarius: woot. that clarifies things much. nice call.
19:51:52 <mmorrow> :)
19:51:52 <rwbarton> JoshTriplett: Agreed on the fail issue
19:52:02 <JoshTriplett> sjanssen: Right.  But that brings me back to the issue of undecidable instances.
19:52:09 <luqui> JoshTriplett, I lied apparently.  It generates MonadFail for pattern matches against single-constructor datatypes, but not for tuples!  i.e. there's a difference between (,) and data Pair a b = Pair a b  (!)
19:52:14 <JoshTriplett> I want to write this: instance MonadReader v m => MonadReader v (FinishT r m) where
19:52:19 <JoshTriplett> sjanssen: ^
19:52:21 <rwbarton> luqui: MonadFail fail
19:53:01 <JoshTriplett> sjanssen: I obviously need at least FlexibleInstances and MultiParamTypeClasses, and I have no problem with that.
19:53:06 <sjanssen> JoshTriplett: that doesn't seem undecidable to me
19:53:15 <pumpkin> what's an elegant way of generating lists of a given length in quickcheck arbitrary instances?
19:53:16 * mmorrow wonders if "intersection-find" is used with postdominators
19:53:30 <JoshTriplett> sjanssen: Agreed. :)
19:53:35 <sjanssen> pumpkin: replicateM n arbitrary -- ?
19:53:36 <JoshTriplett> sjanssen: But ghc claims otherwise.
19:53:38 <rwbarton> JoshTriplett: the requirement about return type matching the error type is just a matter of your runFoo function
19:53:45 <sjanssen> JoshTriplett: which condition does GHC claim it fails?
19:53:46 <pumpkin> sjanssen: nice :P
19:53:48 <JoshTriplett> sjanssen: Illegal instance declaration for `MonadReader v (FinishT r m)'
19:53:50 <rwbarton> @type either id id
19:53:52 <lambdabot> forall b. Either b b -> b
19:53:52 <pumpkin> why didn't I think of that
19:53:55 <JoshTriplett> sjanssen: the Coverage Condition fails for one of the functional dependencies
19:53:59 <luqui> JoshTriplett, something about the coverage condition
19:54:05 <JoshTriplett> luqui: Good call. :)
19:54:08 <luqui> yeah, I've seen that in the mtl docs
19:54:16 <luqui> they just break down and require undecidable instances
19:54:33 <JoshTriplett> luqui: I may end up there, but I'd like to at least know *why*. :)
19:54:39 <luqui> the whole mtl way of doing things is b0rken
19:54:49 <luqui> yeah I don't know what the coverage condition is :-)
19:54:50 <JoshTriplett> luqui: Eh.  It seems fine to me, apart from the undecidable instances. :)
19:54:52 <rwbarton> We need mtl with type families!
19:55:08 <luqui> JoshTriplett, and the quadratic explosion in instances?
19:55:11 <JoshTriplett> rwbarton: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monads-tf
19:55:36 <sjanssen> JoshTriplett: mtl uses undecidable instances in cases like this
19:55:52 <rwbarton> JoshTriplett: sweet
19:55:56 <JoshTriplett> sjanssen: Yes, I realize that.  I guess I just wanted to understand why before I blindly use it too.
19:55:58 <sjanssen> so I don't think there is anything you can do (except switch to type families)
19:56:30 <JoshTriplett> rwbarton: Sweet, except that most other libraries use mtl and not monads-tf. :)
19:56:50 <sjanssen> JoshTriplett: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
19:57:08 <rwbarton> JoshTriplett: well, yeah.  there are so many mtls these days
19:57:23 <JoshTriplett> rwbarton: And of course I'd actually like to get FinishT into mtl. :)
19:57:47 <JoshTriplett> luqui: No comment. :)
19:57:49 <sjanssen> JoshTriplett: essentially, there are a few conditions that guarantee decidability, but they're too strict sometimes
19:57:50 <JoshTriplett> luqui: It works.
19:58:18 <JoshTriplett> sjanssen: *stares at the coverage condition and the fundep on MonadReader for a while*
20:00:12 <sjanssen> class MonadReader r m | m -> r
20:00:31 <sjanssen> m = (FinishT r m)
20:00:34 <sjanssen> r = v
20:00:47 <JoshTriplett> Yeah.
20:01:10 <coco`> can arguments to "main" be set in ghci ?
20:01:14 <sjanssen> v does not appear in (FinishT r m)
20:01:17 <luqui> :set args
20:01:27 <JoshTriplett> sjanssen: Yeah, just got there.
20:01:33 <coco`> luqui: thanks :)
20:01:51 <JoshTriplett> sjanssen: It seems clearly decidable, since the inner m determines the outer v.
20:01:51 <sjanssen> JoshTriplett: please don't ask me why the condition is necessary/sufficient :)
20:02:07 <coco`> can the stdin for "main" be set in ghci?
20:02:28 <sjanssen> coco`: no
20:02:33 <gwern> just the args
20:02:58 <JoshTriplett> sjanssen: So, in this case, GHC requires the coverage condition because the coverage condition provides a sufficient condition for decidability, and the problem comes up because it does not provide a necessary condition?
20:02:59 <rwbarton> The coverage condition is certainly not intended to be necessary
20:03:33 <sjanssen> JoshTriplett: I don't really know the "why" behind the coverage condition, just that GHC deems it necessary
20:03:33 <Nafai> So, GHC compiles things statically, correct?
20:03:53 <Nafai> So I compile a binary on one system, I don't have to have the haskell libraries installed on another, I can just copy the binary over
20:03:57 <Nafai> (given the same architecture)
20:04:02 <JoshTriplett> OK.  So, in other words, this *does* seem decidable, but GHC can't tell from the rules it uses, so I need to tell it that I know it will work, which translates to UndecidableInstances?
20:04:13 <JoshTriplett> Got it.
20:04:14 <gwern> Nafai: more or less, barring things like ghc api
20:04:19 <sjanssen> Nafai: correct, Haskell libraries are linked statically, but C dependencies may be linked dynamically
20:04:23 <gwern> and I think glibc needs tobe the same
20:04:33 <JoshTriplett> sjanssen, rwbarton: Thank you for your assistance.  So I do need UndecidableInstances, but at least now I know why. :)
20:04:45 <Nafai> Thanks
20:04:47 <sjanssen> JoshTriplett: thankfully, type families have a much better story for this
20:04:56 <rwbarton> Nafai: you probably need libgmp and maybe other stuff; you can run ldd on your executable to see what it wants to dynamically link against
20:05:24 <Nafai> rwbarton: Thanks for the pointer.
20:06:26 <gueux> is a star implemented?
20:10:37 <gueux> I need something like that but I would need to deal with imperative structures (too avoid repetitions)
20:10:50 <ozy`> :t ($!)
20:10:52 <lambdabot> forall a b. (a -> b) -> a -> b
20:11:51 <rwbarton> gueux: http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html
20:13:04 <Ralith>   /lastlog hint
20:13:05 <Ralith> er
20:13:12 <Ralith> gwern: you around?
20:14:02 <gwern> Ralith: a little
20:15:40 <gueux> rwbarton: thanks
20:16:03 <m3ga> is there an sprintf in Haskell?
20:16:26 <gwern> we have printf
20:16:27 <m3ga> i am already using Text.Printf.printf
20:16:32 <Draconx|Laptop> m3ga, yes, printf in Text.Printf is suitably overloaded.
20:16:56 <pumpkin> m3ga: it's magic
20:17:04 <pumpkin> it makes a string if you want it to, or an IO otherwise
20:17:21 <m3ga> cool thanks
20:17:26 <TomMD> @type Text.Printf.printf
20:17:28 <lambdabot> forall r. (PrintfType r) => String -> r
20:17:51 <TomMD> @info PrintfType
20:17:51 <lambdabot> PrintfType
20:17:56 <TomMD> damn lambdabot
20:18:00 <Draconx|Laptop> @instances PrintfType
20:18:01 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
20:18:04 <m3ga> nice, now i just wish it did more compile time checking like the Ocaml one :-)
20:18:07 <Draconx|Laptop> @instances-importing Text.Printf PrintfType
20:18:08 <lambdabot> (a -> r), IO a, [c]
20:18:28 <TomMD> m3ga: What compile time checking are you lacking?
20:18:45 <m3ga> printf " %d %d %d " 1 2
20:18:49 <m3ga> will fail at run time
20:19:08 <mmorrow> , $(printf " %d %d %d  ") 1 2
20:19:11 <lunabot>  luna: No instance for (GHC.Show.Show (a[a7ev] -> GHC.Base.String))
20:19:23 <mmorrow> the template-haskell printf doesn't have those problems
20:19:29 <m3ga> :-)
20:19:37 <m3ga> i'm not quite ready for that
20:19:48 <mmorrow> i think there's a TH printf on hackage
20:20:03 <mmorrow> all you have to do is surround it in $(....)
20:20:31 <mmorrow> , ppDoc `fmap` printf " %d %d %d  "
20:20:33 <lunabot>  \x_0 x_1 x_2 -> (" " ++ show x_0) ++ ((" " ++ show x_1) ++ ((" " ++ show ...
20:20:33 <lunabot>                                                                           ...
20:20:33 <lunabot>                                                                           ...
20:20:39 <mmorrow> whoa there
20:20:58 <TomMD> lol
20:23:25 <pumpkin> quickcheck is telling me my test aborted but I can't seem to see why
20:23:59 <pumpkin> oh I see
20:24:37 <physique> does anybody here understand quantum computing
20:24:50 <flippo> No.
20:25:07 <ddarius> There are actually quite a few papers applying Haskell to quantum computing.
20:25:11 <Twey> Nobody understands quantum
20:25:53 <Adamant> but people know enough to TCB.
20:26:27 <ddarius> "People know enough to trusted computing base", what?
20:28:06 <tehgeekmeister> there's not a mean in the prelude?
20:28:16 <tehgeekmeister> that's kind of odd.
20:28:31 <ddarius> There's not a median or mode either or any other k-mean.
20:29:02 <mmorrow> \xs -> let n = length xs; s = foldl' (+) 0 xs in n `par` s `pseq` fromIntegral s / fromIntegral n
20:29:08 <mmorrow> is super fast with -threaded
20:29:15 <mmorrow> (and at least +RTS -N2 -RTS)
20:29:31 <tehgeekmeister> ddarius: yeah, but a lot of people use mean all the time
20:29:33 <luqui> mmorrow, as fast as a manually fused version?
20:29:35 <mmorrow> like, "super fast" as in seconds faster for big lists
20:29:43 <dolio> mmorrow: Did that get sent?
20:29:54 <mmorrow> luqui: how can you fuse it?
20:29:57 <mmorrow> dolio: ?
20:30:00 <tehgeekmeister> i don't need fast bad enough to do all that.
20:30:05 <luqui> its memory performance is much better than without the par, which probably accounts for the speed
20:30:14 <dolio> mmorrow: datatype ('a,'b) sum = INL of 'a | INR of 'b
20:30:18 <mmorrow> luqui: definitely
20:30:38 <mmorrow> dolio: what do you mean by "sent"?
20:30:40 <ddarius> tehgeekmeister: I don't think I've ever actually wanted it.
20:30:53 <dolio> I typed that in just before my IRC client disconnected.
20:31:02 <tehgeekmeister> ddarius: huh.  i find myself using it fairly often.
20:31:03 <mmorrow> oh, /me looks
20:31:06 <luqui> foldl' (\(l,s) x -> (l+1, s+x)) (0,0)   -- modulo explicit strictness
20:31:11 <tehgeekmeister> and i always have to rewrite it.
20:31:15 <ddarius> @hackage hstats
20:31:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hstats
20:31:25 <mmorrow> dolio: i guess not
20:31:37 <mmorrow> dolio: cool, so that's how you do it.
20:31:41 <luqui> also divide at the end
20:32:05 <dolio> Yeah. Not particularly beautiful.
20:32:12 <mmorrow> dolio: that shouldn't be  "datatype ('a * 'b) sum = ... " ?
20:32:23 <mmorrow> (i don't know)
20:32:35 <dolio> Nope.
20:32:47 <Olathe> > let mean xs = let (sum, len) = f 0 0 xs in sum/len where f sum len [] = (sum, len); f sum len (x:xs) = seq sum (seq len (f (sum + x) (len + 1) xs)) in mean [1..10]
20:32:48 <lambdabot>   5.5
20:32:53 <mmorrow> dolio:L heh, no wonder i've been epic'ing
20:33:07 <ddarius> This thing doesn't have a kurtosis function.  What the heck am I supposed to do without a kurtosis function?
20:33:28 <mmorrow> sweet, sml's repl does allows _everything_ at the prompt
20:33:33 <mmorrow> s/does//
20:33:38 <luqui> like a repl ought
20:33:43 <mmorrow> totally
20:33:43 <luqui> well, perhaps not
20:33:49 <ddarius> mmorrow: Yes, it's been doing that for 30+ years.
20:33:56 <luqui> mutually recursive functions is a stretch
20:34:00 * mmorrow shakes his fist at ghci
20:34:13 <luqui> f 42  -- evaluates to _|_, because f hasn't been defined yet, but maybe it will be later?  :-)
20:34:25 <mmorrow> luqui: you can stick them in a let returning a pair of functions
20:34:39 <ddarius> luqui: hbi handled the full Haskell language fine.
20:34:40 <luqui> yeah, but you still can't just paste a haskell program
20:34:40 <dolio> Even ghci lets you define mutually recursive functions.
20:35:00 <Olathe> Hmm...
20:35:06 <ddarius> luqui: Yes you could.
20:35:06 <mmorrow> luqui: hopefully we get this situation fixed soon
20:35:19 <ddarius> (er maybe that wasn't directed to me)
20:35:40 <mmorrow> hbi could do anything
20:35:50 <luqui> I can't imagine a repl in which you can paste any haskell program and it will compile
20:35:50 <mmorrow> (not positive about modules actually, haven't tried..)
20:35:54 <luqui> precisely because of mutual recursion
20:36:13 <mmorrow> luqui: why? then entire module would be a single command
20:36:47 <mmorrow> hbi doesn't do whole modules
20:36:49 <luqui> mmorrow, well... I'll be a pedant... you're allowed to leave off the "module Main where" and it is implied :-)
20:36:52 * mmorrow just checked
20:37:11 <luqui> but you can't have incremental definitions and paste at the same time
20:37:42 <Olathe> > let mean = uncurry (/) . foldb (\(s1, l1) (s2, l2) -> let s = s1 + s2; l = l1 + l2 in seq s (seq l (s, l))) (0, 0) . map (flip (,) 1) in mean [1..10]
20:37:44 <lambdabot>   5.5
20:37:49 <mmorrow> luqui: i don't see why not.
20:37:50 <ddarius> luqui: In hbi you had to terminate an expression to evaluated a certain way.
20:38:00 <ddarius> luqui: Otherwise it was just input.
20:38:42 <tehgeekmeister> oh man it's amazing how long these questions live on sometimes.
20:38:51 <luqui> ddarius, hmm, yeah I guess that woudl work.  well, so much for my creativity :-)
20:40:20 <mmorrow> > let f x = g x
20:40:20 <mmorrow> #     g x = x : f x
20:40:20 <mmorrow> # ;
20:40:20 <mmorrow> f :: a -> [a]
20:40:20 <mmorrow> g :: a -> [a]
20:40:22 <lambdabot>   <no location info>: parse error on input `;'
20:40:34 <mmorrow> (hbi)
20:40:56 <mmorrow> you have to end everything with a ;
20:41:04 <wli> ML-style.
20:41:17 <mmorrow> (on it's own line it seems for multi-line defs)
20:41:33 <porges> > let f = g; g = f
20:41:35 <lambdabot>   <no location info>: parse error on input `;'
20:42:00 <mmorrow> > let f = g; g = f in (f, g)
20:42:16 <lambdabot>   thread killed
20:42:21 <porges> lol
20:42:23 <mmorrow> heh
20:42:36 <porges> the first works in ghci
20:42:46 <mmorrow> oh nice
20:43:06 <mmorrow> hbi:
20:43:08 <mmorrow> > class Foo a where foo :: a -> a;
20:43:34 <lambdabot>   <no location info>: parse error on input `class'
20:43:56 <mmorrow> > data A = A deriving (Show);
20:43:57 <mmorrow> > A;
20:43:57 <mmorrow> A
20:43:59 <lambdabot>   Not in scope: data constructor `A'
20:43:59 <lambdabot>   <no location info>: parse error on input `data'
20:45:29 <wli> I thought hbi could do that.
20:46:24 * wli is adoptively Oregonian.
20:47:06 <TomMD> wli: Oregon?
20:47:23 <TomMD> wli: Portland, Oregon?
20:48:36 <rwbarton> mmorrow: works in my "hacked ghci" also :)
20:49:01 <wli> rwbarton: I tried to figure out how to hack ghci to do that but failed.
20:49:05 <Olathe> > let mean = uncurry (/) . foldb (\(s1, l1) (s2, l2) -> let s = s1 + s2; l = l1 + l2 in seq s (seq l (s, l))) (0, 0) . map (flip (,) 1) in mean . map (1%) $ [1..67500]
20:49:16 <Ralith> Can someone give me some pointers on my efforts to put together a plugin system? I'm having type issues. Code and error at: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1468#a1468
20:49:21 <lambdabot>   398720048961339682192953141905032774721893336655158530747622240370173185193...
20:49:31 <ddarius> Olathe: So is that foldb parallel?
20:49:41 <Olathe> > > let mean xs = let (sum, len) = f 0 0 xs in sum/len where f sum len [] = (sum, len); f sum len (x:xs) = seq sum (seq len (f (sum + x) (len + 1) xs)) in in mean . map (1%) $ [1..20000]
20:49:43 <lambdabot>   <no location info>: parse error on input `>'
20:49:45 <Olathe> > let mean xs = let (sum, len) = f 0 0 xs in sum/len where f sum len [] = (sum, len); f sum len (x:xs) = seq sum (seq len (f (sum + x) (len + 1) xs)) in in mean . map (1%) $ [1..20000]
20:49:47 <lambdabot>   <no location info>: parse error on input `in'
20:50:02 <Olathe> No, it's just partitioned like merge sort does.
20:50:14 <Olathe> > showfold foldb
20:50:17 <lambdabot>   "fold (+) 0 [1..10] = (0 + ((((1 + 2) + (3 + 4)) + ((5 + 6) + (7 + 8))) + (...
20:50:33 <Ralith> loadFunc works, insofar as loading it into ghci and doing foo <- loadFunc "Test" "foo" (as :: IO ()) -- gives a foo of type IO () which behaves as expected, given Test.hs containing function foo in the current dir.
20:51:15 <ddarius> Olathe: Yes, but it should be able te parallelize easily
20:51:20 <wli> rwbarton: I'd love to see that patch merged.
20:51:21 <dsrogers> what does http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1469#a1469 mean?
20:51:46 <dsrogers> why can't I just add FilterMonad Response m to the context of my function?
20:52:00 <ozy`> :t foldb
20:52:03 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
20:52:18 <Olathe> let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs))
20:52:35 <Olathe> I don't know how to parallelize, but there's the code if you want to :)
20:52:56 <Olathe> > let mean xs = let n = length xs; s = foldl' (+) 0 xs in n `par` s `pseq` s/fromIntegral n in mean . map (1%) $ [1..20000]
20:53:12 <lambdabot>   thread killed
20:53:12 <rwbarton> wli: It's not actually a patch at all, but rather a simple wrapper around ghci
20:53:34 <Olathe> I think it would be nice to parallelize it.
20:53:44 <wli> rwbarton: Oh. I was trying to write a patch to ghc/ghci so it would accept it directly at the prompt.
20:53:55 <rwbarton> wli: which writes each line you input to a module, then loads it :)
20:54:11 <Olathe> I wonder if lambdabot can do multithreaded stuff.
20:54:21 <ddarius> Olathe: I think simply sparking the two arguments to (:) would work except that it would create too many sparks at the lowest levels.
20:54:38 <Olathe> Ahh.
20:54:39 <wli> I would not be ery enthusiastic about that sort of wrapper.
20:54:48 <Olathe> Is there a way of detecting how many threads are available ?
20:54:58 * dsrogers is slain by obscure typing errors
20:55:10 <ddarius> There's numCapabalities which gives what the user passed in -N
20:55:18 <Olathe> Ahh.
20:56:27 <Olathe> Hmm, I wonder if there are any thread pool type things in Haskell.
20:56:28 <rwbarton> wli: yeah, it's a horrible hack
20:56:36 <Ralith> anyone?
20:56:54 <Olathe> You could have it wait for a thread to finish its work and then use that to merge the next pair.
20:57:04 <ddarius> Olathe: The new work-stealing implementation of threading may help that particular problem.
20:57:13 <wli> rwbarton: Reputedly there is not much of a barrier in the way of at least parsing it, though I couldn't figure that out. From there I'm too far beyond clueless to have any idea of what to do.
20:57:18 <Olathe> Ahh, what's the basic idea of that ?
20:57:34 <crutcher> Is anyone here familiar with SPJ/Lester's Implementation of Function Languages book/tutorial?
20:58:31 <ddarius> Olathe: I'd have to look it up.  There should be some discussion on the GHC Developer's wiki.
20:58:40 <pumpkin> bah, I hate floating point math
20:58:43 <gueux> I try to use Data.Graph.Astar but I need to install Data.PSQueue
20:58:43 <wli> I worked through a large amount of it at one point. I've since gotten too much dumber to understand what little of it I did.
20:58:44 <Olathe> > let mean xs = let (sum, len) = f 0 0 xs in sum/len where f sum len [] = (sum, len); f sum len (x:xs) = seq sum (seq len (f (sum + x) (len + 1) xs)) in mean . map (1%) $ [1..20000]
20:58:51 <ddarius> Olathe: A manual way to handle this particular problem would be to unfold the loop a few levels.
20:58:59 <lambdabot>   thread killed
20:59:11 <gueux> what do you use to install libraries?
21:00:41 <Ralith> pumpkin: what's the standard way of passing functions around without accidentally calling them all the time?
21:00:46 <monochrom> I manually get from hackage and run Setup.
21:00:57 <pumpkin> Ralith: how do you mean?
21:01:28 <Ralith> pumpkin: say I have foo :: IO () which is meant to be called at a specific time only
21:01:53 <ddarius> Ralith: Just pass it around.
21:01:54 <pumpkin> make it take a bogus parameter
21:02:22 <wli> foo :: () -> IO ()
21:02:25 <ddarius> > let x = putStrLn "foo" in [x, x]
21:02:28 <Olathe> Ralith: You can pass that around just fine, as long as you don't mix it in directly with the results of main.
21:02:41 <lambdabot>   thread killed
21:02:47 <Olathe> Thread killed ?
21:02:48 <Ralith> laziness works for me here, then?
21:02:48 <pumpkin> that's odd
21:02:52 <Ralith> I guess ghci mislead me.
21:02:54 <wli> Or wrap it in Just
21:02:54 <Olathe> > let x = putStrLn "foo" in [x, x]
21:02:56 <ddarius> Ralith: Laziness has nothing to do with it.
21:03:03 <ddarius> Ralith: GHCi possibly did mislead you.
21:03:06 <pumpkin> Ralith: ghci will run IO for you
21:03:15 <pumpkin> if you ask for its value
21:03:23 <monochrom> which I hate
21:03:28 <wli> newsham: It's one of the standard delaying tactics for other FP languages.
21:03:34 <Olathe> > let x :: IO (); x = return () in [x, x]
21:03:39 <lambdabot>   thread killed
21:03:43 <pumpkin> interestng
21:03:54 <pumpkin> poor abused lambdabot
21:04:07 <wli> e.g. ocaml, sml.
21:04:11 <crutcher> wli: do you remember enough to answer questions about the very first interpreter?
21:04:20 <newsham> wli: but why in haskell?
21:04:34 <wli> crutcher: No.
21:04:40 <Ralith> progress!
21:04:49 <monochrom> ãfunny :: IO () -> IO (); funny x = putStrLn "hello"ã  This function takes your foo and won't even run it.
21:05:00 <wli> newsham: That guy sounded like he wanted to do something like that as a defensive programming measure.
21:05:10 <lambdabot>   thread killed
21:05:49 <christian_> mabdabot: Do you have emotions ;)
21:05:50 <christian_> ?
21:05:52 <wli> crutcher: I may (though probably not) be able to chime in if a fair number of specifics are laid out.
21:05:55 <christian_> ah
21:06:02 <christian_> lambdabot
21:06:11 <monochrom> ãnanny :: IO () -> IO (); nanny x = putStrLn "hello" >> x >> putStrLn "done"ã  This function takes your foo and runs it after printing hello and before printing done, very precisely.
21:06:35 <ddarius> dons: Isn't the "total alloc" just how much memory was allocated, not the maximum residency?  He may just be misinterpreting the numbers.
21:06:43 <christian_> lambdabot: Do you have emotions?
21:06:59 * wli is choking on subtraction for his arbitrary precision naturals newtype Nat = Nat (Word32, [Word32])
21:07:05 <Ralith> @src maybe
21:07:08 <wli> Never mind division.
21:07:19 * Ralith pokes lambdabot 
21:07:28 <Ralith> christian_: you broke it :(
21:07:33 <wli> I managed to sort of eke out addition and multiplication after a few iterations.
21:07:40 <christian_> :)
21:07:40 <Olathe> > 5
21:08:13 <Olathe> lambdabot has died :(
21:08:22 <Olathe> Again
21:08:24 <pumpkin> onoes
21:08:28 <crutcher> wli: I'm twisted up in the Template interpreter. Its very short, but there's a big gap between what it does, and what the transition rules describe. I'm a bit lost about the motivation for some of its actions, and about why they are correct.
21:08:29 <pumpkin> I can bring in pumpkinbot
21:08:31 <christian_> uh...ai and al...
21:08:36 <wli> (Grossly inefficient addition and multiplication.)
21:08:40 <Olathe> > 5
21:08:42 <pumpkinbot>   5
21:08:46 <Olathe> Yay !
21:08:50 <newsham> wli: zip the two variable length lists together in such a way that one gets padded out with zeros, then do a fold over the list while propogating carries?
21:08:50 <crutcher> wli: So I guess I don't have a specific question atm.
21:08:59 <Olathe> > let mean = uncurry (/) . foldb (\(s1, l1) (s2, l2) -> let s = s1 + s2; l = l1 + l2 in seq s (seq l (s, l))) (0, 0) . map (flip (,) 1) in mean . map (1%) $ [1..67500]
21:08:59 <wli> crutcher: I was never able to figure out how any of the transition rules related to anything.
21:09:00 <pumpkinbot>   mueval: Prelude.read: no parse
21:09:06 <Olathe> Bah.
21:09:20 <Olathe> > let mean = uncurry (/) . foldb (\(s1, l1) (s2, l2) -> let s = s1 + s2; l = l1 + l2 in seq s (seq l (s, l))) (0, 0) . map (flip (,) 1) in mean . map (1%) $ [1..67500]
21:09:26 <newsham> s/carries/borrows/
21:09:28 <pumpkinbot>   mueval: Prelude.read: no parse
21:09:32 <wli> crutcher: I sort of took them on blind faith. I never figured out the pattern even while I was more mentally capable.
21:09:42 <christian_> has one of you experience with FP and swarm intelligence?
21:09:53 <newsham> I guess if you propogate borrows all the way out and you end up with a negative value you gotta return zero?
21:10:13 <wli> newsham: I got addition going, but subtraction is defeating me.
21:10:29 <crutcher> wli: I've got some background with formal semantics, which is what the rules are. But I'm still a bit lost by what they actually coded.
21:10:31 <Ralith> pumpkin, ddarius, Olathe: thanks, that seems to have worked for two out of three of my funcs
21:10:35 <newsham> wli: sort of like addition, but instead of carrying overflows, you borrow underflows
21:10:48 <Olathe> Ralith: You're welcome.
21:10:57 <christian_> lamdabot!!!!
21:10:57 <wli> Subtraction goes the wrong way down the list and I can't smoke out how to program it.
21:11:00 <christian_> ah
21:11:05 <christian_> lambdabot!!!!
21:11:06 <newsham> just like with decimal.  ie:   (123 - 104),  3-4 = 9 with a borrow, 2-0-1 = 1, 1-1=0
21:11:11 <Ralith> however
21:11:14 <Ralith> (and this is tangental)
21:11:14 <newsham> and you get 19 (if I did it right)
21:11:23 <pumpkin> @bot
21:11:23 <lunabot>  :)
21:11:23 <pumpkinbot> :)
21:11:24 <Ralith> the one func that takes an argument is now giving me issues :/
21:11:26 <wli> I know I need to borrow. I just can't translate it into code.
21:11:41 <christian_> @bot: Weather NY!!
21:11:42 <pumpkinbot> No such poll:"Weather"
21:11:42 <lunabot>  :)
21:11:55 <christian_> @bot: How are you?
21:11:55 <pumpkinbot> usage: @vote <poll> <choice>
21:11:55 <lunabot>  :)
21:12:06 <christian_> ??
21:12:15 <christian_> lunabot seems intelligent
21:12:18 <wli> crutcher: You probably have a deeper understanding of it now than I ever did even while at top form.
21:12:19 <gueux> I have an "Ambiguous occurrence `map'". the reason is that I use Prelude and Set libraries
21:12:21 <pumpkin> it uses string distance
21:12:26 <christian_> @bot: 1+1;;
21:12:27 <pumpkinbot> usage: @vote <poll> <choice>
21:12:27 <lunabot>  :)
21:12:27 <pumpkin> probably edit
21:12:36 <christian_> @bot : 1+1
21:12:36 <lunabot>  :)
21:12:36 <pumpkinbot> :)
21:12:44 <gueux> is there a way to say "by default use the functions of the Prelude"?
21:12:47 <christian_> @bot >1+1
21:12:48 <pumpkinbot> :)
21:12:48 <lunabot>  :)
21:12:51 <christian_> hm
21:13:09 <crutcher> wli: k. thanks, :(
21:13:10 <christian_> @bot @bot
21:13:10 <pumpkinbot> :)
21:13:10 <lunabot>  :)
21:13:24 <christian_> @bot !prey
21:13:24 <pumpkinbot> :)
21:13:24 <lunabot>  :)
21:13:28 <christian_> boring
21:13:34 <christian_> @bot: talk
21:13:34 <pumpkinbot> usage: @vote <poll> <choice>
21:13:34 <lunabot>  :)
21:13:35 <pumpkin> anyway!
21:13:43 <monochrom> @human
21:13:43 <pumpkinbot> Unknown command, try @list
21:13:46 <crutcher> gueux: import Data.Set as S ... S.map
21:13:50 <christian_> @bot @list
21:13:50 <pumpkinbot> :)
21:13:50 <lunabot>  :)
21:13:53 <Ralith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1470#a1470
21:13:56 <newsham> wli: fold where your inputs are the new (a,b) digits, and the (result,borrow) accumulator
21:13:58 <pumpkin> christian_: that's not how it works...
21:14:04 <gueux> crutcher: I've done that
21:14:04 <ddarius> crutcher: import qualified ...
21:14:05 <Ralith> describes the problem with the remaining function
21:14:06 <christian_> jo
21:14:10 <christian_> but how?
21:14:11 <newsham> compute the new (a-b-c) into a new digit and a new borrow
21:14:16 <christian_> @list
21:14:16 <pumpkinbot> http://code.haskell.org/lambdabot/COMMANDS
21:14:18 <newsham> and return (digit:result, newborrow)
21:14:20 <gueux> but when I use a Prelude.map
21:14:21 <christian_> ah
21:14:25 <monochrom> Last time someone issued @human a lot of humans volunteered to answer it!
21:14:26 <pumpkin> @bot
21:14:27 <pumpkinbot> :)
21:14:27 <lunabot>  :)
21:14:28 <crutcher> gueux: paste your code?
21:14:28 <wli> newsham: I probably need an even more boneheaded description.
21:14:30 <christian_> @bot
21:14:31 <pumpkinbot> :)
21:14:31 <lunabot>  :)
21:14:33 <lambdabot> :)
21:14:39 <pumpkin> pumpkinbot: @part
21:14:39 <lambdabot> :)
21:14:39 <pumpkinbot> Plugin `system' failed with: Prelude.last: empty list
21:14:39 <crutcher> gueux: on hpaste.org
21:14:44 <newsham> wli: gimme a few seconds to write it up?
21:14:44 <christian_> @lamdabot say something
21:14:44 <pumpkinbot> Unknown command, try @list
21:14:44 <pumpkin> pumpkinbot: @part #haskell
21:14:47 <gueux> ghci says that the map is ambiguous
21:14:48 <ddarius> gueux: Use import qualified Data.Set as Set.
21:14:49 <lambdabot> Unknown command, try @list
21:15:15 <christian_> @dice
21:15:18 <monochrom> /ignore *bot!*@*
21:15:21 <lambdabot> unexpected end of input: expecting number
21:15:39 <christian_> @dice 10
21:15:39 <pumpkin> christian_: you can play with lambdabot in private ;)
21:15:45 <christian_> where?
21:15:47 <lambdabot> 10 => 10
21:15:57 <pumpkin> christian_: /msg lambdabot @ohai2uwannaplay?
21:16:01 <Olathe> christian_: /query lambdabot
21:16:09 <wli> I think at this point it may be best for me to stall for a while and hope I figure out how the list manipulations and arithmetic interact.
21:16:10 <christian_> ah... private message
21:16:17 <monochrom> christian_: /quit lambdabot @bot
21:16:26 <pumpkin> lol
21:16:41 * ddarius started an arbitrary precision floating point library in assembly many years ago.
21:17:05 <gueux> ddarius: ok
21:17:37 <pumpkin> I like Data.AEq, but just blindly checking against epsilon seems silly
21:17:45 * wli has an arbitrary-precision floating point module in Haskell he's too dumb to get any operations at all working for.
21:18:11 <pumpkin> wli: using lists of digits?
21:18:12 <pumpkin> or what?
21:19:00 <Ralith> what's MonadCatchIO, anyway?
21:19:29 <wli> pumpkin: Lists of Word32's or Int32's depending on which one looks like I could get anywhere using that day.
21:19:41 <pumpkin> ah
21:20:31 <wli> I'm at a loss as to the API, never mind the internals.
21:20:46 <silkarn> god, why are schemers and lispers such assholes?
21:21:02 <pumpkin> just provide a Num and RealFloat / Fractional instance for now?
21:21:16 <monochrom> I saw no assholes.
21:21:21 <hotaru2k3> silkarn: think about how you would feel if you spent hours counting parentheses
21:21:29 <monochrom> haha
21:21:38 <christian_> hehe
21:21:50 <hotaru2k3> they just take out the frustration from that on all the non-(lisp|scheme)ers
21:21:55 <monochrom> I would feel like a computer.
21:22:14 <monochrom> Hell, I already feel like a computer.
21:22:22 <christian_> you are im sure
21:22:30 <pumpkin> would it be possible to make an arrow that kept track of the number of floating point operations performed on a given value?
21:22:33 <christian_> that sort of ms intelligence
21:22:37 <wli> pumpkin: I suspect the Num/RealFloat/Fractional instances won't fly for reasons of needing to pass desired tolerances around somehow (e.g. MonadReader) and maybe throw floating point errors it's not possible to proceed in the face of.
21:23:07 <ddarius> pumpkin: If you lifted each floating point operation into an "action" sure.
21:23:09 <wli> I don't know how to either specify the tolerances or use them, though.
21:23:20 <pumpkin> ddarius: yeah
21:23:38 <wli> ddarius/pumpkin: That was the alternative API I devised.
21:24:04 <pumpkin> hmm
21:24:56 <wli> It looked kind of like assembly when you wrote computations in terms of it, not that I ever had anything but undefined in any of the ops.
21:25:04 <christian_> i got headache reading haskell code....
21:25:28 <christian_> but its beatifull
21:25:54 <christian_> i hope at least its not negative for me when i learn ocaml
21:26:57 <christian_> at least FP
21:27:02 <christian_> :)
21:27:08 <wli> It's not entirely stateless, since forcing the values to feed into other operations wants higher tolerances than asked for of the original operation.
21:27:28 <pumpkin> wli: there was a floating point monad put on hackage the other day iirc
21:27:39 <pumpkin> but I think it was for setting rounding / exception modes in your calculations
21:27:46 <pumpkin> not what you're doing with it really I guess
21:27:47 <newsham> wli: http://www.thenewsh.com/~newsham/x/machine/subtract.txt
21:27:51 <wli> pumpkin: It probably renders everything I ever thought of irrelevant.
21:27:57 <newsham> wli: examples arent tested, I just wrote it out in text form.
21:28:03 <pumpkin> wli: I'm sure it doesn't
21:28:13 <wli> newsham: Thanks.
21:28:22 <newsham> let me know if you have questions or see errors
21:28:32 <monochrom> API design is hard. I spend forever on it. Implementation is just 1% of the time in comparison.
21:29:03 <wli> I wrote a modular arithmetic lib in the spirit of what I had in mind for floating point.
21:29:06 <wli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1451#a1451
21:29:16 <newsham> wli: the code for addition should be nearly identical
21:30:01 <wli> What I did for addition looks very different.
21:30:18 <newsham> but if you wanted to do it like this, you should end up with a very similar fold
21:30:24 <newsham> with a just slightly different step function
21:30:42 <wli> It's probably not substantially different, but it is superficially different.
21:30:44 <Ralith> pumpkin: could I get your input on my issue?
21:31:31 <newsham> you can obviously write the folds out recursively
21:31:37 <newsham> which might make it slightly clearer
21:31:45 <christian_> has haskell some sort of records?
21:31:46 <wli> One thing that completely stumps me is how to switch between relative and absolute tolerances, and for that matter, how to cope with "catastrophic cancellation" during addition.
21:32:15 <pumpkin> Ralith: where does loadFunc come from?
21:32:34 <Ralith> it's a function I wrote, which works as intended as far as I can see; I can up the whole file if you really want.
21:32:41 <wli> That's the actual case where you need to jack up the tolerances on the inputs so the output meets the specified tolerances.
21:33:07 <newsham> christian: yes, you can define record data types
21:33:13 <christian_> :)
21:33:20 <Ralith> pumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1471#a1471
21:33:21 <newsham> data Foo = Foo { val1 :: Int, val2 :: String, bar :: Maybe Int }
21:33:23 <wli> So the whole concept is resting on a case I have no idea how to use the concept to handle.
21:33:24 <christian_> so at least SOME sort of state
21:33:36 <pumpkin> Ralith: btw, your do f <- x; f is just x
21:33:43 <christian_> :)
21:33:46 <Ralith> 'kay
21:33:53 <Ralith> that was the product of a whole lot of experimenting
21:34:04 <Ralith> and I've been hesitant to improve other bits until I have what's broken nailed down
21:34:17 <ddarius> pumpkin: 'do x <- m; x' is 'join x'
21:34:36 <pumpkin> oh, yeah
21:34:38 <pumpkin> sorry :)
21:34:49 <ddarius> (er 'm' in that case)
21:34:54 <pumpkin> yeah
21:34:56 <Ralith> yeah
21:34:57 <monochrom> You saw me making the same mistake, I think!
21:35:01 <Ralith> join is more elgant though
21:35:02 <Ralith> elegant*
21:35:21 <christian_> @bot: topic multiagentsystem
21:35:21 <lambdabot> No such poll:"topic"
21:35:21 <lunabot>  :)
21:35:31 <christian_> aw
21:35:51 <newsham> wli: my subtract function doesnt properly handle one case.  ie: subtract 9 9 1 = (9,1)
21:35:53 <pumpkin> christian_: @bot isn't used to talk to the bot...
21:35:53 <monochrom> I vote against multiagentsystem, in case you want to know.
21:36:07 <TomMD> @botsnack
21:36:08 <lambdabot> :)
21:36:08 <lunabot>  :)
21:36:11 <christian_> jeah...im a freak talking with bots
21:36:22 <christian_> why, monochrome?
21:36:22 <Ralith> revised
21:36:25 <newsham> c' = if ((a-b) > a || r > a) ...
21:36:27 <Ralith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1471#a1472
21:36:47 <pumpkin> Ralith: where does the MonadCatchIO constraint come from?
21:37:14 <TomMD> @hoogle MonadCatchIO
21:37:14 <christian_> i think autonomous and isolated objects are a bonus
21:37:14 <lambdabot> No results found
21:37:16 <Ralith> possibly:
21:37:16 <Ralith> runInterpreter :: (MonadCatchIO m, Functor m) => InterpreterT m a -> m (Either InterpreterError a)
21:37:25 <pumpkin> ah
21:37:50 <christian_> im a freak anyway
21:38:14 <wli> newsham: I suspect mapAccumR may be more natural for my representation (most significant digit at the list head).
21:38:47 <christian_> and mas are a good ditributed programming paradigm
21:38:56 <christian_> +s
21:39:17 <christian_> or am i false
21:39:21 <christian_> ??
21:39:27 <Ralith> pumpkin: Message is a fairly simple datatype, which I've already had to add deriving (Typeable) to (by way of ghc's DeriveDataTypeable extension)
21:39:41 <Ralith> that's necessary to even get it into the as :: foo bit
21:39:43 <Ralith> I think
21:39:57 <silkarn> is fold a procedure on lists specifically or is ok to use it as a name for any procedure that accumulates a value from each elemnts of a structure?
21:39:57 <pumpkin> is as just undefined?
21:40:14 <Ralith> as :: (Data.Typeable.Typeable a) => a
21:40:15 <newsham> I dont know mapAccumR, I'll look
21:40:26 <Ralith> not sure what it is, it's from Hint
21:40:34 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
21:40:43 <pumpkin> silkarn: ^
21:41:15 <pumpkin> Ralith: hmm
21:41:22 <newsham> wli: yah, that looks good
21:41:23 <christian_> i need a mas and a holistic logic system, i think
21:41:49 <christian_> any idea?
21:42:02 <wli> If I can smoke out the step functions, I might be able to write addition in terms of mapAccumR as well.
21:42:13 <monochrom> I now think the word "agent" is overrated, just as the word "object" is. The words say nothing. The statement "mas are a good ditributed programming paradigm" is infallible because the "mas" part says nothing.
21:42:34 <newsham> are you folding from the tail of the list or from the head of the list?
21:42:36 <wli> BTW the lists look a little funny; they're actually newtype Nat = Nat (Word32, [Word32])
21:42:48 <newsham> which side do you store your least significant leg?
21:42:56 <christian_> well, at least it is a pragmatic environment
21:43:13 <newsham> wli:    f (Nat x ys) = x:ys
21:43:20 <newsham> you can easily move to a list
21:43:26 <dibblego> pragmatism is an infection of the mind
21:43:44 <christian_> i associate autonony when i hear agent
21:43:58 <newsham> is there any reason you separated out one of the legs?
21:44:08 <monochrom> If you don't disagree that the word says nothing, how can you even discuss whether that nothingness is pragmatic or not?
21:44:18 <christian_> hm
21:44:28 <wli> newsham: I do that left and right and do ~(x : xs) pattern matches against things known not to be empty.
21:44:43 <christian_> well at least i have associations but can not falsify you
21:44:51 <wli> newsham: It's to enforce the invariant of nonemptiness of the digit string.
21:44:53 <christian_> *does just fuzzy logic*
21:45:01 <newsham> why not allow [] to represent zero?
21:45:12 <Ralith> because [] is not 0
21:45:22 <newsham> ralith: except when it is
21:45:27 <Ralith> true!
21:45:43 <newsham> type Nat = [] ()    ;-)
21:45:56 <newsham> z = []; s = (():)
21:45:58 <wli> newsham: I wanted the representation of 0 to be unique.
21:46:16 <wli> Nat (0, []) == 0
21:46:21 <sjanssen> wli: why Word32 and not Word?
21:46:22 <newsham> wli: its not.    (0,[]) == (0,[0]) = (0,repeat 0)
21:46:49 <newsham> its only unique in canonical form of no trailing zeros
21:47:11 <wli> newsham: Leading zeros appearing anywhere but with an empty tail list are considered denormalized.
21:47:24 <newsham> ps: when doing subtraction you might want to normalize the results by stripping trailing zeros
21:47:40 <wli> sjanssen: Word32/Word64 are used for double precision vs. single precision.
21:47:42 <newsham> wli: you can apply that same rule with  data Nat = Nat [Word]
21:47:47 <newsham> where [] is normal form for 0
21:47:48 <wli> newsham: It's most significant digit first.
21:47:48 <christian_> but i will remind your statement, monochrome
21:47:57 <christian_> aw...remember
21:48:09 <newsham> I would store least significant first myself.
21:48:13 <newsham> but either should work
21:48:36 <newsham> i guess normalization is easier in big endian.  head of list should never be 0
21:48:47 <Ralith> pumpkin: I get the same error if I s/Message/Int/
21:49:03 <wli> Yeah, that's one reason why.
21:49:05 <newsham> with little endian, you can write the zero-extending zip more easily
21:49:12 <Ralith> pumpkin: which is weird, because the Hint example demonstrates with a function of type Maybe Int -> Int
21:50:07 <wli> Maybe it would be better as a sequence so both ends are equally accessible.
21:50:31 <wli> Data.Sequence, that is.
21:50:43 <pumpkin> Ralith: not sure how all that stuff works :/
21:50:49 <newsham> i'd do it the simplest way first, then rewrite for efficiency if/when needed
21:50:51 <Ralith> pumpkin: so I doubt it's just that I need to instantiate the IO thing.
21:50:56 <newsham> then you will have simple model you can QuickCheck against
21:51:24 <christian_> or say instead of mas, programs that have complex communication possibilities
21:51:32 <wli> newsham: It's not even for efficiency, but so that operations coming at the list from either end are equally doable.
21:51:48 <newsham> wli: there's always "reverse"
21:52:31 <christian_> good n8
21:52:44 <christian_> over and out
21:54:21 <wli> So long as it helps me get it written.
21:54:53 <pumpkin> I never did get the good n8 thing
21:55:00 <pumpkin> it sounds like nate to me
21:57:26 <Ralith> pumpkin: new revision, simplified and easy to test by just commenting/uncommenting last line: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1471#a1473
21:58:30 <rwbarton> pumpkin: maybe it's german
21:59:01 <rwbarton> pumpkin: (n)acht
21:59:06 <monochrom> perhaps related to l8t3r
21:59:08 <pumpkin> aha!
22:00:22 <Ralith> getting somewhere
22:00:27 <Ralith> I got the fancier func to load in ghci
22:00:33 <Ralith> > Right bar <- runInterpreter $ do loadModules ["Test"]; setTopLevelModules ["Test"]; interpret "handler" (as :: Message -> IO ())
22:00:35 <lambdabot>   <no location info>: parse error on input `<-'
22:00:42 <Ralith> that wasn't for you, lambdabot
22:03:30 <Ralith> pumpkin: how does what I pasted differ from my func? :/
22:06:12 <Ralith> pumpkin: ok, got it isolated:
22:06:22 <Ralith> Right bar <- runInterpreter $ do loadModules ["Test"]; setTopLevelModules ["Test"]; interpret "handle" (as :: Message -> IO ()) -- works
22:06:31 <Ralith> let baz = do Right bar <- runInterpreter (do loadModules ["Test"]; setTopLevelModules ["Test"]; interpret "handle" (as :: Message -> IO ())); bar -- does not work
22:06:36 <Ralith> what's the difference?
22:06:39 <Ralith> anyone?
22:06:46 <pumpkin> how does it not work?
22:07:00 <Ralith>     No instance for (MonadCatchIO ((->) Message))
22:07:05 <pumpkin> oh, the difference is that you're doing join on it?
22:07:17 <pumpkin> try return bar
22:07:26 <Ralith>     Ambiguous type variable `m' in the constraints:
22:07:43 <Ralith> here, I'll paste the whole thing on hpaste
22:07:58 <Ralith> pumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1474#a1474
22:08:28 <pumpkin> you need to tell it what type you want baz to be
22:08:44 <pumpkin> it's an IO (Message -> IO ()) isn't it?
22:08:58 <Ralith> I think so
22:09:11 <Ralith> worked
22:10:20 <pumpkin> in your loadPlugin I think you need to make the thing return an IO Plugin
22:10:45 <Ralith> kay, got the parallel baz working in a file
22:11:54 <Ralith> pumpkin: doesn't like that being forced in the type sig directly, seeing what I can do in loadFunc
22:12:01 <pumpkin> well
22:12:07 <pumpkin> you need to make changes to the function to match the new type sig
22:12:25 <pumpkin> you'll want to return $ Plugin x y z
22:12:26 <pumpkin> etc.
22:13:01 <Ralith> uhh, realized something
22:13:12 <Ralith> loadFunc is being required to return multiple types
22:13:16 <Ralith> how is that supposed to work?
22:13:21 <pumpkin> ?
22:13:34 <monochrom> what is multiple types?
22:13:47 <Ralith> monochrom: more than one.
22:13:55 <monochrom> example?
22:14:07 <wli> Overloading on the result type or maybe tuple return types.
22:14:48 <monochrom> That's an ambiguity there.
22:14:49 <Ralith> pumpkin: e.g. ideally it's alternately a (Data.Typeable.Typeable a) => String -> String -> a -> (IO ()) or a (Data.Typeable.Typeable a) => String -> String -> a -> (Message -> IO ())
22:15:00 <Ralith> monochrom: ^
22:15:16 <Ralith> then again
22:15:26 <Ralith> wait, that's perfectly reasonable, isn't it
22:15:33 <Ralith> since the last bit is determined by the type of a
22:16:25 <Ralith> pumpkin: well, I've got loadPlugin as String -> IO Plugin, but I'm not sure what good it's done mie
22:16:28 <monochrom> Difficult.
22:16:29 <Ralith> me*
22:16:31 <Ralith> error remains
22:18:08 <Ralith> pumpkin: this puts me pretty much back a revision with no improvements
22:18:52 <Ralith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1475#a1475
22:19:07 <pumpkin> the point is you don't want to join those things
22:19:14 <pumpkin> I think
22:19:37 <Ralith> how do I do that?
22:19:50 <Ralith> change my data structure to Maybe (IO (IO ()) etc.?
22:20:17 <Ralith> if I omit join, I get:
22:20:35 <Ralith> Plugins.hs:25:39:
22:20:35 <Ralith>     Couldn't match expected type `()' against inferred type `IO ()'
22:20:35 <Ralith>       Expected type: IO ()
22:20:35 <Ralith>       Inferred type: IO (IO ())
22:20:44 <pumpkin> I posted a change to your paste
22:20:50 <pumpkin> I haven't tested it because I don't have those modules
22:21:04 <pumpkin> it might be ridiculous :)
22:21:10 <Ralith> cabal install hint irc
22:21:17 <Ralith> if you awnt to.
22:21:28 <Ralith> hpaste needs diffs
22:21:49 <Ralith> trying it.
22:22:15 <pumpkin> I was too, but I don't have your message class :P
22:22:36 <Ralith> that's in irc
22:22:38 <Ralith> :D
22:22:40 <Ralith> it seems to work!
22:22:42 * Ralith does final testing
22:22:44 <pumpkin> :)
22:23:39 <Ralith> it works!
22:23:40 <Ralith> :DDD
22:23:47 <Ralith> thank you!
22:23:54 <pumpkin> do you understand what was wrong?
22:24:04 <Ralith> yeah, I think so
22:24:12 <Ralith> sorta.
22:24:35 <Ralith> if you want to put it together eloquently I might benefit :>
22:25:06 <pumpkin> as far as I can see, you were basically loading the function and trying to call it immediately, and stick the result of the function into the Plugin structure
22:25:16 <pumpkin> rather than sticking the function itself in
22:25:30 <pumpkin> doing the x <- loadFunc ... ; x
22:25:35 <pumpkin> and the join did that too
22:25:48 <Ralith> actually, those both worked on their own
22:25:55 <Ralith> they just didn't work in parallel with the fancier type
22:26:02 <pumpkin> strange then :)
22:26:50 <Ralith> I suspect I was forcing something to specialize prematurely or something
22:27:00 * Ralith needs more practice with monads.
22:28:11 * Ralith starts working on error handling
22:28:48 <pumpkin> you making an irc bot then?
22:29:50 <ski_> @ghc
22:29:51 <lambdabot> ghc says: All the type patterns for a generic type constructor must be identical
22:31:00 <Ralith> pumpkin: yeah
22:31:11 <Ralith> my second serious bot
22:31:18 <Ralith> first one was in D and was pretty successful
22:31:29 <Ralith> hoping to improve on it.
22:31:31 <pumpkin> seems like you'd want each plugin to report a list of commands it reponds to as well
22:31:35 <pumpkin> not just a handler
22:31:50 <Ralith> nah
22:31:53 <Ralith> that's very limiting
22:31:57 <pumpkin> so you can dispatch more efficiently, and can avoid sending everything to each plugin?
22:32:06 <Ralith> for example
22:32:18 <Ralith> many plugns will do things *other* than reply to standard PRIVMSG !dosomething commands
22:32:22 <Ralith> plugins*
22:32:42 <Ralith> e.g. reply to emotes involving the bot, respond to PONG, interact with nickserv, etc.
22:32:45 <pumpkin> it seems like most plugins don't care about everything that's said in a channel though
22:32:56 <pumpkin> so can avoid being passed all messages
22:33:01 <Ralith> well, I haven't worked out a way to filter that isn't extremely limiting yet
22:33:11 <pumpkin> so you could have a way of reporting either that you're only intested in some messages, or all messages
22:33:35 <pumpkin> otherwise you'll have repetitive code in most plugins
22:33:36 <Ralith> on my last bot each plugin had an 'filter' function that was called w/o forking or anything
22:33:44 <Ralith> but it didn't really seem to be worth it
22:33:54 <Ralith> repetitive code?
22:33:55 <Ralith> I dunno.
22:34:16 <pumpkin> i.e., most plugins will do "when (message `startsWith` "@moo") doMyThing
22:34:18 <kmeyer> hey, arch is the distro with >1000 haskell packages, right?
22:34:20 <Ralith> I wouldn't call one instance of "handler (Message _ _ _) = return" very repetitive.
22:34:37 <pumpkin> or rather "@moo" `isPrefixOf` message
22:34:41 <pumpkin> :)
22:34:46 <Ralith> pattern matching can be used to get coarse filtering post-dispatch
22:34:50 <monochrom> I think so, kmeyer.
22:34:54 <Ralith> then analysis can be done on the matched bits
22:35:01 <kmeyer> know if any of the arch maintainers are here then?
22:35:18 <pumpkin> Ralith: true, but pattern matching of list prefixes is ugly :)
22:35:32 <nanothief> kmeyer, try #arch-haskell
22:35:33 <kmeyer> ah, nevermind
22:35:35 <kmeyer> oh, ok
22:35:35 <monochrom> dons turns coffee and haskell packages into arch packages and announces on mailing lists
22:35:45 <pumpkin> '@':'m':'o':'o':rest
22:36:09 <Ralith> well, I'd love to have an efficient generalized pre-dispatch filter
22:36:21 <Ralith> I just haven't thought of a good way to do one
22:36:23 <Ralith> any suggestions?
22:36:45 <Ralith> I want to maintain as much generality as possible
22:36:48 <pumpkin> I still think the common case is a string prefix, so have plugins report either a list of prefixes they will accept, or that they want unfiltered input
22:37:09 <Ralith> but that's special-casing
22:37:12 <Ralith> which is :/
22:37:25 <monochrom> dons :: (CoffeeMonad m) => Package Haskell -> m (Package Arch)
22:37:56 <pumpkin> Ralith: have each plugin return a [(String -> Bool, String -> IO ())] then
22:38:00 <pumpkin> :P
22:38:14 <Ralith> er
22:38:15 <Ralith> to what end?
22:38:28 <Ralith> perhaps you mean
22:38:37 <Ralith> s/String/Message/
22:38:50 <pumpkin> yeah
22:39:16 <ray> ray :: Coffee -> () -- i've developed a tolerance for caffeine :(
22:39:19 <pumpkin> [(isPrefixOf "@bot", const $ text ":)"), (isPrefixOf "@faq", const $ text "Yes! Haskell can do that"]
22:39:23 <pumpkin> something like that
22:39:31 <pumpkin> except with message instead of string
22:39:36 <pumpkin> what does Message buy you over string btw?
22:39:47 <pumpkin> it includes join/part/status messages?
22:39:54 <Ralith> yeah
22:39:59 <Ralith> it can represent any IRC message
22:40:04 <Ralith> without making it take extra effort to get the interesting bits
22:40:10 <pumpkin> ah
22:40:16 <Ralith> so I can e.g. work out who sent a message
22:41:19 <ski_> `String -> Maybe (IO ())' ?
22:41:21 <Ralith> at least, in theory.
22:41:25 <Ralith> I haven't worked out this IRC lib quite yet.
22:41:28 <Ralith> I may yet write my own.
22:41:51 <pumpkin> ski_: that could also work
22:41:53 <dmwit> ski_: why?
22:42:07 <dmwit> s/Nothing/return ()/g
22:42:30 <pumpkin> it would allow you to determine if no one responded to a message
22:42:31 <ski_> if the second part of `(String -> Bool, String -> IO ())' is only to be used when the first part succeeds (and on the same string), then i think a `Maybe' solution is nicer
22:42:44 <Ralith> pumpkin: I don't care if no plugins use the message.
22:42:49 <Ralith> that's not important data.
22:42:52 <ski_> dmwit : well, that doesn't tell you whether it matched or not, no ?
22:42:58 <Raynes> Functional programming is the best thing evar.
22:43:21 <dmwit> ski_: Oh, I see, yes.
22:43:30 <dblhelix> Raynes: don't rule out sliced bread. ;-)
22:43:40 <Raynes> ;)
22:43:41 <Ralith> pumpkin: the only reason I should filter at all is because the cost of dispatching could be greater than the cost of running an isolated filter, right?
22:43:55 <dmwit> ski_: I thought you were suggesting (String -> Bool, String -> Maybe (IO ())), which is a little less sensical. =P
22:43:56 <pumpkin> yeah
22:44:06 <ski_> dmwit : i see :)
22:44:40 * ski_ conjectures that toasted bread is better than sliced bread
22:44:44 <pumpkin> I agree
22:44:56 <ivanm> ski_: doesn't the former depend on the latter?
22:45:06 <ski_> well, yes
22:45:09 * ivanm just came in and thus doesn't know in what context bread is being discussed...
22:45:11 <ivanm> ;-)
22:45:19 <ski_> but i don't like pre-sliced bread
22:45:29 <ivanm> ski_: so toasted sliced bread is the greatest thing since sliced bread? :p
22:45:35 <ski_> but i like toasted bread (and can accept pre-sliced, in that case)
22:45:47 <ivanm> hmmm.... what about bread that isn't meant to be sliced? e.g. pull-aparts, etc.
22:45:48 <Ralith> pumpkin: actually
22:46:08 <Ralith> I think [(String -> Bool, String -> (IO ()))] is better
22:46:08 <ddarius> http://pdos.csail.mit.edu/~engler/dpf.html
22:46:20 <ski_> (you might formulate this as sliced bread which is not to be toasted is bad)
22:46:27 <Ralith> the only reason there's significant dispatch overhead is because I want to fork for each handler
22:46:28 <b\6> Data.Accessor.Template deriveAccessors isn't generating type signatures. is there something to do about that?
22:46:45 <pumpkin> Ralith: why not use lightweight threads?
22:46:46 <Ralith> and since forking is pervasive, that logic doesn't belong in plugins
22:46:48 <pumpkin> or did you mean forkIO
22:46:52 <ddarius> Ralith: "forking" isn't expensive.
22:46:54 <Ralith> pumpkin: lightweight threads, w/e
22:47:04 <Ralith> I don't know how it's done in haskell yet
22:47:06 <dblhelix> ski_: I think I better get me some coffee before I engage in this discussion
22:47:07 <Ralith> I just know what I want
22:47:09 <dblhelix> :-)
22:47:15 <Ralith> which is pervasive parallelism
22:47:16 <pumpkin> if you're doing forkIO, no need to do it my way cause it's dirt cheap
22:47:24 <ski_> Ralith : why is that better than `[String -> Maybe (IO ())]' ?
22:47:28 <Ralith> okay then
22:47:41 <Ralith> ski_: because my way lets the central code decide whether to launch a new fork or not
22:47:46 <pumpkin> Ralith: you'll also probably need to pass a chan do your subthreads, as I doubt they can all write to the IRC connection at once
22:47:48 <Ralith> but it sounds like it's so lightweight I dont' need to pre-filter at all
22:47:56 <ski_> Ralith : and my variant doesn't ?
22:47:58 <pumpkin> Ralith: that Maybe one allows you to do that too
22:48:01 <Ralith> pumpkin: yeah, thus the fully supported Message version
22:48:05 <Ralith> Message data structure*
22:48:16 <Ralith> in theory it provides all info relevant to the given message
22:48:22 <ddarius> Ralith: There would be a point in combining input filters to avoid redundant checking, but that's probably negligible in this case.
22:48:39 <Ralith> ddarius: i.e. I don't need to filter?
22:48:48 <Ralith> ski_: well, how would you do it your way?
22:48:57 <pumpkin> Ralith: if it returns Just x, call x
22:49:02 <pumpkin> otherwise, skip over it
22:49:16 <ski_> Ralith : as pumpkin. but if you want to fork it, then fork off `x'
22:49:19 <Ralith> point.
22:49:24 <Ralith> still
22:49:28 <Ralith> if forking is that light
22:49:32 <Ralith> why bother prefiltering at all?
22:49:38 <pumpkin> Ralith: the reason I wanted prefix reporting is that you could do awesome merging of prefixes into a trie or something :P
22:49:45 <ddarius> Ralith: You shouldn't if all you were worried about is "forking overhead"
22:49:49 <dmwit> Ralith: It has nothing to do with whether forking is light or not.
22:49:51 <pumpkin> so you wouldn't have linear time in the number of commands
22:49:54 <Ralith> ddarius: well, there will be a lot of it
22:50:00 <Ralith> because
22:50:03 <ddarius> pumpkin: See that dpf link I mentioned above.
22:50:11 <dmwit> Ralith: You have exactly the same fork overhead whether you use Bool to decide whether you fork or whether you use Maybe to decide whether you fork.
22:50:17 <ddarius> Ralith: Is "a lot" millions at once?
22:50:21 <Ralith> dmwit: that's not the issue
22:50:27 <Ralith> without prefiltering, there will be one dispatch per plugin per IRC message.
22:50:27 <ski_> Ralith : my point is merely that `Maybe a' is better than `(Bool,a)' in the case you never want to use the `a' in case of `False'
22:50:35 <Ralith> ski_: yeah, I get it, I agree
22:50:52 * dmwit still doesn't understand Ralith's point
22:50:57 <Ralith> I'm just somewhat worried about what might in the long term add up to more than a hundred forks per second
22:50:58 <ddarius> Ralith: Which will be like what, hundreds?  That's no problem.
22:51:04 <Ralith> really?
22:51:05 <Ralith> awesome.
22:51:08 <ski_> (removes another possibility for hiding bugs, and intent obscuration)
22:51:10 <Ralith> my last bot was in D, as I said
22:51:23 <Ralith> and threads there were OS threads, which meant 7MB stack plus misc. other stuff
22:51:29 <Ralith> I ended up just using a threadpool
22:51:42 <pumpkin> ddarius: looks neat
22:51:42 <Ralith> which sacrificed my ideal somewhat.
22:51:50 <Ralith> ddarius: just how do forks manage to be so light?
22:51:54 <ddarius> Ralith: I believe the overhead of a thread in Haskell is on the order of a few words.
22:51:55 <wli> Ralith: IIRC ghc's RTS has M:N threads.
22:52:00 <Ralith> wli: M:N?
22:52:27 <ski_> `M' OS threads executes `N' haskell threads
22:52:33 <Ralith> ah.
22:52:42 <wli> Ralith: The language thread abstraction is not directly tied to OS/kernel threads, so you specify the number of those to process your user threads with on the cmdline or in an env var.
22:52:59 <Ralith> kk
22:53:02 <Ralith> well then!
22:53:08 <Ralith> ludicrous parallelism, here we come!
22:53:11 <dmwit> -RTS -N2 # to use 2 OS threads
22:54:12 <pumpkin> +RTS?
22:55:08 <dmwit> Maybe.
22:55:13 <pumpkin> Either.
22:55:15 <dmwit> I thought +RTS ended the RTS options.
22:55:25 <pumpkin> I thought it started them
22:55:31 <pumpkin> haven't played with it in a while
22:55:48 <dolio> +RTS starts them, last I checked.
22:55:51 <wli> Ralith: The way ghc's runtime switches between user threads on its kernel threads is kind of similar to how an OS kernel switches between threads on the various CPU's of an SMP system.
22:56:31 <dmwit> Okay, I was wrong, according to GHC's manual.
22:57:04 <Ralith> wli: cool.
22:57:25 * sjanssen <3 GHC's threads
23:00:26 <b\6> Data.Accessor.Template deriveAccessors isn't generating type signatures. is there something to do about that?
23:03:20 <ddarius> It looks like the overhead for a thread is roughly 20 words plus however big its stack is.
23:03:47 <pumpkin> words being 2 bytes?
23:03:50 <pumpkin> or 4?
23:04:05 <pumpkin> or the address size?
23:04:37 <ddarius> pumpkin: Machine word size for many.  Some fields are specific sizes, some are pointers.
23:04:44 <pumpkin> ah
23:48:25 <redditbot> Why Not Haskell?
23:49:09 <pumpkin> redditbot: troll
23:50:59 <dolio> "Conclusion: Haskell is now one of my favorite programming languages"
23:52:20 <ivanm> pumpkin: lol
23:52:21 <ivanm> ;-)
23:52:36 <pumpkin> :)
23:55:56 <Gracenotes> redditbot needs some linkage
23:57:36 <pumpkin> Gracenotes: I think rwbarton gave dons a patch, but dons probably hasn't had a chance to put it up yet :)
