00:00:00 <luqui> somnolence, oh you want perl-like behavior?
00:00:00 <pumpkin> somnolence: you might want to fold an mplus over it, or name your functions with more indicative names? :P
00:00:04 <ksf> dons, go on and post "Haskell is the most popular programming language" on reddit.
00:00:11 <somnolence> factors?!?!
00:00:16 <somnolence> -.-
00:00:28 <pumpkin> somnolence: you have a function called factors that returns either a value or nothing
00:00:39 <somnolence> can I have it
00:00:45 <somnolence> actually return "Nothing" not null
00:00:47 <somnolence> as in
00:00:48 <somnolence> it doesn't return
00:00:53 <somnolence> oh wait
00:00:54 <pumpkin> no
00:00:56 <luqui> somnolence, no.  perl is far too vague for Haskell's taste.  you have to return *something*
00:00:57 <somnolence> yeah fail
00:01:00 <luqui> :t joinMaybes
00:01:02 <pumpkinbot> Not in scope: `joinMaybes'
00:01:03 <somnolence> damn anonymous functions
00:01:05 <dons> ksf: i'm not sure we can conclude that. i think its more that we like to talk on the weekends, and we have a well organised path from haskell.org -> #haskell
00:01:07 <luqui> : catMaybes
00:01:09 <luqui> :t catMaybes
00:01:10 <pumpkinbot> forall a. [Maybe a] -> [a]
00:01:18 <luqui> somnolence, ^^ that is a useful function
00:01:20 <dons> so we're just more efficient for our size.
00:01:27 <pumpkin> @src catMaybes
00:01:28 <pumpkinbot> catMaybes ls = [x | Just x <- ls]
00:01:30 <pumpkin> meow
00:01:33 <somnolence> it's fine I just won't use the anonymous function
00:01:55 <luqui> somnolence, yeah, a list comprehension is the best way to go for what you're trying to do anyway :-)
00:02:07 <ksf> dons, so what?
00:02:08 <somnolence> is *not* the best way to go
00:02:14 <pumpkin> I would still question your naming of that function, but if it makes sense to you (and no one else has to read it) that's all that matters :)
00:02:16 <somnolence> luqui I think you meant to say is *not*
00:02:22 <luqui> no I meant to say is
00:02:38 <somnolence> list comprehension is incredibly slow if you add each element for large numbers
00:02:39 <luqui> > let factors n = [ x | x <- [1..n]; n `mod` x == 0 ] in factors 42
00:02:41 <pumpkinbot>   mueval: Prelude.read: no parse
00:02:44 <luqui> > let factors n = [ x | x <- [1..n], n `mod` x == 0 ] in factors 42
00:02:46 <dons> so, we don't need to be silly
00:02:46 <pumpkinbot>   [1,2,3,6,7,14,21,42]
00:02:59 <Gracenotes> > let f xs = [4 | Nothing <- xs] in f [Just 1, Just 2, Nothing, Just 3]
00:03:01 <pumpkinbot>   [4]
00:03:10 <pumpkin> somnolence: it's not the list comprehension that's slow, it's checking every possible factor :P
00:03:12 <luqui> somnolence, oh, I meant in terms of readability.  it's the same algorithm as the one you're doing.
00:03:33 <ksf> dons, then add "possibly"
00:03:41 <dons> you do it.
00:03:48 <luqui> lol
00:04:17 <pumpkin> we could post #haskell is the most friendly large programming language IRC channel
00:04:28 <dons> we actually have to think about that a bit.
00:04:31 <pumpkin> but that would just attract trolls trying to prove we're human after all
00:04:32 <Gracenotes> heh
00:04:39 <dons> people are starting to complain about questions going unanswered
00:04:49 <dons> and i saw on person ask for a #haskell-beginners
00:04:52 <pumpkin> :o
00:05:00 <somnolence> lol
00:05:08 <luqui> pumpkin, we're not though.  said trolls get banned in a microsecond.  machine-like efficiency we have.
00:05:13 <somnolence> how can I count the number of element n in list x
00:05:14 <somnolence> e.g.
00:05:22 <somnolence>  count n in [n,n,n,n,x
00:05:23 <somnolence> ]
00:05:23 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
00:05:29 <pumpkin> somnolence: length . filter
00:05:32 <Gracenotes> ]
00:05:32 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
00:05:42 <somnolence> rite
00:05:44 <pumpkin> where filter takes a predicate of what you're looking for
00:05:56 <pumpkin> > length . filter (==1) $ [1,2,3,1,1,5,67,2]
00:05:58 <pumpkinbot>   3
00:06:09 <ksf> WE ARE CURRY. RESISTANCE IS BOTTOM.
00:06:12 <luqui> pumpkin, although the composition is beautiful, you probably shouldn't use it when you don't mean it.
00:06:24 <pumpkin> yeah, I should've included a p in there :)
00:06:56 <somnolence> yo pumpkin
00:07:02 <pumpkin> yo somnolence
00:07:03 <somnolence> what happened to lambda bot?
00:07:10 <pumpkin> somnolence: pumpkinbot eated it
00:07:14 <pumpkin> whole.
00:07:18 <somnolence> I don't like pumpkin bot
00:07:27 <somnolence> > jack-o-latern
00:07:28 <pumpkin> it'll eat you too if you say that too loudly
00:07:28 <ddarius> dons: You named your blog "Control.Monad.Writer"?
00:07:29 <pumpkinbot>   mueval: Prelude.read: no parse
00:07:34 <somnolence> @jack-o-lantern
00:07:35 <pumpkinbot> Unknown command, try @list
00:07:38 <Gracenotes> hm. How does the infixity of (.) go?
00:07:51 <pumpkin> infixr 9 .
00:07:55 <Gracenotes> ah.. r
00:08:54 <Gracenotes> @unpl (a .) . b . c
00:08:54 <pumpkinbot> (\ g m -> a (b (c g) m))
00:09:02 <luqui> Gracenotes, well.. but.. it's associative, so...
00:09:25 <Gracenotes> @unpl ((a .) . b) . c
00:09:25 <pumpkinbot> (\ g m -> a (b (c g) m))
00:09:35 <Gracenotes> @unpl (a .) . (b . c)
00:09:36 <pumpkinbot> (\ g m -> a (b (c g) m))
00:09:38 <Gracenotes> ah, yeah :)
00:11:17 <pumpkin> somnolence: but apparently the box lambdabot is hosted on is down
00:11:26 <ddarius> dons: Comparing the topics for each channel is interesting.
00:11:28 <pumpkin> so I brought in pumpkinbot in the mean time
00:11:50 <pumpkin> Topic: NO LOL
00:12:18 <luqui> @bot
00:12:18 <pumpkinbot> :)
00:12:18 <lunabot>  :)
00:12:54 <Gracenotes> ddarius: the syntax error still hasn't been fixed :)
00:13:05 <ddarius> Gracenotes: It's a trap to catch bots.
00:13:13 <somnolence> pumpkinbot : is evil
00:13:20 <pumpkin> somnolence: why?
00:13:25 <pumpkin> it runs exactly the same software :P
00:13:27 <Gracenotes> ddarius: oh, really *raises eyebrows* What's the idea?
00:13:30 <pumpkin> almost exactly the same config file too :P
00:14:10 <mmorrow> @bot
00:14:10 <lunabot>  :)
00:14:10 <pumpkinbot> :)
00:14:11 <blbrown> woa, haskell is popular now
00:14:50 * Gracenotes fully expects the topic of #haskell to be runnable :P
00:15:01 <somnolence> almost exactly the same config file too :P
00:15:05 * mmorrow is just waiting for two lambdabots to be in here to make them botquine
00:15:11 <astrobunny> whoa haskell is fun
00:15:20 <somnolence> lololol
00:15:22 <mmorrow> @source , let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in
00:15:23 <pumpkinbot> , let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
00:15:23 <somnolence> mmorrow
00:15:25 <lunabot>  @source , let not = text . (++" in") . ap(++)show; available = "@source ,...
00:15:28 <astrobunny> i just tried currying for the first time!
00:15:37 <somnolence> ^
00:15:39 <somnolence> 2 bots?
00:15:42 <Gracenotes> aww. so close.
00:15:54 <pumpkin> somnolence: ?
00:16:05 <dons> ddarius: we're the only channel that doesn't put rules and regulations in the topic
00:16:08 <dons> interesting
00:16:20 <pumpkin> mmorrow: I normally @part mine when lambdabot comes back to avoid annoying duplicate answers to LB commands
00:16:29 <dons> oh, the git one is similar
00:16:30 <mmorrow> lambdabot has a "bug" in @source" which could be used to make two lambdabot go nuts
00:16:59 <somnolence> someone spends a bit too much time in #haskell ic
00:17:00 <Gracenotes> feature
00:17:05 <mmorrow> somnolence: heh
00:18:48 <mmorrow> somnolence: sclv et al noticed it last night, and i just applied the make-you-a-quine formula to it
00:19:15 <pumpkin> Peaker had a bot in here for a little while a few days ago
00:19:21 <mmorrow> (\x -> x `apply` (quote x)) (quote (\x -> x `apply` (quote x)))
00:19:23 <ray> dons: #scheme doesn't (seem to)
00:19:35 <ray> unless you were talking about big channels, not language channels
00:19:37 <mmorrow> , ap(++)show"ap(++)show"
00:19:38 <lunabot>  "ap(++)show\"ap(++)show\""
00:20:14 <wli> mmorrow: quining?
00:21:01 <mmorrow> , let (<<$>>) = dynApply in (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x))
00:21:02 <lunabot>  Just <<Maybe Dynamic>>
00:21:05 <mmorrow> grr
00:21:14 <mmorrow> , let (<<$>>) = dynApp in (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x))
00:21:15 <lunabot>  <<Dynamic>>
00:25:29 <mmorrow> in javascript
00:25:31 <mmorrow> (function(x){return("eval("+x+")("+x+")")})(function(x){return("eval("+x+")("+x+")")})
00:25:51 <mmorrow> ((lambda (x) (list x (list 'quote x))) '(lambda (x) (list x (list 'quote x))))
00:26:23 <ddarius> mmorrow: Where's my brainfuck quine?
00:26:31 <mmorrow> ?!
00:26:31 <pumpkinbot> Maybe you meant: . ? @ v
00:26:58 <mmorrow> hmm, how would you apply this strategy to brainfuck
00:27:14 * ddarius goes to sleep while mmorrow isn't looking.
00:27:18 <mmorrow> heh
00:29:29 <ksf> d'oh.
00:30:03 <ksf> if you curry, say, a -> b -> c, you don't have to care about a, anymore.
00:30:11 <mmorrow> TH:
00:30:12 <mmorrow> [|(\x -> return x `appE` lift x) $(lift =<< [|\x -> return x `appE` lift x|])|]
00:30:20 <mmorrow> (modulo cleaning up varnames)
00:30:27 <ksf> it's so plainly obvious it's hard to assume.
00:30:46 <mmorrow> how do you mean?
00:31:22 <ksf> ...that the more obvious something is, the harder it is to notice and therefore exploit.
00:31:51 <ksf> it's the essence of I ACCIDENTALLY WHEN IT DID NOT MAKE SENSE
00:32:05 <mmorrow> i agree, but i don't understand what you mean by " you don't have to care about a, anymore"
00:32:28 <ksf> a won't ever concern the type checker, in any way whatsoever.
00:32:49 <mmorrow> oh, because you've partially applied the function to an `a' already?
00:33:01 <ksf> hindley-milner is much better at forgetting things than humans.
00:33:04 <ksf> yeah.
00:33:08 <mmorrow> ah, i gotcha
00:34:29 <ksf> part of that seems to be my idosyncratic usage of "to curry", which seems to confuse everyone but me.
00:34:59 <ksf> possibly because I just imagine a chicken and currying it... that is, decorating it with a value.
00:35:08 <mmorrow> part of my confusion was not knowing if you meant partial app or the `curry' function
00:35:14 <ksf> the curry is gone, and the chicken changed.
00:35:15 <mmorrow> @type curry
00:35:17 <pumpkinbot> forall a b c. ((a, b) -> c) -> a -> b -> c
00:36:06 <ksf> I've never, ever used that one, only uncurry.
00:36:20 <mmorrow> @source > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in
00:36:20 <pumpkinbot> > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
00:36:35 <mmorrow> > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
00:36:37 <Gracenotes> functions return tuples more often than they ask for them :)
00:36:37 <pumpkinbot>   @source , let not = text . (++" in") . ap(++)show; available = "@source , l...
00:37:01 <ztirF> if I'm trying to decodeFile a big datafile, and I get a stack overflow, what's the best way to approach it?
00:37:10 <ksf> I've even written uncurry3 and uncurry4, once.
00:37:14 <mmorrow> yeah, curry is rare since functions usually don't take tuples
00:37:51 <mmorrow> ztirF: there's probably an accumulating parameter that isn't being kept "one-level-deep"
00:38:18 <mmorrow> (somwhere)
00:38:22 <mmorrow> (somewhere)
00:38:35 <ztirF> mmorrow: the encoded structure contains a big list.  That must be it, right
00:38:41 <ztirF> ?
00:39:16 <mmorrow> what's decodeFile looks like? is it a foldl or explicit recursion with an accumulating param or something?
00:39:38 <ztirF> it's in Data.Binary
00:39:42 <mmorrow> oh
00:39:44 <ztirF> I was hoping to use it as a black box
00:39:52 <ztirF> o well
00:39:53 <mmorrow> yeah, you should be able to
00:40:07 <mmorrow> hmm, could you paste a relevant snippet?
00:40:23 <ztirF> sure
00:40:29 <pumpkin> I'm going to sleep, don't forget to @part pumpkinbot if it gets on your nerves
00:40:30 <ztirF> @paste
00:40:30 <pumpkinbot> Haskell pastebin: http://hpaste.org/new
00:40:47 <ztirF> bah what's the new one called
00:40:55 <mmorrow> @where hpaste2
00:40:55 <pumpkinbot> I know nothing about hpaste2.
00:40:59 <mmorrow> moonpatio.com
00:41:10 <mmorrow> @where+ hpaste2 http://moonpatio.com
00:41:10 <pumpkinbot> It is forever etched in my memory.
00:42:01 <ksf> maybe someone should set up paste.haskell.org
00:42:37 <redditbot> Installing IPPrint, Haskell pretty-printing library
00:45:12 <mmorrow> ztirF: oh, i just realized that also since "the encoded structure contains a big list", the Binary instance for that type might be such that it has to see the end of the list before it returns any results, in which case the longest list you can decode'll be limited by the size of your stack
00:45:29 <ztirF> mmorrow: ahh, that makes a lot of sense
00:45:42 <mmorrow> so if that's the case, you might have to rewrite the Binary instance to be "online"
00:45:52 <ksf> ...which is also know as failure to tailrecurse.
00:46:01 <ztirF> so I should replicateM get or something like that ?
00:46:37 <ztirF> ksf: yeah, I would think that that get for [] would be written that way?
00:46:52 <mmorrow> hmm, that might do it. i'm not positive the usual strategy for this, but i know there is one/a way to do it
00:47:36 <beelsebob> dons: I hacked in a WordPress mode for HsColor – how's this for output? http://noordering.wordpress.com/2009/02/01/simulating-n-bodies-and-functional-programmingre/
00:47:36 <pumpkinbot> Title: Simulating n-bodies and functional programmingRe « No Ordering, http://tinyurl.com/btmbrx
00:47:56 <mmorrow> oh, i think you might have to encode the list as chunks of either a pre-specified size, or chunks with a "header" byte (or something) giving you the chunk length of that chunk
00:48:23 <mmorrow> but again i'm not positive how people usually do this
00:48:38 <ztirF> mmorrow: yuck.  Anyway here's the structure http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1099#a1099
00:49:15 <ztirF> I want to submit a patch Data.Binary so that it uses XDR to encode C-equivalent types
00:49:20 <ztirF> so doubles don't take 25 bytes
00:49:38 <mmorrow> whoa, doubles take 25bytes?!
00:49:42 <ztirF> they sure do
00:49:53 <ztirF> > length $ encode 1.0
00:49:54 <pumpkinbot>   mueval: Prelude.read: no parse
00:50:14 <beelsebob> It's awesome that wordpress thinks that spongebob squarepants pillows are related to the nbodies problem
00:50:19 <ztirF> > Data.Binary.ByteString.Lazy.length $ Data.Binary.encode 1.0
00:50:19 <pumpkinbot>   mueval: Unsafe functions to use mentioned.
00:50:25 <ztirF> bah
00:50:47 <mmorrow> ghci>  Data.ByteString.Lazy.length $ encode (1.0::Double)
00:50:47 <mmorrow> 25
00:51:01 <ztirF> that ticks me off a lot
00:51:14 <mmorrow> ztirF: that sounds like a sweet patch to me :)
01:15:12 <cnwdup> > runWriter (tell ["foo"] >> pass $ return ((), const ["baz"]))
01:15:14 <pumpkinbot>       No instance for (MonadWriter
01:15:14 <pumpkinbot>                         [[Char]] ((->) (Wr...
01:15:47 <cnwdup> > runWriter (tell ["foo"] >> pass (return ((), const ["baz"])))
01:15:49 <pumpkinbot>   ((),["foo","baz"])
01:16:02 <cnwdup> > runWriter (tell ["foo"] >> pass (return ((), mappend ["baz"])))
01:16:03 <pumpkinbot>   ((),["foo","baz"])
01:16:39 <cnwdup> Why's that the same? I would expect the result of the first would be ((), ["baz"])
01:18:40 <cnwdup> Ah, okay. Is there a way to modify the Writer's log variable?
01:18:50 <Gracenotes> cnwdup: according to trace, the argument passed is []
01:19:19 <cnwdup> Gracenotes, yes. I didn't think of what >> does there.
01:21:11 <Gracenotes> :t \x -> runWriter (tell ["foo"] >> pass x)
01:21:13 <pumpkinbot> forall a. Writer [[Char]] (a, [[Char]] -> [[Char]]) -> (a, [[Char]])
01:22:54 <Gracenotes> cnwdup: it might be a way of "inserting" another writer, probably? hm :/
01:23:17 <cnwdup> Gracenotes, not really because >> is concatenating (at least for lists) the w variable of both writers.
01:23:37 <mmorrow> cnwdup: use State?
01:23:45 <cnwdup> mmorrow, yes. I guess I have to.
01:24:40 <mmorrow> or you could define the Monoid instance to a custom type to be what you want (but State would probably be less of a hassle and more general)
01:25:29 <Gracenotes> I've never used pass or listen before, personally... what's the general idea about them?
01:28:01 <Gracenotes> > runWriter (tell (Sum 4) >> pass (return ((), const $ Sum 3) ))
01:28:03 <pumpkinbot>   ((),Sum {getSum = 7})
01:28:53 <Gracenotes> > runWriter (tell (Sum 4) >> pass (return ((), \(Sum x) -> (Sum x) mappend (Sum x+1)) ))
01:28:54 <pumpkinbot>   Couldn't match expected type `t1 -> t2 -> Sum t'
01:28:57 <Gracenotes> :X
01:29:14 <Gracenotes> > runWriter (tell (Sum 4) >> pass (return ((), \(Sum x) -> (Sum x) `mappend` (Sum x+1)) ))
01:29:15 <pumpkinbot>       No instance for (Num (Sum t))
01:29:16 <pumpkinbot>        arising from the literal `1' at <i...
01:29:40 <Gracenotes> jeez
01:29:42 <Gracenotes> > runWriter (tell (Sum 4) >> pass (return ((), \(Sum x) -> (Sum x) `mappend` (Sum $ x+1)) ))
01:29:44 <pumpkinbot>   ((),Sum {getSum = 5})
01:30:01 <mmorrow> i don't use Writer much myself either, but Saizan used it in a brainfuck interp (in the parser) in a cool way: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=839
01:30:02 <Gracenotes> > runWriter (tell (Sum 4) >> pass (return ((), \(Sum x) -> (Sum $ x+1)) ))
01:30:04 <pumpkinbot>   ((),Sum {getSum = 5})
01:31:38 <Gracenotes> haskell.org seems to be down.
01:32:00 <mmorrow> for me too
01:33:08 <jeffz`> it's not down, just slow
01:33:47 <Gracenotes> oh... it timed out a couple of times
01:33:56 <mmorrow> ah yeah, i can ping it
01:37:33 <vixey> @go Haskell Continuations Examples
01:37:34 <pumpkinbot> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
01:37:39 <vixey> no.....
01:41:49 <|jedai|> > runWriter ( pass $ tell ["foo"] >> return ((), const ["baz"])) )
01:41:50 <pumpkinbot>   mueval: Prelude.read: no parse
01:41:55 <vixey> :t callCC
01:41:56 <pumpkinbot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
01:42:10 <|jedai|> > runWriter ( pass $ tell ["foo"] >> return ((), const ["baz"]) )
01:42:12 <pumpkinbot>   ((),["baz"])
01:42:22 <|jedai|> > runWriter ( pass $ tell ["foo"] >> return ((), mappend ["baz"]) )
01:42:24 <pumpkinbot>   ((),["baz","foo"])
01:44:39 <mmorrow> lol
01:44:41 <mmorrow> "Implemented here is a thread pool library on crack."
01:44:47 <mmorrow> http://hackage.haskell.org/packages/archive/Control-Engine/0.0.2/doc/html/Control-Engine.html
01:44:48 <pumpkinbot> Title: Control.Engine, http://tinyurl.com/br5vec
01:44:57 <|jedai|> Gracenotes: The object of pass is to modify the writer log of it's argument (so it's only useful if there is a writer log different from mempty)
01:45:15 <Peaker> Is there any record TH thing or library that lets you define records and automatically get lens/accessors/frefs to the fields?
01:46:05 <mmorrow> Peaker:  i believe theirs data-accessor (name?) that'll gen some stuff for record updates
01:46:10 <Peaker> In Haskell', it could be nice, if record field names were Accessors to their fields rather than getters
01:46:11 <mmorrow> *there's
01:46:33 <Peaker> mmorrow: Data.Accessor is old, I can't use it (had to rewrite parts of it) because it depends on old "transformers" instead of "mtl"
01:46:39 <Peaker> At least that's what I figured :)
01:46:52 <mmorrow> what is "transformers" ?
01:46:53 <vixey> mmorrow, I give up on trying to implement type system atm :/
01:47:04 <|jedai|> Peaker: look for functional references maybe
01:47:16 <mmorrow> vixey: oh noes! what do mean by "implement"?
01:47:25 <vixey> in haskell
01:47:30 <Peaker> mmorrow: Its a conflicting package on hackage, like mtl
01:47:37 <Peaker> mmorrow: that afaik, only data.accessor uses in place of mtl
01:47:50 <Peaker> mmorrow: and I don't even need the transformers in there :(
01:47:58 <mmorrow> vixey: but do you have the idea/system sketched out wherever?
01:48:13 <|jedai|> Peaker: Anyway I doubt Haskell' will bring much change to records since nobody know which proposition to use (even though almost everyone believe the current state isn't satisfactory)
01:48:28 <mmorrow> vixey: like, is the only difficulty the actual implem of it in a prog lang (here, haskell), or the phrasing of it in the first place?
01:49:03 <vixey> mmorrow, was just going for CoC with beta-eta-pi conv, have been trying for ages to get a syntax directed version of the type rules but I dunno it's too hard
01:49:11 <Peaker> |jedai|: I'm not talking about fixing the record system -- only fixing the accessors so they aren't biased towards getting but allow setting as well
01:49:17 <Peaker> |jedai|: the record field names
01:49:26 <mmorrow> Peaker: hmm, i can't imagine the code for data.accessor is that huge. i bet it'd at least be a good place to start from to write the code to do what you want
01:49:29 <dibblego> joed?
01:49:29 <vixey> beta-eta is fine, but proof irrelevance is extremely non obvious
01:49:58 <vixey> mmorrow, I have a declarative spec. but I can't /run/ that
01:49:59 <mmorrow> vixey: hmm. what exactly is "proof irrelevance"?
01:50:00 <Peaker> mmorrow: I think I need TH -- how else can I overload the name of the field?
01:50:13 <mmorrow> Peaker: well yeah of course :)
01:50:24 <Peaker> mmorrow: I guess its a good oppurtunity to learn TH
01:50:32 <mmorrow> Peaker: exactly!! :)
01:50:40 <Peaker> this is horrible: (\newVBox model -> model{vboxModel=newVBox})
01:50:52 <Peaker> (for each field)
01:51:37 <mmorrow> Peaker: all of a sudden TH becomes extremely interesting when it can save you work/give you convenience
01:52:13 <Peaker> mmorrow: I wonder if I can get records to not create the getter at all, only the accessor
01:53:06 <vixey> mmorrow, when type checking you must check if types are equal sometimes (it's more than syntactic equality like haskell because you also have values, functions in types).. some objects are just proofs/witnesses of properties so the structure of those values shouldn't matter in terms of typechecking
01:53:49 <mmorrow> Peaker: if you had a function like (foo :: Q [Dec] -> ...) that you'd call like (foo [d|data A a = A {one :: ..., two :: ...}|]), you would is esssence be getting the syntax of that decl as input, and you could do anything you want with it, and return any type you wanted as well (including another data decl)
01:54:10 <mmorrow> Peaker: so yes, you could do that for sure
01:54:15 <mmorrow> vixey: /me reads
01:54:56 <vixey> anyway I can't get an algorithm for it which is disappointing so I got to do something else
01:55:24 <Peaker> mmorrow: but if my TH thing doesn't get rid of the record and keeps its field names - don't I have to also keep the name binding Haskell automatically creates for the field name as a getter?
01:55:27 <vixey> mmorrow, (it might sound a bit odd but it's pretty much essential for implementing pattern matching imo)
01:55:53 <vixey> you can do dependent pattern matching on a lot of objects without having it, but it's just awkward to do it that way
01:56:08 <mmorrow> vixey: doesn't type equality become just alpha or beta equality?
01:56:45 <vixey> mmorrow, in Coq alpha-beta, in Agda alpha-beta and a bit of weird added n stuff that doesn't make sense, in my prototype alpha-beta-eta
01:56:48 <mmorrow> Peaker: exactly, you'd spit out a NON-record data decl, plus whatever functions you want to do what you want
01:57:00 <vixey> mmorrow, so nobody implements a pi algorithm I can steal :p
01:57:20 <mmorrow> vixey: ah, ok. hmm i have to think for a sec about what eta equality means here
01:57:36 <Peaker> mmorrow: ah, I guess giving up the record "convenience" is a fair trade
01:57:46 <Peaker> mmorrow: (e.g if I do want to use record syntax anywhere)
01:58:03 <vixey> mmorrow (\x -> x) =beta-eta (\f x -> f x) : (P -> Q) -> (P -> Q)
01:59:06 <mmorrow> Peaker: yeah, unfortunately it'd have to be a trade-off
01:59:12 <vixey> so if you have id in one type, nd ($) in the other type.. they should be considered equal
01:59:25 <vixey> (you need that to prove the monad laws on Cont monad)
01:59:29 <vixey> for example
01:59:39 <mmorrow> hmm, interesting
02:00:06 <Peaker> mmorrow: Could rename the record fields to recordName' or something, so  blah'= would allow record-update or record-pattern-match syntax
02:00:32 <vixey> mmorrow, it would be a really nice lang. if I could just implement it :p
02:00:36 <mmorrow> vixey: i need to think about this for a bit until i really grok what it's saying
02:00:37 <vixey> I can't be the first to say that
02:00:42 <mmorrow> vixey: heh, don't give up!
02:00:53 <vixey> I kinda gave up
02:01:10 <vixey> I'm just waiting until someone writes a paper that describes the algorithm I want
02:01:15 <vixey> bc. I can't do that
02:01:30 <mmorrow> why not?
02:01:36 <vixey> it's too hard :p
02:02:10 <mmorrow> Peaker: yeah, that'd be an option. some systematic way wrt naming would be key
02:02:14 <Raynes> It's too harrrrrrddddddd. I don't wannnnnnaa. ;)
02:02:26 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1100#a1100 I'm trying to implement a lockable Writer monad. But I have trouble creating appropiate instances for monad transformers. Can anyone explain to me why the compile error is being reported?
02:02:45 <vixey> keep seeing stuff like maybe OTT solves this, or modal logic . or ..
02:03:09 <mmorrow> just think about the problem at hand, then phrase it in your own terms
02:04:55 <vixey> actually I will reread the constraint section in ATTAPL
02:05:43 <vixey> but yeah really just needs someone clever to turn this spec. into an algorithm
02:05:55 <mmorrow> ooh, i've got that book about too. i should dig it up, there's some good stuff in there
02:06:03 <vixey> yeah it's a great one
02:06:23 <vixey> mmorrow, oh on that note, you know lazy linear context splitting?
02:06:31 <vixey> (it's in like chapter 1 or something)
02:06:54 <vixey> I was wondering, is it possible to implement lazy context splitting using haskells built in lazyness?
02:07:30 <vixey> I thought probably not because there is this dependency there but I am often. wrong when I think something is impossible :)
02:16:51 <draco_> greetings
02:17:59 <draco_> in  ruby there is a nice app in which you can search through the documentation straight, for example if I want to know something about the string class I can search "ruby-doc String", is there anything similar in Haskell?
02:19:22 <mmorrow> Peaker: here's some TH stuff in ghci that i find extremely helpful http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1102#a1102
02:19:36 <Peaker> mmorrow: thanks
02:19:46 <Peaker> mmorrow: btw, clearly I should create a new name for the accessors rather than rename everything :)
02:19:58 <Peaker> mmorrow: something like 'a':fieldName would be fine :)
02:20:27 <mmorrow> Peaker: the basic strategy i use is: (1) use pretty/pprint on a made-up [||]/[d||]/etc to show me what i have to build, (2) build it. so you can just let TH show you examples of what you have to make
02:20:48 <mmorrow> vixeyL heh
02:20:52 <mmorrow> vixey: heh
02:21:23 <mmorrow> Peaker: yeah, a new name might be easiest (and least confusing)
02:21:58 <mmorrow> , (\name -> mkName (nameBase name ++ "A")) (mkName "foo")
02:21:59 <lunabot>  fooA
02:23:38 <mmorrow> Peaker: (oh, also that paste assumes the haskell-src-meta pkg (and by dependency thereof haskell-src-exts))
02:24:17 <mmorrow> , $(lift =<< reify ''Maybe)
02:24:18 <Peaker> mmorrow: Ok, I'll get to that today, hopefully, currently fixing other stuff in my widget set :)
02:24:18 <lunabot>  TyConI (DataD [] Data.Maybe.Maybe [a_1627417581] [NormalC Data.Maybe.Noth...
02:24:23 <mmorrow> , cleanNames $(lift =<< reify ''Maybe)
02:24:24 <lunabot>  TyConI (DataD [] Maybe [a_1627418279] [NormalC Nothing [],NormalC Just [(...
02:24:47 <mmorrow> Peaker: good luck, let me know if i can help :)
02:24:57 <Peaker> mmorrow: sure, thanks
02:27:28 <maltem> draco_: you mean, like a man command? I don't think anyone has written such a thing; people are typically browing html (haddock) docs
02:28:55 <maltem> draco_: otherwise you should know about hoogle and hayoo (in case you didn't yet)
02:30:50 <ray> lost my hayoo mail
02:32:49 <vixey> http://sigfpe.blogspot.com/2009/01/beyond-regular-expressions-more.html
02:32:50 <pumpkinbot> Title: A Neighborhood of Infinity: Beyond Regular Expressions: More Incremental String  ..., http://tinyurl.com/cway3a
02:32:57 <vixey> is cool...
02:35:00 <draco_> maltem: thanks
02:40:38 <zachk> so my mum passworded her windows machine, too bad she didnt password her bios gogoogo ubuntu livecd :D
02:41:05 <vixey> what
02:42:06 <zachk> i circumvented the windows password on a pc by going into bios and choosing boot from cdrom drive and i booted a linux livecd so i dont damage anything
02:42:39 <redditbot> First (real) Yesod commit (new Haskell web framework
02:42:40 <Gilly> well that was a very haskellian story *g*
02:42:50 <ray> at least this sentence *mentions* haskell
02:42:53 <vixey> wow your saying that you were able to use a machine you had physical access to? lol
02:43:14 <Peaker> funny after many design cycles, I ended up not using almost any ghc extensions at all (plenty when I started :) -- I am only using GeneralizedNewtypeDeriving for MonadTrans
02:43:28 <Peaker> Yesod = Hebrew for basis
02:43:42 <zachk> Teva = Hebrew for nature
02:44:01 <Peaker> zachk: are you Israeli?
02:44:41 <zachk> no but i believe one of my ancestors had a yiddish last name, klotz
02:44:56 <zachk> i just pick up words here and there from other languages
02:47:03 <Peaker> zachk: ah
02:48:52 <zachk> major ad: Teva sandals are AMAZING. if they still make the ones with spider rubber get them. you can walk on 3inches of melting ice without slipping
02:50:00 <ray> shopping for sandals is hard, let's go do some math
02:53:38 <Raynes> That's like saying "Hey, this is bad! Quick make it worse!
02:53:48 <Raynes> "
02:54:29 <asgaroth> Raynes: srsly? math by far beats shopping
02:54:45 <vixey> what are monads??
02:57:56 <kapil> vixey: a mathematical answer wanted?
02:58:55 <zachk> monads are warm fuzzy things that hide internal magic and give you nice clean syntax for using the magic
02:58:56 <NameAlreadyInUse> where is lambdabot today?
02:59:05 <Cale> vixey: They're monoid objects in the category of endofunctors and natural transformations on a given category.
02:59:14 <zachk> @vixen where is lamdabot
02:59:14 <pumpkinbot> I like to pick everything up and smell it... Its a fetish of mine... And i mean everything! Is that cool with you?
02:59:28 <Cale> NameAlreadyInUse: I couldn't log into the machine on which it runs
02:59:39 <NameAlreadyInUse> oh :#
03:00:07 <vixey> so they really are based on monoids?
03:00:32 <Cale> vixey: Well, a vast generalisation of monoids, but yes.
03:01:04 <NameAlreadyInUse> is there any alternative to lambdabot's @src feature, that i can use?
03:01:15 <Cale> A normal monoid is a set M with functions identity: 1 -> M (picks out the identity element), and multiply: M x M -> M
03:01:17 <kapil> the category of endofunctors has a monoidal structure so it is possible to define monoid objects in that category.
03:01:48 <Peaker> Yay, my widget set now has proxy widgets too, and a separate example that's starting to look clean :-)
03:01:49 <Cale> A monad is an endofunctor M with natural transformations return: 1 -> M, and join: M . M -> M
03:02:07 <Cale> and the laws they satisfy are analogous
03:02:11 <mmorrow> , ppDoc `fmap` (let fmaps n = let go n = foldr (|.|) [|fmap|] (replicate (n-1) [|fmap|]) in go n in fmaps 6)
03:02:12 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . fmap))))
03:02:28 * Peaker would love feedback from anyone who can cabal install sdl and sdl-ttf :-)
03:02:36 <vixey> what is the meaning of  1 -> M  for a Monad M?
03:02:46 <vixey> because I mean.. it seems like a kind error
03:02:54 <Cale> vixey: Well, we would write it  forall a. a -> M a
03:03:18 <vixey> so it's like  liftA2 (->) 1 M
03:03:19 <Cale> vixey: The arrows between functors are natural transformations, which in Haskell are realised by polymorphic functions.
03:03:45 <mmorrow> , $(let fmaps n = let go n = foldr (|.|) [|fmap|] (replicate (n-1) [|fmap|]) in go n in fmaps 6) (*2) [[[[[[0..3]]]]]]
03:03:47 <lunabot>  [[[[[[0,2,4,6]]]]]]
03:03:59 <mmorrow> hehe sweet
03:04:47 <mmorrow> , $(let fmaps n = let go n = foldr (|.|) [|fmap|] (replicate (n-1) [|fmap|]) in go n in fmaps 12) (*2) [[[[[[[[[[[[0..3]]]]]]]]]]]]
03:04:49 <lunabot>  [[[[[[[[[[[[0,2,4,6]]]]]]]]]]]]
03:05:35 <vixey> is there some relation from identity/multiply -> return/join .. and map?
03:05:55 <Cale> vixey: Well, fmap is required for M to be a functor.
03:05:58 <araujo> morning
03:06:11 <Cale> So it's just part of the structure of that given category in which we're finding the monoid object.
03:12:05 <mmorrow> @pl (\u -> app u (q u)) (q (\u -> app u (q u)))
03:12:07 <pumpkinbot> ap app q (q (ap app q))
03:12:27 <mmorrow> , ap(++)show"ap(++)show"
03:12:28 <lunabot>  "ap(++)show\"ap(++)show\""
03:12:50 <mmorrow> , let (<<$>>) = dynApp in (\x -> x <<$>> toDyn x) (toDyn (\x -> x <<$>> toDyn x))
03:12:52 <lunabot>  <<Dynamic>>
03:14:24 <mmorrow> the String one is kinda slightly "odd", since (show (ap(++)show) /= "ap(++)show")
03:15:30 <mmorrow> but i guess that's just confusing the underlying concept here with the haskell one
03:15:37 <mmorrow> (or something)
03:18:47 <NameAlreadyInUse> is there source code for the Array module?
03:18:54 <NameAlreadyInUse> that i can have a look at?
03:19:29 <mmorrow> http://darcs.haskell.org/libraries/base/
03:19:31 <pumpkinbot> Title: Index of /libraries/base
03:19:41 <Cale> NameAlreadyInUse: In GHC, there is...
03:19:49 <mmorrow> not sure which array lib you're looking for, but
03:19:50 <mmorrow> http://darcs.haskell.org/libraries/base/GHC/Arr.lhs
03:19:57 <mmorrow> is the lowest level
03:20:09 <Cale> NameAlreadyInUse: Arrays are kind of partly wired in, so it's not exactly the easiest stuff to read.
03:20:31 <Cale> (they're something you'd consider a language primitive)
03:20:32 <mmorrow> then there's http://darcs.haskell.org/libraries/array/
03:20:35 <pumpkinbot> Title: Index of /libraries/array
03:20:56 <Cale> Though I suppose there's a possible implementation in terms of the FFI stuff.
03:21:20 <Cale> (but there's a possible implementation of almost anything in terms of the FFI stuff ;)
03:21:24 <mmorrow> yeah definitely, you can always use a Ptr a + peek and plusPtr
03:21:32 <mmorrow> (and poke ..)
03:21:40 <mmorrow> Cale: heh, true
03:26:25 <mmorrow> , ap(dynApp)(toDyn)(toDyn(ap(dynApp)(toDyn)))
03:26:26 <lunabot>  <<Dynamic>>
03:27:13 <mmorrow> , foldr (.) id (replicate 1000 (fromJust . fromDynamic)) $ ap(dynApp)(toDyn)(toDyn(ap(dynApp)(toDyn)))
03:27:15 <lunabot>  <<Dynamic>>
03:27:17 <mmorrow> , foldr (.) id (replicate 100000 (fromJust . fromDynamic)) $ ap(dynApp)(toDyn)(toDyn(ap(dynApp)(toDyn)))
03:27:18 <lunabot>  <<Dynamic>>
03:31:51 <NameAlreadyInUse> what does the '!' mean in "= Array !i"?
03:32:04 <mmorrow> , ap(|$|)(lift=<<) [|ap(|$|)(lift=<<)|]
03:32:05 <lunabot>  AppE (AppE (AppE (VarE ap) (VarE |$|)) (InfixE (Just (VarE lift)) (VarE =...
03:32:41 <mmorrow> NameAlreadyInUse: it means that that value is strict, ie always kept one-level-deep thunkwise
03:34:35 <Cale> NameAlreadyInUse: Just in case, at the value level, there's also an operator ! defined by the array library which is array indexing.
03:34:56 <Cale> If a is an array, and i is an index for a, then a ! i is the value of the array at that index.
03:37:10 <NameAlreadyInUse> Cale: yeah, i understand
03:37:40 <NameAlreadyInUse> what about the '#' sign in "Array#", does that refer to foreign code or something?
03:40:03 <Cale> It's usually used to indicate low-level and unboxed stuff.
03:40:54 <Cale> (just a convention, for the most part -- there's an extension needed to allow # in names though)
03:41:54 <NameAlreadyInUse> so it doesn't have a real meaning like '!' does?
03:42:05 <Cale> right
03:42:44 <draco_> I'm just starting out learning Haskell, I do have some previous experience in lisp, anyhow, I'm looking for laborations/exercises that I can do to learn haskell
03:43:31 <NameAlreadyInUse> and finally, in the source there is an "Array" data constructor defined, but if i do "import Array" in ghci, there is no Array data constructor in scope. how does that work?
03:43:48 <vixey> draco_, you could just choose a program you would use and then write it
03:44:58 <Baughn> @type fix
03:45:08 <draco_> vixey: heh, I guess so
03:45:27 <lilac> NameAlreadyInUse: "import Array" imports the module named Array along with all of its exports
03:45:43 <Cale> NameAlreadyInUse: the Array constructor isn't exported
03:45:50 <lilac> NameAlreadyInUse: presumably the module Array doesn't export a data constructor named Array
03:45:55 <camio> cixey: Sheesh, I'd imagine the problem someone comes up with will have an imperative bias.
03:46:35 <lilac> NameAlreadyInUse: module Array (Array(Array), ...) where
03:46:37 <NameAlreadyInUse> so it is possible to export the data type "Array", but not the data constructor?
03:46:45 <lilac> yes
03:46:57 <lilac> that's how encapsulation is achieved in Haskell
03:47:38 <kapil> draco_, have a look at the problem sets of project euler.
03:48:26 <pumpkinbot> forall a. (a -> a) -> a
03:49:13 <draco_> kapil: good idea :)
03:50:27 <Cale> In fact, almost the only means of encapsulation Haskell has is via the module system.
03:50:46 <Cale> I suppose you might be able to count parametric polymorphism too, to some extent.
03:51:21 <mmorrow> , [$ty| fix |]
03:51:23 <lunabot>  forall a . (a -> a) -> a
03:52:52 <lilac> > typeOf fix
04:01:52 <Peaker> ghc doesn't seem to complain about unnecessary data constructor imports
04:04:14 <pumpkinbot>   Add a type signature
04:04:47 <Peaker> "ghc doesn't seem to complain about unnecessary data constructor imports" :: String
04:05:17 <Heffalump> ghc's warnings are generally quite broken
04:05:20 <augustss> lol
04:08:30 <Peaker> so, does anyone want to give me some feedback about the code/functionality of a cool (currently keyboard-only) purely functional widget set?
04:10:28 <Peaker> I think maybe instead of data/newtype distinction, Haskell should get a type-product/multi-constructor type distinction
04:10:51 <Peaker> So generally, type products shouldn't introduce new bottoms (The newtype restriction of just one field just makes people wrap with tuples?)
04:15:20 <NameAlreadyInUse> is there some easy way to turn [x, y, z, ...] into [(1, x), (2, y), (3, z), ... ]?
04:15:56 <lilac> NameAlreadyInUse: yep. zipWith (,) [1..]
04:16:19 <lilac> > zipWith (,) [1..] [x,y,z] :: [(Int,Expr)]
04:16:26 <Deewiant> zip = zipWith (,)
04:16:32 <NameAlreadyInUse> cool
04:16:36 <Deewiant> , zip [1..] [x,y,z]
04:16:38 <NameAlreadyInUse> i wasn't actually sure what zipWith did
04:16:39 <lunabot>  [(1,x),(2,y),(3,z)]
04:16:52 <lilac> Deewiant: duh :)
04:21:08 <Peaker> Deewiant, lilac: Maybe that's a good reason to get rid of "zip" and rename zipWith zip :)
04:23:13 <Saizan_> ?bot
04:23:25 <Peaker> @bot
04:23:26 <lunabot>  :)
04:26:10 <alans> I don't understand how (flip id) works - why is it the same as (/a b -> b a)? I expect flip to take a (a->b->c) argument
04:26:14 <pumpkinbot> :)
04:26:14 <pumpkinbot> :)
04:26:16 <pumpkinbot>   [(1,x),(2,y),(3,z)]
04:27:03 <vixey> alans,
04:27:10 <vixey> id :: forall a. a -> a
04:27:20 <icqn> > putStrLn $ map Data.Char.toUpper "abcäöüxyz"
04:27:27 <vixey> flip :: forall x y z. (x -> y -> z) -> (y -> x -> z)
04:27:38 <vixey> when you write:  flip id
04:27:54 <vixey> then a -> a is unified with x -> (y -> z), which results in:
04:28:14 <vixey> {a = y -> z, x = y -> z}
04:28:57 <icqn> Is bot lost in space?
04:29:05 <Deewiant> evidently
04:29:08 <Deewiant> luna's here though
04:29:10 <Raevel> @bot
04:29:10 <vixey> so it's   (flip :: (y -> z) -> (y -> z)) -> (y -> (y -> z) -> z)) (id :: (y -> z) -> (y -> z)) :: y -> (y -> z) -> z
04:29:10 <lunabot>  :)
04:29:33 <vixey> alans, I wonder I missed out anything important ?
04:29:38 <vixey> about how that works
04:29:53 <pumpkinbot>  mueval: *** Exception: "<IO ()>"
04:30:21 <pumpkinbot> :)
04:30:48 <alans> vixey, thanks - I think that makes sense, I'll check it out with pencil & paper
04:30:56 <Peaker> alans: basically, ($)=id, ($) just has a more specialized type.   The type of ($) is (a -> b) -> a -> b   which is the same as  (a -> b) -> (a -> b)     note that ($) doesn't really "do" anything to its input (a->b), just returns it
04:32:21 <vixey> alans, the relevant type rule is: gamma |- f :: a -> b;  gamma |- x :: a';  unify(a, a') ==> gamma |- f x :: b
04:32:59 <jrx> hi everyon, do you know why there is Endo monoid defined in Prelude, but nothing as: http://codepad.org/VJll4J8r ?
04:33:21 <Cale> jrx: You mean in Data.Monoid?
04:33:30 <jrx> Cale: yep
04:34:00 <Cale> ah, there's no good reason that's not defined there. I suppose nobody thought of it.
04:34:12 <vixey> there is a monoid for every monad
04:34:15 <vixey> :L
04:34:18 <zachk> cale: what is an endo monoid
04:34:59 <Cale> zachk: Well, the Endo monoid in Data.Monoid is functions a -> a with composition as the operation.
04:35:36 <Cale> I suppose if you want to generalise that, you can take a category C, and any object A in C, and the arrows A -> A form a monoid under composition.
04:35:50 <Cale> (the endomorphisms of A)
04:36:25 <zachk> so its a "warm fuzz thing" that goes back to itself, but not like an identity
04:36:26 <Peaker> @type abs
04:36:26 <jrx> I guess it can be abstracted using classes defined in Control.Arrow
04:36:58 <icqn> Is there a function in the library, which is able to upper characters like öäü?
04:36:59 <vixey> what's the name of (0,+) (1,*) (id,(.)) ("",++) ...
04:37:04 <Peaker> Cale: what happened to lambdabot?
04:37:16 <Cale> Peaker: I can't log into the machine on which it runs.
04:37:44 <zachk> vixey: monoid??
04:38:53 <icqn> PeakerLambda > putStrLn $ map Data.Char.toUpper "abcäöüxyz"
04:38:56 <icqn> :-P
04:39:42 <jrx> a function in the library, which is able to upper characters like öäü?
04:39:53 <jrx> http://codepad.org/zFkNznBZ
04:39:54 <Cale> The main problem with äöü, etc is that they're encoded as more than one byte in UTF-8, so you need a UTF-8 encoding library to handle them
04:40:02 <jrx> sorry, bad paste
04:40:04 <Cale> Otherwise, I think toUpper etc. should work.
04:40:19 <Peaker> > putStrLn $ map Data.Char.toUpper "abcäöüxyz"
04:40:20 <PeakerLambda>   * Exception: "<IO ()>"
04:40:28 <Cale> > map Data.Char.toUpper "abcäöüxyz"
04:40:29 <PeakerLambda>   "ABC\196\214\220XYZ"
04:40:47 <Peaker> Cale: why this exception? Does lambdabot not prevent IO execution by default or something?
04:40:55 <Cale> Peaker: I have no idea.
04:41:29 <Cale> Peaker: I haven't bothered to investigate. It really should just be <IO ()>
04:41:30 <hackage> Uploaded to hackage: djinn 2009.2.1
04:42:04 <Peaker> Cale: hopefully this is not some insane security breach by default :)_
04:42:14 <Cale> It's not in any case.
04:42:23 <icqn> Cale, toUpper seems to ignore ü, so it does not turn it to Ü.
04:42:32 <Cale> icqn: interesting.
04:42:43 <vixey> @hackage djinn
04:42:43 <PeakerLambda> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/djinn
04:43:21 <vixey> how do you find out what's new?
04:44:21 <pumpkinbot> forall a. (Num a) => a -> a
04:44:21 <pumpkinbot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/djinn
04:44:25 <PeakerLambda> Title: HackageDB: djinn-2009.2.1
04:45:07 <icqn> jrx, Why do you write my question by the way?
04:45:34 <pumpkinbot>   "ABC\196\214\220XYZ"
04:45:35 <pumpkinbot>  Terminated
04:45:36 <pumpkinbot> Title: HackageDB: djinn-2009.2.1
04:45:45 <jrx> icqn: just X11 pasted it for me instead of what I wanted ;)
04:45:52 <Saizan> err, we should have only one bot at a time :)
04:45:53 <Cale> Here, ö comes out as "\195\182"
04:46:11 <Cale> So map toUpper is not going to do anything sensible to that.
04:46:18 <Saizan> (lambdabot's admins can make pumpkinbot part)
04:46:43 <blazzy> does the sequence function immediately evaluate the entire list?
04:47:36 <Cale> blazzy: No.
04:48:03 <vixey> you can use sequence with an infinite list in IO
04:48:10 <icqn> Cale, So, there is not toUpper with a wide character/utf-8/etc. support
04:48:24 <vixey> but in e.g. Maybe.. it has to look through the whole thing to see if there is a Nothing before returning
04:48:38 <Deewiant> icqn: I think there's one somewhere on hackage
04:48:39 <Cale> icqn: I was sort of hoping that the usual one would support unicode straightforwardly so long as the Char values were the right ones.
04:49:17 <blazzy> well i guess that's not why my program is hanging.
04:49:21 <Deewiant> ah, right, never mind, it's the literals that're wrong
04:49:58 <Deewiant> > toUpper (chr 0xe4)
04:50:00 <PeakerLambda>   '\196'
04:50:11 <Deewiant> yeah, that's right
04:51:00 <Peaker> unicode support is about more than supporting a bunch more codepoints than ascii, though
04:51:11 <Peaker> (and encodings)
04:51:21 <Peaker> new control characters, bidirectional text, and other horrors also exist
04:51:29 <dcoutts> @seen mriou
04:51:29 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
04:51:37 <Deewiant> preflex: seen mriou
04:51:37 <preflex>  mriou was last seen on #haskell 5 hours, 30 minutes and 6 seconds ago, saying: how do I make it available (I've tried register)?
04:51:51 <Peaker> As a Hebrew speaker, I'd prefer to reverse Hebrew's direction than suffer through the Bidi hell.. it would probably take a few months to get used to, but its worth it
04:51:55 <Deewiant> Peaker: well, depends on what you're doing
04:52:01 <mmorrow> vixey: i just snaked the fixity parsing function from Parsek, which in turn snaked it from Parsec ==> fixity parsing with ReadP with the parsec interface: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1104#a1104
04:52:23 <Deewiant> if all you have to do is manipulate bytes then you don't have to worry about bidirectional text and control characters
04:52:26 <mmorrow> (Parsek is http://www.augustsson.net/Darcs/Parsek/)
04:52:28 <PeakerLambda> Title: Index of /Darcs/Parsek
04:52:34 <Deewiant> if you have to put something on screen, then yes, of course.
04:53:41 <mmorrow> (infixP === buildExpressionParser, but i couldn't stand the length of that name ;)
04:53:59 <Botje> parsek?
04:54:03 <Botje> that reminds me of dalek :P
04:54:12 <mmorrow> heh
04:54:25 <mmorrow> ReadP is a specialized Parsek essentially
04:54:59 <Botje> what, no EXTERMINATE?
04:55:02 <Botje> boo :)
04:55:37 <dancor> ghc 6.10.1 on debian i386 is saying: /bin/sh: /home/danl/i/hs/ghc/ghc-6.10.1/libraries/cabal-bin: No such file or directory
04:55:44 <mmorrow> Botje: yes that too
04:55:49 <dancor> the install for ghc 6.10.1 is saying that
04:56:03 <dancor> it was also complaining about not being able to execute 'pwd'
04:56:38 <|jedai|> mmorrow: what's the difference between Parsek and Parsec ?
04:56:56 <Cale> "WE ARE PARSEKS... YOU WILL PROVIDE INPUT! INNNPUT!!!"
04:57:18 <dancor> description: Parsek is a parsing library compatible with Parsec, but with an commutative <|> operator.
04:57:29 <mmorrow> |jedai|: parsec searches depth-first, which parsek/readp does breadth-first
04:57:29 <dancor> Parsecomm
04:57:54 <mmorrow> so, among other differences, (+++)/(<|>)/whatever is commutative
04:57:55 <|jedai|> thanks
04:58:25 <mmorrow> s/which/while/ parsek does ...
04:58:41 <lilac> does that mean ambiguity gives a parse error in parsek?
04:58:54 <mmorrow> you can get multiple results
04:59:13 <mmorrow> and choose among them. e.g. first result, longest result, ...
04:59:15 <lilac> ah, so it's only commutative up to reordering of the results
04:59:42 <mmorrow> p +++ q    will return both if they both succeed, and which is first depends on which is shorter
05:00:02 <mmorrow> but if one fails and one succeeds, you'll get the one that succeeds
05:00:55 <mmorrow> but commutative in the sense that
05:01:02 <lilac> in '(char 'x' >> return a) +++ (char 'x' >> return b)', the order of results must depend on the way round you put the arguments, no?
05:01:04 <mmorrow> p +++ q === q +++ p
05:01:14 <mmorrow> no
05:01:16 <dancor> i need to manip php code for work (groan), what is the most reasonable way to parse php in haskell
05:01:26 <mmorrow> (no it doesn't depends on order of args)
05:01:32 <lilac> mmorrow: how can parsek deterministically order them?
05:01:32 <dancor> they have a yacc parser in the php distro
05:02:13 <mmorrow> lilac: oh, in that particular case it'll order them however it's coded in the mplus instance
05:02:18 <dancor> i wish the yaxx project were actually maintained
05:02:33 <lilac> mmorrow: right. so it's not /quite/ commutative :)
05:02:43 <dancor> is it absurd to try to manipulate a yacc grammar into like a parsec grammar
05:03:18 <pumpkinbot> I saw mriou leaving #haskell 4h 58m 2s ago, and .
05:03:19 <Cale> Prelude Codec.Binary.UTF8.Light Data.ByteString System.IO> Data.ByteString.putStrLn . encode . Prelude.map Data.Char.toUpper . decode =<< Data.ByteString.getLine
05:03:19 <Cale> öäü
05:03:19 <Cale> ÖÄÜ
05:03:20 <mmorrow> well, there's no a-priori structure you're putting the results in, so you could easily account for that fact if you realllllly wanted to
05:03:29 <dancor> or i could manipulate their yacc parser into a c program that generates a parse tree
05:03:32 <lilac> dancor: you're planning on writing a source->source transformation on the php?
05:03:37 <dancor> lilac: yes
05:03:48 <Cale> So toUpper works, you just need something to handle the encoding/decoding of non-ascii characters correctly.
05:04:11 <dancor> php has a built-in lexer, so that part's easy
05:04:29 <dancor> i wonder how close the output of their yacc grammar is going to be to what i want to manipulate anyway
05:04:35 <dancor> ast
05:04:50 <mmorrow> lilac: but that example i would call not very admissible, because it would more sanely be programmed:
05:04:56 <nothingmuch> blah... i have a multithreaded curl fetcher thing, and once i override the WriterFunction i start getting zombie thread errors. what does "zombie thread" mean? it threw some error and I didn't catch it?
05:05:03 <mmorrow> (char 'x' >> return (a,b))
05:05:26 <vixey> p +++ q === q +++ p
05:05:28 <vixey> means
05:05:39 <vixey> p +++ q =permutation q +++ p
05:05:45 <pumpkinbot>   '\196'
05:05:49 <lilac> mmorrow: the 'real' example would be in, say, C++, where you could parse the same sequence of tokens in two different ways (say, as an expression statement or as a definition)
05:05:51 <vixey> or think of [a] is a bag of a's
05:05:54 <pumpkinbot> Title: Index of /Darcs/Parsek
05:05:57 <vixey> actually that's wrong still
05:06:07 <vixey> run (p +++ q) input =permutation run (q +++ p) input
05:06:23 <blazzy> why does this result in a stack overflow?  http://pastebin.com/m12c1df4d
05:06:54 <lilac> also, if the parser returns infinitely many results, the order presumably matters
05:06:57 <mmorrow> lilac: ok,   (someSpecificSeqP >> return (a::Exp,b::Foo,c::Decl))
05:07:14 <mmorrow> lilac: but since it's /breadt-first/, you'll reach /any/ result in finite time
05:07:52 <dancor> unless there's infinite-degree branching :2
05:08:06 <mmorrow> (unless you do something like      choice (repeat (char 'x'))
05:08:08 <mmorrow> )
05:08:36 <mmorrow> dancor: exactly
05:08:51 <dancor> in that case you would need to do like crazy cantor pairing to get all-finite-finds?
05:09:28 <dancor> the cantor pairing of breadth and depth
05:09:47 <mmorrow> i'm not sure, but that'd be interesting to know what you'd do
05:10:03 <mmorrow> have you seen that "search infinite spaces in finite time" stuff
05:10:06 <mmorrow> ?
05:10:09 <dancor> oh ya
05:10:13 <vixey> infinite branching trees are still countable aren't they?
05:10:15 <mmorrow> i wonder if that's related
05:10:20 <dancor> that has to do with like computable noncountablitily or something
05:10:23 <mmorrow> vixey: sure
05:10:34 <dancor> but could still apply
05:11:36 <vixey> I want to program something :/
05:11:51 <dancor> vixey: solve this infisearch problem
05:12:50 <dancor> i may just reproduce the php grammar and hate myself as i do it
05:13:35 <mmorrow> hehe
05:14:02 <Raevel> php's grammar may turn out to be ambiguous!?
05:14:13 <dancor> or infinite
05:14:19 <vixey> I was thinking of prototyping a language that is basically haskell + type level lambda
05:14:20 <vixey> +I mena
05:14:25 <vixey> GADTs + type lambda
05:14:28 <dancor> it will probably feel that way, by the time i get to the phpoo constructs
05:14:29 <vixey> using lambda prolog
05:15:22 <vixey> because I think you can internalize the languages type system if you have that
05:18:28 <dancor> has anyone recently had luck with the "Generic i386 Linux for libedit2/Debian" ghc 6.10.1 tarball
05:18:43 <dancor> i'm starting to think it's wack
05:21:07 <blazzy> if I try to bind an infinite sequence to a function, does the sequence get evaluated in its entirety first?
05:21:08 <mmorrow> , readP_to_S (string (repeat '!') +++ (:[]) `fmap` char '!') (repeat '!')
05:21:09 <lunabot>  [("!","!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
05:22:00 <daf> dancor: there are packages for Debian in experimental
05:22:41 <mmorrow> , ((take 1 . fmap fst .) . readP_to_S) (string (repeat '!') +++ (:[]) `fmap` char '!') (repeat '!')
05:22:42 <lunabot>  luna: The operator `GHC.Base..' [infixr 9] of a section
05:23:05 <mmorrow> , (\p -> take 1 . fmap fst . readP_to_S p) (string (repeat '!') +++ (:[]) `fmap` char '!') (repeat '!')
05:23:06 <lunabot>  ["!"]
05:24:36 <vixey> , (\p -> fmap fst . readP_to_S p) (string (repeat '!') +++ (:[]) `fmap` char '!') (repeat '!')
05:24:42 <lunabot>  Killed.
05:24:47 <scook0> @pl \x->x
05:24:47 <mmorrow> , readP_to_S (choice (fmap (\n -> string . take n . repeat '!') [1..])) (repeat '!')
05:24:47 <PeakerLambda> id
05:24:47 <NameAlreadyInUse> what sort of types can be used as Ixs?
05:24:48 <lunabot>  luna: Couldn't match expected type `a -> [a1]'
05:24:58 <scook0> @pl \f -> takeWhile (not . f)
05:24:58 <PeakerLambda> takeWhile . (not .)
05:24:59 <mmorrow> , readP_to_S (choice (fmap (\n -> string . take n . repeat $ '!') [1..])) (repeat '!')
05:25:03 <lunabot>  Stack space overflow: current size 8388608 bytes.
05:25:03 <lunabot>  Use `+RTS -Ksize' to increase it.
05:25:19 <mmorrow> , fmap fst . take 10 . readP_to_S $ (choice (fmap (\n -> string . take n . repeat $ '!') [1..])) (repeat '!')
05:25:20 <lunabot>  luna: Couldn't match expected type `[a]'
05:26:55 <mmorrow> hmm, maybe it could do infinite branching if it produced result w/in each level incrementally rather than all at once
05:26:58 <mmorrow> (or something)
05:27:27 <mmorrow> , fmap fst . take 1 . readP_to_S $ (choice (fmap (\n -> string . take n . repeat $ '!') [1..])) (repeat '!')
05:27:28 <lunabot>  luna: Couldn't match expected type `[a]'
05:27:31 <vixey> mmorrow, probably easy with a computation monad
05:28:08 <mmorrow> hmm
05:28:30 <dancor> daf: ah nice worked
05:32:21 <beelsebob> @where hpastetwo
05:32:22 <PeakerLambda> I know nothing about hpastetwo.
05:32:32 <dancor> @where hpaste2
05:32:32 <PeakerLambda> I know nothing about hpaste2.
05:32:32 <draco_> I have a function fn, "fn n x = if (n `rem` x) == 0 then True else False", shouldn't it be possible to make it shorter? (removing the "then True else False" somehow)
05:32:39 <mmorrow> vixey: i think you could do it with   data Step a = Done | One a (ReadP (Step a))
05:32:42 <Olathe> jrx: I think I understand why it does the readFile first in that example from yesterday. <- means to either get the data on the right or to fail without evaluating anything after it in the do block if the right has failed.
05:32:45 <vixey> draco_, yes
05:33:01 <dancor> beelsebob: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
05:33:05 <lilac> draco_: fn n x = (n `rem` x) == 0
05:33:06 <beelsebob> yep, just got it :)
05:33:15 <beelsebob> anyone here tried to build SDL-ttf on OS X?
05:33:16 <vixey> n `rem` x == 0
05:33:17 <Olathe> jrx: So, if the readFile fails, it doesn't get to the putStrLn stuff.
05:33:18 <beelsebob> I get this... http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1105#a1105
05:33:18 <draco_> ah thanks
05:33:24 <lilac> @pl n x -> n `rem` x == 0
05:33:24 <vixey> btw 'fn' is a bad name
05:33:24 <PeakerLambda> (line 1, column 5):
05:33:24 <PeakerLambda> unexpected ">" or "-"
05:33:24 <PeakerLambda> expecting variable, "(", operator or end of input
05:34:18 <lilac> @unpl ((==0).).rem
05:34:18 <PeakerLambda> (\ e h -> (rem e h) == 0)
05:34:38 <vixey> @let zero = ((==0) .)
05:34:40 <PeakerLambda>  Defined.
05:34:41 <vixey> :t zero
05:34:42 <PeakerLambda> forall a b. (Num b) => (a -> b) -> a -> Bool
05:35:11 <vixey> :t zero . rem
05:35:12 <PeakerLambda> forall a. (Integral a) => a -> a -> Bool
05:35:20 <dancor> @where+ hpastetwo http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
05:35:20 <PeakerLambda> Done.
05:35:24 <dancor> @where+ hpaste2 http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
05:35:24 <PeakerLambda> Done.
05:35:32 <pumpkinbot> id
05:35:48 <vixey> :t rem
05:35:49 <PeakerLambda> forall a. (Integral a) => a -> a -> a
05:36:13 <vixey> I don't see how that works at all
05:36:46 <beelsebob> :t zero . rem
05:36:47 <PeakerLambda> forall a. (Integral a) => a -> a -> Bool
05:37:00 <vixey> @undef
05:37:08 <beelsebob> vixey: think of (.) as a unary function
05:37:14 <vixey> @let zero f = (0 ==) . f
05:37:15 <PeakerLambda>  Defined.
05:37:17 <beelsebob> better yet, think of it as `fmap`
05:37:30 <pumpkinbot> thread killed
05:37:40 <vixey> :t zero . mod
05:37:41 <PeakerLambda> forall a. (Integral a) => a -> a -> Bool
05:37:43 <pumpkinbot> Plugin `eval' failed with: thread killed
05:37:51 <Cale> Thinking of (.) as fmap is genuinely useful.
05:37:56 <beelsebob> indeed
05:38:07 <vixey> fmap f m = \o -> f (m o)
05:38:29 <vixey> :t let fmap f m = \o -> f (m o) in fmap
05:38:30 <PeakerLambda> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
05:38:48 <pumpkinbot> takeWhile . (not .)
05:39:07 * beelsebob wonders what pumpkinbot is up to
05:39:19 <jrx> Olathe: hi
05:39:20 --- mode: ChanServ set +o Saizan
05:39:24 --- kick: pumpkinbot was kicked by Saizan (Saizan)
05:39:29 <beelsebob> > text "penis" -- I wonder how delayed he is
05:39:30 <PeakerLambda>   penis
05:39:34 <draco_> hmm, is the "cabal" system pretty new?
05:39:41 <jrx> Olathe: exactly
05:39:45 --- mode: Saizan set -o Saizan
05:39:59 <dcoutts> draco_: some bits are new some older
05:40:15 <jrx> Olathe: if the IO was lazy enough it could postpone opening of file to the point it it used
05:40:34 <draco_> okay, is it suppose to handle dependencies (ie installing them if needed)?
05:41:00 <dcoutts> draco_: the 'cabal' program does that yes
05:42:05 <draco_> ok
05:42:40 <redditbot> Simulating n-bodies and functional programming
05:46:14 <beelsebob> oh, someone redited it?
05:46:19 <beelsebob> neat :)
05:48:19 <Olathe> jrx: No, I mean that it has to be used there, since the do notation needs to know whether that line has failed before evaluating the part on a line after it where it seems that it's used.
05:50:36 <Olathe> jrx: To be lazy, the line where it seems that it's really used should be evaluated only if the <-s previously haven't failed, so it evaluates the failure first.
05:51:07 <Olathe> jrx: So, it's lazy, it's just using a different evaluation ordering than you'd expect.
05:53:23 <Olathe> Like with the Maybe monad. If you have readsAFileGivesAMaybe >>= \Just x -> if fileExists then doStuffWith x else ""
05:53:57 <Olathe> In order to do >>=, it has to figure out if the input is a Nothing or a Just.
05:54:08 <Olathe> It does that before checking if the file exists.
05:58:22 <dancor> there are a lot of things on http://hackage.haskell.org/packages/archive/pkg-list.html#cat:web.  is happs not where-it's-at anymore?
05:58:24 <PeakerLambda> Title: HackageDB: packages by category
05:58:53 <hsuh> dons: ftr, result links are 404 here http://code.haskell.org/nobench/
05:58:54 <PeakerLambda> Title: nobench : benchmarking Haskell implementations
06:00:07 * maltem discovers that literate Haskell programming gets considerably more attractive if using markdown formatting and marking code by indentation instead of '>'
06:02:20 <Saizan> dancor: what do you mean?
06:02:44 <dancor> Saizan: i'm just wondering where most of the popularity for webapp-making is these days
06:03:02 <dancor> is it with happs or lighter-weight stuff like salvia and janus etc
06:04:15 <jrx> Olathe: well not exactly
06:04:41 <jrx> Olathe: currently (I think) file is opened when you call readFile but it's not read
06:05:32 <jrx> Olathe: if the error happens during reading file, it appers where the reading is performed (ahead of call to readFile, something might be in between)
06:08:02 <jrx> Olathe: so in fact opening of file which fails in case file does'nt exist, can be also delayed in the same lazy way
06:08:30 <jrx> Olathe: which for example putStrLn can't (because it would be useless)
06:12:30 <mmorrow> , $(fmaps 0) (*2) 2
06:12:32 <lunabot>  4
06:12:40 <mmorrow> , $(fmaps 12) (*2) [[[[[[[[[[[[0..3]]]]]]]]]]]]
06:12:42 <lunabot>  [[[[[[[[[[[[0,2,4,6]]]]]]]]]]]]
06:12:56 <mmorrow> , ppDoc `fmap` fmaps 6
06:12:58 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . fmap))))
06:13:17 <mmorrow> , ppDoc `fmap` fmaps 0
06:13:19 <lunabot>  id
06:13:21 <mmorrow> , ppDoc `fmap` fmaps 1
06:13:23 <lunabot>  fmap
06:14:39 <jrx> Olathe: see that http://codepad.org/dhBkRgzI
06:14:46 <jrx> Olathe: it works perfectly
06:15:45 <jrx> Olathe: but there is no mechanical way to make IO -> LazyIO
06:16:12 <jrx> because Layziness can only be intoduced for ReaderIO, not WriterIO
06:17:36 <vixey> lol @ fmaps
06:25:33 <Olathe> jrx: Ahh, I see.
06:26:56 <Olathe> pumpkinbot has 12 minutes lag.
06:27:04 <Olathe> > 5
06:27:06 <PeakerLambda>   5
06:27:17 <Olathe> Ahh, I see we're using PeakerLambda now.
06:39:15 <shepheb> having trouble building SVN pandoc: http://pastebin.com/m5db7b38a
06:43:38 <Olathe> data PNGChunk = IEND | forall a. (BC.ByteContainer a) => PNGChunk String Word32 a
06:43:55 <Olathe> How do I fix that so that it sees PNGChunk on the right as a constructor instead of a type.
06:44:15 <vixey> remove forall a.
06:44:29 <Olathe> How do I get a to be existential ?
06:44:39 <NameAlreadyInUse> i have a "Pair" type like this: "data Num t => Pair t = Pair t t deriving (Eq, Show)"
06:44:42 <NameAlreadyInUse> how can i define methods like (+) so they work for my pair type?
06:44:55 <Olathe> NameAlreadyInUse: Make a Num instance for it.
06:45:17 <opqdonut> yeah, there is no automated way
06:46:01 <NameAlreadyInUse> Olathe: i have been trying, i have something that looks like this "instance Num Pair where" but it does not seem to work
06:46:17 <vixey> remove Num t =>
06:47:07 <opqdonut> and you shoud be saying "instance Num (Pair t)" where
06:47:24 <opqdonut> and even that's notenough, you need "instance Num t => Num (Pair t)"
06:48:12 <shepheb> I'm having package version trouble building SVN pandoc: http://pastebin.com/m5db7b38a
06:48:28 <NameAlreadyInUse> alright, that is better, but now i get: "is not a (visible) method of class Pair"
06:49:04 <Olathe> {-# OPTIONS_GHC -XFlexibleInstances #-} instance (Num t) => Num (Pair t) where (+) (Pair a b) (Pair c d) = Pair (a + c) (b + d)
06:49:41 <nothingmuch> is it considered evil to match (_, length) against CWStringLen ?
06:50:09 <nothingmuch> actually CStringLen, but same thing
06:50:39 <nothingmuch> hoogle has nothing for CStringLen -> IO Int
06:50:52 <nothingmuch> or CStringLen -> Int
06:51:41 <NameAlreadyInUse> that seems to have done the trick
06:54:08 <gwern> @seen dcoutts
06:54:08 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
06:54:17 <dcoutts> hia gwern
06:55:03 <gwern> dcoutts: so I was looking into having yi strip its recompiled binaries
06:55:09 <gwern> and I couldn't remember the ghc option for that
06:55:30 <gwern> was it -optl-s?
06:55:43 <dcoutts> gwern: that is not portable
06:55:51 <dcoutts> gwern: just calling strip is more portable
06:56:08 <gwern> hm. where is -optl-s not portable?
06:57:20 <gwern> (since yi goes from 30M to 19M, I do intend some sort of stripping)
06:58:54 <Olathe> Bah.
06:59:20 <Olathe> return Constructor a b c causes all sorts of unrelated errors.
07:00:04 <gwern> @hoogle runProcess
07:00:04 <PeakerLambda> System.Process runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
07:01:29 <draco_> hm, why isn't ghc available from cabal? ("cabal ghc")
07:01:38 <dcoutts> heh
07:01:46 <dcoutts> draco_: ghc is very complex to build
07:01:53 <draco_> ok
07:02:19 <dcoutts> gwern: -s is specific to the GNU linker I think. So probably does not work on OSX, BSD, Solaris.
07:02:48 <dcoutts> gwern: strip works everywhere that you can find the strip program.
07:04:14 <draco_> anyways, I'm trying to install soegtk ("cabal install soegtk") but it gives me the error " Could not find module `System.Time': it is a member of package old-time-1.0.0.0, which is hidden", how can I fix that?
07:05:50 <gwern> add old-time to the build-depends
07:06:17 <draco_> how do I do that?
07:08:39 <mopped> any alternative haskellpaste with hpaste down?
07:09:12 <BONUS> @where hpaste2
07:09:13 <PeakerLambda> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
07:09:24 <gwern> draco_: you edit the cabal file
07:09:25 * vixey does not set the topic for #haskell to ["Real World Haskell: out now", "Haskell News: http://reddit.com/r/haskell" "The Haskell programming language", "http://haskell.org", "Paste: http://moonpatio.com:8080/", "Logs: http://tunes.org/~nef/logs/haskell/"]
07:09:28 <PeakerLambda> Title: Haskell :: Reddit
07:09:30 <drhodes> with, XTypeSynonymInstances? choice,  data A = A [B]  -OR-  type A = [B]; if what's needed is a more explicit symbol for [B] (in this case  A ).
07:09:55 <draco_> gwern: but I don't have a cabal file? Or do I? hmm!
07:09:57 <Cale> draco_: Unfortunately that means the package on Hackage is out of date.
07:10:10 <draco_> Cale: okay
07:10:28 <clanehin__> I wonder if someone has experience with what I need to do to not spam planet.haskell.org . . .
07:10:39 <Cale> draco_: cabal will have downloaded the package to ~/.cabal/packages/hackage.haskell.org/soegtk/...
07:10:55 <Cale> draco_: You can go to it and unpack the tarball you find there and edit it
07:11:00 <draco_> oh ok
07:11:10 <Cale> draco_: then just run "cabal install" out of the directory it unpacked into
07:11:18 <draco_> ok
07:11:27 <Axman6> clanehin: stop postin' so much! :)
07:11:48 <draco_> anyways I think I'll reinstall everything from source so I'm up to date
07:12:08 <mopped> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1107 Can anyone explain why the commented out line breaks, but the two previous work ok? and how i can get a working version of the commented out line
07:12:48 <Axman6> mopped: you probably want mapM or mapM_
07:13:15 <shepheb> I'm having package version trouble building SVN pandoc: http://pastebin.com/m5db7b38a
07:13:27 <mopped> is that the IO version?
07:13:28 <clanehin> sigh, I haven't posted in a month but I changed my theme and did a few minor formatting changes and now I have three old posts at the top of the planet.  It's just planet haskell though, my other planet is not picking them up.
07:13:55 <Axman6> mopped: it's the Monad version
07:14:16 <Axman6> mopped: that, or you could use sequence_ . map ...
07:14:21 <mopped> How come I dont need a Monad version for sum and product?
07:14:51 <Axman6> :t map (\x -> putStrLn ("The factorial of " ++ show x ++ " is " ++ (show x)))
07:14:53 <PeakerLambda> forall a. (Show a) => [a] -> [IO ()]
07:15:04 <Axman6> see how it's [IO ()]?
07:15:12 <Axman6> you need IO a, not [IO a]
07:15:22 <Axman6> :t mapM (\x -> putStrLn ("The factorial of " ++ show x ++ " is " ++ (show x)))
07:15:23 <PeakerLambda> forall a. (Show a) => [a] -> IO [()]
07:15:32 <Axman6> :t mapM_ (\x -> putStrLn ("The factorial of " ++ show x ++ " is " ++ (show x)))
07:15:33 <PeakerLambda> forall a. (Show a) => [a] -> IO ()
07:16:05 <Axman6> mopped: see the difference?
07:16:35 <Axman6> @src mapM
07:16:35 <PeakerLambda> mapM f as = sequence (map f as)
07:16:42 <Axman6> heh
07:16:48 <mopped> While I see the difference, I don't know what it signifies :P
07:17:20 <Axman6> well, thing in IO do blocks must have the type IO a, or be in a let
07:17:31 <mopped> map works on a list of IO objects, rather an IO list?
07:17:33 <Axman6> things*
07:17:43 <nothingmuch> exactly
07:17:56 <Axman6> well, what you're building is a list of IO actions. nothing's executing them
07:17:57 <nothingmuch> s/works on/produces/;
07:18:34 <Axman6> mopped: also, you might want to use readLine instead of getLine then read
07:18:40 <Axman6> @src readLine
07:18:40 <PeakerLambda> Source not found. Sorry.
07:19:11 <mopped> What does the () signify, and what does M_ instead, if it doesnt return a list?
07:19:23 <Axman6> it returns IO [a]
07:19:34 <Axman6> instead of [IO a]
07:20:14 <nothingmuch> mapM returns IO [a], mapM_ sequences but then discards the value
07:20:30 <nothingmuch> s
07:20:57 <nothingmuch> in your case since you are printing and producing a list of empty tuples, there is no real use for the values
07:21:00 <mopped> I think i'll read on, i've not really covered type classes yet and have only started IO, so i'ts a bit confusing
07:21:03 <Axman6> basically, mapM_ will run all the actions, in order, but you use it when you don't care about the result, you just want them run
07:21:47 <Axman6> Workybob: i commented on your blog post
07:23:18 <tibbe> @seen dcoutts
07:23:18 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
07:23:30 <tibbe> dcoutts: ping
07:24:14 <leadnose> @src mappend
07:24:14 <PeakerLambda> Source not found.
07:27:49 <ketil> @ping
07:27:50 <PeakerLambda> pong
07:27:59 <ketil> @seen dons
07:27:59 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
07:28:14 <ketil> So, where's the old lambdabot?
07:28:27 <gwern> in the hospital
07:29:05 <arw> when i compiled some packages from cabal with an earlier ghc, say 6.6, will they link to programs from ghc 6.10?
07:30:16 <shepheb> preflex: seen dons
07:30:16 <preflex>  dons was last seen on #haskell 7 hours, 13 minutes and 47 seconds ago, saying: oh, the git one is similar
07:31:44 <gwern> arw: don't think so
07:32:07 <Axman6> arw: haskell packages are pretty fast moving
07:32:16 <arw> hmkay. i just installed some stuff to get cabal-install working and forgot --with-compiler :)
07:32:25 <arw> now i get Setup: /local/ghc-6.10.1/lib/ghc-6.10.1/directory-1.0.0.2/HSdirectory-1.0.0.2.o: unknown symbol `unixzm2zi3zi1zi0_SystemziPosixziDirectory_a12_info'
07:32:37 <arw> i guess ghc-pkg unregister on something?
07:34:21 <tibbe> anyone know it's possible to easily update the version of the network library that comes with ghc 6.8.3 or if that'll lead to troubles down the road?
07:35:53 <Baughn> tibbe: I've never had any problems
07:36:19 <Baughn> Other than the usual "bar is compiled against foo-1, baz is compiled against foo-2, and my program needs both bar and baz"
07:36:33 <Axman6> it annoys me that i can't use cabal upgrade because it installed process-1.0.1.1
07:36:45 <tibbe> Baughn: right
07:37:04 <tibbe> Baughn: right
07:37:11 <Baughn> tibbe: right
07:37:53 * tibbe is thinking about changing the network library but want GHC 6.8 users to be able to upgrade
07:41:29 <ztirF> am I doing something wrong
07:41:31 <hackage> Uploaded to hackage: xml2x 0.4.1
07:41:39 <ztirF> or is it hard to read a big list in Data.Binary
07:42:51 <Baughn> ztirF: Eh~?
07:43:01 <Baughn> Exactly what's the problem?
07:43:18 <Baughn> (And Data.Binary already has an instance for lists. It should be trivial.)
07:43:27 <ztirF> Baughn: I'm trying to read a 100000 element list of doubles, and I get a stack overflow
07:43:41 <Baughn> ztirF: Hmm. Try compiling with -O2?
07:44:39 <ztirF> Baughn: I'll try it, but I want to be able to do this in the interpreter so I can mess with it
07:45:33 <Baughn> ztirF: Well, you can always start the interpreter with -fobject-code -O2
07:46:00 <Baughn> ztirF: But the optimizer is annoyingly smart. It has a tendency to plug space leaks that really should be plugged manually, so the interpreter ends up not working.
07:46:25 <ztirF> Baughn: yeah that sounds like using gdb on a file compiled with -g -O2 to me
07:46:45 <ztirF> Baughn: it "works", but none of your variables exist anymore
07:47:59 <ztirF> Baughn: no dice with -O2
07:48:01 <drhodes> class Iter a where toList :: a -> [a]    mapI f someIterInstance   , is there something like this?
07:48:26 <opqdonut> traversable?
07:48:27 <methos> Q: need a zipWith but keeping the longer list with some neutral element to use when the first list has ended?
07:48:28 <opqdonut> foldable?
07:48:46 <drhodes> traversable sounds promising, thanks opqdonut
07:48:47 <Olathe> @src replicateM
07:48:47 <PeakerLambda> replicateM n x = sequence (replicate n x)
07:48:53 <Olathe> @src sequence
07:48:53 <PeakerLambda> sequence []     = return []
07:48:53 <PeakerLambda> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:48:53 <PeakerLambda> --OR
07:48:53 <PeakerLambda> sequence xs = foldr (liftM2 (:)) (return []) xs
07:49:16 <dcoutts> Axman6: use cabal install instead of upgrade
07:49:30 <dcoutts> tibbe: pong
07:49:57 <tibbe> dcoutts: I was going to ask you if see any problems in upgrading a library that ships with base like network
07:50:15 <dcoutts> tibbe: in principle there is no problem
07:50:15 <tibbe> dcoutts: for context I want to modify network but want it to bepossible for ghc 6.8 users to upgrade to it
07:50:22 <tibbe> dcoutts: and in practice?
07:50:39 <Baughn> ztirF: Does /saving/ a ten-thousand element list happen to work?
07:50:45 <ztirF> Baughn: yes
07:50:51 <ztirF> Baughn: it's 100k
07:50:59 <ztirF> and I want to do 1M eventually
07:51:01 <dcoutts> tibbe: yes, I think the version of network released at the same time as 6.10 will also build with 6.8
07:51:08 <tibbe> dcoutts: oh and a second thing. what do you think about enforcing upper version limits on hackage? I'm planning to release a new version of network-bytestring but all users have an open dependency on the library
07:51:09 <Baughn> ztirF: Data.Binary unaccountably stores lists in length-prefixed format, which apparently has an unfortunate tendency to cause stack overflows
07:51:21 <tibbe> dcoutts: ok, that's good to know
07:51:32 <Baughn> ztirF: (Oh, but make sure you've got the latest version of Data.Binary
07:51:42 <dcoutts> tibbe: aye, the solution is to opt-in to the package version policy and for us to then enforce that on dependent packages
07:52:04 <dcoutts> tibbe: we're doing it now for base but eventually we want to let any package opt-in
07:52:25 <ztirF> Baughn: yeah wow mine's pretty old
07:52:27 <ztirF> thanks
07:52:37 <tibbe> dcoutts: so if network-bytestring opts in noone can depend on it with an open dependency?
07:53:05 <dcoutts> tibbe: we cannot universally require upper bounds I think, it requires knowing the version policy of the package. But if the package does declare a version policy then we should be able to enforce it.
07:53:16 <Baughn> ztirF: But although the put implementation for lists will force the whole list backbone into existence before writing the first element, the get implementation does not have this problem. I don't see how put could work while get fails.
07:53:41 <tibbe> dcoutts: so I'm trying to warn users against putting such dependencies on my libraries
07:53:41 <dcoutts> tibbe: right, yes once we've got the system in place that's what it'd mean. But it'd also place constraints on your package, it would have to actually follow the policy.
07:53:48 <tibbe> dcoutts: so I can upgrade them without upsetting them
07:54:04 <dcoutts> tibbe: one temporary thing we can do is use a preferred version on hackage
07:54:17 <ztirF> Baughn: I don't know.  I'll try to upgrade and see if that makes a difference
07:54:18 <tibbe> dcoutts: like we do with base3/4?
07:54:23 <Baughn> ztirF: (Using a sentinel element to end the list would be much nicer from a laziness perspective, but it'd also add one byte to every element)
07:54:32 <dcoutts> tibbe: yep, and haxml, parsec, quickcheck
07:54:48 <ztirF> Baughn: what I don't understand is why the list is not read in chunks anyway
07:54:54 <dcoutts> tibbe: http://hackage.haskell.org/packages/archive/preferred-versions
07:54:54 <shepheb> so if I built pandoc-1.1 from the SVN version, and it appears in ghc-pkg, why is cabal-install trying to rebuild it from hackage?
07:55:22 <Baughn> ztirF: Again, I don't understand why /reading/ would fail. That's probably a bug, so how does it work with the new binary package?
07:55:29 <ztirF> Baughn: trying it now
07:55:36 <tibbe> dcoutts: but how about a warning on an open dependency, I can't see a point where an open upper dependency makes sense
07:56:21 <dcoutts> tibbe: but without a version policy it's not clear what they should use instead
07:56:33 <shepheb> gitit depends on pandoc >= 1.1, so wouldn't that satisfy? is cabal-install using a cache other than what's installed in ghc-pkg
07:56:41 <tibbe> dcoutts: hmm
07:57:02 <dcoutts> shepheb: cabal-install has no caches. It uses the package list from hackage and the ghc-pkg info
07:57:05 <tibbe> dcoutts: I guess I'm asking: How should we encourage people to use the PVP?
07:57:29 <tibbe> dcoutts: because people aren't using it today although it has existed for quite some time and been mentioned in several emails on cafe
07:57:30 <shepheb> dcoutts: that's what I thought. any ideas why it wouldn't accept my SVN pandoc?
07:57:36 <Olathe> Does it check for an error in any elements of the list before returning the list ?
07:57:50 <dcoutts> tibbe: that's because it's not enforced
07:58:07 <mopped> say I have f = (\x y -> x*2 + y), :t f is (Num a) => a -> a -> a, right? It takes a number, and returns (\y -> 10 + y), which takes another number, which returns a final number.. now that's supposedly the same as a -> (a -> a), but can anyone give me an example of (a -> a) -> a, and what the difference would be?
07:58:09 <ztirF> Baughn: 0.4.4 works for me, cool
07:58:12 <dcoutts> tibbe: once we can enforce it and we have a way of opting in I think it'll be much better
07:58:16 <ztirF> I was using 0.2
07:58:19 <tibbe> dcoutts: it sounds like the enforcement I can opt-in for is the wrong way around
07:58:20 <Axman6> "< dcoutts> Axman6: use cabal install instead of upgrade" the thing is, i don't know what's out of date :\
07:58:33 <tibbe> dcoutts: I can declare in my package spec that my package follows it
07:58:43 <vixey> mopped:  (Bool -> Int) -> Int
07:58:44 <dcoutts> Axman6: install always installs the latest version
07:58:50 <tibbe> dcoutts: what I want to do is to prevent people from depending on my package
07:59:00 <vixey> mopped: total ints = ints True = ints False
07:59:03 <dcoutts> Axman6: the only difference with upgrade is that upgrade also upgrades all dependencies
07:59:08 <vixey> mopped: total ints = ints True + ints False **
07:59:10 <Axman6> Baughn: but i'm trying to upgrade all my outdated stuff
07:59:11 <tibbe> dcoutts: without realizing the consequences
07:59:20 <dcoutts> tibbe: yes of course, so that's why your package would opt-in
07:59:21 <mopped> Is that a function that takes a function, which takes a bool and returns an int, and then then returns an int?
07:59:39 <Baughn> Axman6: In my experience, blindly upgrading *everything* is a recipe for disaster, so you should only upgrade at need
07:59:42 <tibbe> dcoutts: so if I opt in people will get a warning, cool that's what I want
07:59:50 <BONUS> mopped: (a -> a) -> a means that it takes a function of a -> a and returns an a. an example of an (a -> a) -> a -> a would be f g x = g x
07:59:52 <dcoutts> tibbe: and once your package opts in, we can advise or enforce on all packages that depend on yours.
07:59:56 <Axman6> yeah you're probably right
08:00:10 <dancor> @pl f g x = g x
08:00:10 <PeakerLambda> f = id
08:00:18 <Baughn> Axman6: Specifically, upgrading the packages that ship with GHC is a Bad Idea. Which is why they're trying to shrink that set.
08:00:20 <dcoutts> tibbe: but importantly, we can actually give those developers a suggested dependency, rather than just saying open deps are bad.
08:00:33 <tibbe> dcoutts: right, sounds good
08:00:46 <Axman6> Baughn: yeah, hence my problem with process :(
08:00:54 <Baughn> Axman6: (Actually, that's a good reason always to use cabal-install to get the extra libraries instead of building them with ghc. UPgrading those is safe either way, but..)
08:00:55 <mopped> ok thanks
08:00:57 <dcoutts> tibbe: because you're making a promise about how your package will evolve, so we can make concrete suggestions for dependent packages.
08:01:09 <tibbe> dcoutts: right
08:01:32 <tibbe> dcoutts: what cabal version is that slated for?
08:01:49 <shepheb> I had that dual-dependency on process problem
08:01:55 <dcoutts> tibbe: 1.8 or 1.10, sooner if you help. :-)
08:02:02 <tibbe> dcoutts: of course
08:02:18 <Baughn> ztirF: http://www.nabble.com/two-problems-with-Data.Binary-and-Data.ByteString-td18954800.html <-- Oh, and this goes into depth on the problem you're not having
08:02:19 <tibbe> dcoutts: can we get the field in earlier so people can start populate it?
08:02:21 <PeakerLambda> Title: Nabble - Haskell - Haskell-Cafe - two problems with Data.Binary and Data.ByteStr ..., http://tinyurl.com/6h84fh
08:02:22 <shepheb> I solved it by uninstalling and reinstall GHC and deleteing my local packages. not pretty, but it worked. I've learned my lessons about blindly cabal upgrade'ing
08:02:32 <tibbe> dcoutts: and implement the advice/enforcement later?
08:02:36 <dcoutts> tibbe: yes, we can get that into 1.8 at least
08:02:49 <tibbe> dcoutts: I think that would be a good idea
08:02:51 <dcoutts> tibbe: and perhaps not warn that it's undefined in 1.6
08:02:55 <tibbe> dcoutts: want me to file a ticket for it?
08:03:26 <dcoutts> tibbe: http://hackage.haskell.org/trac/hackage/ticket/434
08:03:28 <PeakerLambda> Title: #434 (Let packages opt-in to the Package Versioning Policy) - Hackage - Trac
08:03:32 <tibbe> dcoutts: start warning in 1.8 you mean?
08:03:53 <dcoutts> tibbe: all versions of cabal warn if they see a field they do not recognise
08:04:31 <dcoutts> tibbe: we can add the field in 1.8 and for the next release of 1.6 we can at least silently ignore the new field.
08:04:37 <tibbe> dcoutts: oh, I see what you mean. I thought I meant start warning about the field being missing
08:05:27 <dancor> i have a process that writes/reads postgres rows (never deletes/changes).  i want this to be syncable across machines that are not always online.  should i make a way to do additive-only postgres-syncing, or should i use something besides postgres
08:05:59 <dcoutts> shepheb: ok, now what was your problem with pandoc?
08:07:07 <shepheb> dcoutts: I built it from SVN, and it shows in ghc-pkg as pandoc-1.1
08:07:18 <dcoutts> ok
08:07:28 <shepheb> when I try to build gitit from git, cabal-install tries to reinstall it from Hackage
08:07:34 <shepheb> reinstall pandoc, I mean
08:07:42 <dcoutts> shepheb: the same version 1.1
08:07:47 <shepheb> yes
08:08:21 <shepheb> should I install the other gitit dependencies and just runhaskell Setup gitit?
08:08:21 <dcoutts> shepheb: I've fixed that in the darcs version of cabal-install the workaround is to bump the version number of the dev version
08:08:35 <nothingmuch> http://scsys.co.uk:8001/23823 -- what is the idiomatic way to fiddle the scoping here?
08:08:49 <dcoutts> shepheb: the fact that the one on hackage and the one that's installed have different dependencies confuses the install planner
08:09:01 <shepheb> mm, okay. I'll do that, thanks
08:09:02 <tibbe> dcoutts: are you editing the ticket at the same time as me?
08:09:03 <nothingmuch> i don't like the two where blocks, but I don't know of any other way to make the various variables created by bindings in the do block visible to them
08:09:04 <dcoutts> shepheb: when they both claim to be the same version
08:09:13 <dcoutts> tibbe: sorry, just cross-linking two tickets.
08:09:21 <tibbe> dcoutts: no worries
08:09:29 <Philonous> The GHC about the "close_fds" field in the CreateProcess struct "Close all file descriptors except stdin, stdout and stderr in the new process ". What is this supposed to mean? Which descriptors are closed and when?
08:09:39 <dcoutts> tibbe: see also http://hackage.haskell.org/trac/hackage/ticket/472
08:09:40 <PeakerLambda> Title: #472 (new field for version policy) - Hackage - Trac
08:09:52 <Philonous> GHC docs say*
08:09:56 <mmorrow> @bot
08:09:56 <lunabot>  :)
08:09:57 <PeakerLambda> :)
08:15:48 <Baughn> I find myself typing things like "type Hostname = String" to improve the quality of haddock documentation. Is this normal?
08:16:15 <byorgey> sure, that sounds like a common (and useful) practice.
08:16:20 <dcoutts> Baughn: yes
08:16:36 <byorgey> it improves the quality of the code, too.
08:16:46 <dcoutts> Baughn: you can also document the parameters to functions
08:17:42 <Baughn> dcoutts: It'd be nice to see the actual names of those parameters. Guess I should read the haddock documentation more thoroughly..
08:18:18 <draco_> hey again
08:18:46 <dcoutts> Baughn: foo :: String -- ^ the docs for this param
08:19:10 <draco_> How can you add event for key-combinations in gtk2hs?
08:19:33 <Baughn> draco_: gtk2hs is a fairly low-level binding. Do you know how to do it in gtk?
08:20:04 <Baughn> dcoutts: And yes, I'd just found that myself. :P
08:20:09 <draco_> nope, I guess I should check that out then Baughn :)
08:20:49 <byorgey> hmm, why does the Hackage front page still say that cabal-install is "experimental"?
08:21:08 <dcoutts> byorgey: depends on your opinion :-)
08:21:10 <Baughn> byorgey: Well, it is. Lots of its functionality is likely to change.
08:21:39 <byorgey> well, ok, fair enough.  =)
08:21:53 <dcoutts> it's clearly already useful but it's occasionally quite surprising or annoying
08:22:01 * dcoutts is preparing a new release
08:22:05 <byorgey> I just can't remember the last time I manually downloaded and unpacked a .tgz from Hackage, so it doesn't feel very experimental to me =)
08:22:17 <dcoutts> byorgey: :-)
08:22:51 <byorgey> new release sounds good
08:25:24 <Baughn> dcoutts: Last time I tried to alter anything in cabal-install, I got lost in an infinite maze of similar functions. Are there any plans to shrink its codebase?
08:26:03 <Baughn> It doesn't seem like it needs to be quite that large. Some functionality duplicates packages such as LogicT, so..
08:26:24 <dcoutts> Baughn: logicT? how so?
08:26:35 <Baughn> dcoutts: Dependency resolution
08:26:38 <dcoutts> Baughn: are you referring to the constraint solver?
08:26:42 <Baughn> Right
08:27:01 <dcoutts> Baughn: LogicT is for backtracking solvers though right?
08:27:11 <Baughn> dcoutts: Cabal-install backtracks
08:27:19 <dcoutts> no it doesn't
08:27:19 <Baughn> At least some of the time
08:27:24 <dcoutts> no, never
08:27:34 * dcoutts ought to know
08:27:36 <dcoutts> :-)
08:27:42 <Baughn> If it fails to solve dependencies with one flag set, doesn't it try clearing it?
08:28:03 <dcoutts> ah, well ok that bit does local backtracking
08:28:10 <dcoutts> that bit is in the Cabal lib
08:28:14 <dcoutts> finalisePackageDescription
08:29:14 <dcoutts> you could call it backtracking or just enumerating all possible solutions and picking the first one that works
08:29:18 <dcoutts> it's pretty dumb
08:29:23 <shepheb> is it possible to use plugins when pandoc is being called as a library?
08:31:03 <Baughn> dcoutts: Exponential blowup? I'd better make sure not to use lots of flags.
08:31:11 <dcoutts> Baughn: yep
08:31:51 <dcoutts> Baughn: the first impl was deliberately very simple, so it's only usable locally. We need a better approach for fixing flags globally.
08:32:13 <aluink> i'm reading rwh and i'm not clear on what is meants when talking about what types can be automatically derived: it seems to me that it's saying the standard requires the compiler to be able to auto-derive for (Read, Show, Eq, Ord), but not for other typeclasses
08:32:18 <dcoutts> Baughn: however exhaustive backtracking when you're trying to solve for all of hackage is not feasible.
08:32:39 <Baughn> aluink: Some type-classes have automatic derivation in ghc, yes. Others have not-quite-as-automatic derivation through Drift.
08:32:52 <Baughn> aluink: (Especially useful for Data.Binary ;)
08:33:11 <Baughn> dcoutts: Well, maybe with a quantum computer..
08:33:16 <Saizan> or Data.Derive
08:33:19 <dcoutts> Baughn: or a SAT solver
08:33:23 <mopped> I'd have thought (\x -> x x) is a function that takes a function (f), and returns a function that preforms f twice on an input, is this invalid because it is not x . x?
08:33:24 <aluink> well, before i can understand what you just said, am i correct at least in what i've said so far?
08:33:35 <Baughn> aluink: Yes
08:33:46 <aluink> ok, now, what's Drift?
08:33:51 <Baughn> aluink: Hackage Package
08:34:06 <Baughn> aluink: Basically, a lot of template haskell code to auto-derive more types than GHC already does
08:34:08 <aluink> ok, i'll ask my friend Google about it
08:34:16 <aluink> cool!
08:34:21 <Baughn> aluink: Ask it about hackage and cabal-install. ;)
08:34:27 <Peaker> mopped: right, x x applies x to x, which is invalid in Haskell because (a->b) cannot be given an (a->b) as an argument, it means a=a->b, but that's an infinite type
08:34:46 <Peaker> mopped: and infinite types are not allowed
08:34:56 <aluink> now, is GHC the standard Haskell compiler we always talk about? or is it _only_ an open source compiler that implement the Haskell standard
08:34:56 <mopped> ok
08:35:17 <aluink> as in, does it define the standard, or only implement it
08:35:18 <aluink> ?
08:35:21 <mopped> but (\x -> x . x) f would be akin to a function that applies f twice?
08:35:38 <Baughn> aluink: In practice, GHC defines the standard, but only in that it inspires the haskell' project
08:35:58 <Peaker> mopped: yes
08:36:01 <Peaker> @type \f -> f . f
08:36:02 <PeakerLambda> forall c. (c -> c) -> c -> c
08:36:03 <Baughn> aluink: Oh. And other haskell compilers always seem to aim at implementing GHC once they've gotten Haskell98 down. ;)
08:36:13 <Peaker> mopped: yes, by convention you call function-arguments "f" and not "x" :)
08:36:23 <Peaker> mopped: function values in general, that is
08:36:31 <mopped> that infinite type thing is quite a task to get my head around
08:36:54 <Peaker> mopped: if you apply a function to itself, it means that the function type is also its own argument type, right?
08:37:12 <mopped> right
08:37:24 <Peaker> mopped: so  a = (a -> b) right?
08:38:24 <mopped> right
08:38:58 <Peaker> mopped: That is called an "infinite type" -- because its basically: ((((.... -> b) -> b) -> b) -> b) .. all the way down
08:39:31 <mopped> Do some languages allow them?
08:39:38 <Peaker> mopped: untyped languages do, for example
08:39:38 <Axman6> aluink: haskell compilers should really be able to compile H98 to be called as such these days.
08:39:56 <Olathe> Dynamically typed languages allow them.
08:39:59 <iwannalog> mopped: ocaml with a switch (not sure)
08:40:18 <aluink> so is H98 like hte baseline standard and it's been extended since then? kinda like C89 and C99?
08:40:42 <Axman6> kinda
08:40:48 <Axman6> it's the latest standard
08:40:59 <Axman6> Haskell' is the one that;s being worked on
08:41:03 <ztirF> @hoogle rnf
08:41:03 <PeakerLambda> Control.Parallel.Strategies rnf :: NFData a => Strategy a
08:41:10 <Axman6> taking a lot of stuff from what GHC has these days
08:42:42 <redditbot> Haskell with only one typeclass
08:43:48 <aluink> so is "Haskell'" != "H98"?
08:44:01 <koeien> Haskell' is the new revision of Haskell, it's in progress
08:44:10 <aluink> ahh, ok
08:47:27 <sebaseba> is there a monadic version of iterate?
08:47:48 <Olathe> forever
08:47:56 <sebaseba> @src forever
08:47:57 <PeakerLambda> Source not found. :(
08:48:44 <BONUS> i wouldn't say that's a monadic version of iterate
08:49:01 <Peaker> @pl forever x = x >> forever x
08:49:02 <PeakerLambda> forever = fix (ap (>>))
08:49:03 <BONUS> iterate is (a -> a) -> a ->. [a] whereas forever is m a -> m b
08:49:25 <BONUS> most importantly, the result of the previous computation doesn't get fed into the next one with forever
08:49:40 <BONUS> maybe something like (a -> m a) -> a -> m [a]
08:49:47 <sebaseba> BONUS: exactly
08:49:53 <koeien> BONUS: forever :: m a -> m ()   ?
08:50:13 <Peaker> sebaseba: inefficient: forever x = x >> forever x        or more efficiently: forever x = let y = x >> y in y
08:50:31 <Peaker> forever is really an applicative operation
08:50:45 <Peaker> as (>>) is really an applicative operation
08:50:50 <BONUS> koeien: uh no, the m () is too tight
08:51:04 <Peaker> @type liftA2 (flip const)
08:51:05 <PeakerLambda> forall b a (f :: * -> *). (Applicative f) => f a -> f b -> f b
08:51:07 <BONUS> it can be done as m a -> m b and has that type in 6.10 afaik
08:51:13 <koeien> BONUS: perhaps. but in practice it's m ()
08:51:16 <Olathe> @hoogle m (n a) -> n (m a)
08:51:17 <PeakerLambda> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
08:51:17 <PeakerLambda> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
08:51:17 <PeakerLambda> Prelude sequence :: Monad m => [m a] -> m [a]
08:51:18 <koeien> ah, 6.10. ok.
08:51:39 <Peaker> Olathe: why do you need that?
08:52:13 <sebaseba> Peaker: I want to collect results in a list: (a -> m a) -> a -> m [a]
08:52:20 <Peaker> sebaseba: sequence
08:52:30 <Peaker> @type sequence
08:52:31 <PeakerLambda> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:52:43 <Peaker> which is, too, btw, an Applicative operation. Haskell's stdlib is foooobar
08:53:52 <BONUS> although yeah imho you can't do that
08:53:58 <BONUS> because sequence doesn't work on infinite lists
08:54:16 <vixey> BONUS, it does
08:54:28 <BONUS> even if you do iterateM f x = do { x' <- f x; xs' <- iterateM f x'; return $ x':xs'}, you still can't get anything out of it
08:54:31 <BONUS> vixey: really?
08:54:35 <BONUS> well i mean it works
08:54:36 <vixey> yes
08:54:39 <BONUS> it just never returns a result
08:54:45 <Deewiant> BONUS: sequence . repeat . print $ 0
08:54:57 <sebaseba> BONUS: yes, that's the problem I ran into, so I wonder if wanting iterateM even makes sense...
08:55:02 <Deewiant> right, of course it doesn't return :-)
08:55:06 <Olathe> @type \f a -> sequence . iterate (\x -> do { y <- x; f y }) . return $ a
08:55:07 <PeakerLambda> forall (m :: * -> *) a. (Monad m) => (a -> m a) -> a -> m [a]
08:55:26 <Cale> at least, in many monads
08:55:35 <Cale> In (->) e it should work correctly
08:56:26 <Cale> > let iterateM f x = do { x' <- f x; xs' <- iterateM f x'; return $ x':xs'} in iterateM (*) 1 2
08:56:27 <PeakerLambda>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
08:56:36 <Cale> oh, and it misses out x...
08:56:41 <Olathe> > let mIterate f a = sequence . iterate (\x -> do { y <- x; f y }) . return $ a in mIterate (return.(+1)) 0 :: [[Int]]
08:56:44 <Cale> > let iterateM f x = do { x' <- f x; xs' <- iterateM f x'; return $ x:xs'} in iterateM (*) 1 2
08:56:45 <PeakerLambda>   * Exception: stack overflow
08:56:45 <PeakerLambda>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:57:27 <Cale> It's not very usable in noncommutative monads though.
08:58:27 <Saizan> it should be usable in monads like Writer too
08:58:40 <Cale> ah, possibly
08:59:17 <sebaseba> what I wanted was to use it for monte carlo simulations, using a random result to feed the next computation, and collect the list of random results
08:59:40 <Cale> yep, writer works
09:00:15 <koeien> can i `safely' use HDBC 2.0 with mysql?
09:00:41 <Baughn> I don't see why not
09:01:12 <Cale> hmm, in Writer, it seems closely related to unfoldr
09:02:14 <Baughn> Is there a way to automate rewriting import statements to the minimum required?
09:02:21 <rovar> can someone familiar with Parsec help me formulate a strategy for altering a parser?
09:02:25 <andrewsw> can anyone help me understand how filterM (const [True,False]) [some,list,here] works?
09:02:35 <Cale> andrewsw: sure
09:02:47 <rovar> I have:  x <- many (noneOf "\"")
09:02:59 <andrewsw> Cale: primarily, it's the const [True, False] part that I don'tunderstand
09:03:01 <Cale> andrewsw: That reads as: for each element, regardless of its value, keep it (pick True) or drop it (pick False)
09:03:10 <xcthulhu> Silly question - does anyone know the asymptotics for "foldl1 lcm [1..n]"?
09:03:40 <Peaker> andrewsw: filterM takes a function that returns (m Bool) for some monad m.  (const [True, False]) returns that stuff are both accepted and unaccepted by the filter, regardless of what they are.  So filterM will both accept/not-accept each element in the list in its result
09:03:46 <rovar> and what I want is to put into  x <- many (noneOf "\"" unless it's escaped by \)
09:04:07 <andrewsw> okay. hrmm..
09:04:43 <sebaseba> rovar: I think you have to use try
09:04:59 <andrewsw> but const [True, False] always returns [True, False] and I don't see how [True, False] is a function that does anything
09:05:01 <Cale> xcthulhu: it's asymptotic to e^(n(1+o(1))) as n -> infinity
09:05:01 <Peaker> andrewsw: in the list monad, instead of just a single result, the list represents all possible results, and when the "result" is used in a computation that returns another "result" (each of these "result"s are lists of possible results) you get a cartesian product of all possible results
09:05:17 <xcthulhu> Cale: Thanks!
09:05:17 <andrewsw> Peaker: Aha! that helps a lot
09:05:31 <Olathe> @type filterM
09:05:33 <PeakerLambda> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:05:35 <Axman6> is Malcolm Wallace someone who hangs in here?
09:05:39 <Cale> xcthulhu: At least, according to Sloane.
09:05:43 <BONUS> think of it like branching
09:05:47 <BONUS> or super symmetry haha
09:05:52 <Cale> andrewsw: I have a diagram of it you might like...
09:06:00 <andrewsw> Cale: yes please!
09:06:05 <Cale> http://cale.yi.org/share/filterM.png
09:06:13 <rovar> sebaseba, I'll give it a try
09:06:25 <xcthulhu> @src filterM
09:06:25 <PeakerLambda> Source not found.
09:06:30 <xcthulhu> bummer
09:06:34 <sebaseba> rovar: pun intended? :)
09:06:40 <Cale> andrewsw: There's a slight abuse of notation involved there
09:07:06 <andrewsw> Cale: I see the concept. thanks!
09:07:14 <Cale> andrewsw: 1 : filterM (const [True,False]) [2,3] is blatantly a type error ;)
09:07:28 <andrewsw> yeah, but the idea makes it clear.
09:07:35 <rovar> sebaseba, for once.. no :)
09:08:22 <xcthulhu> Cale: It should be "map (1:) $ filterM (const [True,False] [2,3]"?
09:08:40 <Cale> yes
09:08:44 <vixey> (1:) . filterM ...
09:08:47 <andrewsw> So I read this as the list monad will expand the list-as-boolean-function into multiple instances of filterM working on a subset of the original list? sort of
09:08:48 <BONUS> that would be correct, although imho this is more readable
09:08:55 <Cale> and then  map (1:) . map (2:) $ filterM ...
09:09:23 <xcthulhu> BONUS: This diagram is how I think about these programs too
09:09:29 <Peaker> filterM is not applicative, right?
09:09:33 <Peaker> (can't be, that is)
09:09:34 <xcthulhu> BONUS: ...and Modal Logic...
09:09:38 <BONUS> hehe
09:09:47 <vixey> what about Modal Logic?
09:10:04 <Cale> andrewsw: filterM is just like filter, except that the conditional is a computation in the monad -- the list monad allows for each computation to produce zero or more results, and it collects up all possible ways of choosing from those.
09:10:15 <BONUS> mapM can be done with just applicative, i dont think filterM can
09:10:33 <Cale> andrewsw: So the condition (\x -> [True,False]) or (const [True, False]) means, regardless of the value of x, either keep it, or drop it.
09:10:44 <andrewsw> okay okay. I think I'm getting it.
09:11:05 <xcthulhu> vixey: Modal Logic has a complete semantics as a Boolean Algebra with Operators.  And as monads and functors are like operators in combinatory logic, I get the same sort of feeling doing both.
09:11:09 <Cale> > filterM (\x -> if even x then [True,False] else [True]) [1,2,3,4]
09:11:10 <PeakerLambda>   [[1,2,3,4],[1,2,3],[1,3,4],[1,3]]
09:11:14 <xcthulhu> vixey: Modal Logic and Haskell that is
09:11:18 <andrewsw> I'm confused because in this case Monad m => (a -> m Bool) the m is the list
09:11:44 <Cale> Right, so  filterM :: (a -> [Bool]) -> [a] -> [[a]]
09:11:57 <Cale> (in this case)
09:12:14 <andrewsw> okay, the function on a has a list of boolean results that are used to process [a].
09:12:22 <Axman6> :t filterM
09:12:23 <PeakerLambda> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:12:29 <Cale> > filterM (\x -> if even x then [True] else [False]) [1,2,3,4]
09:12:30 <PeakerLambda>   [[2,4]]
09:12:32 <Peaker> @type let filterM f = foldr (\(x:r) -> f x >>= (\y -> if y then x:r else r)) (return []) in filterM
09:12:33 <PeakerLambda>     Couldn't match expected type `b -> b' against inferred type `[t]'
09:12:33 <PeakerLambda>     In the expression: x : r
09:12:33 <PeakerLambda>     In the expression: if y then x : r else r
09:12:35 * beelsebob slaps that for needing to be filterA
09:12:43 <Cale> > filterM (\x -> [even x]) [1,2,3,4]
09:12:44 <PeakerLambda>   [[2,4]]
09:13:11 <Cale> > filterM (\x -> [even x, (==1) `mod` 4]) [1,2,3,4]
09:13:12 <PeakerLambda>   Couldn't match expected type `GHC.Bool.Bool'
09:13:19 <Cale> > filterM (\x -> [even x, x `mod` 4 == 1]) [1,2,3,4]
09:13:20 <PeakerLambda>   [[2,4],[2],[2,4],[2],[4],[],[4],[],[1,2,4],[1,2],[1,2,4],[1,2],[1,4],[1],[1...
09:13:27 <Axman6> > filterM (return.even) [1,2,3,4]
09:13:28 <PeakerLambda>   No instance for (GHC.Show.Show (m [a]))
09:13:28 <PeakerLambda>    arising from a use of `M16930208...
09:13:29 <xcthulhu> >filterM (\x -> Just (even x)) Just 2
09:13:32 <Axman6> lame
09:13:32 <Cale> > filterM (\x -> nub [even x, x `mod` 4 == 1]) [1,2,3,4]
09:13:33 <PeakerLambda>   [[2,4],[2],[4],[],[1,2,4],[1,2],[1,4],[1]]
09:13:53 <andrewsw> so a different application of filterM might have the m be some other monad and the function returns that boolean wrapped in the monad, unwraps that boolean and applies it to [a]
09:14:25 <Cale> andrewsw: I hate the term "wrapped" in the context of monads, but okay, yes.
09:14:37 <Cale> A better term for 'unwraps' is 'runs'
09:14:38 <rovar> sebaseba, I think the cleaner version would be to create a version of noneOf which accepted all chars if they were escaped by \
09:14:47 <rovar> but I'm not sure if I could use try with satisfy
09:15:00 <andrewsw> yeah, I realize it's a less-than-ideal, but it's where my understanding is at the moment.
09:15:19 <Peaker> @type let filterM accept = foldr (\(x:r) -> accept x >>= (\y -> if y then liftM (y:) r else r)) $ return [] in filterM
09:15:20 <PeakerLambda>     Couldn't match expected type `[Bool] -> [Bool]'
09:15:20 <PeakerLambda>            against inferred type `[t]'
09:15:20 <PeakerLambda>     In the second argument of `liftM', namely `r'
09:15:30 <andrewsw> Cale: I guess "runs" includes the idea of ordered operations within the monad
09:16:04 <Cale> For example, in the IO monad, you can have:  filterM (\x -> do putStrLn $ "Keep " ++ show x ++ "?"; readLn) [1,2,3,4,5]
09:16:27 <Cale> and it will read a Bool from the user, for each of the elements.
09:16:34 <andrewsw> oh that's interesting
09:16:51 <andrewsw> yay! I actually understood that before you told me what it did!
09:17:03 <aluink> > tail . tail "othello"
09:17:04 <PeakerLambda>   Couldn't match expected type `a -> [a1]'
09:17:22 <Cale> > tail . tail $ "othello"
09:17:23 <PeakerLambda>   "hello"
09:18:05 <Peaker> @pl \(x:r) -> accept x >>= (\y -> if y then liftM (y:) r else r
09:18:05 <PeakerLambda> (line 1, column 60):
09:18:05 <PeakerLambda> unexpected end of input
09:18:05 <PeakerLambda> expecting letter or digit, variable, "(", operator or ")"
09:18:15 <andrewsw> Cale, et al, thanks! I'm back to reading now.
09:18:19 <Peaker> @pl \x r -> accept x >>= \y -> if y then liftM (y:) r else r
09:18:22 <PeakerLambda> (. join (flip . ap if' . flip (fmap . (:)))) . (>>=) . accept
09:18:22 <PeakerLambda> optimization suspended, use @pl-resume to continue.
09:18:46 <Peaker> Can anyone find prettier than: filterM accept = foldr (\x r -> accept x >>= (\y -> if y then liftM (x:) r else r)) $ return [] in filterM
09:20:30 <chessguy> @src words
09:20:30 <PeakerLambda> words s = case dropWhile isSpace s of
09:20:30 <PeakerLambda>     "" -> []
09:20:30 <PeakerLambda>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:20:55 <BMeph> Use Lua! ;)
09:21:31 <dcoutts> Baughn: btw, don't think that I wouldn't appreciate help with making the constraint solver better, either work better or have clearer code.
09:21:35 <mopped> Do I pattern match on a class or a constructor?
09:21:35 * BMeph goes to get some coffee and wake up...
09:21:57 <roconnor> @djinn (a -> c,b -> c) -> (Either a b -> c)
09:21:58 <PeakerLambda> f (a, b) c =
09:21:58 <PeakerLambda>     case c of
09:21:58 <PeakerLambda>     Left d -> a d
09:21:58 <PeakerLambda>     Right e -> b e
09:22:04 <roconnor> is there a name for that function?
09:22:06 <vixey> mopped, patterns are made from constructors and variables
09:22:06 <Axman6> mopped: you mean on a type or a constructor? (the answer is constructor)
09:22:24 <mopped> hmm yeah a type
09:22:48 <dcoutts> Baughn: if you have concrete suggestions that's great. In my experience however I've noticed that it's easy to say "it'd be better if..." and actually making something work. There always turns out to be lots of details (esp error reporting).
09:23:41 <Baughn> dcoutts: Don't think I wouldn't enjoy helping. We'll see how fast I get this thesis written, though.
09:23:56 <dcoutts> Baughn: ok :-)
09:23:59 <augustss> roconnor: either
09:24:18 <roconnor> augustss: ah!
09:24:20 <sebaseba> rovar: makes sense, it would go something like this: many ((char '\\' >> anyChar) <|> noneOf "\"")
09:24:26 <dcoutts> Baughn: if we go for a rewrite I think it should be based on some recognised sat or constraint solving technique.
09:24:31 <roconnor> augustss: so obvious.
09:24:42 <augustss> roconnor: maybe :)
09:24:42 <BMeph> roconnor: looks like some mix of (.) and either. With an 'uncurry' thrown in for fun. :)
09:24:48 <Baughn> dcoutts: Agreed. No reason to reinvent the wheel in hexagonal form.
09:25:11 <BMeph> roconnor: Oh, NM, augustss caught it. I'm gonna go find me that coffee, now... :)
09:25:17 <Axman6> hmm, i've made some changes to HsColour, what do i need to do to send those patches to the maintainer?
09:25:19 <dcoutts> Baughn: the hard part however is preferences and error messages. SAT solvers are not great for either.
09:25:24 <Axman6> darcs wise i mean
09:25:58 <BMeph> :t uncurry either
09:25:59 <PeakerLambda> forall a c b. (a -> c, b -> c) -> Either a b -> c
09:26:20 <BMeph> roconnor: No (.) needed, even. :)
09:26:25 <roconnor> dcoutts: is cairo supposed to be a thin wrapper around cairo, or would adding a dependency on a colour lib (like mine :) be (eventually) appropriate?
09:26:33 <roconnor> @type uncurry either
09:26:33 <PeakerLambda> forall a c b. (a -> c, b -> c) -> Either a b -> c
09:26:40 <mopped> does there happen to be a pastebin option for haskell-mode? :P
09:26:42 * BMeph puts down the keyboard and goes to find coffee - Really!
09:27:00 <augustss> And just a bit of trivia:  Mikael Rittri named the Either type.
09:27:02 <Axman6> @where hpaste2
09:27:02 <PeakerLambda> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
09:27:05 <Axman6> mopped: ^^
09:27:22 <dcoutts> roconnor: It's mostly supposed to be a thin wrapper. What colour lib?
09:27:23 <mopped> I mean, if i could select text, press a bind and it pastes automagically
09:27:23 <Axman6> @whe
09:27:24 <PeakerLambda> Maybe you meant: where where+ ghc thx what wn
09:27:36 <roconnor> @remember augustss And just a bit of trivia:  Mikael Rittri named the Either type.
09:27:36 <PeakerLambda> It is forever etched in my memory.
09:27:37 <Axman6> @what
09:27:37 <PeakerLambda>  @where <key>, return element associated with key
09:27:58 <roconnor> dcoutts: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour-2.2.0
09:28:01 <PeakerLambda> Title: HackageDB: colour-2.2.0, http://tinyurl.com/cg7nfr
09:28:43 <ehird> cabal: user error (Unresolved dependencies: base >=4&&<5)
09:28:45 <ehird> how can I resolve this?
09:28:47 <Peaker> I think @remember is kind of useless on my bot
09:29:03 <dcoutts> roconnor: and what would be the purpose? to allow specifying cairo colours in colour spaces other than RGB(A) ?
09:29:06 <byorgey> is lambdabot on vacation, or what?
09:29:13 <mopped> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1109 Is there a terser method for this?
09:29:26 <vixey> hi byorgey
09:29:29 <Axman6> ehird: install GHC 6.10.1
09:29:33 <byorgey> hey vixey =)
09:29:34 <Raevel> mopped: record syntax
09:29:42 <roconnor> dcoutts: so that cairo colours can be used easily with other libraries that use colours.
09:29:48 <ehird> Axman6:
09:29:48 <ehird> % ghc --version
09:29:49 <ehird> The Glorious Glasgow Haskell Compilation System, version 6.10.1
09:29:58 <ehird> I don't think that would help.
09:30:02 <Peaker> roconnor: like "maybe".. and "foldr" should have been "list", they're all the catamorphisms of the type with the same name
09:30:11 <Axman6> ehird: well, base 4 is what ships with ghc 6.10.1
09:30:16 <dcoutts> roconnor: cairo just uses RGB(A) afaik, it doesn't define anything itself
09:30:20 <vixey> mopped, I use  (a, (b, (c, ()))) so  fst, fst . snd, fst . snd . snd, ...
09:30:24 <Badger> GHC, comrades!
09:30:26 <ehird> Axman6: Well... i don't know.
09:30:30 <Peaker> or  maybe foldList, foldMaybe, foldEither
09:30:48 <rovar> okay, I think I finally know what question to ask:
09:30:50 <Axman6> anyone savvy with darcs?
09:31:03 <Axman6> rovar: don't mess it up!
09:31:25 <rovar> I'm going through Write you self a Scheme .... and there is an exercise in the parser section: "You may want to replace noneOf "\"" with a new parser action that accepts either a non-quote character or a backslash followed by a quote mark."
09:32:02 <rovar> the parser noneOf and the like are Character parsers.. how do I validate the current char by finding what char follows it?
09:32:14 <rovar> and/or validate a char by finding which char precedes it?
09:32:30 <sebaseba> rovar: char '\\' >> anyChar
09:32:55 <dcoutts> roconnor: I've no idea what colour space cairo is supposed to be using. I expect it's not well defined.
09:33:22 <rovar> sebaseba, you mean I can advance the parser a character from within the char parser itself?
09:34:21 <sebaseba> rovar: >> composes two parsers, it succeeds it both succeed, and returns the result of the second parser
09:34:58 <Axman6> how do i get darcs to notice i've made a change to a file in some code i've checked out?
09:35:18 <Axman6> and then, how do i make/submit that patch?
09:35:23 <mopped> Is there an Either for more than two cases?
09:35:26 <Baughn> Axman6: darcs record, then push or send
09:35:35 <Axman6> cheers
09:35:44 <BONUS> ooh
09:35:48 <BONUS> Category.Control
09:35:48 <Baughn> mopped: At that point, it's probably time to make an ADT
09:35:50 <BONUS> i mean
09:35:51 <Gracenotes> hm... is Write Yourself a Scheme a good way to learn Parsec?
09:35:55 <koeien> mopped: chained Either. but anyway it's easier to define your own type then
09:35:56 <BONUS> Control.Category. didnt notice this until now
09:36:03 <sebaseba> so your new noneOf would be noneOf' = (char '\\' >> anyChar) <|> noneOf "\""
09:36:24 <mopped> YAHT tells me to express it in Either, although i'm not sure why I would..
09:36:40 <koeien> Either Int (Either String Int) -- you can use such a thing
09:37:03 <koeien> this gets ugly quickly though
09:37:31 <conal> nicer with infix: Int `Either` String `Either` Int
09:37:42 <conal> like 2 + 3 + 5
09:37:57 <Baughn> mopped: Right. You shouldn't.
09:38:12 <Baughn> mopped: data Foo = One a | Two b | Three c is much cleaner
09:40:00 <Heffalump> conal: happy birthday!
09:40:03 <ehird> Hrm...
09:40:38 <conal> Heffalump: thanks!  how'd you know?
09:40:45 <Heffalump> you told facebook
09:40:45 <mopped> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1110 why doesn't that work?
09:40:53 <conal> oh, yeah. :)
09:41:14 <Heffalump> I should have pretended to psychic powers.
09:41:31 <hackage> Uploaded to hackage: gitit 0.5.1
09:42:10 <Raevel> mopped: f needs to have a type, what would that one be?
09:42:34 <mopped> I was hoping the compiler would figure that out for me! :P
09:42:57 <Axman6> Baughn: don't suppose you know what needs to be done to get sendmail working with darcs?
09:43:02 <thom_logn> does anyone have a link to a good critique of what's "wrong" with erlang from a haskell point of view?
09:43:11 <byorgey> oh, happy birthday, conal!
09:43:12 <Raevel> mopped: basically, there is no type that includes both a 2-tuple and a 3-tuple, etc
09:43:25 <conal> byorgey: thanks, brent.  :)
09:43:31 <Raevel> mopped: you might want to use a list instead
09:43:33 <Axman6> happy birthday conal :)
09:43:34 <conal> byorgey: was just reading your dragonny blog post
09:43:35 <pumpkin> moo
09:43:39 <conal> Axman6: :) :)
09:44:17 <ehird> Do I have to reinstall cabal after upgrading ghc, perhaps?
09:44:26 <ehird> oh, happy birthday, conal!
09:44:36 <ehird> whoa, same sentence as byorgey. freaky
09:44:39 <Heffalump> ehird: the cabal binary shouldn't need reinstalling
09:44:58 <ehird> Heffalump: mm - I just reinstalled ghc in place, not the libs.
09:44:59 <byorgey> whoa, same sentence as ehird. freaky
09:45:08 <ehird> Guess that wasn't so clever.
09:45:12 <ehird> byorgey: Shut up, ALICE :p
09:45:13 <mopped> Raevel: YAHT stipulates a tuple, I guess this is where Either comes in :)
09:45:17 <byorgey> hehe
09:45:23 <Philonous> @src filterM
09:45:23 <PeakerLambda> Source not found. Sorry.
09:45:36 <rovar> sebaseba,  thanks,   I have:   	x <- many ((char '\\' >> anyChar) <|> noneOf "\""
09:46:06 <dcoutts> ehird: if you're using cabal-install 0.6.0 then there is no need to upgrade it or reinstall it
09:46:08 <rovar> which i think works, I'm not sure yet becasue I'm having an issue with the Error type later on
09:46:15 <conal> ehird: thanks.
09:46:17 <byorgey> Philonous: http://byorgey.wordpress.com/2007/06/26/deducing-code-from-types-filterm/
09:46:20 <PeakerLambda> Title: Deducing code from types: filterM « blog :: Brent -> [String], http://tinyurl.com/6k4uuu
09:46:26 <ehird> How can I check my cabal-install version?
09:46:35 <Philonous> byorgey: thanks
09:46:37 <byorgey> cabal --version ?
09:47:26 <ehird> cabal doesn't understand --version
09:47:30 <ehird> Unrecognized options:
09:47:30 <ehird> --version
09:47:34 <Raevel> mopped: anytime you want to use your own tuple type there, you'll have to check each possible TupleN, so i doubt that the f function will be helpful
09:47:38 <byorgey> well, it must be an old version of cabal-install then ;)
09:47:58 <arw> cabal: cannot configure syb-0.1.0.0. It requires base >=4.0
09:48:04 <dcoutts> ehird: oh, you've got a very very very old version in that case. You need to get the latest version.
09:48:05 <byorgey> ehird: the version I have installed (0.6.0) has a --version flag, at least
09:48:09 <arw> what does that mean, and where is 'base'?
09:48:13 <ehird> Very old, oh dear :)
09:48:22 * ehird downloads newer version
09:48:24 <mopped> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1111 would this be a working method Raevel?
09:48:29 <arw> because trying to update base reports that base doesn't exist...
09:48:29 <Philonous> byorgey: Ah, actually I think I should figure it out myself, too.
09:48:31 <ehird> (It is probably circa early 2008...)
09:48:46 <ehird> Is my Cabal out of date or just my cabal-install?
09:48:47 <byorgey> Philonous: sure, that's probably a good idea =)
09:48:57 <Baughn> arw: base refers to GHC itself, actually
09:49:05 <dcoutts> ehird: the Cabal lib comes with ghc, the cabal program does not
09:49:06 <Baughn> arw: Version 4 means ghc 6.10.1
09:49:07 <dcoutts> arw: the version of base is tightly tied to the versino of ghc
09:49:09 <ehird> OK
09:49:14 <rovar> The parser tutorial seems to indicate that Error has the methods  noMsg and strMsg,  ghc disagrees.. which one is correct?
09:49:39 <dcoutts> arw: the syb stuff is in base 3. With base 4 it got split out into a separate syb package.
09:49:58 <byorgey> rovar: the Error class does indeed have those methods.
09:50:03 <dcoutts> arw: so it's likely that the program could be made to work with base 3 and the syb stuff it includes.
09:50:09 <byorgey> rovar: have you imported Control.Monad.Error?
09:50:19 <paolino> @bot
09:50:20 <lunabot>  :)
09:50:20 <PeakerLambda> :)
09:50:28 <arw> uh, i guess cabal is just using the wrong compiler then...
09:50:51 <dcoutts> arw: sounds like you're using 6.8
09:50:56 <paolino> @hoogle TVarIO
09:50:57 <PeakerLambda> No results found
09:51:06 <rovar> byorgey,it was my mistake.. I failed to import Control.Monad.Error
09:51:16 <dcoutts> arw: it uses the 'ghc' from the $PATH by default, you can use another one by passing -w ghc-6.whatever
09:51:28 <Raevel> mopped: well, it'll compile, though i don't really see how it's useful :-)
09:51:37 <arw> dcoutts: hm, systems compiler in /usr/bin is 6.8 or 6.6, but there is one in a different directory with version 6.10
09:52:05 <arw> dcoutts: i tried compiler: /local/ghc-6.10.1/bin/ghc in ~/.cabal/config, but that seems to be ignored.
09:52:14 <ehird> WTF.
09:52:15 <ehird> Setup: At least the following dependencies are missing:
09:52:16 <ehird> HTTP >=3000 && <3002, network >=1 && <3, zlib >=0.4 && <0.6
09:52:22 <ehird> I very much have them...
09:52:38 <arw> dcoutts: disregard that last sentence, i'm just too dumb :)
09:52:46 <ehird> ??
09:52:46 <arw> -- is of course commented out :)
09:52:46 <Baughn> ehird: Are they installed globally, or in ~/.ghc? ;)
09:52:48 <Gracenotes> ehird: cabal? :(
09:52:52 <Raevel> mopped: the Tuple type by itself is all you need
09:52:54 <ehird> Baughn: Locally...
09:53:00 <ehird> Well.
09:53:04 <ehird> bootstrap.sh installed them.
09:53:09 <ehird> By the looks of it, locally.
09:54:04 <Gracenotes> bootstrap.sh didn't install, say, zlib for me. I had to manually set it up...
09:54:28 <ehird> [4 of 5] Compiling Codec.Compression.Zlib ( Codec/Compression/Zlib.hs, dist/build/Codec/Compression/Zlib.o )
09:54:47 <ehird> So it did try to install zlib...
09:55:26 <ehird> ... ok, zlib works now, but I get
09:55:27 <ehird> HTTP >=3000 && <3002, network >=1 && <3
09:55:32 <ehird> So it wants... the null string package?
09:55:43 <ehird> oh wait, that's a constraint on network.
10:00:35 <Saizan> ?hoogle TVarIO
10:00:35 <PeakerLambda> No results found
10:01:54 <pumpkin> I guess pumpkinbot died?
10:01:59 <ehird> regex-dfa-0.91 failed during the building phase. The exception was:
10:01:59 <ehird> exit: ExitFailure 1
10:02:01 <ehird> Whee...
10:02:23 <ehird> Hmmm...
10:02:24 <ehird>     Could not find module `Data.IntMap':
10:02:24 <ehird>       it is a member of package containers-0.2.0.0, which is hidden
10:03:34 <ehird> very odd
10:03:39 <roconnor> hpaste, lambdabot, pumpkinbot are all dead?
10:03:51 <roconnor> no wonder people don't take haskell seriously :P
10:04:27 * ehird sets up Iambdabot
10:04:34 <ehird> capitalism!
10:04:34 <pumpkin> roconnor: pumpkinbot is still up
10:04:35 <SamB> maybe we should have written them in Erlang ...
10:04:41 <pumpkin> roconnor: someone with power must've @parted him
10:04:55 <SamB> our botnet needs more net
10:05:19 <ehird> So, how can I cabal _uninstall_?
10:05:29 <SamB> ehird: what now ?
10:05:37 <ehird> Uninstall a Cabal package.
10:05:38 <dcoutts_> ehird: rm the files and ghc-pkg unregister
10:05:47 <ehird> High tech. Alright.
10:05:52 <SamB> good luck figuring out what all the files are :-(
10:05:54 <Axman6> if you're on reddit, upvote pls :) http://www.reddit.com/r/funny/comments/7u2fu/mighty_putty/
10:05:59 <PeakerLambda> Title: Mighty Putty! : funny
10:05:59 <Axman6> whoops, wrong chan
10:06:16 <roconnor> <dcoutts> roconnor: I've no idea what colour space cairo is supposed to be using. I expect it's not well defined.
10:06:23 <trygvis> pumpkin: pumpkinbot was kickbanned a while back IIRC
10:06:27 <Axman6> but, don't feel you can't follow the instructions ;) (watch the video, it's awesome)
10:06:31 <roconnor> dcoutts: right.  that might be reason enough not to tie it to Data.Colour
10:06:38 <pumpkin> trygvis: interesting
10:06:39 <ehird> ghc-pkg: unregistering containers would break the following packages: haddock-2.3.0 ghc-6.10.1 hpc-0.5.0.2 template-haskell-2.3.0.0 Cabal-1.6.0.1 Cabal-1.6.0.1 binary-0.4.4 fgl-5.4.2.2 pureMD5-0.2.4 regex-base-0.93.1 (use --force to override)
10:06:45 <ehird> Oh, crap.
10:06:59 <Axman6> pumpkin: link above! click it! laugh! vote up! now!
10:07:04 <ehird> (This is _after_ I delete all the files, of course.)
10:07:05 <roconnor> ehird: heh
10:07:11 <roconnor> oh no
10:07:11 <ehird> Wonder what I should do now, ay.
10:07:14 <pumpkin> trygvis: by whom?
10:07:22 <roconnor> reinstall?
10:07:23 <ehird> Do i get to recompile ghc?
10:07:25 <ehird> That will be fun fun fun.
10:07:43 <trygvis> pumpkin: I think you can see that if you list all bans
10:07:47 <Yoric[DT]> Does anyone know if ghc still compiles with continuations?
10:07:49 <trygvis> it was misbehaving
10:07:57 <roconnor> we need to get a nix-cabal
10:07:58 <pumpkin> it's not on the ban list that I can see :/
10:08:00 <FliPPeh> Haskell hates me :(
10:08:02 <ehird>       it is a member of package base, which is hidden
10:08:06 <ehird> ohhhhhhhhhhhhhhhhhh deaaaaaaaaaaar.
10:08:15 <FliPPeh> It doesn't want to be learned by me
10:08:31 <dcoutts_> roconnor: ghc has to be able to support arbitrarily slotted packages, it's not something we can do in cabal directly
10:08:32 <SamB> hmm, why is hackage trying to build lhc with multiple versions of the same package that is not designed for this ?
10:08:43 <pumpkin> ah well
10:08:49 <dcoutts_> roconnor: about colour, it would not stop people using the output of your colour package as input to cairo
10:09:05 <trygvis> pumpkin: 14:39 -!- pumpkinbot was kicked from #haskell by Saizan [Saizan]
10:09:12 <pumpkin> lol
10:09:16 <dcoutts_> SamB: the hackage auto-builder is dumb
10:09:19 <pumpkin> Saizan: you had admin access on pumpkinbot :P
10:09:22 <Axman6> FliPPeh: haskell loves you, just not in a way you're used to
10:09:28 <FliPPeh> You think?
10:09:29 <dcoutts_> SamB: it does no planning at all
10:09:34 <SamB> dcoutts: why doesn't it use cabal-install ???
10:09:45 <Axman6> FliPPeh: why do you think it hates you?
10:09:45 <dcoutts_> SamB: that's what we'll do for the new server
10:09:46 <vegai> Haskell loves you but hates your code
10:09:48 <FliPPeh> I've read so many tutorials, some are too small and some are overkill
10:09:56 <FliPPeh> Real World Haskell is way too much
10:10:39 <Heffalump> way too much what?
10:10:54 <Cale> FliPPeh: Have you seen "Learn You A Haskell"? It seems like it should be pretty fun :)
10:10:57 <FliPPeh> In a way you need 3 hours to understand a single chapter
10:11:13 <FliPPeh> And in the next chapter everything is forgotten again :(
10:11:28 <Cale> otoh, I would love to be able to absorb a chapter of an average mathematics text in 3 hours. ;)
10:11:33 <Axman6> FliPPeh: have you done any other programming before?
10:11:33 <Saizan> pumpkin: did i?
10:11:43 <ehird> So... is my ghc Irreparably Broken(TM), or can I salvage it?
10:11:46 <FliPPeh> Imperative languages
10:11:54 <FliPPeh> PHP, Ruby, D
10:12:25 <Cale> ehird: Can you reinstall containers? Is there a copy of it on hackage?
10:12:33 <Axman6> FliPPeh: so what are you having trouble with i haskell?
10:12:36 <FliPPeh> It's really hard to forget all previously learned things
10:12:38 <ehird> Cale: When I try and install containers:
10:12:39 <ehird> Data/IntMap.hs:182:7:
10:12:40 <ehird>     Could not find module `Data.Data':
10:12:42 <ehird>       it is a member of package base, which is hidden
10:12:49 <Cale> mm...
10:12:53 <FliPPeh> MOstly type errors, as these are common for beginners
10:13:00 <Cale> ehird: Which ghc do you have?
10:13:01 <tibbe> dcoutts: hmm, the PVP doesn't specify what happens if you add a new module to your package
10:13:07 <Axman6> FliPPeh: well, that's what we're here for :)
10:13:08 <Philonous> monadic return is injective, isn't it?
10:13:11 <Cale> ehird: That sounds like a base version mixup.
10:13:12 <tibbe> dcoutts: doing so might break user code if the module name collides
10:13:12 <ehird> Cale: 6.10.1
10:13:17 <FliPPeh> When I've overcome those, it's really hard to implement certain things I did in imperatives in haskell
10:13:18 <lilac> Philonous: for most monads, yes.
10:13:21 <Cale> ehird: okay, curious.
10:13:26 <Axman6> one of the friendliest irc channels you'll find anywhere
10:13:29 <FliPPeh> Just in "How the hell do I do that?"
10:13:32 <pumpkin> Saizan: yeah, I specifically added you, and announced that you and others had such powers in #haskell-ops :)
10:13:37 <Cale> FliPPeh: :)
10:13:42 <dcoutts> tibbe: the same is potentially true for new exports from a module
10:13:43 <Philonous> lilac: For which monad is it not?
10:13:44 <FliPPeh> :>
10:13:45 <pumpkin> but it's not  a big deal, same end-result was achieved :)
10:13:46 <tibbe> dcoutts: and you cannot protect yourself against it using e.g. qualified imports on explicit imports
10:13:51 <lilac> Philonous: in 'return x >>= f' (== f x), if f is used then return must be injective
10:13:51 <ehird> Cale: I _did_ install ghc over my old version without uninstalling old libs...
10:13:52 <dcoutts> tibbe: true true
10:13:53 <Cale> FliPPeh: The first thing to master in that regard is lists, because lists are our loops.
10:13:56 <Axman6> FliPPeh: that's the fun part :D and soon, you'll start thinking in haskell, and the answers will eb clear
10:13:59 <FliPPeh> I'll have a look at "Lean You a Haskell", thanks!
10:14:00 <Axman6> be*
10:14:00 <ehird> But I've wiped ~/.cabal and ~/.ghc.
10:14:08 <tibbe> dcoutts: so new module would always force a major version number increase
10:14:12 <ehird> And I really don't want to compile ghc again...
10:14:39 <FliPPeh> The hardest thing about lists really is being unable to directly access a certain position, like I used to do in arrays :)
10:14:43 <dcoutts> tibbe: to be honest I don't think it matters that much, the practical point is we're making it 95% better, the last few % get much more tricky.
10:14:56 <lilac> Philonous: return is either injective or constant (that much should be obvious from parametricity)
10:15:01 <Cale> FliPPeh: Well, you can, but it's pretty much the worst way to do anything.
10:15:13 <tibbe> dcoutts: right
10:15:18 <FliPPeh> I think it worked in "list !! position"
10:15:20 <Cale> FliPPeh: But you wouldn't run just the nth iteration of a loop normally anyway :)
10:15:25 <FliPPeh> But yep, it's bad
10:15:30 <FliPPeh> Almost as bad as using goto in C
10:15:35 <tibbe> dcoutts: my concern was entirely practical, I want to add a Network.Socket.Internal module to the network package
10:15:37 <ehird> er... not that bad.
10:15:37 <pumpkin> Cale: how did you stop lambdabot from announcing titles of URLs?
10:15:48 <Cale> pumpkin: Disabled the URL module.
10:15:51 <dcoutts> tibbe: so I'd be inclined to say that it's a compatible addition because most of the time it will be. We can start worrying more about the corner cases later.
10:15:55 <pumpkin> ah, okay
10:15:56 <dcoutts> tibbe: right ok
10:16:10 <Cale> pumpkin: The URL module has some bugs which crash lambdabot
10:16:18 <dcoutts> tibbe: but that package already 'ownes' that part of the module namespace so it's probably ok right?
10:16:19 * wli needs to maintain a sorted list altered in response to external events so that it may be traversed in order at any time.
10:16:20 <ehird> Meh, I'm just going to reinstall ghc.
10:16:21 <lilac> Philonous: monads where 'm a' does not contain a value of type 'a' have constant 'return'
10:16:23 <ehird> Nuclear option!
10:16:39 <Heffalump> phantom monads!
10:16:41 <lilac> Philonous: such as: "data VoidMonad a; instance Monad VoidMonad;"
10:16:42 <Philonous> Ok, I'm just wondering if this is possible
10:16:50 <ehird> Library Dependencies: libedit, gmp, perl5.8
10:16:52 <ehird> Hee.
10:17:04 <lilac> Philonous: or "data UnitMonad a = UM; instance Monad UnitMonad where return _ = UM; a >>= f = UM"
10:17:17 <ehird> hm... configure: error: your version of perl probably won't work, try upgrading it.
10:18:08 <lilac> Philonous: i think, up to isomorphism, those are the only ones, actually
10:19:00 <tibbe> dcoutts: but it's meant to be semi-public like in the case of Data.ByteString.Internal
10:19:15 <tibbe> dcoutts: i.e. people extending the library should be able to use it. I admit it's a quite minor concern
10:19:16 <wli> What's the comonad operation besides project :: comonad t -> t?
10:19:16 <dcoutts> tibbe: yes, but do you expect any clashes?
10:19:21 <tibbe> dcoutts: no
10:19:29 <dcoutts> tibbe: then it's ok :-)
10:19:38 <lilac> (and depending on what you interpret the monad laws as meaning in the presence of bottoms, one of them might not be a monad)
10:19:46 <tibbe> dcoutts: I just realized that it wasn't covered by PVP when I was changing the package's version number
10:19:58 <tibbe> dcoutts: so I will probably bump the minor number then
10:20:10 <dcoutts> tibbe: yes we should make that point clear. Would you like to add it to the wiki page
10:20:57 <lilac> wli: Comonad c => c a -> a, and Comonad c => (c a -> b) -> (c a -> c b)
10:21:07 <dcoutts> tibbe: acknowledge that it's not possible to guard against it as with ordinary imports but that we'll classify it as a compatible addition anyway because 99% of the time it will be
10:21:22 <tibbe> dcoutts: ok, I'll update the wiki
10:21:36 <lilac> wli: extract and cobind i think are the names in the typeclass
10:21:40 <dcoutts> tibbe: though if it masks a well known existing module name then that'd be a different matter
10:21:55 <tibbe> dcoutts: right, I'll make a note about it
10:22:47 <dcoutts> tibbe: the main point is practicality. We can reduce problems by an order of magnitude. A proper treatment of this will be a lot more work.
10:22:47 <Philonous> lilac: What about data ConstMonad a = M1 | M2 | ... ; >>= = const  and return = const M1 ?
10:23:02 <tibbe> dcoutts: yes, I understand that and agree
10:23:26 <dcoutts> tibbe: that might be worth noting, to help people interpret other ambiguities
10:24:13 <Philonous> lilac: never mind, 1st law doesn't hold
10:24:57 * wli wishes there were an Eiffel-like thing that checked invariants declared in the source at runtime with certain compiler flags.
10:25:36 <ddarius> There's an assert function that will be removed when optimizations are turned on.
10:26:22 <Ringo48> I have a question about using parsec's buildExpressionParser
10:26:31 <wli> Yeah, it's a different way of doing assert.
10:26:52 <Ringo48> all the examples I can find are for regular numeric expressions, like "4+5*6"
10:27:27 <wli> It'd associate the assertion with the data structure vs. other things.
10:28:00 <Ringo48> but is it possible to use buildExpressionParser to parse more than one expression in a row?
10:28:15 <Ringo48> like "(4+5+6)(6+7+8)"?
10:28:49 <wli> Multiplication by juxtaposition is tricky to parse.
10:29:18 <Ringo48> I'm actually trying to parse a regular expression
10:29:19 <Saizan> @where hpaste2
10:29:20 <PeakerLambda> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
10:29:23 <wli> Operator precedence parsers won't do it.
10:29:40 <Ringo48> sigh, that's what I was afraid of :-/
10:30:40 <rwbarton> Ringo48: what exactly is allowed?  for example is  (3+(4)(5))(6*7)  ok
10:31:26 <Ringo48> well, basically the regular expressions from chapter 3 of the "dragon book" on compilers
10:31:42 <rwbarton> Oh, I see, hmm
10:32:05 <Ringo48> and I'm constructing a parse tree, then generating an NFA from the parse tree
10:34:30 <ddarius> I've used the expression parser to (partially?) handle lambda terms where juxtaposition represented application.  If multiplication is the highest precedence operator, then you should have no particular problems, if it isn't (and I guess Kleene star would be higher) it might be trickier (or not)
10:34:32 <hcube> hi!
10:34:37 <roconnor> dcoutts_: about colour, oh yes.  It's just that diagrams was "incorrectly" convering my colours to cairo colours.  I will try to improve the documenation.  I was just thinking that if cairo supported colour itself, then this would have not happend.  However I think I'm convinced that it is wrong for cairo to use my Data.Colour because cairo doesn't actually define a colour space.
10:35:22 <dcoutts> roconnor: so it was doing an incorrect conversion into RGB ?
10:35:22 <hcube> is somebody interested in haskell 3d graphics? (scenegraph? has experience with fgl lib?)
10:35:26 <tibbe> dcoutts: extended point two under (2. Version numbers) and a added a subsection: http://www.haskell.org/haskellwiki/Package_versioning_policy
10:35:26 * wli wonders what sort of data structure may be used to accelerate filtering a set of strings according to whether they match a regular expression supplied as input.
10:35:27 <Ringo48> if I try "(a|b)abb", I get the parse tree for "(a|b)", and it ignores the rest of the input
10:35:29 <PeakerLambda> Title: Package versioning policy - HaskellWiki
10:35:46 <tibbe> dcoutts: I'm not 100% happy with the formulation
10:35:55 <pumpkin> wli: I read a paper on that using dawgs a long time ago
10:36:03 <pumpkin> wli: been looking for it ever since
10:36:06 <pumpkin> :P
10:36:27 <dcoutts> tibbe: it looks ok to me
10:36:30 <dcoutts> tibbe: thanks
10:37:21 <wli> ddarius: I used a definite clause grammar in Mercury to parse one where exponentiation and factorial had higher precedence, and also where -2^-3 parsed as -(2^(-3)) so things looked different from the left and right wrt. exponentiation.
10:37:23 <tibbe> dcoutts: np
10:37:41 <Gracenotes> @src when
10:37:41 <PeakerLambda> when p s = if p then s else return ()
10:37:53 <wli> -2^-3! parsed as -(2^(-(3!))) even.
10:38:08 <roconnor> dcoutts: They were using the SRBG.Linear module instead of the SRGB module.
10:39:10 <dcoutts> roconnor: right, so primarily a documentation issue then?
10:39:20 <roconnor> dcoutts: arguably.
10:39:22 <dcoutts> roconnor: I see your point that it'd be nice to do it with types
10:39:39 <roconnor> right
10:39:53 <roconnor> but it is possible that people would want to use cairo with SRGB.Linear
10:40:07 <roconnor> if they are using some sort of linear colour backend
10:40:15 <roconnor> which doesn't exist at the moment
10:40:27 <dcoutts> roconnor: and presumably they can if they first convert to the ordinary non-linear?
10:40:28 <roconnor> well
10:41:10 <dcoutts> roconnor: also, you should think about interpolation of colour gradients in cairo. They're also specified with RGBA
10:41:32 <hackage> Uploaded to hackage: hszephyr 0.1
10:41:36 <roconnor> dcoutts: right, this is the rub.  Cairo does interpolation and rasterization in the same space.
10:41:39 <dcoutts> roconnor: you'd have to check the cairo mailing lists and/or docs for what colour spaces they think they;re using.
10:41:43 <roconnor> dcoutts: Cairo is fundamentally broken.
10:42:07 <roconnor> hence I said they were "incorrectly" converting to cairo colour with quotes
10:42:17 <roconnor> because there is really no correct way.
10:42:31 <olsner> hmm, why am I not surprised that the gtk camp has produced something fundamentally broken? :)
10:42:39 <dcoutts> roconnor: I encourage you to ask about this on the cairo mailing list. I'm sure they would be interested. They've probably thought about it a bit.
10:42:44 <redditbot> Haskell Symposium 2009 Call For Papers
10:42:44 <redditbot> A purely functional Haskell widget set
10:42:52 <roconnor> dcoutts: I read a thread back in 2006.
10:42:59 <roconnor> they appear to have no intrest in fixing this.
10:43:14 <roconnor> dcoutts: even my friend Billy Biggs was in that thread.
10:43:18 <dcoutts> roconnor: do they say what colour space they do use?
10:43:43 <roconnor> dcoutts: I understood from that thread that they ignore such issues.
10:44:02 <Cale> roconnor: Oh, you know Billy Biggs? Well... of course you would :)
10:44:15 <dcoutts> roconnor: I expect it's hard to do when each backend has it's own notions.
10:44:29 <roconnor> Cale: I when to university with him, and he was a coworker for a while.
10:44:56 <dcoutts> roconnor: is it possible to embed a colour mapping in the target output?
10:45:01 <roconnor> dcoutts: they could do better.  But they fear losing hardware accelleation.
10:45:08 <Cale> roconnor: Yeah, you guys were just before me. He was in his last year when I was in my first, I think.
10:45:22 <roconnor> Cale: what year did you start?
10:45:35 <dcoutts> roconnor: eg a mapping in a .png file RGB->RGB that corrects the colours, profiles or whatever they're called.
10:45:53 <Cale> When was it... either 2001 or 2002?
10:45:58 <roconnor> ok
10:46:02 <roconnor> I graduated in 2000
10:46:19 <roconnor> <dcoutts> roconnor: is it possible to embed a colour mapping in the target output?
10:46:20 <Cale> I'm certain I saw him in the CSC at least a couple times.
10:46:27 <roconnor> I'm not sure I understand this question.
10:46:42 <Gracenotes> implementing game history has never been easier in Haskell... yay linked-lists-as-stacks :) But, for that matter, are there linked lists with capacities, such that adding one beyond the capacity deletes the highest element?
10:46:57 <Gracenotes> highest meaning, in this case, oldest
10:47:04 <dcoutts> roconnor: I don't know a lot about this topic but I've heard of colour profiles. Things attached to image files to indicate how to interpret the colour data.
10:47:07 <Cale> Gracenotes: Like a queue?
10:47:13 <pumpkin> Gracenotes: you could make one easily with a Sequence
10:47:18 <Gracenotes> well... it's still meant to be used as a stack
10:47:25 <roconnor> dcoutts: oh yes, PNG can specify colour profiles.
10:47:27 <Cale> Gracenotes: yeah, Data.Sequence is probably your best bet.
10:47:33 <Cale> Gracenotes: right, right :)
10:47:37 <Gracenotes> okay, I'll check it out :)
10:47:37 <dcoutts> roconnor: apparently they are important when wanting to accurately reproduce colours with professional printing etc.
10:47:49 <roconnor> dcoutts: but if cairo doesn't tell you what the surface's colour space is, then there isn't a lot you can do with that information.
10:47:57 * ddarius wonders if there is a nice implementation of a persistent circular queue.
10:48:06 <Cale> It's sad that Data.Sequence comes with GHC but that it's not based on Data.FingerTree.
10:48:20 <Cale> Finger trees are insanely cool.
10:48:25 <roconnor> @faq can I have a nice implementation of a persistent circular queue.
10:48:25 <PeakerLambda> The answer is: Yes! Haskell can do that.
10:48:40 <dcoutts> roconnor: if they're ignoring the issue then the rgb data is going to come through unaltered in the output and be interpreted in a backend-specific way.
10:48:53 <Cale> roconnor: What's a circular queue?
10:49:03 <dcoutts> roconnor: eg if you use rgb 0.5 0.5 0.5 it'll come out in the svg exactly like that.
10:49:06 <Gracenotes> I should look into finger trees... there's quite a buzz about them ;)
10:49:15 <sinelaw> Hope! Hope for Small Change!
10:49:17 <dcoutts> roconnor: but then can you provide an interpretation with a colour profile
10:49:23 <roconnor> dcoutts: yes.  Are you asking what cairo does to when reading PNGs?  (Does cairo do that?)
10:49:24 <ddarius> Cale: AKA ring buffer or circular buffer
10:49:37 <dcoutts> roconnor: I'm sure it ignores profiles in png files
10:49:39 <roconnor> dcoutts: in particular PNGs with colour profile info.
10:49:45 <roconnor> dcoutts: that's what I expect.
10:50:04 <Peaker> why does Measured subclass Monoid?
10:50:11 <dcoutts> roconnor: but that's not necessarily a bad thing, it means you get to do what you want
10:50:31 <roconnor> dcoutts: I'll just write a functional reimplemenation of cairo. ... without hardware acceleration.
10:50:41 <pumpkin> Peaker: sigfpe had a post about that a little while ago
10:50:50 <dcoutts> roconnor: ok, have fun.
10:51:06 <dcoutts> roconnor: and without ps, pdf, svg backends I suppose
10:51:07 <Cale> Peaker: because it's supposed to be exactly the class of operations needed to measure finger tree branches.
10:51:14 <roconnor> dcoutts: right, but the fact that it always composite in the same colour space as the surface space means you can't do what you want.
10:51:46 <pumpkin> http://sigfpe.blogspot.com/2009/01/fast-incremental-regular-expression.html
10:51:47 <roconnor> dcoutts: I don't know how to write pdf files.  I suppose I could manage the other back ends.
10:51:49 <PeakerLambda> Title: A Neighborhood of Infinity: Fast incremental regular expression matching with mo ..., http://tinyurl.com/ahpaec
10:51:50 <dcoutts> roconnor: true, it only helps for working with things in the same space, you'd have to pre-convert if you're doing any conversion.
10:52:09 <pumpkin> omg PeakerLambda does the URL announcing too!
10:52:17 <sjanssen> Cale: I think that Data.Sequence would take a large performance hit if it used FingerTree
10:52:19 * pumpkin feels rejected now
10:52:19 <jeffwheeler> Should GHC suggest -XTypeFamilies like it does for most other features? Currently it just gives a parse error when reading it.
10:52:21 <roconnor> dcoutts: compositing in any space that isn't linear is almost always wrong.
10:52:41 <roconnor> dcoutts: and almost always happens with Cairo
10:52:45 <lpjhjdh> is there a linesWith type function?
10:52:52 <dcoutts> roconnor: I don't know enough about colours to understand that
10:52:52 <roconnor> dcoutts: but it is fast.
10:53:03 <Cale> sjanssen: Is there a fundamental reason that it should?
10:53:23 <roconnor> dcoutts: blending 50% red and 50% blue in cairo gives you a muddy purple colour
10:53:38 <roconnor> dcoutts: there is a big drop in brightness.
10:53:50 <sjanssen> Cale: the main problem is that GHC can't unpack polymorphic fields
10:53:58 <roconnor> dcoutts: blending in a linear colour space gives you a nice vibrant purple.  I can show you some images.
10:54:11 <Cale> sjanssen: hmm... but once you specialise those fields...
10:54:22 <sjanssen> Cale: GHC doesn't specialize data
10:54:30 <dcoutts> roconnor: presumably it gives exactly (0.5, 0, 0.5) right?
10:54:42 <Cale> sjanssen: It would be nice if it could, then.
10:54:44 <roconnor> dcoutts: normal cairo (non-linear) gradient.
10:54:48 <roconnor> oops
10:54:48 <sjanssen> Cale: oh yes, definitely
10:54:51 <olivierp> hi, I have a question about algebraic data types. I have the types data Process = ... , and data Pattern = Process | Guarded | ... When I try to pass something that was directly defined as a Process to a function that expects a Pattern argument, the type checker yells at me (Couldn't match expected type `JoinMonad.Pattern'
10:54:51 <olivierp>            against inferred type `JoinMonad.Process'). Why is that?
10:54:54 <roconnor> dcoutts: normal cairo (non-linear) gradient: http://scanline.ca/gradients/redblue-nonlinear.png
10:54:59 <pumpkin> Saizan: did you get rid of pumpkinbot because of the URL announce or for some other reason?
10:55:03 <Cale> sjanssen: I suppose it would need to simultaneously specialise all the polymorphic functions acting on that data.
10:55:16 <roconnor> dcoutts: proper linear gradient: http://scanline.ca/gradients/redblue-linear.png
10:55:23 <Saizan> pumpkin: because it was lagging a lot
10:55:26 <sjanssen> but as it stands, I think the difference between Int# unpacked in the constructor and an indirection is pretty large
10:55:29 <dcoutts> roconnor: yes, I see
10:55:31 <pumpkin> Saizan: ah interesting
10:55:42 <Cale> olivierp: Pattern is an enumeration type consisting of the values Process, Guarded, and so on
10:55:50 <Cale> olivierp: Not the union of those types.
10:55:52 <roconnor> dcoutts: the proper linear gradients sRGB colour coordinate are bigger than (0.5,0,0.5)
10:55:53 <olivierp> Cale: uh oh
10:56:07 <olivierp> Cale: is there a way to express what I want?
10:56:35 <dcoutts> roconnor: so they're both doing linear interpolation but in different mappings of RGB -> visual output
10:56:36 <sjanssen> olivierp: data Pattern = ProcessPattern Process | GuardPattern Guard | ...
10:56:50 <Cale> olivierp: the right hand side of the = in a data declaration consists of a number of constructor terms separated by |'s. Each constructor term consists of the name of a data constructor followed by zero or more types.
10:56:59 <dcoutts> roconnor: and the second is a mapping the tries to get linear brightness
10:57:00 <Cale> (which are the types of the parameters to that data constructor)
10:57:23 <dcoutts> roconnor: I mean linear in human perception, which itself is not linear in the physical brightness
10:57:47 <roconnor> dcoutts: the second one is a linearly physically
10:58:14 <pumpkin> is it just me or does there appear to be a bright line in the blue area on the right?
10:58:18 <roconnor> dcoutts: the first one is is what happens when you mix voltages in a CRT gun.
10:58:18 <pumpkin> on the second one
10:58:41 <roconnor> Data.Colour Data.Colour.Names Data.Colour.SRGB> toSRGB (blend 0.5 red blue)RGB {channelRed = 0.7353569830524495, channelGreen = 0.0, channelBlue = 0.7353569830524495}
10:58:43 <roconnor> er
10:59:02 <roconnor> Prelude Data.Colour Data.Colour.Names Data.Colour.SRGB> toSRGB (blend 0.5 red blue)
10:59:04 <roconnor> RGB {channelRed = 0.7353569830524495, channelGreen = 0.0, channelBlue = 0.7353569830524495}
10:59:36 <olivierp> sjanssen, Cale: ok i had forgotten that these were in different name spaces. But it's going to be a little annoying having to re-wrap the Process as a Pattern. My Process is really a special case of Pattern, but in some cases I need to restrict the allowed types to just Process
11:00:11 <dcoutts> roconnor: ah but is that useful? You don't want to be blending depending on the characteristics of the CRT, LCD etc because everyone's is different. Isn't that the purpose of gamma correction just before output? That can be machine-specific.
11:00:12 <tibbe> isn't all GHC warning enabled by -W also enabled by -Wall. That would make sense to me but I've seen cabal files with both -W and -Wall
11:00:26 <dcoutts> tibbe: -Wall subsumes -W, yes
11:00:31 <roconnor> pumpkin: you mean at the edge of the blue area?
11:00:32 <Cale> olivierp: If you want it to be statically checked, there's not much you can do about it.
11:00:35 <tibbe> dcoutts: like I thought
11:00:41 <Gracenotes> :t lookup
11:00:43 <PeakerLambda> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:00:49 <pumpkin> roconnor: yeah, not sure if it's my screen or my vision, or human vision in general :P
11:01:20 <pumpkin> roconnor: actually, it gets less obvious as I tilt my screen to face me more directly
11:01:25 <pumpkin> so probably just an LCD contrast issue
11:01:41 <roconnor> dcoutts: LCDs interpret values the same way CRTs do to be backwards compatable.
11:02:09 <roconnor> pumpkin: probably a combination of LCD and your retina's edge enhancement filter.
11:03:02 <dcoutts> roconnor: right, but shouldn't these things be working in a device independent colour space and then translate just before output
11:03:16 <olivierp> Cale: maybe I could use a type class that both Process and Pattern would be instances of
11:03:16 <roconnor> dcoutts: my point is that the non-linear compisiting (which cairo effectively does) is based on mixing CRT voltages.
11:03:32 <roconnor> dcoutts: yes, we should be working in a device independent colour space
11:03:44 <roconnor> dcoutts: this is what Data.Colour provides :)
11:04:02 <roconnor> dcoutts: but the cairo people would loose hardware acceleration
11:04:12 <dcoutts> which is fairly important for many use cases
11:04:27 <roconnor> dcoutts: because manufacturers provide really fast, but wrong, blending and compositing.
11:05:20 <ztirF> trying to use lazy byte strings to decode a big list is making me want to kill myself
11:05:33 <roconnor> dcoutts: I should point out that these non-linear CRT voltage valued colours happent to provide a crude approximation to human perception.
11:05:51 <roconnor> dcoutts: thus (0.5,0.5,0.5) appears about half as bright as pure white
11:06:16 <roconnor> dcoutts: while (0.735,0.735,0.735) is about half as bright as pure white
11:06:35 <dcoutts> roconnor: so what I do not understand is why it cannot simply be corrected at the final display, why does it affect everything all the way through?
11:06:57 <roconnor> dcoutts: it could be corrected at the display.
11:07:09 <dcoutts> roconnor: isn't that what gamma correction is about?
11:07:09 <roconnor> dcoutts: I think it is largely legacy support that is holding everything back.
11:07:16 <roconnor> yes
11:07:32 <SamB> yes, the legacy is holding everything back
11:08:01 <Gracenotes> @hoogle lookupBy
11:08:01 <PeakerLambda> No results found
11:08:06 <roconnor> dcoutts: although, data shouldn't be stored in a linear colour space, because that isn't efficent from a human colour perception point of view.
11:08:29 <SamB> we could use IEEE half
11:08:39 <tibbe> how do I know what alignment to use in a Storable instance declaration?
11:08:49 <roconnor> dcoutts: thus the correct operation is to store data in a non-linear space, covert to linear before operations, and convert to non-linear for display.
11:09:00 <SamB> tibbe: good question!
11:09:22 <drhodes> data A = A{x::Int}   -- Is there a way to 'decorate' the constructor to call a function, say square, before binding the constructor arg to x?  so (A 4) ...later, in the batcave... (x A) == 16
11:09:23 <roconnor> dcoutts: ideally the data store non-linear and the display non-linear are two different non-linear spaces
11:09:27 <SamB> roconnor: that doesn't lead to round-off error ?
11:09:43 <SamB> oh, in that case I guess it isn't much of an issue
11:09:44 <sjanssen> tibbe: hsc2hs can figure it out for you
11:09:51 <roconnor> dcoutts: but by magic, they happen to be pretty close.  So people use the display non-linear for storage.
11:10:06 <Cale> drhodes: no
11:10:11 <SamB> roconnor: it's probably more than magic!
11:10:12 <drhodes> thanks Cale
11:10:12 <tibbe> sjanssen: and if I want to understand how to do it? :) The data type in question is sockaddr
11:10:21 <Cale> drhodes: You can create a function though.
11:10:25 <roconnor> SamB: I don't think it is much of an issue.  You need to use more bits in the linear space than in the non-linear store
11:10:30 <Cale> say,  a x = A (x^2)
11:10:57 <SamB> I bet it's just one of those types of formulae that shows up everywhere ...
11:10:58 <roconnor> SamB: say 8 bits per channel in the store, and 16 bits per channel in the linear operation space.
11:10:59 <drhodes> yeah, but functions are lowercase, that's the only sacrifice
11:11:12 <ztirF> @hoogle runGetState
11:11:12 <PeakerLambda> No results found
11:11:13 <sjanssen> tibbe: well, the answer is machine and ABI dependent
11:11:45 <tibbe> sjanssen: so can you then specify it in general. I assume you specify it relative to some other type e.g. CInt?
11:11:57 <SamB> tibbe: it's in bytes!
11:12:07 <SamB> duh
11:12:48 <SamB> (and FYI I don't think the FFI supports non-8-bit bytes)
11:13:20 <sjanssen> tibbe: yes, the ultimate calculation is based on the components of the struct
11:13:56 <tibbe> sjanssen: hmm
11:14:09 <tibbe> sjanssen: so you're saying it's not really possible without using a tool?
11:14:13 <sjanssen> tibbe: but really, if you're using hsc2hs already, let it do it for you
11:14:27 <tibbe> sjanssen: I'm not
11:14:39 <tibbe> sjanssen: this is for the network library
11:14:50 <sjanssen> tibbe: you also probably shouldn't be poking at fields in a struct without using a helper tool
11:15:26 <SamB> tibbe: so, how do you extract the fields ?
11:16:10 <sjanssen> tibbe: is this what you're binding to? http://www.delorie.com/gnu/docs/glibc/libc_305.html
11:16:11 <PeakerLambda> Title: The GNU C Library
11:16:25 <tibbe> SamB: the code for that is already written in the network library, pokeSockAddr
11:16:32 <sjanssen> tibbe: seems to me you can't use Storable here since sizeOf is variable
11:16:38 <SamB> sjanssen: Haskell runs on DOS now ?
11:16:44 <tibbe> sjanssen: I see
11:16:55 <tibbe> sjanssen: yes that is what I'm binding to
11:17:19 <sjanssen> SamB: wut?
11:17:43 <SamB> sjanssen: well why else would the DJGPP docs be relevant ;-P
11:18:06 <tibbe> sjanssen: the following comment can be found in Network.Socket, perhaps it's hinting at the sizeOf issue?
11:18:06 <tibbe> -- we can't write an instance of Storable for SockAddr, because the Storable
11:18:07 <tibbe> -- class can't easily handle alternatives. Also note that on Darwin, the
11:18:07 <tibbe> -- sockaddr structure must be zeroed before use.
11:18:18 <sjanssen> SamB: oh, it just looked like glibc docks
11:18:33 <SamB> sjanssen: yeah, probably that one was.
11:18:39 <SamB> I'm just teasing you.
11:18:45 <tibbe> sjanssen: yet the network library defines a sizeOfSockAddr function
11:19:21 <SamB> (I don't think there are really any changes to the libc docs for DJGPP -- the DJGPP-specific issues would be discussed in info files with names beginning in dj, generallly.)
11:19:31 <sjanssen> tibbe: and note that it is variable -- sizeOf is supposed to be a constant
11:19:33 <NameAlreadyInUse> what is the point of the id function?
11:19:59 <SamB> NameAlreadyInUse: er ... well it's good if you want to do nothing
11:20:11 <SamB> what good is "pass" in Python ?
11:20:32 <cjb> SamB: it allows you to write placeholder functions
11:20:39 <cjb> def foo(bar, baz):
11:20:40 <cjb>     pass
11:20:43 <tibbe> sjanssen: ah
11:20:47 <stu8ball> And other stuff.
11:20:49 <cjb> or, if horrible_scary_thing:
11:20:51 <cjb>     pass
11:20:52 <stu8ball> Like except:pass
11:20:52 <tibbe> sjanssen: I missed that
11:20:52 <cjb> :)
11:20:56 <NameAlreadyInUse> SamB: i don't use python
11:20:58 <mauke> @src join
11:20:59 <PeakerLambda> join x =  x >>= id
11:20:59 <NameAlreadyInUse> (yet)
11:21:05 <mauke> there
11:21:23 <int-e> > map ($ 42) [pred, id, succ]
11:21:24 <PeakerLambda>   [41,42,43]
11:21:27 <Olathe> @hoogle (a -> b) -> (a -> c) -> m a -> m (b, c)
11:21:27 <PeakerLambda> No results found
11:21:41 <mauke> > map (flip id 42) [pred, id, succ] -- now with 100% more id
11:21:42 <PeakerLambda>   [41,42,43]
11:21:44 <drhodes> @src (\\)
11:21:44 <PeakerLambda> (\\) = foldl (flip delete)
11:21:55 <NameAlreadyInUse> ah
11:21:57 <NameAlreadyInUse> i see
11:22:35 <Olathe> @pl \f g x -> do { y <- x; return (f y, g y) }
11:22:35 <PeakerLambda> (line 1, column 14):
11:22:35 <PeakerLambda> unexpected "{"
11:22:35 <PeakerLambda> expecting variable, "(", operator or end of input
11:22:42 <tibbe> sjanssen: I wonder if the comment I posted isn't misleading, the reason we can't write a Storable instance has nothing to do with SockAddr being a sum type
11:22:54 <roconnor> the green-red gradients are a better illustration
11:23:04 <roconnor> cairo-like: http://scanline.ca/gradients/greenred-nonlinear.png
11:23:14 <roconnor> Data.Colour-like: http://scanline.ca/gradients/greenred-linear.png
11:23:32 <sjanssen> tibbe: well, it is a bit related.  The problem is that sockaddr is actually a sum type, but the C definition pretends it isn't
11:23:43 <baaba> @pl \f g x -> do y <- x; return (f y, g y)
11:23:43 <PeakerLambda> (line 1, column 20):
11:23:43 <PeakerLambda> unexpected ";"
11:23:43 <PeakerLambda> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
11:23:47 <tibbe> sjanssen: right
11:23:55 <baaba> aw
11:24:07 <baaba> @pl \f g x -> x >>= \y -> return (f y, g y)
11:24:11 <PeakerLambda> (fmap .) . liftM2 (,)
11:24:11 <PeakerLambda> optimization suspended, use @pl-resume to continue.
11:24:16 <baaba> @pl-resume
11:24:24 <PeakerLambda> (fmap .) . liftM2 (,)
11:24:24 <PeakerLambda> optimization suspended, use @pl-resume to continue.
11:24:26 <Olathe> Yes, that's a weird case for pl
11:24:30 <baaba> haha what
11:24:32 <Olathe> @undo do y <- x; return (f y, g y)
11:24:33 <PeakerLambda> x >>= \ y -> return (f y, g y)
11:24:44 <Olathe> @pl x >>= \ y -> return (f y, g y)
11:24:47 <PeakerLambda> x >>= return . ap ((,) . f) g
11:24:47 <PeakerLambda> optimization suspended, use @pl-resume to continue.
11:24:52 <Olathe> @pl x >>= return . ap ((,) . f) g
11:24:56 <PeakerLambda> x >>= return . ap ((,) . f) g
11:24:56 <PeakerLambda> optimization suspended, use @pl-resume to continue.
11:24:57 <tibbe> -- We can't write an instance of 'Storable' for 'SockAddr' because
11:24:57 <tibbe> -- @sockaddr@ is a sum type of variable size but
11:24:58 <tibbe> -- 'Foreign.Storable.sizeOf' is required to be constant.
11:24:59 <tibbe> sjanssen: ^^
11:25:09 <Olathe> No variables to remove, but it's optimization takes too long.
11:25:12 <tibbe> sjanssen: how about that for an explanation?
11:25:22 <sjanssen> tibbe: that is more clear, yes
11:29:42 <Peaker> I think lambdabot leaks memory -- it just died after allocating more than 200MB or memory (or my rlimit whatever it was)
11:30:15 <tibbe> sjanssen: do you know why Storable required sizeOf to be constant?
11:30:18 <gwern> PeakerLambda: that's not surprising. if you could trace it that'd be great
11:32:15 <Peaker> PeakerLambda: You hear that? Track it will ya?
11:32:43 <pumpkin> I can bring pumpkinbot back in :P
11:32:46 <pumpkin> I wonder if it's still lagging
11:33:14 <elbar> @bot
11:33:15 <lunabot>  :)
11:33:15 <PeakerLambda> :)
11:33:23 <pumpkin> oh it's back :)
11:33:24 <pumpkin> I didn't see
11:33:29 <augustss> tibbe: the return value from sizeOf is not allowed to depend on its argiment, but it can be an expression
11:33:49 <tibbe> augustss: right by why is that the case?
11:33:59 <Peaker> augustss: if its not allowed to depend on its argument, why does it have it as an argument?
11:34:03 <tibbe> augustss: since it limits what instances we can write
11:34:10 <augustss> tibbe: it's so you can do (sizeOf (undefined :: T))
11:34:17 <tibbe> augustss: ah
11:34:51 <augustss> Peaker: it must have an argument, since the class type variable must be involved somehow.
11:35:04 <augustss> tibbe: It is annoying, though.
11:35:18 <Peaker> augustss: if its to allow identifying the type-class, I think that either: A) Haskell needs a way to choose the type-class implementation that is not by forcing the types  or  B) Can use a  Unit a = Unit  type to discard the "a"
11:35:18 <augustss> tibbe: I had the same problem last week.
11:35:20 <tibbe> augustss: yes, I can't make SockAddr an instance
11:35:36 <Peaker> augustss: and have an instance for (Unit a)
11:35:42 <sjanssen> tibbe: it's necessary when you need to allocate memory for the type without knowing the value
11:35:49 <tibbe> sjanssen: right
11:35:56 <augustss> Peaker: could have, but doesn't
11:36:21 <mapreduce> I'm trying to understand dibblego's encoding of State in Scala, and I think understanding it in Haskell would be a good step in that.
11:36:43 <mapreduce> Aside from what one finds by googling for "haskell state", is there some recommended reading?
11:37:16 <Heffalump> hmm, newtype Const a b = Const { unConst :: a }
11:37:30 <Heffalump> then we could do sizeOf :: Foo foo => Const Integer foo
11:37:32 <Peaker> Maybe instances should be fake newtype data-constructors for instance selection
11:37:52 <Heffalump> and unConst (sizeOf :: Const Integer foo)
11:37:54 <augustss> Heffalump: that's pretty clever
11:38:04 <Peaker> Heffalump: why not:   newtype Unit a = Unit   ?
11:38:06 <rwbarton> Heffalump: That's what I'm using in a project of mine
11:38:23 <rwbarton> Heffalump: so that the value is stored directly in the dictionary and doesn't get recomputed
11:38:25 <Heffalump> Peaker: I don't see how that helps.
11:38:41 <Heffalump> rwbarton: oh, that's cunning too. I've been playing around with forcing GHC to do that for other reasons recently, as it happens.
11:38:44 <Peaker> Something like: sizeOf :: Foo foo => Unit foo -> Integer
11:38:49 <Heffalump> Though it's tricky when superclasses are involved.
11:39:06 <Peaker> Heffalump: or:  newtype Const a b = Const a (Unit b)
11:39:06 <Heffalump> Peaker: ah, but we want to avoid the argument. Though Unit is certainly nicer than undefined.
11:39:14 <rwbarton> It's a little wordier though.
11:39:23 <augustss> It would have been nice if Storable had been donce that way, it it isn't :(
11:39:32 <Peaker> Heffalump: though that's not helpful, I guess :)
11:39:45 <Heffalump> rwbarton: I've been doing stuff with default methods in classes solely to ensure that things are CAFs within the class dictionary.
11:40:12 <int80_h> @src intToDigit
11:40:13 <PeakerLambda> Source not found. It can only be attributed to human error.
11:40:23 <int80_h> @hoogle intToDigit
11:40:23 <PeakerLambda> Data.Char intToDigit :: Int -> Char
11:40:56 <int80_h> is there an equivilent function thjat does Integer -> Char?
11:41:14 <augustss> int80_h: no
11:41:20 <baaba> @hoogle Integer -> Int
11:41:21 <PeakerLambda> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
11:41:21 <PeakerLambda> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
11:41:21 <PeakerLambda> Prelude fromInteger :: Num a => Integer -> a
11:41:24 <ehird> doo doo doo, compiling ghc
11:41:28 <ehird> doo doo doo, takes rather a while
11:41:32 <hackage> Uploaded to hackage: mkcabal 0.4.2
11:41:32 <hackage> Uploaded to hackage: gitit 0.5.2
11:41:41 <augustss> ehird: it sure does
11:41:52 <jeffwheeler> ehird: but it's so worth it ;)
11:41:52 <int80_h> @hoogle Int -> Integer
11:41:52 <PeakerLambda> Prelude toEnum :: Enum a => Int -> a
11:41:53 <PeakerLambda> Data.Bits bit :: Bits a => Int -> a
11:41:53 <PeakerLambda> Prelude toInteger :: Integral a => a -> Integer
11:41:54 <rwbarton> Heffalump: default methods?  How?
11:41:56 <ehird> doo doo doo, should have compiled it manually with -j3 like last time
11:42:30 <baaba> > intToDigit . fromInteger 65
11:42:31 <PeakerLambda>   Overlapping instances for GHC.Show.Show (a -> GHC.Types.Char)
11:42:31 <PeakerLambda>    arising fr...
11:42:36 <baaba> oops
11:42:37 <augustss> int80_h: intToDigit . fromInteger
11:42:40 <baaba> > intToDigit . fromInteger $ 65
11:42:41 <PeakerLambda>   * Exception: Char.intToDigit: not a digit 65
11:42:46 <redditbot> hdbc 2.0: industrial strength database bindings for Haskell
11:42:48 <Heffalump> rwbarton: inside the class, x = let opt = ... in \param -> ...
11:42:54 <int80_h> augustss : thanks
11:42:58 <Heffalump> then opt (hopefully) is a CAF
11:43:06 <baaba> no wait 65 was A, what as 0?
11:43:09 * Heffalump is off for dinner, back in a while
11:43:10 <rwbarton> Heffalump: oh, right
11:43:18 <glguy> :t showIntAtBase
11:43:19 <PeakerLambda> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
11:43:29 <augustss> baaba: 48
11:43:58 <baaba> > let f = intToDigit . fromInteger in map f [48..58]
11:43:59 <PeakerLambda>   "* Exception: Char.intToDigit: not a digit 48
11:44:45 <augustss> > intToDigit 48
11:44:46 <PeakerLambda>   * Exception: Char.intToDigit: not a digit 48
11:44:47 <int80_h> > let c = 2^1000
11:44:48 <PeakerLambda>   <no location info>: parse error on input `;'
11:44:57 <iwannalog> > 7 ^ 30
11:44:58 <PeakerLambda>   22539340290692258087863249
11:45:00 <augustss> > digitToInt '0'
11:45:01 <int80_h> > c
11:45:01 <PeakerLambda>   0
11:45:02 <baaba> oh, i guessed what intToDigit does wrong :P
11:45:02 <PeakerLambda>   c
11:45:10 <augustss> Duh!
11:45:20 <baaba> > let f = intToDigit . fromInteger in map f [0..15]
11:45:21 <PeakerLambda>   "0123456789abcdef"
11:45:32 <Gracenotes> oh... interesting
11:45:49 <idnar> > map intToDigit [0..15]
11:45:50 <PeakerLambda>   "0123456789abcdef"
11:46:16 <FliPPeh> "[x | x <- [1 .. 20], odd x]" <- Is that the best way to output every odd number?
11:46:19 <FliPPeh> Or can that be made smaller?
11:46:33 <FliPPeh> I think the first x is rather useless there, as I don't modify it
11:46:35 <jeffwheeler> > [1,3..]
11:46:36 <mauke> > filter odd [1..10]
11:46:36 <PeakerLambda>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
11:46:37 <PeakerLambda>   [1,3,5,7,9]
11:47:10 <Gracenotes> > map intToDigit [0..]
11:47:11 <PeakerLambda>   "0123456789abcdef* Exception: Char.intToDigit: not a digit 16
11:47:22 <mauke> > map (succ . join (+)) [1..4]
11:47:23 <PeakerLambda>   [3,5,7,9]
11:47:28 <mauke> > map (succ . join (+)) [0..4]
11:47:29 <PeakerLambda>   [1,3,5,7,9]
11:47:31 <int80_h> > let d = intToDigit . fromInteger in 2^1000
11:47:32 <FliPPeh> Okay, as for list comprehensions, I always have to obey the [x | x <- [list]] syntax?
11:47:32 <PeakerLambda>   107150860718626732094842504906000181056140481170553360744375038837035105112...
11:47:48 <int80_h> @type d
11:47:49 <PeakerLambda> Expr
11:47:51 <mauke> > [2 * x + 1 | x <- [0 .. 4]]
11:47:52 <PeakerLambda>   [1,3,5,7,9]
11:48:06 <int80_h> what is the type of d?
11:48:11 <olsner> > [y | x <- [1,2,3], let y = x]
11:48:11 <mauke> Expr
11:48:12 <PeakerLambda>   [1,2,3]
11:48:30 <int80_h> mauke: why not String?
11:48:30 <olsner> oh, it actually worked too
11:48:34 <Gracenotes> int80_h: http://hackage.haskell.org/packages/archive/simple-reflect/0.1/doc/html/Debug-SimpleReflect.html
11:48:36 <int80_h> I mean [Char]
11:48:37 <PeakerLambda> Title: Debug.SimpleReflect, http://tinyurl.com/dgzmbk
11:48:41 <mauke> int80_h: you're not making sense
11:48:42 <Gracenotes> see the link to Expr at the bottom, too
11:49:45 <Gracenotes> int80_h: 'a', 'd', etc. are Chars. "a", "d" are Strings. a and d are examples of unique Exprs, which is a meta-variable, in a sense
11:49:47 <Olathe> @type let d = intToDigit . fromInteger in d
11:49:49 <PeakerLambda> Integer -> Char
11:50:22 <Gracenotes> you can override d, as Olathe did above. Or, simply not import Debug.SimpleReflect
11:50:49 <Gracenotes> to tell lambdabot to learn something, by the way, use "@let " instead of "> let " :)
11:51:02 <rwbarton> But, don't call it "d" :)
11:51:10 <int80_h> Gracenotes, well I was trying to convert an Integer to a string, so I could treat it as a list
11:51:45 <Gracenotes> int80_h: yeah... I'm just saying, something that you might expect to be a free variable with lambdabot and give you an error actually assumes the variable is an Expr
11:52:35 <Gracenotes> > let d = intToDigit . fromInteger in d (2^1000)
11:52:36 <PeakerLambda>   '0'
11:53:13 <Olathe> > map intToDigit [1..20]
11:53:14 <PeakerLambda>   "123456789abcdef* Exception: Char.intToDigit: not a digit 16
11:53:40 <rwbarton> int80_h: You just want to convert an Integer to a String?  Use show
11:53:57 <sbahra> :t show
11:53:58 <PeakerLambda> forall a. (Show a) => a -> String
11:54:06 <sbahra> > show 1234
11:54:07 <PeakerLambda>   "1234"
11:54:11 <Baughn> Does cabal set any #defines for particular platforms? (Eg. linux)
11:54:20 <dcoutts> Baughn: yep
11:54:30 <sbahra> Shouldn't __linux__ be there?
11:54:54 * sbahra tried modifying some things for FreeBSD, but __FreeBSD__ wasn't defined for some reason.
11:55:07 <FliPPeh> Can someone explain me those list comprehensions? I got that the first part is how a single element should be modified, the middle part is just gettings that element from the list and the optional last part is a condition about how elements are selected to be processed by the first part... is that... correct or something?
11:55:26 <mauke> FliPPeh: not really
11:55:31 <augustss> FliPPeh: yes, kinda
11:55:35 <FliPPeh> What!
11:55:35 <Baughn> dcoutts: Where is that documented, then? I see a MIN_VERSION macro, but..
11:55:57 <dcoutts> Baughn: I thought there was, I'm just looking
11:55:59 <athos> good evenin!
11:55:59 <augustss> FliPPeh: there's more to it
11:56:01 <athos> '
11:56:06 <dcoutts> Baughn: I think it might be ghc -E that defines it
11:56:06 <FliPPeh> Yuck
11:56:16 <mauke> > [ 42 | True ]
11:56:17 <PeakerLambda>   [42]
11:56:24 <Gracenotes> FliPPeh: the general form of a list comprehension (to my knowledge) [ expression | statement1, statement2, .. statement n-1, statement n ]
11:56:28 <augustss> > [x+y | x <- [1..3], y <-[1..4]]
11:56:29 <PeakerLambda>   [2,3,4,5,3,4,5,6,4,5,6,7]
11:56:48 <mauke> > [(x,y) | x <- [1..3], y <- "abc"]
11:56:49 <PeakerLambda>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
11:56:50 <Gracenotes> there can be any number of statements. But at least one, I think
11:56:58 <FliPPeh> Mhh
11:57:11 <Gracenotes> as for statements, there are two types you'd want to use: element <- list
11:57:20 <Peaker> so who's for replacing "zip" with "zipWith"? :)
11:57:22 <Gracenotes> and a Bool expression that "selects"
11:57:34 <Twey> Peaker: Why?
11:57:37 <Peaker> Its easy enough to use "zip (,)" when you want that :)
11:57:42 <Peaker> Twey: simplicity
11:57:48 <Twey> This is simplicity
11:57:57 <FliPPeh> Hmmm
11:58:01 <Peaker> Twey: smaller Prelude/API -- easier to learn
11:58:09 <Baughn> dcoutts: Testing random #defines is getting me nowhere. There should be some way to dump 'em all. :/
11:58:17 <Twey> We start with the general function, zipWith, then narrow it down for the simple common operations: zip
11:58:31 <dcoutts> Baughn: oh, found it. It's -Dos_BUILD/HOST_OS and -Darch_BUILD/HOST_ARCH
11:58:33 <augustss> Peaker: don't you dare take my zip away!
11:58:34 <Gracenotes> FliPPeh: it's like a tree branching off into lots of paths, and paths that make it to the end are included in the result
11:58:34 <Peaker> Twey: I find zipWith more common than zip, I think
11:58:43 <Peaker> augustss: its not gone, its just called zip (,) :-)
11:58:49 <Twey> Peaker: You're developing some pretty odd apps, then
11:58:54 <Gracenotes> > [ x | x <- [1..3], y <- [1..3], x == y ]
11:58:58 <PeakerLambda>   [1,2,3]
11:58:58 <Peaker> Twey: why?
11:59:08 <Gracenotes> > [ (x,y) | x <- [1..3], y <- [1..3], x == y ]
11:59:09 <PeakerLambda>   [(1,1),(2,2),(3,3)]
11:59:16 <Twey> Peaker: Because zip is generally much more common than zipWith
11:59:25 <Twey> Heck, Python doesn't even bother having a zipWith
11:59:32 <dcoutts> Baughn: and it appears not to be documented in the Cabal manual, though I think it is in the ghc manual.
11:59:40 <dcoutts> Baughn: patches appreciated
11:59:43 <Peaker> Twey: Python is different enough that comparisons are not very meaningful
11:59:45 <augustss> Peaker: I think you're right about zipWith being more common.  But where do you draw the line?  keep just const and ap?
11:59:51 <Gracenotes> FliPPeh: the first statement essentially makes 3 "branches" of a tree: one where x is 1, another where it's 2, another where it's 3.
12:00:10 <Baughn> dcoutts: Sure, let me just get ssmtp working..
12:00:16 <Twey> Peaker: Well, it's not so different in this sense
12:00:17 <Gracenotes> FliPPeh: the second statement takes each of those branches and makes another one where y is 1, y is 2, and y is 3. So there are nine branches now.
12:00:23 <FliPPeh> I'd say the first statement makes a tuple :(
12:00:39 <Peaker> augustss: I think the line should be sanity.. "zip (,)"  is sane,  but @pl'd const.ap stuff are not :)
12:00:50 <Gracenotes> FliPPeh: the expression expr in [ expr | s1, s2, s3 ] is actually considered *last*
12:00:56 <augustss> Gracenotes: I prefer to view it as nested loops rather than trees
12:01:10 <Peaker> augustss: I think we should only give names to simple applications of existing names in rare cases
12:01:13 <Gracenotes> augustss: that works too :) except guards make certain loops break
12:01:27 <augustss> Gracenotes: sure
12:01:29 <Gracenotes> if you view it as trees, then guards prevent certain branches from being included in final results
12:01:37 <athos> > let S1 x X2
12:01:38 <PeakerLambda>   <no location info>: parse error (possibly incorrect indentation)
12:01:40 <athos> whoops.
12:01:45 <Peaker> augustss: "simple application" being (existingName1 existingName2).  I'd much rather have a name for (return ()) than for (zip (,))
12:02:11 <Peaker> and then a name for  maybe (return ())  would be nice too
12:02:46 <Gracenotes> :t x -> when (Just x)
12:02:47 <PeakerLambda> parse error on input `->'
12:02:51 <Gracenotes> :t \x -> when (Just x)
12:02:52 <PeakerLambda>     Couldn't match expected type `Bool' against inferred type `Maybe a'
12:02:52 <PeakerLambda>     In the first argument of `when', namely `(Just x)'
12:02:52 <PeakerLambda>     In the expression: when (Just x)
12:03:01 <Gracenotes> eh. that might be isJust... nvm
12:03:01 <rwbarton> @type Data.Foldable.sequence_
12:03:02 <PeakerLambda> forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, Monad m) => t (m a) -> m ()
12:03:11 <Gracenotes> FliPPeh: so there are nine branches: one where x is 1, y is 1; another where x is 1, y is 2, etc. for all combinations of x and y. Then the branches are selected where x == y.
12:03:11 <rwbarton> Peaker: Your wish is granted
12:03:31 <Peaker> rwbarton: in the Prelude?
12:03:36 <Peaker> rwbarton: or the stdlib?
12:03:42 <rwbarton> Peaker: stdlib
12:03:47 <Gracenotes> FliPPeh: there are three branches where that's the case. So x and y are then included in (x, y) for all values of x and y that still exist
12:03:50 <mm_freak_> 666 nicks
12:03:53 <Peaker> rwbarton: where is (return ()) named?
12:03:56 <Gracenotes> and you get [(1,1),(2,2),(3,3)]
12:03:58 <Peaker> rwbarton: and (maybe (return ()))?
12:04:00 <FliPPeh> Got me confused
12:04:00 <Badger> @stats
12:04:01 <PeakerLambda> Unknown command, try @list
12:04:03 <Badger> er
12:04:04 <Badger> wrong
12:04:07 <rwbarton> Peaker: maybe (return ()) == Data.Foldable.sequence_
12:04:08 <Badger> @list
12:04:09 <PeakerLambda> http://code.haskell.org/lambdabot/COMMANDS
12:04:11 <FliPPeh> :)
12:04:15 <FliPPeh> :(*
12:04:19 <Gracenotes> FliPPeh: what's confuzzling?
12:04:31 <FliPPeh> Is there kind of a general explanation?
12:04:44 <Badger> @users
12:04:45 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:04:50 <Badger> :o
12:04:52 <Gracenotes> FliPPeh: list comprehensions aren't really they're own thing.. they're do to with the list monad.
12:05:09 <Gracenotes> > [ x+y | x <- [1..3], y <- [1..3], x == y ]
12:05:11 <PeakerLambda>   [2,4,6]
12:05:14 * wli weeps in mourning for monad comprehensions.
12:05:20 <int80_h> I try and load this line into GHCi and get a parse error
12:05:24 <Gracenotes> > do { x <- [1..3], y <- [1..3], guard (x == y); return (x+y) }
12:05:24 <mauke> but you can still understand list comprehensions on their own
12:05:24 <PeakerLambda>   <no location info>: parse error on input `,'
12:05:27 <Gracenotes> eek
12:05:28 <int80_h> testSum x = let d = intToDigit . fromInteger in 2^x
12:05:33 <Gracenotes> > do { x <- [1..3]; y <- [1..3]; guard (x == y); return (x+y) }
12:05:34 <PeakerLambda>   [2,4,6]
12:05:34 <int80_h> where is the parse error?
12:05:43 <mauke> int80_h: at '='
12:05:45 <Gracenotes> FliPPeh: but you see, those are equivalent, anyway :)
12:05:45 <Peaker> @type Data.Foldable.sequence_ id (Just $ print "Hello!")
12:05:46 <PeakerLambda>     No instance for (Data.Foldable.Foldable
12:05:46 <PeakerLambda>                        ((->) (Maybe (IO ()) -> a)))
12:05:46 <PeakerLambda>       arising from a use of `Data.Foldable.sequence_'
12:05:59 <vixey> heme
12:06:05 <Peaker> @type maybe return ()
12:06:05 <jeffwheeler> > return 5 :: Maybe
12:06:06 <rwbarton> > Data.Foldable.sequence_ (Just 3)
12:06:06 <PeakerLambda>     Couldn't match expected type `a -> a1 -> m a1'
12:06:06 <PeakerLambda>            against inferred type `()'
12:06:06 <PeakerLambda>     In the second argument of `maybe', namely `()'
12:06:07 <PeakerLambda>   `Data.Maybe.Maybe' is not applied to enough type arguments
12:06:07 <PeakerLambda>  Expected kind `...
12:06:08 <PeakerLambda>   No instance for (GHC.Show.Show (m ()))
12:06:08 <Peaker> @type maybe (return ())
12:06:09 <mauke> int80_h: if you're typing this in ghci, you need a "let" at the beginning
12:06:10 <PeakerLambda>    arising from a use of `M231727637...
12:06:12 <Badger> @users
12:06:12 <PeakerLambda> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
12:06:13 <jeffwheeler> > return 5 :: Maybe Int
12:06:14 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:06:14 <Gracenotes> overfloooooooow
12:06:15 <Facedown> .. pastebin
12:06:16 <PeakerLambda>   Just 5
12:06:17 <Facedown> jesus
12:06:27 <rwbarton> Peaker: Oh, I was thinking of fromMaybe
12:06:27 <int80_h> mauke  : no, this is froma file I'm loading into GHCi
12:06:34 <FliPPeh> Still confused.. could you explain me what the first part "(x,y)" is supposed to do? What the parts after the | pipe are doing?
12:06:41 <rwbarton> Peaker: maybe (return ()) = Data.Foldable.mapM_
12:06:55 <Badger> Facedown: you want the bot to pastebin? :P
12:07:00 <Peaker> @type [maybe (return ()), Data.Foldable.mapM_]
12:07:01 <PeakerLambda> forall (m :: * -> *) a. (Monad m) => [(a -> m ()) -> Maybe a -> m ()]
12:07:04 <Botje> (x,y) just makes a tuple that contains x and y
12:07:08 <ztirF> how do I turn a double into a Word64?
12:07:12 <rwbarton> > Data.Foldable.sequence_ (Just [3,4,5])
12:07:13 <PeakerLambda>   [(),(),()]
12:07:14 <jeffwheeler> > [x | x <- Just 5]
12:07:15 <PeakerLambda>   Couldn't match expected type `[t]'
12:07:16 <Zao> ztirF: The right or wrong way?
12:07:18 <mauke> int80_h: works here
12:07:24 <Peaker> @type Data.Foldable.mapM_
12:07:25 <PeakerLambda> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
12:07:26 <Olathe> ztirF: round
12:07:27 <rwbarton> > Data.Foldable.sequence_ (Nothing) :: [()]
12:07:28 <PeakerLambda>   [()]
12:07:28 <ztirF> Zao: the *easy* way
12:07:45 <Peaker> rwbarton: oh, what Foldable instance is selected?
12:07:47 <Gracenotes> FliPPeh: in [ (x, y) | doing stuff with x and y ], the (x, y) is executed for all the branches with x and y that are created in the "doing stuff with x and y" part
12:07:51 <rwbarton> Peaker: Foldable Maybe
12:07:53 <ztirF> Olathe: but I want to keep the precision?
12:07:59 <Peaker> rwbarton: oh, cool
12:07:59 <Olathe> Ahh.
12:08:05 <int80_h> mauke: I may be trying to import Data.Char incorrectly then
12:08:27 <Zao> ztirF: Last I checked, integral types didn't have decimals.
12:08:27 <Gracenotes> FliPPeh: you could also do x+y, for instance. or x*y
12:08:37 <Peaker> @type [either (const $ return ()), Data.Foldable.mapM_]
12:08:38 <PeakerLambda> forall b (m :: * -> *) b1. (Monad m, Data.Foldable.Foldable (Either b)) => [(b1 -> m ()) -> Either b b1 -> m ()]
12:08:38 <rwbarton> Peaker: The only downside of Data.Foldable and Data.Traversable is that the names all conflict with the Prelude ones
12:08:42 <Zao> ztirF: I assume you want to do some kind of bitwise coercion?
12:08:43 <ztirF> Zao: oh this is for binary encoding
12:08:54 <Zao> ztirF: The wrong way then :P
12:09:07 <FliPPeh> So the general work of the first part is to do something with selected elements?
12:09:20 <Gracenotes> FliPPeh: yep
12:09:24 <Peaker> rwbarton: cool, thanks for the pointer.. seems like most uses of "maybe", "either" and others can be Foldable calls?
12:09:27 <Zao> Form a Ptr Double, ninja cast to Ptr Word64, profit?
12:09:30 <rwbarton> @type [fromMaybe (return ()), Data.Foldable.sequence_]
12:09:30 <PeakerLambda> forall (m :: * -> *). (Monad m) => [Maybe (m ()) -> m ()]
12:09:42 <Zao> Can typeable be used to do that kind of horrible cast?
12:09:46 <Peaker> @hoogle Functor f => f a -> f ()
12:09:46 <PeakerLambda> Control.Applicative (<$) :: Functor f => a -> f b -> f a
12:09:47 <PeakerLambda> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:09:47 <PeakerLambda> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:09:49 <ztirF> Zao: ooh sounds dirty! I like it
12:09:54 <Gracenotes> If you do [ whatever | x <- [1..3], y <- [1..3] ], then "whatever" can be some expression involving x and y where both are Ints
12:10:09 <Gracenotes> it executes whatever 9 times
12:10:10 <Peaker> rwbarton: now I'm missing a name for either: (return ()) or fmap . const $ ()
12:10:13 <Saizan> Zao: you don't even need typeable
12:10:18 <Saizan> ?hoogle castPtr
12:10:19 <PeakerLambda> Foreign.Ptr castPtr :: Ptr a -> Ptr b
12:10:19 <PeakerLambda> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
12:10:19 <PeakerLambda> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
12:10:30 <mauke> :t with ?d (peek . castPtr)
12:10:31 <PeakerLambda> Not in scope: `with'
12:10:31 <PeakerLambda> Not in scope: `peek'
12:10:31 <PeakerLambda> Not in scope: `castPtr'
12:10:33 <mauke> aw
12:10:47 <FliPPeh> Could be translated into laymans term as "For every match of the rightmost expressions, apply the first function to it and append it to a list" ?
12:10:52 <Olathe> [ "x = " ++ show x ++ ", y = " ++ show y | x <- [1..3], y <- [1..3] ]
12:10:52 <int80_h> if I want to import a module would "module Data.Char where" be an example of doing that?
12:10:52 <Peaker> too bad _ can't be used inside operators
12:10:56 <Olathe> > [ "x = " ++ show x ++ ", y = " ++ show y | x <- [1..3], y <- [1..3] ]
12:10:58 <PeakerLambda>   ["x = 1, y = 1","x = 1, y = 2","x = 1, y = 3","x = 2, y = 1","x = 2, y = 2"...
12:11:05 <Saizan> since when are we using the same imports for @type and @run?
12:11:19 <Gracenotes> FliPPeh: yep, that sounds right
12:11:46 <Olathe> int80_h: "import Data.Char"
12:11:48 <FliPPeh> To make sure I understand it.. give me something I could solve using such a list comprehension!
12:12:05 <Gracenotes> FliPPeh: try listing Pythagorean triples
12:12:05 <Peaker> @type (()<$)
12:12:06 <PeakerLambda> forall (f :: * -> *) b. (Functor f) => f b -> f ()
12:12:12 <rwbarton> :t fmap . const $ ()
12:12:12 <PeakerLambda> forall a (f :: * -> *). (Functor f) => f a -> f ()
12:12:13 <Peaker> @type ($>)
12:12:13 <PeakerLambda> Not in scope: `$>'
12:12:22 <FliPPeh> Now I just need to know what pythagorean triples are
12:12:25 <mauke> FliPPeh: write 'map' and 'filter' as list comprehensions
12:12:33 <Gracenotes> FliPPeh: Pythagorean triples using list comprehensions aren't very efficient... but they're an interesting example
12:12:39 <Olathe> FliPPeh: (x, y, z) where x^2 + y^2 = z^2
12:13:01 <Peaker> rwbarton: Instead of an extra "return ()" line to equate do block types and such, I'd like to be able to use   do { ... ; last_statement $> () } or some single operator to do that
12:13:03 <rwbarton> Peaker: I don't have any suggestions for those beyond  () <$
12:13:05 <Gracenotes> ah. They're the sides of right triangles
12:13:31 <Gracenotes> Pyth triples are. So one size can be 3, another can be 4, and the hypotenuse can be 5
12:13:37 <Baughn> @hoogle cmsg
12:13:37 <PeakerLambda> No results found
12:13:41 <Gracenotes> 3^2 + 4^2 = 5^2
12:14:07 <FliPPeh> Got it.. I think
12:14:24 <jeffwheeler> > [(x, y, z) | x <- [1..10], y <- [x..10], z <- [y..10]]
12:14:25 <PeakerLambda>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
12:14:26 <jeffwheeler> err
12:14:35 <Gracenotes> jeffwheeler: shh :)
12:14:39 <jeffwheeler> oh, what?
12:14:40 <Gracenotes> mauke's suggestion is good too... more Haskelly than mine
12:15:09 <FliPPeh> [ (x, y, z) | x <- [1..10], y <- [1..10], z <- [1 .. 10], x^2 + y^2 == z^2 ]
12:15:10 <Zao> ztirF: let f x = alloca (\p -> do { poke p x; peek (castPtr p) :: IO Word64})
12:15:18 <mauke> > [ (x, y, z) | x <- [1..10], y <- [1..10], z <- [1 .. 10], x^2 + y^2 == z^2 ]
12:15:24 <PeakerLambda>   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
12:15:25 <Zao> ztirF: Does a bitwise cast of any type to Word64, at your own risk.
12:15:30 <ztirF> Zao: tyvm
12:15:35 <FliPPeh> Worked for me at least :)
12:15:41 <jeffwheeler> You shouldn't need to start at 1 for the second two.
12:15:42 <Zao> ztirF: Probably expressible in a way shorter and more elegant way.
12:15:44 <mauke> Zao: you can use 'with' instead of 'alloca'
12:15:45 <Gracenotes> FliPPeh: yep. Now, can you try eliminating duplicates?
12:15:54 <Zao> mauke: So I guessed.
12:15:57 <Gracenotes> for example, (6,8,10) and (8,6,10) are kind of the same thing
12:16:14 <mauke> stage 2: write 'concat' using a list comprehension
12:16:17 <Gracenotes> because 8^2 + 6^2 = 6^2 + 8^2 kinda trivially
12:16:17 <Zao> mauke: Haven't thankfully done any FFI for months though :)
12:16:26 <FliPPeh> Mhh
12:16:33 <FliPPeh> No idea :/
12:16:39 <FliPPeh> Any pointer?
12:17:05 <Gracenotes> well, one property that might help is that for a triple (x, y, z), x and y are never equal
12:17:05 <Olathe> (6, 8) and (8, 6) are reverses.
12:17:10 <int80_h> okay I'm confused
12:17:16 <int80_h> testSum x = let d = intToDigit . fromInteger in (2^x)
12:17:30 <int80_h> this gives a type of testSum :: (Num t, Integral b) => b -> t
12:17:42 <mauke> yes
12:18:00 <int80_h> but but the type of intToDigit is
12:18:04 <int80_h> intToDigit :: Int -> Char
12:18:05 <Gracenotes> FliPPeh: remember, there are two basic types of statements in list comprehensions, x <- list, which is making new possibilities for values
12:18:09 <rwbarton> int80_h: you're not using d in any way
12:18:10 <mauke> yes
12:18:13 <Olathe> intToDigit isn't used in testSum.
12:18:25 <Gracenotes> FliPPeh: the other kind is a boolean expression which can possibly narrow down your results
12:18:40 <Gracenotes> if you want to remove duplicates, you should probably use the second
12:18:40 <int80_h> okay
12:18:45 <ztirF> @hoogle alloca
12:18:45 <PeakerLambda> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
12:18:46 <PeakerLambda> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
12:18:46 <PeakerLambda> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
12:18:53 <FliPPeh> I have no idea how to detect those duplicates :/
12:19:06 <ztirF> @hoogle peek
12:19:06 <PeakerLambda> Foreign.Storable peek :: Storable a => Ptr a -> IO a
12:19:07 <PeakerLambda> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
12:19:07 <PeakerLambda> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
12:19:09 <mauke> FliPPeh: x == y
12:19:15 <mauke> er
12:19:18 <mauke> no :(
12:19:21 <jeffwheeler> FliPPeh: don't; don't generate them to start with
12:19:25 <ztirF> @hoogle castPtr
12:19:25 <PeakerLambda> Foreign.Ptr castPtr :: Ptr a -> Ptr b
12:19:25 <wli> [(i, j, k) | k <- [1..], j <- [1..k-1], let i = floor (sqrt . fromIntegral $ k*k - j*j :: Double), i <= j, i*i + j*j == k*k] :: [(Integer, Integer, Integer)]
12:19:25 <PeakerLambda> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
12:19:25 <PeakerLambda> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
12:19:45 <mauke> the key idea is to make sure that x < y < z
12:19:54 <Gracenotes> jeffwheeler: that's one way to do it, but with guards :)
12:20:33 <jeffwheeler> Gracenotes: no; by not ever allowing the second statement to generate a number less than or equal to the one provided by the first statement ;)
12:20:49 <int80_h> okay I've changed the code now I get a type error
12:20:51 <Gracenotes> jeffwheeler: yes, that's more efficient. Yet another way to do it :)
12:21:01 <int80_h> testSum :: Integer -> [Char]
12:21:01 <int80_h> testSum x = intToDigit . fromInteger 2^x
12:21:09 <FliPPeh> The only way I could think of is saving the results and using another loop to scan for doubles
12:21:11 <Olathe> I'd say x <= y < z, since x = y doesn't repeat.
12:21:38 <Olathe> Actually, x <= y <= z
12:21:45 <rwbarton> Olathe: True.  But also x = y happens to be impossible.
12:21:59 <jeffwheeler> Olathe: except that wouldn't form a right triangle.
12:22:01 <Gracenotes> FliPPeh: the thing about list comprehensions is that, as augustss said, it basically already *is* a loop
12:22:01 <Olathe> Sure, in this problem, that's true.
12:22:22 <Olathe> But, in general, that will eliminate duplicates on a nice symmetric thing.
12:22:54 <int80_h> hmm, I made a change I thought would solve the problem, still type error
12:23:02 <int80_h> testSum x = [] : (intToDigit . fromInteger 2^x)
12:23:19 <mauke> int80_h: use more parens
12:23:19 <jeffwheeler> @type (:)
12:23:20 <PeakerLambda> forall a. a -> [a] -> [a]
12:23:26 <int80_h> since intToDigit give a Char, [] : ... should put that in a list right?
12:23:30 <mauke> int80_h: no
12:23:41 <Gracenotes> > [ (x,y) | x <- [1..3], y <- [1..x] ]
12:23:42 <PeakerLambda>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
12:23:51 <Olathe> int80_h: To test that, see what [] : 'a' is
12:23:51 <rwbarton> int80_h: if you want to put something in a list, just put it in [ ]
12:23:53 <Gracenotes> FliPPeh: that's possible
12:23:56 <Olathe> > [] : 'a'
12:23:57 <PeakerLambda>   Couldn't match expected type `[[a]]'
12:24:02 <Gracenotes> > [ (x,y) | x <- [1..y], y <- [1..3] ]
12:24:03 <PeakerLambda>   * Exception: not a number
12:24:04 <jeffwheeler> int80_h: look at the type of (:); a Char isn't a []
12:24:13 <Gracenotes> FliPPeh: that's not possible.
12:24:27 <FliPPeh> Math was never my strength
12:24:49 <jeffwheeler> FliPPeh: don't start at 1 every time.
12:25:10 <Gracenotes> FliPPeh: that's okay, it's more procedural than mathematical. Math is just a nice example...
12:25:22 <int80_h> jeffwheelertestSum x = [intToDigit . fromInteger 2^x]
12:25:25 <int80_h> oops sorry
12:25:26 <Gracenotes> > [ (x,y) | x <- ['a'..'c'], y <- ['a'..x] ]
12:25:27 <int80_h> testSum x = [intToDigit . fromInteger 2^x]
12:25:27 <PeakerLambda>   [('a','a'),('b','a'),('b','b'),('c','a'),('c','b'),('c','c')]
12:25:41 <Olathe> We need @uncomprehend to change comprehensions to whatever.
12:25:46 <int80_h> should that line work, because here's the type definition
12:25:55 <rwbarton> @undo  [ (x,y) | x <- [1..3], y <- [1..x] ]
12:25:55 <PeakerLambda> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [1 .. x]) [1 .. 3]
12:26:01 <int80_h> testSum :: Integer -> [Char]
12:26:03 <Olathe> Ahh :)
12:26:15 <int80_h> and I'm getting a type error, but it's close to what I want
12:26:21 <jeffwheeler> What's doing the parsing in stuff like that? Does lambdabot work with a GHC API?
12:26:22 <int80_h>     Couldn't match expected type `Char'
12:26:22 <int80_h>            against inferred type `a -> Char'
12:26:35 <Olathe> @redo concatMap (\ x -> concatMap (\ y -> [(x, y)]) [1 .. x]) [1 .. 3]
12:26:36 <PeakerLambda> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [1 .. x]) [1 .. 3]
12:26:39 <Olathe> :|
12:26:56 <rwbarton> int80_h: You still need more parentheses
12:26:57 <Olathe> It's not comprehending.
12:27:02 <Gracenotes> heh
12:27:24 <jeffwheeler> @redo do { x <- [1..3], y <- [4..6], return (x, y) }
12:27:24 <PeakerLambda>  Parse error at "," (column 17)
12:27:33 <jeffwheeler> @redo do { x <- [1..3]; y <- [4..6]; return (x, y) }
12:27:34 <PeakerLambda> do { x <- [1 .. 3]; y <- [4 .. 6]; return (x, y)}
12:27:43 <jeffwheeler> @undo do { x <- [1..3]; y <- [4..6]; return (x, y) }
12:27:43 <PeakerLambda> [1 .. 3] >>= \ x -> [4 .. 6] >>= \ y -> return (x, y)
12:27:56 <jeffwheeler> @redo [1 .. 3] >>= \ x -> [4 .. 6] >>= \ y -> return (x, y)
12:27:56 <PeakerLambda> do { x <- [1 .. 3]; y <- [4 .. 6]; return (x, y)}
12:28:00 <jeffwheeler> neato
12:28:07 <Gracenotes> FliPPeh: hm, this was probably a bad example. Here's one way to do it:
12:28:11 <Gracenotes> > [ (x,y,z) | x <- [1..50], y <- [1..50], z <- [1..50], x < y, x^2 + y^2 == z^2 ]
12:28:13 <PeakerLambda>   [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,...
12:28:22 <FliPPeh> :/
12:28:34 <jeffwheeler> Or . . . what I suggested earlier:
12:28:39 <int80_h> okay I don't understand where to place the parens
12:28:41 <Gracenotes> > [ (x,y,z) | x <- [1..50], y <- [1..x], z <- [1..50], x^2 + y^2 == z^2 ]
12:28:42 <PeakerLambda>   [(4,3,5),(8,6,10),(12,5,13),(12,9,15),(15,8,17),(16,12,20),(20,15,25),(21,2...
12:28:52 <jeffwheeler> > [ (x,y,z) | x <- [1..50], y <- [x..50], z <- [y..50], x^2 + y^2 == z^2 ]
12:28:53 <PeakerLambda>   [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,...
12:29:11 <Gracenotes> oh... that's a good idea, too.
12:29:15 <Olathe> > [ (x,y,x^2 + y^2) | x <- [1..50], y <- [x..50] ]
12:29:16 <PeakerLambda>   [(1,1,2),(1,2,5),(1,3,10),(1,4,17),(1,5,26),(1,6,37),(1,7,50),(1,8,65),(1,9...
12:29:49 <Gracenotes> FliPPeh: in the first example, though, the phrase is x < y
12:29:51 <Olathe> That's not right :)
12:29:57 <rwbarton> int80_h: f . g x  means  f . (g x)  because function application has higher precedence than any operator
12:30:21 <rwbarton> int80_h: This is the one precedence rule that is really good to know
12:30:24 <FliPPeh> That letter example seems to be better for me, tho
12:30:25 <FliPPeh> > [ (x,y) | x <- ['a'..'c'], y <- ['a'..x] ]
12:30:26 <PeakerLambda>   [('a','a'),('b','a'),('b','b'),('c','a'),('c','b'),('c','c')]
12:30:40 <rwbarton> int80_h: Of course, if you're not sure about precedence, you can always add more parentheses to make sure things group the way you want.
12:31:04 <Gracenotes> > [ [x,y] | x <- ['a'..'c'], y <- ['a'..x] ]
12:31:05 <PeakerLambda>   ["aa","ba","bb","ca","cb","cc"]
12:31:21 <idnar> I wish people wouldn't add unnecessary parens, it always confuses me
12:31:30 <Gracenotes> > [ [x,y,z] | x <- ['a'..'c'], y <- ['a'..x], z <- ['a'..y] ]
12:31:32 <PeakerLambda>   ["aaa","baa","bba","bbb","caa","cba","cbb","cca","ccb","ccc"]
12:31:45 <Riastradh> I wish people wouldn't use infix operators with precedence tables I must memorize, it always confuses me.
12:32:02 <jeffwheeler> > [[x,y] | x <- ['a'..'d'], y <- [x..'e']]
12:32:03 <PeakerLambda>   ["aa","ab","ac","ad","ae","bb","bc","bd","be","cc","cd","ce","dd","de"]
12:32:19 <Olathe> I wish computers could figure out what I mean and do it.
12:32:22 <mauke> precedence tables are easy
12:32:35 <Gracenotes> FliPPeh: it might help to divide it up into three parts: ["aaa"]   ["baa","bba","bbb"]   and  ["caa","cba","cbb","cca","ccb","ccc"]
12:32:48 <Gracenotes> in the first, x is a; in the second x is b, and so on
12:32:50 <ddarius> We need to make precedence directed cyclic graphs!
12:32:56 <FliPPeh> Ahh
12:33:01 <Gracenotes> FliPPeh: what happens internally is that these three parts are combined to give the final list
12:33:04 <mapreduce> While I wait for git to grab ghc, can I see the source for State somewhere?
12:33:39 <Gracenotes> FliPPeh: and if you take the third part, you can view *this* as three lists: ["caa"]  ["cba","cbb"]  and  ["cca","ccb","ccc"]
12:33:58 <Gracenotes> or for the second part, there are two lists, ["baa"]  and  ["bba", "bbb"]
12:34:14 <int80_h> testSum x = [intToDigit . (fromInteger (2^x))]
12:34:24 <int80_h> this is how I htink I want precedence
12:34:31 <int80_h> but I'm wrong, still get a type error
12:34:31 <mauke> int80_h: no :-)
12:34:37 <mauke> that doesn't make sense
12:34:39 <FliPPeh> Got it
12:34:41 <FliPPeh> :(
12:34:42 <FliPPeh> :)
12:34:47 <Olathe> mapreduce: http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/src/Control-Monad-State-Lazy.html#State
12:34:48 <PeakerLambda> Title: Haskell Code by HsColour, http://tinyurl.com/adfevh
12:34:51 <mauke> int80_h: (.) takes two functions; fromInteger (2^x) is not a function
12:35:00 <FliPPeh> Complicated at first
12:35:26 <Gracenotes> FliPPeh: sorry... math can be unnecessarily complicated at times ;)
12:35:56 <Gracenotes> I find, personally, that I don't use list comprehensions that much...
12:36:04 <Baughn> Is Network.Socket.sendFd... reliable?
12:36:13 <mapreduce> Olathe: Thanks.
12:36:31 <Gracenotes> FliPPeh: and if you learn about the list monad sometime down the line, you'll see that it's exactly the same thing
12:36:45 <FliPPeh> I hope I won't be touching monads any time soon
12:36:57 <mle> Baughn: that's for passing fds between processes on the same system
12:37:08 <FliPPeh> I've never got behind them, but that's something I'll solve later
12:37:08 <chrisdone> I touched monads last night
12:37:08 <mapreduce> So a State s a is a fancy way of saying s -> a?
12:37:20 <mauke> @unmtl State s a
12:37:20 <PeakerLambda> s -> (a, s)
12:37:44 <mauke> @unmtl Reader s a
12:37:44 <PeakerLambda> s -> a
12:37:46 <Olathe> @unmtl Either a b
12:37:47 <PeakerLambda> Either a b
12:38:09 <Baughn> mle: I know, but when I tried that in C I ran into a maze of differing implementations, none alike. This seems too easy.
12:38:26 <rwbarton> chrisdone: http://arcanux.org/lambdacats/monad.jpg
12:38:26 <FliPPeh> > [ x | x <- [1 .. 20], x `mod` 10 /= 0]
12:38:28 <PeakerLambda>   [1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19]
12:38:31 <dons> hmm. we don't really have a good search interface to all the haskell lists, do we?
12:38:32 <FliPPeh> \o/
12:38:49 <FliPPeh> Okay, got it finally
12:38:55 <ddarius> @googli site:haskell.org inurl:pipermail "monoids"
12:38:57 <PeakerLambda> http://www.haskell.org/pipermail/haskell-cafe/2009-January/054127.html
12:38:57 <PeakerLambda> Title: [Haskell-cafe] Why monoids will abide...
12:39:02 <FliPPeh> Let's sort out multiples by five...
12:39:07 <mauke> FliPPeh: so ... can you define 'filter' using a list comprehension?
12:39:09 <mle> Baughn: i suspect your intuition is correct here...
12:39:09 <FliPPeh> > [ x | x <- [1 .. 20], x `mod` 5 /= 0]
12:39:10 <PeakerLambda>   [1,2,3,4,6,7,8,9,11,12,13,14,16,17,18,19]
12:39:51 <FliPPeh> What does filter do again? I always thought list comprehension can be used as a filter dublicate..
12:40:03 <pumpkin> it can
12:40:14 <koeien> yes, but you should understand how filter works as well
12:40:16 <ddarius> @undo [ x | x <- [1 .. 20], x `mod` 5 /= 0]
12:40:17 <PeakerLambda> concatMap (\ x -> if x `mod` 5 /= 0 then [x] else []) [1 .. 20]
12:40:19 <jeffwheeler> > filter even [1..5]
12:40:21 <PeakerLambda>   [2,4]
12:40:24 <ddarius> Stupid cleverness.
12:40:28 <koeien> > [x | x <- [1..37], x `mod` 4 == 0]
12:40:29 <PeakerLambda>   [4,8,12,16,20,24,28,32,36]
12:40:42 <koeien> > filter (\x -> x `mod` 4 == 0) [1..37]
12:40:42 <Gracenotes> aww, what happened to http://www.haskell.org.monadtransformer.parallelnetz.de/haskellwiki/Category:Monad ?
12:40:44 <PeakerLambda>   [4,8,12,16,20,24,28,32,36]
12:40:44 <PeakerLambda> http://tinyurl.com/af8nqz
12:41:01 <Gracenotes> koeien: I see what you did there :3
12:41:13 <FliPPeh> > let myFilter f l = [ x | x <- l, f ]
12:41:13 <PeakerLambda>   <no location info>: parse error on input `;'
12:41:30 <FliPPeh> > let myFilter f l = [ x | x <- l, f x ]
12:41:31 <PeakerLambda>   <no location info>: parse error on input `;'
12:41:36 <FliPPeh> Could do the trick?
12:41:41 <jeffwheeler> FliPPeh: add an "in f ..." part
12:41:55 <mauke> FliPPeh: that looks right
12:41:59 <Gracenotes> FliPPeh: for lambdabot, it might help to have something of the form let func = definitinon in func example parameters
12:42:15 <Gracenotes> > let myFilter f l = [ x | x <- l, f x ] in myFilter even [0..20]
12:42:17 <PeakerLambda>   [0,2,4,6,8,10,12,14,16,18,20]
12:42:21 <Gracenotes> :D
12:42:42 <FliPPeh> :D
12:42:43 <mauke> FliPPeh: now 'map'!
12:42:44 * jeffwheeler can't whine enough about using 'l' as an argument.
12:43:21 * Gracenotes can't whine enough either, about using '1' as an argument :P
12:43:26 <athos> :t concatMap
12:43:30 <PeakerLambda> forall a b. (a -> [b]) -> [a] -> [b]
12:44:04 <Peaker> How do I see the C output of ghc with -fvia-c?
12:44:30 <pumpkin> there's an option to keep the c file
12:44:38 <chrisdone> athos: see also (>>=)
12:44:41 <pumpkin> -keep-hc-file
12:44:45 <jeffwheeler> That doesn't use C-- does it?
12:44:55 <FliPPeh> > let myMap f l = [ x == fx | x <- l ] in myMap odd [1 .. 20]
12:44:57 <PeakerLambda>   Not in scope: `fx'
12:44:59 <pumpkin> there's a category of "files to keep" in the man page
12:45:02 <FliPPeh> > let myMap f l = [ x == f x | x <- l ] in myMap odd [1 .. 20]
12:45:03 <PeakerLambda>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
12:45:03 <PeakerLambda>    arising from a use of ...
12:45:05 <FliPPeh> :(
12:45:18 <FliPPeh> > let myMap f l = [ f x | x <- l ] in myMap odd [1 .. 20]
12:45:20 <PeakerLambda>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
12:45:22 <jeffwheeler> > map (+2) [1..5] -- it never throws elements away
12:45:23 <PeakerLambda>   [3,4,5,6,7]
12:45:30 <jeffwheeler> Exactly.
12:45:31 <FliPPeh> > let myMap f l = [ f x | x <- l ] in myMap odd [1 .. 10]
12:45:33 <PeakerLambda>   [True,False,True,False,True,False,True,False,True,False]
12:45:41 <SubStack> wooo
12:45:49 <FliPPeh> mauke: like that?
12:45:52 <mauke> stage 1 cleared!
12:45:55 <Gracenotes> > let myMap f l = [ f x | x <- l ] in myMap negate [1 .. 10]
12:45:56 <PeakerLambda>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
12:46:10 <mauke> stage 2: write 'concat' using a list comprehension
12:46:18 <jeffwheeler> > do { x <- [1..5]; guard odd; return x }
12:46:19 <PeakerLambda>   Couldn't match expected type `GHC.Bool.Bool'
12:46:26 <jeffwheeler> > do { x <- [1..5]; guard (odd x); return x }
12:46:27 <PeakerLambda>   [1,3,5]
12:46:33 <SubStack> monads are awesome for tricking the GL matrix stack into being not so cumbersome
12:46:40 <FliPPeh> concat removes one level of list intendation, right?
12:46:45 <FliPPeh> > concat [[1]]
12:46:46 <PeakerLambda>   [1]
12:46:48 <Gracenotes> the outer level, in this case
12:46:50 <FliPPeh> Right
12:47:00 <mauke> > concat ["foo", "bar", "baz"]
12:47:01 <PeakerLambda>   "foobarbaz"
12:47:16 <FliPPeh> Hmmmm
12:48:16 <jeffwheeler> > let mapAndFilter f m list = do { x <- list; guard (f x); return (m x) } in mapAndFilter (even) (+1) [1..10]
12:48:18 <PeakerLambda>   [3,5,7,9,11]
12:48:46 <jeffwheeler> > let mapAndFilter f m list = [m x | x <- list, f x] in mapAndFilter (even) (+1) [1..10] -- or in boring form
12:48:47 <PeakerLambda>   [3,5,7,9,11]
12:49:00 <wks> myConcat l = [x | xx <- l, x <- xx]
12:49:16 <FliPPeh> NO idea how to rewrite concat :(
12:49:29 <jeffwheeler> wks: I wouldn't have thought of that. Clever.
12:50:35 <vixey> :t (>>= id)
12:50:37 <PeakerLambda> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
12:50:43 <vixey> :t join
12:50:44 <PeakerLambda> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:50:51 <Gracenotes> conspiracy :X
12:50:54 <wks> how about writing foldl or foldr in list-cmprehension?
12:51:36 <icqn> > putStrLn $ map Data.Char.toUpper "abcäöüxyz"
12:51:37 <PeakerLambda>   * Exception: "<IO ()>"
12:51:54 <luqui> @index comparing
12:51:54 <PeakerLambda> bzzt
12:52:04 <luqui> @hoogle comparing
12:52:05 <PeakerLambda> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:52:05 <PeakerLambda> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:52:22 <Gracenotes> > text $ map Data.Char.toUpper "abcäöüxyz"
12:52:23 <PeakerLambda>   ABCÄÖÜXYZ
12:53:49 <koeien> does HDBC-MySQL support 'TEXT' type columns?
12:53:56 <Gracenotes> wks: it's possible, right? :)
12:54:26 <int80_h> okay someone said that fromInteger 2^x is not a function
12:54:42 <int80_h> and since . takes two functions
12:54:48 <Jedai> wks: I don't think you can, someone confirm ?
12:55:05 <int80_h> fromInteger 2^x would not work
12:55:18 <Gracenotes> It probably involves some kind of clever recursion... lemmethink
12:55:33 <wks> I didn't think I can, either, but not sure.
12:55:34 <int80_h> however not . (divides x) works. what's the difference
12:55:44 <idnar> @type divides
12:55:45 <PeakerLambda> Not in scope: `divides'
12:55:49 <idnar> bah
12:55:56 <int80_h> idnar, I wrote that yesterday
12:55:57 <mauke> int80_h: divides x is probably a function
12:56:01 <idnar> int80_h: divides is a function of two arguments, so divides x is a function of one argument
12:56:17 <int80_h> I'm confused fromInteger is a function
12:56:27 <idnar> @type fromInteger
12:56:28 <PeakerLambda> forall a. (Num a) => Integer -> a
12:56:29 <int80_h> 2^x is an argument for fromInteger
12:56:43 <int80_h> what makes it not a function
12:57:03 <idnar> int80_h: fromInteger is of type (Num a) => Integer -> a
12:57:03 <mauke> int80_h: its being a number
12:57:12 <idnar> int80_h: if you apply it to 2^x, you get a value of type (Num a) => a
12:57:16 <idnar> int80_h: which is a number, not a function
12:57:25 <int80_h> oooh
12:57:38 <idnar> int80_h: divides is presumably of type (Num a) => a -> a -> Bool (or something like that)
12:57:40 <int80_h> I misinterpreted the type definition
12:57:40 <mjb> int80_h: (^) is a function. (2^x) is a value.
12:57:52 <int80_h> idnar, yes that's right about divides
12:57:56 <pumpkin> wouldn't you get (fromInteger 2)^2 the way you wrote it anyway?
12:58:08 <idnar> int80_h: so when you apply divides to x, you get a value of type (Num a) => a -> Bool
12:58:17 <icqn> Gracenotes, where is text function defined?
12:58:25 <idnar> int80_h: you probably want \x -> fromInteger (2^x) or fromInteger . (2^)
12:58:35 <Gracenotes> icqn: it's in the pretty-printing module
12:58:35 <pumpkin> or fromIntegral
12:58:42 <rwbarton> no, int80_h just doesn't want .
12:58:44 <idnar> (although I missed the beginning of this discussion, so I don't know the context)
12:58:45 <Peaker> how is it possible that ghc --make  works, but ghc --make -fvia-c   fails to find include files?
12:58:48 <Gracenotes> icqn: the string that results is still the proper string.
12:58:50 <idnar> rwbarton: ah
12:58:52 <int80_h> idnar that sounds right, but someone told me I just needed more parens.
12:58:56 <Gracenotes> pretty-printing just makes it nicer to display in IRC
12:59:01 <Peaker> what could prevent ghc from passing the include options to gcc?
12:59:04 <Gracenotes> > map Data.Char.toUpper "abcäöüxyz" --otherwise
12:59:06 <PeakerLambda>   "ABC\196\214\220XYZ"
12:59:08 <mauke> Peaker: -fasm doesn't use include files
12:59:15 <Peaker> mauke: oh
12:59:18 <int80_h> rwbarton: what? I don't want .?
12:59:19 <idnar> oh, I see
12:59:23 <rwbarton> int80_h: yes, you can also do it with more parens
12:59:27 <idnar> int80_h: we're still talking about testSum x = [intToDigit . (fromInteger (2^x))] ?
12:59:38 <int80_h> idnar: yes
12:59:38 <Baughn> Is there no more precise way of handling IOExceptions than to show them and discriminate based on the error message?
12:59:39 <rwbarton> int80_h: intToDigit is a function and fromInteger is a function
12:59:43 <rwbarton> int80_h: so you can compose them with .
12:59:48 <idnar> right, that should either be [intToDigit (fromInteger (2^x))]
12:59:58 <idnar> or [intToDigit . fromInteger . (2^) $ x]
13:00:04 <augustss> Peaker: Are these C include files it can't find?
13:00:12 <int80_h> idnar: the second way looks more idiomatic
13:00:14 <idnar> (if you prefer pointfree style or whatever that's called)
13:00:19 <mauke> [(intToDigit . fromInteger) (2^x)]
13:00:29 <augustss> augustss: nm, mauke answered it
13:00:31 <mauke> [intToDigit (2^x)]
13:00:34 <int80_h> mauke: I tried that...it compiles but I get the following error
13:00:35 <Olathe> (:[]) . intToDigit . fromInteger . (2^) $ x
13:00:43 <pumpkin> oh no, a monkey
13:00:52 <icqn> Gracenotes, is it Text.PrettyPrint?
13:00:55 <Olathe> It's going to eat you, if you're x.
13:01:01 <Peaker> augustss: yeah, SDL.h
13:01:08 <icqn> Gracenotes, Is it in Text.PrettyPrint?
13:01:08 <idnar> I think I'd prefer [intToDigit . fromInteger $ 2^x] or something
13:01:13 <int80_h> "*** Exception: Char.intToDigit: not a digit 1024
13:01:13 <Gracenotes> text :: String -> Doc 	-- Defined in Text.PrettyPrint.HughesPJ
13:01:18 <Gracenotes> yeah
13:01:26 <Peaker> augustss: apparently ghc-pkg describe SDL doesn't have /usr/include/SDL in include paths, but it compiles fine with -fvia-c here on my ghc 6.10 but fails at my friend's ghc-6.8
13:01:26 <mauke> int80_h: er, what did you expect?
13:01:47 <pumpkin> int80_h: maybe it should generate random symbols for higher digits?
13:01:52 <pumpkin> up to 0x10ffff
13:01:54 <int80_h> mauke: I expected to get more information about how haskell works
13:01:59 <idnar> intToDigit doesn't handle base 1024
13:02:03 <idnar> ;P
13:02:20 <mauke> uh, ok
13:02:22 <pumpkin> > map intToDigit [0..]
13:02:23 <PeakerLambda>   "0123456789abcdef* Exception: Char.intToDigit: not a digit 16
13:02:26 <pumpkin> :)
13:02:46 <Gracenotes> @src intToDigit
13:02:46 <PeakerLambda> Source not found. Where did you learn to type?
13:02:50 <Gracenotes> On my own
13:02:53 <idnar> heh
13:02:55 <pumpkin> Gracenotes: it shows!
13:03:02 <Gracenotes> :X
13:03:06 <pumpkin> :)
13:03:07 <pumpkin> j/k
13:03:25 <yitz> python supports higher bases
13:03:28 <Gracenotes> :3
13:03:36 <pumpkin> omg python >> haskell
13:03:37 <pumpkin> QED
13:03:43 <rwbarton> @hoogle base
13:03:44 <PeakerLambda> package base
13:03:44 <PeakerLambda> Text.XHtml.Frameset base :: String -> HtmlAttr
13:03:44 <PeakerLambda> Text.XHtml.Strict base :: String -> HtmlAttr
13:03:49 <Gracenotes> @hoogle Int -> Int -> String
13:03:51 <rwbarton> @hoogle atbase
13:03:52 <PeakerLambda> Distribution.Simple.Command commandShowOptions :: CommandUI flags -> flags -> [String]
13:03:54 <PeakerLambda> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
13:03:56 <PeakerLambda> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
13:03:58 <PeakerLambda> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
13:04:19 <yitz> PeakerLambda?
13:04:29 <pumpkin> pumpkinbot wasn't good enough
13:04:30 <rwbarton> > showIntAtBase 36 (([0..9] ++ ['a'..'z']) !!) 1247685 ""
13:04:31 <PeakerLambda>   No instance for (GHC.Num.Num GHC.Types.Char)
13:04:31 <PeakerLambda>    arising from the literal `0...
13:04:33 <pumpkin> lambdabot ran away
13:04:40 <rwbarton> > showIntAtBase 36 ((['0'..'9'] ++ ['a'..'z']) !!) 1247685 ""
13:04:41 <PeakerLambda>   /tmp/1008723250:66:113: Not in scope: `showIntAtBase'
13:04:45 <rwbarton> > Numeric.showIntAtBase 36 ((['0'..'9'] ++ ['a'..'z']) !!) 1247685 ""
13:04:46 <PeakerLambda>   /tmp/1900666569:66:109: Not in scope: `Numeric.showIntAtBase'
13:04:49 <pumpkin> aw
13:04:53 <int80_h> okay what I want to happen is this, I give testSum an Integer x. Then I do 2^x, and convert that Integer into a [Char]
13:04:58 <rwbarton> , Numeric.showIntAtBase 36 ((['0'..'9'] ++ ['a'..'z']) !!) 1247685 ""
13:04:59 <lunabot>  "qqpx"
13:05:06 <int80_h> I've changed the definition to testSum x = [intToDigit . fromInteger $ 2^x]
13:05:16 <int80_h> and still get *Main Data.Char> testSum 10
13:05:16 <int80_h> "*** Exception: Char.intToDigit: not a digit 1024
13:05:32 <mauke> int80_h: stop using intToDigit
13:05:33 <yitz> rwbarton: ok so Haskell does also
13:05:47 <mauke> int80_h: testSum x = show (2^x)
13:05:55 <NameAlreadyInUse> how does the function composition operator work?
13:06:00 <ztirF> @src getWord64be
13:06:00 <PeakerLambda> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:06:07 <rwbarton> @src (.)
13:06:07 <PeakerLambda> (f . g) x = f (g x)
13:06:11 <yitz> testSum = show . (2^)
13:06:26 <int80_h> mauke: wow, that simple
13:06:40 <int80_h> yitz: yes I need practice with partial applications, I'll do it that way
13:07:16 <yitz> @src (.)
13:07:16 <PeakerLambda> (f . g) x = f (g x)
13:07:25 <yitz> NameAlreadyInUse: like that ^
13:07:59 <int80_h> yay!
13:08:25 <NameAlreadyInUse> is the x necessary?
13:08:34 <yitz> NameAlreadyInUse: no
13:08:55 <dons> hey guys, i added a much smarter google haskell search link to haskell.org's front page. try it out and let me know opinions, http://haskell.org/haskellwiki/Haskell
13:08:57 <PeakerLambda> Title: Haskell - HaskellWiki
13:09:08 <dons> gwern: any idea on how to embed the search box directly in the frontpage ?
13:09:12 <yitz> NameAlreadyInUse: a nice example just came up a few seconds before you joined the channel:
13:09:16 <vixey> dons any luck with the reddit bot?
13:09:20 <iwannalog> @users
13:09:20 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:09:39 <dons> vixey: in tweaking it? no, too busy. will accept patches
13:09:56 <vixey> dons, You got given a patch
13:09:56 <yitz> NameAlreadyInUse: <int80_h> okay what I want to happen is this, I give testSum an Integer x. Then I do 2^x, and convert that Integer into a [Char]
13:09:58 * rwbarton looks for the patch
13:09:59 <gwern> dons: offhand, dunno
13:10:04 <int80_h> okay now I can extract each character, convert them back to Ints, and sum them
13:10:35 <yitz> NameAlreadyInUse: testSum = show . (2^)
13:11:49 <dons> vixey: did someone send one? i can darcs apply from my inbox if someone sends something
13:11:55 <yitz> dons: there are not only guys here
13:11:57 <vixey> dons oh I see
13:12:02 <NameAlreadyInUse> yitz: but is it possible to do "show . (^)"?
13:12:07 <dons> yitz: generic term
13:12:20 <rwbarton> :t show . (^)
13:12:20 <PeakerLambda> forall a. (Num a) => a -> String
13:12:46 <dons> gwern: i'd be interested to know if you think the search results are accurate too
13:13:01 <ztirF> why oh why is there no instance for Get Double in Data.Binary.Strict.Get?
13:13:06 <ztirF> it seems like a rather glaring oversight
13:13:07 <rwbarton> NameAlreadyInUse: Not really.  (show . (^)) 3 would be show ((^) 3) which is trying to show a function.
13:13:24 <Olathe> > 5 :: Double
13:13:25 <dons> ztirF: hmm.
13:13:26 <PeakerLambda>   5.0
13:13:26 <yitz> dons: in some informal dialects of American English, "you-guys" is 2nd pers. pl. pronoun. But is "guys" generic as a separate word?
13:13:40 <dons> what's a network portable representation we can efficiently use?
13:13:48 <dons> and how can i convert a pure Double into that form, please.
13:13:58 <Heffalump> unsafeCoerce#
13:13:59 <NameAlreadyInUse> rwbarton what about "(show . (^)) 3 5"?
13:14:00 <ztirF> dons: XDR
13:14:03 <yitz> @type show . (^)
13:14:04 <PeakerLambda> forall a. (Num a) => a -> String
13:14:04 <Heffalump> oh, network portable
13:14:14 <pumpkin> dons: protocol buffers?
13:14:20 <dons> needs to be word, and host portable, and capable of being serialised purely
13:14:34 <dons> the current Data.Binary has a high level one
13:14:39 <dons> but there's no primop for reading them that's portable
13:14:40 <ztirF> dons: http://en.wikipedia.org/wiki/External_Data_Representation has been around since '95
13:14:41 <PeakerLambda> Title: External Data Representation - Wikipedia, the free encyclopedia
13:14:41 <pumpkin> there's a haskell protocol buffers compiler
13:14:47 <dons> ztirF: right, use Data.Binary
13:14:51 <dons> not Data.Binary.Get
13:14:59 <yitz> @type (^)
13:14:59 <PeakerLambda> forall a b. (Num a, Integral b) => a -> b -> a
13:15:03 <rwbarton> Since @type and @run have different imports anyways (argh) @type ought not have any Show (a -> b) instances...
13:15:04 <augustss> yitz: guys can certainly be used as a generic term
13:15:06 <ztirF> dons: that has a strict get?
13:15:11 <dons> instance Binary Double where put d = put (decodeFloat d) get   = liftM2 encodeFloat get get
13:15:12 <rwbarton> @type show (\x -> x :: Integer)
13:15:13 <PeakerLambda> String
13:15:21 <Heffalump> why would strict and lazy get differ in what they support?
13:15:32 <dons> the strict lib has a different maintainer, fwiw
13:15:36 <ztirF> Heffalump: it appears to me that strict is only half implemented
13:15:37 <yitz> ok, dons and augustss both accept it, who am I to argue.
13:15:39 <dons> so i make no representations wrt. to it.
13:15:47 <dons> you should just use Data.Binary unless you've some specific reason
13:16:04 <augustss> yitz: I've heard it used by a woman to other women
13:16:12 <ztirF> dons: I can't get data.binary to read a 100000 element list without stack overflow
13:16:33 <ztirF> dons: I've spent hours trying
13:17:16 <dons> ztirF: use a non-strict list serialisation. i can give you an instance, if you like.
13:17:18 <iwannalog> is lambdabot dead ?
13:17:31 <Gracenotes> lambdabot... okay, I won't make a pun :/
13:17:32 <ztirF> dons: please!
13:17:42 <yitz> @seen Peaker
13:17:43 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:17:52 <Peaker> yitz: here
13:17:53 <dons> also, you're not running in ghci are you?
13:17:57 <pumpkin> aw, Peaker's bot has a broken @seen :P
13:18:04 <pumpkin> pumpkinbot > PeakerLambda
13:18:09 <Peaker> pumpkin: bring your bot then :)
13:18:15 <Peaker> pumpkin: I only fill the void
13:18:29 <pumpkin> Peaker: it was a void cause an op kicked my bot, so I'm reluctant to bring it back :)
13:18:39 <pumpkin> lest I incur the wrath of ops
13:18:57 <yitz> Peaker: ok good. I was a little worried about your bot using the same trigger chars. as  \bot, but as long as you're here babysitting it's ok.
13:19:18 <Peaker> yitz: worst-case, it can be kicked
13:19:21 <dons> we need hpaste fixed lads
13:19:24 <dons> ?paste
13:19:24 <PeakerLambda> Haskell pastebin: http://hpaste.org/new
13:19:31 <dons> where's mmorrow's paste?
13:19:36 <pumpkin> @where hpaste2
13:19:36 <PeakerLambda> I know nothing about hpaste2.
13:19:39 <pumpkin> oh
13:19:43 <rwbarton> http://moonpatio.org
13:19:43 <dons> mmorrow: ?
13:19:45 <pumpkin> http://moonpatio.com
13:19:51 <pumpkin> whoops :)
13:19:58 <dons> thanks
13:20:00 <mauke> preflex: ? hpaste2
13:20:00 <preflex>  factoid not found
13:20:02 <pumpkin> oh, both work
13:20:03 <int80_h> I always htought haskell_overflow would be a good place for bots
13:20:18 <mauke> preflex: + hpaste2 http://moonpatio.org/
13:20:20 <int80_h> when I start writing bots, that's where I will put them
13:20:33 <dons> ztirF: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=1114#a1114
13:20:43 <dons> we need hpaste.org to redirect to moonpatio
13:20:44 <arjanb> maybe someone can host hpaste at c.h.o
13:20:52 <dons> yep
13:20:58 <ztirF> dons: thank you so much
13:21:04 <pumpkin> who owns hpaste.org?
13:21:06 <gwern> dons: the results aren't too bad, but poking around with 'koan' or 'haiku' I think I get better results with regular google and 'haskell koan' or 'haskell haiku'
13:21:14 <dons> mm
13:21:18 <pumpkin> oh, it's bos
13:21:29 <dons> gwern: in which sense better? missing sites? or too many sites turning up?
13:21:38 <gwern> dons: for example, none of the emails turn up with the former as they do the latter
13:21:44 <dons> oh
13:21:50 <gwern> and the reddit hits are for users only, not the relevant comment pages/links
13:21:50 <dons> it should be indexing all the mailing lists. let's see..
13:21:54 <dons> huh
13:21:55 <dons> ok.
13:22:12 <dons> there's a setting to have it extract links from reddit, rather than indexing reddit
13:22:15 <dons> which is actually what i want.
13:22:22 <yitz> arjanb: better to host hpaste2, and let hpaste.org point to it. But make urls to old existing hpastes still work.
13:22:37 <gwern> dons: and I don't think I saw anything from the HWN
13:22:52 <pumpkin> what is wrong with the current hpaste.org btw? was the db lost, or is it just a configuration issue?
13:22:59 <gwern> and, come to think of it, no IRC log hits
13:23:02 <gwern> which can be valuable
13:23:22 <dons> yeah, hwn wasn't yet indexed. i just added it.
13:23:26 <dons> logs we can also do.
13:25:32 <tehgeekmeister> is there a way to do an analogue of manyTill that always matches at least one instance of p and doesn't consume any input for end?  (in reference to parsec)
13:25:48 <int80_h> @hoogle foldl'
13:25:50 <PeakerLambda> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
13:25:50 <PeakerLambda> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
13:25:50 <PeakerLambda> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
13:26:32 <Gracenotes> eh. I'm still trying to do a fold via list comprehensions, but all I can come up with is a list-embedded version of the regular foldl: let fff f z [] = [z]; fff f z xs = [ t | (e:es) <- [xs], t <- fff f (f z e) es ] in fff (+) 0 [1,2,3,4,5,6]
13:26:50 <Gracenotes> @src foldl
13:26:50 <PeakerLambda> foldl f z []     = z
13:26:50 <PeakerLambda> foldl f z (x:xs) = foldl f (f z x) xs
13:26:51 <Heffalump> I don't think list comprehensions really support folding
13:26:56 <pumpkin> I'm not sure it's possible
13:27:01 <Gracenotes> me neither :P
13:27:17 <luqui> @hoogle zipM
13:27:17 <PeakerLambda> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
13:27:17 <Gracenotes> after all, it has to return a list
13:27:32 <Gracenotes> however, I'm trying to do a scanl instead now
13:27:35 <dons> gwern: ok. try again. i removed reddit, having instead it pull links from reddit haskell rsss, and added logs
13:27:38 <Gracenotes> somehow using inits or tails
13:27:41 <Heffalump> Gracenotes: even then.
13:27:51 <Heffalump> gracenotes: that might work, at the cost of repeated work
13:28:17 <Gracenotes> Heffalump: yes, of course, calculating each element on its own
13:28:24 <Gracenotes> something on the order of n^2
13:28:42 <Gracenotes> I didn't come into this thinking it was possible :P lemme see, though...
13:29:06 <Heffalump> oh, you'd still need a fold inside
13:29:54 <shapr> dang, I missed johnw AGAIN!
13:29:57 <Gracenotes> hopefully, the list-comprehension-scan can serve as its own fold
13:30:49 <Gracenotes> eh... or maybe not. They say recursion is all about wistful thinking, but this might be a little too wistful :)
13:30:54 <gwern> dons: mm, for 'koan' I'm still not seeing the reddit comments or emails or hwn
13:30:55 <rwbarton> dons: the only question about the rss bot including the links is whether you'll always want to include them.
13:31:04 <gwern> anywhere in the 16 hits...
13:31:05 <rwbarton> dons: otherwise, you'll need a configuration flag, command-line syntax, etc.
13:31:14 <dons> rwbarton: right
13:31:22 <dons> gwern: ok. let's give it some time to crawl the sites.
13:31:30 <dons> i noticed xmonad's custom search results improved over time.
13:31:46 <dons> at least it is more comprehensive than the mediawiki search
13:31:51 <dons> i.e. it turns up sigfpe's blog
13:32:04 <tehgeekmeister> http://pastebin.com/mf80ee6c <== why do i get this exception shown at the bottom?
13:32:17 <ehird> ghc compiled!
13:32:19 <ehird> Joy to the world!
13:32:37 <dons> so bos owns hpaste.org?
13:32:38 <tehgeekmeister> (that's from in ghci, just testing the parsing functions, not running the main)
13:32:46 <dons> annd do we want to redirect it to moonpatio, or move moonpatio?
13:33:07 <Olathe> tehgeekmeister: If it can match many empty strings, it doesn't know how many to give as a result.
13:34:13 <tehgeekmeister> Olathe: oh, so using many1 fixes it.  thanks!
13:34:44 <Philonous> Gracenotes: Why did you want to use list comprehension for this in the first place?
13:34:46 <Olathe> You're welcome.
13:35:25 <Gracenotes> Philonous: why is a lot of Haskell code written?
13:35:42 <Gracenotes> code that's useless, inefficient, etc...
13:36:07 * chessguy eyes Gracenotes strangely
13:36:25 <Gracenotes> :/
13:36:43 <chessguy> haskell code is useless and inefficint?
13:36:45 <Gracenotes> anyway, if I wanted to implement foldl, I could just look at the source, or something
13:36:55 <chessguy> @src foldr
13:36:56 <PeakerLambda> foldr f z []     = z
13:36:56 <PeakerLambda> foldr f z (x:xs) = f x (foldr f z xs)
13:36:57 <Olathe> Quick ! Write integer power using only succ, pred, (<), and (%).
13:37:06 <Heffalump> Gracenotes: intellectual masturbation?
13:37:11 <Gracenotes> exactly! :)
13:37:21 <Gracenotes> the idea is implementing foldl as a list comprehension, without the context of things-to-do-with-list-comprehensions
13:37:28 <Gracenotes> or scanl, or something like
13:37:41 <vixey> Gracenotes, I write programs to learn things sometimes
13:38:02 <vixey> Gracenotes, the feedback from computation as well as just making your idea totally formal (putting it into a program) can work well
13:38:05 * wli suggests parsing more network protocols.
13:38:07 <Philonous> Gracenotes: I didn't think it was a bad Idea. I was just curious what you were trying to achieve
13:38:07 <Peaker> vixey: what do you generally work on? Seems to be language stuff, mostly?
13:38:37 <yitz> dons: ideal would be redirect hpaste.org to an hpaste2 (moopatio, or c.h.o, or whatever), but have urls that refer to old-style hpaste pastes still bring them up
13:38:38 <vixey> Well that's because there is so much about programming languages I don't know :)
13:38:55 <ray> wli: parsing irc is a favorite project of irc addicts like us
13:39:10 <ehird> ooh, parsing IRC.
13:39:17 <ehird> the funnest pointless trivial task around!
13:39:18 <Gracenotes> Philonous: okay... I still think scanl might be implementable, though :)
13:39:23 <Olathe> Next, we need to work on pausing IRC.
13:39:38 <wli> Try parsing other protocols, e.g. IMAP, LDAP, SNMP, SMTP, etc.
13:39:44 <ehird> Pfft, those aren't IRC.
13:39:52 <ray> i'm not a mail addict
13:39:52 <Olathe> Haha
13:39:53 <ehird> I don't even use those protocols! Well, except for IMAP. And SMTP.
13:39:58 <Gracenotes> doing X with only Y is interesting, imho
13:40:00 <shapr> Actually, I'd like to see a protocol parsing project.
13:40:11 <Gracenotes> for example... er... hello world only with the IO monad! :X
13:40:22 <Olathe> Write stuff using only Bools and nands.
13:40:24 <ray> hello  world with only the Either monad
13:40:25 <Peaker> shapr: hopefully, the parsers will be bidirectional as pickler combinators, and not "parsers"
13:40:35 <ehird> ooh, I love bidirectional things.
13:40:37 <Gracenotes> use entirely polymorphic functions to do arithemetic
13:40:41 <Gracenotes> (church encoding)
13:40:48 <ehird> church encoding fails in haskell unfortunately
13:40:51 <ehird> due to the type system
13:40:52 <shapr> Peaker: Oh that would be cool, got any demos of that?
13:41:05 <BMeph> s/Church/Scott/g! ;)
13:41:07 <Peaker> shapr: nope, I started working on something like that, and it was more difficult than I had imagined :)
13:41:07 <Gracenotes> ehird: it /can/ work sometimes.
13:41:19 <Gracenotes> ehird: if you relax everything a little
13:41:20 <Peaker> shapr: so I abandoned it for my other projects, for now (I have too many personal projects!)
13:41:25 <ehird> Text/Regex/DFA/Common.hs:6:7:
13:41:25 <ehird>     Could not find module `Data.IntMap':
13:41:26 <ehird>       it is a member of package containers-0.2.0.0, which is hidden
13:41:28 <ehird> Not THIS again.
13:41:30 <vixey> BMeph, Scott-Mogunus!
13:41:32 <shapr> Peaker: Ah, well if you have anything written up about it, would be neat.
13:41:38 <Peaker> shapr: its surely possible, I just couldn't figure out the good combinators to build it on
13:41:56 <vixey> Mogensen**
13:42:16 <Peaker> shapr: I started with a seemingly simple (but not easy to specify) example of "excel csv", and all the escaping rules are really hard to specify in a bidirectional way
13:42:18 <ehird> aha!
13:42:29 <ehird> regex-dfa doesn't build on recent ghcs :-S
13:42:34 <yitz> ehird: i imagine oleg would be able to do church encoding in the Haskell type system
13:42:42 <ehird> Deewiant: coadjute depends on regex-dfa, which doesn't build
13:42:47 <redditbot> Submit a paper to the Haskell Symposium
13:42:48 <Gracenotes> ehird: for instance, iszero n = \x y -> n (\z -> y) x
13:42:49 <BMeph> vixey: Okay, I was about to ask who "Mogunus" was... ;)
13:43:03 <ehird> Gracenotes: the types mess up after a while
13:43:08 <ehird> e.g. you can't do addition
13:43:11 <Heffalump> what is redditbot?
13:43:23 <conal> luqui: ping
13:43:24 <Heffalump> oh, telling us about new reddit links, I see
13:43:25 <Gracenotes> let church n = \f z -> (iterate f z) !! n
13:43:27 <vixey> Heffalump, just some obnoxious thing
13:43:28 <wli> notes support for a broad spectrum of network protocols would enhance Haskell's reputation as a practical language.
13:43:35 <luqui> conal, pong
13:43:37 <Gracenotes> a Haskelly way to Church encode numbers
13:43:41 * wli notes, even.
13:43:52 <Deewiant> ehird: I know. regex-dfa's problem, not mine.
13:43:53 <Gracenotes> entirely breaks the internals of the lambda calculus, but it works
13:44:03 <ehird> Is it possible to fix a package on hackage that you don't own?
13:44:06 <conal> luqui: look under "the fundamental chain rule" in http://en.wikipedia.org/wiki/Chain_rule .
13:44:06 <PeakerLambda> Title: Chain rule - Wikipedia, the free encyclopedia
13:44:09 <ehird> that is ,to make it work with split base
13:44:18 <Heffalump> ehird: I think if you establish it's been abandoned you can do so
13:44:25 <conal> luqui: and then the manifold formulation in terms of tangent bundles.
13:44:43 <int80_h> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1115#a1115
13:44:45 <ehird> (c) 2006
13:44:48 <ehird> uploaded 2007
13:44:51 <ehird> dead enough for me.
13:44:57 <Gracenotes> ehird: it is possible to write a Y combinator in Haskell, of course... but it's not the same as the lambda calculus, intensionally
13:45:02 <int80_h> could someone take a peek at my attempt at using foldl'
13:45:44 <luqui> conal, I'm knee deep in dependent types here... that property is reminiscent, isn't it?
13:45:50 <Gracenotes> @type (+).digitToInt
13:45:51 <PeakerLambda> Char -> Int -> Int
13:46:11 <conal> luqui: the compositional/functor property?
13:46:16 <iwannalog> @type digitToInt
13:46:17 <PeakerLambda> Char -> Int
13:46:20 <int80_h> Gracenotes: trying to use partial application
13:46:24 <luqui> conal, yeah
13:46:26 <skorpan> hey. if i want to write a (seemingly) simple application which just pings a host, where do i start looking?
13:46:29 <iwannalog> > digitToInt '0'
13:46:30 <PeakerLambda>   0
13:46:35 <iwannalog> > digitToInt 'a'
13:46:36 <PeakerLambda>   10
13:46:36 <luqui> conal, well, no, the first one
13:46:39 <iwannalog> > digitToInt '.'
13:46:40 <PeakerLambda>   * Exception: Char.digitToInt: not a digit '.'
13:46:43 <conal> oh, yeah.
13:46:44 <iwannalog> > digitToInt 'g'
13:46:45 <PeakerLambda>   * Exception: Char.digitToInt: not a digit 'g'
13:46:49 <iwannalog> > digitToInt 'f'
13:46:50 <PeakerLambda>   15
13:46:53 <iwannalog> > digitToInt 'F'
13:46:54 <PeakerLambda>   15
13:47:05 <luqui> conal, maybe I'm just seeing non-connections due to immersion
13:47:16 <conal> luqui: check out the second one.  it's "compositional" in the semantic sense.
13:47:23 <idnar> skorpan: you need to be root to send ICMP packets, so that's not all that simple (unless you just fire up /usr/bin/ping or something)
13:47:32 <luqui> conal, oh right!
13:47:42 <Gracenotes> int80_h: you're not really using (.) correctly, again :)
13:47:57 <int80_h> again! ugh...okay
13:47:57 <skorpan> idnar: so how does /usr/bin/ping do it?
13:47:59 <conal> luqui: wild, huh!  now i'm trying to get a sense of what tangent bundles are about.
13:48:03 <idnar> skorpan: it's setuid root
13:48:05 <luqui> conal, yeah, and differentiation on tangent bundles is where that absolutely beautiful statement of stokes theorem comes from
13:48:09 <Gracenotes> int80_h: does "show . 8" make sense?
13:48:13 <idnar> er, that's /bin/ping I guess, but whatever
13:48:15 <skorpan> ah... but can't i setuid with haskell?
13:48:18 <luqui> conal, I don't really know much about it though
13:48:31 <ray> you still have to be root
13:48:33 <Gracenotes> :t (.)
13:48:34 <PeakerLambda> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:48:42 <idnar> skorpan: well, there's no reason you couldn't make a haskell binary suid root, it's just getting out of "simple" territory :P
13:48:49 <int80_h> Gracenotes: on in the sense that I recognize patterns, and I've seen that pattern before
13:48:58 <luqui> conal: stokes theorem: integral_dS f = integral_S df
13:49:00 <idnar> (you need to start worrying about potential security holes allowing privilege elevation, and so on)
13:49:12 <ehird> Question... with the split_base thing, does cabal 'automagically' choose it?
13:49:16 <ehird> If not, how do I make it work with hackage?
13:49:17 <idnar> also, I have no clue how to send ICMP packets in Haskell, but that's a separate matter
13:49:18 <Gracenotes> int80_h: (.) is for when you have two functions to apply to an initial value
13:49:19 <int80_h> Gracenotes: oh wait, you didn't provide a function to 8..no that doesn't make any sense
13:49:24 <iwannalog> conal: do you want a pdf ?
13:49:25 <ehird> Bit confusing.
13:49:31 <skorpan> idnar: but i suppose there is an even simpler way then, just using /bin/ping and getting the output from it. *now* where do i start looking? :)
13:49:32 <Gracenotes> int80_h: ($) is for when you have one function. Generally
13:49:40 <int80_h> Gracenotes: I thought I was using partial application to provide that initial value
13:49:54 <Gracenotes> int80_h: in this case, your initial value is (2^x)
13:50:01 <shapr> @users
13:50:02 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:50:03 <conal> iwannalog: of?
13:50:06 <shapr> hmm
13:50:08 <iwannalog> tangent bundles
13:50:14 <glguy> shapr, 660
13:50:16 <iwannalog> but you could have find it
13:50:17 <shapr> Ah, thanks
13:50:20 <ehird> Hmm...
13:50:30 <int80_h> Gracenotes: so if I want . to do what I want, I have to be explicit
13:50:32 <ehird> Should I do split_base or is just using the newer dependency style OK? Considering that I'm fixing a dormant package...
13:50:41 <conal> iwannalog: a pdf of an doc on tangent bundles?
13:50:57 <iwannalog> a pdf of a document yes
13:50:59 <Gracenotes> int80_h: try writing th entire function without partial application first
13:51:02 <Gracenotes> *the
13:51:02 <conal> iwannalog: yeah.
13:51:06 <skorpan> now that i think of it, i believe i don't really *need* a ping, i just need to try to contact google.com and see if i can.
13:51:07 <iwannalog>   but it's a bit more general
13:51:11 <Gracenotes> int80_h: then take off extra parameters as you see fit
13:51:13 <skorpan> Network.Curl?
13:52:00 <conal> Network.VectorCalculus.Curl
13:52:05 <int80_h> Gracenotes: Okay I think I have the source of my confusion. I thought the initial value would be the first char in the string
13:52:14 <iwannalog> conal: firewall problem I think
13:52:15 <iwannalog> http://www.math.cornell.edu/~hatcher/VBKT/VBpage.html
13:52:16 <PeakerLambda> Title: Vector Bundles & K-Theory Book
13:52:32 <conal> iwannalog: thanks!
13:52:58 <iwannalog> conal: but it will explain other things
13:53:01 <wli> Well, one thing is that Haskell's formal methods stuff have some sort of beneficial security implications.
13:53:10 <int80_h> Gracenotes: because foldl' take the head of a list and applies a function to it, and some other value right?
13:53:15 <vixey> which formal methods stuff?
13:54:23 <wli> The proof of correctness stuff that goes around with algebraic types and other things.
13:54:33 <Gracenotes> int80_h: foldl is of type (a -> b -> a) -> a -> [b] -> a. So in f, the first parameter is the accumulator, and the second parameter is the next element of the list
13:55:40 <bos> @seen dons
13:55:41 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:55:55 <bos> bollocks.
13:56:00 <int80_h> in f? is f (a -> b -> a)?
13:56:04 <Gracenotes> yeah
13:56:13 <bos> who owns hpaste2?
13:56:17 <glguy> bos, try /whois dons dons
13:56:24 <glguy> bos, it will give you his idle time
13:56:27 <Gracenotes> > foldl (\acc x -> acc - x) 0 [3,2,1]
13:56:28 <glguy> bos, I do
13:56:29 <PeakerLambda>   -6
13:56:30 <bos> glguy: cheers
13:56:34 <bos> glguy: oh!
13:56:37 <glguy> bos, well, I wrote much of the code
13:56:37 <mauke> preflex: seen dons
13:56:38 <preflex>  dons was last seen on #haskell 23 minutes and 51 seconds ago, saying: annd do we want to redirect it to moonpatio, or move moonpatio?
13:56:40 <glguy> mmorrow is hosting
13:56:49 <Gracenotes> int80_h: in that case, it's ((0-1)-2)-3
13:56:53 <glguy> mmorrow, you there?
13:56:59 <Gracenotes> > foldl (\acc x -> x:acc) 0 [3,2,1]
13:57:00 <PeakerLambda>   No instance for (GHC.Num.Num [b])
13:57:00 <PeakerLambda>    arising from the literal `0' at <inter...
13:57:00 <rwbarton> dons: Hopefully I've sent you a patch to rss2irc adding an option to include link URLs. (first time using darcs send)
13:57:07 <Gracenotes> > foldl (\acc x -> x:acc) [] [3,2,1]
13:57:08 <PeakerLambda>   [1,2,3]
13:57:11 <bos> glguy, mmorrow - want a host to run hpaste on? i own the hpaste.org domain, and can help with getting it going.
13:57:35 <tibbe__> I know there's a guy for library proposal somewhere on the wiki but I can't find it, anyone have it bookmarked?
13:57:46 <lilac> > let foldl f x xs = zipWith f (x:foldl f x xs) xs in foldl f x [0,1,2,3] :: [Expr]
13:57:47 <PeakerLambda>   [f x 0,f (f x 0) 1,f (f (f x 0) 1) 2,f (f (f (f x 0) 1) 2) 3]
13:57:51 <glguy> mmorrow, bos: if mmorrow is happy hosting hpaste, I'd support you pointing hpaste.org to his site
13:57:57 <shapr> yes!
13:58:20 <shapr> I still haven't gotten around to fixing a forward page or anything.
13:58:20 <BMeph> vixey: ...so who's Mogensen? :)
13:58:28 <int80_h> Gracenotes: in my case, say I did sum2 10, the next element in the list would be "1", right
13:58:33 <bos> glguy: running it on port 8080 is kinda cheezy
13:58:45 <glguy> bos, ah, agreed
13:58:47 <Gracenotes> int80_h: I don't want to confuse things, but try comparing these two types...
13:58:51 <Gracenotes> (b -> a -> a) -> a -> [b] -> a
13:58:52 <shapr> vixey: Torben Ae gidius Mogensen?
13:58:53 <Gracenotes> (a -> b -> a) -> a -> [b] -> a
13:58:59 <bos> shapr: thanks for the pointer, btw
13:59:01 <Gracenotes> the first one is foldr; the second on is foldl
13:59:14 <shapr> bos: Er, what pointer?
13:59:27 <lilac> @pl \f x xs = fix (\k -> zipWith f (x:k) xs)
13:59:27 <PeakerLambda> (line 1, column 9):
13:59:27 <PeakerLambda> unexpected "="
13:59:27 <PeakerLambda> expecting pattern or "->"
13:59:34 <lilac> @pl \f x xs -> fix (\k -> zipWith f (x:k) xs)
13:59:34 <bos> shapr: you twittered its location to me
13:59:37 <PeakerLambda> ((fix .) .) . (flip .) . flip ((.) . (.) . zipWith) (:)
13:59:37 <PeakerLambda> optimization suspended, use @pl-resume to continue.
13:59:38 <shapr> bos: oh right!
13:59:48 <lilac> @pl-resume
13:59:49 <Gracenotes> int80_h: with foldl, the function is \accumulator value -> something of type accumulator
13:59:54 <PeakerLambda> ((fix .) .) . (flip .) . flip ((.) . (.) . zipWith) (:)
13:59:55 <PeakerLambda> optimization suspended, use @pl-resume to continue.
14:00:01 <Gracenotes> int80_h: with foldr, the function is \value accumulator -> something of type accumulator
14:00:35 <lilac> > (((fix.).).(flip.).flip((.).(.).zipWith)(:)) (+) 0 [1..10]
14:00:36 <PeakerLambda>   [1,3,6,10,15,21,28,36,45,55]
14:00:46 <lilac> well, that was pointless :)
14:01:06 <Gracenotes> int80_h: if you can think of it this way... in a sense, the argument order reflects how foldr and foldl are different.
14:01:42 <Gracenotes> foldr takes the arguments in order "value accumulator", and what you do it append the value onto the result for the rest of the list
14:02:17 <int80_h> Gracenotes: sounds like what I want!
14:02:21 <lilac> > (foldl (+) x [1..5] :: [Expr], foldr (+) x [1..5] :: [Expr])
14:02:21 <PeakerLambda>   Couldn't match expected type `[SimpleReflect.Expr]'
14:02:50 <Gracenotes> int80_h: however, the list is going in reverse, in a sense
14:02:57 <Gracenotes> > foldr (+) 0 [a,b,c,d,e]
14:02:58 <PeakerLambda>   a + (b + (c + (d + (e + 0))))
14:03:30 <tibbe> @seen dcoutts
14:03:31 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:03:38 <yitz> @unpl (((fix.).).(flip.).flip((.).(.).zipWith)(:)) (+) 0 [1..10]
14:03:38 <PeakerLambda> (fix (\ e -> zipWith (+) ((:) 0 e) [1 .. 10]))
14:03:40 <Gracenotes> that takes argument in the order value accumulator -- and you can see that, for instance, "a" is the value and "(b + (c + (d + (e + 0))))" is the accumulator
14:03:51 <int80_h> Gracenotes: that should be fine,
14:04:08 <int80_h> reverse order I mean
14:04:34 <yitz> now that's unpointless
14:04:42 <vixey> Grace, I have a different view of foldr
14:05:06 <vixey> it just replaces all the (:) in the list with your cons, all the [] in the list with your supplied nil
14:05:13 <int80_h> Gracenotes: so I should be trying to use foldr, then?
14:05:46 <vixey> http://en.wikipedia.org/wiki/Mogensen-Scott_encoding
14:05:58 <mmorrow> bos: if i didn't have to use moonpatio.com as the domain name, i'd be happy to run it on port 80
14:06:48 <yitz> int80_h: the general rule is: if the result needs to be lazy, like an infinite list, use foldr. otherwise, use foldl'.
14:07:02 <mmorrow> (it's temporarily on moonpatio.com:80 for now, but i need moonpatio.com in a bit)
14:07:08 <mmorrow> (it's also on :8080)
14:07:31 <Gracenotes> int80_h: hm.... what does your function do, exactly?
14:07:32 <bos> mmorrow: i can give you a login on a debian box that you can use to host it, if you like.
14:07:43 <Gracenotes> example parameters and result
14:08:07 <mmorrow> bos: i have plenty of hosting space and ip addrs, just not plenty of domain names :)
14:08:21 <Heffalump> domain names are cheap!
14:08:28 <mmorrow> heh, true
14:08:47 <mmorrow> but thinking of non-taken ones is hard
14:08:47 <Peaker> conal: hey, I noticed you wrote that wrapping imperative libraries with pure interfaces can be problematic, right?
14:08:51 <Gracenotes> int80_h: ah, it adds the digits of a number?
14:09:00 <Botje> hmm
14:09:02 <Botje> hpaste.be is free
14:09:03 <yitz> mmorrow: System.Random is useful for that
14:09:07 <mmorrow> (non-taken ones that don't suck)
14:09:09 <Botje> i could donate a few euros for the cause :)
14:09:12 <int80_h> Gracenotes: sum2 10 would yield 7
14:09:19 <mmorrow> omg, emacs.vi is free last i checked ...
14:09:20 <bos> mmorrow: i can just point hpaste.org at a server of yours, then?
14:09:22 <Gracenotes> int80_h: well, addition is commutative, so you could implemenet it with both foldr and foldl
14:09:27 <int80_h> Gracenotes: yeah that's what I want. this si for project euler
14:09:32 <rwbarton> emacs.isbetterthan.vi
14:09:46 <ehird> trolls.arebetterthan.cake
14:09:51 <mmorrow> bos: that's ok with me. first though, let me switch hpaste2 to a different ip
14:09:57 <ehird> also, .vi isn't a valid domain
14:09:57 <ehird> is it?
14:10:03 <bos> mmorrow: ok
14:10:04 <int80_h> Gracenotes: that is why I didn't think reverse application would be a problem. But I thought you were leading me to folr because it would be the easier way to go
14:10:07 <ehird> huh, it is
14:10:17 <mmorrow> bos: i'll let know once i get it done
14:10:17 <rwbarton> ehird: What is it?
14:10:22 <Heffalump> mmorrow: you could also make a subdomain of one you already own
14:10:27 <mmorrow> ehird: oh yesh it's valid
14:10:29 <ehird> virgin islands
14:10:31 <Gracenotes> int80_h: nah, it's just a mnemonic I use -- regarding argument order -- to imagine how both functions work
14:10:31 <Peaker> conal: I wanted to mention lui -- a purely functional widget set that I am working on. Its based on SDL (I hope to adapt it to GLUT at some point, preferably with an abstraction layer that works with either).  Thought it might be of interest to you
14:10:33 <rwbarton> ah
14:10:33 <conal> Peaker: kind of.  more like the very goal itself encourages muddled thinking.
14:10:34 <ehird> only $35/year!
14:10:37 <ehird> I must have emacs.vi
14:10:43 <Gracenotes> int80_h: foldl is helpful if you have a huge number of digits
14:10:57 <int80_h> Gracenotes: I do. 2^1000 is the number
14:11:04 <Gracenotes> foldl', that is
14:11:07 <drhodes> does ghci have a clear function, to wipe the chars off the screen, the history buffer holds repeated \n from holding the enter key down.  <whine>
14:11:11 <int80_h> Gracenotes: I'm just using small numbers as test cases
14:11:16 <yitz> conal: quicksilver's reaction was exactly the same
14:11:18 <ztirF> what kind of function would you use to fit a smooth 2D surface?  Legendre polynomials?
14:11:20 <rwbarton> drhodes: Ctrl-L?
14:11:22 <Gracenotes> int80_h: have you looked at the source of sum?
14:11:22 <mmorrow> Heffalump: but that would be like 20+ minutes of rtfm'ing... ;)
14:11:24 <conal> yitz: oh?
14:11:25 * drhodes checks
14:11:27 <Gracenotes> @src sum
14:11:27 <PeakerLambda> sum = foldl (+) 0
14:11:28 <ehird> how can I generate haddock documentation for all installed cabal packages?
14:11:30 <int80_h> @src sum
14:11:31 <ziman> drhodes, ^L ?
14:11:31 <PeakerLambda> sum = foldl (+) 0
14:11:38 <drhodes> \o/ SUCCESS
14:11:38 <conal> yitz: i wonder if for similar reasons.
14:11:44 <Heffalump> mmorrow: are you handling your own DNS?
14:11:45 <bos> mmorrow: ok, send me email or something
14:11:47 <yitz> probably
14:11:48 <Gracenotes> int80_h: you could also define a sum' = foldl' (+) 0
14:12:12 <mmorrow> Heffalump: no, i'm using the co's i bought ther names through
14:12:15 <int80_h> Gracenotes: sum wants a list though right?
14:12:19 <mmorrow> bos: will do
14:12:20 <Gracenotes> yeah
14:12:25 <Heffalump> ok, then it's not easy
14:12:37 <Badger> @seen PeakerLambda
14:12:37 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:12:39 <Peaker> conal: Widget is a   model -> functionRecord { size, draw, getKeymap }    where size/draw are limited to a Compute/Draw monad (not Monoid, because text size computations require IO, so I wrap it in a safe monad), and getKeymap returns a dictionary mapping keys to new models to switch to
14:12:40 <conal> Peaker: a purely functional wrapper can eliminate the semantic complexity of imperative programming (in Haskell, the IO type).  or it can hide it.
14:12:41 <mmorrow> Heffalump: no biggy, i have like 8 free ip addrs
14:12:43 <Badger> oh, not at all
14:12:44 <int80_h> Gracenotes: I was trying to do a variation on sum. one reason I picked foldl'
14:12:59 <Peaker> conal: well, I am writing the widget set itself, not wrapping one
14:13:00 <yitz> conal: if not a widget set, then what will be the reactive equivalent way of writing platform-flexible guis?
14:13:06 <Gracenotes> int80_h: you might find "map" useful in this case
14:13:12 <int80_h> Gracenotes: but instead of (+) I wrote my own function
14:13:23 <int80_h> Gracenotes: but map yields a list
14:13:46 <int80_h> Gracenotes: I thought about map but discarded it as appropriate. How would map be helpful?
14:13:49 <yitz> conal: and what does topology and k theory have to do with it?
14:14:00 <int80_h> I mean inapproproate
14:14:02 <int80_h> bah
14:14:14 <Peaker> conal: I would love feedback if you can afford to look. I think it should lend itself neatly to Reactive too: http://www.reddit.com/r/haskell/comments/7u0mb/a_purely_functional_haskell_widget_set/
14:14:15 <PeakerLambda> Title: A purely functional Haskell widget set : haskell, http://tinyurl.com/cy2lfh
14:14:17 <conal> yitz: i have no idea.
14:14:17 <Gracenotes> int80_h: start with your input, 2^1000
14:14:25 <Gracenotes> how can you make that into a list somehow?
14:14:36 <int80_h> Gracenotes, with show
14:14:48 <Gracenotes> okay. Once you have show, what is it a list *of*?
14:14:59 <int80_h> Gracenotes: [Char]
14:15:14 <Peaker> conal: I noticed a very close relationship between semantic editor combinators and functional references there, too
14:15:16 <Gracenotes> how can you make that a list of [Int], that you can sum and get your answer?
14:15:19 <int80_h> oooh! I could map digitToInt over it!
14:15:21 <yitz> conal: about the gui,, or about the k-theory?
14:15:28 <Gracenotes> int80_h: :D
14:15:32 <conal> yitz: the k-theory connection.
14:15:37 <int80_h> Gracenotes: which would make a [Int]!
14:15:40 <yitz> oh :)
14:15:56 <int80_h> gracenotes: nice. Okay, so much for my foldl' adventure
14:16:00 <conal> Peaker: i've been working with jefferson heard to explore whether hieroglyph can have a clear semantic foundation, which leads to some great benefits of compositionality, formal properties, etc.  if you're (really) interested, we could do some of the same w.r.t your library.
14:16:24 <conal> Peaker: for me, it's more defined goal than "purely functional".
14:16:30 <Peaker> conal: yeah, definitely interested :-)
14:16:45 <Peaker> conal: well, "purely functional" is a better start than everything being in IO :-)
14:16:59 <conal> Peaker: only sometimes.
14:17:34 <conal> Peaker: sometimes "purely functional" is a label that hides the truth.
14:17:48 <Gracenotes> int80_h: also, there's something called map fusion, that means that your solution could have been equivalent to using map.
14:17:48 <Peaker> conal: I don
14:17:51 <Gracenotes> but much more complicated
14:17:53 <Peaker> conal: 't think its the case here
14:17:56 <conal> Peaker: in other words the label might be merely accurate, rather than true.
14:18:20 <conal> Peaker: do you have a clear sense of what you mean by "purely functional" here?
14:18:26 <m3ga> Is there a haskell equivalent to the POSIX stat function?
14:18:32 <Gracenotes> int80_h: foldl f v . map g = foldl (\a x -> f a (g x)) v
14:18:48 <Gracenotes> or, for you, it's... sum . map digitToInt = foldl (+) 0 . map digitToInt = foldl (\a x -> a + digitToInt x) 0
14:19:04 <mauke> m3ga: http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Files.html#4
14:19:05 <PeakerLambda> Title: System.Posix.Files, http://tinyurl.com/2c4o79
14:19:06 <dcoutts> ehird: you can enable building of docs by default in the ~/.cabal/config file
14:19:14 <dcoutts> tibbe: pong
14:19:16 <ehird> dcoutts: I did.
14:19:21 <ehird> That doesn't account for libs I already have :)
14:19:21 <int80_h> Gracenotes; map fusion sounds like something I won't be getting to yet
14:19:27 <Peaker> conal: Well, the only code in IO or State monads is in the main loop.  My Widget declaration is at: http://github.com/Peaker/lui/blob/54034af819356897828932b38cfeb158f99e12c1/Widget.hs  -- widgets are a function from model to a draw function that only composes draw operations, and an events dictionary, whose values are new values of the model
14:19:29 <PeakerLambda> Title: Widget.hs at 54034af819356897828932b38cfeb158f99e12c1 from Peaker's lui - GitHub, http://tinyurl.com/b828qd
14:19:34 <int80_h> Gracenotes: trying to take the language in pieces
14:19:50 <dcoutts> ehird: ok, you're all set then. From now on all packages you build will get docs.
14:19:53 <Heffalump> is just setting haddockdir enough for that?
14:19:54 <rwbarton> @free foldl'
14:19:54 <vixey> map f . map g = map (f . g)  why?
14:19:55 <PeakerLambda> (forall x. f . h x = k (f x) . g) => f . foldl' h y = foldl' k (f y) . $map g
14:19:55 <tibbe> dcoutts: is it still necessary to use a split-base flag in .cabal files? I just looked at Data.Text's and it doesn't use one
14:20:06 <ehird> dcoutts: ... but I need docs for packages I already have :)
14:20:12 <Gracenotes> int80_h: all it means is that you were trying to write one big foldl, but a foldl and a map would have worked too
14:20:20 <Gracenotes> which is a more elegant solution, I think :)
14:20:26 <tibbe> @dcoutts also, is it really safe to depend on base < 5.0? base 4.1 is one major version number from base 4.0
14:20:26 <PeakerLambda> Unknown command, try @list
14:20:30 <conal> Peaker: the fundamental question for me is always "What does it mean?"  Everything else follows.
14:20:30 <yitz> vixey: because List is a functor?
14:20:41 <m3ga> mauke: thanks. searched the docs and couldn't find it. the name was too different from what I was expecting.
14:20:43 <Gracenotes> if not somewhat more performance-intensive :/ very slightly
14:20:52 <dcoutts> tibbe: it's probably not been tried with 6.6 and it's questionable as to if we want to since we're really aiming for ghc-6.12 and base 4/5
14:20:54 <Peaker> conal: Well, if the answer to that has to be a type-class morphism, I don't have that yet :-)
14:21:10 <mauke> m3ga: just be glad 'stat' is mentioned in the description now :-)
14:21:20 <mauke> that hasn't always been there
14:21:23 <tibbe> dcoutts: so if I want to skip split-base I should aim for 6.8 and what cabal version?
14:21:25 <Peaker> conal: A widget is basically an editor of a model, usually via a functional-reference to that model
14:21:26 <conal> Peaker: before you get to TCMs, can you describe what your widgets (etc) *mean*, precisely and without appealing to what IO means?
14:21:37 <dcoutts> tibbe: base seems to jump in it's first digit. it's not really been formalised.
14:21:52 <Peaker> conal: is that a good definition of a widget's meaning?
14:21:53 <tibbe> dcoutts: my rule of thumb is usually to aim for the latest version of GHC available on Ubuntu if possible
14:21:53 <conal> Peaker: if you can give a precise semantics more simply than IO, that's what i call "genuinely functional", or "denotational".
14:21:54 <dcoutts> tibbe: ghc-6.8 came with cabal-1.2.x
14:21:58 <Gracenotes> int80_h: also, same thing with foldr. foldr f v . map g = foldr (f . g) v
14:21:58 <m3ga> mauke: in Ocaml, its called stat and its in the Unix module. *really* easy to find :-)
14:22:00 <tibbe> dcoutts: ok
14:22:02 <Gracenotes> but that's a different story
14:22:06 <dcoutts> tibbe: which is what these days?
14:22:12 <tibbe> dcoutts: 6.8 I believe
14:22:13 <conal> Peaker: is *what* a good definition ?
14:22:14 <mauke> m3ga: I know
14:22:19 <rwbarton> @free foldr
14:22:19 <dcoutts> tibbe: that's good
14:22:19 <PeakerLambda> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
14:22:22 <Peaker> conal: "A widget is basically an editor of a model"
14:22:33 <int80_h> Gracenotes: okay I'll look into map fusion. Just seems to be a combination of things I already know
14:22:36 <int80_h> of
14:22:43 <Gracenotes> yeah.
14:22:43 <conal> Peaker: thx.  perhaps.  what's an editor?  model -> model ?
14:22:44 <tibbe> dcoutts: because then new haskell hackers don't need to complain about having compile the compiler to get started
14:22:54 <dcoutts> dons: I note you've updated mkcabal. Do you want to integrate it into cabal-install?
14:23:02 <Peaker> conal: That's the setter part of the editor, yes.  But its also   model -> Draw
14:23:06 <Gracenotes> rwbarton: free?
14:23:08 <Gracenotes> @help free
14:23:08 <PeakerLambda> free <ident>. Generate theorems for free
14:23:24 <Gracenotes> oh, cute (?)
14:23:37 <Gracenotes> @free map
14:23:38 <PeakerLambda> g . h = k . f => $map g . map h = map k . $map f
14:23:39 <tibbe> dcoutts: so it's good to model my .cabal file after http://code.haskell.org/text/text.cabal ?
14:23:42 <conal> Peaker: getting there.  two more questions: (1) is 'model' a type parameter? and (2) what's Draw?
14:23:44 <BMeph> ehird: Check for "let.them.eat.ca.ke" ;p
14:24:03 <tibbe> dcoutts: I guess the ghc >= 6.10 check is to force base-4 on systems that have it
14:24:03 <dcoutts> tibbe: I would not take that as gospel, I've not reviewed it for portability.
14:24:03 <Peaker> conal: yeah, model is a type parameter. Draw is somewhat like Geometry2, but a Monad rather than Monoid so you can query things like text render sizes
14:24:05 <ehird> So... how could I generate haddock documentation for _already installed_ packages?
14:24:05 <rwbarton> Gracenotes: your statement is the g = id case of @free foldr
14:24:10 <tibbe> dcoutts: ok
14:24:29 <conal> Peaker: what's the meaning of Draw?
14:24:36 <conal> Peaker: (i mean precisely)
14:24:43 <Gracenotes> hrm
14:24:50 <yitz> hpaste.it is available too
14:25:17 <conal> Peaker: Monad/Monad/... are interface slices, not meanings.
14:25:22 <Peaker> conal: Its a sequence of potentially moved (I intend to support scaling, later) drawing operations, in pixel-surface terms
14:25:25 <mmorrow> yitz: heh, nice
14:25:33 <conal> Peaker: with laws also, so constraints on meanings.
14:25:45 <rwbarton> hpaste.it/now
14:25:46 <mmorrow> .it is a good suffix
14:25:52 <mmorrow> especially for verb names..
14:25:56 <Peaker> conal: Where drawing operations may have results (basically textSize is the only such operation)
14:25:57 <conal> Peaker: make that definition precise, and we'll have a starting point for a design.
14:25:58 <dons> ?yow
14:25:59 <PeakerLambda> Couldn't find fortune file
14:26:04 <yitz> mmorrow: the italians know that, and charge for it
14:26:09 <mmorrow> yitz: haha
14:26:16 <pumpkin> @type fmap ((,) a) f
14:26:17 <PeakerLambda> forall a (f :: * -> *). (SimpleReflect.FromExpr (f a), Functor f) => f (Expr, a)
14:26:22 <augustss> dcoutts: how can i make 'cabal fetch' tell me where the already downloaded package actually is?
14:26:29 <pumpkin> @type \a f -> fmap ((,) a) f
14:26:30 <PeakerLambda> forall a a1 (f :: * -> *). (Functor f) => a -> f a1 -> f (a, a1)
14:26:47 <dons> bos?
14:27:01 <dcoutts> augustss: the answer is get the darcs version of cabal-install. It's got cabal unpack which is what you probably want.
14:27:02 <Philippa_> Peaker: so presumably what you get out of running one is a pixel surface, plus the usual monadic result?
14:27:06 <bos> dons: never mind, i got my answers elsewhere
14:27:09 <Peaker> conal: I think the Draw monad design is interesting, but it should be possible to discuss the widget's design without diving into its draw method and Draw monad meaning?
14:27:11 <dons> great.
14:27:17 <augustss> dcoutts: that is what I want
14:27:20 <conal> Peaker: please read (or reread) http://lukepalmer.wordpress.com/2008/07/18/semantic-design/ to get a sense of semantics-based design
14:27:24 <PeakerLambda> Title: Semantic Design « Luke Palmer
14:27:34 <dcoutts> augustss: yes, it's really handy.
14:27:38 <Philippa_> (another way of looking at it: what's the type of runDraw?)
14:27:41 <Heffalump> dcoutts: how do we get cabal to fetch and install from darcs? :-)
14:27:42 <Peaker> Philippa_: Not exactly a pixel surface, because you can use:  Draw.move :: Position -> Draw a -> Draw a
14:27:42 <augustss> dcoutts: except using the darcs version is not what I want
14:27:57 <dcoutts> augustss: I know. I'll be doing a release soon.
14:27:58 <Philippa_> (what would a 'mostly descriptive type' be?)
14:28:05 <Peaker> Philippa_: runDraw is called render :: HaskGame.Surface -> Position -> Draw a -> IO a
14:28:11 <Heffalump> sometimes I wonder if dcoutts's sole role in life is to be the target of cabal complaints
14:28:15 <Peaker> Philippa_: it renders to a surface
14:28:21 <dcoutts> Heffalump: yeah, probably. :-)
14:28:32 <Philippa_> Peaker: surely the moving just results in a surface with an offset rendering?
14:28:35 <conal> Peaker: so far, from your phrasing, i suspect you've got imperative stuff mixed into your thinking about the visual aspect.  i'd like to get it cleared up and simplified.
14:28:41 <dcoutts> Heffalump: you'll need another tool. Packages can now specify their source repos, darcs, git etc. So all the info is there to do what you want.
14:28:44 <augustss> Heffalump: That's the fate if you make a popular program.
14:28:44 <Philippa_> right, so handwave away the IO and what you get out is a surface
14:29:05 <rwbarton> augustss: isn't is always in .cabal/packages/hackage.haskell.org/<packagename>/<versionnumber>?
14:29:12 <Heffalump> dcoutts: but cabal (the binary) knows how to do almost all the other pieces of what's needed
14:29:16 <conal> Peaker: once you force yourself to make your thinking precise, then you'll be compelled to simplify/generalize it.
14:29:17 <augustss> rwbarton: not on windows
14:29:21 <dcoutts> Heffalump: I accept patches
14:29:23 <Heffalump> I can see why you wouldn't want to put VCS support into it
14:29:26 <tibbe> dcoutts: do you know by any change know how to find the library change submission process page on the wiki, tried for 20 mins now
14:29:29 <Peaker> conal: I modeled my Draw after your Geometry2. In fact, I started with a similar concept - but I couldn't draw a cursor after a certain amount of text :)
14:29:35 <Heffalump> oh, ok, I thought you were saying you wouldn't want it to do that
14:29:37 <dcoutts> Heffalump: I wouldn't mind supporting darcss and git
14:29:54 <int80_h> Gracenotes: I tried to implement what we talked about. Getting another type error
14:29:54 <Peaker> Philippa_: Yeah
14:29:57 <dcoutts> augustss: but if you were to try the darcs version before the release and tell me if there's anything obviously wrong that would be a great service.
14:30:00 <int80_h> Gracenotes: I'll post
14:30:04 <conal> Peaker: i mean a semantics, not an interface.
14:30:07 <dons> rwbarton: trying...
14:30:18 <Philippa_> Peaker: so an idealised semantics is that it yields a surface + computation result, right?
14:30:29 <Peaker> conal: If you use fieldtri to draw text, how do you draw a "cursor", for example, after a certain amount of text?
14:30:34 <Philippa_> (perhaps, that it /updates/ a surface, but...)
14:30:35 <redditbot2> Haskell with only one typeclass  http://www.reddit.com/r/haskell/comments/7u1u4/haskell_with_only_one_typeclass/
14:30:35 <redditbot2> Submit a paper to the Haskell Symposium  http://www.reddit.com/r/haskell/comments/7u3gl/submit_a_paper_to_the_haskell_symposium/
14:30:36 <redditbot2> Simulating n-bodies and functional programming  http://www.reddit.com/r/haskell/comments/7u0mu/simulating_nbodies_and_functional_programming/
14:30:37 <PeakerLambda> Title: Haskell with only one typeclass : haskell, http://tinyurl.com/crfowm
14:30:38 <PeakerLambda> Title: Submit a paper to the Haskell Symposium : haskell, http://tinyurl.com/cyrjfq
14:30:38 <dons> mm
14:30:39 <PeakerLambda> Title: Simulating n-bodies and functional programming : haskell, http://tinyurl.com/bkmoda
14:30:39 <redditbot2> A purely functional Haskell widget set  http://www.reddit.com/r/haskell/comments/7u0mb/a_purely_functional_haskell_widget_set/
14:30:39 <conal> Peaker: if you (re)read luke's post, i think you'll know what i mean.
14:30:41 <dons> needs tinyrul
14:30:41 <PeakerLambda> Title: A purely functional Haskell widget set : haskell, http://tinyurl.com/cy2lfh
14:30:41 <vixey> yay!
14:30:42 <redditbot2> #haskell is a busy place  http://www.reddit.com/r/haskell/comments/7tzqh/haskell_is_a_busy_place/
14:30:43 <pumpkin> ack
14:30:44 <PeakerLambda> Title: #haskell is a busy place : haskell, http://tinyurl.com/d5w2e2
14:30:50 <dons> ah ha mwhahah haha
14:30:53 <pumpkin> nice new redditbot :)
14:30:58 <int80_h> Gracenotes: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1115#a1117
14:31:02 <augustss> dcoutts: I'll have to install darcs first
14:31:03 <Peaker> Philippa_: yeah, though maybe more accurate to say it yields a set of drawing operations on a surface, rather than a surface (it draws to a given surface rather than return a new one)
14:31:06 <dons> so redditbot needs tinyurl, and pumpkinbot needs to ignore it.
14:31:06 <pumpkin> PeakerLambda: it's quite easy to remove the URL announcing from lambdabot btw
14:31:11 <Peaker> Philippa_: but that's more implementation than meaning
14:31:19 <pumpkin> this is PeakerLambda, not pumpkinbot :)
14:31:29 <dcoutts> tibbe: http://haskell.org/haskellwiki/Library_submissions
14:31:30 <Heffalump> augustss: are you being swallowed up by the git bandwagon, then? :-)
14:31:31 <PeakerLambda> Title: Library submissions - HaskellWiki
14:31:35 <conal> Peaker: i want to get you away from the idea of draw-ing altogether.
14:31:38 <pumpkin> I turned off URL announces in pumpkinbot
14:31:38 <Philippa_> Peaker: a surface transformer, nothing wrong with that
14:31:43 <augustss> Heffalump: we use git at work
14:31:50 <rwbarton> Maybe we can switch from PeakerLambda to pumpkinbot for the moment
14:31:56 <pumpkin> yay for forward-thinking workplaces
14:31:56 <vixey> @src Cont
14:31:56 <PeakerLambda> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
14:31:57 <Peaker> conal: Drawing is already a completely separate issue, not really an interesting part of the widget set
14:32:06 <Philippa_> conal: does "surface transformer" work, given a reasonable definition of "surface"?
14:32:07 <dcoutts> tibbe: the mediawiki search is terrible
14:32:12 <Philippa_> work for you, rather/
14:32:13 <Heffalump> augustss: officially?
14:32:15 <Philippa_> ?
14:32:18 <Gracenotes> int80_h: there might be a better way to compose the functions
14:32:21 <augustss> Heffalump: well, company policy is Clearcase, but we use git
14:32:37 <conal> Philippa_: depends on the person & context ("reasonable")
14:32:38 <pumpkin> @bot
14:32:38 <pumpkinbot> :)
14:32:38 <lunabot>  :)
14:32:38 <PeakerLambda> :)
14:32:41 <beelsebob> Peaker: why can it not simply be "an image", rather than doing the action of drawing something
14:32:42 <Gracenotes> int80_h: it seems you're abusing the "where" clause :)
14:32:52 <pumpkin> lots of smiley bots
14:32:52 <conal> beelsebob: exactly!
14:32:59 <conal> beelsebob++
14:32:59 <Peaker> Philippa_: the "render" does everything in IO and in-place, so its really not a transformer.  But that's the imperative mainloop part, I don't consider it part of the "widget set"
14:33:08 <int80_h> Gracenotes: I like to think of as working it hard, not abuse . ;)
14:33:13 <Gracenotes> int80_h: if a function has no arguments, try to fit it inline. It enhances readability in many cases (though not in others)
14:33:16 <Philippa_> conal: you get to be the person, reasonable for this purpose
14:33:17 <Peaker> beelsebob: Because an image has no result :-)
14:33:18 <augustss> dcoutts: and, of course 'cabal install darcs' fails :(
14:33:28 <beelsebob> Peaker: exactly ;)
14:33:28 <int80_h> Gracenotes: But I'll re-examine
14:33:29 <pumpkin> http://google.com
14:33:30 <vixey> @instances Monad
14:33:30 <PeakerLambda> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:33:30 <pumpkinbot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:33:31 <PeakerLambda> Title: Google
14:33:41 <Philippa_> Peaker: if you /had/ to you could copy the surface first. Don't worry about it :-)
14:33:53 <rwbarton> Can someone here part or kick PeakerLambda?
14:33:54 <int80_h> Gracenotes: I don't see where any of my functions don't have an argument
14:34:00 <dcoutts> augustss: does it? it should work, unless you're on windows in which case you need some -foptions
14:34:05 <Badger> rwbarton: it's the only lambdabot
14:34:06 <Peaker> beelsebob: I tried that approach - but I had a problem: How do I build a text image that has some other image put on the text at a certain position, depending on the text render size?
14:34:06 <Philippa_> Peaker: to put it another way, your run function can be treated as "destructively update a surface with..."
14:34:08 <rwbarton> int80_h: you're trying to compose functions and numbers again
14:34:18 <Peaker> Philippa_: yeah, true
14:34:19 <augustss> dcoutts: I am on Windows, it can't find -lcurl
14:34:35 <Gracenotes> int80_h: both listOfInts and stringedInt don't have an argument
14:34:40 <conal> Peaker: i'm very suspicious about your dismissing the draw part.  if the semantics are not important, then let's define them to be nulll, i.e., all widgets are completely invisible.
14:34:47 <Peaker> beelsebob: basically, my text edit widget wants to draw a cursor after cursor letters
14:34:59 <conal> Peaker: if you're not happy with invisible widgets, then the visual semantics are important to you.
14:34:59 <rwbarton> Badger: pumpkin has a better-configured one
14:35:04 <beelsebob> Peaker: you mean it wants to be a Behavior of an image?
14:35:06 <int80_h> Gracenotes: ah, okay what do you mean by inline then?
14:35:12 <beelsebob> that sometimes contains a vertical line
14:35:15 <beelsebob> and sometimes doesn't?
14:35:21 <Peaker> conal: well, we could for now specify that Draw is just an image, and ignore the "a" in (Draw a).  It would definitely work, I'd just have no cursor in my text edits :)
14:35:27 <tibbe> dcoutts: thanks
14:35:29 <conal> Peaker: otherwise, i think you're playing the same game as people who say IO is functional because they don't care about what actions *mean*.
14:35:32 <Badger> Peaker: you have configured and been found wanting :P
14:35:41 <pumpkin> aw
14:35:42 <dcoutts> augustss: I think you need -f-curl -f-libwww. It should end up selecting the Haskell http package. That should in theory work.
14:35:51 <dons> rwbarton: we need a tinyurl package
14:36:01 <vixey> :t (>>=)
14:36:02 <PeakerLambda> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:36:04 <conal> Peaker: we could do that.  and we could look for a denotational solution for cursors.
14:36:04 <Peaker> beelsebob: it wants to be a (String, Int) -> Image     where Int determines where the cursor lies, relatively to the letters. If its 2 it has to be after the render size of (take 2 text)
14:36:22 <dcoutts> augustss: the reason it's not automatic is that cabal cannot yet resolve flags automatically on non-haskell dependencies yet (ie presence of libcurl C lib).
14:36:29 <pumpkin> could just pull the tinyurl bit out of lambdabot for redditbot :) or even use is.gd, which is even shorter
14:36:40 <yitz> @slap PeakerLambda
14:36:40 <Gracenotes> int80_h: in this case (though it's still not correct in terms of type), sum2 x = sum . map digitToInt . show . (2^x)
14:36:41 * PeakerLambda jabs PeakerLambda with a C pointer
14:36:41 <beelsebob> Peaker: but why does "text render" have to be an action at all – why can't render :: String -> Image, and width :: String -> Int
14:36:51 <augustss> dcoutts: :(
14:36:54 <Philippa_> conal: I reckon I can see an easy enough one for cursors
14:37:01 <beelsebob> the latter returning the width of the image you get by rendering the text
14:37:02 <dcoutts> augustss: planned for Cabal 1.8 :-)
14:37:07 <Gracenotes> int80_h: but... how bout this. What's more useful, a function that takes a number and returns the sum of its digits, or a function that takes a number and returns the sum of the digits of 2 raised to it?
14:37:08 <dcoutts> augustss: however I think it's better to use darcs with curl, I'd go for a binary from darcs.net
14:37:16 <int80_h> Gracenotes: ah I was trying to prevent too long of a composition chain
14:37:17 <Philippa_> have everything work on unit sizes theoretically, transform the coordinate space around it
14:37:21 <conal> Philippa_: it's probably not very hard.  i want Peaker to *try*, rather than giving up on semantics.
14:37:31 <Heffalump> who does PeakerLambda belong to? Peaker?
14:37:32 <int80_h> Gracenotes, the first one
14:37:38 <Philippa_> conal: Peaker may not have the maths to figure it out though
14:37:39 <int80_h> Gracenotes: more general
14:37:40 <conal> Heffalump: or vice versa
14:37:43 <pumpkin> lol
14:37:45 <Gracenotes> int80_h: it will end up being a long composition chain. You can disguise it, but it'll still be a somewhat long chain
14:37:57 <Peaker> conal: I agree, you're right - my widget set is not "completely functional" and semantically sound if I don't fully define Draw well too.  But since I can for now treat (Draw a) as if it was just a Draw that represented an Image, that lets me compartmentalize the problem into the draw part, and the rest. I think the rest is sound, and I wonder if you have a better solution for the Draw part
14:37:58 <beelsebob> Philippa_: maybe worth letting him try before discounting him as a failure though ;)
14:38:04 <Gracenotes> int80_h: it might be easier to write the first function, then feed (2^1000) to it
14:38:29 <Gracenotes> don't fear long composition chains -- they're naturalish in functional programming
14:39:05 <Peaker> beelsebob: Unfortunately, those are the types of the underlying system.  FieldTrip has  utext :: String -> Geometry2   -- I have  text :: String -> Draw Size     -- not sure if there's that big a difference
14:39:26 <conal> Peaker: sounds good to me.  about the cursor, before looking for the answer, let's clarify the question (when you want to).  when the question is clear, i bet the answer will be easy.
14:39:32 <Peaker> beelsebob: both Geometry2 and Draw represent a "Drawing" or "Image", but Draw also has a size result
14:39:49 <beelsebob> Peaker: yeh, but "drawing" is a verb, "geometry" is a noun
14:39:51 <Gracenotes> int80_h: also... I hate to interfere even more, but your type signature is wrong
14:39:56 <beelsebob> one did the action
14:40:04 <beelsebob> the other is a thing
14:40:09 <Gracenotes> int80_h: try Int -> Int for now
14:40:11 <conal> "image" is also a thing.
14:40:22 <conal> also "picture".  "drawing" is ambiguous.
14:40:34 <Peaker> conal: ok, assuming we go back to a Draw type that simply represents an image,  I want to have  (String, Int) -> Draw  that builds an image of that text rendered, with a rectangle drawn on top of the right place for a cursor
14:40:41 <beelsebob> hmm, perhaps I'm just misinterpretting what Peaker is saying
14:40:52 <int80_h> Gracenotes: If I di Int->Int how do I sum the digits?
14:40:56 <Peaker> beelsebob: s/drawing/image
14:41:02 <Badger> > "Imposter!"
14:41:03 <pumpkinbot>   "Imposter!"
14:41:03 <PeakerLambda>   "Imposter!"
14:41:05 <beelsebob> Peaker: ah, cool
14:41:07 <Gracenotes> int80_h: you take a number, make into into a list of digits, and return the sum
14:41:10 <Peaker> PeakerLambda: @quit
14:41:13 <conal> Peaker: what cursor?
14:41:21 <Gracenotes> int80_h: that's Int -> Int
14:41:22 <rwbarton> @users
14:41:22 <pumpkinbot> Maximum users seen in #haskell: 658, currently: 653 (99.2%), active: 9 (1.4%)
14:41:23 <Badger> @seen pumpkinbot
14:41:23 <pumpkinbot> Yes, I'm here. I'm in #haskell
14:41:32 <conal> Peaker: oh -- that's the int?
14:41:32 <hackage> Uploaded to hackage: rss2irc 0.2
14:41:34 <Peaker> conal: The Int input is an index into the string of where the rectangle should be shown
14:41:47 <sinelaw> whew, just finished re-doing a stupid control exercise
14:41:48 <olivierp> hi, could you suggest a way to fix this: JoinMonad.hs:47:31:
14:41:49 <olivierp>     Couldn't match expected type `a1' against inferred type `B.VAR a'
14:41:49 <olivierp>       `a1' is a rigid type variable bound by
14:41:49 <olivierp>            the constructor `SingleChannel' at JoinMonad.hs:47:7
14:41:50 <olivierp>     In the pattern: B.VAR _ _
14:41:50 <olivierp> That's in this function declaration: spawn (SingleChannel name var@(B.VAR _ _)) = ...
14:41:52 <conal> Peaker: great.  do you also have font info?
14:42:01 <Peaker> conal: no, all font stuff is in IO (in SDL, at least)
14:42:10 <conal> Peaker: no.  i mean semantically.
14:42:17 <conal> Peaker: drop all implementation notions from your head.
14:42:31 <Philippa_> Peaker: pretend the library is in fact a language. Does your language know what a font is?
14:42:32 <conal> Peaker: hm.  that came out more harshly than i meant.
14:42:40 <Peaker> Philippa_: currently, no
14:42:42 <conal> Philippa_: thanks! :)
14:42:42 <yitz> preflex: seen lambdabot
14:42:42 <preflex>  lambdabot was last seen on #haskell 22 hours, 24 minutes and 2 seconds ago, saying: System.CPUTime getCPUTime :: IO Integer
14:42:58 <Badger> owch, that long?
14:43:02 <Peaker> conal: I could model Fonts functionally, I suppose
14:43:11 <m3ga> hmm, if I create a symlink to a directory, System.Posix.Files.isDirectory returns True and System.Posix.Files.isSymbolicLink false????
14:43:16 <conal> Peaker: :)
14:43:27 <beelsebob> actually, fonts are something pretty horrific to think about the semantics of
14:43:31 <conal> Peaker: because fonts are *things*
14:43:32 <beelsebob> there's a bucketload to go on there
14:44:01 <pumpkin> just highlight my name if pumpkinbot is acting up
14:44:26 <augustss> dcoutts: the cabal-install page on hackage doesn't say where the darcs repository is
14:44:33 <Peaker> conal: buildFont would be a yucky adapter from font name to a Font.   render :: Font -> String -> (Size, Image)
14:44:40 <yitz> @vixen will you behave yourself today?
14:44:40 <pumpkinbot> let's don't talk about that
14:45:01 <Badger> @vixen do you love pumpkin?
14:45:01 <pumpkinbot> i wouldn't say i do love...
14:45:18 <Peaker> conal: or maybe I can have buildFont be in IO and just feed the fonts to the functional part
14:45:21 <dcoutts> augustss: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
14:45:29 <conal> Peaker: that render type looks good to me.  to get your own thinking clear, you can a simplified model for fonts for now.  only enough to handle your current needs.
14:45:41 <dcoutts> augustss: you meant the package page for cabal-install I guess.
14:45:51 <rwbarton> olivierp: can you paste the definition of the type that SingleChannel belongs to?   http://moonpatio.org/
14:45:58 <augustss> dcoutts: yes
14:46:04 <dcoutts> augustss: I'm not sure if hackage supports showing the darcs repo declared in the .cabal file yet.
14:46:08 <Peaker> conal: Yeah, basically only need render and size, and those can be unified into the above render function
14:46:16 <conal> Peaker: semantically, is there anything imperative about font building?
14:46:24 <augustss> dcoutts: it supports showing a home page, many point that to the darcs repo
14:46:30 <conal> Peaker: e.g., in comparison to string append?
14:47:02 <olivierp> rwbarton: it's short enough to fit here: data Process =  forall a . J.CollectArgs a => SingleChannel { name :: String, arg :: a }
14:47:02 <olivierp>               | MultipleChannels Process Process
14:47:09 <Peaker> conal: Possibly, it requires a font designator/name that might only be meaningful if you can list existing fonts/etc
14:47:11 <dcoutts> augustss: ah, I should add the homepage that's true. I've not added the source repo there yet anyway because it's useful for that package in particular to be backwards compatible with older Cabal lib versions.
14:47:41 <int80_h> Gracenotes: Okay here's what I have so far
14:47:42 <olivierp> rwbarton: and J.CollectArgs is in Join.Join in here: http://hackage.haskell.org/packages/archive/join/0.2/doc/html/Join-Join.html
14:47:47 <conal> Peaker: i suspect you're mixing at least two different things: fonts & maps (dictionaries)
14:47:51 <int80_h> Gracenotes: sum2 :: Int -> Int
14:47:51 <int80_h> sum2 x = sum . (map digitToInt . (show . x))
14:47:55 <rwbarton> olivierp: ah, there's your problem, why do you expect that the second parameter to SingleChannel in the pattern match is of whatever type B.VAR is
14:48:04 <beelsebob> conal: what type would you expect buildFont to have?
14:48:07 <int80_h> Gracenotes: I figure this is a precedence problem I have now
14:48:20 <conal> beelsebob: i have no idea.  what's buildFont?
14:48:23 <olivierp> rwbarton: because it's an instance of the CollectArgs typeclass
14:48:29 <int80_h> Gracenotes: without parens I have even more type errors
14:48:48 <rwbarton> olivierp: but there could be lots of instances
14:48:49 <Peaker> conal: Ah, I could imperatively build the dictionary of available fonts, and functionally only select from that
14:48:51 <olivierp> rwbarton: and I know that this second parameter is an instance of CollectArgs
14:49:05 <olivierp> rwbarton: so it's one of the possible cases
14:49:09 <rwbarton> olivierp: you don't know which instance this particular SingleChannel goes with
14:49:16 <conal> Peaker: maybe.  although dictionaries are *things* also.
14:49:25 <Gracenotes> int80_h: this technique might help... try taking away the type signature, compiling it, and checking the type that GHC infers?
14:49:26 <olivierp> rwbarton: no, but I need to handle that case differently
14:49:32 <rwbarton> olivierp: if you want to "pattern match" on the type, you need to be using a class method of CollectArgs
14:49:45 <olivierp> rwbarton: aaah
14:49:47 <skorpan> could someone help me out with this error? it seems like it's a bug in Network.Curl, but i doubt it... http://pastebin.com/d6b37f98a
14:50:09 <int80_h> Gracenotes: I get this for a type
14:50:14 <int80_h> sum2 :: (Show b) => (a -> b) -> a -> Int
14:50:21 <Peaker> conal: Yeah, they're exposed in the functional side -- the fact they're built imperatively isn't exposed
14:50:32 <Gracenotes> int80_h: so, it expects x to be a function
14:50:43 <int80_h> Gracenotes: this tells me I have a type constrain (Show b). Don't know what that means. I didn't know Show is a type.
14:50:44 <conal> Peaker: and i doubt they need to be *built* imperatively either.
14:51:01 <conal> Peaker: for now, to get you started, i suggest taking a 'Map String Font' as a given.
14:51:18 <Peaker> conal: Well, to even have all the keys of the dict, you need an imperative listing, no?
14:51:21 <rwbarton> int80_h: Show isn't a type, it's a type class, that of types that can be shown.
14:51:26 <Gracenotes> int80_h: it isn't... it's a typeclass. However, an Int is a Show, so you can imagine the type being (a -> Int) -> a -> Int
14:51:34 * beelsebob always felt uncomfortable that fonts got intexed by nam
14:51:36 <beelsebob> name*
14:51:44 <conal> Peaker: what's an "imperative listing"?
14:51:48 <beelsebob> I always felt there should be a better way to identify the font you want
14:51:57 <Peaker> conal: ls /usr/share/fonts :-)
14:51:58 <conal> beelsebob: like algebraically.
14:52:09 <beelsebob> conal: hmm?
14:52:33 <SamB> hey, is this indentation legal? http://hackage.haskell.org/packages/archive/smallcheck/0.4/doc/html/src/Test-SmallCheck.html#progressReport
14:52:51 <olivierp> rwbarton: thanks a lot, this will be more complicated than expected but I did understand :)
14:52:51 <Gracenotes> int80_h: so clearly it expects the first parameter to be a function, (a -> Int)
14:52:56 <Gracenotes> but you want it to be an Int
14:53:24 <Gracenotes> the problem is where you have (show . x), because it expects x to be a function. It's the second parameter of (.), which is:
14:53:26 <Gracenotes> :t (.)
14:53:27 <pumpkinbot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:53:29 <Gracenotes> a function
14:53:39 <int80_h> Gracenotes: I've adjusted to "sum2 x = sum . map digitToInt . show  x"
14:53:47 <augustss> dcoutts: cabal unpack is indeed nice!
14:53:51 <int80_h> oops
14:54:02 <conal> Peaker: i don't want to derail you, so how about we leave it as you're given a 'Map String Font'?
14:54:09 <dcoutts> augustss: :-) let me know if you bump into unexpected things
14:54:13 <cebewee> =wc
14:54:21 <koeien> @where liftIO
14:54:21 <pumpkinbot> I know nothing about liftio.
14:54:24 <Gracenotes> int80_h: the problem is that (show x) is also a value, but (.) expects it to be a function
14:54:25 <Peaker> conal: that's good. I think that does indeed convert the Draw monad back to a nicer Image Monoid :)
14:54:43 <Gracenotes> int80_h: try doing "show $ x"
14:54:59 <conal> Peaker: great.  and s/Draw/Image/, okay?
14:55:04 <Peaker> conal: yeah
14:55:11 <conal> Peaker: and drop Monad?
14:55:21 <Peaker> conal: yeah, it'll be a Monoid
14:55:21 <dcoutts> augustss: the other new command is cabal info pkgname
14:55:34 <Peaker> conal: not a monad (kind = *, too)
14:55:34 <conal> Peaker: oh, sry.  i misread your comment.
14:55:37 <int80_h> Gracenotes: sum2 x = sum . map digitToInt show $ x
14:55:42 <int80_h> Gracenotes: type error
14:55:45 <conal> Peaker: much better!
14:56:16 <Gracenotes> int80_h: sorry... I shouldn't be so socratic. It must be kind of annoying and confusing. The function is something like sum2 x = sum . map digitToInt . show $ x
14:56:17 <Peaker> conal: so now we have (pretty much):   type Widget model = model -> (Image, Size, Map Event model)
14:56:17 <conal> Peaker: and not because of monad --> monoid.   because it's non-semantic --> semantic.
14:56:35 <Gracenotes> int80_h: it's just a matter of notation, but you definitely had the right order
14:56:36 <Peaker> conal: I'd say its complicated-semantic --> simple-semantic       rather than non- :-)
14:56:54 <int80_h> Gracenotes: If you were asking me leading questions I would regocnize that as socratic. I can play along with socratic. I just need to recognize it. ;)
14:56:55 <Gracenotes> (.) and ($) take a short while to get used to
14:57:02 <conal> Peaker: the reason i say non-semantic is that IO has no (denotational) semantic model that i know of.
14:57:35 <conal> Peaker: in that Widget def, can you replace 'Map Event model' with 'Event -> model' ?
14:57:38 <int80_h> Gracenotes: let's talk about what this definition is saying
14:57:45 <beelsebob> conal: maybe that's where the confusion creeps in – because IO certainly has meaning, it's just not very well defined, and very complex
14:57:53 <BMeph> yitz: payme.for.it? ;)
14:58:02 <Peaker> conal: no, because its really  Map Event (String, model)   where String allows describing to the user all available Event handlers
14:58:04 <Philippa_> conal: that does strike me as a little fundamentalist :-) Calling it "operational" would do
14:58:11 <int80_h> Gracenotes: since show x is a value, I'm confused that show $ x is a function
14:58:12 <yitz> BMeph: I guess that's where you sign up
14:58:26 <beelsebob> Philippa_: you know of an operational semantics for IO?
14:58:40 <Gracenotes> int80_h: it isn't... the expression is equal to sum2 x = (sum . map digitToInt . show) $ x
14:58:52 <Gracenotes> or, in other words, sum2 x = (sum . map digitToInt . show) x
14:58:53 <conal> Philippa_: i don't mean the fundamentalism.  i forget to say "denotational" sometimes.
14:59:10 <conal> Philippa_: and yeah -- i think you got my meaning.
14:59:41 <Gracenotes> or, sum2 = sum . map digitToInt . show
14:59:42 <Philippa_> beelsebob: fully specced, no. But it's not too hard to write the guts of one
14:59:45 <Peaker> conal: I lie a bit to simplify. More accurately, its Map EventGroup (String, Event -> model)  where EventGroup is a grouping of events, to better describe the available things the user can do to the user
14:59:54 <int80_h> Gracenotes: I think I might understand $. f g $ x = (f g) x
14:59:55 <Philippa_> beelsebob: whereas a denotational one is a much, much bigger problem
15:00:00 <int80_h> Gracenotes: is that right?
15:00:09 <Gracenotes> int80_h: more basically, f $ x = f x
15:00:22 <roconnor> @src ($)
15:00:22 <pumpkinbot> f $ x = f x
15:00:23 <Peaker> conal: for example, the user sees "Printable   insert character at cursor ; Backspace   delete character before cursor" and so on
15:00:33 <Gracenotes> such a function seems useless, but it's useful for dividing up functions and things to apply it to
15:00:35 <int80_h> Gracenotes: okay I'll practice with it more to make sure I understand it
15:01:12 <int80_h> Gracenotes: people say it makes things more readable, but I still have lisp in my head. Still trying to move to haskell idiom
15:01:25 <Gracenotes> int80_h: you have a function "sum . map digitToInt . show". You apply it to 123 via "sum . map digitToInt . show $ 123"
15:01:37 <conal> Peaker: it's important to get all this truth out there, so you/we can measure its complexity and steer the design.
15:02:15 <Gracenotes> (sum . map digitToInt . show) 123 -> (sum . map digitToInt) "123" -> (sum) [1,2,3] -> 6
15:03:12 <conal> Peaker: implementing a denotational prototype in haskell will flush out those details.
15:03:24 <rwbarton> int80_h: BTW, you can write Lispy syntax in Haskell too.  sum2 x = (sum (map digitToInt (show x)))   is perfectly valid :)
15:03:26 <Gracenotes> int80_h: it's just an idiom of sorts. Think of (f (g (h (x)))  <-> f . g . h $ x
15:03:47 <Peaker> conal: do you see a problem with the above Map though?
15:04:28 <conal> Peaker: yes & no.  a `Map` b is a more complex than a -> b.  and i look for every chance to simplify.
15:04:52 <conal> Peaker: how about your Event type.  is it a Reactive Event?
15:05:02 <conal> Peaker: i.e., collection of time/value pairs.
15:05:03 <int80_h> Gracenotes: it's idiomatic alright. Thanks for the tips :)
15:05:04 <Peaker> conal: Yes, the parts of a `Map` b that I need are (a -> b, [a])
15:05:18 <skorpan> The type signature for `getHostCode' lacks an accompanying binding <- what?
15:05:22 <Peaker> conal: its just a Keyboard input for now
15:05:25 <conal> Peaker: cool. that makes it clearer to me.
15:05:50 <conal> Peaker: Keyboard input with Reactive's Event semantics?  i.e., a collection of time/keystroke pairs?
15:05:51 <Gracenotes> int80_h: sure :) sorry for throwing out all kinds of not-terribly-useful hints. For me, sometimes I just need to see code first to understand how it works, and apply it to other things
15:06:12 <Gracenotes> you'll definitely be able to use . . . $ in other Euler problems
15:06:24 <Peaker> conal: oh, no nothing like that, sorry about using that confusing name.. EventGroup is really just KeyGroup and Event-> is really just Key->
15:06:32 <Gracenotes> :/ anyway, I'm off to get dinner. brb
15:06:48 <Peaker> conal: do you think its better to use (Key->(String,model), [Key]) than Map Key (Strnig, model) ?
15:06:52 <conal> Peaker: oh!  good.  what's a KeyGroup?
15:07:05 <Peaker> conal: Its a set of keys
15:07:17 <Peaker> conal: like all the alphanumeric characters on the keyboard
15:07:27 <ehird> ya mean like
15:07:29 <ehird> Set Key?
15:07:29 <ehird> :P
15:07:47 <Gracenotes> int80_h: by the way, if you did want to write the function that does the power of two thing, it's sum2 = sum . map digitToInt . show . (2^)
15:07:58 <conal> Peaker: super.  it's sounding pretty precise & simple.  And Map is fine.  it's a finite partial function that can tell you its domain.
15:08:12 <Peaker> conal: yeah, I knew you'd approve of the non-draw part :-)
15:08:26 <conal> Peaker: while the (a->b,[a]) model doesn't say that the [a] part is the domain of the a-> part.
15:09:00 <Peaker> conal: btw, its pretty cool that I show the user all the available keys and what they do at all times :-)  Very nice to start people off without a README
15:09:30 <conal> Peaker: nice :)
15:09:38 <Peaker> conal: How come fieldtrip doesn't functionally model fonts?
15:10:09 <conal> Peaker: fieldtrip is in its infancy.  i worked on it last spring and not much since.
15:10:36 <conal> Peaker: it didn't even have a semantic model.
15:10:48 <Peaker> conal: ah. When I first mentioned that I "have to make my Draw a Monad instead of a Monoid" nobody yelled -- stop, in fact, quicksilver said its commonly used as a solution :)
15:11:24 <conal> Peaker: yeah.  sequential thinking is very popular.  a deep rut.
15:11:51 <conal> Peaker: "it's obvious"
15:12:14 <sbahra> mmorrow, ping?
15:12:20 <Peaker> conal: I think one of the main differences about my widget set, btw, compared with Phooey, perhaps, is that widgets represent layout, and I compose them together, and the model is composed separately. To associate widgets with parts of the model, I compose functional references/accessors together
15:12:40 <Peaker> conal: so layout is separately composed from the model
15:13:08 <Philippa_> conal: tbh, sequential crept in with the monoid rather than the monad
15:13:11 <conal> Peaker: the connection/disconnection between model & vis has a long istory.
15:13:21 <Peaker> conal: when creating multiple widgets in your layout, you can associate them to edit the same parts of the model by using the same functional references
15:13:27 <augustss> dcoutts: why does 'cabal install HaXml' install version 1.13.1 when 1.19.4 is the latest?
15:14:02 <dcoutts> augustss: the 'preferred' version is < 1.14. You can use cabal install 'haxml >= 1.14'
15:14:06 <Peaker> conal: I think this approach here will allow something like a TV where they're associated and compose together, but starting when they're composed together will make it harder (impossible?) to separate
15:14:08 <conal> Peaker: also related to functional references & model/viz composition is TV/Eros.
15:14:14 <conal> Peaker: :)
15:14:27 <augustss> dcoutts: how can I tell what the preferred version is?
15:14:31 <conal> Peaker: oh yeah.  now i remember we talked at length about eros.
15:14:42 <tehgeekmeister> can parsec handle unicode?
15:15:08 <conal> Peaker: separability is key
15:15:10 <Peaker> conal: I basically wrote this widget set to implement something like Eros, except I want to offer an ASG editor, rather than semantic value editor
15:15:22 <conal> ASG?
15:15:29 <conal> oh abstract syntax graph?
15:15:32 * wli thought parsec was polymorphic in the alphabet (so ASCII, EBCDIC, Unicode, et al are all possible).
15:15:32 <Peaker> conal: yeah
15:15:34 <dcoutts> augustss: it's not so easy. Perhaps cabal info should say. It's in the preferred-versions file in the hackage index (00-index.tar).
15:15:42 <Philippa_> tehgeekmeister: Parsec doesn't care what the token type is
15:15:50 <conal> Peaker: back to our first chats
15:15:51 <dcoutts> augustss: http://hackage.haskell.org/packages/archive/preferred-versions
15:15:52 <Peaker> conal: the only reason its a "tree" anywhere, is because text serializes trees better than graphs, and then names and namespaces are used to build the graph links
15:15:59 <augustss> dcoutts: It's annoying that the documentation you can find on the hackage page is not for the preferred version.  It confused me.
15:16:12 <Peaker> conal: so if you never lose the notion that code is a graph, you actually have an ASG
15:16:29 <dcoutts> augustss: yes the unversioned package package should point to the preferred version rather than the latest.
15:16:49 <conal> Peaker: i'm glad you're making progress with your idea.
15:16:53 <Peaker> conal: and you don't need any "names" to form links, but they are still useful as comments. Their being only comments allows them to be better comments, and makes renames a snap :)
15:17:10 <Peaker> conal: thanks.  You're helping too! Gonna refactor now :)
15:17:48 <conal> Peaker: great.  :)
15:18:02 <Peaker> conal: I just had a possibly-inaccurate thought through my head, that an ASG editor is really a superset, functionality-wise, of a semantic value editor.. You can perform editing operations on the whole value, or you can "dig in" and manipulate its internals
15:18:21 <Peaker> conal: If you "hide" the "digging in" part in the UI, you have a semantic value editor
15:18:27 <vixey> @src Cont >>=
15:18:27 <pumpkinbot> Source not found. You type like i drive.
15:18:32 <vixey> @src >>= Cont
15:18:32 <pumpkinbot> Source not found. My mind is going. I can feel it.
15:18:36 <vixey> @src Cont (>>=)
15:18:36 <pumpkinbot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
15:18:56 <conal> Peaker: i think so.  in fact, the first Eros implementation (as described in my paper) did both.
15:19:35 <Peaker> conal: the one in the google tech talk had only editing of the whole semantic value.. did you drop support for editing internals because of UI clutter?
15:21:38 <Peaker> conal: is that the part where you mentioned that it is essential that you "don't show the intermediate values, like unix pipes"?
15:21:51 <conal> Peaker: no -- because it was simpler to manipulate just the semantics (values) directly, and because hs-plugins broke on windows.
15:22:41 <Peaker> conal: oh, I see.  I think it would still be a great feature to show how a value was formed (even though its not the only possible way to form that exact semantic value) as an ASG, and allow you to edit that :)
15:22:49 <Peaker> but I remember that's where we disagreed last time
15:22:58 <pumpkin> how is value formed?
15:23:05 <pumpkin> you need to do way instain function
15:23:05 <thom__> hmmmm sum [1..100000] --> 5000050000 but sum [1..1000000] --> *** Exception: stack overflow
15:23:17 <pumpkin> thom__: use foldl' (+) 0
15:23:19 <skorpan> is there any utility or tool which can take a "do"-expression and show me the unsugared expression?
15:23:21 <pumpkin> instead of sum
15:23:25 <conal> Peaker: i agree.  and very helpful for run-time code generation.  maybe via llvm next time.
15:23:42 <thom__> why is this using tons of stack? shouldn't it simply iterate/tail call?
15:23:49 <cads> thom, sum isn't tail recursive, but foldl' (+) 0 should be
15:23:50 <pumpkin> @src sum
15:23:50 <pumpkinbot> sum = foldl (+) 0
15:23:58 <pumpkin> it's using the non-strict foldl
15:24:08 <Peaker> conal: I am almost getting to the editor part now, and I am wondering whether I want to generate strings into ghci, use hs-plugins, some pure Haskell type-checker, or what
15:24:23 <cads> @src foldl'
15:24:23 <thom__> ah, okay. thakns. interesting
15:24:23 <pumpkinbot> foldl' f a []     = a
15:24:23 <pumpkinbot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:24:29 <vixey> Peaker, pure
15:24:35 <cads> @src foldl
15:24:36 <pumpkinbot> foldl f z []     = z
15:24:36 <pumpkinbot> foldl f z (x:xs) = foldl f (f z x) xs
15:25:29 <rwbarton> thom__: in some sense, foldl is tail recursive, it's just that it generates the result (...((1+2)+3)...)+100000, and evaluating that leads to stack overflow
15:25:40 <Peaker> vixey: Do you know if existing pure Haskell libraries to deal with Haskell code and types are mature/usable?
15:25:43 <jberryman> skorpan: the first monad chapter in Real World Haskell has a good explanation of the algorithm for desugaring 'do' notation.
15:25:53 <rwbarton> skorpan: lambdabot can
15:25:58 <cads> wait foldl is tail recursive.
15:26:05 <skorpan> rwbarton: how?
15:26:13 <ddarius> rwbarton: In the sense that tail recursion is a syntactic property and it holds of foldl.
15:26:13 <skorpan> jberryman: i know, but i would like a tool for it
15:26:21 <rwbarton> @undo do { x <- y; guard $ p x; return x }
15:26:21 <pumpkinbot> y >>= \ x -> guard $ p x >> return x
15:26:53 <skorpan> @undo do { code <- getHostCode "www.google.com"; putStrLn $ "Google's response: " ++ show code; return $ code == CurlOK }
15:26:53 <pumpkinbot> getHostCode "www.google.com" >>= \ code -> putStrLn $ "Google's response: " ++ show code >> return $ code == CurlOK
15:26:59 <jberryman> is there nothing lambdabot can't undo?
15:27:08 <thom__> foldl (+) 0 [1..1000000] is overflowing the stack too :/
15:27:09 <rwbarton> It's a property of (+) that causes foldl (+) 0 to lead to stack overflow.
15:27:21 <pumpkin> thom__: you missed the apostrophe ;)
15:27:29 <pumpkin> foldl'
15:27:32 <wli> thom__: foldl' not foldl
15:27:41 <pumpkin> though I don't blame you
15:27:42 <vixey> Peaker, I think not
15:27:55 <Peaker> vixey: then why do you suggest pure Haskell code?
15:27:55 <thom__> <interactive>:1:0: Not in scope: `foldl''
15:28:15 <Peaker> vixey: I think you're a type/language guru, but I'm not - I'd rather use some existing type checker :)
15:28:21 <cads> > foldl' (+) 0 [1..(10^20)]
15:28:27 <pumpkinbot>   mueval: Prelude.read: no parse
15:28:42 <vixey> Peaker, shorter feedback loop wrt. interactive programming
15:28:52 <pumpkin> cads: that's a little excessive :P
15:28:53 <thom__> cads: same error here
15:28:56 <Peaker> vixey: the idea is that it interactively updates all the time in any case
15:29:03 <ddarius> @indox foldl'
15:29:03 <pumpkinbot> Data.List
15:29:15 <Peaker> vixey: I want the editor to only let you do editing operations that maintain type-correctness
15:29:20 <pumpkin> thom__: if you're really summing up an arithmetic series like that, why not do it in constant time?
15:29:29 <Peaker> vixey: I think having all the types of everything can greatly improve the editing primitives you have
15:29:38 <cads> > (10^20)*(10^20 +1)/2
15:29:40 <pumpkinbot>   5.0e39
15:29:48 <thom__> just learning. thought that would be the way to do it
15:29:58 <pumpkin> > (10^20)*(10^20 +1) `div` 2 :: Integer
15:29:59 <pumpkinbot>   5000000000000000000050000000000000000000
15:30:13 <rwbarton> thom__: if you compile with optimizations, ghc will work out that it should convert foldl to foldl' for you.
15:30:23 <cads> > foldl' (+) 0 [1..10000000000000]
15:30:29 <pumpkinbot>   mueval: Prelude.read: no parse
15:30:31 <vixey> Peaker, In that case
15:30:32 <pumpkin> my poor xen
15:30:34 <Olathe> > foldl'
15:30:35 <pumpkinbot>       Overlapping instances for Show ((a -> b -> a) -> a -> [b] -> a)
15:30:35 <pumpkinbot>        ...
15:30:37 <vixey> Peaker, 1) Look at Epigram 1
15:30:38 <thom__> I'm just in ghci
15:30:40 <Olathe> > foldl' (+) 0
15:30:41 <pumpkinbot>       Overlapping instances for Show ([a] -> a)
15:30:41 <pumpkinbot>        arising from a use of ...
15:30:46 <cads> pumpkin, what am I doing wrong?
15:30:50 <Peaker> vixey: you don't have a link? :(
15:30:51 <Olathe> > [1..10000000000000]
15:30:53 <pumpkinbot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:31:02 <vixey> Peaker, 2) I think that will be possible only if you have got a typechecker built into the editor
15:31:03 <Olathe> > foldl' (+) 0 [1..10000000000000]
15:31:06 <pumpkin> cads: giving it huge numbers that lead to mueval being killed before the answer comes back
15:31:07 <FliPPeh> > [1 .. ]
15:31:09 <pumpkinbot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:31:09 <pumpkinbot>   mueval: Prelude.read: no parse
15:31:27 <vixey> http://www.e-pig.org/epigram1.html#down
15:31:28 <Peaker> vixey: 2) I agree, the question if its built-in via communicating with ghci, hs-plugins, using existing type-checker libs, or its own lib
15:31:28 <Olathe> Why doesn't it finish parsing before getting results ?
15:31:39 <pumpkin> > foldl' (+) 0 [1..10000000000]
15:31:45 <pumpkinbot>   mueval: Prelude.read: no parse
15:31:47 <pumpkin> > foldl' (+) 0 [1..100000000]
15:31:47 <thom__> what is <interactive>:1:0: Not in scope: `foldl'' trying to tell me?
15:31:53 <pumpkinbot>   mueval: Prelude.read: no parse
15:31:55 <ddarius> Olathe: That's just how the error is displayed.
15:31:57 <pumpkin> thom__: that you didn't :m + Data.List
15:32:01 <thom__> ah
15:32:04 <pumpkin> > foldl' (+) 0 [1..1000000]
15:32:06 <pumpkinbot>   500000500000
15:32:09 <pumpkin> > foldl' (+) 0 [1..10000000]
15:32:11 <pumpkinbot>   50000005000000
15:32:29 <vixey> Peaker, Actually the System FPH stuff is a good implementation, but you'd be out of sink with the normal GHC type stuff
15:32:29 <thom__> ah, much beter
15:33:07 <Peaker> vixey: out of sync?
15:33:08 <glguy> pumpkinbot, take that to /msg please
15:33:08 <mmorrow> , [ty| let fix f = let x = f x in x in fix |]
15:33:09 <lunabot>  luna: parse error on input `|]'
15:33:18 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
15:33:19 <Philippa_> vixey: System FPH?
15:33:21 <lunabot>  forall a . (a -> a) -> a
15:33:21 <Badger> yeah, pumpkinbot
15:33:22 <Peaker> vixey: I think not supporting ghc extensions as a first stage is fine
15:33:24 <Badger> >:(
15:33:28 <Peaker> vixey: I'd be very happy with that at first
15:33:40 <mmorrow> , [$tyQ| fix |]
15:33:42 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT a)) (VarT a)))...
15:33:47 <pumpkin> glguy: sorry :)
15:33:55 <vixey> Philippa_, http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/ *wants this in GHC*
15:34:06 <mmorrow> sbahra: hi
15:34:07 <Philippa_> ah, right
15:34:08 <vixey> (not the boxy types one)
15:35:02 <cads> let mersenne46 = (2^43122609 - 1) in mersenne46
15:35:08 <mmorrow> andyjgill: ping
15:35:09 <cads> darn :P
15:35:11 <tehgeekmeister> does haskell have inline comments?
15:35:18 <pumpkin> {- -}
15:36:07 <cads> pumpkin, haskell is extremely impressive in that it _will_ evaluate 2^43122609 without overflowing
15:36:20 <pumpkin> yup :)
15:36:23 <vixey> > 2^43122609
15:36:29 <pumpkinbot>   mueval: Prelude.read: no parse
15:36:30 <pumpkin> but my lambdabot might not be
15:36:30 <cads> but the program that does takes about 100mb of memory
15:37:50 <blackdog> i have this pattern: (\x -
15:37:50 <thom__> is "do" defined in the standard predlude or is that a internal compiler thing?
15:38:03 <Peaker> vixey: the epigram xemacs stuff doesn't work on a modern emacs (22-23)
15:38:03 <dobblego> thom__,  it is a keyword
15:38:07 <blackdog> urgh. (\x -> return $ foo a x)
15:38:10 <blackdog> can it be simplified?
15:38:12 <vixey> ok
15:38:15 <koeien> thom__: this is a keyword. compare it to primitives like '='
15:38:23 <sbahra> mmorrow, hi
15:38:24 <Riastradh> Any language with bignums will do that, cads.
15:38:26 <pumpkin> blackdog: return . foo a
15:38:26 <dobblego> blackdog, return $ foo a
15:38:30 <sbahra> mmorrow, could you have lunabot join #haskell-FreeBSD?
15:38:38 <pumpkin> @pl  (\x -> return $ foo a x)
15:38:38 <pumpkinbot> return . foo a
15:38:42 <sbahra> mmorrow, since lambdabot is dead
15:39:09 <blackdog> pumpkin: cheers. odd that . works where $ doesn't, though
15:39:32 <dobblego> blackdog, mine is an error
15:39:54 <cads> Riastradh: You need very high performance bignums to do that, fast fourier transform multiplication and whatnot
15:40:02 <blackdog> ah, fair enough. (am just trying to do that final pass where you get rid of the more obvious infelicities :)
15:40:13 <Peaker> conal: hey, are you still here?
15:40:30 <cads> Riastradh:  trying to evaluate the 46th mersenne number in ruby, for example, yields Infinity
15:40:44 <pumpkin> it does?
15:40:55 <pumpkin> ruby has nice bignums too
15:41:03 <cads> yep
15:41:23 <cads> but the implementation of bignums in ruby is based on using strings to represent the numbers
15:41:27 <lpjhjdh> so I'm trying to parse a CSV file and having a bit of trouble
15:41:29 <lpjhjdh> http://www.unsafecoerce.com:8080/fastcgi/hpaste.fcgi/view?id=1118#a1118
15:41:42 <Peaker> conal: Having implementation troubles, all font rendering in SDL is in IO.. hard to hide that when I expose a real concrete size result, and not just an Image
15:41:47 <rwbarton> I don't think you need any fancy multiplication algorithms to compute 2^43122609.
15:41:56 <rwbarton> After all it's just 1 followed by 43122609 zeros :)
15:42:06 <Peaker> conal: I could unsafePerformIO that, but I'm not sure that's a good idea :-(
15:42:25 <cads> rwbarton, heh, I hadn't thought of it that way
15:42:29 <Riastradh> At most, for a naive bignum representation, you need the space for the number.
15:42:31 <vixey> Please answer this simple math question
15:42:31 <vixey> 4 + 72 =
15:42:36 <vixey> hehehe
15:42:37 <ziman> the decadic representation is more of a challenge :)
15:42:46 <Riastradh> An unclever bignum library will take time, too.
15:43:02 <lpjhjdh> the csv file has flowers, and 4 attributes per flower.  I'm creating lists of flowers, but I'd like a lists of attributes.
15:43:04 <pumpkin> vixey: what base?
15:43:07 <Peaker> conal: I mean, String -> Font -> Image   is fine, because Image, afaic cannot be used for anything but later rendering. But Size can be immediately used, so I have to swallow IO in pure code
15:43:09 <pumpkin> :P
15:43:11 <cads> but i've looked at ruby's bignum and it uses the plain pen and paper algorithms for multiplication and addition
15:43:17 <Riastradh> (and will spend a lot of time in garbage collection)
15:43:22 <rwbarton> lpjhjdh: you can use transpose
15:43:34 <ehird> :t foldl
15:43:35 <pumpkinbot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:43:37 <lpjhjdh> thanks
15:43:37 <vixey> String -> Font -> Text
15:43:42 <Badger> > 4 + 72
15:43:43 <pumpkinbot>   76
15:43:49 <Badger> pumpkinbot knows his stuff.
15:43:51 <Riastradh> cads, pen and paper algorithms work...
15:43:51 <vixey> String -> Font -> NSAttributedString
15:44:05 <ehird> :t unfoldr
15:44:06 <pumpkinbot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:44:18 <cads> in quadratic time for multiplication, no?
15:44:45 <cads> hey do you need bignums to convert a long binary number into decimal?
15:45:02 <Riastradh> Who said anything about decimal formatting?
15:45:08 <mmorrow> sbahra: i guess i could, sure. hmm, gimme a sec
15:45:16 <vixey> cads, no
15:45:39 <vixey> cads, I think you can do it lazyly if you start at the right end
15:46:53 <cads> hehe, I had an algorithm for it, too
15:47:15 <cads> but I don't remember it involved accumulating large powers of two in decimal form
15:47:42 <pumpkin> I imagine it would be a lot easier if the to and from bases were nicer
15:47:46 <pumpkin> *better friends
15:48:47 <Peaker> Num sucks :P
15:48:48 * QtPlatypus alters the universe so humans evolve to have 8 fingers.
15:48:56 <Peaker> why does it subclass Eq?
15:48:57 <cads> well I am pretty sure that the haskell bignums (which are implemented with the GMP library) are stored as sequences of decimal digits
15:49:02 * ddarius already has eight fingers.
15:49:16 <vixey> decimal? I thought they used some larger base
15:49:21 <Peaker> ddarius: my name is Inigo Montoya
15:49:53 <pumpkin> base-256? :P
15:49:54 <cads> vixey: I feel like printing them is too fast for them to be in another base
15:50:08 <ehird> @src foldl
15:50:08 <pumpkinbot> foldl f z []     = z
15:50:08 <pumpkinbot> foldl f z (x:xs) = foldl f (f z x) xs
15:50:36 <QtPlatypus> vixey: But printing them is a pritty trival action.
15:51:26 <QtPlatypus> You only have to examine about pi bits of a bitstream to work out the decimal value.
15:51:37 <QtPlatypus> And that last comment was directed at cads.
15:51:41 <pumpkin> pi :o
15:51:56 <pumpkin> > logBase 2 10
15:51:57 <cads> QtPlatypus: I am trying to find that algorithm
15:51:57 <pumpkinbot>   3.3219280948873626
15:52:01 <mmorrow> sbahra: ok, done
15:52:17 <Peaker> vixey: why did you suggest epigram?  the emacs bindings or the language itself?
15:52:30 <vixey> the interface
15:52:46 <dons> beelsebob: the hscolour looks good. where's your patches?
15:52:47 <QtPlatypus> pumpkin: I use Pi as an approximation to that number.
15:53:08 <pumpkin> > logBase 2 10 - pi :: CReal
15:53:10 <pumpkinbot>   0.1803354412975691094076760462098872916677
15:53:13 <Peaker> vixey: it seems to only have an emacs interface?
15:53:40 <Peaker> vixey: and that doesn't work, its ancient (xemacs)
15:54:05 <QtPlatypus> > (logBase 2 10 / pi) * 100 :: CReal
15:54:07 <pumpkinbot>   105.7402553794332887150818771331976202481647
15:54:36 <ehird> should I build a list backwards then reverse at the end, or use (current++[new]) at every step
15:54:36 <ehird> ?
15:55:11 <pumpkin> > logBase 2 10 - pi - ((sqrt $ -1)**(sqrt $ -1)) :: Complex CReal
15:55:15 <pumpkinbot>   (-0.0275441350531927991392795736250914783662) :+ 0.0
15:55:30 <vixey> :t ($ []) . ('x':)
15:55:31 <pumpkinbot>     Couldn't match expected type `[a] -> b'
15:55:31 <pumpkinbot>            against inferred type `[Char]'
15:55:31 <pumpkinbot>     Probable cause: `:' is applied to too many arguments
15:55:51 <Peaker> conal: I could use an opaque type for Size that would have been a Num instance (if not for that Eq superclass..) -- that is only usable as an input for moving/scaling and other Image manipulations
15:56:01 <vixey> :t (('x':) . ('y':) . ('z':)) []
15:56:02 <pumpkinbot> [Char]
15:56:20 <rwbarton> ehird: the latter is quadratic time; use the former or difference lists
15:56:25 <vixey> :t ((++['x']) . (++['y']) . (++['z'])) []
15:56:26 <pumpkinbot> [Char]
15:56:27 <ehird> the former then
15:56:28 <ehird> :)
15:56:30 <ehird> :t unfoldl
15:56:32 <pumpkinbot> Not in scope: `unfoldl'
15:56:32 <cads> what the heck are CReals?
15:56:35 <ehird> I implemented unfoldl
15:56:48 <ehird> @src unfoldr
15:56:48 <pumpkinbot> unfoldr f b  = case f b of
15:56:48 <pumpkinbot>    Just (a,new_b) -> a : unfoldr f new_b
15:56:48 <pumpkinbot>    Nothing        -> []
15:56:50 <sbahra> mmorrow, thanks
15:56:51 <cads> > pi :: CReal
15:56:52 <pumpkinbot>   3.1415926535897932384626433832795028841972
15:56:57 <ehird> my unfoldl has the advantage of being tail recursive :P
15:57:04 <cads> > 1/3.0 :: CReal
15:57:06 <pumpkinbot>   0.3333333333333333333333333333333333333333
15:57:11 <tehgeekmeister> i defined a custom show instance for a type of mine, and after doing so my code has a stack overflow, but when using derived Show it doesn't, why is this?
15:57:44 <luqui> tehgeekmeister, you probably implemented show wrong?
15:57:52 <cads> > 1/334523464645453423523452466666.0 :: CReal
15:57:53 <pumpkinbot>   0.0000000000000000000000000000029893269253
15:58:09 <cads> > 1000000000000000000000/334523464645453423523452466666.0 :: CReal
15:58:10 <pumpkinbot>   0.0000000029893269252722096111387168554855
15:58:16 <luqui> tehgeekmeister, oh, one possibility is that you didn't implement show at all.  Did you just say "instance Show Foo" without eg. "show foo = ..." ?
15:58:22 <cads> > 100000000000000000000000000000000000000000/334523464645453423523452466666.0 :: CReal
15:58:23 <pumpkinbot>   298932692527.220961113871685548547561180446652459561
15:58:39 <cads> that's purty.
15:59:00 <vixey> > 9 :: CReal
15:59:02 <pumpkinbot>  Terminated
15:59:11 <vixey> 9 is irrational
15:59:18 <pumpkin> interesting
15:59:22 <pumpkin> 5 :: CReal
15:59:25 <pumpkin> > 5 :: CReal
15:59:26 <pumpkinbot>   5.0
15:59:28 <rwbarton> @let chunks n = map (take n) . takeWhile (not . null) . iterate (drop n)
15:59:29 <pumpkinbot>  Defined.
15:59:31 <pumpkin> > 9 :: CReal
15:59:32 <pumpkinbot>   9.0
15:59:42 <luqui> vixey, rather, the function from CReal -> String is discontinuous
15:59:46 <luqui> and that is a point of discontinuity
15:59:56 <tehgeekmeister> luqui: forgot to indent it.  =P
16:00:11 <luqui> (all continuous functions CReal -> String are constant)
16:00:28 <ehird> :t join
16:00:29 <pumpkin> > 9 == 9 :: CReal
16:00:30 <pumpkinbot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:00:30 <pumpkinbot>   Couldn't match expected type `CReal' against inferred type `Bool'
16:00:35 <pumpkin> > 9 == (9 :: CReal)
16:00:36 <pumpkinbot>   True
16:00:38 <ehird> > join 1 :: (Integer,Integer)
16:00:39 <pumpkinbot>       No instance for (Monad ((,) Integer))
16:00:39 <pumpkinbot>        arising from a use of `joi...
16:00:41 <ehird> err, oops
16:00:46 <ehird> @hoogle a -> (a,a)
16:00:46 <pumpkinbot> System.Random split :: RandomGen g => g -> (g, g)
16:00:46 <pumpkinbot> Prelude divMod :: Integral a => a -> a -> (a, a)
16:00:46 <pumpkinbot> Prelude quotRem :: Integral a => a -> a -> (a, a)
16:00:53 <rwbarton> > map read . chunks 3 . drop 2 $ show (1000000 / 998999 :: CReal) :: [Int]
16:00:54 <pumpkinbot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,6]
16:00:57 <pumpkin> > join (,) 1
16:00:58 <pumpkinbot>   (1,1)
16:01:00 <luqui> > 9 == (9.00000000000000000000001 :: CReal)
16:01:01 <pumpkinbot>   False
16:01:03 <ehird> aha
16:01:15 <luqui> > 9 == (9 + 10^(-100) :: CReal)
16:01:16 <ehird> @hoogle join
16:01:16 <pumpkinbot> Control.Monad join :: Monad m => m (m a) -> m a
16:01:16 <pumpkinbot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
16:01:16 <pumpkinbot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
16:01:17 <pumpkinbot>   mueval: Prelude.read: no parse
16:01:17 <pumpkinbot>  mueval: *** Exception: Prelude.^: negative ...
16:01:25 <luqui> > 9 == (9 + 10^^(-100) :: CReal)
16:01:26 <pumpkinbot>   True
16:01:36 <luqui> == is not *real* equality, it is an approximation
16:01:48 <pumpkin> when does it give up?
16:02:00 <luqui> > 9 == (9 + 10^^(-50) :: CReal)
16:02:01 <pumpkinbot>   True
16:02:04 <luqui> > 9 == (9 + 10^^(-25) :: CReal)
16:02:05 <pumpkinbot>   False
16:02:11 <pumpkin> oh
16:02:19 <pumpkin> is it just comparing showCReal 30 ?
16:02:36 <luqui> no, it doesn't show, as we can see, because 9 == 9 isn't _|_
16:03:57 <Olathe> > head $ filter (\n -> 9 /= (9 + 10^^(-n) :: CReal)) [1..]
16:03:58 <pumpkinbot>   1
16:04:03 <Olathe> > head $ filter (\n -> 9 == (9 + 10^^(-n) :: CReal)) [1..]
16:04:04 <pumpkinbot>   42
16:04:07 <pumpkin> omg
16:04:09 <pumpkin> profound
16:04:27 <pumpkin> we haz founded ze answer!
16:05:02 <Olathe> Now we know the question.
16:05:31 <pumpkin> omg we ha both
16:06:33 <ehird> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1119
16:06:38 <ehird> unfoldr & desum
16:06:41 <ehird> err
16:06:41 <dons> hey guys, anyone know steven woodhouse? he created a reddit clone with wash, but the site is gone, http://209.85.173.132/search?q=cache:yhN6zPdBrXcJ:www.swoodhouse.com/reddit.html+steven+woodhouse+haskell&hl=en&ct=clnk&cd=1&gl=us
16:06:43 <ehird> _unfoldl_
16:06:47 <dons> prize from me to anyone who can find the code.
16:07:00 <ehird> has unfoldl been implemented before?
16:07:01 <ehird> I haven't seen it
16:07:14 <pumpkin> ehird: I saw it somewhere
16:07:17 <pumpkin> but can't remember where
16:07:26 <ehird> Oh well, I like mine.
16:07:35 <mmorrow> @hooge buildInfo
16:07:36 <pumpkinbot> Distribution.PackageDescription buildInfo :: Executable -> BuildInfo
16:07:36 <pumpkinbot> Distribution.PackageDescription data BuildInfo
16:07:36 <pumpkinbot> Distribution.PackageDescription BuildInfo :: Bool -> [Dependency] -> [String] -> [String] -> [String] -> [Dependency] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [Extension] -> [String] ->
16:07:36 <pumpkinbot>  [String] -> [FilePath] -> [FilePath] -> [FilePath] -> [(CompilerFlavor, [String])] -> [String] -> [String] -> [(String, String)] -> BuildInfo
16:07:40 <ehird> I like desum too, even though it leans rightwards a bit column-wise.
16:07:46 <mmorrow> @hooge writeHookedBuildInfo
16:07:46 <pumpkinbot> Distribution.PackageDescription writeHookedBuildInfo :: FilePath -> HookedBuildInfo -> IO ()
16:08:07 <mmorrow> grr, apparently not anymore
16:08:15 <ehird> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1119#a1120
16:08:20 <ehird> fixed by adding a carefully-placed newline.
16:10:15 <rwbarton> @src unfoldr
16:10:16 <pumpkinbot> unfoldr f b  = case f b of
16:10:16 <pumpkinbot>    Just (a,new_b) -> a : unfoldr f new_b
16:10:16 <pumpkinbot>    Nothing        -> []
16:10:29 <ehird> Yeah. That's not tail recursive though.
16:10:34 <ehird> and it's unfold_r_
16:10:47 <pumpkin> dons: he's on facebook, you could send him a message :)
16:11:08 <mmorrow> grr, apparently not anymore
16:11:09 <Gracenotes> I don't think you could have an unfoldl :P
16:11:10 <mmorrow> oops
16:11:18 <ehird> Gracenotes: Er, I just linked to one
16:11:21 <ehird> didn't I?
16:11:22 <Gracenotes> :X
16:11:30 <ehird> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1119#a1120
16:11:31 <mmorrow> @hoogle PAckageName
16:11:31 <pumpkinbot> Distribution.Package packageName :: Package pkg => pkg -> String
16:11:31 <pumpkinbot> Distribution.Simple.PackageIndex deletePackageName :: Package pkg => String -> PackageIndex pkg -> PackageIndex pkg
16:11:31 <pumpkinbot> Distribution.Simple.PackageIndex lookupPackageName :: Package pkg => PackageIndex pkg -> String -> [pkg]
16:11:37 <Gracenotes> I don't think it would be terribly useful
16:11:42 * Gracenotes thinks
16:11:44 <ehird> it's... as useful as unfoldr.
16:11:54 <ehird> Since, as far as I can tell, they're identical modulo implementation details.
16:11:58 <ehird> (Specifically: mine's tail-recursive.)
16:11:59 <rwbarton> ehird: maybe I'm being dense, but what use of unfoldl couldn't I replace by unfoldr?
16:12:05 <ehird> rwbarton: None.
16:12:10 <ehird> Well.
16:12:22 <ehird> rwbarton: none, apart from ones that cause unfoldr to blow the stack.
16:12:24 <rwbarton> unfoldl is stricter in the spine of the input
16:12:27 <Gracenotes> ehird: eek... the fries must be going to my head
16:12:32 <rwbarton> ehird: what ones are those?
16:12:45 <ehird> rwbarton: I dunno. Invent some. :-)
16:13:05 <Gracenotes> ehird: okay then... never mind :)
16:13:43 <rwbarton> Are there any though?
16:13:45 <dons> pumpkin: good idea. he's been pinged.
16:13:49 <ehird> rwbarton: Dunno.
16:13:51 <Gracenotes> I've simply used unfoldr as a way to create a list by repeatedly applying a function; I haven't thought of it in terms of a left fold vs. right fold
16:14:00 <ddarius> > unfoldr (\x -> Just (x+1,x)) 0
16:14:01 <pumpkinbot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:14:05 <ehird> @hoogle unfoldr
16:14:05 <pumpkinbot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
16:14:05 <pumpkinbot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
16:14:05 <pumpkinbot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
16:14:11 <ddarius> > unfoldr (\x -> Just (x+1,x+1)) 0
16:14:12 <pumpkinbot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:14:30 <Gracenotes> not to mention, unfoldr can yield infinite lists
16:14:34 <ehird> um
16:14:35 <ehird> so can mine
16:14:41 <ehird> er, wait
16:14:42 <ehird> no it can't :)
16:14:46 <pumpkin> aw
16:14:49 <pumpkin> there, there
16:14:51 <Gracenotes> it's like it's switched around.
16:15:01 <ehird> Gracenotes: well yeah... keyword is "un" :-)
16:15:44 <pumpkin> ununfoldr
16:15:53 <rwbarton> @src reverse
16:15:54 <pumpkinbot> reverse = foldl (flip (:)) []
16:16:26 <ehird> I wonder if you can implement fold with unfold.
16:16:33 <Gracenotes> your unfoldl uses a foldl :X
16:16:34 <pumpkin> yeah
16:16:43 <ehird> Gracenotes: huh?
16:16:44 <ehird> does it?
16:16:51 <ehird> ... you might be right.
16:16:52 <skorpan> @src unfoldl
16:16:53 <pumpkinbot> Source not found. You speak an infinite deal of nothing
16:16:56 <skorpan> =(
16:17:02 <ehird> skorpan: It's here:
16:17:05 <ehird> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1119#a1120
16:17:13 * ehird rewrites unfoldl using foldl >:D
16:17:27 <ehird> ... Hang on a second...
16:17:34 <idnar> you can write either one with the other, surely?
16:17:36 <ehird> I'm fairly sure I don't use a foldl.
16:17:41 <rwbarton> I think you could implement your unfoldl as  unfoldl f = reverse . reverse . unfoldr f  :)
16:17:41 <ehird> ... do I?
16:17:51 <ehird> rwbarton: *g*
16:18:06 <ehird> Same results, not the same implementation.
16:18:14 <pumpkin> reverse . reverse ftw
16:18:27 <ehird> Gracenotes: how does my unfoldl use a foldl?
16:18:32 <skorpan> my favorite is id . id
16:18:49 <skorpan> i like it because i want to make sure it really is the identity function
16:18:59 <rwbarton> skorpan: for that there's also id (id)
16:19:06 <Gracenotes> ehird: well, you don't *need* a foldl to reverse a list. But it's how it's implemented
16:19:16 <Gracenotes> it's rather efficient as well
16:19:16 <ehird> Gracenotes: oh, ha!
16:19:32 <ehird> you can omit the reverse, but then everything goes backwards. /obviou
16:19:32 <ehird> s
16:22:22 <Gracenotes> :t unfoldr
16:22:23 <pumpkinbot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:23:09 <dons> yo sclv , is fmapfixreturn your blog?
16:23:12 <dons> sclv: ^
16:23:40 <sclv> dons: yeah. very defunct at the moment tho.
16:23:50 <dons> is it on planet.haskell ?
16:24:02 <sclv> i sent in a request ages ago and it never went through...
16:24:08 <dons> ah ha. well, that's my job now.
16:24:10 <dons> let's make it so!
16:24:14 <sclv> awesome
16:25:07 <ehird> do blogs have to be haskell only to be on planet haskell?
16:25:28 <dons> done. updating.
16:25:31 <thetallguy> ehird: no
16:25:36 <dons> ehird: from people in the haskell community
16:25:41 <ehird> do they have to be *mostly* haskell? :-)
16:25:50 <thetallguy> ehird: no
16:25:55 <sclv> although some people provide feeds of only posts tagged haskell...
16:26:04 <dons> either you're a haskell person blogging about stuff, or a person blogging about haskell stuff
16:26:16 <ehird> sclv: yeah, I have a religious objection to tags :)
16:26:28 <thetallguy> ehird: personally, I like the mix
16:26:47 <thetallguy> man does not live by category theory alone
16:26:56 <defun> There have been benchmarks comparing the speed of haskell code to other languages. What about GHC to other compilers (like gcc, g++, etc?). Would GHC be faster than g++, in your opinions, for example? Or would this benchmark be useless?
16:26:57 <ehird> well now -that's- arguable.
16:27:40 <dons> defun: use the shootout, that's the only public one.
16:27:58 <dons> in generaly your g++ or gcc code will be on par or <2x faster.
16:28:03 <dons> than good haskell code from ghc
16:28:08 <dons> the exception is parallel programs
16:28:12 <dons> where ghc will win, mostly.
16:28:17 <ddarius> ehird: CosmicRay's (John Goerzen's) blog is mostly about day to day stuff.
16:28:23 <ehird> :)
16:28:27 <dons> defun: see http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gcc
16:28:32 <defun> ok, thanks.
16:28:35 <dons> actually, my 2x was wrong.
16:28:43 <dons> well, mostly < 2x, a couple of outliers
16:28:57 <Gracenotes> hm... I'm trying to do foldl with unfoldr, but either the element at the beginning or the element at the end is getting left out :)
16:29:34 <rwbarton> meteor-contest is a little different, you're encouraged to come up with your own algorithm for that one
16:30:27 <dons> so on the shootout, when haskell is slower, it averages 2.3x slower than gcc currently
16:30:31 <dons> it is faster in two cases.
16:30:47 <dons> which is about right.
16:31:14 <dons> vs ocaml, looks about ==
16:31:23 <defun> very helpful, indeed. Thanks.
16:31:28 <dons> faster in 5 progs (including 1 threaded on), slower in 3
16:31:34 <rwbarton> I wonder why ghc is using 234 times more memory than gcc on pidigits... that can't be good
16:31:36 <dons> worst slow down vs ocaml, 3.1x
16:31:38 <ddarius> Still have a lot of faster-code-toys in the pipeline too.
16:31:44 <dons> best speedup, non-threaded, 3.7x
16:32:03 <dons> so good haskell ranges between 3x and 3x slower than ocaml, averaging about ==
16:32:09 <dons> (little yay from me there)
16:32:23 <shepheb> anyone know a program I can feed a fairly simple CFG, and then fire strings at it to check that my grammar is sensible (and also not ambiguous?)
16:32:24 <dons> yeah, ghc's getting faster.
16:32:28 <elly> hm
16:32:37 <elly> is there a way to get ghc to generate a lazy list of the multiples of 3?
16:32:44 <dons> yes
16:32:51 <elly> aha, I got it
16:32:54 <dons> :)
16:32:55 <elly> [ 3, 6 .. ] :D
16:32:59 <dons> :)
16:33:10 <ddarius> shepheb: There's a few things that might do that.  Certainly several parser generators could be used if you language falls into theirs.
16:33:18 <elly> so the multiples of 3 < 1000 is: takeWhile (< 1000) [ 3, 6 .. ]
16:33:21 <tehgeekmeister> how do you match end of line in parsec?  \n didn't seem to do it
16:33:28 <tehgeekmeister> well, string "\n"
16:33:42 <ddarius> BNFC, the Grammar Framework, or Stratego might have something that can do that handily
16:33:45 <dons> > takeWhile (< 1000) [ 3, 6 .. ]
16:33:46 <pumpkinbot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
16:34:17 <ddarius> > fix (map (3*) . (1:))
16:34:18 <pumpkinbot>   [3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,1434...
16:34:45 <ddarius> > fix (map (3+) . (0:))
16:34:46 <pumpkinbot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
16:37:24 <shepheb> ddarius: I'm working on an assignment, so something quick to set up and learn is paramount.
16:39:18 <glguy> there is always: [3,6 .. 999]
16:41:33 <hackage> Uploaded to hackage: OpenVG 0.1
16:41:33 <hackage> Uploaded to hackage: gitit 0.5.3
16:46:01 <Saizan> what do you think about considering "empty" and "insert" the constructors of Data.Map.Map for the sake of a Data instance?
16:47:25 <Saizan> the current Data instance is has most methods filled with undefined
16:47:26 <ddarius> Sounds like it would lead to a list not a balanced tree...
16:47:37 <ddarius> Oh, Data as in the class.
16:47:46 <Saizan> yeah
16:47:46 <ddarius> @src Data
16:47:46 <pumpkinbot> Source not found. Have you considered trying to match wits with a rutabaga?
16:47:53 <ddarius> , src ''Data
16:47:56 <lunabot>  class (Typeable a) => Data a where
16:47:56 <lunabot>          gfoldl ::
16:47:56 <lunabot>                 forall c .
16:48:40 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Data.html
16:49:23 <Saizan> you essentially get an association-list view, in this way
16:50:52 <FliPPeh> Partial function "part = (/10)" works, as calling "part 100" divides by 10. Using (-10) will obviously fail due to it meaning negative four. How can I do it anyways?
16:51:51 <rwbarton> > (subtract 10) 25
16:51:52 <pumpkinbot>   15
16:52:16 <wli> Partial application, slices, etc.
16:52:45 <Saizan> you meant negative ten, right?
16:54:00 <FliPPeh> That's kind of an akward solution
16:54:30 <Gracenotes> people expect subtraction and negation to mean the same thing
16:54:38 <Gracenotes> that is, to have the same symbol
16:54:47 <Gracenotes> even though they're kinda distinct
16:55:07 <Gracenotes> one is unary and the other is binary. This is kinda a problem in Haskell :X
16:56:05 <FliPPeh> > let part = (subtract 10) in part 50
16:56:06 <pumpkinbot>   40
16:56:08 <Gracenotes> @hoogle (-)
16:56:08 <pumpkinbot> Prelude (-) :: Num a => a -> a -> a
16:56:08 <pumpkinbot> keyword --
16:56:08 <pumpkinbot> keyword ->
16:56:27 <Gracenotes> -- is a keyword? as a comment?
16:56:36 <FliPPeh> > :t --
16:56:37 <pumpkinbot>   mueval: Prelude.read: no parse
16:56:48 <FliPPeh> > let part = (subtract 10) in part 50 --comments work here?
16:56:49 <pumpkinbot>   40
16:56:50 <FliPPeh> :D
16:57:06 <ddarius> It's a token at least which is why --> is allowed as an operator
16:57:15 <FliPPeh> Too bad you have to go around subtracting instead of minussing
16:59:10 <Gracenotes> the one time I've used subtract, really..
16:59:15 <Gracenotes> > foldl' subtract 4 (map (4/) [3,5..10^7])
16:59:18 <pumpkinbot>   3.1415928535897395
16:59:24 <Gracenotes> and even that's of limited application :)
17:00:20 <FliPPeh> Well, I guess every language comes with it's weaknesses
17:00:48 <FliPPeh> While C and friends make your head explode, Haskell is limited by it's own rules at times
17:01:26 <Peaker> FliPPeh: rarely do I find this "limiting", I often find it liberating, because it frees me to think about important stuff, knowing the compiler is the pedant for me :)
17:01:37 <FliPPeh> Not so bad, considering it only applies to partial functions
17:02:29 <rwbarton> I'm not sure what you mean by "it", but the only exception to the section syntax is for -, Haskell's only unary operator
17:03:26 <FliPPeh> By "it" I mean the last successful executed expression :))
17:03:37 <BMeph> > it
17:03:38 <pumpkinbot>   mueval: Prelude.read: no parse
17:03:45 * BMeph gets it. ;)
17:03:50 <FliPPeh> No really, that unary - replacement subtract :)
17:04:16 <FliPPeh> I think I'll fall for that sooner or later
17:05:42 <Gracenotes> @hoogle default
17:05:42 <pumpkinbot> keyword default
17:05:42 <pumpkinbot> Distribution.Simple.Setup defaultBuildFlags :: BuildFlags
17:05:42 <pumpkinbot> Data.ByteString.Lazy.Internal defaultChunkSize :: Int
17:05:43 <FliPPeh> > let p x = x `mod` 3892 == 0 in head (filter p [100000, 99999..])
17:05:44 <pumpkinbot>   97300
17:07:07 <FliPPeh> > take 20 [ x | x <- [1..], odd x ]
17:07:08 <pumpkinbot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39]
17:07:10 <mmorrow> , let (.-) = subtract in fmap (.-1) [0..]
17:07:11 <lunabot>  [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-...
17:07:26 <Gracenotes> default is only for Nums?
17:07:29 <mmorrow> oops
17:07:34 <mmorrow> , let (.-) = flip subtract in fmap (.-1) [0..]
17:07:35 <lunabot>  [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2...
17:07:47 <FliPPeh> > reverse (take 30 [ x | x <- [1..], odd x ])
17:07:48 <pumpkinbot>   [59,57,55,53,51,49,47,45,43,41,39,37,35,33,31,29,27,25,23,21,19,17,15,13,11...
17:08:25 <BMeph> I find it an annoyance that (- x) is parsed the same way as (-x).
17:08:49 <Gracenotes> :t ((-) 4)
17:08:51 <pumpkinbot> forall t. (Num t) => t -> t
17:09:11 <BMeph> I guess the whole layout rule spoils me into thinking that whitespace is used where it isn't... :\
17:09:59 <tehgeekmeister> is there a way to make parsec signal an error somehow if it doesn't parse all of it's input?  could be via exception or an either/maybe value?
17:10:38 <rwbarton> :t eof
17:10:39 <pumpkinbot> Not in scope: `eof'
17:10:42 <rwbarton> @hoogle eof
17:10:43 <pumpkinbot> Text.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
17:10:43 <pumpkinbot> Text.ParserCombinators.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
17:10:43 <pumpkinbot> Text.Read EOF :: Lexeme
17:11:03 <rwbarton> tehgeekmeister: you can match eof at the end of your parser
17:11:12 <tehgeekmeister> rwbarton: okay, thanks
17:13:45 <FliPPeh> map (\a -> a*a) [1..10]
17:13:49 <FliPPeh> > map (\a -> a*a) [1..10]
17:13:50 <pumpkinbot>   [1,4,9,16,25,36,49,64,81,100]
17:14:02 <FliPPeh> Looks like I got lambdas, too
17:14:24 <FliPPeh> > map (\a -> a:[]) [1..10]
17:14:26 <pumpkinbot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
17:14:43 <skorpan> @djinn (forall a. a -> a) -> b
17:14:43 <pumpkinbot> -- f cannot be realized.
17:14:50 <FliPPeh> > map (\a -> ("Item", a)) [1..10]
17:14:51 <pumpkinbot>   [("Item",1),("Item",2),("Item",3),("Item",4),("Item",5),("Item",6),("Item",...
17:15:36 <int80_h> test
17:15:43 <FliPPeh> Failed
17:15:50 <FliPPeh> > let test = False
17:15:51 <pumpkinbot>   mueval: Prelude.read: no parse
17:16:13 <FliPPeh> :t flip
17:16:14 <pumpkinbot> forall a b c. (a -> b -> c) -> b -> a -> c
17:16:55 <FliPPeh> > flip (add 4 5)
17:16:56 <pumpkinbot>   mueval: Prelude.read: no parse
17:17:09 <FliPPeh> > flip (max 4 5) (max 5 4)
17:17:11 <pumpkinbot>       Overlapping instances for Show (a -> c)
17:17:11 <pumpkinbot>        arising from a use of `s...
17:17:13 <FliPPeh> :/
17:17:41 <BMeph> > flip max 4 5
17:17:42 <pumpkinbot>   5
17:17:54 <FliPPeh> What does flip do?
17:17:55 <BMeph> @bo
17:17:55 <pumpkinbot> :)
17:18:05 <Gracenotes> flip add 4 5 ..means.. (flip add) 4 5
17:18:13 <augustss> > flip (/) 2 3
17:18:14 <pumpkinbot>   1.5
17:18:19 <BMeph> Gracenotes: Correct. :)
17:18:28 <Gracenotes> function application groups to the left like that
17:18:56 <augustss> FliPPeh: it flips the arguments to a function
17:19:01 <FliPPeh> Hmm!
17:19:13 <FliPPeh> > flip (++) "bar" "foo"
17:19:14 <pumpkinbot>   "foobar"
17:19:17 <FliPPeh> Sweet
17:19:19 <BMeph> FliPPeh: flip takes a "two-arg" function and makes it into a "two-arg" function that takes it's arguments in reversed order. :)
17:19:38 <BMeph> @let swap ~(a,b) = (b,a)
17:19:39 <pumpkinbot>  Defined.
17:19:40 <FliPPeh> > flip (++) " cake" "delicious"
17:19:42 <pumpkinbot>   "delicious cake"
17:19:52 <Gracenotes> > let if' a b c = if a then b else c in flip if' 42 False 63
17:19:54 <pumpkinbot>   63
17:20:41 <FliPPeh> :t foldl
17:20:42 <pumpkinbot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:21:27 <augustss> FliPPeh: you can actually tell from the type of flip exactly what it does
17:21:32 <augustss> :t flip
17:21:34 <pumpkinbot> forall a b c. (a -> b -> c) -> b -> a -> c
17:21:38 <FliPPeh> The "forall" confuses me
17:21:50 <augustss> FliPPeh: ignore it
17:21:55 <FliPPeh> > foldl (+) [1..36]
17:21:56 <pumpkinbot>       Overlapping instances for Show ([[t]] -> [t])
17:21:56 <pumpkinbot>        arising from a use...
17:22:16 <FliPPeh> > foldl [1..36] (+)
17:22:17 <pumpkinbot>   Couldn't match expected type `a -> b -> a'
17:22:19 <FliPPeh> :(
17:22:30 <augustss> > foldl (+) 0 [1..36]
17:22:32 <pumpkinbot>   666
17:22:46 <Gracenotes> if the interpreter tells you that there's no instance of "Show", it might mean that you're missing an argument
17:23:01 <augustss> > flip foldl 0 (+) [1..36]
17:23:01 <FliPPeh> > foldl (+) 0 [1..36]
17:23:02 <pumpkinbot>   666
17:23:03 <pumpkinbot>  Terminated
17:23:07 <FliPPeh> > foldl (+) 1 [1..36]
17:23:08 <pumpkinbot>   667
17:23:30 <Gracenotes> > max 5
17:23:31 <pumpkinbot>       Overlapping instances for Show (t -> t)
17:23:31 <pumpkinbot>        arising from a use of `s...
17:23:33 <augustss> > foldl1 (+) [1..36]
17:23:34 <pumpkinbot>   666
17:23:58 <Gracenotes> foldl1 f (x:xs) is literally foldl f x xs
17:24:00 <FliPPeh> > foldl (\a b -> a*b) 0 [1..36]
17:24:01 <pumpkinbot>   0
17:24:04 <BMeph> Gracenotes: I prefer to say that if it says there's no instance for Show, then UR DOIN IT RONG! ;p
17:24:12 <FliPPeh> > foldl (\a b -> a*b) 5 [1..36]
17:24:13 <pumpkinbot>   1859966633949506087339997240754176000000000
17:24:18 <FliPPeh> > foldl (\a b -> a*b) 1 [1..36]
17:24:20 <pumpkinbot>   371993326789901217467999448150835200000000
17:24:27 <Gracenotes> @src product
17:24:27 <pumpkinbot> product = foldl (*) 1
17:24:35 <FliPPeh> > foldr (\a b -> a*b) 1 [1..36]
17:24:36 <pumpkinbot>   371993326789901217467999448150835200000000
17:25:07 <Gracenotes> BMeph: heh ;) though the other few times I just forgot to derive Show :P
17:27:12 <Gracenotes> just how does pi :: Floating a => a work? Magic?
17:27:37 <augustss> Gracenotes: what do you mean, how?
17:27:51 <FliPPeh> > let (\o/) a b = a * b in 5 \o/ 5
17:27:52 <pumpkinbot>   mueval: Prelude.read: no parse
17:27:53 <rwbarton> , src 'pi
17:27:56 <lunabot>  Class op from Floating: pi :: forall a . Floating a => a
17:28:00 <ddarius> data FloatingDict = FloatingDict { pi :: a, ... };  x = pi --> x dict = pi dict
17:28:08 <Gracenotes> is it just defined internally as a constant?
17:28:10 <FliPPeh> > let (</>) a b = a * b in 5 </> 5
17:28:12 <pumpkinbot>   25
17:28:16 <ddarius> It's just a method of Floating.
17:28:26 <augustss> Gracenotes: Each Floating instance define the value of pi.
17:28:49 <FliPPeh> > let ((*)y(*)) a b = a * b in 5 (*)y(*) 5
17:28:49 <skorpan> what the heck
17:28:50 <pumpkinbot>       No instance for (Num
17:28:50 <pumpkinbot>                         ((t -> (t1 -> t2 -> t3) ->...
17:28:52 <FliPPeh> Awww
17:28:56 <FliPPeh> No boobie operator
17:28:59 <skorpan> :t (</>)
17:29:00 <pumpkinbot> Not in scope: `</>'
17:29:05 <Gracenotes> ah, okay... that's a bit of an odd thing to have in a typeclass
17:29:12 <skorpan> oh, right, oh
17:29:16 <Gracenotes> @src CReal pi
17:29:16 <pumpkinbot> Source not found. And you call yourself a Rocket Scientist!
17:29:20 <Gracenotes> not really
17:29:24 <augustss> Gracenotes: is it?
17:29:56 <Gracenotes> hm. Well, I guess if you're defining sin, you may as have something to feed it
17:30:15 <augustss> Gracenotes: saves you doing 4 * atan 1
17:30:30 <Gracenotes> I'm wondering how it works for CReal, then... is it really infinite precision?
17:30:40 <dmwit> No, it's arbitrary precision.
17:30:45 <dmwit> There's a big difference.
17:30:48 <Gracenotes> well, yes, arbitrary.
17:30:51 <augustss> Gracenotes: as much as you ask for
17:31:05 <Gracenotes> hmm.
17:31:35 <augustss> Gracenotes: So pi is defined by a formula in Floating CReal
17:32:02 <Gracenotes> > last $ showCReal 10000 pi
17:32:07 <pumpkinbot>   mueval: Prelude.read: no parse
17:32:21 <Gracenotes> > last $ showCReal 1000 pi
17:32:22 <pumpkinbot>   '9'
17:32:31 <Gracenotes> hm.
17:32:41 <augustss> what's wrong with the bot?
17:33:33 <Gracenotes> pi = 16 * atan (fromRational (1 % 5))  - 4 * atan (fromRational (1 % 239))
17:33:37 <Gracenotes> heh
17:33:47 <Gracenotes> in Floating CReal
17:33:59 <Gracenotes> so I guess *you* don't have to manually call atan...
17:34:22 <augustss> That's what I said :)
17:34:29 <Gracenotes> yeah
17:34:38 <Gracenotes> O
17:36:15 <Gracenotes> CReal uses interesting maths...
17:37:39 <augustss> It's pretty incomprehensible. :)
17:38:19 <Gracenotes> /some/ of it is plain enough. e.g. sinh x  = (y - recip y) / 2 where y = exp x
17:39:06 <augustss> yes, true
17:39:51 <FliPPeh> > let (^-^) a b = a * b in 5 ^-^ 5
17:39:52 <pumpkinbot>   25
17:40:00 <FliPPeh> Happy-Operator, yay.
17:40:10 <wli> Gracenotes: It's better to use tanh(x/2) or some such; that particular thing gets bad cancellation near 0.
17:40:16 <dmwit> > let a ^-^ b = a * b in 5 ^-^ 5
17:40:17 <pumpkinbot>   25
17:40:27 <dmwit> > let (^-^) = (*) i 5 ^-^ 5
17:40:28 <pumpkinbot>   mueval: Prelude.read: no parse
17:40:29 <Gracenotes> it seems that it basically involves a function that takes a number of one precision and converts it to another, until the satisfactory precision is reached
17:40:33 <augustss> wli: but it doesn't matter much for CReal
17:40:34 <dmwit> uh
17:40:39 <dmwit> oh
17:40:41 <dmwit> > let (^-^) = (*) in 5 ^-^ 5
17:40:43 <pumpkinbot>   25
17:41:00 * roconnor defines pi as 176*atan(1/57) + 28*atan(1/239) -48*atan(1/682)+96*atan(1/12943)
17:41:11 <FliPPeh> Bed time, gotta get up in 3 hours
17:41:15 <Gracenotes> it uses what seems to be a variation of Newton's method for sqrts
17:41:16 * Twey defines pi as 22/7.
17:41:18 <Twey> >.>
17:41:23 <augustss> roconnor: is that more efficient?
17:41:23 <Gracenotes> and power series for transcendental operations
17:41:27 <dmwit> pi = 3
17:41:28 * elly hmms
17:41:31 <Twey> Hahaha
17:41:32 <wli> augustss: Faster convergence or some such helps in general.
17:41:33 <hackage> Uploaded to hackage: gofer-prelude 2.30.2
17:41:34 <roconnor> augustss: I believe so.
17:41:37 <elly> generating a list of the first 10000 primes takes a while
17:42:23 <roconnor> elly: depends how you do it
17:42:26 <augustss> roconnor: faster convergence for all the atans, I guess
17:42:30 <elly> I am doing it in a naive manner
17:42:36 <elly> namely filter isPrime [ 1 .. ]
17:42:40 <roconnor> augustss: right, the inputs to atan are quite a bit smaller
17:42:49 <redditbot> Assertions in Haskell
17:42:49 <redditbot> System U-Box compiler is go
17:42:53 <Twey> elly: It's free if you don't use it!
17:42:59 <roconnor> elly: depends how you implement isPrime
17:43:01 <elly> but I am using it
17:43:05 <elly> isPrime does trial division up to n
17:43:13 <Gracenotes> :X
17:43:20 <roconnor> elly: http://r6.ca/blog/20081116T213644Z.html
17:43:25 <Gracenotes> there is probably a trade-off between complexity and efficiency, in terms of pi formulas.
17:43:25 <wli> I think for sinh x a continued fraction may work.
17:43:32 <Gracenotes> those involving atans anyway
17:46:13 <wli> tanh(x) falls to continued fractions if nothing else.
17:46:36 <elly> roconnor: that's terrifying
17:47:01 <roconnor> elly: in a good way?
17:47:05 <elly> yes
17:47:07 <elly> also it's fast
17:47:22 <roconnor> it's fairly fast for it's simplicity
17:47:26 <roconnor> its
17:48:10 <roconnor> Gracenotes: http://web.archive.org/web/20021208234336/http://www.cacr.caltech.edu/~roy/upi/pi.formulas.html
17:48:52 <augustss> roconnor: so, do you have a way to calculate erf?
17:49:21 <roconnor> augustss: I implemented it in FewDigits
17:49:59 <mmorrow> \
17:50:45 <roconnor> augustss: I don't know how to do any range reduction on it, so it converges slowly for large inputs
17:50:58 <augustss> roconnor: very, very slowly
17:51:17 <roconnor> but works fairly well on inputs less than 1 in absolute value
17:51:23 <augustss> sure
17:51:33 <augustss> did you use the obvious power series?
17:51:37 <roconnor> yes
17:51:58 <elly> whee
17:52:02 <elly> doing project euler in haskell is fun
17:52:07 <roconnor> :)
17:52:09 <augustss> I'd like to have a better way.  because it's useless for large arguments
17:52:34 <roconnor> yes
17:52:41 <roconnor> I don't define it in my thesis.
17:53:05 <Gracenotes> > last $ showCReal (10^10) pi
17:53:11 <pumpkinbot>   mueval: Prelude.read: no parse
17:53:11 <Gracenotes> <interactive>: out of memory (requested 1074790400 bytes)
17:53:14 <Gracenotes> :/
17:53:23 <Gracenotes> that's a lot of bytes.
17:53:31 <augustss> Gracenotes: CReal is not really a good way to compute pi
17:53:32 <elly> is there a builtin to find all the sublists of a list?
17:53:45 <pumpkin> elly: as of 6.10 yeah
17:53:49 <elly> what's it called?
17:53:51 <pumpkin> , subsequences [1..5]
17:53:52 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[...
17:53:53 <Gracenotes> yeah, I figured :) may as well give it a try, but apparently my computer can't handle it
17:53:55 <roconnor> > last $ showCReal (10^10) $ 176*atan(1/57) + 28*atan(1/239) -48*atan(1/682)+96*atan(1/12943)
17:53:59 <pumpkin> if by sublists you mean subsets
17:54:01 <pumpkinbot>   mueval: Prelude.read: no parse
17:54:02 <idnar> Gracenotes: that's only about 1GB
17:54:05 <elly> I mean sublists, unfortunately
17:54:10 <thetallguy> I wonder if that article by Hoare will have an effect on the imperative community
17:54:11 <elly> (contiguous ordered ones)
17:54:13 <ddarius> , subsequences [2,2]
17:54:14 <lunabot>  [[],[2],[2],[2,2]]
17:54:15 <pumpkin> nopes
17:54:15 <idnar> Gracenotes: ;P
17:54:19 <augustss> > filterM (const [False,True]) [1,2,3]
17:54:20 <pumpkinbot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
17:54:29 <pumpkin> > concatMap inits . tails $ [1..5]
17:54:30 <pumpkinbot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[],[2],[2,3],[2,3,4],[2,3,4,5],...
17:54:37 <idnar> hmm, it's exactly 1GB + 1MB
17:54:41 <pumpkin> > filter (not . null) . concatMap inits . tails $ [1..5]
17:54:42 <Gracenotes> idnar: my computer can handle more... 4 GB. But I guess ghci didn't want to hurt me
17:54:42 <pumpkinbot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[2],[2,3],[2,3,4],[2,3,4,5],[3],[3...
17:54:54 <pumpkin> > filter (not . null) . concatMap tails . inits $ [1..5]
17:54:55 <pumpkinbot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
17:55:01 <SamB_XP> > concatMap tails (inits [1..10])
17:55:03 <pumpkinbot>   [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[]...
17:55:10 <pumpkin> elly: how's that?
17:55:25 <wli> sinh(x) = 2*tanh(x/2)/(1-tanh(x/2)^2), which is not very promising.
17:55:37 <SamB_XP> > concatMap inits (tails [1..10])
17:55:38 <pumpkinbot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
17:55:49 <SamB_XP> > concatMap inits (tails [1..5])
17:55:50 <pumpkinbot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[],[2],[2,3],[2,3,4],[2,3,4,5],...
17:55:56 <pumpkin> I like doing the inits first then the tails, as it works more nicely on infinite lists
17:56:07 <blackdog> is there an idiom for running an IO action with an index a certain number of times, or do you just mapM over a list of indices?
17:56:19 <SamB_XP> pumpkin: shouldn't there be one [] in there ?
17:56:27 <rwbarton> :t replicateM_
17:56:28 <pumpkinbot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
17:56:33 <glguy> :t inits <=< tails
17:56:34 <pumpkin> SamB_XP: maybe :)
17:56:34 <blackdog> rwbarton: thanks
17:56:34 <pumpkinbot> forall a. [a] -> [[a]]
17:57:15 <augustss> blackdog: forM [1..10] $ \ i -> ...
17:57:32 <augustss> @src forM
17:57:32 <pumpkinbot> forM = flip mapM
17:59:04 <blackdog> augustss: so really just the map-over-a-list approach...
17:59:53 <luqui> blackdog, without the index, some people use  sequence . replicate n
18:00:06 <glguy> replicateM
18:00:25 * elly ponders how inits works
18:00:30 <ddarius> @src inits
18:00:31 <pumpkinbot> inits []     =  [[]]
18:00:31 <pumpkinbot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
18:00:39 <glguy> pondering averted!
18:00:44 <blackdog> oh, replicateM_ doesn't quite work, i need to pass the index. mapM_ or forM_ seems a goer.
18:01:13 <elly> what does the _ suffix mean?
18:01:20 <blackdog> throw the result away
18:05:29 <elly> hm
18:05:41 <augustss> :t mapM
18:05:43 <pumpkinbot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:05:45 <wli> Actually using the duplication formulae, sign formulae (sinh(-x) = -sinh(x), cosh(-x) = cosh(x)), and the series for sufficiently small arguments are the way to go.
18:05:45 <elly> that inits yields multiple []s
18:05:47 <augustss> :t mapM_
18:05:48 <pumpkinbot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
18:06:52 <augustss> elly: how can it do that?
18:07:12 <elly> e.g., inits [1, 2]
18:07:15 <augustss> both equation have exactly one [] in the list
18:07:20 <elly> yeah, but it recurses
18:07:23 <elly> and each recursive call adds a []
18:07:34 <augustss> elly: and maps (x:)
18:07:36 <wli> (sinh(2*x) = 2*sinh(x)*cosh(x), cosh(2*x) = sinh(x)^2+cosh(x)^2)
18:07:42 <elly> > inits [1, 2, 3]
18:07:43 <pumpkinbot>   [[],[1],[1,2],[1,2,3]]
18:07:45 <elly> hm
18:07:51 <elly> I could've sworn it did that before...
18:08:29 <ddarius> elly: You can prove that it doesn't.  (By this, I mean do that as an exercise.)
18:08:55 <augustss> ddarius: And I already gave the gist of the proof
18:09:00 <ddarius> Indeed.
18:09:20 <elly> yes, I see what happens
18:09:32 <wli> So it can always be reduced to a partial sum of a power series with positive coefficients with positive argument strictly less than 1.
18:09:39 <elly> induction gives the proof pretty quickly
18:09:41 <augustss> I would not have used ++ in the definition of inits
18:09:51 <ddarius> Yeah, that's a bit bizarre.
18:10:03 <wli> And then brought back to the original argument with no cancellation.
18:10:09 <elly> why is it not just [] :?
18:10:16 <augustss> elly: exactly
18:10:28 <augustss> it would be better
18:10:50 <augustss> I wonder if ghc optimizes that use of ++?
18:10:55 <elly> @src tails
18:10:55 <pumpkinbot> tails []         = [[]]
18:10:55 <pumpkinbot> tails xxs@(_:xs) = xxs : tails xs
18:11:21 <ddarius> tails is pretty
18:11:31 <glguy> the results of @src are not necessarily what GHC uses
18:11:39 <augustss> true
18:12:35 <augustss> glguy: but in this case it is
18:12:43 <glguy> augustss, yeah... i just noticed :)
18:12:51 <glguy> http://darcs.haskell.org/packages/base/Data/List.hs , right?
18:13:11 <augustss> glguy: I looked in my ghc source tree
18:13:44 <ddarius> augustss: If (++) is worker-wrapper transformed then it probably optimizes to the same thing.
18:16:35 <glguy> it appears that rules file
18:16:36 <glguy> fire
18:21:42 <dcoutts> augustss: btw, I filed your complaint from earlier: http://hackage.haskell.org/trac/hackage/ticket/483
18:22:43 <mmorrow> @let ats = let go _ [] _ = []; go _ _ [] = []; go n a@(i:is) (x:xs) | n==i = x : go (n+1) is xs | otherwise = go (n+1) a xs in go (0::Int)
18:22:43 <pumpkinbot>  Defined.
18:23:21 <wli> With a small lack of list sorting tha should be going on, sch x | x < 0, (s, c) <- sch (-x) = (-s, c) | x == 0 = (0, 1) | x >= 1/2, (s, c) <- sch (x/2) = (2*s*c, s*s + c*c) | otherwise = let terms = scanl (\t n -> t*x / fromInteger n) 1 [1..] ; step (u, v) (~(t_e:t_o:ts)) | u + t_o == u && v + t_e == v = (u, v) | otherwise = step (u + t_o, v + t_e) ts in step (0, 0) terms
18:23:31 <mmorrow> @let pie n = let fibs m n = m : fibs n (m+n) in (*4) . foldl' (\a b -> a + atan(1/b)) 0 . fmap fromIntegral . take n . ats (fmap(\k->2*k+1)[1..]) $ fibs 0 1
18:23:32 <pumpkinbot>  Defined.
18:23:47 <mmorrow> > fmap pie [10000..]
18:23:53 <pumpkinbot>   mueval: Prelude.read: no parse
18:23:53 <wli> The terms should be added up in ascending order.
18:24:10 <mmorrow> @type pie
18:24:11 <pumpkinbot> forall b. (Floating b) => Int -> b
18:24:16 <mmorrow> > fmap pie [1000..]
18:24:18 <pumpkinbot>   [3.141592653589794,3.141592653589794,3.141592653589794,3.141592653589794,3....
18:24:30 <mmorrow> > fmap pie [1000..] :: [CReal]
18:24:36 <pumpkinbot>   mueval: Prelude.read: no parse
18:24:43 <mmorrow> > fmap pie [10..] :: [CReal]
18:24:45 <pumpkinbot>   [3.1413668052471954530649856532569510866334,3.14150638719919239644901963378...
18:25:01 <mmorrow> > pie 100 :: CReal
18:25:03 <pumpkinbot>   3.1415926535897932384626433832795028841972
18:25:07 <wli> The sinh series should be for sinh(x)/x and cosh(x) as-is, then comparison with eps gives a takeWhile (> eps) to filter terms of the series.
18:25:34 <mmorrow> > pi
18:25:35 <pumpkinbot>   3.141592653589793
18:25:52 <mmorrow> > pi :: CReal
18:25:54 <pumpkinbot>   3.1415926535897932384626433832795028841972
18:26:07 <DrSyzygy> So baguasquirrel has a problem with Parsec.Rfc2822: he gets weird type errors on running > runParser address () input
18:26:16 <DrSyzygy> Anyone here know how to get this to work?
18:26:58 <adekoba> is it possible to define an empty class?
18:27:05 <DrSyzygy> Sure.
18:27:09 <DrSyzygy> data Myclass = Myclass
18:27:18 <skorpan> DrSyzygy: what?
18:27:24 <mmorrow> class A a
18:27:29 <DrSyzygy> Oh wait. Class.
18:27:30 <DrSyzygy> Sorry.
18:27:31 <mmorrow> instance A [Int]
18:27:36 <DrSyzygy> I'm not thinking. :P
18:27:41 <mmorrow> heh
18:28:08 <mmorrow> > showCReal 100 pi
18:28:10 <pumpkinbot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
18:28:14 <Gracenotes> RFC 2822?
18:28:22 <Gracenotes> is that IRC? or e-mail?
18:28:23 <mmorrow> > showCReal 100 (pie 100)
18:28:24 <pumpkinbot>   "3.141592653589793238462643383279502884197163953826196770339846278850521861...
18:28:29 <wli> Lambert's W is more interesting, I suppose. x*e^x is minimized when (x + 1)*e^x = 0 or x = -1, I think W(x) might have some meaningful bounds to bootstrap Newton wit.
18:28:31 <DrSyzygy> Gracenotes: That's email.
18:28:53 <Gracenotes> okay
18:29:40 <Saizan> ?hoogle runParser
18:29:40 <pumpkinbot> Language.Haskell.ParseMonad runParser :: P a -> String -> ParseResult a
18:29:40 <pumpkinbot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
18:29:40 <pumpkinbot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
18:30:25 <Saizan> DrSyzygy: which type errors?
18:31:42 <mmorrow> @let diffAt xs = length . takeWhile id . zipWith (==) xs
18:31:44 <pumpkinbot>  Defined.
18:32:16 <mmorrow> @let diffAtCReal n a b = diffAt (showCReal n a) (showCReal n b)
18:32:17 <pumpkinbot>  Defined.
18:32:31 <mmorrow> > diffAtCReal 100 pi (pie 100)
18:32:32 <pumpkinbot>   43
18:32:36 <mmorrow> > diffAtCReal 100 pi (pie 500)
18:32:38 <pumpkinbot>   101
18:32:44 <mmorrow> > diffAtCReal 1000 pi (pie 500)
18:32:47 <pumpkinbot>   210
18:33:19 <adekoba> no way to make a GADT a derived instance of a class (like e.g. Show), eh?
18:33:37 <mmorrow> > fmap (diffAtCReal 1000 pi . pie) [100,200..]
18:33:43 <pumpkinbot>   mueval: Prelude.read: no parse
18:33:54 <mmorrow> > fmap (diffAtCReal 1000 pi . pie) (take 5 [100,200..])
18:33:59 <pumpkinbot>   mueval: Prelude.read: no parse
18:34:11 <mmorrow> > fmap (diffAtCReal 300 pi . pie) (take 5 [100,200..])
18:34:14 <pumpkinbot>   [43,84,126,167,210]
18:34:44 <L_11> Alright i'm tinkering with haskell for the first time (coming from C) - I have ghci open and am trying to create a new function as "fibonacci :: Int -> Int" and it gives me an error that fibonacci is not in scope. No idea what this means . . .
18:34:54 <L_11> book doesn't explain anything either
18:35:18 <dmwit> Use let.
18:35:24 <dmwit> "let fibonacci n = ..."
18:35:31 <mmorrow> > fmap (uncurry subtract) . (zip`ap`tail) . fmap (diffAtCReal 300 pi . pie) $ (take 5 [100,200..])
18:35:35 <pumpkinbot>   [41,42,41,43]
18:35:58 <dmwit> ?let fibonacci 0 = 1; fibonacci 1 = 1; fibonacci n = fibonacci (n-1) + fibonacci (n-2)
18:35:59 <pumpkinbot>  Defined.
18:36:05 <dmwit> > let fibonacci 3
18:36:06 <pumpkinbot>   mueval: Prelude.read: no parse
18:36:16 <L_11> hm lemme try that out
18:36:18 <SamB> L_11: even better would be to write it in an emacs buffer
18:36:20 <dmwit> > fibonacci 3
18:36:21 <pumpkinbot>   3
18:36:35 <L_11> i'm familiar with vim, haven't used emacs too much - can you explain?
18:36:46 <SamB> or vim
18:36:47 <SamB> whatever
18:36:54 <L_11> I know there is a haskell mode, not sure how to enable it or if I need additional packages
18:37:06 <L_11> well when you say, buffer what do you mean exactly?
18:37:14 <luqui> @pl \x y z -> x
18:37:14 <pumpkinbot> const . const
18:37:18 <SamB> oh, just whatever you use to edit a file in vim ...
18:37:29 <L_11> oh hm
18:38:10 <mmorrow> > let convergeSteps showLen tgt f xs = fmap (uncurry subtract) . (zip`ap`tail) . fmap (diffAtCReal showLen tgt . f) $ xs in convergeSteps 300 pi pie [100,200,300,400,500]
18:38:11 <SamB> let me start over
18:38:14 <pumpkinbot>   [41,42,41,43]
18:38:20 <mmorrow> @let convergeSteps showLen tgt f xs = fmap (uncurry subtract) . (zip`ap`tail) . fmap (diffAtCReal showLen tgt . f) $ xs
18:38:22 <pumpkinbot>  Defined.
18:38:26 <DrSyzygy> Gah! cabal-install requires HTTP but not the latest HTTP!?
18:38:29 <SamB> even better: write it in your text editor and use :l
18:38:47 <L_11> SamB: alright this is what i tried first
18:38:57 <SamB> what was the issue with that ?
18:38:58 <L_11> I get an error about me missing main, my book never specifies how to initiate main
18:39:12 <SamB> using ghci and :l ?
18:39:16 <luqui> @pl \x y z -> z
18:39:16 <pumpkinbot> const (const id)
18:39:36 <L_11> yea, i punched in 'fibonacci :: Int -> Int' in a file then did a :l and got that error
18:39:43 <Saizan> DrSyzygy: if you are on unix there's a bootstrap.sh script in cabal-install's tarball
18:40:37 <pumpkin> @users
18:40:37 <pumpkinbot> Maximum users seen in #haskell: 658, currently: 616 (93.6%), active: 17 (2.8%)
18:40:55 <L_11> well in my .hs file do I still need the ?let ? or is that only for the interpreter?
18:41:11 <mmorrow> now i can't think of any functions to test against each other for convergence.. :/
18:41:13 <Saizan> L_11: only for the interpreter
18:41:33 <hackage> Uploaded to hackage: syb-with-class 0.5.1
18:41:33 <hackage> Uploaded to hackage: syb-with-class 0.5
18:41:55 <glguy> L_11, The GHCi prompt is like defining "main = do ..." in your .hs file
18:42:06 <glguy> L_11, the ?let command is a bot command on this IRC channel
18:42:06 <L_11> ah
18:42:24 <L_11> oh
18:42:32 <Saizan> ":l yourfile.hs" shouldn't complaing about a missing main function
18:42:45 <dmwit> mmorrow: sum of 1/n^2 and whatever it converges to
18:43:00 <dmwit> mmorrow: Or isn't that what you meant...?
18:43:01 <L_11> alright well let me go tinker with this. Thanks everyone :)
18:43:22 <DrSyzygy> Saizan: I'm almost on unix.
18:43:24 <DrSyzygy> OSX.
18:43:37 <DrSyzygy> Got it up and running now.
18:43:38 <SamB> DrSyzygy: do you have wget ?
18:43:42 <DrSyzygy> Nope.
18:43:47 <DrSyzygy> I don't have ports or fink.
18:43:55 <SamB> well I think the script uses wget
18:43:56 <DrSyzygy> So I use curl instead of wget.
18:43:57 <wli> mmorrow: sn(x,k) as k -> 0 and k -> 1
18:44:00 <mmorrow> > convergeSteps 100 0 (\x->1/(x**2)) [1..20]
18:44:02 <pumpkinbot>   [2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
18:44:39 <dmwit> :t convergeSteps
18:44:41 <pumpkinbot> forall a. Int -> CReal -> (a -> CReal) -> [a] -> [Int]
18:44:42 <mmorrow> > convergeSteps 100 0 (\x->1/(x**2)) (take 10 $ iterate (+0.01) 0.0001)
18:44:44 <pumpkinbot>   [0,0,0,0,0,0,0,0,0]
18:44:49 <mmorrow> > convergeSteps 100 0 (\x->1/(x**2)) (take 10 $ iterate (+0.01) 0.01)
18:44:50 <pumpkinbot>   [0,0,0,0,0,0,0,0,0]
18:45:08 <mmorrow> > 1/(2^2) :: CReal
18:45:10 <pumpkinbot>   0.25
18:45:14 <mmorrow> > 1/(2^8) :: CReal
18:45:15 <pumpkinbot>   0.00390625
18:45:23 <mmorrow> um
18:45:28 <glguy> On OS X, the ftp(1) command can  be used to download from HTTP
18:45:34 <dmwit> The result type of [Int] is suspicious.
18:45:38 <dmwit> Is that really what you want?
18:45:47 <mmorrow> > fmap (\x->1/(x**2)) [0..10] :: [CReal]
18:45:53 <pumpkinbot>   mueval: Prelude.read: no parse
18:46:01 <mmorrow> > fmap (\x->1/(x^2)) [0..4] :: [CReal]
18:46:07 <pumpkinbot>   mueval: Prelude.read: no parse
18:46:13 <dmwit> eh
18:46:18 <mmorrow> > (\x->1/(x^2)) 4 :: CReal
18:46:20 <pumpkinbot>   0.0625
18:46:28 <mmorrow> > (\x->1/(x^2)) 20 :: CReal
18:46:29 <pumpkinbot>   0.0025
18:46:29 <wli> The sum of 1/n^2 converges too slowly; you have to use series acceleration.
18:46:34 <mmorrow> > (\x->1/(x^2)) 1000 :: CReal
18:46:35 <pumpkinbot>   0.000001
18:46:37 <glguy> mmorrow, can you do some of that in /msg?
18:46:47 <mmorrow> glguy: yes
18:48:10 <glguy> thanks :)
18:48:13 <pumpkin> > sqrt . (*6) . sum . map ((1/) . (^2)) $ [1..100]
18:48:15 <pumpkinbot>  Terminated
18:48:19 <pumpkin> :(
18:48:21 <pumpkin> > sqrt . (*6) . sum . map ((1/) . (^2)) $ [1..100]
18:48:22 <pumpkinbot>   3.1320765318091053
18:48:39 <pumpkin> > sqrt . (*6) . sum . map ((1/) . (^2)) $ [1..200]
18:48:40 <pumpkinbot>   3.136826306330968
18:48:44 <pumpkin> meh :)
18:48:45 <wli> I think Euler-MacLaurin summation is how to do it.
18:48:57 <Gracenotes> pumpkin: pi from a circle..?
18:49:08 <Gracenotes> hrm, no
18:49:39 <Gracenotes> I can see the formula in my mind, I just don't recognize it :P
18:49:52 <pumpkin> > sqrt . (*6) . sum . map ((1/) . (^2)) $ [1..2000]
18:49:53 <pumpkinbot>   3.1411152718364823
18:50:58 <pumpkin> \frac{pi^2}{6} = sum_{i=1}^{\infty}{\frac{1}{i^2}
18:51:05 <pumpkin> whoops, didn't close it
18:51:42 <pumpkin> whoops \sum
18:51:53 <Gracenotes> ah! that I recognize. don't forget its derivation though
18:52:00 <Gracenotes> don't remember, even
18:52:37 <mmorrow> @let pie1 n = sqrt . (*6) . sum . map ((1/) . (^2)) $ [1..n]
18:52:38 <pumpkinbot>  Defined.
18:52:59 <mmorrow> > convergeSteps 300 pi pie [100,200,300,400,500]
18:53:01 <pumpkin> Gracenotes: it's not too complicated, more info here http://en.wikipedia.org/wiki/Basel_problem
18:53:03 <pumpkinbot>   [41,42,41,43]
18:53:06 <mmorrow> > convergeSteps 300 pi pie1 [100,200,300,400,500]
18:53:11 <pumpkinbot>   mueval: Prelude.read: no parse
18:53:14 <mmorrow> gah
18:53:18 <pumpkin> I doubt it converges very fast :P
18:53:32 <DrSyzygy> Re. the question earlier: I tried installing HsEmail from scratch on a natively installed ghc system (my own), and it works out of the box.
18:53:37 <mmorrow> i can't seem to get any results :)
18:53:40 <DrSyzygy> I've told baguasquirrel to go reinstall.
18:53:49 <Gracenotes> pumpkin: neat
18:54:05 * Gracenotes hasn't read up on infinite series in too long...
18:54:06 <wli> head . dropWhile (\(_, x) -> abs (sqrt (6*x) - pi) >= 1e-6) . zip [1..] $ scanl1 (+) $ map (^^(-2::Int)) [1..] :: (Int, Double) ---> (954930,1.6449330196516412)
18:55:05 <wli> Comparing that to pi*pi/6 :: Double doesn't look promising.
18:55:28 <wli> Summing 1M terms to get to 1e-6 is pathetic.
18:55:48 <pumpkin> I didn't propose it as a good way to compute pi :P
18:56:44 <wli> I'm saying one would never do that in practice; analytic methods of accelerating the series (try the Lerch transcendant) would always come into play.
18:57:04 <wli> You always look at the rate of convergence.
18:57:04 <islon_s> how do i know the current working dir in ghci??
18:57:16 <pumpkin> :!pwd
18:57:28 <pumpkin> assuming you're not on windows
18:57:36 <islon_s> pumpkin, i am =/
18:57:44 <dmwit> import System.Directory
18:57:47 <dmwit> getCurrentDirectory
18:58:12 <islon_s> dmwit, thanks =)
18:58:58 <wli> ISTR integral representations due to Hermite being around.
18:59:22 <islon_s> ghci doesnt have permission to open files??
18:59:34 <dmwit> hm?
18:59:50 <islon_s> "*** Exception: todo.txt: openFile: permission denied (Permission denied)"
19:00:03 <pumpkin> I'd say chmod
19:00:11 <pumpkin> but I won't
19:00:41 <dmwit> islon_s: That's odd.
19:00:48 <dmwit> Do you have permission to see that file otherwise?
19:00:52 <islon_s> im on windows and ghci created the file itself
19:00:54 <dmwit> How are you opening the file?
19:01:01 <SamB_XP> islon_s: hah
19:01:06 <islon_s> fhandle <- openFile todoFile ReadWriteMode
19:01:10 <dmwit> Do you have it open in other programs?
19:01:17 <SamB_XP> islon_s: what does the properties box tell you ?
19:01:34 <dmwit> I bet another program (perhaps ghci itself) has a write-lock on it.
19:01:38 <SamB_XP> maybe you can't open textfiles in ReadWriteMode in Winodws ?
19:01:49 <dmwit> You can't open a single file in write mode twice.
19:02:30 <dmwit> islon_s: Try "readFile todoFile" to see if it's specifically a write-mode problem.
19:02:36 <islon_s> the only program that has the file open is ghci itself (i closed the session and open again but it didnt work)
19:03:20 <SamB_XP> islon_s: what does the properties dialog say about the ACL of the file ?
19:03:31 <dmwit> Yeah, that's a good question, too.
19:03:38 <islon_s> goddamn! i have put a "print =<< readFile todoFile" in the next line
19:03:51 <islon_s> my bad
19:03:55 <SamB_XP> next line after what ?
19:04:02 <mmorrow> iirc there's some extra thing that ghci and/or cabal does on windows since essentially any user can rm -rf /, but i can't remember the specifics
19:04:04 <islon_s> after open it for write
19:04:20 <SamB_XP> mmorrow: the what now ?
19:04:23 <wli> Okay, for the Riemann zeta function, use http://en.wikipedia.org/wiki/Dirichlet_eta_function#Borwein.27s_method
19:04:29 <mmorrow> i don't remember
19:04:38 <mmorrow> i just recall someone giving dcoutts a hard time about it
19:05:23 <mmorrow> (this probably has nothing to do with the current situation)
19:07:28 <mmorrow> ah, looks like it was wrt permissions on globally installed binaries or some such
19:08:45 <mmorrow> SamB: hey, do you know if it's a (long-term/whatever) goal of lhc to compile itself?
19:09:07 <SamB_XP> mmorrow: well, it's not a short-term goal!
19:09:16 <mmorrow> heh
19:09:25 <SamB_XP> there's a LOOONG list of features we'd need before that's practical
19:09:38 <mmorrow> i'm wondering though if it's ever been mentioned or anything like that
19:09:50 <mmorrow> (explicitly)
19:10:25 <ddarius> Dirichlet series are joyful.
19:10:26 <mmorrow> hmm, can yhc or nhc build themselves?
19:10:37 <dons> nhc can via gcc
19:10:44 * pumpkin starts phc
19:10:44 <dons> but its faster if you build it via ghc, iirc
19:11:13 <mmorrow> ooh, nice. via gcc is more than nothing
19:11:42 <mmorrow> is it equivalent capabilities via gcc?
19:11:57 <mmorrow> nhc is one compiler i've never had any contact with
19:12:08 <SamB_XP> we'd need MPTCs, functional dependencies, a garbage collector, less memory leakage, Template Haskell ...
19:12:34 <glguy> dons, so GHC and OCaml are competitive on the shootout. Time to get building GHC to be competitive with ocaml :)
19:12:51 <SamB_XP> dcoutts: is there a way to find out all the extensions used by a package and it's dependencies (besides base) ?
19:13:15 <L_11> another question - what would be the best way to take a list then create another list with the values alternating: ie [a2, a1, a4, a3 . . .]?
19:13:46 <SamB_XP> L_11: what do you want to do if the list is odd in length ?
19:14:00 <L_11> put the odd value at the end
19:14:06 <L_11> I'm assuming working backwards would be best?
19:14:10 <SamB_XP> hmm ?
19:14:11 <augustss> L_11: just plain recursion
19:14:20 <mmorrow> SamB_XP: ah yeah, that reminds me. could you possibly paste the lhc-generated C code of some trivial program? i'm unclear how to get the lhc base built-and-hooked-in (trying to build from darcs), and i want to check out the C
19:14:36 <SamB_XP> f [] = []
19:14:39 <L_11> yea, I guess my question is how do I pass in a list of lists?
19:14:42 <SamB_XP> f [x] = [x]
19:14:49 <L_11> SamB: yea I have those parts already
19:14:53 <mmorrow> like "main = print =<< getContents"
19:14:55 <L_11> just not sure about the more complicated portions
19:14:59 <augustss> L_11: f (x1:xs:xs) = x2:x1:f xs; f xs = xs
19:15:00 <L_11> I suppose the recurrsion
19:15:12 <SamB_XP> f (x1:x2:xs) = x2 : x1 : f xs
19:15:17 <mmorrow> SamB: is it really any diff than the C output from jhc at this point?
19:15:26 <SamB_XP> mmorrow: hmm ?
19:15:27 <L_11> (x1:xs:xs) basically a regular expression?
19:15:40 <augustss> L_11: no
19:15:42 <mmorrow> SamB: the lhc C output
19:15:47 <SamB_XP> not much yet
19:15:58 <dons> glguy: bah, ghc does more stuff, so i don't care.
19:15:59 <SamB_XP> well, I mean, it's in the same STYLE
19:16:04 <SamB_XP> I dunno about the structure
19:16:20 <SamB_XP> but if you report a bug, we're liable to fix it!
19:16:22 <mmorrow> SamB: do you have lhc working?
19:16:28 <mmorrow> (on your box)
19:16:35 <SamB_XP> define working
19:16:46 <SamB_XP> I guess it works as well as can be expected ;-)
19:16:51 <mmorrow> can you build "main = putStr =<< getContents" and paste the generated C?
19:17:06 <mmorrow> (=: working)
19:17:14 <mmorrow> :)
19:18:17 <SamB> mmorrow: well, maybe after this compile fails ... it's using huge amounts of RAM
19:18:37 <SamB> I have 33 MB "free"
19:19:14 <mmorrow> don't explode you box, but if next time you happen to have an lhc-produced .c i'd give you ++ if you pasted it :)
19:19:32 <pumpkin> omg bribes
19:19:37 <mmorrow> i try
19:21:54 <wli> let n `choose` k | k < 0 || k > n = 0 | k == 0 || k == n = 1 | 2 * k > n = n `choose` (n - k) | otherwise = (n * ((n - 1) `choose` (k - 1))) `div` k ; dt n i = (fromIntegral $ (n + i) `choose` (2*i)) / (fromIntegral $ n + i) ; d n k = let ds = map (fromIntegral n *) . scanl1 (+) $ zipWith (*) (iterate (4*) 1) [dt n i | i <- [0..k]] in ds !! k ; eta n s = recip (d n n) * sum [(-1)^k*(d n n - d n k)/((fromIntegral $ k + 1)**s) | k <- [0 .. n-1]]
19:21:57 <twb> To which BTS should I report a haddock bug?
19:22:00 <pumpkin> scary
19:22:52 <SamB_XP> twb: haddock trac
19:22:55 <SamB_XP> @go haddock trac
19:22:56 <pumpkinbot> No Result Found.
19:23:19 <SamB_XP> well, if you google it yourself you should find it
19:23:42 <wli> eta 18 seems to be the right thing to do
19:23:54 <SamB_XP> twb: but you are using haddock 2.4.1, right ?
19:24:15 <wli> pumpkin: Try it with s = 2 for finding sum [n^^(-2) | n <- [1..]]
19:25:09 <wli> pumpkin: It reputedly also works for non-integer values of s so long as s > 1.
19:25:18 <pumpkin> what does it do?
19:25:19 <mmorrow> SamB_XP: ah, just realized i need cabal 1.7 for lhc base
19:25:23 <pumpkin> I'm too tired to parse that
19:26:08 <SamB> mmorrow: you can't use cabal-install with the head, just FYI
19:26:11 <pumpkin> oh eta
19:26:16 <SamB> I mean the head of cabal
19:26:31 <SamB> I don't know how far you'd have to unpull to get it to work :-(
19:26:43 <mmorrow> SamB: i'm not using cabal-install anyways :)
19:26:58 <wli> eta n s is a particular approximation of n terms to sum [(-1)^(n-1)/((fromIntegral n)**s) | n <- [1..]]
19:27:06 <mmorrow> i'll just build a ghc-HEAD to get new cabal
19:27:17 <pumpkin> ah cool
19:27:20 <wli> The larger the n the more terms are used.
19:27:27 <SamB> mmorrow: how the heck did you install all the dependencies!
19:27:50 <wli> The function it approximates is \eta(s) = (1-2^{1-s})\zeta(s)
19:28:32 <wli> So eta n s / (1 - 2**(1-s)) gives you your answer in some way that actually converges with machine arithmetic.
19:29:06 <mmorrow> SamB: for what?
19:29:27 <islon_s> so, zipWith is just map with a function that takes 2 lists and a second list parameter?
19:29:42 <pumpkin> islon_s: it takes a function to combine matching elements of two lists
19:29:45 <kapil> wli: as opposed to blindly summing n^^(-2) which never does!
19:30:03 <islon_s> just like map does to a single list
19:30:20 <pumpkin> islon_s: yeah, it's a "parallel" map over two lists
19:30:27 <wli> kapil: By the time roundoff errors are done building up with enough terms to meet any useful tolerance, you've got a wrong answer.
19:30:33 <kapil> wli: isn't this called Euler summation or something?
19:30:35 <mmorrow> SamB: oh, i have some scripts to build stuff. i just can't use cabal-install in particular on this particular ghc install because there're a bunch of hacked packages and i don't want cabal-install to try to rebuild/install them
19:30:59 <islon_s> pumpkin, its parellel?
19:31:15 <SamB> mmorrow: yes but there are SO MANY dependencies!
19:31:28 <pumpkin> parallel in that it covers both lists at once, not in the multithreaded sense
19:31:50 <islon_s> ah, ok
19:32:49 <mmorrow> nice, looks like nhc can fully bootstrap from C
19:32:58 <mmorrow> SamB: grrrr
19:33:10 <SamB> mmorrow: grr what ?
19:33:17 <mmorrow> grrr so many deps :)
19:33:37 <SamB> hey, at least we don't list cabal-install as an actual dependency ;-P
19:33:51 <mmorrow> true
19:33:55 <wli> kapil: The results of Euler summation are a different series/sequence.
19:34:17 <twb> SamB: I dunno.
19:34:19 <islon_s> strange, my current code in haskell is shorter than my english-pseudocode
19:34:22 <twb> SamB: I'll cabal install it to be sure.
19:35:05 <SamB> mmorrow: have you heard of our channel #lhc-compiler ?
19:35:14 <BMeph> islon_s: That's because your Haskell code can beat up your honor student... ;)
19:36:10 <islon_s> and im a newbie...
19:36:38 <pumpkin> omg its BMeph
19:36:54 <BMeph> OMG, it's...not pumpkinbot! ;p
19:37:43 <pumpkin> :o
19:39:54 <ddarius> islon_s: Learn J.
19:40:08 <islon_s> ddarius, why?
19:40:32 <ddarius> Because you are hard pressed to make English pseudocode that is shorter than the equivalent J code.
19:41:33 <hackage> Uploaded to hackage: PerfectHash 0.1.1
19:41:43 <islon_s> ill put on my to learn list
19:45:04 <mmorrow> SamB: i haven't
19:48:00 <islon_s> i want to compile a single Todo.hs to an exe on windows with ghc the command is "ghc Todo.hs"? (it contains a main function)
19:49:39 <twb> SamB: my fault; I was using Debian's (very old) copy of haddock.
19:49:58 <dons> ghc --make -O2 Todo.hs
19:52:29 <islon_s> dons, it generated the .hi and the .o but no exe
19:54:44 <dons> do you have 'main' defined in Todo.hs ?
19:54:50 <goalieca> so say i have «input <- readFile 'someTxt'»  and then the next line i have print (splitLines input). how come that works but split_list <- (splitLines input) doesnt?
19:54:51 <dons> i.e. main = print "hello"
19:55:22 <dons> goalieca: do-blocks need to end in a statement
19:55:22 <islon_s> dons, yeah "main :: IO ()"
19:55:31 <BMeph> goalieca: Check your types. :)
19:55:35 <dons> islon_s: what is the main function? do you have module Main where?
19:55:43 <dons> and  check your types., goalieca
19:55:44 <dons> :)
19:55:47 <roconnor> @hoogle Unique
19:55:47 <pumpkinbot> module Data.Unique
19:55:47 <pumpkinbot> Data.Unique data Unique
19:55:47 <pumpkinbot> Data.Unique hashUnique :: Unique -> Int
19:56:00 <islon_s> dons, i need the module to be named main?
19:56:05 <dons> islon_s: as a test, does the file containing:   main = print "foo"
19:56:07 <dons> compile to a .exe ?
19:56:11 <goalieca> ya. umm. i did. but i dont get why
19:56:26 <dons> <- is for monadic code.
19:56:30 <dons> splitLines is pure.
19:56:37 <goalieca> i tried liftM
19:56:39 <dons> so you'd say, let xs = splitLines input
19:56:40 <roconnor> aww Unique is IO based
19:57:05 <islon_s> dons, it worked now, i changed the module name from Todo to Main, thanks
19:57:29 <goalieca> hmm.. throwing the let works..
19:57:38 <goalieca> whereas liftM doesnt. i need to review more
19:57:46 <dons> islon_s: cool
19:58:04 <dons> goalieca: try: xs <- return (splitLines foo)
19:58:08 <BMeph> islon_s: Conga-Rats! :)
19:58:22 <islon_s> BMeph, =)
19:58:39 <roconnor> is there a supply monad out there somewhere with runSupply :: [a] -> Supply a b -> b  ?
19:59:17 <islon_s> so there's no relation in module name and .hs file name?
19:59:46 <dons> no, there is, but not for the main module
19:59:52 <L_11> I'm trying to write a function that will take a list of integers, subtract two pairs and multiply them: (a1 - a2) * (a2 - a3) . . . my code is just giving 1 no matter what: http://pastebin.com/df5a6252
19:59:54 <dons> which is a bit magic (you can leave module Main out entirely)
19:59:57 <goalieca> dons ya that works.
20:00:17 <nanothief> islon_s, normally the filename and module name must be the same, but Main is special, and can appear in a file with any name
20:00:44 <islon_s> so a file named Whatever.Bla needs to be named Bla.hs and reside in a directory named Whatever?
20:00:50 <islon_s> *a module named
20:01:26 <SamB> islon_s: yeah, and Whatever's parent must be on the search path
20:02:07 <islon_s> just like java
20:03:16 <wli> L_11: I don't see a proble.
20:03:18 <wli> > let d ([] :: [Integer]) = 1 :: Integer ; d [_] = 1 ; d (a1:a2:as) = (a1 - a2) * d as in map d $ inits [2*k+1 | k <- [1..10]]
20:03:20 <pumpkinbot>   [1,1,-2,-2,4,4,-8,-8,16,16,-32]
20:04:36 <L_11> wli: yea i'm not sure what's going on
20:04:48 <wli> L_11: What are you trying to compute?
20:05:25 <L_11> i just need to take a list of integers, and get the produce of all the element differences: (1,2,3,4) = (1-2) * (2-3) * (3*4)
20:05:33 <L_11> *products
20:06:24 <L_11> no matter what, my code gives me 1
20:06:26 <L_11> not sure why
20:06:40 <wli> L_11: First, try discriminant xs = product . zipWith (*) xs $ tail xs
20:07:05 <BMeph> L_11: Because you're only giving it lists that work out to be 1. Do you have any other lists? :)
20:07:06 <wli> L_11: First, try discriminant xs = product . zipWith (-) xs $ tail xs
20:07:18 <wli> L_11: Second, it works fine.
20:07:41 <L_11> heh never occurred to me that my lists might actually equate to one - tried a few lists, let me try it again
20:08:02 <L_11> lol yea it works >_<
20:08:05 <wli> > let discriminant [] = 1; discriminant [_] = 1 ; discriminant (a1:a2:as) = (a1 - a2) * discriminant as in discriminant [k^2 | k <- [1..10]]
20:08:06 <BMeph>  > let d ([] :: [Integer]) = 1 :: Integer ; d [_] = 1 ; d (a1:a2:as) = (a1 - a2) * d as in d [1,2,3,4]
20:08:07 <pumpkinbot>   -65835
20:08:35 <BMeph> > let d ([] :: [Integer]) = 1 :: Integer ; d [_] = 1 ; d (a1:a2:as) = (a1 - a2) * d as in d [1,2,3,4]
20:08:37 <pumpkinbot>   1
20:08:51 <wli> > let discriminant [] = 1; discriminant [_] = 1 ; discriminant (a1:a2:as) = (a1 - a2) * discriminant as in map discriminant . take 10 $ inits [k^2 | k <- [1..]]
20:08:51 <BMeph> > let d ([] :: [Integer]) = 1 :: Integer ; d [_] = 1 ; d (a1:a2:as) = (a1 - a2) * d as in d [1,2,3,45,6]
20:08:53 <pumpkinbot>   [1,1,-3,-3,21,21,-231,-231,3465,3465]
20:08:53 <pumpkinbot>  Terminated
20:09:05 <BMeph> > let d ([] :: [Integer]) = 1 :: Integer ; d [_] = 1 ; d (a1:a2:as) = (a1 - a2) * d as in d [1,2,3,4,5,6]
20:09:06 <pumpkinbot>   -1
20:09:10 <wli> > let discriminant [] = 1; discriminant [_] = 1 ; discriminant (a1:a2:as) = (a1 - a2) * discriminant as in map discriminant inits [k^2 | k <- [1..10]]
20:09:12 <pumpkinbot>   Couldn't match expected type `[[t]]'
20:09:15 <pumpkin> the Terminated thing seems random
20:09:21 <pumpkin> not sure why I get it
20:09:37 <wli> Well, anyway...
20:10:02 <wli> L_11: I think the discriminant is defined differently if you have a list of roots of a polynomial.
20:10:55 <Axman6> > let d (a1:a2:as) = (a1 - a2) * d as; d a = 1 in d [1..6] -- BMeph
20:10:57 <pumpkinbot>   -1
20:11:23 <wli> L_11: I think it would be let discriminant [] = 1 ; discriminant [_] = 1 ; discriminant (x:xs@(_:_)) = product [x - y | y <- xs] * discriminant xs
20:15:27 <gwern> > 0.12 * 4000
20:15:29 <pumpkinbot>   480.0
20:17:00 <gio123bot> 480
20:17:55 <conal> @seen Peaker
20:17:55 <pumpkinbot> Peaker is in #haskell. I last heard Peaker speak 3h 16m 29s ago.
20:18:08 <conal> @localtime Peaker
20:18:09 <pumpkinbot> Local time for Peaker is Mon Feb  2 06:18:09
20:18:56 <dmwit> > 153 + 95 - 224
20:18:57 <pumpkinbot>   24
20:21:41 <gio123bot> 23
20:37:24 <Axioplase> Are there logical operators that work on numbers somewhere? (I'm looking for "inclusive or" on integers…)
20:38:38 <Axioplase> Ah. Data.Bits maybe…
20:44:26 <luqui> Hmph!  My program which uses unsafeCoerce everywhere is not working properly!  Who'd have thought...
20:51:11 <sjanssen> @remember luqui Hmph!  My program which uses unsafeCoerce everywhere is not working properly!  Who'd have thought...
20:51:12 <pumpkinbot> I will remember.
20:51:19 <sjanssen> bah, not even the real bot
20:51:42 <pumpkin> yeah :/
20:54:41 <liyang> 'topic
20:54:45 <liyang> oops
20:54:59 <ray> bumpkinbot
20:55:04 <magnicida> hi
20:55:14 <magnicida> i've got a problem with parsec.expr
21:08:18 <chrisdone> I was just reasoning through unification and realised ?x = (?x) would be invalid but would unify, and would go into an infinite loop to boot
21:08:26 <chrisdone> I'm guessing this is what the occurs check can be used for?
21:08:42 <sjanssen> magnicida: feel free to ask your question any time
21:10:04 <BMeph> chrisdone: Every time I've seen the occurs check in action, it's always been with types that expanded in some way, not with types that worked out to the same symbols. If that makes any sense at all... :)
21:13:51 <chrisdone> BMeph: well I mean it could be unify (a ?x) with (a (b ?x)) and we'd get (a (b Infinite loop
21:17:13 <BMeph> chrisdone: But then that would (presuming the 'a' and '?x" are the same, that ?x = b ?x, which is different problem from just ?x = ?x. :)
21:17:37 * BMeph hopes magnicida wasn't scared off...
21:18:08 * BMeph thinks, "Oops..." ;)
21:19:15 <chrisdone> yeah exactly
21:19:30 <chrisdone> `?x = b ?x' is the problem indeed
21:20:03 <chrisdone> apparently prolog doesn't check for this for efficiency
21:21:09 <chrisdone> oops,, heh
21:24:52 <BMeph> mib_8u9gaj: Hello.
21:25:29 <int80_h> BMeph: stop scaring the newbies :)
21:25:34 <int80_h> oh nm
21:25:50 <idnar> haha
21:26:17 <rwbarton> HWN from next week:  "BMeph went on vacation and #haskell reached 700 users"
21:26:29 <rwbarton> :)
21:26:32 <int80_h> hee hee
21:27:58 <chrisdone> haha
21:28:14 <BMeph> rwbarton: I'd go "haha," if I thought I'd actually go on vacation... ;p
21:31:35 <magnicida> hi
21:31:46 <magnicida> i can't get the Parsec.Expr example to compile
21:32:01 <chrisdone> welcome back
21:32:04 <magnicida> I've tried with Parsec 3, 2, and 1, without luck
21:32:23 <magnicida> thx chrisdone
21:32:30 <magnicida> have you got any experience with Parsec?
21:37:04 <chrisdone> I have a little
21:37:11 <chrisdone> do you have a question?
21:37:33 <magnicida> yep
21:38:26 <magnicida> i can't get to compile the Parser.Expr example found here: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#buildExpressionParser
21:38:52 <magnicida> i have tried with all Parsec versions without luck
21:38:55 <sjanssen> magnicida: what is the error message?
21:39:18 <magnicida> 1 sec
21:39:27 <chrisdone> I love personal whiteboards. perfect for jotting down code ideas
21:40:35 <travisbrady> anyone have any pointers with this error? http://pastie.org/377097
21:40:48 <travisbrady> i can't figure out what sort of type signature i need there
21:40:59 <hiredman> chrisdone: I have a big mirror I draw on with a dry erase marker
21:41:12 <magnicida> sjanssen, this is what i get with Parsec 2: http://pastebin.com/m1d1cff1b
21:41:31 <chrisdone> hiredman: good thinking!
21:42:48 <magnicida> this is the actual source i'm trying to compile: http://pastebin.com/d79b31df0
21:44:08 <magnicida> any hints?
21:45:23 <magnicida> well, i've just found an example that does compile here: http://hoc.sourceforge.net/examples.html
21:45:32 <magnicida> maybe I can rework my code starting from it
21:45:43 <magnicida> oh... this brainmelting and seducing haskell :)
21:46:20 <sjanssen> magnicida: so one thing to note is that the uu.nl docs are outdated
21:46:23 <llayland> magnicidia.  I did mine by starting with the While example that came with parsec
21:46:44 <magnicida> llayland, many thanks, i'll take a look at it
21:46:52 <magnicida> sjanssen, i see...
21:47:18 <pumpkin> dons: my upcoming change to uvector will make every unsafe operation I've found so far safe if the safe flag is on (but leave things alone otherwise... I'm just using your existing check functions)
21:48:50 <pumpkin> (and I'll amend the tests to check for the exceptions in cases that should throw them)
21:59:39 <llayland> So, I was reading "Real World Haskell" earlier, and my fever got to be a bit much so I took a nap.  I dreamed that I was coding and it did affect the real world.  Unfortunately I wasn't any better in my dreams
21:59:54 <llayland> very weird stuff
22:00:58 <shteou> 'lo guys.
22:01:16 <jrockway> llayland: obviously your dream took place in the IO monad
22:01:21 <jrockway> "impure thoughts" if you will
22:01:33 <byorgey> hi shteou
22:01:41 <shteou> How's it going in here?
22:01:59 <llayland> lol jrockway
22:03:13 <byorgey> travisbrady: do you know wh the constraint:
22:03:13 <byorgey>       `Stringable a'
22:03:13 <byorgey>         arising from a use of `directoryGroup' at <interactive>:1:7-47
22:03:21 <byorgey> err, sorry
22:03:33 <byorgey> travisbrady: do you know what instances are defined for Stringable?
22:03:42 <travisbrady> byorgey: i just hacked and figured out ":: IO (STGroup String)"
22:04:00 <BMeph> travisbrady: It's saying "Your result is of type IO (STGroup a), where a is a Stringable type. You don't say what type it is, though." :)
22:04:00 <byorgey> travisbrady: cool, yeah, that ought to work
22:04:29 <travisbrady> i was confused by the code, it's applicative and all the <$>'s kind of messed me up, i just don't get it
22:04:32 <byorgey> travisbrady: note that you'll probably only have this problem when doing something like this at the ghci prompt, since under normal circumstances the correct type would probably be inferred from the context
22:05:06 <BMeph> travisbrady: You could do that, sure. Just call it some type that works, or use it later in a way that pins it down...er, what byorgey said. :)
22:11:31 <llayland> Are there any good tutorials for using applicative functors?
22:13:34 <sereven> llayland: I've been looking for them, too. http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/ and http://en.wikibooks.org/wiki/Haskell/Applicative_Functors are where I've been focusing so far, but there are others for people with stronger background.
22:14:18 <xpika> are there any examples of a library written in haskell where  bindings for it have been exported to another language.
22:15:06 <llayland> Thanks sereven that first one looks like it might be helpful.   I certainly don't have a strong background.
22:22:22 <llayland> The fever and the pink elephant are back, so I'm out.  magnicida, good luck. shoot me an email if you get stuck.
22:28:14 <BMeph> xpika: From what I've seen, any Haskell libraries like that, other folks just rewrite instead - the whole "pay attention to types" think scares 'em away. ;)
22:52:27 <zenhacker> hi everyone
22:52:40 <byorgey> hi zenhacker
22:52:53 <blarz> hi, I just wanted to know out of curiosity if anybody knows why there are no new posts on http://ghcsparc.blogspot.com/
22:53:06 <zenhacker> if I have the following definition: data Variable a = NewVariable a
22:53:31 <zenhacker> how can i restrict a to 2 types
22:53:45 <mmorrow> @yow
22:53:45 <pumpkinbot> Couldn't find fortune file
22:53:46 <SubStack> jan 22 is pretty new
22:53:56 <zenhacker> say for: data T1 = NewT1
22:54:01 <SubStack> and people still use sparc? o_O
22:54:09 <zenhacker> and for: data 21 = NewT2
22:54:27 <byorgey> zenhacker: maybe you want to do something like  data Variable a = IntVar Int | CharVar Char ?
22:54:27 * mmorrow finally figured out how to finish translating this syntax to another one
22:54:43 <jeffz`> SubStack: as long as Sun still sells them and supports sparc, I'm sure people will.
22:54:49 <mmorrow> it's been weeks off-and-on
22:54:50 <blarz> SubStack: well there were new posts on a daily basis, so I thought perhaps something happened ;)
22:54:57 <byorgey> zenhacker: I'm not sure I really understand what you're asking though.
22:55:26 <zenhacker> byorgey: i need to restrict the 'a' in data Variable a = NewVariable a
22:55:43 <zenhacker> byorgey: i need to restrict the 'a' in data Variable a = NewVariable a to some other types
22:55:50 <mmorrow> love it when it finally goes, it goes in an almost trivial amount of code too
22:55:58 <mmorrow> "it"
22:56:02 <byorgey> zenhacker: well, there's no really good way to 'restrict' it.  Instead what you can do is make a different constructor for each possible type.
22:56:28 <ski_>   data Variable :: * -> *
22:56:31 <ski_>     where
22:56:31 <byorgey> zenhacker: like  data Variable = T1Var T1 | T2Var T2
22:56:36 <ski_>     NewT1Variable :: T1 -> Variable T1
22:56:37 <ski_>     NewT1Variable :: T2 -> Variable T2
22:57:03 <ski_> (preferably renaming the second constructor to `NewT2Variable')
22:57:18 <byorgey> zenhacker: what's your use case?
22:57:20 <ski_> zenhacker : how about that ?
22:58:04 <byorgey> good point, GADTs can help you restrict the parameter to Variable, if you want it to be parameterized.
22:58:10 <somnolence> how can you insert a value into a list at a given index?
22:58:19 <byorgey> but you still need a different constructor for each possible type.
22:58:57 <byorgey> somnolence: use 'splitAt' to break the list into two parts, then prepend the element to the second half of the list and stick them back together with ++
22:59:58 <mmorrow> , (\n x xs -> (\(ys,zs)->ys++x:zs) (splitAt n xs)) 4 900000 [0..9]
23:00:01 <lunabot>  [0,1,2,3,900000,4,5,6,7,8,9]
23:00:11 <BMeph> ...or be old-fashioned and use an alrray... ;p
23:00:14 <zenhacker> byorgey:http://haskell.pastebin.com/m3217b4bb
23:01:01 <ski_> , (\n f xs -> (\(ys,x:zs)->ys++f x:zs) (splitAt n xs)) 4 (+900000) [0..9]
23:01:02 <lunabot>  [0,1,2,3,900004,5,6,7,8,9]
23:01:10 <byorgey> zenhacker: I see.  In that case you probably want to use a GADT as ski_ suggested.
23:01:20 <mmorrow> ski_: haha
23:01:28 <mmorrow> nice
23:01:53 * mmorrow writes that one down
23:01:59 <zenhacker> byorgey: thnx for the help
23:02:06 <zenhacker> ski_: thnx for the help
23:02:49 <byorgey> zenhacker: hmm, do you really need a type parameter to 'Literal' though?
23:02:59 <mmorrow> ski_: ohhhh, n/m. i didn't notice the `f' and thought you somehow exploited a parse ambiguity for a second
23:03:10 <zenhacker> byorgey: not really, i guess
23:03:16 <Taejo> @src undefined
23:03:16 <pumpkinbot> undefined =  error "Prelude.undefined"
23:03:22 <byorgey> zenhacker: would it not work to just have   data Literal = IntLit IntLiteral | StrLit StringLiteral
23:03:40 <zenhacker> byorgey: sure, but I thought there is a cleaner way to write it
23:03:43 <byorgey> in general that's how you combine two types into one: use a constructor for each
23:04:03 <byorgey> zenhacker: not really
23:04:16 <zenhacker> but then the values get wrapped up by each type constructor and I have to unwrap them
23:04:31 <byorgey> that seems fairly clean to me, given that you really need the IntLiteral and StringLiteral types
23:04:53 <byorgey> as opposed to just having  data Literal = IntLit Int | StrLit String
23:05:10 <ski_> , let (!!<-) = (\xs n f -> (\(ys,x:zs)->ys++f x:zs) (splitAt n xs)) in [[0,1,2,3],[4,5,6],[7,8],[9]] !!<- 1 $ \xs -> xs !!<- 2 $ \x -> x*x
23:05:11 <lunabot>  [[0,1,2,3],[4,5,36],[7,8],[9]]
23:05:13 <byorgey> zenhacker: well, yes, how else would you tell them apart?
23:05:43 <Olathe> Is there a standard way of representing RGB color values ?
23:05:46 <byorgey> if you combine two types into a single type, you need to be able to pattern-match on a constructor so you know which type you have
23:06:00 <jeffz`> Olathe: you could take a look at the Data.Colour package
23:06:02 <Taejo> Olathe: there is a colors package
23:06:06 <zenhacker> byorgey: yes
23:06:08 <Olathe> Thanks.
23:06:09 <mmorrow> ski_: hehe
23:06:26 <ddarius> ski_: Looks pretty fugly to me.
23:07:02 <ski_> it looks a little more sane, indented right
23:07:20 <zenhacker> byorgey: if i then want to create a literal i have to write something like: NewStrLit NewStringLiteral "t"
23:07:22 <ski_>   xss !!<- 1 $ \xs ->
23:07:29 <ski_>   xs  !!<- 2 $ \x  ->
23:07:30 <ski_>   x*x
23:07:33 <zenhacker> byorgey: which can become a bit confusing
23:08:02 <zenhacker> byorgey: so i thought i could get something like this: NewLiteral NewStringLiteral "t"
23:08:04 <byorgey> zenhacker: indeed. but I think that's more a result of having separate wrapper types IntLiteral and StringLiteral.
23:08:21 <byorgey> zenhacker: you'll need extra parens there:  NewLiteral (NewStringLiteral "t")
23:08:30 <zenhacker> byorgey: but i need them because i refer to them in other type constructors
23:08:31 <ski_> (mmorrow : i used that operation in a laboration that insisted on defining a `(!!:=)' operation .. which i duly implemented, but never used)
23:09:03 <mmorrow> ski_: hah
23:09:05 <zenhacker> byorgey: i first had: data Literal = NewIntLiteral Int | NewStringLiteral String
23:09:27 <ski_> (but, yes .. the idea could be expressed nicer, if fit into lenses)
23:10:32 <byorgey> zenhacker: IntLiteral and StringLiteral are just isomorphic to Int and String.  so you could just pass Int and String directly to the other type constructors, instead of wrapping them inside IntLiteral and StringLiteral.
23:10:52 <byorgey> zenhacker: there is little use for wrapper types like that, unless you are declaring type class instances for them
23:11:46 <ski_> zenhacker : it *might* be useful to index the `Literal' type with `String' vs. `Int' .. but then you'd better have a reason for doing it, instead of what byorgey suggested
23:12:53 <zenhacker> byorgey: im writing a small interpreter for my own language and need to pattern match on StringLiteral or IntLiteral
23:13:06 <mmorrow> i like  data Lit = IntL Int | StringL String | CharL Char | FloatL Double {-or Rational-}
23:13:21 <mmorrow> data Exp = .... | LitE Lit | ....
23:13:39 <somnolence> can someone take a look at my haskell code, there's something seriously wrong with the divisors function but I just don't see it: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1123#a1123
23:14:16 <byorgey> zenhacker: the only way you can pattern match on StringLiteral vs. IntLiteral is if they are two different constructors for the same type.  declaring singleton types  like 'data IntLiteral = NewIntLiteral Int' doesn't buy you anything.
23:14:18 <ddarius> We should get rid of primitives like numbers and strings.  They are so basic.  I think the base data structures should be graphs.
23:14:35 <zenhacker> byorgey: that is why i am wrapping up the int and string values in the IntLit and StringLit types
23:15:13 <byorgey> zenhacker: right. what I'm trying to say is that  data Literal = IntLit Int | StringLit String  should work just fine.
23:15:38 <wli> somnolence: I don't get what factors and divisors are supposed to do.
23:16:16 <zenhacker> byorgey: but i also need to be able to say data Expression = NewExpression StringLit [ functions ]
23:16:21 <somnolence> wli : one would think their names would be self evident
23:16:37 <byorgey> zenhacker: no, you can just say  data Expression = NewExpression String [ functions ].
23:17:08 <byorgey> zenhacker: I think I see what you are saying though.
23:17:38 <wli> somnolence: I'd write divisors n = [k | k <- [1 .. n], n `mod` k == 0] which doesn't seem to line up with your functions' types.
23:17:41 <zenhacker> byorgey: sorry for being so vague :)
23:17:48 <ski_> somnolence : you should define a wrapper to `factors'
23:17:50 <byorgey> zenhacker: I think you have two options: (1) do it like above (data Expression = NewExpression String [ ... ]) and so on
23:18:22 <byorgey> zenhacker: or (2) use GADTs and have Literal be indexed by the type of the literal, so that you can say  data Expression = NewExpression (Literal String) [...]
23:18:32 <wli> somnolence: So there is a trickiness wrt. what you mean by them.
23:18:34 <byorgey> zenhacker: choice (2) is a bit more complicated though.
23:18:35 <ski_> somnolence : i.e. rename `factors' to `factors_aux' (or what you will), and then define `factors n = factors_aux 1 n 100'
23:18:37 <somnolence> divisors has a glitch
23:18:42 <somnolence> I'm fixing it thanks I guess
23:18:47 <somnolence> ski_ thank you for irrelevant help
23:19:14 <wli> somnolence: Are the factors supposed to be prime power factors?
23:19:24 <ski_> somnolence : if had done that before, then wli would probably have understood what your code is supposed to be doing
23:19:27 <zenhacker> byorgey: thnx for all the help
23:19:32 <byorgey> zenhacker: sure.
23:19:41 <zenhacker> byorgey: i will have a look at the options
23:19:55 <zenhacker> byorgey: and see which work out the best :)
23:20:05 <byorgey> zenhacker: sometimes getting the type system to express exactly what you want can be tricky =)
23:20:13 <ski_> (somnolence : and yes, i usually provide help on whatever issues i see, in the order i see them .. i haven't reached `divisors' yet)
23:20:34 <zenhacker> byorgey: i see that :)
23:21:19 <byorgey> somnolence: it's customary to be polite to people offering you help, even if it seems irrelevant to you.
23:22:09 <somnolence> byorgey : I know but telling someone to write a wrapper instead of actually addressing issues is annoying and should be discouraged in my opinion.
23:23:03 <byorgey> somnolence: but perhaps ski_ *was* addressing issues.  Do you know Haskell well enough to be sure that he wasn't?
23:23:12 <ski_> somnolence : wli had trouble deciphering the intent of your function. i was thinking providing a proper wrapper would help with that
23:23:37 <somnolence> byorgey : yes, and if you don't understand the intent of a function called 'factors' feel free not to help =P.
23:24:39 <ski_> (since you have not given any intended semantics of the function, we're left to guess what it's supposed to do. making a wrapper with the standard expected interface to the function helps with this guessing)
23:25:18 <wli> There are various kinds of factors. They could be divisors, prime power factors, squarefree factorizations, etc.
23:25:34 <ski_> (it is not obvious why a function called `factors, which ostenably has something to do with factoring, should take two integers, and a list of integers as input)
23:26:06 <pumpkin> lol, I tried telling him that
23:27:17 <somnolence> At least I do type signatures now >_<
23:36:44 <ski_> somnolence : ok, now i see the problem
23:37:33 <ski_> to `divisors' you pass the divisors of `n' less than the square root of `n'
23:38:13 <ski_> then you intend (i think) to add as divisors the result of dividing `n' by each previous divisor
23:38:30 <ski_> however, you get confused when managing the indices
23:38:35 <_Jordan_> Can someone tell me what I'm doing wrong here? data Foo = Foo { mapOfBar :: M.Map String MyBarTypeClass }    ... it says I can't use a typeclass as a type, so how do I express "a Map where values are instances of MyBarTypeClass"?
23:38:37 <ski_> consider when `n = 100'
23:39:04 <ski_> then the initial call to `divisors' is
23:39:31 <ski_>   divisors 3 100 [5,4,2,1]
23:39:52 <ski_> where the `3' there is the current index into the list, initialized to the last index
23:39:58 <ski_> so, you compute
23:40:07 <wli> somnolence: witness
23:40:11 <wli> > let takeOne (~(p:ps)) n | n == 1 = [] | n `mod` p == 0 = p : takeOne (p:ps) (n `div` p)| otherwise = takeOne ps n ; primes = 2 : 3 : [p | p <- [5,7..], all (\q -> p `mod` q /= 0) $ takeWhile (\q -> q*q <= p) primes] ; factors n = map (\ps -> (head ps, length ps)) . group $ takeOne primes n in factors 52
23:40:12 <pumpkinbot>   [(2,2),(13,1)]
23:40:29 <ski_>     100 `div` ([5,4,2,1] !! 3)
23:40:37 <ski_>   = 100 `div` 1
23:40:40 <ski_>   = 100
23:40:50 <ski_> so, now the next call to `divisors' is
23:41:01 <ski_>   divisors 2 100 [100,5,4,2,1]
23:41:11 <ski_> and the next number you now compute is
23:41:25 <ski_>     100 `div` ([100,5,4,2,1] !! 2)
23:41:38 <ski_>     100 `div` 4
23:41:42 <ski_>     25
23:41:53 <ski_> do you see the problem, now ?
23:42:03 * ski_ just notices somnolence left :/
23:43:43 <Olathe> Hmm...Data.Binary has a maximum list size of 2^64.
23:43:51 <ski_> _Jordan_ : a map where values are values in *which* type instances of `MyBarTypeClass' ?
23:44:14 <glguy> Olathe, due to lazy bytestring
23:44:32 <BMeph> _Jordan_: You'd have to do something like data Foo = forall a. MyBarTypeClass a => Foo { mapOfBar :: M.Map String a }. Hopefully, your class instances have some way of self-identification. :)
23:44:44 <Olathe> Yeah, but if people still use Haskell code in 20 years, that might be too small.
23:44:52 <ski_> _Jordan_ : do you want each specific map to have every value in the *same* type (for that map) ?
23:45:21 <ski_> _Jordan_ : or should one map be able to hold values in *different* types, which are instances of that class ?
23:45:29 <BMeph> Hm, that wouldn't even work. :\
23:45:37 <_Jordan_> ski_: no, I don't care -- they just have to belong to MyBarTypeClass
23:45:50 <ski_> _Jordan_ : you have to decide what you want
23:45:58 <_Jordan_> :(
23:46:49 <byorgey> ski_++  -- deserved for trying to help somnolence
23:47:06 <ski_> with what BMeph suggested, each value in the map would be of some hidden type, of which you *only* know that it is in the class `MyBarTypeClass'
23:47:08 * wli tried too.
23:47:29 <_Jordan_> so I can't have a map of say, Ints and Floats, if all I care about is that they are some sort of number?
23:47:38 <glguy> _Jordan_, you can wrap the type up with its type class with existential quantification
23:47:40 <BMeph> ski_: I also noticed that he'll never have q in his list, if n == q*q.
23:47:44 <ski_> _Jordan_ : sure you can ..
23:47:52 <glguy> _Jordan_, you can make a new type
23:47:57 <ski_> (BMeph : yes, that's the other direct bug)
23:48:07 <glguy> data StuffIcareAbout = Ints Int | Floats Float
23:48:20 <byorgey> wli++  -- indeed
23:49:05 <BMeph> ski_ Kind of sad how some people can't stand to be told that they're doing it wrong...even though they're asking you what they're doing wrong... :\
23:49:07 * ski_ forgot mentioning <http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1123#a1124> ..
23:49:31 <_Jordan_> alright -- I think I understand
23:49:45 <ski_> BMeph : well, it looked like somnolence's connection went bad .. so s/he might be back
23:51:13 <wli> In what I wrote, d = product . map ((+1) . snd) . factors
23:51:15 <_Jordan_> so I can do like data Bars = (list of my MyBarTypeClass instances), and then do M.Map String Bars
23:52:14 <ski_> _Jordan_ : yes .. or you can do what BMeph suggested .. or you could for each map choose beforehand which type of values you want in that map (this is overloadable in many cases)
23:52:34 <glguy> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification
23:53:41 <BMeph> ski_, _Jordan_: That is, have multiple maps, one for each type in the MyBarTypeClass class, amirite? ;)
23:54:18 <ski_> (`data Foo a = Foo { mapOfBar :: M.Map String a }', yes)
23:55:11 <wli> Enumerating all possible divisors is trickier. divisors n = foldr (\ds ps -> [d*p | d <- ds, p <- ps]) [1] [take (k+1) $ iterate (p*) 1 | (p, k) <- factors n]
23:55:20 <glguy> _Jordan_, a lot of times you can just pre-apply the values to the function you were eventually going ot use them with anyway
23:55:26 <glguy> for example, if you want a map of Show instances
23:55:31 <glguy> just show them and have a map of strings
23:56:27 <ski_> (glguy : hehe, i don't think _Jordan_ has yet agreed s/he want existential functionality)
23:56:46 <glguy> ski_, well, _Jordan_ hasn't really explained what he is trying to do
23:56:54 <glguy> so I'm just filling the air with suggestions :)
23:56:56 <ski_> agreed
23:57:14 <_Jordan_> sorry, was reading that link
23:57:16 <ski_> (but i'm not sure _Jordan_ yet understand the subtlety)
23:57:48 <glguy> _Jordan_, if you give us more information, we can give you better answers
23:58:41 <_Jordan_> alright. I was trying to avoid details because my program is stupid, but oh well :)
23:58:48 * wli ponders methods of flattening out environment stacks like tagging them with levels.
23:59:18 <_Jordan_> I'm making a little game, and it has rooms, and in the rooms can be items
