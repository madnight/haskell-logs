00:00:04 <shapr> ivanm: Hey, be nice to Canadians, I may be one soon.
00:00:09 <pumpkin_> that would be awesome if it could
00:00:13 <ivanm> shapr: I know some canadians :p
00:00:19 <mmorrow> pumpkin_: not that i know of
00:00:26 <shapr> I don't, surprisingly.
00:00:26 <ivanm> we just had a really annoying canadian head of music at my high school ;-)
00:00:28 <mmorrow> pumpkin_: i think that'd be pretty hard in general
00:00:32 <pumpkin_> yeah :P
00:01:04 <Cheshire> hello
00:01:10 <shapr> hi Cheshire
00:01:11 <mmorrow> like a similar problem is taking all the live vars are being able to distinguish what's "semantic garbage"
00:01:13 <wli> I can't seem to get useful monads going with arrays.
00:01:31 <pumpkin_> yeah
00:01:36 <mmorrow> as in, vars that are still live but could actually be garbage collected since they'll never be used again
00:01:44 <shapr> __nfw: Ah, you're close to Seattle then?
00:01:45 <pumpkin_> makes sense
00:01:53 <BrokenClockwork1> hey, is someone able to tell me, how I have to interpret the data types of a languages written as: +/- 1,7E+308 (it's about floating numbers, which long precision, but how can I translate the E?)
00:01:53 <shapr> I want to move to Ontaria myself.
00:01:57 <pumpkin_> would still be pretty awesome to even catch in restricted cases
00:02:24 <Axman6> BrokenClockwork1: eN = * 10 ^ N
00:02:26 <mmorrow> pumpkin_: totally (which? the mutable thing or the sematic garbage thing?)
00:02:26 <Cheshire> BrokenClockwork, E for Exponential means  times ten to the power of
00:02:38 <pumpkin_> both, they seem pretty close
00:02:53 <BrokenClockwork1> so this would be -1,7 * 10^308
00:02:56 <ivanm> shapr: well, I've only ever heard it referred to as "Ontario"... ;-)
00:03:12 <mmorrow> pumpkin_: yeah. if you can think of a strategy you can write a paper about it :)
00:03:20 <__nfw> Yeah, really close to Seattle
00:03:20 <shapr> ivanm: I have a specific university I want to attend.
00:03:21 <pumpkin_> hah, maybe one day
00:03:27 <pumpkin_> mmorrow: still learning the basics :P
00:03:30 <shapr> ivanm: and it's in Hamilton!
00:03:30 <ivanm> shapr: ahhh
00:03:31 <__nfw> Never been there though
00:03:42 * ivanm has no idea where Hamilton is wrt North America
00:03:53 <__nfw> Right on top of the Great Lakes
00:03:55 <pumpkin_> is there a path to get there ;)
00:03:59 <pumpkin_> ?
00:04:01 <shapr> ivanm: Closest north american point is Buffalo NY
00:04:04 <ivanm> shapr: for PhD?
00:04:10 <ivanm> heh, that doesn't help much :p
00:04:13 <pumpkin_> (a hamiltonian path?)
00:04:16 <shapr> ivanm: Yeah, or master,s or what have you.
00:04:18 <ivanm> pumpkin_: *groan*
00:04:32 <pumpkin_> :P
00:04:37 <mmorrow> pumpkin_: boooooo :)
00:04:39 * ivanm has limited knowledge of the geographical layout of the Americas
00:04:49 <shapr> As long as they have capoeira, I'm happy.
00:04:59 <Axman6> ivanm: they're talking about places up north like florida and stuff
00:05:02 <Axman6> >_>
00:05:09 * shapr laughs
00:05:09 <BrokenClockwork1> Axman6: because if it was 1,7 * 10^308 , this would not be about precise floating number, would it?
00:05:14 <ivanm> I thought florida was down south... :s
00:05:15 <Cheshire> shapr in computerology?
00:05:19 <shapr> Axman6: .co is north of you :-)
00:05:27 <shapr> Cheshire: Yeah, computerology.
00:05:35 <Axman6> .co?
00:05:39 <shapr> Cheshire: Because a PhD of athropology wouldn't really excite me.
00:05:44 <ivanm> Axman6: what UK, etc. uses instead of .com
00:05:48 <shapr> Axman6: M-x what-domain co
00:05:48 <Axman6> ivanm: missed the joke? :(
00:05:54 <ivanm> Axman6: possibly ;-)
00:06:10 <ivanm> though when I saw "* shapr laughs", I think I got it ;-)
00:06:29 <shapr> .co is Colombia
00:06:37 <ivanm> ahhhh
00:06:56 <ivanm> Axman6: what are you up to this year? weren't you looking for places to study (or is that next year?) ?
00:07:02 <shapr> Hamilton, ON, Canada is http://maps.google.com/maps?f=q&source=s_q&hl=en&geocode=&q=Hamilton,+ON,+Canada&sll=48.429201,-123.365479&sspn=3.65971,8.448486&ie=UTF8&ll=43.261206,-79.848633&spn=31.303448,67.587891&z=5&iwloc=addr
00:07:15 <Axman6> ivanm: starting second year at ANU tomorrow :)
00:07:27 <ivanm> \o/
00:07:36 <ivanm> what's ANU like? much haskelling?
00:07:37 <shapr> I'd like to attend school in .au for a year or two.
00:07:55 <Axman6> looking forward to COMP2300 this semester, doing things like C and ASM
00:07:59 * ivanm extends an invitation to shapr 
00:08:07 <ivanm> Axman6: *shudder*
00:08:17 <Axman6> ivanm: they do a lot really, i've done haskell and java so far, and as i said, C and ASM (and more java...)
00:08:17 <shapr> ivanm: If you can find me a job, I'll show up.
00:08:21 <ivanm> I think my course code for that kind of garbage was about the same... :s
00:08:27 <mmorrow> preflex: seen SamB
00:08:28 <preflex>  SamB was last seen on #haskell 3 hours, 24 minutes and 25 seconds ago, saying: oh, the identity
00:08:31 <mle> aha
00:08:33 <wli> MArray doesn't mix well with monad transformers.
00:08:34 <ivanm> shapr: heh... at the local supermarket? ;-)
00:08:45 <shapr> ivanm: Um, something that can support my education habit :-)
00:08:48 <Axman6> ivanm: but ben lippmier (or however it's spelt) is from ANU too, the one working on the GHC sparc stuff
00:08:57 <mle> in ref to my wxhaskell question; it's a mac/wx issue; you need to wrap it in a App.app dir
00:09:04 <ivanm> Axman6: I was never formally taught Haskell at UQ, just one semester of scheme (though one assignment was to implement haskell-like pattern matching \o/ ) :(
00:09:18 <shapr> I've not yet had any CS courses.
00:09:26 <ivanm> shapr: hmmm.... not sure what international postgrad costs are like...
00:09:49 <Axman6> shapr: come to Aus, and go to either UNSW or ANU (the cool kids are at ANU >_>)
00:09:53 <mmorrow> @tell SamB i'm digging your lhc haddocks, since i don't have a HEAD haddock atm (and mine still has the "renameDecl" bug), that'd be sweet if there were LHC haddocks (with src links!!) on the lhc website
00:09:53 <lambdabot> Consider it noted.
00:09:54 <shapr> ivanm: I'm quite serious though, if I can find funding in .au, I'll show up and hang for at least a year.
00:10:01 <Axman6> unsw has a lot of haskell stuff from what i can tell though
00:10:09 <Axman6> i mean, dons came from there. nuff said :P
00:10:14 <shapr> Axman6: Ah, but unsw has ChilliX and all his cool NDP stuff.
00:10:34 <ivanm> shapr: well, I'm hoping to get funding to get away from aus for a few years :p
00:10:38 <shapr> Thus my bias.
00:10:39 <Axman6> dunno who that is, but sure, sounds cool :P
00:10:49 <shapr> That would be Manual Chakravarty.
00:10:50 <ivanm> Axman6: so does some macquarie IIRC
00:10:51 <shapr> Manuel
00:10:57 * shapr has had a few too many beers.
00:11:16 <dons> someone should build a fun game with the hipmunk lib, http://www.youtube.com/watch?v=61JRV0dPto0
00:11:48 <erikc> i wanna make a bullet hell shooter sometime
00:12:44 <ivanm> dons: what is this post referring to? http://i44.tinypic.com/2hfp3wk.png
00:13:07 <dons> my deleted post
00:13:16 <ivanm> which was?
00:13:27 <ivanm> or did you delete the entire blog post?
00:13:40 <dons> http://www.cse.unsw.edu.au/~dons/images/notprogramming.png
00:13:50 <dons> nope. i didn't delete it . i think reddit did
00:13:50 <stepcut> reddit sucks
00:13:53 <ivanm> ahhh
00:14:08 <Axman6> http://img301.imageshack.us/img301/7564/c068de69cb7475120c8387eoq1.swf loud. awesome. watch.
00:14:12 <mmorrow> dons: whoa! are those graphics happening in a console!?!
00:14:16 <ivanm> detector-pro is particularly annoying :s
00:14:31 <mmorrow> dons: or is it just drawing to the framebuffer somehow
00:14:38 <stepcut> by the time happstack  0.5 is out, we should have enough supporting libraries to write a non-sucky reddit in a day :)
00:14:40 <dons> mmorrow: in X
00:14:46 <mmorrow> (or is that fullscreened)
00:14:47 <ivanm> Axman6: what am I watching here?
00:14:51 <dons> stepcut: :)
00:14:57 <Axman6> ivanm: who cares!
00:15:00 <dons> stepcut: i have a copy of wash-based reddit
00:15:02 <ivanm> does it actually end up doing anything apart from random zooms?
00:15:05 <Axman6> feel the powah!
00:15:08 <ivanm> or is it "infinite"?
00:15:33 <stepcut> dons: I think the key to avoiding suckiness is to make sure that no one can post ;)
00:15:43 <erikc> http://www.youtube.com/watch?v=v6LxhMJK95s        so awesome
00:15:54 <dons> heh
00:16:28 <ivanm> dons: I'm trying to watch the hipmunk video, but youtube doesn't want to play :s
00:16:46 <pumpkin_> ivanm: same here, had to wait for it all to load
00:16:47 <pumpkin_> then it played it
00:17:02 <ivanm> ahhh
00:17:07 <dons> try reloading it
00:17:08 * ivanm couldn't be bothered waiting
00:17:17 <dons> there was some bug in youtube that i was getting for  thhe last week or so too
00:17:24 <dons> but i'm no longer getting the bug you descrribe
00:17:53 * ivanm wonders if flashblock is interfereing somehow...
00:18:09 <pumpkin_> nope, I don't have it
00:18:14 <pumpkin_> or anything similar :)
00:18:19 <ivanm> OK, youtube just fails... as usual
00:18:53 * stepcut discovered today that he can watch youtube videos on his cell phone
00:19:06 <ivanm> stepcut: and that makes you happy _why_?
00:19:19 <ivanm> dons: what's yaourt?
00:19:23 <stepcut> ivanm: who said I was happy ?
00:19:30 <ivanm> heh
00:19:50 * mmorrow is waiting until someone write a terminal with multiple adjustably-transparent-overlays (with opengl or something) and the ability to print cooler stuff than text
00:19:57 <dons> ivanm: arch package manager
00:20:04 <ivanm> ahhh
00:20:09 <Axman6> thought that was pacman
00:20:12 <Axman6> something change?
00:20:14 <Cheshire> in the meantime, lets abuse HTML
00:20:20 <ivanm> Axman6: yeah, so did I :s
00:20:23 <dons> yaourt builds packages for pacman from source
00:20:36 <ivanm> ahhhhhh
00:20:36 <dons> pacman installs binary equivalents
00:20:45 <ivanm> silly arch users, not able to decide which type of package they want ;-)
00:20:52 <mmorrow> Cheshire: yay ! :) :/ :(((
00:21:04 <dons> yaourts like cabal-install, but uses different config files (and knows about C libs on the system)
00:21:15 <dmead_home> oh god, lisp interpreters are horrible
00:21:19 <Axman6> dons: is it as nice ac pacman?
00:21:19 <dmead_home> someone save me
00:21:26 <Axman6> as*
00:21:31 <dons> Axman6: well, it supports AUR
00:21:36 <Axman6> nice
00:21:40 <ivanm> dmead_home: in what way are they horrible, and how do you want to be saved?
00:21:43 <dons> meaning it can use the 900+ haskell packages i've made
00:21:54 <dons> which is nice, since it finds all the C deps
00:21:59 <Axman6> i still don't have a use for Arch though. OS X gives me everything i need. if i had a small thinkpad, i'd stick it on there
00:22:06 <dmead_home> i find their error messages overly crpytic and not user friendly
00:22:11 <dons> everything except good haskell packages :)
00:22:11 <ivanm> dons: so is it haskell-only, or a standard arch tool?
00:22:16 <dmead_home> and i want someone to do my homework, it magically let me do it in haskell
00:22:17 <dons> standard tool
00:22:21 <dmead_home> *or magically
00:23:04 <mmorrow> dmead_home: and you could could do it while riding a pony-unicorn too!
00:23:15 <mmorrow> :)
00:23:32 <dmead_home> !!!!
00:23:53 * dmead_home puts on his wizard hat and robe
00:24:00 <mmorrow> heh
00:24:12 <david_> is there a good way of calculating the cross product of 2 lists?
00:24:29 <Axman6> sum . zipWith (*)
00:24:36 <mmorrow> , [(x,y)|x <- [0..4], y <- ['a'..'d']]
00:24:37 <lunabot>  [(0,'a'),(0,'b'),(0,'c'),(0,'d'),(1,'a'),(1,'b'),(1,'c'),(1,'d'),(2,'a'),...
00:24:44 <dmead_home> liftM2?
00:24:53 <Cheshire> david_, doesn't make sense
00:25:06 <david_> thanks
00:25:08 <david_> Cheshire: ?
00:25:17 <Cheshire> @go what is cross product
00:25:20 <lambdabot> http://en.wikipedia.org/wiki/Cross_product
00:25:21 <lambdabot> Title: Cross product - Wikipedia, the free encyclopedia
00:25:30 <Axman6> > let dotp = sum . zipWith (*) in dotp [1..10] [2..]
00:25:31 <lambdabot>   Couldn't match expected type `[a]'
00:25:41 <Axman6> wait, crossproduct, my bad
00:25:46 <dmead_home> ?src liftM2
00:25:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:25:54 <dmead_home> try that
00:26:04 <dmead_home> it's polymorphic with it's "cross" operator
00:26:23 <pumpkin_> david_: you mean cartesian product?
00:26:31 <dmead_home> > liftM2 (+) [1..10] [11..20]
00:26:33 <lambdabot>   [12,13,14,15,16,17,18,19,20,21,13,14,15,16,17,18,19,20,21,22,14,15,16,17,18...
00:26:34 <dmead_home> etc
00:26:43 <pumpkin_> or (,) instead of (+)
00:26:50 <dmead_home> > liftM2 (,) [1..10] [11..20]
00:26:51 <david_> yea, got it work thanks
00:26:51 <lambdabot>   [(1,11),(1,12),(1,13),(1,14),(1,15),(1,16),(1,17),(1,18),(1,19),(1,20),(2,1...
00:28:14 <Cheshire> I can't figure out some design issue in this program I am writing
00:28:38 <Axman6> http://eviljaymz.com/files/whypeopleseemtohavefreetime.png
00:30:34 <ivanm> Axman6: nah, can't beat the xkcd "compiling" comic
00:30:52 <Axman6> link? (i'm sure i've seen it, but can't remember it)
00:31:27 <ivanm> @go xkcd compiling
00:31:28 <lambdabot> http://xkcd.com/303/
00:31:28 <lambdabot> Title: xkcd - A Webcomic - Compiling
00:31:33 <ivanm> that's probably it ;-)
00:32:18 <Axman6> :)
00:32:31 <Axman6> love the mouse over :P
00:34:26 <Cheshire> mmorrow, I remember showing you some broken prototype I did... but did I show you the working one? (if not do you want to see it?)
00:35:30 * wli brute-force lifts all the array operations to get a writer monad going.
00:36:00 <mmorrow> Cheshire: i'm not sure which you're talking about, but i'd love to see it
00:36:13 <Cheshire> great
00:36:13 <Cheshire> !
00:36:26 <mmorrow> Cheshire: also, didn't you write a pattern-match compiler at one point?
00:36:46 * mmorrow needs to bang one out with the quickness
00:37:01 <Cheshire> I've written pattern matching in a couple languages
00:37:07 <Cheshire> in various way :p
00:37:16 <pumpkin_> how long have you all been haskelling?
00:37:19 <Cheshire> why?
00:37:35 <ivanm> mmorrow: did you end up looking at my thesis?
00:37:42 <mmorrow> Cheshire: perrfect. do you have any code somewhere for one in haskell for haskell-like patterns?
00:38:02 <Axman6> ivanm: you has a thesis?
00:38:12 * Axman6 thought you were young and cool
00:38:13 <ivanm> yes, for honours
00:38:16 <Cheshire> mmorrow, I'm using [] (Square) to denote proofs and Prf as a modality for proof irrelevence.. http://rafb.net/p/thNyzl35.html , maybe nice to recover a Prop sort like Sheards stuff but that's not my concern atm
00:38:21 <ivanm> I'm not _that_ old :p
00:38:31 <mmorrow> ivanm: i did, super cool. those kind of things could be awesome for groking code fast
00:38:37 <ivanm> yeah
00:39:00 * wli dons the dunce cap.
00:39:27 <mmorrow> Cheshire: looking..
00:39:46 <Cheshire> mmorrow, for patterns theres a couple stabs http://rascal-haskell.googlecode.com/svn/trunk/HOAS.hs & http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=751#a753 -- been thinking about dependent pattern matching recently
00:39:50 * ivanm waits for matthew-_ to approve the graphviz changes to that graphalyze+sourcegraph can be updated
00:40:47 <Cheshire> mmorrow, the bit in my code I'm wondering about at the moment is in the last section: Examples/Toys -- I add inductive types and computational eliminators manually
00:41:14 <mmorrow> Cheshire: wow, that's pretty cool
00:41:21 <Cheshire> mmorrow, so I got this idea about having some kind of data declaration inside the language.. instead of hacked into the compiler :p
00:42:32 <mmorrow> cayenne and pisigma have datatypes that you can just make up dynamically (in a sense). do you mean like that?
00:42:44 <Cheshire> I mean just like haskell   data Foo = ...
00:42:51 <Cheshire> basically I want to implement the equivalent of that
00:42:58 <mmorrow> ohh, i see
00:43:03 <hackage> Uploaded to hackage: RJson 0.3.7
00:43:15 <mmorrow> so you mean instead of how you're doing it there, you want to integrate it into your lang
00:43:19 <mmorrow> i see
00:43:22 <Cheshire> yes
00:43:26 <Cheshire> but I got this other idea too
00:43:55 <Cheshire> these 'elim' constants are basically folds with a bit extra  (and extra expressive types)
00:45:23 <Cheshire> mmorrow, but in theory.. if I showed it is possible to elaborate some function into the eliminators, then perhaps it woul be most sensible to *not* use that compiled version.. instead generate real haskell code that uses case (just like these)
00:45:24 <mmorrow> Cheshire: i really like the way PiSigma does datatypes. it has "finite labels", and "datatype" and defined via function decls
00:45:39 <mmorrow> *..and "datatypes" _are_ defined ...
00:45:47 <Cheshire> actually no idea why I started that with "in theory" because this is in practice
00:46:32 <mmorrow> ah, i see. so you're also looking to map the way you ultimately decide to do this onto haskell as a target?
00:46:58 <Cheshire> well not specifically
00:47:11 <Cheshire> I don't really have any idea what to do or what would work well
00:47:16 <Cheshire> so I thought I would just throw some ideas out :p
00:47:49 <Axman6> > words "thing\nstuff"
00:47:49 <mmorrow> Cheshire: for this interpreter (that i'm almost ready to "release"!:), i'm basically just treating datacons (at the lowest-level) as:
00:47:50 <lambdabot>   ["thing","stuff"]
00:47:55 <mmorrow> (one sec)
00:48:33 <mmorrow> data Con a = Con Tag [a]
00:48:37 <mmorrow> type Tag = Int
00:48:51 <mmorrow> anything that maps onto that..
00:49:03 <mmorrow> *so anything that maps onto that..
00:49:29 <mmorrow> and that's basically how ghc treats them (although ghc also attaches names to them, i'm not)
00:49:47 <mmorrow> (just throwing random info out there)
00:50:10 <mmorrow> but that rep assumes that the source language has already been typechecked/etc
00:50:12 <Cheshire> mmorrow (roughly like http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=330 )
00:50:48 <mmorrow> exactly
00:51:24 <mmorrow> and with `a' in there, you can reuse that rep for expressions, patterns, types, whatever
00:51:30 <Heffalump> david_: use a list comprehension
00:51:37 <Heffalump> oops, talking to scrollback, sorry
00:51:40 <Cheshire> I don't really understand Pi Sigma at all
00:52:14 <Cheshire> e.g. why is it typed?
00:52:24 <mmorrow> Cheshire: i'm not completely clear on the typechecking algo (mostly since there's no code), but
00:52:37 <mmorrow> i guess because it'd be the last level of typing
00:53:22 <ivanm> Heffalump: but does the scrollback respond back? ;-)
00:53:27 <Cheshire> If you imagine something like compiling Pi Sigma into typed assembly language
00:53:34 <mmorrow> for instance, with this interp it'd kindof a pain because the "core" language that i'm using as entrypoint-wrt-language is untyped, so i have no way of preventing
00:53:39 <mmorrow> , 4 12
00:53:40 <lunabot>  luna: No instance for (GHC.Num.Num (t -> a))
00:53:45 <Heffalump> ivanm: not without a time machine
00:54:05 <mmorrow> Cheshire: so a typed core language (from this perspective) would be nice
00:54:06 <Cheshire> my question is:  What would you get out of the language being typed compared to just compiling untyped lambda calculus (with vectors) into?
00:54:49 <mmorrow> Cheshire: because you could write a compiler/interp that *starts* with PiSigma and compiles to whatever
00:55:00 <mmorrow> without having to worry about any particular source lang
00:55:16 <mmorrow> and at the same time knowing that you're compiling code that "makes sense"
00:55:16 <ivanm> dons: so is mkcabal dead?
00:55:20 <Cheshire> I don't think Pi Sigma would be able to take advantage of "Dependent types need not store their indices"
00:55:21 <mmorrow> slash won't segfault
00:55:38 <Cheshire> although edwinb is more likely to know about that than me I guess :D
00:56:06 <mmorrow> Cheshire: from what i understand, any dependently-typed lang would be able to inject into PiSigma
00:56:16 <mmorrow> (but i may be wrong)
00:56:33 <Cheshire> mmorrow, but what about translating into Pi Sigma -after- compiler optimizations on the source language?
00:57:00 <mmorrow> hmm, yeah i see your point
00:57:01 <Cheshire> (for example optimizations that erase proofs)
00:57:02 <mmorrow> i'm not sure
00:57:34 <Cheshire> mmorrow, but I'm thinking about the other way :)
00:58:00 <mmorrow> how do you mean?
00:58:44 <mmorrow> (i'm missing what you mean by other way)
00:59:26 <Cheshire> mmorrow, well I would like to do something like   take some program source code, show that it can be elaborated into the core (just implemented in terms of 'folds'/eliminators) .. and if it can, then represent the program as higher level haskell code for the actual execution
01:00:08 <mmorrow> Cheshire: well, you could always just translate it to haskell where typechecking is "turned off"
01:00:35 <mmorrow> which is cool because you're providing the typesystem..
01:00:39 <Cheshire> well my syntax is not typed
01:00:59 <mmorrow> oh, so you want to use haskell's type system then somehow?
01:01:10 <Cheshire> well haskells type system doesn't get in the way (as usual)
01:01:29 <Cheshire> but if you compare the untyped lambda calculus with vectors code with
01:01:36 <Cheshire> data V
01:01:36 <Cheshire>  = VType
01:01:36 <Cheshire>  | VPi V (V -> V)
01:01:36 <Cheshire>  | ...
01:01:55 <Cheshire> they are basically the same
01:03:36 <deiga> if I have variables nr001 to nr100, is there any way I can get them in a list w/o me typing tem all in list?
01:03:46 <mmorrow> hmm, so to get this straight, you're looking to translate a program into your lang, do some transformations/whatnot on it, then embed the translated code back into haskell?
01:04:00 <Cheshire> deiga, make a function called nr instead that takes an int parameter and  map nr [1..100]
01:04:12 <Cheshire> mmorrow, I think so
01:04:21 <Axman6> deiga: could use template haskell i'm sure
01:04:22 <mmorrow> deiga: that sounds like a perfect application of generating code
01:04:40 <Cheshire> mmorrow, it kind of sucks though (not in a way that matters) because you have to compile everything into haskell ... then recompile the compiler....
01:04:48 <mmorrow> deiga: you could use template-haskell, or just do a quicky one-off generation of the code with Strings
01:04:51 <Cheshire> just to actually use a program you wrote
01:05:14 <mmorrow> heh, yeah
01:05:43 <mmorrow> (by recompile the compiler do you mean because datatypes are currently hardcoded?)
01:05:49 <Cheshire> yes
01:06:13 <Cheshire> but also complex function definitions could be dealt with similarly
01:06:14 <mmorrow> so coming full-circle, you want to represent datatypes in your lang
01:06:28 <mmorrow> hmm
01:06:40 <Cheshire> because all a data type *is*, is a postulation of some variables that have the right type.. and one computation rule
01:07:08 <mmorrow> yeah, they're essentially just tuples with a tag (and possibly a name)
01:07:11 <Cheshire> it's not bits and mortar like in C, in this context they are much closer to the initial algebra sort of thing
01:07:29 <mmorrow> (Int, (a1,....,an))
01:07:53 <Cheshire> well in my case not even tuples and a tagged, literally just:  Cons :: forall a. a -> [a] -> [a]   added to the left of the  |-
01:08:22 <Cheshire> the trick is that an application like   Cons 3 Nil  gets 'stuck' because 'Cons' has no computation rule
01:08:23 <mmorrow> oh yeah, you can rep datatypes as functions too, like how SAPL does it
01:08:52 <bos> @src scanr1
01:08:52 <lambdabot> scanr1 f []     = []
01:08:52 <lambdabot> scanr1 f [x]    = [x]
01:08:52 <lambdabot> scanr1 f (x:xs) = f x q : qs where qs@(q:_) = scanr1 f xs
01:08:53 <Cheshire> well in SAPL Cons has a compution rule
01:09:07 <Cheshire> I mean Cons evaluates into  \x -> \xs -> \e -> e x xs  or whatever
01:09:15 <mmorrow> oh, so you want it to get stuck?
01:09:32 * mmorrow is confused
01:09:38 <Cheshire> mmorrow, that's the current scheme, (which seems to work well, and esp. fits my view of initial algebra)
01:10:38 <Cheshire> mmorrow, well if you implement a dependent type checker, you might not even know you did it -- but you also implemented symbolic calculator (reflexive proofs and so on make use of that)
01:10:42 <mmorrow> so how would you take them apart? like, haskell uses "case", and SAPL uses function app (since cons "do the case themselves")
01:10:55 <Cheshire> (by symbolic calculator I mean stuff like Maxima)
01:11:41 <mmorrow> sure, like as in you have to do some evaluation of the types to reach a conclusion that it's well-typed
01:11:55 <Cheshire> mmorrow, say you have built up the number 3 for example,  it's  S (S (S O))  and represented as a value it's like   VNeutral (NApp (Variable "S") ...)
01:12:13 <Cheshire> so the eliminator just looks for that stuck appplication
01:12:18 <Cheshire> natElim motive zero succ (VNeutral (NFree (Global "Z"))) = zero
01:12:18 <Cheshire> natElim motive zero succ (VNeutral (NApp (NFree (Global "S")) m)) = succ % m % natElim motive zero succ m
01:12:44 <mmorrow> hmm
01:12:55 <Cheshire> so you could add a new thing to the values   | VConstructor Tag [More Crap]
01:13:03 <Cheshire> and pattern match on that and stuff -- but it's not required
01:14:05 <Cheshire> mmorrow, (it seems weird having non-canonical normal forms.. but that's just what happens when you aren't in the closed context, and it causes a lot of trouble for proof irrelevence too)
01:14:57 <mmorrow> Nat : Type.    Nat = tag : {'Z, 'S}; !case tag of {'Z -> [unit] |'S -> [  Nat  ] }.
01:15:10 <mmorrow> is how PiSigma does Nat
01:15:15 <mmorrow> and then:
01:15:21 <mmorrow> zero = 'Z, 'unit.
01:15:28 <mmorrow> succ = \n -> 'S, n.
01:15:39 <Cheshire> I guess that we have   'unit : unit  ?
01:15:48 <mmorrow> oh,
01:15:54 <mmorrow> unit : Type.
01:15:54 <mmorrow> unit = {'unit}.
01:15:59 <Cheshire> ok
01:16:11 <mmorrow> the "!case ... -> [..] | -> [..]
01:16:44 <mmorrow> means inside the [...] the types aren't unfolded during typechecking
01:16:49 <Cheshire> {...} seems like variants from ocaml
01:17:02 <mmorrow> they call them "finite labels"
01:17:22 <mmorrow> and  (x:s);t   is their syntax for sigma types
01:17:52 <mmorrow> and the vals look like  "... , ..."
01:19:01 <mmorrow> so datatypes are modeled as sigma types, where the first elem is a label/tag, and the second the type of said label
01:19:18 <mmorrow> (or something along those lines, i think i butchered it slightly)
01:20:33 <maurer2> Hey, does anyone have any idea how I would go about making a "Parallell" Monad transformer? The idea for what it should do is roughly as follows: It takes a list of any starting parameters for the inner monad (probably a state monad or similar), then execute these in parallel, performing each step synchronously
01:20:38 <Cheshire> no that makes sense
01:20:39 <Xilon> I'm trying to learn Haskell by doing project euler problems. I'm trying to do #3 but the algorithms is too slow (though, as far as I know, sound). Is there any way to make it faster/better? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1518#a1518
01:21:17 <maurer2> The reason I would want this instead of just using mapM is that I also want to write actions that rather than going on an individual inner monad level, allow each inner monad to access the state of other inner monads
01:22:34 <Heffalump> why would a monad transformer be the appropriate abstraction?
01:23:10 <Cheshire> mmorrow, I suppose there's something nice about having a closed theory
01:23:33 <Cheshire> i.e. "new" inductive types just give names to that which already existed
01:24:29 <mmorrow> hmm, i'm not sure but that sounds like it makes sense
01:25:24 <Cheshire> mmorrow, I mean like naming Nat = tag ... it's just putting together parts that Sigma Pi already had, whereas my system you define a new data type and that causes cogs to turn and program code to be derived etc..
01:25:43 <mmorrow> ohhh, yeah totally
01:26:19 <Cheshire> mmorrow, Martin Lofs one is closed too, you could build most anything from just this W type
01:26:23 <mmorrow> it's definitely nice imo to be able to define everything with the same language you use for expressions
01:26:53 <mmorrow> err, clarifying that, for nothing to be "special"
01:28:24 <mmorrow> so yeah, a closed theory
01:28:36 <mmorrow> (i just now realize what you meant by that)
01:29:00 <Cale> Xilon: A number of things... one is that you appear to only be looking for the largest prime factor, but then you're searching for all the divisors and testing each for primality (and you're starting at the large end too...)
01:29:43 <Cale> Xilon: It's better to factor the number into primes by dividing them out as you find them, for one.
01:30:52 <Cale> Xilon: another thing is that your isPrime should make use of the list of primes -- why test all the numbers less than the square root when you only care about the primes?
01:33:31 <Cheshire> actually what is "Core Language"?
01:33:46 <Cheshire> does it mean, not used directly as a programming language
01:34:01 <Cheshire> i.e. equivalent of System F(c)
01:36:57 <CTA> Heyy guys
01:37:43 <CTA> Can I make nintendo DS/DSi games with Haskell?
01:37:55 <mmorrow> Cheshire: exactly
01:37:56 <ivanm> CTA: depends the arch of nintendo DS
01:38:00 <ivanm> what libs you need to use, etc.
01:38:06 <Cale> Xilon: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1518#a1519
01:38:47 <Xilon> Well that's different :D
01:38:52 <CTA> ah kk
01:39:13 <Cale> Xilon: not *that* different though, idea-wise. :)
01:39:29 <Cale> It just avoids wasting some work.
01:39:35 <mmorrow> Cheshire: like as in, the source language stripped of all syntactic sugar and non-relevant-to-typechecking/optimizing/transforming bits
01:39:51 * Cheshire wonders if luqui is thinking about writing an OS in the dependently typed equivalent of System-Fc ....
01:39:52 <CTA> Is it *not* best to do like: lol :: a -> b     when you are doing simple things like..         lol a = a * 2
01:40:03 <Cheshire> combinatory version ..
01:40:07 <CTA> just im sure LYAH said its not good practise I think
01:40:08 <Xilon> Btw what's the difference between the "." and "$" operators? They seem to do the same thing
01:40:31 <Cheshire> Xilon, that's really interesting how did you get that idea?
01:40:41 <Cale> Xilon: (.) is function composition, ($) is function application
01:40:46 <Cale> :t (.)
01:40:47 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
01:40:49 <Cale> :t ($)
01:40:50 <lambdabot> forall a b. (a -> b) -> a -> b
01:40:57 <Cale> f $ x = f x
01:41:06 <Cale> But $ has low precedence
01:41:37 <Cale> Well, perhaps I should say "high" -- it happens after other operators anyway :P
01:41:51 <Cheshire> I like low better
01:41:53 <Cale> (.) on the other hand takes two functions and makes a new function from them
01:42:00 <pumpkin_> how can I get from a GHC.Prim.ByteArray to a Ptr ?
01:42:01 <Cale> (f . g) x = f (g x)
01:42:10 <Axman6> CTA: not good practise to do what?
01:42:15 <CTA> how do I make a function (like '*' a symbol etc? and how would i make it infix without backticks?)
01:42:26 <Gracenotes> > negate . length . show $ 15
01:42:27 <lambdabot>   -2
01:42:43 <Xilon> Hmm, not sure what I did, but I tried both (substituting "$" for ".") and got the same result.
01:42:59 <Gracenotes> > negate $ length $ show $ 15
01:43:00 <lambdabot>   -2
01:43:13 <Cale> Xilon: right, but that's a bit of a trick -- it has to do with the fact that $ is defined as right associative (rather than left associative like it probably should be)
01:43:37 <Gracenotes> > (negate (length (show 15))) --either way, they do this
01:43:38 <lambdabot>   -2
01:43:44 <CTA> Axman, aprently to do lol :: ...   on very simple functions?
01:43:50 <Cale> That is,  f $ g $ h $ x  parses as f $ (g $ (h $ x))
01:44:04 <Cale> But note that g $ h doesn't mean much on its own.
01:44:13 <Axman6> CTA: it's documentation, and a good habbit to get into, but you can leave it off simple functions if you want to
01:44:17 <Xilon> indee
01:44:18 <Xilon> d*
01:44:19 <Cale> for example, filter isPrime $ reverse  would be a type error.
01:44:28 <Cale> But filter isPrime . reverse is fine.
01:44:40 <Cale> So (.) is a nicer operation to use as much as you can.
01:44:52 <CTA> I'm going to do it, Just I'm sure LYAH said it's not good practise idk
01:44:58 <Cale> $ is still convenient for applying that long chain of functions to a value in the end
01:45:06 <Cale> (so you don't need the parens)
01:45:33 <Cale> Xilon: Does that explanation make sense?
01:46:45 <CTA> after I get a good knowledge of Haskell would geting this be a bonus? http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=pd_bxgy_b_text_b
01:47:00 <Heffalump> CTA: yes
01:47:05 <Heffalump> I have it and it's good
01:47:48 <CTA> What does it talk about? Don't just say structures I mean like what are they
01:48:23 <Heffalump> it's about the different things you have to think about when designing data structures for a purely functional world
01:48:27 <Heffalump> where mutation isn't appropriate
01:48:49 * Heffalump looks for his copy to give more detail
01:50:11 <CTA> I don't know much atm, but in Haskell is nearly everything (or everything..) done in functions?
01:50:35 <ivanm> I would say everything is _explicitly_ done in functions
01:50:39 <Cale> CTA: Well, functions are more valuable than in some languages I suppose.
01:50:50 <Cale> There's still plenty of other datatypes.
01:50:50 <ivanm> since in all other languages, you have to use functions/methods/procedures/etc. to do stuff as well ;-)
01:51:17 * dancor does a lot of changing $ to . and wonders if that wastes more refactor time than just leaving the $
01:51:25 <CTA> so that book I posted, would you say I should learn some more first then maybe get a Haskell book then that one?
01:51:41 <Cale> Which book?
01:51:51 <Cale> Oh, Okasaki's?
01:52:10 <Cale> It's supposed to be interesting. You can check out his thesis which is available online to see if you find it interesting.
01:52:17 <Cale> I think the book is an extension of that work.
01:52:18 <dancor> perhaps i can have it both ways with an editor macro..
01:52:43 <CTA> what's online, that book?
01:53:15 <Cale> CTA: Okasaki's thesis was on purely functional data structures and is free. The book is an extended version of that, I think.
01:53:21 <Cale> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
01:53:28 <david_> I hope it's ok to ask beginner questions here?
01:53:38 <Cale> david_: absolutely
01:53:40 <p_l> CTA: Book isn't (officially). Thesis is and it was the beginning of his book
01:54:49 <Cale> david_: That's most of what this channel is for :) You might catch the occasional lecture on category theory or type theory going by here, but don't hesitate to ask about anything.
01:54:50 <david_> ok.. I'm not sure how I can express this in functional languages but I'd like to do a while-loop kind-of-thing
01:55:11 <david_> ehm
01:55:26 <Cale> david_: okay... depending on the purpose the while loop would have served, there are a number of possibilities
01:55:36 <david_> yea, I guess so
01:55:52 <Cale> Often lists are good enough to take the place of loops.
01:56:07 <Cale> and we have functions like takeWhile :)
01:56:22 <Cale> > takeWhile (not . null) . iterate (drop 2) $ "hello there"
01:56:23 <lambdabot>   ["hello there","llo there","o there","there","ere","e"]
01:56:27 * Heffalump finally finds it hiding between two much larger books
01:56:32 <david_> hmm
01:56:35 <CTA> does Haskell have loops, just I thought LYAH said you can't change the value of that thing later, "what, are you some kind of liar?"
01:56:43 <Axman6> CTA: that;s quite fun to read actually :)
01:57:09 <Axman6> CTA: haskell doesn't have looks like for loops. it uses lists usually
01:57:14 <Axman6> or explicit recursion
01:57:26 <david_> I'd like to call a function foo until it returns true and when it does I'd like to get the parameter I passed in to foo
01:57:38 <Cale> ah, okay
01:58:02 <Cale> david_: what parameters do you want to call foo with?
01:58:37 <david_> well, actually it's a list with ints
01:58:51 <Cale> hmmm
01:59:12 <Cale> If you apply a function to the same parameter, you'll always get the same result.
02:00:41 <david_> ah yea
02:00:51 <Cale> > break isUpper "hello There"
02:00:51 <david_> that is true
02:00:52 <lambdabot>   ("hello ","There")
02:01:02 <Cale> > let (xs,y:ys) = break isUpper "hello There" in y
02:01:03 <lambdabot>   'T'
02:01:30 <Raevel> > head $ filter isUpper "hello There"
02:01:31 <lambdabot>   'T'
02:01:48 <Cale> yep :)
02:03:29 <david_> I mean, I'd like to not having to set the upper limit
02:03:41 <Cale> david_: lists can be infinite :)
02:03:54 <david_> hmm, how?
02:03:58 <Cale> > [1..]
02:03:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:04:12 <david_> oh heh
02:04:20 <Axman6> > last [1..]
02:04:28 <lambdabot>   mueval: Prelude.read: no parse
02:04:35 <Axman6> o.O
02:04:40 <ivanm> Axman6: be nice!
02:05:04 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
02:05:05 <ivanm> > last [1..] :: Int -- does it wrap around when it hits maxBound ?
02:05:09 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:05:11 <Cheshire> no
02:05:20 <lambdabot>   thread killed
02:05:20 <Deewiant> > [maxBound-1 ..] :: [Int]
02:05:23 <lambdabot>   [9223372036854775806,9223372036854775807]
02:05:44 <ivanm> heh, it just takes too long to get there ;-)
02:05:52 <Cale> heh, on a 64 bit machine, it takes a while to get to the maxBound for Int :)
02:06:07 <yitz> anyone know what the right precedence is for conal's ~> operator?
02:06:09 <Axman6> > last [1..] :: Int16
02:06:11 <lambdabot>   32767
02:06:14 <ivanm> > drop (maxBound - 3) [1..] :: [Int]
02:06:17 <Axman6> > last [1..] :: Int32
02:06:25 <Cheshire> yitz I thought it was twanvls or someone elsesa
02:06:29 <lambdabot>   thread killed
02:06:30 <ivanm> yitz: Conal?
02:06:31 <ivanm> ;-)
02:06:32 <lambdabot>   thread killed
02:06:53 <ivanm> Int32 == Int on 32-bit machines, right?
02:06:56 <yitz> oh, ok, thought it was conal's. goes with "argument" and "result", right?
02:07:16 <Axman6> ivanm: yeah
02:07:18 <opqdonut> ivanm: yep
02:07:45 <opqdonut> or actually, h98 allows for it to be 30-32 bits
02:07:48 <opqdonut> for tagging purposes
02:07:59 <ivanm> :o
02:08:06 <Cale> david_: A useful idiom is to zip [0..] with a list before doing something like filter or map, if you want to be able to work with the indices of the elements.
02:08:16 <yitz> anyway, what's the precedence supposed to be? is there some standard package it's defined in?
02:08:18 <ivanm> zip++
02:08:26 <ivanm> @hoogle (~>)
02:08:26 <lambdabot> No results found
02:08:32 <Cale> > [x | (n,x) <- zip [0..] "hello there", even n]
02:08:36 <lambdabot>   "hlotee"
02:08:36 <david_> Cale okay
02:09:07 <Cale> david_: In case you feel the need for a for-loop's index ;)
02:09:44 <carl_> why on earth would reads return [(a, String)] and not (a, String), surely theres a reason
02:09:44 <david_> :)
02:09:46 <Cale> david_: Of course, more imperative foreach and while loops are available for arbitrary monads, including IO
02:09:53 <yitz> david_: kind of like python's "enumerate"
02:09:53 <david_> okay
02:09:59 <david_> I see
02:10:22 <Cale> david_: In fact, one of the purposes of the monad abstraction is to make it so that such things can be library functions and reused in different contexts :)
02:10:30 <Axman6> carl_: because if it can't read it, you get [] back
02:10:44 <pumpkin_> did I get kicked off haskell-cafe or has it just been really quiet for the last few hours?
02:11:04 <carl_> ooo k
02:11:05 <Deewiant> carl_: in theory something could be parsed with multiple different results, but I've never seen a Read instance which would do that
02:11:28 <Axman6> > reads "hello there :: [(Integer,String)]
02:11:31 <lambdabot>   <no location info>:
02:11:31 <lambdabot>      lexical error in string/character literal at chara...
02:11:38 <Axman6> > reads "hello there" :: [(Integer,String)]
02:11:40 <lambdabot>   []
02:11:49 <Axman6> > reads "1hello there" :: [(Integer,String)]
02:11:53 <lambdabot>   [(1,"hello there")]
02:12:14 <Deewiant> Axman6: that doesn't give a reason why it uses [] instead of Maybe :-)
02:12:34 <Axman6> Deewiant: but i does give a reason why it doesn't return (a,String) :)
02:12:53 <Axman6> > reads "1 2 3 hello there" :: [(Integer,String)]
02:12:56 <lambdabot>   [(1," 2 3 hello there")]
02:13:00 <Axman6> :\
02:13:20 <ivanm> @src reads
02:13:21 <lambdabot> reads = readsPrec minPrec
02:15:24 <carl_> whats the syntax to do this on one line. getDistsHelper [] = []; | [(a, s)] = a : getDistsHelper (reads s)
02:15:40 <carl_> havent used haskell in a while
02:15:53 <ivanm> carl_: why do you want to do it on one line?
02:15:54 <Deewiant> replace "|" with "getDistsHelper"
02:16:05 <carl_> cause i want to use prelude
02:16:11 <ivanm> OK...
02:16:20 <ivanm> doesn't stop you from having multiple lines...
02:19:07 <Cale> carl_: Is the overall idea to apply reads over and over until an entire string is consumed?
02:19:49 <Cale> (well, so long as it can parse more...)
02:21:00 <wli> Hmm. No convenient functions to chop up arrays.
02:22:30 <ivanm> wli: what are you wanting to do?
02:22:55 <Xilon> Cale: Yeah. Sorry, I was distracted. Thanks for the tips.
02:22:58 <ivanm> probably easiest to convert to list, chop up the list and map makeing an array
02:23:18 <wli> Break up an augmented matrix on which Gauss-Jordan is done.
02:23:35 <ivanm> :/
02:24:15 <Raevel> hmm when i do "cabal upgrade base" i get "No packages to be installed. All the requested packages are already installed.", did i do it wrong?
02:24:28 <ivanm> Raevel: base is part of ghc
02:24:35 <wli> It wouldn't be all that big a deal to do it at the low level.
02:24:38 <Raevel> ah
02:24:40 <ivanm> you shouldn't (in fact, you can't) updtae it manually
02:24:51 <wli> You could share the original storage even.
02:25:07 <Raevel> so, what version of ghc is base 4.0.0.0 ?
02:25:19 <Saizan> 6.10.1
02:25:37 * yitz tries infixr 1 ~>
02:26:01 <Raevel> oh... i still don't have 6.10 on this box
02:26:16 <ivanm> heh
02:27:11 <Raevel> someone should put it in the ubuntu repo :-( or perhaps i should switch to arch
02:27:21 <ivanm> or gentoo! ;-)
02:27:24 <Cale> carl_: In any event, something like: f [] = [[]]; f x = [v:vs | (v,s) <- reads x, vs <- f s]  would handle the possible nondeterminism from reads a little more cleanly (compose with concat . take 1 to get what you're probably more interested in). But I don't think there's a particularly nice inline way of writing this... there's undoubtedly something a little strange involving fix :)
02:42:10 <Axman6> are there any easy ways to serialise data out to disk? i know you can use show and read it back in later, but that seems hackish to me
02:42:39 <Heffalump> Data.Binary?
02:43:13 * Axman6 checks it out
02:44:26 <p_l> Axman6: I'd say that show and read are less hackish...
02:46:17 <Axman6> Data.binary seems very nice actually
02:46:20 <Axman6> B*
02:46:33 <ivanm> anyone know who the digest dev is?
02:47:20 <Saizan> the horrible part about Binary is that Get has no error reporting facility
02:47:54 <Axman6> :\
02:49:04 <Saizan> fsvo horrible, off course
02:49:35 <redditbot> Why is this expert written code taking up 42 times more memory than the Java version?!
02:58:32 <Axman6> hmm, Data.Binary looks quite cool
03:00:53 <ivanm> redditbot: because
03:00:56 <ivanm> next question? :p
03:02:39 <pao> @unmtl StateT s (StateT t m) a
03:02:39 <lambdabot> s -> t -> m (a, s, t)
03:08:12 <pk> hey
03:09:02 <pk> I'm currently using glut + hipmunk, and I get very slow physics updates
03:09:11 <pk> now, if I use a print in the loop
03:09:21 <pk> I get the normal behavior
03:09:33 <opqdonut> normal as in fast?
03:09:36 <pk> yep
03:09:40 <opqdonut> you're being too lazy, then
03:09:56 <ivanm> awwww..... you actually expect us to do _work_? :(
03:09:57 <ivanm> ;-)
03:10:00 <pk> some unsafeInterleaveIO ?
03:10:07 <opqdonut> probably not
03:10:30 <opqdonut> changing a foldl to a foldl' or an accumulating parameter to a strict one usually works
03:10:34 * b_jonas shudders as he hears the u-word
03:10:37 <opqdonut> hard to say withoutseeing the code
03:11:17 <ivanm> > cycle "unsafe " -- for b_jonas
03:11:19 <lambdabot>   "unsafe unsafe unsafe unsafe unsafe unsafe unsafe unsafe unsafe unsafe unsa...
03:11:30 <pk> I didn't use any unsafe code
03:11:32 <ivanm> ;-)
03:11:45 <pk> of course I can't debug anything
03:11:51 <opqdonut> > 'u' : cycle "nsafePerformU"
03:11:52 <lambdabot>   "unsafePerformUnsafePerformUnsafePerformUnsafePerformUnsafePerformUnsafePer...
03:12:08 <Xilon> We are no longer the knights who say "nip!". We are not the knights who say "unsafe!"
03:12:10 <pk> each time I try to print a value everything 's fine
03:12:12 <Xilon> now*
03:12:14 <ivanm> opqdonut: lol
03:12:22 <ivanm> Xilon: *ni ;-)
03:12:28 <opqdonut> pk: could you paste the loop in question somewhere?
03:12:48 <cnwdup> Is there a good reason, bracket is of type IO a -> … instead of m a -> … (possibly with type constraints)?
03:12:57 <pk> you want the whole glut loop ?
03:12:59 <b_jonas> pk: well, if you're calling print, then you can deeply evaluate whatever you'd print without actually printing it as well
03:13:08 <pk> but I print "lal"
03:13:12 <opqdonut> :D
03:13:45 <opqdonut> pk: and the loop is wholly in IO?
03:13:49 <pk> yep
03:14:17 <Xilon> print "lal" is an optimisation in Haskell? Awesomeness
03:14:44 <ivanm> time for seq?
03:14:47 <pk> I'm want my name on this one
03:15:34 <pk> wait
03:15:40 <pk> I think I got it
03:15:46 <ivanm> rainmann: where are you bringing rain to?
03:16:07 <rainmann> Sydney!
03:16:12 <Xilon> Is there anything Haskell is particularly _not_ good at?
03:16:24 <trygvis> sucking
03:16:30 <ivanm> rainmann: don't send any up north, we've just had some and cairns, etc. has had _way_ too much ;-)
03:16:41 <opqdonut> pk: pray tell?
03:16:41 <ivanm> Xilon: low-level drivers, etc. maybe
03:17:05 <Saizan> pk: are you compiling with -threaded ?
03:17:11 <ivanm> Xilon: possibly mission-critical stuff, because you never know when garbage collection will come into effect
03:17:29 <pk> replicateM_ nStep (step (simSpace bot) timeStep) >> upfunc) --that needs a print to work
03:17:50 <pk> replicateM_ nStep (step (simSpace bot) timeStep) -- works without problems
03:18:11 <b_jonas> @faq Is there anything Haskell is particularly _not_ good at?
03:18:11 <lambdabot> The answer is: Yes! Haskell can do that.
03:18:11 <opqdonut> pk: how should the parenthesis go in the first version?
03:18:53 <b_jonas> that might be a godelian question: you can prove that there's something haskell is particularly not good at, but you can't prove that haskell is not good in any particular thing.
03:18:54 <pk> replicateM_ nStep (step  >> upfunc) --that needs a print to work
03:19:12 <opqdonut> pk: printing the result of step, you mean?
03:19:16 <pk> no
03:19:20 <pk> printing anythin
03:19:26 <pk> print "" works
03:19:31 <b_jonas> wha?
03:19:32 <opqdonut> between step and upfunc or where?
03:19:49 <pk> anywhere in the glut loop
03:19:56 <opqdonut> wow
03:20:20 <opqdonut> so i guess this is what one would call a time leak
03:20:30 <opqdonut> one of the things functional reactive programming aims to solve
03:20:45 <opqdonut> i think you might want to post the code on haskell-cafe
03:21:12 <pk> Is there an easy way to have a physic engine with FRP ?
03:21:15 <gaze> how would I get a "handle" from an "IO handle"?
03:21:35 <Axman6> h <- thingGivingIOHandle
03:21:40 <Axman6> in a do block
03:21:41 <asgaroth> gaze: you don't. everything you continue to do with that, has to stay in the IO monad.
03:22:00 <opqdonut> pk: probably, but i haven't heard of an implementation
03:22:03 <gaze> hmm, that's what I was afraid of...
03:22:20 <asgaroth> >>= gives you a way to access it, but the passed function has to be monadic in its result as well
03:22:45 <asgaroth> there's also unsafePerformIO, but you don't want to use that.
03:23:03 <Axman6> indeed
03:23:54 <ivanm> asgaroth: not if he wants to keep his sanity, anyway...
03:24:56 <pk> it's working now !
03:25:09 <b_jonas> pk: what did you do?
03:25:20 <pk> parentheses problem
03:25:31 <pk> honestly I don't get it
03:37:17 <Furious_Joe> what does the "qualified" keyword do?
03:38:28 <Zao> It gives an import a friendlier name.
03:38:42 <b_jonas> no, that's "as".
03:39:02 <b_jonas> "qualified" makes haskell not let you access the imported names without a dotted qualifier
03:39:03 <Zao> Erm, it puts things under the module name instead of putting it in global scope.
03:39:13 <Axman6> if you have import qualified Data.Map, when ever you use a function from Data.Map, you need to use Data.Map.funcName, not just funcName
03:39:14 <b_jonas> so they don't shadow simple undotted names
03:39:27 <Furious_Joe> ok, thanks
03:39:49 <Xilon> Why is it like that and not the other way around? I've heard a lot of people criticize Haskell for it.
03:40:23 <Axman6> Xilon: for what?
03:40:32 <Axman6> and what other way around?
03:40:39 <Furious_Joe> Xilon: It's to prevent naming conflicts, so you can force your map function to be my.map
03:40:44 <Xilon> Have qualified as opposed to unqualified
03:41:08 <Xilon> I.e., importing into the global scope by default
03:41:22 <Axman6> Xilon: you want to by typing Prelude.putStrLn, Prelude.null, Prelude.map all the time?
03:41:37 <Xilon> Axman6: No, there's "as"
03:41:49 * Axman6 is confused and going to bed
03:42:01 <Furious_Joe> Axman6: then prelude would be called P for brevity, and haskell would look like java
03:42:07 <Xilon> You could also have import Prelude (*) or something
03:42:19 <b_jonas> well, it would be useful if "as" implied "qualified"
03:42:31 <b_jonas> (you could still write two imports if you don't like that)
03:42:31 <Xilon> or just import unqualified Prelude
03:43:01 * b_jonas reads the basics of haddock from http://www.haskell.org/haddock/doc/html/markup.html
03:43:19 <b_jonas> meanwhile in another thread /me wonders if he should try asking his question about ghc again
03:43:45 * Xilon wishes all languages had docstrings
03:43:59 <Furious_Joe> b_jonas: I use funnelweb, like haddock but generalized for any programming language, and it does (la)tex output
03:44:24 <Xilon> Although docstrings for haskell might be weird
03:45:01 <Axman6> Xilon: i think the idea of having to use th full dotted name by default is silly personally :\
03:45:07 <Axman6> makes the code cluttered and ugly
03:45:26 <Xilon> Axman6: Maybe, but it also makes it more readable and prevents name collision
03:45:40 <Axman6> how does it make it more readable?
03:45:50 <Xilon> You know where stuff comes from
03:45:55 <Xilon> easier to read documentation for it
03:46:14 <Furious_Joe> although as compilers go, ghc is pretty clever. I'm sure that it would stop collisions
03:46:26 <Axman6> well, that's the point of having specific import lists. like import Data.Map (toList, fromList)
03:46:27 <Xilon> if you have foo in Bar and Baz, and you import Baz, how would you know it's not from Bar without looking?
03:46:54 <Xilon> especially with import Bar hidden (foo) and import Baz :P
03:46:56 <Zao> Xilon: Most sane people tend to put exports lists in their modules, so things don't leak.
03:47:17 <Axman6> anyway, naming conflicts are something to be avoided anyway. they're the problem, not the other part
03:47:33 <b_jonas> Zao: that would be great if only ghci would have a way to access the not exported names as well for debugging
03:47:47 <Xilon> Axman6: Not if there are two completely unrelated modules with common names
03:47:54 <b_jonas> though you could solve that by putting the implementation in an internal module and reexporting only the public names from another module
03:48:39 <Furious_Joe> Xilon: I'm using a module like that, Data.ByteString, and they recomend on the do page to do a qualified import, which is why I asked
03:48:39 <ChilliX> The common case is that names do *not* clash.  Haskell optimises for the common case.
03:49:01 <Furious_Joe> s/do/doc
03:49:08 <Axman6> Xilon: haskell is about writing beautiful code. Data.Foo.Bar.func (Control.Baz.Type (x :: Text.Lame.Whatsit)) is not beautiful ;)
03:49:27 <Axman6> ChilliX: i heard earlier you're at UNSW?
03:49:55 <Xilon> Axman6: I suppose that's a good point. There are more "inline" function calls in Haskell than imperative languages
03:50:06 <Axman6> yes
03:50:16 <Axman6> it makes more sense in things like Java than haskell
03:50:25 <ChilliX> Axman6: that's right
03:50:44 <Axman6> ChilliX: well G'day then :) it's nice seeing other aussies here
03:50:54 <ChilliX> :)
03:51:10 <Axman6> (or G'night even, going to bed in a sec, first day of second year at ANU tomorrow)
03:51:11 <ChilliX> where are you?
03:51:12 <Furious_Joe> I'm at UNSW to. Do I know you? im Richard/RiRi IRL
03:51:37 <jpcooper> does anyone have experience with Gtk2HS?
03:51:40 <Axman6> Furious_Joe: from what i hear, ChilliX is more likelt to be lecturering you than to be in one of your courses :P)
03:51:54 <jpcooper> onClicked closeButton $ do
03:51:54 <jpcooper>         widgetDestroy window
03:52:01 <jpcooper> I'd like to know whether the do is really needed
03:52:11 <Axman6> jpcooper: nope
03:52:12 <b_jonas> couldn't we just say that both qualified and unqualified imports have very good use cases, which is why haskell offers both?
03:52:19 <jpcooper> okay
03:52:28 <Furious_Joe> I'll look for ``chilliX'' on my timetable
03:52:40 <ChilliX> Axman6: at anu? doing Haskell stuff there?
03:52:44 <Axman6> has nothing to do with Gtk2Hs btw, it's just how monads work
03:52:50 <ChilliX> Furious_Joe: lol
03:53:12 <ChilliX> http://www.cse.unsw.edu.au/~chak/
03:53:12 <Axman6> ChilliX: well, not this semester. but first semester we were taught haskell by clem baker finch, and that's what got me hooked :)
03:53:29 <ChilliX> Axman6: ah, cool
03:53:30 <Axman6> ah, i think i've read some of your stuff actually
03:53:56 <ChilliX> I hope you liked it ;)
03:54:10 <Axman6> ChilliX: reckon OpenCL will be useful for the DPH stuff you've done?
03:54:49 <ChilliX> Axman6: we are also working on targetting GPUs, at the moment independent of DPH: http://www.cse.unsw.edu.au/~chak/papers/LCGK09.html
03:55:03 <ChilliX> but the idea is to eventually make it into an alternative backend for DPH
03:55:13 <Furious_Joe> for comp1927 we had to write an interpreter for ``FLAN'' functional language, but pretty mutch simplified haskell.
03:55:39 <Axman6> seems you're interested in the sorts of areas i am, so i've read quite a fe3w things actually :P
03:55:39 <ChilliX> the tricky bit is that DPH allows arbitrary Haskell in parallel computations, but the capabilities of GPUs are still pretty restricted (eg, no function pointers)
03:55:55 <ChilliX> Furious_Joe: with RichardB?
03:56:16 <Furious_Joe> no, but I did 1917 with him. Great teacher.
03:56:30 <ChilliX> yeah
03:56:35 <ChilliX> who did 1927?
03:57:00 <Heffalump> do these numbers refer to the year the subject matter was invented? :-)
03:57:08 <ChilliX> Heffalump: lol - and Hi :)
03:57:34 <Axman6> ChilliX: any reason for the owl?
03:57:40 <Furious_Joe> I can't remember his name. He had very long hair, was a databases pro and always wore those hippie blended-color t shirts
03:58:26 <ChilliX> Axman6: not really, need to redo some of my web pages, but there so many of these stupid static paper web pages and I can't be bothered to enter all the data into a database and serve it properly
03:58:34 <Axman6> ChilliX: oh, didn't realise how recent that paper was, nice
03:58:35 <ChilliX> Furious_Joe: jas
03:58:54 <Furious_Joe> that's it
03:59:29 <b_jonas> lol, "http://www.haskell.org/haddock/doc/html/ch03s08.html" says "The following characters have special meanings" then lists some characters, then "To insert a literal occurrence of one of these special characters, precede it with a backslash"
03:59:29 <ChilliX> Furious_Joe: btw, my research group always looks for students who are interested to do haskell stuff for their honours project etc - just so you know ;)
03:59:36 <b_jonas> but it does not list backslash as special in first place
03:59:46 <Heffalump> hi ChilliX
04:00:36 <b_jonas> and then promptly mentions how the ampersand is special too
04:00:49 <Axman6> i wish there was more Haskell stuff going on at ANU, the only thing i can think of is ben L's GHC Sparc stuff
04:01:10 <Furious_Joe> thanks, I started writing a server for a router, to limit 25G of bandwidth between my sibblings in haskell, and realized how easy and fast it is. Before I'd only done baby learning programs
04:01:28 <ChilliX> Axman6: yeah, but Ben did Haskell before the sparc project, too
04:01:37 <ChilliX> Axman6: clem does FP stuff, too
04:01:52 <Axman6> yeah, i think we used their stuff for out first assignment, ANUPlot
04:02:21 <Axman6> yeah, clem's done some interesting work too
04:02:41 <ChilliX> To be honest, at UNSW, my group is the only real hardcore FP/Haskell group, too
04:03:04 <ChilliX> It's just that we are very loud and convince other people to use it, too ;)
04:03:14 <Axman6> maybe one day i'll end up there with the rest of you ;)
04:03:14 <ChilliX> like our operating system guys
04:03:51 <Axman6> it's looking like a lot of my future study will be using java and C though :\
04:04:21 <Axman6> anyway, must get to bed. good talking to you :)
04:04:33 <ChilliX> Axman6: this is just so that you know what you got when you are using Haskell ;)
04:04:39 <ChilliX> Axman6: 'nite
04:05:00 <Furious_Joe> bye
04:05:11 <Axman6> ChilliX: heh, yeah. i'm looking forward to the C (and ASM) stuff this semester though. won't be pretty, but i'll learn a lot
04:05:36 <p_l> C is better than Java when it comes to learning...
04:05:37 <ChilliX> Axman6: yeah, it's good to know the machine, too
04:05:48 <chaoslynx> what do i have to do to convince haskell that n*(n+1)/2 is an Integer if n is an Integer
04:05:58 <Axman6> p_l: yeah. though java can be quite productive
04:06:09 <ChilliX> chaoslynx: use div instead of /
04:06:23 <Axman6> ChilliX: / doesn't work in integral values
04:06:33 <p_l> Axman6: I was tainted by more productive languages. Can't force myself to Java now...
04:06:39 <Axman6> uh, chaoslynx even
04:06:47 <Axman6> p_l: heh :)
04:07:15 <Axman6> i think the java stuff is there to turn me into a nice little code monkey and learn how to write big projects
04:07:19 <p_l> Axman6: Unfortunately University uses Java for teaching (haskell appears in 4th year, somewhere along you get C)
04:07:23 <Furious_Joe> p_l: I do haskell, C and ARM asm. Although I have to learn java soon :(
04:07:45 <Axman6> Furious_Joe: you liking haskell?
04:08:10 <chaoslynx> ChilliX, thx i forgot about that
04:08:18 <Furious_Joe> yes. the idea is to write code for microcontrolers in C and Asm, and haskell for all app programming
04:08:20 <Xilon> Furious_Joe: I hope uni in the eastern states is better than in the western *Sigh*
04:08:22 <ChilliX> chaoslynx: sure :)
04:08:41 <Axman6> Xilon: we're all in Aus
04:08:57 <Xilon> Yeah, me to :P
04:09:05 <Axman6> ah, righto :)
04:09:08 <Axman6> perth then?
04:09:14 <Xilon> indeed
04:09:21 <Xilon> Isolated City
04:09:30 <Furious_Joe> what's so bad about western unis? Pascal?
04:09:50 <Xilon> Furious_Joe: Besides not learning anything and paying thousands? Nothing, it's all good fun.
04:09:56 <ChilliX> Furious_Joe: lol @ Pascal
04:10:04 <Cheshire> how would you generate haskell source to print out as a textfile?
04:10:06 <Axman6> i did pascal and forth in high school
04:10:08 <Cheshire> is Language.Haskell.Pretty the best thing?
04:10:21 <Axman6> programmed robots with it :)
04:10:28 <Xilon> I did Pascal and Java in HS
04:10:29 <Axman6> ayway, really must be off to bed. night all
04:10:31 <p_l> Furious_Joe: Believe me, Java is worse than Pascal.
04:10:33 <Xilon> The more Java at uni
04:10:40 <Furious_Joe> Axman6: Forth is pretty hardcore
04:10:42 <Xilon> Then*
04:10:51 <ChilliX> Axman6: forth is not bad, kind of rewires your brain, too
04:11:03 <Axman6> didn't do enough forth to learn it though
04:11:09 <ChilliX> p_l: yeah, I would actually agree with that statement
04:11:13 <p_l> Any language that doesn't change the way you think is not worth learning
04:11:18 <Furious_Joe> I'll do java for the course, then try to forget it
04:11:31 <Furious_Joe> p_l: I agree
04:12:00 <Xilon> p_l: Java can make the happiest person want to commit suicide. Is that good enough?
04:12:14 <p_l> I'll admit that I don't really know Java. Doesn't stop me for getting 20/20 from all java assignments, thanks to a bad case of "it's not different at all from n other languages"
04:12:18 <Cheshire> p_l, nice catch phrase
04:13:01 <p_l> Cheshire: The one about changing the way you think? It's an old one, but I found it very true, even with my little amount of experience
04:13:22 <Xilon> So far I've been able to pick up most languages fairly easily. Even haskell wasn't too hard (only started a couple days ago), it's just the immutability that's different.
04:13:34 <Xilon> A function is a function...
04:14:11 <Cheshire> afaict Language.Haskell.Pretty is probably the only thing
04:14:13 <Furious_Joe> Xilon: once youv'e done a few, the rest become really easy
04:14:19 <Axman6> fucking huntsman in my room
04:14:41 <Xilon> Furious_Joe: Indeed. If you do C, you know a lot straight away.
04:14:59 <Xilon> Lisp and Python helped me learn the functional idioms a bit
04:15:38 * Axman6 goes to sleep finally
04:15:57 <p_l> Reading a lot of old programming books is also an interesting exercise, cause they don't assume tons of memory, powerful CPU and nice GUI to guide you step by step
04:16:21 <Xilon> Haskell seems to be very fun though. Not really because of how concise and short the code is, but more because it's a challenge and a (as far as I know, better) different way of thinking
04:16:50 <Axman6> Xilon: wait until you get to the concurrency stuff, then you'll be having fun :)
04:17:05 * Axman6 goes off to read C book then sleep
04:17:06 <Furious_Joe> You'll miss the nice lists and pattern matching when you switch to another one
04:17:09 <Xilon> It seems like Haskell is ver friendly towards concurrent programming
04:17:12 <p_l> nah, concurrency is really fun in Erlang :-)
04:17:15 <gaze> it's not always necessarily better. It's different for sure, great for turning your brain inside out and making you see computer programs differently
04:17:22 <gaze> oh concurrency is a blast in haskell for sure
04:17:25 <Xilon> Furious_Joe: Pattern matching is my favorite feature so far :D
04:17:34 <p_l> gaze the end result might be a better way of thinking :)
04:17:37 <Xilon> Lists seem to be pretty much the same as in python/lisp
04:17:51 <gaze> yeah and since it's done with radix trees with strings you can go wicked fast
04:18:05 <Xilon> cool
04:18:43 <Xilon> I haven't really done concurrent programming yet. I've been meaning to learn for a while, but I don't want to get into threads. I just know there's a better way.
04:18:57 <gaze> threads aren't the worst thing...
04:19:00 <Xilon> At the very least Haskell will help me write reentrant functions in other languages
04:19:25 <Xilon> But then there's I/O. Oh how I hate I/O :(
04:19:42 <gaze> xilon: Not necessarily, it'll keep you thinking of the right things but there's weird gotchas that you'll miss if you don't really focus on them in other languages
04:19:57 <gaze> in other words, you don't have to learn to avoid the issues because you never see them in haskell
04:20:34 <Xilon> That's always a good thing (when using Haskell)
04:20:51 <gaze> yeah
04:21:29 <Xilon> Io seems to have a nice idea about concurrent programming, but I haven't read into it. You basically call functions asynchronously and they get put in a queue.
04:21:59 <Furious_Joe> does haskell have any timer-interupt stuff? Extreemly un-haskell, but the alternative is a recursive loop checking thing, extreemly un-efficient.
04:22:15 <Cheshire> heh un-efficient
04:22:21 <Xilon> inefficient*
04:22:29 <gaze> I can't think about a possible way to implement that functionally
04:22:40 <Cheshire> Xilon, I thought it was intentional
04:22:53 <Xilon> I hope so :P
04:23:14 <Furious_Joe> gaze: your probably right, all it needs to be is an alarm, so I can wait a while, then start up again, unless something happens in the meantime
04:23:33 <Cheshire> I am such a timer waster :/ even now I am writing about it instead of writing the program
04:23:34 <Furious_Joe> intentional, un-haskell/un-efficient
04:23:52 <gaze> oh that's right... haskell does have a way to catch signals (sighup, etc.) so you must be able to catch a SIGALRM
04:23:57 <ChilliX> Furious_Joe: you can use signals: http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Signals.html
04:24:14 <Furious_Joe> thanks
04:24:57 <ChilliX> Furious_Joe: people have written operating systems in Haskell
04:25:02 <dcoutts> Furious_Joe: how about forking a thread and just having it wait for a timeout? would that be enough? That's more Haskelly.
04:25:29 <p_l> Xilon: you can use shared-nothing multiprocessing
04:25:48 <p_l> Xilon: In haskell you have it easier by using immutable data
04:25:50 <Furious_Joe> dcoutts: that might actually work, and it is much nicer
04:26:17 <Xilon> p_l: Yeah, the whole mindset should make multiprocessing "simpler"
04:26:27 <dcoutts> Furious_Joe: it should also be just as efficient (seeing how signal handlers are run in fresh Haskell threads anyway)
04:26:28 <p_l> Xilon: That's the way it's done in Erlang
04:26:34 <Xilon> I still can't really get my heard around it though :P
04:26:38 <Furious_Joe> I looked at the house OS a while ago, I should take a look at the code though
04:26:44 <Xilon> head*
04:26:51 <gaze> yeah the scheduler is based on polling so that'd be really nice
04:26:53 <p_l> Xilon: Mind you, using >10k threads in Erlang is normal, not exceptional :)
04:26:59 <dcoutts> Furious_Joe: but more importantly it's much more modular than posix signals which are notorious for their non-modularity
04:27:01 <Xilon> :|
04:27:13 <gaze> they're not threads though
04:27:17 <Xilon> How would 10k threads improve performance rather than hinder?
04:27:26 <Xilon> Green threads?
04:27:34 <dcoutts> ChilliX: if the answer is unix signals, the question is usually wrong :-)
04:27:36 <Furious_Joe> dcoutts: I thought about it some more, and that will work fine, thanks
04:27:46 <gaze> I guess? Like... are you familiar with poll()?
04:27:48 <ChilliX> dcoutts: :P
04:27:49 <gaze> or select or all those
04:27:54 <p_l> Xilon: NxM threading (i.e. M green threads mapped onto N hardware threads)
04:28:41 <p_l> posix threading theoretically allows it, but operating systems that had tried it gave up
04:28:42 <gaze> instead of having actual threads, you have a gigantic file descriptor driven state machine
04:28:46 <ChilliX> dcoutts: but I agree that in this case, using Control.Concurrent is better
04:29:07 <ChilliX> just let JafaCake deal with the dirty stuff in the rts ;)
04:29:09 <mmorrow> gaze: that should be pretty easy to do with System.Posix.{Types,Process,Signals} and Control.Concurrent (although Control.Concurrent isn't strictly necessary i guess)
04:29:11 <Xilon> gaze: Interesting. I much prefer select() than threading
04:29:24 <gaze> well yeah. Threading has huge overhead
04:29:24 <Xilon> but then that isn't really multiprocessing (what I've used it for) :P
04:29:51 <dcoutts> ChilliX: actually the new signals api that JafaCake and I worked on should make many uses of signals less nasty. It allows multiple handlers to be added/removed independently.
04:29:55 <gaze> it's funky that if you create enough threads the OS will just run out of memory for the stacks
04:30:03 <mmorrow> dcoutts: ooh, cool
04:30:21 <dcoutts> ChilliX: not suitable for error handling but fine for things like poking servers to update themselves
04:30:25 <ChilliX> dcoutts: except that it borked my macosx compile ;)
04:30:31 <gaze> and on linux anyhow, thread == process - VM... threads are pids in the kernel, processes are tgids (thread group ids)
04:30:35 <p_l> Xilon: multiprocessing in Erlang usually means that you have as many OS processes as you have processing units, and then you map green threads onto them. Oh, and the application as a whole might span multiple machines
04:31:02 <dcoutts> ChilliX: heh
04:31:07 <ChilliX> dcoutts: yeah, when you actually do unix'y things outside of the process, then you do want signals
04:31:30 <p_l> Unix could use event flags or better asynchronous mechanisms....
04:31:42 <gaze> poll driven programs don't incur the overhead... you just copy the filedescriptor state straight out of the kernel for some bulk number of file descriptors
04:31:43 <dcoutts> but some people want to block signals or attach cleanup handlers to signals, and that's rarely a sensible thing
04:31:48 <ChilliX> dcoutts: well, after the signal patch landed, the stage2 compiler segfaulted on macosx
04:32:09 <dcoutts> ChilliX: doesn't validation catch that then?
04:32:17 <ChilliX> dcoutts: and it is very hard to get right
04:32:20 <Xilon> I should read up on that, seems like a great alternative
04:32:24 <mmorrow> just catch SIGSEGV with teh new api!
04:32:30 <ChilliX> dcoutts: there are a million possible races when you use signals
04:32:53 <gaze> hahaha... read up on async signal safety
04:32:55 <gaze> it's a riot
04:33:10 <gaze> it's like thread safe only you can't get unblocked by someone else
04:33:13 <ChilliX> I had a nice assignent for my Distributed Systems course where the students had to implement a virtual shared memory library on a linux cluster using signals, sockets, and mmap()/mprotect()
04:33:15 <dcoutts> ChilliX: aye, at least it only has to be done properly once in the rts
04:33:16 <gaze> so it sucks twice as hard
04:33:31 <p_l> gaze: threading is a kind of strapped on Unix using duct tape and spit
04:33:35 <Xilon> ouch :P
04:33:38 <dcoutts> ChilliX: you're cruel :-)
04:33:41 <ChilliX> dcoutts: re validation, well if you validate on the all archs, yes
04:33:43 <mmorrow> ChilliX: oh, that sounds like an interesting task
04:33:46 <ChilliX> dcoutts: hehehe
04:34:00 <gaze> ohhhh would you mprotect some large chunk of memory, wait for the segfaults, and copy over the network?
04:34:11 <gaze> and restart
04:34:13 <gaze> that's cool
04:34:19 <b_jonas> ChilliX: I once thought of that, but I can't think of a way to collect the access statistics as efficently as the kernel can from the page table access bits
04:34:25 <mmorrow> you'd have to longjmp out of the handler if you're catching a SIGSEGV
04:34:42 <ChilliX> gaze: yep
04:34:57 <gaze> I know valgrind restarts out of SIGINVLs... when it tries to do some probing on PPC
04:34:59 <mmorrow> that's super cool
04:35:04 <gaze> and doesn't need a longjmp
04:35:09 <cnwdup> Is there a version of catch which works in any monad built on top of IO?
04:35:16 <gaze> why's sigsegv different?
04:35:33 <mmorrow> hmm, iirc you can't return or else
04:35:46 <mmorrow> well, i guess you could "fix the problem" somehow
04:35:50 <b_jonas> mmorrow: you can I think, if you handle the particular pagefault
04:35:53 <mmorrow> but i don't know how
04:35:53 <ChilliX> why do you want to longjmp out of the handler?
04:36:02 <mmorrow> ah, yeah that's true
04:36:03 <gaze> fouled return stack?
04:36:26 <b_jonas> mmorrow: you just find out (from the sigaction interface) what fault happened, and map the correct data there
04:36:28 <mmorrow> ChilliX: i wasn't counting on being able to fix the fault
04:36:36 <b_jonas> (or call the previous segv handler if you can't fix it)
04:36:47 <ChilliX> mmorrow: you can have the faulting instruction retryed
04:37:00 <gaze> the PC doesn't jump ahead after a page fault
04:37:03 <ChilliX> check out the man page of sigaction()
04:37:11 <mmorrow> sweet
04:37:27 * mmorrow is actually doing something currently where this is a somewhat issue
04:37:59 <ChilliX> tricky is to find out whether it was a read or write fault (and they had to implement a multiple-reader/single-writer strategy)
04:38:19 <ChilliX> (not really tricky, but trickier)
04:38:20 <b_jonas> ChilliX: it could be both
04:38:22 <mmorrow> hmm
04:38:29 <p_l> hmmm.... since we actually had gone down to low-level details of signals... is it possible that a rogue signal ends trashing the stack and making a jump into hyperspace (i.e. somewhere completely outside)
04:39:51 <ChilliX> on linux, you can cheat and access some non-posix fields on the stack, but that's not portable
04:40:28 <b_jonas> ChilliX: wait, doesn't the sigaction struct tell you whether it's a read or write fault? /me looks up docs
04:40:54 <p_l> cause I've got a code that looks bug-free but when executing on target machine it trashes the stack and jumps somewhere after the end of getpass() in uclibc. Except that _nothing_ calls that function
04:41:04 <paulvisschers> Is there a reactive/fieldtrip irc channel?
04:41:18 <ChilliX> b_jonas: nah, it doens't, at least it didn't use to
04:41:24 <mmorrow> heh, i was playing with ucontext.h the other day.. didn't even know that existed until then
04:41:26 <mmorrow> big fun
04:41:48 <b_jonas> ChilliX: hmm, it might not. in that case either you could map that page read-only and retry the instruction to see if it fails that way, or patch the kernel to fill it out for you
04:42:23 <ChilliX> b_jonas: yeah, you map read-only and retry
04:42:30 <ChilliX> you need to get the page first anyway
04:42:44 <ChilliX> and when the read fails, you got to invalidate all other copies
04:43:06 <b_jonas> I think patching the kernel could also be an option
04:43:23 <b_jonas> I mean, filling out some field in the siginfo structure that no-one uses shouldn't break anything
04:43:27 <b_jonas> (famous last words)
04:43:44 <mmorrow> how do find out what page it is?
04:43:47 <ChilliX> b_jonas: hehe, linux has the info somewhere on the stack anyways
04:43:58 <b_jonas> mmorrow: that _is_ in the siginfo struct the signal handler gets
04:43:59 <ChilliX> mmorrow: you get the address
04:44:01 <boegel> hiya gang!
04:44:17 <boegel> any Haskell geek in here who had a go at the Netflix Prize (using Haskell, of course)
04:44:18 <mmorrow> ohhhh. gah, i've been trying to figure that out for a while.
04:44:33 <b_jonas> mmorrow: read man 2 sigaction
04:44:40 <b_jonas> or possilby the posix docs of sigaction
04:45:21 <mmorrow> yeah, i've been going through the opengroup docs
04:45:44 <mmorrow> oh, i think i just found it
04:45:44 <b_jonas> mmorrow: several years ago someone mentioned to me a vague idea that you could compress memory pages instead of swapping them to a slow hard disk
04:46:06 <boegel> can someone tell me how many bytes a Double value needs in Haskell?
04:46:27 <Xilon> 42
04:46:32 <p_l> ....
04:46:32 <b_jonas> ChilliX: what cpu type was that?
04:46:35 <mmorrow> boegel: you can find out with ghci> Foreign.Storable.sizeOf(undefined::Double)
04:46:47 <boegel> mmorrow: ah, thanks!
04:46:50 <b_jonas> just out of curiosity
04:46:53 <Heffalump> boegel: depends what you're doing with it, of course
04:47:09 <b_jonas> > Foreign.Storable.sizeOf(undefined::Double)
04:47:10 <lambdabot>   /tmp/5533003656615214385:70:32:
04:47:10 <lambdabot>      Not in scope: `Foreign.Storable.sizeOf'
04:47:14 <Heffalump> if you serialise it with Data.Binary it requires a huge amount because the instance is designed to be portable, not efficient
04:47:18 <trofi> import it
04:47:30 <boegel> Heffalump: what do you mean?
04:47:31 <Heffalump> but in memory and unboxed it will only be 8 bytes
04:47:39 <Heffalump> (on all implementations I know of)
04:47:57 <Heffalump> boegel: the Data.Binary serialisation basically uses decodeFloat and serialises that result
04:48:01 <boegel> Heffalump: I have a self defined data type Int [(Int,Double)]
04:48:31 <boegel> Heffalump: the problem is, I need to keep track of over 100M (Int,Double) pairs in total
04:48:33 <b_jonas> is decodeFloat the haskell name for frexp?
04:48:42 <boegel> Heffalump: and I'm running into memory constraints...
04:48:54 <b_jonas> boegel: how about two unboxed arrays?
04:49:07 <b_jonas> one for the ints and one for the doubles
04:49:15 <b_jonas> then you don't have to implement anything in non-haskell
04:49:18 <boegel> b_jonas: any references to more info on that?
04:49:20 <Heffalump> b_jonas: roughly
04:49:33 <boegel> b_jonas: I don't want to implement anything in non-haskell at all :)
04:49:53 <b_jonas> boegel: on what? the unboxed array types?
04:50:07 <boegel> b_jonas: yeah
04:50:27 <boegel> b_jonas: any blog posts / tutorials on efficiently keeping track of that much data in Haskell?
04:51:31 <b_jonas> boegel: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IO.html
04:52:02 <b_jonas> IOUArray is like a plain IOArray except that 1. it works only for some types, 2. it costs fewer memory, 3. it's strict in all its values so it can't store bottom
04:52:20 <boegel> "can't store bottom" ?
04:52:55 <maltem> boegel: being strict in its values means that, if one of the values is bottom, the whole array will be bottom
04:52:59 <b_jonas> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-MArray.html documents their interface
04:53:12 <boegel> maltem: I'm not sure what you guys mean by 'bottom'...
04:53:15 <Heffalump> it also means that the structure won't be lazy, so all elements must be fully evaluated before you access any of them
04:53:41 <b_jonas> because there's a shared class MArray that abstracts the shared interface of IOArray and IOUArray (and others)
04:53:41 <boegel> Heffalump: that's a good thing, in my case
04:53:56 <boegel> Heffalump: I just read the elements from files, so I want them to be strict
04:53:59 <maltem> boegel: If a value has denotation 'bottom', it means that there was an error in computing the value, or that the computation does not terminate
04:54:09 <boegel> maltem: hmm, k
04:54:18 <boegel> maltem: I don't think I'll run into that issue
04:54:37 <boegel> maltem: so, I guess something like 'sum [1..]' is bottom?
04:55:00 <maltem> boegel: yeah that's right
04:55:03 <boegel> cool
04:55:09 * boegel is learning fast
04:55:16 <maltem> :)
04:55:25 <ChilliX> boegel: or  "bottom = bottom" is bottom, too
04:55:49 <boegel> ChilliX: hmm?
04:55:52 <Raevel> today's subject: bottoms
04:56:00 <ChilliX> as a function definition in Haskell
04:56:11 <boegel> ChilliX: hmm
04:56:22 <ChilliX> there is actually a standard Prelude function defined in that exact way
04:56:29 <ChilliX> it's 'undefined'
04:56:49 <trofi> @src undefined
04:56:49 <lambdabot> undefined =  error "Prelude.undefined"
04:56:58 <Heffalump> @src error
04:56:58 <lambdabot> error s = throw (ErrorCall s)
04:57:04 <Heffalump> @src throw
04:57:04 <lambdabot> throw exception = raise# exception
04:57:07 <boegel> ChilliX: heh, cool
04:57:09 <ChilliX> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aundefined
04:57:11 <Heffalump> @src raise#
04:57:11 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:57:25 <Heffalump> GHC always has to complicate things, doesn't it? ;-)
04:57:30 <maltem> boegel: As you can see, ChilliX was wrong about how undefined is defined, but that's the point: Both definitions mean that undefined is bottom
04:57:37 <ChilliX> argh, well, bad definition ;)
04:57:51 * Cheshire calls it  __ = __
04:57:55 <boegel> maltem: fair enough :)
04:57:58 <Heffalump> I don't think ChilliX is wrong, the report defines it his way IIRC
04:58:04 <Cheshire> usually for type level nonsense
04:58:06 <maltem> oh ok
04:58:15 <Cheshire> foo (__ :: <complicated type)
04:58:17 <Heffalump> implementations are obviously free to do their own thing
04:58:24 * boegel hopes using IOUArray can resolve his memory issues
04:58:32 <trofi> @let und | False = und
04:58:33 <lambdabot>  Defined.
04:58:34 <ChilliX> Heffalump: I think it did before the H98 2nd edition or so
04:58:41 <trofi> > und
04:58:42 <Heffalump> ChilliX: fair enough
04:58:42 <lambdabot>   * Exception: <local>:7:0-16: Non-exhaustive patterns in function und
04:58:54 <Heffalump> boegel: unboxed arrays should have almost no overhead
04:59:06 <Heffalump> and certainly no overhead that is proportional to the size of the array
04:59:10 <ChilliX> Heffalump: the current version is the boring one, I always found "undefined = undefined" more instructive
04:59:27 <mmorrow> beautiful, this is where it's been hiding  struct siginfo_t { .... void *si_addr .... }  :)
04:59:42 <Heffalump> It's instructive in denotational terms, but not in operational ones.
04:59:50 <ChilliX> Heffalump: yeah :)
04:59:54 <mmorrow> heh, "instructive"
05:00:08 <ChilliX> Heffalump: well, I guess, you'd get "<loop>"
05:00:11 <Zao> Signal delivery on Windows is more fun as those are delivered on a new thread instead of interrupting the main one.
05:00:17 <maltem> It's funny to think that multi-dimensional IOUArrays should use less memory than a multi-dimensional heap C array
05:00:22 <ChilliX> Heffalump: that's almost as good
05:00:28 <boegel> Heffalump: how about regular arrays (Array Int Double), how will they compare to using [(Int,Double)] ?
05:00:41 <boegel> also, why is the unboxed array part of the IO monad?
05:00:53 <Heffalump> boegel: better
05:00:55 <mmorrow> because it's mutable
05:00:57 <Heffalump> but still inefficient
05:00:57 <ChilliX> Heffalump: Why turn a perfectly good black hole into a stupid exception.
05:00:59 <ChilliX> ?
05:01:01 <Zao> http://blogs.msdn.com/oldnewthing/archive/2008/07/28/8781423.aspx
05:01:09 <b_jonas> boegel: there's an immutable IOArray too
05:01:22 <Heffalump> ChilliX: ask the GHC RTS :-)
05:01:25 <b_jonas>  boegel: you can use that too if you're not modifying your array only reading it once
05:01:55 <boegel> b_jonas: I will be only reading from it, once it's constructed
05:02:06 <maltem> b_jonas: you mean, an immutable UArray?
05:02:12 <ChilliX> Heffalump: I mean the Report - I have no issue with the RTS ;)
05:02:15 <b_jonas> maltem: er, yes
05:02:24 <b_jonas> an immutable UArray
05:02:37 <maltem> boegel: oh then you should be fine with that very UArray from Data.Array.Unboxed
05:02:45 <boegel> maltem: hmm, k
05:03:02 <boegel> I'll be looking further into the details of unboxed an immutable types...
05:03:32 <maltem> boegel: The only trick with Haskell arrays is to find the documentation :)
05:03:38 <ChilliX> boegel: use the immutable one; then, you don't need a monad to access it
05:03:49 <b_jonas> > listArray (0,9) map negate [6..] :: UArray Int Int
05:03:50 <lambdabot>       Not in scope: type constructor or class `UArray'
05:04:42 <boegel> ChilliX: hmm, k
05:04:51 <b_jonas> > listArray (0,9) (map negate [6..]) :: UArray Int Int -- sorry
05:04:52 <lambdabot>       Not in scope: type constructor or class `UArray'
05:05:05 <b_jonas> > listArray (0,9) (map negate [6..]) :: Data.Array.Unboxed.UArray Int Int -- sorry
05:05:06 <lambdabot>   Couldn't match expected type `Data.Array.Base.UArray Int Int'
05:05:06 <boegel> ChilliX: now that you tell me that, it makes sense that IOUArray is part of the IO monad
05:05:24 <boegel> ChilliX: it's like an IORef, but then in the form of a UArray, right?
05:05:32 <ChilliX> yeah
05:05:38 <boegel> k, cool
05:05:47 <Xilon> yi is still under development? Cool
05:05:50 <ChilliX> but you can "freeze" a mutable array and get an immutable version
05:06:06 <ChilliX> then you can't modify it anymore, but instead you can index it in pure code
05:06:07 <boegel> ChilliX: I see
05:06:22 <boegel> ChilliX: so, it might be wise to start with an IOUArray to read the data from file...
05:06:37 <b_jonas> why?
05:06:44 <boegel> b_jonas: why what? :)
05:06:45 <ChilliX> that's a standard idiom in Haskell array programming: (1) alloc mutable array, (2) init it, (3) freeze, (4) use in oure code
05:07:10 <b_jonas> you can read the data from the file to a list, which is lazy so is not stored entirely in memory at once, and pass it to array or listArray to build the array
05:07:13 <maltem> (2) doesn't need mutability though
05:07:18 <ChilliX> boegel: yep, so that you don't have to go through a list (which you say won't work for you)
05:07:22 <maltem> (i.e. not always)
05:07:38 <b_jonas> then you don't need more memory than what the immutable array costs
05:08:13 <b_jonas> that works provided you don't need to read from the array while you're initializing it
05:08:32 <ChilliX> and, btw, use unsafeFreeze (not plain freeze), so that the monster array doesn't get copied
05:09:13 <b_jonas> ChilliX: why, wouldn't plain array or listArray work?
05:09:47 <ChilliX> because you need to stick everything into a list first, which boegel said won't fit into memory
05:09:58 <b_jonas> I don't think so
05:10:15 <b_jonas> er, maybe
05:10:22 <b_jonas> yeah, if you're reading from a file then yes
05:10:23 <b_jonas> hmm
05:10:35 <ChilliX> if you are lucky it gets fused away, but with IO, I won't bet on that
05:10:39 <b_jonas> well, in that case you may need a mutable array,
05:11:01 <boegel> b_jonas: I'm reading over 2G of data into memory
05:11:04 <b_jonas> oh weel
05:11:18 <boegel> b_jonas: well, actually, I'm discarding part of the data, but still, it's a lot of data :)
05:11:22 <b_jonas> boegel: so you're running to an address space limit, not a memory limir, right?
05:11:33 <boegel> b_jonas: yeah
05:11:35 <b_jonas> well, I think there's a safe freezing interface somewhere in the array modules
05:11:45 <boegel> b_jonas: my system has 3G of ram, but a limit of 3G/process
05:11:57 <ChilliX> safe freezing copies
05:12:07 <b_jonas> ChilliX: no, there's a non-copying one
05:12:10 <b_jonas> but it's tricky
05:12:13 <b_jonas> let me look it up
05:12:34 <b_jonas> ah yeah, that doesn't work with reading from a file
05:12:42 <b_jonas> I think
05:12:44 <b_jonas> ok, well
05:12:47 <ChilliX> maybe in ST
05:12:57 <b_jonas> so you can't copy it because of the address space limit
05:13:00 <b_jonas> tough thing
05:13:30 <boegel> what does the "unboxed" aspect of UArray refer to specifically? an implementation detail?
05:13:32 <b_jonas> well, you could try reading it to smaller array chunks, each of which you can copy, but then access to the arrays might be slower
05:13:38 <b_jonas> boegel: not only
05:13:45 <maltem> What was the thing with the list again? Why can't we rely on lazy processing of the list?
05:13:47 <b_jonas> boegel: it's that the values in the arrays are not lazy
05:13:49 <Botje> boegel: all values are strict
05:13:54 <b_jonas> they're not storing a lazy haskell value
05:14:08 <b_jonas> so the number you store in it has to be computed when you store in it
05:14:25 <b_jonas> maltem: because it's read from a file, with IO
05:14:26 <ChilliX> boegel: unboxed arrays are like C arrays
05:14:27 <maltem> boegel: The implementation detail is that the array is stored as a compact memory area
05:14:37 <b_jonas> maltem: you can't compute them in pure code
05:14:44 <ChilliX> they store just the bits of the int or float, or whatever you put in
05:15:01 <ChilliX> boxed arrays in contrast, store a pointer to a heap allocated object containing the data
05:15:07 <boegel> b_jonas, Botje, Chillix, maltem: thanks!
05:15:13 <maltem> b_jonas: Hm... and lazy IO is evil or what?
05:15:19 <Botje> glorious quadrophonic sound!
05:15:21 <b_jonas> maltem: you bet
05:15:30 <Botje> upgrade from stereo! apply now!
05:15:31 <boegel> maltem: oh yeah, I've run into that too :)
05:15:33 <ChilliX> boegel: np
05:15:44 <p_l> Hmm... can I cast IOUArray from Word8 to Word32/Word64 and expect the values to be constructed from the bytes stored in Word8? Like Word32 = low-level equivalent of 4 Word8s in original array?
05:16:12 <maltem> How to follow if all are talking at once!
05:16:25 <pbuetow> hehe, i found a 15 year old book about gofer programming. it is a nice start for learning haskell. because i am waiting for my real world haskell book to arrive :D
05:16:25 <ChilliX> p_l: if you want to do stuff like that, you should use ByteArray#
05:16:36 <ChilliX> (on which the other stuff is built)
05:16:43 <b_jonas> ChilliX: why, wouldn't just the pointer stuff in Foreign work?
05:17:02 <ChilliX> b_jonas: with what?
05:17:22 <b_jonas> ChilliX: for implementing an io array like that he can cast to word32 from word8
05:17:33 <p_l> ChilliX: Basically, I'm trying to simulate memory with atomic 8, 16, 32 and 64bit wide accesses
05:17:44 <b_jonas> atomic in what way?
05:18:10 <ChilliX> yeah, you can just use Foreign, that's fine, but then you got to malloc/free, whereas ByteArray# is GC'ed
05:18:24 <ChilliX> depends on whether you want to alloc in C-heap or Haskell heap
05:18:46 <b_jonas> ChilliX: I think there's a wrapper in foreign that can free on garbage collection, let me look that up
05:18:58 <ChilliX> b_jonas: you can use a finalizer
05:19:07 <p_l> b_jonas: The best would be for them to compile into one opcode on 64bit machine, but as long as I can run acceses from different threads and not have a 64bit read have it data rewritten in the middle of reading, it's okay :)
05:20:03 <p_l> I guess Foreign might be interesting for that
05:20:28 <b_jonas> ChilliX: yes, there's ForeignPtr.mallocForeignPtr which does that for you rightaway
05:21:36 <b_jonas> p_l: is it ran from a single os thread or multiple os thread? which way are you compiling it?
05:22:20 <b_jonas> wait, just "not have it rewritten in the middle of reading"? that's not too useful of a guarantee
05:22:27 <b_jonas> can you even do anything with that?
05:23:04 <chaoslynx> im trying to get all divisors of an integer but the types wont match and there should really be a prettier way divisors n = [m | m <- [1..(toInteger $ floor $ sqrt n)], (n `mod` m) == 0]
05:23:15 <pejo> pbuetow, is it written by Mark Jones?
05:23:43 <p_l> b_jonas: It's emulating an atomic read by CPU in multiprocessing system (with multiprocessing emulated by different threads)
05:25:51 <p_l> Another way would be to allocate mutable array of Word64s and use similar access pattern as in pre-BWX alpha
05:26:17 <boegel> when using an UArray of type UArray (Int,Int) Double, will it matter if the second index may get fairly high, but it sparsely indexed (range upto >2.5M with only ~480,000 unique indices used)
05:26:26 <boegel> in terms of memory usage that is
05:26:41 <boegel> s/but it/but is/
05:26:51 <ChilliX> boegel: it's like a C array, you waste all the unused entries
05:27:35 <boegel> ChilliX: oh, crap
05:27:44 <b_jonas> > 480000/2.5e6
05:27:45 <lambdabot>   0.192
05:28:06 <boegel> ChilliX: so I should create a seperate mapping of real indices to the 1-480,000 range
05:28:16 <ChilliX> yes
05:29:09 <boegel> ChilliX: any better datatypes to work with a large amount of sparse data? i.e. 100M elements in a 17770x480,000 matrix?
05:29:42 <boegel> it's very sparse, because only ~1.5% of the elements is there
05:30:11 <boegel> so I'm guessing an UArray might not be the best thing to go with?
05:30:11 <b_jonas> boegel: wait, first you said it's 480000 elements filled out from 2500000, which is 19%
05:30:14 <b_jonas> which one is it?
05:30:22 <ChilliX> afaik, there is nothing pre-done that handles huge sparse structures efficiently
05:30:30 <b_jonas> if it's only 1.5%, then you can hash it to a sparser structure probably,
05:30:40 <boegel> b_jonas: no, I said 480,000 unique indices from a range of 1-2.5M
05:30:58 <boegel> b_jonas: but I have a 2-dim matrix
05:31:10 <boegel> b_jonas: the 480,000 unique indices are only one dimension
05:31:20 <boegel> b_jonas: the other ranges from 1-17770
05:31:37 <b_jonas> and it's sparse in only one direction, with each column either empty or dense?
05:31:55 <b_jonas> also, how do you have to be able to access it?
05:32:08 <boegel> b_jonas: it's only sparse in the larger dimension, so if you see 1-17770 as the row indices, then the rows will be sparse
05:32:39 <boegel> b_jonas: but every row will have a number of elements filled in, ranging from 100 to something like 100,000 orso
05:33:23 <boegel> b_jonas: I'm trying to attack the Netflix Prize problem using Haskell, in case you're wondering ;-)
05:33:50 <b_jonas> so, wait, it's sparse in every way, there are not much empty rows or empty columns either?
05:33:54 <b_jonas> and how sparse?
05:34:14 <boegel> b_jonas: 100M elements are filled in, so roughtl 1.5% of the data is available
05:34:22 <b_jonas> > 100000 / (17770 * 480000)
05:34:23 <lambdabot>   1.1723879197148752e-5
05:34:38 <b_jonas> I can't get the numbers right
05:34:55 <boegel> > 10e8 / (17770 * 480000)
05:34:56 <lambdabot>   0.11723879197148752
05:35:02 <boegel> 1.2% :)
05:35:05 <b_jonas> and how will you want to access it? only by indexing it with a coordinate, or in more complicated ways too, like finding all filled values in a row or column or whatever?
05:35:08 <boegel> erm
05:35:20 * boegel scratches his head
05:35:26 <b_jonas> > 100000000 / (17770 * 480000)
05:35:27 <lambdabot>   1.1723879197148752e-2
05:35:51 <boegel> b_jonas: that's the way
05:35:54 <boegel> > 10e8
05:35:55 <lambdabot>   1.0e9
05:35:58 <b_jonas> 100M is not 10e8, it's 1e8
05:36:03 <boegel> > 1e8 / (17770 * 480000)
05:36:05 <lambdabot>   1.1723879197148752e-2
05:36:06 <boegel> :)
05:36:12 <boegel> b_jonas: right
05:36:25 * boegel smashes his head on the able for getting that wrong
05:36:45 <boegel> b_jonas: I'll be accessing it like all elements in a row or column
05:36:53 <boegel> b_jonas: all available elements that is
05:37:07 <b_jonas> probably that's doable too if it's only 1% filled
05:37:17 <boegel> b_jonas: while still knowing what row/column the elements come from
05:37:37 <boegel> b_jonas: array won't suffer from the fact that the matrix is sparsely filled?
05:38:17 <b_jonas> well, if you want to find all elements of a row, then a sparse matrix might be worse
05:38:23 <b_jonas> really depends on what you do
05:38:56 <b_jonas> if you want to traverse rows and columns, then you might want to collect an array of index-value pairs for each row and for each column
05:39:17 <boegel> b_jonas: I want fast access over using fewer memory...
05:39:26 <b_jonas> bit if you also want random access then apart from that you'll need a big hash table too or something
05:39:40 <RayNbow> @seen jamii
05:39:40 <lambdabot> jamii is in #haskell. I last heard jamii speak 16h 47m 21s ago.
05:39:52 <b_jonas> > 17770 * 480000 * 8
05:39:53 <lambdabot>   68236800000
05:40:00 <b_jonas> > (17770 * 480000 * 8)/2^(30)
05:40:02 <lambdabot>   63.550472259521484
05:40:20 <b_jonas> > (1e8*8)/2^(30)
05:40:20 <boegel> 63G of potential data? :)
05:40:21 <lambdabot>   0.7450580596923828
05:40:24 <b_jonas> > (1e8*8)/2^(60)
05:40:25 <lambdabot>   6.938893903907228e-10
05:40:33 <b_jonas> > (1e8*8)/(2^30)
05:40:35 <lambdabot>   0.7450580596923828
05:40:37 <b_jonas> > (1e8*16)/(2^30)
05:40:38 <lambdabot>   1.4901161193847656
05:40:45 <b_jonas> still a lot
05:40:55 <boegel> b_jonas: yeah, but I'm fine with that
05:41:04 <pbuetow> pejo, no Goos
05:41:07 <boegel> b_jonas: as long as it'll fit in my 3G memory limit, then I'm fine
05:41:12 <b_jonas> it's on the borderline, because you probably need more than that to make it efficent
05:41:18 <pbuetow> it's in german, don't know if its available in english
05:41:28 <pbuetow> looks like a learning book for university
05:41:49 <Cheshire> does anyone have a good synonym for suggestion?
05:42:36 <bolrod> proposal ?
05:42:37 <mmorrow> here's "a thought"
05:43:48 <bolrod> also depends on your definition of suggestion
05:43:56 <Cheshire> type Suggestion = Maybe String
05:44:03 <bolrod> :)
05:44:05 <b_jonas> recommendation
05:44:08 <b_jonas> Cheshire: heh
05:44:36 <bolrod> try "define: suggestion"  in google? :o
05:49:26 <pk> #haskell-in-depth
05:49:26 <pk> sry
05:49:26 <boegel> b_jonas: so, what would you think my best option is, giving the fact that I'm primarily focused on fast row/column access, and only want to fit the whole thing in 3G of memory?
05:49:26 <boegel> pk: damned, now you've spoiled the secret!
05:49:26 <maltem> Cheshire: thesaurus.com should give you some
05:49:26 <maltem> @seen conal
05:49:26 <lambdabot> I saw conal leaving #haskell, #ghc and #haskell-in-depth 7h 56m 59s ago, and .
05:51:10 <b_jonas> boegel: I'm still not sure what exact ways you want to access it
05:51:10 <b_jonas> Cheshire: or try that dinosaur thing
05:51:10 <boegel> b_jonas: I want to be able to quickly get a list of (Int,Double) pairs, given a certain row index
05:51:10 <boegel> b_jonas: and the same for a certain column index
05:51:12 <boegel> b_jonas: i.e. I want the get all the user ratings for one movie, or from one user
05:51:37 <boegel> b_jonas: while still knowing from which user/for which movie the ratings are
05:52:28 <bolrod> ..you trying to solve the netflix prize?
05:52:38 <pk> sounds like a cool project
05:52:44 <boegel> bolrod: yeah :)
05:52:48 <bolrod> :D
05:52:49 <boegel> bolrod: using Haskell!
05:52:59 <C-Keen> what's missing if i try to use cabal-install and it tells me /usr/bin/ld: cannot find -lHSrts_thr
05:53:09 <bolrod> well.. they're like .5% off the main prize right?
05:53:20 <boegel> bolrod: I plan to do several blog posts on it, in case you're interested... :)
05:53:22 <boegel> bolrod: yeah
05:53:33 <boegel> bolrod: but they have been going forward _really_ slow
05:53:43 <boegel> bolrod: I plan to come up with something totally different
05:54:07 <bolrod> ok.. :)
05:54:08 <boegel> bolrod: I have almost zero experience with predicting ratings, but I have a few ideas I want to try out
05:54:09 <bolrod> what's your plan
05:54:27 <boegel> bolrod: heh, see my blog where I'll reveal my plans as I go
05:54:37 <b_jonas> boegel: could you perhaps get a 64 bit operating system so you're not limited to 3G of address space?
05:54:41 <maltem> C-Keen: Do you have ghc installed in an unusual location?
05:54:43 <boegel> bolrod: along with the analysis I perform to see if has any chance to be succesful
05:54:50 <b_jonas> though that would end with lots of swapping
05:54:52 <boegel> b_jonas: well, maybe
05:54:56 <b_jonas> which might not be that good
05:54:57 <boegel> b_jonas: but I would prefer not :)
05:55:04 <b_jonas> let's see
05:55:06 <C-Keen> maltem: the debian package put the lib in /usr/lib/ghc-6.8.2
05:55:11 <boegel> b_jonas: my chances? probably not, but if you don't try...
05:55:31 <b_jonas> > (3*2^30)/1e8
05:55:33 <lambdabot>   32.21225472
05:55:35 <boegel> b_jonas: we have some 64-bit systems at work which have 16G of RAM, but I don't want to use those
05:55:40 <C-Keen> maltem: I build cabal-install with ghc --make Setup ... so that works
05:55:54 <pk> is is really bad if a part of the data is on the disk ?
05:55:55 <boegel> b_jonas: I wanna make sure uni doesn't claim my prize if I win it, so I only use my private systems
05:56:02 <maltem> C-Keen: oh, debian, then maybe the threaded RTS isn't installed at all... maybe look for some package involving ghc and threading
05:56:11 <boegel> pk: well, I need fast access to the data
05:56:16 <C-Keen> maltem: ah ok
05:56:20 <maltem> C-Keen: although, that would be strange really.
05:56:27 <maltem> C-Keen: but I don't have a better idea
05:56:29 <b_jonas> boegel: but most computer hardware in the last few days can handle 64-bit systems
05:56:31 <boegel> b_jonas: 32K per data lement...
05:56:34 <C-Keen> maltem: well the ar file is there so I don't know
05:56:35 <b_jonas> so it's the RAM that's the problem
05:56:36 <pk> boegel, all at once ?
05:56:40 <boegel> b_jonas: I'm using an iMac
05:56:41 <b_jonas> boegel: WHAT?
05:56:43 <Zao> b_jonas: days?
05:56:57 <b_jonas> 32 kilobytes?
05:57:03 <boegel> b_jonas: err
05:57:05 <boegel> b_jonas: bytes
05:57:11 <boegel> b_jonas: I was being optimistic :)
05:57:15 <b_jonas> :(
05:57:28 <boegel> b_jonas: ?
05:57:42 <bolrod> boegel: where you gonna put the blog about it?
05:57:55 <boegel> bolrod: http://boegel.kejo.be
05:57:58 <b_jonas> boegel: if you could traverse all of it serailly, possibly pre-sorting it etc, then a disk would work
05:58:10 <boegel> bolrod: I haven't revealed I plan on using Haskell for it, yet
05:58:24 <boegel> b_jonas: I won't be traversing it serially
05:58:29 <bolrod> why do you want to use haskell anyway?
05:58:35 <b_jonas> boegel: so do you want to traverse it only by rows, or by both rows and columns?
05:58:45 <boegel> bolrod: because I think it would be damn cool if I win the prize using Haskell
05:58:48 <b_jonas> if it's only by rows than that's easy, you just store each row
05:58:53 <bolrod> though there was some python script on that forum which compressed the data to 500MB
05:59:02 <bolrod> basically removing duplicate data
05:59:03 <b_jonas> that is, an array of indices and values per each row
05:59:03 <boegel> bolrod: and I'm primarily seeing it as a darn good exercise to improve my Haskell-fu
05:59:40 <boegel> b_jonas: I think that accessing by columns will be more frequent...
05:59:43 <b_jonas> that could even work if you don't want random access
05:59:46 <b_jonas> because look
05:59:53 <boegel> b_jonas: as in 100 by column vs 1 by row or so
06:00:06 <b_jonas> an int and a double is 12 bytes if you store the two in separate arrays
06:00:12 <b_jonas> and there aren't too many rows nor columns
06:00:19 <b_jonas> and you need it twice, once for each direction
06:00:32 <b_jonas> so that could be under 32 bytes per element
06:00:37 <b_jonas> how many rows was it agian?
06:00:52 <b_jonas> 480000 rows
06:00:53 <boegel> b_jonas: 17770 rows (movies), 480,000 columns (users)
06:01:10 <boegel> b_jonas: well, yeah, depends on how you look at it :)
06:01:12 <b_jonas> then the headers for rows could fit as well
06:01:25 <b_jonas> that's provided you don't need random access for a row-column coordinate
06:01:42 <b_jonas> because that would cost another 2G or 4G so you won't fit both of them at once
06:01:54 <boegel> b_jonas: I'll need the entire set of ratings per column first, which I'll filter probably
06:02:14 <b_jonas> of course, if you access only rows or only columns in each pass, you could just load (swap in) the relevant half
06:02:25 <b_jonas> also,
06:02:36 <b_jonas> do you really need a whole double for each rating?
06:02:38 <boegel> b_jonas: dude, you're helping me big time here... :)
06:02:47 <boegel> b_jonas: hmm, good point
06:02:51 <b_jonas> I mean, do people give ratings precise to more than six digits?
06:02:51 <boegel> b_jonas: probably not
06:03:05 <boegel> b_jonas: in fact, the ratings are {1,2,3,4,5}
06:03:13 <b_jonas> I don't know what exact data  the netflix channelge has so I can't tell
06:03:21 <boegel> b_jonas: but I use Double because a predicter rating won't be integer probably
06:03:33 <b_jonas> so?
06:03:46 <b_jonas> if you want to store lots of data, that's whta smaller types are for
06:03:54 <b_jonas> you can still compute with doubles where you don't have to store lots
06:03:54 <boegel> b_jonas: well, for the data I read in from file, I only need something that can hold 1-5
06:04:05 <boegel> b_jonas: integer values, that is
06:04:07 <b_jonas> like one byte or a half
06:04:16 <boegel> b_jonas: yeah, 4 bits should do it
06:04:34 <boegel> b_jonas: Char is 1 byte, right?
06:05:03 <boegel> b_jonas: I could seperate between GivenRating (Char) and PredRating (Double, or Float)
06:05:08 <boegel> that would help a lot I guess
06:05:11 <boegel> :)
06:05:24 * boegel curses not being able to see obvious stuff right away
06:06:05 <bolrod> so when can we see the method you're going to use to tackle it? :)
06:06:07 <boegel> b_jonas: I guess that'll help big time, right?
06:06:14 <maltem> boegel: Haskell Char /= C char. For specific word sizes use Data.Word
06:06:20 <boegel> bolrod: when I manage to handle the data somewhat efficiently
06:06:30 <boegel> maltem: hmm, k
06:06:47 <b_jonas> so you'd store the indices and values for each row in unboxed arrays?
06:06:51 <b_jonas> that might work
06:07:16 <boegel> b_jonas: with rows, do you mean movies or users? :)
06:07:17 <b_jonas> you'd better presort the input files both by row and by column for easier loading
06:07:23 <b_jonas> either
06:07:24 <maltem> Btw will we all get a cheque once you're done?
06:07:25 <b_jonas> whatever
06:07:28 <b_jonas> probably users
06:07:33 <boegel> b_jonas: well, yeah, probably
06:07:39 <boegel> b_jonas: seems like the most efficient
06:07:46 <bolrod> :)
06:07:48 <boegel> (brb)
06:08:26 <Feuerbach> what is /usr/lib/imports for?
06:08:54 <b_jonas> whether you store all of it in a single array or each row in a separate iarray is still a question of detail
06:08:56 <bolrod> boegel: maybe buy an i7 system with 6GB of memory?... those things are so fast :P
06:09:04 <PeakerWork> Maybe rename Char to CodePoint?
06:09:06 <PeakerWork> type String = [CodePoint]
06:09:46 <Feuerbach> PeakerWork: would be great, really
06:09:57 <maltem> PeakerWork: Better, in C, rename char to byte or something
06:10:04 <PeakerWork> C won't change :)
06:10:21 <maltem> Char won't eihter :P
06:10:53 <maltem> or it will. or well
06:10:59 <boegel> maltem: well, if I do manage to win (don't count on it), I'll donate something useful to the Haskell community
06:11:09 <boegel> maltem: a big set of hardware or something :)
06:11:33 <boegel> bolrod: I won't buy a new system to tackle a problem
06:11:41 <maltem> boegel: That's a good thing to say anyways :)
06:12:10 <pejo> bolrod, those systems are so expensive.
06:12:10 <boegel> bolrod: I'll figure out a way to find an elegant solution that uses the system I have the best it can
06:12:26 <boegel> maltem: well, I promise, if I do win, I'll donate
06:12:33 <bolrod> pejo: what's expensive.... I think he could be done for.. 1500 euro?
06:13:24 <boegel> bolrod: I don't have that kind of cash, we just bought ourselves a house
06:13:53 <bolrod> o;
06:14:04 <boegel> so, I don't think anybody answered this yet... is an Array (or UArray) good in handling sparse data?
06:14:31 <maltem> They're just arrays
06:14:58 <boegel> maltem: so, they're not...
06:15:56 <maltem> I think I only once saw a Haskell thing involving the word "sparse data". What was it, hmatrix?
06:16:07 <maltem> Maybe it could give you ideas
06:16:52 <Botje> boegel: if your data is sparse, you're better off using Data.Map
06:18:23 <boegel> Botje: does that also hold when I have over 100M (Int,Int)'s that map to a byte value ? :)
06:18:46 <Botje> eh
06:18:55 <Botje> 100M elements and your data still is sparse? :p
06:20:05 <Botje> i'd say just try it
06:22:20 <boegel> Botje: the (Int,Int) index ranges from (1,1) to (17770,480000)
06:22:28 <boegel> > 17770*480000
06:22:29 <lambdabot>   8529600000
06:22:36 <boegel> > 1e8/17770*480000
06:22:37 <lambdabot>   2.7011817670230722e9
06:22:45 <Botje> heh :p
06:22:58 <boegel> > 1e8/(17770*480000)
06:22:59 <lambdabot>   1.1723879197148752e-2
06:23:16 <boegel> Botje: so with only 1.17% of the data available, yes, it's sparse :)
06:24:27 <Botje> i'd say TIAS :)
06:24:33 <Botje> (try it and see)
06:24:56 <boegel> Botje: I'll figure something out :)
06:25:35 <bolrod> we'll be expecting daily updates on the blog!!! :p
06:28:56 <boegel> bolrod: heh
06:29:05 <p_l> boegel: You already have an idea as to how to tackle the problem? :)
06:29:08 <boegel> bolrod: unfortunately, I don't have the time to work on it each day
06:29:25 <boegel> p_l: I have an idea, but I don't know if it'll work?
06:31:23 <p_l> You never really know before you try. And even then not always :D
06:32:05 <boegel> p_l: I plan to take it one step at a time
06:32:29 <boegel> p_l: doing thorough analysis first, to check if the ideas I have will work or not
06:33:31 <p_l> well, the moment I had seen the problem, I thought of my AI coursework :)
06:33:59 <boegel> p_l: feel free to share your thoughts with me
06:34:29 <boegel> p_l: I have little information with this particular kind of problem (rating systems), but I have done stuff on predicting stuff
06:34:45 <boegel> p_l: I see that as a good thing, i.e. see the problem from a different angle
06:35:05 <p_l> boegel: Well, I had considered it from predicting/classification angle
06:35:23 <boegel> p_l: I think most people do
06:35:45 <boegel> p_l: as my blog post described, most people rely on something like SVD to extract factors for each user/movie
06:36:03 <Cheshire> is this good?
06:36:05 <Cheshire> foldl1 f x [] = x
06:36:05 <Cheshire> foldl1 f x (y:ys) = foldl1 (f x y) ys
06:36:23 <boegel> p_l: the thing that struck me a odd is that they only have 1% of the data available, and they don't seem to consider that a problem
06:36:58 <p_l> boegel: Well, it's supposed to tackle the rest without knowledge, then?
06:37:24 <p_l> I think that winner will get to be trained on complete set, which is probably too big to transfer
06:38:13 <boegel> p_l: they rely on the algorithm to extract relialable information
06:38:16 <p_l> it might be of the size where you start considering the bandwidth of a truck full of tapes
06:38:28 <boegel> p_l: which I think is impossible with just 1% of the data
06:38:47 <boegel> p_l: there's no such thing as a complete set
06:38:51 <p_l> boegel: I'm not so sure
06:39:03 <boegel> p_l: if you have the complete set, then there's no point in predicting, is there? :)
06:39:14 <p_l> heh
06:39:35 <p_l> well, predicting what the user will choose in the futuree ;)
06:40:40 <p_l> hmmm... they say they use a straightforward statistical analysis....
06:41:14 <bolrod> who;s gonna watch 17000 movies anyway
06:41:34 <Botje> at 1 movie per day that only takes 50 years :pp
06:41:47 <bolrod> + all the movies that are made in those 50 years
06:41:52 <Cheshire> does anyone know ReadP a bit?
06:42:00 <Cheshire> please can you give me any advice about this? http://rafb.net/p/oE3WVj38.html
06:42:10 <boegel> bolrod: the point is, Netflix wants to predict which movies the user will like
06:42:10 <p_l> bolrod: I guess you never tried watching at double speed? :)
06:42:11 <Cheshire> it should have only given one result..
06:42:23 <boegel> bolrod: and the more accurately they can do so, the more money they earn
06:42:42 <p_l> so that $1m is not such a big thing :)
06:42:50 <Cheshire> should I use parsec so that I have commited choice?
06:44:30 <Cheshire> I solved it
06:46:10 <p_l> boegel: I'm thinking of an approach based on AI research, not statistical - neural nets, genetic programmic, bayesian networks, markov process and some derivatives calculated from data, all mashed together :D
06:46:45 <JuanDaugherty> AI is just application of the techniques mentioned, among others.
06:47:31 <JuanDaugherty> ie. AI = Not stuppyfuckus data processing.
06:48:08 <bolrod> boegel: I know :p
06:48:12 <JuanDaugherty> in 1960 compilers for hll were AI.
06:48:21 <bolrod> I've tried it myself with that pythong script thing once..
06:48:23 <p_l> JuanDaugherty: Sure, I'm just applying them in a way taken from AI research
06:48:37 <bolrod> made up some simple thing... which wasn't really fast.. nor good :P
06:48:44 <bolrod> took ages to run through the set
06:48:57 <p_l> JuanDaugherty: Everything that isn't basic business logic or number crunching is probably descendant of AI research, though :)
06:49:59 <bolrod> I think there was also some team which did a really simple algorithm
06:50:02 <boegel> p_l: feel free to try it yourself
06:50:14 <boegel> bolrod: that's what I'm aiming for ;-)
06:50:18 <boegel> bolrod: simple and effective
06:50:22 <bolrod> and just looked up the movie on imdb or wikipedia or something.. and connected it to the movie that needed the rating
06:50:35 <bolrod> :P
06:51:01 <boegel> bolrod: that's supposed to be a no-go
06:51:02 <p_l> bolrod: I'm thinking of including that
06:51:20 <bolrod> boegel: is it in the rules?... I think they did pretty well
06:51:40 <p_l> Not taking the rating, but connecting over different values (like who is the director etc.)
06:51:45 <bolrod> damnit... getting random disconnects >:(
06:51:53 <bolrod> and don't know if its the ISP's fault .. or my uni's
06:52:29 <bolrod> I don't know what they did exactly.. was quite some time ago
06:53:38 <p_l> I see that the best team at the moment used a similar idea to one of mine :-)
06:55:39 <bolrod> well... go implement it yourself.. and go win :P
06:56:00 <boegel> bolrod: I think it is
06:57:34 <boegel> > (17770*480000) / (2^30)
06:57:37 <lambdabot>   7.9438090324401855
06:58:39 <boegel> > (5*1e8) / (2^30)
06:58:40 <lambdabot>   0.46566128730773926
06:58:44 <bolrod> grrrrrr.. I wonder if someone is pissing me off by killing my ssh connection
06:58:49 <boegel> bolrod: hehe
06:58:49 <bolrod> or if the ISP is being a generall ass
06:59:12 <bolrod> its not even lag
06:59:18 <bolrod> its just... *poof*  disconnected
06:59:40 <boegel> bolrod: maybe server maintanance?
06:59:49 <bolrod> no idea
06:59:53 <bolrod> its just a simple server/computer
07:01:01 <bolrod> 2 XEON cores with 1GB of memory..
07:02:06 <p_l> bolrod: Maybe something somewher constantly keeps doing autodetection of link? :-)
07:03:06 <bolrod> I have no idea whats going on..
07:03:17 <bolrod> 2 days ago it wouldn't even let me connect to it
07:03:21 <bolrod> while others could connect to it
07:03:23 <Cheshire> in something like  data F = A Int | B F  .. you could call the 'F' part of B inductive (or recursive perhaps), but what do you call the 'Int' part of A?
07:03:26 <bolrod> so I guess its my ISP
07:03:40 <bolrod> though my traceroute did get to the server
07:03:56 <bolrod> or at least.... outside of my isp
07:04:06 <bolrod> and into the university servers
07:04:53 <Cheshire> there must be a better name than non-foo ? :?
07:05:34 <EvilTerran> Cheshire, if i had "data F = A Int | B F", i might call (A _) the "base case" and (B _) the "inductive case"
07:06:11 <Cheshire> ok thanks Base is perfect
07:09:49 <bolrod> boegel: well you might be like 'just a guy in a garage'  :P He went up to the top 10 in like 7 weeks I think
07:13:20 <PeakerWork> does anyone use Kristof's haskell indentation mode? Does it, like the builtin Haskell mode, complete multiple pattern matches in a function binding?  It seems not to here, wondering if that's a local problem
07:17:29 <boegel> bolrod: well, I made my first submission in the beginning of Jan. I think
07:17:35 <boegel> bolrod: just to test my output :)
07:17:54 <boegel> bolrod: I just predicted '1' for all requested ratings :)
07:19:38 <bolrod> :o.. how did you do :P
07:21:37 <Xilon> How can I install vty >=2.0 && < 3.0 when I can't find it on hackage?
07:22:06 <Xilon> oh nvm, I meant terminfo :P
07:27:49 <defun> Just for clarification: Can functions take datatypes as args? Does the same apply to newtypes and type synonyms?
07:29:06 <chrisdone> what is a datatype?
07:31:01 <boegel> bolrod: I had a RMSE of 2.9028
07:31:28 <boegel> bolrod: where the baseline (the Netflix algorithm) is 0.9514, and the goal is thus 0.8563
07:31:36 <boegel> bolrod: so predicting 1 doesn't work that well ;-)
07:36:05 <defun> chrisdone: data Constructor = Constructor1 Bla Bla Bla | Constructor2 Bla Bla
07:38:17 <asgaroth> defun: Constructor1 can be used as a normal function and thus passed around as argument and such. The actual datatype "Constructor" cannot.
07:42:33 <boegel> > [5..1]
07:42:36 <lambdabot>   []
07:42:42 <boegel> > [5,4,..1]
07:42:43 <lambdabot>   <no location info>: parse error on input `..'
07:42:45 <boegel> > [5,4..1]
07:42:46 <lambdabot>   [5,4,3,2,1]
07:42:56 <boegel> > [5..2,1]
07:42:57 <lambdabot>   <no location info>: parse error on input `,'
07:43:04 <hackage> Uploaded to hackage: xmonad-eval 0.1
07:43:22 <boegel> @src foldl'
07:43:22 <lambdabot> foldl' f a []     = a
07:43:23 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:43:28 <defun> asgaroth: thanks. So, I take it newtypes and type synonyms can't be used as such?
07:43:32 <boegel> @src foldr
07:43:32 <lambdabot> foldr f z []     = z
07:43:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:46:45 <EvilTerean> grr
07:46:58 <EvilTerean> sometime, i'll type that correctly...
07:51:45 <bolrod> boegel: hmm... how can you be more then a half off by predicting 1... people like the 5 more?
07:52:10 <bolrod> so you would gain 0.4 already by adding 0.4 to your predicted value? :P
07:54:01 <pejo> Are there any standard examples of accumulating parameters other than reverse?
07:54:42 <bolrod> fold ?
07:55:23 <bremner> pejo: factorial, power...
07:57:10 <mopped> http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=1525 Can anyone tell me how I can greatly clean up my prime factors function? it seems quite a verbose method of doing it
07:57:36 <wli> I'll take a look.
07:59:40 <wli> mopped: okay, there's some strangeness
08:00:29 <mopped> where abouts?
08:03:07 <wli> mopped: I added a revision
08:04:02 <mopped> ah, i knew that lambda was bad form :P
08:06:51 <wli> Next is the list return.
08:06:57 * Xilon has been trying to install yi for the past 2 hours :(
08:07:51 <jutaro> Xilon: try leksah
08:08:12 <ozy`> Xilon: I gave up on all hopes of ever using the GUI version... installing the text version works okay if you use cabal
08:08:37 * Xilon got it working :D
08:08:42 <Xilon> ozy`: Which GUI?
08:08:49 <ozy`> Xilon: any of them.
08:09:10 <ozy`> I haven't managed to get gtk2hs to compile yet, but I don't like gtk anyway
08:09:19 <ozy`> the others..... ugh
08:09:50 <Xilon> I'm not sure how to enable a GUI
08:18:57 <guest> help
08:19:13 <guest> uit
08:19:25 <wli> mopped: Another rev en route.
08:19:36 <Raynes> Leksah is as close to useless as an IDE can get.
08:19:41 <EvilTerran> are you okay there, guest?
08:20:21 <EvilTerran> apparently not.
08:20:53 <augustss> @seen dcoutts
08:20:53 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
08:21:02 <dcoutts> hia augustss
08:22:03 <augustss> dcoutts: I want to use cabal to build an executable that just has a C file.  So I need to execute the command 'ghc foo.c -o foo'.  Is that possible?
08:22:12 <jutaro> Raynes: Thanks
08:22:44 <dcoutts> augustss: not at the moment I think. You can check what goes wrong if you use: main-is: foo.c
08:22:46 <Raynes> jutaro: >_> You're a developer aren't you? ._.
08:22:59 <dcoutts> augustss: if we want that to work then that's probably how we should specify it.
08:23:06 <jutaro> Raynes: No comment
08:23:28 <dcoutts> augustss: though I'm not sure about how we use a C main and other-modules for Haskell modules. I'm not sure if ghc can cope with that.
08:23:44 <Raynes> jutaro: I've always expected big things from Leksah and I still do, but right now it's not so great. Sorry for being so mean.
08:23:44 <augustss> dcoutts: Does the cabal file have to build anything at all?
08:24:08 <dcoutts> augustss: I don't follow
08:24:47 <jutaro> Raynes: Whats the latest version you have tried?
08:24:58 <Raynes> jutaro: Whatever version was out a week ago.
08:25:12 <augustss> dcoutts: I want a cabal file, so I can upload my package to hackage.  Does that mean I have to have a cabal file that builds a binary or a library?  Or can the cabal file just specify a bunch of files?
08:25:16 <wli> mopped: Yet another revision.
08:25:41 <dcoutts> augustss: no, it must specify that it's a lib or a binary.
08:26:04 <augustss> dcoutts: but the binary i want to install is the one built from C. :(
08:26:26 <augustss> dcoutts: I can make a dummy binary, I guess.
08:26:36 <mopped> i've never used unfoldr or >>=, what is it doing there wli?
08:27:01 <dcoutts> augustss: how would that help? Your binary has to be built from the C code, how does a dummy help?
08:27:28 <wli> mopped: If the input is Nothing, the result is also nothing, else if it's Just z it's uncurry factors z
08:27:28 <augustss> dcoutts: people will just have to build it by hand
08:27:34 <dcoutts> augustss: I think that it would not be too hard to let "main-is: foo.c" work, as opposed to the current expected "main-is: foo.hs"
08:27:42 * Xilon_ sighs
08:27:48 <Xilon_> now I have to install Objective-C bindings :P
08:27:56 <ozy`> Xilon_: good luck :|
08:28:01 <dcoutts> augustss: what definitely works now if you need this immediately is to use a Haskell main that ffi-calls out to the C code
08:28:35 <dcoutts> augustss: and I can investigate making it work directly if you think this is something that you'll need more frequently
08:28:58 * wli always thought deriving Functor should be standard.
08:29:07 <augustss> I know what I'll do.  I'll build  dummy binary that when you run it tells people what to build by hand. :)
08:29:17 <dcoutts> augustss: we can have libs that consist only of C code already
08:29:35 <dcoutts> augustss: come on, it's like 10 lines to have a Haskell wrapper!
08:30:36 <Xilon> I think I might just forgo the Cocoa GUI for now :P
08:30:47 <jpcooper> is there any way to make an empty IORef and have it set later?
08:30:55 <ozy`> Xilon: get GLTerminal and run it full screen
08:31:01 <augustss> dcoutts: it's not something I'd expect to ever use again
08:31:03 <jpcooper> actually never mind
08:31:04 <dcoutts> augustss: main = real_main; foreign import ccall "real_main" real_main :: IO ()
08:32:25 <Xilon> ozy`: ... freaky
08:33:18 <wli> mopped: It's really tempting to improve the algorithm.
08:34:57 <Philonous> What whent wrong when ghc tells me that an "Inferred type is less polymorphic than expected" ?
08:35:22 <PeakerWork> Philonous: you said your value has a type: forall a. a  or such, but it actually had a more specific type, like Int
08:35:30 <PeakerWork> oh wait, forget that, I'm not sure its that
08:36:08 <wli> I think it's that most of the time.
08:36:08 <PeakerWork> Philonous: I think it might be use of a specifically typed value where an existential was expected, but still am not sure
08:36:28 <wli> Not an existential, just a free type var.
08:36:57 <dolio> I think you can get it from an existential, too.
08:37:12 <dolio> But that's because it kind of adds a particular type variable.
08:37:46 <wli> I get it when trying to use ST all the time.
08:38:04 <wli> No, wait, it's something about the thing escaping when it's existentials.
08:38:21 <dolio> \(E a) -> a will get you the error with existentials, for instance.
08:38:55 <Philonous> I'm still not sure what I need to look for to get rid of it
08:39:16 <wli> Existentials are a different errmsg, something about the tyvar escaping.
08:39:48 <dolio> runST will give it to you if you try something like runST (newSTRef 0).
08:40:45 <dcoutts> augustss: got it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1624
08:40:46 <wli>     Inferred type is less polymorphic than expected
08:40:46 <wli>       Quantified type variable `s' escapes
08:40:46 <wli>     In the first argument of `runST', namely `(newSTRef 0)'
08:42:35 <Xilon> I think I'm going to like Yi
08:42:50 <Xilon> If it provides the extensibility of Emacs and the awesomeness of Vi... I'm in.
08:43:05 <hackage> Uploaded to hackage: husky 0.2
08:43:05 <hackage> Uploaded to hackage: leksah 0.4.1
08:45:50 <bremner> Xilon: well, extensible is one thing, having the extensions is another
08:46:26 <Xilon> bremner: An abundance of extensions isn't that great either. Some packages in Emacs land are a mess.
08:47:01 <bremner> Xilon: sure, but two in particular I depend on completely. So waddya gonna do?
08:47:06 <Xilon> There could be yi extensions packaged cabal :D
08:47:21 <Xilon> with*
08:47:32 <Xilon> bremner: Port them, of course!
08:47:36 <Xilon> ;)
08:48:36 <Philonous> Would you mind having a glimpse at my code and tell me what makes it say it's less polymorphic than expected? I don't seem to find the error. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1625#a1625
08:49:19 <Philonous> This is the complete error message: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1626#a1626
08:49:29 <dcoutts> augustss: turns out the restriction will be that ghc -no-hs-main doesn't seem to work. That's what we'd want if we were linking a binary that uses a C main. I'll file tickets.
08:49:38 <redditbot> Computational Thoughts: Some examples of Software Transactional Memory in Haskell
08:52:09 <dcoutts> augustss: oh, no I'm wrong, -no-hs-main does work. I was just getting name clashed between a local real_main and the one defined in the rts.
08:53:04 <Xilon> Hmm all I need now is a Haskell shell and virtual terminal, and I can run a pure Haskell environment :P
08:54:47 <chrisdone> Xilon: are you running House?
08:55:12 <b_jonas> Xilon: are you running some sort of haskell kernel too?
08:55:14 <Xilon> nope
08:55:19 <boegel> creating a UArray Int Word8 shouldn't be a problem, right?
08:55:35 <Xilon> b_jonas: Well I meant it in the sense of a desktop environment (the apps I actually use)
08:55:55 <Cheshire> laughs at "pure" Haskell environment
08:55:56 <Xilon> ignoring all the "plumbing" (core utils, etc)
08:56:07 <b_jonas> well I for one am running a C and C++ and perl environment then
08:56:09 <Xilon> It was in jest anyway :P
08:56:42 <b_jonas> but I for one don't care what things are implemented in
08:57:13 <Xilon> I do if it brings in huge dependencies... *cough*
08:57:35 <pk_> the misterious "lal" bug strikes again
08:57:41 <Xilon> lol
08:57:41 <b_jonas> huge… meh
08:58:01 <Xilon> b_jonas: Well for some reason the Mac Haskell package is almost 0.5gb, that's pretty huge :P
08:58:16 <b_jonas> yeah, haskell is huge
08:58:27 <Xilon> On linux it's only like 100mb
08:58:30 <b_jonas> but if you compile it without profiling libraries I think it gets a bit smaller
08:58:35 <Xilon> I guess it's just packaged with more stuff
08:58:39 <bremner> ghc is big, but other compilers not so much
08:58:42 <pk_> is there another print function ?
08:58:56 <b_jonas> and if they finally succeed in making ghc use shared libraries well, it will be smaller again
08:59:08 <bremner> hugs for example fits in 500k or so on the iphone
08:59:17 <b_jonas> pk_: what do you mean by another print function?
08:59:26 <bremner> err, of course hugs is not actually a compile
08:59:30 <bremner> er
08:59:31 <pk_>  does a similar job
08:59:40 <pk_> @src print
08:59:40 <lambdabot> print x = putStrLn (show x)
08:59:46 <Xilon> Yeah I'd take the extra disk usage over the performance decrease :P
08:59:50 <pk_> @src putStrLn
08:59:51 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
08:59:54 <ozy`> Xilon: I've thought about cloning GLTerminal in HOpenGL. wanna help? :p
09:00:03 <pk_> @src putChar
09:00:03 <lambdabot> putChar c = hPutChar stdout c
09:00:08 <Xilon> ozy`: uhh... no thanks :P
09:00:16 <pk_> @src hPutChar
09:00:16 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:00:34 <b_jonas> Xilon: so you're running darcs?
09:00:34 <pk_> @src putStr
09:00:34 <lambdabot> putStr s  = hPutStr stdout s
09:00:44 <ozy`> @src hPutStr
09:00:44 <lambdabot> Source not found. Take a stress pill and think things over.
09:00:44 <pejo> pk, what is wrong with print?
09:00:45 <dolio> My haskell install on linux is 540 MB.
09:00:45 <Xilon> b_jonas: Nope
09:00:52 <b_jonas> bremner: wait, you are actually running haskell on your phone?
09:00:58 <dolio> Cabal is 65 MB, for instance. So is base4.
09:01:05 <pk_> it's very strange
09:01:14 <b_jonas> Xilon: what other version control system is written in haskell?
09:01:17 <pk_> it already happened to me this morning
09:01:21 <bremner> b_jonas: well, I installed hugs. Didn't do anything interesting with it.
09:01:25 <b_jonas> wait, I'll du mine
09:01:35 <ozy`> b_jonas: the iphone runs a stripped-down version of OS X... it can run pretty much arbitrary unix stuff
09:01:37 <bremner> b_jonas: it turns out I don't know how to use the hugs top level
09:01:48 <pk_> when I don't call it in my glut main loop, it makes everything slow
09:01:49 <dcoutts> dolio: 65 MB !!? how do you get that?
09:02:04 <Xilon> b_jonas: Err... I don't use version control >.>... ok fine, I use some C programs :(
09:02:14 <dcoutts> dolio: what are you measuring? size of libHSCabal-1.6.0.2.a ?
09:02:15 <lilac> mopped: i've annotated your hpaste
09:02:22 <mopped> ok
09:02:36 <dolio> dcoutts: Everything in /usr/local/lib/ghc-6.10.1/Cabal-1.6.0.1
09:02:53 <b_jonas> my ghc install (on x86 linux) is 590M, but that counts a few modules I've installed, and docs
09:03:09 <RayNbow> hmm... @ http://confusion.tweakblogs.net/blog/1418/why-functional-programming-doesnt-catch-on.html
09:03:22 <dcoutts> dolio: oh, so all the .hi files too. Even so, I only get 17M
09:03:37 <dolio> dcoutts: The .a file is 21M, the profiling .a is 31MB.
09:03:46 <dcoutts> dolio: wow, what arch?
09:03:58 <dolio> x86-64
09:04:39 <dcoutts> dolio: you've got something different in your setup, I'm on x86-64 linux too, .a is only 8.6M
09:04:53 <pk_> like very slow
09:04:53 <pk_> and it works with putChar too
09:04:58 <Xilon> dolio: It's only 14mb here
09:04:59 <bremner> RayNbow: send em RWH
09:05:03 <Xilon> (Mac OS, 32bit)
09:05:11 <dcoutts> dolio: did you build ghc with split-objs? or perhaps cabal with split-objs?
09:05:21 <mopped> doh, thanks lilac
09:05:23 <dolio> Well, I didn't build this myself. I installed the zip from the GHC page.
09:06:21 <dolio> So whatever /configure ; make ; make install gets you with that.
09:13:47 <Alpounet> haha
09:14:02 <Alpounet> my RWH is next to me, now...
09:14:26 <lilac> mopped: slightly cleaner version annotated (using -XPatternGuards)
09:14:34 <b_jonas> -rw-r--r-- 1 root staff 57419782 Nov  8 21:24 /usr/local/ghc/lib/ghc-6.10.1/ghc-6.10.1/libHSghc-6.10.1_p.a
09:14:41 <b_jonas> that's 57 megs in itself
09:14:51 <b_jonas> the largest file in the 500 megs
09:15:01 <b_jonas> but who cares, I have the disk space
09:15:34 <dolio> Yeah, I'm not running into space issues with ghc or anything.
09:16:26 <b_jonas> let me note that I have GAP installed and it takes 463 megs
09:17:04 <newsham> *remembers running BSD off an 80M hard drive*
09:17:56 <Alpounet> are you that old ? :-p
09:18:01 <b_jonas> oh, when I first had my own computer, I had a 2G hard drive, of which linux ran on 850 megs
09:18:03 <trofi> :]
09:18:13 <newsham> alpounet: yes.
09:19:46 <boegel> any particular reason why there's no 'union' function for Arrays?
09:19:47 <bremner> newsham: I can top that, I paid good money for a 30M harddrive for the Atari ST. I didn't have all of BSD, just TeX and helpers
09:20:08 <boegel> > array (1,5) [(1,'a')]
09:20:09 <lambdabot>   array (1,5) [(1,'a'),(2,* Exception: (Array.!): undefined array element
09:20:32 <boegel> @type array
09:20:33 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
09:20:45 <newsham> bremner: but do you still have drive images that run in an emulator?  ;-)
09:20:45 <boegel> > array (1,5) [(1,3.5)]
09:20:46 <lambdabot>   array (1,5) [(1,3.5),(2,* Exception: (Array.!): undefined array element
09:20:52 <Alpounet> @src ($)
09:20:53 <lambdabot> f $ x = f x
09:21:15 <boegel> > array (1,3) [(1,3.5),(2,7.0),(3,10.5)]
09:21:16 <lambdabot>   array (1,3) [(1,3.5),(2,7.0),(3,10.5)]
09:21:20 <bremner> newsham: ok, you win. My whole atari experience is nothing but a dim memory.  Sort of like Ada, but less painful.
09:21:31 <newsham> :(
09:21:54 <newsham> computing is so ephemeral
09:24:59 <Philonous> Why is it that when I have a function f :: (Num t) -> (Vec3 t) -> (Vec3 t) -> t and I declare g = f that suddenly g becomes (Vec3 Int) -> (Vec3 Int) -> Int ?
09:26:07 <dolio> Monomorphism restriction.
09:27:13 <Philonous> Ah gee, I keep forgeting about that -.-
09:28:11 * wli recommends {-# LANGUAGE NoMonomorphismRestriction, FlexibleInstances, FlexibleContexts, PatternGuards, PatternSignatures #-} as standard.
09:28:21 <wli> If not some superset thereof.
09:29:17 * wli may spot other options that are never worth turning off.
09:29:42 <Philonous> Thanks. That helps a lot.
09:30:03 <dolio> I use RankNTypes a lot, but maybe I'm weird.
09:32:05 <Saizan> i always start with -fglasgow-exts, and use LANGUAGE only when i get to release the code
09:33:46 <wli> NoMonoPatBinds
09:35:01 <wli> RankNTypes is probably never worth leaving turned off.
09:35:09 <Deewiant> ScopedTypeVariables
09:35:33 <wli> That one can change working code into non-working code.
09:36:04 <Deewiant> So can NoMonomorphismRestriction :-P
09:36:07 <wli> Well, compiling code into non-compiling code.
09:36:32 <wli> I didn't realize turning off the DMR could.
09:37:26 <Deewiant> For instance Philonous's example: g has types Int instead of Num a => a, which can prevent ambiguity
09:37:54 <wli> Well, that's Num, so you get defaulting.
09:38:18 <wli> I think the usual examples are read/show -based.
09:38:22 <Deewiant> Okay, bad example then. :-)
09:38:40 <Deewiant> But yes, you see the point.
09:39:08 <dolio> > map fromIntegral [1..10]
09:39:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:39:17 <dolio> Huh, didn't expect that to work.
09:39:26 <Deewiant> Defaulting again!
09:39:44 <wli> I can't actually smoke out a counterexample that wouldn't also be puked on with the monomorphism restriction on.
09:39:49 <kaol> @type map fromIntegral [1..10]
09:39:50 <lambdabot> forall b. (Num b) => [b]
09:39:52 <dolio> I actually got an error from something like that recently.
09:40:10 <Deewiant> wli: One second, I ran into this a few weeks back and might be able to dig something out of git.
09:40:32 <wli> defaulting is mostly for numeric types. Maybe a numeric-unrelated constraint was involved.
09:41:47 <wli> You've really got to dig for examples of the monomorphism restriction saving you. I can't think of how it's even plausible that the monomorphism restriction accepts a program where relaxing it doesn't.
09:43:08 <wli> Almost by definition, the thing rejects programs that would otherwise be fine.
09:43:14 <Deewiant> Okay, I found it, now let's see if I can cook up a simple example
09:44:08 <Deewiant> This is a bit complicated because Template Haskell is involved
09:44:36 <wli> The TH can probably be eliminated with some work.
09:44:55 <Deewiant> Yep, I can expand it out manually, I'm working on it :-)
09:46:10 <CTA> Heyy =D
09:47:03 <wli> I'm a bit foggier on how NoMonoPatBinds works.
09:47:25 <ddarius> wli: With defaulting, the monomorphism restriction can lead to programs that type check that wouldn't without the monomorphism restriction.
09:47:35 <dolio> @type let (x:xs) = [1..10] in x:xs
09:47:36 <lambdabot> forall t. (Enum t, Num t) => [t]
09:47:48 <CTA> Anyone here got ubuntu lol I need some help
09:48:01 <CTA> nvm lol #ubuntu
09:49:12 <dolio> @type let p@(x,y) = (6,7) in p
09:49:13 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
09:49:38 <redditbot> Interview: Lennart Augustsson on DSLs Written in Haskell
09:50:12 <dolio> @type let (x,y) = (6,7) in x
09:50:13 <lambdabot> forall t. (Num t) => t
09:50:48 <wli> Okay... let f s = show (read s + 1) in f "1" ?
09:51:37 <dolio> If you do '(x,y) = (6,7)' at the top level, it'll be monomorphic, even if the monomorphism restriction is turned off.
09:51:43 <dolio> Apparently it doesn't trigger for lets.
09:52:11 <RayNbow> > let f s = show (read s + 1) in f "1.0"
09:52:12 <lambdabot>   "* Exception: Prelude.read: no parse
09:52:16 <RayNbow> > let f s = show (read s + 1) in f "1"
09:52:17 <lambdabot>   "2"
09:52:23 <dolio> @type runIdentity $ do (x,y) <- return (1,2) ; return x
09:52:24 <lambdabot> forall a. (Num a) => a
09:53:18 <dolio> @let (foo,bar) = (6,7)
09:53:19 <lambdabot>  Defined.
09:53:21 <dolio> @type foo
09:53:22 <lambdabot> Integer
09:53:56 <MarcWeber> How would you start serializing NominalDiffTime ? The constructiors aren't exported so I can't just derive Read, Show ?
09:53:57 <CTA> Int == Integer -- I mean they the same thing in Haskell?
09:53:59 <wli> I'm still not finding something rejected by NoMonomorphismRestriction that the monomorphism restriction accepts.
09:54:10 <dolio> Int is a machine integer.
09:54:20 <dolio> Integers are abitrarily large.
09:54:34 <byorgey> > 2^5000 :: Int
09:54:35 <lambdabot>   0
09:54:40 <byorgey> > 2^5000 :: Integer
09:54:41 <lambdabot>   141246703213942603683520966701614733366889617518454111681368808585711816984...
09:55:39 <CTA> is there a "for" loop in Haskell?
09:55:42 <CTA> or any loop at all?
09:56:01 <pejo> CTA, recursion
09:56:16 <CTA> ah k
09:56:17 <byorgey> CTA: no, but you don't need it.
09:56:35 <byorgey> CTA: usually instead of a 'loop', you can, say, 'apply a function to every element of a list'
09:56:39 <byorgey> using 'map'
09:56:45 <byorgey> > map (+1) [1,2,3,4,5]
09:56:46 <lambdabot>   [2,3,4,5,6]
09:56:49 <CTA> so, what happens if i want to, print x + 10 -- 5 times?
09:57:10 <byorgey> for that you could use replicateM
09:57:21 <byorgey> replicateM 5 (print (x + 10))
09:57:35 <CTA> cool
09:57:49 <CTA> so thats like saying do this 5 times?
09:57:59 <byorgey> replicateM repeats a monadic computation a certain number of times.
09:58:00 <byorgey> right.
09:58:25 <wli> I still can't find something rejected by -XNoMonomorphismRestriction that is accepted with the monomorphism restriction in force.
09:58:29 <CTA> succ - that gives the successor of a number, whats a successor, i know it's +1 of the input but like..?
09:58:45 <m0nkfish> a successor is the opposite of a predecessor
09:58:53 <byorgey> CTA: that's right, it's just +1  =)
09:58:58 <m0nkfish> > succ 'a'
09:58:59 <lambdabot>   'b'
09:59:10 <byorgey> CTA: but it's more general, succ applies to things other than numbers
09:59:14 <Deewiant> Gah, every attempt I make at reducing this thing which otherwise depends on 1000+ lines just makes it be accepted with or without the DMR
09:59:15 <byorgey> as m0nkfish shows above.
09:59:42 <byorgey> CTA: you rarely need succ, actually.
09:59:53 <CTA> thought so
10:00:12 <RayNbow> :t replicateM
10:00:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:00:29 <RayNbow> byorgey: wouldn't replicateM_ be better?
10:00:31 <RayNbow> :t replicateM_
10:00:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
10:00:52 <byorgey> > map succ "gdkkn\USBS@"
10:00:53 <lambdabot>   "hello CTA"
10:01:05 <byorgey> RayNbow: ah, you're right, it would.
10:01:06 <CTA> is this true, "most haskell programs have functions built up from simpilier ones, e.g. doubleMe x = x + x doubleUs x y = doubleMe x + doubleMe y"                         ?
10:01:46 <byorgey> CTA: yes, that's quite true.  but that's true in most languages.  building up complicated things from simpler ones is part of what programming is all about. =)
10:01:55 <CTA> :)
10:02:01 <byorgey> CTA: but Haskell does make it particularly easy in many cases.
10:02:11 <CTA> I get the general feeling of Haskell now, not saying that I can master it..
10:02:50 <CTA> not having a IDE gets on my nerves lol =)
10:02:55 <byorgey> CTA: ah, mastering it takes many moons.  but it's a worthy goal.
10:02:59 <danl> CTA, I didn't mean to come off in a rude manner, if I did, I am sorry
10:04:16 <CTA> you never lol? =)
10:05:54 <CTA> If 'A' : " small cat" is instantanious is: "A small ca" : 't' the same?
10:06:13 <RayNbow> :t (:)
10:06:14 <lambdabot> forall a. a -> [a] -> [a]
10:06:47 <CTA> But putting something at the end of a list that's fifty million entries long is going to take a while. However, putting something at the beginning of a list using the : operator (also called the cons operator) is instantaneous.
10:07:22 <b_jonas> > let { doubleMe x = x + x; doubleUs = doubleMe <*> doubleMe; } in doubleUs 10 1
10:07:23 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
10:07:23 <lambdabot>      Proba...
10:07:28 <RayNbow> "A small ca" : 't'  -- is a type error
10:07:40 <b_jonas> > let { doubleMe x = x + x; doubleUs = (+) <$> doubleMe <*> doubleMe; } in doubleUs 10 1
10:07:41 <lambdabot>       No instance for (Num (t -> a))
10:07:41 <lambdabot>        arising from a use of `doubleMe' ...
10:08:04 <CTA> How is it Ray?
10:08:06 <b_jonas> > let { doubleMe x = x + x; doubleUs = pure (+) <$> doubleMe <*> doubleMe; } in doubleUs 10 1
10:08:07 <lambdabot>       Ambiguous occurrence `pure'
10:08:07 <lambdabot>      It could refer to either `Control.Appl...
10:08:36 <asgaroth> > ((*2) *** (*2)) 10 1
10:08:37 <lambdabot>   Couldn't match expected type `t1 -> t'
10:09:40 <RayNbow> CTA: "A small ca" has type [Char], 't' has type Char
10:10:09 <CTA> 'T' : 'LOL' is the same but opposite though?..
10:10:23 <CTA> *"lol"
10:11:22 <RayNbow> the first argument of (:) should be of type a, but the second argument should be of type [a]
10:11:55 <RayNbow> (cons takes a head as its first argument and a tail as its second argument)
10:12:13 <Deewiant> Okay, I managed to bring this down to 135 lines!
10:13:23 <_boegel_> goddamned, finding a good ADT for tackling this netflix problem is hard
10:18:12 <_boegel_> does anyone know how much overhead a list [...] has in terms of memory?
10:18:33 <_boegel_> say I have a list of 1000 Doubles, would that take 1000*8 bytes? or?
10:18:59 <dolio> More than that.
10:19:06 <ddarius> I believe each cons has three words of overhead and in the case of doubles you'd have an extra indirection.
10:19:15 <RayNbow> it probably also depends on whether the list is fully evaluated or not
10:20:55 <ddarius> You are looking at 12/24 bytes to hold the cons and the indirection plus 8 bytes to hold the double.
10:21:17 <p_l> _boegel_: If memory is really a problem, you could use binary files, lazyMmap and convert test data into in-memory format before usage...
10:23:06 <RayNbow> I still smile every time I visit the Haskell reddit and I see the new logo... (a little voice in my mind goes "YEAAAAH" everytime :p)
10:25:25 <ozy`> heh, I didn't even notice that
10:25:55 <_boegel_> ddarius: so 12/24 bytes overhead per double?
10:26:07 <ozy`> could GHC provide its own compile-and-run-bytecode facility as a library? how big would that have to be?
10:26:23 <Cale> ozy`: I think it does, actually.
10:26:31 <_boegel_> p_l: that's one way, but not really elegant :)
10:26:35 <Cale> ozy`: Basically all of GHC is available as a library
10:26:42 <_boegel_> is there a datatype smaller than Word8?
10:26:47 <ozy`> Cale: but how much of it do you have to link into your executable...?
10:26:56 <p_l> _boegel_: You wanted efficient memory use...
10:27:06 <_boegel_> I only need to be able to store numbers 1 through 5, so 8-bit is overkill for me...
10:27:15 <_boegel_> p_l: I want efficient enough to fit in 3G ;-)
10:27:43 <Cale> ozy`: Well... as much of it as you use at least? I don't know how much memory it would take... space is pretty cheap these days though :)
10:27:50 <ddarius> _boegel_: Not counting any unevaluated thunks which can be arbitrarily large.  The 12/24 is based on whether you are using 32-bit or 64-bit words.
10:28:04 <p_l> _boegel_: You could try to create a new instance of Integral with smaller data...
10:28:30 <ozy`> Cale: I'm specifically thinking about the possibility of evaluating code directly from a buffer in yi... :p
10:28:33 <Deewiant> wli: Alright, finally.
10:28:37 <Deewiant> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1627#a1627
10:28:41 <ozy`> and wondering how responsive that would be, as well
10:29:03 <ddarius> _boegel_: If you want to bitpack them, UArray Bool is a bit-vector.
10:29:23 <Cale> ozy`: yi already uses the GHC API, so it's probably not going to hurt much
10:29:33 <gwern> Cale: it's optional
10:29:39 <defun> hey are there any available parsec parsers that I could look at for examples on parsing?
10:29:45 <wolverian> Cale: does Yi use the GHC API directly, or via mueval or such?
10:29:46 <_boegel_> ddarius: would creating a 3-element UArray Bool save me 5 bits of a Word8?
10:29:51 <gwern> he'd need to compare -fghcapi versus not
10:29:52 <_boegel_> p_l: hmm
10:29:55 <ddarius> _boegel_: No
10:29:57 <Cale> wolverian: Directly from what I understand.
10:30:01 <wolverian> thanks.
10:30:06 <gwern> wolverian: directly, via the copy of shim
10:30:12 <_boegel_> ddarius: but it would save me some bits?
10:30:13 <wolverian> ah, right.
10:30:19 <gwern> since shim isn't maintained, yi had to copy it in directly...
10:30:24 <ddarius> _boegel_: You'd have to stick several into one bit vector to get a savings.
10:30:33 <_boegel_> ddarius: hmm, I see
10:30:46 <_boegel_> ddarius: that's one option indeed...
10:30:59 <ddarius> _boegel_: You can get anything smaller than a word in an unpacked data structure.
10:31:17 <wli> I don't quite understand the example.
10:31:30 <wolverian> my main problem with yi at the moment is the syntax highlighting for haskell, which colours all functions cyan...
10:31:30 <ddarius> I.e. a Word8 still takes up 32/64-bits unless you are talking about e.g. an array of them.
10:31:40 <_boegel_> ddarius: could you elaborate on what unpacked exactly means?
10:32:01 <_boegel_> ddarius: hmm
10:32:12 <_boegel_> ddarius: interesting, I never looked at it that way
10:33:01 <_boegel_> I guess that's way my [(Int,Word8)] approach to avoid an expensive Array Int Word8 (because the array would be sparsely filled), doesn't work
10:33:36 <Deewiant> ddarius: even if strict?
10:33:47 <Deewiant> i.e. data Foo = Foo !Word8
10:34:09 <p_l> _boegel_: I was talking about representing memory in efficient way (for an emulator project) with Baughn, he redirected me to uvector. Might be of use
10:34:26 <_boegel_> p_l: any references to that?
10:34:45 <p_l> _boegel_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uvector-0.1.0.3
10:35:06 <ddarius> Deewiant: Word8 by itself takes up a whole machine word in most context.  If you do that (with -funpack-strict-fields) you'll save the indirection but the field will still be a word wide.
10:35:41 <ddarius> Deewiant: I'm pretty sure that if you did something like data D = D !Word8 !Word8 !Word8 !Word8 it would still take up four words (but maybe not in that case).
10:36:11 <lilac> Deewiant: i can't see why your examples fails with -XNoMonomorphismRestriction -- surely the functional dependency is enough to resolve that fst'' :: (String, Int) -> String ?
10:36:16 <Deewiant> Hmh, that's unfortunate.
10:36:30 <Deewiant> lilac: I haven't thought about why it does, I just know that it does. :-P
10:36:43 <wli> The Void Int type signature is crucial.
10:36:51 <Deewiant> Yep.
10:37:13 <Deewiant> I can't reduce that example at all without inadvertently making it compile.
10:37:33 <wli> It's reduced enough.
10:37:52 <Deewiant> The type signature for 'void' is crucial as well.
10:38:03 <p_l> _boegel_: Though my problem is easier since I can always use an IOUArray of Word64 for my purposes :)
10:38:34 <_boegel_> :)
10:38:37 <lilac> i don't get the "No instance for (Id [Char] b)". surely it should deduce that it needs (Id a [Char])?
10:39:03 <lilac> (because x :: (String, Int) from the Void Int signature)
10:39:19 <ddarius> _boegel_: An UArray of indices and a UArray of Word8 would probably be the simplest sparse array.  This would lead to 5/9 bytes per Word8.
10:39:36 <wli> I suspect shorter examples won't resemble this at all.
10:39:36 <p_l> _boegel_: Also, I've got a cache (with it's own idiosyncracies) to implement, so I only really need to care about direct access to memory for uncached ops :)
10:39:45 <wli> Is this something involving phantom types?
10:41:00 <Deewiant> wli: No, the type values are used. (In this case the Void isn't for simplification.)
10:41:20 <Deewiant> s/type/types'/
10:41:58 <ddarius> (uvectors instead of UArrays would also work and probably be nicer to use)
10:42:32 <lilac> so it deduces that x :: forall a. Id String a => (a, Int)
10:42:40 <_boegel_> ddarius: hmmk
10:43:57 <lilac> that seems somewhat broken, since in order to get the 'String' there it needs to have already assumed that a is String
10:44:09 <Deewiant> Have I found a GHC bug? :-)
10:44:11 <Cale> ISTR a UArray of Bool will pack the bits together in memory.
10:44:27 <ddarius> Cale: I said that above.
10:44:33 <Cale> oh, okay good :)
10:44:57 <ddarius> Also _boegel_ left.
10:45:13 <lilac> Deewiant: well, a smarter typechecker could accept this code. does that make this a compiler bug?
10:45:33 <Deewiant> Not necessarily
10:45:43 * wli notes there's a huge boilerplate lhs2TeX thing he's been passing around and ponders cpp.
10:46:20 <Deewiant> We'd have to look at the definition of the MR and be certain that turning it off should not affect that code
10:46:32 <Deewiant> http://www.haskell.org/onlinereport/decls.html#sect4.5.5
10:46:40 <olsner> source -> cpp -> tex-ifier -> tex -> pdf? gotta love those intermediates :)
10:46:59 <lilac> Deewiant: we'd also have to look at the definition of functional dependencies
10:47:17 <Deewiant> Well yes, and a lot of other stuff. :-)
10:47:32 <wli> What's the latest replacement for fundeps? Associated types or type families?
10:47:42 <Deewiant> wli: Yes.
10:47:44 <Cale> wli: those are the same thing
10:47:48 <Cale> ;)
10:48:16 <Deewiant> lilac: Alternatively I could just report it and have a Simon tell us ;-)
10:48:21 <Cale> Associated types are just type families whose definition is attached to a class, basically.
10:48:50 <Cale> (and if you turn on the TypeFamilies extension, I believe you get both)
10:49:04 <lilac> Deewiant: it certainly looks like it needs to have assumed that x :: (String, Int) in order to find the type of fst'', and then 'rediscovers' a more general (non-working) type for x
10:49:39 <redditbot> Interesting ... evaluation Haskell expressions inside a running xmonad instance
10:49:39 <redditbot> Help improve the Language Shootout Rankings further: submit parallel programs for missing benchmarks!
10:49:39 <redditbot> Bryan O'Sullivan speaking about Haskell .. at an Erlang conference
10:49:39 <redditbot> AVar changes - Data.Random
10:49:39 <redditbot> FP-Syd: Sydney FP Group: FP-Syd #12 summary
10:53:56 <Deewiant> lilac: void x :: Void Int  -->  x :: (String,Int)  -->  id' a :: String  -->  id' :: Id a [Char] => a -> String  -->  id' :: String -> String [via fundep]  ?
10:54:39 <Deewiant> Seems straightforward to me and I don't see why the MR would affect that.
10:55:00 <CTA> Is this code fine: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1628#a1628 like I mean am I doing everything right/"okay" lol?
10:55:15 <Deewiant> And inferring the type of fst' should be trivial.
10:56:00 * lilac wonders if it's possible to get irssi to filter out the word 'lol'
10:56:24 <CTA> sorry, I won't use it anymore
10:56:27 <glguy> You can have irssi filter out whole lines containing the offending word
10:56:30 <Deewiant> lilac: Only lines containing it, I think.
10:56:44 <lilac> alas :)
10:56:57 <CTA> Well, can you see if my code is "okay" and if I'm doing everything correctly please?
10:57:18 <glguy> CTA it looks like it would compile
10:57:19 * ddarius sees little point in filtering out the "word"
10:57:35 <glguy> CTA, if you ask more specific questions you might get better results..
10:57:54 <glguy> are you asking about formatting?
10:58:09 <lilac> CTA: if it were my code, i'd remove lines 2 and 7, and combine lines 3 and 4, and lines 8 and 9 onto one line each
10:59:05 <CTA> ah kk, and yeah I mean my standards, are they okay and readiable?
11:02:56 <DrSyzygy> > length "diffeomorphism"
11:02:57 <lambdabot>   14
11:03:35 <DrSyzygy> > length "homeomorphism"
11:03:36 <lambdabot>   13
11:03:42 <Philonous> @type (^)
11:03:43 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:03:45 <K6HX> hmm.  that reminds me.
11:03:49 <Philonous> @src (^)
11:03:49 <lambdabot> x ^ 0            =  1
11:03:49 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:03:49 <lambdabot>   where f _ 0 y = y
11:03:49 <lambdabot>         f x n y = g x n
11:03:49 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
11:03:51 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:03:53 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:03:53 <Philonous> @src (^^)
11:03:55 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
11:05:20 * CTA runs in terror
11:06:35 <Deewiant> Alright, unless somebody can tell me why http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1627#a1627 doesn't compile I'm going to report it as a GHC bug. Any takers?
11:10:52 <glguy> Deewiant, you are missing a fundep a -> b on your Id class?
11:11:14 <Deewiant> glguy: I'm only questioning why the code works when NoMonomorphismRestriction is removed
11:11:18 <glguy>  No instance for (Id [Char] b) knowing [Char] isn't enough to pick an instance
11:11:35 <Deewiant> Yes, but where does it get Id [Char] b
11:11:54 <Deewiant> glguy: What I said earlier: void x :: Void Int  -->  x :: (String,Int)  -->  id' a :: String  -->  id' :: Id a [Char] => a -> String  -->  id' :: String -> String [via fundep]  ?
11:12:37 <CTA> Is String an alias for [Char] ?
11:12:42 <Baughn> Yes
11:13:23 <CTA> So doing lol :: [Char] -> [Char] is the same as String -> String?
11:13:29 <Deewiant> Yes
11:14:04 <glguy> with the MR off, line 17 stays polymorphic?
11:14:28 <trofi> @src String
11:14:28 <lambdabot> type String = [Char]
11:14:52 <Deewiant> glguy: What do you mean?
11:15:13 <eu-prleu-peupeu> hello
11:15:27 <glguy> with noMR, the y= line has no effect on x
11:15:39 <Deewiant> And why not?
11:15:49 <Cale> That's not quite true...
11:15:55 <Deewiant> (void x :: Void Int) should still apply
11:16:02 <Deewiant> Which should nail down x
11:16:14 <CTA> do you just use "let" in GHCi?
11:16:15 <glguy> or, x stays polymorphic
11:16:20 <glguy> and y= only uses it in one way
11:16:28 <Cale> Commenting out the y = void x line will make it compile with noMR
11:16:31 <Deewiant> Ah! That makes sense
11:16:42 <Deewiant> But that's true and that doesn't.
11:16:56 <glguy> Cale, I don't think so
11:17:03 <Cale> try it.
11:17:04 <Deewiant> glguy: It does.
11:17:13 <glguy> it doesn't here
11:17:16 <Deewiant> glguy: That was the whole point, removing pretty much anything will make it compile.
11:17:20 <Deewiant> glguy: Oo! GHC version?
11:17:22 <glguy> I tried it here before disagreeing
11:17:31 <Cale> 6.10.1 here
11:17:40 <glguy> NOMR, and y= commented doesn't work in 6.10.1
11:17:51 <chrisdone> vgrabbj can output images to stdout one after the other. how can I distinguish these images so that I can read them in with libgd one after the other?
11:17:52 <Deewiant> O_o
11:17:53 <glguy> ah
11:17:54 <Cale> Eh?
11:17:57 <glguy> I had added a type sig
11:17:59 <Cale> oh
11:18:00 <glguy> when experiementing
11:18:13 <Deewiant> "ah" "eh?" "oh" heh
11:18:57 <chrisdone> I was thinking maybe libgd might lazily read in only what it needs to of the image, so I could read directly from the Handle with hGetContents and give it to the libgd image function, but... I doubt this is true...
11:19:00 <olsner> "O_o" "ah" "eh?" "oh" :)
11:19:18 <olsner> mutually assured incomprehension?
11:19:20 <Deewiant> glguy: Any other ideas?
11:19:36 <chrisdone> unsafePerformCommunication
11:20:34 <glguy> Deewiant, Deewiant about what?
11:20:46 <Deewiant> glguy: As to why it doesn't work.
11:21:03 <glguy> without the MR, there is nothing to make x pick an instance
11:21:06 <Deewiant> "x stays polymorphic" makes sense
11:21:08 <glguy> by using it in y
11:21:14 <Deewiant> Yes
11:21:20 <Deewiant> But why does it then work if y is removed
11:22:01 <glguy> Deewiant, because of your weird b->a dependency
11:22:05 <Deewiant> If I understood you correctly and the way I see it now, the 'y =' line is a no-op
11:22:16 <Cale> Deewiant: Interestingly TypeFamilies handle this better.
11:22:30 <Deewiant> fst'' :: (Id t b, Fst (b, t1)) => (t, t1) -> String
11:22:31 <Cale> I'll post a revision
11:22:36 <Deewiant> That's what it gets when y is removed
11:23:06 <Deewiant> Cale: FWIW I'm not worried that it doesn't work with NoMR, in my actual case I can fix that with a single type signature :-)
11:23:29 <Deewiant> glguy: Why would the above type not apply with the 'y =' line?
11:23:38 <defun> quick noob question, when would one use >> instead of >>=  ?
11:23:39 <Cale> Deewiant: Yeah, I think this is a strangeness about how fundeps work.
11:23:58 <mauke> defun: when the function to the right of >>= doesn't use its argument
11:23:58 <Cale> defun: When one doesn't care about the result of the action on the left, only its effects.
11:24:02 <Deewiant> defun: '>>= \_ ->' can be replaced with '>>'
11:24:04 <mauke> @src (>>)
11:24:04 <lambdabot> m >> k      = m >>= \_ -> k
11:24:14 <defun> thanks
11:24:39 <Gracenotes> however, you can still use the result of previous actions :)
11:24:40 <Cale> Deewiant: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1627#a1630
11:24:51 <PeakerWork> (>>) can be replaced with liftA2 (flip const) :-)
11:24:53 <Cale> Deewiant: Check it out, that works fine :)
11:25:00 <CTA> http://www.haskell.org/haskellwiki/Guess_a_random_number that's a SIMPLE game o.O?
11:25:01 <Gracenotes> so it's not like you're losing all your data by doing >>
11:25:10 <Cale> Deewiant: So one way to get around your problem might just be to switch to type families.
11:25:11 <Deewiant> Cale: but not in Hugs! ;-)
11:25:16 <Cale> bah, hugs
11:25:19 <Deewiant> Like said, I don't have a problem.
11:25:25 <glguy> Deewiant, have you tried writing the explicit type sig for fst''?
11:25:35 <glguy> Does this look right? fst'' :: (Fst (b,Int), Id String b) => (String,Int) -> String
11:25:55 <Cale> Deewiant: Does the code with fundeps work in hugs?
11:26:29 <Plouj> hi
11:26:34 <Deewiant> glguy: Giving it the general type makes it require FlexibleContexts and then bail out with even more errors
11:26:35 <Cale> Oh, interesting. With TFs the inferred type is: fst'' :: (Idt t ~ [Char], Id t) => (t, Int) -> String
11:26:39 <glguy> Deewiant, if what I wrote looks right, then it is obvious why it can't work
11:26:49 <Plouj> is there a way to trace haskell functions similar to how Real World Haskell shows them, but in GHCi?
11:27:03 <Cale> So it ends up needing a type equality!
11:27:43 <Cale> er, oh, I see.
11:27:44 <Deewiant> Currently I'm more interested in why it does work if the 'y =' line is removed.
11:27:47 <Cale> I translated incorrectly :)
11:28:03 <glguy> Deewiant, I'm trying to explain that to you  but you haven't answered yet
11:28:08 <Cale> yeah, if  id' :: Idt a -> a
11:28:11 <Deewiant> Cale: I haven't actually tried Hugs, I suppose I'd have to install it first
11:28:13 <Cale> then the inferred type is
11:28:16 <Cale> fst'' :: (Idt String, Int) -> String
11:28:23 <Deewiant> glguy: Looks correct to me, yes.
11:28:31 <glguy> Deewiant, then there is no way to pick the instances
11:28:36 <glguy> Deewiant, the 'b' doesn't appear in the type
11:28:42 <Deewiant> Yes, that is clear to me.
11:28:45 <glguy> but it needs to be known to pick an instance
11:29:31 <jeffwheeler> There are a bunch of sqlite packages on Hackage; for fairly simple tasks, is there any reason I should pick one over another?
11:29:40 <Deewiant> glguy: I understand all this. But as you said earlier, x should stay polymorphic regardless of y, so fst'' should not get a type containing Int.
11:29:44 <jeffwheeler> Or, I should say, which should I use for simple tasks?
11:29:44 <dons> level of abstraction, jeffwheeler
11:30:14 <jeffwheeler> dons: Then, what's the highest level? :)
11:30:38 <dons> here, http://archhaskell.wordpress.com/2009/02/16/haskelldb-high-level-type-safe-database-queries-for-haskell/
11:30:52 <jeffwheeler> dons: thanks
11:31:38 <glguy> Deewiant, I think it must be a bug that GHCi infers the following type with MR and no y= fst'' :: (Id t b, Fst (b, t1)) => (t, t1) -> String
11:31:43 <glguy> but that it doesn't allow you to specify that
11:32:10 <Deewiant> With MR it gets fst'' :: ([Char], Int) -> String, of course
11:32:22 <Deewiant> I guess you meant to say 'without MR' :-)
11:32:31 <glguy> without MR and withour y=
11:33:07 <Cale> adding an extra fundep also helps
11:33:10 <Cale> class Id a b | a -> b, b -> a where id' :: a -> b
11:33:15 <Cale> will fix the problem
11:33:31 <glguy> yeah, then the original ambiguous 'b' isn't ambiguous
11:33:33 <Deewiant> Cale: Hugs also gets fst'' :: ([Char], Int) -> String but I'm not sure whether it's using the MR or not
11:33:48 <Cale> unless you turned it off, it would be
11:33:57 <glguy> Poor innocent fundeps have  been neglected with the shiny new Type Families in town
11:33:58 <Deewiant> I don't know how to turn it off :-P
11:34:02 <Cale> er, well, I'm not sure if it supports that extension
11:34:44 <Deewiant> Hmm, I suppose it might not
11:35:17 <Deewiant> Welp, guess I'm filing a bug.
11:36:30 <Cale> I still haven't managed to work out if it really is a bug
11:38:03 <Deewiant> Hmm, actually the reason it rejects fst'' :: (Id t b, Fst (b, t1)) => (t, t1) -> String is the good old fundep problem: it can't unify 'b' and the 'b1' it infers
11:38:15 <Deewiant> That explains that, at least
11:38:45 <Deewiant> But I still think it should infer that type regardless of the 'y =' line.
11:38:56 * pumpkin_ yawns
11:39:04 <b_jonas> aren't fundeps just more general?
11:39:09 <Cale> When you get right down to it, fundeps are strange.
11:39:18 <Cale> b_jonas: They're equally general.
11:39:20 <Heffalump> what's strange about them?
11:39:30 <b_jonas> both are strange
11:39:38 <Heffalump> fundeps are fully implemented, though
11:39:40 <b_jonas> both fundeps and dependent types are strange
11:39:51 <Heffalump> but type families allow for actually inferring equalities
11:39:53 <Cale> b_jonas: associated types you mean?
11:40:12 <b_jonas> Heffalump: as much as type classes are fully implemented
11:40:32 <b_jonas> Cale: something like that. whatever that functional type thing with the tildes is
11:40:35 <Heffalump> to the extent that they have a spec, they are fully implemented
11:41:00 <Heffalump> if I want to generate commuting diagrams or similar, what's the best package to use?
11:41:28 <Heffalump> hi andyjgill
11:41:35 <ddarius> Heffalump: In what context, TeX?  (If so, I recommend xypic)
11:41:45 <andyjgill> hi Heffalump
11:41:53 <Heffalump> ddarius: from Haskell
11:43:00 <Deewiant> Cale: it seems a rather clear bug to me that it cares about that 'y =' line.
11:43:31 <b_jonas> I still don't really understand how classes and modules work together
11:44:23 <wli> In Haskell, the approach seems to be "neuter modules until classes and modules scarcely interact anymore."
11:45:05 <Cale> b_jonas: instances are always exported, and always imported.
11:45:06 * jeffwheeler just fell in love with 'cabal unpack' --- that is awesome
11:45:06 <ddarius> Heffalump: Possibly the easiest thing to do would be to use graphviz if you can control it well enough.  Possibly the blobs, diagrams, dotgen.
11:45:24 <Cale> b_jonas: That's about all there is to say about the interaction :P
11:45:27 <dolio> In the sense that Haskell doesn't have ML-like modules, just like 99% of all other languages?
11:45:48 <wli> Yeah.
11:45:52 <b_jonas> oh sure
11:46:04 <b_jonas> the only other language with ml-like modules is D, isn't it?
11:46:05 * wli is probably a loon for wanting ML-like modules in C.
11:46:19 <b_jonas> wli: wait, D doesn't have them?
11:46:25 <Deewiant> Cale: I'll file it for now and have SPJ figure it out :-)
11:46:29 <b_jonas> I probably have to review what D templates really are
11:46:30 <Cale> Deewiant: okay :)
11:46:33 <monochrom> modula-3, ada
11:46:40 <bremner> what are ML like modules?
11:46:51 <wli> I don't know. I'm usually stuck with whatever version of C mainline Linux is using.
11:46:56 <b_jonas> bremner: what standard ML has
11:46:57 <Deewiant> b_jonas: I don't know anything about ML-like modules but I do know some things about D templates
11:47:06 <monochrom> parameterized modules
11:47:13 <dcoutts> jeffwheeler: it is isn't it :-) we've got Saizan to thank for that feature.
11:47:15 <b_jonas> I don't know anything about anything really
11:47:33 <b_jonas> I scarcely remember what standard ML modules did too
11:47:36 <wli> Also nested modules and exports thereof.
11:47:37 <b_jonas> so I'm just guessing here
11:47:53 * wli used to love the fully functorial style.
11:48:09 <Cale> bremner: Basically, modules have signatures consisting of the names of things they export and the types involved. Different modules might implement the same signature, and you're allowed to have modules which are functions of other modules in that way.
11:49:36 <b_jonas> let me see...
11:49:40 <redditbot> "EHC/UHC aims to be a full Haskell98 compiler with extensions"
11:49:40 <b_jonas> http://digitalmars.com/d/2.0/template.html
11:50:06 <Cale> bremner: So, you can tell one library to use a particular implementation of another when importing it.
11:50:37 <bremner> Cale: thanks. It rings a vague bell from Concepts, Techniques and Models (Haridi and Van Roy)
11:52:56 <BONUS> is typeable mostly used for turning stuff that's contained in foralled ADTs into normal types
11:53:01 <BONUS> or are there other uses as well
11:54:58 <b_jonas> ok, apparently D templates have nothing to do with ML modules
11:55:11 <b_jonas> I'm still reading what D templates are about
11:57:44 <Cale> BONUS: hmm... not quite sure what you mean by foralled ADTs :)
11:58:04 <BONUS> like when you have
11:58:05 <Cale> BONUS: But it's used to implement Data.Dynamic
11:58:18 <BONUS> data Foo = forall a. Typeable a => Foo a
11:58:30 <Cale> ah, existential types
11:58:40 <BONUS> and then you can but different Typeable instances in there and then get them out by using cast
11:58:48 <Cale> yes, you can do that.
11:58:54 <BONUS> sort of like Data.Dynamic i guess yeah
11:59:14 <Cale> It's also used in Data.Generics
11:59:39 <BONUS> is there a lot of magic involved in Typeable and Dynamic? i've been reading about them and seeing how to use them, but i've just glanced over the implementation
12:00:01 <PeakerWork> Where would you really use them?
12:00:02 <Cheshire> no magic
12:00:38 <Cale> Not *much* magic anyway
12:00:41 <BONUS> PeakerWork: Typeable in the new scheme for exceptions
12:00:55 <Cale> unsafeCoerce is involved in implementing cast for Typeable
12:01:00 <PeakerWork> BONUS: Sounds like a bad idea to me
12:01:11 <Cale> and writing instances of Typeable by hand ought to be forbidden
12:01:17 <pejo> Cale, is the implementation that really?
12:01:20 <monochrom> There is no magic in Typeable because you have to write your own instance for each of your type (in theory; in practice it's so obvious the compiler can write it for you).
12:01:21 <Cale> You can break the type system by writing bad instances of Typeable.
12:01:56 <ddarius> There is a more cumbersome and less efficient way of implementing Typeable that doesn't require unsafeCoerce.
12:02:06 <Cale> Really?
12:02:19 <Cale> How does it work?
12:02:37 <ddarius> http://citeseer.ist.psu.edu/692677.html
12:02:46 <dolio> You can use GADTs.
12:02:58 <dons> you shouldn't really be able to write Typeable instances
12:03:13 <b_jonas> dons: why?
12:03:16 <dolio> And if you don't have GADTs, you can use identity coersions instead, which is probably what that paper uses.
12:03:22 <dons> anymore than you should be able to declare your own arbitrary typing rules
12:03:28 <b_jonas> what? break the type system?
12:03:40 <b_jonas> the type system can't be broken, that's the whole point of a type system
12:04:00 <b_jonas> oh, it's using unsafeCoerce?
12:04:00 <Saizan> you can get unsafeCoerce back from cast with the right instance
12:04:01 <b_jonas> hmm
12:04:04 <pumpkin_> unsafeCoerce yeah
12:04:13 <b_jonas> what's the poing
12:04:20 <ddarius> dolio: Yeah, the paper could probably be reworked using GADTs.
12:05:01 <ddarius> I believe this paper does something like that using a proposed idea that is a predecessor to GADTs: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.70.4267
12:05:33 <Cale> b_jonas: the point of what?
12:06:08 <mopped> How would I represent a graph in Haskell? Being able to link nodes, and have a length inbetween asid nodes?
12:06:35 <ddarius> mopped: There are several ways and a few libraries for it already.
12:07:11 <Cale> mopped: I like  Map Vertex (Set (Length, Vertex))
12:07:46 <mopped> what would the minimalistic way? I'd rather not use any libraries and such, but I cant think of a way other than dictionaries (imperative thinking!), perhaps a list of 3ples (a, b, length) or so?
12:07:57 <Cale> mopped: Data.Map
12:08:00 <Cale> and Data.Set
12:08:04 <mopped> ok
12:08:22 <pejo> ddarius, could you give a hint about which paper you're linking to for those of us who are web cahllenged? :-)
12:08:41 <Cale> mopped: Data.Map is an efficient pure finite map (dictionary) implementation, and Data.Set is an efficient implementation of sets.
12:08:42 <b_jonas> Cale: the point of the type system is that it can't be broken, but then if it's using unsafeCoerce then it still can be
12:08:56 <jeffwheeler> Many of the db packages on Hackage don't work with 6.10, but all the current development versions seem to work fine (e.g. hsql-sqlite3); the new versions just need to be uploaded to Hackage!
12:08:58 <ddarius> pejo: The first was "A lightweight implementation of generics and dynamics" the second is "First class phantom types"
12:09:31 <Cale> b_jonas: Right, well, the purpose of unsafeCoerce is to allow you to do things which are safe in the end but which the type system isn't powerful enough as-is to prove are safe.
12:10:17 <Cale> b_jonas: So it's a way of saying "I take responsibility for the proof that I'm using these values in a type-safe way."
12:11:20 <_boegel_> ddarius: I've been trying the suggestion you had, i..e using two UArrays to keep track of indices and Word8's, but it seems I have something like 400-450 bytes / Word8 I keep track of
12:11:25 <Cale> Heh, perhaps it ought to be called unsafeTakeResponsibilityForTheProofThatTheUseOfThisValueIsTypeSafe
12:11:35 <_boegel_> which is a lot more then I was expecting, obviously :)
12:11:46 <Cheshire> I think that we should not have any unsafe functions
12:12:03 <Cheshire> clearly we are too weak to resist using them all the time everywhere
12:12:08 <Cale> Cheshire: I think they're a good thing to have, but they're not currently controlled strictly enough.
12:12:28 <_boegel_> ddarius: how much overhead does a UArray have? is there a fixed amount of overhead per UArray, or per UArray element? I assume the former, but...
12:12:32 <Cale> It should require an extra commandline flag to compile a module which uses them.
12:12:42 <Eridius> Haskell should prevent you from using unsafe functions unless you've published a paper ;)
12:12:47 <Cale> and unsafety should default to being hereditary
12:13:25 <Cale> (except with the use of a pragma to explain that you're really sure that it's safe)
12:13:50 <Cheshire> Human nature:  Give a problem and a choice  (1) solve it tommorow  (2) make some crap ad-hoc progress right now .. we always choose (2)
12:14:00 <ddarius> _boegel_: A UArray should be a pointer to an array and a length (plus normal heap object overhead), so you have a few words per UArray.
12:14:02 <Cheshire> unsafe functions are often (2) solutions
12:15:09 <Cale> Cheshire: Well... I think that's perhaps being too harsh. You need unsafePerformIO and the like in order to properly implement a lot of basic data structures efficiently -- ByteStrings for example.
12:15:24 <Cale> It gives us a way to add new language primitives.
12:15:46 <pejo> Eridius, publishing papers doesn't make you a good programmer.
12:15:56 <_boegel_> ddarius: so I must be doing something horribly wrong then...
12:15:56 <Cale> But it really ought to be treated with the same gravity as adding something to the compiler.
12:16:00 <Eridius> no, but it adds a hurdle to prove you're serious ;)
12:16:30 <_boegel_> ddarius: or could it be related to the fact that my data is _very_ sparse, i.e. ~1.2 of the 'matrix' elements are filled
12:16:48 <_boegel_> > 1e8 / 480000
12:16:49 <lambdabot>   208.33333333333334
12:17:02 <ddarius> _boegel_: Possibly.  If you are "modifying" the UArray a lot, you are doing something wrong.  More likely the memory use you are seeing is from loading in the data.
12:17:03 <monochrom> I think (1) and (2) are a false dichotomy. Here is a true dichotomy: (A) prove that the solution solves the problem. (B) intuit that the solution solves the problem.
12:17:03 <_boegel_> on average, each (pair of) UArrays has only 208 elements
12:17:31 <ddarius> _boegel_: You should be aiming (ideally) at one big UArray.
12:17:48 <_boegel_> ddarius: well, once the data is read in, I only need read access
12:18:06 <_boegel_> ddarius: constructing the UArrays is probably far from ideal right now though
12:18:21 <_boegel_> ddarius: well, now I have 480k x 2 UArrays
12:18:22 <_boegel_> :)
12:18:37 <_boegel_> > 480000*2*4
12:18:38 <lambdabot>   3840000
12:18:42 <_boegel_> > 480000*2*4 / (^230)
12:18:43 <lambdabot>       No instance for (Fractional (a -> a))
12:18:43 <lambdabot>        arising from a use of `/' ...
12:18:45 <_boegel_> > 480000*2*4 / (2^30)
12:18:46 <lambdabot>   3.5762786865234375e-3
12:18:51 <michaelcdever> hey could someone tell me why Control.Exception.catch won't catch exeptions on this? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1631#a1631 all it does is create a pixbuf from a filepath
12:19:16 <_boegel_> it doesn't seem like the overhead of the UArrays is what's killing me
12:20:16 <Saizan> michaelcdever: i think the scope of the catch is not the one you're thinking
12:21:11 <Saizan> try this: (pixbufNewFromFile =<< iconpath ( IconDetails ( tail name ) )) `E.catch` (\_ -> putStrLn( "here" ) >> iconpath ( IconDetails "Open" )
12:21:42 <ddarius> _boegel_: Oh, incidentally, if you are just storing bytes you can just use bytestrings.
12:22:30 <olsner> is it possible that you have uarray constructions in thunks, referring to large structures of thunks that haven't been put into the array yet?
12:23:01 <ddarius> olsner: The pointer to the UArray can be a thunk, but once it's forced all the elements will be forced as well.
12:23:20 <olsner> yeah, I was referring to the pointer to the UArray
12:24:00 <olsner> if you have a lot of those arrays I guess it could add up
12:24:12 <_boegel_> olsner: the way I'm doing it now, the arrays grow one element at a time, i.e. I merge one array I already have with an array of just one element
12:24:22 <michaelcdever> Saizan: but theres a missing brace there...
12:24:28 <_boegel_> and I do that _a lot_, but that seems fine to me, at least in terms of space usage
12:24:45 <_boegel_> the old arrays should just be thrown away by the garbage collector
12:24:45 <Saizan> michaelcdever: oh, sorry, add ) at the end
12:25:15 <ddarius> _boegel_: If you are not forcing as you go, that could build up into a large thunk.
12:25:34 <_boegel_> olsner: the UArrays are in a Data.Map with (UArray, UArray) as values, and Int as key
12:25:54 <_boegel_> ddarius: forcing what? and how, using seq you mean?
12:26:07 <olsner> hmm, so I guess you'd need to make sure you force both arrays before storing them in the map
12:26:19 <mopped> What's the correct version of: data Graph a = (Num b) => [(a, a, b)]
12:26:20 <ddarius> forcing the "merges" and using seq directly or indirectly somewhere
12:26:30 <drhodes> Are there generic concurrent data structures available, for example, ConcurrentMap - where lookup/insert times are improved?
12:28:46 <dons> are improved by what?
12:28:49 <dons> having concurrent access?
12:29:18 <dons> there are some (hunt around on hackage). haskell data structures are by default thread safe, so you can often write algorithms for them using `par` and friends to also gain performance speedups
12:29:32 <dons> see e.g. Control.Parallel.Strategies for parallel functions on the default thread safe data structures
12:31:52 <LouisJB> even though I'm unlikely to use haskel at work atm, would it be worth me learning it? I'm currently learning scala and wondered if haskell would be a good suppliment to all things functional and lazy
12:32:20 <wli> omfg mutable array stuff is a total nightmare
12:33:00 <_boegel_> olsner: hmm, I see
12:33:25 <olsner> or maybe construct the arrays in their final size by a different algorithm
12:33:35 <_boegel_> ddarius: I'm using unionWith to merge the UArrays, that might be the problem
12:34:00 <amaron> anyone knows good haskelldb tutorial?
12:34:19 <_boegel_> @src Data.Map.unionWith
12:34:19 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:34:46 <olsner> oh, that'd definitely leave the uarrays as thunks, I think
12:35:21 <Axman6> wli: how so?
12:35:22 <Deewiant> yep, there's no unionWith'
12:35:27 <_boegel_> olsner: hmmk
12:36:27 <pejo> LouisJB, learning a couple of different programming paradigms is very useful.
12:36:30 <tibbe> @type allocaBytes
12:36:31 <lambdabot> Not in scope: `allocaBytes'
12:37:14 <LouisJB> pejo: that's what i was thinking, scala is my first adventure into fp from a load of oo and imperative languages, I like it
12:37:26 <LouisJB> is there a definitive book / paper / text?
12:37:36 <_boegel_> olsner: I guess I could use update...
12:38:10 <Deewiant> _boegel_: BTW, with Int as key, IntMap would probably be faster
12:38:59 <olsner> hmm, update would probably be nlogm rather than n+m though
12:39:17 <_boegel_> Deewiant: hmmk, thanks
12:39:21 <olsner> maybe just add some $!'s in the combining functions would do it
12:39:35 <Deewiant> I doubt it
12:39:42 <Deewiant> since it probably doesn't evaluate the functions strictly
12:39:48 <_boegel_> olsner: I don't care about construction time, memory usage is my main concern when reading the data
12:39:55 <pejo> LouisJB, real world haskell (RWH) is available online, and lots of people like it. I've heard good things about Graham Hutton's "Programming in Haskell" as well. There's plenty of tutorials available online if you do not wish to buy a book however.
12:40:03 <sjanssen> olsner: it won't, unionWith places no demand on the result of the function
12:40:06 <Deewiant> but of course you can do something like 'rnf toList'
12:40:07 <wli> Getting the existential in ST/STArray to stop escaping requires some horrendous contortions.
12:40:15 <Deewiant> 'rnf . toList', that is
12:41:03 <olsner> oh, right, would still need that unionWith'-like thing to force the seqs
12:42:09 <ddarius> A really hacky solution would be to "just do it" and then after each little UArray finishes being built, seq the entry.
12:42:09 <olsner> hmm, what would happen if you replace the pair with something like P !UArray !UArray?
12:42:44 <sjanssen> olsner: that still won't work, the pair itself is never forced
12:42:51 <olsner> d'oh, yeah, that'd probably still be wrapped in a box on the outside
12:43:24 <LouisJB> pejo: thanks, will take a look at that
12:43:33 <Deewiant> the Map/Set APIs are somewhat weird
12:44:01 <Deewiant> deficient in terms of strictness and yet there's useless stuff like insertWithKey
12:44:14 <Deewiant> not very well thought out IMHO
12:49:41 <redditbot> David R. MacIver : Playing with Arrows
12:50:21 <Cale> Deewiant: How is insertWithKey useless?
12:50:48 <Deewiant> insertWithKey f k = insertWith (f k) k
12:51:15 <olsner> @pl \f k -> g (f k) k
12:51:15 <lambdabot> (g =<<)
12:51:35 <Cale> Deewiant: Well, it's easily obtained from insertWith, sure.
12:51:38 <Deewiant> It's just a shortcut, I've never seen any use for it where it would actually make code significantly more readable or such
12:52:34 <Deewiant> Hell, I think even writing a lambda is actually more readable; it's not obvious what "insertWithKey" means (of course you insert with a key!)
12:53:10 <Cale> I think insertWithKey is primarily intended to be partially applied.
12:53:12 <Deewiant> The issue of whether "WithKey" makes sense in general is a separate one, though.
12:53:21 <gnuvince_> Does anyone know of a blog post/article that would help people understand closures if they've never used them before?
12:53:55 <ddarius> gnuvince: SICP
12:53:56 <Cale> gnuvince_: Closures are basically a pair consisting of a tree of code with some free variables in it, and a dictionary mapping those free variables to values.
12:54:13 <Cale> gnuvince_: You can use them to implement first class functions.
12:54:17 <ddarius> "tree of code" seems overly specific
12:54:25 <Cale> Well, okay, "code"
12:54:36 <gnuvince_> Yeah, I know that, I just want something I can link to people who don't know closures so that they can see what they are, what they're about, why they should care, etc.
12:54:57 <Cale> People who are not implementing a compiler should *not* care about closures.
12:54:58 <ddarius> Deewiant: I believe the intended usage is data Person = Person { name :: String, ... }; insertWithKey name
12:55:02 <b_jonas> gnuvince_: how about Higher Order Perl?
12:55:09 <b_jonas> the book is now available online for free
12:55:14 <Cale> (or interpreter)
12:55:16 <b_jonas> and I think most of it is about closures
12:55:28 <Deewiant> ddarius: Ah, that makes some sense.
12:55:31 <ddarius> Cale: I highly suspect he's using "closures" as a synonym for "higher order functions"
12:55:40 <gnuvince_> I am.
12:55:50 <Cale> Closures are an implementation detail which is irrelevant at the level of semantics. People should care about first class functions of course :)
12:55:57 <b_jonas> actually no
12:56:06 <b_jonas> closures doesn't only mean the implementatoin
12:56:10 <Cale> It does.
12:56:17 <b_jonas> well, dunno
12:56:19 <Cale> People abuse the term, but that's what it means.
12:56:44 <Cale> If you can't separate the code from its environment, you don't have a closure anymore, you have something more abstract.
12:56:48 <Deewiant> ddarius: Wait, no it doesn't. insertWithKey (\name person1 person2 -> ...) (name person)
12:56:52 <b_jonas> what do you call the way you create first-class functions in haskell and lambda calculus, by closing them over lexical variables in the above scope?
12:57:03 <Cale> b_jonas: First class functions.
12:57:26 <ddarius> @hoogle insertWithKey
12:57:26 <b_jonas> I mean, differentiating that from other ways of making first class functions, like those in J, postscript, C, C++, or assembly
12:57:26 <lambdabot> Data.IntMap insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
12:57:26 <lambdabot> Data.Map insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
12:57:26 <lambdabot> Data.Map insertWithKey' :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
12:57:46 <Cale> b_jonas: Or, specifically, I might refer to the way that they capture the values of variables in lexical scope, but this is usually implied.
12:58:01 <pejo> b_jonas, the support for first class functions in C is limited, to say the least.
12:58:11 <Cale> C does not support first class functions.
12:58:13 <b_jonas> pejo: yeah, maybe forget C
12:58:16 <olsner> I thought closure referred to the closure of a certain operation (this case, finding reachable variables, or mapping free variables to variable definitions in scope)
12:58:22 <ErhardtMundt> hail
12:58:32 <pejo> Cale, I'd say that is limited. :-)
12:58:38 <Cale> olsner: er, you might be thinking of a different sort of closure...
12:58:43 <ddarius> olsner: "closure" refers to "closing a term"
12:58:54 <Deewiant> pejo: Either functions are first class in a language or they aren't. There is no "limited".
12:58:55 <olsner> hmm, maybe I'm confusing different uses yeah
12:59:27 <Axman6> Deewiant: anything else is hacky emulation?
13:00:08 <Deewiant> Axman6: it's not first class functions. Maybe you have closures or whatever but functions either are first class or not.
13:00:27 <Axman6> yeah
13:00:30 <Deewiant> E.g. D has closures but not first class functions.
13:00:38 <Cale> You *can* however, have closures in C.
13:00:40 <Deewiant> Python too, I think?
13:00:42 <Axman6> D looks interesting
13:01:02 <ddarius> Deewiant: Python has first-class functions.
13:01:05 <b_jonas> 5I'm tired of this argument. I brought this up a few times and we can never agree on terminology. But it's so unimportant what we call what.
13:01:18 <Cale> It is important :)
13:01:36 <Deewiant> ddarius: I'll take your word for it, I don't know Python very well.
13:01:53 <ddarius> Deewiant: I don't know python at all really.
13:01:57 <dolio> Java has functors, just like ML.
13:02:07 <Cale> In fact, the reason I'm so picky about this is that I've seen *a lot* of confusion arise over this abuse of terminology, and I'd like to see it stop.
13:02:47 <amaron> anyone here uses haskelldb?
13:03:04 <Cale> It's (somewhat) meaningless to ask if a language "has closures", it's meaningful to ask whether its implementation uses closures.
13:03:30 <Deewiant> The term 'closure' is somewhat overloaded.
13:03:48 <Deewiant> http://en.wikipedia.org/wiki/Closure_%28computer_science%29
13:03:49 <mauke> a language has closures if it says it has closures :-)
13:03:56 <pumpkin_> I'm having a lot of difficulty getting at an associated type data constructor (is that what it's called?) from outside the module that defines it... if I add it to the export list it says it can't find the class or constructor
13:04:39 <olsner> pumpkin: add Type(..) to the export list to export all associated constructors
13:04:50 <olsner> Type(Foo,Bar) to add specific constructors
13:05:02 <Cale> To me, it would seem rather strange for a language to build-in support for closures, but not at all strange to include support for first class functions.
13:05:02 <pumpkin_> oh, that makes sense
13:05:06 <pumpkin_> I was going about it wrong :)
13:05:14 <pumpkin_> thanks :)
13:05:16 <drhodes> @karma+ olsner
13:05:16 <lambdabot> olsner's karma raised to 1.
13:05:34 <mauke> preflex: karma olsner
13:05:35 <preflex>  olsner: 3
13:05:37 <Cale> (but of course, the whole confusion was about what it means to support "closures")
13:05:44 <pumpkin_> olsner:     attempts to export constructors or class methods that are not visible here
13:05:47 <pumpkin_> :P
13:06:20 <roconnor> > 0.3*0.04
13:06:21 <lambdabot>   1.2e-2
13:06:23 <olsner> hmm...
13:06:35 <pumpkin_> olsner: it's the constructor for an associated type
13:06:41 <pumpkin_> not sure if that makes a difference
13:06:55 <olsner> hmm, probably does
13:07:35 <olsner> I don't know how those work
13:08:14 <olsner> mauke: hmm, how come I have a karma in preflex too?
13:08:42 <mauke> olsner: because someone said "olsner++" with preflex in the same channel
13:09:19 <olsner> I guess lambdabot had a mind-wipe more recently than preflex or something
13:09:27 <Gracenotes> preflex: karma C
13:09:27 <preflex>  C: 65262
13:09:53 <olsner> heh, unsigned short underflow :)
13:10:10 <mauke> olsner: preflex doesn't get its mind wiped (unlike lambdabot)
13:10:42 <Deewiant> What is preflex? Does it have source somewhere?
13:12:02 <FunctorSalad_> constrFields $ toConstr ("foo",()) evaluates to []?
13:12:48 <FunctorSalad_> is that a bug?
13:13:03 <Deewiant> What do you expect?
13:13:25 <Deewiant> Ah, it's a tuple isn't it, hmm
13:13:49 <Deewiant> Shrug
13:14:34 <FunctorSalad_> hmm nevermind it also returns [] for custom types with non-recordstyle constructors
13:16:02 <FunctorSalad_> I guess I should just run gmapQ to get some representation of *all* the children, not just named ones
13:16:03 <mauke> preflex: store source http://mauke.ath.cx/preflex/ (sometimes)
13:16:18 <SamB> preflex: help
13:16:18 <preflex>  try 'help help' or see 'list' for available commands
13:16:21 <SamB> preflex: help help
13:16:22 <preflex>  help COMMAND - show help for a command
13:16:22 <wli> I don't seem to be able to get around having to explicitly annotate crap of the form forall s . ST s (STArray s (Int, Int) Rational) etc.
13:16:29 <SamB> preflex: list
13:16:29 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
13:16:52 <Cale> preflex: 8ball
13:16:53 <preflex>  what
13:17:03 <FunctorSalad_> preflex: help cdecl
13:17:04 <preflex>  cdecl DECLARATION - explain a C declaration
13:17:09 <paper_cc> preflex: help
13:17:10 <preflex>  try 'help help' or see 'list' for available commands
13:17:17 <Cale> preflex: help 8ball
13:17:18 <preflex>  8ball QUESTION - automated fortune teller machine
13:17:20 <SamB> mauke: you should make him silently copy down all the stuff given with @remember
13:17:30 <Deewiant> preflex: 8ball huh?
13:17:30 <preflex>  it is decidedly so
13:17:46 <FunctorSalad_> preflex: 8ball is 2009 the year of haskell on the desktop?
13:17:47 <preflex>  it is decidedly so
13:17:58 <kaol> preflex: 8ball Can Haskell do it?
13:17:58 <preflex>  very doubtful
13:18:08 <kaol> @faq Can Haskell do it?
13:18:08 <lambdabot> The answer is: Yes! Haskell can do that.
13:18:09 <Cale> preflex: 8ball Am I asking the 8-ball a question right now?
13:18:10 <preflex>  as I see it, yes
13:18:31 <Deewiant> preflex: 8ball Are you sure about that?
13:18:31 <preflex>  ask again later
13:18:40 <bolrod> preflex: 8ball are you always right?
13:18:40 <preflex>  better not tell you now
13:18:45 <bolrod> preflex: 8ball are you always right?
13:18:46 <preflex>  cannot predict now
13:19:09 <Deewiant> It's remarkable how accurate these kinds of things always are :-)
13:19:14 <bolrod> :)
13:19:19 <bolrod> preflex: 8ball are you always correct?
13:19:19 <preflex>  better not tell you now
13:19:29 <bolrod> lame
13:19:32 <Deewiant> preflex: 8ball are you always wrong?
13:19:32 <preflex>  better not tell you now
13:19:32 <SamB> maybe because they say "maybe" so much ?
13:19:45 <bolrod> maybe
13:19:53 <Deewiant> I wonder if "are you" is special-cased or something :-)
13:20:01 <Cale> preflex: 8ball are you?
13:20:02 <preflex>  my sources say no
13:20:07 <bolrod> preflex: 8ball are statements made by preflex correct?
13:20:07 <SamB> hahaha
13:20:08 <preflex>  most likely
13:20:09 <olsner> @karmabot
13:20:09 <lambdabot> Unknown command, try @list
13:20:13 <mauke> preflex: 8ball is "are you" special-cased?
13:20:13 <preflex>  cannot predict now
13:20:20 <bolrod> screw that
13:20:20 <olsner> preflex: karmabot
13:20:20 <bolrod> :P
13:20:25 <preflex>  <: -6964; <-: -1404; -: -931; <!: -273; apathy: -259; ^: -219; <--: -213; me: -136; -rw-r--r: -119; --: -113
13:20:51 <FunctorSalad_> err
13:20:53 <olsner> hehe
13:20:59 <olsner> <--
13:21:03 <olsner> preflex: karmabot
13:21:08 <preflex>  <: -6965; <-: -1404; -: -931; <!: -273; apathy: -259; ^: -219; <--: -213; me: -136; -rw-r--r: -119; --: -113
13:21:16 <FunctorSalad_> why so often <:-- though
13:21:17 <bolrod> preflex: 8ball 8ball is always wrong, right?
13:21:17 <preflex>  most likely
13:21:22 <Deewiant> Why so often <--
13:21:34 <Deewiant> I guess people just draw arrows
13:21:41 <mauke> <-- tired
13:21:46 <Deewiant> --- is a bit silly though
13:21:49 <SamB> it's also a symop
13:21:52 <bolrod> hmm... did preflex give me a correct answer ? :/... right -.-
13:21:53 <FunctorSalad_> hmm the : is part of the metadata I guess
13:22:03 <olsner> apathy seems to get a lot of gripe though
13:22:06 <SamB> I like the <!--
13:22:16 <FunctorSalad_> preflex: apathy++
13:22:35 <SamB> anyway, it looks as though preflex should probably ignore operator tokens ?
13:22:43 <Deewiant> yep
13:23:00 <bolrod> O.O
13:23:04 <Deewiant> @karma-all
13:23:04 <lambdabot>  "moritz"              391
13:23:05 <lambdabot>  "pmichaud"            234
13:23:07 <lambdabot>  "pmurias"             203
13:23:10 <lambdabot>  "lwall"               171
13:23:11 <Axman6> @karma apathy
13:23:11 <lambdabot>  "azawawi"             124
13:23:14 <lambdabot> [852 @more lines]
13:23:15 <lambdabot> apathy has a karma of 1
13:23:19 <SamB> -rw-r--r also has a lot of gripe ;-P
13:23:19 <mauke> preflex: karma lwall
13:23:19 <preflex>  lwall: 355
13:23:23 <Axman6> apathy++
13:23:46 <kaol> @karma Java
13:23:47 <lambdabot> Java has a karma of -3
13:23:53 <Valodim> hahaha
13:23:54 <mauke> preflex: karma java
13:23:55 <preflex>  java: -15
13:23:55 <Deewiant> preflex: karma Java
13:23:57 <preflex>  Java: -15
13:24:02 <mauke> preflex: karma C++
13:24:02 <preflex>  C++: -29
13:24:05 <bolrod> @karma haskell
13:24:05 <lambdabot> haskell has a karma of 49
13:24:07 <FunctorSalad_> preflex: karma C
13:24:08 <preflex>  C: 65263
13:24:10 <FunctorSalad_> :D
13:24:11 <kaol> @karma PHP
13:24:11 <lambdabot> PHP has a karma of 0
13:24:16 <kaol> PHP--
13:24:23 <bolrod> @karma google
13:24:23 <lambdabot> google has a karma of 1
13:24:30 <bolrod> @karma microsoft
13:24:31 <lambdabot> microsoft has a karma of 0
13:24:47 <Valodim> @karma lambdabot
13:24:47 <lambdabot> lambdabot has a karma of 1
13:25:25 <__nfw> Hey guys, Haskell newbie here
13:25:30 <Cale> hello :)
13:25:35 <__nfw> I'm getting the error message ERROR "Ass3.hs":38 - Syntax error in expression (unexpected `;', possibly due to bad layout)
13:25:41 <__nfw> But there are no semicolons
13:25:47 <__nfw> What else could this error be?
13:25:52 <mauke> newlines count as semicolons (sometimes)
13:25:53 <Cale> __nfw: yes, semicolons are inserted according to indentation
13:25:57 <SamB> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1636#a1636
13:26:01 <mle> when you use line breaks and indentation, it inserts semicolons... sometimes in the right place
13:26:04 <__nfw> Oh okay, great
13:26:08 <__nfw> Thanks a lot for the info guys
13:26:14 <__nfw> That's exaclty what I needed
13:26:18 <__nfw> exactly
13:26:33 <SamB> mauke: that's lambdabot's ++/-- handling code
13:26:36 <Cale> __nfw: So we'd need to see how things are indented. General rules: don't use tab characters, things at the same level should be vertically aligned, things inside other things should be indented more
13:26:47 <Axman6> @karma ++/
13:26:47 <lambdabot> ++/ has a karma of -2
13:26:53 <Axman6> :)
13:27:15 <Cale> (You can configure your text editor to insert spaces instead of tabs)
13:27:24 <mauke> SamB: I don't like it
13:27:28 <__nfw> oh, I think that's my problem
13:27:33 <__nfw> I have some comments tabbed in
13:27:35 <SamB> mauke: hmm
13:27:35 <Deewiant> @karma <!
13:27:36 <lambdabot> <! has a karma of -5
13:27:37 <SamB> perhaps not
13:27:39 <Deewiant> @karma <
13:27:39 <lambdabot> < has a karma of -557
13:27:41 <kaol> I tried > repeat "PHP-- " but lambdabot won't pick up that
13:27:48 <SamB> mauke: I didn't say it was pretty
13:27:50 <Deewiant> @karma --
13:27:50 <lambdabot> -- has a karma of -14
13:27:51 <Deewiant> @karma -
13:27:52 <lambdabot> - has a karma of -82
13:27:57 <mauke> SamB: I don't like what it does
13:28:00 <Axman6> --++!
13:28:01 <Deewiant> lambdabot could use some work as well
13:28:04 <Cale> tab characters almost inevitably create indentation problems, unless you are extremely careful, so it's best to avoid them altogether
13:28:04 <SamB> but it looks like it's probably a good idea to check if a valid IRC ncik is given ?
13:28:16 <mauke> SamB: no
13:28:23 <Deewiant> SamB: you--
13:28:33 <SamB> Deewiant: that *is* valid
13:28:34 <Axman6> @karma php
13:28:34 <lambdabot> php has a karma of -1
13:28:43 <Axman6> , repeat "php-- "
13:28:46 <lunabot>  ["php-- ","php-- ","php-- ","php-- ","php-- ","php-- ","php-- ","php-- ",...
13:28:49 <bolrod> lol
13:28:54 <Axman6> @karma php
13:28:54 <bolrod> @karma php
13:28:54 <lambdabot> php has a karma of -1
13:28:54 <lambdabot> php has a karma of -1
13:28:56 <skorpan> lol
13:28:57 <SamB> I never said anything about in-channel
13:28:58 <wli> Am I the only person in the universe who uses tabs and hasn't had an alignment problem in recent memory?
13:29:04 <Deewiant> SamB: ah, you meant valid according to the IRC specs, and not valid as in on-network
13:29:10 <Axman6> , concat . repeat $ "php-- "
13:29:11 <lunabot>  "php-- php-- php-- php-- php-- php-- php-- php-- php-- php-- php-- php-- ...
13:29:12 <SamB> , repeat " php-- "
13:29:13 <lunabot>  [" php-- "," php-- "," php-- "," php-- "," php-- "," php-- "," php-- "," ...
13:29:19 <Axman6> @karma php
13:29:19 <bolrod> @karma php
13:29:19 <lambdabot> php has a karma of -20
13:29:19 <SamB> or at least CLOSE to
13:29:19 <lambdabot> php has a karma of -20
13:29:24 <Axman6> hooray :)
13:29:26 <Deewiant> wli: I used to but then I started running into problems and switched away (for Haskell only)
13:29:29 <mauke> preflex: karma "php
13:29:30 <preflex>  "php: -4
13:29:36 <bolrod> @karma ["php
13:29:37 <lambdabot> ["php has a karma of -1
13:29:38 <SamB> most strings of punctaution probably shouldn't be allowed karma
13:29:45 <Deewiant> Well, problems and problems; too much vertical space usage for my tastes
13:29:47 <mauke> SamB: why?
13:29:51 <Axman6> > concat . repeat $ "php-- "
13:29:52 <lambdabot>   "php-- php-- php-- php-- php-- php-- php-- php-- php-- php-- php-- php-- ph...
13:29:52 --- mode: irc.freenode.net set +o ChanServ
13:29:56 <SamB> ----
13:30:09 <FunctorSalad_> uhoh
13:30:10 <SamB> -- this is a comment
13:30:12 <Axman6> preflex: karma php
13:30:12 <preflex>  php: -100
13:30:18 <mauke> I fail to see the problem
13:30:29 <FunctorSalad_> ChanServOverlords++
13:30:31 <SamB> preflex: karmabt
13:30:36 <bolrod> maybe implement -= for php
13:30:36 <SamB> preflex: karmabot
13:30:38 <wli> I've never had alignment problems in all of the 11 or 12 years I've been farting around with Haskell.
13:30:39 <bolrod> php-=100
13:30:41 <preflex>  <: -6967; <-: -1404; -: -932; <!: -274; apathy: -257; ^: -219; <--: -213; me: -136; -rw-r--r: -119; --: -113
13:30:50 <mauke> preflex: karma Mickey Rourke
13:30:51 <preflex>  Mickey Rourke: 1
13:31:00 <Axman6> php++ for documentation though. happs needs something a tenth as good to be really useful
13:31:09 <Deewiant> preflex: karma arstdhneio
13:31:10 <preflex>  arstdhneio has no karma
13:31:20 <Deewiant> Mickey Rourke has karma o_O
13:31:20 <mmorrow> preflex: karma Sarah Conor
13:31:21 <preflex>  Sarah Conor has no karma
13:31:25 <bolrod> hm
13:31:28 <bolrod> @karma bolrod
13:31:28 <lambdabot> You have a karma of 0
13:31:31 <mmorrow> Sarah Conor++
13:31:31 <bolrod> bolrod++
13:31:33 <bolrod> @karma bolrod
13:31:33 <lambdabot> You have a karma of 0
13:31:34 <Deewiant> mmorrow: two n's
13:31:39 <Valodim> php's docs are not bad.. now, if the naming conventions were anywhere near that :P
13:31:39 <mmorrow> Sarah Connor++
13:31:41 <mmorrow> ;)
13:31:42 <Cale> mmorrow: Isn't it Connor?
13:31:43 <wli> Wouldn't that be Connor?
13:31:45 <Cale> yeah
13:31:47 <mmorrow> Sarah Connor++
13:31:48 <mmorrow> Sarah Connor++
13:31:52 * mmorrow laughs
13:31:56 <bolrod> > concat . repeat $ " bolrod++ "
13:31:57 <lambdabot>   " bolrod++  bolrod++  bolrod++  bolrod++  bolrod++  bolrod++  bolrod++  bol...
13:31:57 <Axman6> @karma conner
13:31:57 <lambdabot> conner has a karma of 0
13:31:58 <mauke> preflex: karma Sarah Connor
13:31:58 <preflex>  Sarah Connor has no karma
13:32:01 <bolrod> @karma bolrod
13:32:01 <lambdabot> You have a karma of 0
13:32:02 <SamB> mauke: well, I mean, it doesn't make sense to ascribe karma to < , <- , - , <!, ^ , and <-- like that
13:32:04 <Axman6> @karma connor
13:32:04 <lambdabot> connor has a karma of 3
13:32:05 <bolrod> well.. ok
13:32:08 <wli> Cale: Maybe he's doing the phone book search phonetically.
13:32:12 <mmorrow> SarahConnor++
13:32:24 <bolrod> , concat . repeat $ " bolrod++ "
13:32:26 <lunabot>  " bolrod++  bolrod++  bolrod++  bolrod++  bolrod++  bolrod++  bolrod++  b...
13:32:27 <olsner> bolrod: lamdabot doesn't read her own output
13:32:29 <bolrod> @karma bolrod
13:32:29 <lambdabot> You have a karma of 7
13:32:32 <bolrod> :]
13:32:47 <bolrod> hax!
13:32:50 <mauke> , concat . repeat $ " bolrod--"
13:32:51 <lunabot>  " bolrod-- bolrod-- bolrod-- bolrod-- bolrod-- bolrod-- bolrod-- bolrod--...
13:33:03 <wli> He will show up on the doorsteps of 3 additional women when including "Conor" as well as "Connor."
13:33:03 <Deewiant> @karma bolrod
13:33:03 <lambdabot> bolrod has a karma of 0
13:33:12 <bolrod> :[
13:33:22 <Axman6> ha
13:33:35 <wli> Is it just me or is the mutable array API extremely awkward?
13:34:00 <SamB> wli: you expected mutation to be pleasant ?
13:34:26 <wli> It seems to do fine for other forms of state.
13:34:28 <Axman6> wli: i find it quite nice
13:34:28 <FunctorSalad_> @faq can haskell make you understand the type of gfoldl?
13:34:28 <lambdabot> The answer is: Yes! Haskell can do that.
13:34:51 <Axman6> FunctorSalad_: what's the type?
13:34:55 <wli> I get garbage like:
13:34:58 <wli> runST $ do { (m, _, w) <- (\x -> runRWST x undefined undefined) $ (lift (thaw (Data.Array.array ((1,1),(3,3)) [((1,1),3),((1,2),-1),((1,3),0),((2,1),-1),((2,2),3),((2,3),-1),((3,1),0),((3,2),-1),((3,3),3)] :: Array (Int, Int) Double) :: forall s . ST s (STArray s (Int, Int) Double)) >>= \matrix -> local (const matrix) (put (1,1) >> moveToCorner (3,3) >> lift (freeze matrix) >>= \(u :: Array (Int, Int) Double) -> return u)) ; return (m, w) }
13:35:07 <FunctorSalad_> @type gfoldl -- Axman6
13:35:08 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
13:35:22 <olsner> wli: wow :)
13:35:23 <Axman6> jesus...
13:35:38 <Deewiant> RankNTypes for the win
13:35:49 <FunctorSalad_> Axman6: to be fair, we are warned that trying to understand it may lead to brain damage ;)
13:36:03 <Axman6> @src gfoldl
13:36:03 <lambdabot> Source not found. I am sorry.
13:36:10 <FunctorSalad_> it's a method
13:36:10 <Deewiant> Axman6: class method
13:36:11 <Axman6> so you should be!
13:36:14 <Axman6> ah
13:36:22 <wli> moveToCorner :: (MArray a e m, Enum i, Ix i, Enum j, Ix j)
13:36:22 <wli> => (i, j) -> RWST (a (i, j) e) [Either (i, i) (j, j)] (i, j) m ()
13:37:16 <wli> The thing that makes it so very painful is that the mutable array monads don't commute with any of the monad transformers.
13:37:21 <Axman6> wli: ok, you're doing far more funky stuff than i have. seems very complicated. does it need be so?
13:38:20 <olsner> move it into IO rather than ST to get rid of the existential?
13:38:27 <Deewiant> The gfoldl docs do explain the parameters somewhat
13:38:34 * ddarius has never used RWS or RWST ever.
13:38:40 <Deewiant> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Data.html#v%3Agfoldl
13:38:55 <wli> Well, either I use a MonadReader or I pass in the same argument to 20 functions. MonadWriter is essential. The state helps track which parts of the matrix haven't been eliminated and/or reduced out of the picture.
13:38:57 <Deewiant> Axman6: 'The type of gfoldl is a headache, but operationally it is a simple generalisation of a list fold.'
13:39:07 <bolrod> @type gfoldlAccum
13:39:08 <lambdabot> forall a (c :: * -> *) d. (Data d) => (forall d1 r. (Data d1) => a -> c (d1 -> r) -> d1 -> (a, c r)) -> (forall g. a -> g -> (a, c g)) -> a -> d -> (a, c d)
13:39:10 <Axman6> ah ha
13:39:12 <bolrod> whuts dat den
13:39:14 <bolrod> O.o
13:39:20 <FunctorSalad_> bolrod: pwned.
13:39:36 <Axman6> :t \q w e r t y u i o p -> t y p e w r i t e r
13:39:37 <lambdabot>     Occurs check: cannot construct the infinite type:
13:39:37 <lambdabot>       t = t5 -> t7 -> t3 -> t2 -> t4 -> t6 -> t -> t3 -> t4 -> t1
13:39:37 <lambdabot>     Probable cause: `t' is applied to too many arguments
13:39:43 <danderson> Hi.
13:39:44 * Axman6 can be a monster too
13:39:54 <Deewiant> bolrod: gfoldl with an accumulation, of course!
13:39:57 <wli> sans MonadWriter it's near-impossible to track the row permutations
13:40:03 <Axman6> :t \q w e r t y u i o p -> t y p e w r i e r -- lame
13:40:04 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9. t -> t1 -> t2 -> t3 -> (t4 -> t8 -> t2 -> t1 -> t3 -> t6 -> t2 -> t3 -> t9) -> t4 -> t5 -> t6 -> t7 -> t8 -> t9
13:40:18 <danderson> I'm trying to get xmonad installed on an ancient distro, which implies a lot of building of ghc and related haskell libs.
13:40:27 <wli> I suspect most people give up and use Data.Map or lists.
13:40:28 <FunctorSalad_> > gfoldl (\f x -> f  `ap` (return x)) Just ('a','b')
13:40:29 <lambdabot>   /tmp/2695761328825878287:70:32: Not in scope: `gfoldl'
13:40:42 <FunctorSalad_> hmm?
13:40:51 <Deewiant> try luna
13:40:59 <danderson> Right now, I have a problem with cabal-install. It doesn't seem to have any package servers specified by default, and I have no idea where to find a server definition that would be adequate. Any pointers?
13:40:59 <FunctorSalad_> , gfoldl (\f x -> f  `ap` (return x)) Just ('a','b')
13:41:01 <lunabot>  Just ('a','b')
13:41:05 <FunctorSalad_> \o/
13:41:11 <Axman6> id++
13:41:46 <FunctorSalad_> , gfoldl (\_ x -> Just (x+1)) Just ('a','b')
13:41:47 <lunabot>  luna: Could not deduce (GHC.Num.Num d)
13:42:18 <Deewiant> , gfoldl (\_ x -> Just (x + 1 :: Int)) Just ('a','b')
13:42:19 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
13:42:22 <FunctorSalad_> meh (I'm trying to count the number of children)
13:42:33 <FunctorSalad_> (without resorting to gmapQ ;))
13:42:48 <wli> Speaking of matrices, I should fine tune the fraction-free Gaussian elimination code to reduce the matrix size when it encounters a column with only one nonzero element.
13:43:05 <hackage> Uploaded to hackage: openid 0.1.1.0
13:43:05 <hackage> Uploaded to hackage: hackage2hwn 0.5
13:43:27 <FunctorSalad_> , length $ gmapQ (\_ -> ()) ('a','b')
13:43:28 <lunabot>  2
13:43:32 <FunctorSalad_> yay
13:43:34 <jeffwheelerPhone> OpenID? Neat.
13:44:03 <FunctorSalad_> , length $ gmapT id ('a','b')
13:44:04 <lunabot>  luna: Couldn't match expected type `[a]'
13:44:21 <FunctorSalad_> , length $ gmapT (\x -> x) ('a','b')
13:44:22 <lunabot>  luna: Couldn't match expected type `[a]'
13:44:29 <Axman6> , typ "gmapT"
13:44:29 <FunctorSalad_> hmm not the DMR ;)
13:44:32 <lunabot>  "forall a.\n(Data.Data.Data a) =>\n(forall b. (Data.Data.Data b) => b -> ...
13:44:44 <Axman6> data data data
13:44:58 <FunctorSalad_> Axman6: gmapT applies some generic transformation to all the immediate children
13:45:25 <FunctorSalad_> duh no wonder it doesn't produce a list ;)
13:45:26 <Axman6> sounds funky
13:45:33 <FunctorSalad_> so it's gmapQ I guess
13:46:33 <wli> It's dumb. You find the nonzero matrix element of smallest absolute value, check if it's the only nonzero element in the column. If it's the smallest nonzero element in its column, pivot it to the upper left and reduce the matrix size. Otherwise, row reduce by row' := row' - q*row where q is the quotient via e.g. divMod of the coefs in that column, and keep working on that column until it's only got one nonzero element.
13:46:40 <wolverian> I'm trying to compile Takusen on GHC 6.11, but it's somehow seeing the old Exception data type, not the type class, and the build fails. any hints what might be going on?
13:46:44 <FunctorSalad_> , runState s 0 where s = gmapM (\x -> modify (+1) >> return x) (1,2)
13:46:45 <lunabot>  luna: parse error on input `where'
13:46:58 <FunctorSalad_> , let s = gmapM (\x -> modify (+1) >> return x) (1,2) in runState s 0
13:46:59 <lunabot>  luna: No instance for (GHC.Show.Show (m (t, t1)))
13:46:59 <pejo> wolverian, a dependency on base 3.x in the cabal?
13:47:07 <olsner> @ty \q w e r (t :: forall a b . a -> b) y u i o p -> t y p e w r i t e r
13:47:08 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 a t8. t -> t1 -> t2 -> t3 -> (forall a1 b. a1 -> b) -> a -> t4 -> t5 -> t6 -> t7 -> t8
13:47:12 <FunctorSalad_> ._.
13:47:16 <Axman6> wli: sounds easy as
13:47:17 <wolverian> pejo: ah, let's see.
13:47:18 <Axman6> >_>
13:47:27 <wli> ergh, if it's the only nonzero element in its column pivot it to the upper left and reduce
13:48:10 <sjanssen> is hpaste down?
13:48:12 <FunctorSalad_> , runState     (gmapM (\x -> modify (+1) >> return x) (1,2))        0
13:48:13 <lunabot>  luna: No instance for (GHC.Show.Show (m (t, t1)))
13:48:32 <FunctorSalad_> , evalState     (gmapM (\x -> modify (+1) >> return x) (1,2))        0
13:48:33 <lunabot>  luna: Not in scope: `evalState'
13:48:36 <wolverian> pejo: no, no explicit versions in the .cabal file
13:48:38 <FunctorSalad_> I give up.
13:48:48 <wolverian> pejo: (base *is* depended on, of course :)
13:49:12 <dcoutts> wolverian: it's using base 3 because you didn't say you wanted version 4
13:49:20 <FunctorSalad_> , snd $ runState     (gmapM (\x -> modify (+1) >> return x) (1,2))        0
13:49:21 <lunabot>  luna: No instance for (GHC.Show.Show (m (t, t1)))
13:49:32 <dcoutts> wolverian: if it needs version 4 then it should say so. If it works with both then it'll be ok.
13:49:36 <FunctorSalad_> doint it 'rong...
13:49:41 <redditbot> Discussion of TH on the Python list circa 2003
13:49:43 <FunctorSalad_> *g
13:49:47 <wolverian> dcoutts: it forces new style exceptions on if ghc version is >= 6.10
13:49:51 <wli> The only reason not to pivot it right away when you find that it's not the only nonzero element in its column is because you aren't sure which row will still have a nonzero element left when the smoke clears.
13:49:56 <wolverian> dcoutts: (with CPP #ifdef)
13:50:04 <bjorkintosh> ->> ghc-6.8.2: not built for interactive use
13:50:06 <bjorkintosh> what the hell?!
13:50:11 <wolverian> evidently I need to fix the .cabal file, then. thanks.
13:50:17 <dcoutts> wolverian: oh, well that's not correct. It cannot use ghc version as a proxy for the version of base. They are not related any more.
13:50:18 <bjorkintosh> and that was after 'ghci' :|
13:50:26 <bjorkintosh> i just apt-get install-ed ghc6.
13:50:45 <bjorkintosh> is it missing ... something?
13:50:47 <wli> You could pivot the column all the way to the left right away, and then wait to see which row ends up nonzero to pivot the rows.
13:50:58 <wolverian> dcoutts: so it should depend on either base4 or base3, and in the case of base4, it can assume new style exceptions are present?
13:51:30 <hallongrottan> :t join
13:51:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:51:35 <harblcat> bjorkintosh: do you specifically need ghc6?
13:51:51 <whpearson> @where hpaste
13:51:52 <lambdabot> http://hpaste.org/
13:51:52 <dcoutts> wolverian: yes, because new style exceptions are in base 4 and not base 3. The exceptions style is nothing to do with ghc and everything to do with the libs.
13:51:53 <mauke> harblcat: what other options are there?
13:51:53 <wli> I ended up just copping out and pivoting on every reduction and never reduced the matrix etc.
13:51:56 <whpearson> @where hpaste2
13:51:56 <lambdabot> http://hpaste.org/
13:52:12 <harblcat> Well, I meant, why not apt-get install ghc instead?
13:52:13 <Deewiant> wolverian: for new-style exceptions there's the extensible-exceptions package which works with both base 3 and 4
13:52:19 <whpearson> Anyone have another suggestion?
13:52:20 <bjorkintosh> harblcat, sure. the RWH uses it.
13:53:18 <bjorkintosh> "We assume that you're using at least version 6.8.2 of GHC ..."
13:53:25 <bjorkintosh> is that ghc6 or not?
13:53:29 <wolverian> Deewiant: then perhaps it should just depend on that instead of conditional compilation.
13:53:37 <Deewiant> wolverian: yes, that's easier
13:55:21 <whpearson> What am I doing wrong here? http://pastebin.com/d56ec83bc
13:55:34 <harblcat> bjorkintosh: does ghci exist?
13:55:44 <harblcat> should be in /usr/bin/
13:56:07 <bjorkintosh> it does.
13:56:15 <bjorkintosh> it tells me 'not built for interactive use'
13:56:45 <harblcat> bjorkintosh: try ghc --interactive?
13:56:57 <Cale> whpearson: The type you gave for toNum is way more polymorphic than your implementation
13:57:07 <pejo> bjorkintosh, are you on a strange architecture? (Debian?)
13:57:14 <bjorkintosh> pejo, it's debian on an imac.
13:57:18 <Cale> whpearson: toNum's type says that it has to be able to convert a value of type w to *any* type of Num
13:57:20 <bjorkintosh> is that ... strange?
13:57:33 <harblcat> bjorkintosh: powerpc imac?
13:57:38 <Cale> whpearson: Whereas the implementation you provide just turns a value of type w into *some* type of Num
13:57:45 <whpearson> Ah, so I need to use exists?
13:57:47 <bjorkintosh> yes
13:58:08 <Cale> whpearson: If it were valid to do so.
13:58:13 <harblcat> bjorkintosh: That could be the problem
13:58:35 <Cale> whpearson: However, in this case, you probably want the WrappedNum class to indicate the specific relationship between two types
13:58:36 <carl_> why is LSgetCoeff :: [a] -> (a -> a) -> (a -> a) -> a
13:58:37 <Cale> w and a
13:58:41 <carl_> invalid
13:58:43 <Cale> So it should probably be:
13:58:50 <Cale> class WrappedNum w a where ...
13:58:50 <bjorkintosh> madness!
13:58:59 <Cale> Perhaps:
13:59:00 <Deewiant> carl_: starts with a capital letter
13:59:02 <whpearson> Cale: Okay, thanks.
13:59:07 <carl_> o
13:59:08 <carl_> lol
13:59:11 <Cale> class Num a => WrappedNum w a | w -> a, a -> w where ...
14:01:45 <bjorkintosh> very well.
14:01:57 <bjorkintosh> it seems to be running just fine on my bsd box.
14:02:20 <jdkoeck> hello
14:04:15 <jdkoeck> does someone know if there is a "forM" function for ByteStrings ?
14:04:52 <Zao> They do expose some kind of map, don't they?
14:05:47 <jdkoeck> yes
14:06:27 <jdkoeck> I'm modifying an ST array by iterating on a string
14:06:35 <jdkoeck> which is easy with a normal string
14:06:53 <jdkoeck> but I don't know how to do it with bytestrings
14:06:59 <pumpkin_> you could just map regularly and sequence it?
14:07:06 <wli> Is there some way to get arrays to interoperate better with monad transformers?
14:07:09 <ddarius> jdkoeck: ByteStrings have O(1) indexing so you can just mapM over [1..n]
14:07:15 <pumpkin_> @src mapM
14:07:15 <lambdabot> mapM f as = sequence (map f as)
14:07:27 <jdkoeck> mmh, it makes me load a whole file in memory
14:07:45 <pumpkin_> not with a lazy bytestring
14:08:01 <jdkoeck> tried it too, seems it did not work
14:08:05 <jdkoeck> but i will try again
14:09:55 <jdkoeck> with lazy, still loading everything in memory, so i'll try sequence and map
14:10:19 <Gracenotes> hm.. a ziplist of sorts was recently released on hackage -- anyone remember what was called?
14:11:22 <Zao> Gracenotes: pointedlist
14:11:32 <Zao> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointedlist-0.3
14:11:41 <Zao> Erm, wrong version, but meh.
14:11:50 <Gracenotes> that's it :)
14:12:00 <Zao> Managed to yank the wrong link from my RSS archive :P
14:18:07 <jdkoeck> Ok, it works now ! Turns out there was a kind of space leak (using forM instead of forM_) that made me load a whole file in memory...
14:19:46 <wli> It might be nice to keep a priority queue of array indices prioritized by the absolute value of array elements for search purposes.
14:19:49 <Cale> jdkoeck: I seem to recall seeing ケ next to your name somewhere. Is that a subtle pronunciation hint? :)
14:22:52 <jdkoeck> Cale: you saw it on twitter I think, it's a japanese "ke"
14:22:58 <Cale> I know :)
14:23:10 <jdkoeck> Ow, ok
14:23:15 <dons> huh. by my reckoning, galois engineers have written just shy of 10% of haskell libraries
14:23:17 <jdkoeck> Actually my name is German
14:23:40 <Cale> 私は日本語を勉強します
14:23:55 <bos> All hail the Galwegians!
14:24:03 <pumpkin_> 僕も
14:24:12 <wli> type RWSMatrix a i j e m t = RWST (a (i, j) e) [Either (i, i) (j, j)] ((i, j), (i, j)) m t <-- you must be kidding me
14:24:28 <jdkoeck> This channel is becoming very cryptic
14:24:40 <pumpkin_> lol
14:25:10 <jdkoeck> Cale: can't answer, I haven't yet learned those :-(
14:25:49 <pumpkin_> dons: I have epic bytestring serialization for uvector now :) one safe version that uses Data.Binary and should work across machines, and one unsafe one in O(1) (for which I still haven't written a deserializer)
14:26:07 <Cale> jdkoeck: わたしはにほんごをべんきょうします
14:26:22 <Cale> jdkoeck: "I am studying Japanese" :)
14:26:27 * bos has finished implementing Data.Text
14:26:55 <hallongrottan> Cale: that seems to be correct :)
14:26:57 <jdkoeck> Cale: cool :)
14:26:58 <bos> hmm, actually, is that true? i guess i don't have mapAccumR quite right.
14:27:15 <pumpkin_> bos: what is Data.Text? :o
14:27:38 <bos> pumpkin_: compact unicode text support using stream fusion
14:27:44 <pumpkin_> ooh nice
14:27:58 <pumpkin_> is it built on top of something else?
14:29:07 <bos> no.
14:29:31 <bos> unfortunately, our three big packages that use stream fusion all have slightly different needs.
14:31:39 <pumpkin_> yeah
14:33:27 <dons> pumpkin_: woo!
14:33:30 <dons> bos: woo!
14:33:37 <dons> the next big thing.
14:34:09 <jdkoeck> Is it me or hpaste is broken ?
14:34:26 <pumpkin_> jdkoeck: looks broken to me too
14:34:38 <pumpkin_> maybe mmorrow is backing up the database and locked it while that happened?
14:34:51 <bos> I wonder whether to release a Data.Text preview now, or whether to code up the lazy API first.
14:35:03 * pumpkin_ loves previews
14:35:10 <Gracenotes> what does badly written Haskell look like? that is, stuff that works, but is badly designed
14:35:15 <bos> Oh, I know! I'll finish up the API docs first. And fix mapAccumR.
14:35:29 <pumpkin_> Gracenotes: everything sits in IO and looks like c?
14:35:38 <jdkoeck> bos: why the sudden enlightenment ? :)
14:36:04 <carl_> mulColumn :: (Num a) => [[a]] -> [a] -> [a]; mulColumn [] [] = []; Couldn't match expected type `[Char]' against inferred type `Char', any ideas?
14:36:13 <bos> Gracenotes: like bad code anywhere else, sort of. no separation of concerns, poor or no use of abstractions, etc.
14:36:21 <Gracenotes> pumpkin: heh. Hm.. not entirely what I was thinking of.. then, what would bad code in an impure function language look like?
14:36:28 <Gracenotes> *functional
14:36:41 <wli> bos: Sounds like what I'm writing right now.
14:36:49 <dons> elliottt: openid probably can handled containers 0.2.*
14:37:01 <bos> dammit, haddock produces the awfullest of error messages.
14:37:09 <jdkoeck> bos: using haskell without using abstractions seems hard
14:37:14 <bos> "haddock: parse error in doc string"
14:37:25 <dons> haddock needs a fault tolerance hammer hit
14:37:32 <Gracenotes> I suppose the worst one can do in functional programming is not abstract
14:37:37 <bos> well, at least printing a file name and line number would help.
14:37:37 <dons> ignore errors in markup and continue, rather than exiting
14:37:44 <bos> which it usually does.
14:37:53 <dons> Gracenotes: the worst you can do in any language
14:38:02 <bos> jdkoeck: that's what new haskell programmers do all the time, though
14:38:04 <dons> there's nothing fundamentally different: we just have cooler tools
14:38:13 <FunctorSalad_> "<Gracenotes> what does badly written Haskell look like?" <-- no documentation ;)
14:38:19 <Raevel> on error resume next
14:38:27 <Gracenotes> dons: well, C :)
14:38:52 <Gracenotes> although even there one can have structs, unions, etc. So it's a different type of abstraction
14:39:19 <olsner> Raevel: speak not such evil here!
14:39:29 <Gracenotes> it seems that functional programming abstracts over structures well, like lists/functors/monads/etc.
14:39:34 <FunctorSalad_> did someone make a GOTO quasiquoter yet?
14:39:37 <FunctorSalad_> ;)
14:40:08 <olsner> FunctorSalad_: iirc, augustss made a basic-like dsl with goto recently :)
14:40:36 <dons> bos: so are we going to see the design & impl of Data.Text soon?
14:40:39 <FunctorSalad_> olsner: hehe... was just wondering in the context of Gracenotes 's question...
14:40:41 * dons is keen
14:40:48 <bos> dons: it's all up on code.haskell.org already
14:40:54 <mathijs> I have a list of (at most) 2 elements, which I both want to insert into a Data.Set. is there a way to map-insert these somehow? or should I just fromList them and union that? which is better performance-wise?
14:40:55 <bos> just not in hackage
14:41:00 <dons> k.
14:41:09 <Gracenotes> I always think of carrots when I hear "keen"
14:41:24 <FunctorSalad_> mathijs: why would you need union *and* fromList?
14:41:33 <Gracenotes> I think it has something to do with how carrots are good for your eyesight
14:41:34 <pumpkin_> hmm
14:41:41 * bos wonders how many people ever use scanr, mapAccumR, and friends.
14:41:42 <FunctorSalad_> , Data.Set.fromList ['a','b']
14:41:43 <lunabot>  luna: Not in scope: `Data.Set.fromList'
14:41:50 <yitz> mathijs: foldl'
14:41:54 <wli> bos: I do.
14:41:56 <mathijs> FunctorSalad_: to turn the list into a set, which I can union with another set.
14:41:57 <bos> all those weird list fold/map mashups that are so very obscure.
14:42:04 <pumpkin_> I have epic low level question about memory buffers
14:42:07 <pumpkin_> in ghc
14:42:14 <FunctorSalad_> mathijs: ah, thought you meant a new set with just these two
14:42:27 <bos> pumpkin_: we have the answers
14:42:38 <olsner> Gracenotes: 'keen' also means 'A loud, wailing lament (for the dead).'
14:42:49 <mathijs> yitz: ah... that sounds like it :)  is inserting twice better than the fromList/union thing?
14:42:53 <FunctorSalad_> so yeah, foldl' as yitz said sounds good
14:42:54 <pumpkin_> @human_hoogle ForeignPtr a -> ByteArray# O(1)]
14:42:54 <lambdabot> Unknown command, try @list
14:42:59 <Gracenotes> olsner: what's the etymology on that?
14:43:05 <hackage> Uploaded to hackage: cabal2arch 0.5
14:43:05 <hackage> Uploaded to hackage: archnews 0.2
14:43:05 <hackage> Uploaded to hackage: hackage2hwn 0.5.1
14:43:05 <hackage> Uploaded to hackage: hackage-sparks 0.5
14:43:05 <hackage> Uploaded to hackage: hackage-plot 0.2
14:43:07 <yitz> mathijs: why twice?
14:43:22 <olsner> Gracenotes: "From Irish Gaelic caoineadh, from caoninim, I lament, from Old Irish caínim, coínim, perhaps of Brittonic origin."
14:43:22 <bos> pumpkin_: whuh? you want to copy the contents?
14:43:25 <mathijs> list has (at most) 2 elements, both need to be inserted
14:43:28 <ddarius> Gracenotes: "keen" is a old slang word
14:43:37 <Gracenotes> ah. sounded Gaelic
14:43:49 <FunctorSalad_> I think the union will have to check each added element for collision with existing elements anyway...
14:43:55 <bos> the "cry" meaning of "keen" is gaelic in origin.
14:43:58 <yitz> mathijs: oh. yeah, I found that to work the best. ymmv
14:43:59 <FunctorSalad_> but I don't know how Data.Set is implemented
14:43:59 <pumpkin_> bos: nope, just a cast :/
14:44:05 <bos> pumpkin_: you can't do that.
14:44:15 <pumpkin_> I did it the other way around :(
14:44:19 <mathijs> yitz: so the question is... will inserting one by one be as fast as turning the whole list into a set and union that one.
14:44:26 <FunctorSalad_> (maybe the duplicate removal is lazy?)
14:44:31 <Gracenotes> says OED, "The original meaning is somewhat obscure" .. :\
14:44:32 <mle> different word
14:44:36 <bos> pumpkin_: Ptr and ByteArray# are handled differently by the runtime.
14:44:40 <pumpkin_> yeah, I know
14:44:46 <pumpkin_> it's sitting in a very unsafe function :P
14:44:49 <mle> the cry sense, the sharp sense, the eager/cool sense are all inherited from different languages
14:44:55 <pumpkin_> I have superduperunsafeDump
14:44:57 <pumpkin_> :P
14:45:09 <bos> pumpkin_: yeuch.
14:45:24 <FunctorSalad_> a dump doesn't sound that unsafe
14:45:29 <pumpkin_> FunctorSalad_: this one is :P
14:45:30 <yitz> mathijs: unions have been optimized pretty well for when you already have sets, but when you have a list of things to insert it's best to insert them one at a time.
14:45:34 <yitz> imho
14:45:45 <FunctorSalad_> pumpkin_: it dumps into random memory areas rather than stdout? ;)
14:45:51 <pumpkin_> bos: well, dons said it would be nice to have an O(1) conversion from UArrs to strict ByteStrings and back again
14:46:00 <dons> i'm not sure its possible though :)
14:46:03 <mathijs> yitz: cool, thanks
14:46:04 <pumpkin_> the UArr underlying structure is BUArr, which contains a ByteArray#
14:46:08 <dons> we can certainly do a copying version
14:46:08 <pumpkin_> I've done it in one direction
14:46:13 <bos> pumpkin_: yes, it would be nice. i would also like a pony.
14:46:14 <pumpkin_> just not the other
14:46:21 <dons> my previous attempts resulted in segfaults, fwiw :)
14:46:29 <pumpkin_> boo :P
14:46:33 <dons> cabal install pony
14:46:34 <pumpkin_> well, we can settle for O(1) in one direction
14:46:43 <pumpkin_> but it'd be nice to go both ways
14:46:48 <dons> the price we pay for a good runtime
14:47:02 <dcoutts> dons: no, not yours!
14:48:04 <yitz> keen is also the name of a classic video game
14:48:26 <ddarius> yitz: Commander Keen is.
14:48:34 <yitz> right
14:49:01 <dblick> I've been stuck on this for a while now... Can anyone help me understand how to rewrite parseNumber using explicit ordering (>>=) from http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
14:49:25 <pumpkin_> maybe I'll just settle for copying for now
14:49:32 <yitz> the video game sense was also inherited from a different language - C.
14:49:41 <mauke> @src liftM
14:49:41 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:49:42 <redditbot> Neil Mitchell's Haskell Blog: Hoogle package search
14:49:48 <mauke> @. undo src liftM
14:49:49 <lambdabot> ()
14:49:53 <mauke> what
14:50:02 <mauke> @undo do { x1 <- m1; return (f x1) }
14:50:03 <lambdabot> m1 >>= \ x1 -> return (f x1)
14:50:20 <pumpkin_> sad as it makes me to copy one big chunk of memory to another big chunk of memory :(
14:50:32 <mauke> @undo do { x1 <- many1 digit; return ((Number . read) x1) }
14:50:32 <lambdabot> many1 digit >>= \ x1 -> return ((Number . read) x1)
14:50:39 <SamB> @src censor
14:50:40 <lambdabot> Source not found. stty: unknown mode: doofus
14:50:46 <mauke> @. pl undo do { x1 <- many1 digit; return ((Number . read) x1) }
14:50:46 <lambdabot> (Number . read) `fmap` many1 digit
14:51:09 <bos> i wish i knew more about when to trust GHC to apply CPR.
14:51:10 <dblick> mauke, thanks!
14:51:14 <danie2> I have eclipse 3.4 with the eclipsefp plugins installed and I can't start haskell - I get "ghc: missing -B<dir> option" - any hints?
14:51:18 <chessguy_work> nice
14:52:44 <mauke> sounds like it's using the wrong ghc executable
14:52:45 <Gracenotes> censor and listen are funny functions
14:53:11 <Gracenotes> that make me lol considerably
14:53:28 <yitz> @hoogle censor
14:53:28 <lambdabot> Control.Monad.Writer.Class censor :: MonadWriter w m => (w -> w) -> m a -> m a
14:53:58 <pumpkin_> bos: do you know of an interface to memcpy for ByteArray#?
14:54:23 <bos> pumpkin_: it should be safe to use memcpy directly.
14:54:24 <pumpkin_> or for Ptr even
14:54:26 <danie2> mauke: any hints how to fix it? or what other Haskell IDE in linux would u recommend?
14:54:43 <pumpkin_> yeah, just wanted to avoid writing a foreign declaration for it :) but I'll do that
14:54:47 <mauke> linux is my IDE
14:54:55 <dons> cabal update ; cabal install pony ; rehash ; can-i-have-a-pony
14:54:55 <bos> pumpkin_: there's certainly code that calls memcpy on ByteArray#, but it's buried in the GHC internals.
14:55:04 <dons> :)
14:55:04 <pumpkin_> fair enough
14:55:26 <pumpkin_> lol, he really did it
14:55:37 <dons> i love hackage
14:55:48 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pony-1.0
14:56:06 <mauke> % /usr/lib/ghc-6.8.2/ghc-6.8.2
14:56:06 <mauke> ghc-6.8.2: missing -B<dir> option
14:56:22 <mauke> % /usr/bin/ghc-6.8.2
14:56:22 <mauke> ghc-6.8.2: no input files
14:56:23 <bos> i gotta say, QuickCheck is my absolute favourite Haskell library.
14:56:35 <Pseudonym> Data.Map is mine.
14:56:41 <dcoutts> dons: oh! you can have a pony. There I was saying you couldn't.
14:56:58 <rovar> i'm pretty happy with DeriveTH right now :)
14:57:03 <ddarius> dons: When's the Arch package?
14:57:04 * wli can't think of a favorite library.
14:57:05 <Pseudonym> It's been my favourite since it was called FiniteMap.
14:57:19 <mauke> Data.Sequence is pretty awesome
14:57:39 <bos> Data.Sequence would be even more awesome if the underlying finger tree was exposed so we could perform magic with it.
14:58:00 <Pseudonym> bos: True.  If you could implement, say, a priority search queue on top of it.
14:58:00 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree
14:58:03 <bos> as it is, it's too opaque for use as anything other than a sequence.
14:58:06 <Pseudonym> Then it'd be cooler.
14:58:08 <Gracenotes> go go mtl
14:58:27 <SamB> I think my favorite is the libray for monad transformers that doesn't need O(n^2) instance declarations
14:58:30 <Pseudonym> True.  MTL has saved me more than once.
14:58:32 <bos> mauke: i know about fingertree, but the two should have been packaged together
14:58:38 <bos> SamB: which one is that?
14:58:39 <SamB> Pseudonym: that isn't it
14:58:43 <SamB> bos: I'm not sure yet
14:58:57 <bos> SamB: i thought all the monad transformer libraries i've seen have that problem.
14:59:04 <Pseudonym> SamB: I was talking to Gracenotes.
14:59:07 <bos> mtl and monadLib certainly do.
14:59:08 <Peaker> SamB, I think the whole class-per-monad-type is silly
14:59:11 <Pseudonym> bos: Coproducts!
14:59:28 <bos> Pseudonym: i know not of what you speak.
14:59:37 <Pseudonym> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.3581
14:59:39 <SamB> Peaker: well ... you don't ALWAYS need one
14:59:42 <Pseudonym> Be enlightened!
15:00:39 * dcoutts is tempted to make "cabal install pony" report "No, you can't have a pony"
15:00:48 <Peaker> SamB, I prefer the approach:    newtype MyMonadT m a = MyMonad (MonadT1 (MonadT2 m) a) ; liftName1 :: MonadT1 (MonadT2 m) a -> MyMonadT m a ; liftName2 :: MonadT2 m a -> MyMonadT m a
15:00:53 <Peaker> SamB, so I never need one
15:01:09 <ddarius> Pseudonym: That doesn't lead to quite the same thing as what a monad transformer produces.
15:01:14 <Pseudonym> No, it doesn't.
15:01:21 <SamB> bos: aren't I allowed something not yet discovered as a favorite ?
15:01:35 <Pseudonym> But that's kinda the point.
15:01:48 <Pseudonym> It is true that transformers provide one feature that coproducts don't.
15:01:52 <ddarius> It's also painfully explicit.  I'll stick to my monad transformers.
15:01:58 <bos> SamB: um, sure.
15:02:21 <glguy>  what monad transformer library problem are you discussion?
15:02:28 <Pseudonym> BTW, I think that the O(N^2) instance problem is simply a design error.
15:02:33 <pumpkin_> well this has been an epicly eye-opening experience for me
15:02:43 <Peaker> Pseudonym, yeah, as I mentioned above - just newtype your transformer and give names to lifters of each level
15:02:49 <Pseudonym> Exactly.
15:02:56 <Pseudonym> Moreover, give _meaningful_ names.
15:03:15 <Peaker> Yep! The monad type is only part of the meaning
15:03:21 <Pseudonym> Rather than exposing, say, read, call it getModuleName.
15:03:24 <bos> 80 list-like functions implemented.
15:03:25 <Peaker> You could have multiple State monads for different states in there
15:03:29 <Pseudonym> Or whatever.
15:03:29 <SamB> Pseudonym: well, yeah.
15:03:37 <SamB> but what about transformers in libraries ?
15:03:50 <Pseudonym> What about them?
15:04:04 <SamB> isn't it kind of a pain if you can't stack them ?
15:04:05 <Peaker> Pseudonym, Its better to expose the lifters than to expose composition of lift with ask and such because otherwise you get a cartesian product of monad's funcs X level
15:04:14 <sjanssen> Pseudonym: I'd rather not write that boilerplate for every monad stack
15:04:17 <Peaker> SamB, why can't you?
15:04:18 <wli> I'm experiencing some pain because the mutable array monads don't conveniently stack with anything else.
15:04:27 <Pseudonym> sjanssen: You have two scenarios.
15:04:29 <Peaker> SamB, you just have to lift everything in your computation explicitly and appropriately
15:04:36 <SamB> Peaker: uh
15:04:39 <yitz> It's time to re-open our logo contest.
15:04:43 <dolio> How many instance declarations does liftBase require?
15:04:46 <SamB> Peaker: how about you do it ?
15:04:50 <Pseudonym> Either you expose a monad/transformer, or you use it internally.
15:05:01 <Pseudonym> If you expose it, then it's abstract.
15:05:09 <Pseudonym> So don't expose internal details.
15:05:11 <yitz> For years, the logo of GNU emacs was the kitchen sink, which was the only thing that emacs didn't include.
15:05:21 <yitz> Our logo now needs to be a pony.
15:05:24 <Peaker> SamB, Lifting to the right level automatically by the monad type - which is what the N^2 monad classes do, is just not right a lot of the time - and the compiler won't catch the error when you're wrong
15:05:25 <Pseudonym> If you only use it internally, then it doesn't matter.
15:05:39 <SamB> yitz: which years ?
15:05:50 <Pseudonym> You might call it boilerplate.  I call it abstraction.
15:06:09 <yitz> SamB: until about two or three years ago, iirc
15:06:10 <Pseudonym> If it's internal to a model, it's micro-abstraction, but abstraction nonetheless.
15:06:27 <wli> Peaker: I'd much rather have that than the horrors I'm hitting without auto-lifting.
15:06:40 <Pseudonym> See, if it's providing semantically meaningful operations, then it's not boilerplate.
15:07:05 <Pseudonym> If what you're writing is boilerplate, then you're doing something wrong.
15:07:06 <Peaker> wli, Why is it so horrible to specify the level? I don't mean with something like: lift . lift . lift $ ...   but with something like:  liftGUIData $ ...
15:07:34 <Pseudonym> liftIO being the classic example.
15:07:41 <wli> Pealer: Every time something gets rearranged I have to go back over 10000 lifts.
15:07:41 <pumpkin_> I'm in way above my head
15:07:45 <Peaker> Pseudonym, I disagree there - newtype'ing an abstract monad transformer and a bunch of lifters is a bit of boilerplate (It could be auto-derived from a sequence of (name, monad-transformer-type)
15:07:54 <ErhardtMundt> bye
15:08:13 <Peaker> wli, That's why you need abstract lifters like: liftGUIData = lift . lift . lift  that sits right next to your monad transformer newtype
15:08:21 <coconut> Is there a way of enabling generalized "deriving" for multi-param type classes?
15:08:31 <Pseudonym> Peaker, that's why I think you're doing something wrong. :-)
15:08:35 <Peaker> Pseudonym, but its not a lot of boilerplate and rather painless
15:08:39 <Pseudonym> liftGUIData is one way of looking at it.
15:08:48 <Peaker> Pseudonym, something like:    newtype MyMonadT m a = MyMonad (MonadT1 (MonadT2 m) a) ; liftName1 :: MonadT1 (MonadT2 m) a -> MyMonadT m a ; liftName2 :: MonadT2 m a -> MyMonadT m a
15:08:56 <Pseudonym> A better way of looking at it is to make getGUIData instead.
15:09:03 <Pseudonym> Peaker: Ugh.
15:09:06 <dblick> @src space
15:09:06 <sjanssen> coconut: I believe GeneralizedNewtypeDeriving already does that
15:09:06 <lambdabot> Source not found. Do you think like you type?
15:09:18 <dons> dcoutts: of course you can have a pony.
15:09:20 <Peaker> Pseudonym, getGUIData only exposes ask, but not other reader accessors
15:09:21 <Pseudonym> Mind you, given that you only need to write that once...
15:09:24 <dons> ?faq can i have a pony?
15:09:24 <lambdabot> The answer is: Yes! Haskell can do that.
15:09:30 <glguy> I just tried (on a recent module) having a typeclass, like MonadIO
15:09:39 <Pseudonym> Peaker: So provide other meaningful operations.
15:09:41 <Peaker> Pseudonym, but Reader only has ask, so its a bad example. I prefer State
15:09:53 <glguy> I made all of the operations i my module auto-lifting
15:10:06 <glguy> to use that monad in a stack, you implement the lift class
15:10:15 <Peaker> Pseudonym, writing getGUIData, setGUIData, modifyGUIData, instead of just liftGUIData is more boilerplate, not less
15:10:26 <Pseudonym> Peaker: Take a look at this.
15:10:28 <Pseudonym> http://www.ninebynine.org/Software/Swish-0.2.1/HaskellRDF/Dfa/Dfa.lhs
15:10:33 <glguy> so to use it you implement one instance and all of the operations lift as specificed
15:10:41 <Pseudonym> The monad I used there3 was:
15:10:43 <Pseudonym> type ReM m t a = StateT (ReState t) (ReaderT (ReRead t) m) a
15:11:14 <Pseudonym> About 1/3 of the module is devoted to providing an abstraction layer.
15:11:33 <Pseudonym> Rather than exposing modify, get, set, etc, I exposed _meaningful_ operations.
15:11:44 <Pseudonym> Like remPush.
15:11:45 <coconut> sjanssen: you are right, but I'm not sure about the syntax
15:12:03 <Pseudonym> Now I'm not saying this is always appropriate, especially if you have a large surface area.
15:12:09 <coconut> sjanssen: the deriving clause has to have arity 1, but allows currying
15:12:23 <coconut> sjanssen: is there a way to curry in the second argument?
15:12:24 <Pseudonym> But I think that in general, if you can, hide implementation.  Even within a module.
15:12:54 <Pseudonym> One more thing.  I think that providing transformer and non-transformer versions of everything was a mistake.
15:12:55 <sjanssen> coconut: MonadState S -- for example
15:12:57 <Pseudonym> Well...
15:13:00 <sjanssen> will derive an instance MonadState S thetype
15:13:04 <Peaker> Pseudonym, well, in a little toy I wrote a while ago I had a "meaningful" modifyGUIState, modifyModel, writeGUIState, getGUIState, getModel, writeModel - which I instead exposed as liftGUIState, liftModel
15:13:17 <Pseudonym> Maybe not a mistake.  Maybe it was necessary when the compiler wasn't so sophisticated.
15:13:41 <Peaker> Pseudonym, both allowed a state operation to be lifted to the right level
15:13:48 <gaze__> what's the best way to represent a data structure that gets filled in as the program progresses... I was thinking it could be a bunch of Maybes but that doesn't seem right...
15:13:54 <coconut> sjanssen: right, what I want is deriving (\S -> MonadState S M)
15:14:06 <coconut> sjanssen: (currying in the *first* argument actually)
15:14:07 <Pseudonym> Peaker: Maybe.  Perhaps it's because GUIState and Model have a huge surface area.
15:14:16 <Peaker> gaze__, What is this data that's being filled?
15:14:17 <sjanssen> coconut: oh, I think you have to use GHC's standalone deriving syntax for that
15:14:24 <Peaker> Pseudonym, "surface area"?
15:14:38 <gnuvince_> Is it an error to try and define a Monad instance that would have the type m a -> (a -> m a) -> m a?
15:14:40 <coconut> sjanssen: I see, thanks
15:14:42 <ddarius> gaze__: Do you ever touch the data when it isn't there (i.e. do you ever check if it is there?)
15:14:45 <Pseudonym> The surface area of an abstraction is, roughly speaking, the number of operations on it that you need.
15:14:46 <sjanssen> coconut: derive instance MonadState s M
15:14:51 <ddarius> gnuvince: Yes.
15:15:05 <Pseudonym> Reader, for example, only really has one or two operations, so a low surface area.
15:15:09 <Pseudonym> IO has lots.
15:15:13 <gaze__> well, the structure holds client information
15:15:16 <Pseudonym> So a large surface area.
15:15:28 <gaze__> so, fqdn, capabilities, etc.
15:15:34 <gaze__> so as the client issues commands it gets filled in
15:15:41 <Pseudonym> liftIO makes sense because you can't re-abstract every IO operation.  That really would be boilerplate.
15:15:58 <gaze__> and if it tries to do something that conflicts with the data in the structure, that'd be an error condition
15:16:11 <gnuvince_> ddarius: so if my type cannot acommodate that, I can't make it a monad?
15:16:16 <wli> Usually I try to break things up into things that stack.
15:16:21 <Pseudonym> But it can make sense to re-expose Reader or, even better, provide a meaningful abstraction layer on top of it that doesn't leak the fact that it's Reader.
15:16:24 <wli> e.g. a counter monad
15:16:28 <Pseudonym> Right.
15:16:33 <Pseudonym> A counter monad is a good example.
15:16:38 <Pseudonym> You can think of it as State.
15:16:43 <ddarius> gnuvince: It's not a monad if you can't make a (>>=) of it's given general type (which is what I think you are talking about)
15:16:47 <Pseudonym> But you wouldn't expose State.  You'd expose increment.
15:16:52 <gaze__> wli!!!
15:16:58 <wli> I usually call it "tick"
15:17:02 <Peaker> Pseudonym, well, I agree it has a large surface area and wasn't particularly good - but for that not-bright-design, the lifters were the best solution
15:17:04 <Pseudonym> Cool.
15:17:10 <Pseudonym> Peaker: Sure.
15:17:14 <wli> gaze__: /
15:17:21 <Pseudonym> So in a RAD-like scenario, I can definitely see doing the lifter thing.
15:17:21 <wli> gaze__: ?
15:17:28 <Peaker> Pseudonym, which consisted of minor repetition (no big deal though)
15:17:31 <Pseudonym> Yeah.
15:17:42 <Peaker> (Nothing N^2 or such :)
15:17:43 <gaze__> wait, you are the same wli as from #osdev, right?
15:17:49 <ddarius> Pseudonym: RAD = write bad code quickly?
15:17:59 <Pseudonym> You can't write bad code in Haskell, so no.
15:18:04 <wli> gaze__: Yes.
15:18:09 <coconut> sjanssen: it explicitly refuses: "(The last argument of the instance must be a data or newtype application)"
15:18:12 <Pseudonym> RAD = get something working quickly
15:18:16 <Peaker> gaze__, You'd probably want something to input the data and return it whole
15:18:45 <wli> Anyway, I do the autolifting stuff when I roll my own monad transformer abstractions.
15:19:11 <Pseudonym> I'd still like coproducts, anyway.
15:19:27 <pumpkin_> I have a kind error :(
15:19:28 <Peaker> wli, the thing that bothers me there is not just the N^2 craziness (everyone knowing everyone else) but also the fact that the monad transformer's type is not the right indicator of the level you want to lift to
15:19:37 <ddarius> pumpkin: Would you rather a mean error?
15:19:38 <gaze__> yeah but it just kinda does a repl kinda thing... like this data structure might as well be the environment.
15:19:41 <dolio> I don't see how one is obviously "less boilerplate" than another.
15:19:44 <gaze__> I guess I could just do it as a hash or a list
15:19:54 <pumpkin_> ddarius: I'd rather no error :P
15:20:03 <dolio> You're just choosing between writing more function definitions and writing "lift" more all over the place.
15:20:27 <ddarius> gaze__: You could have something like a Map Key Value and add to it.
15:20:31 <Peaker> dolio, not "lift" - but specific "liftToRightLevel" functions to accomodate each newtype'd transformer
15:20:43 <Pseudonym> I agree dolio.  If you really think it's boilerplate, then the choice is between boilerplate and boilerplate plus multiple maintenance problem.
15:20:45 <dolio> That's the same thing.
15:20:52 <Pseudonym> I'll take the boilerplate if that's my choice.
15:20:59 <gaze__> alright... alternatively I could just have a data structure full of maybes... is that kosher?
15:21:04 <Peaker> dolio, "liftToRightLevel" which captures the right level you want to by name, rather than type (which may be wrong)
15:21:15 <Pseudonym> gaze: You should get it checked by a Rabbi.
15:21:27 <Peaker> dolio, liftState is wrong - liftGUIState or liftModelState may be right
15:21:33 <Pseudonym> It could be done well or it could be done poorly.
15:21:50 <ddarius> gaze__: Nothing stops you.  See some of the configurations as monoids stuff.
15:21:54 <Pseudonym> Yeah.
15:22:01 <Pseudonym> There's nothing wrong with it in principle.
15:22:08 <gaze__> it just seems gross.
15:22:23 <Pseudonym> gaze: Then you should add a layer of abstraction so the grossness is contained?
15:22:27 <Peaker> gaze__, Can't the function that reads the data build it in a lexical scope and then return the data whole?
15:23:29 <Peaker> gaze__, also see: http://conal.net/blog/posts/merging-partial-values/
15:24:05 <Pseudonym> It'd be nice if you could auto-derive Monoid.
15:24:09 <Pseudonym> If your type is a product of Monoids.
15:24:18 <Pseudonym> You can probably do it with TH.
15:24:24 <pumpkin_> oh my god, I got my epic hackage to actually compile
15:24:27 <pumpkin_> I wonder if it works
15:24:32 <Pseudonym> Epic success!
15:24:37 <pumpkin_> I bet it'll crash with a wonderful ghc internal error
15:25:01 <sjanssen> Pseudonym: I suppose you could newtype T = T (a, b, c ...)
15:25:14 <sjanssen> but that's ugly
15:25:19 <Pseudonym> Yes.
15:25:38 <Pseudonym> There's probably a SYB way of doing it.
15:26:21 <monochrom> epic build
15:26:41 <dons> dcoutts: :) http://www.reddit.com/r/programming/comments/7zfyn/can_haskell_give_me_a_pony_video/
15:26:43 <olsner> epic build?
15:26:56 * dons feels silly. but i do like ponies
15:27:04 <monochrom> pumpkin got his epic package to build successfully. epic build. :)
15:27:16 <pumpkin_> :P
15:27:16 <Pseudonym> People who say they like ponies have never owned an actual pony.
15:27:25 <pumpkin_> I realized I forgot to implement one function
15:27:30 <pumpkin_> so can't tell if it crashes or not just yet
15:27:44 <olsner> dons: awesome!!
15:27:54 <fsanches> Pseudonym: True, but does that really matter? Everyone loves ponys!
15:27:56 <sjanssen> dons: your videos play now, but youtube constantly displays the little buffering animation
15:28:07 <sjanssen> dons: youtube doesn't like Haskell, apparently :)
15:28:10 <dons> yeah, that's what I get.
15:28:16 <Pseudonym> Did you know that there's a critical distance at which sheep become picturesque?
15:28:28 <dons> they've gone from low-def always working .ogv, to hi-def, mostly works .gov
15:28:28 <monochrom> funny
15:28:29 <dons> .ogv
15:28:56 <Pseudonym> That's not a pony, it's a unicorn.
15:29:05 <BMeph> So, if pumpkin's build crashes with a lot of weird type failures, would that be a 'monic fail'? ;p
15:29:10 <dons> yeah, it's like 'generics' in haskell
15:29:11 <Pseudonym> And it's not even a good one.
15:29:20 <olsner> Pseudonym: what's a unicorn if not a horned pony?
15:29:21 <dons> we reserve 'pony' for serious examples
15:29:28 <fsanches> Pseudonym: It could be a unicorn pony. Or a horned pony.
15:29:29 * Pseudonym sighs
15:29:34 <Pseudonym> Do people know nothing?
15:29:42 <pumpkin_> is there an easy way to convert a lazy bytestring into a _single_ strict one?
15:29:42 <Pseudonym> A unicorn is not a horse with a horn.
15:29:51 <olsner> is too
15:29:52 <Pseudonym> It has a goat beard, a lion's tail and cloven hooves.
15:29:55 <fsanches> So it's a pony with a horn?
15:29:56 <sjanssen> what is it?
15:29:56 <dons> pumpkin_: yes, concat . fromChunks
15:30:04 <pumpkin_> ah, thanks
15:30:06 <dons> at least it isn't a narwhal
15:30:32 <Pseudonym> http://upload.wikimedia.org/wikipedia/commons/a/ae/Wildweibchen_mit_Einhorn.jpg
15:30:37 <Pseudonym> See?  Cloven hooves.
15:30:54 <sjanssen> dons: ooh, there should be a --narwhal flag to your program
15:30:57 <dons> hehe
15:31:00 * ddarius doesn't know what a Weibchen is.
15:31:03 <mauke> female
15:31:14 <Pseudonym> Yes.
15:31:20 <Pseudonym> Wildweibchen == wild woman
15:31:29 <mauke> not really
15:31:34 <Pseudonym> No?
15:31:47 <cjb> what's the difference between weibchen and madchen?
15:31:54 <mauke> more like "female game"
15:32:08 <whpearson> Sorry, I need a bit more guidance as to why this doesn't work http://pastebin.com/d463edcb0. I feel it is the same sort of error as before, but I don't know how to apply the same fix as last time.
15:32:09 <mauke> or am I reading this wrong?
15:32:16 <Pseudonym> mauke: This is from 1500.
15:32:24 <Pseudonym> There might be a dialect issue.
15:32:25 <ddarius> Pseudonym: That's a really ugly picture by the way.
15:32:32 <mauke> ok, right
15:32:34 <Pseudonym> I didn't paint it.
15:32:42 <monochrom> haha, "monic fail", I'll use that next time.
15:33:00 <Pseudonym> http://upload.wikimedia.org/wikipedia/en/7/78/The_Hunt_of_the_Unicorn_Tapestry_7.jpg That one is a bit fuzzy, but you can still see the cloven hooves.
15:33:17 <mauke> cjb: http://dict.leo.org/ende?search=weibchen
15:33:54 <ddarius> Pseudonym: That doesn't seem like it would be much of a hunt.
15:34:15 <Pseudonym> Well, this is obviously after it was captured.
15:34:57 <cognominal> Network.URI seems broken
15:35:17 <Pseudonym> Anyway, consult your bestiary for further details.
15:35:33 <cognominal>  isURI "http://sun.com"
15:35:33 <cognominal> *** Exception: q: openFile: does not exist (No such file or directory)
15:35:33 <cognominal> GOA Network.URI> isURI "http:/sun.com"
15:35:33 <cognominal> isURI "http:/sun.com"
15:35:33 <cognominal> True
15:35:33 <cognominal> GOA Network.URI>
15:35:34 * whpearson curses the day he tried to think of a nice way to add instances of Num for Sum, Products etc.
15:35:50 <pumpkin_> w00t, I can unsafeserialize and unsafedeserialize UArrs :P
15:35:55 <wli> Medieval German is quite different.
15:36:12 <sjanssen> whpearson: instance Num a => Num (Sum a)?
15:36:28 <cognominal> anyway how can isURI can get me an exception with a file does not exist?
15:36:32 <sjanssen> whpearson: you could even newtype derive that, I bet
15:36:48 <cognominal> I am utterly confused...
15:37:02 <monochrom> whpearson: I feel that "instance (Show (w a), Eq (w a), WrappedNum (w a) a)=> Num (w a)" is wrong. Should be "instance (Show w, Eq w, WrappedNum w a)=> Num w"
15:37:02 <cognominal> should I use something else to parse URIs?
15:37:02 <wli> It's not usually as convenient as "Wildweibchen." Spelling also tends to be weird and nonstandardized. The handwriting is also different.
15:37:43 <Yoric[DT]> Hi.
15:37:49 <Yoric[DT]> I have a type-theoretical question.
15:37:58 <Yoric[DT]> Is anyone around here familiar with existentials?
15:37:58 * wli is running into number-like affairs that really want something like a MonadReader.
15:38:15 <whpearson> sjanssen, I'm trying avoid the boilerplate of implementing  + - etc for all the very similar types.
15:38:19 <Yoric[DT]> (essentially, I need someone who could explain something about unpack)
15:38:32 <whpearson> monochrom: I'll fiddle some more
15:38:56 <sjanssen> whpearson: are you familiar with GHC's newtype deriving extension?
15:39:06 <pumpkin_> I feel a lot more intimate with GHC's internals now
15:39:21 <whpearson> sjanssen: It is safe to assume I not familiar with much.
15:39:40 <monochrom> yeah, "deriving Num" works much better and eliminates WrappedNum.
15:39:42 <sjanssen> whpearson: newtype Max a = ... deriving (Num, ...)
15:39:59 <sjanssen> whpearson: that will generate "instance Num a => Num (Max a) where ..." for you
15:40:10 <monochrom> The best way to fix bugs is delete code. I'm serious.
15:40:35 <monochrom> "so simple there is obviously no error" vs "so complicated there is no obvious error" thing.
15:40:44 <Twey> pumpkin_: Kinky
15:40:52 <pumpkin_> yeah :)
15:40:58 <pumpkin_> I've used all sorts of nasty hacks
15:41:41 <whpearson> Heh, that works with the extension enabled.
15:41:43 <pumpkin_> Creating an ST by hand, unsafeCoerce#s up the wazoo, threading the state thread around myself
15:43:01 * Twey laughs.
15:43:05 <hackage> Uploaded to hackage: pony 1.0
15:43:15 <pumpkin_> it's pretty awesome
15:43:26 <pumpkin_> I've even more surprised that it worked the first time
15:44:08 <pumpkin_> http://pastie.org/private/t8gpmby7ufge5qsw8ykt8a that beast, that is
15:44:26 <jdkoeck> Has anyone used the mutable priority queue package ? Maybe I should use fingertrees, but I'm trying to make my program as fast as possible.
15:44:31 <pumpkin_> those fromIntegrals are probably unnecessary
15:44:36 <pumpkin_> if I was willing to throw a few more hashes in
15:45:19 <pumpkin_> anyway bbiab
15:47:22 <yitz> jdkoeck: are you sure you need that? try one of the many pure pq packages first and see if that is really your bottleneck
15:47:54 * whpearson hopes that GeneralizedNewtypeDeriving goes into haskell'
15:49:43 <redditbot> cabal update ; cabal install pony ; rehash ; can-i-have-a-pony
15:49:53 <Botje> :]
15:50:35 * Twey laughs.
15:50:58 <Cale> haha, look at the new Haskell reddit logo :)
15:51:33 <skorpan> Cale: where?
15:51:37 <Cale> http://www.reddit.com/r/haskell/?fp
15:51:47 <Twey> Hahaha, what is that?
15:51:47 <skorpan> i don't get it
15:51:49 <skorpan> what is that?
15:51:56 * Twey high-fives skorpan.
15:51:57 <yitz> a narwhal. hehe
15:52:04 <chrisdone> whpearson: agreed, that is good stuff
15:52:20 <skorpan> is that some kind of pun?
15:52:22 <fsanches> amazing
15:52:31 <Twey> Ohhh
15:52:32 <Twey> Hahaha
15:52:44 <fsanches> skorpan: it's one of the "proposed" logos
15:52:53 * wli wishes for a Haskell' without quite as many chains of backward compatibility.
15:52:54 <Twey> http://haskell.org/haskellwiki/Shootout — eh?  Loses to C on source size?  I don't believe it
15:52:55 <skorpan> we're getting an official logo?
15:52:58 <Cale> There was a thing like that which said something like "Narwhals, yeeeaaaahhh!!"
15:53:01 <Twey> wli: I concur
15:53:13 <Cale> and so someone turned it into a proposal for a Haskell logo
15:53:18 <dons> something like that ... http://img525.imageshack.us/img525/7835/ignboardsofficiallookinkj4.png
15:53:19 <Cale> and now it's on the reddit :)
15:53:27 <Pseudonym> Twey: I can believe it.  Writing C in Haskell is verbose.
15:53:41 <dons> Twey: arrays are verbose
15:53:47 <skorpan> lol
15:53:47 <Twey> But I thought the benchmarks were supposed to be idiomatic
15:53:49 <Twey> Ah, true
15:53:55 <dons> no, they're supposed to be fast
15:53:56 <Cale> Oh, right, I'd almost forgotten about that thread :)
15:54:08 <dons> idiomacy is something explicitly not measured.
15:54:16 <dons> if that's the wrod.
15:54:26 <raxas> Cale: http://www.weebls-stuff.com/toons/Narwhals/?
15:54:31 <FunctorSalad_> what was it for .lhs -> .hs again?
15:54:33 <Twey> Cripes, 300× worse on memory use?
15:54:43 <dons> that's a bug
15:54:50 <dons> literally.
15:55:16 <dons> #2747
15:55:27 <dons> Fixed Thu Nov 6 03:37:14 PST 2008 Simon Marlow
15:55:34 <Twey> Ah
15:55:44 <Cale> I see that weebl's still up to his flash loops :)
15:55:50 <Twey> Why's it still there, then?
15:56:01 <Twey> « Haskell entries compared to C on the quad core, Feb 2009 »
15:56:14 <dons> ghc 6.10.2 isn't out yet?
15:56:28 <dons> it was found right after the ghc 6.10.1 relesae
15:56:32 <chrisdone> Cale: got lions and tigers. WHERE?
15:56:58 <idnar> chrisdone: only in Kenya!
15:57:00 <Cale> Only in Kenya
15:57:05 * chrisdone beams
15:57:10 <dons> ah kenyans
15:57:41 <sjanssen> wut?
15:58:02 <chrisdone> http://www.weebls-stuff.com/toons/kenya/
15:58:06 <dons> http://www.youtube.com/watch?v=qRuNxHqwazs
15:59:17 <chrisdone> Cale: what do you think of × for mappend?
15:59:30 <Cale> great, but too annoying to type
15:59:40 <chrisdone> mine is alt+8 :-(
15:59:48 <Twey> Compose x x
16:00:04 <Cale> Why not just ++ ?
16:00:13 <Twey> Oops, bed-time.  'night.
16:00:35 * raxas wishes ghc could crosscompile some day
16:00:44 <mjrosenb> raxas: same here
16:00:46 <mjrosenb> actually
16:01:00 <mjrosenb> i just want it to compile on ppc-64 in linux
16:01:02 <jdkoeck> dons: sent you a twitt about my program
16:01:07 <dons> jdkoeck: woot!
16:01:09 <dons> url?
16:01:23 <jdkoeck> dons: http://pastie.org/396979
16:01:35 <chrisdone> Cale: is changing the meaning of a common symbol a good idea? I'm thinking about how in Clojure everything has different names because it does something different ... seems like a good idea
16:01:44 <dons> how are you compiling it?
16:02:04 <jdkoeck> dons: ghc -o huffman -Wall -O2 -funbox-strict-fields --make Main
16:02:07 <dons> ok.
16:02:21 <Cale> chrisdone: I don't think of it so much as changing the meaning as generalising it.
16:02:26 <dons> data Tree = Node Label !Weight Tree Tree | Leaf !Char !Weight
16:02:34 <dons> nice code
16:02:39 <Cale> chrisdone: The new definition subsumes the old one as a special case.
16:02:43 <dons> even some room for parallelism
16:02:44 <jdkoeck> dons: thank you !
16:02:56 <chrisdone> Cale: true. it doesn't break backwards compatibility
16:03:11 * wli is duly terrrified of system-level programming in Haskell.
16:03:13 <dons> oh, odd.
16:03:22 <wli> (e.g. odd syscalls)
16:03:39 <Cale> Plus it just looks right in a lot of handy cases... like combining comparison operators :)
16:03:39 <dons> jdkoeck: you're taking in a bytestring, unpacking it to a list writing each element in to an STUarray then assocs of the array
16:03:42 <dons> that's very inefficient
16:04:08 <Cale> sortBy (comparing length ++ compare) (words "here are some words to sort by length and then alphabetically")
16:04:12 * edward1 likes ++ for mappend, but has generally accepted the fact that he can't get the haskell world to change things like (.) or (++) to more general definitions.
16:04:24 <dons> firstly, we'd never want to unpack a bytestring
16:04:26 <chrisdone> Cale: that is gorgeous. om nom nom❤
16:04:29 <Cale> edward1: I don't know about that, I'm still hoping :)
16:04:44 <sjanssen> jdkoeck: using ST in this case is probably no faster than the oneline "accumArray (+) 0 (minBound, maxBound) . map (flip (,) 1)"
16:04:47 <dons> jdkoeck: do you see the code i'm talking about
16:04:49 <edwardk> cale: you have far more stamina for this fight than i ;)
16:04:51 <dons> countOcc :: P.ByteString -> [Tree]
16:04:54 <dons> should be very efficient
16:04:55 <jdkoeck> dons: I know... but I did not find any forM for bytestrings
16:04:56 <sjanssen> (perhaps a bit, but not much at all)
16:05:09 <dons> well, you can just write a loop (or use a bytestring trie even?
16:05:18 <chrisdone> edwardk: maybe the Hackage.Username stuff could at least help?
16:05:28 <dmead_home> >?hoogle sortby
16:05:30 <chrisdone> is that idea being taken seriously?
16:05:32 <BONUS> i like generalizing ++ to monoid and . to cat but i dread of having to explain those to someone who's a newbie
16:05:34 <dmead_home> ?hoogle sortby
16:05:35 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
16:05:40 <dmead_home> ?src sortBy
16:05:40 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:05:48 <chrisdone> BONUS: and map to fmap? :D ?
16:05:48 <BONUS> not really dread but it would be like java's void main static blah blhah blah
16:05:49 <dons> otherwise the code looks ok.
16:05:53 <dmead_home> ?src insertBy
16:05:54 <lambdabot> insertBy _   x [] = [x]
16:05:54 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
16:05:54 <lambdabot>                                  GT -> y : insertBy cmp x ys'
16:05:54 <lambdabot>                                  _  -> x : ys
16:05:54 <BONUS> yeah
16:05:58 <jdkoeck> dons: I should write a loop to iterate on the bytestring ?
16:05:59 <dons> just that conversion from bytestring -> tree is wacky.
16:06:06 <BONUS> where you have to tell someone: use this without knowing what it actually is for now
16:06:11 <glguy> jdkoeck, is the input set somewhere online?
16:06:15 <chrisdone> BONUS: isn't most of haskell like that?
16:06:19 <dons> bytestring -> list -> stuarray -> list -> tree
16:06:23 <dons> too many data structures :)
16:06:30 <chrisdone> "the IO monad is ah, uhm, well you can print to the screen, we'll find out what a monad is later"
16:06:36 <dons> jdkoeck: yeah, talk to glguy
16:06:36 <pumpkin_> must... do... fusion
16:06:49 <BONUS> chrisdone: i wouldn't say most, i think there's a lot you can teach without saying "trust me" too much
16:06:59 <Cale> It doesn't matter what a monad is until you know at least two of them.
16:07:03 <dons> jdkoeck: it would also be helpful to see the ocaml code
16:07:11 <glguy> jdkoeck, is this the same algorithm you are using? http://pastie.org/396987
16:07:11 <sjanssen> jdkoeck: I also think the use of ST in 'codes' is not necessary
16:07:17 <dons> since given identical structures ghc / ocaml should produce pretty much identical results
16:07:27 <BONUS> i tried to take that way when writing LYAH, the only place i think i do the "trust me" thing is I/O but i dont even say that it's a monad
16:07:40 <Cale> yes, I agree with that approach I think.
16:07:57 <BONUS> imho IO being a monad is not that important anyway
16:07:59 <chrisdone> BONUS: do you think there is a good explanation waiting to be thought for standard functions instead of dumbing them down?
16:08:12 <Cale> Don't even bother mentioning that IO is a monad unless you want to explain about monads first without the IO example.
16:08:13 <jdkoeck> I'm trying to re-find the input set online
16:08:15 <BONUS> yeah probably
16:08:28 <Cale> Yeah, it's not that important that IO is a monad.
16:08:59 <dons> is it classic huffman encoding? i wonder if that's still a two liner
16:08:59 <jdkoeck> ok, the data set is here : http://www.kilgarriff.co.uk/bnc-readme.html
16:09:07 <ozy`> if IO were a non-monad, the only real change would be that you couldn't use do-notation with it; you'd have to use special operators.
16:09:10 <jdkoeck> direct link : http://www.kilgarriff.co.uk/BNClists/all.al.gz
16:09:18 <BONUS> so yeah this is an interesting dilemma
16:09:32 <jdkoeck> it's a word frequency list (I used it to build an ocaml spellchecker, completely unrelated)
16:09:42 <jdkoeck> glguy: I'm reading your code
16:09:55 <BONUS> on the one hand functions can be more general and elegant, but on the other hand they're scarier for newbies who can get confused enough as it is
16:10:26 <BONUS> but i dont think the language should be limited just so newbies aren't scared away or something
16:10:32 <Cale> BONUS: Well, you can explain the special case. Eventually you teach what a typeclass is and then it hardly matters.
16:10:41 <BONUS> it's up to us to find the appropriate explanations and ways of teaching
16:10:48 <glguy> jdkoeck, whoa, are you storing all of the words in a List and using the list "insert" function??
16:11:02 <pumpkin_> insertion sort ftw
16:11:04 <BONUS> yeah
16:11:19 <chrisdone> I think if I were to learn another language, I'd be happy with a X does this, and can be used for other things, too, which we can check out later
16:11:21 <sjanssen> jdkoeck: your algorithm won't produce the optimal Huffman code
16:11:29 <jdkoeck> I know about this
16:11:36 <jdkoeck> This is just a quick implementation
16:11:42 <glguy> jdkoeck, insert actually runs linearly down the list
16:11:45 <BONUS> there's still that baby haskell for people too scared of real haskell, although i dont think i'd recommend it
16:11:46 <sjanssen> erm, sorry, it will.  I missed the "insert"
16:11:47 <jdkoeck> I should use 2 priority queues
16:11:49 <glguy> not for use in cases where you have more than a few elements
16:11:50 <dons> yeah, so the original impl was all lists, which is fine.
16:11:50 <jdkoeck> one for leaves
16:11:54 <jdkoeck> one for nodes
16:12:00 <glguy> jdkoeck, no, just look at what I pasted
16:12:03 <dons> and you use mutable arrays in ocaml?
16:12:05 <ozy`> BONUS: baskell? helium?
16:12:12 <BONUS> yeah helium
16:12:15 <BONUS> thats it
16:12:23 * sjanssen throws his hat in the ring http://pastebin.com/m7adeda28
16:12:30 <jdkoeck> dons: yes, i can post it too (should clean it up before)
16:12:46 <chrisdone> admittedly I remember first learning Haskell and someone tried to explain fmap to me and Functor and I wasn't having any of it
16:12:50 <dons> sjanssen: w2c is exported from bytestring i you need it
16:12:56 <sjanssen> complete with an untested decoding optimization
16:12:58 <Cale> chrisdone: Was it me?
16:13:00 <Cale> hehe
16:13:12 <chrisdone> might have been
16:13:40 <dons> haskell comes with a wider range of data structures out of the box, than ocaml, and the arrays are less intuitive, so you have to be somewhat careful early on when 'benchmarking'
16:13:51 <BONUS> although the state of haskell learning materials is waaay better today imho than when i started learning it back in march or april
16:13:52 <dons> since haskell's going to encourage you to use lists, before say, a priority queue
16:13:54 <jdkoeck> I was at first using Map to map from characters to occurences, but it was too slow
16:13:59 <glguy> jdkoeck, are you ignoring the contents of this all.al other than creating a tree based on the individual characters?
16:14:00 <dolio> Rereading that paper, monad coproducts seem a bit less attractive than I'd previously thought.
16:14:02 <jdkoeck> Ok
16:14:02 <dons> while ocaml's going to push you towards mutable arrays
16:14:08 <maurer> Is there a way to compose a regular function with a monad without writing custom glue code? I'm looking for something along the lines of
16:14:08 <maurer> a <- get . (!! n)
16:14:13 <BONUS> mainly because of RWH
16:14:17 <Cale> BONUS: You should have seen what it was like when I started :)
16:14:18 <maurer> (where the state in that state monad is a list)
16:14:20 <jdkoeck> glguy: yes, I'm just looking at characters
16:14:24 <glguy> kk
16:14:25 <BONUS> Cale: haha oh my
16:14:25 <chrisdone> BONUS: agreed. when I started it was basically Gentle and YAHT (which I read in that order)
16:14:28 * bos adds a portable line splitting function to Data.Text, but wonders what to call it.
16:14:31 <pumpkin_> is there a way to declare "Friend" modules that can see all your symbols, without exporting those to the general public?
16:14:35 <bos> it's currently named "lines'"
16:14:42 <Cale> maurer: er, what's the code supposed to do?
16:14:45 <chrisdone> splitLines?
16:14:47 <dons> bos: mm. split of some kind?
16:14:52 <Cale> maurer: get the nth element of the state?
16:14:56 <maurer> Cale: yes
16:14:57 <Cale> maurer: fmap (!! n) get
16:15:00 <FunctorSalad_> pumpkin_: heh, I just ran into exactly this problem...
16:15:03 <BONUS> i did gentle and that haskell for c programmers tutorial and then i started hanging areound here and just learning by osmosis
16:15:03 <maurer> Cale: Thanks
16:15:05 <chrisdone> yeah, can it be implemented in terms of Data.List.Split?
16:15:12 <ddarius> Cale: gets (!! n)
16:15:21 * BONUS thinks learning by osmosis is underrated
16:15:25 <chrisdone> agreed
16:15:27 <Cale> Or yeah, gets
16:15:29 <Cale> :)
16:15:32 <chrisdone> learning by Calemosis
16:15:32 <FunctorSalad_> (trying to derive Data for some types from the ghc package, but they don't export their constructors)
16:15:42 <pumpkin_> FunctorSalad_: yeah, did you find a good way?
16:15:44 <dons> we should collect these huffman's on the wiki
16:15:47 <BONUS> chrisdone: lol. so true
16:16:00 <BONUS> also yeah the haskell wikibooks page helped me a lot
16:16:07 <BONUS> i still read it sometimes today
16:16:11 <FunctorSalad_> pumpkin_: not yet :(
16:16:30 <jdkoeck> glguy: I get your code now, it's neat (and how did you come up with it so fast ??)
16:16:54 <JoshTriplett> I can re-export the contents of a module as part of my module by putting "module Some.Module.Name" in my export list, but does any means exist to re-export a module's contents qualified?
16:16:55 <FunctorSalad_> pumpkin_: maybe have the package export everything, but ask the user to import some dummy package that only exports the public stuff?
16:17:00 <glguy> jdkoeck, fast inserts and fast findMin makes me think of Data.Map
16:17:34 <chrisdone> BONUS: I think being a good haskeller might require an attitude shift from the fierce skepticism of anything weird to fascination with anything that could be a neat abstraction
16:17:43 <pumpkin_> > unsafeDeserialize $ unsafeSerialize (toU [1:+2,2:+3,3:+4]) :: (UArr (Complex Double), ByteString)
16:17:43 <pumpkin_> (toU [1.0 :+ 2.0,2.0 :+ 3.0,3.0 :+ 4.0],Empty)
16:17:44 <lambdabot>   Not in scope: `unsafeDeserialize'Not in scope: `unsafeSerialize'Not in scop...
16:17:47 <JoshTriplett> For instance, something like "module Something ( module Text.XHtml.Strict H ) where import qualified Text.XHtml.Strict as H ..."
16:17:52 <pumpkin_> whee
16:17:59 <dons> might be worth benchmarking http://hackage.haskell.org/packages/archive/PSQueue/1.1/doc/html/Data-PSQueue.html
16:18:02 <dons>  at some point
16:18:09 <JoshTriplett> So that doing a bare "import Something" gives me the names from Text.XHtml.Strict as H.foo .
16:18:14 <pumpkin_> FunctorSalad_: was thinking of that, but it seems like it would still mess with the inlining wouldn't it?
16:18:16 <dons> seems to be not quite obvious what the canonical priority queue impl. is.
16:18:17 <chrisdone> there's usually something in the back of my mind in Haskell that's weird that I have to learn at some point. can't think what it it as the moment
16:18:27 <BONUS> chrisdone: yeah, totally agreed. some people are like "wtf" when they meet a new weird concept, i just get a big grin on my face and dive into it
16:18:30 <Cale> PSQueue is really cool
16:18:35 <BONUS> and then when i get it the grin is even bigger
16:18:38 <FunctorSalad_> pumpkin_: no idea...
16:18:48 <chrisdone> BONUS: :D
16:18:54 <p_l> BONUS: And some people grab the concept, make others wtf and run away with it ;P
16:18:55 <Cale> At least in terms of its interface and asymptotic performance.
16:19:00 <chrisdone> what's all this about parametrized monads?
16:19:01 <BONUS> hahah
16:19:02 <jdkoeck> glguy: I will use your code and see how fast it is, coming back in a few minutes
16:19:04 <Cale> I don't know how good the concrete implementation is.
16:19:38 <sjanssen> dons: the priority queue implementation shouldn't matter much, anything with O(n log n) will do since n = 256
16:19:41 <BONUS> chrisdone: cool generalization of monads, really simple to boot, check out sigfpe's blog for more
16:19:50 * chrisdone googles
16:19:52 <pumpkin_> dons: my epic binary/unsafebytestring implementation is up on the patch-tag fork (in the git sense, not sure how darcs thinks of forks) of uvector
16:20:17 <BONUS> i toyed a bit with parameterized monad transformers, but i'm still not done with them
16:20:30 <chrisdone> BONUS: oh, haha. this is in my bookmarks. I forgot I meant to read this ^_^
16:20:56 <BONUS> also, slightlyly off-topic, is it parameterized or parameterised?
16:21:20 <chrisdone> or parametrized?
16:21:20 <bos> depends on whether you write in british or US english.
16:21:31 <BONUS> which is which
16:21:37 <bos> z is american.
16:21:41 <JoshTriplett> http://www.googlefight.com/index.php?word1=parameterized&word2=parameterised
16:21:46 <BONUS> i dont think it's parametrized because it's "parameter"
16:21:53 <BONUS> not parametric
16:22:04 <JoshTriplett> BONUS: Yeah, you definitely don't drop the e. :)
16:22:06 <FunctorSalad_> it's a tough choice if you are neither british or US and have to 'take sides' ;)
16:22:20 <chrisdone> I saw a weird 'e' drop recently, so I was suspicious
16:22:30 <JoshTriplett> FunctorSalad_: I like the googlefight approach.  parameterized wins on the web. :)
16:22:31 <pumpkin_> or both
16:22:37 <BONUS> FunctorSalad_: yeah. i'm neither and i find myself mixing and matching often, i'll have to pick a side one day
16:22:38 <Badger> always s
16:22:39 <Badger> :)
16:22:49 <dolio> Go with British. You'll sound more sophisticated.
16:22:55 <FunctorSalad_> :)
16:23:02 <chrisdone> I usually just go with american seeing as it dominates coding
16:23:15 <ddarius> dolio: One word: aluminum
16:23:18 <dons> pumpkin_: ok...
16:23:28 <BONUS> lol
16:23:29 <chrisdone> "compile error: undefined property: x.colour"
16:23:51 <ddarius> @hackage colour
16:23:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour
16:24:10 <chrisdone> "A model for human colour/color perception"
16:24:11 <chrisdone> hahaha
16:24:14 <pumpkin_> http://patch-tag.com:5003/publicrepos/pumpkin-uvector (this one)
16:25:10 <Badger> ddarius: what about aluminium?
16:25:55 <dolio> pumpkin_: I don't think your stuff is going to raise sjanssen's confidence in uvector.
16:26:21 <pumpkin_> dolio: I don't either :)
16:26:39 <pumpkin_> dolio: although I did make a list of unsafe functions
16:26:46 <pumpkin_> and ways to crash using them
16:27:17 <dolio> Handy.
16:28:01 <dolio> Where's the evil stuff, by the way?
16:28:15 <dolio> I want to see ByteArray# -> Addr# or whatever.
16:28:23 <pumpkin_> Data.Array.Vector.Binary (for lack of a better name for now)
16:28:29 <pumpkin_> I haven't written tests for it yet
16:28:40 <pumpkin_> but it worked in the very basic sense
16:28:40 <pao> I've wrestling with indenting...  can anyone tell me if I can get rid of backslashes here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1538#a1538 ?
16:29:09 <pumpkin_> dolio: it's also my first foray into the MagicHash land, so it might be epicly wrong :P
16:29:24 <dons> what's sjanssen's concern? the use of -fsafe only optionally?
16:29:35 <FunctorSalad_> pao: you can put the commas below the [
16:29:39 <dolio> Something like that.
16:29:40 <pumpkin_> I think the fact that it's off by default
16:29:49 <dolio> The general unsafety of the library, I think.
16:29:55 <sjanssen> dons: total lack of memory safety without massive disclaimers
16:29:56 <Cale> pao: The backslashes are wrong.
16:30:03 <Cale> pao: If you delete them, you should be fine.
16:30:03 <dons> cabal install uvector -fsafe
16:30:06 <pao> Cale: but they work!
16:30:12 <pumpkin_> my list of unsafety is currently in the TODO along with some examples
16:30:15 <Cale> pao: really?
16:30:17 <Cale> hmm
16:30:17 <FunctorSalad_> Cale: they're CPP
16:30:18 <pao> Cale: without it does not!
16:30:21 <sjanssen> dons: that isn't good enough, IMO
16:30:25 <Cale> oh, cpp?
16:30:29 <FunctorSalad_> (I think)
16:30:35 <pumpkin_> sjanssen: would you prefer cabal install uvector -funsafe ?
16:30:37 <dons> it doesn't have total lack, but its also *alpha* and *experimental*. unannounced. don't use it if you dont understand it
16:30:40 <FunctorSalad_> (C preprocessor)
16:30:54 <dons> there are still several design aspects, safety being one of them, that aren't solved
16:30:58 <sjanssen> dons: it should not be possible to write a segfault in Haskell without using the word "unsafe"
16:31:02 <dons> agreed
16:31:05 <pao> Cale: FunctorSalad_ how do I say if CPP is used?
16:31:15 <pumpkin_> sjanssen: so using the word unsafe during cabal install is good? :D
16:31:33 <Philonous> :t -3
16:31:34 <lambdabot> forall a. (Num a) => a
16:31:36 <FunctorSalad_> pao: hmm actually CPP should only be used if you have the -XCPP pragma on :)
16:31:50 <pao> FunctorSalad_: that's not the case
16:31:53 <sjanssen> pumpkin_: I'd prefer safety as the user interface, with unsafe back doors for those cases when the programmer needs them
16:32:00 <Cale> pao: I can't see how that would work...
16:32:01 <jeffwheeler> pumpkin_: fun and safe are!
16:32:11 <Philonous> Why is that not Num a => a -> a ?
16:32:21 <pumpkin_> Philonous: a hack
16:32:26 <FunctorSalad_> pao: then maybe I'm mistaken about \ being part of CPP syntax :( I seemed to remember that I needed to use -XCPP
16:32:27 <Cale> Philonous: It's negative 3?
16:32:34 <Philonous> :t +3
16:32:35 <lambdabot> parse error on input `+'
16:32:40 <Philonous> :t (+3)
16:32:41 <lambdabot> forall a. (Num a) => a -> a
16:32:45 <Philonous> :t (-3)
16:32:46 <lambdabot> forall a. (Num a) => a
16:32:55 <Cale> (-3) is negative 3
16:32:56 <wli> Philonous: You mean instance Num nr => Num (t -> nr)?
16:32:57 <dolio> -3 wouldn't be a section even if - weren't special cased.
16:33:02 <Cale> (+3) is an operator section
16:33:22 <Cale> You can write subtract 3 for that function.
16:33:27 <wli> Philonous: There's nothing to stop you from declaring it.
16:33:31 <Cale> :t subtract
16:33:32 <lambdabot> forall a. (Num a) => a -> a -> a
16:33:43 <jeffwheeler> > subtract 5 2
16:33:44 <lambdabot>   -3
16:33:47 <jeffwheeler> Oh, they're backwards.
16:34:00 <jeffwheeler> "Subtract 5 from 2."
16:34:21 <pumpkin_> dolio: how disgusting is the code? I was groping around in the dark most of the time :)
16:34:29 <idnar> > (-) 5 2
16:34:30 <lambdabot>   3
16:34:38 <jeffwheeler> @src subtract
16:34:38 <lambdabot> subtract x y = y - x
16:34:39 <FunctorSalad_> pao: hmm... my ghc won't accept end-of-line backslashes without -XCPP... maybe you're using some other version
16:34:40 <Philonous> Ok thanks. It's still somewhat ugly
16:34:44 <FunctorSalad_> (6.10.1 here)
16:34:50 <Sekaino> Hey guys, what's the scope of a where clause with respect to a case statement?  I seem to be confusing something.
16:34:56 <dons> dcoutts_: you might want to use http://www.youtube.com/watch?v=Tu0iuHxL3z8 as an example on the cabal-install page of how easy it is to use and distribute code with cabal
16:34:58 <jeffwheeler> > let sub = flip (-) in sub 5 2
16:34:59 <lambdabot>   -3
16:35:03 <bos> Sekaino: that depends on their relative indentation.
16:35:08 <pao> FunctorSalad_: in the source of that specific file I haven't CPP enable
16:35:20 <Sekaino> bos, I want the where to be seen inside the case, but am getting "not in scope" errors.
16:35:22 <wli> instance Num nr => Num (t -> nr) where (f + g) x = f x + g x ; (f - g) x = f x - g x ; (f * g) x = f x * g x ; (negate f) x = negate (f x) ; (abs f) x = abs (f x) ; (signum f) x = signum (f x) ; fromInteger n = const (fromInteger n)
16:35:27 <Sekaino> I've tried several indentations.
16:35:31 <sjanssen> dons: perhaps there could be a disclaimer in the documentation?
16:35:35 <dcoutts> dons: hmm, I guess I should go find a machine with flash installed so I can watch it
16:35:39 <bos> Sekaino: hpaste it
16:35:46 <pao> FunctorSalad_: maybe that is enabled globally in *.cabal?
16:35:50 <FunctorSalad_> pao: just in case you missed my first message, you could just drop the backslashes and align the commas with [ :)
16:35:55 <dons> sjanssen: well, i'm hoping we can ensure the exposed api is safe
16:35:57 <FunctorSalad_> pao: yes, that's possible
16:35:58 <Sekaino> 500 Internal Server Error
16:35:58 <Sekaino> 58030 5: database is locked
16:36:02 <pao> FunctorSalad_: just tried...
16:36:03 <Sekaino> (for hpaste) :)
16:36:04 <pao> no way
16:36:09 <dons> dcoutts: linux man, linux.
16:36:09 <sjanssen> dons: at the top: "This library exposes unsafe features, caveat emptor"
16:36:15 <sjanssen> dons: oh yes, that'd be best
16:36:27 <dons> I'd prefer "This is alpha, experimental software. APIs are likely to change!"
16:36:35 <dcoutts> dons: ok, I should go find a linux machine with flash
16:36:37 <sjanssen> but that isn't enough
16:36:43 <dons> sjanssen: it was never the intent to expose segfaults
16:36:44 <dcoutts> dons: they don't make it for 64bit linux
16:36:49 <dons> dcoutts: i'm using it on 64 bit linux
16:36:50 <sjanssen> dons: API changes aren't as bad as unadvertised segfaults
16:36:56 <dons> yep
16:37:01 <dcoutts> dons: using 32bit libs presumably
16:37:40 <Philonous> wli: This instances declares 2 ( 3+4). That's a little funny.
16:37:41 <idnar> running a 32-bit firefox (or iceweasel, in my case) is a pain, and nspluginwrapper + flash requires a browser restart every third flash applet to get flash working again
16:37:50 <idnar> er, flash animation?
16:37:53 <idnar> whatever you call 'em
16:38:06 <dons> i'm using a 64 bit firefox, with whatever wrapper for shockwave flash arch ships
16:38:17 <Philonous> wli: 2 (3+4) to be 2*
16:38:33 <FunctorSalad_> pao: weird, it should work that way. maybe the error is somewhere else?
16:38:50 <bos> I wonder if it's worth adding support to Data.Text to check whether a stream contains characters only within the BMP. it should be a big performance win, at the cost of some code bloat.
16:39:06 <dons> dcoutts: actually, adobe has released 64 bit flash for linux
16:39:09 <dons> that's what i'm using.
16:39:42 <dons> dcoutts: http://www.archlinux.org/packages/extra/x86_64/flashplugin/
16:39:44 <dolio> pumpkin_: Hey, my memcpyOffset function gets more use. :)
16:39:49 <dons> Last Updated:  2008-12-19
16:39:51 <idnar> oh, yeah, forgot about that; probably because I tried some the Debian packages of that, and it just segfaulted Iceweasel on any Flash animation; didn't ever get around to investigating further
16:39:56 <dons> so fairly recent, dcoutts
16:39:56 <pumpkin_> dolio: yeah, I changed the FFI signature a little to copy from a Ptr
16:40:07 <pao> FunctorSalad_: strange indeed
16:40:13 <pumpkin_> dolio: but it was handy, even though I'd love to not need to copy at all
16:40:18 <dolio> pumpkin_: Yeah. That seems to be standard operating procedure.
16:40:25 <dcoutts> dons: ah yes, just been added to gentoo unstable
16:40:26 <pumpkin_> dolio: maybe I'll make a memcast c function ;)
16:40:38 <pumpkin_> for even more epic unsafeness
16:40:42 <dcoutts> dons: damn, does that mean I loose my excuse for avoiding flash?
16:40:49 <dons> i think so.
16:41:00 <dons> its useful: you can watch my cabal videos
16:41:27 <idnar> oh, there are packages in Debian proper now; let me try that
16:41:32 <glguy> dons, I don't think we should be encouraging people to be putting "pony" on hackage :-p
16:41:53 <sjanssen> dcoutts: your new excuse can be "Even the native x86_64 Flash crashes all the time" :)
16:42:06 <idnar> sjanssen: haha
16:42:11 <pumpkin_> be back in a few
16:42:20 <glguy> the native 64-bit proprietary flash has been rather stable for me
16:42:20 <dcoutts> sjanssen: phew! :-)
16:42:58 <dons> its a cuter helloworld for cabal than 'noop' i think :)
16:43:41 <bos> dcoutts: any objections to tagging and announcing text-0.0.1?
16:43:48 <yitz> dcoutts: don't worry, you still don't have silverlight
16:44:26 <jdkoeck> dons and glguy: Thank you very much, here is the revised code http://pastie.org/397017
16:44:31 <dons> bos, tests pass, api is decent?
16:44:31 <dcoutts> bos: oh, lemme check the API quickly
16:44:41 <FunctorSalad_> hmm does readProcess limit the called process's memory usage? it exits with "out of memory", but I'm not
16:44:43 <dcoutts> dons: yes, hnop is booring
16:44:54 <dons> countOcc is much nicer, jdkoeck
16:44:57 <dcoutts> bos: in the announce, don't promise API stability yet
16:45:01 <FunctorSalad_> (of course, maybe graphviz just limits itself)
16:45:04 <dons> jdkoeck: how's it run?
16:45:18 <glguy> jdkoeck, any improvement?
16:45:41 <jdkoeck> down to 1 sec. now
16:45:56 <dcoutts> bos: do we need to expose so many modules?
16:46:15 <shapr> wheee!
16:46:21 <jdkoeck> Very satisfaying, the code is both terse and efficient
16:47:32 <dcoutts> bos: there's 3 modules that are not used by Data.Text
16:48:04 <jdkoeck> dons and glguy: Well, can't really compare it to OCaml now, it's a different (ans much better) algorithm now.
16:48:25 <dcoutts> bos: docs don't build for me
16:48:26 <dons> should be faster then :)
16:48:37 <dons> if its using better algos and data structures.
16:48:57 <jdkoeck> dons: yes, down from 3 to 1 sec.
16:49:43 <redditbot> Announcing the Bay Area Haskell Users Group
16:50:04 <dons> right, but there's no reason ghc wouldn't beat ocaml if its using better structures and algos. they generate much the same low level code these days
16:50:07 <idnar> woo, it worked
16:51:58 <jdkoeck> dons: my OCaml code is at 0.4 sec, Haskell at 1 sec., but it does not mean much since the algorithms are not the same
16:52:31 <dons> right, still not acceptable in my books
16:52:40 <jdkoeck> dons: Don't worry, I do know ghc is the most advanced compiler on earth !
16:52:45 <dons> at the very least, a direct translation of the ocaml to haskell should yield the same performance
16:53:03 <dolio> Oh, that reminds me: was the last update of stream-fusion just to make it work on 6.10.1?
16:53:13 <dons> dolio: yep, the list lib.
16:53:13 <jdkoeck> dons: I'll try that tomorrow (2 in the morning here in France)
16:53:17 <dons> i'm reimplementing it.
16:53:20 <dolio> Okay.
16:53:23 <jdkoeck> dons: thank you and bye
16:53:31 <dons> jdkoeck: a nice benchmark would be a direct translation of imperative ocaml
16:53:42 <dolio> I dropped it in on a benchmark from comp.lang.functional and to my surprise, it actually ran slower than foldr/build.
16:53:42 <dons> then you'd have something like the "shootout" code: imperative haskell, but fast.
16:53:53 <dons> interesting
16:53:59 <dons> concatMap can be a culprit, or list comps
16:54:04 <dons> since they're not fusible without compiler mods
16:54:19 <dolio> Well, it had something to do with my enumFromTo in terms of unfoldr not being specialized or something.
16:54:29 <dolio> When I changed it to Int -> Int -> [Int] it got optimized better.
16:54:30 <jdkoeck> dons: Looking forward to seeing your improvements :)
16:54:37 <dolio> And matched the foldr/build.
16:54:41 <jdkoeck> Bye everyone !
16:55:03 <dolio> There was nothing in the benchmark that foldr/build couldn't fuse though, so I wasn't thinking it'd be a lot faster.
16:56:30 <dolio> Although fusion from uvector was noticeably faster.
16:57:02 <dons> ah ha
16:57:10 <dons> then that's interesting - prob. a bug in the old list-fusion lib.
16:57:15 <dons> its getting a rewrite from scratch though.
16:57:32 <cognominal> given an IOError, how can I print it?
16:57:48 <dcoutts> bos: this is the weirdest thing, haddock falls over on "-- License     : BSD-style" in Data.Text.Unsafe
16:58:51 <bos> dcoutts: it does? huh.
16:58:53 <pumpkin_> epic snowfall is epic
16:59:17 <dcoutts> bos: it doesn't say so, but if I take that line out it works, with it there it fails
16:59:44 <bos> hmm.
17:00:06 <cognominal> hum, show, apparently
17:00:23 <dcoutts> bos: actually, removing any one of the module header comment lines apart from first and last makes it work
17:01:04 <bos> dcoutts: my mind, she boggles
17:01:28 <dcoutts> bos: ie any of the ones between (but not including) Module..Stability
17:01:38 <dcoutts> bos: anyway, I can build docs for now
17:01:54 <dcoutts> bos: so can we avoid exposing the internal modules in the first release?
17:02:02 <dcoutts> bos: adding is easy, taking things away is hard
17:02:11 <bos> dcoutts: i think that's fair.
17:04:04 <dcoutts> bos: I might hesitate about including lines', it's not in ByteString or Data.List
17:04:37 <bos> dcoutts: i know. but it's very useful.
17:05:17 <dcoutts> bos: oh, that's the universals one. We can expose it later in a different module. lines' isn't a good name for it
17:05:31 <bos> other suggestions welcome :-)
17:06:06 <sjanssen> hmm, how do inline pragmas interact with default class methods?
17:06:18 <dcoutts> bos: so my suggestion is do not expose it initially and we can think about where it's better to put it later
17:07:36 <pumpkin_> what's the difference between forall a. (Constraint a) => a -> ... and (Constraint a) => a -> ... ?
17:07:43 <pumpkin_> I didn't think there would be one
17:08:30 <dons> sjanssen: interestingly
17:08:34 <sjanssen> pumpkin_: the forall will put a type variable in scope when that extension is turned on
17:08:35 <dons> sjanssen: its documented though.
17:08:45 <dons> sjanssen: the class method defaults can be inlined.
17:08:50 <sjanssen> dons: interestingly ... Either Yes No -- :)
17:08:57 <pumpkin_> sjanssen: aha, that's exactly the change I noticed :) seemed like strange behavior, but it's good to know that it's expected :P
17:09:14 <sjanssen> dons: ah, good
17:09:22 * sjanssen is looking at uvector
17:09:26 <dons> sjanssen: you can inline them. check the INLINE pragma manual (i believe that's where it was listed)
17:09:38 <bos> when does GHC's simplifier eliminate asserts?
17:09:40 <pumpkin_> epic scrutiny
17:10:35 <pumpkin_> sjanssen: what part of it?
17:11:11 <sjanssen> pumpkin_: I want to make indexU and readMU check bounds
17:11:18 <pumpkin_> indexU already does
17:11:21 <pumpkin_> I thought
17:12:12 <pumpkin_>     check (here "indexBU[Bool]") n i $
17:12:44 <chrisdone> could you use NoImplicitPrelude to redefine the IO monad?
17:12:46 <sjanssen> pumpkin_: ah, perhaps it does
17:12:59 <pumpkin_> but readMU definitely doesn't, and nor does writeMU
17:13:10 <sjanssen> so what part of uvector was I bumping into that doesn't?
17:13:19 <pumpkin_> what was your example?
17:13:25 <sjanssen> ah, the mutable stuff (which is even worse for memory safety)
17:13:31 <pumpkin_> yeah
17:13:45 <pumpkin_> those two already check bounds too btw
17:13:53 <pao> how do I setup the sender email address for darcs send? I'm on mac... --from doesn't work... I bounced by haskell.org mailserver
17:13:56 <sjanssen> something like forM_ [0, -1 ..] $ \i -> writeMU a i i
17:14:03 <pumpkin_> sjanssen: but the bounds checking on those is only on with -fsafe :)
17:14:11 <sjanssen> bah
17:14:27 <pumpkin_> you can go into the Debug.hs and make debugCritical = True unconditionally
17:14:37 <pumpkin_> currently it's conditional on the safe flag
17:14:49 <sjanssen> pumpkin_: I assume this will degrade performance
17:15:08 <pumpkin_> it'd be interesting to have a benchmark suite to see how much it affects it though
17:15:24 <sjanssen> what we really want is for internal (ie. trusted, probably correct) users to avoid bound checks while providing a nice interface to the outside world
17:16:07 <pumpkin_> the interface could be split into Data.Array.Vector and Data.Array.Vector.Unsafe, with almost exactly the same ops in each, but no bounds checking in the latter
17:18:42 <pumpkin_> but I dunno :) it's not my library :P
17:21:48 <jgrimes> in gtk2hs, how do you get a pixmap from an X11 XID? in python you use "pixmap_foreign_new_for_display", but I can't figure out the equivalent in gtk2hs
17:22:14 <dcoutts> jgrimes: you may need to bind another function
17:22:48 <jgrimes> dcoutts, ah, ok.
17:23:21 <dcoutts> jgrimes: whatever the python one binds it'll be the same in the haskell version, but it's probably missing. It's not hard to add though if you feel like sending patches to the mailing list.
17:24:32 <jgrimes> dcoutts, if I can figure it out I'll send the patch
17:24:49 <dcoutts> jgrimes: if you need help, ask on the mailing list
17:25:08 <jgrimes> dcoutts, will do
17:29:30 <pumpkin_>  shhh... i'm hunting bunny wabbits.
17:32:35 <sw17ch> mapM_ shoot wabbits
17:32:39 <dons> hehe
17:32:52 <sw17ch> see, that's the version where you hunt for sport
17:33:00 <sw17ch> mapM shoot wabbits -- if you need the meat
17:33:11 <pumpkin_> lol
17:33:36 <edwardk> but before to only take whatYouNeed
17:34:03 <edwardk> of course by then since you used mapM the rabbits won't care, so maybe you'd better do something with all of them
17:35:57 <blackh> dons: I just submitted a parallel version of binary-trees - just adding a parallel strategy... but according to the wiki you submitted the same thing last year - only - there's no trace of it on the shootout!
17:36:36 <dons> blackh: ah ha.
17:36:38 <dons> you know why?
17:36:50 <dons> it is there: it just runs no faster, due the the GC bottleneck
17:36:57 <dons> you have to disable GC ( which is illegal )
17:37:01 <dons> or maybe use the parallel GC
17:37:06 <dons> i'm half way through a blog post on the topic
17:37:15 <dons> with the GC out of the way we have the fastest entry , fwiw
17:37:26 <blackh> dons: No idea. On my machine it definitely runs faster.  Well, let me know if you want me to tell shootout to cancel my submission. It's exactly the same as your old one.
17:37:31 <pumpkin_> are they running 6.10 on the shootout?
17:37:38 <dons> the parMap version is on the wiki
17:37:39 <blackh> Yes, they are.
17:37:51 <dons> blackh: well, how do you deal with GC ?
17:38:00 <dons> what does -sstderr say the time spent in GC is?
17:38:04 <dons> or do you try to use the parallel gc?
17:38:30 <blackh> dons: I don't - I'm using 6.10.1 and it runs in less time overall. I have two cores. I have measured it a number of times with different tree sizes.
17:38:54 <blackh> I didn't use parallel gc.
17:39:01 <blackh> Let me double check that what I did was the same.
17:39:42 <dons> i think it becomes worse on 4 cores
17:39:52 <dons> as the GC becomes the primary bottleneck
17:39:58 <dons> i think it wrote about it on the wiki?
17:40:11 <blackh> Not exactly the same.  Yours says "let vs = (parMap rnf) (depth' maxN) [minN,minN+2..maxN]".  Mine says "parMap rnf id $ depth minN maxN"
17:40:47 <dons> did you modify depth?
17:40:48 <blackh> dons: I read the wiki too late!
17:41:10 <dons> anyway, with the GC off you get perfect speedup here.
17:41:14 <blackh> dons: No - the only modification was the "parMap rnf id $" then I measured it a few times and it was consistently better. I'll compare yours against mine now.
17:41:17 <dons> but then the GC kicks in to collect all those tree nodes
17:41:29 <dons> yes. you may have stumbled on something
17:41:38 <dons> and still -- i've not tried with ghc 6.10 or the parrallle GC
17:41:41 <blackh> dons: I was trying to parallelize "check" only
17:41:42 <dons> so things may be quite different
17:41:47 <dons> `par` got cheaper, for example
17:41:55 <blackh> dons: That might by why mine works. I'll just verify this.
17:42:48 <dons> yes, you might well be on to sometihng.
17:42:57 <dons> hopefully i included the preferred flags on the wiki?
17:43:01 <dons> so you can also try the no-GC version
17:43:22 <dons> its frustrating, since this one we can knock out of the park.
17:43:28 <dons> just needs fast sparks, good parallel GC , etc...
17:43:57 <blackh> dons: unrolling 'check' makes it significantly faster too but that's not allowed
17:46:22 <sw17ch> am i correct in thinking GHC does no unrolling whatsoever?
17:46:43 <blackh> dons: My one is much faster than your one off the wiki.  Yours hasn't even finished yet.
17:47:35 <blackh> dons: Here's mine: http://alioth.debian.org/tracker/download.php/30402/411646/311499/3080/binary-trees.hs
17:47:45 <pumpkin_> sw17ch: I think so, you might be able to do -via-C and ask gcc to unroll though
17:48:11 <blackh> dons: Speed on two cores: real	0m42.648s / user	0m47.111s
17:49:20 <pumpkin_> blackh: not much parallelism though? how's the one that's currently on the shootout page?
17:50:13 <blackh> pumpkin_: My one adds only "parMap rnf id $" to the current entry. There definitely isn't much parallelism, but allocation heavy code parallelizes badly on ghc at this point in time.
17:50:25 <pumpkin_> ah
17:50:31 <blackh> pumpkin_: The current entry doesn't parallelize at all
17:50:47 <pumpkin_> hey, one of the CPUs has 1% utilization! ;)
17:50:53 <pumpkin_> 0% 1% 100% 0%
17:50:54 <pumpkin_> :P
17:52:39 <BMeph> Just idle curiosity, but has anyone fixed/changed the shootout script for regex-dna, so that it uses the right package?
17:53:38 <blackh> BMeph: Yes, I have.
17:53:57 <blackh> BMeph: Or rather, I gave instructions on how to do it, along with speeding the benchmark up.
17:54:21 <blackh> BMeph: http://alioth.debian.org/tracker/index.php?func=detail&aid=311443&group_id=30402&atid=411646
17:56:04 <dons> BMeph: regex-pcre ?
17:56:13 <dons> we just have to ask nicely for regex-pcre to be installed via cabal-install
18:04:29 <rovar> what is the recommended way to throw away the result of a function in a do block?
18:05:20 <pumpkin_> return () ?
18:05:25 <pumpkin_> or wait
18:05:37 <pumpkin_> just call the function without saving its result?
18:05:46 <rovar> in a ReaderT, I'm calling:  bdb <- asks db   to retrieve a BerkeleyDB instance, then I call DB.insert (key) (value) bdb
18:05:51 <rovar> in a do block.
18:06:38 <rovar> one method I've found is   > let bdb' = DB.insert (key) (value) bdb
18:07:13 <rovar> so that the line doesn't return a value
18:07:25 <rovar> but that's rather misleading, cause I don't care about bdb'
18:09:07 <blackh> rovar: That does nothing. Maybe you want > DB.insert (key) (value) bdb >> return ()
18:09:45 <blackh> rovar: That is, "let bdb' = DB.insert (key) (value) bdb" will not perform the insert
18:10:08 <rovar> blackh good idea... yea.. because since i don't use bdb', it won't bother defining it
18:10:37 <blackh> rovar: The problem is really that you're never telling the IO monad to execute the insert
18:11:44 <rovar> but >> return() will?
18:12:16 <gilbert> hi
18:12:20 <Botje> yes
18:12:21 <gilbert> i'm a haskell noob
18:12:32 <gilbert> having some trouble with pattern matching
18:12:40 <blackh> rovar: "DB.insert (key) (value) bdb >> return ()" is equivalent to two lines "DB.insert (key) (value) bdb ; return ()"
18:13:01 <blackh> rovar: i.e. a newline is syntactic sugar for >>, and >> will eat your return value
18:13:21 <gilbert> what is wrong with this simple func?
18:13:22 <gilbert> myIntersperse (x:xs) delim = x ++ delim ++ (myIntersperse xs delim)
18:13:33 <gilbert> i want it to take in a list of strings and a string delimiter
18:13:42 <rovar> blackh: but just doing a newline made it complain about non matching types
18:14:00 <blackh> rovar: return () on the second line should fix that
18:14:24 <Draconx|Laptop> gilbert, you have no base case for your recursion.
18:14:26 <blackh> rovar: "return ()" means "do nothing and give a return value of ()"
18:14:34 <pumpkin_> is there a logical difference between Chunk "" Empty and Empty in a lazy ByteString?
18:14:50 <gilbert> Draconx|Laptop: myIntersperse [] delim = ""
18:15:00 <gilbert> but ghc complains that
18:15:37 <gilbert> it can't match the expected type [[[Char]]]
18:16:01 <Botje> gilbert: you want x:delim ++ myInterspers xs delim
18:16:05 <rovar> gotcha
18:16:08 <Botje> or [x] ++ delim
18:16:12 <Draconx|Laptop> gilbert, your function works fine here, although with slightly different behaviour than Data.Lists's
18:16:22 <BMeph> gilbert: Yes, that's another problem with your code: ":" /= "++" (short version)
18:16:34 <gilbert> hmm....let me restart my ghci...
18:16:40 <Draconx|Laptop> BMeph, it takes a list of lists.
18:17:36 <gilbert> weird...
18:17:45 <gilbert> it works now
18:17:55 <gilbert> the only difference b/t my ghci before and after is that
18:17:59 <Draconx|Laptop> > let myIntersperse (x:xs) delim = x ++ delim ++ myIntersperse xs delim; myIntersperse [] _ = "" in myIntersperse ["foo","bar"] ";"
18:18:02 <gilbert> before, i had loaded the List module
18:18:03 <lambdabot>   "foo;bar;"
18:18:04 <rovar> blackh:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1539#a1539
18:18:11 <rovar> still getting that error when using >>
18:18:49 <BMeph> Draconx|Laptop: Yes, you are right. Never mind.
18:19:18 <gilbert> anyhow, thx alot everyone
18:19:46 <blackh> rovar: The monad that DB.insert expects to run in is a different type to the one you're giving it.
18:19:56 <rovar> right
18:20:08 <gilbert> Draconx|Laptop, Botje thx
18:20:24 <Botje> what's the type for db.insert?
18:20:32 <blackh> rovar: Which Berkeley DB library is this? It's not my one. :)
18:20:42 <blackh> rovar: My one works. :)
18:21:15 <rovar> blackh: I like the Data.Map interface
18:21:22 <rovar> i guess I don't need to use this one
18:21:49 <rovar> this is http://hackage.haskell.org/packages/archive/berkeleydb/2008.10.31/doc/html/Data-BerkeleyDB.html
18:21:55 <blackh> rovar: OK - I understand it now.
18:22:05 <BMeph> gilbert: Okay, this part is true: List is made to conform to H98 standards, while Data.List gets  more in it.
18:22:17 <Draconx|Laptop> gilbert, however, I would write the function as follows: myIntersperse xs delim = concatMap (++ delim) xs
18:22:21 <blackh> rovar: That library is pure - it doesn't run in a monad...
18:22:46 <rovar> i know
18:23:15 <rovar> that's where my confusion spawns.. I should be able to execute this pure funtion in my do block, yes?
18:23:16 <blackh> rovar: So I was assuming it wasn't and put you wrong before.
18:23:22 <rovar> ah
18:23:46 <blackh> rovar: Yes - "let bdb' = DB.insert (key) (value) bdb" as you had before is correct.
18:23:55 <blackh> rovar: However, you can't just throw bdb' away - because that's your new database.
18:23:59 <gilbert> Draconx|Laptop: cool, didn't know concatMap exists
18:24:10 <rovar> blackh, but.. but..
18:24:19 <BMeph> Draconx|Laptop: But that will put an extra delimiter on the end.
18:24:23 <rovar> the old handle to the db should still be valid, yes/
18:24:23 <blackh> rovar: My library (BerkeleyDB) is much more dumbed down - it just runs in the IO monad.
18:24:40 <rovar> yea, I've used that too :)
18:24:40 <Botje> there's lot of scary unsafeEatBabies magic in there :(
18:24:45 <Draconx|Laptop> BMeph, which is what the function as defined did.
18:24:53 <blackh> rovar: If it's pretending to be pure, then it's creating a "new" database. I don't know how it's supposed to work!
18:25:07 <blackh> rovar: There could be babies being eaten, definitely.
18:25:23 <Botje> i think you're supposed to use it like an immutable datastructure
18:25:30 <rovar> blackh:  Lemmih wrote it, so I trust that it doesn't suck..
18:25:54 <rovar> I was hoping to ignore the returned DB values so that I could put the instance in my reader monad
18:26:19 <blackh> rovar: Well, since it behaves like Data.Map, you should use the new reference, and throw the old one away. I don't know how far Lemmih went in preserving the illusion of purity.
18:26:22 <rovar> hence the bdb <- asks db
18:26:30 <rovar> gotcha.
18:27:04 <BMeph> Draconx|Laptop: Fair enough. I've already had the "pleasure" of someone who _insisted_ that is should be "obvious" what his function did, when it was only somewhat suggested by the name what he _wanted_ it to do.
18:28:09 <rovar> i guess I'll put the db instance back into the StateT,  though it is so much cleaner in the readerT
18:29:22 <blackh> rovar: You can't do the ReaderT thing, because that violates referential transparency. Things don't work when you do that.
18:29:48 <blackh> rovar: You can just go 'modify $ DB.insert (key) (value)'
18:30:54 <rovar> blackh, in the StateT, not ReaderT correct?
18:32:25 <blackh> rovar: Yes - that modify thing I suggested is for a State or StateT and it should be quite tidy.
18:34:37 <rovar> blackh: I've got other stuff managed by StateT, so it won't be that neat
18:35:24 <senxhnsshp> http://confusion.tweakblogs.net/blog/1418/why-functional-programming-doesnt-catch-on.html
18:35:55 <senxhnsshp> ^^ someone hack together a mp3-player in X-windows that trakcs the user listening habits with sqlite k thnx
18:36:27 <pumpkin_> is there a rewrite rule for encode . decode?
18:36:40 <rovar> senxhnsshp: amarok not good enough for you?
18:37:22 <NotMe> nothing is every good enough for anyone, ever
18:39:51 <pumpkin_> I like: http://squing.blogspot.com/2008/11/beautiful-folding.html
18:40:58 <pilkarn> is amarok written in Haskell?
18:41:13 <BMeph> That's funny: a couple of weeks after someone makes a "package" that gives funtional-style programming stuff to php, and then links a blog with that title. Yeah, great... ;p
18:41:51 <bremner> pilkarn: don't think so.
18:44:06 <pilkarn> so why did rovar say what he said? is it written ina functional language?
18:44:25 <pilkarn> or he didnt read the link i posted and
18:45:32 <rovar> pilkarn: eh?
18:45:34 <pumpkin_> hmm, my quickcheck tests are passing in ghci
18:45:37 <pumpkin_> but not in ghc
18:47:30 <pumpkin_> any ideas?
18:51:42 <pumpkin_> (fromU . decode . encode $ toU xs) == xs is my property
18:52:16 <pumpkin_> it works just fine in ghci, but fails immediately in ghc, with []
18:52:16 <bos> pumpkin_: fusion rules firing?
18:52:21 <pumpkin_> that's what I'm thinking
18:52:29 <pumpkin_> but I'm not sure why it would magically fail
18:52:32 <bos> pumpkin_: you have to explicitly disable the rewrite rules
18:52:45 <bos> {-# OPTIONS_GHC -fno-enable-rewrite-rules #-}
18:52:45 <pumpkin_> shouldn't the rewrite rules not affect correctness though?
18:52:50 <dons> what's the name for people who impulsively rant when math and programming are combined?
18:52:51 <pumpkin_> mmkay, I'll give that a go
18:52:56 <bos> they'll definitely affect correctness
18:53:15 <dons> who shout and whimper at the idea there could be formal foundations to the business of programming.
18:53:17 <bremner> dons: insecure?
18:53:24 <bos> PHP hackers?
18:53:32 <pumpkin_> bos: still fails, hmm
18:53:45 <bos> pumpkin_: hm
18:53:52 <dons> its just a horrible, bizarre fear of learning or someting. insecurity? job insecurity... ?
18:54:13 <pumpkin_> those people puzzle me too
18:54:15 <ozy`> dons: people absolutely hate to relearn what they think they already understand.
18:54:21 <dons> mmm
18:54:39 <pumpkin_> what's sad is that the safe interface is the one  failing for me
18:54:41 <dons> "hey, i'm a programmer. i have a job as a programmer. i never heard of monoids. wtf?! you're a stupid head"
18:54:43 <pumpkin_> and the unsafe one passes all the tests
18:54:54 <rovar> dons, it's simply a matter of irrelevance.
18:54:59 <pumpkin_> not at all
18:55:09 <pumpkin_> they're quite relevant concepts
18:55:24 <rovar> there are some who are naturally curious about all things programming, there are others who are only concerned about what is relevant to their job as a java programmer
18:55:25 <dons> well, they don't see it as relevant, but that's not enough -- they actively disparage such things.
18:55:38 <lament> <dons> what's the name for people who impulsively rant when math and programming are combined? <-- computer engineers
18:55:42 <dons> so rather than just ignoring, its like they have to justify why they're ignoring them
18:55:56 <dons> ah well.
18:56:04 <pumpkin_> it's sad
18:56:29 <pumpkin_> people who don't want to learn in general make me sad, but in fields that I care about it's worse
18:56:42 <rovar> i don't see much actively disparaging, when I tell people I'm learning Haskell, their response is usually "oh, that language we took back in college?"
18:57:06 <rovar> but honestly, there wasn't much in that 1 required college course that was relevant to rapid application development
18:57:26 <Nafai> A coworker explained Monads to another coworker.  I wasn't there so I don't know the effectiveness of the explanation.
18:57:38 <Nafai> But the one that had it explained to him feels like they are useless
18:57:38 <rovar> their could have been.. if such a book as Real World Haskell existed... but instead, we wrote a parser for a useless language
18:57:40 <dons> you learn rapid application development at university now?
18:57:41 <pumpkin_> I don't even bother trying to explain them to people :P
18:57:53 <dons> ah, so you learned how to write a compiler (or part of it)
18:57:54 <SamB> Nafai: they are
18:57:55 <SamB> like id
18:58:00 <dons> so now you know more about how we get from src to hardware
18:58:03 <pilkarn> rover: eh what?
18:58:20 <ozy`> rovar: in RWH you write a parser for a useless language
18:58:29 <dons> json? :)
18:58:47 <rovar> ozy`: in addition, you do a lot of useful things, and the parser you write is only useless because a better one exists in hackage :)
18:59:03 <pumpkin_> ozy`: not sure I'd call json useless :P
18:59:06 <rovar> i've actually had to write a json parser for work
18:59:14 <rovar> wish I could have done it in haskell
18:59:16 <ozy`> dons, pumpkin_: I haven't read that chapter :p
18:59:18 <pilkarn> rover: is amarok written in haskell ro some functional language?
18:59:26 <pumpkin_> ozy`: so what's the useless language you're referring to?
18:59:30 <Axman6> ozy`: i gave up on it
18:59:33 <bos> IsString and ghci don't mix well
18:59:48 <pilkarn> the article requested a practical example of an something that uses guis, databases, state et
18:59:49 <pilkarn> c
18:59:55 <Axman6> dons: i was playing with your Data.Binary stuff last night, it's quite fun :)
19:00:01 <ozy`> pumpkin_: the image thing earlier on
19:00:09 <pumpkin_> ah, don't remember that
19:00:11 <Nafai> dons: It's been mentioned, but I think part of the problem is this.  People who are programmers look at what they are doing.  Then they hear of how those who bring theory (particularly maths) into the realm of programming.  This does not look like what they do for their job and thus can't be useful.
19:00:14 <pumpkin_> I've only leafed through it a bit
19:00:20 <Axman6> ozy`: skipped that too :P
19:00:26 <rovar> pilkarn: no, was that a requirement of senxhssnp or whatever his name was
19:00:44 <SamB> rovar: oh, the pnm parser?
19:00:49 <pumpkin_> bos: so fromU . decode . encode . toU would fuse away completely, you think? that should just leave id x == x
19:00:51 <SamB> (whichever variant of pnm)
19:00:56 <pumpkin_> so I'm stil not sure why that would fail
19:01:00 <SamB> rovar: not sure how that's useless ;-P
19:01:00 <Axman6> i need to do more RWH, but i don't have the time now i'm back at uni. seems i'll be doing 4 languages this semester: Java, Matlab, C and ASM
19:01:11 <pumpkin_> matlab ftl
19:01:20 <lament> java, c and asm ftl
19:01:24 <Axman6> hoping it's better than mathematica :\
19:01:26 <pumpkin_> not as bad as matlab
19:01:31 <lament> ouch
19:01:39 <Axman6> pumpkin_: used mathematica?
19:01:42 <pumpkin_> Axman6: nope
19:01:53 <Axman6> seriously has the worse syntax of any language i've ever seen
19:01:54 <pumpkin_> matlab can be concise if you're doing lots of work with vectors
19:01:56 <pilkarn> rovar: yeah thats me
19:02:02 <pumpkin_> other than that, it's rather ugly
19:02:03 <SamB> Axman6: you'll see worse
19:02:03 <Axman6> makes me appreciate things like C ad Java
19:02:09 <lament> Axman6: matlab IS quite bad
19:02:09 <SamB> I think
19:02:22 <SamB> mathematica just has a lousy library ;-P
19:02:28 <Axman6> need to use matlab for my engineering systems analysis course
19:02:38 <pilkarn> Axman6: what do you study?
19:02:48 <Nafai> I used matlab (well, octave, really) for a math analysis course
19:02:50 <Axman6> SamB: they tried to add functional programming to it... it didn't work very well
19:02:56 <Axman6> pilkarn: egineering/IT
19:03:09 <rovar> pilkarn: ahh. well i didn't see that "written in a functional language" was one of your requirements
19:03:16 <SamB> Axman6: well, isn't that becausee of the aforesaid bad library ?
19:03:41 <pumpkin_> bah :(
19:03:41 <Axman6> SamB: well, the syntax is just plain ugly
19:03:52 <SamB> well, yes
19:03:53 <pumpkin_> this makes no sense!
19:03:57 <SamB> but matlab is worse
19:03:57 <ozy`> Axman6: are you including COBOL in languages you've seen?
19:04:08 <SamB> (the semantics are ugly, too!)
19:04:08 <Axman6> ozy`: haven't seen it
19:04:20 <Axman6> SamB: lame >_<
19:05:09 <senxhnsshp> X-windows is for haskell what Swing is for Java right?
19:05:20 <pumpkin_> not sure I'd say that
19:05:20 <Axman6> :\
19:05:24 <SamB> no
19:05:25 <Axman6> me either
19:05:26 <SamB> not a bit
19:05:30 <Axman6> Gtk2hs maybe
19:05:35 <SamB> X is for Haskell what X is for Java
19:05:37 <Gracenotes> haskell doesn't quite have a homebrew GUI library
19:05:40 <BMeph> Almost the inverse, really.
19:05:41 <Axman6> don't kow enough about Swing though
19:05:49 <SamB> and it's not called X-windows
19:05:56 <Pseudonym> Indeed.
19:06:01 <Gracenotes> Forsooth.
19:06:06 <Pseudonym> If you type "man X", they're very insistent on this.
19:06:16 <SamB> (except there are actually reasonable X bindings for Haskell ;-P)
19:06:27 <bremner> Swing is like GTK, or QT, except worse
19:06:47 <SamB> and, if you can believe this, more bloated
19:06:48 <Gracenotes> Swing isn't terrible to work with.
19:06:53 <Axman6> i think java cops more flak than it deserves personally. it could be a lot worse
19:07:00 <Pseudonym> That's a bit unfair.  Swing is SO different to GTK or Qt there's little comparison.
19:07:16 <bremner> Swing is a user interface toolkit
19:07:18 <Nafai> Yeah, Swing doesn't compare
19:07:24 <Axman6> heh
19:07:27 <SamB> it doesn't ?
19:07:30 <pumpkin_> prop_encDec xs = (fromU . decode . encode . toU $ xs) == xs works in ghci, but fails in the full ghc-compiled testsuite (quickcheck)... any ideas?
19:07:38 <Gracenotes> SamB: it doesn't swing that way
19:07:43 <Nafai> It's an odd mashup of low-level and high-level stuff
19:07:49 <senxhnsshp> swing is neater than anythign else ive tried for making guis
19:07:50 <SamB> what is GTK, then, chopped liver?
19:08:00 <ozy`> senxhnsshp: X11 ("X-windows") is the general purpose low-level graphics system for almost all unix systems. on linux, all windows are displayed by X, regardless of the toolkit
19:08:13 <pumpkin_> ...including swing
19:08:16 <Axman6> pumpkin_: encode and decode are Data.Binary?
19:08:17 <bremner> ok, ok, swing might not suck so badly, but until java apps work in xmonad, I reserve the right to hate everything java-gui-like
19:08:24 <pumpkin_> Axman6: yeah, instances I wrote myself though
19:08:26 <SamB> ozy`: unless you use qtopia!
19:08:33 <pumpkin_> Axman6: but they do the right thing, in ghci at least
19:08:39 <Axman6> heh
19:08:48 <ddarius> Axman6: It's not that Java could be worse, it's that it could've been so much better.
19:08:54 <senxhnsshp> ah i didnt know
19:08:59 <Gracenotes> awwww.
19:09:01 <Axman6> ddarius: how so?
19:09:07 <ozy`> SamB: "It's Linux, Jim, but not as we know it." <- my opinion of qtopia :p
19:09:20 <Nafai> I did swing component development at my last job
19:09:23 <Nafai> It wasn't that fun
19:09:23 <Axman6> i rarely hear any actual criticisim of java, other than yuck java, java sucks
19:09:49 <pumpkin_> being forced to make classes where no classes belong irks me
19:09:55 <SamB> I've never actually used qtopia myself, but I do know that it uses the framebuffer, not X
19:09:59 <blackh> Axman6: I like Java a lot (but Haskell is better!)
19:10:03 <pumpkin_> I shouldn't have to make a class with a single static method for main
19:10:12 <Axman6> g'day blackh :)
19:10:25 <ddarius> Axman6: There was no reason for it to omit generics or first-class functions.  The know-how for the JVM came from the Self team.  Self was way more advanced than Java (though I'm not saying Java should have pushed that instead).
19:10:28 <Axman6> i woudn't say i like java, but that's because it's mainly used for things i'm not interested in
19:10:32 <blackh> Gidday!  (<-- Everyone take note the NZ vs. Australian spelling difference!)
19:10:42 <Pseudonym> Eh, bro!
19:10:43 <ddarius> Axman6: C#, especially now, is quite a bit a "better Java"
19:10:45 <Nafai> Axman6: Start with a type system that really isn't helpful (in comparison to Haskell's).  Too many holes and potentials for runtime errors
19:10:49 * Pseudonym can speak New Ziland
19:10:54 <Axman6> ddarius: yeah i've heard that a lot about C#
19:10:54 <SamB> pumpkin: well, give thanks, for Jython is (er ... was?) here
19:11:13 <Nafai> SamB: Is.  It's in very active development again for the last year or so.
19:11:20 <bremner> SamB: or Clojure if want
19:11:30 <SamB> Nafai: what Python version are they at now ?
19:11:33 <Axman6> Pseudonym: it's nuh zulund
19:11:43 <Nafai> I think Clojure would be JVM language of choice these days
19:11:44 <blackh> Pseudonym: If you can speak New Ziland, eh - do you want to join my NZ ICFP programming contest team?
19:11:51 <Nafai> SamB: They are in beta of a version that is up to 2.5
19:11:56 <SamB> cool
19:12:16 <SamB> nice to hear that they've come back after having been left at 2.1 for so long ...
19:12:26 <Pseudonym> Nah, bro. We Aussies would never knowingly allow a team from New Zealand to do well.
19:12:32 <Axman6> does anyone else get pleasure from the fact that jruby is faster than standard ruby?
19:12:45 <rovar> scala is a nice language on the jvm, and does well in benchmarks too
19:12:50 <pumpkin_> I don't see why it wouldn't be faster
19:12:51 <Axman6> Pseudonym: :)
19:13:00 <rovar> scala is faster than java in some cases
19:13:04 <Pseudonym> http://www.youtube.com/watch?v=mo7-Q95OwDo <- Obligatory reference.
19:13:15 <Axman6> the jvm is pretty awesome really
19:13:20 <blackh> Pseudonym: Ooooh no ! I'm beached as!
19:13:24 <Axman6> hotspot is really cool
19:13:38 <pumpkin_> soooo about my test failure
19:13:38 <Axman6> blackh: got a bucket or a hose bro?
19:13:40 <pumpkin_> anyone have any ideas?
19:13:42 <Nafai> rovar: scala seems too complex to me.  Just a mish-mash of features
19:13:48 <Axman6> pumpkin_: check the core!
19:13:49 <Axman6> >_>
19:13:53 <Axman6> </dons>
19:13:58 <senxhnsshp> i like Java because it makes things i hate easy, like guis
19:13:59 <pumpkin_> maybe I will :P
19:14:11 <senxhnsshp> then i can hack in clojrue for the fun stuff
19:14:12 <pumpkin_> senxhnsshp: there are things that make them even easier then
19:14:28 <Axman6> oo, rain coming
19:14:32 <SamB> senxhnsshp: why can't you use clojure for the whole thing ?
19:14:42 <senxhnsshp> i have tried python+tcl, python+gtk2ks or whatever it is called, and id say no.
19:14:44 <Axman6> and i'm not in it, and my girlfriend just bought me an umbrella :(
19:14:56 <SamB> senxhnsshp: it's called tkinter, I think, and it is horrible
19:15:02 <SamB> but not because it looks "ugly"
19:15:07 <Nafai> senxhnsshp: You find swing easier than gtk?
19:15:08 <rovar> Nafai: yea, it's like a refined ruby :)
19:15:15 <SamB> (which is what people are always telling me about Tk ;-)
19:15:17 <Gracenotes> eek, tkinter in GNOME
19:15:22 <Axman6> SamB: reminds me of sphincter (sp?)
19:15:23 <Gracenotes> *vomits*
19:15:34 <rovar> Coacoa/Obj-c makes guis pretty damn easy :)
19:15:35 <Nafai> senxhnsshp: I'm the other way around, and I've done a ton more swing :)
19:15:36 <SamB> but because of the way it interfaces Python with TCL
19:15:39 <SamB> (Eww!)
19:15:45 <Axman6> cocoa confuses me :(
19:15:51 <Axman6> not sure why. should give it another go
19:15:54 <Gracenotes> I have cocoa in my closet
19:15:54 <senxhnsshp> samb: i guess i could write bdinings to other guis, but yeah i use clojrue for the whole thing. but the gui-stuff is basically just wrpaping java-code in clojure calls, shorter but still java-ish
19:15:56 <ozy`> I'm still trying to wrap my head around the cocoa event model
19:15:56 <rovar> it's very different
19:16:00 <SamB> I'll admit it doesn't fit in too well with gnome -- it fit in better on Windows 95, I guess ;-P
19:16:10 <Axman6> i was going to try and learn it these holidays, but haskell called
19:16:13 <senxhnsshp> tes tkinter
19:16:15 <SamB> senxhnsshp: clojure can't use java libs directly ?
19:16:23 <Axman6> and i ended up on planet haskell, so i'm not too unhappy :)
19:16:31 <ozy`> apple's more recent documentation has extremely helpful diagrams of event messages getting passed around between applications, so cocoa is making more sense
19:18:14 <Axman6> i think the OOP stuff in cocoa confuses me a lot more than it does in java
19:19:11 <Nafai> Is it Cocoa or ObjC that confuses you?
19:19:48 <angerman> if anyone has a pointer for some example code using the com lib to create a COM server with haskell?
19:19:49 <ozy`> Axman6: objective-C has a lot of syntactic noise, which doesn't help. but, have you seen F-script?
19:19:50 <senxhnsshp> samb: yes i dont wrap them then i use them directly
19:19:57 <Nafai> (I never made it that far in learning ObjC/Cocoa myself)
19:20:18 <Axman6> ozy`: i havem it seems really cool
19:20:21 <senxhnsshp> (let [pane (JPanel.))]
19:20:24 <Axman6> s/m/,
19:20:41 <senxhnsshp> but it still java libs that make it easy to do guis
19:20:43 <angerman> ozy`: isn't that a personal preference? There are people who like VB ;-)
19:21:07 <Axman6> VB6 was ok. but .Net ruined it
19:21:14 <ozy`> angerman: I'm not saying it's ugly... I'm saying the signal-to-noise ratio isn't terribly helpful for learning it ;)
19:21:20 <Nafai> senxhnsshp: What libs?
19:21:30 <Axman6> the thing that finally made me hate VB was Something.VBColor.Black
19:21:49 <angerman> ozy`: :)
19:21:57 <angerman> Axman6: lol...
19:22:07 <angerman> Axman6: well I can't stand that Dim X as Y ...
19:22:10 <SamB> wow. that's the strangest emacs binding I've seen in a while ...
19:22:11 <Axman6> yeah
19:22:19 <pumpkin_> bah
19:22:24 <pumpkin_> epic fail
19:22:25 <SamB> C-c <f8> c (translated from C-c M-[ 1 9 ~ c) runs the command (lambda (arg) (interactive "P") (when arg (compile-bm-res\
19:22:25 <SamB> tore "/home/naesten/hacking/haskell/lhc/" "cabal install -p")) (let ((compilation-directory "/home/naesten/hacking/hask\
19:22:25 <SamB> ell/lhc/") (compile-command "cabal install -p")) (recompile)))
19:22:25 <angerman> SamB: ?
19:22:57 <angerman> Axman6: I don't like C# either, that's why I'm trying to figure out how to write COM server in Haskell :)
19:23:14 <Axman6> :)
19:23:15 <SamB> angerman: I think all the COM stuff for haskell is quite bitrotted
19:23:20 <SamB> I could be wrong though
19:23:40 <pumpkin_> I thought sigbjorn finne (sp?) had just submitted some brand new stuff for it
19:23:53 * SamB wanted to write XPCOM client code in hakell
19:23:57 <SamB> pumpkin: really ?
19:24:02 <SamB> cool
19:24:14 <pumpkin_> I may be wrong
19:24:15 <pumpkin_> trying to find it now
19:24:28 <SamB> Axman6: didn't they have that forever ?
19:24:37 <Axman6> don't think so
19:24:48 <pumpkin_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/com Jan 27
19:24:53 <Axman6> i dunno, anyway, it shitted me when i was doing a crappy VB course :)
19:24:56 <SamB> I would correct you but I doubt my installation of VB6 actually works
19:24:59 <ozy`> angerman: the reason I say objective-C is noisy is that you have the entirety of C to deal with + a handful of extensions to interface to what is basically a smalltalk runtime
19:25:02 <angerman> SamB: the com lib seems to be up to date
19:25:04 <curious11> is it possible to compile program into a single .exe that runs on windows?  would it be statically linked to mingw c library?
19:25:23 <SamB> curious11: we don't support dynamic linking on win32
19:25:33 <angerman> pumpkin_: yes he did... the documentation is jsut lacking... :(
19:25:33 <SamB> at leat not for the Haskell code
19:25:39 <pumpkin_> angerman: lacking?
19:25:45 <pumpkin_> it looks like a haddock failure
19:25:57 <curious11> SamB: but it would work with static linking?
19:26:13 <SamB> curious11: should do
19:26:14 <angerman> ozy`: yes :) it's neat ;)
19:26:29 <curious11> SamB: thanks!
19:26:48 <pumpkin_> angerman: judging from the source, it's got plenty of documentation, but something's breaking the haddock build I guess
19:26:50 <SamB> curious11: of course, I haven't tried it really so I don't know what .dlls the executables need ... but none of them are Haskell-related
19:26:58 <angerman> pumpkin_: well I could compile the doc with haddock, but it's not telling you anthing where to start :)
19:27:10 <pumpkin_> oh, fair enough
19:27:11 <pumpkin_> :)
19:27:22 <SamB> angerman: cabal haddock ?
19:27:58 <angerman> pumpkin_: comments like: "This is usefull if you want to do X" are not really helpful. E.g. ok I want to do X ... how do I ?
19:28:08 <pumpkin_> yeah
19:28:09 <sw17ch> so, if a+b+c is a sum, and a*b*c is a product, what is a^b^c?
19:28:22 <pumpkin_> sw17ch: an exponentiation? :P
19:28:36 <pilkarn> a rocketshipnose
19:28:38 <sw17ch> pumpkin_: i'm seriously hoping the technical name is a super power :)
19:28:39 <SamB> angerman: mail the maintainer ?
19:28:48 <newsham> ?check \a b c -> a^(b^c) == (a^b)^(c::Int)
19:28:49 <lambdabot>   "Falsifiable, after 0 tests:\n0\n0\n0\n"
19:28:50 <angerman> maybe I should :)
19:29:27 <Axman6> > 0 ^ (0 ^ 0)
19:29:29 <lambdabot>   0
19:29:34 <pumpkin_> this test is confusing me :(
19:29:37 <Axman6> > (0 ^ 0) ^ 0
19:29:38 <lambdabot>   1
19:29:42 <Axman6> o.O
19:29:45 <sw17ch> lol
19:29:46 <pumpkin_> Axman6: makes sense
19:29:47 <Gracenotes> > 0 ^ 0
19:29:48 <lambdabot>   1
19:29:50 <sw17ch> yep
19:29:50 <Axman6> yeah
19:29:51 <Gracenotes> what
19:29:53 <Gracenotes> no
19:29:55 <Gracenotes> :(
19:29:59 <Axman6> heh
19:30:09 <Gracenotes> although, in most cases where you do need something like 0^0, it's more useful to have it be 1
19:30:23 <Gracenotes> still.
19:30:42 <ozy`> 0 ^ 0, the notorious "null product," is actually undefined, but it makes sense for it to be 1 if we ignore mathematicians for a few minutes ;)
19:31:09 <Gracenotes> it's also so cute
19:31:19 <blackh> It's a fly sunbathing
19:31:20 <pumpkin_> oh wow, random
19:31:21 <Gracenotes> we wouldn't want something so cute raising an exception
19:31:25 <pumpkin_> my tests started working o.O
19:31:29 <newsham> ?check \a b c -> if a > 0 && b > 0 && c > 0 then a^(b^c) == (a^b)^(c::Int) else True
19:31:31 <lambdabot>   "Falsifiable, after 31 tests:\n16\n13\n6\n"
19:31:47 <newsham> ?check \a b c -> a^(b^c) == (a^b)^(c::Integer)
19:31:48 <lambdabot>   "Falsifiable, after 1 tests:\n0\n0\n0\n"
19:31:52 <newsham> oops
19:31:57 <newsham> ?check \a b c -> if a > 0 && b > 0 && c > 0 then a^(b^c) == (a^b)^(c::Integer) else True
19:32:12 <lambdabot>   thread killed
19:32:50 <Gracenotes> 0^0 -> e^(0*ln 0)
19:33:00 <sw17ch> http://en.wikipedia.org/wiki/Tetration
19:33:05 <Gracenotes> and +/- infinity * 0 is a form of indeterminacy
19:33:09 <sw17ch> "Super Power" is way cooler than Tetration :(
19:33:21 <newsham> > (3^(4^5), (3^4)^5)
19:33:22 <lambdabot>   (37339184874102004353295975418486658822540977678373400775063693172207904061...
19:33:41 <sw17ch> but hey, now i know
19:33:50 <SamB> > 3^(4^5) / (3^4)^5
19:33:51 <lambdabot>   Infinity
19:34:00 <SamB> > 3^(4^5) / (3^4)^5 :: Rational
19:34:02 <lambdabot>   107087736377945337588126876039923693643199184652924001580858549826373116385...
19:34:09 <sw17ch> let tetrate (a:as) = foldr (^) a as
19:34:13 <SamB> > 3^(4^5) / (3^4)^5 :: CReal
19:34:14 <lambdabot>   107087736377945337588126876039923693643199184652924001580858549826373116385...
19:34:14 <sw17ch> @let tetrate (a:as) = foldr (^) a as
19:34:15 <angerman> what's that going to be?
19:34:17 <lambdabot>  Defined.
19:34:21 <sw17ch> tetrate [1..3]
19:34:25 <sw17ch> > tetrate [1..3]
19:34:26 <lambdabot>   8
19:34:34 <sw17ch> > 1 ^ 2 ^ 3
19:34:35 <lambdabot>   1
19:34:41 <Gracenotes> > (2^(3^4), (2^3)^4)
19:34:41 * sw17ch did something wrong
19:34:42 <lambdabot>   (2417851639229258349412352,4096)
19:34:48 <sw17ch> > 3 ^ 2 ^ 1
19:34:49 <lambdabot>   9
19:34:52 <sw17ch> wtf
19:34:55 <newsham> > (foldr1 (^) [1..4], foldl1 (^) [1..4])
19:34:56 <lambdabot>   (1,1)
19:34:59 <Gracenotes> infixr 8 ^
19:35:01 <SamB> > length . takeWhile (/='.') . show $ 3^(4^5) / (3^4)^5 :: CReal
19:35:02 <lambdabot>   Couldn't match expected type `CReal' against inferred type `Int'
19:35:10 <SamB> > length . takeWhile (/='.') . show (3^(4^5) / (3^4)^5 :: CReal)
19:35:10 <Gracenotes> 3 ^ 2 ^ 1 is actually 3 ^ (2 ^ 1)
19:35:11 <lambdabot>   Couldn't match expected type `a -> [Char]'
19:35:15 <SamB> > length . takeWhile (/='.') . show $ (3^(4^5) / (3^4)^5 :: CReal)
19:35:17 <lambdabot>   480
19:35:17 <Gracenotes> a not-very-inspiring number
19:35:40 <sw17ch> @let tetrate (a:as) = foldl (^) a as
19:35:41 <lambdabot>  <local>:3:0:
19:35:41 <lambdabot>      Warning: Pattern match(es) are overlapped
19:35:41 <lambdabot>               In...
19:35:41 <Gracenotes> > logBase 10 $ (3^(4^5) / (3^4)^5 :: CReal)
19:35:43 <lambdabot>   479.0297397385410870442080148681357704369294
19:35:46 <chessguy_work> 'sup
19:35:48 <Gracenotes> close enough :)
19:36:00 <sw17ch> @src tetrate
19:36:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:36:03 <chessguy_work> what're we working on?
19:36:07 <SamB> Gracenotes: ah, clever!
19:36:09 <sw17ch> > tetrate [1..3]
19:36:11 <lambdabot>   8
19:36:15 <sw17ch> > tetrate [1..3] :: Expr
19:36:17 <lambdabot>   2 * 2 * 2
19:36:21 <sw17ch> zomg
19:36:31 <SamB> using the mathematical interface instead of hacking with the textual representation ;-P
19:37:01 <Gracenotes> @let tetrate as = foldl1 (^) as
19:37:03 <lambdabot>  Defined.
19:37:09 <sw17ch> @let tetrate (a:as) = foldr1 (^) as
19:37:10 <lambdabot>  <local>:3:0:
19:37:10 <lambdabot>      Warning: Pattern match(es) are overlapped
19:37:10 <lambdabot>               In...
19:37:15 <sw17ch> @unlet
19:37:17 <lambdabot>  Defined.
19:37:21 <sw17ch> @unlet tetrate
19:37:21 <lambdabot>   Parse error
19:37:28 <sw17ch> ... what did i just do?
19:37:40 <Gracenotes> you broke her!
19:37:45 <sw17ch> D:
19:37:57 <sw17ch> > tetrate [2..4]
19:37:58 <lambdabot>   43046721
19:38:04 <sw17ch> > 2 ^ 3 ^ 4
19:38:05 <lambdabot>   2417851639229258349412352
19:38:21 <sw17ch> > (2 ^ 3) ^ 4
19:38:22 <lambdabot>   4096
19:38:31 <sw17ch> > tetrate [2..4] :: Expr
19:38:31 <lambdabot>   3 * 3 * (3 * 3) * (3 * 3 * (3 * 3)) * (3 * 3 * (3 * 3) * (3 * 3 * (3 * 3)))
19:38:32 <newsham> > (foldl1 (^) [2..4], foldr1 (^) [2..4])
19:38:33 <lambdabot>   (4096,2417851639229258349412352)
19:38:41 <sw17ch> i'm so confused
19:38:50 <Gracenotes> foldr starts accumulating at the right end
19:38:55 <sw17ch> oh, right
19:38:57 <sw17ch> :)
19:39:06 <Gracenotes> so it starts with the result (3^4), makes (2^), etc.
19:39:12 <sw17ch> so if the associative property doesn't hold then it gets confused
19:39:48 <O_4> Well, I dunno about 'confused'.
19:39:56 <Gracenotes> if the associative property holds, foldl versus foldr doesn't matter (most of the time)
19:40:18 <SamB> Gracenotes: well, not until you run the code ;-P
19:40:20 <Gracenotes> so long as you get argument order right and such.
19:40:48 <Gracenotes> for (^), you musts choose l vs. r
19:41:27 <sw17ch> how do i undefine something in lambdabot?
19:41:30 <newsham> > 3 $< 4 $< (+)
19:41:31 <lambdabot>   7
19:41:42 <sw17ch> @let correct_tertiate (a:as) = foldl (^) a as
19:41:42 <lambdabot>  Defined.
19:41:52 <sw17ch> > correct_tertiate [1..3]
19:41:53 <lambdabot>   1
19:41:55 <sw17ch> yay!
19:41:58 <sw17ch> > correct_tertiate [1..10]
19:42:00 <lambdabot>   1
19:42:01 <Gracenotes> sw17ch: in that case, you can even use foldl1
19:42:03 <sw17ch> > correct_tertiate [2..10]
19:42:05 <lambdabot>   667010587386907176998684948689877818033334707361993383902779167237965129320...
19:42:08 <sw17ch> whoops
19:42:23 <sw17ch> Gracenotes, yeah, i noticed that after i'd finished the line and decided that i didn't feel like correcting it :)
19:42:30 <ozy`> I forget what the circumstances are where it's okay to use regular foldl and not be too worried about performance or memory usage
19:42:32 <sw17ch> but now the internet will remembger my mistake forever :(
19:43:04 <sw17ch> i saw something really cool with foldr the other day...
19:43:06 <hackage> Uploaded to hackage: chalkboard 0.1
19:43:14 <ddarius> @hackage chalkboard
19:43:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/chalkboard
19:43:20 <sw17ch> foldr ($) Constructor list
19:43:23 <sw17ch> it was awzm
19:44:07 <sw17ch> we were trying to parse out the *'s in a C type
19:44:21 <sw17ch> so we could do something like Ptr ( Ptr ( Ptr ( Ptr Int) ) )
19:44:30 <newsham> > (3 $< x $< (+)) $< 5 $< (*)
19:44:32 <lambdabot>   5 * (x + 3)
19:44:40 <Gracenotes> :t ($<)
19:44:41 <lambdabot> forall a b. a -> (a -> b) -> b
19:45:04 <Gracenotes> wryyyyyyyyy
19:45:04 <BMeph> The short answer is that (a^b)^c == a^(b*c).
19:45:24 <sw17ch> and i'm fairly sure it was something like: let x = Int in foldr (Ptr $) x starList
19:45:46 <ozy`> Gracenotes: now that you've said that, I fully expect your disembodied head to fire itself out of a crossbow
19:46:23 <dons> Chalkboard is a Haskell hosted Domain Specific Language (DSL) for image generation and processing.
19:46:29 <newsham> > foldr ($) (,) [1,3]
19:46:29 <lambdabot>       Overlapping instances for Show (a -> b -> (a, b))
19:46:30 <lambdabot>        arising from a...
19:46:30 <dons> mmm
19:46:35 <dons> gotta get some DSL action
19:46:38 <newsham> > foldr1 ($) (,) [1,3]
19:46:39 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
19:46:39 <lambdabot>      Proba...
19:46:49 * dons boggles at how andyjgill can only depend on array + base
19:46:53 <Gracenotes> @check \a b c -> not (a > 0 && b > 0 && c > 0) || (a^b)^c == a^(b*c)
19:46:54 <lambdabot>   "OK, passed 500 tests."
19:46:56 <blackh> > quickCheck (\(a,b,c) -> if a > 0 && b> 0 && c > 0 then (a^b)^c == a^(b*c) else True)
19:46:57 <lambdabot>   * Exception: "<IO ()>"
19:47:03 <dons> ooh pretty http://ittc.ku.edu/~andygill/chalkboard.php
19:47:08 <Gracenotes> yep
19:47:15 <dons> shapr: ^^
19:47:16 * Nafai looks
19:47:21 <Gracenotes> that might be nice for teaching kids
19:47:30 <Gracenotes> (well, depending on what's meant by nice)
19:47:32 <ddarius> dons; He leaves the rendering up to you perhaps?
19:47:35 <dons> i think it is a teaching language, yes. given andy's teaching FP stuff now
19:48:32 <andyjgill> Yes, I'm using to teach Haskell at KU.
19:48:41 <pumpkin_> nice :)
19:48:43 <dons> andyjgill++ great stuff.
19:48:52 <dons> who wants  to go to KU now?
19:49:09 <dons> this is much better than my pony app
19:49:38 <dons> graphics dsls are coming back strong in 09
19:49:40 <BMeph> I wonder if you could get John Goertzen in on a guest lecture, when he's not hand-holding his servers... :)
19:49:52 <dons> why's that i wonder? good enough low level stuff to be interesting again? (gtk/ wx/ opengl)
19:49:55 <bos> i wish QuickCheck caught exceptions.
19:50:01 <Axman6> who runs hpaste?
19:50:11 <bos> Axman6: mmorrow
19:50:12 <pumpkin_> Axman6: mmorrow now
19:50:12 <andyjgill> Thats a good idea, BMeph.
19:50:29 <sw17ch> would any one be interested in a EDSL to craft network packets?
19:50:30 <pumpkin_> not sure where he went
19:50:38 <dons> andyjgill: here's an Arch Linux package for you, http://aur.archlinux.org/packages.php?ID=24146
19:50:47 <sw17ch> i've been needing a good library to inject packets into a network lately, and those are few and far between now adays :(
19:50:52 <Axman6> pumpkin_: because it's dedzors :(
19:50:52 <newsham> ?hoogle a -> a -> Bool -> a
19:50:53 <dons> so it will be easily installable on arch (even without cabal-install)
19:50:53 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
19:50:53 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
19:50:53 <lambdabot> Test.HUnit.Text PutText :: String -> Bool -> st -> IO st -> st -> PutText st
19:51:03 <pumpkin_> Axman6: yeah, I wonder what's up
19:51:08 <dons> sw17ch: interesting.
19:51:21 <sw17ch> dons: also such a library would be hugely helpful for scurry
19:51:22 <sw17ch> :)
19:51:22 <pumpkin_> sw17ch: you need something like scapy for haskell :D
19:51:30 <newsham> sw17ch: make haskell bindings to dnet?
19:51:31 <pumpkin_> sw17ch: propose it on haskell_proposals :P
19:51:43 <pumpkin_> and lorcon!
19:51:45 <sw17ch> newsham, you'd asked me to do that a long time ago
19:51:48 <sw17ch> and i never did :(
19:52:01 <pumpkin_> http://www.secdev.org/projects/scapy/
19:53:08 <newsham> there are already libs for crafting binary data.  just needs the IO to go wiht it
19:53:18 <Axman6> so, anyone have any happs experience?
19:53:29 <pumpkin_> yeah, but that one is nice in that it has a nice simple interface to all sorts of common protocols
19:53:40 <pumpkin_> at all different layers
19:53:41 <newsham> pumpkin: i'm familiar with it.
19:53:46 <rovar> grr
19:53:49 <sw17ch> i was thinking about a cool set of data types with instances of Binary
19:53:51 <newsham> i prefer dnet/dpkt/pypcap
19:54:01 <sw17ch> such that encode/decode would produce or read a packet off the wire :)
19:54:08 <sw17ch> that would be *so* cool
19:54:40 <newsham> i prefer type Marshall a = (Get a, a -> Put ()) to Binary instances
19:55:09 <newsham> Binary couples marshalling rules too closely with types.
19:55:20 <sw17ch> :(
19:55:31 <dons> that's why Get and Put live on their own
19:55:36 <newsham> *nod*
19:55:47 <bos> Binary is put together quite well.
19:55:47 <dons> so you don't have to do a 'Text' like encoding where decode . encode = id
19:55:50 <pumpkin_> it would be cool if you could just specify the structure for the binary instance and have Get and Put created automatically for you
19:56:03 <sw17ch> deriving (Get, Put)
19:56:09 <sw17ch> that would be handy...
19:56:10 <newsham> bos: I have a RWH haskell/bloom filter question
19:56:14 <sw17ch> but there is that deriving script, right dons?
19:56:15 <dons> Text being the old combined Show /  Read class
19:56:17 <pumpkin_> sw17ch: well, Data.Derive can do it
19:56:17 <newsham> do you happen to have your copy around?
19:56:22 <ddarius> Something like Erlang bitsyntax would likely be a good basis.
19:56:22 <dons> sw17ch: right
19:56:29 <bos> newsham: nope
19:56:33 <dons> ddarius: definitely would help. glguy'd be happy, i bet
19:56:45 <Axman6> ddarius: yeah, probably one of the coolest thigs about erlang
19:56:58 <Axman6> things*
19:57:05 <dons> i don't think anyone's fully exploited view patterns for this yet
19:57:09 * sw17ch needs to learn erlang
19:57:24 <dons> elliottt had a good idea of how to do pseudo-bit syntax via view patterns + Binary
19:57:27 <dons> just needs putting together
19:57:33 <newsham> bos: in http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html at the /Polymorphic testing/ section, you have an unused dummy argument for prop_one_present.
19:58:03 <newsham> and the text hints that its used to change polymorphic function into some monomorphic functions for testing purposes.
19:58:25 <newsham> but, shouldnt there be a type signature for prop_one_present that ensures that the unused argument has the same type as one of the used arguments (no signature is in the text)
19:59:06 <Gracenotes> hm. I'm starting to think that newtyping monad transformers isn't always the best solution
19:59:17 <Gracenotes> especially if you're stacking them on top of each other
19:59:40 <chessguy_work> @where calewiki
19:59:41 <lambdabot> http://cale.yi.org/index.php/Main_Page
19:59:48 <newsham> or am I missing something thats going on?
19:59:56 <Gracenotes> chessguy_work: yes, read it
20:00:00 * glguy wonders what he just got signed up for
20:00:11 <chessguy_work> Gracenotes, ah, ok
20:00:25 <Axman6> dons: i could be wrong, but it seems to me like something that would be better if it were in the compiler somehow. but it's not something i know much at all about
20:00:42 <dons> bit syntax?
20:00:42 <Gracenotes> chessguy_work: I'm trying to use one monad transformer as utility in another monad transformer, but it's getting hard not to have them touch insides
20:00:47 <Axman6> yeah
20:00:51 <dons> maybe. its kind of special purpose though, of course.
20:00:57 <chessguy_work> umm, ok
20:01:02 <pumpkin_> Axman6: you're not on the twitter page on haskell wiki!
20:01:04 <dons> we'd need more general support for bit level marshalling/unmarshalling/data i guess
20:01:07 <dons>  to justify it
20:01:08 <Axman6> :O
20:01:13 <dons> and typing..
20:01:15 <pumpkin_> neither is glguy :o http://haskell.org/haskellwiki/Twitter
20:01:16 <Axman6> yeah :\
20:01:24 <dons> yo, glguy's on twitter!
20:01:32 <Nafai> I would have added myself to that page
20:01:38 <Nafai> But I don't have an acocunt on the haskell wiki
20:01:40 <chessguy> pumpkin_ i am! do i get a gold star?
20:01:53 * pumpkin_ sticks a gold star to chessguy's forehad
20:01:55 <pumpkin_> forehead even :)
20:01:57 <chessguy> yay!
20:02:08 <dons> dcoutts_: someone book marked 'cabal-install' after viewing the youtube video
20:02:15 <dons> wondering what sort of haskell magic they'd just seen.
20:02:17 * chessguy makes sure he hides from the Gestapo...
20:02:19 <dons> dcoutts_: video == good
20:02:46 <pumpkin_> Axman6: if you're not careful, I'll add you myself, then you'll be sorry
20:03:35 * sw17ch doesn't twitter... should he?
20:03:45 <Axman6> yes
20:03:49 <pumpkin_> sw17ch: up to you :P many say it's BS, others say it's nice :)
20:04:18 <Axman6> pumpkin_: whatchu mean i'm not on there? >_>
20:04:28 <sw17ch> some how dons keeps finding my adviser from college when he (adviser) knocks haskell about something.
20:04:31 <dons> its like irc but [announce only]
20:04:40 <dons> sw17ch: mwhaha
20:04:43 <dons> who's that/
20:04:48 <sw17ch> dons: jdfrens
20:04:51 <dons> ah!
20:04:55 <sw17ch> :)
20:05:05 <sw17ch> i prodded him enough and he's teaching some haskell now
20:05:10 <dons> heh
20:05:20 <Axman6> dons: ever heard of peter strazdins by any chance?
20:05:29 <dons> yes, twitter is yet another place to fight the power
20:05:38 <pumpkin_> gotta spread the message!
20:05:44 <dons> nope, Axman6
20:05:48 <Gracenotes> it's like irc but [people pretend to care]
20:05:50 <Gracenotes> oh wait
20:05:53 <glguy> Pokémon!
20:05:56 <Gracenotes> :(
20:05:57 <Axman6> righto
20:05:57 <pumpkin_> Gracenotes: get twitter!
20:06:02 <dons> Gracenotes: i love you
20:06:05 <chessguy> Gracenotes twitters already :)
20:06:09 <pumpkin_> :o
20:06:09 <Axman6> Gracenotes: we'll love you forever!
20:06:13 <sw17ch> see, now i feel left out
20:06:23 * chessguy always perks up when he sees a tweet from Gracenotes 
20:06:46 <pumpkin_> chessguy: last I heard Gracenotes was already taken on twitter and our Gracenotes couldn't think of another musical name
20:07:00 <pumpkin_> I guess I'm behind the times
20:07:03 <Gracenotes> > "Time to" ++ cycle " tweet" ++ "?"
20:07:04 <lambdabot>   "Time to tweet tweet tweet tweet tweet tweet tweet tweet tweet tweet tweet ...
20:07:04 <dons> cabal install pony. 5 star rating on youtube. roxors!
20:07:41 <sw17ch> @pl \i can haz pony -> no can haz pony
20:07:41 <lambdabot> const no
20:07:44 <sw17ch> :D
20:07:50 <dons> heh
20:07:58 <chessguy> oh! i was thinking of TacticalGrace ... i guess it's not the same...
20:08:05 <dons> that's chillix
20:08:10 * sw17ch goes to check if sw17ch is available
20:08:36 <sw17ch> oh dear it is...
20:08:37 * sw17ch makes account
20:08:44 <Gracenotes> chessguy: :P
20:09:31 <chessguy> this blog entry irritates the snot out of me: http://confusion.tweakblogs.net/blog/1418/why-functional-programming-doesnt-catch-on.html
20:10:09 <Gracenotes> I could use vorschlagsnoten :)
20:10:13 <newsham> > unwords $ intercalate ["BOOP"] $ map (flip replicate "beep") $ nubBy (\a b -> b `mod` a == 0) [2..]
20:10:15 <lambdabot>   "beep beep BOOP beep beep beep BOOP beep beep beep beep beep BOOP beep beep...
20:10:17 <Gracenotes> not terribly memorable though
20:10:27 <dons> chessguy: he got smacked down fairly well though
20:10:27 <pumpkin_> Gracenotes: I don't even know how to pronounce that :P
20:15:03 * Gracenotes wonders what changed to pony we'll see in the future
20:15:09 <Gracenotes> *changes
20:15:38 <Axman6> anyone done any work with happs before? we've come up with a proposal for a happs documentation site, and need someone to (help) write it
20:15:48 <Axman6> for the great good
20:16:00 <sw17ch> oh hai guys --> https://twitter.com/sw17ch
20:17:18 <sw17ch> :D
20:17:31 <blackh> Axman6: Is the proposal on the web?
20:17:38 <Gracenotes> :D
20:17:42 <Gracenotes> D:
20:17:47 <Axman6> well, i have notes on the web for it. sec
20:18:13 <chessguy_work> why the $#@%@#$% can't i get an email when someone @replies to me on twitter :(
20:18:24 <Axman6> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1542#a1542
20:18:38 <sw17ch> > cycle ":D D: "
20:18:39 <lambdabot>   ":D D: :D D: :D D: :D D: :D D: :D D: :D D: :D D: :D D: :D D: :D D: :D D: :D...
20:18:53 <sw17ch> it doesn't have the same effect when there are that many of them
20:19:16 <Gracenotes> maybe it you separated them with newlines
20:19:19 <blackh> Axman6: Is the idea to improve the documentation on hackage packages wiki style?
20:19:20 <pumpkin_> sw17ch: yay, add yourself to the wiki page :)
20:19:24 <Gracenotes> :D
20:19:26 <Gracenotes> D:
20:19:28 <Gracenotes> et al.
20:19:30 * sw17ch hunts down wiki credentials
20:19:38 <Axman6> blackh: not so much
20:19:57 <pumpkin_> sw17ch: following you :D
20:19:59 <Gracenotes> speaking of which, for the blahth time in blahever, any chance of account creation being enabled on wiki again?
20:20:03 <Axman6> i've thought about it, and i think that using haddock may not be the best way to do this
20:20:21 <blackh> Axman6: What are you actually trying to achieve?
20:20:25 <Axman6> and i prefer to call this idea editable docs, rather than a wiki
20:20:27 <SamB_XP_> Gracenotes: there was a recent HWN saying to email someone if you want an account
20:20:30 <SamB_XP_> a particular someone
20:20:35 <Gracenotes> okay, some spam guy edited a few articles. The block button is well-suited for this.
20:20:38 <Axman6> blackh: a website for happs documentation, PHP style
20:20:45 <sw17ch> pumpkin_: no one is going to believe that this many people even know who i am :)
20:20:52 <Gracenotes> x.x
20:20:52 <sw17ch> ps: where is wiki link again?
20:20:54 <SamB_XP_> Gracenotes: I think it was worse than that
20:20:56 * chessguy_work finally googles to figure out his twitter issue
20:21:04 <dons> Gracenotes: we need to upgrade mediawiki first
20:21:06 <pumpkin_> sw17ch: http://haskell.org/haskellwiki/Twitter
20:21:14 <dons> which means upgrading  the server it is on
20:21:16 <Axman6> blackh: see http://www.php.net/manual/en/function.echo.php for an example
20:21:18 <pumpkin_> sw17ch: doesn't seem to be any particular ordering on the list :P
20:21:28 <Gracenotes> SamB_XP_: fair enough -- whom shall I email?
20:21:43 <sw17ch> pumpkin_: i noticed...
20:21:44 <SamB_XP_> Gracenotes: look through the HWN's yourself
20:21:46 <SamB_XP_> I forgot
20:21:50 * sw17ch decides the bottom is as good as the top :)
20:21:52 <SamB_XP_> I can't even remember how to pluralize ;-P
20:22:19 <Axman6> blackh: things to notice is the docs are clear, they tell you how to use it, as well as having examples, and they have user comments (which i think is a must)
20:22:33 <blackh> Axman6: I'm with ya. I understand that it could be general, but what API are you planning to document initially?
20:22:40 <sw17ch> people should note their IRC handle if it's different from their twitter handle
20:22:44 <Axman6> blackh: happs
20:22:52 <Axman6> using happs for the app
20:23:01 <Axman6> self documenting documents!
20:24:23 <blackh> Axman6: It seems like a very good idea.  I need to decide whether I can spare any time!
20:24:47 * sw17ch notes that it's 11:30 PM
20:24:49 <Axman6> blackh: yeah, i'd like to do it, but i don't think i have the time, nor the knowledge
20:25:31 <pumpkin_> sw17ch: good idea
20:25:41 <blackh> Axman6: Can anyone edit it, like a wiki?
20:25:52 <Axman6> blackh: yep
20:26:03 <Axman6> thinking accounts mightn't be a bad idea though
20:26:52 <cjfairley> good evening, all
20:27:18 <chessguy> sw17ch, why is that?
20:27:37 <sw17ch> chessguy, because i have no idea who some of you are :)
20:28:07 <sw17ch> except by the name that goes to the left of your text in IRC
20:28:41 <sw17ch> wow, twitter spam already
20:28:43 <sw17ch> woot
20:28:44 <chessguy> sw17ch, well, the link on the wiki page shows my IRC nick, even though it points to my twitter nick. and my twitter page shows my IRC nick on it
20:28:52 <sw17ch> oh hey
20:29:35 <chessguy> sw17ch, you got spam on twitter?
20:29:55 <sw17ch> uhh... just a random follow from some one apparnetly pushing sexxy pics
20:30:02 <chessguy> heh. nice
20:30:14 <pumpkin_> sw17ch: send a message to @spam
20:30:31 <sw17ch> unless one of you is what appears to be an attractive blond female who goes by the name "soon"
20:30:41 <sw17ch> and "likes to make money while staying at home"
20:30:43 <pumpkin_> and she loves sitting at home making money
20:30:44 <chessguy> haha
20:30:45 <pumpkin_> yeah
20:30:47 <sw17ch> woot!
20:30:53 <sw17ch> who be this?
20:31:39 <chessguy> maybe she makes money programming in haskell from home!
20:31:59 <sw17ch> so i'm safe to assume this is spam then?
20:32:33 <Axman6> hmm, how do i remove old Happs stuff from cabal?
20:34:52 <blackh> Axman6: Perhaps I can be roped in to do some infinitessimally small part of this project. I don't have Happs experience, but I'm interested in learning it.  I should warn you that I hate SQL.
20:35:21 <Axman6> blackh: happs doesn't use SQL, hoorah :)
20:35:28 <Axman6> though, being haskell, it can if you want it to
20:35:48 <ozy`> so guys
20:35:57 <ozy`> what non-tiling window managers would you recommend?
20:36:06 <Axman6> Xmonad
20:36:07 <Axman6> >_>
20:36:12 <ozy`> non-tiling
20:36:24 <Axman6> it can work non tiled, sort of
20:36:36 <ozy`> yes but I have it configured to tile already
20:36:46 <ozy`> and I don't want to back up my file
20:37:33 <ozy`> or futz around with the config some more
20:37:45 <ozy`> I just want a normal window manager (that isn't twm)
20:37:52 <ozy`> (or quartzwm)
20:38:01 <chessguy> sw17ch, hey, i got the same treatment! wonder if someone's getting the account names off the wiki page
20:38:16 <sw17ch> chessguy, like, yeah, just a second ago then :)
20:38:19 <sw17ch> b/c i *just* added mine
20:38:36 <chessguy> yeah, mine's been there for a day or so
20:39:53 <pumpkin_> ?
20:40:34 <chessguy> @type return . head =<< getArgs
20:40:35 <lambdabot> Not in scope: `getArgs'
20:40:41 <pumpkin_> sw17ch: I'd be inclinded to believe people are looking at the global feed
20:40:46 <pumpkin_> (the spammers)
20:40:48 <chessguy> @type return . head =<< System.getArgs
20:40:49 <sw17ch> mmm
20:40:49 <lambdabot> IO String
20:41:15 <chessguy> @type liftM head getArgs
20:41:16 <lambdabot> Not in scope: `getArgs'
20:41:22 <chessguy> @type liftM head System.getArgs
20:41:23 <lambdabot> IO String
20:41:37 * chessguy thought as much
20:42:33 <sw17ch> newsham, it's now on my todo list --> http://blog.sw17ch.com/wordpress/?p=79
20:42:41 <Axman6> anyone got any idea how to uninstall the old happs? i've got both happs and happstack installed, so i can't use either
20:42:51 <pumpkin_> Axman6: ghc-pkg unregister ?
20:42:54 <pumpkin_> then delete the files yourself
20:43:00 <Axman6> ghc-pkg can't find it :\
20:43:05 <pumpkin_> o.O
20:43:16 <pumpkin_> so it doesn't show up in ghc-pkg list ?
20:43:32 <Axman6> wait, yes it can
20:44:49 <Axman6> how do you unregister it then? giving the name of the packages doesn't work
20:44:54 <Axman6> and my internet's died...
20:45:06 <pumpkin_> what does it say if you give it the name of the package?
20:45:16 <pumpkin_> give it the full name with version, maybe?
20:45:38 <sw17ch> alright, i'm going to get some sleep. gnight all
20:45:46 <pumpkin_> night :)
20:47:05 <shapr> dons: Oooh, chalkboard is cool!
20:48:19 <Axman6> pumpkin_: s'all good now
20:49:16 <dons> its nice that we can receive really cool project news daily in haskell landd now
20:49:29 <dons> there used to be looong gaps between project announces back in the day
20:49:45 <redditbot> Chalkboard: a beautiful EDSL for image generation and processing
20:51:02 * ddarius considers using DPH to implement wavelet noise.
20:51:38 <pumpkin_> mmm, DPH
20:52:56 * ddarius only has one processor so he wouldn't actually be able to tell if that aspect was working.
20:53:11 <Axman6> :(
20:53:25 <wli> I can't tell if my Gaussian elimination code is working yet.
20:53:48 <roconnor> wli use dependent types, then you won't even have to run it
20:53:51 <wli> I really can't code my way out of a wet paper bag anymore.
20:54:40 <wli> I was going to use it for division of algebraic numbers.
20:55:36 <wli> modelling them as elements of Q[x]/(p(x)) where p(x) is the minimal polynomial.
20:55:49 <pumpkin_> ddarius: I can give you an ssh login to a "box" with 4 if you want
20:58:03 <ddarius> pumpkin: It probably won't be necessary.
20:58:04 <Axman6> shit. getting very strange errors when trying to get something i made with happs a while ago working :(
20:58:05 <wli> roconnor: My big stumbling block is the permutation accounting for pivoting.
20:58:12 <pumpkin_> okay :)
20:58:37 <Axman6> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1544#a1544 :(
20:59:27 <pumpkin_> http://hackage.haskell.org/trac/ghc/ticket/2578
21:01:15 <wli> I can't figure out how to backsubstitute using what I've generated for the life of me.
21:01:30 <lolololol> http://ihateliz.com/?id=hl1k9e2smpri0t42m1rx8cu6fw61zd
21:02:05 <pumpkin_> bah :)
21:02:07 <pumpkin_> bbiab
21:02:17 <wli> (Basically I get an LU factorization and a bunch of transpositions of rows and columns.)
21:02:45 <Axman6> wli: time to stop, sit back, think about the proble, and simplify?
21:02:49 <Axman6> problem*
21:03:58 <wli> Well, it should (in theory) be plug-and-chug just scribbling down of algorithms thoroughly described on the net.
21:04:26 <wli> In practice I've lost too many brain cells to muddle through it.
21:04:43 <Luke> i'm trying to aggregate all this online info about happs and happstack... is there currently nothing for haskell that can compete with django or rails?
21:04:44 <Axman6> that's the problem, thinking it's easy. i do it all the time, and make simple little mistakes, but keep thinking 'wtf, this should work!'
21:05:24 <wli> I can't eke out an AVL tree implementation in C, either. I've done it before on a number of occasions. :(
21:09:20 <Xilon> I'm trying to install happy, but it seems there's a compatibility problem with cabal: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1545#a1545
21:09:32 <Xilon> Do I have to downgrade or what?
21:10:52 <dons> cabal install happy
21:10:54 <dons> -- works here
21:15:15 <dons> blackh: did you see http://haskell.org/haskellwiki/Shootout/Parallel/BinaryTrees ?
21:15:22 <dons> and the others under Parallel/
21:16:00 <dons> ah yes
21:16:14 <blackh> dons: Yes, I found those recently. I edited a couple. The BinaryTrees one is the one I tried earlier, and it didn't work as well as mine.
21:16:40 <dons> wow, your regex-dna is thorough
21:17:04 <dons> i was hoping for a trivial modification, since it was already pretty competitive (top 3)
21:17:26 <blackh> Actually my regex-dna is only modified for the substitution part at the end - the rest of the benchmark is the same.
21:18:02 <dons> awesome.
21:18:19 <blackh> The currently posted one is highly illegal as you've noted (i.e. it doesn't use regexes at all, contrary to the requirement!)
21:18:32 <Axman6> heh
21:18:36 <Axman6> SHHHH!
21:19:31 <blackh> If I had done a straight-forward implementation, the performance would have been terrible. (I tried it.)
21:19:57 <blackh> So I instead I wrote the "C program" that you see at the end. :)
21:21:12 <Axman6> blackh: oh wow... scrolled down.. ugly :(
21:21:38 <Axman6> there must be a faster, idiomatic way of doing it :\
21:21:43 <blackh> Axman6: It's as ugly as sin.
21:22:17 <Axman6> this sort of stuff does not make haskell look good really
21:22:23 <dons> we need good regex substitution in libs
21:22:29 <dons> all these regex-* libs have no subst function
21:22:40 <Axman6> having to resort to writing C in haskell makes people want to just use C
21:22:48 <dons> libraries, man, libraries!
21:22:52 <dons> if 'subst' was there, game over.
21:23:11 <blackh> If we put this sort of approach into a library, the benchmark would be clean and fast.
21:23:21 <dons> chris writes in the src that there's no subst function because there's too many different requirements
21:23:26 <dons> so we should just pick one, i think
21:23:29 <dons> and get it in there
21:24:14 <pumpkin_> or treat it like byorgey did split
21:24:14 <blackh> If this were in the library, it would be faster because we wouldn't need to allocate the array of match positions.
21:25:15 <edwardk> > x + x
21:25:16 <lambdabot>   x + x
21:25:19 <blackh> Still - I think this code is no worse than anything someone might write in C - it's just that we have higher standards.  Or at least some of us do.
21:25:24 <edwardk> what package provides that functionality?
21:25:28 <dons> we expect   this stuff in libs.
21:25:39 <Xilon> dons: Ah, I was trying to compile 1.17, which is _old_, 1.18.2 seems to work :)
21:25:45 <lament> :t (x + x)
21:25:46 <lambdabot> Expr
21:25:55 <dons> these libs should provide a subst function, http://twurl.cc/hyk
21:26:09 <edwardk> simple-reflect?
21:26:11 <dons> since they do just about everything else
21:26:39 <blackh> dons: Well, I think we should do it. I am not sure who "we" is.
21:28:19 <Axman6> edwardk: yep
21:28:36 <blackh> Just this second, my binary-trees got changed to "accepted"
21:29:44 <Axman6> :O
21:33:47 <pumpkin_> omg a mmorrow
21:34:03 <mmorrow> pumpkin seeds!
21:34:11 * kerlo notes that a mmorrow is not the same thing as a morrow
21:34:11 <pumpkin_> where?
21:34:33 <newsham> [19:22] < blackh> If we put this sort of approach into a library, the benchmark would be clean and fast.
21:34:43 <mmorrow> pumpkin: i wish
21:34:44 <kerlo> "omg a morrow" is an appropriate thing to say at midnight, which is what I figured you were doing.
21:34:46 <newsham> you could put all of the benchmark in a shootout lib
21:34:52 <newsham> but that hardly seems fair
21:35:04 <pumpkin_> kerlo: nope, just being silly :P
21:35:13 <pumpkin_> kerlo: but omg half past a morrow maybe
21:43:06 <hackage> Uploaded to hackage: XInput 0.1
21:43:28 <sjanssen> hmm
21:43:43 <blackh> :):-D:-(;-):P=-O:-*8-):-[:'(:-/O:-):-X:-$:-!>:o
21:44:18 <erikc> windows software development is maddening
21:55:12 * wli reads but does not understand.
21:58:41 <BMeph> So, have we already talked gar's latest missive to death? :)
22:00:05 <Axman6> ?
22:01:16 <Axman6> argh, not happy with happs, it's filling me with frustration, confusing and sadness
22:01:23 <Axman6> confusion*
22:02:54 <BMeph> Axman6: http://syntax.wikidot.com/blog:10
22:03:30 <steveklabnik> ah, I saw that.
22:04:15 <BMeph> (FYI: "gar" == Gregg A Reynolds
22:04:17 <BMeph> )
22:04:58 <steveklabnik> I find it interesting... this is similar to something that's happend with me, over the course of my development as a programmer
22:05:00 <BMeph> Axman6: Uh-oh, is this regular happs, or the "New and Improved" Happstack?
22:05:11 * angerman hits his head against a wall: http://failblog.org/2009/02/22/education-fail/
22:05:16 <Axman6> new improved happstack.
22:05:33 <Axman6> but, i may be looking in the worng places :)
22:05:46 <mmorrow> check under the cushions
22:05:52 <BMeph> Axman6: Either way, the Happstack guys may be able (and willing!) to offer advice, or at least useful sympathy. :)
22:06:35 <Axman6> BMeph: heh, well no one in #happs is saying anything. and the thing is, i'm trying to write a website in happs for happs documentation -_-
22:06:48 <Axman6> add stack where necessary there
22:06:53 <steveklabnik> I used to be waay too concerned with performance over all else. I'm slowly learning that sometimes, there's such a thing as 'fast enough'.
22:06:59 <BMeph> I notice that gar likes to go for the dramatic "poke it with a stick, and act innocent afterwards" tactic:
22:07:33 <BMeph> "I can't follow the technical details, but I do know that this kind of "performance" comparison is pointless and probably harmful." -- from his comment on all of the gcc vs. ghc hubbub.
22:08:01 <steveklabnik> BMeph: it's a nice way to sidestep the argument itself and get to the core of the matter, I think
22:08:53 <ddarius> BMeph: He also likes to go for the "I don't understand it, but I know what I'm talking about."
22:15:55 <BMeph> ddarius: "Trust me!" ;p
22:25:22 <pumpkin_> mmorrow: do you have any ideas about the inverse of the problem I presented earlier? Ptr -> ByteArray? I looked at it and it seems to have little bit of info at the beginning of the ByteArray that would make doing what I want in constant time impossible
22:25:56 <mmorrow> pumpkin_: yeah, i'm not sure about that. i tried messing with some stuff but no dice
22:26:03 <mmorrow> i think you'll just have to copy it
22:26:10 <pumpkin_> yeah, I ended up doing that
22:26:14 <pumpkin_> you can see how ugly it is at http://patch-tag.com:5003/publicrepos/pumpkin-uvector/Data/Array/Vector/Binary.hs :P
22:26:19 <mmorrow> heh
22:26:29 <pumpkin_> in unsafeLoadBU
22:27:35 <blygis> What do you say if I say: "Haskell On Rails" (ie a Ruby on Rails port)?
22:27:45 <blygis> Is it even possible?
22:27:46 <kmeyer> gdiaf
22:27:56 <blygis> kmeyer?
22:28:01 <kmeyer> go die in a fire
22:28:01 <sjanssen> pumpkin_: what about endianness?
22:28:03 <kmeyer> is what I say
22:28:10 <blygis> kmeyer how come?
22:28:15 * kmeyer isn't a fan of rails
22:28:21 <blygis> why not?
22:28:23 <pumpkin_> sjanssen: ignored :) that's part of the unsafeness :) I provide a Data.Binary instance for platform-independent serialization
22:28:35 <blygis> what web framework do you prefer kmeyer?
22:28:44 <kmeyer> blygis: none
22:29:04 <blygis> umm
22:29:07 <blygis> "okay"
22:29:19 <pumpkin_> sjanssen: I have a feeling this unsafeSerialize stuff is even more unsafe than you might expect, but I barely know anything about GHC internals :)
22:29:42 <pumpkin_> not sure if that should mean I should stay away from this stuff
22:29:47 <pumpkin_> but I'm learning :D
22:30:10 <Cale> blygis: why shouldn
22:30:14 <Cale> blygis: why shouldn't it be?
22:30:24 <Cale> (possible)
22:30:46 <blygis> Cale: I don't know really.. Well, Ruby is object-oriented and Haskell, does it have objects? :)
22:31:01 <blygis> and if it is possible, why hasn't it been done yet?
22:31:10 <Cale> Well, it wouldn't look exactly the same.
22:31:39 <blygis> of course not :)
22:31:48 <Cale> Haskell has values :)
22:31:55 <blygis> but why hasn't anyone done it then?
22:31:56 <Axman6> blygis: seen happstack?
22:32:11 <Axman6> or turbinado or what ever its called
22:32:18 <Cale> blygis: There are a number of web application framework projects.
22:32:29 <blygis> yea I guess
22:32:34 <Cale> blygis: But there aren't so many web people in the Haskell community yet.
22:32:48 <Axman6> http://www.turbinado.org/Home
22:33:04 <pumpkin_> blygis: objects aren't the only way to go about things
22:33:08 <steveklabnik> blygis: there is also a LOT to rails.
22:33:17 <wli> Maybe there aren't enough Haskell people in the web community.
22:33:26 <blygis> mkay
22:33:27 <Cale> blygis: Personally, I hate how messy all the web standards are, and since I mostly program for fun...
22:34:53 <blygis> Cale you avoid the web? :)
22:35:21 <pumpkin_> sjanssen: have any hints on how to learn low-level stuff like that? I've mostly been poking around existing low-level code and the GHC source, but reading code can be kinda tedious
22:36:24 <raxas> blygis: we do not use objects in haskell for doing html, we use combinators
22:36:24 <ivanm> blygis: at a guess, I'd say that he still _uses_ the web...
22:36:25 <ivanm> ;-)
22:36:52 <Cale> blygis: Basically. I even run mediawiki on my webserver because I'm too lazy to do anything myself. :)
22:37:04 <blygis> hehe
22:38:48 <sbahra> @users
22:38:48 <lambdabot> Maximum users seen in #haskell: 658, currently: 568 (86.3%), active: 17 (3.0%)
22:41:48 <dmead_home> hey channel
22:42:01 <dmead_home> does '.' mean anything special in lisp?
22:42:08 <mmorrow> pumpkin_: couldn't you possibly just create a ByteArray# of the appropriate size, get its Addr# with byteArrayContents# and wrap in a Ptr, then just do one memcpy from the Ptr in the ForeignPtr in the ByteString to that Ptr from the ByteArray# ?
22:42:26 <Cale> dmead_home: It's used to make improper lists -- ones whose tail is not the empty list.
22:42:35 <mauke> dmead_home: (a b c . d) is (cons a (cons b (cons c d)))
22:42:43 <dmead_home> ahh
22:42:46 <dmead_home> thanks
22:42:55 <dmead_home> i just had that crop up in my results
22:42:57 <dmead_home> never seen that before
22:43:08 <mmorrow> pumpkin_: oh wait, i think that's essentially what you're doing
22:43:13 <pumpkin_> yeah
22:43:32 <pumpkin_> one thing I wasn't sure of is how using marr# as the dst of memcpy would work
22:43:43 <mmorrow> yeah, that's what confused me at first
22:43:51 <Cale> It's notable that such lists are used (in many lisps) as the parameter lists in function definitions to define variadic functions.
22:43:56 <Luke> i'm trying to figure out how to use hackage/cabal but it seems like all the guides are self-referencing... can anyone point me to a guide that doesn't presuppose I have cabal working already?
22:44:14 <sauf_> hi, do you know how to make quickCheck work with CReal arguments ?
22:44:28 <Cale> sauf_: You'd need to write an instance of Arbitrary for it.
22:44:30 <pumpkin_> sauf_: write an Arbitrary instance for CREal
22:44:46 <Cale> Luke: you mean cabal-install?
22:44:53 <Cale> Luke: or the Cabal library?
22:44:54 <pumpkin_> sauf_: that mostly involves writing a simple arbitrary function, but you might want coarbitrary too
22:45:54 <Cale> Luke: Download the cabal-install tarball from Hackage and unpack it. Inside, you'll find a bootstrap shell script which will download and install a few other libraries it needs and compile cabal-install for you.
22:46:20 <Cale> (This is assuming you're on a unix-like platform...)
22:46:35 <pumpkin_> sauf_: make sense?
22:47:16 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
22:48:13 <Luke> sorry I was afk. let me read up
22:48:16 <sauf_> pumpkin: *** Exception : No instance nor default method for lass operation Test.QuickCheck.arbitrary
22:48:30 <sauf_> pumpkin: what should I write
22:48:41 <pumpkin_> instance Arbitrary CReal where arbitrary = ...; coarbitrary = ...
22:49:01 <Luke> Cale: yeah I saw that and was unsure what it was far. there's no way to use cabal from the interpreter or anything?
22:49:07 <pumpkin_> arbitrary could be as simple as fmap realToFrac arbitrary
22:49:57 <Cale> Luke: That would be interesting, but no. The cabal program itself isn't a library.
22:50:15 <Luke> why are there no premade binaries for it?
22:50:31 <Luke> i'm wondering why it's not in ubuntu's repos if it this script just makes a bin?
22:51:21 <Cale> Well, ubuntu's support for Haskell isn't so good. The dev cycle is badly aligned, so they're almost always 6 months behind on what they do have.
22:51:38 <Luke> damn that sucks
22:51:39 <Cale> (GHC comes out right after Ubuntu)
22:51:44 <Luke> haha
22:51:54 <pumpkin_> sauf_: get it working?
22:52:17 <sauf_> pumpkin: Ambiguous type variable 'a' in the constraints
22:52:34 <Cale> I just end up using the generic linux binary for GHC, and install cabal-install by hand. Once you have cabal-install, you can use it to install anything else on Hackage that you might need.
22:52:42 <Cale> It would be good if GHC included it though.
22:53:00 <pumpkin_> make that fmap realToFrac (arbitrary :: Gen Double) then
22:53:25 <Cale> I think there's a project to put together a set of core libraries and tools from Hackage to bundle with the large version of GHC.
22:54:07 <ivanm> @seen matthew-_
22:54:07 <lambdabot> matthew-_ is in #haskell-blah, #ghc and #haskell. I don't know when matthew-_ last spoke.
22:54:19 <mmorrow> pumpkin_: lol, "class UnsafeIO a where ..."
22:54:24 <pumpkin_> :P
22:54:41 <pumpkin_> I'm bad at naming
22:54:48 <pumpkin_> I wanted to put the code up, and maybe refactor it a bit later
22:54:50 <mmorrow> i like it ;)
22:54:55 <pumpkin_> not sure about the name of the module either
22:55:10 <pumpkin_> I'd like to see how unsafe the IO really is, too
22:55:13 <mmorrow> seems appropriate
22:55:34 <sauf_> pumpkin: it works ! Thanks :)
22:55:42 <mmorrow> pumpkin_: well if you're doing Doubles it should be fine
22:55:55 <sauf_> pumpkin: what is Gen ?
22:56:03 <mmorrow> pumpkin_: and Int/whatever i guess will just have the endianness of your machine
22:56:05 <pumpkin_> the issue seems to be that uvector uses newByteArray#, not newPinnedByteArray#, so our byteArrayContents# isn't guarnateed to work
22:56:36 <pumpkin_> mmorrow: well, the intent of the UnsafeIO functions was to serialize it to a format that should definitely work on the same computer
22:56:38 <mmorrow> true
22:56:38 <glguy> fun way to use State http://pastie.org/397192
22:57:00 <pumpkin_> mmorrow: so you could be reading arbitrary memory if the GC decides to move your original BUArr around
22:57:19 <mmorrow> pumpkin_: yeah, i dig it. i don't see why there shouldn't be a way to do that if it's possible
22:57:50 <mmorrow> pumpkin_: yeah, that's a problem. luckily though the GC doesn't move arrays (maybe)
22:58:07 <pumpkin_> yeah, it seems strange to move things around, but the existence of pinned arrays made me wonder
22:58:11 <mmorrow> but maybe a memcpy would be the safe thing
22:58:26 <mmorrow> pumpkin_: yeah, that's what makes me second guess what i just claimed
22:58:47 <pumpkin_> then it stops being so unsafe though :(
22:58:54 <pumpkin_> maybe I should make unsaferSerialize
22:59:09 <mmorrow> unsaferestBabySlaughterIO
22:59:20 <glguy> I made a version of that huffman program from earlier to be a little more idiomatic :) http://pastie.org/397193
22:59:59 <mmorrow> pumpkin_: but honestly though, i dunno if O(1) is worth it if the ByteArray# can be moved and garbage'll result
23:00:30 <mmorrow> might as well just memcpy
23:02:01 <pumpkin_> yeah, hmm
23:02:14 <Luke> what does "mtl -any" mean? the cabal-install script says i'm missing it as a dep
23:02:18 <pumpkin_> maybe just a function that takes a handle and writes directly to the handle
23:02:21 <pumpkin_> without a bytestring in between
23:02:33 <pumpkin_> basically fixing the existing UIO interface
23:03:21 <pumpkin_> that would allow sending it over a socket or to a file
23:03:31 <mmorrow> pumpkin_: the handle is still buffered and has all kinds of stuff inside, if you're going for speed maybe just take an Fd and foreign import unsafe ccall "write"
23:03:59 <pumpkin_> yeah, but the UIO interface that's already in uvector takes care of that already I think
23:04:03 <pumpkin_> it was kinda voodooish
23:04:09 <mmorrow> UIO?
23:04:22 <pumpkin_> the existing serialization api
23:04:25 <pumpkin_> which is a little broken
23:04:36 <mmorrow> hmm
23:04:40 <Luke> Cale: any idea what "mtl -any" missing dep means?
23:04:46 <pumpkin_> in that it doesn't write a length out with the vector, so the UAProd-based instances are broken, for example
23:05:10 <Luke> ah nevermind i found the dep
23:05:19 <angerman> what kind of tasks are "easy" to accomplish with haskell?
23:05:26 <Cale> Luke: ah, if you installed ubuntu's GHC, they split up a lot of the common libraries into separate packages.
23:05:41 <Cale> Luke: I think it's libghc6-mtl-dev or something :)
23:05:48 <Luke> yup found it
23:05:58 <Luke> thought it was some kinda flag... the -any threw me off
23:06:02 <mmorrow> angerman: mapping a function over a list
23:06:13 <Cale> It's a version requirement :)
23:06:14 <angerman> mmorrow: ok, what else? :)
23:06:19 <Cale> (or the lack of one)
23:06:29 <angerman> wheee...
23:06:49 <sauf_> pumpkin++
23:07:03 <sauf_> bye
23:07:30 <mmorrow> angerman: trieify `fmap` mapM (\tab -> query db "select .... from " ++ t ++ " ... group by ...") =<< table db
23:07:35 <Cale> angerman: In my experience, Haskell does really well at combinatorial things...
23:07:44 <mmorrow> angerman: "mapping over a list" ;)
23:08:19 <Cale> Things like scheduling problems and search algorithms are fun to do in Haskell.
23:08:41 <Cale> It's a general purpose language though, and there's not a whole lot it does very poorly at.
23:10:05 <pumpkin_> mmorrow: fail constructing SQL strings :P
23:10:12 <mmorrow> heh
23:10:14 <Luke> Cale: so I need zlib to build cabal but ubuntu repos dont have it...
23:10:16 <dmead_home> lisp needs to die
23:10:23 <dmead_home> don't tell #lisp i said that
23:10:30 <mmorrow> lol
23:10:33 <pumpkin_> how old is everyone?
23:10:40 <dmead_home> 26 as of today
23:10:41 <dmead_home> :<
23:10:43 <Cale> Luke: I think it's one of the things which the bootstrap.sh will download
23:10:48 <Cale> I'm 25.
23:10:50 <Luke> i did but didn't build
23:10:59 <mmorrow> 25
23:11:23 <pumpkin_> now let's come upw ith a scheme for determining the sum of our ages without individually revealing them
23:11:37 <pumpkin_> :P
23:11:47 <Cale> dmead_home: It turns out that the entire Haskell user-base is 25, and when you become 26, you're fated to switch to Epigram. Sorry about that.
23:11:55 <dmead_home> ahh shit
23:12:10 <pumpkin_> I'm only 24, is that why I still have to use matlab? :(
23:12:15 <dmead_home> is that like getting put out to stud?
23:12:25 <Cale> Luke: hmm...
23:12:34 <glguy> pumpkin_, 24 is old enough to make money writing Haskell code ;)
23:12:35 <Cale> Luke: What error do you get?
23:12:46 <Cale> Luke: (building zlib)
23:12:47 <pumpkin_> glguy: but I'm in school
23:12:50 <dmead_home> i get paid to write haskell
23:12:57 <Luke> Cale: I think I need the real zlib
23:13:00 <Luke> getting it now
23:13:02 <Cale> Luke: ah, yes
23:13:16 <pumpkin_> glguy: maybe one day I'll make money on haskell
23:13:25 <Cale> The Haskell package is just a binding.
23:13:35 <pumpkin_> 3 months ago I'd never seen a line of haskell
23:13:44 <pumpkin_> 3 years from now I'll be the world's first haskellionaire
23:13:49 <Cale> The bootstrap.sh could probably do with some work to help the ubuntu users :P
23:14:15 <Luke> haha well its just a matter of understanding whats going on.
23:14:29 <Luke> its unclear to me what i'm supposed to install with the OS vs. this magic script =)
23:14:47 <Sekaino> Thanks everyone for the help the past week or so.  Here's what I was working on if anyone is curious:  http://unboundedoperator.blogspot.com/2009/02/fock-states-take-2.html
23:15:15 <pumpkin_> omg you're 25 too
23:15:17 <pumpkin_> everyone's 25
23:15:22 <Sekaino> :)
23:15:42 <vincenz> Moin
23:15:42 * Japsu is not 25
23:15:55 <pumpkin_> me neither
23:16:01 <Sekaino> And now bed for me.  Feel free to comment and criticize the code; I'm sure I have much to learn.
23:16:59 <raxas> not everyone here is 25, really. I am 45 and wrote my first program in PL/I at age of 14
23:17:00 <vincenz> Any hackage peeps around?
23:17:20 <pumpkin_> vincenz: ask the question, the hackage peeps will poke their heads out if they're around :)
23:17:28 * Xilon is a couple years from 25
23:17:31 <vincenz> pumpkin_: maybe, except I can
23:17:37 <Xilon> Seems like I have time to learn some Haskell :P
23:17:41 <vincenz> pumpkin_: maybe, except I can't pay constant attention here, so it might scroll off omy screen
23:17:56 <vincenz> Ok, the question is rather trivial, how does hackage or cabal find out which version of a dependency you need
23:18:11 <pumpkin_> .cabal files can specify constraints on the versions
23:18:12 <Xilon> vincenz: It's specified in the cabalfile
23:18:23 <vincenz> So you have to figure out the numbers yourself
23:18:26 <pumpkin_> and it'll try to find a solution to the constraints
23:18:28 <mmorrow> defaulting to newest available version if none's specified
23:18:55 <vincenz> This is not when installing, I meant, when creating a cabal-package, how does it figure out which version of the dependencies you list are the minimum/maxium
23:19:08 <vincenz> Or do you specify yourself?
23:19:13 <pumpkin_> you write >=, < for versions
23:19:14 <mmorrow> oh, yeah you have to specify it
23:19:29 <pumpkin_> say your code doesn't work with the base 4 exceptions, write base < 4
23:19:54 <mmorrow> base == 4.*, bytestring < 42, foo >= 3.0.*, ...
23:20:04 <vincenz> So people manually install all those different versions until they find one that works?
23:20:12 <vincenz> Or rather, doesn't work.
23:20:16 <pumpkin_> it'll take care of that for you
23:20:22 <mmorrow> (hopefully)
23:20:54 <mmorrow> don't put unnecessary constraints though
23:21:03 <mmorrow> (wrt version numbers)
23:21:03 <sjanssen> vincenz: the version ranges are usually (potentially) wrong
23:21:20 <mmorrow> yeah, and then cabal-install barfs
23:21:22 <vincenz> You just said you have to specify manually, what if I don't have a later or earlier version of some lib? E.g I only have 6.8.2 installed, how will I know whether I have to write a base < 4 constriant?
23:21:23 <Luke> cabal is pretty awesome
23:21:25 <pumpkin_> sjanssen: are you 25 too?
23:22:01 <sjanssen> vincenz: the best thing to do is to find out the package's version policy and use that to guide the ranges
23:22:05 <sjanssen> pumpkin_: 23
23:22:17 <pumpkin_> sjanssen: omg, WAY below 25
23:22:25 <pumpkin_> :)
23:22:27 <vincenz> sjanssen: I'm planning on writing osmething from scratch, so I only have a single set of packages on my list, and I worry about what constraints I'll have to specify.
23:22:53 * ddarius though sjanssen was older than himself (for no particular reason)
23:23:01 <vincenz> ddarius: wow
23:23:10 <pumpkin_> ddarius: are _you_ 25? :P
23:23:11 <mmorrow> vincenz: probably you don't need any version number constraints unless you know you need them
23:23:16 <ddarius> pumpkin: Not yet.
23:23:19 <vincenz> sjanssen: how are you older than yourself?
23:23:30 <pumpkin_> ddarius: epic sandwiching means you're 24?
23:23:50 <sjanssen> vincenz: let age = age + 1
23:23:59 <vincenz> You're a bottom
23:24:05 <ddarius> sjanssen is fix Succ years old.
23:24:24 <vincenz> pumpkin_: What's with the 25 q?
23:24:37 <pumpkin_> there just seem to be a lot of 25-year-olds in here
23:24:49 <pumpkin_> but as I get more samples it's spreading out a little :)
23:25:03 <Luke> haha
23:25:10 <vincenz> No, it's a typical syndrome people have, there's probably a name for it.  When you watch for something, you tend to see more occurences
23:25:24 <vincenz> Cause negatives are not observed as acutely as positives
23:25:28 <Luke> birthday paradox i guess is similar
23:25:31 <Luke> we could lump it with that
23:25:33 * vincenz nods
23:25:33 <Luke> whatever he has =)
23:25:42 <Luke> "omg everyone has my b-day"
23:25:45 <sjanssen> vincenz: confirmation bias?
23:25:46 <pumpkin_> vincenz: mostly just because Cale and mmorrow responded at the same time, both saying 25
23:25:53 <vincenz> sjanssen: That's probably the name, yes.
23:26:13 <vincenz> sjanssen: are you going to hac?
23:26:29 <Luke> pumpkin_: you're 25 as well?
23:26:33 <pumpkin_> nope, 24
23:26:36 <sjanssen> vincenz: I don't even know where it is
23:26:37 <Luke> ah
23:26:39 <Luke> 23 here
23:26:41 <pumpkin_> I probably sound 14 most of the time though
23:26:44 <Luke> seems were all within 5 years
23:26:45 <dmead_home> guys
23:26:49 <vincenz> sjanssen: utretcht
23:26:56 <dmead_home> is useage of 'when' in lisp considered interation?
23:27:00 <vincenz> sjanssen: it was recently announced.
23:27:08 <ddarius> Luke: Lennart was writing code before a lot of us were born...
23:27:17 <gaze__> haha, I'm 19
23:27:22 <vincenz> sjanssen: It'd be nice to finally meet you.
23:27:28 <sjanssen> vincenz: ah, probably not.  International travel is a bit much for a hackathon
23:27:43 * vincenz nods
23:27:56 <Luke> anyone know if there's much of a haskell community in chicago?
23:28:48 <pumpkin_> Luke: you could drive for a day and come to the CHUG shapr's been putting together :)
23:29:01 <Luke> chug?
23:29:09 <pumpkin_> cambridge haskell user group
23:29:12 <Luke> ah
23:29:17 <Luke> MIT?
23:29:29 <pumpkin_> somewhere around there, can't remember exactly
23:29:45 <Luke> i dont have a car =/
23:29:58 <Luke> nor does anyone I know ironically enough
23:30:09 <ddarius> Hitchhike.
23:30:10 <pumpkin_> ah
23:30:13 <ddarius> You still have time to get there.
23:30:18 <pumpkin_> I don't even drive
23:30:26 <Luke> fiiinally got Yi installed! its so fast!
23:30:33 <pumpkin_> Luke: you could probably hike if you jogged the whole way and left tonight
23:30:45 <Luke> i'll skip =)
23:31:21 <Luke> RWH is everywhere now
23:31:34 <Luke> shouldn't be too long before people want to make a users group around here
23:32:08 * ddarius thinks that he -is- the Haskell community of the city he is in.
23:32:17 <TomMD1> What city?
23:32:22 <ddarius> San Angelo
23:32:33 <Luke> who's "he"?
23:32:54 <pumpkin_> Luke: you speak of yourself in the third person in /me messages :P
23:33:04 <pumpkin_> *one speaks of oneself
23:33:07 <pumpkin_> ;)
23:33:33 * TomMD is worried that might confuse him.
23:33:45 <Luke> ooh I didn't catch the /me at a glance =)
23:33:46 <Luke> oops
23:34:11 <Luke> Yi is amazing. you guys use Yi?
23:34:16 <TomMD> Humm, that sounded funny in my head, but insulting in IRC.  Don't be insulted.
23:34:32 <Luke> me?
23:34:58 <TomMD> yeah, I was trying to refer to myself as possibly being confused, but it could be interpreted as insulting you.
23:36:41 <Luke> oh no worries =)
23:36:50 <Luke> can someone explain what $ is?
23:36:58 <glguy> ?src ($)
23:36:58 <lambdabot> f $ x = f x
23:37:11 <TomMD> Its typically used as a replacement for parens  ( )
23:37:26 <TomMD> Its a low priority infix operator that is just identity.
23:37:36 <Luke> dif than (.) ?
23:37:42 <glguy> ?src (.)
23:37:43 <lambdabot> (f . g) x = f (g x)
23:37:49 <TomMD> ex: you often see...
23:37:50 <TomMD> return $ someCalc $ otherCalc $ data
23:37:54 <Luke> i'm reading the :info but dont know how their explained
23:38:11 <TomMD> Which means: return (someCalc (otherCalc data))
23:38:16 <glguy> (.) takes two functions, and turns them into one
23:38:17 <TomMD> in effect.
23:38:43 <Luke> (.) nests the functions
23:38:45 <Luke> right?
23:39:16 <glguy> yeah. usually we say it "composes" them
23:39:22 <Luke> yeah
23:39:30 <Luke> so how is ($) described then?
23:39:38 <vincenz> pumpkin_: for another data point, I'm 29
23:39:39 <glguy> it is application
23:39:46 <pumpkin_> vincenz: aha!
23:39:50 * pumpkin_ jots down more ages
23:39:55 <Luke> how does ($) differ from normal function application?
23:40:05 <vincenz> Luke: fixity
23:40:09 <glguy> lower priority
23:40:13 <Luke> ah
23:40:21 <glguy> a b c -> (a b) c
23:40:23 <Luke> right assoc with 0 priority
23:40:26 <glguy> a $ b c -> a (b c)
23:40:26 <TomMD> so f $ g x  == f (g x)
23:40:27 <TomMD> while f g x = (f g) x
23:40:50 <glguy> a b $ c -> (a b) c
23:41:03 <glguy> now you can pick your answer ;)
23:41:09 <Luke> haha interlaced
23:41:13 <pumpkin_> a $ b $ c = a (b c) too, just for more information
23:41:26 <glguy> pumpkin_ for the steal!
23:41:42 <Luke> does the order of op in the fixity even matter or is it mainly used for its right associativity?
23:41:50 <pumpkin_> Luke: but people don't typically write multiple $ in the same expression
23:41:57 <pumpkin_> glguy $_$
23:42:02 <TomMD> Unless you are an ugly coder like me.
23:42:12 <glguy> pumpkin_, that's a matter of taste
23:42:20 <Luke> does the order of op in the fixity even matter or is it mainly used for its right associativity?
23:42:33 <Luke> i guess that doesnt make sense
23:42:39 <pumpkin_> Luke: also, as $ is an operator, you can use it to apply a function to a fixed parameter, as in map ($ 2) [(+1), (^2)]
23:42:53 <Cale> Luke: It's mainly used for its fixity.
23:42:59 <Luke> thanks
23:43:03 <TomMD> I see two styles fairly often:
23:43:04 <TomMD> f $ g $ h x
23:43:04 <TomMD> f . g . h $ x
23:43:08 <glguy> > sequence [(+1),(^2)] 2
23:43:09 <lambdabot>   [3,4]
23:43:14 <Luke> RWH just started using it without defning it's use =)
23:43:23 <Cale> Luke: That is, the fact that it binds weakly to its parameters is the most important bit
23:43:39 <Luke> right
23:43:46 <Luke> thanks guys
23:44:02 <TomMD> Enjoy the book!
23:44:26 <Luke> main = yi $ defaultConfig {...}
23:44:43 <Saizan> i asked for a pony and i got a an unicorn..
23:44:45 <Cale> Composition is considered nicer than $ because, for example, in the above expressions TomMD gave,  g . h  is going to be well-typed on its own, while  g $ h  is not.
23:44:55 <pumpkin_> Saizan: that sucks
23:44:57 <Cale> Saizan: hehe, I noticed the same.
23:44:58 <Luke> why use it in this case? so the record syntax gets associated to defaultConfig first?
23:44:59 <glguy> a unicorn *
23:45:03 <pumpkin_> you should get a narwhal in stead
23:45:06 <TomMD> so there is a configuration variable 'defaultConfig'.  Some of the defaults are being altered { ... } and then yi is called with that config.
23:45:08 <pumpkin_> *instead
23:45:14 <glguy> Luke, it isn't necessary there, afaik
23:45:31 <Luke> k
23:45:32 <glguy> record syntax binds very tightly
23:45:41 <Luke> thought so
23:45:42 <Cale> Relatedly, (.) is associative, while ($) isn't.
23:45:42 <Luke> ok cool
23:46:04 <Cale> that is, f . (g . h) = (f . g) . h
23:46:20 <Luke> interesting
23:48:29 <Gracenotes> well... (f . g) doesn't really *do* anything. It just waits for an argument for g to come along :) awww.
23:48:59 <pumpkin_> how about (f .) . (. g)
23:49:28 <Gracenotes> second of three arguments
23:49:47 <pumpkin_> I like to call it sandwich
23:50:02 <Luke> afk
23:54:56 <augustss_> I like to eat sandwich
23:55:15 <pumpkin_> u can haz cheezburger
23:55:55 <mmorrow> lol
23:59:34 <lifflander> Hey everyone.
23:59:51 <lifflander> I am writing a program that has a REPL for the interface.
