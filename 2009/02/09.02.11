00:00:51 <cjs> So what does "SYSTEM" mean as a cost center when doing retainer profiling?
00:04:19 <k-zed> hulloh
00:04:33 <k-zed> does control.concurrent.chan store more than one value?
00:04:40 <k-zed> (will the write operation ever block?)
00:05:37 <k-zed> also, is there any other solution for the blocking isEmptyChan problem than spinwaiting instead of readchan?
00:11:24 <mib_47q3bc37> @pl \t1 t2 p -> sameAtRoot (subtermAt t1 p)(subtermAt t2 p)
00:11:24 <lambdabot> (. subtermAt) . ap . (sameAtRoot .) . subtermAt
00:15:14 <mib_47q3bc37> @pl \v1s v2s -> (lenght v1s) == (length v2s)
00:15:14 <lambdabot> (. length) . (==) . lenght
00:21:01 <ski_> > mdo x <- [1..y]; y <- [1..3]; return (x,y)
00:21:02 <lambdabot>   * Exception: stack overflow
00:25:23 <beelsebob> mib_47q3bc37: you're looking for `on` I think
00:25:33 <beelsebob> (==) `on` length
00:35:35 <mib_47q3bc37> @pl \ r1 i -> ((lhs r1) !! i)
00:35:35 <lambdabot> (!!) . lhs
00:38:22 <mib_47q3bc37> beelsebob: Thanks
00:47:00 <redditbot> Kudos to Bodo : fixing Turbinado
00:52:49 <mib_x30j6nc8> @pl (\r1 r2 -> compareAtPos p (frag r1) (frag r2))
00:52:49 <lambdabot> (. frag) . compareAtPos p . frag
00:53:04 <byorgey> in the Haddock docs for Monad: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
00:53:08 <byorgey> it lists 'Monad [::]' as an instance.  What the heck is [::]?  Is it something I don't know about, or a Haddock bug?
00:53:14 <beelsebob> (compareAtPos p) `on` frag -- this mib_x30j6nc8
00:53:30 <byorgey> seems that would be a parse error.
00:54:23 <ziman> isn't it a data parallel array?
00:54:46 <Itkovian> @paste
00:54:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:55:17 <Itkovian> The url is not right, it seems. should be http://hpaste.org/fastcgi/hpaste.fcgi/new I guess.
00:55:38 <beelsebob> oh, how come the old hPaste died?
00:55:57 * beelsebob doesn't like the new one at all
00:59:34 <thoughtpolice> it's now using the hpaste2 code
00:59:52 <thoughtpolice> i don't know why it really died though :/ who owned the domain? glguy?
01:01:18 <beelsebob> its syntax highlighting is rather garish to say the least
01:01:44 <jeffz`> I think I remember there was some advanced warning of its death and some pastes were mirrored.
01:06:39 <Itkovian> Can anybody help me figure out why the code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1345#a1345 runs for argument 113000 but not for 115000 (or not within a decent memory limit > 2GB)? The code solves (or tries to) the EUler project #14, where you figure out the length of the chain of integers starting with n and evolving through n_new = n/2 if n even else 3n+1
01:07:18 <Itkovian> I thought of saving the chain lengths for any n < k, where k should have been 100000, but that does not seem plausible anymore.
01:10:42 <byorgey> ziman: aha, that must be it, thanks =)
01:10:49 <cads> > length $ filter ((x,y) -> (gcd x y) == 1) [(12,17),(13,16),(14,15),(15,14),(16,13),(17,12)]
01:10:50 <lambdabot>   <no location info>: parse error on input `->'
01:10:57 <cads> > length $ filter (\(x,y) -> (gcd x y) == 1) [(12,17),(13,16),(14,15),(15,14),(16,13),(17,12)]
01:10:58 <lambdabot>   6
01:11:07 <cads> > length $ filter (\(x,y) -> (gcd x y) == 1) [(29,17),(29,16),(29,15),(29,14),(29,13),(29,12)]
01:11:08 <lambdabot>   6
01:11:20 <cads> shablazm!
01:12:07 <cads> someone told me of this awesome theorem: gcd(a + k, b - k) = gcd(a+b, b-k)
01:12:51 <byorgey> cads: sure, that follows from the more general result that  gcd(x,y) = gcd(x+y,y)
01:13:12 <byorgey> which is why the euclidean algorithm works
01:14:31 <cads> I think I need to get a schaum's outline on all this, I'm sadly missing intuition here
01:15:07 <byorgey> cads: http://www.mathlesstraveled.com/?p=102
01:15:18 <cads> I wrote a program that needed to count the number of coprime pairs in a list like the above, but with on the order of one billion elements
01:16:03 <cads> and it dies badly
01:17:06 <byorgey> yikes
01:17:50 <alc> are the pairs in the list totally random?
01:18:09 <cads> Given natural numbers 0 < a < b, for 0 <= k < b-a, lets define a sequence X as X(k) = (a+k, b-k).
01:18:22 <alc> you can use Stern-Brocot tree to generate all coprime pairs <= a limit
01:18:47 <cads> > let list a b = [(a+b ,b-k) |k <- [0..b-a]] in list 10000 100000000
01:18:48 <lambdabot>   [(100010000,100000000),(100010000,99999999),(100010000,99999998),(100010000...
01:19:35 <cads> alc, I saw something about the probability of two random numbers being coprime, and I think this is simpler than that analysis
01:19:58 <cads> > let list2 a b = [(a+k ,b-k) |k <- [0..b-a]] in list 10000 100000000
01:19:59 <lambdabot>   Not in scope: `list'
01:20:03 <cads> > let list2 a b = [(a+k ,b-k) |k <- [0..b-a]] in list2 10000 100000000
01:20:04 <lambdabot>   [(10000,100000000),(10001,99999999),(10002,99999998),(10003,99999997),(1000...
01:20:54 <cads> I just need to count the coprime pairs in lists in the forms of what either list a b or list2 a b give us
01:22:22 <cads> byorgey: I was wondering if i could use the fact that one of the arguments to GCD stays the same, to make an algorithm that efficiently GCDs a number agains a long list of numbers
01:22:52 <Gracenotes> @seen lambdabot
01:22:52 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
01:22:52 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, #macosx, ##freebsd, #gentoo-uy, #gentoo-
01:22:52 <lambdabot> haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
01:22:57 <Gracenotes> -.-
01:23:30 <byorgey> cads: hmm... I don't know, off the top of my head it seems like you can't do any better than just running the Euclidean algorithm for each pair.
01:24:41 <cads> byorgey: normally we'd use the euclidian algorithm for gcd because it doesn't require factoring, but I'm betting that in the case of doing the equivalent map (gcd x) [a..b], having x's factors would be helpful
01:25:09 <byorgey> cads: alc's suggestion is a good one, often in situations like this you want to figure out a way to generate the things you're interested in directly, rather than filtering them from a larger list.
01:25:41 <byorgey> cads: it would be helpful if you had the factors of all the [a..b].
01:26:00 <byorgey> the Euclidean algorithm is quite fast though.
01:26:32 <byorgey> I don't think you'll get far just trying to optimize that computation itself, you need to optimize on a much larger scale.
01:27:05 <cads> I feel that way too
01:27:09 <k-zed> i think i did one of the projecteuler problems that involved factorization
01:27:14 <k-zed> by using prime factorization, which was faster
01:27:19 <k-zed> then using permutations.
01:27:42 <k-zed> (but then i know nothing about math :)
01:29:00 <quicksilver> It is faster to use prime factorisation techniques for n-way gcd, afaik.
01:29:10 <quicksilver> if n is sufficiently large
01:29:42 <cads> well, I've got a program that ought to solve project euler problem 202, and man it was too much work to derive for me not to be able to run it because it takes too long. I reduced it from a nightmare seeming problem of geometry into a simple  list and count and gdc, and it's funny that this is where I'm stuck
01:30:52 <cads> quicksilver: that's what my gut tells me, but I'm really out of my element where it comes to this
01:31:34 <quicksilver> if you are a competent programmer, project euler is a mathematics task, not a programming one.
01:31:43 <quicksilver> most of the problems have naive solutions which are infeasibly slow
01:31:50 <quicksilver> and you have to think to find a clever algorithm.
01:32:24 <k-zed> so far i used projecteuler to get into some rough acquaintance with haskell
01:32:30 <cads> for this problem my cleverness was spent in coming up with a clever representation to work in :D
01:32:35 <k-zed> is there any kind of problem collection that's more about programming tasks?
01:35:15 <cads> quicksilver, http://pastebin.com/m76316181 ,  corresponding to http://projecteuler.net/index.php?section=problems&id=202
01:36:06 <cads> I think it must be that it's such a high number, the cleverness needed to turn the problem into one of number theory is not enough :)
01:36:41 <cads> one must be clever enough to reduce that problem in turn
01:36:47 <byorgey> k-zed: sure, try spoj.pl
01:37:42 <cads> alc, I'll see what I can do with a stern-brocot tree
01:41:43 <byorgey> is MonadZero imaginary, or did it really exist at some point in Haskell's history?
01:42:52 <ivanm> @go MonadZero
01:42:53 <lambdabot> No Result Found.
01:43:03 <ivanm> byorgey: well, lambdabot sure doesn't know... >_>
01:44:14 <doserj> it was in Haskell 1.4 I think
01:45:30 <doserj> http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/standard-prelude.html#$tMonadZero
01:48:44 <blathijs> Is it impossible to use partial application on (data) types? I'm trying something like "data Foo a b = ..." and then "instance Applicative (Foo a) where ..."
01:49:27 <blathijs> But that gives 'Foo is not applied to enough type arguments'
01:50:06 <blathijs> but if I do "instance Applicative (Foo a b)", I get Expected kind `* -> *', but `Foo a b' has kind `*'
01:50:22 <blathijs> which seems to make sense, but I'm not sure how to make this work like I want it to
01:50:51 <ivanm> I thought it was... maybe you need an extension for it though :
01:50:53 <ivanm> :s
01:51:03 <ivanm> blathijs: try "instance Applicative (Foo a) b where ... "
01:51:34 <blathijs> Nope: Kind error: `Applicative.Applicative' is applied to too many type arguments
01:51:46 <doserj> blathijs: it works for me. can you show your exact code?
01:51:47 <ivanm> hmmmm.......
01:51:50 <ivanm> @src Applicative
01:51:50 <lambdabot> class Functor f => Applicative f where
01:51:50 <lambdabot>     pure  :: a -> f a
01:51:50 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
01:52:03 <ivanm> blathijs: have you made (Foo a) a Functor?
01:52:07 <byorgey> blathijs: maybe you need to enable -XFlexibleInstances ?
01:52:27 <byorgey> instance Applicative (Foo a) ought to work
01:52:30 <doserj> no extensions needed
01:52:38 <blathijs> It works for "instance Applicative ((->) a)", and I'm trying to do something similar to that (but with different semantics)
01:52:57 <byorgey> blathijs: can you paste your code somewhere?
01:53:53 <blathijs> http://pastebin.com/ma0a0a8b
01:55:10 <ivanm> blathijs: you need a Functor instance...
01:55:11 <blathijs> ivanm: No, I haven't made (Foo a) a Functor
01:55:18 <doserj> blathijs: you can't flip the order of the type arguments
01:55:22 <blathijs> Which might be the problem (though the error is confusing)
01:55:26 <ivanm> well, you have to ;-)
01:55:36 <ivanm> @src Applicative
01:55:36 <lambdabot> class Functor f => Applicative f where
01:55:36 <lambdabot>     pure  :: a -> f a
01:55:36 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
01:55:45 <ivanm> blathijs: ^^ you need to make it a Functor first
01:56:01 <ivanm> but what doserj says appears to be the main problem
01:56:13 <doserj> blathijs: try data PassState s x = ... instead
01:56:40 <quicksilver> I don't immediately see why blathijs is getting a kind error though
01:57:23 <blathijs> doserj: That didn't help :-) I would expect the type flipping to only affect the semantics, not cause these errors..
01:57:42 <blathijs> doserj: Perhaps give type errors in the definition of <*>
01:57:57 <quicksilver> I get all kinds of errors from blathijs's code
01:58:01 <doserj> blathijs: well, I get type errors with your definition
01:58:02 <blathijs> Lemme try making PassState s a Functor
01:58:04 <quicksilver> but certainly I don't get a "kind error" like he pasted.
01:58:14 <ivanm> well, I'm getting a Functor error, a type inference error and an infinite type error when using your code
01:58:19 <ivanm> definitely not a kind error...
01:58:25 <blathijs> I'll extract the code in a seperate file, hang on
01:58:27 <quicksilver> I get (1) occurs check (2) a Functor error and (3) a type check failure
01:58:39 <ivanm> blathijs: I presume you're doing a qualified import of Control.Applicative?
01:58:57 <doserj> blathijs: check what kind of Applicative is in scope
01:59:07 <ivanm> quicksilver: I don't get (1), but I get an inference error
01:59:14 <blathijs> Funky, now I get Could not deduce (Functor (PassState s)) from the context ()
02:00:04 <blathijs> with http://pastebin.com/m6d0586bf
02:00:53 <ivanm> blathijs: why do you use such a long qualification (rather than just "... as A" for example)?
02:00:55 <doserj> blathijs: that's only one of the errors we get
02:01:20 <blathijs> I also get  Occurs check: cannot construct the infinite type: s = s -> (s, a)
02:01:25 <blathijs> but this is something I can work with
02:01:25 <ivanm> yup
02:01:27 <ivanm> @src Functor
02:01:27 <lambdabot> class  Functor f  where
02:01:27 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
02:01:33 <ivanm> blathijs: ^^ you need that
02:01:34 <blathijs> lemme try adding all the imports from my original file
02:02:02 <ivanm> don't forget, Haskell is magic (at least, not yet.... give dons, etc. a few more years...) ;-)
02:03:17 <blathijs> Seems it's not broken by the imports directly
02:03:25 <cads> > [2002939859..4005879716]
02:03:26 <lambdabot>   [2002939859,2002939860,2002939861,2002939862,2002939863,2002939864,20029398...
02:03:51 <cads> > length [2002939859..4005879716]
02:04:06 <lambdabot>   thread killed
02:04:33 <blathijs> Ah, this gives the kind errors: http://pastebin.com/m75da4c97
02:04:51 <blathijs> doh
02:05:01 <blathijs> I should have paid more attention to the line numbers :-S
02:05:17 <cads> would be neat if haskell knew enough to know that I just created that from a simple sequence [a..b] and so has length b-a
02:06:08 <Toxaris> cads: I think you could add that as a ghc RULE, but does it really show up in reality?
02:06:39 <Toxaris> cads: note that it works only for some types
02:06:46 <Toxaris> > length [False .. True]
02:06:47 <lambdabot>   2
02:06:53 <Toxaris> > True - False
02:06:54 <lambdabot>       No instance for (Num Bool)
02:06:54 <lambdabot>        arising from a use of `-' at <interac...
02:07:13 <Toxaris> > length [1.1 .. 2.0]
02:07:14 <lambdabot>   2
02:07:16 <cads> yeah, I don't think it would be very important
02:07:21 <Toxaris> > 2.0 - 1.1
02:07:22 <lambdabot>   0.8999999999999999
02:07:26 <quicksilver> > let (^-^) = (-) `on` fromEnum in True ^-^ False
02:07:27 <lambdabot>   1
02:07:32 <quicksilver> I win!
02:07:56 <quicksilver> although the length of [a..b] is b-a+1, in discrete Enums.
02:08:11 <cads> hrm
02:08:25 <blathijs> ivanm: doserj: quicksilver: byorgey: Thanks for the pointers, I think I should be able to solve it from here :-)
02:08:44 <cads> maybe future systems will understand all of that, and apply the correct math where the human skill is lacking
02:08:54 <doserj> > length ([1..10]::[Data.Fixed.Fixed Data.Fixed.E6])
02:08:55 <lambdabot>   9000001
02:09:05 <doserj> but that is broken anyways...
02:09:33 <Toxaris> well, a RULE should be correct even for broken typeclass instances imho
02:10:26 <Toxaris> or it should come with the typeclass, so that it can be considered part of its semantics
02:11:30 <cads> right now I'm envisioning a program that will sieve [2002939859..4005879716]  against 5,  11, 17, 23, 29, 41, 47.... that's something like two billion elements which will be reduced by something like 400 million elements in the first pass, and not much less in subsequent passes
02:12:17 <cads> that is, I have those 7 primes to sieve against, then the problem's done, but I don't know how long that will take
02:12:41 <cads> do you guys think it should work pretty quickly?
02:14:31 <beelsebob> how long do ~10 billion divisions and comparisons take on your machine?
02:15:24 <cads> probably much faster than 2 billion GCDs which I was performing before
02:15:49 <cads> I am optimistic
02:15:56 <beelsebob> sounds plausable to me
02:16:14 <wli> Maybe try sieving against a product of Fermat primes so that a power-of-two-sized wheel is bitmappable without internal fragmentation.
02:17:24 <Twey> What does it mean when I try to install a package and am greeted with:
02:17:31 <Twey>     Could not find module `Data.Generics':
02:17:31 <Twey>       it is a member of package base-3.0.3.0, which is hidden
02:17:44 <Twey> ?  I can import Data.Generics fine from GHCi
02:17:51 <NameAlreadyInUse> what sort of performance can i expect from the lookup function?
02:17:59 <cads> wli, I hope I don't have to get so fancy :)
02:18:08 <wli> phi(2^(2^n)+1) = 2^(2^n) when 2^(2^n)+1 is prime, so the bitmap ends up nicely power-of-two-sized.
02:18:25 <Twey> NameAlreadyInUse: O(n)
02:18:31 <Twey> If you need better, use Data.Map
02:18:44 <lilac> blathijs: your (<*>) is quite wrong
02:18:46 <beelsebob> NameAlreadyInUse: which lookup function?
02:19:24 <blathijs> lilac: In what way?
02:19:45 <blathijs> ah, yes
02:19:49 <lilac> blathijs: <*> takes a function inside the Functor and a value inside the Functor
02:19:56 <lilac> blathijs: you're treating the function as if it were outside
02:20:04 <beelsebob> no he's not
02:20:08 <beelsebob> it's inside a PassState
02:20:08 <blathijs> lilac: Yeah, I see that its wrong, thanks
02:20:22 <beelsebob> oh, yes he is
02:20:22 <beelsebob> >.<
02:20:47 <blathijs> uh, wait
02:20:51 <NameAlreadyInUse> beelsebob: the one called lookup
02:20:54 <cads> wli, where would I read about using such bitmapped structures in haskell? Things I know for the most part are safely boxed in haskell goodness
02:21:00 <beelsebob> NameAlreadyInUse: the one in the Prelude?
02:21:04 <NameAlreadyInUse> yeah
02:21:12 <beelsebob> then yeh, what Twey said
02:21:15 <lilac> blathijs: you need to decide whether you run your state through 'f' or 'x' first
02:21:17 <beelsebob> O(n)
02:21:21 <NameAlreadyInUse> oh ok, that is a shame
02:21:23 <beelsebob> use Data.Map if you want to look stuff up
02:21:25 <wli> > 2^(32 :: Int) - product [2^(2^n :: Int)+1 :: Integer | n :: Int <- [0..4]]
02:21:26 <lambdabot>   1
02:21:30 <alc> cads, i see.  your problem is like this: given 0 < a < b, find how many x in the range [a..b] thats coprime to a+b
02:21:30 <NameAlreadyInUse> yeah, i will look into Data.Map
02:21:33 <Twey> NameAlreadyInUse: It's not meant for serious usage
02:21:34 <lilac> blathijs: or whether you want to provide the same state to both, and discard one of them
02:21:37 <beelsebob> linked lists are not good for random lookups
02:21:51 <Twey> It's just handy when you have a few items and want to select one based on input
02:22:23 <NameAlreadyInUse> beelsebob: yeah, i know, but i assumed there might be some voodoo that occurs
02:22:29 <beelsebob> nope
02:22:32 <beelsebob> it's a linked list
02:22:34 <Twey> E.G. a calculator â€” (("+", (+)), ("-", (-)), ("/", (/)), ("*", (*)))
02:22:41 <Twey> Er, []
02:22:47 <lilac> blathijs: something like: PassState f <*> PassState x = PassState (\s -> let (s', f') = f s; (s'', x') = x s' in (s'', f' x'))
02:22:51 <alc> cads, since a+b is fixed. first factorize it and use Inclusion-exclusion principle.
02:23:19 <cads> alc, that's it exactly. For my large a+b I've been able to calculate the prime factors, so I'm going to filter the list according to those
02:24:04 <cads> alc, I grok that we've just said the same thing :)
02:24:09 <blathijs> lilac: That's exactly what I meant to write :-)
02:25:14 <alc> define a function f(n,a) which returns how many numbers <= a thats coprime to n.  the final answer is f(a+b,b) - f(a+b,a-1).
02:25:42 <alc> use inclusion-exclusion principle to calculate f(n,a)
02:26:17 <wli> cads: There's not much special about it. A block of 32768 bits is 4KB, then you just need a table for each bit offset into a 4KB block so that block i, bit j represents 65535*i + a ! j
02:27:26 <wli> cads: You probably want to optimize 65535*i into bit shifting and subtraction, i.e. shiftL i 16 - i + a ! j
02:28:10 <cads> alc, wli, my brain is explode :)
02:28:29 <cads> thanks for the help :)
02:29:36 <cads> alc, I'll try to apply the principle
02:30:13 <cads> wli, I'll soon look into low level bit-twiddling type details in haskell, it would be a good tool to have
02:30:39 <wli> cads: Your table looks something like let t = product [2^(2^n :: Int) + 1 :: Integer | n :: Int <- [0..3]] in take 99 . show . array (1,32768) $ zip [1 :: Int ..] [k | k <- [1..t-1], k `gcd` t == 1]
02:30:55 <cads> all, thanks for the help and open ears
02:31:40 <cads> wli that is nuts!
02:32:31 <wli> cads: Well, the idea is that you avoid examining all the things divisible by any of the first 4 Fermat primes.
02:33:23 <wli> cads: You can do similar, albeit with some internal fragmentation and maybe some expensive divisions, by using the first several primes like 2,3,5,7,11, etc.
02:33:39 <cadZZzZ> yeah, im a little familiar with those wierd spiral sieves
02:34:01 <cadZZzZ> I'll review this convo after some desperately needed sleeps :)
02:34:04 <cadZZzZ> goodnight all
02:34:35 <wli> Also, compressing the sieve state by cramming it into bitmaps is good for cache efficiency.
02:42:12 <hackage> Uploaded to hackage: CLASE 2009.2.11
02:46:32 <paolino> why is referential transparency considered a feature ?
02:46:43 <paolino> I always forget
02:46:59 <Botje> no worries about other code stomping on your variables
02:48:31 <paolino> I guess it has not much to do with reassignment of variables
02:48:47 <doserj> paolino: it makes reasoning about your code, and refactoring your code easier
02:54:43 <wli> 2*3*5*7*11*13*17 seems to yield 97% residency with 510510 coprime elements in a 0.5Mbit = 64KB block.
02:55:23 <wli> It'd have to be one heck of a sieving problem for that to be worth it.
02:55:57 <wli> (This is a wheel based on 2,3,5,7,11,13,17.)
02:59:24 <wli> Woops, it's through 29.
02:59:35 <wli> Never mind, 11 does well.
02:59:54 <paolino> doserj: and once it's proved the code is correct ?
03:00:13 <wli> That's 64B, either a cacheline or half of one these days.
03:00:34 <wli> 480/512 bits, 93.75% residency.
03:02:07 <doserj> paolino: it is easier to adapt you code to new requirements
03:02:59 <doserj> paolino: it is also claimed that it is easier for the compiler to reason about your code, and optimize it.
03:03:58 <paolino> doserj: if I have a function from a -> b, referentially transparent, and my code just works, I want to substitute it with one more efficient but not transparent, what I lose doing it ?
03:04:39 <wli> 480*x = 32*15*x = shiftL (shiftL x 4 - x) 5 = shiftL x 9 - shiftL x 5
03:04:57 <tibbe> @type flip
03:04:58 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
03:04:58 <ski_> if the other's not referentially transparent, how can it be equivalent to the former one ?
03:05:46 <wli> A table of 480 Int's (in fact you probably want to use Word16's and promote) isn't bad at all.
03:05:52 <alc> @tell cads http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1346
03:05:52 <lambdabot> Consider it noted.
03:06:02 <tibbe> isn't (flip f a) === (`f` a) ?
03:06:14 <quicksilver> yes.
03:06:17 <paolino> ski_: say f: a -> [b] and code is \k -> find k $ f x
03:07:21 <paolino> I can substitute f with g even f g is not f
03:07:30 <tibbe> @type sizeOf
03:07:31 <lambdabot> Not in scope: `sizeOf'
03:07:31 <paolino> even if
03:07:44 <tibbe> @type Foreign.Storable.sizeOf
03:07:45 <lambdabot> forall a. (Foreign.Storable.Storable a) => a -> Int
03:08:01 <wli> So basically block i, bit j where 0 <= j < 480 is shiftL x 9 - shiftL x 5 + a ! j where a = array (0, 479) [k | k <- [1..2*3*5*7*11-1], k `gcd` (2*3*5*7*11) == 1]
03:08:46 <wli> Then you've got a nicely bitmapped wheel and can sieve larger ranges.
03:08:49 <doserj> paolino: you cannot substitute f with g everywhere (else g would be referentially transparent)
03:09:00 <ski_> paolino : oh, you substituting a *use* of a function .. that's another thing
03:09:43 <doserj> paolino: so everywhere you have an f, you have to check whether you can use g there.
03:10:11 <Twey> paolino: It makes your code make sense.
03:11:28 <paolino> doserj: I suppose it's not rare, specially if you use it in one only place
03:13:14 <tibbe> is a CPP pragma required for files include (#peek ...) constructs from hsc?
03:13:29 <tibbe> and #include statements
03:14:07 <paolino> and, this will happen very often if someone write concurrent code for a computation
03:14:23 <ski_> "this" being ?
03:14:42 <bobshush> @paolino: One example: lets say you have some function f, and lets say for some reason f(47) is evaluated frequently. IF my code is referentialy transparent, I can save the results of f(47) and just use that value instead of evaluating it each time.
03:14:43 <lambdabot> Unknown command, try @list
03:14:52 <jeffz`> tibbe, you preprocess such stuff with hsc2hs
03:15:25 <bobshush> paolino: If my code is not referentially transparent, f(47) might have state, which necesitates that it be evaluated each time it is called.
03:15:55 <bobshush> this can be a problem if f(47) is computationally intensive
03:16:24 <Twey> Â« Could not find module `Data.Generics': it is a member of package base-3.0.3.0, which is hidden Â»
03:16:28 <tibbe> jeffz`: so there won't be any # left right? that's what I thought but then I saw someone add a CPP pragma to such a file
03:16:39 <Twey> That's when trying to install happs-tutorial with Cabal
03:17:23 <Twey> If I install syb, I get s/base-3\.0\.3\.0/syb/
03:17:25 <paolino> bobshush: this is a the optimizing problem, then it cannot defeat conceptually an optimising request on  non transparency
03:17:36 <bobshush> The haskell way is to enforce referential transparency as much as possible so that the compiler can reason about code, and allow foreign function calls if performance is absolutely critical.
03:18:14 <lilac> paolino: if f is referentially transparent, and it's a legal optimization to replace f with g or g with f wherever either of them appears, then g is referentially transparent also
03:18:15 <bobshush> This allows for better automated reasoning, and chances are the compiler is better at it than you.
03:18:28 <pejo> paolino, I didn't understand your last thing?
03:18:40 <doserj> Twey: either fix the dependency to use base-3, add a dependency for syb
03:18:48 <doserj> *or add
03:18:56 <paolino> bobshush: I understand that
03:19:06 <Twey> doserj: How do I do that?
03:19:23 <Twey> I've installed syb now
03:19:40 <Twey> But it gives me the same error, but with 'syb' instead of 'base-3.0.3.0'
03:19:44 <paolino> pejo I want to substitute f with g because g optimizes f
03:19:52 <Twey> I can import Data.Generics from GHCi fine.
03:19:53 <doserj> for example, edit the .cabal file and add syb to the build-depends line
03:20:28 <lilac> paolino: in what way is g not referentially transparent?
03:21:08 <pejo> paolino, anyways, things like Supero is pretty much "impossible" with an impure language.
03:21:14 <paolino> pejo: then I cannot care what the compiler wants, for it's optimizations, if they are not better than mine
03:21:40 <lilac> paolino: i'm having a hard time imagining how g could not be referentially transparent if it's safe and correct to substitute g for f
03:22:01 <lilac> do you have an example?
03:22:08 <paolino> because g has a multithread core which cannot reproduce its evolution
03:22:25 <lilac> multithreaded code can be referentially transparent
03:22:33 <paolino> only can
03:22:52 <bobshush> an example that probably illustrates this better: lets say I have 2 functions, f:: a -> [b] and g:: [b]-> a, and the value I am interested in is f(g(x)) If g is referentially transparent, I can rewrite the code so that the [b] value is never created, thus improving memory efficiency.
03:23:08 <bobshush> 'cannot reproduce its core' -> Is the hardware unreliable?
03:23:09 <lilac> paolino: it sounds like your 'g' probably /is/ referentially transparent
03:23:22 <bobshush> *evolution
03:23:39 <paolino> threads are unreliable on sequencing
03:23:57 <lilac> that's irrelevant unless it causes 'g' to produce nondeterministic results
03:24:07 <bobshush> Not if the values I'm trying to get out of them have no state.
03:24:17 <paolino> lilac it does
03:24:25 <Cthulhon|> :t (uncurry min) &&& (uncurry max)
03:24:25 <Cthulhon|> lambdabot doesn't like me.
03:24:26 <lambdabot> forall a. (Ord a) => (a, a) -> (a, a)
03:24:35 <Cthulhon|> > (uncurry min) &&& (uncurry max) $ (3,2)
03:24:36 <lambdabot>   (2,3)
03:24:45 <paolino> lilac : aside parMap and other simple boxes
03:25:04 <lilac> paolino: if 'g' produces nondeterministic results, how can it be correct to replace a call to a referentially-transparent 'f' with a call to 'g'?
03:25:05 * Twey thinks curry and uncurry should be in Control.Arrow
03:25:07 <pejo> paolino, if therads are unreliable on sequencing you haven't done proper locking, and in that case the outcome of your program is pretty much random.
03:25:36 <paolino> pejo, this is obviously an insult :)
03:25:48 <lilac> adding nondeterminism is /not/ a correct optimization!
03:26:25 <Cthulhon|> Well, it works.
03:26:25 <Cthulhon|> Despite lambdabot.
03:26:50 <paolino> lilac: I made an example ï»¿say f: a -> [b] and code is \k -> find k $ f x
03:27:33 <paolino> pejo, aside humor, I claimed g replaces f in it's semantic and logic
03:28:07 <Cthulhon> :t id
03:28:08 <lambdabot> forall a. a -> a
03:28:30 <lilac> paolino: ok, so you replace 'f' with a 'g' which computes the 'b's in parallel?
03:28:31 <Cthulhon> There, now lambdabot likes me.
03:28:50 * wli golfs a true Eratosthenes.
03:28:52 <paolino> lilac: why parallel
03:28:54 <pejo> paolino, finding that out in general is really hard though. If you don't have side effects in your code the problem becomes a whole lot easier.
03:29:05 <lilac> paolino: i'm guessing what your example is. perhaps you'd like to finish it?
03:29:24 <paolino> pejo, sure it doesn't
03:30:08 <lilac> paolino: does 'g' have side-effects? does it always produce the same answer for the same input?
03:30:16 <bobshush> paolino: Does g return values in the same order as f?
03:30:34 <paolino> bobshush: no
03:30:52 <paolino> lilac: side effects, where ?
03:31:02 <lilac> paolino: that's what i'm asking you!
03:31:22 <paolino> it doesn't produce same answers on same input, no
03:31:24 <bobshush> why am I replacing f with g then?
03:31:38 <lilac> bobshush: it's not an optimization
03:31:40 <paolino> because g is scaling multicore
03:31:52 <lilac> it's a more efficient implementation of the same algorithm
03:32:05 <paolino> lilac: yes
03:32:15 <lilac> nonetheless, your 'find' itself is nondeterministic too
03:32:36 <paolino> and ?
03:32:38 <lilac> (if 'g' can produce two different values for which 'k' returns True, it's undefined which will be found)
03:33:01 <bobshush> Does g terminate?
03:33:35 <paolino> bobshush: in my case no
03:33:44 <paolino> it's just lazy
03:34:15 <paolino> from a to an infinite lazy list of b
03:35:07 <bobshush> so you've changed the functions type from (a -> [b]) to (a -> IO [b]) or similar by this replacement
03:35:15 <lilac> paolino: i think there's two ways to go here. you can fight the language and use some evil unsafe hack to write 'g', and render everything that transitively uses it nondeterministic
03:35:23 <paolino> actually is IO [b], but I'm trying to understand how much  using unsafePerformIO is wrong
03:35:28 <lilac> paolino: or you can be a good haskell citizen and wrap your result up in a monad
03:36:17 <paolino> because f IS a -> [b]
03:36:26 <bobshush> theres not really a problem if you want to have a function a -> IO [b], but it means that ensuring the efficiency of g is up to you.
03:36:38 <paolino> but g a -> IO [b]
03:36:43 <bobshush> well, now f IS a -> IO [b]
03:37:04 <paolino> so one has to rewrite all of the code around f
03:37:15 <wli> Okay, rather, I golfed a priority queue -based true Eratosthenes.
03:37:15 <paolino> over f
03:38:12 <bobshush> not much, just use >>=.
03:38:28 <idnar> okay, someone should put all these prime number sieves in an arena, have them fight to the death, and upload the one that survives to hackage
03:38:33 <paolino> bobshush: if parMap was IO nobody would use it
03:38:41 <lilac> wli: code?
03:39:00 <lilac> wli: how many characters are you down to?
03:39:01 <wli> > let sieve (m :: Map Integer [Integer]) (~(n:ns)) | Just ((k, ps), m') <- minViewWithKey m, k == n = sieve (unionWith (++) m' $ fromListWith (++) [(k + p, [p]) | p <- ps]) ns | otherwise = n : sieve (insertWith (++) (n*n) [n] m) ns ; primes = sieve empty [2..] in take 10 primes
03:39:02 <lambdabot>   Not in scope: type constructor or class `Map'Not in scope: `minViewWithKey'...
03:39:20 <bobshush> @type parMap
03:39:21 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
03:39:22 <wli> lilac: Well, not char-by-char golfing.
03:39:35 <lilac> wli: i was going to say, lots of whitespace there you can kill :)
03:40:05 <wli> lilac: Lots of var names to shorten, too, at that.
03:40:39 <bobshush> parMap doesn't have to be in IO, because it is a) safe and b) deterministic
03:40:56 <bobshush> if f includes parMap somewhere, f is also multicore
03:41:12 <bobshush> (assuming parMap is the function I'm thinking of, it had the right type)
03:41:19 <paolino> the problem is parMap is very limited
03:41:33 <wli> lilac: It's somewhat more efficient than sieve ~(n:ns) = n : sieve (filter (\k -> k `mod` n /= 0) ns)
03:41:57 <Twey> Gah!
03:41:59 <bobshush> what are you wanting to use it for?
03:42:09 <Twey> And 'cabal install happs-tutorial' gives me ghc: /usr/lib/HTTP-3001.1.5/ghc-6.10.1/HSHTTP-3001.1.5.o: unknown symbol `networkzm2zi2zi0zi1_NetworkziSocket_a211_info'
03:42:09 <paolino> and with the restriction of transparency we are stucked
03:42:12 <hackage> Uploaded to hackage: Stream 0.3
03:42:14 * Twey gives up
03:42:28 <lilac> wli: yeah, the nub approach is a little poor :)
03:42:50 <lilac> @hoogle minViewWithKey
03:42:50 <lambdabot> Data.IntMap minViewWithKey :: Monad m => IntMap a -> m ((Key, a), IntMap a)
03:42:50 <lambdabot> Data.Map minViewWithKey :: Monad m => Map k a -> m ((k, a), Map k a)
03:43:09 <dcoutts_> Twey: sounds like some packages have had their dependencies switched without rebuilding
03:43:31 <dcoutts_> Twey: see if rebuilding the http lib fixes it
03:43:31 <paolino> bobshush: with that restriction, I don't see how to do something not truly parallel
03:43:53 <wli> lilac: Oh, yeah, it passes -Wall at the ghci prompt, too.
03:44:11 <Twey> dcoutts_: Did you read the issue earlier?  Â« Could not find module `Data.Generic s': it is a member of package syb, which is hidden Â»
03:44:19 <Twey> Er, Data.Generics
03:44:24 <bobshush> side note: I had actually come in here to ask a question; I'm wanting to write a small test program that plays a 200Hz chime every minute or so. Library suggestions?
03:44:45 <Twey> dcoutts_: That's what I get when I try to install the Arch package... apparently it needs syb added as a dependency, but I can't find any way to do that on the fly
03:44:51 <dcoutts_> Twey: that's probably because it needs base 3 but it's being built against base 4
03:45:12 <lilac> bobshush: openal is fiddly but ok
03:45:23 <wli> lilac: Only a couple of rather benign extensions needed for function argument types and pattern guards.
03:45:32 <paolino> bobshush and all, thanks for the points
03:46:21 <hallongrottan> :t flip concatMap
03:46:22 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
03:46:30 <lilac> @pl \p -> (k+p, [p])
03:46:30 <lambdabot> liftM2 (,) (k +) return
03:46:38 <bobshush> lilac: will check it out. How would one go about the 'every minute or so' portion of the program?
03:46:50 <lilac> @hoogle sleep
03:46:50 <lambdabot> No results found
03:46:57 <lilac> @hoogle delay
03:46:57 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
03:47:01 <beelsebob> (k+) <^(,)^> pure -- damn you!
03:47:27 <wli> @pl \k -> liftM2 (,) (k+) (:[])
03:47:27 <lambdabot> flip (liftM2 (,) . (+)) return
03:48:06 <lilac> (ps<$>(k+)<^(,)^>pure) is sadly not shorter than [(k+p,[p])|p<-ps]
03:48:07 <bobshush> @yhjulwwiefzojcbxybbruweejw
03:48:07 <lambdabot> "\"#$%&'()*+,\""
03:48:12 <Twey> dcoutts_: Hmm... what can I do about that?
03:48:26 <wli> lilac: Neither is flip (liftM2 (,) . (+)) (:[])
03:48:33 <bobshush> @hoogle+ delay
03:48:41 <Twey> Considering that I probably have an awful lot of packages on my system built against 4
03:48:50 <bobshush> hmm
03:49:05 <dcoutts_> Twey: if it's an arch package then I guess you need to modify the arch package or complain to its maintainer
03:49:53 * Twey has been trying to do the former, but hasn't managed so far
03:51:43 <bobshush> lilac: With threadDelay there's no guarantee that the thread will be promptly rescheduled; is there anything you know of that uses the system time? I'm actually going to try to eventually work this into a somewhat bizzare clock
03:53:18 <lilac> bobshush: i know of no such thing. but threadDelay is what reactive uses...
03:53:32 <bobshush> reactive?
03:53:45 <lilac> conal's FRP library
03:53:58 <bobshush> How does it work?
03:54:06 <bobshush> (FRP?)
03:55:04 <bobshush> (I've been focusing more on the math side of haskell than the 'actually getting programs written' side...)
03:56:38 <lilac> i suggest you check out conal's blog entries on the subject :) http://conal.net/blog/tag/frp/
03:56:47 <wli> That reminds me, I never got the complex generalized continued fraction evaluation done for the exponential integral I needed.
03:57:25 <lilac> wli: sometimes i wonder if people in here say things merely to get newbies to panic ;-)
03:58:19 <paolino> is putting unsafe before a function name enough to use unsafePerformIO inside and be a good citizen ?
03:58:23 <wli> lilac: It's a dumb matter of looking up the answer and translating it into Haskell. I wonder how it could sound intimidating.
03:58:52 <wli> I just need to smoke out where to web the algorithm(s).
03:58:59 <lilac> wli: you could say the same about zygomatic hylomorphisms ;-)
03:59:14 <wli> (They're not very involved algorithms.)
03:59:30 <bobshush> You were wanting to integrate functions of contined fractions? like, what, df -> f x = (1 \ x + ( 2 \ x + (3 \ ...)
03:59:46 <bobshush> that would be cool.
04:00:18 <wli> lilac: Well, sort of like Project Euler, all the work is in the math to figure out the algorithm and the programming for it is stupid.
04:03:32 <wli> bobshush: Nah, I've basically got integrals of the form \int_a^b e^{Kt}\frac{pt+q}{t^2+ut+v} dt I need to numerically evaluate; it turns out the closed forms are in terms of Ei(x) = \int_{-\infty}^x \frac{e^t}{t} dt at complex arguments, and Ei(x) is best evaluated via its continued fraction representation. But evaluating continued fraction expansions is not entirely trivial.
04:04:05 <bobshush> hmm, df\g = f'g + g'f \ (g^2) , if f x = 1 \ (x + f x), that would be ... something I'm not sure about but likely involving a lot of partial differential equations
04:04:28 <bobshush> 'not entirely trivial' -> I had noticed.
04:05:50 <wli> bobsush: So basically once I get a complex floating point number generalized continued fraction evaluation routine, it's plug-and-chug for the expansion of Ei(x) and the integration problem is easy prey.
04:06:46 <wli> And that evaluation routine is not much more than cut & paste once I find a description.
04:08:23 <wli> I've hammered it out before and it's not all that involved, but it's not something you'd (normally) come up with on your own.
04:08:44 <let_f_> wli: all is one, one is all
04:08:53 <bobshush> wli: I think I will understand what you are talking about, as soon as I find somewhere to paste those formulas that will interpret them in a more readable format.
04:09:11 <wli> mathbin.net
04:09:14 <bobshush> (Undergraduate math major, still havn't quite gotten the hang of reading them)
04:09:24 <let_f_> where is the automatic tehroem generator?
04:09:27 <let_f_> theorem
04:09:48 <SamB> @free id
04:09:50 <lambdabot> f . id = id . f
04:10:00 <SamB> @go theorems for free
04:10:02 <lambdabot> http://citeseer.ist.psu.edu/250500.html
04:10:02 <lambdabot> Title: Document Not Found
04:10:06 <idnar> haha
04:10:07 <SamB> hahaha
04:10:32 <let_f_> bobshush: what will you end up doing? i have always been interested in math but a pure amth degree what do you end up doing? i like machine learning, computer games, image analysis.
04:10:44 <let_f_> math major/phsyics minor perhaps?
04:11:02 <pozic> There used to be an introduction to the Render monad in GTK2HS, which contained a runnable example. Where is it?
04:11:11 <SamB> http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html
04:11:54 <bobshush> math and econ double major actually, the second of which I am considering replacing.
04:12:02 <Cthulhon> bobshush: http://mathbin.net/5757
04:12:06 <SamB> hmm, the citeseer URL does get redirected to citeseerx before failing like that
04:12:14 <dcoutts_> pozic: I presume you're not referring to the gtk2hs cairo demos
04:12:26 <bobshush> (dropped it into the wikipedia sandbox, actually. :P)
04:12:29 <SamB> (and did at the time of indexing, too)
04:13:51 <pozic> dcoutts_, it contained simple things like drawing a line and so on.
04:13:54 <SamB> dcoutts: well, does it have a Render monad ?
04:13:58 <bobshush> let_f: I really want to experement with things in the general category of Design, so user interfaces and ways of connecting people together in new ways.
04:14:18 <wli> All I'm doing is defining a piecewise rational function via samples x_n at times t_n where the functions p_n(t)/q_n(t) are a sort of rational spline interpolant computed on the fly with the recurrences (d^k/dx^k)(p_n(t)q_{n+1}(t)-p_{n+1}(t)q_n(t))|_{t=t_{n+1}} = 0, which are linear for p_{n+1}, q_{n+1} coefficients because those for p_n, q_n are known at time t_{n+1} etc. and things chain that way given some initial conditions. Then I integrate the thing t
04:14:22 <dcoutts_> SamB: yes, necessarily so because all cairo stuff happens in the Render monad
04:14:40 <dcoutts_> pozic: was it a tutorial or just a code demo ?
04:14:44 <SamB> dcoutts: is that the only part of gtk2hs that uses the Render monad ?
04:14:54 <dcoutts_> SamB: yes
04:15:05 <pozic> dcoutts_: http://home.telfort.nl/sp969709/gtk2hs/app1.html is good enough
04:15:11 <wli> Here I'm using deg(p_n) = 3, deg(q_n) = 2, which makes various things convenient.
04:15:13 <SamB> then I'm pretty sure he DOES mean the Cairo demos ;-P
04:15:17 <pozic> dcoutts_: but I was referring to a code demo.
04:15:32 <dcoutts_> pozic: ok, then look in the gtk2hs demos in the cairo dir
04:15:43 <wli> e^{Kt} is the exponentially-decaying weight factor.
04:15:45 <bobshush> The 200Hz tone every minute is hopefully going to become an ambient sound clock (and hopefully some other things), for instance.
04:17:21 <pozic> dcoutts_: How is eventSent named in the .13 release?
04:17:58 <pozic> The first example in the tutorial on the above URL contains the identifier.
04:18:27 <dcoutts_> pozic: seems to be the same
04:20:44 <pozic> dcoutts_: the tutorial missed an import Graphics.UI.Gtk.Gdk.Events.
04:22:08 <dcoutts_> pozic: I don't understand that. In gtk2hs-0.9.13, the Graphics.UI.Gtk.Gdk.Events module is exported from Graphics.UI.Gtk
04:22:50 <bobshush> @source Data.Time
04:22:50 <lambdabot> Data.Time not available
04:27:17 <SamB> hmm, what is shellac?
04:35:01 <pozic> dcoutts: neither do I (I noticed it in the documentation), but it doesn't.
04:40:07 * SamB wonders if there is a way to conditionalize cabal files on compiler *features* -- say, extensions supported
04:52:17 <shukhov> how do you add things to hackage?
04:53:33 <pejo> shukhov, you need an account, which you get by mailing someone. There are instructions somewhere on hackage for what to do.
04:53:44 <let_f_> what si a good book on set theory? ic category theory an altenative to set thoery as a foundation of mathematics? and didnt gödel kill the ope of a foundation for mathematics? or set theory andc ategory theory are workarounds on that?
04:53:53 <let_f_> is the axiom of choice not just a clever hack?
04:54:13 <shukhov> pejo: ok, ill check it out.
04:56:15 <sioraiocht> lefant: set theory was found to be an insufficient foundation of mathematics
04:56:20 <sioraiocht> hence, category theory
04:58:49 <earthy> let_f_: GÃ¶del proved that Hilbert's program was infeasible
04:58:59 <earthy> this does *not* mean that there is no merit to followingi t
05:01:40 <kapil_> let_f_: have a look at "Sheaves, Geometry and Logic" by Maclane and Moerdjk (sp?) if you (a) are a mathematician and (b) want to know how category theory aims to "replace set theory"
05:03:16 <bastl> im experimenting with HaXml by adding "deriving (Data,Typeable)" to certain types. but for the snippet http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1309  I get >> Can't make a derived instance of `Data ANYContent' (`ANYContent' has non-Haskell-98 constructor(s)) << Can somone explain that or give a workaround?
05:04:14 <malcolmw> bastl: ANYContent contains an existential type
05:04:40 <malcolmw> forall a . (XmlContent a, Show a) => ANYContent a
05:05:09 <malcolmw> bastl: so if you want to derive Data and Typeable for it, you probably need to add them into the context on the existential
05:05:23 <malcolmw> forall a . (XmlContent a, Show a, Data a, Typeable a) => ANYContent a
05:05:36 <Saizan> for Typeable it shouldn't be necessary
05:05:52 <bastl> k, ill try that. i have to understand these thigns soon ...
05:07:17 <Saizan> malcolmw: btw, a library depending on HaXml should upgrade to 1.19 or stick with 1.13?
05:08:19 <malcolmw> Saizan: its your choice whether to upgrade or not.  1.13 does not see any bugfixes these days.  But 1.19 may have new bugs that 1.13 did not :-)
05:09:39 <malcolmw> I recently fixed several serious bugs in 1.19's DtdToHaskell, after Lennart upgraded and noticed them.
05:10:25 <Saizan> malcolmw: i see
05:10:35 <bastl> hmm, any additional compiler settings to switch on (besides glasgow-exts and ExisitentialQualification)? ghc finds the non h98-constructure and it seems it doesnt even try to derive an instance.
05:11:25 <Saizan> maybe the deriving mechanism simply doesn't support this
05:11:34 <malcolmw> bastl: you may need to ask the ghc people about that - it could be that deriving does not work for existentials at all
05:16:23 <malcolmw> bastl: the ghc gurus reckon that deriving Typeable can cope with the existential, but deriving Data probably cannot.
05:17:38 <bastl> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#id2690300 says it's not allowed at all.
05:19:16 <malcolmw> bastl: so the solution is to define your own instances of Data and Typeable.
05:20:20 <bastl> malcolw: yes, and before i have to understand ...
05:20:40 <let_f_> earthy: what is the merit? to have complete system of inference that can be applied to any statement? was hilberts plan to hav no axioms?
05:21:09 <let_f_> and is zermelo frankel set theory also insufficient?
05:21:27 <let_f_> and i mean sint category insufficient to according to gödel? just less insufficient?
05:26:18 <Philonous1> Is there a BerkeleyDB 4 binding that runs under Base 3 ?
05:42:50 <ibid> let_f_: any system sufficiently expressive to be useful as a foundation is insufficient as a foundation, according to gÃ¶del
05:43:17 <ibid> (well, that's a generalisation, but still)
05:44:24 <Olathe> It's not insufficient as a foundation.
05:44:31 <Olathe> Logic is sufficient as a foundation.
05:44:52 <Olathe> You just can't prove everything without adding more and more assumptions.
05:45:29 <Olathe> If you stay with a small set of assumptions, you'll get only a small set of conclusions.
05:45:59 <Olathe> But the tools of logic and set theory and category theory and so on are all fine.
05:46:10 <kapil_> Olathe: you also can't prove consistency if you allow second order logic. that is a more serious drawback than adding a sequence of axioms.
05:46:32 <Olathe> OK.
05:47:37 <kapil_> however, topos theory is meant to be "elementary" so as to avoid second order logic. this is how it tries to escape this aspect of Go:del's theorem.
05:48:12 <Olathe> I'm just saying that the basic tools are fine, Godel was just saying that you have to keep adding assumptions if you want to keep getting conclusions.
05:48:37 <Olathe> As far as what they were talking about before, I mean.
05:48:49 <Olathe> I'm sure Godel said more than that in other areas, as you mentioned.
05:49:09 <kapil_> true enough.
05:50:31 <let_f_> so the limitations that Gödel's theorem imply are only limits to things you can derive by thinking. but if you assume some things(through experimental observation for example) then that can complete it?
05:50:46 <kapil_> so if one means "topos theory" when one takes category theory at the foundations of mathematics, and one believes that this theory is elementary, then one can get a reasonable setup.
05:51:14 <quicksilver> well he said two things (1) there will always be stuff you can't prove (2) one of those things that you can't prove is that your own system is consistent
05:51:37 <quicksilver> to my mind (1) is quite a bit less surprising that (2).
05:51:41 <doserj> (if your system is consistent to start with)
05:52:20 <quicksilver> alternatively (1) you're fucked (2) you can't even tell that you're fucked.
05:52:22 <kapil_> i think there is some aspect of topos theory (Beck's theorem perhaps?) for which no elementary proof is known
05:52:32 <quicksilver> (quicksilver's incompleteness theorems)
05:52:37 <BONUS> hahaha
05:52:49 <score> *yawn*
05:53:44 <score> i remember being around this math guy when he was drunk. this sounds a lot like the conversation he was having with himself.
05:54:12 <opqdonut> :)
05:54:30 <kapil_> perhaps to avoid this issue, haskell's types do _not_ (i think) form a topos. (no power sets).
05:54:39 <weilawei> score it's better than what regular joe's mutter to themselves when they're drunk "shouldn't have ****ed that hooker.. probly got herpes now.."
05:55:05 <junek> @type map
05:55:06 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:55:31 <junek> @pl \(x0,y0) (x1,y1) -> (x0+x1,y0+y1)
05:55:32 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
05:55:36 <kapil_> many of the best theorems are proved when drunk. the hangover cures tend to erase the fine details of the proofs :(
05:56:00 <weilawei> kapil_, and drunk is interchangeable with many other forms of altered consciousness :)
05:56:11 <kapil_> weilawei: of course!
05:56:42 <score> i guess i wouldn't mind if it seemed more helpful
05:57:00 <paolino> score: those are optimizations
05:57:03 <lilac> quicksilver: to my mind, (2) is intuitively obvious. what would it even mean for a system to prove itself consistent? and why couldn't an inconsistent system do that?
05:57:14 <score> paolino: hmm?
05:57:30 <weilawei> score, heh, i often feel the same way.. but let's face it: would you rather have the mindless ramblings of someone vaguely creative and willing to twist interesting concepts or would you have them regurgitate MTV?
05:57:35 <quicksilver> lilac: well, you have a better intuition than me, then. Or Russell, apparently :)
05:57:40 <paolino> score: the other forms
05:58:19 <score> weilawei: one seems like noise, and the other poison
05:58:39 <lilac> quicksilver: actually /proving/ it is another matter :) (but one which itself relies on you using a larger system which you need to assume is consistent!)
05:59:08 <weilawei> score: there IS a solution. just refuse to deal with people unless you're on their level (e.g., them drunk, you drunk)
05:59:28 <lilac> quicksilver: also, my intuition is molded by a mathematical education, so...
05:59:46 <weilawei> surprisingly a few pints can quickly ease that appearance of noise
06:01:21 <score> weilawei: i was drinking at the time. it wasn't any more interesting or entertaining. it just seem like someone resolved to defeat.
06:02:27 <weilawei> score, have you got a PLURbat? try that on them
06:02:49 <junek> @pl \f (x0,y0) (x1,y1) -> (f x0 x1, f y0 y1)
06:02:50 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
06:03:07 <score> weilawei: i don't go outside enough to know what a plur bat is. sorry.
06:04:05 <Olathe> @type \f (a, b) -> (f a, f b)
06:04:06 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
06:04:08 <Olathe> @pl \f (a, b) -> (f a, f b)
06:04:09 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
06:04:11 <weilawei> score: PLUR == peace, love, unity, respect
06:04:22 <Olathe> @pl \f a b -> (f a, f b)
06:04:22 <lambdabot> flip =<< (((.) . (,)) .)
06:04:39 <Olathe> Hmm...
06:04:49 <weilawei> you beat the **** out of someone with it to achieve those goals
06:04:59 <score> weilawei: doesn't sound like something you should or would hit someone with
06:06:13 <saml> @pl \x -> x
06:06:14 <lambdabot> id
06:06:25 <saml> @pl \x -> x x
06:06:25 <lambdabot> join id
06:06:29 <saml> @pl \x -> x x x
06:06:29 <lambdabot> join (join id)
06:06:46 <saml> let me guess. @pl \x -> x x x x would be join (join (join id))
06:06:49 <saml> @pl \x -> x x x x
06:06:49 <lambdabot> join (join (join id))
06:06:53 <saml> i'm so smart
06:07:05 <lilac> none of these are well-typed
06:07:16 <saml> :t join
06:07:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:07:22 <lilac> nor was that sentence. none of these /is/ well typed
06:07:33 <lilac> @type \x -> x x
06:07:34 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
06:07:34 <lambdabot>     Probable cause: `x' is applied to too many arguments
06:07:34 <lambdabot>     In the expression: x x
06:08:01 <saml> > (join id) 1
06:08:01 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a1
06:08:01 <lambdabot>      Prob...
06:08:21 <saml> @type join id
06:08:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
06:08:22 <lambdabot>     Probable cause: `id' is applied to too many arguments
06:08:22 <lambdabot>     In the first argument of `join', namely `id'
06:12:33 <Olathe> @pl \f (a, b) -> (f a, f b)
06:12:33 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
06:12:45 <Olathe> > (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)) (+2) (a, b)
06:12:46 <lambdabot>   Couldn't match expected type `a -> c'
06:12:53 <Olathe> > ((`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))) (+2) (a, b)
06:12:55 <lambdabot>   (a + 2,b + 2)
06:13:08 <Olathe> > liftM2 (.) first second (+2) (a, b)
06:13:09 <lambdabot>   (a + 2,b + 2)
06:15:54 <ozy`> GENTLEMEN
06:16:03 * ozy` shows up with a bunch of compilers in his mouth
06:16:19 <ozy`> we need someone to get GHC working on Haiku
06:16:43 <Olathe> > uncurry ((. (second . (+))) . (.) . first . (+)) (a, b) (c, d)
06:16:44 <lambdabot>   (a + c,b + d)
06:16:47 <ozy`> haskell-on-Haiku... they both start with an H. this is an opportunity we can't afford to miss
06:16:48 <Olathe> There we go :)
06:17:14 <ozy`> :t ((+) &&& (+))
06:17:15 <lambdabot> forall a. (Num a) => a -> (a -> a, a -> a)
06:17:33 <Olathe> @pl \f -> uncurry ((. (second . f)) . (.) . first . f)
06:17:33 <lambdabot> uncurry . ap ((.) . flip (.) . (second .)) (((.) . first) .)
06:17:47 <Olathe> > uncurry . ap ((.) . flip (.) . (second .)) (((.) . first) .) (+) (a, b) (c, d)
06:17:48 <lambdabot>   Couldn't match expected type `a -> b -> c'
06:17:53 <Olathe> > (uncurry . ap ((.) . flip (.) . (second .)) (((.) . first) .)) (+) (a, b) (c, d)
06:17:54 <lambdabot>   (a + c,b + d)
06:18:00 <ozy`> @pl \(a, b) (c, d) -> (a + c, b + d)
06:18:01 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
06:18:04 <ozy`> huh
06:18:13 <ozy`> :t (***)
06:18:14 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:18:15 <Olathe> @pl \f (a, b) (c, d) -> (f a c, f b d)
06:18:16 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
06:18:20 <Olathe> Eeeewww !
06:18:39 <Olathe> > ((`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))) (+) (a, b) (c, d)
06:18:40 <lambdabot>   (a + c,b + d)
06:18:48 <Olathe> > (uncurry . ap ((.) . flip (.) . (second .)) (((.) . first) .)) (+) (a, b) (c, d)
06:18:49 <lambdabot>   (a + c,b + d)
06:19:43 <ozy`> :t (\f (a, b) (c, d) -> (f a c, f b d))
06:19:44 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t) -> (t1, t1) -> (t2, t2)
06:20:27 <ozy`> @hoogle (t -> t1 -> t2) -> (t, t) -> (t1, t1) -> (t2, t2)
06:20:27 <lambdabot> Data.Array.Base unsafeAccum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(Int, e')] -> a i e
06:20:27 <lambdabot> Data.Array.Base unsafeAccumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(Int, e')] -> a i e
06:20:27 <lambdabot> Data.Array.Base accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
06:21:07 <Olathe> @hoogle (a -> a -> a) -> (a, a) -> (a, a) -> (a, a)
06:21:07 <lambdabot> Data.Array.Base accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
06:21:07 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
06:21:07 <lambdabot> Data.Array.Base unsafeAccum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(Int, e')] -> a i e
06:21:22 <ozy`> :t first (+) . second (+)
06:21:23 <lambdabot> forall b d. (Num b, Num d) => (d, b) -> (d -> d, b -> b)
06:22:17 <ozy`> :t (\(a, b) -> first (+ a) . second (+ b))
06:22:18 <lambdabot> forall b d. (Num b, Num d) => (d, b) -> (d, b) -> (d, b)
06:22:23 <fasta> Does cabal install gd work for anyone? I don't understand why Hackage claims it can build it, while it fails here.
06:23:12 <Heffalump> fasta: just trying it. What C libraries do I need?
06:23:41 <ozy`> @pl (\f (a, b) -> first (f a) . second (f b))
06:23:41 <lambdabot> (`ap` snd) . (. fst) . liftM2 flip (((.) . (.) . first) .) (second .)
06:23:47 <fasta> Heffalump: I libgd-dev probably. I don't know, since I already had everything and it didn't complain.
06:23:50 <ozy`> oh well
06:24:44 <doserj> fasta: cabal doesn't complain if you don't have C libraries installed.
06:24:59 <fasta> doserj: I see.
06:25:04 <fasta> Heffalump: it does work now.
06:25:13 <Heffalump> oh, I get an error :-)
06:25:24 <Heffalump> cbits/gd-extras.h:10: error: expected declaration specifiers before 'gdImagePtrD
06:25:27 <Heffalump> estroyIfNotNull'
06:25:45 <doserj> Heffalump: I got that before installing libgd-dev
06:26:09 <Heffalump> I already installed libgd-dev
06:26:25 <Heffalump> but if fasta has it working now I don't particularly care
06:27:20 <fasta> Loading package gd-3000.4.0 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header) <- is this only a ghci problem?
06:27:33 <Heffalump> I think so, yes
06:28:14 <fasta> Is there any library which can give me the width and height of a PNG image while using ghci?
06:30:57 <doserj> /usr/bin/identify :)
06:32:16 <z0d> or some versions of /usr/bin/file
06:33:52 <doserj> but maybe hsmagick works
06:34:17 <fasta> SDL_image works
06:34:34 * fasta wishes he could delete everything that didn't work from Hackage.
06:35:56 <mmorrow> ,  (\x -> [$ski|S[(,)][id][x]|]) 42
06:35:58 <lunabot>  (42,42)
06:36:45 <ehird> , [$ski|S[I][I][S[I][I]]|]
06:36:48 <lunabot>  luna: Couldn't match expected type `[Luna.SKI.SKI]
06:36:53 <ehird> :(
06:37:08 <mmorrow> , [$ski|SSK[\x->x]IK|]
06:37:11 <lunabot>  (((\x -> x) :$ I) :$ \x -> x) :$ K
06:37:27 <mmorrow> anything inside [...] is parsed as haskell code
06:37:42 <mmorrow> and outside you can only do "S", "K", or "I"
06:38:06 <ehird> ah
06:38:11 <mmorrow> it'll eval the code if there are no SKI's left, else it'll prettyprint it inside the SKI's
06:38:15 <ehird> umm mmorrow
06:38:20 <ehird> how can you do precedence
06:38:21 <ehird> ()?
06:38:23 <ehird> , [$ski|SII(SII)|]
06:38:29 <lunabot>  Killed.
06:38:30 <ehird> I see :D
06:38:38 <tromp__> , [$ski|SSK(S(K(SS(S(SSK))))K)]
06:38:39 <lunabot>  luna: lexical error in string/character literal at end of input
06:38:50 <tromp__> , [$ski|SSK(S(K(SS(S(SSK))))K)|]
06:38:52 <lunabot>  (S :$ (S :$ K :$ (S :$ S) :$ S :$ (S :$ S) :$ K) :$ K) :$ K :$ (S :$ K :$...
06:39:00 <mmorrow> ehird: the code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1306#a1307
06:39:01 <ehird> is it lazy?
06:39:04 <ehird> it should be lazy.
06:39:33 <ehird> i.e., does SII(SII) grow Is forever?
06:39:34 <mmorrow> i can't think why it souldn't be, but i'm not positive
06:39:46 <ehird> mmorrow: make it print out every step of reduction
06:39:49 <mmorrow> , [$ski|SII(SII)|]
06:39:54 <ehird> if SII(SII) grows more Is forever and ever, it's lazy
06:39:55 <lunabot>  Killed.
06:40:11 <mmorrow> it's being spliced by TH though, so maybe that messes with it
06:40:27 <FunctorSalad> does "foo `using` rnf" do anything if foo is a NFData but its computation involves intermediate things that aren't?
06:40:41 <FunctorSalad> (how could that work?)
06:41:12 <tromp__> , [$ski|SSK(S(SSK))|]
06:41:14 <lunabot>  (S :$ S :$ (S :$ S) :$ K) :$ K :$ S :$ (S :$ S) :$ K
06:41:29 <cads> aaaaah ski ski ski ski!
06:41:29 <lambdabot> cads: You have 1 new message. '/msg lambdabot @messages' to read it.
06:41:29 <tromp__> , [$ski|SSK(S(SSK))K|]
06:41:33 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:42:08 <tromp__> , [$ski|SSK(S(SSK))[undefined]|]
06:42:11 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:43:05 <Neun> Axman6: hi, I noticed you tried my app hevolisa, did you get it to run?
06:43:29 <Axman6> Neun: no, it crashed for me :(
06:44:03 <Neun> Axman6: could you try with strace?
06:44:19 <Neun> maybe its file handling
06:44:27 <Neun> it's
06:47:03 <redditbot> Regression : Lennart Augustsson
06:47:04 <Axman6> ok, gimme a sec
06:47:23 <Axman6> Neun: i don't have strace
06:48:09 <Neun> Axman6: ok, maybe i should do some exception handling with the file handling
06:48:20 <Saizan> FunctorSalad: thos intermediate things will be forced as much as needed to reduce foo to nf, rnf is just a class method nothing fancy
06:48:22 <Axman6> heh, probably
06:48:32 <mmorrow> i think how it needs to go via TH is effecting the laziness
06:48:34 <Neun> next version then
06:48:38 <Axman6> hevolisa: internal error: allocGroup: requested zero blocks
06:48:42 <chessguy_work> anybody have any good heuristics for when is a good idea to reach for CPS
06:48:43 <Axman6> was the error btw
06:48:43 <mmorrow> it probably needs to be fully evaluated to be spliced
06:49:00 <mmorrow> , [$ty| skival |]
06:49:03 <lunabot>  SKI -> SKI
06:49:09 <mmorrow> , src ''SKI
06:49:12 <lunabot>  data SKI = S | K | I | E Exp | SKI `(:$)` SKI
06:49:32 <Saizan> mmorrow: you can encode lazyness in E Exp
06:49:45 <mmorrow> , skival (S:$S:$K:$(S:$(S:$S:$K)):$K)
06:49:49 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:49:57 <mmorrow> hmm, maybe it's my eval function then
06:49:59 <Neun> Axman6: try to run hevolisa in the directory where the file mona_lisa_crop.png is
06:50:09 <chessguy_work> well, i should say continuations in general, not necessarily CPS
06:50:19 <mmorrow> Saizan: but in E Exp i'm encoding arbitrary code
06:50:27 <mmorrow> and not SKI stuff
06:50:30 <Neun> then it should work
06:50:46 <mmorrow> , [$ski|[id]|]
06:50:48 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
06:50:48 <Axman6> Neun: seems to work now :)
06:50:58 <Axman6> what are the numbers it's outputting?
06:51:04 <FunctorSalad> Saizan: hmm... beginning to understand ;)
06:51:04 <mmorrow> , [$ski|S[(,)][42]["42"]|]
06:51:07 <lunabot>  luna: No instance for (GHC.Num.Num ([GHC.Types.Char] -> b))
06:51:07 <Neun> Axman6: great, now I know what to fix
06:51:19 <Neun> it's the current error from the error function
06:51:38 <mmorrow> , [$ski|S[(,)][show][42]|]
06:51:41 <lunabot>  (42,"42")
06:52:00 <Neun> the images are created in the images subdirectory
06:52:23 <mmorrow> , [$ski|S[:$][S][I]|]
06:52:25 <lunabot>  S
06:52:27 <tromp__> mmorrow SSK(S(SSK)) is supposed to blow up
06:52:27 <mmorrow> heh
06:52:47 <mmorrow> tromp__: see if i'm botching anything: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1306#a1307
06:53:09 <chessguy_work> hey mmorrow, i assume you saw the source of the BASIC code the other day
06:53:29 <mmorrow> chessguy_work: oh no, i haven't looked yet but i've been meaning to
06:54:23 <Axman6> Neun: so one image every 1000 iterations?
06:54:52 <Neun> Axman6: yes, you can change that in Evolusion.hs
06:55:21 <Neun> Axman6: I could do that as an option in a future version
06:55:37 <Axman6> yeah, that'd be good. does it take any options at the moment?
06:55:39 <tromp__> mmorrow: if you define W=SSK, then W(SW)x = W(SW)(x(SW)) = ...
06:55:55 <Neun> Axman6: no, not at the moment
06:56:00 <Axman6> ok
06:56:03 <mmorrow> ah, i see
06:56:17 <Axman6> i think an -f file/path.png would be quite useful
06:56:17 <tromp__> so it's building some term x(SW)(SW)(SW)...
06:56:46 <Neun> yes, noted
06:57:21 <Axman6> did you have fun writing it?
06:57:34 <mmorrow> ok, so we're expecting failure .. (?)
06:57:55 <Neun> Axman6: yes, lots of, except for building gtk2hs :(
06:58:01 <mmorrow> whoa, hmm so then
06:58:02 <Axman6> heh
06:58:03 <mmorrow> , [$ski|SSK(S(SSK))|]
06:58:05 <lunabot>  (S :$ S :$ (S :$ S) :$ K) :$ K :$ S :$ (S :$ S) :$ K
06:58:15 <mmorrow> this means my eval function is wrong then
06:58:18 <mmorrow> ?
06:58:20 <tromp__> it blows up as soon as you apply it
06:58:47 <mmorrow> , [$ski|SSK(S(SSK))I|]
06:58:51 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:58:55 <mmorrow> ohhhh, that's pretty cool
06:58:59 <tromp__> yes
06:59:02 <mmorrow> :)
06:59:15 <mmorrow> , [$ski|SSK(S(SSK))[id]|]
06:59:19 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:59:24 <saml> , []
06:59:25 <lunabot>  []
06:59:25 <tromp__> it doesnt matter what u apply it to
06:59:29 <tromp__> that's the x above
06:59:30 <mmorrow> , [$ski|[SSK(S(SSK))]|]
06:59:32 <lunabot>  luna: Not in scope: data constructor `SSK'
06:59:33 <tromp__> which can even be undefined
06:59:45 <mmorrow> , [$ski|[S:$S:$K:$(S:$(S:$S:$K))]|]
06:59:48 <lunabot>  ((S :$ S) :$ K) :$ S :$ (S :$ S) :$ K
06:59:56 <mmorrow> , [$ski|SSK(S(SSK))|]
06:59:58 <lunabot>  (S :$ S :$ (S :$ S) :$ K) :$ K :$ S :$ (S :$ S) :$ K
07:00:12 <quicksilver> when it gets a non-terminating combinator it should convert it to an L-system and render the result as an image which it posts a link to.
07:00:50 <mmorrow> that level of sweetness would probably create a mini blackhole which would swallow us all
07:00:52 <tromp__> SSK x y = x y x
07:01:58 <mmorrow> , [$ski|SSK[x][y]|]
07:02:00 <lunabot>  luna: Couldn't match expected type `Luna.SimpleReflect.Expr
07:02:31 <mmorrow> , [$ski|SSK[id][x]|]
07:02:34 <lunabot>  luna: Couldn't match expected type `(a1 -> a1) -> a'
07:02:40 <mmorrow> , [$ski|SSK[id][id]|] 42
07:02:42 <lunabot>  42
07:02:45 <mmorrow> heh
07:02:51 <tromp__> x y x is not gonna type too well :(
07:03:01 <mmorrow> true
07:03:30 <bombshelter13_> Am I off track in noticing similarity between the sort of transformation monads do and CPS?
07:03:54 <idnar> bombshelter13_:
07:03:55 <mmorrow> bombshel2er13: no, it's very similar
07:03:56 <idnar> http://sigfpe.blogspot.com/2008/12/mother-of-all-monads.html
07:04:07 <bombshelter13_> mmorrow: sweet, glad to know I'm making sense of it :)
07:04:09 <idnar> oh, it moved?
07:04:14 <idnar> try http://blog.sigfpe.com/2008/12/mother-of-all-monads.html instead
07:04:47 <mmorrow> bombshel2er13:   foo >>= \x -> ....    =~=    foo $ \x ->
07:05:07 <cads> lambdabot, how do I send messages?
07:05:31 <cads> @help
07:05:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:06:11 <mmorrow> @tell
07:06:12 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
07:06:14 <chessguy_work> mmorrow, what is =~= ?
07:06:34 <mmorrow> some off the cuff symbol for  "is similar to"
07:07:05 <chessguy_work> oh, ok
07:07:09 <mmorrow> in hindsight that was kinda random i guess ;/
07:07:59 <petrosian> Anyone here familia with the HBC compiler?
07:08:06 <chessguy_work> mmorrow, actually, it was my leading guess, i just wasn't sure
07:08:15 <petrosian> Trying to translate some code written for HBC that uses some of the unsafe primitives
07:08:50 <chessguy_work> in http://blog.sigfpe.com/2008/12/mother-of-all-monads.html when he has the picture with the "hole", is he talking about some function other than ex1 x = do ... b <- return x ... ?
07:09:14 <chessguy_work> because if so, i don't get it
07:09:26 <chessguy_work> but if not, i don't get the next snippet
07:11:03 <Axman6> @src Cont
07:11:03 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
07:11:23 <Axman6> o.O
07:11:57 <quicksilver> chessguy_work: he's generalising
07:12:08 <quicksilver> chessguy_work: saying 'instead of 10, let's consider an arbitrary hole here'
07:12:15 <chessguy_work> quicksilver, sure, but the function i just gave generalizes too
07:12:30 <chessguy_work> quicksilver, the question is, is he generalizing in a different way somehow
07:12:47 <quicksilver> well his hole really covers the return
07:12:54 <quicksilver> so his picture is a bit confusing
07:13:00 <quicksilver> but yes, you have the right idea.
07:13:01 <chessguy_work> oh!
07:13:05 <chessguy_work> yes, that makes more sense
07:13:44 <Saizan> do ...; return hole >>= \b -> return (a+b), then fred = \b -> return (a+b)
07:13:44 <quicksilver> return is the simple case (\fred -> fred 10)
07:13:49 <chessguy_work> sure
07:14:55 <Saizan> maybe rather than around it should say after
07:15:18 <sw17ch> I've just started playing with the diagrams package...
07:15:20 <sw17ch> oh what fun!
07:18:19 <chessguy_work> so then the question becomes: why do we want that hole in particular? why not have a hole in the other spot? or both?
07:18:47 <petrosian> Anyone any clue about this HBC stuff?
07:19:44 <Saizan> chessguy_work: no particular reason
07:20:26 <Saizan> chessguy_work: but with two "holes" one will live in the continuation of the other
07:20:37 <chessguy_work> err
07:20:39 <chessguy_work> ok
07:20:47 <chessguy_work> maybe i should get my head around this hole first :)
07:20:56 <chessguy_work> or at least finish reading the article :)
07:22:53 <mmorrow> @src return Cont
07:22:53 <lambdabot> Source not found. My mind is going. I can feel it.
07:23:00 <mmorrow> @src Cont return
07:23:00 <lambdabot> return a = Cont ($ a)
07:23:07 <mmorrow> i always get that backwards
07:23:24 <Saizan> ?djinn a -> Not (Not a)
07:23:24 <lambdabot> f a b = b a
07:23:34 <mmorrow> @pl ($ ($ a))
07:23:34 <lambdabot> ($ ($ a))
07:23:38 <mmorrow> @pl \a -> ($ ($ a))
07:23:38 <lambdabot> flip id . flip id
07:25:57 <mmorrow> , [$ski|S[f][g::Expr->Expr][x]|] :: Expr
07:25:59 <lunabot>  f x (g x)
07:26:37 <mmorrow> , [$ski|SSK[f][g::Expr->Expr][x]|] :: Expr
07:26:39 <lunabot>  luna: No instance for (GHC.Show.Show
07:26:54 <mmorrow> , [$ty| [$ski|SSK[f][g::Expr->Expr][x]\|]  |]
07:26:57 <lunabot>  luna: Exception when trying to run compile-time code:
07:27:06 <mmorrow> , [$ty| [$ski|SSK[f][g::Expr->Expr][x]\|] ::Expr |]
07:27:09 <lunabot>  luna: Exception when trying to run compile-time code:
07:27:15 <mmorrow> hmm
07:28:44 <mmorrow> @. djinn type \a -> ($ ($ a))
07:28:45 <lambdabot> f a b = b (\ c -> c a)
07:29:05 <mmorrow> @type \a -> ($ ($ a))
07:29:06 <lambdabot> forall b a b1. a -> (((a -> b1) -> b1) -> b) -> b
07:29:34 <mmorrow> @. djinn type \a -> ($ ($ ($ ($ ($ ($ ($ a)))))))
07:29:36 <lambdabot> f a b =
07:29:36 <lambdabot>     b (\ c ->
07:29:36 <lambdabot>        c (\ d -> d (\ e -> e (\ f -> f (\ g -> g (\ h -> h a))))))
07:30:20 <mmorrow> @pl \a b ->  b (\ c -> c (\ d -> d (\ e -> e (\ f -> f (\ g -> g (\ h -> h a))))))
07:30:20 <lambdabot> flip id . flip id . flip id . flip id . flip id . flip id . flip id
07:30:25 <mmorrow> heh
07:32:04 <ozy`> @pl iterate (flip id) !! 7
07:32:05 <lambdabot> iterate (flip id) !! 7
07:32:52 <mmorrow> @pl foldr (.) id (repeat 7 (flip id))
07:32:52 <lambdabot> foldr (.) id (repeat 7 (flip id))
07:33:06 <mmorrow> *replicate
07:33:11 <AllNight^> hello :)
07:37:18 <glguy> thoughtpolice, bos owns the domain, shapr the server, mmorrow the new server
07:53:55 <chrisdone> BMeph: ping
07:55:17 <dmead> Saizan, xchat picks up the comma after the redit link in the topic
07:55:31 <Saizan>  /topic
07:56:15 <Saizan> dmead: i guess it happens for every link then?
07:56:27 <chrisdone> are commas valid in URLs?
07:56:41 <dmead> Saizan, yep
07:56:41 <chrisdone> or speech marks?
07:56:48 <dmead> chrisdone, no
07:56:56 <chrisdone> xchat must be fixed?
07:56:57 <dmead> well in cgi paramters they are
07:57:10 <Saizan> " surprises me more
07:57:20 <chrisdone> yeah me too
07:57:44 <dmead> yea, they must have weird string escapes
07:57:51 <dmead> http://www.reddit.com/r/haskell,
07:57:58 <dmead> is what it konq and ff open to
07:59:20 <chrisdone> gnome-terminal gets it right
07:59:29 <chrisdone> xchat is broken
07:59:50 <chrisdone> but it's fairly easy to patch in my experience
08:01:09 <lispy> Man, IRC can be a huge time sink :)
08:01:20 <lispy> I mean, Good morning #Haskell!
08:01:30 * lispy waves
08:01:39 <chrisdone> you sunk my IRC-ship
08:01:59 <chrisdone> :t unwrapMonad
08:02:00 <lambdabot> forall (m :: * -> *) a. WrappedMonad m a -> m a
08:05:07 <chrisdone> :t runErrorT
08:05:08 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
08:05:14 <ozy`> what the...
08:05:29 <ozy`> $ cabal install xmonad
08:05:30 <lunabot>  luna: Not in scope: `cabal'
08:05:31 <AllNight^> hi lispy :)
08:05:32 <ozy`> cabal:
08:05:35 <ozy`> whoops
08:05:51 <ozy`> ^ anyway I've never seen cabal-install do that O_o
08:06:00 <ozy`> just... no error message
08:06:26 <sw17ch> http://code.sw17ch.com/fun/diagram.hs <-- Fun with the diagrams package!
08:06:31 <sw17ch> http://code.sw17ch.com/fun/out.svg <-- the output SVG image
08:06:53 <chrisdone> nice
08:07:22 <Saizan> ozy`: weird, cabal --version ?
08:07:37 <ozy`> Saizan: 0.6.0 / 1.6.0.1
08:10:38 <lilac> @index unwrapMonad
08:10:38 <lambdabot> bzzt
08:10:43 <lilac> @hoogle unwrapMonad
08:10:43 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
08:10:59 <Saizan> ozy`: try with -v3
08:11:16 <lilac> what an unhelpful name. MonadApplicative or similar would make it clear what it did ;-(
08:12:10 <ozy`> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1348#a1348
08:12:22 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1347#a1347
08:12:40 <mreh> scroll down to my polygonTrapezoidArea method, what do you make of it?
08:12:54 <mreh> id like to hear your opinions
08:12:58 <maltem> calling something 'wrapped' in a generic library is indeed not ideal
08:13:00 <ozy`> I wonder if my ~/.whatever is messed up
08:13:37 <chrisdone> :hoogle MonadError
08:14:18 <chrisdone> :hoogle a -> a
08:14:24 <chrisdone> lambdabot: ??
08:14:37 <maltem> @hoogle
08:14:37 <lambdabot> No query entered
08:14:37 <lambdabot> Try --help for command line options
08:14:37 <Saizan> ozy`: i'd guess something like that
08:14:38 <quicksilver> sw17ch: nice, but, byorgey : yewch? "fc" as an exported symbol?
08:14:40 <chrisdone> oh I forgot about the command inconsistency
08:15:11 <paper_cc> chrisdone: seems that :t is the only \bot command with ":"
08:15:46 <Saizan> ozy`: does it matter which package you're trying to install?
08:15:55 <ozy`> Saizan: doesn't seem to
08:16:09 <ozy`> but I just wiped out my ~/.cabal and ~/.ghc anyway
08:16:15 <ozy`> I'll reinstall and see if it works
08:16:28 <Saizan> .ghc is not related..
08:18:07 <sw17ch> quicksilver: i agree... that's a strange one to export :\
08:18:26 <sw17ch> it's covered by fillColor already
08:21:38 <Philonous1> How can I report a bug for the process library? Should I email the maintainer?
08:23:04 <maltem> Philonous: Sounds like a case for libraries@haskell.org
08:23:16 <byorgey> quicksilver: 'fc' is a synonym for 'fillColor'.  I didn't want to have to type 'fillColor' all the time.
08:23:24 <byorgey> sw17ch: nice =)
08:23:43 <byorgey> quicksilver: also, what does 'yewch' mean?
08:23:45 <quicksilver> byorgey: yes, not a good choice to export though.
08:23:51 <Philonous> maltem: Thanks. Is there a tracking system? I wouldn't like to report bugs that are already known.
08:23:53 <byorgey> quicksilver: why not?
08:24:00 <quicksilver> byorgey: it's the noise I make when trying to digest a really badly named exported primitive.
08:24:14 <byorgey> hehe
08:24:29 <sw17ch> it's like "yowch!" with an australian accent
08:24:37 <sw17ch> or, that's how i'd immagine it :)
08:24:56 <quicksilver> it's too short, and doesn't explain itself.
08:25:09 <quicksilver> zipWith fillColor as bs would look much nicer
08:25:12 <quicksilver> (in sw17ch's code)
08:25:14 <maltem> Philonous: I'm not sure of a tracker... If they don't make it obvious where to look things up, they mustn't complain if they receive duplicates!
08:25:33 <sw17ch> quicksilver: actually, i was just about to push that change to my /code
08:25:38 <ozy`> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1348#a1350 <- I forget whether this is a normal error message to get...
08:25:56 <byorgey> quicksilver: well, fillColor is exported too.  I like to provide alternatives.
08:26:15 <sw17ch> http://code.sw17ch.com/fun/diagram.hs <-- tada!
08:26:25 <let_f_> > zipWith (+) [1,2,3] [4,5,6]
08:26:26 <lambdabot>   [5,7,9]
08:26:31 <sw17ch> actually, for this example
08:26:33 <let_f_> > zipWith (+) [[1,2,3], [4,5,6]]
08:26:34 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
08:26:34 <lambdabot>        arising from a u...
08:26:34 <sw17ch> starting with fc was nice
08:26:42 <let_f_> > zipWith (+) [1,2,3] [4,5,6] [7,8,9]
08:26:43 <sw17ch> but i'm throwing this code at some one here at work
08:26:43 <lambdabot>   Couldn't match expected type `[t1] -> t'
08:26:45 <sw17ch> as an example
08:27:05 <Philonous> maltem: Agreed. Thanks again.
08:27:18 <sw17ch> and i wanted better named primitives
08:28:10 <let_f_> > let zippinWith f (x:xs) (y:ys) (z:zs) = f x y z : zippinWith f xs ys zs in zippinWith (+) [1,2,3] [4,5,6] [7,8,9]
08:28:11 <lambdabot>       No instance for (Num (t -> a))
08:28:11 <lambdabot>        arising from a use of `+' at <int...
08:28:16 <let_f_> how do I do recursion in here?
08:28:34 <sw17ch> :t zipWith3
08:28:35 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
08:28:38 <quicksilver> byorgey: given that haskell doesn't have a namespace qualification system which is good enough to be widely used, its prudent to avoid stepping on the short meaningless names
08:28:39 <let_f_> > let zippinWith f [] [] [] = []
08:28:40 <lambdabot>   <no location info>: parse error on input `;'
08:28:41 <quicksilver> IMO.
08:28:54 <let_f_> zipWith3 (+) [1,2,3] [4,5,6] [7,8,9]
08:28:59 <let_f_> > zipWith3 (+) [1,2,3] [4,5,6] [7,8,9]
08:29:00 <lambdabot>       No instance for (Num (c -> d))
08:29:00 <lambdabot>        arising from a use of `+' at <int...
08:29:01 <byorgey> quicksilver: that's a fair point.
08:29:05 <sw17ch> zipWith3 (\x y z -> x + y + z) [1..3], [4..6], [7..9]
08:29:07 <sw17ch> > zipWith3 (\x y z -> x + y + z) [1..3], [4..6], [7..9]
08:29:08 <lambdabot>   <no location info>: parse error on input `,'
08:29:14 <sw17ch> > zipWith3 (\x y z -> x + y + z) [1..3] [4..6] [7..9]
08:29:15 <asgaroth> let_f_: + takes two arguments not three
08:29:15 <lambdabot>   [12,15,18]
08:29:18 <sw17ch> wtf was i just doing there
08:29:33 <sw17ch> commas, what language do i think this is...
08:29:58 <asgaroth> > zipWith3 (((+) .) . (+)) [1,2,3] [4,5,6] [7,8,9]
08:29:59 <lambdabot>   [12,15,18]
08:30:32 <let_f_> > zipWith3 (\x y z -> x+y+z) [1,2,3] [4,5,6] [7,8,9]
08:30:33 <lambdabot>   [12,15,18]
08:31:06 <mreh> how does one change the sign of a number in haskell? e.g. 1 = -1
08:31:12 <idnar> > -5
08:31:13 <mreh> f 1 = -1 what is f?
08:31:13 <lambdabot>   -5
08:31:17 <idnar> > let x = 5 in -5
08:31:18 <lambdabot>   -5
08:31:20 <let_f_> > zipWith3 (\x y z -> 10) [1,2,3] [4,5,6] [7,8,9]
08:31:20 <paper_cc> mreh: negate
08:31:21 <lambdabot>   [10,10,10]
08:31:22 <idnar> er
08:31:22 <byorgey> > let z = ZipList in (\x y z -> x+y+z) <*> z [1,2,3] <*> z [4,5,6] <*> z [7,8,9]
08:31:23 <lambdabot>   Couldn't match expected type `(a -> b) -> a -> b'
08:31:25 <ozy`> > negate 3
08:31:26 <lambdabot>   -3
08:31:36 <idnar> > let x = 5 in -x -- is what I meant
08:31:37 <lambdabot>   -5
08:31:37 <mreh> is - also a unary operator?
08:31:42 <let_f_> > (map . map) (\x -> x*x) [[1,2,3],[4,5,6]]
08:31:43 <lambdabot>   [[1,4,9],[16,25,36]]
08:31:47 <byorgey> > let z = ZipList in (\x y z -> x+y+z) <$> z [1,2,3] <*> z [4,5,6] <*> z [7,8,9]
08:31:48 <lambdabot>       No instance for (Show (ZipList a))
08:31:48 <lambdabot>        arising from a use of `show' ...
08:31:52 <ozy`> mreh: yes and no. it's complicated.
08:31:53 <byorgey> =O
08:32:04 <paper_cc> > map (foldr (+)) . transport $ [[1,2,3], [4,5,6], [7,8,9]]
08:32:05 <lambdabot>   Not in scope: `transport'
08:32:06 <byorgey> no instance for Show ZipList?
08:32:10 <mreh> that's the price you pay!
08:32:14 <paper_cc> > map (foldr (+)) . transpose $ [[1,2,3], [4,5,6], [7,8,9]]
08:32:15 <lambdabot>       Overlapping instances for Show ([[a]] -> [a])
08:32:15 <lambdabot>        arising from a use...
08:32:17 <idnar> byorgey: it really ought to have one :/
08:32:22 <byorgey> seriously
08:32:28 <paper_cc> > map (foldr (+) 0) . transpose $ [[1,2,3], [4,5,6], [7,8,9]]
08:32:29 <lambdabot>   [12,15,18]
08:32:37 <byorgey> I mean, I guess I could write a patch...
08:32:38 <mreh> so it wont object if i pass back "-x" as an answer to a function that returns a Num?
08:32:41 <Twey> Feh
08:32:48 <mreh> do i have to make it explicit in the type of the function?
08:32:54 <paper_cc> mreh: write it like (-x) not -x
08:32:54 <ozy`> mreh: it's a unary operator only when it's least convenient. it's a binary operator at all other times, ie. when it's even less convenient
08:33:02 <Twey> It makes such a bad impression when a web framework generates crap markup
08:33:15 <mreh> i might use negate then :D
08:33:24 <ozy`> mreh: go for it
08:34:33 <idnar> @type \x -> -x
08:34:34 <lambdabot> forall a. (Num a) => a -> a
08:34:43 <idnar> @type (\x -> -x) ?a
08:34:44 <lambdabot> forall a. (?a::a, Num a) => a
08:36:23 <mreh> right, have a look at this beast of a function and tell me what I've done wrong, because it looks uuuugly...
08:36:25 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1352#a1352
08:36:33 <mreh> the one called areaTrapezoid
08:40:23 <mreh> is everyone thinking hard about that one?
08:40:50 <asgaroth> mreh: hmm, you could sortof factor out the call polyArea' in the first case and add signum (x2-x1) * xAxis...
08:41:03 <asgaroth> that way you wouldn't need the guards
08:41:31 <mreh> okay
08:41:36 <mreh> i had a though aswell
08:42:06 <asgaroth> same could be done for the second case of polyArea
08:42:13 <hackage> Uploaded to hackage: data-accessor-monadLib 0.0.1
08:42:13 <hackage> Uploaded to hackage: fft 0.1.3
08:43:50 <mreh> @src signum
08:43:50 <lambdabot> Source not found.
08:44:03 <mreh> signum 0
08:44:08 <paper_cc> > signum 0
08:44:09 <mreh> > signum 0
08:44:10 <lambdabot>   0
08:44:10 <lambdabot>   0
08:44:37 <asgaroth> mreh: hmm, I guess that would work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1352#a1353
08:47:04 <redditbot> BHLog : Notes from PADL
08:47:45 <mreh> i like it
08:47:51 <mreh> much more concise
08:48:26 <asgaroth> you could probably replace the explicit recursion by using foldr or such as well, but I don't know whether that'd make it clearer
08:48:27 <mreh> it may be fluke that we can use signum this time, but it works
08:48:57 <asgaroth> or maybe not, since you need the two first elements
08:49:10 <mreh> do you guys have some kind of foldl foldr boot camp? i need to practice
08:49:39 <mreh> you need the first one again at the end of the list, you could just fold over vs ++ [head vs]
08:49:48 <mreh> that's pretty idiomatic in haskell
08:50:07 <Nafai> w00t
08:50:26 <Nafai> I'm giving an impromptu introduction to Haskell for our engineering team today
08:51:17 <pejo> mreh, Graham Hutton has a good article on his homepage about the expressivity of fold: http://www.cs.nott.ac.uk/~gmh/fold.pdf
08:51:34 <byorgey> Nafai: cool! good luck!
08:51:44 <Nafai> Thanks
08:52:05 <mreh> oh yeah, the old fold paper
08:52:33 <mreh> split some wigs
08:52:44 <byorgey> mreh: http://haskell.org/haskellwiki/Stack_overflow is also a good thing to read to understand the difference between foldl and foldr.
08:55:11 <mreh> are there any self employed haskell programmers here?
08:55:21 <mreh> or have they all starved
08:55:39 <bran_> you mean garbage collected
08:55:56 <lstor> You mean gone out of scope and created a memory leak
08:55:58 <mreh> they collect garbage? oh dear
08:56:56 <mreh> can you get a memory leak in a haskell program?
08:57:24 <Cheshire> mreh, apparently you can but I've never seen one
08:57:25 <paper_cc> mreh: you can, if you overuse the evil Foreign
08:58:11 <mreh> haha, sounds like a fairy tale
08:58:23 <asgaroth> Don't mistake that sentence for xenophobia though :)
08:58:27 <mreh> to scare young engineers
08:58:30 <mreh> haha, no, i got it
08:59:14 <mreh> this second chapter of HSOE has taken me all week
09:00:06 <mreh> i could have received each one as part of a series
09:02:28 <mreh> is there a way to declar a module's interface by exclusion?
09:05:16 <paolino> would be nice :)
09:17:33 <sw17ch> second rendition: http://sw17ch.is-a-geek.com/~john/fun/out2.svg
09:17:50 <mdmkolbe> What is the easiest way to do asynchronous IO in Haskell?
09:17:53 <sw17ch> code: http://code.sw17ch.com/fun/diagram2.hs
09:18:24 <sw17ch> err: better link for the svg --> http://code.sw17ch.com/fun/out2.svg
09:24:53 <selmanj> I'm having a dumb issue with types and the Random module that I can't figure out.  I'm trying to force the 'random' function to return a Double, but I'm getting a weird type error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1354#a1354
09:24:56 <quicksilver> mdmkolbe: threads.
09:25:54 <quicksilver> selmanj: according to haskell, those "g"s are different. That is, the "g" in line 3 and the "g" in line 6.
09:26:10 <mdmkolbe> quicksilver: you mean like with forkIO and maybe an MVar to for the thread worker to report the answer back to the main thread?
09:26:36 <quicksilver> The fix is either (1) turn on -XScopedTypeInstances and add a 'forall' before the sig in line 3 or (2) annoted the type of 'r' instead of 'rand'.
09:26:39 <quicksilver> mdmkolbe: yes.
09:27:47 <selmanj> quicksilver: out of curiousity, why does the compiler think they are different?  Is it because there's no way to express that both types of 'g' refer to the same value?
09:28:30 <quicksilver> selmanj: there is no way to express that both 'g's are intended to be the same type variable
09:28:41 <quicksilver> selmanj: separate type signatures have entirely separate variable scopes.
09:28:54 <quicksilver> unless you turn on -XScopedTypeVariables which is designed for exactly this kind of problem ;)
09:29:04 <selmanj> quicksilver: that makes sense.  Ok, I'll settle for typing 'r'.  thanks :)
09:29:36 <quicksilver> ;)
09:31:41 <mdmkolbe> Is MVar the simplest/most-efficient/most-basic syncrhonizing variable type?
09:32:55 <quicksilver> mdmkolbe: Yes.
09:33:32 <mdmkolbe> thx
09:38:36 <Twey> module paulaBean (getPaula) where paula, getPaula :: String; paula = "Brilliant"; getPaula = paula
09:39:04 <p_l_> ...
09:39:33 <Twey> Something just called that to mind.  :-P
09:39:33 <p_l> Paula Bean is everywhere?
09:39:48 <lilac> Twey: s/Brilliant/Brillant/
09:39:57 <Twey> Oh yes.  Pardon me.  :-P
09:40:32 <Twey> Haha, I don't know why everyone's started calling her Paula Bean.  I think someone missed the fact that that class was actually a Java bean, or maybe they're just playing on the title.
09:40:46 <lilac> module PaulaBean (getPaula) where data PaulaBean = { getPaula :: String }; paula = PaulaBean "Brillant"
09:40:56 <ehird> lilac: I wrote that code!
09:41:07 <lilac> snap?
09:41:12 <Twey> Hahaha
09:41:14 <doserj> module UtilBool where isTrue x = if x == True then True else False
09:41:15 <ehird> I put it on hpaste a while ago
09:41:16 <lilac> ehird: that means i get all your code
09:41:23 <ehird> it was identical
09:41:24 <ehird> 100%
09:41:26 <Twey> :-D
09:41:27 <ehird> except with newlines
09:41:34 <quicksilver> all ur code is belong to lilac. new game.
09:41:53 <Twey> You can't replicate the dodgy naming in Haskell, can you
09:42:04 <dons> ?seen Axman
09:42:04 <lambdabot> I haven't seen Axman.
09:42:19 <sw17ch> hi dons
09:42:22 <dons> hey!
09:42:27 <chessguy_work> what in the world are you guys talking about?
09:42:38 <dons> did you guys notice we're slowly climbing back up the shootout? http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
09:42:52 <dons> and even without the regex-pcre parallel entry
09:42:56 <Philonous> @seen Axman6
09:42:56 <lambdabot> I saw Axman6 leaving ##freebsd, #macosxdev, #haskell and #macosx 1h 34m 35s ago, and .
09:42:57 <sw17ch> yay for win over Java again
09:43:00 <Twey> chessguy_work: The brillant Paula Bean!
09:43:01 <chessguy_work> dons, were we doing badly for a while?
09:43:18 <dons> no, not really. we were stuck though
09:43:25 <Twey> Ooh
09:43:26 <Cheshire> > 1+1
09:43:27 <lambdabot>   2
09:43:33 <chessguy_work> Twey, oh, i see now
09:43:41 <Twey> 1.5, missing 1?
09:43:54 <Twey> Which are we missing?
09:43:59 <Twey> Oh, regex-dna
09:44:04 <Cheshire> > 1+2
09:44:05 <lambdabot>   3
09:44:31 <Twey> What happened here?
09:45:39 <chessguy_work> wow, poor Rubyb
09:45:45 <chessguy_work> probably mis-represented
09:46:16 <Twey> No, I don't think so
09:46:34 <Twey> The older versions of MRI were horribly slow
09:46:55 <Twey> Only language I've seen whose native interpreter was slower than its Java counterpart...
09:49:51 <Twey> The build failed because of a missing package, which the program mentions, and they just left it?  x.x
09:51:05 <sm> so.. gtk uses it's own look and feel while wx uses the platform's, is that right ?
09:51:30 <Twey> sm: To some extent
09:51:47 <Twey> Of course, under X wx is implemented using GTK+ anyway...
09:55:37 <Philonous> libraries@haskell.org seems to be a bad place to send bug reports to. Is there maybe someplace else to report bugs to?
09:56:58 <SamB_irssi> Philonous: GHC trac
09:57:18 <Philonous> For packages on hackage as well?
10:09:35 <sm> other findings on gtk vs wx:
10:10:02 <sm> both built out of the box on leopard (maybe because I did this before)
10:10:25 <sm> gtk has more developers, users and better organization
10:11:13 <sm> simplicity of code in hello world is the same
10:11:21 <Cheshire> how do you read  Î“ // Ï‰3 âŠ¢ F : Ï„1 /Ï‰1 â†’ Ï„2 /Ï‰2 // Ï‰4   Î“ // Ï‰2 âŠ¢ E : Ï„1 Ï‰3 ==> Î“ // Ï‰1 âŠ¢ F E : Ï„2 // Ï‰4  ?
10:12:00 <sm> wx 0.11's apps aren't recognised by the osx window manager
10:13:45 <rwbarton> dons: do you know what is up with the pidigits shootout entry?  on my machine it runs twice as fast under ghc-6.8.2 or ghc-HEAD as under ghc-6.10.1 (and in much lower space)
10:14:55 <BMeph> chrisdone: pong
10:15:08 <pejo> sm, isn't there a script that you run on the binary to make it a "real" application?
10:15:25 <BMeph> chrisdone: Did I completely miss the point of your post? :)
10:15:26 <dons> rwbarton: i think its a bug in 6.10.1
10:15:29 <snhmib> isn't this function tail recursive? f _ 0 acc = acc, and f b c acc = f b (c-1) (acc+b)
10:15:37 <dons> rwbarton: we need to check against the 6.10.2 RC and file a bug report
10:15:39 <dolio> Cheshire: Seems like that'd be something that'd be explained in the paper you got that from.
10:15:44 <rwbarton> dons: yeah, I just saw what you wrote on the wiki discussion apge
10:15:47 <dolio> Or, at least, in a previous paper that it's building on.
10:15:58 <sm> pejo: that could be.. I thought that was just for packaging. The app appears but.. I'll try it
10:16:03 <dons> rwbarton: a bug report now would be good in fact..
10:16:04 <snhmib> if i make c bigger ghci gives stack overflow :S
10:16:15 <fsanches> snhmib: I think it's not recursive
10:16:25 <fsanches> snhmib: *tail recursive
10:16:32 <rwbarton> dons: I just wondered if it was a known bug, since it seems to be fixed in HEAD (though not necessarily the 6.10.2 RC I guess)
10:16:34 <Cheshire> snhmib, "tail recursive" in haskell is meaningless
10:16:42 <snhmib> oh
10:16:46 <dons> rwbarton: well, not sure. JaffaCake will know.
10:16:48 <dons> or igel
10:16:50 <dons> Igloo:
10:17:02 <Cheshire> snhmib, if you write a tail recursive (in the ocaml/scheme sense) function that has no bearing on how many 'stack frames' or whatever got allocated
10:17:24 <mmorrow> , [$ski|SSK[f][g::Expr->Expr][x]|] :: Expr
10:17:26 <lunabot>  luna: No instance for (GHC.Show.Show
10:17:35 <mmorrow> , [$ski|S[f][g::Expr->Expr][x]|] :: Expr
10:17:37 <lunabot>  f x (g x)
10:17:47 <Cheshire> mmorrow, coool
10:17:51 <mmorrow> :)
10:18:03 <Cheshire> , [$ski|SSS|] :: Expr
10:18:04 <rwbarton> dons: maybe I'll email g-h-u
10:18:05 <lunabot>  luna: Couldn't match expected type `Luna.SimpleReflect.Expr'
10:18:11 <Cheshire> , [$ski|SS|] :: Expr
10:18:13 <lunabot>  luna: Couldn't match expected type `Luna.SimpleReflect.Expr'
10:18:16 <Cheshire> , [$ski|Sxyz|] :: Expr
10:18:18 <lunabot>  luna: Couldn't match expected type `Luna.SimpleReflect.Expr'
10:18:19 <arjanb> snhmib: the stack overflow happens when it is evaluating the long chain of +
10:18:22 <mmorrow> it was just Expr since i had embedded haskell
10:18:25 <Cheshire> , [$ski|S[x][y][z]|] :: Expr
10:18:27 <lunabot>  luna: Couldn't match expected type `Luna.SimpleReflect.Expr -> t'
10:18:38 <mmorrow> , [$ski|SIKI|]
10:18:40 <lunabot>  K :$ I
10:18:50 <mmorrow> , [$ty| [$ski|SIKI\|] |]
10:18:52 <BMeph> rwbarton: I seem to recall is being logged as found and fixed.
10:18:53 <lunabot>  SKI
10:19:01 <Cheshire> o-o
10:19:01 <mmorrow> , [$ty| [$ski|[fix]\|] |]
10:19:01 <snhmib> arjanb: i thought i avoided that with the accumulator argument :(
10:19:04 <lunabot>  forall a . (a -> a) -> a
10:19:09 <mmorrow> , [$ty| [$ski|[id]\|] |]
10:19:11 <lunabot>  forall a . a -> a
10:19:55 <rwbarton> snhmib: the applications of + don't get computed during the f "loop"
10:20:27 <snhmib> so i should make the accumulator argument strict?
10:20:29 <mmorrow> , [$ski|S[(,)][show][42]|]
10:20:31 <lunabot>  (42,"42")
10:20:36 <snhmib> that's with a ! somewhere right?
10:21:33 <Cheshire> snhmib, what are you trying to compute
10:21:33 <Cheshire> ?
10:21:36 <Cheshire> , [$ty| [$ski|[x]\|]|]
10:21:38 <lunabot>  Expr
10:21:46 <Cheshire> , [$ty| [$ski|K[x][y]\|]|]
10:21:49 <lunabot>  Expr
10:21:51 <rwbarton> BMeph: ah, perhaps it is http://hackage.haskell.org/trac/ghc/ticket/2747
10:22:09 <mmorrow> Cheshire: if it reduces to no SKI anything and just a haskell expression (embedded in [...]), it splices the expression as a real val, but if there are and S,K,or Is left, it prettyprints the expression inside the SKI expression
10:22:23 <snhmib> Cheshire: (*) :)
10:22:38 <BMeph> rwbarton: Yes, I think that's it. Nice catch! :)
10:22:42 <mmorrow> Cheshire: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1306#a1307
10:23:08 <mmorrow> , [$ski|SIKI[\x->x]|]
10:23:10 <lunabot>  I
10:23:13 <mmorrow> grr
10:23:54 <mmorrow> , [$ski|SIK[\x->x]|]
10:23:56 <lunabot>  (\x -> x) :$ K :$ \x -> x
10:24:17 <snhmib> yay it works with $!
10:24:24 <snhmib> thanks all =)
10:24:47 <mmorrow> , [$ski|SSIK[\x->x*2]|] 42
10:24:48 <sm> giving up on wx's macosx-package, too hard and undocumented and I think not related to this problem
10:24:49 <lunabot>  84
10:25:22 <ozy`> sm: OS X is a second-class citizen in the haskell world
10:25:29 <sm> more trivia: gtk's helloworld binary is 0.5M, wx's is 9M
10:25:55 <ozy`> ouch
10:26:21 <Cheshire> :t \e ->  \c -> (\f -> e f) (\x c' -> c' (c x)) (\x -> x)
10:26:22 <lambdabot> forall t t1 t2 t3 t4. ((t2 -> (t3 -> t1) -> t1) -> (t4 -> t4) -> t) -> (t2 -> t3) -> t
10:26:25 <sm> 10, actually
10:26:50 <pejo> ozy, is it? Igloo got a mac quite recently.
10:26:59 <mmorrow> , [$ski|SSK(S(SSK))|]
10:27:01 <lunabot>  (S :$ S :$ (S :$ S) :$ K) :$ K :$ S :$ (S :$ S) :$ K
10:27:04 <mmorrow> , [$ski|SSK(S(SSK))I|]
10:27:07 <lunabot>  luna: out of memory (requested 1048576 bytes)
10:27:23 <mmorrow> apparently that one blows up once you apply it to anything
10:27:58 <sm> finally: gtk2hs lists seems to be full of people getting stuff done, wxhaskell lists seem to be full of people having problems. Correct me if your experience differs..
10:28:40 <mmorrow> , (\x -> [$ski|S[(,)][id][x]|]) 42
10:28:42 <lunabot>  (42,42)
10:28:44 <Cheshire> , [$ski|SSSSSSSSSSSSSSS|]
10:28:46 <lunabot>  (S :$ S) :$ (S :$ S) :$ (S :$ S) :$ (S :$ S) :$ (S :$ S) :$ (S :$ S) :$ (...
10:28:51 <Cheshire> what
10:28:55 <Cheshire> , [$ski|SSS|]
10:28:57 <lunabot>  (S :$ S) :$ S
10:29:02 <sm> conclusion: attractive end-user guis at least on mac are barely possible with haskell as yet
10:29:09 <Cheshire> , [$ski|SKCK|]
10:29:11 <lunabot>  S :$ K
10:29:18 <Cheshire> , [$ski|SXKCK|]
10:29:20 <lunabot>  S
10:29:25 <lament> sm: :(
10:29:26 <pejo> sm, aren't there cocoa-bindings somewhere?
10:29:47 <mmorrow> weird, i dunno what 'X' gets parsed as there..
10:29:56 <mmorrow> , [$ski|X|]
10:29:58 <lunabot>  luna: ski: parse error
10:30:02 <mmorrow> , [$ski|SX|]
10:30:05 <lunabot>  S
10:30:07 <mmorrow> wut
10:30:09 <rwbarton> , [$ski|C|]
10:30:11 <lunabot>  luna: ski: parse error
10:30:12 <lament> sm: i think the best option would be to have a Cocoa application with foreign bindings to haskell
10:30:12 <byorgey> huh?  why does SSSSSSSSS parse as (SS)(SS)(SS)... ?
10:30:17 <mmorrow> , [$ski|SC|]
10:30:19 <lunabot>  S
10:30:21 <lament> sm: but i've never actually tried that, just seems like it should work
10:30:21 <mmorrow> ohhh
10:30:22 <Cheshire> byorgey, I think it evalates into that
10:30:34 <mmorrow> my parser will parse the prefix up until an error
10:30:34 <byorgey> ah, that would make more sense =)
10:30:44 <mmorrow> that's kindof buggish
10:30:49 <rwbarton> , [$ski|SSS|]
10:30:51 <lunabot>  (S :$ S) :$ S
10:30:53 <rwbarton> , [$ski|SSSS|]
10:30:55 <lunabot>  (S :$ S) :$ S :$ S
10:30:58 <mmorrow> , [$ski|SZOMGOMGOMG|]
10:31:00 <lunabot>  S
10:31:12 <Cheshire> How have you learned linear logic?
10:31:16 <Cheshire> everyon
10:31:18 <Cheshire> ?
10:31:26 <rwbarton> shouldn't it evaluate to (SS)(SS)S?  SSSS I mean
10:31:31 <mmorrow> byorgey: it's parsing + reducing
10:31:43 <rwbarton> oh wait
10:31:45 <mmorrow> i dunno
10:31:47 <sm> pejo: good point, though of course ideally one would like to write once run everywhere. Are you thinking of http://hoc.sourceforge.net/ ?
10:31:54 <Cheshire> mmorrow, you don't have to have an explicit (:$) constructor
10:32:07 <byorgey> mmorrow: I see, that makes sense
10:32:08 <Cheshire> if you drop that you have got normal forms only
10:32:17 <ddarius> Cheshire: There are quite a few resources and introductions.
10:32:19 <mmorrow> Cheshire: but i'm embedding haskell code inside
10:32:22 <pumpkin> sm, pejo: there's a vague movement to start another such thing at #hobjc
10:32:40 <xcthulhu> Cheshire: Oxford Handbook of Phil Logic is a good place to start.  And Dov Gabbay has a paper on linear logic and importing the Curry-Howard Isomorphism
10:32:44 <mmorrow> hmm
10:32:49 <MichaelGG> What's the most concise way of taking a list of ints, and turning them into contiguous-range tuples? i.e. 1;2;3;7;8;10 to (1,3);(7,8);(10,10)?
10:32:49 <pumpkin> 0xF0rD
10:32:58 <mmorrow> Cheshire: yeah, maybe that would be nicer actually (w/out (:$))
10:33:19 <pumpkin> MichaelGG: explicit recursion I'd say
10:33:41 <geezusfreeek> hmm... haskell's green threads are still 9 times faster than my pure haskell cooperative threads. i was hoping for a smaller gap
10:33:52 <mmorrow> Cheshire: err, so what are you thinking for S for example?  S SKI SKI SKI     ?
10:34:05 <mmorrow> I SKI    K SKI SKI
10:34:09 <mmorrow> ?
10:34:12 <Cheshire> what
10:34:19 <Elly> are we trolling with SK calculus now?
10:34:29 <mmorrow> how would you modify the datatype to eliminate (:$) ?
10:34:31 <nms2> Hi all
10:34:47 <sm> pumpkin: good to know. I really want something cross-platform, and of course production-ready today, and a pony. I suppose gtk acquiring native widgets support soon is unlikely ?
10:34:50 <Cheshire> if you can hold:
10:34:53 <rwbarton> , src ''SKI
10:34:56 <lunabot>  data SKI = S | K | I | E Exp | SKI `(:$)` SKI
10:34:59 <Cheshire> S, Sx, Sxy, K, Kx
10:35:05 <Cheshire> that is the normal forms
10:35:16 <mdmkolbe> I take your cross-SKI and raise it a SKI-Jump
10:35:22 <sm> so I believe that leaves html/css/js for crossplatform uis
10:35:25 <Cheshire> so instead of (:$) constructor, you have ($) function
10:35:35 <pumpkin> sm: quite unlikely :P the other issue is that GUI paradigms change across platforms, so ultimately you'd want to specify your GUI more abstractly than "place a button here and a text box here, with a toolbar here"
10:35:36 <Cheshire> K $ x = Kx
10:35:41 <Cheshire> Kx $ y = x
10:35:43 <Cheshire> etc
10:35:56 <MichaelGG> pumpkin, yea youre right
10:35:58 <mmorrow> so you would parse them as already being normal forms?
10:36:02 <pumpkin> sm: and of course you want it to be beautiful and reactive
10:36:13 <Cheshire> mmorrow, no you just build them up using $ instead of :$
10:36:17 <mmorrow> or you would essentially be just merging the parsing and eval stages
10:36:25 <Cheshire> the result is that everything is in normal form + you have lazy evaluation
10:36:27 <geezusfreeek> err, GHC's threads, that is
10:36:39 <Cheshire> mmorrow, you could use that data SKI for a parse tree
10:36:53 <Cheshire> then fold into my domain
10:36:55 <sm> ideally, yes. There *is* an excellent free js gui toolkit: qooxdoo. GTK is much more powerful though
10:37:46 <pumpkin> sm: qooxdoo does look nice, but it looks different from any "native" widget set too
10:38:10 <sm> for sure
10:38:12 <mmorrow> Cheshire: cool, i'll play with that idea when i mess with [|$ski again
10:38:21 <tromp> what about normal forms like xSKS?
10:38:33 <Arnar> hi all
10:38:49 <Cheshire> xSKS is not a normal form
10:38:50 <Arnar> anyone have experience with Haskell wiki software (e.g. flippi or pandocwiki)?
10:38:51 <sm> so for native widgets, dealing with wxhaskell issues is the only game in town
10:39:25 <gwern> Arnar: man, nobody uses those these days
10:39:32 <gwern> Arnar: all the cool kids use gitit or orchid
10:41:11 <chrisdone> BMeph: did you get my email?
10:41:33 <geezusfreeek> Arnar, i have used gitit and likedit
10:41:40 <BMeph> chrisdone: Let me check; my silly boss actually expected work from me this morning... ;p
10:41:40 <chrisdone> gwern: s/use/use and write/
10:41:41 * gwern is playing n-back. man this is hard; and I'm only on 2-back and I'm ignoring the sounds!
10:42:06 <chrisdone> BMeph: tut!
10:42:11 <Cheshire> gwern, n-dimensional backgammon?
10:42:14 <gwern> chrisdone: no, I think more people use gitit/orchid than are actually developing them. since the devs are basically me, john, and sebaastian
10:42:16 <Arnar> gwern, geezusfreeek: ooh.. sounds good
10:42:22 <gwern> Cheshire: no, a working memory drill
10:42:34 <chrisdone> gwern: mhm :-P
10:42:43 <gwern> Cheshire: see https://secure.wikimedia.org/wikipedia/en/wiki/N-back
10:46:04 <Cheshire> oh it's a bit like  just a minuite
10:47:06 <redditbot> Building a high performance WAVE file reader
10:47:18 <gwern> yes, that's *exactly* like n-back
10:47:28 <gwern> (if you ignore all the ways they differ :))
10:49:25 <chrisdone> ØŸÂ¿high performanceâ€½?
10:49:41 <chrisdone> why doesn't redditbot give us links? srsly
10:51:50 <gwern> chrisdone: nobody has bothered to add it
10:51:55 <gwern> redditbot: version
10:52:31 <gwern> (ah well. I'd look at the source if I could)
10:55:01 <dons> links are added. see rss2ird
10:55:02 <dons> irc
10:55:06 <dons> they're too verbose though
10:55:19 <dons> needs is.gd or tinyurl-ifying. and pumpkinbot needs to ignore it.
10:55:37 <thetallguy> Hmm... I don't see any prime factorization code in any library.  Am I missing something?
10:55:56 <gwern> dons: why not print the links and let pumpkin/lb tinyurl them?
10:56:18 <zachk> thetallguy: write your own factorization code :D
10:56:20 <rwbarton> pumpkinbot does ignore them.
10:56:37 <asgaroth> thetallguy: I found this, but I don't know how good it is perfomance-wise: http://hackage.haskell.org/packages/archive/Crypto/4.1.0/doc/html/src/Codec-Encryption-RSA-NumberTheory.html#factor
10:56:41 <dons> gwern: that was the problem. we ended up with 4 lines of text per item.
10:56:42 <thetallguy> zachk: write your own compiler.
10:56:46 <dons> check the logs
10:56:51 <zachk> have you?
10:56:57 <zachk> i know im still a newb
10:57:03 <zachk> cause i havent written my own compiler yet
10:57:21 <zachk> but i did get n-body going with opengl so i am a happy newb
10:57:22 <rwbarton> dons: that was PeakerLambda, which had an old configuration, and was only around briefly.  currently we'd only get one line per item, it'd just be long.
10:57:38 <gwern> dons: 4? one for the title, one for the long link, and one for lb's tiny url reply. where's the last coming from?
10:57:44 <Cheshire> thetallguy, i's NP complete
10:58:06 <dons> then one that looks up the title again
10:58:07 <thetallguy> asgoroth: hmm... hoogle is not showing htat.
10:58:09 <chrisdone> tinyurl's API is complex but usable http://tinyurl.com/api-create.php?url=http://haskell.org
10:58:22 <thetallguy> Cheshire: what's your point?
10:58:33 <Cheshire> just sayin'
10:58:36 <dons> it was way too noisy. so if someone wants to look at it again, all the code is in lambdabot and rss2irc
10:58:44 <thetallguy> zachk: why shouldn't prime factorization be in a library?
10:58:47 <rwbarton> dons: it wouldn't be as noisy now
10:58:52 <pumpkin> dons: I already turned off URL reposting on pumpkinbot :)
10:59:02 <pumpkin> but it hasn't been around much as lambdabot has been working more
10:59:06 <chrisdone> lambdabot just needs an /ignore
10:59:17 <rwbarton> lambdabot has been ignoring URLs for a long time now
10:59:21 <dons> ok. and can we get rss2irc to not print the long url, just the tinyurl?
10:59:26 <dons> then we might be ok.
10:59:40 <dons> maybe we need an is.gd , twurl or tinyurl lib?
10:59:51 <chrisdone> I was thinking that
11:00:12 <paper_cc> [offtopic] is there a good image manipulation library around?
11:00:18 <gwern> imagemagick
11:00:24 <thetallguy> asgoroth: thanks, that should suffice
11:00:28 <asgaroth> thetallguy: hoogle doesn't since it isn't in the standard libs. hayoo can also search hackage packages
11:00:40 <thetallguy> I don't find it in hayoo either
11:01:00 <asgaroth> that link finds it for me : http://holumbus.org/hayoo/hayoo.html?query=factor
11:01:20 <rwbarton> @bot
11:01:20 <lambdabot> :)
11:01:20 <lunabot>  :)
11:01:26 <thetallguy> oh, I added an `s` and it's singular. ;-)
11:01:52 <thetallguy> not sure whether I should adjust my caffeine levels up or down.
11:02:27 <pumpkin> when in doubt, turn them down
11:02:28 <paper_cc> gwern: is a Haskell binding available?
11:03:43 <chrisdone> dons: what module namespace would a small url maker come under? Network or Text, or Web(?)?
11:03:57 <gwern> paper_cc: not that I know of
11:04:16 <dons> Network.* ?
11:04:16 <pumpkin> lol, there's a lib opposite to what we need
11:04:20 <pumpkin> a longurl one :)
11:04:24 <pumpkin> it extends shortened urls
11:04:25 <gwern> chrisdone: wouldn't it have to go under network? since you need to request the small url website to make you one
11:04:34 <chrisdone> yeah i thought so
11:04:39 <pumpkin> Network.URL.Compress? :P
11:04:42 <chrisdone> bbs, dinner
11:04:44 <chrisdone> pumpkin: heh
11:04:51 * paper_cc looks at a 2007 cafe message about an ImageMagick binding
11:05:21 <rwbarton> dons: you could also effectively decrease the amount of noise by increasing the frequency of updates to once every 15 min or so
11:05:31 <rwbarton> then we won't get five lines of updates at once as often
11:07:41 <paper_cc> gwern: looks like http://community.haskell.org/~tim/ has a magick binding
11:08:26 <gwern> paper_cc: but how complete is it?
11:08:53 <paper_cc> it isn't
11:09:30 <gwern> guess paper_cc knows how he'll be spending his free time this week
11:09:39 <thorkilnaur> thetallguy, What size of numbers do you wish to factor? And how many? Just to get a rough idea. I have some factorization code, never published, somewhat inconveniently packaged, that you may be interested in.
11:09:44 <paper_cc> hehe
11:09:48 <rwbarton> I found imagemagick buggy and poorly documented when I dealt with it a few years ago, but couldn't find a better replacement
11:10:06 <rwbarton> I'm talking about the command-line programs mostly
11:10:29 <Elly> you mean convert and friends?
11:10:31 <Elly> I <3 convert
11:10:47 <gwern> well, convert has never destroyed a file of mine so far as I know, so I use it
11:10:50 <gwern> besides that the docs are hard
11:11:13 <lepassive> I want some help with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1358#a1358
11:11:43 <paper_cc> a really interesting question would be an unified interface for CPU and GPU version of image manipulation functions ... combinators?
11:12:01 <asgaroth> lepassive: you need an return $ .. in line 17
11:12:16 <asgaroth> lepassive: ah, ignore that, mapM_ is what you need
11:12:33 <gwern> paper_cc: sounds very difficult and with little marginal return. so a good research paper
11:12:48 <asgaroth> and some parentheses in the argument to mapM_ and some reodering of the parameters
11:13:23 <lepassive> asgaroth, still      Couldn't match expected type `IO t' against inferred type `()'
11:13:29 <rwbarton> gwern: when I used it it had simple bugs like this which were caused by careless use of floating point: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=337837
11:13:34 <thetallguy> thorkilnaur: well, I got the prime factors then immediately realized I needed to generate all combinations... which is a list of divisors, which I already have.
11:13:59 <paper_cc> gwern: why? texture manipulation is a good point for GPUs - a good and specialized stream processing task
11:14:39 <thetallguy> thorkilnaur: so, at the moment, I don't.  Still, I find that there is a dearth of this kind of functionin the libraries, I think because professors like to give them as homework examples and because they are quick to whip up
11:14:48 <thorkilnaur> thetallguy, Ok, so no need for heavy factorization machinery, then
11:14:50 <thetallguy> so nobody thinks it worth putting them in.
11:14:53 <pumpkin> paper_cc: have you seen gpugen?
11:15:01 <paper_cc> no
11:15:03 <gwern> paper_cc: amdahl's law, man.
11:15:04 <paper_cc> @where gpugen
11:15:04 <lambdabot> I know nothing about gpugen.
11:15:13 <paper_cc> @google gpugen
11:15:14 <lambdabot> No Result Found.
11:15:19 <thetallguy> thorkilnaur: not at the moment, though, but I'd encourage you to add it anyway. ;-)
11:15:28 <gwern> rwbarton: well my use of imagemagick is limited basically to 'convert foo.png foo.jpg'
11:15:35 <rwbarton> gwern: yeah, I think it works ok for that
11:15:40 <asgaroth> lepassive: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1358#a1359
11:15:50 <blueonyx> hi, is there a fgl func for finding all not connected subgraphs in a given graph?
11:15:53 <rwbarton> gwern: but I don't have a high level of trust in it :)
11:16:15 <pumpkin> blueonyx: not connected subgraphs?
11:16:21 <thorkilnaur> thetallguy, For smallish numbers (say up to 20-30 decimal digits), you may be rigt. For really large numbers (say 50-150 digits), the story is different. Also primality testing is not all that simple
11:16:23 <lepassive> thanks asgaroth
11:16:27 <lepassive> @src flip
11:16:27 <lambdabot> flip f x y = f y x
11:16:52 <blueonyx> pumpkin: subgraphs, where no node of a has an edge with a node of b
11:16:57 <pumpkin> paper_cc: http://www.cse.unsw.edu.au/~chak/papers/gpugen.pdf is a draft
11:17:18 <blueonyx> zusammenhangskomponenten would be the german term :/
11:17:29 * paper_cc is reading the gpugen talk abstract
11:17:29 <rwbarton> connected components?
11:17:42 <paper_cc> pumpkin: is it being developed now?
11:17:43 * Cheshire yuck @ argument naming of flip
11:17:51 <lepassive> asgaroth, It yields     Couldn't match expected type `t -> [Char]'
11:17:51 <lepassive>            against inferred type `[Char]' at 37:49 ?
11:18:01 <paper_cc> @where+ gpugen http://www.cse.unsw.edu.au/~chak/papers/gpugen.pdf
11:18:02 <lambdabot> It is forever etched in my memory.
11:18:07 <pumpkin> paper_cc: yeah, I think the one of the authors is in here sometimes too
11:18:16 <BMeph> chrisdone: ping
11:18:24 <asgaroth> lepassive: ah, add a '$' between show and the rest in that line
11:18:45 <thetallguy> thorkilnaur: actually, I was giving other people's reasoning.  For standard math functions, I think it should be in a library regardless.
11:18:47 <thorkilnaur> thetallguy, I have been considering publishing the code as a library, but the packaging is not simple. A lot depends on what you really want to use it for.
11:18:49 <rwbarton> gpugen sounds cool, but I'd also be interested in the equivalent of LLVM or Harpy for GPUs (if such a thing is sensible)
11:19:30 <thetallguy> thorkilnaur: Understood.  Thanks for speaking up.
11:19:34 <lepassive> asgaroth, still :(
11:19:41 <gwern> wonder if extending harpy to gpus would be a sensible soc
11:20:00 <pumpkin> blueonyx: I still don't understand what you're looking for :(
11:20:01 <tibbe> anyone here works at janestreet?
11:20:04 <asgaroth> lepassive: there's also a ++ missing between file and "--"
11:20:29 <thorkilnaur> thetallguy, You are most welcome.
11:20:47 <asgaroth> lepassive: And you want to avoid the code duplication in main, just calling viewEntry on (head args) should be enough
11:21:21 <paper_cc> pumpkin: even a not-so-high-level layer (a version of Expr with Cg-like interface compiled to GPU assembly) would be great I think
11:21:38 <paper_cc> because automatic vectorization is a pain
11:22:11 <chrisdone> BMeph: pong
11:22:56 <BMeph> I sent you a response, but it's easier to say in-IRC.
11:23:23 <BMeph> chrisdone: unwrapMonad :: WrappedMonad m a -> m a
11:23:34 <rwbarton> pumpkin: connected components.  go to http://de.wikipedia.org/wiki/Zusammenhangskomponente and click on English in the lower left :)
11:23:51 <idnar> isn't that lift?
11:23:51 <lepassive> asgaroth, I'm afraid of duplicating that part        allEntries <- getDirectoryContents dir     let entries = allEntries \\ [".", ".."]  I tried to refractor it but doesn't work
11:23:55 <idnar> oh wait, misread
11:24:06 <blueonyx> pumpkin: given http://www.picpaste.de/pics/isooctan.1234380138.png, i want to cut the edge between C_8 and C_6 and then get the connected component of H_26, H_25, H_24 and C_8 as one graph, and the whole rest as another graph
11:24:20 <lepassive> + It only views "files" no dirs!
11:24:20 <BMeph> idnar: It's Stupid type-cloaking Tricks. ;p
11:24:27 <chrisdone> BMeph: mhm..
11:24:45 <blueonyx> rwbarton: thanks :D
11:24:53 <pumpkin> rwbarton, blueonyx: aha!
11:25:06 <rwbarton> blueonyx: how about components in Data.Graph.Inductive.Query.DFS
11:25:18 <BMeph> chrisdone: I.e., you tried to unwral a monad (return l) before you wrapped it first. ;)
11:25:24 <BMeph> *unwrap
11:25:52 <BMeph> chrisdone: I still like the short answer, though... ;p
11:26:09 <chrisdone> BMeph: well, that was with the assumption that it had an instance of Monad
11:26:53 <let_f_> would it be hard to make interfaces to webAPIs like yahoo boss etc for haskell?
11:27:01 <blueonyx> rwbarton: yea its a start, but then i need the edges too to construct the graph, or?
11:27:05 <chrisdone> > unwrapMonad $ pure 1
11:27:06 <lambdabot>       Ambiguous occurrence `pure'
11:27:06 <lambdabot>      It could refer to either `Control.Appl...
11:27:17 <chrisdone> > unwrapMonad $ Control.Applicative.pure 1
11:27:18 <let_f_> or you can call it through some haskell-python ffi?
11:27:18 <lambdabot>       No instance for (Show (m a))
11:27:18 <lambdabot>        arising from a use of `show' at <in...
11:27:47 <chrisdone> > unwrapMonad $ Control.Applicative.pure 1 :: Maybe Integer
11:27:48 <lambdabot>   Just 1
11:27:50 <idnar> @type unwrapMonad $ Control.Applicative.pure 1
11:27:51 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
11:27:57 <rwbarton> blueonyx: oh
11:28:03 <chrisdone> BMeph: I don't need WrapMonad here..
11:28:05 <idnar> @type unwrapMonad
11:28:06 <lambdabot> forall (m :: * -> *) a. WrappedMonad m a -> m a
11:28:56 <chrisdone> BMeph: how do you use WrappedMonad?
11:29:18 <chrisdone> what's the point in wrapping a monad with WrapMonad??
11:29:24 <bblueonyx> ah its Data.Graph.Inductive.Query.BCC
11:29:46 <rwbarton> blueonyx: that is something else though
11:30:37 <bblueonyx> i got an undirected graph, so what do you mean?
11:30:56 <idnar> @hoogle unwrapMonad
11:30:57 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
11:31:25 <idnar> @type unwrapMonad $ (Control.Applicative.pure 1 `asTypeOf` ?x)
11:31:26 <lambdabot> forall (m :: * -> *) a. (?x::WrappedMonad m a, Monad m, Num a) => m a
11:32:09 <rwbarton> bblueonyx: biconnected component means there are at least two paths between any two vertices that don't share any interior vertices in common
11:32:29 <chrisdone> yes, the polymorphic `pure` function creates a WrappedMonad value
11:33:13 <bblueonyx> oh
11:33:27 <drhodes> @users
11:33:27 <lambdabot> Maximum users seen in #haskell: 661, currently: 655 (99.1%), active: 24 (3.7%)
11:33:29 <chrisdone> instance Monad m => Monad (WrappedMonad m) where
11:33:29 <chrisdone>     return = WrapMonad . return
11:33:29 <chrisdone>     a >>= b = WrapMonad $ unwrapMonad a >>= unwrapMonad . b
11:33:36 <chrisdone> this works but probably wrong
11:35:29 <chrisdone> BMeph: do you have a better answer than "doin it rong"?
11:36:14 <rwbarton> bblueonyx: I think you have to use the result of components to build the component graphs manually... annoying
11:36:15 <Cheshire> what is the point in WrappedMonad
11:36:23 <chrisdone> Cheshire: I have no idea
11:36:39 <paper_cc> @instances Applicative
11:36:40 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
11:36:46 <rwbarton> Cheshire: I think it has the Applicative instance that every Monad should have
11:36:46 <bblueonyx> rwbarton: yea think so too, but thanks!
11:36:48 <idnar> it gives you Functor / Alternative / Applicative instances for "free", I guess?
11:36:52 <chrisdone> I thought it was for getting an Applicative/Alternative instance for free
11:36:58 <BMeph> chrisdone: WrappedMonad gives you the Applicative form of a particular Monad, without excluding any other Applicative forms which do not corespond to the same Monad. Hmm, let me try to say that in English, now... ;p
11:37:01 <Cheshire> oh yuck ok
11:37:12 <Cheshire> it sucks yuo have to wrap to implement that
11:37:27 <paper_cc> why not Monad m => Applicative m?
11:38:01 <idnar> paper_cc: wrong way around
11:38:18 <pumpkin> idnar: for some definitions of wrong :P
11:38:23 <BMeph> paper_cc: Because there are (sometimes? usually? always?) more than one way to skin a Monad. ;)
11:38:24 <idnar> well, rather, the problem is you get overlapping instances or whatever
11:38:33 <Saizan> instance Monad m => Applicative m where overlaps with any other instance of Applicative
11:38:55 <chrisdone> BMeph: but I need more than just an applicative instance in my blog post .. I need Monad and MonadIO and MonadError
11:38:56 <Saizan> even for 'm' which are not Monad's
11:39:18 <BMeph> paper_cc: For instance: ZipList is an Applicative made with...well, purists would say that it's made with streams, but we can, and do, use lists for it. :)
11:39:19 <chrisdone> BMeph: well, just monadError, but..
11:39:50 <Saizan> BMeph: the Applicative is fine for lists
11:40:31 <paper_cc> BMeph: why not newtype ZipList = ZipList [a], instance Applicative ZipList?
11:40:42 <BMeph> chrisdone: If it's a MonadError, then it's a Monad. WrappedMonad lets you manipulate a Monad as an Applicative, without barring some other way to make an Applicative using that Monad's type. :)
11:41:01 * paper_cc tries to remember if ZipList is actually like that
11:41:07 <let_f_> would it be hard to make interfaces to webAPIs like yahoo boss etc for haskell?
11:41:08 <let_f_> or you can call it through some haskell-python ffi?
11:41:10 <idnar> @src ZipList
11:41:10 <lambdabot> Source not found. :(
11:41:11 <Saizan> paper_cc: it is
11:41:16 <BMeph> paper_cc: Yes, we have that. Now, tell me how to use a ZipList as a Monad. :)
11:41:18 <chrisdone> BMeph: yeah, but it's not a MonadError
11:41:51 <BMeph> chrisdone: What's not a MonadError - the WrappedMonad? :)
11:42:02 <paper_cc> BMeph: so why have to wrap both versions of Applicative for [a]?
11:42:13 <chrisdone> yeah
11:42:14 <Saizan> you don't
11:42:24 <Saizan> in fact we have an instance Applicative [] where
11:42:32 <Saizan> which works like the Monad instance
11:42:45 <paper_cc> ... and not instance (Monad m) => Applicative m. brr
11:43:14 <rwbarton> chrisdone: you should be able to use standalone generalized newtype deriving (whew!)
11:43:25 <BMeph> paper_cc: The point is, we have to invent a new type - ZipList - to use lists in that Applicative style. That way, it doesn't ruin it for using lists in the "native" Applicative style. :)
11:43:34 <Saizan> paper_cc: the instance resolution algorithm is limited like that :)
11:43:36 <chrisdone> rwbarton: for what?
11:44:02 <rwbarton> chrisdone: to make WrappedMonad m an instance of MonadIO and so on when m is
11:44:10 <rwbarton> (if you need to do that)
11:44:23 <Saizan> BMeph: yeah, and that point doesn't have anything to do with WrappedMonad it seems
11:44:28 <BMeph> chrisdone: The point is: when you want to use your Monad as an Applicative, Wrap it. Then if you want to use it as a Monad again, unwrap__ it.
11:44:31 <rwbarton> oh wait
11:44:50 <rwbarton> It's probably much more sensible to write the missing Applicative instance for your monad which can take at most 3 lines. :)
11:45:06 <chrisdone> yeah..
11:45:49 <paper_cc> so the whole story in WrappedX is you can't hide instances :(
11:46:28 <chrisdone> BMeph: why is that a good idea?
11:46:31 <Saizan> how is that related?
11:46:38 <BMeph> paper_cc: No, thwe whole story is that Haskell doesn't treat class contraints in the way that most expect and want. :)
11:46:41 <BMeph> *the
11:47:56 <Saizan> instance Monad m => Applicative m; actually means "every 'm' is an Applicative. fail if that m isn't also a Monad"
11:48:10 <BMeph> chrisdone: Eh, I just like keeping ones' options open. There was nothing wrong with the way you did it originally. Especially since there is likely no useful way to use it some other way as an Applicative. :)
11:49:03 <chrisdone> BMeph: so it's mostly a way of separating instances for the same type?
11:49:23 <let_f_> would it be hard to make interfaces to webAPIs like yahoo boss etc for haskell?
11:49:24 <let_f_> or you can call it through some haskell-python ffi?
11:49:27 <BMeph> rwbarton: Yeah, that's exactly what chrisdone did. I then went and tried to make it Complicated. ;)
11:49:50 <chrisdone> rwbarton: it's just this example http://chrisdone.com/blog/html/2009-02-10-applicative-configfile-hsql.html
11:49:56 <BMeph> Heh-heh, "chrisdone did." That souonds funny. ;)
11:50:04 <BMeph> *sounds
11:50:24 * BMeph checks his mouth and fingers for stray marbles
11:50:25 <chrisdone> ^_<
11:50:36 <Saizan> let_f_: for haskell<->python is pretty easy to go via C, though for webAPIs you might want to implement them directly handling HTTP messages, no?
11:51:15 <rwbarton> chrisdone: yeah, I wrote some TH code for automatic JSON (de)serialization in a similar style
11:51:39 <chrisdone> spiffing
11:51:42 <BMeph> chrisdone: " it's mostly a way of separating instances for the same type?": Exactly
11:52:16 <BMeph> .
11:52:53 <chrisdone> BMeph: I can see it also as a way of getting an applicative (or /any/ instance) for /any/ Monad that you wanted it for.. (but whether there are actually so many monads (that aren't already applicative instances) to make it worth it, I have no idea)
11:53:58 <rwbarton> I guess if you had a (Monad m) => context, and really wanted to use m as an applicative, then WrappedMonad would come in handy.
11:54:12 <chrisdone> yeah
11:54:35 <let_f_> Saizan: and with some haskell http module that would be doable without much hassle?
11:54:46 <BMeph> chrisdone, rwbarton: Exactly. :)
11:55:15 <paper_cc> [random thoughts] why not have a MonadWrapper class (like MonadTrans) to solve the MonadXX problems?
11:55:47 <let_f_> should I do a yahoo boss wrapper and put it on hackage?
11:55:49 <chrisdone> like unwrapErrorMonad?
11:55:53 <BMeph> let_f_: s/some haskell http/ the HTTP/ :)
11:55:56 <chrisdone> or something
11:56:09 <chrisdone> a temporary instance for MonadError
11:56:10 <Saizan> let_f_: yeah, why not?:)
11:57:15 <paper_cc> like class MonadWrapper where wrapMonad, unwrapMonad; instance (MonadWrapper w, MonadIO m) => MonadIO (w m)...
11:59:29 <Saizan> isn't that MonadTrans?
11:59:36 <rwbarton> don't you need some kind of abstraction of type classes?
11:59:41 <rwbarton> s/of/over/
11:59:47 <BMeph> paper_cc: Monads don't (always) allow that. :)
12:00:23 * paper_cc didn't get it
12:00:29 <paper_cc> BMeph: for example?
12:00:32 <BMeph> paper_cc: Hmm, well, just that part shouldn't be a problem.
12:01:04 <rwbarton> oh, like class Newtype
12:01:37 <BMeph> Saizan: It seems like MonadTrans in reverse..... :\
12:02:30 <Saizan> unwrapMonad looks like the inverse of lift
12:03:04 <Saizan> and e.g. how do you write that for (ReaderT r) ?
12:03:23 <rwbarton> Saizan: w is WrappedMonad here I think
12:03:24 <paper_cc> it's reversible MonadTrans if you want
12:03:38 <paper_cc> rwbarton: Saizan: it is
12:04:16 <rwbarton> I think MonadWrapper should be named more like NewtypeToGetAroundLackOfClassAliases
12:04:21 <Saizan> right, so it's useful only for newtypes?
12:05:09 <paper_cc> Saizan: but don't you have to define an algebraic type when you just want to have a strictness annotation?
12:05:23 <paper_cc> data Strict a = Strict !a
12:05:24 <dolio> rwbarton: That'd be a little less useful.
12:05:47 <rwbarton> dolio: "That"?
12:06:03 <dolio> A newtype with that gigantic name.
12:06:08 <rwbarton> Oh, sure :)
12:06:13 <dolio> This isn't Java. :)
12:06:58 <Cheshire> Yes it is!
12:07:07 <dolio> Oh. My bad.
12:07:16 <paper_cc> Data.ByteString.Lazy ... import to the rescue!
12:07:24 * Gracenotes pulls out his shiny new MonoidFactoryBuilder
12:07:38 <rwbarton> It could be useful whenever you need to pretend that a general instance x of Foo is also an instance of Bar without losing other instances that x has.
12:07:44 <dolio> Also, how do class aliases help?
12:07:48 <rwbarton> (I think this is a pretty contrived situation.)
12:08:16 <idnar> Javakell
12:08:25 <dolio> There is a Jaskell.
12:08:29 <chrisdone> idnar: you tried
12:08:34 <dolio> Although it's kind of nutty.
12:08:56 <Cheshire> it's ok with a splash of milk though
12:09:23 <Gracenotes> Javakell sounds like the the name of a Dutch river, or something
12:09:33 <dolio> Like, it's lazy, but not pure.
12:09:43 <paper_cc> rwbarton: "if you're an instance of Bar, OK, but if you aren't, here's an instance for you" - like that?
12:10:22 <rwbarton> paper_cc: no, more like, if you're also an instance of Quux, let's keep that available in the wrapped type also
12:11:19 <rwbarton> but actually this has terrible problems with overlapping instances
12:11:45 <paper_cc> exactly what WrappedMonad was invented to solve.
12:12:04 <rwbarton> right
12:12:23 <rwbarton> MonadIO m => MonadIO (WrappedMonad m) looks OK... but what about Applicative m => Applicative (WrappedMonad m)!
12:12:49 <paper_cc> well, the second is simply wrong
12:12:59 <rwbarton> So WrappedMonad has to be specific to Applicative in that there is no instance like the second
12:13:05 <rwbarton> you can't reuse it for other classes
12:13:13 * paper_cc wants second-order typeclasses or something
12:13:32 <Botje> what, kindclasses? :D
12:13:37 <paper_cc> no. instance NiceWrappableTypeclass MonadIO ...
12:14:02 <thetallguy> ï»¿Am I right in thinking that there is no support for PackageImports in the :browse command (6.10.x)?
12:14:10 <rwbarton> variables that abstract over type classes
12:14:18 <rwbarton> class NiceWrappableTypeclass a -- a :: ??
12:14:28 * sw17ch ducks and covers in preparation for the firestorm between dons and bulat on -cafe
12:15:16 <paper_cc> a :: <whatever character not reserved for denoting kinds>
12:17:23 <dolio> @kind (->)
12:17:24 <lambdabot> ?? -> ? -> *
12:17:50 <paper_cc> btw, is that ? a kind variable?
12:17:58 <dolio> No.
12:18:05 <rwbarton> I wish ghc didn't use ? and ?? there
12:18:10 <rwbarton> I guess I just need to start writing ??? :)
12:18:48 <dolio> ?? is the union of * and #, and ? is the union of ?? and (#), I believe.
12:18:48 <paper_cc> *confused* why isn't it * -> * -> * then?
12:18:48 <lambdabot> Plugin `compose' failed with: Unknown command: ""
12:19:17 <rwbarton> paper_cc: It is, in Haskell 98.
12:19:50 <dolio> It's ?? -> ? -> * because of GHC's implementation of unboxed types.
12:20:17 <dolio> Int# :: #, so if it were * -> * -> *, you wouldn't be allowed to use Int#s as function parameters.
12:20:17 <paper_cc> that is, a separate kind for them.
12:20:22 <dolio> Which would make them kind of useless.
12:24:40 <rwbarton> Can I just imagine that there are separate type constructors (->1), (->2), ... with kinds * -> * -> *, # -> # -> *, ..., and (->) is overloaded over all of them?
12:25:40 <paper_cc> what for?
12:25:55 <rwbarton> So I don't need a notion of subkinds
12:26:22 <dolio> That's roughly how it works in a pure type system.
12:26:33 <dolio> Except everything is called Pi there.
12:26:47 <dolio> Including the kind constructors, I suppose.
12:27:26 * BMeph thinks, "Mmm...Pi!"
12:28:15 <dolio> And you just have a rule Pi (_::k1) k2 :: k3, where you have a set of triples (k1,k2,k3) as primitive in your type system.
12:28:22 <Cale> Ooh, floor pie! Doh!
12:28:25 <dolio> More or less.
12:28:30 <athos> @users
12:28:30 <lambdabot> Maximum users seen in #haskell: 661, currently: 655 (99.1%), active: 22 (3.4%)
12:29:14 <dolio> (Technically there's about one more level of indirection.)
12:39:18 <Nafai> Well, my Haskell presentation went ok
12:39:27 <Nafai> I didn't convince them it was useful for real-world stuff though
12:40:03 <lament> did you try?
12:40:29 <Nafai> Sort of
12:41:11 <augustss> @seen Heffalump
12:41:11 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 6h 13m 38s ago.
12:42:06 <koeien> Nafai: where/how? :)
12:42:14 <hackage> Uploaded to hackage: vect 0.4.0
12:42:26 <chessguy_work> @bot
12:42:26 <lambdabot> :)
12:42:26 <lunabot>  :)
12:42:34 <chessguy_work> hackage, version
12:42:52 <Nafai> koeien: Internal work lunch-time training.  Just by giving code examples and showing the advantages (safety, etc)
12:43:24 <chessguy_work> are they generally open to new technologies/languages?
12:44:21 <koeien> Nafai: ah. depends probably on where you work if people like it :)
12:44:25 <Nafai> chessguy_work: Yes.  Pretty open.
12:44:39 <lament> Nafai: what languages do you use at work?
12:45:43 <Nafai> On various projects, we are currently using Python, Ruby, PHP, C++.  Are looking at D.
12:46:12 <asgaroth> Nafai: did you mention the various real world haskell projects that exist?
12:46:25 <Nafai> Yes, of course.'
12:46:43 <asgaroth> And that didn't convince them?
12:46:46 <maltem> Â»If Perl is for people who want to Get Things Done, then Haskell is for people who want to Do Things Right, Eventually, After You Figure Out Exactly What That Means.Â« Nice one :)
12:46:57 <koeien> hehe, my employer is getting more enthousiastic about Haskell
12:47:36 <chrisdone> koeien: why?
12:47:58 * p_l delivered today a rant about Java being current-day COBOL and how other languages (with big amount of Lisp and Haskell references) are the future
12:48:06 <koeien> chrisdone: i keep ranting about it
12:48:16 <Nafai> I guess I just need to demostrate it to them
12:48:18 <koeien> well not ranting
12:48:24 <chrisdone> raving?
12:48:27 <dolio> Yes. Haskell is the COBOL of tomorrow!
12:48:27 <koeien> yeah
12:48:29 <Nafai> Rewrite our internal code in Haskell and compare
12:48:39 <koeien> Nafai: and then? nobody can read it
12:48:44 <chrisdone> Nafai: "just" write it?
12:48:46 <koeien> so you have 100% job security
12:48:58 * chrisdone did that
12:49:12 <asgaroth> apl would be better for the "unreplaceable" aspect though :)
12:49:50 <dolio> If you want job security, write in malbolge.
12:49:51 <paper_cc> Nafai: and rewrite your GUI code for wxHaskell and show =)
12:49:52 <Cheshire> Haskell is the Java of yesterday
12:50:04 <p_l> asgaroth: These days, COBOL fills that niche nicely
12:50:20 <athos> what does ~ stand for in the following snippet:
12:50:23 <athos> let (f, ~(target:s)) = splitAt (nth-1) alive
12:50:26 <koeien> athos: lazy pattern match
12:50:27 <sw17ch> some one should make a COBOL DSL in the same spirit as the BASIC one :)
12:50:51 <chrisdone> Haskell is data oriented C++
12:50:51 <koeien> > let (f, []) = (id, [1,2,3]) in f 37
12:50:52 <lambdabot>   * Exception: /tmp/7581248909224933910:71:56-78: Irrefutable pattern failed ...
12:50:55 <p_l> asgaroth: I was once told that if I wanted to make big amount of money fast, I should learn COBOL and mainframe, and I'd be making 100k/month in no time :P
12:50:57 <koeien> > let (f, ~[]) = (id, [1,2,3]) in f 37
12:50:58 <lambdabot>   37
12:50:59 <Nafai> paper_cc: gtkhs!
12:51:34 <asgaroth> p_l: yeah, and get mentally scarred beyond comparison in the process :D
12:51:53 <sw17ch> asgaroth: but he could afford the boose and toys to fix any broken soul!
12:51:54 <p_l> asgaroth: Not necessarily, but it depends on coworkers and the kind of code you're replacing
12:52:25 <p_l> COBOL _can_ be written nicely. Unfortunately it's target demographic wasn't capable of that :)
12:52:41 * osfameron twitches
12:52:44 <koeien> p_l: PERFORM ... UNTIL
12:52:47 <koeien> p_l: "nicely"
12:52:50 <koeien> ?
12:52:55 <athos> koeien: hmm... i don't get it. why would i want to do that?
12:53:10 <osfameron> PERFORM VARYING foo BY 1 UNTIL YOUR BRAIN SLOWLY DRIBBLES OUT OF YOUR EARS
12:53:11 <koeien> athos: sometimes you have two separate branches
12:53:58 <koeien> > let (y, ~(x:xs)) = (0, []) in if y == 0 then [] else (x+1):xs -- contrived example
12:53:59 <lambdabot>   []
12:54:09 <koeien> > let (y, ~(x:xs)) = (1, [1]) in if y == 0 then [] else (x+1):xs -- contrived example part 2
12:54:10 <lambdabot>   [2]
12:55:50 <paper_cc> > let (y, ~(x:xs)) = (1, []) in if y == 0 then [] else (x+1):xs -- failure
12:55:51 <lambdabot>   [* Exception: /tmp/2358260366138273314:71:48-69: Irrefutable pattern failed...
12:56:02 <athos> ah!
12:56:04 <athos> i see
12:56:09 <koeien> > let (y, (x:xs)) = (0, []) in if y == 0 then [] else (x+1):xs -- also failure
12:56:10 <lambdabot>   * Exception: /tmp/8593556367415976365:71:48-68: Irrefutable pattern failed ...
12:56:31 <athos> got it :)
12:56:33 <athos> thanks koeien, paper_cc
12:57:19 <roconnor> > 50*0.02/12
12:57:20 <lambdabot>   8.333333333333333e-2
12:57:51 <athos> > 1/12
12:57:52 <lambdabot>   8.333333333333333e-2
12:57:58 <koeien> > 1%12
12:58:00 <lambdabot>   1%12
12:58:00 <roconnor> > 50*0.02**(1/12)
12:58:01 <lambdabot>   36.09019018232972
12:58:08 <roconnor> > 50*(0.02**(1/12))
12:58:09 <lambdabot>   36.09019018232972
12:58:16 <roconnor> > 50*(1.02**(1/12))
12:58:17 <lambdabot>   50.08257906509601
12:58:36 <roconnor> I didn't even notice that 0.02 was the inverse of 50
12:59:12 <athos> hehe
12:59:42 <roconnor> I was estimating the intrest on $50 at 2% for one month
13:01:12 <koeien> > let x = ( 1.02**(1/12) ) - 1 in 50*x
13:01:13 <lambdabot>   8.25790650960112e-2
13:01:43 <dolio> > 50 * exp (0.02/12)
13:01:44 <lambdabot>   50.083402816374104
13:01:46 <roconnor> > let x = ( 1.02**(1/12) ) - 1 in 50*x :: CReal
13:01:47 <lambdabot>   0.0825790650960087400475753326517885697269
13:02:44 <koeien> dolio: are you sure that is correct?
13:07:09 <roconnor> koeien: depends on if 2% is APR or instantenous effective
13:07:44 <roconnor> koeien: african or european
13:09:50 * Heffalump waves
13:10:11 * roconnor waves back
13:11:23 * chrisdone likes big butts and he cannot lie
13:12:09 <skorpan> and you other brothers can't deny
13:13:50 * Gracenotes sees that chrisdone has a weakness for _|_
13:14:30 <Cheshire> @go stop thinking about bottoms
13:14:30 <lambdabot> No Result Found.
13:14:39 <Cheshire> hmf www.cs.swan.ac.uk/BCTCS2006/Slides/Altenkirch.pdf
13:15:34 <dolio> koeien: It's correct if you get continuous interest.
13:15:38 <dolio> Which nobody does.
13:16:36 <roconnor> dolio: most banks give you daily intrest
13:16:38 <eu-prleu-peupeu> hello
13:16:39 <roconnor> which is pretty close
13:16:45 <dolio> Yeah, that's pretty good.
13:18:56 <dolio> > let i r t k = (1 + r*k)**(t/k) in map i [1, 1/12, 1/365, 1/(365*24), 1/(365*24*60)] ++ [exp 1]
13:18:57 <lambdabot>       No instance for (Floating (a -> a -> a))
13:18:57 <lambdabot>        arising from a use of `...
13:19:10 <dolio> > let i r t k = (1 + r*k)**(t/k) in map (i 1 1) [1, 1/12, 1/365, 1/(365*24), 1/(365*24*60)] ++ [exp 1]
13:19:11 <lambdabot>   [2.0,2.613035290224676,2.7145674820219727,2.7181266916179077,2.718279242666...
13:20:39 <roconnor> > let i r t k = (1 + r*k)**(t/k) in map (i 1 1) [1, 1/12, 1/365, 1/(365*24), 1/(365*24*60)] ++ [exp 1] :: [Float]
13:20:40 <lambdabot>   [2.0,2.6130366,2.71451,2.719252,2.72509,2.7182817]
13:20:59 <roconnor> 2.72509!
13:21:08 <roconnor> way to go Float :/
13:21:12 <dolio> :)
13:21:50 <dolio> That one's actually further away than the previous approximation. :)
13:21:54 <roconnor> @remember don't let Float do your finance homework for you
13:21:54 <lambdabot> Done.
13:22:12 <Saizan> @quote don't
13:22:12 <lambdabot> don't says: let Float do your finance homework for you
13:22:28 <roconnor> don't needs to say more things
13:22:45 <roconnor> he has all sorts of crazy advice
13:22:53 <Raevel> i don't think so
13:22:57 <Cheshire> @keal
13:22:57 <lambdabot> #haskell needs to take its meds
13:24:17 <dolio> @protontorpedo
13:24:17 <lambdabot> paul graham said static typing and ML types fo lisp hurt exploratory progrmaming
13:25:43 <dolio> @palomer
13:25:43 <lambdabot> That's a lie
13:25:51 <let_f_> paul graham writes a 00yer langauge, thats great then you never need to deliver
13:25:57 <let_f_> 100year
13:27:03 <Cale> 100 year?
13:27:35 <drhodes> "According to the TNG Technical Manual, photon torpedoes use 1.5kg of matter and 1.5kg of antimatter. The resulting energy output would be 2.70x1017Joules of energy (by the well-known formula E=mc2). This amount of energy release would be equivalent to a 64.4 megaton nuclear explosion."
13:28:15 <dolio> Not photon. Proton.
13:28:23 <augustss> @keal
13:28:24 <lambdabot> ithink has to do with hardcased government failsafe in chip
13:28:26 <dolio> Like what they used to blow up the death star.
13:28:37 <drhodes> never heard of a proton topedo
13:29:04 <p_l> dolio: That's Star Trek, not Star Wars. Photon it is
13:29:10 <Cheshire> so what's new wrt. functional programming/types?
13:29:29 <roconnor> @photontorpedo
13:29:30 <lambdabot> as u scale and complexity grows?
13:29:46 <dolio> @list quote
13:29:46 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo nixon farber
13:29:57 <augustss> Cheshire: are you bored with the old?
13:30:03 <Cheshire> augustss yes :(
13:30:07 <roconnor> @yhjulwwiefzojcbxybbruweejv
13:30:07 <lambdabot> Exception: <<loop>>
13:30:15 <p_l> dolio: It's pity that Star Trek is pretty low on Sci-Fi scale of hardness :)
13:30:22 <mathijs> is prependHello cs = "hello" ++ cs more expensive than prependHello cs = 'h':'e':'l':'l':'o':cs ?
13:30:35 <olsner> roconnor: what does that command even do?
13:30:44 <Cale> mathijs: Perhaps negligibly so.
13:30:46 <roconnor> @help yhjulwwiefzojcbxybbruweejw
13:30:46 <lambdabot> V RETURNS!
13:30:56 <olsner> helpful!!!1 :)
13:30:57 <asgaroth> @quote remember
13:30:57 <lambdabot> avdi says: alter ego? i'll never remember that name when i'm looking for a state machine.
13:31:06 <dolio> @help v
13:31:06 <lambdabot> let v = show v in v
13:31:08 <Cale> mathijs: But it's not worth the trade-off, I think.
13:31:16 <roconnor> @v
13:31:16 <lambdabot> Exception: <<loop>>
13:31:25 <Cheshire> I think I am becoming stagnant
13:31:26 <roconnor> > let v = show v in v
13:31:27 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:31:27 <augustss> Cheshire: done your dependent types?
13:31:38 <Cheshire> augustss, I prototyped my system -- seems fine
13:31:40 <roconnor> apparently v is broken
13:31:56 <dolio> I don't think it was quite that simple.
13:32:10 <roconnor> > fix show
13:32:12 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:32:16 <dolio> v was some hidden variable that lambdabot's haskell execution used.
13:32:24 <augustss> Cheshire: well, then you have to invent your own.
13:32:31 <roconnor> oh
13:32:34 <dolio> So people used it to cause various wacky things to happen.
13:32:42 <mathijs> Cale: thanks, but the other way around (cs ++ 'hello') can become expensive if cs is long right?
13:32:43 <Cheshire> augustss, my own what?
13:32:48 <Cale> mathijs: yes.
13:32:54 <dolio> And those got catalogued in @v. Then the name got switched to yhjulwwiefzojcbxybbruweejv.
13:32:54 <Cale> mathijs: But necessarily so.
13:33:02 <augustss> Cheshire: exciting type system
13:33:06 <Cheshire> oh
13:33:07 <dolio> To try and avoid people running into it.
13:33:21 <Cale> mathijs: There's no more efficient way to do that, but often there are ways to avoid having to do it at all.
13:33:30 <roconnor> @let yhjulwwiefzojcbxybbruweejw = yhjulwwiefzojcbxybbruweejw
13:33:31 <lambdabot>  Defined.
13:33:38 <drhodes> why weren't list implemented doubly linked?
13:33:39 <olsner> ooh, nice piece of lambdabot history there
13:33:54 <Elly> drhodes: what would be gained from that?
13:33:55 <Cale> mathijs: For instance, if you represent your lists instead as functions which prepend elements to other lists, then composition becomes concatenation, and composition happens in constant time.
13:34:02 <jeffwheeler> Elly: quick appends?
13:34:12 <Elly> that doesn't get you quick appends
13:34:26 <jeffwheeler> Elly: Okay, keeping a pointer to the end does. You're right.
13:34:44 <jeffwheeler> Elly: . . . but isn't that normally done with a doubly-linked list?
13:34:45 <Cale> ..., no it wouldn't because lists are still immutable
13:34:51 <Elly> lists are immutable, yes
13:34:53 <jeffwheeler> Hmm
13:34:58 <Elly> you can't do adjusting the next pointer of the last element
13:35:00 <Elly> doubly-linked list or not
13:35:02 <augustss> drhodes: if you have immutable lists then double linked lists get boring.
13:35:09 <drhodes> ahh. right immutable,yeah.
13:35:16 <mathijs> Cale: I saw that somewhere in RWH I think. I do think that such a 'trick' should be handled by the compiler instead, instead of obfuscating the code just for performance.
13:35:18 <Cale> So it would just make the efficient operations less efficient and buy you nothing.
13:35:49 <Cale> mathijs: It's not too obfuscatory, once you're aware of it.
13:36:08 <Cale> mathijs: and it isn't something which can always be done...
13:36:27 <Cale> Not all list operations can easily be applied to functions that add elements to other lists.
13:36:28 <drhodes> but getting the last n elements would be faster, reversing..
13:36:43 <SamB_irssi> mathijs: how about in library ?
13:36:53 <jeffwheeler> Haskell needs to do something like the Google Highly Open Participation contest from a few years back.
13:37:03 <mathijs> SamB_irssi: well yeah, that would be the obvious next best thing :)
13:37:09 <SamB_irssi> http://hackage.haskell.org/packages/archive/dlist/0.4.1/doc/html/Data-DList.html
13:37:16 <Cale> There's DList, if you really don't want to have to think about it, but I think DList is almost too heavy to bother with for such an easy little trick.
13:37:23 <roconnor> jeffwheeler: what's that?
13:37:25 <jeffwheeler> The idea was that high-school students could do pretty simple tasks (a few hours to a day) like unit tests and documentation, etc. and a lot of work could be done very quickly.
13:37:45 <jeffwheeler> . . . but it doesn't have to apply just to high-school students and there need not be a prize.
13:37:49 <SamB_irssi> Cale: well, it's not so easy with the proper Monoid (a -> b) instance
13:37:52 <olsner> the comment in lambdabot sources say "v used to be a bug in @eval.  See the logs from April 9, 2006." ... I should check that log out :)
13:38:03 <augustss> drhodes: Data.Sequence is a good data structure if you need something like doubly linked lists.
13:38:04 <jeffwheeler> Simply having simple tasks that can be achieved in a few hours to a day without tons of expert knowledge would be great.
13:38:41 <Saizan> > __compileExpr
13:38:42 <lambdabot>   Not in scope: `__compileExpr'
13:39:28 <drhodes> Oh. Sequence is a type, thought twas just a function module.
13:39:42 <jeffwheeler> Here are the tasks from the Python project a few years ago: http://code.google.com/p/google-highly-open-participation-psf/issues/list?can=1&q=
13:39:45 <Cale> Data.Sequence is far better than doubly linked lists in a few ways. It has fast operations which don't destroy the old version of the list.
13:39:49 * SamB_irssi says this as the one who made DList a newtype instead of a type synonym
13:40:36 <Cale> With doubly linked lists, to add an element, you either have to ruin the old list, or copy the whole thing.
13:40:47 <mathijs> Cale: I can't seem to find the part in RWH that talked about the function-composition-as-concatenation trick. you are talking about 'b = (++ "hello")' right?
13:41:00 <Cale> More like ("hello" ++)
13:41:14 <roconnor> @src String shows
13:41:14 <lambdabot> Source not found. Are you on drugs?
13:41:15 <Cale> Let me scribble you a quick example.
13:41:28 <roconnor> @src Char showsList
13:41:28 <lambdabot> Source not found. You type like i drive.
13:41:32 <mathijs> Cale: thanks
13:41:36 <roconnor> @hoogle [a] -> String
13:41:36 <lambdabot> Prelude cycle :: [a] -> [a]
13:41:36 <lambdabot> Prelude init :: [a] -> [a]
13:41:36 <lambdabot> Prelude reverse :: [a] -> [a]
13:41:41 <roconnor> @hoogle [a] -> String -> String
13:41:41 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
13:41:41 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
13:41:41 <lambdabot> Distribution.Simple.PreProcess.Unlit plain :: String -> String -> String
13:41:51 <roconnor> @src Show
13:41:51 <lambdabot> class  Show a  where
13:41:51 <lambdabot>     showsPrec :: Int -> a -> ShowS
13:41:51 <lambdabot>     show      :: a   -> String
13:41:51 <lambdabot>     showList  :: [a] -> ShowS
13:42:01 <roconnor> @src+
13:42:01 <lambdabot> src <id>. Display the implementation of a standard function
13:42:08 <roconnor> ho
13:42:09 <roconnor> oh
13:42:13 <roconnor> showList is to Shows
13:42:14 <hackage> Uploaded to hackage: stb-image 0.1.3
13:42:21 <roconnor> @src Char showList
13:42:22 <lambdabot> Source not found. Sorry.
13:42:26 <roconnor> @src showList Char
13:42:26 <lambdabot> Source not found. stty: unknown mode: doofus
13:42:29 <roconnor> damn it!
13:42:51 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1314#a1314
13:43:08 <roconnor> @src showString
13:43:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:43:12 <roconnor> @src showsString
13:43:12 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:43:16 <Cale> If you can understand how that code works and why it's efficient, then it will no longer be a mystery :)
13:43:18 <roconnor> @hoogle showsString
13:43:18 <lambdabot> No results found
13:43:24 <roconnor> @hoogle showString
13:43:24 <lambdabot> Prelude showString :: String -> ShowS
13:43:24 <lambdabot> Text.Show showString :: String -> ShowS
13:43:34 <roconnor> why no source?
13:43:45 <Cale> Note the conspicuous absence of (++), relative to how you might initially think to implement inorder.
13:44:04 <Cheshire> Cale, http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1314#a1315
13:44:56 <roconnor> Cheshire: nice
13:45:07 <roconnor> Cheshire: but doesn't quite parse
13:45:12 <Cale> Cheshire: ... does that typecheck?
13:45:15 <Cheshire> oh
13:45:16 <Cheshire> it's wrong
13:45:31 <roconnor> Cheshire: still nice.  I never thought of that before
13:45:58 <roconnor> Cheshire: now do it with callCC
13:46:10 <Cheshire> naturally :p
13:46:15 <Cale> I get the idea, I think :)
13:46:50 <Cale> mathijs: Does that code make sense?
13:46:54 <roconnor> oh, it is the same as Cales, except eta expanded
13:47:14 <roconnor> funny how the same thing can seem so different
13:47:25 <Cale> roconnor: Yeah, it feels totally different that way.
13:47:47 <Cale> Well, it's a different function, but other than that :P
13:47:51 <mathijs> Cale: a bit :)  still telling myself what its result will be, before trying it in ghci :)
13:48:14 <roconnor> Cale: it's really the same (modulo the fact that she is using a different Tree type)
13:48:19 <Cale> roconnor: yes
13:49:00 <Cale> ... and it's not even just collecting the leaves, so its name is a bit misleading :P
13:49:03 <mathijs> Cale: ah... got it... I was a bit confised because of the (x:) part being to the right of inorder' l
13:49:21 <mathijs> but it makes sense now, since inorder' l takes a list as argument
13:49:23 <Cale> mathijs: Right, that's what makes it inorder and not preorder.
13:50:04 <Cale> Basically, instead of [a] we use [a] -> [a] where we append the elements to the start of some other list
13:50:09 <Cale> and instead of (++), we use (.)
13:50:15 <Cale> and instead of [], we use id
13:50:57 <Cale> Then, to get a list in the end, we apply the function to an empty list.
13:52:03 <Cale> This inorder traversal is O(n), as opposed to the naive one using (++) which is O(n^2)
13:52:19 <mathijs> Cale: thanks, this makes it clearer. But in case of   take 10 (cs ++ "hello"), even if cs is very big, won't laziness prevent the new/copied (cs ++ "hello") string from being generated?
13:52:38 <Cale> mathijs: Only 10 elements of it will be generated.
13:52:49 <Cale> mathijs: You're still paying a constant cost per element.
13:53:04 <mathijs> so element by element is copied?
13:53:06 <Cale> (c:cs) ++ ds = c : (cs ++ ds)
13:53:22 <Cale> That rule will be applied for each element you pattern match against.
13:53:34 <Cale> (assuming that cs doesn't run out of elements)
13:54:02 <mathijs> so   take 3 ("somelongstring" ++ "short") is more expensive than  take 3 "somelongstring" ?
13:54:11 <Cale> a little, yes.
13:54:26 <dons> i love gitit.
13:54:37 <Cale> But the cost is O(3) ;)
13:54:38 <mathijs> just in memory usage or also in execution speed?
13:55:11 <Cale> Well, the memory usage is questionable. It'll possibly allocate, but garbage will get collected.
13:55:33 <Cale> It's really only time which I'm talking about.
13:56:39 <Cheshire> :(
13:57:07 <Cale> Why Cheshire is sad?
13:59:31 <mathijs> Ok, It's clearer now. thanks for your example.  The part that basically confused me about ++ is that I didn't think of it as 'modifying' (as in changing elements), but then I realized that the last element has to be modified to point to the first element of the next string. and since that's not allowed, all elements before that need to be modified too.
13:59:48 <roconnor> right
14:00:03 <Cale> Well, a new list has to be constructed, more accurately.
14:00:10 <roconnor> right
14:00:23 <sw17ch> pshc: i hate the word synergy
14:00:26 <Cale> It can't directly share the spine of the old list, because that spine has a different tail than we want.
14:00:27 <sw17ch> ps:*
14:00:53 <mathijs> yeah that's what it comes down to, because modifying is not allowed (even not just change the pointer-to-next-element)
14:01:14 <drhodes> sw17ch: moving forward with synergizing paradigms - biz speak, yay.
14:01:33 <sw17ch> drhodes: you're making me all staby talking like that....
14:01:41 <sw17ch> > repeat "stab"
14:01:42 <lambdabot>   ["stab","stab","stab","stab","stab","stab","stab","stab","stab","stab","sta...
14:01:43 <mathijs> I remember that part again... in the comparisson between alist and Data.Map
14:02:13 <mathijs> making the spinal part that needs to modify as small as possible
14:12:49 <sm> this is a puzzle: how can I get "not in scope: data constructor `Ptr'" after ghci, import Foreign.Ptr ?
14:13:03 <koeien> sm: it's a type constructor?
14:13:29 <sm> koeien: ithttp://haskell.org/ghc/docs/6.8.2/html/libraries/base/Foreign-Ptr.html
14:13:46 <sm> urgh.. it's at that doc, I'm not sure what it is
14:13:50 <koeien> sm: yeah? i don't see it
14:13:56 <koeien> only type constructor Ptr
14:14:00 <Gracenotes> @hoogle (a -> Bool) -> [a] -> Int
14:14:00 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
14:14:00 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
14:14:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:14:09 <Gracenotes> ... :x
14:14:20 <sm> ok, that's a type constructor ? thanks. Then..
14:14:22 <Gracenotes> how muy useful
14:14:31 <koeien> sm: data Maybe a = Nothing | Just a
14:14:39 <koeien> sm: Maybe is the type constructor, Nothing & Just are data constructors
14:15:46 <sm> isn't NewlyAllocated also a type constructor here ? data NewlyAllocated a = NewlyAllocated (Ptr ObjCObject) | NewSuper (Ptr ObjCObject) (Class ())
14:16:07 <koeien> sm: yep it's possible to have one with the same name as a type constructor
14:16:11 <koeien> in fact it's fairly common
14:16:19 <koeien> there is no possibility for confusion anyway
14:16:27 <koeien> (to the compiler, that is)
14:16:51 <sm> my confusion then is why :t NewlyAllocated gives me NewlyAllocated :: GHC.Ptr.Ptr HOC-1.0:HOC.Base.ObjCObject -> NewlyAllocated a
14:17:55 <koeien> NewlyAllocated is a data constructor here
14:18:07 <jeffwheeler> @pl \pl -> (focus pl, focus pl == focus l)
14:18:07 <lambdabot> liftM2 (,) focus ((focus l ==) . focus)
14:18:08 <koeien> :t Just -- analogy
14:18:08 <lambdabot> forall a. a -> Maybe a
14:18:47 <koeien> the "NewlyAllocated" on the right hand side of :: is a type constructor, the one on the left of the :: is the data constructor
14:18:50 <sm> koeien: ah.. thank you, got you
14:18:57 <sm> brain is a bit fried
14:20:09 <Gracenotes> ah 2-tuples specially optimized for performance?
14:20:11 <Gracenotes> *are
14:20:16 <sm> correction to my earlier pronouncement: wx is not the only hope for gui apps on a mac, hoc also works, given sufficient bloodymindedness
14:21:20 <drguildo> the markup the text.xhtml outputs is weird
14:22:00 <drguildo> the closing parenthesis is always on a newline
14:22:04 <drguildo> anybody else noticed that?
14:23:02 <drguildo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1362
14:23:17 <Cheshire> drguido, nice formatting
14:23:48 <koeien> drguildo: yes, whitespace is sometimes significant
14:23:52 <koeien> this formatting prevents that
14:24:11 <drguildo> koeien: i don't understand
14:24:15 <koeien> there are other functions to render if you want other output
14:24:41 <koeien> drguildo: <p>   \n  Hello \n </p> may be different from <p>Hello
14:24:50 <koeien> drguildo: i don't know the details, this is just what i've been told
14:25:16 <drguildo> interesting
14:32:07 <drguildo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1363
14:32:22 <drguildo> can anybody compile that? i get a ton of linking errors
14:32:26 <Cheshire> why is it (<<) ?
14:33:03 <drguildo> ask whoever wrote Text.XHtml
14:33:20 <Axman6> drguildo: using ghc --make?
14:33:56 <drguildo> Axman6: thanks
14:34:25 <Axman6> drguildo: linking errors are almost always caused by the lack of --make
14:34:43 <drguildo> Axman6: what does --make do? ghc --help doesn't seem to say
14:35:18 <Axman6> To compile and link a complete Haskell program, run the compiler like
14:35:19 <Axman6> sOpen:
14:35:19 <Axman6> ghc --make Main
14:35:36 <Axman6> uh, sorrt sOpen, that was supposed to say so:
14:35:38 <Axman6> y*
14:36:24 <drguildo> yeah but i mean what's the difference between "ghc -o foo foo.hs" and "ghc --make -o foo foo.hs"
14:36:31 <drguildo> what does the latter do that the former doesn't
14:36:49 <Axman6> --make tells it to link the executable and produce a proper program
14:37:26 <let_f_> is there no when in haskell?
14:37:37 <Deewiant> drguildo: --make tells it to figure out what libraries and other object files to link in
14:37:38 <let_f_> [if x < 10 && mod x 2 == 1 || x == 34 then x else Nothing | x <- [1..100]]
14:37:40 <Axman6> :t when
14:37:41 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:37:43 <Cheshire> there is no i in haskell
14:38:20 <let_f_> i?
14:38:31 <Deewiant> > [x | x <- [1..100], x < 10 && mod x 2 == 1 || x == 34]
14:38:33 <lambdabot>   [1,3,5,7,9,34]
14:38:35 <Axman6> let_f_: that code doesn't make sense
14:38:39 <Deewiant> let_f_: I guess that's what you're after?
14:38:43 <sw17ch> http://www.reddit.com/r/haskell/comments/7wp46/having_some_fun_with_the_diagrams_package/
14:38:51 <drguildo> hmmm
14:38:57 <drguildo> i'll have a look at the manual
14:39:10 <Deewiant> drguildo: in short: always use --make
14:39:19 <Deewiant> there's rarely a reason not to
14:39:45 <let_f_> yes thats it
14:39:50 <let_f_> Axman6: why not?
14:39:56 <drguildo> sure but i just like to understand why
14:40:18 <drguildo> i would it expect to do all that stuff by default unless -c was specified
14:40:23 <drguildo> i suppose i am too used to gcc
14:40:25 <Axman6> well, x is an integer right? and Nothing is Maybe a. you'd need then Just x else Nothing
14:40:28 <let_f_> is a haskellfile.exe portable? ie runs on all platforms or i ahve to compile specifically for each?
14:41:09 <pejo> drguildo, if you leave out the -l flags to gcc you'll get a linker error too.
14:41:22 <drguildo> sw17ch: pretty
14:41:52 <sw17ch> drguildo: :)
14:41:53 <Deewiant> drguildo: ghc does just as much as gcc unless you pass it --make. Which is exactly why you want to use --make. ;-)
14:42:14 <Deewiant> let_f_: if something ends in ".exe" it's probably safe to say it only runs on windows.
14:42:14 <hackage> Uploaded to hackage: pointedlist 0.1
14:42:45 <Deewiant> let_f_: and yes, as a main rule compiled executables only run on one platform
14:42:47 * Gracenotes attacks #haskell with pointed lists
14:43:08 <drguildo> Deewiant: hmmm, yeah. i guess you have to do all that -l/pkg-config crap with gcc.
14:43:52 <Deewiant> drguildo: you can run ghc --make -v to see what exactly it's doing.
14:44:25 <drguildo> Deewiant: cool
14:44:46 <Deewiant> (for fuzzy values of 'exactly')
14:45:46 <zax> @src iterate
14:45:46 <lambdabot> iterate f x =  x : iterate f (f x)
14:47:14 <redditbot> Having some fun with the diagrams package!
14:52:44 <zax> How do I do 4! in Haskell?
14:52:48 <zax> 1*2*3*4 in other words
14:52:54 <Cheshire> :t let duplicate x = (x,x) in unfoldr (Just . duplicate . f)
14:52:55 <mm_freak> > product [1..4]
14:52:55 <lambdabot> forall b. (SimpleReflect.FromExpr b, Show b) => b -> [b]
14:52:56 <lambdabot>   24
14:53:03 <zax> oh, product smart
14:53:03 <z0d> > fact 4
14:53:03 <Cheshire> :t let duplicate x = (x,x) in \f -> unfoldr (Just . duplicate . f)
14:53:04 <lambdabot>   Not in scope: `fact'
14:53:04 <lambdabot> forall b. (b -> b) -> b -> [b]
14:53:36 <tromp> :t ^
14:53:37 <lambdabot> parse error on input `^'
14:53:43 <tromp> :t (^)
14:53:44 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:53:47 <tromp> :t (**)
14:53:48 <lambdabot> forall a. (Floating a) => a -> a -> a
14:54:04 <tromp> > 0^0
14:54:05 <lambdabot>   1
14:54:09 <tromp> > 0**0
14:54:10 <lambdabot>   1.0
14:54:34 <tromp> :t pi
14:54:35 <lambdabot> forall a. (Floating a) => a
14:54:43 <mm_freak> > fix (\r p x -> if x == 0 then p else r (p*x) (x-1)) 1 4
14:54:44 <lambdabot>   24
14:54:47 <tromp> > pi :: Complex
14:54:48 <lambdabot>       `Complex' is not applied to enough type arguments
14:54:48 <lambdabot>      Expected kind `?...
14:54:50 <mm_freak> > fix (\r p x -> if x == 0 then p else r (p*x) (x-1)) 1 8
14:54:51 <lambdabot>   40320
14:55:04 <tromp> > pi :: Complex Double
14:55:05 <lambdabot>   3.141592653589793 :+ 0.0
14:55:15 <Axman6> > cis pi
14:55:16 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
14:55:27 <Axman6> > cis pi :: Complex CReal
14:55:28 <lambdabot>   (-1.0) :+ 0.0
14:55:45 <tromp> > i :: Complex Double
14:55:46 <lambdabot>   Couldn't match expected type `Complex Double'
14:56:08 <Cheshire> > 1 2 miss a few 99 100
14:56:09 <lambdabot>   Not in scope: `miss'Not in scope: `few'
14:56:09 <Axman6> > sqrt (-1) :: Complex Double
14:56:10 <lambdabot>   (-0.0) :+ 1.0
14:56:15 <tromp> @let ci = 0.0 :+ 1.0
14:56:16 <lambdabot>  Defined.
14:56:20 <tromp> :t ci
14:56:21 <lambdabot> forall t. (RealFloat t) => Complex t
14:56:38 <mm_freak> :t mfix (\r x -> if x == 0 then return () else modify (*x) >> r (x-1)) 8
14:56:39 <lambdabot>     Couldn't match expected type `m b' against inferred type `()'
14:56:39 <lambdabot>       Expected type: a -> m b
14:56:39 <lambdabot>       Inferred type: a -> ()
14:56:42 <tromp> > exp (ci*pi) :: Complex Double
14:56:43 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
14:56:56 <tromp> > exp (ci*pi) :: Complex CReal
14:56:57 <lambdabot>   (-1.0) :+ 0.0
14:56:59 <mm_freak> :t mfix (\r x -> if x == 0 then return 0 else modify (*x) >> r (x-1)) 8
14:57:00 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
14:57:00 <lambdabot>     Probable cause: `>>' is applied to too many arguments
14:57:00 <lambdabot>     In the expression:
14:57:01 <tromp> hmm, cool
14:57:36 <mm_freak> :t mfix (\r x -> if x == 0 then return 0 else (modify (*x) >> r (x-1))) 8
14:57:38 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
14:57:38 <lambdabot>     Probable cause: `>>' is applied to too many arguments
14:57:38 <lambdabot>     In the expression:
14:59:09 <mm_freak> :t mfix (\r x -> if x == 0 then return 0 else modify (*x) >> return (r $ x-1)) 8
14:59:09 <lambdabot> forall a t. (MonadState a ((->) a), Num t, Num a) => a -> t
14:59:29 <mm_freak> > execState (mfix (\r x -> if x == 0 then return 0 else modify (*x) >> return (r $ x-1)) 8) 1
14:59:30 <lambdabot>   Couldn't match expected type `a -> b'
15:00:55 <dolio> Normal fix works like that because with (a -> a) -> a you can set a = b -> c to get additional parameters.
15:01:07 <mm_freak> > execState (fix (\r x -> if x == 0 then return 0 else modify (*x) >> r (x-1)) 8) 1
15:01:08 <lambdabot>   40320
15:01:24 <dolio> But with (a -> m a) -> m a, adding more parameters means you have to unify 'm a' with 'b -> n c'.
15:02:09 <mm_freak> any point in mfix besides recursive do?
15:02:58 <roconnor> mm_freak: not really.  Oleg uses it to make IORef objects that have a self pointer.
15:03:56 <mm_freak> hmm, well
15:03:59 <mm_freak> i'm human =)
15:06:52 <dolio> mfix is an important part of how his OO framework in haskell works.
15:07:10 <dolio> Which I guess makes sense.
15:07:35 * sw17ch goes home
15:07:36 <sw17ch> cya!
15:08:11 <Cheshire> augustss, maybe I should turn it into a proper language for programming and proving
15:08:27 <mm_freak> hmm, ok
15:08:32 <Cheshire> like something that would be useful
15:09:55 <Cheshire> idk
15:11:32 <Cheshire> hi
15:12:18 <dolio> > runState (mdo x <- modify (+1) >> return (1:x) ; return (head x)) 1
15:12:49 <lambdabot>   thread killed
15:13:01 <dolio> > runState (mdo x <- modify (+1) >> return (1:x) ; return (head x)) 1
15:13:03 <lambdabot>   (1,2)
15:13:59 <dolio> > runState (mdo x <- get >>= \y -> put (y+1) >> return (y:x) ; return (take 10 x)) 1
15:14:01 <lambdabot>   ([1,1,1,1,1,1,1,1,1,1],2)
15:16:36 <dolio> > runState (runListT (mdo x <- get >>= \y -> put (y+1) >> return (y:x) `mplus` return (y:x) `mplus` return (y:x) ; return (take 10 x)) 1
15:16:37 <lambdabot>   <no location info>: parse error on input `;'
15:17:10 <dolio> > runState (runListT (mdo x <- get >>= \y -> put (y+1) >> (return (y:x) `mplus` return (y:x) `mplus` return (y:x)) ; return (take 10 x)) 1
15:17:12 <lambdabot>   <no location info>: parse error on input `;'
15:18:24 <Cheshire> http://www.dur.ac.uk/p.c.callaghan/plastic/
15:18:34 <Cheshire> looks really interesting but there is no source code :/
15:18:41 <Cheshire> claims to be implemented in haskell...
15:20:44 <dolio> No MonadFix for ListT apparently.
15:29:50 <mathijs> Hi all, RWH mentions that the Monad instance of Maybe doesn't completely short-circuit when a Nothing is encountered. So all remaining actions will still be run (all get feed Nothing and return Nothing). Nothing >>= _ = Nothing. Does this mean that for every remaining >>= a new Nothing value is constructed? isn't there just 1 Nothing value in memory?
15:30:25 <roconnor> mathijs: that doesn't sound right
15:30:31 <roconnor> Nothing >>= _ = Nothing
15:30:43 <roconnor> the _ means the second argument is completely ignored
15:30:48 <roconnor> and won't even be evaluated
15:31:01 <sbahra> Nothing >> (Just 1) >> (Just 3)
15:31:05 <sbahra> > Nothing >> (Just 1) >> (Just 3)
15:31:06 <lambdabot>   Nothing
15:31:32 <sbahra> mathijs, check this out
15:31:33 <sbahra> @src Maybe (>>=)
15:31:33 <lambdabot> (Just x) >>= k      = k x
15:31:33 <lambdabot> Nothing  >>= _      = Nothing
15:31:40 <mathijs> so it does completely shortcut?
15:31:47 <dolio> Depends on the parenthesizing.
15:32:07 <koeien> > (Nothing >>= Just 37) >>= undefined
15:32:08 <lambdabot>   Couldn't match expected type `a1 -> Maybe a'
15:32:14 <koeien> > (Nothing >> Just 37) >> undefined
15:32:15 <lambdabot>   Nothing
15:32:18 <mathijs> what if there's remaining >>= operators remaining? will the only 'cost' the book talks about be the pattern matching ?
15:32:22 <dolio> ((Nothing >>= f) >>= g) >>= h =reduction=> (Nothing >>= g) >>= h ==> Nothing >>= h ==> Nothing
15:33:12 <dolio> Nothing >>= \x -> f x >>= g >>= h =reduction=> Nothing
15:33:14 <roconnor> mathijs: what dolio said about assocativity
15:33:44 <roconnor> in ((Nothing >>= f) >>= g) >>= h example the f , g and h all have to be tossed away separately
15:34:05 <roconnor> the f , g, h are not evaluated, but it does take 3 steps to get rid of them all
15:35:11 <roconnor> in the Nothing >>= (\x -> (f x >>= g >>=h)) case
15:35:15 <mathijs> well, (>>=) is infixl, so I guess this will be the case?
15:35:21 <roconnor> the (\x -> (f x >>= g >>=h)) is tossed all at once
15:36:30 <mathijs> the performance-loss will probably not even be measurable, but I ask this just to get my perception straight.
15:36:52 <roconnor> see also http://www.haskell.org/haskellwiki/Performance/Monads#Use__Continuation_Passing_Style
15:37:12 <roconnor> mathijs: it can be big in some cases.
15:37:39 <dolio> The monad laws actually say you can turn '((m >>= f) >>= g) >>= h' into 'm >>= (\x -> f x >>= g >>= h)'.
15:37:45 <dolio> But that isn't always an optimization.
15:38:00 <dolio> In fact, I'd say it usually the opposite.
15:38:02 <mathijs> But my other question: is there ever only 1 Nothing value in memory? in other words, would   n@Nothing >>= _ = n   matter?
15:38:24 <dolio> There should only ever be one Nothing.
15:38:29 <dolio> In GHC, at least.
15:39:00 <mathijs> And I guess that's true for all algebra types?
15:39:20 <dolio> It's true for constructors with 0 arguments.
15:39:45 <Cheshire> mathijs, Nothing == Nothing but if you have two programs p, and q that compute Nothing p could take 2 seconds to compute and q could take 1 hour
15:39:46 <roconnor> mathijs: the size of Nothing is irrelevent compared to the overhead of pointing to nothing
15:41:45 <mathijs> dolio: the monad law you state... does GHC know about it? (so it can short-circuit in the Nothing example)? or should it be put into the RULES file?
15:41:49 <roconnor> mathijs: would   n@Nothing >>= _ = n   matter?
15:42:00 <roconnor> mathijs: all values are immutable, so it does not matter
15:44:24 <mathijs> roconnor: I get that. It's just that 'immutability' sometimes means copying an 'object' when trying to 'change' it. Which of course doesn't apply to Nothing.
15:46:02 <roconnor> mathijs: I see.  I'm not sure if you get sharing with n@Nothing >>= _ = n
15:46:09 <roconnor> intresting question
15:47:00 <mathijs> roconnor: well, if ghc knows there's only 1 Nothing in the whole world(process), my guess would be that it's automatically shared?
15:47:27 <roconnor> mathijs: I don't think that is the case
15:47:52 <roconnor> but I'm not a GHC expert
15:47:53 <mathijs> roconnor: or do you mean using Nothing instead of n will make ghc look up again where Nothing is?
15:48:07 <int-e> roconnor: the point is moot. Nothing is a unary constructor, and afaik these are always shared. But yes, you get sharing in that case.
15:48:09 <roconnor> mathijs: well, I expect it to create a new nothing
15:48:44 <roconnor> mathijs: which I presume is 1 Word in size holding the value 0
15:50:55 <mathijs> yeah it's a bit strange. allocating a new Nothing isn't expensive, perhaps cheaper than keeping track if Nothing is already allocated somewhere else.
15:52:20 <mathijs> int-e: do you suggest that there's at any time only 1 allocation of Nothing in memory, and all uses point to that single 'instance'?
15:52:21 <Cheshire> mathijs, I don't think it allocates a new Nothing
15:53:00 <Cheshire> mathijs, would really have to double check against a specific implementation
15:53:22 <dolio> mathijs: I don't think GHC does optimizations based on the monad laws.
15:54:01 <roconnor> > 2048/22.756
15:54:02 <lambdabot>   89.9982422218316
15:54:07 <mathijs> well it's not a real issue I guess, but it's interresting to know those small internal workings to see the bigger picture
15:54:12 <int-e> mathijs: yes
15:54:45 <mathijs> dolio: but putting it in RULES will make it optimize them?
15:55:03 <mathijs> dolio: or can it get worse, like you said?
15:55:10 <dolio> Sure, if you can get it to recognize it correctly.
15:55:15 <dolio> Which might be a challenge, I don't know.
15:55:49 <dolio> Yes, well, ((m >>= f) >>= g) >>= h is usually preferable.
15:56:13 <mathijs> well, that brings me to another question... do RULES mandate ghc to apply them all the time, or just concider using them?
15:56:24 <dolio> Since it's less nested.
15:57:14 <mathijs> dolio: I guess it depends on the monad being strict or lazy
15:57:52 <dolio> Like, in the list monad (m >>= f) >>= g loops over m with f, collecting the results, and then loops over that with g.
15:58:13 <dolio> Whereas m >>= \x -> f x >>= g is like nested loops.
15:58:23 <mathijs> for lazy monads right associativity seems preferable (just like foldr being better than foldl)
15:59:16 <dolio> Generally I'd say you want to limit the scope of the intermediate things (here x is an intermediate) as much as possible.
15:59:34 <dolio> Since it probably lets you garbage collect them earlier.
15:59:36 <roconnor> > 768*2
15:59:37 <lambdabot>   1536
16:01:46 <dolio> Unfortunately going from something like 'm >>= \x -> f x >>= g' to 'm >>= f >>= g' is the harder optimization (I think), becuase you have to figure out the appropriate scope of x before you can do anything.
16:02:36 <mathijs> dolio: can't that be done at compile-time most of the time?
16:02:51 <int-e> mathijs: although it's not true in ghci, apparently: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1364#a1364
16:04:28 <dolio> Well, it'd always be a compile-time thing. But I'd rate finding x's minimal scope and pruning it to that as harder than adding a fresh variable and extending its scope as much as possible.
16:06:46 <let_f_> http://lispclub.com/
16:06:47 <dolio> And, further, standard do notation always translates into 'm >>= \x -> f x >>= g' style.
16:06:57 <let_f_> ^^ why sint it the same just running his?
16:07:05 <let_f_> bayes rule ok but how do I formulate it?
16:07:06 <dolio> Writing 'm >>= f >>= g' style things in do notation looks really weird.
16:07:22 <roconnor> dolio: with good reason, that is how scoping of variables works.
16:07:34 <dolio> Yeah.
16:08:10 <mathijs> int-e: cool testcase you posted :)  I don't exactly know some of the stuff you're using, but I do get its implication :)
16:08:12 <dolio> I'm not saying it doesn't make sense.
16:08:43 <int-e_> mathijs: (the behaviour in ghci doesn't surprise me much - interpreted code is a different beast from compiled code)
16:08:55 <dolio> But then you get things like dpiponi writing "do { x <- do { y <- do { z <- ... } } }" in a blog post to get order of magnitude speedups. :)
16:09:40 <mathijs> dolio: that looks awful
16:09:45 <dolio> Right.
16:10:35 <int-e> mathijs: reallyUnsafePtrEquality# answers the question whether two thunks are stored in the same location (i.e. whether they are the same thunk). I# is just the constructor for the Int data type.
16:11:01 <dolio> , let x = Nothing ; y = Nothing in x .==. y
16:11:03 <lunabot>  True
16:11:25 <eu-prleu-peupeu> has anyone managed to build the haskell sdl stuff for windows ?
16:11:38 <mathijs> it's one thing that bothers me about haskell... many times different notations can have very different performance. It feels weird that a very high level language needs low-level tuning to get more performance.
16:11:43 <int-e> mathijs: (and you should never have to use it, I think. I'm not sure why it even exists.)
16:12:07 <mathijs> int-e: well that much I figured :)
16:12:29 <dolio> , let x :: Maybe Int ; x = Nothing ; y :: Maybe char ; y = Nothing ; (unsafeCoerce x) .==. y
16:12:31 <lunabot>  luna: parse error on input `)'
16:12:34 <dolio> , let x :: Maybe Int ; x = Nothing ; y :: Maybe char ; y = Nothing ; in (unsafeCoerce x) .==. y
16:12:35 <lunabot>  luna: Not in scope: `unsafeCoerce'
16:12:39 <dolio> Aww.
16:13:44 <iago_> @src callCC
16:13:44 <eu-prleu-peupeu> mathijs: just wait until whole program optimization comes to the party
16:13:44 <lambdabot> Source not found. Do you think like you type?
16:13:45 <int-e> dolio: yes, that will be true as well.
16:14:04 <let_f_> bayes rule ok but how do I formulate it?
16:14:31 <dolio> Actually, it won't.
16:14:41 <dolio> Probably because unsafeCoerce x is a thunk...
16:14:59 <int-e> dolio: it will work in compiled code (where unsafeCoerce is a true noop)
16:15:13 <dolio> Ah. Yeah, I believe that.
16:15:47 <int-e> dolio: hmm. oh I tested with unsafeCoerce# - for unsafeCoerce, unsafeCoerce will have to get inlined for that to work.
16:15:57 <roconnor> > 30 / 9
16:15:59 <lambdabot>   3.3333333333333335
16:16:01 <mathijs> but I decided not to pay too much attention to those optimization-tricks. functional languages _should_ describe what stuff _is_ instead of _how_ to get to the result. So to me f >>= g if the same as f >>= \x -> g x. And probably when ghc improves over time, many of these optimizations will be done automatically whenever possible.
16:16:03 <dolio> Oh, okay.
16:16:07 <roconnor> > 30 / 9 :: Rational
16:16:08 <lambdabot>   10%3
16:16:27 <eu-prleu-peupeu> http://darcs.haskell.org/~lemmih/hsSDL/hssdl/WIN32 is really sweet
16:16:28 <eu-prleu-peupeu> :D
16:19:37 <mathijs> I think this is the first time I heard 'sweet' and WIN32 in one sentence :)
16:20:41 <roconnor> > (30 / 9)^2
16:20:42 <lambdabot>   11.111111111111112
16:21:39 <score> mm, there a reason why adding -- enable-documentation: True to .cabal/config doesn't cause cabal to actually generate the documentation?
16:21:54 <dcoutts> score: you need to uncomment it
16:21:57 <roconnor> > 2048 * 10/3
16:21:58 <lambdabot>   6826.666666666667
16:22:17 <score> dcoutts: aha, thought it was kind of like --enable-documentation on the command line
16:22:22 <roconnor> > 1536 * 10/3
16:22:23 <lambdabot>   5120.0
16:23:04 * cschneid finally got Real World Haskell.  Yay.  What's a good gui framework for the mac. Is there an easy way to make native guis w/ haskell on osx?
16:23:18 <Nafai> cschneid: Apparently HOC, I hear can
16:23:46 <mathijs> roconnor: are floats internally kept as rationals? or will doing lots of calculations on them get less exact on every 'step' ?
16:24:33 <cschneid> Nafai: slick
16:26:02 <roconnor> mathijs: doing lots of calculations on them get less exact on every 'step'.
16:26:16 <roconnor> mathijs: use CReal for exact real number computaiton
16:26:20 <roconnor> pi :: CReal
16:26:23 <roconnor> > pi :: CReal
16:26:24 <lambdabot>   3.1415926535897932384626433832795028841972
16:26:56 <roconnor> > tan (10) :: CReal
16:26:58 <lambdabot>   0.6483608274590866712591249330098086768169
16:27:07 <roconnor> > tan (10**10) :: CReal
16:27:09 <lambdabot>   -0.5583496378112418465618934073186368185816
16:27:17 <roconnor> > tan (10**(10**10)) :: CReal
16:27:32 <lambdabot>   thread killed
16:27:38 <mathijs> roconnor: CReal's won't degrade when doing lots of computations on them?
16:27:38 <roconnor> > tan (10)
16:27:40 <lambdabot>   0.6483608274590866
16:27:45 <roconnor> > tan (10**10)
16:27:46 <lambdabot>   -0.5583496378112418
16:27:55 <roconnor> > tan (10**(10**10))
16:27:57 <lambdabot>   NaN
16:27:59 <roconnor> mathijs: nope
16:28:12 <encryptio> roconnor: they just get slow?
16:28:13 <rwbarton> only the performance might degrade :)
16:28:19 <roconnor> hmm 10^10 is too easy
16:28:24 <roconnor> > tan (10**100)
16:28:25 <lambdabot>   -0.4116229628832498
16:28:31 <roconnor> > tan (10**100) :: CReal
16:28:32 <lambdabot>   0.4012319619908143541857543436532949583239
16:28:49 <mathijs> > (pi :: CReal) / 10^1000 * 10^1000
16:28:51 <lambdabot>   3.1415926535897932384626433832795028841972
16:28:55 <roconnor> > (tan (10**1000),  tan (10**1000) :: CReal)
16:29:10 <lambdabot>   thread killed
16:29:16 <roconnor> oh too much
16:29:22 <roconnor> > (tan (10**200),  tan (10**200) :: CReal)
16:29:25 <lambdabot>   (-0.8417321552123704,-3.9335305454529854344687231582890482259966)
16:29:31 <shapr> So, who do I ask about creating a mailing list on haskell.org?
16:29:41 <shapr> I hope it's not me :-/
16:29:56 <roconnor> > pi / 10^1000 * 10^1000
16:29:57 <lambdabot>   NaN
16:30:33 <rwbarton> > pi / 10^25 * 10^25
16:30:34 <lambdabot>   3.141592653589793
16:30:36 <dolio> > 0 * 10^1000 :: Double
16:30:37 <lambdabot>   NaN
16:30:52 <roconnor> > 0 * 10^1000 :: CReal
16:30:53 <lambdabot>   0.0
16:31:19 <roconnor> > deriv (\x -> x**x) x
16:31:20 <lambdabot>   (1 * recip x * x + log x * 1) * exp (log x * x)
16:31:46 <roconnor> > deriv (\x -> x**x) pi :: CReal
16:31:48 <lambdabot>   78.2014834121896345036951435212340559438021
16:32:11 <ddarius> shapr: There's a haskell-admin@haskell.org which which doesn't sound like the right email but it probably still goes to the person you'd need to talk to anyway or that person can probably answer your question.
16:32:36 <ddarius> Also, mailman@haskell.org
16:33:25 <mathijs> hrm... NaN is interresting, I can't say "let n = NaN", but when doing "let n = pi / 10^1000 * 10^1000" n gets the value NaN, and :t n tells me n is a valid Double
16:33:54 <roconnor> > isNaN (10^1000)
16:33:55 <lambdabot>   False
16:34:06 <roconnor> > isNaN (pi / 10^1000 * 10^1000)
16:34:07 <lambdabot>   True
16:34:12 <mathijs> ah... so I can compare to NaN :)
16:34:24 <roconnor> > join (==) (pi / 10^1000 * 10^1000)
16:34:25 <lambdabot>   False
16:34:29 <dolio> > (0/0) == (0/0)
16:34:31 <lambdabot>   False
16:34:35 <dolio> > (0/0) /= (0/0)
16:34:36 <lambdabot>   True
16:34:38 <roconnor> > (pi / 10^1000 * 10^1000) == (pi / 10^1000 * 10^1000)
16:34:39 <lambdabot>   False
16:34:55 <mathijs> dolio: that's odd?
16:35:22 <roconnor> mathijs: NaN is not in the "domain" of the Doubles, so it isn't equal to itself.
16:35:48 <ozy`> mathijs: that's standard IEEEEEEE behavior, IIRC.
16:36:03 <dolio> I'd actually kind of expect NaN /= NaN to be True. But who knows.
16:36:10 <dolio> Er, be False.
16:36:26 <roconnor> dolio: interesting.
16:36:29 <ozy`> > 0/0
16:36:30 <lambdabot>   NaN
16:36:37 <roconnor> dolio: think the IEEE has something to say about that.
16:36:54 <dolio> Could be. I've never investigated it much.
16:36:54 <mathijs> dolio: what would you expect of (1/0) /= (0/0) ?
16:36:58 <roconnor> dolio: it would be a justification of having both (==) and (/=) in the Eq class
16:37:32 <dolio> > (1/0) /= (0/0)
16:37:33 <lambdabot>   True
16:38:02 <dolio> I don't know.
16:38:05 <ozy`> > let x = 0/0 in x == x
16:38:06 <lambdabot>   False
16:38:36 <dolio> I kind of expect NaN to be like NULL in SQL. But in that case you have NULL /= NULL = NULL.
16:39:35 <mathijs> well (0/0) /= (0/0) somehow implies there are different kinds/grades of NaN
16:41:06 <mathijs> sqrt (-1) == sqrt (-1)
16:41:10 <mathijs> > sqrt (-1) == sqrt (-1)
16:41:11 <lambdabot>   False
16:41:56 <dolio> GCC does NaN /= NaN = True, as well.
16:42:34 <roconnor> the worsts is compare (0/0) (0/0)  It ought to return an error, but doesn't.
16:42:48 <dolio> > compare (0/0) (0/0)
16:42:49 <lambdabot>   GT
16:42:52 <dolio> Heh.
16:43:22 <dolio> Anyhow, in another way, I expect NaN to be incomparable to every Double, including itself.
16:43:23 <mathijs> dolio: hehe that's even weirder
16:43:39 <mathijs> incompatible as in GT? :)
16:43:53 <biddi> how do I repeat a function call
16:43:54 <biddi> ?
16:44:06 <biddi> runRound = takeWhile (/= 6) $ repeat $ R.randomRIO (1::Int, 6)
16:44:23 <roconnor> biddi: I've always had to write my own function for that.
16:44:24 <mathijs> > compare (100/0) (10/0)
16:44:25 <lambdabot>   EQ
16:44:45 <dolio> So, since Eq doesn't allow for that, always returing False seems not so weird.
16:44:48 <mathijs> well that makes sense :)
16:44:50 <Gracenotes> @hoogle randoms
16:44:50 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
16:48:06 <roconnor> @hoogles randomsIO
16:48:07 <lambdabot> Maybe you meant: hoogle hoogle+
16:48:08 <dolio> I'm not sure what that'd make Double, though. That's not even a partial order.
16:48:11 <roconnor> @hoogle randomsIO
16:48:12 <lambdabot> No results found
16:48:17 <roconnor> @hoogle randomIOs
16:48:18 <lambdabot> No results found
16:48:39 <roconnor> @hoogle IO [a]
16:48:39 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
16:48:39 <lambdabot> Control.Concurrent.Chan getChanContents :: Chan a -> IO [a]
16:48:39 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
16:48:46 <roconnor> @hoogle+
16:48:46 <lambdabot> Prelude getContents :: IO String
16:48:47 <lambdabot> Prelude getLine :: IO String
16:48:47 <lambdabot> System.IO getContents :: IO String
16:48:50 <roconnor> bah
16:48:54 <mathijs> [compare (0/0) (0/0), compare (0/0) (1/0), compare (1/0) (0/0), compare (1/0) (1/0)]
16:48:57 <mathijs> > [compare (0/0) (0/0), compare (0/0) (1/0), compare (1/0) (0/0), compare (1/0) (1/0)]
16:48:58 <lambdabot>   [GT,GT,GT,EQ]
16:49:12 <zax> > product [1..7] `div` (product [1..4] * product [1..3])
16:49:13 <lambdabot>   35
16:49:57 <biddi> everytime i use random nbrs in haskell i feel suicidal
16:51:15 <dons> > randomRs (1,6) (mkStdGen 42) :: [Int]
16:51:16 <lambdabot>   [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,...
16:51:18 <dons> easy peasy
16:52:01 <Gracenotes> Critical Success(TM)
16:52:09 <dolio> Just make sure you call mkStdGen with a truly random number.
16:52:15 <dolio> Like, one you got by rolling dice.
16:52:26 <iago_> > getStdGen >>= return . randomRs (1,6)
16:52:27 <lambdabot>   * Exception: "<IO [Integer]>"
16:52:37 <iago_> :S
16:52:52 <brad_larsen> TH question
16:52:54 <mathijs> anyway, goodnight all. thanks for all help
16:52:59 <shapr> biddi: They're only pseudorandom, you're safe.
16:53:19 <biddi> yeah except it starts with 6 so ...
16:53:25 <iago_> > print "a"
16:53:27 <lambdabot>   * Exception: "<IO ()>"
16:53:27 <biddi> fails evryt iem on firs
16:53:28 <brad_larsen> I want to know if this is possible with TH:
16:53:43 <brad_larsen> I want perl-like string interpolation, for multiline strings
16:53:45 <ddarius> shapr: Find the email or take a shot in dark yet?
16:54:00 <ddarius> brad_larsen: With the new quasiquotation stuff, anything is possible.
16:54:10 <brad_larsen> I'm looking at the multiline string literal quasiquoter here: <http://groups.google.com/group/fa.haskell/browse_thread/thread/0172df171348c8bc/6a63dc4540f0486d?#6a63dc4540f0486d>
16:54:47 <shapr> ddarius: not yet
16:54:57 <biddi> tso how do i get this truly random nbr
16:55:13 <brad_larsen> I'm hoping to use a quasiquoter like so:  [$qq|hello $name|]
16:55:24 <shapr> biddi: Use packet reception intervals?
16:55:25 <brad_larsen> where $name is a variable, `name' in scope
16:55:29 <brad_larsen> in the haskell code
16:55:51 <biddi> let suicide = (repeat . gunToMouth . pointToHead)
16:55:57 <brad_larsen> (or more precisely, where `name' is a Haskell string, in scope at the use of the quasiquoter)
16:56:04 <biddi> takeWhile alive suicide
16:56:09 <brad_larsen> is this something that it is possible to do now with TH?
16:56:58 <ddarius> brad_larsen: It is something, therefore it falls under anything and thus it is possible to do as I said before.
16:57:26 <biddi> how can i test eq on IO Int?
16:58:10 <roconnor> @type liftM2 (==)
16:58:11 <lambdabot> forall a1 (m :: * -> *). (Monad m, Eq a1) => m a1 -> m a1 -> m Bool
16:58:31 <brad_larsen> ddarius, I guess I'll have to read more then.
16:58:42 <roconnor> biddi: but you probably want to do the test inside a do block
16:58:48 <biddi> where is liftM2?
16:58:50 <Gracenotes> @type liftM2 (||)
16:58:51 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
16:58:57 <roconnor> @hoogle liftM2
16:58:57 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:58:58 <Gracenotes> now, if only there were an ifM...
16:59:16 <Gracenotes> m Bool -> m a -> m a -> m a
16:59:24 <brad_larsen> @type when
16:59:25 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:59:40 <Gracenotes> note the not-very-monadish Bool :P
16:59:42 <biddi> if r CM.liftM2 (==) 6
16:59:42 <brad_larsen> not quite
16:59:44 <biddi> how?
16:59:44 <brad_larsen> heh
17:00:10 <roconnor> biddi: what is r?
17:00:31 <biddi> io int
17:00:49 <biddi> roll :: IO Int
17:01:19 <roconnor> do { i <- r; if r == 6 then fooAction else barAction }
17:01:22 <roconnor> er
17:01:25 <roconnor> do { i <- r; if i == 6 then fooAction else barAction }
17:01:42 <roconnor> or
17:01:47 <biddi> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1365#a1365
17:01:54 <roconnor> do { i <- r; when (i == 6) fooAction }
17:01:56 <roconnor> or
17:02:01 <roconnor> do { i <- r; unless (i == 6) fooAction }
17:03:21 <Gracenotes> roconnor: yes, that's the long way to do with it. (there is no short way)
17:03:39 <Gracenotes> unfortunately, it fails for lazy || and && :/
17:04:15 <augustss> we need ifM (with monadic condition)
17:04:17 <roconnor> biddi: do { gen <- getStdGen; takeWhile (/=6) R.randomRs (1,6) gen}
17:05:58 <biddi> Couldn't match expected type `[a]'
17:05:58 <biddi>            against inferred type `(a1, a1) -> g -> [a1]'
17:06:01 <ozy`> augustss: like this? do { p <- pred; if p then fstop else sndop }
17:06:10 <Axman6> :t do { gen <- getStdGen; takeWhile (/=6) R.randomRs (1,6) gen}
17:06:11 <lambdabot> Couldn't find qualified module.
17:06:24 <augustss> ozy`: yeah
17:06:35 <ddarius> ozy`: Lord.  'fstop' and 'sndop' are worse than 't' and 'e'
17:07:01 <roconnor> @type takeWhile (/=6) . randomRs (1,6) `liftM` getStdGen
17:07:02 <lambdabot>     precedence parsing error
17:07:02 <lambdabot>         cannot mix `(.)' [infixr 9] and `liftM' [infixl 9] in the same infix expression
17:07:07 <ozy`> ddarius: okay. then substitute "froz" and "quux"
17:07:09 <roconnor> @type (takeWhile (/=6) . randomRs (1,6)) `liftM` getStdGen
17:07:11 <lambdabot> forall a. (Random a, Num a) => IO [a]
17:07:29 <roconnor> I like the do notation better
17:07:55 <Gracenotes> @hoogle withM
17:07:56 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
17:07:56 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
17:07:56 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
17:08:02 <ddarius> :t takeWhile (/=6) . randomRs (1,6) <$> getStdGen
17:08:03 <lambdabot> forall a. (Random a, Num a) => IO [a]
17:08:37 <iago_> :t runRand
17:08:38 <lambdabot> Not in scope: `runRand'
17:08:41 <dons> Whatâ€™s Haskellâ€™s biggest weakness?
17:08:44 <iago_> no monadrandom ;P
17:08:48 <Gracenotes> @hoogle Monad m => m a -> (a -> b) -> m b
17:08:49 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
17:08:49 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:08:49 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
17:08:58 <biddi> dons: Monads
17:09:09 <biddi> and zip8
17:09:18 <ddarius> dons: Technically or more generally.
17:09:20 <ddarius> ?
17:09:22 <dons> zip8 rocks. who's with me!
17:09:30 <Gracenotes> hm :/ It's nice that liftM works nicely as a functor, but I think a withM = flip liftM might be nice
17:09:34 <dons> ddarius: for a broad audience (reading an interview).
17:09:44 <Gracenotes> if only for the same reason we have forM (vs. mapM)
17:09:53 <dons> ddarius: its an interview question i'm going through.
17:09:56 <ddarius> dons: It's biggest weakness is that it is not a slight variation on Java.
17:10:00 <dons> yepa
17:10:18 <Gracenotes> how are we doing on distributed concurrency?
17:10:20 <biddi> its biggest weakness is that it doesnt compromise
17:10:31 <ddarius> Gracenotes: We aren't.
17:10:34 <biddi> i think it will stay in research and others will copy the good stuff
17:10:39 <Gracenotes> :)
17:10:45 <biddi> from it but not adapt the langauge itself
17:11:01 <Gracenotes> something that possibly needs to be worked on, then, given that I'm sure there's potential
17:11:17 <biddi> erlanf is over there looking smug ->
17:11:21 <biddi> erlang
17:11:38 <Gracenotes> > Just 4 `flip liftM` show
17:11:39 <lambdabot>   <no location info>: parse error on input `liftM'
17:11:43 <Gracenotes> :x
17:12:09 <ddarius> One GSoC project that I'd take in a slightly different one (the one for an SNMP library) would be to start an idiomatic copy of OTP.
17:12:21 <Gracenotes> one of the professors in my CS department said that Haskell was
17:12:26 <Gracenotes> erm
17:12:30 <ddarius> That said, there is some infrastructure support that Haskell is lacking and would not be trivial to add.
17:12:34 <Gracenotes> "fascistly functional"
17:12:49 <ddarius> "fascistly" == "actually"
17:12:52 <Axman6> heh
17:13:04 <StoneToad> Gracenotes: unsafePerformIO :)
17:13:04 <Axman6> Gracenotes: and he had a problem with that?
17:13:28 <Gracenotes> he's used to OCaml, apparently he finds Haskell too arbitrarily structured, or somelike
17:13:32 <rwbarton> :t (<$$>)
17:13:33 <lambdabot> Not in scope: `<$$>'
17:13:47 <Gracenotes> or seemingly arbitrary. Monads kinda did come from out of nowhere, after all...
17:14:18 <ddarius> Objects came out of nowhere too.
17:14:47 <lament> tell aristotle that
17:14:49 <Gracenotes> well, versus from some corner of category theory
17:15:06 <ddarius> lament: Bring him over and I will.
17:15:45 <iago_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1366 <- someone knows how I could make OtherT MonadTrans and MonadStateW at the same time?
17:18:25 <rwbarton> @src MonadState
17:18:25 <lambdabot> Source not found. It can only be attributed to human error.
17:19:23 <rwbarton> OtherT doesn't have the right kind to be an instance of MonadStateW, if I am reading it correctly
17:21:01 <rwbarton> And it's either already an instance of MonadTrans, or it can't be because it's a type synonym
17:22:39 <rwbarton> Is there a 6.10.2 release candidate yet?
17:22:55 <iago_> well, the question is more: there is a way of define a monad to be at the same time MonadTrans and MonadStateW?
17:23:43 <mmorrow> brad_larsen: it'd look something like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1316#a1316
17:23:52 <rwbarton> No, because the type classes MonadTrans and MonadStateW have arguments of different kinds
17:23:53 <mmorrow> that's the basic shell at least
17:24:07 <rwbarton> StateT is an example of MonadTrans, State is an example of MonadStateW
17:24:20 <rwbarton> You could modify MonadStateW to a "MonadStateTW", though.
17:25:58 <jonaskoelker> hi all
17:26:21 <mmorrow> @tell brad_larsen the basic shell might look something like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1316#a1316
17:26:22 <lambdabot> Consider it noted.
17:31:14 <iago_> rwbarton, uhmm
17:31:20 <iago_> this could be the solution
17:42:33 <mmorrow> augustss: totally. also i find myself wishing for `whenM' daily
17:43:03 * ddarius rarely wants whenM.
17:43:27 <mmorrow> heh, i always want whenM
17:44:08 <ddarius> I have to make all my crazy code be crazier. *sigh*
17:45:12 <mmorrow> @pl \m o -> flip when o =<< m
17:45:12 <lambdabot> (. flip when) . (>>=)
17:45:45 <mmorrow> hmm, doesn't quite cut it
17:45:59 <mmorrow> @let whenM = (. flip when) . (>>=)
17:46:00 <lambdabot>  Defined.
17:46:17 <rwbarton> I can't imagine you'd need the pointfree version of whenM very often.
17:47:19 <ddarius> Tip: Use when infix to confuse your readers.
17:49:13 <brad_larsen> mmorrow, thanks.  checking it out now.
17:49:13 <lambdabot> brad_larsen: You have 1 new message. '/msg lambdabot @messages' to read it.
17:49:18 <mmorrow> i usually settle with     flip when blah =<< isItNoonYetM
17:49:26 <kerlo> Oh, when is backwards.
17:49:54 <mmorrow> well, it's backwards if you want it to take a monadic condition
17:50:21 <dolio> > True `when` tell "w00t" :: (String,())
17:50:22 <lambdabot>       No instance for (MonadWriter [Char] ((,) String))
17:50:22 <lambdabot>        arising from a...
17:51:02 <kerlo> "x `when` y" means y when x.
17:51:39 <mmorrow> oh, yeah if you use it infix i guess it sounds backwards compared to how you'd say it
17:52:11 <mmorrow> kinda like subtract
17:52:14 <kerlo> @hoogle while
17:52:14 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
17:52:14 <lambdabot> Data.ByteString dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
17:52:14 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
17:52:20 <kerlo> @index while
17:52:20 <lambdabot> bzzt
17:52:21 <mmorrow> , 42 `subtract` 100
17:52:22 <lunabot>  58
17:52:41 * mmorrow has a good while
17:52:48 <kerlo> Clearly, we should use while = flip when instead.
17:52:58 <dolio> It's mildly confusing if you're used to the languages where you can say "e if p" in lieu of "if p e".
17:53:04 <kerlo> Yes, but we don't say "42 subtract 100", we say "from 42 subtract 100".
17:53:06 <dolio> Or, I suppose it would be.
17:53:18 <kerlo> > let from x y z = y z x in from 42 subtract 100
17:53:20 <lambdabot>   -58
17:53:33 <kerlo> > let from x y z = y z x in from 42 mod 100
17:53:34 <lambdabot>   16
17:53:48 <kerlo> I don't think it means anything with mod.
17:53:51 <mmorrow> @let ref a = newSTRef a
17:53:52 <lambdabot>  Defined.
17:54:06 <mmorrow> > (!)
17:54:07 <lambdabot>       Overlapping instances for Show (Array i e -> i -> e)
17:54:07 <lambdabot>        arising fro...
17:54:23 <dolio> @type flip flip
17:54:24 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
17:54:34 <dolio> @type let from x y z = y z x in from
17:54:35 <lambdabot> forall t t1 t2. t -> (t1 -> t -> t2) -> t1 -> t2
17:54:59 <mmorrow> @let (!!!) = readSTRef
17:55:00 <lambdabot>  Defined.
17:55:19 <mmorrow> @let goto  = join . (!!!)
17:55:20 <lambdabot>  Defined.
17:55:33 <geezusfreeek> goto?
17:55:36 <Axman6> :t readSTRef
17:55:37 <lambdabot> forall s a. STRef s a -> ST s a
17:55:56 <dolio> @type goto
17:55:57 <lambdabot> forall s a. STRef s (ST s a) -> ST s a
17:56:23 <geezusfreeek> huh, like a continuation
17:57:16 <mmorrow> @let (.=) = writeSTRef
17:57:17 <lambdabot>  Defined.
17:57:49 <Axman6> :t (.=)
17:57:50 <lambdabot> forall s a. STRef s a -> a -> ST s ()
17:58:12 <roconnor> @bab nl en Gewenste oplage:
17:58:13 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
17:58:19 <desp> Does anyone know of a Haskell vs Scala comparison, in the spirit of http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html ?
17:58:50 <mmorrow> @let whileST p f a = mdo x <- ref a; k <- ref (do v <- (x!!!); (if p v then (x.=) =<< f v else k .= return v); goto k); goto k
17:58:50 <lambdabot>  <local>:8:22: parse error on input `<-'
17:59:11 <mmorrow> @let asdfdsasd = mdo (return 2) :: ST s Int
17:59:12 <lambdabot>  <local>:8:12: Not in scope: `mdo'
17:59:33 <mmorrow> crap
18:00:03 <SamB_XP> @go site trac.haskell.org
18:00:07 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/
18:00:07 <lambdabot> Title: Haskell Prime - Trac
18:00:09 <SamB_XP> @go site:trac.haskell.org
18:00:09 <lambdabot> No Result Found.
18:00:53 <mmorrow> @type let whileST p f a = mdo x <- ref a; k <- ref (do v <- (x!!!); (if p v then (x.=) =<< f v else k .= return v); goto k); goto k in whileST
18:00:54 <lambdabot> forall a s. (a -> Bool) -> (a -> ST s a) -> a -> ST s a
18:01:02 <Axman6> SamB_XP: gotta give it a search term too
18:01:09 <SamB_XP> @go site:trac.haskell.org trac
18:01:09 <lambdabot> No Result Found.
18:01:29 <Axman6> @go trac sire:trac.haskell.org
18:01:30 <lambdabot> No Result Found.
18:01:34 <Axman6> meh
18:01:40 <mmorrow> @type let whileST p f a = mdo x <- ref a; k <- ref (do v <- (x!!!); (if p v then (x.=) =<< f v else k .= return v); goto k); goto k in \p f a -> runST (whileST p (return . f) a)
18:01:41 <lambdabot> forall b. (b -> Bool) -> (b -> b) -> b -> b
18:02:05 <SamB_XP> @go site:haskell.org
18:02:06 <lambdabot> No Result Found.
18:02:11 <SamB_XP> @go site:haskell.org trac
18:02:12 <lambdabot> http://hackage.haskell.org/trac/ghc/
18:02:12 <lambdabot> Title: GHC - Trac
18:04:45 <brad_larsen> mmorrow, thanks for that code snippet.  It's enough to get me started.
18:06:39 <mmorrow> brad_larsen: cool, glad i could help
18:06:44 <code_m> Does anyone use nano for writting their code?
18:07:01 <mmorrow> here's the nicely formatted version of `while' http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1317#a1317
18:07:01 <Axman6> once for quick edits
18:08:57 <code_m> I'm asking because nano is my favorite editor... and I love syntax.
18:09:07 <code_m> syntax highlighting*
18:09:18 <ddarius> Use whatever editor you want.
18:10:07 <code_m> ddarius: I know, but I would like highlighting, and it's sorta hard to write a syntax for nano if you don't know the language.
18:10:26 <ddarius> @google nano haskell syntax highlighting
18:10:27 <lambdabot> No Result Found.
18:11:31 <straw_> Hey
18:11:36 <Axman6> o/
18:11:55 <straw_> Can you give me a hint how to output line-by-line? Something like: http://pastebin.com/d37ae6222
18:12:14 <ddarius> code_m: Okay, then you might be screwed.
18:13:31 <dancor> does yi have a nano mode?
18:14:44 <code_m> dancor: yi ?
18:14:58 <dancor> code_m: it's an editor written in haskell
18:15:12 <code_m> oh
18:15:19 <code_m> I'll pacman it...
18:15:22 <dancor> straw_: you are trying to write func in terms of test and sh?
18:15:48 <Shiruka> nano mode = disable all features and add a help text on the bottom?
18:16:06 <straw_> dancor: yup, in fact I want to see all the single computation steps of 'test'
18:16:10 <dancor> @let sh a b = show a++" : "++show b++" = "++show(div a b)++" | Rest: "++show(mod a b)
18:16:11 <lambdabot>  Defined.
18:16:36 <dancor> @let test 0 _ = 0
18:16:37 <lambdabot>  Defined.
18:16:43 <dancor> @let test a b = test (div a b) b
18:16:44 <lambdabot>  Defined.
18:16:50 <dancor> test 27 2
18:16:52 <dancor> > test 27 2
18:16:53 <lambdabot>   0
18:17:12 * straw_ nods
18:17:32 <straw_> no fine-tuning done yet, because I wanted to sort out the "line-by-line part" first
18:18:05 <dancor> you want to print a and b at the beginning of every call to test..
18:18:33 <straw_> uhm, yes :>
18:19:41 <Axman6> see
18:19:45 <Axman6> Debug.Trace*
18:19:50 <dancor> you can do it with the fix function.  but it's going to be kind of heady
18:19:54 <dancor> yeah trace is what you want instead
18:20:22 <straw_> I'll have a look at it, thanks for the pointer!
18:20:25 <Axman6> something handy i saw defined somewhere was dbg x = trace (show x) x
18:20:36 <Axman6> @src Debug.Trace
18:20:36 <lambdabot> Source not found. My pet ferret can type better than you!
18:20:40 <Axman6> @src Debug.Trace.trace
18:20:40 <lambdabot> Source not found.
18:20:43 <Axman6> bah
18:21:20 <Axman6> it's something like trace x y = unsafePerformIO $ putStrLn x >> return y
18:22:07 <mmorrow> debug x = unsafePerformIO (print x >> return x)
18:22:52 <kerlo> Is that the same as unsafePerformIO (print x) `seq` x?
18:22:55 <Axman6> yeah
18:23:08 <Axman6> i think so
18:23:25 <mmorrow> i'm not positive, but probably close enough
18:24:42 <dancor> it's harder to use a fix-variant when there are two inputs and when the output type will not match the input (tuple) type
18:24:56 <dancor> but fix-variants are so cool
18:35:15 <dancor> oh i'm crazy, fix-variant works fine
18:38:16 <rwbarton> dons: I wrote a TinyURL package (well, it's only one function :)
18:38:25 <rwbarton> dons: but I don't have a hackage account yet
18:51:37 <dancor> rwbarton: a service, in happs or something?  or client (isn't there already that in lambdabot somewhere)
18:57:41 <rwbarton> dancor: just a function to take a URL and send it to tinyurl for a short version
18:57:59 <rwbarton> dancor: yeah, lambdabot does that too but the code uses some lambdabot utilities library
18:59:33 <dons> rwbarton: please request an account :)
19:06:16 <abuiles> Hi guys, Has someone had problems using HDBC.Postgresql to save a clockTime ?
19:06:19 <chessguy> hey ya'all
19:06:36 <abuiles> *type
19:06:51 <dancor> abuiles: yeah don't you have to make it into like two ints or something crazy
19:06:59 <dancor> iirc..
19:07:51 <Gracenotes> > "only two hyphens..." --
19:07:52 <lambdabot>   "only two hyphens..."
19:08:03 <Gracenotes> oh I see.
19:08:16 <rovar> hey chessguy
19:08:27 <chessguy> so i've been thinking about something strange today, wondering if it's related to continuations somehow
19:08:32 <chessguy> check this out: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1318#a1318
19:08:35 <abuiles> dancor: I found a partial solution and is convert the clockTime to string, and the apply toSql to the String that I got, that fix the problem in the db, once it recognized the type.
19:09:20 <abuiles> but I was just wonder if it is another way, of keeping the clockTime type.
19:12:13 <dancor> abuiles: not sure, i've also had to do hackery for it.  it's possible other db libraries can do it more type-sanely.  but it's probably hard to support date types and simultaneously support pg/mysql/etc
19:13:47 <abuiles> dancor: Thanks mate!
19:15:44 <gwern> I wonder why so few people cabalize packages like wash
19:15:49 <gwern> it's not that difficult
19:16:17 <chessguy> hm, no thoughts on my continuation-ish thing?
19:16:52 <gwern> continuations are just associated with wash in my mind :)
19:19:11 <chessguy> well, yeah
19:19:14 <chessguy> that too :)
19:20:58 <dsrogers> is there a formalized notion of a lift inverse?
19:23:45 <Axman6> drop >_>
19:25:03 <chessguy> hm, probably defining it in terms of State would have been better
19:26:45 <jberryman> chessguy: looks like a comonad, maybe?? it also is very similar to a zipper structure I'm using / created.
19:27:25 <Gracenotes> what would you put in a comonad instance? coreturn, cobind? cojoin, fmap?
19:29:08 * SamB wonders if cojoin is called part
19:29:13 <jberryman> chessguy: going back up the tree (or list or any other recursive type) is as simple as: goUp (f:fs, tree) = (fs, f tree)
19:30:28 <chessguy> hmm
19:31:20 <chessguy> jberryman:  the underlying list of functions is constantly changing though
19:31:24 <shapr> @seen edwardk
19:31:24 <lambdabot> I saw edwardk leaving #haskell 1h ago, and .
19:31:27 <shapr> bah
19:31:34 <byorgey> Gracenotes: if you make it a subclass of Functor, coreturn and cobind should do it.
19:31:46 <chessguy> jberryman:  like one of those functions could zero out the rest of the list
19:32:06 <Gracenotes> byorgey: so, you have to implement fmap and coreturn and cobind?
19:32:10 <byorgey> SamB: I think I've seen it called 'duplicate'
19:32:42 * SamB thinks he was thinking of IRC or something ;-P
19:33:59 <jberryman> chessguy: yeah, what kinds of things might you do with it?
19:34:04 <byorgey> Gracenotes: that would be sufficient, yes.
19:34:15 <byorgey> Gracenotes: you could also do fmap, coreturn, and cojoin.
19:34:20 <chessguy> jberryman: i'm considering using something like this to represent a strategy
19:34:27 <Gracenotes> ehmhm.
19:35:13 <chessguy> jberryman:  where the individual functions recognize things about the state, and influence, add to, or replace what is intended to happen later
19:42:54 <jberryman> chessguy: cool
19:46:25 <jberryman> has anyone done any tests measuring things like the performance differences in GHC between using 'compare' vs (>)... things like that?
19:46:51 <jberryman> I mean I'm sure people have profiled their own code, etc.
19:47:46 <jberryman> I guess I'm looking for good rules of thumb, so I know what I don't have to bother thinking about, performance-wise
19:53:37 <ddarius> Code crazified.
19:54:11 <ddarius> Gracenotes: In particular, cobind and coreturn imply fmap.
19:55:04 <Gracenotes> and they imply cojoin as well?
19:55:10 <ddarius> Yes.
19:55:22 <Gracenotes> hm... I see
19:55:35 <ddarius> This is why monad is just return and (>>=), though I prefer the categorical decomposition.
19:58:00 <Gracenotes> ddarius: and, going out on a limb, fmap+cojoin => cobind+coreturn?
19:59:20 <ddarius> Nqo
19:59:23 <ddarius> -q
19:59:29 <ddarius> fmap+cojoin+coreturn => cobind
20:00:16 <Gracenotes> ah, okay
20:01:17 <Gracenotes> I guess diagrams help :) Right now I'm working through a book on abstract algebra and one called Categories for Types... both interesting. I just need to actually finish them >_<
20:01:36 <Gracenotes> hopefully it'll help
20:02:45 <ddarius> Gracenotes: What's your goal, i.e. what is this going to "help"?
20:05:21 <gwern> I has a monad problem
20:05:22 <Gracenotes> uh, understanding various areas of abstract algebra. Also apparently Categories for Types talks about the lambda calculus, which I'm not terribly familiar with in a formal sense (beyond Church numerals)
20:06:14 <jberryman> Gracenotes: the control.comonad package has a good explanation of the realtionships between the different functions:
20:06:18 <jberryman> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad.html
20:06:21 <gwern> I have 'processWith :: (Data.Data.Data a, Data.Data.Data b) => (a -> a) -> b -> b' and  'convertWikiSign âˆ·  Inline â†’  IO Inline', and I want to do 'signed â†  processWith convertWikiSign wikid'. but is not working :(
20:06:21 <Gracenotes> O
20:06:28 * Gracenotes has looked at the source of that
20:07:00 <ddarius> Gracenotes: Category theory and monads don't fall under abstract algebra.
20:07:18 <ddarius> (Though they can be applied very well to it.)
20:07:45 <gwern> @type liftM
20:07:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:08:14 <Gracenotes> yeah, I know. It seems a good way to familiarize myself with the degree of formality/(for lack of better term) abstractness used in CT
20:08:29 <Gracenotes> plus, groups/rings apparently can be useful here and there
20:09:14 <gwern> hm. I could make convertWikiSign pure and get around it that way...
20:09:42 <Samad> hi all
20:09:47 <Gracenotes> > cycle "Data."
20:09:48 <lambdabot>   "Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data...
20:09:58 <Olathe> > cycle "up the hill"
20:10:00 <lambdabot>   "up the hillup the hillup the hillup the hillup the hillup the hillup the h...
20:10:06 <Samad> need help about driver programming
20:10:41 <ddarius> Gracenotes: So I think you misunderstood my question.  Your end goal is to understand category theory or abstract algebra?
20:11:06 <monochrom> Data.Structures.Year1960.I.Did.It.Uphill.Both.Ways
20:11:10 <Axman6> Samad: like hardware drivers?
20:11:38 <Gracenotes> ddarius: any combination of the two, really. I'd like to see if I can finish both of these books without getting horribly lost
20:11:42 <gwern> bleh, that didn't help at all
20:11:58 <Samad> no software driver
20:12:42 <Samad> software driver mean RAMDISK
20:13:40 <ddarius> Almost all my types are longer than the code they type...
20:14:16 <ddarius> Furthermore, all the functions are one-liners, but the not all the types are...
20:14:52 <monochrom> Use "sudo mkdir /tmp/haha; sudo mount haha /tmp/haha -t tmpfs" to create a ramdisk. It's present under /tmp/haha .
20:16:11 <mofmog> so i have a list of pairs and i have a function that determines if one is greater than the other
20:16:23 <mofmog> how do i find if the greater function defines a well ordered set?
20:17:06 <monochrom> I don't like the diction, but I suppose I see what you mean.
20:17:18 <mofmog> so far i have a crazy solution with the list monad where i also string through a list of pairs that are supposedly greater than the current pair, and then i generate a list of pairs smaller than the current.
20:17:34 <mofmog> if any pair in the smaller list is in the list of previously seen pairs, then we know it's not well ordered
20:18:40 <Gracenotes> @hoogle partitionEithers
20:18:40 <lambdabot> No results found
20:21:52 <mofmog> great, my solution died
20:22:19 <Gracenotes> is it in solution heaven now? :(
20:22:27 <monochrom> Give the function and the list to sortBy for sorting. Do not worry about whether sorting is meaningful; the next step will handle that. In the sorted list, check that the first item is "less than" everyone in the rest of the sorted list according to the given function, check that the 2nd item is "less than" everyone after it, etc.
20:23:35 <mofmog> oh ok
20:26:51 <mofmog> find that the first item is "less than" the rest of the list?
20:26:55 <mofmog> ok, i have the list sorted
20:30:18 <chessguy> hm. i want to do something like this:
20:30:20 <chessguy> class Strategy s where
20:30:20 <chessguy>     eval :: s a -> (a -> a)
20:30:21 <chessguy> instance Strategy (a -> a) where
20:30:21 <chessguy>     eval = id
20:30:28 <chessguy> oops
20:30:47 <chessguy> sorry, i thought that would get put together
20:30:50 <chessguy> anyway
20:30:59 <chessguy> the instance doesn't work, obviously
20:31:00 <noknok> Hello out there! This is my first visit and I am not sure if I understand how it works. I have written a Haskell program that should read from and write to a file. But when I run it, I get a complaint: "openFile: resource busy (file is locked)".  But the file isn't in use.
20:31:31 <chessguy> @hpaste2
20:31:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:31:33 <Axman6> did you open it in write mode?
20:31:44 <Axman6> @hoogle openFile
20:31:44 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
20:32:02 <chessguy> noknok:  welcome to the channel! can you paste your code on hpaste?
20:32:09 <Axman6> @src IOMode
20:32:09 <lambdabot> data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
20:32:48 <shukhov> writeFile can be used if you just want to write.
20:33:38 <gwern> it's kind of funny to work with gitit in ghci. the first real expression requires something like 40 libraries to be loaded in first :)
20:33:44 <noknok> Thanks Axman6. I used "input <- readFile filename"
20:34:25 <Gracenotes> that works too... iirc the string is lazy, though
20:34:53 <Gracenotes> so keep that in mind :)
20:36:47 <noknok> Thanks shukhov and lambdabot. I just use the functions from the PreludeIO and there are no r/w rights involved.
20:37:07 <pumpkin_> > text "you're welcome noknok"
20:37:09 <lambdabot>   you're welcome noknok
20:37:40 <Gracenotes> @thanks
20:37:40 <lambdabot> you are welcome
20:37:46 <Gracenotes> @vixen thanks
20:37:47 <lambdabot> you're very welcome!
20:38:11 <gwern> > [1..10] !! 1
20:38:12 <lambdabot>   2
20:39:16 <chessguy> hm, i'm sure there's some silly type hackery way to do this, but i don't know it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1367#a1367
20:41:41 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1368#a1368 <-- can't see what my syntax error here is
20:41:56 <rwbarton> chessguy: you need to define a newtype
20:42:09 <chessguy> i suspected as much, but where?
20:42:41 <noknok> There is a function  evalStr :: String -> String  in my program and I try to use that on the content of a file "standardIO.txt". So there is a "do" command with two lines input <- (readFile "standardIO.txt") and writeFile "standardIO.txt" (evalStr input). But then I get this error message.
20:43:01 <gwern> filehandle not closed?
20:43:06 <rwbarton> chessguy: newtype Foo a = Foo (a -> a); instance Strategy Foo where ...
20:43:16 <chessguy> ugh
20:43:18 <rwbarton> gwern: you have "case res of" followed by more stuff on that line
20:43:41 <noknok> What do you mean by filehandle? I just use a filename, don't I?
20:44:02 <gwern> oh, I forgot the case syntax. the result isn't named, it's just the expression
20:44:53 <gwern> yay, it compiles. let's see how well it works in practice
20:45:07 <noknok> In the PreludeIO there are  readFile :: FilePath -> IO String   and   writeFile :: FilePath -> String -> IO )
20:45:57 <rwbarton> noknok: that code reads the file lazily, which means writeFile might erase the file before it gets read, depending on your OS
20:46:03 <rwbarton> noknok: on windows you'll probably get an error message
20:47:13 <rwbarton> noknok: See if you get an error message if you change the output file name
20:47:16 <redditbot> Making Valentineâ€™s day special with Haskell and brainfuck.
20:47:46 <noknok> Hi rwbarton. I don't understand. Do you mean "input <- (readFile filename)" destroys the content? By the way, I use Linux.
20:48:12 <rwbarton> noknok: it will open the file, but not actually read any of the contents until the value of input is needed
20:48:39 <rwbarton> noknok: then writeFile will open the file again, for writing, and I'm not sure what the semantics of that are
20:50:33 <noknok> Hi rwbarton. I changed the standard file name in my program, recompiled it and run it. And now it complaints: "standardIO2.txt: openFile: does not exist..."
20:51:08 <rwbarton> just change the file name for writeFile, not the one for readFile
20:54:11 <noknok> Yes, rwbarton. I am using two file names now (reading from the input file "standardIO.txt" and writing to "standardOut.txt") and it works.
20:55:00 <Gracenotes> not standardIn? :P
20:55:11 <Gracenotes> (I kid, I kid)
20:55:35 <noknok> But this doesn't solve my overall problem. I want to use it as an executable in a PHP web page.........
20:59:28 <noknok> My idea was that a "standardIO.txt" file could server an the interface. There shall be a form on the web page, the user fills in some expression (e.g. an arithmetic term or simple task), the input is (via the "post" method) written into the "standardIO.txt", the Haskell executable evaluates the content and writes the result back, and that is then displayed in the web page again.
21:00:21 <rwbarton> I don't see why you'd want to use the same file for reading and writing
21:00:27 <rwbarton> but of course, you can if you want to
21:00:35 <rwbarton> you just need a non-lazy version of readFile
21:00:39 <shukhov> wouldn't it block many times?
21:02:24 <Gracenotes> or chaining processes together somehow? using stdin/stdout
21:03:18 <dsrogers> you shoudl write to a temp file in the same directory then rename as an atomic operation (well atomic on unix anyway)
21:03:30 <noknok> The file is just the interface and constantly changing anyway. The next problem of course would be when many user sent a request simultaneously...
21:03:33 <dsrogers> then a second thread can continue to serve the old file.
21:04:09 <dsrogers> that's a very typical way of solving that threading problem.
21:04:28 <noknok> rwbarton, what is a non-lazy version of readFile and why do you mean that?
21:06:55 <chessguy> @src repeat
21:06:55 <lambdabot> repeat x = xs where xs = x : xs
21:06:58 <noknok> dsrogers, thanks. I was thinking of passing the input/output without a file, just by standard input and standard output as values in the POST array. But I am not sure if that allows malicious input.
21:07:12 <chessguy> this is probably not the clearest way we can explain this function.
21:07:23 <chessguy> can soemone change the definition to repeat x = x : repeat x ?
21:07:47 <chessguy>  @src is supposed to be conceptual definitions
21:07:55 <wli> repeat x = let xs = x : xs in xs = iterate (x:) [] = x : repeat x = cycle [x] etc.?
21:08:37 <int-e> iterate (x:) [] is something different
21:09:03 <int-e> fix (x:)
21:09:14 <wli> woops
21:09:40 <chessguy> @help src
21:09:40 <lambdabot> src <id>. Display the implementation of a standard function
21:13:19 <koninkje_away> chessguy: why would we want to use "repeat x = x : repeat x"? I much prefer constant space for those sorts of lists
21:13:45 <chessguy> koninkje_away: @src isn't about what to use
21:14:01 <chessguy> it's about a conceptual definition for showing off
21:14:08 <ddarius> chessguy: The @src definition is the Report definition.
21:14:14 <chessguy> err
21:14:15 <chessguy> really?
21:14:18 <ddarius> Yes.
21:14:19 <koninkje> I'd think it's for people who want to know how the function is written
21:14:35 <chessguy> @src sequence
21:14:35 <lambdabot> sequence []     = return []
21:14:35 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:14:35 <lambdabot> --OR
21:14:35 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:14:45 <chessguy> the report actually says it should be either of these?
21:14:46 <koninkje> i.e. the fact that it's constant space is an important learning message for @src users
21:15:17 <ddarius> chessguy: No, the Report allows any equivalent definition and repeat x = x:repeat xs is equivalent.
21:15:38 <ddarius> But I agree with koninkje, @src should show how code -should- be written within reason.
21:15:49 <chessguy> bah
21:15:51 <koninkje> ddarius: it's only denotationally equivalent, not operationally
21:16:05 <ddarius> koninkje: It may be operationally equivalent too.
21:16:08 <koninkje> ...and there _are_ folks who care about the operational semantics
21:16:08 <kerlo> I disagree. GHC should be extended to make --OR meaningful.
21:16:27 <dolio> It already is.
21:16:30 <dolio> It's a comment.
21:16:39 <kerlo> That makes it not meaningful. :-P
21:16:41 <koninkje> ddarius: if and only if the compiler is smart enough to optimize it into the lazy loop
21:16:42 <ddarius> koninkje: I agree that in practice understanding why it's written that way and what it leads to is important, but the Report's definition does not preclude the repeat x = x:repeat xs definition.
21:16:54 <kerlo> @src (^)
21:16:54 <lambdabot> x ^ 0            =  1
21:16:54 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
21:16:54 <lambdabot>   where f _ 0 y = y
21:16:54 <lambdabot>         f x n y = g x n
21:16:54 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
21:16:54 <koninkje> that may be.
21:16:56 <lambdabot>                       | otherwise = f x (n-1) (x*y)
21:16:58 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
21:17:04 <kerlo> @src (^^)
21:17:04 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
21:17:06 <ddarius> koninkje: No, call-by-name is a perfectly legitimate strategy to implement Haskell as far as the Report is concerned.
21:17:26 <ddarius> Under call-by-name semantics, those two definitions are operationally identical.
21:17:27 <kerlo> Huh.
21:18:19 <kerlo> I expect (**) to be not defined.
21:18:21 <kerlo> @src (**)
21:18:22 <lambdabot> Source not found.
21:18:38 <dolio> @src Double (**)
21:18:38 <lambdabot> Source not found.
21:19:05 <koninkje> It's been a while since I've read the Report, but [[ repeat x = x:repeat x ]] /= [[ repeat x = let xs=x:xs in xs ]] operationally
21:19:22 <dolio> call-by-name doesn't do any sharing.
21:19:32 <ddarius> koninkje: Not in call-by-need semantics, but the Report doesn't require call-by-need semantics.
21:19:36 <koninkje> call-by-name is denotational, not operational
21:19:51 <ddarius> koninkje: The rewriting semantics is an operational semantics and perfectly legitimate.
21:20:16 <koninkje> call-by-name makes no provisions for resources and sharing, at least not with Haskell
21:20:41 <ddarius> Call-by-name is also not a denotational semantics, it's an evaluation order.
21:21:06 <koninkje> "legitimate" to whom? It's not how GHC works, hence it's misleading to those who care about memory usage in GHC
21:21:07 <ddarius> The denotational idea would be non-strictness which is all the Report requires.
21:21:25 <ddarius> koninkje: Who said anything about GHC?
21:21:59 <ddarius> I said originally it "may" be operationally equivalent and I already agreed with you that understanding the difference it makes -in practice- is important.
21:22:02 <koninkje> I did. Though I'm sure the other extant Haskell compilers have the same exact issues
21:23:10 <ddarius> You've only said "GHC" once this whole time and you've suggested that the Report required some kind of operational distinction between the two definitions.
21:23:16 <koninkje> Personally I think it would be nice to have a theory which captures those "in practice" bits as part of the semantics. Any semantics which neglects them is, IMO, incomplete
21:23:57 <ddarius> koninkje: In practice, you can write a call-by-name implementation of Haskell.  And in practice there -are- implementations that probably would not follow any prescribed operational semantics.
21:24:02 <koninkje> I did not suggest the Report required a distinction, I suggested that actual implementations of the Report (e.g. GHC) do
21:25:27 <koninkje> I'm pretty sure that the report would have that xs=x:xs must be circular whereas xs=x:repeat x may not be
21:26:35 <koninkje> We could make a semantics where that's not so, but it seems not to be the one from my memory of the Report.
21:26:45 <koninkje> it's been a while since I've read it, admittedly
21:26:56 <ddarius> koninkje: Again, the Report says -nothing- about sharing.
21:27:19 <ddarius> All it says about evaluation order is that it is "non-strict".
21:28:28 <ddarius> Heck, the Report doesn't even require tail call optimization.
21:31:12 <shapr> There once was a monad from Nantucket,
21:32:11 <Ralith> Its data was all in a bitbucket
21:32:20 <shapr> haha
21:39:16 <Heffalump> yet the report does require that newtype has no overhead
21:39:32 <koninkje> ...and the monomorphism restriction
21:43:51 <ddarius> The former has (denotationally) semantic implication and the latter is a restriction that implementation couldn't then apply, but yeah.
21:46:57 <ddarius> Heffalump: Actually the Report suggests that newtypes have no overhead.  "These coercions may be implemented without execution time overhead; newtype does not change the underlying representation of an object."
21:47:32 <ddarius> Admittedly, the latter part of the sentence is mildly weird as there is no way to know the "underlying representation"
21:50:01 <sjanssen> ddarius: it is also rather uncharacteristic of the report to be so specific about implementation detail
21:50:32 <sjanssen> (I guess this is what Heffalump was getting at)
21:50:33 <ddarius> Indeed, it goes on to talk about "indirections" and how newtypes don't have an "extra level of indirection"
21:51:49 <sjanssen> I do think it is good that the report explains the benefit of the semantics of newtype
21:52:37 <ddarius> sjanssen: I think the detailed implementational description was there to explain why newtype was there at all.
21:52:51 <sjanssen> ddarius: yes, I think you're right
21:53:09 <sjanssen> the language should probably be changed from "implementations should" to "implementations may"
22:03:51 <ozy`> I wonder what filesystems are best described as "whimsical"
22:05:26 <djwonk> I'm about five chapters into the R.W. Haskell book. I would like to start figuring out how to translate / rewrite a simple, modular program from Ruby into Haskell as an exercise.
22:05:46 <djwonk> I'm stumbling a bit on how to rethink an object oriented program into Haskell.
22:05:58 <djwonk> Any recommendations on where to start reading to get a sense for this?
22:06:21 <djwonk> (I'm working on the dining philosophers problem)
22:06:39 <ozy`> (ah, a classic)
22:07:06 <djwonk> it is great fun! i'm doing a discrete time simulation, nothing fancy with distribution or concurrency yet
22:07:39 <djwonk> my ruby version is a great starting point, just struggling a bit with how it should look in Haskell
22:09:12 <ozy`> um well I guess you could start by declaring either a data type or a module for each class you used in the ruby version
22:09:49 <ozy`> with the methods becoming regular functions (write them in infix notation if that helps you translate it)
22:09:56 <ozy`> this won't actually work
22:09:57 <ozy`> but
22:10:07 <ozy`> it's an okay first step, I suppose
22:11:42 <djwonk> ozy`: ok, i'm starting at the very top level.  there are about 5 things I want to do from the "api" point of view 1. create a table of philosophers 2. advance N time steps 3. view a snapshot at the current time 4. summmarize the simulation up to the current point 5. compare several runs in a tabular format
22:12:02 <djwonk> is this a reasonable approach (top-down)?
22:12:15 <ozy`> Â¯\O_o/Â¯
22:12:17 <wli> Yeah.
22:12:31 <ozy`> it should work, sure
22:13:38 <djwonk> ozy` wli ok, nobody hold their breath.  this is going to be interesting :)
22:13:46 <Eridius> I have a very weird issue. I have the file http://gist.github.com/62511 but running it sucks up RAM and hangs forever. In fact, it hangs if n (line 33) is >= 2. If I set n == 1 it runs just fine
22:13:53 <Eridius> I don't know if this is an issue with monte-carlo or with my code
22:13:57 <ozy`> consider that instead of having "special" functionality to snapshot the current state of the simulation, you'd just carry the entire state around as a function parameter or two
22:14:14 <ozy`> and your helper function would just return when it felt like it
22:14:18 <ozy`> or something
22:14:32 * ozy` is too tired to be coherent
22:14:41 <djwonk> ozy`: I agree totally. I just want to make a helper function to display that state when it is asked for.
22:14:45 <sjanssen> Eridius: does it continue eating more RAM, or is the RAM use constant after a certain point?
22:15:05 <Eridius> sjanssen: not sure. When I first ran it in ghci it sucked up 2.2GB and then my machine entered swap hell
22:15:08 <wli> He can always use MonadRWST or some such.
22:15:26 <Eridius> if I compile and run the example with n == 2, it jumps to 762MB, but I think it might stop there. I've never gotten a result from it
22:15:34 <rwbarton> @hoogle toDouble
22:15:35 <lambdabot> No results found
22:15:42 <rwbarton> oops never mind :)
22:15:53 <Eridius> nope, the RAM grows
22:15:54 <rwbarton> fromIntegral would be more idiomatic
22:16:07 <djwonk> ozy`: out of curiosity, are there certain problems that you still prefer to think about in OO terms?
22:16:20 <djwonk> or do you prefer largely to do things in functional style?
22:16:24 <Eridius> rwbarton: I copied that bit out of a monte-carlo sample
22:16:42 <sjanssen> Eridius: "turns <- (sequence.repeat) runTurn" -- most likely your problem
22:16:49 <ozy`> djwonk: functional style and OO style are totally different places in my brain, dude
22:16:52 <rwbarton> Eridius: where is Control.Monad.MC from?
22:17:03 * wli does C and asm (for numerous architectures), not OOP.
22:17:14 <Eridius> sjanssen: I tried running just that bit in ghci and it worked fine
22:17:18 <Eridius> rwbarton: monte-carlo on cabal
22:17:19 <sjanssen> Eridius: unless MC is very lazy (it probably isn't) that will never return
22:17:36 <Axman6> me dreams in haskell now
22:17:39 <Eridius> sjanssen: running `take 10 $ (sequence.repeat) runTurn` worked just fine
22:17:52 <sjanssen> hmm
22:18:01 <Eridius> the dev version of monte-carlo has a nice repeatMC function which gives an infinite list for me, but that's not in the published 0.2
22:18:39 <rwbarton> take 10 $ (sequence . repeat) runTurn shouldn't even type check, do you mean fmap (take 10) $ (sequence . repeat) runTurn ?
22:18:58 <Eridius> rwbarton: err, I liftM'd the take 10
22:19:12 <Eridius> liftM (take 10) $ (sequence.repeat) runTurn
22:19:13 <rwbarton> ok
22:19:48 <rwbarton> sjanssen: looks like MC is the lazy State monad on some type RNG
22:20:01 <rwbarton> I don't understand how that can work though
22:20:13 <sjanssen> I think that should work with lazy state
22:20:19 <Eridius> it does use its own RNG type
22:20:26 <wli> Mersenne twister?
22:20:36 <Eridius> mt19937 is the Mersenne Twister function
22:20:51 <Eridius> mt19937 :: GHC.Word.Word64 -> RNG
22:20:55 <Eridius> where RNG is its own custom type
22:20:59 <djwonk> Axman6: dreaming in code, that's fun.  as long as it compiles.
22:21:21 <Axman6> don't even get me started >_<
22:21:28 <rwbarton> sjanssen: how can it? imagine the RNG is just spitting out consecutive numbers, then what number do I get after liftM (take 10) $ (sequence.repeat) runTurn
22:21:37 <Axman6> if i've been working on something all day, my brain can't stop thinking about it
22:21:58 <sjanssen> rwbarton: ah!
22:22:09 <sjanssen> rwbarton: in isolation, it is fine
22:22:27 <rwbarton> oh right
22:22:31 <sjanssen> rwbarton: but when you have sequence (repeat x) >> sequence (repeat x) -- stuff breaks
22:22:32 <rwbarton> :)
22:22:41 <rwbarton> damn laziness hiding broken programs
22:22:43 <sjanssen> Eridius: (sequence . repeat) is your problem
22:22:49 <Eridius> I'm not following..
22:23:12 <sjanssen> hmm, how to articulate this
22:23:16 <pumpkin_> who's that bulat person?
22:23:32 <sjanssen> Eridius: if you want to observe it, try running "runGame >> runGame"
22:23:48 <sjanssen> pumpkin_: an infrequent poster on the mailing list
22:23:56 <sjanssen> he likes to whine about Haskell being slow
22:23:59 <rwbarton> Eridius: imagine the action runTurn just spits out consecutive numbers 0, 1, 2, ...
22:24:03 <pumpkin_> dammit, why doesn't the mailing list set reply-to to the list
22:24:08 <pumpkin_> I just replied to him personally and that's awkward
22:24:13 <Eridius> wow, `runGame >> runGame` does break
22:24:38 <rwbarton> Eridius: if you do a (sequence . repeat) runTurn, what will the state (next number) be after that?
22:24:48 <Eridius> to put it in laymans terms, the second one never runs because the first still needs to evaluate the entire lazy list to get at the resulting state?
22:25:00 <rwbarton> note that it doesn't matter how much of the list you actually consume
22:25:10 <rwbarton> yes, precisely
22:25:19 <porges> @instances-importing Control.Category Category
22:25:20 <lambdabot> Couldn't find class `Category'. Try @instances-importing
22:25:24 <Eridius> the goal was to make it stop running turns when it found the result it wanted
22:25:26 <rwbarton> the tricky part is that it works for n == 1 because you don't need the resulting state at all in that case
22:25:59 <Eridius> interesting. Thank you so much for your help
22:26:59 <Eridius> the repeatMC function in the source for monte-carlo (which gives the infinite list) uses unsafeInterleaveIO. I guess this is why
22:27:37 <rwbarton> right, using unsafeInterleaveIO, you can make the actions performed depend on how much of the list is consumed by elemIndex
22:28:13 <sjanssen> Eridius: eww, that's a bit ugly
22:28:22 <sjanssen> I wonder why they don't just split the RNG?
22:28:27 <Eridius> I'm still not sure how it works, because I couldn't figure out where the IO type was introduced in the source there, maybe it's part of the MC monad
22:28:47 <Eridius> sjanssen: monte-carlo uses its own custom RNG type. I'm not sure how it's implemented, but it doesn't have splitting
22:29:02 <rwbarton> There wasn't any IO in the definition of MC in the version I looked at.
22:29:17 <Eridius> from the description: Importantly, they only keep one copy of the generator state, and so are much more efficient than MonadRandom
22:29:30 <wli> MonteCarloT IO?
22:31:26 <rwbarton> It's kind of cute that split is just what you need to write "unsafeInterleaveMC"
22:31:41 <sjanssen> rwbarton: and it doesn't even have to be unsafe!
22:31:47 <rwbarton> right
22:32:21 <sjanssen> this is something I've pondered before, but with Applicative
22:33:19 <rwbarton> ah, interesting
22:33:43 <rwbarton> reminds me somehow of the Applicative instance which is basically f <*> x = x `par` f x
22:33:54 <sjanssen> (R f) <*> (R x) = R $ \g -> let (g', g'') = split g in f g' (x g'')
22:34:07 <Eridius> sweet, I turned runGame into a recursive function and now it actually runs
22:34:22 <ski_> (rwbarton : `Applicative' instance of what ?)
22:34:39 <rwbarton> ski_: (newtype Par x = Par x)
22:34:46 <sjanssen> rwbarton: yes, one could easily combine the two ideas
22:35:10 <rwbarton> ski_: (with Par liberally inserted into that definition)
22:36:00 <sjanssen> rwbarton: I think conal has something like this in his FRP stuff
22:36:09 <sjanssen> except with forkIO rather than par
22:36:58 <rwbarton> now we just need OverloadedApplication and we get automatic parallelization! :)
23:11:50 <sm> what would be the most robust cross-platform way of opening a browser to some url ?
23:13:07 <score> sm: dunno, maybe something like run-mailcap
23:13:22 <sm> run-mailcap ? on windows ?
23:13:58 <score> sm: heh, n/m
23:14:15 <sm> I guess this would make a nice library for hackage..it's not something you want to reinvent
23:14:36 <sm> maybe check the platform and try a bunch of things depending
23:14:48 <score> sm: sounds like it'll end up being something awful like that
23:14:55 <sm> yeah
23:15:14 <sm> for mac it seems easy: open url
23:15:32 <score> sm: they have a program called 'open' or what?
23:15:37 <sm> yes
23:16:00 <Cheshire> sm: solution for other systems: implement the program "open" ?
23:18:25 <score> sm: http://portland.freedesktop.org/xdg-utils-1.0/  think that might be a cross-distro tool to consider
23:18:41 <score> sm: xdg-open, that is
23:19:49 <sm> hmm, maybe one could ship that with one's product
23:20:49 <sm> when one is deploying to unix users
23:43:50 <Cheshire> > iterate reverse "(}{)"
23:43:51 <lambdabot>   ["(}{)","){}(","(}{)","){}(","(}{)","){}(","(}{)","){}(","(}{)","){}(","(}{...
23:48:26 <cizra> > concat . iterate $ reverse "(}{)"
23:48:27 <lambdabot>   Couldn't match expected type `[[a]]'
23:48:42 <Cheshire> > concat (iterate reverse "(}{)")
23:48:44 <lambdabot>   "(}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}...
23:49:01 <Ralith> > concat $ iterate reverse "(}{)"
23:49:02 <lambdabot>   "(}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}{)){}((}...
23:49:09 <cizra> hm
23:49:31 <Ralith> $ is for replacing parenthesis
23:49:34 <lunabot>  luna: Not in scope: `is'
23:49:44 <Cheshire> parenthesis don't need replaced
23:49:46 <Ralith> foo $ bar = foo (bar)
23:49:55 <Ralith> Cheshire: I mean, that's how it works :P
23:50:57 <SubStack> balancing parens is annoying
23:51:14 <SubStack> also hard to read
23:51:14 <Ralith> indeed.
23:51:39 <Ralith> parens are great most of the time, but sometimes $ does wonders for readability
23:53:24 <Cheshire> add paren matching support to your editor
23:53:40 <Ralith> that doesn't help much
23:54:07 <Ralith> makes it marginally easier for you to work with, but the code is still ultimately less readable than it could be
23:54:36 <Cheshire> I usually write  f . g . h  btw, not  f . g . h $ x
23:54:46 <Cheshire> so I find ($) ugly
23:55:22 <Ralith> that has nothing to do with parenthesis, and does not cover the full scope of useful cases of $
23:55:33 <Ralith> such as the one I demo'd just a few minutes ago
23:55:34 <Cheshire> yes it does
23:55:49 <Cheshire> (f . g . h) x  replaced with  f . g . h $ x
23:55:57 <RayNbow> > succ . (*3) . pred `id` 4
23:55:58 <lambdabot>       precedence parsing error
23:55:58 <lambdabot>          cannot mix `(.)' [infixr 9] and `id' ...
23:56:04 <RayNbow> ah damn
23:56:35 <RayNbow> if only `id` had a lower precedence :p
23:57:11 <Ralith> Cheshire: by that logic, anything could be said to be relevant to parenthesis, because you can use them when unneeded just about anywhere :P
23:58:02 <Cheshire> Ralith, every time you use ($) to omit a paren, it is preceeded by a sequence of zero of more (.)'d functions
23:59:11 * tonyIII_ wonders why keep getting "Exception: stack overflow" when using randomIO
23:59:39 <Ralith> Cheshire: every time you do anything at all, it is preceded by a sequence of zero or more (.)'d functions.
23:59:46 <Ralith> this includes eating breakfast.
23:59:58 <Cheshire> you are talking nonsense
