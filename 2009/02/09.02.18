00:00:38 <ski_> things like `modify (\st -> st {knownTargets = IS.union targets $ knownTargets st})' might look nicer if you define
00:01:11 <ski_>   modknownTargets f st = st {knownTargets = f (knownTargets st)}
00:01:15 <ski_> then you get
00:02:00 <ski_>   modify . modKnownTargets $ IS.union targets
00:02:31 * wli can't seem to get a grip on arrows.
00:02:50 <ski_> (you might do a full lens / functional reference here)
00:03:11 <ski_> what about them can't you seem you grip ?
00:03:30 <wli> ski: Almost everything, really.
00:03:54 <ski_> the above use of `***' can be thought of as just a useful function combinator
00:04:13 <ski_>   (***) :: (a0 -> a1) -> (b0 -> b1) -> ((a0,a1) -> (b0,b1))
00:04:45 <wli> Yeah, I seem to have gotten to where I can use (***), (|||), first, second, left, and right as convenience functions on (,) and Either
00:04:47 <ski_> given a modifier function on the left parts, and one on the right parts, we get a combined modifier on pairs
00:05:45 <ski_>   (&&&) :: (x -> a) -> (x -> b) -> (x -> (a,b))
00:06:12 <newsham> if you use arrow do-notation you can avoid having to manually plumb your data around using things like &&& and ***
00:06:14 <ski_> is instead used when you want to pass in a single input, and both functions should get it, but you want both the outputs in a pair
00:06:22 <ski_> indeed
00:07:02 <tehgeekmeister> oh, didn't notice you were still providing tips, ski_
00:07:11 <tehgeekmeister> was cleaning up
00:07:15 <tehgeekmeister> http://tinyurl.com/cl3mzx
00:07:20 <tehgeekmeister> there's a problem i'm having now
00:07:21 <tehgeekmeister> *catches up
00:07:29 <ski_> oh, you didn't annotate the moonpaste ?
00:08:21 <ski_> .. yes you did
00:08:35 <ski_> (it was just hidden behind the tinyurl)
00:08:52 <tehgeekmeister> i did, but i tinyurled to the annotation instead.  =P
00:09:11 <wli> Oh, and (+++)
00:09:18 <wli> (+++) more than (|||)
00:09:54 <ski_> (+++) : (***) :: (|||) : (&&&)
00:10:25 <ski_>   (+++) :: (a0 -> a1) -> (b0 -> b1) -> (Either a0 a1 -> Either b0 b1)
00:10:54 <ski_> used just like `(***)' but will apply the modifier of the actually passed case of the `Either'
00:11:24 <ski_> `(|||)' is used for mapping the two cases of an `Either' into a single result type
00:11:46 <ski_>   (|||) :: (a -> y) -> (b -> y) -> (Either a b -> y)
00:11:48 <newsham> or-elimination
00:12:09 <ski_> *nod*
00:12:25 <newsham> if you give me an (a or b) and a way to map (a -> y) and a way to map (b -> y) I can give you a y
00:12:28 <ski_> @type either
00:12:29 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:12:42 <ski_> @src (->) (|||)
00:12:43 <lambdabot> Source not found. Just try something else.
00:12:49 <quicksilver> indeed, (****) is the generalised form of and-elimination.
00:12:59 <wli> map (head ||| chr) [Left "foo", Right $ ord 'u']
00:13:19 <wli> I don't know what (****) is, only (***)
00:13:30 <quicksilver> that was a typo ;)
00:14:05 <Deewiant> @check \x -> ((:[]) ||| take 1) x == either (:[]) (take 1) x
00:14:06 <lambdabot>   "OK, passed 500 tests."
00:14:07 <wli> I'd not mind something that could give me something like a Monad instance for Set
00:14:17 <ski_> quicksilver : didn't you mean to say that `(&&&)' is the generalized version of and-introduction ?
00:15:08 <ski_> @check \x -> ((:[]) ||| take 1) x == either (:[]) (take 1) (x :: [Int])
00:15:09 <lambdabot>   Couldn't match expected type `[Int]'
00:15:11 <quicksilver> perhaps.
00:15:17 <ski_> er
00:15:23 <quicksilver> my logic is embarrassingly rusty.
00:15:28 <banisterfiend> man, haskell looks like perl
00:15:34 <ski_> @check \x -> ((:[]) ||| take 1) x == either (:[]) (take 1) (x :: Either Int [Int])
00:15:35 <lambdabot>   "OK, passed 500 tests."
00:16:35 <Deewiant> @check \x -> ((:[]) +++ take 1) x == either (Left . (:[])) (Right . take 1) (x :: Either Int [Int])
00:16:36 <lambdabot>   "OK, passed 500 tests."
00:17:55 <ski_> @check id ||| id
00:17:57 <lambdabot>   "Arguments exhausted after 0 tests."
00:18:08 <tehgeekmeister> hmm
00:18:23 <leadnose_> :t (|||)
00:18:24 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
00:18:30 <tehgeekmeister> can i put State inside of Writer?
00:18:49 <tehgeekmeister> or would it go the other way?
00:19:07 <tehgeekmeister> i want to end up with a list of all the states at every step
00:19:18 <tehgeekmeister> so i think that's state inside writer
00:19:27 <ski_> @check (id ||| id :: Either Bool Bool -> Bool)
00:19:28 <lambdabot>   "Falsifiable, after 0 tests:\nLeft False\n"
00:20:04 <ski_> @unmtl StateT s (Writer w) a
00:20:04 <lambdabot> s -> (a, s, w)
00:20:15 <ski_> @unmtl WriterT w (State s) a
00:20:15 <lambdabot> s -> (a, w, s)
00:20:32 <ski_> i don't think it matters much
00:20:52 <wli> class ConstrainedFunctor f t t' and class ConstrainedMonad m t t' seem to fly.
00:21:07 * ski_ wonders since when `unmtl' flattens tuples
00:21:11 <wli> MPTC FTW
00:21:44 <ski_> wli : for  (t -> t') -> (f t -> f t')  ?
00:21:59 <wli> class ConstrainedFunctor f t t' where
00:22:00 <wli>         fmapC :: (t -> t') -> f t -> f t'
00:22:08 <ski_> *nod*
00:22:10 <wli> instance (Ord t, Ord t') => ConstrainedFunctor Set t t' where
00:22:10 <wli>         fmapC f xs = Set.map f xs
00:22:39 <ski_> (i think that's morally wrong .. but, you can try if you want)
00:22:50 <wli> What's so morally wrong about it?
00:22:54 <cizra> Hey, does Haskell have variadic functions?
00:23:09 <wli> cizra: google for Printf.hs
00:23:35 <cizra> wli: Were you looking for "printf.net"? hehe
00:23:37 <Deewiant> > (printf "%d" 3, printf "%d %d" 3 4) :: (String, String)
00:23:38 <lambdabot>   ("3","3 4")
00:23:57 <ski_> wli : there is no guarrantee that instances are even polymorphic in the two latter type parameters there
00:24:05 <quicksilver> cizra: No, it doesn't, but it has typeclass overloading which can give you something which behaves like them.
00:24:11 <tehgeekmeister> ski_: did you understand that error i hpasted?
00:24:18 <ski_> um
00:24:22 <ski_> i didn't look yet
00:24:25 <ski_> i'll do now
00:24:25 <cizra> quicksilver: OK, hm. Well. Thanks.
00:24:30 <tehgeekmeister> thanks
00:24:41 <tehgeekmeister> i can't figure this one out on my own and i'm stuck at this point
00:25:14 <wli> ski: I don't see why that's a problem.
00:27:20 <ski_> it seems weird to me to define a class, and require that every instance *ought* to keep some parameters polymorphic
00:27:58 <ski_> (i think probably there's more exact ways to pinpoint what i'm after .. but i don't know them)
00:28:11 <wli> I don't see why they need to be kept polymorphic, even.
00:28:47 <ski_> how will you guarantee the functor laws, otherwise
00:28:50 <ski_> ?
00:29:15 <ski_> for `Set' we want
00:29:17 <wli> Which ones sound like a problem? I presume proof burdens of some sort.
00:29:29 <dmwit> Q: How do you guarantee the monad laws?
00:29:32 <dmwit> A: You don't.
00:30:49 <ski_>   forall a :: *. Ord a => fmapSet (id :: a -> a) = id :: Set a -> Set a
00:31:44 <ski_>   forall a b c :: *. (Ord a,Ord b,Ord c) => forall (f :: a -> b) (g :: b -> c). fmapSet (g . f) = fmapSet g . fmapSet f
00:32:45 <ski_> to even state these laws, i must be able to instantiate your  t  and  t'  to any types which are in `Ord'
00:33:08 <ski_> the above instance allows that .. but i want the class definition to not allow instance which don't allow this
00:34:44 <wli> I just say that you shouldn't screw it up.
00:36:39 <NameAlreadyInUse> is getLine always the same value, no matter where i put it?
00:36:56 <quicksilver> yes
00:37:00 <ski_> yes `getLine' is always the same action
00:37:01 <quicksilver> getLine is an IO action
00:37:09 <quicksilver> it's one particular constant IO action
00:37:22 <quicksilver> the result of executing it in IO is different each time though, of course.
00:37:29 <yitz> @type getLine
00:37:30 <lambdabot> IO String
00:37:31 <quicksilver> (but that is true of many/most IO actions, in general)
00:37:53 <NameAlreadyInUse> great
00:37:55 <NameAlreadyInUse> i understand now
00:38:23 <yitz> NameAlreadyInUse: I like your nick
00:39:14 <ski_> tehgeekmeister : i'm not sure what type you want `makeReader' to have ..
00:39:22 <NameAlreadyInUse> yitz: thanks (:
00:39:48 <tehgeekmeister> ski_: ReaderState is the type of the state, the value i never set
00:41:00 <wli> Things whine about overlapping instances with instance Functor f => ConstrainedFunctor f t t' where fmapC = fmap
00:41:04 <ski_> the error message looks like forgotten argument somewhere, or vice versa
00:41:09 <ski_> but i'm not sure where
00:41:16 <tehgeekmeister> yeah, that's what i thot
00:41:18 <tehgeekmeister> but i can't find one
00:41:41 <ski_> so, again, what should be two type of `makeReader' ?
00:41:47 <tehgeekmeister> that's why i indented that line, to look for anything missing
00:41:50 <ski_> probably something similar to `makeMap' ?
00:42:09 <tehgeekmeister> yeah, analogous to that
00:42:18 <ski_> can you state the type ?
00:42:44 <hackage> Uploaded to hackage: AVar 0.0.2
00:42:45 <tehgeekmeister> *tries
00:44:07 * wli can't seem to smoke out how to do monad transformers with ConstrainedMonad
00:44:42 * ski_ doubts it's possible .. at least sensibly
00:45:40 * wli isn't too worried about sensibility.
00:46:14 <tehgeekmeister> makeReader :: Ord a, Fractional a, MonadState (ReaderState a) m => [(Int,[String])] -> m ()
00:46:16 <tehgeekmeister> i thinkt hat's it
00:46:19 <tehgeekmeister> *that's
00:46:25 <ski_> `(\items -> map (\a -> (a,fromJust $ M.lookup a ordinalFrequencies)) $ S.toList items)' can be written `(map (\a -> (a,fromJust $ M.lookup a ordinalFrequencies)) . S.toList)'
00:46:30 <ski_> which could be written
00:47:08 <tehgeekmeister> oh yeah, use a section, that's a good way of doing that
00:47:49 <ski_>   (map . graph (fromJust . (`M.lookup` ordinalFrequencies)) . S.toList)
00:47:52 <ski_> where
00:47:58 <ski_>   graph f = id &&& f
00:48:34 <ski_> (you can expand the `graph' call, if you think it unintelligble)
00:48:41 <wli> uh-oh, I'd better get to sleep
00:49:06 * ski_ looks at the type signature above
00:49:22 <tehgeekmeister> man i need to learn about arrows
00:49:33 <wli> Join the club.
00:49:37 <ski_> this isn't really serious arrow use
00:49:50 <ski_> just function combinators, here
00:49:55 <tehgeekmeister> it's a lot more than no arrow use
00:50:00 <tehgeekmeister> which is how much i'm used to
00:50:05 <ski_> in
00:50:08 <wli> The thing is that I have no idea what serious arrow use is.
00:50:10 <ski_> @type (&&&)
00:50:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:50:32 <ski_> remove the `Arrow a =>' part, and replace each `a foo bar' with `foo -> bar'
00:50:42 <ski_> wli : other arrows than `(->)'
00:51:05 <tehgeekmeister> oh!
00:51:07 <tehgeekmeister> it's sensible then.
00:51:25 <ski_> (.. it would be nice if the type signatures used the
00:51:37 <wli> Well, I have that idea floating around somewhere. The trouble is that I don't understand any of the examples.
00:52:09 <ski_>   (&&&) :: forall ((~>) :: * -> * -> *) a b b'. (Arrow (~>)) => (a ~> b) -> (a ~> b') -> (a ~> (b, b'))
00:52:14 <ski_>  syntax, instead
00:52:15 <ski_> )
00:53:38 <ski_> (however, whether it's better or not to use `&&&' (or `graph') in the above code is up to you to decide .. i just showed it can be done)
00:55:51 <ski_> hrm
00:55:58 <opqdonut> did you know that the graph of a continous function X->Y is closed if Y is a hausdorff space?-)
00:56:40 <adrian_> If you had to choose between writing a bachelor's thesis about "Arrows and Computation" or about "Origami Programming" which one would you choose?
00:56:49 <opqdonut> the latter
00:57:00 <adrian_> why
00:57:11 <nanothief> because origami is cool?
00:57:21 <opqdonut> a bachelor's should be fun and light
00:57:54 <opqdonut> imo one can do an excellent bachelor's on origami programming but doing an excellent one on arrows is quite a bit harder
00:58:02 <quicksilver> opqdonut: once upon a time, I did, yes ;)
00:58:05 <tehgeekmeister> ski_:  so graph  is equivalent to (\f (a,b) -> (a,f b))
00:58:06 <ski_> the `map (..blah..) $ M.toList $ M.map (..bleh..) (..fnord..)' can be rewritten into
00:58:15 <ski_> tehgeekmeister : yes
00:58:19 <opqdonut> quicksilver: :)
00:58:43 <ski_>   M.toList $ M.map ((..blah..) . (..bleh..)) (..fnord..)
00:59:13 <ski_> tehgeekmeister : that applies to `main'
00:59:17 <adrian_> opqdonut: Indeed folding is much easier
00:59:49 <jpcooper> hello
00:59:57 <ski_> @djinn (a -> b) -> (a -> (a,b))
00:59:57 <lambdabot> f a b = (b, a b)
01:00:14 <blackh> jpcooper: Hello!
01:00:29 <opqdonut> adrian_: well I don't know how extensive bachelors' theses tend to be where you study but here they're usually pretty small
01:00:36 <jpcooper> could anyone tell me how to get haskell-ghci-load-file in haskell-mode to change to the buffer's directory from which it is called with C-c C-l instead of CDing to ~/.cabal?
01:01:13 <oklopol> i think it was a joke
01:01:30 <oklopol> (in any case it was pretty funny)
01:01:53 <opqdonut> oklopol: ?
01:02:24 <oklopol> actually i don't know what origami programming is, so might've misunderstood.
01:02:42 <ski_> (opqdonut : no, didn't know that ..)
01:03:00 <adrian_> opqdonut: I don't know really. But I tend to believe that they're nothing special. Yet I strive to impress my professors, hoping that they'll offer me to work for them once I done with studying.
01:03:15 <jpcooper> adrian_, I've got two years to go until then
01:03:38 <opqdonut> adrian_: indeed, as i said it's easier to make an excellent bachelor's on origami than on "arrows and computing"
01:03:41 <jpcooper> I hope to do something on arbitrage betting with statistical inference or ANNs or something. At least there will be a profit to me
01:03:46 <opqdonut> you shouldn't aim too high
01:04:30 <ski_> (.. isn't a thesis supposed to contribute to the knowledge known to mankind ?)
01:04:56 <adrian_> ski_:  afaik a bachelor's thesis is very shallow on original research.
01:05:50 <jpcooper> anyone?
01:06:29 <blackh> jpcooper: Is that an emacs question?
01:06:35 <jpcooper> yes
01:06:46 <jpcooper> pertaining to haskell-mode, which I guess a lot of people here use
01:06:50 <tehgeekmeister> ski_: thanks
01:06:58 <blackh> jpcooper: You know what that means? That means I know more than nothing about emacs!
01:07:44 <ski_> tehgeekmeister : the type error is eliding me, though .. i'm starting to get a bit sleepy
01:08:19 <tehgeekmeister> ski_: i haven't figured it out yet either, but the cleaner the code gets the easier it'll be to see, so progess has certainly been made.
01:08:27 <ski_> tehgeekmeister : i suggest you annotate every (or almost every) top-level function with its intended type signature, at least when hunting down the error
01:08:30 <jpcooper> eliding?
01:08:43 <ski_> s/is eliding me/elides me/
01:08:55 <ski_> (i said i'm sleepy)
01:09:18 <jpcooper> I don't know that "elide" is used correctly in that context
01:09:22 <blackh> ski_: elude?
01:09:42 <jpcooper> yes, that would be suitable
01:10:02 <ski_> blackh : that's the word, ty
01:15:19 <Itkovian> Is there any way to work around the timer_create issue, other than compiling the application on an old system?
01:21:23 <fasta>  #math
01:22:09 <Elly> No, #haskell
01:22:11 <Elly> close though
01:22:49 <tehgeekmeister> okay, i'm passing out at the keyboard now
01:22:50 <tehgeekmeister> time to go to bed
01:22:57 <tehgeekmeister> ski_: thanks for your help
01:23:06 <fasta> Elly: I was just advertising the channel with subliminal messaging.
01:23:16 <Elly> fasta: good work :)
01:24:58 <mmorrow> i need to learn about how instruction sets are encoded asap. what's a nice/most-sane instruction set to read about to this end?
01:25:43 <fasta> mmorrow: how do you mean "encoded"?
01:26:05 <mmorrow> like, as in how  jmp *(%eax)  is encoded in bits
01:26:22 <fasta> mmorrow: that depends on the architecture. Are you reading the JonesForth implementation?
01:26:35 <mmorrow> i'm not, but should i?
01:26:37 <jpcooper> so could anyone tell me how to prevent haskell-mode from changing the directory to ~/.cabal when it loads a file from a different directory?
01:26:49 <Elly> mmorrow: if you want to know that, the canonical place is the Intel manuals
01:26:53 <mmorrow> totally, i'm trying to figure out what arch is the nicest to read about as an example of this
01:26:54 <Elly> which I absolutely recommend you do not read
01:26:58 <ivanm> mmorrow: _you're_ asking people how to do something? I thought you were one of those select few that hung around here in a buddha fashion to help the rest of us mere mortals achieve haskellian enlightenment :s
01:27:04 <Elly> if you want to see a good example, read the MIPS ISA documentation
01:27:07 <jpcooper> mmorrow, try MIPS maybe?
01:27:12 <Elly> yes
01:27:15 <ivanm> (since the high-end abstract category theory discussions now have their own channel, anyway...)
01:27:15 <fasta> mmorrow: I heard good things about MIPS.
01:27:21 <Elly> MIPS has a very nice orthogonal instruction set
01:27:25 <Elly> and it's very easy to compile for
01:27:25 <blackh> mmorrow: The ancient processors are good because they're really simple - 8080 and 6800
01:27:35 <Elly> the 8080 is *NOT* "really simple"
01:27:37 <mmorrow> cool, i think i'm gonna go with MIPS
01:27:40 <jpcooper> blackh, 8080 simple!?
01:27:41 <fasta> mmorrow: but I don't think it really matters, as there are also one instruction set computers.
01:27:44 <mmorrow> yeah, i've heard all things intel are nasty
01:27:50 <mmorrow> ivanm: heh
01:27:53 <Elly> it has a complexity that dwarfs even today's RISC processors
01:27:56 <ivanm> ;-)
01:28:04 <Elly> I mean
01:28:11 <Elly> intel released the original 4004 manuals a while ago
01:28:14 <Elly> for historical reasons
01:28:14 <blackh> It seemed simple at the time. Maybe I was more intelligent then.
01:28:19 <Elly> and those read like some kind of sick joke
01:28:28 <Elly> banked memory, segments, &c.
01:28:58 <mmorrow> thx for the tips all :)
01:29:18 * Elly has way more experience with bit-bashing than with functional programming :P
01:29:31 <jpcooper> mmorrow, I guess in RISC, one has the instruction which has a corresponding code, and all of its arguments such as registers have a corresponding address, and if there's a memory argument, you of course give a hex address that is encoded into binary, and this all gets concatenated
01:29:37 <jpcooper> but I guess you know this
01:30:12 <Elly> if it's RISC, there is not a memory argument :)
01:30:44 <Elly> a Real RISC Machine (tm) has four instruction types: reg/const, reg/reg, reg, and branch
01:30:49 <jpcooper> what if you're copying to memory?
01:30:54 <Elly> where 'load' and 'store' are reg/reg
01:30:57 * mmorrow takes notes
01:31:01 * mmorrow studied math
01:31:08 <jpcooper> surely you need a memory address to copy to memory
01:31:14 <Elly> jpcooper: ah, yes, but it's not written specially
01:31:35 <jpcooper> mmorrow, so the only operations that work on memory in RISC are loading and storing
01:31:38 <Elly> if you want to load location 0 into register 3, you just do: mov 0, r1 ; lw r1, r3
01:31:48 <mmorrow> in particular, i'm trying to figure out a good way to encode for mov/jmp/etc. which regs/mem/imm are being operated on
01:31:50 <jpcooper> every other operation works on registers where data has to be loaded into them before hand
01:31:51 <Elly> where 'lw' dereferences its first register argument into its second register argument
01:31:58 <Elly> mmorrow: definitely look at MIPS and ARM
01:32:04 <mmorrow> cool
01:32:34 <Elly> ARM in particular has a neat trick
01:32:42 <Elly> the first four bits of every instruction are the 'condition code'
01:32:55 <Elly> so it can make conditional execution without any branches
01:33:01 <Elly> (branches are not your friends)
01:33:02 <ivanm> mmorrow: though there is at least one problem with MIPS: ghc hasn't been ported to it yet :s
01:33:13 <ivanm> ;-)
01:33:18 <mmorrow> Elly: interesting, i'll make sure to read about that
01:33:29 <dcoutts> jpcooper: re haskell-mode and the ~/.cabal dir. The solution is to update your haskell-mode to a version without that bug.
01:33:41 <Elly> mmorrow: you could also look at x86 as an example of how not to do it
01:34:00 <mmorrow> ivanm: snap, what runs MIPS anyways if there's no ghc?
01:34:07 <ivanm> heh
01:34:10 <mmorrow> Elly: i can imagine the horror
01:34:14 <Elly> there are some laptops coming out of china with MIPS knockoffs in them
01:34:29 <Elly> mmorrow: to give you a taste: variable-length instructions, from 1 to 15 bytes, some of which take 3 or 4 operands
01:34:42 <jpcooper> dcoutts, thanks. I thought that I had the latest version. Do you know where I _can_ get the latest?
01:34:46 <Elly> instruction prefixes which can be stuck onto any instruction (sort of) to change its meaning
01:34:54 <ivanm> dcoutts: there's no official version that has that fixed as yet, you either have to manually patch the source or get a snapshot of the CVS :s
01:35:05 <jpcooper> I'll check CVS
01:35:05 <Elly> a super-magical byte you can insert called the 'ModR/M' byte which has bits for things like "I know that operand 2 says memory, but really make it an offset register"
01:35:18 <ivanm> jpcooper: there isn't one
01:35:20 <Elly> four privilege levels instead of the normal two, but only two are really supported any more
01:35:24 <Elly> and so on :)
01:35:39 <mmorrow> Elly: wow, it's worse than i imagined :/
01:35:47 <Elly> that is barely scratching the surface
01:35:51 <mmorrow> heh
01:35:55 <Elly> most arches have one memory-protection mechanism
01:36:00 <Elly> x86 has two or three, depending on who you ask
01:36:13 <Elly> there's the old segmentation system, which everyone still has to use but which is effectively disabled
01:36:19 <Elly> there's the new paging system, which everyone actually uses
01:36:40 <Elly> and there's a semi-mystical piece of hardware trickery called System Management Mode which shifts you into an alternate universe in RAM that is not normally addressible
01:36:58 <cizra> Elly: What's their point? Running that old Arcade Volleyball and Crazy Digger on a modern CPU?
01:37:08 <Elly> cizra: backward compatibility is law
01:37:15 <Elly> you can still boot DOS 1.0 on a Core 2
01:37:19 <cizra> *nod*
01:37:30 <Elly> not that you ever would, but you *can*
01:37:57 <cizra> Does that also apply to the MIPS architecture?
01:38:01 <Elly> most chips have only one operating mode, which in x86 parlance is 'flat protected' mode - all memory is linearly addressed
01:38:09 <cizra> Or did they break compatibility? Or did they not evolve at all?
01:38:15 <Elly> cizra: yes, actually; all MIPS revisions are supersets of previous MIPSes
01:38:17 <vorner> but you still talk about the 32 bit ones, the 64bit ones are more fun, because they have 32bit and 64bit modes ;-)
01:38:21 <jpcooper> ivanm, it seems that the CVS version still has the same bug
01:38:21 <Elly> but some old instructions are finally deprecated
01:38:32 <jpcooper> I should go to my lecture and look at this later
01:38:41 <Elly> but anyway
01:38:47 <Elly> most chips have 'flat protected' mode
01:38:49 <ivanm> jpcooper: nope, it's been fixed
01:38:50 <Elly> where memory is linearly addressed
01:38:52 <angerman> I tried to install HDirect (COM interoperability for Haskell) it had -package lang. So I removed those from the Makefile, now it sais it needs IOExt
01:38:55 <Elly> x86 chips have more modes
01:39:10 <ivanm> I know I managed to get the gentoo emacs devs to provide a CVS snapshot with this issue fixed...
01:39:13 <Elly> they have 'segmented protected', where all memory accesses have an implicit or explicit segment base added to them
01:39:19 <ivanm> jpcooper: alternatively, there's a variable you can set to disable this IIRC
01:39:24 <dcoutts> jpcooper: I've really no idea, I don't use emacs. I just know it's an old (frequently reported) bug that has been fixed.
01:39:27 <Elly> 'segmented real', where the segment base is *shifted left by four* and added to the base
01:39:28 <jpcooper> okahy
01:39:29 <ivanm> google for it, there's been enough mailing list messages about it
01:39:36 <Elly> and unreal, long, and flat protected :P
01:39:56 <dcoutts> ivanm: seriously? there's no release with the fix? But that bug has been around for more than a year!
01:40:00 <jpcooper> oh, I didn't copy properly
01:40:03 <angerman> Does anyone know how to get the IOExt? As I read was lang depricated...
01:40:18 <ivanm> dcoutts: I've asked the maintainer, and he doesn't like making releases
01:40:26 <ivanm> he only makes them every 6 months or so OORC
01:40:26 <dcoutts> ivanm: aaarg!
01:40:29 <ivanm> yeah :s
01:40:51 <ivanm> unlike the unofficial haskell lib policy of "hey, this is cool.... I know, I'll make a hackage package!"
01:40:51 <ivanm> ;-)
01:41:13 <jpcooper> ivanm, it works now. Thanks
01:41:45 <ivanm> no worries
01:41:50 * jpcooper is off to learn more about half-range fourier series
01:54:42 --- mode: irc.freenode.net set +o ChanServ
01:55:44 --- mode: irc.freenode.net set +o Cale
01:56:07 <Elly> why hello there
01:58:05 <Python1320> "woohoo"
02:00:19 <temoto> Hello, i'm very newcomer with previous exp in C, Python. It's about classes... they are not what called classes in other languages, right. Like i define class Validable and some data types are Validable if appropriate functions are defined to operate with those types, right?
02:00:53 <kmeyer> type classes aren't the same as classes in, say, Python, sure
02:01:03 <Zao> Classes are more like interfaces or templates.
02:01:29 <Zao> @src Ix
02:01:29 <temoto> Yeah interfaces, great. And what about multiple of them?
02:01:29 <lambdabot> class (Ord a) => Ix a where
02:01:29 <lambdabot>     range           :: (a,a) -> [a]
02:01:31 <lambdabot>     index           :: (a,a) -> a -> Int
02:01:33 <lambdabot>     inRange         :: (a,a) -> a -> Bool
02:01:35 <lambdabot>     rangeSize       :: (a,a) -> Int
02:02:04 <temoto> Is it possible to define type which implements multiple classes?
02:02:21 <Zao> Ix Int and Num Int, say.
02:02:56 <temoto> Zao: sorry, i don't understand "Ix".
02:03:16 <vorner> surely it is. One data type can act as a number, as something convertible to string, as something comparable, etc...
02:03:22 <Zao> Ix is a class for things suitable as Array indexes.
02:04:12 <temoto> Understood, thank you very much.
02:04:21 <Zao> As long as you have the functions in the Ix class implemented for your type, you can use it anywhere that wants generic Ix:es.
02:05:00 <blackh> temoto: Make an instance declaration for each type class you want to implement on a given data type.
02:05:05 <Zao> I only picked Ix as I knew that the lambdabot spam on it would be short :P
02:06:03 <blackh> temoto: If you want your data type to implement multiple type classes, do an instance declaration for each one.
02:06:28 * Elly writes "Unnecessary use of malloc() is considered a social faux pas" on a student assignment
02:06:35 <temoto> blackh: i understand, thanks.
02:07:47 <temoto> Is there kind of Unix socket or TCP HTTP server with executing user callbacks for URLs in Haskell world?
02:08:05 <temoto> I know there is one implementing FastCGI protocol.
02:09:29 <blackh> temoto: There are several things like that. I understand there's at least one HTTP server. There's also an SCGI protocol implementation.
02:09:30 <fasta> Elly: aren't you afraid next time the student might not ever call malloc?
02:10:16 <Elly> fasta: no
02:10:20 <Elly> fasta: I would consider that a plus
02:10:40 <fasta> Elly: then make that a bonus assignment ;)
02:11:00 <Elly> students should think very long and very hard before calling malloc
02:11:08 <Elly> (note that this is a low-level systems programming course)
02:12:26 <blackh> Elly: malloc() doesn't bother me. Not calling free() is what bothers me.
02:12:43 <Elly> blackh: malloc() bothers me when called in IRQ context :P
02:13:00 <blackh> Elly: You should hit them with a ruler for that!
02:13:12 <Elly> I sometimes do!
02:13:25 <C-Keen> [ ] student understands what malloc does
02:15:09 <temoto> Elly: could you show me "unnecessary use of malloc()" too ?
02:15:35 <Elly> temoto: sure. They're writing a keyboard device driver
02:15:41 <Elly> it's supposed to buffer keypresses
02:15:46 <Elly> there are a few strategies people use for this
02:16:01 <Elly> the most common is a fixed-size ring buffer with separate head and tail pointers; easy to do, constant time, no races
02:16:08 <Elly> this student uses a linked list of individual characters
02:16:25 <Elly> (thus paying 16 bytes of malloc overhead per character, making it linear-time, AND calling malloc in IRQ context)
02:16:36 <Elly> I cannot actually *give* you this code because it is not mine to give
02:16:40 <Elly> but that description conveys what is wrong
02:18:56 <temoto> Elly: i understand memory and speed overhead, but what is bad in calling malloc in IRQ context, sorry? I'm at most familiar with lowlevel coding until real mode with 640K mem.
02:19:10 <blackh> Ooh! Ooh! Pick me! Pick me!
02:19:22 <Elly> temoto: IRQ handlers are supposed to do their thing fast and then return
02:19:30 <Elly> temoto: malloc is many things, but it is not fast
02:19:42 <Elly> temoto: also, if they were inside a call to malloc outside the IRQ context, the heap is now corrupt
02:20:19 <blackh> temoto: Depending on the implementation, malloc could have mutexes that block...
02:20:46 <blackh> temoto: Or even ones that don't block...
02:20:47 <temoto> Elly: understood, thanks. Was just curious but you're very verbose, thank you.
02:21:12 <blackh> temoto: If you do that in an IRQ context, you'll wait for another thread to release it - but the other thread can't run - so you'll deadlock.
02:21:33 <Elly> well, really, with their code you'll triple-fault
02:21:48 <Elly> because failing to acknowledge the interrupt controller within a certain amount of time makes it depressed
02:21:53 <Elly> and it starts asserting IRQ 7 at you
02:22:07 <Elly> and they have no handler, so they'll double-fault immediately, which will triple-fault and reboot the machine :)
02:22:21 <temoto> Ring buffer seems all sides winner.
02:22:41 <Elly> it is, in fact
02:23:47 <temoto> blackh: http server you mentioned is HApps?
02:25:10 <Elly> I AM DONE GRADING! :D
02:25:14 <Elly> and I have class in 3.5 hours
02:25:15 <Elly> D:
02:25:26 <blackh> temoto: I am not that knowledgeable, but I think HApps is an application framework that sits on top of a web server. Search for "web server" on hackage - there are a few there.
02:25:56 <dolio> @yow!
02:25:56 <lambdabot> There's a little picture of ED MCMAHON doing BAD THINGS to JOAN RIVERS
02:25:56 <lambdabot> in a $200,000 MALIBU BEACH HOUSE!!
02:26:15 * Elly -> sleep immediately
02:28:29 <blackh> You can get a beach house in Malibu for $200,000?
02:29:05 <aleator_> Why is Data.Map.unionWith type Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a instead of Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c?
02:29:58 <quicksilver> aleator_: because it's union.
02:30:21 <quicksilver> aleator_: so it contains elements which are only present in the first map (for example)
02:30:22 <aleator_> quicksilver: Oh. Right. I was looking for intersection then?
02:30:25 <quicksilver> yes
02:30:29 <aleator_> Sorry :/
02:30:30 <quicksilver> intersectionWith maybe?
02:30:42 <quicksilver> intersectionWith is a cool function.
02:31:23 <quicksilver> :t M.intersectionWith (*)
02:31:24 <lambdabot> forall a k. (Ord k, Num a) => M.Map k a -> M.Map k a -> M.Map k a
02:32:35 <aleator_> Yep. That seems to be it.
02:32:44 <timbod> Hi all - can someone point me to the documentation for cabal-install? I'm trying to configure it to build and install haddock API docs automatically. Should be easy, but I can't find a reference.
02:34:56 <fasta> timbod: No manual entry for cabal-install <- I don't think there is a manual.
02:36:03 <fasta> timbod: regarding your actual problem: just select a random package on Hackage until you found one that does what you are searching for.
02:36:46 <timbod> fasta, hmmm... it seems a shame that it builds all this stuff automatically, but doesn't seem to want to build and install doco. "--enable-documentation" seems to get docs built, but not copied out of the build directory.
02:37:31 <Yuanqiang_Gao> hi
02:38:00 <doserj> timbod: "documentation: True" in .cabal/config works for me.
02:38:42 <fasta> timbod: that file also contains all(?) options.
02:38:53 <fasta> timbod: the source of cabal-install is also not that large.
02:39:19 <dcoutts> timbod: --enable-documentation should build and install docs, lemme know if you find any cases where it does not
02:40:14 <timbod> is it the case that "--enable-X" is the same as "X: True"  in the config file?
02:42:55 <timbod> dcoutts, doserj, fasta : Thanks that seems to work for me ok.
02:43:20 <temoto> Elly: a friend of mine is curious what are 16 bytes wasted for each malloc?
02:44:04 <dcoutts> timbod: you said you thought that --enable-documentation on the command line was not working properly, is that really what was happening? The command line flag and the config file option use exactly the same mechanism.
02:44:43 <dcoutts> timbod: if you've found an obscure bug then I want to know! :-)
02:44:55 <p_l> Question: Which is faster when choosing the right code to deal with data - case statement, pattern matching or dispatching by type? Type information is not known before running (it's an instruction stream)
02:45:13 <timbod> dcoutts: No, it was actually working fine - I was looking for the results in the wrong place. Sorry for the noise.
02:45:30 <dcoutts> timbod: ok, np
02:46:14 <dcoutts> p_l: pattern matching is the same as a case statement (or nested case statements for complex pattern matching)
02:46:46 <timbod> If I want an index of the documentation for all the modules that cabal install has handled, should I just write a script to walk over ~/.cabal/share/*/html? Or is there some automated way to get this?
02:46:49 <dcoutts> p_l: and I don't know what you mean about the types in the instruction stream, you might need to explain
02:47:31 <dcoutts> timbod: you should write code to do it and send in your patch. See http://hackage.haskell.org/trac/hackage/ticket/206
02:47:34 <daf> p_l: pattern matching is the same as a case statement
02:47:52 <daf> p_l: at least, GHC treats function argument pattern matching as sugar for case
02:48:27 <p_l> dcoutts: There's a queue, into which objects of class Instruction enter. Then the queue is processed by execution engine, and it can either read the exact type of the instruction or match on opcode
02:49:01 <dcoutts> p_l: but if it's a queue, then it has to be a queue of a single type
02:49:08 <timbod> dcoutts, thanks for the prod :-) Right now I am throwing together a talk for syd-fp (http://groups.google.com/group/fp-syd) tomorrow night, but I'll take a look at it sometime soon.
02:49:22 <dcoutts> timbod: great :-)
02:50:42 <p_l> dcoutts: I'm not talking of any concrete type for queue right now, though. All of instructions have the same size and format and I was just wondering if it wouldn't be better to use the typesystem to choose correct execution function for the instruction instead of traditional case statement
02:51:01 <dcoutts> p_l: sounds like your thinking about this from an OOP perspective where you could subclass an instruction type. That's not how it works in a parametrically polymorphic system.
02:51:37 <dcoutts> p_l: you can have an Instruction data type with many alternatives, one for each kind of instruction
02:51:51 <dcoutts> that way you can keep lists/queues/streams of them
02:52:03 <p_l> dcoutts: Actually I was thinking more from generic function pov, i.e. creating a generic for instruction and specialized functions for execution
02:52:03 <fasta> dcoutts: I think he is worried about efficiency and whether or not it uses a jump table internally and so on.
02:52:36 <dcoutts> p_l: pattern matching is really pretty efficient
02:53:00 <dcoutts> it uses if/then/else for small numbers of alternatives and jump tables for bigger ones
02:53:03 <dcoutts> like C switch
02:53:35 <pejo> > 7 % 0
02:53:37 <lambdabot>   * Exception: Ratio.%: zero denominator
02:53:56 <pejo> Has % behaved this way forever?
02:54:11 <temoto> Man what a powerful bot here.
02:54:24 <quicksilver> pejo: I believe so.
02:54:25 <dcoutts> p_l: you can make an Instruction an abstract type which is more in the OO style, but that will be somewhat less efficient as it will have to indirect through per-object method calls.
02:54:37 <p_l> I guess I'll use pattern matching then, though using typesystem was nice idea :)
02:54:51 <p_l> s/nice/interesting/
02:55:01 <fasta> temoto: what's powerful about it?
02:55:20 <dcoutts> p_l: yes, in other examples it works better. But for a sequence of instructions they pretty much have to be of the same type.
02:55:49 <quicksilver> "Type classes are for overloading; they are not a general purpose abstraction"
02:56:09 <dcoutts> that's what alternatives and records are for
02:56:14 <p_l> dcoutts: At least MMIX is easier than some by having all instructions in the same format (u8,u8,u8,u8) :)
02:57:22 <temoto> fasta: it knows many commands, i've never seen bot knowing so many.
02:57:39 <fasta> temoto: doesn't dpkg in #debian have more?
02:57:57 <fasta> temoto: ignoring that it doesn't have almost arbitrary code execution.
02:58:08 <temoto> fasta: dunno, i never use it besides -i. Git has many commands.
02:58:20 <fasta> temoto: no, dpkg is a bot
02:58:23 <temoto> oh
02:58:33 <fasta> temoto: it knows more about Debian than I do ;)
02:58:52 <temoto> fasta: i've never seen #debian bot in action.
02:59:24 <fasta> Lambdabot may have a lot of features, but it is low on content.
02:59:26 <p_l> dcoutts: I'm trying to write a MMIX simulator and found Haskell nicer to write it in than some other languages :)
03:00:08 <dcoutts> p_l: yes, an algebraic data type is a good choice for representing asm instructions
03:00:37 <dcoutts> data Instr = ADD Reg Reg Reg | ...
03:00:49 <temoto> man i just realized haskell is probably best language to implement virtual machine
03:04:09 <p_l> temoto: That's what I'm currently doing, except that I'm trying to create a simulator for a "real" machine
03:05:41 <temoto> p_l: i guess "simulator for real machine" is kinda definition for virtual machine :)
03:06:06 <temoto> p_l: it'd be very interesting to see your result.
03:06:23 <daf> p_l: the usual rule applies
03:06:27 <daf> p_l: write it, then measure
03:06:41 <daf> worry about performance if it's too slow the first time around
03:12:06 <p_l> daf: Well, it probably won't be stellar performance anyway - the only benchmark it could have would be against knuth's emulator :D
03:12:21 <p_l> (which is much simpler than my target)
03:12:46 <daf> sounds like a fun project
03:14:18 <p_l> daf: Well, getting the basic cpu emulation (enough to run user-mode code) shouldn't be hard (since you can forget about mmu etc.). Getting the rest will be harder :)
03:14:47 <daf> the hard ones are often the ones worth doing
03:15:32 <p_l> daf: If the emulator will work well enough, I'm going to try to raise few people in order to get a FPGA version
03:16:56 <X-Scale> p_l: are you trying to simulate it at RTL level or instruction level ?
03:18:12 <p_l> X-Scale: Instruction level. I want to simulate a complete computer, get some software, and get some people better at electronic design to help with hw side :)
03:19:50 <X-Scale> That's a quite interesting project. I'm trying to do the same for the R4x00 MIPS platform as a base for an accurate Nintendo 64 simulator.
03:22:47 <p_l> X-Scale: I'd kill for a working, not fussy MIPS emulator that could run mips32 little-endian linux for testing ^^;
03:24:20 <p_l> unfortunately, none will arrive before the thing I need it for is over :)
03:25:09 <quicksilver> emulating the instruction set is the easy bit.
03:25:26 <quicksilver> emulating all the other bits you need to actually run software is the hard bit.
03:27:29 <p_l> quicksilver: that's the later, harder part of my project idea
03:28:31 <p_l> till today it was "on hold till I get a copy of MMIXware book". Today I found that knuth's emulator was the book's manuscript
03:31:05 <p_l> I felt quite stupid when I realized that to get the book I simply had to execute "make docs"
03:35:26 <rio> do you know any up to date haskell books available online as pdf?
03:41:18 <temoto> rio: i know good monads explanation.
03:41:27 <temoto> as html
03:42:45 <hackage> Uploaded to hackage: bindings 0.0.1
03:44:22 <timbod> rio: http://book.realworldhaskell.org/
03:45:15 <luqui> monads as html?
03:45:21 <luqui> that sounds like a fun analogy
03:46:38 <timbod> rio:  but it's not pdf.
03:47:03 <timbod> but it is a good book - worth buying on paper.
03:48:12 <rio> timbod: yeah, i need it quick so i can read it on my trip tomorrow ;)
03:49:48 <temoto> luqui: html set of articles explaining what are monads. I did not get deep understanding yet, though.
03:51:25 <SamB> temoto: don't worry
03:51:31 <SamB> it isn't that deep ;-P
03:52:26 <SamB> rio: you could go to the bookstore
03:52:59 <temoto> I only understood so far that monads is somehow abstraction on something that is changed from outside.
03:53:51 <temoto> And i've heard that it is rather mathematican thermin than programming language invented.
03:54:11 <SamB> temoto: did you learn about the laws ?
03:54:39 <temoto> SamB: i guess no, it doesn't sound familiar.
03:55:49 <beelsebob> luqui: well, they're both mostly used for the wrong purposes, sounds like a not-bad annalogy
03:55:59 <temoto> I've got a book but it is so hard to read without mathematic degree. Not a topic book though.
03:56:12 <luqui> beelsebob, hehe
03:56:23 <rio> SamB: im in germany and i dont think many bookstores have it
03:56:34 <luqui> monads are like html:  they're both not as important as people think...
03:56:41 <temoto> beelsebob: what exactly you meaning wrong in html purposes?
03:56:41 <SamB> rio: hmm, that's a pretty good excuse ;-)
03:56:44 <beelsebob> luqui: lol
03:56:59 <beelsebob> temoto: most people use html for layout
03:57:03 <SamB> luqui: and far too messy and complicated ?
03:57:08 <beelsebob> which it's not for
03:57:15 <luqui> mm... analogy breaks down there
03:57:23 <temoto> beelsebob: you mean they don't use styles?
03:57:41 <beelsebob> I dunno â€“ do notation is messy and complicated (at least compared to the utter simplicity of all the other classes in the chain)
03:58:02 <luqui> do notation /= monad :-)
03:58:03 <beelsebob> temoto: no, I mean they store things in the html that shouldn't be in the html at all
03:58:07 <beelsebob> luqui: indeed :)
03:58:17 <temoto> beelsebob: like what?
03:58:26 <temoto> Articles?
03:59:00 <luqui> I have no problem with monads.  When your abstraction *is* a monad, make it a monad.  When it's not, for the love of god don't make it one.
03:59:01 <beelsebob> temoto: like information on where to position things, or how to style them â€“ they may use styles, but they usually put too much info in the html
03:59:40 <beelsebob> luqui: it's not that part that bothers me (well, it bothers me, but not as much as the other part) â€“ people use the monad abstraction when they don't need it â€“ i.e. they do functor/applicative based computation in monads
03:59:44 <beelsebob> because it's all they seem to know
03:59:46 <temoto> beelsebob: like table markup vs. semantic+css?
03:59:53 <beelsebob> temoto: indeed
04:00:37 <luqui> beelsebob, who cares?  fmap = liftM, <*> = ap.  doesn't matter which you use, because they're equal.
04:00:52 <beelsebob> luqui: yeh, but people don't usually use liftM or ap
04:01:00 <beelsebob> they usually use do x <- m; return $ f x
04:01:06 <temoto> beelsebob: as webdev i must admit those bad days are almost gone you know. At very least it can be clearly concluded that that html unsemantic use really goes down rather than expanding.
04:01:13 <beelsebob> and do x <- m; y <- n; return $ x y
04:01:32 <luqui> fmap = liftM = ((return .) <=<) = ...
04:01:42 <SamB> oooh fishy
04:01:57 <beelsebob> luqui: sure â€“ but people seem to see things like bind as being ultar important/clearer than just writing fmap/liftA/liftM
04:02:12 <beelsebob> temoto: I know of next to no sites that actually do the seperation of semantics/style properly
04:02:27 <SamB> beelsebob: it's not easy!
04:02:29 <beelsebob> but that's mostly because css is in no way powerful enough to do the style properly
04:02:31 <luqui> beelsebob, maybe... I think it's probably a thinking crutch during the transition
04:02:51 <beelsebob> luqui: I'm not sure â€“ I suspect it's more to do with monads being put on high, as being uber important
04:02:56 <beelsebob> so people learn what bind and return are
04:02:57 <luqui> could be
04:03:03 <SamB> CSS doesn't even have parenthesization
04:03:04 <beelsebob> but don't get that there's some other operations that you get first
04:03:10 <SamB> in selectors
04:03:28 <temoto> beelsebob: i mean things are changing to good, maybe not changed to some milestone yet. But tends are very good.
04:03:34 <beelsebob> SamB: indeed â€“ nor does it have simple arithmatic â€“ life would be much simpler if you could specify position: fixed 100% - 100px
04:03:40 <luqui> beelsebob, I was asked to give a monad tutorial at boulder functional programmers group.  I spent 75% of the time on functors :-)
04:03:48 <beelsebob> luqui: :)
04:03:53 <temoto> beelsebob: that's one hell a great example of what CSS lacks.
04:03:53 <SamB> beelsebob: yeah
04:04:05 <mornfall> beelsebob: I find liftM2 to be somewhat unreadable though.
04:04:18 <beelsebob> mornfall: oh? why's that?
04:04:30 <temoto> Hated IE supports that through expression though.
04:04:34 <beelsebob> also, you may find <$> and <*> to be more readable
04:04:43 <mornfall> I do lot of fmap-ing, but that's conceptually simpler, AFAICT.
04:04:56 <mornfall> (Like foo `fmap` monadBar)
04:04:57 <beelsebob> mornfall: it's conceptually equal
04:05:06 <beelsebob> liftM2 is just fmap, but with arity two functions
04:05:15 <SamB> I wasted a lot of time yesterday trying to figure out how to get the code on trac.haskell.org/lhc (WARNING: do not actually look! it'll take a half hour to load if it loads at all!) to stop overflowing and making scrollbars ...
04:05:23 <beelsebob> mornfall: also, if you want to use fmap infix, use <$>
04:05:38 <SamB> the code in the tickets, I mean
04:05:50 <mornfall> beelsebob: Where does that come from?
04:06:01 <beelsebob> Control.Applicative (fucking stupid place for it to be)
04:06:06 <SamB> what I'd really like to do is make the boxes wider but make the normal text wrap about where it does now, I think ...
04:06:21 <beelsebob> > (+1) <$> [2,3,4]
04:06:23 <lambdabot>   [3,4,5]
04:06:25 <mornfall> I guess I'm fine with `fmap` : - )
04:06:37 <beelsebob> > (+) <$> [1,2,3] <*> [2,3,4]
04:06:38 <lambdabot>   [3,4,5,4,5,6,5,6,7]
04:06:51 <beelsebob> ^ much nicer version of liftM2 ^
04:06:56 <luqui> beelsebob, I think applicative is a fine place for <$>.   <$> is part of applicative *notation*
04:07:03 <beelsebob> luqui: is it?
04:07:09 <beelsebob> it depends on nothing from applicative
04:07:10 <mornfall> @type <*>
04:07:11 <lambdabot> parse error on input `<*>'
04:07:15 <mornfall> @type (<*>)
04:07:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:07:25 <luqui> well, that's what I call the foo <$> bar <*> baz. "applicative notation"
04:07:34 <luqui> whether or not the applicative functor comes into it, that's still what I call the notation :-)
04:07:35 <beelsebob> mornfall: this is what I mean about people not realising that monads aren't necessary a lot of the time
04:07:53 <beelsebob> luqui: oh, I would call (pure foo) <*> bar <*> baz the applicative notation
04:08:04 <beelsebob> and foo <$> bar <*> baz the applicative functor notation
04:08:16 <luqui> haha
04:08:23 <beelsebob> (although pure is really from pointed, so I guess that's twisted)
04:08:25 <mornfall> @type (<$>)
04:08:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:08:30 <luqui> wow, there is a lot of overloading going on here
04:09:17 <beelsebob> luqui: did you see our discovery of branchy, sat between applicative and monad?
04:09:25 <mornfall> beelsebob: Dear sir, it's a mess. : - )
04:09:31 <luqui> beelsebob, no!  what is it?
04:09:45 <beelsebob> luqui: http://noordering.wordpress.com/2009/02/14/between-applicative-and-monad/
04:10:12 <beelsebob> mornfall: it's lovely â€“ it clearly expresses that application is curried
04:10:28 <beelsebob> unlike liftMn which suffers all the drawbacks of uncurried functions
04:10:41 <McManiaC> is there a way to get autocompletition for haskell in vim?
04:11:41 <luqui> beelsebob, nice.  I definitely like the either formulation.  The original one seemed silly and arbitrary.
04:11:59 <beelsebob> luqui: yeh, the either one seems rather arbitrary to me too though
04:12:44 <luqui> yeah that church encoding is rough
04:12:58 <luqui> it's not equivalent to commuting over EIther?
04:13:05 <luqui> f (Either a b) -> Either (f a) (f b)
04:13:19 <luqui> oh right, not
04:15:18 <luqui> what about: f (b -> c) -> f (Either b d) -> f (EIther c d)
04:15:33 <luqui> no, that doesn't do it
04:16:31 <Cheshire> why do you have to write : before infix type operators?
04:17:10 <BONUS> you don
04:17:11 <BONUS> t
04:17:11 <luqui> f (Either a b) -> f (a -> c) -> f (b -> c) -> f c   really is the right one, I think...
04:17:34 <BONUS> > let a ^.^ b = 2*a + 3*b in 3 ^.^ 8
04:17:35 <lambdabot>   30
04:17:52 <luqui> Cheshire, it's a false consistency.  at the value level, variables start with lowercase and constructors start with uppercase.  for infix, constructors start with : and variables don't
04:17:56 <SamB> Cheshire: it's the capital "letter"
04:18:06 <luqui> so it was just generalized
04:18:14 <Cheshire> what do you mean here _false_ consistency?
04:18:27 <fasta> What exactly is the point of all these "abstractions"? Just like "arrows" can express "parallel computations", so can just writing a basic compiler for Haskell (modulo the fact that writing one that does it always better than just using one core is not that easy). Monads solve a very concrete problem, the rest seems to be just there for efficiency reasons because the compiler is not smart enough.
04:18:28 <SamB> it isn't false
04:18:39 <SamB> but the capital/lowercase thing is of dubious utility
04:18:43 <luqui> it's a cursory syntactic consistency, not an essential one. there are already enough differences between type and operator level
04:19:00 <luqui> that trying to draw the already-broken analogy is a lost cause
04:19:17 <beelsebob> fasta: because not everything is a monad
04:19:24 <beelsebob> but a lot of useful things can be encoded for them anyway
04:19:26 <SamB> luqui: well, the constructors are already differentiated from the values ...
04:19:29 <beelsebob> e.g. a ZipList is useful
04:19:32 <beelsebob> but not a monad
04:19:40 <Cheshire> maybe I am not true but it seems there is never a context in haskell which you don't know whether it's a type or a value
04:19:49 <SamB> (at the type level)
04:20:03 <SamB> Cheshire: 'tis unfortunate
04:20:04 <luqui> Cheshire, yep, that sounds right
04:20:05 <Cheshire> so.. just in terms of getting a parse, these conventions aren't essential are they?
04:20:29 <luqui> no they are not
04:20:36 <SamB> no. we don't need the capital/lowercase distinction at all just to get a parse, really ...
04:20:50 <SamB> (though it would complicate matters!)
04:20:57 <Cheshire> what would it complicate?
04:20:57 <luqui> SamB, well, a reasonably informative parse, eg. pattern matching...
04:21:12 <SamB> luqui: yes, that's what it would complicate
04:21:32 <Cheshire> huh
04:21:36 <SamB> you'd have to know what was in scope to decide whether or not it was a pattern match ...
04:21:42 <SamB> er. that is, what kind it is.
04:21:56 <SamB> (whether it binds a variable or not)
04:22:12 <SamB> (you also couldn't shadow constructors)
04:22:21 <luqui> but SPJ, among others, has proposed the death of that rule
04:22:24 <SamB> (not that you can now either ;-P)
04:22:32 <luqui> colon on infix type operators, that is
04:22:36 <SamB> hmm.
04:22:39 <luqui> *constructors
04:22:51 * Cheshire wants 0 1 + * for type constructor..
04:23:06 <luqui> I would much rather use * than (,)
04:23:12 <SamB> so would he be proposing the abolishment of capital/lowercase restrictions at the type level as well ?
04:23:23 <luqui> (1,2) :: (Int,Int)  bugs me to no end.  A tuple is not a type!
04:23:24 <Cheshire> hm this reminds me of something
04:23:47 <beelsebob> Cheshire: yes, I want that too
04:23:51 <luqui> SamB, no, just for infix
04:23:52 <beelsebob> it would mean we could tidy up bottoms
04:23:58 <beelsebob> we don't need extra bottoms for 1 and *
04:24:02 <SamB> luqui: how come ?
04:24:04 <luqui> SamB, outlawing infix type *variables*, only allowing consturctors
04:24:11 <SamB> luqui: ah.
04:24:23 <SamB> that would deal with a certain haddock bug very well ;-P
04:24:59 <SamB> no more broken printing of the tyvar ~~>
04:25:07 <luqui> beelsebob, uh... how do you propose?
04:25:16 <luqui> for * esp.
04:25:36 <beelsebob> luqui: well 1 and * have known _|_ values â€“ for * it's _|_ * _|_, while for 1 it's 1
04:25:58 <beelsebob> (we *could* extend the types to contain extra values, but we don't have to in those cases)
04:26:11 <beelsebob> luqui: of note, this would allow fmap on tuples to be lazy
04:26:19 <beelsebob> because _|_,_|_ really would be _|_
04:26:31 <luqui> beelsebob, of note, we would have to use unamb for seq
04:26:40 <beelsebob> oh?
04:26:43 <luqui> (or kill seq, mwahahahaha!)
04:26:46 * beelsebob thinks about that
04:27:09 * beelsebob doesn't see it yet
04:27:16 <luqui> (halting1, halting2) `seq` ...  -- is this _|_ ?
04:27:31 <luqui> only if *neither* halting1 nor halting2 halt
04:27:39 <beelsebob> oh, interesting
04:27:47 <Cheshire> you can implement seq for most stuff juts using a typeclass
04:28:00 <luqui> Seq used to be a typeclass
04:28:14 <luqui> Why was Haskell98 a step backwards?
04:28:21 <beelsebob> heh
04:29:18 <luqui> I just realized something... most of the haskell features which were put in purely for practicality are getting shunned by the community
04:29:39 <beelsebob> oh?
04:29:42 <Cheshire> luqui, except for unsafePerformIO which everyone loves
04:29:43 <luqui> That's a good support argument for my being an unreasonably purist
04:29:50 <luqui> Cheshire, lol
04:29:58 <beelsebob> I love unsafePerformIO
04:30:06 <beelsebob> it's a good way of adding extra litteral types to Haskell
04:30:26 <Cheshire> "Well you just prove that your use is ok and then you have type safety again!"
04:30:27 <luqui> beelsebob, well, seq and fail at least...
04:30:47 <luqui> except you have no framework in which to prove it!
04:30:50 <beelsebob> Cheshire: yep, and adding extra litterals to Haskell always is safe that way :)
04:30:54 <luqui> because of the IO in unsafePerformIO
04:31:05 <Cheshire> HWLF (hand-wave logical framework)
04:31:06 <beelsebob> yep, "proofs" are always rather vague
04:31:33 <luqui> well, they're always tied in to the operational semantics of GHC
04:31:54 <beelsebob> imageLit = unsafePerformIO . readImage -- I have no problem with this at all
04:32:12 <beelsebob> even if it does make a large assumption that readImage doesn't have side effects
04:32:18 <luqui> beelsebob, oh!  I was wondering what you meant by literals.
04:32:28 <Cheshire> beelsebob, lets blow up the proportian a few times just for pedagodgy
04:32:48 <beelsebob> Cheshire: pardon?
04:32:50 <Cheshire> beelsebob, imagine you're writing a 3D computer game and you loaded (large) textures this way
04:32:57 <beelsebob> Cheshire: okay...
04:33:21 <beelsebob> I'm imagining
04:33:25 <luqui> Cheshire, what you're getting at sounds like a limitation of a particular implementation rather than a fundamental problem
04:33:27 <Cheshire> beelsebob, so my character goes around a corner then unsafePerformIO starts forcing all this file access at one -- it's not predictable
04:33:41 <Cheshire> so you get jumpyness etc
04:33:43 <beelsebob> Cheshire: that's what seq is for
04:33:53 <beelsebob> also, you're writing your 3D games wrong
04:33:54 <luqui> yeah, fix hacks with other hacks!
04:34:09 <beelsebob> you should be pushing all your resources onto the GPU right at the start
04:34:12 <Cheshire> beelsebob, sigh who is the one that is using unsafePerformIO here....
04:34:16 <beelsebob> luqui: :)
04:34:27 <beelsebob> Cheshire: that's a cyclic argument
04:34:36 <Cheshire> what?
04:34:54 <beelsebob> you're arguing that my use of unsafePerformIO here is bad because I'm using unsafePerformIO
04:34:56 <beelsebob> ...
04:35:00 <Cheshire> ok
04:35:17 <Cheshire> (that's not what I said at all but I wont force you to listen to me)
04:35:22 <Axman6> beelsebob: not an entirely bad argument though :P
04:35:29 <luqui> hm, I guess the right way to do extended literals is to hook the linker
04:35:44 <beelsebob> luqui: interesting idea
04:35:52 <beelsebob> I guess my version is dynamic litteral linking
04:36:05 <beelsebob> just my dlls have .png extensions
04:36:14 <luqui> really simple-minded, but yeah :-)
04:36:20 <luqui> (oops, I chdired!)
04:36:27 <beelsebob> yeh
04:36:47 <HugoDaniel> haskell = unsafePerformIO
04:37:05 <idnar> unsafePerformHaskell
04:37:06 <beelsebob> HugoDaniel: no, haskell is unperformSafeIO
04:37:12 <beelsebob> the Haskell is safe
04:37:22 <beelsebob> and you undo it all pushing it into the IO world
04:37:36 <luqui> LOL
04:37:57 <Cheshire> beelsebob, "you're arguing that my use of unsafePerformIO here is bad because I'm using unsafePerformIO" -- no, I'm saying that "you're writing your 3D games wrong" is missing the point, I used this example to try and explain something
04:38:13 <HugoDaniel> :D
04:38:16 <beelsebob> Cheshire: yes â€“ but a performance problem is not a semantic one
04:38:20 <beelsebob> that was my point
04:38:35 <beelsebob> solution â€“ don't open yourself up to that performance problem
04:38:39 <Cheshire> mumbo jumbo
04:38:48 <Cheshire> everything is "semantic" these days
04:38:48 <HugoDaniel> i think 3D games should be 2D
04:38:55 <HugoDaniel> like the streetfighter
04:38:59 <HugoDaniel> 2d is the new 3d
04:39:04 <luqui> Cheshire, welcome the revolution!
04:39:09 <beelsebob> Cheshire: well, meaning is what's important ;)
04:39:12 <HugoDaniel> streetfighter 4 :)
04:39:24 <luqui> beelsebob, but performance is also important
04:39:31 <Cheshire> luqui, I think it's a buzzword but we'll see
04:39:33 <luqui> ultimately, I think performance needs to be part of meaning
04:39:51 <luqui> but we don't have the maths to describe that nicely yet
04:40:08 <luqui> Cheshire, you do know that it has a precise definition, right?
04:40:11 <Cheshire> you might have to enter into operational semantics (oh no!)
04:40:19 <Cheshire> luqui, so does 'closure' and 'DSL' :p
04:40:31 <beelsebob> luqui: true, but it can be worked around
04:40:39 <luqui> Cheshire, oh, conal's disciples mean "denotation semantics" when they say "semantics"
04:40:40 <beelsebob> in this case by shoving your textures onto the GPU when you start
04:40:46 <beelsebob> also... I has new toy
04:40:50 * beelsebob runs off to play
04:42:24 <luqui> Cheshire, but yeah, it could be.  I guess the point is to be able to do math on programs, whatever you call it.
04:42:37 <luqui> we have to be careful not to stray from that when we use the word
04:44:00 <Cheshire> luqui, but haskell basically is just an implementation of a domain theory text book
04:44:17 <luqui> Cheshire, yeah!
04:44:17 <Cheshire> so you can probably get away with it
04:44:33 <Axman6> beelsebob: did you see i released that AVar thing on hackage?
04:44:36 <luqui> get away with what?
04:44:42 <Cheshire> calling everything semantic :p
04:44:59 <luqui> I'd be lying if I used that word for unsafePerformIO :-)
04:45:45 <luqui> and it's tough to use that word for IO.  if we claim IO has a meaning, but can't say what it is... um...
04:46:39 <fasta> beelsebob: right, but you don't have to explicitly name everything as to what it is. If you would do that, you would end up with horribly long names.
04:47:50 <Cheshire> well the question about IO (and it's not a very interesting question but I will ask it anyway) is:  Is it unsatisfactory to axiomatise the relations between various IO primitives compared to constructing some model (GADT, IOTree, etc..) that you can prove the relations from.
04:48:11 <fasta> Regaring arrows specifically: they might be a nice compilation target, but to program with them directly without any kind of better UI is just cumbersome.
04:48:27 <luqui> Cheshire, if you prove your axioms consistent, then they're the same thing
04:48:36 <SamB> Cheshire: both are unsatisfactory!
04:48:39 <luqui> Cheshire, although on a human level, it's nice to have a "platonic" model to work with
04:49:40 <luqui> I think either would be satisfactory.  I don't think it is feasible, however.
04:50:02 <luqui> I'm talking about a deep axiomatic system, not "it corresponds to some random-ass data structure"
04:50:59 <SamB> well, what I mean is that it's not going to be feasable to prove much about any actual IO implementation
04:51:24 <luqui> right.  the operational semantics are tangled up with those of the operating system and the computer and the RTs
04:51:37 <luqui> which are all pretty complex beasts
04:52:00 <SamB> and with all the code generation hacks that might be involved
04:52:18 <luqui> though you could do some stuff using nondeterministic semantics, maybe.  I don't know how much that would buy you
04:52:28 <luqui> (you might find that most of your programs are quite incorrect!)
04:56:54 <ski_> beelsebob : could you elaborate on "Well no, bind/join give us too much power, they let us make choices between an infinite number of functions" ?
05:05:31 <ski_> (hmm .. it appears to start with `<mreh> myGetLine :: String -> IO String' ..)
05:13:55 <ivanm> matthew-_: enjoy my graphviz updates :p
05:15:50 <alexeevg> @seen dcoutts
05:15:50 <lambdabot> dcoutts is in #haskell-overflow, #darcs, #ghc, #haskell, #haskell-soc and #gentoo-haskell. I last heard dcoutts speak 19m 14s ago.
05:15:57 <dcoutts> @arr!
05:15:57 <lambdabot> Aye Aye Cap'n
05:16:26 <alexeevg> dcoutts: how urgent is the #262 ?
05:17:37 <dcoutts> alexeevg: oh, I've fixed it
05:17:51 <dcoutts> alexeevg: I'm just testing it now
05:17:58 <alexeevg> oh, I see
05:18:00 <dcoutts> building ~900 packages, twice
05:18:47 <ski_> @type maybe Nothing
05:18:48 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
05:18:52 <ski_> @type either Left
05:18:53 <lambdabot> forall a b b1. (b1 -> Either a b) -> Either a b1 -> Either a b
05:20:12 <alexeevg> btw, what is the accepted practice to prevent "developer collisions" for Cabal? As far as I can see, tickets are never assigned
05:20:33 <dcoutts> alexeevg: you can assign them if you like
05:20:45 <dcoutts> alexeevg: I tend not to because I work on anything/everything
05:21:09 <alexeevg> I see, thanks
05:21:15 <dcoutts> alexeevg: you got me in the few hours between fixing that ticket and pushing the patches
05:22:49 <lilac> @@ @type (=<<) :: @type maybe Nothing
05:22:51 <lambdabot>  forall a1 a. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
05:22:57 <Axman6> how could i forkIO lots of threads, and then not exit my program until they've all finished? trying to think of a way to do it with mvars, but can't think of anything nice
05:24:09 <Axman6> thesting this concurrent mutable variable thing, and i'm trying to see how well it copes with concurrency
05:26:26 <quicksilver> Axman6: write a wrapper around fork which makes a new MVar and fills it when that thread is done
05:26:35 <quicksilver> and then make the main thread wait on all those mvars
05:26:45 <quicksilver> such a wrapper has occurred to me as useful quite often.
05:27:22 <Axman6> yeah, seems that needing to wait for a thread to terminate must be kind of common
05:27:31 <dcoutts> alexeevg: the new header and lib check is really pretty good.
05:27:47 <Cheshire> * Thou shalt curry your functions
05:27:58 <blackh> Axman6: My k-nucleotide benchmark has something like what you're after
05:28:19 <Axman6> oh really? sounds nice. got a link?
05:28:33 <dcoutts> alexeevg: only 6 packages where it made them fail where they would not otherwise have done, and with a couple fixes those now work too.
05:28:49 <blackh> http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&lang=ghc&id=3
05:28:54 <blackh> Look at "parallel"
05:29:15 <Axman6> looks perfect
05:29:22 <ski_> @type list [] . ((++) .)
05:29:23 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
05:29:28 * Axman6 steals it :P
05:29:49 <Cheshire> :t flip concatMap
05:29:50 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
05:30:07 * blackh is glad to have made himself useful!
05:30:19 <Axman6> blackh: thanks for that, saved me some time, and rather hackish code
05:30:20 <luqui> :t list
05:30:21 <lambdabot> forall b a. b -> (a -> b -> b) -> [a] -> b
05:30:30 <ski_> list = flip foldr
05:30:32 <temoto> What means that dot after 'a'?
05:30:41 <quicksilver> temoto: it's punctuation
05:30:49 <temoto> Like newline?
05:30:52 <quicksilver> temoto: it's there to separate the 'forall part' from the main type
05:30:59 <ski_> temoto : end of the list of quantified variables, start of the body of the quantification
05:31:15 <quicksilver> note that 'forall' isn't haskell98
05:31:18 <quicksilver> it's a GHC extension.\
05:31:20 <skorpan> function :: quantified variables. quantification
05:31:32 <blackh> temoto: "forall b a." is a keyword - you can generally ignore that part
05:31:32 <temoto> erh.. it looks exactly like that in all sources? With dot?
05:31:35 <ski_> s/quantification/quantificand/
05:31:43 <quicksilver> temoto: it's not part of haskell98
05:31:45 <temoto> blackh: you made it clear, thanks.
05:31:48 <quicksilver> haskell98 sources would just have
05:31:56 <quicksilver> [a] -> (a -> [b]) -> [b]
05:31:59 <quicksilver> for example.
05:32:02 * ski_ would like a good role name for the quantified variables ..
05:32:10 <temoto> quicksilver: yeah i used to read that kind of header.
05:32:25 <temoto> quicksilver: is that outdated or something?
05:32:35 <quicksilver> I woudln't say that.
05:32:39 <quicksilver> it is what it is.
05:32:42 <luqui> temoto, it is still the norm
05:32:46 <quicksilver> haskell98 has a simpler type system than GHC.
05:32:51 <temoto> Aha.
05:33:03 <quicksilver> in haskell98, all variables are implicitly quantified at the top level
05:33:12 <quicksilver> so for brevity the quantification is left out
05:33:30 <quicksilver> GHC can express nested foralls and stuff, so it has to have syntax to write them explicitly.
05:34:14 <temoto> quicksilver: i thought auto type inspecting is most strong feature of haskell. It is not language level?
05:34:27 <luqui> inspecting?
05:34:39 <temoto> Well like you don't write types like in C.
05:34:47 <asgaroth> that's type inference
05:34:48 <luqui> oh inference
05:34:54 <temoto> Inference, sorry.
05:35:05 <luqui> yeah.  so you don't have to write type signatures at all
05:35:09 <quicksilver> temoto: I think we have an impedance mismatch.
05:35:10 <asgaroth> I really wouldn't call it the most strong feature though
05:35:12 <luqui> most people do, for top level functions
05:35:18 <quicksilver> temoto: your question appears to have nothing to do with what we were talking about.
05:35:31 <quicksilver> we were talking about haskell98 not having a forall keyword
05:35:33 <quicksilver> and why GHC does.
05:35:37 <temoto> oh
05:36:10 <temoto> My question was that i've never seen that "forall a b." in sources in books.
05:36:29 <luqui> asgaroth, it's a very strong feature for people coming from a C background.  At least it is the most approachable one
05:36:38 <quicksilver> well books tend to describe haskell98 for the most part.
05:36:39 <luqui> until they start to see the really strong features :-)
05:36:41 <quicksilver> so they wouldn't use that.
05:37:02 <temoto> quicksilver: yeah well one was describing HUGS.
05:37:38 <quicksilver> well hugs has a few extensions of its own too
05:37:52 <quicksilver> but haskell98 is already an interesting enough language to write a book about
05:38:04 <quicksilver> you can leave extensions for later :)
05:38:38 <temoto> To have it clear
05:38:41 <temoto> :t list
05:38:42 <lambdabot> forall b a. b -> (a -> b -> b) -> [a] -> b
05:38:53 <temoto> if we remove forall part, would it still be the same?
05:39:14 <doserj> yes
05:39:15 <MyCatVerbs> temoto: in Haskell98, the forall is implicit.
05:39:16 <Axman6> blackh: hmm, doesn't seem to quite do what i want, and i don't know why :\
05:39:18 <ski_> yes, since the `forall' appears first
05:39:25 <ski_> (not inside anything)
05:39:31 <temoto> omg inside too
05:39:38 <blackh> temoto: "forall" is used for Rank-N types which is fairly advanced. A lot of text books don't cover it.
05:39:44 <Axman6> blackh: ah, scratch that, i was using forkIO where i shouldn't have :)
05:39:46 <temoto> i guess i'll have to understand that later.
05:40:00 <MyCatVerbs> temoto: lambdabot just puts the forall in front explicitly because some people like it that way. :)
05:40:15 <temoto> MyCatVerbs: understood.
05:40:15 <blackh> temoto: It isn't that difficult, but you just need to learn everything else first.
05:40:27 <temoto> blackh: yeah, i will.
05:41:43 <MyCatVerbs> temoto: (plus if you turn on certain GHC type system extensions, you *have* to explicitly put the foralls in yourself when writing type signatures. That's only for scoped type variables and rank-n-types at the moment, AFAIK, neither of which you're likely to be interested in right away).
05:43:21 <temoto> MyCatVerbs: yeah i won't turn extensions right away :)
05:44:42 <blackh> Axman6: That 'parallel' thing is so simple and neat, eh. I really love Haskell's concurrency stuff.
05:45:04 <Axman6> blackh: yeah me too. seems like a function that could be really useful to others too
05:45:46 <Axman6> quicksilver: did you see this parallel function of blackh's? (http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&lang=ghc&id=3)
05:46:45 <blackh> Axman6: I kept wondering if you could do the same function with parMap and so forth from the parallel strategies package - but I haven't figured out whether that's possible.
05:51:58 <Axman6> blackh: yeah, i'm sure it could be done, but not sure how
06:14:04 <ertai> I'm wondering why the directory-1.0.0.2 package is not on hackage?
06:42:46 <hackage> Uploaded to hackage: pqueue-mtl 1.0.4
06:42:46 <hackage> Uploaded to hackage: stateful-mtl 1.0.4
06:42:46 <hackage> Uploaded to hackage: funsat 0.5.2
06:44:04 <CTA> Hmm I'm really debated over Haskell & C#
06:44:13 <Elly> How can there be a debate there?
06:44:26 <CTA> Like what to learn
06:44:27 <drhodes> I need to read raw bytes from a file and ::Int them, having trouble finding good docs, for lack of words.
06:44:41 <Elly> Learn haskell :)
06:44:44 <Cheshire> CTA, both ...
06:44:44 <Axman6> CTA: learn both
06:44:47 <CTA> I don't know which way to go, I just got a C# book 10 days ago, I want to be in the games industry
06:44:55 <Axman6> then realise haskell is way cooler
06:44:56 <Elly> then learn C++, not C#
06:45:01 <Cheshire> ugh don't learn C++
06:45:05 <CTA> Nope i've been there
06:45:05 <Elly> (I never thought I'd tell someone to learn C++)
06:45:07 <Cheshire> people are writing games in C# today
06:45:21 <Elly> Really? I didn't think the CLR's JIT was that good yet
06:45:27 <CTA> I've came from Java - C++ - C - pascal - C#
06:45:42 <Axman6> can't you use C# on the Wii? (no idea where i got this idea from)
06:45:44 <Cheshire> Elly, (perhaps the engine is written in C++)
06:45:56 <Cheshire> but the /games/ may be in C#
06:45:57 <daf> and people will write games in Haskell tomorrow
06:46:00 <Elly> ah, I see
06:46:05 * Elly -> classes
06:46:05 <Axman6> CTA: in that case, learn haskell, you've had too much C*
06:46:56 <CTA> the thing is I just bought a book like 2 weeks ago for "22
06:46:59 <CTA> *£22
06:47:00 <Cheshire> CTA, if you can already use Java and C there is not much to 'learn' for using C#, just pick it up as you go
06:47:16 <CTA> breif knowledge in everythong but c++
06:48:47 <quicksilver> my understanding is that games are not written in C# and are unlikely to be.
06:48:54 <CTA> most are C++
06:49:04 * Zao points quicksilver at SlimDX.
06:49:07 <quicksilver> because game developers have to think about PS3, Wii, possibly Mac
06:49:13 <CTA> my understanding is that games are not written in Haskell
06:49:14 <quicksilver> Zao: I'm generalising.
06:49:18 <quicksilver> CTA: indeed.
06:49:29 <quicksilver> hence Elly's advice. If you want a job in computer games today, get good at C++.
06:49:54 <CTA> I've been at C++, Ok it's good, but for GUIs etc? no..
06:50:03 <Cheshire> people are using C#, lua etc to write games
06:50:09 <Cheshire> C++ to write a game engine
06:50:18 <Zao> Games generally don't have traditional GUIs.
06:50:28 <Zao> Tools do, and are preferably written in non-C++.
06:50:46 <CTA> say I went back to C++, I have the book accelerated C++, but like, The programs I make are "naff"
06:50:50 <Nafai> A lot of gaming engines use C++ for the engine and then some scripting language to do game logic
06:52:16 <Axman6> sounds like the way it should be done
06:52:46 <CTA> Ok.. I might go back to C++.. rgh idk, i just spend £22 buying a book :(
06:52:58 <quicksilver> C# is an interesting language.
06:53:00 <daf> CTA: where did you buy it?
06:53:01 <quicksilver> no harm learning about it.
06:53:11 <quicksilver> haskell is a much more interesting language though :)
06:53:30 <daf> making games is fun
06:53:38 <daf> but writing Haskell is much more fun than writing C++
06:53:44 <wjt> quicksilver: mono has a linker now, so you can run Câ™¯ on things that don't have a .net VM
06:53:45 <Nafai> making games is sort of fun
06:54:01 <Nafai> I did my 2 years in the game industry and that was enough :)
06:54:06 <CTA> amazon
06:54:07 <wjt> quicksilver: some folks have written Câ™¯ games for the iPhone using it
06:54:09 <CTA> head first c#
06:54:11 <quicksilver> wjt: yeah, I know. But I don't want to. ;)
06:54:12 <daf> wjt: â™¯? get out!
06:54:22 <Axman6> ah hooray, my AVar package has docs now: http://hackage.haskell.org/packages/archive/AVar/0.0.2/doc/html/Data-AVar.html
06:54:44 <daf> quicksilver: I think wjt is saying that this means games people are more likely to use it
06:54:46 * Axman6 would like comments if anyone has some
06:54:48 <daf> I can believe it
06:55:12 <Cheshire> CTA, why don't you give the book to a charity shop
06:55:17 <wjt> I think Câ™¯ is less scary than Haskell to an industry used to C++
06:55:25 <CTA> hmm no..
06:55:37 <Cheshire> CTA, clearly spending Â£22 on this book is making you very uneasy
06:55:42 <CTA> what happens if i want to go back to it in the future?
06:56:00 <paper_cc> nothing should be scary to a programmer used to and familliar with C++ ...
06:56:03 <Cheshire> CTA, presumably you will (or will not) be repaid for your kindness
06:56:05 <CTA> I'm prepared to learn another language instead, I just want one that I can stick with forever lol..
06:56:19 <daf> wjt: then again, I also think that shipping a .net VM is not necessarily that big a deal
06:56:21 <Cheshire> CTA, stick with forever means stagnation and that doesn't taste good
06:56:37 <wjt> daf: it is on the iPhone :)
06:56:38 <CTA> say if I did learn Haskell, I'm a complete beginner in functional programming, what book would you recommend me? real world haskell? i would want a book that told me exactly what to do, like how to compile a program etc
06:56:58 <paper_cc> @where lyah
06:56:58 <lambdabot> www.learnyouahaskell.com
06:57:02 <wjt> CTA: RWH is very good.
06:57:14 <daf> CTA: yes, I would recommend RWH too
06:57:16 <fasta> I read about some language features of C# and thought some features were utterly pointless.
06:57:29 <Axman6> both RWH and lyah are great
06:57:29 <daf> CTA: learning multiple languages is a very good thing to do in the long term
06:57:51 <CTA> hard though?
06:57:58 <CTA> I can barely learn one atm, i'm 15
06:58:05 <MyCatVerbs> fasta: that's nothing. I looked at the GHC manual and I couldn't think of a single use for even half of those type system extensions.
06:58:24 <MyCatVerbs> fasta: thank goodness there are more imaginitive people in this world than myself, no? :)
06:58:30 <fasta> MyCatVerbs: do we have the same manual?
06:58:43 <Axman6> MyCatVerbs: well, they come out of need rather than want don't they?
06:58:49 <daf> CTA: learing to write programs is hard
06:58:50 <fasta> MyCatVerbs: I only didn't use TypeFamilies, because they are way too fragile.
06:58:56 <daf> CTA: but the first one is probably the hardest
06:59:05 <daf> CTA: and we do it anyway because it's fun
06:59:08 <fasta> MyCatVerbs: I don't think there is anything I didn't use at some point in time.
06:59:18 <MyCatVerbs> Axman6: no, you can hack around the lack of any of them, you'll just end up with a program that sucks more than it otherwise would.
06:59:27 <fasta> MyCatVerbs: some features are also bad features, so I don't use those anymore :)
06:59:32 <Axman6> heh
06:59:53 <Axman6> fasta: aren't they called bugs? :)
06:59:56 <MyCatVerbs> fasta: I've yet to run into a need for any of the extensions other than rank n types.
07:00:15 <dancor> what's the best way to see if a fifo has anything in it
07:00:18 <MyCatVerbs> Axman6: no. The term is "misfeatures". They work as intended, but the intensions were incorrect. =)
07:00:25 <Cheshire> MyCatVerbs, I use NoMonomorphismRestriction often
07:00:35 <fasta> MyCatVerbs: I don't really like rank n types, as it completely disables the ability to do refactoring.
07:00:39 <dancor> there is no 'select' wrapper or non-blocking io that i can see in standard libs
07:00:42 <MyCatVerbs> Cheshire: I usually just give explicit signatures.
07:00:47 <CTA> doubleSmallNumber x <-- so that's a function: doubleSmallNumber with parameter of x?
07:00:48 <fasta> MyCatVerbs: and most of the times you don't actually need it.
07:00:58 <dancor> should i just kill a thread after a short timeout?
07:00:58 <CTA> ./argument
07:01:04 <Axman6> CTA: sure
07:01:05 <MyCatVerbs> fasta: don't know, and poppycock, respectively. :)
07:01:37 <Axman6> > let f x = if x < 100 then x+x else x in (f 10,f 123)
07:01:38 <lambdabot>   (20,123)
07:01:39 <fasta> MyCatVerbs: No definitions found for "poppycock"
07:01:42 <MyCatVerbs> fasta: (I've only ever found one use for them, where I wanted a state parameter in a datatype whose type the outer code really didn't want to care about).
07:02:24 <fasta> MyCatVerbs: http://en.wiktionary.org/wiki/poppycock
07:02:26 <Axman6> sounds somewhat like ST...
07:02:28 <MyCatVerbs> fasta: it's an old dutch loanword for "soft deer excrement". Along with monocles, canes, pipe smoking and top hats, it's pretty much a shibboleth for anyone pretending to be Victorian british. :)
07:02:29 <fasta> MyCatVerbs: never mind :)
07:02:32 <CTA> how do i declare, asign and output a var'? int iNumber = 0 .. putStrLn iNumber? / print(iNumber) ?
07:02:52 <fasta> MyCatVerbs: I am Dutch, but I didn't know it.
07:03:32 * dancor is sure shibboleth is the shibboleth of something too
07:03:33 <Axman6> CTA: just iNumber = 0, and the in main, main = print iNumber
07:03:39 <paper_cc> CTA: well, you can't assign actually
07:03:39 <ozy`> fasta: it's probably been mutated somewhat from the original dutch version. and even so, the original might have gone out of use altogether
07:04:04 <ozy`> dancor: yes, the word "shibboleth" was a shibboleth at one point
07:04:04 <Axman6> dancor: is was in a wast wing episode, proving some chinese refugees' christianity
07:04:15 <fasta> ozy`: yes, I found some Dutch people discussing it.
07:04:17 <Cheshire> @w80 shibboleth
07:04:18 <lambdabot> *** "shibboleth" wn "WordNet (r) 2.0"
07:04:18 <lambdabot> shibboleth
07:04:18 <lambdabot>      n 1: a favorite saying of a sect or political group [syn: {motto},
07:04:18 <lambdabot>            {slogan}, {catchword}]
07:04:18 <lambdabot>      2: a manner of speaking that is distinctive of a particular
07:04:20 <lambdabot>         group of people
07:04:25 <Axman6> and i believe that's how it was used in the bible
07:04:29 <fasta> ozy`: so, it's not a universal truth on wiktionary ;)
07:04:37 <CTA> do you not declare what type it has Axman?
07:04:52 <Axman6> CTA: iNumber = 0 :: Integer
07:04:59 <Cheshire> is something like  "the book seemed cathartic for me even from its beginning"  a useful comment on haskell wiki?
07:05:01 <Axman6> or :: Int if you want
07:05:05 <paper_cc> CTA: you mustn't declare the type actually
07:05:09 <daf> CTA: you don't have to; the compiler can work it out
07:05:22 <paper_cc> s/mustn't/haven't got to/
07:05:22 <Axman6> CTA: all these questions and more can be answered by reading lyah though ;)
07:05:26 <MyCatVerbs> Cheshire: not unless you're going to explain how on Earth a Haskell wiki provides you with catharsis. :)
07:05:33 <quicksilver> "iNumber :: Int; iNumber = 0"
07:05:43 <quicksilver> where ; is probably a newline
07:06:06 <pk> hey
07:06:31 <pk> Is there a handy way to mesure time ?
07:06:46 <Axman6> Dats.Time.Clock i think
07:06:50 <Axman6> @hoogle Clock
07:06:51 <lambdabot> module Data.Time.Clock
07:06:51 <lambdabot> System.Posix.Types type ClockTick = CClock
07:06:51 <lambdabot> Foreign.C.Types data CClock
07:07:07 <Axman6> @hoogle diffTime
07:07:07 <lambdabot> Data.Time.Clock data DiffTime
07:07:07 <lambdabot> Data.Time.Clock data NominalDiffTime
07:07:07 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
07:07:10 <quicksilver> now <- getCurrentTime; do some stuff; later <- getCurrentTime
07:07:11 <pk> it gives the date
07:07:34 <MyCatVerbs> Further to what quicksilver said, that's in the System.Time module.
07:07:55 <pk> how can I get the diffenrence between to dates ?
07:07:56 <MyCatVerbs> Er, I'm wrong. Data.Time. System.Time gives other stuff enirely.
07:08:42 <ozy`> :t (------>)
07:08:42 <lambdabot> parse error (possibly incorrect indentation)
07:08:43 <CTA> http://codepad.org/zvdl5RPv so all variables have to be global? i got error when it was local?
07:08:47 <Axman6> pk: diffUTCTime
07:08:52 <CTA> something to do with the =
07:08:59 <ozy`> :t (<------)
07:09:00 <lambdabot> parse error (possibly incorrect indentation)
07:09:05 <fldr> Does anyone know if there exist Haskell bindings for ptrace?
07:09:09 <Axman6> CTA: please go read a tutorial ;)
07:09:10 <pk> thx
07:09:27 <CTA> haha lol
07:09:43 <CTA> just most of them just go on about GHCi not making the actual code
07:10:23 <Axman6> pk: then you can use diffUTCTime t2 t1 to get the time between t1 and t2 (the order confuses me :\)
07:10:28 <ozy`> CTA: you can do "let (vars) in (expr)" to get local variables... only they're not really variable.
07:10:41 <ozy`> > let (+) = (-) in 1 + 2 + 3
07:10:42 <lambdabot>   -4
07:10:47 <pk> Axman, thx alot
07:10:52 <pk> i'll try
07:10:53 <dancor> it's like t2 `diffUTCTime` t1
07:11:07 <Axman6> CTA: taking a tutorial will show you how code is usually written in haskell, so you won't be trying to do things you'd be doing in imperative languages
07:11:14 <dancor> infix stuff is always backwards
07:11:24 <dancor> it's a bit of weakness
07:11:29 <Axman6> ah, t2 - t1 basically
07:11:43 <dancor> you have to kind of memorize the funcs that are intended to be infix
07:11:51 <Axman6> yeah :\
07:12:31 <CTA> Is there any good vid tuts?
07:13:03 <Axman6> you need more patience my son ;)
07:13:20 <CTA> eh hows that
07:13:22 <Axman6> @where lyah
07:13:22 <lambdabot> www.learnyouahaskell.com
07:13:31 <skorpan> for great good!
07:13:40 <Axman6> go forth and learn from!
07:14:06 <CTA> I don't like reading loads via pc lol
07:14:19 <Cheshire> me neither
07:14:23 <skorpan> i love the layout of lyah
07:14:32 <skorpan> makes me feel like having some chunky bacon
07:14:39 <Axman6> CTA: well, there's quite a bit of reading to get a lot out of haskell (i'm dyslexic, so it can be ahrd at times, but it's well worth it)
07:14:44 <Cheshire> 2.3 Cayenne
07:14:44 <Cheshire> Cayenne is influenced also by constructive type theory (see its page).
07:14:48 <Cheshire> Depandent types make it useful also as a theorem prover.
07:14:52 <dancor> it's like the vaguely racist tutorial i never had
07:14:58 <Cheshire> but everything is true in Cayenne isn't it ?
07:15:08 <Cheshire> why is this "theorem proving"?
07:15:10 <Axman6> @remember skorpan i love the layout of lyah. makes me feel like having some chunky bacon.
07:15:10 <lambdabot> Done.
07:15:15 <Axman6> @quote lyah
07:15:15 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
07:15:17 <Axman6> @quote lyah
07:15:17 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
07:15:31 <dancor> dependent types are surprisingly related to proving everything..
07:15:47 <dancor> it turns out
07:15:54 <drhodes> @hoogle (Data.ByteString -> Int)
07:15:54 <lambdabot> Parse error:
07:15:54 <lambdabot>   --count=20 "(Data.ByteString -> Int)"
07:15:54 <lambdabot>                   ^
07:16:14 <CTA> moo
07:16:22 <drhodes> @hoogle ByteString -> Int
07:16:22 <lambdabot> Data.ByteString length :: ByteString -> Int
07:16:22 <lambdabot> Data.ByteString.Char8 length :: ByteString -> Int
07:16:22 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
07:17:08 <CTA> is it "easy" to play music files via haskell rather than c++ etc?
07:17:19 <Axman6> probably not
07:17:24 <Cheshire> CTA, yes
07:17:59 <Axman6> CTA: quit thinking about writing games in haskell (for now at least). like all languages, you can't just start out writing games, you have to learn how the language works
07:18:13 <Cheshire> Axman6, you can definitely just start out by writing games
07:18:20 <drhodes> pygame makes it pretty easy
07:18:28 <ozy`> start out by writing text adventure games
07:18:29 <CTA> so i could: output saying press 1 to blah 2 to blah, blah = play file then have if
07:18:34 <Cheshire> drhodes, you don't use pygame to write a game in haskell
07:18:39 <CTA> else ladder? / switch if it has one?
07:18:52 <ozy`> CTA: what the...
07:18:54 <drhodes> Cheshire: I don't?
07:18:58 <Axman6> o.O
07:19:08 <Cheshire> drhodes, One does not use pygame to write a game in haskell
07:19:12 <Axman6> CTA: wanna try that again?
07:19:29 <ozy`> CTA: my wernicke's area just threw a "parse error" exception trying to read that
07:19:34 <Axman6> drhodes: if you do, i'd like to know how :)
07:20:30 <CTA> rephrase, i could output saying "press 1 to play dance.mp3, 2 to play.. 5.." and then get some input, then depending on their input play a song?
07:20:39 <ozy`> CTA: of course
07:20:45 <Cheshire> CTA, this is a completely trivial programming problem
07:21:04 <Axman6> anyone have any comments on http://tinyurl.com/dnjt2m for me? i'm about to update the package again, and i was wondering if the docs were lacking in any way.
07:21:14 <Cheshire> CTA, you can do all sorts of stuff in Haskell the best way to see what's possible is to start programming
07:21:27 <CTA> haha lol yeah
07:21:33 <CTA> i will some time lol..
07:21:36 <daf> CTA: "switch" in Haskell is called "case"
07:21:38 <CTA> i gtg soon
07:21:41 <Cheshire> ok
07:21:44 <Cheshire> until them bye
07:21:48 <Cheshire> then*
07:21:51 <quicksilver> Axman6: a comparison with TVars would be useful
07:21:57 <CTA> kk in c* its like switch (var) case: ..
07:22:00 <quicksilver> Axman6: to explain when you'd want AVars
07:22:24 <Axman6> CTA: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:sound shows there's 36 sound packages you could use too ;)
07:22:29 <daf> CTA: in Haskell it's like "case var of; 1 -> ..."
07:22:39 <C-Keen>  
07:22:52 <Olathe> > let f n = case n of 1 -> "zomg"; 2 -> "kthx"; otherwise -> "hello" in f 1
07:22:53 <rwbarton> CTA: But really, just read LYAH :)
07:22:53 <lambdabot>   "zomg"
07:23:01 <ski_> (Axman6 : i don't see any `putAVar' ..)
07:23:36 <Axman6> quicksilver: hmm, good idea, though i'm not at all sure where they might be useful, they're just interesting to me, and i thought others might find uses for them :)
07:23:46 <Axman6> ski_: huh... maybe i forgot to export that, ha
07:23:51 <CTA> OpenGL = graphics library AL = audio?
07:24:11 <Axman6> ski_: yep, indeed i forgot to export it -_-
07:25:08 <gwern> my god! a JHC patch!
07:25:15 <gwern> this is the first in like a year
07:26:11 <ski_> Axman6 : you could try implementing transactions on an `AVar' .. and then on several `AVar's ..
07:26:34 <Axman6> ski_: i could, but... it doesn't sound at all fun :(
07:26:50 <CTA> 'elem' does it have to have quotes around it?
07:27:09 <doserj> > elem 3 [1..10]
07:27:10 <lambdabot>   True
07:27:17 <quicksilver> CTA: the `` quotes are to use it infix.
07:27:17 <doserj> > 3 `elem`[1..10]
07:27:18 <ski_> > 3 `elem` [1..10]
07:27:18 <lambdabot>   True
07:27:19 <lambdabot>   True
07:27:32 <Axman6> not really trying to have a fully transactional system though.
07:27:58 <ski_> (and then nestable transactions .. also distributed transactions ..)
07:28:15 <doserj> CTA: and it has nothing to do with elem specifically
07:28:29 <ski_> > divMod 100 7
07:28:30 <lambdabot>   (14,2)
07:28:35 <ski_> > 100 `divMod` 7
07:28:36 <lambdabot>   (14,2)
07:29:18 <ski_> > let barf x s = show x ++ ' ' : s in 42 `barf` "bottles"
07:29:20 <lambdabot>   "42 bottles"
07:29:21 <Axman6> ski_: i thought of one way of doing that sort of thing using more MVars, and waiting until all syncronised variables were ready to perform the action, but i can see it getting messy
07:30:43 <Axman6> CTA: functions that take two arguments (generally) can have `'s put around them, to form a sort of ad hoc operator, just like +, *, / etc.
07:31:22 <Axman6> also, sticking brackets around an infix operator makes it act like a normal function (because, they are infact re normal functions. ther's nothing special about + or *)
07:31:25 <rwbarton> Axman6: you wrote "quaranteed"
07:31:47 <Axman6> ha, so i did, thanks
07:36:20 <lilac> > let 1 = 3; (+) = (-); 4 = 6 in 1 + 4
07:36:22 <lambdabot>   -3
07:36:32 <Axman6> oh god!
07:36:49 <Axman6> you just broke the intergalatic language of maths!
07:36:54 <lilac> hehe :)
07:37:39 <ziman> > let 1 = 42; (+) = (-); 4 = 6 in 1 + 4
07:37:40 <lambdabot>   -3
07:37:41 <drdozer> wow, I didn't realise you could rebind those symbols to new constants!
07:37:49 <lilac> you can only rebind (+)
07:37:56 <lilac> i chose my example carefully ;-)
07:38:00 <ziman> :)
07:38:08 <drdozer> are you not rebinding the constant 1?
07:38:11 <Elly> there's no way that - yeah
07:38:18 <lilac> drdozer: nope
07:38:27 <quicksilver> > let 1 = "try it yourself" in 1
07:38:28 <lambdabot>       No instance for (Num [Char])
07:38:28 <lambdabot>        arising from the literal `1' at <in...
07:38:40 <ziman> why is that construction legal; how does it parse?
07:38:44 <drdozer> > let 1 = 20 in 1
07:38:45 <lilac> > let 1 = 1 + 1 in 1
07:38:45 <lambdabot>   1
07:38:46 <lambdabot>   1
07:39:07 <quicksilver> it's a very bizaree edge case of the numeric pattern desugaring
07:39:11 <lilac> > let (1, a) = (1+1, 2) in a
07:39:13 <lambdabot>   * Exception: /tmp/2961053681035186554:71:52-68: Irrefutable pattern failed ...
07:39:38 <quicksilver> I think it desugars to let x | x == fromInteger 1 = 20 in ... something that doens't mention x ...
07:39:51 <drdozer> why is the let syntax allowing digits to appear as identifiers?
07:40:03 <lilac> drdozer: it's not. it's allowing them to appear as patterns
07:40:08 <ski_> > let (x,1) = (2,3) in x
07:40:10 <lambdabot>   * Exception: /tmp/5920811987915328464:71:48-60: Irrefutable pattern failed ...
07:40:16 <lilac> if digits couldn't appear as patterns, then 'case x of 1 -> ...' couldn't work
07:40:17 <ziman> but there's no x mentioned in the definition, does ghc make up an identifier for the function being defined?
07:40:36 <ski_> `1 = 3' succeeded only because there were no variables in the pattern what were forced later
07:40:40 <ski_> > let (x,1) = (2,3) in 18
07:40:41 <lambdabot>   18
07:40:41 <lilac> of course, you /could/ have different pattern syntax for case versus let, but...
07:40:54 <drdozer> ah, so let 1 = 20 is a binding that both fails, and also happens not to have a variable that's getting a value bound?
07:41:33 <drdozer> >let (x,1) = (2,3) in x
07:42:14 <drdozer> > let (x,1) = (2,3) in x
07:42:15 <lambdabot>   * Exception: /tmp/7684614963801622084:71:48-60: Irrefutable pattern failed ...
07:42:19 <drdozer> kk, I get it now :D
07:42:46 <hackage> Uploaded to hackage: husky 0.1
07:42:46 <hackage> Uploaded to hackage: pqueue-mtl 1.0.5
07:42:55 <drdozer> and this is because 1, 2, ... are (polymorphic) constructors rather than values?
07:43:14 <ski_> no
07:43:21 <ski_> > let (x,True) = (2,False) in 18
07:43:22 <lambdabot>   18
07:43:22 <ski_> > let (x,True) = (2,False) in x
07:43:24 <lambdabot>   * Exception: /tmp/9037538706061664295:71:40-59: Irrefutable pattern failed ...
07:43:32 <ski_> > let True = False in 3
07:43:33 <lambdabot>   3
07:43:39 <drdozer> sure, but True/False are constructors
07:43:51 <ski_> but not *polymorphic* ones
07:43:58 <drdozer> no, but 1 is
07:44:05 <ski_> also, consttructors are also values
07:44:09 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1446#a1446 Is something like this possible?
07:44:33 <ziman> so "1 = 4" is a failed pattern match where nothing gets bound?
07:44:37 <drdozer> let (x, "henry") = ("george", "henry") in x
07:44:52 <ski_> ziman : it doesn't actually fail, since there's nothing that forces it
07:44:57 <drdozer> > let (x, "henry") = ("george", "henry") in x
07:44:59 <lambdabot>   "george"
07:45:02 <ziman> i see.
07:45:39 <drdozer> let (x, "jane") = ("george", "henry") in x
07:46:29 <quicksilver> cnwdup: I don't understand your question.
07:46:36 <cnwdup> Oh, nevermind. I've mistaken fromDyn's type signature. Now the type error I'm getting makes sence. (:
07:46:44 <drdozer> and that works as expected because "george" is shorthand for 'g':'e':'o':'r':'g':'e':[]?
07:46:46 <quicksilver> cnwdup: fromDyn is an overloaded function, it needs to "know" what type to cast to.
07:46:56 <cnwdup> I thought fromDyn was fromJust . fromDynamic or something like that.
07:47:48 <ski_> @hoogle (forall a. Typeable a => a -> b) -> Dynamic -> b
07:47:48 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:47:48 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:47:48 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:47:51 <ski_> bah
07:47:56 <quicksilver> and my comments apply equaly to fromDynamic, cnwdup ;)
07:48:09 <quicksilver> fromDynamic is also an overloaded function which needs to know what type to cast to.
07:48:18 <cnwdup> quicksilver, it would work if func was of type Int -> Int, right?
07:48:22 <quicksilver> and by 'needs to know' I meant it needs to know statically - at compile time.
07:48:34 <quicksilver> cnwdup: Yes. And give a runtime error if the thing wasn't an Int.
07:48:43 <cnwdup> quicksilver, ok. Thanks what I want. Thanks. (:
07:49:01 <cnwdup> @src dynApply
07:49:01 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:50:21 <temoto> How to ask bot for function description?
07:50:39 <cnwdup> s/Thanks/That's/
07:52:07 <ski_> would `(forall a. Typeable a => a -> b) -> Dynamic -> b' be useful ?
07:52:27 <ski_> (cnwdup : <http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/Data-Dynamic.html>)
07:52:39 <cnwdup> ski_, thank you.
07:52:59 <ski_> also
07:53:05 <ski_> @source Data.Dynamic
07:53:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/Dynamic.hs
07:53:28 <temoto> @source ($)
07:53:28 <lambdabot> ($) not available
07:53:36 <ski_> @index ($)
07:53:36 <lambdabot> Prelude
07:53:43 <ski_> @source Prelude
07:53:43 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
07:53:49 <temoto> what is operator dollar? :)
07:53:56 <ski_> @. source index ($)
07:53:56 <lambdabot>  not available
07:53:59 <temoto> How to ask bot for description?
07:54:00 <Zao> @src ($)
07:54:00 <lambdabot> f $ x = f x
07:54:13 <temoto> omg
07:54:27 <temoto> What is it for?
07:54:45 <Zao> It's function application but with a different precedence.
07:54:58 <ski_> foo x $ bar y z $ baz a b  =  foo x (bar y z (baz a b))
07:55:10 <temoto> oh
07:55:24 <ski_> you can also write
07:55:41 <ski_> f . g . h . i $ x
07:55:43 <ski_> instead of
07:55:48 <ski_> f $ g $ h $ i $ x
07:55:55 <temoto> hm it's like parenthesis in python
07:56:47 <ski_> (some argue that `$' ought to associate the other way, so that you would use the `f . g . h . i $ x'
07:56:53 <gwern> it's syntactic sugar, not required
07:57:01 <gwern> ski_: shh! you'll wake Cale!
07:57:06 <ski_>  and `f $ g $ h $ i $ x' would then be `(f) (g) (h) (i) (x)'
07:57:07 <ski_> )
07:57:34 <ski_> (gwern : i often include myself in that "some" ..)
07:57:46 <temoto> wait a minute, how   foo x (bar y z)   is different from   foo x bar y z ?
07:57:50 <ski_> yes
07:57:51 <gwern> ski_: bah, you're just a deep one to his great old one
07:58:03 <gwern> (if you follow)
07:58:05 <ski_> `foo x bar y z' is `(((foo x) bar) y) z'
07:58:18 <temoto> ah sure, my fault
07:58:39 <ski_> (gwern : not really .. have you visited Innsmouth recently ?)
07:59:15 <temoto> Well, you know in python decorators are serve like this $.
07:59:17 <gwern> ski_: I had a lovely cassis in a cafe in Miskatonic recently, but no
08:00:06 <ski_> one argument for left-associative `$' is that it would be nice if `$!' was left-associative, and then the former should possibly also be, for consistency
08:00:20 <temoto> (i was hoping someone knowing python would support or argue that compare)
08:00:28 <ski_> @src foldl'
08:00:29 <lambdabot> foldl' f a []     = a
08:00:29 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:00:40 <Cheshire> @w80 illative
08:00:41 <lambdabot> *** "illative" wn "WordNet (r) 2.0"
08:00:41 <lambdabot> illative
08:00:41 <lambdabot>      adj 1: relating to or having the nature of illation or inference;
08:00:41 <lambdabot>             "the illative faculty of the mind" [syn: {inferential}]
08:00:41 <lambdabot>      2: resembling or dependent on or arrived at by inference; "an
08:00:43 <lambdabot> [3 @more lines]
08:00:44 <ski_> the recursive case can be written
08:00:56 <gwern> Cheshire: hm, a good word of the day for me!
08:01:14 <ski_>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
08:01:24 <ski_> it would be nice if it could be written as
08:01:32 <ski_>   foldl' f a (x:xs) = foldl' f $! f a x $ xs
08:01:46 <guenni> hi is there an sql parser?
08:01:54 <daf> there is
08:02:05 <guenni> daf: cool
08:02:26 <guenni> daf: some more details pls :)
08:02:43 <daf> guenni: PostgreSQL has one, MySQL has one, there are lots!
08:03:13 <guenni> um, I meant one written in parsec
08:03:54 <fasta> And they all parse a different language ;)
08:04:14 <daf> indeed
08:04:24 <daf> guenni: it seems like a strange thing to need
08:05:16 <guenni> well I using literal sql statements in my code, together they fit on a wallpaper
08:05:31 <guenni> daf: so I'd like to do something about that
08:06:02 <guenni> agentzh: ping
08:06:03 <daf> guenni: I don't understand
08:06:43 <guenni> daf: kind of "normalize" the statements or turn them into something intermediate
08:06:56 <LeoD> liftM (putStrLn . show) (parseYamlFile "config.yaml") -- is there a better way to do this? it has type IO (IO ()), which seems weird to me
08:07:10 <Feuerbach> LeoD: use join
08:07:19 <gwern> isn't 'print' == putStrLn.show?
08:07:32 <Apocalisp> @src print
08:07:32 <lambdabot> print x = putStrLn (show x)
08:07:33 <Cheshire> gwern, yes
08:07:39 <daf> LeoD: you don't need to lift in this case
08:07:56 <daf> LeoD: putStrLn . show $ ... would work
08:08:07 <daf> LeoD: or print ... as guenni mentioned
08:08:10 <daf> er gwern
08:08:22 <LeoD> ah, show accepts IO a?
08:08:22 <temoto> @src listM
08:08:23 <lambdabot> Source not found. Do you think like you type?
08:08:27 <daf> LeoD: no
08:08:28 <Feuerbach> parseYamlFile "config.yaml" >>= putStrLn . show
08:08:36 <temoto> @src liftM
08:08:36 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:08:51 <temoto> do :(
08:08:53 <daf> LeoD: oh, sorry, I was confused
08:09:12 <daf> :t putStrLn . show
08:09:13 <lambdabot> forall a. (Show a) => a -> IO ()
08:09:14 <Axman6> LeoD: parseYamlFile "config.yaml" >>= print
08:09:15 <temoto> Could i have explanation what liftM does?
08:09:24 <cnwdup> @src liftM
08:09:24 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:09:26 <Axman6> @src liftM
08:09:26 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:09:29 <Axman6> bah
08:09:31 <LeoD> ok, thanks guys :)
08:09:44 <daf> :t liftM
08:09:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:09:53 <temoto> i mean explanation to guy who doesnt know haskell.
08:09:54 <daf> temoto: it "lifts" a function into a monad
08:09:57 <cnwdup> temoto, it unwraps a monadic value, applys the function to it and wraps it back.
08:10:33 <temoto> oh well... when should one use it?
08:10:47 <cnwdup> If you want to apply a function to a monadic value. q:
08:10:49 <Axman6> temoto: if x :: IO Integer, then liftM even x would be :: IO Bool
08:11:40 <cnwdup> temoto, if you've got IO 12 and you want to add 5, you can do: liftM (+5) (return 12). It's just something that saves you from manual unwrapping and wrapping.
08:12:06 <temoto> Axman6: that seems understandable
08:12:11 <temoto> cnwdup: thank you
08:12:38 <Axman6> temoto: or x :: Maybe Integer, liftM even x :: Maybe Bool
08:12:52 <temoto> that sounds crazy :)
08:13:01 <Axman6> why?
08:13:09 <temoto> What is Maybe? :)
08:13:14 <Axman6> oh, heh
08:13:16 <Cheshire> @src Maybe
08:13:16 <Zao> A rather friendly type.
08:13:16 <lambdabot> data Maybe a = Nothing | Just a
08:13:17 <Axman6> @src Maybe
08:13:17 <lambdabot> data Maybe a = Nothing | Just a
08:13:22 <Axman6> beaten again!
08:13:34 <Zao> A nullable value, kind of.
08:13:39 <Axman6> temoto: Maybe is either Nothing, or Just a result
08:13:42 <temoto> It's like any python variable could be it's type or None?
08:14:01 <Elly> except in haskell it has to be explicitly declared to be Maybe :P
08:14:09 <Elly> whereas in python everything is implicitly a Maybe
08:14:12 <Zao> @type [Just 42, Nothing, Just 3]
08:14:13 <lambdabot> forall t. (Num t) => [Maybe t]
08:14:18 <temoto> Great.
08:14:33 <temoto> Why not making everything explicitly Maybe in Haskell?
08:14:40 <Axman6> useful for things like findIndex, which takes a list and an item, and either returns Just (the index of the item) or nothing if it's not found in the list
08:14:42 <Zao> Because not everything has to.
08:14:58 <Axman6> Nothing*
08:15:04 <Elly> because you like to not have to write cases for Nothing everywhere
08:15:19 <paper_cc> > head [1,2,3]
08:15:20 <lambdabot>   1
08:15:23 <paper_cc> > head []
08:15:25 <lambdabot>   * Exception: Prelude.head: empty list
08:15:35 <temoto> oh sure, cases
08:15:38 <Axman6> i do wish the prelude used Maybe more often :\
08:15:42 <ertai> I'm (still) wondering why the directory-1.0.0.2 package is not on hackage?
08:16:06 <temoto> you know in python [][0] is an error too
08:16:14 <temoto> i see logic here
08:16:28 <Feuerbach> Often you know for sure that list isn't empty. Where you don't, just check
08:17:01 <temoto> Ok, so Maybe is Monad too, right?
08:17:05 <Axman6> still, writing if null xs then [] else tail xs is a bit of a pain
08:17:05 <ferret_0567> I have an idea for something I want to make in Haskell. I want to make a shoutcast radio station browser.
08:17:12 <Axman6> temoto: yep
08:17:30 <ferret_0567> Axman6: use pattern matching
08:17:39 <rwbarton> Axman6: drop 1
08:17:50 <Axman6> rwbarton: heh, right
08:18:03 <temoto> uh.. how does it change nature of Maybe type... compared to it was declared like simple   data Maybe a = Nothing | Just a  ?
08:18:23 <temoto> it was declared like that...
08:18:27 <paper_cc> temoto: it's actually declared so ... no changes here
08:18:28 <Axman6> @src Maybe Monad
08:18:28 <lambdabot> Source not found. My pet ferret can type better than you!
08:18:31 <temoto> what makes it monade?
08:18:33 <ozy`> temoto: the declaration doesn't change
08:18:34 <Axman6> @src Maybe (>>=)
08:18:34 <lambdabot> (Just x) >>= k      = k x
08:18:34 <lambdabot> Nothing  >>= _      = Nothing
08:18:40 <Axman6> @src Maybe return
08:18:40 <lambdabot> return              = Just
08:18:44 <ozy`> temoto: Monad is a typeclass, not a type
08:18:55 <paper_cc> temoto: an instance declaration for Monad makes it a Monad
08:19:01 <ozy`> if a type is a Monad, that just means you can use monadic functions on it
08:19:04 <temoto> Aha. It's a class.
08:19:06 * ferret_0567 wishes perl would just die
08:19:16 <ferret_0567> a stupid linguist designed it]
08:19:29 <ozy`> ferret_0567: the more often I hear that the more interesting perl looks
08:19:37 <ozy`> I never explored its possibilities
08:19:47 <olidu> a question about multi-threading: I ran a program on an 8-core machine,  I found N7 runs the fastest and N8 the slowest; on a dual-core,  N1 is much faster than N2. Is it normal? ( #Core -1 is the optimal? )
08:19:48 <ozy`> also, what's wrong with linguists?
08:19:48 <paper_cc> ferret_0567: be careful. there are people here that say that regexes are readable
08:19:50 <temoto> ferret_0567: i'm with you. Python would've been much better at perl's role all-stuff-scripting-language.
08:20:04 <ferret_0567> ozy`: it's not that great, I don't think. Granted, I've never tried programming in it...
08:20:11 <asgaroth> perl was designed? Didn't it rather evolve from thousands of sysadmins extending it in random directions? *scnr*
08:20:36 <ferret_0567> paper_cc: regexes are somewhat readable
08:20:38 <fasta> asgaroth: you could say the same thing about Haskell.
08:20:43 <Cheshire> go to #perl-haters
08:20:49 <temoto> Monade is a type class... so is it like generic type class or is there something special compiler-level for it?
08:21:07 <paper_cc> , src ''Monad
08:21:13 <lunabot>  class Monad m where
08:21:13 <lunabot>          (>>=) :: forall b a . m a -> (a -> m b) -> m b
08:21:13 <lunabot>          (>>) :: forall b a . m a -> m b -> m b
08:21:22 <paper_cc> temoto: only the do-notation
08:21:29 <Axman6> perl play(ed|s) a quite important roll in ghc (though not for long luckily. things named the evil mangler need to die)
08:21:30 <byorgey> temoto: the only special compiler support is the do-notation, which desugars to Monad operations.
08:21:45 <ozy`> Axman6: isn't it still a build dependency?
08:21:50 <Axman6> probably
08:21:51 * paper_cc looks at the lunabot definiton for Monad ... o_O
08:22:57 <ozy`> temoto: any time you write a do block in haskell, the compiler turns it into a series of (>>) and (>>=) applications (with a few other changes I won't get into).
08:23:04 <osfameron> ozy`: there are some interesting articles/talks about the role of linguistics in Perl's design.  Though it's also true that grabbing bits from other languages at random may have played a *little* bit of a part too :-)
08:23:16 <ozy`> temoto: lambdabot has an @undo command to help see how it gets taken apart
08:23:29 <paper_cc> @undo do { x:xs <- getArgs; putStrLn x; }
08:23:30 <lambdabot> getArgs >>= \ a -> case a of { x : xs -> putStrLn x; _ -> fail ""}
08:23:41 <ozy`> osfameron: that's easily the most pointless and least interesting part of perl :p
08:23:56 <guenni> mmorrow: ping
08:24:11 <temoto> How is special in Maybe being monade compared it not to be monade instance?
08:24:28 <temoto> What is special*
08:24:33 <Axman6> well, you can use do notation
08:24:35 <lilac> paper_cc: lunabot has a 3-line limit in this channel, privmsg gives the full source
08:24:59 <temoto> aha so you make type a monade instance to use do-notation on that type?
08:25:03 <ozy`> temoto: RWH has a really nice demonstration of exactly what that gets you
08:25:14 <doserj> temoto: it's called Monad, not Monade
08:25:24 <temoto> ozy`: i didn't buy that book yet.
08:25:29 <lilac> wasn't perl a language defined by someone saying "what would happen if we tried to make a language which was a superset of sed, awk and C?"
08:25:41 <ozy`> temoto: that's okay, you can read the chapter here: http://book.realworldhaskell.org/read/monads.html
08:26:01 <Axman6> temoto: it;s just monad by the way, no e :)
08:26:05 <ozy`> lilac: pretty much, yeah. (shell scripts, too.)
08:26:18 <temoto> doserj: i thought someone used monade and it's right spelling, will know then, thanks.
08:26:20 <Axman6> ah dang, beaten by doserj
08:26:21 <osfameron> well yes, but also Ada and SNOBOL
08:26:29 <Itkovian> When trying to install a ghc binary tarball (vanilla linux) I get the utils/pwd/pwd to throw a floating point exception. Any idea what glibc version is required for 6.4+ ghc version, or, conversely, what ghc will work with glibc 2.3.4? I can try them all, of course, but I'd rather not.
08:26:52 <osfameron> (this kind of magpie thing is why Perl has real lambdas, while Python for example still doesn't)
08:27:00 <osfameron> er, s/lambda/closure/
08:27:14 <lilac> temoto: do you understand typeclasses? you need to understand them before you can reasonably hope to understand monads in haskell
08:27:19 <temoto> osfameron: def is python syntax for closures, i've heard that once.
08:27:45 <Axman6> ok, sleep time. night all
08:28:25 <ozy`> temoto: python closures are significantly crippled compared to other languages, even where it does support them. on the upside, it's possible to work around this with (unfortunately not very intuitive) macro-ish stuff
08:28:26 <temoto> lilac: obviously i can't really tell, if i understand type classes. But i can take some tests and i guess i understand what people say about type classes here.
08:28:32 <osfameron> temoto: yeah, tbh I don't know python that well.  I believe the scoping is slightly surprising, or the closed over values are readonly for example ?
08:28:55 <osfameron> http://perl.plover.com/classes/fp/samples/slide016.html # "Closures aren't important" - Guido van Rossum
08:29:07 <temoto> osfameron: you can not overwrite outer variable, yes.
08:29:29 <temoto> ozy`: thanks for link.
08:29:37 <lilac> osfameron, temoto: i believe python 3 allows 'nonlocal x'
08:29:38 <osfameron> of course python has nice tricks like generators which obviate a lot of the need for that in Perl, meh...
08:29:44 <lilac> (which allows overwriting outer variables)
08:30:00 * whpearson would like feedback on a variant of the monoid class on his blog http://vrrm.wordpress.com/2009/02/18/haskell-vmonoids/
08:30:02 <temoto> lilac: it does, but they keep telling python3 is not ready yet.
08:30:03 <lilac> nonlocal is the keyword which global should always have been
08:30:10 <ozy`> python should really be more like scheme..... hmmmm
08:30:13 * paper_cc looks at a link pointing to a "perl" site inside a "fp" directory made by GvR... oh
08:30:28 <lilac> temoto: who says that these days? python3.0.1 is out...
08:31:02 <temoto> lilac: python3.0 is like proof of concept or developer release. Stable production version will be 3.1
08:31:15 <temoto> python3.0 is 30% slower than 2.x
08:31:32 <lilac> *shrug* they broke enough stuff in python3 that i'm sticking to python2 for the foreseeable future anyway
08:32:01 <temoto> lilac: well lots of changes are for good really. In example, strings is my favourity.
08:32:03 <Itkovian> 6.4.2 seems to install on glibc 2.3.4
08:32:06 <temoto> favourite*
08:32:20 <lilac> temoto: yeah, they're not bad changes, but they're incompatible with my mind at the moment :)
08:32:35 <temoto> just like monads with my atm :)
08:33:02 <paper_cc> @where ychim
08:33:02 <lambdabot> I know nothing about ychim.
08:33:20 <paper_cc> @google "You could have invented monads"
08:33:21 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:33:21 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
08:34:09 <paper_cc> temoto: ^^ that is a _very_ good thing to read if you understand the basic semantics (basic syntax, type system etc)
08:35:40 <whpearson> Does anyone know of any DSLs for debugging code written in haskell?
08:36:14 <whpearson> Err, that is the the DSL written in haskell not the code....
08:36:37 <osfameron> DSL for debugging?
08:38:31 <whpearson> osfameron, so you can script debugging processes, e.g. running to certain points, sniffing memory.
08:39:15 <osfameron> wouldn't you first need a debugger that happens to expose those hooks?
08:39:33 <osfameron> or do you mean that the debugger is turned inside out so that it /is/ represented by the DSL ?
08:39:38 <osfameron> <-- confused
08:40:06 <whpearson> The second is the way I am thinking of going.
08:41:08 <ozy`> @pl \f x -> concat (map f x)
08:41:08 <lambdabot> (=<<)
08:41:12 <ozy`> bah
08:41:19 <osfameron> hmm, in fact it's more that tht /interpreter/ is turned inside out?  so that the debugger is basically the DSL for running the interpreter ?
08:41:20 <whpearson> I found one recently for a variety of languages, but I've lost it.
08:42:18 <ozy`> @pl \c m f x -> c (m f x)
08:42:18 <lambdabot> (.) . (.)
08:42:20 <whpearson> Yeah, something like that.
08:42:50 <rwbarton> @pl \f x -> concat' (map' f x)
08:42:50 <lambdabot> (concat' .) . map'
08:42:57 <ozy`> ahahahaha
08:43:03 <ozy`> rwbarton: thanks :p
08:43:19 <rwbarton> ozy`: handy trick for when @pl goes overboard :)
08:43:21 <temoto> paper_cc: thank you, i was reading RWH.
08:44:18 <temoto> It seems to now that monads are something to bind some state to some name. Which is what variables in all languages are.
08:44:53 <temoto> And my ghci doesn't know liftM function. Where is it?
08:45:05 <Feuerbach> Control.Monad
08:45:09 <drdozer> try importing Control.Monad
08:45:17 <drdozer> :m +Control.Monad
08:46:04 <ozy`> > liftM (* 5) (Just 10)
08:46:05 <lambdabot>   Just 50
08:46:10 <ozy`> > liftM (* 5) (Nothing)
08:46:11 <lambdabot>   Nothing
08:46:21 <earthy> > fmap (* 5) (Just 10)
08:46:23 <lambdabot>   Just 50
08:46:57 <temoto> ozy`: i just tried it, great.
08:47:19 <temoto> liftM length (return "foo")   got me 3, it is just great.
08:47:39 <lilac> > Just 10 <^(*5)
08:47:40 <lambdabot>   Not in scope: `<^'
08:47:41 <Feuerbach> temoto: it's (return 3)
08:47:50 <temoto> > let s = return "foo"
08:47:50 <lambdabot>   <no location info>: parse error on input `;'
08:47:57 <Feuerbach> or it's Identity monad
08:47:59 <temoto> What am i doing wrong?
08:48:10 <temoto> > let s = (return "foo")
08:48:11 <lambdabot>   <no location info>: parse error on input `;'
08:48:15 <Feuerbach> :t length (return "foo")
08:48:16 <lambdabot> Int
08:48:27 <Feuerbach> :t liftM length (return "foo")
08:48:28 <lambdabot> forall (m :: * -> *). (Monad m) => m Int
08:48:32 <ozy`> :t flip liftM (return "foo")
08:48:33 <lambdabot> forall r (m :: * -> *). (Monad m) => ([Char] -> r) -> m r
08:48:35 <ozy`> heh
08:48:36 <lilac> @let (<^) = flip fmap; (^>) = ap
08:48:37 <lambdabot>  Defined.
08:48:44 <redditbot> Dependent types are ridiculously easy
08:48:44 <redditbot> Share your haskell experience
08:48:45 <lilac> > Just 10 <^(* 5)
08:48:46 <lambdabot>   Just 50
08:48:59 <paper_cc> temoto: a stale "let" without "in" is valid only in a do-block
08:49:10 <lilac> > Just 10 <^(*)^> Just 5
08:49:11 <lambdabot>   Just 50
08:49:27 <temoto> paper_cc: my ghci takes let, it shows error about type.
08:50:06 <lilac> temoto: ghci's prompt is basically like a do block
08:50:11 <LeoD> say i have 'data Foo = Foo (Bool -> Bool)', is there any way to make deriving (Show) work on a type like this?
08:50:14 <paper_cc> temoto: well, it's also valid in GHCi (but not in source files) and is equivalent to "let foo = bar in <the rest of the session>"
08:50:15 <temoto> oh
08:50:22 <Feuerbach> paper_cc: no
08:50:31 <Cheshire> LeoD, no
08:50:33 <temoto> lilac: thanks.
08:50:39 <Cheshire> LeoD, you can't derive show for anything with an arrow in it
08:50:39 <LeoD> ok
08:50:44 <lilac> LeoD: no. but there are other deriving-like mechanisms which might help
08:50:48 <paper_cc> Feuerbach: err... why?
08:50:52 <Feuerbach> paper_cc: or, maybe, there's show somewhere in Data.Function
08:50:53 <temoto> > do let s = return "foo"
08:50:54 <lambdabot>   <no location info>:
08:50:54 <lambdabot>      The last statement in a 'do' construct must be an ...
08:50:57 <lilac> @where DriFT
08:50:57 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
08:51:01 <Feuerbach> because functions are not observable
08:51:03 <lilac> @where Data.Derive
08:51:04 <lambdabot> I know nothing about data.derive.
08:51:12 <Cheshire> well Bool -> Bool can be shown
08:51:12 <temoto> must be an what?..
08:51:16 <Cheshire> but not automatically
08:51:54 <doserj> well Int -> Int could be shown. But you don't want that...
08:52:08 <Cheshire> doserj, I don't think you could show Int -> Int
08:52:23 <Cheshire> not in any finite and transparent way at least
08:52:31 <doserj> Int is as bounded as Bool
08:52:41 <quicksilver> Cheshire: you can't show [1..] in a finite way
08:52:45 <Cheshire> oh true
08:52:48 <quicksilver> Cheshire: and that doesn't stop us having a show method :)
08:52:52 <Cheshire> I was thinking Integer for some reason
08:52:59 <temoto> > do let s = return "foo"
08:53:00 <lambdabot>   <no location info>:
08:53:00 <lambdabot>      The last statement in a 'do' construct must be an ...
08:53:05 <temoto> must be what?
08:53:13 <paper_cc> temoto: an expression
08:53:31 <paper_cc> > do { let s = return "foo"; s }
08:53:32 <lambdabot>   <no location info>: parse error on input `}'
08:53:35 <lilac> > do let s = return "foo" in s :: Maybe String
08:53:36 <paper_cc> grr
08:53:36 <lambdabot>   Just "foo"
08:53:42 <cypher-> is there any good tutorial on floating point computation with haskell?
08:53:50 <lilac> > do let {s = return "foo"}; s :: Maybe String
08:53:51 <lambdabot>   Just "foo"
08:54:09 <paper_cc> > do { let { s = return "foo"}; s; } :: Maybe String
08:54:10 <lambdabot>   Just "foo"
08:54:11 <ozy`> paper_cc: you need the inner braces >_>
08:54:20 * paper_cc loves alignment
08:54:25 <temoto> > do let { s = return "foo" }
08:54:26 <lambdabot>   <no location info>:
08:54:26 <lambdabot>      The last statement in a 'do' construct must be an ...
08:54:34 <temoto> > do let { s = return "foo" }; s
08:54:35 <lambdabot>       No instance for (Show (m [Char]))
08:54:35 <lambdabot>        arising from a use of `show' a...
08:54:39 <temoto> aha
08:55:01 <temoto> > do let { s = return "foo" }; liftM s
08:55:02 <lambdabot>       Overlapping instances for Show (m a1 -> m [Char])
08:55:02 <lambdabot>        arising from a...
08:55:05 <paper_cc> temoto: it doesn't know what Monad to show
08:55:14 <paper_cc> (no need to liftM)
08:55:25 <temoto> > do let { s = return "foo" }; liftM show s
08:55:26 <lambdabot>       No instance for (Show (m String))
08:55:26 <lambdabot>        arising from a use of `show' a...
08:55:26 <asgaroth> I once saw a proof-of-concept paper for using Haskell expressions in Excel, is there a similar thing for open office or is there another haskell-capable spreadsheet-application?
08:56:05 <quicksilver> temoto: I wonder if there is a question underlying your experimentations? or are you just experimenting?
08:56:23 <temoto> paper_cc: why everyone was using Maybe monad for s?
08:56:34 <quicksilver> "do let {s=return "foo"}; ... " is quite a strange thing to write
08:56:35 <paper_cc> temoto: randomly =)
08:56:48 <paper_cc> > do let { s = return "foo" }; liftM show s :: [[Char]]
08:56:49 <lambdabot>   ["\"foo\""]
08:57:42 <temoto> quicksilver: yes, the questions are two: is it true that monads are something that holds state bounded to name, like variables in all languages do?
08:57:53 <paper_cc> temoto: well, Maybe is the most obvious showable monad. There is also [a]
08:58:58 <asgaroth> temoto: that depends on the monad. State simulates mutable variables/state but "s <- foo" is the same as "foo >>= \s -> ...", so nothing really special
08:59:33 <paper_cc> temoto: well, Maybe doesn't hold any "variables"
08:59:59 <paper_cc> temoto: and you can even embed LLVM assembly as a monad computation inside Haskell :P
09:00:08 <quicksilver> because the 'return' in that exprs isn't the same as the monad the do is, necessarily.
09:00:12 <quicksilver> temoto: short answer "no"
09:00:20 <idnar> uhm, is there an existing function something like: count e xs = length . filter (== e) $ xs
09:00:43 <quicksilver> temoto: monads don't necessarily hold state (that's just an example) and they aren't really related to naming.
09:01:18 <temoto> And second: if Monad is class that defines those 3 functions. And do-notation is sugar for those functions. Isn't it kinda self-closured, i mean one for another and what's the point.
09:01:34 <temoto> i must be looking dumb
09:01:42 <zachk> its ok
09:01:51 <quicksilver> temoto: well sugar is just sugar
09:01:54 <zachk> the do notation lets you write what looks to be normal code.
09:01:56 <quicksilver> temoto: as you say, it is a bit pointless.
09:02:03 <quicksilver> just convenience.
09:02:15 <quicksilver> "foo" is just sugar for 'f':'o':'o':[]
09:02:20 <quicksilver> but it's convenient.
09:02:36 <zachk> saves a lot of keystrokes
09:02:54 <quicksilver> yeah. and do notation saves a lot of nested parenthesis, in general.
09:03:03 <temoto> I mean even if there would be no do-notation and one had to write some huge expressions.
09:03:13 <quicksilver> temoto: people used to; I have
09:03:21 <quicksilver> I've written 'monadic' code in ML with no sugar
09:03:31 <quicksilver> ljhj >>= \s ->
09:03:34 <zachk> I have done it a little bit. It is healthy to do it a few times.
09:03:35 <quicksilver> lkjhkl >>= \t ->
09:03:41 <quicksilver> lkhj >>= ...
09:03:50 <quicksilver> it's slightly clumsy but not the end of the world.
09:04:02 <temoto> What's the point to differ Maybe 50 to monade, so you have to write do for it. Why not just work with monadic values as if they weren't such?
09:04:14 <temoto> Like compiler has auto type inference.
09:04:40 <paper_cc> temoto: you don't have to use do, but you can if you find it convenient
09:05:15 <quicksilver> temoto: you never have to use do.
09:05:24 <zachk> I recommend learning do notation and the IO monad first. That way you can open some files and print stuff to the screen.
09:05:33 <quicksilver> temoto: [] and Maybe are both monads which are very often used without do.
09:05:37 <temoto> paper_cc: but i can't apply length to something that is returned to me, say, from file, right?
09:05:44 <idnar> is there a Haskell equivalent to python -c or perl -e ?
09:05:49 <ozy`> idnar: ghc -e
09:05:50 <idnar> well, I mean a GHC equivalent, I guess
09:06:05 <idnar> ozy`: oh, now I feel stupid
09:06:06 <quicksilver> experienced haskell programmers don't bother with do for simple expressions where it doesn't gain anything.
09:06:13 <zachk> idnar: ghci ?
09:06:21 <SamB_irssi> > do 1
09:06:22 <temoto> idnar: i feel stupid whole day in this channel :)
09:06:22 <lambdabot>       No instance for (Num (t t1))
09:06:22 <lambdabot>        arising from the literal `1' at <in...
09:06:28 <idnar> zachk: I wanted something I could toss into a shell pipeline
09:06:36 <paper_cc> temoto: well, IO is a special case
09:06:36 <SamB_irssi> (technically, that is supposed to work)
09:06:49 <temoto> paper_cc: what makes it special?
09:06:57 <paper_cc> temoto: you CAN'T say that IO is purely functional
09:07:04 <zachk> idnar: I see I am grokking.
09:07:17 <SamB_irssi> paper_cc: you can
09:07:37 <SamB_irssi> that's the beautiful thing about IO
09:07:44 <paper_cc> SamB_irssi: I meant you can't say getChar :: Char
09:07:45 <cypher-> it isn't purely functional
09:07:47 <idnar> oh, wait, does ghc -e let me get stuff from stdin somehow?
09:08:03 <temoto> idnar: it isn't what python -c
09:08:04 <SamB_irssi> it can be shamelessly imperative and extremely dirty but still purely functional ;-P
09:08:21 * idnar tries to find some docs
09:08:23 <cypher-> it's model is, but as soon as you do proper IO there is no real referential transparency
09:08:35 <SamB_irssi> cypher-: what do you mean?
09:08:36 * SubStack knows the feeling
09:08:46 <quicksilver> cypher-: IO is completely referentially transparent.
09:08:49 <SamB_irssi> you apply the same value to the same arguments, you get the same action
09:08:49 <fasta> cypher-: it is referential transparent.
09:08:55 <idnar> ah, I want interact
09:09:01 <quicksilver> that's the whole point of using a monad for IO, really :)
09:09:07 * SubStack sees right through referential transparency
09:09:15 <paper_cc> temoto: that is, you can't expect, say, getChar to return the same value for the same arguments (in fact, getChar has no arguments so it's a _constant_ in a functional language)
09:09:28 <cypher-> is it? the value of a function depends on the state of the machine, does it not?
09:09:42 <SamB_irssi> cypher-: no
09:09:43 <lilac> temoto: http://metafoo.co.uk/practical-monads.txt <-- this might help.
09:09:53 <quicksilver> cypher-: 'getChar :: IO Char' is always the same value.
09:09:56 <temoto> lilac: thanks.
09:09:59 <paper_cc> temoto: the point is that getChar isn't a constant Char, it's an action returning Char, that is, IO Char
09:10:00 <quicksilver> it is, indeed, a constant as paper_cc says.
09:10:13 <idnar> @src interact
09:10:14 <lambdabot> interact f = do s <- getContents; putStr (f s)
09:10:25 <quicksilver> "do x <- getChar; print x" is also a constant.
09:10:30 <quicksilver> it's a more complex action returning ().
09:10:41 <quicksilver> it obeys all the rules of referential transparency.
09:10:42 <fasta> The IO monad is conceptually just a data structure containing commands basically, which are executed one by one. This data structure then gets interpreted by the runIO monad which is your interpreter.
09:10:48 <quicksilver> you can duplicate it and inline it all you want.
09:11:11 * cypher- is a bit confused about that
09:11:30 <SamB_irssi> what is this "runIO"?
09:11:51 <cnwdup> > runErrorT (putStrLn "Hello World.")
09:11:52 <lambdabot>   Couldn't match expected type `ErrorT e m a'
09:11:55 <paper_cc> SamB_irssi: it's something :: IO a -> a
09:12:07 <fasta> SamB_irssi: it is something implemented by GHC or is called runhaskell on an actual system.
09:12:25 <fasta> SamB_irssi: it doesn't actually exist, I think.
09:12:28 <ozy`> :t \() -> \() -> \() -> \() -> ()
09:12:29 <lambdabot> () -> () -> () -> () -> ()
09:13:47 <temoto> damn i don't see how Maybe is monad.. if i think about monads as something allowing sideeffects as for IO, i don't get how monads related to Maybe.
09:13:58 <lilac> I like to think of IO as a sugaring over a hypothetical FFI monad (this neatly also gives a denotational semantics for IO...)
09:14:10 <quicksilver> temoto: monads aren't defined by being something allowing side-effects as for IO.
09:14:12 <asgaroth> temoto: Maybe is a monad that allows failure:
09:14:16 <quicksilver> temoto: that's an *example* of a monad
09:14:21 <fasta> temoto: you just verify the monad laws one by one and then you see it is a monad.
09:14:25 <quicksilver> temoto: it's not a pattern from which you can infer all monads.
09:14:26 <asgaroth> > Nothing >> Just 3
09:14:27 <lambdabot>   Nothing
09:14:36 <paper_cc> > Just 3 >> Just 2
09:14:37 <lambdabot>   Just 2
09:14:41 <quicksilver> temoto: Maybe is a monad for 'short-circuiting' failed calculations.
09:14:42 <osfameron> "just verify the monad laws" is of very little help to understanding what a monad is though :-)
09:14:51 <quicksilver> as lon as everything goes right, (Just) you get the answer out
09:15:01 <quicksilver> if anything goes wrong along the way you get 'Nothing'
09:15:08 <fasta> osfameron: it completely specifies what a monad is.
09:15:08 <quicksilver> so it's a monad for computations which can "fail" in some way.
09:15:13 <paper_cc> @let safeDiv a b = if b == 0 then Nothing else a `div` b
09:15:14 <lambdabot>  Defined.
09:15:15 <cypher-> temoto: the chaap and tirty explanation is that you can prove monadic laws for Maybe
09:15:24 <cypher-> temoto: therefore it is a monad
09:15:24 <quicksilver> specification is not understanding, though.
09:15:29 <asgaroth> monads are in no way specific/limited to IO, they are just most popular for that purpose in haskell
09:15:36 <osfameron> perhaps it's useful to the mathematically minded?
09:15:48 <cypher-> it always is
09:15:53 <cypher-> except when you want to get a date
09:15:53 <fasta> quicksilver: what is understanding? ;)
09:16:24 <lilac> the definition of a monad tells you everything you need to know, but nothing you want to know
09:16:34 <temoto> ok monad is something <laws>
09:16:35 <osfameron> lilac: heh
09:17:07 <paper_cc> temoto: that's the mathematicians' way to explain things
09:17:22 <quicksilver> I don't think it is, really.
09:17:25 <temoto> ok so i shouldn't bother what a monad is, right?
09:17:31 <quicksilver> it's the mathematician's way of setting up the context
09:17:41 <quicksilver> they explain what it actually is by proving theorems about it
09:17:51 <Ferdirand> perhaps you shoud start with functors
09:18:07 <paper_cc> ... and giving you some examples you can play with
09:18:12 <temoto> If i happend to use something and it happends to be a monad, then cool. Maybe it won't be a monad, then cool.
09:18:56 <temoto> Kinda imperative way to learn pure functional language.
09:19:12 <quicksilver> I think that's a reasonable attitude.
09:19:27 <quicksilver> I find familiarity with using stuff practically a good basis for insight ;)
09:20:26 <fasta> â€œIn mathematics you donâ€™t understand things. You just get used to them.â€ Johann Von Neuman
09:20:35 <fasta> One of my favorite quotes.
09:21:14 <temoto> Alright... some things can't be expressed in pure functional way and here monads help. Why just not allow language do not pure language stuff? Like in Erlang you spawn a process, that is, function returns PID, which is always different. And everyone is happy.
09:21:31 <paper_cc> temoto: it allows you to do optimization
09:21:32 <zachk> cause when you do non pure stuff
09:21:41 <zachk> it spoils your code with side effects
09:21:46 <temoto> paper_cc: alright, optimization.
09:21:57 <ozy`> temoto: pure functions are half the point of haskell... and most of the reason it's as fast as it is
09:21:57 <Eridius> I'm coming into this conversation late, so forgive me if what I'm saying isn't relevant, but isn't the only non-functional aspect here the IO monad?
09:22:04 <paper_cc> temoto: and it's a very nice thing to have, as you'll soon see
09:22:07 <ozy`> Eridius: yep
09:22:13 <paper_cc> temoto: and it allows consistent laziness
09:22:14 <zachk> you can write a bunch of a little programs in haskell. come back a few months latter and just glue them together into a large application quite easily
09:22:18 <Eridius> ok, so what is temoto trying to argue?
09:22:36 <ozy`> Eridius: he's not really arguing so much as inquiring
09:22:46 <paper_cc> temoto: and, well, IO is the _only_ monad that contains non-pure acctions
09:22:55 <Eridius> IO is the only magic in the whole shebang
09:22:56 <fasta> Eridius: we just established that the IO monad is just as much "functional" as anything else.
09:23:01 <Eridius> ok
09:23:10 <Eridius> is he confused because do-notation looks imperative?
09:23:11 <stepcut> temoto: and things like STM are much easier to implement because of purity
09:23:45 <paper_cc> temoto: you can rewrite State and Maybe and Reader and Writer and ... computations as purely functional, but they'll _look_ worse or be less maintainable
09:23:48 <temoto> Eridius: i'm confused that haskell has this special things monads :)
09:24:01 <Eridius> @google you could have invented monads
09:24:02 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:24:02 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
09:24:06 <Eridius> you've seen that, right?
09:24:24 <temoto> I have that opened for reading, it was advices.
09:25:10 <quicksilver> temoto: purity makes your code less buggy.
09:25:17 <paper_cc> temoto: you simply haven't read enough of it =)
09:25:24 <quicksilver> temoto: because effects (in a very general sense) are localised
09:25:26 <Eridius> purity means you can make mathematically provable statements about your code
09:25:35 <quicksilver> you can't have a 'surprising' interaction between two distance functions.
09:25:42 <quicksilver> they either interact because one passes a value to the other
09:25:47 <quicksilver> or they don't interact, at all.
09:25:55 <temoto> quicksilver: i understand that.
09:26:07 <quicksilver> in a non-pure language they can interact by one altering some subtle piece of global state that the other depends on.
09:26:20 <quicksilver> well, IMO, that's the pragmatic case for purity.
09:26:33 <temoto> In Erlang processes pass messages to each other and that is only way of interaction.
09:26:36 <quicksilver> ability to prove theorems is a theoretical case; in practice, I don't prove theorems about my code any more.
09:26:39 <Valodim> you can mathematically prove pure code
09:26:52 <quicksilver> the pragmatic case is "your code has fewer bugs"
09:26:57 <quicksilver> or is easier to write without bugs.
09:27:15 <paper_cc> temoto: do you like that "undefined behaviour" thing? you have much less chances for it in pure code
09:27:45 <Valodim> also the compiler has more information about the code at compile time, because nothing can happen that isn't known at compile time
09:27:47 <temoto> And i tend to write my python code to have at most no side effects, though i guess you guys understand "no side effects" in other way :)
09:28:12 <quicksilver> well it's good practice in any language
09:28:18 <quicksilver> in haskell it's enforced.
09:28:21 <quicksilver> you can like that or hate it.
09:28:22 <paper_cc> temoto: do you know Python generators?
09:28:26 <osfameron> in cobol it's forbidden :-)
09:28:31 <temoto> paper_cc: yes.
09:28:50 <paper_cc> temoto: then, you know what a lazy list is
09:29:02 <temoto> Yes i understand that. Very great thing.
09:29:14 <temoto> Well to process huge loads of data.
09:29:20 <paper_cc> temoto: and you should agree that computing a lazy list shouldn't involve side effects
09:29:38 <temoto> paper_cc: i agree if i should :)
09:29:59 <paper_cc> s/should/probably will/
09:30:20 <temoto> just kidding, i agree
09:31:08 <paper_cc> and when everything is lazy (like it is in Haskell), it's very nice to have everything free of side effects
09:31:09 <pejo> quicksilver, another pragmatic reason for purity in Haskell is that a lazy impure language is crazy.
09:31:24 <Eridius> crazy? or fun?
09:31:27 <Eridius> ;)
09:31:30 <temoto> paper_cc: yeah i like haskell laziness very much.
09:31:47 <paper_cc> otherwise, synchronizing all those side effects would be a hell multithreading can't be compared to.
09:32:05 <Valodim> oh that's another thing, parallelization
09:32:23 <temoto> Yes, what is Erlang famous for.
09:32:23 <pejo> Eridius, (\x.print "world") (print "hello ")
09:32:26 <Valodim> although we can't mess with erlang there, from what I've heard. :P
09:32:29 <Itkovian> GHC 6.4.2 bails when building 6.10.1 :-( "splitTyConApp e1{tv a2oH}"
09:32:34 <ozy`> dealing with side effects is bad enough as it is with lazy IO alone...
09:32:52 <temoto> Valodim: can't mess? What that means?
09:32:58 <Valodim> keep up
09:33:05 <pejo> Itkovian, isn't it 6.6+?
09:33:07 <paper_cc> @w80 mess with
09:33:08 <lambdabot> *** "mess" wn "WordNet (r) 2.0"
09:33:08 <lambdabot> mess
09:33:08 <lambdabot>      n 1: a state of confusion and disorderliness; "the house was a
09:33:08 <lambdabot>           mess"; "she smoothed the mussiness of the bed" [syn: {messiness},
09:33:08 <lambdabot>            {muss}, {mussiness}]
09:33:10 <lambdabot> [19 @more lines]
09:33:11 <pejo> Itkovian, that is required, that is.
09:33:17 <Eridius> pejo: hehe
09:33:27 <temoto> oh well they had real machine for that, it was right from the start
09:33:31 <ozy`> temoto: "mess with X" == fight X, bother X, etc.
09:33:39 <Itkovian> pejo: I've no idea, I am just trying to get something going on an ancient machine where I cannot really install anything system-related.
09:33:51 <Itkovian> but I'll give it a try, thx
09:33:51 <Valodim> still, pure function calls can very easily be outsourced to another core once all arguments are known at whatever point, because the compiler can actually be sure that nothing happens it can't know then
09:34:02 * paper_cc likes the idea of learning phrasal verbs on #haskell
09:34:04 <pejo> Itkovian, 6.8 should build with the version you have though.
09:34:05 <Valodim> as soon as any side effects are there, you can't do that anymore
09:34:10 <temoto> Erlang's syntax is one hell antihumanic shit, though.
09:34:15 <Valodim> at least not without specific instructions to do so
09:34:20 <temoto> ozy`: thanks.
09:34:24 <ozy`> erlang's syntax is hilarious
09:34:33 <Itkovian> pejo: aha! Then I'll try that first, cool.
09:35:00 <temoto> @w80 hilarious
09:35:04 <lambdabot> *** "hilarious" wn "WordNet (r) 2.0"
09:35:08 <lambdabot> hilarious
09:35:12 <quicksilver> ozy`: lazy IO isn't part of the language.
09:35:12 <lambdabot>      adj : marked by or causing boisterous merriment or convulsive
09:35:14 <lambdabot>            laughter; "hilarious broad comedy"; "a screaming
09:35:15 <ozy`> temoto: "very funny" :p
09:35:16 <lambdabot> Plugin `dict' failed with: thread killed
09:35:19 <quicksilver> ozy`: it's a misguided botch :P
09:35:32 <ozy`> quicksilver: yeah. oh well :p
09:35:35 <temoto> Thread killed!
09:35:51 <temoto> What a murderer.
09:36:03 <temoto> ozy`: thank you.
09:36:34 * paper_cc thinks "Thread killed" is a very good phrase for a discussion board moderator
09:37:12 <temoto> ok so this isn't serious anymore, i'll send links home and thank you all very much, you made my day
09:38:13 <temoto> Another friendliest channel in freenode. Other one is #git
09:38:41 <BMeph> temoto: Other one is #darcs. ;)
09:38:41 <lambdabot> BMeph: You have 1 new message. '/msg lambdabot @messages' to read it.
09:39:32 <temoto> Why doesn't he write that to private?
09:39:54 <quicksilver> because this is a community ;)
09:39:56 <quicksilver> it's nice to talk.
09:40:07 <quicksilver> messages are often placed + discussed in public
09:40:07 <temoto> oh
09:40:19 <temoto> how nice
09:41:03 <temoto> See you tommorrow community :) best regards
09:51:10 <Hiato> Can someone tell me where the type-casting goes wrong here: prm n = length [x|x <- [2..(sqrt n)-1], n `mod` x == 0] == 0 but prm n = length [x|x <- [2..n-1], n `mod` x == 0] == 0 works just fine
09:51:39 <Hiato> do I need a round or something? Sorry to bug on this most basic of questions
09:51:41 <quicksilver> Hiato: the first one implies that 'n' is an integer, by use mod
09:51:51 <quicksilver> Hiato: but then it implies that it is floating point, by using sqrt
09:52:05 <quicksilver> adn then haskell complains because there is no type which is both integer and floating point.
09:52:14 <quicksilver> > sqrt (5 `mod` 3)
09:52:15 <lambdabot>   Add a type signature
09:52:21 <Peaker> mod makes sense on floats too
09:52:25 <Hiato> ah, so I need to do a trunc or round :D Aha, thanks :)
09:52:31 <quicksilver> Hiato: the fix is (sqrt (fromIntegral n))
09:52:44 <Hiato> perfect, thanks quicksilver :D
09:52:46 <quicksilver> Hiato: which 'upcasts' the integer n to a Doubel just for the purpose of the sqrt.
09:52:58 <Hiato> I see
09:53:03 <quicksilver> Peaker: whilst that is true that doesn't really help solve Hiato's problem just here does it ;)
09:53:03 <rwbarton> You'll probably need to round (or floor) the result also
09:53:16 <Peaker> :-)
09:53:16 <Hiato> yep
09:53:46 <Peaker> it should be:  5.2 `mod` 2.1 = 1
09:55:35 <cypher-> does anyone know some good tutorial on sensible floating point computation in haskell?
09:55:39 <quicksilver> > 5.2 `mod'` 2.1
09:55:40 <lambdabot>   1.0
09:55:44 <quicksilver> Peaker: it's there.
09:55:55 <quicksilver> Peaker: but there are reasons to prefer exact computations
09:56:10 <quicksilver> and I don't think it's unreasonable that "mod" defaults to the exact (integer) case.
09:56:14 <Peaker> @index mod'
09:56:14 <lambdabot> bzzt
09:56:19 <quicksilver> Data.Fixed
09:56:23 <Peaker> @type mod'
09:56:24 <lambdabot> forall a. (Real a) => a -> a -> a
09:56:25 <quicksilver> not sure why @index can't see it.
09:56:38 <quicksilver> @hoogle mod'
09:56:39 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
09:56:39 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
09:57:21 <quicksilver> cypher-: you should read this :) http://docs.sun.com/source/806-3568/ncg_goldberg.html
09:57:29 <quicksilver> it's not haskell-specific, though.
09:57:48 <quicksilver> neither is it an easy read.
09:58:14 <quicksilver> but the point is, really, FP is more complex than most people think, and to use it for anything non-trivial where you care about accuracy you do need to understand it.
09:58:35 * paper_cc remembers reading about floating point in the Art of Computer Programming ... aargh ...
09:58:43 <drhodes> is it better to construct a datatype by using the (MyType (sliceA ChunkA) (diceB ChunkB)) or to have a (myType_constructor ChunkA ChunkB) ?  if the former, is there a name convention for constructors?
09:59:34 <paper_cc> using myType for MyType seems reasonable
09:59:46 <cypher-> quicksilver: thanks
10:00:25 <quicksilver> drhodes: using convenience constructors is a very natural thing to do
10:00:36 <quicksilver> it makes the actual construction of the type abstract.
10:00:42 <quicksilver> (from the point of view of that code)
10:01:15 <quicksilver> calling it just 'myType' works well if there's really just one.
10:01:20 <drhodes> ok paper_cc quicksilver, thanks, I shall continue forth with confidence and vigor.
10:01:24 <quicksilver> otherwise people tend to give them simple names.
10:01:28 <quicksilver> e.g. "empty"
10:01:37 <quicksilver> empty is a convenience constructor for Set and Map
10:01:49 <quicksilver> (making an empty one, obviously!)
10:01:54 <quicksilver> and Seq too, I think.
10:01:58 <quicksilver> @hoogle empty
10:01:58 <lambdabot> Control.Applicative empty :: Alternative f => f a
10:01:58 <lambdabot> Data.ByteString empty :: ByteString
10:01:58 <lambdabot> Data.IntMap empty :: IntMap a
10:02:01 <pumpkin_> moo
10:02:23 <quicksilver> 'fromList' is another popular name for a convenience constructor.
10:02:40 <quicksilver> ByteString has a convenience constructor called 'pack'
10:02:42 <quicksilver> and so on :)
10:02:49 <quicksilver> doens't seem to be much of a convention.
10:03:19 <drhodes> I like fromList, it's a great name.  Lots of great names in haskell.
10:04:58 <paper_cc> by the way, is there a good way to write things that do (a -> b -> c) -> (a1 -> a) -> (b1 -> b) -> (a1 -> b1 -> c)?
10:05:10 <lament> fromList is pretty confusing, since it tells you the type of the argument (which you probably know anyway if you're reading the source) but does not tell the type of the result
10:05:25 <skorpan> @djinn (a -> b -> c) -> (a1 -> a) -> (b1 -> b) -> (a1 -> b1 -> c)
10:05:25 <lambdabot> f a b c d e = a (b d) (c e)
10:05:32 * paper_cc would name it on', but he wants to go infix
10:06:13 <quicksilver> :t \f g -> curry . (f *** g) . uncurry
10:06:14 <lambdabot>     Couldn't match expected type `(b, b')'
10:06:14 <lambdabot>            against inferred type `(a, b1) -> c'
10:06:14 <lambdabot>     Probable cause: `uncurry' is applied to too few arguments
10:08:09 <quicksilver> paper_cc: can't think of one, no :)
10:09:04 <ozy`> @unpl f *** g
10:09:04 <lambdabot> (f *** g)
10:09:14 <ozy`> :t (f *** g)
10:09:15 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a, SimpleReflect.FromExpr (a b' c'), SimpleReflect.FromExpr (a b c)) => a (b, b') (c, c')
10:09:27 <quicksilver> you probably wanted :t (***)
10:09:31 <ozy`> maybe
10:09:48 <paper_cc> :t (**)
10:09:49 <lambdabot> forall a. (Floating a) => a -> a -> a
10:09:53 <paper_cc> :t (***)
10:09:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:10:02 <ozy`> :t curry (uncurry f *** uncurry g)
10:10:04 <lambdabot> forall a b c a1 b1 c1. (SimpleReflect.FromExpr c1, Show b1, Show a1, SimpleReflect.FromExpr c, Show b, Show a) => (a, b) -> (a1, b1) -> (c, c1)
10:10:09 <lilac> paper_cc: yes, there's a good way to write that...
10:10:12 <lilac> @type (~>)
10:10:13 <lambdabot> Not in scope: `~>'
10:10:44 <ozy`> @unpl curry (uncurry f *** uncurry g)
10:10:44 <lambdabot> curry ((uncurry f) *** (uncurry g))
10:10:48 <ozy`> bah
10:10:51 * paper_cc tried \f g h -> f <$> g <*> h and found it amusing (though unrelated)
10:10:54 <ozy`> @pl curry (uncurry f *** uncurry g)
10:10:54 <lambdabot> curry (uncurry f *** uncurry g)
10:11:07 <dancor> @let aaa = (***) :: (b -> c) -> (b' -> c') -> ((b, b') -> (c, c'))
10:11:08 <lambdabot>  Defined.
10:11:21 <dancor> @unpl f `aaa` g
10:11:21 <lambdabot> (aaa f g)
10:11:23 <dancor> hhe
10:11:25 <dancor> heh
10:11:33 <lilac> > let (f ~> g) h = g . h . f in \f g h -> (g ~> h ~> id) f
10:11:34 <lambdabot>       Overlapping instances for Show
10:11:34 <lambdabot>                                  (((a ->...
10:11:36 <lilac> @type let (f ~> g) h = g . h . f in \f g h -> (g ~> h ~> id) f
10:11:38 <lambdabot> forall a b c c1 c2. ((a -> c1) -> c2) -> (a -> b) -> (c -> c1) -> (b -> c) -> c2
10:12:07 <lilac> @let (f ~> g) h = g . h . f
10:12:08 <lambdabot>  Defined.
10:12:36 <lunabot>  luna: parse error on input `do'
10:12:58 <lilac> > ((+1) ~> (*2) ~> (-1)) (*) 1 2 3
10:12:59 <lambdabot>       No instance for (Num (((a -> c1) -> a -> c1) -> t -> t1 -> a1))
10:12:59 <lambdabot>        ...
10:14:31 <lilac> @undefine
10:14:59 <lilac> @let infixl 9 ~>; (f ~> g) h = g . h . f
10:14:59 <lambdabot>  Defined.
10:15:41 <lilac> > ((+1) ~> (*2) ~> (+1)) (*) 1 2
10:15:42 <lambdabot>   9
10:15:55 <lilac> (that's with @let infixr 9 ~>; (f ~> g) h = g . h . f)
10:16:06 <lilac> paper_cc: ^^ i forget who invented this trick, but i like it
10:16:38 <Cheshire> @pl \f g h -> g . h . f
10:16:39 <lambdabot> flip ((.) . (.)) . flip (.)
10:18:38 <paper_cc> @ty (~>)
10:18:39 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
10:18:57 <paper_cc> @ty ((+1) ~> (*2))
10:18:58 <lambdabot> forall a c1. (Num c1, Num a) => (a -> c1) -> a -> c1
10:21:07 <mmorrow> no way
10:21:25 <mmorrow> ohh
10:21:35 <mmorrow> my font makes '~' look like '-'
10:22:02 * mmorrow was confused/excited for a second
10:22:08 <pumpkin_> :o
10:24:01 <quicksilver> lilac: maybe conal? or did conal merely evangelise it?
10:24:21 <kerlo> > ((+1) -> (*2)) show 5
10:24:22 <lambdabot>   <no location info>: parse error on input `->'
10:24:27 <kerlo> > ((+1) ~> (*2)) show 5
10:24:27 <lambdabot>       No instance for (Num String)
10:24:27 <lambdabot>        arising from the literal `2' at <in...
10:24:41 <zachk> man haskell is such a dense language. dense in a good sense
10:24:58 <paper_cc> @ty \f g h -> f ~> g ~> h
10:24:59 <lambdabot> forall a b a1 b1 c1 c. (a -> b) -> (a1 -> b1) -> (c1 -> c) -> (b -> b1 -> c1) -> a -> a1 -> c
10:25:07 <quicksilver> zachk: "pithy" ;)
10:25:18 * paper_cc wishes that lambdabot renamed type variables
10:25:49 <paper_cc> @ty \f g h p -> f ~> g ~> h ~> p
10:25:50 <lambdabot> forall a b a1 b1 a2 b2 c1 c. (a -> b) -> (a1 -> b1) -> (a2 -> b2) -> (c1 -> c) -> (b -> b1 -> b2 -> c1) -> a -> a1 -> a2 -> c
10:25:53 <kerlo> As in you can write "flip((.).(.)).flip(.)" and it'll mean "solve the Millenium Prize Problems and all known encryption schemes in 30 seconds"?
10:26:01 <yitz> >((+1) ~> ((>1).length)) show 9
10:26:10 <kerlo> That kind of dense?
10:26:11 <yitz> > ((+1) ~> ((>1).length)) show 9
10:26:12 <lambdabot>   True
10:26:18 <zachk> i just wrote out and hpasted basic set functions then got bogged down doing test code. wanted to help out idnar with some basic set theory. felt like forever. when i am done it is only 49 lines of code. and i am like omg what
10:26:25 <pumpkin_> @unpl flip((.).(.)).flip(.)
10:26:25 <lambdabot> (\ r c f i -> c (f (r i)))
10:26:45 <paper_cc> lilac: that's wonderful. thangs
10:26:50 <paper_cc> thanks*
10:27:11 <Fredrik> Is there a shorthand function that does this?
10:27:12 <Fredrik> (\x y -> x ++ [y])
10:27:16 <zachk> what does unpl do?
10:27:21 <quicksilver> Fredrik: no.
10:27:25 <paper_cc> @ty mappend
10:27:26 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:27:30 <yitz> lilac, what are the other ones? uh, "argument" and "result" I think?
10:27:33 <paper_cc> @ty mappend . []
10:27:34 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
10:27:34 <lambdabot>     In the second argument of `(.)', namely `[]'
10:27:37 <dancor> @pl \ x y -> x ++ [y]
10:27:38 <lambdabot> (. return) . (++)
10:27:39 <paper_cc> @ty mappend.return
10:27:40 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => a -> m a -> m a
10:28:03 <paper_cc> still wrong
10:28:08 <ozy`> zachk: it expands a (presumably) terse expression into a lambda with all the variables made explicit
10:28:10 <zachk> frederik: you might be better off doing x:[y] or using a tuple (x,y)
10:28:19 <ozy`> zachk: it doesn't usually work so well
10:28:37 <zachk> it seemed to work quite well there
10:28:41 <Fredrik> i have a string and a character, and i want to append the character to the string
10:28:49 <dancor> zachk: x:[y] doesn't work bc x is a List as well here right
10:29:07 <quicksilver> Fredrik: the way you did it was the right way.
10:29:15 <quicksilver> there's no better way to write it.
10:29:25 <quicksilver> If you're doing it often, you probably shouldn't use lists though.
10:29:25 <rwbarton> Fredrik: People are just suggesting that you try to avoid getting into this situation in the first place. :)
10:29:29 <Fredrik> ok, i just dont like lambdas :)
10:29:31 <quicksilver> they're slow for backend append.
10:29:36 <Fredrik> I know :)
10:29:50 <dancor> Fredrik: you could call it something if you want, tho that might promote using it
10:29:55 <dancor> :)
10:30:01 <Fredrik> I just want to do it ONCE
10:30:05 <ozy`> @pl \x y -> x ++ (y : z)
10:30:05 <lambdabot> (. (: z)) . (++)
10:30:27 <ozy`> Fredrik: so... (. (:[])) . (++)
10:30:31 <ozy`> is that terse enough?
10:30:46 <Fredrik> Let me see if I understand that :)
10:30:56 <rwbarton> @pl \x y -> foldr (:) [y] x
10:30:56 <lambdabot> flip (foldr (:) . return)
10:30:58 <Fredrik> What is this @pl stuff?
10:31:14 <koeien> pointfree expressions
10:31:18 <ozy`> Fredrik: @pl and @unpl rewrite functions in terser and clearer forms, respectively
10:31:18 <yitz> Fredrik: it's pointless
10:31:20 <zachk> it expands crazy looking stuff into nice lambdas
10:31:28 <rwbarton> @type foldr (:)
10:31:29 <lambdabot> forall a. [a] -> [a] -> [a]
10:31:30 <koeien> e.g. "f x = x^2" is changed into (^2)
10:31:33 <dancor> ozy`: pl is not always terser
10:31:37 <yitz> @help pl
10:31:38 <lambdabot> pointless <expr>. Play with pointfree code.
10:31:42 <Fredrik> What is it now, pointFREE or pointLESS? :)
10:31:49 <koeien> formally it's pointfree
10:31:50 <ozy`> dancor: I consider that a bug ;)
10:31:52 <koeien> but i use pointless :)
10:31:58 <zachk> frederik: google pointfree topology :D
10:32:03 <koeien> i use pointfree now for the 'pointless' case :)
10:32:21 <yitz> Fredrik: because spending too much time on it can really be a pointless exercise
10:32:37 <pumpkin_> is @pf a synonym for @pl because of the edit distance thing, or because it's an explicitly listed command?
10:32:38 <mmorrow> @let prod (><) = \p1 p2 -> \f g -> \a -> (f . p1) a >< (g . p2) a
10:32:38 <lambdabot>  Defined.
10:32:41 <pumpkin_> or vice versa :o
10:32:42 <mmorrow> @let coprod (<>)= \i1 i2 -> \f g -> \a -> (i1 . f) a <> (i2 . g) a
10:32:42 <lambdabot>  Defined.
10:32:44 <dancor> @pl a b c d e f g = g e d b a
10:32:44 <lambdabot> a = fix (((const . ((const .) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
10:33:19 <mmorrow> @. djinn type prod
10:33:20 <lambdabot> f a b c d e f = a (d (b f)) (e (c f))
10:33:22 <mmorrow> @. djinn type coprod
10:33:23 <lambdabot> f a b c d e f = a (b (d f)) (c (e f))
10:33:41 <Fredrik> I dont understand the first point in (. (:[])) . (++)
10:33:47 <Fredrik> What are we concatenating here?
10:33:50 <Fredrik> Theres nothing on the left
10:33:57 <monochrom> "f x = g (h x)" the parameter x is a "point". You can write instead "f = g . h" without mentioning the parameter. And so without the point, you have "point-free" or "point-less". It is unrelated to the usual English word "pointless".
10:34:01 <dancor> @unpl (. f) . g
10:34:02 <lambdabot> (\ d i -> g d (f i))
10:34:05 <guenni> mmorrow: hi
10:34:11 <mmorrow> guenni: hey
10:34:16 <rwbarton> Fredrik: IMHO (. (:[])) . (++) is terrible style
10:34:33 <Fredrik> Yes, I just want to understand it before I abandon it :)
10:34:44 <Fredrik> just curios :)
10:34:48 <ozy`> Fredrik: you know about sections? eg. (+ 1), (* 2), (1 /)
10:34:50 <koeien> Fredrik: see what happens by applying it
10:34:51 <byorgey> it's great style for robot monkeys.
10:34:56 <rwbarton> Then write ((. (:[])) . (++)) x y and reduce it until you get something recognizable
10:35:27 <rwbarton> first it reduces to (. (:[])) ((++) x) y, etc.
10:35:29 <ozy`> > (+) 1 2
10:35:30 <lambdabot>   3
10:35:33 <ozy`> > (+ 1) 2
10:35:34 <lambdabot>   3
10:35:39 <mmorrow> ((. (:[])) . (++)) x y ==> (. (:[])) (x++) $ y ==> (x++) . (:[]) $ y ==> (x++) [y] ==> [x,y]
10:35:39 <ozy`> > (2 +) 1
10:35:41 <lambdabot>   3
10:35:49 <ozy`> > (:[]) 'h'
10:35:50 <lambdabot>   "h"
10:36:00 <ozy`> > 'h' : []
10:36:01 <lambdabot>   "h"
10:36:10 <mmorrow> i didn't know what "(. (:[])) . (++)" was gonna turn into until that last step
10:36:32 <Fredrik> x and y are of different types, how can they be in the same list?
10:36:40 <rwbarton> yeah that last step is wrong
10:36:40 <koeien> that cannot be
10:36:42 <ozy`> Fredrik: mmorrow did it wrong. ignore him ;)
10:36:44 <rwbarton> it should be x ++ [y]
10:36:46 <mmorrow> hehe
10:36:47 <rwbarton> the rest is right
10:36:54 <mmorrow> oh, yeah
10:37:34 <Peaker> If you're using ((.a).(b.).c) and such forms maybe you could use ~> ?
10:37:38 <comex> why can't I do 'instance Ord [Char]'?
10:37:56 <mathijs> Hi all, this might seem like a beginner question, but say I have a lists of tuples (x,y) and want to find the tuple with the highest y. What's the nicest way to do this? I currently use foldl1' with a maxTuple function, but I'm sure there's something like maximumWith snd or something.
10:38:07 <Peaker> @let result = (<<<) ; argument = (>>>) ; infixr 2 ~> ; f ~> g = argument f . result g
10:38:08 <lambdabot>  <local>:4:52:
10:38:08 <lambdabot>      Multiple declarations of `L.~>'
10:38:08 <lambdabot>      Declared at: <local>...
10:38:11 <pumpkin_> comex: there's already an (Ord a) => Ord [a]
10:38:21 <mmorrow> @type maximumBy (comparing `on` snd)
10:38:22 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
10:38:22 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
10:38:22 <lambdabot>     In the first argument of `on', namely `comparing'
10:38:29 <byorgey> mathijs: maximumBy (comparing snd)
10:38:29 <mmorrow> @type maximumBy (compare `on` snd)
10:38:29 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
10:38:54 <byorgey> @src comparing
10:38:55 <lambdabot> Source not found. My pet ferret can type better than you!
10:38:55 <Peaker> @type (~>)
10:38:56 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
10:39:05 <rwbarton> comex:
10:39:07 <mathijs> mmorrow, byorgey: thanks... I was looking for maximumWith (since I knew about zipWith)
10:39:11 <rwbarton> > compare "abc" "def"
10:39:12 <lambdabot>   LT
10:39:16 <rwbarton> > compare "gbc" "def"
10:39:17 <lambdabot>   GT
10:39:36 <ozy`> @src (>)
10:39:36 <lambdabot> x >  y = case compare x y of { GT -> True;  _other -> False }
10:39:36 <rwbarton> mathijs: there are a lot more fooBy functions
10:39:41 <mmorrow> > flip compare "abc" "def"
10:39:42 <lambdabot>   GT
10:39:44 <Peaker> > [compare "LT" "GT", compare LT GT]
10:39:45 <lambdabot>   [GT,LT]
10:40:02 <rwbarton> > comparing show LT GT
10:40:03 <lambdabot>   GT
10:40:13 <mathijs> rwbarton: I see. takes some getting used to :)
10:40:26 <cognominal> on a mac is it possible to have both the 6.8.3 and the 6.10.1 package installed?
10:40:37 <ozy`> > GT > LT
10:40:39 <lambdabot>   True
10:40:40 <koeien> cognominal: on debian it is, just use a different prefix
10:40:45 <cognominal> if yes what is the way to switch?
10:40:58 <ozy`> cognominal: that depends how you installed it
10:41:08 <koeien> --with-compiler if you compile a cabal package, otherwise directly call the correct ghc (or change PATH)
10:41:17 <cognominal> I am using .pks files so far
10:41:17 <ozy`> cognominal: by the way, you better have Xcode 3.1 before you go any further
10:41:27 <cognominal> .pkg...
10:41:38 <cognominal> I have Xocde 3.1
10:41:42 <ozy`> okay, good
10:42:12 <rwbarton> cognominal: I think someone was complaining that every ghc .pkg uninstalls other versions... I don't know if he found a way around that
10:42:41 <comex> what if it's a random class, 'instance Something [Char]'
10:42:46 <ozy`> cognominal: I installed 6.10 via macports. much as I despise macports, it works nicely for some things
10:42:54 <cognominal> I don't think it unisntalls, apparently it messes with symlinks
10:43:10 <comex> how do I make that work?
10:43:10 <rwbarton> comex: in that case you need the FlexibleInstances extension
10:43:17 <pumpkin_> ozy`: why not just the precompiled .pkg ?
10:43:18 <rwbarton> comex: (ghc should tell you that)
10:43:34 <comex> it does, but I was assuming there's a better way
10:43:37 <ozy`> pumpkin_: 'cause I'm still on PPC
10:43:44 <rwbarton> comex: there is a worse way :P
10:43:45 <pumpkin_> ozy`: omg epic phail
10:43:51 <cognominal> ozy` : thx for the macport tip
10:43:57 <ozy`> pumpkin_: NO U
10:44:02 <comex> what's the worse way
10:44:06 * pumpkin_ shakes his head
10:44:28 <rwbarton> comex: suppose you want class Foo a where bar :: a -> a
10:44:35 <rwbarton> comex: and instance Foo [Char]
10:44:38 <cognominal> so far, I have had very mixed results with macport. I have to see that I am using 4 or 5 different installation systems on my mac
10:44:41 <pejo> cognominal, macports only allow one version of the port installed.
10:44:44 <rwbarton> comex: then define class Foo' a where bar :: [a] -> [a]
10:44:59 <SamB_irssi> cognominal: what, no "alternatives" mechanism
10:45:00 <rwbarton> comex: instance Foo' Char where (definition of bar for [Char])
10:45:02 <ozy`> pumpkin_: no, epic fail is when I complained to #ghc that cabal wasn't building, and it turned out to be an insufficiently clear comment in the mac build instructions
10:45:10 <cognominal> btw, the best linux distro for haskell is arch linux?
10:45:13 <ozy`> I wasted like half an hour of their time :(
10:45:17 <rwbarton> comex: err, call the bar in Foo' bar'
10:45:17 <pumpkin_> ozy`: :o
10:45:25 <koeien> cognominal: define "best". it certainly has the most haskell packages
10:45:30 <rwbarton> comex: instance Foo' a => Foo [a] where bar = bar'
10:45:39 * koeien prefers debian anyway
10:45:46 <rwbarton> comex: I told you it was worse :)
10:45:46 <comex> rwbarton: thanks for the explanation
10:45:57 <comex> I don't even need it, I'm just curious :p
10:45:58 <rwbarton> comex: I believe FlexibleInstances basically does this behind the scenes for you
10:46:05 <ozy`> cognominal: once you get cabal-install up and running, haskell packages are largely self-sufficient.
10:46:33 <rwbarton> comex: That's how show works on strings differently from other lists.  You can look at the Prelude source for more details
10:47:40 <rwbarton> cognominal: I prefer debian too.  Just because Haskell and ghc are unstable and moving quickly these days doesn't mean the rest of your system has to be :)
10:48:08 <rwbarton> (I mean unstable as a synonym for changing quickly)
10:48:30 <mathijs> ?pl \x -> (x, f x)
10:48:30 <lambdabot> ap (,) f
10:48:50 <pumpkin_> lol
10:49:09 <SamB_irssi> rwbarton: you mean "at greater than glacial rate"?
10:49:25 <SamB_irssi> no, wait, that's "testing"
10:50:01 <Peaker> @type \f -> [\x -> (x, f x), id&&&f]
10:50:02 <lambdabot> forall a c'. (a -> c') -> [a -> (a, c')]
10:50:05 <rwbarton> SamB_irssi: debian moves just as quickly as other distributions
10:50:10 <rwbarton> SamB_irssi: it's just with a global lag :)
10:50:35 <Peaker> Debian samples the world at greater intervals
10:51:16 <SamB_irssi> which is usually a good thinf when it comes to the programs you don't really want to think about ...
10:51:17 <Fredrik> OK, can I improve this function further?
10:51:19 <Fredrik> conc = concat . zipWith (\x y -> x ++ [y]) hyphens where hyphens = iterate ('-':) []
10:51:32 <rwbarton> SamB_irssi: Exactly, which for me is most programs (not ghc)
10:51:53 <SamB_irssi> I haven't gotten around to upgrading to 6.10 yet
10:51:54 <Cheshire> @let conc = concat . zipWith (\x y -> x ++ [y]) hyphens where hyphens = iterate ('-':) []
10:51:55 <lambdabot>  Defined.
10:51:58 <rwbarton> @type conc
10:51:58 <Cheshire> :t conc
10:51:59 <lambdabot> [Char] -> [Char]
10:52:00 <lambdabot> [Char] -> [Char]
10:52:06 <Cheshire> > conc "foobar"
10:52:07 <lambdabot>   "f-o--o---b----a-----r"
10:52:23 <SamB_irssi> I suppose mostly because they forgot to merge my patch and now I have to wait until 6.12 ;-P
10:52:32 <ozy`> @pl \f -> [\x -> f x, id &&& f]
10:52:32 <lambdabot> ap (:) (return . (id &&&))
10:52:42 <ozy`> wow
10:52:49 <rwbarton> @let hyphens = iterate ('-':) []
10:52:49 <lambdabot>  Defined.
10:53:02 <SamB_irssi> > hyphens
10:53:03 <lambdabot>   ["","-","--","---","----","-----","------","-------","--------","---------"...
10:53:43 <SamB_irssi> > let hr = fix ('-':)
10:53:44 <lambdabot>   <no location info>: parse error on input `;'
10:53:52 <SamB_irssi> @let hr = fix ('-':)
10:53:52 <lambdabot>  Defined.
10:53:54 <SamB_irssi> > hr
10:53:55 <lambdabot>   "--------------------------------------------------------------------------...
10:54:24 * SamB_irssi has a test to take now
10:54:32 <rwbarton> > concat . zipWith (\x y -> [x,[y]]) hyphens $ "foobar"
10:54:33 <lambdabot>   ["","f","-","o","--","o","---","b","----","a","-----","r"]
10:54:47 <Cheshire> @pl (\x y -> [x,[y]])
10:54:48 <lambdabot> (. (return . return)) . (:)
10:55:49 <gwern> @quote orly
10:55:50 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
10:55:56 <BMeph> newsham: Thanks for trying to help me not look like a complete idiot. :)
10:55:57 <gwern> @quote orly
10:55:57 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
10:56:01 <gwern> bah
10:56:28 <ozy`> @quote rly
10:56:29 <lambdabot> pjd says: clearly you lack pessimism
10:56:32 <ozy`> @quote rly
10:56:32 <lambdabot> chrisdone says: zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
10:56:48 <ozy`> @quote rly
10:56:49 <lambdabot> ghc says: GHCi's bytecode generation machinery can't handle 64-bit code properly yet.
10:57:44 <pumpkin_> are the ghc quotes just comments from the ghc source?
10:57:48 <newsham> bmeph: i was just trying to figure out your amazing function, but ghci conspired against me
10:58:12 <paper_cc> > zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
10:58:13 <lambdabot>   "hail satan"
10:58:16 <paper_cc> wow
10:58:30 <pumpkin_> steganography ftw
10:59:23 <newsham> its too bad it doesnt make a diff message when swapped the other way
10:59:31 <pumpkin_> yeah
10:59:59 <Fredrik> So I guess my function cannot be made significantly easier/shorter? Thanks anyway!
11:01:00 <Fredrik> Of course I could remove the where clause
11:01:01 <Fredrik> conc = concat . zipWith (\x y -> x ++ [y]) (iterate ('-':) [])
11:01:07 <Fredrik> Bit that's not very readable, is it? :)
11:01:25 <pumpkin_> it's not too bad
11:01:46 <Cheshire> @let triangle x = iterate (x:) []
11:01:47 <lambdabot>  Defined.
11:01:51 <Cheshire> > triangle '-'
11:01:52 <lambdabot>   ["","-","--","---","----","-----","------","-------","--------","---------"...
11:02:04 <Fredrik> triangle, thats a nice name for that :)
11:02:08 <Cheshire> @let twiddle (x:xs) (y:ys) = x : y : twiddle ys xs
11:02:08 <lambdabot>  Defined.
11:02:33 <Cheshire> > twiddle (repeat "foo") (triangle '-')
11:02:35 <lambdabot>   ["foo","","-","foo","foo","--","---","foo","foo","----","-----","foo","foo"...
11:02:48 <Cheshire> aha twiddle is wrong
11:02:53 <Fredrik> > twiddle "foo" $ triangle '-'
11:02:54 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
11:03:01 <mathijs> I asked lambdabot for ?pl \x -> (x, f x) and it gave me ap (,) f... It works of course, but I don't completely get it. I know ap and (,), but I fail to see which monad we're talking about here. Is a tuple monadic somehow?
11:03:17 * ksf wants a compilation monad.
11:03:20 <Cheshire> :t ap (,)
11:03:21 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
11:03:21 <pumpkin_> > twiddle (map return "foo") $ triangle '-'
11:03:22 <lambdabot>   ["f","","-","o","o","--"* Exception: <local>:8:0-44: Non-exhaustive pattern...
11:03:25 <Cheshire> :t ap
11:03:25 <paper_cc> mathijs: it's the ((->) a) monad
11:03:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:03:27 <pumpkin_> :P
11:03:40 <Cheshire> :t (,)
11:03:41 <ksf> so that there is a lineNumber :: Syntax String
11:03:41 <lambdabot> forall a b. a -> b -> (a, b)
11:03:44 <paper_cc> mathijs: (probably)
11:03:52 <Cheshire> mathijs,  (a -> b -> (a, b)) = m (a -> b)
11:03:57 <Cheshire> what 'm' solves this?
11:04:13 <Cheshire> or maybe that is not even it
11:04:23 <Peaker> :t ((,)>>=)
11:04:23 <doserj> it's the ((,) a) monad
11:04:24 <lambdabot> forall a b b1. ((b -> (a, b)) -> a -> b1) -> a -> b1
11:04:34 <ksf> which means that you can use it anywhere you can use syntax, or, in other words, "Syntax a" forbids stuff to be passed around.
11:04:43 <doserj> ignore me...
11:04:52 <paper_cc> mathijs: what you're trying to write is (id &&& f) actually =)
11:05:03 <paper_cc> @ty \f -> id &&& f
11:05:04 <lambdabot> forall a c'. (a -> c') -> a -> (a, c')
11:05:14 <paper_cc> @ty second
11:05:15 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
11:05:53 <ozy`> can't lambdabot be altered to print out Arrow types as (~>)?
11:05:54 <mathijs> paper_cc: looks the same yeah. But I find both the ap version, and the &&& version harder to read than the original version
11:06:28 <ksf> another application is TH, which'd look like splice :: Syntax a -> Syntax a or something.
11:06:40 <paper_cc> the &&& version is natural for because &&& means exactly what you want
11:06:43 <paper_cc> (for me)
11:06:48 <paper_cc> @ty (&&&)
11:06:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:06:53 <mathijs> paper_cc: what's the ((->) a) monad? I don't know that syntax. is it an 'application' monad or something?
11:07:10 <ksf> :t ((-> a))
11:07:11 <lambdabot> parse error on input `->'
11:07:16 <ksf> :t ((->) a)
11:07:17 <lambdabot> parse error on input `->'
11:07:18 <whpearson> Does anyone have a way of turning (x,y) into a monoid where mappend finds the combined range of the numbers? E.g. (4,10) `mappend` (3,8) = (3, 10)?
11:07:19 <mauke> mathijs: (->) a b is the type of functions from a to b
11:07:20 <ksf> grrr
11:07:35 <paper_cc> mathijs: it's the Reader monad with a different name. the syntax says that a -> b is equivalent to (->) a b
11:07:38 <mathijs> well, I didn't encounter arrows yet... probably best to stick to the old version until I learn about them :)
11:07:42 <ksf> it's an applacative functor. (.) = map.
11:07:53 <Cheshire> whpearson what should  (0,1) `whappend` (2,3) be?
11:07:59 <monochrom> (0,1) `mappend` (3,4) = ?
11:08:09 <whpearson> (0,4)
11:08:15 <doserj> whpearson: direct product of min monoid and max monoid?
11:08:16 <whpearson> For monochrom
11:08:35 <paper_cc> mathijs: when you see (Arrow a) => a b c you can safely substitute it with just b -> c.
11:08:42 <whpearson> Cheshire: (0,3)
11:08:50 * paper_cc remembers the (snd &&& fst) trick
11:08:54 <Olathe> @src Arrow
11:08:54 <lambdabot> class Arrow a where
11:08:54 <lambdabot>     arr, pure   :: (b -> c) -> a b c
11:08:54 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
11:08:54 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
11:08:54 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
11:08:56 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
11:08:58 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
11:09:03 <ozy`> :t (snd &&& fst)
11:09:04 <lambdabot> forall a b. (a, b) -> (b, a)
11:09:07 <ksf> @src (->)
11:09:07 <lambdabot> Source not found. Where did you learn to type?
11:09:39 <whpearson> @instances monoid
11:09:40 <lambdabot> Couldn't find class `monoid'. Try @instances-importing
11:09:44 <whpearson> @instances Monoid
11:09:44 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:10:03 <ozy`> sweet, you can use consyms as type names
11:10:11 * ozy` names a type :~|
11:10:34 <mathijs> paper_cc: ok thanks, I've put it in the comments so someday in the (near?) future I get back to it. Arrow is probably still to come :)
11:10:42 <paper_cc> @where arrows
11:10:43 <lambdabot> http://www.haskell.org/arrows/
11:11:02 <mauke> data O = X():-O
11:11:07 <mathijs> ah, handy :)
11:12:01 <whpearson> doserj: I haven't come across the min or max monoids.
11:12:33 <Cheshire> @rules Monoid
11:12:33 <lambdabot> Unknown command, try @list
11:13:00 <ozy`> data XD = XD :\ XD | (:=|) :& (:=|)
11:13:01 <Cheshire> whpearson, I don' think it has an identity, does it?
11:13:18 <Cheshire> well (-infinity,infinity)
11:13:30 <doserj> the typed would have to be in Bounded
11:13:52 <whpearson> Cheshire, not in the normal sense. Although each value has lots of identities.
11:14:23 <doserj> instance (Bounded a, Ord a) => Monoid (Max a) where mappend = max ; mempty = minBound
11:14:35 <whpearson> E.g. mappend (4,5) (4,4) = (4,4)
11:14:41 <whpearson> E.g. mappend (4,5) (4,4) = (4,5) even
11:15:02 * paper_cc thinks that the ((->) a) instance is surprising like hobbits: you can understand it in several minutes and you'll get surprises very long afterwards
11:15:02 <Peaker> > (1,2) `mappend` (3,4)
11:15:03 <lambdabot>   Add a type signature
11:15:09 <Peaker> > (1,2) `mappend` (3,4) :: (Int, Int)
11:15:10 <lambdabot>       No instance for (Monoid Int)
11:15:10 <lambdabot>        arising from a use of `mappend' at ...
11:15:13 <whpearson> doserj, yeah that'd do.
11:15:47 <pumpkin_> > (Sum 1,Sum 2) `mappend` (Sum 3, Sum 4) :: (Sum Int, Sum Int)
11:15:49 <lambdabot>   (Sum {getSum = 4},Sum {getSum = 6})
11:16:33 <pumpkin_> > (Min 1, Max 2) `mappend` (Min 3, Max 4)
11:16:34 <lambdabot>   Not in scope: data constructor `Min'Not in scope: data constructor `Max'Not...
11:16:41 <pumpkin_> :(
11:17:44 <mathijs> another question... I need 'cheap concurrency' for map... say I have 4 cores and need to map through a list. I can take 4 elements, compute them on their own core, and put the results back. Is there some kind of 'threadpool' that makes this easy?
11:18:09 <koeien> this can be done
11:18:12 <koeien> :t par
11:18:13 <lambdabot> forall a b. a -> b -> b
11:18:31 <koeien> however there is a more general framework for this, i forgot the name
11:18:37 <Ferdirand> :t parMap
11:18:38 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
11:18:51 <pumpkin_> you might want to use a chunk strategy though
11:18:57 <pumpkin_> unless each element is quite expensive on its own
11:19:04 <brutopia> hey, why do I get "cannot construct the infinite type a = [a] when I try to compile itoa num = itoa (div num 10) : mod num 10
11:19:17 <koeien> brutopia: the right hand side is not a list
11:19:26 <koeien> brutopia: of the (:)
11:19:46 <mathijs> pumpkin_: no, not that expensive. what's chunk strategy?
11:20:09 <pumpkin_> http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel-Strategies.html#v%3AparListChunk
11:20:09 <brutopia> so it should be itoa num = itoa (div num 10) : [mod num 10]?
11:20:22 <brutopia> or is there more elegant way to do it
11:20:24 <pumpkin_> brutopia: or you might as well write a full list yourself
11:20:37 <pumpkin_> [itoa (div num 10), mod num 10]
11:20:40 <koeien> brutopia: [itoa (div num 10), mod num 10]
11:20:47 <brutopia> ah, thank you very much
11:20:48 <koeien> brutopia: but why not use a tuple?
11:20:54 <mathijs> pumpkin_: thanks, that's what I'm referring to I think
11:21:17 <brutopia> would tuple be more appropriate for this
11:21:19 <koeien> brutopia: also, personally, i like   num `div` 10   better than div num 10
11:21:30 <pumpkin_> brutopia: I'd say so
11:21:30 <raji> i'm a good C programmer. I want to learn functional programming. Which are good books to functional programming concepts rather than language more at a tutorial level ?
11:21:43 <ozy`> ^ that definition of itoa still won't work
11:21:43 <koeien> brutopia: yes, if you always return the same number of elements, a tuple is far better
11:21:50 <brutopia> I dislike the backticks
11:21:57 <Peaker> raji, I think learning the language from a tutorial will be a good gateway to learning FP concepts too
11:22:12 <ozy`> raji: learn by doing. that's the best way.
11:22:16 <brutopia> koeien: that's what I suspected, my function converts arbitrary number to array of digits of that number so tuple wouldn't be very good with that
11:22:30 <Ferdirand> q
11:22:33 <Ferdirand> oops
11:22:45 <pumpkin_> koeien: but your list only has two elements
11:22:49 <brutopia> itoa = integer to ascii as in c programming but I'm not actually converting anything to ascii
11:22:54 <raji> Peaker: ozy` : i read haskell tutorial, i could understand until first few pages. Then it is over my head
11:23:03 <brutopia> my function was recursive
11:23:25 <Peaker> raji, which tutorial?
11:23:28 <pumpkin_> brutopia: it wouldn't work like that
11:23:39 <brutopia> why?
11:23:54 <pumpkin_> because you were constructing an infinite type :P
11:24:00 <pumpkin_> you need the right-hand side of the : to be the list
11:24:05 <koeien> pumpkin_: yeah
11:24:06 <pumpkin_> the left side is the element
11:24:13 <paper_cc> @ty unfoldr
11:24:14 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:24:14 <koeien> pumpkin_: i didn't look at all at the expression really
11:24:15 <brutopia> I have a special case declaration for 0
11:24:22 <raji> Peaker: http://www.haskell.org/tutorial/
11:24:22 <pumpkin_> koeien: me neither :)
11:24:28 <pumpkin_> brutopia: still a problem
11:24:31 <pumpkin_> :t (:)
11:24:32 <lambdabot> forall a. a -> [a] -> [a]
11:24:42 <pumpkin_> if a is [a]
11:24:50 <pumpkin_> then you have an infinite type there :)
11:25:06 <Peaker> raji, try http://learnyouahaskell.com   or   http://realworldhaskell.org
11:25:20 <brutopia> so I have to declare the type signature so it wouldn't be infinite?
11:25:23 <pumpkin_> brutopia: you might want to make an explicit accumulator
11:25:23 <paper_cc> > let digits x = unfoldr (\x -> return . (snd&&&fst) $ x `divMod` 10) x in digits 12345
11:25:25 <lambdabot>   [5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
11:25:30 <paper_cc> oops =)
11:25:43 <pumpkin_> brutopia: nope, you either need to generate the list backwards or rethink how you're doing it
11:26:00 <koeien> brutopia: generating it backwards and then reversing it in the end is fine
11:26:51 <ozy`> brutopia: itoa = reverse . ih where ih n = if n < 10 then [n] else mod n 10 : ih (div n 10)
11:27:21 <ozy`> > let ih n = if n < 10 then [n] else mod n 10 : ih (div n 10) in (reverse . ih) 1250
11:27:23 <lambdabot>   [1,2,5,0]
11:27:35 <pumpkin_> > itoa = show :: Int -> String :D
11:27:36 <lambdabot>   <no location info>: parse error on input `='
11:27:39 <ozy`> this will break on some numbers, but oh well
11:28:03 <ozy`> (ie. anything negative)
11:28:23 <pumpkin_> we need a Natural type :P
11:28:34 <paper_cc> > let digits = map read . show :: Int -> [Int] in digits 12340
11:28:35 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
11:28:36 <koeien> pumpkin_: define (-) on Natural
11:28:49 <pumpkin_> koeien: I don't :) we also need a new Num typeclass :P
11:28:54 <paper_cc> koeien: define Semigroup =)
11:29:29 <koeien> paper_cc: class Semigroup a where (+*+) :: a -> a -> a
11:30:13 <whpearson> > let itoa num = if num < 10 then [num] else itoa (div num 10) ++ [mod num 10] in itoa 999
11:30:13 <mm_freak> > map (`rem` 10) . iterate (`div` 10) $ 12345
11:30:15 <lambdabot>   [9,9,9]
11:30:15 <lambdabot>   [5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
11:30:16 <koeien> pumpkin_: yeah but Naturals make subtraction partial :(
11:30:28 <pumpkin_> but I'm partial to Naturals
11:30:28 <koeien> pumpkin_: or at least not well behaving in some cases
11:30:32 <pumpkin_> so that's fine :)
11:30:43 <mm_freak> > map (`rem` 10) . takeWhile (> 0) . iterate (`div` 10) $ 12345
11:30:44 <pumpkin_> this concept of negativity is too abstract for me
11:30:44 <lambdabot>   [5,4,3,2,1]
11:30:46 <Elly> I think integers are obviously where it's at
11:30:54 <paper_cc> > map (`rem` 10) . takeWhile (> 0) . iterate (`div` 10) $ 123450
11:30:55 <lambdabot>   [0,5,4,3,2,1]
11:31:09 <koeien> pumpkin_: oh no, it's easy. an integer is a tuple of two natural numbers (a, b)  together with a relation ~ ... :)
11:31:21 <pumpkin_> zomg
11:31:24 <gueux> hi :-)
11:31:39 <gueux> I am trying to implement a little game server
11:31:39 * pumpkin_ 's head splatters all over the wall
11:32:13 <mm_freak> pumpkin_: it's really not that hard
11:32:14 <gueux> but I have a problem to save the current state of the game
11:32:25 <pumpkin_> mm_freak: just being silly :)
11:32:42 <gueux> and to allow a user (when it's his turn) to modify it (for everybody)
11:32:49 <mathijs> I got the parListChunk working, but reading about Strategies raised a lot of questions, is there a simple (not too scientific) tutorial about them?
11:32:49 <gueux> here is my code
11:32:52 <gueux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1517#a1517 [+]
11:32:57 <mm_freak> just ask yourself, which problem integers solve, which natural numbers can't solveâ€¦  state that problem as an equation and consider each solution of that equation an integer number =)
11:33:22 <gueux> do you know how I could do?
11:33:28 <mm_freak> the same way you can construct rational numbers from integers
11:33:50 <pumpkin_> :)
11:35:26 <mathijs> my main questions are: what's the difference between r0 and rnf, and what difference will parMap make from parListChunk. I understand that chunking will divide the data in chunks, helping to get the right number of threads for the right number of cores, but what will parMap do? just keep on creating new threads even if all cores are busy?
11:35:57 <mm_freak> mathijs: look at:  fix (1:)
11:35:58 <pumpkin_> mathijs: parListChunk is a strategy you can use on parMap, that is built from things from r0 and rnf
11:36:01 <mm_freak> r0:  THUNK
11:36:08 <mm_freak> rwhnf:  1:THUNK
11:36:14 <mm_freak> rnf:  1:1:1:1:1:â€¦
11:36:58 <ziman> mm_freak, rwhnf: THUNK:THUNK :)
11:36:59 <gueux> the first player would have to enter the size of the board and then play the first turn
11:37:13 <mathijs> mm_freak: so rnf 'flattens'/evaluates everything to values, rwhnf just what's needed, and r0 doesn't at all?
11:37:23 <mm_freak> ziman: oh yeah, of course =)
11:37:39 <mm_freak> mathijs: rwhnf resolves one level of data abstraction, in informal words
11:38:02 <pumpkin_> mathijs: I wouldn't say rwhnf does just what's needed
11:38:09 <gueux> then it would be to the second player, but I need to have the same board for both of them
11:38:10 <ziman> it forces the outermost constructor
11:38:13 <pumpkin_> what's needed depends on your program
11:38:17 <mm_freak> pumpkin_: but that's not true
11:38:49 <gueux> and to allow modifications by both of them, too
11:38:54 <rwbarton> rwhnf does just what's needed to check whether a value is _|_
11:39:16 <pumpkin_> mm_freak: what's not true?
11:39:27 <gueux> so, I can't see how to do without an imperative structure...
11:39:28 <mm_freak> <pumpkin_> mathijs: I wouldn't say rwhnf does just what's needed
11:39:33 <mm_freak> r0 does only what's needed
11:39:39 <mm_freak> rwhnf may do more
11:40:01 <pumpkin_> how was my statement untrue? :P
11:40:04 <mehrheit> gueux: is each player served in a different thread?
11:40:29 <mm_freak> pumpkin_: as said =)
11:40:38 <monochrom> r0 does nothing, rwhnf is like seq. If I read the docs correctly.
11:40:39 <gueux> mehrheit: yes
11:41:21 <gueux> but maybe they should be in the same thread... I don't very well
11:41:26 <gueux> how to do it
11:41:52 <brad_larsen> is compile-time IO in template haskell not fully implemented?
11:41:53 <mm_freak> monochrom: exactly
11:41:57 <mehrheit> gueux: then you'll probably need to use either IORefs or software transactional memory, since you need coordination between the threads
11:42:29 <mehrheit> gueux: I think threads are suitable here, since each player should be able to interact with the server concurrently
11:42:37 <mm_freak> uhmâ€¦  for a game state, i'd use a separate management thread, which you can access through an MVar
11:43:18 <Itkovian> pejo: 6.8.3 has been built! Bootstrapping 6.10.1 now using that.
11:43:23 <Itkovian> pejo: Thx.
11:43:41 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1288 â‡ here is an old example of how this works
11:43:48 <pumpkin_> brad_larsen: like what?
11:45:40 <brad_larsen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1518#a1518
11:45:45 <brad_larsen> uhhh, have a look at that
11:46:12 <brad_larsen> i'm calling `sleep', and it should be executed at splice time
11:46:15 <brad_larsen> unless i am very confused
11:46:23 <brad_larsen> but it appears to do nothing
11:46:45 <brad_larsen> i'm expecting ghci, or the compiler, or whatever, to sleep for a few seconds when it encounters
11:46:50 <brad_larsen> $(sleeper 5)
11:46:51 <lunabot>  luna: Not in scope: `sleeper'
11:46:53 <pumpkin_> why not threadDelay ?
11:47:11 <brad_larsen> i was just experimenting
11:47:20 <brad_larsen> @type threadDelay
11:47:20 <pumpkin_> there was a post on cafe recently about sleep not doing what you expect it to
11:47:21 <lambdabot> Not in scope: `threadDelay'
11:47:26 <pumpkin_> @hoogle threadDelay
11:47:27 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
11:47:57 <rwbarton> brad_larsen: in my experience the IO in a TH splice happens about 4 times
11:48:33 <pumpkin_> brad_larsen: http://www.mail-archive.com/haskell-cafe@haskell.org/msg53534.html
11:48:43 <brad_larsen> pumpkin, threadDelay doesn't hold up ghci, either
11:49:06 <brad_larsen> pumpkin, whoops, let me retry
11:49:40 <brad_larsen> there it goes!
11:49:44 <pumpkin_> it's in microseconds :)
11:49:46 <brad_larsen> yes
11:49:47 <pumpkin_> (btw)
11:50:12 <brad_larsen> so i guess i'm experiencing the ``sleep not working'' from that thread, in TH IO
11:50:34 <brad_larsen> but it sounds like in general, any IO action could be performed by TH?
11:50:44 <brad_larsen> e.g. socket IO, file IO, ...
11:50:58 <pumpkin_> don't see why not
11:51:34 <brad_larsen> ok.  Just trying to determine the limits of TH :-)
11:52:06 <brad_larsen> a more pragmatic question about TH now.
11:52:08 <pumpkin_> it's mostly limited in that it doesn't support many of GHC's extensions
11:52:13 <monochrom> Yes, TH can do IO. You can instruct the compiler to play a movie.
11:52:23 <brad_larsen> monochrom, lol
11:52:52 <brad_larsen> Suppose I have a string value, bound to name `str' at splice time
11:53:01 <monochrom> "Thank you for building GHC using GHC. While you wait, please enjoy this complimentary movie from the Catsters!"
11:53:17 <brad_larsen> how can I parse that string into ExpQ?
11:53:36 <brad_larsen> (I'm trying to implement a perl-like HERE doc quasiquoter)
11:54:58 <brad_larsen> i have it partially working, but I want to be able to be able to escape haskell expressions, e.g. [$here|this is a here doc, 5 + 2 is ${5 + 2}|]
11:55:13 <brad_larsen> so, take the string inside ${ ... }
11:55:52 <brad_larsen> and evaluate it as Haskell, at splice time
11:56:02 <brad_larsen> any ideas?
11:56:27 <cnwdup> @source ReaderT
11:56:27 <lambdabot> ReaderT not available
11:56:30 <cnwdup> @source Reader
11:56:30 <lambdabot> Reader not available
11:57:52 <athos> , src ''Reader
11:57:55 <lunabot>  newtype Reader i a = R' {unR :: (ReaderT i Id a)}
11:57:59 <pumpkin_> @src Reader
11:57:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:58:05 <cnwdup> @src Reader (>>=)
11:58:05 <lambdabot> Source not found. My brain just exploded
11:58:25 <cnwdup> Well, I found it via google.
12:01:44 <whpearson> Is it worth trying to patch ghc to have the Min and Max monoid as standard?
12:02:33 <rwbarton> whpearson: how about a libraries proposal?  it sounds like a good idea to me
12:02:33 <asgaroth> whpearson: I don't think that structure of yours forms a monoid, since by definition, a monoid has to have neutral element
12:02:44 <rwbarton> oh oops :P
12:03:01 <rwbarton> Well, if you also have Bounded you can make monoids
12:03:11 <pumpkin_> on Float/Double
12:03:13 <pumpkin_> you could say so
12:03:21 <whpearson> Yeah I was going with Bounded.
12:03:21 <pumpkin_> but then you have to deal with NaN
12:05:01 <whpearson> pumpkin_: Then I should make it Ord as well?
12:05:07 <whpearson> @instances Ord
12:05:07 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:05:19 <asgaroth> It would probably be possible to use (Infinity,-Infinity) as a neutral element when dealing with Double-pairs.
12:05:26 <asgaroth> but I don't think that constructor is exported
12:05:29 <pumpkin_> well, if you're talking about Max and Min it seems reasonable to expect Ord?
12:06:33 <whpearson> Asgaroth: I was just going to define Min and Max separately, then make a tuple of one of each.
12:07:16 <whpearson> rwbarton: I'll try to get something working, then where should I submit it too? Hackage?
12:07:32 <asgaroth> yes, also a possibility if you have an upper/lower limit you already know
12:07:53 <whpearson> Asgaroth: Bounded gives you that.
12:08:57 <asgaroth> you lose some generality with that though
12:09:12 <asgaroth> (e.g. you can't use Integer)
12:09:29 <rwbarton> Right, and then you don't get a monoid.
12:10:13 <rwbarton> whpearson: there's something specific you're supposed to do, hang on
12:10:38 <whpearson> > NaN < 1.0
12:10:39 <lambdabot>   Not in scope: data constructor `NaN'
12:11:17 <rwbarton> whpearson: http://www.haskell.org/haskellwiki/Library_submissions
12:11:49 <rwbarton> whpearson: it should go alongside Sum and Product in Data.Monoid
12:12:00 <whpearson> rwbarton: Thanks. That was what I was thinking.
12:12:13 <rwbarton> (in fact, in some sense it is the same thing!)
12:12:17 <rwbarton> er, pair of things
12:15:13 <whpearson> NaN doesn't seem to be greater, less than or equal to 0.0.... so if I code it right it shouldn't ever go in.
12:15:34 <asgaroth> > Infinity > 1
12:15:35 <lambdabot>   Not in scope: data constructor `Infinity'
12:15:41 <asgaroth> > 2.12^2180300123231
12:15:43 <lambdabot>   Infinity
12:15:50 * whpearson gets to work
12:17:00 <asgaroth> > let x = 2.0^231882319831 in x > x-1
12:17:01 <lambdabot>   False
12:20:10 <ksf> > nan == nan
12:20:12 <lambdabot>   Not in scope: `nan'Not in scope: `nan'
12:20:29 <ksf> > 0/0 == 0/0
12:20:31 <lambdabot>   False
12:20:37 <whpearson> > sqrt (-1) == sqrt (-1)
12:20:38 <lambdabot>   False
12:20:40 <ksf> whpearson, nan isn't even equal to itself.
12:21:27 <whpearson> Heh.
12:21:40 <ksf> it's just undefined in disguise.
12:22:13 <monochrom> It's IEEE 754's way to say undefined, error, exception, bad bad bad, ...
12:22:19 <LeoD> has anyone used HsSyck before? it's giving me lots of \NULs in the strings it reads..
12:22:23 <ksf> yeah.
12:22:26 <icqn> > sqrt (-1)
12:22:27 <lambdabot>   NaN
12:22:53 <roconnor> > sqrt (-1) :: CReal
12:23:07 <ksf> > sqrt (-1) :: Complex
12:23:08 <lambdabot>   thread killed
12:23:09 <lambdabot>       `Complex' is not applied to enough type arguments
12:23:09 <lambdabot>      Expected kind `?...
12:23:15 <roconnor> > sqrt (0) :: CReal
12:23:16 <ksf> > sqrt (-1) :: Complex Double
12:23:18 <lambdabot>   0.0
12:23:18 <lambdabot>   (-0.0) :+ 1.0
12:23:27 <roconnor> > sqrt (-1) :: Complex CReal
12:23:29 <lambdabot>   0.0 :+ 1.0
12:24:02 <roconnor> > (-0.0)
12:24:03 <lambdabot>   -0.0
12:24:14 <Gracenotes> >:-x
12:24:16 <Gracenotes> <.<
12:24:30 <icqn> -.-
12:25:11 <tehgeekmeister> is there an easy way to grab an old version of a file out of darcs without reverting the repository at all?  i just want to see an older version.
12:25:37 <roconnor> #darcs ?
12:26:35 <tehgeekmeister> oh, right
12:31:43 * gwern wonders how many days I should wait before snidely commenting to dons that some sort of deadline on the logo voting would've been really really good
12:32:23 <mornfall> What logo vote?
12:32:41 <gwern> precisely
12:35:20 <roconnor> gwern: voting is a silly idea.  We need a benevolent dictator
12:35:23 <yrlnry> It's been going on since 1988.
12:35:46 * whpearson votes for dons to be the benevolent dictator!
12:36:01 <gwern> roconnor: what's even sillier is saying 'we need a perfect voting process. let's start looking for one. and we won't set a deadline of any kind'
12:36:02 <gnuvince> Pick this one: http://media.nokrev.com/junk/haskell-logos/logo1.png
12:37:45 <tehgeekmeister> in a lambda in an expression inside the state monad, get >>= foo is legal?
12:38:25 <mauke> regardless of context, why would get >>= foo be illegal?
12:38:58 <tehgeekmeister> mauke: it doesn't work in a where clause
12:39:11 <mauke> sure it does
12:39:15 <tehgeekmeister> it does?
12:39:29 <tehgeekmeister> i must've done something else wrong, then
12:39:32 <temoto> I'm reading Practical Monads. It's awesome paper. It even helped me to discover how bad browser is - it doesn't have an option to wrap lines of text/plain. But i need comment.
12:39:54 <tehgeekmeister> man that would've made all this code much simpler if i'd known that.
12:41:55 <temoto> It says "there's ambiguity in  do  text <- getLine ; length text    -- whether to deal with text as String or as IO String" and i perfectly understand it
12:43:33 <temoto> But then it says we introduce   return  ::  a -> IO a   so it takes pure value and creates a computation which does nothing and produces that value.
12:43:52 * whpearson sighs at checking out ghc head from darcs
12:44:26 <temoto> (btw git is so much faster :) )
12:44:57 <pumpkin> that's pretty much a tautology
12:45:14 <tehgeekmeister> gwern: there's a logo vote?
12:45:45 <gwern> tehgeekmeister: no. that's the problem
12:46:03 <tehgeekmeister> i like that one linked up there a lot, i'd vote for it if there were a vote.
12:46:19 <temoto> And i completely don't understand it. Instead of having another IO a, no, no, i want  IO a -> a, i want to take something IO-ish a pure value and then i know how to compute it's length.
12:46:44 <pumpkin> temoto: unsafePerformIO :P
12:46:47 <pumpkin> ;)
12:47:05 <mauke> temoto: the solution is >>=
12:47:13 <temoto> pumpkin: meh i'm trying to understand the paper :)
12:47:14 <rwbarton> pumpkin is lying.  There's no such thing as unsafePerformIO.
12:47:17 <tehgeekmeister> mauke: the problem i was having is that i was doing something like get >>= fooThatDoesn'tEvaluateToSomethingMonadic, which obviously won't work.  but that's precisely what i want to do.  how do i lift just the return result of that expression into the monad, so it can be on the tail end of >>= ?
12:47:19 <gwern> no! the solution involves spacesuits
12:47:29 * pumpkin hangs head in shame
12:47:33 <lament> spacesuits filled with oranges? :\
12:47:34 <mauke> tehgeekmeister: in general, 'return'
12:47:44 <mauke> tehgeekmeister: in this case, just use fmap
12:47:53 <rwbarton> tehgeekmeister: or even more specifically, gets
12:47:55 <rwbarton> @type gets
12:47:56 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
12:48:22 <tehgeekmeister> oh that's cool
12:48:38 <temoto> mauke: i don't understand why paper introduces return :: a -> IO a... i don't have `a` atm, i have `IO a` which is returned by getLine.
12:49:04 <rwbarton> temoto: well what do you want to do with the line?
12:49:14 <temoto> Does it relates to   text <- getLine   being inside do-notation?
12:49:15 <pumpkin> temoto: then you use >>=
12:49:17 <mauke> temoto: the answer is still >>=
12:49:27 <tehgeekmeister> mauke: err now i run into another problem, i'm realizing.  i don't want that result to be in the monad.  which i think means i'm screwed.
12:49:29 <mauke> temoto: <- in do notation is syntactic sugar for >>=
12:49:30 <Nafai> When does it make sense to use the State monad?
12:49:44 <rwbarton> tehgeekmeister: but of course it has to be, after all the value depends on the state
12:50:02 <Nafai> I have a single recursive function where I am explicitly passing state around (state, in this case, is a map that is built up over time)
12:50:17 <Nafai> Would it make my code better to switch to using State?
12:50:32 <temoto> mauke: oh what do you know... it's a sugar :)   so   do text <- getLine   is    text >>= getLine   outside of do-notation?
12:50:36 <tehgeekmeister> Nafai: you could do that very easily in state.  i'm doing precisely that.
12:50:44 <tehgeekmeister> Nafai: but you could do it without state, too
12:50:48 <mauke> temoto: no, it's getLine >>= \text -> ...
12:50:55 <rwbarton> Nafai: Depends on how much code you have that looks like   let (x, s') = foo s; (y, s'') = bar x s'; ... in ...
12:51:15 <tehgeekmeister> rwbarton: i know.  what i was trying to do was grab the state and then export it to pure code.  =/
12:51:28 <temoto> mauke: getLine >>= \text -> length text   ?
12:51:31 <Nafai> rwbarton: Not a ton, as exists now: http://gist.github.com/66138
12:51:31 <tehgeekmeister> but that's the point!  you can't get things out of a monad.
12:51:38 <Nafai> rwbarton: (seenMap is the state)
12:51:44 <mauke> temoto: yes, except that's a type error
12:51:56 <temoto> mauke: thank you.
12:52:04 <mauke> temoto: see also http://mauke.ath.cx/stuff/haskell/how-to-io.html :-)
12:52:08 <Nafai> But I'm trying to figure out how to turn this function into something that uses things like fold, filter, and map instead of recursion
12:52:45 <Nafai> And wondering if State would help in utilizing other abstractions
12:53:01 <tehgeekmeister> Nafai: you can do that using maybe and forM_
12:53:08 <gwern> Nafai: sic hlint on it. if it doesn't find valid transformations, send them to ndm!
12:53:26 <Nafai> gwern: Yeah, hlint doesn't give me any info on this file :)
12:53:49 <gwern> Nafai: well then. I guess you've got your work cut out for you
12:54:03 <Nafai> gwern: Well, actually, hlint won't parse it now
12:54:11 <Nafai> gwern: Because of the bang pattern, I imagine
12:54:38 <tehgeekmeister> Nafai: something like forM_ list (maybe (return) monadicActionThatAcceptsAJustValue)
12:54:40 <Nafai> Prior to adding the bang pattern, I encorporated all hlint suggestions
12:54:52 <tehgeekmeister> Nafai: but i may not have that perfectly.
12:55:03 <jpcooper> are type-declarations allowed in do-blocks?
12:55:12 <rwbarton> Nafai: ah, in this case, you can write better code using the state monad because of mapM_
12:55:29 <blackh> Nafai: This doesn't answer your question, but I've started using the state monad for simple cases of modifying some state if some condition is true otherwise leaving it the same.
12:55:31 <rwbarton> you could equivalently use mapAccum[LR]
12:55:50 <tehgeekmeister> yeah, that'd do too.
12:55:59 <tehgeekmeister> and then you wouldn't have to wrap it in execState or some such
12:56:10 <Nafai> Interesting
12:56:30 <Nafai> The problem I was trying to wrap my head is around is how to update the map in this process
12:56:53 <blackh> Nafai: e.g. storage' = flip execState storage $ when (button == text_Delete) $ modify $ filter (\x -> x /= selected)
12:57:52 <whpearson> @instances Bounded
12:57:53 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
12:58:04 <rwbarton> Nafai: why not build a Map of (ID, number of occurrences) using M.fromListWith and then use M.keys?
12:58:11 <blackh> Nafai: Updating the map would be ... modify $ Map.insert anId (count + 1)
12:58:13 <rwbarton> I guess that will sort the keys
12:58:52 * Nafai tries to understand blackh's example
12:59:16 <blackh> Nafai: My example deletes the selected item from a list in a web application when the user has clicked the "delete" button
12:59:59 <CTA> Heyy guys :)
13:00:09 <jkff> btw, regarding maps: I wonder why there is still no hashtable package on hackage based on MArray. I've almost written one today, but hey, didn't anyone else need it before me?
13:00:37 <jkff> CTA: hi
13:00:40 <Nafai> I'm actually considering switching this code to using Data.Set because I really don't use the count anywhere else
13:00:45 <Nafai> I just need to know if something has been seen before
13:00:55 <rwbarton> Nafai: then it will be S.fromList . S.toList :)
13:01:00 <rwbarton> er, other order
13:01:06 <blackh> Nafai: In this case the state monad doesn't give me much but if the condition is really complicated, it can work quite well.
13:01:30 <Nafai> Cool
13:01:38 <Nafai> I wish I wasn't at work, I want to improve this code :)
13:01:41 <rwbarton> (again it will sort the keys)
13:01:45 <jkff> Nafai: Are you just going to take distinct elements? If so, then map head . sort . group will work a lot faster
13:02:05 <Nafai> jkff: Well, distinct elements, but I'm keeping a history
13:02:21 <jkff> What kind of history?
13:02:21 <Nafai> jkff: The function that calls this loads a serialized state from disk and then stores it again afterwards
13:02:45 <Nafai> So basically I only want to show unique items that I have never seen before on any run of this program
13:03:08 <CTA>   #haskell      what do you call the #? sharp?
13:03:20 <roconnor> hash
13:03:29 <jkff> Nafai: But how does that influence the choice of Data.Map?
13:03:32 * rwbarton just pronounces it '#'
13:03:49 <CTA> haskell = has-kell
13:03:51 <CTA> ?
13:03:51 <roconnor> octothorp!
13:03:55 <Nafai> jkff: I don't care about counts
13:03:55 <CTA> how do you pronounce?
13:04:35 <true\false> Hask-L
13:04:36 <jkff> Nafai: Well, the choice of Data.Set, then :) Do you mean that you are storing the Data.Set in some serialized form that is more efficient than sorting everything from scratch?
13:04:41 <pumpkin> CTA: HAS KILL (ED PEOPLE)
13:04:53 <true\false> pumpkin? oO
13:05:45 <rwbarton> Nafai: oh, I see, you might call deDupItems' with nonempty seenMap, and you really want both pieces of output
13:06:07 <CTA> how you get that type of info? who you bribe!!
13:06:21 <mmorrow> brad_larsen: i actually have a QQ that does exactly that
13:06:33 <mmorrow> brad_larsen: i'll paste it
13:06:43 <rwbarton> Nafai: Using the State IdCountMap monad here might be convenient for the caller of your function also
13:07:43 <Nafai> jkff: What do you mean "sorting everything from scratch"?  Instead of serializing a Data.Set, serialize a list?
13:07:44 <temoto> mauke: so after  text <- getLine,   text is already pure [Char] type?
13:07:49 <Nafai> rwbarton: *nods*
13:07:52 <mauke> temoto: yes
13:08:00 <jkff> Nafai: Yes
13:08:36 <jkff> Nafai: If you are going to use a serialized set in a substantially more efficient way than serializing a list, you are probably going to write an ad-hoc database :)
13:08:45 <mmorrow> brad_larsen: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1450#a1450
13:08:54 <brad_larsen> mmorrow, thanks, i'll take a look
13:09:10 <Nafai> jkff: Heh.  Well, what you see in that function is the extent of how I'm using the data
13:09:48 <CTA> LYAH ios quite nice :)
13:10:09 <Nafai> rwbarton: That's what I'm guessing, I'm going to dive into it tonight, hopefully
13:10:13 <jkff> You mean http://gist.github.com/66138 ? That code doesn't mention serialization at all. How big are the sets and how often are you serializing / deserializing them?
13:10:19 <mmorrow> (i had to steal your example "5 + 7 is $(5 + 7)"  as "[0..4] is $([0..4])" since it's a perfect way to illustrate it ;)
13:11:12 <mauke> the last example looks broken
13:11:19 <mauke> why is there a \ in the output?
13:11:43 <temoto> mauke: i've heard that it is not possible to make pure value out of monadic one,.. did i misunderstood something?
13:11:59 <rwbarton> jkff: he has some state (the visited ids) which naturally forms a set, why would he convert it to a list and back every time he wants to add to it?
13:12:05 <mauke> temoto: well, this is only local
13:12:21 <mauke> temoto: the type of >>= ensures that everything will end up in IO (or whatever monad) again
13:12:27 <temoto> mauke: you mean only inside do-notation ?
13:12:28 <jkff> rwbarton: Ah, so the set is built incrementally. That changes things substantially.
13:12:44 <mauke> temoto: no, in the function given to >>=
13:12:44 <mathijs> mm_freak: I played around with the parallel strategies a bit. Am I correct to assume that the 'rnf' strategy is almost always what's wanted when parallelizing?
13:12:47 <rwbarton> jkff: That's my guess
13:13:37 <temoto> mauke: so  text <- getLine  here i have "function" text?
13:13:53 <mmorrow> brad_larsen: crap, i just noticed a typo
13:14:16 <mauke> temoto: no, 'text' is the function parameter
13:14:24 <Nafai> jkff, rwbarton: http://github.com/Nafai77/recent-feeds/blob/009295631438ddef7658dd97190d5cec326516ef/recent-feed.hs <- here's the entire program
13:14:25 <mauke> everything after that is the function body
13:14:36 <CTA> what would be a good book for learning haskell?
13:14:46 <Nafai> CTA: Real World Haskell
13:14:47 <mmorrow> fixed http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1450#a1451
13:14:55 <CTA> real world, is there any others? book form haskell not LYAH
13:14:56 <temoto> mauke: oh man that makes  return (length text)  perfectly reasonable and clear!
13:15:16 <mauke> temoto: really? cool :-)
13:15:32 <mmorrow> (it was '[' and ']' instead of '(' and ')' in the last two cases of `go' in the where of oneP (since i converted this from another QQ))
13:16:08 <mathijs> CTA: RWH and LYAH are really the best 2 books/tutorials for starting haskell
13:16:09 <gwern> @where rwh
13:16:09 <lambdabot> is http://www.realworldhaskell.org/blog/
13:16:12 <temoto> mauke: It even reads like imperative languages i'm used to.   text <- getLine ; return (length text)   like assigned variable and calculated its length.
13:16:33 <mauke> temoto: yes, but 'return' doesn't return :-)
13:16:37 <temoto> mauke: the only thing bothers me is that after return there could be other stuff, right?
13:16:46 <mathijs> temoto: mind you, return is nothing like return in any imperative language
13:17:10 <brad_larsen> mmorrow, the quasiquoter in the Language.Haskell.Meta.QQ.Here does interpolation like this?
13:17:24 <temoto> mauke: so where is ending of that function that starts after <- ?
13:17:27 <ksf> the easiest thing might be to read "return" as "pure".
13:17:33 <mmorrow> brad_larsen: looking at `oneP', i'm not positive there aren't little weird side-case bug/oversights... i haven't tested/used this much yet
13:17:37 <mauke> temoto: at the end of the do block
13:17:43 <ksf> it's the same, and doesn't have any evil associations.
13:17:57 <chessguy_work> preflex: seen geezusfreeek
13:17:57 <preflex>  geezusfreeek was last seen on #haskell 1 day, 21 hours, 18 minutes and 32 seconds ago, saying: andy6, perhaps you would get better results from a channel more specific to irc?
13:18:12 <temoto> mauke: but there may be two getLine inside do block...
13:18:23 <mmorrow> brad_larsen: no, that one just does basic strings. i wrote this the other day
13:18:38 <mathijs> temoto: than that function (the do block) is a function that reads 2 lines
13:19:01 <jkff> Nafai: Looks like your scenario is "Read a set from file, add some items to it, write the set back to file". Then, looks like you don't really need much a Data.Map, and a list will really do; besides, you will have the advantage of the file being human-readable.
13:19:14 <temoto> mauke: so do is function, not getLine?
13:19:21 <CTA> :l myfile == :load myfile ?
13:19:27 <ksf> return just shoves a value into a monad, the thing that's _really_ returned from a do-block is the result of its last statement.
13:19:31 <mathijs> CTA: yes
13:19:31 <mmorrow> brad_larsen: i'm planning on uploading this one to hackage either as its own pkg or as another in the group in ...QQ.* in haskell-src-meta
13:19:37 <FunctorSalad_> hmm, a Data.Map is just shown as fromList [....] I think :)
13:19:48 <mauke> temoto: do { x <- getLine; y <- getLine; return (x ++ y) } is syntactic sugar for getLine >>= (\x -> getLine >>= (\y -> return (x ++ y)))
13:19:50 <temoto> mathijs: so do is function, not getLine?
13:19:52 <mmorrow> but it's pretty self-contained..
13:20:03 <mauke> temoto: what do you mean?
13:20:21 <Nafai> FunctorSalad_: Yes
13:20:25 <brad_larsen> mmorrow, aha.  I got the feeling from looking at the TH docs that there wasn't a way to take a non-literal string and parse it into an Exp.
13:20:32 <Nafai> jkff: True, a list might work.  Just wondering about when this gets bigger how slow the searches will be
13:20:32 <temoto> sorry i'm confusing mathijs and mauke :)
13:20:40 <ksf> do isn't a function, it's syntactic sugar for foo >>= (\x -> bar x >>= ...
13:20:47 <mathijs> temoto: like mauke said. it's another way of writing. it means 'combine these functions and feed their results to each other in a certain way'
13:21:08 <FunctorSalad_> speaking of that, is there some deeper reason why fromList isn't a typeclass method or is it just legacy?
13:21:11 <brad_larsen> mmorrow, in the code you pasted, it looks like you are using a haskell parser you wrote (Language.Haskell.Meta.Parse), no?
13:21:22 <temoto> my god... in a certain way even..
13:21:23 <Nafai> rwbarton: So would State make sense here?
13:21:24 <ksf> temeto, observe that getLine and return "foo" have the same type: IO String.
13:21:27 <jkff> Nafai: There are no searches: you read the list from file, append to it the list from feed, and map head . group . sort the result.
13:21:31 <mmorrow> brad_larsen: exactly. that's the crucial piece
13:21:39 <brad_larsen> mmorrow, i didn't want to have to write all that myself.  :-)
13:21:43 <jkff> Or you can read the list from file and put it into a Data.Set if you like :)
13:22:05 <jkff> However that will be slower
13:22:12 <mathijs> temoto: don't worry, just pretend the IO stuff to be imperative-like for now and don't put stuff after return.
13:22:12 <temoto> Thanks guys, i guess i understand this part. Back to reading.
13:22:13 <drguildo> i seem to remember a copy of the ghc standard library docs that had links to the source code, but i can't seem to find it anywhere. am i imagining things?
13:22:18 <Nafai> jkff: *nods*
13:22:19 <jkff> Unless you have a small file and a big big big feed
13:22:19 <ksf> (return "foo" has type Monad m => m String, but that's beside the point)
13:22:41 <ksf> return--
13:22:42 <gwern> @seen byorgey
13:22:42 <lambdabot> byorgey is in #haskell-overflow, #haskell-in-depth, #haskell-blah, #xmonad and #haskell. I last heard byorgey speak 2h 43m 47s ago.
13:22:54 * ksf thinks it's the worst named function in all of haskell.
13:22:58 <gwern> @tell byorgey when I try http://www.cis.upenn.edu/~byorgey/papers/typeclassopedia-draft-090216.pdf I get access forbidden. linked from your blog
13:22:59 <lambdabot> Consider it noted.
13:23:06 <mathijs> anyone?... I played around with the parallel strategies a bit. Am I correct to assume that the 'rnf' strategy is almost always what's wanted when parallelizing?
13:23:18 <mmorrow> brad_larsen: yeah, once haskell-src-meta can deal with parsing TH splices and QQ syntax themselves, we'll almost be at the point where we can reflect
13:23:47 <mmorrow> (to get there, the final piece would be an `eval' function)
13:24:12 <mmorrow> which is possible, but you have to link to ghc to get it, which brings your executable to 14MB+ after stripping min
13:24:27 <Nafai> jkff: Each feed is 100 items, but this will be run over a long time, so I could eventually see numbers in the 10k's in the list
13:24:45 <ksf> you don't necessarily need an interpreter or compiler to implement eval.
13:24:46 <CTA> main :: IO () -- is that saying main does input-output things?
13:25:01 <brad_larsen> mmorrow, you mean run-time eval, right?
13:25:02 <mathijs> CTA: yes
13:25:11 <ksf> CTA, If I were to say yes, it'd be a lie for kids.
13:25:48 <CTA> explain ksf
13:25:48 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
13:25:51 <lunabot>  42
13:25:57 <mmorrow> yeah. it's bytecode though
13:26:12 <mmorrow> so mostly just feasible for compile-time stuff
13:26:25 <ksf> well, main is a value of type IO (), which is interpreted by the run-time system to do input-output things.
13:26:26 * Cheshire cry
13:26:31 <mmorrow> like generating/creating-programmatically code/programs
13:27:30 <ksf> did I scare him away?
13:27:31 <mmorrow> for instance, you could parse the linux kernel, and generate haskell ffi bindings to all the functions user-permissions allow
13:27:51 <mathijs> ksf: dunno, he runs windows, so there might be another reason :P
13:27:58 <mmorrow> $(importLinuxKTHX)
13:27:59 <lunabot>  luna: Not in scope: `importLinuxKTHX'
13:29:23 <mmorrow> you could maybe do this already, and this is of course a random extreme case, but `eval' would make most of the current staging hassles go away
13:29:27 <ksf> you could also parse arbitrary c source or machine binaries and provide a POSIX interface on top of house.
13:29:36 <bd_> mmorrow: Actually, you can't parse the linux kernel like that :)
13:29:50 <bd_> ioctls in particular are too irregular to handle in any automated way
13:29:51 <mmorrow> bd_: well, you'd preprocess it first
13:29:57 <mmorrow> bd_: heh, ok
13:30:02 <mathijs> ksf: house?
13:30:07 <bd_> the sysctl list, otoh, you could
13:30:10 <mmorrow> s/linux kernel/some massive task/
13:30:11 <ksf> the haskell operating system.
13:30:49 <Cheshire> $(3)
13:30:50 <lunabot>  3
13:30:52 <ksf> basically, ghc on bare metal (you've gotta write things like mmap and a couple of others) with bells, whistles and device drivers.
13:31:17 <mmorrow> which would become massively more feasible when being able to manipulate your code and the code which you'll eventually generate
13:31:28 <tehgeekmeister> perhaps slightly off topic: is there a way to redirect ghc's error output from stderror to stdout, so i can actually view all the errors?  i can't figure out the ones at the bottom of the printout yet, so i need a way to view all of it.  =P
13:31:33 <mathijs> ksf: so no underlying kernel?
13:31:44 <olsner> tehgeekmeister: 2>&1 after the command line
13:31:47 <ksf> well, there's the ghc rts.
13:31:56 <mmorrow> house ported ghc to bare metal
13:31:57 <olsner> (if you have a shell that can do that)
13:32:11 <brad_larsen> mmorrow: thanks for the pointers.
13:32:13 <mmorrow> well, iirc they've ported up to 6.8.2
13:32:29 <mmorrow> brad_larsen: no problem :)
13:33:45 <ksf> writing an interface for linux modules would be a cool SoC project for someone metal-inclined...
13:34:51 <mmorrow> the house code is pretty cool to look at
13:35:06 <mmorrow> especially the datatypes modelling an os
13:35:22 <mmorrow> (modeling and becoming)
13:35:51 <tehgeekmeister> is there a function that can take any datatype like data Foo = Foo SomeType and return the SomeType it holds?
13:36:00 <Cheshire> no
13:36:17 <tehgeekmeister> yeah, what type would it have?
13:36:17 <tehgeekmeister> okay.
13:36:50 <ksf> dependent typing would be bleeding cool for an os. imagine a function sync : File -> (f : File | OnPersistentStorage)
13:38:04 <ksf> I mean, I hate to admit it, but even linux tends to crash on me, once or twice a year.
13:38:24 <mathijs> does house only run haskell applications? Or are there gonna be c-bindings? :)  Is it posix-like (or trying to be?) Does it mean all haskell software on it can share 1 RTS?
13:38:36 <Eridius> @src [] mconcat
13:38:36 <lambdabot> Source not found. Do you think like you type?
13:38:42 <ksf> dd if=/dev/urandom of=/proc/kmem
13:38:44 <Eridius> bah
13:39:48 <ksf> mathijs, you can have any feature, as long as it's implemented ... by you.
13:40:41 <mathijs> ksf: ah... not much different from linux then =)
13:41:26 <tehgeekmeister> @type (concat . mapM)
13:41:27 <lambdabot>     Couldn't match expected type `[[a]]'
13:41:27 <lambdabot>            against inferred type `[a1] -> m [b]'
13:41:27 <lambdabot>     Probable cause: `mapM' is applied to too few arguments
13:41:53 <tehgeekmeister> @type (\f -> concat . mapM f)
13:41:54 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
13:42:26 <Eridius> @src concat
13:42:26 <lambdabot> concat = foldr (++) []
13:42:57 <Eridius> huh. Typeclassopedia says mconcat for lists is more efficient than the default (which is foldr mappend mempty, which translates to that same definition of concat)
13:43:54 <tehgeekmeister> @type forM_
13:43:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
13:44:41 <tehgeekmeister> hmm, i want something like forM_ but of type Monad m => [m a] -> (a -> m b) -> m ()
13:44:45 <tehgeekmeister> does it exist?
13:44:56 <Eridius> huh, Typeclassopedia is just plain wrong. Monoid.hs in the ghc 6.10.1 source doesn't redefine mconcat for the Monoid [a] instance
13:45:17 <ksf> tehgeekmeister, which a of all those do you want to use?
13:45:51 <ksf> you can fmap (foldr ...) >>= foo >> return ()
13:45:54 <olsner> ksf: all of them, presumably?
13:46:02 <tehgeekmeister> ksf: yep
13:46:06 <tehgeekmeister> ksf: all of them
13:46:07 <ksf> then you'd need ([a] -> mb)
13:47:03 <olsner> @ty \xs f -> mapM_ (>>= f) xs
13:47:03 <ksf> ... or do you want that m in the middle to be List?
13:47:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [m a] -> (a -> m b) -> m ()
13:47:06 <Taejo> will C++'s allocator kill me if I program in a functional style?
13:47:28 <mauke> C++'s allocator will kill you, period
13:47:40 <ksf> Taejo, your brain will kill you for forcing yourself to be a masochist.
13:48:00 <Taejo> mauke: I'm thinking about insertion into immutable trees, in this case
13:48:06 <olsner> ksf: "... and it will enjoy yourself"
13:48:10 <gueux> is it possible to use a \ with a tuple?
13:48:22 <gueux> \(a,b) -> ...
13:48:28 <gueux> something like that
13:48:29 <blackh> gueux: yes
13:48:29 <mauke> Taejo: and how are you going to keep track of live memory?
13:48:38 <tehgeekmeister> i can make a list of values which are in the monad, and i want to, for each value, take it out of the monad, run some action on it that puts it right back in the same monad, and i don't care about the values, because the side effects are what i'm after.  that's what i want.
13:48:51 <ksf> > (\(a,b) -> a + b)) in (1,2)
13:48:52 <lambdabot>   <no location info>: parse error on input `)'
13:48:57 <ksf> > (\(a,b) -> a + b) in (1,2)
13:48:58 <lambdabot>   <no location info>: parse error on input `in'
13:49:02 <Taejo> mauke: oshi, refcounting here we come
13:49:02 <ksf> > (\(a,b) -> a + b) (1,2)
13:49:02 <gueux> ok :-)
13:49:03 <lambdabot>   3
13:49:07 <ksf> gragh.
13:49:11 <gueux> my error was somewhere else
13:49:19 <mauke> Taejo: cycles
13:49:26 <Taejo> mauke: *tree*
13:49:31 <Cheshire> > uncurry (+) (1,2)
13:49:32 <lambdabot>   3
13:49:33 <mauke> Taejo: user error
13:49:39 <olsner> tehgeekmeister: I think that's what my function above does
13:49:41 <Taejo> mauke: I'm the only user
13:49:47 <mauke> that won't save you :-)
13:49:51 <Taejo> and the code only has to be maintained for a week
13:50:03 <mmorrow> here's the current house site + code http://web.cecs.pdx.edu/~kennyg/house/
13:50:13 <tehgeekmeister> olsner: oh, didn't notice it
13:50:14 <tehgeekmeister> thanks
13:50:38 <ksf> tehgeekmeister, sequence_ . fmap?
13:50:50 <tehgeekmeister> @type (sequence_ . fmap)
13:50:51 <lambdabot>     Couldn't match expected type `[m a]'
13:50:51 <lambdabot>            against inferred type `f a1 -> f b'
13:50:51 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
13:51:21 <ksf> (sequence_ . fmap print) [1,2]
13:51:27 <tehgeekmeister> @type (\f -> (sequence . fmap f))
13:51:28 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
13:52:07 <tehgeekmeister> a1 happens to include monads because of the use of fmap, right?
13:52:34 <mmorrow> this downloads the house floppy-boot image and has it running it in qemu in under 10 seconds:
13:52:36 <mmorrow> wget http://web.cecs.pdx.edu/~kennyg/house/House.flp && qemu -boot a -fda House.flp
13:52:38 <ksf> > (sequence_ . fmap print) [1,2]
13:52:39 <lambdabot>   * Exception: "<IO ()>"
13:52:49 <ksf> tehgeekmeister, nope, that's because of sequence.
13:52:54 <ksf> fmap is defined on functors.
13:53:00 <ksf> there's mapM, too....
13:53:02 <tehgeekmeister> aren't all monads functors?
13:53:07 <ksf> they are.
13:53:15 <tehgeekmeister> that's what i was getting at.
13:53:25 <ksf> ...and, if nomenclature wasn't insane, fmap would be called map.
13:55:13 <ksf> tehgeekmeister, to be precise, all monads are applicative functors, though haskell doesn't enforce it.
13:55:31 <ksf> see the typeclassopedia for details.
13:55:41 <tehgeekmeister> ksf: this is the sort of thing i will learn once i become all smart about types and categories and whatnot?
13:55:54 <tehgeekmeister> i keep hearing about that, i really should take a look.
13:56:02 <ksf> this is the sort of thing you will learn once you read the typeclassopedia.
13:57:39 <tehgeekmeister> only 48 pages.  i can handle that.
13:58:00 <Nafai> I didn't really understand typeclassopedia
13:58:03 <ksf> once you've arrived at monoid, you're well into buiseness.
13:58:04 <Nafai> It was too abstract for me :(
13:58:12 <tehgeekmeister> @type fmap fmap fmap
13:58:13 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:58:23 <tehgeekmeister> that is scary, the typeclassopedia is right.
13:58:31 <olsner> @ty zip.ap fmap.(id &&& ?x)
13:58:32 <lambdabot>     Couldn't match expected type `(a -> b) -> f a'
13:58:32 <lambdabot>            against inferred type `(a1, c')'
13:58:32 <lambdabot>     Probable cause: `&&&' is applied to too many arguments
13:59:26 <tehgeekmeister> i am sure euclid didn't say anything about haskell.
13:59:27 <guenni> mmorrow: ping
13:59:57 <tehgeekmeister> oh, i didn't even know what i wanted.  silly me.
14:00:07 <ksf> "I know that I don't know Haskell, therefore I know more than those that know Haskell" -- Sokrates
14:00:30 <tehgeekmeister> i really wanted Monad m => m [a] -> (a -> m b) -> m ()
14:00:39 <tehgeekmeister> which is probably much easier to write.
14:01:21 <paper_cc> @ty sequence_
14:01:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:01:41 <paper_cc> @ty forM_
14:01:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
14:01:51 <paper_cc> tehgeekmeister: ^^
14:01:57 <gwern> fun. riot is broken with latest cabal
14:02:02 <tehgeekmeister> paper_cc: that's not quite right
14:02:10 <paper_cc> oops, yes
14:02:11 <dcoutts> gwern: yep
14:02:20 <dcoutts> gwern: it was broken before, we just didn't notice
14:02:27 <ksf> tehgeekmeister, the magic word is ">>="
14:02:43 <tehgeekmeister> oh, man, i've come full circle.
14:02:45 * paper_cc tries to write \f -> (>>= forM_ f)
14:02:58 <mm_freak> mathijs: yeah, usually you'll want rnf
14:03:04 <ksf> m [a] -> ([a] -> (a -> m b ) -> m ())
14:03:11 <tehgeekmeister> @type (=<< forM_)
14:03:12 <lambdabot> forall b a (m :: * -> *) b1. (Monad m) => (((a -> m b1) -> m ()) -> [a] -> b) -> [a] -> b
14:03:23 <gwern> dcoutts: how do I fix it?
14:03:28 <paper_cc> tehgeekmeister: wrong direction
14:03:38 <dcoutts> gwern: make it not use dist/blah/.h files
14:03:39 <paper_cc> @ty \f -> (>>= forM_ f)
14:03:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> m (a -> m b) -> m ()
14:03:42 <tehgeekmeister> @type (>>= forM_)
14:03:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ((a -> m b) -> [a]) -> (a -> m b) -> m ()
14:03:49 <paper_cc> oops, I'm wrong too
14:03:59 <mauke> wait, what are you trying to do?
14:04:07 * FunctorSalad_ prefers =<<... "do { y <- x >>= f }" is just evil ;)
14:04:08 <paper_cc> @ty \f -> (>>= mapM_ f)
14:04:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m ()
14:04:17 <dcoutts> gwern: I think that package uses a little-known hsc2hs feature which spits out a .c file
14:04:18 <paper_cc> so flip it ...
14:04:20 <gwern> dcoutts: but they don't seem to exist!
14:04:24 <tehgeekmeister> Monad m => m [a] -> (a -> m b) -> m ()
14:04:27 <tehgeekmeister> mauke: ^
14:04:28 <dcoutts> gwern: well exactly :-)
14:04:33 <gwern> dcoutts: it wants dist/build/riot/riot-tmp/Curses/Curses_hsc.h but there's only Curses/ Curses.hsc
14:04:49 <dcoutts> gwern: it gets created by hsc2hs from the .hsc file from the #c .. #endc bits
14:04:52 <paper_cc> @ty (sequence_ .) . (>>=)
14:04:53 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [a1] -> (a1 -> [m a]) -> m ()
14:04:57 <rgr> from the command line how do I query which network interface is in use?
14:05:02 <tehgeekmeister> @type mapM_
14:05:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:05:07 <ksf> @src mapM_
14:05:07 <lambdabot> mapM_ f as = sequence_ (map f as)
14:05:21 <paper_cc> @ty (sequence .) . (>>=) . liftM
14:05:22 <lambdabot>     Couldn't match expected type `[]'
14:05:22 <lambdabot>            against inferred type `(->) (m a1)'
14:05:22 <lambdabot>     Probable cause: `.' is applied to too few arguments
14:05:23 <dcoutts> gwern: this is the hsc2hs feature that Cabal does not support. riot tries to hack it anyway. It used to work, though not by design.
14:05:47 <gueux> I am trying to use the IORef in a threaded server game
14:05:59 <dcoutts> gwern: the solution is not to use the hsc2hs #c .. #endc feature and to use a separate standalone .c and .h file
14:06:03 <tehgeekmeister> @type (\f xs -> xs >>= mapM_ f)
14:06:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m ()
14:06:09 <tehgeekmeister> tada!
14:06:13 <tehgeekmeister> that'll work.
14:06:16 <gueux> but when I try to modify the IORef the server close the connection
14:06:20 <gueux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1517#a1519 [+]
14:06:21 <whpearson> @pl (\f xs -> xs >>= mapM_ f)
14:06:21 <lambdabot> (=<<) . mapM_
14:06:23 <ski_> "I believe any statement as soon as I believe that it would be true should I believe it." -- Loeb
14:06:33 <Cheshire> lol
14:06:54 <gwern> dcoutts: sure that's the syntax? I don't see any #endc in Curses/Curses.hsc
14:07:14 <dcoutts> gwern: it's something like that, a way to embed actual C into the .hsc file.
14:07:23 <dcoutts> gwern: like inline wrapper functions etc
14:07:53 <ksf> It's my firm belief that it's a mistake to hold firm beliefs.
14:08:16 <olsner> > [1] :: [] Int
14:08:16 <gwern> ksf: fortunately you minimize your mistakes by holding that belief
14:08:17 <lambdabot>   [1]
14:08:19 <dcoutts> gwern: ahh, I think it's #def
14:08:35 <dcoutts> gwern: like:
14:08:35 <dcoutts> #def inline chtype hs_curses_color_pair (HsInt pair) {return COLOR_PAIR (pair);}
14:08:39 <gwern> '#def C_definition'?
14:08:44 <olsner> oh, I always thought ([] a) was only metasyntax
14:08:52 <dcoutts> gwern: yes, they get spat out into a .c file
14:09:17 <FunctorSalad_> > [-23] :: ([] Int)
14:09:18 <ksf> gwern, OTOH, beliefs tend to stick onto other beliefs.
14:09:18 <lambdabot>   [-23]
14:09:21 <FunctorSalad_> :D
14:09:44 <roconnor> this CIVS polling site looks great
14:10:02 <FunctorSalad_> (does it work with other numbers too?)
14:10:31 <ksf> FunctorSalad_, now I wanna see the isomorphism between 23 and  the curry-howard isomorphism.
14:10:39 <ski_> "If I believed that I don't believe contradictions, I would believe a contradiction." -- Goedel
14:11:09 <ksf> Goedel is a spawn of Dante's mind.
14:12:45 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/schroedinger.png
14:14:12 <ksf> http://www.flickr.com/photos/dantekgeek/522563155/
14:14:25 <FunctorSalad_> they say he comes from the sventh layer of the first inaccessible cardinal.
14:14:45 <FunctorSalad_> *seventh
14:14:59 <ksf> the lambdacat would be type Schroedinger :: Maybe Cat
14:15:33 <ski_> why not `NonDeterministic Cat' ?
14:16:07 <ksf> Maybe (Deterministic Cat)?
14:16:59 <gwern> ski_: because then you're taking a stance on copenhagen vs many worlds!
14:17:34 <ski_> which stance would that be ?
14:18:04 <Raevel> nondeterministic cat is ...
14:18:08 <gwern> you're for it!
14:18:15 <mauke> iron horse stance
14:18:16 <gwern> I mean, a wide stance
14:19:05 <ski_> which stance of `copenhagen' and `many worlds' ?
14:19:09 <ski_> (i expect you to answer by "yes")
14:19:28 <ksf> any. it doesn't matter.
14:19:30 <gwern> 'for it' is a variant
14:19:44 <tehgeekmeister> is there some sneaky way of checking the types of helper functions defined in wheres and lets?
14:19:48 <gwern> going back to an old story about daniel boone when he was in congress
14:19:52 <tehgeekmeister> or giving them type signatures?
14:19:53 <gwern> tehgeekmeister: lift them to the top level?
14:20:04 <gwern> only way I've ever found
14:20:04 <ksf> it's like arguing pixies inducing dreams vs. fairies inducing dreams.
14:20:08 <tehgeekmeister> was trying to avoid that clutter.
14:20:19 <tehgeekmeister> might have to do it, tho
14:20:31 <gwern> ksf: my understanding was that there were testable consequences to mw
14:20:49 <tehgeekmeister> @type (=<<) . mapM
14:20:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
14:20:51 <ksf> then it wouldn't be an interpretation, but a theory.
14:21:29 <tehgeekmeister> @type (=<<) . forM
14:21:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> m (a -> m b) -> m [b]
14:21:45 <tehgeekmeister> oh that's all wrong, that's not it at all.
14:22:02 <lifflander> Hey everyone.
14:22:02 <pk> should I use postRedisplay in my opengl' s idleCallback ?
14:22:06 <pk> hey
14:22:32 <pk> because otherwise there is no update
14:22:32 <tehgeekmeister> @pl (\f xs -> xs >>= forM xs)
14:22:32 <lambdabot> const (ap (>>=) forM)
14:22:33 <Eridius> ugh, the more I read up on crazy Haskell stuff the more I think I shouldn't even try to get involved, because I'll never be able to understand all of this stuff :/
14:22:34 <ksf> you don't need an idleCallback at all, afair.
14:22:44 <pk> okay then
14:22:49 <lifflander> I need to create a range of large numbers, on the order of 512 bits...
14:22:59 <ksf> you should do the painting when your window system tells you to.
14:23:09 <ski_> Eridius : come on. it's fun !
14:23:14 <ksf> w....wait.
14:23:16 <ksf> no.
14:23:52 <ksf> of course you need some function that waits for some time and then repaints, otherwise you won't get any kind of fps.
14:23:53 <pk> so, should I recompile windows ?
14:24:08 <ksf> how about using glut?
14:24:11 <lifflander> I don't want to do the calculations by hand, is there a library for creating a numbers of a certain order?
14:24:12 <tehgeekmeister> @pl (\f xs -> xs >>= (forM f))
14:24:12 <lambdabot> (=<<) . forM
14:24:16 <pk> I'm using it
14:24:18 <FunctorSalad_> tehgeekmeister: :type it in ghci, adding lambda binders for the requisite local variables?
14:24:25 <pk> or am I ?
14:24:42 <lifflander> Large numbers, anyone?
14:24:51 <tehgeekmeister> FunctorSalad_: that'd require a lot of lambdas.  moving it to the top level's easier in this case.
14:24:54 <pk> yeah I'm using glut
14:25:13 <pk> createWindow and everything
14:25:32 <ski_> "creating a numbers of a certain order" ?
14:25:34 <pk> but I get no update
14:25:44 <pk> and postRedisplay is a glut function
14:25:44 * tehgeekmeister is lost in type errors
14:25:59 <lifflander> Yes, in the 512-bit range -- without expliciting typing them.
14:26:17 <lifflander> I guess I could use product or exponentiation?
14:26:20 <ski_> > 2^512
14:26:21 <lambdabot>   134078079299425970995740249982058461274793658205923933777235614437217640300...
14:26:29 <ksf> hmmm... in my code, I'm setting displayCallback, a few others (reshape, keyboardMouse, visibility), and then mainLoop.
14:26:36 <lifflander> Sweet, thanks,
14:26:37 <ksf> *calling mainLoop
14:26:47 <Cheshire> > 2^516
14:26:49 <lambdabot>   214524926879081553593184399971293538039669853129478294043576983099548224481...
14:27:00 * ski_ is not sure what lifflander is after .. some kolmogorov complexity compressions of large numbers ?
14:27:10 <FunctorSalad_> those are pretty non-arbitrary numbers though.... ;)
14:27:28 <Eridius> my biggest problem with trying to play around with Haskell is I still haven't found a project to actually use it for. Pretty much everything I do these days is Cocoa-related and HOC is far too unwieldy to replace using Objective-C
14:27:42 <lifflander> I am implementing a variant of RSA and will use the large number range to probe for prime numbers using Millerâ€“Rabin's primality test.
14:28:27 <lifflander> That's fine FunctorSalad_, it will just provide a range for me to search.
14:29:03 <tehgeekmeister> http://tinyurl.com/c3y7j2 <== help?
14:29:24 <Cheshire> yuck
14:29:27 <FunctorSalad_> Eridius: that makes me wonder too, but there must be some other reason than haskell not being good enough... I guess it's must be the network effect (or what's it called) that noone wants to use it for a large project until someone did :)
14:29:33 <Cheshire> this is not readable
14:29:37 <FunctorSalad_> s/it's/it
14:29:55 <tehgeekmeister> oh that formatting was so much better on my system
14:29:55 <ksf> > (\n m -> [(2^n)..(2^(n+m))]) 10 2
14:29:56 <lambdabot>   [1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038...
14:30:04 <FunctorSalad_> Eridius: (particularly with commercial projects)
14:30:10 <Eridius> FunctorSalad_: regardless of what other projects have chosen to use it, Haskell is just not a viable option for doing anything Cocoa-related.
14:30:15 <ksf> or am i missing something?
14:30:47 <Eridius> the only project idea I've had that seems even somewhat reasonable is implementing a ticketing system in Haskell similar to ticgit, but that would require implementing a Haskell-git bridge which is not a trivial task
14:31:01 <FunctorSalad_> Eridius: hmm I misread, thought you wrote "I still haven't found a project to actually use it"
14:31:08 <Eridius> ah
14:31:33 <Eridius> not just "a project" but "some project that I would want to work on", whether it's pre-existing or something I create
14:31:58 <pejo> Eridius, how about HOC? :-)
14:32:17 <Eridius> pejo: I think the impedance mismatch between Haskell and Obj-C is just too great for HOC to ever become anything but unwieldy
14:32:32 <FunctorSalad_> I guess lack of stable GUI library (that I know of) is still a barrier as well
14:33:10 * ksf recommends http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf to anyone interested in types.
14:34:02 <Cheshire> is there an HTML version?
14:34:22 <ksf> eh... no.
14:34:25 <ksf> it's a book.
14:34:38 <ksf> quite old, tbh, but a solid introduction.
14:34:46 <ksf> (quite old being 15, 20 years)
14:35:00 <tehgeekmeister> 1999 according to the front page?
14:35:10 <ksf> well, that's still old.
14:35:16 <tehgeekmeister> yeah
14:35:42 <ksf> I was judging by the dates of the references as I went along.
14:36:00 <Cheshire> so what's new since 1999? :)
14:36:28 <mauke> this millennium
14:36:39 <Cheshire> Im mean type theory
14:36:41 <FunctorSalad_> lolkittens
14:36:57 <roconnor> @quote roconnor
14:36:58 <lambdabot> roconnor says: ugh, Latex is as frustrating as Haskell. :P
14:37:07 <Cale> Eridius: That's interesting, why do you think that is?
14:37:09 <tehgeekmeister> @type (\f xs -> xs >>= (forM f))
14:37:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> m (a -> m b) -> m [b]
14:37:23 <ksf> http://www.cs.nott.ac.uk/~txa/publ/pisigma.pdf is the newest publication I could find that isn't tied to a particular language or is a blog post.
14:37:25 <tehgeekmeister> @type (\f xs -> xs >>= (mapM f))
14:37:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
14:37:31 <Eridius> Cale: going from an Ã¼ber static typed language like Haskell where everything's done at compile time to a dynamically-typed message-passing language like Obj-C?
14:37:34 <tehgeekmeister> @pl (\f xs -> xs >>= (mapM f))
14:37:34 <lambdabot> (=<<) . mapM
14:37:43 <olsner> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
14:37:43 <lambdabot> f a b =
14:37:43 <lambdabot>     case a of
14:37:43 <lambdabot>     Nothing -> Nothing
14:37:43 <lambdabot>     Just c -> b c
14:37:53 <mauke> Eridius: why do you think everything's done at compile time?
14:37:58 <pejo> Cheshire, MLF, the other type systems by Daan Leijen that are nearly as powerful, and a bunch of more things.
14:38:00 <Eridius> Cale: HOC takes a lot of stuff that's normally done at runtime in Obj-C and shoves it into the compile time
14:38:20 <Eridius> mauke: I'm talking type-related here
14:38:22 <gwern> Eridius: how does ticgit integrate with git? far as I knew, git has to be worked with as process calls
14:38:25 <mauke> ok
14:38:41 <Cheshire> what is MLF short for?
14:38:46 <Eridius> gwern: IIRC ticgit uses Grit, a ruby library that bypasses the git binary and reads the .git files directly
14:39:06 <gwern> mm. interesting. I was wondering if it was doing stuff analogous to filestore
14:39:09 <ksf> ugh. isn't the whole sense of git _using_ the binaries?
14:39:23 <Cale> Eridius: That's a design choice of HOC's, of course... though isn't Objective C statically typed?
14:39:26 <gwern> ksf: I guess git has graudated to being a format now as well
14:39:39 <Eridius> Cale: variables are typed, but a ton of stuff is done at runtime
14:39:53 <pejo> Cheshire, not sure, Didier Remy should have the article on his homepage (2003 I think).
14:39:59 <Cheshire> thanks
14:40:11 <Eridius> for example, every single object reference is just that - a reference. No compile-time guarantee that the variable actually contains the object it thinks it does
14:40:18 <webIRC_864417> http://www.youtube.com/watch?v=I1WsL_iBBqk
14:40:26 <Cheshire> "MLF: Raising ML to the power of System F"
14:40:30 <Cheshire> sounds cool
14:41:02 <Cale> Eridius: So HOC uses Haskell's type system to ensure that?
14:41:25 <Eridius> Cale: I've only barely touched on HOC, but even the syntax it uses is very unweildy
14:41:56 <Cale> I should perhaps have a look at it, though I don't have a mac, so it's a little bit silly for me :)
14:42:00 <Eridius> hehe
14:42:47 <hackage> Uploaded to hackage: HDBC-mysql 0.3
14:44:00 <Cale> Eridius: It's possible to do a lot to make interfaces nicer. At some point you might have a look at Gtk2Hs which, even though it's still considered a somewhat lowlevel binding, already does quite a bit to correct the impedance mismatch with a C library.
14:44:20 <Eridius> Cale: last time I tried compiling gtk2hs it didn't record the right linker paths so I couldn't actually even use it :/
14:44:26 <Raevel> I'm trying to install editline via cabal, but i get "exit: ExitFailure 1", any tips? :-)
14:44:31 <Cale> Oh, that's disappointing...
14:44:39 <gwern> Eridius: hah. I can't even *configure* gtk2hs correctly!
14:44:41 <Cale> Then there are lots of (admittedly more experimental) libraries built on top of it which are more functional.
14:44:49 <Eridius> I wanted to see the gtk interface to yi, since the cocoa one is quite out of date
14:44:53 <Raevel> shoot, maybe i screwed up :-)
14:45:10 <dcoutts> Eridius: you've got the gtk libs installed somewhere that's not on the runtime linker path?
14:45:11 <Eridius> gwern: I had to pass extra CFLAGS just to get it to compile, which I think is why it screwed up in recording the linker paths
14:45:18 <Eridius> dcoutts: I've got them installed in /opt/local/lib
14:45:20 <gwern> Eridius: I think the pango yi interface is supposed to be the way forward
14:46:34 <gwern> (pang-o! paaangg-o! daylight come, we compile our code!)
14:47:35 <dcoutts> Eridius: ok, so you can hack it. Once you've got gtk2hs installed you can adjust the package registration for the gtk package to add extra ld flags.
14:47:50 <haedent> I am baffled by a Parsec problem. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1520
14:47:53 <Eridius> dcoutts: I had to do something similar for another package
14:48:41 <dcoutts> Eridius: do you need to do this with cabal packages too? Is it the -rpath that you need as well as ordinary -L dir flags ?
14:48:43 <haedent> does Parsec.Token.natural $ makeTokenParser haskellDef not work the way I thought it should?
14:48:53 <Eridius> dcoutts: I don't need to do this with cabal normally
14:49:03 <Eridius> though normally it's not using a lib from /opt
14:49:20 <dcoutts> Eridius: right, only for bindings for things in /opt
14:50:16 <dcoutts> Eridius: the problem is that while we're reasonably good at being able to specify extra -L dirs, we tend to assume that those dirs will still be on the runtime linker path. So we do not use -rpath/-R
14:50:29 <dcoutts> it's hard to tell if that's a mistake or not
14:50:36 <rwbarton> haedent: natural is a "lexeme parser" which means that it eats either leading or trailing spaces (I forget which)
14:50:57 <rwbarton> haedent: apparently trailing spaces
14:51:05 <Eridius> dcoutts: if I have to tell it where to find the libraries, it should assume that it has to record that
14:51:43 <haedent> hmm. That would do it I suppose
14:52:31 <dcoutts> Eridius: yes I agree. For some reason you'll find people on the net saying that -R/-rpath is evil and should be avoided. So I'm not sure what to do.
14:52:57 <Eridius> so I'm looking at the ghc-pkg describe gtk, I'm thinking /opt/local/lib should be listed in library-dirs:, right?
14:55:02 <Eridius> dcoutts: so how can I tell gtk2hs to add extra library paths when it registers with ghc-pkg?
14:55:22 <Eridius> to get it to build I used ./configure LDFLAGS=-L/opt/local/lib
14:58:48 <pumpkin> MonadST :o
14:59:08 <tehgeekmeister> if you use fromJust all over in your code, and suddenly you hit a Nothing, you will have a hard time finding which one was the problem.  i just learned this the hard way.
14:59:20 <pumpkin> use fromMaybe instead
14:59:33 <pumpkin> maybe even fromMaybe (error "boo you suck at line 352")
15:00:12 <ski_> @type maybe even fromMaybe (error "boo you suck at line 352")
15:00:13 <lambdabot>     No instance for (Integral (Maybe Bool))
15:00:13 <lambdabot>       arising from a use of `even' at <interactive>:1:6-9
15:00:13 <lambdabot>     Possible fix:
15:00:41 <bolrod> no fix
15:02:20 <dcoutts> Eridius: the easiest way is probably to change the package registration after you've installed gtk2hs
15:02:39 <olsner> @src concat
15:02:39 <lambdabot> concat = foldr (++) []
15:02:41 <Eridius> I just did that. I think it worked
15:02:46 <Eridius> at least, yi is now building further than before
15:02:46 <glguy> Where is Haskell's  "htonl"
15:02:53 <dcoutts> Eridius: use ghc-pkg describe glib > glib.pkg; edit glib.pkg; ghc-pkg update glib.pkg;
15:03:01 <olsner> glguy: putWord16be?
15:03:08 <Eridius> dcoutts: that's exactly what I did
15:03:14 <pumpkin> olsner: doesn't that just put it into a bytestring?
15:03:20 <glguy> olsner, that's Data.Binary specific
15:03:29 <dcoutts> Eridius: edit the glib.pkg to add the extra library dir. If necessary use ld-options: -R/whatever  if you need that too.
15:03:39 <Eridius> I just added /opt/local/lib to library-dirs:
15:03:47 <Eridius> and yi is building, so I think that's all that was necessary
15:03:52 <rwbarton> glguy: you "shouldn't need one"
15:04:04 <pumpkin> Eridius: why not just --extra-library-dirs
15:04:07 <glguy> rwbarton, bummer
15:04:11 <rwbarton> glguy: why would you want to perform a random operation on ints that varies from platform to platform
15:04:26 <rwbarton> glguy: unless you are talking about FFI stuff
15:04:33 <glguy> rwbarton, so that one platform can talk to another
15:04:36 <Eridius> pumpkin: such an option is not documented in ./configure for gtk2hs
15:04:43 <glguy> rwbarton, yup, ffi
15:04:45 <dcoutts> pumpkin: it's better to embed this in the gtk2hs packages, not every dependent package
15:05:03 <pumpkin> oh, I thought it was a generic cabal-install thing :)
15:05:09 <dcoutts> Eridius: if you find when you run yi that it cannot find the libs then you probably also need the -R/-rpath flag
15:05:10 <ski_> (glguy : istr that was a goal of jhc ..)
15:05:16 <pumpkin> but /opt/local/lib is pretty macports-specific isn't it?
15:05:18 <dcoutts> pumpkin: it is, but gtk2hs doesn't use cabal yet
15:05:37 <rwbarton> glguy: if you want two pure haskell programs on different machines to talk to each other htonl isn't relevant, the only way to unpack an int into words is with bit operations anyways
15:05:40 <Eridius> Failed to load interface for `Yi.Syntax.BList' when compiling my yi.hs. wtf
15:05:48 <rwbarton> s/words/bytes/
15:06:08 <glguy> rwbarton, I'm not interested in debating if it should be necesary
15:06:39 <rwbarton> glguy: I'm pretty sure there is no htonl :: Int32 -> Int32
15:06:44 <tehgeekmeister> pumpkin: that wouldn't type right
15:06:56 <pumpkin> tehgeekmeister: ?
15:07:13 <Eridius> Yi.Syntax.BList was compiled. Why is it not working?
15:07:16 <tehgeekmeister> pumpkin: the use of fromMaybe you suggested
15:07:20 <tehgeekmeister> @type fromMaybe
15:07:21 <lambdabot> forall a. a -> Maybe a -> a
15:07:30 <tehgeekmeister> @type (error "")
15:07:31 <lambdabot> forall a. a
15:07:32 <br1> I'm trying to understand a big haskell project (EHC) and I miss the "go to definition" and "find all references" features of comercial IDEs. How should I tackle this problem?
15:07:35 <tehgeekmeister> oh!
15:07:39 <Eridius> hrm, no Yi/Syntax/BList.hi file in the installed location
15:07:39 <Eridius> wtf
15:07:42 <tehgeekmeister> error is designed nicel.
15:07:46 <tehgeekmeister> *nicely.  nevermind.
15:07:57 <pumpkin> tehgeekmeister: it's like undefined :) it'll take any type you need it to, and barf if you evaluate it
15:09:19 <Cheshire> > 1+
15:09:20 <Cheshire> > 1+1
15:09:20 <lambdabot>   <no location info>: parse error on input `;'
15:09:21 <lambdabot>   2
15:09:24 <Cale> lispy: Did the RSA host key on olive change?
15:11:08 <mmorrow> ehc released code?!?
15:11:13 * mmorrow looks
15:11:16 <gwern> br1: hasktags, probably
15:11:31 <gwern> mmorrow: ehc code has been around for quite a while
15:11:33 <pumpkin> how does the SPECIALIZE pragma play with exported functions?
15:11:47 <mmorrow> hmm, i might be thinking of something else
15:12:08 * mmorrow doublechecks
15:12:49 <mmorrow> nope, i'm thinking of the right thing
15:13:08 <mmorrow> gwern: what do you call a long time? 2-3weeks?
15:13:12 <gwern> I've had subversion checkouts for like half a year at least now
15:13:19 <mmorrow> :o
15:13:26 <pumpkin> say for example I have a mean :: (Fractional a, Num a) => [a] -> a, and said specialize for Float and Double. Could I then stick it in a module, import that module, and have it use the specialized versions for Double, Float, but use the polymorphic one for CReal, for example?
15:13:37 * mmorrow just isn't in the know
15:13:48 <gwern> I think there may be a cabal bug report from like june where I ask dcoutts to add uuagc preprocessor support to cabal so I could cabalize the ehc compilers
15:14:13 <dcoutts> gwern: oh right
15:14:22 * gwern is pleased. I've shocked mmorrow, all without one stitch of clothing removed!
15:14:29 <pumpkin> lol
15:14:37 <dcoutts> gwern: I'm not sure there is a ticket actually, I don't remember any
15:15:00 * mmorrow splits mmorrow with a neutron causing a chain reaction of mmorrows which he then fuses into uncountably many mmorrows
15:15:01 <gwern> dcoutts: maybe we just discussed it here then
15:15:21 <br1> gwern: I'll look into hasktags. Thanks!
15:15:35 <gwern> hey now, the axiom of choice is not physically realizable! no banach-tarski here thank you very much
15:16:16 <dcoutts> gwern: well do file a ticket
15:16:21 <Tordek> Is it possible to import a module, and say "if I overwrite a definition, use mine, and pay no attention to errors"?
15:16:42 <gwern> dcoutts: but now I can't remember anything about it!
15:18:05 <pumpkin> Tordek: not that I know of, but you can do hiding (hiddenFunction) after your import
15:19:08 <QtPlatypus> I know haskell's strong typing eleminates a entire class of errors so its not considered as neccery but is there a unit testing framework for haskell?
15:19:19 <Cale> QtPlatypus: yes
15:19:20 <pumpkin> hunit
15:19:23 <pumpkin> or quickcheck
15:19:26 <pumpkin> the latter is more fun
15:19:40 <pumpkin> but both are useful
15:19:41 <gwern> or smallcheck
15:19:43 <Cale> QuickCheck uses type information to generate random test data.
15:19:43 <gwern> funner?
15:20:05 <QtPlatypus> -Ofun
15:20:15 <pumpkin> ooh, hadn't heard of smallcheck
15:21:32 <lispy> ?scheck True
15:21:33 <lambdabot>   "OK, passed 500 tests."
15:21:39 <lispy> ?scheck const True
15:21:40 <lambdabot>   "OK, passed 500 tests."
15:21:48 <lispy> ?scheck (==)
15:21:49 <lambdabot>   "OK, passed 500 tests."
15:21:54 <lispy> hmm
15:22:00 <gwern> I've never understood smallcheck well enough to use it
15:22:02 <lispy> ?scheck (==) :: Int -> Int -> Bool
15:22:04 <lambdabot>   Couldn't match expected type `Int -> Int -> Bool'
15:22:14 <lupsyn> can someone explain me the treefoldr in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1525#a1525
15:22:17 <lupsyn> please ?
15:22:50 <lispy> ?scheck \x y -> (x :: Int) == y
15:22:51 <lambdabot>   "Falsifiable, after 0 tests:\n1\n-1\n"
15:23:04 <lispy> ?type \x y -> (x :: Int) == y
15:23:06 <lambdabot> Int -> Int -> Bool
15:23:11 <lispy> okay....
15:23:54 <Cheshire> lupsyn, what about it?
15:23:58 <rwbarton> ?scheck ((==) :: Int -> Int -> Bool)
15:23:59 <lambdabot>   "Falsifiable, after 0 tests:\n2\n1\n"
15:24:21 <Cheshire> lupsyn, (this is not the definition I would give by the way)
15:25:14 <lupsyn> i don't understand the use of g and f
15:25:30 <lispy> lupsyn: people have found that putting a type class constraint into a data declaration usually don't work as well as you would like
15:26:05 <lispy> lupsyn: and  you're familiar with the normal foldl/foldr?
15:27:32 <lispy> lupsyn: what is the type of treefoldr?
15:28:01 <lupsyn> (a -> b -> b1) -> b1 -> (b1 -> b -> b) -> b -> Tree a -> b1
15:29:03 <glguy> lupsyn, The Void constructor doesn't make as much sense when your child-trees are a list
15:29:34 <monochrom> @quote sugar
15:29:34 <lambdabot> ghc says: GHC error in desugarer lookup
15:29:47 <lispy> also, treefoldr f x g y Void = x, seems potentially wrong to me.  f x?
15:30:14 <glguy> foldr _ x [] = x
15:30:23 <glguy> fwiw
15:30:40 <lispy> ah, so i guess it matches that
15:31:05 <lupsyn> ok this is the height with normal tree fold treefold (\_ xs-> if null xs then 0 else  1+maximum(xs)) (-1)
15:31:11 <mathijs> is there a reason why using Int instead of Integer makes my program almost 3 times slower?
15:31:17 <lupsyn> how to ,for example,with the treefoldr ?
15:31:27 <glguy> mathijs, because it is overflowing and changing the behavior?
15:31:39 <monochrom> Int is closer to machine words
15:31:57 <mathijs> monochrom: that's why I thought it would be faster...
15:32:18 * wli gets very very stupid division going.
15:32:36 <mathijs> glguy: it's not overflowing, I get the exact same results, and since I'm on 64bit overflowing shouldn't happen on the numbers I'm working with
15:32:58 <glguy> treefold f x (Node a ts) = f x (map (treefold f x) ts)
15:33:24 <glguy> treefold :: (t -> [b] -> b) -> t -> Tree t1 -> b
15:33:31 <pumpkin> I like the look of smallcheck
15:33:54 <QtPlatypus> I've been using tupples to represtent things I would in other langauges use a record for.  Is there a more self documenting way of doing this?
15:34:01 <pumpkin> records
15:34:13 <rwbarton> @quote record
15:34:13 <lambdabot> ghc says: scavenge_stack: weird activation record found on stack
15:34:17 <pumpkin> @quote pumpkin
15:34:17 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
15:34:33 <Pseudonym> @quote exploded
15:34:33 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
15:34:49 <gwern> @quote oleg
15:34:49 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
15:34:49 <lispy>  data MyFirstRecord a = MFR { foo :: a, bar :: Int }
15:34:50 <gwern> @quote oleg
15:34:50 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
15:34:58 <gwern> h
15:34:59 <gwern> @quote oleg
15:34:59 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
15:35:06 <monochrom> âˆžP
15:35:07 <gwern> all the oleg quotes are gone!
15:35:10 <Pseudonym> @quote OlegFacts
15:35:10 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
15:35:10 <gwern> @quote Oleg
15:35:10 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
15:35:23 <gwern> ok, that's more like it
15:35:49 <ksf> @quote OlegFacts
15:35:49 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
15:35:55 <ksf> @quote OlegFacts
15:35:55 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
15:35:57 <ksf> @quote OlegFacts
15:35:57 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
15:36:03 <lispy> spaaaamy
15:36:06 <monochrom> Next decade Oleg will implement SmallCheck at the type level.
15:36:11 <ksf> we need more of those.
15:36:26 <rwbarton> monochrom: SmallCheck for type-level functions? I like it
15:36:45 <lispy> The implicit configurations paper by Oleg is the one that really wrecked my brain
15:36:59 <monochrom> Someone will also do lambdabot at type level.
15:37:10 <lispy> Converting between values and types dynamically is just...wow.
15:37:22 * rwbarton <3 implicit configurations
15:37:41 <wli> This stuff is incredibly messy and incredibly inefficient.
15:38:35 <lispy> wli: stop looking over my shoulder :)
15:39:47 <ksf> @remember Oleg implemented first-class continuations in Haskell... in the type system
15:39:47 <lambdabot> Done.
15:40:12 <Cheshire> ksf, no he didn't
15:40:19 <ksf> @forget Oleg implemented first-class continuations in Haskell... in the type system
15:40:19 <lambdabot> Done.
15:40:30 <ksf> @remember OlegFacts Oleg implemented first-class continuations in Haskell... in the type system
15:40:30 <lambdabot> Done.
15:40:46 <lispy> ?quote OlegFacts
15:40:46 <lambdabot> OlegFacts says: Oleg implemented first-class continuations in Haskell... in the type system
15:41:03 <Pseudonym> Exercise: try adding "in the type system" to the end of any sentence.
15:41:07 <Pseudonym> ...in the type system.
15:41:32 <wli> http://pastebin.com/m3ae17c15 <-- Nat module
15:41:34 <lispy> ?remember OlegFacts Oleg's first datatype in haskell started like this: data ChuckNorris ...
15:41:34 <lambdabot> Done.
15:41:44 <mathijs> LOL did anyone see this on slashdot? http://www.ohesso.com/essays/essay006.htm
15:42:42 <ricky_clarkson> I saw that on slashdot in Haskell's type system.
15:42:47 <BrokenClockwork> Do you know if this is legal?
15:42:47 <hackage> Uploaded to hackage: wxFruit 0.1.2
15:42:53 <monochrom> Did Oleg implement Haskell in Haskell... in the type system?
15:42:56 <Pseudonym> It's legal... in the type system.
15:43:03 <BrokenClockwork> >.<
15:43:17 <Pseudonym> Obviously, I'm not a lawyer in the type system.
15:43:21 <ricky_clarkson> It's life, Jim, but ...in the type system
15:43:24 <pumpkin> Oleg got the haskell type system to agree to EULAs
15:43:28 <Cheshire> mathijs, hehehe
15:43:37 <newsham> mono: see user profile http://codepad.org/users/haskell
15:43:47 <Pseudonym> Another thing to try would be to build a robot that periodically presses "enter", in the type system.
15:45:12 <monochrom> newsham: What should I look for?
15:45:26 <newsham> the type system
15:45:35 <int-e> mathijs: Nice! "On the internet, nobody knows that you're really a cat."
15:45:43 <wli> There are two basic problems: (a) finding the largest power of the radix so that the radix to that power times the divisor is still less than the dividend, and (b) finding the largest multiple of the power of the radix determined in (a) for which the dividend is still greater than that multiple of that power of the radix times the divisor.
15:45:45 <monochrom> Oh haha. "Location: in the type system"
15:45:49 <olsner> you'll find it ... in the type system!
15:46:12 <BrokenClockwork> http://codepad.org/GYcTGLYEs
15:46:36 <BrokenClockwork> this is nice, but why the hell does it compile the code? just to give an exact debug error output?
15:46:53 <olsner> BrokenClockwork: 404?
15:46:56 <wli> Thus far I just brute-force search starting from 0 for (a) and do bisection search on the interval [1,maxBound :: Word32] for (b).
15:47:03 <BrokenClockwork> http://codepad.org/GYcTGLYE
15:47:18 <BrokenClockwork> > cycle [1]
15:47:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:47:32 <monochrom> Who compiled the code?
15:47:34 <wli> When I try to do smarter things, the code stops working.
15:47:54 <BrokenClockwork> has anyone yet shot the lambdabot?
15:48:07 <EvilTerran> not in the type system
15:48:11 <monochrom> Why shoot the lambdabot? We all love her!
15:48:16 <BrokenClockwork> her?
15:48:17 <int-e> > show (1 == 1)
15:48:18 <lambdabot>   "True"
15:48:21 <newsham> ?slap lambdabot
15:48:21 * lambdabot locks up lambdabot in a Monad
15:48:25 <BrokenClockwork> her? this freaks me out
15:48:36 <Cheshire> lol
15:48:40 <EvilTerran> ?vixen asl?
15:48:40 <lambdabot> 19/f/California
15:48:53 <newsham> Hot for Vixen
15:48:57 <lispy> ?vixen Are we still on for watching a movie later?
15:48:57 <lambdabot> who's to say?
15:49:08 <newsham> ?vixen happy valentines day.
15:49:08 <lambdabot> ain't it just like a man?
15:49:19 <lispy> ?vixey How's it going?
15:49:19 <lambdabot> no
15:49:19 <Philippa_> *snigger*
15:49:21 <BrokenClockwork> my first semester has passed, and I leanred how to construct recursion functions in lambda calculus and I am very sure, that lambdabot is not a her
15:49:22 <EvilTerran> wait, what?
15:49:22 <int-e> > map (show . ap (==) reverse) ["abc", "ere"]
15:49:24 <lambdabot>   ["False","True"]
15:49:25 <wli> lambdabot clearly has no sex as it's not even a biological entity. The gender of the pronoun used for it is irrelevant.
15:49:29 <monochrom> #haskell-blah topic has url to a lot of pictures of lambdabot.
15:49:39 <pumpkin> omg Philippa_ used a superstring of the N word
15:49:44 <roconnor> wli: or lambdabot is a girl
15:49:47 <Gracenotes> ?vixen How have you dealt with the stigmatization of your bisexuality?
15:49:48 <lambdabot> It's all about sex isn't it? :)
15:49:56 <ddarius> Why do you have to be biological to have sex?
15:49:56 <Gracenotes> -.-
15:50:15 <newsham> http://www.haskell.org/sitewiki/images/1/13/Lambdabot.png
15:50:15 <Pseudonym> English speakers don't have gendered nouns, so it's confusing for us.
15:50:19 <newsham> proof enough?
15:50:51 <Philippa_> Pseudonym: it never used to be. Ships are "her"...
15:50:51 <olsner> Pseudonym: you mean like, lambdabot's not an actual girl?
15:50:57 <BrokenClockwork> this is insane, I don't want to have something to do with it
15:50:58 <lambdabot> Existentialist bots should be free to find their own identity.
15:51:07 <Pseudonym> Sure.  And so are countries.
15:51:08 <BrokenClockwork> I mean the christians don't have a photograph of their god, have they?
15:51:16 <Pseudonym> England is feminine, Germany is masculine.
15:51:19 <newsham> ?elite I am a free variable!
15:51:19 <lambdabot> i Am A Fre3 \/ariAbl3!
15:51:22 <ddarius> Giving arbitrary nouns genders is silly.
15:51:31 <BrokenClockwork> word
15:51:36 <Pseudonym> BrokenClockwork: No graven images, you mean?
15:51:53 <lispy> ?vixen are you a woman?
15:51:53 <lambdabot> yup, i'm all woman
15:51:54 <Philippa_> BrokenClockwork: ceiling of the Sistine Chapel, 'nuff said?
15:51:55 <BrokenClockwork> hah, true
15:51:59 <lispy> There we have it.
15:52:12 <Pseudonym> The thing about the Hebrew deity that distinguishes it, though, is that they picked a gender and stuck to it, to distinguish it from polytheism.
15:52:19 <BrokenClockwork> so and what about #haskell-blah is this a hostile channel?
15:52:20 <Pseudonym> I didn't word that well.
15:52:42 <ddarius> Polytheism is quite a bit more pragmatic than monotheism.
15:52:51 <monochrom> #haskell-blah is a friendly channel
15:52:55 <Philippa_> BrokenClockwork: it's our off-topic chan
15:53:01 <Philippa_> sometimes too friendly
15:53:04 <wli> This is one for #haskell-blah
15:53:14 <Pseudonym> ddarius: My response to that is in #haskell-blah.
15:53:14 <lament> i like noun gender, probably because my native language has it. ddarius doesn't like noun gender, probably because his native language doesn't.
15:53:23 <ddarius> wli, Pseudonym: Agreed.
15:53:38 <ddarius> lament: I didn't dislike it until learning German.
15:53:42 <whpearson> How can I tell if ghc from darcs compiled correctly?
15:53:43 <NameAlreadyInUse> are there any cairo bindings for haskell?
15:53:51 <dcoutts> NameAlreadyInUse: yes!
15:53:52 <Gracenotes> yep
15:54:02 <newsham> let NaturalGods = NoGods | OneMore NaturalGods
15:54:10 <lispy> NameAlreadyInUse: Look on hackage.  http://haskell.org/hackage
15:54:20 <lispy> NameAlreadyInUse: tons of libraries there of all kinds
15:54:26 <NameAlreadyInUse> ojh
15:54:28 <NameAlreadyInUse> oh*
15:54:30 <monochrom> Mr. Speaker: You follow the building instructions and if there is no error message, it builds correctly.
15:54:30 <dcoutts> lispy: but not the cairo bindings
15:54:34 <NameAlreadyInUse> i found some on the site: http://www.cairographics.org/hscairo/
15:54:36 <dcoutts> NameAlreadyInUse: the cairo bindings are part of gtk2hs
15:54:36 <lispy> dcoutts: ah
15:55:12 <dcoutts> NameAlreadyInUse: yes, the bindings in gtk2hs are very distantly related to the ones you mention. Much improved and now widely used.
15:55:23 <lispy> NameAlreadyInUse: sorry about that.  Normally we you can find the libraries you need through hackage and install them from the commandline with cabal-install :)
15:56:00 <whpearson> monochrom: I get a wall of warnings, but no errors.... I'll try making again.
15:56:11 <NameAlreadyInUse> dcoutts: so should i go for the gtk bindings? i was hoping to be able to use cairo and SDL to do some vector drawing
15:56:25 <monochrom> I forgot whether the warnings are irrelevant.
15:56:31 <dcoutts> NameAlreadyInUse: yes, use the cairo package that is part of gtk2hs
15:56:46 <dcoutts> NameAlreadyInUse: it does not have to be used with gtk
15:56:47 <NameAlreadyInUse> ok, good stuff
15:56:48 <monochrom> Oh, "non-exhaustive patterns" is certainly irrelevant.
15:57:13 <ksf> zomg functn not total!
15:57:20 <whpearson> "link destinations" warnings, which sound bad
15:57:37 <monochrom> I don't know that one.
15:57:58 <monochrom> total functions are overrated.
15:58:18 <rwbarton> whpearson: "link destinations" is a haddock warning
15:58:18 <pumpkin> totally overrated
15:58:39 <SubStack> toe-tally
15:58:50 <monochrom> Ah, haddock warnings are irrelevant too.
15:59:02 <pumpkin> SubStack: 10 last I tallied
15:59:15 <SubStack> all's well then
15:59:21 <pumpkin> decimalist
15:59:27 <monochrom> I got 10.000999....
15:59:30 <ksf> bottom is overrated.
15:59:32 <whpearson> rwbarton: Ah, okay. Although I hadn't configured for docs
15:59:47 <pumpkin> > foldl1 (+) $ replicate 10 (1 :: Float)
15:59:48 <SubStack> ten all told totals the tally
15:59:49 <lambdabot>   10.0
15:59:52 <pumpkin> > foldl1 (+) $ replicate 100 (1 :: Float)
15:59:53 <lambdabot>   100.0
15:59:57 <pumpkin> > foldl1 (+) $ replicate 100 (0.8 :: Float)
15:59:58 <lambdabot>   80.000015
16:00:09 <pumpkin> > foldl1 (+) $ replicate 100 (0.7 :: Float)
16:00:10 <lambdabot>   70.00002
16:00:18 <pumpkin> </pumpkin>
16:00:59 * SubStack has a computer that can do glsl finally :D
16:01:05 <SubStack> for haskell glut fun times
16:03:38 <gueux> I've coded a chat server to play a two player game, it works (:-)). Now I would like to include it into another chat server such that the users could create several games
16:04:14 <gueux> but it seems that there is a problem  (again :-))
16:04:35 <gueux> is it possible to declare sockets into a socket?
16:04:36 <necroforest> Is there a program/latex macro to convert Haskell into formatted LaTeX or embed Haskell into a LaTeX document (NOT literate programming, mind you)
16:04:38 * SubStack gives a talk about how to properly format emoticons in parentheticals
16:04:42 <eu-prleu-peupeu> hi
16:05:12 <pumpkin> ooh it's eu-prleu-peupeu!
16:05:26 <eu-prleu-peupeu> hey pumpkin!
16:05:27 <Pseudonym> ...in the type system!
16:05:40 <eu-prleu-peupeu> anyone here planing to come to the haskell hackaton?
16:05:44 <eu-prleu-peupeu> i will go :D
16:05:49 <eu-prleu-peupeu> to learn how to code in haskell
16:05:53 <pumpkin> eu-prleu-peupeu: I can't make it ...in the type system!
16:06:15 * SubStack is probably too far away, wherever this event is.
16:06:34 <kyagrd> GHC don't seem to support nested GADT patten matching well.
16:07:01 <kerlo> The Rule of Natural Language: Whenever you have two of something in a row, get rid of one.
16:07:03 <pumpkin> SubStack: do you live on tristan da cunha?
16:07:05 <kyagrd> have to break down several case expressions
16:07:11 <eu-prleu-peupeu> ohh thats a pitty pumpkin
16:07:19 <eu-prleu-peupeu> i hope to meet lots of great haskle coderz!
16:07:21 <pumpkin> ... in the type system!
16:07:24 <eu-prleu-peupeu> that can teach me a lot!
16:07:25 <pumpkin> eu-prleu-peupeu: haskell ;)
16:07:26 <SubStack> I don't think so.
16:07:29 <monochrom> Such as "OOP" becomes "OP"?
16:07:33 <kerlo> That's why people don't say "What if if X happened, Y happened"?
16:07:34 <pumpkin> they can teach you to spell haskell first :D
16:07:43 <kerlo> Yep. Oriented Programming.
16:07:44 <gueux> when I try to connect to the other server from the first one the connection is being closed
16:07:47 <kerlo> I mean, Programing.
16:07:48 <whpearson> C+?
16:07:59 <kerlo> Make C only a litle bit beter.
16:08:07 <skorpan> i wouldn't say better...
16:08:18 <int-e> kerlo: Done right, it would make both C and C++ better.
16:08:23 <monochrom> I had Object Obfuscation Pomposity in mind. I guess Obfuscation Pomposity would do.
16:08:26 <kerlo> Inded.
16:08:38 <kerlo> This is the point where I realize this isn't #lojban.
16:08:48 <sjanssen> no, "C++" becomes "Unexpected end of input"
16:08:49 <whpearson> Does this patch sem sane? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1528#a1528
16:08:50 * SubStack omits lettrs
16:09:00 <cytzol> leters
16:09:05 <SubStack> orite
16:09:19 <sjanssen> whpearson: seems very reasonable
16:09:23 <cytzol> that is the way on frenode #haskel
16:09:42 <kerlo> Inded, I'd forgoten this place was so maleable.
16:09:49 <pumpkin> whpearson: there's a mostly meaningful version for Float/Double that you're missing out on there :/
16:09:51 * cytzol just spent the evening making a colouriser for ghci, only to realise that it doesn't actually look very nice
16:10:05 <monochrom> whpearson: good
16:10:09 <sjanssen> whpearson: though it might be useful to use a newtype of Maybe, so you can support types that don't have MaxBound
16:10:19 <kerlo> Anyway, this is why we say (:-)
16:10:46 <rwbarton> pumpkin: if someone wants the Infinity/-Infinity instance they can define instance Bounded Double where ...
16:10:48 <whpearson> pumpkin: The correct way would be to make Float/double Bounded?
16:10:55 <SubStack> can anyone be truly happy when using parentheticals?
16:11:31 <pumpkin> how about integer?
16:11:34 <nominolo> anyone know whether StrategyLib / Strafunski offers anything over SYB?
16:11:44 <glguy> [-1/0..1/0]
16:11:45 <pumpkin> I guess integer isn't a monoid in that case
16:11:53 <glguy> > [-1/0..1/0] -- :>
16:11:54 <lambdabot>   [-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Inf...
16:11:59 <glguy> We'll get there!
16:12:13 <sjanssen> is there a name for things that have an mappend, but no mempty?
16:12:15 <SubStack> that's pretty nifty glguy
16:12:22 <rwbarton> sjanssen: semigroups
16:13:38 <whpearson> sjanssen, pumpkin: I was thinking about the Integer case and you can do it with something a bit like a monoid, that has a function instead of mempty
16:13:56 <pumpkin> how do you mean?
16:14:19 <rwbarton> whpearson: you could also have  data WithBounds a = Bottom | Middle a | Top deriving (Ord)
16:14:26 <whpearson> That takes a value and returns something that is mempty in respect to that value.
16:15:11 <pumpkin> hmm
16:15:33 <pumpkin> well, you only need a lower bound for min and an upper bound for max
16:15:33 <Eridius> is there a list somewhere of open-source projects that use Haskell? I'm wondering if there's anything out there that I might want to get involved in
16:15:56 <rwbarton> pumpkin: it's true, but there are no separate BoundedBelow and BoundedAbove classes
16:16:04 <pumpkin> maybe there should be! :P
16:16:05 <whpearson> pumpkin: This might explain better -> http://vrrm.wordpress.com/2009/02/18/haskell-vmonoids/
16:16:10 <pumpkin> for when we introduce Natural
16:16:12 <pumpkin> :D
16:16:13 <sjanssen> rwbarton: do you think it would be a good idea to provide a Semigroup class?
16:17:04 <sjanssen> http://www.haskell.org/ghc/docs/6.8.3/html/libraries/base/src/Data-Monoid.html search for semigroup
16:17:17 <NameAlreadyInUse> alright, i've got gtk2hs up and working
16:17:52 <rwbarton> sjanssen: I'm not a big fan of semigroups but if it were possible to add a Semigroup superclass of Monoid I think it would be good to have
16:17:58 <NameAlreadyInUse> but it was complaining about some gtk+ dll's being in the system path, does it matter? i already had the gtk+ bundle 2.14 installed
16:18:04 <rwbarton> sjanssen: there's been a thread on haskell-cafe just today about semigroups
16:18:24 <rwbarton> sjanssen: but of course it has all the same problems as (insert your favorite refinement of the standard type class hierarchy)
16:19:32 <Eridius> hrm, why is cabal not bothering to install dependencies when I say `sudo cabal install some-package` but instead just complaining they're not installed?
16:19:36 <sjanssen> rwbarton: of course
16:19:48 <sjanssen> somebody needs to get cracking on type class aliases
16:19:56 <pumpkin> yeah!
16:20:41 * whpearson thinks he'll try doing rwbartons extension
16:20:46 <Gracenotes> > let nub (x:x:xs) = x:nub xs; nub (x:xs) = x:nub xs; nub xs = xs in nub [1,2,2,3,3,4]
16:20:47 <lambdabot>       Conflicting definitions for `x'
16:20:48 <lambdabot>      In the definition of `nub'
16:20:56 <Gracenotes> so apparently ^^ was allowed in Miranda
16:21:18 <dcoutts> NameAlreadyInUse: you're on windows I guess? Yes it is fairly important that it picks up the right versions of the dlls.
16:21:20 <Gracenotes> but removed because everything isn't an Eq, I assume
16:21:44 <dcoutts> Eridius: are you talking about dependencies on tools like happy, alex?
16:21:54 <Pseudonym> Gracenotes: Yes.
16:21:59 <Eridius> I'm saying I tried `sudo cabal install hexpat` and it complained that c2hs wasn't installed
16:22:09 <Pseudonym> That feature never sat very well with people, though.
16:22:21 <dcoutts> Eridius: right, it doesn't yet track deps on build tools, only on dependent libs.
16:22:27 <Eridius> ah, ok
16:22:59 <Eridius> oh great, hexpat won't even build anyway because c2hs thinks the header file has an error
16:23:05 <sjanssen> Max with semigroups http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1528#a1530
16:23:17 <Eridius> I think c2hs can't handle #directives that don't start on column 0
16:23:21 <karl__> @hoogle
16:23:21 <lambdabot> No query entered
16:23:21 <lambdabot> Try --help for command line options
16:23:35 <karl__> @hoogle (t, t, t) -> [t]
16:23:35 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
16:23:35 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
16:23:47 <dcoutts> Eridius: you mean .chs directives or cpp directives in .h files?
16:24:06 <karl__> hey, what's a function I can use to turn a tuple into a list?
16:24:07 <Eridius> I mean it complained about # on /usr/include/available.h:85
16:24:12 <Eridius> which was an #ifdef that was indented by one tab
16:24:18 <rwbarton> Gracenotes: if you have such a feature you need to specify how the equality tests interact with the top-to-bottom, left-to-right order of pattern matching
16:24:28 <Eridius> well, by 4 spaces
16:24:31 <RyanT5000> so, i'm looking for a clean solution to the problem where you get a key from a Map, then you immediately turn around and lookup that key in that dictionary
16:24:33 <augustss_> karl__: there is none
16:24:37 <karl__> hm
16:24:48 <augustss_> karl__: it's an unusual thing to do
16:24:53 <karl__> then I must be doing something wrong.
16:24:56 <dcoutts> Eridius: hmm, shouldn't be a problem. c2hs doesn't see the original header until it's been pre-processed.
16:25:11 <Gracenotes> rwbarton: presumably it would be semantically equivalent to having a blah == blah2 guard
16:25:25 <pumpkin> RyanT5000: ?
16:25:31 <RyanT5000> i should be able to then look it up with a guaranteed return
16:25:36 <RyanT5000> i.e.: not returning maybe
16:25:37 <Eridius> dcoutts: http://gist.github.com/66634
16:25:37 <dcoutts> Eridius: you might like to report it to the c2hs list. c2hs should be able to parse all C code.
16:26:01 <rwbarton> Gracenotes: so that case (1 : 2 : 3 : undefined) of (x : y : x : []) -> () is _|_?
16:26:03 <RyanT5000> sorry, i'm being unclear; what i mean to say is that i want a way of statically proving that a key is present in a Map
16:26:14 <RyanT5000> and achieving some kind of syntactic improvement as a result
16:26:17 <Eridius> dcoutts: I'd rather not join a new mailing list just to report a bug :/
16:26:22 <dcoutts> Eridius: we'd have to look at the code post-preprocessing
16:26:31 <Eridius> this came from `sudo cabal install hexpat`
16:26:32 <Eridius> so hexpat 0.3
16:26:33 <dcoutts> Eridius: oh sure, there's a track. you don't need to join a list
16:26:34 <rwbarton> RyanT5000: how are you getting the key from the map?
16:26:43 <pumpkin> RyanT5000: just use ! once you know you have the key
16:26:44 <pumpkin> :P
16:26:54 <dcoutts> Eridius: aye, but I'm not on OSX, I'll not be able to reproduce it. I've got different header files.
16:27:02 <RyanT5000> pumpkin: right, but then if i'm wrong, we have a problem :P
16:27:10 <RyanT5000> (and i hate haskell's error reporting)
16:27:30 <rwbarton> RyanT5000: you want the type checker to tell you whether you're wrong? (by not using ! presumably?)
16:27:32 <RyanT5000> rwbarton: suppose i get it by enumerating the keys of the map
16:27:43 <whpearson> Would having Maybe an instance of Bounded with maxBound and minBound = Nothing, be horrible?
16:27:44 <RyanT5000> i want a statically-verified !
16:27:47 <Gracenotes> rwbarton: hm.. depends on how fine-grained it is
16:27:58 <pumpkin> RyanT5000: why do you even need that to happen?
16:28:03 <rwbarton> RyanT5000: OK, then don't enumerate the keys, enumerate the key-value pairs
16:28:19 <pumpkin> I mean, get a key from a map and then look up that key?
16:28:20 <RyanT5000> ok, well i actually have a more complex datastructure
16:28:24 <dcoutts> Eridius: if you upack hexpat and run cabal configure; cabal build -v; then copy the c2hs command line and add --keep
16:28:24 <RyanT5000> with several different kinds of IDs
16:28:38 <sjanssen> whpearson: 'maxBound == minBound' seems ugly to me
16:28:42 <Eridius> I'm looking at the source and I'm wondering where it even invokes c2hs
16:28:42 <pumpkin> RyanT5000: you'd need dependent types I think
16:28:45 <Gracenotes> rwbarton: I suppose I'd allow that degrees strictness :)
16:28:46 <Eridius> `grep -R c2hs .` shows nothing
16:28:51 <Gracenotes> *degree of
16:29:02 <RyanT5000> e.g.: you have playerIDs and buildingIDs (it's a strategy game)
16:29:08 <glguy> > maxBound :: ()
16:29:08 <dcoutts> Eridius: then we want to look at the .i file that c2hs leaves and see what c2hs is actually seeing after cpp is done with the file.
16:29:09 <lambdabot>   ()
16:29:13 <glguy> > minBound :: ()
16:29:14 <lambdabot>   ()
16:29:19 <sjanssen> glguy: blah
16:29:20 <RyanT5000> so there's a function "players" that returns Set playerID
16:29:35 <dcoutts> Eridius: no, you won't see any direct references to c2hs, cabal is the one that calls c2hs on .chs files.
16:29:37 <rwbarton> Gracenotes: but now if it turns out that 1 == 3 is _|_ (because we're in a funny Num instance) the pattern match case [1,2,3] of [x,y,x,w] -> () diverges instead
16:29:43 <Eridius> ah
16:30:02 <pumpkin> you essentially want it to return a KeyDefinitelyPresent key map, and have a lookupMaybe key map give you a KeyDefinitelyPresent key map so you can then call lookupDefinite (KeyDefinitelyPresent key map) and get something without a maybe?
16:30:07 <rwbarton> Gracenotes: so you have to make a choice and it's not really obvious which one you want
16:30:18 <whpearson> I'll try and think of a nicer way.
16:30:18 <RyanT5000> pumpkin: yeah
16:30:19 <sjanssen> glguy: fine, forall x. maxBound < Just x
16:30:20 <glguy> minBound :: Ord a => Maybe a  = Nothing,   maxBound :: Ord a => Maybe a = Just maxBound
16:30:34 <pumpkin> RyanT5000: sounds like a dependent type to me, but I'm no expert :)
16:30:50 <RyanT5000> pumpkin: yeah... i know how to do it with dependent types... i just want to do it in haskell :P
16:31:04 <sjanssen> glguy: 'a' is not an instance of Bounded
16:31:08 <RyanT5000> are there any usable languages that support dependent types?
16:31:19 <glguy> sjanssen, I'm coming into this late :)
16:31:23 <pumpkin> I'm pretty sure you need to do it at runtime :) anyway, you can do fromJust on the Maybe output since you're 100% positive it contains the key
16:31:24 <dcoutts> RyanT5000: depends what you mean by usable.
16:31:25 <Gracenotes> rwbarton: hm? What I'm saying is that it seems to make sense to me to pattern match normally, then check equality where appropriate -- although the choice is somewhat arbitrary.
16:31:26 <Eridius> dcoutts: I'm not seeing a .i file
16:31:40 <glguy> sjanssen, just pointing out that Maybe's Ord instance has Nothing as the minBound
16:31:43 <RyanT5000> dcoutts: i mean i want to write a game for the iPhone, lol
16:31:52 <dcoutts> RyanT5000: then no
16:32:06 <RyanT5000> dcoutts: that's what i thought - even haskell's a bit of a stretch, i think
16:32:13 <dcoutts> Eridius: you ran c2hs manually and added -k near the beginning of the c2hs command line?
16:32:14 <pumpkin> RyanT5000: we don't even have ghc compiling for iphone yet :)
16:32:20 <Eridius> I ran: /usr/local/bin/c2hs --include=dist/build --cppopts=-D__GLASGOW_HASKELL__=610 --output-dir=dist/build --output=Text/XML/Expat/IO.hs ./Text/XML/Expat/IO.chs
16:32:25 <pumpkin> RyanT5000: you writing a text-based game for hugs?
16:32:31 <Eridius> oh there it is
16:32:33 <sjanssen> glguy: instance Bounded a => Bounded (Maybe a) where minBound = Nothing; maxBound = Just maxBound
16:32:33 <dcoutts> Eridius: we need -k or --keep
16:32:41 <dcoutts> Eridius: ok, great
16:32:42 <RyanT5000> pumpkin: can't i shoehorn it using -via-c?
16:32:46 <Eridius> oops the paste missed the --keep. I had it in there
16:32:59 <pumpkin> RyanT5000: it's quite a bit more complex than that I think :)
16:33:02 <Eridius> anyway I'm still seeing preprocessor directives in here
16:33:04 <pumpkin> but you can try
16:33:06 <pumpkin> RyanT5000;
16:33:09 <dcoutts> Eridius: so we should go and look at the equivalent to /usr/include/available.h line 85
16:33:16 <pumpkin> and then if you want a GUI, you need HOC or some other objective-c bridge
16:33:29 <dcoutts> Eridius: really? there are still cpp directives in the .i file?
16:33:38 <gueux> isn't it possible to have a socket inside a socket? the line: "bindSocket sock (SockAddrInet 4242 iNADDR_ANY)" inside a socket turns the connection off
16:33:41 <Eridius> yes
16:33:43 <RyanT5000> pumpkin: i was planning on writing the objective-C stuff in C and then hosting haskell, and having haskell use OpenGL
16:33:56 <dcoutts> Eridius: that'd certainly explain why c2hs is upset. But now we want to know why cpp isn't doing it's job.
16:34:06 <sjanssen> whpearson: by the way, Paterson and Hughes paper on finger trees uses a Maybe-like approach for Max and Min
16:34:11 <pumpkin> RyanT5000: I don't think the .c files ghc produces are very easy to compile yourself
16:34:11 <Eridius> dcoutts: http://gist.github.com/66634
16:34:16 <pumpkin> but I don't know :)
16:34:28 <dcoutts> Eridius: ok, re-run the c2hs command with --dump=trace and lets see how cpp is getting called.
16:34:41 <RyanT5000> pumpkin: well how difficult are we talking here - days, weeks, or months?
16:35:09 <Eridius> Invoking cpp as `cpp  -x=c -D__GLASGOW_HASKELL__=610 dist/build/Text/XML/Expat/IO.chs.h >IO.i'...
16:35:09 <pumpkin> RyanT5000: I dunno, give it a go and see :)
16:35:25 <dcoutts> Eridius: oh, that is odd looking. It seems that cpp is only interpreting cpp directives in column 0
16:35:26 <NameAlreadyInUse> can someone direct me towards a good binding for SDL? there seem to be several but i'm not sure how complete, etc they are
16:35:33 <whpearson> sjanssen, Paterson and Hinze?
16:35:37 <pumpkin> ideally we'd be able to cross-compile straight to mach-o arm from any host
16:35:46 <Eridius> dcoutts: it does appear that way
16:35:48 <sjanssen> whpearson: sorry, you're right
16:36:00 <dcoutts> Eridius: try the equivalent cpp command but replace cpp -x=c by gcc -E -x c
16:36:36 <dcoutts> Eridius: and look at the .i file produced by that, compare, lets see if that's any better looking
16:36:59 <Eridius> dcoutts: the resulting .i file looks quite different
16:37:20 <Eridius> it looks like that worked as expected
16:37:35 <whpearson> sjanssen: Thanks I'll take a look.
16:37:39 <dcoutts> Eridius: ok, so macosx cpp is borked :-)
16:38:04 <dcoutts> Eridius: I guess when we invoke it as cpp it uses some ancient traditional compatibility mode
16:38:10 <Eridius> dcoutts: is it? or are non-column-0 preprocessor directives a gcc extension?
16:38:28 <dcoutts> Eridius: they might be, I've no idea.
16:38:49 <dcoutts> Eridius: fortunately this has already been changed in the darcs version of c2hs. So I'll get that released soon.
16:38:54 <Eridius> great
16:39:02 <dcoutts> Eridius: thanks for helping tracking this down.
16:39:06 <Eridius> np
16:39:54 * wli actually managed to implement quotRem for the Nat module.
16:40:20 <wli> Albeit horribly inefficiently and awkwardly.
16:42:07 <Eridius> dcoutts: `darcs get http://darcs.haskell.org/c2hs/` fails with an unapplicable patch
16:42:13 <Eridius> ...from 2002
16:42:35 <dcoutts> Eridius: use --partial. It's due to case insensitive file system.
16:42:38 <Eridius> ah
16:42:54 <dcoutts> well, it's a darcs bug, but related to case insensitive file systems
16:43:13 <Eridius> hrm, website says to execute autoconf, but doing that says no input file
16:43:57 <dcoutts> Eridius: oh, the website is out of date. it uses cabal
16:44:02 <dcoutts> just cabal install
16:44:41 <Eridius> woot, hexpat just built and installed
16:45:21 <dcoutts> yay
16:45:36 * dcoutts will endeavour to release c2hs-0.16.0 soon
16:45:49 <dcoutts> just as soon as I'm done with Cabal-1.6.0.2 and cabal-install-0.6.2
16:46:10 * dcoutts uploads the Cabal-1.6.0.2 release...
16:46:17 <Eridius> heh
16:48:47 <Eridius> oh great, all this work was useless. The project I wanted to check out (c-repl, on github) doesn't even build with ghc 6.10.1. Well, actually ti's the Distribution.Simple version that it's conflicting with
16:49:56 <Eridius> which I guess means Cabal
16:50:29 <gueux> I try to declare an instance of the Class Stream but I have an error ""`close' is not a (visible) method of class `Stream'"
16:51:12 <sjanssen> Eridius: you can certainly install and use older or newer versions of Cabal
16:51:17 <gueux> and that for the four methods of the Class Stream
16:52:09 <sjanssen> gueux: is close a method of Stream?  Have you imported it?
16:53:12 <gueux> I've declared a type
16:53:38 <sjanssen> gueux: could you hpaste what you've got?
16:53:40 <gueux> and I try to instanciate it as an instance of Stream
16:53:48 <gueux> ok
16:53:49 <gueux> :-)
16:54:48 <gueux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1531#a1531 [+]
16:54:56 <gueux> (in the end)
16:55:27 <sjanssen> gueux: where does the Stream class come from?
16:55:40 <Eridius> sjanssen: I don't want to use older versions of cabal
16:56:13 <sjanssen> Eridius: you can install and use it for just this one package
16:56:31 <sjanssen> eg ghc --make Setup -package Cabal-w.x.y.z
16:56:39 <Eridius> sjanssen: I just wanted to play around with this thing, not actually use it for anything real, so it's not even worth that
16:57:25 <gueux> sjanssen: what do you mean?
16:58:08 <sjanssen> gueux: I've never heard of the 'Stream' class, where does it come from?
16:58:13 <gueux> ok
16:58:18 <gueux> http://hackage.haskell.org/packages/archive/HTTP/3001.0.4/doc/html/Network-Stream.html
16:59:47 <dcoutts> sjanssen: would you like to check the new cabal releases for "brown paper bag" bugs? :-)
17:00:01 <dcoutts> http://haskell.org/cabal/release/rc/Cabal-1.6.0.2.tar.gz
17:00:02 <dcoutts> http://haskell.org/cabal/release/cabal-install-0.6.2.tar.gz
17:00:08 <sjanssen> gueux: try adding import Network.Stream
17:00:21 <gueux> I've tried it
17:00:29 <gueux> now I have new errors
17:00:37 <dcoutts> cabal-install has a new improved bootstrap however that will not quite work perfectly 'til Cabal-1.6.0.2 is on hackage
17:00:48 <sjanssen> gueux: progress :)
17:00:53 <gueux> :-)
17:01:08 <dcoutts> if anyone can give the above two a spin and let me know the outcome that'd be great
17:01:30 <FunctorSalad_> hmm how would I find external process calls in the profiler output?
17:02:38 <gueux> the line 119 of: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1532#a1532 [+] close the client's connection
17:02:59 <gueux> do you know where can be the problem?
17:04:34 <sjanssen> dcoutts: the former builds, the latter is 403: Forbidden
17:04:41 <gueux> (I call main => mainLoop => mainConn => gameChan
17:04:46 <gueux> )
17:05:34 <dcoutts> sjanssen: thanks, fixed the perms.
17:06:01 <whpearson> I've added a revision to my Min/Max monoids, adding UMax and UMin monoids for unbounded types.
17:06:03 <whpearson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1532#a1532
17:07:18 <MyCatVerbs> whpearson: how can you have a mempty for an unbounded type?
17:07:39 <rwbarton> whpearson: I feel UMin has the wrong Ord instance
17:08:10 <whpearson> MyCatVerbs: They are Maybe unbounded types with Nothing being the Min or Max, repectively.
17:08:33 <whpearson> rwbarton: Hmm, True.
17:08:54 <MyCatVerbs> Ah. data UMin a = PosInfty | UMin a, in effect.
17:09:04 <sOpen> join #xmonad
17:09:26 <rwbarton> BTW, I think reactive has a type that adds a new (lower?) bound
17:09:45 <sjanssen> dcoutts: seems to work
17:10:01 <dcoutts> sjanssen: ta
17:10:01 <sOpen> curse you, slash key!
17:10:08 <rwbarton> whpearson: oh actually reactive has Data.{AddBounds,Min,Max}
17:10:31 <whpearson> MyCatVerbs: Yup.
17:11:10 <NameAlreadyInUse> has anyone built hsSDL on windows before?
17:11:19 <sjanssen> gueux: what is the error message?
17:11:20 <whpearson> rwbarton: Heh. I'll file it away to have a look at. It is night for me.
17:11:27 <rwbarton> whpearson: http://hackage.haskell.org/packages/archive/reactive/0.10.5/doc/html/Data-AddBounds.html
17:12:32 <gueux> sjanssen: I just have: Connection closed by foreign host.
17:12:39 <gueux> for the client
17:12:53 <gueux> and for the server there is no error message
17:14:45 <jasondew> is it possible to generate pseudorandom numbers in pure code?
17:15:06 <skorpan> given a seed, yes, i guess so
17:15:11 <augustss__> yes and no
17:15:22 <Eridius> why no?
17:15:32 <jasondew> i've tried the examples in both real world haskell and on the haskell wiki with no luck
17:15:51 <augustss__> not without a seed that you keep changing
17:16:00 <rwbarton> http://xkcd.com/221/
17:16:26 <sjanssen> > randomRs (0, 10) (newStdGen 42)
17:16:27 <lambdabot>   Couldn't match expected type `t -> g'
17:16:37 <augustss__> simula used the seed method too so it must be good.
17:16:44 <sjanssen> > randomRs (0, 10) (mkStdGen 42)
17:16:45 <lambdabot>   [4,9,3,3,5,8,6,5,4,8,4,8,6,5,3,4,8,5,7,1,10,10,5,3,5,4,6,5,7,9,1,6,6,4,4,2,...
17:18:47 <jasondew> @janssen thanks :)
17:18:47 <lambdabot> Unknown command, try @list
17:20:47 <gueux> I've written a simpler version
17:20:49 <gueux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1534#a1534 [+]
17:21:32 <gueux> which does not require the Crossway module
17:21:44 <gueux> like that it compiles
17:21:55 <gueux> but it has the same problem
17:22:01 <tehgeekmeister> get >>= (lift print) is not right for printing state in StateT
17:22:02 <tehgeekmeister> what is?
17:22:32 <tehgeekmeister> @type lift print
17:22:33 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t, Show a) => t ((->) a) (IO ())
17:22:38 <gueux> I just run main, and then connect via telnet localhost 4242
17:25:14 <tehgeekmeister> @type lift . print
17:25:15 <lambdabot> forall (t :: (* -> *) -> * -> *) a. (Show a, MonadTrans t) => a -> t IO ()
17:29:25 <NameAlreadyInUse> what does it mean when "copyFile does not exist"?
17:32:31 <agentzh> guenni: pong
17:32:49 <guenni> agentzh: hi there
17:32:58 <agentzh> :)
17:33:18 <agentzh> i've just seen you were talking about sql and parsec :)
17:33:41 <guenni> agentzh: and been doing a lot of googling about it too :)
17:33:48 * agentzh nods.
17:34:03 <guenni> agentzh: so you name came up every now and them
17:34:11 <agentzh> :P
17:34:37 <guenni> agentzh: I could do with some advice, all the Business logic in my app is in sql
17:34:39 * agentzh just wrote a minisql parser.
17:34:55 <agentzh> guenni: and?
17:34:57 <guenni> sql strings actually and I'm not too happy with that
17:35:12 <agentzh> guenni: in haskell?
17:35:17 <llayland> I built a pl/sql parser (sort of) which of course includes sql
17:35:20 <guenni> yes
17:35:41 <guenni> and I'd like to bring them into some other form
17:35:47 <agentzh> llayland: wow. i was also targeting pg's sql :P
17:35:52 <guenni> agentzh: any suggestions?
17:36:03 <agentzh> guenni: quasiquotes?
17:36:12 <agentzh> guenni: or some combinator love?
17:36:16 <guenni> agentzh: sry?
17:36:19 <llayland> big target :)
17:36:36 <agentzh> guenni: or just define a bunch of stored procedures?
17:36:48 <agentzh> guenni: and then simply call them from your haskell code?
17:36:50 <guenni> no, no stored procedures
17:37:17 <guenni> at the end of the day of course I will need sql strings again
17:37:33 <guenni> but I just don't want to use literal sql strings in my code
17:37:44 <agentzh> guenni: quasiquotations gives you sql-ish sqk while combinators give you haskell-ish sql :)
17:37:46 <gwern> hm. what would happen if I tried to run a instance of gitit on community.haskell.org?
17:37:49 <agentzh> *sql
17:38:16 <guenni> well actually I propably was thinking about combinators then :)
17:39:09 * agentzh thinks mudding with stored procedures might be one of his best practices.
17:39:43 <guenni> agentzh: well in this case not such a good idea because I'm using Sqlite
17:39:43 <agentzh> but i'm fiddling with a *huge* amount of sql strings in my openresty codebase
17:39:54 <agentzh> well, they're quasiquotes in the Perl world :)
17:40:05 <agentzh> guenni: i see :)
17:41:07 <guenni> agentzh: and also I'll need to refine these statements until I get them right but want to get away from strings
17:41:22 * wli is still looking for commentary on the Nat module.
17:41:22 * agentzh just worries about that (little) runtime performance penalty involved in combinators :P
17:42:07 <agentzh> guenni: then combinators should give you the best flexibility :)
17:42:13 <guenni> agentzh: right now that is so not a problem, actually I was told to slow the app down in any case, it alread runs too fast
17:42:23 * agentzh wows.
17:42:44 <agentzh> llayland: indeed :)
17:43:24 <wli> http://pastebin.com/m3ae17c15 <-- the Nat module
17:44:04 <guenni> agentzh: about the combinator approach, could you point me to something more detailed?
17:45:03 * gwern waits impatiently on the upload of gitit. hurry up!
17:46:17 <SamB_irssi> gwern: community.haskell.org ? that was crawling this morning ...
17:47:41 <gwern> 24kb/s :(
17:47:54 <kerlo> What function will turn [a, b, ..., y, z] into [a, b, ..., y, f z]?
17:48:33 <SamB_irssi> gwern: I speak of HTTP, btw, not SSH
17:48:41 <SamB_irssi> oh, also last night
17:48:52 <gwern> begone storm petrel
17:49:09 <guenni> kerlo: you want f to be applied only to least element?
17:49:54 <kerlo> guenni: yep.
17:50:00 <gwern> guenni: he must, else it'd be ill-typed wouldn't it?
17:50:21 <llayland> > (\x -> heads s ++ (+999) tail x) [1,2,3]
17:50:22 <lambdabot>   Not in scope: `heads'
17:50:23 <SamB_irssi> http://haskell.org/haskellwiki/Image:Trac-crawling.png
17:50:34 <llayland> crud
17:50:51 <gwern> SamB_irssi: you showed me that already
17:51:07 <SamB_irssi> gwern: I can't remember who I showed what, okay ;-P
17:51:34 <guenni> kerlo: I can't think of anything prebuilt, but you could easily define your own via pattern matching
17:51:36 <gwern> o.0
17:51:40 <SamB_irssi> so, uh, I'd be prepared for it to happen again, since nobody knows what happened
17:51:42 <NameAlreadyInUse> is there a GLUT module in the latest GHC? i've tried "Graphics.UI.GLUT" but it doesn't exist
17:51:50 <agentzh> guenni: hsql?
17:51:52 <SamB_irssi> Igloo just restarted apache
17:52:10 <gwern> SamB_irssi: one would think you could remember who you showed what, else people might get the wrong ideas about you
17:52:15 <guenni> agentzh: I had been using hdbc so far
17:52:37 <SamB_irssi> eh, well, it was early and/or late when last I showed that to someone
17:52:49 <SamB_irssi> come to think of it, I should have gone home hours ago this time
17:52:50 <guenni> agentzh: or was that meant as a suggestion?
17:53:12 * agentzh looks for that pdf.
17:53:21 <gwern> nooooo
17:53:28 <gwern> c.h.o can't execute my gitit binary
17:53:58 <gwern> uname -a: linux i686??? NOOOO
17:54:21 <SamB_irssi> gwern: gitit: /home/gwern/bin/share/gitit-0.5.3/data/template.html: copyFile: does not exist (No such file or directory)
17:54:24 <SamB_irssi> ?
17:54:26 <gwern> wait, I'm on i686 too
17:54:31 <gwern> -_-
17:54:42 <SamB_irssi> that's what happens when *I* try to run it
17:54:42 <gwern> SamB_irssi: hm? what's that?
17:54:52 <mooism> I have a cabal-install problem --- http://pastebin.com/d5a040ec3 --- any ideas how I can fix it?
17:54:53 <gwern> you sure you running it with the right args?
17:55:00 * wli arghs at the silence wrt. the Nat module.
17:55:00 <SamB_irssi> not at all
17:55:13 <gwern> SamB_irssi: the right args look like 'gitit -f static/Config.hs'
17:55:15 <SamB_irssi> but it would seem to indicate that it will load fine at the linker level ;-P
17:56:03 <gwern> ah, that's interesting. my recorded config.hs would seem to be out of date.
17:56:23 <agentzh> guenni: http://www.cs.chalmers.se/~bringert/publ/haskelldb/haskelldb-db-2005.pdf
17:56:37 <agentzh> guenni: i think haskelldb might be the right way to go :)
17:56:55 <agentzh> guenni: sorry i've been massively distracted because i'm at $work :P
17:56:59 <SamB_irssi> gwern: anyway, I was only running the one you uploaded to your home dir ...
17:57:12 <guenni> agentzh: np and thx
17:57:18 <agentzh> :)
17:57:22 * gwern fixes
17:57:43 <SamB_irssi> for no real reason besides to see if you were right about the arch thing
17:57:48 <gwern> http://community.haskell.org:5001/ bwa ha ha!
17:58:03 * gwern is in ur hos, rooting their upper ports
17:58:15 <SamB_irssi> or um, that's fine
17:58:25 <SamB_irssi> get 1023 or so and we'll start worrying
17:58:30 * gwern admires my latest work: http://community.haskell.org:5001/N-back
17:58:49 <gwern> SamB_irssi: yeah I know below that is reserved to root. I'm just surprised that it worked at all
17:59:23 <gwern> there must be *some* rule against using cho as your personal wiki server :)
17:59:34 <SamB_irssi> probably
17:59:52 <SamB_irssi> I decided that it would be a bad idea to use it as a smoke server for LHC
18:00:01 <SamB_irssi> considering how much resources that takes
18:00:14 <gwern> smoke server = continual rebuilds?
18:00:41 <gwern> ooh, actually this is a good chance to see real world benchmarks for gitit
18:00:43 <SamB_irssi> er, well, if by "continual" you mean "whenever the last one finishes"
18:00:45 * gwern turns on firebug & yslow
18:01:28 <guenni> agentzh: I had come accross this earlier, have you used it yourself yet?
18:01:44 <agentzh> guenni: nope
18:02:03 <johannh> Newbie question: Is there any convenient way to compose an injection with equals to get an equivalence in the range?  Basically I want a nicer way to write \x y -> (f x) == (f y).
18:02:07 <guenni> how do you handle this problem?
18:03:12 * agentzh would rather use haskell for parsers/compilers/maths.
18:03:53 <agentzh> better no db apps :P
18:03:53 <nominolo> johannh: is comparing close enough?
18:03:53 <ddarius> johannh: (==) `on` f
18:03:53 <nominolo> :t comparing
18:03:53 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
18:03:53 <ddarius> @hoogle equaling
18:03:53 <lambdabot> No results found
18:03:53 <guenni> agentzh: don't have a choice, tried HAppS-IxSet and that blew up
18:03:53 <ddarius> @hoogle equal
18:03:53 <lambdabot> System.FilePath.Posix equalFilePath :: FilePath -> FilePath -> Bool
18:03:53 <lambdabot> System.FilePath.Windows equalFilePath :: FilePath -> FilePath -> Bool
18:03:53 <lambdabot> Language.Haskell.Lexer Equals :: Token
18:03:53 <agentzh> guenni: heh
18:03:53 <nominolo> :t on
18:03:53 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:03:53 <guenni> :info on
18:03:57 * wli could really use a bit of help on the division algorithm.
18:04:11 <wli> What I've got there is total crap.
18:04:40 <ddarius> @hoogle equating
18:04:40 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
18:05:01 <johannh> nominolo: comparing is pretty good
18:05:30 <gwern> ouch, 9s to load. all those requests are killing me
18:05:30 <ddarius> johannh: equating is exactly what you want, but it is in a weird place
18:05:30 <johannh> ddarius: And "on" is it exactly, thanks.
18:05:31 <gwern> 1.95s to transfer 8kb of gzipped text???
18:05:54 <ddarius> gwern: Perhaps you got a connection through a 2400 baud link.
18:06:15 <gwern> thank god for the caching of the css/js/pngs!
18:06:23 <BMeph> @src comparing
18:06:24 <lambdabot> Source not found. stty: unknown mode: doofus
18:06:26 <gwern> ddarius: no, my connection is fine, it's c.h.o
18:06:38 <gwern> ddarius: see for yourself, browse http://community.haskell.org:5001/
18:06:40 <johannh> ddarius: Yep, equating is it. Thanks.
18:06:57 <BMeph> @src on
18:06:57 <lambdabot> (*) `on` f = \x y -> f x * f y
18:08:31 <Igloo> gwern: It looks like gitit is leaking memory, which is going to cause problems
18:09:00 <gwern> Igloo: that's the caching
18:09:16 <gwern> at least, me and john are reasonably sure that we fixed the leaking and that's just caching
18:09:36 <gwern> hm, the css isn't being gzipped. why didn't we do that...
18:10:53 <Igloo> gwern: Hmm, OK. It might be a problem anyway
18:12:25 <gwern> good, according to the stderr the cache is working
18:12:47 <gwern> that saves about .3s - no need to have pandoc render teh markdown into html when the html is cached
18:15:13 <NameAlreadyInUse> is there any way to check a module version?
18:15:44 <gwern> Igloo: most annoying I think is the constant 1/2% cpu use of gitit
18:17:11 <tehgeekmeister> i overflowed the stack.  is this probably an infinite loop?
18:17:20 <kerlo> apt-get install libhugs* failed to install anything. Now what should I do, I wonder.
18:20:33 <jberryman> lloking through hackage now, but are there any tools to help in testing bits of code? I would like something that could extract a function and its dependencies to a new file, for example
18:21:58 <kerlo> GHC doesn't work on normish.org. I don't suppose there are many other good Haskell compilers or interpreters out there.
18:22:08 <gwern> not really
18:22:26 <kerlo> I think I'm using Haskell 98 with the Network module.
18:26:37 <tehgeekmeister> it is amazing to me how my program can take a one megabyte file and turn it into 150 megabytes of memory usage.
18:27:54 <ddarius> It's pretty easy to do with Strings.  You are looking at 12/24 bytes per cons.
18:28:40 * wli needs to get a better division algorithm.
18:28:44 <tehgeekmeister> hmm, i was using strings because i'm only working with small stuff
18:28:54 <tehgeekmeister> bytestring would be better, i'm guessing?
18:29:34 <ddarius> For (very) small strings, bytestrings have greater overhead than Strings.
18:29:50 <tehgeekmeister> they are single words
18:30:04 <ddarius> I believe they are about comparable at that level.
18:30:22 <tehgeekmeister> okay
18:31:36 <ddarius> What you really want to do, if possible, is not have all the file in memory at the same time.  If not possible, then choosing a more space-efficient representation may or may not be advisable.  Run-time representations are almost always more space-wasteful than file format.s
18:32:06 <tehgeekmeister> yeah, right now i'm sure i'm using a horrible representation
18:32:10 <wli> I've got quite a bit of work to do for ArbFloat if my arbitrary-precision Nat is this hacky.
18:32:18 <tehgeekmeister> i have i think three maps mapping different directions
18:32:23 <tehgeekmeister> that all store essentially the same data
18:32:35 <tehgeekmeister> what i really need is a database or something like happs-ixset
18:32:53 <tehgeekmeister> but it'd slow me down to change right now, so i'm going to do that change after i get to a better stopping point
18:34:07 * wli has hit the multiply-indexed dataset issue as well.
18:35:15 <tehgeekmeister> from what i understand of how happs-ixset works, it would solve this, but i'm hesitant to touch anything from happs until i try to learn all of it.  it seems to be very tangled up together right now.
18:36:56 <conal> hi all.  i've had my nose buried in icfp writing lately and so haven't been around here much.  i have a draft paper some of you might enjoy.  i'd sure appreciate feedback on it.  abstract & pdf pointer at http://conal.net/blog/posts/denotational-design-with-type-class-morphisms/
18:41:08 <jberryman> what kinds of tools are available to do things like analyze haskell source and pick out the functions, examine how they interact, etc. Can I leverage GHC to do this?
18:42:37 <Saizan> jberryman: the ghc-api can help i guess
18:49:22 <llayland> I;m trying to understand the phrase "least fixed point of a functor". I get everything but the word least.  What is the partial ordering
18:49:33 <llayland> of functors?
18:51:01 <tehgeekmeister> http://tinyurl.com/dhj6h4 <== checkForTargets is not finding all targets it should in this code.  i'd greatly appreciate any help figuring out why.
18:51:37 <tehgeekmeister> in fact, it is always making a IntSet of size zero and calling that the new targets.  which is entirely wrong.
18:51:59 <tehgeekmeister> this is all in the makeReader function
18:52:59 <Saizan> llayland: if we think of types as sets, then it's inclusion
18:53:21 <Saizan> llayland: the ordering is on the fixed points, not on the functors
18:54:00 <llayland> ah, so the set of fixed points with the least members
18:54:09 <roconnor> yes
18:54:37 <Saizan> each fixed point is a set, and you pick the intersection of all of them
18:54:57 <llayland> Thanks.  that makes sense.
18:56:14 <tehgeekmeister> @type unsafePerformIO
18:56:15 <lambdabot> Not in scope: `unsafePerformIO'
18:56:35 <dmwit> ?type Foreign.unsafePerformIO
18:56:36 <lambdabot> forall a. IO a -> a
18:58:17 <jberryman> Saizan: thanks
19:04:34 <kerlo> > Foreign.unsafePerformIO (return "hi")
19:04:35 <lambdabot>   /tmp/5717391128432340754:70:32:
19:04:35 <lambdabot>      Not in scope: `Foreign.unsafePerformIO'
19:04:48 <kerlo> Cool, we get to see what file it is.
19:05:01 <dolio> > Foreign.unsafePerformIO (return "hi")
19:05:02 <lambdabot>   /tmp/3856105952771408882:70:32:
19:05:03 <lambdabot>      Not in scope: `Foreign.unsafePerformIO'
19:05:14 <dolio> Different one every time. :)
19:05:32 <kerlo> I imagine it's not predictable.
19:08:19 <kerlo> Or maybe it decreases by 1861285175660931872 every time.
19:08:45 <dolio> Yeah, that's probably it.
19:09:25 <dolio> Huh, according to some random benchmarks on c.l.functional, F# is faster than OCaml.
19:09:28 <dolio> And FreePascal.
19:09:37 <dolio> And so is Clojure.
19:09:55 <MyCatVerbs> Clojure, seriously?
19:09:59 <tehgeekmeister> anyone have a trick they use for tracking down where their code starts to do the wrong thing?
19:10:28 <llayland> I usually look at the first character I typed
19:10:38 <tehgeekmeister> if haskell had a gdb style debugger and i could step thru evaluation i could figure it out.
19:10:47 <tehgeekmeister> llayland: just the first?
19:10:49 <dolio> MyCatVerbs: After they fixed the benchmark, I guess. His first-pass at clojure was 100 times slower than the others.
19:11:22 <llayland> yeah that's where it starts to go wrong - gets worse from there :)
19:11:24 <MyCatVerbs> tehgeekmeister: Mostly I abuse the ever-loving Hell out of Debug.Trace.
19:11:43 <MyCatVerbs> tehgeekmeister: GHCi has had a debugger built in since 6.8.something, but I find it too painful to use.
19:11:45 <kerlo> Stare at the code and use sheer mental power, or just evaluate stuff.
19:11:58 <kerlo> Proving that the code works is a good way to know why it doesn't work.
19:12:11 <tehgeekmeister> kerlo: how do you go about proofs of that sort?
19:12:14 <MyCatVerbs> kerlo: yeah, at the point where you hit a contradiction. :)
19:12:28 <tehgeekmeister> (altho i'm sure i couldn't manage such a proof anyway.)
19:12:54 <kerlo> If you believe it should work, write down your reasoning and form it into a proof. If you don't believe it should work, throw it away and write something that you believe should work. :-)
19:13:11 <MyCatVerbs> tehgeekmeister: informally. Just try to prove to yourself that your program does the correct thing. If it's buggy, then by definition you will at some point find a problem with your attempt to prove it correct. :)
19:13:35 <rwbarton> The problem with this proof approach is it's easy to make the same mistake in your proof that you made while writing the buggy code.
19:13:42 <MyCatVerbs> tehgeekmeister: the approach I take to debugging Haskell, usually, is a mixture of abusing Debug.Trace and trying things manually in the REPL.
19:14:00 <MyCatVerbs> rwbarton: go slower. Oh well.
19:14:12 <tehgeekmeister> i think i need to make more of these functions top level
19:14:16 <tehgeekmeister> so i can test them individually
19:14:25 <kerlo> Go slower. Once you've gone slow enough, you'll be ready for a formal proof checker.
19:14:25 <rwbarton> tehgeekmeister: yes
19:15:15 <MyCatVerbs> tehgeekmeister: yes, I do that a lot as well. Make things top-level, test them manually, (or write quickcheck properties too, perhaps, but that's overkill for debugging).
19:15:29 <rwbarton> tehgeekmeister: testing specific cases and narrowing down which function is producing wrong output is a great way to start
19:15:39 <tehgeekmeister> haven't ever used quickcheck, but i want to learn it
19:15:44 <tehgeekmeister> i know where the problem is
19:15:49 <tehgeekmeister> well, which function
19:15:55 <tehgeekmeister> but i have no idea why it's not working
19:16:04 <tehgeekmeister> because i haven't changed it's code and it was working recently
19:16:05 <rwbarton> Well, this helps more if your functions are sufficiently small of course
19:16:57 <rwbarton> In my experience all three of (1) it's actually working (2) you actually changed its code (3) it wasn't working before are approximately equally likely :)
19:17:38 <tehgeekmeister> i'm going to take the approach of breaking it all into smaller more manageable functions
19:17:42 <tehgeekmeister> and testing them all thoroughly
19:18:18 <tehgeekmeister> now a tricky question
19:18:38 <tehgeekmeister> these functions want to be executed inside another function which is in the state monad
19:18:43 <tehgeekmeister> how do i do that in the top level in ghci?
19:18:57 <Saizan> runState?
19:18:59 <Sam__> runState
19:19:01 <tehgeekmeister> use execState on the individual functions and supply a dummy state?
19:19:16 <tehgeekmeister> okay
19:19:26 <tehgeekmeister> wasn't sure if there was some problem with doing that in the top level
19:19:41 <Sam__> why would there be ?
19:19:45 <Sam__> it's just a function!
19:20:03 <tehgeekmeister> yes but it's in a monad
19:20:09 <tehgeekmeister> and monads are still scary and confusing
19:20:11 <tehgeekmeister> =P
19:20:21 <tehgeekmeister> albeit a lot less so than they once were
19:20:25 <tehgeekmeister> they are still not warm fuzzy things
19:20:40 <monochrom> numbers are scary and confusing
19:20:51 <Pseudonym> Monads have evolved to be burritos.
19:20:57 <tehgeekmeister> burritos?
19:21:05 <tehgeekmeister> hmm, i could go for a burrito.
19:21:11 <Pseudonym> Burritos aren't warm and fuzzy unless they've gone off.
19:21:25 <monochrom> sometimes they say "you can't divide them" and sometimes they say "you can divide them"
19:21:54 <dolio> They're warm, usually.
19:22:00 <dolio> Who likes a cold burrito?
19:22:05 <tehgeekmeister> but fuzzy?
19:22:17 <tehgeekmeister> who likes a *fuzzy* burrito?
19:22:20 <Pseudonym> "Number" is a somewhat vacuous term.
19:22:32 <Pseudonym> tehgeekmeister, that sounds like a euphemism for something.
19:22:34 <Pseudonym> No idea what.
19:22:39 <Sam__> tehgeekmeister: the same people who like fuzzy dice ?
19:22:44 <dolio> Like a "hot lunch"?
19:23:10 <monochrom> sometimes they say "you can't take square root when it's negative" and then next year they say "you can take square root when it's negative"
19:23:22 <Pseudonym> Actually, they don't say that.
19:23:34 <Pseudonym> When numbers are negative, there's never a "the square root".
19:23:46 <Pseudonym> Except when there is, of course.
19:24:11 <monochrom> but the most ridiculous is when they first say "any two numbers can be compared, one of them must be smaller", then next year they say "you can't say i is bigger or smaller than -i"
19:24:12 <Sam__> Pseudonym: well, aren't there two of them ?
19:24:13 <wli> Then there are quadratic residues...
19:24:17 <byorgey> Pseudonym: just because it isn't true doesn't mean "they" don't say it, unfortunately =(
19:24:17 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
19:24:21 <Pseudonym> Sam, exactly.
19:24:23 <Sam__> well, I guess there usually are ;-P
19:24:28 <hotaru2k3> are there any numbers that have only one square root execpt 0?
19:24:54 <Sam__> but the difference is that these two are basically indistinguishable except for being opposite from eachother
19:24:58 <wli> Does x have a square root mod n?
19:25:12 <wli> The integers mod n don't have signs per se.
19:25:18 <Pseudonym> hotaru2k3: In some rings, yes.
19:25:40 <wli> The integers mod n also don't necessarily have square roots... about half of them don't.
19:25:41 <Cale> But not over the complex numbers
19:25:43 <Pseudonym> In regular expressions, for example, the empty string has two square roots.
19:25:55 <Cale> what?
19:25:58 <Pseudonym> Sorry, only one square root.
19:26:16 <monochrom> There is a parallel between numbers and monads that people keep denying.
19:26:26 <Cale> monochrom: which one?
19:26:43 <Pseudonym> You mean there's only one?
19:27:47 <monochrom> They are both abstract data types. To learn them, the correct question is not "what is a number/monad?" The correct approach is practice with a lot of concrete examples and slowly build up the abstract notion.
19:28:13 <Cale> Aww, I was hoping for a correspondence between monads over Hask and rational numbers.
19:28:16 <dolio> Numbers are easy.
19:28:30 <SamB_XP> Cale: you are too into categories ;-P
19:28:33 <dolio> They're a type with (+), (*), (-), negate, abs, signum and fromInteger.
19:28:45 <SamB_XP> dolio: you seem a bit confused
19:28:55 <SamB_XP> granted, SPJ seems a bit confused on this point as well ;-P
19:29:00 <dolio> :)
19:29:09 <monochrom> Numbers are not easy. Kids take 10 years to learn them and still suck at them. (Needing a calculator for 3*10 for example!) It's even harder than natural languages.
19:29:13 <Pseudonym> SPJ isn't confused, regardless of how confused he was in the early 90s.
19:29:36 <SamB_XP> Pseudonym: I'm only saying that because he's down as "Editor" on the Haskell 98 report
19:29:41 <Pseudonym> monochrom, those same kids often don't have a great command of natural languages, either.
19:29:47 <byorgey> @seen gwern
19:29:47 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 1h 7m 39s ago.
19:29:56 * SamB_XP isn't *quite* that bad at arithmatic
19:30:32 * Pseudonym thinks that Integer should be renamed RationalInteger
19:30:43 <SamB_XP> Pseudonym: what ?
19:30:51 <SamB_XP> why Rational ?
19:30:52 <rwbarton> "rational integer" sounds so 1920s to me
19:31:01 <Pseudonym> Rational as opposed to Gaussian, etc.
19:31:19 <Pseudonym> type GaussianInteger = Complex RationalInteger
19:31:20 <SamB_XP> that would just get me confused about "what does this have to do with fractions?"
19:31:39 <Pseudonym> Well, I can't help your personal confusion.
19:32:02 <dolio> Then you just need a standard type that actually able to represent a Gaussian integer.
19:32:35 <dolio> > 1 :+ 3 :: Complex Integer
19:32:36 <lambdabot>       No instance for (RealFloat Integer)
19:32:36 <lambdabot>        arising from a use of `show'...
19:32:54 <Pseudonym> And there's yet another problem.
19:35:10 <wli> Yeah, there are some issues.
19:36:02 <wli> Algebraic ring extensions more generally etc.
19:36:10 <wli> Maybe the Numeric Prelude can do it.
19:36:45 <monochrom> There is a generalization of "integer" so that from any nice field (I forgot the exact requirement. Noetherian?) you can extract a subset and get a nice ring. If you do this to â„š you get â„¤ as expected, but you can do this to more interesting fields. And so the general result is called "the integers of that field".
19:37:02 <SamB_XP> how do `div` and `mod` work on those ?
19:37:08 <Pseudonym> Interesting.
19:37:31 <chessguy_work> hey conal, you around?
19:37:38 <Pseudonym> And what does it take for them to be Euclidean?
19:37:48 <monochrom> The naming problem it brings up is: should you let "integer" to refer to the general result and give another name to â„¤, or should you keep "integer" for â„¤ and find another name for the general result?
19:37:58 <ari> welp, I thought my irc client was speaking utf-8 but I seem to be wrong: I'm reading "if you do this to <square> you get <square> as expected"
19:38:11 <SamB_XP> monochrom: I can't see that character here
19:38:22 <Pseudonym> I would imagine, for example, that the "integers" of rational polynomials are normal polynomials.
19:38:29 <SamB_XP> monochrom: could you please go make MS include it with their OS?
19:38:34 <monochrom> Godawful you people and your 19th Century software.
19:38:45 <SamB_XP> it's actually 21st-century
19:38:46 <monochrom> MS included it since WIndows 2000.
19:38:54 <SamB_XP> hmm
19:38:54 <llayland> any good sites to help a poor schlub get up to speed on these types of math?
19:39:03 <SamB_XP> maybe it's just pango being helpless ?
19:39:03 <Pseudonym> llayland: Right here!
19:39:13 <Pseudonym> I've learned more here than on any web site.
19:39:18 <rwbarton> Pseudonym: I think this particular construction only works inside a finite extension of Q
19:39:27 <Pseudonym> Right.
19:39:31 <Pseudonym> Shame.
19:39:42 <monochrom> I should be helpful.  â„š is Q, â„¤ is Z.
19:39:51 <Pseudonym> And, it seems, trivial.
19:39:52 <mauke> ari: sounds like a font problem
19:40:07 <Pseudonym> Not trivial in the sense of easy to prove, but trivial in the sense that I'd like some integers that are more interesting.
19:40:10 <llayland> pseudonym, probably true once I get a little more background
19:40:15 <monochrom> If that doesn't help let me know. I'll repeat the long paragraph in ASCII.
19:41:53 <SamB_XP> monochrom: the pango here doesn't do the nice thing with the hex digits :-(. but I think I can guess it out.
19:43:03 <Pseudonym> BRB
19:43:25 <ari> mauke: Hm, true. Oh well, with what I know of algebra, it's not like I'd understand the significance anyway...
19:43:41 <ferret_0567> ari: you mean the order of operations?
19:43:49 <monochrom> MS embraces unicode very early on. Don't diss them on this. Diss them for any reason but not this. The OS and the NTFS commit to UTF-16 internally.
19:44:11 <ferret_0567> monochrom: Didn't VMS though?
19:44:25 <monochrom> I don't know about VMS.
19:44:38 <ferret_0567> monochrom: you know what VMS is though, right?
19:44:46 <monochrom> I know.
19:44:59 <ferret_0567> I want to use OpenVMS
19:45:05 <ferret_0567> It's too bad I can't
19:45:32 <ferret_0567> unless I get lucky and there is a torrent...in which case I will be ripping off Digital, HP/Compaq and others
19:46:23 <ferret_0567> or rather, could be, because I won't download OpenVMS
19:48:59 <angerman> Has anyone done anything with COM in Haskell?
19:49:07 <Pseudonym> A few people, yes.
19:49:12 <angerman> I know there is HDirect but that won't even compile anymore :/
19:49:40 <Pseudonym> Yeah.  I can't think of anyone lately.
19:49:50 <Pseudonym> Still, if you wanted to submit a patch...
19:50:22 <kerlo> HBC, Helium, Jhc, nhc98, Yhc.
19:51:48 <SamB_XP> kerlo: what's that list for?
19:52:02 <SamB_XP> and I think LHC has been updated more recently than jhc
19:52:22 <SamB_XP> though I think jhc was updated just yesterday or today ...
19:52:52 <gwern> SamB_XP: bizarre eh? but the updates were small build-system changes
19:52:52 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
19:53:02 <gwern> @messages
19:53:02 <lambdabot> byorgey said 22m 30s ago: strange, it seems to work fine for me. (and I'm not on campus or anything special like that.) um... try again?
19:53:06 <SamB_XP> gwern: so I read in the list
19:53:16 <kerlo> GHC doesn't work on normish.org and apt-get isn't able to get the Network module for Hugs.
19:53:20 <gwern> not real changes like lhc
19:53:37 <SamB_XP> really, I'm waiting for him to realizer he can use our Derive macros
19:54:55 <ispiked> http://haskell.pastebin.com/m52910c1a
19:55:00 <ispiked> I cannot figure out what that error means
19:55:45 <Saizan> ?type (:)
19:55:46 <lambdabot> forall a. a -> [a] -> [a]
19:56:02 <Saizan> you're trying to use it as if it was of type [a] -> [a] -> [a]
19:56:28 <Saizan> i.e. (:) is for adding an element in front, not for prepending a list
19:56:33 <int-e> ?type (++)
19:56:34 <lambdabot> forall a. [a] -> [a] -> [a]
19:56:59 <ispiked> I don't think (++) will do what I want
19:57:04 <ispiked> but thank you
19:57:07 <rwbarton> @type let myconcat :: [[a]] -> [a]; myconcat (x:xs) = x : myconcat xs in myconcat
19:57:08 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
19:57:08 <lambdabot>     When generalising the type(s) for `myconcat'
19:57:10 <rwbarton> @type let myconcat :: [[Int]] -> [Int]; myconcat (x:xs) = x : myconcat xs in myconcat
19:57:11 <lambdabot>     Couldn't match expected type `Int' against inferred type `[Int]'
19:57:11 <lambdabot>     In the first argument of `(:)', namely `x'
19:57:11 <lambdabot>     In the expression: x : myconcat xs
19:57:24 <rwbarton> Is there some reason the first error message can't be as good as the second one?
19:57:34 <rwbarton> @type let myconcat :: forall a. [[a]] -> [a]; myconcat (x:xs) = x : myconcat xs in myconcat
19:57:35 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
19:57:35 <lambdabot>     When generalising the type(s) for `myconcat'
19:57:57 <ispiked> rwbarton: I don't know... I'm using this vim haskell plugin and am not sure how to get the first error
19:58:25 <monochrom> Why are you not writing x++myconcat xs ?
19:58:26 <rwbarton> ispiked: Oh, GHC only gives one error
19:58:38 <int-e> ispiked: rwbarton has a point. you can read "cannot construct the infinite type: a = [a]" as "couldn't match the type a against the type [a]"
19:58:41 <rwbarton> What I meant was, if I pin down the type a to a fixed type, I get a more helpful error message
19:59:03 <ispiked> rwbarton: yes, I gathered that. thank you
19:59:16 <rwbarton> int-e: but the second and third lines of the second error message are important
19:59:24 <monochrom> the type variable leads the compiler to think differently and come to a different error message.
19:59:28 <rwbarton> I'm wondering whether GHC's error message in the first case could be improved
19:59:55 <kerlo> ispiked: why don't you think ++ will do what you want?
20:00:39 <monochrom> error messages can always be improved.
20:01:12 <Saizan> > [1..3] ++ [4..6]
20:01:13 <lambdabot>   [1,2,3,4,5,6]
20:01:41 <int-e> rwbarton: I guess the reason is that the types in question generally don't correspond to subterms.
20:01:44 <tehgeekmeister> oh, i love it when i realize i'm re-implementing a standard library function and can stop working so hard
20:01:45 <tehgeekmeister> =]
20:01:50 <int-e> monochrom: so it's harder to pinpoint
20:01:55 <int-e> huh?
20:02:04 <int-e> that was meant for rwbarton as well
20:02:12 <int-e> (the huh? was directed at myself)
20:02:41 <monochrom> You just can't be sure whom to talk to. Come join me, just talk to Mr. Speaker always.
20:03:45 <ispiked> kerlo: I misunderstood how the method worked
20:03:57 <ispiked> I thought it was like Python's list.append() method
20:04:13 <monochrom> append is ++, no?
20:04:25 <monochrom> Please ignore me.
20:04:30 * SamB_XP wonders if Tara1 would be interested in joining the L side of the Force
20:05:18 <ispiked> http://www.diveintopython.org/native_data_types/lists.html#d0e5887
20:05:44 <monochrom> No wonder. append is not ++.
20:05:53 <rwbarton> ispiked: There's nothing in Haskell like list.append() :)
20:06:07 <ispiked> rwbarton: ah, just just answered the question I was typing :)
20:06:31 <Petrosian> ispiked: Well, there's nothing in the Prelude like list.append() at least
20:06:36 <dons> what does list.append() do? destructive updates?
20:06:44 <monochrom> Emphatically.
20:06:50 <SamB_XP> oh, you mean += ?
20:06:54 <dons> emphatically destructive eh?
20:06:56 <int-e> xs ++ [x]  is concise enough.
20:07:05 <dons> let there be no doubt that the old list is gone
20:07:23 <pumpkin> gone and lost for ever
20:07:28 <pumpkin> just like clementine
20:07:33 <dons> dcoutts_, Igloo, kolmodin http://www.reddit.com/r/programming/comments/7ydqz/why_use_a_tiling_window_manager_why_xmonad/c07r7bn
20:07:35 <tehgeekmeister> it's amazing how much easier it became to simplify my code when i made everything a top level and could focus on one simple problem at a time.
20:07:43 <dons> any ideas on why ghc's packaged way about 100M on some distros?
20:07:51 <dons> tehgeekmeister: yaya!!
20:07:57 <SamB_XP> dons: hmm ?
20:07:59 <ozy`> dons: come again?
20:08:07 <dons> ozy`: ?
20:08:26 <ozy`> dons: did you mean "way above" in place of "way about?"
20:08:39 <pumpkin> dons: I got myself an epic speed increase in my uvector code (code that uses uvector, not my edits to the lib itself) yesterday :D
20:08:44 <dons> way above. sorry
20:08:48 <dons> woot woot
20:08:50 <pumpkin> was very happy
20:08:50 <gueux> if I modify an IORef inside another IORef, is the outer IORef modified?
20:08:58 <dons> no.
20:09:08 <dons> pointer to pointer to thing
20:09:08 <pumpkin> dons: cumulatively, it was around 60x speed increase, and I started out with -O2 :P
20:09:12 <gueux> ok
20:09:18 <dons> pumpkin: huh. so some fusion kicked in?
20:09:20 <pumpkin> yup
20:09:24 <dons> sweet
20:09:30 <pumpkin> some things I was doing were not getting fused right
20:09:43 <dons> what are you doing with uvector?
20:09:53 <pumpkin> machine learning stuff, lots and lots of floats :)
20:10:01 <pumpkin> I think I had 300 million of them in memory yesterday
20:10:18 <pumpkin> using lots of RAM :P
20:10:20 <dons> mmm.
20:10:24 <dons> sounds very cool.
20:10:31 <dons> do you need me to apply patches to uvector?
20:10:43 <pumpkin> nah, none of my patches did anything behavior-changing
20:10:46 <pumpkin> I just added tests and docs :)
20:11:01 <pumpkin> well, I did a couple of minor changes to tiny bugs
20:11:25 <dons> ok. could you resend your final , approved set of patches?
20:11:34 <dons> there were so many, and i was travelling, i find it hard to sort though
20:11:37 <dons> through
20:11:45 <pumpkin> haha sure :) yeah, sorry for being confusing
20:11:50 <dons> thanks!
20:11:59 <dons> sometimes i just have to call email patch bankruptcy
20:12:04 <ozy`> wow, intel procs build stuff fast
20:12:22 <pumpkin> especially when someone sends you half-working monster patches and forgets to include files in them :P
20:12:40 <SamB> ozy`: not *all* of them
20:12:47 <SamB> for instance, my old PII ...
20:12:56 <ozy`> SamB: modern ones, I mean
20:12:58 <SamB> well, okay, I guess it was mostly RAM
20:13:56 <ozy`> my main machine is a 1.4GHz PPC with a 140MHz (?) FSB and 768M of RAM
20:14:20 * SamB has no idea what his FSB is
20:14:25 <chessguy> hm, i got cona'ls paper, right up until he started making his main point. then my head exploded
20:14:39 <ozy`> the FSB was the worst part of old PPC machines
20:15:12 <ozy`> it was so easy to peg the system with a load that by all rights should have been a breeze for that CPU
20:15:39 <SamB> how do you tell what your FSB is in Linux ?
20:15:44 <ozy`> no idea
20:16:00 <int-e> dons: Binary distributions? A ghc build, with profiling libraries, packed, comes to that size, I'd guess. Maybe with extra libraries.
20:16:01 <SamB> I figured you wouldn't likely know, but maybe someone else does ?
20:16:16 <monochrom> find out everything about your cpu, then ask wikipedia how fast its fsb is.
20:16:22 * angerman is trying to compile HDirect... (first time haskell -- wheee)
20:16:28 <ozy`> I was going to recommend /proc/cpuinfo but it looks like that doesn't work
20:16:31 <dons> int-e: haskell.org/ghc says full binary builds are 70M
20:16:38 <SamB> just the compiler and plain libs come to 160 MB here, unpacked
20:16:45 <dons> so i wonder where the other 230M comes form
20:16:47 <SamB> er, 130
20:16:49 <SamB> sorry
20:17:00 <SamB> dons: what distro was this ?
20:17:19 <SamB> maybe it comes with the home edition of hackage ?
20:17:53 <monochrom> I swear by extralibs. I get 300M for 6.8.2. installation size, not tarball size.
20:19:36 <int-e> dons: you wrote 100M above btw
20:19:49 <SamB> that's true
20:19:49 <dolio> pumpkin: Since you're the only one I know of that's looked at uvector-algorithms, I'll ask you. What do you think is a good name for a schwartzian transform combinator?
20:19:55 <monochrom> The tarball of 6.8.2 and extralibs is just 41M.
20:19:59 <dolio> Right now I have "schwartzian" but I'm not sure that's good.
20:20:26 <dons> monochrom: ah, .tar.gz might also explain some things
20:20:50 <pumpkin> dolio: ooh, maybe just call it schwartz? not ideal but less typing, and still gets the idea across
20:20:50 <SamB> dons: what do you mean ?
20:20:51 * dons notes he applied Thu Jul  3 23:33:33 PDT 2008  dan.doel@gmail.com * Add unsafe (un)zipping of mutable arrays
20:21:07 <dons> i owe dolio a copy of RWH
20:21:18 <dolio> So it looks like "schwartzian sortBy keyFun arr" when you use it.
20:21:34 <dons> i wonder if we should merge statistics-fusion with uvector-algorithms ?
20:21:52 <rwbarton> I always thought naming that after someone was strange, I mean, doesn't everyone come up with this idea at some point?
20:21:53 <dons> dolio: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/statistics-fusion
20:21:53 <pumpkin> as I've mentioned, I think the apply function is general enough, at least, to be in the main module
20:22:05 <dons> bartonizan-transforms
20:22:05 <wli> Schwartzian?
20:22:35 <pumpkin> wli: the sort transformation that avoids comparing more than necessary
20:22:41 <dolio> wli: After Schwartz, some perl hacker who's "famous" for bringing up the technique somewhere.
20:22:46 <pumpkin> well, avoids transforming more than necessary
20:23:13 <wli> Doesn't sound too involved. What is it?
20:23:20 <pumpkin> the simplest thing ever :P
20:23:26 <ddarius> dolio: We should start naming random techniques after random people.
20:23:43 <pumpkin> doelian transform?
20:23:57 <sjanssen> dolio: what is the type of your function?
20:23:59 <dolio> wli: It's like using "sortBy (comparing f)" only you precompute the f for each element and use "sortBy (comparing fst)" isntead.
20:24:19 <sjanssen> IMO something like sortKey or sortAs is more descriptive than some guy's name
20:24:29 <ddarius> dolio: The definition of schwartz would probably be clearer and shorter than any description.
20:24:31 <wli> Curiously I'm writing that very thing as we speak.
20:24:33 <monochrom> The "Wall construct" refers to the perl statement "xxx if (y>0);"
20:24:46 <angerman> ok, the modules tries to use GlaExts, where do I find those? I think they were in lang once.
20:24:51 <dolio> ddarius: Not for mutable arrays.
20:24:54 <pumpkin> wli: I'm sure most programmers have independently come up with the idea without knowing it had a name
20:25:03 <ddarius> dolio: Then do it for lists.
20:25:11 <sjanssen> angerman: wow, what ancient piece of code are you looking at?
20:25:21 <angerman> sjanssen: hdirect
20:25:28 <int-e> @type \f -> map snd . sortBy (comparing fst) . map (f &&& id)
20:25:29 <lambdabot> forall a c. (Ord c) => (a -> c) -> [a] -> [a]
20:25:31 <angerman> sjanssen: COM haskell interoperability
20:25:47 <angerman> sjanssen: I already fixed the lang IOExt imports.
20:26:16 <sjanssen> angerman: GlaExts is so old I'm not sure what it even is.  It might correspond to GHC.Exts?
20:26:24 <angerman> sjanssen: if there is any other COM interop module
20:26:50 <angerman> sjanssen: probably as far as I know it's "The GlaExts interface provides access to extensions that only GHC implements"
20:27:01 <ddarius> HDirect was pre-FFI if I recall correctly.
20:27:16 <sjanssen> angerman: yeah, try GHC.Exts
20:27:24 <angerman> ddarius: ?
20:27:24 * wli realizes that division in algebraic extensions requires linear algebra.
20:27:30 <sjanssen> but if that is any indication, you have an uphill battle in front of you
20:27:43 <angerman> sjanssen: thanks. Let's see :)
20:27:54 <angerman> sjanssen: ohh and it's my first time trying out haskell...
20:28:03 <dolio> sjanssen: (UA e, UA k, Ord k) => (forall e'. UA e' => Comparison e' -> MUArr e s -> ST s ()) -> (e -> k) -> MUArr e s -> ST s ()
20:28:05 <dons> angerman: there's a library called 'com' on hackage.haskell.org
20:28:11 <dons> and lots of modern COM and .NET support
20:28:18 * wli realizes that division of algebraic extensions of rings which are not fields requires linear algebraic algorithms not described in very many places.
20:28:27 <dons> in general, only install things from hackage.haskell.org-- other things are likely to be less usable
20:28:28 <dolio> I was thinking maybe "usingKeys" or something similar would be a better name.
20:28:32 <angerman> dons: omg? why did I not find that when searching for COM ?
20:28:42 <dons> angerman: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hs-dotnet
20:28:48 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/com
20:28:57 <dolio> It's parameterized by the algorithm, so using "sort" in the name doesn't make a lot of sense, I think.
20:29:03 <sjanssen> dolio: what's a Comparison?
20:29:03 <dons> enjoy! this is the sucessor to hdirect, in fact, (i think..)
20:29:18 <dolio> sjanssen: (e -> e -> Ordering)
20:30:06 <angerman> dons: yes, looks like com has hdirect in it.
20:30:14 <angerman> dons: someone should update the hdirect website
20:30:21 <sjanssen> dolio: oh, I understand now
20:30:26 <angerman> dons: http://www.haskell.org/hdirect/
20:30:56 * wli points to division in the Eisenstein integers.
20:31:21 <sjanssen> dolio: so it'd be used as 'usingKey sort array'
20:31:40 <dolio> Right.
20:31:40 <sjanssen> dolio: erm 'usingKey sort keyfn array'
20:32:25 <rwbarton> shouldn't it be 'usingKey keyfn sort array'? (english-wise)
20:32:31 <rwbarton> or is that too cute?
20:32:59 <rwbarton> sort `usingKey` keyfn $ array
20:33:03 <sjanssen> (sort `usingKey` foo) array -- no, this is too cute
20:33:06 <dolio> Well, either way. I actually had it that way originally, but I thought "scwartzian sortBy" sounded better with the current name.
20:33:10 <pumpkin> oh no
20:33:24 <rwbarton> That's the other problem with schwartzian :P
20:33:32 <pumpkin> the test suite isn't linking for me for uvector (I updated from dons' repo just now)
20:34:00 <ddarius> The algorithm should be the first argument, arguably.
20:34:00 <ddarius> \
20:34:16 <rwbarton> Agreed
20:34:22 <angerman> dons: thanks for the hint :)
20:34:32 <angerman> too bad I have to compile on windows... urgs :)
20:35:18 <pumpkin> dolio: did the changes you sent to dons work with the testsuite? I'm getting a linker error for the makefile in the tests dir
20:35:29 <pumpkin> for _memmove_offset and _memcpy_offset
20:35:44 <pumpkin> it may just be my mac os doing something wrong though :)
20:35:48 <dolio> pumpkin: No idea.
20:37:43 <ScaryBitinFerret> @rwh
20:37:43 <lambdabot> Maybe you meant: rc run wn
20:37:47 <ScaryBitinFerret> @where rwh
20:37:47 <lambdabot> is http://www.realworldhaskell.org/blog/
20:38:33 <pumpkin> dons: did it work for you? (the testsuite)
20:41:06 <pumpkin> works fine if I explicitly compile and link in memcpy_extra.c
20:41:41 <dolio> Yeah, doesn't link here, either.
20:41:58 <pumpkin> I'll just add a compilation step to the makefile and submit it along with my other patch
20:50:34 <anderbubble> Why can't a function pattern-match against ((x:xs) ++ [y]) to get the first and last element of a list as x an y?
20:51:11 <Draconx|Laptop> anderbubble, because ++ is not a data constructor.
20:51:42 <monochrom> it would be similar to pattern-matching against (n*m)
20:51:43 <pumpkin> dons: I sent a patch using darcs send, and it claims to have worked :)
20:52:39 <anderbubble> Draconx, That makes complete sense now. (Complete noob here. I'm still working on getting my mind around the threefold world of types, constructors, and functions.)
20:53:04 <ddarius> monochrom: You could do that in Gofer.
20:53:04 <monochrom> fourfold: types, type constructors, data constructors, functions.
20:53:36 <ddarius> twofold: types and values
20:53:48 <monochrom> onefold: Haskell
20:53:50 <pumpkin> ddarius: would it factor the number for you and call the function once for every combination? :P
20:53:52 <ddarius> monochrom: Yay
20:54:09 <monochrom> Yeah, I'm wondering what would n, m become.
20:54:13 <ddarius> pumpkin: Well, you needed one of those to be fixed.
20:54:18 <pumpkin> oh okay
20:54:27 <monochrom> Darn that.
20:54:31 <ddarius> You can, however, formulate arithmetic in a "reversible" way.
20:54:38 <ddarius> (in a logic language)
20:54:48 <sauf_> conal: are you still looking for a way to play waves with OpenAL ? I was too, and finally I wrote this
20:54:51 <sauf_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1538
20:55:01 <anderbubble> monochrom, Like I said... still noobing. :)
20:55:23 <monochrom> halffold: Hask
20:55:35 <wli> http://pastebin.com/m4a55fec <-- algebraic number module
20:56:03 <monochrom> "If you take Haskell and keep folding it, how many folds before it's tall enough to reach the moon?"
20:56:03 * wli is lacking division, though.
20:56:44 <pumpkin> wli: you need a repository :P
20:56:51 <pumpkin> pastebins are not the answer!
20:56:51 <pumpkin> ;)
20:56:59 <pumpkin> gist.github.com if you must :)
20:57:16 <wli> pumpkin: Why? It's garbage.
20:57:32 <pumpkin> no self deprecation allowed!
20:57:47 <conal> sauf_: i think it was lilac who playing with OpenAL.
20:58:15 <wli> But it actually is complete crap code.
20:58:28 <wli> (Like almost all code I write.)
20:58:31 <sauf_> conal: I thought I saw you on haskell-cafe ...
20:58:56 <monochrom> The most interesting bits of historical evidence are not dug up from well-organized repositories. They are dug up from random places like the remains of the home of a random person, or in the future random remaining pieces of a pastebin.
20:59:26 <monochrom> And oh, the most interesting bits of historical evidence are thought of as garbage by the contemplorary, too.
20:59:51 <gueux> if I want to instanciate Read with a type
21:00:01 <rwbarton> monochrom: that's probably partly for statistical reasons--most stuff is garbage
21:00:09 <ddarius> monochrom: In the future, our ancestors (if they exist) will be digging up meaningless strange metal discs.
21:00:20 <gueux> what functions do I have to exhib?
21:00:44 <hotaru2k3> "In the future, our ancestors" <- what?
21:00:50 <wli> ddarius: s/ancestors/descendants/?
21:01:08 <monochrom> Perhaps ddarius knows some secret about time travel!
21:01:09 <ddarius> Whatever (stupid time)
21:01:10 * wli will have no descendants.
21:01:41 <ddarius> monochrom: Our ancestors do, but not our descendants.  Luckily, our ancestors only ever needed to move forward in time.
21:02:54 <roconnor> ddarius uses mdo for time travel
21:03:02 <rwbarton> gueux: readsPrec--according to the GHC docs--but it's uncommon to do it
21:03:48 <gueux> ok, thanks
21:03:54 <gueux> I hadn't found it
21:06:14 <sauf_> lilac: are you interested in OpenAL ?
21:12:12 <wli> pumpkin: Why do you think this garbage code I'm cranking out is valuable?
21:13:27 <dsrogers> is there a comparison operator that returns an Ordering?
21:13:49 <wli> compare
21:13:55 <wli> @type compare
21:13:56 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
21:15:44 <dsrogers> Data.List.sort doesn't specify whether it sorts ascending or desending.
21:16:32 <ddarius> dsrogers: It sorts "ascending"
21:17:11 <pumpkin> wli: it can't be that worthless or you wouldn't be spending time on it :) and I'm hoping it'll turn into a nice hackage module :
21:19:56 <wli> pumpkin: They're pedagogical exercises for me to try to get back up to speed programming (unlikely, but I'll try). There are already superior implementations extant.
21:20:30 <pumpkin> well, if nothing else yours seems shorter than others I've seen so far
21:20:41 <pumpkin> so it'll be educational for others to read too, maybe :)
21:28:47 <pumpkin> dolio: I have a patched version of uvector up on patch-tag if you want at http://patch-tag.com/repo/pumpkin-uvector/home
21:39:22 <mmorrow> > sortBy (flip compare) [0..9]
21:39:23 <lambdabot>   [9,8,7,6,5,4,3,2,1,0]
21:39:46 <dons> shapr: check it out. http://blog.happstack.com/2009/02/18/socalfp-presentation-slides-happstack-is-better-than-x/
21:39:52 <dons> happs(tack) is kicking butt!
21:40:05 <newsham> ?seen conal
21:40:05 <lambdabot> I saw conal leaving #haskell, #ghc and #haskell-in-depth 41m 4s ago, and .
21:42:55 <dmwit> http://www.dmwit.com/menger
21:43:37 <pumpkin> mmm sponge
21:44:58 <zachk> pumpkin: i need soap
21:45:16 <zachk> on a rope oh my rhymes are so dope i should become the pope
21:45:41 <oss> What can haskell do? Could anyone show me some examples?
21:45:43 <jml> is there a particular reason for why you need to use ++ to concatenate lists in Haskell, rather than +?
21:45:58 <jml> or is it just historical?
21:46:00 <Cale> jml: Because (+) is taken for Num instances.
21:46:06 <WrongWindowMan> @faq Can Haskell do anything?
21:46:06 <Cale> :t (+)
21:46:06 <lambdabot> The answer is: Yes! Haskell can do that.
21:46:07 <lambdabot> forall a. (Num a) => a -> a -> a
21:46:07 <Heffalump> just that (+) is in Num which has all sorts of other things that don't make sense for lists
21:46:47 <sbahra> @src Num
21:46:47 <lambdabot> class  (Eq a, Show a) => Num a  where
21:46:47 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:46:47 <lambdabot>     negate, abs, signum     :: a -> a
21:46:48 <lambdabot>     fromInteger             :: Integer -> a
21:46:58 <Cale> The more pressing question, I think, is why (++) itself is not more general.
21:47:10 <jml> right, but couldn't (+) just as well be in a separate typeclass to Num?
21:47:18 <Cale> It could.
21:47:31 <sbahra> Good question.
21:47:35 <mmorrow> class Monoid a where (++) :: a -> a -> a; zero :: a
21:47:37 <blackh> oss: Take a look at http://hackage.haskell.org/  You can click through to the code for each package.
21:47:43 <Cale> mmorrow: yeah :)
21:48:08 <jml> mmorrow: I was thinking that.
21:48:08 <mmorrow> i wonder how best to make that happen
21:48:18 <Cale> I don't think I would want (+) for lists, unless it was going to be something like the pointwise sum.
21:48:37 <jml> I guess (++) isn't commutative, whereas (+) often connotes commutativity
21:48:48 <Cale> yeah
21:48:50 <jml> how about (.) then? :-P
21:48:52 <redditbot> Denotational design with type class morphisms
21:48:52 <redditbot> SOCALFP Presentation Slides: Happstack is better than X
21:49:00 <Cale> (.) is composition
21:49:03 <Twey> Better than X?
21:49:08 <jml> Cale: I know :)
21:49:35 <Cale> Composition is too important to take (.) away from it, unless you want to generalise it somehow.
21:49:43 <jml> well, composition is a monoid operation over certain sets of functions.
21:49:45 <mmorrow> yeah, i agree
21:49:58 <jml> ++ = . ; zero = id
21:49:58 <Cale> A monoid is just a certain type of category :)
21:50:11 <mmorrow> jml: but thats just on (a->a)
21:50:14 <jml> yeah.
21:50:35 <Saizan> @source Data.Set
21:50:35 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
21:51:03 <Cale> hmmm
21:51:03 <Heffalump> jml: Cale would like (.) = fmap instead
21:51:19 <Cale> Yeah, I think that might be nicer.
21:52:03 <dibblego> so would I
21:52:07 * Heffalump thinks (.) shouldn't be overloaded at all. Too confusing and too little gain.
21:52:45 * Cale thinks (.) should be (Integer -> String) -> (Bool -> Integer) -> (Bool -> String) only!
21:53:12 <Cale> ;)
21:53:19 <Heffalump> that's (lack of) polymorphism, not overloading
21:53:43 <mmorrow> screw that! /me wants it to be (a -> ()) -> ([a] -> [()]) exclusively
21:54:24 <ddarius> @src Category
21:54:24 <lambdabot> Source not found. :(
21:54:34 <Cale> "Overloading" is a strange way of expressing typeclass parametric polymorphism.
21:55:28 <Heffalump> why? It's very similar to OO method signature overloading, albeit with a nicer type system
21:55:40 <Cale> I don't think of it like that though
21:55:53 <Cale> I think of it as a restricted kind of parametric polymorphism.
21:56:16 <Heffalump> *shrug*
21:56:18 <monochrom> Cale has liberated (.), now he's on to (++).
21:56:30 <Cale> Despite that initial paper's choice of wording, it has little to do with ad-hoc overloading.
21:56:35 <Heffalump> particularly when (.) would be the class member, it smells much more like overloading than parametric polymorphism to me
21:56:49 <Cale> Heffalump: Do you worry about fmap?
21:56:50 <Heffalump> it's not like parametricity laws hold unless you make the dictionary explicit
21:56:59 <ddarius> (.) = snd
21:57:01 <Heffalump> worry about it in what sense?
21:57:20 * Heffalump had a legitimate need to write liftM . map . fmap the other day, btw
21:57:21 <Heffalump> that was fun
21:57:28 <Cale> oh?
21:57:36 <Cale> and fmap . fmap . fmap wouldn't do?
21:57:40 <ddarius> I've written liftM (fmap (liftM (fmap ...)))
21:57:57 <Heffalump> of course it would have, but liftM ... fitted in with my types much better so was more readable
21:58:03 <int-e> fmap (fmap fmap fmap) fmap
21:58:14 <Heffalump> well, not of course since I might have needed to constrain some type class, but I didn't
21:58:26 <Cale> Yeah, that's what I was wondering about.
21:58:40 <Heffalump> it grew up over time, started out as liftM, then liftM . map
21:58:45 <monochrom> English teachers tell you that you should avoid using the same words too often, you should rotate around synonyms.
21:58:49 <Heffalump> I think I've removed at least one of them again now, anyway.
21:58:51 <Cale> I basically never use liftM except to implement fmap in the case that I already have a definition for return and >>=
21:59:09 <ddarius> monochrom: "Rotating" would be a little rigid.
21:59:17 <Heffalump> monochrom: that's not necessarily good advice in academic and technical writing where there'll possibility of ambiguity and foreign readers, though
21:59:31 <int-e> we really need more aliases for fmap. It occurs so often in code ;)
21:59:33 <monochrom> Totally.
21:59:37 <Cale> heh
21:59:41 <Twey> Haha
21:59:50 <Twey> 'You, too, can be awesome, like Perl!'
22:00:18 <mmorrow> , $(fmaps 6) (*2) [[[Node [Just 42] []]]]
22:00:20 <lunabot>  [[[Node {rootLabel = [Just 84], subForest = []}]]]
22:00:36 <mmorrow> TH++
22:00:36 <Cale> Cute.
22:00:38 <monochrom> I'm setting you up to accept that "Proof: ... implies ... implies ... implies ..." is good, "Proof: ... we have ... but then ... therefore ..." is bad.
22:00:52 <mmorrow> , ppDoc `fmap` fmaps 6
22:00:54 <dons> hey, what do people think about having a multicore example in 'learn haskell in 5 steps' ?
22:00:56 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . fmap))))
22:01:09 <ddarius> monochrom: "Proof: ... => ... => ... => ..."
22:01:10 <dons> e.g. here's one i prepared earlier (after spotting it on the ubuntu wiki): http://ubuntuprogramming.wikidot.com/haskell
22:01:22 <monochrom> Yes ddarius, my ultimate goal is that.
22:01:22 <zachk> my friend who i taught how to code moved away. got heavy into linux and c. He came back i had read the perl book. i told him im a better programmer then him just too lazy. now he writes in perl for nvidia 100k a year no college. oh btw i told him c sucked and perl was way better. but that was back in highschool :-D
22:01:27 <dons> seems like seeing > 100% cpu might motivate people...
22:01:29 <Heffalump> dons: are you hackathoning, btw?
22:01:34 <dons> Heffalump: yeah, i reckon.
22:01:42 <Heffalump> cool
22:01:49 <dons> might visit some anglo haskellers too
22:02:09 <mmorrow> Cale: fmaps: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1302
22:02:13 <Cale> It would be nice to have some way that all the various categories which are implicitly lying around could have their composition named (.)
22:02:26 <ddarius> @hackage category
22:02:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category
22:02:35 <zachk> dons. on learn haskell in 5 steps do it i loved your roll your irc bot tutorial :D
22:02:36 <dolio> Perl for nvidia?
22:02:44 <Heffalump> sounds good, you should pop in and visit us, we're getting jealous of all those visits NY gets :-)
22:02:45 <zachk> yea
22:02:46 <Cale> Can we unify the inferface for Monoid and (Control.)Category?
22:02:56 <dons> Heffalump: hehe.
22:02:58 <zachk> they have massive server farms
22:03:05 <dolio> Ah.
22:03:07 <Cale> Might have to give (.) a funny type for that :)
22:03:13 <dons> Heffalump: well i'm near NY a lot. but yeah, dropping in to say 'hi' would be good
22:03:29 <zachk> by ny you mean the city?
22:03:31 <dons> yep
22:03:47 <zachk> ive lived in new york for 15+ years and i have never been to the city
22:03:52 <pumpkin> the hackathon is in europe?
22:03:59 <dons> any suggestions on what a good 'hello world' for multicore is ? http://ubuntuprogramming.wikidot.com/haskell
22:04:01 <Gracenotes> zachk: not even for travel?
22:04:02 <Heffalump> pumpkin: yep, Utrecht
22:04:07 <pumpkin> ah
22:04:10 <pumpkin> boo :)
22:04:12 <dons> what's the canonical 'yeah, i used > 1 core' program?
22:04:24 <zachk> nah the man dont let me drive anymore so i have to travel on foot
22:04:36 <Gracenotes> *nods*
22:04:45 <erikc> dons: matrix multiply?
22:05:18 <zachk> does ghci _._ on vista support multicores?
22:05:20 <ddarius> type MonoidToCat m a = MonoidToCat' m a a; newtype MonoidToCat' m a b = MonoidToCat { unMonoidToCat :: m}  instance Monoid m => Category (MonoidToCat' m) where id = MonoidToCat mempty; MonoidToCat a . MonoidToCat b = MonoidToCat (a `mappend` b)
22:05:25 <dons> mm. zipWith (*) two lists? we'd need parMap/zipWith
22:05:29 <dons> zachk: ghc does.
22:06:09 <ddarius> I guess: type MonoidToCat m = MonoidToCat' m () ()
22:06:20 <pumpkin> meow
22:06:32 <zachk> i am thinking n body = n core but then i think of memory bandwidth
22:06:33 <monochrom> People can write Perl for NVidia for 100K? No wonder NVidia graphics chips are overheating. They are forced to overclock the chips because the internals are in Perl!
22:06:41 <Cale> I suppose to do any better you need some kind of strange kind polymorphism.
22:07:16 <Heffalump> is kind polymorphism strange?
22:07:23 <ddarius> Control.Category.Category should take things of kind forall k. k -> k -> *
22:07:34 <zachk> are we going to eventually have charm polymorphism?
22:07:47 * Heffalump wants kind aliases
22:07:50 <pumpkin> I was thinking of calling my arm disassembler charm
22:08:39 <monochrom> "I have 2 cores" can be shown off by two infinite loops in parallel.
22:08:43 <erikc> dons: http://www.openmp.org/mp-documents/spec30.pdf
22:08:55 <erikc> maybe the examples section from there
22:09:11 <pumpkin> btw, does anyone know how SPECIALIZE pragmas work for exported functions in modules? will ghc do the right thing, or do they only work reliably for internal stuff?
22:09:14 <ddarius> monochrom: But can you write those two infinite loops in parallel... in one line!
22:09:24 <Cale> monochrom: We can generate fibonacci numbers and factorials at the same time!
22:09:28 <Saizan> Heffalump: what are you doing with our precious kind system? noone implemented something in it yet! it's still too young!
22:09:48 <ddarius> Saizan: Kind aliases wouldn't be anything.
22:09:51 <monochrom> I think fibonaaci and factorials are pretty stale for non-Haskellers and beginners.
22:10:02 <ddarius> What I'd like is rather more dramatic.
22:10:06 <zachk> i love them
22:10:50 <monochrom> Don't go for one-line. Go for five-line or something.
22:10:52 <int-e> dons: replicateM_ 2 $ forkIO $ putStrLn "Hello, world!"  printing "HeHlellol,o ,w owrolrdl!d!" is quite nice, even though you don't need two cores for that *g*
22:11:00 <zachk> i just run factorial with an accumulator with a print statement in it and people are like omg the matrix
22:11:10 <monochrom> hahaha
22:11:18 <blackh> dons: finding anagrams?
22:12:21 <zachk> i swear i have a multithreaded program that will print R in Z time
22:12:39 <dons> int-e: mwhaha! but it should also show > 100% cpu (imo) ?
22:14:01 <SamB> int-e: and on what system does it actually do that ?
22:14:13 <SamB> usually there are much larger blocks, I think
22:14:15 <ddarius> chunkedForkMapM print [1..]  -- will start with very low CPU usage and increase to more and more.
22:14:25 <pumpkin> :o
22:14:33 <monochrom> haha
22:14:39 <int-e> SamB: I admit I cheated. I used ghci, without any +RTS -N options ;-)
22:15:00 <dons> int-e: yeah.
22:15:04 <dons> $ ./B +RTS -N2
22:15:04 <dons> Hello, world!
22:15:04 <dons> $ ./B +RTS -N2
22:15:11 <dons> sometimes no output, sometimes 1 line
22:15:16 <dons> sometimes 2
22:15:19 <lunabot>  luna: Not in scope: `./'
22:15:19 <lunabot>  luna: Not in scope: `./'
22:15:32 <pumpkin> aw, I thought mmorrow turned off the $
22:15:35 <dons> i like the idea of doing fibonacci and factorials in parallel
22:15:36 <SamB> ahahah
22:15:41 <dons> an ironic hello world :)
22:15:57 <int-e> dons: well, you clearly need a delay in the main thread. and even then you need to get lucky for the threads to actually run concurrently. (solution? use more threads ;-)
22:16:00 <SamB> mmorrow: what happened to getting rid of that $?
22:17:01 <monochrom> Kerokerokerokerokerokeropi   <--- result of many threads printing "kero"
22:17:09 * ddarius considers making a highly concurrent GUI library (wrapper?) with no attempt to be "functional"
22:17:31 <SamB> monochrom: what the ?
22:17:39 <SamB> your threads speak japanese ?
22:18:07 <blackh> dons: I tried doing anagrams in parallel to try out the parallel stuff, but there was a lot of copying of strings going on so the performance wasn't that great.
22:18:45 <monochrom> http://www.vex.net/~trebla/photo/unorganized/lcd-kero.jpg  <--- result of many threads printing "kero" into the windows desktop
22:18:54 <int-e> dons: I really can't think of anything canonical. I guess you could do something silly like computing the 35th and 36th fibonacci numbers naively, in parallel.
22:18:58 <dons> yeah
22:19:09 <dons> i think something silly/ironic like that
22:20:05 <blackh> dons: What about cracking a unix password?
22:20:21 <pumpkin> lol
22:20:25 <monochrom> nice!
22:20:33 <SamB> blackh: why just one ?
22:20:47 <int-e> hmm. 'blueberry'
22:20:47 <Gracenotes> dons: maybe searching a filesystem?
22:20:54 <dons> nah, no IO.
22:21:00 <dons> its hello world. it should only print
22:21:18 <monochrom> PIck two Euler Project problems and compute them in slow ways.
22:21:23 <rwbarton> int-e: that's exactly the same interleaving I got
22:21:26 <ddarius> For something small, IO will probably mean IO-bound.
22:21:30 <SamB> dons: MAYBE read from ONE file ?
22:21:30 <monochrom> Err, Project Euler.
22:21:55 <int-e> rwbarton: yes, the RTS scheduler is fairly predictable with a single worker thread.
22:22:09 <int-e> rwbarton: especially in ghci
22:22:24 <Gracenotes> dons: solving a puzzle concurrently, then.. would that work?
22:22:43 <int-e> rwbarton: where apparently, it switches thread on every character written. Which I find quite fascinating really.
22:22:55 <monochrom> Sudoku generator in one thread and Sudoku solver in another.
22:23:14 <rwbarton> int-e: If I repeat the command, I get various outputs, but they don't seem really random
22:24:05 <int-e> rwbarton: I seem to get regular interleavings with varying offsets, with 2 being the most common offset
22:24:10 <rwbarton> int-e: yes
22:24:24 <rwbarton> int-e: often I get completely separate output also
22:25:59 <monochrom> I'm hungry. Any newbies?
22:26:23 <rwbarton> int-e: replacing "Hello, world!" with "12345678901234567890" makes it much clearer what's going on :)
22:26:24 * pumpkin raises his hand
22:27:08 <monochrom> OH! I haven't brushed, in fact. Let me get some cheese.
22:27:29 * pumpkin lies down on a cracker
22:27:40 <Gracenotes> I have a cracker.
22:27:57 <int-e> rwbarton: good idea
22:28:58 <int-e> dons: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1539 ;-)
22:30:02 <pumpkin> lol
22:30:24 <pumpkin> that's neat :)
22:30:37 * SamB gets some cheese, too
22:30:46 * pumpkin lies back down
22:31:06 <dons> why do i always get 'Service Temporarily Unavailable' ?
22:31:10 <dons> from hpaste now
22:33:02 <dons> this page looks wrong: http://en.wikipedia.org/wiki/Tak_(function)
22:33:12 <dons> the haskell one wins not because it is lazy, but because ghc kicks python.
22:33:53 <pumpkin> yeah
22:34:06 <shapr> Looks like I'll be giving a talk on STM soon after my talk on QuickCheck.
22:34:18 <pumpkin> int-e: that's a bit like a counting sort isn't it?
22:34:30 <shapr> Clearly, I need more Haskell stickers to put on my laptop for proper presentation attire.
22:34:38 <shapr> Where can I get Haskell stickers?
22:34:46 <int-e> pumpkin: yes, with the difference that counting sort is actually useful :)
22:34:54 <mjrosenb> does minimum do anything special that would cause it to stack overflow on a reasonable list?
22:34:57 <pumpkin> int-e: but you run in O(max element) !!
22:35:01 <pumpkin> that might be useful :P
22:35:06 <monochrom> hahahaha int-e
22:36:25 <shapr> dons: Are you aware of any Haskell stickers?
22:36:38 <pumpkin> http://www.zazzle.com/haskell_sticker-217425587103660577
22:36:56 <pumpkin> ;)
22:36:57 <dons> some xmonad ones
22:36:58 <shapr> hah
22:36:59 <dons> but not haskell ones
22:37:01 <shapr> dons: Oh good idea!
22:37:19 <pumpkin> be proud of your family crest! http://www.cafepress.com/ultraheraldry.130291524
22:37:59 <shapr> dons: got url?
22:38:17 <mjrosenb> map (head test<) test
22:38:25 <mjrosenb> returns in about 1 second
22:38:34 <mjrosenb> with about 100 elements in the list
22:38:38 <mjrosenb> but sort test
22:38:47 <mjrosenb> gives a stack overflow
22:38:52 <mjrosenb> any idea?
22:38:57 <pumpkin> mjrosenb: ghci?
22:39:00 <mjrosenb> pumpkin: ja
22:39:07 <shapr> Ya know, an XMonad t-shirt would be perfect attire for the first meeting of the Boston group.
22:39:18 <shapr> dons: thanks for all your hard work on xmonad!
22:39:31 <pumpkin> mjrosenb: Data.List.sort?
22:39:34 * shapr is a proud xmonad user for some amount of time.
22:39:35 <pumpkin> 100 elements, stack overflows??
22:39:40 <mjrosenb> pumpkin: yeah
22:39:44 <dons> :)
22:39:51 <mjrosenb> minimum does the same thing
22:39:53 <pumpkin> did you call ghci with a tiny stack or something?
22:40:04 <mjrosenb> nope, just ghci
22:40:19 <mjrosenb> it also takes a good 5 seconds before the overflow
22:40:20 <Saizan> > minimum [1..100]
22:40:21 <lambdabot>   1
22:40:33 <mjrosenb> these aren't numbers
22:40:36 <pumpkin> oh
22:40:37 <pumpkin> what are they?
22:40:49 <Saizan> ?src minimum
22:40:49 <lambdabot> minimum [] = undefined
22:40:50 <lambdabot> minimum xs = foldl1 min xs
22:40:54 <mjrosenb> datatype
22:41:03 <pumpkin> is it big complicated stuff?
22:41:08 <mjrosenb> not really
22:41:11 <mjrosenb> as stated
22:41:18 <Saizan> mjrosenb: try "foldl1' min"
22:41:24 <mjrosenb> map (head test<) test works just fine
22:41:37 <Saizan> note the '
22:41:53 <mjrosenb> Saizan: yeah, the strict version
22:41:56 <mjrosenb> overflows
22:42:49 <hackage> Uploaded to hackage: digest 0.0.0.3
22:42:55 <Saizan> it overflows with foldl1' ? weird
22:43:02 <mjrosenb> ok
22:43:07 <mjrosenb> no one comparison is doing it
22:43:19 <mjrosenb> [x < y | x <- test, y <- test]
22:43:20 <mjrosenb> is fine
22:43:39 <mjrosenb> min hangs
22:44:14 <dons> ok. how's that. http://haskell.org/haskellwiki/Haskell_in_5_steps#And_in_parallel
22:44:18 <pumpkin> try rnf-ing the result of sorting it?
22:44:23 <Saizan> did you write the Ord instance yourself?
22:44:33 <dons> i just think we have a killer hook if we drop 'oh yeah, program your multicore' into the intro :)
22:44:34 <pumpkin> rnf [min x y | x <- test, y <- test]
22:44:35 * mjrosenb probably needs to add a new function to ord
22:44:49 <dolio> Did you implement (<) or (<=)?
22:45:00 <mjrosenb> min (head test) (head . tail $ test) hangs
22:45:01 <mjrosenb> <
22:45:19 <Saizan> i think you need to implement either (<=) or compare
22:45:20 <dolio> Yeah, you need either compare or (<=).
22:45:21 <pumpkin> mjrosenb: I was wondering whether maybe the show was causing the issue
22:45:30 <pumpkin> oh
22:45:42 <dolio> @src (<)
22:45:42 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
22:45:43 <pumpkin> didn't you say the < worked fine though?
22:45:50 <dolio> @src compare
22:45:50 <lambdabot> compare x y | x == y    = EQ
22:45:50 <lambdabot>             | x <= y    = LT
22:45:50 <lambdabot>             | otherwise = GT
22:45:54 <Saizan> he implemented < directly
22:45:57 <pumpkin> oh
22:46:00 <Saizan> ?src min
22:46:00 <lambdabot> min x y = if x <= y then x else y
22:46:01 <pumpkin> :)
22:46:08 <dolio> @src (<=)
22:46:09 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
22:46:19 <dolio> So (<=) uses compare which uses (<=) ...
22:46:29 <mjrosenb> ...
22:46:31 <tehgeekmeister> how space-efficient are Data.Map and Data.Set?
22:46:37 <dolio> And min uses (<=).
22:46:59 <mjrosenb> if i *need* to implement <= or compare, why does it let me instantiate the class with neither defined
22:47:21 <Saizan> because the defaults are cyclic
22:47:33 <rwbarton> int-e: my first stm program: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1539#a1540 :)
22:47:46 <monochrom> I hope someone has a more precise answer. A Map/Set is a binary search tree. Each item becomes a tree node. Perhaps you can estimate from this.
22:47:59 <dolio> There's no way to declare a set of minimal definitions for a type class.
22:48:10 <dolio> Kind of an oversight in retrospect.
22:48:30 <tehgeekmeister> i managed to use up 1.5 gb of ram between two small ish maps of and two sets.
22:48:32 <Saizan> it's only in the documentation
22:48:37 <int-e> rwbarton: hehe
22:48:41 <pumpkin> tehgeekmeister: maybe lots of thunks?
22:48:45 <pumpkin> are you being strict?
22:48:51 <monochrom> Yeah, thunks.
22:48:52 <redditbot> Random Permutations and Sorting
22:49:01 <tehgeekmeister> and they should be quite small, really, because they're generated by a 1mb file
22:49:23 <monochrom> Every time you insert, you risk building an insert thunk instead of a new tree.
22:49:36 <tehgeekmeister> so i should insert strictly?
22:49:51 <pumpkin> tehgeekmeister: yeah, I think there's an insertWith'
22:49:54 <monochrom> seq every insertion.
22:49:57 <tehgeekmeister> okay
22:50:04 <Saizan> and depending on how you generate the elements you want to evaluate those early too
22:50:19 <pumpkin> just rnf the whole thing at every step to be safe ;)
22:50:21 <pumpkin> j/k
22:50:40 <monochrom> Do both what I said and what pumpkin said. They're orthogonal. Two independence sources of thunks.
22:51:08 <tehgeekmeister> so thunks can take up that much space?  wow.
22:52:02 <monochrom> Don't know.
22:52:29 <tehgeekmeister> well, we'll find out
22:52:32 <Saizan> thunks tend to keep other things alive too
22:53:00 <tehgeekmeister> how does seq work?
22:53:11 <tehgeekmeister> Data.Set doesn't have a strict insert
22:53:57 <pumpkin> a `seq` b evaluates a and returns b, when its result is evaluated
22:54:30 <tehgeekmeister> it is not immediately obvious how i use that in this case
22:54:45 <tehgeekmeister> S.insert val set becomes?
22:54:53 <Saizan> so e.g. insertMany s ((k,v):xs) = let s' = S.insert k v s in s' `seq` insertMany s' xs
22:54:58 <pumpkin> set `seq` S.insert val set maybe
22:55:02 <int-e> dons: wait, in that Tak function, lazy evaluation does help avoiding to calculate the 'z' argument when it's not needed.
22:55:12 <dons> ah ha!
22:55:15 <dons> yes, x <= y
22:55:20 <dons> so tak is bizarrely useless in z
22:55:21 <Saizan> (which can be rewritten with foldl')
22:56:00 <int-e> dons: it's an elaborate implementation of the maximum of three numbers.
22:56:41 <tehgeekmeister> is seq in the prelude?  hoogle doesn't find it, need to know if i need to import anything
22:56:52 <pumpkin> it is
22:57:15 <dons> http://mathworld.wolfram.com/TAKFunction.html
22:57:47 <tehgeekmeister> apparently the majority of my updating is not done by inserting
22:57:57 <tehgeekmeister> but by something of this form
22:58:09 <pumpkin> tehgeekmeister: you could try profiling if you can't find where the memory is going
22:58:25 <pervonisse> hmm, I'm looking for some project idea to get working on something
22:58:28 <tehgeekmeister> pumpkin: i may do that, but i'm going to see if strictness solves it first
22:58:37 <pumpkin> pervonisse: reddit.com/r/haskell_proposals! :P
22:59:02 <pervonisse> oh, interesting
22:59:14 <tehgeekmeister> so a `seq` b is strict in both arguments?
22:59:26 <monochrom> eager in a.
22:59:39 <tehgeekmeister> but a is what i want to return the value of?
22:59:42 <monochrom> I guess by some other reason eager in b too.
22:59:49 * mjrosenb wishes that Ints were represented as pseudo-church numerals
23:00:01 <pumpkin> tehgeekmeister: note that if a is a list, it only means the head gets evaluated
23:00:03 <dons> i like hardware support for some of my computation
23:00:06 <mjrosenb> so that let inf = 1+ inf in 5 < inf would return true
23:00:14 <dolio> You wish they were slow? :)
23:00:16 <Saizan> it's strict in b since it returns it
23:00:21 <pumpkin> there's an inf in Int?
23:00:22 <jml> so, I know it's a pretty simple thing
23:00:29 <jml> but gosh I wish Python had 'let' and 'where'
23:00:38 <idnar> pumpkin: he said let inf = 1 + inf
23:00:43 <pumpkin> ah :)
23:00:48 <monochrom> ints should be represented as black boxes
23:01:09 <tehgeekmeister> so S.empty `seq` S.insert val set will be a strict insert, or not?
23:01:18 <pumpkin> tehgeekmeister: no
23:01:23 <tehgeekmeister> bah
23:01:51 <tehgeekmeister> what do i do then?
23:01:54 <monochrom> It is hard to tell you how to optimize a black box, no?
23:01:58 <pumpkin> what Saizan said
23:02:03 <pumpkin> or in the foldl' form
23:04:00 <Saizan> insert' val s = val `seq` insert val s takes care of forcing the value, assuming that seq is enough for it
23:04:14 <tehgeekmeister> okay, that'll work
23:04:25 <Saizan> but, you also want to force the Set itself
23:04:31 <tehgeekmeister> yes, i do
23:04:40 <hotaru2k3> > map (\n -> mod (product [2..n-1]) n==n-1) [2..20]
23:04:41 <Saizan> before inserting other things in it
23:04:41 <lambdabot>   [True,True,False,True,False,True,False,False,False,True,False,True,False,Fa...
23:04:49 <tehgeekmeister> so how about
23:04:50 <hotaru2k3> @pl \n -> mod (product [2..n-1]) n==n-1
23:04:50 <lambdabot> liftM2 (==) (mod =<< product . enumFromTo 2 . subtract 1) (subtract 1)
23:05:04 <tehgeekmeister> S.insert val set `seq` S.insert val set
23:05:07 <hotaru2k3> > map (liftM2 (==) (mod =<< product . enumFromTo 2 . subtract 1) (subtract 1)) [2..20]
23:05:08 <lambdabot>   [True,True,False,True,False,True,False,False,False,True,False,True,False,Fa...
23:05:38 <monochrom> Maybe you can look for places to use $! instead.
23:05:42 <Saizan> that doesn't make sense since you've no reference to the first argument of seq
23:05:42 <int-e> dons: and that indeed saves a lot - for tarai 14 7 0, it reduces the number of calls to tarai from 208549 calls to 148 calls.
23:05:51 <pumpkin> int-e: wow
23:05:52 <hotaru2k3> hmm... for some reason that last one doesn't work in ghci for me...
23:05:54 <Saizan> yeah, or bang patterns
23:06:05 <pumpkin> hotaru2k3: how does it fail?
23:06:38 <Saizan> btw, x `seq` x == x, it does nothing
23:06:48 <monochrom> You have a recursion over that changing set. Use bang pattern for the set parameter, or use $! at the recursive call for the set parameter.
23:07:18 <monochrom> This is stretching the limit of suggesting code change to code I've never seen.
23:07:21 <hotaru2k3> pumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1541#a1541
23:07:30 <Saizan> heh :)
23:07:40 <pumpkin> hotaru2k3: :m + Control.Monad.Instances
23:08:17 <hotaru2k3> ah, thanks
23:10:18 <tehgeekmeister> monochrom: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1460#a1460
23:10:27 <tehgeekmeister> monochrom: that's a previous version but the updating bits are identical
23:10:37 * monochrom plays a TRWBW tactic
23:10:51 <monochrom> "Feel free to stop talking to me. I have lost interest."   <duck>
23:11:02 <pumpkin> :)
23:11:18 <Saizan> TRWBW?
23:11:20 <pumpkin> just seq the value and the set before inserting
23:11:24 <pumpkin> ^^ tehgeekmeister
23:11:28 <pumpkin> at each iteration
23:11:51 <pumpkin> tehgeekmeister: if you really want to be sure, call rnf on it (Control.Parallel.Strategies)
23:11:57 <tehgeekmeister> value `seq` set `seq` insert
23:12:10 <tehgeekmeister> ?
23:13:31 <monochrom> Control.Monad.State adds more laziness and thunking.
23:13:49 <tehgeekmeister> bahhhh
23:13:54 <tehgeekmeister> i did not ask for all these thunks
23:14:00 <tehgeekmeister> =P
23:15:23 <monochrom> State.modify adds more, on top of what State's >>= adds.
23:15:23 <Saizan> you can use Control.Monad.State.Strict and (put $!) to eliminate that thunking
23:16:20 * Saizan wonders why he never had such problems with Maps and State
23:16:37 <Saizan> maybe i never built large maps without inspecting them regularly
23:16:49 <tehgeekmeister> this isn't that large of a map!
23:16:52 <monochrom> You have maps and sets in a record. That is very convenient. Add !'s in the record declaration.
23:17:12 <tehgeekmeister> i mean, the text file is not even a megabyte.
23:17:18 <tehgeekmeister> where in the declaration?
23:17:46 <monochrom> targetsToItems:: !(M.Map Int (S.Set String))  for example
23:18:37 <tehgeekmeister> okay
23:18:45 <tehgeekmeister> that'll make it strict by default?
23:18:58 <monochrom> necessary but not sufficient.
23:22:50 <monochrom> State is probably the biggest contributor. Use State.Strict instead.
23:23:06 <monochrom> import Control.Monad.State.Strict
23:25:02 <tehgeekmeister> is $! not defined as infix?
23:25:11 <monochrom> It's infix.
23:25:13 <pumpkin> it's an operator, it has to be
23:25:31 <tehgeekmeister> yeah, that's what i thot, but it gave me some weird errors when i added it in
23:25:43 <tehgeekmeister> i assumed it'd have the same fixity as $
23:25:50 <tehgeekmeister> and used it that way
23:25:53 <pumpkin> it does
23:26:05 <tehgeekmeister> *wonders what he did wrong
23:26:21 <pumpkin> if you told us the error we might be able to give you more help :)
23:26:22 <pumpkin> infixr 0 $!
23:27:09 <tehgeekmeister> M.insertWith $! f val someMap
23:27:12 <tehgeekmeister> and the error was
23:27:48 <tehgeekmeister> well there are three of them, i'll hpaste
23:27:51 <monochrom> That causes the wrong precedence. It also has the wrong semantics.
23:28:02 <monochrom> M.insertWith' f val someMap
23:28:05 <pumpkin> that's going to call f on val and someMap
23:28:11 <pumpkin> and call M.insertWith on the result
23:28:55 <pumpkin> @src ($!)
23:28:56 <lambdabot> f $! x = x `seq` f x
23:29:20 <pumpkin> you could do M.insertWith f val $! someMap
23:29:43 <monochrom> M.insertWith' f val $! someMap
23:30:11 <tehgeekmeister> okay
23:30:27 <tehgeekmeister> and for my uses of S.insert?
23:31:03 <quicksilver> @remember tehgeekmeister bahhhh; i did not ask for all these thunks
23:31:03 <lambdabot> Good to know.
23:31:11 <quicksilver> ;)
23:31:23 <pumpkin> S.insert val $! val `seq` someSet maybe, or you might not need val to be forced
23:31:48 <tehgeekmeister> val should be evaluated already always, i think
23:32:04 <tehgeekmeister> it's read in from a file, io forces evaluation, no?
23:32:15 <tehgeekmeister> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1460#a1461 <== current version
23:32:37 <pumpkin> if no one asks for the value, the IO won't even happen :P
23:32:58 <monochrom> All the world's strictness annotation will do nothing if they are hidden behind yet another thunk.
23:33:26 <tehgeekmeister> somehow that paste managed to be the wrong version.
23:34:04 <monochrom> The work of adding strictness to a program is to know its entire dataflow and add strictness annotation along a whole path, especially those guys on the path closest to the main program.
23:34:52 <tehgeekmeister> i don't have to worry about thunks when i'm using a numeric literal, do i?
23:34:52 <monochrom> If the main program doesn't force a thunk, it won't see the other $!'s deep down, and nothing will happen.
23:34:54 <tehgeekmeister> please tell me no.
23:35:06 <monochrom> No.
23:35:10 <tehgeekmeister> thank you.
23:35:45 <cizra> $!'s? Sounds like Perl
23:35:47 <lunabot>  luna: Not in scope: data constructor `Sounds'
23:35:54 <int-e> It depends. How many instances of Num are you using? *g*
23:36:18 <pumpkin> beware, the inventor of sleepSort speaks!
23:36:19 <monochrom> You don't make everything strict either. Some strictness makes things worse.
23:36:25 <callen> wow, this is a happening place.
23:36:32 <pumpkin> callen: fo sho
23:36:57 <tehgeekmeister> monochrom: i like laziness.  i just don't like my computer being dragged to a standstill by thunks.
23:37:24 <tehgeekmeister> i mean, 1.4gb of ram and 600 mb in vm, it took me five minutes just to kill the program
23:37:27 <callen> pumpkin: so, I've worked with a variety of languages, everything from scheme to asm. What are some advantages to learning/using haskell?
23:37:33 <tehgeekmeister> (that's with 2gb of ram total.)
23:38:00 <monochrom> It also does you no good if you make strict something that only buys you O(1) speedup. As with all optimizations, it only helps if it improves an inner loop, a hot spot.
23:38:07 <pumpkin> callen: http://offthelip.org/?p=125
23:38:24 <callen> pumpkin: thanks for the linkage.
23:38:40 <pumpkin> it's a very recent blog post from someone in here :)
23:41:43 <dmwit> callen: Advantages: pattern matching, enforced purity, higher-order programming, typeclasses are pretty neat
23:41:58 <dmwit> static type-checking # big one
23:42:24 <temoto> callen: for me auto type inference is a big one.
23:42:32 <Elly> static typechecking is the biggest win, I think
23:42:45 <callen> is anyone familiar with ATS?
23:42:54 <dmwit> I've heard of it.
23:42:59 <callen> if so, why does ATS code scare my face?
23:43:05 <dmwit> The syntax looks terrible, but I guess it's pretty fast.
23:43:19 <temoto> But only combined with static typechecking. Python doesn't have static types so it doesn't need type interference. C have static types and it really lacks type iference.
23:43:23 <callen> dmwit: evidently. it's in second place on most of the shootouts.
23:43:32 <mathijs> Hi all, I tried to do a small program to calculate the number of steps for the 3N+1 problem. I wanted to find the number that needs the most steps. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1462
23:44:25 <temoto> What is "happening place" ?
23:44:28 <dmwit> mathijs: The big loss there is that you recompute "steps" a lot of times for some things.
23:45:01 <dmwit> mathijs: For example, suppose the longest chain starts out [x, y, z, ...] and has 3000 steps.  Then you have to do 3000^2 operations to count them each!
23:45:30 <dmwit> mathijs: A bit of memoization is just what the doctor ordered...
23:46:04 <mathijs> As you can see, I added parListChunk to speeds things up on multiple cores, it works, but not as much as I would like. I figured that the chunking needs a lot of extra memory, since the maps are kept per thread before being fed to maximumBy. Is there a nice (not too manual) way to make the threads all compute the maximum in their chunk, and then let the main thread just max those chunks?
23:47:04 <mathijs> dmwit: I know the algorithm isn't perfect :)  that's not what I'm trying to fix here... this was just an attempt to try parallelization. especially, parallelization that doesn't involve manual forking/syncing and stuff.
23:47:16 <dmwit> A list comprehension might help here.
23:47:36 <dmwit> foo = maximumBy (comparing snd)
23:47:52 <pumpkin> now you need dolio's uvector schwartz!
23:47:53 <dmwit> foo [foo xs | xs <- chunk 50000 [1..1000000]]
23:48:08 <dmwit> err... that doesn't really type-check
23:48:09 <dolio> It's not call schwartzian anymore.
23:48:20 <pumpkin> dolio: what did you call it?
23:48:40 <dmwit> mathijs: There's parMap, which might be relevant, too.
23:48:42 <dolio> I went with usingKeys.
23:49:11 <dmwit> maximum (parMap (maximumBy f) (chunk 50000 [1..10000000])) -- with appropriate extra bits tacked on
23:49:13 <mathijs> dmwit: parMap sparks a thread per list item, which is a big overhead, I'm pretty sure I need chunking
23:49:14 <pumpkin> is that combined with sort somehow?
23:49:27 <mathijs> dmwit: ah... that looks ok to me
23:49:29 <dmwit> mathijs: Right, so chunk first; then each list that you're sparking is already a chunk. ;-)
23:49:33 <dolio> Yes. "usingKeys sortBy f a"
23:49:36 <pumpkin> ah :)
23:49:40 <pumpkin> that sounds awfully fancy!
23:49:51 <dolio> Or "sortBy `usingKeys` f $ a" as someone pointed out.
23:50:06 <pumpkin> what's the type of usingKeys?
23:50:09 <tehgeekmeister> well i think it was growing just as badly this time.  got to 500mb before i decided to kill it.
23:50:23 <pumpkin> tehgeekmeister: do a heap profile and  throw some cost centers around
23:50:26 <mathijs> dmwit: thanks, this'll get me going for now :)    anyway... what do you mean by the appropriate extra bits?
23:50:35 <pumpkin> tehgeekmeister: did you use strict state as was suggested?
23:50:40 <tehgeekmeister> part of it, i think, is that by accident i was constructing a list of strings of every word in the greek new testament
23:50:42 <dolio> usingKeys :: (UA e, UA k, Ord k) => (forall e'. UA e' => Comparison e' -> MUArr e' s -> ST s ()) -> (e -> k) -> MUArr e s -> ST s ()
23:50:44 <tehgeekmeister> which before i wasn't doing
23:50:56 <tehgeekmeister> (and storing the entire list in memory.)
23:51:09 <tehgeekmeister> and not just every word, but every word as it occurs
23:51:10 <tehgeekmeister> in order
23:51:16 <tehgeekmeister> that would eat up space, no?
23:51:29 <zachk> here is what you do
23:51:37 <zachk> use factorial
23:51:47 <pumpkin> dolio: wow, scary :) but I think I get it
23:52:27 <zachk> and just push every factorial number to a file
23:52:32 <dolio> pumpkin: The type of the algorithm is a little fancy, but I thought it looked better than "Comparison (k :*: e) -> MUARR (k :*: e) s -> ST s ()".
23:52:34 <dmwit> mathijs: Well, I just meant that what I wrote was a sketch; obviously "chunk" and "f" and "maximum" need to be fleshed out, and you need some plumbing in various places.
23:52:38 <zachk> my friend wanted a system test
23:52:43 <pumpkin> yeah
23:52:50 <zachk> i got his harddrive to grind he was quiet pleased
23:53:11 <mathijs> dmwit: and the memoization thing... you mean I can just hint ghc to remember some input->output for a function?  How do I make sure that the memoization (which is probably hash/alist -like) doesn't cost more than just recalculating?
23:53:46 <dmwit> mathijs: No, you can't just hint GHC that way, unfortunately.
23:53:59 <zachk> java seriously disgusts me
23:54:07 <dmwit> mathijs: I keep this link around for good measure:
23:54:09 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
23:54:23 <zachk> im like wow what a pretty site now why the hell is it so slow
23:54:51 <zachk> click careers
23:54:55 <dmwit> zachk: Who are you talking to, and what is it you're telling them?
23:55:01 <zachk> looking for senior java analyst
23:55:02 <mathijs> dmwit: so I will need to setup a (probably) Data.Map to store previous results? that will clobber up the 'real' algorithm I'm affraid.
23:55:07 <zachk> i am just talking
23:55:24 <dmwit> Can you go to -blah?
23:55:33 <zachk> yea
23:55:53 <dmwit> mathijs: Right, Map or Array.  (Probably Array is better here.)
23:56:03 <dmwit> mathijs: And yeah, that would clutter things up quite badly, I think.
23:56:30 <dmwit> mathijs: The link above makes it fairly painless, but I don't know how it interacts with parallel-ness.
23:56:54 <mathijs> dmwit: Array is better? ah, because if I store _every_ result, it can index into it without having to 'search' you mean?
23:57:29 <dmwit> mathijs: That, and because it is a little bit (okay, a lot bit) lazier.
23:57:31 <mathijs> dmwit: reading the link you gave...
23:57:54 <temoto> Please what means "happening place" ?
23:57:58 <dmwit> mathijs: Maps are spine-strict, meaning any read forces the entire list of keys.
23:58:09 <dmwit> temoto: It means a lot is happening here, i.e. the channel is popular.
23:58:17 <temoto> dmwit: thanks.
23:58:57 <mathijs> dmwit: thanks, I think I can speed things up for now :)
23:59:06 <jekor> Anyone know of a good way to get Text.Formlets to use friendlier input names than input0, input1, etc?
