00:00:00 <pumpkin> holy crap
00:00:04 <pumpkin> that book is expensive
00:00:10 <idnar> heh
00:04:53 <mmorrow> i was like "how expensive could it..", then i looked and was like "oh, yeah that's expensive"
00:04:55 <Taejo> :t fmap fmap fmap (+1) (+2) (+3)
00:04:56 <pumpkinbot> forall a. (Num (a -> a), Num a) => a -> a
00:05:28 <pumpkin> :)
00:05:54 <pumpkin> :t (fmap . fmap) (+1) (+2) (+3)
00:05:55 <pumpkinbot> forall a. (Num (a -> a), Num a) => a -> a
00:06:15 <Taejo> pumpkin: notice the Num (a -> a)
00:06:30 <pumpkin> :t (fmap `fmap` fmap) (+1) (+2) (+3)
00:06:31 <pumpkin> yeah
00:06:31 <pumpkinbot> forall a. (Num (a -> a), Num a) => a -> a
00:06:53 <idnar> pumpkinbot: fmap`fmap`fmap is the same as fmap fmap fmap :P
00:06:53 <pumpkin> just checking they're all equal
00:06:57 <pumpkin> I know :)
00:07:01 <BMeph> erick: Thanks - just found that book at my local library, and put it on order! :)
00:07:13 <pumpkin> but the infix fmap showed the (.)-ness of it better :P
00:07:13 <idnar> BMeph: oooh, rub it in :P
00:08:08 <BMeph> idnar: Okay...I had to choose one out of about fifteen copies across the city. >;)
00:08:43 * BMeph gets up and does the Kirby dance...
00:09:15 <pumpkin> yay, I have them all in my lib too
00:09:20 <pumpkin> and mine is a 5 minute walk away
00:09:27 * pumpkin rubs it in BMeph's face
00:09:53 <pumpkin> and erikc's
00:09:59 <pumpkin> muahaha etc.
00:10:04 <Taejo> I own the library
00:10:11 * Taejo rubs it in pumpkin's face
00:10:15 <pumpkin> :o
00:10:25 <pumpkin> I didn't think a single person owned this lib :o
00:10:42 <elbar> but maybe that book ;)
00:11:41 <Taejo> if you look at the keystone, you'll find "This library was secretly funded by Taejo for his own pleasure, and is only open to the public because he likes to have somebody to gloat over."
00:12:48 <Taejo> I also own #haskell; shapr is my front company. But don't tell anyone
00:17:07 <ski_> @tell conal SEC posts ?
00:17:07 <pumpkinbot> Consider it noted.
00:19:18 <ski_> glguy : SYN
00:22:15 <enoksrd> @src words
00:22:15 <pumpkinbot> words s = case dropWhile isSpace s of
00:22:15 <pumpkinbot>     "" -> []
00:22:15 <pumpkinbot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:34:58 <sm> evening all.. where do I put the type signature to fix this ambiguous type when using catch ? http://paste.lisp.org/display/74909
00:35:26 <sm> (I get this error with ghc 6.10 but not 6.8)
00:36:22 <silentOpen> haskell noob question: what's wrong with "(:) 1 2 3 4 []"?
00:36:47 <baaba> :t (:)
00:36:48 <pumpkinbot> forall a. a -> [a] -> [a]
00:37:06 <baaba> (:) takes exactly two arguments
00:37:32 <pumpkin> > 1 : 2 : 3 : 4 : []
00:37:33 <pumpkinbot>   [1,2,3,4]
00:37:40 <silentOpen> baaba, ah... not "point-free"?
00:37:47 <pumpkin> > [1,2,3,4]
00:37:49 <pumpkinbot>   [1,2,3,4]
00:38:13 <pumpkin> silentOpen: that's not it, being point-free is not mentioning one's arguments "points"
00:38:21 <pumpkin> " => (
00:38:54 <silentOpen> pumpkin, oh, yes, that's right.
00:38:56 <enoksrd> silentOpen: are you expecting LISP like behavior, e.g. (+ 1 2 3) => 1 + 2 + 3?
00:39:11 <silentOpen> enoksrd, yes, in fact I just checked out the type of (+)
00:39:41 <BONUS> basically operators are binary in haskell
00:40:00 <enoksrd> silentOpen: you don't have that in haskell, but you can easily simulate with a fold, e.g. foldr (:) [] [1,2,3,4] does what you want
00:40:26 <silentOpen> I've been reading the docs and started on a wikibook tutorial but no mention of operators yet... are they not the same as functions? or just a special name for binary functions that are usually infix?
00:40:36 <BONUS> yes, they're functions
00:40:54 <BONUS> if a function is made of only special chars like +^.> and so, it can be used as an operator
00:41:09 <baaba> > let plus = (+) in 5 `plus` 3
00:41:09 <silentOpen> ohhhhhh... then I don't have to use backticks?
00:41:10 <pumpkinbot>   8
00:41:12 <BONUS> or you can surround it with parens to treat it like a normal postfix function
00:41:17 <baaba> > 5 + 3
00:41:19 <pumpkinbot>   8
00:41:21 <BONUS> > (+) 3 4
00:41:22 <pumpkinbot>   7
00:41:40 <BONUS> > let a .*. b = a*2 + 3*c in 3 .*. 5
00:41:42 <pumpkinbot>   3 * 2 + 3 * c
00:41:51 <osfameron> sadly you can't do RPN using:  > 4 3 {+}    ;-)
00:42:00 * sm finds it
00:42:01 <baaba> (+), (+ 2), (2 +) are all sugar for partial application of the operator +
00:42:12 <BONUS> but it's trivial to do process a RPN in haskell
00:42:25 <silentOpen> ohhh postfix would be cool
00:44:25 <BMeph> silentOpen: You know the meme, "There's a pill for that"? :)
00:44:51 <silentOpen> BMeph, no? :-/
00:45:08 <silentOpen> should I stop taking all these drugs?
00:45:36 <silentOpen> I saw them advertised on TV so I ordered them from the Internet.
00:45:58 <mmorrow> silentOpen: they're probably fine, i wouldn't worry about it
00:46:00 <BMeph> silentOpen: Naugh, Haskell is red-pill enough that anything else you're on is like sugar. Like syntactic sugar for your brain. ;)
00:46:25 <silentOpen> hahaha... i'm enjoying it so far. Damn you xmonad!
00:46:53 <BMeph> silentOpen: Anyway, if there's something you're trying to figure out in Hskell, there's usually some paper that tells how to do it. :)
00:47:02 <mmorrow> if haskell was a dinosaur, i think it'd be a pterodactyl
00:47:34 <silentOpen> BMeph, it seems to be painfully flexible. Just enough rope to build an atomic bomb.
00:47:53 <BMeph> silentOpen: For instance, http://www.eecs.usma.edu/webs/people/okasaki/hw02.ps shows ways to do postfix stuff in Haskell. :)
00:48:06 <povman> is there some secure function available f :: String -> a which evaluates a haskell expression?
00:48:35 <povman> i've looked at mueval but it's a program
00:48:38 <mmorrow> povman: kind of, but you have to use the ghc-api
00:48:44 <mmorrow> , eval "1+1"
00:48:47 <silentOpen> BMeph, wow... that's awesome. From now on I will assume it's possible (and has been done!). Thanks :-)
00:48:49 <lunabot>  <<Integer>>
00:48:56 <mmorrow> , fromDynamic (eval "1+1") :: Maybe Integer
00:48:58 <lunabot>  Just 2
00:49:14 <povman> can i allow The Internet to plug functions into my program?
00:49:20 <BMeph>  ;)
00:49:31 <mmorrow> povman: i have it in this pkg http://moonpatio.com/repos/luna/
00:49:51 <Peaker> so, how come Applicative's (>>) doesn't have a name?
00:50:07 <Peaker> @type liftA2 const
00:50:08 <pumpkinbot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f a
00:50:13 <Peaker> @type liftA2 (flip const)
00:50:13 <mmorrow> povman: the haddocks + the "luna_test.hs" file should be enough to give a start
00:50:14 <pumpkinbot> forall b a (f :: * -> *). (Applicative f) => f a -> f b -> f b
00:50:28 <povman> mmorrow: awesome. eval seems to be what i want...
00:50:48 <mmorrow> povman: also, if you end up using it, you'll want to edit Config.hs (the package versions imported for one) for your setup
00:51:11 <mmorrow> povman: lunabot is using that exact same eval function to run Strings coming in over the network
00:51:24 <mmorrow> the best part is that eval can see itself
00:51:30 <povman> sweet. so if i'm screwed, then so are you.
00:51:38 <mmorrow> hehe
00:51:40 <povman> what do you mean 'see itself'?
00:51:50 <vegai> , eval (eval "1+1")
00:51:51 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
00:52:06 <povman> oh wow
00:52:08 <mmorrow> so the Env that eval is using imports the module eval is defined in, so evals can be infinitely nested
00:52:19 <mmorrow> , eval "eval \"42\""
00:52:21 <lunabot>  <<Dynamic>>
00:52:39 <vegai> , eval "eval \"1+1\""
00:52:42 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"" ) :: Integer
00:52:42 <lunabot>  <<Dynamic>>
00:52:44 <lunabot>  42
00:52:49 <vegai> ah :)
00:53:20 <povman> mmorrow: i assume eval protects from infinite recursion and unsafePerformIO and the like?
00:53:36 <mmorrow> povman: it would depend on what you import into its env
00:53:49 <mmorrow> so for the bot it does, but you don't have to if you don't want
00:53:49 <povman> , eval "[1..]
00:53:50 <lunabot>  luna: lexical error in string/character literal at end of input
00:53:57 <Deewiant> , eval "last [1..]"
00:53:58 <povman> , eval "[1..]"
00:53:59 <lunabot>  <<Integer>>
00:54:00 <lunabot>  <<[Integer]>>
00:54:06 <Deewiant> cheater :-P
00:54:12 <mmorrow> also, there's a "run", and "runIn" functions that you can do anything inside of
00:54:16 <povman> , fromDynamic eval "[1..]"
00:54:17 <lunabot>  luna: Couldn't match expected type `Data.Dynamic.Dynamic'
00:54:25 <povman> , fromDynamic $ eval "[1..]"
00:54:27 <lunabot>  Nothing
00:54:31 <povman> what.
00:54:39 <mmorrow> Typeable is finicky
00:54:48 <mmorrow> you have to give an explicit type sig
00:54:49 <Deewiant> , fromDynamic (eval "last [1..]" :: Integer)
00:54:50 <lunabot>  luna: Couldn't match expected type `GHC.Integer.Internals.Integer'
00:54:59 <Deewiant> , fromDynamic (eval "last [1..]") :: Maybe Integer
00:55:05 <mmorrow> , eval "last [1..]"
00:55:05 <lunabot>  Killed.
00:55:07 <lunabot>  <<Integer>>
00:55:42 <mmorrow> this file shows an example of using the runIn function (and acquiring an :: Env) http://moonpatio.com:8080/repos/luna/luna_test.hs
00:57:38 <sior|oifig> dcoutts: ping?
00:57:54 <dcoutts> sior|oifig: pong
00:58:21 <dcoutts> sior|oifig: how do you like the snow? :-)
00:58:49 <sior|oifig> dcoutts: it's AWESOME! Wouldn't want to have to drive or bike in it, though
00:59:51 <evil_china> test
01:00:01 <dcoutts> sior|oifig: quite. I'll be walking in today
01:01:05 <mmorrow> gah, my laptop dies
01:01:07 <mmorrow> *died
01:02:09 <evil_china> bury it
01:03:31 <mmorrow> if anyone tries luna, please note that (1) it only works with _exactly_ 6.10.1 (due to the volatility of the ghc-api), and (2) you'll need to edit the packages/modules for the defaultEnv in Luna/Config.hs to be correct for you setup (it should be self-explanatory how to do so (just need to change a pkg version number or two)) :)
01:04:33 <mmorrow> <povman> mmorrow: i assume eval protects from infinite recursion and unsafePerformIO and the like?
01:04:47 <povman> mm?
01:05:00 <mmorrow> povman: err, to the extent that ghci does (let x = x in x will lock you up)
01:05:29 <povman> , eval "unsafePerformIO (forever return)"
01:05:31 <mmorrow> lunabot has the evaluator in a separate proc, which sets rlimits on itself before evaluating incoming code
01:05:31 <lunabot>  luna: Not in scope: `unsafePerformIO'
01:05:40 <mmorrow> , let x = x in x
01:05:42 <lunabot>  luna: out of memory (requested 2097152 bytes)
01:05:43 <povman> ok so that stuff is up to me
01:05:46 <povman> cool
01:05:46 <mmorrow> yes
01:06:06 <povman> sounds awesome. i'm making a web based kolmogorov complexity game :p
01:06:12 <mmorrow> ooh, cool
01:06:49 <povman> all my real-life friends say 'huh. that's really boring.'
01:06:53 <mmorrow> heh
01:07:28 <ray> that's why the internet exists
01:08:16 <povman> looks like i have at least 1 player then
01:08:58 <ray> for me it all depends on whether it crashes my junk computer
01:09:02 <SubStack> grr opengl's uniform type should have floats and doubles >_<
01:09:48 * SubStack just wastefully throws it into a Vertex2
01:10:45 <povman> ray: if your computer can run an IRC client, it can surely render some text and a textbox on a web page
01:11:59 <ray> that seems reasonable, but junk computers don't do reasonable things
01:12:21 <SubStack> it compiled! D:
01:12:36 * SubStack is undecided about whether it should have compiled
01:12:48 <silentOpen> povman, what's the game? do you try to compute complexity? write the shortest code to generate given data?
01:12:55 <SubStack> GL error: invalid operation >:|
01:14:16 <povman> silentOpen: 1. game generates 100 numbers between 0 and 9;  2. you write the shortest program to generate that sequence
01:14:30 <SubStack> neat
01:14:46 <silentOpen> povman, how is the generation done? are there levels?
01:14:56 * SubStack is working on a generalized version of that problem
01:15:20 <SubStack> turns out regular languages have some peculiar properties
01:15:32 <SubStack> but you didn't hear it from me!
01:15:48 <povman> silentOpen: i was thinking just completely random to start with, but it might be nice to base them on simple sequences too
01:16:14 <SubStack> or maximally irreducible for extra wins
01:16:23 <SubStack> that'll show 'em
01:17:22 <silentOpen> povman, hmmm... users could submit sequences, too -- challenge others. Will you compress the code somehow to determine how much information is in it?
01:17:24 <povman> i could pull some sequences from the encyclopedia of integer sequences!
01:17:37 <ray> i was just about to say Math.OEIS
01:17:45 <SubStack> povman: do it!
01:17:49 <int80_h> I want a list of the same number, of arbitrary length
01:17:55 <int80_h> [3,3,3]
01:17:59 <int80_h> like that
01:18:01 <povman> > replicate 3 3
01:18:02 <pumpkinbot>   [3,3,3]
01:18:06 <int80_h> ah replicate!
01:18:14 <int80_h> nice. I was hoping there was a function
01:18:32 * SubStack hands int80_h 60 replicator credits
01:18:46 <povman> (look out for inflation)
01:23:07 * SubStack throws in a bunch of prints to track this down
01:23:11 <SubStack> curse these side effects!
01:24:23 <fldr> @src sum
01:24:23 <pumpkinbot> sum = foldl (+) 0
01:31:04 <evil_china>  8
01:32:26 <ac> is there any way to load a Haskell file in ghci without blowing away your top level bindings?
01:32:45 <ac> that's really starting to bug me
01:33:04 * vegai concurs
01:33:37 <vegai> as a workaround, you can move your bindings to the module temporarily
01:33:41 <int80_h> ac: tell me about it
01:34:02 <ac> well, the particular binding I want to save is an external resource, so I can't just stick it in a file
01:34:16 <ski_> (what should happen if those top level bindings has types mentioning types which are re-defined in the reloaded file(s) ?)
01:35:42 <ac> I also wish I could paste functions and multiple lines of code in to ghci
01:36:02 <ac> but I'm well aware that wish has been made here enough
01:36:08 <doserj> ski_: sml can deal with this. the bindings stay, but the types are sonehow "shadowed" into a non-existing module called "?"
01:44:55 <ski_> (doserj : yes, i know)
01:46:14 * alexeevg vaguely remembers getting errors like "expected type Foo, but received Foo instead" in some ML repl
01:46:52 <hallongrottan> @pl intercalate " " . map (\x -> [x,toUpper x])
01:46:52 <pumpkinbot> intercalate " " . map (ap (:) (return . toUpper))
01:49:00 <alexeevg> Just checked in OCaml repl, it allows redefining types from command prompt, and then yells at you "This expression has type foo but is here used with type foo"
01:49:15 <alexeevg> anyway, ocaml repl is very convenient
01:53:23 <int80_h> what does pl do?
01:53:50 <alexeevg> frees the points
01:54:04 <alexeevg> @pl (\x -> x)
01:54:05 <pumpkinbot> id
01:54:29 <alexeevg> @pl (\f g x -> f (g x))
01:54:29 <pumpkinbot> (.)
01:55:13 <pao> @type catch
01:55:16 <pumpkinbot> forall a. IO a -> (IOError -> IO a) -> IO a
01:55:51 <kaol> @pl (\a b c d -> (a . b) + (c . d))
01:55:52 <pumpkinbot> flip flip (.) . (((.) . (.) . (+)) .) . (.)
01:57:32 <pao> is using TH considered a "good practice?"
01:58:14 <sjanssen> pao: it isn't a "bad practice"
01:58:18 <fasta> pao: if it saves you work, yes.
01:58:26 <sjanssen> but I think you rarely need it
02:00:01 <pao> sjanssen: I have to update a record with the info from another record (the fields in the source are a subset of the fields in the destination record) ... could TH help me? (I have simplified the problem)
02:04:44 <fasta> pao: TH can help you in a theoretical sense. I don't think TH has much value currently, because there is no coherent, up-to date document describing how to use it.
02:05:12 <pao> fasta: point taken... thanks for your help
02:05:30 <fasta> There are some people that use TH, but most of them are connected to the compiler writers, or just have too much time.
02:05:33 <sjanssen> fasta: yeah, learning TH is really not easy
02:05:36 <sjanssen> somebody needs to fix that
02:07:15 <pao> fasta: it's quite funny that this very useful info (TH hasn't much value...) isn't retrievable on web sites ;-)
02:07:36 <macron> i think the major problem with TH is that it only partially delivers on its promises: splicing types or patterns isn't implemented, amongst other things, making it all to often necessary to do things very verbosely and jumping around hoops.
02:07:39 <fasta> pao: that is because the people that know it have an interest in getting more people to know it.
02:08:12 <fasta> pao: I too have an interest in having better TH, as do most Haskell users, I guess.
02:08:53 <pao> fasta: I understand... but for a newbie is very ineffective to find the real situation only after investing in the topic...
02:09:28 <pao> fasta: my point is that IRC (with "unofficial" and "personal" point of view) is a _great_ resource :-)
02:23:41 <povman> who remembers that program 'buddha'/
02:23:43 <silentOpen> what's TH?
02:23:54 <dibblego> Template Haskell
02:24:00 <povman> that was SUCH A GOOD WAY of debugging, i actually wanted my code to have bugs so i could use it
02:24:08 <silentOpen> dibblego, thanks
02:24:30 <povman> imo something similar belongs in ghc
02:37:20 <Boney> povman: the guy that wrote it works in my department.
02:37:41 <Boney> Declarative debuggers are awesome.
02:38:22 <Boney> research is being done on smarter algorithms that search for bugs, so that the user answering the questions can generally answer the questions quicker.
02:38:57 <Boney> for example if you have functions f and g, it's a good idea that if you ask a question about f, then you should ask another question about f while it's still in the user's mind.
02:43:01 <povman> oooo
02:44:45 <score> Boney: have a debugger of choice?
02:45:25 <povman> currently buddha doesn't work
02:45:41 <score> povman: why is that?
02:47:03 <povman> score:
02:47:11 <povman> score: where should i get it from?
02:48:05 <Boney> score: for haskell,  No not really.  I normally work in Mercury where the provided debugger has declartive debugging support.
02:49:14 <score> povman: looks like the source is available
02:49:31 <povman> you mean version 1.2.1 from 2 years ago?
02:50:03 <__vikrant__> fix f = f (fix f)
02:50:04 <povman> doesn't seem to build with newer technology
02:50:15 <__vikrant__> :t fix
02:50:16 <pumpkinbot> forall a. (a -> a) -> a
02:51:06 <score> povman: you could've just said that buddha is outdated..
02:51:18 <povman> i said it doesn't work
02:51:26 <score> povman: not sure why you would ask me where you should get it from
02:51:54 <povman> i thought you were suggesting there was a darcs version somewhere which does build
02:52:03 <povman> sorry, misunderstanding
02:53:12 <score> what about hood or hat?
02:53:31 <povman> i never got either of them working, but haven't tried recently
02:54:03 <fasta> Hat doesn't work currently.
02:54:36 <povman> The current released version of HOOD is the July 2000 release
02:54:43 <score> not sure what to do when debugging. i keep hearing that Debug.Trace is for newbies
02:55:24 <povman> debug.trace works for me, but really it's just the equivalent of inserting debugging printfs
02:55:55 <povman> buddha was _really_ nice to work with
02:56:01 <score> yeah, well, if there is something better, i'd like to hear it
02:58:12 <povman> debug.trace is also easier to use if you make a little wrapper function: tr a = trace (show a) a
02:58:47 <povman> then you can put tr$ at the start of lines you want to see the value of
02:58:55 <povman> etc
03:10:37 <jkff> Hi. There are quite a few regex packages on hackage; which one is the fastest for non-tricky patterns like "foo=([0-9]+).*bar=([0-9]+)"? (no exponential blowup for pcre, no nothing, but I'm using pcre-light and it seems pretty slow to me)
03:18:00 <jkff> Disregard that, I found http://www.haskell.org/haskellwiki/Regular_expressions
03:19:19 <Martijn> Does anyone have lambdabot or pl running locally?
03:19:33 <lilac> yes
03:19:55 <dagg> ciao
03:20:35 <Martijn> @pl \x -> abcdefgh x []
03:20:35 <pumpkinbot> flip abcdefgh []
03:20:51 <Martijn> When I run that one locally it's really really slow.
03:20:54 <dagg> !list
03:21:10 <Martijn> And I have no idea why
03:22:06 <lilac> Martijn: i see the same thing
03:22:52 <Martijn> It seems crucial that abcdefgh has at least 8 characters.
03:24:15 <lilac> Martijn: it also seems crucial that it's applied to []
03:24:20 <Martijn> yes
03:24:40 <Martijn> But the lambda is crucial too, as is the position of the argument :-)
03:25:08 <lilac> indeed :) nice minimal failing testcase there :)
03:25:41 <Martijn> pumpkinbot has no problems though
03:25:47 <Martijn> ,help
03:25:48 <lunabot>  luna: Not in scope: `help'
03:25:58 <lilac> , pl
03:26:00 <lunabot>  luna: No instance for (GHC.Show.Show
03:26:01 <Martijn> ,pl \x -> abcdefgh x []
03:26:02 <lunabot>  luna: parse error on input `\'
03:26:25 <lilac> , pl (\x -> slowdown x [])
03:26:26 <lunabot>  luna: Not in scope: `slowdown'
03:26:28 <lilac> :(
03:26:40 <Martijn> Sadness
03:27:01 <lilac> Martijn: i guess it's probably trying to substitute out 'abcdefgh' and using a very-poorly-performing lookup?
03:27:35 <lilac> @pl \x -> concatMap x []
03:27:35 <pumpkinbot> ([] >>=)
03:27:59 <lilac> aww. i was hoping for const []
03:28:01 <Martijn> Possibly
03:28:37 <Martijn> There aren't that many functions pl knows the definition of
03:28:43 <ivanm> lilac: that sounds more like a "logic" replacement rather than a function manipulation one
03:28:57 <ivanm> notice that what pumpkinbot is, indeed, point-free
03:31:33 <mun> hi
03:32:12 <daf> ho
03:32:49 <mun> i'm trying to run make to compile a tool called HETS, which uses ghc. i'm getting several errors at the moment, e.g., "n/uni/util/libuni-util.a(Debug.o): In function `snE7_info': (.text+0xd0b): undefined reference to `__stginit_haskell98_IO_'"
03:32:55 <mun> does anyone know what could be wrong?
03:33:16 <mun> this is the command it tried to run: /usr/bin/ghc -o testDynamics -O   -fno-mono-pat-binds -fglasgow-exts -fallow-overlapping-instances -fallow-undecidable-instances -fwarn-unused-imports -fwarn-missing-signatures -fwarn-unused-binds -fwarn-deprecations -recomp -fth -package-conf /home/mchan/uni/uni-package.conf  -package uni-util  TestDynamics.o  -package uni-util-test
03:33:37 <lilac> ivanm: sure, but @pl also does optimization of the result
03:33:45 <doserj> mun: try -package haskell98
03:33:56 <lilac> (although i'm not sure exactly what it's optimizing /for/)
03:33:58 <doserj> mun: or simply --make
03:34:35 <mun> doserj: i'll give that a try now
03:36:13 <Martijn> afk
03:36:19 <inbuninbu> can anyone tell me what the preferred way of reading/writing binary is? i've seen a couple of different ways, but the one i decided to try i can't get to work right
03:38:22 <cytzol> ?check \xs ys -> reverse (xs ++ ys) == (reverse ys) ++ (reverse xs)
03:38:23 <pumpkinbot>   "OK, passed 500 tests."
03:38:40 <cytzol> Well, that's my formal methods assignment done!
03:39:20 <mun> doserj: the same error unfortunately
03:39:27 <inbuninbu> i've tried Data.ByteString.Char8.readInt, per 'Real World Haskell'. I've seen it suggested that hGetBuf should be used as well
03:39:58 <mun> doserj: -make is unrecognised, apparently
03:40:09 <mun> but -package haskell98 didn't help
03:40:10 <liwp> try --make
03:40:10 <BONUS> --make
03:40:13 <BONUS> not -make
03:40:15 <BONUS> ::]
03:40:26 <mun> ah okay
03:45:04 <jkff> Hmm, seems like the 'Log in or create an account' page on haskellwiki has lost its ability to create an account. To whom should I report that?
03:45:36 <jkff> (There's nothing resembling an account creation form there, just the login form)
03:46:44 <ksf> jkff, it has been disabled due to spammers.
03:47:36 <jkff> That's a pity. Is there now no way to create an account at all?
03:47:50 --- mode: irc.freenode.net set +o ChanServ
03:47:53 <ksf> I've got no idea.
03:52:44 <bobshush> Hello, everyone!
03:52:50 <bobshush> Small question
03:53:25 <ivanm> wow! it was so small I couldn't even see it! :p
03:53:31 <bobshush> Ive been trying to write a function for about the past hour with type [IO a] -> IO [a]
03:53:40 <bobshush> sorry, can be slow typing
03:53:45 <lilac> @type sequenceM :: [IO a] -> IO [a]
03:53:46 <pumpkinbot> Not in scope: `sequenceM'
03:53:48 <ivanm> @hoogle [IO a] -> IO a
03:53:49 <pumpkinbot> Control.Monad msum :: MonadPlus m => [m a] -> m a
03:53:49 <pumpkinbot> Control.Exception block :: IO a -> IO a
03:53:49 <pumpkinbot> Control.Concurrent runInBoundThread :: IO a -> IO a
03:53:56 <ivanm> @src msum
03:53:57 <pumpkinbot> msum =  foldr mplus mzero
03:54:05 <lilac> @type sequence :: [IO a] -> IO [a]
03:54:06 <pumpkinbot> forall a. [IO a] -> IO [a]
03:54:07 <ivanm> looks about right
03:54:15 <ivanm> oh, wait, IO [a]
03:54:23 <ivanm> yeah, sequence is probably what you want
03:54:24 <lilac> bobshush: 'sequence' will work for any Monad instance
03:54:28 <ivanm> @src sequence
03:54:29 <pumpkinbot> sequence []     = return []
03:54:29 <pumpkinbot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:54:29 <pumpkinbot> --OR
03:54:29 <pumpkinbot> sequence xs = foldr (liftM2 (:)) (return []) xs
03:54:51 <ivanm> hmmmmm..... is there any performance difference between the two?
03:55:01 <ivanm> is the second fusable maybe?
03:55:38 <bobshush> ok, trying to wrap my head around these
03:55:40 <lilac> ivanm: yeah, the foldr is fusable. otherwise, they're identical.
03:55:48 <bobshush> you said sequence?
03:55:53 <ivanm> yeah
03:56:06 <ivanm> see the first version defined above, it should be pretty simple to understand
03:56:15 <ivanm> (especially if you write the do block over multiple lines)
03:56:59 <leviatha`> I have a dependency problem when installing hxt. It requires base >=4. I have installed ghc6.8.2 in debian. What can I do to resolve the problem?
03:57:23 <lilac> leviatha`: install ghc6.10.1 :)
03:58:24 <doserj> leviatha`: or install an older version of hxt. 8.1.0 should work
03:59:13 <bobshush> I think I sort of understand sequence now, cool
03:59:16 <bobshush> thanks
03:59:24 <ivanm> hmmmmm.... are there any major packages apart from gtk2hs that don't work with 6.10 yet?
03:59:29 <bobshush> what was that hoogle thing?
03:59:32 <leviatha`> I'll try the older version. Thanks
03:59:42 <bobshush> @hoogle a -> [a]
03:59:42 <pumpkinbot> Prelude repeat :: a -> [a]
03:59:42 <pumpkinbot> Data.List repeat :: a -> [a]
03:59:42 <pumpkinbot> Prelude iterate :: (a -> a) -> a -> [a]
03:59:49 <ivanm> bobshush: @hoogle (there's an online version as well) searches for functions by name or type signature
04:00:07 <bobshush> @hoogle iterate
04:00:07 <pumpkinbot> Prelude iterate :: (a -> a) -> a -> [a]
04:00:07 <pumpkinbot> Data.List iterate :: (a -> a) -> a -> [a]
04:00:07 <pumpkinbot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
04:00:13 <ivanm> note that it's not perfect, as sometimes the type signature search over-generalises (e.g. changing [a] to a)
04:00:36 <bobshush> @hoogle [IO a] -> IO [a]
04:00:36 <pumpkinbot> Prelude sequence :: Monad m => [m a] -> m [a]
04:00:36 <pumpkinbot> Control.Monad sequence :: Monad m => [m a] -> m [a]
04:00:36 <pumpkinbot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:00:49 <bobshush> cool
04:02:53 <bobshush> Alright, I think I know what I'm doing now. Thanks everyone!
04:02:54 <yitz> there is an alternative search engine: hayoo
04:03:00 <yitz> @where hayoo
04:03:00 <pumpkinbot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
04:05:41 <yitz> @seen lispy
04:05:41 <pumpkinbot> I saw lispy leaving #haskell 18h 58m 23s ago, and .
04:07:14 <mun> i'm trying to run make to compile a tool, but i keep getting an error saying:
04:07:23 <chrisdone> one day I will fix that "and ." bug, I swear
04:07:31 <mun> "/uni/util/libuni-util.a(Debug.o): In function `snE7_info':(.text+0xd0b): undefined reference to `__stginit_haskell98_IO_'"
04:07:45 <mun> does anyone know how it can be fixed?
04:08:01 <mux> mun: you usually have these kind of errors because of a missing -package
04:08:21 <mux> try adding -package haskell98 to your GHC command line
04:08:29 <mux> or use --make !
04:08:39 <mun> mux: right. i've tried that haskell98, but no good
04:08:42 <mux> it'll figure out the package dependencies for you
04:09:42 <mux> mun: mmm, make sure to clean stale .o and .hi files too, that might help
04:09:43 <mun> mux: what should be the input to --make?
04:09:55 <mux> I mean ghc --make -o foo Foo.hs
04:11:29 <mun> mux: i see. is this command correct? /usr/bin/ghc --make -o testDynamics -O   -fno-mono-pat-binds -fglasgow-exts -fallow-overlapping-instances -fallow-undecidable-instances -fwarn-unused-imports -fwarn-missing-signatures -fwarn-unused-binds -fwarn-deprecations -recomp -fth -package-conf /home/mchan/uni/uni-package.conf  -package uni-util  TestDynamics.o  -package uni-util-test
04:11:41 <mun> basically the Makefile tries to run exactly that without --make
04:11:59 <mun> but i get the error "no input files"
04:12:13 <mux> well yeah, where are the sources here in this command line?
04:12:20 <mux> there's only some .o file which looks weird
04:12:34 <mux> are you trying to adapt .c rules to haskell in your makefile?
04:12:51 <Cale> Whoa, this conversation confused me at first :)
04:12:51 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
04:12:58 <Cale> mun vs. mux :)
04:13:11 <mun> :)
04:13:13 <mux> heh
04:13:30 <mun> mux: well i don't think so..
04:13:30 <yitz> Cale: good morning :) I notice that lispy's machine is back up again. (sigh)
04:13:40 <Cale> Just sshing into it now :)
04:15:10 <ivanm> lambdabot is back! \o/
04:15:20 <mun> mux: should that command line contain sources?
04:15:32 <Axman6> \o/
04:15:39 <mux> mun: yes, as far as I know it should
04:15:54 <ivanm> Cale: if you got confused by mun vs mux, maybe you need an IRC client that colours the nicks ;-)
04:16:06 <Cale> ivanm: hehe, I'm fine now :)
04:17:03 <leviatha`> lilac: hxt.8.1.0 was installed without problems. Thank you for your help.
04:17:27 <mux> btw, I'm in desperate need of help with my space leak problem
04:17:32 <Cale> actually, I do have a coloured nicknames option, perhaps I'll try leaving that on for a while, and see if it annoys me or not :)
04:17:38 <mux> I got 0 answers on my nearly one month old post to haskell-cafe@
04:17:43 <mux> http://www.haskell.org/pipermail/haskell-cafe/2009-January/053225.html
04:18:10 <mun> could someone kindly try to run make.. just to assure me that it actually works..?
04:18:39 <mun> this is the link: http://www.informatik.uni-bremen.de/agbkb/forschung/formal_methods/CoFI/hets/src-distribution/versions/uni-ghc-6.8.x-HaXml-1.13.2-2008-01-25.tgz
04:19:04 <mux> Cale: would you happen to have any idea on this?
04:19:36 <mfp> WTF why did this get 5 upvotes (NSFW!!!)  http://www.reddit.com/r/programming/comments/7v22j/why_iteration_can_sometimes_land_you_in_deep/
04:19:37 <Cale> mux: I'm just looking at it... strange.
04:20:00 <mfp> (= plz downvote)
04:20:39 <Axman6> ?users
04:20:39 <pumpkinbot> Maximum users seen in #haskell: 692, currently: 639 (92.3%), active: 14 (2.2%)
04:20:40 <lambdabot> Maximum users seen in #haskell: 658, currently: 639 (97.1%), active: 9 (1.4%)
04:20:46 <Cale> mux: does it happen if you remove the 'snd' from that definition of main ?
04:20:55 <Axman6> hmm, new max while lambdabot was gone? :o
04:21:03 <ivanm> mfp: because some people like porn?
04:21:08 <Cale> mfp: reported.
04:21:24 <mux> Cale: well I'd need to replace it with show then, wouldn't I?
04:21:36 <Cale> mux: yeah...
04:21:44 <mux> ok let me try this
04:22:07 <Cale> mux: I'm just curious if it has something to do with the other components of those pairs piling up or something.
04:22:16 <Cale> Though, that would be strange.
04:22:24 <sempaticboy> hi
04:22:29 <Cale> hello
04:22:51 <Martijn> @src showList
04:22:51 <pumpkinbot> Source not found. Maybe you made a typo?
04:22:52 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:22:59 <Martijn> @hoogle showList
04:22:59 <pumpkinbot> Prelude showList :: Show a => [a] -> ShowS
04:22:59 <pumpkinbot> Text.Show showList :: Show a => [a] -> ShowS
04:22:59 <pumpkinbot> Text.Show showListWith :: (a -> ShowS) -> [a] -> ShowS
04:23:00 <lambdabot> Prelude showList :: Show a => [a] -> ShowS
04:23:00 <lambdabot> Text.Show showList :: Show a => [a] -> ShowS
04:23:00 <lambdabot> Text.Show showListWith :: (a -> ShowS) -> [a] -> ShowS
04:23:12 <Cale> pumpkinbot: @part #haskell
04:23:15 <mux> Cale: rebuilding the index to be able to test, it'll a few minutes
04:23:38 <Martijn> Hi Cale
04:23:48 <Cale> Martijn: hello
04:24:20 <bastl> hi, i try to add "deriving Data,Typeable" to the datatypes of HaXml. Most things work, but i get these error messages for types "OneOfN" with N>=8. http://haskell.pastebin.com/m7e0ee418 The funny thing is that it works for types OneOfN <=7.
04:24:24 <Cale> mux: It might be easier for people to respond to, by the way, if they had something they could run themselves...
04:24:43 <mux> alright I'll followup with sources
04:24:50 <mun> woohoo.. i've got it to compile
04:24:51 <mun> thanks
04:25:15 <Cale> mux: It's just an idea :)
04:25:19 <mux> problem will be I cannot provide the data to generate the index
04:25:25 <Cale> mux: yeah...
04:25:29 <mux> it involves illegal stuff *blush*
04:25:47 <Cale> mux: I wonder if there's a way to simplify out something which won't need data.
04:26:27 <mux> bah, I can't seem to generate a proper index now, I must have done some changes that I forgot about
04:26:32 <Cale> Illegal stuff eh? :)
04:26:44 <Martijn> > foldr (.) id [shows 4, shows 5] $ ""
04:26:48 <lambdabot>   "45"
04:27:10 <Martijn> Is there a standard function for foldr (.) id?
04:27:16 <andun> is there a good repository providing debian packages of ghc 6.10?
04:27:42 <doserj> bastl: that's a documented issue. http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#deriving-typeable
04:28:10 <baaba> > mconcat [(+1), (+2)] $ 0
04:28:12 <lambdabot>   Add a type signature
04:28:23 <Cale> Martijn: not really...
04:28:26 <baaba> > mconcat [(+1), (+2)] $ 0 :: Integer
04:28:28 <lambdabot>       No instance for (Monoid Integer)
04:28:28 <lambdabot>        arising from a use of `mconcat'...
04:28:36 <Martijn> Well, I guess it's short enough as it is :-)
04:28:43 <Cale> > runEndo (mconcat [Endo (+1), Endo (+2)]) 0
04:28:44 <lambdabot>   Not in scope: `runEndo'
04:28:47 <Cale> er...
04:29:04 <mux> Cale: it searches for directories of the form Foo.Bar.Baz.DVDRiP-LALA if you see what I mean
04:29:07 <Martijn> Yes, the default instance for Monoid (a -> b) is not what I want here.
04:29:08 <Cale> andun: That sure would be nice :)
04:29:11 <Martijn> Endo works though.
04:29:18 <Cale> ah, appEndo
04:29:22 <Cale> > appEndo (mconcat [Endo (+1), Endo (+2)]) 0
04:29:24 <lambdabot>   3
04:29:27 <Martijn> But then I might as well write foldr (.) id
04:29:30 <Cale> yes
04:29:40 <Cale> foldr (.) id is what I'd write myself
04:30:19 <andun> Cale: right. :)
04:30:53 <Cale> andun: Personally, I've been using the generic linux binaries which you can get from the GHC download page.
04:32:00 <bastl> doserj: thanks
04:32:02 <mun> now i'm getting another problem when running another make: "Could not find module `Packer': it was found in multiple packages: uni-htk-kernel uni-htk-1.1" anyone know what it means? is Packer a name clash?
04:32:36 <mux> Cale: yes, same leak with B.putStrLn . snd changed to print
04:33:00 <andun> Cale: i'll try them. thanks
04:33:33 <Cale> mux: hmm, okay
04:35:41 <Cale> mux: So, the profiler is suggesting that the allocation is all in the call to replicateM? How big an n are we talking about here? replicateM does allocate a list...
04:36:49 <mux> Cale: there are only 6702 elements in the list and I know it can hold in memory just fine since there is no problem creating the index (although in that case we get more sharing)
04:37:00 <mux> 6702 ByteString's
04:37:07 <Cale> Yeah, that's a trivial sized list on its own.
04:37:24 <Cale> How big is each bytestring? Just a filename?
04:38:12 <mux> yes
04:38:19 <mux> the longest one is 172 characters
04:38:23 <Cale> Okay, that's ridiculous then...
04:39:01 <mux> at any rate, the index file I'm serializing is only 1.2MB
04:39:18 <andun> is there a way to make cabal rebuild all my packages for ghc-6.10?
04:39:59 <Cale> andun: I think when you install the new ghc, it'll have a different package database. You can use cabal to install them individually though.
04:40:19 <mux> Cale: I have also tried to just decode the array which is the first thing in the binary file, and I can deserialize and use it just fine. however when I deserialize the array and the trie, it blows up
04:40:30 <mux> and I also tried to just deserialize the trie, before you ask :-)
04:41:12 <mux> I think I could workaround this problem by keeping both separate, but I'd really like to understand why it doesn't work
04:41:51 <Cale> and just deserialising the trie works fine too?
04:41:56 <mux> yes
04:41:56 <Cale> How odd...
04:42:23 <mux> you know what's the most odd thing? as I mention in my mail, if I copy paste the one-line definition of main in GHCi, the code runs fine
04:42:34 <mux> whereas if I type "main" in GHCi, it leaks memory
04:42:43 <mux> that really makes me o_O
04:43:14 <Cale> Do you have a .o file sitting around?
04:43:38 <mux> I've wiped out the whole dist/ subdir several times (using cabal to build)
04:43:40 <Cale> If there's a .o/.hi, then ghci will load that instead of the source code.
04:43:45 <Cale> oh
04:43:53 <boxbeat> computer-oriented computing. what does that mean? it is translated from a apsnaish site, uni of tenerife
04:44:10 <Cale> boxbeat: heh
04:45:06 <boxbeat> man tenerife, didnt realize they had such a great university. surfing,windsurfing and study physics and math there, hwo awesome!
04:48:43 <mux> Cale: I should probably rebuild all the dependent packages from fresh - now if I try to run the code in GHCi, it still doesn't leak, but I get an exception from Data.Binary saying there are too few bytes
04:48:48 <mux> I must have mangled things up
04:53:02 <lepassive> f following g doesn't it equals f $ g(x) ?
04:53:31 <mun> i'm trying to run a make and i'm getting this error: "Could not find module `Data.Time':  Use -v to see a list of the files searched for."
04:53:53 <mun> and it has looked through  Data/Time.hs and Data/Time.lhs
04:53:59 <mun> does anyone know how to fix this?
04:55:50 <yitz> mun install the time package?
04:56:42 <mun> yitz: oh silly me. thanks
04:57:19 <Saizan> lepassive: can you rephrase the question?
04:57:40 <mstr> hey, how do I use named fields in instance declarations?
04:58:06 <mstr> all tutorials just give dumb: red = "Red" examples :/
04:58:26 <yitz> mstr: fields of what?
04:58:38 <Cale> Named fields?
04:58:48 <mstr> of datatypes
04:58:59 <lepassive> Saizan, http://pastebin.com/d62b81d9c
04:59:07 <Cale> You... use them like you'd use them in defining ordinary functions.
04:59:12 <yitz> mstr: nothing special about instances
04:59:14 <mstr> like data myNum = myNum { value : Int}
04:59:24 <lepassive> I'm trying to apply f following g on that snippet
04:59:38 <Cale> s/myNum/MyNum/ of course
04:59:50 <Cale> and s/:/::/
04:59:52 <scook0> data MyNum = MyNum { value :: Int }
04:59:56 <Saizan> lepassive: function application has the highest precedence, so "f . g x" is parsed as "f . (g x)" while you want "(f . g) x"
05:00:10 <mstr> guys, forget the typos :)
05:00:11 <yitz> mstr: so if you have a MyNum, the expression value x gives an Int
05:00:17 <Cale> mstr: So, I don't get what this has to do with instances.
05:00:28 <yitz> mstr: anywhere, not just in instances
05:00:36 <mstr> How do I make it the instance of Eq
05:00:36 <lepassive> Saizan, you are my hero thanks alot
05:00:38 <Cale> yitz: x?
05:00:40 <Saizan> lepassive: that's why we usually write "f . g $ x"
05:00:42 <mstr> so that the values get compared?
05:00:51 <Cale> mstr: You can either add  deriving Eq
05:00:52 <yitz> mstr: x is a MyNum, yeah, sorry
05:00:58 <Cale> Or you can write something like
05:01:04 <Cale> instance Eq MyNum where
05:01:06 <mstr> instance Eq MyNum where:
05:01:08 <mstr> and then?
05:01:14 <Cale>   x == y = value x == value y
05:01:33 <mstr> oh, it's that simple :o
05:01:40 <yitz> data MyNum = MyNum {value :: Int} deriving Eq
05:01:51 <yitz> that's even simpler
05:02:08 <yitz> data MyNum = MyNum {value :: Int} deriving (Eq, Ord, Show)
05:02:17 <mstr> how do you define the comparison function if you use deriving?
05:02:34 <yitz> mstr: it inherits it automatically from Int
05:02:40 <BONUS> it's defined automatically based on the types of the fields
05:02:43 <mstr> no thanks, that's useless
05:02:55 <yitz> mstr: ok
05:02:56 <BONUS> if it has several fields, they're czeched from left to right
05:03:04 <BONUS> how is that useless
05:03:30 <Saizan> essentially, it'll give you the same instance as Cale has written above
05:03:31 <mstr> sorry, not interested in pasting the whole problem :)
05:03:56 <mstr> just had a problem with small part of the syntax :P
05:04:04 <Cale> http://sciencehack.com/videos/view/I_xh-bkiv_c -- tiny OM NOM NOM :)
05:04:31 <mstr> oh, it compiles. thx Cale
05:06:15 <yitz> BONUS: sometimes they are slovaked from left to right
05:06:37 <BONUS> hehe
05:07:13 <alexeevg> @src cast
05:07:14 <lambdabot> Source not found. You speak an infinite deal of nothing
05:07:25 <alexeevg> @src Data.Typeable.cast
05:07:26 <lambdabot> Source not found. Just try something else.
05:07:38 <yitz> @type asTypeOf
05:07:40 <lambdabot> forall a. a -> a -> a
05:09:19 <yitz> @type 3
05:09:20 <lambdabot> forall t. (Num t) => t
05:09:38 <yitz> @type 3 `asTypeOf` (log 1)
05:09:40 <lambdabot> forall t. (Floating t) => t
05:10:17 <Martijn> Heh, asTypeOf is just const
05:10:29 <yitz> Martijn: sshhh
05:11:50 <chrisdone> wow, the haskell mailing list is so active
05:12:03 <Martijn> Sorry
05:13:16 <yitz> chrisdone: you mean cafe?
05:14:27 <bastl> is anyone aware of tools or papers that use/analyse/transform syntax trees for common tasks (e.g. diff, refactoring, consistency check, bug finder) ? Everything that uses syntax trees as its core datastructure is welcome (beside obvious compilers ...)
05:16:09 <yitz> bastl: HLint
05:17:41 <pejo> bastl, Catch?
05:17:57 <yitz> (so far all works of ndm)
05:18:00 <dreixel> :t elem
05:18:02 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:18:37 <yitz> bastl: WASH, but that is very old. I think someone is working on a modern version of it though.
05:19:00 <bastl> im not focussed on haskell programs.
05:19:38 <yitz> bastl: mmm, how about the ffi tools that analyze haskell and produce C headers?
05:19:56 <daf> or the ones that analyze C headers and produce Haskell? :)
05:20:55 <bastl> yep. inputs other than haskell would be more interesting to me (e.g. java, c, xml)
05:20:56 <yitz> bastl: every IDE
05:21:24 <bastl> yitz: the only IDE i know that has a fairly good AST representation is eclipse ...
05:21:53 <yitz> bastl: emacs
05:22:09 <bastl> ah, the "e"-word :-/
05:22:42 <yitz> bastl: but you're right, I don't think too many emacs modes actually build an AST, they're just a bunch of hacks.
05:22:48 <lambdapants> hello.
05:22:48 <lambdapants> Can anyone give me an example of how to construct a Ptr so as to read a certain number of bytes from a handle using hGetBuf?
05:24:20 <ddvlad> hi, everyone. for those familiar with http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot , if i want to add mutable state to the bot (e.g. a list of channels), would changing ReaderT to StateT be a correct choice?
05:24:20 <bastl> yitz: too few tools really use the inherent structure of source code. diff is considering files as sequence of bytes. thats very old-school IMHO
05:24:35 <ddvlad> (i know i'll have to refactor some code)
05:24:36 <bastl> (and lines of course)
05:24:57 <lambdapants> ddvlad: StateT is often what I use when dealing with mutable state
05:25:59 <ddvlad> lambdapants: i see; i asked because i was concerned about being able to modify eg the connection handle, which should be read-only
05:26:37 <lilac> ddvlad: it might be nicer to seperate the read-only state (socket) from the read-write state (channels)
05:26:58 <lilac> (use ReaderT for one and StateT for the other, perhaps
05:27:13 <Cale> ddvlad: If it's over IO anyway, you can just use the ReaderT to carry around an IORef for you.
05:28:04 <ddvlad> Cale: i'll have to read into IORef
05:28:09 <Martijn> Yay! The sun is out, finally.
05:28:24 <ddvlad> lilac: i might be biting off more than i can chew with two transformers :-P
05:28:31 <Cale> ddvlad: Well, you can write operations which sort of hide the fact that the IORef is there.
05:29:28 <lambdapants> ah... mallocbytes is what I need to make a pointer...
05:29:43 <yitz> lambdapants: a little safer to use allocaBytes
05:29:54 <lambdapants> yitz: thankyou
05:30:55 <mux> if the buffer size is fixed, it's even better to have a newtype and make it an instance of Storable; then you can just use alloca
05:31:21 <yitz> lambdapants: allocaBytes n $ \ptr -> do ...
05:31:22 <ddvlad> Cale: so if i got this right, it'd be ReaderT (IORef Config) IO ? sorry, i'm quite new to monad transformers
05:31:39 <mux> it's also insanely cool to allocate memory without specifying the size of it :-P
05:31:44 <yitz> lambdapants: but then watch out for buffer overflow
05:31:45 <Cale> ddvlad: Well, you're already using something like ReaderT Bot IO ?
05:32:15 <Cale> ddvlad: Where Bot is the bot state?
05:32:20 <yitz> mux: yes, that is definitely the best, when it's possible.
05:32:41 <ddvlad> Cale: yes, s/Config/Bot/ in my previous line
05:32:46 <Cale> ddvlad: So you just add a field to the Bot datatype which holds an IORef.
05:33:20 <Cale> data Bot = Bot { socket :: Handle, channels :: IORef [String] }
05:33:22 <ddvlad> Cale: whoa. that just blew my mind with its simplicity. thanks for the suggestion
05:34:13 <pejo> bastl, continuing on the work of Neil Mitchell: Supero too. But it's not java or c.
05:35:45 <lambdapants> yitz/mux: what it is is I get an msn packet that looks like this: MSG Hotmail Hotmail x\r\n where x is the number of bytes I then have to read from the socket.  So I will have to specify the number of bytes I need, and use allocabytes.  Thankyou both.
05:37:16 <inbuninbu> newbie question: what should i look at if i want to pass partially-evaluated functions along behind-the-scenes as a monad?
05:38:15 <Martijn> inbuninbu: State?
05:39:13 <inbuninbu> Martijn: Thanks! *runs off to do more reading* Martijn++
05:40:42 <BONUS> also take a look at the Endo monoid, it might be your thing
05:40:45 <lepassive> I've this doubt, I really like Haskell, but I don't know how to get deeper
05:41:17 <BONUS> idk, i always somehow manage to find topics about haskell i don't know yet
05:41:22 <BONUS> the haskell wiki is good for that
05:41:30 <BONUS> and just reading haskell stuff and playing with it i guess
05:41:56 <lepassive> BONUS, you are the writer of Learn yourself a Haskell
05:42:40 <lilac> *learn you a haskell
05:42:48 <lilac> people always seem to want to correct the grammar ;-)
05:42:52 <yitz> *for great good
05:43:09 <lepassive> lilac, that's right I'm sorry
05:43:30 <lepassive> I just wanted to say it's super awesome. Thanks BONUS
05:43:34 <cizra> Martijn: Hi. I've got troubles getting Yogurt to compile. Help me in private?
05:43:38 <lilac> lepassive: no need to be sorry, just observing :D
05:43:43 <redditbot> happstack hits hackage!
05:46:16 <yitz> Cale: i noticed that \bot has not joined #haskell-in-depth yet
05:47:03 <BONUS> lepassive: : yes :)
05:47:13 <BONUS> haha thanks, im glad you like it
05:47:20 <yitz> it sounds like that channel is really another name for #haskell-overflow, with a new name so that people won't feel guilty about starting up new threads there
05:47:52 <yitz> is there any way to define channel aliases on freenode?
05:48:53 <yitz> lepassive: the Haskell wikibook is also a good place to look
05:50:44 <vincenz> Anyone know when the hac is this yaer, and where too?
05:50:45 <alexeevg> Data.Typeable.cast is implemented in terms of unsafeCoerce. I know little about dependent types, but is seems that cast can be implemented in some dependently-typed language without unsafe operations. Can anybody point me in the right direction?
05:50:50 <lepassive> yitz, I checked it before and YAHT, and of course learn you a Haskell .. the thing is I'm trying to 'learn by doing'
05:51:25 <yitz> lepassive: oh - looking for a project?
05:51:47 <yitz> lepassive: there are a lot of things to do around the haskell world
05:51:49 <lepassive> yeah simple but yet complete to learn from
05:51:57 <lilac> yitz: i thought -in-depth was more for not-so-newbie-friendly material
05:52:17 <yitz> lepassive: or you could just do project euler
05:52:17 <lilac> yitz: hence "no monad tutorials"
05:52:33 <yitz> lilac: is that a difference from overflow?
05:53:08 <lilac> *shrug* I thought I'd seen Cale take people to -overflow to teach basics
05:53:16 <lepassive> yitz, the problem is I'm still thinking in a pythonic way the code doesn't flow in my head -in haskell-
05:53:20 <yitz> lepassive: what have you been interested in in the past?
05:53:44 <yitz> lepassive: use generators in Python :)
05:54:22 <lepassive> yitz, I've been working on P2P applications, alots of XML parsing.
05:54:51 <yitz> lepassive: try some of the project euler problems - start with simple ones. then compare your solution with the ones on the wiki (don't peek first)
05:55:35 <yitz> lepassive: so there are a lot of p2p things missing from hackage. pick one, and write it!
05:56:06 <BONUS> there's a haskell solution posted also in every problem's thread
05:56:07 <yitz> lepassive: zooko, who works on darcs a lot, works for a p2p company
05:56:13 <BONUS> to which you get access once you solve it
05:56:26 <BONUS> anyway, euler really helped me when i was starting out, got me into the haskell groove
05:57:25 <ksf> learning how to parse xml with haskell is kinda pointless, if you've got an dtd it's fully automatic.
05:57:32 <yitz> lilac: ok, then it's different I guess.
05:57:35 <ksf> *haskell by parsing xml
05:57:43 <lepassive> yitz, That's the thing I don't feel like into haskell yet just learned a basics + finally got Monads.. so I'm trying to start writing simple apps
05:58:11 <lepassive> BONUS, euler is to mathy like I don't get enough math at college :P
05:58:21 <yitz> lepassive: sounds like you really are getting it
05:58:24 <BONUS> hehe, but it's the fun kind! :)
05:59:31 <ksf> I started off by prototyping a web-server
05:59:56 <ksf> ...the way in which it sucked told me what I still had to learn.
06:01:30 <Saizan> the exception type corresponding to error "foo" should be ErrorCall, right?
06:01:59 <SamB> isn't it obvious from the name ?
06:02:36 <ksf> lepassive, did someone point you to real world haskell, yet?
06:02:39 <ksf> @where rwh
06:02:40 <lambdabot> is http://www.realworldhaskell.org/blog/
06:03:07 * SamB hopes lepassive had the sense NOT to write a Monad tutorial on his blog
06:03:44 <lepassive> ksandstr, yes i did, but got stuck in chapter 10, 12, didn't fully get Parsec yet
06:04:10 <lepassive> SamB, the best way to understand Moands is to write your own tutorial right ? :D
06:04:23 <SamB> lepassive: actually no
06:05:12 <ksf> the best way to understand monads is to stop wondering what they are.
06:05:13 <lepassive> SamB, Actually there's no need for a new tutorial as http://ertes.de/articles/monads.html exists
06:05:59 * SamB wonders why lambdabot isn't telling the title of that page
06:06:38 <ksf> I heard she doesn't like web browsing and now refuses to do it.
06:07:42 <lepassive> she? now it get freaky
06:07:43 <SamB> she doesn't need to browse -- just send an HTTP GET request and extract the contents of the title element!
06:07:48 <Saizan> ?src IO fail
06:07:49 <lambdabot> fail s  = failIO s
06:08:05 <ksf> @vixen, lepassive doesn't believe you're a girl.
06:08:06 <lambdabot> do i seem  un-feminine to you?
06:08:23 <ksf> @vixen, well, to him.
06:08:23 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
06:08:53 <lepassive> hahaha very funny
06:09:07 <ksf> @vixen, I didn't ask you to date him. You're thinking waaay to much about that.
06:09:08 <lambdabot> what do you want to know about me?
06:09:54 <lepassive> are you in love with some other bot ? maybe sigmabot gammabot ?
06:09:59 <Martijn> @vixen I want to know the color of your eyes
06:09:59 <lambdabot> you're my type :)
06:10:06 <Martijn> oh la la
06:11:26 <ksf> @vixen, what is a monad?
06:11:27 <lambdabot> i dunno...
06:11:57 <lepassive> @vixen, do you like haskell?
06:11:58 <lambdabot> church is my favourite computer scientist.
06:12:29 <ksf> I think she learnt that one by hard to dig innocent geeks.
06:12:58 <osfameron> eeeek!  pornspam masquerading as haskell reddit
06:13:45 <SamB> osfameron: eh ?
06:14:06 <yitz> @vixen have you been posting pictures to reddit again?
06:14:06 <lambdabot> no pic, i'll get one soon
06:14:33 <lilac> @vixen what do you like about haskell?
06:14:33 <lambdabot> church is my favourite computer scientist.
06:14:35 <SamB> yitz: doesn't she look like a South Park character anyway ?
06:14:36 <yitz> osfameron: then report it as abuse
06:15:08 <osfameron> yitz: ah good point.  I closed the window, what with being in the office and all...
06:15:13 <yitz> he
06:15:34 <lepassive> @vixen, gtk2hs vs qtHaskell ?
06:15:35 <lambdabot> church is my favourite computer scientist.
06:15:55 <SamB> osfameron: which link was it ?
06:16:00 <lepassive> hmmmm looks like she does alot of win32
06:16:17 <yitz> SamB: someone posted the link here earlier
06:16:27 <osfameron> SamB: something about haskell and iteration
06:16:37 <osfameron> might have been on programming reddit
06:17:07 <yitz> osfameron: a more likely target for such spam
06:17:19 <SamB> yes, it is
06:17:49 <lepassive> I've to go. nice to meet you guys
06:18:05 <yitz> lepassive: drop by again
06:18:06 <SamB> oh, someone posted that "why LLVM probably won't replace C--" article there?
06:18:17 <SamB> just an hour ago ?
06:18:44 * SamB wonders if he can mark that on analytics somehow
06:18:47 <yitz> SamB: that's an old discussion
06:18:59 <ski_> geezusfreeek : afternoon
06:19:26 <dolio> Seriously. Like 2 weeks ago.
06:19:30 <dolio> That's practically the dark ages.
06:19:34 <SamB> dolio: the post is old, yes
06:19:40 <pumpkin> @users
06:19:41 <lambdabot> Maximum users seen in #haskell: 659, currently: 658 (99.8%), active: 18 (2.7%)
06:20:09 <SamB> but someone posted it on programming.reddit.com an hour ago. johnnowak, in fact.
06:20:35 <tromp_> > ()
06:20:37 <lambdabot>   ()
06:22:39 <jkff> Well, let's give it another try. Anyone know what is the fastest regex package? PCRE or does there exist anything faster?
06:22:48 * SamB wonders if it would be possible to get analytics going on trac ...
06:23:59 <yitz> jkff: ask on cafe, hopefull chrisk will answer
06:24:06 <yitz> *hopefully
06:24:49 <jkff> yitz: Thanks, I will
06:26:15 <yitz> hmm. chrisdone /= chris k.?
06:26:34 <jkff> @seen chrisdone
06:26:34 <lambdabot> chrisdone is in #haskell. I last heard chrisdone speak 1h 14m 44s ago.
06:31:14 <true\false> Simple thing, what is the reason for using <- and = for different things?
06:31:20 <true\false> Is one simply for IO/impure?
06:32:16 <Cale> true\false: Well... it's more complicated than that.
06:32:18 <cizra> true\false: = is not really a value assignment
06:32:31 <Cale> true\false: = means that you're defining something to be equal to something else
06:32:49 <Cale> So if you have an IO action, like, say, getLine, and you write foo = getLine
06:32:57 <Cale> It means that foo is the same action as getLine.
06:33:09 <Cale> It doesn't mean "run getLine and call its result foo"
06:33:27 <jkff> Oh. Here we behold the perils of learning do-notation before understanding what a monad is!
06:33:36 <geezusfreeek> ski_, morning
06:33:38 <Cale> It's not a problem :)
06:34:02 <Cale> Whereas in do-notation, when you write foo <- getLine, that means to run getLine, and name its result foo.
06:34:04 <ski_> geezusfreeek : you were earlier mentioning something about `ContT' and cooperative coroutines ?
06:34:06 <true\false> It means 'foo equals getLine'? Such as that, when you use foo, getLine is evaluated?
06:34:18 <Cale> true\false: Such that they represent the same action.
06:34:25 <geezusfreeek> ski_, yeah, i'm working on a monad transformer that provides fibers
06:34:47 <Cale> getLine :: IO String is a value which represents some stuff which can be done in order to produce a String.
06:34:47 <ski_> geezusfreeek : `fibers' meaning ?
06:34:55 <inbuninbu> newbie question: ok, there is just something i'm not getting about monads. this is currently what i'm after: i want to read a string, and put data from the string into a constructor. i want to put the data in the constructor while i'm keeping the remainder of the string left over, and so on... is this possible?
06:35:05 <Cale> (in particular, it represents the action of getting a line of text from the user)
06:35:21 <true\false> I think I follow
06:35:22 <geezusfreeek> ski_, fibers being the word i will use from now on to refer to cooperative threads ;)
06:35:28 <Cale> So foo = getLine would define foo to be the same action.
06:35:34 <Cale> It wouldn't cause the action to occur.
06:35:47 <true\false> So ... foo = 2 + 1, is the action of adding 2 to 1?
06:35:50 <ski_> inbuninbu : yes
06:35:58 <Cale> true\false: mmm... no
06:36:01 <true\false> Sorry, then foo is the action of adding 2 to 1?
06:36:05 <ski_> true\false : no `2 + 1' isn't an action, it's a number
06:36:12 <Cale> true\false: It's not an action at all. It's just a number.
06:36:22 <BONUS> 2 + 1 means the same thing as 3
06:36:33 <ski_> true\false : an action is a kind of value, just like a number, or a string, or a boolean, or a function
06:36:37 <BONUS> and because values don't change in haskell, both those expressions are interchangeable
06:36:46 <geezusfreeek> ski_, but yeah, two nights ago i (thought) i had something working, and all was well with the world, but last night i either introduced or discovered a bug that causes some continuations to be scheduled more than once, and i haven't yet figured that one out :(
06:36:47 <jkff> true\false: "do a <- b ; f a"  means literally "b >>= \a -> f a". In case of the IO monad, >>= means just sequencing of side effects and it has type (IO a) -> (a -> IO b) -> (IO b). In case of other monads, it means completely different things (but has essentially the same type). >>= takes an action and a parameterized action, and passes the result of the first action as a parameter to the second, abstracting you from what actually 'result' means and 
06:37:03 <ski_> (true\false : specifically, to each monad there's a class of actions belonging to that monad)
06:37:16 <BONUS> inbunibu: you can just read the whole input into a string and then cut that string up how you want
06:37:18 <ski_> geezusfreeek : ok
06:37:20 <true\false> I've not done monads just yet
06:37:33 <inbuninbu> ski_: thanks. so what should the type of my function be?
06:37:40 <ski_> geezusfreeek : i have some old code lying around that istr uses `ContT' for coroutines ..
06:37:40 <BONUS> because of IO laziness, the string will be read from input only when needed, and only the parts that are needed
06:37:41 <Cale> I'm not sure that monads are really going to clear up this picture...
06:37:52 <ski_> inbuninbu : which function ?
06:37:57 <jkff> In case of the List monad, for example, the 'result' of a List-action "List a" is a list of values of type 'a', and the act of passing the result of a "List a" action to "a -> List b" consists in threading the results of "List a" to "a -> List b" and concatenating the results
06:38:02 <Cale> It's perhaps simpler to just understand the IO monad on its own first.
06:38:12 <jkff> Cale: This is precisely where I disagree :)
06:38:24 <BONUS> i don't think you need to know monads to understand I/O
06:38:28 <true\false> Perhaps I should just keep working through RWH and see if this sinks in.
06:38:30 <geezusfreeek> ski_, i could possibly be interested in seeing that. unfortunately, i have to leave soon
06:38:39 <Cale> The hard part has nothing to do with monads, or the fact that IO happens to be a monad.
06:38:42 <inbuninbu> ski_: the function to parse through the string, to be written by me
06:38:55 <Cale> The hard part is that IO actions are values and evaluating those values doesn't cause the actions to occur.
06:39:15 <inbuninbu> basically i have several functions that will pull off the top of some strings and do things with them, they will pull off different amounts
06:39:17 <ski_> inbuninbu : possibly `parseFoo :: String -> Maybe (Foo,String)'
06:39:19 <Cale> (this is what's essentially different about IO in Haskell from imperative languages)
06:39:22 <jkff> To my mind the hard part is that in IO, '<-' is too tempting to be interpreted as assignment
06:39:34 <jkff> If one knew other monads, one wouldn't have such an impression
06:40:08 <Cale> Right, it's important to realise that in a do-block, when you have v <- x, it means to run the action x, and name its result v, and NOT run the action x and store its result in the location named v.
06:40:15 <inbuninbu> so i was thinking i could, for each datatype i have, have a parsing function that would create that datatype from a string by calling the right functions in order, and pass the remainder back
06:40:35 <BONUS> yeah i think it's important to understand that IO a doesn't mean "a but gotten from the IO", but it means an IO action
06:40:39 <Cale> But that's something which can be understood without monads.
06:40:53 <BONUS> the concept of actions and when they're performed vs. when they're evaluated
06:41:47 <inbuninbu> ski_: thanks, that's sort of what i'm thinking. but in my parse function, the constructor won't be complete until i finish a series of reads on the string
06:42:08 <jkff> true\false: Are you familiar with Java, for example?
06:42:16 <true\false> C#, so near enough Java
06:42:48 <Cale> true\false: Did my comments help at all? I have a very short intro here: http://www.haskell.org/haskellwiki/Introduction_to_IO
06:42:57 <jkff> OK, then think that getLine has type "public static IOAction<String> getLine() {return delegate { ...perform io here... }}"
06:43:16 <jkff> And "do a <- getLine; f a" means "getLine().bind(delegate(String a) {return f(a);})"
06:43:55 <lilac> @losers
06:43:56 <lambdabot> Maximum users seen in #haskell: 669, currently: 669 (100.0%), active: 23 (3.4%)
06:44:00 <jkff> However, you don't know how 'bind' is implemented. The point is that executing getLine() does not yield a String, it yields something which can be bound to a computation that uses a String!
06:44:18 <ski_> geezusfreeek : if you care to look for it, it's at <http://www.mdstud.chalmers.se/~md9slj/code/afp_lab1_v4.tar.gz>. the coroutine things are in `Snail'
06:44:31 <true\false> Hrm..
06:44:45 * Cale thinks the translation into C#/Java is confusing :)
06:45:16 <true\false> Cale: Also I'll look at that in a bit, think I need to rest my eyes from the screen after 4hours :)
06:45:20 <true\false> Thanks for the input
06:45:38 <Cale> true\false: Running any Haskell program is basically broken up into two interleaved processes
06:45:54 <Cale> true\false: One is Evaluation which reduces expressions to values.
06:46:07 <ski_> inbuninbu : yes, if `Foo' consists of a `Bar' and a `Baz', then `parseFoo' will call `parseBar' and `parseBaz'
06:46:18 <geezusfreeek> ski_, thanks a lot!
06:46:19 <Cale> true\false: The other is what I call execution, which carries out the instructions specified by IO actions.
06:46:44 <ski_> (geezusfreeek : if you have any question, i'd be happy to try to answer them)
06:46:44 <BONUS> also check out the IO section on learnyouahaskell.com :) i think i managed to explain it quite plainly there
06:47:10 <Cale> true\false: When you write a compiled Haskell program, you define an IO action called main. This expression is evaluated into an IO action, and then executed.
06:47:34 <Cale> true\false: In turn, its execution might require further expressions to be evaluated.
06:47:43 <BONUS> basically main can be only one I/O action. what you actually do with the "do" syntax is you glue several I/O actions together into one, which you then call main
06:47:53 <inbuninbu> ski_: thanks, i think my brain is not bleeding quite so much now. ski_++
06:48:08 <ski_> inbuninbu : so after `parseBar' has been called, you've got the rest of the string, so you can pass it to `parseBaz', and after that, you can "complete" the constructor of `Foo'
06:48:16 <true\false> Ahh, that I follow..
06:48:48 <true\false> BONUS: And I'll make sure to take a look at lyh for a few things I'm spotty on :)
06:48:53 <ski_> (inbuninbu : of course, there may still be more data to parse, since this `Foo' might be part of something larger to pass, so we return both the `Foo' and the rest of the string)
06:48:55 <BONUS> :]
06:49:27 <inbuninbu> ski_: i understand that in principle. i guess i'm having syntax issues. i don't understand how i pass it transparently
06:49:32 <ski_> (inbuninbu : the `Maybe' would be in case of parse errors .. one could alternatively return a list of possible parses, this is sometimes useful)
06:49:36 <true\false> Or maybe just read it from start to finish and look at RWH later.. Confusing book at times :
06:49:53 <ski_> inbuninbu : do you have any current code you have trouble with ?
06:50:03 <Martijn> Is it possible to write children :: Traversable f => f a -> [a] ?
06:50:15 <inbuninbu> i just deleted it all because it wouldn't compile. i'll put something up
06:51:25 <geezusfreeek> ski_, this code seems to make sense to me. thanks again! and on this note, i must leave for work
06:53:07 <ski_> geezusfreeek : glad you're happy :)
06:53:26 <mm_freak> what is an intuitive name for the 'const' function?  it feels incorrect to call it "the constant function"
06:53:39 <mm_freak> probably the "constant combinator"
06:55:48 <ziman> the K combinator :)
06:55:56 <jkff> Martijn: maybe, foldMap (\a -> [a]) ?
06:56:11 <ski_> @tell geezusfreeek before i forget it, here's two pics drawn by the program in question : <http://www.mdstud.chalmers.se/~md9slj/BellFlower.png> , <http://www.mdstud.chalmers.se/~md9slj/Tree.png>
06:56:11 <lambdabot> Consider it noted.
06:56:13 <jkff> (I'm looking at Data.Foldable for the first time in my life, so I may be mistaken)
06:56:23 <jkff> :t foldMap
06:56:24 <lambdabot> Not in scope: `foldMap'
06:56:25 <ski_> lambdabot: @vixen you're back!
06:56:26 <lambdabot> Hmmm
06:56:28 <jkff> > :t foldMap
06:56:29 <inbuninbu> ski_: this is what i'm messing around with. it should be obvious i'm not sure how this is supposed to work
06:56:29 <lambdabot>   <no location info>: parse error on input `:'
06:56:31 <Martijn> :t Data.Foldable.toList
06:56:32 <jkff> Ahh.
06:56:33 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
06:56:33 <mm_freak> ziman: that's probably only useful to lambda geeks ;)
06:56:39 <inbuninbu> Main = do
06:56:39 <inbuninbu>         s <- readBinaryFile "test.bin"
06:56:40 <inbuninbu>         case uint8 s of
06:56:40 <inbuninbu>                 Nothing -> Nothing
06:56:40 <inbuninbu>                 Just s1 -> uint8 (snd s1)
06:56:40 <inbuninbu>         return ()
06:56:51 <Martijn> jkff: found it :-)
06:57:08 <ski_> inbuninbu : i think you want `main'
06:57:22 <Martijn> @pl \x -> x : f x
06:57:23 <lambdabot> ap (:) f
06:57:27 * cizra prods Martijn 
06:57:32 <inbuninbu> ski_: ah yeah, i know. truncated it when pasting, and i capitalized it then
06:57:36 <Martijn> cizra: hi :_)
06:57:40 <inbuninbu> ski_: that isn't my problem
06:58:00 <drhodes> 20 :: Float  -- is there any going back to thing known as 20 after clamping the ::Float on it?
06:58:40 <ski_> inbuninbu : instead of `Just s1 -> uint8 (snd s1)', why not use pattern-matching like `Just (n,s1) -> uint8 s1' ?
06:59:39 <inbuninbu> ski_: uint8 is of type [cha:22r] -> Maybe (Int,[Char])
06:59:40 <ski_> inbuninbu : also, having `Nothing' and `uint8 s1' in the branches will give an error because the branches insists to have type `IO blah' for some type `blah'
07:00:29 <inbuninbu> ski_: yeah, that seems to me my main problem. but i don't understand how to fix it
07:00:36 <ski_> inbuninbu : you might, e.g., replace the second `Nothing' with `putStrLn "Can't parse first unit8"'
07:01:21 <ski_> inbuninbu : generally, if you have a `case ...' directly as a command in a `do'-construct, you want to open a new `do' in each branch
07:01:50 <ski_> however, if there's only one command after a `do', one may omit the `do' keyword
07:02:16 <ski_> for the second case, you need to decide what to do with the result of `uint8 s1'
07:02:44 <ski_> since it's not an `IO'-action, you can't put that as the whole branch, since the whole branch must be an `IO'-action
07:02:57 <ski_> maybe you want to `print' it, for now ?
07:03:22 <ski_> or maybe you want to open a new `case' to check whether the parse succeeded, and decide what to do in either case
07:03:45 <roderyk> does Debug.Trace.trace output to stderror? I can't seem to grep the output...
07:03:54 <Cale> roderyk: iirc, yes
07:04:02 <inbuninbu> ski_: thanks for your explanation, i'm starting to understand (a little)
07:04:30 <liwp> inbuninbu: try using the maybe function instead of the case. It might make the code a bit cleaner
07:04:33 <liwp> :t maybe
07:04:34 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:04:40 <ski_> in the latter case, i'd probably write something like
07:04:43 <ski_> main = do
07:04:49 <ski_>   s <- readBinaryFile "test.bin"
07:05:01 <ski_>   case uint8 s of
07:05:13 <paolino> @users
07:05:13 <lambdabot> Maximum users seen in #haskell: 671, currently: 669 (99.7%), active: 25 (3.7%)
07:05:20 <roderyk> shouldn't ./foo 2>&1 | grep bar  work in grepping a trace output?
07:05:21 <ski_>     Nothing -> putStrLn "Can't parse first unit8"
07:05:29 <ski_>     Just (n0,s1) -> do
07:05:31 <inbuninbu> liwp: thanks for the tip
07:05:40 <ski_>       case uint8 n1 of
07:05:45 <ski_>         Nothing -> ...
07:05:46 <beatbox> is it possibel to integrate mathematica or matlab code in normal code or are those just prototyping tools? can you write an app in mathematica? does it have annoying licenses?
07:05:54 <ski_>         Just (n1,s2) -> do
07:05:59 <ski_>           ...
07:06:01 <anakreon> I am trying to figure out how hxt works, but seems to be a little bit heavy for me.
07:06:06 <liwp> something like: maybe (uint8 s) (\(_, s1) -> uint8 s1) Nothing
07:06:36 <inbuninbu> ski_: thanks, i think i've got a handle on it. seems that the nest will go on deep though, but i think i saw a section on that problem in my haskell book
07:06:39 <ski_> inbuninbu : sorry, this because a little cluttered .. would you prefer me to paste it ? (in which case you should probably paste your current code first)
07:06:46 <liwp> i.e. if (uint8 s) is Just x, apply the given function (\(_,s1) -> uint8 s1), otherwise return the default value (Nothing)
07:07:02 <anakreon> The use case is as follow: In a html document there is an ul, with li elements each having two links.
07:07:14 <inbuninbu> ski_: actually i've got it working now. now i just need to clean it up and make it less redudant
07:07:17 <pejo> beatbox, the GpH-people have some project on making computer algebra systems working on grids. I think they basically do the coordination in Haskell and have matlab/maple/.. do the calculations.
07:07:38 <anakreon> The problem is the >>> operator. I can't figure out the kind of the result I get. Is it a list-like structure?
07:07:42 <byorgey> beatbox: seeing as it is proprietary and expensive, it probably has annoying licenses. =)
07:07:47 <byorgey> beatbox: but see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mathlink
07:07:50 <inbuninbu> ski_++ ski_++ liwp++
07:07:56 <byorgey> and also http://hackage.haskell.org/cgi-bin/hackage-scripts/package/matlab
07:07:56 <ski_> liwp : my opinion is that it will be easier at first to get a handle of `case' (not having things so much out of order)
07:08:15 <liwp> yeah, maybe
07:08:32 <paolino> :t (>>>)
07:08:33 <ski_> inbuninbu : when you've got it working, you could let us have a look at it
07:08:34 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
07:08:39 <liwp> it's just annoying writing Nothing -> Nothing all the time...
07:08:40 <byorgey> anakreon: what are you trying to accomplish?  you just want to extract some info from an html document?
07:08:43 <Cale> anakreon: If you're referring to the arrows used in HXT... sort of. It composes two list-processing functions.
07:08:50 <byorgey> anakreon: or are you trying to transform it in some way?
07:09:12 <anakreon> Just extract info. :t (>>>) is not that usefull to me
07:09:22 <ski_> inbuninbu : also, there's an alternative approach to doing the same thing which we could should .. at least just for getting an idea of what is possible, even if you don't get the details at this point
07:09:40 <inbuninbu> ski_: this is what i have at the moment:
07:09:42 <inbuninbu> main = do
07:09:42 <inbuninbu>         s <- readBinaryFile "test.bin"
07:09:42 <inbuninbu>         case uint8 s of
07:09:42 <inbuninbu>                 Nothing -> putStrLn "error"
07:09:43 <inbuninbu>                 Just (n,s1) -> putStrLn $ show $ uint8 s1
07:09:43 <inbuninbu>         return ()
07:09:49 <Cale> anakreon: It might become more useful once you look at the types of the things you're applying >>> to.
07:09:52 <byorgey> anakreon: if you just want to extract some info, you might consider using tagsoup instead of hxt, much more lightweight
07:09:56 <ski_> @src print
07:09:56 <lambdabot> print x = putStrLn (show x)
07:10:06 <ski_> inbuninbu : you might use `print' there instead
07:10:12 <inbuninbu> ski_: and i'd love to see a better way of doing it
07:10:22 <anakreon> tagsoup is easier to use and understand?
07:10:26 <inbuninbu> ski_: ok, thanks
07:10:36 <byorgey> anakreon: definitely
07:10:46 <paolino> anakreon: there are examples on the wiki
07:11:11 <Cale> anakreon: XML processing filters are things which have possibly many inputs and many results. For example, one might take a bunch of HTML document trees, and look for all the ul elements in each.
07:11:16 <byorgey> anakreon: http://www-users.cs.york.ac.uk/~ndm/tagsoup/
07:11:17 <ski_> sShintah : shantih! shantih! shantih!
07:11:22 <byorgey> there's even a nice tutorial for it =)
07:11:26 <Cale> anakreon: >>> chains these processing filters together
07:12:02 <lilac> maybe (putStrLn "error") (\(n, s1) -> putStrLn . show $ uint8 s1) <$> readBinaryFile "test.bin"
07:12:03 <Cale> anakreon: So you might want all the li elements in each of the ul elements, and you'd use something like  findULs >>> findLIs
07:12:13 <anakreon> Ok. I'll check tagsoup. I wonder if  li >>> getChildren >>> aTag "a" is a list.
07:12:20 <lilac> inbuninbu: ^^ how i'd write that
07:12:29 <Cale> anakreon: It's a list processor.
07:13:05 <anakreon> I want to call a function on the first link and an other on the second. How could I accomplish this?
07:13:39 <ski_> inbuninbu : btw, one suggestion : when you get a little more code, you might want to put the meat of the parsing code in separate (non-`IO') functions, and let `main' call this with the file string and handle the output
07:13:59 <Cale> anakreon: Use listA to collect the results
07:14:37 <ski_> @index listA
07:14:38 <lambdabot> bzzt
07:14:48 <Cale> listA :: a b c -> a b [c]
07:14:59 <Cale> listA :: ArrowList a => a b c -> a b [c]
07:15:00 <Cale> rather
07:15:00 <lilac> putStrLn (maybe "error" (\(n, s1) -> show $ uint8 s1) =<< readBinaryFile "test.bin"
07:15:11 <anakreon> Thanks Cale. Perhaps this will do.
07:15:12 <inbuninbu> ski_: thanks, i understand; but for now i'm just figuring out how to do the smallest parts what i'm trying to do
07:15:24 <Cale> So, for instance, if you add ">>> listA" to the end of the chain there
07:15:41 <ski_> inbuninbu : yes, that's fine
07:15:44 <Cale> Your processor will have a single result, which will be a list of all the results the old one produced.
07:15:56 <Cale> This will let you act on each of the elements of that list separately.
07:17:04 <Cale> (via arr, say)
07:19:16 <ski_> @arr
07:19:17 <lambdabot> Swab the deck!
07:20:03 * ski_ wonders what `ArrowList' signifies
07:20:32 <ski_> some kind of nondeterminism reification ?
07:21:54 <BONUS> is ArrowList like using the kleisli arrow with the list monad or what
07:22:56 <BMeph> Cale: HXT? :)
07:23:16 <Cale> BMeph: It's an XML processing library.
07:23:33 <byorgey> BONUS: yes.
07:23:50 <asgaroth> Is there some language pragma for proc notation with arrows that I can put in a source file to avoid having to use ghci -farrows?
07:24:11 <chessguy_work> @type getChar >>= \x -> getChar
07:24:12 <z0d> Hello
07:24:12 <lambdabot> IO Char
07:24:13 <lilac> asgaroth: -XArrows i think
07:24:24 <lilac> asgaroth: so {-# LANGUAGE Arrows #-}
07:24:33 <SamB> lilac: should be right
07:24:42 <SamB> it's listed in ghc --supported-languages
07:24:44 <BMeph> Cale: Right, Haskell has a lot of them. I was asking if HXT was the one that ArrowList is in - it's been a while since I've used it.
07:24:48 <asgaroth> lilac: Thanks
07:24:52 <byorgey> hi z0d
07:24:56 <Cale> BMeph: yeah
07:24:57 <SamB> (which really sounds wrong, if you think about it ;-)
07:25:01 <asgaroth> SamB: Ah, thanks I'll consult that before asking next time
07:25:24 <SamB> asgaroth: I only found out about it the other day
07:25:31 <byorgey> SamB: hehe, yeah, I always expect it to print "Haskell" ;)
07:25:39 * lilac was looking through the man page for that option but it wasn't listed :(
07:25:43 <ehird> So, does anyone know if it's possible to make GHC generate completely non-consing code? Using only primitive #-types and ! -patternseverywhere
07:25:49 <SamB> before I'd been looking at Language.Haskell.Extensions either in haddock or GHCi
07:25:54 <ski_> apparently at <http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/Control-Arrow-ArrowList.html>
07:26:14 <SamB> ehird: well, it's not wise to do that yet
07:26:23 <ehird> SamB: It's a good thing i'm not wise.
07:26:24 <ehird> :)
07:26:26 <lilac> "ghc --supported-languages | head -n 1" prints "CPP" for me ;-)
07:26:41 <ehird> SamB: So, does that mean it's _possible_?
07:26:43 <lilac> it's secretly a C++ compiler
07:26:52 <SamB> ehird: not for the WHOLE program
07:26:54 * ski_ arghs at `arr2', et.c. ..
07:27:21 <ehird> SamB: Right, well, specifically, I'm trying to implement malloc in Haskell, so that the program I uses uses it to allocate. so the rest can use malloc, but this part very obviously can't.
07:27:27 <ehird> So, is it possible? :D
07:27:53 <ski_> what the bleep does `arr2' have to do with the idea that `ArrowList' is meant to encapsulate ?!
07:28:04 <lilac> @hoogle malloc
07:28:05 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
07:28:05 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
07:28:05 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
07:28:15 <ehird> lilac: ok, that's not relevant though
07:28:26 <ehird> I'm trying to implement my own malloc, in Haskell, so the ghc rts uses it.
07:28:32 <ehird> Of course, this malloc can't cons for obvious reasons.
07:29:33 <lilac> @hoogle sbrk
07:29:33 <lambdabot> No results found
07:29:36 <lilac> @hoogle mmap
07:29:37 <lambdabot> package mmap
07:29:37 <lambdabot> package bytestring-mmap
07:29:49 <ehird> lilac: ok, and? :)
07:30:08 <anakreon> listA returns  IOSLA (XIOState s) b [XmlTree]. I'm trying to get the tree with function:
07:30:13 <lilac> ehird: well, you need some way to get memory from the system. the standard way an allocator does that is via the sbrk and mmap syscalls
07:30:24 <anakreon>  getTree IOSLA (XIOState _) _ tree = tree
07:30:28 <ehird> lilac: Ahaha... well... I'm afraid there aren't any syscalls where I'm going
07:30:56 <lilac> ehird: fair enough. it also doesn't answer your question of, how do you write this so it compiles to non-allocating code :)
07:31:07 <ehird> mm :-)
07:31:09 <anakreon> This does not compile. The error is: Constructor `IOSLA' should have 1 argument, but has been given 0
07:31:25 <lilac> ehird: haskell is not the droids you are looking for here.
07:31:46 <ehird> lilac: I refuse to step into C-land. :-D
07:31:58 <lilac> ehird: although a haskell DSL which produces assembly would be possible...
07:32:30 <doserj> anakreon: you need parantheses: getTree (IOSLA (XIOState _) _ tree) = tree
07:32:34 <ehird> lilac: I don't wanna write malloc in assembly :)
07:33:05 <lilac> ehird: your DSL could still be high-level
07:33:44 <lilac> @ubers
07:33:45 <lambdabot> Maximum users seen in #haskell: 678, currently: 676 (99.7%), active: 25 (3.7%)
07:34:04 <ehird> I'm sure it must be _possible_... e.g.
07:34:05 <ehird> intID :: Int# -> Int#
07:34:06 <ehird> intID !a = a
07:34:10 <ehird> I don't even see an oppertunity to cons there
07:35:07 <idnar> @type arr2
07:35:08 <lambdabot> Not in scope: `arr2'
07:35:14 <idnar> @hoogle arr2
07:35:15 <lambdabot> No results found
07:35:17 <ski_> idnar : see the link above
07:35:27 <idnar> oh there
07:35:43 <pitekus> I'm trying to use type families. I getting a  Conflicting family instance declarations with the following code: http://paste.lisp.org/display/74920 Any idea how i can fix this?
07:35:50 <ski_> (read and weep)
07:36:11 <idnar> uhm
07:36:12 <lilac> ehird: presumably you want "malloc :: Int -> IO (Ptr a)"?
07:36:14 <idnar> that is one insanely huge typeclass
07:36:19 <lilac> ehird: where are you going to store your state?
07:36:30 <mm_freak> hmm
07:36:39 <mm_freak> somehow (>>=) in IO confuses me
07:36:49 <ehird> lilac: 1. I'm exposing this to GHC via "foreign export ccall" 2. I'm not sure about that.
07:36:54 <mm_freak> return undefined >> return 3 = return 3
07:37:06 <mm_freak> but getChar >> return 3 reads from the terminal
07:37:11 <mm_freak> why?
07:37:22 <anakreon> doserj: Parenthesis were missing. Now I get an error stating I have provided 3 parameters instead of 1.
07:37:27 <ski_>   return x >>= f  =  f x
07:37:37 <lilac> mm_freak: undefined >> return 3 = undefined, though
07:37:41 <anakreon> doserj: Doesn't type IOSLA (XIOState s) b [XmlTree] need 3 parameters?
07:37:50 <tromp_> because its an IO action
07:37:56 <doserj> anakreon: Look at the type definition of IOSLA.
07:37:58 <ski_> mm_freak : so `return undefined >> return 3  =  return undefined >>= \_ -> return 3  =  (\_ -> return 3) undefined  = return 3'
07:37:59 <mm_freak> lilac: is that IO-specific?
07:38:11 <ski_> mm_freak : no, monad-specific
07:38:16 <doserj> anakreon: the *type* IOSLA needs 3 type parameters
07:38:28 <lilac> mm_freak: true of every monad except the unit monad i think
07:38:30 <mm_freak> it doesn't happen for the unit monad
07:38:35 <doserj> anakreon: but the *data constructor* IOSLA needs only one argument
07:39:00 <mm_freak> hmm
07:39:04 <BMeph>  anakreon: you need parantheses: getTree (IOSLA (XIOState _)) _ tree = tree
07:39:18 <doserj> BMeph: no :)
07:39:44 <doserj> newtype IOSLA s a b = IOSLA { runIOSLA :: s -> a -> IO (s, [b]) }
07:40:13 <ski_> anakreon : mayhaps it might be deconfusing for you to name the type constructor and the data constructor differently ?
07:40:30 <ski_>   newtype IOSLA s a b = MkIOSLA { runIOSLA :: s -> a -> IO (s, [b]) }
07:40:31 <ski_> e.g.
07:41:19 <doserj> IOSLA is defined in HXT
07:41:31 <ski_> oh, i see
07:41:49 <lilac> is that the kleisli arrow of 'newtype IOSLM s a = MkIOSLM { runIOSLM :: s -> IO (s, [a]) }'?
07:42:13 <ski_> lilac : yes
07:42:25 <lilac> ... which is ListT (StateT s) IO, I think
07:42:35 <mm_freak> so getChar >> return 3 depends on getChar, but not on its result
07:42:37 <ski_> (ignoring the small difference in the currying)
07:43:07 <anakreon> doserj: Yes. BMeph: Unfortunatly your suggestion does not compile.
07:43:09 <lilac> mm_freak: perhaps thinking of IO as State RealWorld# will help you?
07:43:10 <anakreon>  I need to read more examples from xht.
07:43:17 <lilac> @src IO
07:43:18 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:43:45 <mopped> Instead of a large if statement, is there a terse way to if (x == "Bob") || (x == "Jim") || (x == "Phil")? Perhaps if x `elem` ["Phil", "Jim" "Bob"]?
07:44:28 <ski_> mopped : yes
07:44:50 <roconnor> @wiki IO_Semantics
07:44:50 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
07:44:56 <mm_freak> lilac: that's not really the problem…  i always thought that IO specifically forces evaluation, but it doesn't
07:45:24 <lilac> mm_freak: nor does State, in exactly the same way.
07:45:28 <ski_> running an `IO'-action will force the effects of the action
07:45:39 <ski_> (not the result value of the action)
07:45:40 <lilac> ski_: not 'force' in the sense of evaluation
07:45:56 <ski_> lilac : hence "force the effects"
07:46:01 <lilac> running an IO action will cause its effect to happen.
07:46:09 <lilac> this is unrelated to forcing of thunks
07:46:14 <ski_> *nod*
07:47:39 <ehird> Hmm, it occurs to me that maybe I could store state in malloc using some reallyUnsafePointerFun#
07:48:18 <leimy> I'm really wondering if it makes sense to try to write Haskell code such that an interactive text program just uses interact and Writer instead of IO prompting.
07:48:44 <leimy> It certainly makes the program seemingly more pure, but the same things have to happen to make the program go, so what's the difference? :-)
07:48:56 <lilac> leimy: sounds like continuation-based IO?
07:49:01 <leimy> Kind of
07:49:03 <leimy> :t interact
07:49:05 <lambdabot> (String -> String) -> IO ()
07:49:13 <mopped> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1206 Why do I get Prelude.read: no parse? (and what does that error mean)
07:49:18 <leimy> Basically main calls interact, and you give it the String -> String function
07:49:37 <leimy> well if you use (Writer String) you can do linewise output based on input.
07:49:56 <ehird> @src seq
07:49:56 <lambdabot> Source not found. That's something I cannot allow to happen.
07:49:56 <leimy> and the IO is sort of "hidden away"
07:50:03 <ski_> leimy : i think one of the main questions is whether it would compose better ..
07:50:20 <leimy> Well it's easier to test pure functions right? :-)
07:50:26 <ski_> depends
07:50:27 <leimy> in that they can be automated
07:50:34 <leimy> and it also separates WHERE of IO
07:50:39 <leimy> like it doesn't have to be stdin
07:50:39 <lilac> leimy: with a continuation-based formulation, you write f :: String -> (a -> (String -> String)) -> (String -> String), and get reasonable composition
07:50:42 <leimy> it could be a socket.
07:51:09 <doserj> mopped: read tries to parse the input as a string, i.e., it expects it to start with "
07:51:17 <lilac> maybe flipping those arguments makes it nicer?
07:51:25 <doserj> mopped: just delete the read
07:51:28 <leimy> lilac: I'm not sure I understand that :-)
07:51:32 <mopped> ok
07:51:38 <Gracenotes> > show "name"
07:51:39 <lambdabot>   "\"name\""
07:51:46 <leimy> I mean, I use something like that in some code I use at work
07:51:48 <ski_> lilac : yes, and then you can invent `Cont (String -> String)' and call it `MyIO'
07:51:50 <Gracenotes> see, there's a set of quotes added. The reading doesn't have that :)
07:51:53 <leimy> but it's done with data maps.
07:52:17 <lilac> type Interactor = String -> String; type InteractorCont a = a -> Interactor; f :: InteractorCont a -> InteractorCont String
07:52:24 <ehird> @hoogle Word# -> Word# -> ()
07:52:25 <lambdabot> Control.Concurrent.Chan unGetChan :: Chan a -> a -> IO ()
07:52:25 <lambdabot> Control.Concurrent.Chan writeChan :: Chan a -> a -> IO ()
07:52:25 <lambdabot> Data.IORef writeIORef :: IORef a -> a -> IO ()
07:52:32 <ehird> <_<
07:52:44 <lilac> (f is approx :: String -> IO a)
07:53:00 <ski_>   type InteractorArrow a b = InteractorCont b -> InteractorCont a
07:53:07 <ski_>   f :: InteractorArrow String a
07:53:13 <lilac> much nicer :)
07:53:33 <leimy> What I like about interact is all the input is a single string
07:53:35 <leimy> you can "lines" it
07:53:38 <leimy> "words" it
07:53:39 <leimy> etc.
07:53:44 <leimy> and get what you want from it.
07:53:50 <leimy> then map over the lines
07:53:56 <mopped> How would I write that function using case? can I do case x of and then `elem` [..] -> .., == "Koen" -> etc?
07:54:07 <leimy> even parse it linewise or what have you.
07:54:22 <lilac> leimy: that's fine unless you want to do something more interactive
07:54:35 <ehird> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Prim.html#11
07:54:36 <ehird> Aha!
07:54:46 <ski_> mopped : `case x of Just y | y `elem` [..] -> ..; ..' ?
07:54:51 <leimy> lilac: Eh I got interactivity working for that
07:55:02 <lilac> leimy: composable interactivity?
07:55:04 <leimy> lilac: pretty complex stuff too, like dealing with bowling frames :-)
07:55:23 <leimy> stateful interactivity?
07:55:33 <leimy> I don't know about composable
07:55:50 <mopped> do i need the guard ski_
07:56:03 <ski_> mopped : depends
07:56:22 <ski_> do you want the next branch in the `case' to be tried if the guard fails ?
07:56:26 <mopped> yes
07:56:27 <ski_> if so, then you need it
07:57:43 <lilac> mopped: you could write 'case read x of "Simon" -> thing1; "John" -> thing2; "Phil" -> thing3' if you like
07:59:05 <leimy> :t (\f ->  getContents >>= mapM_ putStr . f . lines)
07:59:06 <lambdabot> ([String] -> [String]) -> IO ()
07:59:08 <ski_> oh, the `x' being `case'd upon is the same `x' that is searched for in `["Phil", "Jim", "Bob"]' ?
07:59:30 <mopped> yes
07:59:36 <ski_> i'd say haskell doesn't have alternative patterns ..
07:59:48 <mopped> although I just used case x of x | and it works
07:59:50 <ski_> s/i'd say/it's sad/
08:00:07 * ski_ wonders how his fingers wrote the former instead of the latter
08:00:21 <ski_> mopped : yes, that should do it
08:00:27 <lilac> ski_: let result | x `elem` [...] = ... | otherwise = ... in result ?
08:01:28 * lilac thinks pattern guards on non-function values are underused
08:01:31 <ski_> (lilac : yes, i regard that as basically the same as a `case')
08:01:42 <leimy> :t (\in f -> in >>= mapM_ putStr . f . lines)
08:01:44 <lambdabot> parse error on input `in'
08:01:48 <leimy> oops
08:01:51 <leimy> in is reserved
08:02:02 <lilac> in is a keyword too
08:02:08 <ski_> > let foo | False = "foo"; foo | True = "fnord" in foo
08:02:10 <leimy> :t (\input f -> input >>= mapM_ putStr . f . lines)
08:02:10 <lambdabot>       Conflicting definitions for `foo'
08:02:10 <lambdabot>      In the binding group for: foo, foo
08:02:11 <lambdabot> IO String -> ([String] -> [String]) -> IO ()
08:02:19 <ski_> bah
08:02:23 <lilac> leimy: somehow i read what you wrote as "in is reversed" :-o
08:02:27 <leimy> ah :-)
08:02:36 <ski_> > let foo _ | False = "foo"; foo _ | True = "fnord" in foo ()
08:02:37 <lambdabot>   "fnord"
08:02:45 * ski_ is disappointed
08:03:34 <mopped> If something is of type (), does it return nothing?
08:03:37 <leimy> :t (\input output f -> input >>= mapM_ output . f . lines)
08:03:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m String -> (a -> m b) -> ([String] -> [a]) -> m ()
08:03:47 <opqdonut> mopped: no, it returns ()
08:03:53 <hesky> Hello, somebody can tell me the signature of: \x y-> (x, 3) : [("String", y)] ... and why ???
08:03:54 <opqdonut> mopped: Void is the usual for the empty type
08:04:06 <ski_> mopped : a (ground) value of type `()' must be the value `()', which is the empty tuple
08:04:15 <opqdonut> mopped: empty in the sens that it has no values
08:04:22 <opqdonut> () has one value, namely ()
08:04:26 <opqdonut> if you ignore bottoms
08:04:35 <ski_> mopped : it's mostly used as a place-holder where some value must be passed, but we usually don't care about the actual value
08:04:50 <mopped> ok
08:05:02 <SamB> man, why does PyPI suck so much compared to Hackage :-(
08:05:13 <SamB> they only seem to keep the latest version of a package
08:05:28 <Lemmih> hesky: 'x' is a String, 'y' is a number, and the function is returning a list.
08:05:53 <ski_> (mopped : btw, note that if you're familiar with a `void' in any of C,C++,Java,C#,et.c., that type is more similar to Haskell's `()' than to Haskell's `Void')
08:06:01 <hesky> :t \x y-> (x, 3) : [("String", y)]
08:06:03 <lambdabot> forall t. (Num t) => [Char] -> t -> [([Char], t)]
08:06:16 <SamB> ehird: oh, this is why I was saying it isn't wise to write cons-free code: http://hackage.haskell.org/trac/ghc/ticket/367
08:06:24 <hesky> ok, is there another way of writing this function? because i dont understand that \x y z.... thing
08:07:00 <liwp> hesky: foo a b = (a, 3 : [("String", b)]
08:07:05 <ehird> SamB: Well, my malloc won't infinite loop ... but ... surely those allocate?!
08:07:09 <baaba> hesky, f x y = ... is the same as f = \x y -> ...
08:07:16 <lilac> which is better, doesNotReturn :: Int -> a, or doesNotReturn :: Int -> Void ?
08:07:18 <ehird> they allocate thunks at least
08:07:30 <ehird> lilac: Int -> (forall a. a)
08:07:44 <SamB> ehird: hmm ?
08:07:51 <liwp> :t let foo x y = (x, 3) : [("String", y)]
08:07:52 <lambdabot> <no location info>:
08:07:52 <lambdabot>     not an expression: `let foo x y = (x, 3) : [("String", y)]'
08:07:56 <tromp_> :t \x->x
08:07:58 <lambdabot> forall t. t -> t
08:08:01 <liwp> :t let foo x y = (x, 3) : [("String", y)] in foo
08:08:02 <lambdabot> forall t. (Num t) => [Char] -> t -> [([Char], t)]
08:08:11 <lilac> ehird: is there a good reason for the preference?
08:08:16 <mopped> I'm wondering what's so significant about type declarations? all they tell you is the type of the inputs and the output type, it doesnt seem that important
08:08:17 <ehird> SamB: surely those allocate, I mean
08:08:20 <lilac> (other than it's what is done in the std libs)
08:08:22 <ehird> lilac: Nope, I just like it
08:08:23 <baaba> lilac, so you can use it in an arbitrary expression
08:08:40 <lilac> baaba: surely that's an advantage of the 'Void' formulation?
08:08:45 <SamB> ehird: well, the relevant factor is allocating on the RTS heap
08:09:01 <baaba> er, no
08:09:14 <baaba> f :: Int -> Int; f (doesNotReturn 5)
08:09:28 <ehird> SamB: Basically, where I'm putting GHC, there isn't anything. Apart from maybe alloca, I think that's provided by gcc free-of-charge.
08:09:29 <lilac> baaba: looks like a bug to me
08:09:33 <Cheshire> ceceNePasUnFonction
08:09:41 <Cheshire> can't spell French yet :/
08:09:45 <ehird> SamB: So the allocators simply can't cons.
08:09:51 <idnar> ski_: uhm, void doesn't really seem much like ()
08:09:51 <SamB> ehird: eh ???
08:09:57 <lilac> Cheshire: something like: ceciNestPasUnFunction
08:10:00 <ehird> SamB: what do you mean, eh?
08:10:10 <baaba> lilac, so what's better, let _ = doesNotReturn 5 in undefined?
08:10:12 <SamB> there is no heap, you say ?
08:10:12 <idnar> ski_: you can't have an actual value of void in C, afaik
08:10:24 <hesky> and why is it a Number and not a Int?
08:10:25 <lilac> baaba: well, why would you want to do that?
08:10:31 <SamB> I don't think Haskell is the best choice for that kind of environment
08:10:32 <ehird> SamB: Well there's a heap, but there's no malloc or mmap or ...
08:10:45 <ehird> Specifically, because I'm implementing malloc.
08:10:49 <ehird> So that there is one. :P
08:10:54 <baaba> lilac, because everything has a type? i presume you'll want to use doesNotReturn *somewhere*
08:11:02 <liwp> baabe: doesNotReturn won't be called
08:11:03 <idnar> although, I'm not really sure what Void in Haskell is
08:11:05 <lilac> baaba: the only non-bug cases I can think of are things like 'throw :: a -> IO b' versus 'throw :: a -> IO Void'
08:11:17 <SamB> ehird: well ... check how the OSes written in Haskell do it :-)
08:11:25 <lilac> where 'Void' seems to have an advantage in that the result can't be accidentally used
08:11:29 <SamB> maybe they write that bit in C :-(
08:11:34 <Cheshire> SamB: don't they just increment a pointer?
08:11:38 <ehird> SamB: I'm writing an OS in Haskell. But House just cops out and hacks GHC, and Kinetic writes that in C++ (ewwww!!!)
08:11:38 <ski_> (idnar : that is debatable :)
08:12:15 <SamB> ehird: Hmm, the thing to do here is design an EDSL that generates either C or assembly ;-P
08:12:21 <idnar> ski_: well, for example, you can't write "void foo(); void x = foo();"
08:12:44 <ehird> SamB: Generating C would violate my "no C" policy, and writing malloc in pseudo-assembly would be painful :-D
08:12:45 <lilac> idnar: /don't give them ideas!/
08:13:06 <ski_> idnar : right. i'd say that `void' values are not first-class, in that you can't store them, or pass them as arguments
08:13:16 <idnar> I think you can cast a value to (void), but only if you throw it away
08:13:18 <ehird> <lilac> where 'Void' seems to have an advantage in that the result can't be accidentally used
08:13:20 <SamB> well, you could ask on the GHC mailing list
08:13:23 <ehird> The idea is so that it can stand in for any other expression
08:13:30 <ehird> SamB: Mm.
08:13:37 <idnar> eg. "int foo(); (void)foo();"
08:13:42 <ehird> SamB: Thing is, all the primitive pointer functions (for keeping malloc state) seem to cons up a tuple.
08:13:46 <ehird> Wait a mo.
08:13:51 <idnar> which is sometimes used to indicate that the result is discarded deliberately
08:13:53 <ehird> Doesn't GHC just mmap a huge amount of memory and use it for everything?
08:14:03 <ehird> I could just stub out mmap to return memory location 0.
08:14:12 <idnar> ski_: you also can't create a void value
08:14:24 <idnar> ski_: it sort of appears by magic
08:14:32 <ski_> idnar : well, i'd say that calling your `foo' does exactly that
08:14:36 <leimy> void is not a value :-)
08:14:37 <baaba> void is an incomplete type
08:14:49 <mopped> @src bracket
08:14:50 <lambdabot> bracket before after thing = block $ do
08:14:50 <lambdabot>     a <- before
08:14:50 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
08:14:50 <lambdabot>     after a
08:14:50 <lambdabot>     return r
08:14:51 <ski_> (of course, it is immediately then discarded, after the return)
08:15:23 <ski_> (idnar : your `void foo();', i.e.)
08:15:51 <geezusfreeekwork> data Void = forall a . Void a; fromVoid (Void a) = unsafeCoerce a
08:16:01 <ehird> geezusfreeekwork: er
08:16:06 <geezusfreeekwork> :P
08:16:06 <ehird> it's `data Void`
08:16:18 <ehird> but yes, you can make generic containers with that + type tags
08:16:20 <roconnor> stop using unsafeCoerce with void
08:16:25 <idnar> ski_: well, this all seems pretty similar to Void :P
08:16:29 <ski_> yes, please stop that
08:16:32 <roconnor> data Void = forall a . Void a; fromVoid (Void a) = a
08:16:35 <ehird> i _think_ you could implement ST
08:16:39 <ehird> with it
08:16:52 <ehird> although only for things deriving a certain typeclass...
08:16:54 <roconnor> er
08:17:04 <roconnor> data Void = Void (forall a . a); fromVoid (Void a) = a
08:17:17 <roconnor> I forget how forall interacts with data constructors
08:17:20 <ski_> idnar : a ground function `f :: Foo -> Void' never returns
08:17:26 <roconnor> I think the above is correct
08:17:39 <ski_> idnar : a function `void f();' does return, but it doesn't return any interesting value
08:17:55 <geezusfreeekwork> roconnor, but that's type safe! i'm trying to be like C ;)
08:17:57 <idnar> ski_: f :: Foo -> Void not returning is only a problem if you never inspect the return value
08:18:05 <ski_> idnar : haskell's `Void' might be used in C for things like `longjmp'
08:18:13 <idnar> ski_: void f(Foo a); is more like f :: Foo -> IO Void
08:18:17 <roconnor> geezusfreeekwork: :D
08:18:29 <roconnor> @quote C
08:18:29 <lambdabot> vincenz says: I thought the kinkiness of this channel had just gone way up
08:18:38 <geezusfreeekwork> uh
08:18:40 <ski_> idnar : i don't agree
08:18:42 <idnar> ski_: you can't do anything with the value you get back, but the side-effects may be useful
08:18:48 <geezusfreeekwork> @quote c++
08:18:48 <lambdabot> gwern says: [regarding the naming of Monoids] we will call them CuteFluffableThings, since you can put more fluff into them, but no one would remove fluff from a cute thing
08:19:18 <ehird> awwwwww
08:19:28 <ski_> idnar : i'm here considering proper functions that returns ground results (so no `undefined')
08:19:29 <geezusfreeekwork> heh
08:19:56 <roconnor> idnar: you can't (easily) make a function of type Foo -> IO Void
08:20:10 <roconnor> void f(Foo a) corresponds with Foo -> IO ()
08:20:15 <ehird> sure you can, roconnor
08:20:16 <idnar> roconnor: const (return undefined)
08:20:19 <ehird> yeah
08:20:20 <ehird> :P
08:20:26 <roconnor> that's moronic :)
08:20:34 <ehird> you're moronic :|
08:20:36 <ehird> :P
08:20:43 <geezusfreeekwork> @quote moron
08:20:43 <lambdabot> EvilRanter says: I find "your a moron! unban me, or i shall TAUNT YOU A SECOND TIME!!" to be a particularly poor attempt
08:20:48 <idnar> roconnor: look, mappi
08:20:53 <idnar> er
08:21:03 <idnar> roconnor: look, I think mapping a void return type to IO () makes sense on a working level
08:21:13 * ski_ actually had some code that returned `M ()' for a monad `M' .. but changed it to `M Void' to avoid lurking bugs
08:21:19 <idnar> roconnor: but in terms of actual operation, () isn't really anything like void
08:21:25 <roconnor> when you write a function in C of type void f(Foo a) you do not return an infinite loop at the end
08:21:28 <lilac> roconnor: you're going to need a 'toVoid = Void . unsafeCoerce' to go with that...
08:21:35 <idnar> () is a real value, you can do stuff with it
08:21:53 <idnar> you can't do anything with a value of type void; you can't even assign a name to it
08:22:00 <lilac> @quote q
08:22:00 <lambdabot> augustss says: ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
08:22:01 <ski_> (the code was not meant to monadically return .. so the use of `undefined' all over the place made be weary .. changing to proper `Void' allowed me to remove the `undefined' and regain my sanity)
08:22:02 <roconnor> idnar: operationally C's void is exactly like ()
08:22:17 <idnar> roconnor: except you can inspect (), pass it around, assign it a name
08:22:23 <idnar> roconnor: you can also create values of ()
08:22:32 <geezusfreeekwork> ah now i see what this conversation is actually about
08:22:36 <ski_> idnar : that's a question of first-classness of `()'
08:22:40 <roconnor> you can't make variables of type void in C?
08:22:44 <lilac> C's void is either like () or Void, depending on how C feels at the time
08:22:44 <idnar> the only way you can get a value of void is to call a function returning void, and then you can't do /anything/ with that value
08:22:46 <Cheshire> no you cannot
08:23:04 <roconnor> but in haskell you can make variables of type Void too, and pass them around
08:23:04 <SamB> roconnor: and () is lifted
08:23:11 <ski_> idnar : you can't return arrays in C either, because they're not first-class
08:23:21 <roconnor> so ski_ is right, it is a question of first-classedness of `()'
08:23:25 <Trafalgard> so I have a question:
08:23:27 <Trafalgard> > let foo = [(1,2),(3,4),(5,6)]
08:23:28 <ski_> (roconnor : C is moronic in many ways)
08:23:29 <lambdabot>   <no location info>: parse error on input `;'
08:23:31 <idnar> I'm not saying Void is identical to void
08:23:36 <idnar> it just seems like a better comparison than ()
08:23:45 <SamB> roconnor: you aren't supposed to be able to pass values of type Void around
08:23:46 <bd_> idnar: in C, you can cast things to (void) too. You can't do anything with that either, though.
08:23:48 <Trafalgard> > map show . map fst foo
08:23:50 <lambdabot>   Not in scope: `foo'
08:23:52 <Trafalgard> huh?
08:23:53 <lilac> @let foo = [(1,2),(3,4),(5,6)]
08:23:55 <lambdabot>  Defined.
08:23:55 <geezusfreeekwork> okay, in the module that defines the monad, have (data Void = Void) and only export the type. then you can create meaningless values that can't be used anywhere. we happy?
08:23:55 <SamB> you aren't supposed to HAVE them
08:24:00 <Trafalgard> > map show . map fst foo
08:24:01 <lambdabot>   Couldn't match expected type `a -> [a1]'
08:24:01 <lilac> > map show . map fst $ foo
08:24:03 <lambdabot>   ["1","3","5"]
08:24:04 <roconnor> SamB: sure you can.  id :: Void -> Void
08:24:15 <lilac> Trafalgard: that gets parsed as (map show) . (map fst foo)
08:24:17 <Trafalgard> why doesn't that work?
08:24:25 <SamB> roconnor: oh, I guess you can still have _|_
08:24:26 <grul> > let foo = [(1,2),(3,4),(5,6)] in map show . map fst $ foo
08:24:28 <lambdabot>   ["1","3","5"]
08:24:29 <Trafalgard> I don't seem to understand . at all
08:24:32 <lilac> Trafalgard: and (map fst foo) is not a function, so can't be the RHS of .
08:24:37 <Trafalgard> I keep going over http://book.realworldhaskell.org/read/functional-programming.html
08:24:39 <Trafalgard> and I just don't get it
08:24:46 <roconnor> SamB: even ignoring _|_ I can still pass variables of type Void around.
08:24:46 <lilac> Trafalgard: (f . g) x = f (g x)
08:24:47 <ski_> SamB : `id :: Void -> Void' is a total function
08:24:48 <Trafalgard> I think I get it, but it doesn't work
08:24:54 <Trafalgard> whenever I try it
08:24:59 <SamB> ski_: true, but it isn't a value of type Void
08:25:04 <roconnor> just because a type has no value, doesn't mean I can't have variables of that type.
08:25:05 <Trafalgard> when I think I get it, I try to use it, and it doesn't do what I think it should
08:25:09 <grul> @src (.)
08:25:09 <lambdabot> (f . g) x = f (g x)
08:25:10 <lilac> Trafalgard: ((map show) . (map fst foo)) x = map show (map fst foo x)
08:25:16 <Trafalgard> but if I replace . with $, voila, it works x_X
08:25:17 <lilac> Trafalgard: and that's /not/ what you want
08:25:22 <lilac> Trafalgard: right.
08:25:25 <lilac> @src ($)
08:25:26 <lambdabot> f $ x = f x
08:25:30 <liwp> > map (show . fst) foo
08:25:31 <SamB> $ and . aren't the same
08:25:32 <lambdabot>   ["1","3","5"]
08:25:32 <roconnor> fmap (+1) :: (Void,Int) -> (Void,Int)
08:25:33 <lunabot>  luna: Not in scope: `aren't'
08:25:34 <Trafalgard> right
08:25:46 <lilac> map show $ map fst foo = (map show) (map fst foo) = map show (map fst foo)
08:25:50 <lilac> which /is/ what you want
08:25:59 <SamB> it's kind of a freak accident that you can turn $s on the left into .s (when the types aren't too wierd)
08:26:21 <ski_> SamB : how about my `stop :: Action Void',`kill :: SystemM Void' then ?
08:26:31 <idnar> if you wanted () in C, it would be struct Unit {}; or something
08:26:43 <roconnor> SamB: when programing in Coq, 70% of the time is spend shuffling variables of empty types around.
08:26:54 <lilac> if we had an 'instance Functor  where fmap :: (a -> b) -> a -> b; fmap = id'...
08:27:05 <lilac> ... then we could replace all uses of . and $ with <$> and everyone would be happy
08:27:17 * roconnor needs to find a convincing argument for idnar
08:27:19 <Cheshire> that doesn't sound very constructive roconnor
08:27:22 <SamB> roconnor: operationally ?
08:27:31 <Trafalgard> Right, map show $ map fst foo was the second thing I did and it did exactly what I wanted
08:27:42 <Trafalgard> but the whole point was that I was trying to figure out . :P
08:27:43 <roconnor> Cheshire: 80% of constructive math is classical math, as I have found out.
08:27:48 <idnar> roconnor: I suspect we're just arguing over aesthetic preference here :P
08:27:53 <lilac> Trafalgard: ok, it works like this:
08:27:56 <Cheshire> all these %s are confusing me :p
08:27:57 <SamB> Cheshire: well, there are a lot of absurd cases to throw out
08:27:59 <roconnor> idnar: I think it is deeper than that.
08:28:06 <lilac> Trafalgard: you have "f (g (h (i (j x)))))"
08:28:09 <idnar> roconnor: as was previously mentioned, there are pretty massive differences either way
08:28:16 <SamB> is constructive math 20% of classical math ?
08:28:22 <lilac> Trafalgard: you can write that as "f $ g (h (i (j x)))"
08:28:23 <Trafalgard> You said <lilac> Trafalgard: and (map fst foo) is not a function, so can't be the RHS of .
08:28:34 <Trafalgard> Why did the error message show up at the .?
08:28:41 * ski_ would like continuations in a constructive math programming language
08:28:42 <Trafalgard> instead of at foo?
08:28:43 <roconnor> Cheshire: 70% of the time is passing empty types around, 10% of the time is passing unit-like types around, and 20% is spend with real computation.
08:28:46 <Trafalgard> or is GHC just weird
08:28:53 <lilac> Trafalgard: because (map fst foo) is perfectly reasonable
08:28:58 <Trafalgard> ok
08:29:02 <Trafalgard> makes sense, I suppose
08:29:05 <ski_>   jump :: Not a -> a -> Void  -- ftw !
08:29:12 <SamB> roconnor: unit-like!
08:29:18 <roconnor> idnar: the fact that void isn't first class in C makes it hard to see its true nature.
08:29:21 <Cheshire> ski_, as in Cont monad or more like SML style?
08:29:27 <Trafalgard> <lilac> Trafalgard: you can write that as "f $ g (h (i (j x)))"
08:29:31 <Trafalgard> so far I've had to use lots of $s
08:29:32 <roconnor> SamB: types with one element (extensionally).
08:29:33 <ski_> Cheshire : more like the latter, only pure
08:29:43 <roconnor> SamB: Void -> Void is unit like
08:29:43 <lilac> Trafalgard: ... which is the same as "f $ g $ h $ i $ j x"
08:29:43 <Trafalgard> or parens
08:29:58 <Cheshire> ski_, I think saw a lambda-mu-calculus that models LK, which computationally had CWCC
08:30:05 <lilac> Trafalgard: now, it just so happens that "a $ b $ c" is the same as "a . b $ c"
08:30:12 <Cheshire> ski_, details are fuzzy though.. maybe I'm mixing bits of it up
08:30:19 <Cale> (because $ associates the wrong way)
08:30:30 <Trafalgard> Cale: @_@
08:30:30 <ski_> Cheshire : yes .. but iirc that is impure (evaluation order matters)
08:30:34 <Cheshire> aha
08:30:41 <Cheshire> yes I was about to say, not sure if it's pure or not
08:30:45 <ski_> Cheshire : i think what would be needed is some variant of linear logic
08:30:47 <lilac> Trafalgard: because "a $ b $ c" = "a (b (c))" and "a . b $ c" = "(a . b) $ c" = "(\x -> a (b x)) c" = "a (b c)"
08:31:04 <ski_> (Cheshire : hopefully/probablh including the multiplicative disjunction)
08:31:06 <Cheshire> ski_, delimited continuations aren't pure ?
08:31:15 <SamB> roconnor: well, okay.
08:31:15 <lilac> Trafalgard: so "f $ g $ h $ i $ j x" == "f . g $ h $ i $ j x" == "f . g . h . i $ j x"
08:31:20 <idnar> roconnor: its true nature is just a figment in our imaginations
08:31:21 <ski_> Cheshire : not as i've seen them formulated, no
08:31:23 <lilac> Trafalgard: note that the last one stays as a $
08:31:27 <Cheshire> ah ok
08:31:36 <Martijn> > "f . g $ h $ i $ j x" == "f . g . h . i $ j x"
08:31:37 <lambdabot>   False
08:31:43 <Martijn> :-(
08:31:43 <Cheshire> Shifting The Stage had a State monad implementation.. but I guess just because they used a monad didn't mean it was in a pure setting
08:31:52 * ski_ even has some syntax sketched for working with `par'-types ..
08:31:54 <Cheshire> (implementation in terms of delimited continuations)
08:32:00 <lilac> > f . g $ h $ i $ j x == f . g . h . i $ j x
08:32:01 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Expr'
08:32:04 <SamB> Cheshire: generally what you do with the values of void-like types in Coq is prove that they do not, in fact, exist ;-P
08:32:09 <Martijn> (just kidding, lilac)
08:32:09 <ski_> Cheshire : possibly they reified that monad :)
08:32:10 <idnar> roconnor: since the language is defined in a way that prevents you from observing the semantics that would arise were it "first class"
08:32:13 <lilac> > f . g $ h x == f $ g $ h x
08:32:14 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
08:32:17 <ski_> (which is impure, in general)
08:32:37 <edbond> how can I sort list of lists by length ?
08:32:39 <lilac> Martijn: IIRC, SimpleReflect ought to make something like that work :)
08:32:43 <idnar> @quickcheck \x -> f . g $ h x == f $ g $ h x
08:32:44 <lambdabot> Unknown command, try @list
08:32:52 <idnar> er, guess that wouldn't work anyway
08:32:57 <idnar> @check \f g h x -> f . g $ h x == f $ g $ h x
08:32:58 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
08:32:59 <SamB> roconnor: you know why it bothers ME that void isn't first-class in C?
08:33:08 <idnar> @check \f g h x -> (f . g $ h x) == (f $ g $ h x)
08:33:10 <lambdabot>       Overlapping instances for Show (t -> a)
08:33:10 <lambdabot>        arising from a use of `m...
08:33:21 <idnar> oh come on
08:33:41 <SamB> because I can't do tail calls at void type like "return foo(x,y);"
08:34:02 <roconnor> :)
08:34:02 <idnar> SamB: why is the "return" so important? :P
08:34:15 <Cheshire> ski_, why would linearity help make it pure?
08:34:37 <roconnor> @src Ix
08:34:38 <lambdabot> class (Ord a) => Ix a where
08:34:38 <lambdabot>     range           :: (a,a) -> [a]
08:34:38 <lambdabot>     index           :: (a,a) -> a -> Int
08:34:38 <lambdabot>     inRange         :: (a,a) -> a -> Bool
08:34:38 <lambdabot>     rangeSize       :: (a,a) -> Int
08:34:41 <SamB> idnar: well, it would make it quite obvious that it's a tail call
08:34:50 <SamB> I mean, so obvious that a human doesn't have to think to see it
08:34:59 <ski_> Cheshire : because the unrestricted copying and discarding of continuation (and simultaneously of values) is i think what makes it impure
08:35:01 <Martijn> idnar: hehe :-)
08:35:05 <idnar> SamB: is there any C implementation where it matters whether it's a tail call or not?
08:35:06 <Cheshire> ski_, although I guess the duality you get with negation and such sort of intuitively suggests you might get continuations
08:35:22 <idnar> I'm not sure why you would care about tail-call-ness aside from optimisation concerns
08:35:25 <SamB> idnar: the C implementations where it matters can handle the other way anyway
08:35:35 <lilac> Trafalgard: so "$" is used to /apply/ functions, and "." is used to /build/ functions
08:35:43 <Trafalgard> ah.
08:35:45 <SamB> idnar: I gather you haven't read your GCC documentation ?
08:35:46 <Cheshire> idnar, it's so you can use functions to implement control structures
08:35:47 <ski_> @where hpaste2
08:35:48 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
08:36:03 <Cheshire> idnar, obviously not a big concern in C or Java, which is why they don't need TCO
08:36:14 <SamB> Cheshire: tell that to GCC ;-)
08:36:17 <roconnor> @hoogle Ix
08:36:17 <lambdabot> module Data.Ix
08:36:17 <lambdabot> Data.Ix class Ord a => Ix a
08:36:17 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
08:36:18 <lilac> Trafalgard: consider: map (+1) (map (*2) [1,2,3])
08:36:18 <idnar> Cheshire: but that's exactly my point, the 'O' stands for optimisation
08:36:27 <idnar> Cheshire: so if you don't care about optimisation, why does it matter?
08:36:35 <SamB> idnar: well, it's kind of like garbage collection
08:36:35 <Cheshire> idnar, no
08:36:35 <lilac> Trafalgard: you could say that's applying the function "map (+1)" to the value "map (*2) [1,2,3]"
08:36:46 <SamB> it's not really just an optimization
08:36:49 <lilac> Trafalgard: so that's "map (+1) $ map (*2) [1,2,3]"
08:36:54 <roconnor> aww
08:37:01 <roconnor> Ord is a superClass of Ix!
08:37:04 <roconnor> damn
08:37:04 <Cheshire> idnar, If I called it Tail Call Elimination, the meaning of what I said would be the same
08:37:12 <lilac> Trafalgard: or you could say, you build the function which doubles then adds one, like so: "map (+1) . map (*2)"
08:37:13 <Trafalgard> but you'd rather compose the two map functions
08:37:15 <roconnor> @hoogle Ix
08:37:16 <lambdabot> module Data.Ix
08:37:16 <lambdabot> Data.Ix class Ord a => Ix a
08:37:16 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
08:37:17 <idnar> Cheshire: it's still an optimisation :P
08:37:20 <roconnor> @src Ix
08:37:21 <lambdabot> class (Ord a) => Ix a where
08:37:21 <lambdabot>     range           :: (a,a) -> [a]
08:37:21 <lambdabot>     index           :: (a,a) -> a -> Int
08:37:21 <lambdabot>     inRange         :: (a,a) -> a -> Bool
08:37:22 <lambdabot>     rangeSize       :: (a,a) -> Int
08:37:25 <idnar> Cheshire: without it, you just need an infinite stack :P
08:37:32 <roconnor> why would they make Ord a super class?
08:37:36 <lilac> Trafalgard: then you apply it to the list, as either "(map (+1) . map (*2)) [1,2,3]" (not the brackets)
08:37:37 <SamB> idnar: kind of like calling free() is an optimization
08:37:41 <lilac> *note the brackets
08:37:59 <idnar> SamB: right, you just need infinite memory without it
08:38:08 <lilac> Trafalgard: or as "map (+1) . map (*2) $ [1,2,3]" (here the extra brackets aren't needed because (.) happens before ($))
08:38:18 <drhodes> :t (<-)
08:38:20 <lambdabot> parse error on input `<-'
08:38:30 <idnar> SamB: (or a way of automatically free()ing when appropriate)
08:38:31 <Trafalgard> ah. hmm.
08:38:52 <lilac> Trafalgard: or you can think of it as applying the function "map (*2)" to the value "[1,2,3]" then applying "map (+1)" to the result
08:39:01 <idnar> well, rather, the "automatic free()ing" is the optimisation
08:39:03 <lilac> Trafalgard: that gives you "map (*2) $ map (+1) $ [1,2,3]"
08:39:14 <SamB> idnar: if you want to think of it like that
08:39:24 <lilac> Trafalgard: that's the same as "map (*2) $ (map (+1) $ [1,2,3])"
08:39:29 <Martijn> :t eval
08:39:30 <lambdabot> Not in scope: `eval'
08:39:31 <Trafalgard> Hey, this compiles now :P
08:39:33 <roconnor> Cale: when you write your Hascale report, can you remove Ord as a super class of Ix?
08:39:34 <lilac> Trafalgard: the brackets there aren't needed because ($) is right associative :)
08:39:45 * Trafalgard thinks I understand this now :P
08:39:47 <Trafalgard> Thanks
08:39:55 <lilac> great :)
08:40:04 <lilac> Cale: can you remove Eq ans a superclass of Ord too? :)
08:40:53 <SamB> Hascale, huh
08:40:58 <roconnor> lilac: isn't that going a little too far?
08:41:05 <Cheshire> idnar, if you are going to use a programming language in reality, you take into account operational concerns... dismissing them as 'optimizations' doesn't give any new understanding on how to program
08:41:14 <SamB> lilac: yeah, what's it hurt ?
08:41:15 <dolio> Just get rid of Ix. Everyone knows that arrays are indexed by Words.
08:41:24 <SamB> dolio: hah
08:41:25 <lilac> roconnor: i don't think so. i don't like the way haskell insists on Ord being a total ordering with equivalence the same as equality.
08:41:45 <roconnor> lilac: Well, I would support a POrd class.
08:41:54 <idnar> Cheshire: but the compiler does the right thing here anyway
08:42:24 <Cheshire> 'here' ?
08:42:25 <SamB> idnar: even GCC can do it
08:43:40 <idnar> well, I understood what SamB said to mean that "foo();" worked (ie. had TCO applied) for a void function
08:43:44 <redditbot> Matching Brackets in Haskell - Passing Curiosity
08:43:44 <redditbot> GHC on SPARC: Just Testing
08:43:44 <redditbot> Other shootout news - Data.Random
08:43:44 <redditbot> xmonad contribs review: SpawnOn
08:43:44 <redditbot> Hieroglyph Haddock docs | Hieroglyphics
08:43:54 <idnar> so "return foo();" in that case only has aesthetic value
08:45:11 <drhodes> [??? <- x | x <- [my-IO String-s] ]   -or-   map (<-) [my-IO String-s], I have a list of file names and need to concat the contents of all of them.
08:45:27 <ski_> Cheshire : an example of my ideas for syntax <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1208>
08:45:35 <lilac> roconnor: even c++ deals with orderings better than haskell. don't you find that a little embarrassing? ;-)
08:45:39 <mmorrow> i got sick of having to compile C stuff all the time and made a quicky C interactive repl http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1207#a1207
08:45:40 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:46:04 <newsham> ?tell lambdabot hi
08:46:04 <lambdabot> Nice try ;)
08:46:08 <roconnor> :)
08:47:09 <ski_> @tell pumpkinbot @tell lambdabot hi
08:47:10 <lambdabot> Consider it noted.
08:47:16 <newsham> mmorr: what are the MALLOC/FREE defns for?
08:48:59 <mmorrow> newsham: just so i can swap them out for something else easily
08:49:23 <ehird> :t callcc
08:49:24 <lambdabot> Not in scope: `callcc'
08:49:27 <ehird> :t callCC
08:49:28 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
08:49:49 <ehird> <mmorrow> i got sick of having to compile C stuff all the time and made a quicky C interactive repl http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1207#a1207
08:49:51 <ehird> try c-repl
08:49:54 <ehird> its written in haskell to
08:49:55 <ehird> o
08:50:13 <mmorrow> :o
08:50:19 <mmorrow> where?
08:50:38 <mmorrow> omg sweet!
08:50:49 <mmorrow> i was looking for this exact same thing last week for hours
08:51:12 <ehird> http://neugierig.org/software/c-repl/
08:51:14 <ehird> It's jawsome.
08:51:58 <mmorrow> i remember someone mentioned it in here a while ago, but no one seemed to recall it and it's as good as nonexistent without its exact name to google with
08:52:26 <lilac> @go root cint
08:52:28 <lambdabot> http://root.cern.ch/
08:52:28 <lambdabot> Title: The ROOT System Home Page
08:52:44 <lilac> mmorrow: CINT is a pretty competent C++ interpreter from what I understand
08:58:05 <dancor> given that so many things you'd think are statements turn out to be expressions, i'm wondering if my php AST should just combine the two notions
08:59:00 <dancor> i guess i have to keep them separated otherwise i'd have to like error on un-AST-ing if you tried like $a = unset($b);
09:00:50 <dancor> having an extra layer bc $a += $b; is an expression is lame tho
09:01:24 * dancor will try being correct first and convenient later
09:04:06 <mmorrow> lilac: thanks, i'll check it out (although i'm really just interested in C)
09:05:42 <mmorrow> lilac: ah cool, it looks nice, but unfortunately i need gcc extensions
09:05:52 * mmorrow is still battling the c-repl .cabal
09:06:31 <mmorrow> (and it imports the _paths that cabal would generate, so i've gotta hack Setup.lhs until it works :/ )
09:06:33 <chessguy_work> ermm
09:06:47 <chessguy_work> what's would happen if you did getChar >> getChar ?
09:06:54 * mmorrow meant he is still battling the c-repl Setup.lhs
09:07:01 <chessguy_work> would it try to get one char or 2?
09:07:05 <lilac> chessguy_work: 2
09:07:06 <mmorrow> you'd get two chars
09:07:11 <mmorrow> (and return 1)
09:07:19 <chessguy_work> that's what i thought
09:07:31 <chessguy_work> so what's this talk on -cafe about optimizing it into just getChar
09:07:53 <lilac> "optimizing" must mean something different there?
09:07:56 <vegai> that'd be a disturbing optimization
09:08:11 <lilac> "brokenizing" perhaps fits better
09:08:17 <conal> ski_: SEC == semantic editor combinator
09:08:24 <lilac> optimize all programs to "main = return 42"
09:08:30 <vegai> then again, gcc does it all the time. Hah.
09:08:37 <chessguy_work> i quote:
09:08:37 <chessguy_work> It is perfectly possible to construct IO actions as values of this data type and execute them by some function evalIO :: IO -> Prelude.IO with the obvious definition. Now the question arises: do you think
09:08:38 <chessguy_work> getChar >>= \x -> getChar would be optimized to getChar by compiler?
09:09:09 <ski_> conal : yes, but you mentioned some posts ?
09:10:58 <conal> ski_: http://conal.net/blog/posts/semantic-editor-combinators/ and examples in http://conal.net/blog/?s=%22semantic+editor+combinator%22
09:12:41 <ski_> conal : ty
09:13:03 <Saizan> ?hackage c-repl
09:13:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/c-repl
09:14:04 <conal> ski_: type of what?
09:14:36 <ski_> ": ty" is not ":ty" :)
09:15:21 <conal> ski_: oh, cons ?
09:15:56 <chessguy_work> lol
09:16:33 <chessguy_work> overloaded operators ftw :)
09:16:54 <boxbeat> could someone point me to how to to write the most basic lambda calculues interpreter?
09:17:39 <boxbeat> like what is the 3 basic commands? it is apply and...
09:17:39 <Cheshire> boxbeat, look at eval and (*) in here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=330
09:17:42 * conal still doesn't get it
09:17:50 <idnar> conal: "ty" == "thank you"
09:17:53 <chessguy_work> conal, ty = thank you
09:17:58 <conal> oh!!
09:17:58 <idnar> I thought SEC was Securities and Exchange Commission
09:18:01 <conal> hah!
09:18:12 <boxbeat> i missed if someone posted...
09:18:28 <Cheshire> boxbeat, check the topic for channel logs
09:18:42 <ski_> conal : oh, sorry
09:18:56 <boxbeat> what?
09:19:22 <dons> ?yow
09:19:23 <lambdabot> I feel better about world problems now!
09:19:25 * conal chuckles some more
09:20:26 <boxbeat> what are the basic operators of lambda calculus? apply+ 2 other
09:20:31 <chessguy_work> conal, that would be pretty naughty of ski_ to be consing you onto something random wihtout your permission
09:20:49 <idnar> wikiconspedia
09:21:14 <dancor> boxbeat: http://tunes.org/~nef/logs/haskell/09.02.05
09:21:38 <elbar> is it possible to pass gcc options through 'ghc -fvia-c' ?
09:21:54 <elbar> like -mtune=whatever?
09:22:45 <chessguy_work> conal, ok, follow-up from our discussion from last night, if you've got time
09:24:04 <Baughn> elbar: You can use -optc-foo or some such
09:24:59 <conal> chessguy_work: sure.  and i wanted to mention: add sets (including countably & uncountbly infinite) and really-real numbers to your semantic types.
09:25:08 * lilac is slightly amused by "bind is a sequencing operator" on haskell-cafe
09:25:20 <lilac> time to bring out the reverse state monad?
09:25:28 <Baughn> Probably. :P
09:25:29 <chessguy_work> conal, via Data.Set ?
09:25:31 <conal> lilac: do it!
09:25:37 <conal> chessguy_work: no.  real sets
09:25:42 <Baughn> Amazing that you can get so much structure from what is basically operator-;
09:25:45 <idnar> reverse state is still sequencing, just the wrong way :P
09:25:45 <conal> chessguy_work: math, not programming.
09:25:53 <chessguy_work> ok, fair enough
09:26:06 <idnar> ambiguous state monad?
09:26:32 <lilac> how about the identity monad plus mdo ?
09:26:51 <conal> pair monad?  function monad?
09:26:59 <chessguy_work> conal, ok, so you suggested that ADTs tend to be more representation-ish than meaning-ish (sorry for the paraphrase). you also said (relatedly, i think) that types should _mean_ something. i'm not sure i get this
09:27:12 <chessguy_work> conal, what does it mean for a type not to mean anything
09:28:01 <chessguy_work> and why could data Piece = Pawn | Knight | Bishop | ... (for example, since it's a domain i know well) be less meaningful than some other representation
09:28:27 <lilac> conal: how about the ForkIO monad?
09:28:49 <elbar> Baughn: yeah, seems to work that way...thx
09:28:50 <conal> lilac: i don't know that one
09:28:57 <FalconNL> I know I'm overlooking something terribly obvious, but I can't think of the correct solution. Suppose I have the definition data Test = A Int | B Int and tests = [A 1, B 2, A 3, A 4, B 5]. Is there any way to filter out the B's without have to write a helper function that matches both patterns? I tried deriving Typeable, but typeOf (A 1) == typeOf (B 2), so that doesn't work.
09:29:41 <Baughn> FalconNL: Use "type Test = Either Int Int" instead?
09:29:42 <lilac> conal: something like: a >>= (Wrap f) = Wrap $ do r <- newEmptyMVar; forkIO (a >>= writeMVar r); takeMVar r >>= f
09:29:54 <rwbarton> > let tests = [Left 1, Right 2, Left 3, Left 4, Right 5] in [ Right x | Right x <- tests ]
09:29:55 <lambdabot>   [Right 2,Right 5]
09:30:01 <lilac> conal: like IO, but side effects happen in a nondeterministic order
09:30:20 <conal> lilac: disturbingly cool
09:30:24 <Baughn> > rights [Left 1, Left 2, Right 3]
09:30:25 <lambdabot>   Not in scope: `rights'
09:30:37 <FalconNL> Baughn: unfortunately the data type I need it for has much more than two constructors. I used two to keep the example simple
09:31:03 <Baughn> FalconNL: Then rwbarton's example is the simplest syntax I'm aware of
09:31:13 <conal> chessguy_work: thinking ...
09:31:48 <Baughn> FalconNL: Preferably you'd want a predicate Test -> Bool, right?
09:32:20 <rwbarton> , constrIndex (Left 1)
09:32:21 <lunabot>  luna: Couldn't match expected type `Data.Data.Constr'
09:32:54 <FalconNL> Baughn: yes, but ideally automatically derived instead of having to write such a function myself
09:32:57 <rwbarton> , toConstr (Left 1)
09:32:57 <conal> chessguy_work: if i say i want a *program's types* to mean something, i'm really saying that i want *me* to be clear about what i mean by those types.
09:32:58 <lunabot>  luna: Ambiguous type variable `b' in the constraint:
09:33:06 <rwbarton> , toConstr (Left 1 :: Either Int String)
09:33:07 <lunabot>  Left
09:33:12 <conal> chessguy_work: i by "clear", i mean in precise math terms.
09:33:20 <ski_> FalconNL : how about `isA :: Test -> Bool; isA (A _) = True; isA (B _) = False', and then use `filter isA tests' =
09:33:23 <ski_> s/=/?
09:33:29 <asgaroth> @hoogle toConstr
09:33:30 <lambdabot> Data.Generics.Basics toConstr :: Data a => a -> Constr
09:33:47 <Baughn> FalconNL: Understandable. I'm not aware of any way to do it, unfortunately.
09:33:50 <rwbarton> FalconNL: You could derive Data, if you really think you have a need for it, and then get toConstr
09:34:03 <rwbarton> but it seems like an odd thing to do normally
09:34:18 <ski_> (conal : a negative example might be Control.Arrow.ArrowList' ..)
09:34:35 <conal> chessguy_work: i want to work with both a representation (in the program) and a meaning (in my head or in a theorem prover), and know how exactly they relate to each other.
09:35:12 <chessguy_work> conal, so you think that ADTs are in some sense not very precise?
09:35:52 <conal> chessguy_work: they don't have a chance to be precise, in the sense i mean.
09:36:01 <conal> chessguy_work: because they're only part of the story.
09:36:10 <Baughn> > filter (\(Left a) -> True) [Left 1, Right 2]
09:36:11 <lambdabot>   [Left 1* Exception: /tmp/8551121693000407881:71:48-64: Non-exhaustive patte...
09:36:25 <conal> chessguy_work: it's like talking only about yourself and asking if you've given a precise description of your marriage.
09:36:42 <chessguy_work> conal,  what's the missing piece?
09:36:47 <Baughn> Patterns could do with being a bit more flexible. :/
09:36:49 <SamB> conal: so, would ADTs in Coq be precise enough for you?
09:37:09 <SamB> also, what does the A stand for here ?
09:37:16 <conal> chessguy_work: a semantic model and the semantic function that relates the two.
09:37:28 <conal> SamB: depends on what's specified
09:37:34 <ski_> Andromeda
09:37:52 <chessguy_work> conal, ok, we've defined semantic model somewhat. i'm not sure what you mean by semantic function, though
09:38:13 <conal> chessguy_work: meaning :: Representation -> Model
09:38:47 <conal> chessguy_work: e.g., Image a -> (R2 -> a)
09:39:46 <chessguy_work> conal, so you're saying an ADT is just a representation
09:39:50 <FalconNL_> rwbarton: thanks, the toConstr does exactly what I need
09:40:24 <rwbarton> FalconNL_: Hooray for hammers! :)
09:40:25 <Saizan> if Model is in haskell it'll be an ADT too
09:40:56 <chessguy_work> ohhh, so a better model could be, e.g., a piece is a function from a given square to the squares it could move to
09:41:08 <chessguy_work> then you could have different pieces be different values
09:41:11 <conal> chessguy_work: yeah!  for instance.
09:41:27 <chessguy_work> then you're not separating the representation from the meaning
09:41:46 <conal> chessguy_work: then s/is/means/
09:41:54 <Saizan> Model is supposed to be easy to reason about, Representation can be more complex for the sake of efficiency
09:41:58 <conal> chessguy_work: and you can probably simplify that model.
09:42:05 <chessguy_work> conal, oh?
09:42:07 <conal> Saizan: yes!
09:42:49 <conal> chessguy_work: nm.
09:43:41 <chessguy_work> conal, oh, like, a ray is a sequence of squares going off in a particular direction from a given square, and a bishop is a composition of these rays
09:43:43 <lilac> conal: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1210
09:44:06 <lilac> conal: denotationally, (>>) is associative.
09:44:21 <Ringo48> what processor does GHC's code generation target?
09:44:26 <lilac> although operationally it seems to be left-biased
09:44:56 <conal> lilac: (>>) must be associative, given monad laws, no?
09:45:08 <conal> chessguy_work: yeah, that kind of thing.
09:45:15 <conal> chessguy_work: what Saizan said is right to the heart of it.
09:45:15 <chessguy_work> cool idea
09:45:32 * chessguy_work ponders again
09:45:42 <Ringo48> *the windows version of GHC
09:45:57 <chessguy_work> this idea of not separating representation from meaning seems to be a key
09:46:31 <conal> chessguy_work: describe two worlds.  the "semantics" which is optimized for precise & simple reasoning, and the "implementation" optimized for execution on computers.
09:46:56 <lilac> conal: yeah, it's been a bad day for me. of course i meant commutative ;-)#
09:46:56 <hallongrottan> augustss_: i'm looking forward to hearing your talk tomorrow. what will it be about?
09:47:01 <conal> chessguy_work: and describe a single bridge between them: the semantic function.
09:47:09 <conal> lilac: oh!  okay.
09:47:09 <ski_> (hallongrottan : talk ?)
09:47:20 <hallongrottan> ski_: well yes
09:47:27 <augustss_> hallongrottan: I'm writing slides now... "Fun with Haskell overloading"
09:47:35 <hallongrottan> augustss_: ah, cool
09:47:50 <conal> lilac: then it may be an ideal counter-example to that bind is sequencing confusion.
09:48:02 <Dybber> In the Emacs haskell-mode, is there a way to avoid the directory change to ~/.cabal when loading a file into the GHCI-buffer?
09:48:27 <idnar> augustss_: Haskell overloading sounds like writing code that makes the compiler's brain explode
09:48:37 <ski_> (hallongrottan : at some conference .. or what ?)
09:48:49 <Saizan> Ringo48: ghc doesn't do cross-compilation, so it targets only the arch of the machine where it's installed
09:48:50 <conal> Dybber: oh -- you don't have an intervening *.cabal file
09:48:52 <Gnuts> Need some help: I want to write a function which reads the stdin and write in a file till '.' is pressed
09:49:07 <Ringo48> Saizan: okay, thanks
09:49:10 <hallongrottan> ski_: it's a guest lecture in frontiers of programming language technology
09:49:15 <conal> Dybber: does it really change *to* ~/.cabal, not to ~ ?
09:49:31 <chessguy_work> conal, i think that reasoning about the model isn't the only benefit to this approach. it seems like this would improve compositionality of the representation too, if you represented it more closely to the semantic model you have in mind
09:49:36 <Ringo48> I only ask because the machine is really old (Pentium 2)
09:49:50 <geezusfreeekwork> chessguy_work, in addition to much of conal'
09:49:52 <geezusfreeekwork> oops
09:49:56 * geezusfreeekwork tries again
09:49:58 <Ringo48> not sure they'd bother to support something that old
09:49:59 <Dybber> conal: Yes, it executes :cd ~/.cabal/
09:50:25 <ski_> hallongrottan : hm, when an where ?
09:50:34 <ski_> (i might like to attend)
09:50:35 <Cale> Gnuts: sure. Should it do anything else after that?
09:50:42 <geezusfreeekwork> chessguy_work, of course conal's work is full of good examples of semantic design. i think another good example might be the PDF you can find on the camp web site
09:50:44 <conal> chessguy_work: i think you're talking about when you *don't* make the clear distinction between model & rep.
09:50:46 <hallongrottan> ski_: the edit room
09:50:57 <hallongrottan> ski_: third floor, close to linsen
09:51:13 <Cale> Gnuts: Do you want that to be a '.' on its own on a line, or a '.' anywhere in the input?
09:51:20 <conal> chessguy_work: if you *do* keep your distinction clear, then you still have the option of making your rep closely match your model.  in that case, implementation is trivial.
09:51:23 <geezusfreeekwork> chessguy_work, camp being the hopeful future successor to darcs
09:51:25 <Dybber> I don't have any .cabal files in my working-directory. I'm just using cabal to easily install things from Hackage, nothing else.
09:51:40 <geezusfreeekwork> chessguy_work, the original darcs theory of patches is also good
09:51:47 <ski_> hallongrottan : to the left, from the entrance with the big stairs ?
09:51:50 <chessguy_work> conal, i think i didn't say what i meant very clearly. close distance between semantic model and representation = better compositionality of representations
09:51:55 <ski_> hallongrottan : time ? 13:15 ?
09:52:06 <geezusfreeekwork> i am speculating that these are things conal would agree with me on, at least
09:52:09 <conal> chessguy_work: i'd say *easier*, not better.
09:52:12 <chessguy_work> geezusfreeek got a link to camp?
09:52:21 <chessguy_work> conal, fair enough
09:52:35 <conal> chessguy_work: if you follow the discipline, you'll get ideal composability, no matter what repr you use.
09:52:40 <geezusfreeekwork> http://projects.haskell.org/camp/
09:52:52 <conal> chessguy_work: because composability is a function of the semantic and discipline, never of the representation.
09:53:02 <Gnuts> Cale i dont really understand your question
09:53:12 <conal> chessguy_work: assuming the implementation is correct, i.e., is faithful to the semantic function.
09:53:37 <Cale> Gnuts: Well, I'm just trying to understand better what you want the program to do.
09:53:53 <glith> ski_: the answer is yes to both of your questions to hallongrottan
09:53:56 <chessguy_work> geezusfreeek merci
09:54:02 <ski_> glith : ic. ty
09:54:03 <conal> chessguy_work: what you've hit upon is a very nice idea also: denotation as representation.
09:54:03 <Gnuts> Ok, the programm should end when . (dot) is pressed on the keyboard
09:54:55 <chessguy_work> conal, <conal> chessguy_work: because composability is a function of the semantic and discipline, never of the representation
09:54:59 <Cale> Gnuts: okay, so you basically want to repeatedly getChar until the result is '.'
09:55:00 <chessguy_work> conal, i'm not sure what you mean by this
09:55:02 <conal> chessguy_work: it's a nice technique when it wants to be.  it can also seduce you away from an ideal semantic model.
09:55:19 <Gnuts> yes
09:55:34 <Cale> Gnuts: Or you could use getContents and takeWhile (/= '.')
09:55:52 <conal> chessguy_work: i mean composability is in your interface and its meaning.
09:55:56 <Cheshire> A monad m is stong given:   st :: (a, m b) -> m (a, b)  ?
09:56:03 <Cheshire> do you need more for a strong monad?
09:56:11 * geezusfreeekwork finds himself inspired to think about a semantic design for concurrency
09:56:21 <conal> chessguy_work: any correct implementation of an interface & semantics will be exactly as composable as any other correct implementation.
09:56:30 <idnar> Cheshire: you need an 'r'
09:56:31 * idnar hides
09:56:36 <chessguy_work> conal, what do you mean here by interface?
09:56:42 <sbahra> conal, are you guys talking in reference to some article/paper?
09:57:05 <chessguy_work> sbahra, i'm just picking conal's brain, hoping to absorb some of his thinking by osmosis
09:57:14 <Gnuts> Cale you can show me a programm what this does i cant do this
09:57:23 <conal> chessguy_work: i mean an abstract interface: a type w/o representation and the constants & functions for that type.
09:57:30 <sbahra> Cheshire, I see.
09:57:36 <sbahra> s/Cheshire/chessguy_work/
09:58:02 <Cale> Gnuts: Something like  main = do xs <- getContents; writeFile "foo" (takeWhile (/= '.') xs)
09:58:17 <dolio> @type uncurry $ fmap . (,)
09:58:18 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a, f a1) -> f (a, a1)
09:58:22 <Cale> Gnuts: But the line buffering will mean that it will wait for enter to be pressed after.
09:58:23 <conal> chessguy_work: like Data.Set minus any access to the representation.
09:58:31 <Cale> Gnuts: So you might want to turn that off...
09:58:37 <chessguy_work> conal, ok
09:59:39 <Cale> Gnuts: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1211#a1211
09:59:56 <Cale> Gnuts: getContents is slightly magical.
10:00:38 <Cheshire> functors are strong monads !?
10:00:44 <Cheshire> that doesn't even make sense
10:00:50 <conal> lilac: unsafePerformIO may spoil the impact of the ForkIO example
10:00:58 <dolio> Functors can be strong or not.
10:01:03 <Cheshire> I don't have a clue what is a strong monad
10:01:07 <chessguy_work> conal, ok, i think i'd better get back to work before i sit here picking your brain all day :)
10:01:09 <dolio> All Functors in Haskell are strong.
10:01:11 <Gnuts> Cale a ok, thanks... but what exactly say this line: xs <- getContents
10:01:16 <chessguy_work> conal, will continue to ponder this though, fascinating stuff
10:01:26 <conal> lilac: maybe the pair monad is enough of a non-sequential example to make the point.
10:01:33 <sbahra> @tell lunabot You smell funny
10:01:34 <lambdabot> Consider it noted.
10:01:39 <sbahra> , True
10:01:40 <lunabot>  True
10:01:41 <lambdabot> lunabot: You have 1 new message. '/msg lambdabot @messages' to read it.
10:01:44 <Cheshire> hieroglyphics http://en.wikipedia.org/wiki/Strong_monad
10:01:46 <Cale> Gnuts: It says that xs is the result of running getContents
10:01:48 <conal> chessguy_work: okay :)
10:02:03 <geezusfreeekwork> i think a blog article on semantic design sounds pretty awesome
10:02:05 <Cale> Gnuts: getContents produces a String which is the contents of stdin.
10:02:49 <sbahra> Yeah, it was an interesting discussion.
10:02:57 <chessguy_work> conal, thanks again!
10:03:10 <conal> chessguy_work: you're welcome. :)
10:03:24 <Cale> Gnuts: another way, for illustration: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1211#a1212
10:03:40 <Gnuts> Cale ahh now i understand.. and this function have to be named main to run?
10:03:46 <conal> geezusfreeekwork: semantic design peeks through many of my recent posts.  and there's luke palmer's "semantic design" post from a while back.  i'll noodle over what else i might say, more coherently.
10:03:51 <Cale> Gnuts: In a compiled program, yes.
10:04:19 <Cale> Gnuts: It's also not really a function, since it has no parameters.
10:04:30 <Cale> Gnuts: it's just an IO action.
10:05:29 <dolio> Cheshire: According to that article, strong monads are just monads where the monad operations interact nicely with the strength operation for the functor.
10:05:59 <Cheshire> strength operation being (,) ? or that one you defined ?
10:06:15 <dolio> strength is a * f b -> f (a * b)
10:06:24 <Cheshire> ok
10:06:32 <dolio> In Haskell, with (,), all Functors are strong.
10:06:54 <dolio> But, obviously, with arbitrary monoidal categories, that's not always the case.
10:07:09 <dolio> Otherwise there'd be no need to talk about it.
10:07:36 <Cheshire> monoidal categories
10:07:39 <Cheshire> :S
10:07:40 <leoncamel> hey. folks.
10:08:51 <dolio> There's also costrong functors with costrength :: f (Either a b) -> Either a (f b), I believe.
10:09:05 <dolio> Which you can define for Traversable functors...
10:09:15 <rwbarton> Right, and not every functor is costrong, unless you are in a language with callCC
10:09:28 <dolio> @type traverse :: Traversable f => f (Either a b) -> Either a (f b)
10:09:30 <lambdabot> Not in scope: `traverse'
10:09:30 <lambdabot>     Not in scope: type constructor or class `Traversable'
10:09:42 <dolio> @type Data.Traversable.traverse :: Data.Traversable.Traversable f => f (Either a b) -> Either a (f b)
10:09:43 <lambdabot>     Couldn't match expected type `Either a (f b)'
10:09:43 <lambdabot>            against inferred type `t a1 -> Either a (t b)'
10:09:43 <lambdabot>     Probable cause: `Data.Traversable.traverse' is applied to too few arguments
10:09:56 <rwbarton> @hoogle sequence
10:09:57 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:09:57 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:09:57 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:10:04 <dolio> Oh, right.
10:10:11 <dolio> Well, there you go.
10:10:25 <dolio> You also need a nicer Monad instance for Either.
10:10:30 <dolio> So that it doesn't require Error a.
10:10:37 <dolio> But I digress.
10:10:56 * ski_ wants functors with a weakness !
10:11:16 <ski_> f (a + b) -> f a + b
10:11:28 <leoncamel> I want to build a data structure, which are very complex. The data structure I am designing is a recursive one. The data structure is: Block contains a list of [Pin]s. Net contains a list of [Pin]s. what shall I do with this kind of structure ?
10:12:06 <luqui> ski_, can you think of a nontrivial functor with that property?
10:12:29 <dolio> @type let coswap Left a = Right a ; coswap Right a = Left a in coswap . sequence . fmap coswap
10:12:31 <lambdabot>     Constructor `Left' should have 1 argument, but has been given 0
10:12:31 <lambdabot>     In the pattern: Left
10:12:31 <lambdabot>     In the definition of `coswap': coswap Left a = Right a
10:12:41 <dolio> @type let coswap Left a = Right a ; coswap Right a = Left a in coswap . Data.Traversable.sequence . fmap coswap
10:12:42 <lambdabot>     Constructor `Left' should have 1 argument, but has been given 0
10:12:43 <lambdabot>     In the pattern: Left
10:12:43 <lambdabot>     In the definition of `coswap': coswap Left a = Right a
10:12:59 <rwbarton> luqui: Every functor that's Traversable, see above discussion :)
10:13:03 <idnar> dolio: need ()?
10:13:21 <luqui> @type let coswap (Left a) = Right a ; coswap (Right a) = Left a in coswap . Data.Traversable.sequence . fmap coswap
10:13:21 <dolio> Oh, yeah. I need to get more sleep, apparently.
10:13:22 <lambdabot> forall a a1 (f :: * -> *). (Error a1, Data.Traversable.Traversable f) => f (Either a a1) -> Either (f a) a1
10:13:51 <Cheshire> hi luqui
10:13:52 <idnar> does Traversable subclass Functor?
10:14:17 <dolio> Yes.
10:14:18 <luqui> Cheshire, hi?
10:14:27 <Cheshire> luqui, I read your post about Dana
10:14:33 <dolio> Foldable, too.
10:15:20 <luqui> Cheshire, oh yeah?  what's up? :-)
10:15:30 <Saizan> leoncamel: data Pin = Block [Pin] | Net [Pin] ?
10:15:43 <boxbeat> case x of B x = x
10:15:44 <Cheshire> luqui, this seems really interesting! I'm trying to figure what you're doing more
10:15:55 <Saizan> leoncamel: or the Pin's are something else?
10:16:04 <luqui> Cheshire, thanks!  ask anything you like.
10:16:28 <Cheshire> luqui, I suppose you chose somthing like pi-sigma for generic programming? (and/or other reasons?)
10:16:28 <Cheshire> a
10:16:50 <leoncamel> Saizan: hmm, OK. is there any way to use "reference" type in Haskell ?
10:17:18 <leoncamel> Saizan: something like pointer in C/C++, or reference type in Java ?
10:17:29 <Saizan> leoncamel: IORef
10:17:44 <luqui> Cheshire, there are two reasons I chose a dep. type language as core:
10:17:51 <Saizan> leoncamel: but you need to be in IO to read or write those
10:18:21 <luqui> Cheshire, because there is no compilation phase, it makes sense for values to weave back and forth between compile-time and runtime.
10:18:30 <Saizan> leoncamel: sometimes it's nicer to just use Int and a Map Int Value
10:18:34 <luqui> dependent types can handle that injection
10:19:02 <Cheshire> my computer crashed.. just catching up :/
10:19:08 <luqui> ok :-)
10:19:30 <luqui> Cheshire, the other reason is that, though I have no formal backing, I feel like dependent types are "complete"
10:19:46 <luqui> i.e. with other type systems, you'll run across problems you just can't express
10:19:57 <Raynes> C++ Does not exist.
10:19:57 <Gnuts> Cale you are here? I have another question i want to look up a list of lists if they are the same length... if yes then True and if not then False
10:19:59 <leoncamel> Saizan: hmm, I am try to design a floorplan program. which the data structure is something like I describe before.
10:20:19 <luqui> but with enough type annotations and proof terms, dependent types can express anything.  still... just a feeling, and I'm not even sure how to formalize that statement.
10:20:38 <leoncamel> Saizan: I will try to describe it in C++. Pls give some suggestion to implement it in Haskell.
10:20:57 <lilac> Gnuts: so you want True if all lists are the same length and False if not?
10:21:03 <Botje> Gnuts: 1 == (length $ group $ map length lists)
10:21:05 <Saizan> leoncamel: i'm not sure i can read C++ well enough :)
10:21:18 <Cheshire> luqui, about 'complete' yes I should think so:  You can't internalize haskells type system without type lambda, but if you added type lambda then you can.. Peter Morris has some amazing papers about this sort of thing
10:21:35 <lilac> Gnuts: allSame = and $ zipWith ((==) `on` length) `ap` tail
10:21:46 <Botje> leoncamel: haskell is not C++. You can't just translate the C to haskell and expect it to work.
10:22:03 <luqui> Cheshire, thanks, I'll look him up
10:22:03 <Cheshire> luqui, maybe you have seen them, stuff like Exploring the Regular Tree Types and Universes for Generic Programming
10:22:17 <luqui> Cheshire, nope
10:22:18 <lilac> leoncamel: i know C++; i might be able to give it a go
10:22:40 <Gnuts> whats "ap"?
10:22:48 <lstor> armour piercing
10:22:54 <sbahra> :t ap
10:22:55 <Cheshire> luqui, also why have something that is partial recursive?
10:22:56 <Saizan> @type ap
10:22:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:22:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:23:08 <Saizan> ?src ap
10:23:09 <lambdabot> ap = liftM2 id
10:23:11 <Cheshire> luqui, it seems a shame to miss out on everything being total, but maybe there is something more
10:23:12 <lilac> Gnuts: allSame xs = and (zipWith (\x y -> length x == length y) xs (tail xs))
10:23:36 <lstor> @src ap
10:23:37 <lambdabot> ap = liftM2 id
10:24:01 <Cheshire> luqui, (also about generics, Peter Dybjers has some inductive-recursive internalization of types)
10:24:02 <luqui> Cheshire, totality is not good for a core for a programming language.
10:24:06 <ski_> luqui : define "nontrivial"
10:24:14 <lilac> @type ap :: (a -> b -> c) -> (a -> b) -> (a -> c)
10:24:16 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
10:24:16 <luqui> Cheshire, necessarily I cannot compile Haskell to a total core.
10:24:27 <luqui> ski_, not-identity.
10:24:34 <sbahra> > Just (+ 1) `ap` (Just 1)
10:24:35 <lambdabot>   Just 2
10:24:38 <luqui> ski_, and I was shown a pretty large class of them :-)
10:27:03 <Cheshire> luqui, and you are making an OS?
10:27:13 <Cheshire> or is that not quite acurate ?
10:27:25 <luqui> Cheshire, yeah, that's the ultimate goal
10:27:31 <luqui> I'm sort of starting from the middle, though
10:29:35 <Cheshire> luqui, I hope it goes well, seems really cool! hard work though
10:29:40 <eric_j> if you read a stream with readFile, and then write it with writeFile, haskell interleaves the actual reads and writes. what gives it permission to do that? doesn't it violate the IO monad?
10:30:12 <leoncamel> lilac: thanks. could you pls take a look at http://pastebin.com/f3e1ff401 , and give me some suggestion about how to implement it in Haskell ?
10:30:20 <luqui> Cheshire, it is hard work, but I have a underlying suspicion that compositional FP yields exponential rewards.
10:30:38 <luqui> Cheshire, so if it's easier than it should be, I can confirm that suspicion
10:31:23 <leoncamel> lilac: what I want is, Block and Pin are real instance object, and Net are just reference type to these instances. how can I deal with it in Haskell ?
10:31:25 <luqui> Cheshire, I also just started working with faculty at CU to get an NSF grant for it :-)
10:31:30 <rwbarton> eric_j: yes.  Under the hood readFile is using unsafeInterleaveIO which is the cause of that behavior.
10:31:44 <eric_j> okay, thanks
10:32:07 <lilac> leoncamel: ignore that distinction. haskell is garbage collected.
10:32:27 <lilac> leoncamel: you don't do explicit memory management / ownership handling in haskell
10:32:33 <lilac> (or at least, not usually)
10:33:10 <lilac> leoncamel: but i suspect you want some kind of identity semantics on pins?
10:33:10 <luqui> related question for anybody who knows:  is there an FP language that does not have garbage collection, but is still safe?
10:33:16 <luqui> maybe based on linear types or something?
10:33:23 <lilac> leoncamel: that is, you want the equivalent of operator==(Pin*, Pin*)?
10:33:32 <Cheshire> luqui, Henry Bakers linear lisps and forthish languages I guess
10:33:53 <luqui> Cheshire, forth, really?  I thought it had GC...
10:33:59 <luqui> I don't know much about it though
10:34:16 <Cheshire> luqui, (another possibility is linear type theories like Frank Pfennings written about I suppose)
10:35:10 <lilac> leoncamel: more generally, it's useful to think about data structures in haskell in terms of what you do with them rather than what they contain.
10:35:12 <pejo> luqui, http://dalila.sip.ucm.es/~ricardo/SafePub.html
10:35:26 <luqui> Cheshire, you should give me your email or something.  you seem to be full of useful references.
10:35:32 <Cheshire> haha
10:36:15 <pejo> luqui, have you checked out Hume as well?
10:36:18 <lilac> leoncamel: can you make a list of the operations you want to perform on your Nets, Pins and Blocks?
10:36:20 <luqui> pejo, no
10:36:32 <luqui> pejo, I'm bookmarking all this stuff like a madman :-)
10:37:01 <luqui> pejo, hume link?
10:37:09 <luqui> or a keyword with which to find it
10:37:15 <pejo> luqui, www.hume-lang.org I think
10:37:22 <ski_> luqui : maybe some restricted ML-Kit with region management ?
10:38:18 <leoncamel> lilac: hmm, yes. list are OK. but, what I want is, if I modified one of block positions, other pins in the net list should be modified.
10:38:40 <Botje> then generate a new list
10:41:01 <dons> ?users
10:41:01 <lambdabot> Maximum users seen in #haskell: 679, currently: 679 (100.0%), active: 26 (3.8%)
10:41:01 <lilac> leoncamel: there are two different ways of doing 'mutable' data structures in Haskell. one is to make a mutable data structure (using IORefs or STVars or whatever), and the other is to make an immutable data structure and update it by creating a new data structure
10:41:04 <dons> mm
10:41:29 <luqui> lilac, and the second one is the only morally correct one =P
10:41:36 <dons> ok. that's the all time record.
10:41:40 <dons> ?users
10:41:41 <lambdabot> Maximum users seen in #haskell: 680, currently: 680 (100.0%), active: 26 (3.8%)
10:41:44 <leoncamel> lilac: Oh.. thanks, I should check IORefs and STVars first.
10:41:44 <luqui> hawt
10:41:54 <luqui> leoncamel, nooo!!
10:42:07 <luqui> don't give in to the dark side
10:42:21 <pumpkin> dons: it was actually even higher last night!
10:42:24 <leoncamel> luqui: oh ?
10:42:27 <pumpkin> pumpkinbot saw it
10:42:34 <pumpkin> @users
10:42:34 <pumpkinbot> Maximum users seen in #haskell: 692, currently: 681 (98.4%), active: 3 (0.4%)
10:42:35 <lambdabot> Maximum users seen in #haskell: 681, currently: 681 (100.0%), active: 25 (3.7%)
10:42:42 <pumpkin> pumpkinbot: @part #haskell
10:42:44 <lilac> leoncamel: the second way is the better way for most purposes, for many reasons. but it's harder :(
10:42:45 <leoncamel> luqui: what does I miss ?
10:43:00 <dons> mm
10:43:02 <luqui> leoncamel, a beautiful and elegant functional solution hiding deep within your problem.
10:43:28 <lilac> leoncamel: if your goal is to use haskell as a nicer imperative language than C++, then STVars are a reasonable choice, i think.
10:43:45 <redditbot> Snippet: Lazily sorting a map of lists
10:43:46 <lilac> leoncamel: but you're missing out on the advantages of a pure solution
10:43:51 <int80_h> this is one of the few places where people agree with me that aesthetics matter
10:43:52 <leoncamel> luqui: hmm, sorry, I can't catch the second way ? how exactly ?
10:44:23 <luqui> leoncamel, not sure.  haven't looked at your problem.
10:44:36 <luqui> leoncamel, but I'm more being a pure evangelist than actually suggesting
10:44:55 <Botje> leoncamel: you are aware haskell isn't just "a better C++" but a radically different paradigm, right?
10:44:55 <leoncamel> lilac: OK. any example about the second way ? or papers ?
10:44:56 <luqui> there are beautiful functional solutions everywhere, but it usually takes a pretty deep understanding of both your problem and FP to find them.
10:45:13 <SamB> luqui: everywhere ?
10:45:29 <luqui> SamB,  .. yes?
10:45:55 <lilac> luqui: basically, we have something like 'data Block = Block Pos [Block] [Pin]; data Pin = Pos; data Net = [Pin]' and we want to be able to update the positions of Blocks and Pins.
10:46:14 <leoncamel> Botje: :), no, I am trying to solve my problem in pure functional way.. But, it would take time to switch my brain from imperative language to pure functional way.
10:46:37 <SamB> leoncamel: yeah, it would take time
10:46:40 <SamB> so take time ?
10:47:00 <Botje> leoncamel: how much time do you have? is there a deadline?
10:47:19 <Botje> if there isn't, you should take time to work through some haskell tutorials
10:47:39 <Botje> to get a feel of how functional programming approaches problems
10:47:59 <luqui> lilac, such that these objects have identity, right?  i.e. these structures can be cyclic, etc.?
10:48:33 <lilac> luqui: correct.
10:48:41 <luqui> leoncamel, what is your problem, from a broader view?
10:48:53 <luqui> leoncamel, try not to use the word "update".
10:49:26 <leoncamel> Botje: no, there are no deadline. I have read several tutorials, but, I don't know how to deal my problem . :(
10:49:36 <leoncamel> lilac: ya. s/switch/update.
10:49:51 <Botje> leoncamel: start by dropping the C code and going back to the problem statement
10:49:53 <dolio> @type let callcc :: ((a -> b) -> a) -> a ; callcc = undefined in \t -> callcc (\k -> Right (fmap (\e -> case e of Left a -> k (Left a) ; Right b -> v) t))
10:49:55 <lambdabot> forall t t1 (f :: * -> *). (Functor f) => f (Either t t1) -> Either t (f Expr)
10:50:07 <Botje> think about the solution and how it differs from the problem statement
10:50:11 <dolio> @type let callcc :: ((a -> b) -> a) -> a ; callcc = undefined in \t -> callcc (\k -> Right (fmap (\e -> case e of Left a -> k (Left a) ; Right b -> b) t))
10:50:13 <lambdabot> forall b t (f :: * -> *). (Functor f) => f (Either t b) -> Either t (f b)
10:50:27 <Botje> often you can extract type definitions from your problem statement and incrementally build functions to do stuff
10:50:28 <lilac> is there a trick for creating zippers for self-referential/cyclic structures?
10:50:41 <mmorrow> @let callcc :: ((a -> b) -> a) -> a ; callcc = undefine
10:50:42 <lambdabot>  <local>:7:42: Not in scope: `undefine'
10:50:44 <luqui> dolio, oh... wow.  every functor is weak?
10:50:45 <mmorrow> @let callcc :: ((a -> b) -> a) -> a ; callcc = undefined
10:50:47 <lambdabot>  Defined.
10:50:49 <leoncamel> luqui: hmm, I am trying to redesign the original physical design program, into pure beautiful haskell one.
10:50:53 <ski_> @type let callCC (\(\a1 -> _) -> a0) = a0@a1 in callCC
10:50:55 <lambdabot> Parse error in pattern
10:51:17 <luqui> leoncamel, what's the original problem, from 10,000 feet?
10:52:06 <ski_> (dolio : yes, that's basically treating `Either' as a multiplicative disjunction)
10:52:21 <zachk> does gmp in ghci do 64bit floating point numbers?
10:52:43 <zachk> er ghc
10:52:44 <boxbeat> give me a Functor!
10:53:25 <leoncamel> luqui: Oh. you know the electric design automation. there are sub-field called physical design, which will process a large set of block, and try to place them in most compact one, without overlap of these blocks.
10:53:38 <dolio> luqui: Only if you have callcc.
10:54:00 <luqui> leoncamel, oh, I'm not aware.  but okay, sounds cool.
10:54:02 <leoncamel> luqui: typically, a block contains a set of pins. the the connection relation-ship are called net-list.
10:54:07 <luqui> dolio, oh right, I see what you did there.
10:54:24 <Baughn> leoncamel: That sounds distinctly NP-complete
10:54:36 <lilac> Baughn: /everything/ in EDA is NP-complete
10:54:51 <Baughn> ..fun
10:55:03 <dancor> isn't optimizing circuits like much worse thant NP-complete even
10:55:09 <lilac> Baughn: yep, and I get paid for it too -)
10:55:12 <luqui> NP-complete is no problem.  we're happy to get NP-complete problems.
10:55:12 <lilac> +:
10:55:17 <luqui> in PL /everything/ is undecidable
10:55:21 <Baughn> dancor: I don't see how it can be. There are only so many combinations..
10:55:25 <mib_2f6ttb> pl?
10:55:28 <leoncamel> luqui: in the previous design, we deal with these kind of problem in C++. but, I want try it in Haskell, the beautiful way.
10:55:29 <luqui> programming languages
10:55:39 <leoncamel> Baughn: yea, totally NP-C
10:55:48 <Baughn> Unless verifying one combination takes more than linear time?
10:56:14 <luqui> Baughn, you mean polynomial?
10:56:24 <luqui> which is... unlikely :-)
10:56:29 <lilac> Baughn: depends whether you take into account quantum effects on the nets, etc.
10:56:36 <Baughn> Well, I don't know much about circuit design. :P
10:56:55 <lilac> Baughn: proving two circuits equivalent, for instance, is not computable
10:57:03 <Baughn> I just threw the problem at a computer, and it figured out a solution. I never had to worry about /how/.
10:57:25 <leoncamel> so, any suggestion about my problem ?
10:57:30 <lilac> Baughn: which means formal equivalence tools will /never/ be perfect :)
10:57:57 <Baughn> lilac: Unless you start by generating both designs from the same algorithm, but that's cheating. ;)
10:58:21 <roconnor>  <lilac> Baughn: proving two circuits equivalent, for instance, is not computable
10:58:28 <roconnor> what are circuts?
10:58:37 <Baughn> Not computable, though? Or just not feasibly computable?
10:58:48 <roconnor> I thought they were finite
10:58:52 <lilac> Baughn: equivalent to the halting-problem
10:58:52 <Baughn> Seems to me there are a finite number of states, even if it's a very large number
10:58:56 <roconnor> and hence this is trivially computable.
10:59:02 <Baughn> lilac: Halting-problem only applies to infinite systems
10:59:12 <pejo> Leoncamel, Mary Sheeran and Emil Axelsson have been doing hardware stuff with functional languages, but I'm not familiar enoguh with their research to knwo if it helps your problem in any way.
10:59:17 <roconnor> or are there loops in the circuts?
10:59:29 <lilac> roconnor: in general there can be loops and state elements.
10:59:31 <Baughn> Even if there were, it'd still be a finite number of states
10:59:36 <tromp_> loops dont make it infinite
10:59:51 <roconnor> lilac: is that the source of the non-computability?
11:00:09 <roconnor> oh
11:00:12 <roconnor> state elements
11:00:14 <roconnor> god
11:00:16 <roconnor> ok
11:00:20 <roconnor> sounds uncomputable
11:00:21 <luqui> I think Baughn is right.  if you don't have infinite memory, you can't have TC
11:00:30 <roconnor> ooh
11:00:33 <roconnor> good point
11:00:39 <tromp_> what are strate elements?
11:00:41 <dolio> ski_: I don't think the (small amount of) linear logic material I've read has mentioned multiplicative disjunction before.
11:00:46 <lilac> it depends whether you're modelling some environment in which the thing operates or not
11:00:52 <Baughn> So the computation is totally unfeasible, but it's not actually /uncomputable/
11:01:13 <lilac> if all you want to show is that, given the same inputs, they'll produce the same outputs, that's only NP-complete
11:01:13 * luqui ponders the formal definition of "totally unfeasible"
11:01:18 <luqui> unfeasible for every input
11:01:25 <lilac> or at least NP-hard
11:01:46 <Baughn> ..I didn't mean it that formally
11:01:47 <mstr> Baughn: do you assume that the halting test program also runs in a finite computer=
11:01:48 <lilac> if you have some model of the environment in which two different sequences of output are considered equivalent, then...
11:01:58 <Baughn> "Unfeasible for random input"
11:02:16 <Baughn> You can choose input for which it's feasible, for example trivially by computing x==x
11:02:34 <ski_> dolio : possibly because it's part of classical linear logic (but not "intuitionistic linear logic")
11:02:44 <Baughn> mstr: When I specifically say "for finite systems"? Then, yes.
11:02:46 <dolio> Ah. That'd probably explain it.
11:02:54 <roconnor> intuitionistic linear logic?
11:02:56 <dolio> I think the only thing I've really read was Wadler's paper on the subject.
11:03:06 <dolio> It also has ! but not ?.
11:03:14 <mstr> Baughn: so, if we have a program that used 100% of a computer's resources, where do you load the halting tester program?
11:03:35 <Baughn> mstr: In a separate computer, connected via a debug port.
11:03:35 <mstr> there's something there I just don't get :P
11:04:07 <lilac> if 'equivalent' means 'equivalent whenever a certain output pin is asserted' then the problem is not computable.
11:04:12 <Baughn> You're probably just mixing up "unfeasible" and "incomputable"
11:04:20 <leoncamel> pejo: oops, it seems different from my problem field. :(
11:04:55 <mstr> hmm, makes sense
11:04:55 <lilac> (although again it depends what external circuitry you're assuming, and is predicated on the assumption that you can create infinitely many states by manipulating it)
11:04:59 <tehgeekmeister> i've made a parser for wikimedia markup (it's not very general or very polished yet); what's the consensus, would people like such a thing on hackage?  if so i'll clean it up, make it a bit more general and add it.
11:05:05 <ski_> roconnor : intuitionistic as in not having `par' nor `why not'
11:06:01 <Baughn> mstr: A /finite/ system will always either loop or halt, so the halting problem is trivially (but unfeasibly) solvable for anything real-world.
11:06:23 <ski_> (roconnor : with par (here `(+)') we can prove `Not a (+) a' .. and it's constructive ! :)
11:06:55 <roconnor> ok
11:07:10 <ski_> (and `Not' is an involution)
11:07:40 <roconnor> Not a is a --o 0 ?
11:07:48 <ski_> not quite
11:07:57 <roconnor> ok
11:08:02 <mstr> Baughn: if we agree that trivial but unfeasible things are included into the real world ;)
11:08:15 <ski_> `Not a' is equivalent to `a -o _|_', where `_|_' is the multiplicative falsity
11:08:24 <ski_> (`0' would be the additive falsity)
11:08:30 <roconnor> ah
11:08:57 <Baughn> mstr: Well, we can't rule out the possibility that we'll some day be able to harness a law of physics for inf/inf computing.
11:09:05 <ski_> (`0' is like haskell's `Void', a variant-type with no alternatives)
11:09:20 <Baughn> mstr: (Though personally I'd be worried that trying to run an infinite program would lock up the universe)
11:09:37 <sbahra> ski_, what is "-o"?
11:09:43 <ski_> linear implication
11:09:53 <sbahra> Ok
11:10:22 <mstr> Baughn: Let's hope that the universe doesn't have ring 0 exploits in case we just exist inside a huge computer :D
11:10:22 <dancor> Baughn: an infinite program in finite time?  i'd never even thought of that
11:10:29 <ski_> a function of type `a -o b' may only use its argument of type `a' once (and it *must* use it once, it may not discard it)
11:11:16 <Baughn> mstr: It could be a good thing. We'd be able to break out.
11:11:20 <ski_> (a function of type `!a -o b' may use its argument as many times as it likes, because a value of type `!a' contain as many copies of a value of type `a' as we like)
11:11:39 <Baughn> mstr: Certainly better than the current assumption that there's only a finite amount of computation possible over the entire life of the universe
11:12:03 <ski_> (a function of type `a -o ?b' may use its call continuation as many times as it likes, returning zero,one or more times, with different values)
11:12:37 <sbahra> tehgeekmeister, would be a nice thing to add
11:12:43 <Baughn> dancor: http://www.frc.ri.cmu.edu/~hpm/project.archive/general.articles/1991/TempComp.html <-- Here's something vageuely resembling formal treatment of the issue
11:12:55 <lilac> ski_: sounds interesting, got a reference to a paper on this?
11:12:59 <tehgeekmeister> sbahra: okay, i'll get it up there soon =]
11:13:16 <leoncamel> BTW, is data parallel ready now ?
11:14:22 <ski_> lilac : i don't recall which are nice introductory papers to linear logic .. possibly Girard or Blass .. istr there's one paper linked from WP, but i don't recall how good it is
11:14:40 <dancor> Baughn: back about optimal-circuit, i don't think it is easy to determine if you have an optimal circuit
11:15:02 <ski_> (lilac : if i recall, i could later try to dig something up ..)
11:16:08 <lilac> ski_: thanks, i'll have a google. if you do happen across a reference, i'd appreciate an @tell :)
11:19:03 <geezusfreeekwork> leoncamel, it has some major optimizations in the works, but it is working pretty well in GHC 6.10.1
11:19:37 <geezusfreeekwork> leoncamel, and i'm not even sure if these optimizations i heard about are about ndp specifically or just about the threaded runtime generally
11:20:07 <leoncamel> geezusfreeekwork: thanks. it seems the DPH is quite cool.. :)
11:20:21 <geezusfreeekwork> yes it is yes it is :)
11:22:23 <tromp_> > 1366 % 768
11:22:25 <lambdabot>   683%384
11:23:14 <tromp_> > 1366 % 768 - 16%9
11:23:16 <lambdabot>   1%1152
11:23:31 <geezusfreeekwork> have a weird resolution or something?
11:23:51 <tromp_> it's 1366x768 advertised as 16:9
11:24:02 <tromp_> > 1367 % 768 - 16%9
11:24:03 <geezusfreeekwork> ugh
11:24:04 <lambdabot>   5%2304
11:24:18 <tromp_> > 1365 % 768 - 16%9
11:24:20 <lambdabot>   (-1)%2304
11:24:27 <tromp_> that wld be closer:)
11:27:07 <geezusfreeekwork> actually i wonder if that is the resolution of my roommate's tv too. it looks about right
11:28:28 <lilac> does Jeff Heard's latest blog post on planet seem a bit overcomplicated to anyone else?
11:28:47 <mle> > 1360 % 765
11:28:49 <lambdabot>   16%9
11:29:12 <tromp_> they cld just make it 1280 % 720 and have easy 720p display
11:29:13 <lilac> "sort mp key = map (map snd . sort $ flip zip (mp ! key)) mp" seems to do the trick
11:30:09 <geezusfreeekwork> > 1379%774
11:30:11 <lambdabot>   1379%774
11:30:23 <geezusfreeekwork> > 1376%774
11:30:23 <lilac> > 848 % 480
11:30:25 <lambdabot>   16%9
11:30:25 <lambdabot>   53%30
11:30:26 <geezusfreeekwork> err
11:30:29 <geezusfreeekwork> ah
11:30:31 <lilac> > 854 % 480
11:30:33 <lambdabot>   427%240
11:31:19 <lilac> ^^ i have a 854x480 projector. it's nuts
11:31:34 <lilac> 854 /is not even a multiple of 4/ :(
11:31:39 <jeffersonheard> Is there someone on reddit who downmods everything in the Haskell channel?
11:31:49 <geezusfreeekwork> > 854%480 - 16%9
11:31:50 <lambdabot>   1%720
11:31:57 <jeffersonheard> Seems kinda pointless, but my posts always have 1 and no more down votes
11:32:04 <lilac> jeffersonheard: sort mp key = map (map snd . sort $ flip zip (mp ! key)) mp
11:33:25 <jeffersonheard> lilac: that sorts each list on its own
11:33:38 <lilac> jeffersonheard: it sorts by your key row.
11:34:02 <repnop> jeffersonheard: your posts have 1 and no downvotes? that just means no one is up voting.
11:34:16 <jeffersonheard> repnop, no 1 downvote and some number of upvotes
11:34:21 <repnop> ah k
11:35:14 <lilac> jeffersonheard: if you want to be more sure the order is the same on all rows, you can do
11:35:26 <lilac> sort mp key = map (map snd . sortBy (comparing fst) $ flip zip (mp ! key)) mp
11:35:34 <jeffersonheard> lilac...  I see it now, but won't that recompute the sort for each row?
11:35:36 <BMeph> conal: ping
11:35:44 <lilac> jeffersonheard: you already recompute the sort for each row
11:36:19 <jeffersonheard> lilac: I compute the order in which I sorted the key row once...  after that, it should just use the ordering
11:36:40 <lilac> jeffersonheard: well, that's true :)
11:36:49 <jeffersonheard> which is why I did it that way
11:36:55 <jeffersonheard> but I like your one-liner :-)
11:37:20 <lilac> in terms of runtime i bet it makes no measurable difference (unless your rows are looong)
11:37:57 <jeffersonheard> lilac: I'm sure your right there.  My rows tend to be looong, but that's because of the kind of data I generally deal with.  million element rows are nothing
11:38:48 <BMeph> jeffersonheard: There are *many* 'someones' who downvote anything that mentions Haskell. I suspect at least one of those persons does major work in php. ;)
11:39:20 <repnop> but reddit karma is worth $0 so you shouldn't really care :)
11:39:22 <jeffersonheard> but on the whole, you're right, and there's no diff between the two versions other than the fact that yours is shorter and easier to read
11:39:35 <jeffersonheard> repnop, I don't really care.  I was just wondering if we knew of a troll
11:39:55 <repnop> jeffersonheard: the majority of the site? :)
11:40:24 <jeffersonheard> well, I meant a troll that had a peculiar grudge against the Haskell community, but point taken
11:43:31 <lilac> jeffersonheard: how about this: zip mp!key with a list of functions (!0), (!1), (!2), ..., then sortBy (comparing fst), map snd. then map that over your map.
11:43:46 <redditbot> Hieroglyph: Interactively graph a spreadsheet in 99 lines of Haskell
11:44:58 <lilac> jeffersonheard: something like: \mp key -> map (flip map (map snd . sortBy (comparing fst) $ zip (mp!key) (flip (!!) <$> [0..])) . flip ($)) mp
11:45:24 <lilac> jeffersonheard: but you'll need to add your IntMap thing to remove the quadratic runtime due to (!!) ;-)
11:45:30 <jeffersonheard> yep
11:46:50 <lilac> if you're going to apply the same permutation to a whole bunch of lists, it seems like there should be a nicer way of doing that quickly than converting eack list into a intmap / array
11:48:06 <Baughn> lilac: I've got a function here that does permutations on pure lists.. not sure how efficient it is, but just a minute
11:48:16 <jeffersonheard> lilac, I agree with you, but on the other hand you need something that treats each list separately.
11:48:46 <jeffersonheard> But actually, I could simplify a bit by doing IntMap.fromList on a zipped (ordering + list) and then IntMap.toAscList
11:48:57 <Baughn> http://rafb.net/p/ixk0Em35.html <-- How about this?
11:49:05 <lilac> jeffersonheard: i think the zip is /almost/ perfect
11:49:12 * Baughn blinks. Hmm. It seems to use Seq internally.
11:49:32 <Baughn> ..wait. *I* did that.
11:49:42 <lilac> jeffersonheard: all you need is to get the compiler to compute a function which does the list reordering instead of computing the new list
11:51:38 * lilac is not sure whether that's actually straightforward or even possible
11:51:57 <jeffersonheard> no, but this is straighforward enough:
11:52:12 <BMeph> lilac, jeffersonheard: I suspect that 'transpose' should be useful for you somewhere... :)
11:52:32 <lilac> BMeph: read the article :) transpose makes it too strict
11:52:32 <jeffersonheard> BMeph: see blog post
11:52:52 <jeffersonheard> gah
11:52:58 <jeffersonheard> hpaste is still down
11:53:00 <jeffersonheard> where's the new one?
11:53:03 <lilac> @where hpaste2
11:53:04 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
11:53:06 <BMeph> @where hpaste2
11:53:07 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
11:53:09 <jeffersonheard> grazie
11:53:28 <BMeph> Prego. ;)
11:53:54 <jeffersonheard> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1213#a1213
11:54:08 <jeffersonheard> oh, and the nitems can go away again
11:54:10 <jeffersonheard> duh
11:54:59 <lilac> jeffersonheard: fromList . zip ordering $ vs = fromList $ zip ordering vs
11:55:13 <jeffersonheard> yes
11:55:19 <lilac> although that's a matter of taste...
11:56:50 <lilac> you want a function f : [2,3,4,1,0] |-> \(a0:a1:a2:a3:a4:[]) -> a2:a3:a4:a1:a0. presumably that's not too hard to wrote?
11:57:02 <lilac> although i can't see exactly how one would do it...
11:57:19 <lilac> (that is, without going via another data type or being > O(n)
12:11:02 <mstr> hey, about the instancing..
12:11:03 <mstr> http://pastebin.com/m9e7fb8
12:11:21 <mstr> how do you make the + operator?
12:11:27 <mauke> rewrap
12:11:36 <mauke> MyNum (value x + value y)
12:12:01 <mauke> alternatively, MyNum x + MyNum y = MyNum (x + y)
12:12:01 <jeffersonheard> but why aren't you just doing it with a newtype?
12:12:33 <mstr> newtype?
12:12:44 <jeffersonheard> newtype MyInt = MyInt Int
12:13:15 <mauke> newtype MyInt = MyInt {value :: Int} deriving (Eq, Show, Num)  -- magic
12:14:37 <mstr> because the operations need to work differently than operations in Num
12:17:04 <ehird> Hi, anyone used hSDL?
12:17:10 <ehird> % ghc --make bleep.hs
12:17:10 <ehird> Linking bleep ...
12:17:12 <ehird> /usr/bin/ld: Undefined symbols:
12:17:14 <ehird> _SDL_main
12:17:52 <mstr> @type negate
12:17:53 <lambdabot> forall a. (Num a) => a -> a
12:18:06 <pejo> ehird, that's a common question. Not sure if anyone has solved it but the channel logs should contain lots of references.
12:19:07 <ehird> pejo: how can I search the logs?
12:19:26 <mstr> ehird: I'm not sure how it works with haskell but you need to link sdlmain from other lib that libSDL
12:19:38 <ehird> mstr: hm? Like what?
12:20:02 <mstr> sdlmain.lib etc
12:20:05 <pao> what the "best" coding convention for the do notation? do go to a newline after the "do"?
12:20:12 <pejo> ehird, google for "_SDL_main site:tunes.org" or similar.
12:20:49 <ehird> pejo: two results, only one from this channel, no resolution.
12:21:01 <ehird> You must include either SDLMain.m/.h or libSDLmain in your application, because this is the code that defines SDL's entry point. If you fail to do this, it is likely that "_main undefined" will be thrown by the linker.
12:21:02 <ehird> You must give your main() procedure the following prototype:
12:21:04 <ehird> int main(int argc, char*argv[]);
12:21:06 <ehird> You must make sure the file containing your main() procedure #includes SDL.h.
12:21:06 <mstr> with cocoa you would just include sdlmain.m to your project, etc.
12:21:08 <ehird> So... it's an hSDL problem?
12:21:16 <ehird> Like, hsdl has compiled it wrong?
12:22:10 <mstr>    negate x = MyNum ( 0 - (value x) )
12:22:26 <mstr> this gives parse error. haskell syntax sure can be complex
12:22:45 <mauke> really?
12:22:56 <mauke> are you sure it's that line?
12:23:00 <mstr> parse error on input `negate'
12:23:07 <Apocalisp> Is there a general name for things like ((a -> b), a)?
12:23:33 <Apocalisp> A function together with a distinguished index
12:23:37 <mauke> mstr: then it's probably before that
12:23:55 <ehird> Lemmih: ping
12:23:58 <edbond> http://paste.lisp.org/display/74935
12:24:07 <mstr> mauke: if I comment that out then no parse error
12:24:07 <Apocalisp> (Ord a) => ((a -> b), a),  even
12:24:13 <Lemmih> ehird: pang!
12:24:21 <pao> the reason for haddock not linking to the source is becouse of a bug?
12:24:25 <paolino> mstr: indentation ?
12:24:26 <ehird> Lemmih: you made hSDL, right? :)
12:24:27 <ehird> /usr/bin/ld: Undefined symbols:
12:24:27 <ehird> _SDL_main
12:24:31 <ehird> how do I fix that error? any ideas?
12:24:38 <pao> *because
12:24:40 <Lemmih> ehird: Install Linux.
12:24:57 <ehird> uh, thanks.
12:24:59 <edbond> can someone help me?
12:25:15 <pao> edbond: what's the problem?
12:25:28 <edbond> pao: http://paste.lisp.org/display/74935
12:25:30 <Lemmih> ehird: I'm not sure how to solve that problem correctly.
12:25:44 <ehird> Lemmih: The SDL docs say you have to link with SDLmain ... does hSDL do that?
12:26:01 <asgaroth> edbond: you need to convert x to a string
12:26:03 <edbond> I'm stuck at Maybe monad
12:26:07 <asgaroth> edbond: for example with show x
12:26:15 <Lemmih> ehird: I don't know what hSDL does.
12:26:22 <asgaroth> edbond: putStrLn $ show x
12:26:36 <mstr> paolino: I think that was it
12:26:54 <Lemmih> ehird: http://darcs.haskell.org/~lemmih/hsSDL/hssdl/MACOSX
12:26:56 <asgaroth> edbond: ah and you need to convert that head of the args to an Integer with read first
12:27:04 <ehird> Lemmih: ok, thanks
12:27:06 <pao> paolino: what's your "coding style" for the do notation? do you put a \n after the "do"?
12:27:12 <eu-prleu-peupeu> hi
12:27:25 <edbond> asgaroth: it doesn't help.
12:27:28 <eu-prleu-peupeu> is there anything art related with haskell ?
12:27:31 <paolino> pao: only when lines are long
12:28:06 * pao thinks the ought to be a coding style guide for haskell...
12:28:12 <Lemmih> ehird: Sorry I couldn't be of more help.
12:28:19 <ehird> Lemmih: ok, thanks :)
12:28:43 <asgaroth> edbond: Also change the line max to max = read $ head args
12:28:52 <asgaroth> *argv
12:29:01 <mm_freak> this channel is growing exponentially
12:29:10 <mm_freak> 405 212848 -!- Irssi: New peak in #haskell@fn : 696
12:29:13 <repnop> been in the 600s for awhile now
12:29:27 <mm_freak> it's almost in the 700s
12:29:44 <mm_freak> when i first came here, which is less than a year ago, it was in the 300s
12:30:02 <mm_freak> now it's even larger than #perl
12:30:26 <mm_freak> it has yet to beat #python, but it's very close =)
12:30:37 <paolino> some languages needs a channel more than others
12:30:57 <asgaroth> paolino: By that logic, python is the most confusing language around :)
12:31:05 <edbond> asgaroth: thanks! it compiles now.
12:31:33 <paolino> I didn't state they share the reason :)
12:31:53 <repnop> most people just idle here :)
12:31:54 <mm_freak> lol
12:32:08 <repnop> ?users
12:32:09 <lambdabot> Maximum users seen in #haskell: 698, currently: 698 (100.0%), active: 17 (2.4%)
12:32:14 <repnop> 2.4% :)
12:32:16 <int80_h> I may look like I'm idling, but I'm really lurking
12:32:29 <int80_h> in fact, I have a question for the channel - prepping it now
12:32:44 <mstr> http://pastebin.com/m14d127fb
12:32:45 <Lemmih> Newbies should be counted, not heard. (:
12:32:46 <pao> I'm here too :-)
12:32:54 <mstr> now fromInteger fails
12:32:55 <asgaroth> repnop: Are there any such statistics on other channels?
12:32:59 <mstr> argh, this is hard :D
12:33:02 <mm_freak> well, #haskell is very active
12:33:03 <pao> all of you in lurking mode... do a PING! :-)
12:33:09 * int80_h cries because Lemmih made him feel bad.
12:33:14 <mm_freak> i think, the number of users isn't meaningful a lot
12:33:19 <repnop> asgaroth: no clue :)
12:33:23 <mm_freak> but there is almost always traffic in here
12:33:26 <tromp_> PING!
12:33:33 <jeffersonheard> mstr: fromIntegral
12:33:38 <asgaroth> mstr: there's a paren missing at the end
12:33:47 <pao> tromp_: thanks :-)
12:34:11 <pao> .. not so many lurkers :-)
12:34:28 <pao> @users
12:34:28 <lambdabot> Maximum users seen in #haskell: 699, currently: 697 (99.7%), active: 18 (2.6%)
12:34:29 <mstr> `fromIntegral' is not a (visible) method of class `Num'
12:34:37 <Apocalisp> @users
12:34:37 <lambdabot> Maximum users seen in #haskell: 699, currently: 697 (99.7%), active: 18 (2.6%)
12:34:45 <mle> active is a better metric, perhaps
12:35:01 <pao> mle: it does not count the lurkers
12:35:08 <mle> well yes; they aren't active
12:35:13 <pao> mle: I'm very often in lurking mode
12:35:19 <mle> shame on you!
12:35:20 <asgaroth> mstr: fromInteger is the correct name, did you add the closing parenthesis at the end?
12:35:20 <mathijs> Is there work/planning underway for a new haskell standard? I mean ghc has quite a few very useful language extensions, but 'staying standard' somehow feels better. So is there already a list of features that are planned to become standardized in time?
12:35:20 <mle> heh
12:35:42 <lament> mathijs: there's haskell'
12:36:00 <Badger> @src connectTo
12:36:01 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:36:04 <Badger> k
12:36:30 <paolino> @hoogle connectTo
12:36:31 <lambdabot> No results found
12:37:16 <Badger> huh
12:37:20 <Badger> should be in Network
12:37:33 <pao> mathijs: http://video.google.com/videoplay?docid=5177116830079185902
12:37:36 <mstr> asgaroth: yea, http://pastebin.com/m5ba5149c
12:37:37 <mathijs> lament: haskell' ?
12:37:42 <Badger> @src newStdGen
12:37:43 <lambdabot> Source not found. Are you on drugs?
12:37:52 * Badger sighs and looks them up properly
12:38:11 <mathijs> pao: thanks :)
12:38:14 <lament> mathijs: haskell'.
12:38:17 <paolino> 700 people 1 $ each , we can ask someone to fix @src on this offensive bot ...
12:38:59 <pao> mathijs: no prob :-)
12:39:05 <geezusfreeekwork> @users
12:39:06 <lambdabot> Maximum users seen in #haskell: 699, currently: 697 (99.7%), active: 22 (3.2%)
12:39:14 <geezusfreeekwork> oh dang
12:39:41 <asgaroth> mstr: Ah, that's because value is an Int. So you need to run fromIntegral on it
12:40:14 <Apocalisp> Is there a name for the ((a -> b), a) comonad? Sorry to repeat.
12:40:53 <Apocalisp> (looking for a googlable string)
12:41:07 <Badger> @hoogle MTGen
12:41:08 <lambdabot> No results found
12:41:16 <mstr> asgaroth: like fromInteger x = MyNum (fromIntegral (value x)) ?
12:41:54 <jeffersonheard> @hoogle ((a -> b), a)
12:41:54 <lambdabot> No results found
12:41:55 <Eridius|lappy> Apocalisp: you mean change the first part of a tuple?
12:42:05 <Eridius|lappy> Apocalisp: you might want Control.ARrow
12:42:08 <Eridius|lappy> *ARrow
12:42:09 <Eridius|lappy> *Arrow
12:42:55 <Axman6> Badger: that's dons' mersenne-twister random library right?
12:42:56 <asgaroth> mstr: Ah, I misunderstood: x is the Integer not a MyNum so just MyNum (fromInteger x) should do it
12:43:02 <Badger> Axman6: indeed
12:43:29 <Apocalisp> Eridius: A function together with a distinguished input value. For example, a time-variable signal together with the current time.
12:43:31 <beelsebob> asgaroth: or provide a Num instance for MyNum
12:43:40 <mstr> asgaroth: (fromInteger x) or (fromInteger value x) ?
12:43:45 <beelsebob> (presumably with fromIntegral = MyNum)
12:43:59 <paolino> value is not a function for x
12:44:17 <mstr> beelsebob: that's what I'm trying to do
12:44:35 <mstr> http://pastebin.com/m14d127fb
12:44:38 <Eridius|lappy> Apocalisp: I guess I don't understand what you're doing. I'm still a neophyte in a lot of respects for Haskell
12:44:54 <chessguy_work> so what would happen if we had a library like UnsafeRandoms that had a function next :: Int which used unsafePerformIO to always generate a new random number?
12:45:21 <paolino> mstr: fromInteger = MyNum should do
12:45:25 <chessguy_work> how much harm would be done?
12:45:38 <dolio> It wouldn't work.
12:45:42 <dolio> It'd have to be next :: () -> Int
12:46:00 <chessguy_work> ok
12:46:14 <mstr> paolino: that says: Couldn't match expected type `Integer' against inferred type `Int'
12:46:31 <chessguy_work> so what would happen if we had a library like UnsafeRandoms that had a function next :: () -> Int which used unsafePerformIO to always generate a new random number?
12:46:38 <paolino> @src Num
12:46:38 <lambdabot> class  (Eq a, Show a) => Num a  where
12:46:39 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:46:39 <lambdabot>     negate, abs, signum     :: a -> a
12:46:39 <lambdabot>     fromInteger             :: Integer -> a
12:47:08 <Cheshire> chessguy_work, just use ocaml or sml or something
12:47:23 <beelsebob> mstr: http://pastebin.com/m220befbe this?
12:47:29 <asgaroth> I think it should be fromInteger = MyNum . fromIntegral since the type inside MyNum is Int
12:47:29 <paolino> :t fromIntegral
12:47:31 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:47:59 <mathijs> I read about the RULES file for ghc, do the rules that I put there mandate the compiler to apply them? or is it just a hint that can help it optimize?
12:48:11 <paolino> asgaroth: right
12:48:11 <mstr> beelsebob: what does "on" mean?
12:48:18 <beelsebob> @type on
12:48:20 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:48:39 <chessguy_work> Cheshire, really? it's that bad?
12:48:42 <beelsebob> > ((+) `on` read) "876" "81"
12:48:43 <lambdabot>   957
12:48:50 <Cheshire> It's impure
12:49:00 <chessguy_work> yes, i'm aware of that
12:49:20 <chessguy_work> but it's also clearly marked off as such, with well-known semantics
12:49:43 <Cheshire> that's why it makes sense in languages like ocaml
12:49:59 <chessguy_work> you're begging the question
12:50:34 <Cheshire> I stop bothering to try and answer your question now
12:50:43 <drhodes> filter  (isSpace ..(or.compose).. isAlpha)  "as12 #$%as"  -- is there a way to OR compose?
12:51:12 <mauke> :t any
12:51:13 <chessguy_work> @pl \x -> isSpace x || isAlpha x
12:51:13 <lambdabot> liftM2 (||) isSpace isAlpha
12:51:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:51:25 <chessguy_work> blech
12:51:28 <beelsebob> isSpace <^(||)^> isAlpha
12:51:52 <chessguy_work> heh. looks like disjunction with a gun show :)
12:52:03 <beelsebob> hehe
12:52:04 <mauke> :t or . sequence [isSpace, isAlpha]
12:52:05 <lambdabot> Char -> Bool
12:52:10 <drhodes> looks like a vampire to me .. ;)   :E
12:52:11 <ehird> Lemmih: got it working... If anyone's interested, here's how you use hSDL on OS X: http://pastie.org/private/b4humfcteprzojcrqhcq
12:52:27 <chessguy_work> Cheshire, sorry, maybe my question isn't clear. i throught you were brushing me off. let me try again
12:52:31 <mauke> > filter (or . sequence [isSpace, isAlpha]) "as12 $#%as"
12:52:33 <lambdabot>   "as as"
12:52:35 <beelsebob> > fmap fmap fmap sequence fmap (pure . (+5)) [1,2,3,4,5] :: Maybe [Int]
12:52:37 <lambdabot>       Ambiguous occurrence `pure'
12:52:37 <lambdabot>      It could refer to either `Control.Appl...
12:52:43 <beelsebob> > fmap fmap fmap sequence fmap (return . (+5)) [1,2,3,4,5] :: Maybe [Int]
12:52:45 <lambdabot>   Just [6,7,8,9,10]
12:52:47 <beelsebob> >.>
12:52:50 <drhodes> mauke: thanks a bunch!
12:52:53 <mauke> needs more fmap
12:53:08 <mauke> > fmap fmap fmap sequence fmap (fmap return (+5)) [1,2,3,4,5] :: Maybe [Int]
12:53:09 <lambdabot>   Just [6,7,8,9,10]
12:53:11 <chessguy_work> my question is, what guarantees would we not get from the language if we had modules which kept impurity sectioned off from pure code, that we get from the language now
12:53:16 <beelsebob> mauke: ohhh, nice
12:53:23 <Lemmih> ehird: Interesting.
12:53:38 <ehird> Lemmih: yeah, the important part is in main.c you include SDL.h then type main
12:53:45 <ehird> which makes SDL rewrite that to SDL_main
12:53:51 <ehird> then you can call your haskell program via th e ffi
12:55:17 <mstr> @type on
12:55:18 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:56:58 <mstr> is there a way to find a module by function name?
12:57:39 <paolino> http://haskell.org/hoogle
12:57:42 <Botje> ask hoogle
12:57:48 <Cale> Did anyone see the google suggest results for "I am extremely"? :)
12:58:24 <Axman6> yep
12:58:45 <mstr> thx
12:58:47 <Axman6> i liked the "google suggest is" -> "google suggest is not working"
12:59:11 <Cale> heh
13:00:07 <Axman6> it was the only suggestion too
13:00:35 <Axman6> Cale: did you see the "how to beat your" one? that was a little scare
13:00:45 <Axman6> 14 million results for kids...
13:01:47 <mstr> beelsebob: nah, didn't work
13:02:20 <Cale> Axman6: whoa.
13:02:57 <Axman6> anyway, i must be off. heading up to sydney for top gear live :D
13:03:31 <ehird> @hoogle IO ()
13:03:32 <lambdabot> Distribution.Make defaultMain :: IO ()
13:03:32 <lambdabot> Distribution.Simple defaultMain :: IO ()
13:03:32 <lambdabot> System.Mem performGC :: IO ()
13:03:41 <ehird> I guess that is not the best way to search for "Just Exit" :-)
13:03:54 <trofi> @hoogle exitWith
13:03:55 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
13:04:06 <trofi> @hoogle ExitSuccess
13:04:07 <lambdabot> System.Exit ExitSuccess :: ExitCode
13:04:11 <trofi> @hoogle ExitFailure
13:04:12 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
13:04:12 <lambdabot> System.Exit exitFailure :: IO a
13:04:27 <ehird> thanks
13:04:37 <eu-prleu-peupeu> is there anything art related with haskell ?
13:04:48 <ehird> tons
13:05:21 <Axman6> eu-prleu-peupeu: check out Clem Baker-Finch, i think he's used it for some. he was my first comp lecturer
13:06:23 <conal> BMeph: pong
13:07:04 <eu-prleu-peupeu> conal: are you art related ?
13:07:31 <conal> eu-prleu-peupeu: ??
13:07:39 <conal> isn't everyone?
13:07:43 <Axman6> of course, conal is beautiful :P
13:07:48 <eu-prleu-peupeu> :)
13:07:53 <eu-prleu-peupeu> ok
13:07:55 * Axman6 leaves before any more strange looks
13:07:58 <Badger> conal is a functional artist :P
13:08:05 * Badger looks strangely at Axman6 
13:08:09 <eu-prleu-peupeu> eheheh
13:08:23 <conal> :)
13:08:29 <roconnor> I should just write a simple 2-d geometry lib and upload it to hackage.
13:08:36 <conal> Axman6: thanks!  (blushes)
13:09:03 <eu-prleu-peupeu> im looking for someone that can teach art, and haskell at the same time :D
13:09:25 <conal> eu-prleu-peupeu: neat.  to whom & where?
13:09:36 <roconnor> hmm I have a friend with a degree in CS and a minor in fine art
13:09:46 <roconnor> but he doesn't know haskell yet. :(
13:10:25 <eu-prleu-peupeu> well, no big deal... these scholarship's came out in my country, for people to go out and learn with some artist/artistic company
13:10:37 <eu-prleu-peupeu> they fund everything, anywhere in the world...
13:11:03 <cknapp> Does Haskell have support for data structures defined by each other? E.g. newtype BinHeap a = [BinTree a]; BinTree a = Tree Int a BinHeap
13:11:06 <eu-prleu-peupeu> since im going to a art school now, i can try to get one...
13:11:12 <eu-prleu-peupeu> thats about it :/
13:11:16 <mauke> cknapp: sure
13:11:20 <Cale> cknapp: yes, there's no problem with that
13:11:23 <roconnor> @faq Does Haskell have support for data structures defined by each other? E.g. newtype BinHeap a = [BinTree a]; BinTree a = Tree Int a BinHeap
13:11:24 <lambdabot> The answer is: Yes! Haskell can do that.
13:11:42 <cknapp> thanks
13:11:50 <cknapp> Also, I love lambdabot
13:12:16 <pao> @faq can ghc cook?
13:12:17 <lambdabot> The answer is: Yes! Haskell can do that.
13:12:18 <roconnor> if you love lambdabot type "@karma+ lambdabot"
13:12:27 <mauke> no, type "lambdabot++"
13:12:32 <conal> eu-prleu-peupeu: they're art scholarships, while not disallowing things like programming?  or they encourage programming?
13:12:34 <roconnor> oh right
13:12:37 <roconnor> what mauke said
13:12:43 * pao thinks lambdabot is cheating :-)
13:12:44 <cknapp> lambdabot++
13:12:49 <mauke> that way other bots will also listen :-)
13:13:04 <roconnor> oh
13:13:13 <roconnor> @karma lambdabot
13:13:13 <lambdabot> lambdabot has a karma of 2
13:13:29 <mauke> preflex: karma lambdabot
13:13:30 <preflex>  karma for lambdabot: 3
13:13:37 <mauke> :-|
13:14:05 <eu-prleu-peupeu> conal, well its a very broad spectrum, they say like "Visual artists", "Performative Arts", "Audiovisual", "Multimedia"... and they require computer know-how in their selection process (only 200 positions available)
13:14:19 <cknapp> So... what's the syntax? I'm messing something up (I might just have data declarations wrong)
13:14:42 * BMeph agrees, that " Badger looks strangely"
13:14:54 <conal> eu-prleu-peupeu: cool scholarship!
13:15:00 <cknapp> I have: newtype BinHeap a = [BinTree a] deriving (Show, Eq, Ord); {semi-colon = newline, here} data BinTree a = Tree Int a (BinHeap a) deriving (Show, Eq, Ord)
13:15:10 <mauke> cknapp: semicolon also works
13:15:18 <cknapp> Oh... right.
13:15:19 <mauke> cknapp: your BinHeap newtype is missing a constructor name
13:15:20 <cknapp> I forgot about that.
13:15:31 <mauke> did you mean 'type'?
13:15:36 <eu-prleu-peupeu> conal: yeh, its a political move that didn't went quite as expected... because the organizations they were expecting to host the students didn't show up... so its up to the people who want the scholarship to get them...
13:17:36 <cknapp> Hurray! Thanks mauke. (I did mean type)
13:17:50 <cknapp> Not like it really makes a difference...
13:18:16 <conal> eu-prleu-peupeu: maybe the plans were made before the economic melt-down.
13:19:34 <eu-prleu-peupeu> hmm, maybe yes
13:20:45 <eu-prleu-peupeu> in the 1st day 300 appliances showed up
13:21:11 <FliPPeh> 300 spartans?
13:21:34 <eu-prleu-peupeu> :)
13:22:22 <FliPPeh> I don't know what to concentrate on, you must help me!
13:22:38 <Badger> FliPPeh: life, the universe and everything
13:22:44 <FliPPeh> 1) Fixing my Arch installation, 2) Learning Haskell, 3) Playing games, 4) My Girlfriend
13:23:04 <conal> FliPPeh: wow -- four great choices!
13:23:10 <FliPPeh> 2 would cancel out all others :(
13:23:32 <eu-prleu-peupeu> conal, it is not quite a scholarship, it is more like a "go work somewhere else in the world, and then come back and work in your country with the knowledge you earned" kind of funding
13:23:34 <Mortomes> FliPPeh: Learn haskell together with your girlfriend
13:23:41 <eu-prleu-peupeu> Mortomes: ahahah
13:23:55 <eu-prleu-peupeu> while playing games
13:23:56 <eu-prleu-peupeu> :)
13:24:01 <Mortomes> Exactly
13:24:06 <cknapp> And, put Arch on her machine!
13:24:07 <conal> FliPPeh: design and implement a game in haskell in which your gf is the protagonist and her evil twin is the antagonist.  get it running on arch.
13:24:18 <FliPPeh> DEAL!
13:24:24 <Mortomes> Your girlfriend is female, she can help you with the multitasking thing I'm sure
13:24:34 <FliPPeh> parallelism?
13:25:08 <lament> females good at multitasking?
13:25:10 <FliPPeh> She is "dual core" *hint hint nudge nudge*
13:25:26 <Mortomes> haha
13:25:29 <cknapp> ...
13:25:49 <roconnor> what's the deal about Arch?
13:26:01 <FliPPeh> suspend hates me
13:26:12 <FliPPeh> It puts my laptop in standy...
13:26:17 <FliPPeh> and I can wake it up!
13:26:22 <FliPPeh> But monitor will stay blank
13:26:27 <MyCatVerbs> roconnor: Arch Linux? It's a rolling-release distro with almost nothing set up by default. Also, pacman is nicer than apt-get, IMO.
13:26:32 <FliPPeh> I can still SSH to it, tho...
13:26:52 <MyCatVerbs> roconnor: roughly similar set of advantages and disadvantages to that you get with, say, Gentoo, but slightly less so. ^^
13:27:03 <FliPPeh> It's Gentoo without steroids
13:27:06 <roconnor> MyCatVerbs: non-binary distro?
13:27:16 <FliPPeh> You don't get to compile your own awesomeness
13:27:21 <FliPPeh> But get precompiled awesomeness
13:27:29 <roconnor> oh
13:27:35 <roconnor> what are the advantages of Gentoo?
13:27:41 <FliPPeh> But it doesn't come with any desktop
13:27:48 <FliPPeh> Nothing preconfigured
13:27:57 <roconnor> ...
13:27:59 <MyCatVerbs> roconnor: no, but you get roughly half the advantages. :)
13:28:00 <lament> roconnor: i dare you go to #gentoo and ask that
13:28:12 <cknapp> So... you put xmonad and gnome on it... together :)
13:28:15 <roconnor> can you explain how nothing preconfigured is a good thing?
13:28:16 <FliPPeh> With gentoo you can compile your own stuff, and optimize it
13:28:17 <cknapp> and life is good.
13:28:21 <FliPPeh> I got XMonad!
13:28:22 <lament> the advantage of gentoo is that when stuff breaks you know it's your own fault
13:28:23 <joga> roconnor, you can customize it with finer granularity...
13:28:24 <FliPPeh> \o/
13:28:28 <lament> the disadvantage of gentoo is that stuff breaks
13:28:29 <cknapp> roconnor: you do it all your way.
13:28:35 <roconnor> ah
13:28:37 <conal> FliPPeh: i have a the problem with my laptop & standby.  sometimes i get video on wake-up and sometimes not.  i had the same issue under windows xp, so i guess it's not the OS.  i have an asus.  you?
13:28:47 <roconnor> sounds like Arch / Gentoo isn't for me
13:28:49 <FliPPeh> Dell Vostro 1310
13:28:52 <FliPPeh> But Windows works
13:29:03 <MyCatVerbs> roconnor: it was one of the first distros to be compiled i686 rather than i486.
13:29:13 <cknapp> But, Arch actually gives you the tools and support to get stuff configured unlike Gentoo...
13:29:13 <FliPPeh> But for me, it's 100% failure rate
13:29:15 <FliPPeh> No bug
13:29:21 <MyCatVerbs> roconnor: plus, there are no -dev packages. If you install libfoo, you get foo.h as well as libfoo.so.
13:29:25 <yitz> the disadvantage of gentoo is that you wear out your computer with constant compiling
13:29:31 <eu-prleu-peupeu> desktop things are so much better :/
13:29:45 <yitz> but you sure get a nicer set up in between compiles
13:29:46 <roconnor> how is pacman better than aptitude?
13:30:17 <dancor> so liftM = fmap = <$>
13:30:19 <MyCatVerbs> roconnor: the end result is that, even though you rarely have to, you *can* compile anything - and they provide install scripts roughly analogous to ebuilds for everything they ship binaries for.
13:30:47 <roconnor> MyCatVerbs: I see
13:31:19 <roconnor> MyCatVerbs: but Debian-like has source packages, or are you saying that that isn't good enough?
13:31:21 <mauke> :t [liftM, liftA, fmap, (<$>), (.)]
13:31:23 <lambdabot> forall a1 r a. [(a1 -> r) -> (a -> a1) -> a -> r]
13:31:24 <MyCatVerbs> roconnor: it has better searching facilities - effectively both apt-cache and apt-file are built in, nicely. Aside from that, rather terser invocation syntax. I'm not sure whether it's quicker or not. I -think- it is, a little, but it doesn't actually matter in practice. What portion of your computer's lifetime is spent waiting for apt anyway?
13:31:55 <roconnor> MyCatVerbs: I have found searching in Aptitude pretty easy.
13:31:59 * dancor built a wrapper when he switched from gentoo to debian
13:31:59 <MyCatVerbs> roconnor: talk later.
13:31:59 <joga> source packages are one thing, a system designed to configure them is another
13:32:13 <yitz> MyCatVerbs: but if you decide to compile something to change something, does that automatically propagate to other pkgs as well? and does it tell which others also need to be compiled now?
13:32:15 <roconnor> Although learning aptitude was a big pain
13:32:20 <FliPPeh> Offtopic question: how many partitions can I have at max? 4 primary, but how many logical?
13:32:30 <FliPPeh> I'm at sda7 now
13:32:38 <FliPPeh> Enough place for another distro?
13:32:39 <dancor> http://dzl.no-ip.org:81/gitweb/?p=dancomp.git;a=blob;f=bin/gen/ag
13:32:46 <cknapp> yitz: yes.
13:32:56 <yitz> nice
13:33:35 <cknapp> yitz: I've found that pacman plays nicer than other package managers I've used... but I know very little, so my impressions with a grain of salt. (Or a teaspoon)
13:33:50 <FliPPeh> Or a truck
13:33:52 <cknapp> *so take*
13:34:02 <FliPPeh> I like pacman
13:34:08 <FliPPeh> Not only because of it's name
13:34:24 <joga> FliPPeh, I think you can have 60 logical partitions but not sure..
13:34:29 <FliPPeh> \o/
13:34:39 <FliPPeh> I might want to get rid of windoze
13:34:52 <yitz> FliPPeh: if you accidently eat a blinking pkg, then you have to run away quickly?
13:35:14 <FliPPeh> If it's looking like a ghost, then yes, run like hell
13:35:28 <FliPPeh> Only visible in a gui frontend, tho
13:35:31 <FliPPeh> So beware!
13:35:35 <dancor> it's too bad that to get as large as #linux we also had to turn into it
13:35:53 <FliPPeh> Better reach for #ubuntu
13:36:03 <FliPPeh> GNU/Linux -> Windows/Linux
13:36:13 * FliPPeh ducks and covers
13:36:24 <cknapp> Hmm...
13:36:24 <mauke> no quack!
13:36:35 <roconnor> there are a lot of strange packages on hackage
13:36:38 <FliPPeh> Duck typing
13:36:43 <roconnor> turing-music program: Plays music generated by Turing machines with 5 states and 2 symbols
13:37:20 <dancor> the notes better be configurable!
13:37:27 <dancor> or i'm not using it
13:38:01 <joga> FliPPeh, actually, scratch that, I'm not sure if there is some limit to no. of logical partitions, I seem to remember that they're just linked together. the OS may have some restrictions (such as the amount of drive letters in windoze)
13:38:03 <lament> roconnor: lol?
13:38:20 <FliPPeh> I wonder what happens if you reach Z
13:38:27 <FliPPeh> Will a gate to another dimension open?
13:38:28 <joga> heh, I didn't even realize this was #haskell
13:38:34 <roconnor> @hackage turing-music
13:38:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/turing-music
13:38:42 <joga> FliPPeh, I suspect that windows just won't show you more partitions
13:38:56 <FliPPeh> Boring
13:38:59 <dancor> well that's fine right, hackage is supposed to have everything and surfacing the general stuff is a separate issue
13:39:04 <joga> ...since giving them letters is dumb to begin with
13:39:06 <FliPPeh> I want to restart at AA:\\
13:39:10 <FliPPeh> AB:\\
13:39:14 <mauke> Ä: Ò: Ñ:
13:39:24 <FliPPeh> \r\n:\\
13:39:24 <cknapp> Should I do a safety check for merging Binomial Trees (making sure they have the same rank), or should I not export my merge function, and write my code correctly? If I do the check, should I store the rank of each tree, or just calculate it on the fly?
13:39:27 <mauke> Σ:
13:39:35 <dancor> g\rÄÒÑ
13:40:06 <FliPPeh> mv mauke /dev/null
13:40:16 <cknapp> Hurray! :D
13:40:26 <dancor> cknapp: idk but generally you err on the side of safety with generic apis maybe..
13:40:45 <mauke> mv: inter-device move failed: `mauke' to `/dev/null'; unable to remove target: Permission denied
13:40:49 <cknapp> dancor: I'm writing it for the sake of writing it... I don't expect any to use it, God forbid!
13:41:01 <dancor> just file it under Games in hackage
13:41:24 * roconnor isn't sure what cabal fetch just did
13:41:49 <FliPPeh> What permissions
13:41:56 <FliPPeh> chmod +666 FliPPeh
13:42:03 <cknapp> "Check out the newest game by Knapp Studios: Binomial Heap! Exhilarating O(1) action!"
13:42:25 * cknapp doesn't think that will be a very popular game...
13:42:30 <dancor> haskell has a way of getting you to later fix the incorrectnesses you left along the way.  why fight it
13:42:56 <BMeph> cknapp: A key philosophy of Haskell is: If you're not going to use it, why do you expect is to be calculated? :)
13:43:25 <Badger> chmod: changing permissions of 'FliPPeh': Operation not permitted
13:43:27 <cknapp> BMeph: Huh?
13:43:29 <FliPPeh> That's my excuse for school
13:43:34 <FliPPeh> If I don't need it, why do it?
13:43:44 <FliPPeh> Lazy learning
13:43:47 <redditbot> citeproc-hs - A Haskell Implementation of the Citation Style Language
13:44:01 <dancor> that's fine as long as you actually need anything
13:44:07 <FliPPeh> [citation needed]
13:44:50 <yitz> let's change the name of "seq" to "exams"
13:44:55 <FliPPeh> Wait, our topic is a list?
13:45:07 <mauke> always has been
13:45:11 <FliPPeh> :|
13:45:17 <yitz> channelTopic :: [String]
13:45:21 <lament> a list of lists even
13:45:30 <dancor> it's actually a ("x " ++) . show
13:45:46 <dancor> oh nm irssi adds the x
13:45:48 <FliPPeh> let topic = ["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]
13:45:49 <geezusfreeekwork> roconnor, Arch, in a nutshell, is about making it as easy as possible to control everything that goes on in your system, and that's about it
13:45:51 <FliPPeh> Meh!
13:46:04 <geezusfreeekwork> i use arch and love it, but it's not for everyone
13:46:14 <FliPPeh> geezusfreeekwork
13:46:20 <FliPPeh> Tell me how to fix my suspend!
13:46:26 <FliPPeh> Monitor will not turn back on ;<
13:46:31 <geezusfreeekwork> ew
13:46:46 <geezusfreeekwork> i do not know :P
13:46:46 <FliPPeh> You say it buddy
13:47:01 <FliPPeh> Meh!
13:47:02 <BMeph> FliPPeh: Take it to the vet, they'll usually fix things for about $60... ;p
13:47:07 <FliPPeh> I'm not gonna use it then
13:47:12 <geezusfreeekwork> woops
13:47:12 <FliPPeh> Hibernation works, tho
13:47:56 <FliPPeh> Do you think they'll believe me if I tell them arch is a rare species of linuxidia distributionia?
13:48:01 <geezusfreeekwork> i did not have a similar issue myself. can't help you, sorry :\
13:49:04 * roconnor tries play Monadius
13:49:21 <roconnor> Although learning aptitude was a big  pain
13:49:44 <FliPPeh> KDE or GNOME?
13:49:51 <FliPPeh> What do YOU prefer?
13:49:55 <geezusfreeekwork> xmonad
13:49:56 <roconnor> KDE
13:49:59 <roconnor> or rather
13:50:03 <roconnor> Not GNOME
13:50:13 <FliPPeh> XMonad/Gnome here
13:50:17 <cknapp> xmonad/Gnome at the moment... but I need to do some playing...
13:50:26 <Philonous> Why not gnome?
13:50:29 <geezusfreeekwork> i did the whole xmonad/gnome thing, but realized i never used the gnome stuff
13:50:30 <FliPPeh> I like the idea of tiling WMs
13:50:49 <FliPPeh> And using XMonad could help me improve my haskell magic
13:51:19 <geezusfreeekwork> eh, configuring xmonad seems to involve little to no haskell skill unless you really really customize things
13:51:43 <cknapp> geezusfreekwork: I sue Gnome right now becuase the eyecandy is easier...
13:51:46 <afreude1> hi, I'm learning Haskell, can anyone tell me anything about it?
13:51:51 <FliPPeh> Compiz!
13:51:55 <mmorrow> oh yesh!
13:52:20 <cknapp> s/sue/use
13:52:24 <mmorrow> i prefer to be inside the cube, rather than outside
13:52:24 <FliPPeh> You're in #haskell
13:52:33 <FliPPeh> Of course we can tell you about haskell
13:52:39 <afreude1> well, yeah that's why I asked..
13:52:40 <afreude1> :)
13:52:47 <cknapp> What do you want to know?
13:52:58 <geezusfreeekwork> afreude1, most of us can :)
13:53:00 <FliPPeh> Learning curve
13:53:56 <afreude1> I don't know what I want to know exactly....
13:54:19 <FliPPeh> Haskell is a pure, lazy functional programming language
13:54:19 <geezusfreeekwork> afreude1, "Haskell is awesome!" stuff like that? ;)
13:54:22 <geezusfreeekwork> we have plenty of that
13:54:30 <FliPPeh> It's fun as long as you know how to!
13:54:45 <geezusfreeekwork> @faq Can Haskell cure cancer?
13:54:46 <lambdabot> The answer is: Yes! Haskell can do that.
13:55:05 <FliPPeh> Cure :: Cancer -> NoCancer
13:55:28 <cknapp> @faq Can Haskell answer the question to life the universe and everything?
13:55:28 <FliPPeh> How can I display my battery fullness in XMonad?
13:55:28 <lambdabot> The answer is: Yes! Haskell can do that.
13:55:29 <Badger> Not in scope: data constructor 'Cure'
13:55:38 <roconnor> @djinn cancer -> Not cancer
13:55:39 <lambdabot> -- f cannot be realized.
13:55:42 <roconnor> :(
13:55:43 <geezusfreeekwork> proof of this proposition is left as an exercise for the reader
13:55:52 <dino-> FliPPeh: I've been using xmobar for status bar with xmonad.
13:56:06 <dino-> Yes! xmobar can do that
13:56:13 <geezusfreeekwork> i have been using xmobar as well, but i'm thinking about playing with conky a bit
13:56:22 <burton_> hello world
13:56:32 <afreude1> I can make a powerset from a list, but that's about it
13:56:36 <cknapp> hello, burton.
13:57:12 <geezusfreeekwork> burton_, We are not world. We are #haskell. We are side-effect free!
13:57:56 * cknapp doubts geezusfreeek's claims...
13:58:07 <cknapp> hanging out here has greatly changed my state of mind...
13:58:22 <wchogg> If we're side effect free, I think that's equivalent to calling us all useless.
13:58:39 <burton_> I'm trying to get to learn Haskell and reading learnyouahaskell.com but I'd like to have some exercises to practice, anything you guys can advice me?
13:58:40 <cknapp> whogg: I think pointless is more correct. :)
13:58:55 <geezusfreeekwork> point free?
13:58:57 <cknapp> burton_: what do you know?
13:59:03 <nikki93> I've decided to learn assembly programming. :)
13:59:15 <burton_> cknapp: about haskell or progamming in general?
13:59:20 <cknapp> geezusfreeek: that was the point...
13:59:27 <cknapp> burton_: both, I guess
13:59:55 <jre2> nikki93: which arch?
14:00:12 <cknapp> burton_: how far into Learnyouahaskell are you?
14:00:21 <yitz> burton_: project euler
14:00:40 <afreude1> project Euler is confusing in Scheme
14:00:44 <burton_> cknapp: about haskell not so much, I got interessed in it a few days ago only, and about programming I mostly know some C and C++
14:00:51 <cknapp> Not in haskell! :)
14:00:56 <geezusfreeekwork> cknapp, then you are not point free
14:01:12 <burton_> cknapp: syntax-in-functions now
14:01:23 <burton_> yitz: mmmh why not, that could be a good idea
14:01:44 <cknapp> burton: it's how I got comfortable with the basics. And it's fun!
14:01:51 <yitz> burton_: it's fun in Haskell
14:02:01 <geezusfreeekwork> i personally do not recommend project euler to learn haskell. it doesn't lend itself well to learning the awkward squad
14:02:25 <znutar> project euler is great for getting haskell list comprehensions down though
14:02:32 <geezusfreeekwork> znutar, quite
14:02:38 <roconnor> @hoogle (a -> a -> Ordering) -> [a] -> [a]
14:02:41 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
14:02:41 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:02:41 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
14:02:44 <yitz> geezusfreeekwork: ok, you learn that with other exercises
14:02:45 <burton_> cknapp: with project euler or learnyouahaskell?
14:02:46 <cknapp> and for a few of the other basic things, and the way functions work in haskell...
14:02:52 <roconnor> @hoogle (a -> a -> Ordering) -> [a] -> [[a]]
14:02:53 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
14:02:53 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:02:53 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
14:03:20 <cknapp> burton_: Euler; although I did read learnyouahaskell at some point. I'm trying to think of fun "exercises"
14:03:22 <nikki93> jre2: x86 intel
14:03:26 <roconnor> @type \c l -> groupBy c (sortBy c l)
14:03:27 <lambdabot>     Couldn't match expected type `Ordering'
14:03:28 <lambdabot>            against inferred type `Bool'
14:03:28 <lambdabot>       Expected type: a -> a -> Ordering
14:04:03 <roconnor> @type \c l -> groupBy (((==EQ) .) . c) (sortBy c l)
14:04:05 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [[a]]
14:04:17 <geezusfreeekwork> what is the name of that blog article that has several haskell function types and you are supposed to fill in the implementation? that was pretty nice
14:04:35 <roconnor> @pl \c l -> groupBy (((==EQ) .) . c) (sortBy c l)
14:04:36 <lambdabot> ap ((.) . groupBy . (((EQ ==) .) .)) sortBy
14:04:45 <afreude1> Project Euler in Haskell seems almost too easy though.
14:05:10 <cknapp> afreude1: how clean are your solutions?
14:05:28 <jre2> nikki93: oh.  have you learned other archs before? x86 is exactly fun to dive into
14:05:30 <jre2> isn't*
14:05:42 <afreude1> cknapp: better than yours
14:05:55 <cknapp> ... Aren't you glad you're sitting next to me? :)
14:06:52 <Olathe> > 5
14:06:53 <cknapp> burton_: have you learned folds yet?
14:06:54 <lambdabot>   5
14:08:16 <burton_> cknapp: it don't think so, the term doesn't seem familiar to me
14:08:17 <Guenni> anybody here using ihc.exe for generating haskell stubs?
14:08:34 <yitz> @type foldr
14:08:36 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:08:38 <cknapp> burton_: Basically, it's a way of accumulating down a list.
14:08:41 <yitz> @src foldr
14:08:42 <lambdabot> foldr f z []     = z
14:08:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:08:51 <cknapp> > foldr (+) 0 [1..5]
14:08:53 <lambdabot>   15
14:09:15 <yitz> @type foldl -- but use foldl' really
14:09:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:09:22 <yitz> @src foldl
14:09:22 <lambdabot> foldl f z []     = z
14:09:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:09:56 <yitz> foldl' is the same, except with the correct strictness. it's in Data.List
14:09:56 <cknapp> burton_: it should now be incredibly clear, and you should have no questions. :)
14:10:22 <yitz> @src reverse
14:10:23 <lambdabot> reverse = foldl (flip (:)) []
14:10:28 <burton_> cknapp: i think i understand the concept now
14:10:55 <yitz> @src sum
14:10:56 <lambdabot> sum = foldl (+) 0
14:10:57 <cknapp> burton_: now you need to learn to grok it.
14:11:06 <yitz> @src product
14:11:07 <lambdabot> product = foldl (*) 1
14:11:39 <yitz> @src (++)
14:11:40 <lambdabot> []     ++ ys = ys
14:11:40 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:11:40 <lambdabot> -- OR
14:11:40 <lambdabot> xs ++ ys = foldr (:) ys xs
14:11:45 * cknapp isn't getting anything done...
14:12:02 <tromp_> > foldr (foldr (:)) "" [" it"," grok"," to"," learn"," to"]
14:12:03 <lambdabot>   " to learn to grok it"
14:12:21 <cknapp> tromp: you forgot an "is"
14:12:31 <BMeph> geezusfreeekwork: You mean: http://blog.tmorris.net/20-intermediate-haskell-exercises/
14:12:33 <Olathe> @src (++)
14:12:34 <lambdabot> []     ++ ys = ys
14:12:34 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:12:34 <lambdabot> -- OR
14:12:34 <lambdabot> xs ++ ys = foldr (:) ys xs
14:14:03 <tromp_> can we write last iin terms of foldr?
14:14:31 <cknapp> tromp_: is it primitive recursive?
14:14:32 <Olathe> Yes, but it's evil.
14:15:03 <nikki93> jre2: Nope. But that's the one I have. I'm thinking either nasm or fasm. What do you think?
14:15:04 <tromp_> just how evil:-?
14:15:27 <Olathe> Well, you have to use fromJust or something.
14:15:46 <Olathe> @type foldr
14:15:47 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:16:28 <Botje> > foldr mplus mempty [1..10] :: Last int
14:16:29 <chessguy_work> BMeph, that looks like fun
14:16:30 <lambdabot>       No instance for (MonadPlus Last)
14:16:30 <lambdabot>        arising from a use of `mplus' a...
14:16:33 <Olathe> > foldr (\el ac -> mplus ac (Just el)) Nothing [1..10]
14:16:35 <lambdabot>   Just 10
14:16:41 <Olathe> > fromJust . foldr (\el ac -> mplus ac (Just el)) Nothing [1..10]
14:16:43 <lambdabot>   Couldn't match expected type `(->) a' against inferred type `Maybe'
14:16:43 <Botje> > foldr mappend mempty [1..10] :: Last int
14:16:44 <lambdabot>       Could not deduce (Enum (Last int)) from the context ()
14:16:45 <lambdabot>        arising f...
14:16:46 <Olathe> > fromJust $ foldr (\el ac -> mplus ac (Just el)) Nothing [1..10]
14:16:48 <lambdabot>   10
14:16:49 <Botje> silly :/
14:16:56 <burton_> BMeph: thanks for the url, i'm gonna give a look at those
14:17:09 <Botje> > foldr mappend mempty [1..10] :: Last Int
14:17:10 <lambdabot>       No instance for (Enum (Last Int))
14:17:11 <lambdabot>        arising from the arithmetic se...
14:17:14 * Botje gives up
14:18:28 <dpiponi_> Theorems for Free is presented as a CS thing. But I think it's really a category theoretical thing with nothing specifically CS about it. Is there a good paper on this point of view? (If it is in fact a sensible point of view).
14:18:51 <dpiponi_> Hmmm...I was in the wrong window, I'll redirect that to haskell-in-depth
14:19:44 <afreude1> can someone explain category theory to me?  (since it's been mentioned and reminded me about it)
14:20:10 <Olathe> afreude1: Have you done abstract algebra ?
14:20:26 <afreude1> yeah
14:20:33 <afreude1> well, sort of.
14:20:39 <int80_h> sort of?
14:20:49 <Olathe> What have you done ? Rings and groups and so on ?
14:21:00 <afreude1> groups, and I've read a little about rings and fields and such
14:21:05 <Olathe> Ahh.
14:21:07 <ehird> @hoogle (Integral a) => a -> Int
14:21:08 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
14:21:08 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
14:21:08 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
14:21:11 <yitz> Olathe: it's the "and so on" that gets you
14:21:18 <Olathe> There are lots of things that fit the definition of a group.
14:21:33 <cknapp> Olathe:? And all of them are groups... :)
14:21:41 <Olathe> The definition of a category is something like the definition of a group.
14:21:47 <afreude1> as long as they fit with the axioms it's okay
14:21:50 <cknapp> Ah.
14:21:51 <Olathe> Only, like, totally meta !
14:22:03 <afreude1> yeah, functors go from categories to groups or something like that right?  (sorry if I sound dumb here)
14:22:21 <Olathe> Oh, I haven't really studied category theory too much.
14:22:27 <ddarius> Olathe: There's nothing "meta" about it (or perhaps you were responding to something else?)
14:22:36 <yitz> all groups form a category
14:22:50 <cknapp> Functors go from categories to categories; if you have a functor from some category to Grp (the category of groups), then you can map some object to a group.
14:22:57 <afreude1> ah
14:22:59 <afreude1> that makes sense
14:23:04 <defun> does anyone know of any good, in depth parsec tutorials or examples?
14:23:17 <Badger> [#python] This channel is logged by IRSeek, and what you say may turn up on the web.
14:23:23 <Badger> oops
14:23:41 <ddarius> defun: The Parsec "letter" is a decent introduction if slightly out-dated.
14:23:42 <dino-> Badger: This incident will be reported!
14:23:44 <Badger> too many haskells!
14:23:55 <Olathe> #python should stop threatening us like that.
14:23:55 <afreude1> now how does Haskell use category theory?
14:24:13 <int80_h> #python is just jealous of our channel population
14:24:24 <z0d> int80_h: you mean ##ptyhon?
14:24:29 <Badger>  -!- Irssi: #python: Total of 706 nicks
14:24:33 <Olathe> afreude1: Some of it has been implemented, like monads and so on.
14:24:41 <defun> thanks
14:24:44 <Olathe> afreude1: We use those implemented classes.
14:25:04 <pumpkin> @users
14:25:04 <lambdabot> Maximum users seen in #haskell: 699, currently: 688 (98.4%), active: 33 (4.8%)
14:25:08 <pumpkin> wow
14:25:12 <Badger> defeated
14:25:22 <afreude1> I guess I know that, but I don't quite get how it works.  I'm a math person and not really a computer person; I have trouble understanding how a computer language can use these really abstract ideas
14:25:24 <BMeph> > foldr mappend mempty $ map (getLast . Just ) [1..10] :: Last Int
14:25:26 <lambdabot>   Couldn't match expected type `Last a'
14:25:45 <ddarius> afreude1: Some ideas from category theory are instantiated in a Haskell context.  That's about it in the pragmatic realm.
14:25:59 <z0d> int80_h: It's strange. I'd expect the #Python population to be larger
14:26:22 <BMeph> > map (getLast . Just ) [1..10]
14:26:23 <lambdabot>   Couldn't match expected type `Last a'
14:28:13 <BMeph> > map ( Just ) [1..10]
14:28:15 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
14:28:43 <BMeph> > map ( getLast) . map Just $ [1..10]
14:28:45 <lambdabot>   Couldn't match expected type `Last a'
14:28:53 <BMeph> :t getLast
14:28:54 <lambdabot> forall a. Last a -> Maybe a
14:29:11 <BMeph> > foldr mappend mempty $ map ( Last . Just ) [1..10] :: Last Int
14:29:12 <lambdabot>   Last {getLast = Just 10}
14:29:20 <yitz> what is Last?
14:29:24 * BMeph facepalms
14:29:44 <tromp_> @let rrr = foldr (\x f y-> f(x:y)) id []
14:29:46 <lambdabot>  Defined.
14:29:49 <marcot> Hello, I'm trying to build a ghc-paths only for profiling (I'm packaging for debian), but when I try to run ./setup configure --enable-library-profiling --disable-library-vanilla, I get:
14:30:06 <marcot> /usr/bin/ld: dist/build/GHC/Paths.o: No such file: No such file or directory
14:30:06 <BMeph> yitz: It's based off of Maybe, and takes the "right-most" non-Nothing value. :)
14:30:07 <ddarius> foldr mappend mempty = mconcat
14:30:24 <marcot> Is it a problem to generate profiling without vanilla?
14:30:46 <yitz> BMeph: so it's the Exit monad
14:30:53 <yitz> sort of
14:31:03 <tromp_> > rrr "olleh"
14:31:05 <lambdabot>   "olleh"
14:31:27 <yitz> @go Exit monad
14:31:29 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadExit
14:31:29 <lambdabot> Title: New monads/MonadExit - HaskellWiki
14:31:39 <loadquo_> @let lll = foldl (\x f y-> f(x:y)) id []
14:31:40 <lambdabot>  <local>:9:26:
14:31:40 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t ...
14:32:00 <loadquo_> @let lll = foldl (\x f y-> f([x]++y)) id []
14:32:01 <lambdabot>  <local>:9:29:
14:32:02 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t ...
14:32:18 <marcot> Or is it this package?
14:33:08 <mauke> f x y
14:33:14 <Olathe> foxy
14:33:20 <yitz> marcot: you're packaging for debian? are you really?
14:33:36 <marcot> yitz: what's the problem?
14:33:44 <yitz> marcot++
14:33:49 <marcot> =)
14:34:03 <mauke> preflex: karma marcot
14:34:03 <preflex>  karma for marcot: 1
14:41:45 <Gracenotes> ah, Stack Overflow. Where only a topic called "Anyone know any programming related poetry?" could get tagged "not-programming-related"
14:41:49 <hackage> Uploaded to hackage: mersenne-random 1.0
14:41:49 <hackage> Uploaded to hackage: happstack-helpers 0.11
14:43:11 <Cale> Gracenotes: But programming related poetry is not programming related!
14:43:50 <yitz> Cale: there was a time when people were writing poetry in perl. it had to be a valid program that ran without error.
14:44:03 <mauke> http://en.wikipedia.org/wiki/Black_Perl
14:44:04 <monochrom> Do not naively consider "programming-related blah" to be programming-related just because of the syntax "p, r, o, g, ..."
14:44:05 <ehird> Hi, why doesn't hSDL provide access to a keysym's scancode?
14:45:16 <tromp> @src rrr
14:45:16 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:45:41 <lament> ehird: why don't you add it then
14:45:49 <ehird> hm?
14:46:20 <lament> add that ability to the api
14:46:34 <ehird> That would prove rather a problem to giving the program to other people.
14:47:04 <Gracenotes> mauke: what's the output of that program?
14:47:18 <lament> ehird: not if your patch gets accepted!
14:47:18 <mauke> I have no idea
14:47:21 <dibblego> newtype X a b = X (a -> b, a) -- does this structure have a recognised name?
14:47:31 <mauke> nothing sane
14:47:37 <Gracenotes> heh
14:47:37 <mauke> it just barely parses
14:47:45 <ehird> lament: I think I'd rather see if there's anything that can be done.
14:48:38 <dolio> It's the state-in-context comonad.
14:48:59 <dibblego> ha, figured it was "like state" and was a comonad -- thanks!
14:49:29 <dolio> counit (f, a) = f a obviously.
14:49:35 <dibblego> yep
14:49:42 <dolio> cojoin I have to think about.
14:50:20 <Gracenotes> or.. cobind?
14:50:49 <Gracenotes> hm... cobind can be written in terms of unit+join, right?
14:51:01 <dolio> cojoin :: (a -> b, a) -> (a -> (a -> b, a), a), right?
14:51:04 <dibblego> just cojoin
14:51:18 <Badger> :t cojoin
14:51:19 <lambdabot> Not in scope: `cojoin'
14:51:21 <dibblego> cobind k (f , s) = ((\s' -> k (f , s')) , s)
14:51:21 <mauke> that's some cojoines you've got there
14:52:20 <Gracenotes> (=>>) :: w x -> (w x -> y) -> w y
14:52:30 <dolio> cojoin (f, s) = (\s' -> (f, s'), s), I guess.
14:52:50 <Gracenotes> @type \k (f , s) -> ((\s' -> k (f , s')) , s)
14:52:51 <lambdabot> forall t t1 t2 t3. ((t, t2) -> t3) -> (t, t1) -> (t2 -> t3, t1)
14:53:17 <Gracenotes> eek. types confuse me.
14:53:40 <dolio> @type \(f, s) -> (\s' -> (f, s'), s)
14:53:42 <lambdabot> forall t t1 t2. (t, t1) -> (t2 -> (t, t2), t1)
14:53:48 <Deewiant> t<n> is a lot harder to read than a-z
14:56:04 <tromp> wait i got something very faint
14:56:17 <tromp> sorry, wrong channel
14:56:22 <roconnor> @hayoo hmac
14:56:23 <lambdabot> Unknown command, try @list
14:57:50 <lament> is haskell reddit more or less a dump of planet haskell?
14:58:30 <pumpkin> sometimes
14:58:58 <roconnor> lament: sorted by user preference?
14:59:31 <Deewiant> with only haskell-related topics
14:59:42 <Deewiant> (as opposed to posts from haskell-related blogs)
14:59:49 <monochrom> A lot of man-hours are spent on converting planet haskell to haskell reddit. :)
15:00:02 <tromp> @let rr = ($ []) . foldr (\x f-> f.(x:)) id
15:00:03 <lambdabot>  Defined.
15:00:15 <lament> monochrom: you mean the software?
15:00:34 <monochrom> Of course not.
15:00:55 <lament> what do you mean?
15:01:09 <monochrom> dump
15:01:38 <monochrom> transfer of data from planet haskell to haskell reddit
15:01:53 <lament> <monochrom> A lot of man-hours are spent on converting planet haskell to haskell reddit. :)
15:01:59 <lament> you meant the other way around then?
15:02:24 <ehird> er, no?
15:02:30 <lament> oh, i see, "converting" could really be interpreted both ways there
15:02:59 <monochrom> "convert betamax to VHS", "convert int to double"
15:03:00 <lament> "making haskell reddit look like planet haskell", or "converting things on planet haskell to things on haskell reddit"
15:03:30 <yitz> <segfault>
15:03:40 <xcthulhu> monochrom: int to double is really a lot easier
15:05:28 <monochrom> The web is a lot of man-hours transferring data between servers.
15:06:30 <loadquo_> The web is a lot of man hours transferring neural connections between brains.
15:06:56 * Badger plugs into loadquo_'s brains.
15:08:17 <loadquo_> Note: Neural connection transfer is not efficient or error proof.
15:08:19 <monochrom> haskell is a lot of man-hours delaying evaluations.
15:10:19 <loadquo_> I wonder if we should re-brand haskell as a procrastinating language. That might stave off some of the success that it has been getting.
15:11:22 <lament> loadquo_: there must be a more appropriate term than 'functional', as well
15:13:30 <loadquo_> lament: Disorganized?
15:14:28 <lament> Inconsequential?
15:16:13 <monochrom> "academic". that will kill success instantly.
15:16:40 <monochrom> "haskell is a pure higher-order academic language" XD
15:17:44 <lament> from haskell.org: "Haskell is an overengineered purely inconsequential prograstinating programming language. An unsupported product of more than twenty years of academia tinkering, it allows rapid development of robust, concise, correct one-liners."
15:17:54 <monochrom> Someone should go acquire the domain name "haskell-university" :)
15:17:58 <lament> minus typos
15:19:20 <int80_h> science has already located the center of the universe
15:19:24 <int80_h> hmmm
15:19:29 <drhodes> prove it!
15:19:30 <mauke> Haskell, the world's leading purely fictional programming language
15:19:52 <monochrom> When some other people finally understands the big bang, they will be surprised to learn that they are the center of the universe, too.
15:19:54 <sjanssen> hahaha
15:20:06 <int80_h> well rather, some modeling locates the center of the universe at any arbitrary point
15:20:16 <sjanssen> @remember mauke Haskell, the world's leading purely fictional programming language
15:20:16 <lambdabot> Done.
15:20:21 <mauke> :-/
15:20:25 <mauke> I didn't invent it
15:20:43 <sjanssen> mauke: oh, to whom should it be attributed?
15:20:55 <bolrod> god
15:21:00 <mauke> Anonymous from 4chan
15:21:04 <mauke> at least that's where I read it
15:21:12 <int80_h> god create Number, all else is the work of man
15:21:15 <lament> monochrom: i'm not the centre of the universe, the place where MBR is shifted equally in all directions is the centre of the universe
15:21:24 <drhodes> The
15:21:25 * sjanssen tries to remember how to delete quotes
15:21:32 <drhodes> Natural Numbers, eh?
15:21:38 <mauke> @help forget
15:21:38 <lambdabot> forget nick quote.  Delete a quote
15:21:52 <sjanssen> @forget mauke Haskell, the world's leading purely fictional programming language
15:21:52 <lambdabot> Done.
15:22:24 <sjanssen> @remember Anonymous Haskell, the world's leading purely fictional programming language
15:22:25 <lambdabot> Okay.
15:22:57 <lament> @quote fictional
15:22:57 <lambdabot> Anonymous says: Haskell, the world's leading purely fictional programming language
15:24:16 <sjanssen> is it just me, or is the placement of those book covers strange http://haskell.org/
15:24:50 <lament> they're vertically aligned to their headlines
15:24:59 <lament> and horizontally aligned to nothing in particular
15:25:10 <monochrom> Not too strange.
15:25:56 <sjanssen> they look bad, IMO
15:26:51 <SamB_irssi> yes, they look BAD
15:27:00 <drhodes> does the "where" clause simply tell the compiler to find-and-replace within the function?
15:27:13 <Raynes> I think they look fine.
15:27:38 <monochrom> Not necessarily find-and-replace.
15:28:09 <sjanssen> drhodes: no
15:28:18 <Gracenotes> it might be convenient to put them in a floating div
15:28:31 <drhodes> ok, thanks sjanssen monochrom
15:28:32 <Gracenotes> or just not include them at all ;)
15:28:37 <sjanssen> drhodes: 'where' desugars into 'let' which does more than textual substitution
15:28:46 <drhodes> ah
15:28:48 <Cale> drhodes: But all Haskell evaluation can be implemented by something that looks a little like "find and replace"
15:28:54 <Cale> (though not quite)
15:29:05 <monochrom> The exact meaning is declarations/definitions that can be used locally but not globally.
15:29:11 <Gracenotes> how does Haskell internally keep track of bindings..?
15:29:33 <pumpkin> Data.Map!
15:29:34 <pumpkin> ;)
15:29:47 <Gracenotes> yeah, union is only O(n+m) :P
15:30:22 <Cale> Gracenotes: You mean, how does GHC keep track of them?
15:30:23 <sjanssen> Gracenotes: 'Haskell' the language doesn't, Haskell compilers are free to implement that however they wish
15:30:28 <monochrom> If you accept the idea of nested definition of things, "where" is a syntax for it.
15:30:31 <Cale> (when it is compiling the code?)
15:30:34 <chessguy> more like #UnsafeMutableMap* or something equally incomprehensible
15:30:40 <Gracenotes> yes, GHC. **usage error**
15:30:46 <chessguy> @ghc
15:30:46 <lambdabot> ghc says: Splices are not allowed in hs-boot files
15:31:14 <conal> sjanssen: i read "Haskell -- the language that doesn't".  which is a pretty cool description of pure functional programming.
15:31:28 <chessguy> conal:  link?
15:31:32 <monochrom> the language that doesn't suck :)
15:31:33 <Gracenotes> when compiling, when interpreting, either.
15:31:39 <Cale> Good question. I would hope it uses nice data structures like Data.Map.
15:31:47 <ehird> Time for an apropos quote:
15:31:49 <conal> the language that *doesn't*, period.
15:31:59 <ehird> "The fact that some calculation is necessary in order to view a picture of the Mandelbrot set, or in order to "run" a Lazy K program, is an implementation detail. That's the essence of functional programming."
15:32:00 <conal> chessguy: sjanssen's previous remark
15:32:01 <yitz> the little language that could
15:32:03 <ehird> -- http://homepages.cwi.nl/~tromp/cl/lazy-k.html
15:32:08 <sjanssen> Gracenotes: bindings don't really exist at run time in GHC, they're values on the stack
15:32:09 <chessguy> conal:  oh! i thought it was a blog entry
15:32:14 <jeffwheeler> @users
15:32:15 <lambdabot> Maximum users seen in #haskell: 699, currently: 665 (95.1%), active: 28 (4.2%)
15:32:17 <sjanssen> or on the heap
15:32:26 <ehird> 699, ouch
15:32:29 <ehird> let's put some bots in here to inflate it
15:32:49 <conal> some self-replicating bots
15:32:55 <dsrogers> When I try to write this type signature: ticketGet :: (MonadIO m, Authenticator domain Credentials IO)=>domain->Credentials -> m Response
15:33:02 <conal> fibonacci-bot
15:33:02 <dsrogers> t complains about a Non type-variable argument in the constraint: Authenticator domain Credentials IO
15:33:10 <dsrogers> and suggests I use -XFlexibleContexts...
15:33:12 <Gracenotes> sjanssen: ah, so the the variable names 'disappear'? How is coded loaded that uses these names?
15:33:16 <dsrogers> o my question is: am I doing this wrong, and what are the consequences of -XFlexibleContexts?
15:33:20 <jeffwheeler> Yeah. We need to make lambdabot spawn lambdabots.
15:33:27 <sjanssen> dsrogers: use FlexibleContexts
15:33:45 <sjanssen> dsrogers: FlexibleContexts are pretty harmless, they're just a bit more flexible than Haskell '98
15:34:07 <Gracenotes> jeffwheeler: not too hard. "NICK Lambdabotx\r\nUSER lambda 0 0 :Clone\r\nJOIN #haskell"...set there and do nothing...
15:34:08 <dsrogers> but what I've written is essentially correct, then?
15:34:16 <sjanssen> dsrogers: as to what you might be doing wrong, a class with 3 type arguments isn't terribly typical
15:34:23 <Cale> dsrogers: Just delete that constraint.
15:34:38 <dsrogers> it has to be constrained somehow...
15:34:46 <Cale> dsrogers: Either there's an instance Authenticator domain Credentials IO or there isn't.
15:35:04 <Cale> dsrogers: If there is, the constraint is superfluous. If there isn't, then what are you writing?
15:35:24 <sjanssen> Cale: but 'domain' is a type variable
15:35:25 <dsrogers> there is an ambiguity.
15:35:31 <Cale> oh!
15:35:34 <Cale> heh, sorry
15:35:43 <dsrogers> that argument is not constrained enough...
15:35:48 <dsrogers> so I need to constrain it.
15:35:50 <Cale> yes
15:35:59 <Cale> I missed the fact that it was a variable.
15:36:07 <sjanssen> Gracenotes: well, top-level names still exist
15:36:20 <sjanssen> Gracenotes: they're mangled and are available as symbols in the object code
15:36:39 <Cale> (It's somewhat unusual to see type variables with multi-character names ;)
15:36:56 <monochrom> Oleg does it all the time.
15:37:04 <Gracenotes> ah, I see. If there are type signatures, inferred or explicit, where are they stored?
15:37:11 <yitz> monochrom: otherwise he wouldn't have enough
15:37:43 <Cale> Gracenotes: Types don't exist any longer at runtime in most implementations.
15:37:47 <sjanssen> Gracenotes: type signatures are stored in .hi files, which are stored seperately from the object code and aren't linked into executables
15:37:54 <Cale> Gracenotes: they're used during compilation, and then discarded.
15:38:46 <Gracenotes> mm..interesting.
15:39:01 <Cale> Similarly with names of functions/values etc.
15:39:24 <Cale> (though there's actually a little bit of preservation there, but it's not essential)
15:39:32 <enoksrd> @users
15:39:33 <lambdabot> Maximum users seen in #haskell: 699, currently: 666 (95.3%), active: 26 (3.9%)
15:39:46 * enoksrd sacrifices a goat
15:39:56 <pumpkin> omg the devil!
15:39:56 <BMeph> Why does GHCi say you have an "ambiguous occurance" when you import same-named functions from miltiple modules, when the type can only go one way? :\
15:39:59 * pumpkin hides
15:40:03 <yitz> enoksrd: one less user now
15:40:17 <dsrogers> thanks.
15:40:21 <dsrogers> that worked.
15:40:22 <pumpkin> BMeph: probably a conscious decision on not resolving ambiguities by type? :P
15:40:26 <sjanssen> BMeph: because Haskell doesn't support ad-hoc overloading
15:40:27 <pumpkin> *to not
15:41:07 <lament> BMeph: because of type inference
15:41:35 <lament> BMeph: if you could guarantee beforehand that the type can only go one way, this wouldn't be an issue, which is how languages like C# handle this
15:42:37 <lament> BMeph: but the only way you could do that is by having all variables type-annotated
15:42:52 <Gracenotes> hrm. Having the empty set defined in regular expressions doesn't seem that useful...
15:43:15 <Cale> Gracenotes: It's the identity for +
15:43:22 <BMeph> lament: I'm doing a map . sort . zip - doesn't the zip "guarantee" that I'm working with a list, not, say, a Set? :p
15:43:48 <lament> BMeph: of course not - what if you have a different zip loaded from some different module? :)
15:44:13 <Gracenotes> Cale: it seems to be an identity for unions too :)
15:44:31 <BMeph> lament: ... I don't have one now, so why worry about what could be defined? :p
15:44:35 <Cale> Gracenotes: By + I mean union. :)
15:44:45 <sjanssen> BMeph: attempting to resolve these issues would lead to exponential type check time
15:44:54 <Gracenotes> ah... I thought you meant concatenation.
15:45:09 <Cale> Concatenation is multiplication :)
15:45:17 <PeakerWork> forkIO creates a user-level thread, what was the name of the function that created a real new kernel thread?
15:45:20 <Gracenotes> but actually I suppose the empty set concat'd with a string wouldn't return any results
15:45:26 <Cale> right.
15:45:33 <Gracenotes> oh... that's the novel way of thinking about it
15:45:44 <Gracenotes> e = 1, (/) = 0
15:46:33 <Cale> A regular expression is 0, 1, a letter of the alphabet, the sum of two regular expressions, the product of two regular expressions, or a regular expression starred.
15:47:35 <Gracenotes> starred meaning exponentiation to any power, in a sense
15:47:49 <Cale> Well... x* = 1/(1-x), if you like
15:48:08 <Cale> = 1 + x + x^2 + ...
15:48:23 <SamB_irssi> sjanssen: does http://haskell.org/haskellwiki/Template:Main/Headlines look any better ?
15:48:46 <sjanssen> SamB_irssi: yeah, a bit
15:49:20 <Gracenotes> it reminds me of Church encoding of numbers, in a sense :)
15:49:48 <Gracenotes> I suppose that's what you call an isomorphism of sorts, perhaps...
15:50:27 <Cale> I'm not certain how it relates to Church encoding... though it's a recursive algebraic datatype, so I suppose you can Church encode it :)
15:50:53 <Cale> data Reg a = Zero | One | Sym a | Sum [Reg a] | Prod [Reg a] | Star (Reg a) -- this is the definition I tend to use.
15:50:56 <Gracenotes> I mean, in its similarity to natural number operations
15:51:04 <Cale> The lists are mainly for convenience.
15:52:26 <Cale> Gracenotes: hmm, like "A natural number is either 0 or the successor of a natural number"?
15:52:39 <int80_h> @seen lemmih
15:52:39 <lambdabot> lemmih is in #haskell-in-depth and #haskell. I last heard lemmih speak 2h 59m 15s ago.
15:54:26 <Gracenotes> Cale: I guess. The fact that all three systems have closure on exponentiation-like, product-like, and sum-like operations, and have zero elements and one elements that have certain identities with respect to those operations
15:54:52 <Cale> Well...
15:55:04 <Cale> There's not quite a proper exponentiation for regular expressions.
15:55:21 <Cale> But otherwise, they're a semiring like the naturals.
15:56:03 <Gracenotes> ah... I see what you mean. In A^n, n isn't terribly well-defined if it's a regex
15:56:16 <Cale> right.
15:57:04 <Gracenotes> oh, it seems ring theory covers this...
15:57:06 <Cale> You have A^n for n natural, but you have that anywhere you have multiplication (especially if it's associative)
15:57:37 <Cale> It's almost a ring, but addition lacks an inverse.
15:57:50 <Cale> (similarly to the naturals)
15:58:16 <Gracenotes> I've read tidbits about ring theory and group theory, though it doesn't seem.. er... practical ;)
15:58:22 <Cale> another strangeness we can pick out is that a + a = a for regular languages
15:58:39 <Cale> making it an idempotent semiring
15:59:03 <Cale> throwing in the Kleene star gives us a Kleene algebra
15:59:15 <Cale> http://en.wikipedia.org/wiki/Kleene_algebra
15:59:42 <chessguy> is there any support in haskell for numbers in bases other than 10?
16:00:25 <mauke> > 0o101
16:00:27 <lambdabot>   65
16:00:42 <Gracenotes> hm. if anything, abstract algebra does lend some useful terminology.
16:00:43 <chessguy> what the heck is that?
16:00:45 <Cale> :t showIntAtBase
16:00:46 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:01:18 <chessguy> > 0o102
16:01:20 <lambdabot>   66
16:01:31 <chessguy> wtf
16:01:34 <chessguy> @type o
16:01:35 <lambdabot> Expr
16:01:40 <Gracenotes> octal
16:01:40 <Badger> > 0o65
16:01:42 <lambdabot>   53
16:01:57 <Gracenotes> > 0b101 -- ?
16:01:58 <lambdabot>   Not in scope: `b101'
16:02:11 <chessguy> mauke:  how does that work?
16:02:15 <gweiqi> > 0x101
16:02:17 <mauke> what
16:02:17 <lambdabot>   257
16:02:34 <chessguy> mauke:  0o01
16:02:35 <Gracenotes> well, that's not 5 :P
16:02:36 <porges> Gracenotes: it needs a more logical nomenclature though
16:03:01 <mauke> what do you mean by "work"?
16:03:16 <chessguy> mauke:  what notation is it?
16:03:18 <porges> we need a Linnaeus :P
16:03:21 <mauke> octal
16:03:24 <gweiqi> > 0o7
16:03:25 <lambdabot>   7
16:03:27 <gweiqi> > 0o8
16:03:28 <lambdabot>   Not in scope: `o8'
16:03:48 <gweiqi> > 0o10
16:03:50 <lambdabot>   8
16:04:02 <chessguy> mauke: is that support defined in H98?
16:04:03 <Gracenotes> porges: eek, that would be a nightmare
16:04:09 <mauke> I don't know
16:04:55 <chessguy> hm, looks like it is
16:05:03 <chessguy> interesting
16:06:33 <porges> chessguy: C is worse
16:06:39 <porges> $ echo 'int main() { return 09; }' > tests.c && gcc tests.c
16:06:39 <porges> tests.c:1:21: error: invalid digit "9" in octal constant
16:06:40 <lunabot>  luna: parse error on input `09'
16:07:10 <chessguy> heh
16:07:13 <chessguy> $ echo 'hi'
16:07:14 <lunabot>  luna: Not in scope: `echo'
16:07:50 <chessguy> porges:  javascript is pretty bad too
16:12:03 <chessguy> whee
16:12:32 <appletizer> lol
16:13:45 <Cale> Descartes walks into a bar. The barkeeper says 'Do you want a beer?'. Descartes says 'I think not', and disappears.
16:14:06 * conal chuckles
16:14:12 <monochrom> haha
16:17:55 * chessguy giggles a bit
16:19:05 <BMeph> A blonde walks into a bar. A brunette sees her...and ducks. ;p
16:20:19 <conal> where'd the ducks come from?
16:20:59 <lament> time flies like an arrow, blonde walks into a bar?
16:21:23 <skorpan> i don't get the joke.
16:22:37 <BMeph> skorpan: The brunette saw the bar, so she ducked. ;p
16:27:13 <ehird> what's the function generally used for stripping excess quitespace again? I los tit
16:27:55 <Gracenotes> @hoogle trim
16:27:56 <lambdabot> Data.ByteString.Internal createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
16:27:56 <lambdabot> Data.ByteString.Internal createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
16:27:56 <Cale> > unwords . words $ "   here's    something   with \t\n extra spaces   "
16:27:58 <lambdabot>   "here's something with extra spaces"
16:28:53 <ehird> Cale: from the front and end
16:28:55 <ehird> not all throguh
16:29:53 <Cale> I suppose you can rig something up with dropWhile isSpace
16:30:37 <conal> maybe a composition of words & unwords
16:30:51 <conal> oh -- just front & end.
16:31:19 <conal> twice (reverse . dropWhile isSpace)
16:31:35 <ehird> mm :)
16:31:44 <ehird> it's only ever at the end
16:31:44 <ehird> so
16:31:49 <ehird> reverse . dropWhile isSpace . reverse
16:36:08 <dancor> how would you make an intercalating list type
16:36:10 <chessguy> hmm. what's the constructor for ((->) t) ?
16:36:29 <ehird> chessguy: (\a -> b)
16:36:29 <ehird> :P
16:36:41 <chessguy> really?
16:36:47 <dancor> i'm feeling like if i go (a, [(b, a)]) or ([(a, b)], a) i'm going to wind up regretting one or the other at different times
16:37:04 <Olathe> @src (->) (>>=)
16:37:05 <lambdabot> f >>= k = \ r -> k (f r) r
16:37:13 <ehird> dancor: make your own data type?
16:37:32 <chessguy> so wait, is this right? instance Functor ((->) t) where
16:37:32 <chessguy>   furry f g = f . g
16:37:39 <chessguy> err
16:37:45 <Olathe> > ((+1) >>= (*2)) x
16:37:46 <chessguy> fmap = (.)
16:37:47 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
16:37:47 <lambdabot>      Proba...
16:37:48 <dancor> (also applies to data-ed analogues like data Intercal a b = Intercal a b (Intercal a b) | Interend a)
16:37:51 <conal> chessguy: yeah
16:37:55 <chessguy> nice
16:37:58 <dancor> ehird: i think i'll have same issue
16:38:01 <Olathe> > ((+1) >>= (*)) x
16:38:02 <lambdabot>   (x + 1) * x
16:38:17 <Olathe> > (*) ((+1) x) x
16:38:19 <lambdabot>   (x + 1) * x
16:38:27 <dancor> i guess there's no real alternative
16:38:45 <Olathe> @src (->) return
16:38:45 <lambdabot> return = const
16:39:27 <chessguy> ok, ok, enough spoilers :)
16:39:28 <dancor> maybe casting to some [Either a b] will make certain things (and changing between the two forms) ok
16:42:28 <ehird> Is there a Data.Set that takes a tuple yet only sets on one argument?
16:42:38 <ehird> that is, ("a",2) and ("a",3) both go under "a"
16:42:42 <ehird> insetad of being separate
16:47:33 <chessguy> hmmm, backwards banana
16:47:47 <chessguy> this is really good stuff: http://blog.tmorris.net/20-intermediate-haskell-exercises/
16:48:58 <BMeph> chessguy: When you're done, check out the reddit dicussion. ;)
16:49:18 <chessguy> BMeph:  will do
16:49:31 <gio1239> is here people from rewriting?
16:49:44 <chessguy> BMeph:  the backwards banana threw me for a minute
16:50:33 <chessguy> actually it still has me thrown a bit
16:50:39 <BMeph> chessguy: Keep going - after banana, *everything* is reversed. :\
16:50:49 <ehird> gio1239: ?
16:50:59 <chessguy> oh boy
16:51:04 <ehird> chessguy: oh, what?
16:51:10 <monochrom> boy
16:51:15 <chessguy> ehird:  what what?
16:51:20 <ehird> dunno.
16:51:28 <chessguy> um, ok
16:51:50 <chessguy> ehird:  we're talking about the link i just pasted
16:51:54 <ehird> ah
16:53:30 <BMeph> The (main) reddit link: http://www.reddit.com/r/programming/comments/7290h/20_intermediate_haskell_exercises/
16:53:40 <chessguy> BMeph:  does it have spoilers?
16:53:45 <BMeph> It was such fun, it got posted twice. ;)
16:54:18 <BMeph> chessguy: On hpaste,...so no. :(
16:55:19 <chessguy>     Could not deduce (Functor m1) from the context (Misty m1)
16:55:19 <chessguy>       arising from a use of `fmap' at ../Haskell/Junk.hs:44:11-14
16:55:20 <chessguy> bah
16:55:22 <PeakerWork> BMeph: are you allowed to just answer fmap to all of these?
16:55:30 <PeakerWork> ah, I guess not :)
16:55:43 <chessguy> Peaker:  it only works for a few
16:57:22 * BMeph thinks PeakerWork should find a secluded corner, before "fmapping" too much at work... ;p
16:57:42 <PeakerWork> BMeph: I haven't yet converted my coworkers to Haskell
16:57:49 <PeakerWork> so I can only write some little tools and such in Haskell :)
16:58:10 <PeakerWork> but I'm working on it, and we should be getting Real World Haskell in the office here soon :)
16:59:34 <BMeph> PeakerWork: Ooh, then you can have "fmap-fmap-fmap" all through the halls. Better bring a towel... ;p
17:00:06 <monochrom> should I try to understand that?
17:00:12 <dancor> a haskell bathhouse?
17:00:20 <BMeph> monochrom: No, you shouldn't. ;)
17:00:33 * BMeph winks and nods at dancor
17:00:47 * dancor ^5
17:01:58 <conal> i love the banana.  monads finally felt right to me a few weeks ago when i finally saw extend :: (a -> m b) -> (m a -> m b).
17:03:02 * chessguy finally gets furry' written, with a little help from @src
17:03:18 <dancor> @hoogle (a -> m b) -> (m a -> m b)
17:03:19 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:03:19 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:03:19 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
17:04:30 <dancor> i guess extend turned out to be (=<<).  or does anything else interesting have that type?
17:05:00 <zeno> prelude =<< is the same as Control.Monad =<< right
17:06:24 <dancor> zeno: yes
17:06:26 <monochrom> There is no =<< in the prelude IIRC.
17:07:43 <dolio> @hoogle =<<
17:07:44 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:07:44 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:07:50 <dancor> monochrom: (main = print =<< return 4) says otherwise..
17:09:03 <conal> chessguy: one reason i like fmap in place of (.) is that the notation encourages a *unary* perspective, which is really powerful.
17:09:12 <monochrom> My prelude skill is outdated.
17:09:38 <conal> chessguy: with the type (b -> b') -> ((a -> b) -> (a -> b'))
17:09:52 <chessguy> conal:  why is that so powerful
17:10:21 <conal> chessguy: because it promotes functions, and it's composable!
17:10:24 <dancor> no one ever thinks about the tertiary perspective!  (b -> b') -> (a -> b) -> a      -> b'
17:10:35 <conal> chessguy: compare the type with the (function-specialized) types of first and second.
17:10:53 <chessguy> conal:  i'm not familiar with it
17:11:21 <conal> chessguy: see http://conal.net/blog/semantic-editor-combinators
17:11:35 <conal> chessguy: i often use an alias result = (.)
17:11:49 <conal> then i can say things like 'first.result.second.result'
17:12:22 <conal> which directs a semantic editor (a function) deeply inside a value.
17:12:48 <conal> and then result generalizes to arrows.
17:13:03 <conal> so these semantic editor combinators become very general beasties, working on lots of Arrow types.
17:13:22 <conal> this is the basis of Tangible Functional Programming.
17:13:54 <conal> for gestural dynamic composition of GUI-wapped functionality.
17:15:00 <conal> the generalization to arrows is crucial, and it depends on the unary perspective.
17:15:42 <chessguy> fascinating stuff
17:15:51 <chessguy> i need to watch your TV video again
17:15:55 <conal> because the type (b -> b') -> ((a -> b) -> (a -> b'))  generalizes to  (b ~> b') -> ((a -> b) ~> (a -> b'))
17:16:00 <conal> which is *necessarily* unary.
17:16:18 <porges> @hoogle (.)
17:16:18 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
17:16:19 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
17:16:19 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
17:16:24 <conal> in that case (~>) is an arrow
17:16:44 <jimi__hendrix> whats a good tutorial for someone coming from a C/C++ background
17:16:47 <porges> lambdabot is missing Control.Category (.)
17:17:10 <dancor> porges: well hoogle is missing it more specifically i think
17:17:15 <silentOpen> jimi__hendrix, I liked Yet Another Haskell Tutorial (but i'm not from c/c++ directly)
17:17:17 <conal> chessguy: and then "Tangible Functional Paper" for the theory.
17:17:25 <dancor> hoogle is missing a lot of things that hayoo has
17:17:29 <porges> dancor: shows up alright in hoogle
17:17:34 <dancor> hm
17:17:35 <dolio> They're still on 6.8, no?
17:17:37 <conal> chessguy: i mean the "Tangible Functional Programming" paper
17:17:57 <jimi__hendrix> silentOpen: what are you from then?
17:18:01 <chessguy> conal:  ooh, i haven't read that yet
17:18:17 <silentOpen> jimi__hendrix, python, scheme, javascript
17:18:21 <conal> http://conal.net/papers/Eros/
17:18:44 <monochrom> I started up a virtual machine from scratch in my head to learn Haskell. The virtual machine had little background.
17:19:06 <jimi__hendrix> meh...how much scheme...python is close enough but scheme might have made it easier
17:19:22 <silentOpen> jimi__hendrix, YAHT assumes a Java/C background
17:19:28 <Nafai> monochrom: A virtual machine that has no memory of previous background? :)
17:19:29 <conal> chessguy: a bit more info at http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
17:19:37 <silentOpen> jimi__hendrix, the 10 minute intro and linked pages on the wiki are also pretty good
17:19:46 <jimi__hendrix> ok thanks
17:19:59 <BMeph> We need a type for Arrows-that-don't-do-arr... :\
17:20:09 <conal> BMeph: yeah, we do.
17:20:23 <monochrom> Of course the virtual machine had to know the English alphabet, otherwise how could it read "f x = x" :)
17:20:26 <silentOpen> is there some reason I can't use "=" in the repl?
17:20:56 <zeno> jimi real world haskell is good
17:21:03 <porges> silentOpen: you have to use "let ... = ..."
17:21:08 <monochrom> BrokenArrow is Arrow-that-doesn't-do-arr. :)
17:21:14 <silentOpen> porges, ahhh... a giant do :-)
17:21:18 <silentOpen> thanks
17:21:36 * BMeph wants to put pairs (regular and strict) into the type, but that annoying arr constraint tanks it. :(
17:22:30 <monochrom> You can abuse it and violate the constraint.
17:22:38 <BMeph> Maybe call it an Aqqow, to emphasize that it doesn't do arr... ;p
17:22:51 <monochrom> BrokenArrow is funnier.
17:23:05 <cknapp> I like BrokenArrow
17:23:19 <conal> including arr alongside (>>>) and first appears to have been a mistake.  i don't mind using an error-raising arr method.
17:23:35 <BMeph> It reminds me of the Travolta-Slater movie. :\
17:23:44 <monochrom> Yes, that is my intention!
17:24:13 <monochrom> An Arrow that doesn't do arr. A missile that misses its warhead.
17:24:20 <mm_freak> @pl \f a b = b  {- const id? -}
17:24:20 <lambdabot> (line 1, column 8):
17:24:20 <lambdabot> unexpected "="
17:24:20 <lambdabot> expecting pattern or "->"
17:24:26 <mm_freak> @pl \f a b -> b  {- const id? -}
17:24:27 <lambdabot> const (const id)
17:24:40 <mm_freak> hmm
17:24:44 * BMeph nods patiently at mono.
17:25:06 <BMeph> Oops, gotta get home - chat later...
17:25:35 <conal> gee -- that was abrupt.  was it something we said?  sniff.
17:25:50 <Gracenotes> arr is all pirates have going for them in the general library. If we take it away, surely ninjas would unfairly gain the upper hand.
17:27:24 <Gracenotes> Results 1 - 1 of about 0 for "real world abstract algebra". (0.39 seconds)  :/
17:27:43 <monochrom> haha
17:27:57 <porges> is there any good relationship between Functor  & Category (in haskell types), or does the arity difference prevent this
17:29:43 <kerlo> mm_freak: are you expecting f in \f a b -> b to be the lambda itself?
17:30:54 <Gracenotes> @unpl const id
17:30:54 <lambdabot> (\ _ b -> b)
17:31:23 <porges> previous question was prompted by seeing (fmap . fmap) written as (fmap `fmap` fmap)
17:31:59 <Gracenotes> :t (map.map)
17:32:00 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
17:32:47 <PeakerWork> :t (map.(.).flip (.).first.second.fmap)
17:32:49 <lambdabot> forall a c d d1 a1 b (f :: * -> *). (Functor f) => (a1 -> b) -> [a -> ((d1, f b), d) -> c] -> [a -> ((d1, f a1), d) -> c]
17:33:38 <PeakerWork> porges: I was interested in that as well, seemed like duplication to me, as one should be expressable in terms of the other, at least theoretically
17:34:56 <porges> well I think that that particular rewrite was because for functions fmap == . but I was wondering if there was a more general one
17:35:20 <porges> actually perhaps not
17:37:23 <Saizan> well, i think for many categories (or all?) you can have the Hom(R,-) functor
17:39:16 <Saizan> but our Functor class only represents endofunctors in Hask, where the arrows are (->)
17:39:32 <porges> indeed, perhaps what I want is (class (Category c) => Functor c f where fmap :: c x y -> c (f x) (f y))
17:39:38 <Saizan> yeah
17:39:46 <porges> and then that should be
17:39:56 <porges> indeed, perhaps what I want is (class (Category c) => Functor c f where fmap :: c (c x y) (c (f x) (f y)))
17:40:15 <porges> or should the "outer" category there be a parameter as well
17:40:28 <porges> hm
17:40:30 <kerlo> Hum, what is the Category class?
17:40:38 <porges> id & composition
17:40:53 <Saizan> fmap is not really described as a morphism in CT
17:41:55 <Saizan> kerlo: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Category.html
17:57:07 <arvidj> looking for something like processing for haskell. basically, i want to paint pretty graphics with minimum effort (lazily i guess ;)) any ideas?
17:58:27 <monochrom> The blank screen is the prettiest graphic.
17:58:51 <skorpan> arvidj: something like processing?
18:00:07 <arvidj> skorpan: http://processing.org
18:01:42 <porges> Saizan: it bottoms out anyway if you try to get (.) :: (catO (cat b c) (catO (cat a b) (cat a c)))
18:01:51 <porges> Saizan: you can't have cycles in the class graph
18:04:26 <chessguy> hey conal ?
18:04:37 <conal> chessguy: hi
18:04:47 <chessguy> hey. question
18:05:01 <chessguy> i'm watching your Tangible Functional Programming video
18:05:32 <conal> :)
18:05:57 <chessguy> it seems to me that part of what you're saying is that there shouldn't be a schism between libraries and applications. is that accurate?
18:06:42 <conal> chessguy: i don't do shoulds & shouldn'ts.  at least i mean not to.
18:07:59 <chessguy> conal:  ok. do you think that the difference between libraries and apps (e.g., DLLs and EXEs) make code more or less composable?
18:08:09 <Peaker> conal: btw, me and my friends (coworkers a while ago) went through virtually the same thinking path as you did about unix pipes, composability and usability -- some parts of your video were almost re-enacting our discussions :)
18:08:22 <Peaker> conal: only back then we didn't implement anything :-)
18:09:38 <conal> chessguy: iirc, i was suggesting that libraries have composability and applications have usability.  both abilities are awesome.  i'd like people to have both abilities, not just one or the other.
18:10:09 <conal> chessguy: the standard means of usability (e.g., Haskell IO) thwarts composability.
18:10:36 <conal> chessguy: in haskell terms, IO is usable, non-IO is composable.
18:10:45 <conal> chessguy: and i'm proposing an alternative to IO that has both.
18:10:49 <chessguy> conal: that makes sense
18:10:57 <conal> cool :)
18:11:24 <conal> Peaker: neat.
18:13:35 <porges> hrm, using type operators as class names is weird
18:14:13 <conal> porges: sounds fun.  any examples?
18:14:24 <porges> conal: weird in that it doesn't seem to work
18:14:30 <porges> :D
18:14:44 <conal> porges: oh, oops.  what do you get?
18:14:46 <porges> or at least I can't figure out how to make it
18:14:52 <jimi__hendrix> does vim have autoindenting for haskell? it seems to not do auto indent for me with .hs files but it does syntax highlighting
18:15:35 <porges> conal: it's like there's no way to give the class a name to refer to
18:16:19 <conal> like this?  -- class a `Foo` b where ...
18:16:54 <conal> or maybe:  class a :*: b where ...
18:17:09 <porges> oops I was doing the wrong thing
18:17:20 <porges> writing the equivalent of "id :: Category a a"
18:17:35 <conal> oh
18:19:07 <Cale> jimi__hendrix: There might be a plugin you can get somewhere, but I usually just settle for "make the next line indented as much as the last" sort.
18:19:29 <porges> that's better
18:19:39 <porges> class Category (-->) where id :: a --> a
18:21:10 <porges> class (Category (-->)) => Functor' (-->) f where fmap' :: (x --> y) -> (f x --> f y)
18:22:07 <porges> pity there's no way to get the equivalent of (.) :: (b --> c) ---> (a --> b) ---> (a --> c) (where (-->) and (--->) are different Categories)
18:22:37 <Cale> You really want  fmap :: (a ~~> b) -> (a --> b)
18:22:59 <Cale> er
18:23:00 <dsrogers> so, happstack is released a 0.1, which is effectively an upgrade/fork of HAppS.  What's the best way to get rid of HAppS and use happstack?
18:23:05 <Cale> fmap :: (a ~~> b) -> (f a --> f b)
18:23:07 <Cale> rather
18:23:39 <sereven> jimi__hendrix: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/ -- haskellmode for vim
18:24:16 <porges> class (Category (-->), Category (~~>)) => Functor' (-->) (~~>) f where fmap' :: (x --> y) -> (f x ~~> f y)
18:24:20 <porges> this is getting a bit meta
18:24:55 <porges> class (Category (-->), Category (~~>), Category (==>)) => Functor' (-->) (~~>) (==>) f where fmap' :: (x --> y) ==> (f x ~~> f y)
18:27:41 <conal> See Control.Functor.Categorical
18:27:53 <athos> :t lookup
18:27:54 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:27:58 <conal> class (Category r, Category s) => CFunctor f r s | f r -> s,  f s -> r where cmap :: r a b -> s (f a) (f b)
18:28:00 <athos> :t Data.Map.lookup
18:28:01 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
18:28:18 <athos> ah
18:28:21 <athos> it doesn't default to maybe
18:28:58 <augustss_> athos: it's Maybe in 6.10
18:29:33 <athos> augustss_: no 6.10 available for me :(
18:29:39 <porges> conal: what's the reason behind not abstracting the ->
18:29:50 <augustss_> athos: why not?
18:29:53 <athos> augustss_: but i could manage this "problem" :)
18:29:57 <athos> (with maybe)
18:30:07 <athos> augustss_: i'd have to build it on my own
18:30:10 <athos> :o)
18:30:19 <augustss_> athos: that's not hard
18:30:39 <augustss_> just slow
18:30:40 <porges> wah I want a way to defined Category in terms of Category :P
18:30:54 <conal> porges: i think it allows for more kinds of 'mappings' than functions.  e.g., linear functions/maps for linear algebra
18:31:25 <porges> conal: I mean the middle ->, is still a haskell function
18:31:38 <Peaker> I wish ghc --make treated compiler flags as inputs, and not just the file contents
18:31:39 <porges> conal: do you not gain anything by it becoming Categorical
18:31:43 <conal> porges: oops. i didn't read carefully.
18:31:56 <augustss_> Peaker: don't we all :)
18:32:16 <Peaker> augustss_: it seems that virtually all build systems make this mistake
18:32:19 <conal> porges: i think that (->) is what CT calls a map rather than a functor
18:32:23 <JoshTriplett> Does any GHC extension or language feature exist that would allow me to define a nullary operator?  In particular, such that I could write f x + y and have it parse as f (x) (+) (y) rather than (f x) + (y) ?
18:32:25 <conal> or a morphism.
18:32:36 <conal> a map rather than a morphism
18:32:52 <augustss_> JoshTriplett: no
18:33:03 <Peaker> JoshTriplett: f (x) (+) (y)  is f x (+) y   which is fine
18:33:22 <porges> QuasiQuotes? :D
18:33:24 <JoshTriplett> Peaker: Yes, but if the operator took no arguments then I wouldn't need the parentheses.
18:33:37 <JoshTriplett> porges: Heh.  No.
18:33:41 <conal> porges: so i think CFunctor mirrors CT, while our Functor is less general.
18:33:46 <Peaker> JoshTriplett: but its an infix operator and as such takes 2 arguments?
18:34:01 <augustss_> 2 or more
18:34:17 <JoshTriplett> Peaker: Not if I write "import Prelude hiding ((+))" and then "(+) :: SomeOtherType". :)
18:34:36 <JoshTriplett> > let (+) = 42 in print (+)
18:34:37 <lambdabot>   * Exception: "<IO ()>"
18:34:37 <Peaker> > let (*) = (+5) in (3*)
18:34:38 <porges> all operators are infix though
18:34:39 <lambdabot>   8
18:34:44 <porges> to get otherwise you have to bracket
18:34:51 <Peaker> augustss_: its not enforced, so can be used weirdly this way
18:34:55 <augustss_> JoshTriplett: The treatment of operators is syntax, and ny types are involved.
18:35:16 <JoshTriplett> augustss_: Yeah, OK.
18:35:16 <augustss_> s/ny/no/
18:35:20 <athos> > (\(Just n) -> n+3) Just 3
18:35:21 <lambdabot>   Couldn't match expected type `Maybe (t -> t1)'
18:35:29 <JoshTriplett> I guess I'll have to play some typeclass tricks instead.
18:35:30 <Peaker> JoshTriplett: well, its supposed to take 2 args, and having it not does not affect the parse, and is kind of pointless probably :)
18:35:35 <athos> > (\(Just n) -> n+3) $ Just 3
18:35:36 <lambdabot>   6
18:35:39 <athos> Woah.
18:35:46 <Peaker> JoshTriplett: why do you mind using () to prefixize your infix operators?
18:35:47 <athos> How cool is that
18:35:54 <augustss_> JoshTriplett: Or just write (+)
18:36:14 <porges> liftM (+3) $ Just 3
18:36:18 <porges> > liftM (+3) $ Just 3
18:36:19 <lambdabot>   Just 6
18:36:20 <Peaker> > (+3) . unjust $ Just 3
18:36:21 <lambdabot>   Not in scope: `unjust'
18:36:28 <Peaker> > (+3) . fromJust $ Just 3
18:36:30 <lambdabot>   6
18:36:37 <athos> @pl \c -> M.insert "F" ((\(Just f) -> map reverse $ [map head f, map (head.tail) f, map (head.tail.tail) f]) (M.lookup "F" c :: Maybe Face)) c
18:36:37 <lambdabot> (line 1, column 29):
18:36:37 <lambdabot> unexpected "f"
18:36:37 <lambdabot> expecting operator or ")"
18:36:40 <augustss_> it should have been called unjust!
18:36:41 <conal> (+3) <$> Just 3
18:36:44 <conal> > (+3) <$> Just 3
18:36:46 <Peaker> > maybe 0 (+3) $ Just 3
18:36:46 <lambdabot>   Just 6
18:36:47 <lambdabot>   6
18:36:57 <Peaker> note he extracted from the maybe
18:37:02 <conal> > maybe undefined (+3) $ Just 3
18:37:04 <lambdabot>   6
18:37:06 <augustss_> > 6
18:37:08 <lambdabot>   6
18:37:09 <JoshTriplett> > (+3) <$> Nothing
18:37:10 <lambdabot>   Nothing
18:37:14 <Peaker> augustss_: cheater
18:37:32 <athos> > fmap (+3) (Just 3)
18:37:33 <lambdabot>   Just 6
18:37:44 <porges> fromJust makes me feel dirty
18:37:51 <JoshTriplett> > length $ return (,) `ap` [1..3] `ap` [1..2]
18:37:52 <lambdabot>   6
18:37:53 <augustss_> rightly so
18:38:02 <Gracenotes> porges: what, would you rather define a more specific error message? :)
18:38:04 <JoshTriplett> Peaker: I have a hackish module which uses NoImplicitPrelude to abuse Haskell syntax into letting me write BASIC. :)
18:38:16 <Peaker> JoshTriplett: ouch, who wants basic?
18:38:22 <athos> @pl f x = foo x
18:38:22 <lambdabot> f = foo
18:38:24 <augustss_> JoshTriplett: !!!
18:38:33 <JoshTriplett> Peaker: Nobody *wants* BASIC.  But as an exercise in language hackery, I find it pretty amusing. :)
18:38:39 <athos> @pl f x = Some.test (3+x)
18:38:40 <lambdabot> f = Some.test . (3 +)
18:38:50 <Gracenotes> heh. GHC source code,
18:38:52 <Gracenotes> fromJust Nothing  = error "Maybe.fromJust: Nothing" -- yuck
18:38:53 <drhodes> :t (!!!)
18:38:54 <lambdabot> Not in scope: `!!!'
18:38:58 <athos> turnR c = M.insert "F" ((\(Just f) -> map reverse $ [map head f, map (head.tail) f, map (head.tail.tail) f]) (M.lookup "F" c :: Maybe Face)) c
18:39:02 <athos> whopps
18:39:06 <athos> @pl turnR c = M.insert "F" ((\(Just f) -> map reverse $ [map head f, map (head.tail) f, map (head.tail.tail) f]) (M.lookup "F" c :: Maybe Face)) c
18:39:06 <lambdabot> (line 1, column 9):
18:39:06 <lambdabot> unexpected "="
18:39:06 <lambdabot> expecting variable, "(", operator or end of input
18:39:19 <porges> @let (!!!) = error "!!!"
18:39:20 <lambdabot>  Defined.
18:39:31 <augustss_> athos: those functions you map look unpleasent
18:39:50 <athos> well, it's very ugly i know :/
18:39:54 <porges> maybe face? HE HAS NO FACE
18:40:06 <athos> type Face = [[Int]]
18:40:11 <augustss_> you could use (!!0) (!!1) (!!2)
18:40:20 <porges> eww
18:40:39 <porges> damn you undecidability
18:40:39 <JoshTriplett> Peaker: Sample: runBASIC $ do 10 PRINT "BASIC in Haskell" ; 20 GOTO 10
18:40:45 <porges> taking away our dependent types
18:40:47 <JoshTriplett> Peaker: Which does what you'd expect.
18:41:07 <porges> Num a=> ???
18:41:14 <athos> augustss_: yeah thats right
18:41:22 <Gracenotes> JoshTriplett: PRINT is a datatype or typeclass? :)
18:41:23 <athos> augustss_: prolly it's more readable
18:41:26 <JoshTriplett> Peaker: (Of course, good luck writing normal Haskell in the same module.  *shrug*.)
18:41:30 <augustss_> JoshTriplett: awesome!
18:41:32 <JoshTriplett> Gracenotes: Data type.
18:41:34 <athos> but i still feel unsatisfied with this piece :/
18:41:38 <Gracenotes> wow. neat
18:41:46 <JoshTriplett> Gracenotes: Or rather, one constructor of a data type.
18:42:09 <augustss_> JoshTriplett: you need to blog about this Haskell abuse
18:42:25 <JoshTriplett> augustss_: I plan to write it up after extending it a bit more.
18:42:30 <Gracenotes> JoshTriplett: how do you get away with 10 PRINT "string"?
18:42:32 <JoshTriplett> Right now it only has PRINT, GOTO, GOSUB, and RETURN.
18:42:48 <JoshTriplett> Gracenotes: Heh. ;)
18:42:54 <augustss_> JoshTriplett: you just need IF now
18:42:57 <JoshTriplett> Gracenotes: NoImplicitPrelude lets me redefine Integers as I see fit.
18:42:58 <Gracenotes> define some obscene instance for Num?
18:43:15 <JoshTriplett> Gracenotes: And I define integers as functions. :)
18:43:16 <Gracenotes> eek.
18:43:17 <JoshTriplett> fromInteger :: Labelable l => Integer -> l -> l
18:43:31 <JoshTriplett> instance Labelable BASIC
18:43:39 <Gracenotes> aaaaaaaaaaaaaaaah
18:43:40 <JoshTriplett> instance Labelable (a -> BASIC)
18:43:43 <augustss_> JoshTriplett: does you really need NoImplicitPrelude?
18:43:51 * Gracenotes gets a paper bag and breathes slowly into it
18:44:08 <JoshTriplett> augustss_: Only if I want line numbers.
18:44:20 <JoshTriplett> augustss_: Otherwise I could just write pretty ordinary BASIC.
18:44:20 <augustss_> JoshTriplett: hmmm
18:45:01 <Gracenotes> so you have GOSUB, but do you have SUB?
18:45:14 <JoshTriplett> augustss_: If I wrote something like runBASIC $ do l 10 PRINT "hello" , then I wouldn't need NoImplicitPrelude.
18:45:30 <JoshTriplett> Gracenotes: Named subroutines?  Nah.  No structured BASIC here, just unstructured BASIC.
18:45:30 <Gracenotes> or whatever BASIC used for functions. I wrote them so long ago...
18:45:44 <JoshTriplett> Gracenotes: But I could pretty easily implement SUB if I wanted to.
18:45:53 <JoshTriplett> Gracenotes: Right now, though, I really want to make this work:
18:45:59 <JoshTriplett> 10 PRINT 2 + 2
18:46:10 <JoshTriplett> And note that I didn't write (2 + 2). :)
18:46:12 <Gracenotes> without the parens, huh.
18:46:33 <Gracenotes> if you encounter a return not in a GOSUB, what happens? Nothing?
18:46:41 <JoshTriplett> Gracenotes: End of program.
18:46:46 <JoshTriplett> Gracenotes: (arbitrary)
18:46:48 <Gracenotes> ah. interesting.
18:46:53 <SamB> "ERROR: RETURN WITHOUT GOSUB"
18:46:56 <JoshTriplett> If I could define + as a unary operator, along with * and - and everything else, I could just implement a shift-reduce "parser" for operator precedence.
18:47:02 <JoshTriplett> SamB: Yeah, I could have done that instead.
18:47:13 <JoshTriplett> Er, as a nullary operator I meant.
18:47:46 <JoshTriplett> But since + has to take two arguments, I instead need to make it support a left argument of type BASIC, and dig into the BASIC to figure out where to append the +. :)
18:47:58 <JoshTriplett> (10 PRINT 2) + 2, effectively.
18:48:11 <Gracenotes> yes.
18:48:37 <Gracenotes> how would you interpret 10 PRINT "OH" + 2
18:49:06 <JoshTriplett> Gracenotes: Ideally as a compile-time type error.
18:49:21 <Gracenotes> that would be impressive :)
18:49:58 <JoshTriplett> Or alternatively, as 10 PRINT "OH2", interpreting + as string concatenation.
18:50:28 <Gracenotes> whee, an overloaded +
18:50:43 <JoshTriplett> Or, if you follow the Perl model, 10 PRINT 2, interpreting "OH" as 0 since it has no digits.  (And "2" + 2 = 4).
18:50:50 <athos> @pl \c -> M.insert "F" ((\(Just f) -> map reverse $ [map (!!0) f, map (!!1) f, map (!!2) f]) (M.lookup "F" c :: Maybe Face)) c
18:50:51 <lambdabot> (line 1, column 29):
18:50:51 <lambdabot> unexpected "f"
18:50:51 <lambdabot> expecting operator or ")"
18:51:00 <athos> @pl \c -> M.insert "F" ((\f -> map reverse $ [map (!!0) f, map (!!1) f, map (!!2) f]) (M.lookup "F" c :: Maybe Face)) c
18:51:00 <lambdabot> M.insert "F" =<< map reverse . ap ((:) . map (!! 0)) (ap ((:) . map (!! 1)) (return . map (!! 2))) . (:: Maybe Face) . M.lookup "F"
18:51:14 <athos> hehe
18:51:15 <revertTS> does lambdabot have a werewolf plugin?
18:51:27 <Gracenotes> revertTS: like, mafia?
18:51:35 <Gracenotes> the-game-also-called
18:51:36 <athos> :t fromJust
18:51:37 <lambdabot> forall a. Maybe a -> a
18:51:41 <revertTS> Gracenotes: yeah
18:51:44 <athos> > fromJust $ just 5
18:51:45 <lambdabot>   Not in scope: `just'
18:51:47 <athos> > fromJust $ Just 5
18:51:48 <lambdabot>   5
18:52:19 <Gracenotes> revertTS: not that I'm aware of. Actually, I'm mulling over and IRC bot library in my mind... haven't gone too far with it, though
18:52:25 <Gracenotes> *an
18:52:55 <Gracenotes> the connection and parsing stuff is simple enough, but the whole point of a library is a nice, streamlined design :)
18:53:09 <pumpkin> reactive irc bot! ;)
18:54:33 <Gracenotes> are there any libraries which use reactive to provide some functionality? Or only reactive, by itself?
18:54:40 <Gracenotes> (or yampa etc.)
18:54:59 <lispy> Anyone know if this paper was published? http://okmij.org/ftp/Computation/lightweight-dependent-typing.html
18:55:16 <Gracenotes> hm, http://hackage.haskell.org/packages/archive/pkg-list.html#cat:frp
18:56:17 <Gracenotes> really, though, simple would do it, probably some fancy tricks with monad transformers and some sugar-y functions for creating a "bot in 10 lines" or somesuch that offer frameworks offer
18:57:44 <lispy> dons has a blog article to the effect of "creating a bot in 10 lines"
18:57:57 <Gracenotes> yes. Although it's more than 10 lines :)
18:58:01 <lispy> (I'm missing context, so maybe that's not useful info, sorry if that is the case!)
18:58:29 <Gracenotes> I've looked at it. It definitely points the direction in terms of which (e.g. networking) modules would be useful
18:59:17 <Gracenotes> I've written little IRC bot frameworks in two languages already... they're not uncommon :)
18:59:43 <lispy> yeah and someone on here mentioned an irc client in Haskell
18:59:45 <lispy> Hercules?
18:59:49 <Gracenotes> hircules
19:00:01 <lispy> ah
19:00:11 <pastah> i hate wx
19:00:17 <lispy> Not the name I would pick :)
19:00:25 <pastah> and i especially hate wxHaskell
19:00:32 <athos> @index (<$>)
19:00:32 <lambdabot> bzzt
19:00:35 <athos> @index <$>
19:00:35 <lambdabot> bzzt
19:00:43 <lispy> ?hoogle <$>
19:00:44 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
19:00:50 <athos> ah, thakns!
19:00:53 <lispy> np
19:00:57 <lepassive> wx/gtk are useless as qt moved LGPL
19:00:57 <conal> pastah: for being imperative?
19:01:05 <lispy> ?ho <$>
19:01:06 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
19:01:17 <pastah> > (+1) <$> [1..10]
19:01:19 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
19:01:30 <lispy> <$> is basically liftM/fmap
19:01:42 <pastah> conal: for being stupid... and for having shitty documentation
19:01:43 <conal> lepassive: ?? qt's license change affected wx & gtk?
19:01:46 <pastah> and shitty exapmles
19:02:01 <conal> pastah: anything more specific than stupid?
19:02:49 <lispy> What I didn't like about wxHaskell was that I felt that event handlers needed global state and I felt compelled to use the top level unsafePerformIO hack
19:03:04 <conal> lispy: oh, urg.
19:03:12 <lepassive> conal, of course, GTK 'd havent been there except of Qt's License issue and wx is mainly described as 'alternative to Qt when you get stuck'
19:03:15 <pastah> conal: yeah, the whole issue with that you can't draw a new line in a frame/panel without having to redraw all your old ones
19:03:21 <conal> lispy: i didn't run into that trouble with wxHaskell.
19:03:42 <lispy> conal: my level of experience at the time could have been the limiting factor
19:04:17 <conal> lispy: could be.  the designer of wxHaskell (not wx) is one of the best designers & implementors i know.
19:04:23 <athos> hmm
19:04:25 <athos> f' = (\(Just x) -> map reverse [map (!! 0) x, map (!! 1) x, map (!! 2) x]) f
19:04:30 <athos> this looks really ugly
19:04:34 <conal> lispy: on the other hand, it *is* an imperative library.
19:04:39 <pastah> and that is especially annoying when you're drawing an infinite number of lines
19:04:41 <athos> (f :: Maybe [[Int]])
19:04:46 <p_l> lepassive: GTK for me has this one great thing, namely not requiring C++ :-)
19:04:55 <pastah> conal: who designed it?
19:05:12 <conal> pastah: daan leijen.
19:05:16 <athos> anyone got an idea how this can be done prettier? :)
19:05:48 <porges> lispy: not basically, it *is* fmap :)
19:05:52 <lepassive> p_l, I've crossed on qtHaskell a few days ago while *venturing haskell* and it sounds just great
19:06:03 <pastah> athos: use hpaste and show some desired output for some inputs...
19:06:12 <lispy> porges: But it has a different type so it can't be exactly :)
19:06:29 <lispy> porges: oh, maybe I'm wrong
19:06:30 <athos> Service Temporarily Unavailable
19:06:30 <athos> The server is temporarily unable to service your request due to maintenance downtime or capacity problems. Please try again later.
19:06:34 <athos> :(
19:06:35 <chessguy> what is (>>=) for ((->)e) ?
19:06:38 <athos> hpaste is N/A unfortunately
19:06:47 <porges> :t fmap
19:06:48 <lispy> ?type (>>=)
19:06:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:06:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:06:53 <jeffz`> @where hpaste2
19:06:54 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
19:06:55 <porges> :t (<$>)
19:06:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:07:19 <lispy> porges: I was thinking it worked on a different class than functor, something simpler
19:07:20 <conal> sometimes people think a library is defective when really it doesn't fit their preconceptions/expectations.
19:07:47 <porges> it's defined in applicative to match <*> :) so you get f <$> x <*> y
19:07:48 <lispy> chessguy: so replace m with (e ->) and see if you can figure out the type
19:08:07 <chessguy> lispy:  i know the type, i don't know the implementation
19:08:08 <conal> just as some people think functional programming is defective when they're used to thinking imperatively.
19:08:12 <lispy> chessguy: that should give you a pretty good idea what bind is for reader
19:08:22 <chessguy> oh
19:08:27 <chessguy> maybe i don't know the type
19:08:33 <athos> hm, i'll use different paste
19:08:43 <athos> hpaste2 messes up the whole layout
19:08:44 <lispy> chessguy: I haven't done the exercise myself, I'm just guessing :)
19:09:20 <pastah> athos: maybe [] (map reverse . transpose)
19:09:37 <athos> :t transpose
19:09:38 <lambdabot> forall a. [[a]] -> [[a]]
19:09:39 <lispy> m a -> (a -> m b) -> m b ==> (e -> a) -> (a -> e -> b) -> (e -> b)
19:09:59 <pastah> athos: try that out, i think that's what you want...
19:10:31 <conal> pastah: nice one.
19:10:31 <lispy> chessguy: That doesn't look quite right to me
19:10:41 <lispy> chessguy: maybe I can't figure it out from the type after all
19:10:55 <chessguy> ((e -> a) -> b) -> (e -> a) -> (e -> b)
19:10:59 <chessguy> that's what i got
19:11:18 <silentOpen> ack! nfiniterelayou loo
19:11:31 <athos> @src transpose
19:11:31 <lambdabot> transpose []             = []
19:11:31 <lambdabot> transpose ([]   : xss)   = transpose xss
19:11:31 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:11:36 <athos> pastah: yeah it is, thanks
19:11:56 <pastah> conal: thanks... but as to my trouble with an infinite list of thinks to draw... any ideas? i have been looking a little at paintRaw, but i'm not sure how to use it (seing how the documentation for it is missing)
19:12:06 <lispy> chessguy: I don't thnk your type is right
19:12:12 <chessguy> lispy:  probably not
19:12:18 <lispy> chessguy: why is the first part ((e -> a) -> b) ?
19:12:37 <lispy> chessguy: also, I think your first two parameters are swapped from the order of (>>=)
19:12:58 <conal> pastah: not off-hand.  i think there's a wxHaskell mailing list.
19:13:14 <augustss_> JoshTriplett: you can do a lot without NoImplicitPrelude.  It's a bit icky, but who cares. :)
19:13:18 <athos> :t maybe
19:13:18 <lispy> IIRC, kowey was the maintaner of wxHaskell or still is
19:13:19 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:13:25 <chessguy> lispy, it's ((->) t) a -> (a -> ((->) t) b) -> ((->) t) b
19:13:30 <pastah> conal: wow, this lib is really amazing... i have to join the mailing list in order to get shit done
19:13:32 <pastah> nice
19:13:42 <chessguy> lispy:  but i haven't worked it out in normal notation yet
19:13:55 <lispy> chessguy: okay, well ((->) t) a = t -> a
19:13:55 * pastah is a tad bitter
19:14:04 <athos> > maybe (map reverse.transpose) [[1..3],[4..6],[7..9]]
19:14:05 <lambdabot>   Couldn't match expected type `a -> [[a1]] -> [[a1]]'
19:14:13 <chessguy> so (t -> a) -> (a -> (t -> b)) -> (t -> b)
19:14:24 <porges> what's the equivalent of Applicative in the Categorical library
19:14:26 <pastah> athos (maybe [] myFun)
19:14:33 <lispy> chessguy: right and (a -> (t -> b)) reduces to a -> t -> b
19:14:33 <athos> oh okay
19:14:43 <pastah> @type maybe
19:14:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:14:55 <pastah> @type maybe []
19:14:57 <lambdabot> forall a a1. (a1 -> [a]) -> Maybe a1 -> [a]
19:15:10 <athos> i see, thanks
19:15:11 <pastah> athos: seing how [] :
19:15:16 <pastah> [] :: [a]
19:15:24 <lispy> chessguy: function arrows are right associative if I recall correctly
19:16:13 <porges> (a → t → b)... don't forget the outside parentheses :)
19:16:31 <lispy> chessguy: I have this feeling that we'd have solved this already if we thought of it in terms of join instead
19:16:50 <athos> pastah: i'm now down to: f' = map reverse . transpose $ fromJust
19:17:02 <chessguy> lispy:  i've got it
19:17:04 <athos> fromJust f
19:17:14 <athos> pastah: or is fromJust considered harmful or something? :)
19:17:23 <lispy> > fromJust Nothing
19:17:25 <lambdabot>   * Exception: Maybe.fromJust: Nothing
19:17:32 <lispy> athos: ^^ :)
19:17:55 <lispy> chessguy: so what does it do?
19:18:04 <conal> pastah: maybe there's another lib that fits you better.  good luck in any case.
19:18:07 <pastah> athos: don't use fromjust
19:18:16 <athos> hm
19:18:19 <pastah> it's kinda unsafe
19:18:33 <pastah> use the function maybe instead
19:18:40 <chessguy> Lispy: (>>=) g f = \x -> f (g x) x
19:18:47 <Gracenotes> maybe is somewhat too general at times
19:18:51 <pastah> does the same thing, AND allows you to fail, all at the same time :D
19:18:52 <lispy> chessguy: right :)
19:18:53 <athos> maybe my whole design is fucked up, because i can be quite sure that Nothing won't occur
19:19:22 <athos> the Maybe is (necessarily) created from some Map.lookup call
19:19:24 <lispy> > (+1) >>= (*2) 1
19:19:26 <lambdabot>       Overlapping instances for Show (a -> b)
19:19:26 <lambdabot>        arising from a use of `s...
19:19:32 <lispy> > ((+1) >>= (*2)) 1
19:19:34 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
19:19:34 <lambdabot>      Proba...
19:19:51 <pastah> well i you never can get Nothing, then you shouldn't have any use of Just either
19:19:52 <lispy> > ((+1) >>= (*)) 1
19:19:54 <lambdabot>   2
19:20:12 <pastah> @hpaste2
19:20:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:20:15 <Gracenotes> pastah: lookup does
19:20:47 <Gracenotes> athos: do you have some sort of enum mapped to values? And each enum has a pair?
19:21:09 <lispy> chessguy: when the types have such a high degree of parametric polymorphism like that you can usually reason out the implemenation from the types :)
19:21:44 <athos> Gracenotes: i have got six pairs of the form (String,[[Int]])
19:21:59 <monochrom> haha
19:22:30 <Gracenotes> athos: hm. 'Just' Curious, where do you get the strings from?
19:22:34 <pastah> athos: what are you working on?
19:22:55 <augustss_> Wow!  BASIC is Haskell is wonderfully perverse
19:23:09 <lispy> augustss_: say what?
19:23:11 <monochrom> Very perverse.
19:23:15 <pastah> augustss_: wut?
19:23:28 <monochrom> "BASIC in Haskell" I bet.
19:23:46 <pastah> a domain specific language?
19:23:49 <lispy> More like, Beginner's All-purpose Symbolic Instruction Code
19:23:52 <augustss_> JoshTriplett has the great idea of doing BASIC as an embedded language in Haskell
19:24:03 <lispy> augustss_: link please?
19:24:06 <Gracenotes> where's the code? :)
19:24:26 <augustss_> No links yet.  But I've hack a little myself now
19:24:28 <athos> Gracenotes: well, at the moment of course hardcoded, but basically the user should deliver 6 [[Int]] and i just determine on my own which [[Int]] get's which string
19:24:39 <augustss_> prog = do
19:24:39 <augustss_>     10 PRINT "Hello"
19:24:40 <augustss_>     15 GOSUB 30
19:24:40 <augustss_>     20 GOTO 10
19:24:40 <augustss_>     25 PRINT 2 + 3
19:24:40 <augustss_>     30 RETURN
19:24:42 <athos> the strings that will be used are predefined
19:24:44 <defun> Is the top half of this code (http://pastebin.com/f4d0b48f4) equivalent to the bottom half?
19:24:48 <augustss_> There's a snippet
19:25:04 <lispy> augustss_: Hmm...so using a BASIC monad?
19:25:04 <athos> pastah: well, basically it should grow to a simple rubik's cube (3x3) solver
19:25:06 <Gracenotes> athos: could you perhaps use an ADT instead of the strings...?
19:25:15 <augustss_> lispy: indeed
19:25:21 <athos> pastah: i don't mind really short (proven short) solutionns
19:25:30 <athos> Gracenotes: hm, yeah, would be possible to
19:25:40 <pastah> augustss_: are you abusing callCC for making goto work here?
19:25:43 <lispy> augustss_: does it also require a funky instance for Int? (I'm wondering how 10 can be where it is)
19:25:45 * Pseudonym would imagine that FOR loops would be hard
19:25:49 <athos> Gracenotes: maybe that's "cleaner"
19:26:00 <athos> because i don't use any feature which come from using strings
19:26:06 <augustss_> pastah: nah, you can just collect all the lines in a writer monad and interpret them
19:26:20 <Gracenotes> athos: perhaps. You also have this function..
19:26:21 <lispy> is it just me, or was BASIC very inspired by fortran?
19:26:22 <Gracenotes> :t fromEnum
19:26:23 <augustss_> lispy: it does need some strange overloading
19:26:23 <lambdabot> forall a. (Enum a) => a -> Int
19:26:43 <Gracenotes> athos: so you can do ["item1", "item2", ... "item3"] !! fromEnum yourvalue
19:26:45 <pastah> augustss_: and do all lines HAVE to be numbered?
19:26:54 <Gracenotes> or just use pattern matching, or something
19:26:55 <Pseudonym> lispy: You can't change the value of 4 in Fortran.
19:26:56 <augustss_> pastah: it's BASIC, of course
19:27:00 <Pseudonym> Sorry, in BASIC.
19:27:18 <Gracenotes> It may or may not be more elegant depending on your program, but it might help :)
19:27:19 <lispy> Pseudonym: but you can in fortran?
19:27:21 <pastah> i was under the impression that it wasn't a requirement
19:27:23 <Pseudonym> Yup.
19:27:28 <augustss_> Pseudonym: and only in some implementations of FORTRAN
19:27:33 <Pseudonym> augustss: How much of ANSI BASIC does it implement?
19:27:39 <athos> Gracenotes: okay, thank you :)
19:27:40 <Pseudonym> Sigils would be lexically difficult.
19:27:54 <Gracenotes> no problem
19:28:06 <Gracenotes> and make it derive Enum, Eq, probably Show might help, etc.
19:28:43 <Gracenotes> augustss_: Do you have a BASIC type you make into a monad? The kind is * -> *, no?
19:29:19 <augustss_> Gracenotes: I don't want to steal JoshTriplett's thunder.  I'll let him explain. :)
19:29:33 <chessguy> geez, there's 20 of these exercises, and i'm only through 10 of them....
19:29:40 <Gracenotes> I saw him explain it earlier
19:29:42 <chessguy> augustss_:  is he on planet haskell?
19:29:59 <augustss_> chessguy: I dunno.  He should be
19:30:02 <Gracenotes> chessguy: the furry exercises?
19:30:08 <chessguy> Gracenotes:  yeah
19:30:10 <Gracenotes> :t emptyDef
19:30:11 <lambdabot> Not in scope: `emptyDef'
19:30:18 <Gracenotes> defun: what is emptyDef?
19:30:41 <augustss_> I guess LET X = 5 will never work :(
19:30:49 <chessguy> augustss_:  nope :(
19:30:57 <chessguy> augustss_:  (he's not)
19:31:01 <Gracenotes> augustss_: maybe .=., though :)
19:31:09 <pumpkin> stick it all in a QQ :P
19:31:11 <lispy> or :=
19:31:19 <Gracenotes> chessguy: you just have to think through the type signatures... of course, being familiar with monads might've helped me beforehand
19:31:29 <defun> Gracenotes: No idea. I copied the example from a parsec tutorial. Just wanted to make sure I could use the latter syntax instead of the first.
19:31:41 <chessguy> Gracenotes:  yeah, i'm progressing....slowly
19:32:22 <Gracenotes> > let (:=) = flip const in 'x' := 3
19:32:23 <lambdabot>       No instance for (Show (Assoc Char t))
19:32:23 <lambdabot>        arising from a use of `sho...
19:32:27 <Gracenotes> wha.
19:32:59 <lispy> What is Assoc?
19:33:06 <lispy> ?hoogle Assoc
19:33:08 <lambdabot> Control.Parallel.Strategies data Assoc a b
19:33:09 <lambdabot> Text.Parsec.Expr data Assoc
19:33:09 <lambdabot> Text.ParserCombinators.Parsec.Expr data Assoc
19:33:55 <lispy> Anyway, I expect := to parse as a data constructor
19:34:12 <Gracenotes> defun: hm... emptyDef seems to be a data constructor
19:34:32 <Gracenotes> a default instance of a data type
19:34:54 <Gracenotes> the tutorial uses something called "record replace" or somethinglike syntax
19:34:57 <sjanssen> augustss_: LET X <- 5 -- possibly?
19:35:12 <Gracenotes> defun: see http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-Language.html#emptyDef
19:35:32 <Gracenotes> those are the default values for emptyDef. By having the {block} after, you replace the default values with your new values without copying them all explicitly
19:35:42 <augustss_> sjanssen: my brains hurts trying to figure out if that is possible.  I thin I'll use := or =:
19:35:56 <Gracenotes> defun: and record replacing only works with curly braces, I believe
19:36:09 <augustss_> sjanssen: I think it is possible
19:36:38 <Gracenotes> defun: so the second version is not equivalent; I don't think it compiles, actually
19:36:42 <augustss_> sjanssen: since BASIC only has 286 variables
19:36:50 <Gracenotes> ah, it's called record update syntax
19:36:57 <pumpkin> omg now we know where the x86 naming scheme came from
19:37:27 <Gracenotes> > 26*26
19:37:29 <lambdabot>   676
19:38:30 <Gracenotes> defun: sorry if you're lost :) But, the important thing is that your example takes the default definition of emptyDef and replaces values like "commentStart" and "commentEnd" with different tokens
19:42:52 <defun> Gracenotes: ok, I've got it figured out, now. Though, I'd really like to know what the difference is the type Bool and the type !Bool. (Or type Int and !Int, for example). What does the '!' do?
19:43:29 <Gracenotes> it's a bang pattern
19:44:00 <Gracenotes> I'm not quite familiar with them myself
19:44:01 <pumpkin> it makes it strict
19:44:30 <Gracenotes> from what I understand, it absolutely makes sure that the type you claim to give it is 100% the correct type
19:44:42 <Gracenotes> http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html might be more helpful :x
19:45:23 <pumpkin> you only use it in type constructors
19:45:25 <Gracenotes> http://www.haskell.org/haskellwiki/Keywords#.21 also
19:45:33 <defun> thanks.
19:45:36 <koninkje> Type checking makes sure you get the correct type, strictness just ensures you don't have the _|_ value
19:45:38 <pumpkin> and it ensures that the given field is strict
19:46:17 <Gracenotes> yes. and undefined or let a=a would be the wrong 'type', although not to the compiler sans bangs
19:46:19 <pumpkin> bang patterns are the extension that allows something similar in arguments to functions
19:46:46 <Twey> let a = a in a :: a
19:46:48 <thoughtpolice> they allow you to use a bang ('!' character) anywhere a pattern is permitted
19:47:21 <Gracenotes> pumpkin: okay, so what's it called in a type constructor?
19:47:42 <pumpkin> strict field?
19:47:53 <pumpkin> that's my guess given the -funbox-strict-fields option :)
19:48:01 <pumpkin> but I dunno, haven't heard them named
19:48:08 <thoughtpolice> patterns using '!' which mean 'strictness' in data constructor fields are part of the standards
19:48:16 <thoughtpolice> bang patterns extend that functionality to any pattern
19:58:07 <pumpkin> @users
19:58:08 <lambdabot> Maximum users seen in #haskell: 699, currently: 623 (89.1%), active: 13 (2.1%)
19:58:34 <pumpkin> tomorrow will be The Day
20:01:42 <Gracenotes> Gee, pumpkin, what do you want to do tomorrow?
20:01:50 <pumpkin> hit 700!
20:02:20 <Gracenotes> correct response: "The same thing we do every day, Gracenotes: try to take over the world! mwahahaha" ;)
20:02:30 <sjanssen> @brain
20:02:31 <lambdabot> Pinky, I am in considerable pain.
20:02:35 <pumpkin> The same thing we do every day, Gracenotes: try to take over the world! mwahahaha
20:03:17 <Gracenotes> mwahaha...er
20:04:49 <spooXe> please visit http://pages.ykt.ru/svalka/
20:05:06 <Gracenotes> I dunno, I wouldn't if I were you :x
20:05:09 <cknapp> pumpkin: I miss that show...
20:05:13 * cknapp is sad now...
20:05:37 <pumpkin> spooXe: o.O
20:05:54 <pumpkin> cknapp: blame Gracenotes!
20:05:56 <monochrom> please visit haskell.org :)
20:06:28 <monochrom> spooXe is clearly a spammer who doesn't care what you say.
20:06:33 <cknapp> Yeah... I just came into the discussion, and then read what I missed and now I'm sad *and* I feel stupid.
20:06:53 <Gracenotes> @brain
20:06:53 <lambdabot> I think so, Brain, but a codpiece made from a real fish would get smelly after a while, wouldn?t it?
20:07:08 <Gracenotes> ah. Are you thinking what I'm thinking...?
20:07:23 <Gracenotes> @brain
20:07:24 <lambdabot> But where are we going to find a duck and a hose at this hour?
20:07:33 <Gracenotes> @brain
20:07:33 <lambdabot> I think so, Commander Brain from Outer Space! But do we have time to grease the rockets?
20:07:46 <porges> @type (.id(.))
20:07:48 <lambdabot> forall c b c1 a. (((a -> b) -> a -> c1) -> c) -> (b -> c1) -> c
20:08:00 <Gracenotes> Pinky seems more the cultural, literate type than the engineer type
20:08:01 <porges> O_O
20:11:44 * jberryman is hoping that's not what porges wants
20:12:17 <cknapp> well then...
20:12:17 <porges> I don't think I even understand how that type works
20:14:03 <porges> hrm. there's a bit of a hole in haskell syntax
20:14:47 <Saizan> porges: really?
20:14:50 <porges> if you have a class Foo (-->) where bar :: a --> b --> c, for example, there's no way to say (-->) should be right-associative
20:15:06 <porges> although it's probably good for understandability
20:15:15 <gwern>  @yow
20:15:25 <gwern> 'Yow! I can HEAR the CONSing!'
20:25:59 <bos> @users
20:25:59 <lambdabot> Maximum users seen in #haskell: 699, currently: 613 (87.7%), active: 12 (2.0%)
20:26:09 <bos> holy cannoli, we've gotten up to almost 700?
20:28:18 <pumpkin> bos: yeah, tomorrow will be the day!
20:32:11 <koninkje> Why oh why does everyone have to introduce monads by starting with IO?
20:32:52 <Twey> Because they want to make it as difficult a concept for new learners to grasp as possible
20:32:54 <monochrom> Wrong. Phil Wadler doesn't.
20:33:23 * koninkje hasn't seen Phil's intro
20:33:28 <arw> same reason everyone starts computers with windows. if you have expirienced pain you can appreciate whats nice :)
20:33:42 <koninkje> He would be the one who wouldn't mess it up :)
20:34:10 <monochrom> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf  accept no substitute.
20:34:33 <koninkje> ah yes, that paper. Hmm, I suppose it *is* an intro...
20:35:55 <koninkje> Though I was referring more to the 1,001 Haskell tutorials that get everyone off on the wrong foot thinking that monads have anything whatsoever to do with side effects
20:36:24 <Twey> Well, I started off thinking that . was >>
20:36:43 <koninkje> that would be intriguing
20:37:02 <Gracenotes> :t (>>)
20:37:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
20:37:41 <Gracenotes> in general, one shouldn't expect that someone learn monads before they do some I/O
20:37:58 <geezusfreeek> Gracenotes, as a musician, i find your nick amusing
20:37:59 <lambdabot> geezusfreeek: You have 1 new message. '/msg lambdabot @messages' to read it.
20:38:00 <koninkje> Why not? The list monoid is terribly useful
20:38:23 * pumpkin skips the Gracenotes
20:38:24 <Gracenotes> koninkje: practicality is enticing when learning a language
20:38:25 <koninkje> As is Maybe
20:38:27 <pumpkin> actually, I don't
20:38:44 <Gracenotes> that's why so many tutorials to programming languages with REPLs start out using the language as a calculator
20:39:22 * koninkje looks for the fibs button on my TI-82
20:39:54 <Gracenotes> geezusfreeek: I picked it in reference to acciaccatura and the like
20:40:28 <pumpkin> acciacatura della merda?
20:40:49 <Gracenotes> I also have apoyaturas, note_d-agrement, and vorschlagsnoten linked to this name
20:41:00 <Gracenotes> the French is singular, but I don't know French well enough
20:41:00 <pumpkin> :o
20:41:02 <geezusfreeek> interesting
20:41:35 <monochrom> Some people don't care about the list monad. All they care is I/O.
20:41:50 <hackage> Uploaded to hackage: WikimediaParser 0.1
20:41:50 <hackage> Uploaded to hackage: hs-twitter 0.2.5
20:41:57 <Gracenotes> koninkje: you'll need a TI-89 :)
20:41:58 <geezusfreeek> those people are learning the wrong language
20:42:17 <koninkje> People coming from the Python world and such certainly seem fond of their list comprehensions...
20:43:06 <Gracenotes> I agree that I/O isn't necessarily a good way to introduce monads, but in general I/O is not a bad thing to learn
20:43:11 <Saizan> btw, monads are all about effects though, but not necessarily IO effects
20:43:55 <koninkje> Monads are about structure, which only falls under a _very_ broad notion of "effect"
20:44:08 <roconnor> only by defining effects to be what monads are all about
20:44:21 <Gracenotes> I read the I/O chapter in RWH before learning about monads. I'm not crippled for life with respect to monad comprehension, I don't think :)
20:44:52 <roconnor> @type get
20:44:54 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
20:44:57 <roconnor> @type put
20:44:58 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
20:45:11 <Gracenotes> although, BASIC was my first language. So apparently I've been saved from many possibly-life-crippling programming actions :P
20:45:14 <geezusfreeek> monads just provide combinators. i don't see all this hubbub about effects, spacesuits, etc. anymore (although i do relate to learning with them)
20:45:50 <monochrom> monad is broader than number. remember how many years you spent learning numbers. then you will spend the same number of years on monads.
20:45:56 <koninkje> I think monads and IO can be perfectly well introduced separately. And from what I've seen, introducing them together teaches monads like telling someone a car has to do with bananas
20:46:23 <Saizan> well, they were introduced in CS to describe the semantics of non-pure languages, afaik
20:46:33 <roconnor> a car is a tool for transporting bananas from a store to home
20:46:33 <monochrom> "learning" means at the end you have to realize you should stop asking "what is number", "what is zero".
20:46:41 <koninkje> roconnor: yes!
20:47:10 <geezusfreeek> monochrom, so true, but so hard to explain
20:47:23 <Gracenotes> there's ignorance, rudimentary skills, superficial understanding, then finally mastery :P
20:47:44 <roconnor> > @type runState
20:47:45 <lambdabot>   <no location info>: parse error on input `@'
20:47:50 <roconnor> @type runState
20:47:51 <lambdabot> forall s a. State s a -> s -> (a, s)
20:47:56 <Gracenotes> according to one model anyway
20:47:57 <geezusfreeek> i would have inserted a few ???s between superficial understand and mastery ;)
20:48:13 <geezusfreeek> *understanding
20:48:23 <Gracenotes> I wonder -- is it possible to conceptually introduce monads without introducing >>= or >>? i.e., using only do notation and returns?
20:49:00 <koninkje> you need return and join
20:49:01 <geezusfreeek> i would rather introduce >>= without introducing do notation
20:49:02 <monochrom> do { x; y; z}  you need that thing between those x, y, z.
20:49:26 <koninkje> (that is, sine you've said you don't like the return+bind alternative ;)
20:49:29 <Gracenotes> koninkje: well the semicolons are conceptually >>, and <- is conceptually >>=
20:49:44 <Gracenotes> return+join is one representation of monads, but the >> and >>= are implicit in do notation
20:50:05 <geezusfreeek> although i must say i agree with conal on this one. (=<<) :: (a -> m b) -> (m a -> m b) just makes far more sense to me
20:50:08 <Gracenotes> I mean, >>= is a lot more clear, I'm considering the merits of a do-only route :)
20:50:11 <roconnor> > mdo { put c; a <- get; put undefined; b<-get; put 7; c <- get; return (a,c)} 6
20:50:12 <lambdabot>   <no location info>: parse error on input `6'
20:50:25 <roconnor> > runState (mdo { put c; a <- get; put undefined; b<-get; put 7; c <- get; return (a,c)}) 6
20:50:26 <lambdabot>   ((7,7),7)
20:50:34 <roconnor> jackpot
20:51:52 <geezusfreeek> the merits of a do-only learning path is you can use do notation to introduce IO and keep that separate from general monads for a while, only much farther down the line presenting IO as a monad and do notation as a notation for any monad
20:52:12 <koninkje> Gracenotes: I think the do-notation is a bit too implicit to give a good introduction to monads. E.g., a number of the monad laws become less obvious looking
20:52:33 <koninkje> Serviceable, perhaps. But non-ideal
20:52:35 <Gracenotes> hm... that's true
20:53:05 <koninkje> geezusfreeek: I'd say that's probably the best way to do it.
20:53:17 <Gracenotes> do { m' <- return m; f} == f m
20:53:25 <koninkje> Well that or the way Mark Jones teaches it (which avoids do-notation alltogether)
20:53:32 <geezusfreeek> i'm imagining a beginner finally getting to the point that it is revealed that do notation is just syntax sugar for monad and letting them make the connection that IO is itself a monad. "Woah!"
20:53:34 <Gracenotes> er, s/f}/f m'/
20:53:38 <Gracenotes> }
20:53:45 <Gracenotes> yeah, it's getting a bit tricky >_>
20:54:13 <porges> (>>) :: (Applicative f (x) (⤳), Functor f (→) (→)) ⇒  f () → (f a ⤳ f a)
20:54:23 <koninkje> geezusfreeek: one of the tricky things with that approach is it leads people ot the idea that IO is somehow special, which undermines the emphasis on purity
20:54:28 <porges> hurrah for type inference
20:55:00 <geezusfreeek> if you don't teach IO up front the only alternative is to allow beginners to believe it is special for a while, i think
20:55:27 <porges> interesting thing is that the first Category of Applicative completely doesn't matter
20:55:28 <erikc> and handwave the liftM's
20:56:06 <Gracenotes> impure actions aren't bad, necessarily. Just, there are certain benefits to explicitly 'separating' it from pure results
20:56:29 <Gracenotes> I was wary of I/O for a while until I realized I had to use it sooner or later :P
20:56:37 <koninkje> Gracenotes: the join . join == join . fmap join rule gets really wacky
20:57:08 <monochrom> The commuting diagram for that is really nice. :)
20:57:44 <koninkje> monochrom: the one with [[[a]]]?
20:57:51 <Gracenotes> koninkje: well... join is more important in the category theory sense. For monad laws in Haskell programs, not so much, though they naturally follow from the ones involving >>= and return
20:57:52 <monochrom> Yes.
20:58:39 <koninkje> Gracenotes: That law is crucial, it's what gives associativity of composing monadic actions. The version with bind is just the one we usually see
20:59:12 <koninkje> (x >>= f) >>= g == x >>= (\x' -> f x' >>= g)
20:59:16 <Gracenotes> yeah
20:59:29 <koninkje> though it looks less pretty :)
20:59:32 <Gracenotes> that version isn't /terribly/ in do notation
20:59:36 <Gracenotes> *terrible
21:02:33 <Saizan> do-notation desugars to the latter, right?
21:03:13 <Saizan> ?undo do v <- x; v' <- f x; g v'
21:03:14 <lambdabot> x >>= \ v -> f x >>= \ v' -> g v'
21:04:14 <Saizan> (f >=> g) >=> h == f >=> (g >=> h) is prettier anyhow :)
21:04:42 <monochrom> http://www.haskell.org/haskellwiki/Monad_laws  has the do version.
21:04:54 <monochrom> Please visit http://www.haskell.org/ ! :)
21:06:01 <Saizan> "In this notation the laws appear as plain common sense."
21:06:08 <koninkje> And I do say it doesn't roll off the tongue in the same way
21:08:28 <monochrom> People do not internalize enough the fact that laws/axioms are there to formalize common sense. They read it in school, they nod through it, and they can give that as answer in exams, but they don't etch it into their feelings.
21:10:27 <geezusfreeek> huh, so (Monad m => a -> m a) is a monoid with (mempty = return) and (mappend = (<=<)) or (mappend = (>=>)). could that be at all useful...
21:10:53 <geezusfreeek> we already have a Category instance that does almost the same thing i suppose
21:11:36 <koninkje> Monads are monoids on a category of endofunctors
21:12:03 <Saizan> that's a different monoid though, i think?
21:12:10 <NameAlreadyInUse> @src (==)
21:12:11 <lambdabot> x == y = not (x /= y)
21:12:22 <dibblego> does lambdabot have a command @last-spoke?
21:12:35 <geezusfreeek> i understand only on a very naive level that a monad is a monoid somehow
21:12:46 <NameAlreadyInUse> @src (/=)
21:12:46 <lambdabot> x /= y = not (x == y)
21:12:51 <koninkje> It's a strange thing to internalize, IMO
21:12:53 <Saizan> geezusfreeek: that's basically Endo in the Kleisli category for m
21:12:54 <geezusfreeek> i see "endofunctor" all the time. i should really try to internalize it
21:13:12 <geezusfreeek> yes, and Endo ;)
21:13:45 <koninkje> all Functors are endofunctors (what other category would you map Haskell types into?)
21:14:21 <koninkje> ((when programming in Haskell I mean))
21:14:31 <Gracenotes> endomorphism is just an a -> b?
21:14:32 <gnut> hi
21:14:43 <gnut> is there good support for UNIX pipes?
21:14:56 <Saizan> (the "mappend" corresponding to "monads are monoids on a category of endofuctors" is join)
21:14:59 <koninkje> endo == back to self. So endomorphism is a->a for some a
21:15:16 <koninkje> endofunctor is C->C for some C, ets
21:15:18 <Saizan> dibblego: ?seen ?
21:15:21 <Gracenotes> ah, yeah, that's what Endo is. So it's an.. arrow, basically?
21:15:21 <koninkje> s/ets/etc/
21:15:39 <dibblego> @seen dibblego
21:15:40 <lambdabot> You are in #haskell-in-depth, #xmonad, #functionaljava, #haskell and #scala. I last heard you speak just now.
21:15:57 <roconnor> gnut: I think so
21:16:04 <roconnor> @hoogle POSIX
21:16:05 <lambdabot> module Data.Time.Clock.POSIX
21:16:05 <lambdabot> module System.FilePath.Posix
21:16:05 <lambdabot> package posix-realtime
21:16:08 <Saizan> ?hoogle pipe
21:16:09 <lambdabot> package Pipe
21:16:09 <lambdabot> package shell-pipe
21:16:11 <roconnor> :/
21:16:26 <Saizan> there's something about pipes under System.Posix
21:16:51 <Gracenotes> gnut: also... depends on what you mean. If you mean piping through Haskell programs, there is an 'interact' function that takes stdin input and returns a string to print out
21:17:02 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html#v%3AcreatePipe
21:17:19 <gnut> Gracenotes: yeah... that's what I meant.
21:17:29 <Gracenotes> @type interact
21:17:30 <lambdabot> (String -> String) -> IO ()
21:17:42 <gnut> I want haskell to start a program and intercept stdout of that program
21:17:52 <roconnor> main = intract pipe
21:17:59 <roconnor> pipe :: String -> String
21:18:04 <roconnor> pipe input = ...
21:18:44 <porges> would having a way to "lock" a class so no more instances outside of the module can be added fix some of the cases where UndecidableInstances are required?
21:19:25 <geezusfreeek> ah, Kleisli m a a is the monoid, i see
21:19:33 <porges> actually, thinking about it, it might be similar to class aliases
21:19:45 <porges> it *always* comes back to class aliases!
21:20:25 <Gracenotes> gnut: for example, a function that takes input and returns it to upper case would be main = interact (map toUpper)
21:20:37 <Gracenotes> assuming you import Data.Char
21:20:44 <pumpkin> > toUpper '1'
21:20:45 <Gracenotes> which does the to-upper-ing
21:20:46 <lambdabot>   '1'
21:21:03 <koninkje> porges: I think you'd have to add an additional theorem prover as well (e.g. to prove Ord a=>PartialOrd a does actually terminate given a closed Ord)
21:21:08 <Gracenotes> and then, echo 'yes no' | runhaskell upper.hs
21:21:16 <gnut> Gracenotes: ah... ok. yeah. I've used toUpper before.
21:21:20 <Gracenotes> and YES NO is printed to stdout
21:21:42 <Gracenotes> iirc you can also chmod +x Haskell programs and somehow execute them ./likethis
21:21:43 <porges> koninkje: okay
21:21:59 <gnut> or compile them :)
21:22:06 <Saizan> porges: closing a class can give a nicer semantic to OverlappingInstances
21:22:09 <Gracenotes> yeah :)
21:22:30 <gnut> so let's say I want to start "ls -l"
21:22:37 <gnut> hmmm
21:22:38 <gnut> ok
21:22:39 <gnut> I got it.
21:23:04 <Gracenotes> interact is rather crude, too... there are more fine-grained I/O functions, like getLine
21:23:13 <gnut> where is interact?
21:23:39 <Gracenotes> uh, Prelude, it seems. So you don't have to import it or anything.
21:24:10 <Gracenotes> so is getLine, etc. The file/directory handlers are in System.IO, though
21:24:15 <porges> it seems when you have a semi-complex hierarchy  you'll always run in into Undecidableinstances sooner or later.. it's strange, because in some ways it's a punishment for having a rich hierarchy. e.g (class (Foo a, Bar a) => Zap a && instance (Foo a, Bar a) => Zap a)
21:24:44 <Gracenotes> actually, excuse me, there seems to be more directory stuff in System.Directory
21:25:48 <gnut> hmm... cool
21:26:11 <gnut> Gracenotes: will interact block until the piped program completes?
21:26:26 <gnut> say I run "dbus-monitor" and pipe it into myhaskell.hs
21:26:44 <gnut> and dbus-monitor just spits stuff out to stdout as things happen
21:27:01 <gnut> will myhaskell wait until dbus-monitor exits before it spits anything out?
21:27:09 <Gracenotes> it blocks until some kind of EOF is reached, I think
21:27:09 <cjb> better to just listen on the bus with haskell-dbus directly
21:27:43 <gnut> hmm... dbus-monitor's output is the thing I'm trying to parse
21:27:47 <Gracenotes> oh this.. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/DBus
21:28:02 <gnut> and yes, I know I can use perl, but I hate perl :) and would much rather do it in haskell
21:28:16 <cjb> gnut: but why?  dbus-monitor's *input* is messages on the bus
21:28:24 <cjb> you might as well use the haskell dbus bindings
21:28:32 <cjb> and get that input directly
21:28:40 <gnut> didn't know about it until just now... reading...
21:28:41 <cjb> instead of in a convoluted fashion through shell scripts and parsing
21:28:52 <gnut> :)
21:29:29 <gnut> what? the homepage is forbidden!
21:29:42 <Gracenotes> but shell scripts and convoluted parsing is the Unix way! ;)
21:29:58 <cjb> Gracenotes: haha
21:30:00 <gnut> hehe... yeah
21:32:59 <gnut> Gracenotes: hey... thanks for this dbus tip... I guess I'll try this out.
21:33:13 <gnut> I'll save the pipe learning for another day then.
21:33:22 <Gracenotes> cjb suggested it :)
21:33:50 <Gracenotes> but pipes aren't that complicated. Again, the Unix way -- doing one thing and doing it well. Just read and output accordingly.
21:33:59 <Gracenotes> Of course, people can pipe together some interesting things :P
21:34:09 <gnut> cjb: ahh.. thanks :)
21:34:46 <cjb> gnut: welcome
21:35:09 <cjb> when someone's bothered to write a parser for a complicated format such that you can avoid doing so yourself, it's usually a good idea to use it :)
21:35:27 <gnut> don't reinvent the wheel
21:41:50 <hackage> Uploaded to hackage: multiplicity 0.1.0
21:43:52 <redditbot> Galois's Blog: Equivalence and Safety Checking in Cryptol
21:43:52 <redditbot> Notes on the LHC: Grin a little.
21:44:17 <Gracenotes> hm. When using a Writer to log a fibonacci calculator, is there some way to log the sum before the calculations?
21:45:02 <rwbarton> @users
21:45:03 <lambdabot> Maximum users seen in #haskell: 699, currently: 613 (87.7%), active: 17 (2.8%)
21:45:22 <Gracenotes> basically, something like this--
21:45:25 <Gracenotes> fibWithLog n = if (n <= 1) then do {tell "1"; return 1} else do {tell "("; f1 <- fibWithLog' (n-1); tell " + "; f2 <- fibWithLog' (n-2); tell $ " = " ++ show (f1 + f2) ++ ")"; return (f1 + f2)}
21:46:01 <Gracenotes> I don't think there's a way to tell the sum /before/ running the recursive calculations... right?
21:46:30 <Gracenotes> or by somehow making the recursive calculations not log, but still retrieve a result
21:46:41 <rwbarton> maybe using mdo...
21:46:56 <Gracenotes> well, log. But log after the sum.
21:47:16 <Gracenotes> hm... I'm not familiar with mdo. I've seen it, though :) What's it sugar for?
21:47:25 <Gracenotes> @unmdo mdo { return x }
21:47:25 <lambdabot>  Parse error at "x" (column 14)
21:47:27 <rwbarton> mfix
21:47:36 <Gracenotes> @undo mdo { return x }
21:47:37 <lambdabot>  Parse error at "x" (column 14)
21:47:47 <rwbarton> I don't think undo knows about it.
21:47:50 <idnar> @undo mdo { \x -> return x }
21:47:51 <lambdabot>  Parse error at "\x" (column 7)
21:48:10 <rwbarton> > let fibWithLog n = if (n <= 1) then do {tell "1"; return 1} else do {tell "("; f1 <- fibWithLog' (n-1); tell " + "; f2 <- fibWithLog' (n-2); tell $ " = " ++ show (f1 + f2) ++ ")"; return (f1 + f2)} in runWriter fibWithLog 5
21:48:11 <lambdabot>   Not in scope: `fibWithLog''Not in scope: `fibWithLog''
21:48:14 <gnut> hrm... haskell-dbus doesn't compile for me :(
21:48:22 <rwbarton> > let { fibWithLog n = if (n <= 1) then do {tell "1"; return 1} else do {tell "("; f1 <- fibWithLog' (n-1); tell " + "; f2 <- fibWithLog' (n-2); tell $ " = " ++ show (f1 + f2) ++ ")"; return (f1 + f2)} } in runWriter fibWithLog 5
21:48:24 <lambdabot>   Not in scope: `fibWithLog''Not in scope: `fibWithLog''
21:48:25 <NameAlreadyInUse> are there any purely functional, dynamically typed languages?
21:48:26 <Gracenotes> oh, sorry, forgot the prime on the declaration
21:48:36 <rwbarton> > let { fibWithLog' n = if (n <= 1) then do {tell "1"; return 1} else do {tell "("; f1 <- fibWithLog' (n-1); tell " + "; f2 <- fibWithLog' (n-2); tell $ " = " ++ show (f1 + f2) ++ ")"; return (f1 + f2)} } in runWriter fibWithLog' 5
21:48:37 <lambdabot>   Couldn't match expected type `Writer w a'
21:48:46 <rwbarton> > let { fibWithLog' n = if (n <= 1) then do {tell "1"; return 1} else do {tell "("; f1 <- fibWithLog' (n-1); tell " + "; f2 <- fibWithLog' (n-2); tell $ " = " ++ show (f1 + f2) ++ ")"; return (f1 + f2)} } in runWriter (fibWithLog' 5)
21:48:47 <lambdabot>   (8,"((((1 + 1 = 2) + 1 = 3) + (1 + 1 = 2) = 5) + ((1 + 1 = 2) + 1 = 3) = 8)")
21:48:56 <gnut> NameAlreadyInUse: what about erlang?
21:48:57 <rwbarton> you want 8 = (...)?
21:49:14 <gnut> wait... erlang is or isn't pure?
21:49:23 <Gracenotes> rwbarton: yeah. If it's possible.
21:49:37 <rwbarton> > let { fibWithLog' n = if (n <= 1) then do {tell "1"; return 1} else mdo {tell $ "(" ++ show (f1 + f2) ++ " = "; f1 <- fibWithLog' (n-1); tell " + "; f2 <- fibWithLog' (n-2); tell ")"; return (f1 + f2)} } in runWriter (fibWithLog' 5) -- let's see!
21:49:39 <lambdabot>   (8,"(8 = (5 = (3 = (2 = 1 + 1) + 1) + (2 = 1 + 1)) + (3 = (2 = 1 + 1) + 1))")
21:49:50 <pumpkin> is there a good way to show there's a bijection between two uncountably infinite sets?
21:49:54 <NameAlreadyInUse> gnut: i am not sure
21:49:54 <Gracenotes> ooh. interesting.
21:50:05 <rwbarton> That was... more successful than I expected. :)
21:50:12 <NameAlreadyInUse> gnut: but i was looking for something more along the lines of a purely functional lisp or something
21:50:15 <idnar> rwbarton: woot! :)
21:50:49 <rwbarton> Hooray for laziness
21:51:06 <rwbarton> @src mfix Writer
21:51:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:51:10 <Gracenotes> can you do it without mdo?
21:51:21 <Gracenotes> lemme see how successful
21:51:23 <Gracenotes> > let { fibWithLog' n = if (n <= 1) then do {tell "1"; return 1} else do {tell $ "(" ++ show (f1 + f2) ++ " = "; f1 <- fibWithLog' (n-1); tell " + "; f2 <- fibWithLog' (n-2); tell ")"; return (f1 + f2)} } in runWriter (fibWithLog' 5)
21:51:25 <lambdabot>   Not in scope: `f1'Not in scope: `f2'
21:51:26 <Saizan> you can use listen/censor
21:51:28 <Gracenotes> ah.
21:51:49 <Gracenotes> Saizan: yeah... I never really got a feel for those :)
21:51:54 <Saizan> but mdo is way more elegant..
21:52:41 <Gracenotes> although, what does mdo desugar to?
21:53:03 <Saizan> it uses mfix
21:53:06 <Saizan> ?type mfix
21:53:08 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
21:53:16 <Gracenotes> how does it use it? :)
21:53:25 <rwbarton> It builds a big tuple of all the bindings made in the do block
21:53:28 <rwbarton> *mdo
21:53:41 <Gracenotes> ah. so it's very lazy.
21:53:55 <Gracenotes> you don't need mfix for that, though?
21:54:33 <rwbarton> something like: fmap fst $ mfix (\(_, (f1, f2)) -> do { tell ...; f1' <- ...; tell ...; f2' <- ...; tell ...; return (f1' + f2', (f1', f2')) }
21:54:40 <rwbarton> where the ... refer to f1 and f2
21:55:18 <Gracenotes> @src mfix
21:55:19 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:55:31 <Gracenotes> @src MonadFix
21:55:32 <lambdabot> class (Monad m) => MonadFix m where
21:55:32 <lambdabot>     mfix :: (a -> m a) -> m a
22:10:44 <enoksrd> @tell pumpkin maybe Scroder-Bernstein will help? http://en.wikipedia.org/wiki/Cantor%E2%80%93Bernstein%E2%80%93Schroeder_theorem
22:10:45 <lambdabot> Consider it noted.
22:15:40 <porges> hehe
22:16:34 <porges> if you try to generalize everything to operating in Category then each typeclass ends up having an additional context (Category x) so that you'll end up with a ridiculous amount :P
22:16:47 <juhp> https://admin.fedoraproject.org/updates/ghc-6.10.1-7.fc10,ghc-paths-0.1.0.5-2.fc10,haddock-2.4.1-2.fc10,ghc-gtk2hs-0.9.13-8.20081108.fc10
22:20:35 <porges> actually I might be wrong
22:20:38 <porges> :D
22:23:14 <porges> although liftA2 ∷ (Apply f (↱) (↳) (⤳), Functor f (⇉) (⤳) (→)) ⇒ (a ⇉ (b ↱ c)) → ((f a) ⤳ (f b ↳ f c))
22:23:26 <Gracenotes> eek, unicode
22:23:51 <porges> Gracenotes: not showing up?
22:24:15 <dolio> A couple aren't.
22:24:17 <Gracenotes> well, my IRC client is parsing it just fine
22:24:19 <dolio> Here, at least.
22:24:23 <Gracenotes> my mind, on the other hand...
22:24:44 <dolio> Third thing in parens in Apply, and second in Functor.
22:25:17 <Saizan> yeah, same here
22:25:24 <porges> although liftA2 ∷ (Apply f g h i, Functor f j i (->)) => (j a (g b c)) -> (i (f a) (h (f b)  (f c)))
22:25:39 <porges> it's the same symbol
22:25:49 <dolio> They just look like spaces here. not even the no character box.
22:26:09 <porges> U+2933 WAVE ARROW POINTING DIRECTLY RIGHT
22:26:53 * cjb http://www.inference.phy.cam.ac.uk/cjb/codepoints.html
22:27:17 * ski_ calls the /me police
22:27:30 * Gracenotes Someone called us?
22:27:39 * Gracenotes What's the problem, sir?
22:28:01 * cjb well it's my leg you see it's fallen off
22:28:12 <porges> must have been a tiger
22:28:16 <ski_> i want you to arrest sirs Gracenotes and cjb for abusing emote actions, sir
22:28:56 <porges> it seems that GHCi doesn't realize some codepoints are symbols and I start getting things like Functor → →2 →3
22:29:01 * Gracenotes I shall put cjb in an ocean and call him "Bob"
22:30:20 <Gracenotes> ski_: actually, the original CTCP containing the ACTION (/me) CTCP command said "This is used by losers on IRC to simulate "role playing" games."
22:30:26 <Gracenotes> *specification
22:30:53 <Gracenotes> http://www.irchelp.org/irchelp/rfc/ctcpspec.html
22:31:20 * Saizan casts silence
22:31:45 * ski_ invokes MON FUL IR
22:33:10 <ski_> .. i never understood why various filled unicode points were called "black .."
22:33:42 <ski_> (and hollow corresponding ones "white ..")
22:33:56 <koala_man> how can I model absolute and relative positions (let's say int), and be able to have rel+rel=rel, abs+rel=abs, but have abs+abs rejected at compile time?
22:34:11 <porges> ski_: jargon, just like a bold font is "heavier"
22:35:00 <arw> koala_man: create types abs and rel and define operators for rel + rel and abs + rel, but not for abs + abs.
22:35:09 <ski_> well, as a dark-background, bright-foreground fundamentalist, i feel discriminated !
22:35:25 <Heffalump> if you want to actually use (+) you'll need to hide Num, which is a bit fiddly
22:35:52 <Saizan> and if you want to use the same function for both "operations" you need typeclasses
22:36:03 <koala_man> arw: can I use the same operator for all of them?
22:36:23 <arw> with typeclasses yes.
22:36:42 <Saizan> i'd probably use data Pos type = Pos Int; data Rel; data Abs; and have Pos Abs and Pos Rel
22:37:25 <ski_> maybe index the same type with `Abs' and `Rel' indices
22:37:37 <Saizan> class Add t t1 t2 | t t1 -> t2 where add :: Pos t -> Pos t1 -> Pos t2
22:37:56 <ski_> (oh, that's what you said .. misread)
22:38:05 <Saizan> instance Add Rel Rel Rel where ..; instance Add Abs Rel Abs where ..;
22:38:15 <porges> f <$> a <*> b = (f <$> a) <*> b, right?
22:38:24 <ski_> maybe this would a a fine job for type families ?
22:38:26 <Saizan> yes
22:38:41 <ski_> s/a a/be a/
22:38:49 <porges> lambdabot doesn't think so :/
22:38:54 <koala_man> ooh, thanks, I'll give it a try
22:39:13 <Saizan> yeah, with class Add a b where type Result a b :: *; add :: Pos a -> Pos b -> Pos (Result a b)
22:39:55 <Saizan> koala_man: you need MultiParamTypeClasses and FunctionalDependencies for my first stub
22:40:30 <koala_man> pardon my noobness, but.. what?
22:40:52 <Saizan> koala_man: they are two extensions provided by GHC
22:40:57 <koala_man> ah
22:41:17 <Saizan> koala_man: enabled with {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies #-} at the top of your file
22:43:53 <redditbot> Galois' Blog : Equivalence and Safety Checking in Cryptol
22:46:06 <mib_sq1v77> {-# LANGUAGE MultiParamTypeClasses, FlexibleContexts, TypeFamilies #-} is at the top of Data.AffineSpace which seems what you want
23:12:52 <joga> is there some haskell library for parsing an mbox file?
23:15:47 <raji> if i'm given a set of digits , how can i use them to create smallest multiple of a N. example {6,3} 36 =>36, {1,2} 13=>221, i use a queue for BFS but it either takes memory or it is slow
23:17:34 <bd_> raji: try first generating a list of all numbers that can be built out of those digits.
23:17:53 <bd_> since it sounds like homework, I'll stop here to let you think about what happens from there :)
23:18:13 <raji> bd_, that is slow, example 3 99991
23:18:20 <raji> no it ain't homework
23:18:30 <scook0> why not generate a list of multiples, and search for the first one that contains only digits in your set?
23:18:52 <bd_> raji: 99991 isn't a digit
23:18:59 <raji> scook0, that is slow
23:19:05 <scook0> ah, ok
23:19:07 <raji> raji, first one is digit and second is N
23:19:12 <bd_> ah
23:19:30 <raji> scook0, 3 99991 contains around 40000+ digits
23:19:53 <scook0> I see, sounds like a thorny problem then
23:19:55 <silentOpen> raji, what is N?
23:20:00 <bd_> well one thing to consider is how the formula you get with (a + b*10 + c * 10^3 + ...) mod N behaves
23:20:03 <raji> N is the multiple to be made
23:20:13 <raji> bd_, yes thats what i do
23:20:26 <raji> a*10 + digit or digit*10^len + a
23:21:52 * bd_ tries some things 
23:22:39 <dons> ?users
23:22:40 <lambdabot> Maximum users seen in #haskell: 699, currently: 609 (87.1%), active: 10 (1.6%)
23:22:43 <dons> .... doh!
23:23:15 <dons> this really feels  like a RWH-related boom time.
23:23:21 <bd_> raji: here's an untested approach
23:23:26 <idnar> heh
23:23:38 <silentOpen> raji, why don't you factor N?
23:23:44 <bd_> raji: you're essentially trying to solve a, b, ... in (a + b*10^1 + c * 10^2 + ...) mod N
23:23:48 <raji> silentOpen, you are joking
23:23:56 <raji> bd_, yes
23:24:02 <silentOpen> raji... no?
23:24:08 <bd_> normalize constant multipliers and sort them, first
23:24:12 <bd_> so eg if we're looking at mod 7
23:24:36 <bd_> we'll have (a + b*3 + c*2 + d*6 + ...)
23:24:52 <bd_> ... wait, nevermind, I forgot where I was going after that >_>;;
23:25:10 <bd_> let me think about this some more :P
23:25:35 <raji> bd_, i could work this out until i get ties, then it becomes damn slow or out of space
23:26:09 <bd_> ties?
23:26:10 <raji> example 36 , 31 gives 36363 and 33666 ,
23:26:18 <raji> we have to choose 33666
23:26:30 <raji> ties of same length
23:26:41 <bd_> you mean 36363?
23:26:54 <raji> using digits 3 and 6 , smallest multiple of 31
23:26:59 <raji> is of length 5
23:27:16 <bd_> wait read it wrong
23:27:19 <bd_> okay
23:27:46 <mkbunday> I'm going throw out the idea that you should always be able to find a number with less digits than the order of 10 mod N, or else you can't find one at all. Now, I'm not sure how that helps yet. :P
23:28:47 <bd_> 10 digits is a reasonable space to brute force, if you limit the number of digits you're using, but is that really the case?
23:28:50 <raji> sometimes it is not possible example 2
23:28:52 <mkbunday> Oh, no, what I said isn't true, but it suggests a way to solve it.
23:29:25 <raji> example using 3's to get a multiple of 2
23:29:31 <mkbunday> Yup.
23:29:53 <scook0> or trying to get a multiple of 5 without 5 or 0
23:29:55 <raji> bd_, N would be less < 10^5
23:30:46 <bd_> obviously if you have 0 the solution is trivial :)
23:33:00 <mkbunday> Is the set of digits always size two?
23:39:38 <raji> mkbunday, no it can be all 10 digits
23:39:39 <raji> base 10
23:39:43 <raji> atmost
23:42:27 <cizra> Hi. I've got readline installed (cabal list readline says so), however, when I run "runhaskell Setup.hs configure", it says readline -any can't be found. Do I perhaps need to give it a path or something?
23:43:18 <raji> i'll figure out something bye
23:43:53 <redditbot> Hieroglyph HOWTO Part 1: Functional 2D drawing using Cairo.
23:52:16 <mib_sq1v77> cizra:  is it the haskell package readline that's missing or the GNU readline program?
23:52:55 <cizra> mib_sq1v77: I don't know. Here, lemme paste you what Setup.hs says:
23:53:06 <cizra> Setup.hs: At least the following dependencies are missing:
23:53:06 <cizra> readline -any
23:54:31 <mib_sq1v77> that must be the haskell I guess, so it's probably about paths....   is your .cabal folder in the path?
23:55:28 <Workybob_> oh lame
23:55:42 <Workybob_> read what redditbot just said and got excited
23:55:47 <Workybob_> turns out it's not functional at all :(
23:55:53 <cizra> mib_sq1v77: Prolly not. Do you mean $PATH?
23:57:25 <mib_sq1v77> yeah
23:58:00 <mib_sq1v77> what operating system are you using
23:58:41 <cizra> mib_sq1v77: Linux, Debian. And no, PATH=/home/`whoami`/.cabal:$PATH runhaskell Setup.hs configure didn't work either.
