00:43:45 <tonyIII> how to limit amount of memory ghci can use?
00:45:20 <beelsebob> ask in your OS's channel
00:46:11 <ddvlad> @src sequence
00:46:12 <lambdabot> sequence []     = return []
00:46:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:46:12 <lambdabot> --OR
00:46:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
00:46:32 <beelsebob> foldr (liftA2 (:)) (pure []) damn it!
00:46:55 <Peaker> @src sequenceA
00:46:56 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:47:12 <Peaker> beelsebob: someone said that Haskell used to have Monad as a subclass of Applicative?
00:47:13 <beelsebob> yeh, I know, then you even get traversable not list
00:47:20 <beelsebob> I don't think so
00:47:25 <Peaker> back in the 1.4 days?
00:47:26 <beelsebob> Applicative is a relatively recent thing
00:47:36 <beelsebob> I think it didn't even exist in 1.4 days
00:47:42 <beelsebob> it *should* be a subclass of Applicative
00:48:11 <tonyIII> @src pure
00:48:12 <lambdabot> Source not found. Where did you learn to type?
00:48:19 <beelsebob> @src Applicative
00:48:20 <lambdabot> class Functor f => Applicative f where
00:48:20 <lambdabot>     pure  :: a -> f a
00:48:20 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
01:08:03 <tonyIII> Can Haskell give type to self_app f = f f ? self_app (f::forall a.a->a) = f f doesn't work.
01:08:29 <wli> id id
01:08:43 <yitz> @type \f -> f f
01:08:44 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
01:08:44 <lambdabot>     Probable cause: `f' is applied to too many arguments
01:08:44 <lambdabot>     In the expression: f f
01:09:17 <tonyIII> @type \(f::forall a.a->a) = f f
01:09:19 <lambdabot> parse error on input `='
01:09:53 <wli> lambdabot can't parse it
01:09:57 <Ralith> tonyIII: is self_app f = f . f not what you want?
01:10:04 <tonyIII> -XRankNTypes -XScopedTypeVariables are handle it
01:11:29 <tonyIII> Ralith: "self_app f = f . f" doesn't pass the type check. self_app (f::forall a.a->a) = f f can but fails on "self_app double" with "double f =f.f"
01:11:47 <Ralith> tonyIII: what's the type check?
01:11:48 <yitz> tonyIII: but you want the type variable a to be a fixed point of the type expression itself. that is what ghc calls an "infinite type", and it has told you that it cannot construct it.
01:11:56 <Ralith> tonyIII: works fine in ghci.
01:12:22 <yitz> @type \f -> f . f
01:12:23 <lambdabot> forall c. (c -> c) -> c -> c
01:12:55 <yitz> but that's not "selfApp", that's "applyTwice"
01:13:26 <Ralith> well, what would self_app do differently?
01:13:41 <yitz> Ralith: think lambda calculus
01:13:59 <yitz> untyped, that is
01:14:03 <Ralith> I don't know lambda calculus
01:14:04 <wli> occurs check
01:14:07 <Ralith> so that doesn't do much good
01:14:17 <yitz> haskell lives in the typed lambda calculus, not the untyped lambda calculus
01:14:57 <yitz> Ralith: look it up, it's fun, and fundamental
01:15:33 <Ralith> yitz: free time's fun too :D
01:15:44 <yitz> Ralith: time is money
01:16:18 <Ralith> free money is also fun.
01:17:01 <yitz> Ralith: anyway, us nerds enjoy our free time with things like lambda calculus. that's why normal people look at us with that funny look
01:19:33 <Ralith> and yet my question lies unanswered
01:20:03 * yitz scrolls back, looking for a question asked by Ralith
01:20:30 <tonyIII> Rephrase my question: can self_application, which can map id to (id id), and (\f -> f.f) to (\f -> f.f.f.f), be defined in Haskell?
01:20:32 <yitz> oh - you mean Ralith: well, what would self_app do differently?
01:20:57 <Ralith> yes
01:21:36 <yitz> tonyIII: no, because there is no type in Haskell for which those are valid expressions
01:21:37 <beelsebob> tonyIII: id -> id id and f -> f . f are conflicting
01:21:43 <beelsebob> if f -> f . f, then id -> id . id
01:22:03 <idnar> beelsebob: that's not what he said :P
01:22:14 <Ralith> idnar: exactly
01:22:17 <idnar> oh, wait, it sorta is
01:22:26 <ddarius> :t let f :: (forall a. a -> a) -> a -> a; f g = g . g in f id
01:22:28 <lambdabot> forall a. a -> a
01:22:41 <tonyIII> sorry, map id to (id.id), map (\f -> f.f) to (\f -> f.f.f.f)
01:23:20 <yitz> ddarius: ok, your right. it makes sense for the type containing only bottom
01:23:35 <ddarius> yitz: Where is bottom in what I posted?
01:23:36 <beelsebob> tonyIII: oh, so join (.) then?
01:23:42 <tonyIII> :t let f :: (forall a. a -> a) -> a -> a; f g = g . g in f (\f -> f.f)
01:23:44 <lambdabot>     Couldn't match expected type `c -> c' against inferred type `a'
01:23:44 <lambdabot>       `a' is a rigid type variable bound by
01:23:44 <lambdabot>           the polymorphic type `forall a. a -> a' at <interactive>:1:54
01:24:36 <ddarius> The only function f can be applied to (modulo technicalities) is id.
01:24:53 <ddarius> That's not actually necessary for this case.
01:24:56 <ddarius> :t join (.)
01:24:58 <lambdabot> forall b. (b -> b) -> b -> b
01:25:24 <ddarius> :t join (.) (\f -> f . f)
01:25:28 <lambdabot> forall c. (c -> c) -> c -> c
01:25:43 <ddarius> But for the self application case, it's more necessary.
01:25:48 <tonyIII> :t join (.) (\f -> f.f)
01:25:49 <lambdabot> forall c. (c -> c) -> c -> c
01:26:36 <tonyIII> :t join (.) (join (.))
01:26:37 <lambdabot> forall b. (b -> b) -> b -> b
01:27:08 <yitz> @type let f :: (forall a . a -> a) -> (forall a . a -> a); f g = g g in f
01:27:10 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
01:27:26 <yitz> ddarius: I thought that is what you meant
01:28:09 <yitz> @type let f :: (forall a . a -> a) -> b -> b;  f g = g g in f
01:28:10 <ddarius> yitz: And that works on id.  No bottoms involved.
01:28:10 <lambdabot> forall b. (forall a. a -> a) -> b -> b
01:28:15 <tonyIII> @src join
01:28:16 <lambdabot> join x =  x >>= id
01:28:29 <yitz> ddarius: yours does.  does mine?
01:28:45 <yitz> @type let f :: (forall a . a -> a) -> b -> b;  f g = g g in f id
01:28:47 <lambdabot> forall b. b -> b
01:29:03 <yitz> > let f :: (forall a . a -> a) -> b -> b;  f g = g g in f id 3
01:29:05 <lambdabot>   3
01:29:09 <yitz> hmm
01:30:32 <yitz> @type let f :: (forall a . a -> a) -> b -> b;  f g = g g in f (const id)
01:30:33 <lambdabot>     Couldn't match expected type `a1' against inferred type `a -> a'
01:30:33 <lambdabot>       `a1' is a rigid type variable bound by
01:30:33 <lambdabot>            the polymorphic type `forall a1. a1 -> a1' at <interactive>:1:54
01:31:16 <yitz> @type let f :: (forall a . a -> a) -> b -> b;  f g = g g in f (flip const id)
01:31:18 <lambdabot> forall b. b -> b
01:31:36 <yitz> @type let f :: (forall a . a -> a) -> b -> b;  f g = g g in f (flip const 42)
01:31:38 <lambdabot> forall b. b -> b
01:32:10 <yitz> so rank n types allow you to embed the untyped lambda calculus in haskell's type system, does it?
01:32:17 <ddarius> No.
01:32:24 <yitz> what's missing?
01:33:20 <tonyIII> @type (join (.) (\f -> f.f)) (+1) 1
01:33:22 <lambdabot> forall c. (Num c) => c
01:33:36 <ddarius> The only function you can apply to f in that case is id which is certainly not enough for general recursion.  As for doing anything particular at the type level, it doesn't really add much computationally.
01:34:55 <yitz> all the lambda calculus has is id, const, and self-application. so what we're missing here is const?
01:35:16 <yitz> *application, including self-application
01:35:46 <Heffalump> yitz: the S combinator isn't just "application"
01:36:14 <ddarius> yitz: Where does id and const come in?  The untyped lambda calculus has lambda abstraction, variables, and application.  Also, you only have self-application for a single function, id and that produces id.  It's not interesting.
01:36:46 <Heffalump> also, the Haskell type system is effectively simply-typed (by the kind system), which rules out the Y combinator
01:36:58 <tonyIII> Is this join from Monad?
01:37:06 <yitz> tonyIII: yes
01:37:26 <ddarius> It's defined in terms of methods in the Monad class as you saw above.
01:38:03 <tonyIII> Why it says "No instance for (Monad ((->) ((a -> a) -> a -> a)))" in ghci for (join (.) id) (+1) 1
01:38:17 <dmwit_> import Control.Monad.Instances
01:38:38 <ddarius> The rank-n polymorphic lambda calculus (lacking fix) can interpret/embed a rank-(n-1) polymorphic lambda calculus.  None can interpret the untyped lambda calculus.
01:39:07 <tonyIII> It works. Thanks all.
01:48:48 <yitz> what's with dmwit?
01:49:14 <yitz> oh, you spoke. dmwit?
01:49:58 <yitz> ping dmwit
01:50:42 <yitz> ping dmwit
01:52:07 <m0nkfish> hi, i'm trying to learn haskell and i'm getting an 'invalid type signature' error
01:52:26 <m0nkfish> my type signature is this:
01:52:27 <m0nkfish> getlist n :: Integer -> [Integer]
01:52:41 <m0nkfish> does that look wrong?
01:55:53 <doserj> m0nkfish: yes. try to give a type-signature for getlist, not for getlist n
01:57:54 <Gracenotes> fractran >> fail "head explodes"
01:58:28 <Gracenotes> though, it would be straightforward to implement in Haskell
01:58:32 <pk_> hi
01:58:44 <Gracenotes> hello, pk_
02:02:26 <m0nkfish> thank you doserj that was the problem :)
02:05:23 <Gracenotes> @src Fractional
02:05:23 <lambdabot> class  (Num a) => Fractional a  where
02:05:23 <lambdabot>     (/)             :: a -> a -> a
02:05:23 <lambdabot>     recip           :: a -> a
02:05:23 <lambdabot>     fromRational    :: Rational -> a
02:06:38 <pk_> suppose I have an action valued behavior (in reactive) composed of 2 or more actions
02:09:37 <Axman6> @sr
02:09:38 <lambdabot> src <id>. Display the implementation of a standard function
02:09:41 <Axman6> hmm
02:09:43 <Axman6> @s
02:09:44 <lambdabot> Maybe you meant: seen shootout show slap smack source spell spell-all src . ? @ v
02:11:21 <pk_> forget about that
02:17:55 <Peaker> is there a real-forkIO for real threadS?
02:18:17 <Peaker> (for various blocking syscalls that aren't already nicely wrapped to use select/etc)
02:18:50 <idnar> forkOS?
02:21:26 <Peaker> @hoogle forkOS
02:21:27 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
02:21:31 <Peaker> idnar: ah, thanks
02:22:07 <Peaker> weird naming scheme...
02:22:17 <idnar> it gives youn an OS thread, instead of a GHC thread
02:22:24 <idnar> I assume that's the idea behind the name, anyhow
02:22:26 <Peaker> yeah, "forkOS" is a bit misleading though
02:22:42 <pk_> @src sequence
02:22:43 <lambdabot> sequence []     = return []
02:22:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:22:43 <lambdabot> --OR
02:22:43 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:22:47 <idnar> I think you still need to tell the RTS to use threads, though
02:26:21 <niff> is partial applicationt he same as currying?
02:26:59 <dcoutts> @seen mightybyte
02:27:00 <lambdabot> mightybyte is in #haskell and #haskell-in-depth. I last heard mightybyte speak 3h 36s ago.
02:27:30 <niff> which channelf or dicussing CS-theory, complexity, computability etc?
02:29:45 <Gracenotes> niff: well, there's #math for math-related stuff
02:30:46 <Gracenotes> as far as I know there aren't any real theory channels on freenode
02:31:18 <pk_> why isn't there a sequence like function for reactive's events ?
02:31:40 <pk_> something to turn an Event (IO a) to IO (Event a)
02:34:57 <pk_> what if I do it myself ? something like sequenceE = return . fmap (unsafePerformIO)
02:35:18 <senex1> Hi there
02:36:27 <jpcooper> @pl (listenOn . PortNumber . read . head $ args) >>= communicationGetter chan nodes
02:36:28 <lambdabot> communicationGetter chan nodes =<< listenOn (PortNumber (read (head args)))
02:37:23 <senex1> Iâ€™ve got a small question â€¦
02:37:49 <senex1> I want to replace an item of a list with another item â€¦
02:37:52 <senex1> so i wrote:
02:38:05 <senex1> replace :: (Eq a) => a -> a -> [a] -> [a]
02:38:42 <senex1> replace item item' list = if item `elem` list then delete item list ++ item' else list
02:39:06 <senex1> but I get an error:  Occurs check: cannot construct the infinite type: a = [a]
02:39:07 <senex1>     When generalising the type(s) for `replace'
02:39:25 <doserj> ++ [item']
02:39:45 <Gracenotes> senex1: or, if you want to do it more efficiently, try a recursive definition
02:39:51 <senex1> thanks!
02:39:55 <senex1> how?
02:40:06 <doserj> or why not "item' : delete item list"?
02:40:16 <BONUS> well recurse and check if it's the element
02:40:18 <Gracenotes> you'd have two cases. One in which the list is empty, and one in which the list has elements
02:40:20 <BONUS> if it is, replace it
02:40:24 <BONUS> if it isn't just keep it
02:40:28 <senex1> yes, this would be possible, the order of the items doesnt matter
02:40:47 <BONUS> if the order doesn't matter why not use a Data.Set?
02:41:14 <Gracenotes> not to mention: item `elem` list possibly goes through the whole list, This may be in efficient.. it's possible to do a replace in an infinite list if you define it recursively :)
02:41:37 <senex1> moment, I will try the recursive solution â€¦
02:41:45 <BONUS> also you can do it with a fold
02:42:05 <doserj> or a map
02:42:15 <Gracenotes> fold doesn't strike me as terribly efficient if the list is huge...
02:42:41 <BONUS> i think a foldr would be just as efficient as a recursive definition
02:42:47 <BONUS> i mean it's just recursion under the hood
02:43:18 <Gracenotes> yeah, but possibly more recursion and used stack space than you need :) it also doesn't fare well with infinite lists
02:44:00 <senex1> now i have:
02:44:11 <senex1> replace item item' [] = []
02:44:35 <Gracenotes> that case is correct :)
02:44:35 <BONUS> Gracenotes: i dont know, foldr works nicely on infinite lists and i have a feeling a foldr and a recursive definition would get compiled down to the same thing anyway
02:44:43 <senex1> replace item item' (x:xs) = (if item == x then item' else x) : replace item item' xs
02:44:54 <senex1> looks nice
02:45:05 <senex1> and compiles
02:45:14 <senex1> and should work :)
02:45:29 <BONUS> yes :)
02:45:35 <doserj> senex1: have you considered what should happen if item appears more than once in the list?
02:45:36 <Gracenotes> senex1: one thing to note, though -- it replaces all elements in a list, not just the first one. If that is your intention.
02:45:44 <BONUS> you could use guards
02:46:11 <BONUS> replace item item' (x:xs) | item == x = item':xs | otherwise = x:xs
02:46:14 <BONUS> also with a foldr
02:46:37 <Gracenotes> otherwise = x:replace item item' xs ?
02:46:47 <BONUS> yeah
02:46:52 <BONUS> i forgot to recurse, though
02:46:55 <senex1> hmm â€¦ the list will only contain one occurence of item, I think â€¦ when I take this for granted, I can optimize it a bit, I think â€¦
02:46:58 <Gracenotes> and possibly in the other case, depending
02:47:05 <BONUS> also
02:47:36 <Gracenotes> senex1: yep. You'll either want to return the new element with the unmodified list, OR the old element with the recursively replaced rest-of-list
02:47:40 <BONUS> replace item item' = foldr (\x z -> if x == item then item':z else x:z) []
02:48:03 <jpcooper> I'm trying to use break in GHC to debug a loaded module in GHCi, but it's saying that it isn't interpreted. What should I do?
02:48:21 <BONUS> but anyway, if order doesn't matter and you expect there only to be one element in the list, i'd use a set from Data.Set
02:48:27 <Gracenotes> > let replace item item' = foldr (\x z -> if x == item then item':z else x:z) [] in replace 10 20 [1..]
02:48:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,20,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:49:01 <Gracenotes> oh, indeed it does work. :)
02:49:02 <doserj> > let replace item  item' = map (\x -> if item == x then item' else x) in replace 10 20 [1..]
02:49:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,20,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:49:54 <senex1> thanks for the help so far â€¦ nice channel :)
02:50:05 <doserj> the recursive version has the advantage that you can stop comparing after you have found the item, though.
02:50:11 <Gracenotes> no problem :)
02:50:31 <trofi> > length [(.)]
02:50:33 <lambdabot>   1
02:50:38 <Gracenotes> oh, I multiplied 5 and 7 in Haskell recently... truly a great accomplishment.
02:50:43 <Gracenotes> > let eval list num = either (eval list) id (check' list num); check' [] n = Right n; check' (x:xs) n = let n' = n*x in if denominator n'==1 then Left n' else check' xs n; multiply a b = floor . logBase 5 . fromRational . eval [385%13,13%21,1%7,3%11,7%2,1%3] $ 2^a*3^b in multiply 5 7
02:50:45 <lambdabot>   35
02:50:50 <Gracenotes> ;)
02:50:51 <BONUS> hah
02:51:07 <Gracenotes> unfortunately it fails for larger numbers due to overflow
02:51:08 <flup> one thing I dont understand is, all computational models can simulate each other. but can it be proven that there is no more powerful model?
02:51:13 <Gracenotes> > let eval list num = either (eval list) id (check' list num); check' [] n = Right n; check' (x:xs) n = let n' = n*x in if denominator n'==1 then Left n' else check' xs n; multiply a b = floor . logBase 5 . fromRational . eval [385%13,13%21,1%7,3%11,7%2,1%3] $ 2^a*3^b in multiply 25 25
02:51:14 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
02:51:40 <trofi> :]
02:51:42 <doserj> flup: there are more powerful models.
02:53:09 <augustss> Gracenotes: what is it that overflows?  the Double?
02:53:57 <Gracenotes> I'm not sure. It looks like an Int overflow to me, though.
02:54:11 <Gracenotes> Double overflow just turns up as Infinity
02:54:19 <Gracenotes> > let eval list num = either (eval list) id (check' list num); check' [] n = Right n; check' (x:xs) n = let n' = n*x in if denominator n'==1 then Left n' else check' xs n; multiply a b = eval [385%13,13%21,1%7,3%11,7%2,1%3] $ 2^a*3^b in multiply 25 25
02:54:21 <lambdabot>   718212087483073508066162477348002474436463402065604320713967078077436641711...
02:54:43 <augustss> Gracenotes: yeah, since the result is the log of something.  Perhaps you should use some different numbers
02:54:50 <Gracenotes> > let eval list num = either (eval list) id (check' list num); check' [] n = Right n; check' (x:xs) n = let n' = n*x in if denominator n'==1 then Left n' else check' xs n; multiply a b = eval [385%13,13%21,1%7,3%11,7%2,1%3] $ 2^a*3^b in multiply 25 25::Ratio Integer
02:54:52 <lambdabot>   718212087483073508066162477348002474436463402065604320713967078077436641711...
02:55:31 <augustss> Gracenotes: there are various packages which compute, e.g., log for Rational
02:56:14 <Gracenotes> oh, neat. I know in this case that the log will always be an integer, so maybe some repeated division might work
02:56:31 <augustss> > let eval list num = either (eval list) id (check' list num); check' [] n = Right n; check' (x:xs) n = let n' = n*x in if denominator n'==1 then Left n' else check' xs n; multiply a b = floor . logBase (5::CReal) . fromRational . eval [385%13,13%21,1%7,3%11,7%2,1%3] $ 2^a*3^b in multiply 25 25
02:56:33 <lambdabot>   625
02:56:47 <Gracenotes> ah, CReal, is there nothing you can't do? :)
02:57:09 <qebab> can it ride a bike?
02:57:18 <augustss> yes, relieable comparison :)
02:57:26 <Gracenotes> @faq Can Haskell's CReal ride a bike?
02:57:26 <lambdabot> The answer is: Yes! Haskell can do that.
02:57:42 <flup> doserj: like what?
02:58:08 <augustss> Gracenotes: btw, I have no idea how that multiplication works :)
02:58:38 <augustss> it's rather amazing
02:59:11 <chrisdone> "invisible bike"
02:59:17 <doserj> flup: for example, a turing machine that has access to a halting problem oracle. Or a turing machine that is allowed an infinite number of steps  before "converging" to an answer.
02:59:31 <Gracenotes> augustss: eval is named "eval" because it's an evaluator for Fractran, an esoteric language John Conway invented. http://scienceblogs.com/goodmath/2006/10/prime_number_pathology_fractra.php
02:59:58 <Gracenotes> the basis of its computation is prime numbers
03:00:07 <Gracenotes> it's really quite mind boggling >_>
03:04:34 <hcube> hi!
03:04:56 <Gracenotes> greetings, hcube!
03:06:08 <hcube> i'm working with uulib parser. I'd like to ask somebody who has experiences with it about a problem.
03:06:26 <jpcooper> would I be right in surmising that getChanContents only returns the current contents and will not be added to as things are added to it?
03:07:06 <hcube> did you guys use uulib parser combinator lib?
03:10:15 <flup> doserj: and those are not used because?
03:10:33 <flup> nondeterministic?
03:10:46 <doserj> flup: because turing machines are closer to what we intuitively understand as computable.
03:10:50 <mstr> is this correct? http://pastebin.com/m3b79d572
03:12:42 <doserj> flup: we can build a turing machines in reality (well, with a finite tape, but for computations that don't need more, this is ok)
03:13:22 <doserj> flup: but we do not know how to build a halting problem oracle, or how to make a machine an infinite number of steps in finite time.
03:13:46 <flup> so then there arent more powerful ones in reality?
03:14:04 <doserj> flup: that is the church-turing thesis, yes.
03:14:11 <jpcooper> anyone?
03:14:43 <doserj> flup: which cannot be proved, of course (it could only be disproved, but not many people believe so)
03:15:09 <mstr> or, an exact guide to do-notation could help too
03:16:21 <ziman> can we build stronger machines than TM?
03:16:38 <Axman6> ?users
03:16:39 <lambdabot> Maximum users seen in #haskell: 699, currently: 638 (91.3%), active: 17 (2.7%)
03:16:56 <doserj> mstr: the exact translation rules from do-notation to (>>=) are in the haskell report.
03:17:00 <Dirk99> I'm trying to use Network.HTTP to GET a webpage with user/password authorization. That doesn't work, snooping shows that the authorization is not transmitted. Now I'm puzzling over the source code of simpleHTTP, and it looks like it doesn't do authorization at all.
03:17:09 <Dirk99> Is that correct, or I am missing something obvious?
03:18:39 <augustss> Gracenotes: You should put Language.Fractran on hackage
03:18:58 <mstr> doserj: the haskell report?
03:20:03 <Gracenotes> augustss: hm... sounds like a silly good idea :)
03:20:27 <Gracenotes> but I guess that's one esoteric language down. Next: befunge! :P
03:21:29 <doserj> @where report
03:21:29 <lambdabot> http://www.haskell.org/onlinereport/
03:22:49 <doserj> http://www.haskell.org/onlinereport/exps.html#sect3.14
03:37:08 <jpcooper> @hoogle sleep
03:37:09 <lambdabot> No results found
03:37:12 <jpcooper> @hoogle delay
03:37:13 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
03:39:48 <Gracenotes> @type ***
03:39:50 <lambdabot> parse error on input `***'
03:39:53 <Gracenotes> @type (***)
03:39:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:39:59 <Gracenotes> @type (&&&)
03:40:01 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:41:59 <hackage> Uploaded to hackage: djinn 2009.2.8
03:42:28 <pejo> augustss, what's new in djinn 2009? :-)
03:42:45 <Botje> sugar lambdas!
03:43:37 <Gracenotes> > approxRational pi 0.0000000001
03:43:39 <lambdabot>   312689%99532
03:44:01 <Gracenotes> > approxRational (pi::CReal) 0.000000000000000001
03:44:03 <lambdabot>   * Exception: CReal.toRational
03:46:27 <dcoutts> pejo: nothing, in that release, just a dep fix
03:47:30 <Gracenotes> now, if only there were a Fractan addition algorithm, I could make a Num wrapper...
03:53:32 <u5h> hello haskellers
03:53:36 <u5h> check out my truth engine!
03:53:39 <u5h> http://thought.k.vu
03:58:25 <yitz> dmwit? dmwit_? dmwit__?
04:00:34 <yitz> u5h: that's an old game.
04:00:59 <yitz> @seen dmwit
04:00:59 <lambdabot> I saw dmwit leaving #haskell-blah, #xmonad, #haskell-in-depth and #haskell 3m 46s ago, and .
04:01:10 <yitz> @seen dmwit_
04:01:11 <lambdabot> dmwit_ is in #haskell-blah, #xmonad, #haskell-in-depth and #haskell. I don't know when dmwit_ last spoke.
04:01:15 <u5h> what's an old game
04:01:19 <yitz> @seen dmwit__
04:01:20 <lambdabot> dmwit__ is in #haskell-blah, #xmonad, #haskell-in-depth and #haskell. I don't know when dmwit__ last spoke.
04:02:37 <yitz> u5h: I mean I have seen stuff like that on the web before. It's a kind of multi-player distributed game. Some people become very immersed in it, I think.
04:02:49 <yitz> u5h: is yours in haskell?
04:03:06 <u5h> it's in php, it will be in haskell in a few months
04:05:58 <u5h> it's all functional so
04:06:03 <u5h> no harm no foul
04:08:13 <cognominal> :t one of
04:08:15 <lambdabot> parse error on input `of'
04:08:16 <cognominal> arf
04:08:22 <cognominal> :t oneOf
04:08:24 <lambdabot> Not in scope: `oneOf'
04:08:29 <asgaroth> @hoogle oneOf
04:08:30 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
04:08:30 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
04:08:30 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
04:10:27 <cognominal> I found it, that in Interact.hs file of yi
04:10:56 <cognominal> that's indeed a parser function
04:12:19 <flup> is partial applicationt he same as currying?
04:12:41 <Heffalump> not exactly, though I don't think either term is very clearly defined
04:13:06 <Heffalump> I would say that currying is the style of writing functions in a way that they can be partially applied
04:14:10 <flup> can functions using $ be partially applied? or is the (f . f) style encouraged to increase curryability?
04:14:27 <flup> and why the hell is it called pointsfree when it uses points...?
04:14:39 <Heffalump> I don't really understand what you mean.
04:14:57 <opqdonut> flup: because the term pointfree comes from category theory
04:15:15 <opqdonut> values are "points", the definition is pointfree if it doesn't mention the (input or output) values
04:15:16 <Heffalump> oh, points refer to explicitly naming values
04:15:20 <opqdonut> yep
04:17:51 <tertium> Heffalump: \x -> f (x,a) gives us a partial application of f to a without currying
04:19:47 <gio123> @seen ski_
04:19:48 <lambdabot> ski_ is in ##logic, #haskell, #haskell.hr and #haskell-in-depth. I last heard ski_ speak 21h 16m 48s ago.
04:20:16 <opqdonut> hmm, #haskell-in-depth?
04:20:23 <Heffalump> ok, in a way that can easily be partially applied
04:20:38 <Heffalump> I did think of that example as I wrote what I said above, I just thought it was overly pedantic :-p
04:21:05 <tertium> it was ;)
04:21:56 <Heffalump> hi ChilliX
04:29:23 <_sana> there is any equivalent of sockets in haskell ?
04:29:46 <opqdonut> ?hoogle network
04:29:46 <lambdabot> package network
04:29:46 <lambdabot> package network-bytestring
04:29:46 <lambdabot> package network-connection
04:30:12 <Lemmih> _sana: Well, there are Sockets.
04:30:24 <opqdonut> http://hackage.haskell.org/packages/archive/network/2.2.0.1/doc/html/Network.html
04:30:29 <opqdonut> http://hackage.haskell.org/packages/archive/network/2.2.0.1/doc/html/Network-Socket.html
04:30:47 <opqdonut> the former is a high-level library, the latter is a straightforward implementation of sockets
04:30:48 <_sana> and do you think i can use them to make a communication between a C++ program and a "hello world" in haskkel ?
04:31:43 <z0d> _sana: sockets are standard and language independent
04:32:11 <_sana> how can i serialize a haskell object ?
04:32:28 <opqdonut> see Data.Binary
04:32:35 <_sana> thanks
04:32:38 <opqdonut> :)
04:32:41 <Lemmih> Or just use Read/Show.
04:33:22 <maltem> _sana: If you're looking for unix file sockets, there should be something in System.Posix.Files
04:33:50 <_sana> nice :)
04:34:20 <Lemmih> maltem: Network has support for unix file sockets.
04:34:51 <maltem> oh, good to know, then that one is probably preferable
04:36:45 <maltem> Lemmih: what is the connection function called then?
04:37:13 <Lemmih> maltem: connectTo.
04:37:34 <maltem> oh, nevermind, I didn't see that PortID incorporates UnixSocket
04:39:07 <xcthulhu> I have a horrible backtrack search problem.  Does anyone know any good reads for memoizing with Map in Haskell?
04:39:33 <xcthulhu> Maybe in the State monad?
05:01:40 <_sana> why monad classes aren't derivable ?
05:02:00 <Botje> it's not trivial to derive? :)
05:02:55 <_sana> retoric question ? :)
05:04:47 <asgaroth> _sana: You can derive them for newtype declarations with NewtypeDeriving enabled via language pragma afaik
05:06:41 <Toxaris> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
05:06:42 <lambdabot> f a b =
05:06:42 <lambdabot>     case a of
05:06:42 <lambdabot>     Nothing -> Nothing
05:06:42 <lambdabot>     Just c -> b c
05:06:49 <Toxaris> @djinn a -> Maybe a
05:06:50 <lambdabot> f = Just
05:06:55 <Toxaris> not so hard :)
05:07:35 <ziman> @src Maybe (>>=)
05:07:36 <lambdabot> (Just x) >>= k      = k x
05:07:36 <lambdabot> Nothing  >>= _      = Nothing
05:08:12 <JKL_> is this a good way to do this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1259#a1259
05:08:24 <Toxaris> @djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
05:08:25 <lambdabot> f a b c =
05:08:25 <lambdabot>     case a c of
05:08:25 <lambdabot>     (d, e) -> b d e
05:08:35 <Toxaris> @djinn a -> (s -> (a, s))
05:08:36 <lambdabot> f a b = (a, b)
05:08:37 <moozilla> http://book.realworldhaskell.org/ is down
05:09:08 <Botje> JKL_: looks fine
05:09:23 <Toxaris> so for many interesting types, an IDE could "guess" the correct implementation, but of course, the user has to look at it and approve it
05:09:27 <JKL_> Botje: no simple idea how to cut lines?
05:09:29 <maltem> JKL_: you're missing a final Â»tuple1 _ = NothingÂ«
05:09:49 <rwanderley> hi, I'm having trouble trying to build the "network" package using cabal.  Am using ghc 6.11.20090127.  Have anyone have the same problem?
05:09:51 <JKL_> maltem: but there arent any more types?
05:09:53 <Botje> maltem: there are no other possibilities
05:10:05 <maltem> d'oh
05:10:06 <maltem> right
05:10:16 <Botje> JKL_: nope
05:10:29 <rwanderley> The problem seems to be at code dealing with exceptions.
05:10:38 <JKL_> Botje: ok, thx
05:11:01 <maltem> rwanderley: Control.Exception has undergone an API change in newer ghcs
05:11:49 <rwanderley> maltem: I read something about that at RWH, so you thing trying to change ghc to version 6.8 is the best solution?
05:12:03 <tertium> JKL_: why is it Tuple a instead of Tuple a b c d?
05:12:16 <maltem> rwanderley: To get Â»oldÂ« packages to compile again, they must now use Control.OldEcxeption. But actually I'd have thought that this would be fixed in the network package
05:12:32 <JKL_> tertium: I just wanted that all are same type. no other reason.
05:23:55 <Cheshire> > 1+0
05:23:57 <lambdabot>   1
05:28:19 <senex1> I want to parse lines in the style a,brs,c,d=>f, ignoring white space â€“ is Parsec the right choice or is it overkill for the task?
05:28:34 <sadache> if i have two functions both have a type a->b and a third function that has type b->b->c, is there anyway to compose them using some predifines functions or operators?
05:29:20 <paper_cc> @ty on
05:29:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:29:30 <paper_cc> sadache: ^^
05:29:44 <doserj> not quite...
05:30:30 <idnar> @src on
05:30:31 <lambdabot> (*) `on` f = \x y -> f x * f y
05:30:36 <idnar> so, you want something like
05:30:46 <idnar> (*) `on` f g = \x y -> f x * g y
05:31:02 <maltem> > uncurry (+) $ ((*2) &&& (^2)) 7
05:31:04 <lambdabot>   63
05:31:05 <sadache> ok great
05:31:15 <paper_cc> @ty (&&&)
05:31:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:31:21 <idnar> er, except don't call it 'on', obviously :P
05:32:08 <maltem> Well arrow notation doesn't really make anything clearer here.
05:32:44 <sadache> but in my case x and y is the same
05:33:20 <idnar> oh, more like: (*) `on2` f g = \x -> f x * g x
05:33:38 <paper_cc> @ty \f g -> join $ (f .) . g
05:33:40 <lambdabot> forall b c a. (b -> c) -> (a -> a -> b) -> a -> c
05:33:44 <Cheshire> senex1, in programming "overkill" does not exist
05:33:46 <idnar> @type \(*) f g = \x -> f x * g x
05:33:48 <lambdabot> parse error on input `='
05:33:53 <idnar> @type \(*) f g x -> f x * g x
05:33:55 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
05:34:31 <idnar> @pl \o f g x -> o (f x) (g x)
05:34:31 <lambdabot> liftM2
05:34:40 <idnar> oh, of course
05:34:41 <maltem> senex1: I find parsec nice to use for small things, too
05:34:41 <paper_cc> o_O
05:35:06 <idnar> liftM2 or liftA2 on functions
05:35:12 <sadache> but there is not predifines such function like the on2 you just defined?
05:35:22 <maltem> senex1: Still I wouldn't use it just to, say, split on commas
05:35:27 <idnar> > liftA2 (+) (*2) (*3) 5
05:35:29 <lambdabot>   25
05:35:37 <senex1> I mean: is it easier to write my own functions or learn how to use Parsec and then do it with a Parser
05:35:46 <idnar> > liftA2 (+) f g x
05:35:48 <lambdabot>   Add a type signature
05:35:49 <idnar> > liftA2 (+) f g x :: Expr
05:35:51 <lambdabot>   f x + g x
05:36:09 <idnar> sadache: ^^^ how's that?
05:36:09 <maltem> senex1: Learning parsec is easy
05:36:10 <sadache> ok that is it
05:36:27 <paper_cc> @ty liftA2
05:36:29 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
05:36:30 <maltem> senex1: otherwise, you probably have to try out :)
05:36:31 <sadache> idnar that is what i am searching for
05:36:35 <sadache> :)
05:36:42 <idnar> sadache: excellent :)
05:36:58 <sadache> thanks very much, you guys rock!
05:37:02 <paper_cc> , src ''Applicative
05:37:06 <lunabot>  class (Functor f) => Applicative f where
05:37:06 <lunabot>          pure :: forall a . a -> f a
05:37:06 <lunabot>          (<*>) :: forall b a . f (a -> b) -> f a -> f b
05:37:20 <sadache> i am doinf an f# application that looks much like happs on the .net
05:37:23 <senex1> ok â€¦ itâ€™s more than just splitting on the commas, because I also need to recognize the "=>" â€¦ I will try Parsec, thanks
05:38:14 <paolino> senex1: also readP can be useful
05:38:35 <senex1> readP?
05:38:49 <dcoutts> rwanderley: you can try building the network package against base 3 instead of 4
05:39:53 <paolino> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html
05:40:33 <paolino> it's in the base
05:40:49 <senex1> ok, thanks â€¦
05:43:02 <paolino> it has the nice feature that can be run to obtain reads function so you can use it easily  for Read instances
05:43:49 <JKL_> Am I all lost here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1261#a1261
05:46:06 <maltem> paolino: With the drawback that you get a list of alternatives instead of Either ErrorMessage Result
05:46:32 <paolino> right
05:47:21 <paolino> in the spirit of, there can't be errors in parsing
05:47:44 <maltem> JKL_: With "Haskell quadruple" the mean (a,b,c,d)
05:48:07 <maltem> JKL_: or, in your case, (a,a,a,a)
05:54:27 <Axman6> @src even
05:54:27 <lambdabot> even n = n `rem` 2 == 0
05:57:13 <Arnar> hi all
05:57:51 <Cheshire> hello
05:57:59 <evilbeetroot> GADT question: I read the wikibook on GADTs, and I looked at the SafeList example, and my immediate thought was to try and create a SafeTail to match the SafeHead.  You see, I wanted to see if it would blow up at runtime by recursing along the safe tail till it was empty.  But my code wouldn't compile with a wobbly type.  Is this to stop one from blowing it up at runtime, like I was attempting?
05:58:23 <Arnar> I'm wondering.. I have a self-compiled ghc 6.8.x in /usr/local/bin on os-x, and just installed the 6.10 package (which goes in /usr/bin).. what's the proper way to uninstall the former?
05:58:56 <maltem> evilbeetroot: Will you paste the code?
05:58:58 <zachk> sudo rm -rf hahha just kidding :D
05:59:09 <Arnar> zachk: :)
06:00:24 <maltem> Arnar: I fear there is no proper way, short of identifying large directories with the string "ghc" in it
06:00:32 <zachk> arnar: check out where 6.8 links too for directories and try renaming the directories for 6.8 and then run ghc and see if you get any errors
06:01:14 <Arnar> maltem, zachk: ok.. thanks :) I can easily remove the binaries, was just worried it'd leave some libs around that will interfere
06:01:26 <Cheery> hi, I heard a rumor that you can do haskell in .NET
06:01:35 <zachk> arnar: i am not quite sure. but if you do a mv (move) first then you can undo them
06:01:40 <pejo> Arnar, I can provide you with a file list. Is it 6.8.3 or 6.8.2?
06:01:44 <Cheery> what do you require for this? and can you use libs meant for C# this way?
06:01:59 <Arnar> pejo: excellent, thanks.. it's 6.8.2
06:02:18 <zachk> cheery: ive heard of F# which is close to ocaml fo .NET but i have not heard of haskell for .NET
06:02:31 <Cheery> oh, so that rumor is not true
06:02:40 <zachk> im not sure it is probably not
06:02:56 <maltem> Arnar: there shouldn't interfere anything, since the libraries are in $prefix/lib/ghc-$version
06:02:56 <zachk> but there is a functional language for .net. i just dont think its haskell
06:03:05 <Japsu> F#
06:03:05 <Cheery> I hate C# even if I have just couple of hours exposure on it
06:03:06 <pejo> Cheery, http://haskell.forkio.com/dotnet
06:04:02 <Arnar> maltem: ah, good. thanks
06:04:09 <evilbeetroot> maltem: hpaste won't save for some reason... http://virtualpaste.com/74788.  I know the forall y doesn't really fit, as its not really for all y, but only Empty and NonEmpty that are appropriate, but still it's the best idea I had.
06:04:38 <Cheery> hm. before going to hurt my head with interop wrappers, I think I rather do C#
06:04:56 <Cheery> even though I'm not sure about this
06:04:59 <Cheshire> evilbeetroot, sorry this GADT example is absolutely ridiculous
06:05:03 <pejo> zachk, it's an interop-layer for .net.
06:05:13 <Cheshire> evilbeetroot, we should really update the wiki so that it has got some sense
06:05:15 <Sup3rkiddo> is there a haskell newbie channel?
06:05:23 <Cheshire> Sup3rkiddo, you are here :p
06:05:39 <Cheshire> Sup3rkiddo, it is fine to ask beginner questions here
06:05:45 <Sup3rkiddo> Cheshire, oh.. ok :D, thanks
06:08:06 <maltem> evilbeetroot: yes the "forall y" is the problem, but sry I'm leaving now
06:08:07 <Cheshire> evilbeetroot maybe you missed my message
06:08:19 <evilbeetroot> I'm sorry, i got lagged out
06:08:40 <Cheshire> want me to repeat it ?
06:08:52 <evilbeetroot> If you would, thankyou
06:08:55 <evilbeetroot> :)
06:08:56 <Cheshire> evilbeetroot, sorry this GADT example is absolutely ridiculous
06:09:01 <evilbeetroot> ha
06:09:02 <Cheshire> evilbeetroot, we should really update the wiki so that it has got some sense
06:11:31 <athos> hi
06:11:43 <evilbeetroot> Chesire: I think I understand what GADTs can do now, but the cogs are turning to think up a more appropriate example
06:11:49 <evilbeetroot> hello
06:12:21 <Cheshire> evilbeetroot, I don't think anyone ever uses GADTs like that
06:15:49 <evilbeetroot> Maybe I still don't understand what they're useful for... I was thinking of a graph that could be Directed, or Undirected, but I still don't see why having an abstract variable in the graph declaration would improve things, rather than just having it reference say a GraphType data type.
06:15:49 <evilbeetroot> Ah.. the cogs finally turned
06:15:49 <evilbeetroot> it's so you can use an existentially quantified class members?
06:19:34 <athos> , permute [1,2,3]
06:19:36 <lunabot>  luna: Not in scope: `permute'
06:19:40 <athos> , permutation [1,2,3]
06:19:41 <lunabot>  luna: Not in scope: `permutation'
06:20:00 <Cheshire> , permutations [1,2,3]
06:20:00 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
06:20:02 <Sup3rkiddo> so, i was reading yaht and trying to solve its exercises. Can anyone tell me whats wrong with the following little function. I am well, 2 hours into haskell, so am not able understand why i get parse error (possibly incorrect indentation) in this piece of code, http://dpaste.com/118135/
06:20:18 <athos> , src 'permutations
06:20:20 <lunabot>  permutations :: forall a . [a] -> [[a]]
06:20:44 <Cheshire> Sup3rkiddo: I don't think there's anything wrong there really, just that you need to indent the 'then' and 'else' branches of the if a bit more
06:21:23 <Sup3rkiddo> Cheshire, hmm, ok.. i thought emacs would be indent it right..
06:23:01 <Axman6> , permutations [1,2,3]
06:23:02 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
06:25:06 <Axman6> , src 'permutations
06:25:09 <lunabot>  permutations :: forall a . [a] -> [[a]]
06:25:13 <athos> hehe
06:25:14 <Axman6> hmm
06:25:20 <Axman6> whatever lunabot
06:25:30 <athos> , where 'permutations
06:25:31 <lunabot>  luna: parse error on input `where'
06:25:34 <Cheshire> permutations = exerciseForTheReader
06:25:36 <athos> :0)
06:26:50 <Axman6> @src permutations
06:26:50 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:27:00 <athos> :D
06:30:26 <athos> :t delete
06:30:32 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
06:30:53 <athos> > delete 'A' "BAC"
06:30:57 <lambdabot>   "BC"
06:32:36 <athos> > let permutations [] = [[]]; permutations str = do { x <- str; xs <- permutations (delete x str); return (x:xs) } in permutations [1,2,3]
06:32:38 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
06:38:46 <Sup3rkiddo> hmm, now I get a No instance for (Num String) with http://dpaste.com/118141/ :(
06:38:58 <idnar> athos: unfortunately that doesn't work for duplicate values
06:38:59 <Axman6> athos: using delete adds an unnecessary restriction on permutations
06:39:11 <idnar> eg. permutations [1,1,2,3]
06:39:24 <Cheshire> Sup3rkiddo, because of (read x) should be just x
06:39:33 <Axman6> > delete 1 [1,1,2,3]
06:39:35 <lambdabot>   [1,2,3]
06:39:55 <idnar> > let permutations [] = [[]]; permutations str = do { x <- str; xs <- permutations (delete x str); return (x:xs) } in permutations [1,1,2,3]
06:39:57 <lambdabot>   [[1,1,2,3],[1,1,3,2],[1,2,1,3],[1,2,3,1],[1,3,1,2],[1,3,2,1],[1,1,2,3],[1,1...
06:40:16 <idnar> > let permutations [] = [[]]; permutations str = do { x <- str; xs <- permutations (delete x str); return (x:xs) } in permutations [1,1,2]
06:40:18 <lambdabot>   [[1,1,2],[1,2,1],[1,1,2],[1,2,1],[2,1,1],[2,1,1]]
06:40:20 <Sup3rkiddo> Cheshire, hmm, but getLine would give me a string right? so I have to convert the string to int?
06:40:22 <idnar> oh, hmm
06:40:35 <Sup3rkiddo> (or number, if i got the term wrong)
06:40:36 <idnar> I guess my reasoning was a bit faulty
06:41:16 <idnar> oh, except there are duplicated permutations there
06:41:27 <papermachine> idnar: I don't think so. |S_n| should be n!
06:41:34 <athos> Axman6: yeah, it's not my solution ;)
06:41:43 <idnar> so that doesn't really work
06:41:43 <Sup3rkiddo> Cheshire, i think it will help i pastebin the entire error message?
06:42:00 <hackage> Uploaded to hackage: hevolisa-dph 0.0
06:42:00 <hackage> Uploaded to hackage: hevolisa 0.0
06:42:03 <Cheshire> Sup3rkiddo, well you didn't getLine x
06:42:25 <athos> Axman6: eventually i need something "more" than permutations, so perhaps i won't go for "find a neat permutations solution and do some dirty tricks/hacks with it"
06:42:27 <Axman6> > let permutations [] = [[]]; permutations (x:xs) = [h ++ [x] ++ t |let xs' = permutations xs in (h,t) <- zip (inits xs) (tails xs)] in permutations [1..3]
06:42:29 <lambdabot>   <no location info>: Parse error in pattern
06:42:29 <Cheshire> Sup3rkiddo, by the way there is also  readLine  which is like getLine except it uses read too
06:42:37 <Axman6> bleh, wrong
06:43:08 <Sup3rkiddo> Cheshire, oh, ok..  have a long way to go.. just got my toes into the waters of haskell :D
06:43:17 <Cheshire> :)
06:45:43 <idnar> @where hpaste
06:45:44 <lambdabot> http://hpaste.org/
06:45:46 <idnar> @where hpaste22
06:45:47 <lambdabot> I know nothing about hpaste22.
06:45:47 <idnar> er
06:45:48 <idnar> @where hpaste2
06:45:49 <lambdabot> http://hpaste.org/
06:46:11 <JKL_> how to get 2 from (Left (Right 2))?
06:46:45 <Saizan> > let f (Left (Right x)) = x in f (Left (Right 2))
06:46:47 <lambdabot>   2
06:46:49 <idnar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1262 -- my permutations
06:46:51 <Axman6> >t join either (either id id)
06:46:55 <Axman6> :t join either (either id id)
06:46:57 <lambdabot> forall c. Either (Either c c) (Either c c) -> c
06:47:07 <idnar> I suspect it's a little long-winded
06:47:28 <Axman6> > join either (either id id) ((Left (Right 2)))
06:47:30 <lambdabot>   2
06:47:46 <Axman6> i'm quite impressed with that solution
06:47:50 <JKL_> no any more general than either?
06:48:14 <Axman6> what's wrong with it?
06:48:24 <Axman6> i mean, that's what it's there for
06:48:32 <JKL_> well i dont know what does join
06:48:42 <JKL_> maybe its that general part
06:49:34 <Axman6> @src (->) join
06:49:35 <lambdabot> Source not found. You untyped fool!
06:49:38 <Axman6> bah
06:50:18 <Axman6> well join on functions has the type join :: (a -> a -> b) -> (a -> b), and basically has to be written as join f x = f x x
06:50:53 <Axman6> the only reason i know about it is from this...
06:51:05 <Axman6> @pl \x -> x * x
06:51:06 <lambdabot> join (*)
06:51:21 <Axman6> applies x to both sides of the * basically
06:54:51 <jasondew> \msg lambdabot help
06:54:57 <jasondew> or not
06:55:22 <jasondew> anyone know how to get command help for the lambdabot?
06:55:39 <Axman6> /msg, not \msg
06:55:47 <Axman6> it's always / on IRC
06:55:52 <JKL_> Why this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1263#a1263
06:56:25 <jasondew> thanks axman
06:56:28 <Axman6> JKL_: import Control.Monad i think
06:56:34 <Axman6> or Control.Monad.Instances
06:57:08 <JKL_> Axman6: thx
07:01:31 <JKL_> join either (either id id) ((Left (Right 2))) == ((either id id) . (either id id)) (Left (Right 2)). But what if its (Left ( Left (...( Right 2)...)))). Or is it so stupid that who cares?
07:02:57 <Fredrik> I have trouble understanding the following expression: (< 5) How is it possible to bind the second argument to the function (<)? As I understand partial function application, you have to start at the left. Anyone care to explain? Thanks!
07:03:26 <trofi> (< 5) == \x -> (<) x 5
07:03:26 <paulvisschers> How can I tell ghc to also look for libs in a particular dir?
07:04:00 <trofi> (`mod` 5) == \x -> mod x 5
07:04:48 <Fredrik> I understand what it does, but I don't understand how it is possible :) Is it some special rule in the language about infix operators?
07:04:54 <Cheshire> (< 5) = \x -> (x < 5)
07:05:04 <Cheshire> Fredrix, exactly
07:05:12 <Fredrik> ah ok
07:05:22 <Fredrik> so i cannot do it with normal functions without writing lambdas?
07:05:38 <Cheshire> Fredrik, well you can use things like  flip
07:06:02 <Fredrik> flip :: (a -> b -> c) -> b -> a -> c
07:06:05 <Fredrik> great! thanks a lot!
07:06:28 <tertium> you can use backquotes, too: (`elem` S)
07:07:09 <Fredrik> also great, thanks!
07:08:57 <Olathe> @src flip
07:08:57 <lambdabot> flip f x y = f y x
07:13:07 <AfRoDoZiAk> Hi all
07:13:11 <paulvisschers> Fredrik: The backquotes actually make textual functions into infix operators, just like parentheses turn infix operators into prefix functions
07:13:27 <AfRoDoZiAk> Here there are girls from America to which it is possible to communicate?
07:13:49 <Fredrik> Thanks, I already knew that, but it didn't cross my mind to (ab?)use that for binding the second argument ;)
07:14:06 <AfRoDoZiAk> Here there are girls from America to which it is possible to communicate?
07:14:59 <AfRoDoZiAk> Who in a condition with me to talk:?
07:16:53 <ehird> augustss: I'm downloading the BASIC package.
07:16:58 <ehird> If I vomit shortly after, I'm suing.
07:17:10 <ehird> Just so you know.
07:17:11 <paulvisschers> I haven't been around in this channel for a while, but is it common for people with bad grammar to ask for cybersex?
07:17:19 <ehird> Erm. Not that I know of.
07:17:30 <ehird> We had a guy saying !list a lot recently.
07:18:17 <RayNbow> hmm
07:18:20 <RayNbow> !list
07:18:32 <ehird> !list
07:18:32 <RayNbow> no fserv/xdcc bots :p
07:18:38 <ehird> omg it has haskell 3.0
07:20:23 <ehird> instance Monad Expr where
07:20:24 <ehird>     a >> b = unsafePerformIO $ do push (flex a); push (flex b)
07:20:27 <ehird> Ahhhhhhhhh my god
07:20:32 <RayNbow> "Generating and compiling a zillion numerical type aliases, this might take a while" <-- XD
07:33:41 <AfRoDoZiAk> Hi all
07:33:46 <hallongrottan> hi AfRoDoZiAk
07:34:04 <AfRoDoZiAk> You as call
07:34:23 <Axman6> eh?
07:34:24 <AfRoDoZiAk> What is your name
07:34:56 <hallongrottan> I really don't follow
07:35:10 * Axman6 is confused too
07:35:19 * Axman6 thinks AfRoDoZiAk might be lost
07:35:23 <rwbarton> AfRoDoZiAk: You need to put @vixen before what you type
07:35:38 <AfRoDoZiAk> Here is American girls to whom it is possible to communicate?
07:35:59 <asgaroth> AfRoDoZiAk: This is not the channel you are looking for.
07:36:09 <Axman6> @vixen asl?
07:36:10 <lambdabot> 19/f/California
07:36:21 <koeien> only men with beards here
07:36:23 <Axman6> AfRoDoZiAk: lambdabot is hot and up for it
07:37:06 <AfRoDoZiAk> ppc
07:37:16 <AfRoDoZiAk> Åáëÿ êàêàåòî
07:37:22 <AfRoDoZiAk> ß õóåþ
07:37:33 --- mode: ChanServ set +o Saizan
07:37:47 --- mode: Saizan set +b *!*=afrodozi@217.149.186.*
07:37:47 --- kick: AfRoDoZiAk was kicked by Saizan (this is the wrong channel.)
07:38:14 --- mode: Saizan set -o Saizan
07:38:26 <Axman6> heh
07:39:14 <ehird> Here is American girls to whom it is possible to communicate.
07:39:29 <ehird> As opposed to American girls who are mute and cannot type and do not emit brainwaves
07:39:44 <hallongrottan> haha
07:46:27 <athos> :t foldr (.) id
07:46:29 <lambdabot> forall a. [a -> a] -> a -> a
07:46:49 <ehird> nice
07:47:53 <pk> @src unsafeInterleaveIO
07:47:53 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
07:47:54 <mauke> :t appEndo . mconcat . map Endo
07:47:56 <lambdabot> forall a. [a -> a] -> a -> a
07:48:01 <pk> @type unsafeInterleaveIO
07:48:03 <lambdabot> Not in scope: `unsafeInterleaveIO'
07:48:13 <mauke> IO a -> IO a
07:48:17 <athos> mauke: ah, nice :)
07:48:29 <athos> :t Endo
07:48:31 <lambdabot> forall a. (a -> a) -> Endo a
07:48:37 <pk> what does it do ?
07:48:42 <athos> @src Endo
07:48:43 <lambdabot> Source not found. I am sorry.
07:49:41 <pk> I don't understand the source at all
07:49:52 <mauke> me neither
07:51:02 <mauke> :t return . unsafePerformIO `asTypeOf` id
07:51:04 <lambdabot>     precedence parsing error
07:51:04 <lambdabot>         cannot mix `(.)' [infixr 9] and `asTypeOf' [infixl 9] in the same infix expression
07:51:04 <lambdabot> Not in scope: `unsafePerformIO'
07:51:20 <pk> what's res ?
07:51:24 <pk> and #
07:51:34 <pk> and can we pattern match on IO ?
07:51:39 <mauke> res is a variable bound by the pattern match
07:51:49 <mauke> er, this is all ghc internals
07:52:00 <mauke> this is not supposed to be used by you
07:52:02 <pk> so res = IO m
07:52:14 <asgaroth> athos: Endo is the type constructor so it has no real source definition besides "data Endo a = Endo (a -> a)"
07:52:30 <mauke> newtype Endo a = Endo {appEndo :: a -> a}
07:53:03 <ehird> Expando!
07:53:23 <ehird> pk: unsafeperformio is deep magic
07:53:25 <mauke> @src unsafePerformIO
07:53:26 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
07:53:31 <ehird> just don't even try to understand it
07:53:32 <Cheshire> @src lazy
07:53:33 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:53:37 <ehird> Cheshire: primitive
07:54:00 <ehird> basically, (# ... #) is an unboxed tuple, i.e. not on the heap
07:54:14 <ehird> and IO actions are functions taking the real world and returning a new real world.
07:54:21 <ehird> which is (# state of real world,  value #)
07:54:29 <ehird> so now you understand how unsafeperformio works
07:54:32 <ehird> or, not
07:54:51 <pk> i just wanna know what it does
07:55:01 <ehird> pk: black magic.
07:55:05 <ehird> unsafePerformIO :: IO a -> a
07:55:10 <Axman6> turns an IO a function into an a function
07:55:20 <ehird> it lets you do IO outside of the safe confines of the IO monad
07:55:27 <ehird> and thus royally screws up most things. including the type system.
07:55:30 <Axman6> makes IO 'pure' i guess. lets you use it anywhere, not just in monadic IO code
07:55:38 <rwbarton> You might think you want to do this, but you don't.
07:55:39 <ehird> don't use it. if you need to, you'll know where you need to use it.
07:55:41 <asgaroth> Don't use except for ffi stuff
07:55:43 <ehird> rwbarton: yeah, exactly
07:55:46 <pk> ok but I'm talking about unsageInterleaveIO
07:55:56 <ehird> pk: that's slightly more acceptable.
07:56:01 <ehird> you'll still get funny looks.
07:56:02 <athos> :t mapM
07:56:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:56:07 <Axman6> @src unsafeInterleaveIO
07:56:07 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
07:56:28 <Axman6> i don't get what that does either :\
07:56:36 <ehird> Axman6: it "forks off" a realworld, essentially
07:56:46 <ehird> unsafeInterleaveIO = return . unsafePerformIO
07:56:47 <ehird> I believe
07:56:56 <Axman6> hmm, i see
07:57:05 <ehird> @src getContents
07:57:05 <lambdabot> getContents = hGetContents stdin
07:57:10 <ehird> @src hGetContents
07:57:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:57:15 <ehird> Axman6: getContents uses it
07:57:18 <ehird> basically it does:
07:57:24 <rwbarton> Axman6: the effect is that the IO effects don't occur until the result of unsafeInterleaveIO is demanded
07:57:25 <ehird> unsafeInterleaveIO (read the whole file and return it)
07:57:29 <ehird> thus making it layz
07:57:32 <ehird> *lazy
07:57:35 <pk> ok
07:57:36 <ehird> even though the reading of the whole file is strict
07:57:48 <Axman6> rwbarton: ah, i see.
07:57:57 <mauke> @src hGetContents
07:57:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:57:59 <Axman6> nice timing, worked well with what ehird is saying too
07:58:04 <ehird> :)
07:58:05 <rwbarton> actually, it's more like getContents f = unsafeInterleaveIO (liftM2 (:) (getChar f) (getContents f))
07:58:15 <ehird> rwbarton: well, yeah
07:58:21 <mauke> it's unsafe all the way down
07:58:21 <pk> It's making sense
07:58:27 <pk> why is it unsafe ?
07:58:45 <ehird> i'm not sure why interleave is unsafe in itself
07:58:52 <ehird> I think because you can make the rest of the program unpredictabl
07:58:53 <ehird> e
07:58:54 <ehird> e.g. using iorefs
07:59:06 <rwbarton> It's unsafe in the sense that it causes the order of IO operations to become undefined
07:59:17 <ehird> right
07:59:21 <ehird> getContents is safe, though
07:59:24 <rwbarton> which would break the semantics for IO, if it had any
07:59:27 <ehird> because the order doesn't matter there
07:59:37 <mauke> ehird: not really
07:59:58 <ehird> why no
07:59:59 <ehird> t
08:00:12 <rwbarton> Everything is safe relative to something.  If you're worried about the contents of the file changing if you defer the file read, then getContents is not safe.
08:00:27 <rwbarton> Personally, I think that's a silly thing to worry about 99% of the time
08:00:36 <ehird> well, I'd specify the semantics of getContents as forbidding any other IO on that file
08:00:36 <mauke> you have a potential filehandle leak
08:00:54 <mauke> any errors in reading the file will be hidden
08:01:03 <ehird> ah, true
08:01:06 <ehird> you can fix that though
08:01:11 <ehird> by giving it an extra func to handle errors
08:01:16 <aeolist> hello everyone. i was wondering if you can emulate state with a monad, or do you need to interfae with a C program for that
08:01:18 <ehird> that's more a cornercase
08:01:32 <hallongrottan> aeolist: yu
08:01:35 <mauke> aeolist: you can emulate state with function parameters
08:01:35 <hallongrottan> oopn
08:01:48 <aeolist> when i say state, i mean like a mutable variable
08:01:58 <mauke> yes
08:02:03 <rwbarton> @src State
08:02:04 <mauke> ok, function parameters + return values
08:02:04 <lambdabot> Source not found. There are some things that I just don't know.
08:02:09 <rwbarton> , src ''State
08:02:10 <lunabot>  luna: Not in scope: type constructor or class `State'
08:02:10 <hallongrottan> @hoogle State
08:02:11 <lambdabot> module Control.Monad.State
08:02:11 <lambdabot> Test.HUnit.Base data State
08:02:11 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
08:02:15 <dsrogers> join #haskell-in-depth
08:02:21 <ehird> dsrogers: no
08:02:25 <dsrogers> lol
08:02:32 <hallongrottan> aeolist: take a look at Control.Monad.State
08:02:33 <dsrogers> it was a mistake.
08:02:39 <ehird> :)
08:02:52 <aeolist> ok thank you, i'll come back with more questions on type systems in a while
08:03:22 <pk> the whole point of IO is to force an evaluation order, right ?
08:03:31 <ehird> no
08:03:35 <ehird> the point of IO is to let you do IO
08:03:52 <pk> by forcing an evaluation order ?
08:03:55 <mauke> depends on your point of view
08:03:57 <rwbarton> No
08:04:11 <rwbarton> Evaluation and execution are different
08:04:15 <Cheshire> pk, no
08:04:44 <mauke> IO turns execution order into data dependencies ... or something
08:05:09 <mightybyte> Anyone know why ghc-6.10.1 installs libraries with 640 permsissions using make install on ubuntu?
08:05:20 <Cheshire> pk, if you wrote a program that computes a list [1,2,3] changing evaluation order wont make the program compute [2,1,3] somehow
08:06:04 <chipdude> My turn to explain
08:06:06 <Cale> pk: Evaluation does essentially nothing observable to IO values.
08:06:18 <Cale> pk: You can think of them as abstractly representing actions to be performed.
08:06:39 <chipdude> pk: an object of type IO () actually carries hidden information about what's supposed to be done, and the runtime does it, in a non-specified way
08:07:07 <mauke> chipdude? topaz? are you the Salzenberg guy from the perldocs?
08:07:14 <chipdude> mauke: the same :-)
08:07:26 <mauke> woot
08:07:27 <chipdude> the lambdacamels got me interested in Haskell
08:07:28 <Cale> You might think of a value of type (IO t) as the source code or abstract syntax for a program that does arbitrary stuff on your machine in order to compute a value of type t.
08:07:46 <chipdude> though it would seem that Pugs has been unmaintained for some time...?
08:07:49 <Cheshire> hehe "Do I know you off programming language documentation?"
08:08:07 <Cale> Evaluating that value doesn't cause it to run, any more than opening source code in a text editor will cause the program it describes to run.
08:08:21 <mauke> .oO( word macro viruses )
08:08:41 <chipdude> cheshir: I had to ask that recently, when I met Roland McGrath.  "Your name is familiar somehow..."   "I wrote GNU Make and lots of glibc."   "ooooh"
08:09:02 <mauke> haha
08:09:14 <ehird> chipdude: sounds like a nightmare</bsd flamebait>
08:09:29 <pk> it's an action, it's a program
08:09:36 <pk> what's an action, what's a program then ?
08:09:51 <chipdude> hehe.  GNU Make is a fine and powerful system.  As for glibc, well, given the constraints (fast-changing kernel) I think they've done well
08:10:12 <mauke> pk: something that can be executed by the gods outside of the haskell program
08:10:25 <chipdude> pk: the standard doesn't say.  "Magic Happens Here"
08:10:33 <pk> semanticaly
08:10:39 <mstr> where would be the best place to look how for example "instance Monad Maybe" is implemented?
08:11:23 <hallongrottan> mstr: where Maybe is defined
08:11:28 <pk> let's say I have an evil C function evalIO
08:11:31 <hallongrottan> like Data.Maybe
08:11:44 <mstr> hallongrottan: which can be found in?
08:11:45 <pejo> Is there an Either with one more constructor available somewhere?
08:12:06 <hallongrottan> mstr: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
08:12:22 <pk> I have evalIO(a >> b) do something like eval(a) then eval(b)
08:12:39 <Cale> pk: right.
08:12:45 <hallongrottan> mstr: doesnt seem to give the code for the instance though
08:12:46 <mstr> hallongrottan: and on this page the implementation of >>= can be found where?
08:12:46 <Cheshire> pk, what language is this eval(...) stuff in?
08:12:47 <ziman> why aren't there the `Source' links in GHC libs' documentation anymore?
08:12:49 <Cale> pk: But it's misleading to call it "eval"
08:12:54 <rwbarton> pk: call it execIO
08:12:56 <mauke> mstr: http://haskell.org/onlinereport/standard-prelude.html
08:12:57 <pk> ok
08:13:01 <Cale> pk: Better to use another word like 'execute'
08:13:14 <Cale> pk: Because it doesn't have anything to do with reducing expressions into values.
08:13:18 <pk> ok
08:13:45 <asgaroth> ziman: I rebuilt ghc with hscolour installed to get these at least for my local docs.
08:13:48 <Cale> It's entirely about causing the effects to occur. If it needs to reduce an expression to a value, it will call the (pure) Haskell evaluator.
08:13:54 <pk> ok
08:14:02 <mstr> thx mauke. it seems that the report page has an answer for most of my questions
08:14:06 <pk> so exec(return a) = eval(a)
08:14:18 <Cale> exec (return a) = a
08:14:19 <Cheshire> pk, what language
08:14:25 <Cale> No need to force the evaluation there.
08:14:29 <pk> any noy pure language
08:14:30 <Cale> (and it doesn't)
08:14:52 <Cale> Cheshire: He's thinking about the implementation of an RTS for Haskell.
08:15:24 <Cheshire> pk, so something strict/applicative which has got IO/side effects
08:15:58 <pk> yeah
08:16:01 <Cheshire> then you have:  exec(m >>= f) = exec(f $ exec(m))  ?
08:16:02 <aeolist> so i'm trying to classify type classes... they are existential types or F \omega?
08:16:13 <Cale> So we can think of the running of a Haskell program as consisting of these two interleaved processes. Evaluation, which reduces expressions into values (so that they can be pattern-matched against), and execution, which interprets (pattern matches) IO values and carries out the effects described.
08:16:24 <aeolist> F\omega is not implemented in haskell in any way
08:16:29 <Cheshire> aeolist, it can't work like that
08:17:33 <pejo> aeolist, atleast Wadler & Blott gives a translation from HM+TC -> HM.
08:17:36 <aeolist> Cheshire: i'm afraid you are right
08:17:57 <Cheshire> aeolist, I think this is why they called it ad-hoc overloading
08:19:18 <pk> so now suppose I have a haskell function evList (x:xs) = return x >> evList xs of type [a] -> IO (a)
08:19:23 <Cale> Evaluation is a pure function -- it always reduces the same expression to the same value. Execution is by definition not pure, because it carries out the effects, and occasionally gets values from input. But thought of as, say, a function from IO action values to C programs to be executed, say, it's pure.
08:19:26 <pejo> (Wadler & Blott is very readable, btw)
08:19:29 <rwbarton> pk: an expanded picture is exec(m) = case eval(m) of { return a -> a; m' >>= f -> exec(f(exec(m'))); putChar c -> exec(eval(c)); ... }
08:19:44 <Cale> pk: return x >> y  is always the same as y
08:19:58 <aeolist> pejo: to the uninitiated? i'll try that, thank you
08:20:07 <hallongrottan> mstr: did you find the implementation of Maybe >>= ?
08:20:07 <Cale> pk: x will not be evaluated there.
08:20:14 <Cheshire> pk, we can model a language like this with effects inside haskell using IO
08:20:37 <Cheshire> pk, so you could implement this 'exec' in that model (IO monad)
08:20:38 <pejo> aeolist, I'm very much uninitiated when it comes to type systems, so yes. :-)
08:20:46 <Cale> So that even if evaluating x would give nontermination, return x >> y will still be y.
08:22:06 <hallongrottan> mstr: anyway, it is most likely defined as Just x >>= f = f a, and Nothing >>= f = Nothing
08:22:30 <pk> ok so
08:22:31 <Cale> pk: The IO monad is about sequencing *effects* and not evaluation.
08:23:36 <pk> evList (x:xs) = (seq x $ evList xs)
08:23:43 <pk> now
08:24:15 <Cheshire> pk, foldr seq (?)
08:24:43 <pk> yep
08:25:36 <pk> my question is evList . (map unsafePerformIO) = sequence ?
08:26:09 <Cheshire> pk, that does not even type check
08:26:21 <Cheshire> pk, and I don't know what the (?) is supposed to be
08:26:29 <pk> a question marker
08:26:44 <pk> my question is evList . (map unsafePerformIO) == sequence ?
08:26:55 <rwbarton> :t [foldr seq () . map unsafePerformIO, unsafePerformIO . sequence_]
08:26:57 <lambdabot> Not in scope: `unsafePerformIO'
08:26:57 <lambdabot> Not in scope: `unsafePerformIO'
08:27:04 <Cheshire> pk, I said it  does't type check
08:27:07 <rwbarton> :t [foldr seq () . map ?unsafePerformIO, ?unsafePerformIO . sequence_]
08:27:08 <Cheshire> pk, so they cannot be equal
08:27:09 <lambdabot> forall (m :: * -> *). (?unsafePerformIO::m () -> (), Monad m) => [[m ()] -> ()]
08:27:22 <Cheshire> pk, the def of sequence doesn't use unsafe functionsn either
08:27:37 <ehird> @src sequence
08:27:37 <lambdabot> sequence []     = return []
08:27:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:27:37 <lambdabot> --OR
08:27:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:27:39 <pk> I know
08:28:13 <pk> but if it is equal then it shows my use of unsafePerformIO is justified
08:28:28 <ehird> no
08:28:31 <Cheshire> pk, no it does not
08:28:33 <ehird> your use of unsafeperformio is not justified
08:28:35 <ehird> ever
08:28:40 <rwbarton> pk: you need unsafePerformIO on the RHS also
08:28:41 <Cheshire> pk, and for a third time they aren't equal....
08:28:47 <ehird> there is no exception to this rule, and if there is, you'll know for sure when there is
08:28:55 <ehird> even though there isn't.
08:28:59 <rwbarton> :t [return . foldr seq () . map ?unsafePerformIO, sequence_]
08:29:01 <lambdabot> forall b (m :: * -> *) a. (?unsafePerformIO::m a -> b, Monad m) => [[m a] -> m ()]
08:29:15 <ehird> m a -> b? :P
08:29:25 <ehird> :t [return . foldr seq () . map (?unsafePerformIO :: IO a -> a), sequence_]
08:29:26 <lambdabot>     Could not deduce (?unsafePerformIO::IO a -> a) from the context ()
08:29:26 <lambdabot>       arising from a use of implicit parameter `?unsafePerformIO'
08:29:26 <lambdabot>                    at <interactive>:1:30-45
08:29:53 <rwbarton> :t let unsafePerformIO :: IO a -> a; unsafePerformIO = undefined in [return . foldr seq () . map unsafePerformIO, sequence_]
08:29:55 <lambdabot> forall a. [[IO a] -> IO ()]
08:30:17 <dolio> Those are no the same, however.
08:30:37 <rwbarton> that's true.
08:30:46 <dolio> Perhaps if you replaced return with evaluate.
08:31:37 <dolio> But I don't know how IO exceptions get propagated through unsafePerformIO.
08:31:42 <dolio> If at all.
08:32:05 <pk> if we forgot about exeptions
08:32:44 <pk> the two parts will behave the same way
08:32:56 <pk> I'm talking about your version rwbarton
08:33:14 <rwbarton> It's certainly not true unless you replace return by evaluate
08:33:32 <mstr> hallongrottan: oh, yeah, it was in mauke's link. for some reason hoogle doesn't seem to index the report page
08:33:44 <pk> @src evaluate
08:33:45 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
08:33:52 <rwbarton> Then, it is probably true in practice, but there are no semantics that you can appeal to to prove it
08:33:52 <ehird> o_O
08:33:53 <ehird> :t evaluate
08:33:55 <hallongrottan> mstr: oh, ok
08:33:55 <lambdabot> Not in scope: `evaluate'
08:34:01 <ehird> Where's evaluate?
08:34:01 <rwbarton> evaluate :: a -> IO a
08:34:02 <augustss> ehird: any vomiting?
08:34:12 <ehird> augustss: I'm still in shock atm
08:34:16 <ehird> rwbarton: you mean ... return?
08:34:17 <dolio> Control.Exception, I think.
08:34:20 <rwbarton> ehird: Nope
08:34:27 <ehird> oh, it's strict return
08:34:30 <ehird> foo !a = return a
08:34:33 <rwbarton> ehird: Nope :)
08:34:39 <ehird> what then
08:34:47 <rwbarton> ehird: evaluate a = (return $! a) >>= return
08:34:54 <ehird> weird
08:35:00 <ehird> what's the point
08:35:04 <rwbarton> ehird: The Control.Exception haddock page explains a little what's going on.
08:35:09 <ehird> OK
08:35:21 <rwbarton> evaluate a is an IO action that evaluates a
08:35:30 <ehird> hm.
08:35:36 <rwbarton> when the IO action occurs, not when "evaluate a" is forced
08:36:30 <pumpkin_> mauke: your client went bonkers in -blah
08:36:36 <asgaroth> Why is there an ">>= return" in the above definition? Wouldn't that normally do nothing according to the monad laws?
08:36:40 <pumpkin_> in case you're here and it's doing things behind your back
08:36:44 <mauke> more like s/bonkers/AWESOME/
08:36:55 <dolio> asgaroth: evaluate _|_ `seq` () = () is a required law.
08:36:58 <pumpkin_> lol
08:37:06 <dolio> But (return $! _|_) `seq` () = _|_.
08:37:18 <rwbarton> did I get that definition right?
08:37:27 <dolio> Yes, probably.
08:37:53 <rwbarton> right, the point is that _|_ >>= return is not actually _|_
08:38:08 <rwbarton> just like id . _|_ is not actually _|_
08:38:12 <dolio> Although it might be, depending on the definition of >>=.
08:38:24 <rwbarton> Right
08:39:08 <dolio> > ((return $! undefined) >>= return :: [Int]) `seq` ()
08:39:10 <lambdabot>   * Exception: Prelude.undefined
08:39:13 <asgaroth> Ok, thanks for the explanation
08:39:21 <ehird> it occurs to me that in theory land, all errors and nontermination are equal to the single value bottom,
08:39:30 <ehird> that the only way to keep this in practice is
08:39:34 <ehird> let undefined = undefined
08:39:35 <ehird> let error _ = undefined
08:39:52 <rwbarton> > ((return $! undefined) >>= return :: State Int Int) `seq` ()
08:39:54 <lambdabot>   ()
08:40:07 <dolio> I don't think evaluate is definable in general such that it always works.
08:40:15 <dolio> It's close to a walking monad law violation.
08:40:40 <rwbarton> I don't think it even makes sense to ask that it "work" in an arbitrary monad.
08:41:25 <dolio> Considering 'foo >>= return = foo' is a law, so '(return $! a) >>= return = return $! a' is required to hold if you're strict about the monad laws.
08:41:26 <rwbarton> Well, hmm...
08:41:45 <rwbarton> Heh, "strict" :)
08:42:59 <dolio> Which means that State is wrong. :)
08:43:27 <dolio> Of course, you can always wave your hands and ignore bottoms.
08:43:57 <dolio> Or, ignore seq.
08:44:10 <ehird> <dolio> Of course, you can always wave your hands and ignore bottoms.
08:44:18 <ehird> or get rid of bottom and live in the platonic realm of  total fp :^)
08:44:39 <dolio> Yes, well, then you're not using Haskell.
08:45:08 <ehird> If you ignore seq you're ignoring part of Haskell...
08:47:25 <mstr> how can you mix where or let with bind expressions?
08:47:36 <dolio> Yes, but not as much of Haskell as if you restricted yourself to totality.
08:48:04 <mstr> like in: http://pastebin.com/m2e0eafde
08:48:32 <mauke> mstr: you can't mix 'where' with expressions
08:48:48 <dolio> Anyhow, "Fast and Loose Reasoning is Morally Correct."
08:49:00 <dolio> So we're allowed to pretend Haskell is total even when it isn't. :)
08:49:14 <mstr> mauke: let?
08:49:25 <mauke> mstr: let is fine
08:49:47 <mstr> just can't figure out the syntax
08:50:14 <mauke> ... -> let xd = x - x'; yd = y - y' in return (sqrt (xd * xd + yd * yd))
08:50:26 <asgaroth> mstr: When using do-notation you can just put in lets and leave out the `in', otherwise just use let as you normally would
08:50:54 <mstr> I'm using the explicit binds for learning purposes
08:51:41 <mstr> so let needs to be before return?
08:51:56 <mstr> if I put it before bind operators, it fails
08:52:15 <mauke> er
08:52:44 <mauke> x, x', y, and y' need to be in scope to use them in the definitions of xd and yd
08:54:02 <mstr> ah, obv
08:59:28 <sadache> does anyone here has some knowledge in C# or Java? I want to know what is the difference between type constructors in haskell and generics in java and c#
09:01:26 <sadache> it seems to me often that we can do the same thing as type classes on decleration site using generics and interfaces inheritence, am i wrong?
09:01:53 <mauke> how do you write (Ord a, Num a) => a -> a in Java?
09:02:57 <Cheshire> mauke, I'm not sure if it's exactly valid but something like:  abstract class OrdAndNum implements Ord, Num {}
09:03:08 <Cheshire> then OrdAndNum foo(OrdAndNum x) { ...}
09:03:24 <mauke> but those are two different OrdAndNums
09:03:30 <Cale> sadache: They're roughly similar.
09:03:58 <mauke> and now I can't call foo(42), because Int doesn't inherit from OrdAndNum
09:04:47 <sadache> in C# Func<A> where A:Ord,Num
09:05:13 <sadache> in C# Func<A> where A : Ord,Num
09:05:22 <mauke> and where's the return type?
09:05:34 <sadache> sorry  Func<A,A> where A : Ord,Num
09:05:44 <mauke> ew
09:06:32 <sadache> i am just trying to see what type constructors are more than generics
09:06:48 <sadache> and what type classes are more than generic interfaces with constrains
09:07:33 <mauke> how do you define Monoid in C#?
09:07:39 <dolio> Can you write fromInteger :: Num n => Integer -> n in C#?
09:08:13 <memento> e
09:08:19 <athos> @hoogle <>
09:08:20 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
09:08:20 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
09:09:10 <sadache> Cale: when i interviewed Simon Peyton Jones he told that it is not as powerful because you do not have real type constructors and you can't abstract over type constructors, and i didnt understand it exactly
09:09:13 <athos> @hoogle <&>
09:09:14 <lambdabot> No results found
09:09:18 <athos> fine.
09:10:14 <mauke> data Mu t = In (t (Mu t))
09:10:29 <dolio> Oh, right. Can you write 'data Foo f = Foo (f Int)' in C#?
09:10:56 <sadache> dolio: I cant because interfaces work only on type decleration site, and that's a difference that i am aware of, but i feel that there is more to type classes than that
09:11:15 <mauke> huh? what typeclasses?
09:11:41 <rwbarton> maybe sadache is way back at fromIntegral
09:11:42 <dolio> Well, I did give two examples so far.
09:12:03 <mauke> dolio: template<template<typename> F> struct Foo { typedef F<int> t; };
09:12:09 <mauke> (C++)
09:12:35 <dolio> Yeah, that goes beyond my C++ abilities.
09:13:15 <dolio> I don't think C# and Java allow that kind of thing.
09:14:58 <rwbarton> sadache: can you define an interface Functor in C#/Java?
09:14:59 <dolio> C++ of course makes it as repulsive as possible. :)
09:15:07 * mauke tries template<template<typename> F> struct Mu { typedef F< Mu<F> > t; };
09:15:20 <byorgey> MY EYES
09:15:59 <byorgey> the goggles, etc.
09:16:24 <mauke> it doesn't compile
09:16:55 <sadache> dolio: yes you can define data Foo f = Foo (f Int) in c#
09:17:33 <dolio> Ah. I was under the impression that you were limited to kind *, eseentially.
09:17:48 <dolio> For your variables.
09:17:52 * rwbarton was too
09:17:58 <mauke> ah, it's template<template<typename> class F> struct Mu { typedef F< Mu<F> > t; };
09:18:00 <sadache> ah you are right
09:18:13 <sadache> i have to specify it explicitly
09:18:18 <sadache> i guess i am getting it
09:18:50 <sadache> in c# i have to say class Foo<F<T>>{}
09:19:17 <eric_j> anyone know of a function that has the capabilities of both foldl' and foldr?
09:19:43 <mauke> class Foo<F<T>> { F<Foo<F>> x; }?
09:20:17 <dolio> There's something you can't do in C++.
09:20:27 <dolio> Close two template brackets without space in between.
09:20:42 <pumpkin_> that annoys the hell out of me
09:20:51 <byorgey> eric_j: what do you mean?  which capabilities are you referring to?
09:21:21 <eric_j> hmm, i want to be able to accumulate, like fold', but i also want to be able to build a lazy list, like foldr
09:21:45 <byorgey> eric_j: ah, maybe you want something like mapAccumL
09:21:52 <byorgey> @type mapAccumL
09:21:53 <eric_j> thanks i'll check it out
09:21:54 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:22:25 <sadache> dolio: thank you i got it, you can not pass an abstract type with type parameters
09:23:09 <sadache> I can do so only if they have an interface in common
09:23:56 <sadache> so i can pass F<T> as an interface and then fill in whatever type that implements F<T> but i can not without an interface
09:26:33 <mauke> fuck. I need higher order templates
09:27:06 <kalven> dolio: it has been fixed
09:27:16 <dolio> It?
09:27:21 <kalven> >>
09:27:45 <dolio> Has it? Where? 0x?
09:27:51 <kalven> yes
09:27:54 <dolio> Ah.
09:28:15 <dolio> Is that official yet? They're running out of 0x years.
09:28:26 <kalven> it'll be 1x
09:28:37 <mauke> A<B<1>>2>>
09:29:45 <kalven> mauke: that'll require parenthesis in 1x
09:30:15 <gio123> @seen Cale
09:30:16 <lambdabot> Cale is in #haskell, #ghc, #haskell-overflow and #haskell-in-depth. I last heard Cale speak 26m 45s ago.
09:30:28 <gio123> @seen ski_
09:30:28 <lambdabot> ski_ is in ##logic, #haskell, #haskell.hr and #haskell-in-depth. I last heard ski_ speak 1d 2h 27m 28s ago.
09:36:31 <edbond> how to convert string to integer?
09:36:41 <Cheshire> edbond, use read :: String -> Integer
09:36:41 <pumpkin_> read
09:37:05 <edbond> thanks, I will try.
09:39:44 <edbond> how to convert String to [Char] ?
09:39:55 <Saizan> they are the same thing
09:39:58 <Cale> edbond: Nothing to do. String is [Char]
09:39:58 <pk> id
09:39:59 <Saizan> ?src String
09:40:00 <lambdabot> type String = [Char]
09:40:00 <edbond> I need to convert "1234" to [1,2,3,4]
09:40:14 <Cale> "1234" = ['1','2','3','4']
09:40:22 <Cale> They're notation for the same thing
09:40:26 <czShadoW> edbond: map digitToInt "1234"
09:40:43 <czShadoW> > map digitToInt "1234"
09:40:44 <lambdabot>   [1,2,3,4]
09:42:01 <hackage> Uploaded to hackage: BASIC 0.1.2.1
09:42:01 <hackage> Uploaded to hackage: BASIC 0.1.2.0
09:42:33 <ehird> oh god no
09:42:36 <edbond> thanks. haskell community is the best!
09:42:41 <pumpkin_> lol
09:42:50 <SamB> augustss: what was wrong with .0 ?
09:42:50 <pumpkin_> we're becoming the BASIC community now
09:42:56 <SamB> hackage: get it in ORDER
09:43:13 <augustss> SamB: an example file was missing from the .cabal file
09:43:33 <SamB> augustss: ah
09:43:48 <dcoutts> augustss: aye, we should implement that sdist check feature
09:43:59 <SamB> dcoutts: how would that catch missing examples ?
09:44:01 <augustss> dcoutts: yeah
09:44:20 <SamB> I guess at least implementing a feature to tell you which files WON'T be included in the sdist would be good ;-)
09:45:01 <dcoutts> SamB: what, comparing files under darcs control with those that'll end up in the tarball?
09:46:10 <SamB> dcoutts: ... maybe
09:46:31 <augustss> SamB: I've not implemented GOSUB in the LLVM code generator yet.  I need to change my LLVM bindings first. :)
09:46:34 <gwern> I keep saying - we need to build from sdist by default
09:46:41 <gwern> that'll kill these issues dead
09:47:08 <SamB> augustss: the what now ?
09:47:36 <SamB> gwern: won't kill missing human-targetted files
09:47:45 <SamB> only missing files needed for build
09:47:46 <augustss> SamB: GOSUB.  BASIC's wonderful totally unstructured subroutine call.  It's messy to implement
09:47:50 <Cheshire> augustss, do you use Cont?
09:47:53 <SamB> augustss: I know what GOSUB is
09:48:00 <SamB> I just didn't realize you had an LLVM backend
09:48:02 <Cheshire> ContT or whatever
09:48:02 <augustss> Cheshire: No
09:48:04 <Cheshire> oh......
09:48:09 <Cheshire> LLVM ? lol
09:48:23 <gwern> SamB: well, that's true. I suppose cabal could try something like darc's boringfiles thing, but that'd be bad...
09:48:24 <augustss> Cheshire: there is an interpreter and an LLVM backend
09:48:53 <pumpkin_> augustss: will you win the "fastest and most perverse basic implementation ever" award when this is done?
09:49:29 <augustss> pumpkin_: who gives out the award?
09:50:03 <pumpkin_> the basic foundation
09:50:25 <augustss> pumpkin_: i should have a fair chance
09:51:15 <dons> augustss: a native package for Arch of the lib, http://aur.archlinux.org/packages.php?ID=23761
09:51:39 <augustss> dons: the abomination spreads
09:51:53 <dons> :D
09:52:05 <mauke> augustss: http://dis.4chan.org/read/prog/1233796872/38-47
09:52:34 <dons> haha it has made it to 4chan
09:53:04 <ehird> 4chan has a rather large haskell obsession.
09:53:20 <ehird> i'm fairly sure that "label" doesn't have its do block indented enough
09:53:22 <ehird> also, needs to be $ do
09:53:24 <Cheshire> who taught 4chan how to use haskell..............
09:53:27 <mauke> /prog/ maybe.
09:53:31 <ehird> just (label "haxing") would work, though
09:53:32 <ehird> mauke: well, yeah
09:53:51 <augustss> mauke: haha
09:55:25 <adimit> Hey folks. I'd like to ask if there is a reference implementation of FSA (and DFSA) that implements the most common operations (Union, determinzation, whatnot) as a Haskell Library?
09:58:23 <dons> check on hackage.haskell.org, if not, it probably doesn't exist.
09:59:22 <pumpkin_> adimit: halex might have it
09:59:43 <gwern> hm, who packaged halex?
09:59:56 <pumpkin_> GwernBranwen
09:59:57 <pumpkin_> :P
10:00:06 <gwern> oh. right -_-
10:00:06 <mauke> ooh, a great package name: halitosis
10:00:24 <adimit> dons: I tried hoogle and hackage first, and I thought i'm probably too dumb to find one.
10:00:26 <ray> bad breath is not type safe
10:01:20 <RayNbow> mauke: you visit 4chan? :p
10:01:32 <mauke> RayNbow: sometimes
10:02:39 <adimit> there seems to be an fst library though. Maybe I'll just write an FSA lib myself. *sigh*
10:04:35 <augustss> ARGH!  This thing about 'cabal install' installing as user instead of global is driving me nuts.
10:04:42 <adimit> pumpkin_: ah, thanks, halex seems to have DFA and NFA modules. nice. But Hoogle doesn't find them.
10:05:23 <adimit> augustss: try --global or --prefix?
10:05:39 <mauke> user-install: False
10:05:41 <augustss> adimit: I just forget --global all the time
10:06:22 <dolio> augustss: There's some .cabal you can add it to, I think...
10:06:40 <dolio> .cabal/config, I guess.
10:06:43 <augustss> I should.  I think it's a misfeature
10:07:07 <SamB> yeah, global should be the default
10:07:21 <SamB> it's confusing enough when you set that to --user on PURPOSE
10:07:24 <augustss> cabal install and Setup install should have the same default, I don't care which it is
10:07:29 * SamB knows this from experience
10:07:30 <dons> augustss: you can set global in the config file.
10:07:40 <dons> its not global by default becaues that works for more people
10:07:45 <SamB> I also wish Setup used the setting as well, so I'd have some consistancy ...
10:07:53 <gwern> gobal implies root doesn't it?
10:08:22 <Saizan> global installs in /usr/local by default
10:08:33 <augustss> Having cabal install and Setup install have different defaults is really bad, imo.
10:09:31 <mauke> gwern: no
10:10:19 <SamB> mauke: yes!
10:10:24 <mauke> SamB: no
10:10:27 <SamB> basically yes
10:10:44 <SamB> do YOU have write permissions to /usr or /usr/local as non-root ?
10:10:48 <mauke> no
10:11:10 <SamB> so what does --global mean to you ?
10:11:43 <adimit> didn't --global use some command for gaining root-context (i.e. sudo)?
10:11:52 <augustss> SamB: I have write permission o /usr/local as non-root
10:11:59 <Saizan> if you set --root-cmd
10:12:06 <SamB> augustss: what kind of freak are you!
10:12:26 <Saizan> (and only in cabal-install)
10:12:28 <augustss> SamB: /usr/local is empty except for what I install there.
10:12:35 <mauke> SamB: register with ghc's package.conf, not my user's
10:12:59 <Saizan> cabal install and Setup install are quite different, btw
10:13:17 <SamB> mauke: oh, well, most people keep GHC in /usr or /usr/local ...
10:13:25 <mauke> I don't
10:13:28 <augustss> Of course, some broken systems install lots in /usr/local.  That's just wrong.
10:13:41 <SamB> augustss: yeah
10:14:17 <mauke> wow, I have ghc-6.4.1 remains in /usr/local
10:14:44 * SamB 's reasons for using --user are (a) lack of disk space in /usr and (b) not wanting to have to be there to type in the password OR for the building to be done as root
10:24:35 <Martijn_> Does anyone know if it's possible to combine hscurses with readline/editline/haskeline?
10:25:01 <gwern> I've never heard of it beign done, fwiw
10:25:38 * Martijn_ nods sadly.
10:25:38 <athos> @hoogle space
10:25:39 <lambdabot> Text.Parsec.Char space :: Stream s m Char => ParsecT s u m Char
10:25:39 <lambdabot> Text.PrettyPrint.HughesPJ space :: Doc
10:25:39 <lambdabot> Language.Haskell.TH.PprLib space :: Doc
10:25:52 <athos> @hoogle isSpace
10:25:53 <lambdabot> Data.Char isSpace :: Char -> Bool
10:25:53 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
10:25:53 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
10:26:15 <mauke> > filter isSpace [minBound .. maxBound]
10:26:17 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
10:27:23 <athos> > minBound
10:27:25 <lambdabot>   ()
10:27:29 <pumpkin_> > length $ filter isSpace [minBound .. maxBound]
10:27:31 <lambdabot>   24
10:27:49 <pk> > maxBound
10:27:50 <lambdabot>   ()
10:27:57 <mauke> @check (==)
10:27:59 <lambdabot>   "OK, passed 500 tests."
10:28:07 <pumpkin_> :P
10:28:22 <pumpkin_> @check (==) :: Int -> Int -> Bool
10:28:24 <lambdabot>   Couldn't match expected type `Int -> Int -> Bool'
10:28:38 <sbahra> :t (==)
10:28:40 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:28:44 <pumpkin_> @check ((==) :: Int -> Int -> Bool)
10:28:46 <lambdabot>   "Falsifiable, after 0 tests:\n1\n0\n"
10:29:02 <pumpkin_> I wonder why I need to parenthesize it
10:29:44 <mauke> @check )
10:29:44 <lambdabot>  Unbalanced parentheses
10:29:47 <Trafalgard> okay, so http://haskell.org/haskellwiki/GHC:FAQ says (omitting the very long #link) for a failure in the program where the exception/error isn't saying where it's happening, either to run it with teh GHCi Debugger or use -prof -auto-all and so on
10:29:48 <mauke> @check )(
10:29:49 <lambdabot>  Unbalanced parentheses
10:30:00 <Trafalgard> I tried using the GHCi debugger last night and had no luck
10:30:10 <Trafalgard> let's see, *tries again*
10:30:34 * Trafalgard sets :set -fbreak-on-exception
10:30:52 * Trafalgard loads main.hs
10:31:10 * Trafalgard does :trace main
10:31:24 <Trafalgard> Stopped at <exception thrown>
10:31:25 <Trafalgard> _exception :: e = _
10:31:25 <Trafalgard> [<exception thrown>] Prelude Main>
10:31:38 <Trafalgard> not a very stack tracey stack trace.
10:31:43 <Trafalgard> :|
10:32:05 <athos> > let f (x:[]) = [x+3] in f [0]
10:32:07 <lambdabot>   [3]
10:32:10 <Trafalgard> ah, I'm supposed to type something else after it.
10:32:13 <athos> > let f [x] = [x+3] in f [0]
10:32:16 <lambdabot>   [3]
10:32:24 <athos> Ah, cool.
10:32:47 <m0nkfish> athos..?
10:33:04 <m0nkfish> coding out loud? :p
10:33:44 <Trafalgard> My other question was about "Alternatively, compile your program with -prof -auto-all (make sure you have the profiling libraries installed), and run it with +RTS -xc -RTS to get a ´stack trace¡ at the point at which the exception was raised."
10:33:50 <Trafalgard> What are "the profiling libraries"
10:34:03 <Trafalgard> because I've been completely unable to find them
10:34:04 <koeien> ghc6-prof in debian
10:34:09 <Trafalgard> I'm on windows
10:34:15 <koeien> then i don't know :/
10:34:40 <Trafalgard> I looked on hackage and the only thing with prof in its name was prof2doc
10:34:51 <Saizan> Trafalgard: profiling libraries refers to the profiling version of the libraries you are using
10:35:18 <Saizan> Trafalgard: you should have the prof version for the ones shipped with ghc
10:35:29 <Trafalgard> Hmm, you'd think one of the five pages I read would have explained that :P
10:35:50 <Trafalgard> They all assumed you already had the libraries
10:36:15 <Trafalgard> yeah, I'm getting an error when I try to compile with it still though, but it's not about the ones that come with GHC, it's -
10:36:22 <Saizan> well, profiling libraries are just ones compiled with -prof
10:36:29 <Trafalgard> from cabal :P
10:36:39 <Trafalgard>     Could not find module `Distribution.Simple.Utils':
10:36:40 <Trafalgard>       Perhaps you haven't installed the profiling libraries for package Cabal-1.6.0.1?
10:36:50 <Trafalgard> and I assume I'd get further errors from other ones that didn't come with ghc
10:37:02 <SamB> Trafalgard: how'd you install GHC?
10:37:07 <Saizan> Trafalgard: e.g. cabal install -p --reinstall Cabal
10:37:25 <SamB> Saizan: he's probably right about those other libs though
10:37:45 <Saizan> SamB: right about what?
10:38:04 <Trafalgard> with the windows installer
10:38:06 <SamB> that he'll need profiling versions of those too
10:38:17 <SamB> Trafalgard: it didn't have an option to install profiling libraries ?
10:38:31 <Trafalgard> I had to install cabal separately if that's what you mean
10:38:36 <Saizan> SamB: that Cabal is almost surely not the one that comes with ghc
10:38:42 <pumpkin_> it's quite painful to move from a situation with a bunch of non-profiling libraries to one with profiling libs
10:38:46 <SamB> Saizan: hmm.
10:38:54 <Saizan> Trafalgard: which version of ghc?
10:38:59 <SamB> ah, yes, he says as much
10:39:00 <dons> pumpkin_: yes, maybe building -p ones should be on by default, if we spot that it is a library...
10:39:16 <SamB> Trafalgard: well, okay, then do what Saizan said and we'll see if that fixes it ;-)
10:39:38 <pumpkin_> dons: I'd certainly welcome it... I ended up getting rid of my .cabal when I tried it
10:39:40 <SamB> dons: -p only affects libraries anyway
10:39:44 <pumpkin_> although now I'd probably know better
10:39:44 <Saizan> you'll probably get other similar errors about libraries installed with cabal-install
10:40:03 <Trafalgard> 6.10.1/me checks what version of ghc this is
10:40:08 <Trafalgard> I THINK it's 6.10.1
10:40:12 <Trafalgard> but I'm not sure
10:40:15 <Trafalgard> so I'm checking
10:40:15 <Saizan> ghc --version
10:40:18 <SamB> really, the thing to do is get cabal to be able to go back and build the profiling versions too
10:40:19 * Trafalgard pretyped that :P
10:40:24 <pumpkin_> wow, your IRC client knew what version you had before you did :)
10:40:28 <pumpkin_> that's a smart client
10:40:38 <Trafalgard> I was in ghci and typing stuff like :ver and crap and it was going "yeah, no"
10:40:49 <dcoutts> SamB: yes, we should track each 'way' separately
10:40:54 <Trafalgard> yep, 6.10.1
10:41:17 <Trafalgard> okay, trying cabal install -p --reinstall Cabal
10:41:32 <pumpkin_> dcoutts: maybe have arbitrary possible 'ways'?
10:41:37 <Saizan> ah, then that error probably refers to a Cabal installed as --user
10:41:39 <pumpkin_> I can think of another situation in which that would be helpful
10:41:44 <dcoutts> pumpkin_: yes, that's the plan
10:41:45 <SamB> dcoutts: er, well, maybe not quite
10:42:01 <pumpkin_> dcoutts: sweet
10:42:15 <dcoutts> pumpkin_: but not before ghc 6.12
10:42:16 <SamB> dcoutts: I think it should go back and install the profiling version of whatever library version you were using for that package already
10:42:28 <mib_3x7ufy8d> hey all
10:42:29 <pumpkin_> dcoutts: I'll just set my clock forward
10:42:44 <dcoutts> SamB: yes, but that involves tracking the profiling libs at all
10:42:55 <SamB> dcoutts: yes, tracking is definately good
10:43:05 <Trafalgard> I installed cabal in msys, by the way, if that's relevant
10:43:20 <dcoutts> SamB: and that's what I mean about tracking different ways separately
10:43:29 <Trafalgard> and do the compiling and running ghci and so forth in there too
10:43:45 <pumpkin_> also, will cabal-install be distributed with ghc? I think it's way confusing to have a program called cabal in a package called cabal-install, and not in the package called cabal :P
10:43:48 <m0nkfish> how do i stop ghc going crazy when ive defined an infinite function
10:43:48 <m0nkfish> :(
10:44:06 <dcoutts> pumpkin_: no but both will be distributed with the platform
10:44:09 <koeien> m0nkfish: ctrl+C ?
10:44:10 <mauke> m0nkfish: what?
10:44:10 <pumpkin_> m0nkfish: you mean how ghci will refuse to ctrl+c sometimes?
10:44:18 <pumpkin_> dcoutts: ah, okay
10:44:25 <redditbot> "I've been using xmonad for the last 6 months and it is simply beautiful ... and it has crashed exactly zero times"
10:44:25 <redditbot> The Non-Determinism Monad
10:44:41 <m0nkfish> well i kinda defined my fibonacci sequence as being infinitely recursive
10:44:43 <rovar> open another shell; ps -ef ghci; kill -9 <pid>
10:44:44 <m0nkfish> then tested it
10:44:49 <mauke> rovar: overkill
10:44:55 <mauke> m0nkfish: ok, what's the problem?
10:44:57 <rovar> that's the best kind
10:45:01 <Trafalgard> okay, it finished
10:45:09 <Trafalgard> and... trying ghc -prof -auto-all --make Main again
10:45:10 <Trafalgard> and...
10:45:20 <pumpkin_> m0nkfish: I often ctrl+z and kill the process from the shell, if ghci goes haywire and refuses to accept my ctrl+c
10:45:24 <m0nkfish> well it just kept going...
10:45:26 <Trafalgard> Could not find module `Distribution.Simple.Utils':
10:45:26 <Trafalgard>       Perhaps you haven't installed the profiling libraries for package Cabal-1.6.0.1?
10:45:27 <m0nkfish> yeah i just ended the process
10:45:27 <Trafalgard> lol
10:45:36 <m0nkfish> and heres my fib output:
10:45:36 <m0nkfish> fib 1 2
10:45:37 <m0nkfish> 19,-1932295239,-557391920,1805280137,
10:45:39 <m0nkfish> :D
10:45:50 <pumpkin_> m0nkfish: I think something may be wrong ;)
10:45:51 <koeien> m0nkfish: looks like you used Int instead of Integer then
10:45:52 <mauke> why does your fib take two args?
10:46:17 <m0nkfish> fibonacci sequence needs two arguments to start it off
10:46:19 <m0nkfish> yeah i used int
10:46:24 <m0nkfish> whats the difference? i am a newb
10:46:32 <wli> m0nkfish: Where's the code?
10:46:32 <pumpkin_> Integer can get a lot bigger
10:46:33 <pumpkin_> :P
10:46:36 <koeien> m0nkfish: Int is of finite precision
10:46:43 <koeien> m0nkfish: whereas Integer is arbitrary precision
10:46:47 <m0nkfish> fib :: Integer -> Integer -> [Integer]
10:46:47 <m0nkfish> fib a b = a : fib b (a+b)
10:47:03 <Trafalgard> It even said when it was re-building/installing/whatever cabal [16 of 50] Compiling Distribution.Simple.Utils ( Distribution\Simple\Utils.hs,   ist\build\Distribution\Simple\Utils.p_o )
10:47:08 <Trafalgard> so I don't know why it didn't work
10:47:12 <koeien> m0nkfish: however Int is a bit faster
10:47:28 <koeien> m0nkfish: that's why 'length' for example returns an Int
10:47:28 <Saizan> Trafalgard: ok, it's ghc-pkg getting confused about having two Cabal-1.6.0.1 installed, the latter was probably initially installed by the bootstrap.sh script
10:47:30 <koeien> :t length
10:47:32 <lambdabot> forall a. [a] -> Int
10:47:33 <m0nkfish> but essentially they should act in the same way
10:47:43 <Saizan> Trafalgard: ghc-pkg list Cabal-1.6.0.1 lists 2 of them, right?
10:47:55 <koeien> m0nkfish: yes, but Int is limited to say 2^31-1 or so
10:47:57 <m0nkfish> when you add 3 and 5 you get 8 regardless of Int or Integer, correct?
10:47:59 <Trafalgard> ah, yep
10:48:02 <koeien> m0nkfish: yes
10:48:02 <dcoutts> Saizan: yes, another reason to get a new release out soon, to update that silly bootstrap script
10:48:15 <pumpkin_> > let 3 + 5 = 7 in 3 + 5
10:48:17 <lambdabot>   7
10:48:23 <pumpkin_> @type let 3 + 5 = 7 in 3 + 5
10:48:24 <m0nkfish> :p
10:48:25 <lambdabot> forall t. (Num t) => t
10:48:33 <m0nkfish> whats Num
10:48:35 <koeien> > 10 * 2^30
10:48:36 <wli> m0nkfish: What are you trying to do?
10:48:37 <lambdabot>   10737418240
10:48:42 <koeien> > 10 * (2^30  :: Int)
10:48:44 <lambdabot>   10737418240
10:48:46 <Saizan> Trafalgard: "ghc-pkg unregister --user Cabal-1.6.0.1" should fix the situation about Cabal
10:48:50 <pumpkin_> m0nkfish: a "number"
10:48:56 <Cale> m0nkfish: Num is a typeclass of types which are for representing numbers
10:49:00 <Trafalgard> one in program files / ghc / ghc-6.10.1 / package.conf, and one in documents and settings
10:49:11 <m0nkfish> currently im trying to learn haskell through Project Euler
10:49:17 <m0nkfish> and i'm on problem 2 ;D
10:49:19 <Cale> m0nkfish: Types in the class Num support basic arithmetic operations ((+), (*), negate and some others)
10:49:19 <koeien> > 10*(2^62 :: Int)
10:49:21 <lambdabot>   -9223372036854775808
10:49:23 <koeien> > 10*(2^62 :: Integer)
10:49:25 <lambdabot>   46116860184273879040
10:49:31 <koeien> heh, 64 bits machine
10:49:35 <m0nkfish> so i'm just trying to define a fibonacci sequence
10:49:45 <wli> m0nkfish: You seem to be priming the recurrence x_{n+2} = x_{n+1} + x_n with x_0 and x_1 and cranking it from there.
10:50:05 <Trafalgard> great, it compiles now!
10:50:06 <Saizan> dcoutts: we need to fix the tickets for the 0.6 milestone for that?
10:50:07 <Trafalgard> Thanks
10:50:22 <dcoutts> Saizan: yes, they're almost all done
10:50:28 <Trafalgard> and now I guess you know about a problem :P
10:50:33 <m0nkfish> well... it seems to make sense to me
10:50:51 <m0nkfish> you input 1 and 2, the function does 1 : fib 2 3
10:50:57 <m0nkfish> which then goes to 2 : fib 3 5
10:50:58 <dcoutts> Saizan: I hope to release Cabal-1.6.0.2 this week and cabal-install-0.6.2 shortly after that. Mostly it just needs proper testing.
10:50:59 <m0nkfish> etc
10:51:15 <m0nkfish> so its kinda an infinite list but i got the impression that haskell can handle such things
10:51:21 <Gracenotes> hm... I wonder if there's a transcript anywhere for Hilbert's speech
10:51:37 <pumpkin_> m0nkfish: yeah, it can, just don't try to read the whole thing
10:51:44 <m0nkfish> cool
10:51:49 <m0nkfish> so i tried "take 5 fib 1 2"
10:51:53 <m0nkfish> it doesnt like it :(
10:52:09 <pumpkin_> you ned to parenthesize it better
10:52:10 <pumpkin_> or add a $
10:52:25 <wli> m0nkfish: Let's start with generating functions...
10:52:27 <pumpkin_> that is basically (take 5 fib) 1 2
10:52:27 <m0nkfish> what does $ do?
10:52:41 <m0nkfish> ok so take 5 (fib 1 2)
10:52:51 <m0nkfish> woohoo it worked
10:52:54 <m0nkfish> i am happy :)
10:53:01 <koeien> m0nkfish: ($) is just function application
10:53:07 <m0nkfish> gonna learn me a haskell
10:53:08 <koeien> > (^2) 37
10:53:10 <lambdabot>   1369
10:53:10 <wli> m0nkfish: If you have a sequence like the Fibonacci numbers, its generating function is a power series whose coefficients are the members of the sequence.
10:53:14 <koeien> > (^2) $ 37
10:53:16 <lambdabot>   1369
10:53:21 <Gracenotes> meh. For this great speech, I'd at least hope someone would have a transcript
10:53:33 <m0nkfish> wli please use english ;)
10:53:33 <koeien> m0nkfish: its main use is preventing parentheses, since it has the lowest precedence
10:54:07 <m0nkfish> ^2 $ 37
10:54:20 <koeien> m0nkfish: you need parentheses, (^2) is a so-called "section"
10:54:37 <koeien> m0nkfish: (+1) is a function that adds one to its argument, (^2) is a squaring function
10:54:39 <m0nkfish> but the only difference was $, it didnt appear do do anything?
10:54:48 <m0nkfish> i am aware of this !
10:54:54 <koeien> > (*2) 1 + 1
10:54:55 <m0nkfish> i was just wondering what the $ did
10:54:55 <pumpkin_> m0nkfish: not in that example
10:54:56 <m0nkfish> :)
10:54:56 <lambdabot>   3
10:54:58 <koeien> > (*2) $ 1 + 1
10:54:59 <lambdabot>   4
10:55:03 <m0nkfish> ooh ok
10:55:13 <Gracenotes> aha, http://aleph0.clarku.edu/~djoyce/hilbert/toc.html
10:55:47 <true\false> Is there a decent PDF version of learn you a haskell?
10:56:04 <ehird> true\false: nope, what's wrong with the site?
10:56:33 <true\false> I'd prefer some form of offline version
10:56:40 <ehird> wget -r?
10:56:42 <true\false> The option of having, I should say.
10:56:51 <ehird> httrack? etc
10:56:56 <pumpkin_> true\false: maybe if you ask BONUS
10:57:14 <Gracenotes> hopefully there will be a decent hardbound version of Learn You a Haskell soon :D
10:58:19 <true\false> Ahh well, I guess I'll just download it all for now .. Decent thing to learn from. :)
10:59:48 <rovar> a while back i found a tutorial on setting up the complete haskell environment, (cabal, darcs, etc) now that I want it, I can't find it.. can anyone direct me?
11:01:06 <pumpkin_> dons: you still around?
11:03:02 <ehird> There should be a site like project euler, but just for haskell
11:03:12 <ehird> Like, stuff that comes out much better if you use clever haskell tricks.
11:03:27 <int80_h> speaking of which
11:03:29 <pumpkin_> yeah, I've wanted something like that before
11:03:37 <pumpkin_> and I want a codegolf site just for haskell
11:03:43 <int80_h> I tan my code overnight and it still never completed
11:03:45 <ehird> pumpkin_: well, anarchy golf has haskell
11:03:45 <PhilRod> that would be cool - I'd love to have a set of exercises for learning/using monads, etc
11:03:48 <ehird> and segregates results by language
11:03:51 <ehird> http://golf.shinh.org/
11:03:54 <pumpkin_> ehird: yeah, but it's not pretty
11:04:02 <pumpkin_> ehird: :P
11:04:12 <ehird> looks fine to me. plus, who cares? It's just golf :-P
11:05:11 <m0nkfish> project euler is pretty useful for learning any language
11:05:32 <pumpkin_> m0nkfish: it's mostly about algorithms and math though
11:05:34 <m0nkfish> especially new paradigms
11:05:35 <Gracenotes> http://golf.shinh.org/l.rb?hs
11:05:54 <pumpkin_> there's no reason to ever learn what a monad transformer does through project euler
11:05:55 <m0nkfish> yes but you need to know how to implement those algorithims
11:06:03 <m0nkfish> yeah for more advanced stuff theres no need
11:06:09 <ehird> Gracenotes: yep
11:06:14 <Gracenotes> except, like many code golf sites, it doesn't have the code :/ which is useful for competition, but not /that/ useful
11:06:20 <ehird> Gracenotes: yes it does
11:06:25 <ehird> you can decide when you submit a competition
11:06:30 <ehird> how long before the sources are revealed
11:06:41 <ehird> but that's a new feature
11:06:46 <ehird> so older challenges don't have it
11:06:51 <ehird> look at newer ones
11:07:04 <wli> m0nkfish: Anyway, Fibonacci ends up being f_n = c_1*r_1^n + c_2*r_2^n ; geometric summation gives the answer.
11:07:10 <Gracenotes> eh. Ideally, a Haskell code golf site wouldn't be /that/ competitive
11:07:32 <Gracenotes> people can get ideas from other people, and more than one class of solution could be developed
11:07:37 <ehird> anagolf is like that
11:07:42 <ehird> they just mostly do it on their irc channel
11:07:48 <ehird> #anagol on this server
11:08:25 <Gracenotes> is it...?
11:09:11 <ehird> yep
11:09:45 <Gracenotes> from {ChanServ} Channel #anagol is not registered.
11:09:56 <Gracenotes> or anagolf
11:10:00 <wli> c_1*(r_1^{n+1}-1)/(r_1-1) + c_2*(r_2^{n+1}-1)/(r_2-1) then you can calculate in the algebraic number field containing r_1 and r_2.
11:11:32 <wli> There's also some kind of identity you can use more directly I'm forgetting.
11:21:35 <m0nkfish> woooohoooooo
11:21:36 <wli> m0nkfis: Found it.
11:21:41 <m0nkfish> ?
11:21:58 <wli> m0nkfish: http://en.wikipedia.org/wiki/Fibonacci_numbers#Third_Identity
11:22:03 <m0nkfish> i dont understand all this maths stuff :(
11:22:55 <wli> The sum of the first n even Fibonacci numbers is f_{2n+1}-1
11:23:15 <m0nkfish> ah i see
11:23:27 <m0nkfish> i'm not trying to learn maths ;)
11:23:30 <edbond> how to check number has a digits after point?
11:23:49 <m0nkfish> mod (1 x) == 0 ?
11:23:52 <m0nkfish> dunno if it would work
11:24:01 <m0nkfish> worth a try eh
11:24:07 <paper_cc> @ty
11:24:09 <lambdabot> <no location info>: not an expression: `'
11:24:10 <paper_cc> @ty mod
11:24:12 <lambdabot> forall a. (Integral a) => a -> a -> a
11:24:20 <m0nkfish> nope
11:24:26 <m0nkfish> maybe just /
11:24:32 <rwbarton> edbond: you have a Double and you want to know whether it's an integer?
11:24:42 <edbond> rwbarton: yep
11:24:48 <pumpkin_> m0nkfish: you won't get too far in project euler if you don't want to learn maths :P
11:24:58 <mriou> hi, I just need a quick confirmation: if I call twice the same pure function with the same parameters in a given expression
11:24:58 <m0nkfish> i'm not trying to get far
11:25:05 <wli> m0nkfish: let fib :: Integer -> Integer ; fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n - 1) + fib (n - 2) in [(fib (2*n + 1) - 1, sum [fib (2*k) | k <- [0..n]]) | n <- [0..]]
11:25:05 <zzz> ls -lrt
11:25:06 <m0nkfish> i am trying to learn some haskell ;)
11:25:07 <edbond> rwbarton: I have a result of sqrt and want to check is in Int.
11:25:13 <rwbarton> edbond: oh
11:25:14 <mriou> practically speaking the computation is going to be done only once right?
11:25:15 <pumpkin_> m0nkfish: alright :P
11:25:29 <zzz> oops. Wrong window. Sorry.
11:25:51 <bd_> mriou: the results of the two calls will be the same. whether it's actually evaluated depends on how smart the compiler is, but don't necessarily trust it to make a O(2^n) algorithm into a O(n) algorithm, for example...
11:26:21 <rwbarton> edbond: I don't trust Doubles much so I'd probably use round to convert the Double to the nearest integer, and then square it, and see whether it's my original integer.
11:27:20 <edbond> rwbarton: thanks, great solution.
11:27:21 <mriou> bd_ so say in ghc to be more specific, I do (fst $ foo a) + (snd $ foo a) for example, is the (foo a) computation going to happen twice?
11:27:51 <rwbarton> mriou: Yes, almost certainly
11:28:22 <paper_cc> mriou: that's `uncurry (+)' btw =)
11:28:23 <mriou> doing a "let fa = foo a" just to make sure it isn't repeated looks like visual pollution to me sometimes
11:28:52 <Olathe> You could use where on the next line.
11:28:55 <mriou> paper_cc: right, that was just an example but thanks for the tip :)
11:29:05 <mriou> rwbarton: perfect, thanks
11:29:07 <wli> m0nkfish: Now the trick is to find the largest n where F_{2n} is <= 4M.
11:29:10 <pumpkin_> mriou: I would also like to have some unobtrusive annotation for marking sharable stuff
11:29:14 <Olathe> I do that to avoid the clutter.
11:29:38 <rwbarton> mriou: the reason is that sharing foo a as you do with the let might increase the space complexity of the program
11:29:54 <mriou> pumpkin_ what sort of annotation are you thinking of?
11:30:12 <mriou> rwbarton: good point
11:30:32 <pumpkin_> haven't thought of a good way to do it :) but I mean some inline way of specifying that you're fine with something being shared
11:30:35 <rwbarton> mriou: maybe not in this case, but for  product [1..1000000] - sum [1..1000000]  say.  So ghc won't do this optimization (usually)
11:30:56 <pumpkin_> rwbarton: ideally it would traverse the list once :P
11:31:20 <pumpkin_> and still not keep the entire list around
11:31:47 <mriou> rwbarton: that's understandable if maybe not optimal, it's a but more complex than just reusing a pure computation
11:31:59 <luqui> pumpkin, aye, (-) is strict in both arguments, so you can evaluate them in parallel
11:32:00 <pejo> pumpkin, what kind of transformation would make it traverse it only once?
11:32:04 <mriou> (but -> bit)
11:32:22 <L11> is there an easy way to check if a string starts with a vowel?
11:33:01 <luqui> pumpkin, but the problem remains, since you can't always do that:   if product [1..1000000] < x then sum [1..1000000] else 0
11:33:02 <rwbarton> mriou: in a strict pure language there would be no hope of consuming [1..1000000] as it gets produced so there's no cost in sharing it
11:33:03 <pumpkin_> luqui: I don't mean parallel as in `par`, but just "merging" the product and sum folds to maintain a pair :P
11:33:15 <luqui> pumpkin, sure, but I *do* mean parallel as in `par`
11:33:29 <pumpkin_> luqui: that'd be less efficient than what I'm saying though
11:33:34 <luqui> because that is a much easier transformation for a compiler to do than fusing
11:33:48 <luqui> pumpkin, not necessarily.  just on the current RTS implementation on current hardware.
11:34:05 <pumpkin_> luqui: yeah, of course... but it would be beautiful to be able to figure out what can be computed independently on the same input list, so as to only actually iterate over the list once
11:34:11 <pumpkin_> pejo: a difficult one :P
11:34:19 <mstr> L11: (x !! 0) `elem` "aeiouy" ? :P
11:34:28 <pejo> luqui, efficient automatic parallelization is very hard though.
11:34:38 <luqui> pejo, so is fusing
11:34:42 <pumpkin_> @src sum
11:34:43 <lambdabot> sum = foldl (+) 0
11:34:44 <pumpkin_> @src product
11:34:45 <lambdabot> product = foldl (*) 1
11:34:59 <luqui> if these were easy problems, they wouldn't be problems :-)
11:35:10 <pumpkin_> sumproduct = foldl ((+) *** (*)) (0, 1) or something
11:35:12 <pumpkin_> :P
11:35:18 <pejo> luqui, but we do have some kind of fusion in existing compilers today. Is there any working automatic parallelization available anywhere?
11:35:22 <pumpkin_> actually that won't work
11:35:36 <sm> ghc needs me to declare an error value is an exception. With 6.8 I must use Exception, with 6.10 I must use SomeException. Is there a way to satisfy both compilers without an #ifdef ?
11:35:53 <luqui> pejo, sure.  whether there is any *good* automatic par is another question.
11:36:14 <pejo> sm, no, there was discussions somewhere how Cabal handles it - i'd copy what they do if you can find the mails.
11:36:37 <sm> thanks
11:36:43 <luqui> pejo, but, for example, I think what I suggest would be fine for this example.  If you have a function call independently strict in both arguments, you can parallelize evaluation of them.  The problem is the thread forking overhead.
11:36:50 <L11> mstr: mind explaining that syntax to me?
11:37:05 <rwbarton> sm: I think you can use the extensible-exceptions package which does the CPP thing for you
11:37:13 <sm> aha
11:37:26 <pejo> luqui, yes, Satnam Singh and Tim Harris had a paper at ICFP a couple of  years ago about that.
11:37:27 <luqui> in fact, I would consider forking overhead the #1 problem to be tackled in parallelization.
11:38:22 * sbahra would have to disagree with luqui 
11:38:39 <sbahra> Unless you're referring to it being a problem in Haskell.
11:39:13 <luqui> sbahra, uhmm... yeah. one must take my statements with the implicit hypothesis "haskell is the only programming language"
11:39:14 <mauke> sm: it probably involves restricting your version of base to 3.*
11:39:23 <mstr> L11: take first char from string x and check if it's in string which has vovels
11:39:24 <sm> can't do that..
11:39:37 <sbahra> luqui, ;-p
11:39:38 <sm> but http://hackage.haskell.org/cgi-bin/hackage-scripts/package/extensible-exceptions says it works with base 4 too
11:40:00 <mauke> wtf
11:40:27 <rwbarton> luqui: I think knowing that product [1..1000000] - sum [1..1000000] should be transformed at all is difficult.  It relies on knowing quite a lot about sum, product, and (-)
11:41:03 <luqui> rwbarton, really?  I think it only relies on knowing something about (-)
11:41:10 <rwbarton> L11: you can also write   startsWithVowel :: String -> Bool; startsWithVowel (c:cs) | c `elem` "aeiouy" = True; startsWithVowel _ = False
11:41:17 <luqui> rwbarton, unless you are talking about forking overhead ...
11:41:53 <asgaroth> I have a module A which depends on a newtype declaration(with deriving and such) from module B which in turn depends on A. There's a B.hs-boot file to get around some of the dependency, but adding the newtype there or using data makes the deriving in B.hs fail. How can I fix this?
11:43:38 <rwbarton> luqui: hmm, maybe you're right, since there is really only one way to traverse a list
11:43:50 <sm> rwbarton: indeed, that seems to solve it. Thanks! all
11:43:53 <paper_cc> asgaroth: standalone deriving?
11:45:45 <asgaroth> paper_cc: Would I have to use that in B.hs or B.hs-boot? (The datatype in question also uses these NewtypeDeriving features)
11:46:12 <rwbarton> luqui: if the common expression is a binary tree, and the two functions traverse it differently, sharing it and doing the traversals in parallel won't run in low memory
11:46:47 <paper_cc> asgaroth: I'd say in B.hs, but I haven't used it actually
11:47:15 <paper_cc> pumpkin_: btw, is there a standard way to write \f g (a, b) (x, y) -> (f a x, g b y) ?
11:47:20 <L11> what does (x !! 0) mean?
11:47:37 <paper_cc> L11: indexing
11:47:37 <pumpkin_> L11: getting the 0th index of list x
11:47:45 <pumpkin_> paper_cc: hmm
11:47:56 <pumpkin_> @pl \f g (a, b) (x, y) -> (f a x, g b y)
11:47:58 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
11:48:00 * pumpkin_ barfs
11:48:00 <L11> so i take it !! is a special operator?
11:48:07 <rwbarton> @src (!!)
11:48:07 <lambdabot> xs     !! n | n < 0 = undefined
11:48:07 <lambdabot> []     !! _         = undefined
11:48:07 <lambdabot> (x:_)  !! 0         = x
11:48:07 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:48:09 <pumpkin_> L11: nope, nothing special about it
11:48:11 <asgaroth> paper_cc: thanks, I'll give it a try
11:48:11 <paper_cc> pumpkin_: aha
11:48:20 <luqui> rwbarton, the memory performance will be no worse than doing it sequentially
11:48:29 <paper_cc> L11: (!! 0) can also be written as head
11:48:29 <pumpkin_> paper_cc: chessguy had something similar a couple of weeks ago
11:48:32 <pumpkin_> with only one function
11:48:37 <luqui> rwbarton, in the tree case
11:48:51 <rwbarton> luqui: it will be worse than not sharing at all... in some cases
11:49:08 <luqui> rwbarton, oh right, which was the original context.  good observation.
11:49:34 <pumpkin_> paper_cc: someone on -cafe came up with one
11:49:56 <pumpkin_> @type uncurry (***) . (first f) . (second f)
11:49:58 <lambdabot> forall (a :: * -> * -> *) b c b' c' b1 d. (SimpleReflect.FromExpr (a b' c'), Show b1, SimpleReflect.FromExpr (a b c), Show d, Arrow a) => (d, b1) -> a (b, b') (c, c')
11:50:02 <pumpkin_> @type \f -> uncurry (***) . (first f) . (second f)
11:50:04 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => (d -> a b c) -> (d, d) -> a (b, b) (c, c)
11:51:21 <kerlo> > [] !! 9001
11:51:22 <lambdabot>   * Exception: Prelude.(!!): index too large
11:51:26 <dolio> first f . second f = f *** f
11:51:35 <JKL_> Exercise 4.10 in yaht is too hard for me. Heeelp :) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1269#a1269
11:51:42 <kerlo> It lies.
11:51:50 <mstr> L11: x !! 0 is like x[0] in C
11:51:56 <pumpkin_> dolio: yeah, hmm
11:52:06 <pumpkin_> I was just playing with the email responses :)
11:52:29 <dolio> :t join (***) >>> uncurry (***)
11:52:31 <lambdabot>     No instance for (Arrow (,))
11:52:31 <lambdabot>       arising from a use of `***' at <interactive>:1:5-9
11:52:31 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
11:52:48 <asgaroth> paper_cc: Hmm, still the same problem.
11:53:26 <dolio> :t \f -> f *** f >>> uncurry (***)
11:53:28 <lambdabot> forall b (a :: * -> * -> *) b' c'. (Arrow a) => (b -> a b' c') -> (b, b) -> a (b', b') (c', c')
11:54:32 <pumpkin_> I'd like to see djinn come up with the reverse of that :P
11:54:35 * paper_cc duz want some `specialize-the-type-for-(->)' command
11:55:05 <paper_cc> @ty (>>> uncurry (***))
11:55:07 <lambdabot> forall b (a :: * -> * -> *) b1 c b' c'. (Arrow a) => (b -> (a b1 c, a b' c')) -> b -> a (b1, b') (c, c')
11:55:11 <dolio> :t \f -> f *** f >>> uncurry ((***) . id)
11:55:13 <lambdabot> forall b (a :: * -> * -> *) b' c'. (Arrow a) => (b -> a b' c') -> (b, b) -> a (b', b') (c', c')
11:55:21 <dolio> Hmm, that didn't work.
11:55:34 <dolio> :t \f -> f *** f >>> uncurry ((***) . (. id))
11:55:36 <lambdabot> forall b b' c'. (b -> b' -> c') -> (b, b) -> (b', b') -> (c', c')
11:55:42 <dolio> There we go.
11:56:09 <pumpkin_> :D
11:56:21 <paper_cc> the @pl way to get the answer =)
11:56:35 <pumpkin_> is that pairzip?
11:56:41 <pumpkin_> pairzipwith
11:57:15 <pumpkin_> > let pairZipWith f = f *** f >>> uncurry ((***) . (. id)) in pairZipWith (+) (1,2) (3,4)
11:57:17 <lambdabot>   (4,6)
11:57:18 <dolio> It's \f (a,a') (b,b') -> (f a b, f a' b')
11:57:26 <ddvlad> @hoogle isDigit
11:57:27 <lambdabot> Data.Char isDigit :: Char -> Bool
11:58:23 <paper_cc> @ty join (***)
11:58:24 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:59:04 <wli> ugh, it's the fibs which are themselves even, not f_n for even n
11:59:30 <paper_cc> @ty uncurry (*) *** uncurry (+)
11:59:32 <lambdabot> forall a a1. (Num a1, Num a) => ((a, a), (a1, a1)) -> (a, a1)
11:59:49 <paper_cc> @ty curry $ uncurry (*) (***) uncurry (+)
11:59:50 <dolio> fix $ (1:) . scanl (+) 1
11:59:51 <lambdabot>     Couldn't match expected type `(a, a)'
11:59:51 <lambdabot>            against inferred type `a1 b c -> a1 b' c' -> a1 (b, b') (c, c')'
11:59:51 <lambdabot>     In the second argument of `uncurry', namely `(***)'
11:59:54 <dolio> > fix $ (1:) . scanl (+) 1
11:59:56 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
12:00:09 <dolio> So, every 3?
12:00:13 <wli> Those are F_{3n}
12:00:13 <paper_cc> @ty curry $ uncurry (*) *** uncurry (+)
12:00:15 <wli> Yeah.
12:00:15 <lambdabot> forall a a1. (Num a1, Num a) => (a, a) -> (a1, a1) -> (a, a1)
12:01:11 <jekor> Is it possible to pattern match on types? I'd like to match on something like (s :: String), etc.
12:01:56 <paper_cc> @ty (*) *** (+)
12:01:57 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a -> a, b' -> b')
12:01:58 <asgaroth> jekor: A value can only have one specific type
12:02:12 <paper_cc> jekor: you can use typeclasses for that
12:02:25 <jekor> asgaroth: Makes sense. But what about a function that's using a type class?
12:02:43 <jekor> So I need to look up the constructors for the typeclass?...
12:02:58 <rwbarton> jekor: No, your function needs to be a method of a type class
12:03:01 <paper_cc> class CanDoF where f :: {- ... -}, instance CanDoF String where f x = ...
12:03:10 <paper_cc> jekor: ^^ like this
12:03:12 <m0nkfish> how do you make lambdabot do stuff
12:03:16 <jekor> Ah...
12:03:20 <asgaroth> m0nkfish: > code
12:03:22 <asgaroth> > 1 +1
12:03:24 <lambdabot>   2
12:04:12 <paper_cc> @ty uncurry on
12:04:14 <lambdabot> forall b c a. (b -> b -> c, a -> b) -> a -> a -> c
12:04:19 <trofi> @do stuff
12:04:20 <lambdabot> stuff not available
12:04:25 <paper_cc> =)
12:04:26 <rwbarton> > do stuff
12:04:28 <lambdabot>   Not in scope: `stuff'
12:05:35 <paper_cc> @ty uncurry ($)
12:05:37 <lambdabot> forall a b. (a -> b, a) -> b
12:05:37 <wli> Well, the geometric series gives c_1(r_1^{3n+1}-1)/(r_1-1) + c_2(r_2^{3n+1}-1)/(r_2-1)
12:05:49 <wli> So F_{3n+1} seems plausible...
12:06:02 <paper_cc> @ty uncurry (.)
12:06:03 <gwern> @seen waern
12:06:04 <lambdabot> forall b c a. (b -> c, a -> b) -> a -> c
12:06:04 <lambdabot> I saw waern leaving #ghc, #yi and #haskell 22h 33m 48s ago, and .
12:06:46 <paper_cc> @ty join (***) ($)
12:06:48 <gwern> hm, this is strange. why do docs fail with cabal install but work with configure && haddock?
12:06:48 <lambdabot> forall a b. (a -> b, a -> b) -> (a -> b, a -> b)
12:07:30 <dcoutts> gwern: lemme know if you find out more details
12:07:32 <m0nkfish> how can i extract digits from a number?
12:07:39 <m0nkfish> must i convert it to a literal string?
12:08:18 <paper_cc> > 123456 `div` 100 `mod` 10
12:08:19 <lambdabot>   4
12:08:34 <rwbarton> > look
12:08:36 <lambdabot>   You are standing at the end of a road before a small brick building.
12:08:40 <rwbarton> > enter
12:08:41 <m0nkfish> lol
12:08:41 <lambdabot>   You are inside a building, a well house for a large spring.  There are some...
12:08:44 <rwbarton> > get keys
12:08:46 <lambdabot>       Ambiguous occurrence `get'
12:08:46 <lambdabot>      It could refer to either `L.get', defin...
12:08:52 <mauke> foiled!
12:08:52 <Olathe> > enter
12:08:53 <rwbarton> > L.get keys
12:08:55 <lambdabot>   You are inside a building, a well house for a large spring.  There are some...
12:08:55 <lambdabot>   "Taken."
12:08:58 <gwern> dcoutts: cabal install yields 'setup: can't find source for module Paths_filestore' during the doc build
12:08:59 <Olathe> > enter
12:09:00 <lambdabot>   You are inside a building, a well house for a large spring.  There are some...
12:09:02 <Gracenotes> psaw.
12:09:15 <Olathe> How do I enter the well ?
12:09:26 <Gracenotes> > 123456 `divMod` 10 -- m0nkfish
12:09:28 <lambdabot>   (12345,6)
12:09:37 <dcoutts> gwern: ok, can you file a ticket with the details to reproduce please
12:09:44 <paper_cc> > let a `digit` n = a `div` (10 ^ n) `mod` 10 in 123456 `digit` 3
12:09:46 <lambdabot>   3
12:09:54 <paper_cc> m0nkfish: ^^
12:10:12 <Gracenotes> m0nkfish: still, generally (map digitToInt . show) is used, as far as I've seen
12:10:22 <m0nkfish> hmm
12:10:46 <m0nkfish> what does the in keyword do?
12:10:57 <Zao> > let foo = 2 in foo
12:11:00 <Gracenotes> it's reasonably quick-ish. Still, a divMod solution can be implemented if you feel like it, or something using div and mod like paper_cc had
12:11:03 <mauke> ends a block of definitions started with let
12:11:03 <Olathe> It separates the let stuff from the stuff you're using it in.
12:11:03 <lambdabot>   2
12:11:26 <glguy> > let digits = unfoldr (\n -> if n == 0 then Nothing else Just (let (a,b) = divMod n 10 in (b,a))) in digits  123456
12:11:27 <gwern> dcoutts: this is with roughly darcs cabal-install & cabal. could cabal 1.7x have fixes cabal-install's 1.6 doesn't?
12:11:28 <lambdabot>   [6,5,4,3,2,1]
12:11:32 <Zao> `do' blocks are silly as they let you have lets floating around.
12:11:48 <dcoutts> gwern: it could do
12:12:08 <dcoutts> gwern: but I can't think of anything specific. So long as I can reproduce the problem it's ok.
12:12:12 <Gracenotes> in do blocks and ghci, lets are implicitly "let x = y in [the rest of the session/do block]"
12:12:50 <glguy> it seems like a bit of a shame that showIntAtBase isn't more polymorphic
12:12:52 <glguy> :t showIntAtBase
12:12:54 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
12:13:15 <gwern> dcoutts: can you?
12:13:25 <SamB> glguy: what's wrong with it?
12:13:29 <paper_cc> glguy: it should be a -> (Int -> b) -> a -> [b] -> [b]?
12:13:31 <SamB> oh, the String bit ?
12:13:39 <dcoutts> gwern: I don't have time right now, that's why I want all the details recoded in a ticket.
12:13:40 <glguy> paper_cc, yeah
12:14:13 <SamB> glguy: that at least is practical ...
12:14:24 <paper_cc> @hoogle (a -> b, a -> b) -> (a, a) -> (b, b)
12:14:24 <lambdabot> No results found
12:14:35 <glguy> paper_cc, you can use Arrow combinators for that
12:14:44 <glguy> ***, iirc
12:14:52 <paper_cc> o_O
12:14:52 <Olathe> > showIntAtBase 5 intToDigit 16 "zomg"
12:14:54 <lambdabot>   "31zomg"
12:14:56 <paper_cc> @ty (***)
12:14:57 <trofi> :t (***)
12:14:58 <glguy> > succ *** pred $ (5,7)
12:14:59 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:14:59 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:15:00 <lambdabot>   (6,6)
12:15:04 <Taejo> ADD 1 TO COBOL GIVING COBOL
12:15:24 <paper_cc> Taejo: COBOL == undefined?
12:15:33 <Taejo> paper_cc: COBOL++
12:15:50 <Taejo> karmabot: COBOL--
12:15:50 <Taejo> @karma COBOL
12:15:51 <lambdabot> COBOL has a karma of 0
12:16:10 <mauke> preflex: karma COBOL
12:16:10 <preflex>  karma for COBOL: 4
12:16:25 <wli> I forgot how I came up with a closed form for the sum of F_{3n}
12:16:33 <paper_cc> @ty uncurry (**)
12:16:35 <lambdabot> forall a. (Floating a) => (a, a) -> a
12:16:39 <paper_cc> @ty uncurry (***)
12:16:41 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
12:16:55 <glguy> SamB, and the name is wrong, should be: showsIntAtBase :)
12:17:11 <paper_cc> @ty uncurry (***) $ uncurry (*) *** uncurry (+)
12:17:13 <lambdabot>     Couldn't match expected type `(b, c)'
12:17:13 <lambdabot>            against inferred type `(a, a) -> a'
12:17:13 <lambdabot>     In the first argument of `(***)', namely `uncurry (*)'
12:17:23 <paper_cc> @ty uncurry (*) *** uncurry (+)
12:17:25 <lambdabot> forall a a1. (Num a1, Num a) => ((a, a), (a1, a1)) -> (a, a1)
12:17:32 <SamB> glguy: most of the showFoo functions share that, er, aspect of name
12:17:38 <SamB> showChar, showString ...
12:17:49 <paper_cc> @ty uncurry (***) $ (+) *** (*)
12:17:51 <lambdabot>     Couldn't match expected type `(b, c)'
12:17:51 <lambdabot>            against inferred type `a -> a -> a'
12:17:51 <lambdabot>     In the first argument of `(***)', namely `(+)'
12:17:54 <SamB> also they don't show things
12:17:57 <Newb> Hello, I was wondering if I could be asissted with programming here?
12:18:00 <SamB> they just convert them to ShowS
12:18:06 <glguy> SamB, I'm not listing the other mistakes, just my annoyance with that one function :)
12:18:08 <SamB> Newb: what language ?
12:18:26 <paper_cc> @ty uncurry (***) . ((+) *** (*))
12:18:28 <lambdabot> forall b b'. (Num b', Num b) => (b, b') -> (b, b') -> (b, b')
12:18:37 <paper_cc> pumpkin_: ^^
12:18:58 <L11> is there a function to grab the first letter in a String?
12:19:12 <paper_cc> @ty \f g -> uncurry (***) . (f *** g)
12:19:14 <lambdabot> forall (a :: * -> * -> *) b c b' c' b1 b'1. (Arrow a) => (b1 -> a b c) -> (b'1 -> a b' c') -> (b1, b'1) -> a (b, b') (c, c')
12:19:38 <rwbarton> L11: first letter as opposed to, say, digit?
12:19:46 <Newb> Eng
12:19:48 <Olathe> L11: head
12:19:51 <Olathe> > head "zomg"
12:19:53 <lambdabot>   'z'
12:19:54 * SamB suggests that Newb refrain from PMing people
12:20:19 <Newb> Im sorry.
12:20:32 <SamB> also, I meant what programming language ;-)
12:20:34 <L11> Olathe: I tried that and it threw an error. Lemme give it another shot
12:20:54 <Newb> Ah, Im new to this stuff, Html, Javascript mainly.
12:21:07 <glguy> Newb, feel free to ask your Haskell question in channel. If someone wants to help they will answer
12:21:34 <Newb> I was just intreseted in programming. and all i wanted to Know how I should Start off.
12:21:44 <int80_h> I have revised my Project Euler code...all the way at the bottom it is...
12:21:47 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1270
12:21:49 <gwern> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/494
12:22:02 <int80_h> If someone could have a look and tell me why it's an endless loop...
12:22:39 <Olathe> Which function and arguments are an endless loop ?
12:22:43 <int80_h> Newb: http://www.learnyouahaskell.com
12:23:25 <int80_h> Olathe: specialSieve I think. I will paste example usage
12:24:08 <int80_h> Olathe: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1271
12:24:46 <int80_h> I need to be able to find the length of the list made when I do specialSieve 50000000
12:25:01 <int80_h> smaller numbers work, like 10000
12:25:08 <wli> dolio: (F_{3n+6}-3F_{3n+3}-2)/4
12:25:33 <int80_h> okay maybe it's not an endless loop. But after waiting 12 hours it still didn't finish with the input of 50 million
12:25:42 <dolio> Nice.
12:26:11 <Botje> int80_h: which euler problem is it?
12:26:19 <wli> F_{3n+6}-3F_{3n+3} <= 16M + 2 or some such.
12:26:23 <Gracenotes> int80_h: your primality test might be a bit too naive. Check out Wikipedia about [[primality test]]
12:26:27 <int80_h> Botje: 216
12:26:35 <Botje> oh
12:26:38 <Botje> haven't done that one yet
12:26:38 <Gracenotes> it's a nice example of corecursion, but it's not terribly efficient
12:26:45 * Botje looks
12:27:03 <int80_h> Gracenotes: okay
12:27:40 <dolio> His prime test isn't that bad, actually. You could do worse.
12:27:49 <paper_cc> @pl \f g x y -> f (g x y)
12:27:50 <lambdabot> (.) . (.)
12:27:54 <dolio> 50 million might be pushing it, though, I suppose.
12:28:06 <wli> Where's int80's prime test?
12:28:14 <rwbarton> even 500 thousand is exceeding my patience
12:28:20 <athos> @hoogle isDigit
12:28:21 <lambdabot> Data.Char isDigit :: Char -> Bool
12:28:23 <Botje> int80_h: for n = 50M your isPrime has to check all the way up to 100_000
12:28:27 <paper_cc> @ty ((.).(.)) (***) (***) (+) (*)
12:28:28 <lambdabot> forall b' c' b b'1. (Num b'1, Num b) => (b' -> c') -> ((b, b'1), b') -> ((b -> b, b'1 -> b'1), c')
12:28:34 <Botje> probably more, but bleh
12:28:37 <Botje> it's too much :)
12:28:40 <dolio> wli: It's the usual mutally defined list of primes and trial division up to sqrt n.
12:28:46 <Botje> oh wait
12:28:50 <Olathe> int80_h: Did you test it with smaller inputs ?
12:28:53 <Botje> for n = 50M you have to check 50M primes
12:29:00 <int80_h> Olathe: yes it works with 10000
12:29:01 <Botje> brute force is not an option here :)
12:29:14 <Olathe> int80_h: About where does it stop working ?
12:29:21 <Botje> random guess: look up the miller-rabin primality test.
12:29:22 <wli> Doing the real sieve is a lot faster.
12:29:39 <wli> All you really need is a priority queue.
12:29:56 <int80_h> I tried S of E but when I had trouble augustss provided me with something he said was "simpler"
12:30:19 <dolio> Trial division with a list is, in my experience, faster than a filter sieve, for example.
12:30:24 <int80_h> Olathe: I will play around with it and tel you where I think it fails
12:30:24 <dolio> Which might be what you try first.
12:30:27 <rwbarton> right, this algorithm is O(n^2 / log(n)^k) for some k, probably k = 2
12:31:39 <int80_h> I just tried 100,00 and it's still going
12:31:40 <wli> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1257#a1257 <-- not ONeillPrimes (or even close) but decent
12:31:46 <int80_h> I mean 100,000
12:32:51 <int80_h> oh I haven't learned monads yet. Using them would belay the point of this exercise
12:32:54 <wli> You can golf it down to a one-liner with mapAccumL etc.
12:32:55 <rwbarton> Even if you were magically provided with a list of primes less than 100M, that wouldn't help significantly.
12:33:44 <int80_h> Olathe: I have to say this code fails at 100,000
12:34:30 <rwbarton> There are roughly n / log n results k which are prime and for each of them you'll have to test all the roughly n / log n primes less than sqrt(2k^2-1).
12:34:59 <wli> I'd try something like let isect :: Ord t => [t] -> [t] -> [t] ; isect ~(x:xs) ~(y:ys) = case x `compare` y of { EQ -> x : isect xs ys ; LT -> isect xs (y:ys) ; GT -> isect (x:xs) ys } in isect primes [2*n*n-1|n<-[1..]]
12:35:09 <int80_h> rwbarton: yeah I'm looking at other primality tests on wikipedia
12:35:15 <athos> > "a" * 2
12:35:17 <lambdabot>       No instance for (Num [Char])
12:35:17 <lambdabot>        arising from the literal `2' at <in...
12:35:27 <rwbarton> wli: Good luck generating (or traversing) a list of less than 2*(50*10^6)^2.
12:35:29 <athos> heh :>
12:35:32 <rwbarton> *list of primes
12:36:00 <wli> What are we searching for that needs to be up to 50M?
12:36:18 <rwbarton> wli: we want primes of the form 2*n^2-1, n in [1..50M]
12:36:22 <int80_h> wli : primes with the property 2n^2+1
12:36:28 <Gracenotes> so about 10^15
12:36:37 <wli> rwbarton: The largest among those?
12:36:43 <rwbarton> wli: The number of them
12:37:00 <Olathe> > 2*50000000^2+1
12:37:01 <lambdabot>   5000000000000001
12:37:11 <int80_h> so this is an exercise in efficient primality tests
12:37:26 <rwbarton> Olathe: Good news--it's actually only 2*50000000^2-1! :)
12:37:28 <dolio> Sieving in a mutable array is probably the way to go.
12:37:33 <Olathe> Excellent !
12:37:51 <int80_h> mutable: So I *need* monads?
12:38:02 <wli> No, you don't need monads.
12:38:23 <rwbarton> int80_h: length . specialSieve $ 500000 finally finished for me, ~12 minutes, so 50 million would be around 120000 minutes :)
12:38:44 <Gracenotes> hey dudes, can someone hit me up with a monad?
12:38:46 <Olathe> > div 120000 60
12:38:48 <lambdabot>   2000
12:38:51 <Olathe> > div 2000 24
12:38:53 <lambdabot>   83
12:38:59 <rwbarton> @google 120000 minutes in days
12:38:59 <Olathe> Only 84 days or so !
12:39:00 <lambdabot> No Result Found.
12:39:08 <Olathe> Bah !
12:39:13 <int80_h> rwbarton: the code I gave you would actually finish? I ran it for 12 hours on lemmih's server and it never finished
12:39:15 <Olathe> We have no need for Google ! We have Haskell !
12:39:26 <rwbarton> int80_h: for 500000, not 50000000 (two fewer zeros)
12:39:37 <int80_h> rwbarton: ooooh
12:39:47 <dolio> Don't bogart the monad.
12:40:09 <Gracenotes> > logBase 10 $ 2*(50000000^2)
12:40:11 <lambdabot>   15.698970004336019
12:40:25 <int80_h> okay I don't know how to use mutable arrays without monads
12:40:25 <rwbarton> int80_h: oh also, I wasn't running it in ghci, you can add another huge factor if you want to do that :)
12:40:37 <wli> 2*n^2-1 is an odd prime if it is prime at all, so when p = 2*n^2-1 one has (p+1)/2 = n^2
12:40:45 <int80_h> rwbarton: heh yeah I was running it in ghci
12:40:51 <Gracenotes> what, a mutably array with 10^15 elements? :)
12:40:54 <mauke> int80_h: !
12:40:55 <Gracenotes> e
12:41:14 <rwbarton> int80_h: I don't think you need mutable arrays for this problem, just a more efficient primality test, like miller-rabin probably
12:41:14 <athos> :t join
12:41:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:41:17 <int80_h> dolio suggested I should sieve with a mutable array. was he having fun with me?
12:41:32 <int80_h> miller-rabin, okay
12:41:38 <athos> > join ["F"]
12:41:40 <lambdabot>   "F"
12:41:48 <Olathe> int80_h: No, those are decent for true sieves.
12:41:52 <dolio> Oh, wait, are you going up to 2*50M^2 - 1?
12:41:57 <dolio> In that case, no, don't use an array.
12:41:58 <chipdude> > join ["me","for","lunch"]
12:41:59 <lambdabot>   "meforlunch"
12:42:01 <hackage> Uploaded to hackage: data-spacepart 0.1.1
12:42:01 <hackage> Uploaded to hackage: PerfectHash 0.1.2
12:42:01 <hackage> Uploaded to hackage: BASIC 0.1.3.0
12:42:01 <hackage> Uploaded to hackage: llvm 0.6.4.0
12:42:01 <hackage> Uploaded to hackage: xhb 0.1.2009.2.8
12:42:03 <athos> hehe
12:42:06 <Gracenotes> whoa there
12:42:09 <Olathe> You can do it in blocks.
12:42:18 <Olathe> I think primegen does that somehow.
12:42:21 <athos> @index join
12:42:21 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:42:28 <athos> Okay.
12:42:30 <dolio> I was thinking primes up to 50 million for some reason.
12:42:36 <Gracenotes> join is probably most useful for the function application monad
12:42:42 <dolio> Although that shouldn't take that long to compute even for the list version.
12:43:18 <BONUS> i wish Monad was a subclass of Functor and >>= and join were mutually defined
12:43:29 <Gracenotes> join func == \x -> func x x
12:43:53 <BONUS> i.e. join x = x >>= id and x >>= f = join $ fmap f x
12:43:55 <rwbarton> I used to use join instead of concat all the time
12:44:20 <athos> @index nub
12:44:21 <lambdabot> Data.List
12:44:26 <redditbot> Shall I improve your haskell source [y/n]?
12:44:26 <redditbot> Utrecht Summer School 2009: Applied Functional Programming
12:44:26 <redditbot> darcs advanced revision control system: darcs weekly news #16
12:44:33 <Gracenotes> wat.
12:44:41 <shapr> watt?
12:44:54 <dolio> British thermal unit.
12:45:01 <int80_h> okay I realize why I disregarded Miller-Rabin earlier
12:45:05 <shapr> Associations for free!
12:45:12 <Olathe> redditbot: y
12:45:18 <athos> Lol.
12:45:20 <shapr> hackage: w00! new BASIC and llvm packages!
12:45:40 * shapr upgrades his local installation
12:45:41 <rwbarton> shapr: two great tastes that go great together
12:45:47 <shapr> Just like.. well, yeah.
12:45:49 <dolio> That's 3 versions just today!
12:46:06 <int80_h> I need to find some a such that a^d= 1 `mod` n
12:46:11 <int80_h> or ...
12:46:39 <rwbarton> int80_h: that's what the miller-rabin test builds for you, kind of
12:46:58 <int80_h> a^2rd = -1 `mod` n
12:47:15 <Gracenotes> there's also psuedocode in the Wikipedia article
12:47:19 <int80_h> now, for large numbers finding a seems to be inefficient which leads me to believe I don't understand this at all
12:47:34 <int80_h> gracenotes: oh okay I'll keep looking
12:47:40 <rwbarton> int80_h: I suggest reading the algorithm first and then the explanation
12:48:35 <int80_h> rwbarton: oh that's the other thing...it only tells you that it's "probably prime"
12:48:37 <dolio> http://www.polyomino.f2s.com/david/haskell/numbertheory.html
12:48:57 <int80_h> is "probably prime" good enough here?
12:49:11 <rwbarton> int80_h: probably :)
12:49:17 <int80_h> :)
12:49:18 <Gracenotes> Miller-Rabin should be 100% correct, no?
12:49:18 <dolio> Just do it multiple times if you're paranoid.
12:49:37 <int80_h> dolio:not paranoid, but there's only one correct answer to this problem
12:49:44 <dolio> :)
12:49:54 <int80_h> saying my answer is "probably x" won't get me a cookie :)
12:49:59 <Gracenotes> unless I misunderstand it, it's based on probabilistic processes, but yields the correct result
12:50:06 <somnolence> how do you break an integer up into a list?
12:50:10 <jiyunatori> hi people. I'm currently poking a mysql database with HDBC, and I get strings such as 'SqlString "les r\232gles de"'. As you can see there are accentuated characters coded as UTF8. when I turn that into a string and try to print it, I get the "\232" kind of display rather than the actual character. Is there a way to display this properly ?
12:50:14 <Gracenotes> ah. "Its original version, due to Gary L. Miller, is deterministic, but the determinism relies on the unproven generalized Riemann hypothesis"
12:50:16 <Olathe> somnolence: A list of what ?
12:50:24 <int80_h> somnolence: use show :)
12:50:27 <wli> I forget whether fewer numbers are examined by filter isPrime [2*n*n-1 | n <-[1..]] or [p | p <- primes, odd p, isSquare ((p + 1) `div` 2)]
12:50:35 <somnolence> k
12:50:40 <Gracenotes> int80_h: so if the answer is correc,t you've proved the Riemann hypothesis! Congrats! :P
12:50:56 <int80_h> Gracenotes: will *that* get me a cookie?
12:50:58 <dolio> "the Rabin test involves selecting random bases b and checking that p is a strong pseudoprime to that base if p passes the strong pseudoprime test for k bases, the probability of a false positive is 4^-k."
12:51:14 <rwbarton> int80_h: It will get you 1000000 / (price of a cookie in $) cookies
12:51:38 <Olathe> @paste
12:51:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:51:41 <Olathe> Bah.
12:52:12 <rwbarton> jiyunatori: are you print-int the string, or putStr-ing it?
12:52:35 <dolio> Isn't there some new (like, few years old) fangled polynomial time prime test?
12:52:49 <Gracenotes> rwbarton: I assume there that the price of a cookie is less than a dollar :)
12:52:54 <jiyunatori> I am putStr-ing it. but actually, my final intent is to write it to a file
12:53:01 <dolio> Use a probabilistic algorithm to weed out the simple non-primes and then use the more expensive test to ensure you're right.
12:53:02 <rwbarton> dolio: Yeah, ~5 years ago
12:53:04 <blork> dolio: http://en.wikipedia.org/wiki/AKS_primality_test
12:53:08 <wli> p mod 4 can be smoked out, I think. 2*(4*k)^2-1 = 3 mod 4, 2*(4*k+1)^2 - 1 = 1 mod 4, 2(4*k+2)^2 - 1 = 3 mod 4, 2*(4*k+3)^2 - 1 = 1 mod 4, so there's that much.
12:53:33 <blork> @pl mf m = (>>= maybe (fail m) return)
12:53:34 <lambdabot> mf = (=<<) . flip maybe return . fail
12:54:06 <wli> 2|n then 2*n^2-1 = 3 mod 4, otherwise 2*n^2-1 = 1 mod 4.
12:54:29 <rwbarton> int80_h: typically you just run the test enough times until the probability of a false positive is less than the probability in your compiler/hardware/etc.
12:54:36 <Gracenotes> hm.. it doesn't seem we have a "primes" package on Haskell
12:54:41 <rwbarton> *probability of a bug
12:54:44 <Gracenotes> or anything like it
12:54:57 <Gracenotes> er, Hackage
12:55:05 <aeolist> can we have F \omega in haskell? or is there no way to achieve F \omega with the current tools
12:55:09 <Gracenotes> maybe some common algorithms could be collected
12:55:18 <wli> Most of these have ways to smoke out the answer with paper and pencil, provided you're patient enough to do arithmetic by hand with some vaguely large numbers.
12:55:41 <asgaroth> Gracenotes: There's this which contains some prime-related functions: http://hackage.haskell.org/packages/archive/Crypto/4.1.0/doc/html/Codec-Encryption-RSA-NumberTheory.html
12:56:25 <wli> There is actually something special about odd primes where (p+1)/2 is a perfect square.
12:56:28 <Gracenotes> aha
12:56:30 <Gracenotes> test <- mapM rabinMillerPrimalityTest $ take 5 $ repeat a
12:56:57 <Gracenotes> so Rabin-Miller has been implemented, at least.
12:57:00 <athos> > let s = ["f", "o", "o"] in [ [x, " ", y] | x <- s, y <- s ]
12:57:02 <lambdabot>   [["f"," ","f"],["f"," ","o"],["f"," ","o"],["o"," ","f"],["o"," ","o"],["o"...
12:57:48 <jiyunatori> rwbarton: when I replace putStrLn by print, it "double escapes" : \232 turns to \\232
12:57:53 <Gracenotes> isPrime :: Integer -> IO Bool, due to randomness
12:58:23 <Gracenotes> the package also implements a naive divisor-checking algorithm. But nothing else, it seems
12:58:25 <blackdog> i'd like to build my tests specified in the cabal file, but not install them onto the filesystem... is there a standard way of doing that?
12:58:31 <rwbarton> jiyunatori: OK, so your string actually contains the characters \ 2 3 2
12:58:46 <athos> is there a cartesian product function in prelude, or Data.List
12:58:47 <athos> ?
12:58:50 <somnolence> show(1024)
12:58:54 <somnolence> >show(1024)
12:59:09 <somnolence> > map digitToInt show(1024)
12:59:10 <ddarius> > liftM2 (,) [1..3] "abc"
12:59:10 <lambdabot>   Couldn't match expected type `[Char]'
12:59:11 <Gracenotes> athos: list comprehensions
12:59:11 <ziman> > liftM2 (,) [1..3] ['a'..'d']
12:59:12 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
12:59:13 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(2,'a'),(2,'b'),(2,'c'),(2,'d'),(3,'a'),(3...
12:59:15 <dons> gwern: are you interested in help set up a voting system for hte logos?
12:59:16 <jiyunatori> rwbarton: ok then, I guess i'll have to write a clean up function for the strings ...
12:59:18 <somnolence> how can I fix this error?
12:59:30 <somnolence> > map digitToInt show(1024)
12:59:31 <lambdabot>   Couldn't match expected type `[Char]'
12:59:33 <rwbarton> jiyunatori: and you're sure that those characters aren't actually in the table
12:59:34 <Gracenotes> oh, yeah, that works nicely x.x
12:59:42 <trofi_> @pl (\(c, (n, p) -> (n, c * p)))
12:59:42 <lambdabot> (line 1, column 14):
12:59:42 <lambdabot> unexpected "-"
12:59:42 <lambdabot> expecting operator, "," or ")"
12:59:56 <blork> somnolence: map digitToInt (show 1024)
13:00:30 <somnolence> is there any
13:00:32 <somnolence> digitToInteger
13:00:35 <somnolence> equivilent function?
13:00:40 <trofi_> @pl \(c, (n, p)) -> (n, c * p)
13:00:41 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip ((.) . (,)) . (*))
13:00:46 <ziman> > digitToInt '9'
13:00:48 <lambdabot>   9
13:00:51 <asgaroth> somnolence: fromIntegral . digitToInt
13:00:53 <athos> Gracenotes: yeah, but i don't know in advance if it'll be e.g. RxR, or RxRxRxRxR. what i do for some set m = S^2 is [ [x, " ", y] | x <- m, y <- m]
13:01:04 <athos> Gracenotes: but i don't know how to generalize this for some set S^n
13:01:04 <Olathe> somnolence: digitToInteger :: Char -> Integer; digitToInteger = fromIntegral . digitToInt
13:01:13 <jiyunatori> rwbarton: that's a possibility ; it's actually a local import of a foreign database. So I may have screwed up with unicode during the backup.
13:01:15 <Gracenotes> athos: then you're not seeking to make a tuple?
13:01:25 <Olathe> somnolence: Or, actually, just toInteger . digitToInt
13:01:36 <Olathe> @type toInteger . digitToInt
13:01:38 <lambdabot> Char -> Integer
13:01:42 <athos> Gracenotes: nope, i explictely want the form [x, " ", y, " ", ..., z]
13:01:50 <rwbarton> jiyunatori: I feel that you shouldn't have to parse the strings yourself.  But there may be some magic incantation needed to get the connection into UTF-8 mode or whatever
13:01:52 <somnolence> > map toInteger . digitToInt (show 1024)
13:01:54 <lambdabot>   Couldn't match expected type `Char' against inferred type `String'
13:01:58 <somnolence> ^
13:02:04 <athos> explicitely
13:02:08 <rwbarton> > map (intersperse ' ') (replicateM 3 "abc")
13:02:10 <lambdabot>   ["a a a","a a b","a a c","a b a","a b b","a b c","a c a","a c b","a c c","b...
13:02:17 <asgaroth> somnolence: map (toInteger . digitToInt) $ show 1024
13:02:23 <doserj> > map (toInteger . digitToInt) (show 1024)
13:02:24 <lambdabot>   [1,0,2,4]
13:03:15 <Gracenotes> > map (intersperse " ") (replicateM 3 ["a", "b", "c"])
13:03:17 <lambdabot>   [["a"," ","a"," ","a"],["a"," ","a"," ","b"],["a"," ","a"," ","c"],["a"," "...
13:03:36 <m0nkfish> > 1
13:03:38 <lambdabot>   1
13:03:41 <m0nkfish> cool i did it
13:03:52 <Gracenotes> > let f = map (intersperse " ") . replicateM 3 . map return in f "abc"
13:03:54 <lambdabot>   [["a"," ","a"," ","a"],["a"," ","a"," ","b"],["a"," ","a"," ","c"],["a"," "...
13:03:57 <wli> Quadratic reciprocity may come into it.
13:04:05 <BONUS> > foldl ((+) . (*10)) 0 [1,2,3,4]
13:04:07 <lambdabot>   1234
13:04:40 <rwbarton> I think the way you're intended to do this problem is an adaptation of the usual sieve where you solve the congruence 2n^2-1 = 0 (mod p) for each p rather than just marking the multiples of p
13:04:53 <Fredrik_> > 1 + 1
13:04:55 <lambdabot>   2
13:05:01 <Fredrik_> cool :)
13:05:06 <Fredrik_> > [1..100]
13:05:06 <athos> rwbarton: thanks, that'll be useful :)
13:05:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:05:10 <paper_cc> > let 1 + 1 = 3 in 1 + 1
13:05:12 <lambdabot>   3
13:05:20 <asgaroth> > take 10 $ fix ((0:) . scanl (+) 1)
13:05:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
13:06:53 <Fredrik_> > putstr "hello"
13:07:00 <lambdabot>   Not in scope: `putstr'
13:07:07 <Fredrik_> > putStr "hello"
13:07:07 <blork> paper_cc: i'll call all my functions (+) from now on
13:07:09 <lambdabot>   * Exception: "<IO ()>"
13:07:18 <Gracenotes> > let f = map (intersperse " ") . (replicateM =<< length) . map return in f "abc" --to simplify it further
13:07:19 <lambdabot>   [["a"," ","a"," ","a"],["a"," ","a"," ","b"],["a"," ","a"," ","c"],["a"," "...
13:07:21 <newsham> > ([1,8,27,64]...)
13:07:23 <lambdabot>   [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832...
13:07:46 <blork> :t (...)
13:07:48 <lambdabot> forall a. (Num a) => [a] -> [a]
13:08:03 <asgaroth> @src (...)
13:08:03 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:08:03 <jiyunatori> rwbarton: at least the strings are well displayed when poking the database with mysql or with phpmyadmin. so I guess all is well inside the db
13:08:09 <Gracenotes> > 6^3
13:08:10 <lambdabot>   216
13:08:16 <newsham> blork: http://codepad.org/WDXeV59b
13:08:18 <paper_cc> :t ..
13:08:20 <lambdabot> parse error on input `..'
13:08:25 <paper_cc> :t (..)
13:08:27 <lambdabot> parse error on input `..'
13:08:42 <paper_cc> > [1,2,3]...
13:08:44 <lambdabot>   <no location info>: parse error on input `;'
13:08:52 <newsham> > ([1,2]...)
13:08:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:08:57 <blork> I always thought operators had to be kind *->*->* at least
13:09:19 <newsham> > ([9,16,25]...)
13:09:21 <lambdabot>   [9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,52...
13:09:25 <mmorrow> :k (->)
13:09:27 <lambdabot> ?? -> ? -> *
13:09:37 <dolio> Value-level operators don't have kinds.
13:09:49 <dolio> But, postfix operators like that are a GHC extension.
13:10:27 <mmorrow> :k Either
13:10:29 <lambdabot> * -> * -> *
13:11:47 <blork> dolio: i stand corrected. "have type unifiable with a->b->c" then
13:11:57 <Heffalump> are kind aliases possible?
13:12:14 <mmorrow> Heffalump: how do you mean?
13:12:29 <Heffalump> kind x = (* -> * -> * -> * -> *) -> *
13:12:35 <mmorrow> oh
13:12:43 * Heffalump assumes they don't exist right now
13:12:51 <mmorrow> yeah, i don't think so
13:12:56 * dancor finally sees that (f . g) x y is f (g x) y
13:13:08 <dolio> There's no reason why you couldn't have them.
13:13:14 <ddarius> > (f . g) x y
13:13:15 <lambdabot>   Add a type signature
13:13:19 <ddarius> > (f . g) x y :: Expr
13:13:21 <lambdabot>   Add a type signature
13:13:41 <mmorrow> i guess they could be useful if you're having to write excessive kind sigs
13:13:53 <dancor> @unpl \ x y -> f . g
13:13:54 <lambdabot> \ x y c -> f (g c)
13:14:02 <wli> There's something special about such primes that you're supposed to use.
13:14:05 <ddarius> :k RWS
13:14:07 <lambdabot> * -> * -> * -> * -> *
13:14:12 <ddarius> :k RWST
13:14:13 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
13:14:51 <dancor> @unpl \ x y -> (f . g) x y
13:14:51 <lambdabot> \ x y -> f (g x) y
13:15:02 <dancor> @unpl \ x y z -> (f . g) x y z
13:15:02 <lambdabot> \ x y z -> f (g x) y z
13:15:07 <mmorrow> , [|data A (a :: * -> ((* -> *) -> *) -> *) (b :: * -> *)|]
13:15:09 <lunabot>  luna: parse error on input `data'
13:15:14 <mmorrow> , [d|data A (a :: * -> ((* -> *) -> *) -> *) (b :: * -> *)|]
13:15:15 <lunabot>  luna: `A' has no constructors (-XEmptyDataDecls permits this)
13:15:53 <rwbarton> , [d|data A (a :: * -> ((* -> *) -> *) -> *) (b :: * -> *) = A |]
13:15:55 <lunabot>  DataD [] A [a_0,b_1] [NormalC A []] []
13:16:15 <dancor> it's so obvi now bc (f . g) x is f (g x) of course.  something about the way extra variables come in to play when tacked on the end is still fundamentally unclear to me
13:16:38 <sbahra> @fact symbols
13:16:39 <lambdabot> symbols: "âŠ¤ âŠ¥ Î» Îµ Î· Î¹ âˆƒ âˆ€ Â¬ âˆˆ âˆ‰ âˆ‹ âˆŒ âˆ§ âˆ¨ âŠ• â†‘ â†“ â‡’ â‡ â‡” âŠ¢ âŠ¬ âŠ¨ âŠ­ âˆ˜ âˆª âˆ© âˆ´ âˆµ â‰¡ âŠ‚ âŠƒ âŠ» âŠ¼ â‹€ â‹ âŠ² âŠ³ âŸ¦âŸ§"
13:16:43 <dancor> but maybe soon i'll understand (.) . (.) etc
13:16:46 <rwbarton> , [d|data A (a :: * -> ((* -> *) -> *) -> *) (b :: * -> *) where F :: A a b |]
13:16:47 <lunabot>  luna: Illegal generalised algebraic data declaration for `A'
13:16:55 <Gracenotes> @src (.)
13:16:55 <lambdabot> (f . g) x = f (g x)
13:17:08 <rwbarton> , [d|data Foo a where I :: Foo Int|]
13:17:09 <ddarius> dancor: (f . g) x y is ((f . g) x) y, the y doesn't "come into play" at all.  You are just reducing the expression in parentheses.
13:17:09 <lunabot>  luna: Illegal generalised algebraic data declaration for `Foo'
13:17:15 <sbahra> What's a standard name for {âŠ¤, âŠ¥} in sentential logic?
13:17:35 <sbahra> Semantic value doesn't seem very accurate.
13:17:48 <dancor> ddarius: yeah i guess it's just the fact of function application being left-associative
13:17:56 <ddarius> sbahra: Do you mean for that set in particular or in general?
13:18:03 <dancor> that becomes difficult to internalize in cases like (.) . (.)
13:18:04 <ddarius> sbahra: And there aren't standard names.
13:18:09 <sbahra> ddarius, both would be good.
13:18:27 <blork> @unpl (.) . (.)
13:18:28 <lambdabot> (\ i b c f -> i (b c f))
13:18:37 <somnolence> is there anyway
13:18:44 <somnolence> to return to print, instead of only being able to print once in the main statement?
13:18:52 <mmorrow> , [d|data A (a :: * -> ((* -> *) -> *) -> *) (b :: * -> *)|]
13:18:53 <lunabot>  luna: `A' has no constructors (-XEmptyDataDecls permits this)
13:18:55 <sbahra> ddarius, well, the sentence I'm using it in is, "Semantic evaluation through interpretation is done by fixing {âŠ¤, âŠ¥} to variables. Operators are a mapping from {âŠ¤, âŠ¥} to {âŠ¤, âŠ¥}."
13:19:07 <mmorrow> gah, wrong extension
13:19:24 <sbahra> ddarius, or something along this line. I'm trying to make a clear distinction between meta-object language and object language.
13:20:16 <mmorrow> gah, wrong extension
13:20:18 <mmorrow> heh
13:20:19 <mmorrow> , [d|data A (a :: * -> ((* -> *) -> *) -> *) (b :: * -> *)|]
13:20:21 <lunabot>  DataD [] A [a_0,b_1] [] []
13:20:35 <sbahra> From x \memberof {\top, \bot} that is.
13:20:41 <mmorrow> TH needs kinds too
13:20:43 <rwbarton> mmorrow: that's kind of disturbing
13:20:55 <mmorrow> heh, it is
13:22:19 <ddarius> sbahra: Well, {true,false} is often referred to as 2, Î©, bool or occasionally B.  In the general case, I'd just refer to it as a set, at least in this context.
13:22:51 <sbahra> ddarius, thanks.
13:23:58 <athos> @pl \x -> ('f' `elem` x) || ('r' `elem` x)
13:23:59 <lambdabot> liftM2 (||) ('f' `elem`) ('r' `elem`)
13:26:32 <beelsebob> ('f' `elem`) <^(||)^> ('r' `elem`)
13:27:14 <athos> @hoogle replace
13:27:15 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
13:27:15 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
13:27:15 <lambdabot> Data.Array.Diff replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
13:27:19 <dancor> @pl \ f -> any . map f
13:27:20 <lambdabot> (any .) . map
13:27:34 <luqui> :t result
13:27:36 <lambdabot> Not in scope: `result'
13:27:42 <luqui> @let result = (.)
13:27:44 <lambdabot>  Defined.
13:27:59 <luqui> :t result any . map
13:28:01 <lambdabot>     Couldn't match expected type `a -> Bool'
13:28:01 <lambdabot>            against inferred type `[b]'
13:28:01 <lambdabot>     Probable cause: `map' is applied to too many arguments
13:28:30 <dancor> :t ((any .) . map) (\ y -> y `elem` x)
13:28:32 <lambdabot>     Couldn't match expected type `a -> Bool'
13:28:32 <lambdabot>            against inferred type `[b]'
13:28:32 <lambdabot>     Probable cause: `map' is applied to too many arguments
13:28:51 <luqui> :t result or . map
13:28:52 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:29:05 <ziman> :t result
13:29:07 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:30:25 <wli> 2*n^2-1 = p then 2*n^2 = 1 mod p, so 2^{-1} is a quadratic residue mod p
13:30:30 <dancor> :t \ x -> any (`elem` x)
13:30:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
13:30:42 <dancor> @pl \ x -> any (`elem` x)
13:30:43 <lambdabot> any . flip elem
13:31:17 <wli> Which also means 2 is a quadratic residue mod p.
13:32:19 <newsham> ?type and
13:32:21 <lambdabot> [Bool] -> Bool
13:32:34 <dancor> athos: so like this works for that i think:  (any . flip elem) x "fr"
13:33:13 <wli> So p = +/-1 mod 8
13:33:33 <dancor> i.e.  flip (any . flip elem) "fr"
13:35:03 <dancor> maybe someone will make a @pl/djinn/ai-from-the-Future that tries to shorten the code by adding lists into the mix
13:36:44 <athos> dancor: ah okay, thanks :)
13:36:45 <somnolence> how can I concatenate two lists into one list?
13:36:50 <Cale> somnolence: ++
13:36:53 <somnolence> k
13:36:55 <Cale> > [1,2,3] ++ [4,5]
13:36:56 <lambdabot>   [1,2,3,4,5]
13:37:07 <Cale> > "hello" ++ "world"
13:37:08 <lambdabot>   "helloworld"
13:37:59 <blork> @pl a >>= (:b)
13:37:59 <lambdabot> (: b) =<< a
13:38:10 <ddarius> > ['h', 'e', 'l', 'l', 'o'] ++ ['w', 'o', 'r', 'l', 'd']
13:38:12 <lambdabot>   "helloworld"
13:38:13 <Cale> @pl \a b -> a >>= (:b)
13:38:14 <lambdabot> (. flip (:)) . (>>=)
13:38:15 <blork> @pl f a b = a >>= (:b)
13:38:16 <lambdabot> f = (. flip (:)) . (>>=)
13:38:41 <blork> @pl s x y z = (x z) (y z)
13:38:42 <lambdabot> s = ap
13:39:14 <Olathe> @pl s a b c d = (a d) (b d) (c d)
13:39:15 <lambdabot> s = (ap .) . ap
13:39:26 <blork> is there an @sk for turning anything into a mess of ((ap const) const (ap ap)) etc
13:39:33 <Olathe> @pl s a b = (a b) (b a)
13:39:34 <lambdabot> s = ap ap (flip id)
13:39:48 <Olathe> @type let s a b = (a b) (b a) in s
13:39:48 <athos> hmm, i'm quite stuck at the moment, although i know the solution is sure not difficult: i've got a list of strings, like ["FRx", "UyB"] and i want to replace every x (which is a Char) with some string of length two (so it's not a char anymore), such that ["FRx", "UyB"] is transformed into ["FRab", "UcdB"]
13:39:49 <lambdabot>     Occurs check: cannot construct the infinite type:
13:39:49 <lambdabot>       t = (t -> t1 -> t2) -> t1
13:39:49 <lambdabot>     Probable cause: `b' is applied to too many arguments
13:40:07 <Olathe> @type ap ap (flip id)
13:40:09 <lambdabot>     Occurs check: cannot construct the infinite type:
13:40:09 <lambdabot>       m = (->) (m (a -> b) -> c)
13:40:09 <lambdabot>     Probable cause: `flip' is applied to too few arguments
13:40:12 <aeolist> can i make a type constructor constructor in haskell?
13:40:26 <pumpkin_> :o
13:40:32 <somnolence> how can I remove the first item of a list or select all but the first item from a list?
13:40:35 <pumpkin_> in TH maybe
13:40:39 <gnuvince_> somnolence: tail
13:40:41 <Olathe> somnolence: head, tail.
13:40:51 <BONUS> well yeah, just define a type consturctor that takes several parameters
13:40:52 <somnolence> > head [1,2,3,4]
13:40:54 <lambdabot>   1
13:40:58 <dancor> athos: you just want to do "x" -> "ab" and "y" -> "cd" on every element?
13:41:00 <BONUS> then when you partially apply it, it will return a constructor
13:41:02 <Olathe> > tail [1, 2, 3, 4]
13:41:03 <lambdabot>   [2,3,4]
13:41:06 <somnolence> k
13:41:25 <athos> dancor: yeah, every 'x' should be replaced with "ab", and every 'y' with "cd"
13:41:31 <BONUS> like Either a b = Left a | Right b, Either Int returns a type constructor that takes one type, which is what will be in the Right part
13:42:01 <hackage> Uploaded to hackage: BASIC 0.1.4.0
13:42:01 <hackage> Uploaded to hackage: zoneinfo 0.2
13:42:01 <hackage> Uploaded to hackage: PerfectHash 0.1.3
13:42:11 <dancor> athos: you could look at the subst function i wrote once http://dzl.no-ip.org:81/gitweb/?p=futil.git;a=blob;f=src/FUtil.hs
13:42:37 <athos> i know that's sounds strange and is rather a confession of failure (for my code) ;)
13:42:46 <blork> > z ["FRx", "UyB"]  where f 'x' = "ab"; f 'y' = "cd"; f x = [x]; z = map (concatMap f)
13:42:48 <lambdabot>   ["FRab","UcdB"]
13:43:15 <athos> thank you dancor and blork :)
13:44:25 <dancor> ya subst is easier if your from's are singletons
13:44:51 <dancor> err i mean such a function is simpler if it handles singletons specifically
13:45:19 * dancor talking
13:45:28 <wli> 2 is always a quadratic residue for prime 2*n^2-1 so if 2 = (+/-m)^2 mod p then +/-m*n may be a nontrivial square root of 1 mod p.
13:45:36 <BMeph> atho: PE #220? ;)
13:45:49 <BMeph> *athos: ^^
13:46:05 <athos> BMeph: no, an own project
13:46:18 <BMeph> athos: Okay. :)
13:46:28 <BMeph> athos: The cube thing? :)
13:47:06 <athos> BMeph: yes. but at the moment the code is quite ugly, i do rely too much on Strings
13:48:10 <athos> what i'm doing is to generate a set of moves from some "generators", where the generators are string like "F", "R", etc.
13:48:17 <gwern> @fact logic
13:48:18 <lambdabot> I know nothing about logic
13:48:59 <adimit> lol.
13:49:14 <wli> This is impossible for prime p so n, which is a square root of (p+1)/2, must be the inverse of a square root of 2.
13:49:30 <athos> but, i really dislike this approach because i run into problems like that i need such functions like the one above, because the inverse of "F" would be "F'", and so it's really ugly code
13:50:06 <athos> you should better not get to see my inverse :: String -> String function ;)
13:50:21 <dancor> athos: should probably be working with like [Symbol] then instead of [Char]?  idk
13:50:54 <dancor> where Symbol is of your own devising.  maybe type Symbol = String even
13:51:00 <trofi> > let (n % d) = 1%3 in d
13:51:01 <lambdabot>   <no location info>: Parse error in pattern
13:51:36 <trofi> is there Ratio (de) constructor? or i have to use numerator/denomnator explicitely?
13:52:05 <Gracenotes> eek, unsafe* functions are slowly invading the libraries! Even roman-numerals has an unsafeFromRoman :X
13:52:09 <dolio> > let n :% d = 1%3 in d
13:52:10 <lambdabot>   Not in scope: data constructor `:%'
13:52:11 <augustss> trofi: there is no accissible constructor
13:52:14 <dolio> It's hidden.
13:52:59 <trofi> why? is there any reason?
13:53:01 <wli> I guess you need to invert n in Z/(2n^2-1)Z and maybe find a square root of 2 in it.
13:53:03 <dancor> is there unsafelyBifurcatingCodebase
13:53:12 <trofi> > 1 :% 3
13:53:14 <lambdabot>   Not in scope: data constructor `:%'
13:53:17 <augustss> trofi: yes, because 1%3 == 2%6
13:53:23 <trofi> ah
13:53:33 <BMeph> athos: Yeah, sounds like you should separate your internal and external representations. :)
13:53:33 <athos> dancor: well, you're right, but i still find the String approach, even if it's now known as Symbol, quite ugly. but i couldn't come up with a better data structure
13:53:34 <wli> Or, rather, check that it's a square root of 2.
13:53:48 <dancor> trofi: so maybe make ratioToTup?
13:54:06 * rwbarton thinks functions with names unsafe* should actually be unsafe
13:54:22 <trofi> np with writing it myself, but i thought ... :]
13:54:25 <athos> but, i think i'll just use your advise, push things a lil bit forward and maybe one day i'll have a better representation for a move ;)
13:54:47 <BMeph> Gracenotes: When I see "unsafeFromRoman," I think of a pilum. ;)
13:54:56 <augustss> rwbarton: how unsafe?  launch missiles?
13:55:12 <Gracenotes> >.>
13:55:14 <senex1> is there an easy way of doing case-insensitive parsing with Parsec?  I want to do something like Â»string "abc"Â« which should also match "aBC" or "AbC"
13:55:23 <rwbarton> augustss: Strictly more unsafe than, say, fix. :)
13:55:39 <augustss> rwbarton: I agree
13:55:45 <dancor> athos: i don't know your problem but if you have vars F and inverses F' then you could already do like data Symbol = Symbol {base :: String, isInverted :: Bool} or something
13:55:54 <Gracenotes> senex1: I haven't seen anything like that.. :/
13:56:20 <sjanssen> senex1: you can do something like: char 'a' <|> 'A'
13:56:21 <senex1> maybe the best way is just to make all the input lower case and then look for "abc"
13:56:39 <sjanssen> perhaps write a combinator to make that more convenient
13:57:04 <senex1> but it should work also for strings, and I donâ€™t want to write string "ABC" <|> string "Abc" <|> string "aBc" â€¦
13:57:08 <Gracenotes> caseInsensitiveChar c = char (toUpper c) <|> char (toLower c)
13:57:26 <Gracenotes> or liftA2 (<|>) toUpper toLower
13:57:27 <BMeph> senex1: That' a good point. How would that function run on Unicode, for instance. Well, bsdes "badly," I mean. ;)
13:57:50 <BMeph> BRB, changing my keyb batteries. :\
13:57:59 * luqui uses unsafe* for any function which violates the semantic model
13:58:15 <senex1> hmm â€¦ I canâ€™t load Parsec into ghci?  What am I doing wrong?
13:58:27 <ddarius> senex1: The easiest way would be to do what you suggest.  That lets you reuse as much that already exists as possible, but it means you'll lose the case information if that is important to you.
13:58:27 <trofi> -package parsec
13:58:36 <Gracenotes> caseInsensitiveString = choice . map (try . caseInsensitiveChar)
13:59:11 <Gracenotes> wait.. that's actually a bad idea
13:59:15 <ddarius> Gracenotes: I'm pretty sure you don't need try there (but that it also doesn't really hurt)
13:59:32 <Gracenotes> that checks for each character in turn, not a string of characters
13:59:41 <ddarius> You want sequence not choice.
13:59:47 <Gracenotes> yeah.
13:59:49 <ddarius> Which leads to mapM
13:59:58 <luqui> toUpper <^(<|>)^> toLower -- our operators are getting out of hand...
14:00:12 <ddarius> luqui: Soon they will rise up against us.
14:00:13 <Gracenotes> ah... that works
14:00:31 * Gracenotes finds liftA2 harmless enough
14:00:59 <Gracenotes> @hoogle (<^)
14:01:00 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
14:01:13 <dancor> how many sane-looking operators can there really be
14:01:56 <dancor> prob ~216
14:01:56 <luqui> Gracenotes, from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative
14:02:03 <Gracenotes> aiieeee
14:02:04 <ddarius> > let (===================) = (+) in 3 ==================== 4
14:02:06 <lambdabot>   Not in scope: `===================='
14:02:10 <ddarius> > let (===================) = (+) in 3 ===================== 4
14:02:12 <lambdabot>   Not in scope: `====================='
14:02:45 * ddarius suddenly has an idea for syntactic abuse of Haskell.
14:03:34 <Gracenotes> @brain
14:03:35 <lambdabot> I think so, Brain, but a codpiece made from a real fish would get smelly after a while, wouldn?t it?
14:03:48 <luqui> pinky++
14:04:11 <BMeph> luqui: got an 'unsafeSeqs' fn? ;p
14:04:11 <Gracenotes> ddarius: does it involve brainfuck, by any chance?
14:04:17 <ddarius> Gracenotes: No
14:04:29 <Gracenotes> okay then :)
14:04:39 <luqui> BMeph, if I designed Haskell, it would be unsafeSeq :-)
14:05:08 <ddarius> Gracenotes: Though now I wonder if you could embed a decent amount of brainfuck programs into Haskell.
14:05:36 <Gracenotes> with enough spacing, probably
14:05:43 <Gracenotes> the problematic operator, I think, would be ,
14:05:50 <Gracenotes> can you redefine that?
14:05:54 <ddarius> No
14:06:23 <Gracenotes> the simply solution would probably be to wrap an entire program in [], then
14:06:26 <Gracenotes> *e
14:06:56 <Gracenotes> tuples might work except there are only so many lengths you can have before it gets o_O
14:07:19 <BMeph> luqui: You're the one doing Dana, right? :)
14:07:25 <luqui> BMeph, ya
14:07:30 <luqui> =P
14:08:22 <blork> @pl f s u a b = s (u a b)
14:08:22 <lambdabot> f = (.) . (.)
14:08:29 <blork> crap
14:08:57 <blork> is there a way to get an intermediate one
14:09:02 <blork> @unpl (.) . (.)
14:09:03 <lambdabot> (\ i b c f -> i (b c f))
14:09:14 <Gracenotes> :t let (>) = id in [ > > > > > > > ]
14:09:15 <lambdabot> parse error on input `>'
14:10:04 <Gracenotes> :t let (>>>>) = id in [ >>>> ]
14:10:06 <lambdabot> parse error on input `]'
14:10:25 <rwbarton> blork: maybe like this
14:10:30 <rwbarton> @pl \a b -> s (u a b)
14:10:31 <lambdabot> (s .) . u
14:11:17 <Gracenotes> @pl \k s a o w -> r j k o w m a
14:11:17 <lambdabot> const . flip . (flip .) . flip flip m . (flip .) . r j
14:11:48 <Gracenotes> @pl \a b c d e -> a . b . c . d . e
14:11:49 <lambdabot> (. ((. ((. (.)) . (.) . (.))) . (.) . (.) . (.))) . (.) . (.) . (.) . (.)
14:11:54 <hallongrottan> Boobies!
14:13:02 <kerlo> Alien boobies.
14:13:58 <kerlo> @pl \a b -> a b b a b a a b b a a b a b b a b a a b a b b a a b b a b a a b
14:14:01 <lambdabot> flip ap id . join (flip . join (flip . flip ap id . join (flip . flip ap id . flip ap id . join (flip . join (flip . flip ap id . flip ap id . join (flip . flip ap id . ap (flip . ap (flip . flip ap
14:14:01 <lambdabot> id . ap (flip . flip ap id . flip ap id . ap (flip . flip ap id . ap (flip . ap (flip . flip ap id . flip ap id . ap (flip . ap (flip . flip ap id . ap (flip . flip ap id) id) id) id) id) id) id) id)
14:14:01 <lambdabot>  id) id))))))
14:14:01 <lambdabot> optimization suspended, use @pl-resume to continue.
14:14:06 <kerlo> >:-)
14:14:08 <kerlo> @pl-resume
14:14:15 <lambdabot> join . (flip =<< join (flip . join . join (flip . join . join . join (flip . join (flip . join . join . join (flip . join . join (flip . join (flip . join . join (flip . join . join . join (flip .
14:14:15 <lambdabot> join . join (flip . join (flip . join . join . join (flip . join (flip . join . join (flip . join)))))))))))))))
14:14:15 <lambdabot> optimization suspended, use @pl-resume to continue.
14:14:18 <kerlo> Mmkay.
14:14:26 <SamB> @pl-resume
14:14:36 <lambdabot> join . (flip =<< flip =<< join . (flip =<< join . join . (flip =<< flip =<< join . join . (flip =<< join . (flip =<< flip =<< join . (flip =<< join . join . (flip =<< join . (flip =<< flip =<< join .
14:14:36 <lambdabot>  join . (flip =<< flip =<< join . (flip =<< join))))))))))
14:14:41 <pumpkin_> scary
14:14:50 <SamB> @pl-resume
14:14:51 <lambdabot> pointless: sorry, nothing to resume.
14:14:58 <SamB> oh, it's done now
14:15:09 <BONUS> i remember someone posting a pl that didn't terminate
14:15:14 <BONUS> it threw the pl machine into a loop
14:15:32 <mofmog> what is going on
14:15:43 <ddarius> @quote flip.stream
14:15:44 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
14:15:46 <Cheshire> it's because @pl is untyped
14:15:50 <m0nkfish> hmm my laptop volume control doesnt work when im working in openoffice
14:15:51 <m0nkfish> o_O
14:16:58 <rwbarton> what does  module `Foo' is not loaded  mean as a result of :m +Foo?
14:17:38 <rwbarton> I know it's not loaded, that's why I did :m + :)
14:17:53 <SamB> rwbarton: it means you need to use :l or :a or something like that
14:18:17 <SamB> :m is only for stuff that was already pulled in or is in a non-hidden package, apparantly
14:18:18 <rwbarton> SamB: ooh
14:18:37 <rwbarton> so not for things just lying around in the current working directory
14:19:53 <pumpkin_> mmorrow: can you add rewrite rules or other pragmas in TH, or does the TH evaluation happen at the wrong time?
14:20:34 <SamB> pumpkin: no to both, I think
14:20:46 <pumpkin_> ah
14:20:55 <SamB> not positive about the former though
14:21:47 <SamB> hmm, the constructor(s) for it don't seem to be in Dec though
14:22:09 <gnuvince_> If variables are immutable in Haskell, does this mean that they can safely be passed by reference to functions?
14:22:41 <SamB> gnuvince_: what, and add ANOTHER indirection?
14:23:26 <pumpkin_> gnuvince_: you mean how it's done behind the scenes?
14:23:32 <gnuvince_> pumpkin_: yes.
14:23:37 <ddarius> gnuvince_: Most things in Haskell (in all current implementations) are "passed by reference"
14:23:44 <pumpkin_> yeah, there's no reason to "duplicate" it
14:23:44 <ddarius> Of course, there's no way to tell this semantically.
14:23:51 <gnuvince_> ddarius: thanks
14:24:04 <gnuvince_> ddarius: it was more a personnal curiosity than anything else.
14:24:46 <Axman6> gnuvince_: only a few primitives can be passed by value, mainly things like Int#, Float#, Double#, Addr#
14:25:21 <gnuvince_> Axman6: OK
14:25:43 <gnuvince_> It's nice to know that it's not something we need to worry about.
14:25:53 <ddarius> Axman6: Those are GHC extensions and they are guaranteed to be passed by value, but that doesn't mean other things can't be.
14:26:40 <Axman6> fair enough. how can other things be passed by value?
14:27:01 <mofmog> how would i go around establishing constraints on a data type?
14:27:10 <ddarius> Axman6: Usually when you use Int, it gets internally translated to Int# so you have no need to use Int# directly.
14:27:18 <mofmog> for example, if i want to have a data type that defines a probability space, i want a check that sees if all the probabilities add up to 1
14:27:24 <Cheshire> mofmog, just let type inference do it
14:27:32 <Cheshire> mofmog, oh you didn't mean class constraints
14:27:46 <ddarius> mofmog: You'd have to maintain the invariant using typical abstract data type techniques.
14:27:50 <Axman6> ddarius: well what i mean is, can you define things that are passed by value? or do they have to be compiler primatives?
14:27:55 <Axman6> primitives even
14:28:25 <pumpkin_> Axman6: why would you pass something by value? it seems that immutability would remove the need in most cases
14:28:44 <Axman6> speed? i dunno, curious ;)
14:28:46 <rwbarton> mofmog: namely, don't export the constructor for your data type and instead export a "smart constructor" that does a run-time check before applying the real constructor
14:28:53 <mofmog> oic
14:28:57 <pumpkin_> Axman6: passing by reference should be faster?
14:29:00 <mofmog> ah that makes sense
14:29:04 <mofmog> a lot fo sense
14:29:37 <Axman6> pumpkin_: well, using things like Int# ad passing by value can often be faster. the values can be kept in registers in certain cases
14:30:23 * SamB hopes mofmog doesn't expect floating-point values to add up to 1 ;-P
14:31:06 <dolio> And Int# is the same size as a pointer. So why would passing around a pointer to a heap allocated Int# be faster than passing around the Int#?
14:31:25 <pumpkin_> dolio: an extra layer of indirection?
14:31:31 <pumpkin_> in very tight stuff, I guess
14:31:49 <Axman6> well, wouldn't incrementing the value vbe faster? no need to fetch the value, increment it then store it
14:32:54 <dolio> Even merely using it would likely be faster.
14:33:01 <dancor> SamB: maybe he'll just check for x in [0.5, 1.0)  ;)
14:33:07 <dolio> Since it's "just use it" versus "fetch it and then use it".
14:33:09 <dancor> 1.5 rather
14:33:15 <lunabot>  luna: lexical error in string/character literal at end of input
14:34:02 <rwbarton> what was lunabot responding to there?
14:34:17 <pumpkin_> it does that sometimes
14:34:19 <pumpkin_> I'm not sure why
14:34:20 <dancor> 1.5 test
14:34:26 <rwbarton> maybe the quit message?
14:34:28 <rwbarton> ]"
14:34:29 <lunabot>  luna: lexical error in string/character literal at end of input
14:34:37 <rwbarton> test ]"
14:34:38 <pumpkin_> ah, that could be it
14:35:10 <lunabot>  luna: lexical error in string/character literal at end of input
14:35:12 <rwbarton> yep
14:35:22 <pumpkin_> it responded?
14:35:24 <dolio> ] 1 + 1
14:35:25 <rwbarton> yeah
14:35:25 <lunabot>  2
14:35:34 <pumpkin_> sounds like a good way to do parthian shots
14:36:01 <Axman6> dolio: i found that using unboxed Ints in the nbodies stuff i've been doing saved some time when accessing arrays abd using I# (n +# 1) for example
14:36:04 <Axman6> 1#
14:36:22 <rwbarton> pumpkin_: that one didn't do anything
14:36:30 <pumpkin_> hmm
14:36:48 <rwbarton> pumpkin_: still nothing
14:36:50 <Axman6> needs the : i think
14:36:53 <Axman6> hmm
14:37:00 <lunabot>  luna: lexical error in string/character literal at end of input
14:37:06 <dolio> You mean re-boxing them saved time?
14:37:08 <pumpkin_> weird lunabot :)
14:37:53 <Axman6> dolio: well, the functions needed boxed ints, but using unboxed addition did save some time. not sure why it would though (seems like something GHC should be abe to optimise)
14:38:01 <dolio> Oh.
14:38:04 <Axman6> pumpkin_: that last one worked
14:38:12 <pumpkin_> fun
14:38:14 <lunabot>  luna: parse error (possibly incorrect indentation)
14:38:17 <dolio> Well, if you're using STUArrays, they have optimization issues.
14:38:34 <pumpkin_> [17:38:14] <lunabot> luna: parse error (possibly incorrect indentation)
14:38:35 <rwbarton> ddarius: lunabot doesn't understand comments, but maybe just one " in the message will work
14:38:38 <Axman6> i am actually. what kind of issues?
14:38:48 <dolio> GHC can't seem to see through everything to unbox all the way down to Int#s and MutableByteArrays# and such.
14:39:06 <Axman6> looking at the Core it seems it can
14:39:53 <dolio> It can do a lot, but every time I've used STUArrays, there's been residual boxing over what you could optimally write.
14:40:00 <roconnor> I guess there is no ST transformer.
14:40:03 <dolio> As opposed to uvector, which tends to do better.
14:40:07 <pumpkin_> yay uvector
14:40:21 <pumpkin_> dolio: I think your magic apply function should be in the main uvector package :P
14:40:47 <mopped> @src sep
14:40:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:40:49 <BMeph> pumpkin_: [I hope someone will] fix error
14:40:52 <ddarius> roconnor: An ST transformer wouldn't make any more sense than an IO one.
14:40:52 <Axman6> yeah, i need to try a uvector version. i don't don't totally undrstand uvector yet
14:40:52 <mopped> @src seq
14:40:53 <lambdabot> Source not found. Just try something else.
14:40:57 <mopped> whats the function? its something like that :(
14:41:02 <mopped> for evaluating something
14:41:12 <roconnor> ddarius: right.  I guess I can simply do ST (m a)
14:41:19 <pumpkin_> mopped: seq can't be implemented in regular haskell
14:41:36 <pumpkin_> Axman6: it shouldn't be very different from what you're used to
14:41:46 <roconnor> I'll probably just use state
14:41:53 <mopped> @src foldr'
14:41:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:41:54 <roconnor> @hackage monad-lib
14:41:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monad-lib
14:41:56 <pumpkin_> most of the usual functions have a U suffix on them
14:42:01 <dolio> Yeah, it's the same as STUArray, just with different names for everything.
14:42:28 <dolio> And everything is Int indexed.
14:42:29 <roconnor> @hackage monadlib
14:42:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monadlib
14:42:35 <dolio> And 0-based.
14:42:43 <pumpkin_> :D
14:42:50 <roconnor> @hackage monadLib
14:42:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monadLib
14:43:03 <Axman6> hmm, i should check out uvector then
14:43:13 <pumpkin_> Axman6: :D
14:43:22 <dolio> If you're writing nbodies, though, you can't use uvector on the shootout.
14:43:30 <Axman6> cd pumpkin-uvector/ -- still got it :P
14:43:31 <pumpkin_> :(
14:43:32 <ddarius> dolio: uvector is a pure interface, not a mutable one.
14:43:41 <pumpkin_> there's a MUArr
14:43:43 <ddarius> dolio: It's like a Data.List but for arrays.
14:43:45 <dolio> It has mutable vectors, too.
14:43:59 <Axman6> dolio: why not? they won't install external libs?
14:44:23 <dolio> I don't know what their criteria is. But at least at the moment there's no uvector.
14:44:39 <pumpkin_> Axman6: just include the entire uvector pacakge in your source
14:44:40 <pumpkin_> :P
14:44:47 <Axman6> heh :P
14:45:23 <benmachine> @src fix
14:45:24 <lambdabot> fix f = let x = f x in x
14:46:26 <mmorrow> pumpkin: that's a good question, i think i knew a partial answer to that at one point but i can't remember.
14:46:37 <pumpkin_> ah
14:46:42 <pumpkin_> I'll be back in a few!
14:47:24 <benmachine> is there a standard library function that applies an (a -> a) to an a a given number of times?
14:47:32 <benmachine> like fix but not infinite, I guess
14:47:45 <mmorrow> \n -> foldr (.) id . replicate n
14:47:53 <ddarius> benmachine: No, but you can use a couple of functions to do it.
14:47:55 <Gracenotes> benmachine: closest I've found is iterate f x !! n
14:47:55 <Cheshire> there should be a Data.Nat but I suppose there isn't
14:48:00 <ddarius> mmorrow's is on example
14:48:30 <benmachine> yeah I wrote my own fairly simply but it just seemed like the sort of thing that wouldn't look at all out of place in there
14:48:54 <benmachine> so I wanted to make sure I wasn't unnecessarily duplicating things
14:49:22 <benmachine> yours are much better than mine though >_>
14:49:31 * benmachine haskellnewb
14:49:38 <Gracenotes> > foldr (.) id [f, f, f, f, f]
14:49:39 <lambdabot>       Overlapping instances for Show (a -> a)
14:49:39 <lambdabot>        arising from a use of `s...
14:49:52 <Gracenotes> > foldr (.) id [f, f, f, f, f] $ x
14:49:54 <lambdabot>   f (f (f (f (f x))))
14:50:26 <BMeph> benmachine: Yeah, there are some funny (to some) decisions on what's in the Prelude, and what isn't in any library.
14:50:29 <mmorrow> , foldr (.) id [f, f, f, f, f] x
14:50:31 <lunabot>  f (f (f (f (f x))))
14:51:06 <benmachine> , foldr (.) id [f, f, f, f, f] y
14:51:08 <lunabot>  f (f (f (f (f y))))
14:51:09 <BMeph> benmachine: My favorite example: swap. :)
14:51:12 <Axman6> benmachine: technicallt iterate does that
14:51:15 <Axman6> y*
14:51:58 <Axman6> 108 people dead in the victoria bushfires :(
14:52:14 * QtPlatypus nods to Axman6 
14:52:30 <QtPlatypus> They have been alot worse then normal.
14:52:48 <Axman6> yeah, by far the worst they've ever had
14:53:08 <Axman6> some of the footage was insane. never seen fire move anywhere near that fast
14:57:20 <mmorrow> , fix ((h::Expr->Expr) . g . (f ::Expr->Expr))
14:57:22 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h...
14:57:31 <ddarius> @free fix
14:57:33 <lambdabot> f . g = h . f => f (fix g) = fix h
14:58:33 <mmorrow> that's a good @free
14:58:53 <Axman6> yeah
14:59:35 <ddarius> mmorrow: In this case (with the unstated side-conditions on strictness), it actually uniquely charaterizes fix.
14:59:54 <mmorrow> nice
15:03:16 <senex1> is there a more elegant way to tell Parsec to match zero or one times a given parser?  At the moment I use option "" p to do this
15:03:29 <ddarius> @hoogle optional
15:03:30 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
15:03:30 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
15:03:30 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
15:03:49 <senex1> Ah, thanks a lot :)
15:04:46 <Olathe> > iterate f x
15:04:48 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
15:05:07 <ddarius> senex1: Well Parsec's optional doesn't provide the result so you can't tell whether it parsed it or not.  You can make the equivalent of Applicative's by using option Nothing (Just <$> p)
15:05:18 <ddarius> :t \p -> option Nothing (Just <$> p)
15:05:20 <lambdabot> Not in scope: `option'
15:06:20 <senex1> I donâ€™t care if he parses or not, so itâ€™s ok
15:07:14 <senex1> why isnâ€™t optional listed in the Parsec-Documentation?
15:08:09 <mmorrow> , [$ty|  \p -> (Just `fmap` p) +++ return Nothing  |]
15:08:12 <lunabot>  forall a . ReadP a -> ReadP (Maybe a)
15:08:30 <mmorrow> , [$ty|  \p -> (Just `fmap` p) <++ return Nothing  |]
15:08:33 <lunabot>  forall a . ReadP a -> ReadP (Maybe a)
15:09:21 <ddarius> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html#v%3Aoptional
15:09:24 <pumpkin> @seen dons
15:09:25 <lambdabot> dons is in #arch-haskell, #haskell, #ghc, #xmonad, #concatenative, #darcs and #haskell-in-depth. I last heard dons speak 36m 32s ago.
15:09:31 <ddarius> (and there's an optionMaybe that does what I wrote above)
15:09:48 <mmorrow> , readP_to_S ((\p -> (Just `fmap` p) +++ return Nothing) (string "foo")) "foo"
15:09:49 <lunabot>  [(Nothing,"foo"),(Just "foo","")]
15:09:55 <mmorrow> , readP_to_S ((\p -> (Just `fmap` p) <++ return Nothing) (string "foo")) "foo"
15:09:56 <lunabot>  [(Just "foo","")]
15:10:01 <shapr> I sort of wish cabal packages were also legal darcs repos.
15:10:09 <mmorrow> shapr: yeah, me too
15:10:17 <shapr> It'd be nice to grab a package, make changes, and do NMUs
15:10:22 <mmorrow> err, i thought you said hackage packages
15:10:27 <shapr> I did
15:10:30 <dcoutts> shapr: cabal packages can specify their darcs repo
15:10:33 <shapr> But I mean both.
15:10:39 <shapr> dcoutts: Yeah, but sometimes the repo disappears.
15:10:43 <mmorrow> dcoutts: ah yeah, that's true
15:10:46 <pumpkin> omg two of me
15:10:49 <ddarius> Not everything on hackage has a darcs repo.
15:10:56 <mmorrow> yes
15:11:11 <mmorrow> it'd be nice if each hackage pkg could be darcs got
15:11:11 <dcoutts> ddarius: well, or git then, that gets you 90%
15:11:21 <ddarius> Not everything on hackage has a repo at all.
15:11:30 <dcoutts> mmorrow: the info is there, just need to write the tool
15:11:38 <shapr> On the other hand, perhaps it's not a good idea to tightly couple hackage/cabal with a specific repository.
15:11:47 <Axman6> so what do you need to do to set up a darcs repo on a server? like how to you put stuff into the repo once you've made changes? i get how it works with svn, but not darcs
15:11:48 <shapr> Er, specific source control system
15:11:49 <mmorrow> dcoutts: good idea :)
15:12:08 <dcoutts> shapr: we don't. Packages can specify darcs, git, blah, blah repos
15:12:09 <shapr> Axman6: I've used ssh and email.
15:12:26 <shapr> dcoutts: Right, but I was advocating the other approach for a moment :-)
15:12:27 <Axman6> sounds not very nice imo :\
15:12:34 <shapr> Axman6: It's nicer than you might think.
15:13:03 <shapr> Axman6: For example, you don't need a server repo at all.
15:13:21 <ddarius> Axman6: There is no (particular) notion of a "darcs server".
15:13:24 <shapr> If you and I can both access each other's repo via http, then newly recorded patches can be applied with 'darcs pull'
15:13:59 <mmorrow> dcoutts: hmm, were you thinking a tool to grab the tarball, unpack locally, the darcs init && darcs add -r ., or having each package unpacked into a darcs repo on the hackage side ?
15:14:26 <dcoutts> mmorrow: I was thinking of a tool to get the dev version of any package using darcs, git or whatever the package uses
15:14:34 <Gracenotes> @type ((?f . ?g), (?g . h?))
15:14:35 <lambdabot>     The operator `?' [infixl 9] of a section
15:14:36 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
15:14:36 <lambdabot>         in the section: `(?g . h ?)'
15:14:36 <shapr> Sounds good!
15:14:40 <Axman6> see, my problem is that i want to do al my dev on my macbook pro. but if i had something i wanted to share, i'd want it on my web server, and i don't understand how i'd do that easily
15:14:46 <Gracenotes> @type ((?f . ?g), (?g . ?h))
15:14:48 <lambdabot> forall c b c1 a. (?f::c1 -> c, ?g::b -> c1, ?h::a -> b) => (b -> c, a -> c1)
15:14:53 <ddarius> Axman6: When you darcs get a repository, there's no difference between your repository and the one you got from.
15:14:56 <mmorrow> dcoutts: ah. but what wabout the packages for which no repo exists?
15:14:58 <shapr> Axman6: rsync/ftp/ssh would work fine
15:15:07 <Axman6> hmm
15:15:20 <ddarius> Axman6: You just darcs push to the repo on your web server.
15:15:31 <Axman6> and what would that actually do?
15:15:37 <shapr> Axman6: If you have a public ip address, you could run an http server locally.
15:15:53 <shapr> Axman6: It'd push your changes to the server.
15:16:05 <Axman6> shapr: well, my server is running next door to my bedroom
15:16:13 <Axman6> does that mean anyone could push changes?
15:16:15 <ddarius> Axman6: It depends on how you set it up.  One way would (automatically) use ssh or so to send the data.
15:16:25 <Axman6> hmm, sounds good
15:16:26 <mmorrow> dcoutts: oh, i think we're talking about two different things
15:16:53 <dons> this is the second one of these i've seen in two weeks, http://twitter.com/brools/statuses/1190000583
15:16:55 <FunctorSalad> anyone tried leksah 4 yet?
15:17:20 <Cheshire> dons, have you seen batteries?
15:17:26 <FunctorSalad> seems like I can't open a module A.B if there's also a module A.B.C
15:17:27 <dcoutts> mmorrow: I don't see the point of adding an unpacked hackage tarball into a darcs repo
15:17:30 <Axman6> ddarius: heh, nice
15:17:34 <Axman6> uh, dons
15:17:36 <dons> Cheshire: yep.
15:17:40 <dcoutts> mmorrow: what is the use case, I'm missing something
15:17:41 <shapr> dons: hah
15:17:54 <mmorrow> dcoutts: yeah, me neither. i realized the badness of that idea right after i said it
15:18:08 <dcoutts> mmorrow: ok ;-)
15:18:16 <mmorrow> hehe
15:18:37 <shapr> I would like a tool that slurps down a package in such a way that it's immediately ready for changing :-)
15:19:41 <dons> shapr: mmm
15:19:51 <dons> cabal install foo --repo
15:20:00 <juhp> #fedora-haskell btw
15:20:02 <mmorrow> shapr: yeah, that's exactly what i'm thinking of too
15:20:04 <dons> to lookup the repo tag, then grab the repo?
15:20:15 <dcoutts> dons: more like fetch I think
15:20:19 <dons> ah
15:20:28 <mmorrow> then unpack the tarball + init to your vcs of choice
15:20:36 <dcoutts> dons: cabal fetch foobar --source-repository
15:20:44 <dons> dcoutts: srsly?
15:20:45 <dons> woo!
15:20:56 <shapr> dons: yeah
15:21:05 <dcoutts> dons: that's a proposal, not a delivered feature!
15:21:07 <dcoutts> :-)
15:21:08 <dons> ah ha
15:21:09 <mmorrow> haha
15:21:12 <mmorrow> i just tried
15:21:15 <dons> you raise expectations ever so.
15:21:18 <mmorrow> :)
15:21:18 <shapr> dcoutts: Sounds great to me!
15:21:29 <mmorrow> me too
15:21:31 <dcoutts> dons: which would darcs get or git whatever just like  cabal unpack does now with tarballs
15:21:35 <dons> yup
15:21:37 <SamB> dcoutts: and that works with xyzvcs?
15:21:38 * juhp wants to rfe "cabal source <package>"
15:21:51 <juhp> ah
15:21:54 <juhp> unpack?
15:21:55 <dcoutts> juhp: is that the same as cabal unpack?
15:22:00 <juhp> probably :)
15:22:04 <juhp> is that new?
15:22:13 <dcoutts> it fetches the taball and unpacks it in the $CWD
15:22:22 <juhp> cool, yes
15:22:26 <dcoutts> juhp: yes, in dev version
15:22:36 <juhp> ah look forward to that then
15:22:40 <juhp> thanks
15:22:56 <Saizan> testers welcomed :)
15:23:20 <dcoutts> Saizan: augustss found one bug :-)
15:23:23 <juhp> okay maybe I will start running from darcs soon on my dev box
15:23:24 <Saizan> it's still a quite stable dev version imo, since it follows the stable branch of Cabal
15:23:30 <dcoutts> but we already discussed that
15:23:33 <juhp> ok
15:23:34 <Saizan> dcoutts: attached a fix :)
15:23:45 <dcoutts> Saizan: oh great, will review tomorrow evening
15:24:35 <rwbarton> dcoutts: so there is currently a field I can add to my .cabal file to say where the development repository is?  what is it?
15:24:49 <augustss> so when are we getting the new cabal-install version? :)
15:25:02 <dcoutts> rwbarton: http://haskell.org/cabal/release/latest/doc/users-guide/authors.html#source-repos
15:25:33 <dcoutts> augustss: hopefully during the week or next weekend, I've got to test and release the cabal lib first
15:26:03 <Axman6> how old is darcs 2.0.2?
15:26:29 <roconnor> @type runStateT
15:26:31 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:26:59 <rwbarton> dcoutts: excellent, thanks
15:30:32 <juhp> Axman6: seems to be about 2008-06-24
15:31:03 <Axman6> yeah, i might just try installing stuff from source rather than freebsd ports
15:31:18 <juhp> Axman6: or did you mean 2.2.0? :)
15:31:23 <juhp> ah gotcha
15:31:48 <juhp> or move to a more lively distro? :)
15:31:57 <Axman6> pfft
15:32:16 <Axman6> that'd mean using linux, nd that is something i want to avoid whereever possible
15:33:15 * juhp ponders
15:34:27 <shapr> hej juhp
15:34:30 <Axman6> how do you open a .tar.bz2 again?
15:34:39 <Japsu> ...
15:34:42 <shapr> Axman6: tar xjf $filename
15:34:53 <shapr> heippa hei Japsu
15:34:58 <Japsu> moi shapr
15:35:01 <jberryman> trying to install cabal, I'm getting this error after running bootstrap.sh:
15:35:02 <Axman6> or better yet, how would i open the ghc-src and ghc-extralibs tarballs into the saqme dir?
15:35:03 <jberryman> Setup: At least the following dependencies are missing:
15:35:05 <juhp> hei shapr! :)
15:35:15 <jberryman> Setup: At least the following dependencies are missing:
15:35:17 <augustss> dcoutts: do you know anything about building the docs for hackage packages?
15:35:25 <jberryman> HTTP >=3000 && <3002, network >=1 && <3
15:35:31 <dcoutts> augustss: only that it's more than a little unreliable :-)
15:35:34 <shapr> What's the best choice for doing bytestring parsing? attoparsec, bytestring-lexing, or what? I want to parse FLAC (audio) files.
15:35:46 <dcoutts> augustss: it's done on a box that sits under Ross's desk and nobody else has access
15:35:50 <SamB> augustss: you mean the ones on hackage, or you want to do it yourself ?
15:35:53 <augustss> dcoutts: it's annoying that the docs don't get built if the compilation fails
15:35:57 <juhp> Axman6: isn't there a ports package script?
15:36:06 <dcoutts> augustss: yep it is, it'll be done differently with the new server
15:36:13 <SamB> augustss: fails how?
15:36:26 <Axman6> juhp: sure, but what's that got to do with it?
15:36:35 <juhp> use it :)
15:36:35 <Axman6> the ports version is 6.8.3
15:36:42 <SamB> if it fails in typechecking or earlier, haddock will too
15:36:43 <augustss> SamB: e.g., the llvm package needs LLVM to be installed to compile
15:36:46 <dcoutts> augustss: mind you, with haddock-2 it's rare that a package can fail to build but have the docs work. Haddock afterall does 2/3rds of the compile/build process.
15:37:06 <SamB> augustss: will it typecheck without LLVM installed, then ?
15:37:21 <augustss> SamB: it will do everything excpt link
15:37:40 * SamB didn't think libraries actually had to link
15:37:45 <dcoutts> augustss: will it? I assume you don't use hsc2hs then.
15:38:03 <Axman6> augustss: does anything special need to be done to get the LLVM package to find your LLVM install? i've used macports for LLVM, and it doesn't seem to find it
15:38:18 <augustss> dcoutts: oh, you're right.  there are a few hsc2hs bits now.  there didn't use to be
15:38:29 <dcoutts> Axman6: use the --extra-include-dirs --extra-lib-dirs flags
15:38:36 <Axman6> ah, thanks
15:38:45 <Axman6> can those be used with cabal-install
15:38:46 <Axman6> ?
15:38:49 <dcoutts> yes
15:38:59 * dcoutts notes the new check for libs/headers now suggests using these flags
15:39:07 <Axman6> just stick them on the end of the command?
15:39:11 <dcoutts> yup
15:39:17 <Axman6> excellent, thanks :)
15:39:34 <dcoutts> Axman6: well, you need to say =/the/path/where/llvm/can/be/found of course
15:39:42 <Axman6> yeah
15:40:00 <shapr> enolan: hey echo, ltns
15:40:10 <enolan> shapr: Hiya.
15:40:19 <shapr> How's code?
15:40:38 <enolan> In C recently.
15:40:39 <augustss> very basic
15:40:48 * SamB groans
15:40:50 <shapr> :-P
15:40:59 <Axman6> heh
15:41:03 <SamB> augustss: that's a bad pun
15:41:12 <SamB> especially for those who are out-of-the-loop
15:41:13 <Axman6> dcoutts: seems to be working, thanks :)
15:41:19 <shapr> augustss: Hey, are you showing up in Boston anytime soon? I'll buy you a beer(s) if you'll talk about ioccc or other cool stuff :-)
15:41:44 <shapr> augustss: Oh hey, can you point me to any of the BlueSpec guys actual emails? I'm trying to find a CHUG venue.
15:41:47 <augustss> shapr: I dunno.  I'd like to go, but I've had no excuse in a long time
15:41:59 <shapr> Well, next time you're in town, look me up.
15:42:12 <augustss> shapr: one sec
15:42:17 <Axman6> augustss: shapr's dying and needs to tell you the secret to umtimate knowledge!
15:42:24 <Axman6> gogogo!
15:42:26 <shapr> %-?
15:42:37 * shapr is confused
15:42:53 <Axman6> he needed an excuse to go see you
15:43:04 <shapr> Dude, if I were dying, I'd probably spend more time coding... so many cool things I haven't gotten to try yet!
15:43:12 <shapr> oh right
15:43:32 <ddarius> shapr: If you were dying you should be single-mindedly chasing one of those many girls.
15:43:34 <augustss> shapr: Nikhil has nikhil@bluespec.com
15:43:40 <shapr> augustss: Thanks!
15:43:48 <shapr> That should get me started.
15:44:18 * SamB hopes they have good spam filters
15:45:00 <augustss> shapr: Ravi has ravi@bluespec.com
15:45:25 <L11> :: (a->b) -> [a] -> [b], what's the purpose of the (a->b)?
15:45:48 <jberryman> L11: means "a function from some type a to some type b"
15:45:49 <Cheshire> L11, the ([a] -> [b]) function is based on the (a -> b) one
15:45:49 <augustss> L11: it's the function you apply to all the elements of the list
15:45:51 <ddarius> There are no functions [a] -> [b] other than the contantly [] one.
15:45:58 <ddarius> (and some undefined ones.
15:45:58 <Axman6> L11: it's a function fro type a to type b
15:46:00 <ddarius> )
15:46:08 <jberryman> first
15:46:09 <Axman6> from*
15:46:12 <wli> int80_h: You're not supposed to even consider most of the numbers involved.
15:46:16 <L11> ah thanks :)
15:46:49 <Axman6> "Generating and compiling a zillion numerical type aliases, this might take a while"
15:46:52 <Axman6> heh
15:46:57 <Valodim> huh
15:47:04 <shapr> Valodim: cabal install BASIC
15:47:05 <dons> haha
15:47:09 <jberryman> the docs for installing cabal-install mention something about a "self-documenting config file" which doesn't seem to exist
15:47:10 <augustss> Axman6: :)
15:47:11 <Valodim> ..what?
15:47:19 <shapr> Valodim: Try it!
15:47:33 <Axman6> argh, still can;t get LLVm to compile
15:47:35 <Axman6> M*
15:47:44 <Valodim> I wonder, is there any common reason why a (very simple) program works in ghci but not compiled?
15:47:49 <augustss> Axman6: what happens?
15:47:56 <shapr> Axman6: It's working for me now, after upgrading to llvm 2.4
15:47:57 <Axman6> configure: error: could not find LLVM C bindings
15:47:59 <dcoutts> jberryman: if your ~/.cabal/file is decidedly not self-documenting then it's because you've got one generated by an older version. Back it up and let the program create a new one.
15:48:00 <Valodim> getting tons of undefined reference errors
15:48:13 <shapr> Valodim: You probably need llvm 2.4
15:48:15 <rwbarton> Valodim: use --make
15:48:29 <Valodim> --make works
15:48:32 <Valodim> thanks
15:48:41 * Valodim goes read what --make does
15:49:00 <augustss> Axman6: have you read INSTALL.txt?
15:49:13 <Axman6> nope, just trying to cabal install llvm :\
15:49:26 <augustss> Axman6: but that's not enough
15:49:28 <jberryman> dcoutts: I just installed cabal-install, and have no file: ~/.cabal/config
15:49:38 <augustss> Axman6: cabal install --configure-option --with-llvm-prefix=$SOMEWHERE
15:49:51 <ddarius> People complain about missing documentation, then you write documentation and then they don't read it.
15:49:53 <jberryman> following these instructions: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
15:50:03 <Axman6> what's that do?
15:50:16 <SamB> ddarius: partly because it was still missing as far as they were concerned?
15:50:35 <augustss> Axman6: you need to tell the configure script where your LLVM lives
15:50:39 <Axman6> or rather, what should $SOMEWHERE point to?
15:50:40 <augustss> Axman6: it's all documented
15:50:49 <Axman6> ok, i'll have a look then
15:50:54 <ddarius> SamB: It's still missing because they didn't even attempt to look for it?
15:50:59 <augustss> Axman6: it should point to where LLVM in installed
15:51:18 <SamB> ddarius: where are they going to look if they just tried to install it from hackage ?
15:51:31 <Axman6> "checking for LLVMModuleCreateWithName in -lLLVMCore... yes" looks promising
15:51:40 <Axman6> seems to be where it failed beforehand
15:51:52 <augustss> dcoutts: Here's another caba-install feature:  if a file with a certain name exists, it will be listed before the build starts
15:52:02 <Axman6> awesome, all working now. thanks augustss
15:52:03 <dcoutts> augustss: ideally the package would work with the standard --extra-lib-dirs --extra-include-dirs flags rather than needing a custom --with-llvm-prefix flag passed to the ./configure script.
15:52:23 <dcoutts> augustss: you mean a README.first file?
15:52:33 <augustss> dcoutts: yes
15:52:48 <pumpkin> Generating and compiling a zillion numerical type aliases, this might take a while
15:52:50 <ddarius> SamB: At the "source".  It will be on their hard drive or they can look at the homepage.
15:52:53 <dcoutts> augustss: it doesn't really work when installing a whole set of packages at once
15:52:57 <augustss> dcoutts: maybe it already works?
15:53:26 <dcoutts> augustss: not if your ./configure script tries to detect the llvm libs and only consults the --with-llvm-prefix flag
15:53:43 <dcoutts> augustss: it'd be a nice test case for the new lib checks in Cabal-1.6.0.2
15:53:52 <augustss> dcoutts: the whole configure script is just a pain.  I blame it on bos.
15:53:52 <Axman6> i think an instructions-file: directive in the .cabal file would be good. something that's supposed to be short, that tells the user what needs to be done to get the package installed
15:54:06 <augustss> dcoutts: I've bypassed it for the Windows install.
15:54:11 <dcoutts> augustss: I'd be interested to know what it does and if we can eliminate it
15:54:34 <dcoutts> Axman6: but the point with these packages is that there should be no manual fiddling required
15:54:43 <Axman6> indeed
15:54:54 <augustss> dcoutts: it basically runs llvm-config with a few arguments to find paths and flags
15:54:54 <dcoutts> Axman6: so I'd rather fix things that tell everyone about workarounds
15:54:59 <Axman6> i think it's reasonable when things depend on external libs though
15:55:04 <dcoutts> augustss: ok, so that can be done in Setup.hs
15:55:27 <augustss> dcoutts: yes
15:55:57 <pumpkin> what are the security implications of having an executable Setup.hs ? what if someone included a huge Setup.hs that in some cases did something malicious, like clearing someone's home dir?
15:55:58 <dcoutts> augustss: if it runs llvm-config then why does it need a --with-llvm-prefix? it's that what llvm-config tells you?
15:56:10 <dcoutts> it's isn't
15:56:23 <augustss> dcoutts: it needs to find llvm-config :)
15:56:27 <dcoutts> hah
15:56:34 <dcoutts> ok, so it's not on the path
15:56:41 <augustss> dcoutts: not necessarily
15:56:43 <SamB> pumpkin: hopefully hackage would get really mad about that ?
15:56:45 <dcoutts> augustss: well that works already, --with-llvm-config=...
15:56:56 <dcoutts> augustss: using the Program mechanism in the Setup.hs
15:57:06 <SamB> if hackage's porn all got deleted, what would it do?
15:57:08 <chessguy> yo ho ho
15:57:17 <pumpkin> SamB: but someone could do a decent amount of damage before getting pulled off...
15:57:27 <augustss> dcoutts: is that documented?
15:57:28 <Axman6> http://webkit.org/blog-files/leaves/index.html awesome in the latest webkit (or any semi recent webkit)
15:58:06 <SamB> pumpkin: but, you know, they could also put code for that in their library ...
15:58:12 <ddarius> pumpkin: Currently there is little in the way of security except that you need to get an account to upload to hackage and that's not an automated process.
15:58:23 <dcoutts> augustss: well, only to the extent that the user guide points to the api docs for UserHooks in Distribution.Simple
15:58:30 <SamB> not an automated process ANYMORE
15:58:31 <pumpkin> SamB: true :)
15:58:39 <dcoutts> augustss: and UserHooks contains hookedPrograms :: [Program]
15:58:59 <ddarius> pumpkin: The big issue, currently, is that once you can upload you can upload over -any- package.  So you don't need to make an alluring seeming package to get people to download
15:59:03 <augustss> dcoutts: hmmm.  it's not the most selfdocument API
15:59:21 <dcoutts> augustss: indeed, the API for Setup.hs is not well documented or well designed
15:59:23 <pumpkin> ddarius: yeah I noticed that non-maintainers often seemed to be listed as the uploaders
15:59:50 <pumpkin> ddarius: I like how much everyone trusts each other in this community, but all it takes is one bad apple :/
16:00:24 <SamB> hmm, probably NMUs should require more than just an account?
16:00:54 <ddarius> SamB: There are a variety of different mechanisms that could be put to bear on that problem.
16:01:19 <SamB> ddarius: yes
16:04:03 <augustss> Axman6: did it work?
16:04:10 <Axman6> yep :)
16:06:16 <seafood> Anyone know a function for getting the nth root of a real number?
16:06:37 <augustss> seafood: (**(1/n))
16:06:43 <pumpkin> > let nthRoot n x = x**(1/n) in nthRoot 3 8
16:06:45 <lambdabot>   2.0
16:06:53 <seafood> Errr, yeah, of course that would work :)
16:07:42 <Axman6> augustss: are errore like this common? "ld warning: atom sorting error for _llvmzm0zi6zi4zi0_LLVMziFFIziCore_Type_closure_tbl and _llvmzm0zi6zi4zi0_LLVMziFFIziCore_ModuleProvider_closure_tbl in dist/build/LLVM/FFI/Core.o"
16:07:52 <Axman6> well, warnings
16:07:56 <augustss> Axman6: yes, it's a bug in the Apple linker
16:08:07 <Axman6> ok, that's ok then
16:08:17 <wli> If 2 has a square root mod 2*n*n-1, call it q, then 2*x^2-1 factors as (q*x+1)*(q*x-1)
16:09:24 <wli> substitute x = n and it's a potential factorization of 2*n*n-1
16:09:35 <mhydronic> i'm trying to write a function that takes in a word and returns that word + a string appended to the end. is there a simpler syntax than this: http://pastebin.com/m5b5076e8 ?
16:10:10 <Botje> mhydronic: [c] ++ cs is equivalent to c:cs
16:10:37 <mauke> isVowel = (`elem` "aeiou")
16:10:43 <mhydronic> thanks
16:11:07 <mauke> test s@(c : _) | isVowel c = s ++ "ay"
16:11:13 <mauke> test s = s
16:11:14 <mreh> can I overload functions in Haskell?
16:11:26 <Axman6> in a way
16:11:27 <mauke> mreh: only if they're part of a class
16:11:42 <mreh> im making a library for cartesian co-ordinates
16:11:43 <Axman6> @src Num
16:11:44 <lambdabot> class  (Eq a, Show a) => Num a  where
16:11:44 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:11:44 <lambdabot>     negate, abs, signum     :: a -> a
16:11:44 <lambdabot>     fromInteger             :: Integer -> a
16:11:49 <mreh> trying to make them generic for 2D and 3D
16:12:03 <pumpkin> mreh: nope
16:12:05 <Axman6> mreh: well, make a class then, and then make instances
16:12:12 <BMeph> mhydronic: don't you mean 'cs ++ [c]', though? ;)
16:12:29 <pumpkin> for that you need snoc!
16:12:42 <mreh> im only doing haskell school of expression! i haven't gotten that far yet
16:12:43 <BMeph> mhydronic: Unless, of course this isn't doing Pig Latin. :)
16:12:45 <mhydronic> BMeph: no, i dont think so
16:12:51 <mreh> i might just make a 2D library for now then :D
16:13:02 <mhydronic> mauke: what does s@ mean?
16:13:17 <mreh> s@ is an 'as' pattern
16:13:33 <mreh> binds the following pattern to 's'
16:14:03 <mhydronic> ok so translate into english: test s@(c : _) | isVowel c = s ++ "ay"
16:14:37 <Olathe> In English, it's 'In Haskell, test s@(c : _) | isVowel c = s ++ "ay"'
16:14:47 <mhydronic> BMeph: it is pig latin
16:14:53 <Axman6> if the first letter in s in a vowel, the  append 'ay' to s
16:14:59 <mreh> is the string a pig latin word
16:15:33 <Olathe> > let f xxs@(x:xs) = "xxs = " ++ show xxs ++ ", x = " ++ show x ++ ", xs = " ++ show xs in f [1..10]
16:15:35 <lambdabot>   "xxs = [1,2,3,4,5,6,7,8,9,10], x = 1, xs = [2,3,4,5,6,7,8,9,10]"
16:15:55 <mhydronic> translates any word into pig latin
16:15:57 <davidL> @seen sorear
16:15:58 <lambdabot> I haven't seen sorear.
16:16:09 <mauke> preflex: seen sorear
16:16:09 <preflex>  sorear was last seen on #haskell 242 days, 8 hours, 34 minutes and 19 seconds ago, saying: @join ##php-quirk
16:16:14 <Olathe> > let f xxs@(x:xs) = "xxs = " ++ show xxs ++ ", x = " ++ show x ++ ", xs = " ++ show xs in f "zomg"
16:16:15 <BMeph> mhydronic: then you want 'cs ++ (c:"ay")' for non-vowels. :)
16:16:16 <lambdabot>   "xxs = \"zomg\", x = 'z', xs = \"omg\""
16:16:23 <mauke> hah, good times
16:16:37 <davidL> what happened to him?
16:16:49 <augustss> yeas, what happened?
16:16:53 <Axman6> caught the php bug
16:17:05 <Axman6> and segfaulted
16:17:17 <mauke> ##php-quirk was a rather short-lived troll channel
16:17:20 <mhydronic> BMeph: i was just testing the case where the word starts with a vowel
16:17:22 * wli attempts to figure out where te square roots of 2 yield something interesting.
16:17:49 <BMeph> mhydronic: Add "way", then. :)
16:18:09 <enolan>  /join #haskell-in-depth
16:18:12 <enolan> oops
16:18:22 * BMeph finds it disturbing that he ID'd it as Pig Latin so quickly...
16:18:45 <wli> 2*n^2-1 is always +/-1 mod 8, so there's always a square root of 2 mod 2*n*n-1.
16:18:50 <mhydronic> BMeph: i dont think that works -> mhydronic: then you want 'cs ++ (c:"ay")' for non-vowels. :)
16:19:31 <mhydronic> for instance, stripe -> ipestray, not tripesay
16:20:16 <BMeph> mhydronic:Ah, good catch. :)
16:20:39 <shapr> Seriously, does anyone know what happened to sorear?
16:21:21 <Botje> he's still on #nethack
16:21:49 <Botje> perhaps he prefers to squash goblins instead of bugs :)
16:24:04 <sjanssen> shapr: I've wondered that myself
16:24:08 <augustss> mmm, nethack!
16:24:14 <sjanssen> he must have lost interest in Haskell?
16:24:48 * shapr asks sorear
16:24:53 <shapr> sjanssen: I dunno, I'll ask him.
16:24:56 <ddarius> Probably chasing women in college.
16:24:56 <augustss> sjanssen: he was just too smart for Haskell
16:25:08 <shapr> ddarius: I'm jealous.
16:25:21 <ddarius> shapr: Weren't you looking to take classes recently/
16:25:23 <ddarius> ?
16:25:35 * ddarius also needs to enroll in classes...
16:25:37 <shapr> er, yeah
16:25:48 <Botje> second semester starts tomorrow for me!
16:26:01 <shapr> I asked Norman Ramsey where I was likely to learn about Frege and Gentzen in evening classes...
16:26:21 <ddarius> "Philosophy of Mathematics"
16:26:24 <augustss> shapr: what did Norman say?
16:27:53 <shapr> augustss: He said he didn't know of anything, and that I should ask Hongwei Xi at BU.
16:28:03 <ddarius> shapr: So did you?
16:28:09 <shapr> Not yet
16:28:30 <augustss> shapr: what do you do in Boston?
16:28:40 <shapr> C# code
16:28:45 <shapr> It's not very exciting.
16:28:56 <shapr> On the good side, I work with edwardk, and that's lots of fun.
16:29:01 <shapr> Never a boring lunch conversation.
16:29:05 <augustss> oh, cool
16:29:19 <augustss> he doe C# too?
16:29:36 <shapr> Yup, we work about three cubes from each other.
16:30:28 <shapr> My brain gets fried on a regular basis at lunch, I hear about things I never knew existed.
16:30:55 <Valodim> inventive chef?
16:30:55 <BONUS> haha
16:31:01 <BONUS> edward kmett owns
16:31:33 <shapr> I'm thinking of trying out for some of the Haskell jobs in the area though, this C# job is getting to me.
16:31:41 <dolio> shapr owns a unicycle.
16:32:13 <roconnor> monadLib could use more supporting functionality
16:32:32 <augustss> shapr: can you juggle as you unicycle?
16:32:54 <shapr> augustss: No, I prefer contact juggling over the more standard form of juggling.
16:33:09 <ddarius> shapr: Can you contact juggle while you unicycle?
16:33:09 <shapr> Oh, speaking of which, I forgot to go to the MIT juggling club today! doh!
16:33:16 <ddarius> Also how many unicycles do you own?
16:33:18 <shapr> ddarius: Somewhat, yeah
16:33:28 <enolan> What does let S = (big U with an i below it and S sub i to the right of it) mean? this is from TaPL
16:33:29 <shapr> ddarius: Only one at the moment, 3.7" tire on a mountain unicycle.
16:33:43 <shapr> enolan: Which page?
16:33:45 <pumpkin> we really need the IRCTeX
16:33:50 <enolan> 27
16:33:52 <Valodim> now contact juggling on a unicycle must look neat
16:34:05 <augustss> enolan: union of all the S sub i
16:34:06 <ddarius> enolan: The union of the all the S_i
16:34:19 <Axman6> augustss: is it possible to play with the LLVM binding in ghci?
16:34:49 <augustss> Axman6: if you can figure out how to get ghci to load the libraries
16:34:58 <augustss> Axman6: I've not tried very hard
16:34:59 <enolan> that's what I thought
16:35:23 <Axman6> heh, ok, i won't bother (only had 5 hours sleep last night, half my usual holiday sleep time)
16:35:27 <juhp> btw when will gtk2hs-0.10.0 be officially releases, anyone know?
16:35:29 <ddarius> enolan: Think of it in analogy with summation (sigma) notation, if you are familiar with that.
16:36:40 <wli> Nothing seems to fall prey to the difference of squares obtained in that fashion.
16:36:41 <shapr> Aha, Hongwei Xi is mrd's advisor.
16:36:55 <shapr> mrd: Does Hongwei Xi offer any evening or weekend classes?
16:39:14 <shapr> The FP community is really tightly connected.
16:39:36 <shapr> I was sort of hoping Norman Ramsey had something on offer, since Tufts is a few blocks away from where I live :-)
16:39:52 <mrd> not that i know about
16:40:09 <mrd> I think NR has a regular class this semester
16:40:37 <shapr> Yeah, but it's like Wednesdays around lunch time. I doubt Raytheon would let me take that time off.
16:40:58 <augustss> shapr: where do you live?
16:41:11 <shapr> augustss: I live in Somerville and I work in Billerica.
16:41:24 * wli fails to smoke out useful criteria to rule out consideration of the majority of the n for which 2*n*n-1 may be prime.
16:41:33 <augustss> shapr: Somerville is nice
16:41:45 <shapr> augustss: Yeah, I'm learning Brazilian Portuguese :-)
16:42:13 <shapr> And I randomly asked some guy on a street corner for directions, and he turned out to be a coworker of Bryan O'Sullivan's (bos on #haskell).
16:42:23 <augustss> odd
16:42:31 <wli> shapr: In Portland?
16:42:34 <drhodes> I have an aunt in Billerica :) small world
16:42:48 <shapr> wli: Nah, I'm pretty sure bos works in SF.
16:43:01 <augustss> He does
16:43:39 <SamB> shapr: so how did you find this out ?
16:43:43 * ddarius is reminded of the woman at the bread place.
16:44:16 <shapr> SamB: I asked him if he'd ever heard of Haskell. You think I only proselytize online? :-)
16:44:36 <SamB> you ask that when asking for DIRECTIONS?
16:44:39 <shapr> Linden Labs has a location in Boston as well, so it's not too surprising.
16:44:47 <ddarius> SamB: Best to cover all bases.
16:45:09 <shapr> SamB: Nah, that was after I discovered this guy has a passion for cluster admin. We started talking about the hardware that Second Life uses.
16:45:47 <SamB> shapr: ah.
16:45:51 <SamB> that makes far more sense.
16:46:27 <shapr> enolan: I wonder if there's a #tapl channel for asking questions?
16:46:37 <shapr> hm, guess not.
16:50:16 <wli> Looks like the difference of squares can find some things but not many.
16:54:36 <roconnor> dons: do you guys at galois have some sort of monadLib-extras library, that would have modify, gets, and whatnot?
16:55:12 <dons> mmm. not afaik
16:55:15 <dons> glguy:
16:55:23 <dons> we just hack monadlib
16:55:51 <wli> What's in monadlib?
16:56:06 <dons> monads!
16:56:09 <roconnor> dons: what do you mean by hack?
16:56:18 <roconnor> @hackage monadLib
16:56:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monadLib
16:56:27 <dons> roconnor: someone sends a patch to iavor, and he applies it to the repo
16:56:54 <pumpkin> dons: got a moment?
16:57:55 <glguy> When we use monadlib for anything substantial, we rarely expose things like  get and set
16:57:58 <roconnor> dons: think If I add modify and gets, the patch would be accepted?
16:58:09 <roconnor> dons: monadLib seems minimal.  Maybe that is deliberate
16:58:17 <glguy> rather would use them in an internal definition to create new primitives for the monad
16:58:48 <mmorrow> haskell needs some form of ML modules bad!
16:59:14 <glguy> incidentally, I was just making an example of how to use MonadLib :) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1278
16:59:24 <roconnor> glguy: of course, but when developing your own monad commands, using get, set and modify is the way to go.
16:59:38 <wli> int80_h: Anyway, the idea (I think) is to smoke out some kind of theorem excluding most n between 2 and 50M from consideration, and then maybe something that lets you deduce primality for numbers of the form 2*n*n-1 more easily than usual.
16:59:53 <wli> mmorrow: Amen.
17:01:11 <wli> int80_h: I can't seem to get off the ground with criteria to exclude most of the range [2..50M]
17:01:25 <glguy> anyway, I don't know that Iavor would be opposed to such functions
17:01:30 <glguy> the topic has been discussed already
17:03:03 <Botje> wli: 2*n*n-1 is not divisible by any factor of n
17:04:51 <wli> Botje: Yeah, I can't get from there to thinning out the search space for filter isPrime [2*n*n-1|n <- [2..5*10^7]]
17:05:47 <byorgey> wli: is this Project Euler?
17:06:21 <wli> byorgey: Yeah, I'm trying (in theory) to help int80 and ending up not getting a whole lot done.
17:06:28 <byorgey> hehe, ok
17:06:36 <byorgey> yeah, I haven't solved that one either
17:08:39 <augustss> byorgey: which one is it?
17:08:54 <byorgey> augustss: 216
17:10:43 * glguy misses the old days when he had finished project euler
17:10:43 <wli> Maybe there's some k, q where n mod q = k implies 2*n*n-1 is composite.
17:11:19 * byorgey too
17:11:25 * ddarius misses the old days when he hadn't started Project Euler.  Oh wait, I still haven't started Project Euler.
17:11:32 <byorgey> =P
17:11:54 <augustss> that ones looks like it needs more than brute force
17:12:05 <dons> glguy: time to redo it in lennart-BASIC
17:12:23 <augustss> it's fast!
17:12:47 <tromp__> when will the magic og module BASIC be revealed?
17:12:53 <tromp__> of
17:12:54 <ddarius> @hackage BASIC
17:12:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BASIC
17:13:00 <wli> n = a*k+b where 2*b^2-1|a must certainly be composite.
17:13:06 <rwbarton> How often do new problems get added to project euler?
17:13:35 <wli> Provided b > 1 anyway.
17:14:35 <byorgey> rwbarton: maybe one a week, on average?
17:14:43 <byorgey> rwbarton: they tend to come in clumps though
17:16:02 <wli> Alternatively, n = a*k+b where a|2*b^2-1
17:17:32 <wli> If you ever do smoke out a composite 2*n^2-1 its divisors give you a sequence to knock out.
17:18:40 <augustss> Hmmm, brute force will take about a month of CPU time
17:19:00 <ddarius> So get a 32-core machine...
17:19:20 <dons> :)
17:19:23 <augustss> it could be quicker if the primes are rare
17:19:41 <SamB> ddarius: you are supposed to be able to do it in 5 minutes
17:19:50 <SamB> CPU-wise
17:20:30 <ddarius> > 32 * 24 * 12
17:20:34 <lambdabot>   9216
17:21:19 <pumpkin> one minute
17:21:46 <wli> augustss: I think you're supposed to derive theorems that dramatically thin out the search space.
17:21:47 <pumpkin> I thought the problems were designed to be solvable in one minute of an "average computer's" cpu time
17:22:05 <augustss> wli: i bet you are
17:22:18 <SamB> pumpkin: oh, was it one?
17:22:23 <pumpkin> I thought so
17:22:38 <SamB> well, I think I was close enough ;-P
17:22:43 <ddarius> > 9216*5
17:22:45 <lambdabot>   46080
17:23:28 <ddarius> So 2^16 cores very roughly to turn 1 month of CPU-time into 1 minute of real time.
17:23:46 <ddarius> (assuming pretty linear speed-up of course)
17:24:29 <SamB> ddarius: which is extremely unlikely!
17:24:40 <ddarius> Depends on the problem.
17:25:06 <augustss> Actually, my MacBook should be able to do it in 5 days of CPU time worst case (I actually time 64 by 32 bit divide instead of guessing)
17:25:44 <wli> I think we may be able to do something with n = a*k+b where a|2*b^2-1
17:25:44 <SamB> most PE problems can't be immediately decomposed into 2^16 subproblems of the same size ...
17:25:53 <augustss> This one can
17:26:12 <SamB> okay
17:26:14 <SamB> next argument
17:26:19 <augustss> roughly
17:26:27 <SamB> where are you going to get such a big CPU?
17:26:42 <SamB> well, I meant roughly the same size
17:26:46 <SamB> er.
17:26:50 <SamB> so many CPUs
17:26:53 <augustss> I'm not the one suggesting it.  I'm all for a clever trick
17:26:54 <ddarius> SamB: Start fabricating stack CPUs on a chip.
17:27:05 <SamB> ddarius: stack ?
17:27:20 <ddarius> SamB: As in Forth and such.
17:27:38 <augustss> you make a fake porn site and run the computations in Javascript on the machines of the people who visit
17:27:57 <SamB> augustss: I don't see how you can make a fake porn site
17:28:08 <augustss> ok, i'll put up some real porn :)
17:28:47 <pumpkin> don't forget to pay royalties to the artists!
17:29:14 <augustss> They'll get to know how many of the numbers that are prime
17:29:36 <ddarius> "Math Nerds Gone Wild !!!"
17:30:02 <tromp__> which euler problem are you discussing?
17:30:11 <augustss> 216
17:34:50 <wli> So first we get 2*9^2-1 = 7*23, so n = 9 mod 23 and maybe n = 9 = 2 mod 7
17:36:50 <wli> 2 mod 7 seems to work
17:37:28 <wli> The only case where 2*n^2-1 is prime when n mod 7 == 2 seems to be n=2, 2*n*n-1=7.
17:37:35 <BMeph> wli: +/- 2 mod 7. 5 is first. :)
17:37:54 <BMeph> wli: Er *secd ;p
17:37:58 <BMeph> **second
17:38:20 <wli> BMeph: 5 isn't of the form 2*n^2-1
17:38:40 <wli> Else 3 would have an integer square root.
17:39:06 <Olathe> > let pi d = 4*(f 3 1 d)/fromIntegral dSq where dSq = d*d; f _ _ 0 = 0; f p l n = sqrt (fromIntegral (dSq - l)) + f (p + 2) (l + p) (n - 1) in pi 100000
17:39:09 <lambdabot>   3.141572616401991
17:39:14 <mauke> http://www.superpoop.com/120108/divisible-by-zero.jpg
17:39:15 <rwbarton> wli: BMeph means that 2*5^2 - 1 isn't prime because it's divisible by 7
17:39:23 <BMeph> wli: I meant 2*(5)^2-1. :p
17:39:44 <BMeph> rwbarton: Yes, thank you. :)
17:39:58 <wli> 5 isn't of the form 7*k+2 so it's not pertinent.
17:40:52 <wli> n = 9 mod 23 has n = 78, 2*n^2-1 = 12167 = 23^3
17:40:59 <BMeph> wli: Oh, you're doing where it _is_ prime? Hmm, aren't most of them prime?
17:41:23 <tromp__> 216 looks quite feasible
17:41:29 <BMeph> wli: Okay, 2202 out of 10k, so never mind.
17:41:33 <wli> BMeph: I'm trying to rule out most n from consideration for 2*n^2-1 being prime.
17:41:50 <ambrjn> i need a mentor
17:41:54 <tromp__> with a modified sieve
17:41:54 <ambrjn> someone who knows happs inside out ;)
17:42:13 <wli> BMeph: length $ filter isPrime [2*n^2-1 | n <- [2..50*10^6]]
17:42:35 <tromp__> u only need primes up to 50<
17:42:36 <tromp__> 50M
17:43:04 <Cale> mauke: I love that one
17:43:05 <wli> No, you need n up to 50M, so 2*50M^2-1
17:43:06 <pumpkin> ambrjn: there's a dedicated happs channel that might have more potential mentors :)
17:43:15 <somnolence> what's the best way to filter multiples of number n from list l?
17:43:16 <ambrjn> no kidding
17:43:18 <rwbarton> tromp__: Yeah, you just need to figure out for which n 2n^2-1 is divisible by p, which isn't too hard
17:43:22 <tromp__> you need not compute any 2n*2-1
17:43:53 <BMeph> Yeah, so up to 70M, then. :)
17:43:57 <wli> tromp: Why not?
17:44:09 <Olathe> > let pi d = 4*(f 3 1 0 d)/fromIntegral dSq where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt (fromIntegral (dSq - l)) in r' `seq` f (p + 2) (l + p) r' (n - 1) in pi 1000000
17:44:17 <lambdabot>   3.141590652413929
17:44:28 <redditbot> Conal Elliott : From the chain rule to automatic differentiation
17:44:35 <tromp__> right rwbarton, you just consider all primes up to 50M, and for each one, you remove all n for which p divides 2n*2-1
17:44:57 <BMeph> tromp__: 70M. :)
17:45:01 <wli> That sounds insanely slow.
17:45:04 <tromp__> so you first check that (p+1)/2 is a quadratic residue mod p
17:45:26 <rwbarton> yeah
17:45:29 <tromp__> and if it's, say a^2, then you strike out all n that are +-a mod p
17:46:19 <dolio> tromp__: It's 2*n^2-1 prime for n <= 50,000,000.
17:46:25 <BMeph> tromp__: For all p < 70M? THat does sound like a lot of work for a prelim filter.
17:46:27 <dolio> Not for 2*n^2-1 <= 50,000,000.
17:46:36 <Taejo> :t first.second$(const 10)
17:46:38 <lambdabot> forall d b c d1. (Num c) => ((d1, b), d) -> ((d1, c), d)
17:46:50 <Taejo> > first.second$(const 10) (('b',7),"hallo")
17:47:04 <rwbarton> how easy is it to compute square roots mod p though?
17:47:06 <Taejo> > first.second$(const 10) $ (('b',7),"hallo")
17:47:16 <tromp__> the total work is only O(nlongn) with n=50M
17:47:25 <tromp__> nO(n log n)
17:47:36 <tromp__> darn, O(n log n)
17:47:54 <mofmog> so i just made a data type that is an instance of Num
17:48:10 <BMeph> mofmog: Congratulations! :)
17:48:14 <mofmog> i've defined what to do if you add two of said data types together for example
17:48:24 <mofmog> but how do i dispatch on "mismatched" data types so to speak
17:48:55 <Olathe> You use different constructors on the same type.
17:48:55 <mofmog> moreover, i want to define (**) for it, but then wouldn't i also have to define sin and cos etc on it too since (**) is part of Fractional?
17:49:00 <tromp__> sqaure roots mod p is hard for really big p
17:49:02 <wli> dolio/tromp: It's [2*n^2-1 | n <- [2..50000000]] not takeWhile (<=50000000) [2*n^2-1|n<-[2..]]
17:49:11 <tromp__> some crypto is based on that
17:49:23 <BMeph> mofmog: 1) You don't 2) Yes. :)
17:49:43 <wli> 5 mod 7 looks like it's out also.
17:49:48 <rwbarton> mofmog: It's impossible to call (+) on two arguments of different type.
17:49:53 <tromp__> yes, 5 = -2 mod 7
17:49:55 <mofmog> i'm trying to define discrete random variables built off of bernoulli r.vs
17:50:17 <mofmog> and assuming X and Y were RVs id like a seemless way to multiply two rvs together or a scalar and an rv
17:50:39 <Olathe> > 4^3 `mod` 7
17:50:45 <Olathe> @bot
17:50:46 <lunabot>  :)
17:50:51 <Olathe> , 4^3 `mod` 7
17:50:52 <lunabot>  1
17:51:04 <wli> I get n = 2 mod 7, n = 5 mod 7, n = 3 mod 17, n = 14 mod 17, n = 9 mod 23, n = 14 mod 23, n = 4 mod 31, n = 27 mod 31, n = 12 mod 41, n = 20 mod 47, n = 27 mod 47, etc.
17:51:12 <mofmog> , 4^6 `mod` 7
17:51:13 <lunabot>  1
17:51:27 <Olathe> , map (\n -> 4^n `mod` 7) [0..6]
17:51:28 <mofmog> 2313434^28 `mod` 29
17:51:30 <lunabot>  [1,4,2,1,4,2,1]
17:51:43 <mofmog> , 234234^28 `mod` 29
17:51:44 <lunabot>  1
17:51:55 <Taejo> Every type of kind * -> * is a monad!
17:51:58 <mofmog> i see lunabot has the discretemath theorems extensions
17:52:06 <rwbarton> wli: yes, this is the sieve that tromp__ and I are talking about
17:52:15 <ddarius> Taejo: Every type of that kind isn't even a functor necessarily.
17:52:23 <ddarius> Taejo: E.g. Endo
17:52:47 <Olathe> , map (\n -> n^2 `mod` 7) [0..6]
17:52:48 <lunabot>  [0,1,4,2,2,4,1]
17:52:56 <wli> You guys must have immediately spotted what it took me all day to come up with and then took it vastly further in no time flat.
17:53:09 <Taejo> ddarius: {return = undefined, (>>=) = undefined} is a monad, isn't it?
17:53:17 <BMeph> wli: 29 mod 41? :)
17:53:19 <wli> I had an idea quadratic residues were involved but couldn't figure out how to use them directly on the problem.
17:53:35 <wli> BMeph: It doesn't show up in the list but it's probably eventually there.
17:53:36 <mofmog> ,map (\x -> 2353545^(x-1) `mod` x) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
17:53:38 <lunabot>  [1,0,0,1,1,1,1,1,1,1]
17:53:52 <mofmog> wait that doesn't make sense
17:53:59 <ddarius> Taejo: No, it isn't. undefined >>= Just should be Just undefined, not undefined.
17:54:02 <mofmog> hmmm
17:54:03 <mofmog> oh
17:54:04 <mofmog> dang
17:54:25 <somnolence> how do you filter one list from another?
17:54:31 <mauke> \\
17:54:39 <Olathe> > [1..10] \\ [9..12]
17:54:45 <mofmog> , 4^2 `mod` 3
17:54:46 <lunabot>  1
17:54:47 <Olathe> , [1..10] \\ [9..12]
17:54:48 <lunabot>  [1,2,3,4,5,6,7,8]
17:55:01 <somnolence> right -.-
17:55:02 <Taejo> ddarius: oh, right... that's what happens when I try to be smart
17:55:08 <mofmog> , 6^2 `mod` 3
17:55:10 <lunabot>  0
17:55:25 <mofmog> oh right, n can't be a multiple of p
17:55:37 <ddarius> Sorry, that should have been return undefined >>= Just.
17:56:28 <BMeph> > undefined >>= Just
17:56:36 <BMeph> , undefined >>= Just
17:56:37 <lunabot>  luna: Prelude.undefined
17:56:46 <mauke> @bot
17:56:46 <lunabot>  :)
17:56:57 * BMeph shakes his head at lunabot, disappointed.
17:57:08 <aluink> what is the haskellers prefered distro?
17:57:16 <mofmog> House
17:57:18 <CakeProphet> hmmm... could you use arrows to model a dataflow paradigm?
17:57:20 <Olathe> aluink: Windows XP
17:57:22 <ddarius> aluink: Whichever one they are currently using.
17:57:34 <ddarius> CakeProphet: Sure, if you wanted to.
17:57:37 <aluink> Olathe: right ;)
17:57:39 <BMeph> Olathe, ddarius: Not true. ;)
17:57:40 <mofmog> isn't that what FRP is anyway
17:57:45 <pumpkin> should I fetch pumpkinbot?
17:57:51 <mofmog> in a certain sense i guess not really
17:58:20 <aluink> reason i ask is cause i think i've finally gotten sick of Ubunut, and i'm looking for an alternate
17:58:33 <Olathe> > [1, 1 + 3, 1 + 3 + 5, 1 + 3 + 5 + 7]
17:58:38 <Olathe> , [1, 1 + 3, 1 + 3 + 5, 1 + 3 + 5 + 7]
17:58:39 <lunabot>  [1,4,9,16]
17:58:42 <Olathe> Foolish lambdabot !
18:00:03 <pumpkin> @bot
18:00:03 <pumpkinbot> :)
18:00:03 <lunabot>  :)
18:00:18 * wli isn't sure how much this actually this out the search space.
18:00:59 <Olathe> Yay !
18:01:20 <rwbarton> wli: the point is now you can adapt the sieve of eratosthenes but instead of crossing out the multiples of p, cross out those n for which 2*n^2 - 1 is 0 mod p
18:01:32 <rwbarton> by first finding a square root of 1/2 mod p
18:01:57 <tromp__> for prime moduli, computing square roots is efficient but requires randomization
18:02:19 <tromp__> http://en.wikipedia.org/wiki/Shanks-Tonelli_algorithm
18:03:00 <wli> I had this idea that the square root of the inverse of 2 somehow yielded a nontrivial divisor of 2*n*n-1 but got wrong answers somewhere.
18:03:40 <rwbarton> tromp__: the second email of http://www.math.niu.edu/~rusin/known-math/94/sqrt.mod has a nice algorithm (which also requires some guesswork though)
18:04:11 <wli> I'm not sure this is the part that needs to be fast.
18:04:15 <wli> Maybe it does.
18:04:29 <rwbarton> Well it needs to run in sublinear time in p at least.
18:07:13 <tromp__> is there a haskell library that has things like legendre & jacobi symbol?
18:10:19 <Monk1> Hello, I've just heard about haskell earlier today and decided to try it out. Anyways, I have a quick question on function definitions.  At http://www.haskell.org/tutorial/functions.html they expalin the function definition of map. The part that is confusing me is (a->b) ->[a]->[b]. This means that the 1st arguemnt is of type a that returns type b, the 2nd argument is a list of type a, and the function returns an array of type b.
18:10:47 <Monk1> The thing that confuses me is why won't , for the 2nd argument, specifying a list of type b work?
18:11:04 <Monk1> Oh, and sorry, replace array with list in the 1st paragraph.
18:12:07 <nanothief> Monk1: it will. a means any type, b means any type, so a can equal b if it is needed. Eg
18:12:11 <gwern> :t (*2)
18:12:11 <nanothief> > map (+2) [1,2,3]
18:12:12 <gwern>  > map (*2) [1..10]
18:12:13 <pumpkinbot> forall a. (Num a) => a -> a
18:12:13 <pumpkinbot>   [3,4,5]
18:12:35 <Olathe> > map (++"zomg") ["Hello", "How are you"]
18:12:36 <pumpkinbot>   ["Hellozomg","How are youzomg"]
18:12:39 <gwern> hm. race condition in lb?
18:12:40 <gwern>  > map (*2) [1..10]
18:12:47 <rwbarton> Monk1: if we call the first argument to map "f", then the second argument needs to be a list of values of the type of the domain of f, so that we can apply f to them
18:12:57 <Olathe> > map (*3) [1..10]
18:12:58 <pumpkinbot>   [3,6,9,12,15,18,21,24,27,30]
18:12:59 <nanothief> gwern: Ii won the race :)
18:13:00 <gwern> oh, d'oh I had a leading space
18:13:01 <Olathe> > map (*2) [1..10]
18:13:03 <pumpkinbot>   [2,4,6,8,10,12,14,16,18,20]
18:13:08 <gwern> nanothief: that you did!
18:14:22 <tonyIII_> ghc keeps swapping memory when linking, any way to get out of this?
18:14:53 <ddarius> @bot
18:14:53 <lunabot>  :)
18:14:54 <pumpkinbot> :)
18:14:54 <gwern> tonyIII_: you are using split-objs?
18:15:01 <lambdabot> :)
18:15:05 <pumpkin> omg!
18:15:08 <pumpkin> it woke up
18:15:15 <pumpkin> > 1
18:15:17 <pumpkinbot>   1
18:15:25 <pumpkin> or maybe not
18:15:25 <lambdabot>   1
18:15:26 <rwbarton> still a little groggy
18:15:33 <pumpkin> wow, quite groggy
18:15:34 * SamB wonders whose bug http://code.google.com/p/ndmitchell/issues/detail?id=151 really is
18:15:47 <pumpkin> worth getting rid of pumpkinbot you think?
18:16:22 <gwern> wait a while and see if lb will stay
18:17:01 <Monk1> rwbarton: hm, i think i understand now. I was thinking for some reason that a b where already similar types....
18:18:10 <Monk1> anyways, thank you both for the help.
18:18:34 <tonyIII_> gwern: I am doing cabal install of lambdabot, the final link almost hangs my 500M RAM machine for a few seconds. I wonder if it can be made to be more friendly.
18:19:05 <pumpkin> isn't the link just done by ld?
18:19:19 <ddarius> pumpkin: Yes.
18:19:32 <gwern> tonyIII_: oh, 500megs? that might just be normal then
18:20:04 <gwern> gnu ld is not the memory-thriftiest linker around, I understand, and lb has a lot of deps and code
18:21:07 <tonyIII_> gwern: Wow, that's quite surprising. Thanks, gwern.
18:24:37 <SamB> is there any way to get type variables out of TH that don't print like this?
18:24:39 <SamB> Prelude Language.Haskell.TH> $(sigE [| 1 |] (varT =<< newName "a"))
18:24:39 <SamB> <interactive>:1:2: Not in scope: type variable `a[a1nT]'
18:26:28 <rwbarton> , [| 1 :: a |]
18:26:29 <lunabot>  SigE (LitE (IntegerL 1)) (ForallT [a_0] [] (VarT a_0))
18:27:01 <SamB> I mean, after they get spliced
18:27:10 <SamB> I don't care what they print like BEFORE they are spliced
18:27:18 <SamB> but I'd prefer my haddocks not to look like this:
18:27:24 <rwbarton> I was just curious why you were getting the erorr
18:27:46 <SamB> tvrInfo_s :: forall e[aq1x]. Info -> TVr' e[aq1x] -> TVr' e[aq1x]
18:27:59 <SamB> rwbarton: because it ISN'T in scope, probably
18:28:22 <SamB> the error was intentional
18:28:23 <Saizan> can you avoid using newName?
18:28:37 <SamB> actually, in the real code I didn't use newName
18:28:53 <SamB> they came from a reify
18:28:55 <rwbarton> SamB: sure, but it *looks* as though you wrote 1 :: a, which is valid Haskell
18:29:12 <SamB> rwbarton: I think TH needs explicit foralls ...
18:29:24 <rwbarton> SamB: Yeah, that's what I found out. :)
18:29:31 <Saizan> , sigE [| 1 |] (varT =<< newName "a")
18:29:32 <lunabot>  SigE (LitE (IntegerL 1)) (VarT a_0)
18:30:05 <SamB> unfortunately, those get printed out indiscriminantly
18:31:59 <Saizan> ?hackage haskell-src-meta
18:31:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
18:31:59 <pumpkinbot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
18:32:09 <pumpkin> > 1
18:32:11 <pumpkinbot>   1
18:32:11 <lambdabot>   1
18:32:19 <pumpkin> pumpkinbot: @part #haskell
18:32:31 <rwbarton> If I have a context (Foo (a, b)), and an instance (Foo a, Foo b) => Foo (a, b) in scope, can ghc deduce the context Foo a?
18:33:06 <Saizan> no
18:33:16 <SamB> it's not GHC's fault, though
18:33:20 <rwbarton> ok, that was my guess
18:33:55 <BMeph> rwbarton: I'd hope not. That's not likely true, except by coincidence. :)
18:33:56 <mauke> why not?
18:34:39 <rwbarton> BMeph: If I do not have OverlappingInstances then there must in fact be an instance Foo a somewhere, right?
18:35:43 <mauke> I think of instance declarations as pattern matching + function calls
18:36:12 <mauke> in this case "if the pattern Foo (a, b) matches, call Foo a and Foo b"
18:36:26 * wli had to take care of real life; did anything happen on primes of the form 2*n^2-1?
18:36:33 <ddarius> rwbarton: It can't deduce Foo a but it can simplify to (Foo a, Foo b)
18:36:44 * BMeph doesn't think so, wli. :)
18:38:26 <Saizan> , reify ''Maybe
18:38:27 <lunabot>  luna: No instance for (GHC.Show.Show
18:38:35 <ddarius> :t undefined :: Monoid (a,b) => (a,b)
18:38:37 <lambdabot> forall a b. (Monoid b, Monoid a) => (a, b)
18:38:49 <mauke> nice
18:39:53 <wli> The second supplement to quadratic reciprocity deals with sqrt(2) mod p.
18:40:09 <wli> p = +/-1 mod 8 is the conclusion IIRC.
18:41:31 <rwbarton> argh, the new hpaste is broken now?
18:43:32 <ddarius> rwbarton: Haskell software just isn't reliable.
18:43:51 <rwbarton> this is the kind of thing I'm wondering about: http://rafb.net/p/CHQE6T42.html
18:44:19 <SamB> rwbarton: broken how ?
18:44:21 * ddarius writes hpaste3 in PHP.
18:44:36 <rwbarton> SamB: It failed when I tried to create a new paste
18:44:53 <rwbarton> 500 Internal Server Error
18:44:54 <rwbarton> 58030 5: Unable to close due to unfinalised statements
18:45:36 <SamB> maybe he's using MySQL
18:45:48 <Saizan> the one at moonpatio.com works?
18:45:51 <SamB> mmorrow: fix it please ?
18:46:10 <rwbarton> Saizan: oh, apparently so.
18:46:16 <SamB> why are they not the same one ???
18:46:32 <rwbarton> I assumed hpaste.org was a CNAME...
18:46:37 <SamB> me too
18:46:55 <mauke> rwbarton: I don't understand how baz can return a tuple for p
18:46:56 <SamB> why are they the same color if they have different content ?
18:47:25 <rwbarton> mauke: because p is unified with (x, y) because of the pattern match on W
18:47:33 <mauke> huh?
18:47:55 <Saizan> that's how GADTs work
18:48:02 <SamB> yeah, that is how GADTs work
18:48:03 <mauke> oh, d'oh
18:48:17 <mauke> I keep forgetting that parameters are ignored in GADTs
18:49:59 <Saizan> http://rafb.net/p/KCvbp360.html <- who wants to prove associativity for me?
18:50:09 <mauke> aw, data Weird _ is invalid
18:50:52 <Saizan> data Weird :: * -> * where ..
18:50:58 <Saizan> with KindSignatures
18:51:04 <rwbarton> yeah I usually prefer the KindSignatures style
18:51:40 <rwbarton> Saizan: Foo m is the monoid generated by m and a new generator S with the relation xS = S for every x in m
18:51:51 <rwbarton> Saizan: and also SS = S
18:52:07 <rwbarton> Saizan: associativity follows
18:53:24 <Saizan> rwbarton: can you expand "generated by"?
18:55:01 <rwbarton> Saizan: an element of Foo m is a sequence of symbols which are either elements of m or the symbol S
18:55:27 <rwbarton> Saizan: with relations that say that the product of two elements of m is their product in m, and any product xS is equal to S
18:55:39 <ddarius> I.e. the free monoid on Maybe m or [Maybe m]
18:55:45 <rwbarton> Saizan: using those relations you can write any element uniquely in the form m or Sm
18:56:16 <chessguy> anybody know if http://citeseer.ist.psu.edu/335780.html has been turned into a hackage module?
18:56:43 <Gracenotes> what do N and S represent here?
18:56:54 <ddarius> chessguy: I don't think that in particular has (but maybe) but I think similar things have.
18:57:04 <rwbarton> right, in that notation we have rules [Just x, Just y] -> [Just (x `mappend` y)] and [Just _, Nothing] -> [Nothing]
18:57:27 <rwbarton> and [Nothing, Nothing] -> [Nothing]
18:57:36 <BMeph> Gracenotes: I'd guess "Not S" and "S", respectively. ;)
18:57:42 * pumpkin does the dons-summoning dance
18:57:51 <Saizan> rwbarton: but my S contains an element of 'm'
18:57:56 * sbahra is summoned 
18:58:05 <pumpkin> sbahra: wow!
18:58:13 <pumpkin> I need to perfect my dancing technique I guess
18:58:19 <pumpkin> but I'm glad I managed to summon someone
18:58:23 <rwbarton> Saizan: Yeah.  the constructor S m corresponds to the element Sm or [Nothing, Just m]
18:58:49 <chessguy> @hoogle ApplyCons
18:58:49 <lambdabot> No results found
18:58:54 <rwbarton> while the constructor N m corresponds to just m
18:58:59 <Gracenotes> that's some lovely C++, by the way
18:59:47 <Saizan> rwbarton: ah i see, since there's not rule for Sm i just keep it as it is
18:59:53 <rwbarton> Saizan: Yes
19:00:21 <kerlo> So, to find a list of axioms of first-order logic and declare each one to be a combinator.
19:02:08 <kerlo> Is there a finite set of axioms of first-order logic?
19:02:16 <Gracenotes> well, there's http://en.wikipedia.org/wiki/List_of_first-order_theories thought as the title says they're a bunch of theorems
19:02:39 <Gracenotes> -t
19:02:41 <kerlo> Theories and theorems are very different things.
19:03:08 <pumpkin> it's just a theory! ;)
19:03:24 <Gracenotes> er, yes, that's correct... either way, they might not be axioms.
19:03:43 <kerlo> pumpkin, you just made the word "theory" meaningless. Congratulations.
19:03:45 <Gracenotes> I dunno. http://en.wikipedia.org/wiki/List_of_axioms maybe
19:04:07 <pumpkin> kerlo: I was mocking people who said that, but IRC isn't the best place for sarcasm
19:04:20 <Gracenotes> kerlo: http://en.wikipedia.org/wiki/Theory .. can you see that Ilove this?
19:04:58 <Gracenotes> oh, it's been reverted. Never mind.. argh vandals.
19:05:32 * wli doesn't quite get how a sieve of Eratosthenes -like affair is possible apart from the use of a wheel -like affair.
19:06:14 <chessguy> @pl s c = t c (g c)
19:06:14 <lambdabot> s = ap t g
19:06:42 <kerlo> pumpkin: I know.
19:07:00 <kerlo> Gracenotes: that's what the "permanent link" link is for. :-)
19:08:21 <Gracenotes> kerlo: oh, sorry. Here: http://en.wikipedia.org/w/index.php?title=Theory&oldid=264358440#Usage
19:09:33 <Gracenotes> this version may also lend especial insight: http://en.wikipedia.org/w/index.php?title=Theory&oldid=258211912
19:10:32 <pumpkin> especial!
19:10:54 <pumpkin> muy especial
19:11:41 <kerlo> The word "especially" is rather weird.
19:13:06 <pumpkin> dmwit has connection issues :P
19:13:10 <lament> the word "rather" is especially weird.
19:13:37 <kerlo> The word "weird" is rather especially.
19:15:19 <Gracenotes> c'mon now, folks. This is exactly how useless threads on reddit get started.
19:15:20 <Olathe> The word "word" is like totally meta.
19:15:26 <Gracenotes> see?!?!?
19:16:38 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/bthreads/1233183689999.jpg
19:17:03 <Olathe> > let pi d = 4*(f 1 dSq 0 d)/dSq where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt l in r' `seq` f (p + 2) (l - p) r' (n - 1) in pi 5000000
19:17:15 <lambdabot>   3.1415930534842986
19:19:41 <Olathe> > let pi d = 4*(f 1 dSq 0 d)/dSq where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt l in r' `seq` f (p + 2) (l - p) r' (n - 1) in pi 5000000 :: Float
19:19:53 <lambdabot>   3.093721
19:20:54 <BMeph> mauke: Heh-heh - "priceless"! 8D
19:21:02 <rwbarton> > let pi d = 4*(f 1 dSq 0 d)/dSq where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt l in r' `seq` f (p + 2) (l - p) r' (n - 1) in pi 5 :: Expr
19:21:03 <lambdabot>   4 * (0 + sqrt (5 * 5) + sqrt (5 * 5 - 1) + sqrt (5 * 5 - 1 - (1 + 2)) + sqr...
19:21:36 <rwbarton> ah
19:22:29 <shapr> ddarius: Hongwei Xi responds quickly :-)
19:22:42 <Olathe> Ahh, Expr is a nice trick :)
19:22:58 <ddarius> shapr: Coolsville.
19:23:14 * wli is at a loss for an Eratosthenes-like algorithm.
19:23:42 <ddarius> shapr: Any good advice?
19:23:44 <rwbarton> > let pi d = 4*(f 1 dSq 0 d)/dSq where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt l in r' `seq` f (p + 2) (l - p) r' (n - 1) in reduce $ pi 5
19:23:46 <lambdabot>   4 * (0 + sqrt 25 + sqrt (5 * 5 - 1) + sqrt (5 * 5 - 1 - (1 + 2)) + sqrt (5 ...
19:23:52 <rwbarton> > let pi d = 4*(f 1 dSq 0 d)/dSq where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt l in r' `seq` f (p + 2) (l - p) r' (n - 1) in reduce . reduce $ pi 5
19:23:53 <lambdabot>   4 * (0 + 5.0 + sqrt (5 * 5 - 1) + sqrt (5 * 5 - 1 - (1 + 2)) + sqrt (5 * 5 ...
19:24:03 <Olathe> @type reduce
19:24:04 <lambdabot> Expr -> Expr
19:24:21 <rwbarton> > let pi d = 4*(f 1 dSq 0 d)/dSq where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt l in r' `seq` f (p + 2) (l - p) r' (n - 1) in iterate reduce (pi 5) !! 50
19:24:22 <lambdabot>   3.4370488288835515
19:24:23 * wli is clueless or something.
19:24:25 <rwbarton> > let pi d = 4*(f 1 dSq 0 d)/dSq where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt l in r' `seq` f (p + 2) (l - p) r' (n - 1) in iterate reduce (pi 5) !! 10
19:24:27 <lambdabot>   4 * (9.898979485566356 + sqrt (24 - 3) + sqrt (5 * 5 - 1 - (1 + 2) - (1 + 2...
19:24:50 <bobshush> @source getStdRandom
19:24:50 <lambdabot> getStdRandom not available
19:25:18 <Olathe> It's 4/5^2 * sum of sqrt(5^2 - n^2) for n from 0 to 4 or something.
19:25:57 <Olathe> > 4/25 * sum (map (\n -> sqrt (25 - n^2)) [0..4])
19:25:58 <lambdabot>   3.4370488288835515
19:27:17 <Olathe> Hmmm...
19:27:34 * BMeph thinks wli should bone up by (re-)reading Melissa O'Neill's paper, and stop all the self-abuse :)
19:27:39 <Olathe> > let pi d = 4/dSq*f 1 dSq 0 d where dSq = d*d; f _ _ r 0 = r; f p l r n = let r' = r + sqrt l in r' `seq` f (p + 2) (l - p) r' (n - 1) in pi 5000000
19:27:51 <lambdabot>   3.1415930534842986
19:28:02 <Olathe> Yay, less parentheses.
19:28:19 <wli> BMeph: That's for finding just any primes, not primes of the form 2*n^2-1.
19:30:07 <BMeph> \wli: Have you considered starting the sieve with 'map  (\x -> 2*x^2-1) [1..]' instead of [2..]? :)
19:30:10 * SamB wonders if stepcut has tried using Haddock HEAD
19:30:43 <wli> BMeph: What point is there?
19:31:01 <Olathe> 2*x^2 - 1 ?
19:31:04 <Olathe> Hmm...
19:31:16 <Olathe> > map (\x -> 2*x^2 - 1) [1..10]
19:31:18 <lambdabot>   [1,7,17,31,49,71,97,127,161,199]
19:31:34 <somnolence> does `div` ceiling, floor, or round?
19:31:55 <BMeph> somnolence: I think you a verb there, buddy. ;)
19:31:56 <rwbarton> somnolence: floor
19:32:08 <somnolence> rwbarton: oh no >_< lol
19:32:10 <Olathe> > let xs = f 6 1 where f a r = r:f (a + 4) (r + a) in take 10 xs
19:32:11 <tromp__> > -5 `div` 3
19:32:11 <lambdabot>   [1,7,17,31,49,71,97,127,161,199]
19:32:13 <lambdabot>   -1
19:32:13 <ddarius> floor or truncate ?
19:32:14 <Taejo> > (-1) `div` 2
19:32:16 <lambdabot>   -1
19:32:19 <Taejo> floor
19:32:24 <Olathe> There's a nicer one, I think
19:32:27 <Taejo> > 1 `div` (-2)
19:32:28 <lambdabot>   -1
19:32:29 * BMeph agrees with rwbarton, as far as the question made sense...
19:32:48 <Taejo> > 1 `quot` (-2)
19:32:49 <lambdabot>   0
19:32:56 <Taejo> > (-1) `quot` 2
19:32:58 <lambdabot>   0
19:33:06 <ddarius> @check \x y -> x `div` y == floor (fromIntegral x / fromIntegral y)
19:33:07 <lambdabot>   "* Exception: divide by zero
19:33:16 <ddarius> @check \x y -> y /= 0 ==> x `div` y == floor (fromIntegral x / fromIntegral y)
19:33:17 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
19:33:17 <lambdabot>           ...
19:33:28 <somnolence> > 5 `div` 2
19:33:29 <lambdabot>   2
19:33:34 <Gracenotes> mauke: is there no end??
19:33:55 <ddarius> Gracenotes: Well there are only 942 comments in the thread.
19:33:56 <BMeph> wli: How about sieve on a pair, one side has all the primes, the other side has the 2*x^2-1's? :)
19:34:18 <wli> BMeph: That's preposterously naive.
19:35:01 <Gracenotes> ddarius: or I could just download the JSON data and find the deepest branch..
19:35:07 <chessguy> @pl f c = n . (i c)
19:35:07 <lambdabot> f = (n .) . i
19:35:09 * rwbarton wonder whether BMeph has an irc client configured to append a random smiley to each line
19:35:37 <wli> BMeph: It's not possible to exhaustively examine the n's between 2 and 50M; one can only tolerate some suitably thin field of candidates being generated at all.
19:35:54 * BMeph wonders about rwbarton's choice of things to wonder about... =8*O
19:36:26 <Gracenotes> "phire 19 points 5 months ago[+] (1400 children)" whaat... and I've been following it for 10 minutes...
19:36:31 <BMeph> wli: I love you, too.
19:36:47 <pumpkin> BMeph: you forgot the random smiley ;)>=
19:36:49 <ddarius> Gracenotes: Possibly, when you click one of the "continue this thread ->" links it will take you back some comments leading to a cycle in the thread.
19:37:15 * Gracenotes downloads the JSON data
19:37:32 <jrib> "The Haskell Road to Logic, Math, and Programming" looks interesting.  How much (if at all) do I need to worry about regarding language/ghc changes since 2004?
19:38:19 <ddarius> jrib: You shouldn't need to worry at al.
19:38:36 <ddarius> Furthermore, for what that book is aimed at, such details would not be particularly important.
19:38:36 <jrib> ddarius: thanks
19:38:42 <wli> It looks like if you're going to do a wheel it should have at most the first 5 primes p = +/-1 mod 8.
19:39:12 <wli> But that only thins the field by 48.7%
19:39:24 <pumpkin> 32.33, recurring of course
19:40:00 * BMeph jumps up and starts to code, saying, "Okay, let's do this..."
19:40:36 <wli> Here it takes 40.59s just to tabulate the wheel on the first 5 so...
19:41:13 <wli> 0.9s for a wheel on the first 4 primes p = +/-1 mod 8, though, so that's a bit more promising.
19:42:41 <Gracenotes> or... I can just look at the RSS feed. duh.
19:43:00 * ddarius thinks Gracenotes is spending entirely too much effort on this.
19:43:03 <kerlo> Okay, looking for a set of first-order logic axioms is boring. I want to roll my own.
19:43:32 <jrib> start with x != x, that makes it easy
19:43:32 <ddarius> kerlo: You don't have them memorized?
19:43:35 <Gracenotes> indeed, is there such a thing?
19:44:24 <kerlo> ddarius: I think I have the ZFC axioms memorized well enough.
19:44:33 <kerlo> But no, not a set of first-order logic axioms.
19:45:09 <kerlo> There can't be many primitive thingies. Forall, implication, falsehood.
19:45:16 <ddarius> kerlo: You know what all the connectives of FOL are, yes?
19:45:16 <kerlo> That sounds like plenty.
19:45:36 <kerlo> Who needs connectives when you have forall? :-P
19:46:35 <kerlo> Implication is a forall, even, if you take full advantage of the Curry-Howard isomorphism.
19:46:44 <gio123> @seen ski_
19:46:44 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I don't know when ski_ last spoke.
19:47:20 <ddarius> kerlo: Well you can apply the Sheffer stroke and get all of propositional logic down to a single binary connective and then tack universal quantification on to that.
19:47:29 <kerlo> Eh.
19:48:51 <ddarius> kerlo: If you are interested in making combinators corresponding to a logic, probably the most natural way to get there is via a Hilbert presentation of the logical axioms.
19:49:59 <kerlo> Some nice axioms are S, K, I, callCC, void, and all the lambda axioms.
19:50:55 <kerlo> And the * axiom: "there exists a sentence". It's the only thing that's a proof of itself. :-)
19:53:46 <kerlo> Yep, here's a notation that takes some getting used to: _=>_ :: * => \a -> a => \_ -> *
19:56:08 <allbery_b> I have 70 messages in my inbox about widget toolkits.  Worth reading, or even skimming?
19:56:43 <allbery_b> (ti took me all day to get therough the *other* huge haskell-cafe threads...
19:58:10 <ddarius> The "Why binding" one.  If you are interested in functional GUIs, FRP, and "semantic design", you might find it mildly interesting, though it's not a very "deep" or technical thread.
19:59:14 * kerlo ponders the types of the S combinator and callCC in full-out dependent typing
19:59:23 <chessguy> @pl \x -> (x, f x)
19:59:23 <lambdabot> ap (,) f
20:00:11 <Gracenotes> I have found the end -- http://www.reddit.com/r/science/comments/6nz1k/got_six_weeks_try_the_hundred_push_ups_training/c07j7vc
20:00:21 <chessguy> @index ap
20:00:21 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
20:00:21 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
20:01:34 <Gracenotes> now I should do something useful to balance out the sloth
20:03:55 <kerlo> If x z (y z) is well-typed, then x takes z to return something which takes y z to return the end result...
20:04:25 <allbery_b> might wait for someone on planet haskell to blog the cliff's notes :)
20:04:45 <allbery_b> (or they already have, my blogroll's even farther behind than my mail)
20:05:31 <ddarius> allbery_b: The thread isn't coherent/information dense enough to both with a blog post.
20:06:00 <mmorrow> rwbarton: heh, crap i guess i didn't actually test that it worked :/
20:06:04 <ddarius> HWN might have a brief summary.
20:06:13 <mmorrow> i think it's the permissions on the sqlite db
20:06:31 <rwbarton> mmorrow: ah, yeah, googling indicated it was an sqlite error
20:06:38 <mmorrow> no wonder no one's been pasting there :)
20:09:52 <kerlo> Looks like my S combinator is going to take nine arguments.
20:10:01 <mmorrow> crap, it wasn't that
20:10:10 <mmorrow> oh wait, maybe i have to restart it
20:10:25 <mmorrow> if that's not it, then maybe the sqlite lib is too old
20:10:51 <kerlo> No, only six...
20:11:53 <mmorrow> grrr, i'm out of ideas. i'll figure it out
20:11:54 <ddarius> kerlo: Note that what you are probably talking about isn't "full-out dependent typing" but explicit type abstractions and instantiations.
20:12:06 * kerlo shrugs
20:12:18 <somnolence> how can I map a double into a list of each digit of the double?
20:13:00 <rwbarton> somnolence: using show
20:13:02 <tromp> > ()
20:13:06 <lambdabot>   ()
20:13:07 <pumpkin> what's the best way to install profiling versions of cabal (not install)? last time I tried I got some weird dependency issue
20:13:09 <ddarius> > map digitToInt $ filter isDigit $ show pi
20:13:11 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3]
20:13:48 <kerlo> Okay, this is the type of s: * => \c -> (c => \_ -> *) => \e -> (c => \f -> e f => \_ -> *) => \h -> (c => \f -> e f => \g -> h f g) => \_ -> (c => \d -> e d) => \_ -> c
20:14:31 <kerlo> Finding out the type of callCC here is likely to be more difficult, as callCC doesn't exactly have an implementation.
20:15:01 <ddarius> callCC :: /\ab.((a -> b) -> a) -> a
20:15:17 <mmorrow> ok i got it. the directory that the sqlite db is in also needed to have a group that hpaste.fcgi is in
20:15:24 <mmorrow> it works now
20:16:56 <rwbarton> mmorrow: it's still confusing that there are two, I might create a paste on one and not remember which one when I go to look for it later
20:17:38 <mmorrow> i think i'm going set it up that they're always synced (or just point moonpatio.com at hpaste.org)
20:18:23 <mmorrow> hmm, if they're two though the db's would have to be merged and that'd probably cause some problems
20:18:33 <dancor> shouldn't the default pi be like a CReal version
20:18:49 <ddarius> There isn't a "default pi"
20:18:56 <dancor> > pi
20:18:57 <lambdabot>   3.141592653589793
20:19:02 <mmorrow> dancor: the only thing with CReal is that it's unusable in practice, because it's so slow
20:19:04 <pumpkin> @index pi
20:19:04 <lambdabot> Prelude
20:19:10 <rwbarton> :t pi
20:19:12 <lambdabot> forall a. (Floating a) => a
20:19:14 <L11> Can you do multiple things inside a function?
20:19:21 <pumpkin> dancor: I doubt they want to put CReal into the standard lib
20:19:32 <pumpkin> L11: don't do too many, but there's no limit :P
20:19:39 <SamB> L11: functional programming would be kind of useless if you couldn't!
20:19:43 <L11> how do you separate them?
20:19:44 <mmorrow> L11: put all the things you want to do in a list or something
20:19:58 <L11> like in C, you can end a line with a semicolon
20:20:03 <pumpkin> L11: what are you trying to do? remember that a function takes some stuff in and returns something else
20:20:14 <pumpkin> L11: so you might want to return a tuple with both results
20:20:21 <mauke> L11: just remove the first line, it doesn't do anything useful anyway
20:20:34 <mmorrow> zipWith myTwoArgFunction listOne listTwo
20:20:57 <mmorrow> L11: you just have to think about the flow differently
20:21:00 <L11> pumpkin: yea, that's why I was a bit confused. I thought you had to do one thing inside the function and return
20:21:07 <L11> yea very confusing
20:21:18 <pumpkin> L11: well your function returns one value, but that value can be a "compound" value
20:21:19 <mauke> L11: do you have a concrete example?
20:21:25 <kerlo> L11, as you can see, Haskell people get really excited whenever someone says the word "do" or "C". :-)
20:21:27 <erikc> mmorrow: does hpaste work on 6.10? takusen doesnt build on 6.10 for me
20:21:47 <ddarius> LL1: Functions don't "do" stuff.  The people that are responding may want to ask you what you mean by "do" or "do two things"
20:21:51 <mmorrow> erikc: yeah, but i had to hack the Setup.lhs + i think some imports
20:21:56 <erikc> k
20:21:57 <mmorrow> erikc: i'll paste a diff
20:22:06 <kerlo> L11: don't get overwhelmed; just tell us exactly what it is you're trying to do.
20:22:15 <L11> Well say I want to take in an integer, increase it then call another function
20:22:31 <mmorrow> nother . (*42)
20:22:37 <mauke> what do you mean by "increase it"?
20:22:46 <rwbarton> what do you mean by "then call"? :)
20:22:50 <kerlo> L11: well, you can take in an integer, and return both an increased integer and the result of another function.
20:23:11 <rwbarton> > let f x = sin (x+1) in f 3 -- ?
20:23:12 <lambdabot>   -0.7568024953079282
20:23:23 <kerlo> > let foo x = (x+1, show x ++ " is a great number") in foo 35
20:23:25 <lambdabot>   (36,"35 is a great number")
20:24:01 <L11> hm kerlo: was that directed to me?
20:24:07 <kerlo> L11: yes.
20:24:18 <L11> hm alright, let me give it a try on my end
20:24:20 <L11> thanks :)
20:24:54 <Gracenotes> hm... I must be missing something, but how can it be that the lambda calculus is guaranteed to halt `and` that the Y and omega combinators can be simply implemented in the lambda calculus?
20:25:08 <lament> lambda calculus is not guaranteed to halt.
20:25:12 <mauke> Gracenotes: the first part is wrong
20:25:20 <ddarius> Gracenotes: Because you are using two different "the lambda calculus"es
20:25:28 <pumpkin> calculi!
20:25:42 <Gracenotes> hm. How are they different?
20:25:50 <gwern> types
20:25:56 <kerlo> Simply-typed lambda calculus without Y is guaranteed to halt, I believe, but it's impossible to implement Y in simply-typed lambda calculus without Y.
20:25:57 <ddarius> The Simply Typed Lambda Calculus is guaranteed to halt (unless you add in fix).  In the Untype Lambda Calculus you can implement fix.
20:26:10 <ddarius> s/Untype/Untyped/
20:26:16 <Gracenotes> oh. Fix is impossible to implement in the typed calculus?
20:26:33 <kerlo> Simply-typed, yes.
20:26:35 <Gracenotes> ah, infinite type warnings, etc.
20:26:41 <ddarius> Gracenotes: In most typed lambda calculi, yes unless it's essentially added in as an axiom (somewhere)
20:26:43 <Gracenotes> yes, simply-typed is what I meant.
20:27:15 <L11> alright one more quick question, whats the easiest way to convert a chart to an int?
20:27:31 <ddarius> E.g. in Haskell fix is built-in to function definition and let, but even removing those you can use the fix built into type level recursion to implement Y.
20:27:40 <rwbarton> Maybe Haskell should accept the fact that the word "function" has been appropriated by imperative languages and use some scary technical term instead
20:27:42 <Gracenotes> so the simply typed lambda calculus is guaranteed to halt, because more complicated constructs won't type-check, it seems.
20:27:45 <mauke> @hoogle Char -> Int
20:27:45 <lambdabot> Data.Char digitToInt :: Char -> Int
20:27:45 <lambdabot> Data.Char ord :: Char -> Int
20:27:45 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
20:27:55 <mauke> L11: Data.Char.ord
20:27:57 <Gracenotes> rwbarton: morphism?
20:27:57 <lament> :t fix
20:27:58 <lambdabot> forall a. (a -> a) -> a
20:28:10 <lament> @src fix
20:28:10 <lambdabot> fix f = let x = f x in x
20:28:12 <ddarius> rwbarton: "function" -is- the technical term.
20:28:20 <rwbarton> ddarius: I know.  But it's not scary enough.
20:29:09 <mmorrow> erikc: takusen diff: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1280
20:29:29 <Gracenotes> a -> b is a morphism, I suppose, and a -> a is an endomorphism. I guess.
20:30:16 <gwern> @quote morphism
20:30:17 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
20:30:22 <gwern> @quote morphism
20:30:23 <lambdabot> edwardk says: i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
20:30:50 <Gracenotes> then I suppose there's all this talk about zygohistomorphic prepromorphisms on the wiki
20:30:59 <gwern> hm. we could use that term, yes
20:31:06 <SamB> Gracenotes: that's just silly
20:31:12 <kerlo> Hmm.
20:31:14 <kerlo> @quote ihope
20:31:14 <lambdabot> ihope says: Laziness is free, but it doesn't always pay off.
20:31:20 <gwern> there are so few category theorists that we could assassinate them all and bury the bodies on a single weekend, after all
20:31:26 <Gracenotes> SamB: well, we are looking for something 'silly' :)
20:31:29 <kerlo> I'm disappointed.
20:31:35 <lament> @quote ihope
20:31:35 <lambdabot> ihope says: Laziness is free, but it doesn't always pay off.
20:31:36 <SamB> I mean, xylematic phloamomorphisms make about as much sense
20:31:40 <lament> I'm disappointed.
20:31:43 <kerlo> There's another one. Keep digging.
20:31:46 <lament> no.
20:31:50 <kerlo> Oh.
20:31:53 <kerlo> @quote GADTs
20:31:54 <lambdabot> ghc says: Use -fglasgow-exts to allow GADTs
20:31:59 <kerlo> @quote my factorial function
20:31:59 <lambdabot> No quotes for this person. Where did you learn to type?
20:32:12 <mauke> preflex: quote
20:32:12 * SamB has trouble seeing why it needs to pay off if it's free
20:32:12 <preflex>  <gr00ber> asking for a table for four on a restaurant is funny in binary
20:32:15 <kerlo> @quote factorial
20:32:15 <lambdabot> jcreigh says: <chessguy> i mean if someone says factorial should be of type String -> [(Float, Bool)], you should just tell them they're nuts  <jcreigh> > let fac n = map (\x -> (x, True)) $ scanl (*
20:32:16 <lambdabot> ) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
20:32:31 <ddarius> gwern: As far as "pure category theorists" go you are probably right, but beyond that there are quite a few categorists.
20:32:37 <kerlo> Bleh.
20:37:30 <Gracenotes> @src filterM
20:37:31 <lambdabot> Source not found. That's something I cannot allow to happen.
20:38:09 <gwern> @quote assembl
20:38:09 <lambdabot> int-e says: C++ does make a reasonably usable high-level assembler
20:38:13 <gwern> @quote assembl
20:38:13 <lambdabot> qwe1234 says: all you happened to have demonstrated is that you suck at writing assembly code.
20:38:18 <gwern> @quote assembl
20:38:18 <lambdabot> SamB says: C is a good language. If what you want is an assembly language where you can't be sure what anything does
20:38:39 <gwern> hm. I was looking for the quote that goes 'assembly is great for getting the wrong answer really really fast'
20:39:00 <SamB> @quot really.really
20:39:06 <lambdabot> No quotes match. :(
20:39:11 <SamB> @quot really.fast
20:39:13 <lambdabot> No quotes match. My brain just exploded
20:39:17 * gwern was paraphrasing
20:39:17 <mauke> preflex: ? #11963
20:39:18 <preflex>  It's easy to get the *wrong* answer in O(1) time.
20:39:19 <SamB> @quot wrong.answer
20:39:19 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
20:39:28 <SamB> @quot wrong
20:39:29 <lambdabot> qwe1234 says: just because it's inflammatory doesn't mean it's wrong
20:39:35 <SamB> @quot ass.*wrong
20:39:36 <lambdabot> No quotes match. There are some things that I just don't know.
20:39:44 <SamB> @quot ass
20:39:44 <lambdabot> qwe1234 says: haskell type classes smell like c++ concepts.
20:39:59 <pumpkin> mmm, you ask for ass, you get smell
20:40:11 <ddarius> We stole the idea from the C++ standards committee.
20:40:16 <kerlo> Darn. Looks like the type of callCC here *contains* the continuation.
20:40:33 <mauke> preflex: quote
20:40:34 <preflex>  <dcoutts> kolmodin and I considered implementing lolcode in the small step semantics style, including how to simulate lolcode io purely
20:40:56 <SamB> ddarius: which idea ?
20:41:06 <wahjava> hi everyone
20:41:18 <ddarius> SamB: Concepts, which we then called type classes.
20:41:20 <kerlo> Hum, I hope I derived the type of s correctly.
20:41:22 <pumpkin> wahjava: welcome!
20:41:37 <wahjava> hi pumpkin
20:41:50 <SamB> ddarius: but the C++ committee seems not to have used it for anything useful ...
20:41:52 <ddarius> kerlo: I have to say, it sounds like you are doing something wildly, wildly wrong, but I'm not sure what it is you are actually doing.
20:42:06 <kerlo> ddarius: I'll take that as a compliment. :-)
20:42:10 <wahjava> I'm having problem understanding monads, I'm following YAHT
20:42:26 <pumpkin> wahjava: think of them like chicken, or burrito!
20:42:28 <SamB> wahjava: why do you want to understand them?
20:42:31 <SamB> just use them
20:42:37 <SamB> pumpkin: don't be so "helpful"
20:42:56 <wahjava> can anyone tell me the workings of {get,put}State in the Simple State Monad Section at http://en.wikibooks.org/wiki/Haskell/YAHT/Monads#A_Simple_State_Monad
20:43:03 * SamB spent a lot of time trying to understand Monads when he *already did*
20:43:13 <pumpkin> :)
20:43:26 <wahjava> SamB: to use them, I've to understand them.
20:43:39 <SamB> wahjava: there isn't much to it
20:43:54 <mauke> wahjava: you don't, actually
20:44:02 <pumpkin> wahjava: how about "there is nothing special about monads, other than all the hype around them, and the fact that they get some syntactic sugar in haskell that you could live without"
20:44:05 <SamB> the laws is basically it
20:44:12 <mauke> wahjava: to use a single instance of Monad you don't have to understand monads in general
20:44:34 <SamB> you don't have to understand what they are until you want to make your own
20:44:50 <SamB> and if you want to make your own, you'll probably have figured out what they are by then ;-P
20:44:55 <kmeyer> does haskell have recursive types?
20:44:56 <mauke> even then you can go a long way by combining monad transformers
20:45:01 <wahjava> lol
20:45:05 <ddarius> kmeyer: It has iso-recursive types, yes.
20:45:12 <SamB> wahjava: I'm totally serious
20:45:25 <SamB> I wasted a ton of time trying to come up with a thing that monads "are"
20:45:35 <wahjava> SamB: I understood the laws, but not that piece of code
20:46:03 <mauke> your problem is with State, not monads
20:46:11 <wahjava> {get,put}State and numberTree function
20:46:24 <ddarius> mauke: Indeed, that's what he (eventually) said (indirectly)
20:46:51 <Gracenotes> wahjava: well... do you know what get and put do?
20:46:57 <ddarius> And indeed, this is what most people who "don't get" monads mean by "not getting" them.  (Not necessarily, for the State monad.)
20:47:22 <kmeyer> ddarius: ah, I think I understand
20:47:25 <Gracenotes> ignore the implementation for now. What does get or put do?
20:47:30 <wahjava> Gracenotes: yes, they're supposed to get and set state as mentioned on the page.
20:47:59 <pumpkin> wahjava: do you know how you'd do a similar "state" without the State monad?
20:48:05 <pumpkin> or have you thought about it, rather
20:48:38 <wahjava> pumpkin: I would have to write some complex functions
20:48:51 <wahjava> pumpkin: to track states in their parameters
20:48:53 <mauke> @unmtl State s s
20:48:53 <lambdabot> s -> (s, s)
20:49:00 <pumpkin> wahjava: not that complex... try to think about how it might work
20:49:05 <mauke> @unmtl s -> State s ()
20:49:05 <lambdabot> s -> State s ()
20:49:09 <mauke> :-(
20:49:12 <Jedi_Stannis> why does
20:49:12 <Jedi_Stannis> do let x = f x
20:49:12 <Jedi_Stannis> cause an infinite loop?  shouldn't the let x just mask the old x?
20:49:25 <mauke> Jedi_Stannis: there is no old x
20:49:27 <wahjava> pumpkin: http://gitorious.org/projects/abbe-repo/repos/mainline/blobs/master/haskell/torrent.hs
20:49:37 <mauke> Jedi_Stannis: you've written a recursive definition
20:49:37 <pumpkin> wahjava: or if you want a nice article, try http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
20:49:40 <wahjava> pumpkin: here is a piece of code, I wrote without using monads, afaics
20:49:40 <ddarius> wahjava: Write numberTree however you like without using monads.
20:49:49 <Gracenotes> personally, thinking about the implementation of State confused me when I tried to learn it, as did authors introducing their own notation for it
20:50:05 <wahjava> but someone on this channel pasted a version which looks more cleaner than mine
20:50:28 <pumpkin> wow, someone using git but not github! blasphemy :)
20:50:30 <Jedi_Stannis> mauke: in do notation is it possible to do something like let a = 1 in (let a = 2 in a + 1)
20:50:38 <Jedi_Stannis> the inner a masks the outer one
20:50:59 <mauke> > do let a = 1 in let a = 2 in a + 1
20:51:00 <lambdabot>       No instance for (Num (t t1))
20:51:00 <lambdabot>        arising from the literal `2' at <in...
20:51:15 <mauke> > do let a = 1 in let a = 2 in return (a + 1) :: Maybe Int
20:51:16 <lambdabot>   Just 3
20:51:17 <wahjava> ddarius: and what after that ?
20:51:38 <sjanssen> Jedi_Stannis: do a <- foo; a <- bar; return (a + 1)
20:51:50 <pumpkin> wahjava: you'll solve it by reinventing the state monad without realizing it
20:51:54 <ddarius> wahjava: Make sure it works and think about how you did it, then think about how you could abstract repeated code.
20:51:54 <rwbarton> > do let a = 1; let a = 2; return (a + 1) :: Maybe Int
20:51:55 <lambdabot>   <no location info>: Invalid type signature
20:52:04 <mauke> I like to think of 'State s a' as a box with one input (of type s) and two outputs (of types a and s)
20:52:05 <rwbarton> > do { let a = 1; let a = 2; return (a + 1) } :: Maybe Int
20:52:06 <lambdabot>   <no location info>: parse error on input `}'
20:52:14 <rwbarton> > do { let { a = 1 }; let { a = 2 }; return (a + 1) } :: Maybe Int
20:52:15 <wahjava> pumpkin, ddarius : that is a nice idea, thanks I'll try it :)
20:52:16 <lambdabot>   Just 3
20:52:20 <kerlo> Jedi_Stannis: if you want it to not be a recursive definition, why don't you just use x' the second time instead of x?
20:52:34 <Gracenotes> mauke: but then of course there's the question of where the initial 'a' comes from :)
20:52:35 <wahjava> thnaks Gracenotes, pumpkin, ddarius, mauke, and rest of the #haskell :)
20:52:38 <mauke> 'get' is then simply a box that replicates its input to its outputs
20:52:38 <pumpkin> wahjava: also, read that blog post I posted if you get a chance :) it's more of the same approach
20:52:47 <Jedi_Stannis> kerlo: that's what I was doing, I just didn't understand why
20:52:49 <wahjava> okay pumpkin
20:52:51 <pumpkin> wahjava: feel free to hang around and ask more questions if you have issues :)
20:53:00 <wahjava> sure
20:53:02 <Jedi_Stannis> the initial a was coming from an io call: a <- foo
20:53:08 <mauke> 'put x' is a box that ignores its input and sets its outputs to () and x, respectively
20:53:38 <ddarius> mauke: Now draw diagrams and post a link to the pictures.
20:53:39 <kerlo> Jedi_Stannis: well, the cause for it is that's the way Haskell works: if the right hand side of an equation contains the variable you're defining, it ends up working recursively rather than masking. The purpose for this is because otherwise, you wouldn't be able to make a recursive definition.
20:53:44 <Jedi_Stannis> sjanssen: I think that might be what I was going for
20:53:58 <pumpkin> we need visual IRC + LaTeX formulas
20:54:37 <Jedi_Stannis> kerlo: yeah I understand this in normal code, but when in do notation I wasn't sure how it expanded and thought let expressions got expanded out into something like nested let expressions
20:54:56 <mauke> ddarius: they'd end up being ugly (due to my use of paint)
20:55:15 <ddarius> (mauke: Actually, Launchbury and Peyton Jones' "Lazy Functional State Threads" has such pictures unless I'm thinking of the wrong paper.)
20:55:21 <ddarius> mauke: Try Inkscape.
20:55:45 <mauke> eek
20:56:23 <Gracenotes> actually, a guy at Microsoft made such pictures in a talk on the State monad
20:57:02 <Gracenotes> uh, Brian Beckman. Except that they use a Visio format, a proprietary Microsoft thing
21:00:28 <Gracenotes> perhaps we just need another spacesuit metaphor, then all will be crystal clear. Something of type State s a is a path that an astronaut is supposed to take, stopping by space stations (functions) to get instructions based on a parcel he's holding. doing runState (path) (initial) means that he now has a parcel with the value (initial), and can begin his journey between space stations
21:01:02 <Gracenotes> ah, epiphany already!
21:01:45 <Gracenotes> :
21:01:49 <Gracenotes> :\
21:13:02 <wahjava> aadityabhatia: /join #emacs
21:15:52 <kerlo> Djinn effectively deals with intuitionistic logic, right?
21:16:18 <ddarius> kerlo: A small subset of it, yes.
21:16:46 <ddarius> Since it is using a subset of propositional logic though, you can embed classical propositional logic into it.
21:16:48 <kerlo> Mmkay.
21:17:36 <kmeyer> @source Ord
21:17:36 <lambdabot> Ord not available
21:17:40 <kmeyer> @search ord
21:17:40 <lambdabot> Unknown command, try @list
21:17:46 <ddarius> @src Ord
21:17:46 <lambdabot> class  (Eq a) => Ord a  where
21:17:46 <lambdabot>     compare      :: a -> a -> Ordering
21:17:46 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
21:17:46 <lambdabot>     max, min         :: a -> a -> a
21:17:49 <kmeyer> ah, thanks
21:17:52 <kerlo> If I add the law of excluded middle or double negation elimination to intuitionistic logic, do I get classical logic?
21:18:01 <ddarius> kerlo: Yes.
21:18:06 <kerlo> Great.
21:19:02 * wli fails problem 215.
21:19:10 <wli> Problem 216 rather.
21:19:29 <kmeyer> problem 216?
21:19:35 <kerlo> Project Euler?
21:19:47 <wli> Project Euler problem #216, rather.
21:20:50 <wli> I can't get enough theorems together to thin the field by a substantial enough margin.
21:21:46 <wli> I'm still pretty much stuck doing ca. 25M iterations.
21:22:16 <wli> (Out of 50M candidates to consider.)
21:22:48 <wli> There are a lot of primes of the form 2*n^2-1 so there needs to be some way to avoid looking at them all.
21:22:49 <Gracenotes> > sum [1..50000000]
21:23:03 <lambdabot>   mueval: Prelude.read: no parse
21:23:15 <rwbarton> Is haddock implemented using template haskell?  What is its representation of haskell source code?
21:23:51 <wli> e.g. proving that broad swaths of numbers of the form 2*n^2-1 are prime at once so as to avoid even considering them.
21:24:26 <rwbarton> wli: I'm pretty sure it's not even known that there are infinitely many primes of that form.
21:25:11 <wli> Well, I'm not getting anywhere wrt. writing a program that runs fast enough.
21:25:37 <chessguy> 'ello
21:27:28 <chessguy> > let fac n = map (\x -> (x, True)) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
21:27:32 <lambdabot>   [(1.0,True),(1.0,True),(2.0,True),(6.0,True),(24.0,True),(120.0,True)]
21:27:58 <wli> I've got a day job and a lot of other stuff to keep up with. Pull the chain on this one.
21:28:56 <rwbarton> We need a website where we can predict how long a thread on haskell-cafe will be generated by an initial email
21:31:12 <wli> rwbarton: Data mining?
21:31:52 <dancor> sounds more like off-track betting
21:32:12 <rwbarton> wli: More like a betting pool for whether an email will provoke a, mmm, prolonged discussion
21:32:38 <dancor> see if anyone has ideas for that site on the list
21:32:47 <Olathe> > 6^3
21:32:49 <lambdabot>   216
21:39:25 * shapr boings cheerfully
21:39:44 <chessguy> shapr,  :)
21:39:50 <kerlo> @get-shapr
21:39:50 <lambdabot> shapr!!
21:39:50 <shapr> hiya chessguy!
21:39:53 <kerlo> Cool.
21:39:55 <shapr> kerlo: w00!
21:39:55 <kerlo> Hi, shapr.
21:40:06 <shapr> hiya! How's code?
21:40:19 <shapr> kerlo: Weren't you ihope?
21:40:25 <kerlo> Yes, I was.
21:40:27 <chessguy> shapr, check it out: http://tinyurl.com/cgafs3
21:40:44 <kerlo> Do you recognize me or just my username? :-)
21:41:36 <shapr> I recognized the ihope@ part as an irc nickname that I saw on #haskell lots.
21:42:03 <shapr> chessguy: neat
21:42:37 <shapr> and really quite scary too.
21:42:41 <chessguy> shapr, woman had a seizure and came THROUGH a tree to smash into me in my parked car
21:42:49 <shapr> you were IN the car?
21:42:58 <chessguy> yup, and my wife and dog
21:43:10 <shapr> do you have pix of your car afterwards?
21:43:20 <chessguy> no, i didn't think to take them
21:43:26 * kerlo nods
21:43:31 <shapr> I think I'd be distracted myself.
21:43:33 <chessguy> i don't know why
21:43:41 <shapr> I dunno, getting run over?
21:43:49 <shapr> yeesh
21:43:50 <chessguy> heh, nah
21:44:06 <chessguy> she landed right on my driver-side door, too
21:44:14 <shapr> yikes!
21:44:39 <chessguy> we figure she musta been doing a good 20-30 mph at least, to spin us 90 degrees like that
21:44:47 <shapr> yah, wow
21:45:11 <chessguy> fun times
21:46:36 <shapr> I'm glad you survived!
21:47:07 <chessguy> heh, so is my wife, incidentally
21:47:15 <shapr> funny that
21:47:17 <ddarius> So is your dog likely.
21:47:32 <chessguy> ddarius, actually, the dog was thoroughly unfased
21:47:59 <chessguy> we got him out of the car, and he was like "cool, where we going? for a walk??"
21:48:05 <shapr> haha
21:48:20 <ddarius> And if you had been dead there would be no possibility for a walk, at least not for a while.
21:48:31 <chessguy> indeed
21:51:22 <chessguy> i kind of assumed from the fact that my door worked, and i wasn't hurt that she had hit farther back on the car. shook me up a bit when i went and looked at where the dent actually is
21:51:48 <chessguy> my door was definitely ground zero
21:52:40 <Heffalump> was the woman with the seizure ok?
21:53:03 <chessguy> last we heard, she was stable, but unable to talk to the cops yet
21:53:20 <Heffalump> as a result of the seizure or the collision?
21:53:26 <chessguy> the seizure
21:53:51 <chessguy> doesn't seem to have been injured in the collision, other than a tiny cut from flying glass
21:53:52 <Heffalump> sounds like everyone was pretty lucky then
21:54:21 <chessguy> yeah, we're all very curious as to why she was driving when she has a seizure history though
21:54:28 <Heffalump> I can't really see from the google pics how big the tree is/was
21:54:47 <chessguy> it's not real big
21:54:49 <chessguy> err, wasn't
21:55:00 <chessguy> it now looks like the last tree standign after the apocalyps
21:55:03 <chessguy> e
21:55:04 <Heffalump> :-)
21:55:17 <Heffalump> did it bend and go under the car?
21:56:04 <chessguy> i'm not sure, actually. i think maybe she just kind of side-swiped it pretty hard
21:57:01 <chessguy> we think the tree must have slowed/turned her just enough that the impact was a little more glancing than it could have been
21:57:12 <Heffalump> I was in an accident as a kid where our car hit a tree front-on, but off-centre, and then spun round
21:58:19 <chessguy> yikes
21:59:21 <Heffalump> it gets better - the back didn't have seat belts and I was thrown out, taking the entire back window (intact) with me. Luckily really, as a branch of the tree then proceeded to squish the back part of the roof. All I had was cuts and bruises.
21:59:31 <Heffalump> and my parents just had whiplash
21:59:36 <chessguy> wow
22:00:37 <chessguy> i'm amazed we didn't wind up with more cuts. my side window pretty much exploded, and we were covered with glass and dirt
22:02:49 <dsrogers> can you _ match a Type constructor?
22:03:14 <dsrogers> f (_ a b) -> ...
22:03:17 <Heffalump> dsrogers: in what, a class declaration?
22:03:25 <mauke> no
22:03:25 <dsrogers> in a function defintion
22:03:27 <Heffalump> dsrogers: that would be a data constructor, wouldn't it?
22:03:29 <Heffalump> and no.
22:03:32 <dsrogers> sorry ,yes.
22:03:50 * wli writes a number parser in parsec for the zillionth time.
22:04:02 <Heffalump> there's no way to match against multiple constructors at once, which is what you presumably want
22:04:11 <Heffalump> (unless you just want to match against any value at all)
22:06:32 <chessguy> wli, so why don't you factor it out, and release it on hackage
22:06:45 <monochrom> haha
22:06:49 <wli> Nothing to release.
22:07:02 <wli> Just crap code to postprocess logs.
22:07:28 <wli> It really is garbage code. People would pay me to keep it off hackage.
22:07:45 <Zao> chessguy: You sounded like gwern there for a bit.
22:07:58 <chessguy> Zao, insults aren't necessary
22:08:13 <monochrom> There would be 100x more lines in the cabal file, in the doc, in the unit tests... than in the number parser code. :)
22:08:34 <chessguy> yeah, i guess a number parser would only be a few lines, huh?
22:08:50 <chessguy> still, on principle...
22:09:03 <chessguy> you don't have to make a real fancy package out of it
22:14:07 <ddarius> There is already more than one number parser in Parsec.
22:15:37 <wli> Everything I saw dragged in a whole language parser with it.
22:19:36 <ddarius> import qualified Text.Parsec.Token as T; import Text.Parsec.Language; integer = T.integer (T.makeTokenParser emptyDef)
22:19:50 <bogner> is it possible to define a function such that using it is a compile error? I'd like to remove a function from a module, but have an error message other than "Not in scope:"
22:20:10 <bogner> ie, it could say "x is gone, use y instead"
22:20:49 <wli> That's the bit about dragging in a whole language parser.
22:20:58 <ddarius> wli: The problem being?
22:21:25 <dancor> bogner: maybe some crazy TH?  idk
22:21:40 <mxc> @seen ndm
22:21:40 <lambdabot> I haven't seen ndm.
22:21:56 * monochrom conceives the great plan (great prank?) of importing the whole of Hackage to output "hello".
22:22:01 <mxc> really?
22:22:06 <mxc> isn't ndm a regular here?
22:22:07 <ddarius> bogner: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#warning-deprecated-pragma
22:22:19 <ddarius> preflex: seen ndm
22:22:20 <preflex>  ndm was last seen on #haskell 98 days, 12 hours, 50 minutes and 36 seconds ago, saying: the code was, but most of it is type theory rules :)
22:22:35 <monochrom> heh, was a regular 98 days ago. :)
22:28:25 * wli tries to remember what the first parameter after the parser monadic action name is. runParser myParser wtfIsThis "sourceName" stringToParse
22:28:42 <ddarius> @hoogle runParser
22:28:43 <lambdabot> Language.Haskell.ParseMonad runParser :: P a -> String -> ParseResult a
22:28:43 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
22:28:43 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
22:29:10 <ddarius> The user state.
22:29:27 <wli> I don't believe I keep much of that.
22:30:06 <sjanssen> wli: you probably don't, that functionality is rarely used
22:30:15 <ddarius> parse is probably what you want to use
22:30:25 <ddarius> @hoogle parse
22:30:26 <lambdabot> Distribution.Text parse :: Text a => ReadP r a
22:30:26 <lambdabot> Text.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
22:30:26 <lambdabot> Text.ParserCombinators.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
22:31:06 * wli now tries to figure out why the line numbers are wrong.
22:32:54 * wli uses setSourceLine
22:35:22 <wli> Somehow ignored.
22:37:07 <wli> pos <- Text.Parsec.getPosition ; Text.Parsec.setPosition $ Text.Parsec.setSourceLine pos 3 -- follow it with the parser in a do { } block and no effect
22:47:09 <wli> do { pos <- getPosition ; setPosition $ setSourceLine pos 3 ; integer } -- isn't that supposed to flag errors as coming from line 3?
22:58:45 <wli> wliSetLine n = updateParserState (\st -> st { statePos = setSourceLine (statePos st) n })
23:00:57 <wli> wliSetPos (line, column) = updateParserState (\st -> st { statePos = setSourceColumn (setSourceLine (statePos st) line) column })
23:15:19 <wli> nikki93: What software interrupts do depends entirely on the OS; better to call into C libs with scanf/printf etc.
23:19:52 <dibblego> @type \f g -> (f `fmap`) `fmap` g -- does this exist in the standard library?
23:19:54 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f1 (f a) -> f1 (f b)
23:21:59 <jfredett> soo -- If I want to roll my own fancy monad, where might I peruse for tutorials/advice before coming to you lovely folks?
23:22:19 <jfredett> is there a "So now you know what they are, how the hell do you build them?" tutorial?
23:22:25 <jfredett> -- oh, I should check RWH...
23:22:33 <dibblego> instance Monad M where ...
23:22:44 <jfredett> i understand the mechanics
23:22:51 <dibblego> then what?
23:22:56 <jfredett> i'm talking about the theory- how should I design the system?
23:23:02 <mauke> what are you trying to do?
23:23:23 <wli> jfredett: A monad transformer stack.
23:23:30 <dibblego> http://pastebin.com/m770264d9 here is an example I am using right now to demonstrate exactly that
23:23:52 <wli> jfredett: Don't make a single monad; always make a monad transformer.
23:24:20 <jfredett> mauke: Filter email based on header information, but in a kind of high-level way, it's tough to explain, I'm not sure what I want to do yet, or how to do it
23:24:50 <wli> jfredett: Yeah, you want a monad transformer. Your innermost monad in the stack will always be IO.
23:24:58 <jfredett> effectively, I want to construct from an email header and (optionally) body a string which descripts where to put the email.
23:25:01 <jfredett> wli: right
23:25:39 <jfredett> wli: I think I have a grasp- but I've never dealt with transformers before- so I guess I just want some kind of transformer tutorial I can RTF before I ask silly questions.
23:26:03 <mauke> @where all
23:26:04 <lambdabot> I know nothing about all.
23:26:22 <jfredett> @where that_at_all
23:26:22 <mauke> http://www.haskell.org/all_about_monads/html/index.html
23:26:22 <lambdabot> I know nothing about that_at_all.
23:26:25 <wli> jfredett: springschool95.ps and YAHT should do the trick.
23:26:34 <ski_> @type fmap . fmap
23:26:35 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
23:26:51 <jfredett> fantastic, thanks gang.
23:26:52 <ski_> @pl \f g -> (f `fmap`) `fmap` g
23:26:52 <lambdabot> fmap . fmap
23:27:05 <dibblego> yeah that :)
23:28:44 <wli> mov $1, %eax is AT&T for that IIRC.
23:30:32 <tonyIII_> Module Control.Parallel is reported missing, how to determine which package in cabal-install includes it ?
23:31:38 <jfredett> gnite haskellers, thanks people who suggested MT stuff
23:31:47 <mauke> tonyIII_: guessing
23:32:03 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parallel
23:32:22 <tonyIII_> mauke: Thanks.
23:34:24 <Gracenotes> @unpl (map.map)
23:34:25 <lambdabot> (\ c -> map (map c))
23:36:09 <ski_> dibblego : you can derive those instances on `Conn'
23:36:20 <tonyIII_> Why I keep getting undefined reference of "parallelzm1zi1zi0zi0_ControlziParallel_par_closure" with ghc 6.10, both x86-win and x86-linux ?
23:36:43 <mauke> because ghc -package parallel
23:36:47 <dibblego> ski_, yeah I know, but that wasn't part of the exercise
23:36:53 <mauke> or ghc --make
23:37:19 <tonyIII_> mauke: Big thanks.
23:37:22 <mauke> preflex: zdec parallelzm1zi1zi0zi0_ControlziParallel_par_closure
23:37:23 <preflex>  parallel-1.1.0.0_Control.Parallel_par_closure
23:37:26 <mauke> (in case you cared)
23:39:39 * ski_ wonders if there's a `Compose' or `O' hiding somewhere in lambdabot ..
23:56:06 <tonyIII_> mauke: Get it!
