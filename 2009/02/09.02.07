00:00:53 <shapr> jsn: Check the jobs page on the HaskellWii
00:00:56 <shapr> wiki*
00:01:25 * ski_ imagines using a Wiki with a Wii
00:04:12 <jsn> so my general impression of haskell hiring is that it is heavily dependent on domain expertise or academic credentials
00:04:27 <jsn> basically, my haskell job was total luck -- the founder thinks haskell is cool
00:05:51 <Taejo> any ideas how to deal with the ambiguous type variable in http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1230#a1233?
00:05:55 <erikc_> or...start a company and eat someone's lunch
00:06:04 <erikc_> thats my plan
00:07:01 <jsn> well, now is the time
00:07:14 <jsn> plenty of developers lying around
00:07:24 <erikc_> yup
00:07:25 <Taejo> hmm... I could encode all expressions into strings, and add a num instance for strings
00:07:38 <Spark> lying around... especially after a bit of genocide
00:07:45 <Spark> although that's more like 'piled up'
00:09:57 <cads> hey you guys, check this out: philosophers have questioned, "does the conceptual object which is both a square and a circle exist?'
00:10:11 <cads> this guy constructs one on a napkin: http://www.youtube.com/watch?v=4CzMXkzMrL4
00:11:15 <Taejo> cads: if you define square as a four-sided figure with four equal angles, than the equator of a sphere is a square circle
00:11:57 <Taejo> which is how he defines it
00:12:18 <Spark> i define a square as being the same fucking thing as a circle
00:12:21 <Spark> problem solved
00:12:31 <Spark> have a happy saturday
00:12:40 <cads> :)
00:12:44 <cads> you too spark
00:12:59 <Taejo> oh hax, he considers infinity a length
00:13:09 <Taejo> my way is better
00:13:34 <cads> Taejo, yup, on a spherical manifold a equilateral polygon with equal angles could be a greatcircle in the space.
00:15:19 * ski_ considers the question malformed
00:18:32 <chrisdone> can you prove that a program terminates by limiting the language in which it is written in some way?
00:19:31 <ski_> yes
00:19:34 <bobshush> you can create languages in which all programs are gauranteed to terminate, if thats what you mean
00:20:17 <cads> @remember Taejo oh hax, he considers infinity a length
00:20:17 <lambdabot> It is forever etched in my memory.
00:20:46 <cads> hehe
00:20:51 <cads> @quote
00:20:52 <lambdabot> Anonymous says: A monad is a functor from a category to itself. Honestly, I don't know how I could make this any simpler.
00:21:17 <cads> @quote
00:21:18 <lambdabot> Dianora says: He didn't bother waving his hands.
00:21:19 <ski_> (.. satisfying certain properties)
00:22:56 <chrisdone> I could prove that a haskell program terminates by going through the substitution
00:23:14 <chrisdone> but can programs proven to terminate be useful?
00:23:21 <cads> chrisdone: in constructing the algorithm as well, you can give termination as an axiom
00:23:23 <cinimod> @djinn a -> a
00:23:24 <lambdabot> f a = a
00:24:07 <cads> chrisdone: if you need a final answer from a program, only programs that terminate are useful
00:24:08 <cinimod> @djinn (b -> b') -> (a -> (b -c)) -> (a -> (b' -c))
00:24:09 <lambdabot> Cannot parse command
00:24:18 <cinimod> @djinn (b -> b') -> (a -> (b -c)) -> (a -> (b' -> c))
00:24:18 <lambdabot> Cannot parse command
00:24:26 <cinimod> @djinn (b -> b') -> (a -> (b -> c)) -> (a -> (b' -> c))
00:24:27 <lambdabot> -- f cannot be realized.
00:25:01 <cinimod> @djinn (b -> b') -> (a -> b) -> (a -> b')
00:25:02 <lambdabot> f a b c = a (b c)
00:25:07 <ski_> (chrisdone : many useful programs are expected to terminate ..)
00:25:23 <chrisdone> yes, expected to
00:25:38 <chrisdone> I notice you didn't say 'proven to'
00:25:44 <cinimod> @djinn (b -> b') -> (a -> b) -> c)) -> (a -> b') -> c))
00:25:44 <chrisdone> why?
00:25:44 <lambdabot> Cannot parse command
00:25:52 <cinimod> @djinn (b -> b') -> (a -> b) -> c) -> (a -> b') -> c))
00:25:52 <lambdabot> Cannot parse command
00:25:57 <cads> I'd say it's more like constructed to
00:26:06 <ski_> (.. i would be surprised if having a termination proof of them would make them cease to be useful)
00:26:09 <cinimod> @djinn (b -> b') -> ((a -> b) -> c) -> ((a -> b') -> c))
00:26:09 <lambdabot> Cannot parse command
00:26:10 <jsn> shapr: what sort of work did you do with haskell? was it academic?
00:26:19 <chrisdone> ski_: so would I
00:26:23 <cinimod> @djinn (b -> b') -> ((a -> b) -> c) -> ((a -> b') -> c)
00:26:24 <lambdabot> -- f cannot be realized.
00:26:24 <chrisdone> ski_: so?
00:26:48 <ski_> so ?
00:27:13 <cads> chrisdone: is it that a known terminating algorithm would be more useful?
00:27:30 <bobshush> A general class of programs that might be useful to have proofs of termination are ones that try to find some optimal solution to a given problem
00:27:39 <ski_> @djinn (a -> b) -> (a -> b -> c) -> (a -> c)
00:27:40 <lambdabot> f a b c = b c (a c)
00:27:56 <cads> yes, I was just thinking about that, any search or heuristic function
00:28:04 <ski_> @djinn (b' -> b) -> ((a -> b) -> c) -> ((a -> b') -> c)
00:28:05 <lambdabot> f a b c = b (\ d -> a (c d))
00:28:09 <wli> Termination is sometimes expressed in terms of lifted and unlifted types.
00:28:54 <cinimod> skI_: any idea why djinn didn't like my variant?
00:29:10 <cads> I'd say it should be possible to compose terminating computational primitives in ways that would preserve termination assurance
00:29:12 <cinimod> ski_: any idea why djinn didn't like my variant?
00:29:19 <ski_> (cinimod : not suprising, since the `b' occurs in contra-variant position in `(a -> b) -> c')
00:29:44 <cinimod> ski_: I wanted a contravariant functor
00:29:54 <wli> cads: Typechecking in terms of unlifted types.
00:29:56 <cads> chrisdone: if you find an interesting treatment on this, shoot me a line about it
00:30:02 <cinimod> ski_: which is why I put it there
00:30:05 <ski_> cinimod : yes .. so you must reverse the "b -> b'" arrow
00:30:13 <cads> wli, I'll crank that through a search engine :)
00:30:30 <bobshush> I actually remember reading a paper that outlined an always terminating language that allowed for recursion, let me see if i can find it
00:31:14 <wli> cads: I'm trying to say that there are a lot of interesting papers on it.
00:31:32 <cads> lol the first google results says "Unlifted types cannot currently be used to represent terminating functions"
00:31:52 <wli> Like it's a huge topic of study.
00:32:03 <cads> but that statements seems to tease at the possibilities
00:33:03 <wli> cads: The statement is noteworthy.
00:33:17 <cads> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
00:34:19 <cads> me searches for a bibliography
00:35:57 <cinimod> ski_: I was expecting djinn to work out I wanted contravariance
00:36:25 <cinimod> ski_: I shall complain to the author :-)
00:36:29 <cads> chrisdone: you could consider functions that may or may not be terminating normally, but return bottom if they run too long
00:36:43 <ski_> cinimod : that's like saying `@djinn a -> b', and expect djinn to work out `b' was meant to be the same as `a'
00:37:38 <cinimod> ski_: I know but I was hoping for magic
00:37:51 <ski_> cinimod : for a contravariant functor from `*' to `*', you need the pattern `(b -> a) -> ((..a..) -> (..b..))'
00:37:57 <cads> wli, can't find much about termination proof and unlifted types, but it is also very very late and I am drunk.
00:38:10 <idnar> hoping for magic from a djinn seems logical ;)
00:38:44 <cinimod> ski_: I just did that (i.e. reversed the arrows in my head)
00:39:05 <cinimod> ski_: I was being lazy
00:39:14 <ski_> @djinn Magic -> (b -> b') -> ((a -> b) -> c) -> ((a -> b') -> c)
00:39:15 <lambdabot> f = void
00:40:17 <cinimod> I recall in December there was discussion somewhere (haskell-cafe?) on this and it included something on negative(?) types
00:40:25 <cads> chrisdone: this looks interesting: http://www.springerlink.com/content/pu86034186xn08m8/
00:40:37 <chrisdone> cads: running for "too long" sounds like the algorithm is broken
00:40:50 <cinimod> Can anyone recall this? I made some notes on it but can't find the original discussion
00:40:59 <ski_> cinimod : maybe negative parameters of type functions ..
00:41:08 <cinimod> That sounds right
00:41:35 <cinimod> i.e. types / objects in contravariant positions
00:41:42 * ski_ str O'Caml allows specifying parameter polarity
00:42:56 <cinimod> I'm guessing I'd need to have cartesian closed for this to work in a category
00:43:36 <cads> chrisdone: think about it. you can map all algorithms into the terminating ones that way.. many algorithms will try to refine a solution forever, and might give you some assurance to the quality of solution but can't give you an assurance that the best has been reached. Or are simply impractical to implement due to space and time concerns.
00:43:37 <wli> cads: The hackage link's statement translated to plain English is "ghc refuses to obey when you use the type system to command it to distinguish between terminating and nonterminating functions a.k.a. solve the halting problem."
00:44:24 * cinimod goes off to ponder
00:45:22 <cads> chrisdone: we can build a terminating algorithm that will traverse all possible chess games and eventually tell us if there is a win or draw strategy for white or black (essentially this would solve chess).
00:45:57 <cads> the space of chess games is finite so such an algorithm would terminate through definition
00:46:24 <cads> but not untill we convert the moon to quantum-entangled computronium will we ever run the algorithm to its end
00:46:28 <chrisdone> assuming it was implemented properly
00:46:54 <cads> yeah to implement we'd need nanobots!
00:47:01 <cads> ;)
00:47:29 <cads> anyways, why do you seek termination?
00:47:35 <jsn> wli: it is puzzling to me that terminating algorithms require lifted types
00:47:53 <jsn> why is is that the _|_ needs to be there?
00:48:02 <bobshush> cads: they actually proved checkers was a draw recently
00:48:02 <wli> jsn: Provability, halting problem, etc.
00:48:10 <chrisdone> I don't seek termination
00:48:55 <wli> bobshush: The hard way IIRC.
00:49:06 <bobshush> http://news.bbc.co.uk/2/hi/science/nature/6907018.stm
00:49:17 <cads> bobshush: yeah, I was in jail and had a bet with one of the guys, I thought red wins
00:49:20 <bobshush> well, with group theory and lots of processing, yeah
00:49:23 <jsn> wli: well, doesn't lifting a type ensure that the function can not be proven to terminate?
00:49:42 <jsn> wli: so basically, they are punting? or i am missing something?
00:49:44 <wli> bobsush: No, IIRC by constructing optimal strategies.
00:49:50 <chrisdone> bobshush: I like that. "Computers crack famous board game". if it's famous why not say "Computers crack draughts"
00:50:13 <erikc_> man its hard making a haskell presentation for c++ folk, i forgot how far ive come
00:50:51 <cads> chrisdone: because everyone would rush to see if it was chess :D
00:51:53 <chrisdone> I'm poking about in the correctness proving literature for haskell
00:52:23 <jsn> erikc: you are making a presentation for coworkers or...?
00:52:28 <bobshush> Anyway, not finding that paper I was thinking about, did find BlooP and FlooP:
00:52:30 <chrisdone> and something in SICP about the logic database algorithm not terminating made me wonder
00:52:32 <bobshush> http://en.wikipedia.org/wiki/BlooP_and_FlooP
00:52:43 <erikc> jsn: yea
00:52:58 <erikc> im also doing a presentation to the vancouver lisp users group, but that'll be easier
00:53:20 <bobshush> The idea was that you could have recursion, but you were only allowed to define loops via induction,
00:53:39 <cads> goodnight all
00:53:56 <bobshush> night cads
00:55:22 <bobshush> defining on f 0 and then requiring definitions of f n in terms of f (n-1)
00:56:40 <erikc> jsn: its tricky balancing showing off awesome stuff with actually explaining how/why awesome stuff works
00:56:55 <jsn> erikc: indeed
00:57:06 <jsn> "and then, magic occurs..."
00:58:05 <jsn> erikc: i think c++ programmers have a leg up when it comes to the parameterized types and some of the type discipline
00:59:21 <jsn> which is to say, i think they are accustomed to the notion that types can be great and types take time
01:00:08 <wli> "Type discipline is great. All you have to do is be disciplined in one place, cast to void *, then be disciplined in another, and the two (or more) different disciplines do wonderful things by disagreeing."
01:00:10 <jsn> whereas a folks with more experience in ruby and python really do flip out over it
01:00:34 <jsn> wli: what is that from?
01:00:39 <wli> Or such is my impression of C++ programmers' type discipline.
01:00:47 <jsn> wli: well, yes
01:00:50 <wli> jsn: It's just my impression of C++ programmers.
01:01:08 <jsn> wli: well, okay
01:01:22 <jsn> but they at least have to pay respect to the STL once in awhile
01:02:24 <erikc> yea, c++ folk with lots of template programming experience should be able to grok it
01:02:29 <jsn> right
01:02:51 <jsn> c++ is a multi-paradigm language, after all :)
01:02:55 <erikc> most are 'Java-style' C++ programmers though :)
01:03:08 <jsn> not everyone is going to engage in "generic programming" :)
01:03:13 <jsn> erikc: hehe
01:11:10 <chrisdone> therp: what's the latest on the new liskell?
01:11:59 <therp> chrisdone: I'm reading GRIN papers to get away from GHC
01:13:11 <therp> chrisdone: you have seen the standalone release last month?
01:13:50 <chrisdone> therp: yep, I compiled and ran it, played with it a bit
01:14:01 <therp> chrisdone: oh nice, any feedback? :)
01:14:09 <therp> except for largely undocument code and error messages
01:15:38 <chrisdone> therp: haha, indeed. well, my interest with Liskell lies in the ability to use GHC and all it's goodies, and I thought it was really cool that you started to use the API. but if you're moving away from GHC I'm not sure how much I'd personally have use for it
01:16:06 <chrisdone> therp: what, put simply, are the (inflexibility?) issues with GHC?
01:16:57 <therp> chrisdone: frankly the GHC API isn't well designed at all
01:18:14 <chrisdone> therp: is it annoying to use or does it actually not support necessary features for Liskell?
01:18:50 <therp> chrisdone: also I like to play more with the runtime itself which I do not fully understand for the current RTS implementation
01:19:29 <therp> chrisdone: both. annoying in the sense that you do not know how to use it, you get random error messages from uninitialized fields, or some violated other constraints
01:19:59 <dmwit> How to use the GHC API: step 1. be a GHC developer
01:20:00 <therp> chrisdone: and also if you look at the Liskell code, I do not use the API at all. what I'm practically doing is reinventing a suitable API on top of the next lower level
01:20:47 <chrisdone> therp: I found the code quite bewildering, yes, I didn't see much actual use of the API
01:21:42 <therp> chrisdone: I could work on a few upstream patches to make things more flexible..
01:23:09 <chrisdone> therp: that would be awesome. but I'd understand if you'd rather not, of course
01:23:58 <therp> my girlfriend demands breakfast sorry, will be back later :)
01:24:06 <chrisdone> laters ;-)
01:41:55 <hackage> Uploaded to hackage: haskeline 0.6.1.1
02:07:58 <flap> what is so cool about currying? is it just that you can amke a functional progr lang from lambda claculus?
02:08:09 <flap> is it something you actually use in everyday programming?
02:08:17 <Saizan> yes
02:08:38 <Saizan> > map ((+) 1) [1..] -- so easy because of curring
02:08:40 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
02:08:41 <baaba> it helps make code much more concise all around
02:08:44 <flap> > let f x y z = x*x+y*y+z*x in g z = f 10 20 z in g 50
02:08:46 <lambdabot>   <no location info>: parse error on input `='
02:08:54 <flap> > let f x y z = x*x+y*y+z*x in let g z = f 10 20 z in g 50
02:08:56 <lambdabot>   1000
02:09:13 <flap> > let f x y z = x*x+y*y+z*z in let g z = f 10 20 z in g 50
02:09:14 <lambdabot>   3000
02:09:26 <Saizan> i.e. it makes creating function to use as callbacks for HOFs extremely convenient
02:09:32 <flap> ok
02:11:15 <newb12345> in open source projects, what's the biggest haskell succeess story?
02:11:50 <flap> darcs
02:12:49 <Axman6> ghc!
02:13:13 <baaba> i rather like xmonad
02:13:30 <asgaroth> How can I add custom functions to that yi (M-x) prompt? I put one in my yi.hs and recompiled but it doesn't appear there.
02:15:45 <waern> asgaroth: #yi
02:18:13 <sOpen> Axman6, seems sort of like a means to an end, ne?
02:18:25 <Axman6> ghc?
02:19:46 <asgaroth> Nevermind, I found the solution to my question
02:21:48 <sOpen> Axman6, yeah
02:21:59 <Axman6> yeah
02:22:50 <Axman6> "The culmination of all the most advanced work in haskell has resulted in the world's most advanced, most powerful, most amazing haskell compiler!"
02:23:27 <sOpen> "And it's better for humanity because... because... WE HAVE MONADS!"
02:23:43 <newb12345> lol
02:24:53 <Axman6> "Due to it's impressive laziness features, it can finish compiling itself, before it has even read all of the necessary files. It inferrs, correctly, what functions its too lazy to find the definition of actually do."
02:25:45 <idnar> well, he said open source projects
02:25:56 <idnar> presumably ghc is used on lots of closed source projects :P
02:27:09 <shteou> That doesn't make it any less open source or successful? :o
02:27:43 <shteou> Also, is there an emacs-like Haskell environment?
02:28:16 <Axman6> what about the emacs haskell mode?
02:28:49 <idnar> shteou: no, the point is that it's not so self-fulfilling that way
02:28:57 <athos> hi
02:29:21 <asgaroth> shteou: There's also yi which is similar to emacs but extensible in haskell
02:29:31 <pk_> If I have a reactive value generated by an IO action, is the IO tag necessary ?
02:29:32 <shteou> Ah excellent, that's what I'm after :)
02:29:36 <shteou> Thanks asgaroth, Axman6.
02:30:01 <sOpen> idnar, ah, that is true. I tend to think only of open projects :-/
02:30:12 <shteou> Yeah, looks perfect asgaroth :>
02:30:27 <pk_> I mean, is there a way to go from Event (IO Truc) to Event Truc ?
02:30:59 <pk_> or to IO (Event Truc)
02:32:12 <beelsebob> sequence
02:32:28 <beelsebob> assuming Event is travrsable
02:33:59 <pk_> I don't think it is
02:34:40 <beelsebob> where is this Event type defined?
02:34:53 <beelsebob> oh, is this Rective?
02:34:57 <pk_> yes
02:35:04 <beelsebob> you shouldn't be using IO anywhere in a reactive program
02:35:16 <beelsebob> the point is to model time purely
02:35:19 <beelsebob> IO isn't pure
02:35:38 <pk_> what if I need a physic library ?
02:35:47 <beelsebob> then make a pure one ;)
02:36:04 <pk_> I'll need a bigger brain
02:37:09 <sOpen> then order one online ;)
02:39:22 <pk_> maybe
02:39:39 <pk_> I mean, in some way, the physics library is pure
02:39:51 <pk_> at a given time, it'll allways produce the same result
02:40:36 <pk_> and an event already capture this idea of time dependency
02:41:48 <beelsebob> then if it's pure, it shouldn't be in IO
02:42:12 <beelsebob> if it's going through the FFI, but it's still pure, use unsafePerformIO to fix it
02:42:49 <pk_> my problem is the time dependency isn't explicit
02:43:01 <beelsebob> ah
02:43:12 <beelsebob> then it makes very little sense to use them in reactive Events – they're lazy
02:43:24 <beelsebob> so the computation time may not match up with the time the event thinks its at
02:43:41 <beelsebob> and you'll get some pretty weird behavior
02:44:19 <pk_> yeah
02:45:21 <pk_> Maybe I could wrap the physics with time dependant function
02:45:31 <pk_> using unsafePerformIO
02:45:40 <pk_> then put this in a Behavior
02:45:41 <idnar> why IO?
02:45:51 <beelsebob> idnar: it's an FFI physics library
02:46:07 <idnar> oh!
02:46:16 <beelsebob> and it's time dependancy is implicit
02:46:20 <beelsebob> :(
02:49:45 <HugoDaniel> hello
02:50:01 <pk_> yeah, i'll put the update function in a behavior and make it dependent to the time behavior
02:50:18 * juhp_ hopes this is the last gtk2hs-0.10.0 packaging test build
02:50:23 <pk_> I suppose each time the time change my update behavior should be recomputed
02:50:35 <olsner> 0.10? isn't that really old?
02:50:38 <pk_> even if I use unsafe perform IO in it, right ?
02:50:56 <juhp_> olsner: no really new actually :)
02:51:10 <juhp_> not officially releases yet I guess
02:51:23 <juhp_> last release was 0.9.13 :)
02:51:31 <olsner> aah, 0.9.13 and not 0.13 :P
02:51:38 <olsner> I just remembered the "13"
02:51:44 <juhp_> nod me too
03:14:21 <pao> can anyone explain the difference between error and throw?
03:14:24 <pao> @type error
03:14:26 <lambdabot> forall a. [Char] -> a
03:14:32 <pao> @type throw
03:14:34 <lambdabot> Not in scope: `throw'
03:14:48 <Saizan> @hoogle throw
03:14:49 <lambdabot> Control.Exception throw :: Exception -> a
03:14:49 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
03:14:49 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
03:15:01 <mauke> @src error
03:15:01 <lambdabot> error s = throw (ErrorCall s)
03:15:34 <pao> so, basically with thorw you have control on the type of the exception...
03:21:12 <pao> @src undefined
03:21:12 <lambdabot> undefined =  error "Prelude.undefined"
03:21:24 <Botje> heh, cool
03:22:05 <juhp_> one more build ;)
03:22:23 <Botje> nobody at FOSDEM?
03:22:30 <Botje> we need a haskell devroom :]
03:23:01 <juhp_> ah
03:23:10 <pao> mauke: Saizan: thanks
03:23:37 <Axman6> Botje: does #haskell-in-depth count?
03:28:17 <Botje> i guess :)
03:41:55 <hackage> Uploaded to hackage: HPDF 1.4.2
03:50:38 <Merdam> Are more than 4% of Haskell programmers black?
03:53:39 <blackh> That Merdam really did his/her homework and found out that Haskell is a programming language.  I am impressed.
03:53:42 <Axman6> ?users
03:53:43 <lambdabot> Maximum users seen in #haskell: 699, currently: 636 (91.0%), active: 8 (1.3%)
03:53:58 <Axman6> bloody hell, almost 700 :O
03:54:19 <Axman6> dons: seen @users lately?
03:55:34 <FunctorSalad> is the "can't derive ... has a non-Haskell98-constructor" restriction really necessary if the only thing special about the constructor is a context?
03:55:51 <FunctorSalad> the generated code should be the same
03:56:14 <idnar> Axman6: that 699 was a while back though, I think
03:56:22 <Axman6> sure?
03:56:29 <idnar> I could be wrong
03:56:49 <mauke> wasn't it at 692 just a few days ago?
03:57:20 <Deewiant> my logs show that 698 was two days ago
03:57:35 <Deewiant> and 699 too, actually
03:57:35 <mauke> myth confirmed!
03:57:46 <Deewiant> about 40 hours ago
03:59:17 <idnar> heh
04:00:37 <Axman6> anyone know where those stats about channel size etc are?
04:01:29 <RayNbow> Axman6: http://www.haskell.org/haskellwiki/IRC_channel ?
04:01:50 <Axman6> i was thinking more for freenode, not just #haskell
04:02:06 <Axman6> searchirc is linked from there though, looks good
04:02:25 <Axman6> we're 6th largest on freenode now :)
04:03:01 <Axman6> hmm, which is down a spot from what it was
04:27:49 <juhp_> woah, leksah is pretty cool
04:35:03 <lstor> Axman6: I got time to read through your IO tutorial, by the way, and it was really helpful. Thanks :)
04:35:14 <Axman6> oh good, i'm glad :)
04:35:38 <Axman6> lstor: i should mention in it that what i've said is not technically correct, but i feel it is a good way to explain it to beginners
04:36:24 <lstor> Axman6: I think you convey that message -- or it could be that I just figured it out because I've been discussing it a bit with a friend of mine
04:36:39 <Axman6> heh, good
04:36:55 <lstor> Axman6: By the way, the last line of code didn't get a > in front of it, and one of the comments at the bottom (the last?) was partially hidden in my browser
04:37:11 <Axman6> hmm, i'll takre a look
04:37:21 <Axman6> -r
04:37:50 <BONUS> Axman6: what's the URL
04:38:09 <Axman6> http://axman6.homeip.net/blog/axmans-haskell-io-tutorial.html
04:38:51 <lstor> Axman6: http://folk.uio.no/larsstor/axman.png
04:39:01 <lstor> The comment at the top of the screen
04:39:22 <BONUS> cool :)
04:40:12 <Axman6> yeah, i'll try and fox both of those issues now ;)
04:41:13 <beelsebob> Axman6: a lot of your examples there can be expressed rather more neatly
04:41:25 <Axman6> i'm sure they could
04:41:38 <shteou> Also Axman6: Last line needs a >
04:41:44 <shteou> oh sorry
04:41:47 <shteou> that was mentioned
04:41:56 <beelsebob> for example main = do {int <- getInteger; print (2^int) } would be neater as main = print . (2^) =<< getInteger
04:42:56 <lstor> I think the former is clearer, especially considering that the tutorial is aimed at beginners
04:43:27 <Axman6> beelsebob: i'm trying to make it clear to beginners how to do IO, and i think adding pointfree stuff like that will just be offputting for someone who's just started with the language
04:43:37 <beelsebob> true
04:43:37 <Axman6> beelsebob: plus, it's how i'd write it :P
04:44:20 <Axman6> http://axman6.homeip.net/blog/axmans-haskell-io-tutorial.html better now?
04:44:55 <lstor> The comment is still hidden, but the last line is good
04:45:28 <Axman6> oh right. yeah i should change my CSS for that
04:45:29 <lstor> (I love literate haskell. It's so neat to have a tutorial like that where the entire tutorial is compilable)
04:46:01 <Axman6> heh, i see you're a tab addict like me :P
04:46:12 <Axman6> 55 tabs open atm
04:46:50 <skorpan> wtf
04:46:56 <lstor> It's good to know there are more of us :)
04:46:58 <Cale> Heh, I like tabs, but I can't stand having more than about 10 of them open.
04:47:41 <lstor> I have about ten tabs which I use frequently, and the rest are usually temporary bookmarks ("I need to get back to this" when I have the time)
04:47:42 <Axman6> well, i spread them over a few pages. and i do keep my browser open all the time
04:47:53 <lstor> Same for me
04:47:53 <pejo> Cale, open a new window after 10. :-)
04:47:54 <Axman6> lstor: heh, yep, exactly :P
04:48:22 <Cale> If it's something I care about, I'll just bookmark it and close it.
04:49:13 <lstor> I do too, but most of the tabs are pages that I just need to go through and then close, rather than use again many times
04:49:39 <Axman6> yeah, same
04:50:58 <koeien> i have the 'treemap' extension for firefox
04:51:10 <koeien> 'tree style tab'
04:51:26 <koeien> so you can have a gazillion tabs open and still have a good overview ;)
04:51:50 <Axman6> i try to avoid firefox whenever i'm on a platform that doesn't have IE
04:53:04 <skorpan> Axman6: the text doesn't fit
04:53:06 <lstor> I don't use FF either. Opera has several nice features that I just can't live without, and in my experience Opera is faster
04:53:12 <Axman6> skorpan: wokring on it ;)
04:53:24 <Axman6> i find opera far too strange
04:54:05 <lstor> Opera is originally Norwegian. I'm Norwegian. I guess there is some connection there :P
04:54:23 <skorpan> yeah, you're both terrible
04:54:25 <mauke> Opera has no Adblock Plus. Case closed!
04:54:28 <skorpan> *bodum pish*
04:54:50 <koeien> and opera is non-free so i can't install it easily
04:54:52 <ahf>  /58
04:54:53 <shteou> lstor, I stopped using Opera because the middle mouse click centred the mouse horizontally
04:54:56 <shteou> but they fixed that recently
04:55:00 <shteou> now I use Opera again \o/
04:55:07 <shteou> It's good to have gestures back
04:56:17 <skorpan> there *are* gestures for firefox
04:57:33 * beelsebob pokes Axman6's entry in the comment
04:57:42 <Axman6> :o
05:09:18 <Axman6> beelsebob: that last comment didn't quite come through properly
05:09:30 <beelsebob> no, any way I can edit it?
05:09:44 <beelsebob> or get you to edit it (stick in an &lt; and &gt; to fix the fmap)
05:11:32 <Axman6> i'll see, never tried
05:13:33 <Axman6> beelsebob: all good now
05:13:58 <Axman6> or you could go and mess everything up by commenting twice :P
05:15:02 <beelsebob> lol
05:15:03 <beelsebob> >.>
05:15:07 <beelsebob> go delete it then
05:16:10 <Axman6> no, i'll just keep it there so you look like a fool! ha!
05:16:57 * Axman6 deletes all the other useless comments from MT and himself
05:17:08 <beelsebob> hmm?
05:20:43 <McManiaC> hi
05:21:30 <Axman6> o/
05:21:32 <blackh> Hello!
05:24:31 <McManiaC> just started to do my first steps with haskell and downloaded ghc to compile it
05:24:42 <McManiaC> /usr/bin/ld:test.sh: file format not recognized; treating as linker script
05:24:55 <McManiaC> whats the problem? :S
05:24:57 <mauke> what command did you use?
05:25:02 <McManiaC> ghc -o test test.sh
05:25:08 <mauke> rename to .hs
05:25:10 <p_l> McManiaC: shouldn't that be *.hs
05:25:12 <p_l> ?
05:25:12 <mauke> and don't call it test
05:25:33 <McManiaC> oh :D
05:25:38 <McManiaC> that easy...
05:26:35 <mstr> hi, I've still got a question about "Maybe" and "Just"
05:26:52 <mstr> if I have a function Int -> Maybe Int
05:27:02 <McManiaC> what editor are u guys using?
05:27:03 <mstr> how do I handle the result?
05:27:06 <lstor> McManiaC: vim
05:27:12 <mauke> mstr: pattern matching
05:27:14 <Cale> mstr: Handle?
05:27:22 <mstr> McManiaC: emacs, but will trade for anything that works
05:27:24 <mauke> case x of Nothing -> ...; Just i -> ...
05:27:37 <Cale> mstr: Yes, usually pattern matching, if that's what you mean.
05:27:45 <mstr> so how do I get the i from Just i ?
05:27:46 <Cale> There are also functions for working with Maybe values.
05:27:57 <koeien> mstr: you pattern match, Just i -> {- here the i is in scope -}
05:28:01 <mauke> mstr: you already got it
05:28:09 <mauke> what more do you want, cruel blighter
05:28:14 <Cale> hehe
05:28:38 <Cale> :t maybe
05:28:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:28:42 <mstr> so the type I get back is "Maybe Int" not just "Maybe" ?
05:28:44 <mauke> :t fromMaybe
05:28:45 <lambdabot> forall a. a -> Maybe a -> a
05:28:55 <Cale> mstr: yes.
05:29:01 <mstr> like in C++ templates for example?
05:29:09 <Cale> mstr: Because it's either Nothing, or it's Just x, where x is an Int
05:29:12 <mauke> in some sense, yes
05:29:23 <Cheshire> there's no value that has got a type 'Maybe' since Maybe :: * -> *
05:29:26 <koeien> mstr: "Maybe" has `kind' *->*, so that is not a type on itself
05:29:29 <mauke> I think boost had something like it. boost::optional?
05:29:31 <Cale> Similar to how [Int] is a list of values of type Int
05:29:50 <Cale> (or the type thereof, rather :)
05:30:21 <mstr> now I think I finally got it :)
05:30:35 <mauke> http://www.boost.org/doc/libs/1_37_0/libs/optional/doc/html/index.html
05:30:42 <mstr> or at least my mental model seems to be close enough
05:30:48 <mauke> you can also think of Maybe as a list with at most one element
05:30:52 <Cale> > case lookup [(1,"hello"),(2,"world")] 2 of Nothing -> "oops"; Just x -> x ++ x
05:30:54 <lambdabot>       No instance for (Num [([(t, [Char])], [Char])])
05:30:54 <lambdabot>        arising from the...
05:30:57 <Cale> mm
05:31:02 <Cale> > case lookup 2 [(1,"hello"),(2,"world")] of Nothing -> "oops"; Just x -> x ++ x
05:31:04 <lambdabot>   "worldworld"
05:31:12 <Cale> > case lookup 7 [(1,"hello"),(2,"world")] of Nothing -> "oops"; Just x -> x ++ x
05:31:14 <lambdabot>   "oops"
05:31:32 <mstr> "Just x -> x ++ x" is there some kind of an implicit cast here?
05:31:36 <mauke> no
05:31:37 <Cale> mstr: no
05:31:39 <mauke> there are no casts
05:31:44 <koeien> mstr: no
05:31:45 <mstr> or type inference or whatever :P
05:31:47 <Cale> mstr: It pattern matches on the structure of the value.
05:31:56 <mauke> mstr: there is type inference in 2 + 2
05:32:06 <koeien> mstr: there is type inference going on
05:32:12 <Cale> mstr: A value of type Maybe Int is either the value Nothing, or it is of the form Just x for some x :: Int.
05:32:36 <koeien> mstr: [(1, "hello"), (2, "world")] is of type [(Int, String)], so it knows that lookup 7 ... returns a Maybe String
05:32:44 <blackh> mstr: 'maybe' and 'fromMaybe' are two very useful functions for handling a Maybe-type result. They're in Data.Maybe
05:32:48 <mstr> where does the "Maybe Int" get converted to "Int" ?
05:32:52 <Axman6> mstr: there's no casting in haskell
05:32:56 <mstr> pattern matching does it?
05:33:00 <koeien> mstr: in the pattern match. Just x :: Maybe Int
05:33:07 <mauke> mstr: it doesn't
05:33:07 <Cale> mstr: x is a String there.
05:33:07 <koeien> mstr: so x has to be of type Int
05:33:10 * Axman6 's friend got shouted at when he suggested casting in a haskell lecture
05:33:14 <koeien> ehm right, String, sorry
05:33:27 <Cale> :t Just "hello"
05:33:29 <lambdabot> Maybe [Char]
05:33:30 <koeien> Axman6: and rightly so
05:33:46 <Cale> > case Just "hello" of Nothing -> 0; Just x -> length x
05:33:47 <lambdabot>   5
05:33:47 <mstr> > Just "Hello"
05:33:49 <lambdabot>   Just "Hello"
05:33:53 <mauke> where does the employee become an amount of money in employee.getSalary()?
05:34:17 <Cheshire> :t maybe length 0
05:34:19 <lambdabot> forall a a1. (Num (a1 -> [a] -> Int)) => Maybe a1 -> [a] -> Int
05:34:26 <Axman6> koeien: well, it was like out 4th week with the language, in a coutrse for programming for engineers (basically)
05:34:33 <Cheshire> the argument order of maybe changes every day....
05:34:38 <Cale> :t maybe 0 length
05:34:38 <mauke> haha
05:34:39 <lambdabot> forall a. Maybe [a] -> Int
05:34:44 <koeien> Axman6: yeah i'm also in a university of technology. there are few haskell-fans out here
05:34:49 <Cheshire> I swear it was the other way around yesterday
05:34:54 <koeien> Axman6: most people want to "get things done"
05:34:55 <Cale> > maybe 0 length (Just "hello")
05:34:57 <lambdabot>   5
05:35:00 <Cale> > maybe 0 length Nothing
05:35:02 <lambdabot>   0
05:35:08 <Cheshire> :t foldr
05:35:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:35:16 <mauke> > length $ fromMaybe [] (Just "hello")
05:35:17 <lambdabot>   5
05:35:18 <Cheshire> :t maybe
05:35:19 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:35:22 <mauke> > length $ fromMaybe [] Nothing
05:35:24 <lambdabot>   0
05:35:27 <Cale> foldr is backwards :/
05:35:39 <Axman6> koeien: this is actually a very academic university, and has quite a few haskell nuts (ben lippmeir, the one working on GHC Sparc to name one)
05:36:08 <Cale> mstr: Is that getting any clearer?
05:36:14 <koeien> Axman6: most students here hate the course on FP :)
05:36:18 <Cale> mstr: Just "hello" is a value of type Maybe String
05:36:20 <mstr> Cale: I'm thinking hard :)
05:36:22 <Cheshire> :t foldr (\x -> maybe (Just x) Just)
05:36:24 <lambdabot> forall a. Maybe a -> [a] -> Maybe a
05:36:32 <Cheshire> > foldr (\x -> maybe (Just x) Just) Nothing "foobarz"
05:36:33 <lambdabot>   Just 'z'
05:36:35 <Axman6> koeien: yeah, i seem to be one of the only ones to like haskell sadly :\
05:36:37 <Cale> mstr: The case expression matches the parts of the value with the variables and binds the variables to their values.
05:36:42 <mstr> maybe pattern matching semantics is the thing I don't understand
05:36:46 <Cheshire> > foldr (\x -> flip maybe Just (Just x)) Nothing "foobarz"
05:36:48 <lambdabot>   Just 'z'
05:36:51 <Axman6> few see the beauty. they have this idea that programming should be all javay and C++y
05:36:51 <Cale> For example, with a list...
05:36:57 <Cheshire> > foldr (flip maybe Just . Just) Nothing "foobarz"
05:36:59 <lambdabot>   Just 'z'
05:37:05 <Cale> > case 1:(2:[]) of [] -> 0; (x:xs) -> xs
05:37:07 <lambdabot>       No instance for (Num [t])
05:37:07 <lambdabot>        arising from the literal `0' at <inter...
05:37:14 <Cale> er
05:37:16 <Cale> > case 1:(2:[]) of [] -> 0; (x:xs) -> x
05:37:18 <lambdabot>   1
05:37:25 <mstr> Axman6: the beauty is destroyed when you actually have to produce an effect :)
05:37:27 <koeien> Axman6: i liked it immediately when i saw it. otoh i'm doing both math and cs so perhaps the mathematical syntax was appealing :)
05:37:28 <Cale> > case 1:(2:[]) of [] -> []; (x:xs) -> xs
05:37:30 <lambdabot>   [2]
05:37:36 <Cheshire> mstr, and effect?
05:37:44 <mstr> at least that's what I'm feeling now. I might get over it :P
05:38:01 <Cale> mstr: IO in Haskell is quite beautiful compared to mainstream languages.
05:38:03 <mauke> > case [1,2,3] of [_,x,_] -> x * 10
05:38:04 <lambdabot>   20
05:38:12 <koeien> > case 1:2:3:undefined:[] of [] -> []; (x:xs) -> [x]
05:38:14 <lambdabot>   [1]
05:38:30 <Cale> mstr: It's just not quite as beautiful as the rest of the language :)
05:38:38 <mstr> once you get to side effects in functional language, even simple things start to require bending over backwards ;P
05:38:51 <Cale> mstr: nah
05:38:53 <Axman6> mstr: not really
05:38:54 <koeien> mstr: no
05:39:01 <Axman6> just getting used to
05:39:05 <koeien> mstr: it's easier to reason in Haskell then in, say, ML
05:39:08 <koeien> s/then/than
05:39:11 <Cale> mstr: You just represent effects as values. It solves all the problems.
05:39:20 <mstr> yea, I believe that it might be just a phase in learning
05:39:23 <koeien> @faq Can Haskell solve all problems?
05:39:24 <lambdabot> The answer is: Yes! Haskell can do that.
05:39:40 <Cale> @faq Can Haskell do that?
05:39:41 <lambdabot> The answer is: Yes! Haskell can do that.
05:39:42 <Cheshire> mstr, maybe it's not, what exactly is bending over backwards?
05:39:43 <mstr> but it's still hard to shake the idea "this is trivial in any normal language" s/normal/imperative
05:39:59 <lstor> mstr: Like qsort? :-)
05:40:00 <Cale> mstr: What in particular? :)
05:40:22 <mstr> ahh, let's not go any further. I want to learn this anyway :)
05:40:38 <Cale> Well, if you get stuck, let us know :)
05:41:05 <Cale> You'll probably find that everything which was trivial before is trivial again, just perhaps with some small changes :)
05:41:06 * Cheshire is stuck.. except it's not really a how to use haskell.. more an algorithmic thing
05:41:27 <athos> is something like: getMove :: String -> M.Map String (Foo->Bar) -> (Foo->Bar)  getMove = maybe id id $ M.lookup considered bad style?
05:41:43 <mstr> ah, I think I got the Just x = x... etc pattern thing
05:41:48 <Cheshire> athos, I consider it a type error (?)
05:42:02 <mstr> it's no different than x:xs , where x is Char and xs is [Char] ?
05:42:04 <Cheshire> unless Foo = Bar.. somehow
05:42:09 <lstor> mstr, Cale: And that some things that weren't trivial before is trivial now
05:42:28 <Cale> lstor: Yes, like defining your own control structures :)
05:42:30 <Cheshire> athos, if you are trying to give a default, I think there is an actual function which does that
05:42:37 <mstr> lstor: yea, but those things are always teached first to bait you in :P
05:43:20 <athos> Cheshire: well, i got some pairs of (String,CorrespondingFunc) in a Map, and i want to lookup a function by a string and use it
05:43:32 <lstor> mstr: Still, I think that qsort in two lines (rather than almost 30) speaks for itself :P
05:43:34 <athos> Cheshire: so somehow i have to extract the function
05:43:55 <Cale> mstr: One of the nice things about IO in Haskell is that IO actions can be stored in data structures and passed around to functions like any other value.
05:45:18 <Cale> mstr: and there are operations for combining them in various ways, and you don't have to worry about them accidentally running before you want them to, because evaluation of expressions and execution of IO actions are completely separate things.
05:45:41 <mstr> and this is good because? :)
05:46:00 <Cale> Well... you can write your own control structures to fit your task easily.
05:46:33 <mauke> you can refactor things without thinking
05:46:40 <Cale> In most popular languages these days, if you want a control structure you don't have, your only recourse is to bug the language designer, or rig up something horribly complicated.
05:47:15 <mstr> hmm, thanks for clearing the maybe thing. I'll go read one more monad tutorial and try to change my state threading random number code to something nicer :)
05:47:32 <mauke> there's a monad for that
05:47:33 <Cale> mstr: You might try the Rand monad.
05:47:56 <mstr> I still don't get monads :D
05:48:01 <mauke> there's no need to
05:48:04 <koeien> it's easy, it's just two functions :P
05:48:13 <Cale> They're just libraries which have a particular interface
05:48:33 <mauke> seriously, you can completely ignore "monads" and still write programs in haskell
05:48:38 <Cheshire> > 0+0
05:48:40 <lambdabot>   0
05:49:07 <mauke> you should understand IO and maybe learn a few useful tricks like StateT or ReaderT
05:49:13 <ivanm> mauke: and just ignore that IO is a monad?
05:49:16 <mauke> ivanm: yes
05:49:24 <mauke> you can do all of that without "understanding monads"
05:49:26 <mstr> and the do notation
05:49:29 <Cale> The fact that IO happens to be a monad is not really that important.
05:49:41 <Cale> The important thing is that IO actions are values.
05:49:44 <ivanm> Cale: just a big coincidence?
05:49:47 <koeien> although you can get some obscure error message
05:49:47 <ivanm> ;-)
05:49:52 <Cale> ivanm: basically, yeah.
05:49:55 <Cheshire> well it helps to know
05:49:58 <Cheshire> (A >> B) >> C does the same as A >> (B >> C)
05:50:05 <mauke> that's obvious
05:50:16 <koeien> that's "obvious" if you know imperative programming
05:50:20 <mauke> yep
05:50:24 <Cheshire> everything is obvious
05:50:31 <Cheshire> it doesn't mean I already know it :p
05:50:33 <ozy`> your mom is obvious
05:50:40 <mauke> Haskell's comma operator is spelled >>
05:50:42 <mauke> there :-)
05:50:58 <Cale> The only time that's not obvious is when you're working in an arbitrary monad rather than a specific one -- then you have to rely on the monad laws, and not the particulars of what >> means in your specific case.
05:51:20 <koeien> Cheshire: no, but an imperative programmer will think that   do { putStr "Hello "; putStrLn "World!" }   does the right thing.
05:51:25 <McManiaC> noob question, what is IO?
05:51:26 <koeien> and the good news is, it does :)
05:51:26 <McManiaC> :D
05:51:37 <mauke> McManiaC: a type constructor
05:51:42 * mauke <- unhelpful
05:51:57 <Cheshire> koeien, they are just assuming it, it may not be true
05:51:57 <Cale> McManiaC: If t is some type, then a value of type (IO t) is an action which if executed will produce a value of type t.
05:52:10 <koeien> McManiaC: Haskell functions cannot do Input or output or any other side effects, i.e.   fact n = product [1..n]  cannot launch the missiles
05:52:17 <Cale> McManiaC: Execution of IO actions can do just about anything (they're like arbitrary executable programs)
05:52:22 <ziman> Immediately Obvious :)
05:52:25 <Cheshire> koeien, by the same thought process they might thing  let x = a in let y = b ... a is evaluted before b
05:52:26 <koeien> McManiaC: So for any type t, IO t is an "action" that, when performed, will return a value t
05:52:32 <Cale> McManiaC: and normal Haskell evaluation doesn't cause that execution to occur
05:52:38 <mauke> IO is Intuitively Obvious!
05:52:42 <koeien> Cheshire: yeah, true. they are assuming it
05:52:49 <Cale> McManiaC: For example...
05:52:52 <Cale> :t getLine
05:52:54 <lambdabot> IO String
05:52:59 <Cheshire> GNU/IO
05:53:08 <Cale> Is an action which asks the user for a line of text, producing a String
05:53:12 <McManiaC> woot
05:53:14 <Cale> :t putStrLn
05:53:16 <lambdabot> String -> IO ()
05:53:16 <McManiaC> so many answers :D
05:53:25 <mauke> http://dis.4chan.org/read/prog/1233901578/
05:53:30 <Cale> Is a function which takes a String and produces an action for printing it on the screen.
05:53:39 <mauke> firehose
05:54:14 <Cale> McManiaC: Simple actions can be combined into more complex ones with do-notation, or various combination operations (like >>= and >>)
05:54:33 <Cale> In the end, you define an action called main, which is what is executed in a compiled program.
05:54:48 <Cale> For instance...
05:54:55 <McManiaC> ok
05:54:59 <Cale> main = do v <- getLine; putStrLn v
05:55:35 <Cale> Here, main is defined to be the action which first runs getLine, naming its result v, and then runs putStrLn v
05:55:50 <Cale> So it reads a line of text from the user, and prints it back out for them.
05:55:50 <McManiaC> think ill just continue doing this tutorial :D
05:55:55 <Cale> okay :)
05:59:20 <McManiaC> http://www.haskell.org/haskellwiki/Introduction_to_IO
05:59:21 <McManiaC> hehe
05:59:39 <JKL_>  is there a way to do this without calculate two times http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1235#a1236
06:00:09 <Cheshire> JKL_, yes
06:00:14 <JKL_> calculate 1 should be (calculate 1) i think
06:00:29 <mauke> let v = calculate 1 in do1 v + do2 v
06:00:33 <Cheshire> JKL_, let ofOne = calculate 1 in ... do1 ofOne ... do2 ofOne ...
06:01:09 <Cale> McManiaC: yes!
06:01:09 <mauke> liftM2 (...) do1 do2 (calculate 1)
06:01:13 <Cale> McManiaC: I wrote it :)
06:01:19 <McManiaC> ah okay :D
06:01:47 * Axman6 waves at Soliah 
06:06:26 <Cale> JKL_: let x = calculate 1 in ... something with x ...
06:06:39 <Cale> JKL_: x will then be computed at most once.
06:07:20 <mauke> > let x = sqrt pi in (x :: Double, x :: Complex Double)
06:07:21 <lambdabot>   Couldn't match expected type `Complex Double'
06:07:57 <Cheshire> > sqrt 2 :: Rational
06:07:59 <lambdabot>       No instance for (Floating Rational)
06:07:59 <lambdabot>        arising from a use of `sqrt'...
06:08:34 <mauke> > let x :: (Floating a) => a; x = sqrt pi in (x :: Double, x :: Complex Double)
06:08:35 <JKL_> Cheshire, mauke and cale: im trying these here. thanks.
06:08:35 <lambdabot>   (1.7724538509055159,1.7724538509055159 :+ 0.0)
06:08:37 <Cale> mauke: I'm taking for granted the fact that calculate has a monomorphic type signature ;)
06:10:26 <chrisdone> I just read the QuickCheck section of Real World Haskell. how do we test monadic code, ones with side-effects, etc.?
06:10:46 <mauke> "monadic" does not mean "does IO"
06:10:54 <chrisdone> so?
06:11:13 <chrisdone> 1) how do we test monadic code?
06:11:13 <jpcooper> could anyone please advise me on how to make infinite IO lists and pass them to pure functions with binding?
06:11:18 <chrisdone> 2) how do we test side effectual code?
06:11:19 <chrisdone> 3) etc
06:11:27 <mauke> chrisdone: what's the problem with monadic code?
06:11:37 <mauke> (I don't know how to use QuickCheck with IO)
06:12:22 <chrisdone> mauke: can I use regular quickcheck to test ST?
06:12:49 <Cheshire> why test at all?
06:12:50 <mauke> well, you can just use runST to get the results out
06:13:13 <chrisdone> I just got a paper called Testing Monadic Code with Quickcheck
06:13:17 <chrisdone> and now I am wondering what's so special
06:13:48 <chrisdone> mauke: I thought so
06:14:56 <chrisdone> Cheshire: yeah, why bother trying to find bugs?
06:15:19 <jpcooper> Cale, could you help me with this? I'm wondering whether or not it's possible. I've tried it myself but of course, the list will be empty until something comes in
06:15:30 <Cheshire> btw just out of curiousity what are you unifying?
06:15:44 <mauke> jpcooper: you mean like getContents?
06:16:15 <jpcooper> mauke, Oh yeah, I'd forgot about that
06:16:22 <Cale> [print k | k <- [0..]]
06:16:24 <Cale> ?
06:16:34 <Cale> Infinite lists of IO actions?
06:16:39 <chrisdone> Cheshire: terms for a logic language based on the one in SICP. I'm not testing ST though, that was just an example
06:16:43 <Cale> Or IO actions whose results are infinite lists?
06:16:51 <Cale> return [0..] ;)
06:16:52 <Cheshire> ok cool
06:17:21 <Cale> But if you want something like getContents, it's a bit magical.
06:17:33 <koeien> yeah but that doesn't work if you have to do immediately infinitely many actions to construct the list
06:17:33 <Cale> Its definition uses a primitive called unsafeInterleaveIO
06:17:39 <koeien> unless you use unsafeInterleaveIO
06:17:50 <Cheshire> @src unsafeInterleaveIO
06:17:51 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
06:17:56 <koeien> magic!
06:18:19 <Axman6> what does unsafeInterleaveIO actually do?
06:18:25 <Cheshire> what was the point in all this monad and pure function stuff again? :p
06:18:31 <jpcooper> Cale, I wanted to make an action that would return an infinite list of incoming commands from the net. I guess I'll use a channel for this
06:18:45 <chrisdone> unsafeBurnTooMuchIncense
06:18:49 <Cale> Axman6: It turns an IO action into one which when executed finishes immediately and produces an expression which when evaluated causes the IO to occur.
06:19:09 <ski_> (Axman6 : clone the world, pass the clone to the action, discard the resulting world and return the result and the original world)
06:19:27 <Axman6> hmm
06:19:30 <Cale> ski_: whaaa...?
06:19:35 <koeien> @faq can Haskell clone the world?
06:19:36 <lambdabot> The answer is: Yes! Haskell can do that.
06:19:47 * ski_ 's just reading the code aloud :)
06:20:45 <ski_> since obviously the world doesn't allow cloning, the actual semantics is more complicated
06:21:15 <mauke> unsafeQuantumInterleaveIO
06:21:51 <koeien> runQuantumComputation :: ...
06:22:32 <ski_> (Axman6 : anyway, listen to Cale, don't listen to me :)
06:27:47 <pejo> Suppose I have two lists of equal length, [x, y, z] and [x, a, z], and want a result list that contains the elements that were not equal and in the same position (so in this case I want [a]). Is there a nice name for that operation?
06:28:25 <lstor> pejo: In the same position, or in the same order?
06:28:48 <chrisdone> Cheshire: I am doubtful as to whether the Unifiable class can be useful for implementing an “and” operator with which one needs to unify one pattern with a fact and keep that unification "frame" in order to perform unifications on the second set of facts, unless ST has a way of extracting the state. otherwise I'll have to stay inside the ST monad, I think
06:28:50 <doserj> pejo: you only want a, not (y,a)?
06:29:20 <mauke> :t \x y -> map snd . filter (uncurry (/=)) $ zip x y
06:29:22 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
06:29:56 <chrisdone> (and (foo a ?x) (?k ?y ?x)) -- bindings for ?x obviously need to be carried over to any unfications for (?k ?y ?x) and a fact
06:30:48 <Cheshire> chrisdone, did you look at my examples like the type inference?
06:31:05 <pejo> mauke, and what would you call that function?
06:31:14 <athos> @hoogle <+>
06:31:15 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
06:31:15 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
06:31:15 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
06:31:15 <Cheshire> chrisdone, it traverses syntax doing a unification at each jundction
06:31:52 <mauke> pejo: I don't know
06:31:58 <pejo> doserj, either works
06:32:20 <Cheshire> chrisdone, all unification is local to things inside the Unify monad.. if you wanted a pure implementation could change Unify from ST into Map or hold a substitution (Var -> Value)..
06:32:43 <chrisdone> yeah fair enough
06:32:44 <Cheshire> actually I'm not sure how well that would work out in terms of type checking
06:33:01 <chrisdone> I don't know about type checking
06:33:21 <doserj> pejo: something like "difflist"?
06:33:36 <lstor> pejo: I think 'Victoria' is a nice name
06:34:09 <chrisdone> but
06:34:09 <lstor> Of course, in the event that function names should be descriptive, difflist is better, I guess...
06:36:13 * ski_ thinks it would be interesting to make an implementation of unification parametric enough in the implementation of substitution to allow both persisent ones and ephemeral ones like with `ST s'
06:36:33 <pejo> doserj, thanks. Makes completely sense.
06:36:40 <doserj> actually, I would probably call it "zipFilter (/=)"
06:36:49 <ski_> pejo : not sure, but maybe it would be easier to name if you generalized it ..
06:36:50 <chrisdone> Cheshire: I do like how the unification is nice and contained with ST
06:37:50 * ski_ supposes he should finish off his LP embedding in haskell some time ..
06:37:58 <chrisdone> at first I was WTF'ing at the code but then I scratched my head a lot and aha'd
06:38:07 <chrisdone> ski_: what have you started?
06:39:13 <ski_> chrisdone : a working (i think) logic monad, with logic variables and skolems (with a few caveats)
06:40:09 <chrisdone> can I see?
06:40:21 <ski_> sure
06:40:53 <Cheshire> ski_, that would be interesting..
06:41:41 <beelsebob> hmm, is there anywhere a BNF grammar for Haskell that incorporates the offside rule into the grammar?
06:41:53 <beelsebob> the one in the report only specifies the syntax with { and }
06:43:26 * beelsebob isn't totally sure it can be encoded into BNF
06:45:10 <chrisdone> has anyone used the Cont monad for anything real? it's neat but I've not yet had chance to solve a problem with it
06:45:38 <chrisdone> (or ContT)
06:47:13 <Cheshire> beelsebob, I think BNF is turing complete
06:47:22 <beelsebob> not at all
06:47:29 <beelsebob> it's context free
06:47:31 <ozy`> Cheshire: uhhh... dude
06:47:39 <ozy`> chomsky hierarchy much?
06:47:50 <ozy`> it might be touring complete but it's not turing complete.
06:48:07 <mauke> I think HTML is turing complete
06:48:09 * Cheshire is thinking about something else
06:48:10 <Cheshire> @go Markov algorithm
06:48:12 <lambdabot> http://en.wikipedia.org/wiki/Markov_algorithm
06:48:12 <lambdabot> Title: Markov algorithm - Wikipedia, the free encyclopedia
06:49:32 <chrisdone> nice
06:49:43 <jpcooper> @p (\n c -> c >>= maybe (return ()) (writeChan chan) >> actual n)
06:49:43 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
06:49:44 <lambdabot> v
06:49:48 <jpcooper> @pl (\n c -> c >>= maybe (return ()) (writeChan chan) >> actual n)
06:49:49 <lambdabot> flip ((>>) . (maybe (return ()) (writeChan chan) =<<)) . actual
06:50:49 <ski_> (chrisdone : clarifying, in case i wasn't clear : i haven't implemented aforementioned substitution parametricizing, i was just thinking that would be nice)
06:51:07 <chrisdone> ski_: okay
06:51:37 <Cheshire> beelsebob, is offside context-free?
06:51:52 <beelsebob> I don't know
06:51:56 <ski_> (chrisdone : i have implemented a basic LP system, with an extra unusual (i believe) feature, namely, implication (and `forall') goals which admits exporting instantiations)
06:51:57 <beelsebob> but I suspect not :/
06:52:51 <ski_> chrisdone : i'll give you the link to the system in PM, since its not really completed,polished
06:52:58 <chrisdone> ski_: cheers
06:53:24 * beelsebob wonders if the only way to encode Haskell syntax into a text editor properly would be to allow people to just write their own parsers
06:53:25 <chrisdone> what does this markov algorithm remind me of
06:53:46 <Cheshire> ozy`, it was quite insulting the way you replied about that turing complete, but maybe you will find this interesting: http://en.wikipedia.org/wiki/Context-free_grammar#Undecidable_problems
06:53:53 <Cheshire> ozy`, specifically the bit about Universality
06:54:26 <ehird> BNF is not turing complete.
06:54:37 <ehird> ozy`'s response wasn't rude, it's just... saying BNF is TC is absolutely nonsensical
06:55:14 <Cheshire> ehird, I'm not saying it is
06:55:20 <ehird> that's what you said...
06:55:23 <ozy`> Cheshire: I -was- deliberately being snarky but I didn't expect to actually insult you. sorry about that
06:55:27 <ehird> <Cheshire> beelsebob, I think BNF is turing complete
06:55:37 <Cheshire> ehird, I made a mistake
06:55:40 <ehird> ah
06:55:41 <ehird> OK
06:55:45 <Cheshire> ehird, Do you know what that is? :p
06:55:46 <ehird> i thought you were still saying it was :-)
06:55:51 <ehird> also, no.
06:55:54 <ehird> I'm immortal and perfect.
06:56:18 * Badger swaps words on the "im"
06:56:19 <chrisdone> ski_: did you pm me? I didn't see anything
06:56:46 <Cheshire> so deciding if a CFG is the empty language is equiv. to the halting problem (?)
06:57:22 <ehird> seems so
06:59:17 <chrisdone> hey bonus
06:59:40 <BONUS> heyo
06:59:45 <BONUS> what's crackin
07:00:45 <chrisdone> unification and logic monads and CFGs
07:01:48 <chrisdone> "Beware of bugs in the above code; I have only proved it correct, not tried it." -- Donald Knuth
07:01:51 <chrisdone> discuss
07:02:37 * Badger sends chrisdone to haskell-blah with that quote.
07:02:42 <Cale> ehird: No, the emptiness problem is decidable for CFGs.
07:02:48 <ozy`> heh, adding (CL-style) macros to that scheme tutorial is surprisingly easy... apply (...) >>= eval instead of eval (...) >>= apply
07:02:56 <Cale> It's context sensitive languages which it's undecidable for.
07:02:58 <ski_> chrisdone : just packaged up my current latest version .. coming
07:03:01 <ehird> chrisdone: old.
07:03:05 <chrisdone> ozy`: interesting
07:03:08 <chrisdone> ehird: ya think?
07:03:14 <chrisdone> ski_: ok
07:03:22 <ehird> yes. donald knuthosaurus, a dinosaur, wrote it :P
07:03:23 <Cale> Er, oh, I missed a good bit of that conversation ;)
07:03:54 <athos> @pl \x -> maybe id id $ M.lookup x foo
07:03:55 <lambdabot> maybe id id . flip M.lookup foo
07:05:52 <Cale> Oh, interesting. Apparently the problem which asks for a given CFG whether the language it generates is regular is an undecidable problem.
07:06:17 <beelsebob> that's interesting
07:06:34 <beelsebob> I would have expected there to be a fairly small set of things that stopped it being regular
07:07:49 <athos> > foldr f z [a,b,c]
07:07:52 <lambdabot>   f a (f b (f c z))
07:10:07 <gmaths> hi i'm trying to install package HStringTemplate-0.4.3 but when i try to build it i got a message like this: "Could not find module 'Data.Generics.Aliases': it is a member of package base-3.0.3.0, which is hidden". I checked the build-depends inside the *.cabal file i see that the base package is refered there. There is something else i need to check?
07:11:25 <Saizan> gmaths: put base == 3.* in build-depends
07:11:25 <byorgey> Cale: really?  amazing.
07:11:34 <xci> '
07:11:53 <Saizan> gmaths: or configure with --constraint="base < 4"
07:11:54 <gmaths> Saizan: Thanks, just a mom, i'll try here
07:12:58 <ziman> Cale, could you give a rough sketch why it is undecidable?
07:13:24 <gmaths> i put this in the *.cabal file: build-depends:	     base == 3.*
07:13:29 <gmaths> but i get the same message
07:13:34 <Cale> ziman: The thing I'm reading doesn't have the proof here. I suppose I could look it up.
07:13:52 <McManiaC> how can i setup vim to indent my hs files correct?
07:14:05 <gmaths> Saizan: Ok, I'll try to put the --constraint there
07:14:21 <Cale> However, apparently deciding if a CFG generates all strings on the alphabet is also undecidable...
07:14:27 <RayNbow> Cale: I did find a proof that says that L(G) =? L(R) is undecidable
07:14:31 <asgaroth> McManiaC: That can't be done completely automatic since indentation is semantically relevant
07:15:10 <ehird> asgaroth: I think that's very pedantic.
07:15:13 <ehird> There is an indentation file for vim.
07:15:18 <Cale> So given that much, a constructive way of showing that the CFG is regular is out of the question.
07:15:35 <ehird> McManiaC: http://tokyoenvious.xrea.jp/vim/indent/haskell.vim
07:15:35 <asgaroth> ehird: Hmm, but this is some semi-automatic thing, right?
07:15:45 <ehird> asgaroth: It helps immensely.
07:15:59 <ehird> same with haskell-indent.el or whatever it's called for emacs
07:16:09 <asgaroth> Yes, I also use something like that for emacs. I just wanted to point out that it won't be complete
07:16:18 <mauke> I indent my code manually
07:16:19 <asgaroth> s/complete/completely automatic/
07:16:23 <ehird> McManiaC: but do this in your vimrc
07:16:26 <ehird> let g:haskell_indent_if = 2
07:16:28 <ehird> let g:haskell_indent_case = 4
07:16:32 <ehird> since the defaults are screwy
07:16:45 <McManiaC> asgaroth: anything better than the current tab will do it ;)
07:16:55 <mauke> what's wrong with tab?
07:17:38 <Cheshire> Cale, it may be possible to prove it in some cases though, like termination of PEGs is proved for a subset of PEGs by a kind of abstract-evaluation
07:17:50 <Cheshire> Cale, (constructively)
07:18:12 <ehird> McManiaC: I just linked you :-)
07:18:33 <McManiaC> ?
07:19:14 <McManiaC> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
07:19:19 <McManiaC> i installed that but it wont work =(
07:20:01 <ehird> I linked you.
07:20:15 <ehird> 15:15 <ehird> McManiaC: http://tokyoenvious.xrea.jp/vim/indent/haskell.vim
07:20:15 <Cale> Apparently to show that it's undecidable whether a CFG generates all strings, you construct a CFG which generates all strings which are not accepting computation histories for a Turing machine (descriptions of the entire computation of it) on a particular input, and so the CFG will accept all strings only if the machine doesn't accept that input.
07:20:16 <ehird> 15:16 <ehird> McManiaC: but do this in your vimrc
07:20:16 <ehird> 15:16 <ehird> let g:haskell_indent_if = 2
07:20:18 <ehird> 15:16 <ehird> let g:haskell_indent_case = 4
07:20:20 <ehird> 15:16 <ehird> since the defaults are screwy
07:20:23 <McManiaC> yeh i did that
07:20:26 <McManiaC> but it wont work...
07:20:35 <ehird> McManiaC: you did load the file in your vimrc, right?
07:20:54 <Saizan> gmaths: worked?
07:20:54 <McManiaC> how?
07:20:55 <McManiaC> ^
07:21:01 <ehird> McManiaC: see vim docs :-)
07:21:08 <RayNbow> "Inserting an existing element into a binary search tree copies the entire search path even though the copied nodes are indistinguishable from the originals. Rewrite INSERT using exceptions to avoid this copying. Establish only one handler per insertion rather than one handler per iteration."
07:21:08 <RayNbow> hmm, would a solution in Haskell resort to exceptions? (exercise from Okasaki's data structures book; uses Standard ML)
07:21:33 <McManiaC> hmmm
07:21:33 <McManiaC> ^^
07:21:40 <ehird> Raynes: i'd go for continuations
07:22:06 <Saizan> or the Either e monad
07:22:08 <gwern> hm. where does one get 'hc2ps'?
07:22:40 <Saizan> it's hp2ps
07:22:50 <gwern> is it?
07:23:03 <Heffalump> it is.
07:23:09 <Cheshire> RayNbow, idiomatic haskell would not use a zipper?
07:23:22 <gwern> that would explain why John couldn't get it to work, presumably
07:23:30 <idnar> using exceptions? wtf
07:24:17 <Saizan> uhm, how do you do it with exceptions in ML?
07:24:20 <RayNbow> ehird: I'm not quite familiar with continuations (I have only read about them, never put them to practice... maybe this is a good time to practice :p)
07:24:49 <ehird> exceptions = one-use down-only continuations
07:24:51 <Toxaris> you can easily "simulate" the exception-solution here with continuations
07:25:22 <Saizan> ah, "existing"
07:25:30 <McManiaC> where in the vim docs ehird ? ^^
07:25:45 <ehird> 'load' function, I believe
07:25:47 <ehird> while since I used vim
07:25:53 <Toxaris> more Haskell-style would maybe be to return Maybe (new tree here), and Nothing signifies to take the old tree
07:25:56 <ehird> hmm, no
07:25:58 <ehird> McManiaC: source
07:26:00 <ehird> in your vimrc
07:26:08 <ehird> source ~/.vim/indent/haskell.vim
07:26:11 <ehird> let (put the settings I said here)
07:26:51 <FunctorSalad> how do I use syb to convert (Foo X Y Z) to (Bar X Y Z)?
07:26:56 <McManiaC> thx ehird
07:27:02 <FunctorSalad> where Foo and Bar are constructors of different types
07:27:05 <coco`> join /#Haskell
07:27:20 <ehird> coco`: you're already here.
07:27:21 <gmaths> Saizan: sorry, i couldn't find where exactly should i put that --constraint flag. i'm doing some research here about this
07:27:21 <Toxaris> RayNbow: like   if contains element tree then tree else insert element tree,  but  contains and insert fused into one
07:27:31 <Saizan> ?type gfoldl
07:27:31 <ehird> :)
07:27:32 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
07:27:39 <FunctorSalad> XD
07:27:55 <coco`> ehird: thanks, sorry :)
07:28:03 <FunctorSalad> that one always makes for a good party joke (j/k)
07:28:14 <coco`> how can I make an IO operation atomic wrt to other haskell threads?
07:28:26 <ehird> hunh?
07:28:36 <Saizan> gmaths: how are you trying to build the package?
07:28:40 <Toxaris> RayNbow: but note that this optimization makes the insert operation more strict, which doesn't matter in ML, but may be good or bad in Haskell
07:29:17 * RayNbow nods
07:29:31 <Saizan> gmaths: you can e.g. do: runghc Setup configure --constraint="base < 4" -- user && runghc Setup build && runghc Setup install
07:30:38 <Saizan> coco`: you can use a MVar or a QSem
07:31:12 <gmaths> Saizan: Thanks very much! now it is working...
07:31:18 <FunctorSalad> ,type Color
07:31:20 <lunabot>  luna: parse error on input `type'
07:31:41 <FunctorSalad> ,[t|Color|]
07:31:42 <lunabot>  luna: Not in scope: type constructor or class `Color'
07:32:12 <FunctorSalad> ,[t|Point|]
07:32:13 <lunabot>  luna: Not in scope: type constructor or class `Point'
07:32:47 <coco`> isn't it weird that putStrLn is *not* atomic ?
07:33:43 <JKL_> is here something I have done really bad http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1237#a1237
07:33:58 <int80_h> any suggestions for good primality test algorithms?
07:34:16 <int80_h> I'll *implement*, I'm just looking for a good algorithm
07:34:22 <gwern> erastoshene's sieve? :)
07:34:37 <int80_h> That's a good generator
07:34:54 <Raevel> int80_h: rabin's
07:35:11 <gwern> well, isn't a generator a tester too? if you generate anything >n, without n appearing, then it's not a prime
07:35:12 <int80_h> but if I have some number X, I want to prove it's a prime (or not)
07:35:43 <mauke> JKL_: it looks like newbie code, but nothing totally awful :-)
07:35:51 <byorgey> int80_h: look up the pollard rho algorithm, perhaps?
07:36:07 <JKL_> mauke: did I passed it tought?
07:36:19 <mauke> taught?
07:36:27 <int80_h> thanks I'll look up rabin's and pollard rho :)
07:36:29 <JKL_> hmm, anyway
07:37:02 <Raevel> hmm, there might be a better one, but i forgot what the name was
07:37:10 <JKL_> but it looks like I can read on that yaht tutorial?
07:37:45 <leimy> So that BASIC EDSL was awesome
07:37:48 <leimy> anyone ever find the source to it?
07:39:05 <byorgey> leimy: I think augustss is intentionally keeping it secret, as a puzzle =)
07:39:12 <leimy> hah
07:39:14 <leimy> oh well
07:39:18 <leimy> it's pretty neat
07:39:23 <augustss> :)
07:39:24 <lambdabot> augustss: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:39:24 <byorgey> perhaps he will reveal it at some point.
07:39:31 <Raevel> int80_h: rabin is O((log n)^k), and there's a deterministic one by Arawal Kayal and Saxena with the same complexity
07:39:57 <leimy> I'm hoping the hackery to make it look like BASIC and have line number labels isn't too hacky :-)
07:40:16 <augustss> leimy: it's not pretty
07:40:25 <augustss> and I'm making it uglier
07:40:25 <leimy> I had a hunch it might not be
07:40:25 <byorgey> some sort of function instance for Num, I'm guessing
07:40:35 <augustss> yeah
07:41:16 <leimy> Yeah that's about the only way I could figure that would work.
07:41:27 <Toxaris> what about a <some grammar formalism> to <type class hackery> compiler?
07:41:33 <leimy> is there a way to restrict that interpretation to the context of runBasic?
07:41:49 <mauke> http://rafb.net/p/m3d63F96.html
07:41:55 <pmurias> hi
07:42:19 <byorgey> JKL_: looks pretty good to me.
07:42:22 <pmurias> does any one know when will be the third reactive tutorial published?
07:42:32 <JKL_> good
07:42:37 <Toxaris> that BASIC thing does more then just a function instance for numbers, I think it has to be a polyvariadic function instance for numbers
07:42:40 <JKL_> then chapter 4 :)
07:42:44 <byorgey> JKL_: note that there are already functions in the prelude called 'sum' and 'product' that do those folds
07:42:47 <byorgey> > sum [1,2,3,4]
07:42:49 <lambdabot>   10
07:43:04 <leimy> Toxaris: so like Text.printf? :-)
07:43:16 <byorgey> JKL_: but yes, definitely move on to the next chapter =)
07:43:20 <Toxaris> leimy: yes
07:43:34 <Toxaris> leimy: but more complicated, because it has to "parse" the structure of the BASIC code
07:43:44 <leimy> Toxaris: I looked at the code for Text.Printf.printf.... and then I decided not to look at it anymore.
07:43:53 <JKL_> well i really should think that sum is in prelude :)
07:44:26 <Toxaris> so i guess its a big fat GADT which contain all the keywords and variables and everything, and represents it on value and type level, and type class hackery to parse the type level representation
07:44:39 <leimy> I wish I knew what Hapstack was capable of, I'd probably be more interested if I could get a demo :-)
07:45:19 * Toxaris is short before trying to plagiate it, but has too much real work to do unfortunately :(
07:46:48 <leimy> Hmmm.  GHC sparc port is looking good too
07:47:00 <rwbarton> Toxaris: the especially tricky thing is that 40 IF X <> 11 THEN 20 *has* to parse as (40 IF X) <> (11 THEN 20)
07:47:26 <Saizan> FunctorSalad: let me know if you can do it without an existential like data AData = forall a. Data a => AData a
07:47:30 <Toxaris> rwbarton: good point.
07:49:02 <byorgey> whoa.  that's nasty.
07:49:08 <Toxaris> are nested expressions allowed?
07:49:46 <rwbarton> Good question.
07:50:22 <rwbarton> If they're not, you can just parse (40 IF X) <> (11 THEN 20) to some tree with <> as the root, and then flatten the tree in order and re-parse according to BASIC syntax
07:52:40 <Toxaris> this looks like one needs some CPS here
07:52:55 <byorgey> Toxaris: definitely, for the goto's
07:53:12 <byorgey> or at least something involving ContT
07:53:16 <Toxaris> byorgey: well, the gotos are implemented by runBasic, so no problem
07:53:24 <Toxaris> I mean for the parsing
07:53:29 <byorgey> ah, hm
07:53:47 <byorgey> good point
07:54:00 <Toxaris> the denotation of (40 IF X) and (11 THEN 20) have to be combined by (<>)
07:54:15 <Toxaris> but (<>) has no clue about its own position in the BASIC syntax tree
07:54:28 <Toxaris> but (40 IF X) knows everything (because it is the left-most portion of the parsed stuff)
07:54:47 <Toxaris> so what about   a <> b   =  a NotEqual b
07:55:02 <Nafai> Dang it.
07:55:04 <Toxaris> this way, a sees that it is followed by "<>" and b, and can decide what to do
07:55:11 <Nafai> I need to upgrade to GHC 6.10
07:55:36 <Cheshire> Toxaris, that is so clever :p
07:55:40 <ehird> augustss: You should give us the library object file so we can test :-)
07:55:44 <Cheshire> Toxaris, I think that would work
07:56:16 <SamB_XP> ehird: what is this ... binary compatability ... you speak of ?
07:56:30 <augustss> ehird: you have a Mac?
07:56:42 <ehird> SamB_XP: Cross-compiling is hard, let's go to the stone ages. augustss: Yes.
07:57:36 <augustss> ehird: I'm actually rewriting a bit at the moment.  So you can do '10 PRINT "X = "; X'
07:57:45 <ehird> augustss: make that ,
07:57:50 <ehird> 10 PRINT "X =", X
07:57:56 <augustss> ehird: No, ';'
07:58:05 <ehird> oh, is that what basic had it as
07:58:05 <ehird> ?
07:58:07 <ehird> odd.
07:58:12 <augustss> ehird: BASIC had both
07:58:23 <ehird> augustss: btw, for =, find a unicode character that looks the same
07:58:30 <ehird> like, - with overline or something
07:58:34 <augustss> with ';' they print next to each other, with ',' they print a tab stop apart
07:58:36 <ehird> that would work
07:59:03 <rwbarton> > 7. 9
07:59:04 <augustss> ehird: Using Unicode is a bit of a cheat
07:59:04 <lambdabot>       Overlapping instances for Show (a -> c)
07:59:04 <lambdabot>        arising from a use of `s...
07:59:06 <rwbarton> > 7, 9
07:59:08 <lambdabot>   <no location info>: parse error on input `,'
07:59:19 <ehird> augustss: :-)
07:59:28 <ehird> augustss: It's the closest you can get, though.
07:59:33 <ehird> I'd just stay with =: or := or whatever.
07:59:35 <augustss> ehird: But I'll switch to :=
07:59:36 <ehird> I'm sure _some_ BASIC supports that.
07:59:37 <augustss> ehird: the new version is much, much nastier
07:59:41 <ehird> augustss: Oh no.
07:59:52 <ehird> augustss: SplutteringAndGibberingInstances?
07:59:59 <augustss> unsafePerformIO
08:00:06 <ehird> ...
08:00:14 <ehird> We're not talking any more.
08:00:52 <ehird> You killed the channel with that, augustss.
08:01:02 <augustss> It's unclean.
08:02:00 <Toxaris> ehird: ":=" is harder, because it is a data constructor, so you cannot play parsing tricks with it
08:02:12 <ehird> sure you can.
08:02:21 <Toxaris> ehird: and it cannot be ad-hoc polymorphic.
08:02:31 <augustss> Toxaris: '10 PRINT "X = "; X" is equally hard
08:02:32 <ehird> Toxaris: GHC.Any
08:02:47 <ehird> wait, I was just shunning augustss for unsafePerformIO
08:02:51 <ehird> why did I suggest GHC.Any?
08:03:08 * augustss ponders GHC.Any
08:03:19 <vsthesquares> hey guys, is there someone with access to the haskell wiki?
08:03:20 <Toxaris> augustss: the ";" is your regular monadic semicolon here? nasty.
08:03:26 <vsthesquares> there's some spam on the front page
08:03:40 <vsthesquares> "silver jewelry", it's very subtle ;)
08:04:08 <augustss> Toxaris: it's the only semicolin I have
08:04:30 <ehird> GHC.Any breaks my brain
08:04:43 <njbartlett> Hoorah! My copy of RWH finally arrived!
08:06:03 <Toxaris> is there some trick for a one-click revert?
08:06:05 <RayNbow> njbartlett: how long did it take?
08:06:28 <njbartlett> RayNbow: Two weeks
08:06:52 <vsthesquares> Toxaris: don't know, registrations have been taken down to prevent even more spam, so I couldn't say
08:06:57 <Toxaris> (except for waiting for dons to do it)
08:07:17 <njbartlett> RayNbow: Amazon "super saver" delivery, which was further delayed by snow in the UK
08:07:27 <vsthesquares> great, it's gone!
08:08:30 <SamB_XP> Toxaris: why one-click ?>
08:08:44 <RayNbow> njbartlett: ah yeah, I saw on the news the UK had a lot of snow recently
08:08:48 <p_l> njbartlett: 2 weeks is pretty tame... was it domestic delivery or international?
08:08:51 <pk_> @hoogle unsafePerformIO
08:08:52 <lambdabot> Foreign unsafePerformIO :: IO a -> a
08:08:52 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
08:08:54 <Toxaris> SamB_XP: I mean a "revert to this version" function in the version history
08:09:13 <njbartlett> p_l: Domestic, I ordered from amazon.co.uk
08:09:17 <SamB_XP> Toxaris: maybe you have to pick two versions and revert the changes between them ?
08:09:32 * RayNbow asked a Dutch bookshop to order a copy of RWH... it took 15 days
08:09:41 <p_l> njbartlett: ok, then not so fast <--- last time waited ~4 weeks for international package that usually arrived in 9 days
08:11:28 <vsthesquares> RayNbow: which bookshop? bol?
08:11:47 <gwern> Toxaris: dons already did it
08:11:59 <RayNbow> vsthesquares: Selexyz Donner
08:12:11 <Toxaris> gwern: yeah, as I said "(except for waiting for dons to do it)" :)
08:12:55 <RayNbow> in December, I couldn't find a shop that had RWH in its catalog
08:12:57 <vsthesquares> RayNbow: I think purchasing online might have gone faster...
08:13:20 <RayNbow> so I just emailed Selexyz if they could order it for me
08:13:59 <njbartlett> I simply don't bother trying real "bricks and mortar" bookshops for technical books. Unless you want "Java for Dummies" or "C# in 21 days" they're utterly useless
08:18:42 <p_l> njbartlett: I found normal bookshops quite useful, even if some rarer topics are sometimes overlooked :)
08:20:11 <ozy`> njbartlett: the biggest bookshop around here always has at least five copies of RWH on the shelf... but not a whole lot interesting apart from that
08:20:52 <SamB_XP> ozy`: what, no fiction ?
08:21:13 <SamB_XP> ozy`: how long have they had RWH in stock ?
08:21:35 <ozy`> SamB_XP: I meant as far as CS/programming books :p
08:21:59 <ozy`> they've had it since it came out, but I've visited a few times and the number of copies fluctuates
08:22:10 <SamB_XP> hmm, they should publish a sequel:
08:22:10 <ozy`> so I assume people are buying them and they're restocking them
08:22:13 <SamB_XP> Haskell in Fantasy
08:22:24 <ozy`> hahaha
08:22:33 <SamB_XP> ozy`: oh, pooh, only since it came out ?
08:26:06 <Philonous> base >= 4 means you need ghc 6.10, doesn't it?
08:26:47 <Heffalump> Philonous: yes
08:33:18 <Martijn> How do I enable local echo in Haskeline's getInputLine?
08:40:07 <jeffwheeler> @yhjulwwiefzojcbxybbruweejw
08:40:08 <lambdabot> Just 'J'
08:40:13 <jeffwheeler> What the heck is that?
08:40:20 <jeffwheeler> @yhjulwwiefzojcbxybbruweejw
08:40:21 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
08:40:32 <Cheshire> > fix (show . Just)
08:40:34 <lambdabot>   "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\...
08:40:41 <Cheshire> > fix (Just . show)
08:40:42 <lambdabot>   Just "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\...
08:41:00 <jeffwheeler> > fix (show)
08:41:02 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
08:41:04 <Cheshire> > fix (Just . return . head . show)
08:41:06 <lambdabot>       No instance for (Show (m Char))
08:41:06 <lambdabot>        arising from a use of `show' at ...
08:41:11 <Cheshire> > fix (Just . head . show)
08:41:13 <lambdabot>   Just 'J'
08:41:55 <dolio> Back in the day, when lambdabot evaluated expressions, it used to use a variable named v or something.
08:41:56 <jeffwheeler> @hoogle+ fix
08:42:11 <dolio> So if you used v in your expression, you could get it to print weird stuff.
08:42:31 <dolio> When people figured that out, they changed the name to yhjulwwiefzojcbxybbruweejw.
08:42:33 <Cheshire> ?where v
08:42:33 <lambdabot> I know nothing about v.
08:43:05 <dolio> So @v and @yhjulwwiefzojcbxybbruweejw are quotes of things people had it print out.
08:43:06 <jeffwheeler> @freshname
08:43:07 <lambdabot> Haj
08:43:12 <jeffwheeler> @freshname
08:43:13 <lambdabot> Hak
08:43:14 <jeffwheeler> @freshname
08:43:15 <lambdabot> Hal
08:43:20 <jeffwheeler> That one's not fresh!
08:43:47 <jeffwheeler> @help bf
08:43:48 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
08:44:02 <jeffwheeler> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
08:44:03 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
08:44:09 <redditbot> darcs advanced revision control system: darcs weekly news #16
08:44:11 <ozy`> @
08:44:23 <ozy`> @bf +.
08:44:24 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
08:44:28 <ozy`> huh
08:44:28 <maltem> Is there a way to subscribe to haskell-cafe without receiving the messages?
08:44:33 <jeffwheeler> How can I invite lambdabot to #yi?
08:44:37 <ozy`> @help let
08:44:38 <lambdabot> let <x> = <e>. Add a binding
08:44:41 <ehird> @bf is broken.
08:44:42 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
08:44:42 <ozy`> @help unlet
08:44:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:44:48 <ehird> Use another BF bot.
08:44:48 <ozy`> @list
08:44:49 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:45:12 <jeffwheeler> @invite #yi
08:45:13 <lambdabot> Unknown command, try @list
08:45:20 <jeffwheeler> I know I've seen this before . . .
08:45:49 <Badger> !seen Cale
08:45:52 <Badger> err
08:45:55 <Badger> @seen Cale
08:45:55 <lambdabot> Cale is in #haskell, #ghc, #haskell-overflow and #haskell-in-depth. I last heard Cale speak 1h 25m 40s ago.
08:45:55 <Cale> hi
08:46:10 <jeffwheeler> Cale: how can I invite lambdabot to #yi?
08:46:23 <Cale> lambdabot: @join #yi
08:46:34 <Cale> Need that to be permanent? :)
08:46:40 <jeffwheeler> That'd be great, thanks!
09:04:06 <Cheshire> you know "Curry-Howard Isomorphism" is there a formal statement of it?
09:05:57 <Cale> Cheshire: It's really more of a way of thinking than a concrete theorem, but you can write things down for particular systems that reflect it.
09:07:38 <Cale> Cheshire: Roughly, "types are statements, programs are proofs"
09:07:56 <SamB> "type systems are logics"
09:21:24 <liwp2> is there an elegant way to get a value from a map and delete it from that map? The key might not be in the map, i.e. I must handle maybes. I'm doing this for a number of keys so it get a bit ugly if you need to thread the modified map along after each delete
09:22:03 <BONUS> use the state monad?
09:22:13 <liwp2> yeah, that's an option
09:22:26 <Saizan> or just a fold
09:22:41 <BONUS> yeah or that
09:22:49 <BONUS> also if it's not there and you want it deleted, what do you want to happen?
09:23:03 <BONUS> the natural thing for me would be if just the original Map is returned then
09:23:03 <liwp2> nothing
09:23:12 <liwp2> yeah that's right
09:23:55 <liwp2> i still want to use the value that i've deleted tho, so a fold is not that great because i'll have to dig the values out of the return value
09:24:30 <liwp2> i have a data type like data Foo = Foo T T (Map K T)
09:25:01 <liwp2> sorry, actually it'r data Foo = Foo (Maybe T) (Maybe T) (Map K T)
09:25:14 <liwp2> and I want to fill in the first to fields with values from the map
09:26:02 <liwp2> maybe a fold will work...
09:26:53 <liwp2> i can return an assoc list with (key, Nothing) in it and then use Data.List.lookup to dig out the vals
09:27:52 <liwp2> and use fromJust to avoid having to deal with the Maybe a's returned by lookup
09:29:31 <maltem> liwp2: maybe you could also return a map that maps removed keys to values. That would have the neat effect of the original map being the union of the resulting maps
09:29:42 <rwbarton> So you have a map and a list of keys and you want a list of the corresponding values and a copy of the map with those key/value pairs removd?
09:30:21 <liwp2> rwbarton: yeah, that's right
09:30:33 <rwbarton> What if a key appears twice in the input list?
09:31:08 <liwp2> maltem: that sounds good actually, i can create the 'to_delete' map first and then get the difference of the orig map and the to_delete map
09:31:30 <liwp2> rwbarton: shouldn't happen, although i have no idea at the moment to guarantee that
09:31:50 <rwbarton> That sounds pretty good
09:32:32 <liwp2> the added bonus is that the value types as data Attr = A String | B String | C | D... and I'm interested in the wrapped value, so i need to unwrap the returned value as well
09:32:50 * Nafai tries to backport the new ghc packages from Debian experimental to Ubuntu Intrepid
09:32:51 <maltem> hm... does any Data.Map fusion exist that would suffer under those two traversals?
09:33:08 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1238
09:33:20 <rwbarton> It might be better to put the keys you care about in a Set and then use Map.partition
09:33:22 <int80_h> Project euler problem :)
09:33:32 <int80_h> it's fun and exciting :)
09:34:34 <liwp2> rwbarton: map partition might be a good idea actually
09:35:04 <liwp2> avoids me having to create the to_Delete map
09:35:28 <liwp2> thanks everyone
09:35:34 <jpcooper> if one tries to get the head of a currently empty list returned by getChanContents, what should happen?
09:35:51 <maltem> ah, I would have proposed Map.partition, had I known of its existence :)
09:36:01 <koeien> jpcooper: i think this gets blocked :) not sure
09:36:03 <liwp2> maltem: me too ;)
09:36:13 <jpcooper> koeien, I was hoping that it would, but this doesn't seem to be the case
09:36:20 <jpcooper> I'm doing foldl over it
09:36:29 <jpcooper> sorry, foldM
09:36:33 <mmorrow> jpcooper: what's the type of your Chan ?
09:36:48 <jpcooper> my own defined type
09:36:57 <mmorrow> i don't think getChanContents will ever complete
09:37:09 <Saizan> well the action will
09:37:09 <rwbarton> @src foldM
09:37:09 <lambdabot> foldM _ a []     = return a
09:37:10 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
09:37:13 <mmorrow> because it can't ever know if there're any more to get
09:37:21 <Saizan> but it returns an infinite list
09:37:24 <mmorrow> yes, the action will, but the
09:37:26 <mmorrow> exactly
09:37:26 <koeien> no, there is no way to "close" it
09:37:35 <int80_h> I'm trying to generate primes of the form 2n^2-1, as part of a project euler problem. Could someone check out my broken code? I have output as well.
09:37:38 <jpcooper> yes, I don't want it to complete
09:37:41 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1238
09:37:48 <jpcooper> there is a thread taking commands from the net that is writing to the channel
09:37:56 <jpcooper> or at least would be if I didn't get an empty list error
09:38:10 <mmorrow> i like to do  Chan a ==> Chan (Maybe a), then have a Nothing signal "EOF"
09:38:20 <Saizan> > head [] -- this error?
09:38:22 <lambdabot>   * Exception: Prelude.head: empty list
09:38:27 <jpcooper> that is the error, yes
09:38:33 <mmorrow> and have something like    data Step a = Done | Step a (IO (Step a))
09:38:43 <jpcooper> maybe it isn't coming from this though
09:38:48 <mmorrow> returned by a forkIO'd thread stepping alonf the Chan
09:38:48 <Saizan> jpcooper: but you said you're using foldM over it
09:38:54 <jpcooper> Saizan, I am
09:38:59 <Saizan> jpcooper: so it should come from somewhere else.
09:39:02 <jpcooper> okay then
09:39:15 <jpcooper> mmorrow, I may have a look at that
09:39:31 <jpcooper> I wish I could know where this error is coming from :)
09:39:39 <mmorrow> jpcooper: that `Step' type is super handy
09:39:49 <koeien> int80_h: i think you should consider all numbers   map f [1..10000] instead of all numbers of the particular form in [1..10000]
09:40:16 <Saizan> jpcooper: you can trick the profiler in giving you a sort of stack trace
09:40:25 <jpcooper> how?
09:40:54 <jpcooper> mmorrow, do you know where I can read more about this?
09:41:02 <int80_h> koeien: how will that help me find primes 2n^2-1
09:41:19 <Saizan> compiling with -prof -auto-all and running with +RTS -p -hc, iirc, but it's written in the profiling section of the ghc manual
09:41:22 <mmorrow> jpcooper: do you mean the "Steps" type?
09:41:28 <int80_h> the sieve code generates primes by considering all numbers, and I compare against that/
09:41:33 <jpcooper> mmorrow, yes
09:41:51 <mmorrow> jpcooper: i'll pasted some misc code i have using it
09:41:54 <mmorrow> *paste
09:41:58 <jpcooper> thanks
09:42:14 <koeien> int80_h: for example, yes. i think that the difference between 35 and 2202 is just because you misunderstood their wording
09:43:01 <koeien> int80_h: try length . specialSieve $ f 10000 where f n = 2*n^2 -1  for example
09:43:12 <koeien> that should give you 2202
09:44:00 <int80_h> koeien: that gives me a parse error :)
09:44:09 <int80_h> *Main> length . specialSieve $ f 10000 where f n = 2*n^2
09:44:10 <redditbot> Low-pain, high-gain multicore programming in Haskell: coordinating irregular symbolic computations on multicore architectures
09:44:10 <redditbot> Moggi, monads, category theory and Haskell
09:44:10 <int80_h> <interactive>:1:32: parse error on input `where'
09:44:22 <koeien> int80_h: yeah, where doesn't work interactively i think
09:45:05 <koeien> int80_h: so "let" or just manually fill in 10000
09:45:32 <jpcooper> thanks Saizan
09:46:25 <int80_h> koeien: I did this let x = length . specialSieve $ f 10000 where f n = 2*n^2-1
09:46:58 <int80_h> koeien: then I try to see what x binds to, and the interprer still hasn't given me a result, seconds later
09:47:08 <koeien> yes, of course :)
09:47:12 <koeien> this will take a while
09:47:23 <koeien> that it probably what makes the problem interesting :)
09:47:44 <koeien> the number is ~1e10
09:48:00 <int80_h> koeien: oh good I just wanted to make sure I didn't screw up. My first attempt at this code has a ridiculous infinite list and chewed up alot of CPU
09:48:30 <koeien> int80_h: well, if your code works for [1..10000] you can be reasonably sure (!) that it works for [1..1e10]
09:48:49 <koeien> int80_h: i didn't check the details though
09:48:50 <Zao> koeien: Unless you happen to run into Int vs. Integer
09:48:58 <koeien> Zao: he has Integer everywhere :)
09:49:31 <int80_h> wow, it's still checking
09:49:40 <int80_h> and this is just for 10000
09:49:55 <int80_h> The answer to the problem is for n=50000000
09:50:06 <koeien> int80_h: you have to think of something :)
09:50:44 <int80_h> koeien: what do you mean?
09:50:59 <koeien> int80_h: some interesting mathematical property
09:51:01 <koeien> i think
09:51:49 <int80_h> koeien: mathematical property of what? This seems to be a straightforward problem
09:52:03 <koeien> i don't know how fast a number sieve is
09:52:16 <int80_h> generate a list, filter out all non-primes. count the members of the list
09:53:30 <int80_h> koeien: I don't understand how your example code works with my specialSieve
09:53:46 <int80_h> not understanding it, I can't do an analysis
09:54:07 <koeien> example code? :)
09:54:22 <int80_h> sorry, your example
09:54:23 <dons> dcoutts: any ETA on http 4 support for cabal-install ?
09:54:27 <int80_h> let x = length . specialSieve $ f 10000 where f n = 2*n^2-1
09:54:44 <dcoutts> dons: done
09:54:57 <koeien> int80_h: yes, this was your code, except you counted them up to 10000 appearantly?
09:55:15 <int80_h> koeien:, not that wasn't my code.
09:55:21 <int80_h> I mean, no it wasn't
09:55:31 <int80_h> koeien: this is what I did
09:55:37 <dons> dcoutts: cabal-install released with this support?
09:55:48 <dons> i'd like to move Arch on to HTTP 4. lots of packages want it now.
09:55:54 <int80_h> length . specialSieve $ 10000
09:55:58 <dcoutts> dons: not yet, you're most welcome to test the dev version
09:56:02 <dons> ic.
09:56:20 <int80_h> and specialSieve then looks for the property I want (2*n^2-1)
09:56:27 <dcoutts> dons: I expect to do a release soon but it needs testing
09:56:42 <mmorrow> jpcooper: i can't find any Step+Chan code (i have some somewhere..), but here's some Step+Socket/Handle for http-related stuff  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1239#a1239
09:56:54 <int80_h> koeien: what is tripping me up is your where clause
09:56:56 <koeien> int80_h: yes i see that. however if you read the problem description carefully, this explains why your answer was way smaller than the answer in the problem, for n = 10000
09:56:59 <jpcooper> thanks mmorrow
09:57:08 <mmorrow> np :)
09:57:19 <koeien> int80_h: well, just do    length . specialSieve $ 2*10000^2 - 1  then
09:57:25 <dons> ok
09:59:20 <int80_h> koeien: is this the line ?
09:59:25 <int80_h> oops
09:59:35 <int80_h>  
09:59:42 <int80_h> hmm, can't paste
09:59:47 <int80_h> I'll just type it out
10:00:41 <int80_h> koeien: for n<= 10000 there are 2202 numbers t(n) that are prime
10:00:48 <koeien> yes
10:02:02 <int80_h> koeien: ah I think I see what you mean. :)
10:02:07 <koeien> so that is,   there should be 2202 numbers in  [1..(t n)]  that are prime
10:02:31 <int80_h> ah yes...I was testing [1..n] not the same thing
10:03:38 <mmorrow> jpcooper: found some code related to the "Chan a ==> Chan (Maybe a), Nothing --> \"EOF\"" thing http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=828
10:05:40 <mmorrow> and here's some code by Cale that defines a "nonblocking" getChanContents' by various means http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=110
10:06:46 <mmorrow> err, actually s/"nonblocking"/nonblocking/
10:08:02 <jpcooper> thanks mmorrow
10:10:47 <killerstorm> hi. i'm generating largish XML files with HaXml, and this takes lots of CPU time (no IO bound), is there a way to make it faster? i've tried profiling, but results were not informative
10:11:47 <killerstorm> e.g.:  CAF Main 306          22  99.6   99.9    99.6   99.9, that's what profiler says..
10:15:00 <ddvlad> hi, everyone, i have a problem with ghci: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1240
10:15:12 <ddvlad> i hope it's not offtopic here
10:17:37 <gwern> killerstorm: maybe adding -caf-all to the profiling options would help you more than -auto-all
10:19:33 <Saizan_> ddvlad: not offtopic
10:20:03 <maltem> ddvlad: strange. but is there a particular reason you're using an old dev version of ghc
10:20:07 <maltem> ...?
10:20:32 <yaru1022> hi, if I'd like to study category theory, what else do I need to study as prerequisites? Looks like there are many other things to know like Abstract Algebra, Set Theory, etc.  Can anyone recommend me some curriculum?
10:20:48 <ddvlad> maltem: umm... i just pulled the last one from the gnetoo portage overlay; it worked fine up till last night when i installed cabal-install and used it for lambdabot
10:21:28 <ddvlad> is it possible that something i installed via portage and something i installed via cabal don't mix well?
10:21:47 <maltem> ddvlad: did lambdabot install a new version of some of the packages listed by ghci?
10:21:53 <ddarius> yaru1022: Beyond a basic understanding of the notation of set theory, none of that stuff is necessary.  There are also category theory books geared at computer scientists.
10:21:56 <maltem> ddvlad: er, did cabal-install install ...
10:22:21 <ddvlad> maltem: hmm... i might have. i remember noticing a different version of something familiar, but did not pay attention
10:22:44 <ddvlad> i'll look in ~/.cabal and portage for any conflicts
10:23:13 <dcoutts> ddvlad: portage always installs globally ~/.cabal/ is where cabal installs user packages
10:23:20 <yaru1022> ddarius, and would I need to know something in order to understand Set Theory? Are highschool mathematics fine prerequisite?
10:23:40 <maltem> yaru1022: I think highschool mathematics are overkill for set theory
10:23:49 <ddarius> yaru1022: My impression is that many high schools teach some set theory.
10:23:50 <dcoutts> ddvlad: the only thing you might want to check for is in the output of ghc-pkg list. If the same version of a package is installed both global and user then that's bad.
10:24:05 <ddarius> yaru1022: Set theory does not require any prerequisites.
10:24:24 <ddarius> yaru1022: Basically, all you need to know from it is the notation and what it means.
10:24:44 <yaru1022> ddarius, i c...
10:24:48 <glguy> ddvlad, You'll want to update to the released version of 6.10
10:25:23 <pk_> category theory is all about abstraction right ? so maybe I'll be hard to learn if you doesn't know some examples of what it abstracts
10:26:03 <ddarius> pk_: Most texts will use examples from all over mathematics, just ignore the ones that are far outside your domain of knowledge.
10:26:07 <ddvlad> glguy: i'll start on that right after a sync, since ghc-pkg did not show anything obviously wrong
10:26:11 <killerstorm> gwern: it made more detailed profile data with -caf-all, but still majority of time is spent in main. i wonder, maybe i'm doing the way i'm doing output is wrong?
10:26:49 <killerstorm> program creates huge string from the xml tree, and then writes this huge string into a file.
10:27:21 <killerstorm> i guess it would be more efficient to write to file as it goes through xml tree, incrementally..
10:27:25 <ddarius> That said, it won't hurt you to look up things as you come across them.  Oftentimes the examples used are pretty basic.
10:27:51 <ddarius> E.g. monoids are an often used example and they are a very, very basic example of a structure from abstract algebra.
10:28:15 <ddarius> You certainly don't need a course in abstract algebra to understand monoids.
10:30:01 <ddarius> yaru1022: Also, though this usually goes along with set theory, you need to know the notation of logic.  E.g. that ∧ is conjunction (and), ∨ disjunction (or), etc.  If a different notation is used, it will usually be explained.
10:31:24 <FunctorSalad> killerstorm: did you also -caf-all the dependencies?
10:31:46 <FunctorSalad> or at least auto-all or so
10:33:08 <FunctorSalad> (cabal install --reinstall -p -ghc-option=-auto-all myDependency)
10:33:52 <dark_helmet> hi all
10:34:20 <dark_helmet> short q: has anyone had problems with cabal on Ubuntu intrepid?
10:34:26 <FunctorSalad> err, "--ghc-option=-auto-all"
10:34:45 <FunctorSalad> (two dashes)
10:35:35 <dons> good work, Lemmih http://archhaskell.wordpress.com/2009/02/07/sdl-bindings-for-haskell/
10:35:41 <dons> needs a better category tag and more docs :)
10:35:47 <mmorrow> jpcooper: (in case it's ambiguous which ByteString that is in the paste (i think it is), here's clarification http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1239#a1241)
10:36:27 <FunctorSalad> is there some place to put "stub" projects to put things that aren't quite ready for hackage?
10:37:08 <BONUS> FunctorSalad: github? bitbucket?
10:37:09 <dons> beelsebob: does the hscolour release on monday have your patches? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hscolour-1.12 ?
10:37:13 <FunctorSalad> (say I wrote an exporter for some format that I needed in my program, but it's incomplete)
10:37:42 <dark_helmet> ubuntu intrepid: ghc 6.10.1 installs fine and i can build Cabal, HTTP, zlib, cabal-install; but running cabal update produces cabal: user error (Codec.Compression.Zlib: incompatible version)
10:38:39 <FunctorSalad> BONUS: hmm doesn't hackage require darcs?
10:39:03 <Deewiant> FunctorSalad: hackage only takes tarballs created by 'cabal sdist'
10:40:15 <BONUS> hmm ah right
10:40:43 <BONUS> what about patch-tag.com then
10:41:16 <FunctorSalad> BONUS: ah cool :)
10:41:55 <michaelcdever> hey, if i forkIO with a method that returns a string... how do i collect the result of that method when it's finished?
10:42:16 <dons> put it in some shared memory
10:42:19 <dons> e.g. an MVar or Chan
10:42:26 <dons> you're programming with threads now! :)
10:42:35 <dons> x < -newMVar
10:42:41 <dons> forkIO $ ... .put result in x
10:42:45 <dons> main thread takeMVar on x
10:43:50 <michaelcdever> right :D figured it was something like that :D, dya know if theres a limit to the amount of threads you can have running?
10:44:12 <ddarius> How much memory you have.
10:44:15 <BONUS> and a cool bonus is you can't take something out of an empty MVar, so the main thread waits for the forked thread to put something in it (i.e. to finish)
10:44:37 <mjb_> Do MVars have something like a Peek operation?
10:44:39 <michaelcdever> good stuff, and in my forked threads, i can fork again yes?
10:44:44 <ddarius> mjb_: Yes.
10:44:50 <ddarius> michaelcdever: Of course.
10:45:06 <dons> michaelcdever: it's around 10M or so
10:45:09 <dons> there's no hard limit
10:45:23 <dons> if you can find an upper limit on the number of threads, we'd love to know :)
10:45:34 * ddarius is sure he can't spawn 10,000,000 threads.
10:45:39 <michaelcdever> i just tried indexing all the folders from "/" recursively, 20 mins later its still running
10:45:39 <FunctorSalad> no one will ever need more than 2^16-1 threads ;)
10:45:46 <glguy> some of the "peek" like operations are potentially blocking, howver
10:45:49 <glguy> be careful :)
10:45:50 <michaelcdever> i will be sure to let you know if i break it :D
10:46:14 <mreha> where can i paste my haskell code guys?
10:46:16 <p_l> FunctorSalad: Current limit on many systems is 2^15-1 ;)
10:46:24 <BONUS> @where hpaste2
10:46:25 <lambdabot> http://hpaste.org/
10:46:26 <michaelcdever> hpaste or pastebin mreha
10:46:47 <Olathe> Does anyone know if there are any pure-Haskell zlib libraries ?
10:47:00 <FunctorSalad> p_l: negative threads? ^^
10:47:13 <dons> Olathe: look on hackage.
10:47:21 <Olathe> I have :)
10:47:30 <Olathe> There's a C-based one.
10:47:45 <dons> interesting. haskell-llvm depends on haskell-type-level now
10:47:52 <glguy> @tell mmorrow the repository address for hpaste.git is wrong. I've moved over to github.com/glguy/hpaste
10:47:52 <lambdabot> Consider it noted.
10:48:07 <ddarius> @users
10:48:08 <lambdabot> Maximum users seen in #haskell: 699, currently: 679 (97.1%), active: 27 (4.0%)
10:48:09 <p_l> FunctorSalad: No, but for some reason the limit on linux 2.6 seems to be slightly lower than 2^15
10:48:15 <p_l> (on x86-64)
10:48:27 <mreha> Have a look at this: http://pastebin.com/d25da8ce6
10:48:54 <olsner_> p_l: so, +RTS -N32768 will fail on linux 2.6 if you spawn enough haskell threads?
10:48:55 <dark_helmet1> noone else had problems with zlib in cabal? 0.4 and 0.5 both produce "cabal: user error (Codec.Compression.Zlib: incompatible version)"
10:48:56 <mreha> GHCI tells me that the 'alpha' in the function regular polygon is of type INT?!
10:49:29 <p_l> olsner_: It will fail unless you raise the default thread-max. on my system it's 32621
10:50:13 <mauke> mreha: well, it is
10:50:26 <dons> Olathe: is that the upper limit on linux processes?
10:50:30 <mreha> whyyyyyy?
10:50:36 <mauke> mreha: because n is
10:50:44 <dons> it'll allocate N OS threads, then try to map your M haskell threads onto 32768
10:50:47 <dons> probably you want more cores
10:51:03 <mreha> so int + float = int?
10:51:05 <dons> dcoutts: dark_helmet1 has a question
10:51:10 <mreha> you loose accuracy?
10:51:11 <mauke> mreha: no, int + float = type error
10:51:21 <dons> > (1 :: Int) + (2 :: Float)
10:51:22 <lambdabot>   Couldn't match expected type `Int' against inferred type `Float'
10:51:36 <mreha> pi / n
10:51:40 <mreha> that causes no type error
10:51:47 <p_l> dons: Appears that pid_max by default is ca. 2^15 and thread_max is slightly lower :)
10:51:47 <mauke> mreha: it does, actually
10:51:49 <dark_helmet1> dons: thanks, some recognition at last ;-)
10:52:00 <mauke> mreha: but you never see it because the other error hits first
10:52:01 <mreha> @type 2 * pi / n
10:52:02 <lambdabot> Expr
10:52:22 <FunctorSalad> mreha: there's no implicit conversion, use (fromInteger n)
10:52:36 <mauke> mreha: given than n :: Int, ghc deduces that pi :: Int and pi / n :: Int
10:52:37 <ddarius> Use fromIntegral, not fromInteger.
10:52:38 <dsrogers> @hpaste2
10:52:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:52:40 <mauke> er, that
10:52:46 <dsrogers> it lies
10:52:50 <dsrogers> where is hpaste2?
10:52:57 <mreha> hpaste is broked
10:53:00 <FunctorSalad> ddarius: ?
10:53:00 <Deewiant> @where hpaste2
10:53:01 <lambdabot> http://hpaste.org/
10:53:02 <mreha> cant post
10:53:03 <Deewiant> @where hpastetwo
10:53:04 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
10:53:22 <mauke> hpaste.org works for me
10:53:23 <FunctorSalad> oh right, Int not Integer
10:53:39 <mreha> so GHCI infers the type of an expression that it can't compile?
10:53:52 <mreha> oh i see,
10:53:56 <ddarius> FunctorSalad: There's almost no reason to ever use fromInteger.
10:55:17 <FunctorSalad> is fromIntegral just more convenient or something else?
10:55:38 <FunctorSalad> compared to fromInteger . toInteger
10:55:39 <doserj> @type fromIntegral
10:55:40 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:55:53 <ddarius> fromIntegral is one thing to remember, fromIntegral/fromInteger is two.
10:56:05 <doserj> @src fromIntegral
10:56:05 <lambdabot> fromIntegral = fromInteger . toInteger
10:56:59 <FunctorSalad> @type unsafeCoerce
10:57:01 <lambdabot> Not in scope: `unsafeCoerce'
10:57:26 <FunctorSalad> ;)
10:57:27 <beelsebob> dons: sorry, no I need to tidy them up – I did a hack to make it work with wordpress, but I want to generalise it to just inline-css
10:57:52 <FunctorSalad> (I know, you'd need to shift and add an appropriate exponent)
10:58:05 <dons> beelsebob: ok. well, i need  something :)
10:58:21 <dons> bos, augustss what are you using type-level for? http://archhaskell.wordpress.com/2009/02/07/llvm-bindings-for-haskell/
10:59:12 <beelsebob> dons: give me a couple of hours, and I'll have something in a reasonably sensible state
10:59:30 <dons> yay!
10:59:52 <augustss> dons: to keep track statically of vector lengths
11:00:15 <augustss> dons: and make sure that they are a power of 2
11:00:53 <augustss> dons making sure that zero and sign extension between integer types go from a smaller to a bigger type
11:01:14 <augustss> dons: making sure that bitcast is done between types of the same number of bits
11:02:40 <jpcooper> mmorrow, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1244#a1244 <-- getCommLine is running with a forkIO. The problem is that it doesn't print the "> " until I input something. Is there any way to force it to print before I enter something?
11:03:07 <dons> augustss: very cool.
11:04:44 <jpcooper> or could anyone else advise?
11:05:27 <mauke> putStr "> " >> hFlush stdout
11:05:33 <drhodes> (Maybe Int) is valid return type, but [Maybe String] is not?
11:06:21 <jpcooper> thank you mauke
11:06:55 <jpcooper> excellent, it works
11:07:32 <mauke> handleOutput = print
11:08:01 <FunctorSalad> I wonder how that works... is the IO action in main evaluated "eagerly" on some level?
11:08:04 <michaelcdever> would someone be able to give me a pointer as to where I'm going wrong with this forkIO business?
11:08:05 <bartek-> Hi there, I'm reading through RWH and I had to take 2 weeks off from it, now coming back I see the syntax: foo (a, x:xs) = xs .. this I understand for the most part, but passing in a list [1,2,3] for xs results in [2,3] .. I remember the book touched on this but I cant find the reference anymore. Can anyone remind me what it is doing?
11:08:08 <michaelcdever> http://pastebin.com/d7a520c63
11:08:40 <FunctorSalad> (the final RealWorld state is forced?)
11:09:19 <Raevel> bartek- x:xs will bind the first element of the list to x and the rest to xs
11:09:28 <Cheshire> > (4, 'e':"eees")
11:09:30 <lambdabot>   (4,"eeees")
11:09:37 <bartek-> Raevel: ah perfect, thank you
11:10:12 <bartek-> this is a very interesting language by the way :-)
11:11:35 <Cheshire> How do you do error messages with ReadP?
11:11:44 <mreha> http://pastebin.com/m365e504 any thoughts on my polygon drawing?
11:11:46 <mauke> Cheshire: I think the answer is "no"
11:13:03 <Cheshire> mreha, I am not totally keen on it
11:13:45 <Cheshire> mreha, the accumulating parameter is a bit strange
11:17:09 <Cheshire> > let cis theta = (cos theta , sin theta) in map (cis . (* (2 * pi)) . (/ 5)) [0..4]
11:17:10 <lambdabot>   [(1.0,0.0),(0.30901699437494745,0.9510565162951535),(-0.8090169943749473,0....
11:17:25 <Cheshire> mreha, I think you can get the same sort of thing like that
11:17:44 <Cheshire> (cis is short for cos + i * sin)
11:18:39 <BMeph> @hoogle cis
11:18:39 <lambdabot> Data.Complex cis :: RealFloat a => a -> Complex a
11:18:40 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
11:18:40 <lambdabot> Control.Exception LossOfPrecision :: ArithException
11:18:51 <Cheshire> oh I didn't expect haskell to have it
11:19:13 <michaelcdever> ???
11:19:13 <xenoblitz> Hi people... does anyone have any idea of any papers which talk about interpretting DSELs in Haskell?
11:19:16 <BMeph> Cheshire: I've noticed that if it's math-related, expect it from Haskell. ;)
11:19:40 * SamB wants to read a paper on BASIC in Haskell
11:20:17 <BMeph> xenoblitz: You'll have to be more specific than that, there's a LOT of stuff on that topic. :)
11:20:33 * BMeph wants augustss to write it. ;)
11:20:38 <wli> Cheshire: Wierd, I wonder why they don't just do \x -> exp (0 :+ x)
11:20:56 <Cheshire> @src cis
11:20:57 <lambdabot> cis theta    =  cos theta :+ sin theta
11:21:05 <jpcooper> is there a function that takes a value and a string, checks for a condition and if the condition holds, fails with the string, otherwise returns the value?
11:21:09 <jpcooper> I'm guessing it's an either thing
11:21:13 <Cheshire> oh wli, I think exp has to restrictive a type
11:21:14 <xenoblitz> BMeph: I'm having trouble interpretting a datastructure ... I wanna know if the issues I'm meeting are normal or if someone has been through it... etc etc... anything really to start me off
11:21:20 <Gracenotes> @index cis
11:21:20 <lambdabot> Data.Complex
11:21:38 <wli> @type \x -> exp (0 :+ x)
11:21:40 <lambdabot> forall t. (RealFloat t) => t -> Complex t
11:21:45 <wli> @type cis
11:21:46 <Cheshire> oh cool
11:21:47 <lambdabot> forall a. (RealFloat a) => a -> Complex a
11:22:16 <BONUS> @hoogle a -> (a -> Bool) -> String -> Either a String
11:22:17 <lambdabot> No results found
11:22:19 <Gracenotes> hm. Why RealFloat, not just Floating.. :\
11:22:22 <wli> It may be that there are better computational methods used in the hand-rolled cis.
11:22:24 <mmorrow> Cheshire: for ReadP error msgs, i think you'll have to modify the `P' type so .. | Fail [ErrorMsg] | ... (and whatever other edits that'll necessitate) (this is how Parsek originally did it, for some reason ReadP just discards this)
11:22:25 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
11:22:33 <BONUS> @hoogle a -> String -> (a -> Bool) -> Either a String
11:22:35 <lambdabot> No results found
11:22:36 <Gracenotes> BONUS: there's either
11:22:38 <Gracenotes> :t either
11:22:40 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:22:43 <BMeph> wli: Also, because the definition runs the other way: " exp (x:+y) =  expx * cos y :+ expx * sin y  where expx = exp x"
11:22:49 <Gracenotes> er. no... not what you're thinking of.
11:22:52 <Gracenotes> :/
11:23:01 <BONUS> well there's that, but it looks like he's looking for a function that takes a string, an element and a predicate
11:23:07 <BONUS> and returns an Either
11:23:26 <Gracenotes> @hoogle -> Bool -> a -> b -> Either a b
11:23:27 <lambdabot> Parse error:
11:23:27 <lambdabot>   --count=20 "-> Bool -> a -> b -> Either a b"
11:23:27 <lambdabot>              ^
11:23:28 <Gracenotes> eek
11:23:33 <Gracenotes> @hoogle Bool -> a -> b -> Either a b
11:23:34 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
11:23:34 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
11:23:34 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
11:23:46 <mmorrow> Cheshire: the only thing is though, they won't work like parsec, as in every time you do "choice" and one pfails (w/ a non-[] errormsg), it'd be added to the error/warning pool. so you'd have to deal with that somehow
11:23:55 <xenoblitz> no eh....?
11:24:08 <xenoblitz> thanks all, all the same :)
11:24:18 <matthew-_> grr, you still can't use records with GADTs can you?
11:24:19 <lambdabot> matthew-_: You have 1 new message. '/msg lambdabot @messages' to read it.
11:24:27 <BMeph> @djinn a -> String -> (a -> Bool) -> Either a String
11:24:28 <lambdabot> Error: Undefined type String
11:24:31 <Gracenotes> jpcooper: although, func b x y = if b then Left x else Right y
11:24:40 <mmorrow> (maybe P = ... | Fail [Error] [Warning] | .... , then only show one/more errors if the entire parse fails, and optionally always show warnings)
11:24:43 <mmorrow> (or something)
11:24:47 <jpcooper> alright
11:25:01 <Gracenotes> you can add it (with a useful name) as a utility function and just not export it from the module. There *might* be something, but I'm not sure where.
11:25:06 <Toxaris> @djinn a -> b -> (a -> Bool) -> Either a b
11:25:07 <lambdabot> f a b c =
11:25:07 <lambdabot>     case c a of
11:25:07 <lambdabot>     False -> Left a
11:25:07 <lambdabot>     True -> Right b
11:25:20 <michaelcdever> god this forkIO is annoyng
11:25:23 <Gracenotes> or if (c a) ..
11:25:48 <mmorrow> @djinn (Either a (Either b (Either a))) -> (Either b (Either a (Either b)))
11:25:49 <lambdabot> Error: kind error: (KVar 4,KStar)
11:25:59 <mmorrow> @djinn (Either a (Either b (Either a b))) -> (Either b (Either a (Either b a)))
11:26:00 <lambdabot> f a =
11:26:00 <lambdabot>     case a of
11:26:00 <lambdabot>     Left b -> Right (Left b)
11:26:00 <lambdabot>     Right c -> case c of
11:26:00 <lambdabot>                Left d -> Left d
11:26:02 <lambdabot>                Right e -> case e of
11:26:08 <lambdabot>                           Left f -> Right (Left f)
11:26:09 <Gracenotes> of
11:26:12 <lambdabot>                           Right g -> Left g
11:26:28 <wli> BMeph: It's superfluous compared to e.g. some notion of absolute value / magnitude that allows sharing code between real and complex code.
11:26:45 <ehird> @djinn (a,(a,())) -> [a]
11:26:45 <lambdabot> Error: Undefined type []
11:26:51 <ehird> @djinn (a,(a,())) -> List a
11:26:51 <lambdabot> Error: Undefined type List
11:27:48 <Gracenotes> if you had lists you could probably implement a type-based regular expression..
11:29:44 <BMeph> wli: ?
11:30:07 <Gracenotes> @djinn (a,(b,c)) -> (a,(Either a b,c))
11:30:08 <lambdabot> f (a, (b, c)) = (a, (Right b, c))
11:31:12 <Gracenotes> and indeed abc matches a[ab]c. Except, if commas are used for concatenation, only a substring can match, and two parts of the input can be used more than once in the result :/
11:31:52 <wli> exp is in the Floating typeclass, so \x -> exp (0 :+ x) renders cis superfluous. OTOH people have to roll their own typeclass for an abs/magnitude/etc. function that allows polymorphism across real and complex.
11:33:04 <BMeph> wli: But, cis is just exp inlined. :)
11:33:37 <BMeph> wli: I'm missing an argument, somewhere... :)
11:33:39 <vsthesquares> is there a way to define tuples of a length only known at runtime?
11:33:55 <mauke> vsthesquares: no
11:34:00 <chessguy_> vsthesquares:  not without significant type hackery
11:34:20 <wli> e.g. convergence criteria for Newton's method. |x - x'| < delta, |f x| `max` |f x'| < epsilon ... except you have to write your own | | operator every time.
11:34:23 <BMeph> > abs (3 :+ 4)
11:34:25 <lambdabot>   5.0 :+ 0.0
11:34:38 <chessguy_> @type (:+)
11:34:40 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
11:34:54 <wli> BMeph: Useless for sharing code between real and complex cases.
11:34:58 <vsthesquares> hm, lisp has this great partition function that takes an int n and a list and partitions the list in chunks of length n
11:35:11 <drhodes> I'm porting all of python's str.methods, and have got a question regarding a return type for the partition function, line 128.  http://pastebin.com/m15f533a1  what should the return type be for that? ("", String, "") or (Maybe String, String, Maybe String), somethinge else?
11:35:23 <vsthesquares> I'm not really familiar with the haskell libs, so maybe I'm not looking at the right functions
11:35:31 <chessguy_> @hoogle Int -> [a] -> [[a]]
11:35:32 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
11:35:32 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:35:32 <lambdabot> Prelude take :: Int -> [a] -> [a]
11:35:40 <chessguy_> @hoogle+
11:35:41 <lambdabot> Data.List drop :: Int -> [a] -> [a]
11:35:41 <lambdabot> Data.List take :: Int -> [a] -> [a]
11:35:41 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
11:35:47 <Toxaris> BONUS, Gracenotes: maybe we should have type Bool = Either () (), then one could do    either id (const b) (f a)   :)
11:35:48 <Gracenotes> @hoogle chunk
11:35:49 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
11:35:49 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
11:35:49 <lambdabot> Data.ByteString.Lazy.Internal chunkOverhead :: Int
11:35:57 <paper_cc> > iterate (take 5) [1..20]
11:35:59 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[1,2,3,4,5],[1,2,3,4,...
11:36:20 <Toxaris> BONUS, Gracenotes: oh no,   either (const a) (const b) (f a)   of course
11:36:30 <wli> BMeph: The result type of abs would have to be an instance of Ord i.e. not Complex t in order to be useful.
11:36:40 <Gracenotes> > iterate (take 5 . drop 5) [1..20]
11:36:42 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[6,7,8,9,10],[],[],[]...
11:36:43 <McManiaC> did i get that right? you need do whenever u want to use IOs and open a new layout-block?
11:36:49 <paper_cc> > map fst $ iterate (splitAt 5 . snd) [1..20]
11:36:50 <lambdabot>   Couldn't match expected type `([a], [a])'
11:37:02 <Gracenotes> unzip
11:37:15 <Gracenotes> still.. hm :\
11:37:37 <Toxaris> McManiaC: yes. do is the only layout-block-opening keyword which returns something of type IO whatever
11:37:39 <chessguy_> @type unzip
11:37:43 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
11:37:47 <beelsebob> dons: http://www.cs.kent.ac.uk/people/rpg/tatd2/inlinecss.patch
11:38:14 <dons> woo
11:38:28 <McManiaC> Toxaris: okay thx, i still have to get used to that layout thing
11:38:28 <McManiaC> :D
11:39:08 <maltem> > (map take 3 . iterate (drop 3)) [1..20]
11:39:09 <lambdabot>   Couldn't match expected type `b -> c'
11:39:21 <maltem> > (map (take 3) . iterate (drop 3)) [1..20]
11:39:23 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20],[],[],[],...
11:39:38 <wli> I think it might have to be class Magnitude m t | t -> m where magnitude :: m -> t
11:39:51 <maltem> > (takeWhile (not.null) . map (take 3) . iterate (drop 3)) [1..20]
11:39:53 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
11:40:03 <beelsebob> dons: oh, lame
11:40:06 <chessguy> @pl \n xs -> (m (t n) . i (d n)) xs
11:40:06 <lambdabot> ap ((.) . m . t) (i . d)
11:40:08 <beelsebob> there's a darcs add missing there >.<
11:40:15 <maltem> vsthesquares: see above
11:41:06 <wli> It's not very well expressed by easy type system methods.
11:41:12 <beelsebob> dons: reload and you'll get a sensible patch
11:42:05 <BMeph> drhodes: Either of the three options you 've written would work. Except, for your paste, you'd need to make the sep 'Just sep'. :)
11:42:52 <wli> It may need a few more Olegs than I've got to deal with it.
11:43:02 <drhodes> BMeph: I'm after the most convention compliant way
11:43:32 <drhodes> thanks for taking the time btw.
11:43:47 <paper_cc> @hoogle a -> Bool -> Maybe a
11:43:48 <lambdabot> Control.Exception assert :: Bool -> a -> a
11:43:48 <lambdabot> Prelude const :: a -> b -> a
11:43:48 <lambdabot> Data.Function const :: a -> b -> a
11:44:04 <BMeph> wli: Well, it would need a re-definition of Num, which surprises no one. ;)
11:44:11 <redditbot> First class labels for records, with combinators, allowing selection, modification and update
11:44:11 <redditbot> happstack: a refreshingly innovative web application server | Arch Linux and Haskell
11:44:11 <redditbot> Haskell Weekly News: February 7, 2009 | The Haskell Sequence
11:45:03 <BMeph> drhodes: No problem. I'd suggest taking a spin through the Data.List module - much of what you're doing just needs alpha-conversion. ;)
11:45:07 <wli> It should be doable atop the existing junk, just with dumb names to avoid nameclashes.
11:45:27 <JKL_> is this correct answer: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1247#a1247 ?
11:45:41 <roconnor> what's the diff between fclabels and data-accessor?
11:46:10 <mauke> JKL_: the type looks ok, but where are the functions?
11:46:35 <Ringo48> is there an easy way to use escaped characters when using parsec?
11:46:37 <JKL_> :) ql (Quadruple _ _ _ d) = d
11:46:40 <BMeph> wli: It can't be doable atop the existing junk - like you observed, abs should return a Real, not a Num. :)
11:46:50 <JKL_> and similar
11:46:52 <Gracenotes> @hoogle SOCKS
11:46:53 <lambdabot> No results found
11:46:57 <Gracenotes> @hoogle proxy
11:46:58 <lambdabot> No results found
11:47:01 <Gracenotes> :/
11:48:04 <JKL_> mauke: I just wonder why :t Quadruple is a -> a -> b -> b -> Quadruple a b and not a -> a -> b -> b -> Quadruple a a b b
11:48:17 <mauke> JKL_: because Quadruple a a b b is not a valid type
11:48:49 <mauke> according to your definition, Quadruple takes only two arguments, a and b
11:48:50 <Ringo48> for example, right now I have a regular expression parser, and it handles "(a|b)*abb" as expected, but I want to be able to do "\(a\|\b\)\*abb" to get the "special" characters
11:49:11 <mreha> Cheshire, that solution you provided just draws points on the radius of a circle around the origin
11:49:14 <JKL_> I thought it have only 2 type parameters
11:49:35 <JKL_> Maybe someday I get it :)
11:49:37 <mreha> transforming a list is something i like better
11:49:40 <mreha> thanks
11:49:45 <idnar> JKL_: right; but Quadruple a a b b tries to pass it 4 type parameters
11:49:49 <Gracenotes> Ringo48: you mean -- "\\(a\\|b\\)\\*abb"?
11:50:03 <idnar> which won't work :P
11:50:33 <Cale> JKL_: It helps to name the data constructor and the type constructor differently in order to see why.
11:50:45 <Cale> JKL_: data Quadruple a b = Quad a a b b
11:51:00 <Ringo48> simpler example: "a*" is a 0 or more times, I want "a\*" to be a followed by asterisk
11:51:06 <Cale> JKL_: Quad, the data constructor, takes 4 parameters, two values of type a, and two values of type b
11:51:28 <Cale> JKL_: Quadruple, the type constructor, takes 2 type parameters, the type 'a', and the type 'b'
11:51:35 <Cale> Does that help?
11:51:37 <skorpan> Ringo48: try a\\*
11:51:40 <JKL_> But Im little confused where does those a and b stored ...
11:51:45 <Ringo48> actually, looking at the rules, I think that was a silly question
11:51:46 <Ringo48> k
11:51:53 <Cale> So, for instance, we have  Quad "hello" "world" 3 4 :: Quadruple String Integer
11:52:03 <ozy`> http://www.subtextual.org/subtext2.html <- the very first thing I thought of when watching this was using a textual query language to manipulate the diagrams...
11:52:08 <JKL_> yeh
11:52:08 <BMeph> drhodes: Hmm, after poking around, maybe Data.Map would give more inspiration. Either way, a triple works fine, for what yu've defined.:)
11:52:12 <idnar> ozy`: hahaha
11:52:17 <Gracenotes> really, though, do any GHC libraries support SOCKS localhost proxies?
11:53:00 <JKL_> Cale: I think Im not understand the system behind that constructor
11:53:30 <JKL_> I can see that it works fine, but I cannot directly see why
11:53:57 <JKL_> But maybe it comes clear sooner or later
11:54:07 <Cale> JKL_: Quadruple is something that lives in the world of types. You can think of it as a function which takes two types (Like String and Integer) and forms a new type from them.
11:54:07 <bartek-> One more question (I'm reading through RWH so forgive me for ignorance) .. if I am creating a record: customer1 = Customer ( customerAddress :: Address } deriving (Show) ... How can I define Address as a [String] type for use within that record?
11:54:21 <Cale> JKL_: Quad on the other hand, lives in the world of values
11:54:25 <Ringo48> no, that's not working
11:54:34 <Cale> JKL_: It takes 4 values and produces another.
11:54:40 <mauke> bartek-: type Address = [String]
11:55:07 <bartek-> Ah, thanks
11:55:36 <JKL_> So Quadruple is class and Quad instance of it?
11:56:10 <Cale> JKL_: Quadruple is a type constructor, Quad is a function which builds values of types constructed by it
11:56:11 <Ringo48> right now the rule is using (noneOf "[]|*+()") to get everything except those 7 characters
11:56:22 <Cale> Quad :: a -> a -> b -> b -> Quadruple a b
11:56:32 <BMeph> Cale: A "value constructor"? ;)
11:56:39 <Cale> JKL_: In Haskell, classes are something else.
11:56:43 <Gracenotes> Ringo48: you might have to make a special rule whenever an \ is encountered
11:56:46 <Cale> (and instances)
11:56:57 <Ringo48> yeah, that's what I'm thinking
11:57:06 <Gracenotes> which has the highest precedence. I'm not quite familiar with Parsec, but I think that might work
11:57:19 <JKL_> I thinked c++ or java style... can I have Quad a a b b and Quad2 a a b b a
11:57:19 <Ringo48> thought I'd ask, in case there was a parsec character class similar to noneOf that will return anything but those seven OR one of those seven if it's preceded by '\'
11:57:28 <Ringo48> thank you
11:57:29 <michaelcdever> no wonder its taking forever, its following links like theyre proper directories
11:57:32 <killerstorm> i think i need to write a function (and class) like show/Show, which instead of accumulating everything into a string will write contents to the file instead immidiately. is there any example of such thing?
11:58:06 <paper_cc> > (unfoldr $ \xs -> let (a, b) = splitAt 5 xs in guard (not $ null a) >> return (a, b)) [1..20]
11:58:08 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
11:58:22 <mauke> JKL_: class Quadruple<A, B> { A m1, m2; B m3, m4; Quadruple(A p1, A p2, B p3, B p4) {
11:59:17 <JKL_> so only 1 constructor?
11:59:23 <JN_> newbie here.. could somebody tell me why the following def fails to parse? 2 lines follow
11:59:24 <JN_> sumcount (sum,count) x:xs = (sum + x, count + 1) + sumcount xs
11:59:24 <JN_> sumcount (sum,count) [] = (sum, count)
11:59:32 <mauke> JKL_: yes
11:59:37 <mauke> JKL_: wait, what?
11:59:44 <maltem> JN_: you're missing parentheses around (x:xs)
11:59:52 <JN_> ohhh... d'oh.. thanks :)
11:59:57 <BMeph> JN_: Put parens around 'x:xs'. :)
12:00:09 <SamB> can someone with 6.10 try this for me?
12:00:11 <SamB> Prelude Language.Haskell.TH> $(sigE [|1|] (appT (tupleT 1) [t|Int|]))
12:00:18 <maltem> (peoples' names are to similar here)
12:00:19 <JKL_> mauke: can there be more than 1 constructor per data
12:00:24 <maltem> *too
12:00:26 <ehird> yes
12:00:40 <mauke> JKL_: yes
12:01:03 <JKL_> mauke: who decides how many objects are in data?
12:01:08 <mauke> JKL_: for example data Color = Red | Green | Blue  -- has three constructors
12:01:12 <mauke> JKL_: huh?
12:01:27 <erikc> SamB: 1:: Int
12:01:43 <JKL_> mauke: who says that Quadruple have to has 4 "data" in it
12:01:45 <SamB> erikc: it works ?
12:01:46 <BMeph> SamB: I get a parse error. Maybe there're some more bars you need to throw in? ;)
12:01:57 <ehird> JKL_: the person who types the data does...
12:01:57 <SamB> oh, I forgot to mention :set -fth
12:01:58 <mauke> JKL_: you did?
12:02:03 <erikc> yup, worked
12:02:25 <mauke> SamB: 1
12:02:32 <JKL_> so I can have Quadruples in same program with different amount of "data" in it?
12:02:34 <SamB> nice
12:02:41 <mauke> JKL_: yes
12:02:44 <SamB> I was afraid it would complain about TupleT 1
12:02:59 <ehird> mauke: umm, no?
12:03:01 <JKL_> is there is only 1 made with constructor, are others null then?
12:03:08 <mauke> JKL_: the standard example is data Maybe a = Nothing | Just a
12:03:10 <ehird> JKL_: there can only be one Quadruple type
12:03:16 <maltem> JKL_: "data Quadruple a b = Quad a a b b" means that the constructor Quad always takes four arguments
12:03:17 <ehird> I think you're coming at this from the wrong angle...
12:03:27 <mauke> JKL_: no, they just don't exist in this value
12:03:35 <BMeph> SamB: Why? :)
12:03:41 <mauke> ehird: NO U
12:03:52 <BMeph> SamB: Why were you afraid it would complain, I mean. :)
12:04:06 <SamB> well, I get this:
12:04:14 <dolio> , tupleT 1
12:04:16 <lunabot>  TupleT 1
12:04:16 <SamB> <interactive>:1:2:
12:04:16 <SamB>     No instance for (Num (Int))
12:04:16 <SamB>       arising from the literal `1' at <interactive>:1:2-38
12:04:16 <SamB>     Possible fix: add an instance declaration for (Num (Int))
12:04:25 <mauke> haha
12:04:35 <JKL_> data Quadruple a b = Quad a a b b; let lastQ (Quadruple _ _ _ _ a) = a
12:04:37 <ehird> No instance for (Num (Int))
12:04:39 <SamB> and I read in http://hackage.haskell.org/trac/ghc/ticket/2358 that it was fixed
12:04:39 <ehird> vat
12:04:42 <SamB> but they didn't say how
12:04:51 <mauke> ehird: it's a 1-tuple
12:05:07 <SamB> they aren't supposed to exist, but ...
12:05:08 <ehird> mauke: ... is that even possible?
12:05:15 <SamB> ehird: it was in 6.8 with TH!
12:05:19 <mauke> JKL_: not in scope: data constructor 'Quadruple'
12:05:19 <SamB> is, even
12:05:20 <ehird> haha
12:05:26 <SamB> it's not DESIRABLE
12:05:33 <ehird> oh it totally is. that's awesome
12:06:00 <BMeph> Unboxed 1-tuples exist, so "I shrug in your general direction." ;)
12:06:13 <ehird> do they?
12:06:14 <dolio> Do they?
12:06:14 <ehird> :o
12:06:15 <JKL_> mauke: jeh, and if no typo (should be Quad (still wrong becouse capital q)) id doesnt compile
12:06:16 <BMeph> SamB: ^^
12:06:20 <dolio> Jinx.
12:06:34 <JKL_> so first constructor decides how many "data" it holds?
12:06:39 <mauke> JKL_: no
12:06:55 <mauke> JKL_: there is no fixed number of elements in a type
12:06:56 <gwern> (yay, filestore passes all tests again)
12:06:58 <ehird> I think JKL_ is thinking data = like struct in C
12:06:59 <dolio> Unboxed singles would be odd to have in GHC, at least.
12:07:02 <dolio> Given what they're for.
12:07:25 <BMeph> dolio: Which is? :)
12:07:29 <ehird> SamB:
12:07:30 <ehird> > :t $(sigE [|1|] (tupleT 1 `appT` conT ''Int))
12:07:31 <ehird> $(sigE [|1|] (tupleT 1 `appT` conT ''Int)) :: Int
12:07:31 <lambdabot>   <no location info>: parse error on input `:'
12:07:32 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
12:07:33 <shapr> What's the best way to grab a lib from hackage in order to peruse the source?
12:07:37 <dolio> Returning multiple results from a function in registers.
12:08:03 <dmwit> shapr: I would say cabal install.
12:08:05 <JKL_> how do i write 2 constructors to 1 data?
12:08:09 <dolio> Instead of returning a single value (tuple) with pointers to the things you're returning.
12:08:16 <mauke> JKL_: with a | in between
12:08:17 <JKL_> I think i got this now :) lets see
12:08:24 <maltem> shapr: Not sure about the best way, but what about cabal fetch?
12:08:24 <BMeph> shapr: I would say the web page. :)
12:08:33 <ehird> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Tuple.html
12:08:47 <shapr> maltem: Ah, good point
12:08:53 <maltem> shapr: Even though I do prefer the web page, usually
12:09:11 <shapr> I wish cabal supported sucking down the source and producing TAGS files.
12:09:12 <gwern> silly byorgey!
12:09:20 <shapr> Of course, if I really wished for that, I would fix it :-)
12:09:51 <gwern> @tell byorgey did you repeat last week's HWN quotes?
12:09:52 <lambdabot> Consider it noted.
12:09:55 <dolio> So an unboxed single would be the same as just the value.
12:09:57 <maltem> ehird: woot, that's the *real* GHC implementation?
12:10:07 <shapr> Is there a deb for ghc6.10?
12:10:15 <gwern> shapr: seereason has one iirc
12:10:18 <ehird> maltem: Well, I added some more commas to the last and it still worked... So I dunno!
12:10:24 <dcoutts> shag: patches accepted! :-)
12:10:29 <Gracenotes> @type (,,,,,,,,,,,,,,,,,,,,,,)
12:10:31 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (a, b, c, d, e, f, g, h, i, j,
12:10:31 <lambdabot>  k, l, m, n, o, p, q, r, s, t, u, v, w)
12:10:40 <shapr> gwern: Where at?
12:10:42 <BMeph> dcoutts: "shag"? ;)
12:10:53 <Gracenotes> apparently we have 36-tuples
12:10:55 <gwern> shapr: somewhere in the seereason deb repo presumably
12:11:00 * shapr suspects google knows the answer
12:11:05 <shapr> gwern: good point!
12:11:09 * BMeph thinks it would be fun seeing 'shag boings furiously'... ;)
12:11:16 <Gracenotes> oh wait, no.. 62 tuples
12:11:20 <roconnor> > 3455/2
12:11:22 <lambdabot>   1727.5
12:11:24 <dcoutts> BMeph: oops! :-)
12:11:30 <dcoutts> shapr: sorry :-)
12:11:36 <JKL_> what i think now is: for data i can have different amount of constructors. and constructor names that data at the end. or something like that. data A a = Ca a | Cab a a. After that I have 2 "structs" Ca and Cab
12:11:47 <dolio> Gracenotes: Theoretically GHC supports arbitrarily large tuples. But it starts crashing after a certian point.
12:11:47 <shapr> BMeph: What??
12:11:58 <Gracenotes> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
12:11:59 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
12:12:00 <lambdabot> t63 t64. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36
12:12:00 <lambdabot> -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 ->
12:12:00 <lambdabot> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51,
12:12:02 <lambdabot> t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64)
12:12:04 <shapr> dcoutts: You've done wonderful things with cabal!
12:12:05 <Gracenotes> oops :(
12:12:19 <gwern> @quote fictional
12:12:20 <lambdabot> Anonymous says: Haskell, the world's leading purely fictional programming language
12:12:24 <mauke> JKL_: yes
12:12:27 <dcoutts> shapr: we've got an open ticket on tags if you want to work on it
12:12:30 <gwern> @quote 2009
12:12:31 <lambdabot> No quotes match. Wrong!  You cheating scum!
12:12:36 <BMeph> Gracenotes: Bad IRC-ster, no lambdas for j00! ;p
12:12:39 <Gracenotes> well, there's a 63 tuple, and the GHC.Tuple lists up to 62. So indeed
12:12:39 <gwern> @remember ehird 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
12:12:40 <lambdabot> Nice!
12:12:47 <ehird> gwern: What, again?
12:12:50 <shapr> dcoutts: I'm trying to scratch my own itch, hopefully I can get enough of a C# parser together to do sewage treatment at my job.
12:12:50 <JKL_> mauke: is there a reason why there have to be that data part?
12:12:53 <ehird> That's the third time it's been remembered.
12:12:55 <gwern> @quote unsafeCoerce
12:12:55 <ehird> Fourth.
12:12:56 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
12:12:59 <gwern> @quote unsafeCoerce
12:13:00 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
12:13:01 <ehird> First by axman on pumpkinbot
12:13:03 <ehird> then me on lambdabot
12:13:04 <wli> ehird: What Linux desktop?
12:13:06 <ehird> then axman on lambdabot
12:13:06 <mauke> JKL_: you mean the 'data' keyword?
12:13:08 <gwern> ehird: and it'll keep being remembered until it sticks!
12:13:10 <ehird> then you on lambdabot
12:13:12 <gwern> @quote unsafeCoerce
12:13:13 <ehird> @quote ehird
12:13:13 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
12:13:14 <lambdabot> ehird says: 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
12:13:19 <ehird> wli: Google it :P
12:13:25 <JKL_> mauke: more like why data has to be named
12:13:32 <gwern> @quote Writer
12:13:32 <lambdabot> Gracenotes says: A public service announcement: if you find yourself overusing the Writer monad, tell (Sum 1)
12:13:39 <wli> @type let newt delta epsilon f f' x0 = let xs = iterate (\x -> x - (f x)/(f' x)) x0 in snd . head . dropWhile (\(x, x') -> abs (x - x') >= delta || abs (f x - f' x) >= epsilon) . zip xs $ tail xs in newt 1.0e-6 1.0e-10 sin cos (0 :+ 1)
12:13:41 <gwern> @flush
12:13:41 <lambdabot> forall t. (Ord (Complex t), RealFloat t) => Complex t
12:13:44 <mauke> JKL_: huh?
12:13:44 <ehird> @quote lambdabot
12:13:45 <lambdabot> lambdabot says: Done.
12:13:51 <killerstorm> is there such thing as .. monadic map? i.e. what can i write instead of "renderVerbatim  h (a:as) = (renderVerbatim h a) >> (renderVerbatim h as)" (doing list one by one)
12:13:58 <SamB> JKL_: how are you going to write your type signatures without naming your types ?
12:14:00 <mauke> :t mapM
12:14:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:14:18 <JKL_> SamB: Constructor names it?
12:14:32 <SamB> JKL_: oh, constructor names ?
12:14:32 <BMeph> :t mapM_
12:14:33 <FunctorSalad> :t mapM_
12:14:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
12:14:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
12:14:39 <killerstorm> thanks. i could have guessed this.
12:14:44 <dolio> Gracenotes: It also doesn't dynamically generate show instances and such for them.
12:14:54 * BMeph high-air-fives FunctorSalad
12:14:57 <SamB> how is the compiler supposed to know what the heck you are doing if you don't have to type in the constructors?
12:14:58 <dolio> So you can't get it to do much.
12:14:58 <FunctorSalad> :D
12:15:22 <JKL_> mauke: data NamedData a b = Bettername a b, so why there is NamedData?
12:15:36 <wli> @type let newt delta epsilon f f' x0 = let xs = iterate (\x -> x - (f x)/(f' x)) x0 in snd . head . dropWhile (\(x, x') -> magnitude (x - x') >= delta || magnitude (f x - f' x) >= epsilon) . zip xs $ tail xs in newt 1.0e-6 1.0e-10 sin cos (1.0 :: Double)
12:15:37 <ehird> data Maybe a = Just a | Nothing
12:15:38 <lambdabot>     Couldn't match expected type `Complex t'
12:15:38 <lambdabot>            against inferred type `Double'
12:15:38 <lambdabot>     In the fifth argument of `newt', namely `(1.0 :: Double)'
12:15:41 <mauke> JKL_: so you can write the type of Bettername
12:15:42 <ehird> functions take both Just a and Nothing
12:15:46 <ehird> so you need a name for both
12:15:55 <Gracenotes> Manuel says: Including one more declaration gives a segmentation fault.
12:15:57 <Gracenotes> :/
12:16:08 <JKL_> mauke: but what to do with that NamedData?
12:16:13 <jeffwheeler> > let f n list = fix (fst . splitAt 20) in f 5 "Hello, world" -- ["Hello", ", wor", "ld"]
12:16:15 <lambdabot>   * Exception: stack overflow
12:16:19 <FunctorSalad> you could just make nested tuples...
12:16:31 <mauke> JKL_: what?
12:16:50 <jeffwheeler> > let f n list = fix (splitAt 5) in f 5 "Hello, world" -- ["Hello", ", wor", "ld"]
12:16:51 <lambdabot>   Couldn't match expected type `[a]'
12:17:03 <JKL_> mauke: Sorry that I don't get this. But why to name that Data if I dont use it after what row anywhere?
12:17:11 <jeffwheeler> > let f n list = fix (splitAt 5) [] in f 5 "Hello, world" -- ["Hello", ", wor", "ld"]
12:17:13 <lambdabot>   Couldn't match expected type `[a]'
12:17:15 <jeffwheeler> err
12:17:19 <BMeph> @hoogle magnitude
12:17:20 <lambdabot> Data.Complex magnitude :: RealFloat a => Complex a -> a
12:17:26 <FunctorSalad> which is essentially what Data.Vec does, except it uses :. instead of (,)
12:17:34 <JKL_> mauke: what <- that
12:17:35 <Gracenotes> there are 100-tuples declared in GHC.Tuple. But they're commented out; only up and until 62-tuples are declared.
12:17:39 <jeffwheeler> I'm sure there's a way to do this . . .
12:17:44 <Gracenotes> due to a "segmentation fault", apparently. Weeird.
12:17:47 <mauke> JKL_: Bettername has a type
12:18:01 <SamB> Gracenotes: maybe it was a stack overflow
12:18:05 <wli> Well, the lib is missing a very important piece.
12:18:14 <SamB> wli: what piece ?
12:19:04 <jeffwheeler> > let f n list = if length list <= n then list else let (a, b) = splitAt n list in a : f n b in f 5 "Hello, world" -- ["Hello", ", wor", "ld"]
12:19:05 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
12:19:05 <lambdabot>        Expect...
12:19:23 <BMeph> :t splitAt 5
12:19:25 <lambdabot> forall a. [a] -> ([a], [a])
12:19:27 <wli> SamB: An absolute value usable for genericity across real and complex.
12:19:29 <BMeph> :t fix
12:19:31 <lambdabot> forall a. (a -> a) -> a
12:19:35 <SamB> wli: ah.
12:19:41 <JKL_> mauke: So its named and we can say Bettername's type is NamedData
12:19:47 <Deewiant> jeffwheeler: ++, not :
12:19:50 <BMeph> jeffwheeler: Those types don't line up. :)
12:19:57 <mauke> JKL_: no
12:20:02 <jeffwheeler> > let f n list = if length list <= n then list else let (a, b) = splitAt n list in a ++ f n b in f 5 "Hello, world" -- ["Hello", ", wor", "ld"]
12:20:04 <lambdabot>   "Hello, world"
12:20:08 <jeffwheeler> BMeph: indeed. :)
12:20:10 <mauke> JKL_: its type is a -> b -> NamedData a b
12:20:27 <jeffwheeler> > let f n list = if length list <= n then [list] else let (a, b) = splitAt n list in a : f n b in f 5 "Hello, world" -- ["Hello", ", wor", "ld"]
12:20:29 <lambdabot>   ["Hello",", wor","ld"]
12:20:45 <jeffwheeler> I suspect there's a really clever solution using fix, though.
12:21:03 <JKL_> mauke: But can you see any other reason to name that data?
12:21:24 <mauke> JKL_: I don't see any reason not to name it
12:22:05 <JKL_> mauke: Yeh it doesnt make any harm. But if its only reason it can mix some newbies head :)
12:22:19 <Cale> JKL_: You generally create datatypes not only to package bits of related data together, but to ensure that the various parts of your library/program are fitted together correctly.
12:22:32 <mauke> JKL_: what other language lets you do this?
12:22:50 <Cale> JKL_: A datatype can not only express what data you have, but also the intent of that data.
12:23:03 <BMeph> wli: You'd have to have a way to find a compatible Real for a num, and then re-do abs to use that Real type. I don't think it's possible without specifying it beforehand. :)
12:23:03 <Cale> So having more than one type which is essentially the same is common.
12:23:24 <JKL_> mauke: I dont know
12:24:09 <thetallguy> gwern, shapr: what did you think might be in the seereason repository?
12:24:17 <BMeph> jeffwheeler: I think that's more of a takeWhile/itera thing, though. Yu're not supposed to end i you'ring fix'. :)
12:24:21 <mauke> (the answer is C, but it's not very common)
12:24:25 <BMeph> *iteraTE
12:25:16 <jeffwheeler> BMeph: I have no idea what you just said, haha.
12:25:53 <JKL_> mauke, cele: Thank you. I think I have more understanding again.
12:26:08 <shapr> thetallguy: A very large weapon with a radioactive power supply.
12:27:28 <wli> BMeph: Some associated ordered field... probably requires MPTC to do in any vaguely reasonable way.
12:28:01 * wli was a bit surprised to discover the open problems still remaining in/around MPTC.
12:28:04 <thetallguy> shapr: all our large weapons run on biodiesel
12:28:14 <shapr> thetallguy: Have you read Snow Crash?
12:28:31 <thetallguy> shapr: in '96 or so
12:28:35 <JKL_> mauke: data Maybe. I have seen that word Maybe is used there and there. So there have to be more reson to name data that I thinked
12:28:42 <shapr> thetallguy: There's a neat weapon in there called Reason.
12:28:55 <thetallguy> shapr: ah yes, I'd forgotten that.
12:29:03 <thetallguy> depleted uranium.
12:29:07 <shapr> yup
12:29:19 <JKL_> mauke: Or is Maybe also constructor?
12:29:21 <thetallguy> Yes, I thought of that when David came up with the name.
12:29:30 <thetallguy> but I'd since forgotten
12:29:32 <mauke> JKL_: it's a type constructor :-)
12:29:41 <mauke> JKL_: it has two data constructors, Nothing and Just
12:30:06 <thetallguy> maybe we can make a Haskell metaphor out of that.
12:30:40 <thetallguy> hot, radioactive in the research lab, safe to use outside the lab when it's cooled down a bit.
12:31:53 <JKL_> so data is like an interface?
12:32:25 <mauke> JKL_: no, it's a plain old type
12:33:25 <JKL_> mauke: but what is type. java says classes are types, i think
12:33:58 <mauke> in C++ speak, it's a union of structs
12:34:00 <mauke> sort of
12:34:16 <maltem> JKL_: no, classes and types are two concepts. That's why there are two words for them, after all.
12:34:49 <SamB> only it's a tagged union
12:34:58 <Cale> maltem: But most of the types in Java are classes...
12:34:59 <JKL_> maltem: some have said to me once that in java if you need a new type you write a new class :)
12:35:01 <maltem> JKL_: The Haskell way of defining new data types is called "algebraic data types", while the Java way of defining new data types is called "classes"
12:35:48 <maltem> (which should answer your remarks made at the same time :)
12:35:51 <MyCatVerbs> JKL_: be aware that there's an accidental clash of names between Haskell and Java. What Haskell 'classes' are much, much more like Java 'interfaces' than anything else in Java.
12:36:27 <davidL> are there any live installations of gitit anywhere?
12:36:45 <SamB> MyCatVerbs: so how do you explain the term "method"
12:37:15 <MyCatVerbs> SamB: I don't. Here, have a unicorn.
12:37:19 <Cheshire> are there are pretty printer libraries that let you define a couple different presentations?
12:37:20 <Saizan_> davidL: http://lhc.seize.it/ for example
12:37:32 <Cheshire> it would be nice to have plaintext and html..
12:37:42 <davidL> thanks Saizan_
12:37:52 <BMeph> @el xeblitz Sorry if I sounded like a smart-ass. Here, look at http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages for starters. :)
12:37:53 <lambdabot> Maybe you meant: elements elite pl
12:37:56 <Cheshire> hm prettyPrintWithMode
12:38:17 <ehird> BMeph: itym tell
12:38:19 <augustss> Success!! I can use semicolon in PRINT!
12:38:24 <Toxaris> Cale: I disagree. for every class C, there is a type List<C> in Java, and List<C> is a type, but not a class.
12:38:36 <BMeph> @tell xenoblitz Sorry if I sounded like a smart-ass. Here, look at http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages for starters. :)
12:38:36 <lambdabot> Consider it noted.
12:38:46 <Cale> Toxaris: To be honest, I haven't looked at Java's generics at all.
12:38:56 * BMeph thinks his keyboard needs an acetone bath.
12:38:58 <Toxaris> augustss: cool!
12:39:03 <Cale> Toxaris: I used Java a good while before generics were introduced.
12:39:31 <Toxaris> Cale: ok, so for every class C, there always was a type C[] in Java.
12:39:49 <Cale> Toxaris: yes, I see your point.
12:40:07 <JKL_> data Somedata a b = Some a | Some_ b; funkt :: Int -> Somedata; funkt (Some a) = Some 1; funkt (Some_ a) = Some 'a'; So this is something why we name data?
12:40:20 <BMeph> wli: The real issue is that abs should be a Real, but it's defined in Num.
12:40:21 <dolio> List<C> is the same class as List<B> underneath, I suppose.
12:40:27 <dolio> With different casts magically inserted.
12:40:41 <Cale> JKL_: that looks like a type error to me
12:41:12 <Toxaris> dolio: afaik no casts inserted at all, Java features complete type erasure for generics
12:41:17 <JKL_> Cale: I have to try to compile it then
12:41:52 <Cale> JKL_: I'm not sure I know what question you're asking though...
12:41:58 <dolio> Toxaris: Yeah, but don't you need to insert downcasts from Object?
12:42:10 <Cale> "So this is something why we name data?" doesn't really parse ;)
12:42:17 <JKL_> Cale: Thats the fun part ( me neither) ...
12:42:45 <Cale> JKL_: You'll find there's a type in the prelude defined as  data Either a b = Left a | Right b
12:42:53 <dolio> Or do generics have access to something that I wouldn't just doing everything manually?
12:43:13 <JKL_> Cale: Im just confused why there are multiple constructors for data and why data has unique name etc.
12:43:14 <Cale> JKL_: It's used for a number of purposes, but the most common is when there's a possible error response.
12:43:36 <Toxaris> dolio: yes, generics can do unchecked casts, similar to unsafeCoerce.
12:43:38 <Cale> JKL_: Well, consider the type and definition of lists...
12:43:43 <dolio> Ah, okay.
12:44:05 <Cale> JKL_: A list in Haskell is either the empty list, or it is a nonempty list consisting of a first element and another list.
12:44:21 <Cale> JKL_: So if Haskell didn't already have a list datatype, we could add it as follows:
12:44:31 <dolio> Isn't that kind of unsafe? I though you could treat List<C> as a plain List and insert bad Objects if you wanted ot.
12:44:34 <Cale> data List a = Empty | Nonempty a (List a)
12:44:43 <dolio> Maybe my information is old.
12:45:04 <Cale> So this says that a value of type List a is either the value Empty
12:45:13 <Cale> (which is our equivalent of [])
12:45:15 <Toxaris> dolio: my understanding is that it is totally unsafe. but that's not so bad because of the jvm. so you get some exception (instead of core dump), even if no explicit checked cast is inserted
12:45:26 <Cale> Or it is a value of the form Nonempty x xs, where x :: a, and xs :: List a
12:45:36 <dolio> Ah. I see.
12:45:37 <Cale> (our equivalent of (x:xs))
12:46:24 <Cale> JKL_: Does that make sense? The cases on the right hand side of the data declaration exhaustively list the possible shapes of values which belong to that type.
12:46:27 <Cheshire> how do you pretty print de bruijn syntax?
12:46:52 <Cheshire> I was thinking of adding a Suggestion = Maybe String to each binder, to choose names -- but it's difficult to not capture
12:46:57 <dolio> \\\. 2 1 3 1?
12:46:58 <Toxaris> Cheshire: by introdcuing names?
12:47:06 <Cale> JKL_: This means that if we know that a value has type List a, we know that it fits one of those patterns, and we won't miss out something if we can just handle those two cases.
12:47:14 <Cheshire> yeah I want to print \#0 as \x -> x
12:47:19 <dolio> Yeah, adding names is a good idea.
12:47:21 <JKL_> Cale: I didn't understand it completely. But it makes sense. -data Maybe- is kind of same i think
12:47:31 <Cale> data Maybe a = Nothing | Just a
12:47:42 <dolio> Look up "I am Not a Number, I am a Free Variable"
12:47:54 <Cale> It's similar, without the recursive tail. Sort of like a list of length at most 1.
12:48:21 <JKL_> that recursive tail, dropped me in your list example :)
12:48:31 <Cale> JKL_: So when we write a function to eat a value of type Maybe Integer, say, we just need to pattern match those two cases.
12:48:46 <Cale> f Nothing = 0
12:48:51 <Cale> f (Just x) = x^2
12:48:51 <Saizan_> ?index Either
12:48:52 <lambdabot> Data.Either, Prelude
12:49:07 <Cale> f :: Maybe Integer -> Integer
12:49:41 <Cale> JKL_: Similarly, we can define a type of binary trees...
12:50:03 <Cale> A binary tree is either empty, or it is a branch node consisting of a value, and left and right subtrees
12:50:07 <Cale> So:
12:50:17 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
12:50:21 <shapr> What's the best existing language parser I could use as an example for a C# parser?
12:50:54 <JKL_> Tip is empty tree?
12:50:59 <Cale> JKL_: yeah
12:51:21 <Cale> JKL_: and then we can make a value, like:
12:51:22 <JKL_> looks really good :)
12:51:46 <Toxaris> Cheshire: I don't see the problem with capture here, since you never perform operations on pretty printed terms. what about pretty printing (Lam (Lam (App (Var 1 "f") (Var 0 "x")))) into "\f1 -> \x2 -> f1 x2", so you have globally unique numbers to avoid name clashes, and locally sensible names to improve readability.
12:51:50 <ddarius> shapr: In Haskell?
12:51:51 <Cale> Branch 5 (Branch 2 Tip Tip) (Branch 7 (Branch 6 Tip Tip) Tip)
12:52:07 <shapr> ddarius: yeah
12:52:13 <ddarius> shapr: Probably Language.C
12:52:18 <shapr> k
12:52:18 <Cale> :: Tree Integer
12:52:40 <Cale> and then functions which operate on trees will pattern match:
12:52:43 <Cale> size Tip = 0
12:52:53 <mofmog> so... if ytou can program in haskell with basic
12:52:55 <Cale> size (Branch x l r) = 1 + size l + size r
12:52:58 <mofmog> or is it basic in haskell
12:53:08 <shapr> Speaking of which, is that module available?
12:53:14 <ddarius> It should be.
12:53:16 <orbisvicis> with runhaskell i can unregister a package ... but how do i remove the installed files ?
12:53:41 <Cale> orbisvicis: I think for now all you can do is remove them by hand unfortunately.
12:53:47 <Toxaris> Cheshire: of course, "\f -> \x -> f x" would be nicer, since we don't need the numbers here, and pretty printing (Lam (Lam (App (Var 1 "x") (Var 0 "x")))) would result in "\x -> \x1 -> x x1". that would still be kind-of easy, just keeping a list of already-used names while pretty-printing
12:53:52 <mofmog> you guys have seen the BASIC DSL right?
12:54:10 <mofmog> it reminded me of the C++ templates thing that made "visual numbers"
12:54:14 <Cale> JKL_: Is that starting to make sense?
12:54:15 <JKL_> Cale: is tree easy to force bintree?
12:54:22 <JKL_> Cale: yes, indeed
12:54:27 <orbisvicis> Cale: ah well ok, ty
12:54:30 <Cale> JKL_: These trees I defined can only be binary.
12:54:37 <Cheshire> Toxaris, I have free variables as well as bound variables, like   \(#0 x)  for example, if the binder \ has the suggestion x I might get \x -> x x naively, but I really needed \x' -> x' x
12:54:55 <Cale> JKL_: The branch nodes always have exactly two subtrees.
12:54:57 <Cheshire> maybe I just have to collect all the free vars first
12:55:29 <Cale> JKL_: If you wanted a more general tree, you'd have the Branch constructor take a list of subtrees.
12:55:29 <JKL_> Cale: ok, a is value and 2 childs as trees
12:55:33 <Cale> yeah
12:56:43 <JKL_> Cale: thank you.
12:56:43 <jeffwheeler> mofmog: now I have. That's neat. :P
12:56:51 <Elly> who on earth maintains the gentoo haskell packages
12:56:59 <Toxaris> Cheshire: oh I see. yes, then you could start with fv(term) as the list of forbidden variables. or you could ask for the current free vars in every step, so that you allow local shadowing where possible. not sure if that improves readability, though
12:57:01 <Elly> they're making a pig's breakfast of the deps
12:57:01 <mofmog> compile from source
12:57:23 <byorgey> gwern: eh? did some of them get repeated?
12:57:24 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:57:32 <Cale> Elly: I seem to recall that at least at one time it was dcoutts.
12:57:47 <Cale> Elly: But I don't use gentoo ;)
12:57:56 * Elly glares at dcoutts for xmobar requiring parsec-3.0.0 and darcs requiring parsec-2.1.0.1
12:58:32 <Cale> Elly: To be honest, it's probably best to just get to the point where you can install cabal-install and then install Haskell libraries with that.
12:58:38 <BMeph> shapr, mofmog, ddarius: Yes, it should be, but augustss is a tease. He lets us see what he does, but keeps the fun toys to himself. :\
12:58:43 <Cale> Elly: At least, as a developer. :)
12:59:31 <shapr> BMeph: Perhaps it's a puzzle that we are invited to solve?
12:59:45 <Cale> Elly: Not that this will necessarily save you from dependency hell entirely, but at least you'll have lots of versions to choose from when installing, and it won't complain about installing more than one.
12:59:48 * shapr hugs byorgey 
13:00:02 <shapr> @seen vixey
13:00:03 <lambdabot> I saw vixey leaving #haskell, #scala, #perl6 and ##logic 11d 21h 21s ago, and .
13:00:08 <shapr> eleven days??
13:00:10 <shapr> Where's vixey??
13:00:11 <Cale> (and it'll tend to resolve things itself rather well)
13:00:21 <shapr> Does anyone know vixey's email address?
13:00:23 * byorgey hugs shapr back
13:00:31 <byorgey> shapr: I don't even know vixey's real name!
13:00:32 <BMeph> shapr: Hmm, I think he was going that route with the BASIC stuff. He also has a C-style one, that I haven't heard about in a while.
13:00:33 <Cheshire> shapr shapr I am here
13:00:46 <shapr> Cheshire: Oh, you're vixey? whew!
13:00:49 <Cale> I think I got a patch from vixey a while ago...
13:01:02 <Cheshire> I haven't sent anyone patches
13:01:03 <jeffwheeler> Wait, vixey -> Cheshire?
13:01:09 <Cale> er, maybe not
13:01:09 <Elly> wait, what?
13:01:18 <shapr> Cheshire: I was worried, thought you'd found some other place to have adventures!
13:01:30 <Cheshire> shapr, I am ever writing haskell!
13:01:31 <Cale> (searching my mail revealed nothing, anyway :)
13:01:33 <Cheshire> even*
13:01:47 <shapr> Cale: The mystery has been solved!
13:01:51 <Cale> aha!
13:02:14 <shapr> vixey is now cheshire!
13:02:22 * shapr hugs Cheshire 
13:02:32 * shapr boings frumiously
13:02:33 * Cheshire hugs shapr :p
13:03:24 * byorgey challenges Cheshire to prove it by passing a vixey test, which is sort of like a Turing test except you have to pretend to be vixey instead of Turing
13:03:31 <Cheshire> lol
13:03:41 <Cheshire> ?vixey are you who you say you are?
13:03:42 <lambdabot> yes, i am
13:03:43 <Elly> how does a vixey test go?
13:04:02 <ehird> is ?vixey based on the vixey sometimes in here?
13:04:09 <Cale> no
13:04:15 <ddarius> @help vixey
13:04:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:04:16 <Cale> It's spell correcting to @vixen
13:04:17 <ddarius> @help vixen
13:04:18 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
13:04:20 <SamB> byorgey: but you don't pretend to be Turing in a Turing test
13:04:22 <shapr> It's pretty easy, you ask about former irc nicknames, former colleges, former locations, and previous interests.
13:04:24 <ehird> oh, ha
13:04:26 <SamB> you pretend to be human
13:04:29 <Cheshire> @w80 Sergeant
13:04:30 <ddarius> SamB: Maybe -you- don't.
13:04:30 <lambdabot> *** "sergeant" wn "WordNet (r) 2.0"
13:04:30 <lambdabot> sergeant
13:04:30 <lambdabot>      n 1: any of several noncommissioned officer ranks in the army or
13:04:30 <lambdabot>           air force or marines ranking above a corporal
13:04:30 <lambdabot>      2: a lawman with the rank of sergeant [syn: {police sergeant}]
13:04:32 <lambdabot>      3: an English barrister of the highest rank [syn: {serjeant-at-law},
13:04:33 <byorgey> SamB: it was a joke ;)
13:04:34 <shapr> SamB: ooh, good point
13:04:34 <lambdabot>          {serjeant}, {sergeant-at-law}]
13:04:37 <Cheshire> that spelling looks so wrong
13:04:50 <Toxaris> ?Cheshire is it true? -- doesn't work, Cheshire lies
13:04:51 <lambdabot> Unknown command, try @list
13:05:11 <Cale> Heh, it would be funny to have such a Turing test though, where people and machines pretended to be Turing.
13:05:36 <kaol> didn't GEB have a scene like that?
13:05:53 <byorgey> "so, explain to me those machines you invented"
13:05:58 <Turing> if you had such a test, I'd haunt you for all time from the grave
13:06:18 <Shiruka> I feel like I just channeled someone
13:06:23 <byorgey> "is it because of your father that you explain to me those machines you invented?"
13:06:26 <lepassive> Where is my Data.Time package ?
13:06:27 <ddarius> A Goedel test would be quite a bit more entertaining.
13:06:35 <shapr> Shiruka: #HaskellCurry?
13:06:39 <Cheshire> Toxaris, just realized -- to decide whether to display a product as  X -> Y  or  (x:X)Y[x]  I need to traverse and see if #0 is used... so yeah I will collect up freeVars at the same time
13:06:46 <BMeph> Shiruka: Well, at least you didn't "4chan"nel anything... ;p
13:07:10 <Cheshire> perfect.
13:07:25 <byorgey> ah, Cheshire is coding things with dependent types, that's proof enough for me ;)
13:08:21 <byorgey> ddarius: hehe, or an Erdos test
13:08:23 * Cheshire is writting pretty printer and parser (boring) since the type checking is done
13:08:58 <Shiruka> the curry language looks semi-interesting but unfortunately it's not just a haskell library :-(
13:09:36 <Shiruka> seems like everyone and their brother wants to make their own language implementation instead of extending existing ones
13:10:09 <ddarius> Shiruka: There is a Haskell library that does things like Curry.
13:10:25 <Cheshire> really? does it implement narrowing?
13:10:39 <Toxaris> Cheshire: I find pretty printing quite interesting. e.g. what to do with terms too large for the output context. which parts to leave out? I tried to do that clever for a interpreter, showing types in error messages in a meaningful way (easy to see which parts of two types are equal)
13:10:39 <ddarius> Yes.
13:10:45 <pejo> Shiruka, lots of languages are hard to implement as libraries I would guess.
13:10:52 <Gracenotes> @hoogle bracket_
13:10:53 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
13:11:13 <Shiruka> but if we have BASIC in haskell, why not curry? ;-)
13:11:15 * jkff has read a (take 2kb . reverse . getUrl $ "http://tunes.org/~nef/logs/haskell/09.02.07") and is glad to know that vixey still exists, yet under a different name. Hi Cheshire!
13:11:16 <pejo> Shiruka, not to mention that you inherit the problems of your host language as well.
13:11:27 <Cheshire> hey there jkff :p
13:12:12 <mmorrow> SML's interpreter lets you dynamically configure the depth at which it'll print datastructures before it elides with "..."
13:12:17 <Cheshire> Toxaris, one thing which is kind of interesting (which I haven't solved yet) is dealing with definitions
13:12:39 <mmorrow> it also lets you dynamically set the method it'll even use to print stuff
13:12:46 <Toxaris> pejo: is that a fundamental problem, or is it a problem with existing candidate host languages, that they do not allow a large class of languages to embed?
13:12:50 <Cheshire> Toxaris, like currently if I have some term with type P (f x y) for example, it's printing it with f completely expanded into primitives
13:12:55 <mmorrow> like as in if ghci let you s/Show/MyLeetClass/
13:13:18 <Cheshire> sometimes it should not be expanded.. how to know when as well as how to implement it is trick
13:13:20 <Cheshire> tricky
13:13:30 <mmorrow> you should just make it configurable
13:13:50 <mmorrow> then you don't have to decide! ;)
13:14:10 * mmorrow is half serious
13:14:27 <mmorrow> but both halves fully so
13:14:32 <Toxaris> Cheshire: interesting indeed. I thought about that stuff. My idea was to expand, and then refold using definitions in scope, heuristics guided to get a short type
13:15:00 <mmorrow> yuk, personally i hate using heuristics for anything
13:15:23 <Cheshire> Toxaris, I think that's what Coq does -- seems like a lot of work to do though, probably needs higher order unification
13:15:26 <mmorrow> (but will do so (grudgingly) if i have to)
13:15:47 <Toxaris> mmorrow: but the depth is no good. some parts of a type are more interesting then others, and I want to show the interesting ones.
13:16:09 * jkff returned to writing a lecture in Russian and stared at it for a moment, like, "What? I'm seeing a text that is not in English?". Probably he needs more Tolstoy.
13:16:45 <Toxaris> e.g.   "type error: (forall x : ..., [[Int]]) != (forall x : ..., [[Double]])" clearly shows the problem at a deep level, but doesn't bother with showing the kind
13:16:46 <mmorrow> Toxaris: i'd attack that by providing a hook to get passed some method of "ranking pieces by interest", to avoid hard-coding heuristics
13:17:18 <mmorrow> but of course i'm just talking in generalities and don't know the details of the particular situation you're talking about
13:17:25 <mmorrow> but still
13:18:58 <pejo> Toxaris, I think all implementations will suffer by some kind of artifacts.
13:19:07 <mreh> why ins't [(Side, Side)] the same as [Vertex] if Vertex = (Float, Float) and Side = Float
13:19:38 <Toxaris> and then, of course, if I have "type Goal = <something long>; val term = <something clever>", I want the typechecker to tell me that "term : Name", not "term : <something long>"
13:20:13 <Toxaris> mreh: it should.
13:20:29 <mreh> GHCI tells me otherwise, let me post it
13:20:54 <mreh> http://pastebin.com/m46358664
13:21:27 <Toxaris> mreh: can you post the error message, too?
13:22:06 <mreh> http://pastebin.com/m46ed4646
13:22:37 <koeien> mreh: what is your definition of Shape ?
13:23:00 <mreh> one of the constructors is [Vertex]
13:23:14 <mreh> Shape = [Vertex], Vertex = (Float, Float)
13:23:31 <Toxaris> mreh: so you have data Shape = ... ?
13:23:45 <koeien> mreh: this is type Shape = [Vertex], and type Vertex=(Float,Float) ?
13:23:52 <koeien> i.e. type synonyms?
13:24:11 <koeien> i also see 'Side'
13:24:18 <koeien> this is also a type synonym?
13:24:40 <mreh> yes, data Shape = [Vertex]
13:24:58 <mreh> Side = Float
13:25:04 <mreh> i'll paste the whole prog
13:25:35 <mreh> http://pastebin.com/d3aff2507
13:26:31 <Toxaris> mreh: ok with that data declaration, you do not have Shape = [Vertex]. Instead, you have to actually use the data constructor Polygon to convert a [Vertex] into a Shape.
13:26:49 <Toxaris> mreh: check the type of Polygon in ghci with ":t Polygon"
13:26:56 <mreh> yeah, right, I forgot :D
13:27:03 <mreh> the error was so cryptic though!
13:27:23 <Toxaris> mreh: what information was missing?
13:27:45 <jeffwheeler> Wait, I thought Cryptol was open-sourced?
13:28:06 <jeffwheeler> The Gaolois site only has a trial download.
13:28:26 <Toxaris> I understood that there is a free version and a non-free version
13:28:44 <the_unmaker> how does haskell take on large scael log processing?
13:29:00 <crutcher> I'm trying to build an Environment monad, Env, for building language evaluators
13:29:18 <crutcher> Sorry, not a monad, a type class
13:29:23 <beelsebob> does anyone know of any grammar description languages that can easily encode things like Haskell's offside rule?
13:29:23 <dons> jeffwheeler: it has the full cryptol interpreter (a la ghci)
13:29:24 <Cheshire> crutcher: What is it?
13:29:31 <dons> not the support toolchain for doing proofs.
13:29:37 <crutcher> I'd like to make IO an instance, but I'd also like to build an instance in State
13:29:40 <dons> its a full implementation of cryptol.
13:29:42 <beelsebob> dons: did that do it for you?
13:29:46 <jeffwheeler> dons: ah, that's what I wanted to play with. :)
13:29:56 <jeffwheeler> dons: I was reading through the presentation of the proof that looked neat.
13:30:14 <Cheshire> crutcher, why not just StateT, that way you can use it with IO or Identity
13:30:14 <dons> the equivalence proof tools?
13:30:15 <jeffwheeler> (From PLPV09)
13:30:20 <dons> ah yes
13:30:21 <crutcher> Cheshire: I just want a fakeable IO wrapper, really, that I can instrument for debuging (and for internal eval calls)
13:30:45 <Saizan_> crutcher: have you seen MonadPrompt?
13:30:50 <Cheshire> crutcher, btw I find that using a monad like that will be a huge hassle if you are implementing a lazy language
13:31:05 <Cheshire> crutcher, it doesn't intrude if you implement a strict language though
13:31:23 <dons> has anyone tried retargetting these pure gui dsls to flash?
13:31:38 <ddarius> Cheshire: For a non-strict language you use functions like m a -> m b rather than a -> m b
13:31:55 <crutcher> Saizan_: not yet, looks interesting.
13:32:41 <Cheshire> ddarius, I can't see that working
13:32:43 <crutcher> Cheshire: I know. I want an environment with semantics that look like the RealWorld, but which I control. But I also want to be able to bind it to the RealWorld.
13:32:58 <Cheshire> crutcher, oh I don't know anything about the RealWorld
13:33:11 <crutcher> ha
13:33:12 <Saizan_> crutcher: http://www.mail-archive.com/haskell-cafe@haskell.org/msg33040.html and the rest of the thread
13:34:25 <mathijs_> can someone explain to me why Data.Map is more efficient than alists when it comes to changes? Since they are both immutable? I know balanced trees are very efficient, but I can't see why changing a value in a tree won't need to copy the whole tree with just the change applied.
13:35:14 <mauke> mathijs_: because most of the tree can be reused without changes
13:35:17 <Saizan_> mathijs_: it only has to create new nodes for the path from the root to the value changed
13:35:20 <ddarius> Cheshire: Consider a simple example.  For the semantics of a strict, pure language would a function type like (a -> b) meaning (a -> Lift b) (Lift being the partiality monad effectively, i.e. it adds _|_).  The semantics of a non-strict language translates (a -> b) into (Lift a -> Lift b), i.e. both the source and target are lifted.
13:35:21 <dons> it just copies the path from the root to the node you're changing
13:35:34 <dons> the rest of the pointers out to the tree structure are untouched
13:35:37 <dons> since we know they're immutable
13:36:03 <Saizan_> mathijs_: immutability means that you can refer to subparts of the old tree without worrying about who keeps a reference to them
13:36:29 <mmorrow> mathijs_: this is built into graph reduction
13:36:35 <mathijs_> ah ok, so the new tree just refers to the old tree for the parts that are still the same?
13:36:35 <mmorrow> it "just happens"
13:36:44 <Saizan_> mathijs_: right
13:37:14 <ddarius> As another example, consider in Haskell a function (State s a -> State s a).  Such a function could use the first action multiple times and it would perform its effects each time just as it should in a call-by-name language.
13:37:38 <mathijs_> but if I have an alist, and I change the second value, won't the second value just be able to refer to the original 3rd element also?
13:37:46 <ddarius> Supporting call-by-need though, does need more machinery.
13:37:50 <Saizan_> mathijs_: it would
13:38:15 <Cheshire> ddarius, ah interesting point yeah
13:39:05 <Toxaris> mathijs_: yes that works, but if you change the last element in the list, you have to create a whole new list, while with a balanced tree, you only have to create (log n) new nodes
13:39:06 <Saizan_> mathijs_: the difference is that with trees the paths split in 2 or N, so you have more opportunities for sharing, while for a list you can only share a common tail
13:39:07 <Cheshire> ddarius, I usually reflect whichever strategy (need or name, usually GHC uses need I guess) haskell has by interpreting syntax into a semantic domain (D = D -> D type thing)
13:39:14 <mathijs_> Saizan_: so it all depends on which value I need to change... if it's closer to the start of the list, it's cheap, but moving towards the end it gets more expensive. So I take balanced trees (because of their balance) will generally have the values closer to the start/root?
13:40:22 <tromp__> :t reicp
13:40:23 <lambdabot> Not in scope: `reicp'
13:40:25 <tromp__> :t recip
13:40:27 <lambdabot> forall a. (Fractional a) => a -> a
13:40:44 <Saizan_> right: balanced trees have a depth of ~ log n, while a list has a depth of n
13:41:26 <mathijs_> cool, I get it now. thanks all.
13:44:08 <crutcher> grr. I don't seem to be able to follow the prompt discussion
13:44:13 <redditbot> Lennart: More BASIC
13:45:00 <Gracenotes> more?!?!?!?!?
13:45:01 <ehird> augustss: OverloadedStrings?
13:45:04 <ehird> Have you no SOUL?!
13:45:09 <ehird>     240 FOR X := 1 TO 5
13:45:10 <ehird>     250   PRINT X*X;" You won!"
13:45:11 <ehird>     260 NEXT X
13:45:12 <ehird> My lord...
13:45:17 <ehird> You have no soul.
13:45:27 <ehird> I'm revoking your Haskell license.
13:45:47 <dons> he asked for them.
13:45:57 <Gracenotes> oh my god, I remember writing that program in Haskell :D
13:46:01 <Gracenotes> er, in BASIC
13:46:14 <Gracenotes> I haven't yet written "guess the number" in Haskell, and I see no reason to
13:46:23 <ehird> I'm pretty sure augustss is actually messing with our heads.
13:46:27 <ehird> He hasn't actually implemented any of this.
13:46:29 <Gracenotes> ah, the nostalgia...
13:46:30 <ehird> In fact, it's impossible.
13:46:39 <ehird> But he wants to kill our minds.
13:46:44 <drhodes> :t fmap (+) (Just 5)
13:46:46 <lambdabot> forall a. (Num a) => Maybe (a -> a)
13:46:47 <Cheshire> why can't I just write pArrows = right assocative "->" between pApp :/
13:47:02 <mmorrow> omg, i just realized the potential of overloaded strings OverloadedStrings
13:47:06 <byorgey> Cheshire: for the parser?
13:47:09 <mmorrow> s/strings//
13:47:10 <Cheshire> yes
13:47:14 <ehird> mmorrow: transparent eval? :D
13:47:22 <byorgey> Cheshire: you pretty much can do that, with chainr or somesuch
13:47:26 <mmorrow> all kinds of stuff
13:47:37 <byorgey> Cheshire: let me look and remember how I did it in my lambda-cube interpreter
13:47:45 <mmorrow> i'd never looked at it other than a way to write ByteString literals until now
13:47:52 <jre2> anyone know what the easiest way to render pixels to the screen with sdl is?
13:47:54 <Cheshire> byorgey, sorry I am just being lazy
13:48:36 <Cheshire> many foo >>= return . chainl1 (:->:)
13:48:36 <mmorrow> Cheshire: use that function/algo in InfixP
13:48:37 <Cheshire> or whatever
13:48:54 <mmorrow> you have to give '->' a huge (infixr) precedence
13:49:05 <augustss> ehird: oh :)
13:49:33 <byorgey> I have  'parseTerm = try (chainr1 parseArrTerm (mkArrow <$ arrow)) <|> parseArrTerm'
13:49:40 <drhodes> :t (fmap (+) (Just 5)) 5
13:49:42 <lambdabot>     Couldn't match expected type `t1 -> t'
13:49:42 <lambdabot>            against inferred type `Maybe (a -> a)'
13:49:47 <byorgey> and parseArrTerm either isn't an arrow, or has parens, etc.
13:50:04 <the_unmaker> am I crazy, or is the world?
13:50:05 <drhodes> :t (fmap (+) (Just 5)) (Just 7)
13:50:07 <lambdabot>     Couldn't match expected type `t1 -> t'
13:50:07 <lambdabot>            against inferred type `Maybe (a -> a)'
13:50:13 <Cheshire> byorgey, is the whole implementation online somewhere?
13:50:16 <byorgey> 'arrow' parses a literal "->"
13:50:31 * Cheshire is wondering how many #haskell people have implemented the cube.. :)
13:50:38 <mmorrow> Cheshire: if you setup the fixities right, you could do eg "x :: a -> b * x :: c :: d -> f :: e" unambiguously
13:51:06 <ddarius> Cheshire: Implement a Pure Type System and get all at once.
13:51:25 * drhodes goes to sacrifice kittens
13:51:35 <byorgey> ddarius: that's what I did, although it could probably be more general
13:51:43 * mofmog has officially dedicated his life to replacing R with something not written by monkies
13:51:49 <byorgey> Cheshire: it isn't, but it should be!  just a second
13:51:55 <Cheshire> byorgey, cool :)
13:51:57 <tromp__> :t foldr'
13:51:58 <lambdabot> Not in scope: `foldr''
13:52:05 <jeffwheeler> drhodes: now that's not nice!
13:52:29 <koeien> mofmog: you mean GNU R?
13:53:05 <Gracenotes> it theoretically would be possibly to write a foldr', right? Not like it would /do/ anything useful, but it should be possible.
13:53:21 <mofmog> yeah
13:53:27 <mmorrow> foldr f !b xs = ...
13:53:40 <mofmog> it's godawful
13:54:09 <ddarius> The obvious broken implementation would make all uses of foldr' use linear stack.
13:54:48 <koeien> mofmog: yeah i've had the "pleasure" to work with it. i drove my teacher crazy by using higher-order functions though :)
13:54:52 <mmorrow> yeah, foldr wants the laziness
13:55:07 <ddarius> mmorrow: foldr' f = foldr (\x -> (f x $!))
13:55:13 <mmorrow> whereas foldl wishes it was foldl' (and i do to :)
13:55:35 * mmorrow thinks about that one
13:55:35 <mofmog> i like how there's an option for legends in the basic plot functions but to actually have a decent legend there's a separate legend() into which you have to input the data or something AGAIN
13:55:52 <tromp__> @src sum
13:55:52 <lambdabot> sum = foldl (+) 0
13:56:00 <mofmog> also the legend can't be plotted outside of the little area where the data is plotted *rollseyes*
13:56:10 <Gracenotes> > sum [1..10^6]
13:56:13 <lambdabot>   * Exception: stack overflow
13:56:16 <mmorrow> ddarius: oh nice, that does look useful actually
13:56:21 <mmorrow> hmm
13:56:57 <ddarius> mmorrow has an odd notion of "useful"
13:56:59 <mmorrow> well..
13:57:05 <p_l> hmm... any good plotting libraries for Haskell that I could use to plot statistical data, then? (Preferably working as standalone app on windows)
13:57:16 <olsner_> > (\f -> foldr (\x -> (f x $!))) (+) 0 [1..10^6]
13:57:17 <mmorrow> yeah, i can't think of any instances where that would change anything really
13:57:22 <lambdabot>   * Exception: stack overflow
13:57:31 <ddarius> olsner_: In that case there is no difference.
13:57:43 <mmorrow> you'd have to be building a peculiar structure for that to matter
13:57:55 <ddarius> mmorrow: foldr' (:) [] will stack overflow
13:58:07 <mmorrow> (i mean matter for the better ;)
13:58:34 <mmorrow> @let foldr' f = foldr (\x -> (f x $!))
13:58:36 <lambdabot>  Defined.
13:58:41 <Plouj> @check
13:58:43 <lambdabot>   <no location info>: parse error on input `;'
13:59:19 <Plouj> @check (\xs -> init xs == take ((length xs)-1) xs)
13:59:21 <lambdabot>   "* Exception: Prelude.init: empty list
13:59:23 <byorgey> Cheshire: darcs get http://www.cis.upenn.edu/~byorgey/code/lambda-cube/
13:59:36 <Cheshire> thanks
13:59:38 <byorgey> sure
13:59:54 <Gracenotes> @check (\xs -> null xs || init xs == take ((length xs)-1) xs)
13:59:55 <lambdabot>   "OK, passed 500 tests."
14:00:02 <Plouj> thanks Gracenotes
14:00:12 <Gracenotes> np
14:01:01 <Plouj> although I don't get it...
14:01:23 <olsner_> heh, augustss' haskell-basic is quite awesome... it's just missing a haskell-cobol to complement it :)
14:01:35 <Plouj> null xs is a Bool, while I don't see how take can return a Bool
14:02:38 <mauke> Plouj: it can't
14:02:39 <Gracenotes> it's of the format @check (\xs -> expr1 || expr2). When expr1 -- the list is null -- is true, then the entire check will be true.
14:02:58 <Gracenotes> When the list isn't null, i.e. it has elements, you'll check expr2
14:02:58 <Plouj> Gracenotes: aaah
14:03:05 <Plouj> great
14:03:54 <Gracenotes> in many other programming languages this is a feature called "short-circuit evaluation"; in Haskell, it's just called "laziness" :)
14:04:31 <Peaker> Gracenotes: there's an important distinction though - in Haskell laziness affects evaluation, and not effects, whereas with "short-circuiting", the actual effects are being avoided
14:05:08 <Peaker> Using lazy I/O in Haskell can also lead to that, but the ordinary case doesn't allow evaluation to determine visible effects
14:05:23 <ddarius> > True || undefined
14:05:25 <lambdabot>   True
14:05:29 <ddarius> > False || undefined
14:05:30 <lambdabot>   * Exception: Prelude.undefined
14:07:28 <roconnor> Cheshire: I use ∗ : T in my work.  But I understand if you prefer the use of ascii characters for your concrete syntax.
14:07:33 <Gracenotes> Peaker: what's a case in Haskell where evaluation is avoided but not effects?
14:07:38 <BMeph> > undefined || True
14:07:40 <lambdabot>   * Exception: Prelude.undefined
14:08:14 <Gracenotes> Peaker: "affects" is kind of vague :)
14:09:23 <Peaker> Gracenotes: well, laziness prevents bottoms, which surely affects the result, including effects.  Assuming no bottoms, though,  if x || y then ...   in Haskell doesn't matter if || is lazy or not.  In non-Haskell, the evaluation of x and y, even if it doesn't diverge, contain side effects
14:09:56 <Cheshire> roconnor, ASCII has just not got enough nice symbols
14:10:26 <roconnor> Cheshire: actually what I said isn't entirely true. I also use ∗ for as a member of any type with (extensionally) one element.  So ∗ : F -> F as well; which makes my notation potentially ambiguous.  But it is just my thesis, nothing formal.
14:10:40 <roconnor> Cheshire: Also note that ∗ is not *.
14:10:53 <Toxaris> Gracenotes: do {text <- readFile "somefile"; print (head text)} will read only the first character of somefile *and not close it*
14:10:55 <Cheshire> roconnor, I've seen that use of * a few times though, like Neil Ghanis stuff about eta
14:11:11 <Peaker> Toxaris: doesn't GC eventually close it?
14:11:20 <roconnor> oh good
14:11:31 <Toxaris> Peaker: My understanding is: you never know.
14:11:50 <Toxaris> Peaker: and more importantly, eventually is observably different from now
14:12:00 <Cheshire> bleugh :(
14:12:07 <Cheshire> my parser can't decide what  (t : T)Prf(P t) -> Ex T P  is
14:12:23 <Peaker> Toxaris: eventually places an upper bound, which is often enough, though
14:12:24 <Toxaris> Peaker: in other words, readFile should be called unsafeReadFile :)
14:12:27 <drhodes> > fmap (+7) (Just 11)
14:12:28 <Cheshire> dosen't know if it's ((t:T)...) -> (...) or  (t:T)(... -> ...)
14:12:29 <lambdabot>   Just 18
14:12:32 <Peaker> (or may place)
14:12:36 <Cheshire> and that's /because/ ReadP (+++)
14:12:48 <Toxaris> Peaker: programs which use readFile are often unusable in ghci.
14:12:53 <thoughtpolice> with a lazy readFile, you *don't* ever know when it will close
14:13:12 <Toxaris> Peaker: e.g. if they crash, you cannot start them again, because ghci is still running, so the file is still open :(
14:13:13 <drhodes> took 3 kittens to get that one.
14:13:19 <Gracenotes> Peaker: head [] is a bottom, in a sense, so ||'s laziness is important in many cases.
14:13:42 <Toxaris> Peaker: so even for little hacks (e.g. to test a parser), readFile is no good
14:13:46 <thoughtpolice> lazy IO makes things like this very unpredictable - it's the same with using hGetContents on a handle - you can't close the handle afterwords
14:14:21 <Peaker> Gracenotes: yeah, preventing bottoms is important, but even bottoms are not side effects :)
14:14:32 <thoughtpolice> because it's unknown as to when the stream from the handle is 'done' evaluating completely.
14:14:33 <Gracenotes> quite. I'm not entirely sure which class of side-effects you're talking about.
14:14:39 <Peaker> Gracenotes: also, with parallel-or you don't even have the bottom issue :)
14:14:39 <maltem> Toxaris: maybe ghci should have a :reset command anyway, which would reload and rebind all past definitions
14:15:14 <maltem> hm I'm not sure to what extent :reset could exist
14:15:27 <Peaker> Toxaris: yeah, those are good reasons not to use it -- I agree.. it all stems from hiding the side effects
14:15:27 <Gracenotes> :reload reloads the current module set
14:15:39 <Peaker> Gracenotes: Basically IO stuff
14:15:59 <Toxaris> maltem: so after I have evaluated something which leaks a file handle, I should evaluate it again with :reset? whats the point?
14:16:49 <Toxaris> I want that filehandle closed, and the only way I know to do so is to restart ghci
14:16:49 <maltem> Toxaris: yeah I guess there would be no point wrt file handles
14:16:58 <Peaker> Gracenotes: In Python:  def f(): print "hello" ; def g(): print "bye" ; if f() and g(): ...       the short-circuiting actually prevent the "bye" printing.  Whereas:  if f && g then ...   in Haskell, with laziness, can avoid bottoms, but not avoid printing stuff or side-effecting
14:17:10 <maltem> Toxaris: so maybe my imagination was just a little flawed some seconds ago :)
14:17:46 <Gracenotes> Peaker: ah, that makes sense. The point seems a bit moot, though, since &&/|| only take Bools, not IO Bools.
14:18:36 <Peaker> Gracenotes: that's the difference between laziness and short-circuiting as I see it.. (The argument types)
14:18:48 <Gracenotes> (.||.) a b = do { a' <- a; if a then (return True) else do { b' <- b; return b' }}
14:18:53 <Toxaris> Gracenotes: well, that *is* the point. Since you cannot print stuff in Haskell, you cannot avoid printing stuff :)
14:19:16 <Peaker> Gracenotes: that's indeed short-circuiting :)
14:19:33 <Peaker> Gracenotes: Rather than "just laziness" :)
14:19:43 <Gracenotes> Peaker: yeah, that makes sense. It's even more of a general difference between Haskell and other programming languages, that relates to the relationship between purity and laziness
14:20:16 <Gracenotes> of course, these other languages only really have types "IO Bool", so it's an analogy, take it as you will :)
14:20:18 <Peaker> Gracenotes: laziness is said to be main driver of purity in Haskell, historically
14:20:19 <Toxaris> True || unsafePerformIO (putStrLn "bye" >> return True) -- never printed
14:20:23 <Cheshire> byorgey, very nice!
14:21:15 <ddarius> Nothing keeps an impure language from being call-by-name or call-by-need.
14:21:23 <ddarius> There are several examples of such.
14:21:28 <Cheshire> ALGOL
14:22:03 <yitz> Toxaris: but theoretically, it could print. The compiler/runtime are free to do what they want.
14:22:35 <dons> augustss: its hard to walk back over all the posts in your blog. i wonder if there's a way to see the titles of all posts on a single page.
14:22:36 <Gracenotes> Haskell doesn't really have a commutative IO monad, as far as I can tell. That would probably go against one of the points of using monads for IO...
14:22:55 <lament> yitz: no, it couldn't
14:23:12 <Toxaris> yitz: My understanding is that in a lazy implementation of Haskell, this may not print, while in other implementations, it may do what it wants.
14:23:28 <Shiruka> the compiler/runtime aren't really free to do what they want in practice :-)
14:23:44 <Gracenotes> theoretically, sum [1..5] could launch the missiles...
14:23:46 <mmorrow> > (\xs -> flip (flip (foldr' (.) id . fmap (\a -> flip (. ($ (a:))))) ($ xs)) id $ []) [0..]
14:23:48 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:24:09 <mmorrow> i think that's like 12 cps transforms
14:24:11 * yitz rechecks the report
14:24:18 <Toxaris> yitz: but we are talking about laziness here (not non-strictness)
14:24:24 <Peaker> Gracenotes: I think it makes more sense to have commutative Applicatives than Monads
14:24:25 <mmorrow> (not really, but i lost track)
14:25:50 <yitz> Toxaris: the order of evaluation of || is unspecified (I think, rechecking). So even in a lazy implementation, it could do the second argument, then skip the first one lazily.
14:26:01 <ddarius> yitz: It's not unspecified.
14:26:18 <mmorrow> Cheshire: it looks like you have to adjust the precedences (left and right resp.) of application and (->) so they interact correctly
14:26:32 <Cheshire> mmorrow, I had to change my grammar a bit
14:26:35 <Cheshire> mmorrow, (also)
14:26:37 <yitz> ddarius: oh? do you know where?
14:26:45 <lament> @src (||)
14:26:46 <lambdabot> True  || _ =  True
14:26:46 <lambdabot> False || x =  x
14:26:49 <lament> there.
14:26:50 <ddarius> yitz: If nothing else, in the reference definition.
14:26:55 <mmorrow> Cheshire: i'm still trying to figure out how to do essentially that exact same thing
14:26:56 <Cheshire> mmorrow, e.g. below : (y:A)(R y x -> Acc R y) -> Acc R x  now
14:27:10 <Toxaris> yitz: || is defined with pattern matching on the first argument.
14:27:11 <Cheshire> mmorrow, is like  (forall y :: A. R y x -> Acc R y) -> Acc R x
14:27:17 <Toxaris> yitz: in the report
14:27:55 <Cheshire> morrow, but I was writing ((y:A)R y x -> Acc R y) before.. which now means ((y:A)R y x) -> Acc R y
14:28:05 <Toxaris> yitz: otherwise, the report would not be worth much, if a Haskell implementation could change the strictness of functions from the Prelude.
14:28:09 <Cheshire> I think it's better now though
14:28:21 <dancor> if i'm going to send a message from one process to another using a file or named pipe, does the receiver just have to poll?  getLine e.g. doesn't wait but instead does eof
14:28:31 <mmorrow> Cheshire: i'm thinking i'm going to do (forall x ...) as (\x -> ...)
14:28:33 <yitz> Toxaris: it wouldn't change the strictness
14:28:35 <mmorrow> (in general)
14:28:44 <Cheshire> using lambda notation ?
14:28:52 <mmorrow> or something similar
14:29:01 <Cheshire> mmorrow, prev. I used  /\x:T, ...  but I like this (x:T)... shorthand
14:29:13 <Cheshire> ∏x:T, ... is nice too
14:29:17 <mmorrow> i want to use the same syntax for both expressions and types
14:29:18 <Toxaris> yitz: I understood that your alternative || is strict in the second argument, while the usual || is not.
14:29:27 <Cheshire> mmorrow, but then how you know which is which?
14:29:33 <mmorrow> you won't!!
14:29:35 <mmorrow> :)
14:29:38 <yitz> Toxaris: well, it would given that definition in the Prelude - which forces strictness in the first argument
14:29:40 <mmorrow> they are the same datatype
14:29:42 <Cheshire> hehe
14:29:48 <Cheshire> but how can it work?
14:30:00 <ddarius> One way is type checking.
14:30:11 <Cheshire>   Nothing -> return () -- Ctrl-D
14:30:11 <Cheshire>   Just (init -> line) -> do -- remove trailing '\\n'
14:30:12 <mmorrow> "types" are just expressions in a certain context
14:30:19 <Cheshire> "Warning: Pattern match(es) are overlapped" sigh
14:30:50 <Toxaris> yitz: my point is just that the report has to specify strictness properties for the prelude functions so that applications can use them in a sensible way, because strictness properties are an essential part of the semantics of a function.
14:30:51 <yitz> Toxaris: I don't think that was the intention of that definition though
14:34:23 <yitz> Toxaris: I take that back, you're right
14:35:06 <dancor> oh i'm dumb actual named pipes do block
14:35:07 <yitz> Toxaris: you need to be able to write cheap || expensive and know that you'll only run expensive if required.
14:35:12 <yitz> so yeah
14:36:04 <Toxaris> yitz: especially if expensive is non-terminating
14:36:18 <yitz> Toxaris: that's really expensive
14:36:59 <augustss> dons: I dunno
14:37:41 <Toxaris> yitz: I would say: the compiler is free to implement the report in a way which causes applications to run slower. but the compiler is not free to implement the report in a way which causes an application not to terminate which would terminate with the record interpreted literally.
14:38:10 <yitz> Toxaris: agreed
14:38:30 <Toxaris> yitz: of course, a lot of applications only terminate because of compilers implementing lazy evaluation when call-by-name would be fine with the report, so that discussion is not too realworldish.
14:40:26 <yitz> > take 10 [1..] -- like this?
14:40:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:44:27 <dons> augustss: i also note  that the posts tend not to be displayed with a title
14:45:13 <Nafai> Heh
14:45:25 <alsonk> does anyone know how to catch the errors from a failed "read"?
14:45:30 <Nafai> I'm trying to backport the ghc 6.10 packages from debian experimental to ubuntu intrepid
14:45:33 <alsonk> e.g. read 1 :: Char
14:45:47 <alsonk> "catch" doesn't work...
14:45:51 <Nafai> But haddock depends on ghc 6.10 and ghc depends on haddoc
14:45:51 <yitz> alsonk: use reads
14:46:15 <yitz> @type reads
14:46:17 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:46:40 <yitz> > reads "1" :: [(Char,String)]
14:46:41 <lambdabot>   []
14:46:49 <yitz> > reads "'1'" :: [(Char,String)]
14:46:51 <lambdabot>   [('1',"")]
14:46:53 * Nafai wonders how to get around this
14:46:56 <alsonk> yitz: that looks about right
14:47:32 <mdmkolbe> What is the LANGUAGE option for allowing "type Foo = forall a. [a] -> [a]"?
14:47:42 <alsonk> > reads ('aab', 2) :: [(String, String)]
14:47:43 <lambdabot>   <no location info>:
14:47:44 <lambdabot>      lexical error in string/character literal at chara...
14:47:44 <kaol> Nafai: just set the haddock variable to NO in debian/rules and build haddock with the ghc6 you get from that
14:47:52 <Toxaris> yitz: maybe I'm just wrong with that one.
14:47:53 <alsonk> oops
14:47:59 <Nafai> kaol: Ah, cool.  I didn't look through rules close enough
14:48:02 <Nafai> Thanks
14:48:07 <alsonk> > reads ('aab', 2) :: [((String, String), String)]
14:48:09 <lambdabot>   <no location info>:
14:48:09 <lambdabot>      lexical error in string/character literal at chara...
14:48:15 <Toxaris> yitz: I'm confused.
14:48:31 <kaol> Nafai: http://lists.debian.org/debian-haskell/2009/02/msg00015.html
14:48:34 <yitz> > let maybeRead = listToMaybe . map fst . filter (null . snd) . reads in maybeRead "1" -- alsonk
14:48:34 <alsonk> > reads ("aab", 2) :: [((String, String), String)]
14:48:36 <lambdabot>   Nothing
14:48:36 <lambdabot>   Couldn't match expected type `String'
14:48:59 <yitz> @let maybeRead = listToMaybe . map fst . filter (null . snd) . reads
14:49:01 <alsonk> > reads "(\"aab\", 2)" :: [((String, String), String)]
14:49:01 <lambdabot>  Defined.
14:49:02 <pumpkin_> moo
14:49:03 <lambdabot>   []
14:49:05 <yitz> @type maybeRead
14:49:07 <lambdabot> forall a. (Read a) => String -> Maybe a
14:49:16 <kaol> but I'd still advise waiting until ghc6 moves to unstable
14:49:18 <yitz> alsonk: that is handy
14:49:20 <alsonk> yitz: that's even better...
14:49:29 <Toxaris> yitz: given that call-by-name already guarantuees that all programs terminate which terminate in any strategy, there should be no problem with implementing call-by-need instead (finite size of memory aside).
14:49:30 <Nafai> kaol: Ah, I missed that one :)
14:49:33 <alsonk> I know there was a maybeRead around.  I should have Hoogled it...
14:49:46 <Nafai> kaol: I'm just wanting to try it out on my system
14:50:26 <jre2> any opinions on when a function needs documentation beyond a type signature?
14:51:00 <yitz> Toxaris: finite memory is always a problem
14:51:22 <Nafai> kaol: Is there anything I can do to help?  I'm on the debian-haskell mailing list.
14:51:49 <Gracenotes> @src Typeable
14:51:50 <lambdabot> Source not found. I am sorry.
14:52:18 <yitz> pumpkin_: ?
14:52:25 <BMeph> jre2: Always. :\
14:52:37 <pumpkin_> yitz: I'm a cow
14:53:04 <kaol> Nafai: a lintian check to see that a haskell library package has all the necessary build deps would be nice
14:53:17 <yitz> pumpkin_: your kbd must have large keys
14:53:26 <pumpkin_> yup
14:53:38 <kaol> or those missing man pages for ghc6
14:53:43 <pumpkin_> it's a cowboard
14:54:35 <sereven> anyone know of a cabal hook to make a 'contents' index of a package's modules that includes the module descriptions? I'm looking for more detail than plain contents (index.html) and less than full index (doc-index.html).
14:54:46 <jre2> BMeph: what about the following:
14:54:46 <jre2> incIntList :: [Int] -> [Int]
14:54:46 <jre2> incIntList xs = map (+ 1) xs
14:55:23 <Nafai> kaol: I'll take a look at lintian and see how hard that is. :)  I'm relatively new to Debian packaging
14:56:00 <yitz> Toxaris: in c-b-name you could compute all parameters before the function, thus not terminate when lazy would
14:56:14 <jvd> tf
14:57:19 <yitz> sereven: sounds like a nice thing to write
14:58:02 <sereven> hehe, yeah, shouldn't be even beyond my meager skills, but figured it must be out on the interwebs somewhere already
14:58:23 <yitz> sereven: here's your chance to be famous
14:58:23 <BMeph> jre2: --| IncIntList adds one to each element of the list.
14:58:49 <Toxaris> yitz: isn't the point of cbn *not* to evaluate function parameters?
14:59:10 <BMeph> jre2: There are too many cases where people write functions whose objective "is obvious"...but don't do what people think they (should) do. :)
14:59:23 <jre2> of course
15:00:26 <jre2> but I'm not sure documenting everything is the correct way to fix that
15:01:17 <BMeph> jre2: In faqct, we had someone in-channel get all huffy on us, because we could not tell what the function was doing, even though he (?) insisted that the name told us "exactly" what the function was supposed to do.
15:02:17 <SamB> if that was all there was to it, we wouldn't need to write all this code!
15:02:17 <BMeph> jre2: I'm just saying, that the more you specify about what your function _is_ doing, and how it does it, the easier it is to tell how it works by reading the documentation.
15:03:16 <yitz> Toxaris: maybe I'm thinking of imperative cbn - pass pointer instead of actually calling the function, but you might reduce the pointers down the line before you go to the top-level function. In functional, that would be what we call cbv I guess.
15:03:53 <BMeph> jre2: Full disclosure: I'm a Software Engineering student, so I'm always going to be biased in favor of "document what you think you're doing, you stupid twit", as opposed to "look, my function is so brilliant, it documents itself." ;)
15:04:13 <Toxaris> yitz: I think   cbn  =  substitute the actual parameters "as is" into the body of the function (but capture avoiding, of course)
15:04:28 <SamB> if it's that damn obvious, just do this:
15:04:40 <SamB> write -| @$function@
15:04:42 <SamB> er
15:04:47 <SamB> -- | @$function@
15:04:59 <yitz> Toxaris: yeah. but then "by name" is a misnomer. so to speak, ahem.
15:05:18 <Toxaris> yitz: indeed. there are no names involved.
15:05:41 <SamB> well, how do YOU say that in three words?
15:05:55 <SamB> where the first is "call"
15:06:19 <Toxaris> and the last "name"?
15:06:21 <Toxaris> M)
15:06:24 <Toxaris> ;)
15:06:28 <BMeph> SamB: "Call-by-reference"? ;p
15:06:50 <BMeph> Toxaris: You... you... you _YOU_ you! ;p
15:07:01 <Toxaris> call-by-reference is what yitz means, but how to call what I mean?
15:07:15 <Toxaris> normal-order reduction?
15:07:16 <Toxaris> :)
15:07:17 <yitz> BMeph: even if the function really is "self-docmenting", that will not get picked up by automated documentation processing tools
15:07:27 <SamB> well, I could just call it "non-strict"
15:07:38 <Toxaris> call by non-strict = cbn :)
15:07:45 <SamB> hah
15:07:46 <BMeph> Toxaris: Let me page back and see what you said you meant... ;)
15:08:16 <Toxaris> http://en.wikipedia.org/wiki/Call_by_name
15:08:53 <BMeph> yitz: Well then, "obviously" there's something wrong with that tool. ;p
15:09:15 * BMeph clicks and reads...
15:09:39 <jre2> BMeph: I try to make my functions do as little as possible (thus 90% are 1-2 lines) and so adding 1-2 lines of comments and 1 line for the type sig leaves me a 3:1 or at best 3:2 documentation:code ratio, most of which is useless and so I'm not a fan of the clutter.  I certainly agree with you for anything longer though.
15:10:34 <lpsmith> Actually "non-strict" encompasses more than just call-by-name.
15:11:37 <Toxaris> BMeph: I agree. documentation tools should include source code (optionally) in their output.
15:11:44 <pumpkin_> dons: have you had a chance to take a peek at my patches?
15:12:12 <Toxaris> BMeph: at least for languages with a high information-per-code ratio like Haskell
15:12:20 <SamB> it'd certainly be nice if there was a simple way to say "include the source for this function in it's documentation"
15:12:27 <Cheshire> @go levy call by push value zoo
15:12:29 <lambdabot> http://www.reddit.com/r/programming/comments/7fb3c/latest_addition_to_the_programming_language_zoo/
15:12:29 <lambdabot> Title: Latest addition to the Programming Language Zoo: levy, a call-by-push-value lang ...
15:12:42 <Peaker> call-by-name is a silly name, imo.. the stuff isn't "names"...
15:12:57 <SamB> Toxaris: here you go! http://trac.haskell.org/haddock/newticket
15:12:58 <jre2> SamB: I like haddocks approach of just having a "source" link to the right on the documentation page
15:13:13 <SamB> jre2: even so!
15:13:13 <BMeph> Toxaris: Doesn't that interpretation depend on dynamic scoping?
15:13:46 * SamB has submitted enough Haddock tickets in the past week or so as it is ;-P
15:14:23 <Toxaris> BMeph: you mean the wikipedia entry on cbn?
15:14:51 <lpsmith> Peaker:  lol,  never really thought about the name of Call by Name,  I just try to understand it sometimes.
15:15:03 <Toxaris> BMeph: note that once you are in the position to do the call (by name), there are not free variables left, because free variables from outer lambdas have been bound when their call-by-name was performed
15:15:49 <Toxaris> BMeph: in a real implementation, you want to use an environment instead of substitution, so you have to somehow capture the values of the free variables at the call site
15:16:26 <yitz> lpsmith: since it claims to be about names, you would think it would get its own name right
15:16:50 <Toxaris> BMeph: whether you have dynamic or lexical scope depends on the substituation you do. with capture-avoiding substitution, you get lexical scope
15:16:55 <michaelcdever> hey quick question, i want to filterM a list of filePaths against fileAccess which is of type fileAccess :: FilePath -> Bool -> Bool -> Bool -> IO Bool
15:17:01 <michaelcdever> how would i write that
15:17:41 <michaelcdever> i tried filterM fileAccess ( flip True ( flip True ( flip True paths ) ) )
15:18:00 <Cheshire> :t flip True
15:18:01 <lambdabot>     Couldn't match expected type `a -> b -> c'
15:18:02 <lambdabot>            against inferred type `Bool'
15:18:02 <lambdabot>     In the first argument of `flip', namely `True'
15:18:18 <michaelcdever> :t flip True False
15:18:20 <lambdabot>     Couldn't match expected type `a -> b -> c'
15:18:20 <lambdabot>            against inferred type `Bool'
15:18:20 <lambdabot>     In the first argument of `flip', namely `True'
15:18:27 <michaelcdever> ahh
15:18:41 <Cheshire> :t filterM (?fileAccess :: FilePath -> Bool -> Bool -> Bool -> IO Bool)
15:18:43 <lambdabot>     Couldn't match expected type `Bool'
15:18:43 <lambdabot>            against inferred type `Bool -> Bool -> IO Bool'
15:18:43 <lambdabot>       Expected type: FilePath -> Bool -> Bool
15:18:45 <yitz> @pl \r w x -> \fp -> fileAccess fp r w x
15:18:45 <lambdabot> (flip .) . flip . flip fileAccess
15:19:16 <yitz> michaelcdever: better off with just the lambda exp.
15:19:57 <yitz> @pl \fp -> fileAccess fp True True True
15:19:58 <lambdabot> flip (flip (flip fileAccess True) True) True
15:20:09 <yitz> blech
15:20:32 <michaelcdever> :o, i'm completely lost now lol
15:20:52 <rwbarton> :t ($ True) . ($ True) . ($ True) . ?fileAccess
15:20:54 <lambdabot> forall b a. (?fileAccess::a -> Bool -> Bool -> Bool -> b) => a -> b
15:21:22 <yitz> michaelcdever: use filterM (\fp -> fileAccess True True True)
15:21:31 <yitz> oops
15:21:37 <Cheshire> :t ($ True) . ($ 'x') . ($ ()) . ?fileAccess
15:21:38 <yitz> michaelcdever: use filterM (\fp -> fileAccess fp True True True)
15:21:39 <lambdabot> forall b a. (?fileAccess::a -> () -> Char -> Bool -> b) => a -> b
15:21:50 <Cheshire> :t ($ True) . ($ 'x') . ($ ()) ?fileAccess
15:21:51 <lambdabot> forall b a. (?fileAccess::() -> a -> Char -> Bool -> b) => a -> b
15:21:58 <michaelcdever> ah ok
15:22:00 <michaelcdever> i see
15:22:04 <Cheshire> well that doesn't make any sense at all
15:22:06 <ehird> What are those ? things anyway?
15:22:13 <ehird> :t ?a
15:22:15 <lambdabot> forall t. (?a::t) => t
15:22:18 <Cheshire> :t ($ True) . ($ 'x') (($ ()) ?fileAccess)
15:22:20 <lambdabot> forall b a. (?fileAccess::() -> Char -> a -> Bool -> b) => a -> b
15:22:20 <ehird> Dependent types/
15:22:22 <ehird> ?
15:26:21 <koeien> implicit parameters?
15:26:46 <Toxaris> indeed, implicit parameters.
15:26:53 <koeien> i wasn't sure of the name
15:27:27 <michaelcdever> ok thanks... got it now :D
15:28:45 <ehird> Oh, wow.
15:28:49 <ehird> It's dynamic variables.
15:29:09 <Toxaris> ehird: not dynamic, implicit
15:29:20 <ehird> Toxaris: Yes, but
15:29:25 <ehird> they act like dynamically scoped variables
15:29:30 <ehird> as opposed to lexically scoped ones
15:29:56 <Toxaris> hmm yeah dynamically scoped maybe, but they have lexical extend
15:30:01 <Toxaris> s/extend/extent
15:30:19 <Toxaris> > let magic = ?answer in let ?answer = 42 in magic
15:30:21 <lambdabot>   42
15:30:30 <mauke> http://okmij.org/ftp/Computation/dynamic-binding.html#implicit-parameter-neq-dynvar
15:30:30 <ehird> Aw darnit.
15:30:37 <ehird> fact =
15:30:38 <ehird>     if ?n == 0
15:30:38 <ehird>       then 1
15:30:40 <ehird>       else ?n * (let ?n = ?n - 1 in fact)
15:30:42 <ehird> doesn't work
15:31:06 <rwbarton> let m = ?n in let ?n = m - 1 in fact maybe?
15:31:38 <mmorrow> , let ?n = 10 in let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact)
15:31:39 <lunabot>  luna: parse error on input `)'
15:31:41 <mmorrow> , let ?n = 10 in let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact
15:31:42 <lunabot>  luna: parse error on input `)'
15:32:03 <rwbarton> , let ?n = 10 in ?n
15:32:04 <lunabot>  10
15:32:18 <rwbarton> , [$ty| ?n |]
15:32:21 <lunabot>  luna: Exception when trying to run compile-time code:
15:32:22 <mmorrow> , let ?n = 10 in let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:32:24 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:32:43 <Toxaris> , let n = n - 1 in n
15:32:45 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:33:18 <mmorrow> , let ?n = 10 in let fact = if ?n == 0 then 1 else ?n * (let x = ?n in let ?n = x-1 in fact) in fact
15:33:20 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:33:36 <lpsmith> yitz:   Ok,  I'll bite.  What's so terribly wrong with it?
15:33:56 <lpsmith> I must warn you I like to program in  relatively point-free style
15:34:03 <yitz> lpsmith: "call by name" has nothing to do with names
15:34:12 <lpsmith> Because I hate making up names.   I like to make them nice when I do.
15:34:29 <mmorrow> , let dec x y = let ?n = x in y in let ?n = 10 in let fact = if ?n == 0 then 1 else ?n * dec 1 fact in fact
15:34:31 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:34:43 <mgsloan> I've been trying to understand the CBPV stuff
15:35:04 <mgsloan> I _really_ want to take a class in type systems / semantics
15:35:21 <yitz> lpsmith: so ironically, call by name isn't the name that it is called by. or something.
15:35:30 <Cheshire> mgsloan, it's interesting stuff yeah
15:35:57 <mmorrow> , let dec x y = let ?n = x in y in (let ?n = 10 in dec (?n - 1) ?n)
15:35:58 <lunabot>  10
15:36:46 <rwbarton> :t let dec x y = let ?n = x in y in dec
15:36:48 <lambdabot> forall t t1. t -> t1 -> t1
15:37:12 <rwbarton> :t let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact)
15:37:14 <lambdabot> <no location info>:
15:37:14 <lambdabot>     not an expression: `let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact)'
15:37:18 <rwbarton> :t let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:37:19 <lambdabot> forall a. (?n::a, Num a) => a
15:37:22 <mmorrow> , let set n' k x = let ?n = n' in k x in (let ?n = 10 in set (?n - 1) (\() -> ?n) ()
15:37:23 <lunabot>  luna: parse error (possibly incorrect indentation)
15:37:26 <mmorrow> , let set n' k x = let ?n = n' in k x in (let ?n = 10 in set (?n - 1) (\() -> ?n) ())
15:37:27 <lunabot>  10
15:37:43 <ehird> How did that work/
15:38:34 <mmorrow> , let set n' k x = let ?n = n' in (?n, k x) in (let ?n = 10 in set (?n - 1) (\() -> ?n) ())
15:38:35 <rwbarton> , let ?n = 10 in let fact :: (?n :: Int) -> Int; fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:38:37 <lunabot>  (9,10)
15:38:37 <lunabot>  3628800
15:39:25 <mmorrow> , let set n' k x = let ?n = n' in (?n, k x) in (let ?n = 10 in set (?n - 1) ((,) ?n) ?n
15:39:26 <lunabot>  luna: parse error (possibly incorrect indentation)
15:39:29 <mmorrow> , let set n' k x = let ?n = n' in (?n, k x) in (let ?n = 10 in set (?n - 1) ((,) ?n) ?n)
15:39:30 <lunabot>  (9,(10,10))
15:39:47 <mgsloan> Argh! there are no classes at university of washington (at least under CSE) for type systems and semantics
15:39:48 <mgsloan> bah
15:40:08 <mgsloan> imho computer science without that isn't really much of a science
15:40:18 <Cheshire> mgsload, you can self study
15:40:43 <Cheshire> well a good library is very useful if you do that...
15:42:28 <mgsloan> yeah, I have before, I learned to understand the fraction-looking notation for type values / expressions
15:43:02 <mgsloan> and lambda calc of course, and such, but still, this is the kind of thing I could imagine a class being on
15:43:22 <mgsloan> tons of exercises would be very helpful
15:44:16 * Cheshire will make some exs. soon
15:44:42 <mgsloan> it's not so much the exercises but the fact you've gotta do em :P but good idea!
15:44:58 <mmorrow> this is a good one:
15:44:59 <mmorrow> , let dyn () = ?n; set n' k x = let ?n = n' in (k (\() -> ?n), k x) in let ?n = 10 in set (?n - 1) (\f -> f ()) dyn
15:45:00 <lunabot>  (9,10)
15:45:04 <Toxaris> mgsloan: do you know PLAI?
15:45:08 <Toxaris> mgsloan: http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/
15:45:36 <Toxaris> it's a standard introduction textbook for, well, programming languages
15:45:54 <Toxaris> while it uses Scheme, it contains chapters about types etc.
15:45:56 <mgsloan>  I know of it.  I read significantly into TAPL at one point
15:46:03 <mmorrow> um
15:46:04 <mgsloan> ahh sweet
15:46:17 <Toxaris> oh ok, TAPL would be the standard textbook for the followup course :)
15:46:40 <Toxaris> so what do you miss if you read significantly into TAPL? just go straight to research papers :)
15:46:53 <mgsloan> hah, yeah, I definitely get the base stuff, it's just the notation and verbiage of papers is lost on me
15:47:09 <mgsloan> haha. well I'm afraid most of my TAPL reading hasn't stuck
15:47:21 <mgsloan> I definitely recognize the stuff, but it's gibberish again
15:47:25 <Toxaris> oh, and maybe you should actually implement a typechecker and an interpreter for some small but interesting language, its a great experience and really makes you understand stuff
15:47:40 <mgsloan> yup, I definitely intend to do that, hopefully multiple times
15:49:25 <mmorrow> rwbarton: whoa, why did the type sig make that work?
15:49:33 <michaelcdever> could someone point me at where to look at for exception handling
15:49:45 <mmorrow> , let ?n = 10 in let fact :: (?n :: Int) -> Int; fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:49:46 <lunabot>  3628800
15:49:52 <mmorrow> , let ?n = 10 in let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:49:54 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:50:02 <mmorrow> , let ?n = 10 in let fact :: (?n :: Integer) -> Int; fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:50:03 <lunabot>  luna: Couldn't match expected type `GHC.Integer.Internals.Integer'
15:50:05 <pejo> Toxaris, I find books significantly easier than research papers. Especially TAPL, which is a master piece.
15:50:05 <mmorrow> , let ?n = 10 in let fact :: (?n :: Integer) -> Integer; fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:50:07 <lunabot>  3628800
15:50:13 <rwbarton> mmorrow: I have no idea.  But I read the manual and it said that adding a type signature sometimes changes the behavior of the function. :)
15:50:20 <mmorrow> rwbarton: weird
15:50:49 <mmorrow> i keep thinking "oh i got it now", and then some case comes up that contradicts what i thought was happening :)
15:51:02 <rwbarton> I think it's better not to get it
15:51:09 <mmorrow> heh
15:51:21 <Toxaris> pejo: I agree. that's why one should read books first. But after reading books, one can go on :) (or read books again, and this time do the exercises)
15:51:42 <ddarius> Research papers variable dramatically in approachability.
15:51:51 <Toxaris> thats the role of a lecture: to force me to do the exercises.
15:52:01 <BMeph> ddarius: DYM "vary"? :)
15:52:06 <mgsloan> Toxaris - I'm just a freshman in college, and atm i'm seeing a CSE major as more of a refining, filling the cracks in of my knowledge, and types etc would be awesome to study.
15:52:10 <mgsloan> perhaps I should just take more math
15:52:27 <Toxaris> ok, and sometimes, there is a good lecturer, which actually has to tell something :)
15:53:08 <Toxaris> mgsloan: yeah maybe there are math people at your uni which do type theory (or something else which is interesting)
15:55:48 <mmorrow> rwbarton: heh, i think i found out why
15:55:50 <mmorrow> , let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:55:51 <lunabot>  luna: Unbound implicit parameter (?n::a)
15:55:56 <mmorrow> just `a'
15:56:18 <mmorrow> that looks like a bug to me
15:56:23 <Gracenotes> hm... ADTs would be a good representation of incoming IRC events. Great for pattern matching.
15:57:42 <Toxaris> mmorrow: I guess that "Num a" is also in the context, besides (?n :: a)
15:58:11 <Toxaris> @type ?a + 42
15:58:13 <lambdabot> forall a. (Num a, ?a::a) => a
15:58:19 <Toxaris> > ?a + 42
15:58:21 <lambdabot>       Unbound implicit parameter (?a::a)
15:58:21 <lambdabot>        arising from a use of `e_1142...
15:58:33 <Toxaris> > let ?a = 0 in ?a + 42
15:58:34 <lambdabot>   42
15:59:29 <mmorrow> Toxaris: ah, that's a possibility, but i'm skeptical that the Num is being attached there
15:59:35 <rwbarton> , let fact = if ?n == (0 :: Integer) then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
15:59:36 <lunabot>  luna: Unbound implicit parameter (?n::GHC.Integer.Internals.Integer)
15:59:49 <rwbarton> , let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - (1 :: Integer) in fact) in fact
15:59:50 <lunabot>  luna: Unbound implicit parameter (?n::GHC.Integer.Internals.Integer)
16:00:00 <rwbarton> , let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - (1 :: Integer) in fact) in let ?n = 10 in fact
16:00:01 <lunabot>  luna: Unbound implicit parameter (?n::GHC.Integer.Internals.Integer)
16:00:11 <rwbarton> :t let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - (1 :: Integer) in fact) in fact
16:00:13 <lambdabot> (?n::Integer) => Integer
16:00:32 <Toxaris> that looks broken
16:00:45 <ehird> > let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - (1 :: Integer) in fact) in fact
16:00:47 <lambdabot>       Unbound implicit parameter (?n::Integer)
16:00:47 <lambdabot>        arising from a use of `...
16:00:55 <ehird> > let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - (1 :: Integer) in fact) in let ?n = 6 in fact
16:01:00 <ehird> It's impossible, I think.
16:01:11 <lambdabot>   thread killed
16:01:41 <rwbarton> No, you just need a type signature on fact
16:01:55 <ehird> No, it's because of the
16:01:58 <ehird> let ?n = ?n
16:02:03 <ehird> That will always loop forever
16:02:12 <ehird> You need to do this:
16:02:21 <rwbarton> implicit variable bindings are nonrecursive, according to the manual
16:02:27 <ehird> > let fact = if ?n == 0 then 1 else ?n * ((\a -> let ?n = a - (1 :: Integer) in fact) ?n) in let ?n = 6 in fact
16:02:33 <ehird> hm.
16:02:43 <lambdabot>   thread killed
16:02:44 <Toxaris> rwbarton has read the manual => cheater
16:03:01 <rwbarton> Read, but not understood :)
16:03:03 <ehird> quite
16:04:18 <mmorrow> , let ?n = 10 in let fact :: (?n :: Int) -> Int; fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
16:04:19 <lunabot>  3628800
16:04:23 <mmorrow> , let ?n = 10 in let fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
16:04:24 <lunabot>  luna: out of memory (requested 2097152 bytes)
16:04:31 <mmorrow> , let ?n = 10 in let fact :: (?n :: Integer) -> Integer; fact = if ?n == 0 then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
16:04:32 <lunabot>  3628800
16:04:54 <mmorrow> so there's no way it's defaulting to Integer and Integer is causing the fail
16:05:03 <mmorrow> so if not Integer, then what?
16:06:36 <rwbarton> It's not related to defaulting
16:06:46 <rwbarton> , let ?n = 10 in let fact = if ?n == (0 :: Integer) then 1 else ?n * (let ?n = ?n - 1 in fact) in fact
16:06:48 <lunabot>  luna: out of memory (requested 2097152 bytes)
16:07:32 <shapr> oh no!
16:08:09 <mmorrow> it looks like it's a bug in recursive lets
16:08:11 <mmorrow> , let ?f = id; ?n = ?f 10 in ?n
16:08:12 <lunabot>  luna: Unbound implicit parameter (?f::t -> a)
16:08:19 <mmorrow> , let ?n = ?f 10 in ?n
16:08:20 <lunabot>  luna: Unbound implicit parameter (?f::t -> a)
16:08:32 <mmorrow> , let ?n = ?f 10 in let ?f = id in ?n
16:08:33 <lunabot>  luna: Unbound implicit parameter (?f::t -> a)
16:08:58 <ehird> mmorrow: well duh
16:09:01 <ehird> it's lexically scoped
16:09:08 <ehird> , let ?f = id in let ?n = ?f 10 in ?n
16:09:09 <lunabot>  10
16:09:12 <rwbarton> mmorrow: implicit variable bindings are nonrecursive
16:09:17 <mmorrow> ohhh
16:09:33 <rwbarton> and they can't be mixed with normal let bindings
16:09:43 * mmorrow has to rtfm
16:09:57 <mmorrow> , fix (\x -> ?f x)
16:09:58 <lunabot>  luna: Unbound implicit parameter (?f::a -> a)
16:09:59 <rwbarton> I have an even better idea
16:10:09 <mmorrow> , fix (\x -> let ?f = id in ?f x)
16:10:11 <lunabot>  luna: out of memory (requested 2097152 bytes)
16:10:13 <rwbarton> don't use implicit parameters :)
16:10:28 <mmorrow> , fix (\x -> let ?f = const 4 in ?f x)
16:10:29 <lunabot>  4
16:10:43 <mmorrow> , let ?f = (0:) in fix (\x -> ?f x)
16:10:44 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:11:24 <ehird> I tried to write a fix using implicit variables
16:11:25 <ehird> i.e.
16:11:27 <ehird> fix (1 : ?me)
16:11:29 <ehird> but it didn't work
16:11:30 <ehird> :(
16:11:32 <mmorrow> , let ?f = const ?n in let ?n = fix (\x -> ?f x)
16:11:33 <lunabot>  luna: parse error on input `)'
16:11:43 <mmorrow> , let ?f = const ?n in let ?n = fix (\x -> ?f x) in ?n
16:11:44 <lunabot>  luna: Unbound implicit parameter (?n::a)
16:11:55 <ehird> fix a = let ?me = fix a in a
16:11:57 <ehird> was it
16:11:58 <mmorrow> ehird: ah, ok
16:12:04 <ehird> but it just comes up as
16:12:06 <ehird> fix :: t -> t
16:12:07 <ehird> :(
16:12:30 <mmorrow> i wonder what it's actually doing when it tries to eval it
16:12:43 <rwbarton> ehird: since you didn't actually use ?me...
16:12:50 <ehird> rwbarton: the idea is that a uses me
16:12:56 <ehird> that is you do
16:13:01 <ehird> (fix (1 : ?me))
16:13:04 <rwbarton> :t fix a = let ?me = fix a in a
16:13:06 <lambdabot> parse error on input `='
16:13:15 <rwbarton> :t let fix a = let ?me = fix a in a in fix
16:13:17 <lambdabot> forall t. t -> t
16:14:01 <rwbarton> :t let fix :: ((?me :: a) => a) -> a; fix a = let ?me = fix a in a in fix
16:14:03 <lambdabot> forall a. ((?me::a) => a) -> a
16:14:08 <rwbarton> :t let fix :: ((?me :: a) => a) -> a; fix a = let ?me = fix a in a in fix (1 : ?me)
16:14:10 <lambdabot> forall t. (Num t) => [t]
16:14:13 <rwbarton> , let fix :: ((?me :: a) => a) -> a; fix a = let ?me = fix a in a in fix (1 : ?me)
16:14:14 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:14:29 <rwbarton> you need explicit type signatures for higher-order polymorphism
16:14:53 <roconnor> data-accessor aka lenses seem really really useful.  Like zipper useful.
16:14:59 <roconnor> I can't wait to try it out
16:15:10 <rwbarton> or rather, implicit parameters seem to interact badly with type inference.
16:17:22 <rwbarton> > [| ?a |]
16:17:24 <lambdabot>   <no location info>: parse error on input `|'
16:17:24 <rwbarton> , [| ?a |]
16:17:27 <lunabot>  luna: Implicit parameters not (yet) handled by Template Haskell ?a
16:20:48 * byorgey makes thin-cut lambda fries
16:22:23 <rwbarton> byorgey: how about lambda monads?
16:22:35 <byorgey> rwbarton: ah, that sounds yummy! =)
16:23:36 <byorgey> rwbarton: btw, I think we were at the national mathcounts competition together =)
16:23:48 <byorgey> assuming you are the same rwbarton that was at the national mathcounts competition.
16:24:38 <rwbarton> oh wow, back in 96 or 97?
16:24:43 <byorgey> yup
16:25:45 <michaelcdever> dons: thanks for the help with forkIO, huge speed improvement now ive my method finalized, it's still slow, but with so many folders on linux i can't help that
16:26:14 <wli> michaelcdever: What filesystem?
16:26:15 <dons> using bytestring IO?
16:26:28 <wli> michaelcdever: Also, how many directories?
16:26:29 <dons> you might want to use the bytestring globbing lib?
16:26:38 <ferret_0567> how does Haskell compare to Lua?
16:26:50 <michaelcdever> dons: nah, this is building a tree index of all folders in linux under "/"
16:26:51 <ehird> Blows it outta the water!
16:27:08 <ferret_0567> ehird: in what ways?
16:27:20 <michaelcdever> wli: just normal linux distro
16:27:28 <ehird> ferret_0567: All of them! :-)
16:27:33 <wli> michaelcdever: Sort of like find / -type d
16:27:43 <ferret_0567> ehird: how do you know?
16:27:44 <michaelcdever> eh, dunno hang on :D
16:27:48 <ferret_0567> ehird: have you used both?
16:27:51 <ehird> ferret_0567: Yes.
16:28:04 <ferret_0567> ehird: for a long time?
16:28:05 <geezusfreeek> ferret_0567, what do you like about lua?
16:28:13 <ferret_0567> geezusfreeek: I have not tried Lua
16:28:14 <ehird> ferret_0567: No.
16:28:20 <geezusfreeek> ah
16:28:29 <ferret_0567> geezusfreeek: nor Haskell
16:28:42 <michaelcdever> wli: yeah just like that, mine's a bit slower though
16:28:44 <wli> michaelcdever: Different filesystem formats have different performance characteristics for large directory operations; OTOH since this is a naturally-occurring directory structure vs. one an app constructs for faux database indexing, it's another matter.
16:28:49 <lament> it's hard to find too many similarities between haskell an lua
16:28:53 <geezusfreeek> having used both, i prefer haskell. they are basically complete opposites
16:29:09 <geezusfreeek> both are able to create abstractions fairly easily
16:29:18 <geezusfreeek> but in completely different ways
16:29:57 * ferret_0567 wonders when XMonad will switch to XCB bindings as Awesome WM already has (it uses Lua)
16:30:01 <geezusfreeek> my experiences with lua are limited though, so i can't really be fair to it
16:30:26 <michaelcdever> i plan on just using it naturally, build the tree at execution and use it from there, not sure how im going to deal with folder creates/deletes though... meh, i'll deal with that when i get to it
16:30:27 <dons> why would we switch?
16:30:38 <erikc> Lua is basically Scheme with imperative syntax and a focus on portability and easy binding to C
16:30:46 <ferret_0567> dons: switch to XCB?
16:30:47 <dons> the xcb bindings add all sorts of curious new dependencies.
16:30:49 <dons> yeah.
16:30:57 <ferret_0567> dons: umm...it's less insane
16:31:22 <ferret_0567> dons: maybe it's faster, as well
16:31:23 <dons> but we'd have to rewrite everything to a new API, one that's less widely available. so given xmonad's very stable now, i think its hard to sell the benefits
16:31:25 <lament> erikc: scheme with dictionaries instead of lists
16:31:35 <dons> that's a hard one to say: is xmonad ever a perf. bottleneck?
16:31:39 <ferret_0567> dons: ok then
16:31:41 <ferret_0567> dons: no
16:31:41 <dons> (we looked a lot into XCB a year ago)
16:31:56 <ferret_0567> dons: what where the benefits of XCB?
16:31:56 <erikc> lament: yup, and less parentheses so it doesnt scare away people
16:32:17 <erikc> i think the lack of parentheses is the important factor in lua's success :)
16:32:31 <dons> its a smaller code base, we'd be able to use haskell threads (async/thread safe)
16:32:38 <dons> erikc: haha
16:32:43 <dons> like haskell's ? :)
16:33:26 <michaelcdever> dons: actualy another quick question, ive build up a recursive search, losely based on the one in RWH, but more indepth, it searchs the files contents too, using Data.ByteString.Lazy.Char8, now if i run it just from ghci, it runs fine, but if i run it within my gtk2hs app, it crashes with a too many files open error? any ideas?
16:33:33 <ferret_0567> dons: can I add little titlebars to xmonad's windows?
16:33:49 <michaelcdever> i think it might be to do with gtk2hs's memory management facilities
16:34:04 * michaelcdever ponders would forkIO solve my problems there too
16:35:04 <wli> Relying on GC to close files often leaks.
16:35:10 <alsonk> @seen igloo
16:35:10 <lambdabot> igloo is in #haskell, #ghc and #darcs. I don't know when igloo last spoke.
16:35:17 <dons> michaelcdever: could be GC not running often enough to finalize the handles?
16:35:18 <wli> Leaks fd's, not just memory.
16:35:22 <dons> try closing the resourcces explicitly.
16:36:01 <michaelcdever> i was looking for a way to do it in the Data.....Char8 library, but i couldn't come up with anything
16:36:08 <michaelcdever> and whats GC now?
16:36:10 <michaelcdever> ahh
16:36:14 <michaelcdever> stupid question
16:37:23 <michaelcdever> but yeah, theres no close file function for ..Char8
16:39:17 <michaelcdever> is there a way to ignore quit/join messages here?
16:39:24 <lament> yes.
16:40:08 <dolio> My client has a setting for that.
16:41:57 <hackage> Uploaded to hackage: happs-tutorial 0.7
16:42:02 <mstr> "main = getLine >>= \line ->" ...
16:42:12 <mstr> what does the "->" do?
16:42:41 <byorgey> oooh, happs-tutorial 0.7!
16:42:42 <mstr> next line "putStrLn line >>"
16:42:51 <byorgey> wonder if that's using the new happstack stuff?
16:42:56 <mstr> is it just a lambda expression?
16:43:06 <byorgey> mstr: yes, \line -> ...  is a lambda-expression
16:43:07 <ddarius> mstr: It's part of the syntax of a lambda expression.
16:43:24 <mgsloan> lambdas don't need to be inside parens
16:43:25 <ddarius> -> simply separates the arguments from the body
16:43:48 <mstr> one more thing makes sense again. thx
16:43:51 <mstr> :D
16:44:05 <yitz> mgsloan: sometimes they do
16:44:13 <mgsloan> well, yeah
16:44:14 <redditbot> happs tutorials 0.7: now running on happstack
16:44:38 <mgsloan> I mean that you tend to see them inside parenthesis, so I can see how it would be wierd to see a naked lambda ;)
16:45:04 <yitz> mgsloan: mine are usually either after $ or in parens
16:45:12 <mgsloan> yeah
16:45:34 <Saizan> naked lambdas are NSFW
16:45:41 <byorgey> ah, did I call it or what =)
16:45:44 <mgsloan> lambdas are like women.. in they undress in the right context
16:45:52 <yitz> NSFW?
16:45:52 <mgsloan> ^that
16:46:19 <mstr> when writing a tutorial, clearer syntax could be nice :P http://pastebin.com/m6b76773c
16:46:21 <lpsmith> Lambda Monads?   Sounds like continuations to me...\
16:46:43 <michaelcdever> :r
16:46:51 <Gracenotes> lpsmith: where are your monads?!
16:47:38 <lament> @quote zipper
16:47:38 <lambdabot> lament says: Bullies at school used to tease little Huet: "Hey fool, your zipper's undone and the monad's sticking out!"
16:47:48 <yitz> @vixen how are lambdas like women?
16:47:49 <lambdabot> however you want
16:47:59 <geezusfreeek> lol
16:48:38 <lpsmith> gracenote:  why, whatever do you mean? :-)
16:48:50 <Gracenotes> is it because there are instances for "Show" for a lambda?
16:48:53 <Gracenotes> *no
16:49:09 <Gracenotes> > \a -> a
16:49:11 <lambdabot>       Overlapping instances for Show (t -> t)
16:49:11 <lambdabot>        arising from a use of `s...
16:49:39 <yitz> Gracenotes: no wonder they teased little Huet about that then
16:55:26 <michaelcdever> :r
17:02:49 <lepassive> Can anyone provide me with the sources of Write Yourself a Scheme in 48 Hours ?
17:07:30 <mriou> lepassive: they're at the end of the pdf iirc
17:12:32 <lepassive> mriou, Thanks alot I was reading it online
17:17:27 <michaelcdever> anyone know if theres a way of setting the width of a HBox in gtk2hs?
17:18:05 <dcoutts> michaelcdever: typically you don't do that, it sizes to fit it's children and parents
17:18:22 <michaelcdever> i know, but i cant get a combination that works for me :9
17:21:09 <dsrogers> what is wrong with my syntax?
17:21:10 <dsrogers> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1251#a1251
17:21:38 <byorgey> dsrogers: no 'else' for the 'if'
17:21:47 <dsrogers> ah.
17:21:49 <byorgey> dsrogers: try using 'when' instead of 'if'
17:21:54 <dsrogers> ok
17:22:05 <byorgey> when p m  is the same as   if p then m else return ()
17:28:18 <dsrogers> thanks.
17:28:40 <dsrogers> how do I tell ghci to kills the currently running program?
17:28:51 <yitz> C
17:28:53 <yitz> ^C
17:28:55 <dsrogers> ^C will kill one thread, but it leaves other threads running
17:29:03 <yitz> ohhh threads
17:30:12 <Axman6> no happy. some cockhead in another chan lowered my karma from +5 to -13
17:30:23 <mightybyte> What's the latest version of base?
17:30:40 <yitz> @karma Axman6
17:30:41 <lambdabot> Axman6 has a karma of -25
17:30:46 <mightybyte> My cabal says it's 3.0.1.0
17:30:53 <Axman6> urgh
17:31:00 <pumpkin_> ohai Axman6
17:31:01 <dcoutts> mightybyte: wow, many years into the future! :-)
17:31:12 <pumpkin_> Axman6: how did your karma go down so far?
17:31:21 <mightybyte> dcoutts: Seriously?
17:31:25 <drhodes> > (fromMaybe "blackhole" (Just "some matter")) ++ " escapes!"
17:31:26 <lambdabot>   "some matter escapes!"
17:31:30 <dcoutts> mightybyte: ahh, your version of base :-) not of cabal
17:31:33 <Axman6> because some dickhead is msging lambdabot with @karma- Axman6
17:31:42 <pumpkin_> Axman6: aw, why?
17:31:50 <Axman6> because he's a dickhead
17:31:51 <mightybyte> dcoutts: Yeah.  But syb wants base >= 4.0
17:31:59 <dcoutts> mightybyte: base 3 includes syb
17:32:04 <Axman6> @karma
17:32:06 <lambdabot> You have a karma of -66
17:32:10 <pumpkin_> wow
17:32:12 <pumpkin_> who is this?
17:32:15 <drhodes> @karma+ Axman6
17:32:16 <lambdabot> Axman6's karma raised to -69.
17:32:36 <yitz> this is abuse. an op should kick that person.
17:32:37 <Heffalump> @karma+ Axman6
17:32:38 <lambdabot> Axman6's karma raised to -73.
17:32:42 <Heffalump> how do we know who it is?
17:32:44 <pumpkin_> o.O
17:32:57 <pumpkin_> Axman6 could tell us
17:33:06 <yitz> ping Cale
17:33:10 <Axman6> it's Necrosan
17:33:14 <Heffalump> why, does lambdabot inform you?
17:33:35 <pumpkin_> Heffalump: presumably they had a conversation that resulted in this behavior
17:33:42 <yitz> actually, if it is via msgs, then kicking is nothing more than punishment
17:33:50 <pumpkin_> @karma+ Axman6
17:33:54 <Heffalump> yitz: yeah, though it still seems like it might be an idea.
17:33:55 <lambdabot> Axman6's karma raised to -99.
17:33:59 <pumpkin_> wow, this is ridiculous
17:34:07 <Heffalump> thoughts?
17:34:08 <Axman6> i kicked him from #macosx for abusing lambdabot
17:34:14 <yitz> it's obviously a script
17:34:40 <shapr> Wow, this guy is sad.
17:34:41 <pumpkin_> this is what happens when you bring haskell's good intentions to traditional IRC channels
17:34:44 <Heffalump> oh, wait, he's not on here
17:34:45 <shapr> Amusing, but sad :-)
17:34:49 <sbahra> Why is that a big deal?
17:34:52 <yitz> there should be a way for lambdabot to ban someone from msging it
17:34:52 <Heffalump> so no kicking possible anyway
17:34:56 <sbahra> What does this "karma" mean?
17:35:02 <Heffalump> sbahra: very little
17:35:08 <pumpkin_> sbahra: if your karma goes low enough, you get struck by lightning
17:35:10 <shapr> sbahra: Nothing really, it's just a fun toy.
17:35:15 <Heffalump> but it's still pretty rude/insulting to do that
17:35:23 <yitz> have to ask Cale if that's possible
17:35:29 * sbahra doesn't find it rude/insulting 
17:35:32 <shapr> Anyone who focusses on reducing the karma of another person really desperately needs to get a life.
17:35:35 <yitz> @karma Axman6
17:35:36 <lambdabot> Axman6 has a karma of -89
17:35:36 <sbahra> @karma- sbahra
17:35:37 <lambdabot> You can't change your own karma, silly.
17:35:42 <bartek> I just want to make sure I understand everything here. In this example:  http://dpaste.com/117973/ .. no matter what list of values I pass, the result is 0. Is this because on the final iteration of the recursive function it does not get a proper list that it can grab head/tail from and it just defaults to the 0? (Since the last iteration of [1,2,3] would be: timesList [3]) .. or am I missing something?
17:35:53 <yitz> @karma- sbahra
17:35:54 <lambdabot> sbahra's karma lowered to -1.
17:36:01 <sbahra> @karma- yitz
17:36:02 <lambdabot> yitz's karma lowered to -1.
17:36:09 <yitz> thanks
17:36:11 <pumpkin_> @karma
17:36:11 <lambdabot> You have a karma of 0
17:36:15 <shapr> @karma
17:36:16 <lambdabot> You have a karma of 2
17:36:18 <shapr> yay!
17:36:21 <shapr> Anyway....
17:36:23 <pumpkin_> I used to have a better karma
17:36:27 <pumpkin_> but lambdabot is forgetful :(
17:36:40 <Badger> @karma+ pumpkin
17:36:40 <lambdabot> pumpkin's karma raised to 4.
17:36:45 <pumpkin_> :o
17:37:03 <yitz> sbahra: please put it back
17:37:08 <drhodes> karma karma karma karma, karmeleon
17:37:23 <yitz> @karma+ sbahra
17:37:24 <shapr> Anyway....
17:37:24 <lambdabot> sbahra's karma raised to 0.
17:37:35 <shapr> Is hpaste.org working correctly for everyone now?
17:37:49 <Badger> @karma+ yitz
17:37:49 <lambdabot> yitz's karma raised to 0.
17:37:55 <sbahra> http://hpaste.org/fastcgi/hpaste.fcgi/save
17:37:56 <yitz> thanks Badger
17:37:58 <jeffz`> shapr, old pastes are gone?
17:38:07 <sbahra> 500 Internal Server Error
17:38:07 <sbahra> 58030 5: Unable to close due to unfinalised statements
17:38:22 <kryptiskt> bartek: no the last iter is timesList []
17:38:37 <sbahra> shapr, is what I get when I try to paste something
17:38:40 <davidL> @karma java
17:38:41 <lambdabot> java has a karma of -3
17:38:49 <yitz> heh
17:39:07 <kryptiskt> x:xs matches x:[] and calls timesList []
17:39:12 <bartek> kryptiskt: doh, sorry that's what I mean .. typo, but ok.. just making sure I understand it :)
17:39:16 <bartek> thanks!
17:39:38 <Badger> @karma haskell
17:39:40 <lambdabot> haskell has a karma of 48
17:39:45 <Badger> hah
17:39:46 <yitz> bartek: you probably wanted 1 instead of 0
17:39:47 <dolio> @karma
17:39:48 <lambdabot> You have a karma of 0
17:39:51 <Axman6> @karma
17:39:52 <lambdabot> You have a karma of -89
17:40:00 <dolio> Wow.
17:40:06 <michaelcdever> whats karma?
17:40:06 <shapr> jeffz`: Well, yeah..
17:40:08 <Axman6> yeah
17:40:08 <yitz> seems to have stabilized
17:40:15 <michaelcdever> @karma
17:40:16 <lambdabot> You have a karma of 0
17:40:19 <sbahra> Axman6, you'll survive
17:40:20 <Axman6> he's telling me it's been disabled
17:40:22 <bartek> yitz: heh, yes I do .. it was just more so I can understand what's going on (Reading RWH right now)
17:40:25 <sbahra> Axman6, just be strong
17:40:29 <Axman6> heh
17:40:39 <mdmkolbe> @karma- haskell
17:40:40 <Axman6> i worked hard to get that +5 >_<
17:40:41 <lambdabot> haskell's karma lowered to 47.
17:40:45 * mdmkolbe makes haskell prime
17:40:49 * sbahra only hopes Axman6 is not Hindu 
17:40:57 <dolio> Axman6 is going to be reincarnated as a Cobol programmer.
17:40:58 <shapr> sbahra: You have a point.
17:41:00 <sbahra> mdmkolbe, haha
17:41:09 <yitz> kick mdmkolbe
17:41:31 <yitz> of course, no censorship here
17:41:34 <byorgey> mdmkolbe: what's wrong with 53?  ;)
17:41:47 <Heffalump> byorgey: 5 times more effort
17:41:58 <hackage> Uploaded to hackage: happs-tutorial 0.7.1
17:42:27 <yitz> @faq can Haskell keep its karma above 50?
17:42:28 <lambdabot> The answer is: Yes! Haskell can do that.
17:43:12 <yitz> @karma haskell
17:43:13 <lambdabot> haskell has a karma of 47
17:43:20 <michaelcdever> dcoutts: could i use Adjustment to set the size of a scrolled window?
17:43:22 <mdmkolbe> byorgey: also 47 has other cultural references ;-)
17:44:08 <bartek> I'm sorry, but can someone explain to me what "Just" is ?
17:44:25 <mdmkolbe> @info Maybe
17:44:25 <lambdabot> Maybe
17:44:31 <yitz> mdmkolbe: yes, of course. it's the smallest non-square integer that has a square root in the 10-adic numbers
17:44:32 <Badger> @src Maybe
17:44:32 <lambdabot> data Maybe a = Nothing | Just a
17:44:59 <bartek> That's exactly the line from the book (reversed) and I have no idea what's going on, it just spits it out at the reader
17:45:24 <byorgey> mdmkolbe: oh, it does?
17:45:37 <bartek> Seems to be some sort of value constructor?
17:45:45 <yitz> bartek: right
17:45:54 <mdmkolbe> boyscared: see "Rambaldi"
17:45:57 <Axman6> bartek: it's a way of programming failure into functions.
17:46:06 <bartek> I guess I'll just keep reading till the book explains it .. :)
17:46:16 <Axman6> if you get a result, you get Just result back. if it dails, you get Nothing
17:46:21 <mdmkolbe> s/ boyscared/ byorgey/
17:46:26 <bartek> Axman6: hmm, ok
17:46:28 <Axman6> so, 'Just result' or 'Nothing'
17:46:47 <yitz> @type lookup
17:46:49 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:47:26 <yitz> > lookup 5 [(5,"foo"), (7,"bar")]
17:47:28 <lambdabot>   Just "foo"
17:47:33 <yitz> > lookup 2 [(5,"foo"), (7,"bar")]
17:47:35 <lambdabot>   Nothing
17:47:36 <byorgey> mdmkolbe: ah, I see =)
17:48:12 <Gracenotes> mm.. parsec really is quite neat
17:48:15 <Heffalump> @karma+ Axman6
17:48:16 <lambdabot> Axman6's karma raised to -70.
17:48:18 <mdmkolbe> bartek: in C, they might program lookup to return something like -1 if nothing is found, but that means we can never have a lookup finds the results -1.  In haskell we distinguish the two.  Nothing means nothing was found "Just foo" means "foo" was found.  (There are many extrapolations of this idea)
17:48:22 <sbahra> mdmkolbe, 47 virgins?
17:48:32 <Gracenotes> @karma C
17:48:34 <lambdabot> C has a karma of 0
17:48:44 <sbahra> No, it's 72 virgins apparently.
17:48:48 <yitz> @karma php
17:48:52 <lambdabot> php has a karma of 0
17:49:01 <Axman6> @karma C++
17:49:02 <lambdabot> C++ has a karma of -3
17:49:24 <Gracenotes> Forsooth, C++ is an interesting language
17:49:25 <Gracenotes> @karma C
17:49:26 <lambdabot> C has a karma of 0
17:49:26 <bartek> mdmkolbe: Thanks! That helps clear it up slightly. But what I don't get (and maybe I will eventually as I read more) is we can return Nothing (for nothing found) but why Just foo, why not just return foo?
17:49:31 <Gracenotes> interesante.
17:50:07 <Axman6> bartek: what would the type of the function be then?
17:50:20 <bartek> riiiiiiight
17:50:26 <bartek> ok, ok .. it's clearer now :)
17:50:29 <Axman6> Eq a => a [(a,b)] -> (Nothing|a)?
17:50:38 <eric_j> because you can have Just Nothing
17:51:05 <mdmkolbe> bartek: because "foo" will be of some type (say Int), but Nothing doesn't belong to the type Int.  So we have a new type that is Maybe wrapped around Int called "Maybe Int".  But now it can't return a plain Int because it is "Maybe Int".  So we have to say "Just 4" or what ever.
17:51:39 <JN_> I'm Just 4
17:52:10 <bartek> heh
17:52:16 <bartek> mdmkolbe: Thank you for the explanation
17:52:17 <Badger> > Just Nothing
17:52:19 <lambdabot>   Just Nothing
17:52:23 <Badger> awesome
17:52:30 <Axman6> > Just (Just Nothing)
17:52:32 <lambdabot>   Just (Just Nothing)
17:52:33 <mdmkolbe> @type Just Nothing
17:52:35 <lambdabot> forall a. Maybe (Maybe a)
17:52:39 <sbahra> bartek, "algebraic data type".
17:52:41 <Axman6> > Just (Just (Just Nothing))
17:52:43 <lambdabot>   Just (Just (Just Nothing))
17:52:53 <Badger> :t Just (Just (Just Nothing))
17:52:57 <lambdabot> forall a. Maybe (Maybe (Maybe (Maybe a)))
17:52:58 <sbahra> :t Just "Test"
17:53:03 <lambdabot> Maybe [Char]
17:53:20 <athos> maybe [] id $ Just (Just (Just Nothing))
17:53:23 <mdmkolbe> :t Just (Just 'x')
17:53:25 <lambdabot> Maybe (Maybe Char)
17:53:31 <athos> > maybe [] id $ Just (Just (Just Nothing))
17:53:32 <sbahra> :t Nothing :: Maybe [Char]
17:53:33 <lambdabot>   Couldn't match expected type `[a]'
17:53:34 <lambdabot> Maybe [Char]
17:53:51 <athos> > maybe [] id $ Just (Just (Just []))
17:53:52 <lambdabot>   Couldn't match expected type `[a]'
17:53:56 <athos> eh
17:53:59 <bartek> :t Nothing "bike" :: Maybe [Char]
17:54:01 <lambdabot>     Couldn't match expected type `[Char] -> Maybe [Char]'
17:54:01 <lambdabot>            against inferred type `Maybe a'
17:54:06 <bartek> heh
17:54:06 <sbahra> :i Maybe
17:54:11 <sbahra> @info Maybe
17:54:11 <lambdabot> Maybe
17:54:14 <sbahra> @src Maybe
17:54:14 <lambdabot> data Maybe a = Nothing | Just a
17:54:15 <athos> , src ''Maybe
17:54:18 <lunabot>  data Maybe a = Nothing | Just a
17:54:20 <mdmkolbe> :t Just "bike" :: Maybe [Char]
17:54:21 <lambdabot> Maybe [Char]
17:54:24 <sbahra> bartek, are you familiar with algebraic data types or no?
17:54:41 <bartek> ugh I'm too tired, I meant to type Just not Nothing ..
17:54:46 <mdmkolbe> @karma Axman6
17:54:46 <lambdabot> Axman6 has a karma of 1
17:54:54 <Badger> so when is a word a String rather than a [Char]?
17:54:58 <bartek> sbahra: Very little, just from what I read in real world haskell. I need to look over that chapter again
17:55:00 <Badger> if at all
17:55:02 <sbahra> Badger, same thing
17:55:04 <athos> Badger: type String = [Char]
17:55:05 <Badger> oh
17:55:05 <mdmkolbe> Badger: they are identical
17:55:10 <Badger> huh.
17:55:12 <mdmkolbe> @src String
17:55:13 <lambdabot> type String = [Char]
17:55:13 <bartek> infact, I am going to read it now since it's fresh in my mind
17:55:24 <sbahra> bartek, are you new to functional programming by any chance?
17:55:27 <mdmkolbe> Badger: they are just synonyms for each other
17:55:43 <bartek> sbahra: of course :)
17:55:58 <bartek> (if it wasn't obvious from my silly questions)
17:55:59 <Axman6> :t "hello" :: String
17:56:01 <lambdabot> String
17:56:03 <sbahra> bartek, I would then suggest you check out "Haskell: The Craft of Functional Programming" by Simon Thompson
17:56:06 <Axman6> :t "hello" :: [Char]
17:56:08 <lambdabot> [Char]
17:56:11 <Axman6> :t "hello"
17:56:13 <lambdabot> [Char]
17:56:15 <athos> @src String
17:56:15 <lambdabot> type String = [Char]
17:56:29 <sbahra> bartek, I think that's a better introduction to FP than RWH (which is a better introduction to Haskell).
17:56:43 <bartek> sbahra: Thanks, I bookmarked it on Amazon
17:57:09 <bartek> So far I think I have a decent understanding of everything I've read, but any better resource is ok with me
17:57:15 <Badger> @src [Char]
17:57:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:57:21 <Badger> @src Char
17:57:22 <lambdabot> data Char = C# Char#
17:57:37 <Badger> oh no, hashes!
17:57:52 <sbahra> @let wT = [True, False]
17:57:53 <yitz> @src (,)
17:57:53 <lambdabot>  Defined.
17:57:54 <lambdabot> Source not found. There are some things that I just don't know.
17:57:57 <sbahra> @src wT
17:57:58 <lambdabot> Source not found. My brain just exploded
17:58:08 <Axman6> @set -XMagicHash
17:58:09 <lambdabot>   Parse error
17:58:29 <Badger> @src Int
17:58:30 <lambdabot> data Int = I# Int#
17:58:32 <Badger> @src Integer
17:58:33 <lambdabot> data Integer = S# Int#
17:58:33 <lambdabot>              | J# Int# ByteArray#
17:58:50 <sbahra> Axman6, what does this do?
17:59:10 <Axman6> sbahra: the magic hash thing?
17:59:13 <sbahra> yes
17:59:21 <Axman6> lets you use things like 1# to have unlifted integers
17:59:25 <Axman6> or, ints
17:59:31 <sbahra> Ok
17:59:55 <Axman6> quite handy for writing fast code when ghc doesn't compile quite as optimally
18:01:16 <Axman6> lets you match on things like case int of I# n -> I# (n *# n) to square integers. there's better exampler
18:01:21 <Axman6> s/r/s
18:02:12 <sbahra> Axman6, ah
18:02:27 <sbahra> Axman6, cool
18:03:38 <mdmkolbe> also Int# is strict since it is unboxed where Int is not right?  or have I got that mixed up?
18:04:25 <dino-> I've been working on some code that may produce errors. Something I'm confused about. I see typeclass Error with methods noMsg and strMsg, what is it that ever calls noMsg? MonadError's throwError always takes something (Error e) doesn't it?
18:05:05 <yitz> dino-: yes. noMsg and strMsg are methods of Error
18:05:36 <BMeph> dino-: Imagine using Maybe as a MonadError type. :)
18:05:59 <Gracenotes> how safe is killThread? e.g., if a thread is modifying an IORef or reading a stream, could the data get corrupted?
18:06:10 <mdmkolbe> :t throwError noMsg
18:06:12 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m, Error a) => m a1
18:06:25 <dino-> BMeph: I actually instanced that to try it out and made noMsg = Nothing
18:06:26 <dino-> hm
18:06:34 <mdmkolbe> > throwError noMsg :: Maybe Int
18:06:36 <lambdabot>       No instance for (MonadError a Maybe)
18:06:36 <lambdabot>        arising from a use of `thro...
18:06:40 <yitz> dino-: personally I find the Error e constraint annoying
18:06:55 <mdmkolbe> yitz: as do many
18:06:58 <dino-> But when I throwError (Just 42), the noMsg isn't getting used.
18:07:22 <Gracenotes> make it an Either () Result? kinda hacky, though.
18:08:09 <mdmkolbe> dino-: it allows you to write code that is agnostic about how errors are represented.  You just use noMsg and strMsg.
18:08:16 <yitz> dino-: for every type that is meant to be used as an exception, I add | FooMsg String | FooNoMsg at the end and use those to create Error instance. Then I never use them.
18:08:41 <mdmkolbe> dino-: It also may have to do with having a way for monadic pattern matches to throw errors into the monad instead of just bombing out
18:08:50 <pistacio> hi
18:08:58 <mdmkolbe> > do { 5 <- return 4; return 3 } :: Maybe Int
18:09:00 <lambdabot>   Nothing
18:09:02 <dino-> hm ok
18:10:17 <mdmkolbe> dino-: though the whole monadic pattern match failing problem is a big mess (e.g. it forces "fail" to be a Monad function even though it shouldn't be there and you as a user should never use it)
18:10:21 <yitz> > do { 5 <- return 4; return 3 } :: Either String Int
18:10:23 <lambdabot>   Left "Pattern match failure in do expression at /tmp/8391107372244989167:71...
18:10:48 <mdmkolbe> > strMsg "foo" :: Maybe Int
18:10:50 <lambdabot>       No instance for (Error (Maybe Int))
18:10:50 <lambdabot>        arising from a use of `strMs...
18:11:05 <mdmkolbe> :t strMsg "foo"
18:11:07 <lambdabot> forall a. (Error a) => a
18:11:17 <Gracenotes> @src Error
18:11:17 <yitz> > noMsg undefined :: Either String Int
18:11:18 <lambdabot> class Error a where
18:11:18 <lambdabot>     noMsg  :: a
18:11:18 <lambdabot>     strMsg :: String -> a
18:11:18 <dino-> ^ because String is instanced into Error
18:11:19 <lambdabot>       No instance for (Error (a -> Either String Int))
18:11:19 <lambdabot>        arising from a ...
18:11:40 <dino-> So some of this is because fail exists in typeclass Monad?
18:11:48 <yitz> > noMsg (undefined :: Either String Int)
18:11:50 <lambdabot>       No instance for (Error (Either String Int -> a))
18:11:50 <lambdabot>        arising from a ...
18:12:00 <yitz> @type noMsg
18:12:02 <lambdabot> forall a. (Error a) => a
18:12:09 <mdmkolbe> dino-: possibly
18:12:16 <yitz> > noMsg :: Either String Int
18:12:18 <lambdabot>       No instance for (Error (Either String Int))
18:12:18 <lambdabot>        arising from a use o...
18:12:26 <Gracenotes> @instances Error
18:12:28 <lambdabot> IOError, String
18:12:40 <mdmkolbe> > noMsg :: String
18:12:42 <lambdabot>   ""
18:12:45 <pistacio> I just got a "thread blocked indefinetely" exception while using multiple forkIO threads... does anyone know what it's supposed to mean?
18:12:46 <yitz> > noMsg :: String
18:12:48 <lambdabot>   ""
18:13:24 <mdmkolbe> oh yeah, Error is the class of things that can be thrown by ErrorMonad not the ErrorMonad itself
18:13:29 * mdmkolbe always gets bit by that one
18:13:35 <yitz> pistacio: probably a thread was waiting on an MVar that no other live thread had a reference to
18:14:24 <dino-> Thank you for discussing.
18:14:47 <pistacio> yitz: thanks, I'm using QSems but it's probably the same
18:16:09 <dino-> This all came from repeatedly needing something evaluating to (Maybe a) to throwError if it's Nothing. So:
18:16:12 <dino-> This all came from repeatedly needing something evaluating to (Maybe a) to throwError if it's Nothing. So: 21:12 < lambdabot> forall a. (Error a) => a
18:16:16 <dino-> bah
18:16:22 <dino-> maybeError err mval = maybe (throwError err) return mval
18:16:32 <dino-> maybeError :: (MonadError e m) => e -> Maybe a -> m a
18:17:04 <shapr> hi dino- !
18:17:26 <dino-> A practical case is Data.Map.lookup, but it seems to not buy you much. You still have to babysit the e type there each time you write something.
18:17:33 <dino-> shapr: hey
18:17:52 <shapr> kryptiskt: är du kryptiskt?
18:18:26 <kryptiskt> shapr: it says so, so I guess I am
18:19:04 <kryptiskt> shapr: men jag kan svenska ocks, frsts.
18:19:10 <shapr> kryptiskt: That was punnily self referential.
18:19:23 <shapr> kryptiskt: funny, I don't understand Swedish! oh no!
18:35:36 <gwern> holy cow. these memory profiling options are something else
18:35:36 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
18:35:50 <gwern> 695 *MB* for -hc output?
18:35:54 <gwern> @messages
18:35:54 <lambdabot> byorgey said 5h 25m 52s ago: fixed my xmonad.hs on the wiki, thanks for the heads-up
18:36:14 <mae> gwern: how is that going by the way? with the gitit memory problems?
18:36:20 <gwern> mae: seems to be fixed actually
18:36:24 <mae> new release?
18:36:28 <mae> we were checking it out
18:36:37 <mae> there is something in the diff library that eats up lots of memory sometiems
18:36:40 <gwern> I'm benchmarking gitit with ab and wget -r, and memory use is stable at 11%
18:36:41 <mae> sometimes *
18:36:47 <gio123> @messages
18:36:47 <lambdabot> You don't have any new messages.
18:36:48 <gwern> mae: yeah, john fixed that today
18:37:06 <mae> is he going to release it soon?
18:37:10 <gwern> mae: I suspect the 11% thing may be the old 'haskell binaries don't give memory back to the OS' thing
18:37:40 <gwern> (since it was at 1% when the wget started)
18:41:58 <hackage> Uploaded to hackage: llvm 0.6.3.0
18:50:40 <gio123> @seen ski_
18:50:41 <lambdabot> ski_ is in ##logic, #haskell, #haskell.hr and #haskell-in-depth. I last heard ski_ speak 11h 47m 41s ago.
18:54:09 <mdmkolbe> @seen Roshan
18:54:10 <lambdabot> I saw Roshan leaving #haskell 12d 4h 57m 50s ago, and .
18:54:32 <mdmkolbe> hmm, is ", and ." a bug in lambdabot?
18:54:53 <dino-> Why. certainly, not!
18:55:21 <dino-> I, still. love you lambdabot
18:58:36 <kerlo> Why did she say that?
18:58:43 <kerlo> @seen kerlo
18:58:43 <lambdabot> You are in #haskell. I last heard you speak just now.
18:58:55 <kerlo> @seen dino-
18:58:55 <lambdabot> dino- is in #haskell-blah, #haskell and #darcs. I last heard dino- speak 3m 34s ago.
18:59:37 <mdmkolbe> @seen Roshan
18:59:37 <kerlo> @seen pistacio
18:59:38 <lambdabot> I saw Roshan leaving #haskell 12d 5h 3m 18s ago, and .
18:59:38 <lambdabot> I saw pistacio leaving #haskell 10m 9s ago, and .
19:01:10 <mdmkolbe> @seen Eiler
19:01:11 <lambdabot> Eiler is in #haskell-overflow. I last heard Eiler speak 3h 51m 56s ago.
19:07:31 <chessguy_> @bot
19:07:31 <lunabot>  :)
19:07:32 <lambdabot> :)
19:10:50 <Gracenotes> hm.. in Parsec, how would you get characters until either a space or the end of input occurs?
19:12:05 <sbahra> @seen shapr
19:12:05 <lambdabot> shapr is in #haskell-blah, #haskell and #haskell-in-depth. I last heard shapr speak 42m 18s ago.
19:12:13 <Gracenotes> "anyChar `manyTill` space" doesn't really work, in case it actually is EOF
19:14:06 <dino-> Maybe the space could be space or EOF
19:14:30 <dino-> <- shaky on the parsec though
19:15:27 <Gracenotes> oh, yes... I see the problem. space <|> eof won't work because the first is Char, the latter is (). Thanks :)
19:16:14 <dino-> Thanks! I told you how to break it.
19:16:20 <dino-> more
19:22:08 <Gracenotes> hm.. not working. *scourges the docs*
19:22:29 <Gracenotes> or just my reading of them :/ lemme see.
19:23:01 <pumpkin_> scourges? :o
19:23:04 <pumpkin_> sounds painful
19:23:09 <Gracenotes> there shall be no mercy
19:23:24 <fynn> Hi. Are people actually using Yi?
19:23:26 <chessguy> Gracenotes:  what are you trying to do?
19:24:02 <Axman6> fynn: some do
19:24:07 <Gracenotes> chessguy: scan for non-space characters
19:24:19 <Gracenotes> either until a space, or the end of input
19:24:19 <chessguy> Gracenotes: with parsec?
19:24:23 <Gracenotes> yep.
19:24:29 <Gracenotes> [^ ] in regextalk
19:24:45 <fynn> Axman6: yeah, not too many, it seems :)
19:24:54 <Gracenotes> pumpkin_: I probably did mean scour. But scourge works too, in a sadistic sense.
19:24:56 <fynn> even Haskellers are using Emacs.
19:25:00 <pumpkin_> :P
19:25:09 <Draconx> Gracenotes, noneOf " " perhaps?
19:25:22 <SamB> fynn: what, is there some editor written in Haskell that we should be using ?
19:25:39 <Valodim> Yis
19:25:56 <fynn> SamB: google Yi
19:26:58 <SamB> fynn: you seem to have neglected the last 5 words in my question ;-P
19:27:08 <Gracenotes> Draconx: thanks, that works quite well. I think I skipped over it before for some odd reason.. grazie
19:27:29 <Gracenotes> many1 (noneOf " ")
19:27:45 <fynn> SamB: Yis, you should be using it ;)
19:27:52 <fynn> if you won't, who will
19:28:02 <sbahra> SamB, have you looked at hs-vim?
19:28:34 <SamB> I can't even keep straight how to QUIT vi, do you think I can use it ?
19:28:45 <sbahra> Well, it doesn't exist.
19:28:57 <sbahra> I thought maybe you were a vim user, I wanted to raise your hopes and then crush them.
19:29:02 <dino-> Draconx: Ah! And (noneOf " ") means literally [^ ]
19:29:04 <sbahra> SamB, what do you use?
19:29:10 <SamB> emacs
19:29:29 <Gracenotes> SamB: learning how to quit vi/m was the first step of my journey to become good at it :)
19:29:33 <chessguy> SamB:  i'm an emacs user myself, but every developer should know how to at least get around vi
19:29:54 <Gracenotes> right now I'm, er, at my second step, knowing only how to delete lines and go to insert mode :/
19:29:57 <SamB> chessguy: yeah, I started the tutorial once but I ... er ... got distracted, probably
19:29:58 <Gracenotes> but still :D
19:30:04 <chessguy> heh
19:30:20 <SamB> I think I got further than Gracenotes, but regressed ;-P
19:30:22 <fynn> why would anyone want to quit Vim
19:30:31 <fynn> that's crazy talk.
19:30:38 <sbahra> fynn, how do you justify the current paragraph you're in, in vim?
19:30:45 <chessguy> SamB:  stop downloading pr0n and learn your vi keybindings!
19:30:46 * wli is mostly used to SCSI/FC, which tends to be in smaller sizes than consumer hardware.
19:30:50 <sbahra> fynn, similar to GNU nano's ^J.
19:31:03 <fynn> sbahra: generally re-indent is ==
19:31:18 <Gracenotes> I still have a few problems with hjkl navigation
19:31:19 <fynn> specific modes can of course have their own bindings.
19:31:37 <dino-> Ages ago, when dinosaurs roamed, yada, I went through the built-in tutorial they had in vim as part of first steps. I wonder if it still has that.
19:31:42 <Taejo> Gracenotes: rip out your arrow keys for a few month, and you'll soon get used to it
19:31:49 <Gracenotes> heh
19:31:58 * sbahra navigates with arrows just fine
19:32:09 <fynn> sbahra: (re-indent is actually =, with == being "reindent current line", but you can also reindent arbitrary regions or the whole file. but, #vim )
19:32:19 <sbahra> fynn, ok. :)
19:32:34 <dino-> mm, vimtutor from the shell
19:32:44 <dino-> yay vim
19:32:47 * Gracenotes needs a "Learn Vim with Haskell in 24 Hours"
19:32:49 * wli usually uses 44,89!fmt -w70 etc.
19:33:03 * sbahra started using vim recently
19:33:11 <sbahra> I've been using pico and nano for years.
19:33:41 <Axman6> i haven't really found any benefits to Vim for me. TextMate does everything i want
19:33:59 <repnop> Axman6: how's textmate hold up when you need to ssh into the system :)
19:34:13 <Axman6> just sshfs it and you're fine ;)
19:34:14 <fynn> I still haven't really found the benefits of a hot model girlfriend. my wife does everything I want.
19:34:15 <pumpkin_> sshfs + textmate :P
19:34:16 <pumpkin_> yeah
19:34:25 <Axman6> but i do all my work on my MBP
19:34:29 * jeffwheeler really quite likes TextMate, but wants that extensibility in Yi
19:34:41 * wli isn't much of one for editor wars, but anyway... I tend to use nvi because vim has some behaviors different from traditional vi's that bother me and I can't be arsed to research how to change them. I'd kind of like something even more stripped-down and "traditionalist" than nvi, though.
19:34:48 <Axman6> what does yi offer anyway?
19:34:49 <fynn> jeffwheeler: so Yi isn't extensible?
19:35:02 <fynn> Axman6: supposedly, extensibility via Haskell.
19:35:03 <jeffwheeler> fynn: perhaps extensible is the wrong word.
19:35:18 <fynn> which on the face of it should be pretty cool, like Emacs with a decent language.
19:35:21 <jeffwheeler> fynn: I don't know; TextMate offers a lot of extensions in the plugins.
19:35:28 <jeffwheeler> fynn: that's very much it.
19:35:33 * wli started writing an ed(1) clone in Haskell at some point.
19:35:57 <SamB> fynn: I think they didn't write that part yet
19:36:01 <SamB> like most parts of Yi
19:36:06 <fynn> jeffwheeler: oh, so you meant extensions, not extensibility.
19:36:17 <fynn> SamB: ... the part that edits?
19:36:40 <SamB> fynn: the part where you can write extensions
19:36:44 * wli isn't sure there's a curses lib with sufficient functionality to do a tty/pty -based vi.
19:36:52 <wli> (In Haskell, that is.)
19:36:55 <fynn> SamB: without that, why use Yi at all
19:37:16 <SamB> fynn: that's part of why I'm still using Emacs
19:37:18 <jeffwheeler> fynn: you can do a lot of stuff in your Yi config file, like writing custom actions and stuff.
19:37:34 <jeffwheeler> fynn: but there are no "extension bundles" like in TextMate.
19:37:36 <fynn> jeffwheeler: that's nice, but you can do those things in both Vim and Emacs.
19:37:37 <SamB> the other part is that, even with that, it wouldn't do me much good unless people had actually written the extensions
19:37:49 <jeffwheeler> fynn: but not in Haskell. ;)
19:37:57 <fynn> SamB: they can't write them until they have an API
19:38:13 <fynn> jeffwheeler: how does that change anything if you can't extend it?
19:38:13 <jeffwheeler> Currently there's not much reason to implement extensions into Yi. All the functionality that people are interested in can be built right in.
19:38:32 <SamB> fynn: well, yes, well maybe I can help bring GHC to a state where it's practical if I keep complaining about bugs
19:38:37 <jeffwheeler> fynn: What do you mean? You can extend it via your config or by modifying the source. :)
19:38:39 <SamB> ;-P
19:39:06 <fynn> jeffwheeler: changing the source isn't a good way to extend an editor.
19:39:09 <SamB> jeffwheeler: building it right in isn't terribly convenient
19:39:22 <fynn> anyone doing that is essentially maintaining his own fork.
19:39:23 <SamB> it would be good if there were "hooks"
19:39:23 <jeffwheeler> fynn: As I said, there's no interest in writing non-core extensions because everything people have wanted to do has so far seemed applicable to the main core.
19:39:45 <jeffwheeler> People don't maintain their own fork: they contribute back the features they want. ;)
19:39:46 <SamB> jeffersonheard: oh, well, I guess that's just because they need the bit that edits ?
19:40:02 <jeffwheeler> SamB: I'm thoroughly confused about your complaint.
19:40:36 <fynn> SamB: yeah, anything that's broken in software is because people didn't _complain_ enough ;)
19:40:57 <SamB> jeffwheeler: well, basically I'm complaining that (a) there isn't a way to hook stuff to handle everything under the sun (and some that isn't)
19:41:14 <SamB> fynn: hey, I try to complain as helpfully as possible
19:41:15 <ddarius> Maybe Yi should be made into a Smalltalk-like system where you can edit anything at run-time.
19:41:19 <SamB> I even sometimes write patches
19:41:39 <Axman6> what's the latest yi version?
19:41:44 <Axman6> 0.1.0?
19:41:46 <jeffwheeler> SamB: the thing is, nobody has written hooks because nobody has needed features that couldn't be built into the core.
19:41:54 <jeffwheeler> Axman6: 0.5.3 is currently in development.
19:41:58 <hackage> Uploaded to hackage: BASIC 0.1.0.0
19:41:59 <SamB> but I still have to complain or they won't get committed. (I could commit GHC patches myself, but I'd feel silly because it'd come out under Neil's name)
19:41:59 <jeffwheeler> Axman6: 0.5.2 is on Hackage.
19:42:00 <Axman6> heh, fair enough
19:42:12 <chessguy> mmorrow:
19:42:15 <SamB> jeffwheeler: it's not so much "couldn't" as "shouldn't"
19:42:35 <jeffwheeler> SamB: sure
19:42:45 <SamB> you could build it all into the core
19:42:52 <jeffwheeler> SamB: and Emacs has. :)
19:42:57 <SamB> it hasn't
19:43:00 <jeffwheeler> (kidding, of course)
19:43:01 <SamB> most of that stuff is in elisp
19:43:20 <SamB> I guess some of the elisp is core, but not even most of what comes with Emacs is
19:43:32 <rwbarton> @hackage BASIC
19:43:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BASIC
19:43:33 <jeffwheeler> Anyways, nobody has been interested in writing hooks beyond the current functionality.
19:43:50 <SamB> like, really the Haskell support shouldn't be in the core
19:43:55 <jeffwheeler> The current functionality allows extending the keymap, etc.; really, there's just no package to share the extensions.
19:44:02 <jeffwheeler> SamB: wait, what?
19:44:14 <SamB> it should be in the standard distribution
19:44:36 <jeffwheeler> SamB: Heh, maybe someday. I think it's an odd thing to worry about for now, though.
19:45:02 <SamB> well, if you can't take it out of the core, what can you seriously expect to do outside the core ?
19:45:08 <fynn> ddarius: doesn't that stand at odds with Haskell being a static language?
19:45:15 <ddarius> fynn: No
19:45:20 <jeffwheeler> SamB: You can build it outside the core.
19:45:23 <SamB> fynn: yes and no, really
19:45:29 <SamB> jeffwheeler: okay.
19:45:36 <fynn> ddarius: how so? would seem to require that you restart the process on each change?
19:45:48 <SamB> fynn: not necessarily
19:45:49 <ddarius> fynn: Why?
19:45:58 <SamB> haven't you heard of dynamic loading ?
19:46:02 <jeffz`> fynn, that's like saying you have to restart C programs on each change.
19:46:15 <SamB> jeffz`: well, mostly you do!
19:46:18 <jeffwheeler> SamB: You can easily extend the modes list in your config and include your own Haskell mode based on the internal one. For now, there's no separation, though.
19:46:26 <jeffz`> SamB: nonsense, look at Emacs :P
19:46:45 <SamB> jeffz`: that's not nonsense
19:46:58 <SamB> the C code isn't the bit that you can change without restarting!
19:47:12 <SamB> or rather, it is the one bit that you can't change without restarting
19:47:14 <jeffwheeler> Yi currently has a feature to suspend and recompile with new settings while maintaining state.
19:47:20 <SamB> since it's rather smaller than the elisp portion
19:47:23 <jeffwheeler> It doesn't work perfectly, but it's a good start.
19:47:33 <fynn> ddarius, jeffz`, SamB: I thought you were talking about changes requiring recompilation
19:47:42 <SamB> well, actually irssi you don't have to restart it
19:47:51 <fynn> which afaik is the kind of changes you associate with tampering with a Smalltalk dynamic image.
19:47:52 <SamB> but it does need to be re-exec'd
19:48:17 <SamB> fynn: well, you don't have to statically link everything...
19:48:47 <SamB> with -package ghc, you can do a lot of things!
19:49:30 <SamB> jeffersonheard: what happens if you get a type error?
19:49:31 <ddarius> fynn: Do you recompile a Smalltalk image?
19:49:35 <SamB> does it delete your source file ?
19:49:39 <ddarius> SamB: Use more characters.
19:49:54 <SamB> ddarius: hmm ?
19:50:09 <ddarius> You repeatedly tab complete to the wrong nick.
19:50:16 <SamB> oj
19:50:18 <SamB> oh
19:50:21 <SamB> jeffwheeler:
19:50:28 <jeffwheeler> Oh, what?
19:50:41 <jeffwheeler> Oh, above . . .
19:50:46 <ozy`> "The game of life algorithm implemented and displayed INSIDE Game of life" http://golly.sourceforge.net/gtk-galaxy.png <- my brain just exploded
19:51:15 <ddarius> That's pretty big.
19:51:33 <jeffwheeler> SamB: You mean when restarting Yi and resuming after recompilation?
19:51:41 <fynn> ddarius: I thought at least with some implementations, what happens is that certain pieces of the code (specific classes or even methods) get recompiled.
19:51:43 <opqdonut> :D
19:51:44 <SamB> ozy`: zoom in ?
19:51:55 <ozy`> SamB: don't see a link
19:52:02 <SamB> oh, well, install golly
19:52:06 <SamB> then zoom in
19:52:06 <ozy`> poke around on the golly site
19:52:07 <ozy`> yeah
19:52:10 <ddarius> fynn: The stuff that you change may get recompiled, yes.  Maybe other stuff as well.  So?
19:52:20 <jeffwheeler> SamB: It'll fail to compile and, I expect, reuse the old one because a new ~/.yi/yi-arch-os would not have been installed.
19:52:30 <SamB> jeffwheeler: hmm
19:52:32 <SamB> that makes sense
19:53:01 <jeffwheeler> SamB: alternatively, if something bad happens, yi --resume should get it working again.
19:53:09 <Taejo> @hoogle [a] -> [a] -> [a]
19:53:10 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
19:53:10 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
19:53:10 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:53:15 <Taejo> @hoogle replace
19:53:16 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
19:53:16 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
19:53:16 <lambdabot> Data.Array.Diff replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
19:53:56 <fynn> ddarius: so I thought it would work well with implementations that support incremental compilation (such as certain Smalltalk and Lisp platforms), but I'd doubt GHC supports that.
19:54:10 <ddarius> fynn: When did I say anything about GHC?
19:54:11 <fynn> also, I think you need to be at least partially dynamic to do that.
19:54:35 <ddarius> fynn: If by "dynamic" you mean "can do this stuff" then I agree, otherwise defined "dynamic"
19:54:45 <ddarius> Also define "static language" while you're at it.
19:54:53 <fynn> if it doesn't work with GHC, it seems to not be viable currently anyway.
19:55:14 <mmorrow> fynn: you just have to generate code, then link in memory
19:55:34 <ddarius> It's not particularly viable currently.  I wasn't actually serious about the suggestion.  I freakin' hate Smalltalk style images and the benefit it would provide to a text editor is dubious.
19:55:41 <fynn> mmorrow: yeah, can GHC do that?
19:55:47 <ddarius> fynn: Yes.
19:55:58 <mmorrow> ghc's dynamic linker already does this, the crux is getting GHC to not write to a file at some point
19:56:54 <Axman6> how much of a compiled haskell program is the RTS? i find most programs are usually larger than 1MB
19:57:02 <travisbrady> @undo latestPastes n = {pastes <- getPastes; return . take n $ sort pastes}
19:57:03 <lambdabot>  Parse error at "=" (column 16)
19:57:16 <wli> Axman6: Depends a lot on the program, of course.
19:57:23 <mmorrow> fynn: well, i guess ghc doesn't have an assembler/objfile generator so it'd have to call out
19:57:33 <travisbrady> latestPastes n = do {pastes <- getPastes; return . take n $ sort pastes}
19:57:35 <mmorrow> that's why harpy is so cool
19:57:36 <ddarius> Axman6: I don't think the RTS is particularly big, but pretty much everything is statically linked so the libraries can add a lot.
19:57:42 <travisbrady> @undo latestPastes n = do {pastes <- getPastes; return . take n $ sort pastes}
19:57:43 <lambdabot> latestPastes n = getPastes >>= \ pastes -> return . take n $ sort pastes
19:57:51 <shapr> @seen johnw
19:57:52 <lambdabot> I saw johnw leaving #haskell 9m 55s ago, and .
19:57:56 * shapr sighs
19:58:01 <Axman6> ddarius: ah, fair enough
19:58:07 <mmorrow> omg, yeah if you use any part of ghc, your binary'll 14MB+ /after/ stripping
19:58:16 <mmorrow> *binary'll be ..
19:58:28 <lepassive> I've installed EclipseFP plugin but I can't get it working well
19:58:32 <Taejo> @pl \x y -> x++h++y
19:58:33 <lambdabot> (. (h ++)) . (++)
19:59:02 <jeffwheeler> How does lambdabot parse expressions like that? Is there some GHC API it uses?
19:59:21 <ddarius>  @pl uses its own ad-hoc parser.
19:59:23 <fynn> mmorrow: OK, thanks.
19:59:30 <Taejo> but yes, there is a GHC API
20:00:00 * jeffwheeler wonders how @pl works.
20:00:09 <int80_h> Could someone take a look at my updated project euler code?
20:00:11 <ddarius> jeffwheeler: It's an optimizing compiler.
20:00:12 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1253
20:00:29 <ddarius> jeffwheeler: In some respects it's like Turner's early FP compilers.
20:00:47 * jeffwheeler does a bunch of Googling
20:00:59 * ddarius wonders what jeffwheeler is googling.
20:01:05 <Taejo> is @ a valid infix operator?
20:01:12 <jeffwheeler> Turner's fp compilers, optimizing compilers
20:01:21 <ddarius> > let (@) = (+) in (@)
20:01:24 <lambdabot>   <no location info>: parse error on input `@'
20:01:28 <ddarius> Taejo: No
20:01:33 <ddarius>  @@ is though
20:01:38 <Taejo> weird
20:01:50 <Taejo> I'm looking for a one char operator name for golfinf
20:01:53 <Taejo> *golfing
20:02:20 <int80_h> ddarius: could you take a look at my project euler code. I believe the alogorithm is correct, but is very inefficient
20:02:24 <Taejo> > let a | b = a + b in 1|2
20:02:25 <lambdabot>   <no location info>: parse error on input `|'
20:02:28 <mmorrow> smlnj is sooo cool
20:02:36 <Taejo> > let a % b = a + b in 1%2
20:02:39 <lambdabot>   3
20:02:39 <ddarius> Taejo: @ is used for as patterns which would cause parsing ambiguities.
20:02:45 <Taejo> :t (%)
20:02:48 <Taejo> ddarius: right
20:02:48 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
20:02:52 <Taejo> @where %
20:02:53 <lambdabot> I know nothing about %.
20:02:56 <Taejo> @where (%)
20:02:57 <lambdabot> I know nothing about (%).
20:03:01 <Taejo> @hoogle %
20:03:01 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
20:04:08 <lepassive> readFile "etc/passwd" >>= (\passwdContent >> putStrLn passwdContent_) what's wrong ?
20:04:45 <Gracenotes> lepassive: unless you're in the / directory, try /etc/passwd?
20:04:58 <rwbarton> you want ->, not >>, and also you have an extra underscore
20:05:10 <int80_h> Gracenotes: how about you?
20:05:29 <augustss> And you don't need that lambda at all
20:05:31 <lepassive> readFile "/etc/passwd" >>= (\passwdContent -> putStrLn passwdContent) yeah sorry
20:05:40 <Gracenotes> int80_h: how about me for what? :)
20:05:45 <lepassive> but why -> not >> ? I'm not chaining them together right ?
20:06:19 <ddarius> int80_h: Just paste it and put a link in the channel.  I'm sure someone will look at it.
20:06:44 <rwbarton> Taejo: &
20:07:16 <int80_h> ddarius: oh I did. Okay I will again
20:07:20 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1253
20:07:35 <int80_h> Gracenotes: no wowrries, just looking for someone to look at my project euler code
20:09:09 <chessguy> @pl r a = f (\s k -> k s a)
20:09:10 <lambdabot> r = f . flip (flip . flip id)
20:09:36 <lepassive>  readFile "/etc/passwd" >>= (\passwdContent >> lines passwdContent) I tried both -> and >> and not working
20:10:11 <Taejo> @pl \n->putStr$show n%v%show n%u%w%show (n-1)%x
20:10:12 <lambdabot> putStr . (% x) . ap ((%) . (% w) . (% u) . ap ((%) . (% v) . show) show) (show . subtract 1)
20:10:15 <Gracenotes> lines is not (String ->IO a)
20:10:30 <rwbarton> lepassive: You can stop trying things with >> there.
20:10:34 <ddarius> jeffwheeler: Incidentally, the kind of thing I was referring to is: http://www3.interscience.wiley.com/journal/113444597/abstract?CRETRY=1&SRETRY=0
20:10:43 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1253
20:10:45 <lepassive> @lambdabot, :t lines
20:10:46 <lambdabot> Unknown command, try @list
20:10:46 <rwbarton> lepassive: \passwdContent -> ... is just lambda syntax
20:11:06 <jeffwheeler> ddarius: that link doesn't seem to work. It's got a session error.
20:11:16 <Gracenotes> int80_h: well, your output matches what they have
20:11:54 <ddarius> jeffwheeler: Then stick this into Google: "A new implementation technique for applicative languages"
20:12:40 <lepassive> Okay how can i get the lines then ?
20:12:41 <jeffwheeler> ddarius: that got it, thanks
20:13:01 <Gracenotes> int80_h: hm... except there aren't 2202 numbers
20:13:03 <int80_h> Gracenotes: Look further down. I'm talking about my modified code. The first attempt is wrong
20:13:10 <jeffwheeler> ddarius: it's a beauty: http://www.cs.berkeley.edu/~jcondit/pl-prelim/turner79new.ps :)
20:13:12 <augustss> Wow!  A game-of-life configuration that generates reddit aliens.  I'm much impressed.
20:13:23 <Gracenotes> int80_h: uh.. what's the output :)
20:13:25 <int80_h> Gracenotes: The latest attempt never finishes, after waiting over 30 minutes
20:13:34 <rwbarton> I have ssh access to a Mac, but not root permissions.  How can I install a binary distribution of ghc in my home directory?
20:13:41 <SamB> hmm, this is a very confusing place for a line break:
20:13:43 <SamB> Warning: The documentation for the following packages are not installed. No
20:13:43 <SamB> links will be generated to these packages: ansi-terminal-0.5.0,
20:13:58 <Gracenotes> int80_h: it could be that the primality tests are too expensive..? try http://en.wikipedia.org/wiki/Primality_test
20:14:42 <int80_h> Gracenotes: okay I wanted to verify that my algorithm was at least correct first, if not efficient. I'll look at that url
20:15:10 <ddarius> jeffwheeler: Compilation by combinators is actually a fairly simple technique that can produce reasonably efficient interpreters pretty quickly.
20:15:19 <Gracenotes> I don't know about the correctness, but it is basically filtering a list with isPrime. the list looks correct.
20:15:33 <jeffwheeler> ddarius: that's pretty neat; it's how Parsec works, right?
20:15:34 <augustss> int80_h: you can speed up your sieve by only using prime numbers for the divides test
20:15:45 <ddarius> jeffwheeler: No, Parsec is just a library.
20:16:03 <jeffwheeler> ddarius: err, yeah, but it parses by combinators?
20:16:16 <jeffwheeler> ddarius: which, well, actually is far short of compilation . . . but yeah
20:16:30 <ddarius> jeffwheeler: "Combinators" is used in a technical sense in that paper (and many other places), but often in talking about Haskell "combinators" is used in a very informal (and almost meaningless) sense.
20:16:34 <augustss> jeffwheeler: those are not really related to the SKI combinators
20:17:51 <Taejo> let (p x, q x) = ((+1), (-1) in p 1
20:17:57 <Taejo> > let (p x, q x) = ((+1), (-1) in p 1
20:17:58 <lambdabot>   <no location info>: parse error on input `in'
20:18:04 <Taejo> > let (p x, q x) = ((+1), (-1)) in p 1
20:18:05 <lambdabot>   <no location info>: Parse error in pattern
20:18:22 <augustss> > let (p, q) = ((+1), (-1)) in p 1
20:18:24 <lambdabot>   2
20:19:17 <int80_h> augustss: I believe I am using only prime numbers for my divides test
20:20:04 <int80_h> augustss: oh wait, maybe i'm not. Thanks :)
20:20:19 <Axman6> augustss: q 1 wouldn't work though
20:20:22 <shapr> augustss: Is BASIC.hs available?
20:20:33 <shapr> aha - http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BASIC
20:20:51 <SamB> shapr: I was just going to tell you I saw hackage saying it got uploaded ;-P
20:21:16 <augustss> int80_h: yeah, i think you are.  btw, it might be faster to test x*x < upperBound than using sqrt.  it depends
20:22:04 <lepassive> readFile "/etc/passwd" >>= (\contents -> return () ) >> lines contents  ..still not working
20:22:22 <pumpkin_> hmm
20:22:27 <augustss> lepassive: what is it that you want to do?
20:22:27 <pumpkin_> why are you doing that?
20:22:28 <SamB> shapr: about 40 minutes ago, it seems
20:22:42 <shapr> Ok, so I'm not completely out of touch.
20:22:57 <pumpkin_> fmap lines $ readFile "/etc/passwd" ?
20:23:00 <Axman6> lepassive: well yeah, (\contents -> return () ) is the same as (\_ -> return ())
20:23:19 <SamB> readFile "/etc/passwd" >>= \contents -> return (lines contents)
20:23:22 <lepassive> augustss, I'm trying to read /etc/passwd" then pass it to contents" then ">>" and lines them
20:23:32 <lepassive> :t fmap
20:23:34 <Axman6> lepassive: i'd suggest you use do notation until you understand how it works
20:23:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:23:50 <Axman6> lepassive: do you know what >> does?
20:23:50 <augustss> lepassive: and what do you want to do with those lines?
20:24:15 <lepassive> Axman6, It's like binding but with out passing anything i guess
20:24:16 <Axman6> because >> doesn't pass any information
20:24:23 <Axman6> yes
20:24:29 <lepassive> augustss, Just print the list of the lines
20:24:42 <shapr> Hm, llvm fails to build for me (on debian/unstable), is it working for everyone else?
20:24:43 <augustss> int80_h: if you're just after computing primes quickly there is simple relatively fast way
20:25:00 <Axman6> shapr: llvm, or the haskell bindings?
20:25:04 <int80_h> augustss: Well I want to be able to test primality for any given number.
20:25:05 <augustss> lepassive: readFile "..." >>= print . lines
20:25:08 <shapr> The haskell bindings.
20:25:21 <Axman6> haven't tried them, sorry :\
20:25:24 <augustss> int80_h: you can do that too
20:25:26 <rwbarton> shapr: I got it to build, but I got segfaults after running an llvm function
20:25:28 <SamB> shapr: have you got LLVM you need for that ?
20:25:28 <shapr> Axman6: cabal install llvm? ;-)
20:25:37 <shapr> SamB: good question
20:25:39 <int80_h> augustss: I'm all ears (eyes)
20:25:54 <SamB> last I can recall, debians was *really* stale
20:26:06 <augustss> rwbarton: you can skip the llvm bit and just use the interpreter
20:26:14 <rwbarton> shapr: oh, I had to build my own llvm (the c library). version 2.4
20:26:17 <lepassive> that's will cut it thanks
20:26:21 <Axman6> configure: error: could not find LLVM C bindings
20:26:27 <SamB> rwbarton: I thought it was a C++ library
20:26:29 <SamB> oh.
20:26:31 <rwbarton> augustss: Oh, this was earlier when I wanted to actually use LLVM for something
20:26:33 <Axman6> but could be i don;t have things installed correctly
20:26:34 <SamB> it has C bindings ?
20:26:48 <rwbarton> SamB: Ah, you're right.  No, I just meant "not the Haskell bindings".
20:26:52 <Axman6> well, yeah?
20:27:32 <SamB> rwbarton: it's hard to say with these C++ libs!
20:27:36 <SamB> some of them DO have C bindings
20:28:12 <SamB> rwbarton: oh, actually I was looking at the error Axman6 got from configure
20:28:26 <SamB> it indicates that there *are* C bindings
20:29:00 <jeffwheeler> @hoogle listToMaybe
20:29:01 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
20:29:08 * shapr upgrades to llvm 2.4
20:29:18 <jeffwheeler> @src listToMaybe
20:29:19 <lambdabot> listToMaybe []        =  Nothing
20:29:19 <lambdabot> listToMaybe (a:_)     =  Just a
20:29:40 <int80_h> augustss: are you referring to the APR primality test?
20:30:03 <Taejo> "YODA: Code!  Yes.  A programmer's strength flows from code maintainability.  But beware of Perl.  Terse syntax... more than one way to do it...  default variables.  The dark side of code maintainability are they.  Easily they flow, quick to join you when code you write.  If once you start down the dark path, forever will it dominate your destiny, consume you it will."
20:30:27 <augustss> int80_h: no, something very simple.
20:30:50 <augustss> primes = 2 : filter isPrimes [3, 5 ..]
20:30:50 <augustss> isPrimes n = all ((/= 0) . mod n) $ takeWhile ((<= n) . (^2)) primes
20:31:07 <augustss> s/isPrimes/isPrime/
20:31:38 <Axman6> augustss: i swear, you stole my exact prime computation code :(
20:32:00 <Axman6> without the pointfreeness
20:32:08 <augustss> Axman6: well, it must be the right one then :)
20:32:13 <Axman6> :)
20:32:41 <Taejo> heh, I think my usual code is bit-identical to augustss'
20:33:01 * Gracenotes >_>s
20:33:01 <augustss> It has a very tricky termination proof, though
20:33:02 <Axman6> i prefer using lambdas, i find them clearer
20:33:02 <Taejo> maybe I'd not put spaces around ":"
20:33:04 <int80_h> augustss: ah, so I would just filter my own series of poetential primes...
20:33:16 <ddarius> Taejo: As a multi-time IOCCC winner, perhaps that is not quite a good thing...
20:33:38 <Taejo> ddarius: you're a multi-time IOCCC winner?
20:33:40 <Taejo> awesome
20:33:48 * Taejo bows down before ddarius
20:33:49 <ddarius> Taejo: No, augustss is.
20:33:56 <Taejo> oh, whoops
20:34:00 <Axman6> augustss: any idea wat the time complexity of primes !! n would be?
20:34:11 <augustss> Axman6: no
20:34:16 * Taejo unbows before ddarius, quickly shifting over to augustss to bow down again
20:34:23 <augustss> :)
20:34:26 <Axman6> seems like it'd be something quite strange
20:34:56 <int80_h> what's the name of the annual functional programming contest?
20:34:57 <Axman6> IOCCC?
20:35:02 <Taejo> int80_h: ICFP
20:35:02 <ddarius> @google IOCCC
20:35:03 <lambdabot> http://www.ioccc.org/
20:35:03 <lambdabot> Title: The International Obfuscated C Code Contest
20:35:09 <Axman6> ah, heh
20:35:11 <jeffwheeler> augustss: admittedly, very impressive.
20:35:15 <augustss> Axman6: I don't think it's too strange.  You can just assume the usual rough primes distribution and integrate
20:35:30 <Axman6> hmm, fair enough
20:35:36 <augustss> Axman6: but it's too late
20:35:43 <Taejo> int80_h: usually a very good competition, though often very hard... I dropped out of last year's half-way through
20:36:05 <Gracenotes> @go ICFP
20:36:06 <lambdabot> http://icfpcontest.org/
20:36:06 <lambdabot> Title: ICFP Programming Contest 2008
20:36:17 <augustss> Taejo: I spent months on my Grand Prize entry
20:36:56 <Taejo> there was an article entitled something like "the real sieve of eratosthanes in Haskell" which compared the complexity of this version of primes to a real sieve of Eratosthanes... so that would tell you, Axman6
20:37:01 <Taejo> augustss: which year?
20:37:04 * SamB is amused to discover this in LHC:
20:37:06 <SamB> http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/src/GenUtil.html#rot13
20:37:35 <augustss> Taejo: umm, can't remember.  it's the last of my entries.  called august.c, I think
20:37:53 * Taejo hopes one day to do the ICFP in Haskell (failed epically in Python last year, came second in Perl and C++ the year before)
20:38:19 <Taejo> augustss: 1996?
20:38:22 <augustss> yes
20:38:55 <Taejo> $ file august.c
20:38:55 <Taejo> august.c: data
20:38:56 <lunabot>  luna: Not in scope: `file'
20:39:08 <augustss> Taejo: :)
20:39:55 <Taejo> augustss: gcc doesn't like it
20:40:07 <augustss> what does it say?
20:40:12 <z0d> What is #haskell-in-depth?
20:40:27 <Taejo> august.c:268: error: ‘Z’ undeclared here (not in a function)
20:40:28 <Taejo> august.c: In function ‘main’:
20:40:28 <Taejo> august.c:281: error: ‘g’ undeclared (first use in this function)... and many more
20:40:34 <augustss> Taejo: are you using the Makefile?
20:40:47 <Axman6> z0d: indepth haskell discussions. to make #haskell more noob friendly
20:41:13 <z0d> Axman6: Nice.
20:41:13 <Taejo> augustss: no, but the makefile just runs "cc $? -o $@"
20:41:28 <augustss> Taejo: the Makefile is crucial
20:41:31 <shapr> I think it's time for another IOHCC
20:41:50 <shapr> Too bad I lost the winners for the Zeroth :-(
20:41:53 <z0d> shapr: I though Haskell is already obfuscated.
20:41:53 <Taejo> augustss: oops, was looking at a makefile from an older entry
20:41:58 <hackage> Uploaded to hackage: BASIC 0.1.1.0
20:42:00 <augustss> Taejo: a lot of the code is supplied on the command line
20:42:04 <shapr> z0d: Nah, Haskell is clear... IOHCC is scary.
20:42:10 <Taejo> augustss: I see that now
20:42:11 <Axman6> z0d: if you think that, you have a lot to learn ;)
20:42:28 <z0d> Axman6: That was supposed to be a joke.
20:42:35 <augustss> Taejo: I just couldn't squeeze it all in
20:42:35 <Axman6> dman, i want a doughnut
20:42:43 <Axman6> z0d: good :)
20:44:05 <travisbrady> how does one slice a list ala python's somelist[5:10] syntax?
20:44:22 <lpsmith> What about the IEHCC,  International Esoteric Haskell Code Contest?
20:44:47 <Taejo> travisbrady: (drop 5 . take 5) somelist
20:45:21 <shapr> lpsmith: Good idea!
20:45:47 <Taejo> augustss would win that too, by the looks of his BASIC module
20:48:14 <augustss> int80_h: You should probably make that primality test pointful.  I don't think ghc optimizes (^2).
20:48:27 <augustss> int80_h: isPrime n = all (\ p -> n `mod` p == 0) $ takeWhile (\ p -> p*p <= n) primes
20:48:31 <lepassive> why do I've to write f(-1) instead of f -1 ?
20:48:55 <augustss> lepassive: because f - 1 subtracts one from f
20:49:28 <lepassive> augustss, I wrote f  -1 (negative 1 not minus then space then 1)
20:49:40 <augustss> lepassive: doesn't matter
20:49:53 <geezusfreeek> it's just how it parses
20:50:22 <rwbarton> lepassive: and common style is to write f (-1), not f(-1)
20:50:28 <augustss> lepassive: the lexical syntax for Haskell with regards to negation and negative numbers can be debated
20:50:52 <lepassive> okay thanks :)
20:50:59 <lpsmith> augustss:  indeed.
20:51:43 <augustss> I wanted negation to have higher precedence than any infix operator.  But I lost.
20:52:16 <rwbarton> > 3 * -1
20:52:17 <lambdabot>       precedence parsing error
20:52:17 <lambdabot>          cannot mix `(*)' [infixl 7] and prefi...
20:52:28 <mdmkolbe> @seen dcoutts
20:52:29 <lambdabot> dcoutts is in #darcs, #haskell-soc, #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 3h 20m 29s ago.
20:52:33 <augustss> but for that to help negation would have to be some other operator symbol
20:52:40 <augustss> like ~ in SML
20:53:12 <wli> There are strange parsing tricks possible.
20:53:27 <wli> Like precedences differing from the left and right.
20:53:48 <rwbarton> If -1 was a single token, you could get most of the benefit of negation without having an actual prefix operator at all
20:53:54 <ozy`> augustss: if tokens were forcefully space-separated, it wouldn't be--yeah.
20:54:30 <rwbarton> I guess then 2-1 would stop working.
20:55:07 <ozy`> I personally don't like seeing "n-m" in source code
20:55:22 <ozy`> so good riddance
20:59:13 <Twey> A igree with ozy`.
20:59:14 <Twey> Er
20:59:16 <Twey> I agree**
21:01:38 <lepassive> what wrong with the exponent function ? http://pastebin.com/d678f73bd
21:01:42 <lepassive> what*s
21:02:26 <pumpkin_> you tell us
21:02:39 <pumpkin_> you're parenthesizing wrong
21:03:01 <pumpkin_> you could also just use pattern matching instead of guards too
21:04:24 <lepassive> pumpkin, I know  that I'm just trying to apply YAHT examples
21:04:27 <Axman6> lepassive: get rid of the outer parens
21:04:50 <Twey> lepassive: http://pastebin.com/dfbb2501
21:05:01 <pumpkin_> lepassive: the outer parens are treating a as a function and applying it to b-1
21:05:12 <Twey> expon (a (b - 1)) means 'apply a to (b - 1), then apply expon to the result'
21:05:24 <Twey> a isn't a function, so you get a type error.
21:05:34 <Zao> > let expon x y = foldr (*) 1 $ replicate y x in expon 2 10
21:05:35 <lambdabot>   1024
21:05:56 <Twey> What you want is ((expon a) (b - 1)), 'apply expon to a, then apply the result to (b - 1)'
21:05:57 <pumpkin_> Zao: product?
21:05:58 <lepassive> aha I got it it's not for ordering in passing arguments but in ordering functions
21:06:08 <Twey> Or, using operator precedence, just expon a (b - 1).
21:06:25 <Zao> pumpkin_: I wish someone would tell me about all those handy prelude / Data.List functions.
21:06:32 <pumpkin_> :)
21:06:35 <pumpkin_> > product [1..10]
21:06:37 <lambdabot>   3628800
21:06:42 <Twey> Zao: Read the Report :)
21:06:52 <dibblego> @hoogle Map k v -> k -> Maybe a
21:06:53 <lambdabot> Data.Map lookup :: (Monad m, Ord k) => k -> Map k a -> m a
21:06:53 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
21:06:53 <lambdabot> Data.Map lookupIndex :: (Monad m, Ord k) => k -> Map k a -> m Int
21:07:04 <kerlo> Now someone come up with a pointless implementation of exponentiation by squaring.
21:07:18 <Twey> It's a SICP exercise
21:07:23 <Twey> I've got one lying around already :-P
21:07:27 <kerlo> @pl f True = 3; f False = 4
21:07:27 <lambdabot> (line 1, column 11):
21:07:28 <lambdabot> unexpected ";"
21:07:28 <lambdabot> expecting digit, variable, "(", operator or end of input
21:07:36 <kerlo> @pl let f True = 3; f False = 4 in f
21:07:37 <lambdabot> const 4
21:07:47 <kerlo> ?
21:07:48 <Twey> ... huh?
21:08:04 <kerlo> I understand that lambdabot hasn't been feeling well lately.
21:08:06 <Axman6> heh
21:08:19 <Axman6> it can't pl things like that i think
21:08:22 <kerlo> Something's functor up? :-P
21:08:32 <kerlo> @pl case x of True -> 3; False -> 4
21:08:33 <lambdabot> (line 1, column 16):
21:08:33 <lambdabot> unexpected ">" or "-"
21:08:33 <lambdabot> expecting variable, "(", operator or end of input
21:08:36 <Axman6> @pl let f x = if x then 3 else 4 in f
21:08:37 <lambdabot> flip (flip if' 3) 4
21:08:39 <Twey> @pl \x -> if x then 3 else 4
21:08:40 <lambdabot> flip (flip if' 3) 4
21:08:42 <Twey> Yeah.  :)
21:08:46 <kerlo> That'll do.
21:08:50 <Twey> Where if' x y z = if x then y else z
21:10:01 <rwbarton> @. pl src (^)
21:10:02 <lambdabot> (line 1, column 1):
21:10:02 <lambdabot> unexpected end of input
21:10:02 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:10:27 <kerlo> @pl f x y = if x == 0 then 1 else if odd x then y * f (x `div` 2) y * f (x `div` 2) else f (x `div` 2) y * f (x `div` 2)
21:10:31 <lambdabot> f = fix (ap ((.) . flip if' 1 . (0 ==)) . ap (ap . (ap .) . ap ((.) . if' . odd) . ap (ap . ((flip . ((*) .) . ap (*)) .) . (. (`div` 2))) (. (`div` 2))) (ap (ap . ((flip . ((*) .)) .) . (. (`div` 2)
21:10:31 <lambdabot> )) (. (`div` 2))))
21:10:31 <lambdabot> optimization suspended, use @pl-resume to continue.
21:10:38 <kerlo> Eek.
21:11:11 <rwbarton> @pl f x = y where y = x*x
21:11:11 <lambdabot> (line 1, column 17):
21:11:12 <lambdabot> unexpected "="
21:11:12 <lambdabot> expecting variable, "(", operator or end of input
21:11:21 <rwbarton> @pl f x = let y = x*x in y
21:11:22 <lambdabot> f = join (*)
21:11:42 * Twey thinks we should define data Then = Then; data Else = Else; then = Then; else = Else; if :: Bool -> Then -> a -> Else -> a -> a; if x Then y Else z = case x of True -> y; _ -> z
21:12:35 <Twey> Or even data Then = Then; data Else = Else; then = Then; else = Else; if :: Bool -> Then -> a -> Else -> a -> a; if True Then y Else _ = y; if False Then _ Else z = z
21:12:45 <wli> > let primeStep m n = case minViewWithKey m of Nothing -> (fromList [(n * n, [n])], Just n) ; Just ((k, ps), m') | n /= k -> (insertWith (++) (n * n) [n] m, Just n) | otherwise -> (foldr (\p -> insertWith (++) (k + p) [p]) m' ps, Nothing) in take 10 . catMaybes . snd $ mapAccumL primeStep empty [2..]
21:12:46 <lambdabot>   Not in scope: `minViewWithKey'Not in scope: `fromList'Not in scope: `insert...
21:12:52 <Zao> Twey: As someone who has recently enjoyed the wonders of \ifthenelse in LaTeX, "aaaargh".
21:13:47 <wli> > let primeStep m n = case Data.Map.minViewWithKey m of Nothing -> (fromList [(n * n, [n])], Just n) ; Just ((k, ps), m') | n /= k -> (Data.Map.insertWith (++) (n * n) [n] m, Just n) | otherwise -> (foldr (\p -> Data.Map.insertWith (++) (k + p) [p]) m' ps, Nothing) in take 10 . catMaybes . snd $ mapAccumL primeStep Data.Map.empty [2..]
21:13:48 <lambdabot>   Not in scope: `fromList'
21:14:45 <dons> augustss++ woo
21:16:08 <wli> Okay, apparently lambdabot can't do Data.Map
21:16:09 <travisbrady> is there something special I need to import besides GHC.Exts to enable SPJ's comprehensive comprehensions?
21:16:33 <pumpkin_> @type M.map
21:16:34 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
21:16:42 <rwbarton> > M.empty
21:16:44 <pumpkin_> wli: I think it's just namespaced in M
21:16:44 <lambdabot>   /tmp/6767474312232459149:70:32: Not in scope: `M.empty'
21:17:01 <wli> Witness the response to rwbarton.
21:17:25 <int80_h> @seen augustss
21:17:25 <lambdabot> augustss is in #haskell-in-depth and #haskell. I last heard augustss speak 24m 45s ago.
21:17:32 <int80_h> augustss: busy?
21:18:24 <pumpkin_> dons: you there?
21:19:02 <rwbarton> travisbrady: I think you need -XParallelListComp/-XTransformListComp(/etc.?)
21:19:08 * Gracenotes <_<s
21:20:00 <pumpkin_> > M.singleton 1 'a'
21:20:01 <lambdabot>   /tmp/8924155693460310685:70:36: Not in scope: `M.singleton'
21:20:19 <pumpkin_> > M.insertWith
21:20:21 <lambdabot>       Overlapping instances for Show
21:20:21 <lambdabot>                                  ((a -> ...
21:20:25 <pumpkin_> o.O
21:20:35 <rwbarton> pumpkin_: this is a classic example of typechecking and evaluation in lambdabot having different environments
21:20:54 <rwbarton> pumpkin_: which is incredibly confusing
21:21:11 <pumpkin_> :D
21:21:57 <travisbrady> rwbarton: thank you, i'll give that a try
21:22:01 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1256
21:22:16 <int80_h> could someone take a look at my latest revision to a project euler problem?
21:22:43 <int80_h> I used some code from augustss, withgout understanding it completly. My adaptation of his code broke it
21:23:03 <rwbarton> travisbrady: but I'm surprised you didn't get an error message telling you what to do, so maybe your ghc is too old
21:24:33 <pumpkin_> :(
21:24:54 <int80_h> pumpkin: would you take a look at my code?
21:24:59 <chrisdone> Twey: more like do away with if-then-else crap and have functions in Data.Bool like bool :: b -> b -> Bool -> b
21:25:07 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1238#a1256
21:26:27 <chrisdone> Twey: and if :: (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
21:27:06 <newsham> int80: why not all not divides?
21:27:29 <Twey> Which would do what?  Feed the provided a to all the ((->) a) functions?
21:27:37 <pumpkin_> int80_h: you need more parentheses, basically
21:27:37 <Gracenotes> @hoogle (a -> Bool) -> Maybe a -> Bool
21:27:38 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
21:27:38 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
21:27:38 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
21:27:45 <pumpkin_> stick a $ before specialSieve n
21:28:14 <chrisdone> Twey: well the first (a -> b) is if the predicate is true, the other is for false
21:28:16 <newsham> into80 you want (specialSieve n) to be one arg to takeWhile, yes?
21:28:26 <Twey> chrisdone: Right
21:28:38 <chrisdone> Twey: actually make that vise-versa, to be consistent with `maybe'
21:29:01 <int80_h> oi, augustss' code is way more slower than my origional code
21:29:02 <newsham> you need parens otherwise its trying to give 4 args to takeWhile
21:29:10 <Twey> chrisdone: So the value (the last a) is passed through the appropriate (a -> b) function?
21:29:17 <chrisdone> Twey: right
21:29:19 <int80_h> unless, maybe I'm using it wrongly
21:29:29 * Twey ponders.
21:29:32 <Gracenotes> and, as someone pointed out previously, making an if :: Bool -> a -> a -> a .. would basically amount to Church booleans :)
21:29:33 <Twey> Oh.  I see why.
21:29:37 <Twey> Interesting.
21:29:50 <rwbarton> int80_h: you are using it wrong
21:30:18 <rwbarton> int80_h: just use it as is
21:30:20 <chrisdone> Twey: I figure making it similar to `maybe' and `either' would make it "natural
21:30:24 <chrisdone> :t maybe
21:30:24 <chrisdone> :t either
21:30:26 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
21:30:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:31:11 <int80_h> rwbarton: That wouldn't do what I want. I'm not trying to build a list of primes. I'm trying to test to see if a given number of a certain property is a prime
21:31:17 <Gracenotes> that makes sense. So you can curry to make a function (Bool -> b)
21:31:24 <rwbarton> int80_h: that's exactly what isPrime does
21:31:43 <rwbarton> int80_h: the point of the primes definition is that you then don't recompute your list of primes every time you want to check a number for primality
21:31:54 <Twey> chrisdone: I think maybe I don't get maybe
21:32:02 <Twey> What's the difference between maybe and fromMaybe?
21:32:09 <chrisdone> @src fromMaybe
21:32:15 <Twey> (er, that is, I know that there's a difference, but why is there a difference?)
21:32:16 <chrisdone> Twey: well fromMaybe = flip maybe id
21:32:31 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
21:32:40 <dolio> maybe z f = fromMaybe z . fmap f
21:32:49 <Twey> Yes :-\
21:33:05 <chrisdone> dolio: hehe
21:34:02 <chrisdone> (`maybe' is in the Prelude and fromMaybe is from Data.Maybe)
21:34:43 <dolio> maybe is the canonical morphism you get from the definition of a coproduct.
21:34:46 <int80_h> rwbarton: I need to pass an argument ... an upperbound. His code doesn't have an upperbound. If I use his code as is, I have no way of using the upperbound that I need. Or do I?
21:34:56 <dolio> Maybe a = 1 + a
21:35:03 <newsham> int80: if you want to test if its prime you need to have a list of earlier primes
21:35:11 <newsham> unless you just want a simple probabalistic test
21:35:30 <int80_h> newsham: I know how to test for a prime. I'm trying to do it in a way that's efficient.
21:35:38 <rwbarton> int80_h: your "sift" function returns whether a number is prime right?
21:35:50 <dolio> So given a z :: 1 -> b and an f :: a -> b, there exists a unique [z,f] :: 1 + a -> b.
21:35:51 <rwbarton> int80_h: uh, I mean the one in specialSieve
21:35:57 <wli> I think I've got a spiffier Eratosthenes
21:36:04 <int80_h> rwbarton: I am no longer using sift. I did a revision. It's at the bottom of the page
21:36:11 <newsham> "I'm not trying to build a list of primes.
21:36:12 <newsham> "
21:36:12 <int80_h> ah, okay :)
21:36:15 <wli> let primeStep m n = maybe (singleton (n*n) [n], Just n) (\((k, ps), m') -> if n /= k then (insertWith (++) (n*n) [n] m, Just n) else (Data.Map.union m' (fromListWith (++) [(k + p, [p]) | p <- ps]), Nothing)) (minViewWithKey m) in take 10 . catMaybes . snd $ mapAccumL primeStep empty [2..] :: [Integer]
21:36:34 <rwbarton> int80_h: delete the where block, and instead include the code augustss wrote
21:36:59 <rwbarton> int80_h: delete the definition of isPrime inside the where block rather
21:37:19 <dolio> At least, inasmuch as it's actually a coproduct, which technically it isn't.
21:37:51 <int80_h> rwbarton: okay, but I wouls s/primes/specialSieve right?
21:38:02 <rwbarton> int80_h: no, don't s/// anything at all
21:38:20 <wli> int80_h: Which primality test do you want to use?
21:38:28 <rwbarton> int80_h: all you're trying to do is determine which numbers of the form 2n^2 - 1 are prime right?  Or am I misunderstanding the problem?
21:38:40 <rwbarton> int80_h: say for n in [1..10000]
21:38:46 <int80_h> rwbarton: yeah, you understand the problem correclty
21:38:59 <rwbarton> right so it's just filter isPrime [ 2n^2 - 1 | n <- [1..10000] ]
21:39:10 <int80_h> rwbarton: I'd be happy with for n in n[1..10000] right now, while I verify all is well
21:39:39 <int80_h> rwbarton: well, I'd like to put in any arbitray number. But I could settle for that
21:39:42 <newsham> int80: how about a probablistic test thats fast but has false positives?
21:39:54 <rwbarton> int80_h: yeah, sorry, I chose variable names which conflict with yours
21:40:29 <newsham> http://en.wikipedia.org/wiki/Primality_test#Probabilistic_tests
21:41:17 <Gracenotes> newsham: he basically needs to ensure that no composite number less than 50,000 turns up as a false positive on the test
21:41:32 <Gracenotes> however, those are somewhat easy enough to check manually
21:41:35 <int80_h> 50,000,000
21:41:45 <Gracenotes> oh, 50 million.
21:41:49 <int80_h> ya
21:41:49 <rwbarton> actually 2 * (50M)^2 - 1
21:42:15 <int80_h> rwbarton: 10000 is the test number. They give a solution for that number to test your code, I presume
21:42:18 <Axman6> > 2 * 50000000^2 -1
21:42:19 <Gracenotes> oh, yeah. Actually that :/
21:42:20 <lambdabot>   4999999999999999
21:42:21 <rwbarton> int80_h: right
21:42:29 <Gracenotes> > logBase 10 4999999999999999
21:42:31 <lambdabot>   15.698970004336019
21:43:36 <Gracenotes> > sqrt 4999999999999999
21:43:37 <lambdabot>   7.071067811865474e7
21:44:17 <redditbot> Here it is: BASIC embedded in Haskell via LLVM. Thanks Lennart!
21:44:46 <newsham> what is llvm?
21:45:07 <int80_h> rwbarton: okay should I give up trying to make my code general?
21:45:29 <Axman6> newsham: the low level virtual machine. llvm.org
21:45:30 * wli is not likely to be able to implement the elliptic curve primality test in any reasonable amount of time.
21:45:31 <rwbarton> int80_h: no
21:45:32 <Axman6> i think
21:45:33 <pumpkin_> http://llvm.org/
21:45:34 <Axman6> @go llvm
21:45:35 <lambdabot> http://llvm.org/
21:45:36 <lambdabot> Title: The LLVM Compiler Infrastructure Project
21:45:51 <int80_h> rwbarton: okay then I don't believe I can use his code as given, that I need to make some changes
21:45:57 <rwbarton> int80_h: you can just delete your definition of isPrime and use the isPrime augustss wrote
21:46:00 <rwbarton> int80_h: Why not?
21:46:10 <rwbarton> int80_h: There's only one notion of primality...
21:46:17 <jeffwheeler> @pl f w -> w { h = 5 }
21:46:18 <lambdabot> (line 1, column 5):
21:46:18 <lambdabot> unexpected ">" or "-"
21:46:18 <lambdabot> expecting variable, "(", operator or end of input
21:46:26 <jeffwheeler> @pl f w = w { h = 5 }
21:46:27 <lambdabot> (line 1, column 9):
21:46:27 <lambdabot> unexpected "{"
21:46:27 <lambdabot> expecting variable, "(", operator or end of input
21:46:33 <jeffwheeler> Oh, @pl can't parse that?
21:46:44 <int80_h> rwbarton: because his definition primes doesn't take a parameter. I'm using that ocde, but I need to take a parameter if I am to make my code general
21:46:51 <rwbarton> int80_h: don't use primes
21:46:54 <rwbarton> int80_h: use isPrime
21:47:00 <newsham> semi-off topic, BASIC related, very cool series of blog posts on old BASIC systems here http://www.pagetable.com/?p=48
21:47:02 <rwbarton> int80_h: isPrime uses primes internally
21:47:48 <int80_h> rwbarton: he defines a function calles primes and isPrime
21:48:06 <int80_h> I use primes, but modified for my needs
21:48:10 <rwbarton> int80_h: I'm so confused
21:48:13 <rwbarton> int80_h: Don't modify primes!
21:48:15 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Bool.html
21:48:15 <chrisdone> Stability: experimental
21:48:17 <chrisdone> wat
21:48:24 <pumpkin_> :(
21:48:30 <Axman6> chrisdone: Bools are hard!
21:48:36 <chrisdone> Bools Are Hard™
21:48:38 <int80_h> sorry for inducing confusion :)
21:48:45 <rwbarton> int80_h: hmm
21:49:04 <pumpkin_> Data.Bool looks like the most uninteresting module ever
21:49:05 <rwbarton> int80_h: your last paste is algorithmically wrong, after you insert the missing () around specialSieve n
21:49:13 <rwbarton> int80_h: I think that's related to your confusion
21:49:41 <rwbarton> int80_h: you don't want a list of all numbers of the form 2n^2 - 1 which aren't divisible by any smaller number of the form 2n^2-1
21:49:48 <int80_h> rwbarton: okay. yes I am assuming we're going off my last paste
21:50:06 <rwbarton> int80_h: you want a list of all numbers of the form 2n^2 - 1 which aren't divisible by any smaller number, period
21:50:26 <int80_h> rwbarton: that's right. I want a list of numbers of that form which have no prime factors
21:50:52 <int80_h> rwbarton: corrsect. this is where my efficiency problems come in
21:50:57 <rwbarton> int80_h: so just forget that the list "primes" exists in augustss's code, and use his isPrime function
21:51:24 <rwbarton> int80_h: his primes is like your list [3,5..upperBound] in your earlier pastes
21:51:37 <rwbarton> (Well, he's using it differently I guess)
21:51:46 <int80_h> rwbarton: right. I refer to his primes list in terms of the fact that I've modified it as you have mentioned
21:51:56 <int80_h> oh wait wait
21:52:00 <rwbarton> argh
21:52:03 <rwbarton> do *not* modify primes
21:52:05 <int80_h> no I have modifed it a different way ...
21:52:15 <int80_h> okay don't modify it, got it
21:52:25 <rwbarton> the isPrime function tells you whether a number is prime
21:52:27 <rwbarton> right?
21:52:48 <int80_h> rwbarton: the bell just went off in my head. I get it :)
21:53:04 <Gracenotes> hm... for some reason this Parsec snippet fails: parse (between (char ' ') (char ' ') (many anyChar)) ""  " ? ". How does 'between' work?
21:53:28 <newsham> ?type between
21:53:30 <lambdabot> Not in scope: `between'
21:54:08 <dmwit> Gracenotes: That code looks like it should work.
21:54:40 <Gracenotes> I thought so. But it yielded Left (line 1, column 4): unexpected end of input / expecting " "
21:54:54 <dmwit> Gracenotes: Ah, I get it.
21:55:00 <newsham> grace: doesnt many anyChar overlap with char ' ' ?
21:55:04 <Gracenotes> oh... I need..
21:55:05 <dmwit> Gracenotes: many anyChar is eating the "? ".
21:55:22 <Gracenotes> yeah. I'm thinking in greedy-regex-land
21:55:48 <Gracenotes> so noneOf "blahblah"
21:55:49 <newsham> parsec doesnt like the overlapping alternatives
21:56:13 <int80_h> rwbarton: so far so good. About to test it on 10000
21:56:14 <rwbarton> int80_h: ah, and I just figured out the source of the confusion :)
21:56:25 <rwbarton> int80_h: the tricky thing is that primes and isPrime are mutually recursive
21:56:27 <int80_h> rwbarton: please tell :)
21:56:39 <Gracenotes> hm. I may as well not use between, but rather char 'x', many $ noneOf "x"
21:56:46 <rwbarton> int80_h: you want something like primes, but different; but isPrime needs primes to function
21:57:55 <rwbarton> I mean, primes = 2 : filter isPrime [3, 5..] looks a lot like specialSieve n = filter isPrime [ 2*x^2 - 1 | x <- [1..n] ]
21:58:06 <int80_h> rwbarton: this is what I have which seems to work so far...it's off by one because it tacks on 2 I think
21:58:06 <rwbarton> but you can't change the definition of primes, because isPrime uses it
21:58:28 <int80_h> my code comes up with the answer 2203 instead of 2202
21:58:46 <dmwit> WRONG
21:58:59 <rwbarton> hmm, well, 2 * 1^2 - 1 is 1, so maybe augustss's code is returning True for isPrime 1
22:00:03 <int80_h> ah yes, it says n > 1
22:00:09 <int80_h> oops...I didn't code to spec
22:00:15 <wli> Do you know how to intersect two infinite sorted lists?
22:00:25 <dmwit> :t merge
22:00:26 <lambdabot> Not in scope: `merge'
22:00:28 <dmwit> uh
22:00:38 <dmwit> http://www.dmwit.com/programming/Dmwit.hs
22:00:41 <dmwit> Then use merge. ;-)
22:00:56 <rwbarton> dmwit: cabal install Dmwit?
22:01:00 <dmwit> Hey!
22:01:02 <dmwit> It's not there either.
22:01:09 * dmwit wonders what happened to merge
22:01:18 <newsham> dmwit sleight of hand
22:01:26 <dmwit> rwbarton: I'm not quite egotistical enough yet to put  it on Hackage. =P
22:01:52 <dibblego> is there a standard hack for not being able to restrict exporting of type-class instances?
22:02:03 <dmwit> No.
22:02:15 <dmwit> If you don't want to export the instance, all you can do is refrain from writing it.
22:02:18 <newsham> i was wondering why cabal doesnt have Prelude.User.<username> packages yet :)
22:02:30 <dmwit> newsham: That is a most excellent ideap.
22:02:31 <rwbarton> dmwit: You wouldn't be the first to have such a package.
22:02:40 <dmwit> rwbarton: ...on Hackage, though?
22:03:12 <chrisdone> this is relevant to my interests
22:03:44 <dmwit> newsham: If you start it, I will support it.
22:04:04 <newsham> my measly library is a fraction of the size of yours
22:04:14 <rwbarton> dmwit: I've seen a couple of packages on hackage that are basically loose collections of utility functions.
22:04:38 <wli> ACTION might try someting dumb like let isect ~(x:xs) ~(y:ys) = case compare x y of { EQ -> x : isect xs ys ; LT -> isect xs (y:ys) ; GT -> isect (x:xs) ys } ; primes = catMaybes . snd $ mapAccumL (\m n -> maybe (singleton (n*n) [n], Just n) (\((k, ps), m') -> if n /= k then (insertWith (++) (n*n) [n] m, Just n) else (Data.Map.union m' (fromListWith (++) [(k + p, [p]) | p <- ps]), Nothing)) (minViewWithKey m)) empty [2..] :: [Integer] in take 10 $ isect p
22:04:53 <dmwit> ?where twanvl
22:04:54 <lambdabot> I know nothing about twanvl.
22:04:57 <dmwit> ?where twan
22:04:58 <lambdabot> I know nothing about twan.
22:04:59 <dmwit> boo
22:05:04 <dsrogers> can  you pattern match _|_?
22:05:15 <QtPlatypus> wli: I suggest you use pastbin for that or some equivlerlent
22:05:20 <dmwit> dsrogers: No, that would be equivalent to solving the halting problem.
22:05:28 <dsrogers> ah right.
22:05:33 <dmwit> dsrogers: However, if it is _|_ because of an exception, you can catch that in the IO monad.
22:05:41 <dsrogers> because non-terminating problems are _|_
22:05:45 <wli> Yeah, the line is getting a little long.
22:06:28 <dmwit> wli: http://twan.home.fmf.nl/blog/haskell/generic-merge.details
22:07:25 <dmwit> ?where+ twanvl http://twan.home.fmf.nl/blog/
22:07:26 <lambdabot> It is forever etched in my memory.
22:18:12 <Gracenotes> @djinn (a -> a -> a) -> (a, a) -> a
22:18:13 <lambdabot> f a (b, c) = a b c
22:19:56 <sbahra> :t join
22:19:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:24:52 <mmorrow> newsham: that's a sweet idea
22:25:38 <dibblego> is there [x] -> (x -> m [x]) -> m [x] ?
22:25:56 <dibblego> (Monad m) =>
22:26:07 <newsham> *bows*
22:26:12 <Axman6> sequenc. map?
22:26:17 <Axman6> sequence*
22:26:41 <Axman6> :t sequence.map
22:26:43 <lambdabot>     Couldn't match expected type `[m a]'
22:26:43 <lambdabot>            against inferred type `[a1] -> [b]'
22:26:43 <lambdabot>     Probable cause: `map' is applied to too few arguments
22:26:43 <dibblego> that's mapM which is almost
22:27:12 <ddarius> concatMapM
22:27:27 <ddarius> :t \f -> fmap concat . mapM f
22:27:29 <lambdabot> forall a a1 (m :: * -> *). (Monad m, Functor m) => (a1 -> m [a]) -> [a1] -> m [a]
22:27:50 <dibblego> @index concatMapM
22:27:50 <lambdabot> bzzt
22:29:11 <andresj> hello, what is a good introduction to the language? :)
22:29:17 <chrisdone> Real World Haskell
22:29:24 <chrisdone> @go real world haskell
22:29:26 <lambdabot> http://www.realworldhaskell.org/
22:29:26 <lambdabot> Title: Real World Haskell
22:29:35 <rwbarton> @where LYAH
22:29:36 <lambdabot> www.learnyouahaskell.com
22:29:46 <andresj> is it readable online?
22:29:49 <chrisdone> yes
22:29:52 <newsham> two dozen easy lessons, real world haskell, learn me a haskell, programming in haskell
22:30:07 <andresj> oh it is! awesome :D
22:30:10 <andresj> thank u! :)
22:30:42 <Axman6> andresj: you should buy the book though. the online version is fairly old and buggy
22:31:15 <andresj> hum; what do you mean?
22:31:39 <Axman6> well, it's an O'Reilly book, which you should buy. gogogo!
22:32:21 <andresj> hahaha, no i meant the "old and buggy" part :P
22:33:16 <chrisdone> only a programmer would refer to a book as "buggy"
22:33:18 <chrisdone> caught red handed!
22:33:29 <Axman6> well, it had bugs in the code :\
22:34:07 <Axman6> there's bugs in the actual book too sadly :\
22:34:20 <ivanm> Axman6: the print version is buggy as well!
22:36:21 <newsham> print early print often
22:36:32 <sbahra> haha
22:43:05 <dibblego> @check \x -> all (not . null) (group x) -- is this true?
22:43:07 <lambdabot>   "OK, passed 500 tests."
22:43:25 <rwbarton> @src groupBy
22:43:26 <lambdabot> groupBy _  []       =  []
22:43:26 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
22:43:26 <lambdabot>     where (ys,zs) = span (eq x) xs
22:45:37 <dibblego> > all (not . null) (group [])
22:45:39 <lambdabot>   True
22:46:22 <Axman6> dibblego: [()] is the default for [] in quickcheck
22:46:37 <Axman6> @check \x -> all (not . null) (group (x::[Int])
22:46:37 <lambdabot>  Unbalanced parentheses
22:46:40 <Axman6> @check \x -> all (not . null) (group (x::[Int]))
22:46:42 <lambdabot>   "OK, passed 500 tests."
22:52:25 * wli writes a monadic prime sieve.
22:53:06 <wli> Is hpaste.org still dead?
22:54:13 <Axman6> @where hpaste2
22:54:14 <lambdabot> http://hpaste.org/
22:54:19 <Axman6> o.O
22:54:23 <Axman6> @where hpastetwo
22:54:24 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
22:55:23 <dibblego> @type \f a1 a2 -> f a1 a2 == EQ -- is this in the standard library?
22:55:25 <lambdabot> forall t t1. (t -> t1 -> Ordering) -> t -> t1 -> Bool
22:56:06 <Axman6> @pl \f a1 a2 -> f a1 a2 == EQ
22:56:07 <lambdabot> flip flip EQ . ((flip . ((==) .)) .)
22:56:23 <wli> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1257#a1257 <-- monadic Eratosthenes
22:58:13 <Axman6> wli: how's the performance?
22:58:35 <idnar> monadosthenes
22:58:43 <wli> Probably not very competitive.
22:59:20 <wli> It lacks basic wheel optimizations etc.
22:59:52 <pumpkin_> I use a module called ONeillPrimes I found on the primes page on the wiki
23:00:17 <wli> It should store wheel state alongside each of the primes.
23:00:31 <idnar> pumpkin_: does that use the Stargate algorithm?
23:00:48 <pumpkin_> not sure, I have to admit I just used it, without looking inside :)
23:01:23 <idnar> that was a bad joke, in case it wasn't clear :P
23:01:34 <pumpkin_> oh :)
23:07:13 <wli> I'm not sure what kind of monadic gunk a wheel amounts to.
23:11:39 <wli> I guess a list monad. ;)
23:13:25 <mightybyte> Anyone know what to do about this cabal error?  "ghc-pkg: package has duplicate dependencies: base-4.0.0.0 (use --force to override)"
23:13:36 <mightybyte> ...while installing hunit
23:15:05 <mansour> can someone explain to me what does the <+> in the following means?  xmonad { manageHook = myManageHook <+> dynamicMasterHook dynHooksRef }
23:15:39 <mansour> I am new to all this
23:15:59 <wli> The O'Neill algorithm stores wheel state alongside primes' queue entries, so it's pretty much doing all the right things.
23:16:14 <mightybyte> mansour: It may be the operator defined in Control.Arrow.
23:16:16 <wli> It's got a bunch of hacky things to get ghc to optimize it better, too.
23:16:48 <mansour> what does it do ? where I can I find out ... sorry, but I am totally lost here .
23:17:29 <pumpkin_> mightybyte: I don't think it is, I think it's xmonad-specific?
23:17:36 <pumpkin_> @hoogle (<+>)
23:17:37 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
23:17:37 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
23:17:37 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
23:17:40 <pumpkin_> oh it is!
23:17:44 <pumpkin_> you were right
23:17:49 * pumpkin_ looks embarrassed
23:18:33 <mansour> hum, wow, where do I  fit in this ?
23:18:37 <mansour> :)
23:19:03 <Gracenotes> @instances ArrowPlus
23:19:04 <lambdabot> Kleisli m
23:19:04 <pumpkin_> I think #xmonad might know more about it, although most of the people in there are probably in here too
23:19:06 <mansour> lambdabot: so it's defined in two places
23:20:09 <mansour> pumpkin_: I know this is xmonad specific, but is this a language construct ??
23:20:27 <pumpkin_> well, the language allows you to define arbitrary infix operators like that
23:20:43 <pumpkin_> a module called Control.Arrow has defined that operator, and xmonad appears to use that
23:21:16 <mansour> ok, so Control.Arrow is what I need to search for ? great
23:21:27 <pumpkin_> you might find it rather abstract :P
23:21:46 <mightybyte> mansour: You can hoogle the operator with lambdabot like pumpkin_ did, or you can go to http://haskell.org/hoogle to search for operators or functions you don't understand.
23:22:21 <mightybyte> haskell.org/hoogle will have links to the documentation
23:22:24 <pumpkin_> mansour: maybe the xmonad docs have somethign on it? what are you trying to do?
23:22:38 <mansour> ok, so hoogle is our google ?!!  I C
23:22:44 <mansour> loool
23:22:47 <wli> Not sure how they pulled it off, but they're outrunning Atkin.
23:23:02 <pumpkin_> mansour: it's a smart search engine that allows you to search by type too
23:23:31 <mightybyte> mansour: There's also Hayoo.  http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:24:41 <wli> It's probably because the asymptotics don't set in until something people wouldn't bother testing and constant factors from microoptimizations exaggerate that.
23:25:29 <mansour> mightybyte: hoogle worked for me, but the docs, for a newbee like me is amazing. Nothing understood .... lol
23:26:23 <mightybyte> mansour: Occasionally I've run across things that hoogle doesn't find but hayoo does.  So it's good to know about both.
23:28:07 <mansour> I will try the other one soon. I am still trying to understand what does this thing do ! I know it's basic question, but that's what u get when u let java programmers play with haskel. LOL
23:28:08 <pumpkin_> mansour: the Arrow stuff is rather abstract, you might want to look at xmonad itself
23:29:03 <pumpkin_> xmonad is using an ArrowPlus instance to do something specific that happens to follow a certain abstract structure
23:29:26 <mansour> abstract ?? in use ?!!! I will look into the xmonad thing.
23:32:06 <wli> SPECIALIZE pragmas don't appear to be peppered across AtkinSieve.hs as they would need to be.
23:33:34 <wli> That is, for it to be competitive.
23:34:19 <wli> OTOH the space management and/or random access for the Atkin sieve are potentially realistic reasons for it to become non-competitive.
23:58:18 <cinimod> @djinn (b -> b') -> (a -> (b' -> c)) -> (a -> (b -> c))
23:58:19 <lambdabot> f a b c d = b c (a d)
