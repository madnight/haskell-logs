00:00:35 <Axman6> ?users
00:00:35 <lambdabot> Maximum users seen in #haskell: 658, currently: 624 (94.8%), active: 13 (2.1%)
00:00:48 <Axman6> 13 active? pfft
00:02:48 <sbahra>  
00:02:49 <wli> Lots of idlers.
00:03:07 <wli> ?users
00:03:07 <lambdabot> Maximum users seen in #haskell: 658, currently: 624 (94.8%), active: 13 (2.1%)
00:15:54 <Gracenotes> too many idlers indeed -- perhaps a NAMES flood would stir up the channel?
00:16:28 <ivanm> Gracenotes: and perhaps it will get you kickbanned ;-)
00:16:32 <ivanm> @users
00:16:32 <lambdabot> Maximum users seen in #haskell: 658, currently: 625 (95.0%), active: 11 (1.8%)
00:16:41 <ivanm> wow.... even less active now... >_>
00:16:53 <Gracenotes> it would, I think
00:16:58 <Axman6> i'm upset it doesn't still have the max as 699
00:17:05 <ivanm> so.... are you going to do it? :P
00:17:14 <Gracenotes> no, I don't spam, and now isn't a good time to start.
00:17:20 <Axman6> $names cn pls halp me pls???
00:17:23 <lunabot>  luna: Not in scope: `names'
00:17:29 <Axman6> that'd do it
00:34:17 <pao> this is surely a FAQ... how do I typecheck this with base4?
00:34:33 <pao> (error "foo" :: IO ()) `Control.Exception.catch` (\e -> return ())
00:37:21 <lament> is there any haskell research in canadian universities?
00:39:17 <Deewiant> pao: you need to specify the type of e
00:39:23 <tonyIII_> "sequence_ [forkIO (time f) >> return (), time g >> return ()]" has speedup of 2 on multicore but "time $ g `par` (f `pseq` f + g)" can't, why?
00:39:53 <pao> Deewiant: what if I want to catch all instances of Exception?
00:39:58 <Deewiant> pao: if you really want to catch every single type of exception, which you probably shouldn't, e :: SomeException
00:41:02 <pao> Deewiant: thanks ... also for the advice of not catching everything :-)
00:41:23 <Deewiant> IOException is probably the most common one you need to catch
00:42:04 <hackage> Uploaded to hackage: nthable 0.1
00:42:30 <pao> Deewiant: ... I think I need ScopedTypeVariables if I want to inline the signature, right?
00:42:56 <Deewiant> pao: I use const if I want to not use extensions
00:43:03 <Deewiant> const (return ()) (e :: SomeException)
00:43:15 <pao> Deewiant: thanks a lot
00:44:24 <pao> Deewiant: type variable e doesn't seem to be in scope...
00:44:58 <Deewiant> pao: did you leave out the '\e ->'? :-)
00:45:03 <pao> yep
00:45:14 <Deewiant> well, of course you need it since we want to specify the type of e
00:45:57 <Deewiant> alternatively I guess "blaa `catch` (const (return ()) :: SomeException -> IO ())" also works
00:46:51 <pao> Deewiant: perfect... it works
00:46:52 <liwp> (error "foo") `catch` (const (return ()) :: SomeException -> IO ())
00:47:00 <liwp> yep
00:47:14 <Deewiant> that has the disadvantage that if your type changes from IO () to something else you have to change it manually
00:47:59 <pao> Deewiant: there's a way to work around that?
00:48:13 <pao> a type definition?
00:48:18 <Deewiant> pao: my original way
00:48:18 <liwp> This seems to work as well: (error "foo") `catch` (const (return ()) :: Monad m => SomeException -> m ())
00:48:32 <Deewiant> (error "foo") `catch` (\e -> const (return ()) (e :: SomeException))
00:49:31 <pao> @type \e -> const(return())
00:49:32 <lambdabot> forall t (m :: * -> *) b. (Monad m) => t -> b -> m ()
00:49:42 <pao> it requires two arguments...
00:50:04 <Deewiant> @type \e -> const (return ()) (e :: SomeException)
00:50:05 <lambdabot>     Not in scope: type constructor or class `SomeException'
00:50:07 <Deewiant> gah
00:50:10 <Deewiant> @type \e -> const (return ()) (e :: Int)
00:50:11 <lambdabot> forall (m :: * -> *). (Monad m) => Int -> m ()
00:50:21 <Deewiant> one argument, with a restricted type
00:50:58 <pao> Deewiant: how is that possible? :-)
00:51:08 <Deewiant> how not? :-P
00:51:10 <Deewiant> ?ty const
00:51:11 <lambdabot> forall a b. a -> b -> a
00:51:25 <Deewiant> we've given it 'return ()' as the first argument and 'e :: SomeException' as the second
00:51:38 <Deewiant> so that has the same type as 'return ()'
00:51:41 <pao> ahhhh!
00:51:46 <Deewiant> and then the lambda takes the e
00:51:56 <Deewiant> but we've restricted with our :: SomeException that it has a specific type.
00:52:01 <Deewiant> so we get what we want. :-P
00:52:03 <pao> I missed e as a variable (I thought it was a variable)
00:52:21 <pao> I thought it was the type variable
00:52:36 <Deewiant> no, it's just the parameter of the lambda. :-)
00:54:12 <pao> the trick with SomeException is to use existential quantification... right?
00:54:59 <Deewiant> pao: what do you mean?
00:56:00 <pao> Deewiant: in base 4 you have an Excetion type class... SomeException wraps them all by existential quantification
00:56:38 <Deewiant> Possibly, I haven't looked at it in detail. :-)
00:57:14 <liwp> data SomeException = forall e . Exception e => SomeException e
00:57:39 <liwp> that's the definition on haskell.org
00:58:38 <pao> liwp: yep...
00:58:59 <liwp> so as far as i know the forall bit is existential quantification
00:59:04 <pao> so upgrading from base3 to base4 is quite straightforward...
00:59:27 <pao> ... even if quite verbose...
01:00:06 <liwp> pao: the catch code above broken when you moved from 3 to 4?
01:00:14 <liwp> broke even
01:00:45 <pao> liwp: yep... with base 3 (ghc 6.8.3) I didn't need to add any type signature
01:01:01 <liwp> so you know why this is?
01:01:15 <lament> it would be pretty odd for forall to be existential quantification ;)
01:01:36 <liwp> lament: i must have misunderstood something then :)
01:02:14 <ski_> the `forall' there *effects* what's termed a `existential datatype'
01:02:32 <ski_> (but the `forall' itself is a universal quantification)
01:02:52 <pao> ski_: I could not say better :-)
01:03:03 <ski_> that declaration means that
01:03:14 <liwp> of course! sorry for the confusion
01:03:14 <ski_>   forall e.
01:03:23 <ski_>     Exception e =>
01:03:44 <ski_>       SomeException :: e -> SomeException
01:03:47 <pao> you have it on the right of the data definition.. not on the left...
01:03:59 <ski_> which one may write
01:04:14 <ski_>   SomeException :: forall e. Exception e => e -> SomeException
01:05:06 <liwp> I should've actually paid some attention to the terms after which it's quite clear that forall == universal and exists == existential
01:05:41 <ski_> (if you're still wondering why this creates an `existential datatype', please tell)
01:06:09 <liwp> i'm ok i think
01:06:46 <pao> ski_: would you mind to elaborate further?
01:07:20 <maltem> liwp: Maybe the confusion stems from this: The constructor of an existential datatype can wrap *any* type (satisfying some conditions) (universal), but when you look at the wrapped data again, you only know that it has *some* type (satisfying some conditions) (existential).
01:07:23 <ski_> ok .. but it is easier to see this, when not having type classes thrown into it
01:07:29 <ski_> so, suppose
01:07:59 <ski_>   data StreamProcessor a b = forall x. SP (x,(x,a) -> (x,b))
01:08:04 <ski_> this gives
01:08:23 <ski_>   SP :: forall x. (x,(x,a) -> (x,b)) -> StreamProcessor a b
01:08:48 <ski_> note that `->' binds tighter than `forall x.' so that that is
01:08:52 <ski_>   SP :: forall x. ((x,(x,a) -> (x,b)) -> StreamProcessor a b)
01:09:11 <ski_> now, standard logic tells us that this type is the same as
01:09:29 <ski_>   SP :: (exists x. (x,(x,a) -> (x,b))) -> StreamProcessor a b
01:09:39 <ski_> where the `existential' emerges
01:09:47 <ski_> questions ?
01:10:49 * pao is trying to capture the implied semantics
01:11:08 <liwp> so what do you call types that use forall in their definition? there must be some name for the type system extension.
01:11:18 <liwp> Existential Types?
01:11:26 <ski_> liwp : use `forall' *where* ?
01:11:34 <ski_> (that makes all the difference)
01:11:44 <liwp> e.g. data SomeException = forall e . Exception e => SomeException e
01:12:11 <ski_> that is commonly called `existential datatype' (as mentioned)
01:12:20 <liwp> ok
01:12:22 <liwp> thanks
01:12:37 <pao> ski_:  could you try to translate in plain english the last two notations? SP :: forall x. (( and SP:: (exists....) ....
01:13:10 <Gracenotes> > [1,2,3] >> guard True
01:13:11 <lambdabot>   [(),(),()]
01:13:22 <ski_> in the `language' extensions, that one is names `ExistentialQuantification'
01:13:31 <ski_> pao : sure
01:13:34 <ski_> @type length
01:13:35 <lambdabot> forall a. [a] -> Int
01:13:40 <ski_> or
01:13:47 <ski_>   length :: forall a. [a] -> Int
01:13:52 <ski_> which we could write like
01:13:55 <ski_>   forall a.
01:14:04 <ski_>     length :: [a] -> Int
01:14:26 <ski_> this means that for any type `a' you like, `length' has type `[a] -> Int'
01:14:34 <ski_> same with `SP'
01:14:38 <maltem> pao: The first one means that, no matter what x you give me, SP has that type. The second means that, given some x with a value of type (x,(x,a)->(x,b)), SP will accept that value.
01:14:57 <liwp> ski_: (re: ExistentialQuantification) ok, that's what i thought and that's what i was trying to refer to in the beginning of this thread
01:15:06 <ski_> for any type `x', `SP' takes an argument of type `..x..', and returns something of type `StreamProcessor a b' (which doesn't mention `x')
01:15:31 <ski_> this means that, your choice of a type `x' will not be visible in the result type of `SP'
01:15:56 <ski_> and that means that one can use different `x' types in different `SP' calls, and get the same result type
01:16:24 <ski_> so, when pattern-matching on a value of type `StreamProcessor a b', you have no idea which actual type `x' was used when constructing that particular value
01:16:24 <pao> ski_: yep I grasp it's use...
01:16:31 <ski_> i.e. the type `x' is hidden
01:16:41 <ski_> ok
01:17:28 <pao> ski_: ... moreover in this case you cannot do any "direct use" of x when you manually handle a SP...
01:18:44 <ski_> if you say "for any `x', if `x' is `prime', then `buffalo'", this is the same as saying `if there exists a `x' that is `prime', then `buffalo'"
01:19:08 <ski_> (attempting to explain the change from `forall' to `exists' in the types)
01:20:48 <ski_> (pao : yes)
01:20:52 <pao> that was the difficult point... the problem to me is that function is assimilated to implication... is that correct?
01:22:50 <ski_> yes
01:23:47 <ski_> @vixen if `a' implies `b' and `b' implies `c', does `a' imply `c' ?
01:23:47 <lambdabot> i think you know the answer to that one, silly
01:23:57 <ski_> @djinn (a -> b,b -> c) -> (a -> c)
01:23:58 <lambdabot> f (a, b) c = b (a c)
01:24:07 <ski_> (that's affirmative)
01:24:57 <Gracenotes> @src Arrow runKleisli
01:24:57 <lambdabot> Source not found. stty: unknown mode: doofus
01:25:18 <pao> ski_: how would you translate length :: forall a. [a] -> Int from a "logic" stand point (using implication)?
01:25:47 <Gracenotes> hm.. wait, no
01:25:55 <pao> for all types a if we have a list of a then we can calculate the length of type Int
01:25:59 <pao> is that it?
01:26:24 <ski_> you could phrase it that way, yes
01:27:19 <ski_> because this works for all types `a', the caller can choose any type `a' s/he likes .. but the callee (the implementation of `length') must work for *every* type
01:28:07 <ski_> if you had `exists' there instead of `forall', then the callee could choose any type s/he likes, and the caller must be able to handle any possible type
01:28:34 <ski_> i.e. if you had
01:28:47 <ski_>   foo :: exists a. [a] -> Int
01:28:48 <pao> ski_: length :: (exist a. [a]) -> Int .... correct?
01:28:56 <ski_> pao : yes
01:29:16 <pao> that would be translated as...
01:29:31 <ski_> this would mean that `foo' decides a (secret) type, and you must be able to handle any type which `foo' might have chosen
01:30:11 <ski_> (the only way to call `foo' on a ground value is to pass the empty list, since it does have type `[a]' for any type `a' .. even ones we do not see, so to speak)
01:31:02 <ski_> "`length' takes a list of type `[a]', for some type `a', and returns an `Int'"
01:31:32 <pao> ski_: last question... what's the "topic" of this discussion? predicate logic? we have being using implication in place of "function" ... where is this topic threated?
01:31:45 <pao> *treated
01:31:46 <ski_> Curry-Howard Currespondence
01:32:02 <ski_> sorry s/Curre/Corre/
01:32:20 <Gracenotes> Hm. What's the difference between an identity arrow and an endomorphic arrow?
01:32:37 <pao> ski_: thank you very much... It has been a real pleasure to hear you explanations :-)
01:32:44 <ski_> an endomorphism is any arrow having the same domain and codomain
01:32:57 <ski_> the identity arrow is a specific endomorphism
01:33:09 <lament> curryspondence?
01:33:11 <ski_> pao : i'm glad it helped
01:33:22 <ski_> (lament : i was waiting for that :)
01:34:09 <Gracenotes> ah, okay. And apparently there may be one identity arrow per object, but as many endomorphisms as one wants?
01:34:17 <ski_> (specific to each common domain-codomain, i.e.)
01:34:27 <ski_> yes, almost
01:34:46 <Gracenotes> s/may/must/
01:34:47 <chrisdone> what do you call it when g (f x) = x and f (g x') = x'?
01:34:54 <ski_> (there can't be zero endomorphisms on an object, since identity always exists)
01:35:31 <ski_> chrisdone : if  x  and  x'  are universally quantified there, then `f' is an isomorphism, and `g' is its inverse
01:35:33 <Gracenotes> makes sense.
01:35:47 <ski_> (`g' is also an isomorphism, with `f' as inverse, evidently)
01:35:53 <chrisdone> ski_: thanks, I see
01:36:29 <chrisdone> ski_: I notice that words and unwords do not have this property, and don't know what to call that
01:36:54 <ski_> chrisdone,Gracenotes : are you trying to learn some category theory ?
01:37:01 <ski_> if we have
01:37:09 <ski_>   r . s = id
01:37:15 <ski_> (but not necessarily
01:37:19 <ski_>   s . r = id
01:37:20 <ski_> )
01:37:25 <chrisdone> right
01:37:33 <ski_> then this is called a `retract situation' between `r' and `s'
01:37:33 <augustss> Galois connection, kinda
01:37:33 <lament> :t words
01:37:34 <lambdabot> String -> [String]
01:37:39 <Gracenotes> I've been learning it on and off. At the moment I'm reading through something on scienceblogs.com/goodmath... go on :)
01:37:48 <ski_> `r' is called the `retraction' of `s'
01:37:58 <ski_> `s' is called the `section' of `r'
01:38:03 <ski_> (actually s/the/a/)
01:38:25 <chrisdone> ah, it's like r /retracts/ the changes of r
01:38:33 <Gracenotes> ski_: well, s . r may = id, but a different kind of id than r . s, right?
01:38:35 <chrisdone> er, the changes of s
01:39:22 <dreixel> how can I currently create an account on the Haskell wiki?
01:39:25 <chrisdone> ski_: continue please :-)
01:39:45 <ski_> Gracenotes : assume `s : A >-> B',`r : B >-> A', then if `r . s = id_A' and `s . r = id_B', then `r' and `s' are isomorphisms
01:40:04 <ski_> (so those two `id' need not be over the same object)
01:40:12 <chrisdone> what does 's : A >-> B' say?
01:40:28 <ski_> `s' is a morphism with domain `A' and codomain `B'
01:40:31 <Gracenotes> ah, okay. And s . .r, if not id_B, is probably some endomorphism, then
01:40:46 <ski_> (`morphism',`arrow' is the same concept)
01:40:57 <chrisdone> ski_: is this at all comparable with haskell's type system?
01:40:59 <chrisdone> oh right
01:41:23 <ski_> (augustss : really ?)
01:41:52 <blackh> dreixel: You will have to track down the administrators, but I can't help you much there.
01:41:53 <chrisdone> :t (>>>)
01:41:54 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
01:42:04 <hackage> Uploaded to hackage: BASIC 0.1.5.0
01:42:16 <chrisdone> so here a is the morphism, b is the domain and c is the codomain?
01:42:19 <Gracenotes> > let intid :: Int -> Int; intid = read . show in intid 49293
01:42:20 <lambdabot>   49293
01:42:23 <ski_> no
01:42:38 <dreixel> blackh: thanks
01:42:48 <ski_> a value of type `a b c' would be a morphism (with domain `b' and codomain `c')
01:42:58 <chrisdone> oh I get it
01:43:04 <ski_> `a' there corresponds to `>->' above
01:43:10 <Gracenotes> > let notstringid :: String -> String; notstringid = show . (read :: Int->Int) in notstringid "00032"
01:43:11 <chrisdone> right
01:43:11 <lambdabot>   Couldn't match expected type `Int' against inferred type `String'
01:43:28 <Gracenotes> > let notstringid :: String -> String; notstringid = show . (read :: String->Int) in notstringid "00032"
01:43:30 <lambdabot>   "32"
01:43:31 <blackh> dreixel: One way might be to use one of the code.haskell.org web forms, but there must be a better way than that.
01:43:32 <chrisdone> my GHC version gives
01:43:34 <chrisdone> (>>>) :: (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
01:43:52 <chrisdone> ski_: is it right to call 'a' a category?
01:44:07 <chrisdone> ski_: the 'a' corresponding to >->?
01:44:13 <ski_> yes .. more or less
01:44:21 <Gracenotes> chrisdone: that's an example of Int -> Int being basically id by read . show, but String -> String not being by show . read
01:44:25 <dreixel> blackh: I guess I have to contact John Peterson: http://www.haskell.org/haskellwiki/User:John_Peterson
01:44:29 <ski_> not every category can be expressed through that type-class
01:44:45 <ski_> (and the type-class doesn't capture the laws explicitly)
01:45:08 <chrisdone> ok
01:45:12 <ski_> a simple exercise :
01:45:34 <ski_> assume `r',`s' forms a `retract situation'. prove `s . r' is idempotent
01:46:53 <gio123> ski_:hi
01:46:59 <Gracenotes> hm. What use is a section?
01:47:46 <chrisdone> ski_: `r',`s' forms a retract situation because r · s = id?
01:48:04 <ski_> chrisdone : yes, that's according to the definition
01:48:09 <chrisdone> ok
01:49:11 <Gracenotes> well, s . r should leave you in the same object you started out in
01:49:43 * ski_ tries to figure out a nice example
01:49:48 <chrisdone> words . unwords is a retract situation?
01:50:00 <Gracenotes> ski_: what do you mean by idempotence in terms of category theory?
01:50:22 <ski_> an endomorphism `f' is `idempotent' whenever `f . f = f'
01:50:23 <chrisdone> I thought he meant that s · r = s · r · s · r
01:51:03 <ski_> @check \x -> (words . unwords) x == x
01:51:05 <lambdabot>   "Falsifiable, after 1 tests:\n[\"\\948786\\60879\",\"\"]\n"
01:51:09 <Gracenotes> ah. So due to associativity,  (s . r) . (s . r) = s . (r . s) . r = s . id . r = s . r
01:51:20 <ski_> yes
01:51:57 <ski_> > (words . unwords) ["\948786\60879",""]
01:51:58 <lambdabot>   ["\948786\60879"]
01:52:05 <ski_> > (words . unwords) [""]
01:52:07 <lambdabot>   []
01:52:14 <ski_> chrisdone : so, no
01:52:29 <chrisdone> oh :(
01:52:48 <ski_> > unwords [""]
01:52:48 <Gracenotes> not the other way, either :(
01:52:49 <lambdabot>   ""
01:52:59 <ski_> it might be nice if that gave
01:53:02 <ski_>   "\n"
01:53:19 <Gracenotes> > (words . unwords) ["some example", "text", "to use"]
01:53:20 <lambdabot>   ["some","example","text","to","use"]
01:53:47 <Gracenotes> > (unwords . words) "some   example      text to   use"
01:53:49 <lambdabot>   "some example text to use"
01:54:07 <idnar> @check \x -> (unwords . words) x == x
01:54:08 <lambdabot>   "Falsifiable, after 107 tests:\n\"\\667891\\79505\\958582\\196891\\910447\\...
01:54:35 <chrisdone> I see how (s · r) · (s · r) can be reduced to s · r but wouldn't have figured it out myself
01:55:13 <ski_> Gracenotes : consider `B' the set of pupils in a school, and `A' the set of pupil classes. now `r : B >-> A' maps each pupil to her/his class
01:55:35 <ski_> Gracenotes : a section `s : A >-> B' might map each class to a class representative pupil
01:55:46 <ski_> (who has to be a member of that class)
01:56:50 <ski_> (btw, the axiom of choice is classically equivalent to saying that every retraction function has a section)
01:57:57 <Gracenotes> ski_: hm.. what are objects in that scenario?
01:58:06 <ski_> `A' and `B'
01:58:14 <ski_> (maybe more. not specified)
01:58:29 <Gracenotes> huh. What role do the elements of A and B play, then?
01:59:12 <ski_> (the pupils themselves are not `objects' in the sense of CT here, nor are the pupil classes)
01:59:39 <ski_> they act like "types" for the inputs and outputs of the morphisms
02:00:55 <ski_> (e.g. it's not meaningful to ask what the pupil class of a pupil class is)
02:01:22 <Gracenotes> is s . r /= id possible here?
02:01:45 <ski_> yes
02:02:42 <ski_> (in fact, that would be the nontrivial, common case)
02:03:09 <Gracenotes> ski_: hm.. how so? I'm having trouble thinking about it in terms other than set membership
02:03:42 <ski_> there is no problem thinking about sets in terms of set membership ..
02:03:55 <ski_> .. as long as you can restate what you want in other terms
02:04:00 <ski_> (if needed)
02:04:11 <ski_> consider `B' being the set
02:04:17 <ski_>   {alice,bob}
02:04:27 <ski_> so there's only two pupils at this school
02:04:36 <ski_> and say `A' is
02:04:44 <ski_>   {1A}
02:04:52 <ski_> so there's only one class
02:05:03 <Gracenotes> right
02:05:05 <ski_> now, we need some `r : B >-> A'
02:05:21 <ski_> any suggestion for what function `r' might be here ?
02:05:51 <ski_> (need i go on ?)
02:06:07 <Gracenotes> r _ = {1A}
02:06:17 <Gracenotes> or, er, 1A.
02:06:20 <ski_> yes
02:07:05 <ski_> so, now we need to choose some `s : A >-> B' such that `r . s = id_A' but `s . r =/= id_B'
02:07:05 <Gracenotes> so r . s is a section on s, I suppose
02:07:32 <_sana> Failed to load interface for `Network.Socket':
02:07:37 <_sana> what can i do ?
02:08:12 <ski_> Gracenotes : do you mean `s . r . s = id' ??
02:08:20 <Gracenotes> oh.. I've got the (.) operator confused in my head
02:09:06 <osfameron> eeeek!  partially applying composition on your head can be very painful
02:09:18 <Gracenotes> so s can be either alice or bob then
02:10:09 * ski_ composes osfameron's head with Gracenotes'
02:10:44 <ski_> `alice' and `bob' are elements of the set `B' (which is an object)
02:10:45 * osfameron mocks the mockingbird
02:11:17 <ski_> `s' however, should be a function from `A' to `B'
02:11:51 <Gracenotes> in the set category, s is a function in the 'hat' sense?
02:12:15 <Gracenotes> q hat ({1,2,3}) = {1,4,9}, for squaring
02:12:16 * ski_ doesn't know 'hat' functions
02:12:37 <Gracenotes> it's just notation I used for functions on sets in a course on CS I had
02:12:48 <Gracenotes> or rather, that the professor used
02:12:49 <ski_> `q' there being ?
02:13:07 <ski_> the square function ?
02:13:14 <Gracenotes> q(4) = 16, but q hat({4}) = {16}
02:13:18 <ski_> the non-negative square root function ?
02:13:32 <ski_> ok, that `hat' sounds like `fmap' in haskell
02:14:14 <ski_> > square `hat` [1,2,3]  where square x = x*x; hat = fmap
02:14:15 <lambdabot>   [1,4,9]
02:14:40 <Gracenotes> mm, it is, I think. But.. suppose s always yields {alice}.
02:15:03 <ski_> `s' is supposed to return an element of `B' .. not a subset of `B'
02:15:08 <Gracenotes> {alice,bob} -> {1A} -> {alice}, not an identity (it seems?)
02:15:12 <pao> @seen mcella
02:15:12 <lambdabot> I haven't seen mcella.
02:15:18 <ski_> so maybe you meant `s' returns `alice' ?
02:15:19 <ski_> i.e.
02:15:27 <Gracenotes> ah. Then it returns alice.
02:15:28 <ski_>   s(1A) = alice
02:16:08 <ski_> and yes, then `s . r' is not the identity over `B'
02:16:48 <Gracenotes> are arrows between sets anything like the list monad?
02:17:11 <ski_> no
02:17:12 <Gracenotes> except with idempotence, of course
02:17:36 <Gracenotes> I mean monad in the Haskell-y sense. List comprehension will work too.
02:17:37 <ski_> i don't understand what you mean
02:17:56 <ski_> are you talking about the above situation with pupils ?
02:18:07 <ski_> or maybe you're talking about the `hat' you mentioned ?
02:18:30 <Gracenotes> Yes... about the pupils. I can see how arrows are composed.. but how are 'applied'?
02:18:41 <Gracenotes> can they be?
02:18:54 <Gracenotes> 'applied' in an informal sense
02:19:08 <ski_> (it may help to realize that there's here two different uses of sets, (a) as domains,codomains (objects) of functions (morphisms) (b) as subsets of some ambient set(s))
02:20:00 <ski_> since the objects here are certain sets, and the arrows are certain functions, then yes you can apply the arrows on "elements of the objects"
02:20:20 <ski_> however, in general in category theory, there may not be something like "elements of the objects"
02:20:23 <koeien> element-reasoning in CT
02:20:26 <koeien> i don't like it
02:21:01 <Gracenotes> koeien: that's okay, you can cover your eyes :)
02:21:11 <koeien> :)
02:21:38 <ski_> if the point is to use category theory for something, then usually one would try to rephrase most things without mentioning "elements", then do work in CT .. then possibly at the end interpret the result in terms of elements
02:22:11 <ski_> Gracenotes : do you e.g. know the definition of `injective' ?
02:22:27 <Gracenotes> yes
02:22:37 <Gracenotes> f(a) = f(b) -> a = b, iirc
02:22:42 <koeien> yes
02:23:00 <ski_> there's a concept in CT that's similar to that, but doesn't mention elements such as `a',`b', there
02:23:13 <ski_> this is the concept of `monomorphism'
02:23:17 <koeien> mono/epi
02:23:44 <Gracenotes> is that having only one arrow between two objects..?
02:23:48 <chrisdone> I knew injective :P
02:23:52 <ski_> in the category of sets and (total) functions, the monomorphisms are exactly the injective functions
02:23:54 * chrisdone beams
02:24:40 <ski_> by "categorifying" concepts such as `injective', one may try to apply them in other category, and see whether the concept is useful there
02:24:46 <ski_> (which often seems to be the case)
02:25:13 <koeien> there are categories where mono != injective
02:25:38 <ski_> (koeien : first you have to define `injective' for those categories :)
02:26:03 <ski_> (koeien : but yes, there are categories concrete over `Set' where that inequality holds)
02:26:23 <Gracenotes> one place where things get confusing is between comparing the internal structure of categories and treating categories as objects with arrows between them
02:26:24 <koeien> ski_: an arrow f is called injective if forall g1, g2, fg1 = fg2 implies g1=g2 right?
02:26:49 <ski_> that's the definition of `f' being `mono'
02:26:58 <koeien> ehm yeah
02:26:58 <koeien> mono
02:27:18 <koeien> (you need typing here, f : A->B, g1,g2 : C -> A)
02:27:21 <ski_> Gracenotes : anything special in mind ?
02:27:50 <koeien> i recall an example in group theory where injective /= mono, but I forgot :(
02:28:18 <Gracenotes> monomorphism, as you mentioned. To what extent is there monomorphism between categories?
02:28:42 <z0d> I read Real World Haskell; "A source file must have the same base name (the component before the suffix) as the name of the module it contains.". Is it case-sensitive?
02:29:04 <koeien> z0d: on case-sensitive filesystems, yes iirc. i've never tried otherwise :)
02:29:25 * ski_ fetches "Abstract and Concrete Categories: The Joy of Cats"
02:29:26 <koeien> on Windows you can't help it
02:29:35 <BONUS> i'd suggest using names like Module.hs just in case
02:29:47 <koeien> BONUS: yeah everybody does it :) so it must be good style
02:29:55 <koeien> even if it works otherwise
02:30:15 <earthy> the one exception ofcourse is for module Main
02:31:15 <koeien> why doesn't haskell call a 'module' a 'package' instead?
02:31:34 <earthy> because packages can consist of multiple modules
02:31:47 <koeien> modules are other things in mathematics
02:31:52 * earthy nods
02:32:06 <earthy> however, in cs the term 'module' is quite old and accepted
02:32:16 <ski_> Gracenotes : a functor is an `embedding' when the object-mapping is injective, and every morphism-mapping is injective
02:32:35 <ski_> Gracenotes : a functor is `faithful' when every morphism-mapping is injective
02:33:13 <Gracenotes> mm.
02:33:33 <Gracenotes> maybe I generally should ignore cross-category stuff for now, save maybe functors
02:34:18 <koeien> ski_: do you recommend the joy of cats instead of TTT ?
02:35:39 <ski_> Gracenotes,chrisdone : you might want to check out a book called "Conceptual Mathematics" by Schanuel and Lawvere .. it's a quite basic nice book on CT that doesn't require you to know lots of math fields to understand the examples
02:36:48 <ski_> koeien : i haven't read TTT very much, yet .. the joy of cats seems quite nice, but probably not for every beginner
02:37:34 <koeien> ski_: i have no problem following the mathematical examples in TTT where they give them :) (topological spaces, groups, sets, monoids, semi-groups)
02:37:59 <ski_> (obviously i started by loaning a bunch of interesting-looking books and plunged head-in .. that may not be for everyone, though)
02:38:13 <koeien> yes that's what i'm doing right now
02:38:42 <koeien> but if somebody says what to avoid and what is good/nice, i can save some time
02:38:44 <koeien> :)
02:39:43 <Gracenotes> CT does have some clear applications with respect to Haskell's type category, but it doesn't seem to seem so helpful of an introduction to abstract algebra as, say, group theory
02:40:56 <koeien> if you want to start with algebra i would start with finite fields and groups
02:41:09 <koeien> instead of jumping into CT
02:41:24 <Gracenotes> my library probably has some useful undergrad-level books on it, I should think
02:42:30 <Gracenotes> aha, though. It also has "Conceptual mathematics : a first introduction to categories" :)
02:42:37 <Workybob> @users #macosxdev
02:42:37 <lambdabot> Maximum users seen in #macosxdev: 43, currently: 44 (102.3%), active: 1 (2.3%)
02:42:40 <Workybob> uhhuh?
02:43:59 <koeien> Gracenotes: ha! my uni has it too
02:45:46 * mjrosenb would guess that lambdabot includes itself in one count and not the other
02:45:50 <mjrosenb> maybe?
02:46:53 <mjrosenb> also, is there any way to get the full path to an executable given it's name?
02:53:20 <Ferdirand> mjrosenb: which ?
02:54:10 <mjrosenb> Ferdirand: i was hoping for a haskell function
02:56:51 <Gracenotes> mjrosenb: most OSes I know of can't even do that :)
02:57:15 <Gracenotes> without a full search, that is (e.g. find)
02:57:46 <mjrosenb> Gracenotes: well it only needs to be restricted to things in the path
02:57:52 <mjrosenb> *and*
02:57:53 <Ferdirand> System.Dir.findExecutable ?
02:58:08 <mjrosenb> bash/tcsh does this on a fairly regular basis
02:58:15 <Ferdirand> s/Dir/Directory/
02:58:34 <Gracenotes> mjrosenb: well, only things that are in the PATH
02:58:37 <mjrosenb> Ferdirand: yeah, that's it
02:58:45 <ski_> @type System.Directory.findExecutable
02:58:46 <lambdabot> String -> IO (Maybe FilePath)
02:58:54 <pejo> mjrosenb, your program can be removed after it is started.
02:58:58 <Gracenotes> oh, so Haskell checks the current PATH for you
02:59:15 <mjrosenb> pejo: not the answer to the question that i asked, but close
02:59:18 <Gracenotes> mjrosenb: okay. But as you know, you can't just find any executable :)
02:59:30 <Gracenotes> sorry, was confused
03:00:39 <pejo> mjrosenb, I think Gracenotes answered your question though, I just added the information that even if you do have the binary name it doesn't have to exist when you do the search.
03:02:11 <mjrosenb> pejo: yes, there are race conditions, but if i say that 'flac' is a prerequisite to run this, i expect flac to be in $PATH somewhere or other
03:02:46 <cizra> shapr: Write a wrapper for some already existing C lib?
03:04:14 <Gracenotes> indeed, Haskell does manually search through PATH
03:04:33 <Gracenotes> path <- getEnv "PATH"; search (splitSearchPath path)
03:04:46 <Gracenotes> *GHC
03:08:13 <pejo> mjrosenb, ah, you're not trying to find the path to the binary you're currently executing. That's good to hear.
03:13:07 <anakreon> Hello list. I'm trying to implement a program which uses hxt. I have problems understanding arrows.
03:13:38 <anakreon> I have summerized the problems at: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1281#a1281
03:14:41 <anakreon> I hope someone could provide some advices. After 4 days I struggles with arrows I'm ready to give up.
03:16:56 <mmorrow> @src CInt
03:16:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:21:49 * juhp_ thinks it would be nice if hackage showed a changelog at the bottom of package pages
03:22:25 <pozic> anakreon: you probably have difficulties understanding HXT, which is not the same as understanding arrows. HXT has a very unfriendly API and the best thing to do would be to avoid it.
03:22:32 <doserj> anakreon: your point c) should work if you use "-<<" instead of "-<"
03:23:05 <pozic> juhp_: and select by license, by number of downloads and so on.
03:23:20 <juhp_> yeah
03:23:30 <pozic> juhp_: and a fork Hackage instruction
03:23:37 <juhp_> and a bug a tracker and ...
03:23:50 <pozic> juhp_: and cryptographic signatures.
03:23:50 <doserj> anakreon: s/c)/b)/
03:23:57 <juhp_> let's to do :)
03:23:59 <pozic> juhp_: I could continue this for days ;)
03:24:16 <koeien> there are efforts to port hackage to happstack
03:24:22 <juhp_> what is they say: "talk is cheap..." :)
03:24:29 <juhp_> koeien: awesome
03:24:38 <mmorrow> and someone to pay someone to do all of this ... ;)
03:24:40 <pozic> This awesome thing is getting old.
03:24:59 <juhp_> mmorrow: profit!
03:25:08 <mmorrow> case closed.
03:25:10 <juhp_> :)
03:25:12 <mmorrow> :)
03:25:16 <juhp_> lol
03:25:28 <mmorrow> hehe
03:25:51 <anakreon> doserj: I dont't understand s/c)/b)/. I'm working on point c) after your sujestion
03:26:20 <doserj> I meant, my comment was regarding point b), not point c)...
03:27:32 <juhp_> so is happs already "old hat"? :)  wonder how much happstack has moved from it
03:28:04 <ski_> (<http://www.lemonamiga.com/games/details.php?id=1255>)
03:28:25 <koeien> juhp_: almost nothing yet
03:28:32 <juhp_> ok
03:28:33 <koeien> juhp_: it should be (mostly) compatible now
03:28:39 <juhp_> I see
03:28:48 <koeien> however, this will change in the future :)
03:28:52 <juhp_> sure
03:29:11 <juhp_> koeien: are you working on it? :)
03:29:28 <koeien> HAppS programs should compile on happstack 0.1 & 0.2, save for a few name changes (HAppS -> Happstack)
03:29:34 <koeien> juhp_: a bit, yes
03:29:37 <juhp_> cool
03:30:01 <juhp_> happs-tutorial-0.7.1 depends on Crypto-4.1.0 which failed to install.
03:30:09 <anakreon> about point c: I changed the code to:
03:30:11 <anakreon>              subs <- process_doc >>> sub_li -<< get_id ref2
03:30:11 <anakreon>                       -< url (reverse . tail . dropWhile (/= '#') . reverse $ ref1)
03:30:11 <anakreon>  
03:30:15 <juhp_> maybe I should unwind Crypto
03:30:30 <koeien> juhp_: you can try to ask #happs for this. I know happstack ships its own Crypto library
03:30:40 <juhp_> ah ok
03:30:59 <juhp_> maybe I will just try that first
03:31:08 <anakreon> doserj: Is this what you suggest? However, I have an error with message ref2 Not in scope.
03:31:28 <pejo> Any op awake?
03:31:38 <anakreon> process_doc needs a parameter, the url, and sub_li and other one, the current habitat id
03:32:05 <koeien> juhp_: i don't know anything about happstack-tutorial though
03:32:13 <juhp_> :)
03:32:18 * Baughn just caught a potential race condition with quickcheck
03:32:51 <doserj> anakreon: I thought you wanted something like " subs <- process_doc >>> sub_li (get_id ref2) -<< url ..."
03:33:44 <pejo> @where ops
03:33:44 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
03:33:56 <anakreon> Yes. But that also produces a message ref 2 not in scope.
03:34:06 <dibblego> pejo, ?
03:34:53 <pejo> dibblego, take a closer look at Blastyou, "Reklamos Botas WwW.BlasteR.VisiemS.l..".
03:35:05 <anakreon> Sorry. The error message is different. I forgot to replace -< with -<<.
03:35:10 <juhp_> ah I see happs-tutorial is for happstack
03:36:00 <anakreon> doserj: Your suggestion workded fine. I'll check the docs on the difference of -< and -<<.
03:36:27 <koeien> juhp_: yeah you need happstack 0.1 i believe.
03:36:42 <anakreon> If I can pass one parameter to sub_li, maybe I can pass more and avoid the state usage.
03:36:47 <koeien> juhp_: HAppS is orphaned so there is little reason to stick with that atm
03:38:19 <juhp_> ok
03:38:42 <koeien> juhp_: everything should compile though, if you're on Windows some obscure error message in Network shows up (this is known)
03:38:56 <juhp_> Linux
03:39:37 <koeien> juhp_: there is no problem on any gnu/linux system i know of :) also not on macs. most devs use osx or debian/ubuntu i believe :)
03:40:45 <pejo> dibblego, thank you.
03:44:23 <anakreon> pozic: What would you suggest I used instead of hxt?
03:44:34 <mmorrow> if anyone is wondering how ghc translates "mdo", i just came across this comment: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1282#a1282
03:52:11 <mmorrow> i _think_ this is what that's saying: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1282#a1283
03:53:14 <mmorrow> , mdo x <- (0:xs); return (x+1)
03:53:15 <lunabot>  luna: Not in scope: `xs'
03:54:16 <ski_> hm, isn't there an extension allowing `do ...; rec {...}; ...' ?
03:54:32 <ski_> (which that comment possibly is talking about)
03:54:44 <mmorrow> mdo ?
03:55:32 <mreh> does anyone know a better way of doing this \(x:xs) -> zipWith f (x:xs) xs ++ [x] ??
03:56:13 <mreh> for example transforming a list of verticies in a polygon into a list of vectors
03:56:53 <mmorrow> > runST
03:56:54 <lambdabot>       Overlapping instances for Show ((forall s. ST s a) -> a)
03:56:55 <lambdabot>        arising...
03:57:06 <mmorrow> > newSTRef
03:57:07 <lambdabot>       Overlapping instances for Show (a -> ST s (STRef s a))
03:57:07 <lambdabot>        arising f...
03:57:14 <SamB> mreh: besides the fact that you are missing a pair of parens ?
03:57:17 <mmorrow> > mdo return 2
03:57:18 <lambdabot>       No instance for (Show (t1 t))
03:57:18 <lambdabot>        arising from a use of `show' at <i...
03:57:23 <mmorrow> @let untilST p f x = mdo k <- newSTRef (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); ref <- newSTRef x; join (readSTRef k) >> readSTRef ref
03:57:23 <lambdabot>  <local>:42:22: parse error on input `<-'
03:57:36 <mmorrow> hmm
03:57:46 <mmorrow> i guess @let has different flags on
03:58:29 <blackh> mreh: I don't quite understand what you're trying to do.
03:58:59 <mreh> let zipWrap f (x:xs) = zipWith f (x:xs) (xs++[x]) in zipWrap (\a b -> (a,b)) [1..10]
03:59:10 <mreh> > let zipWrap f (x:xs) = zipWith f (x:xs) (xs++[x]) in zipWrap (\a b -> (a,b)) [1..10]
03:59:11 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,1)]
03:59:16 <mreh> that
03:59:26 <mmorrow> , runST (mdo cont <- newSTRef (readSTRef ref >>= \x -> if x > 100000000 then writeSTRef cont (return()) else writeSTRef ref (x*3) >> join (readSTRef cont)); ref <- newSTRef 2; join (readSTRef cont) >> readSTRef ref)
03:59:27 <lunabot>  258280326
03:59:49 <mreh> i suppose that's quite neat, is there a library function to do that?
04:00:24 <Ogedei> what is the precedence of operators that don't have an infix/infixl/infixr declaration?
04:00:48 <blackh> mreh: Not that I know of.  Thinking...
04:01:28 <mmorrow> , runST (mdo cont <- newSTRef (readSTRef ref >>= \x -> if x > 100000000 then writeSTRef cont (return x) >> return x else writeSTRef ref (x*3) >> join (readSTRef cont)); ref <- newSTRef 2; join (readSTRef cont))
04:01:29 <lunabot>  258280326
04:02:00 <doserj> > zip `ap` (tail.cycle) $ [1..10]
04:02:09 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,1)]
04:02:35 <blackh> doserj: Nope - I can't do better than that.
04:03:27 <mmorrow> cont :: STRef s (ST Int), and cont is a ref to a computation which overwrites itself with a (return x) computation when it's done
04:03:59 <Peaker> mmorrow: isn't that much like a thunk?
04:04:00 * mmorrow just had to say that in words to get it straight
04:04:14 <mreh> cheers doserj
04:04:37 <Peaker> mmorrow: what's the difference
04:04:44 <Peaker> mmorrow: between that and a thunk?
04:05:00 <mmorrow> Peaker: it's self-referential, and once it wants to stop looping it overwrites itself. so yeah, i guess that's equivalent to the underlying thing that's happening with   fix (\x -> ... )
04:05:24 <doserj> mreh: using the (->) Monad is of course a bit troublesome.
04:05:51 <mmorrow> Peaker: well, it first overwrites itself, then jumps to itself
04:06:01 <mmorrow> (which is no longer itself at that point, but the result
04:06:02 <mmorrow> )
04:06:15 <mreh> doserj: -> is a monad?!
04:06:30 <doserj> @instances Monad
04:06:30 <BONUS> (->) r
04:06:30 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:06:30 <mreh> im just making an anonymous function
04:06:52 <blackh> doserj: Bonkers. I had zip x (tail . cycle $ x)
04:07:02 <Peaker> mreh: functions of some argument are monads, where the "content" or "computation result" of the monad is the function result
04:08:19 <blackh> The day when I don't learn something new in #haskell is a bad day.
04:08:54 <shapr> blackh: monotremes lay eggs.
04:08:55 <mreh> what does $ do?
04:09:06 <skorpan> function application
04:09:06 <doserj> mreh: it saves parantheses
04:09:10 * shapr cackles evilly
04:10:01 <mreh> does it have high precedence then?
04:10:10 <mreh> @type $
04:10:11 <lilac> blackh: zip `ap` liftA2 (++) tail (return . head)
04:10:11 <lambdabot> parse error on input `$'
04:10:17 <blackh> shapr: Slow down!
04:10:18 <skorpan> @type ($)
04:10:20 <lambdabot> forall a b. (a -> b) -> a -> b
04:10:25 * shapr snickers
04:10:35 <skorpan> THIS IS BAT COUNTRY
04:10:43 <koeien> mreh: no, really low
04:10:47 <doserj> infixr 0 $
04:12:47 <mmorrow> , runST (do (_,_,out) <- mfix (\ ~(cont,ref,out) -> do cont <- newSTRef (readSTRef ref >>= \x -> if x > 100000000 then writeSTRef cont (return x) >> return x else writeSTRef ref (x*3) >> join (readSTRef cont)); ref <- newSTRef 2; return (cont, ref, join (readSTRef cont))); out)
04:12:48 <lunabot>  258280326
04:12:54 <mmorrow> following that translation
04:13:22 <mmorrow> (at first i tried:
04:13:23 <mmorrow> , runST (do (_,_,out) <- mfix (\ ~(cont,ref,out) -> do cont <- newSTRef (readSTRef ref >>= \x -> if x > 100000000 then writeSTRef cont (return x) >> return x else writeSTRef ref (x*3) >> join (readSTRef cont)); ref <- newSTRef 2; out <- join (readSTRef cont); return (cont, ref, out)); return out)
04:13:25 <lunabot>  luna: out of memory (requested 2097152 bytes)
04:23:30 <cognominal> does someone know how to fix pandoc for ghc 6.10.1?
04:24:25 <maltem> cognominal: maybe - what error do you get, something about Exceptions?
04:24:32 <MyCatVerbs> Apparently you can't put something of kind (* -> *) on the right hand side of a typeclass?
04:25:06 <cognominal> I got   cabal: Error: some packages failed to install:
04:25:06 <cognominal> pandoc-1.1 failed during the building phase. The exception was:
04:25:06 <cognominal> exit: ExitFailure 10
04:25:27 <FunctorSalad_> right hand side of a typeclass? :)
04:25:29 <cognominal> not very helpful
04:25:39 <dcoutts> cognominal: ExitFailure 10 is more interesting that usual :-)
04:25:49 <maltem> cognominal: Better unpack the package to a directory and install it from there. (Funny you should get such an unhelpful error)
04:25:51 <FunctorSalad_> yeah usually it's 1
04:25:51 <dcoutts> cognominal: you've got to look further up to see how it really failed
04:26:01 <maltem> cognominal: cabal fetch pandoc
04:26:10 <FunctorSalad_> you could also try "cabal install -v pandoc"
04:26:21 <FunctorSalad_> (verbose)
04:26:31 <cognominal> I guess I should read more about cabal
04:26:36 <dcoutts> maltem: it's not odd to get such an unhelpful error, that's standard :-) however there is invariable more detail higher up in the build output
04:26:37 <ski_> MyCatVerbs : ?
04:26:38 <SamB> dcoutts: hmm. it really ought to say WHAT failed with that status :-(
04:26:46 <maltem> cognominal: maybe, but that wouldn't help you with your problem :)
04:27:16 <MyCatVerbs> ski_: I'm trying to do, instance (Ord a) => Thingy (TSet a a) (TSet a), where TSet is of kind (*->*).
04:27:19 <dcoutts> SamB: the ExitException doesn't hold that info, which just goes to show we shouldn't throw it :-)
04:27:33 <maltem> dcoutts: So they *do* get the detailed error. That's what I wondered about
04:27:51 <SamB> dcoutts: well, yeah
04:27:52 <ski_> MyCatVerbs : if `TSet :: * -> *', then `TSet a a' is a kind error, just like
04:27:56 <ski_> > not True False
04:27:56 <ski_> is
04:27:57 <lambdabot>   Couldn't match expected type `Bool -> t'
04:28:00 <dcoutts> maltem: yes, but only as the stdout output of the tool that failed
04:28:06 <SamB> why is there such an exception anyway ?
04:28:24 <ski_> (.. a type error)
04:28:38 <FunctorSalad_> maybe you just can't have partially applied tycons in the class
04:28:40 <maltem> dcoutts: well that's as good as it gets, no? (Hoping for stderr to be included)
04:28:47 <dcoutts> SamB: it's the exception you throw to have your process exit with an error code
04:28:48 <FunctorSalad_> (instance)
04:28:49 <MyCatVerbs> ski_: oops, brainfart. TSet :: (* -> * -> *).
04:28:55 <SamB> the only time you should consider throwing such a thing is if you *might* want to exit with that status ...
04:29:07 <dcoutts> maltem: well Cabal could at least say which command failed.
04:29:27 <ski_> MyCatVerbs : there shouldn't be a problem with having a type class `Thingy' with one argument of kind `*' and another of kind `* -> *'
04:29:37 <maltem> dcoutts: ok true
04:29:39 <SamB> you shouldn't throw it when a subprocess fails!
04:29:43 <ski_> (this is/was called `constructor classes')
04:30:17 <dcoutts> SamB: well, I think you mean we should catch it and translate it into a different exception
04:30:30 <SamB> who threw it ?
04:30:47 <maltem> cognominal: well, did you find the actual error message?
04:31:11 <dcoutts> SamB: rawSystemExit
04:31:22 <SamB> dcoutts: and who called that ?
04:31:33 <dcoutts> SamB: it's used in Cabal for running things
04:32:02 * SamB thinks rawSystemExit had no bussiness throwing ExitException
04:32:06 <FunctorSalad_> maybe throw the stderr of the executed process instead
04:32:20 <dcoutts> SamB: yes, it's much better than returning an ExitCode
04:32:29 <SamB> it could sure throw SOMETHING
04:32:32 <SamB> but why that?
04:32:48 <dcoutts> SamB: because it describes exactly the info available
04:33:00 <SamB> but doesn't rawSystemExit also know what command it ran ?
04:33:06 <MyCatVerbs> ski_: hrmn. 'Tis not working though. GHC tells me that (TSet a) has kind (*->*) (which is exactly what I want, of course) but only things of type (*) are allowed in that position.
04:33:23 <dcoutts> SamB: well yes, but that just means having to fail "with a useless error message"
04:33:25 <SamB> also, it isn't suggesting that Cabal terminate with the same exit code, is it ?
04:33:32 <SamB> dcoutts: hmm ?
04:33:53 <SamB> dcoutts: can't you use a new exception ?
04:34:03 <dcoutts> SamB: no, it has to work with base 3
04:34:25 <SamB> dcoutts: and ?
04:34:25 <doserj> MyCatVerbs: well, what does your class declaration say?
04:34:54 <dcoutts> SamB: therefore we cannot use the new style extensible exceptions
04:34:54 <ski_> MyCatVerbs : you might need an explicit kind signature in the type class definition, to avoid defaulting to `*'
04:35:17 <MyCatVerbs> doserj: just (class Thingy a b). Would you believe I don't know the syntax for declaring the kinds?
04:35:28 * SamB wishes the haddock for this package was built with GHC 6.8:
04:35:31 <SamB> http://hackage.haskell.org/packages/archive/extensible-exceptions/0.1.1.0/doc/html/Control-Exception-Extensible.html
04:35:38 <SamB> kinda useless, isn't it :-P
04:36:45 <ski_> MyCatVerbs : well, if you don't have any members (and no superclasses), then the class parameters will get their kinds defaulted to `*'
04:36:46 <SamB> hmm, but then you'd have to add a handler to print out useful info ... hrmm ...
04:37:04 <ski_> MyCatVerbs : try `class Thingy a (b :: * -> *)'
04:37:24 <ski_> (enabling `KindSignatures' if you haven't done so)
04:37:38 <MyCatVerbs> ski_: ah, dankeschön.
04:37:54 * MyCatVerbs took four or five whacks at Google before happening on the GHC KindSignatures extension.
04:38:13 <FunctorSalad_> MyCatVerbs: don't you have any class methods where b is applied to some other type though?
04:38:21 <FunctorSalad_> then it should infer it
04:38:32 <SamB> dcoutts: on the plus side, I finally understand the point of the new exceptions :-)
04:38:39 <ski_> <MyCatVerbs> doserj: just (class Thingy a b). ...
04:39:23 <dcoutts> SamB: :-)  so my plan is not to use IO, but a restricted IO monad and to have better exception handling along with that.
04:39:38 <SamB> dcoutts: okay
04:39:48 <MyCatVerbs> Oh bugger, Kind Signatures aren't in 6.6.
04:40:23 <MyCatVerbs> FunctorSalad_: well, this class is only used to enforce context rather than for any of its methods, so I didn't bother to define any.
04:40:30 <ski_> MyCatVerbs : so define a dummy class member
04:40:42 * SamB wishes he could get information on what types a function is used at ...
04:40:49 <FunctorSalad_> class Thingy a b where dummy :: b Int; dummy = undefined
04:41:55 <SamB> FunctorSalad_: uh
04:42:06 <SamB> wouldn't it be better to just give a kind signature ?
04:42:20 <FunctorSalad_> SamB: they aren't in 6.6 ;)
04:42:25 <SamB> they aren't ?
04:42:32 * SamB doesn't remember that
04:43:07 <MyCatVerbs> SamB: mmmhmm, they're not. Doesn't recognise KindSignatures in a LANGUAGE pragma, et al.
04:43:25 <SamB> does 6.6 even do LANGUAGE ?
04:43:43 <SamB> (tried -fglasgow-exts?)
04:46:12 <MyCatVerbs> SamB: yes and yes, but only because I'm too lazy to put scoped type variables in. :)
04:46:30 <MyCatVerbs> Doesn't work anyway, I'm trying to do something impossible. Heh. ^^
04:46:46 <ivanm> yay!!! the RWH book club now gets spam! :s
04:46:57 <SamB> also I don't think you can have methods that don't mention all type variables without using fundeps
04:47:47 <MyCatVerbs> SamB: so I write { dummy :: a -> (b x) -> Int; dummy _ _ = 5; }, since it's only there to set the kinds.
04:48:21 <FunctorSalad_> as in "class won't compile" or "won't be usable", SamB?
04:48:26 * ski_ 'd `dummy :: Void -> b a' ..
04:48:53 <SamB> FunctorSalad_: I don't know
04:49:08 <FunctorSalad_> lately I couldn't get "class HasBasis a => FiniteBasis a where basis :: [Basis a]" to work
04:49:26 <FunctorSalad_> but basis :: a -> [Basis a] (ignoring it's argument) works
04:49:33 <SamB> FunctorSalad_: in 6.6?
04:49:38 <FunctorSalad_> HasBasis being from vector-space
04:49:51 <FunctorSalad_> SamB: nop, 6.10.1 (Basis is an associated type)
04:49:55 <SamB> oh.
04:50:06 <SamB> associated type, or associated type synonym ?
04:50:09 <FunctorSalad_> the first variant compiled, but functions using it didn't typecheck
04:50:18 <FunctorSalad_> SamB: not sure, synonym IIRC
04:50:31 <SamB> FunctorSalad_: well, that makes perfect sense that it wouldn't be usable then
04:50:37 <SamB> you maybe should report it though ?
04:50:46 <SamB> since I'm not sure it ought to have compiled
04:50:50 <ski_> (FunctorSalad_ : can't there be lots of different finite bases ?)
04:50:58 <FunctorSalad_> hmm why couldn't it possibly work SamB?
04:51:19 <SamB> FunctorSalad_: because it can't infer the a from Basis a
04:51:24 <FunctorSalad_> ski_: yes, but better an arbitrary one that nothing ;)
04:51:37 <ski_> FunctorSalad_ : i'm not sure i agree about that
04:51:52 <SamB> FunctorSalad_: you could have two different "a" with the same Basis a
04:52:23 <FunctorSalad_> ski_: conceptually "FiniteBasis X" would mean "vector space with a canonical finite basis", like R^n
04:53:12 <FunctorSalad_> SamB: oh, right. I thought it should work if I enter something like "basis :: [Basis (Double,Double)]"
04:53:32 <ski_> (so `Basis' need not be injective on types)
04:53:43 <FunctorSalad_> but if that immediately gets translated to its expansion then I see why it couldn't work
04:54:05 <SamB> FunctorSalad_: hmm, I don't think the "if" is appropriate really
04:54:57 <Peaker> I want to wrap SDL/GLUT with HaskGame - and expose a unified interface for both.  That may mean I have to duplicate almost all of their definitions (for example, of all possible key presses)
04:55:11 <Peaker> Maybe I should switch things upside down - and have SDL/GLUT share some common library defining things like all existing keys/etc?
04:55:39 <Peaker> So common things can be shared between these various libraries, rather than duplicated/converted
04:55:54 <FunctorSalad_> SamB: from the form I entered you /can/ infer the a, but apparently it doesn't work like that
04:56:18 <FunctorSalad_> with the annotation I mean
04:56:18 <SamB> FunctorSalad_: well, it wouldn't really be valid to do so ...
04:56:32 <flipflop> hi.  I'm trying to implement "length" in terms of "foldr".  Why won't this work:
04:56:35 <flipflop> f_len :: [a] -> Int
04:56:37 <flipflop> f_len = foldr (\ x y -> x+1) 0
04:57:22 <SamB> flipflap: you maybe want to use foldl' ?
04:57:30 <pk> > foldr (\_ y -> y + 1) 0 [1..10]
04:57:31 <lambdabot>   10
04:57:37 <flipflop> pk: Thank you, that was it :)
04:57:51 <pk> the second arg is the accumulated one
04:57:53 <SamB> > foldr (\_ y -> y + 1) 0 [1..10000]
04:57:56 <flipflop> true
04:57:58 <lambdabot>   10000
04:57:58 <ski_> (flipflop : alternatively, flip the argument order of the anonymous function)
04:58:00 <SamB> > foldr (\_ y -> y + 1) 0 [1..100000]
04:58:02 <lambdabot>   100000
04:58:05 <SamB> > foldr (\_ y -> y + 1) 0 [1..1000000]
04:58:07 <lambdabot>   * Exception: stack overflow
04:58:15 <flipflop> lol
04:58:16 <SamB> > foldl` (\x _ -> x + 1) 0 [1..1000000]
04:58:18 <lambdabot>   <no location info>: parse error on input `('
04:58:21 <SamB> > foldl' (\x _ -> x + 1) 0 [1..1000000]
04:58:23 <lambdabot>   1000000
04:58:26 <flipflop> ah.. nice :)
04:58:48 <flipflop> SamB: thanks :)
04:58:53 <pk> @pl \_ x -> x + 1
04:58:53 <lambdabot> const (1 +)
04:59:18 <ksf> WTF
04:59:27 <ksf> haskell-blah makes my xchat segfault.
05:00:25 <michaelcdever> hey, im looking at the Layout container from gtk2hs... is there anyway to just set the size of it?
05:00:43 <SamB> I didn't x-chat thought there was such a thing as too much sex and violence!
05:00:56 <michaelcdever> i mean, just to set the width
05:01:21 <yitz> michaelcdever: probably
05:01:26 <dcoutts> michaelcdever: the typical approach is not to set the size of layout containers, but to set the default size of the top level window and possibly the sizes of leaf widgets
05:01:46 <dcoutts> michaelcdever: layout widgets size to fit their children and parents
05:03:04 <dcoutts> michaelcdever: you might want to read a tutorial on gtk box packing
05:03:26 <michaelcdever> ah ok, well, i have a ScrolledWindow, i was going to add to the layout, because while it resizes ok an all that, i defaults to bigger than i want, it i PackGrow, its too big, if I PackRepel, it's rubbish, and if i PackNatural, it's too small
05:04:07 <dcoutts> michaelcdever: ah ok, a scrolled window, right they have no natural size determined by their children so are a bit of a special case
05:04:18 <yitz> dcoutts: what's the prognosis on gtk2hs for ghc 6.10?
05:04:26 <dcoutts> yitz: release imminent
05:04:40 <michaelcdever> yep, but i need to set the size of it..., well just the width, the height doesn't bother me
05:04:40 <yitz> dcoutts: great, tnx!
05:05:56 <michaelcdever> and the other two things i have in the box are scrolled windows too! but the first one is hella wider than it need be
05:07:00 <dcoutts> michaelcdever: I'd still advise doing it without fixing one of the widths, however there's the layoutWidth attribute that you can set
05:07:39 <dcoutts> michaelcdever: see also the docs for widgetSetSizeRequest
05:08:12 <michaelcdever> dcoutts: ok, thanks very much :)
05:08:36 <dcoutts> michaelcdever: have you tried playing with the design in glade?
05:08:50 * ksf wonders whether the linux guys dropped pppoe support somewhere between 2.6.23 and 2.6.28
05:09:22 <bastl> hello is there any usable wiki engine written in haskell ?
05:10:04 <michaelcdever> nope, i prefer to do gui stuff by hand!
05:10:26 <juhp_> dcoutts: any idea when gtk2hs-0.10.0 will be out officially? :)
05:11:16 <dcoutts> juhp_: well as an indication, I got an email yesterday from the release manager saying "Ok, I'm going to go ahead and announce this."
05:11:37 <michaelcdever> actually quick question about this widgetSetSizeRequest, if i do say widgetSetSizeRequest scrwin 250 -1 , that would set the with to 250 and the height as unset?
05:11:43 <dcoutts> juhp_: they're just talking about release notes, updating web pages, uploading docs etc
05:12:01 <juhp_> dcoutts: cool!
05:12:19 <bastl> yep, that's cool. im waiting for it too.
05:12:22 <dcoutts> michaelcdever: that's what the documentation leads me to believe, is that the way it reads to you?
05:13:01 <juhp_> dcoutts: I already built a "prelease" tarball for fedora rawhide, but would rather wait before push more builds :)
05:13:18 <michaelcdever> yep, thats the way it reads to me two... but documentation can be misleading sometimes :D thanks very much for your help!
05:15:06 <juhp_> bastl: trying searching for wiki on http://hackage.haskell.org/packages/archive/pkg-list.html
05:16:26 <juhp_> I played a tiny bit with gitit and Flippi I think
05:16:27 <bastl> juhp_ thanks. interesting finds there. the only thing that sounds useable is gitit. any experiences ?
05:16:52 <juhp_> I think it looks promising yes - just a little
05:16:53 <michaelcdever> dcoutts: eureka! it works!
05:16:54 <michaelcdever> :D
05:16:58 <dcoutts> :-)
05:17:05 <dcoutts> michaelcdever: does it resize ok?
05:17:10 <bastl> juhp_ thenn ill try it out. tx
05:17:17 <juhp_> welcome
05:19:31 <michaelcdever> dcoutts: nope :( grr lol
05:19:50 <michaelcdever> ill presever though, ill have to make do if i can't sort it
05:19:57 <dcoutts> michaelcdever: heh, that's the downside of fixing widths. :-)
05:20:27 <juhp_> dcoutts: I tried cabal unpack :)  thanks for that
05:20:29 <dcoutts> michaelcdever: I really recommend experimenting with layouts in glade, makes it very quick to try things and see how it works at various sizes
05:20:39 <dcoutts> juhp_: thanks Saizan_ not me :-)
05:20:45 <dcoutts> s//
05:20:46 <juhp_> ah :)
05:20:55 <michaelcdever> cool, ill give it a look! cheers!
05:26:07 <pk> >@pl \x y -> f (g x y)
05:26:12 <pk> @pl \x y -> f (g x y)
05:26:12 <lambdabot> (f .) . g
05:40:01 <mlesniak> @users
05:40:01 <lambdabot> Maximum users seen in #haskell: 661, currently: 661 (100.0%), active: 12 (1.8%)
05:40:19 <leadnose_> just 5 more...
05:47:43 <drhodes> We're sorry Mr. Thunk, but this program is on a need to run basis, and you don't need to run.  Now go away before I call the garbage collector.
05:48:26 <bastl> is there any function in a standard module that makes a histogram of labels in a tree ?
05:50:40 <MarcWeber> Is readlink /pro/self/exe the only way to get the current executable location on linux?
05:50:51 <byorgey> @remember drhodes We're sorry Mr. Thunk, but this program is on a need to run basis, and you don't need to run.  Now go away before I call the garbage collector.
05:50:52 <lambdabot> Done.
05:57:57 <MarcWeber> ?where posix
05:57:57 <lambdabot> I know nothing about posix.
05:58:33 <Cheshire> who uses types like  data I where X :: ((I -> A) -> B) -> I  ?
05:59:26 <Cheshire> data I where X :: ((I -> A) -> B) -> A-> I  ?
06:01:07 <Saizan_> bastl: histogram? not somethign like Data.Tree.drawTree ?
06:02:15 <bastl> Saizan, no, count occurence of labels. im writing it myself using Data.Map. good exercise ...
06:03:21 <Cheshire> if F :: * -> * -> * what do you call that aspect (takes 2 types) of F?
06:03:35 <Cheshire> can there be a different one than arity?
06:03:48 <BONUS> it's a type constructor that takes two types
06:03:51 <BONUS> that's what i usually say
06:04:00 <Cheshire> but as a variable name to hold the number 2
06:04:03 <BONUS> although in reality it takes one type and returns a type constructor but
06:04:05 <Cheshire> what would you use?
06:04:08 <BONUS> ah
06:04:16 <Ferdirand> "kindness" ? :p
06:04:20 <BONUS> haha
06:04:22 <bastl> :e
06:04:22 <Cheshire> lol
06:04:23 <BONUS> i'd say arity imho
06:04:37 <Cheshire> it's just that I already have a very specific meaning for arity
06:05:03 <BONUS> hmmm then you might have to make something up hehe
06:05:30 <Cheshire> does args make sense?
06:05:34 <Cheshire> takes 2 args
06:06:06 <BONUS> i'd say takes 2 types
06:06:14 <BONUS> but you're looking for a different label for that right
06:06:22 <BONUS> something like arity, only not quite that
06:06:24 <BONUS> hmm
06:08:50 <Cheshire> @hoogle Bool -> String -> Error ()
06:08:50 <lambdabot> Did you mean: Bool -> String -> Reply () a a /count=20
06:08:50 <lambdabot> Language.Haskell.TH.Syntax qReport :: Quasi m => Bool -> String -> m ()
06:08:50 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
06:09:00 <Cheshire> @hoogle report
06:09:01 <lambdabot> Language.Haskell.TH report :: Bool -> String -> Q ()
06:09:01 <lambdabot> Language.Haskell.TH.Syntax report :: Bool -> String -> Q ()
06:09:01 <lambdabot> Test.HUnit.Base type ReportProblem us = String -> State -> us -> IO us
06:09:18 <Cheshire> report True _ = return () ; report False err = throwError err
06:14:53 <drhodes> > zip (nub . sort $ "result of a tree to list function" ) (map length . group . sort $ "result of a tree to list function")
06:14:54 <lambdabot>   [(' ',6),('a',1),('c',1),('e',3),('f',2),('i',2),('l',2),('n',2),('o',3),('...
06:15:03 <drhodes> not a very pretty histrogram
06:16:26 <Cheshire> @let r = "result of a tree to list function"
06:16:27 <Cheshire> > ((length &&& head) . group . sort) r
06:16:29 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
06:16:30 <lambdabot>  Defined.
06:16:35 <Cheshire> > ((length &&& head) . group . sort) r
06:16:36 <lambdabot>       Ambiguous occurrence `r'
06:16:36 <lambdabot>      It could refer to either `L.r', defined a...
06:16:43 <Cheshire> > ((length &&& head) . group . sort) "idiot bot"
06:16:44 <lambdabot>   (6," ")
06:16:51 <Cheshire> > (map (length &&& head) . group . sort) "idiot bot"
06:16:53 <lambdabot>   [(1,' '),(1,'b'),(1,'d'),(2,'i'),(2,'o'),(2,'t')]
06:17:10 <drhodes> :t (&&&)
06:17:11 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:17:53 <Cheshire> @let (f & g) x = (f x, g x)
06:17:55 <lambdabot>  Defined.
06:17:57 <drhodes> was wondering how to factor out the sort
06:17:58 <Cheshire> > (map (length & head) . group . sort) "idiot bot"
06:17:59 <lambdabot>   [(1,' '),(1,'b'),(1,'d'),(2,'i'),(2,'o'),(2,'t')]
06:18:30 <Cheshire> drhodes, I think any attempt to remove the sort would make the overall program less efficient
06:18:44 <Peaker> @let tgroup = map (length & head) . group
06:18:46 <lambdabot>  Defined.
06:19:06 <Peaker> @let histogram = tgroup . sort
06:19:09 <lambdabot>  Defined.
06:19:11 <Peaker> > histogram "hello world"
06:19:13 <lambdabot>   [(1,' '),(1,'d'),(1,'e'),(1,'h'),(3,'l'),(2,'o'),(1,'r'),(1,'w')]
06:19:14 <drhodes> I meant the two sort used my first zip () () post
06:19:18 <Cheshire> Peaker, "tgroup" is a bad name
06:19:29 <Cheshire> call it rle instead
06:19:30 <Peaker> Cheshire: maybe "groups"?
06:19:36 <Peaker> Cheshire: ah, good idea
06:20:39 <Cheshire> in data X where C :: Q1 -> Q2 -> Q3 -> X
06:20:49 <Cheshire> what is the name of Q_i?
06:22:16 <Cheshire> like if I let h = C a b c; what would you call {a,b,c}?
06:22:26 <Cheshire> there doesn't seem to be any name..
06:22:49 <Saizan> "fields" sometimes
06:23:06 <Cheshire> oh nice, thanks
06:34:21 <Cheshire> > throwError "foo" :: Either String Integer
06:34:22 <lambdabot>   Left "foo"
06:34:25 <Cheshire> > throwError "foo"
06:34:26 <lambdabot>       No instance for (Show (m a))
06:34:26 <lambdabot>        arising from a use of `show' at <in...
06:35:05 <Cheshire> > if True then throwError "foo" else return 3
06:35:07 <lambdabot>       No instance for (Show (m a))
06:35:07 <lambdabot>        arising from a use of `show' at <in...
06:39:28 <saml> what's the word to use when you say a series /number sequence approaches aximtoctically 1 or something?
06:39:34 <saml> that word "aximtoctically"
06:39:38 <saml> sorry wront chan
06:39:42 <Cheshire> asymptotically
06:39:51 <saml> oh thanks Cheshire
06:55:58 <ddvlad|> hi, does using `deriving' guarantee that read . show = id for my type?
06:56:10 <ddvlad|> (i'm looking for some free serialization :P)
06:57:18 <blackh> ddvlad: Yes, as long as it depends only on types for which this is true.... and that includes all the pre-defined ones
06:57:51 <blackh> ddvlad|: In other words, it is possible to break the quality of read . show = id using 'instance'
06:58:13 <ddvlad|> blackh: i got it, thanks. i just have a couple of strings, so there shouldn't be a problem
06:59:04 <blackh> ddvlad|: Free serialization is definitely intended by the implementation.
06:59:39 <ddvlad|> blackh: i'd written a `show' and was starting on `read' when i realised :-)
07:00:28 <maltem> I've been wondering about making it easier to run the test cases in a cabal project... Would it make sense for cabal to autogenerate a Tests_$project.hs file in dist/autogen where it lists all properties and test cases by (qualified) name?
07:01:06 <dcoutts> maltem: for our proposed design see http://hackage.haskell.org/trac/hackage/ticket/215
07:02:36 <maltem> dcoutts: ah nice, I'll take a look at that
07:04:28 <maltem> heh, I didn't even know 'cabal test' already exists
07:09:28 <maltem> dcoutts: If I understand correctly, you don't plan to automatically collect tests, though?
07:10:09 <edbond> Is there a possibility to use threads for map and filter functions and use 2 cpu cores?
07:10:22 <edbond> I mean compiler options.
07:10:29 <cjb> edbond: certainly
07:11:17 <andyjgill> Is there a simple way of drawing a 2D canvas in Haskell under X? OpenGL is a bit heavier than I want to use right now.
07:11:18 <dcoutts> maltem: right, just provide a way to hook up sets of QC/HUnit/Custom tests
07:11:19 * fasta giggles at  tests :: SomethingYetToBeDecided 
07:11:28 <dcoutts> andyjgill: cairo
07:11:51 <edbond> cjb: 6.8.2 does have such options?
07:12:06 <cjb> edbond: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html gives an example (near the end) of parallel multicore mapreduce
07:12:16 * mapreduce splutters.
07:12:54 <maltem> dcoutts: ok, so you now have one vote to extend the design :)
07:13:46 <andyjgill> Thanks dcoutts.  Still a bit heavier that I'm wanting, for teaching with :-(
07:14:26 <dcoutts> andyjgill: ah for teaching. Then make a smaller wrapper over cairo, eg see the gtk SOE wrapper that uses cairo.
07:14:46 <edbond> cjb: thanks. I'm reading this book :)
07:14:47 <pk> why not fieldtrip
07:14:54 <andyjgill> I was thinking SOE-like, yes.
07:15:16 <dcoutts> andyjgill: cairo is a nice api and produces very nice results. It's a good substrate for implementing toy graphics apis.
07:15:36 <dcoutts> andyjgill: I used it for a practical once, and GL another time
07:15:39 <andyjgill> Fieldtrip is built ontop of OpenGL (though does not need openGL conceptually), an is a 3D description language.
07:16:29 <pk> you can do 2d with it
07:16:37 <maltem> Maybe someone who has got time should decouple Haskell-cairo from gtk2hs...
07:16:59 <dcoutts> maltem: it's been done but it's not useful 'til gtk2hs is cabalised.
07:17:40 <andyjgill> Is there a reason cairo is not on hackage?
07:18:01 <dcoutts> andyjgill: gtk2hs has not been cabalised yet
07:18:26 <maltem> dcoutts: you mean you want to release a decoupled cairo only as soon as it's cabalized?
07:18:37 <dcoutts> maltem: yes
07:18:48 <maltem> ok, makes sense
07:18:53 <andyjgill> pk: I know. But I'm wanting to building something lighter weight.
07:19:02 <dcoutts> maltem: once gtk2hs is cabalised then it's 9 different packages all on hackage
07:19:15 <maltem> dcoutts: sounds nice :)
07:20:01 <dcoutts> andyjgill: see my implementation of soe on top of cairo. It's short. It should be easy to build something with a nicer api (I was constrained to providing the SOE api).
07:20:52 <andyjgill> Thanks for the pointer!
07:21:11 <pejo> dcoutts, what is the problem with cabalising gtk2hs?
07:21:16 <dcoutts> andyjgill: the only tricky bit is the intersection/union stuff. That does not map onto the cairo/pdf model well.
07:21:29 <dcoutts> pejo: .chs files and dependencies between them
07:21:46 <maltem> Using the SOE api for teaching has the advantage that you have a reason to point people to the book for further reading :)
07:22:20 <dcoutts> pejo: dependencies between .hs files are handled by ghc --make, but we've got no equivalent at the moment for other pre-processors.
07:22:37 <daf> dcoutts: how much gobject magic is there in gtk2hs? I was wondering what the best approach to wrapping clutter would be
07:22:59 <dcoutts> daf: I'm not sure what you mean exactly
07:23:21 <dcoutts> daf: there's a code gen for generating bindings to gobject based C APIs
07:23:29 <daf> right, that's what I meant
07:23:45 <daf> and that code is inside gtk2hs?
07:23:48 <dcoutts> yep
07:23:53 <daf> if you were to split it out, where would it go?
07:24:15 <daf> split gtk2hs apart, I mean
07:24:21 <dcoutts> erm, it's just a standalone tool that happens to live in the gtk2hs darcs repo
07:25:03 <dcoutts> daf: it's not sufficiently automated to use in a build system anyway, so distributing it separately doesn't seem to have any great advantages
07:25:09 <daf> sure
07:25:15 <dcoutts> the generated code still needs some manual adjustments
07:25:23 <daf> it seems like the easiest way to do clutter would be inside the gtk2hs repository then
07:25:23 <dcoutts> due to lack of info in the C api in places
07:25:37 <daf> hmm, what sort of thing?
07:25:38 <dcoutts> daf: oh, I see what you're saying
07:25:47 <daf> that sounds like something that should be fixed in gobject-introspection
07:25:50 <daf> if possible
07:25:55 <dcoutts> daf: yes, we should use that
07:26:17 <dcoutts> daf: it's still using the older approach that the gtk# people used
07:26:19 <daf> I mean, we should give the designers feedback
07:26:48 <daf> to reduce the amount of manual work required for Haskell
07:29:14 <dcoutts> daf: absolutely. If I had infinite time I'd spend some on the code gen :-)
07:29:19 <daf> :)
07:29:25 <daf> I'll put it on my list of things to do sometime
07:29:34 <JaffaCake> dcoutts: only some?
07:29:45 <dcoutts> daf: I've tried a couple times to get others to look at the python and introspection approach
07:29:53 <dcoutts> JaffaCake: hah :-)
07:30:15 <dcoutts> JaffaCake: unlike Cabal, the gtk2hs code gen only requires finite time :-)
07:30:32 <JaffaCake> hehe, right
07:41:45 <asgaroth> I have a module A which depends on a newtype(which uses NewtypeDeriving) from module B which depends on A. There already is an B.hs-boot but adding the newtype or a data declaration of the data type there causes the deriving to fail in B.hs. How could I solve this?
07:42:13 <Gracenotes> why does my university connection always reset overnight :/ argh
07:42:22 <Cheshire> asgaroth, that sounds like a terrible situation, can you not have like 3 modules and break the cycle?
07:43:21 <int-e> asgaroth: does standalone deriving help?  newtype Foo a = Foo a; deriving instance Eq a => Foo a
07:43:33 <int-e> asgaroth: see also http://haskell.org/haskellwiki/GHC/StandAloneDeriving
07:43:37 <asgaroth> Cheshire: Hmm, these modules are part of a bigger project(yi) so I don't know whether I can go around reordering stuff like that.
07:43:54 <asgaroth> int-e: I tried to use that but it caused the same problem(tried deriving in B.hs)
07:44:13 <Cheshire> asgaroth, I think you can
07:45:01 <asgaroth> Cheshire, int-e: hmm, okay. thanks
07:46:18 <marcot> Hello, can someone please add to the topic the creation of the ##haskell-pt channel for people talk about haskell in portuguese?
07:48:44 <int-e> asgaroth: you may have to declare the instance in the .hs-boot file as well (instance Eq a => Eq (Foo a) ... Oh, I messed up the deriving clause above.)
07:48:47 <pejo> marcot, I think most country channels use a dot instead of the dash (#haskell.es #haskell.fi #haskell.fr #haskell.hr #haskell.it #haskell.jp #haskell.cz #haskell.de haskell.no #haskell.ru #haskell.se)
07:48:55 * earthy nods
07:49:10 <earthy> #haskell.dut
07:49:25 <marcot> pejo: good to know
07:49:27 <pejo> earthy, why not .nl?
07:49:33 <marcot> So, #haskell.pt
07:49:44 <asgaroth> int-e: Okay thanks, I'll try that before and split it up to different modules if that doesn't work.
07:50:25 <asgaroth> int-e: would I declare the new type with a data in the .hs-boot? (Since newtype complains about a missing constructor there
07:50:32 * maltem wonders if all #haskell.$lang channels are as silent as #haskell.de
07:51:02 <koeien> maltem: #haskell.dut is
07:51:14 <yottis> at least .fi and .se are
07:51:26 <koeien> it's been a month now :)
07:51:44 <maltem> ok, so it probably holds for all germanic languages :)
07:51:47 <yottis> .dut is dutch? not .nl?
07:51:49 <koeien> dutch
07:51:55 <JMP_> hi
07:52:02 <koeien> .nl would imply netherlands, which excludes belgium :)
07:52:20 <maltem> koeien: I think nl is the iso language code for dutch?
07:52:21 <yottis> .se implies sweden and yet i live in finland :)
07:52:23 <koeien> JMP_: hello. feel free to ask a question :)
07:52:28 <pejo> And .se implies sweden, which excludes finland. We'll live with that. :-)
07:52:55 <JMP_> I don't have any questions ;) just here 4 chat :)
07:52:58 <int-e> asgaroth: I believe you have to reproduce the whole newtype declaration.
07:53:01 <maltem> koeien: But I see how Belgians tend to need to be treated specially :-P
07:53:27 <int-e> asgaroth: (But I've not played with hs-boot files enough to really know.)
07:53:45 <koeien> maltem: hmm, i thought it was 'dut'. i may be wrong :)
07:54:06 <maltem> koeien: well there are two- and three-letter iso codes
07:54:31 <koeien> maltem: ISO 639-2 specifies 'dut' for bibliographic purposes
07:54:32 <maltem> koeien: so maybe you're right
07:54:34 <asgaroth> int-e: Hmm, splitting that module seems like the proper solution, these repetitions in .hs-boot files are annoying.
07:54:47 <yottis> isn't "dutch" just silly english-speaking people's historical inability to make a difference between germans and dutch?-)
07:55:14 <koeien> maltem: but swedish is sv
07:55:17 <koeien> or swe
07:55:28 <koeien> so it's just random
07:55:51 <skorpan> or se
07:55:55 <koeien> yottis: well they sure knew who to attack during the english wars
07:56:03 <maltem> koeien: indeed
07:56:13 <maltem> (random)
07:56:20 <fasta> yottis: http://www.etymonline.com/index.php?term=Dutch
07:56:21 <koeien> skorpan: Northern Sami is se
07:56:27 <yottis> or then their heuristic was as fancy "avast, a ship without the english flag, let's sink it"
07:56:30 <fasta> yottis: ^^
07:56:35 <koeien> yottis: they sure knew who to attack during the english wars
07:56:48 <koeien> yottis: (they surely call it the 'dutch wars' :)
07:56:48 <skorpan> koeien: i'm not sure which ISO you're speaking of, but .se is the swedish TLD
07:56:59 <koeien> skorpan: yeah, .nl our TLD
07:57:14 <koeien> skorpan: but this excludes .be
07:57:15 <koeien> oh well
07:57:18 <maltem> skorpan: TLD /= language code
07:57:35 <skorpan> maltem: "language code" can refer to anything
07:57:45 <asgaroth> koeien: heh, they're called english-dutch wars in germany :)
07:58:31 <maltem> skorpan: well most culture-specific TLDs are named after countries
07:58:56 <maltem> skorpan: whereas there are seperate iso language codes
07:59:19 <skorpan> maltem: that's what i'm saying
07:59:28 <skorpan> "i'm not sure which ISO you're speaking of"
07:59:29 <koeien> asgaroth: always name your wars depending on the enemy :)
07:59:38 <koeien> ISO 639-2
07:59:46 <koeien> at least I was
07:59:52 <koeien> ISO 639-1 defines two-letter names
08:00:00 <maltem> skorpan: hmm, how many isos are there for language codes?
08:00:27 <skorpan> maltem: i'm not sure, more than one obviously :) there are the car stickers, the TLDs (i think it's ISO at least), the "wikipedia code"...
08:00:31 <koeien> 3 i think
08:00:33 <koeien> at least 3
08:00:39 <koeien> ISO 639-{1,2,3}
08:00:57 <arw> some. there are two- and three-letter codes, language codes, region-codes and the stickers on cars (not sure if thats an iso or older)
08:01:02 <maltem> skorpan: well my point was that car stickers and TLDs don't refer to languages
08:01:18 <skorpan> ah, true
08:01:19 <skorpan> my bad
08:01:25 <maltem> heh
08:02:18 <yottis> "culture" is also understood quite differently by different people
08:02:21 <maltem> alright, good that we have talked about it, as we say in Germany (in German?)
08:02:48 <koeien> yottis: it's easy to upset people
08:03:56 <yottis> for some it's a synonym to nationality, and if you don't agree you're probably a traitor :>
08:04:36 * koeien even has a .eu domain name
08:05:01 <maltem> yottis: you basically have to re-define "culture" depending on the cultures being discussed
08:07:50 <Cheshire> > 1+1
08:07:52 <lambdabot>   2
08:08:12 <fsanches> woah, this bot is aways surprising me
08:08:35 <sw17ch> some one needs to make a metalic >>= in the same style as the Jesus Fish bumper thingies
08:10:31 <sproctor_work> I'm looking for a way to get permutations of a string.
08:10:40 <Cheshire> , permutations "a string"
08:10:41 <lunabot>  ["a string"," astring","s atring"," satring","sa tring","as tring","ts ar...
08:10:42 <sproctor_work>  http://www.mail-archive.com/haskell@haskell.org/msg19032.html seems to be helpful, but there is at least 1 typo and after fixing that, it still seems like there's a bug.
08:10:59 <opqdonut> ?src permutations -- very educating
08:10:59 <lambdabot> Source not found. I feel much better now.
08:11:02 <opqdonut> gah
08:11:10 <koeien> lunabot has it?
08:11:19 <Cale> permutations is new in Data.List in 6.10
08:11:29 <liwp> there's a haskell wiki entry on permutations which is very good
08:12:03 <Cale> (somewhat ridiculous that it wasn't there in the report List library :)
08:12:04 <sproctor_work> well, the implementation in that link is bothering me anyway.
08:12:32 <sproctor_work> anyone see what is wrong with it?
08:13:06 <doserj> Cale: I guess the report authors didn't want to spoil their favourite homework assignment...
08:13:08 <sproctor_work> changing the first occurrence of x to y makes it compile, but it always produces an empty list.
08:13:18 <Gracenotes> it doesn't seem terribly efficient
08:13:42 <liwp> > (xs -> [x:ps | x <- xs, ps <- perms (xs\\[x])]) "a string"
08:13:43 <lambdabot>   <no location info>: parse error on input `->'
08:13:49 <liwp> uhh
08:13:54 <liwp> > (\xs -> [x:ps | x <- xs, ps <- perms (xs\\[x])]) "a string"
08:13:55 <lambdabot>   Not in scope: `perms'
08:14:01 <liwp> never mins
08:14:04 <liwp> mind even
08:14:24 <liwp> > let perms xs = [x:ps | x <- xs, ps <- perms (xs\\[x])]) in perms "a string"
08:14:25 <lambdabot>   <no location info>: parse error on input `)'
08:14:27 <Cale> If your implementation of permutations has Eq in its type, you're doing something wrong :)
08:14:39 <opqdonut> :)
08:14:39 <liwp> > let perms xs = [x:ps | x <- xs, ps <- perms (xs\\[x])] in perms "a string"
08:14:41 <Cale> (specifically, there's no need for \\)
08:14:41 <lambdabot>   []
08:14:44 <Gracenotes> sproctor_work: rotate takes all the permutations beginning with the first element of the list, concatenates them with all permutations beginning with the second element in the list, etc.
08:15:10 <Gracenotes> ah, but the post you linked only mentions that one in a quote. never mind.
08:15:15 <liwp> Cale: fair enough
08:15:52 <chessguy_work> hm, why shouldn't a perms implementation have an Eq restriction"
08:15:54 <Gracenotes> ch:chs -> chs ++ [ch] isn't that efficient, though
08:15:55 <sproctor_work> let me pastebin this to avoid confusion.
08:16:09 <chessguy_work> that seems reasonable to me
08:16:20 <koeien> why?
08:16:25 <koeien> i don't see why it would need that
08:16:50 * fasta celebrates the lack of mutual recursive modules (no, I won't use the GHC "solution")
08:16:53 <koeien> it's just fiddling with lists, you don't need the type of the elements
08:17:04 <chessguy_work> hm.
08:17:07 * chessguy_work ponders
08:17:20 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; perms [] = [[]]; perms xs = [(y:zs) | (y,ys) <- select xs, zs <- perms ys] in perms [1,2,3,4,5]
08:17:21 <lambdabot>   [[1,2,3,4,5],[1,2,3,5,4],[1,2,4,3,5],[1,2,4,5,3],[1,2,5,3,4],[1,2,5,4,3],[1...
08:17:25 <chessguy_work> good question. why does it seem reasonable to me
08:17:28 <sproctor_work> http://pastebin.ca/1331649 is the implementation I was using (which didn't work) with the typo "fixed"
08:17:55 <Cale> No need for comparing elements of the list for equality. Constructing permutations is an entirely structural operation.
08:18:17 <sproctor_work> chessguy_work: if you want to avoid duplicate lists when you have duplicate elements, then it seems reasonable.
08:18:53 <Cale> Oh, I suppose that is true. There's not much you can do about that otherwise :)
08:19:15 <koeien> then nub it afterwards :)
08:19:19 <koeien> pretty inefficient though
08:19:41 <sproctor_work> so no one sees some glaring bug in that implementation?
08:19:48 <Cale> sproctor_work: In which one?
08:19:54 <sproctor_work> http://pastebin.ca/1331649
08:20:00 * Cale looks...
08:20:14 <koeien> sproctor_work: base case of permutations
08:20:24 <koeien> sproctor_work: perms, rather
08:20:31 <Cale> ah, yes
08:20:45 <Cale> (compare it with my implementation in the command to lambdabot)
08:20:49 <Cale> perms [] = [[]]
08:20:59 <chessguy_work> that's a FAQ
08:21:03 <sproctor_work> ah
08:21:11 <chessguy_work> very common mistake
08:22:30 <Cale> We really ought to have selections/select in Data.List as well.
08:22:39 <sproctor_work> thank you koeien, Cale
08:23:09 <sproctor_work> that was bugging me because it looked correct.
08:23:42 <Cale> > let select [] = []; select (x:xs) = (x,xs):[(y,x:ys) | (y,ys) <- select xs] in evalStateT (replicateM 3 (StateT select)) [1,2,3]
08:23:43 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
08:24:13 <Cale> > let select [] = []; select (x:xs) = (x,xs):[(y,x:ys) | (y,ys) <- select xs] in evalStateT (mapM (StateT select) [1,2,3]) [1,2,3]
08:24:15 <lambdabot>   Couldn't match expected type `a -> StateT s m b'
08:24:28 <Cale> > let select [] = []; select (x:xs) = (x,xs):[(y,x:ys) | (y,ys) <- select xs] in evalStateT (mapM_ (const (StateT select)) [1,2,3]) [1,2,3]
08:24:30 <lambdabot>   [(),(),(),(),(),()]
08:24:34 <Cale> er, oops :)
08:24:37 <Cale> > let select [] = []; select (x:xs) = (x,xs):[(y,x:ys) | (y,ys) <- select xs] in evalStateT (mapM (const (StateT select)) [1,2,3]) [1,2,3]
08:24:39 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
08:26:46 <sw17ch> , permute [1..3]
08:26:47 <lunabot>  luna: Not in scope: `permute'
08:26:50 <sw17ch> , permutations [1..3]
08:26:51 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
08:27:03 <skorpan> hey... is it possible to uninstall packages with cabal-install?
08:27:07 <pumpkin_> nope
08:27:19 <pumpkin_> ghc-pkg unregister then delete them yourself I think
08:27:21 <sw17ch> , permutations (permutations [1..3])
08:27:22 <lunabot>  [[[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]],[[2,1,3],[1,2,3],[3,2,...
08:27:25 <skorpan> pumpkin_: thanks
08:27:32 <sw17ch> , permutations (permutations [1..2])
08:27:34 <lunabot>  [[[1,2],[2,1]],[[2,1],[1,2]]]
08:27:38 <Cale> hmm, permutations gives the permutations in a somewhat strange order...
08:28:15 <Cale> What order is that?
08:28:17 <pumpkin_> Cale: I think they wanted it to work on infinite lists
08:28:22 <Cale> , permutations [1..4]
08:28:23 <lunabot>  [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3...
08:28:53 <Cale> Hmm... does that explain it completely?
08:28:59 <pumpkin_> probably not :)
08:29:05 <sw17ch> , take 3 $ take 1 $ permutations [1..]
08:29:06 <lunabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
08:29:16 <sw17ch> , take 1 $ take 1 $ permutations [1..]
08:29:17 <lunabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
08:29:21 <pumpkin_> , map (take 4) . permutations $ [1..]
08:29:22 <lunabot>  [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3...
08:29:28 <sw17ch> ah, yes
08:30:11 <Cale> I don't understand why that 3rd permutation in the list is where it is.
08:30:16 <Cale> [3,2,1,4]
08:30:42 <pumpkin_> I think it's "pulling out" elements and moving them to the front
08:30:54 <sw17ch> pumpkin_: but taht doesn't explain the 4th
08:30:55 <Cale> hmm, that might do it :)
08:31:11 <sw17ch> oh, yes it does
08:31:41 * sw17ch wants to see the implementation
08:32:09 <pumpkin_> I'm looking for the source but it's a pain
08:32:15 <pumpkin_> I don't get why some haddock includes little source links
08:32:34 <pumpkin_> but a lot of it doesn't
08:33:10 <Cale> pumpkin_: It's the specific version of haddock which was installed when generating the documentation.
08:33:19 <Cale> pumpkin_: Newer versions of haddock have that feature.
08:33:39 <Cale> I don't understand why the current libraries documentation doesn't...
08:34:03 <rwbarton> speaking of which, is there something I can put in ~/.cabal/config so that my local documentation gets built with source links?
08:34:23 <pumpkin_> yup
08:34:42 <sw17ch> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1286#a1286
08:34:56 <sw17ch> that's the implementation of permutations in Data.List
08:36:35 <sw17ch> that's actually fairly hard to wrap your head around :\
08:36:42 <sw17ch> or at least my head...
08:39:16 <blathijs> Is there any places where class instances are documented?
08:39:30 <opqdonut> yes, api docs
08:39:43 <blathijs> Ie, Control.Applicative docs say that [] is an instance of Applicative, but not what the semantics are
08:40:21 <opqdonut> ah, see the source
08:40:30 <opqdonut> it's a shame the semantics aren't properly documented, i agree
08:40:34 <beelsebob> blathijs: same as the list monad
08:40:45 <beelsebob> it's the cross product
08:40:48 <beelsebob> not the zipper
08:40:57 <blathijs> beelsebob: Yeah, I found that by trying in ghci
08:41:03 <blathijs> beelsebob: But my question was more general :-)
08:41:15 <beelsebob> yeh
08:41:26 <blathijs> But if it's not documented anywhere, I'll check the source
08:46:36 <redditbot> Origami Programming : Jeremy Gibbons :: PDF
08:46:36 <redditbot> The Syntactic Century: Formal semantics for side effects
08:46:36 <redditbot> Learning Haskell: Solving the Josephus Flavius game
08:54:35 <cknapp> By the way, #haskell is a bit more effective at haskell discussion than #scheme is at scheme discussion... dispite our excursions in to algebra, category theory, and translating ancient greek. :)
08:55:20 <chessguy_work> cknapp, #haskell (the community) is one of the best things about haskell (the language)
08:55:34 <fasta> cknapp: I believe in #scheme you are assumed to be a Scheme expert.
08:55:34 <cknapp> I'd noticed :)
08:56:13 <koeien_home> i disagree... the language itself is the prime reason that I use it. although the community is very nice
08:56:41 <cknapp> Anyway, I think I'll be more likely to get an explanation of what closures are doing here...
08:56:44 <rwbarton> Hmm... #haskell versus lazy evaluation... tough choice :)
08:56:44 <SamB_irssi> koeien_home: he sadi "one of the best things"
08:56:58 <Cheshire> cknapp, kinda annoying
08:57:07 <SamB_irssi> cknapp: sitting in ur memory, binding ur variables
08:57:11 <cknapp> Haha
08:57:16 <fasta> I believe this channel should decrease in size, since a perfectly working language implementation would have no need for "support".
08:57:16 <SamB_irssi> no, wait ... that's closure cat
08:57:16 <Cheshire> cknapp, I ask questions here all the time that don't get answered but I don't bitch about it to #scheme
08:58:10 <cknapp> I wasn't actually bitching about it... I was complimenting the #haskell community...
08:58:24 <cknapp> I don't *expect* people to answer noobs... it's not their job.
08:58:33 <cknapp> But it's nice when people do. :)
08:58:43 <fasta> Probably on average the #scheme users are older.
08:58:45 <SamB_irssi> cknapp: tell that to shapr
08:58:52 <cknapp> ?
08:58:57 <SamB_irssi> that it's not our job
08:59:03 <fasta> So, they value their time more.
08:59:04 <cknapp> Why?
08:59:18 <cknapp> fasta: perhaps...
08:59:24 <koeien_home> a friend of mine once entered this channel, wanting to irritate me, and before i could stop him, he entered "Haskell sucks!". The reaction of 3 different people was "why?" "could you elaborate?" ... very nice
08:59:26 <Cheshire> I think this whole conversation is off topic and uncomfortable
08:59:33 <cknapp> Sorry. I'll stop.
08:59:33 <SamB_irssi> well, I think he might say something funny if you do
09:01:17 <BMeph> SamB_irssi: im in ur memory, mutating ur variables
09:02:17 <BMeph> fasta: I disagree. I'm pretty sure the #scheme folks are younger. :)
09:02:31 <SamB_irssi> BMeph: well, do you know how old WE are ?
09:02:35 <cknapp> Anyway, I need to head to class... cheers. Again, sorry for giving the wrong impression, Cheshire.
09:03:07 <BMeph> SamB_irssi: I know how old augustss is. ;p
09:03:10 <SamB_irssi> fasta: this channel isn't just about language support, you know!
09:03:11 <fasta> BMeph: on what do you base that?
09:03:31 <fasta> SamB_irssi: I thought we had indepth and overflow for the other stuff.
09:03:47 <SamB_irssi> what about ... libraries ?
09:03:49 <fasta> SamB_irssi: and oasis and ...
09:04:03 <fasta> SamB_irssi: you mean developing new ones?
09:04:05 <dolio> oasis isn't a haskell channel.
09:04:09 <dolio> It's a vincenz channel.
09:04:35 * Cheshire dislikes the premise of oasis
09:04:41 <SamB_irssi> oh, I thought it was for ICFP contest stuff
09:04:56 <Cheshire> (I include things like type systems etc in syntax...)
09:05:05 <tromp__> > ()
09:05:07 <lambdabot>   ()
09:05:25 <fasta> SamB_irssi: for libraries there is libraries@haskell.org, but I suppose most libraries are just build by people with some need and put it on Hackage if they want.
09:06:03 <fasta> SamB_irssi: most communication in #haskell is the result of broken tools.
09:07:11 <pumpkin_> lol
09:07:19 <pumpkin_> [citation needed]
09:08:38 <SamB_irssi> fasta: people need to USE libraries
09:08:59 <SamB_irssi> they don't necessarily want to post to libraries@ every time they are thinking about using another library ;-P
09:09:30 <SamB_irssi> also, most new tools/libs are "broken"
09:09:46 <SamB_irssi> so if we get more new tools and libraries, we'll have more tools and libraries to fix ...
09:09:51 <fasta> SamB_irssi: when a user wants to use a library he shouldn't need another user to help him. Good documentation solves that.
09:10:06 <SamB_irssi> fasta: he might not know which he wants to use!
09:10:10 <Choko> what is the equivalent to :type in sml/nj ?
09:10:11 <Cheshire> fasta, not true. Some people are too damn lazy
09:10:17 <fasta> SamB: you can even have tools for that.
09:10:30 <SamB_irssi> though I admit we *definately* need to improve the documentation ...
09:10:33 <Toxaris> Cheshire: even reduction rules belong to syntax in a sense :)
09:10:36 <Cheshire> fasta, i.e.   How do you filter out duplicates of a list?
09:10:40 <SamB_irssi> fasta: the tools won't help you evolve a good API!
09:10:44 <maltem> fasta: We *could* decide to use #haskell communication power to improve library documentation
09:10:51 <fasta> SamB: for example if someone wants to do "something" with XML, we should just have one good API, not a bunch of broken ones.
09:10:58 <Cheshire> fasta, a lot of people ask that here and it's not because of a lack of documentation
09:11:10 <SamB_irssi> fasta: a bunch of broken ones is indeed bad
09:11:23 <SamB_irssi> but I'm not sure there is a one-size-fits-all XML API
09:11:24 <fasta> Cheshire: it is because they don't trust the current libraries.
09:11:32 <Cheshire> fasta, no it's not
09:11:38 <pumpkin_> fasta: we need central organization, and to ban anyone from writing another xml lib!
09:11:38 <Cheshire> fasta, it's because they are too damn lazy
09:11:43 <fasta> Cheshire: for good reason. So, they ask which one is _currently_ the least broken.
09:11:54 <Cheshire> fasta, not what I was referring to at all..
09:12:26 <SamB_irssi> fasta: you really can't have a one-size-fits-all XML library
09:12:47 <fasta> SamB_irssi: I know that in the Java world and other there are various APIs too.
09:12:48 <SamB_irssi> or at least, not a one-size-fits-all parse function
09:13:07 <fasta> SamB_irssi: but they are at least documented (although sometimes the implementations suck)
09:13:21 <fasta> Oleg did a benchmark on those once.
09:13:35 <fasta> Some had exponential complexity, IIRC.
09:13:45 <SamB_irssi> fasta: yes, the APIs and docs need a lot of work
09:13:53 <SamB_irssi> but I don't think we really want "just one"
09:14:14 <pumpkin_> which would then lead to (heaven forbid) people asking about which one
09:14:58 <fasta> If they really have a question, we should just be able to point them at some comparison article.
09:14:59 <SamB_irssi> but they really should all be made to work ;-)
09:15:18 <SamB_irssi> programming will never be easy
09:15:21 <fasta> But before we fix the libraries, we first need a decent compiler.
09:15:46 <Toxaris> whats wrong with people talking to other people in #haskell? #haskell is part of the fun of haskell, after all
09:15:54 <pumpkin_> Toxaris: I agree
09:15:55 <SamB_irssi> I can totally see wanting to reduce the amount of conversations that happen because of bugs or infelicities in some tool or other, though ;-)
09:16:08 <fasta> Toxaris: I never said that.
09:16:14 <SamB_irssi> at least, in the tools we have now
09:17:35 <Toxaris> sure, bugs are bad, and documentation is cool.
09:18:27 <Toxaris> still, it's nice & fun to get stuff explained in #haskell, so the wise people should not spend 100% of their haskell time writing documentation, but also some time answering newbie questions in #haskell
09:18:52 <Toxaris> of course, at some point the community gets to big for that to work
09:18:59 <Toxaris> and then its time to learn a new language, maybe :)
09:19:17 <cantor> could anyone help me with that problem please?
09:19:19 <cantor> http://pastebin.com/m5d4e692c
09:19:56 <pumpkin_> Toxaris: well, in some cases you'll inspire the people you teach to learn more and write documentation too :P
09:20:05 <pumpkin_> I did that
09:20:17 <pumpkin_> (I mean, I was the newbie who was inspired to write documentation)
09:20:39 <BMeph> Is the 6.10 users' manual available in PDF?
09:20:39 <Cheshire> cantor' because of indentation
09:20:55 <Toxaris> cantor: try to indent the "v = " exactly as much as the "u ="
09:22:20 <fasta> I wish I had an oracle which told me how many bugs GHC had, so I could at least make an informed decision of whether to put more time in the weaknesses of GHC :/
09:22:34 <cantor> Toxaris:hmm
09:22:45 <fasta> still has*
09:22:56 <pumpkin_> fasta: what kinds of bugs?
09:23:27 <fasta> pumpkin_: mostly type-inferencing bugs.
09:23:52 <opqdonut> wow, really?
09:24:13 <opqdonut> type inferencing for type system extensions i presume?
09:24:40 <cantor> Toxaris: this isnt the problem
09:25:04 <fasta> opqdonut: extensions of H98?
09:25:11 <fasta> opqdonut: in this case no.
09:25:26 <fasta> opqdonut: but I found some when I used fundeps.
09:25:31 <cantor> Toxaris:oh i have it, thank you
09:25:39 <chrisdone> made a simple markdown blog maker if it's useful to anyone http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1287 I just set it up for my own blog http://chrisdone.com/blog/ the markdown and highlighting-kate libs make it really easy
09:25:44 <dolio> fundeps are not H98.
09:25:50 <hellask> fasta: are those bugs? arent they just limitations?
09:26:01 <rwbarton> cantor: You can't have a newtype with multiple fields, you need data
09:26:16 <opqdonut> chrisdone: interesting, do you plan on releasing that?
09:26:25 <pumpkin_> chrisdone: hackage!!!
09:26:27 <pumpkin_> :P
09:26:27 <chrisdone> opqdonut: sure
09:26:48 <opqdonut> chrisdone: nice, i've been looking for a better one :)
09:26:49 <dons> ?yow
09:26:49 <lambdabot> Yow!  Now I get to think about all the BAD THINGS I did to a BOWLING
09:26:49 <lambdabot> BALL when I was in JUNIOR HIGH SCHOOL!
09:27:05 <opqdonut> and pandoc rules
09:27:12 <pumpkin_> chrisdone:     , blogForce    :: Bool does that mean you're a jedi?
09:27:12 <chrisdone> opqdonut: agreed!
09:27:29 <chrisdone> pumpkin_: that forces it to re-render all the pages rather than ignoring unchanged ones
09:27:36 <pumpkin_> oh I see :)
09:27:37 <chrisdone> been useful for my tinkering
09:27:42 <pumpkin_> so you're not a jedi? :(
09:27:49 <chrisdone> :P
09:28:19 <Badger> :(
09:29:59 <gio123> can somebody correct following sentence:
09:30:01 <gio123> in the article is given such modification of the logic, that we can introduce following notions
09:30:11 <gio123> I mean english correction
09:30:19 * SamB_irssi wonders what bug fasta was talking about
09:30:55 <cjb> gio123: "The article modifies the logic such that we can introduce the following notions.." perhaps?
09:31:25 <pumpkin_> chrisdone: is blogRoot necessary? or do you just dislike relative paths?
09:31:34 <rwbarton> SamB_irssi: it's a vaporbug
09:31:41 <chrisdone> pumpkin_: that's for the web URL
09:31:43 <doserj> the article presents a modification of the logic such that...
09:31:58 * doserj doesn't think that articles can modify logics...
09:32:13 <SamB_irssi> @ask fasta what is this about bugs in GHC's Haskell 98 type inference ?
09:32:13 <lambdabot> Consider it noted.
09:32:14 <chrisdone> pumpkin_: (not always the same as the file path) and I'm thinking of adding pretty urls at some point
09:32:19 <pumpkin_> ah ok
09:34:49 <chrisdone> catMaybes<333
09:37:01 <roconnor> @type unfoldr
09:37:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:37:16 <rntz> Is there some flag I can pass to ghc[i] to ask it to strictly conform to haskell 98?
09:37:33 <pumpkin_> eww haskell 98, don't do that
09:38:07 <chrisdone> @src catMaybes
09:38:08 <lambdabot> catMaybes ls = [x | Just x <- ls]
09:38:31 <chrisdone> .. nice
09:42:05 <hackage> Uploaded to hackage: higherorder 0.0
09:46:24 <ddarius> rntz: You can try -fno-glasgow-exts
09:48:24 <Cheshire> @hackage higherorder
09:48:24 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/higherorder
09:52:03 <gio123> can one point me good paper about coinduction?
09:52:08 <pumpkin_> "I suggest we do voting by email, and restrict voting to those who have ever posted on haskell-cafe before 1 Jan 2009. "
09:52:10 <pumpkin_> :(
09:52:17 <ddarius> @google a tutorial on coinduction
09:52:19 <lambdabot> http://citeseer.ist.psu.edu/jacobs97tutorial.html
09:52:25 <pumpkin_> I read cafe, but I haven't posted anything on it :(
09:52:28 <gio123> can one point me good paper about lattice theory?
09:52:29 <pumpkin_> ah well
09:52:37 <pumpkin_> @google lattice theory paper
09:52:39 <lambdabot> http://www.essaytown.com/topics/lattice_theory_essays_papers.html
09:52:39 <lambdabot> Title: Lattice Theory Essays & Term Papers - Lattice Theory Research Paper Essay - Latt ...
09:52:44 <pumpkin_> lol
09:52:47 <pumpkin_> I fail
09:52:52 * dolio seconds ddarius' recommendation.
09:53:10 <pumpkin_> gio123: do you program in haskell?
09:54:09 <gio123> no
09:54:32 <gio123> can one point me good paper about operators theory?
09:55:02 <rwbarton> @google google
09:55:02 <lambdabot> http://www.google.com/
09:55:02 <lambdabot> Title: Google
09:55:29 <koeien_home> gio123: #math
09:55:31 <gio123> @google operators theory
09:55:32 <lambdabot> http://www.math.niu.edu/~rusin/known-math/index/47-XX.html
09:55:32 <lambdabot> Title: 47: Operator theory
09:55:37 <pumpkin_> http://tinyurl.com/cgbytf is another solution
09:57:57 <Toxaris> pumpkin: nice :)
09:58:11 <gio123> can one point me good paper about cpo?
09:58:24 <ddarius> Google can
09:58:28 <gio123> :)
09:58:32 <gio123> google dies
09:58:36 <gio123> :(
09:58:59 <pumpkin_> gio123: I think the point is that google scholar probably is a better place to be getting a literature overview
09:59:39 <pumpkin_> but I may be wrong :)
09:59:42 <z0d> Complete partial order?
09:59:57 <gio123> yes
10:00:01 <pumpkin_> County Prosecutor's Office
10:00:02 <pumpkin_> oh
10:00:05 <gio123> z0d yes
10:05:11 <roconnor> why do I need the ~ in let (f, ~(target:s)) = splitAt (nth-1) alive
10:05:16 <roconnor> I thought all lets were lazy?
10:05:40 <koeien_home> pattern matches are not lazy
10:05:58 <roconnor> but lets are lazy
10:05:58 <rwbarton> > let Just f = Nothing in 3
10:06:00 <lambdabot>   3
10:06:10 <rwbarton> > let (Just f, _) = (Nothing, "foo") in 3
10:06:12 <lambdabot>   3
10:06:18 <dolio> Probably because it's nested.
10:06:30 <roconnor> dolio: probably, but that seems weird
10:06:48 <roconnor> let's are lazy, but once the outer matches then the inner ones are done?
10:06:48 <rwbarton> > let (Just f, s) = (Nothing, "foo") in s
10:06:50 <lambdabot>   "* Exception: /tmp/6806514176093074791:71:36-65: Irrefutable pattern failed...
10:06:53 <roconnor> I guess perhaps
10:07:01 <Cheshire> > let (Just f, _) = (Nothing, "foo") in f
10:07:03 <lambdabot>   * Exception: /tmp/5357707905386585656:71:36-65: Irrefutable pattern failed ...
10:07:14 <rntz> roconnor: "lets are lazy" is, I think, an oversimplification...
10:07:16 <roconnor> > let (Just f, ~s) = (Nothing, "foo") in s
10:07:18 <lambdabot>   "* Exception: /tmp/6284228629805030596:71:36-66: Irrefutable pattern failed...
10:07:26 <rwbarton> > let (~(Just f), s) = (Nothing, "foo") in s
10:07:28 <lambdabot>   "foo"
10:07:30 <roconnor> ah right
10:07:50 <roconnor> rntz: apparently
10:08:18 <pumpkin_> so ~ is saying "assume this pattern is correct until you really need to know"?
10:08:26 <koeien_home> more ore less, yes :)
10:08:54 <rntz> well, it says "delay destructuring" - and since checking is part of destructuring, if you never need to destructure, it never checks
10:10:15 <pumpkin_> gio1239: so what brings you to #haskell? :)
10:10:59 <gio1239> I am learning haskel
10:11:37 <dolio> If you look at the report, it gives clues: let {p1=e1 ; p2=e2 ...} in e0 ==> let (~p1,~p2,...) = (e1,e2,...) in e0.
10:11:38 <hallongrottan> that's nice!
10:12:32 <pumpkin_> gio1239: great!
10:13:41 <dolio> Also: "Operationally, this means that no matching is done on a ~apat pattern until one of the variables in apat is used. At that point the entire pattern is matched against the value, and if the match fails or diverges, so does the overall computation."
10:14:03 <dolio> Which means you need to ~ inner patterns if you don't want them checked.
10:14:45 <rwbarton> And finally, let p = e1 in e0 ==> case e1 of ~p -> p0 (where no variable in p appears free in e1)
10:15:02 <ddarius> More simply, let P x = ... in ... translates to case ... of ~(P x) -> ...
10:17:09 <dolio> Right. I meant the rule for multiple lets indicates that "case (e1,e2...) of ~(p1,p2...) -> e0" isn't enough to delay things right. Otherwise they might as well use that.
10:17:37 <roconnor> ``At that point the entire pattern is matched against the value
10:17:40 <roconnor> I didn't know this
10:17:51 <roconnor> I'm a haskell n00b!
10:17:56 <dolio> :)
10:18:07 <rwbarton> Isn't everyone?
10:18:12 <roconnor> yes
10:18:31 <roconnor> well, maybe not augustss
10:18:40 <roconnor> he probably knew that
10:18:48 <ddarius> He probably wrote it.
10:18:54 <roconnor> :)
10:19:04 <skorpan> @pl get >>= \cpu -> return $ xReg cpu
10:19:04 <lambdabot> xReg `fmap` get
10:19:29 <pumpkin_> so @pl prefers infix fmap?
10:19:32 <rwbarton> :t gets ?xReg
10:19:33 <lambdabot> forall s a (m :: * -> *). (MonadState s m, ?xReg::s -> a) => m a
10:20:01 <hallongrottan> @pl get >>= return . xReg
10:20:01 <lambdabot> xReg `fmap` get
10:20:04 <hallongrottan> okee
10:20:07 <dolio> @pl liftM (+1) readLn
10:20:08 <lambdabot> fmap (1 +) readLn
10:20:20 <skorpan> even lambdabot dislikes liftM...
10:20:22 <koeien_home> this is not correct?
10:20:27 <koeien_home> (1+) /= (+1) in general
10:20:34 <skorpan> koeien_home: when isn't it?
10:20:40 <dolio> Yeah. @pl assumes commutativity.
10:20:44 <koeien_home> why should (+) be commutative? :)
10:20:51 <skorpan> i'm not sure... :(
10:21:10 <koeien_home> well for ordinary numbers it is
10:21:11 <ddarius>  @pl assumes a lot of things that aren't necessarily true
10:21:18 <ziman> isn't it an axiom of the Num class?
10:21:33 <StoneToad> I though that Num required + to be commutative?
10:21:49 <pumpkin_> StoneToad: I don't think @pl knows that
10:21:58 <lilac> koeien_home: you object to that but not lambdabot assuming Monad f => Functor f? :)
10:22:01 <dolio> > 1 + 1e-10 + (-1)
10:22:03 <lambdabot>   1.000000082740371e-10
10:22:07 <koeien_home> lilac: ha. :)
10:22:08 <dolio> > 1 + 1e-30 + (-1)
10:22:09 <lambdabot>   0.0
10:22:11 <StoneToad> pumpkin_: so it works, but only by accident?
10:22:29 <dolio> > 1 + (-1) + 1e-30
10:22:30 <lambdabot>   1.0e-30
10:23:04 <asgaroth> lilac: Correct me if I'm wrong, but isn't any monad instance that isn't crap an instance of Functor?
10:23:09 <rwbarton> dolio: Technically, you only proved (+) is either not commutative or not associative.
10:23:17 <dolio> True. :)
10:23:30 <lilac> asgaroth: every Monad instance gives rise naturally to a Functor instance (and indeed an Applicative instance)
10:23:34 <dolio> Not being associative is a worse crime, really. :)
10:23:39 <koeien_home> i think associativity is more fundamental than commutativity :)
10:23:43 <rwbarton> dolio: Yes :)
10:23:45 <koeien_home> dolio: right
10:23:49 <pumpkin_> asgaroth: someone evil could define a mismatched functor/monad instance
10:23:53 <lilac> asgaroth: but since Functor is not a superclass of Monad, it's legal to define the Monad instance but not the Functor instance
10:23:59 <pumpkin_> but functor isn't defined as a subclass of monad
10:24:08 <asgaroth> lilac: that's what I meant by "not crap" :)
10:24:11 <dolio> (+) on floats probably is commutative.
10:24:12 <mmorrow> @check \x -> x == x+pi-pi::Double
10:24:13 <lambdabot>   Couldn't match expected type `Double' against inferred type `Bool'
10:24:18 <mmorrow> @check \x -> x == (x+pi-pi::Double)
10:24:19 <lambdabot>   "Falsifiable, after 5 tests:\n-0.2\n"
10:24:35 <StoneToad> o+O
10:24:35 <lilac> asgaroth: well, if you define 'crap' such that you're right, then you're trivially right ;-)
10:24:36 <koeien_home> why is Double in Eq ?
10:25:00 <pumpkin_> koeien_home: for convenience :P
10:25:03 <rntz> Double is in Num, which is a subclass of Eq
10:25:05 <mmorrow> @check \x y z -> (x+y)+z == x+(y+z::Double)
10:25:06 <koeien_home> it's almost never correct to do it
10:25:06 <lambdabot>   "Falsifiable, after 10 tests:\n10.0\n-0.4\n1.2\n"
10:25:08 <rntz> and, yeah, convenience
10:25:10 <koeien_home> rntz: i know, but why is that the case?
10:25:21 * lilac wonders whether it's possible for a tycon to have incompatible but legal Functor and Monad instances
10:25:21 <rwbarton> koeien_home: do you think Double should be in Ord?
10:25:22 <rntz> koeien_home: don't ask me man, I didn't do it
10:25:27 <pumpkin_> koeien_home: because the basic Numeric classes don't make much sense probably
10:25:33 <koeien_home> rwbarton: yeah Ord seems sensible :)
10:25:42 <dolio> For non-commutative, see lazy naturals.
10:25:48 <pumpkin_> koeien_home: how about the infinity and NaN values?
10:25:50 <rwbarton> @src Ord
10:25:50 <lambdabot> class  (Eq a) => Ord a  where
10:25:50 <lambdabot>     compare      :: a -> a -> Ordering
10:25:50 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
10:25:50 <lambdabot>     max, min         :: a -> a -> a
10:25:54 <mmorrow> or rubix cubes
10:25:59 <asgaroth> lilac: Hmm, but I'd say that one should care about monad instances that don't have functor instances, so there's no need for lambdabot to assume this anymore than, say, assume that the monad laws hold.
10:26:03 <dolio> Where _|_ + Succ Zero = _|_ but Succ Zero + _|_ = Succ _|_, likely.
10:26:07 <koeien_home> pumpkin_: i forgot about the practicality of Haskell for a moment :)
10:26:14 <koeien_home> NaN is ...
10:26:30 <koeien_home> bleh
10:26:31 <pumpkin_> koeien_home: I hate ieee arithmetic :P
10:26:39 <pumpkin_> but it's awfully convenient
10:26:45 <koeien_home> pumpkin_: yeah although it's pretty fast
10:26:58 <pumpkin_> it should be relegated to its own monad from which no one can escape! like IO
10:26:58 <dolio> Or _|_ + fix Succ = _|_ but fix Succ + _|_ = fix Succ.
10:27:00 <pumpkin_> :P
10:27:14 <koeien_home> pumpkin_: unsafePerformIEEEComputation :)
10:27:22 <mmorrow> sclv wrote an IEEE monad
10:27:26 <pumpkin_> :o
10:27:38 <pumpkin_> http://hackage.haskell.org/packages/archive/ieee-utils/0.4.0/doc/html/Numeric-IEEE-Monad.html
10:27:41 <pumpkin_> wow
10:27:58 <mmorrow> you can mess with the rounding mode at your own peril, look at the fpu state, all kinds of horrific stuff!
10:28:10 <pumpkin_> I imagine it's intel-specific?
10:28:18 <pumpkin_> or maybe not
10:28:28 <mmorrow> err, it's only standard C lib specific..
10:28:48 <mmorrow> (the extent to which that's specific to any arch i'm not sure
10:28:48 <mmorrow> )
10:29:21 <wabash> Hey, anyone have any idea about the overhead associated with foreign function calls?
10:29:31 <wabash> (what's the acronym for that again? FFM? FFH?)
10:29:45 <pumpkin_> FFI?
10:30:01 <mmorrow> but for instance with the rounding mode, ghc's code will happily context switch in the middle of your computation and another thread might be doing a bunch of computations with your super leet fp settings to a bitter end (eg)
10:30:19 <mmorrow> pumpkin: yes
10:30:20 <pumpkin_> wabash: shouldn't be much overhead, except the possible conversions from your native haskell types to whatever the foreign function expects (but that's not the FFI's fault)
10:30:26 <mmorrow> oh, n/m
10:30:40 <pumpkin_> mmorrow: that's sad
10:30:49 <mmorrow> pumpkin: yeah
10:31:09 <wabash> pumpkin_: Ok, cool. Well, say I'm using C. Are there Haskell types that are identical to C types? or do I have to do conversions?
10:31:20 <pumpkin_> CArray, CInt, etc.
10:31:24 <mmorrow> @hoogle Foreign.C
10:31:24 <lambdabot> module Foreign.C
10:31:24 <lambdabot> package c2hs
10:31:24 <lambdabot> package Cabal
10:31:26 <pumpkin_> don't fall for CReal :P
10:31:30 <pumpkin_> that's a different C
10:31:30 <mmorrow> @hoogle Foreign.C.Types
10:31:31 <lambdabot> module Foreign.C.Types
10:31:31 <lambdabot> package xcb-types
10:31:46 <rwbarton> pumpkin_: That confused me for a while :)
10:31:48 <lament> wabash: you should read the FFI manual
10:31:52 <mmorrow> @hoogle malloc
10:31:52 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
10:31:52 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
10:31:52 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
10:31:58 <mmorrow> @hoogle mallocBytes
10:31:58 <lambdabot> Foreign.Marshal.Alloc mallocBytes :: Int -> IO (Ptr a)
10:31:58 <lambdabot> Data.ByteString.Internal mallocByteString :: Int -> IO (ForeignPtr a)
10:31:58 <lambdabot> Foreign.Marshal.Pool pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
10:32:04 <lament> wabash: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
10:32:14 <rwbarton> pumpkin_: "wow, I don't remember C doing this"
10:32:19 <erikc> preparing a presentation on haskell for the vancouver lisp users group...things to highlight: static typing and purity (using algebraic data types, typeclasses, and monads as examples), a high quality free implementation, a growing community with libs that work
10:32:21 <pumpkin_> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi/ffi/ffi/ffi/ffi.html boo doesn't work
10:32:32 <erikc> im not really sure what else to highlight for a lisp crowd
10:32:36 <wabash> lament, pumpkin_ thank you.
10:33:02 <wabash> What is @hoogle? Is the "@" not part of it? Is it hoogle.com?
10:33:03 <lament> erikc: hey, cool, i didn't realize there was a vancouver lisp group
10:33:09 <lilac> asgaroth: i disagree; the report requires that the monad laws hold, so it's reasonable for \b to assume them. the report does not (i think) require a Functor instance for every Monad instance
10:33:10 <lament> erikc: is there by any chance a vancouver haskell group?
10:33:22 * lilac thinks that Functor instances must be unique in general
10:33:23 <pumpkin_> rwbarton: it would be nice to have an arbitrary precision real type in c :P
10:33:33 <erikc> lament: there is, very small though, the last meeting i went to was ... me and the organizer
10:33:36 <beelsebob> wabash: haskell.org/hoogle
10:33:37 <erikc> it was a date!
10:33:47 <lament> erikc: <3
10:33:50 <wabash> ok, thanks.
10:34:06 <mm_freak> randomNumber :: Integer
10:34:14 <erikc> but there are more ppl, its held at the microsoft canada development center
10:34:24 <lament> ooh
10:34:27 <lament> in richmond?
10:34:30 <erikc> yea
10:34:33 <mm_freak> hmm
10:34:37 <mm_freak> randomValue :: a
10:34:44 <lament> erikc: do they have a webpage?
10:35:04 <erikc> http://groups.google.com/group/hugvan
10:35:48 <lament> nice
10:35:52 <lament> 19 members!
10:37:37 <lament> i'll try to go to the next meeting
10:38:39 <lepassive> what's the name of Data package in the REPOs ?
10:39:31 <sw17ch> @seen dons
10:39:31 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 47m 18s ago.
10:39:34 <asgaroth> lilac: good point. Although since conceptually every monad is a functor I think this should be a requirement.
10:40:13 <jberryma1> trying to cabal-install hlint and got this: "cabal: cannot configure hlint-1.2. It requires base ==4.0.*". is my GHC too old then?
10:40:25 <erikc> does ghc ffi use libffi to handle calling conventions or does it generate correct calling sequences
10:40:32 <sw17ch> jberryma1: hlint needs ghc-6.10
10:40:40 <SamB_irssi> lilac: the Monad class should be a subclass of Functor ...
10:41:09 <jberryma1> sw17ch: thanks. too old.
10:41:24 <sw17ch> jberryma1: it's worth upgrading. :) hlint is a great tool
10:41:38 <lepassive> hello ? Could not find module `Data.Time':
10:41:38 <lepassive>   Use -v to see a list of the files searched for.
10:41:39 <lilac> SamB_irssi: the Monad class should be a subclass of Applicative ;-)
10:41:54 <SamB_irssi> lilac: possibly
10:42:03 <SamB_irssi> though I don't actually use Applicative
10:42:05 <hackage> Uploaded to hackage: dequeue 0.1.2
10:42:17 <Cheshire> @hackage dequeue
10:42:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dequeue
10:42:36 <SamB_irssi> lilac: in any case, I never said whether or not it should be a direct subclass
10:42:40 <lepassive> @hackage Data
10:42:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Data
10:42:48 <Cheshire> :/
10:42:53 <Cheshire> what the hell is that dequeue thing
10:42:54 <lilac> SamB_irssi: i never said i disagreed with you ;-)
10:43:46 <lilac> Cheshire: i'm guessing it's an implementation of a deque for haskell :-)
10:44:38 <lilac> (presumably it's more efficient than a fingertree, otherwise i'm not sure what the point would be)
10:46:03 <jberryma1> sw17ch: looks cool. hmm, hopefully the new GHC will trickle down from Debian's experimental branch soon
10:46:04 <stefk0> \join #logic
10:46:38 <redditbot> Starting to read Real World Haskell
10:46:57 <Cheshire> redditbot, good luck with it ... you can ask any questions here if you get stuck
10:47:16 <lilac> Cheshire: redditbot is a bot ;-)
10:47:56 <lepassive> Where is my Data.Time module ?
10:48:03 <Cheshire> @hackage Data.Time
10:48:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Data.Time
10:48:22 <lepassive> 404
10:48:56 <lilac> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/time-1.1.2.3
10:49:16 <dolio> @pl \x -> 1 + x + (-1)
10:49:16 <lambdabot> id
10:49:45 <Cheshire> @pl 0
10:49:45 <lambdabot> 0
10:49:46 <Cheshire> @pl 0 + x
10:49:47 <lambdabot> x
10:49:56 <lilac> > fmap (\x -> 1 + x + (-1)) [0,1e-200,1,1e308]
10:49:58 <lambdabot>   [0.0,0.0,1.0,1.0e308]
10:50:00 <lament> @pl x * y
10:50:00 <lambdabot> x * y
10:50:13 <lepassive> lilac, I can't find it in the REPOs I've installed whatever matches the word libghc6-time and still can't import it
10:50:36 <lilac> lepassive: debian?
10:50:42 <lepassive> lilac, ubuntu
10:50:50 <lilac> libghc6-time-dev
10:51:21 <lilac> (at least, i /think/ that's where it lives)
10:51:41 * lilac checks
10:51:45 <lepassive> lilac, thanks alot i guess i should 've restarted the terminal
10:54:25 <Cheshire> @pl \a b c d e f g -> a b a c a d a e a f a g a b a c a d a e a f a g a
10:54:28 <lambdabot> ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .)
10:54:28 <lambdabot>  .) .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) .
10:54:28 <lambdabot>  (((((flip .) .) .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip
10:54:28 <lambdabot> .) .) .) .) . (((((flip .) .) .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((ap .) .) . (((flip .) .) .
10:54:31 <lambdabot> ) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (ap .) . ((flip .) .) . ((
10:54:34 <lambdabot> [4 @more lines]
10:54:36 <lambdabot> optimization suspended, use @pl-resume to continue.
10:58:35 <dcoutts_> gwern: did you discover if the problem in http://hackage.haskell.org/trac/hackage/ticket/494 is already resolved in the Cabal-1.6 branch?
11:00:16 <drhodes> > fromMaybe (error "in function foo") (fail "")
11:00:19 <lambdabot>   * Exception: in function foo
11:00:43 <pumpkin_> :t fromMaybe
11:00:46 <lambdabot> forall a. a -> Maybe a -> a
11:00:47 <drhodes> so it'd be nice to have a NullType instead of an error sometimes.
11:01:08 <pumpkin_> I've never used fromMaybe before
11:01:14 <paper_cc> @ty catch
11:01:17 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
11:01:38 <drhodes> fromJust craps out and leaves no trace, from what I gather so far.
11:03:09 <gwern> dcoutts_: yes
11:03:31 <dcoutts_> gwern: and it is already fixed in the 1.6 branch?
11:04:01 <gwern> yes
11:04:25 <dcoutts_> ok, ta
11:05:26 <trofi> @pl a -> a a a a a
11:05:34 <lambdabot> (line 1, column 3):
11:05:42 <lambdabot> unexpected ">" or "-"
11:05:43 <trofi> @pl \a -> a a a
11:05:46 <sw17ch> @pl \a -> a a a a a
11:05:48 <lambdabot> Plugin `pl' failed with: thread killed
11:05:49 <lament> @pl a a a a a
11:05:57 <lambdabot> join (join id)
11:06:01 <skorpan> @djinn a -> a -> a -> a -> a
11:06:07 <sw17ch> @pl f a = a a a a a
11:06:09 <lambdabot> Plugin `pl' failed with: thread killed
11:06:15 <skorpan> hm, am i doing it wrong?
11:06:16 <lambdabot> f _ _ _ a = a
11:06:20 <skorpan> oh...
11:06:22 <mmorrow> @pl ($ ($ (\x -> x x))) (\x -> ($ ($ x)) ($ ($ x)))
11:06:31 <lambdabot> Plugin `pl' failed with: thread killed
11:06:34 <Cheshire> @pl \a -> a a a a a
11:06:38 <lament> gah
11:06:39 <Cheshire> @pl \a -> a a a a
11:06:39 <mmorrow> @pl ($ ($ (\x -> x x))) (\x -> ($ ($ x)) ($ ($ x)))
11:06:39 <lambdabot> ap id id $ ap id id
11:06:41 <lambdabot> Plugin `pl' failed with: thread killed
11:06:42 <Cheshire> @pl \a -> a a a
11:06:44 <lambdabot> join (join (join (join id)))
11:06:45 <Cheshire> @pl \a -> a a
11:06:46 <lambdabot> join (join (join id))
11:06:48 <paper_cc> mmorrow: @pl it even more for me? =)
11:06:50 <lambdabot> ap id id $ ap id id
11:06:50 <lambdabot> optimization suspended, use @pl-resume to continue.
11:06:52 <lambdabot> join (join id)
11:06:54 <lament> guys, you don't need to give the "\a ->" part to pl
11:06:54 <lambdabot> join id
11:07:03 <lament> @pl a a a a a
11:07:05 <lambdabot> a a a a a
11:07:06 <skorpan> @pl \a b c d e f g h -> h g f d c b a
11:07:11 <lambdabot> (((const .) .) .) . flip (flip . ((flip . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (
11:07:11 <lambdabot> flip . (flip .) . flip (flip . flip id)))))
11:07:11 <lambdabot> optimization suspended, use @pl-resume to continue.
11:07:14 <lament> oh wait, you do :)
11:07:19 <mmorrow> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
11:07:20 <lambdabot> ap (. join id) (. join id)
11:07:34 <mmorrow> @pl \f -> (\x -> x x) (\x -> x x)
11:07:39 <lambdabot> const (ap id id (ap id id))
11:07:40 <lambdabot> optimization suspended, use @pl-resume to continue.
11:07:40 <mmorrow> @pl \x -> x x) (\x -> x x)
11:07:41 <lambdabot> (line 1, column 10):
11:07:41 <lambdabot> unexpected ")"
11:07:41 <lambdabot> expecting variable, "(", operator or end of input
11:07:45 <mmorrow> @pl (\x -> x x) (\x -> x x)
11:07:49 <lambdabot> ap id id (ap id id)
11:07:49 <lambdabot> optimization suspended, use @pl-resume to continue.
11:07:57 <skorpan> lol, this is pure abuse
11:08:02 <mmorrow> heh
11:08:03 <ziman> :t ap id id (ap id id)
11:08:05 <pumpkin_> > pure
11:08:07 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
11:08:07 <lambdabot>     Probable cause: `id' is applied to too few arguments
11:08:07 <lambdabot>     In the second argument of `ap', namely `id'
11:08:08 <lambdabot>       Ambiguous occurrence `pure'
11:08:08 <lambdabot>      It could refer to either `Control.Appl...
11:08:11 <rwbarton> @pl \x -> ($ ($ x))
11:08:13 <pumpkin_> > abuse pure
11:08:13 <lambdabot> flip id . flip id
11:08:16 <lambdabot>   Not in scope: `abuse'    Ambiguous occurrence `pure'
11:08:16 <lambdabot>      It could refer to...
11:08:18 <Cheshire> :t pure ?awesome
11:08:21 <lambdabot> forall a (f :: * -> *). (Applicative f, ?awesome::a) => f a
11:08:21 <pumpkin_> :t abuse
11:08:25 <lambdabot> Not in scope: `abuse'
11:08:27 <ziman> > pure abuse :: Just Expr
11:08:30 <lambdabot>       Ambiguous occurrence `pure'
11:08:31 <lambdabot>      It could refer to either `Control.Appl...
11:08:47 <mmorrow> rwbarton: oh nice, flip id . flip id  is one of my new favorites
11:08:54 <mmorrow> @type flip id . flip id
11:08:58 <lambdabot> forall c a c1. a -> (((a -> c1) -> c1) -> c) -> c
11:09:29 <skorpan> lambdabot doesn't like `b'?
11:10:30 <trofi> :t b
11:10:37 <lambdabot> Expr
11:10:46 <trofi> :t bb
11:10:55 <lambdabot> Not in scope: `bb'
11:12:08 <roconnor> @seen Cale
11:12:15 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
11:12:49 <Toxaris> skorpan: I guess c and c1 come from the two uses of (flip id), while the a comes from (.)
11:12:55 <Cale> yes?
11:13:08 <Toxaris> skorpan: while all the b's get unified away
11:13:41 <roconnor> Cale: I've been pondering a 2-D (and/or 3-D) geometry library.
11:13:51 <roconnor> Cale: I've been thinking about orientation
11:14:26 <Cale> okay
11:14:32 <roconnor> There are at least 4 concepts to think about:
11:14:41 <roconnor> orientation which is a torsor
11:14:51 <roconnor> rotation which is a group
11:14:59 <roconnor> the covering space for rotation
11:15:07 <roconnor> and the lie algebra for rotation
11:15:40 <roconnor> I wonder if all four are needed and need separate types
11:16:18 * roconnor wonders if these questions beloing in #haskell-in-depth
11:16:21 <Cale> In 2D, you have the option of using complex numbers.
11:16:28 <rwbarton> roconnor: by "rotation" do you mean any rigid motion?  or just rotations around the origin?
11:16:40 <rwbarton> any orientation-preserving rigid motion I suppose
11:16:42 <Cale> You have a nice field structure which can represent rotations, scaling, positions...
11:17:12 <roconnor> field?
11:17:20 <Cale> yes.
11:17:26 <Cale> Complex numbers form a field :)
11:17:39 <roconnor> rwbarton: I've decomposed rigid motion into translation and orientation
11:17:51 <roconnor> Cale: oh right
11:18:47 <roconnor> Cale: and I was thinking 2x2 unital matrices :)
11:19:57 <Cale> Even though orientations are actually a torsor, I'm not sure there's much convenience in not just sticking with a group of rotations, and picking a convention for what that means in terms of orientations.
11:20:11 <roconnor> bah
11:21:03 <rwbarton> The lie algebra for rotation isn't very exciting in 2D.
11:21:39 <roconnor> that's like saying there is no reason to give points and vectors different types
11:21:48 <hellask> @faq can haskell take the stockmarket as input and predict tomorrows rising stock?
11:21:48 <lambdabot> The answer is: Yes! Haskell can do that.
11:21:53 <Cale> Right, and I agree with that as well.
11:21:57 <hellask> wow this ghc shit is good
11:22:05 <hellask> java cant do that
11:22:13 <roconnor> ah
11:22:15 <glguy> sure it can, you type in the program, and it will compile it
11:22:16 <rwbarton> If you've singled out rotations around the origin, then there isn't any such reason.
11:22:17 <sw17ch> hellask: well, the answers aren't necessarily correct :)
11:22:19 <Cale> I don't actually see much convenience in separating points and vectors for 2D geometry.
11:22:34 <lament> Java is not stockmarket-complete
11:22:52 <Cale> Just use complex numbers, and points, vectors, scalings and rotations, orientations, etc. are all the same thing.
11:22:56 <roconnor> Cale: because the type system proves all your functions on points is invarient over change of origin?
11:23:23 <roconnor> Cale: do you have a degree in CS?
11:23:28 <Cale> no
11:23:33 <roconnor> ah
11:23:36 <roconnor> that explains it
11:23:47 <Cale> I'm a pure mathematics person :)
11:23:55 <roconnor> mathematicians like untyped things for some strange reason.
11:23:58 <_kit_> you don't need school for mathematics
11:24:09 <rwbarton> No we don't
11:24:34 <roconnor> I think they like the ability to make mistakes because they never have to worry about the blackboard catching them.
11:24:50 <rwbarton> We just differentiate between talking about an affine space and a vector space where you've chosen an origin.  And in this case notions of angles, etc.
11:24:54 <Cale> I think a better way of putting it is that mathematicians don't require types to be disjoint.
11:25:14 <erikc> a blackboard with handwriting recognition and typechecking would be hottt
11:25:18 <Cale> Every predicate is a type.
11:25:25 <Cale> (to a mathematician)
11:25:34 <Cale> Every set is a type as well.
11:25:41 <Cheshire> erikc, for what purpose/
11:26:03 <lament> Cale: if you're a pure mathematics person, how come you're into type theory so much? :)
11:26:17 <Cale> lament: CS is a hobby of mine :)
11:26:26 <Cale> But I'm not really all *that* into type theory.
11:26:32 <Cheshire> roconnor, Category Theory is typed ?
11:26:50 <Cale> lament: I'm just trying to compare the ways of thinking.
11:27:13 <roconnor> Cheshire: it's true.  But Cale went to U of Waterloo, where they try to avoid Category Theory at all costs.  I only vaguely saw it in a 4th year topology course.
11:27:23 <lament> Cale: i think type theory is unfairly ignored/discounted by the foundations of math
11:27:29 <Cheshire> hah
11:27:37 <Cheshire> they don't teach you the good stuff in classes
11:27:37 <lament> Cale: instead they represent everything as sets which is utterly ridiculous to me
11:27:56 <Cheshire> lament, type theory is a foundation ...
11:28:04 <Cale> roconnor: I don't know... I saw CT diagrams in a number of my courses...
11:28:07 <lament> Cheshire: yes, it is, but one mainly ignored by mathematicians
11:28:13 <roconnor> Cale: oh?
11:28:15 <Cale> roconnor: There's no course on it.
11:28:24 <Cheshire> lament, well it's not proof theoretically as strong as ZFC
11:28:28 <roconnor> Cale: what courses?
11:28:35 <Cheshire> any type theory I know of anywya
11:28:48 <lament> set theory is like duck-typing
11:28:50 <roconnor> Cheshire: It is conjectured that Coq's CIC is stronger that ZFC.
11:28:57 <lament> from a programmer's perspective it's a horrible way of thinking
11:29:01 <Cale> roconnor: Linear Algebra 2, Algebraic Geometry, Algebraic Topology
11:29:05 <Cheshire> roconnor, that's crazy :S
11:29:12 <Cale> There were some in rings.
11:29:19 <Eelis> if, in my package's .cabal, i have a bunch of executable sections which differ only in the main-is fields, is there a way to factor out the common fields, or do i really have to repeat them over and over?
11:29:37 <Cheshire> roconnor, I guess the strength comes from universese?
11:29:39 <roconnor> Cale: wow.  Linear Algebra 2.
11:29:44 <paper_cc> [OT] Can anyone remind me where Mu is?
11:29:45 <roconnor> Cheshire: I believe so
11:29:45 <dcoutts_> Eelis: sorry, at the moment you have to just repeat.
11:29:48 <Cheshire> roconnor, (what is the result from?)
11:29:52 <Cale> roconnor: Just a little.
11:29:59 <Cheshire> conjecture*
11:29:59 <Eelis> dcoutts_: ok :( thanks for the quick response.
11:30:10 <Cale> roconnor: But that's where commutative diagrams were introduced.
11:30:15 <roconnor> Cheshire: I vaguely got the impression that CIC was as strong as ZFC + mahlo cardinal.
11:30:19 <dcoutts_> Eelis: we have a plan to make it better, but don't hold your breath
11:30:33 <Eelis> dcoutts_: good to hear
11:30:55 <Cheshire> roconnor, Peter Dybjer showed that inductive-recursive definitions exist based on assumption of a mahlo cardinal
11:31:17 <Cheshire> roconnor, but in CIC you don't have induction-recursion (other than what you can fake with impredicative Set)
11:31:18 <roconnor> Cheshire: okay, you might know more about this than I do
11:31:50 <Cheshire> roconnor, well this (what I read from Peter Dybjer) isn't a lower bound.. it's an upper bound so it' tdoesn't really say anything..
11:32:25 <roconnor> Cale: anyhow. I appricate your input.
11:32:56 <roconnor> Cale: We have different viewpoints though.
11:32:59 <Cale> roconnor: Of course, I suppose you do have a point about ensuring what bits of information are used by a given function.
11:33:01 <Cheshire> roconnor, they mentioned Martin Lof here http://en.wikipedia.org/wiki/Proof-theoretic_ordinal#Theories_with_proof_theoretic_ordinal_the_Feferman-Sch.C3.BCtte_ordinal_.CE.930
11:33:14 <Cheshire> roconnor, but I guess CIC *is* stronger than that.. (maybe?)
11:33:41 <Cheshire> but I thought that ZFC is so powerful that we can't even study it's proof theory yet
11:33:46 <Cale> roconnor: However, it's still worth noting that even if you newtype things, they can all be represented by complex numbers under the newtype.
11:34:25 <roconnor> Cale: oh sure.  I know one or more ways of representing all this.  The interface is what I'm pondering. :)
11:35:02 <roconnor> A nice restrictive interface helps prevents users from making mistakes.
11:35:36 <roconnor> in particular, myself
11:36:59 <rwbarton> roconnor: it depends on whether you want to model affine spaces, or vector spaces (with an origin), or the complex numbers (with points 0 and 1)
11:38:11 <roconnor> rwbarton: I want affine spaces, vector spaces, torsors, lie groups and maybe lie algebras, if they are useful.
11:38:33 <roconnor> of course affine spaces and vector spaces are also torsers and lie groups
11:38:44 <rwbarton> if you have more structure provided on your space, you might be able to identify some of the four things you listed originally
11:39:11 <roconnor> rwbarton: specifically I want useful types and functions for a 2-D geometry library
11:39:18 <roconnor> and maybe a 3-D library too
11:40:37 <rwbarton> roconnor: ok, let's say you have a type Point representing a point in the plane
11:40:46 <roconnor> ok
11:40:46 <rwbarton> roconnor: do you want your interface to contain a value  origin :: Point ?
11:40:53 <roconnor> not really
11:40:59 <rwbarton> ok
11:41:41 <Cheshire> roconnor, I just found this http://logical.futurs.inria.fr/coq/distrib/current/contribs/ZFC.html
11:41:45 <Cheshire> ZFC in Coq
11:41:59 <Cheshire> had not seen that before though
11:42:06 <hackage> Uploaded to hackage: SDL-mixer 0.5.5
11:42:06 <hackage> Uploaded to hackage: blogination 0.0
11:42:53 <roconnor> Cheshire: I think there might be cavets with that
11:43:42 <roconnor> rwbarton: I'd probably have a serialize, deserialize interface.
11:43:50 <roconnor> rwbarton: this would allow one to "see" the origin
11:44:08 <roconnor> so a user could define origin.
11:44:18 <roconnor> but I think there is no way of getting around that
11:44:29 <roconnor> otherwise there would be no ways of constructing points.
11:44:33 <rwbarton> right
11:44:48 <rwbarton> hmm
11:44:50 <roconnor> so I want to make it "difficult" to get the origin.
11:45:20 <roconnor> make it "difficult" to add two points
11:45:53 <rwbarton> what would this library be used for?
11:46:11 <Cheshire> roconnor, but I saw people trying to add powersets to type theory and they end up with LEM
11:46:25 <rwbarton> building descriptions of geometric figures and exporting them to an image file format?
11:46:30 <roconnor> rwbarton: my immediate use would be to write something like hieroglyphs / diagrams
11:49:55 <rwbarton> roconnor: maybe it makes sense to define a points topLeft, topRight, bottomLeft, bottomRight :: Point
11:50:01 <paper_cc> , where ''Mu
11:50:03 <lunabot>  luna: parse error on input `where'
11:50:03 <rwbarton> roconnor: if your goal is to produce a rectangular image
11:50:07 <paper_cc> , src ''Mu
11:50:10 <lunabot>  newtype Mu f = Mu (f (Mu f))
11:50:16 <paper_cc> , src ''FixF
11:50:18 <roconnor> rwbarton: My lib would be application independent
11:50:19 <lunabot>  newtype FixF f = InF {outF :: (f (FixF f))}
11:50:24 <rwbarton> roconnor: then you don't need any constructors for Points or Vectors
11:50:30 <paper_cc> , src ''Nu
11:50:31 <lunabot>  luna: Not in scope: type constructor or class `Nu'
11:50:38 <rwbarton> roconnor: but as you say you need some sensible way to obtain a point in the first place
11:50:44 <roconnor> rwbarton: exactly
11:50:47 <Cheshire> roconnor, the interpretation of type theory into set theory by assuming huge ordinals (beyond ZFC) gives an upper bound.. but not sure about lower bounds I think you have to do well ordering proofs or something
11:51:10 <rwbarton> roconnor: so your library can perform abstract operations on points in planes and the vector space that you get by considering the vectors between points
11:51:21 <rwbarton> roconnor: but if you want to actually create a point, you need to talk to some back end library
11:52:01 <roconnor> rwbarton: I'd put the back end as part of the same library, but yes.
11:52:23 <rwbarton> roconnor: yeah, I mean a conceptually different part, which could be swapped out
11:52:25 <roconnor> (the back end would be in a serialization module).
11:52:29 <roconnor> right
11:52:51 <roconnor> I'd argue that the empty set is a perfectly valid model of 2-D euclidean space
11:53:07 <roconnor> so I suppose you could swap out the non-empty back end with empty back end
11:53:17 <roconnor> and preserve the rest of the interface
11:54:06 <roconnor> (the empty set is a valid model because 2-D vectors form a transitive action (or whatnot) over the empty set)
11:54:29 <roconnor> I forget the exact definition of affine space.
11:54:50 <rwbarton> roconnor: then you probably want a type Point, a type Vector which is a vector space and which acts on Points by addition, a type of rigid transformations where you can construct elements as translations by Vectors or rotations around Points with given angles
11:54:51 <roconnor> I guess usually it is defined as a *non-empty* set that blah blah
11:55:08 <roconnor> but that non-empty clause is a cop-out
11:55:25 <roconnor> rwbarton: that is exactly what I'm thinking.
11:55:29 <rwbarton> not really, it's just a torsor for the additive group of vectors
11:55:32 <Cale> roconnor: Isn't it just a set with a vector space action on it?
11:55:42 <Cale> Maybe not...
11:55:50 <roconnor> Cale: the action has to be transitive or something like that
11:56:00 <Cale> that would make sense...
11:56:25 <rwbarton> Not just transitive, but there has to be a unique vector v taking p to q for every p and q.  (And, it has to be non-empty)
11:56:33 <rwbarton> (emphasis on unique)
11:56:37 <Cale> Ah, a faithful, freely transitive vector space action.
11:58:12 <rwbarton> obviously rigid transformations would form a group that acts on Points and also by Vectors (by considering just the rotation angle)
11:58:19 <roconnor> Cale: none of that implies non-empty, right?
11:58:30 <Cale> roconnor: it does imply nonempty
11:58:31 <roconnor> rwbarton: exactly
11:58:35 <Cale> er...
11:58:38 <roconnor> Cale: which clause?
11:59:26 <Cale> faithful, I think.
12:00:29 <Cale> Oh, I suppose if the vector space is trivial, then it doesn't quite work.
12:00:31 <rwbarton> But a torsor for the trivial group is also required to be nonempty. :)
12:01:06 <Cale> But if it's not trivial, then for any two distinct vectors v and w, we need an x in the affine space such that x + v is not x + w.
12:02:21 <roconnor> ah, faithful isn't in the definition of torsor
12:02:46 <rwbarton> roconnor: you're quite correct that the definition of principal homogeneous space (aka torsor) on wikipedia is wrong. :)
12:02:52 <rwbarton> s/that/in that/
12:02:53 <roconnor> ah
12:03:01 <rwbarton> It should also say that X is nonempty
12:03:12 <rwbarton> the third paragraph says this
12:03:51 <rwbarton> Oh, the definition of homogeneous space states nonempty.   That's good
12:04:05 <roconnor> if we have a non-empty space with a free and transitive group action, is it faithful?
12:05:27 <roconnor> ``But if it's not trivial, then for any two distinct vectors v and w, we need an x in the affine space such that x + v is not x + w.
12:05:44 <roconnor> maybe I should add a function that takes any two vectors and returns some point.
12:05:51 <roconnor> :)
12:06:12 <rwbarton> Do you want to be able to measure distances and angles between Points?
12:06:28 <roconnor> in Affine_Space: ``An affine space is a set with a faithful freely transitive vector space action, i.e. a torsor (or principal homogeneous space) for the vector space.
12:06:35 <roconnor> so there is the word faithful
12:06:39 <roconnor> intersting
12:06:53 <roconnor> I don't think I knew faithful was part of the definition
12:07:06 <roconnor> rwbarton: I want an inner product, yes.
12:08:06 <roconnor> rwbarton: my big question is, would the covering space of the rotations group be useful to have?
12:08:16 <roconnor> or the lie algebra
12:08:31 <Toxaris> ([a], a, [a]) is a zipper for [a], but how is ([a], [a]) called?
12:08:38 <roconnor> The lie algebra seems important if people want to do computation with angular velocities
12:08:58 <roconnor> Toxaris: ([a], a, [a]) is not the zipper for [a].
12:09:05 <dzrk> is there a way to get ghci to show the code for a given type?
12:09:05 <roconnor>  ([a], [a]) is the zipper
12:09:19 <dzrk> like :info, but with code?
12:10:41 <sw17ch> ...how is it called?
12:11:25 <rwbarton> roconnor: I'm puzzling over orientations
12:11:26 <roconnor> Toxaris:  ([a], a, [a]) is a pointed list
12:11:32 <roconnor> rwbarton: me too
12:11:42 <Toxaris> roconnor: not according to wikipedia, which presents "cursor = [ [0,1,2], 3, [4,5,6,7,8,9] ]" as an example zipper value
12:11:51 <sw17ch> Toxaris: ah....
12:12:01 <roconnor> Toxaris: once again, wikipedia is wrong
12:12:02 <sw17ch> > take 10 $ zip [1..] [2..]
12:12:04 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
12:12:04 <rwbarton> roconnor: if the vector space acting on your affine space is just an inner product space that doesn't let you say "rotate by theta radians counterclockwise"
12:12:11 <Toxaris> of course I trust you more then wikipedia ... :)
12:12:23 <roconnor> rwbarton: an oriented affine space
12:12:23 <sw17ch> I usually use ([a],[a]) for a zipper structure for lists
12:12:34 <sw17ch> the pointed list isn't useful in that case :\
12:13:10 <roconnor> @hackage pointedlist
12:13:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointedlist
12:13:17 <rwbarton> roconnor: right but what structure exactly do you want to give the orientation
12:13:55 <roconnor> rwbarton: that is typically done by selecting a paritcular unit pseduo-vector (an outer product).
12:13:55 <rwbarton> roconnor: the most practical thing to do is probably to specify a homomorphism R -> SO(V) for counterclockwise rotations, when V is two-dimensional
12:14:41 <dcoutts_> @seen SamB
12:14:41 <lambdabot> SamB is in #perl6, #darcs, #ghc and #haskell. I don't know when SamB last spoke.
12:14:45 <dcoutts_> @seen SamB_irssi
12:14:45 <lambdabot> SamB_irssi is in #ghc and #haskell. I don't know when SamB_irssi last spoke.
12:14:50 <dcoutts_> @seen SamB_XP
12:14:50 <lambdabot> SamB_XP is in #haskell-blah and #haskell. I don't know when SamB_XP last spoke.
12:16:28 <Toxaris> roconnor: and the Haskell wikibook presents "type Zipper a = (Thread a, Node a)
12:16:28 <Toxaris> "
12:16:41 <mmorrow> > (uncurry zip) . (inits&&&tails) $ [0..4]
12:16:43 <lambdabot>   [([],[0,1,2,3,4]),([0],[1,2,3,4]),([0,1],[2,3,4]),([0,1,2],[3,4]),([0,1,2,3...
12:16:44 <zloog> Anyone know where I can find the Char8 data type? I have Data.ByteString.Char8 imported qualified as B but when trying to use B.Char8 in a parsec type the ghc says it cant find Char8
12:16:48 <mmorrow> > (uncurry zip) . (inits&&&tails) $ [0..3]
12:16:50 <lambdabot>   [([],[0,1,2,3]),([0],[1,2,3]),([0,1],[2,3]),([0,1,2],[3]),([0,1,2,3],[])]
12:17:06 <roconnor> rwbarton: that homomorphism is either the exp from the lie algebra to the lie group, or the covering space to the lie group.
12:17:12 <mauke> zloog: why do you think there is a type called Char8?
12:17:20 <rwbarton> Toxaris: regardless of what a zipper is (which seems to be disputed), ([a], [a]) is the derivative of [] at a
12:17:45 <roconnor> rwbarton: probably from the lie algebra
12:18:20 <roconnor> rwbarton: in that case I can provide CCW and CW as unit vectors in the lie algebra.
12:18:28 <zloog> mauke: Hrm i see your point. Everything seems to be using a regular Char type...
12:18:31 <rwbarton> roconnor: Yeah
12:18:33 <roconnor> ... do lie algebras have norms?
12:18:45 <zloog> mauke: Then im not sure whats wrong with the parser type decl
12:18:55 <roconnor> or I can use outer products.  That might be easier
12:18:57 <rwbarton> No, but you should probably measure in radians :)
12:19:25 <zloog> test...
12:19:37 <Toxaris> I will just call ([a], [a]) a zipper for now (it's just for an assignment). my understanding was that the derivative describes the context, and   zipper = focus * context
12:19:47 <drhodes> @where (&&&)
12:19:47 <lambdabot> I know nothing about (&&&).
12:19:57 <mauke> @index (&&&)
12:19:57 <lambdabot> Control.Arrow
12:20:00 <drhodes> thanks
12:20:57 <Toxaris> thanks rwbarton, roconnor
12:21:04 <sm> http://www.reddit.com/r/haskell/comments/7w0px/the_syntactic_century_formal_semantics_for_side/ is great
12:21:49 <rwbarton> roconnor: I must be being dense... given a unit vector in /\^2 V and an angle in R is there a good way to get a rotation in SO(V)?
12:22:26 <mmorrow> @type (\((a,(b,c)),d) -> (b, \b -> ((a,(b,c)),d)))
12:22:27 <lambdabot> forall t t1 t2 t3 t4. ((t, (t1, t2)), t3) -> (t1, t4 -> ((t, (t4, t2)), t3))
12:22:38 <rwbarton> I guess I can just pick one of the isomorphisms R^2 -> V that preserves the norm and the bivector and rotate there, but it seems somehow unsatisfactory
12:22:46 <mauke> what's a good name for a parser library?
12:22:52 <lament> Parsec
12:22:57 <mauke> taken
12:23:04 <lament> Token
12:23:06 <mmorrow> \(.... a ....) -> (a, \a -> (.... a ....))
12:23:21 <mauke> that's not a good name
12:23:23 <sbahra> Broken.
12:23:33 <lament> ParseT
12:23:37 <sbahra> mauke, call it "sbahra"
12:23:47 <mauke> my name generator is suggesting "homoid"
12:23:57 <lament> excellent.
12:24:11 <roconnor> rwbarton: lemme think
12:24:19 <mauke> other candidates: gradef, halitosis
12:24:30 <lament> halitosis is a wonderful name for a parser
12:24:31 <rwbarton> roconnor: I don't see how the covering space of the rotation group can be useful, unless you need to keep track of how many times an object has rotated for some reason
12:24:42 <lament> maybe you should get a better name generator :P
12:24:57 <sbahra> mauke, name generators? How does it work?
12:24:59 <roconnor> rwbarton: unless you need to keep track of how many times an object has rotated for some reason
12:25:04 <roconnor> that's what I'm thinking
12:25:06 <mauke> markov chains: silianetje inate aborshly agraphylocate reforjack
12:25:15 <rwbarton> or you are doing quantum mechanis with spin 1/2 particles or something :)
12:26:02 <Toxaris> parsec is a bad name, you cannot google it
12:26:21 <rwbarton> roconnor: I guess it could be useful if you wanted to specify an animation by initial and final state and wanted to have it interpolated somehow
12:26:21 <mauke> I think that rules out halitosis
12:26:26 <zloog> call it kessel run then
12:26:40 <mauke> haha
12:26:43 <lament> Parsec'
12:26:55 <mauke> sunhammer
12:26:59 <roconnor> rwbarton: a 2-D pseudo-vector is just a bi-vector, so don't we use the normal rotor formula
12:27:04 <roconnor> rwbarton: whatever that is
12:27:30 <rwbarton> I don't know what that is
12:27:32 <sm> oh shoot, I mislinked. I meant http://www.reddit.com/r/haskell/comments/7vmww/moggi_monads_category_theory_and_haskell/ is great!
12:27:55 <dolio> Pharce
12:28:09 <mauke> halate
12:28:26 <roconnor> rwbarton: I~ * v * I
12:28:32 <roconnor> where * is the geometric product
12:28:42 <lament> Parasitic
12:28:59 <roconnor> rwbarton: or rather,  I * v * I~
12:29:03 <Toxaris> anyone know how to get a random number in sml/nj ?
12:29:22 <rwbarton> roconnor: I'm confused.  shouldn't there be an angle that gets exponentiated somewhere?
12:29:36 <roconnor> oh
12:29:51 <mauke> appiness
12:29:53 <roconnor> rwbarton: scale I by the angle you want to rotate by
12:30:09 <roconnor> rwbarton: er rather scale by (theta/2)
12:30:46 <ziman> syntacks http://tbn1.google.com/images?q=tbn:5dvJ4TL7s3msuM:http://www.pensionriskmatters.com/RedTack.JPG
12:30:49 <ski_> Toxaris : possibly one of the operations in the structure `Random' ?
12:31:12 <ski_> (try `open Random;' in the interactor)
12:33:55 <Toxaris> ski_: cool thanks. how to find such things? I am missing hoogle :(
12:34:14 * ski_ just guessed in this case
12:34:47 <ski_> <http://www.standardml.org/Basis/> can be useful for general SML things
12:35:14 <ski_> and <http://www.smlnj.org/doc/> for SML/NJ specific things
12:35:43 * ski_ is not away of anything hoogle-like, though ..
12:36:18 <flipflap> How can I get a triple root using Haskell?`Like a square root.. just.. triple...
12:36:22 <flipflap> something^3
12:36:55 <mauke> > 2 ** (1/3)
12:36:57 <ski_> > 27 ** (1/3)
12:36:57 <lambdabot>   1.2599210498948732
12:36:59 <lambdabot>   3.0
12:37:19 <flipflap> > 25 ** (1/2)
12:37:21 <lambdabot>   5.0
12:37:24 <flipflap> Yuck.
12:37:44 <flipflap> > 600 ** (1/3)
12:37:46 <lambdabot>   8.434326653017491
12:38:19 <ski_> @let root n x = x ** recip n
12:38:22 <lambdabot>  Defined.
12:38:27 <ski_> > root 3 600
12:38:29 <lambdabot>   8.434326653017491
12:38:30 <lament> hm, this utrecht summer school thing is expensive for being only 11 days!
12:38:56 <zloog> Does anyone know whats wrong with this parser type "parseNextResp :: GenParser Char st B.ByteString" when I try to feed it a ByteString (imported from the Char8 ByteString lib) ghc says that the parser should accept [Char] not a ByteString...
12:39:48 <ski_> `GenParser Char st B.ByteString' says that the parser consumes `Char' tokens, and constructs a `B.ByteString' result
12:40:32 <zloog> ski_ But are ByteStrings from theChar8 lib constructed from Chars?
12:40:41 * ski_ doesn't know though about parsing from bytestrings ..
12:40:54 <zloog> ski_ coal, back to google then
12:40:58 <zloog> ski_ thanks
12:41:21 <ski_> yes, that type says that a bytestring is constructed, and characters are consumed
12:41:37 <swiert> lament: there are scholarships available + it does include housing,course material, and a social program.
12:41:59 <swiert> compared to AFP last year, it's pretty cheap!
12:43:33 <zloog> ski_ Figured it out, needed to import the Text.Parsec.ByteString
12:43:38 <zloog> ski_: thanks again
12:43:42 <ski_> np
12:45:01 <zloog> ski_ Figured it out, needed to import the Text.Parsec.ByteString
12:45:02 <zloog> ski_: thanks again
12:45:12 <roconnor> rwbarton: http://www.mrao.cam.ac.uk/~clifford/introduction/intro/node6.html
12:45:43 <roconnor> rwbarton: The bivector (sigma_1 /\ sigma_2) has the geometric effect of rotating the vectors  in its own plane by  clockwise when multiplying them on their left.
12:46:16 <roconnor> rwbarton: so my formula wasn't quite right
12:46:50 <roconnor> I is more like exp(pi/4).
12:50:17 * roconnor finally puts hackage on his bookmark toolbar
12:50:22 <chrisdone> roconnor: winrar
12:50:37 <chrisdone> it's also on mine v_v
12:50:51 <flipflap> What.
12:50:52 <roconnor> why didn't I do this sooner?
12:51:16 <chrisdone> I made a post http://chrisdone.com/blog/html/09-02-09-blogination.html and now I go to bed and be are dead
12:53:12 * roconnor prepares a new little hackage package to link data-accessor with monadLib.
12:56:21 <Cale> I've been thinking of doing a library of standard monads in terms of MonadPrompt
12:57:30 <roconnor> Why?
12:57:37 <idnar> what is MonadPrompt?
12:57:39 <roconnor> I never understood the point of MonadPrompt
12:58:06 <sjanssen> @users
12:58:06 <lambdabot> Maximum users seen in #haskell: 697, currently: 693 (99.4%), active: 24 (3.5%)
12:58:23 <roconnor> it almost seems actively a bad thing, given how much people are prone to using it when describing monad semantics.
12:59:07 <flipflap> > 6000*0.91
12:59:08 <lambdabot>   5460.0
12:59:14 <flipflap> Doing my homework on lambdabot is fun
12:59:56 <flipflap> Too lazy to get my calculator out of my bag :K
13:03:08 <Fredrik> > [0,0.1..2.0]
13:03:09 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
13:03:20 <chrisdone> what is that syntax called?
13:03:26 <chrisdone> it's an extension right?
13:03:44 <chrisdone> I wanted it the other day but found it was nonstandard
13:03:52 <Fredrik> what syntax?
13:04:01 <chrisdone> [a,b..c]
13:04:13 <chrisdone> oh
13:04:14 <Fredrik> hm, ghc supports it, i dont know :)
13:04:17 <chrisdone> it was [a..b,c]
13:04:18 <rwbarton> it's Haskell 98
13:04:27 <chrisdone> > [1..10,15]
13:04:27 <rwbarton> that doesn't exist as far as I know :)
13:04:29 <lambdabot>   <no location info>: parse error on input `,'
13:04:30 <chrisdone> :(
13:04:32 <Olathe> It's sugar for enumFromThenTo
13:04:42 <Fredrik> > [1..10] ++ [15]
13:04:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,15]
13:04:47 <Fredrik> is that what you want?
13:04:51 <Olathe> > enumFromThenTo 1 3 10
13:04:53 <lambdabot>   [1,3,5,7,9]
13:04:59 <Olathe> > [1, 3..10]
13:04:59 <chrisdone> only an extra
13:05:00 <lambdabot>   [1,3,5,7,9]
13:05:03 <chrisdone> > length "] ++ [15]"
13:05:05 <lambdabot>   9
13:05:06 <chrisdone> characters
13:05:34 <Fredrik> what exactly do you want [1..10,15] to produce?
13:05:52 <chrisdone> [1..10] ++ [15]
13:06:02 <Fredrik> well alright, there you go then :)
13:06:11 <chrisdone> not really
13:06:26 <chrisdone> the point is I'd rather write [1..10,15] and not write convoluted appends
13:06:31 <Olathe> Hmm...
13:06:33 <chrisdone> but oh well my question was answered minutes gao
13:07:38 <Fredrik> let chrisdone a b c = [a..b] ++ [c]
13:07:41 <Fredrik> there you go :)
13:20:15 <Lemmih> Heffalump: There's isn't a London HUG channel, is there?
13:20:57 <Heffalump> Lemmih: nope. I don't think it's really big enough or organised enough to support that :-)
13:21:44 <dcoutts_> Heffalump: oh, about cabal-install and http proxies on windows, did you have a patch or did you say you might make one?
13:22:02 <Heffalump> I said I might make one.
13:22:09 <erikc> has there been any research / work into modules taking type parameters (like a template would in c++, but at the module level)
13:22:22 <Heffalump> erikc: ML functors do that
13:22:38 <erikc> ah
13:23:14 <dcoutts_> Heffalump: ok great. We've got a release coming up very soon and another a week or two after that.
13:23:35 <Heffalump> so you'd accept a patch that respected http_proxy?
13:23:50 <Heffalump> as opposed to doing the right thing with .pac files etc, which I'm certainly not willing to write :-)
13:24:48 <dcoutts_> Heffalump: yes, reading the env var before looking in the registry
13:25:00 <Heffalump> ok
13:25:16 <dcoutts_> Heffalump: and if we can check if it's the same thing darcs does that'd be nice
13:25:44 <Heffalump> I'll try to check
13:25:46 <dcoutts_> Heffalump: eg I dunno if it should be HTTP_PROXY or http_proxy, I think on unix we check both
13:25:59 <Heffalump> I intend to just keep the UNIX code and fall through from that
13:26:03 <Heffalump> s/keep/enable/
13:26:11 <dcoutts_> Heffalump: that's pretty reasonable
13:40:26 <rwbarton> @users
13:40:26 <lambdabot> Maximum users seen in #haskell: 697, currently: 687 (98.6%), active: 17 (2.5%)
13:42:06 <hackage> Uploaded to hackage: terrahs 0.5
13:42:55 <dons> mmm... http://www.reddit.com/r/programming/comments/7w3o9/an_executable_operational_semantics_for_python/
13:42:58 <dons> in haskell..
13:43:34 <dons> kosmikus: !
13:43:46 <dons> are we going to see this on hackage?
13:43:48 <mreh> @ type zip
13:43:54 <mreh> @type zip
13:43:55 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
13:44:07 <mreh> @type zipWith
13:44:08 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:44:21 <kerlo> @type ap zip uncurry
13:44:22 <lambdabot>     Couldn't match expected type `[a]'
13:44:22 <lambdabot>            against inferred type `a1 -> b -> c'
13:44:22 <lambdabot>     Probable cause: `uncurry' is applied to too few arguments
13:44:52 <kerlo> O great @pl, tell me the magic word...
13:45:23 <mreh> how do you perform operations on adjacent members of a list?
13:45:35 <kerlo> mreh: try foldr or foldl, perhaps.
13:45:43 <kerlo> @pl \x y -> map (uncurry x) (zip y)
13:45:43 <lambdabot> (. zip) . map . uncurry
13:45:48 <kerlo> @pl \y x -> map (uncurry x) (zip y)
13:45:48 <lambdabot> flip (map . uncurry) . zip
13:45:50 <rwbarton> :t zipWith ?f `ap` tail
13:45:52 <lambdabot> forall b c. (?f::b -> b -> c) => [b] -> [c]
13:45:58 <mreh> kerlo: it's a bit trickier than that
13:46:06 <ski_> @type \x y -> map (uncurry x) (zip y)
13:46:07 <lambdabot>     Couldn't match expected type `[(a, b)]'
13:46:08 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
13:46:08 <lambdabot>     In the second argument of `map', namely `(zip y)'
13:46:21 <rwbarton> or more readably   zipWith f xs (tail xs)
13:46:24 <mreh> say i want to compute a list of vectors from a list of points
13:46:40 <redditbot> An executable operational semantics for Python ... in Haskell
13:46:43 <ski_> kerlo : what're yer for ?
13:47:00 <Heffalump> redditbot: dons beat you to it
13:47:31 <kerlo> two f (x1:x2:xs) = f x1 x2 : two f (x2:xs); two _ _ = []
13:47:34 <kerlo> mreh: like that?
13:47:48 <lament> it's funny how the photographs on the utrech CS summer program site show girls exclusively
13:48:04 <kerlo> @pl \x y z -> map (uncurry x) (zip y z)
13:48:05 <lambdabot> (. zip) . (.) . map . uncurry
13:48:06 <lament> oh, no, there's one guy
13:48:14 <mreh> i saw the hottest girl in computer science today, i almost had to excuse myself
13:48:16 <kerlo> @pl \x y z -> map (uncurry z) (zip x y)
13:48:16 <lambdabot> (flip (map . uncurry) .) . zip
13:48:46 <beelsebob> zipWith, with a few flips?
13:49:06 <kerlo> Something like that.
13:49:10 <kerlo> @type zipWith
13:49:11 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:49:16 <ziman> > ap (zipWith (-)) tail [1..5]
13:49:18 <lambdabot>   [-1,-1,-1,-1]
13:49:26 <kerlo> @type (. zip) . (.) . map . uncurry
13:49:27 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:49:31 <lament> mreh: ...that's pretty hot.
13:49:44 <kerlo> ¡Aplauso aplauso!
13:50:09 <mreh> in a computer science department, i was caught of guard
13:50:27 <ski_> @ghc
13:50:28 <lambdabot> ghc says: Splices are not allowed in hs-boot files
13:50:53 <mreh> she was intelligent, totty, that's what i call that
13:54:29 <Heffalump> mreh/lament: I don't think sexist language is appropriate for #haskell
13:54:51 <lament> i said nothing sexist.
13:55:22 <Heffalump> well, that's debatable, but mreh's certainly isn't debatable :-)
13:55:58 <pumpkin_> ugh
13:56:37 <monochrom> functional programmers are hot!
13:56:43 <lament> @quote hot
13:56:43 <lambdabot> dons says: Ooh, functional programmers are so hot!
13:56:52 <Heffalump> :-)
13:57:20 <ski_> `hot' referring to `higher-order and typed', yes ?
13:58:09 <monochrom> programmers are not typed.
13:58:30 <dolio> Speak for yourself.
13:58:35 <glguy> typecast?
13:58:42 <Peaker> We need a type system for discussions
13:58:44 <glguy> stero...typed?
13:58:44 <lament> dictated but not read.
13:58:55 <glguy> stereo*
13:59:02 <kerlo> My type is brivla.
13:59:19 <lament> ohhh THAT'S what 'kerlo' is about.
13:59:25 <lament> you suck. :)
13:59:28 <kerlo> Assuming that I and my name are the same thing, which is actually kind of doubtful.
13:59:47 <kerlo> I suck because my name means "ear"?
14:01:28 <lunabot>  luna: lexical error in string/character literal at end of input
14:02:04 <rwbarton> @msg mmorrow trofi's quit message "byebye :]" causes lunabot to respond for some reason (probably has to do with the ])
14:02:05 <lambdabot> Not enough privileges
14:02:07 <rwbarton> @tell mmorrow trofi's quit message "byebye :]" causes lunabot to respond for some reason (probably has to do with the ])
14:02:08 <lambdabot> Consider it noted.
14:02:11 * glguy wonders if someone's quit message just triggered lunabot 
14:02:28 <dolio> Yes, it does.
14:02:29 <glguy> it probably saw :
14:02:36 <Elly> O_o
14:02:39 <kerlo> So...
14:02:40 <dolio> ] 5 * 5
14:02:41 <lunabot>  25
14:02:42 <kerlo> :]
14:02:46 <glguy> and it knows that IRC messages bodies end in :
14:02:55 <glguy> err
14:02:56 <glguy> start with
14:03:01 <sw17ch> > let a = 3 : 0 : 2 : zipWith (+) a (tail a)
14:03:02 <lambdabot>   <no location info>: parse error on input `;'
14:03:05 <roconnor> how conservative should I be when writing Cabal package version dependencies?
14:03:06 <kerlo> Let's try this: :] 5 * 5
14:03:13 <kerlo> Hmm.
14:03:14 <sw17ch> @let a = 3 : 0 : 2 : zipWith (+) a (tail a)
14:03:15 <lambdabot>  <local>:47:28:
14:03:15 <lambdabot>      Ambiguous occurrence `a'
14:03:15 <lambdabot>      It could refer to either `...
14:03:23 <dcoutts_> roconnor: put an upper bound on base at least
14:03:30 <kerlo> una vez mas :] 5 * 5
14:03:31 <rwbarton> kerlo: I haven't seen anyone reproduce it yet except through a quit/leaving message
14:03:32 <sw17ch> > let a = 3 : 0 : 2 : zipWith (+) a (tail a) in take 10 a
14:03:33 <lambdabot>   [3,0,2,3,2,5,5,7,10,12]
14:03:35 <kerlo> Mm.
14:03:35 <glguy> :t a
14:03:37 <lambdabot> Expr
14:03:46 <rwbarton> kerlo: I don't know enough about IRC to speculate why that would be
14:03:47 <glguy> that's for:
14:03:49 <glguy> > a + b
14:03:50 <sw17ch> i love haskell...
14:03:50 <lambdabot>   a + b
14:04:39 <roconnor> dcoutts_: oh god.  I hadn't even considered that.
14:04:40 <olsner> > take 10 $ fix ( ([3,0,2]++) . ap (zipWith (+)) tail)
14:04:42 <lambdabot>   [3,0,2,3,2,5,5,7,10,12]
14:05:06 <roconnor> dcoutts_: how would I chose such an upper bound?
14:05:07 <dcoutts_> roconnor: nor does anyone else. I'm going to enforce it via hackage soon.
14:05:26 <dcoutts_> roconnor: if it works with base 4 then use build-depends: base < 5
14:05:45 <roconnor> dcoutts_: I  presume it work with base-4.  I'm only importing Control.Monad
14:10:35 <Fredrik> > Control.Monad.Fix.fix (2+)
14:10:37 <lambdabot>   * Exception: stack overflow
14:10:54 <Fredrik> Why doesn't this work in GHCi? It just terminates immediately :(
14:11:28 <mauke> what?
14:11:48 <lament> Fredrik: how do you expect it to work?
14:11:49 <Fredrik> The GHCi window closes immediately
14:11:55 <Fredrik> I expect a stack overflow
14:11:57 <pumpkin_> for me it hangs
14:12:03 <pumpkin_> in a non-ctrl+c-able way
14:12:11 <mauke> but still ctrl-z-able
14:12:11 <pumpkin_> I have to ctrl+z it and kill it
14:12:48 <dcoutts_> in ghci-6.6.1 it gives a stack overflow exception
14:12:50 <paper_cc> [just being curious] ctrl+\-able?
14:13:04 <mauke> nope
14:13:04 * sw17ch goes home
14:13:10 <Fredrik> I use GHCi 6.10.1
14:13:25 <rwbarton> for me it runs forever in constant memory (^C-able) in ghc-6.8.2 and ghc-HEAD but eats all my memory in ghc-6.10.1 and I need ^Z there
14:13:33 <roconnor> dcoutts_: should I put upper bounds on all my packages?  Best guess?
14:14:04 <dcoutts_> roconnor: I do if I know the versioning policy.
14:14:23 <dcoutts_> roconnor: eg if the package follows the standard package versioning policy
14:14:27 <arjanb> Fredrik: ghci 6.10.1 on windows has some problem with catching certain exceptions
14:14:28 <roconnor> and if you don't know the policy?
14:14:37 <dcoutts_> roconnor: I grumble :-)
14:14:46 <roconnor> dcoutts_: what's the standard versioning policy?
14:14:50 <pumpkin_> everyone adopt the TeX versioning policy :P
14:15:11 <dcoutts_> pumpkin_: is that convergence towards pi ?
14:15:15 <pumpkin_> pick a number that isn't finitely representable in decimal and keep adding digits
14:15:27 <pumpkin_> pi is taken, every program should pick a different irrational
14:15:29 <pumpkin_> rationals are no fun
14:15:34 <dcoutts_> roconnor: http://haskell.org/haskellwiki/Package_versioning_policy
14:16:11 <yitz> pumpkin_: and it will take a lot longer to run out of irrationals than rationals
14:16:19 <pumpkin_> I bet :)
14:16:33 <pumpkin_> but you want one that's easy to describe too
14:16:51 <pumpkin_> one with a kolmogorov complexity of at most 1000 bits ;)
14:16:53 <roconnor> dcoutts_: oh. I need to adjust my version numbering scheme
14:16:56 <yitz> pumpkin_: \hmph, then it's no better than rationals :(
14:17:18 <dolio> You won't run out of rationals any faster than computable irrationals.
14:17:20 <pumpkin_> I guess I should specify a machine too
14:17:31 <roconnor> dcoutts_: base doesn't follow this policy?
14:17:39 <rwbarton> pumpkin_: why do you have to describe it?  Only the package maintainer has to know the number
14:17:43 <dcoutts_> roconnor: it does follow it, mostly
14:17:51 <dcoutts_> roconnor: as do the other core packages
14:17:53 <pumpkin_> rwbarton: true
14:18:27 <dcoutts_> roconnor: in what way does it not?
14:18:41 <roconnor> dcoutts_:  but base < 5 isn't correct.  All dependencies need to be of the form  base < A.B according to the standard versioning policy
14:18:55 <roconnor> dcoutts_: because the A is meaningless
14:19:03 <dcoutts_> roconnor: ok, use < 4.1 then
14:21:11 <roconnor> dcoutts: thanks
14:21:36 * roconnor wonders if my code works for base 2.0
14:22:58 <bvck> Is this the right venue for simple CT questions?
14:23:29 <Heffalump> bvck: if CT = Category Theory, #haskell-in-depth might be more appropriate
14:23:43 <bvck> Even simple ones...? ...:)
14:23:50 <Heffalump> I dunno :-)
14:24:04 <dolio> haskell-in-depth?
14:24:09 <Heffalump> #h-i-d is still a work in progress and the boundary will never be defined in black and white terms anyway
14:24:10 <jeffwheeler> > deriv (\x -> x*x)
14:24:11 <lambdabot>       Overlapping instances for Show (a -> a)
14:24:11 <lambdabot>        arising from a use of `s...
14:24:18 <jeffwheeler> > deriv (\x -> x*x) x
14:24:19 <roconnor> > deriv (\x -> x*x) x
14:24:20 <lambdabot>   1 * x + x * 1
14:24:21 <lambdabot>   1 * x + x * 1
14:24:25 <dolio> I'd just ask here.
14:24:35 <Heffalump> its intention is to remove some of the volume of conversation in here so as to not drown out beginner/basic questions
14:24:36 <bvck> Okay. I will give it a go.
14:24:56 <bvck> What would an id morphism exactly return on a Category of Set?
14:25:06 <Deewiant> Notably, its intention is /not/ to add metadiscussion about where to ask questions ;-)
14:25:14 <bvck> Would it return the underlying set itself?
14:25:16 <Heffalump> Deewiant: :-)
14:25:21 <Heffalump> bvck: what else could it be?
14:25:23 <dolio> In Set, morphisms are functions.
14:25:34 <dolio> So identity morphisms are identity functions.
14:25:37 <pumpkin_> Deewiant: I think we should take the Windows approach and segment it into six or seven tiers
14:25:53 <Deewiant> pumpkin_: :-P
14:26:18 <pumpkin_> you can only set -N2 if you get the lowest tier
14:26:19 <bvck> So essentially the Set returned by the id morphism is 'equal' to the Set passed in?
14:26:22 <pumpkin_> +RTS -N2 that is
14:26:59 <dolio> Well, you don't pass sets to functions, really. You pass elements of sets.
14:27:09 <jeffwheeler> > show $ deriv (\x →  x x x) (var "x") -- evaluates to "x+x" on my machine
14:27:10 <lambdabot>       Ambiguous occurrence `var'
14:27:10 <lambdabot>      It could refer to either `Data.Number.S...
14:27:13 <jeffwheeler> err
14:27:23 <jeffwheeler> > show $ deriv (\x →  x * x) (var "x") -- evaluates to "x+x" on my machine
14:27:24 <lambdabot>       Ambiguous occurrence `var'
14:27:25 <lambdabot>      It could refer to either `Data.Number.S...
14:27:32 <jeffwheeler> > show $ deriv (\x →  x * x) x -- evaluates to "x+x" on my machine
14:27:34 <lambdabot>   "1 * x + x * 1"
14:27:46 <rwbarton> bvck: You have the category of sets and you want to know what the identity morphisms are?
14:28:01 <Fredrik> Is there a function like this in the haskell libraries? let ignore1st f x y = f y
14:28:08 <roconnor> jeffwheeler: lambdabot is using SimpleReflect, not Numeric.WhateverTheReflectionModuleIs.
14:28:11 <bvck> rwbarton -> yes
14:28:19 <pumpkin_> if you have a function from the integers to the integers, and the function is defined as f(x) = 2x, should you say that the codomain is the integers, or more specifically the even integers?
14:28:29 <dolio> @type \f -> const f
14:28:30 <lambdabot> forall a b. a -> b -> a
14:28:38 <rwbarton> bvck: Ok, there's an identity morphism for every object A: id : A -> A.  Here A is a set, and id is a function from A to A.
14:28:46 <dolio> @type \f x y -> const f x y
14:28:47 <lambdabot> forall t b t1. (t -> t1) -> b -> t -> t1
14:28:52 <rwbarton> bvck: That function is just the function id(x) = x for all x in A
14:29:27 <lament> pumpkin_: if it's a function from the integers to the integers, integers are the codomain. It doesn't matter what the function is.
14:29:36 <bvck> rwbarton -> Thaks. What is its equivalent for Hask?
14:29:37 <lament> pumpkin_: Even integers are the image.
14:29:45 <bvck> when the underlying object is a 'type'?
14:29:49 <dolio> const f x y = (\a b -> a) f x y = (\b -> f) x y = f y
14:29:57 <rwbarton> bvck: right, a is now a type, and we write id :: A -> A; id x = x
14:29:59 <pumpkin_> lament: so the codomain is pretty much what you say it is (as long as really is a superset of the image)?
14:30:07 <rwbarton> bvck: oops, id :: a -> a; id x = x
14:30:07 <lament> pumpkin_: apparently
14:30:24 <mauke> what operations does a CoList have?
14:30:40 <Heffalump> isn't a CoList a Stream?
14:30:44 <Olathe> Are streams colists ?
14:30:55 <bvck> rwbarton -> So for example  id 2 =2, right?
14:30:59 <pumpkin_> does x is y mean that y is x?
14:31:11 <Olathe> pumpkin_: Not in English.
14:31:13 <dolio> Colists are finite and infinite lists.
14:31:22 <mreh> ((drop 1) . cycle $ vectors) does anyone know a more elegant way doing this?
14:31:35 <rwbarton> bvck: right
14:31:36 <pumpkin_> Olathe: I was just referring to your and Heffalump's inverted question
14:31:45 <Olathe> mreh: drop 1 . cycle $ vectors
14:31:46 <rwbarton> mreh: yes, get rid of all the parentheses :)
14:31:52 <bvck> rwbarton -> But the identity morphism is going to return the same 'type' only. So what about id 2 = 3?
14:31:53 <Deewiant> > cycle []
14:31:53 <Olathe> pumpkin_: Oh :)
14:31:54 <lambdabot>   * Exception: Prelude.cycle: empty list
14:32:00 <dolio> Anyway, what does "operation" mean?
14:32:10 <bvck> rwbarton -> Both are say of 'type' Int
14:32:11 <Deewiant> mreh: tail . cycle $ vectors
14:32:16 <Olathe> tail can fail.
14:32:23 <Deewiant> Olathe: cycle fails too, as shown above.
14:32:28 <mauke> e.g. cons :: a -> List a -> List a
14:32:30 <Olathe> Hmm, yes, you're right.
14:32:34 <Olathe> Yes, tail is better :)
14:32:37 <Deewiant> And since cycle gives an infinite list, tail can't fail.
14:32:45 <pumpkin_> someone should write a rhyming haskell poem
14:32:48 <pumpkin_> involving "tail can fail"
14:32:49 <mreh> >cycle []
14:32:50 <Olathe> Why doesn't cycle [] give [] ?
14:32:58 <mreh> fail
14:32:59 <Deewiant> I don't know.
14:33:07 <pumpkin_> @src cycle
14:33:07 <lambdabot> cycle [] = undefined
14:33:07 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:33:08 <mreh> it's meaningless
14:33:23 <pumpkin_> > let cycle xs = xs' where xs' = xs ++ xs' in cycle []
14:33:39 <lambdabot>   thread killed
14:33:44 <Deewiant> [] ++ _|_
14:33:44 * beelsebob wonders why cycle [] is undefined
14:33:47 <rwbarton> bvck: Well, one of the axioms of a category is that f . id = f for all f :: A -> B
14:33:49 <Olathe> > let cycle [] = []; cycle xs = xs' where xs' = xs ++ xs' in cycle []
14:33:51 <lambdabot>   []
14:33:53 <dolio> Well, then, I guess colists have uncons :: Colist a -> Maybe (a, Colist a)
14:34:16 <pumpkin_> :t uncons
14:34:17 <lambdabot> Not in scope: `uncons'
14:34:20 <dolio> And unfold :: (s -> Maybe (a, s)) -> Colist a.
14:34:23 <pumpkin_> why don't lists have uncons?
14:34:25 <bvck> rwbarton -> duh! Thanks forgot about that one.
14:34:38 <Olathe> uncons [] = Nothing; uncons (x:xs) = Just (x, xs)
14:34:44 <mreh> how can i check all elements in a list are equal?
14:34:51 <mreh> without using fold
14:34:51 <Toxaris> @type head &&& tail
14:34:52 <Fredrik> > Control.Monad.Fix.fix id
14:34:53 <lambdabot> forall a. [a] -> (a, [a])
14:34:54 <lambdabot>   * Exception: stack overflow
14:35:02 <pumpkin_> mreh: check that group on that list has length = 1 ?
14:35:05 <mauke> so does 'class Colist a s | s -> a where uncons :: b -> (a -> s -> b) -> s -> b' look sensible?
14:35:06 <Raevel> mreh: what's wrong with foldl?
14:35:10 <Deewiant> > and . (zipWith (==) `ap` tail) $ [1,1,1]
14:35:11 <lambdabot>   True
14:35:19 <Deewiant> > and . (zipWith (==) `ap` tail) $ [1,1,2]
14:35:20 <lambdabot>   False
14:35:27 <mreh> genius
14:35:36 <Deewiant> ?quote aztec
14:35:36 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
14:35:42 <mreh> with fold i'll have to define an anonymous function
14:35:42 <Toxaris> pumpkin_: uncons for lists is (head &&& tail), but it is partial, while for co-lists, it is total. if i understand things correctly.
14:35:44 <pumpkin_> > length (group [1,1,1]) == 1
14:35:45 <lambdabot>   True
14:35:48 <pumpkin_> > length (group [1,1,2]) == 1
14:35:50 <lambdabot>   False
14:35:59 <monochrom> strange reason
14:36:02 <Deewiant> > length (group [1..]) == 1
14:36:05 <Olathe> > let allTheSame = null . tail . nub in allTheSame [1, 1, 1]
14:36:08 <lambdabot>   True
14:36:10 <Peaker> > length $ group []
14:36:11 <Olathe> > let allTheSame = null . tail . nub in allTheSame [1, 2, 1]
14:36:14 <lambdabot>   0
14:36:14 <lambdabot>   False
14:36:17 <lambdabot>   thread killed
14:36:25 <Deewiant> > and . (zipWith (==) `ap` tail) $ [1,2..]
14:36:26 <lament> mreh: no you won't. It's already defined for you.
14:36:27 <lambdabot>   False
14:36:32 <Deewiant> > length (group [1,2..]) == 1
14:36:39 <Deewiant> pumpkin_: ^
14:36:41 <mofmog> I'm having trouble reasoning about a problem... i want to create a class called "Distribution" and under that I want to defined adding two distributions together
14:36:42 <pumpkin_> boo :)
14:36:47 <lambdabot>   thread killed
14:36:52 <Deewiant> pumpkin_: need to use genericLength and a lazy natural, which is a bit too much trouble :-P
14:36:54 <rwbarton> > length (group [1,2..]) == (1 :: Natural)
14:36:56 <mofmog> but i would like to be able to add two distributions of different types together
14:36:56 <dolio> mauke: Sure.
14:36:56 <lambdabot>   Couldn't match expected type `Int' against inferred type `Natural'
14:36:58 <pumpkin_> yeah
14:36:58 <rwbarton> > genericLength (group [1,2..]) == (1 :: Natural)
14:37:02 <lambdabot>   False
14:37:08 <Deewiant> rwbarton: requires non-base libraries :-)
14:37:11 <koeien2> mofmog: "distribution", probability distributions?
14:37:15 <mofmog> koeien: yeah
14:37:16 <pumpkin_> rwbarton: that's quite nice
14:37:20 <rwbarton> Deewiant: yeah
14:37:21 <mauke> cool
14:37:22 <pumpkin_> how slow are lazy naturals?
14:37:34 <mofmog> well actually a better name would probably be RandomVariable
14:37:52 <koeien2> mofmog: taking real values?
14:38:00 <mofmog> yes
14:38:04 <mofmog> discrete rvs for now
14:38:11 <rwbarton> > map (const ()) (group [1,2..]) == [()]
14:38:14 <lambdabot>   False
14:38:37 <monochrom> "x>0" is O(1) for lazy naturals even if x is 10^1000. That's how "slow" lazy naturals are.
14:38:49 <koeien2> mofmog: okay, so what is your type?
14:38:52 <pumpkin_> that makes sense :) if you want to do real computation on it, though?
14:38:54 <Deewiant> rwbarton: sneaky :-)
14:39:11 <mofmog> koeien: i want to have multiple types, one for each type of r.v.
14:39:14 <monochrom> "x>0" is the realest computation.
14:39:21 <mofmog> but ultimately most will be built off of the Bernoulli distribution
14:39:28 <mofmog> er rv
14:39:36 <koeien2> mofmog: so you want to reflect the distribution in the type?
14:39:40 <mofmog> yeah
14:39:53 <koeien2> mofmog: yeah you need type hackery (i.e. fundeps) for that
14:39:55 <mofmog> so i want to do something stupid like say, Bernoulli + Geometric
14:40:04 <mofmog> hmm
14:40:16 <mofmog> perhaps itd be easier to have multiple constructors and one type, RandomVariable
14:40:40 <koeien2> mofmog: that is a tradeoff. if you have one type + multiple constructor, your universe is closed
14:40:48 <mofmog> exactly
14:40:51 <mofmog> hrm
14:40:53 <koeien2> mofmog: if you have a type class, it's open :) anyone can create a new one
14:40:53 <roconnor> ``If any entity was removed, or the types of any entities or the definitions of datatypes or classes were changed, or instances were added or removed, then the new A.B must be greater than the previous A.B.
14:40:58 <roconnor> such a harsh policy
14:41:32 <roconnor> maybe I'll just document my own versioning policy and refer to it
14:42:11 <roconnor> I mean, simply losing the class constraints on an overly constrained function type will likely maintain compatability.
14:42:17 <koeien2> mofmog: you can probably accomplish it using type classes. however it's hard to distinguish, say, Ber(1/2) from Ber(1/4)
14:42:51 <koeien2> mofmog: where Ber(p) denotes bernoulli distribution with success probability p
14:43:41 <roconnor> dcoutts_: how about a version policy field in .cabal?  version-policy: filename
14:44:08 <pumpkin_> or express the version policy as a haskell Enum instance :P
14:44:09 <mofmog> hmm, this is kinda tough to reason about
14:44:11 <roconnor> dcoutts_: you can put the standard version policy into a file that people can copy.
14:45:32 <monochrom> You can apply "encapsulation by obscurity" by using weird names for your typeclass and methods. Then other people will not write new instances for it.
14:46:40 <redditbot> Snippet: Lazily sorting a map of lists
14:47:01 <pumpkin_> call your method byWritingThisMethodNameIHerebyGrantOwnershipOfMyFirstbornToTheFirstStrangerIMeetOnTheStreet
14:48:25 <monochrom> security by unenforcible shrink-wrap license
14:48:32 <dcoutts> roconnor: yep, see http://hackage.haskell.org/trac/hackage/ticket/434
14:49:06 <dcoutts> roconnor: what do you mean about the PVP in a file people can copy?
14:49:47 <mofmog> koeien: aha i got it
14:49:48 <mreh> is there a room where you can profess your love for haskell and not feel embarrased?
14:49:53 <mofmog> just keep the probability space
14:50:02 <mofmog> and constructors are just smart constructors that create probability spaces
14:50:19 <mofmog> eg, "bernoulli 0.4" will create a prob space etc
14:50:20 <lament> mreh: #java
14:50:24 <koeien> mofmog: yes
14:50:26 <Botje> mreh: ##php, definitely.
14:50:48 <koeien> mofmog: you have to think about the exact representation of a probability space
14:51:05 <koeien> mofmog: as a first guess, you could take an infinite list of probabilities on [0,1,2,...]
14:51:11 <mofmog> well since im only dealing with discrete variables
14:51:12 <mreh> is there a "haskell for dummies" book? I dont think so
14:51:23 <koeien> mofmog: i.e. bernoulli p = [1-p,p]
14:51:53 <koeien> mofmog: geometric p = iterate (*(1-p)) p
14:52:13 <Botje> mreh: not yet ;)
14:52:19 <Botje> there's some pretty kick-ass tutorials around
14:52:33 <mreh> my point is, it aint for dummies
14:52:41 <Botje> learn you a haskell is very good
14:52:52 <CalJohn> mreh: difficult to make a "for dummies" book, as programming is a fundamentally difficult activity
14:53:08 <koeien> CalJohn: "fundamentally". you could argue that programming is in fact very easy
14:53:18 <mreh> you'll be surprised who I've seen programming
14:53:20 <koeien> just that a regular human sucks at it
14:53:29 <mreh> they'll teach chimps to do it these days, no joke
14:53:34 <CalJohn> i would recomend richard birds 1998 book, just ignoring the number theory stuff
14:53:42 <lament> I would recommend RWH.
14:53:57 <lament> it has the advantage of not being 10 years out of date.
14:53:59 <beelsebob> I would recommmend Tony Davie's book
14:54:01 <beelsebob> but I'm biased
14:54:02 <mreh> I would recommed HSOE if you want to do something artistic
14:54:05 <beelsebob> >.>
14:54:18 <koeien> mofmog: do you see what i mean?
14:54:22 <CalJohn> koeien: i'm not sure how you would...programming is a young, poorly understood discipline based around mathematical logic.  i don't know how it's easy
14:54:28 <CalJohn> it's easy to do badly, i suppose
14:54:49 <mreh> it isnt based on logic if you programme in an imperative style
14:54:52 <monochrom> random programming is very easy.
14:54:54 <koeien> CalJohn: just use Hoare logic and you'll write perfect Pascal
14:55:00 <koeien> mreh: this is completely false
14:55:11 <CalJohn> mreh: no, it still is based on logic, it's just got state as well
14:55:23 <CalJohn> *"state everywhere" as well
14:55:31 <mreh> there isn't a system of logic with state in it
14:55:38 <monochrom> Since Newton we already knew how to do state logically.
14:55:41 <koeien> mreh: look up Hoare logic
14:55:48 <mreh> how dare you
14:55:52 <monochrom> Look up differential equations.
14:55:55 <CalJohn> mreh: imperative programming isn't close to _formal_ logic, but it's still a highly logical activity
14:56:07 <mreh> it's a waste of time
14:56:11 <koeien> mreh: you just keep passing around the state space
14:56:15 <monochrom> Everything can be formalized.
14:56:27 <koeien> mreh: like you do everything in a *huge* State monad
14:56:28 <CalJohn> agreed, but i don't see the relevance, monochrom
14:56:41 <koeien> CalJohn: you can formalize Pascal
14:56:54 <monochrom> The relevance is you have a very narrow definition of "formal logic".
14:56:56 <mreh> but what kind of poor sod would do that?!
14:56:56 <koeien> CalJohn: in fact i don't see why this is harder than formalizing, say, Haskell
14:57:29 <mreh> koeien: if you can't do it in your head, then it isn't worth doing
14:57:37 <koeien> mreh: ...
14:57:39 <koeien> mreh: really?
14:57:43 <monochrom> head is overrated.
14:58:01 <mreh> as a programmer, you have no other choice
14:58:21 <mreh> unless you want to use formal methods, which is another thing
14:58:26 <koeien> mreh: if you work in any kind of team, you have to
14:58:27 <pumpkin_> monochrom: I pity you
14:58:45 <koeien> i bet even SPJ can't remember all of GHC :)
14:59:18 <pumpkin_> monochrom: depending on what definition of head you used there :)
14:59:43 <Saizan> exists x. (P x -> forall y. P y) is true in intuitionistic logic too, right? since it's equivalent to (forall x. P x -> forall y. P y) ?
15:00:01 <Saizan> err.
15:00:28 <Saizan> (forall x. P x) -> forall y. P y
15:00:34 <mreh> that's the kind of thing I think about while programming my java classes
15:00:46 <monochrom> Ask Coq. Don't rely on head.
15:01:09 <pumpkin_> lol
15:01:13 <beelsebob> @quote+ monochrom Ask Coq. Don't rely on head.
15:01:14 <lambdabot> No quotes match. :(
15:01:25 <beelsebob> @remember monochrom Ask Coq. Don't rely on head.
15:01:25 <lambdabot> I will remember.
15:01:26 <monochrom> It's @remember
15:01:45 <pumpkin_> can you run coq with your head?
15:01:52 <pumpkin_> with telekinetic powers maybe
15:01:56 <monochrom> Very slowly and unreliably.
15:02:10 <Saizan> Coq has first class existential quantification?
15:03:03 <monochrom> You don't need everything first-class.
15:04:23 <Adamant> people didn't invent theorem proving IDE equivalents because using formal methods is easy and they wanted to make so easy you could do it while throughly drunk. They invented them so they could do formal methods on a decent-sized code base in a reasonable amount of time at all.
15:04:46 <Saizan> well, if i'm not sure how to encode it with the universal one in the first place i'm not sure how Coq helps :)
15:05:05 <ddarius> Saizan: Doesn't the original statement say there exists an x such that if P x is true then P holds for all y which doesn't sound very universally true to me.
15:05:08 <doserj> Saizan: I don't think it is true in intuitionistic logic
15:05:26 <rwbarton> Saizan: I think you have your adjunction backwards
15:06:11 <ddarius> Saizan: Indeed.  forall x. P x -> Y ~ (exists x. P x) -> Y
15:06:37 <ddarius> Or maybe that was meant for rwbarton (as well?)
15:06:49 <rwbarton> yeah, that's what I was in the middle of typing.
15:07:13 <Axman6> http://twitter.com/COURAGEWOLF <-- hardcore!
15:07:18 <monochrom> Both adjunctions hold in classical logic. Exactly one of them holds in intuitionistic logic. If you find out which one holds, you also know the other breaks.
15:07:30 <rwbarton> right
15:07:51 <rwbarton> exists x. P x is the colimit of the P's, so we should be mapping out of it into another statement Y
15:07:58 <Axman6> monochrom: sounds logical
15:11:50 <dolio> exists x. (P x -> forall y. P y) turns into forall x y. P x -> P y, though.
15:12:05 <dolio> Not (forall x. P x) -> forall y. P y
15:12:59 <rwbarton> You mean classically?  And are you sure?
15:13:15 <augustss> That's not right
15:13:34 <rwbarton> Classically, either P is always true, in which case I can choose any x (ok, only if the quantification is over a non-empty set), or it's sometimes false, in which case I can choose x for which it's false
15:13:36 <dolio> No, I'm not sure.
15:14:11 <augustss> It turns into exists x. forall y . (P x -> P y)
15:14:51 <dolio> Yeah, my first one isn't right.
15:15:00 <Saizan> adn then forall r. (forall x y. (P x -> P y) -> r) -> r ?
15:15:01 <dolio> But it definitely doesn't turn into (forall x. P x) -> forall y. P y.
15:15:02 <monochrom> http://www.umsu.de/logik/trees/?f=\exists%20x(Px%20\to%20\forall%20y%20Py)%20\to%20\forall%20x%20\forall%20y%20(P%20x%20\to%20P%20y)  shows you a counterexample for one direction. Do you want the other direction?
15:15:13 <monochrom> DO NOT RELY ON HEAD
15:16:07 <Olathe> E x P <=> not A x (not P)
15:18:32 <monochrom> http://www.umsu.de/logik/trees/?f=\exists%20x(Px%20\to%20\forall%20y%20Py)%20\leftrightarrow%20(\forall%20x%20P%20x%20\to%20\forall%20y%20P%20y)  shows a proof in classical logic. It breaks in intuitionistic logic but only by a half --- one direction still holds.
15:22:50 <dolio> monochrom: That's a pretty sweet website.
15:23:49 <monochrom> Great for homework of logic courses.
15:27:29 * Axman6 shoudl bookmark that
15:42:06 <hackage> Uploaded to hackage: Encode 1.2
15:50:45 <monochrom> When in doubt, use http://calc101.com/webMathematica/derivatives.jsp to get derivatives.
15:51:38 <ddarius> Just never be in doubt.  Anyways, derivatives are easy.
15:52:55 <monochrom> oops, wrong channel.
15:52:58 <rwbarton> yeah, even most mathematicians can compute derivatives :)
16:07:22 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1290#a1290
16:07:55 <mreh> what is wrong with line 54, in the where statement for crossProds
16:08:16 <mreh> i cant see anything obvious, GHCi sees otherwise
16:09:56 <rwbarton> there's nothing wrong with it in isolation; what kind of error are you getting?
16:11:28 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1293#a1293
16:11:29 <Axman6> mreh: what's the type pof crossproduct?
16:11:44 <mreh> (Float, Float) -> Float
16:11:53 <mreh> its a 2d cross product
16:11:57 <Axman6> well that's not goiung to work
16:11:59 <mreh> just gives a magnitude
16:12:02 <Axman6> :t zipWith
16:12:04 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:12:40 <Axman6> :t (signum . (crossProduct :: (Float,Float) -> Float))
16:12:41 <lambdabot> Not in scope: `crossProduct'
16:12:48 <Axman6> :t (signum . (f :: (Float,Float) -> Float))
16:12:50 <lambdabot>     No instance for (SimpleReflect.FromExpr Float)
16:12:50 <lambdabot>       arising from a use of `f' at <interactive>:1:11
16:12:50 <lambdabot>     Possible fix:
16:12:54 <Axman6> bah
16:13:05 <twanvl_> :t (signum . (?f :: (Float,Float) -> Float))
16:13:07 <lambdabot> (?f::(Float, Float) -> Float) => (Float, Float) -> Float
16:13:14 <Axman6> mreh: i don't think you understand how zipWith works
16:13:34 <Axman6> > zipWith (+) [1..10] [10..]
16:13:35 <lambdabot>   [11,13,15,17,19,21,23,25,27,29]
16:14:01 <mreh> i think i do
16:14:23 <mreh> what have i dont wrong? signum . crossProduct is of the type (Float, Float) -> Float
16:14:34 <mreh> oooh
16:14:36 <Axman6> well, signum . crossProduct had the type (Float, Float) -> Float
16:14:49 <mreh> i need Float - Float - Float
16:14:51 <Axman6> you need something of the type a -> b -> c
16:14:56 <mreh> ooooh
16:15:38 <Axman6> so, one way to do it would be (\x y -> signum $ crossProduct x y
16:15:41 <Axman6> )
16:15:49 <mreh> yeah
16:16:09 <Axman6> @pl \x y -> signum $ crossProduct x y
16:16:09 <lambdabot> (signum .) . crossProduct
16:16:20 <pumpkin_> like duh!
16:16:21 <pumpkin_> ;)
16:16:44 <rwbarton> isn't your crossProduct of type Vector -> Vector -> Float? judging from the error message
16:17:06 <Axman6> i think haskell needs a built in function :: (c -> d) -> (a -> b -> c) -> a -> b -> d
16:18:01 <Cale> :t (.).(.)
16:18:02 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:18:10 <Cale> :t fmap . fmap
16:18:11 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:18:40 <pumpkin_> :t fmap `fmap` fmap
16:18:41 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:18:46 <pumpkin_> :P
16:18:47 <rwbarton> :t fmap fmap fmap
16:18:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:19:03 <pumpkin_> too much fmapping in here, we should keep it private
16:19:24 <Axman6> indeed
16:19:24 <pumpkin_> *fmap* *fmap*
16:20:07 <pumpkin_> so, coq or agda?
16:20:29 <pumpkin_> considering I've never tried either and am only familiar with haskell
16:28:04 <Axman6> anyone managed to get http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hevolisa-dph-0.0 installed? not sure how to get cairo
16:28:20 <rwbarton> cairo comes with gtk2hs
16:28:26 <Axman6> ah right
16:30:00 * BMeph thinks fmapping on Coq just sounds dirty...
16:30:46 <Axman6> so, where should gtk2hs be installed?
16:33:43 <gwern> Axman6: can you even build gtk2hs? I keep running into errors
16:33:57 <Axman6> yep
16:34:10 <gwern> lucky
16:34:23 <Axman6> this is the darcs version though
16:34:25 * gwern wants gtk2hs for h-back, but can't :(
16:34:31 <gwern> darcs fails for me too
16:34:58 <Axman6> any ideas what ik should make make the prefix for it?
16:35:28 <dcoutts> gwern: so the released tarballs also fail for you?
16:35:36 <gwern> dcoutts: yes, everything fails
16:35:41 <gwern> we've discussed this before
16:36:06 <Axman6> no one? :\
16:36:12 <dcoutts> gwern: hmm, for some reason I thought it was your dodgy local autoconf, but if the shipped ./configure also does that for you then it's pretty weird.
16:36:13 <gwern> (and peculiarly, this failure has occurred for something like a year now, on entirely different ubuntu installs. my conclusion is that I am cursed.)
16:36:17 <Axman6> need to know where to install it so that ghc will find it
16:36:36 <gwern> Axman6: don't you just install gtk2hs's libs in the usual place?
16:36:43 <dcoutts> Axman6: by default the prefix is /usr/local and a global install, ghc will find it.
16:37:03 <Axman6> eve if ghc's in /opt/local?
16:37:07 <Axman6> n*
16:38:16 <dcoutts> Axman6: it does not matter where it is installed, so long as ghc and ghc-pkg are on the $PATH
16:38:34 <Axman6> ok, thanks
16:38:39 <dcoutts> Axman6: ghc and ghc-pkg know where the global package db is kept
16:39:18 <mofmog> I have a list of type [(Double, Double)]. I want it so that for every unique value in the first part of the tuple, you sum up the second part... so for example [(1,1), (1,2), (2,4), (2,5)] => [(1,3), (2,9)]
16:39:51 <BONUS> mofmog: Data.Map.fromListWith (+)
16:40:02 <Axman6> o.O
16:40:06 <BONUS> > Map.fromListWith (+) [(1,1),(1,2),(2,4),(2,5)]
16:40:09 <lambdabot>   fromList [(1,3),(2,9)]
16:40:13 <mofmog> holy crapwhoozle
16:40:17 <Gracenotes> 0.o
16:40:31 * BONUS bows :]
16:40:55 <Gracenotes> well, still, that does produce a map, not an assoc list :) neat, though
16:40:55 <mofmog> You are a crazy goon
16:41:01 <BONUS> haha
16:41:06 <ddarius> @google metamorphic programming
16:41:07 <lambdabot> http://web.engr.oregonstate.edu/~erwig/meta/
16:41:07 <lambdabot> Title: Metamorphic Programming
16:41:08 <Botje> BONUS: woah
16:41:17 <Botje> i didn't know that existed :(
16:41:17 <BONUS> well you can do Map.toList . Map.fromListWith (+)
16:41:36 <BONUS> yeah the fromListWith function and its cousins are an often overlooked gem
16:42:06 <hackage> Uploaded to hackage: base 4.0.0.0
16:42:38 <ddarius> That "Metamorphic Programming" link goes over an entire style of programming along those lines.
16:42:48 <BONUS> > Map.fromListWith (++) . (fmap . fmap) return $ [(1,1),(1,2),(2,4),(2,5)]
16:42:50 <lambdabot>   fromList [(1,[2,1]),(2,[5,4])]
16:42:55 <BONUS> thi sis also qewl
16:43:33 <mofmog> ddarius: along what lines?
16:43:42 <mofmog> BONUS: I think it's time to revive the haskell threadd
16:44:05 <BONUS> haha yeah someone could bump it :]
16:45:21 * BONUS bids all you y'all good night
16:45:43 <shukhov> does anyone have an opinion on nanocurses vs hscurses?
16:46:42 <redditbot> An executable operational semantics for Python ... in Haskell
16:48:00 <mae_> is there a decent platform independent file/folder tool that i can use commands like 'cp' and 'rm' and 'mkdir' in a cross platform way? (including windows)
16:48:32 <Gracenotes> perhaps a bit too late, this also works if the list is already sorted:
16:48:36 <Gracenotes> > map ((head *** sum) . unzip) $ groupBy ((==) `on` fst) [(1,1), (1,2), (2,4), (2,5)]
16:48:37 <lambdabot>   [(1,3),(2,9)]
16:48:46 <Gracenotes> kinda complicated, though :P
16:51:15 <tromp__> > ()
16:51:17 <lambdabot>   ()
16:51:21 <mofmog> bonus is too much of a genius
16:51:30 <Axman6> hmm, i get a ghc a crash when running http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hevolisa-dph-0.0
16:53:03 <mofmog> > (\x -> x x) (\x -> do { print "Boners!!!"; x x})
16:53:04 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t1
16:53:04 <lambdabot>      Prob...
16:53:22 <mofmog> hrmm
16:54:19 <dzurk> anyone have a good tutorial for haskell + emacs?
16:54:36 <mofmog> > ((\x -> x x) :: IO () -> IO ()) (\x -> do {print "LOL!!!; x x})
16:54:38 <lambdabot>   <no location info>:
16:54:38 <lambdabot>      lexical error in string/character literal at chara...
16:55:14 <Axman6> :t \x -> x x
16:55:15 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:55:16 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:55:16 <lambdabot>     In the expression: x x
16:56:05 <mofmog> wait how am i supposed to make a ycombinator
16:56:46 <wli> mu type constructors?
16:58:16 <Saizan> data Rec a = In { out :: Rec a -> a }
16:58:36 <Saizan> (or newtype if you want)
17:04:50 <gwern> auuggh
17:05:31 <gwern> dcoutts: I tried downloading the gtk2hs release tarball and getting a fresh gtk2hs darcs, and then copying over the build files (configure, Makefile.* etc.) and configuring/building that way
17:05:54 <gwern> dcoutts: but it failed to compile on 'glib/System/Glib.hs:13:0:Failed to load interface for `System.Glib.UTFString':' nonetheless
17:06:26 <gwern> it seemed like such a good idea too - if my autoconf can't be trusted, then I'll just the files generated by someone else's autoconf :(
17:10:05 <matthewp> Real World Haskell Book Club is now covering chapter 4 on #novalang
17:10:36 <Axman6> hmm, i've got an idea for a project; a haskell SQL server, using SQLite as a backend, allowing for things like webapps to use it nicely
17:10:53 <Fredrik> Is there a function that converts [False,False,True,True,False,True] to [2,3,5] ? Only the indices containing True shall be in the result list. I wrote my own function, but it's rather messy.
17:11:42 <ddarius> > findIndices id [False, False, True, True, False, True]
17:11:44 <lambdabot>   [2,3,5]
17:11:48 <monochrom> nice
17:11:56 <Axman6> mattrepl: converting?
17:12:20 <monochrom> covering.
17:12:51 <Axman6> ah
17:12:58 <Axman6> which chapter was chapter 4 again?
17:13:09 <matthewp> Functional Programming
17:13:15 <Axman6> ah ha
17:13:20 <matthewp> right now it's talking about folds
17:13:24 <Fredrik> ddarius: awesome! thanks a lot!
17:13:34 <mattrepl> Axman6: heh, yes, there is a different FP language that has become my primary
17:14:08 <Axman6> nova?
17:14:19 <mattrepl> yup
17:17:52 <shukhov> I'm having some trouble installing HGL 3.2.0.0, I'm getting an error that the E.Exception class is being used as type.
17:18:11 <shukhov> anyone else have this problem?
17:19:11 <gwern> yeah, it's the new control.exception lib
17:19:20 <gwern> standard 6.10/base4 bug
17:19:55 <shukhov> should I go changing in the source? It' seems like I could just do Exception e => e or something
17:20:32 <gwern> the easiest thing is to either import control.oldexception or use base-3
17:21:03 <shukhov> alright, I'll try it.
17:22:29 <shukhov> seems to have worked just changing Control.Exception to Control.OldException
17:26:06 <Axman6> heh, after submitting to reddit: "submitted 961 milliseconds ago by Axman6"
17:26:27 <shukhov> alright! it worked, thank you gwern. somebody should add that to the HGL cabal package.
17:26:51 <Axman6> http://www.reddit.com/r/haskell_proposals/comments/7w59a/a_networked_sqlite_server_hopefully_a_lightweight/ ideas? comments?
17:27:52 <pumpkin_> why?
17:28:17 <pumpkin_> I mean, what would set a networked sqlite apart from any of the other RDBMS?
17:28:49 <Axman6> proof of concept? i reckon it could be done with very little work
17:29:06 <Axman6> and it might even be very high performance
17:40:21 <monochrom> My old hpaste.org paste is gone.
17:40:36 <gwern> Axman6: I really don't think networked sqlite dbs are the niche sqlite is aimed for. that sort of functionality sounds limke it'd be better served by just using happs and multimaster support
17:41:58 <monochrom> What is networked sqlite?
17:42:12 <gwern> ask Axman6 :)
17:42:52 <pumpkin_> a mysql/postresql/oracle competitor!
17:42:53 <pumpkin_> :P
17:43:01 <Axman6> i was wondering how easy it might be to make a networked sqlite server. hopefully with a simple interface (via a library).
17:43:24 <pumpkin_> the main selling point of sqlite was that it was in-process though
17:43:26 <Axman6> not a competitor at all, just talking to some people about using sqlite for webappps, and how they though it would be a bad idea
17:43:46 <pumpkin_> :)
17:43:57 <monochrom> I like the tautological answer.
17:46:55 * sjanssen wonders if any of the ideas on the haskell_proposals reddit have actually been implemented
17:46:56 <dzurk> could I enhance this to prevent null lists at the head? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1300#a1300
17:47:00 <Axman6> well, they said it'd be a bad idea because it doesn't scale well, (being a file based DB, can't exactly keep it on different machines), and the fact it locks the file, so concurrency isn't great with it
17:47:17 <pumpkin_> sjanssen: I doubt it :P
17:48:25 * sjanssen starts the "here_write_this_code_for_me" reddit
17:48:43 <shapr> Anyone up for a Cambridge Haskell User's Group on the 27th or 28th of February?
17:48:45 <gwern> sjanssen: actually, the 'high level interface to dvcss' proposal has been written :)
17:48:48 <shapr> Boston, MA, USA...
17:48:48 <gwern> so that's 1!
17:49:08 <shapr> jfredett: You coming to the CHUG?
17:49:26 <shapr> saccade: Coming to the CHUG?
17:49:39 * Axman6 thinks there should be a CanHUG for Canberra
17:49:45 <shapr> Axman6: Organize it!
17:49:58 <Axman6> there'd be like three people there
17:50:00 <shapr> Probably more than you think.
17:50:09 <shapr> Find a venue, find presenters, see who shows up!
17:50:11 <pumpkin_> shapr: I can probably make it
17:50:14 <shapr> pumpkin_: cool!
17:50:23 <shapr> Looks like it'll be at BlueSpec.
17:50:33 <shapr> Which should be cool in and of itself :-)
17:50:46 <pumpkin_> anyone else from #haskell in that area?
17:50:49 <pumpkin_> who mgiht be there?
17:55:58 <shapr> pumpkin_: jfredett, saccade, several MIT people, various Sun Research Labs folks, a few from Harvard, Tufts, who knows?
17:56:12 <pumpkin_> cool :)
17:57:13 <gwern> > 6 * 1024 * 1024
17:57:15 <lambdabot>   6291456
18:01:29 <shapr> m_stone: Cambridge Haskell User's Group, 27th or 28th (depending on whether weekday or weekend is better for most survey participants).
18:01:41 <shapr> m_stone: At BlueSpec even
18:02:29 * lispy is mildly confused by the number of #haskell channels these days.  What are people talking about there?
18:03:04 * BMeph imagines, that they (occasionally) talk about Haskell.
18:03:25 <pumpkin_> shapr: are we forced to chug beer at CHUG?
18:03:40 <shapr> pumpkin_: Nah
18:05:38 <gwern> shapr: maybe you could force people to chug *something*, even if it be nonalcoholic
18:05:42 <shapr> heh
18:05:46 <shapr> CHUG SOME CODE!
18:06:02 <TomMD> Not enough heap space.
18:06:05 <BMeph> shapr: If I made you feel uncomfortable last night, I apologize. :)
18:06:16 <shapr> BMeph: wah? oh, no worries
18:06:48 <shapr> BMeph: So, you coming to the Cambridge Haskell User's Group?
18:07:36 <shapr> sOpen: Cambridge Haskell User's Group?
18:07:59 <pumpkin_> shapr: maybe post on cafe?
18:08:22 <shapr> Yeah, I will.. I was just hoping to get enough feedback prior to that to have a definite weekday or weekend choice.
18:08:22 <TomMD> When is this HUG and what is the agenda?
18:08:28 <shapr> So far weekend is looking like the best choice.
18:08:31 <BMeph> shapr: Sure, thing, just as soon as I figure out how to convince my wife that moving to New England will be better than a nightmare. ;)
18:08:36 <TomMD> 8:00 - 9:00 Haskell FTW.
18:08:43 <TomMD> 9:00-9:15: Break
18:08:52 <shapr> BMeph: Right, we've had this discussion.
18:09:12 <shapr> TomMD: You going to visit from NYC? :-)
18:09:14 <BMeph> shapr: Yes, and we'll have it again I'm sure. ;)
18:09:18 <TomMD> BMeph: Aren't you on US West coast?
18:09:31 <shapr> BMeph: Probably so. I'm still not happy with your answer ;-)
18:09:32 * shapr snickers
18:09:45 <TomMD> shapr: No, sorry.
18:09:55 <shapr> Aw, too bad
18:10:04 <BMeph> TomMD: Yes, I am.  And, if I were any farther south or west, I'd be in Mexico. Unless I swam and joined newsham in Hawaii. ;p
18:10:23 <pumpkin_> that'd be quite the swim
18:10:34 <shapr> Yeah, newshaw owns southwesterness.
18:10:58 <BMeph> pumpkin_: Yep, but I'm fat, so I float well. ;p
18:11:19 <pumpkin_> BMeph: ah okay :) google maps suggests kayaking
18:11:21 <pumpkin_> fwiw
18:11:23 <BMeph> So, on a more on-topic note... ;p
18:11:35 <shapr> haskell?
18:11:43 <shapr> Oh yeah, what's on the agenda for CHUG?
18:11:49 <shapr> Like, what sort of cool stuff could we talk about?
18:11:51 <BMeph> ...has anyone tried translating the "man or boy test" to Haskell? :)
18:12:03 <TomMD> Any interest in ARM?  No, wait - we covered that.
18:12:05 <shapr> I could describe augustss' BASIC module maybe?
18:12:18 <pumpkin_> TomMD: I'm very interested in ARM :)
18:12:21 <BMeph> Really, this isn't a -blah topic, I mean: http://en.wikipedia.org/wiki/Man_or_boy_test
18:12:22 <shapr> TomMD: Does ARM do Haskell work? I heard that actually.
18:12:32 <TomMD> Thank you for reminding me - now that I'm on a Linux box I can install the BASIC package.
18:14:34 <shapr> Heffalump: Did ARM do anything with Haskell?
18:16:05 <TomMD> Job vacancy from arm.com: "Knowledge of compiler internals. Knowledge of functional programming languages such
18:16:06 <TomMD>  as Haskell"
18:16:08 <TomMD> I'm not kidding.
18:16:18 <TomMD> So, it looks likely.
18:16:21 <pumpkin> interesting
18:16:34 <shapr> TomMD: So, looks like you were right to begin with!
18:16:34 <pumpkin_> zomg pumpkin
18:16:49 <TomMD> What luck.
18:16:49 <guinea> The ghc6 in ubuntu comes with base-3. If I want to use cabal and hackage, do I need to install ghc myself?
18:17:07 <TomMD> No, you should be able to use cabal fine, guinea.
18:17:32 <guinea> TomMD: I tried, cabal install frag, and it complained about needing base-4
18:17:50 <TomMD> I don't know about frag in particular - anyone else?
18:18:01 <guinea> TomMD: I tried installing some other stuff too
18:18:10 <L11> is digitToInt a function in haskell? I googled it and it seems that it is, however i can't use it in ghci
18:18:18 <pumpkin> Data.Char
18:18:19 <TomMD> Its pretty sad if people started requiring base 4 already.
18:18:23 <drhodes> guinea: some interesting packages need 6.10, I apt-get removed all the ghc stuff I could find and settled on the 6.10 binary, things are working well now.
18:18:34 <pumpkin> @hoogle digitToInt
18:18:34 <lambdabot> Data.Char digitToInt :: Char -> Int
18:18:46 <pumpkin> L11: if you want to use it, do Data.Char.digitToInt
18:18:48 <pumpkin> or :m + Data.Char
18:18:52 <guinea> drhodes: cool. I think I'll do that
18:19:41 <L11> ah, thanks pumpkin
18:19:51 <pumpkin> np :)
18:21:06 <gwern> hm, it's nice to see that YSlow gives gitit only 3 Fs; one F is something we won't change, one F is just not applicable, which leaves just one complaint
18:21:19 <gwern> gzippign the CSS. wish I could figure out how to do that
18:26:58 <conal> Cale: ping
18:27:05 <Cale> hey
18:28:07 <conal> Cale: hi.  i want to ask you about natural transformations.  i remember you saying that the free theorem for fmap says that fmap is a natural transformation whenever it type-checks.  (assuming no seq, i guess.)  did i get that right?
18:28:10 <BMeph> Anyone? Man or boy test, familiar with it? :)
18:28:24 <Cale> er...
18:29:04 <Cale> fmap is the arrow part of a functor
18:29:15 <conal> Cale: yeah
18:29:41 <roconnor> @unmtl StateT s (Reader r a)
18:29:41 <lambdabot> err: `StateT s (r -> a)' is not applied to enough arguments.
18:29:47 <Cale> A natural transformation would look like (f a -> g a), for some functors f and g.
18:29:49 <roconnor> @unmtl StateT s (Reader r) a
18:29:49 <lambdabot> s -> r -> (a, s)
18:29:57 <Cale> Naturality is ensured by polymorphism.
18:30:03 <roconnor> @unmtl ReaderT r (State s) a
18:30:03 <lambdabot> r -> s -> (a, s)
18:30:08 <conal> Cale: oh, right.  so fmap h.
18:30:15 <conal> Cale: do you have a reference?  i didn't find it in "theorems for free".  also, does the analogous property hold for applicative functors?
18:30:23 <Cale> Oh, the identity natural transformation you mean?
18:30:27 <Cale> er
18:30:46 <Cale> An example would be, say, a tree traversal.
18:31:00 <TomMD> I discovered gtk2hs is not thread friendly (and not ghc 6.10 friendly).  Does anyone here have an opinion on wxHaskell wrt -threaded or 6.10?
18:31:07 <Cale> (flattening a tree into a list)
18:31:33 <Cale> Suppose we have a polymorphic function  eta :: Tree a -> List a
18:31:39 <SamB> TomMD: what do you mean "not thread friendly"?
18:31:59 <SamB> you are supposed to interact with it in just one thread, yes...
18:32:06 <Cale> The naturality condition is that for any function f :: X -> Y, we have that eta . fmap f = fmap f . eta
18:32:17 <Cale> Note that those are two different fmaps
18:32:22 <TomMD> Evidently you can make it do unsafe things if you perform well-typed calls in the wrong order.
18:32:22 <conal> Cale: yeah.
18:32:42 <SamB> TomMD: wrong order in one thread ?
18:32:55 <Cale> This theorem comes for free, intuitively because eta is not allowed to look at the elements of the structures it's working with, and f is not allowed to look at anything but the elements.
18:32:57 <TomMD> SamB: Additionally, you must call something like 'unsafeInitGUIWithThreads" instead of "initGUI" when compiling with -threaded, which is something of a warning sign.
18:33:12 <TomMD> SamB: No, multiple threads accessing one window for example.
18:33:12 <SamB> TomMD: hmm. aye.
18:33:26 <SamB> oh, well, isn't that GTK mostly ?
18:33:32 <TomMD> Sure is.
18:33:50 <SamB> won't wx have the same issue then ?
18:34:04 <TomMD> Depends on the c library, which I know nothing about.
18:34:14 <TomMD> So I ask.
18:34:16 <SamB> wx is actually a C++ library
18:34:16 <lepassive> in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1311#a1311 , symbol is a character parser parses any of its input,  and parse symbol "lisp" input means parse what using symbol char parser ?
18:34:29 <SamB> which uses different GUI libraries depending on configuration
18:34:45 <Cale> conal: Does that roughly make sense now?
18:35:03 <SamB> (GTK, win32, ...)
18:35:09 <TomMD> Yes, I completely forgot.  Hummm.  I think I should go up-vote that pure Haskell TK idea on reddit.
18:35:19 <roconnor> oh nice, I can import two modules qualified under the same name, it appears.
18:35:51 <conal> Cale: yeah it does.  thx.  i remember now.  i was proving some functor morphisms (NTs) and you pointed out that the specific proofs were unnecessary.
18:36:33 <conal> Cale: thanks for unconfusing me about the form.  i'm wondering now whether something similar holds for applicative functor morphisms.
18:37:21 <Cale> The naturality condition essentially serves to say that although in the general setting, the natural transformation is defined as a separate arrow for each object, these arrows work in a fashion which "doesn't really care" about the particulars of the object.
18:38:01 <Cale> Here, polymorphism forces us to define the arrow in a uniform way for every type, which is even stronger.
18:38:03 <TomMD> Does anyone in here work on House any?  I know there are two people out there who do.
18:38:40 <TomMD> House being the Haskell OS, not a building and not a TV show. Just incase I have to clarify.
18:38:55 <conal> Cale: yep.  so i imagine there's some hope of AF morphisms also following automatically.  but i don't know.
18:39:18 <roconnor> @free [a] -> [a]
18:39:18 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
18:39:33 <Cale> Well, let's take a look at the sort of thing you'd like to show...
18:40:15 <lepassive> found out "lisp" means the name of the input, but the name of input is actually *input*  hmmmm
18:41:02 <pumpkin> would TH be a good way of performing "rewrite" optimizations that are too complex for GHC rewrite rules?
18:41:16 <SamB> pumpkin: probably not
18:41:27 <SamB> but I'm not saying that there's a better one
18:41:42 <pumpkin> but it would be one possible way?
18:41:44 <pumpkin> if not a very elegant one
18:41:46 <SamB> it would
18:42:01 <SamB> though it makes your types ugly
18:42:25 <pumpkin> hmm?
18:43:03 <pumpkin> internally I can see things getting ugly, but the AST it spits out should look like regular haskell shouldn't it?
18:43:45 <roconnor> @hoogle Bool -> m () -> m ()
18:43:45 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
18:43:45 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
18:43:45 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
18:44:37 <pumpkin> hoogle's pretty smart
18:44:43 <pumpkin> I'm impressed by that last one :P
18:46:35 <conal> Cale: examples include the AF instance for behaviors, images, and memo tries.
18:47:12 <conal> Cale: where the AF morphism is a "semantic function", mapping to functions.
18:47:50 <Cale> I suppose you have a few natural transformations lying around there where you get to use this property. pure is one.
18:47:53 <lepassive> What's the point of a dotted list ?
18:48:13 <roconnor> bah
18:48:17 <roconnor> monomorphism restriction
18:48:20 <conal> Cale: oops -- dinner time.  i gotta go.  will look for you tomorrow.  thx for the help so far.
18:48:31 <Cale> conal: sure :)
18:51:05 <roconnor> how bad is FlexibleContexts ?
18:51:26 * wli uses it all the time, but doesn't have a very good idea of what it is.
18:51:47 <SamB> pumpkin: hold on ...
18:51:58 <pumpkin> ?
18:52:28 <roconnor> wli: it allows you to pass non-variables for parameters class constraints
18:52:38 <SamB> pumpkin: look at this: http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/E-Type.html#v%3AtvrInfo_s
18:52:51 <pumpkin> :o
18:52:58 <roconnor> wli: particularly useful with multi parameter type classes
18:53:10 <roconnor> ie monad transformers
18:53:16 <SamB> that is what I meant about it making your types ugly
18:53:16 <pumpkin> SamB: ah, how the TH output looks to haddock?
18:53:24 <wli> Don't MPTC's need some extensions to begin with?
18:53:33 <pumpkin> SamB: isn't it possible to give the types nice names though?
18:55:03 <SamB> well, if it is, hopefully someone will explain it on http://trac.haskell.org/haddock/ticket/87
18:55:13 <roconnor> wli yes
18:55:30 <pumpkin> SamB: maybe mmorrow knows the answer
18:55:36 * pumpkin does the mmorrow summoning dance
18:56:09 <SamB> pumpkin: does mmorrow do a lot of TH ?
18:56:14 <pumpkin> yup
18:56:18 <SamB> mmorrow: http://trac.haskell.org/haddock/ticket/87 ?
18:56:21 <pumpkin> he's the channel's TH evangelist I think
18:56:22 <pumpkin> :P
18:57:41 <gwern> wish he could make th not suck
18:57:44 <SamB> @ask mmorrow http://trac.haskell.org/haddock/ticket/87 ?
18:57:44 <lambdabot> Consider it noted.
18:57:53 <SamB> @ask mmorrow can you please make TH not suck ?
18:57:53 <lambdabot> Consider it noted.
18:58:14 <pumpkin>  @ask mmorrow where are youuu?
18:58:36 <gwern> yay, a minor ugly formatting problem with gitit's css has been solved!
18:58:50 <gwern> if anyone asks me whether *my* evening was productive, I know the answer!
18:59:04 <SamB> what keyword should I add to all TH-related haddock bugs ?
18:59:10 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1289#a1289
18:59:19 <SamB> TH or TemplateHaskell?
18:59:46 <pumpkin> int80_h: you're reversing a one-element list :P
18:59:57 <pumpkin> x : [] === [x]
19:00:03 <pumpkin> > reverse [x]
19:00:05 <lambdabot>   [x]
19:00:09 <ddarius> reverse [x] = []:x
19:00:24 <pumpkin> :o
19:00:49 <Cale> int80_h: It does happen to be an unfoldr...
19:00:55 <gwern> a list from a single value?
19:01:01 <gwern> damn, Cale beat me to it :(
19:02:15 <int80_h> ah so unfoldr is what I want then
19:02:31 <int80_h> @hoogle unfoldr
19:02:31 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
19:02:31 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
19:02:31 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
19:02:45 <Cale> However, in this case... I'm not sure that unfoldr is any clearer.
19:02:54 <pumpkin> ooh, I didn't know about the ByteString versions of it
19:03:10 <int80_h> Cale: should I just leave it the way it is then?
19:03:39 <pumpkin> btw factorsf2 = [2]
19:03:45 <pumpkin> :P
19:03:47 <Cale> int80_h: It might be more natural to use a function which reports the number of factors of 2, along with the divided result.
19:03:55 <int80_h> pumpkin: yeah I realized it was misnamed.
19:04:03 <pumpkin> :)
19:04:25 <int80_h> I was trying to avoid a name like findFactorsofTwoandAlsoD
19:04:56 <int80_h> Cale: I believed that's what I have
19:05:20 <BMeph> Anyone here familiar with the mon or boy test? :)
19:05:37 <BMeph> *man -- sorry about the Jamaican accent... ;p
19:05:40 <wli> int80_h: I tried to help with #216 and failed.
19:05:54 <int80_h> wli: how do you mean?
19:06:01 <Cale> > let factorsOf2 n = (length xs, head ys) where (xs,ys) = span even . iterate (`div` 2) $ n in factorsOf2 24
19:06:02 <pumpkin> BMeph: no problem mon
19:06:03 <lambdabot>   (3,3)
19:06:09 <Cale> or...
19:06:15 <wli> int80_h: I didn't make any progress toward a solution to pass on to you.
19:06:38 <int80_h> wli: I think if I can implment this primality test I'll have 216 solved
19:06:55 <BMeph> pumpkin: Irie. ;)
19:07:03 <int80_h> wli: the issue right now seems to be using a test that's efficient enough
19:07:34 <Cale> > let factorsOf2 = (length *** head) . span even . iterate (`div` 2) in factorsOf2 24
19:07:36 <lambdabot>   (3,3)
19:07:49 <Cale> (Using the *** operator from Control.Arrow)
19:08:01 <int80_h> Cale: oh yeah, I see. I was going to use another function to find the length of xs, which is why I wanted the list to be like [3,2,2,2]
19:08:03 <pumpkin> int80_h: it's quite a large number
19:08:46 <Cale> That doesn't terminate on 0, so might want to be careful...
19:09:43 <Cale> Then again, your existing one doesn't quite terminate with 0 either ;)
19:10:08 <ddarius> Termination is overrated.
19:10:14 * SamB has tagged all the TH haddock bugs he could find: http://trac.haskell.org/haddock/query?status=new&status=assigned&status=reopened&status=closed&keywords=~TH&order=priority
19:10:22 <Cale> 0 has infinitely many factors of 2
19:11:25 <roconnor> 0 has infinitely many factors of 3
19:12:28 <BMeph> SamB: I think you should tag it "MakeItNotSuck". ;)
19:12:45 <SamB> BMeph: but why bother tagging tickets that?
19:12:53 <SamB> they are ALL about *that*
19:13:11 <Olathe> roconnor: That's a lot.
19:13:23 <pumpkin> Olathe: over 9000!
19:13:27 <Olathe> I know !
19:13:42 <ddarius> 9000! is quite a big number.
19:13:52 <Olathe> It's not half as big as infinity.
19:13:59 <Olathe> Maybe a third, but not a half.
19:14:09 <int80_h> I tried finding the length of an infinite list, ghci laughed at me
19:14:20 * ddarius suspects that it's quite a bit larger than infinity.
19:14:31 <Olathe> Hmm...
19:14:33 <sjanssen> > length . show $ product [1 .. 9000]
19:14:33 <Olathe> It might be.
19:14:35 <lambdabot>   31682
19:14:51 <Olathe> > length . show . round $ 1/0
19:14:53 <lambdabot>   309
19:14:59 <Olathe> Hmm...
19:15:17 <pumpkin> > product [1..9000]
19:15:19 <lambdabot>   809958998668719085829131208009794964758281463929464089222191306909090154073...
19:15:35 <SamB> Olathe: is that Float, Double, or Quadruple?
19:15:41 <sjanssen> > round $ 1/0 -- wut?
19:15:43 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
19:15:43 <Olathe> > length . show . round $ (1/0 :: Float)
19:15:45 <lambdabot>   39
19:15:50 <Olathe> > length . show . round $ (1/0 :: Double)
19:15:52 <lambdabot>   309
19:15:56 <Olathe> Wait, that's not double 39 !
19:16:05 <Olathe> > length . show . round $ (1/0 :: Quadruple)
19:16:06 <lambdabot>       Not in scope: type constructor or class `Quadruple'
19:16:07 <ddarius> Olathe: No Refunds!
19:16:08 <pumpkin> > decodeFloat (1/0)
19:16:09 <lambdabot>   (4503599627370496,972)
19:16:14 <Olathe> :(
19:16:14 <SamB> Olathe: it has a bigger exponent field, too
19:16:22 * SamB was kidding about Quadruple
19:16:27 <Olathe> It should have one extra bit.
19:16:43 * SamB wonders when Haskell is likely to support Half
19:16:58 * wli tries to think of how, given a list of lists, to generate a list of all possible choices of one element from each list.
19:17:22 <roconnor> @unmtl StateT s (Exception e) a
19:17:22 <lambdabot> s -> Exception e (a, s)
19:17:26 <SamB> wli: isn't that something like impossible ?
19:17:29 <Olathe> > foldr (liftM2 something something)
19:17:30 <roconnor> @unmtl StateT s (Either e) a
19:17:30 <lambdabot> s -> Either e (a, s)
19:17:30 <lambdabot>   Couldn't match expected type `GenericQ (Maybe u)'
19:17:34 <ddarius> sequence
19:17:35 <SamB> uncomputable reals and all that?
19:17:36 <pumpkin> wli: could you give a small example?
19:17:58 <roconnor> @unmtl ErrorT e (StateT s) a
19:17:58 <lambdabot> err: `StateT s (Either e a)' is not applied to enough arguments, giving `/\A. s -> Either e a (A, s)'
19:17:59 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
19:18:00 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
19:18:05 <roconnor> @unmtl ErrorT e (State s) a
19:18:06 <lambdabot> s -> (Either e a, s)
19:18:07 <Olathe> > foldr (liftM2 (:)) [[]] [[1,2,3],[4,5],[6,7,8]]
19:18:08 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
19:18:19 <Olathe> liftM2++
19:18:26 <pumpkin> sequence++
19:18:29 <rwbarton> @src sequence
19:18:29 <lambdabot> sequence []     = return []
19:18:29 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:18:29 <lambdabot> --OR
19:18:29 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:18:33 <Olathe> haskell++
19:18:41 <pumpkin> Olathe++
19:18:45 <pumpkin> OR--
19:19:02 <wli> Olathe has it.
19:19:06 <sjanssen> @karma or
19:19:06 <lambdabot> or has a karma of -1
19:19:27 <sjanssen> wli: Olathe just wrote out the defn. of sequence
19:20:52 <wli> aha
19:20:59 <roconnor> @unmtl StateT s (ErrorT e) a
19:20:59 <lambdabot> err: `ErrorT e (a, s)' is not applied to enough arguments.
19:21:05 <roconnor> @unmtl StateT s (Error e) a
19:21:05 <lambdabot> s -> Error e (a, s)
19:21:11 <Olathe> sequence is pretty nice :)
19:21:19 <Olathe> Even more general than mine.
19:21:48 <roconnor> @type  runError
19:21:50 <lambdabot> Not in scope: `runError'
19:22:23 <lepassive> something i need to get clear "case parse (spaces >> symbol) "lisp" input of
19:22:23 <lepassive> " shouldn't it be >>= or not ? don't we pass the parser ?
19:22:47 <ddarius> mostGeneralFunctionEver = id -- Any behavior you could want can be had by appropriately parameterizing this function
19:23:09 <Olathe> Heheh
19:23:13 <SamB> lepassive: does symbol want an argument ?
19:23:43 <monochrom> Oh hahaha.
19:24:19 <Olathe> @src (>>)
19:24:20 <lambdabot> m >> k      = m >>= \_ -> k
19:24:34 <lepassive> SamB, Yes
19:24:44 <m_stone> shapr: awesome; thanks for the ping.
19:24:56 <SamB> lepassive: then you probably do want >>=
19:25:30 <lepassive> SamB, hmmmmm but its arguments and the arguments of spaces are "lisp" input
19:25:43 <lepassive> both are Parsers
19:25:46 <SamB> eh ??
19:25:53 <Twey> @hoogle (Eq a) => [a] -> [a] -> Bool
19:25:53 <SamB> parsers take arguments now ?
19:25:53 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
19:25:53 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
19:25:53 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
19:26:11 <lepassive> name of the input and the input
19:26:12 <SamB> lepassive: which library are you using ?
19:26:29 <int80_h> Cale I tried to generalize your code but I get a parse error
19:26:30 <lepassive> SamB, it's write yourself a scheme in 48 hours
19:26:33 <int80_h> factorsof2 x = let n = (length xs, head ys) where (xs,ys) = even . iterate (`div` 2) $ n
19:26:36 <int80_h> factorsof2 x = let n = (length xs, head ys) where (xs,ys) = even . iterate (`div` 2) $ n               in factorsof2 x
19:26:41 <int80_h> hmm, I'll paste it
19:26:44 <SamB> lepassive: but what parser library ?>
19:26:59 <rwbarton> :t parse
19:26:59 <Cale> int80_h: you seem to be missing a 'span
19:27:00 <lambdabot> Not in scope: `parse'
19:27:01 <lepassive> SamB, it's Parsec
19:27:03 <Cale> 'span'
19:27:18 <lepassive> SamB, here's the page http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
19:27:44 <int80_h> Cale: oops
19:27:54 <rwbarton> lepassive: you probably want >>
19:27:56 <SamB> lepassive: symbol doesn't have any arrows in it's type
19:27:57 <Olathe> @type even
19:27:58 <lambdabot> forall a. (Integral a) => a -> Bool
19:28:00 <SamB> so you'll be wanting >>
19:28:08 <rwbarton> lepassive: you are not "passing a parser", you are building a parser out of pieces using >>
19:28:09 <Olathe> int80_h: even gives a Bool rather than a tuple.
19:28:34 <int80_h> still getting a parse error. I think it may have to do with indentation
19:28:40 <lepassive> SamB, I don't even know what arrows are
19:28:46 <int80_h> I'll post
19:28:51 <lepassive> rwbarton, please elaborate
19:28:55 <SamB> lepassive: just -> in this case
19:29:05 <Olathe> int80_h: Ahh, a parse error.
19:29:12 * SamB wasn't talking about Arrows like from Control.Arrow
19:29:13 <Olathe> @where hpaste2
19:29:14 <lambdabot> http://hpaste.org/
19:29:16 <Olathe> Bah.
19:29:21 <rwbarton> lepassive: a parser  x >> y  is a parser that matches whatever x matches, followed by whatever y matches, returning the result of y
19:29:26 * SamB was just talking about the symbol
19:29:27 <Olathe> Oh :D
19:29:30 <Olathe> It's up !
19:29:33 <rwbarton> lepassive: kind of like concatenating regular expressions
19:29:41 <int80_h> I've never used where and let at the same time
19:29:42 <rwbarton> lepassive: (except with return values)
19:29:56 <Olathe> int80_h: Oh !
19:29:57 <matthewp> Finished chapter 4 on the real world haskell book club
19:30:02 <lepassive> rwbarton, is it like (parses by x first then parses by y)
19:30:06 <Olathe> int80_h: You have no function body there.
19:30:27 <SamB> lepassive: well yeah
19:30:35 <Olathe> int80_h: You need let ... in ...
19:30:36 <SamB> how else would it work?
19:30:56 <int80_h> Olathe: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1289#a1291
19:30:58 <Olathe> int80_h: Otherwise, you're just defining variables and you never return anything from the function.
19:31:13 <int80_h> Olathe: I've got let ... in
19:31:30 <rwbarton> int80_h: your definition looks highly recursive
19:31:44 <rwbarton> I guess you haven't gotten to that part yet :)
19:31:49 <int80_h> rwbarton: yeah this is Cale's code that I tired to generalize
19:31:54 <Olathe> rwbarton: Heheh
19:32:02 <int80_h> tried
19:32:10 <lepassive> okay now this line: spaces :: Parser () what are () ?  in the first symbol :: Parser Char it's kinda straight here ?
19:32:30 <Olathe> int80_h: let defs in whatever doesn't do anything without the whatever.
19:32:41 <SamB> lepassive: () is a type with a single value:
19:32:42 <SamB> ()
19:32:45 <Olathe> > let f x = let zomg = 4 in f 5
19:32:47 <lambdabot>   <no location info>: parse error on input `;'
19:32:49 <SamB> :t ()
19:32:51 <lambdabot> ()
19:32:54 <SamB> @djinn ()
19:32:54 <lambdabot> f = ()
19:32:58 <Toxaris> lepassive: () is the name of type, its pronounced "unit", and there is only one value of that type, which is too written () and pronounced unit
19:32:58 <rwbarton> int80_h: your where clause isn't indented enough apparently
19:33:00 <Olathe> > let f x = let zomg = 4 in x + 5 in f 5
19:33:01 <lambdabot>   10
19:33:06 <Toxaris> lepassive: somewhat like:  data () = ()
19:33:07 <Olathe> int80_h: See ?
19:33:14 <int80_h> -- 04:06 < Cale> > let factorsOf2 n = (length xs, head ys) where (xs,ys) = span
19:33:15 <int80_h> --               even . iterate (`div` 2) $ n in factorsOf2 24
19:33:20 <rwbarton> int80_h: my editor put it under the =, and only then did it parse
19:33:22 <Olathe> int80_h: In one, f has a return value, in the other, it's left out.
19:33:29 <Toxaris> lepassive: so  spaces  is a Parser which may accept its input and return (), or fail
19:33:36 <rwbarton> int80_h: but probably you should just use a where clause
19:33:50 <lepassive> Toxaris, ahaa thats reasonable
19:34:26 <int80_h> rwbarton: yeah I give up, I'll just make this a where clause
19:34:56 <int80_h> rwbarton: I changed the indentation to what you said, and I've got an entirely different error now
19:35:47 <Toxaris> int80_h: if the even belongs to the span, then even has to be more indented then the ( after where
19:36:15 <Toxaris> int80_h: if you are talking about that Cale-quote :)
19:36:35 <int80_h> Toxaris: yeah I can post what I have now if you want
19:37:11 <rwbarton> int80_h: you can just take everything that Cale wrote between "let" and "in" and make it a definition in your file
19:37:22 <blackdog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1322#a1322
19:37:49 <blackdog> i'm trying to get a really basic fastcgi script working - is that a normal error message? it works ok under CGI
19:38:56 <rwbarton> blackdog: general consensus is that the atom sorting errors are harmless
19:39:33 <rwbarton> blackdog: you say it works fine as a CGI script?  then it's probably expecting to be passed arguments in the environment, so I'm not surprised running it from the command line like that doesn't work
19:41:40 <blackdog> rwbarton: ok. i guess i'll beat on apache until it tells me a bit more about the error...
19:41:56 <blackdog> at the moment it's giving me more or less nothing useful
19:42:40 <rwbarton> blackdog: oh, hmm.  I've never used fastcgi and I don't know how it relates to regular CGI.
19:43:37 <int80_h> rwbarton: I think I'll use my newbie haskell, because I don't understand Cale's code anyway, and I'm still getting errors
19:44:07 <rwbarton> blackdog: oh, having now read a little about fastcgi, I recommend you disregard my earlier comments about CGI :)
19:44:30 <Cale> int80_h: well, to understand my code, just have a look at each piece in turn, preferably starting from the right :)
19:44:40 <Cale> > iterate (`div` 2) 24
19:44:42 <lambdabot>   [24,12,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:44:57 <int80_h> ah!
19:45:14 <Cale> > span even . iterate (`div` 2) $ 24
19:45:15 <lambdabot>   ([24,12,6],[3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
19:45:19 <pumpkin> iterate is one of my favorite functions
19:45:21 <int80_h> > even . iterate (`div` 2) 24
19:45:22 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
19:45:26 <int80_h> oops
19:45:28 <Cale> not even, span even
19:45:31 <blackdog> rwbarton: ah, ok. i seem to have a heisenbug - when i changed apache's logging level to info, it worked fine, and when i turned it back to warn, it works fine once more. i think i may be going crazy.
19:45:36 <pumpkin> and you need a $
19:45:38 <pumpkin> or parentheses
19:46:26 <SamB> blackdog: and you're sure that no errant caching is going on ?
19:46:33 <Cale> span takes a predicate function, and a list, and it gives a pair of lists: the elements up until the first failure of the predicate to hold, and the remainder
19:46:58 <Cale> So span even will take all the even elements from the start of a list, giving you a list of those, and the rest of the list after that.
19:47:14 <Cale> > span even [2,4,6,8,5,10,12,14]
19:47:15 <lambdabot>   ([2,4,6,8],[5,10,12,14])
19:47:36 <blackdog> SamB: that might have been it. I restarted Apache each time, though.
19:47:50 <rwbarton> blackdog: a random guess, since your error message mentions "accept", is that there was another process that had the port it wanted open
19:48:03 <SamB> blackdog: I meant in the browser
19:48:12 <rwbarton> blackdog: perhaps another copy of your a.out
19:48:20 <int80_h> Cale: thanks, I understand now :)
19:48:22 <Cale> In our case, the number of such elements in the first list is the number of times 2 occurs in the prime factorisation of the number
19:48:28 <Elly> hm...I want dot syntax for record access :(
19:48:47 <Cale> and the first element in the remaining list is the odd number left after they've all been divided out
19:48:51 * SamB doesn't see how a directed graph would be useful for record access
19:49:02 <Elly> SamB: I mean foo.bar instead of bar foo
19:49:08 <blackdog> SamB: nah, i was watching the apache error logs
19:49:11 <SamB> Elly: yeah, I know.
19:49:22 <blackdog> rwbarton: no, it always died immediately
19:49:25 <SamB> Elly: but I just couldn't resist the GraphViz joke ;-P
19:49:39 <Elly> in particular, the internet asserts that if you have an element named bar in two records, you lose
19:49:40 <Cale> > (length *** head) . span even . iterate (`div` 2) $ 24
19:49:41 <lambdabot>   (3,3)
19:49:49 <Cale> So this is exactly the information we wanted.
19:50:05 <Cale> > (length *** head) . span even . iterate (`div` 2) $ 360
19:50:06 <lambdabot>   (3,45)
19:50:07 <Elly> :t iterate
19:50:08 <lambdabot> forall a. (a -> a) -> a -> [a]
19:50:13 <Elly> oh, nice
19:50:22 <Elly> > iterate (`div 2`) 24
19:50:24 <lambdabot>   <no location info>: parse error on input `2'
19:50:27 <Elly> > iterate (`div 2`) $ 24
19:50:28 <lambdabot>   <no location info>: parse error on input `2'
19:50:32 <Elly> oops
19:50:35 <Cale> ` in the wrong place
19:50:36 <Elly> > iterate (`div` 2) $ 24
19:50:38 <lambdabot>   [24,12,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:50:38 <Elly> yeah
19:50:42 <Elly> ah, that's cool :)
19:51:13 <Cale> > iterate (`div` 2) $ 360
19:51:14 <lambdabot>   [360,180,90,45,22,11,5,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:51:15 <Elly> hrm
19:51:30 <Cale> > map (`mod` 2) . iterate (`div` 2) $ 360
19:51:31 <lambdabot>   [0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:51:39 <Cale> There's the binary expansion. :)
19:51:43 <int80_h> Cale: I wanted to deal with the event of getting 0 as input
19:51:46 <dryahetzeph> I never quite got the $ and . operators
19:51:56 <int80_h> Cale : factorsof2 0 = 0
19:52:01 <Elly> hydrapheetz: $ is just: $ a b = a b
19:52:02 <Cale> int80_h: You can add a parameter.
19:52:06 <Elly> it lets you omit parentheses, though :)
19:52:10 <Cale> f $ x = f x
19:52:15 <hydrapheetz> Oh
19:52:20 <SamB> Elly: you forgot the parens
19:52:23 <Elly> so you can say a $ b $ c $ d instead of a (b (c d))
19:52:28 <Elly> I did?
19:52:30 <Cale> But $ happens after almost any other operator
19:52:35 <hydrapheetz> So what would . be, then?
19:52:36 <SamB> $ a b = a b?
19:52:37 <lunabot>  luna: parse error on input `='
19:52:42 <Elly> hydrapheetz: . is function composition
19:52:44 <Elly> SamB: oh, around $
19:52:44 <int80_h> Cale: I thought I could just handle this with pattern matching.
19:52:50 <Cale> hydrapheetz: (f . g) x = f (g x)
19:52:59 <hydrapheetz> Huh, looks familiar
19:53:05 <Elly> it should be
19:53:12 <Cale> Yes, it's written as a little circle in mathematics
19:53:16 * hydrapheetz had to contend with that in a college algebra class
19:53:24 <Elly> as you should have
19:53:32 <Cale> I think it's misleading and unfortunate that $ associates to the right. It really should associate to the left.
19:53:36 <wli> (1+) . (2*) = \n -> 2*n + 1
19:53:40 <Elly> Cale: when would that be confusing?
19:53:53 <Cale> Well, it confuses the difference between $ and .
19:53:55 <ddarius> Application associates to the left and ($) is application.
19:54:01 <Cale> and yes
19:54:06 <Elly> I was looking for a concrete example
19:54:09 <SamB> Cale: dunno about misleading, but it's not convenient when you need to use $!, that's for sure!
19:54:22 <pumpkin> > f $ g $ h $ 4 === f . g . h $ 4
19:54:24 <lambdabot>       precedence parsing error
19:54:24 <lambdabot>          cannot mix `(===)' [infixl 9] and `(....
19:54:28 <blackdog> hm. can you bake RTS options into a binary?
19:54:30 <pumpkin> yeah yeah
19:54:37 <rwbarton> Why isn't Agda on hackage?
19:54:40 <ddarius> (Well, actually ($) is curry application but application is just uncurry id and curry . uncurry = id [close enough] so ($) is just id.)
19:54:41 <Elly> :t $!
19:54:41 <Cale> Well, at present, you can always replace  f $ g $ h $ x with f . g . h $ x
19:54:42 <lambdabot> parse error on input `$!'
19:54:45 <Elly> :t ($!)
19:54:47 <lambdabot> forall a b. (a -> b) -> a -> b
19:54:48 <ddarius> blackdog: Yes.
19:54:50 <SamB> blackdog: there's something you can define in C to do it
19:54:56 <Elly> hm, why is $! different?
19:55:07 <Cale> Elly: f $! x = x `seq` f x
19:55:26 <Elly> :t seq
19:55:27 <lambdabot> forall a t. a -> t -> t
19:55:33 <Cale> Elly: That is, it forces the evaluation of x up to determining the top-level data constructor in it before applying f
19:55:34 <Elly> oO
19:55:42 <Cale> seq is a language primitive
19:55:44 <Elly> the type of seq doesn't make sense to me
19:55:46 <Elly> oh, that's why
19:55:54 <Cale> But it could be defined for various specific types using case
19:55:58 <ddarius> Elly: It's const but not.
19:56:00 <blackdog> SamB: oh, found it. jeez, that's filthy :)
19:56:01 <ddarius> :t const
19:56:03 <lambdabot> forall a b. a -> b -> a
19:56:08 <Cale> For instance, on Maybe, it could be defined as:
19:56:13 <ddarius> Well flip const or const id (whichever you prefer)
19:56:16 <ddarius> :t flip const
19:56:17 <lambdabot> forall a b. b -> a -> a
19:56:24 <Cale> x `seq` y = case x of Nothing -> y; Just u -> y
19:56:34 <rwbarton> Or if x has a function type, seq x y does something weird and then returns y :)
19:56:47 <Cale> Yeah, it has to check that the function is defined.
19:56:49 <SamB> blackdog: I guess it's difficult for the RTS to read RTS options out of Haskell data structures ?
19:57:20 <Cale> Anyway, if $ associated the other way, it would be possible to remove parens from more expressions.
19:57:50 <Cale> We'd be able to rewrite something like  f (g x) (h y) (k z) as  f $ g x $ h y $ k z
19:58:26 <Cale> and we lose very little, because all current uses of chained $'s are better replaced with uses of .
19:58:31 <rwbarton> Am I the only one who ever writes f $ g $ x?
19:58:40 <wli> no
19:58:44 <Cale> Composition is nicer than application because it's associative.
19:58:45 <rwbarton> e.g. do x <- readLn; return $ sin $ pi*x
19:58:53 <rwbarton> "return . sin $ pi*x" is just ridiculous
19:59:03 <blackdog> SamB: yeah, that sounds reasonable. it still feels thrillingly grotty, though.
19:59:12 <ddarius> rwbarton: You should be writing sin . (pi *) <$> readLn
19:59:13 <Cale> I would write  return . sin $ pi * x, or probably return (sin (pi * x))
19:59:23 <Cale> Or yeah, use fmap
19:59:29 <SamB> blackdog: I guess it would be cool if there was a ghc flag for it ...
19:59:38 <Cale> I don't try to avoid parens in that case.
19:59:44 <rwbarton> ddarius: well, I might write that, but surely there are times when I use return, and I didn't feel like coming up with a sufficiently complicated example
20:00:04 <Cale> I have no qualms about composing return with other functions.
20:00:14 <SamB> me either
20:00:38 * ddarius only composes return with numbers.
20:03:13 <Cale> The thing about composition is that in an expression like f . g . h $ x, you have subexpressions like g . h and f . g which are meaningful on their own.
20:04:11 <Cale> Whereas in f $ g $ h $ x, the substrings f $ g and g $ h are likely to be meaningless, and even if by some trick of polymorphism they happen to mean something, it won't be the same thing as in context.
20:04:56 <rwbarton> but in my example, return . sin is meaningless.  I guess it's best to write return (sin (pi * x)) or return (sin $ pi * x)
20:05:09 <Cale> It's not meaningless.
20:05:21 <encryptio> it might be not useful
20:05:22 <rwbarton> If I wrote it, and I say it's meaningless, then it's meaningless.
20:05:29 <Cale> :t return . sin
20:05:31 <lambdabot> forall (m :: * -> *) a. (Floating a, Monad m) => a -> m a
20:05:33 <rwbarton> It has no relation to the problem I'm trying to solve.
20:05:34 <Cale> It typechecks.
20:05:41 <int-e> :t return $ sin
20:05:42 <lambdabot> forall (m :: * -> *) a. (Floating a, Monad m) => m (a -> a)
20:05:42 <rwbarton> It's not a constituent of the mental model of my problem.
20:05:45 <monochrom> return . sin = liftM sin  which is very meaningful.
20:05:46 <ddarius> rwbarton: If it type checks, it must be right.
20:05:57 <Cale> return $ sin also typechecks, but isn't useful to you
20:06:06 <int-e> I think it'd make sense to write  return $ f . g $ x
20:06:09 <rwbarton> Yes, they are both irrelevant
20:06:18 <thoughtpolice> unsafeCoerce# :: a -> b ? ;)
20:06:43 <Cale> I would normally write return (sin (pi*x)) here though.
20:06:48 <L11> when you have something like functionName :: Num a => a -> a, the Num a => portion is assigning a type to a?
20:07:05 <Cale> L11: It's restricting the types over which the type variable a ranges.
20:07:27 <Cale> L11: Saying that whatever type a is, it must have an instance of the Num typeclass.
20:07:48 <int-e> hmm. I guess it'd be  return $ sin (pi*x)  for me.
20:07:53 <L11> ah, thanks cale
20:08:03 <Cale> int-e: yeah, that's not bad.
20:10:25 <lunabot>  luna: lexical error in string/character literal at end of input
20:10:38 <rwbarton> int-e: ah yes.  I like that better than anything else so far.  (that's what I get for coming up with a contrived example)
20:12:04 <gwern> 'EDIT: As noted by another reviewer, it is a shame that one needs to be a Linux sys-admin to run the software as it stands. However, it is possible to rewrite the programs in Haskell or Mathematica on more commonplace platforms. It is also not actually necessary to run the programs as they stand -- the book is good just to read.'
20:12:04 * wli really writes return . sin $ pi * x
20:12:25 <gwern> woo. (the above comment is from a review for the _Structure and Interpretation of Classical Mechanics_)
20:13:37 <wli> What is the software he's talking about?
20:13:45 <wli> C?
20:13:46 <gwern> the mit scheme impl
20:13:47 <Cale> return . sin . (pi*) $ x
20:13:57 <Cale> ;)
20:14:43 <int-e> (*) pi
20:14:55 <rwbarton> Cale: I know you'd really write it as  return . ($ x * pi) $ sin  :)
20:15:20 <rwbarton> gwern: hmm
20:15:22 <gwern> no, Cale would write it as a succesion of flips and fmaps
20:15:32 <int-e> return . sin . uncurry (*) $ (pi, x)
20:15:43 <wli> Cale: return . sin $ pi * x avoids all parens, which seems to be the thrust of how I tend to write expressions.
20:15:45 <rwbarton> gwern: is it possible to install ghc from a binary distribution in one's home directory on linux?
20:16:07 <gwern> rwbarton: sure. I am reasonably sure that's what I did for 6.10
20:16:26 <gwern> in fact
20:16:58 <rwbarton> gwern: hmm, ok.  I tried to do that with the Mac installer and couldn't get it to work.  (Obviously, that's quite unrelated.)
20:17:13 <int-e> sin <$> x * pi
20:17:22 <gwern> well, I make no guarantees for mac - I'm on linux :)
20:17:48 <rwbarton> yeah
20:17:49 <int-e> (or `liftM` instead of <$> if you don't like Functor)
20:18:45 <int-e> (oh. that doesn't work though: `liftM` doesn't have a suitable fixity.)
20:18:58 <int-e> *precedence
20:19:21 <wli> int-e: The type seems to be a little off.
20:20:09 <int-e> @pl \x -> return (sin x)
20:20:09 <lambdabot> return . sin
20:20:21 <gwern> ' The content of the book is thoroughly modern, and covers topics from Lie series to a variety of topics in chaos theory. The authors have an impressive track record in the latter area: they were the first ones to show the fact that the solar system is chaotic, a rather startling discovery when it was announced in 1988 (in Science, 241, 433; using a special-purpose computer, the Digital Orrery, they found that Pluto's orbit has an ...
20:20:28 <gwern> ... inverse Lyapunov exponent of 20 Myr). Finally, all chapters in the book are interspersed with numerous helpful exercises, all of which have been tested extensively during the six years that the authors have taught the material presented in this book to undergraduates at M.I.T. '
20:20:40 * gwern is confused. isn't the 3-body and greater chaotic? 
20:20:56 <wli> @type \x -> (return (sin (pi*x)), sin <$> pi*x)
20:20:57 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Floating a, Monad m, Floating (f a)) => f a -> (m (f a), f a)
20:21:21 <int-e> wli: argh. right
20:21:31 <rwbarton> gwern: I expect that MIT Scheme will languish even further now that the Scheme introductory computer science is gone
20:21:37 <wli> @type (\x -> return (sin (pi*x)), \x -> sin <$> pi*x)
20:21:39 <lambdabot> forall a (m :: * -> *) a1 (f :: * -> *). (Functor f, Floating (f a1), Floating a1, Monad m, Floating a) => (a -> m a, f a1 -> f a1)
20:22:15 <gwern> rwbarton: I get the impression that the issue is that the 'scmutils' library has a heck of a lot of physics utility functions, and that it relies on UI specifics
20:22:16 <wli> rwbarton: Please don't tell me they're using Java.
20:22:19 <int-e> wli: it's just as well that in practice, I'd never even think of trying that :)
20:22:27 <gwern> wli: python iirc
20:22:28 <gwern> robots
20:22:33 <rwbarton> wli: yeah, python
20:22:40 <wli> That's terrifying.
20:22:43 <yav1> do we have any guidelines about how to make a package work with both base3 and base4?
20:22:47 <gwern> 'The version of Scheme that we use in this book is MIT Scheme, augmented with a large library of software called Scmutils that extends the Scheme operators to be generic over a variety of mathematical objects, including symbolic expressions. The Scmutils library also provides support for the numerical methods we use in this book, such as quadrature, integration of systems of differential equations, and multivariate minimization.'
20:22:51 <rwbarton> @who yav1
20:22:51 <lambdabot> Maybe you meant: echo ghc show thx what wn
20:23:17 <rwbarton> gwern: maybe whether the system is chaotic depends on parameters like relative body masses and initial state
20:24:09 <gwern> rwbarton: that actually would make sense - if 2 bodies spiralled into the 3rd, it'd hardly be chaotic
20:25:32 * wli would've gone in for Standard ML or something.
20:25:46 <gwern> wli: it's mit
20:26:01 <gwern> I don't think I've ever heard of miters using anything in the ml family
20:28:13 <SamB> I think it's spelled MITers if you don't want to sound like you are talking about woodworking
20:28:39 <gwern> woodworking? MIT? man, I was talking about my hat
20:28:44 * gwern loves my miter
20:29:19 <SamB> hat ?
20:29:28 <gwern> darn tootin'!
20:30:09 <SamB> you were talking about MIT mail-reader-that-happens-to-run-scheme, weren't you ?
20:30:44 <gwern> dude, that was like 3 minutes ago
20:30:48 <gwern> it's ancient history
20:31:05 <Elly> wli: here (CMU) teaches parts of the CS curriculum in SML
20:31:19 <Elly> using SML/NJ, which is effective in fostering a healthy dislike of ML among all the students
20:31:33 <gwern> (how sad)
20:31:55 <Elly> a lot of the stuff they want you to do forces you to play to ML's weaknesses
20:32:06 <Elly> (i.e. ghastly syntax, ugly way of doing imperative code, &c)
20:37:22 <gwern> 'More than iron, more than lead, more than gold I need electricity. \ I need it more than I need lamb or pork or lettuce or cucumber. \ I need it for my dreams.'
20:37:50 <Adamant> Tesla?
20:38:15 <cjs> Hey, uncollected garbage doesn't show up in heap profiles, does it?
20:38:21 <gio123> gwern: where are u from?
20:38:32 <pumpkin-> he's from wikipedia!
20:38:35 <SamB> cjs: generally the samples are taken immediately after collection
20:38:37 <SamB> so, no
20:38:47 <pumpkin-> gwern has userhost n=gwern@wikipedia/Gwern
20:38:48 <pumpkin-> see?
20:38:51 <Adamant> gio123: don't worry, he's from the Internet
20:39:03 <gio123> ok
20:39:04 <gio123> :)
20:39:22 <gio123> i assumed he were from africa
20:39:23 <gio123> :)
20:40:45 <cjs> Hm. So what does it mean if I see my memory usage head up fairly steeply for 150 seconds or so, then suddenly collapse (e.g., from 40 MB back to 8 MB), and then continue to cycle like this every 150 seconds or so?
20:41:13 <wli> cjs: GC
20:41:23 <mjrosenb> cjs: it sounds like you're building up a *ton* of thunks
20:41:36 <mjrosenb> then something triggers them to all be evaluated
20:41:45 <SamB> or, at least, tons of stuff
20:41:48 <byorgey> cjs: sounds like your program is expressing its output in unary via the GC
20:41:49 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:41:53 <SamB> it might just be data structures
20:42:00 <SamB> byorgey: lol
20:42:32 <cjs> byorgey: Oh, I was wondering how I could get output in Haskell!
20:42:35 <SamB> cjs: what sorts of heap profiles have you tried ?
20:42:50 <byorgey> cjs: yep!  Just make the box get hot in a certain pattern
20:42:57 <cjs> mjrosenb: Yes, I'm definitely building up lots of thunks. I'm not entirely happy about this.
20:43:12 <pumpkin-> you shoulda thunk it through
20:43:15 <cjs> wli: So you think it's actually unreferenced stuff that just hasn't been collected?
20:43:16 <L11> can i not use Data.Char.digitToInt inside a .hs file?
20:43:25 * cjs throws a brick at pumpkin.
20:43:30 * pumpkin- hides
20:43:47 <cjs> And he should, for a joke like that.
20:44:16 <sjanssen> L11: sure, but you have to import Data.Char first
20:44:18 <mjrosenb> cjs: you're ready to punt him just for a bad pun?
20:44:30 <cjs> *Sigh*.
20:44:38 <L11> sjanssen: how do you import?
20:44:45 * pumpkin- throws a brick at mjrosenb from behind his hiding place
20:44:48 <mjrosenb> L11: import <module name>
20:44:51 <dsrogers> join #haaps
20:45:00 <cjs> Hm, but seriously, you think it's gc? So the profiler is counting unreferenced stuff in the heap?
20:45:07 <L11> k thanks :)
20:45:08 <dsrogers>  / is not my friend, it seems.
20:46:10 <SamB> dsrogers: there's nobody there anyway
20:46:52 <dsrogers> how is | m->a  read in a class defintion?
20:46:59 <dsrogers> m determines a?
20:47:06 <sjanssen> dsrogers: yes
20:48:54 <L11> hm, I tried 'import Char' and 'import Data.Char' and both throw an error to the effect of "parse error on input 'import'" - what am i missing here?
20:49:32 <byorgey> L11: imports have to go at the top of the file.
20:49:42 <L11> ah that's it :) thanks
20:50:01 <byorgey> well, after any module declaration
20:50:09 <byorgey> 'module Foo where \n  import Blah ...'
20:50:45 <monochrom> yeah, import everything before defining anything
21:00:41 <SamB> don't even try to put a haddock comment between "module" and "import"
21:38:24 <dons> this is a pretty cool list of newbie hurdles in haskell, guys, http://ripplingbrainwaves.blogspot.com/2009/02/haskell-comprehension-measured-through.html
21:39:01 <dons> "How come there's all these string escapes in the flow of code? W...T...F? Oh, lambda. Cute"
21:39:58 <araujo> Hi dons
21:40:00 <araujo> :)
21:40:22 <dons> heya araujo
21:40:39 <araujo> hah
21:44:39 <Heffalump> shapr: yes, some bits and pieces
21:45:24 <dsrogers> so if I have a new type (NewTypeT) built from a stack of monad transformers that looks like AoneT (AtwoT (MaybeT m)) a and I want my fail method to use MaybeT's fail method, is the correct idiom someting like:
21:45:59 <dsrogers> fail a = NewTypeT $ AoneT $ AtwoT $ MaybeT $ fail a
21:46:01 <dsrogers> ?
21:46:45 <redditbot> Learning Haskell measured through WTF/min!
21:47:12 <dsrogers> I see that it works, I just don't like that it requires so many constructors.  I feel like I should be able to do it with lift or something.
21:47:43 <Heffalump> you shouldn't have MaybeT in the fail definition
21:47:52 <Heffalump> otherwise you'll get the fail from under MaybeT
21:48:00 <Heffalump> and yes, you should be able to do it with lift
21:48:07 <dsrogers> ahhh.
21:48:08 <Heffalump> fail a = NewTypeT $ lift $ lift $ fail a
21:48:31 <Heffalump> also, in general the data constructors for each monad transformer are not the type constructors
21:48:40 <Heffalump> which is in fact the case for MaybeT too, so I presume you didn't try that code :-)
21:48:58 <rwbarton> dsrogers: can you just define fail _ = mzero? (if your monad transformers preserve MonadPlus)
21:48:59 <Elly> :t NewTypeT
21:49:00 <lambdabot> Not in scope: data constructor `NewTypeT'
21:49:08 <Elly> @hoogle NewTypeT
21:49:09 <lambdabot> No results found
21:49:34 <Elly> oh, wait, you were referring to something in your own code :P
21:49:50 <dsrogers> rwbarton: no.  In my case, one of the one is the stack is ErrorT.  Besides I think MaybeT in hackage doesn't implement MonadPlus
21:50:11 <rwbarton> dsrogers: ah
21:50:50 <int80_h> rwbarton: so I tried to add a line to my factoring function, to deal with 0
21:51:09 <int80_h> factorsof2 0 = 0
21:51:29 <int80_h> I was trying to use pattern matching to return 0
21:51:38 <dsrogers> rwbarton: in my case, I'm combining a lot of monads, and picking and choosing which behaviors I want to pull up out of the stack.
21:51:39 <int80_h> doesn't work though
21:52:21 <dsrogers> it's kinda wacky, but I must say, MonadT's are extraordinarily composable.
21:52:21 <rwbarton> int80_h: doesn't your function return a pair?
21:53:29 <int80_h> rwbarton: oops, yeah. This is why I normally write out the type definition.
21:54:32 <lepassive> how is this expression evaluated ? maybe (Bool False) ($ args) $ lookup func primitives
21:55:11 <pumpkin-> lepassive: how do you mean?
21:55:47 <Cale> lepassive: That looks like a data constructor applied to some stuff, so it's already evaluated.
21:55:52 <glguy> if "func" is in the map "primitives" then the function found is applied to "args"
21:55:59 <Cale> Well, okay, the $ disappears.
21:56:00 <lepassive> pumpkin, What i undersatnd is It looks func up in a list of pairs then evaluate ($ args ) but i don't get it ?
21:56:01 <glguy> otherwise the value "Bool False"
21:56:10 <Cale> oh
21:56:13 <Heffalump> Cale: and the maybe..
21:56:14 <Cale> I didn't see the 'maybe'
21:56:22 <Cale> okay, yes
21:56:32 <pumpkin-> that's just because lookup returns a maybe
21:56:34 <pumpkin-> Maybe, that is
21:57:03 <Cale> (I was thinking "Well, that's an odd type for a data constructor..." :)
21:57:18 <Cale> okay
21:57:22 <lepassive> hmmmm how come that func is applied to args ? shouldn't it be f (args ) not args (f ) ?
21:57:35 <pumpkin-> that's what the $ is for
21:57:37 <Cale> ($ args) f
21:57:41 <Cale> = f $ args
21:57:41 <glguy> ?unpl ($ args)
21:57:42 <lambdabot> (\ a -> a args)
21:57:43 <pumpkin-> > ($ 1) (+1)
21:57:43 <Cale> = f args
21:57:45 <lambdabot>   2
21:58:05 <lepassive> Cale, aha now it's clear sorry for disturbance guys
21:58:09 <glguy> ?src ($)
21:58:09 <lambdabot> f $ x = f x
21:58:39 <pumpkin-> not a disturbance!
21:58:39 <glguy> lepassive, questions like that are welcome in this channel
21:59:27 <lepassive> #haskell is really taking over me :)
21:59:47 <Cale> #haskell is the ultimate documentation. ;)
22:00:18 <lepassive> Cale, sounds so, I'd have dropped Haskell a few weeks ago without #haskell
22:01:11 <cjs> Hm. Any thoughts on why I might have a space leak when I run my program on a 64-bit machine, but not a 32-bit machine? This is gcc 6.8.3.
22:02:28 <lepassive> :t reads
22:02:29 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:04:36 <cjs> Why do these things tend to return a list of one element or empty on failure? Because it was designed pre-Maybe and locked into the spec?
22:05:20 <rwbarton> Because you might want to use the ReadS mechanism with your own types that have ambiguous, backtracking parsers
22:06:58 <bd__> Surely that should be: forall a m. (Read a, MonadPlus m) => String -> m (a, String)  then :)
22:09:23 <dons> cjs: mmm
22:09:31 <dons> cjs, dcoutts_ had a funny bug related to this
22:09:39 <dons> the only one i've heard of. see if he's around
22:10:34 <wli> And a rare case where it actually wants to be both MonadPlus and MonadZero.
22:12:08 <cjs> @seen dcoutts
22:12:08 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 5h 33m 28s ago.
22:12:11 <cjs> @seen dcoutts_
22:12:11 <lambdabot> dcoutts_ is in #ghc and #haskell. I last heard dcoutts_ speak 7h 53m 7s ago.
22:12:46 <cjs> Thanks, Don. I'll ping him by e-mail. But first I think I'll test 6.10. Do you think it's worth filing a bug report for 6.8 if it turns out to be a 6.8-only problem?
22:13:01 <dons> nope
22:13:05 <cjs> Ok.
22:13:22 <cjs> Though maybe even just to document the issue?
22:14:17 <rwbarton> I've seen the reverse (space leak on a 32-bit machine, not on a 64-bit machine)
22:15:32 <rwbarton> due to operations on Int64s being handled by FFI calls on a 32-bit system, the strictness analyzer didn't know they were strict
22:15:52 <mjrosenb> what's the trigger for lambdabot's 'optimizer'?
22:18:54 <x6d65> I have a "coming from another language I'd do X" design question. Conceptually I have a set of nodes with connections between them, and in a language with mutation I'd represent the nodes as structs with pointers to other structs of the same type (two structs may have pointers to the same node). What's an efficient way to go about implementing this sort of relationship in Haskell?
22:19:03 <rwbarton> mjrosenb: do you mean @pl?
22:20:06 <dons> x6d65: as a tree? or a graph?
22:20:16 <x6d65> dons: A graph.
22:20:31 <dons> use a graph library (e.g. fgl on hackage)
22:20:47 <dons> do you know how to describe data  types in haskell?
22:20:51 <rwbarton> x6d65: a typical solution is replace pointers by indices into a Map
22:21:15 <dons> e.g. data Tree a = Empty | Node (Tree a) (Tree a) <-- the pointers are implicit here
22:21:18 <x6d65> Fair enough, and yes I'm fine with defining data types.
22:21:37 <wli> There's also the Fortran method, which is to make a big fat array and replace the pointers with indices into the array.
22:22:01 <rwbarton> ... that's more or less the same as the Haskell method. :)
22:22:16 <x6d65> rwbarton: Yes, that was my first though.
22:22:20 <x6d65> *thought
22:22:51 <wli> rwbarton: Usually the Fortran method involves reassembling the data structure by picking up the byte-sized pieces from the array.
22:24:06 <rwbarton> x6d65: there is also STRef/IORef if you really need it.
22:24:14 <wli> I don't know precisely how the casting procedure works. It wasn't explained to me in that much detail. Mostly they cursed and swore about how bad F77 is/was.
22:24:46 <x6d65> The original program that I'm basically just replicating was written in C and had a bunch of arrays that together represented a node and the connections between them.
22:25:46 <rwbarton> wli: oh, an array of bytes, not an array of structs.
22:25:53 <rwbarton> wli: ... that's not very pleasant :)
22:26:40 <x6d65> I can certainly take the same approach in Haskell, but I was curious how a more node-oritented approach would work.
22:27:50 <wli> rwbarton: I'm not entirely sure it was bytes but it was something fixed-size (int?).
22:29:41 <pumpkin-> dons: ping
22:30:04 <mjrosenb> hrmm, is there any way to get the concept of the 'end' with a channel?
22:33:58 <smitty1e> quick syntax question: how do I raise a number to a fractional exponent, specifically, a cube root?
22:33:59 <lambdabot> smitty1e: You have 1 new message. '/msg lambdabot @messages' to read it.
22:34:06 <pumpkin-> **
22:34:11 <pumpkin-> > 8 ** (1/3)
22:34:11 <Olathe> mjrosenb: Do you mean a Chan ?
22:34:12 <lambdabot>   2.0
22:34:26 <smitty1e> ah! ^ was no joy
22:34:45 <pumpkin-> yeah, the three exponentiation functions can be confusing
22:35:10 <pumpkin-> it would be nice if they could be coalesced into a single operator that was specialized for different types
22:35:49 <wli> The numeric hierarchy sucking, as usual.
22:35:52 <Olathe> > let root _ 0 = 0; root n x = if (r' + 1)^n > x then r' else (r' + 1) where r' = shiftR x n in root 3 8
22:35:54 <lambdabot>   2
22:36:09 <Olathe> > let root _ 0 = 0; root n x = if (r' + 1)^n > x then r' else (r' + 1) where r' = shiftR x n in root 8 256
22:36:11 <lambdabot>   2
22:37:44 <smitty1e> pumpkin-: I'd settle for a good wiki page to pop up on a google search.
22:38:03 <pumpkin-> :) yup
22:39:00 <Olathe> Hmm...
22:40:30 <mjrosenb> Olathe: yes
22:40:44 <wli> let root' n x (a, b) | a + 1 >= b = (a, b) | otherwise, c <- (a + b) `div` 2 = case (c^n) `compare` x of EQ -> (c, c) ; LT -> (c, b) ; GT -> (a, c) ; root n x = let rs = root' n x (1, x) in fst . snd . head . dropWhile (uncurry (/=)) $ zip rs (tail rs)
22:40:51 <mjrosenb> pumpkin-: this sounds like a bad idea
22:41:10 <wli> Throw in some Newton steps if you want it faster. ;)
22:41:18 <mjrosenb> pumpkin-: the specialized by type that is
22:41:20 <pumpkin-> probably given the current implementation :P but I'm just saying having three different exponentiation operators is confusing
22:41:39 <pumpkin-> I know specialization is GHC-specific
22:41:44 <pumpkin-> and we'd be breaking from h98 etc.
22:41:52 <mjrosenb> pumpkin-: the fact that exponentiation is defined when the exponent is real is confusing
22:42:00 <Olathe> mjrosenb: If you want, you can use Maybe and terminate it with Nothing.
22:42:13 <pumpkin-> mjrosenb: you mean for negative bases and real exponents?
22:42:29 <pumpkin-> yeah, that could be messy :/
22:42:47 <mjrosenb> Olathe: right, but if i have 5 threads pulling from a single queue, only one will get the Nothing
22:43:16 <mjrosenb> pumpkin-: no, i mean the fact that i can raise something to the pi power is rather confusing
22:43:27 <rwbarton> mjrosenb: you can have the thread put the Nothing back then
22:43:38 <rwbarton> mjrosenb: it's a little delicate I guess
22:44:25 <mjrosenb> rwbarton: eww.
22:44:30 <wli> There are ca. 5 progressive generalizations of exponentiation; (1) from natural number exponent to (possibly negative) integer exponent (2) from integer exponent to rational exponent (3) from rational exponent to real exponent (4) from real exponent to complex exponent (5) from real *BASE* to complex *BASE*
22:44:30 <mjrosenb> * sigh *
22:45:09 <pumpkin-> you never went to real base
22:45:09 <mjrosenb> wli: the last one isn't that tricky
22:45:11 <wli> (5) is where it gets really nasty in conjunction with irrational exponents
22:45:21 <pumpkin-> the real base step, from natural, is a big one
22:45:38 <wli> pumpkin: Not really.
22:45:42 <mjrosenb> pumpkin-: not as long as multiplication on reals is defined
22:45:57 <pumpkin-> I mean, once you already have a real exponent
22:46:13 <dolio> Not all those generalizations can be carried out, depending on what your base's structure is.
22:46:29 <wli> mjrosenb: Cauchy principal value stuff etc.
22:46:36 <Olathe> > let root _ 0 = 0; root n x = if (r' + 1)^n > x then r' else r' + 1 where r' = shiftL (root n (shiftR x n)) 1 in root 5 (37^5)
22:46:38 <lambdabot>   37
22:46:43 <Olathe> Ahh, found the bug in mine.
22:46:45 <wli> I've got to get out of here.
22:46:45 <dolio> Natural to integer only makes sense if there are multiplicative inverses (so, not rings).
22:47:06 <dolio> Etc.
22:47:23 <Elly> hm, lambdabot doesn't listen to private messages?
22:47:34 <dolio> It does.
22:47:54 <mjrosenb> then step 3 is a really tricky one.  once youve done that, you've resorted to a taylor series, and everything else is just a taylor series
22:47:56 <Olathe> lambdabot is nice for that :)
22:47:57 <Elly> I just tried :t in a message and it did not reply
22:48:07 <Elly> is there a prefix one needs to use?
22:48:09 <Olathe> Elly: Ahh, it likes @type in privat.
22:48:12 <Elly> oh
22:48:22 <Olathe> Which works here, too.
22:48:24 <Olathe> @type id
22:48:26 <lambdabot> forall a. a -> a
22:48:39 <Elly> what does '@' mean in haskell?
22:48:51 <Olathe> Oh, it means the whole thing that follows.
22:49:02 <Elly> ?
22:49:03 <dolio> > let f l@(x:_) = x:l in f [1..10]
22:49:04 <lambdabot>   [1,1,2,3,4,5,6,7,8,9,10]
22:49:04 <Olathe> Like xxs@(x:xs) gives xxs == (x:xs)
22:49:19 <ski_> > let f xs@(x:_) = (xs,x) in f [0,1,2,3]
22:49:20 <Elly> oh, I see
22:49:21 <lambdabot>   ([0,1,2,3],0)
22:49:21 <mjrosenb> Elly: like as in sml
22:49:23 <Elly> like 'as' in SML
22:49:25 <Elly> yeah
22:49:44 * mjrosenb likes "as" better
22:49:54 <mjrosenb> @ is useful as in infix operator
22:49:55 <Olathe> > let showIt xxs@(x:xs) = "xxs = " ++ xxs ++ ", x = " ++ show x ++ ", xs = " ++ show xs in showIt "zomg"
22:49:57 <lambdabot>   "xxs = zomg, x = 'z', xs = \"omg\""
22:50:07 <Olathe> Hmm, not quite, but good enough :)
22:50:15 <chrisdone> dons: does hackage have information about how many times a package has been downloaded?
22:50:16 <Olathe> You can use @ as an operator ?
22:50:20 <ski_> `as' is usefule as plural of `a'
22:50:21 <Elly> is it convention to put no spaces around @ like that?
22:50:28 <Olathe> Elly: Yep.
22:50:30 <mjrosenb> Olathe: sml
22:50:38 <Olathe> mjrosenb: Ahh, OK.
22:50:45 <Elly> why is that the convention?
22:51:10 <rwbarton> usually spaces separate different arguments
22:51:19 <mjrosenb> Elly:spacesareevilandshouldbedestroyed
22:51:34 <ski_> if you don't like it i'm sure people won't complain much if you put a few spaces in there
22:51:48 <mjrosenb> notheyshouldallbedestroyed
22:51:58 <Olathe> Spacing is nice.
22:52:07 <dolio> mjrosenb: There might be structures where it makes sense to have rational exponents but not real exponents. Integers modulo a number, for instance.
22:52:08 <Olathe> So that the things that aren't spaced don't stick out as much.
22:52:12 <rwbarton> > let showIt xxs @ (x:xs) = "xxs = " ++ xxs ++ ", x = " ++ show x ++ ", xs = " ++ show xs in showIt "zomg"
22:52:13 <lambdabot>   "xxs = zomg, x = 'z', xs = \"omg\""
22:52:14 <Olathe> Like 2*3 + 5
22:52:31 <rwbarton> > let showIt (xxs @ (x:xs)) = "xxs = " ++ xxs ++ ", x = " ++ show x ++ ", xs = " ++ show xs in showIt "zomg"
22:52:33 <lambdabot>   "xxs = zomg, x = 'z', xs = \"omg\""
22:52:41 <rwbarton> that looks ok to me
22:52:44 <dolio> Although you might not be computing arbitrary roots. I don't know.
22:53:01 <Olathe> > let showIt xxs @ (x:xs) = say $ "xxs = " ++ show xxs ++ ", x = " ++ show x ++ ", xs = " ++ show xs in showIt "zomg"
22:53:02 <lambdabot>   xxs = "zomg", x = 'z', xs = "omg"
22:53:07 <rwbarton> An algebraically closed field has arbitrary rational exponents.
22:53:09 <Olathe> There we go.
22:53:13 <rwbarton> Pretty much nothing has arbitrary real exponents.
22:53:15 <pumpkin-> is there a simple xml combinator lib like the html and xhtml ones?
22:53:19 <dolio> Yeah.
22:53:20 <pumpkin-> I just need to generate some simple xml
22:53:40 <mjrosenb> dolio: i know.  i'm saying that having real exponents is *absurd*
22:53:45 <Olathe> I don't like the spacing around @
22:53:52 <Olathe> It makes it seem like different arguments.
22:54:08 <rwbarton> Olathe: yeah, unless you put it inside ()
22:54:14 <Olathe> Eeeewwww ;)
22:54:22 * ski_ would prefer if `@' bound less tightly, though ..
22:54:51 <dolio> Oh, right, that was step 3.
22:55:22 <dolio> @type (^^)
22:55:24 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
22:55:32 <ski_>   showIt (xxs @ x:xs) = ...  -- e.g.
22:57:29 <pumpkin-> argh, too many xml libs :P
22:58:35 <dolio> Anyhow, what's wrong with exponentiation with reals? People are going to want it for Float and Double.
22:59:01 <dolio> Even if that's the only thing they want it for.
22:59:06 <pumpkin-> > pi ^ pi :: CReal
22:59:08 <lambdabot>   Add a type signature
22:59:09 <rwbarton> > (-78)^(787.6)
22:59:10 <lambdabot>   Add a type signature
22:59:12 <pumpkin-> > pi ** pi :: CReal
22:59:14 <lambdabot>   36.4621596072079117709908260226921236663655
22:59:15 <rwbarton> > (-78)**(787.6)
22:59:17 <lambdabot>   NaN
22:59:17 <Olathe> > (exp 1)**(0 :+ pi)
22:59:19 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
22:59:28 <pumpkin-> > (-pi) ** pi :: Complex CReal
22:59:30 <lambdabot>   (-32.9138577418938781782614637945683708657447) :+ (-15.68971165343317064139...
22:59:34 <Olathe> > (exp 1)**(0 :+ pi) :: Complex CReal
22:59:39 <lambdabot>   (-1.0) :+ 0.0
22:59:59 <Olathe> > (exp 1)**(0 :+ (3*pi)) :: Complex CReal
23:00:05 <lambdabot>   (-1.0) :+ 0.0
23:00:18 <pumpkin-> CReal is never wrong!
23:00:24 <Olathe> Heheh
23:00:53 <pumpkin-> can anyone suggest a simple xml combinator lib? :)
23:02:11 <Elly> "simple" "xml"
23:02:17 <Elly> please reconcile these two words
23:02:33 <pumpkin-> lol
23:02:51 <pumpkin-> I want to generate a very simple .kml file for google earth and want to avoid concatting strings
23:02:59 <pumpkin-> the structure is almost linear
23:03:06 <pumpkin-> I'm just jamming a few coordinates into it
23:04:44 <dsrogers> is there an equivilent of "lift" for single and two argument functions?
23:05:08 <dolio> @type (lift .)
23:05:09 <Olathe> > liftM2 (*) [a, b] [c, d]
23:05:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) a1. (Monad m, MonadTrans t) => (a1 -> m a) -> a1 -> t m a
23:05:11 <lambdabot>   [a * c,a * d,b * c,b * d]
23:05:42 <dolio> @type lift . (.)
23:05:44 <lambdabot> forall (t :: (* -> *) -> * -> *) b c a. (MonadTrans t) => (b -> c) -> t ((->) (a -> b)) (a -> c)
23:05:50 <Olathe> @type lift
23:05:51 <pumpkin-> @type lift
23:05:51 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
23:05:52 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
23:05:59 <Olathe> @src lift
23:05:59 <lambdabot> Source not found. Where did you learn to type?
23:05:59 <dolio> @type ((lift .) .)
23:06:00 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) a1 a2. (Monad m, MonadTrans t) => (a2 -> a1 -> m a) -> a2 -> a1 -> t m a
23:06:05 <Olathe> @src [] lift
23:06:05 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:06:19 <pumpkin-> Olathe: optimus prime!
23:07:03 <Olathe> Ehh ?
23:07:18 <dsrogers> that's not quite the same.
23:07:26 <dsrogers> I have a 3 monadT stack.
23:07:32 <pumpkin-> Olathe: transformers :P
23:08:03 <dolio> Try to keep up with pumpkin's free association.
23:08:08 <Olathe> Oh :)
23:08:13 <dsrogers> and I'm trying to borrow the inner most MonadT's implementatino of monadPlus
23:08:15 <Olathe> I haven't used monad transformers yet, I think.
23:08:30 <Olathe> @src MonadTrans
23:08:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:08:30 <dolio> @type lift . lift . lift
23:08:32 <lambdabot> forall (t :: (* -> *) -> * -> *) (t1 :: (* -> *) -> * -> *) (m :: * -> *) a (t2 :: (* -> *) -> * -> *). (Monad m, MonadTrans t2, Monad (t2 m), MonadTrans t1, Monad (t1 (t2 m)), MonadTrans t) => m a -
23:08:32 <lambdabot> > t (t1 (t2 m)) a
23:08:32 <dsrogers> so for mzero, I can write mzero = lift $ lift $ mzero
23:09:08 <dsrogers> mplus x y = (liftM2 liftM2 mplus) x y
23:09:15 <dsrogers> doesn't work.
23:09:58 <dsrogers> err, liftM2 $ liftM2 mplous
23:10:13 <dsrogers> so how do I pull plus up two monadT levels?
23:10:34 <Cheshire> let qed = fmap . flip (liftL2 modusPonens) >>= exFalsumQ
23:10:39 <dolio> There's no generic function for that.
23:10:52 <Olathe> @type liftL2
23:10:54 <lambdabot> Not in scope: `liftL2'
23:11:02 <dsrogers> is it possible to write?
23:11:46 <rwbarton> :t ((lift .) .) . ((lift .) .) $ mplus
23:11:48 <lambdabot> forall (t :: (* -> *) -> * -> *) (t1 :: (* -> *) -> * -> *) (m :: * -> *) a. (MonadPlus m, MonadTrans t1, Monad (t1 m), MonadTrans t) => m a -> m a -> t (t1 m) a
23:12:07 <pumpkin-> is there a name for foldl (>>=) ?
23:12:30 <Olathe> Hmm...
23:12:35 <Olathe> @src mapM
23:12:35 <lambdabot> mapM f as = sequence (map f as)
23:12:39 <Olathe> No.
23:12:43 <Olathe> Not that.
23:13:02 <dolio> Probably not, because it needs some kind of unlift to get appropriate 'm b' from a 't m b'.
23:13:05 <Olathe> @type foldl (>>=)
23:13:06 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
23:13:07 <dolio> Er, from a 't m a'.
23:13:14 <Olathe> @hoogle (Monad m) => m b -> [b -> m b] -> m b
23:13:15 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
23:13:15 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
23:13:15 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
23:13:19 <dolio> But the b depends on t and a.
23:13:39 <dolio> So there's no appropriate type schema.
23:13:56 <dolio> (It's actually probably worse than 'm b'.)
23:14:03 <Olathe> @hoogle (Monad m) => [b -> m b] -> m b
23:14:03 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
23:14:04 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
23:14:04 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
23:14:26 <pumpkin-> guess not :)
23:14:45 <Olathe> @src foldM
23:14:45 <lambdabot> foldM _ a []     = return a
23:14:45 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
23:14:56 <pumpkin-> oh
23:15:26 <pumpkin-> that seems like it could be massaged into it
23:15:36 <Olathe> It looks like a foldr.
23:16:17 <Olathe> @src foldr
23:16:17 <lambdabot> foldr f z []     = z
23:16:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:16:30 <dsrogers> rwbarton, not quite.  I want to convert m a -> m a -> m a to t1 (t m a) -> t1 (t m a) -> t1 (t m a)
23:16:35 <dolio> @type let f g m = State (\s -> g (runStateT m s))
23:16:36 <lambdabot> <no location info>:
23:16:36 <lambdabot>     not an expression: `let f g m = State (\s -> g (runStateT m s))'
23:16:37 <Olathe> @hoogle fold
23:16:37 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
23:16:38 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
23:16:38 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
23:16:40 <Olathe> @hoogle foldM
23:16:40 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
23:16:40 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
23:16:42 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
23:16:58 <dolio> @type let f g m = State (\s -> g (runStateT m s)) in f
23:16:59 <lambdabot> forall (m :: * -> *) a s a1. (m (a, s) -> (a1, s)) -> StateT s m a -> State s a1
23:17:03 <Olathe> @hoogle (b -> a -> m a) -> a -> [b] -> m a
23:17:03 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
23:17:03 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
23:17:03 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
23:17:11 <Olathe> @src foldrM
23:17:11 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:17:17 <dsrogers> actually I think I can get it from here.
23:17:24 <dolio> @type let f g m = ContT (\k -> g (runContT m k))
23:17:26 <lambdabot> <no location info>:
23:17:26 <lambdabot>     not an expression: `let f g m = ContT (\k -> g (runContT m k))'
23:17:27 <dsrogers> a little flip, a lift lift...
23:17:29 <dolio> @type let f g m = ContT (\k -> g (runContT m k)) in f
23:17:31 <lambdabot> forall (m :: * -> *) r a. (m r -> m r) -> ContT r m a -> ContT r m a
23:18:02 <Cheshire> all the cited papers I want to read are not available online :(
23:18:08 <dsrogers> hmm, maybe not...
23:18:21 <rwbarton> @src MonadTrans
23:18:21 <lambdabot> Source not found. I am sorry.
23:18:33 <rwbarton> , src ''MonadTrans
23:18:36 <lunabot>  luna: Not in scope: type constructor or class `MonadTrans'
23:18:46 <Olathe> With a flip flip flip and a lift lift lift. Here a flip there a flip everywhere a flip flip.
23:19:00 <ski_> @type Control.Monad.Cont.mapContT
23:19:02 <lambdabot> forall (m :: * -> *) r a. (m r -> m r) -> ContT r m a -> ContT r m a
23:19:30 <ski_> @type Control.Monad.State.mapStateT
23:19:31 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
23:21:03 <dolio> @type let f g m = StateT (\s -> do (a, s') <- runStateT m s ; b <- g (return a) ; return (b, s')) in f
23:21:05 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) t s. (Monad m1, Monad m) => (m a -> m1 t) -> StateT s m1 a -> StateT s m1 t
23:21:40 <dolio> Huh, wasn't expecting that.
23:21:43 <Cheshire> @go Implicit and noncomputational arguments using monads
23:21:45 <lambdabot> http://hal.archives-ouvertes.fr/hal-00150900/en/
23:21:45 <lambdabot> Title: HAL :: [hal-00150900, version 1] Implicit and noncomputational arguments using m ...
23:22:21 <dolio> Oh, I see.
23:23:20 <ski_> dolio : what're yer for ?
23:23:22 <rwbarton> MonadTrans doesn't seem to require that its argument be functorial
23:23:36 <ski_> nope
23:23:51 <ski_> there should be a class with a method
23:24:26 <ski_>   tmap :: forall m n a. (Monad m,Monad n) => (forall x. m x -> n x) -> (t m a -> t n a)
23:24:49 <rwbarton> ah right you need higher-order polymorphism
23:24:51 <Cheshire> really?
23:25:00 <Cheshire> how can you just go from one monad to another?
23:25:19 <ski_> Cheshire : see `runContT' and `runStateT' above
23:25:37 <ski_> those are instances of this (modulo the varying result type)
23:25:50 <Cheshire> oops I only noticed the a change to b in mapStateT
23:26:00 <ski_> er, `mapContT', `mapStateT', i meant
23:26:13 <rwbarton> mapContT didn't actually change the monad
23:26:20 <dolio> Yeah. That wasn't actually what was being asked for, though.
23:26:23 <Cheshire> I don't really understand it anyway
23:26:36 <rwbarton> probably because it can't I guess
23:26:37 <ski_> rwbarton : oh, you're right
23:26:51 <Cheshire> I suppose one such forall x. m x -> n x could be like   f (Left _) = Nothing ; f (Right r) = Just r
23:26:52 <ski_> yes, probably because it's invariant in `m'
23:27:03 <rwbarton> right
23:27:17 <dolio> Someone wanted 'lift1 :: (m a -> m b) -> t m a -> t m b' and 'lift2 :: (m a -> m b -> m c) -> (t m a -> t m b -> t m c)'
23:27:26 * ski_ wants
23:27:37 <dsrogers> I did.
23:27:39 <dolio> Right.
23:27:44 <dsrogers> and if someone presented it, I totally missed it.
23:28:10 <dolio> Not so far.
23:28:15 <ski_>   tbind :: forall m n a. (Monad m,Monad n) => t m a -> (forall a. m a -> t n a) -> t n a
23:28:23 <ski_> (that was what i wanted)
23:28:44 <rwbarton> t is a monad on monads?
23:28:49 <ski_> yes
23:29:09 <rwbarton> are the standard examples of monad transformers monads?
23:29:38 <ski_> iirc, when i looked at this last, i think some common ones weren't
23:29:46 <ski_> (i don't recall details, atm)
23:29:51 <pumpkin-> @hoogle exitWith
23:29:51 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
23:30:09 <mjrosenb> is it just me, or is there a race condition in the code that's given in the Control.Concurrent page?
23:30:21 <dolio> dsrogers: Well, I did it for StateT, but I'm not sure you can do it in general.
23:31:01 <dsrogers> ah.
23:31:05 <ski_> it might be nice with an iso-morphism between transformer and corresponding monads, too
23:31:17 <cjs> So it seems as if my leaks-on-amd64-but-not-on-i386 bug may be related to an IOVar I'm using.
23:31:32 <dolio> And it was sketchy to say the least.
23:31:53 <dsrogers> dolio, that works actually.  "do" the innermost action, lift up into the monad I want.
23:32:21 * ski_ wonders whether `ap' would be easier ..
23:33:18 <Cheshire> is [x:T]m good notation, for \(x::T)->m
23:33:19 <Cheshire> ?
23:33:25 <dolio> For instance, the lifting of mplus to state is: mplus s1 s2 = StateT $ \s -> runStateT s1 `mplus` runStateT s2
23:33:47 <dolio> Er, 'runStateT s1 s `mplus` runStateT s2 s'
23:34:05 * mjrosenb grumbles at the "sample code"
23:34:22 <dsrogers> my problem is that I have to unwrap two layers.
23:34:28 <cjs> Oh, weird! When I force evaluation of the thing in the IOVar (via tracing part of the value), the leak goes away when I'm not profiling, but is still there when I do a heap profile.
23:35:23 <dolio> @type \f m n -> StateT $ \s -> runStateT m s `f` runStateT n s
23:35:24 <lambdabot> forall s (m :: * -> *) a (m1 :: * -> *) a1 (m2 :: * -> *) a2. (m1 (a1, s) -> m2 (a2, s) -> m (a, s)) -> StateT s m1 a1 -> StateT s m2 a2 -> StateT s m a
23:35:24 <ski_> Cheshire : might be ..
23:35:54 <dolio> Clearly that doesn't generalize well to a type class.
23:36:00 <dsrogers> I think I really do have to just unwrap both layers, grab the monad plus I want and pack the layers back together.
23:36:22 <dolio> You should just write MonadPlus instances for each of the two transformers.
23:36:32 <ski_> dolio : are you trying to do `lift2' now ?
23:36:42 <dolio> @src ContT mplus
23:36:42 <lambdabot> Source not found.
23:37:17 <rwbarton> dolio: note how you haven't actually written lift2 at all
23:37:34 <mjrosenb> ok, is there anyone who thinks there aren't race conditions in http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Concurrent.html#11
23:37:38 <mjrosenb> ?
23:37:40 <rwbarton> (you've probably realized this long ago)
23:38:04 <dsrogers> dolio: I should put the instance of MonadPlus I want closer to the surface.  The issue here is that I'm combining ErrorT and MaybeT, and I want the 'mplus' behavior of MaybeT only
23:38:22 <dolio> Oh.
23:38:32 <dsrogers> yes.
23:38:47 <rwbarton> dsrogers: you can't by chance reorder those layers?
23:38:50 <dsrogers> I can.
23:38:56 <dsrogers> I can put MaybeT on the outside.
23:39:08 <dsrogers> or at least up one layer.
23:39:14 <dsrogers> outside of the ErrorT
23:40:12 <dsrogers> that will certainly make this a whole lot simplier.  Because then I can glue the MonadPlus layers on the way up.
23:40:21 <dsrogers> and I have to only unpack one layer at the top.
23:40:59 * mjrosenb thinks that more people would pay attention if he were to state the ordering of events he believes leads up to unfortunate events
23:41:17 <dsrogers> anyways, thanks...
23:41:20 <dsrogers> goodnight
23:41:57 <smitty1e> Wow.  I have just spent a couple of hours troubleshooting x::Double->Double and c=a*b, so the value of x c==x(a*b), but x a b differs by an order of magnitude.  I think there is an important point to be gleaned from this.
23:42:07 <hackage> Uploaded to hackage: blogination 0.1
23:43:00 <zloog> Stumped on the syntax necessary for doing writing a rnf strat on a data type using record syntax. Anyone know what it should look like?
23:43:04 <zloog> Stumped on the syntax necessary for doing writing a rnf strat on a data type using record syntax. Anyone know what it should look like?
23:43:28 <ski_>   forall m. Monad m => (forall w. Comonad w => m (w a) -> m (w b)) -> (t m a -> t m b)
23:44:56 <m0nkfish> smitty1e are you waiting for someone to ask you what the important point is
23:46:27 <Cheshire> @go what is the meaning of these constant interruptions
23:46:29 <lambdabot> http://www.cs.nott.ac.uk/~gmh/interrupts.pdf
23:46:29 <lambdabot> Title: What is the Meaning of These Constant Interruptions?
23:46:41 <Cheshire> best pun ...
23:46:43 <smitty1e> m0nkfish: not really.  Too exhausted.  Formulas with big exponents have to be treated with respect.
23:47:47 <Olathe> > 5**(1/0)
23:47:48 <lambdabot>   Infinity
23:47:53 <Olathe> > 0**(1/0)
23:47:55 <lambdabot>   0.0
23:48:00 <Olathe> > 1**(1/0)
23:48:02 <lambdabot>   1.0
23:48:20 <rwbarton> mjrosenb: the code looks plausible to me... what did you have in mind?
23:49:03 <rwbarton> > 0.5**(1/0)
23:49:04 <lambdabot>   0.0
23:49:45 <Olathe> > 1**(0/0)
23:49:47 <lambdabot>   1.0
23:49:49 <Olathe> Heh
23:49:54 <rwbarton> > 0/0
23:49:55 <lambdabot>   NaN
23:50:01 <Olathe> > 3**(0/0)
23:50:02 <lambdabot>   NaN
23:50:13 <Olathe> > (0/0)**(1/0)
23:50:14 <rwbarton> > 0^(0/0)
23:50:15 <lambdabot>   NaN
23:50:16 <lambdabot>   Add a type signature
23:50:19 <rwbarton> > 0**(0/0)
23:50:20 <lambdabot>   NaN
23:50:36 <Olathe> @src (**)
23:50:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:50:39 <rwbarton> > (0/0)**0
23:50:41 <lambdabot>   1.0
23:50:42 <Olathe> Lies.
23:51:16 <rwbarton> > 1**undefined
23:51:18 <lambdabot>   * Exception: Prelude.undefined
23:51:47 <Olathe> > (1::Double) ** undefined
23:51:48 <lambdabot>   * Exception: Prelude.undefined
23:52:10 <Olathe> @type (**)
23:52:12 <lambdabot> forall a. (Floating a) => a -> a -> a
23:52:39 <Olathe> > (-1)**(1/0)
23:52:41 <lambdabot>   1.0
23:52:55 <Olathe> Wow, always nice to know how that converges.
23:53:32 <Olathe> > 1/0 :: CReal
23:53:47 <lambdabot>   thread killed
23:54:14 <Olathe> > 0/0 :: CReal
23:54:29 <lambdabot>   thread killed
23:54:45 <rwbarton> > abs 0 :: CReal
23:54:47 <lambdabot>   0.0
23:55:29 <Olathe> > deriv
23:55:32 <lambdabot>       Overlapping instances for Show ((Dif a -> Dif b) -> a -> b)
23:55:32 <lambdabot>        aris...
23:55:40 <Olathe> > deriv abs x
23:55:42 <lambdabot>   signum x * 1
23:56:00 <Olathe> > deriv (/0) x
23:56:04 <lambdabot>   1 * recip 0
23:56:38 <rwbarton> > deriv (0**) x
23:56:41 <lambdabot>   log 0 * 1 * exp (log 0 * x)
23:56:42 <Olathe> > signum 0
23:56:44 <lambdabot>   0
23:56:49 <Olathe> O-o
23:56:53 <Olathe> > deriv abs 0
23:56:56 <lambdabot>   0
23:57:00 <Olathe> Eewww
23:57:42 <ski_> @hoogle Dif
23:57:42 <lambdabot> package Diff
23:57:42 <lambdabot> module Data.Array.Diff
23:57:42 <lambdabot> Data.Time.Clock.TAI diffAbsoluteTime :: AbsoluteTime -> AbsoluteTime -> DiffTime
23:58:24 <rwbarton> > deriv ((-1)**) x
23:58:26 <lambdabot>   log (negate 1) * 1 * exp (log (negate 1) * x)
23:59:11 <rwbarton> > deriv ((-1)**) 1 :: Complex Double
23:59:14 <lambdabot>   (-3.8473413874435795e-16) :+ 3.141592653589793
23:59:56 <ski_> > deriv (const undefined) 0
