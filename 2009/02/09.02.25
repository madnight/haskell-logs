00:00:31 <tippit> sumOn3 fst [(Just 7,Nothing),(Nothing, Nothing)]
00:00:32 <tippit> <interactive>:1:11:
00:00:32 <tippit>     Couldn't match expected type `(Maybe a, b)'
00:00:32 <tippit>            against inferred type `[a1]'
00:00:53 <tippit> ah
00:00:55 <tippit> map that
00:00:59 <tippit> fold it
00:02:36 <tippit> sumo pos xs = foldl (\x y -> x + (fromMaybe 0 . pos) y)
00:02:37 <tippit>               0 xs
00:02:43 <tippit> but listcomprehnsion nis cleaner
00:03:09 <Eridius> tippit: what are you trying to do?
00:03:11 <w0lter_> Cale: still have a question, dont understand the compile error. thanks  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1758#a1758
00:03:16 <glguy> sum . mapMaybe pos
00:03:24 <BMeph> sum . mayMaybe fst $ [(Just 7,Nothing),(Nothing, Nothing),(Just 3, Just 2)]
00:03:28 <BMeph> > sum . mayMaybe fst $ [(Just 7,Nothing),(Nothing, Nothing),(Just 3, Just 2)]
00:03:29 <lambdabot>   Not in scope: `mayMaybe'
00:03:37 <BMeph> > sum . mapMaybe fst $ [(Just 7,Nothing),(Nothing, Nothing),(Just 3, Just 2)]
00:03:38 <lambdabot>   10
00:03:43 <Eridius> w0lter_: digitToInt returns an Int, but loop is typed as returning an Integer
00:03:53 <Cale> w0lter_: I answered that one...
00:04:17 <Cale> w0lter_: You need fromIntegral to convert the Int which digitToInt gives into an Integer
00:04:19 <w0lter_> I see,
00:04:37 <Cale> So  acc' = acc * 10 + fromIntegral (digitToInt x)
00:05:18 <w0lter_> Cale: yes, this is exactly  what I want to learn.  :)
00:06:41 <w0lter_> Cale: now everythings works, I am realy green on Haskell
00:07:02 <Cale> w0lter_: That's okay, we were all there once :)
00:07:22 <w0lter_> thank you :)
00:21:50 <niet> i cant import a file in the same dir
00:21:53 <niet> whats up qith that?
00:24:34 <Alpounet> how are you tryin' to import it ?
00:25:16 <niet> import qualified Matrix as M
00:27:05 <Axman6> @hoodle MAtrix
00:27:05 <lambdabot> package matrix-market
00:27:05 <lambdabot> package hmatrix
00:27:10 <Axman6> @hoodle Matrix
00:27:10 <lambdabot> package matrix-market
00:27:10 <lambdabot> package hmatrix
00:27:15 <Axman6> bah
00:33:21 * Axman6 dances because he gets to play with a UltraSPARC T2 later this semester
00:33:59 <niet> i have my own matrix
00:34:07 <niet> i can enver get hmatrix to work
00:34:20 <niet> but i have my won matrix in the dir i have my other rogrma and ic ant import it
00:34:44 <fasta> niet: you made such a good joke and then you spoiled it for yourself ;)
00:36:05 <niet> ?
00:36:23 <fasta> How is min defined for Ints?
00:36:33 <fasta> (in GHC)
00:37:16 <fasta> niet: Axman6 was saying he gets to use an UltraSPARC, it seemed like you were saying that this was not interesting, since you had your own Matrix
00:37:39 <niet> min = head . sort ?
00:37:51 <Axman6> minimum*
00:41:02 <fasta> It seems they use a jump in the implementation, while it's not necessary to do so.
00:41:13 <olsner> fasta: instance Ord Int seems to be using the default implementation from Ord, i.e. if x <= y then x else y
00:42:11 <fasta> You can write the Haskell equivalent of : min 2dup or and and ;
00:42:43 <olsner> 2dup or and and?
00:42:57 <fasta> Forth
00:42:58 <Cale> forth
00:43:09 <olsner> yeah, but what does it *do*? :P
00:43:11 <niet> Possible cause: the monomorphism restriction applied to the following:
00:43:11 <niet>       mini :: [a] -> a
00:43:17 <niet> mini = head . L.sort
00:44:03 <ziman> @src minimum
00:44:03 <lambdabot> minimum [] = undefined
00:44:03 <lambdabot> minimum xs = foldl1 min xs
00:44:24 <ziman> @src min
00:44:24 <lambdabot> min x y = if x <= y then x else y
00:44:27 <BMeph> olsner: x .&. y .&. (x .|. y) :)
00:44:49 <fasta> @source min
00:44:49 <lambdabot> min not available
00:44:49 <Cale> x y -2dup-> x y x y -or-> x y (or x y) -and-> x (and y (or x y) -and-> and x (and y (or x y))
00:44:57 <olsner> and that actually calculates the minimum value of those two?
00:44:59 <niet> ah thats better O(n) instead of O(n log n) right?
00:45:29 <fasta> Where does @src get its source? GHC or the report?
00:45:35 <thoughtpolice> the report
00:45:36 <Cale> fasta: A bit of each.
00:45:40 <olsner> niet: depends on the sort used, some sort algorithms are O(n) if you only ask for the first element, I've heard
00:45:46 <Cale> fasta: But mostly the report.
00:47:02 <Axman6> > map log [1..]
00:47:03 <lambdabot>   [0.0,0.6931471805599453,1.0986122886681098,1.3862943611198906,1.60943791243...
00:48:01 <Cale> > exp 1
00:48:02 <lambdabot>   2.718281828459045
00:48:06 <Cale> > log (exp 1)
00:48:07 <lambdabot>   1.0
00:48:47 <Axman6> couldn't remember where log n got larger than 1
00:49:28 <niet> olsner: but then they ahve to be optimized for that right? the laziness cant fix that? it will first sort anyhow
00:49:51 <Cale> niet: It might only sort enough to get the first element
00:49:59 <Cale> niet: Which might take only O(n) time.
00:51:24 <Cale> niet: When you have head (sort xs), it's head which is applied first, because lazy evaluation is outermost first. head immediately pattern matches though, so sort xs has to be evaluated at least enough to decide if the result matches (y:ys)
00:51:59 <Cale> What happens from there depends on the sort algorithm in question, but some are able to get the first element quickly.
00:54:30 <opqdonut> hmm, mergesort doesn't handle getting the first element that well?
00:55:23 <olsner> fasta: was that forth trick supposed to produce the minimum value?
00:55:49 <fasta> olsner: yes, doesn't it?
00:56:45 <olsner> > 2 .&. 49801 .&. (2 .|. 49801)
00:56:46 <lambdabot>       Ambiguous occurrence `.&.'
00:56:46 <lambdabot>      It could refer to either `Data.Bits..&....
00:57:07 <niet> http://www.haskell.org/pipermail/haskell-cafe/2007-July/029477.html
00:57:07 <olsner> > let (.&.) = (Data.Bits..&.) in 2 .&. 49801 .&. (2 .|. 49801)
00:57:08 <lambdabot>   Add a type signature
00:57:19 <olsner> > let (.&.) = (Data.Bits..&.) in 2 .&. 49801 .&. (2 .|. 49801) :: Word16
00:57:20 <lambdabot>   0
00:57:28 <niet> can someone explain to me what the hell is the difference between these 2 powerList definitions? http://www.haskell.org/pipermail/haskell-cafe/2007-July/029477.html
00:58:00 <niet> ah wait
00:58:48 <opqdonut> niet: the first one does powerList only once, the second twice
00:59:33 <Peaker> niet, naming values shares/keeps the computed result for all the uses of the name. A function call is not memoised automatically (each time you use "f x" it will recompute the result)
01:00:30 <niet> yes i got it
01:00:42 <niet> but how can it be mroe spacefficent(the 2nd one)?
01:00:49 <opqdonut> the "lazy invariant" is "every named value is evaluated at most once"
01:01:21 <opqdonut> niet: by not keeping the powerList xs value "alive"
01:01:23 <opqdonut> i think
01:01:29 <opqdonut> it can be garbage collected
01:02:11 <Peaker> niet, its recomputed on-need, instead of being stored/cached in space
01:02:40 <Peaker> niet, trading off space for computation or vice-versa. However if something is very cheap to compute, its unclear that reading it from space/cache is faster than recomputing it at all
01:34:16 <NameAlreadyInUse> does anyone know if newLISP is worth learning/looking in to?
01:37:19 <Peaker> "In newLISP, all variables are dynamically scoped by default. However, by defining a function in its own context, static/lexical scoping can be achieved and variable capture can be avoided in fexpr's." <-- this sounds terrible
01:37:30 <Peaker> this isn't the 60's, "dynamic scoping" should not be a default
01:38:09 <NameAlreadyInUse> yeah i just finished reading the FAQ and wasn't enticed by the idea of dynamic scoping
01:38:22 <niet> how would you define when?
01:38:29 <niet> when p a = if p then a else 1
01:38:49 <niet> actually that only makes sense in a do in haskell
01:38:52 <Peaker> IMO: A new functional language which embeds side effects in evaluation is probably not that interesting
01:39:03 <opqdonut> ?src when
01:39:03 <lambdabot> when p s = if p then s else return ()
01:39:09 <opqdonut> also
01:39:11 <opqdonut> ?src guard
01:39:11 <lambdabot> guard True  =  return ()
01:39:11 <lambdabot> guard False =  mzero
01:39:16 <niet> embeds side effects in evaluation, what doe sthta even mean?
01:39:19 <quicksilver> niet: what you wrote makes sense in a non-do context.
01:39:27 <quicksilver> niet: but of course, only in a numeric context
01:39:33 <quicksilver> (since you wrote "1")
01:39:37 <Peaker> when True = id ; when False = const . return $ ()
01:39:51 <Peaker> (for similarity to guard)
01:42:44 <NameAlreadyInUse> Peaker: you are probably right about newLISP. do you know of any general purpose lisp dialects (other than CL and scheme) that might be worth learning?
01:42:53 <niet> well the 1 isnt suppose be ther
01:42:54 <niet> ereally
01:43:04 <NameAlreadyInUse> i like the look of Clojure but am not keen on JVM languages
01:43:06 <niet> NameAlreadyInUse: CLojure
01:43:38 <Peaker> NameAlreadyInUse, don't know any I find very interesting, but there probably are
01:45:30 <quicksilver> niet: indeed, if it isn't there it doesn't make sense ;)
01:45:39 <quicksilver> and see the "when" from the standard lib, as shown by opqdonut
01:49:26 <basvandijk> Any haskell emacs mode user out there? I have a little problem with it. When I'm in the inf-haskell mode (C-c C-l) and I evaluate an expression, 1+1 for example, A new line appears with the following output: 1+1^J2. I was expecting to only get the answer. It seems ^J is some kind of control character.
01:49:39 <Peaker> I think if "subclass" relationship in Haskell was split to these relationships: 1) This class depends on that class for laws or implementation of methods 2) This class is a superset of that class's expressiveness - and here's proof   -- then the relationship 2 can be independently specified
01:50:12 <Peaker> But how do we solve the overlapping instances that result?  I guess one of the overlaps in this case should just be consistently chosen and the other ignored (perhaps with a warning)
01:50:39 <niet> are there some modules to load images into matrices?
01:51:09 <niet> how can I read an image? can I read it in binary then get its size and for each newline I know ok that was one row ro something?
02:03:15 <niet> "\255\216\255\224\NUL\DLEJFIF\NUL\SOH\STX\NUL\NULd\NULd\NUL\NUL\255\236\NUL\DC1Ducky\NUL\SOH\NUL\EOT\NUL\NUL\NUL\RS\NUL\NUL\255\238\NUL\SOAdobe\NULd\192\NUL\NUL\NUL\SOH\255\219\NUL\132\NUL\DLE\v\v\v\f\v\DLE\f\f\DLE\ETB\SI\r\SI\ETB\ESC\DC4\DLE\DLE\DC4\ESC\US\ETB\ETB\ETB\E
02:03:22 <niet> ok thats an image
02:03:32 <acieroid> hum
02:03:33 <niet> how do I know where a row is?
02:03:46 <acieroid> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1764#a1764
02:03:52 <acieroid> is that normal ?
02:03:55 <niet> i want to turn it into a matrix
02:06:04 <doserj> > 82^7
02:06:05 <lambdabot>   24928547056768
02:06:08 <doserj> > 82^7::Int
02:06:10 <lambdabot>   24928547056768
02:06:21 * doserj sighs
02:06:29 <doserj> acieroid: are you on a 32bit system?
02:07:11 <doserj> > 82^7::Int32
02:07:12 <lambdabot>   556870784
02:07:49 <acieroid> yes doserj
02:07:51 <doserj> @type ord
02:07:52 <lambdabot> Char -> Int
02:08:23 <doserj> 82^7 defaults to Integer, but ord returns an Int. So you do the two calculations at different types
02:08:46 <maxote> > 82*82*82*82*82*82*82
02:08:47 <lambdabot>   24928547056768
02:09:40 <niet> im trying to split a bytestring at \ so i use \\ but it doesnt split
02:10:03 <niet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1765#a1765
02:10:44 <acieroid> ok doserj
02:11:18 <acieroid> so, how can I have a good result ? :-/
02:13:54 <niet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1765#a1765
02:13:56 <niet> im trying to split a bytestring at \ so i use \\ but it doesnt split
02:15:25 <niet> it doesnt split at anything
02:15:25 <niet> why+
02:15:37 <doserj> acieroid: you can use toInteger . ord
02:16:08 <acieroid> ok
02:17:54 <yitz> niet: there is no '\\' in your test string. It has forward slashes '/'.
02:18:45 <doserj> niet: why don't you use Data.ByteString.readFile?
02:21:55 <tippit> i do now, it still doesnt split the damn string, not at any char, why not?
02:22:33 <tippit> im niet btw
02:27:28 <tippit> *Homology> B.split '\255' $ B.pack "\255\216"
02:27:28 <tippit> ["","\216"]
02:28:09 <yitz> @type B.split
02:28:10 <lambdabot> Couldn't find qualified module.
02:28:20 <yitz> @type Data.ByteString.split
02:28:21 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
02:28:31 <yitz> ah BSC here. ok
02:29:01 <yitz> > BSC.split '\\' $ BSC.pack "foo\bar"
02:29:02 <lambdabot>   /tmp/3672561510340275891:70:32: Not in scope: `BSC.split'/tmp/3672561510340...
02:29:33 <yitz> > Data.ByteString.split '\\' $ Data.ByteString.pack "foo\bar"
02:29:34 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
02:29:40 <doserj> yitz: you have to use ByteString.Char8 for that
02:30:07 <tippit> anyone know what delimits a row in an .jpg - file? if there is such a thing
02:30:11 <yitz> > Data.ByteString.split (fromEnum '\\') $ Data.ByteString.pack "foo\bar"
02:30:12 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Int'
02:30:28 <yitz> > Data.ByteString.split (fromIntegral $ fromEnum '\\') $ Data.ByteString.pack "foo\bar"
02:30:29 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
02:30:33 <doserj> > Data.ByteString.Char8.split '\\' $ Data.ByteString.Char8.pack "foo\bar"
02:30:34 <lambdabot>   ["foo\bar"]
02:30:38 <doserj> > Data.ByteString.Char8.split '\\' $ Data.ByteString.Char8.pack "foo\\bar"
02:30:40 <lambdabot>   ["foo","bar"]
02:31:17 <yitz> @type Data.ByteString.split
02:31:18 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
02:31:32 <yitz> > Data.ByteString.split (fromIntegral $ fromEnum '\\' :: Word8) $ Data.ByteString.pack "foo\bar"
02:31:34 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
02:31:47 <yitz> @type Data.ByteString.pack
02:31:48 <lambdabot> [Word8] -> BSC.ByteString
02:31:51 <yitz> ah
02:32:52 <yitz> > Data.ByteString.split (fromIntegral . fromEnum $ '\\') . Data.ByteString.pack . map (fromIntegral . fromEnum) $ "foo\\bar"
02:32:54 <lambdabot>   ["foo","bar"]
02:36:58 <yitz> tippit: jpg is a compressed format. convert it to pnm first to make things really easy for yourself. or use an image library binding, like ImageMagick.
02:39:55 <yitz> tippit: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stb-image
02:45:51 <cajun-rat> A haskell style question: I'm trying to handle a datastructure that is similar in spirit to an expression language.  Either I could represent this as a normal algebraic datatype, and write explicit code to traverse it, or I could represent it 'as it's fold' and represent it as a function that takes reduction function and applies it.  They are pretty much equivalent, but which is considered better style?  This is basically the quest
02:46:35 <yitz> tippit: http://www.haskell.org/pipermail/haskell/2007-October/019939.html
02:47:08 <Botje> cajun-rat: instead of writing explicit code to traverse it  you could use something like Uniplate
02:51:04 <cajun-rat> thanks, I'll take a read of that
03:04:01 <fasta> cajun-rat: or just not use a static language to do this, since you are bound to hit something which is not easily expressible in one.
03:04:48 <fasta> cajun-rat: compare programs written in a language called Stratego and written in Haskell which both transform source code.
03:05:57 <whpearson> Is there no standard function that generates all possible combinations of two lists?  E.g. [1,4] * [1,4] = [(1,1), (1,4), (4,1), (4,4)]
03:06:34 <opqdonut> > liftM2 (,) [1,4] [2,3]
03:06:35 <lambdabot>   [(1,2),(1,3),(4,2),(4,3)]
03:06:40 <opqdonut> the list monad
03:06:54 <pejo> fasta, so far he's only been talking about traversing a structure.
03:07:49 <|Lupin|> hello, everybody.
03:07:58 <osfameron> whpearson: or using list comprehension syntax: [(x,y) | x<-[1,4], y<-[2,3]
03:08:01 <|Lupin|> Just a cultural question for the community.
03:08:06 <osfameron> er, missing closing ]
03:08:11 <fasta> pejo:  "in spirit to an expression language", AFAIK he is talking about generic traversals. Generic traversals still are ugly in Haskell, imho.
03:08:20 <whpearson> opqdonut: Hmm, okay. I just wanted to talk about that operation when explaining a maths concept. I'd hoped it would have a common name.
03:08:35 <|Lupin|> I just heard about design patterns which are, if I understood it correctly, rather object oriented.
03:08:41 <opqdonut> whpearson: yeah it doesn't, some people call it "cross" tho
03:08:51 <|Lupin|> I'm wondering if there exists an equivalent in the world of functional programming ?
03:09:16 <opqdonut> |Lupin|: catamorphisms (folds) are a design pattern, monads and functors are design patterns
03:09:18 <osfameron> well, patterns are just patterns
03:09:19 <pejo> fasta, he hasn't mentioned generic traversals, he was asking how to traverse a specific structure.
03:09:30 <opqdonut> (or rather, can be viewed as such)
03:09:54 <whpearson> opqdonut: Thanks.
03:11:26 <|Lupin|> well... I'm rather looking for something saying: "if you have this software developent problem, you can solve it with this approach", which is what design paterns try to do, if my understanding is correct. But they do it in the context of OO programming, whereas I'd rather have something in functional programming
03:12:49 <osfameron> a real software development patterns book would be more about things like "Use version control" and "Name your variables well", with maybe antipatterns like "Big ball of mud" and "Ghetto"
03:13:00 <pejo> Lupin, there's nothing remotely of the same status for fp as the GoF book for OO.
03:13:03 <osfameron> at least "real" as in "more similar to the Christopher Alexander inspiration"
03:16:17 <tippit> is ImageMagick a haskell library?
03:16:45 <yitz> tippit: http://www.haskell.org/pipermail/haskell/2007-October/019939.html
03:17:10 <yitz> tippit: so - maybe.
03:17:42 <yitz> tippit: if not, you would be greatly blessed if you would make it so.
03:18:38 <doserj> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsmagick
03:18:59 <|Lupin|> okay guys, thanks a lot for your replies.
03:19:13 <yitz> doserj: oh! i didn't find that when i searched - because the name omits "image" :)
03:20:15 <doserj> yitz: it's a binding to graphicsmagick, not imagemagick :)
03:21:21 <yitz> |Lupin|: while there is certainly a lot of room for a broader and deeper literature on fp techniques for the practitioner, I don't think it will take the format of "design patterns".
03:24:14 <osfameron> though if the masses of OO programmers acutally like the "design patterns" expositional style (I found it mainly useless) then it might be a useful approach to teach the strange new FP stuff in a familiar style
03:24:47 <yitz> |Lupin|: oo leaves a lot more room for muddled thinking. in fp, once you have correctly understood your problem space the solution techniques are usually more straightforward.
03:26:25 <niet> where does haskell want to install packages on windows? i cant figure out how to get permission because i dont know where it is. windows is so retarded in some ways.
03:26:55 <Botje> design patterns mostly exist to work around the lack of lambdas in C++
03:27:13 <yitz> niet: are you on vista? i heard there are some problems with that there.
03:27:46 <yitz> niet: your split personality is making me a little dizzy
03:28:45 <lilac> isn't "use a monad to capture global state" a Haskell design pattern?
03:29:15 <lilac> although i suppose that's a special case of the more general haskell design pattern "forall a. use monads for a"
03:29:26 <Botje> grin
03:29:30 <lilac> of course, that's not legal haskell'98
03:29:45 <Botje> the haskell design pattern book: "use monads. that is all"
03:30:03 <pejo> Is it just my impression or has design patterns had a huge impact on software practitioners?
03:30:27 <lilac> {-# LANGUAGE ExistentialQuantification #-} forall a. Problem a => use monads for a
03:31:34 <Botje> pejo: not huge enough, they're still alive :(
03:31:36 <yitz> lilac: well you've no choice but to pass state along in function parameters. I guess the choice of whether to express that monadically could be considered a "design pattern", but it isn't nearly as much of a fundamental design decision as are the typical oo design patterns.
03:32:34 <yitz> pejo: i remember when the book first came out. when i held it in my hands for the first time, i felt like i was transformed.
03:33:20 <basvandijk> > let e = "ë"
03:33:21 <lambdabot>   <no location info>: parse error on input `;'
03:34:10 <basvandijk> > "ë"
03:34:11 <Botje> > let (<) 3 = "♥" in (<3)
03:34:12 <lambdabot>   "\235"
03:34:12 <lambdabot>   Couldn't match expected type `t1 -> t'
03:36:05 <basvandijk> > putStrLn "ë"
03:36:06 <lambdabot>   * Exception: "<IO ()>"
03:38:47 <niet> yitz/lupin: that quote is so good, exactly how i see it. OO is obfuscation, functional programming si clarity. OO (and espiecally those horrible design books that remind me more of self-help books and healing than rigorous advice) is to programming what astrology is to astronomy
03:39:32 <yitz> niet: thanks. but I wouldn't go quite that far :)
03:39:34 <Workybob> > let (<) 3 = text "♥" in (<3)
03:39:35 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `Doc'
03:47:32 <haraldk> > print "⚓"
03:47:33 <lambdabot>   <no location info>:
03:47:33 <lambdabot>      lexical error in string/character literal at chara...
03:53:02 <niet> why is perl.exe in /ghc/?
03:53:12 <haraldk> > print "™"
03:53:13 <lambdabot>   * Exception: "<IO ()>"
03:54:09 <sjanssen> niet: the Evil Mangler is written in Perl
03:54:42 <jtxx000> If I have a tree and a recursive function f which traverses the tree and computes some value, then is there an easy way to have a function g which uses f at each level of the tree without having g be O(n^2)?
03:55:03 <haraldk> I thought the Evil Mangler was no longer in use
03:55:06 <jtxx000> something like this:
03:55:06 <jtxx000> data T = B T T | L Integer
03:55:06 <jtxx000> f (L x)   = x
03:55:06 <jtxx000> f (B x y) = f x + f y
03:55:06 <jtxx000> g (L x)   = x
03:55:07 <jtxx000> g (B x y) = f (B x y) * g x * g y
03:56:30 <sjanssen> jtxx000: yes, this can be done
03:56:50 <jtxx000> easily?
03:57:16 <jtxx000> one way would be to combine the two and have g return a tuple at each level, but this feels like a kludge
03:57:32 <sjanssen> jtxx000: yes, that is what I would suggest
03:58:17 <pejo> haraldk, I don't think they've phased it out yet.
03:59:47 <jtxx000> sjanssen: but if somewhere else you wanted to use f without g, it would still have to find both (well maybe not due to laziness, but it still feels like a hack)
03:59:55 <lilac> yitz: i'd say that using monads is /more/ fundamental than a lot of OO patterns. visitor pattern? that's pattern matching confused with folds. singleton? that's a monad, only worse. factory pattern? just a function. prototype? haskell records. composite, decorator, flyweight, facade, proxy, null object, template method: still patterns in haskell.
04:00:13 <lilac> yitz: threading a monad through your code is a significantly bigger change than most patterns are in haskell
04:00:21 <sjanssen> jtxx000: another option is to allow annotations on the branches of your tree
04:00:42 <sjanssen> jtxx000: data T a = B a T T | L Integer
04:01:13 <sjanssen> jtxx000: f becomes a function that decorates a tree, and g is a consumer of an f-decorated tree
04:02:12 <jtxx000> sjanssen: yep, although then other functions which just want a normal tree have to deal with the annotations
04:02:35 <yitz> lilac: true, non-monad => monad can be a big change in terms of LOC changed. but the underlying design is really the same.
04:02:41 <niet> what is the evil mangler?
04:02:51 * yitz shudders
04:03:15 <lilac> yitz: explicit casting => visitor pattern can be a big change in LOC but the underlying design is really the same
04:03:19 <sjanssen> niet: it takes the assembly output of GCC and transforms it in various ways
04:04:00 <yitz> niet: using *perl*
04:04:01 <fasta> Most big programs converge to use monads, in my experience. It's the same with tuples which converge to data declarations eventually.
04:04:43 <osfameron> is it superceded by the glorious wrangler (written in haskell) yet?
04:04:48 <osfameron> s/wr/m/
04:05:01 <jtxx000> sjanssen: i suppose i'll just create a new data type for the decorated tree or something... thanks for the help!
04:05:04 <sjanssen> osfameron: it is on its way out, yes
04:05:17 <osfameron> fair enough
04:05:31 <osfameron> it's nice that haskell and perl are mutually boot-strapping :-)
04:05:32 <yitz> sjanssen: isn't it already gone in 6.10?
04:05:38 <haraldk> > putStrLn "☺"
04:05:40 <lambdabot>   * Exception: "<IO ()>"
04:05:48 <sjanssen> as -fvia-c is deprecated in favor of the native code gen
04:05:59 <sjanssen> yitz: hmm, I thought it was still around.  I'm not sure
04:06:00 <yitz> osfameron: :)
04:06:02 <niet> I have a question about the Curry-Howard-correspondence. If I write a program that can take a table/matrix of an image and then I have bunch of images that I process that way to group them by homology. Can I prove that way some theorem of homology? Is a working algorithm a theorem?
04:07:22 <haraldk> > putStrLn "⚓"
04:07:23 <lambdabot>   <no location info>:
04:07:23 <lambdabot>      lexical error in string/character literal at chara...
04:08:12 <haraldk> I don't understand the unpredictable responses lambdabot (and ghci) gives to unicode literals
04:08:26 <haraldk> I thought unicode source files was supposed to be the norm?
04:09:06 <yitz> haraldk: what is that character?
04:09:59 <haraldk> ⚓ is an unicode anchor symbol
04:10:03 <sjanssen> haraldk: lambdabot's situation is a bit more complicated, as it goes through two different Haskell parsers
04:10:09 <fasta> niet: the type of your program is all your program proves. And, that doesn't say anything in Haskell, because of undefined.
04:10:24 <haraldk> yeah, I understand that, don't really expect lambdabot to handle it
04:10:34 <haraldk> that ghci and ghc gives different results, though...
04:11:00 <haraldk> they even give different results for different characters
04:11:36 <haraldk> print "™" gives "\8482" (that's a trademark symbol)
04:11:53 <haraldk> but printing the anchor symbol gives an exception
04:11:55 <haraldk> this is in ghci
04:12:14 <sjanssen> haraldk: what sort of exception?
04:12:58 <haraldk> lexical error in string/character literal at character '\9875'
04:15:36 <haraldk> actually ghci and ghc give same error, my fault
04:15:42 <haraldk> errors
04:16:29 <haraldk> they both give exception for the anchor symbol and print the wrong character for the tm symbol
04:17:20 <SamB> what's the anchor symbol ?
04:18:02 <haraldk> SamB: Can you see this correctly? ⚓
04:18:07 <SamB> yeah
04:18:08 <yitz> haraldk: is 9875 the correct unicode value for the anchor symbol?
04:18:20 <yitz> haraldk: I don't see it.
04:18:21 <sjanssen> haraldk: print uses show, which will display all characters outside ASCII as escapes
04:18:33 <SamB> yitz: no
04:18:59 <SamB> U+2122 TRADE MARK SIGN
04:19:05 <SamB> U+2693 ANCHOR
04:19:10 <SamB> U+8482 CJK UNIFIED IDEOGRAPH-8482
04:19:14 <haraldk> yitz: Yes, in decimal. usually it's in hex, though, 2693
04:19:15 <SamB> U+9875 CJK UNIFIED IDEOGRAPH-9875
04:19:30 <SamB> oh, right
04:19:41 <sjanssen> haraldk: putStrLn will give the wrong result because the IO functions only pay attention to the lowest 8 bits of any character
04:19:48 <SamB> those are the right codepoints in decimal
04:19:53 <int-e> yitz: 0x2693 = 9875 the correct unicode value for the anchor
04:19:54 <int-e>   symbol?
04:20:04 <int-e> yitz: woops, copied too much. anyway, yes.
04:20:22 <Botje> all the fun characters are in 0x26XX
04:20:26 <sjanssen> ie. print "™" -> "\8482" is correct behavior
04:20:28 <SamB> so disregard he IDEOGRAPH codepoints ;-P
04:20:34 <yitz> > foldl' (\x y->x*16+y) 0 . map digitToInt $ "2693"
04:20:35 <lambdabot>   9875
04:20:48 <haraldk> but can print "⚓" -> exception be correct?
04:20:50 <int-e> > read "0x2693"
04:20:51 <lambdabot>   * Exception: Prelude.read: no parse
04:21:01 <int-e> > 0x2693
04:21:02 <lambdabot>   9875
04:21:26 <yitz> heh, right
04:21:40 <sjanssen> haraldk: something funny is going on there
04:21:43 <yitz> > "\9875"
04:21:45 <lambdabot>   "\9875"
04:22:15 <haraldk> happens both in ghci and when compiled. My shell is unicode, naturally
04:23:06 <lambdapants> what are the name of the exceptions that are raised by "read" and "head", respectively, speaking form a Control.Exception point of view.
04:23:08 <lambdapants> ?
04:23:39 <sjanssen> lambdapants: they're both the same sort of exception, ErrorException or whatever its called
04:23:49 <lambdapants> I think I see it - ErrorCall
04:23:59 <lambdapants> thankyou
04:25:17 <quicksilver> sjanssen: you forgot to add "Any attempt to catch the ErrorCall exception will leave your soul in mortal peril" ;)
04:26:19 <haraldk> if putStrLn doesn't print unicode characters at all, what should I use?
04:26:36 <sjanssen> haraldk: utf8-string on hackage
04:26:51 <sjanssen> or the next major version of GHC, which doesn't actually exist yet :)
04:26:59 * sjanssen is so happy this is finally getting fixed
04:28:39 <ivanm> sjanssen: is it even a twinkle in SPJ's eye yet? :p
04:29:17 <sjanssen> ivanm: well, Simon Marlow has posted the initial implementation of the encoding stuff on the mailing list
04:29:32 <ivanm> dammit, there goes my feeble attempt at humour :@
04:29:33 <ivanm> ;-)
04:30:06 <jeltsch> Hello, does anyone know about conventions of community.haskell.org project names? Is the project name used directly as a UNIX group name or is it intended solely for humans?
04:30:12 <ivanm> EvilTerran: what, had enough of ranting?
04:30:18 <ivanm> jeltsch: human
04:30:24 <ivanm> though spaces are probably a bad idea...
04:30:40 <jeltsch> How is project access handled? Via UNIX groups?
04:30:47 <cajun-rat> putStrln would have to know the Unicode encoding to use
04:30:48 <sjanssen> jeltsch: the name is used as a UNIX group, yes
04:31:07 <sjanssen> jeltsch: actually, the name appended with -p
04:31:21 <cajun-rat> which _could_ be Utf-8, or Utf-16, or whatever
04:31:24 <jeltsch> sjanssen: So if I start my project name with an uppercase letter, the UNIX group also starts with an uppercase letter?
04:31:35 <sjanssen> jeltsch: yes
04:31:43 <niet> how do I use try? a <- E.try (readFile "C:/users/saftarn/desktop/datasets/goodemails.txt")
04:32:01 <cajun-rat> i just consider it 'Lazy-8' which, drops the top bits
04:32:01 <sjanssen> jeltsch: all your URLs will use the same spelling too
04:32:18 <jeltsch> sjanssen: Is the group name used at other places than URLs and UNIX groups?
04:32:39 <ivanm> jeltsch: it is typically the same as the project name
04:33:05 <cajun-rat> logically, you have to pick an encoding and convert it, i.e. utf8-string or another library
04:33:14 <ivanm> so you'd use it in your .cabal file, etc.
04:33:14 <jeltsch> ivanm: What is the same as the project name?
04:34:10 <ivanm> your group/url name
04:34:46 <jeltsch> Okay, I use lowercase only. I don’t like URLs and UNIX group names with uppercase letters.
04:35:00 <ivanm> *shrug* most do the same...
04:35:17 <yitz> haraldk: I think there must be an error in your haskell source file. I'm able to load a string containing ANCHOR with no problem.
04:35:18 <sjanssen> jeltsch: \projectname -> Project { unixgroup = projectname ++ "p", codedir = "/srv/code/" ++ projectname, codeurl = "http://code.haskell.org/" ++ projectname }
04:35:30 <yitz> haraldk: is your source file in UTF-8?
04:35:40 <ivanm> my stuff on Hackage is capitalised mainly because I was writing it as an academic piece of software, and it's bad enough when my supervisor doesn't like haskell... ;-)
04:35:47 <sjanssen> haraldk: I can reproduce this with GHC 6.8.2, by the way
04:36:00 <ivanm> sjanssen: why ++ "p" for the group name?
04:36:09 <sjanssen> ivanm: that's what they do
04:36:14 <ivanm> to distinguish projects from users?
04:36:14 <sjanssen> and actually, its "-p"
04:36:23 <yitz> haraldk: I created my test file like this: writeFile"TestAnchor.hs" "module TestAnchor where anchor=\34\226\154\147\34"
04:36:36 <yitz> haraldk: then :load TestAnchor
04:36:40 <SamB> just to confuse lispers ;-P
04:36:56 <yitz> haraldk: then anchor prints as "\9875"
04:37:51 <sjanssen> yitz: what version of GHC do you have?
04:38:20 <yitz> The Glorious Glasgow Haskell Compilation System, version 6.10.1
04:38:30 <sjanssen> haraldk: using GHC 6.8?
04:38:40 <haraldk> yitz: yes, source in utf8
04:38:57 <haraldk> sjanssen: 6.8.2
04:38:59 <jeltsch> ++ "-p" is probably necessary for UNIX groups to distinguish project groups from other groups. What if a user creates a project named "news" or "sudo"?
04:39:48 <yitz> sjanssen, haraldk: ok, I have 6.8.2 on my other machine, and I also confirm the problem.
04:39:53 <sjanssen> haraldk: looks like a bug, which is apparently fixed in 6.10
04:40:11 <jeltsch> Is the SSH fingerprint of community.haskell.org published somewhere?
04:41:06 <niet> how do I use try? a <- E.try (readFile "C:/users/saftarn/desktop/datasets/goodemails.txt")
04:41:37 <yitz> jeltsch: RSA key fingerprint is 61:fb:46:e2:c8:c0:05:84:e5:6f:b4:f3:fa:73:97:bf.
04:41:44 <jeltsch> yitz: ThankS!
04:41:56 <Adam1213> you do realise this is plain text :)
04:42:03 <yitz> jeltsch: it's now published in today's #haskell logs :)
04:42:24 <jeltsch> niet: I thing that the lazy reading functions don’t throw any exceptions.
04:42:40 <jeltsch> niet: The problem is that they immediately return, so they could only throw exceptions immediately.
04:43:07 <jeltsch> niet: The actual reading is triggered by later reduction (evaluation of their result).
04:43:26 <jeltsch> niet: I think, this is documented in the Haskell Report.
04:43:44 <quicksilver> jeltsch: they do throw exceptions, they just do so asynchronously
04:43:47 <quicksilver> which is unlikely to be useful.
04:44:07 <fasta> yitz: you do understand that it is completely pointless to verify in this way, right?
04:44:11 <quicksilver> I would avoid using the prelude readFile if you think an exception is likely.
04:44:18 <jeltsch> quicksilver: Are you sure???
04:44:29 <quicksilver> jeltsch: Yes.
04:44:44 <quicksilver> jeltsch: you get your exception buried in the data, as you force
04:44:52 <its_me> Anyone know which room / server unsw cse people would be on
04:44:53 <quicksilver> it occurs in the point in the data that the suspended IO operation threw it
04:45:01 <jeltsch> quicksilver: Buried in the data? As _|_?
04:45:12 <quicksilver> Yes.
04:45:16 <quicksilver> Haskell exceptions are _|_.
04:45:29 <niet> well readFile does result in an exception if the file doesnt exist, how do I catch it ?
04:45:30 <jeltsch> quicksilver: Not really, I’d say.
04:45:42 <yitz> fasta: it's really only pointful to verify by speaking on the phone with someone physically located next to the machine who reads off the fingerprint from the console.
04:45:58 <jeltsch> quicksilver: It is different to throw an exception compared to returning _|_.
04:46:00 <fasta> yitz: even the phone can be faked :)
04:46:16 <yitz> fasta: and the console can be rootkitted :)
04:46:19 <fasta> yitz: and in general, I don't think encryption in general works ;)
04:46:29 <quicksilver> jeltsch: exceptions are one kind of _|_
04:46:33 <niet> *** Exception: C:/users/saftarn/desktop/datasets/goodemails.txta: openFile: does not exist (No such file or directory)
04:46:37 <quicksilver> jeltsch: they are not the only kind of exception.
04:46:46 <quicksilver> jeltsch: sorry, I mean they are no the only kind of _|_
04:46:55 <quicksilver> jeltsch: _|_ can represent non-termination or exception.
04:46:57 <fasta> yitz: but >99.99 % of all computer scientists disagree; they obviously should read more on the subject.
04:47:05 <yitz> fasta: oh, that's the thing, usually it does work, even when you're not as paranoid as you ought to be. works, that is, is useful for something
04:47:07 <niet> why doesnt readFile return a maybe?
04:47:24 <ivanm> niet: because you're meant to catch the error
04:47:25 <quicksilver> because it was designed to throw an exception.
04:47:26 <jeltsch> quicksilver: Returning _|_ is likely to be what Haskell 98 says. GHC can encode exceptions in _|_. So “exceptional values“ are a special kind of _|_. Haskell 98 just says _|_, GHC returns a specific _|_ (an exception _|_).
04:47:44 <Feuerbach> What is gtksourceview2? I don't see it on hackage
04:47:45 <fasta> yitz: yes, in practice it appears to work fine, I just don't believe in the cryptographic assumptions people make.
04:47:48 <niet> yeah so how do I catch it?
04:47:51 <ivanm> jeltsch: actually, ghc implements _|_ as an exception ;-)
04:47:54 <ivanm> @hoogle try
04:47:54 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
04:47:54 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
04:47:54 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
04:47:58 <ivanm> @hoogle catch
04:47:58 <lambdabot> package catch
04:47:58 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
04:47:58 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
04:48:02 <niet> fasta: why not? they are pretty mathematically solid
04:48:03 <yitz> fasta: http://xkcd.com/538/
04:48:05 <jeltsch> quicksilver: But it’s a difference to say "throw myException" and to say "return myExceptionalBottom".
04:48:14 <niet> so i onyl catch? i dont try?
04:48:34 <ivanm> niet: either
04:48:37 <ivanm> they do different things
04:48:38 <quicksilver> jeltsch: yes, completely different. 'return' would wrap it in a monad.
04:48:40 <jeltsch> quicksilver: The former is an I/O action that doesn’t succeed. The latter succeeds, the failure just pops up when its result is evaluated.
04:48:49 <quicksilver> jeltsch: but that's because of return.
04:48:49 <ivanm> the difference is, catch is defined in the prelude, try isn't (by the looks of things)
04:49:02 <quicksilver> jeltsch: you could just write 'myExceptionalBottom' (no return) and that would be the same
04:49:02 <ivanm> but for more fine grained control, see Control.Exception
04:49:02 <fasta> niet: if P=NP, nothing remains. I happen to think there is at least one (published) paper which provides an algorithm for an NPC problem, which runs in polynomial time.
04:49:13 <fasta> yitz: yes, I know it.
04:49:16 <quicksilver> jeltsch: except there is no syntax for 'myExceptionalBottom', as it happens
04:49:27 <quicksilver> jeltsch: or, there is syntax, and that syntax is error/throw.
04:49:29 <jeltsch> quicksilver: Maybe we just use different terminology.
04:49:48 <jeltsch> quicksilver: When I talked about exceptions I thought about throw.
04:50:02 <quicksilver> error generates _|_
04:50:05 <fasta> RSA is probably even easier to crack, it's just that only the NSA knows how :)
04:50:07 <quicksilver> (this is specified by h98)
04:50:13 <yitz> fasta: that's the real problem. P/=NP is ok, at least for a while.
04:50:14 <quicksilver> throw is not in h98, I think.
04:50:20 <jeltsch> quicksilver. So exceptions would always be in the IO monad.
04:50:25 <quicksilver> jeltsch: no.
04:50:27 <ivanm> fasta: I doubt it...
04:50:29 <quicksilver> :t throw
04:50:30 <lambdabot> Not in scope: `throw'
04:50:34 <ivanm> @hoogle throw
04:50:34 <lambdabot> Control.Exception throw :: Exception -> a
04:50:34 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
04:50:34 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
04:50:41 <quicksilver> jeltsch: throw is not in the IO monad
04:50:43 <quicksilver> (thanks ivanm )
04:50:54 <ivanm> jeltsch: it gets even more fun (aka confusing :p) with the new extensible exceptions ;-)
04:50:57 <ivanm> quicksilver: np
04:51:01 <tippit> so I do : catch (readFile path) (print 10) or soemthing?
04:51:04 <tippit> catch :: IO a -> (IOError -> IO a) -> IO a
04:51:09 <ivanm>  @hoogle is usually mroe reliable than :t IMO
04:51:10 <jeltsch> quicksilver: Okay, then it’s not throw but something different. I mean this userError etc. stuff.
04:51:20 <ivanm> tippit: yeah
04:51:21 <quicksilver> jeltsch: "error"?
04:51:26 <ivanm> or even print ()
04:51:26 <blackh> fasta: http://frontalot.com/media.php/325/MC_Frontalot_SFTF_%2801%29_Secrets_From_The_Future.mp3
04:51:27 <quicksilver> jeltsch: that's also not in the IO monad.
04:51:31 <jeltsch> quicksilver: No!!
04:51:37 <quicksilver> jeltsch: exceptions are everywhere. They are stored in _|_.
04:51:41 <ivanm> s/print ()/return ()/
04:51:43 <tippit> ouldn't match expected type `IOError -> IO String'
04:51:43 <tippit>            against inferred type `IO ()'
04:51:47 <tippit>  In the second argument of `catch', namely `(print 10)'
04:51:52 <quicksilver> jeltsch: they can be 'thrown' from anywhere, but only caught in the IO monad.
04:51:55 <jeltsch> quicksilver: Wait, I look it up in the report.
04:52:21 <ivanm> hmmm.... has lambdabot's @Hoogle been updated to include extensible extensions, etc.?
04:52:46 <jeltsch> quicksilver: http://www.haskell.org/onlinereport/io-13.html#sect7.3
04:52:56 <jeltsch> quicksilver: "Exception handling in the I/O monad"
04:53:15 <jeltsch> quicksilver: They use the term "exception" solely for the things you throw with ioError.
04:53:17 <fasta> blackh: summary please, I don't have sound here(crazy ubuntu).
04:53:24 <jeltsch> quicksilver: These are in the I/O monad.
04:53:33 <jeltsch> quicksilver: _|_, error etc. is something different.
04:53:34 <blackh> fasta: Here it is without sound: http://frontalot.com/index.php/?page=lyrics&lyricid=41
04:53:47 <quicksilver> jeltsch: actually it's not.
04:54:01 <quicksilver> jeltsch: they are so closely related it would be foolish to call them something different.
04:54:15 <jeltsch> quicksilver: It’s just GHC & Co. which later generalized the stuff and consider things generated with error as a special kind of exception (which is a good thing).
04:54:42 <quicksilver> you're right of course that it would be better not to use the word 'exception' for "error"
04:54:46 <quicksilver> occasionally I make that point myself
04:54:56 <quicksilver> but in the preceding discussing I have been conceding to the majority usage
04:55:04 <quicksilver> which is to call them exceptions too.
04:55:11 <ivanm> @src undefined
04:55:11 <lambdabot> undefined =  error "Prelude.undefined"
04:55:27 <ivanm> quicksilver: what is the difference?
04:55:30 <jeltsch> quicksilver: In Haskell 98 you cannot catch "exceptions" which were generated with the error function. Evaluating error ... always leads to program termination.
04:55:40 <quicksilver> jeltsch: yes, agreed.
04:55:45 <ivanm> ahhhh
04:55:58 <SamB> hmm, allowing users to enter their email address rather than an account name to login to a site really makes things easier on the user, doesn't it?
04:55:58 <ivanm> errors are final, exceptions are able to be worked around/dealt with?
04:56:09 <quicksilver> ivanm: that was supposed to be the difference, yes.
04:56:18 <ivanm> SamB: saves trying to think up another WeebleFeeble1253698 name...
04:56:23 <quicksilver> and exceptions (confusingly also called 'IO errors') were only in the IO monad.
04:56:29 <quicksilver> but the boundary got blurred.
04:56:34 <ivanm> though if it's a public identity, it can lead to loss of privacy/increase in spammage
04:56:41 <ivanm> quicksilver: *nod*
04:56:49 <ivanm> what non-IO exceptions are there then?
04:57:06 <jeltsch> quicksilver: So *in Haskell 98* there are errors and exceptions and nothing forces a Haskell-98-compliant compiler to unify both worlds. GHC does unify them which is conformant with the Report but not enforced.
04:57:16 <quicksilver> well the whole Control.OldException and Control.Exception hierarchies.
04:57:20 <quicksilver> (that to ivanm)
04:57:26 <ivanm> I guessed that ;-)
04:57:27 <SamB> ivanm: or remembering whether your usual was taken and if so what you used instead ;-)
04:57:28 <quicksilver> which contains some IO related and some less so.
04:57:34 <ivanm> SamB: exactly
04:57:44 <SamB> I'm not saying you shouldn't have a username too
04:57:50 <quicksilver> jeltsch: yes.
04:57:57 <SamB> just that being able to login with the email address simplifies things
04:58:03 <ivanm> I've used three or four variants on my nick here for various sites, due to someone else already having it or minimum length of nick
04:58:22 <ivanm> (why do some sites say that usernames have to be of a minimum length? :s )
04:58:28 <quicksilver> jeltsch: but, the h98 report does not indicate what happens if you get an IO error during readFile
04:58:30 <ivanm> SamB: ahhh
04:58:33 <quicksilver> jeltsch: (which is what we were talking about)
04:58:33 <SamB> ivanm: dunno!
04:58:43 <ivanm> though then you have to do a multiple lookup....
04:58:51 <quicksilver> jeltsch: the h98 report completely fails to address the problems caused by lazy IO, or indeed acknowledge their existence.
04:58:55 <SamB> hmm ? multiple lookup ?
04:59:15 <SamB> I assume the @ sign clues the sites in
04:59:40 <quicksilver> jeltsch: any h98 implementation has to solve this problem.
04:59:45 <ivanm> SamB: as in, do they count it as a double username? (the login->password lookup has an entry for the username and the email) or do they use @ to tell the difference?
04:59:54 <quicksilver> jeltsch: and the only sensible solution appears to be embedding exceptions in _|_, which is what GHC chose.
05:00:00 <ivanm> problem with the latter is if some smart-alec has an @ in their username...
05:00:18 <SamB> ivanm: isn't that usually not allowed ?
05:00:19 <lilac> has it been proved that P == NP on Von Neumann architectures is the same as P == NP on a Turing machine?
05:00:31 <ivanm> SamB: *shrug* dunno, I don't run any websites :p
05:00:37 <jeltsch> quicksilver: I didn’t want to say that what GHC does is bad.
05:00:48 <ivanm> lilac: ummm.... I thought P /= NP had been proven in general...
05:00:54 <lilac> i ask because if we consider C == NC (where C is 'constant time'), the answers are different on the two architectures
05:01:00 <SamB> ivanm: hahaha
05:01:14 <quicksilver> jeltsch: I'm sure you didn't ;)
05:01:22 <SamB> ivanm: I think I would have heard if they finally figured that out
05:01:24 <jeltsch> quicksilver: And if H98 says that upon I/O errors, an _|_ should be embedded then GHC is still H98-compliant since it embeds its exceptions into _|_.
05:01:33 <ivanm> SamB: hmmmm, I thought I had heard of it a few years ago...
05:01:34 <yitz> SamB: to support unicode urls and email addresses, there is now a quoting scheme that allows just about anything.
05:01:38 <tippit> ouldn't match expected type `IOError -> IO String'
05:01:38 <tippit>            against inferred type `IO ()' ;;; but what is IOError -> IO String ?
05:01:40 <ivanm> must have been either a faulty proof or a subset
05:01:47 <quicksilver> jeltsch: H98 only considers the case of IO Errors occuring in IO.
05:01:59 <quicksilver> jeltsch: (in which case, _|_ is not needed, you can just invoke the semnatics of the IO monad)
05:02:07 <quicksilver> jeltsch: as you pointed out, that's a more elegant interface.
05:02:24 <tippit> Samb: I proved it yesterday
05:02:26 <lilac> ivanm: there was a 'proof' which said 'lookit, here's how you make a machine which solves NP-complete problems in polynomial time'
05:02:29 <blackh> tippit: Looks like you've missed an argument out or something.
05:02:31 <quicksilver> jeltsch: however, h98 *does* mandate lazy IO, and gives no hint how to marry up lazy IO with the obvious possibility of 'lazily' encountering an IO error.
05:02:44 <quicksilver> jeltsch: I would view that as a bug in the h98 spec, personally.
05:02:44 <ivanm> lilac: and? did they make it?
05:02:57 <lilac> ivanm: but it was a physical method which went via creating bubble patterns, and it lacked a proof that the optimal pattern would form, and also lacked a proof that it was polynomial time
05:03:02 <ivanm> ahhh
05:03:18 <ivanm> pfffttt.... engineering problem :p
05:03:19 <tippit> but how do I take a type IO Error?
05:03:48 <tippit> hasnt anyoen got an example if using catch?
05:04:00 <lilac> pretty unimpressive proof of P=NP, really, giving a constructive method which might not get the right answer and might not be in P
05:04:20 <lilac> (even if we slacken off the definition of the problem to the extent where the solution is even admissible)
05:04:22 <blackh> tippit: I can help you with catch... What types of exceptions are you catching?
05:04:43 <blackh> tippit: Anyway, here's an example:
05:05:14 <jeltsch> quicksilver: I just had a look. H98 specifies the results of lazy reading only partially. So it would be spec-conformant to finish the list with [] when encountering an error or to “finish” it with _|_. GHC does the latter while putting more information into the _|_. So GHC is H98-conformant and provides a sensible solution. Fine. :-)
05:07:09 <blackh> tippit: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1592#a1592
05:07:30 <blackh> tippit: This is not a very good example, because it catches everything.
05:08:17 <blackh> tippit: You should also be aware that there's a bug in GHC, where Control.Exception.catch can't catch old-style exceptions.  This will be fixed in 6.10.2
05:08:47 <tippit> blackh: just hwen a file doesnt exist
05:08:51 <blackh> tippit: The ::SomeException is needed, otherwise you get an error
05:08:52 <fasta> lilac: http://www.merlins-world.de/ <- much more convincing P=NP proof
05:09:10 <ivanm> blackh: how is that a bug, if the exception syntax has changed?
05:09:23 <tippit> *** Exception: C:/users/saftarn/desktop/datasets/goodemails.txta: openFile: does not exist (No such file or directory)
05:09:35 <ivanm> oh, having to explicitly creating a catching function with the right type is a PITA...
05:09:57 <blackh> ivanm: It's a bug because it means 'bracket' isn't safe.
05:11:26 <blackh> tippit: I am figuring it out...
05:19:32 <blackh> tippit:  Control.Exception.catch (openFile "/xx" ReadMode >> return ()) (\exc -> case fromException exc of {Just exc -> putStrLn $ "It's an IO one: " ++ show (exc::IOException); otherwise -> throwIO exc})
05:19:41 <blackh> tippit: It's an IO one: /xx: openFile: does not exist (No such file or directory)
05:20:25 <blackh> There are probably neater ways, but this allows you to handle an IOException, while re-throwing other types
05:21:13 <blackh> The ::IOException gives the type inference the necessary clue to know what type of exception you're talking about.
05:21:33 <ggl> hi
05:21:36 <blackh> openFile doesn't throw a specific 'file not found' exception, so you can't specifically check for that.
05:21:45 <blackh> ggl: Hello!
05:21:48 <matthew-_> mmm, ok, in call by value, if we have ((\x.x) (\y.y)) ((\z.z) a) then we're evaluate an application only when its rhs is not an application, right?
05:21:48 <lambdabot> matthew-_: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:23:35 <matthew-_> so we don't eval \z.z a first because it is an application, so first we eval \x.x \y.y to \y.y?
05:25:22 <blackh> tippit: The thing to remember with fromException is - if you're used to OO - it is nothing like OO!
05:25:41 <tippit> thanks a lot
05:25:41 <tippit> and holy shit i ahd to do all that
05:26:10 <quicksilver> matthew-_: I'm not sure if CBV defines evaluation order, beyond that it's obviously got to be innermost first.
05:26:23 <quicksilver> matthew-_: commonly it's left to right innermost first
05:26:44 <byorgey> matthew-_: it doesn't much matter whether you evaluate ((\x.x) (\y.y)) or ((\z.z) a) first.  the point is that once you get (\y.y) ((\z.z) a), you must evaluate the ((\z.z) a) first before applying (\y.y).
05:26:46 <blackh> tippit: Exception handling takes a bit of getting used to, but it's easy enough once you get the hang of it.
05:26:47 <quicksilver> matthew-_: in which case it's the \x.x \y.y part first simply because that's the innermost part of the leftmost
05:26:59 <quicksilver> byorgey: it would matter if there were side effects though.
05:26:59 <niet> where is openFile and ReadMode?
05:27:08 <byorgey> quicksilver: true.
05:27:38 <pejo> quicksilver, ick. There shouldn't be side effects.
05:27:42 <byorgey> but since he was using untyped lambda calculus notation...
05:28:06 <byorgey> @hoogle openFile
05:28:06 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
05:28:15 <quicksilver> pejo: there are in most CBV languages :)
05:28:18 <matthew-_> quicksilver, byorgey: thanks
05:28:22 <byorgey> niet: ^^^
05:28:44 <quicksilver> pejo: indeed, one of the reasons that normal-order evaluation is unpopular is the way it makes your side effects unpredictable.
05:28:57 <quicksilver> which is why normal-order goes together so well with a totally pure langauge
05:29:02 <pejo> quicksilver, in ML's defense they were a bit ahead of the monadic thoughts.
05:29:04 <quicksilver> purity + laziness = two sides of the same coin.
05:29:25 <pejo> quicksilver, why would purity and laziness be the same coin?
05:29:57 <matthew-_> ok, so how about that I need for the typing environments to take into account the evaluation order
05:30:26 <matthew-_> i.e. the type of a term is a function that modifies a typing environment
05:31:00 <Cheshire> matthew-_, hmm? what does that mean
05:31:20 <matthew-_> something like application ends up looking like : if (e1 gives gam1 -> gam2) and (e2 gives gam2 -> gam3) then e1 e2 gives gam 1 -> gam3
05:31:35 <lilac> quicksilver: you've shown that laziness doesn't work in an impure language, not that it works well in a pure one ;-)
05:31:54 <Cheshire> matthew-_, I think the algorithm is simpler if you look at it in terms of unification
05:32:06 <matthew-_> yes, but in this case, it's not unification
05:32:13 <matthew-_> it's more like a linear type system
05:32:16 <lilac> FWIW, I think haskell with explicit laziness annotations (or data/codata or whatever) would be nicer...
05:32:43 <Cheshire> matthew-_, ahh so you are thinking about the context splitting operation
05:33:12 <matthew-_> Cheshire: maybe. ;)
05:33:17 <Cheshire> no?
05:33:42 <Cheshire> I guess I'll stop chasing geese now
05:34:09 <matthew-_> mmm. it doesn't feel like it - I mean, what I'm doing feels like the algorithmic approach from chapter 1 of advanced types... book
05:34:09 <pejo> quicksilver, and I disagree with your assertion that normal-order evaluation is unpopular because of how side effects turn out, too.
05:34:29 <matthew-_> but it doesn't feel like the declaritive splitting thing
05:35:29 <matthew-_> it's like given e1 e2, in the reduction of e2 to a value, it may create a resource that is then used by e1. But e1 may need to be reduced to a value too (which may create other resources) before the application can occur
05:35:50 <agruman> is there some "easy" way to apply [a] and [b] to   f :: a -> b -> c  ? was thinking of using foldl somehow but cant seem to get it right, seems superflaus to create a helper function for this.
05:36:04 <Workybob> I've obviously got a missing library here, but does anyone know what I'm doing wrong here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1766#a1766
05:36:42 <matthew-_> so, given SKI,  if you have (I1 I2) (I3 a) then pretend that evaluating a and I2 creates resources
05:36:43 <doserj> @type zipWith
05:36:44 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
05:36:45 <pejo> agruman, cs = zipWith f as bs?
05:36:52 <matthew-_> so then how do you feed the type contexts around?
05:37:31 <niet> hmm, is there some truth in Haskell? ie is it necessary so that Haskell is the way it is? or are there a lot of arbitrary convenient designchoices there as well? Im comparing now for exmaple to PHP which is a bunch of neat stuff mostly
05:37:51 <Cheshire> neit, yes
05:37:56 <Workybob> niet: Haskell is built around lambda calculus
05:38:03 <agruman> pejo, thanks alot :)
05:38:08 <Workybob> a lot of the design desisions are there to keep all it's niceness
05:39:27 <daf> niet: http://www.syntaxpolice.org/index.php/?q=node/419 :P
05:39:54 <daf> non-transitivity of equality considered harmful
05:42:49 <Workybob> No one knows about my link errors up there then?
05:42:49 <Workybob> :(
05:45:37 <pejo> Workybob, does -v give some extra information about where ghc is looking for thinks/what flags it's passing on to the linker?
05:46:49 <Workybob> wow, that's quite a command, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1766#a1768
05:47:35 <Workybob> I think the linker may be fairly convinced by the number of -L/opt/local/libs in there
05:48:00 <stanv_> hello, is there any real GUI working programs on Haskell ?
05:49:17 <Workybob> hmm, it certainly does get the relevant args posted to it
05:50:52 <niet> if you want to learn cryptography, what is a good basic algorithm to implement? (or to break)
05:51:00 <kapil> stanv_: xmonad?
05:51:26 <Workybob> niet: RSA is easy enough
05:52:11 <Workybob> let rsa k p = zipWith xorChars (cycle k) p -- finished
05:52:14 <Workybob> >.>
05:52:18 <pejo> Workybob, what does nm /opt/local/lib/libftgl.a | grep ftglGetLayoutLineLength give?
05:52:24 <kapil> niet: implement the quadratic sieve for factoring. you can then try to use concurrent haskell or "Clean" to actually break keys.
05:52:48 <Workybob> ah, interesting pejo
05:52:49 <Workybob> nothing
05:53:30 <stanv_> kapil: xmonad - uses only xlib
05:53:49 <stanv_> i need futured GUI
05:54:06 <Workybob> futured GUI?
05:54:16 <stanv_> widgets
05:54:32 * kapil mostly uses programs that use only xlib
05:54:32 <pejo> Workybob, do you get anything as output if you nm libftgl.a?
05:54:39 <Workybob> yeh, plenty
05:54:46 <Workybob> but none of the symbols referenced there
05:55:14 <yitz> stanv_: http://xiangqiboard.blogspot.com/
05:55:40 <pejo> Workybob, ok, so you have a libftgl.a that does not contain the symbols the haskell program wants. Wrong major/minor version perhaps?
05:55:46 <yitz> stanv_: http://haskell.org/gtk2hs/archives/2008/02/24/barracuda-p2p-chat/
05:55:49 <stanv_> yitz: thanks
05:55:57 <Workybob> perhaps – I wonder what the requirement is
05:57:00 <yitz> stanv_: http://wxhaskell.sourceforge.net/applications.html
05:58:54 <yitz> stanv_: there is stuff written in opengl, but doesn't sound like that's what you are looking for
06:00:23 <jeltsch> Hi, is it possible to have multiple mailing lists for a single project on the Haskell Community Server? For example, one users and one developers mailing list?
06:00:50 <stanv_> yitz: using gtk binding is fine solution....
06:01:34 <stanv_> yitz: also as variant, is possible use kdialog...
06:01:45 <yitz> stanv_: gtk2hs and wxhaskell are both very nice
06:03:42 <stanv_> for me very important stability
06:03:58 <matthew-_> hmmm, it seems that the typing goes right to left if evaluatoin goes left to right
06:05:16 <Workybob> matthew-_: that's because when writing haskell you shouldn't think about evaluation
06:05:19 <Workybob> you should think about denotation
06:05:23 <Workybob> which goes left to right
06:05:36 <matthew-_> Workybob: yeah, I'm talking about lambda calculus, not haskell
06:06:11 <matthew-_> and in particular lambda calc with CBV and standard left to right innermost first
06:06:14 <Workybob> oh, and typing as in type systems
06:06:22 <matthew-_> yep
06:06:32 <Workybob> sorry, got totally the wrong end of your stick
06:06:43 <matthew-_> np
06:08:09 <jeltsch> I‘m just creating a trac instance for my community.haskell.org project. Now I am asked to register an admin account (i.e., create an account). Aren’t the accounts of the Community Server also used for the trac instances? Has every project’s trac instance its own user database? :-O
06:11:43 <quicksilver> matthew-_: I note that typical denotational treatments are independent of evaluation order.
06:11:56 <quicksilver> matthew-_: it's the operational/reductional semantics where you can "see" the difference.
06:19:16 <pejo> quicksilver, did you miss our questions on lazy/pure earlier?
06:20:51 <matthew-_> quicksilver: yes, but here I effectively have side effects which alter the types
06:21:05 <matthew-_> so the evaluation order is reflected in the type system
06:22:48 <Cheshire> matthew-_, that doesn't make sense
06:22:57 <matthew-_> Cheshire: why's that?
06:24:10 <Cheshire> are you referring to some actual type system?
06:24:30 <niet> satisfies the congruence relation: de /// 1 where /// is really - 3 times under each other
06:24:35 <niet> wtf doesnt all do that?
06:31:04 <jeltsch> Trac instances on community.haskell.org allow everyone to edit wiki pages. Does anyone know whether community.haskell.org has problems with wiki spam?
06:31:25 <gwern> the regular wiki does, dunno about the tracs
06:33:12 <matthew-_> Cheshire: don't worry, we've found errors now!
06:33:45 <Workybob> pejo: hmm, finally got the latest ftgl built from sources – those functions aren't there - it appears the Haskell FTGL module references non-existant(deprecated?) functions
06:35:15 <Cheshire> matthew-_, I *still* have no clue what you are talking about
06:36:11 <pejo> Workybob, I don't have any specific knowledge of ftgl, just a general linking fu for unix, sorry. :-)
06:37:27 <niet> satisfies the congruence relation: de /// 1 where /// is really - 3 times under each other
06:37:41 <polux> hi
06:37:50 <Cheshire> niet, "wtf doesnt all do that?" doesn't make sense
06:38:00 <niet> de /// 1 , what does it mean?
06:38:11 <Alpounet> @src zip
06:38:11 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
06:38:11 <lambdabot> zip _      _      = []
06:38:14 <polux> I just upgraded cabal using cabal upgrade (which upgraded, among other things cabal itself)
06:38:22 <polux> now some packages won't install
06:38:24 <niet> d*e and 1 and the same gcd? isn that true for all? obv I msut be miusudnerstanding
06:38:31 <niet> http://en.wikipedia.org/wiki/RSA
06:38:34 <polux> because of a dependency cycle concerning process
06:38:57 <dcoutts> polux: you didn't want to upgrade process, I suggest you remove it again
06:39:05 <polux> i read on haskell-cafe that a solution is to unregister process-1.0.1.1
06:39:11 <dcoutts> polux: yes
06:39:30 <polux> dcoutts: yes, but it wants me to uninstall a lot a things to do so
06:39:31 <dcoutts> polux: the latest version of cabal-install disables world upgrade because people tend to break their systems with it
06:39:36 <polux> should i use --force ?
06:39:46 <dcoutts> polux: yes and rebuild the broken things
06:39:49 <polux> or should i remove them, then reinstall them
06:39:53 <polux> ok
06:39:55 <polux> thanks
06:40:13 <polux> dcoutts: so i don't want to upgrade world in the future, only single packages ?
06:40:49 <dcoutts> polux: use install instead of upgrade, you can do it on batches of things at once though, that guarantees they all have consistent deps
06:41:03 <polux> ok, thanks a lot
06:41:09 <dcoutts> polux: but upgrade means upgrade all dependencies too, and that's usually a bad idea for core libs
06:41:24 <dcoutts> poliquin: at the end, run ghc-pkg check. Also run ghc-pkg list and look for any cases where the same version is installed per-user and globally
06:41:27 <dcoutts> oope
06:41:34 <dcoutts> polux: ^^
06:41:40 * dcoutts misuses tab completion again
06:42:03 <polux> ok
06:43:17 <hackage> Uploaded to hackage: network-server 0.1.0
06:44:38 <w0lter> oddList (x:xs) | odd x     = x : oddList xs , what is the last " : " mean?
06:45:02 <C-Keen> w0lter: list composition
06:45:18 <Cheshire> that's not a list comprehension
06:45:31 <C-Keen> :t :
06:45:32 <lambdabot> parse error on input `:'
06:45:37 <C-Keen> sigh
06:45:43 <Cheshire> oh C-Keen I misread you
06:45:51 <Cheshire> you said composition but I thought it was comprehension
06:46:17 * Cheshire tries putting the font size bigger..
06:46:36 <Workybob> w0lter: it means "construct a list, by appending x to the front of the list oddList xs"
06:46:38 <w0lter> so it is the same means to (x:xs), isn't it?
06:46:43 <Workybob> w0lter: yes
06:46:45 <Workybob> and no
06:46:57 <Workybob> the (x:xs) means match against things that were constructed using a :
06:47:17 <Workybob> the latter means "construct something into a list" (and the result will match against something like (x:xs))
06:47:34 <w0lter> Workybob: understand, thank you
06:47:39 <Workybob> :)
06:48:01 <w0lter> :)
06:53:17 <PHO_> ah this isn't anything related to Haskell, but... http://data.tumblr.com/jQ9iHEdNfkaxefqnjcQkcJFKo1_500.gif
06:53:39 <Cheshire> PHO_, funny
06:54:43 <Cheshire> PHO_< where is it from?
06:55:01 <PHO_> another channel on IRC
06:55:05 <Cheshire> aw
06:55:51 <w0lter> oddList :: [Int] -> [Int]
06:55:52 <w0lter> oddList (x:xs) | odd x     = x : oddList xs, What is "|odd x"  mean please?
06:55:53 <PHO_> if they came down straight to the earth, they could easily prosper :)
06:56:17 <Cheshire> w0lter, not only does the [Int] parameter have to match the pattern (x:xs) but it also checks that odd x is True
06:56:35 <Cheshire> PHO_, can kind of relate to that .. being in class being told to do everything a round about way :p
06:56:59 <PHO_> はは
06:57:02 <PHO_> haha
06:57:06 <w0lter> Cheshire: got it, thanks :)
06:57:52 <Cheshire> w0lter, btw there a function like  oddList  but instead of using 'odd' it takes any predicate
06:57:54 <niet> can someone explainhttp://en.wikipedia.org/wiki/RSA step 5 to me? deostn any integer satisfy that+
06:58:04 <Cheshire> @src filter
06:58:05 <lambdabot> filter _ []     = []
06:58:05 <lambdabot> filter p (x:xs)
06:58:05 <lambdabot>     | p x       = x : filter p xs
06:58:05 <lambdabot>     | otherwise = filter p xs
06:58:18 <Cheshire> w0lter, so you can see like  oddList = filter odd
06:58:39 <sbahra> :t filter odd
06:58:40 <lambdabot> forall a. (Integral a) => [a] -> [a]
06:58:41 <sbahra> :t filter
06:58:42 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:58:45 <w0lter> Cheshire I see
06:58:53 <sbahra> :t odd
06:58:54 <lambdabot> forall a. (Integral a) => a -> Bool
06:59:01 <sbahra> :t (==)
06:59:02 <lambdabot> forall a. (Eq a) => a -> a -> Bool
06:59:40 <sbahra> C-Keen, BTW
06:59:43 <sbahra> :t (:)
06:59:44 <lambdabot> forall a. a -> [a] -> [a]
06:59:51 <sbahra> :t (+)
06:59:52 <lambdabot> forall a. (Num a) => a -> a -> a
06:59:56 <sbahra> C-Keen, etc
07:02:19 <mdmkolbe> Is there a way to pass a type family as argument to a type constructor?
07:02:54 <sbahra> mdmkolbe, what is a type family?
07:03:18 <PHO_> mdmkolbe: IIRC, that is prohibited for type safety
07:03:44 <PHO_> though I don't understand why that is unsafe
07:04:47 <sbahra> mdmkolbe, ?
07:04:53 <mdmkolbe> PHO_: ok, I can work around it (pass a "key" data type and call a "map" family directly in the type), but it would be much cleaner if I didn't have to
07:05:05 <mdmkolbe> sbahra: http://www.haskell.org/haskellwiki/GHC/Type_families
07:05:31 <sbahra> Ahhh
07:05:32 <mdmkolbe> sbahra: it is (among other things) a way to write a function a the type level
07:05:54 <mdmkolbe> e.g. "type instance Fst (x,y) = x"
07:06:00 <doserj> let p=5; q=7; phi = (p-1)*(q-1); e = 13 in take 20 $ map (\d -> d*e `mod` phi) [1..] -- niet
07:06:03 <doserj> > let p=5; q=7; phi = (p-1)*(q-1); e = 13 in take 20 $ map (\d -> d*e `mod` phi) [1..] -- niet
07:06:05 <lambdabot>   [13,2,15,4,17,6,19,8,21,10,23,12,1,14,3,16,5,18,7,20]
07:06:54 <sbahra> PHO_, mdmkolbe, section 7.2.3
07:06:54 <mdmkolbe> sbahra: regular type synonyms only allow you to build up types, but type families allow you to take them down (similar to "data" type vs GADT)
07:08:11 <sbahra> Ok. Thanks.
07:08:56 <mdmkolbe> sbahra: are you refering to bullet #1?  If so then that doesn't apply b/c that is for type families applying to type families.  I'm after applying a regular type constructor to a type family
07:10:59 <w0lter> Again in   oddList (x:xs) | odd x     = x : oddList xs          "|" mean  AND
07:11:01 <w0lter> while          data bool = False | True                                    "|" means OR ?  I am confused
07:11:05 <sbahra> Ah, ok.
07:11:25 <sbahra> Sorry, I ignored the "family" portion initially. :)
07:11:34 <quicksilver> pejo: yes, I think so. Feel free to repeat them if you think my answers might be useful.
07:11:35 <sbahra> w0lter, these are called "guards".
07:12:14 <sbahra> w0lter, junk x | x == 0 = 1 | x == 2 = 3 | otherwise = (-1);
07:12:20 <dolio> Type families have to be fully applied to their indices.
07:12:21 <w0lter> yes, I just read this part from 'Real World Haskell'
07:12:40 <dolio> So 'type family Foo a b :: * -> * -> *' has to always be applied to a and b when it appears.
07:12:56 <dolio> But you could use 'Foo Int Char' on its own.
07:13:08 <sbahra> w0lter, so if x = 0, then junk x = 1. If x = 2, then junk x = 3, otherwise. junk x = (-1)
07:13:26 <quicksilver> dolio: you can presumably do "newtype FooInt b = FooInt (Foo Int b)"
07:13:33 <quicksilver> dolio: if you want to partially apply a type family
07:13:41 <dolio> Sure.
07:13:48 <quicksilver> just checking ;)
07:14:03 <sbahra> w0lter, the type of a guard (for example, | f = ..., where f is the guard) is bool
07:14:06 <dolio> Although, not with the type I gave above, because the thing inside still has kind * -> * -> *
07:14:30 <pejo> quicksilver, why would lazy and pure be two sides of the same coin?
07:14:45 <quicksilver> pejo: because laziness only makes sense with purity.
07:14:45 <dolio> You could do 'type FooInt b = Foo Int b' in fact.
07:14:59 <pejo> quicksilver, and lilac pointed out that what you had shown was that impure and lazy didn't work very well.
07:15:03 <w0lter> sbahra: thanks,  it seems I have to spend a little time on "guard" to full understand it.
07:15:04 <yitz> w0lter: "|" separates alternatives in both case. For a data type - alternative constructors. For a function - alternative definitions of the function depending on guard conditions.
07:15:05 <quicksilver> dolio: but you can't partially apply a type synonym.
07:15:22 <quicksilver> pejo: well conversely, once you have purity, you might as well have laziness.
07:15:34 <quicksilver> which gives the compiler more flexibility.
07:15:39 <quicksilver> that's the intuition I think.
07:15:40 <pejo> quicksilver, wasn't even Moggi's original paper for cbv?
07:15:49 <quicksilver> monads for computation?
07:15:57 <quicksilver> I don't recall it mentioning an evaluation strategy
07:15:59 <dolio> Right. They're in the same situation as type family indices.
07:16:01 <quicksilver> it's denotational not operational.
07:16:48 <dolio> Perhaps because you can translate "type Foo <v> = ..." into "type family Foo <v> :: k ; type instance Foo <v> = ...".
07:16:49 <dolio> I think.
07:17:22 <pejo> quicksilver, ok, I have to look that paper up later. I think you're jumping the gun a bit when you declare that if you're pure you might as well be lazy. Only time will tell though, I guess.
07:17:46 <Cheshire> pure and stict seems silly
07:18:26 <quicksilver> pejo: I'm not claiming that's a mathematically tight argument.
07:18:35 <quicksilver> pejo: it's an intuition...
07:18:47 <mdmkolbe> dolio, quicksilver: So given that I can't pass type families to type constructors, is this a good work around?  Is there a better way? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1770#a1770
07:18:58 <dolio> You mean, like inductive data in agda/coq/etc? :)
07:19:52 <w0lter> So, in data bool = False | True  , "|" has nothing to do with guard, right?
07:19:55 <quicksilver> pejo: have you read SPJ's hair shirt? or seen him deliver the talk?
07:19:58 <mdmkolbe> dolio: who were you addressing? If me, I don't understand what you mean
07:20:02 <Saizan> w0lter: right
07:20:08 <quicksilver> w0lter: right. Two toally different uses of the same character.
07:20:25 <w0lter> Understand, thanks you all.
07:20:30 <pejo> quicksilver, I read the slides I think. Are you thinking of "laziness kept us pure"-quote?
07:20:48 <dolio> mdmkolbe: That looks like it would work, yes.
07:21:22 <doserj> > [x^2 | x <- [1..20], even x] -- another use of '|'
07:21:23 <lambdabot>   [4,16,36,64,100,144,196,256,324,400]
07:21:38 <dolio> mdmkolbe: I can't think of a nicer way off hand.
07:23:00 <yitz> pejo: I think quicksilver means if you're pure, you might as well not require strictness. You can give the compiler the flexibility to decide. Intuitively, that should only help with a good enough compiler. In practice, we now know that there are certain situations requiring strictness that have proven very difficult for a compiler to detect automatically, so we need strictness annotation. Usually, though, it seems to be a big win as expected.
07:23:46 <yitz> pejo: i.e., you don't require laziness either. let the compiler decide.
07:24:17 <C-Keen> sbahra++
07:25:11 <yitz> w0lter: right. they're just two very different scenarios where haskell allows you to give some alternative definitions.
07:25:40 <w0lter> yes
07:25:43 <mdmkolbe> yitz: there are complications with things like "let x = 1:y; y=2:x in take 5 x" that can force the compiler to be lazy.  i.e. giving the compiler to blindly be strict is a bad idea
07:26:24 <pejo> yitz, ".. it seems to be a big win as expected" - has this been established?
07:26:49 <pejo> mdmkolbe, even strict languages can do recursive structures to varying degrees (F#, Ocaml, etc).
07:26:57 <yitz> mdmkolbe: i think the idea is that you never want the compiler to be blindly anything. it's supposed to be smart.
07:27:57 <quicksilver> mdmkolbe: the compiler only has flexibility within the constraints of the semantics
07:28:03 <mdmkolbe> pejo: even then you can't do an "if" function
07:28:07 <quicksilver> mdmkolbe: it's not allowed to make strict things which actually are not strict.
07:28:39 <quicksilver> in practice the "accepted" semantics of haskell leave the compiler very little wiggle room at all.
07:28:55 <quicksilver> it is widely understood that named values are shared, and never recalculated.
07:28:56 <pejo> mdmkolbe, yes, that is a true (?) limitation, and I think that's a much better argument than ones = 1:ones (that you can do).
07:28:57 <mdmkolbe> quicksilver: yes, I'm merely saying that lazy semantics and the-compiler-is-allowed-to-choose-lazy-or-strict semantics are different
07:29:13 <quicksilver> mdmkolbe: there is only one semantics
07:29:22 <quicksilver> mdmkolbe: the compiler is allowed to choose evaluation model.
07:29:29 <quicksilver> compilers are not permitted to choose the semantics :)
07:29:33 <quicksilver> that's the programmers job.
07:30:05 <yitz> pejo: there are various cases where it is documented to be useful. perhaps more importantly - almost all users subjectively experience a feeling of empowerment when they reach a certain minimum level of skill.
07:30:54 <yitz> pejo: i don't think anyone knows yet how to measure quantitatively what advantage there is though.
07:31:34 <pejo> yitz, we don't know if that is because of lazy evaluation, or the type system in combination with purity, or that people rewire their brain when programming Haskell, or ..
07:32:23 <yitz> pejo: true, or at least we can't prove anything yet. we just have people's introspection.
07:32:24 <mdmkolbe> pejo: a lot of knot ties of functions are also more difficult without lazyness (bit me when I moved back to scheme) e.g. "eval1 eval = ...eval x...; eval2 eval = ...eval y...; let eval = eval1 (eval2 eval) in eval expr"
07:34:29 <yitz> quicksilver: it does have flexility in the converse case though - when a quantity is not named, the compiler uses heuristics to decide whether to inline, share, or neither.
07:36:06 <pejo> mdmkolbe, do you have the complete piece of code for that one? (eval1 and eval2 are lambda abstractions, right?)
07:36:37 <yitz> quicksilver: and if there were a case that recalculating a named quantity is provably safe and better (if that is possible), a compiler could conceivably do that.
07:37:34 <mdmkolbe> pejo: yes, I should have said "eval1 eval x = ...eval (head x)..." or something like that
07:38:56 * mdmkolbe looks for more complete examples
07:39:49 <quicksilver> yitz: increasing sharing leads to arbitrarily bad memory leaks.
07:39:56 <quicksilver> yitz: good compilers don't do that.
07:40:05 <quicksilver> GHC increases sharing in only a tiny number of circumstances.
07:40:10 <quicksilver> (i can't list them)
07:41:29 <yitz> quicksilver: right, but couldn't there be special cases where there is provably no leak?
07:41:47 <pejo> quicksilver, I think you're doing a good job of listing the reasons against laziness, thank you. :-)
07:42:47 <pejo> yitz, this "good compiler" that people talk about would of course prove these things. However, if these things were easy and beneficial GHC would already do it.
07:43:05 <yitz> pejo: ghc is constantly improving
07:43:10 * mdmkolbe wansn't able to fine any good exmaples
07:43:18 <mdmkolbe> s/fine/find/
07:43:28 <yitz> pejo: no one says this is easy. but there has been dramatic progress, and it is continuing.
07:43:31 <ibid> pejo: nope, laziness is not a change in expected semantics caused by the compiler
07:43:35 <pejo> mdmkolbe, it's not that I don't trust you, I'm just not able to infer enough context to fully understand the problem in your examples.
07:44:27 <pejo> ibid, sorry?
07:44:34 <ibid> (well. haskell purports not to be a lazy language, so i suppose technically it is, after all. but then again, everybody treats haskell as if it was a lazy language)
07:45:18 <ibid> pejo: quicksilver's reasoning cannot be leveled against laziness, like you claimed, because laziness is expected, not a compiler-induced change
07:45:19 <dolio> GHC does CSE when you have 'let x = e1 in <expression involving e1>'.
07:45:26 <misterywoman> uuuuuuuu
07:45:27 <gwern> woo! I think I finally did it - my ireader mode now uses data.binary and data.sequence without issue
07:45:40 <gwern> although I still dislike data.binary
07:45:58 <dolio> Although that could still theoretically cause space leaks.
07:45:58 <gwern> (stupid stack overflow and strictness issues)
07:46:54 <dolio> You'd have to write some odd code for it to do so, though.
07:46:59 <pejo> ibid, so?
07:47:20 <ibid> pejo: that's all :)
07:47:48 <gwern> dolio: better than not being able to read in a tiny 8 meg file...
07:48:08 <HugoDaniel> what is the simplest way to periodically call a given function ?
07:48:31 <dolio> gwern: What?
07:48:33 <HugoDaniel> say, i want to call a function every 3 hours... how do i do it easily ? (im currently using the threadDelay)
07:48:37 <yitz> HugoDaniel: periodically? in time, or after certain events?
07:48:44 <HugoDaniel> in time
07:48:51 <ibid> HugoDaniel: i'd use cron :)
07:48:53 <yitz> HugoDaniel: threadDelay sounds right
07:48:58 <Saizan> forkIO $ forever (func >> threadDelay period-in-microseconds)
07:49:46 <HugoDaniel> okey, thanks
07:49:55 <Dybber> Hi. In this article: http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf the author talks about a Quasiquoter for C that he have written. Does anyone know if and where that is available?
07:50:50 <pejo> Dybber, his page claims it's in GHC 6.9, and there's a patch for 6.8.3 linked.
07:51:41 <Saizan> pejo: i doubt a quasiquoter for C has been included in GHC's sources
07:51:42 <Dybber> That's his Quasiquotation library, not the specific Quasiquoter for C (his example). If I understand it correctly
07:51:46 <Cheshire> Dybber, I would /guess/ that it would be part of Language.C
07:52:02 <pejo> Saizan, doh, of course.
07:52:06 <Cheshire> @hackage language-c
07:52:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c
07:52:19 <Cheshire> it doesn't look like it's in there though
07:53:04 <Dybber> Cheshire: I have looked but couldn't see any module named Quasiquotation QQ or something like that.
07:53:29 <Dybber> And none of the other modules looks like somewhere you would like to place a Quasiquoter
07:55:20 <quicksilver> dolio: slightly more subtle than that.
07:55:35 <quicksilver> dolio: it does CSE when the intermediate representation has that form.
07:55:45 <quicksilver> dolio: and that's not a trivial thing to deduce from the source code
07:55:48 <quicksilver> well, not always
07:56:33 <Dybber> Oh looks like I found it (with Googles help): http://code.haskell.org/~morrow/code/haskell/c-qq/
07:56:33 <quicksilver> pejo: the case against laziness is, essentialy, that it makes space usage harder to predit.
07:56:42 <quicksilver> pejo: the case for it, is that it is better in every way.
07:56:43 <quicksilver> ;)
07:57:00 <pejo> quicksilver, oh, that was a balanced view. I should have asked you much earlier!
07:58:23 <quicksilver> it depends at what level of detail you want to make the case, too.
07:58:37 <quicksilver> If you get right down the metal, the case against laziness is that it adds indirection *everywhere*
07:58:41 <quicksilver> and adding indirection is seldom free.
07:58:41 <pejo> quicksilver, (if you want to predict space usuage, why not execution time as well?)
07:59:04 <quicksilver> but of course that's an implementation question.
07:59:13 <quicksilver> It's possible to avoid most of those indirections in principle.
07:59:28 <quicksilver> pejo: I don't find the time behaviour of lazy programs hard to predict
07:59:39 <quicksilver> ...except to the extent that it reflects the space behaviour.
07:59:45 <quicksilver> Which it does, in real life. Large heaps are slower to GC.
08:00:04 <quicksilver> So I think of the space as the key problem, personally.
08:00:22 <pejo> quicksilver, never made a small change to a program and have the execution time spike in a different function?
08:00:30 <jeltsch> Does anyone have experiences with the mailing lists on projects.haskell.org? I created a list but am not able to subscribe. A confirmation mail is sent but my answers to this mail are ignored. :-(
08:00:44 <quicksilver> pejo: not that I recall.
08:00:54 <quicksilver> certainly that's not how I've understood the problem, if it has happened.
08:01:33 <yitz> quicksilver: i've been wondering about that. can every time complexity problem be reduced to a space complexity problem?
08:01:43 <yitz> formally
08:03:43 <quicksilver> yitz: that's not quite what I'm suggesting. What I'm suggesting is that where the lazy evaluation method has worse asymptotic time complexity than the strict one, that will be rooted in a worse space complexity.
08:04:12 <quicksilver> Your time complexity can never be asymptotically lower than your space complexity, unless you are somehow allocating space you never access
08:05:18 <yitz> quicksilver: even then. I am quite sure that there is a lot that could be proven about that.
08:05:43 <gwern> man. I can't believe how complicated my ireader mode for yi turned out to be
08:05:58 <gwern> (would've been like 10 lines max in emacs...)
08:05:59 <yitz> gwern: what does ireader mode do?
08:06:31 <gwern> yitz: it stores on disk a list of buffers each containg lots of text, and you, in one buffer, step through them reading and editing
08:06:40 <gwern> until you choose to delete it because it's 'done'
08:07:00 <yitz> cool
08:07:16 <pejo> quicksilver, ok, let's hope someone understands spaceleaks soon then. It would certainly be interesting.
08:07:18 <gwern> yitz: the way I use it is to each buffer stores a book or essay, and I read through a few paragraphs of the text, turning it into quotes and questions (for my flash card review program Mnemosyne)
08:07:49 <quicksilver> gwern: that's one fo the things that disheartens me about yi. Reinventing emacs will take forever.
08:07:59 <quicksilver> gwern: who volunteers to port org-mode, for example?
08:08:02 * quicksilver shudders
08:08:04 <yitz> gwern:  is see. useful for any kind of scanning lots of content.
08:08:24 <gwern> yitz: I'm irked because in emacs I would write it basically as bind-key M-1 push foo copy-buffer >> printToBuffer car foo, and so on
08:08:39 <yitz> quicksilver: emacs has been reinventing things longer than almost anyone else.
08:08:43 <gwern> but in haskell I'm doing crazy stuff like data.sequence and wrestling with stack overflows in data.bianry
08:09:09 <quicksilver> sounds like "your doing it wrong" ;)
08:09:23 <gwern> quicksilver: fine, look at my code and tell me how it could be better...
08:09:41 <gwern> just the monad distinction between BufferM and YiM at least doubles the line count!
08:10:01 <quicksilver> I don't have time to look at your code, I'm afraid.
08:10:07 <niet> can someone explainhttp://en.wikipedia.org/wiki/RSA step 5 to me? deostn any integer satisfy that+
08:10:14 <quicksilver> But why would you need Data.Binary for something which in emacs just reads/writes files?
08:10:18 <gwern> yitz: well, not so much scanning but a sustainable way of dealing with lots of texts. the idea is that you *could* sit down with a book and take notes, or you could cut it into ireader-mode and deal with it a little at a time - hence the 'incremental reader' part
08:10:39 <gwern> quicksilver: so that way it doesn't take 10 seconds to read in from a file a [String] or Seq String
08:11:20 <quicksilver> gwern: sounds like a facility which Yi should provide though?
08:11:21 <gwern> *chuck it into ireader-mode
08:11:31 <asgaroth> niet: You need to find a d such that d*e leaves a remainder of 1 when divided by phi(n)
08:11:33 <quicksilver> (simple file reading into a ByteString, or some sensible structure)
08:11:48 <gwern> quicksilver: probably. but also, even something like buffer-local state is hard to do
08:11:54 <gwern> not documented at all, and far from obvious
08:12:30 <yitz> gwern: should BufferM provide that?
08:13:06 <gwern> it provides it.. sort of. you have to use obscure data.acessor functions along with even obscurer functions from Buffer.Misc to 'get and 'put' the state
08:13:12 <gwern> *and* you need to define a typeclass!
08:13:33 <asgaroth> niet: Not every integer satisfies that: phi(n) = 10; e = 7; if you set d=2 it's d*e=14 and 14 mod 10 = 4 /= 1 so that is not suitable, whereas d=3 gives 3*7 mod 10 = 1.
08:14:13 <dolio> > let p = 17 ; q = 19 ; phi = 16*18 ; e = 5 in map (\d -> (d*e) `mod` phi) [1..phi]
08:14:14 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,12...
08:19:30 <jberryman> is there any good documentation for quickcheck floating around? I've got three blog posts and the hackage page open.
08:19:35 <jberryman> it's a little disorienting
08:20:21 <Apocalisp> Well, there's the QuickCheck manual.
08:21:12 <Apocalisp> @go quickcheck manual
08:21:14 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/manual.html
08:23:25 <skorpan> mm
08:27:28 <niet> how do I map over 2 lists?
08:27:37 <gnuvince> zipWith
08:27:53 <gnuvince> > zipWith (+) [1,2,3] [4,5,6]
08:27:54 <lambdabot>   [5,7,9]
08:28:27 <byorgey> niet: is that what you meant?
08:29:14 <gnuvince> byorgey: by the way, thanks a lot of the typeclassopedia, *very* helpful
08:29:19 <igel> what on earth are quickcheck's Test.Quickcheck.Poly.* types for?
08:29:25 <igel> qc-2 that is
08:29:30 <byorgey> gnuvince: you're welcome! glad you think so.
08:33:10 <Apocalisp> byorgey: echo that, It's awesome.
08:33:18 <byorgey> thanks =)
08:33:34 <byorgey> I'm just finishing up some revisions to it
08:36:34 <niet> user=> (doc partial)
08:36:34 <niet> -------------------------
08:36:34 <niet> clojure.core/partial
08:36:34 <niet> ([f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])
08:36:34 <niet>   Takes a function f and fewer than the normal arguments to f, and
08:36:44 <niet> how would i do thta in haskell, automatically by itself?
08:37:02 * sm longs for string splitting in the standard libs
08:37:45 <C-Keen> niet: I don't understand the description
08:39:25 <asgaroth> niet: you'd need different functions for that
08:39:29 <C-Keen> niet: inits?
08:39:30 <niet> (def f (fn [x y] (* x y)))
08:39:31 <Saizan> niet: you don't need partial in haskell
08:39:33 <C-Keen> :t inits
08:39:34 <lambdabot> forall a. [a] -> [[a]]
08:39:36 <niet> (def g (partial f 10))
08:39:40 <asgaroth> If you're talking about default parameters
08:39:41 <niet> (g 20) -> 200
08:40:09 <Cheshire> @let partial = ($)
08:40:10 <lambdabot>  Defined.
08:40:14 <pejo> @google neil mitchell blog default parameters
08:40:16 <lambdabot> http://neilmitchell.blogspot.com/2008/04/optional-parameters-in-haskell.html
08:40:16 <lambdabot> Title: Neil Mitchell's Haskell Blog: Optional Parameters in Haskell
08:40:19 <Saizan> > let f x y = x * y; g = f 10 in g 20
08:40:20 <lambdabot>   200
08:40:25 <Saizan> niet: ^^^
08:40:28 <Cheshire> > let f x y = x * y in g = partial f 10 in g 20
08:40:29 <lambdabot>   <no location info>: parse error on input `='
08:40:34 <Cheshire> > let f x y = x * y ; g = partial f 10 in g 20
08:40:35 <lambdabot>   200
08:41:08 <Cheshire> > let f x y = x * y ; g = f 10 in g 20
08:41:09 <lambdabot>   200
08:41:29 <Apocalisp> @type (*) 10
08:41:30 <lambdabot> forall t. (Num t) => t -> t
08:42:31 <BMeph> Is there any good documentation for using arrays, especially mutable ones?
08:42:42 <fasta> MaybeT + an extra return value is ErrorT, right?
08:43:09 <drhodes> :t ErrorT
08:43:10 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
08:43:37 <Apocalisp> niet: In Haskell, every function takes exactly one argument.
08:44:29 <fasta> BMeph: there are two types of mutable arrays: DiffArrays, which are slow and the various STArrays, which are relatively fast. You just do everything in the ST monad and that's it.
08:44:48 <Apocalisp> @type (\x y -> (x, y)) x
08:44:49 <lambdabot> forall t. t -> (Expr, t)
08:45:05 <fasta> BMeph: and you use the MArray interface to operate on them
08:45:13 <quicksilver> BMeph: there is a haskellwiki page on arrays which summarises the different types, I think?
08:45:20 <quicksilver> @go haskellwiki arrays
08:45:21 <lambdabot> http://www.haskell.org/haskellwiki/Arrays
08:45:21 <lambdabot> Title: Arrays - HaskellWiki
08:45:25 <fasta> quicksilver: yes, there is, don't know how old it is.
08:45:59 <quicksilver> me neither
08:46:08 <BMeph> fasta, quicksilver: Thank you, I'll check it out.
08:48:24 <Apocalisp> Is there a good usage example for TreeLoc?
08:48:38 <Apocalisp> i.e. the rosezipper library
08:50:20 <redditbot> network-server: A light abstraction over sockets for servers applications
08:57:38 <fasta> Is there a solution for threading type parameters through the code all the time?
08:58:22 <Cheshire> fasta, if type inference doesn't do that then I guess I don't understand what specifically you mean
08:58:28 <fasta> data A a = A (B a); data B a = B (C a); data C a = C a, only then in a case where it is actually useful.
08:58:46 <fasta> Instead of just 'a' I have already 7 parameters.
08:59:04 <skorpan> no, you have Nothing
08:59:08 <skorpan> hardy harr harr derr
08:59:35 <Alpounet> is there somewhere a tutorial or a well-commented code for creating a minimal compiler using Haskell ?
08:59:39 <Cheshire> fasta do you mean that you would rather write  data A = A . B ?
08:59:56 <quicksilver> newtype f :. g a = O(f(g a))
09:00:07 <quicksilver> note that this is not a pleasant solution in practise.
09:00:15 <quicksilver> or even in practice.
09:01:10 <fasta> Cheshire: no, I would rather just write "add parameter to C", and then the language would figure out the rest.
09:01:25 <Cheshire> I don't understand
09:01:38 <Cheshire> if you wrote some mock up syntax for it  maybe that would be cleare
09:01:39 <fasta> Cheshire: so, something computable would be "add parameter b to constructor C".
09:01:51 <Apocalisp> Solution looking for a problem: I've writ a Comonad instance for TreeLoc, but I haven't the foggiest what such a thing would be useful for.
09:01:51 <fasta> Cheshire: that is mock up syntax.
09:02:04 <pejo> Alpounet, SPJ's book is available on his homepage.
09:02:10 <quicksilver> I think one of the reasons this isn't a feature, fasta, is that type parameters need to correspond to constructor parameters.
09:02:11 <Cheshire> fasta, is it anything like Coqs Section mechanism?
09:02:13 <Cheshire> you can write:
09:02:29 <quicksilver> fasta: sorry, I meant to say "do *not* need to..."
09:02:29 <fasta> Cheshire: I don't know Coq in that much detail, unfortunately.
09:02:32 <Cheshire> Section List.  Variable A : Type.  Inductive list := nil : list | cons : A -> list -> list.  End List.
09:02:53 <Cheshire> fasta, once you did that.. now   list, nil and cons all take a parameter (A : Type)
09:02:59 <Cheshire> so it's equivalent to writing
09:03:06 <fasta> Cheshire: that seems quite sane, yes
09:03:11 <Cheshire> Inductive list A := nil : list A | cons : A -> list A -> list A.
09:03:19 <Cheshire> is that the sort of thing you mean?
09:03:34 <fasta> Cheshire: does it also work with different data types?
09:03:43 <Cheshire> fasta, it works with anything
09:04:03 <pejo> Alpounet, and Appel has a book about compiler construction in ML, but that's an imperative language.
09:04:04 <fasta> Cheshire: so, that you don't just have list, but a a list which contains a list2, which contains a list3 and so on?
09:04:09 <Cheshire> fasta, when you close the section.. then it abstracts the parameter for everything that makes used of it
09:04:16 <Cheshire> yes
09:04:20 <fasta> Cheshire: ok, so, the Coq people are smart :)
09:04:40 <fasta> Haskell must also get something like that, or I might have to switch to Coq ;)
09:04:40 <Alpounet> pejo, I know this one (but haven't read it), and ML is functional too, it just lets introduce some imperative stuffs ;-)
09:04:41 <Cheshire> fasta, it's a very nice and useful feature..I think impossible to simulate in haskell.. you'd have to hack the compiler
09:05:15 <fasta> Cheshire: are you an expert Coq user?
09:05:21 <Cheshire> no
09:05:50 <Cheshire> fasta, I try to write a coulpe programs in Coq sometimes though
09:06:20 <fasta> I have no application for Coq, which is why it is kind of hard to learn for me.
09:06:36 <iago_> is not my favorite feature of Coq...
09:07:27 <Arnar> hi all
09:07:30 <pejo> Alpounet, writing compilers is a fairly large task though, I guess that's why there aren't more blogposts about it.
09:07:49 <Arnar> perhaps I'm daft.. but can I use cabal to get cabal packages just to look at the source and mess?
09:07:56 <Arnar> or should I get the .tar.gz myself?
09:08:02 <dcoutts_> cabal unpack blah
09:08:08 <Arnar> dcoutts_: ah.. thanks
09:08:26 <Arnar> dcoutts_: for some reason that one doesn't show up in cabal --help
09:08:44 <Alpounet> pejo, indeed ! I just would like to find something that give me the basics of a compiler
09:08:45 <dcoutts_> Arnar: you need to get the latest version then
09:08:52 <Alpounet> (in Haskell, of course)
09:08:53 <Arnar> dcoutts_: yup.. just found out
09:08:53 <dcoutts_> Arnar: cabal install Cabal cabal-install
09:09:04 <Alpounet> SPJ's book may be very good
09:09:19 <Alpounet> but I can't get access to SPJ's page
09:10:19 <pejo> Alpounet, http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
09:11:25 <Alpounet> Thanks.
09:13:15 <Alpounet> My browser doesn't manage to get the page :(
09:14:08 <bremner> Alpounet: try again later? is ok here
09:14:46 <Alpounet> Damn, and I'm sure that if I try loading something like java.sun.com it'd work. But I won't !
09:16:44 <sm> cabal check doesn't find as many problems as cabal sdist, am I right ? eg syntax errors in the cabal file
09:17:09 <dcoutts_> sm: they use the same code, they should be the same.
09:17:42 <dcoutts_> sm: if you build a Setup.hs with a different version of Cabal to the one that cabal-install uses then you may get newer/older set of tests.
09:17:44 <sm> cabal check doesn't catch a non-numeric version number, eg
09:18:13 <sm> no, I'm wrong. must be something else going on
09:19:35 <sm> ahh, I see
09:22:17 <Alpounet> pejo, so SPJ explains in this book how we can implement compilers IN haskell (and not for haskell)
09:23:38 <quicksilver> Alpounet: both.
09:23:46 <quicksilver> it is about writing a haskell compiler in haskell
09:23:51 <quicksilver> (well, a haskell-like language, at least)
09:24:00 <quicksilver> but the concepts is describes are transferable to other languages
09:24:05 <quicksilver> (host or target)
09:24:16 <niet> could someone here improve this article:
09:24:16 <niet> http://en.wikipedia.org/wiki/G%C3%A9rard_Huet
09:24:30 <chrisdone> if I want to run a haskell program as a script from my shell, what should I have in the bang line?
09:24:36 <Alpounet> quicksilver, does it also tell about translation in assembly, etc ?
09:24:44 <skorpan> Alpounet: it's really pretty simple, you just make a lexer/parser which lets you work with an abstract syntax tree
09:24:49 <skorpan> from there you can do anything
09:25:00 <quicksilver> Alpounet: it doesn't go into much detail about code generation as far as I can remember,
09:25:05 <quicksilver> although it's a while since I read it.
09:25:13 <quicksilver> skorpan: that's the easy bit.
09:25:25 <quicksilver> skorpan: that's enough to write a naive interpreter.
09:25:27 <skorpan> quicksilver: sure, i'm just saying that from an AST you can do anything
09:25:36 <quicksilver> sure.
09:25:43 <quicksilver> with a chisel and a mountain you can make anything, too.
09:25:47 <quicksilver> that 'anything' remains the hard part.
09:25:56 <quicksilver> optimisation, choice of intermediate language, code generation.
09:26:02 <Alpounet> indeed, that's the part I wuold like to learn
09:26:59 <skorpan> why not take baby steps?
09:27:19 <skorpan> develop a lexer/parser (with alex, happy, bnfc, whatever)
09:27:43 <Alpounet> done in OCaml (it won't be that hard to translate in Haskell)
09:28:24 <Alpounet> not for the real language I want to create but a minimal subset
09:28:45 <Alpounet> That's more the real-code-generation that annoy me for the moment
09:28:47 <skorpan> so then you probably want to translate that into at least one intermediate language
09:29:04 <skorpan> you make a bunch of translations and then eventually into assembly code
09:29:47 <Alpounet> But in that book does it explain translation stage and then assembly generation stage?
09:30:23 <skorpan> haven't read the book, i'm just telling you what i learned from the compiler construction course i took :P
09:30:56 <Alpounet> ok ;)
09:33:44 <iago_> chrisdone, /usr/bin/runhaskell
09:34:07 <iago_> or runghc
09:34:11 <pejo> Alpounet, the assembly generation stage is explained in any book on compiler construction.
09:34:17 <Alpounet> ok
09:42:42 <Olathe> > computerTurnedOn
09:42:44 <lambdabot>   * Exception: "<IO Bool>"
09:45:07 <wjt> @index computerTurnedOn
09:45:07 <lambdabot> bzzt
09:45:09 <wjt> :(
09:45:55 <HugoDaniel> sometimes my functions have lots of args... is there any easy way to solve this ?
09:46:00 <HugoDaniel> hmm ill try a state monad
09:47:31 <Taejo> :t >=>
09:47:32 <lambdabot> parse error on input `>=>'
09:47:34 <Taejo> :t (>=>)
09:47:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:47:57 <paper_cc> @index >=>
09:47:57 <lambdabot> bzzt
09:48:02 <paper_cc> @index (>=>)
09:48:02 <lambdabot> bzzt
09:48:10 <Taejo> paper_cc: I imagine Control.Monad
09:48:16 <Taejo> @hoogle >=>
09:48:16 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:49:24 <conal> @seen kosmikus
09:49:25 <lambdabot> kosmikus is in #gentoo-haskell, #ghc, #darcs and #haskell. I don't know when kosmikus last spoke.
09:51:10 <Taejo> @hoogle (a -> m b) -> (b -> c) -> m c
09:51:10 <lambdabot> No results found
09:52:44 <Taejo> @hoogle (b -> c) -> (a -> m b) -> m c
09:52:45 <lambdabot> No results found
09:53:05 <michaelcdever> i cant believe i basically have to change my whole program to use gtk2hs 0.19
09:53:09 <michaelcdever> *0.10
09:53:23 <dcoutts_> michaelcdever: really? what was so different?
09:53:36 <Olathe> > 64%36
09:53:38 <lambdabot>   16%9
09:54:03 <Botje> @pl \(a,b) -> foo b >>= \x -> return (a, x)
09:54:03 <lambdabot> uncurry (flip ((>>=) . foo) . (return .) . (,))
09:54:33 <michaelcdever> none of my list store stuff works at all, a lot of methods acoss the whole thing has changed, i just finished it yesterday, installed 0.1 today, and ive been trying to solve errors all afternoon
09:55:33 <BMeph> :t return . (>>=)
09:55:34 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m1, Monad m) => m1 a -> m ((a -> m1 b) -> m1 b)
10:09:53 <agruman> i get "Warning: Pattern match(es) are overlapped In a case alternative: _ -> ..." but i only have one "_" case and all other are distinct, any hints on what i might be doing wrong?
10:10:04 <michaelcdever> rrrr
10:10:24 <burp_> hi :>
10:10:39 <dolio> What do your other cases look like?
10:10:53 <burp_> "if length r > 0 then return Nothing" <- what's wrong there? ghc complains about wrong indention
10:11:12 <iago_> burp_, do you have an else branch?
10:11:16 <burp_> no
10:11:18 <iago_> :)
10:11:22 <iago_> this is the problem
10:11:24 <burp_> ok :)
10:11:30 <Cheshire> :t when
10:11:32 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:11:38 <pejo> agruman, perhaps you listed all the alternatives and had a _ as well?
10:11:47 <agruman> dolio they are of a defined data type ex "ExpMul e1 e2 -> ..."
10:11:51 <iago_> GHC syntax errors are shitty..., forget the "perhaps wrong identation" message burp_
10:12:08 <agruman> pejo, that might well be the case
10:12:18 <burp_> right: if length r > 0 then return Nothing else return $ Just "foo"
10:12:20 <burp_> this works :)
10:12:32 <dolio> agruman: Might be easier to diagnose if you pasted the case expression on hpaste.
10:13:16 <iago_> burp_, and if in Haskell is not like in imperative languages, an if is an expression that depends on some boolean condition, you have to specify the expression in both cases
10:13:17 <burp_> and in case of a newline the else has to be more indented than the if
10:13:38 <burp_> iago_, true
10:13:42 <agruman> dolio, yes i know :) but pejo already stated the cause :)
10:13:49 <dolio> Ah, okay.
10:14:24 <Taejo> :t intercalate
10:14:25 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:14:27 <burp_> still trying to forget the imperative way =)
10:14:41 <iago_> if condition
10:14:46 <iago_>     then ....
10:14:50 <iago_>     else .....
10:15:02 <iago_> for example
10:15:27 <iago_> (for the indentation problem when you have an if in several lines)
10:15:37 <agruman> http://en.wikibooks.org/wiki/Programming:Haskell_indentation
10:15:55 <burp_> thanks, that makes sense
10:17:15 <michaelcdever> in gtk2hs 0.10 does anyone know, if i wanted to have a liststore of [icon,text] how would i go about it? I used to do list <- listStoreNew [TMobject,TMstring] but nothing i do seems to work now
10:18:01 <agruman> i have a some recursive functions that call each other (parsing a tree) and ive found a strange case where it loops forever even though it should't, now i cant find the line with the error :( is there some "nice" way in which i can do this?
10:19:13 <dcoutts_> michaelcdever: sounds like you were using the old style list store previously.
10:19:21 <dcoutts_> michaelcdever: the new style is much nicer and typed
10:19:34 <michaelcdever> apparently so, and i cant get my head around the new style :(
10:19:58 <dcoutts_> michaelcdever: you just keep your store type as a Haskell type, eg (Icon, String)
10:20:15 <dcoutts_> michaelcdever: or rather the store is parameterised by your store type
10:20:26 <dcoutts_> michaelcdever: see the demos
10:20:56 <michaelcdever> ive been trying to do that, i.e list <- [(GVobject,GVstring)] but no joy
10:21:11 <dcoutts_> no no, not GV blah
10:21:34 <dcoutts_> none of the demos use that, look at the current demo/treeList/ListDemo.hs
10:23:58 <michaelcdever> ah ok, i think i see it, so if i just make my list, and then do listStoreNew list, but one of my problems is that my icon is a pixbuf, and i cant see how to work that into it
10:26:01 <michaelcdever> ah ok i think i have it now, i do cellRenderPixbuf new like before, and add in from there
10:29:32 <michaelcdever> dcoutts_: is there a cellLayout attribute for cellPixbuf?
10:30:35 <michaelcdever> nevermin, i found it
10:30:38 <dcoutts_> michaelcdever: the CellRendererPixbuf type has a cellPixbuf
10:31:53 <michaelcdever> yep just saw it there, think i can sort it now, thanks
10:39:39 <gwern> My fellow haskellers! I'm glad to announce that I've signed legislation outlawing destructive updates forever. We begin bombing in five minutes.
10:40:14 <kaol> @go land of lisp
10:40:15 <lambdabot> http://www.lisperati.com/landoflisp/panel01.html
10:47:11 <drhodes> is there a type of Thing which has a function f and with it an inverse to f?  something like,  data Thing=Thing{ func::(a->b), cnuf::(b->a) }  , then declare a class Inversable where inverse and justTheFunc, but it's not working because I don't think that's the way it's supposed to be done.
10:49:43 <Cheshire> drhodes, I'd go   type a :<->: b = (a -> b, b -> a)
10:49:57 <Cheshire> but you need LANGUAGE TypeOperators I think
10:50:02 <drhodes> :t (:<->:)
10:50:04 <lambdabot> Not in scope: data constructor `:<->:'
10:50:12 <Cheshire> drhodes, I just gave a definition of it,
10:50:16 <Cheshire> it's got kind  * -> * -> *
10:50:25 <Apocalisp> Lens?
10:57:58 <drhodes> I think I was looking for Data.Bijection.
10:58:13 <drhodes> type :<->: a b = Bijection (->) a b
10:58:27 <BMeph> drhodes: So, you're telling us that you're Data.Bijection-curious? ;)
10:59:45 <michaelcdever> dcoutts is there a way to convert a TreeModel to ListStore anymore list castToListStore in the previous library
11:00:43 <dcoutts_> michaelcdever: no, keep the ListStore around. It's the typed one. The TreeModel is untyped so you cannot use that to modify the data.
11:01:14 <michaelcdever> cool ok thats what i though
11:03:00 <BMeph> drhodes: Check out: http://twan.home.fmf.nl/blog/haskell/References-Arrows-and-Categories.details
11:04:00 <cjay> is there any reason there is no ghc-6.10.x available in freebsd packages/ports? Will building it by hand work?
11:05:02 <drhodes> BMeph: Arrows, yeah, I'm too stupid for those, maybe in a couple decades after monads sink in, I'll brave those thorny bramble of syntax trickery.
11:06:04 <pastah> is there any way to make a function "puts" (like gets) for State
11:06:07 <pastah> e.g:
11:06:14 <pastah> modEnv sel m = \e -> e { sel = m (sel e) }
11:06:28 <pastah> modEnv :: (Env -> a) -> (a -> a) -> Env -> Env
11:06:52 <pastah> is there some cool extension i could use that will allow this?
11:07:34 <BMeph> drhodes: It's not too tough, and I think you'll appreciate the blog posts. :)
11:08:16 <mdiin> mq/j #gtk2hs
11:08:21 <mdiin> Gah, sorry
11:09:06 <mdiin> Is there a channel for gtk2hs?
11:16:22 <bvck> Hi folks! A quick question on partial function application.
11:16:29 <Cale> bvck: sure :)
11:16:51 <bvck> (++) "\n" "1" gives different results from (++ "\n") "1"
11:16:53 <b0fh_ua> Hello! Can somebody please explain, when there is the statement in the Haskell tutorial, which looks like this : (a -> Bool) -> [a] -> [a] - what exactly does these arrows mean?
11:17:21 <ArneB> bvck: (++ "\n") has "\n" as the second argument.
11:17:30 <Cale> bvck: Right, because (++ "\n") means (\x -> x ++ "\n")
11:17:34 <ArneB> ("\n" ++) would have it as the first argument.
11:17:46 <Cale> You probably mean ((++) "\n") "1"
11:17:47 <bvck> ArneB, got it. Thanks.
11:17:55 <Cale> Or yeah, what ArneB said :)
11:18:28 <Cale> b0fh_ua: If A and B are types, then A -> B is the type of functions which take a parameter of type A and produce a result of type B
11:19:01 <Cale> b0fh_ua: (->) associates to the right, so A -> B -> C means A -> (B -> C)
11:19:19 <Cale> which is something that takes a parameter of type A, and a parameter of type B, and gives a result of type C
11:19:34 <Cale> Or, takes just a parameter of type A, and produces a function B -> C
11:19:43 <Cale> b0fh_ua: Does that help?
11:19:56 <b0fh_ua> Cale: let me think for a second )
11:20:20 <Cale> b0fh_ua: So a function of type (a -> Bool) -> [a] -> [a] is something which takes a function a -> Bool as its first parameter, and then a list of a's, and gives a list of a's
11:20:49 <Cale> Alternately, you can think of it as taking a function (a -> Bool), and producing a function from lists of a's to lists of a's.
11:21:05 <b0fh_ua> that makes much more sense
11:21:27 <Cale> They're the same thing in Haskell.
11:21:35 <Cale> When you write f x y z
11:21:42 <Cale> it parses as ((f x) y) z
11:21:47 <kosmikus> conal: pong?
11:22:02 <Cale> All functions really have exactly one parameter :)
11:22:14 <b0fh_ua> Cale: oh!
11:22:21 <conal> kosmikus: i sent you email about a possible lhs2TeX bug.
11:22:23 <Cale> and those which appear to take more really just produce other functions
11:22:24 <b0fh_ua> thank you, so it's just a lambda
11:22:59 <conal> kosmikus: to your lhs2tex@ address
11:23:15 <Cale> Well, if x :: A and y :: B, then (\x -> y) :: A -> B
11:23:24 <kosmikus> conal: oh, ok
11:24:22 <conal> kosmikus: btw, i really appreciate lhs2tex!
11:24:58 <b0fh_ua> Cale: so in general the arrow "->" means (we take some type A and as a result we are getting the type "B")
11:25:04 <Cale> b0fh_ua: right
11:25:10 <kosmikus> conal: actually, I'm not sure if it's a bug or just vaguely documented
11:25:14 <b0fh_ua> and it is being evaluated from left to right
11:25:30 <b0fh_ua> and (...) means a call to a function
11:25:49 <Cale> Well, " " means function application ;)
11:25:59 <kosmikus> conal: these parts have all been written by Ralf Hinze originally, and I've only tried to document them, but I don't know what the intended behaviour was originally
11:26:12 <Cale> That is f x means the function f applied to x
11:26:26 <conal> kosmikus: hard for me to imagine that the current behavior would ever be what one wanted.
11:26:53 <Cale> But function application associates to the left, which just means that things group like: f x y z = ((f x) y) z
11:27:00 <kosmikus> conal: no, probably not. but it might be tricky to change.
11:27:10 <kosmikus> conal: I'll have a look, though.
11:27:24 <Cale> and correspondingly, -> at the type level associates to the right: A -> B -> C -> D = A -> (B -> (C -> D))
11:27:36 <conal> kosmikus: thanks. :)
11:27:45 <Cale> But I think you get the idea :)
11:27:48 <kosmikus> conal: as a future-proof workaround, you could write ((mu ma) k)
11:28:11 <conal> kosmikus: oh!  that's a better workaround than mine.
11:28:34 <b0fh_ua> Cale: that's not clear again - f x y z = ((f x) y) z - does this mean we are avaluating a function f with argument x - but what are we doing with argument y?
11:28:43 <b0fh_ua> or "y" is a function itself?
11:28:46 <Cale> (f x) will be another function
11:28:54 <Cale> and we're applying it to y
11:29:03 <Cale> and then ((f x) y) is again a function
11:29:07 <Cale> which we apply to z
11:29:17 <kosmikus> conal: btw, can I convince you to come to the Hackathon?
11:29:38 <b0fh_ua> Cale: mmm, weird. May be you could give me some simple example? ) I'm a bit lost - but excited )
11:29:41 <Cale> okay
11:29:43 <Gracenotes> b0fh_ua: if f is a function of type (String -> Int -> [Int] -> Char), for example, (f x) is (Int -> [Int] -> Char) because x is a string
11:30:01 <Cale> > let addOne = map (+1) in addOne [1,2,3,4]
11:30:02 <Gracenotes> (f x) y is a function of type ([Int] -> Char), if y is an Int
11:30:02 <lambdabot>   [2,3,4,5]
11:30:14 <Cale> b0fh_ua: map normally takes two parameters, yeah?
11:30:25 <Gracenotes> ((f x) y) z of type (Char)... er yeah. Which is a the value you want.
11:30:30 <Cale> b0fh_ua: It takes a function, and a list, and applies the function to each element of the list to give another list.
11:30:38 <kerlo> I'm reading the descriptions of the AP Computer Science A and AB tests.
11:30:38 <conal> kosmikus: would be fun, of course.  i'm not fond of travel (airplane/height discomfort), and i'm paying my own way to events these days.
11:30:47 <b0fh_ua> sounds familiar
11:30:58 <Cale> or perhaps simpler...
11:31:04 <kerlo> My rough understanding is Computer Science AB = Computer Science A + basic Haskell. :-P
11:31:05 <Cale> (+) :: Integer -> Integer -> Integer
11:31:20 <Cale> Which is: (+) :: Integer -> (Integer -> Integer)
11:31:27 <Cale> So if we apply (+) to just one parameter
11:31:31 <kosmikus> conal: yes, I can certainly understand the airplane thing
11:31:38 <Cale> > let addOne = (+) 1 in addOne 5
11:31:39 <lambdabot>   6
11:31:52 <Gracenotes> computer science I, II, and III in my school is aaalll java
11:32:12 <Cale> We get a function of type (Integer -> Integer) which when applied to an integer, adds that number to it.
11:32:17 <Gracenotes> thankfully I only have to take the latter two.
11:32:23 <kerlo> Gracenotes: what type of school is it?
11:32:29 <b0fh_ua> huh
11:32:45 <Gracenotes> kerlo: public state school in New York. It is a good computer science program, though
11:32:57 <Gracenotes> the theory classes use SML
11:33:12 <Cale> b0fh_ua: Every function which appears to take more than one parameter is really just taking one parameter and returning another function which takes the next.
11:33:12 <kerlo> > let add = \x -> (\y -> x + y) in map (add 3) [4,5,6]
11:33:14 <Gracenotes> there's C and C++ stuff, as well as assembly
11:33:14 <lambdabot>   [7,8,9]
11:33:26 * kerlo suddenly gets an idea
11:33:30 <Gracenotes> and a programming language course with ML, LISP, other stuffs
11:33:40 <Cale> > let add x y = x + y in map (add 3) [4,5,6]
11:33:41 <lambdabot>   [7,8,9]
11:33:48 <kerlo> > let add = \a -> (\b -> a + b) in add x
11:33:49 <lambdabot>       Overlapping instances for Show (Expr -> Expr)
11:33:49 <lambdabot>        arising from a use...
11:33:57 <kerlo> Overlapping instances? Come on!
11:34:07 <Cale> :t let add = \a -> (\b -> a + b) in add x
11:34:08 <lambdabot> Expr -> Expr
11:34:15 <LeoD> the x
11:34:17 <Cale> :t let add = \a -> (\b -> a + b) in add 5
11:34:18 <lambdabot> forall t. (Num t) => t -> t
11:34:24 * b0fh_ua is trying to understand
11:34:30 <Cale> :t let add a b = a + b in add 5
11:34:31 <lambdabot> forall t. (Num t) => t -> t
11:34:59 <burp_> how can I use catch with own types? I have "type Net = ReaderT Bot IO" and want to use catch on a Net computation
11:35:04 <Cale> Excuse the polymorphism there... "(Num t) =>" just means that t must be some numeric type.
11:35:44 <burp_> :t Control.Exception.catch
11:35:45 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
11:35:55 <kerlo> b0fh_ua: you may or may not find this useful: http://en.wikipedia.org/wiki/Currying
11:35:55 <Cale> burp_: Usually it has to be adapted somewhat because the default catch wants a function which produces an IO action.
11:36:24 <Cale> burp_: So you need one which will use runReader on its parameter.
11:36:29 <burp_> hm ok
11:36:51 <Gracenotes> or some odd combination of liftIO... might work
11:37:07 <Cale> liftIO doesn't quite do it.
11:37:10 <Gracenotes> either way some runReaderT will probably be used?
11:37:15 <Cale> yeah
11:37:30 <Gracenotes> but liftIO is definitely more fine-grained
11:37:45 <Saizan> ?type \m h -> do e <- ask; liftIO (catch (runReaderT m e) (flip runReaderT e . h))
11:37:47 <lambdabot> forall (t :: * -> *) r a. (MonadIO t, MonadReader r t) => ReaderT r IO a -> (IOError -> ReaderT r IO a) -> t a
11:37:57 <Gracenotes> so you don't have to do the whole damn computation, it can be segmented. Readers are quite flexible, immutability, etc.
11:38:04 <b0fh_ua> Cale: okay, I trying to follow you at "let add x y = x + y in map (add 3) [4,5,6]". so am I correct if I would say there is the function "add" which takes 2 parameters. when this function is applied to a map with map (add 3) [1,2,3,4] - this mean the program will subsequently call function "add" with the first argument 3 and last argument being taken from the list?
11:38:19 <Cale> b0fh_ua: yeah.
11:38:25 <Cale> add is being applied to 3
11:38:34 <kerlo> @src map
11:38:34 <lambdabot> map _ []     = []
11:38:34 <lambdabot> map f (x:xs) = f x : map f xs
11:38:39 <Cale> and the result is a function which takes a parameter y and gives 3 + y
11:38:50 <Cale> and then that's being mapped over the list
11:39:03 <Cale> > let add x y = x + y in (add 3) 4
11:39:04 <lambdabot>   7
11:39:26 <Cale> maybe a simpler example, but perhaps not as clear that the function (add 3) is actually meaningful on its own there
11:39:28 <burp_> Saizan, you suggest something like that?
11:39:41 <Cale> > let add x y = x + y; addThree = add 3 in addThree 5
11:39:42 <lambdabot>   8
11:40:57 <b0fh_ua> so addThree is expanded to (add 3) 5, right?
11:41:10 <Cale> yeah
11:42:00 <Cale> addThree 5 -> (add 3) 5 -> 3 + 5 -> 8
11:42:50 <b0fh_ua> nice!
11:42:51 <Gracenotes> > let add x y = x + y; addThree = add 3 in iterate reduce (addThree 5)
11:42:52 <lambdabot>   [3 + 5,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,...
11:43:01 <Gracenotes> heh.. not so helpful this time
11:43:09 <Cale> heh
11:43:10 <b0fh_ua> looks like I started to understand
11:43:29 <kerlo> @t reduce
11:43:29 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:43:30 <sbahra> :t reduce
11:43:31 <lambdabot> Expr -> Expr
11:43:41 <kerlo> What takes the derivative of an Expr?
11:44:22 <Gracenotes> > iterate reduce (foldr (+) 0 [1..5])
11:44:23 <lambdabot>   [1 + (2 + (3 + (4 + (5 + 0)))),1 + (2 + (3 + (4 + 5))),1 + (2 + (3 + 9)),1 ...
11:44:31 <drhodes> > (let f a b c d = a + b + c + d in f) 3 5 7 11
11:44:31 <sbahra> aga
11:44:32 <lambdabot>   26
11:44:32 <Gracenotes> > iterate reduce (foldr (+) 0 [1..4])
11:44:34 <lambdabot>   [1 + (2 + (3 + (4 + 0))),1 + (2 + (3 + 4)),1 + (2 + 7),1 + 9,10,10,10,10,10...
11:44:34 <sbahra> cool
11:44:38 <sbahra> very nice
11:44:59 <kerlo> @hoogle deriv :: Expr -> Expr
11:45:04 <lambdabot> Warning: Unknown type Expr
11:45:05 <sbahra> > iterate reduce (foldr (+) 0 [1..4])
11:45:06 <lambdabot> No results found
11:45:08 <lambdabot>   [1 + (2 + (3 + (4 + 0))),1 + (2 + (3 + 4)),1 + (2 + 7),1 + 9,10,10,10,10,10...
11:45:10 * kerlo frowns
11:45:24 <sbahra> > iterate reduce (foldl (+) 0 [1..4])
11:45:25 <lambdabot>   [0 + 1 + 2 + 3 + 4,1 + 2 + 3 + 4,3 + 3 + 4,6 + 4,10,10,10,10,10,10,10,10,10...
11:45:27 <kerlo> @src (Expr -> Expr) show
11:45:27 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:45:39 <maxote> hello, how to get the continued fractions of the sqrt'ed numbers?
11:45:43 <kerlo> @index Expr
11:45:43 <lambdabot> bzzt
11:45:57 <kerlo> maxote: that's more of a math question than a Haskell question, isn't it?
11:46:23 <maxote> yes kerlo
11:47:56 <Cale> You mean like, given the continued fraction of a number, how do you find the continued fraction of its square root? That would be interesting.
11:48:29 <maxote> Cale, it's misterious, xD
11:49:08 <kerlo> I was expecting that maxote was looking for the continued fraction of the square root of an integer.
11:49:09 <Cale> Well, of course you can do it the easy way, but it would be nice if there were a simple formula.
11:49:12 <maxote> i think Ramanujan knew much of continued fractions
11:49:23 <kerlo> A non-negative integer, hopefully. :-P
11:49:47 <kerlo> Indeed, I think Ramanujan was the infinite expressions guy.
11:50:12 <maxote> + infinite lists (from lazy lang) = bingo!
11:51:24 <kerlo> > sum (map (2^) [0..])
11:51:27 <Cale> I believe when n is a positive integer, the continued fraction for sqrt(n) will be periodic.
11:51:43 <kerlo> Cale: correct.
11:51:51 <b0fh_ua> I should read the article http://en.wikipedia.org/wiki/Currying first
11:52:00 <mauke> possibly related: http://blog.plover.com/math/attractors.html
11:52:05 <kerlo> Is lambdabot ignoring me, or just taking an unusually long time to give up?
11:52:32 <Gracenotes> kerlo: 1. it's infinite 2. it diverges, anyway :)
11:52:41 <maxote> kerlo, there is a divergence in the sum
11:52:43 <mauke> @bot
11:52:43 <lunabot>  :)
11:52:44 <kerlo> Gracenotes: no, -1!
11:52:53 <kerlo> > sum (map (2^) [0..4])
11:53:01 <mauke> kerlo: looks like it's dead
11:53:08 <kerlo> @eval sum (map (2^) [0..4])
11:53:08 <sbahra> @botsnack
11:53:08 <lunabot>  :)
11:53:16 <kerlo> @eval 45
11:53:17 <Gracenotes> looks like someone's been feeding it some Special Omega
11:53:18 * drhodes casts resurrect lambdabot 
11:53:22 <mauke> , sum (map (2^) [0..])
11:53:24 <sbahra> , sum (map (2^) [0..4])
11:53:25 <lunabot>  31
11:53:27 <lunabot>  luna: out of memory (requested 1048576 bytes)
11:53:32 <kerlo> There we go.
11:53:41 <kerlo> Haskell isn't very good at taking infinite sums.
11:53:45 <quicksilver> Cale: "Lagrange proved the converse of Euler's theorem: if x is a quadratic irrational, then the regular continued fraction expansion of x is periodic"
11:53:47 <kerlo> Mathematica is better, I believe.
11:53:50 <sbahra> kerlo, ?
11:53:59 <sbahra> What do you mean it isn't good at taking infinite sums?
11:54:14 <kerlo> sum xs, where xs is an infinite list, does not terminate.
11:54:22 <mauke> kerlo: it's very good at it; it just doesn't stop :-)
11:54:40 <maxote> kerlo, none is good at taking divergenced infinite sums, little or none is good at taking convergenced infinite sums.
11:54:56 <mauke> , scanl (+) 0 (map (^2) [0..])
11:54:58 <lunabot>  [0,0,1,5,14,30,55,91,140,204,285,385,506,650,819,1015,1240,1496,1785,2109...
11:55:13 <Cale> maxote: Computer algebra systems can take convergent infinite sums algebraically.
11:55:15 <lambdabot> :)
11:55:15 <lambdabot> :)
11:55:20 <kerlo> mauke: (2^), not (^2).
11:55:21 <lambdabot>   31
11:55:22 <Gracenotes> kerlo: ioh dear
11:55:26 <mauke> , scanl (+) 0 (map (2^) [0..])
11:55:27 <lunabot>  [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,13107...
11:55:41 <kerlo> I guess the sequence 1, 3, 7, 15, 31, . . . does approach -1. It just does so using an unusual metric, is all.
11:55:58 <sbahra> > 1 + 1
11:56:00 <lambdabot>   2
11:56:04 <mauke> it's just two's complement
11:56:05 <sbahra> @botcrack
11:56:05 <lambdabot> :)
11:56:05 <lunabot>  :)
11:56:08 <Cale> kerlo: 2-adic numbers
11:56:12 <Gracenotes> what, kerlo? Can I have some of your drugs?
11:56:16 <Gracenotes> >_>
11:56:24 <mauke> Gracenotes: look at the bit patterns
11:56:43 <kerlo> I think that for all n, if 1, 3, 7, 15, 31, . . . converges modulo n, it converges to -1 modulo n.
11:57:00 <Gracenotes> mauke: sorry, what?
11:57:07 <Cale> hmm... I'm not so sure about that.
11:57:11 <kerlo> Gracenotes: look at the numbers in binary.
11:57:39 <kerlo> 1, 3, 7, 15, 31, . . . in binary is 1, 11, 111, 1111, 11111, . . . in binary.
11:57:43 <Gracenotes> yes, if you're doing anything finite. Which Integer, the default integer type, isn't
11:58:07 <mauke> but the universe uses two's complement
11:58:08 <Gracenotes> am I missing something....? :/
11:58:24 <kerlo> And one way of writing -1 in binary is ...11111, you know. After all, ...11111 + 1 = ...00000, which is obviously the same as 0. Maybe.
11:58:29 <mauke> therefore an infinite number of 1 bits is -1
11:58:59 <Gracenotes> well, depending on the system you're using. is there an analogue of this in decimal?
11:59:03 <Cale> Look up p-adic metric
11:59:03 <kerlo> Gracenotes: well, I did say "using an unusual metric". 1, 3, 7, 15, 31, . . . doesn't converge if you consider the distance between two numbers to be the absolute value of their difference.
11:59:17 <kerlo> Yes, the analogue in decimal is the 10-adic numbers.
11:59:26 <Gracenotes> by system I mean sign/magnitude vs. two's complement vs. etc.
11:59:30 <Cale> In this case, it's the 2-adic metric that you're using.
11:59:53 <kerlo> That would be 9 + 90 + 900 + 9000 + 90000 + . . . = ...99999 = -1.
12:00:19 <mdmkolbe> @hoogle Maybe (a -> b) -> Maybe a -> Maybe b
12:00:19 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:00:19 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:00:19 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:00:54 <Gracenotes> are there any papers, Wikipedia articles about this?
12:01:01 <Cale> For any rational number x, there is a unique integer n such that x = 2^n (a/b) where neither a nor b is divisible by 2.
12:01:08 <qloop> I'm having some 'instance Num Magic where' where Magic has (amongst others) a Float and Int constructor, and I need to define some operator on both the Float and the Int constructor, how do I do this (without conflicting definitions)?
12:01:14 <Cale> Define |x|_2 = 2^(-n)
12:01:18 <kerlo> Gracenotes: http://en.wikipedia.org/wiki/1_%2B_2_%2B_4_%2B_8_%2B_%C2%B7_%C2%B7_%C2%B7 is one.
12:01:35 <mauke> qloop: in the normal way
12:01:43 <kerlo> http://en.wikipedia.org/wiki/P-adic_number is another.
12:01:47 <Gracenotes> I thought it diverged :/ odd, odd
12:01:48 <mauke> qloop: what's the problem?
12:01:49 <Cale> Then we can define a metric d_2(x,y) = |x-y|_2
12:02:52 <Cale> and note that (2^(n+1) - 1) - (2^n - 1) = 2^n
12:02:55 <Gracenotes> qloop: try pattern matching
12:02:57 <kerlo> There's a fancy pastebin that runs your Haskell code, isn't there?
12:03:04 <qloop> mauke: instance Num Magic where (+) (FLOAT a) (FLOAT b) = FLOAT(a + b) --> (+) (INT a) (INT b) = INT(a+b)
12:03:05 <Gracenotes> code..something
12:03:08 <qloop> is conflicting
12:03:11 <b0fh_ua> "count2 p l = foldr (\x c -> if p x then c+1 else c) 0 l" - with this function what the argument "c" is?
12:03:12 <kerlo> codebin?
12:03:13 <mauke> qloop: no, it isn't
12:03:15 <qloop> I'd make it generic
12:03:18 <qloop> hhm
12:03:19 <Cale> and so d_2(2^(n+1) - 1, 2^n - 1) = 2^(-n)
12:03:22 <qloop> lemme paste
12:03:37 <mauke> b0fh_ua: c is the current list element
12:03:47 <Gracenotes> codepad!
12:03:50 <Gracenotes> @kerlo
12:03:50 <lambdabot> the fractal is 5 irrationals
12:03:51 <mauke> b0fh_ua: er, sorry
12:03:53 <Cale> which tends to 0 as n -> infinity -- so at least adjacent elements of the sequence are getting close together :)
12:03:57 <Gracenotes> :/
12:03:58 <mauke> b0fh_ua: c is the accumulator
12:03:59 <prb> Is there a way to set RTS flags for cabal?  I keep getting out of memory errors.  (Tried passing +RTS -H256M -RTS and --ghc-options=-H256M.)
12:04:08 <qloop> mauke: you'd say that should work?
12:04:09 <maxote> > (sum (map (2^) [-1,-2,-3..])) < 1
12:04:10 <lambdabot>   <no location info>: parse error on input `..'
12:04:12 <Cale> Moreover...
12:04:14 <Gracenotes> @lambdabot
12:04:14 <lambdabot> Unknown command, try @list
12:04:21 <kerlo> Aha!
12:04:26 <burp_> ok, I made a workaround to just catch the IO action part :=)
12:04:27 <mauke> qloop: yes (but it doesn't handle the FLOAT + INT case)
12:04:32 <Cale> d_2(2^n - 1, -1) = |(2^n - 1) - (-1)|_2
12:04:35 <maxote> > (sum (map (2^) [-1,-2,-3,..])) < 1
12:04:36 <lambdabot>   <no location info>: parse error on input `..'
12:04:40 <Cale> = |2^n|_2
12:04:43 <Cale> = 2^(-n)
12:04:47 <Cale> which is going to 0
12:05:01 <b0fh_ua> mauke: I'm not sure. It is not defined anywhere, and as far as I udnerstood the function "\x c -> if p x then c+1 else c" takes 2 parameters?
12:05:02 <Cale> So {2^n - 1} -> -1 in the 2-adic metric.
12:05:13 <Gracenotes> maxote: the only patterns recognized are [a..], [a..b], [a,s..], and [a,s..b]
12:05:18 <kerlo> Speaking of @kerlo, is there a way to get irssi to treat my nick in the middle of a message the same way as it does my nick at the beginning of a message?
12:05:23 <mauke> b0fh_ua: that is, at the end of the list, c will be the second argument to foldr (which is 0 here); otherwise it will be the result of the foldr of the tail of the list
12:05:32 <Riastradh> So how come I can't write [1, 2, 4..] and get a geometric sequence?
12:05:33 <Badger> kerlo: /hilight kerlo?
12:05:39 <Gracenotes> Cale: interesting
12:06:01 <maxote> > (sum (map (2^) [-1,-2..])) < 1
12:06:20 <b0fh_ua> hm
12:06:29 <lambdabot>   mueval: Prelude.read: no parse
12:06:32 <Gracenotes> Riastradh: arithmetic only :) it's sugar for enumFrom, enumFromTo, etc.
12:06:45 <maxote> what means mueval?
12:06:49 <Gracenotes> > enumFromToThen 1 3 10
12:06:52 <lambdabot>   Not in scope: `enumFromToThen'
12:06:55 <Gracenotes> :(
12:07:01 <flx_> riastradh, indeed, similarly as [2, 3, 5, 7, 11..] should result in the shortest ever prime number generator..
12:07:05 <mauke> b0fh_ua: that particular foldr either returns c+1 or c, so for each element it either increments the accumulator or leaves it unchanged
12:07:05 <Gracenotes> > enumFromThenTo 1 3 10
12:07:07 <lambdabot>   [1,3,5,7,9]
12:07:25 <Riastradh> And when will `sum' handle summable sequences in arbitrary Banach spaces?
12:07:28 <kerlo> Can I use newtype, record syntax, and deriving all together?
12:07:34 <CTA> Heyy
12:07:36 <mauke> kerlo: yes
12:07:37 <asgaroth> maxote: It's a package for safely evaluating untrused haskell code iirc.
12:07:38 <kerlo> Badger: I don't think that does quite the same thing.
12:07:44 <Gracenotes> kerlo: with a GHC extension
12:08:11 * kerlo sets /hilight the
12:08:18 <Badger> kerlo:
12:08:19 <Badger> 21:07:55 Hilight lines that have "mynick" word:
12:08:19 <Badger> 21:07:55   /HILIGHT mynick
12:08:35 <b0fh_ua> mauke: so the c is nothimg more than initial value, passed to foldr as a second argument?
12:08:57 <mauke> b0fh_ua: it starts as that, yes
12:08:57 <michaelcdever> dcoutts_ got it loading up now but its super buggy!
12:09:00 <Riastradh> flx_, there's a wonderful book by one Carl Linderholm called _Mathematics Made Difficult_.  It has a most delightful section on questions, in IQ tests and the like, of the form `Write the next number in the sequence: x, y, z, _.'
12:09:28 <mauke> b0fh_ua: but for each list element x it's updated by the result of the callback
12:09:28 <qloop> mauke: seems to be solved now... I didn't think whitespace mattered _that_ much :)
12:09:34 <kerlo> Well, all my channels haven't lit up yet. Maybe only one person has said "the" except for the two here who said it.
12:09:35 <b0fh_ua> mauke: that makes much more sense
12:09:41 <b0fh_ua> thanks!
12:10:12 <CTA> if I want to return boolean do I -> Boolean or -> Bool or..?
12:10:15 <Riastradh> One approach is simply to use Lagrange interpolation.  This works beautifully for many sequences.  For example, for 1, 2, 3, it gives 4.  For 2, 4, 6, it gives 8.  For 1, 2, 4, 8, 16, it gives 31.
12:10:56 <mauke> @src Bool
12:10:56 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:11:31 <CTA> isOdd x =
12:11:32 <CTA>   if x % 2 == 0 then
12:11:32 <CTA>     False
12:11:36 <CTA> i get not in scope x
12:11:49 <b0fh_ua> but at this point I am confused about this: the foldr takes a function, a initial valie and a list. the initial value is second argument, and because of the function (which evalueates to the one, which takes an additional argument) - it seems the foldr and the first parameter of foldr (a fucntion) are sharing the same variable?
12:12:06 <Gracenotes> CTA: you also have "else True", right?
12:12:10 <maxote> is arithmetic (descendent/ascendent) progression? [yes/not]  is geometric (asc/desc/converg/diverg) progression? [yes/no] ...
12:12:21 <Gracenotes> CTA: also, the if/else isn't necessary
12:12:22 <CTA> yeah
12:12:36 <maxote> otherwise XXX interpolation
12:12:38 <mauke> CTA: % is not modulo
12:12:44 <CTA> oh
12:12:47 <CTA> what is?
12:12:47 <CTA> mod?
12:12:50 <mauke> yeah
12:12:56 <mauke> :t odd
12:12:56 <Badger> @src mod
12:12:56 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:12:58 <Gracenotes> "if u then False else True" can also be said "not u"
12:12:58 <paper_cc> CTA: well, you can use `mod`
12:12:58 <lambdabot> forall a. (Integral a) => a -> Bool
12:13:01 <Gracenotes> @src not
12:13:01 <lambdabot> not True   =  False
12:13:01 <lambdabot> not False  =  True
12:13:01 <CTA> so x `mod` 2?
12:13:04 <mauke> @index odd
12:13:04 <lambdabot> Prelude
12:13:09 <Gracenotes> CTA: yep
12:13:16 <kerlo> Try isOdd x = not (x `mod` 2 == 0)
12:13:25 <mauke> x `mod` 2 /= 0
12:13:32 <kerlo> Even better.
12:13:35 <vincenz> not . even
12:13:37 <mauke> b0fh_ua: huh?
12:13:37 <paper_cc> > let isOdd = (/= 0) . (`mod` 2) in isOdd 3
12:13:39 <lambdabot>   True
12:13:39 <kerlo> Though I have no idea why it would say x is not in scope.
12:13:44 <b0fh_ua> em
12:13:49 <vincenz> just use 'not . even'
12:13:51 <CTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1773#a1773 i get alot of errors
12:13:57 <kerlo> , let isOdd x = odd x in map isOdd [1,2,3,4]
12:13:59 <lunabot>  [True,False,True,False]
12:14:12 <Gracenotes> paper_cc: you and your fancy pointfree style !!
12:14:15 <mauke> CTA: that looks like a type error
12:14:21 <kerlo> @index Num
12:14:21 <lambdabot> Prelude
12:14:25 <kerlo> @docs Prelude
12:14:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
12:14:34 <maxote> kerlo, i like the spectrum of isOdd for [1...
12:14:40 <maxote> using FFT
12:14:53 <Cheshire> odd = not . not . odd
12:14:57 <paper_cc> CTA: Also, else must be indented more than 'if', and 'then' should be on a line of its own
12:15:01 <tromp_> > 5 .|. 6
12:15:02 <lambdabot>   Add a type signature
12:15:04 <mauke> paper_cc: no, it doesn't
12:15:14 <maxote> armonic is with h or without h?
12:15:14 <tromp_> :t (.|.)
12:15:15 <lambdabot> forall a. (Bits a) => a -> a -> a
12:15:16 <paper_cc> well...?
12:15:20 * paper_cc goes to verify
12:15:23 <tromp_> > 5 .|. 6 :: Word
12:15:24 <lambdabot>   7
12:15:37 <tromp_> > 5 .|. 6 :: Int
12:15:38 <lambdabot>   7
12:15:43 <Gracenotes> the then/else indentation issues annoys me to no end
12:15:47 <kerlo> maxote: you mean the FFT of 1, 0, 1, 0, 1, 0, . . .?
12:15:54 <maxote> yes!
12:15:55 <vincenz> > 5 .|. 6 :: Integer
12:15:56 <Gracenotes> well. hurm.
12:15:56 <lambdabot>   7
12:16:00 <CTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1774#a1774 is that a bit better
12:16:02 <CTA> *?
12:16:17 <kerlo> Well, it's periodic and discrete, so the Fourier transform will also be periodic and discrete, right?
12:16:28 <maxote> so, it can be simplified to a cyclic list
12:16:28 <mauke> CTA: no, it's uglier
12:16:29 <tromp_> > 89324 :: Word8
12:16:30 <lambdabot>   236
12:16:49 <CTA> Well you show me how YOU think it could be pretty
12:16:52 <maxote> size of the cyclic list is based in the spectrum
12:16:58 <tromp_> > 89324 :: Int8
12:16:59 <paper_cc> Gracenotes: I can't read heavy pointfree code, but (/=0).(`mod` 2) looks almost like "is not equal to zero modulo 2" to me - perfectly readable
12:17:00 <lambdabot>   -20
12:17:01 <maxote> of the infinite lists
12:17:01 <mauke> CTA: isOdd x = x `mod` 2 /= 0
12:17:26 <Gracenotes> paper_cc: a typical elitist explanation !!
12:17:30 <maxote> (if the spectrum is finite)
12:17:37 <kerlo> What is the FFT of 1, 0, then?
12:17:40 <b0fh_ua> mauke: let smpl x y = 2*x+y in foldr (smpl) 1 [1,2,3,4] - as far as I understand, this function works like this: it calculates 2*1+1 and stores the result into "accumulator" (3), then calculates 2*3+2 and so on?
12:18:01 <kerlo> @fixity +
12:18:01 <lambdabot> Unknown command, try @list
12:18:03 <mauke> > foldr f z [1,2,3,4]
12:18:03 <tromp_> > foldr f z [a,b,c]
12:18:04 <lambdabot>   f 1 (f 2 (f 3 (f 4 z)))
12:18:05 <lambdabot>   f a (f b (f c z))
12:18:05 <CTA> isOdd :: (Num a) => a -> Bool
12:18:05 <CTA> isOdd x =
12:18:05 <CTA>   x `mod` 2 /= 0
12:18:10 <CTA> I still get errors
12:18:14 <mauke> CTA: WHAT ERRORS
12:18:37 <maxote> if the spectrum is not finite then it's not periodic, its cyclic list is infinite too.
12:18:38 <CTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1775#a1775
12:18:41 <Gracenotes> mod is not defined for all Nums
12:18:52 <Gracenotes> you'll need an Integral
12:19:01 <mauke> b0fh_ua: foldr starts at the end, so the first thing to be computed will be 2*4+1
12:19:01 <CTA> does it have to be Integral a not Num?
12:19:14 <sw17ch> :t mod
12:19:15 <lambdabot> forall a. (Integral a) => a -> a -> a
12:19:20 <CTA> works now
12:19:21 <Gracenotes> CTA: indeed, it tells you in the type ;)
12:19:27 <Gracenotes> and in the error message
12:19:31 <CTA> lol
12:19:35 <b0fh_ua> mauke: and then store the result instead of "1" - right?
12:19:37 <kerlo> @help read
12:19:37 <lambdabot> read "<foo>". Print <foo>
12:19:43 <Gracenotes> typeclasses are kinda confusing.. don't worry about it
12:19:44 <mauke> b0fh_ua: yeah, sort of
12:19:51 <sw17ch> :t x `mod` 2 /= 0
12:19:52 <lambdabot> Bool
12:19:56 <sw17ch> :t \x -> x `mod` 2 /= 0
12:19:57 <lambdabot> forall a. (Integral a) => a -> Bool
12:20:16 <mauke> smpl 1 (smpl 2 (smpl 3 (smpl 4 1)))
12:20:21 <b0fh_ua> mauke: well
12:20:33 <mauke> 2*1 + (2*2 + (2*3 + (2*4 + 1)))
12:21:38 <Gracenotes> > foldr ((+) . (2*)) 1 [1..4] :: Expr
12:21:39 <lambdabot>   2 * 1 + (2 * 2 + (2 * 3 + (2 * 4 + 1)))
12:22:09 <mauke> > let smpl x y = 2*x+y in foldr (smpl) 1 [1,2,3,4] :: Expr
12:22:10 <lambdabot>   2 * 1 + (2 * 2 + (2 * 3 + (2 * 4 + 1)))
12:22:14 <mauke> Expr++
12:22:35 <kerlo> @read "halc\243n"
12:22:35 <lambdabot>  halcn
12:22:40 * kerlo applauds
12:22:43 <b0fh_ua> mauke: but the function is declared as smpl x y = 2*x + y, so why the item of the list is passed to the "x" - but not "y"?
12:22:55 <mauke> b0fh_ua: because that's how foldr works?
12:23:07 <Gracenotes> @help read
12:23:07 <lambdabot> read "<foo>". Print <foo>
12:23:09 <mauke> @src foldr
12:23:09 <lambdabot> foldr f z []     = z
12:23:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:23:13 <Gracenotes> exciting
12:23:21 <kerlo> > "halcón"
12:23:22 <lambdabot>   "halc\243n"
12:23:33 <kerlo> Hey, > is working again.
12:23:46 <tromp_> foldr simply replaces the (:) and [] in your list by other functions
12:23:47 <kerlo> > 1000 + 1000 `mod` 3
12:23:49 <lambdabot>   1001
12:24:05 <Cale> It recovered after someone wrote something that took a long time to fail to evaluate :P
12:24:36 <kerlo> Why did it take so long?
12:24:53 <kerlo> Maybe I should write something that'll take even longer. :-P
12:25:01 <kerlo> @src (^)
12:25:01 <lambdabot> x ^ 0            =  1
12:25:01 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
12:25:01 <lambdabot>   where f _ 0 y = y
12:25:01 <lambdabot>         f x n y = g x n
12:25:01 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
12:25:03 <lambdabot>                       | otherwise = f x (n-1) (x*y)
12:25:05 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
12:25:08 <kerlo> @src (*)
12:25:08 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:25:12 <kerlo> Aha!
12:25:19 <kerlo> @src iterate
12:25:19 <lambdabot> iterate f x =  x : iterate f (f x)
12:25:28 <mauke> > a^11
12:25:29 <lambdabot>   a * a * (a * a) * (a * a * (a * a)) * (a * a * a)
12:25:51 <kerlo> > dropWhile even (iterate (join (*)) 2)
12:25:53 <Gracenotes> heh
12:26:07 <lambdabot>   thread killed
12:26:17 <Gracenotes> > 2^a
12:26:27 <lambdabot>   mueval: Prelude.read: no parse
12:26:34 <Gracenotes> > 11*a
12:26:38 <lambdabot>   11 * a
12:27:00 <tromp_> > 0 + a + 0
12:27:01 <lambdabot>   0 + a + 0
12:27:14 <kerlo> > (-3) `mod` 5
12:27:15 <lambdabot>   2
12:27:16 <paper_cc> > reduce $ 0 + a + 0
12:27:17 <lambdabot>   0 + a + 0
12:27:19 <Gracenotes> > iterate reduce (0 + a + 0)
12:27:20 <lambdabot>   [0 + a + 0,0 + a + 0,0 + a + 0,0 + a + 0,0 + a + 0,0 + a + 0,0 + a + 0,0 + ...
12:27:23 <Gracenotes> :(
12:27:33 <kerlo> > 2 ^ a
12:27:34 <Gracenotes> > iterate reduce (0 + 403892750834275 + 0)
12:27:36 <lambdabot>   [0 + 403892750834275 + 0,403892750834275 + 0,403892750834275,40389275083427...
12:27:44 <lambdabot>   mueval: Prelude.read: no parse
12:27:50 <kerlo> ?
12:27:53 <b0fh_ua> is the ":: Expr" something I could use in ghci to see how the expression is to be evaluated? Or it is the feature of the lambdabot? )
12:28:15 <Gracenotes> it's part of a package you have to install called 'simple-reflect'
12:28:24 <Gracenotes> well, install if you want to use it ;)
12:28:37 <kerlo> > 100 * 100 `mod` 3
12:28:41 <lambdabot>   1
12:28:47 <Gracenotes> it's full of variables that can pretend to be numbers, functions, any random type, etc.
12:29:08 <Gracenotes> > f x
12:29:09 <lambdabot>   Add a type signature
12:29:15 <Gracenotes> > f x :: Expr
12:29:16 <lambdabot>   f x
12:29:50 <Gracenotes> @type let test = f x in (f, x)
12:29:52 <lambdabot> forall a. (SimpleReflect.FromExpr a) => (a, Expr)
12:30:28 <Gracenotes> it's useful sometimes, but lambdabot always has it available
12:31:57 <maxote> can i transform 2^ and [-1,...] to discrete FFT/IFFT operations?
12:32:33 <maxote> to solve the halting problem in the test <1
12:33:10 <b0fh_ua> Gracenotes: do I need to import it somehow?
12:33:26 <drhodes> > map (+1) [1..5] :: expr
12:33:27 <lambdabot>   Couldn't match expected type `expr' against inferred type `[a]'
12:33:47 <Gracenotes> > map (+1) [1..5] :: [Expr]
12:33:48 <lambdabot>   [1 + 1,2 + 1,3 + 1,4 + 1,5 + 1]
12:33:55 <Gracenotes> @where cabal
12:33:55 <lambdabot> http://www.haskell.org/cabal
12:33:55 <drhodes> > map (+1) [1..5] :: Expr
12:33:56 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
12:34:05 <Gracenotes> b0fh_ua: you can use Cabal to install it
12:34:15 <Gracenotes> of course, you do need to install Cabal first :/
12:34:28 <b0fh_ua> Gracenotes: I followed the instructions at http://www.haskell.org/ghc/docs/latest/html/Cabal/builders.html
12:34:34 <b0fh_ua> and looks like it was installed
12:34:56 <Gracenotes> neat. So execute it, "cabal install simple-reflect"
12:34:57 <kerlo> > 1.0 ^ (10^100)
12:34:58 <lambdabot>   1.0
12:35:43 <maxote> > 1 ^ (10 ^ (100^1000))
12:35:46 <Gracenotes> and then, in ghci, "import Debug.SimpleReflect" or ":m +Debug.SimpleReflect"
12:35:58 <lambdabot>   thread killed
12:36:09 <mauke> > 1 ** (10 ** (100**1000))
12:36:10 <lambdabot>   1.0
12:37:33 <burp_> anyone using HDBC here? why does this throw an exception: quickQuery' conn "SELECT message FROM quotes WHERE message LIKE '?'" [toSql "foo"], but message = ? works..
12:37:57 <mauke> the quotes look wrong
12:38:00 <maxote> modify src(^) for  1 ^ x            =  1
12:38:40 <burp_> and message = '?' doesn't work either
12:38:55 <mauke> maxote: I don't like that
12:39:17 <burp_> ok LIKE ? works..
12:39:49 <burp_> I will use "%"++"foo"++"%" then
12:39:54 <Gracenotes> maxote: to what..? 42?
12:40:04 <drhodes> > 1 ^ (-Infinity)
12:40:05 <lambdabot>   Not in scope: data constructor `Infinity'
12:40:25 <kerlo> > fromEnum (toEnum 1000000000000000000000000000000000000 :: Integer)
12:40:27 <lambdabot>   -5527149226598858752
12:40:32 <maxote> > 1 ^ Inf
12:40:33 <lambdabot>   Not in scope: data constructor `Inf'
12:41:00 <Gracenotes> > 1 ** (1/0)
12:41:01 <lambdabot>   1.0
12:41:04 <Gracenotes> > 1 ** (-1/0)
12:41:05 <lambdabot>   1.0
12:41:13 <Gracenotes> > 1 ** (0/0)
12:41:14 <lambdabot>   1.0
12:41:42 <maxote> 1^x=1 if x is not undet.
12:42:15 <Gracenotes> > 1 ** undefined
12:42:16 <lambdabot>   * Exception: Prelude.undefined
12:42:28 <Gracenotes> > 1 ** (let x = x in x)
12:42:30 <maxote> > 1 ^ (0/0)
12:42:31 <lambdabot>   Add a type signature
12:42:43 <lambdabot>   thread killed
12:42:58 <Gracenotes> ^ only works for integer exponents, see?
12:43:00 <Gracenotes> @type (^)
12:43:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:43:12 <Gracenotes> so it's not a concern there
12:43:19 <maxote> > 1 ^ (0/0)
12:43:20 <lambdabot>   Add a type signature
12:43:37 <paper_cc> :t (^)
12:43:38 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:43:43 <paper_cc> :t (^^)
12:43:44 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
12:43:56 <paper_cc> > 1 ^ (0/0) :: Integer
12:43:57 <lambdabot>   Add a type signature
12:44:06 <paper_cc> > 1 ^ (0/0 :: Double) :: Integer
12:44:07 <lambdabot>       No instance for (Integral Double)
12:44:07 <lambdabot>        arising from a use of `^' at <...
12:44:25 <Gracenotes> 0/0 implies fractional *base*
12:44:30 <Elly> @hoogle <$>
12:44:31 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:44:33 <Gracenotes> for ^^ anyway. ^.^
12:44:55 <drhodes> :t (^.^)
12:44:56 <lambdabot> Not in scope: `^.^'
12:45:57 <maxote> > 1 ^ undefined
12:45:58 <lambdabot>   * Exception: Prelude.undefined
12:46:08 <Gracenotes> > let _____ = length "__" in 7 ^_____^ 7
12:46:09 <lambdabot>   148781564719761169591031268174127357033235671715479894989849830508638731542...
12:46:14 <Gracenotes> ^_____^
12:49:29 <b0fh_ua> eigher I did something wrong, but I still can't yse ::Expr. I installed cabal and then did "cabal install simple-reflect"
12:49:43 <Gracenotes> did you import Debug.SimpleReflect?
12:49:52 <bolrod> :t ((^).(^))
12:49:53 <lambdabot> forall b a b1. (Integral b1, Num a, Integral b, Num (b1 -> a)) => a -> b -> b1 -> a
12:50:11 <b0fh_ua> Gracenotes: that's what I'm interested in - how can I configure ghci to always import something on start?
12:50:16 <Gracenotes> function numbers, weirdest thing ever
12:50:41 <Gracenotes> b0fh_ua: ~/.ghci loads on startup
12:51:14 <Gracenotes> you might also want to add :set prompt "ghci> " to avoid things from getting too crowded
12:51:46 <b0fh_ua> Gracenotes: thanks!
12:52:03 <Gracenotes> also... Exprs are all the letters from a to z, which are common variable names. So if you accidentally use a free variable, you'll get a weird expr error
12:52:28 <Gracenotes> > let f x y' = x + y in f 50 40
12:52:29 <lambdabot>   50 + y
12:52:42 <Gracenotes> probably not what you wanted
12:52:50 <Northerngirluk> hay can sum1 private msg me if u knw abt socket programming
12:53:06 <Cheshire> no
12:53:18 <mauke> you give girluks a bad name
12:53:36 <Northerngirluk> what
12:53:38 <Gracenotes> @girl
12:53:39 <lambdabot> I'm in Moscow, Russia
12:53:40 <Northerngirluk> r u talking 2 me
12:53:44 <Gracenotes> @girl
12:53:45 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
12:53:47 <Cheshire> Northerngirluk, the spelling you use is ... ridiculous
12:54:17 <Gracenotes> @. vixen girl19
12:54:18 <lambdabot> what's a program?
12:54:22 <Gracenotes> @. vixen girl19
12:54:22 <lambdabot> I'm sorry, I'm confused.
12:54:23 <Northerngirluk> lisn im new with this chat room
12:54:26 <Gracenotes> @. vixen girl19
12:54:26 <lambdabot> i hate it when i get stuck with chatting with a bot!
12:54:38 <Gracenotes> :(
12:55:22 <Cale> Northerngirluk: On IRC, it's normally considered a courtesy to spell things correctly so that others have an easier time reading them :)
12:55:55 <Northerngirluk> Ok so I am supposed to leave my text language and speak in report way
12:56:12 <Northerngirluk> okay I understand
12:56:16 <mauke> just use normal words
12:56:24 <Gracenotes> @. vixen pl \a -> f a a a a
12:56:25 <lambdabot> wanna hear a story?
12:56:25 <Cheshire> what's "report way"?
12:56:51 <Northerngirluk> have you ever been to a general social chat room, they use this kind of text language
12:57:00 <Cheshire> I try to avoid it :p
12:57:10 <Northerngirluk> when I mean report i just mean correct, long words
12:57:39 <Cheshire> Northerngirluk: btw did you mean socket programming in Haskell or just in general?
12:57:50 <mauke> abbreviations are ok, but spelling "you" as "u" is ridiculous
12:57:58 <Northerngirluk> anyway socket programming in linux
12:58:00 <Cheshire> Northerngirluk: (beause if you know some C .. beejs tutorial is basically the best thing I know)
12:58:11 <Cheshire> And Haskells API is based on that I think
12:58:20 <Cheshire> @go beej socket programming
12:58:21 <lambdabot> http://beej.us/guide/bgnet/
12:58:21 <lambdabot> Title: Beej's Guide to Network Programming
12:58:37 <Northerngirluk> not ridiculas in social chat room but anyway i respect this
12:58:52 <Gracenotes> @. vixen run fix let a = a in a
12:58:53 <lambdabot> I can't of anything nice to say about myself
12:59:04 <Gracenotes> @. vixen run let a = a in a
12:59:10 <Northerngirluk> yeh i have been through that website but i am very new to c
12:59:15 <mauke> apparently you haven't been in the same social channels as I
12:59:18 <sw17ch> @seen dons
12:59:19 <lambdabot> Fuck me like im a school boy
12:59:19 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 14h 16m 33s ago.
12:59:26 <Northerngirluk> i need help compiling multi files
12:59:26 <Gracenotes> ...wha
12:59:33 <Elly> concatenative?
12:59:37 <Cale> Gracenotes: you know it works in private right?
12:59:39 <Elly> also, what is lambda bot on about?
12:59:52 --- mode: ChanServ set +o Igloo
12:59:55 <kerlo> mauke: in Spanish chat-speak, the word "que" is often abbreviated "q" even though the name of the letter "q" isn't even pronounced that way.
13:00:14 --- mode: Igloo set +b lambdabot!*@*
13:00:16 --- kick: lambdabot was kicked by Igloo (Igloo)
13:00:18 <Gracenotes> Cale: uh huh.
13:00:30 <olsner> oh noes! lambdabot got kicked
13:00:44 <dons> sw17ch: ?
13:01:09 <Northerngirluk> what is a DieWithError.c program do in a multi file
13:01:13 <dons> we should just disable the vixen plugin
13:01:17 <Cale> Igloo: hehe, is that an automatic script?
13:01:21 <Igloo> No
13:01:41 <mauke> Northerngirluk: why are you asking C questions in #haskell?
13:01:50 <thetallguy> sure is eye catching
13:01:55 <maxote> some bots can be humans, xD
13:02:23 <Northerngirluk> where else can i go? most of them needs you to have a account and I tried other ones but not many people available
13:02:26 <kerlo> mauke: it'd be a bit like abbreviating "you" as "y", I guess.
13:02:29 --- mode: Igloo set -o Igloo
13:02:40 <Cheshire> Northerngirluk: ##c
13:02:44 <maxote> but in Soviet Russia, some humans can be bots, xD
13:02:45 <Igloo> I think disabling @vixen is the very least that should be done
13:03:02 <mauke> Northerngirluk: why don't you get an account?
13:03:20 <idnar> @botrape
13:03:20 <lunabot>  :)
13:03:25 <idnar> uh.
13:03:33 <Northerngirluk> i dont have time now, i jus want to ask quick questions to those specialise in socket programming
13:03:37 <Northerngirluk> n ppl who hv time
13:03:39 <Cheshire> Northerngirluk: go to ##c them
13:03:41 <Cheshire> Northerngirluk: go to ##c then*
13:03:44 <Northerngirluk> sorry for the text langauge again
13:04:11 <mauke> Northerngirluk: this channel is about Haskell, not sockets
13:04:13 <Northerngirluk> so is that a chat room and where is it on? is it on gogloom.com?
13:04:22 <maxote> a 2nd level bot can be a proxy of mix of 1st level bots and human logins.
13:04:26 <Cheshire> oh no
13:05:39 <Igloo> I also think the ">" command generates noise, more than it is useful, for example
13:06:05 <Northerngirluk> ##c is just a forum. not a chat room right?
13:06:25 <mauke> ##c is a channel on this network
13:06:34 <maxote> i like a chat room with humans and bots, i don't like a chat room without bots
13:06:43 <Cale> Northerngirluk: If you type /join ##c you should join it.
13:06:53 <Cale> Northerngirluk: (assuming you have a normal IRC client)
13:07:06 <b0fh_ua> well, can somebody please explain me the logic behind foldr/foldl in this case: "let f x y = 2 * x + y in foldl (f) 0 [ 1,2,3 ]". I am a bit confused with grouping. Looks like when foldr is used, the X becomes the item from the list, and the y is the foldr "accumulator". But with foldl the accumulator becomes the "x" and the list item becomes the "y"?
13:07:08 <drhodes> ">" has been indispensable, I've personally learned quite a bit watching people work out issues.
13:07:19 <b0fh_ua> > let f x y = 2 * x + y in foldr (f) 0 [ 1,2,3 ] :: Expr
13:07:27 <mauke> ENOBOT
13:07:33 <Twey> 20:59:56 < kerlo> mauke: in Spanish chat-speak, the word "que" is often abbreviated "q" even though the name of the letter "q"  isn't even pronounced that way.
13:07:44 <Cale> b0fh_ua: foldr f z replaces each (:) in the list's construction with f and the [] at the end with z
13:07:44 <Twey> kerlo: That's nothing — in French it sometimes becomes 'k'
13:08:17 <mathijs> ?pl \x -> (x - 1) `div` 3
13:08:32 <mathijs> @pl \x -> (x - 1) `div` 3
13:08:40 <Gracenotes> b0fh_ua: it literally is a left fold
13:08:45 <Gracenotes> well, figuratively :/
13:08:47 <Cale> b0fh_ua: foldl f z on the other hand basically does it in reverse
13:08:57 <mathijs> how can I write - 1 as a section?
13:09:04 <mauke> mathijs: subtract 1
13:09:11 <mauke> mathijs: pred
13:09:15 <Cale> b0fh_ua: foldr f z [1,2,3] = f 1 (f 2 (f 3 z))
13:09:25 <SubStack> (`div` 3) . pred
13:09:35 <Cale> foldl f z [1,2,3] = f (f (f z 1) 2) 3
13:09:39 <mathijs> mauke: ok, so no way to force - to be a binary operator?
13:10:03 <mauke> flip (-) 1
13:10:08 <Gracenotes> b0fh_ua: imagine a list as a bunch of boards in a row connected by a hinges. Folding a list is like folding the boards over on top of each other until you finish folding and get a value
13:10:10 <Cheshire> mathijs, this is some "design decision" or .. something
13:10:27 <Cale> Gracenotes: that's... an interesting metaphor ;)
13:10:29 <Gracenotes> b0fh_ua: folding left is like starting at the beginning of the list, and folding right is like starting at the end
13:10:39 <b0fh_ua> Cale: ouch, thanks! very intelligible
13:10:52 <Cale> http://cale.yi.org/index.php/Fold_Diagrams -- here's some diagrams to help with folds
13:11:03 <Cale> Showing how the list is transformed.
13:11:03 <Gracenotes> Cale: I'd like to make an animation of it... think it might hepl
13:12:02 <mdmkolbe> Type terminology question: is Amb (Ambiguous) the same as NonDet (Nondeterminism)?
13:12:37 <drhodes> Gracenotes: what would be really cool is an animation generator given a chunk of code.
13:12:40 <Cale> mdmkolbe: It's probably one particular implementation of nondeterminism...
13:13:05 <Cale> mdmkolbe: But... this is not something which is widely standardised in any way
13:13:19 <Gracenotes> drhodes: heh. Sounds hard.
13:13:46 <Cheshire> where are these Amb and NonDet from?
13:15:08 <mdmkolbe> Cheshire: from memory.  I'm trying to descide what to call my type which represents a sum of different object type.  I've heard both Amb and NonDet used before and I wondered if there was some subtle distinction between the two that I was unaware of.
13:15:46 <mdmkolbe> Cheshire: my type is similar in spirit (but very different in implementation) to "type Amb x = [x]"
13:16:14 <skorpan> could someone help me out here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1776
13:16:30 <skorpan> it seems according to my smoke testing that "x" is not bound in the case
13:16:45 <mauke> skorpan: it is bound by line 1 and by line 2
13:16:48 <mauke> and never used
13:17:04 <skorpan> so is it possible to do what i want to do? (it should be pretty obvious)
13:17:24 <mauke> specialSym x = symbol (\t -> case toTok of Special y -> x == y)
13:17:32 <skorpan> oh, right!
13:17:40 <Gracenotes> mdmkolbe: an ambiguous what?
13:17:49 <skorpan> hmm, but why did i believe that this would work? what have i misunderstood?
13:18:03 <mdmkolbe> skorpan: hmm, it looks like hpaste just went down
13:18:28 <Gracenotes> mdmkolbe: from what I understand, context-free grammars are generally non-deterministic, and may or may not be ambiguous. (It's undecidable, iirc)
13:19:07 <mdmkolbe> skorpan: "\x -> case ... of x -> y" re-binds x due to the inner case.  it looks like you thought it would match the outer x to be equal to the inner x
13:19:20 <Gracenotes> and then there are regular thangs. :/
13:20:49 <mdmkolbe> Gracenotes: well, I'm not thinking about grammars per say.  But more of a particular data object (e.g. what the parsing process produces)
13:21:30 <Gracenotes> 'parse tree', so to speak?
13:21:38 <mdmkolbe> Gracenotes: yes
13:22:34 <mdmkolbe> Gracenotes: except in my case instead of each node pointing to a child, each "child" is actually a list of children taht could have been parsed
13:23:03 <Gracenotes> so... single-step parsing, of sorts?
13:23:22 <skorpan> mdmkolbe: you don't happen to know of a nicer way to do this whole function?
13:23:35 <skorpan> it seems like it would be something rather common
13:23:39 <mdmkolbe> e.g. instead of "Plus (Add 1 2) 3" I have "[Plus [Add [1.0] [2,2.0], Minus [1] [2]] [3,3.0]]"
13:24:01 <skorpan> it feels like maybe i could pattern match but use some hot syntax for "fallback"?
13:24:22 <mdmkolbe> skorpan: that type is Special and are there other constructors in that type?
13:24:34 <Cale> @seen lispy
13:24:39 <Cale> oh right.
13:26:21 <mdmkolbe> skorpan: also what is the type of "symbol".  on line three you could say "Special y -> x == y", but unless there are special games to be played with "symbol" or "False" you will *have* to do some kind of pattern match and that means either a "case" or a function that does the same thing as your case
13:26:53 <skorpan> mdmkolbe: Special is of some type Hello which also has a bunch of other constructors
13:27:24 <skorpan> i don't think you have to worry about the type of specialSym, but if you do, it would take too much time to explain it :P
13:27:58 <skorpan> symbol :: forall s. (s -> Bool) -> Parser s s
13:28:30 <mdmkolbe> skorpan: ok, in that case the pattern match really is needed and you are right there's no getting around symbol.  So the only other option is to abstract your "case" expression into a function, but that may or may not help
13:28:47 <skorpan> okay, thanks
13:32:45 --- mode: ChanServ set +o Cale
13:32:49 --- mode: Cale set -b lambdabot!*@*
13:33:03 --- mode: Cale set -o Cale
13:33:31 <Cale> The vixen plugin will be removed next time I can recompile lambdabot, but I need to get lispy to install GHC 6.10.1 on that machine.
13:34:05 <kerlo> Exaggeration: With callCC :: ((a -> b) -> a) -> a, it's trivial to implement a well-ordering of the real numbers.
13:34:23 <Cheshire> kerlo, do you have code ?
13:34:46 <kerlo> Actually, that's a weaker statement than it could be.
13:34:57 <kerlo> Exaggeration: It's trivial to implement a well-ordering of the real numbers.
13:35:20 <Cheshire> I don't even know what you are saying here
13:35:21 <Cale> Apply the well-ordering theorem. Done.
13:35:58 <Gracenotes> Cale: isn't there some way to sort out the 'bad' replies?
13:35:58 <kerlo> Catch: This assumes that the axiom of choice is a value :: WellOrdering a.
13:36:12 <kerlo> In other words, precisely what Cale said.
13:36:25 <Cheshire> kerlo I think that what you said is nonsense wrt. haskell
13:36:38 <Cheshire> this is acceptable in set theory but not haskel
13:36:48 <Cale> I don't think callCC implies the axiom of choice.
13:36:59 <Cheshire> yes callCC implies excluded middle
13:37:07 <Cheshire> excluded middle and axiom of choice are very different
13:38:31 <Cale> It would be so convenient of we had a well-ordering oracle for every type though. Especially as this would give us decidable equality :)
13:38:38 <Cale> if*
13:38:57 <Cale> Heh, and a really powerful fixed point operator.
13:38:59 <kerlo> I didn't mean to imply that excluded middle and the axiom of choice were related in any way.
13:39:23 <mdmkolbe> Who do we talk to if hpaste goes down?
13:39:34 <Cale> moonpatio.org:8080
13:39:36 <Cale> ;)
13:40:02 <Cale> But really, I'm not sure.
13:40:06 <Cale> Is it still glguy?
13:40:16 <Saizan> mmorrow:
13:41:18 <kerlo> I like ZF+AD. All sets of real numbers having the property of Baire makes them a lot easier to visualize.
13:41:34 <kerlo> It makes the set of all sets of real numbers almost countable. :-P
13:42:03 <Cale> But anything that contradicts AC makes other sets very strange.
13:42:06 <chrisf> `almost` :)
13:42:38 <Cheshire> what is property of Baire
13:42:40 <Cale> You'll get pairs of sets such that there's no injection from one to the other in either direction.
13:42:48 <gwern> @info Monoid
13:42:49 <lambdabot> Monoid
13:42:53 <gwern> @more
13:43:05 <Cheshire> Cale, that is weird!
13:43:26 <Cheshire> Cale, wait literally not injection between them.. or you just cannot derive an injection?
13:43:34 <Cale> Literally can't be.
13:43:43 <Cale> Cardinalities become incomparable.
13:43:48 <Cheshire> Cale, do you know where I can read about it?
13:45:07 <Cale> Let me see if I can find something
13:45:56 <kerlo> I hope ordinal numbers remain comparable. ;-)
13:46:31 <Cale> http://planetmath.org/encyclopedia/OrderingOnCardinalities.html
13:46:32 <Riastradh> That's not fair, Cale.  The axiom of choice is obviously true, but leads to that irksome nonconstruction of Banach and Tarski; and the well-ordering principle is obviously false, but if that leads to incomparability of cardinals, then maybe Zorn's lemma can lead us to a nicer state of mathematics!
13:46:36 <Cale> there you go
13:46:46 <Cale> Riastradh: hehehe
13:47:09 <Cale> The Banach-Tarski construction is actually quite beautiful, I like it :)
13:47:23 <Riastradh> Construction?
13:47:27 * Riastradh hiccups.
13:47:40 <Cheshire> heh
13:47:43 <idnar> axiom of conflict
13:48:01 <Cheshire> wait Riastraidh
13:48:13 <Cheshire> well ordering is ok with comparability of ordinals ?
13:48:49 <Cale> Cheshire: He's joking a bit, the well-ordering theorem, axiom of choice, and Zorn's lemma are all equivalent.
13:49:02 <Cale> (as is the comparability of cardinals with those)
13:49:12 <kerlo> And God obviously exists. This follows from the fact that all cesium-133 atoms are identical.
13:49:21 <Riastradh> Specifically, I'm modifying a humorous quip of some famous mathematician (Russell?).
13:49:40 <Riastradh> The original quip was something along the lines of:  The axiom of choice is obviously true, the well-ordering principle is obviously false, and who can say about Zorn's lemma?
13:49:42 <Cheshire> ok but,  in ZFC + AoC  then every ordinals x and y,  either equal or one includes the other, doesn't it?
13:49:53 <Cale> ZF + AoC = ZFC
13:50:15 <Cale> Cheshire: ordinals, yes
13:50:36 <Cheshire> if cardinals are a subset of ordinals ... how come they are not comparable?
13:51:24 <kerlo> (The fact that all cesium-133 atoms is, in my opinion, the worst proof of God I've ever heard.)
13:51:54 <kerlo> Cheshire: cardinal numbers are comparable, in ZFC.
13:52:09 <Cale> I'm... not used to working in ZF without AC enough to see right away how this works. Probably you get that there are sets whose cardinality is not the cardinality of an ordinal.
13:52:20 <Riastradh> `Proof of God' assumes that `God' is a proposition in some logical system...  I wonder what cesium atoms have to do with that logical system?
13:52:40 <Cale> In ZFC you can define cardinals as particular ordinals, but I'm not sure it works out so well without choice.
13:53:09 <kerlo> In ZFD (which is presumably what one would call ZF + AD), either some cardinals are not ordinals, or the ordinals are not ordered. Or the cardinals are ordered.
13:53:14 <Cale> (You want cardinals to represent classes of sets under bijection)
13:53:23 <kerlo> Riastradh: I quote: "Cesium 133 atoms never vary a single vibration. They are steady—constant—reliable—and cannot be an accident of nature that just “happens” to always turn out exactly the same. God had to design the complexity and reliability of these atoms."
13:53:52 <chrisf> eh?
13:54:03 <FliPPeh> map (\(a, b) -> putStrLn $ show a ++ "=" ++ show b) env
13:54:07 <FliPPeh> Why doesn't it work? :(
13:54:10 <bolrod> http://www.400monkeys.com/God/
13:54:20 <FliPPeh> Couldn't match expected type `[IO ()]' against inferred type `IO (IO ())'
13:54:25 <Cale> kerlo: That is time-cube-esque
13:54:29 <kerlo> Indeed.
13:54:33 <FliPPeh> env = getEnvironment
13:54:37 <FliPPeh> [IO String]
13:54:48 <Axman6> @tell ozy` i just got a comment on my blog from someone who's made changes to an older haskell bundle, that you may be inteterested in. check out http://axman6.homeip.net/blog/2009/02/textmate-haskell-bundle-improvments.html
13:54:49 <lambdabot> Consider it noted.
13:55:06 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1599#a1599
13:55:07 <thetallguy> kerlo: who's that quote from?
13:55:15 <kerlo> thetallguy: http://www.thercg.org/books/dge.html
13:55:20 <Cale> :t map (\(a, b) -> putStrLn $ show a ++ "=" ++ show b)
13:55:21 <lambdabot> forall t t1. (Show t1, Show t) => [(t, t1)] -> [IO ()]
13:55:32 <Cheshire> I think that is called "intelligent design"?
13:55:56 <kerlo> Anyway, no sufficiently intelligent and knowledgeable person believes that all consistent things are consistent because they were designed that way.
13:56:17 <Cheshire> there is the argument "Any sufficently intelligent person agrees with me" :p
13:56:26 <FliPPeh> Cale: what can I do?
13:56:32 <thetallguy> kerlo: I love those arguments where they use science to try and prove there's a god.
13:56:46 <kerlo> After all, in Conway's Game of Life, a glider in empty space behaves consistently; however, nobody designed it to do that.
13:57:16 <Cheshire> kerlo, Didn't conway ..?
13:57:32 <thetallguy> Conway invented the rules, then discovered the gliders
13:57:42 <Cale> FliPPeh: It... depends what you want.
13:57:45 <Cheshire> is beta reduction magic too..?
13:57:50 <drhodes> how many sets of rules did conway go through before deciding on that one though?
13:57:50 <thetallguy> yup
13:57:59 <FliPPeh> Cale: I want to output every environmnet variable
13:58:04 <Cale> FliPPeh: If env is a list of pairs, then that map will produce a list of actions
13:58:09 <Cale> FliPPeh: You probably want mapM
13:58:21 <FliPPeh> Oh yeah
13:58:23 <kerlo> Cheshire: indeed, he discovered it; he didn't invent it.
13:58:25 <Cale> FliPPeh: Which will sequence those actions together into a single action.
13:58:26 <FliPPeh> That did the job :)
13:58:27 <FliPPeh> Thanks
13:58:29 <thetallguy> drhodes: don't know, but I think not many.  They are very simple.
13:58:49 <FliPPeh> Now I can use Haskell for CGI
13:58:52 <FliPPeh> :)
13:59:10 <drhodes> I think (2 ** 8) * 2
13:59:36 <Cale> Conway invented the game of life, but discovered the glider? :)
13:59:50 <Cale> invention and discovery are the same thing anyway
13:59:51 <Axman6> :t foldr ((:).?f) []
13:59:52 <lambdabot> Not in scope: `.?'
13:59:58 <Axman6> :t foldr ((:). ?f ) []
13:59:59 <lambdabot> forall b a. (?f::a -> b) => [a] -> [b]
14:00:06 <proq> research is when I don't know what I'm doing  ;)
14:00:13 <Axman6> :t chr
14:00:14 <lambdabot> Int -> Char
14:00:30 <Axman6> > foldr ((:). chr [] [1..]
14:00:31 <lambdabot>   <no location info>: parse error on input `;'
14:00:37 <Axman6> > foldr ((:). chr) [] [1..]
14:00:38 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\E...
14:00:49 <m3ga> haskell singles? wtf? I was searched for "send email haskell" and google found this : http://www.matchmaker.com/mm/dating/newjersey-haskell.htm
14:00:54 <FliPPeh> Haskell has no list splitting method? :(
14:00:58 <m3ga> i'm happily married :-)
14:01:04 <FliPPeh> I want to split by "&" and not by " "
14:01:09 <Cale> m3ga: Haskell is a city in a number of states in the US
14:01:36 <Axman6> FliPPeh: there's plenty of list splitting functions
14:01:42 <kerlo> FliPPeh: like "words", but splitting at & instead?
14:01:43 <Axman6> :t split
14:01:43 <FliPPeh> Oh wait yeah
14:01:44 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
14:01:48 <FliPPeh> Yep kerlo
14:01:48 <Axman6> :t splitAt
14:01:49 <lambdabot> forall a. Int -> [a] -> ([a], [a])
14:01:55 <Gracenotes> we has splitting package
14:01:58 <FliPPeh> Forgot about splitAt
14:01:58 <Gracenotes> @hackage split
14:01:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
14:02:04 <kerlo> @hoogle a -> [a] -> [[a]]
14:02:04 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:02:05 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:02:05 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:02:08 <Axman6> which is Data.List.Split
14:02:09 <Gracenotes> we has many splitteh option
14:02:11 <jre2> how do you disable ghci echoing the value of something?
14:02:19 <m3ga> Cale: i realise that, i just found it a little surprsing to find that as a search result
14:02:31 <proq> m3ga: what the heck.  those people do *not* look like haskellers
14:02:40 <Axman6> jre2: that doesn't sound very useful to me :\
14:04:52 <jre2> I have a function that returns an IO array, thus I can do: xs <- loadBmp "test.bmp"  but this causes it to display the entire array
14:05:29 <Cale> jre2: You're talking about from ghci?
14:05:35 <jre2> yea
14:05:41 <Cale> yeah, that's annoying isn't it?
14:05:57 <thetallguy> there's an option to not show the value, isn't there?
14:05:57 <jre2> particularly if I have to wait ~30sec to let the terminal display it all
14:06:09 <jre2> I thought there was a way to disable echo
14:06:12 <Cale> Some newbies argued for that behaviour on the Haskell mailing list a while back and someone was silly enough to implement it. You can partially turn it off, I think.
14:06:13 <jre2> can't find it though
14:06:35 <Cale> I think it was something like -fno-display-bind-result
14:06:39 <Cale> or something along those lines
14:06:53 <thetallguy>   -fno-print-bind-result
14:06:58 <Cale> ah, yeah
14:07:17 <jre2> thank you!
14:12:47 <Cheshire> I wrote this code and I don't like they way it is..
14:12:59 <Cheshire> I wonder if anyone would give me some comment about something ot improve on it?
14:14:36 <iago_> Cheshire, what code?
14:14:46 <Cheshire> it's a bit long.. there is some examples in it: http://rafb.net/p/WOnbd659.html
14:15:24 <Cheshire> basically it takes one syntax-with-binding and translates it into some haskell code
14:15:33 <iago_> Cheshire, hpast.org :) I think anyone prefers Haskell syntax highlight
14:15:40 <iago_> hpaste.org*
14:15:47 <Cheshire> 500 Internal Server Error
14:15:47 <Cheshire> 58030 5: database is locked
14:15:56 <iago_> uhm
14:16:51 <iago_> http://moonpatio.com
14:16:58 <glguy> hpaste seems to be suffering from some takusen quirks :)
14:17:22 <Cheshire> iago_, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1600#a1600
14:19:00 <iago_> uhmm
14:19:13 <iago_> what are you coding Cheshire ?
14:19:28 * tibbe_ is pondering whether computing an average incrementally forms a monoid
14:19:50 <Cheshire> iago_, this bit is half of the code to translate (a simple form of) data definitions into my interpreter
14:20:05 <neale> noob question
14:20:22 <neale> How do I achieve: (1 :: Int) ((Bits..|.) :: Int -> Int -> Int) (1 :: Int)
14:21:15 <Gracenotes> @type (.|.)
14:21:16 <lambdabot> forall a. (Bits a) => a -> a -> a
14:21:26 <Gracenotes> @instances Bits
14:21:26 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
14:21:32 <Cheshire> but any comments about it from anyone...?  I wonder if there is better ways.. or if makes some sense
14:21:37 <neale> @instances Data.Bits
14:21:38 <lambdabot> Couldn't find class `Data.Bits'. Try @instances-importing
14:21:42 * neale shurgs
14:21:46 <Gracenotes> @instances Data.Bits.Bits
14:21:47 <lambdabot> Int, Integer
14:21:55 <Gracenotes> Int should be fine
14:22:14 <neale> does lambdabot have an eval?
14:22:21 <Gracenotes> by default it's just any Bits, but you should be able to specify Int in the type signature
14:22:39 <mmorrow> gah, Takusen fail!
14:22:41 <endojelly> wait a minute. I though the K combinator was \xy.x?
14:22:41 <Gracenotes> neale: yes; you can use it in PM too if you have lots to say. It's just > your command
14:22:45 <neale> Gracenotes: am I specifying the type signature?
14:22:51 <endojelly> is it not?
14:23:05 <Gracenotes> neale: if you want :) It can also be inferred if you use Ints someplace else
14:23:19 <endojelly> it produces a constant function, so \xy.x makes sense
14:23:31 <endojelly> however, someone wrote \yx.x?!
14:23:55 <dolio> > let lift x = (Sum x, Sum 1) ; getAverage (s,l) = getSum s / getSum l in getAverage . mconcat . map lift $ [1..10]
14:23:56 <neale> Gracenotes: I mean in the question I asked; I thought I was specifying the type signature of everything.
14:23:57 <lambdabot>   5.5
14:23:57 <mmorrow> hpaste.org works
14:24:00 <Cheshire> nobody is gonna criticise my code :(
14:24:40 <Gracenotes> neale: you were... weren't you?
14:24:57 <neale> well I thought so, but I get a type error
14:25:05 <Gracenotes> oh, I see
14:25:15 <neale> this is day 1 of Haskell for me, so I really am a noob
14:25:20 <iago_> Cheshire, well, in few minutes I can't understand all you want to do, I have a basic idea, what is the part you think could be improved :?
14:25:22 <Gracenotes> > 5 .|. 8
14:25:23 <lambdabot>   Add a type signature
14:25:27 <Gracenotes> > 5 .|. 8 :: Int
14:25:28 <lambdabot>   13
14:25:30 <Cheshire> iago_, probably all of it
14:25:32 * neale blinks
14:25:37 <Cheshire> iago_, excep the cast section
14:25:46 <Cheshire> but I don't really know what's good and bad
14:25:59 <Gracenotes> neale: however, if you put parentheses around the expression, it's not infix anymore
14:26:00 <neale> Gracenotes: oh my, that's much simpler than what I was trying to do!
14:26:03 <Gracenotes> > (.|.) 5 8 :: Int
14:26:04 <lambdabot>   13
14:26:10 <neale> oh, hm
14:26:18 <Gracenotes> > 5 (.|.) 8 :: Int -- this doesn't work
14:26:19 <lambdabot>       No instance for (Num ((a -> a -> a) -> t -> Int))
14:26:19 <lambdabot>        arising from t...
14:26:39 <FliPPeh> @hoogle cgi
14:26:39 <lambdabot> package cgi
14:26:39 <lambdabot> package cgi-undecidable
14:26:39 <lambdabot> package fastcgi
14:26:40 <neale> ahhh
14:26:45 <Gracenotes> neale: so, in Haskell you don't have to specify the type of /everything/ when it comes to numbers, or many other things.
14:26:48 <neale> Gracenotes: thanks!  I was overthinking things.
14:27:05 <neale> well I was just trying to understand how to use Bits
14:27:15 <neale> so I kept adding more explicit type signatures
14:27:20 <neale> until I had... well, a mess :)
14:27:49 <Gracenotes> if a function is a -> a -> a, just specify the result, and everything else falls in place
14:28:51 <Gracenotes> most of the time, though, you don't need type signatures. In this case, I suppose there's some kind of ambiguity between Ints and Integers (by default, things tend to be Integers)
14:29:09 <neale> It seems Bits works on a lot of different types
14:29:12 <FliPPeh> Could not find module `Pretty':
14:29:12 <FliPPeh>       it is a member of package ghc-6.10.1, which is hidden
14:29:16 <FliPPeh> Help?
14:29:18 <Gracenotes> or Doubles, if more functions are needed
14:29:38 <neale> Gracenotes: very cool, thank you so much.  Your explanation makes total sense.
14:29:42 <Cale> FliPPeh: Are you trying to use the GHC API?
14:29:46 <Axman6> @instances Bits
14:29:46 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
14:29:52 <Cale> FliPPeh: Or are you just looking for a Pretty printing library?
14:29:53 <FliPPeh> I'm trying to use a CGI library.
14:29:57 <Axman6> @instances-importing Data.Bits
14:29:58 <lambdabot> Couldn't find class `Data.Bits'. Try @instances-importing
14:30:01 <Gracenotes> neale: sure :) I mean, there are only two instances, but Ints are very useful
14:30:02 <FliPPeh> Which is trying to use that prettyfier
14:30:05 <Gracenotes> @instances Data.Bits.Bits
14:30:05 <lambdabot> Int, Integer
14:30:14 <Gracenotes> as are Integers
14:30:23 <Cale> FliPPeh: which CGI library?
14:30:39 <FliPPeh> http://www.geocities.com/laitenberger/haskell/CGI/
14:30:46 <FliPPeh> That one, no documentation, nothing :(
14:31:09 <Axman6> @hoogle CGI
14:31:09 <lambdabot> package cgi
14:31:09 <lambdabot> package cgi-undecidable
14:31:09 <lambdabot> package fastcgi
14:31:25 <Cale> FliPPeh: That looks rather old... is there anything wrong with the CGI library that comes with GHC or the ones on Hackage?
14:31:37 <FliPPeh> There's one in GHC?
14:32:35 <Axman6> FliPPeh: Network.CGI apparently
14:32:39 <Cale> Hmm, maybe not 6.10... earlier versions came with a Network.CGI
14:32:44 <FliPPeh> "Could not find module `Network.CGI':"
14:32:51 <FliPPeh> Nope, not in newer versions
14:32:57 <Cale> looks like it got split out and put on Hackage
14:33:03 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cgi
14:33:06 <FliPPeh> Basically I just want something to get a handy list of those environment variables and the query string
14:33:07 <FliPPeh> That's all
14:33:13 <Cale> You should just be able to cabal install it.
14:33:14 <FliPPeh> I really don't need a bloated library
14:33:23 <Cale> It's a fairly simple interface :)
14:33:34 <FliPPeh> I generally hate using libraries
14:33:43 <Cale> oh... heh, it does look like it's gotten a little more complicated since I looked at it.
14:33:47 <FliPPeh> Some quirk, I just have to write it myself
14:33:59 <endojelly> what is a church style term, as opposed to a curry style term?
14:34:08 <FliPPeh> Looks like string splitting is harder than I thought in Haskell
14:34:26 <dolio> Church is \x:t. e, curry is \x. e.
14:34:28 <Cale> FliPPeh: String splitting?
14:34:31 <FliPPeh> Yep
14:34:34 <FliPPeh> Split not by a space
14:34:40 <FliPPeh> But with anything else
14:34:42 <endojelly> dolio, so church is with type annotations, curry without?
14:34:43 <FliPPeh> & r =
14:34:46 <FliPPeh> Whatever
14:34:49 <Cale> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
14:34:51 <dolio> Right.
14:34:54 <FliPPeh> splitString "my&string" &
14:34:55 <endojelly> dolio, thanks.
14:35:02 <Cale> That library comes with a bunch of methods of splitting lists up.
14:35:17 <Cheshire> oh well
14:35:30 <Cale> splitOn "&" "my&string"
14:35:47 <FliPPeh> Can't use it out of the box.. mhh
14:36:02 <Cale> cabal install split
14:36:57 <FliPPeh> I don't have cabal
14:37:10 <Cheshire> FliPPeh, just paste the source code into a file
14:37:17 <Cheshire> @wiki Data.List.Split
14:37:17 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
14:37:23 <Cheshire> FliPPeh, pull one off there
14:37:32 <Cale> FliPPeh: What OS are you running?
14:37:40 <FliPPeh> WinXP :s
14:37:52 <Cale> FliPPeh: It's generally worthwhile to install cabal-install regardless...
14:37:53 <FliPPeh> I find it easier to install anything on linux
14:37:55 * Cheshire wonders if WinXP supports copy/paste
14:38:07 <Twey> Cheshire: Not really
14:38:12 <Cale> Twey: hehe
14:38:47 <Twey> Involving the console, I presume Cheshire meant
14:39:09 <Cheshire> I wish I had someone to collab. with on hacking this
14:43:41 <jeffwheeler> Once past the true pain in the ass of installing and getting HaskellDB to work . . . it is really quite a beautiful DSL.
14:44:11 <jeffwheeler> I would think TH would be interesting to replace some of the boilerplate generated from introspection.
14:44:12 <FliPPeh> How could I map something like ["a=4","b=5"] to [("a", 4), ("b", 5)]? I've got the splitOn function already
14:45:02 <Axman6> :t splitOn
14:45:03 <lambdabot> Not in scope: `splitOn'
14:45:17 <FliPPeh> splitOn (== '=')
14:45:17 <Axman6> :t Data.List.Split.splitOn
14:45:18 <lambdabot> Couldn't find qualified module.
14:45:34 <Cale> map ((\[x,y] -> (x,y)) . splitOn "=")
14:45:42 <FliPPeh> splitOn (== '=') "a=4" -> ["a", "4"]
14:46:13 <Axman6> FliPPeh: map (fmap read) . splitOn (== '=') $ list
14:46:37 <Axman6> ah, spliton [a] -> [[a]]?
14:46:37 <Elly> @hoogle error
14:46:37 <lambdabot> Prelude error :: String -> a
14:46:37 <lambdabot> module Control.Monad.Error
14:46:37 <lambdabot> module Foreign.C.Error
14:46:41 <Elly> aha, excellent
14:47:06 <matthew-_> anyone know of any good effect type systems for lambda calc?
14:47:27 <FliPPeh> Cale: giving me a syntax error
14:47:32 <pastah> @pl \(x,y) (z,w) -> (x+z,y+w)
14:47:33 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
14:47:51 <Cheshire> matthew-_, which effects
14:47:59 <Gracenotes> whoa there, lambda
14:48:00 <Cale> FliPPeh: I accidentally left a ) there
14:48:04 <Cale> FliPPeh: at the end
14:48:08 <iago_> well
14:48:19 <matthew-_> Cheshire: I'm not fussy
14:48:26 <Cheshire> look at DDC
14:48:34 <FliPPeh> Nope, that's not it
14:48:39 <matthew-_> Cheshire: ta
14:48:39 <Cheshire> @go disciple haskell
14:48:41 <lambdabot> http://www.haskell.org/haskellwiki/DDC
14:48:41 <lambdabot> Title: DDC - HaskellWiki
14:48:42 <iago_> Cheshire, if you want a critic the first one is that I don't like your way of write functions without specify its type
14:49:01 <Cheshire> iago_, ok
14:49:07 <Gracenotes> pastah: arrows, maybe... :3
14:49:20 <iago_> worse for read, and less secure
14:49:24 <Gracenotes> or just pointful
14:49:25 <Cheshire> iago_, I use haskell like an untyped language so I don't really think about types when I program it..
14:49:53 <iago_> It's strange use haskell like untyped when haskell is statically and strictly typed
14:50:18 <bremner> Cheshire: wow, that must be a real battle :-)
14:50:37 <Cale> Well, you can't really do that, but the type inference means that you largely can ignore types if you want.
14:50:51 * bremner considers adding type declarations essential to get his newbie code to compile
14:50:52 <Cheshire> bremner, it is easier than trying to encode logical properties/invariants about my program into thet type system :p
14:51:06 <iago_> type inference is very good, but it's a good practice to specify the types of top-level functions
14:51:40 <Cheshire> iago_, so consider if I put down a type sig. for every function in there, and what about it now ?
14:52:13 <iago_> now it's easy to read and safer ^^
14:52:17 <iago_> easier*
14:52:51 <iago_> well, in this case perhaps this isn't very important, but always is a good practice
14:52:53 <iago_> :P
14:53:35 <Gracenotes> does PL do arrows?
14:54:43 <Gracenotes> @pl \f (a, b) -> (f a , b)
14:54:43 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
14:55:07 <Cheshire> anything about the actual code?
14:56:25 <iago_> error "Impossible case"
14:56:34 <iago_> this always sounds funny
14:56:38 <iago_> :P
14:57:15 <BMeph> Gracenotes: Sadly, no. Or rather, "not *yet*." ;)
14:57:44 <Gracenotes> how complicated would the transformation rules be?
14:58:47 <pumpkin> easy peasy
14:59:42 <Gracenotes> hm. Is there a way to specify leaving out certain rules?
15:00:04 <iago_> Cheshire, can you paste the Syntax module?
15:00:21 <Gracenotes> so, for instances, one could leave out function instances for applicative/monad/functor
15:00:55 <Cheshire> iago_, http://rafb.net/p/MKQxqo19.html
15:01:05 <mattam> Cheshire: building the impredicative encodings automatically?
15:01:29 <Cheshire> mattam, no they come as new disjoint types
15:01:44 <Cheshire> mattam, I add them by postulating them as constants, and then a haskell implementation of the eliminator
15:02:14 <Cheshire> (well I didn't implement that yet.. but I will eventually)
15:03:16 <mattam> If I can decifer [pp [] $ elmer bool] right it's the type of the eliminator.
15:03:25 <Cheshire> yes
15:03:32 <Cheshire> I only computed the types so far
15:03:39 <mattam> So it's just missing the bodies, ok :)
15:04:01 <Cheshire> mattam, also I should add (generalized)-inductive and parametrized definitions.. in stages
15:04:09 <Cheshire> oops
15:04:20 <FliPPeh> MAaan
15:04:20 <Cheshire> ((generalized)-indexed)-inductive :p
15:04:23 <FliPPeh> This is driving me nuts
15:04:24 <mattam> Take your time :)
15:04:29 <FliPPeh> Why can't it just work..
15:04:41 <Cheshire> my biggest worry is to implement it in a simple way that is obviously correct
15:04:50 <FliPPeh> type system is killing my nerves
15:05:00 <Cheshire> FliPPeh: what is the problem
15:05:23 <mattam> Btw, parameters are useful because they can be treated specially in eliminators without requiring full dependent inversion, and also params can be erased during conversion.
15:05:48 <FliPPeh> Split a given String of the form "a=5&ddsaud=asdhkj&blah=blah&t=4" into [("a", "5"),("ddsaud", "asdhkj") ...]
15:06:05 <Cheshire> mattam, they can be erased by a similar reason as Miquels implicit calculus?
15:06:06 <Pseudonym> FliPPeh: The reason why it can't "just work" is because your code has a bug. :-)
15:06:19 <FliPPeh>     Couldn't match expected type `Char' against inferred type `[Char]'
15:06:19 <FliPPeh>       Expected type: [Char]
15:06:19 <FliPPeh>       Inferred type: [[Char]]
15:06:26 <FliPPeh> I love those
15:06:37 <Pseudonym> Those are pretty good, actually.
15:06:39 <FliPPeh> Because when I change something, the infereed type will go [[[Char]]]
15:06:46 <FliPPeh> And then [[[[Char]]]]]
15:06:54 <Gracenotes> [a] vs. [[a]] is Haskell's version of an off-by-one error
15:06:58 <Gracenotes> :)
15:07:00 <Pseudonym> It means there is some place where the type checker expects the type to be [Char], but yours is [[Char]].
15:07:01 <dmwit> FliPPeh: Then unfix it!
15:07:10 <Pseudonym> Replace [Char] with String if it helps.
15:07:17 <dmwit> unfix it one step, and *bam* you're done! =)
15:07:44 <thoughtpolice> Gracenotes: luckily for us it's caught at compile time :>
15:08:38 <FliPPeh> When I give it the type it wants, it crashes on my freaking face again
15:09:00 <mattam> Cheshire: Yes and no. They're known to be constant somehow, whereas implicit params are just known not to interfere. There's a paper by Barras and Grégoire about it somewhere.
15:10:09 <Cheshire> ok
15:10:16 <Cheshire> I see how it can work now I think
15:10:21 <travisbrady> FliPPeh: map (splitOn "=") $ splitOn "&" "a=5&ddsaud=asdhkj&blah=blah&t=4"
15:10:32 <Cheshire> just any comparison of them which typechecked they must already be equal
15:10:44 <Cheshire> very nice actualy :)
15:10:52 <Ralith> travisbrady: where's splitOn from?
15:11:03 <travisbrady> Ralith: Data.List.Split
15:11:23 <travisbrady> @hoogle splitOn
15:11:23 <lambdabot> No results found
15:11:32 <travisbrady> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
15:11:43 <Ralith> oh, it's a third party package
15:11:45 <FliPPeh> travisbrady: nope.
15:12:10 <travisbrady> FliPPeh: what do you mean nope? paste you cd on hpaste with the errors you're getting
15:12:16 <Ralith> I'm surprised there's no tokenizer in the standard library
15:12:23 <travisbrady> paste your code rather
15:12:49 <travisbrady> Ralith: there actually is for ByteStrings http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#v%3Asplit
15:13:03 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1601#a1601
15:13:28 <Ralith> travisbrady: only for bytestrings?
15:13:29 <Ralith> wtf?
15:13:39 <travisbrady> oh you're trying to define your own splitOn
15:13:44 <FliPPeh> Not really
15:13:49 <FliPPeh> I copied it
15:13:54 <FliPPeh> It's the original
15:14:33 <FliPPeh> That split function is working
15:15:07 <iago_> Cheshire,
15:15:26 <travisbrady> FliPPeh: from where? http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/src/Data-List-Split-Internals.html#splitOn is not what you pasted
15:15:26 <Cheshire> yes
15:15:48 <Ralith> travisbrady: the examples on that page don't seem to work
15:15:54 <FliPPeh> Haskill wiki
15:15:54 <Ralith>     Couldn't match expected type `GHC.Word.Word8'
15:15:54 <Ralith>            against inferred type `Char'
15:15:55 <iago_> tToP delta (Var (Free (Local _))) = error "Impossible case"
15:16:02 <iago_> Free always have to be Global
15:16:32 <FliPPeh> http://www.haskell.org/haskellwiki/Data.List.Split
15:17:15 <iago_> well, one possibility is Free String, avoid the construction of ill-formed values
15:17:29 <Cheshire> I need Local in a different part of code
15:17:44 <Cheshire> (typechecker)
15:18:41 <travisbrady> FliPPeh: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1601#a1602
15:20:34 <travisbrady> Ralith: which page?
15:21:12 <Ralith> http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#v%3Asplit
15:21:52 <FliPPeh> :t [ (x,y) | [x,y] <- map (splitOn (== '=')) $ splitOn (== '&') f ]
15:21:53 <lambdabot> Not in scope: `splitOn'
15:21:53 <lambdabot> Not in scope: `splitOn'
15:23:24 <FliPPeh> queryString :: String -> [(String, String)] works
15:23:37 <FliPPeh> queryString :: a-> [(a, a)] does not work
15:23:40 <FliPPeh> Why?
15:24:21 <travisbrady> Ralith: looks like they just omitted some stuff
15:24:33 <FliPPeh> Ah wait
15:24:38 <FliPPeh> First one should be [a]
15:25:25 <travisbrady> FliPPeh: no, your query string is a String, it can't be an a
15:25:35 <travisbrady> you have hardcoded the query string in there
15:25:42 <FliPPeh> Not anymore
15:26:07 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1604#a1604
15:26:14 <Elly> I wrote an untyped lambda calculus interpreter and I think it is pretty: http://p.leptoquark.net/pyxy/lc2.hs
15:27:21 <travisbrady> FliPPeh: how could it be an a though, you're splitting on a Char, you can't split every sequence type by a Char
15:27:40 <FliPPeh> Mhhh
15:28:12 <FliPPeh> Makes sense.
15:28:21 <FliPPeh> I keep screwing up on haskells type system..
15:28:30 <FliPPeh> EVERY error I'm getting is type related
15:28:34 <FliPPeh> Why does it hate me so much?
15:28:41 <FliPPeh> queryString :: [Char] -> [([Char], [Char])]
15:28:51 <travisbrady> it can be very frustrating
15:29:20 <FliPPeh> Mostly
15:29:21 <drhodes> Elly: that's concise.
15:29:22 <llayland> it loves you :) it is is just tough love so you don't get runtime errors
15:29:38 <FliPPeh> Well
15:29:40 <Elly> oops, it's also a bit wrong
15:29:47 <FliPPeh> At least I can start using it for CGI now
15:30:18 <augustss> Elly: your substitution is wrong
15:30:23 <Elly> it is?
15:30:55 <augustss> Yes, when you substitute under L you can get accidental variable capture
15:30:58 <Cheshire> Elly, of course it is, you are using strings to represent variable names
15:31:16 <Cheshire> s/variable names/variables/
15:31:22 <Elly> augustss: how's that? if it tries to subst in an L with the same variable name, it stops
15:31:32 <augustss> Elly: if n is free in e you need to alpha-convert n first
15:31:47 <Elly> what's a situation where that could go wrong?
15:31:51 <augustss> Sorry, if n is free in s
15:32:16 <augustss> no v
15:32:44 <augustss> subst (L "x" (V "y")) "y" (Var "x")
15:33:00 <FliPPeh> What's good for CGI? Currently I'm just compiling it to binary and calling it like http://localhost/cgi-bin/sc.exe
15:33:11 <FliPPeh> I'd like to have it as source, much like PHP
15:33:15 <Elly> augustss: ahhhh
15:33:17 <Elly> augustss: oh dear
15:33:26 <augustss> Elly: it's not much more complicated than what you have, but you need to take care of that
15:33:43 <Elly> later :)
15:33:43 <Cheshire> Elly, you could use De Bruijn indices or HOAS instead
15:33:45 <Elly> right now is food time
15:34:04 <augustss> Cheshire: it's quite pretty to just alpha convert
15:35:14 <augustss> you just pick a variable not free in v nor e and use subst to alpha convert
15:39:30 <travisbrady> FliPPeh: i'm pretty sure you don't have to hand parse a query String like that, that's what getInput and getInputs are for
15:39:37 <shapr> Yay, Boston Area Haskell User's Group mailing list! http://groups.google.com/group/bostonhaskell
15:39:41 <travisbrady> http://hackage.haskell.org/packages/archive/cgi/3001.1.7.1/doc/html/Network-CGI.html#v%3AgetInputs
15:41:24 <shapr> jfredett_: You've subscribed to the mailing list, right?
15:42:17 <FliPPeh> @hoogle getInput
15:42:17 <lambdabot> Language.Haskell.ParseMonad getInput :: Lex r String
15:42:17 <lambdabot> Text.Parsec.Prim getInput :: Monad m => ParsecT s u m s
15:42:17 <lambdabot> Text.ParserCombinators.Parsec.Prim getInput :: Monad m => ParsecT s u m s
15:42:25 <FliPPeh> Huh?
15:42:29 <FliPPeh> travisbrady: Where?
15:43:01 <EvilTerran> FliPPeh, Network.CGI; travisbrady pasted a link
15:43:16 <FliPPeh> Oh, I should learn to read
15:43:21 <FliPPeh> Sorry
15:44:39 <shapr> saccade: Showing up this saturday at the Haskell meeting?
15:44:48 <vincenz> @seen dons
15:44:48 <lambdabot> dons is in #haskell, #concatenative, #arch-haskell, #darcs, #xmonad and #ghc. I last heard dons speak 17h 2m 2s ago.
15:45:40 <llayland> Anybody know if there is a Haskell or FP group in Tampa, FL?
15:46:24 <shapr> gdsx: Interest in a Boston Haskell User's Group?
15:46:31 <shapr> OK, who have I forgotten to invite?
15:46:45 <FliPPeh> I'm curious if there's something like LAMH instead of LAMP!
15:47:15 <shapr> Yeah, we're on the LAMH.
15:47:47 <FliPPeh> :|
15:47:51 <FliPPeh> Anyways, bed time
15:47:59 <mdmkolbe> Is there some way to have class contexts that are universally quantified?  For example I would like to do the equivalent of "instance (Data b, forall a. Data a => Show (f a)) => Show Foo f b where ..."  which would mean that if "f" is showable over all Data, then "Foo f" is showable over all Data
15:47:59 <shapr> g'nite FliPPeh!
15:48:02 <Botje> LAMH? aren't those the grenade thingies in Deus Ex ?
15:48:14 <FliPPeh> Linux Apache MySql Haskell!
15:48:23 <Botje> oh
15:48:28 <travisbrady> FliPPeh: sure, you can use Haskell with all those
15:48:29 <Botje> LASH sounds better, then :)
15:48:36 <FliPPeh> ;>
15:48:38 <Botje> (sql instead of mysql)
15:48:45 <shapr> hah
15:48:46 <FliPPeh> That's what I'm doing, travisbrady
15:48:48 <Botje> ooh
15:48:48 <travisbrady> if you want a framework you can check out HappStack or Turbinado
15:48:48 <cjfairley> haha
15:48:52 <Botje> add F for FastCGI!
15:48:56 <FliPPeh> Setting up CGI
15:48:56 <Botje> then we get FLASH!
15:48:59 <shapr> Ok, anyone in Boston here tonight?
15:49:04 <shapr> Or near Boston?
15:49:12 <FliPPeh> What about Lighttpd instead of Apache?
15:49:14 <FliPPeh> FLLSH
15:49:15 <FliPPeh> lame (
15:49:17 <FliPPeh> :(
15:49:25 <Botje> indeed
15:49:56 <FliPPeh> Too bad I could not get userpages working with lighttpd
15:49:58 <matthew-_> nginx is more the new koolaid, not lighttpd
15:50:01 <FliPPeh> So I had to fall back to apache
15:51:11 <mdmkolbe> Is there some way to do the equivalent of "instance (Data b, forall a. Data a => Show (f a)) => Show Foo f b where ..."  which would mean that if "f" is showable over all Data, then "Foo f" is showable over all Data
15:51:14 <matthew-_> last time I checked, the docs for lighttpd were one of the biggest jokes of all time
15:52:08 <shapr> mattam: Hey, you're at Harvard these days, right?
15:52:35 <mattam> Not yet, coming next Wednesday :)
15:53:44 <shapr> mattam: Aw, if I'd know that I would have moved the first meeting of the Haskell User's Group back a week!
15:54:01 <shapr> In any case, I'll buy you a beer when you get here.
15:54:22 <mattam> Great, at least 3 free beers await!
15:54:45 <neale> I'm having more noob problems with, I think, IO.
15:54:48 <neale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1779#a1779
15:55:15 <Cheshire> neale, woah it looks like ocaml
15:55:23 <neale> yeah, guess what language I'm coming from :)
15:55:27 <Cheshire> :p
15:56:41 <neale> the problem is something to do with how I call write_multi
15:58:40 <dmwit> neale: Okay, let's fix the code first, then make it pretty second.
15:58:40 <dmwit> Ready?
15:58:43 <neale> sure
15:59:09 <dmwit> First step: make sure write_multi actually gets inferred as a monadic type.
15:59:23 <dmwit> This means that you should use "return ()" instead of "()" and the second case should be in a "do" block.
15:59:32 <neale> huh
16:00:39 <dmwit> Next up: the standard library makes several of your calls there a bit more readable.
16:00:42 <dmwit> :t uncurry3
16:00:43 <lambdabot> Not in scope: `uncurry3'
16:00:46 <dmwit> shucks
16:00:48 <dmwit> Anyway:
16:01:12 <dobblego> a couple of Maybe.fmap and [].map
16:01:13 <dmwit> write_multi h xs = mapM_ (\(a, b, c) -> write h a b c) xs
16:01:40 <dmwit> Also take a look at "forever", as it makes the last bits of your main function turn into
16:02:01 <dmwit> forever (hGetLine h >>= write_multi h . handleLine)
16:02:28 <neale> :t mapM_
16:02:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:02:39 <neale> huh
16:02:45 <pumpkin> ?
16:04:19 <neale> dmwit: is there a way I can get write_multi (which should be writeMulti I suppose) to just return a list of actions to be run inside of main?
16:04:23 <neale> or is that just silly?
16:04:36 <dmwit> neale: Certainly!
16:04:47 <neale> ooh, I feel like I got something right :)
16:04:50 <dmwit> map (\(a, b, c) -> write h a b c) xs
16:05:04 <dmwit> You can use "sequence" or "sequence_" in main, when you're ready to run them.
16:05:08 <dmwit> ?src mapM
16:05:08 <lambdabot> mapM f as = sequence (map f as)
16:05:16 <neale> aha
16:06:17 <dmwit> text_str = maybe (const "") (" :" ++) text
16:06:21 <dmwit> :t maybe
16:06:22 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:06:31 <dmwit> A similar trick applies to sender_str.
16:07:04 <dmwit> args_str = concat . map (' ':) $ args
16:07:22 <dmwit> or just args_str = args >>= (' ':)
16:07:28 <dmwit> But that one's sneakier. ;-)
16:07:49 <dmwit> :t concatMap
16:07:50 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
16:08:05 <dmwit> :t \args -> concatMap (' ':) args -- does this work?
16:08:06 <lambdabot> [[Char]] -> [Char]
16:08:41 <neale> yes
16:08:44 <neale> but you've lost me now
16:08:57 <neale> oh, okay, I'm back on track
16:11:45 <dmwit> extract_word = partition (' '==) -- this is almost certainly not what you want...
16:11:57 <dmwit> > partition (' '==) "word1 word2 word3"
16:11:58 <lambdabot>   ("  ","word1word2word3")
16:12:10 <dmwit> > break (' '==) "word1 word2 word3"
16:12:11 <lambdabot>   ("word1"," word2 word3")
16:12:34 <neale> ah, no.
16:12:38 <neale> yes, I wanted break.
16:13:30 <neale> actually I want break and then tail on snd
16:13:52 <skorpan> @hoogle m a -> m ()
16:13:52 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
16:13:52 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
16:13:52 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
16:14:08 <dmwit> :t \p -> second (drop 1) . break p
16:14:09 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:14:25 <dmwit> > second (drop 1) . break (' '==) $ "word1 word2 word3"
16:14:26 <lambdabot>   ("word1","word2 word3")
16:14:26 <skorpan> i don't suppose there is any shorter way of writing "x >> return ()"?
16:14:34 <dmwit> skorpan: nope
16:14:35 <neale> dmwit: that hurt my head
16:14:39 <Gracenotes> you know, drop 1 is sort of a safe tail. :X
16:14:39 <skorpan> okay
16:14:50 <dmwit> neale: Sorry, let me slow down. =)
16:15:00 <neale> dmwit: no, no, let me figure it out
16:15:04 <dmwit> neale: "second" is a higher-order function that applies functions to the second half of tuples.
16:15:15 <dmwit> > second (+1) ("hey", 41)
16:15:16 <lambdabot>   ("hey",42)
16:15:19 <neale> ah
16:15:21 <pumpkin> don't ask for the type of it though
16:15:24 <pumpkin> it's scary :)
16:15:24 <neale> man, this is like common lisp
16:15:26 <skorpan> :t second
16:15:27 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:15:33 <skorpan> oh snap!
16:15:34 <neale> millions of little functions
16:15:41 <Gracenotes> b -> c -> (d, b) -> (d, c)
16:15:41 <dmwit> second :: Arrow (~>) => b ~> c -> (d, b) ~> (d, c) -- less scary
16:15:51 <Gracenotes> (b -> c) -> (d, b) -> (d, c), actually
16:16:04 <Gracenotes> for the (->) instance of the arrow
16:16:13 <skorpan> i'm confused
16:16:15 <pumpkin> or just use a squiggly one
16:16:19 <skorpan> what does ~> mean in types?
16:16:27 <dmwit> skorpan: It's an infix type constructor.
16:16:32 <pumpkin> people use it to mean arrow
16:16:38 <dmwit> skorpan: See the context?
16:16:40 <Gracenotes> see, typeclasses screw things up. Instances are easy enough to use :)
16:16:49 <skorpan> dmwit: oh!!
16:17:01 <skorpan> dmwit: that's confusing as hell
16:17:06 <dmwit> neale: To be really pedantic, you probably want
16:17:12 <pumpkin> that's why I said don't look at the type of second :P
16:17:16 <dmwit> :t \p -> second (dropWhile p) . break p
16:17:17 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:17:29 <skorpan> :t 5 + "hello"
16:17:30 <lambdabot>     No instance for (Num [Char])
16:17:30 <lambdabot>       arising from the literal `5' at <interactive>:1:0
16:17:30 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
16:17:33 <dmwit> skorpan: I find it less confusing than the prefix version of the type.
16:17:38 <Gracenotes> > (second :: (b -> c) -> (d, b) -> (d, c)) negate (5,10)
16:17:39 <lambdabot>   (5,-10)
16:17:52 <pumpkin> why the type signature?
16:17:59 <dmwit> for clarity
16:18:10 <Gracenotes> to show that it's can be of that type (and almost always is)
16:18:13 <Gracenotes> *it
16:19:22 <dmwit> > (length *** length) ("sequence_ [x]", "x >> return ()")
16:19:23 <lambdabot>   (13,14)
16:19:33 <neale> @hoogle second
16:19:33 <dmwit> skorpan: Aha!  There is a shorter way. =)
16:19:33 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
16:19:33 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
16:19:33 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
16:19:59 <neale> wild
16:20:02 <dmwit> > (length *** length) ("sequence_[x]", "x>>return()")
16:20:03 <lambdabot>   (12,11)
16:20:26 <dmwit> Let's see...
16:20:29 <travisbrady> anyone know of an example of Haskell code with crazy operator abuse?
16:20:34 <dmwit> ?hoogle m ()
16:20:35 <lambdabot> Distribution.Make defaultMain :: IO ()
16:20:35 <lambdabot> Distribution.Simple defaultMain :: IO ()
16:20:35 <lambdabot> System.Mem performGC :: IO ()
16:20:43 <ddarius> travisbrady: There's an IOHCC entry that does it.
16:22:17 <dmwit> neale: Incidentally, you can drop the parens around "stringOfCommand" in "write" and the parens around "commandOfString" in "handleLine".
16:22:18 <Gracenotes> @type (\x y -> x <<^(++)^>> y)
16:22:19 <lambdabot> forall (a :: * -> * -> *) c d a1. (Arrow a) => a c d -> (([a1] -> [a1]) -> c) -> a [a1] d
16:22:23 <Gracenotes> so cute, isn't it?
16:22:36 <neale> I'm using the parens to keep my sanity.
16:22:46 * dmwit nods
16:22:49 <neale> but it seems like Haskell people like to use as few parens as possible
16:22:52 <dmwit> totally reasonable
16:23:14 <neale> for instance, here's what I came up with
16:23:20 <neale> (second tail) ((break (' ' ==)) "a b c")
16:23:30 <neale> but I have a feeling I should have used more . and less ()
16:23:30 <dmwit> mmmm, lispy
16:23:34 <lament> it's because their inferiority complex - they're trying to distinguish themselves from lispers
16:23:38 <Gracenotes> some people think that $ is ugly
16:23:42 <neale> lament: that's my initial take on it.
16:23:55 <dmwit> neale: At the very least, take the parens away from break.
16:24:00 <Gracenotes> I'll say, a . b . c . d . e $ f doesn't look aesthetic at all
16:24:05 <dmwit> second tail (break (' ' ==) "a b c")
16:24:21 <Gracenotes> better than parens, at least
16:24:21 <Twey> neale: We would say: second tail $ break (' ' ==) "a b c"
16:24:39 <neale> yeah, that looks about right
16:24:43 <Gracenotes> second tail . break (' ' ==) $ "a b c" -- >_>  <_<
16:24:45 <dmwit> Gracenotes: a (b (c (d (e f)))) -- is even worse
16:24:46 <lament> (== ' ') -- maybe
16:25:04 <Gracenotes> dmwit: it has a certain, if not symmetry, charm
16:25:06 <lament> neale: note that mathematicians have the same hatred of extraneous parens
16:25:21 <lament> neale: haskell programmers just like making programs look like math
16:25:24 <RamzaB> hello im new to Haskell, is there any good IDE?
16:25:28 <dmwit> lament: If you use (' ' ==), it's possible that a smart instance could calculate that section once, rather than once for each use. ;-)
16:25:45 <dmwit> RamzaB: emacs and vim are the best we've got.
16:25:50 <dmwit> (And they're pretty good!)
16:26:00 <neale> @hoogle forever
16:26:01 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
16:26:03 <lament> dmwit: if it's smart it ought to know == commutes!
16:26:04 <RamzaB> well im using windows :/
16:26:22 <dmwit> lament: No, that's the compiler's job...
16:26:31 <dmwit> RamzaB: emacs and vim are available for Windows, too.
16:26:34 <lament> the compiler ought to assist, etc
16:26:40 <RamzaB> oh ok thank you
16:26:50 <Gracenotes> forever and ever and ever and ever
16:27:02 <Gracenotes> pssh, why type it out when I could have lambdabot do it for me :/
16:27:11 <dmwit> lament: Right, but that's going above and beyond the spec, whereas writing (==) a = \b -> ... -- is perfectly within the spec as a client-side optimization...
16:27:33 <pastah> @pl \(x,y) -> (y,x)
16:27:33 <lambdabot> uncurry (flip (,))
16:27:41 <dmwit> :t snd &&& fst
16:27:42 <lambdabot> forall a b. (a, b) -> (b, a)
16:31:17 <dmwit> Well, ((==) a = let foo = some complicated expression using a in \b -> ...), anyway.
16:31:50 <dmwit> It's not likely to matter much, anyway. =P
16:32:47 <neale> dmwit: thanks for all your help
16:33:43 <dmwit> no problems =)
16:35:00 <travisbrady> RamzaB: you could have a look at Yi http://www.haskell.org/haskellwiki/Yi
16:35:10 <travisbrady> oh and there is Leksah
16:37:29 <Raynes> I wonder how many people turn down even looking at Haskell because it lacks a decent IDE.
16:37:44 <Raynes> I wish I had a number - Some statistics.
16:37:55 <neale> I think if you've gotten to the point of wanting to learn Haskell, lack of an IDE isn't going to sway you.
16:39:11 <Raynes> I do. I've seen even professional programmers get excited about Haskell and then disregard it completely after seeing that Emacs and Vim are the only really decent things available for it.
16:39:26 <Raynes> s/do/don't/
16:39:56 <jeffz`> their loss?
16:40:08 <Raynes> Their loss.
16:40:42 <travisbrady> an ide is way overkill at first, keyword completion/refactoring support are not important when you're taking your first steps
16:40:55 <Debugger> If you can't program without an IDE... you shouldn't be programming at all.
16:41:28 <travisbrady> anyway vim rules, not sure why you'd need some ram hungry ide to make your laptop's fan turn on
16:41:28 <Twey> If you need an IDE then there's something wrong with the language and/or libraries
16:41:30 <Raynes> Debugger: It's not about /can't/ it's about /don't want to/.
16:41:42 * Raynes <3's his emacs.
16:41:44 <xci> Debugger: I probably could not program without vim or similar
16:41:56 <xci> and isn't that a similar thing
16:41:59 <xci> as a lack of IDE
16:42:10 <Twey> Raynes: They don't seem to see that their IDEs are pointless in a decent language, because they're just compensating for the failings of their language
16:42:12 <RamzaB> im just wondering coming from C++, can you create all the data structs like binary tree/graphs in Haskell?
16:42:22 <Twey> Raynes: Yes
16:42:23 <Twey> Er
16:42:25 <Twey> RamzaB: Yes
16:42:32 <Twey> Much more easily, generally
16:42:42 <RamzaB> ok thank you
16:43:10 <Raynes> Twey: Are you saying that if a language has an IDE and people use it, there is something wrong with the language?
16:43:24 <Twey> RamzaB: For example, a binary tree: data Tree a = Leaf a | Branch (Tree a) (Tree a)
16:43:58 <Twey> RamzaB: No; I'm saying that if people rely so much on that IDE that they're unwilling to program without it, there's something wrong with the language
16:44:18 <Twey> Gah
16:44:20 <Twey> Raynes: ^
16:44:59 <Raynes> Twey: I'd have to say that if people rely so much on an IDE, there is something wrong with the person.
16:45:14 <Twey> I wouldn't
16:45:29 <Twey> For example, in Java there are no integrated getters and setters
16:45:47 <Twey> So good practice is to build a getX()/setX() method for every property x on a class
16:46:07 <Twey> It can get very tedious, and I can understand if someone didn't want to part with an IDE that did that for them
16:51:08 <m0nkfish> > map (^3) [1..5]
16:51:09 <lambdabot>   [1,8,27,64,125]
16:54:03 <m0nkfish> > [ x^3 | x <- [1..5] ]
16:54:05 <lambdabot>   [1,8,27,64,125]
16:55:01 <dmwit> > [x^3 | x <- [1..], even x]
16:55:02 <lambdabot>   [8,64,216,512,1000,1728,2744,4096,5832,8000,10648,13824,17576,21952,27000,3...
16:55:13 <Gracenotes> Incredible !!
16:57:04 <ddarius> > scanl1 (+) . filter odd $ [1..]
16:57:05 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:57:53 <|jedai|> > scanl1 (+) [1,3..]
16:57:55 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
17:04:54 <shapr> Does Conrad Parker hang out on #haskell?
17:05:30 <shapr> Oh wait, that's kfish!
17:06:27 <RamzaB> can anyone help me on how to install emacs for haskell on windows xp?
17:07:00 <shapr> RamzaB: Get EmacsW32 and then get haskell-mode separately?
17:07:04 * monochrom discovers a new abuse of lambdabot's edit-distance-2 allowance
17:07:10 <monochrom> @shapr monochrom
17:07:11 <lambdabot> stop telling me what to do
17:07:20 * shapr sniffles
17:07:22 <monochrom> @shapr monochrom
17:07:22 * lambdabot clobbers monochrom with an untyped language
17:07:23 <shapr> Always ordering me around!
17:07:33 <shapr> @shapr shapr
17:07:33 <lambdabot> *SMACK*, *SLAM*, take that shapr!
17:07:46 <shapr> That's sort of like badger badger badger, but more masochistic.
17:07:58 <shapr> RamzaB: Does that help?
17:08:05 <monochrom> clobbering with an untyped language is a big punishment to me. :)
17:08:20 <RamzaB> i'll try it, never used emacs/vi before
17:08:27 <shapr> RamzaB: They both have their good points.
17:09:09 <monochrom> . o O ( Do you use Visual Studio .NET.ASP.COM.DCOM.ActiveX 2013 usually? )
17:15:24 <jfredett_> @where shapr
17:15:24 <lambdabot> http://www.ScannedInAvian.com/hope
17:15:30 <jfredett_> @seen shapr
17:15:30 <lambdabot> shapr is in #haskell and #haskell-blah. I last heard shapr speak 7m 2s ago.
17:15:35 <jfredett_> I always get that confused
17:15:35 <shapr> jfredett_: whaat?
17:15:44 <jfredett_> wheres the ML for CHUG?
17:15:50 <jfredett_> I haven't sub'd yet.
17:16:03 <shapr> http://groups.google.com/group/bostonhaskell
17:16:04 <jfredett_> I dunno if I'm gonna be able to make it- it's on saturday right?
17:16:09 <shapr> yup, sat @ noon
17:16:12 <shapr> c'mon, it'll be fun!
17:16:17 <jfredett_> I'll try
17:16:21 <shapr> awright, I hope to see you there.
17:16:34 <shapr> I'm doing a presentation on QuickCheck.
17:16:41 <shapr> I should really start working on that.
17:17:17 <edwardk1> jfredett_: saturday noonish was when we were looking at getting started iirc, but since shapr made the invite from like noon to 8:00 or something people will probably drift in all day ;)
17:18:15 <shapr> edwardk1: Er, I thought it was noon to 2pm?
17:18:21 <edwardk1> is it?
17:18:24 <edwardk1> even better
17:18:26 <shapr> Did I really say noon to night?
17:18:32 <shapr> huh, I don't remember that.
17:18:35 * shapr shrugs
17:18:36 <edwardk> dunno, amy mentioned the 8:00pm thing
17:18:46 <jfredett_> okay, I gotta dig up directions from South Station.
17:18:54 <shapr> No no, I have to be at a party on the other side of town at 7pm on Saturday.
17:19:02 <jfredett_> I'm gonna take the T in...
17:19:13 <shapr> And I have to be dressed nicely, and bring whiskey, and there will be chicks there.
17:19:23 <shapr> Aaanyway...
17:19:27 <jfredett_> am I gonna be able to get internet at this place?
17:19:36 <shapr> jfredett_: Yeah, guess logon to the wifi
17:19:39 <shapr> guest*
17:19:48 <shapr> Though I like the first sentence better :-)
17:20:32 <jfredett_> okay, then I should be able to SSH to my server, I think I have GHC installed on my other boot. but all my stuff is on my server...
17:21:12 <shapr> jfredett_: You're going to talk about some of your cool Haskell code?
17:21:28 <edwardk> shapr: no _pressure_ or anything ;)
17:21:49 <shapr> edwardk: If the CHUG goes to 8pm, I won't be there.
17:22:05 <edwardk> lets go with the noon to 2 thing, that fits with what we have content for
17:22:08 <shapr> yup
17:22:25 <edwardk> then we can hang for an hour or two or whatever and figure out content for the next one
17:22:25 <shapr> And honestly, I hope to do about twenty minutes of QC et al, and then get someone else to talk.
17:22:48 <shapr> Oh, and Norman Ramsey sent me an email pointing out that this is terrible timing, ICFP submission deadline is Monday.
17:22:53 <edwardk> hahahaha
17:22:58 <shapr> Yeah, I felt pretty silly :-)
17:23:01 <jfredett_> holy crap, thats a long way...
17:23:16 <shapr> jfredett_: Dude, I pick you up.
17:23:19 <jfredett_> is there a T stop in waltham? :/
17:23:22 <edwardk> jfredett_: well, i'm coming down there from somerville, if you want to meet up somewhere in the middle no big deal
17:23:39 <shapr> edwardk: Which one is over here? North station?
17:23:52 <shapr> Anyway, I gotta go exercise, bbl
17:24:17 <jfredett_> edwardk: I don't have a car, so middle would have to be defined as... well... here.
17:24:29 <endojelly> I have an oral exam in lambda calculus tomorrow
17:24:42 <edwardk> i;m about equidistant to lechmere and sullivan
17:24:48 <edwardk> on green and orange
17:24:51 <jfredett_> The T station is right near me though, walking distance (I'm in Worcester)
17:25:00 <jfredett_> I'm sure theres a T station nearby...
17:25:06 <dolio> Oral exam?
17:25:08 <jfredett_> I just have to look hard enough. :P
17:25:30 <endojelly> oral exam.
17:26:08 <jfredett_> looks like I can take the T from Worcester to North Station, North Station to Waltham...
17:26:18 <edwardk> shapr: you said there was some interest in hosting the next one at mit?
17:26:49 <dolio> Seems like an odd format for that subject.
17:27:30 <jfredett_> edwardk: MIT would be a way better location, it's 1.5hrs to get into boston via the T
17:27:35 <edwardk> dolio: depends on if you give the poor guy a whiteboard or you expect him to do normal forms in his head ;)
17:27:53 <dolio> Either way.
17:28:07 <edwardk> jfredett_: well, if we can get enough people out to this one to show interest i think we can make it fly =)
17:28:26 <endojelly> dolio, I'm sure it involves paper and a pen
17:28:39 <edwardk> that reminds me i never did check with shapr's nemesis to see if he was interested
17:28:41 <jfredett_> hehe, My fiance says if someone picks me up, she'll make cookies...
17:29:13 <ddarius> edwardk: You could introduce them.
17:29:29 <edwardk> might be bloody
17:29:36 <jfredett_> 6 Dean Street in Worcester, Link to Googlemaps forthcoming...
17:30:02 <jfredett_> oops, that was supposed to be a whisper, oh well, stalkers know where I live now.
17:30:07 <dolio> I think the only oral exams I ever had were foreign language, which makes sense since ability to actually speak the language is part of the subject.
17:30:12 <edwardk> hah
17:30:14 * ddarius stalks jfredett
17:36:30 * edwardk isn't sure he'd want to be anywhere near ground zero should shapr and smerdyakov actually meet. matter, anti-matter and all that e = mc^2 jazz
17:38:59 <llayland> just got yi installed.  anybody know where I can get a good yi.hs vim style with reasonable auto-indenting for haskell?
17:39:13 <ddarius> edwardk: They say if matter and anti-matter came into contact they'd wouldn't make a big boom (without quite a bit of opposing momentum) but would rather "sizzle" against each other.
17:40:39 <endojelly> ddarius, still that enormous amount of energy would do... something? radiation maybe?
17:41:01 <jfredett_> I hate it when my computer crashes due to overheating... :(
17:41:06 <edwardk> sounds strangely erotic. either way i'm not sure i'd want to watch them go at it ;)
17:42:05 <llayland> jfredett_ would underclocking it be a big burden?
17:42:29 <jfredett_> llayland: it's not a common enough problem, I probably just need to clean the fan
17:42:35 <jfredett_> the things always run pretty hot...
17:53:15 <jfredett> *sighs* waltham is a bitch.
17:55:35 <HugoDaniel> this is not entirely haskell related, but what kind of software engineering methodology would fit haskell better ?
17:57:17 <edwardk> HugoDaniel: i go with hack -> ship. http://weblogs.java.net/blog/chet/archive/2008/01/crystal_methodo.html
17:57:19 * araujo doesn't believe at SE
17:58:05 <dons> ?yow
17:58:05 <lambdabot> I KAISER ROLL?!  What good is a Kaiser Roll without a little COLE SLAW
17:58:05 <lambdabot> on the SIDE?
17:58:48 <dons> HugoDaniel: hmm. you may be able to compress some things (e.g. 'pseudocode design' directly in executable haskell), or automated testing via QuickCheck
17:59:50 <HugoDaniel> ok, i tend to find pseudocode design quite enjoyable with haskell, since i tend to write higher level pseudo-code
18:02:02 <edwardk> HugoDaniel: the problem with that in Haskell is by the time you're done, your pseudocode just executes, and then what do you do for the other 80% of your time?
18:03:02 <ddarius> edwardk: Read papers.
18:03:36 <HugoDaniel> i dont think its that linear... specially in my case, because im learning a lot as i go
18:05:05 <edwardk> HugoDaniel: no worries, it accelerates as you go. alas, in the end you asymptotically approach writing no code at all, as you realize everything you want is in the prelude, or failing that, at least in hackage ;)
18:08:01 <jml> ... or is a language extension
18:08:38 <HugoDaniel> ... or you just need to write a ffi yourself
18:08:39 <ddarius> edwardk: I asymptotically approach writing no code at all, but only because the "reading papers" part approaches 100% of your time.
18:08:51 <pastah> @type getLine
18:08:52 <lambdabot> IO String
18:09:36 <pastah> @pl \xs -> when (null xs) return "hej"
18:09:37 <lambdabot> flip (flip when return . null) "hej"
18:09:56 <edwardk> you asymptotically approach no code because you're too busy answering all the questions i have from the 100% of my time i spend reading papers? sounds about right ;)
18:10:06 <Cale> @pl \xs -> when (null xs) (return "hej")
18:10:06 <lambdabot> flip when (return "hej") . null
18:10:28 <pastah> Cale: thanks
18:33:25 * byorgey steeps some orange-lambda herbal tea
18:42:02 <pastah> @pl \ts es -> (length ts /= length es)
18:42:02 <lambdabot> (. length) . (/=) . length
18:43:56 <Axman6> > ((==)`on` length) [1..10] [1..3]
18:43:57 <lambdabot>   False
18:44:01 <Axman6> > ((==)`on` length) [1..10] [1..10]
18:44:03 <lambdabot>   True
18:44:04 <Gracenotes> pl doesn't seem to like on... oh wait, Axman6 :D
18:44:09 <Gracenotes> ya got it
18:44:11 <Axman6> :)
18:44:41 <Axman6> > ((/=)`on` length) [1..10] [1..3] -- is the original function
18:44:43 <lambdabot>   True
18:45:57 <Cale> > ((/=)`on` length) [1..] [1..3]
18:46:14 <Gracenotes> heh
18:46:18 <lambdabot>   mueval: Prelude.read: no parse
18:46:50 <Gracenotes> well, we don't all have to worry about infinite lists, although they're trouble when we do but we think we don't >_>
18:47:03 <Gracenotes> > ((/=) `on` map (const ())) [1..] [1..3] -- messy, but
18:47:07 <lambdabot>   True
18:47:20 <Gracenotes> a recursive helper function wouldn't be terrible
18:47:42 <Axman6> > [(),()..]
18:47:43 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
18:47:46 <Axman6> >_>
18:47:55 <skorpan> > >_>
18:47:56 <lambdabot>   <no location info>: parse error on input `>'
18:48:08 * Axman6 should get off to a lecture soon
18:49:19 <ddarius> [x,x ..] is always identical to repeat x
18:49:45 <Cale> > [id, id..]
18:49:46 <lambdabot>       Overlapping instances for Show (a -> a)
18:49:46 <lambdabot>        arising from a use of `s...
18:49:48 <ddarius> For imperfect values of "always"
18:50:00 <Cale> :t [id, id..]
18:50:03 <lambdabot> forall a. (Enum (a -> a)) => [a -> a]
18:50:07 <ddarius> Cale: There are actual counter examples (I suspect)
18:50:13 <Gracenotes> oh, jeez
18:50:28 <redditbot> Another reason to create distro-specific packages for Haskell modules
18:50:32 <Gracenotes> > (pred (+1)) 5
18:50:33 <lambdabot>       No instance for (Enum (a -> a))
18:50:33 <lambdabot>        arising from a use of `pred' at ...
18:50:37 <dolio> @src enumFromThenTo
18:50:37 <lambdabot> Source not found. That's something I cannot allow to happen.
18:50:43 <Gracenotes> ..ahm.. I see
18:50:52 <Gracenotes> yes, typeclasses do funny things
18:51:09 * Gracenotes huggles his Num ((a -> b) -> b)
18:52:21 <Gracenotes> succ might make sense for (a -> a). pred... er...
18:54:42 * wli usually does instance Num t' => Num (t -> t') where (f + g) x = f x + g x ; (f - g) x = f x - g x ; negate f x = negate (f x) ; abs f x = abs (f x) ; signum f x = signum (f x) ; fromIntegral n = const (fromIntegral n) 
18:55:06 <wli> (f * g) x = f x * g x
18:55:40 <Gracenotes> everywhere?
18:55:52 <Saizan> you can write that using only liftM and liftM2
18:55:59 <wli> No. Just as-needed.
18:56:08 <Gracenotes> liftA, liftA2! :D
18:56:38 <Saizan> Control.Applicative exports that instance?
18:56:58 <Gracenotes> yes.
18:57:18 <wli> Sure, instance Num t' => Num (t -> t') where (+) = liftM2 (+) ; (*) = liftM2 (*) ; (-) = liftM2 (-) ; negate = liftM negate ; abs = liftM abs ; signum = liftM signum ; fromIntegral = return
18:58:58 <wli> And instance Num t' => Num (t -> t') where (+) = liftA2 (+) ; (*) = liftA2 (*) ; (-) = liftA2 (-) ; negate = liftA negate ; abs = liftA abs ; signum = liftA signum ; fromIntegral = pure
19:00:35 <Saizan> pure . fromIntegral
19:02:12 <wli> Sorry, yeah.
19:02:25 <wli> return . fromIntegral in the liftM case.
19:14:40 <wli> Was the guy doing the BerkeleyDB -based MUD using HXT?
19:16:24 <wli> cabal: cannot configure BerkeleyDBXML-0.6.1. It requires base >=4
19:16:30 <wli> Go figure.
19:22:20 <dmwit> It's a shame you can't do something like
19:22:37 <dmwit> [(+), (-), (*), (/)] = map liftM2 [(+), (-), (*), (/)]
19:26:36 <shapr> Hm, I can't think of anything suitably Boston to hide under a lambda for a group logo.
19:26:41 <shapr> Perhaps red lambda sox?
19:27:17 <jstanley> what's the best way to turn an n^2-length list into a n-length list of n-element lists? unfoldr? a prim rec version converted to a fold?
19:30:53 <wli> jstanley: mkLOL xs = let chunk n = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) ; isqrt = floor . sqrt . fromIntegral ; k = length xs in chunk (isqrt k) xs
19:31:45 <jstanley> wli: *nod* thanks, is close to what i have
19:32:57 <wks> > take 6 $ map (take 2) $ iterate (drop 2) $ "Hello world!"
19:32:58 <lambdabot>   ["He","ll","o ","wo","rl","d!"]
19:33:23 <wks> jstanley, do you mean this?
19:34:29 <jstanley> wks: the generalized version of that, but i like it better than the unfoldr version above, yeah. iterate on drop is the idea i was looking for. thanks =)
19:35:55 <mmorrow> @type ((((join . join) . join) .) . liftM2 (liftM2 (liftM2 (liftM2 (+)))))
19:35:56 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m (m (m (m a1))) -> m (m (m (m a1))) -> m a1
19:37:48 <mmorrow> @type (join .) . liftM2 (>>=)
19:37:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (m a) -> m (a -> m b) -> m b
19:38:49 <mmorrow> @let (=<<<) = (join .) . liftM2 (=<<)
19:38:50 <lambdabot>  Defined.
19:38:57 <mmorrow> @type (=<<<)
19:38:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> m b) -> m (m a) -> m b
19:39:42 <mmorrow> @type (join .) . liftM2 (<=<)
19:39:43 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (a -> b -> m c) -> (a -> a -> m b) -> a -> m c
19:40:08 <pumpkin> fancy
19:41:23 <pumpkin> > [[1]] =<<< [(\x -> [x+1])]
19:41:24 <lambdabot>   Couldn't match expected type `a -> [b]'
19:42:23 <pumpkin> oh whoops
19:42:48 <pumpkin> > [(\x -> [x+1])] =<<< [[1]]
19:42:49 <lambdabot>   [2]
19:43:23 <pumpkin> > [(\x -> [x+1, x+2]), (\x -> [2*x, 3*x]] =<<< [[1]]
19:43:24 <lambdabot>   <no location info>: parse error on input `]'
19:43:36 <pumpkin> > [(\x -> [x+1, x+2]), (\x -> [2*x, 3*x])] =<<< [[1,2], [7]]
19:43:37 <lambdabot>   [2,3,3,4,8,9,2,3,4,6,14,21]
19:45:11 <dmwit> :t \mf mm -> do { f <- mf; m <- mm; x <- m; return (f x) }
19:45:12 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t (t1 -> t2) -> t (t t1) -> t t2
19:45:27 <dmwit> whoops
19:45:31 <dmwit> :t \mf mm -> do { f <- mf; m <- mm; x <- m; f x }
19:45:32 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t (t1 -> t t2) -> t (t t1) -> t t2
19:45:43 <dmwit> That's a weird one.
19:46:16 <pumpkin> :o
19:46:35 <dmwit> Is there a benefit to doing the join inside of (=<<<) rather than before it gets called?
19:46:38 <pumpkin> too many ts
19:47:01 <pumpkin> how does :t decide what type variables to use?
19:47:17 <dmwit> It uses the type signatures of its constituent functions, adding numbers to avoid conflicts.
19:47:35 <dmwit> :t let foo :: a -> x -> z; foo = undefined in foo 3
19:47:37 <lambdabot> forall x z. x -> z
19:48:15 <dmwit> :t let foo :: a -> x -> z; foo = undefined in foo (foo 3)
19:48:16 <lambdabot> forall x z. x -> z
19:48:28 <dmwit> err
19:48:33 <dmwit> :t let foo :: a -> x -> z; foo = undefined in foo . foo
19:48:34 <lambdabot> forall x z a. a -> x -> z
19:48:58 <dmwit> blagh
19:49:35 <dmwit> :t let foo :: a -> x -> z; foo = undefined in \a b -> foo a 3 + foo b 3
19:49:36 <lambdabot> forall a z a1. (Num z) => a -> a1 -> z
19:49:40 <dmwit> finally
19:50:30 <pumpkin> I see
19:50:57 <pumpkin> :t undefined . undefined
19:50:58 <lambdabot> forall c a. a -> c
19:51:04 <pumpkin> :t (.)
19:51:05 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:06:17 * SamB wonders what continent community.haskell.org is in
20:06:21 <SamB> s/in/on/
20:07:37 <monochrom> Continent Haskell.
20:08:07 <SamB> what ... is it really in the same state as me ?
20:08:35 <monochrom> The Mutable State?
20:08:54 <SamB> no, pennsylvania
20:09:09 <monochrom> Interesting.
20:09:43 * wli is trying to figure out denotational semantics so as to help figure out how to specify and implement a sufficiently stupid but also sufficiently-featured mini-language.
20:11:26 * wli thinks it has something to do with defining the result of a program in terms of structural induction except for the parts where it's not obvious how to represent the result like functions, types, modules, et al.
20:11:43 <wli> Exception handling, too.
20:11:53 <wli> Side effects like IO, too.
20:12:34 <wli> This basically leaves arithmetic expressions as it.
20:12:44 <thoughtpolice> hehe
20:13:04 <ddarius> Goedel encode everything and call it a day.
20:15:16 <wli> I'm lost as to how to represent the meaning of a function definition.
20:15:16 <Saizan> we use monads for exception handling and similar things, maybe we can use them for modules too? or is there another construct already?
20:15:38 <wli> (to start with the very most basic affair)
20:16:00 <wli> Saizan: This is more on the "how to write an interpreter" level of things.
20:16:02 <monochrom> I/O is known to be hard in denotational semantics. Don't try it first.
20:16:48 <wli> Well, functions, user-defined types, and modules are enough for ... if not now, maybe the next 10 years.
20:16:50 <monochrom> Try a pure functional language first. Can still be more interesting than arithmetic.
20:17:02 <Saizan> wli: you can represent those as functions in the host language, though if you translate from a regular AST you won't get something efficient
20:18:29 <wli> monochrom: I've already fallen apart on that level when it comes to functions, user-defined types, and modules. Even with no side effect capabilities so it's no better than a calculator in the end, I'm lost.
20:18:51 <Saizan> (unless you use combinators like in SKI, the point is that substitution will happen under a lambda so it won't be shared)
20:18:58 <monochrom> You can make it a boolean calculator...
20:19:46 <monochrom> Denotational semantics doesn't treat modules.
20:19:50 <wli> Well, too little substance makes the exercise pointless.
20:20:04 <wli> monochrom: What does?
20:20:43 <monochrom> Some people do it by creating a type system.
20:20:47 <wli> Well, might as well forget modules for now since I'm lost on far more basic levels.
20:20:57 <monochrom> Some people don't formalize it at all.
20:28:39 <wli> How do you represent the meaning of a function?
20:30:01 <newsham> lambda calculus?
20:30:20 <newsham> lattice of least upper bound for recursion?
20:30:22 <wli> Denotational semantics yeah.
20:31:28 <wli> Well, you want to write an interpreter using the denotational semantics somehow, so your meaning function done via structural induction has to have some way to return a meaning for a function ... preferably one of observable type.
20:32:11 <ddarius> Denotational semantics aren't for writing interpreters, their for understanding languages (or syntaxes in general)
20:33:01 <Saizan> one way is to just return the AST together with an environment for the free variables
20:33:28 <wli> I thought they had some innate connection with writing interpreters.
20:34:02 <wli> Saizan: That sounds plausible.
20:34:12 <ddarius> No, though writing a denotational semantics is rather similar to writing an interpreter in the lambda calculus.
20:34:19 <ddarius> (usually)
20:35:05 <wli> I guess Saizan's answer works for me. Next up is user-defined data types.
20:35:33 <ddarius> wli: If you want to write interpters, look up stuff on writing interpreters.
20:35:40 <sw17ch> hello all
20:36:36 <wli> I guess I wait until my books are accessible again, though for the most part they only cover untyped languages with no modules.
20:38:28 <newsham> types usually (always?) just disqualify some programs, but dont affect the way you interpret the program.
20:38:35 <juhp> lambdabot: @help
20:38:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:38:38 <Saizan> user-defined datatypes essentially introduce some constants into the typechecker and evaluator environments
20:38:42 <newsham> well, i guess there's the dynamic dispatch stuff
20:38:56 <newsham> if you support polymorphism
20:39:28 <newsham> you can translate data types into functions in lazy lambda calculus
20:39:29 <ddarius> newsham: Often, particularly for more advanced type systems, type erasure is non-trivial.
20:39:35 <juhp> wish lambdabot didn't need @ for privmsgs...
20:39:50 <newsham> ahh.  I'm not too familiar with interpretting those things
20:39:57 <wli> newsham: For parametric-only there shouldn't be dynamic dispatch.
20:40:09 <wli> Saizan: What kinds of constants?
20:41:10 <sw17ch> has any one done work translating the "waht" of code into a spoken language?
20:41:26 <newsham> ie:   nil = \f g -> f; cons x xs = \f g -> g x xs
20:41:58 <sw17ch> map (+1) [1..10] -> "Apply a function which increments a value by 1 to the range of numbers from 1 to 10 and return the result."
20:42:02 <sw17ch> or something simliar?
20:42:04 <Saizan> wli: e.g. data List a = Cons a (List a) | Nil, adds List :: Type -> Type, Cons :: forall a. a -> List a; Nil :: forall a. List a
20:42:05 <wli> So the constructors would be function constants.
20:42:28 <mcnster> hi.  is greencard still a good way to generate ffi?  it seems out of date...
20:44:02 <Saizan> sw17ch: "and return the result" is not really appropriate for a lazy language
20:44:03 <Cale> mcnster: Apart from using the FFI directly, I think c2hs is the most commonly used tool.
20:44:20 <sw17ch> Saizan, i'm aware... but i couldn't think of anything better to say in the 4 seconds i decided to think about it :)
20:44:33 <wli> Saizan: How do you make case statements work with the new constructors?
20:44:41 <mcnster> Cale, thx. :) i'll have a look at it then
20:45:19 <juhp> how to get lambdabot onto another channel? :)
20:46:07 <Cale> mcnster: You should definitely read the FFI spec, which is fairly tutorial in nature, if you haven't already.
20:46:15 <Saizan> wli: right, you've to mark the constructors as so, and then typecheck patterns as if they were expressions where what isn't a constructor is a fresh variable
20:46:37 <Cale> mcnster: It's quite likely that to use things like c2hs you'll need to know what you'll learn from there anyway :)
20:47:19 <mcnster> Cale, yes, i could use a refresher.  as long as you're here, have you ever heard of anyone making haskell bindings to libbfd and libopcodes?
20:47:35 <Cale> mcnster: Nope... I don't even know what those are...
20:48:30 <mcnster> Cale, gnu/unix generalized interfaces to elf and other kinds of platform binaries
20:50:57 <sw17ch> @seen dons
20:50:57 <lambdabot> dons is in #haskell, #concatenative, #arch-haskell, #darcs, #xmonad and #ghc. I last heard dons speak 2h 52m 8s ago.
20:51:53 <erikc> mcnster: there are some pure haskell elf/dwarf/pecoff/macho packages (reading only) on hackage
20:53:09 <mcnster> erikc, thanks :) i'll have a look
21:02:40 <Shimei> Random question: has anyone ever tried to implement skip lists in Haskell? A google search didn't turn up anything interesting. Any particular difficulties with implementing one?
21:04:20 <sw17ch> Shimei, i thought about doing it once... and then discovered that it some how wasn't worht it
21:04:23 <sw17ch> i can't remember why
21:04:44 <sw17ch> but i think part of the problem is that (in my mearger understanding), skip lists are best served by a doubly-linked list
21:04:48 <sw17ch> which have limited use in haskell
21:05:00 <sw17ch> (again, if my meager understanding serves me correctly)(
21:06:12 <Shimei> Hmm. I thought skip lists only needed links in one direction? As long as you keep track of your path through the list when searching anyway.
21:06:28 <Shimei> Without keeping track, the double links seem necessary.
21:06:51 <blackh> Shimei: http://www.haskell.org/pipermail/haskell-cafe/2009-January/052795.html
21:06:54 <sw17ch> yeha, i suppose you could get as far as "whoops, this is too far" and then backtrack
21:07:07 <blackh> Shimei: I'm playing with this doubly-linked list implementation as it happens right now.
21:07:16 <blackh> Shimei: It seems to have some rough edges.
21:07:25 <sw17ch> note: i didn't say they weren't possible :)
21:09:31 <Shimei> I think that if one were to implement skip lists, with either single or double links, its operations would require an extra RandomGen argument though?
21:09:47 <Shimei> blackh: Oh neat. That's some cool code.
21:10:03 <Shimei> Is it efficient?
21:10:34 <blackh> Shimei: It is brilliant! Yes - it is efficient... though I haven't given it any decent tests
21:11:11 <ddarius> Shimei: If you are making a mutable linked list, supporting random numbers will be no problem.
21:12:30 <blackh> Shimei: I am tweaking it. There are a couple of things missing: move_left and ==
21:13:06 <Shimei> Cool. Are you going to librarify it on hackage after tweaking? :)
21:14:53 <jfredett> trying to write to a file via writeFile, except I need to read from the file first, so I get a file lock error, can't find a "closeFile" function on hoogle. am I just blind?
21:15:04 <blackh> Shimei: Hmm... Maybe I should do that after I've tested it by using it for my purpose.
21:15:11 <ddarius> jfredett: hClose
21:15:19 <jfredett> ah, brilliant
21:15:50 <blackh> I also have a polygon clipping algorithm that I don't know what to do with. (Anyone want it?)
21:18:06 * thoughtpolice <3 oleg code
21:18:36 <pumpkin> jfredett: a nice function is withFile
21:18:38 <jfredett> hmm, that doesn't work, since I'm just using readFile/writeFile.
21:18:45 <jfredett> pumpkin: i'll look at that...
21:19:05 <pumpkin> yeah, you can't really rely on readFile closing the file at a particular time
21:19:17 <pumpkin> unless you read to the end
21:19:39 <jfredett> right, withFile/openFile look like they'll do what I need to.
21:19:43 <thoughtpolice> can't you use the 'strict' package which has a strict readFile/writeFile?
21:21:17 <jfredett> hehe, I'm just writing a one-off script... did it in haskell on a whim... now I get to play with fun new IO stuff!
21:21:37 <mmorrow> jfredett: bracket is lovely
21:21:44 <mmorrow> bracket (openFile "foo" ReadMode) hClose (\h -> ....) >> .....
21:22:16 <mmorrow> bracket (malloc 1024) free (\ptr -> ....)
21:22:25 <pumpkin> fancy!
21:22:28 <mmorrow> bracket (connect ....) sClose (\s -> ...)
21:22:30 <jfredett> yah, I don't need _that_ much control... :P
21:22:43 <mmorrow> pumpkin: totally
21:22:54 <ddarius> mmorrow: That pattern is given syntactic support in C#
21:22:55 <pumpkin> @index malloc
21:22:56 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
21:23:03 <jfredett> I just want to add some license info text to the top of a file... It's not like I'm firing nukes or something. :)
21:23:10 <mmorrow> ddarius: what does it look like?
21:23:26 <mmorrow> pumpkin: mallocBytes is nice
21:23:37 <pumpkin> what's the difference?
21:23:43 <sw17ch> mmorrow, is bracket defined, or is it an exercise left to the user :)
21:23:44 <ddarius> using(FileStream foo = new FileStream("foo")) { ... }
21:23:46 <mmorrow> (just foreign import unsafe ccall "malloc" malloc :: CSize -> IO (Ptr a))
21:23:50 <mmorrow> (or ..)
21:24:03 <mmorrow> sw17ch: it's in Control.Exception
21:24:06 <sw17ch> bracket :: IO a -> (a -> IO b) -> IO c
21:24:09 <sw17ch> :t bracket
21:24:10 <lambdabot> Not in scope: `bracket'
21:24:19 * sw17ch goes to check his type sig
21:24:29 <mmorrow> it uses `block' internally to ensure safety from async exceptions during critical stretches :)
21:24:45 <mmorrow> @src bracket
21:24:45 <lambdabot> bracket before after thing = block $ do
21:24:45 <lambdabot>     a <- before
21:24:45 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
21:24:45 <lambdabot>     after a
21:24:45 <lambdabot>     return r
21:25:01 <mmorrow> sweet, i didn't think that was gonna come back with the code
21:25:07 <pumpkin> @src block
21:25:07 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:25:09 <sw17ch> ahhh
21:25:10 <pumpkin> :(
21:25:11 <sw17ch> so close
21:25:22 <mmorrow> @hoogle block
21:25:22 <lambdabot> Control.Exception block :: IO a -> IO a
21:25:22 <lambdabot> System.IO BlockBuffering :: Maybe Int -> BufferMode
21:25:22 <lambdabot> Control.Exception BlockedIndefinitely :: Exception
21:25:25 <sw17ch> bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:25:28 <sw17ch> sweet
21:25:48 * sw17ch wonders if a more general version would make sense
21:25:59 <pumpkin> oh mallocBytes is just the c version
21:26:01 <sw17ch> bracket :: m a -> (a -> m b) -> (a -> m c) -> m c
21:26:38 <pumpkin> does alloca work like the c version?
21:26:40 <mmorrow> ddarius: heh, that C# is kinda like "syntactic cps"
21:26:57 <mmorrow> (w/ block as cont)
21:27:04 <Saizan> which?
21:27:11 <Nafai> It's enlightening to compile your code with -Wall :)
21:27:20 <mmorrow> Saizan: <ddarius> using(FileStream foo = new FileStream("foo")) { ... }
21:27:41 <ddarius> mmorrow: Not really, or not anymore than a for-loop.  (It's quite a bit simpler than almost all other control structures.)
21:27:50 <ddarius> pumpkin: No.
21:27:52 <edwardk> the using declaration, which implicitly does the try catch cleanup of an IDisposable
21:28:13 <pumpkin> ddarius: how does it differ from malloc then?
21:28:41 <pumpkin> ah
21:28:59 <pumpkin> it just gets rid of the allocated buffer as soon as you're done?
21:29:09 <ddarius> pumpkin: It's pretty much like the bracket malloc example mmorrow gave earlier.
21:29:15 <edwardk> ddarius: actually its implementation is somewhat painfully tricky, kind of like their lock, which you can't directly mimic with the public primitives (because of how it works with regards to allocation of the boolean result) =/
21:29:32 <pumpkin> allocaBytes size  = bracket (mallocBytes size) free
21:29:33 <pumpkin> aha
21:29:34 <pumpkin> :)
21:31:10 <ddarius> edwardk: "boolean result" ?
21:31:43 <edwardk> (i.e. i.e. with the syntactic sugar for lock they internally use an internal linkage variant on Monitor.TryEnter that uses an out parameter for the boolean result rather than return it, and all sorts of craziness to comply with their ReliabilityContract stuff) -- to be waay too pedantic
21:32:20 <ddarius> edwardk: Oh, I thought you meant that w.r.t. to the using statement.
21:32:24 <edwardk> ddarius: its one of those things when you start going for a 5th or 6th 9 worth of reliability out of .net code.
21:32:33 <edwardk> the using statement desugars to something equally painful
21:33:29 <edwardk> the lock sugar was something i had dealt with fairly recently though.
21:48:25 <pumpkin> we need a CRF library for haskell, maybe I'll write one
21:49:03 <jfredett> ... this is odd. I have tried several permutations of write/read. but it seems, while I tell haskell to read the file, it doesn't, even though I use it later on...
21:49:22 <edwardk> jfredett: using getContents or what?
21:49:24 <jfredett> I mean- I do a foo <- hGetContents myhdl
21:49:46 <jfredett> then let formatted = formatText bar ++ foo
21:49:55 <edwardk> jfredett: getContents doesn't force the contents, it lies and claims to give you a pure result that really isn't. it loads as it goes
21:50:02 <jfredett> then hPutStr...
21:50:05 <jfredett> hmm
21:50:11 <jfredett> so how can I force it?
21:50:18 <edwardk> you need to force the whole list before you close it. read its length or something
21:50:26 <jfredett> because I want to write to the file...
21:50:27 <jfredett> okay
21:52:01 <ddarius> Or don't use (h)GetContents
21:52:14 <Heffalump> or readFile
21:52:28 <jfredett> hmm. still no dice...
21:52:30 <Heffalump> that is, don't use readFile either
21:52:30 <ddarius> or lazy IO in general
21:52:39 <pumpkin> Data.ByteString.readFile ?
21:52:44 <jfredett> ddarius: if I can't use readFile or hGetContents, what can I do?
21:53:06 <Heffalump> you can use the operations that come with strict bytestrings
21:53:40 <jfredett> Heffalump: I just want to write some text to the top of a file... that seems like a lot of work for a simple task...
21:54:17 <pumpkin> then just force the read before writing
21:54:18 <jfredett> is there a magic strict version of hGetContents?
21:54:21 <jfredett> I did,
21:54:22 <pumpkin> (and don't forget to seek first)
21:54:29 <Heffalump> you can force the read string, anyway
21:54:32 <jfredett> i added hFileSize myhdl.
21:54:37 <Heffalump> xs <- hGetContents ...
21:54:40 <jfredett> didn't help.
21:54:42 <Cale> jfredett: The default readFile/hGetContents is magic and will read the file lazily.
21:54:45 <Heffalump> length xs `seq` ...
21:54:49 <Cale> hFileSize doesn't cut it :)
21:54:58 <jfredett> Cale: yes, but I need to write to the same file.
21:55:01 <jfredett> ah.
21:55:02 <jfredett> okay.
21:55:16 <jfredett> so what do I have to do... seek till I find an EOF?
21:55:17 <Cale> jfredett: Right. One thing you could do is simply use the Data.ByteString versions.
21:55:19 <edwardk> jfredett: you need to run an honest to goodness length on the list to force it to the end or do something
21:55:20 <Heffalump> just make sure that the seq is on something that will have to happen before you try to write
21:55:28 <pumpkin> jfredett: nope, just rnf the list or something
21:55:34 <Cale> jfredett: Or you can ensure that the length of the String is computed.
21:55:37 <pumpkin> jfredett: then you seek to the beginning of the file, and write
21:55:39 <jfredett> This is _ridiculous_, it should _not_ be this hard...
21:55:52 * Heffalump agrees
21:55:54 <Cale> jfredett: Use the Data.ByteString.Char8 version of readFile
21:55:59 <jfredett> i mean, I'm trying to prepend 5 lines of text.
21:56:04 <jfredett> not launch a missle.
21:56:05 <pumpkin> what if he has fancy encodings in his file?
21:56:14 <jfredett> pumpkin: I don't
21:56:35 <Cale> pumpkin: Then he'd use Data.ByteString with whatever conversion library is needed.
21:56:40 <pumpkin> :)
21:56:43 <jfredett> but I have _no_ desire to use bytestrings. I shouldn't have to. this is _simple_...
21:56:53 <jfredett> or, at least, it would be in _perl_.
21:56:55 <Cale> jfredett: They're not complicated to use.
21:57:01 <Cale> jfredett: and they're strict.
21:57:07 <jfredett> thats not the point.
21:57:10 <Cale> jfredett: So it solves the problem, and is easy.
21:57:16 * jfredett is just frustrated.
21:57:38 <ddarius> jfredett: I don't know why you aren't just using a bit of shell.
21:57:42 <jfredett> it strikes my that when I want to deal with text, I should be dealing with string and vanilla file operations.
21:57:44 <pumpkin> jfredett: then x <- hGetContents h; length x `seq` hSeek AbsoluteSeek 0; hWrite $ "moo\n" ++ x
21:57:54 <jfredett> ddarius: because I (mistakenly) thought it'd be fun to do it in haskell.
21:58:05 <jfredett> IO is a bitch, IOHandles are her pimp.
21:58:21 <Cale> jfredett: It should be simple enough to write a small interact-like abstraction for modifying a file.
21:58:23 <Gracenotes> pumpkin: last x `seq` probably better
21:58:39 <pumpkin> why?
21:58:49 <pumpkin> rnf x `seq` :P
21:58:57 <pumpkin> just to be super sure
21:59:03 <jfredett> rnf? what deep incantation is this?
21:59:15 <Gracenotes> there have been times when length hasn't worked, but last has. This wasn't a lazy string, but still :)
21:59:22 <Cale> It's from Control.Parallel.Strategies
21:59:32 <Gracenotes> rnf is supa-eval
21:59:36 <Cale> It's a handy way to force the evaluation of a value completely.
21:59:37 <Gracenotes> or is that supa-seq.
21:59:49 <ddarius> With bytestrings it would be, main = BS.readFile "foo" >>= writeFile . (stuff ++)
21:59:59 <Gracenotes> and unlike last or length, it evalutes the whole list, not just the spine
22:00:18 <Cale> ddarius: Possibly with an unpack in there :)
22:00:19 <ddarius> Of course, you probably want to do more than a single file, so mapM_ the obvious lambda (and add the missing "foo")
22:00:51 <ddarius> Actually I meant BS.writeFile and there should be some thing that corresponds to (++)
22:01:21 <Cale> interactFile file f = writeFile file . f . unpack =<< BS.readFile file
22:01:25 <Gracenotes> > length (replicate (10^6) undefined)
22:01:26 <lambdabot>   1000000
22:01:42 <Gracenotes> > rnf (replicate (10^6) undefined)
22:01:43 <lambdabot>   Add a type signature
22:01:47 <Gracenotes> :( :( :(
22:02:06 <Gracenotes> > rnf (replicate (10^6) undefined :: [Int])
22:02:07 <lambdabot>   * Exception: Prelude.undefined
22:02:08 <Cale> :t rnf
22:02:09 <lambdabot> forall a. (NFData a) => a -> Done
22:02:19 <ddarius> @src NFData
22:02:19 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:02:31 <Gracenotes> [a] isn't an NFData, but NFData a => [a] is
22:02:42 <ddarius> class NFData a where rnf :: a -> Done -- pretty much
22:02:49 <ddarius> type Done = ()
22:02:51 <Cale> :t forceList
22:02:52 <lambdabot> Not in scope: `forceList'
22:02:57 <Gracenotes> uh huh
22:02:57 <Cale> :t strictList
22:02:58 <lambdabot> Not in scope: `strictList'
22:03:00 <Cale> er...
22:03:08 <Cale> what was it called again...
22:03:23 * Cale goes to the documentation :)
22:03:30 <jfredett> ... There should be a function in the System.IO library called, "actuallyReadTheFrakkingFile" which, when run, forces the file to be read like a good little thing, and removes all this silly cognitive load from the should-be-simple task of reading a file.
22:03:40 <jfredett> I cannot believe it is this hard... :/
22:03:40 <Cale> ah, seqList
22:03:57 <Heffalump> jfredett: agreed
22:03:59 <Gracenotes> @type seqList --must needs type
22:04:00 <lambdabot> forall a. Strategy a -> [a] -> Done
22:04:15 <Heffalump> but length xs `seq` ... isn't *that* hard and should work fine
22:04:24 <Cale> jfredett: Yes, there ought to be a readFile', but it's not like importing Data.ByteString and using BS.readFile is all that much harder either.
22:04:26 <ddarius> If it wasn't for lazy IO, that's all readFile could do.
22:04:40 <Heffalump> importing bytestring is an extra unnnecessary dependency
22:04:41 <jfredett> Cale: for a newbie it would be.
22:04:52 <Cale> Heffalump: Which everyone has...
22:04:53 <jfredett> ByteString is scary, String is not.
22:05:02 <Cale> It's not *that* scary.
22:05:09 <jfredett> to _you_
22:05:11 <Cale> The interface is pretty much the same one as lists.
22:05:12 <jfredett> but you're Cale.
22:05:19 <Cale> Try it!
22:05:20 <Cale> hehe
22:05:29 <jfredett> Cale: I will, because I know it's not scary.
22:05:30 <Heffalump> Cale: it's not in ghc
22:05:35 <Heffalump> it was for one release or something
22:05:36 <Cale> Heffalump: it's not?
22:05:38 <Cale> ...
22:05:39 <jfredett> but- to someone who's never messed with Haskell before,
22:05:39 <Cale> ah
22:05:48 <jfredett> thats the thing that makes them go, "IO is hard in Haskell"
22:05:56 <Heffalump> at least, that's what I think the situation is
22:06:03 <ddarius> jfredett: Um, no, it isn't.  Not for most at least.
22:06:07 <Cale> jfredett: another solution is just to write to a different file than you're reading from.
22:06:10 <jfredett> "You have to mess around with these bytestring things"
22:06:17 * Heffalump agrees with jfredett
22:06:37 <jfredett> Cale: The entire _goal_ is to write to the file, I'm trying to have it automatically add the License Info Blurb to the top of the thing.
22:06:49 <Cale> okay
22:06:57 * Heffalump wonders about a strictly :: NFData a => IO a -> IO a
22:06:57 <jfredett> I _could_ frak down on the commandline after writing via system commands, but that misses the point, methinks.
22:07:00 <jfredett> :(
22:07:00 <Cale> interactFile file f = writeFile file . f . unpack =<< BS.readFile file -- did you catch this function?
22:07:14 <Heffalump> jfredett: just use length xs `seq` ...
22:07:16 <Cale> It will be handy :)
22:07:16 <jfredett> yes- but again, that misses the point.
22:07:18 <Heffalump> it's quite simple and will work fine.
22:07:25 <jfredett> Heffalump: okay
22:07:33 <Cale> jfredett: The point is that function ought to be in the libraries, but isn't.
22:07:40 <Heffalump> and solves your immediate problem, and saves us an endless argument where neither side agrees with the other :-)
22:07:47 <jfredett> Heffalump: bingo.
22:08:19 <Cale> I don't actually care for the compute-the-length solution all that much.
22:08:27 <jfredett> Heffalump: do I need to put something where the "..." is?
22:08:29 <ddarius> It's an ugly hack.
22:08:32 <Heffalump> jfredett: yes
22:08:40 <ddarius> But it does work and is the simplest thing to do given the current readFile.
22:08:47 <Cale> jfredett: Presumably the writeFile.
22:08:47 <Heffalump> you need to put it before something that will be required before you write the file
22:08:52 <jfredett> so is Cale's, it's all ugly, because it _shouldn't be this way in the firstplace!_
22:08:55 <Heffalump> someone gave an example above of putting it before the seq
22:09:01 <Heffalump> s/seq/hSeekFile/
22:09:07 <Cale> jfredett: I don't think mine is ugly.
22:09:44 <Cale> interactFile filename (headerLines ++)
22:09:50 <jfredett> Cale: it's a good solution to a problem that shouldn't exist. doesn't matter if it's ugly, there should be no need for it.
22:09:58 <Heffalump> Cale: that's fine, but your solution is not in the library
22:10:00 <jfredett> I'm not trying to be an ass.
22:10:02 <Heffalump> and neither is mine (strictly)
22:10:03 <Cale> Or perhaps you'd prefer the opposite parameter convention to interactFile
22:10:05 <ddarius> jfredett: It's not a "solution to a problem" it's a basic abstraction.
22:10:25 <jfredett> ddarius: Not being able to simply read a file and write back to is a problem.
22:10:34 <ddarius> jfredett: That's all the function does.
22:10:38 <jfredett> having to invoke anything besides the prelude to do that
22:10:50 <jfredett> is unbelievable wrong in the sense of a mortal sin.
22:10:52 <ddarius> jfredett: Cale is saying a function like that should be in the Prelude.
22:10:53 <Heffalump> I don't like interactFile btw, because it's inefficient if you are appending to the file
22:11:02 <Cale> It's probably best for it to take the filename last, since you're more likely to want to do the same thing to a bunch of different files than different things to one file.
22:11:16 <jfredett> ddarius: then evidently we agree. I dunno, I'm just frustrative, like I said.
22:11:17 <ddarius> (Well, not the necessarily -Prelude- per se.)
22:12:28 <Cale> Perhaps System.IO
22:12:29 <ddarius> jfredett: Be frustrated, but actually read what people are saying to you.
22:13:04 <jfredett> ddarius: I am, but text flies so fast for my ailing vision...
22:13:05 <Cale> There are lots of good solutions to the problem you're having, which once you know them, make this seem like much less of a big deal.
22:13:22 <Cale> But it is annoying, and there should be a ready made solution in the libraries.
22:13:29 <ddarius> jfredett: You have some disease you've never mentioned?
22:13:38 <jfredett> ddarius: no, I just can't see for shit.
22:15:28 <jsn> i don't think that stuff should be in the prelude, actually
22:15:36 <Cale> Which stuff?
22:16:00 <jsn> filesystem stuff
22:16:00 <Cale> I/O stuff?
22:16:02 <Cale> yeah
22:16:33 * ddarius doesn't particularly care too much what is and isn't in the Prelude.
22:16:44 <Cale> Well, you want to balance useful stuff that can be done with no imports against modularity.
22:16:51 <jsn> aye
22:17:50 <jsn> i would rather like it if there were a JavaScript Haskell target -- then you wouldn't import the file stuff, you'd import DOM stuff
22:18:16 <Cale> Oh, there's someone who had that partly working.
22:18:25 <jsn> yeah, with yhc
22:18:28 <Cale> yeah
22:19:13 <jsn> i've had to write a lot of JS in the past couple of weeks. probably 90% of my logic is UI right now. how i wish i had currying, types, &c.
22:20:46 <jsn> however, it would be nice if there were a "Scripting" module that imported, for example, filesystem interfaces, regular expressions with quasi-quoters, networking stuff and all the other junk you expect to have at your fingertips when coding with Bourne shell or Perl
22:20:59 <BMeph> jsn: Have you tried the functional bundle? :)
22:21:14 <jsn> All that stuff should be in one place -- just not the Prelude
22:21:22 <jsn> BMeph: the functional bundle?
22:22:07 <jsn> BMeph: for javascript?
22:22:23 <BMeph> jsn: Aye - http://osteele.com/archives/2007/07/functional-javascript
22:23:26 <Gracenotes> Javascript, function, 'magine that :3
22:23:42 <jsn> wow, that is great
22:24:08 * ddarius has used currying extensively in Javascript
22:25:06 <Gracenotes> I've had to implement foldl/foldr a couple times in JS
22:25:28 * ddarius has used monads in Javascript
22:25:31 <Gracenotes> not so much a fan of explicit currying :/
22:25:41 <Gracenotes> plain ol' function composition, though, of course
22:25:43 <Gracenotes> ddarius: Maybe?
22:26:49 <ddarius> Gracenotes: No, a parser monad and a logic programming monad.
22:27:16 <Gracenotes> oh, neat. Logic programming via monads, you say? Must look into this.
22:27:37 <Gracenotes> anything like the [] monad (nondet.)?
22:28:11 <ddarius> Very roughly, but no.  It supported non-determinism, but it didn't use lists.
22:28:18 <ddarius> (Which would fail miserably in JS)
22:29:22 <Gracenotes> what sort of logic programming could it use?
22:29:22 <ddarius> I decided to cheat a little from otherwise purely functional code to add a name generator which seemed innocuous enough and boy I paid for it.
22:29:38 <jsn> oh?
22:29:51 <ddarius> Gracenotes: It was an implementation of Prolog.
22:29:59 <ddarius> (Well, the core of Prolog.)
22:30:07 <Gracenotes> oh, I see.
22:31:25 <Gracenotes> mm, I am a bit curious about implementations of logic programming (moreso those that aren't horribly inefficient)
22:31:45 * Gracenotes googles about
22:31:50 <wli> Gracenotes: http://www.cs.mu.oz.au/
22:31:58 <wli> Gracenotes: http://www.cs.mu.oz.au/research/mercury/ even
22:32:13 <ddarius> This one, other than being written in Javascript, should be acceptable, for a non-serious interpreter.
22:33:23 <Gracenotes> wli: neat.. what's the implementation language?
22:33:43 <wli> Gracenotes: I think they are self-hosting.
22:33:55 <wli> Gracenotes: More than the average amount of C.
22:34:18 <Gracenotes> ah. so says wiki
22:40:45 <Gracenotes> okay, so is it a good idea to prowl through the Mercury source?
22:41:16 <Gracenotes> or is it just a nice language to use? Implementation, not just YAPC-c-c-lone :)
22:42:10 <wli> Gracenotes: The papers are probably more enlightening.
22:43:19 <Gracenotes> *looks*
22:43:39 <Gracenotes> holy.. large amount of papers, batman
22:50:31 <redditbot> Installing GHC, Gtk2HS & Cabal on Ubuntu 8.04
22:56:45 <score> is there a way to see what projects on hackage depend on a package?
23:00:58 <score> i guess downloading the index and grepping works.
23:05:53 <travisbrady> anyone know of the Haskell equivalent of the following python "import md; print md5.new('blahblah').hexdigest(); 42d388f8b1db997faaf7dab487f11290"?
23:06:02 <travisbrady> import md5 rather
23:06:26 <trygvis> did you check out hackage.haskell.org?
23:06:32 <Olathe> @hoogle md5
23:06:32 <lambdabot> package nano-md5
23:06:32 <lambdabot> package pureMD5
23:08:45 <travisbrady> i peaked at those but was hoping there was something in the stdlib
23:11:38 <jsn> travisbrady: do you have cabal?
23:11:50 <travisbrady> jsn: i do yes
23:11:56 <travisbrady> cabal install is great
23:12:01 <jsn> travisbrady: ah, ok
23:12:18 <jsn> travisbrady: just wanted to make sure you weren't held back by painful installation :)
23:42:07 <stanv_> please help: http://paste.org.ru/?l8wxz7
23:43:20 <hackage> Uploaded to hackage: blogination 0.5
23:43:51 <Gracenotes> it appears you're using an Exception as a type, when it is a typeclass. SomeException exists to be used as a type.
23:44:12 <Gracenotes> or just use typeclass quantification
23:44:16 <Gracenotes> qualification? qualification.
23:44:56 <stanv_> Gracenotes: http://paste.org.ru/?ob0w1g
23:45:35 <Gracenotes> (_ :: Exception)
23:46:07 <stanv_> Gracenotes: how to fix ?
23:46:12 <Gracenotes> which also requires a GHC extension allowing type-matching with pattern-matching
23:46:41 <Gracenotes> stanv_: why is it so important that it's an Exception if you don't care what the value is?
23:47:30 <thoughtpolice> you don't need scoped type variables if that's what you mean
23:47:48 <thoughtpolice> you can bind a local function with an explicit type, avoiding the need for ScopedTypeVariables
23:48:16 <Gracenotes> you can, but that also requires you to specify the return value
23:48:21 <thoughtpolice> afaik, none of the extensions that are used in the new exception library are required except existential quantification
23:48:21 <Gracenotes> type.
23:48:46 <stanv_> :( it is not my program... i'm trying to compile foriegn program
23:48:54 <thoughtpolice> it doesn't really matter to me
23:48:55 <stanv_> how to fix this?
23:49:07 <Gracenotes> stanv_: ah. Do you know much Haskell?
23:49:11 <thoughtpolice> i'm just saying you don't have to use the extension, it's just as easy to give an explicit type and avoid it
23:49:24 <Gracenotes> in this case replacing (_ :: Exception) with _ will do the trick
23:50:16 <thoughtpolice> what GHC are you using?
23:50:17 <Gracenotes> the type signature of handle is :: Exception e => (e -> IO a) -> IO a -> IO a, so it's assumed that the expression there will take an e that's an Expression. (typeclass, not quite a type)
23:50:19 <thoughtpolice> i take it 6.10?
23:50:58 <stanv_> another fail:  http://paste.org.ru/?tki5cg
23:51:25 <stanv_> but same  meaning
23:51:51 <stanv_> $ rpm -q ghc
23:51:51 <stanv_> ghc-6.10.1-alt1
23:52:01 <Gracenotes> this guy really wanted Exception to be a type, huh
23:52:41 <thoughtpolice> the code has likely not been upgraded to deal with the exception mechanism changes between ghc 6.8 and ghc 6.10
23:53:03 <Gracenotes> thoughtpolice: oh, it was different? My fault for showing up late to the party, then.
23:53:22 <thoughtpolice> Gracenotes: yes, the exceptions stuff in Control.Exception in ghc 6.10 is brand new
23:53:39 <Gracenotes> aww, shucks.
23:53:47 <thoughtpolice> lots of stuff has broken because of that one change (probably more than anything else, with lookup's type changing coming in at second..)
23:53:57 <BMeph> Changing Exception (the module) to OldException should do it?
23:54:14 <Gracenotes> In that case, generally replacing (\(blah :: Exception) -> blah2) with (\blah -> blah2) should be fine, among other possible changes .-.
23:54:32 <thoughtpolice> Gracenotes: this was the exceptions library - http://haskell.org/ghc/docs/6.8.3/html/libraries/base/Control-Exception.html
23:55:19 <thoughtpolice> i'd rather just have code use the new exceptions library
23:55:29 <thoughtpolice> if you need ghc 6.8 compatibility, then there's extensible-exceptions on hackage
23:55:40 <thoughtpolice> if you don't use cabal-install, well, i feel sorry for you i suppose.
23:55:41 <stanv_> :( is any exit from this situation for
23:55:42 <Gracenotes> oh dear :x
23:55:45 <stanv_> me?
23:56:22 <Gracenotes> oh dear. That looks like it's begging for a typeclass.
23:56:33 <thoughtpolice> stanv_: yes, you should be able to do what BMeph said and change the line 'import Control.Exception...' to 'import Control.OldException'
23:57:16 <Gracenotes> sounds simpler -.-
23:57:24 <stanv_> then i get: http://paste.org.ru/?ivsmvl
