00:00:08 <ivanm> harblcat: sharp?
00:00:12 * ivanm is a muso
00:00:23 <ivanm> or at least an ex-muso :s
00:00:27 <pumpkin_> same here :)
00:00:33 <pumpkin_> well, I still play when I can, but it isn't often :(
00:00:45 <harblcat> Hmm, how about in the context of #haskell?
00:00:50 <ivanm> though IIRC, it's also been pronounced as "pound" in the case of one dailyWTF interview ;-)
00:00:59 <harblcat> sharp-haskell doesn't sound cool.
00:00:59 <pumpkin_> pound, hash, sharp
00:01:02 <Gracenotes> pound, hash, sharp
00:01:06 <Gracenotes> oh, what the hell
00:01:07 <pumpkin_> lol
00:01:12 <ivanm> harblcat: the haskell IRC channel ;-)
00:01:13 <pumpkin_> Gracenotes: get out of my head!!
00:01:14 <Gracenotes> ...
00:01:26 * Gracenotes politely exits
00:01:27 * ivanm passes pumpkin_ some aluminium foil to make a hat
00:01:41 * pumpkin_ shapes it into a foil bowler hat
00:01:51 <ivanm> pumpkin_: with the brim?
00:02:06 <pumpkin_> have you ever seen a carved pumpkin (don't ask, it's painful memories) with a tin foil bowler hat?
00:02:15 <pumpkin_> yeah
00:02:32 <ivanm> so now you just need to paint it black, get yourself a vested suit, a largeish belly and you too can be a stereotypical british banker! ;-)
00:02:41 <pumpkin_> lol
00:02:51 <ivanm> pumpkin_: since I don't like in either of the americas, no
00:03:01 <harblcat> ivanm, I take offense to that..
00:03:11 <ivanm> harblcat: which bit?
00:03:16 <pumpkin_> I take offense to you taking offense to that!
00:03:32 <harblcat> I take offense to British bankers. :)
00:03:35 <Gracenotes> ivanm: also fitting that description is the 19th century American monopolist
00:03:36 <pumpkin_> this feels like -blah material btw
00:03:39 <ivanm> harblcat: heh
00:03:40 <harblcat> With a large stick.
00:03:47 <ivanm> you know, Mary Poppins, etc. ;-)
00:04:02 <ivanm> Gracenotes: where do you think they got it from? :p
00:04:12 <ivanm> @quote on-topic
00:04:12 <lambdabot> No quotes match. You type like i drive.
00:04:17 <ivanm> @quote ontopic
00:04:17 <lambdabot> No quotes match.
00:04:22 <ivanm> @quote topic
00:04:22 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
00:05:47 <shapr> varbls
00:05:58 <pumpkin_> harblvarbl?
00:06:13 * ivanm prefers variables
00:06:14 <pumpkin_> the haskell mentality :)
00:07:03 <Gracenotes> varnishing the varbl
00:07:12 <Gracenotes> a euphemism for.. jeez, I don't want to know
00:07:17 <pumpkin_> lol
00:07:46 <harblcat> I'll have you know that I thought 'harbl' was a completely made-up word when I made this nick ;)
00:08:03 <ivanm> @wn harbl
00:08:03 <lambdabot> No match for "harbl".
00:08:12 <ivanm> still is, according to wordnet...
00:08:13 <pumpkin_> I'm not sure whether to pronounce it like harbul, or a slurred horrible
00:08:23 <mriou_> does someone know if OverlappingInstances is incompatible with other pragmas?
00:08:26 * ivanm thinks like harb-el
00:08:36 <harblcat> I pronounce it like 'marble'
00:08:36 <ivanm> mriou_: shouldn't be AFAIK
00:09:09 <mriou_> mmh ok, after setting it ghc still barfs "overlapping instances"
00:09:45 <Gracenotes> undecidable?
00:10:17 <ivanm> shapr: do you actually do anything apart from uttering cryptic messages every now and again? :p
00:10:18 <Gracenotes> actually, bad idea, never mind. mriou_: how did you set it?
00:10:42 <mriou_> {-# LANGUAGE OverlappingInstances #-} all the way up in the file :)
00:11:10 <ivanm> mriou_: how bout you paste up a minimal example and the error message?
00:11:17 <mriou_> sure
00:12:02 <Taejo> :t map . map
00:12:03 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
00:12:18 <Taejo> :t fmap fmap fmap
00:12:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
00:14:06 <mriou_> here we go: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1509#a1509
00:14:24 <mriou_> if you see an unsafePerformIO there, I'll deny it :)
00:15:27 <mriou_> mmh I removed too much, the module definition isn't correct, you can remove it if you want to actually try the code
00:15:32 <ivanm> mriou_: what bit does it actually complain about?
00:15:35 <mriou_> the pb is with Eq (IORef WyType)
00:15:39 <pumpkin_> instance Eq (IORef WyType) where
00:15:59 <mriou_> yes, last instance definition
00:16:09 <ivanm> ahhh, error is at the top
00:16:21 <ivanm> mriou_: have you tried putting all pragmas in the same bracket?
00:16:41 <mriou_> comma separated?
00:16:45 <ivanm> {-# LANGUAGE OverlappingInstances, GeneralizedNewtypeDeriving, ... #-}
00:16:47 <ivanm> yup
00:17:26 <mriou_> mmh same
00:18:07 <ivanm> *shrug* dunno then, don't have much to do with overlapping instances :s
00:18:36 <pumpkin_> http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
00:19:30 <pumpkin_> kinda ugly though :)
00:19:37 <mriou_> thanks, I'll have a look see if that helps
00:22:34 <pumpkin_> time for bed :) night
00:22:46 <mriou_> me too, night :)
00:29:23 <Trinithis> <3 filterM
00:34:53 <wli> http://pastebin.com/mffcb0c6 <-- slightly better upper triangularization
00:47:50 <rohan> i defined a simple function "add a b = a + b"; when i do :type add in ghci,i get "add :: (Num a) => a -> a -> a". can someone please explain me that?
00:50:10 <jml> rohan: sure.
00:50:48 <jml> rohan: It means, roughly speaking that 'add' is a function that takes to arguments of the same type, and returns a new value of the same type.
00:51:04 <jml> rohan: and that this type can be anything, so long as it is of the 'Num' typeclass
00:52:13 <jml> rohan: the book "Real World Haskell" explains this very well, and is available online.
00:52:29 <rohan> jml: i'm reading that, am on chapter two which defines the add function.
00:52:36 <rohan> i was confused by the "a -> a -> a"
00:52:55 <rohan> thanks jml , now it makes sense
00:53:08 <jml> yeah, so 'a' (or any lowercase name) means "any type", roughly speaking
00:53:22 <jml> rohan: look at ':type map'
00:53:53 * jml has to go now.
00:54:05 <rohan> will do, ty
00:57:01 <Taejo> if GHC tells me "Note_" is not in scope, surely "import Text.XML.MusicXML.Note (Note_)" at the top of the module should have given an error too?
00:57:50 <Taejo> nevermind
01:43:00 <hackage> Uploaded to hackage: xhb 0.2.2009.2.21
01:43:00 <hackage> Uploaded to hackage: xcb-types 0.5.0
01:47:35 <dolio> @seen dons
01:47:35 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1h 34m 43s ago.
01:49:22 <redditbot> The Typeclassopedia
01:56:32 <bos> even dons sleeps sometimes
01:57:05 <ivanm> bos: :o
01:57:18 <ivanm> I thought he lived here!
01:57:20 <ivanm> ;-)
02:05:00 <paolino> @src sequence
02:05:00 <lambdabot> sequence []     = return []
02:05:00 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:05:00 <lambdabot> --OR
02:05:00 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:05:19 <paolino> :t sequence
02:05:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:06:06 <paolino> ﻿:t foldr (flip (>>=))
02:06:59 <paolino> :t foldr (flip (>>=))
02:07:00 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
02:07:07 <cnwdup> Which instances do I have to provide to make use of GeneralizedNewtypeDeriving for custom Monad Transformers?
02:07:43 <paolino> mhh , I thought they were the same is therea name for ﻿foldr (flip (>>=))
02:07:45 <paolino> ?
02:10:46 <ivanm> @pl folder (flip (>>=))
02:10:46 <lambdabot> folder (=<<)
02:38:32 <eu-prleu-peupeu> hello there
02:38:50 <eu-prleu-peupeu> what options do i have in haskell if i want to open a window with opengl context ?
02:46:11 <stianhj> eu-prleu-peupeu: http://www.haskell.org/haskellwiki/Opengl
03:33:02 <Axman6> quiet night...
03:33:14 * Axman6 makes some noise
03:33:24 <dolio> @yow!
03:33:24 <lambdabot> Send your questions to ``ASK ZIPPY'', Box 40474, San Francisco, CA
03:33:24 <lambdabot> 94140, USA
03:33:37 <Axman6> So, i released version 0.0.4 of my AVar package tonight. first big change since i first made it
03:34:01 <stianhj> what does your AVar package do?
03:34:10 <dolio> I can see why you increased the bugfix number, then.
03:34:37 <Axman6> yeah, i just realised i should have made it 0.1.0 :\
03:34:42 <dolio> :)
03:35:54 <Axman6> stianhj: it's a form of semi transactional variable, that carries the state arounf in a forkIO'd process. It also sort of protects itself, handling exceptions in the function, and passing them back to the user where necessary
03:36:15 <Axman6> haven't thought of any really good uses for it, but i'm hoping someone'll find it useful
03:37:10 <dolio> Useless benchmarks seem to be en vogue these days.
03:37:20 <dolio> c.l.functional has some mandelbrot benchmark going.
03:37:30 <Axman6> the ghc vs gcc thread?
03:37:36 <dolio> That too.
03:37:44 <Axman6> what else?
03:37:55 <dolio> The mandelbrot benchmark I just mentioned.
03:38:11 <dolio> With Dr. Jon Harrop being heavily involved.
03:38:17 <Axman6> oh, missed that
03:38:18 <dolio> And illustrating just how bad haskell is.
03:38:26 <Axman6> heh
03:38:34 <Axman6> got a link?
03:38:39 <dolio> By refusing to install libraries that would allow him to run the fastest haskell example.
03:39:18 <Axman6> hey blackh
03:39:21 <stianhj> Axman6; ah, AVar as in MVar..
03:39:28 <blackh> Hi there Axman6, sir!
03:39:38 <dolio> Man, google groups is uglier than I remember.
03:39:41 <Axman6> stianhj: yeah, sort of (it uses MVars heavily)
03:40:08 <dolio> http://groups.google.com:80/group/comp.lang.functional/browse_thread/thread/c13f4fa8b26af265#
03:40:19 <stianhj> Axman6: but why not STM?
03:40:41 <Axman6> stianhj: this thing is safe enough
03:40:59 <Axman6> ensures that actiona will happen one at a time
03:41:18 <stianhj> i see
03:42:55 <Axman6> the only thing i've been able to see that it's useful for is resource accounting, but that can be done with STM anyway
03:43:15 <Axman6> it's possible my thing is faster than stm though
03:43:32 <Axman6> but not as useful in many ways...
03:43:50 <stianhj> faster would be nice though..
03:46:25 <Axman6> doesn't do the same stuff though. might be possible to have actiona that use two variables, but more than that gets difficult (i can see a way to use another MVar that communicates between two variables, but i'm not sure how it'd be used)
03:48:55 <RayNbow> @seen dons
03:48:55 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 3h 36m 3s ago.
03:56:20 <C-Otto> hi there
03:56:28 <C-Otto> could you give me a wiki account on haskell.org please?
03:56:38 <C-Otto> i'd like to enrich the wisdom of the xmonad community
03:59:36 <LostMonarch> let`s return humble
04:00:16 <pejo> dolio, I don't think people should dismiss microbenchmarks though, just use them sensibly.
04:12:44 <Axman6> pejo: agreed, i think that thread brought up some good points
04:19:59 <dolio> pejo: I don't have a problem with microbenchmarks, either. But some people take them to mean more than they do.
04:21:15 <dolio> The one on haskell-cafe shows that loop unrolling would be handy.
04:21:32 <dolio> But for that benchmark, the more you unroll, the better, which isn't really true in general.
04:21:34 <Axman6> hooray, result
04:21:41 <Axman6> now let's keep arguing!
04:22:06 <blackh> They never got that Haskell program running fast. Looks like a challenge. :)
04:22:23 <dolio> Which?
04:22:35 <blackh> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/c13f4fa8b26af265#
04:22:44 <Axman6> blackh: the sum one?
04:22:46 <blackh> At the bottom they're saying it's 63x slow than ocaml
04:22:53 <Axman6> they got it faster than the C :)
04:23:08 <dolio> Yeah, well, that's Harrop saying that.
04:24:00 <dolio> I wouldn't just accept what he says without running the benchmark yourself.
04:24:05 <blackh> Ah, I think that name was mentioned here before. What's the Harrop story in a nutshell?
04:24:44 <opqdonut> well he's an ocaml dev
04:24:47 <opqdonut> or rather the
04:24:49 <Botje> *yawn*
04:24:58 <Botje> it's like i never went to sleep! :p
04:25:08 <bartek> welcome to my world
04:25:14 <dolio> Not anymore. He's promoting F# now.
04:26:28 <pejo> blackh, Harrop is not officially affilated with Ocaml in any way that I know of.
04:26:47 <opqdonut> dolio: ah
04:26:54 <dolio> Anyhow, he once wrote a book on OCaml, and spend most of his time (to all external appearances) promoting it on comp.lang.lisp, and arguing with people there, telling them why lisp sucks.
04:27:53 <dolio> He lurked on one of the haskell mailing lists a bit, and posted a few times, until he came to the conclusion that it's terrible, I guess.
04:28:09 <Axman6> heh
04:28:10 <dolio> Lately he wrote a book on F# similar to his OCaml one, so now he promotes that instead.
04:29:41 <Raynes> F# is a messy excuse for a language. :|
04:30:44 <blackh> I have not spent any actual time on O'Caml, but there are some things that are unique to Haskell that I couldn't live without.
04:30:50 <pejo> I think F# is great.
04:31:24 <blackh> One of them is the fact that Haskell models I/O in a functional way.
04:31:57 <pejo> blackh, O'Caml might not have the features, but there are other languages that have many of Haskell's features.
04:31:57 <titusg> where's the pastebin?
04:32:17 <Axman6> @where hpaste
04:32:17 <lambdabot> http://hpaste.org/
04:32:19 <blackh> pejo: What do you like about F#?
04:32:20 <Axman6> ^^
04:32:28 <titusg> Axman6: thx
04:33:15 <jpcooper> blackh, is it really functional?
04:33:17 <pejo> blackh, it's paving the way for functional programming in the mainstream. I think it's only a matter of time before we see "normal" programmers use type classes.
04:33:25 <jpcooper> I don't understand how it is actually purely functional
04:33:53 <blackh> pejo: I came to Haskell thinking I would not become dogmatic, and would take everything on its merits. Then I wrote 17,000 of Haskell and now I have an *investment* in it, so being unbiased is harder than it was!
04:34:09 <jpcooper> I've in fact been thinking of learning F# to do some freelance .Net projects
04:35:09 <titusg> Why doesn't this program use more than 100% cpu? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1598#a1598
04:35:17 <pejo> blackh, and with that investment you've also come to learn some of the warts and problems with the language. (Not necessarily saying that there are languages out there that solves your problems better).
04:35:18 <jpcooper> blackh, I'm not criticising Haskell, or anything. I just don't understand how IO, even in a monad, is functional
04:36:06 <titusg> taken from a reddit post of dons'
04:36:07 <blackh> pejo: I agree. There are some things in Haskell that are not perfect, e.g. NFData as a method of enforcing strictness.
04:36:25 <blackh> pejo: But there are so many things that make up for the deficiencies.
04:36:28 <pejo> blackh, 'NFData'?
04:36:33 <Olathe> Does Template Haskell allow you to take a standard Haskell source file, see something like the parse tree of it, and optimize it ?
04:37:17 <blackh> jpcooper: I'm sure you're right, but I think the IO monad is a good model that allows IO bound code to be separated from IO without too much re-factoring.
04:37:25 <jpcooper> right
04:37:42 <blackh> titusg: I have a theory about this - and it's only a theory mind... I'll just look over your code again. One moment.
04:39:01 <Axman6> jpcooper: it's functional, becayse each IO action in a sense gets passed the real world as a parameter, since that's always changing, and never the same, then you can say it's referencially transparent :) (i'm probably horribly wrong here...)
04:39:17 <Raynes> pejo: An inelegant mess really, but this is #haskell, so I'm going to stop there before we get into a conversation :\
04:39:29 <titusg> I wondered if I need to tell ghc I have 2 cores when configuring?
04:39:30 <jpcooper> okay
04:39:43 <opqdonut> jpcooper: descriptions of (even mutually dependent) io actions are pure
04:39:51 <blackh> titusg: My theory is that that the memory allocator that Haskell uses has bad lock contention, and that this causes parallel code to use less than 100% CPU.
04:39:55 <opqdonut> they could bejust trees or something
04:40:04 <opqdonut> _running_ the described actions is inpure
04:40:18 <opqdonut> but that's what the RTS does
04:40:41 <titusg> blackh: dons' posted his output and cpu was > 100%
04:40:44 <blackh> pejo: NFData is a typeclass in Control.Parallel.Strategies
04:40:57 <blackh> titusg: How many CPU cores have you got?
04:41:00 <pejo> titusg, I think you need to tell the RTS to use more cores when you start the program.
04:41:05 <titusg> 2
04:41:09 <jpcooper> opqdonut, RTS?
04:41:19 <Axman6> @src IO
04:41:19 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
04:41:20 <titusg> pejo: I ran with +RTS -N2
04:41:23 <blackh> titusg: I think this code probably isn't allocating memory, though - but it could be allocating extra stack space.
04:41:31 <blackh> titusg: Are you using +RTS -N2 ?
04:41:37 <opqdonut> jpcooper: run time system
04:41:45 <blackh> titusg: Oh, you are.
04:41:47 <jpcooper> okay
04:42:05 <Axman6> jpcooper: that definition says that IO is a function, that is very similar to State (as you can see). the thing is, i think RealWorld gets treated as it's something changing all the time
04:42:15 <pejo> blackh, oh. Yes, laziness is tricky. It's one of many things that I don't understand.
04:42:47 <jpcooper> okay
04:42:54 <blackh> titusg: You're getting close to 100% but not quite.
04:42:57 <Axman6> jpcooper: make sense?
04:43:11 <jpcooper> yes
04:43:21 <jpcooper> thank you
04:43:22 <blackh> pejo: I have pretty much got my head around it now, but it's quite subtle and not very well documented.
04:44:08 <Axman6> jpcooper: another thing to note is that's just how GHC defines IO, it may well be (and i think usually is) different in different compilers. which is ok, as long as they act the same
04:44:21 <blackh> titusg: I've found that allocation heavy code struggles to get over 1 CPU, and this is what I'm basing my theory on.
04:44:43 <maltem> Conal's new paper draft is awesome, but he lost me on "hyperstrict"
04:44:49 <blackh> titusg: I believe it could be fixed fairly easily and I'm sure someone will fix it - but I do have that sort of spare time.
04:45:12 <pejo> blackh, I think the next version of GHC will have a bunch of improvements for that kind of code.
04:45:17 <titusg> blackh: is there an example somewhere that I could run that would be likely to use >100%
04:45:22 <titusg> ?
04:45:27 <Axman6> maltem: sitting in a register? :\
04:45:40 <dolio> titusg: The programming languages shootout has some multi-core benchmarks.
04:45:51 <dolio> Some of which actually use multiple cpus for the haskell examples. :)
04:46:13 <blackh> titusg: Doesn't 1.506 real, 2.272 user mean that it was > 100%?
04:46:38 <titusg> blackh: I dunno, does it?
04:46:43 <Axman6> think so
04:47:00 <Axman6> well, it used two or more cores at least
04:47:05 <blackh> titusg: Try it without -N2 and user and real should be about the same
04:47:34 <titusg> yes, I get 2.356 real,2.324 user,0.008 sys, 98.99 cpu
04:47:52 <dolio> Man, these all use Concurrent not Parallel...
04:48:38 <blackh> titusg: Then you're actually getting close to 200%, but not quite.
04:49:22 <titusg> blackh: can I get time to print that?
04:50:08 <blackh> titusg: I don't know. I've been using a number of ways that are less than perfect.
04:51:51 <blackh> dolio: regex-dna uses par. I've submitted a new version of that but it isn't live yet.
04:52:37 <blackh> dolio: I have an unsubmitted change to binary-trees that makes it parallel:  let vs = parMap rnf id $ depth minN maxN     <-- "parMap rnf id $" is the bit I added
04:53:12 <dolio> Yeah, but it's listed as "Make Error" so there's no 3rd party confirmation that it actually uses more than 100% cpu.
04:53:49 <blackh> dolio: I gave them instructions on how to install Regex.PCRE so maybe it's sitting in the "too hard basket".
04:54:03 <Axman6> dolio: was it you who was commenting on  this jon harrop guy earlier?
04:54:16 <dolio> I was, yeah.
04:54:27 <Axman6> what dick he is: "But Cabal itself is not available as a Debian package, so I have to install "
04:54:31 <Axman6> Haskell's own proprietary package manager by hand:
04:54:38 <dolio> pidigits has no attempt to be parallel either, it seems.
04:55:03 <Axman6> dolio: it's ot a benchmark that paralelises well, since each iteration relies on the previous one
04:55:24 <dolio> Kind of odd for it to be part of the parallel shootout, then.
04:55:24 <Axman6> thoug... it might be possible, if you used chans, and forkIO'd the producer
04:55:27 <blackh> dolio: The build error is due to the regex package not being installed on their machine
04:56:15 <blackh> Axman6: Haskell is not proprietary, it is open source.  There *is* a slight difference. :)
04:56:25 <Axman6> blackh: i know :)
04:56:36 <blackh> Axman6: F# on the other hand... !!
04:56:41 <Axman6> heh
04:57:01 <Axman6> blackh: what do you think of my idea for speeding up the pidigits benchmark?
04:57:16 <blackh> Axman6: Tell me your idea!
04:57:20 <Axman6> i need to try this.
04:58:12 <Axman6> it's pretty simple, forkIO the digits producer, and have it stick the results in a Chan, and have another thread (forkIO'd too, because bound to non bound thread stuff is not nice) consume the contents and print them
04:59:01 <bremner> Axman6: IIRC, cabal-install is not packaged (or maybe not packaged) for Debian. Apparently runhaskell Setup.hs is too stressful :-) To be honest, I have never used cabal-install, so I don't know what I am missing
04:59:15 <blackh> Axman6: It is worth trying. The potential problem is that it might introduce more overhead than it saves, but you won't know until you try.
04:59:24 <dolio> Axman6: He's quite a character.
04:59:24 <Axman6> yep :)
04:59:38 <Axman6> dolio: that's one way of putting it
04:59:40 <bremner> s/is not packaged/is not installed by default/
04:59:42 <dolio> @quote JonHarrop
04:59:42 <lambdabot> JonHarrop says: As the Lispers always say, it is theoretically possible to do a good job but...
04:59:46 <dolio> @quote JonHarrop
04:59:46 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
04:59:50 <blackh> bremner: cabal-install is *wonderful*!!
05:00:09 <blackh> Axman6: I think pidigits is pretty well optimized by the compiler.
05:00:11 <bremner> blackh: what does it buy over runhaskell Setup.hs
05:00:48 <Axman6> bremner: cabal install somepackage-withmany-deps will install them all for you
05:00:49 <blackh> bremner: it automatically downloads & compiles dependencies like apt-get.
05:01:03 <bremner> ahh. I prefer to use apt-get as much as possible
05:02:24 <bremner> essentially the same issues arise with CPAN and perl. CPAN will install everything if you let it. I prefer not...
05:03:31 <bremner> but then debian perl packaging seems to be more successful than Haskell, probably at least partly because of more developers
05:04:01 <bremner> also, ghc upgrades seem traumatic
05:04:32 <blackh> bremner: The upgrade from ghc 6.8 to 6.10 was very traumatic because they decided to break a few things in the name of progress.
05:05:03 <pejo> blackh, was it something more than exceptions that broke? (Because people leave an open ended dependency on base).
05:05:09 <blackh> bremner: Also I think the transition from 6.8 to 6.10 hasn't been handled all that perfectly by cabal.  But cabal latest + ghc 6.10.1 works well now.
05:05:32 <bremner> I maintain at least 5 machines, so compilation starts to be boring
05:06:36 <blackh> pejo: In the depths of my mind I can only recall one other thing that broke: The "Category" typeclass was new and broke some arrow stuff.
05:06:40 <bremner> anyway, back on topic, it would be good if cabal-install could be integrated with debian. I remember some project like that (cabal-debian?) but I don't know what happen
05:07:02 <Axman6> @hoogle digitTo
05:07:02 <lambdabot> Data.Char digitToInt :: Char -> Int
05:07:13 <Axman6> @hoogle intTo
05:07:13 <lambdabot> Data.Char intToDigit :: Int -> Char
05:07:13 <lambdabot> Language.Haskell.Lexer IntTok :: Integer -> Token
05:07:13 <lambdabot> Distribution.Verbosity intToVerbosity :: Int -> Maybe Verbosity
05:09:04 <blackh> bremner: Yes, it would be good. Isn't there a debian source called "unsafe" with newer Haskell stuff?
05:09:11 <blackh> I read that somewhere.
05:09:37 <bremner> blackh: dunno. Not an official one. Maybe you are thinking of experimental, which has ghc 6.10
05:10:01 <blackh> bremner: This is an unofficial one. I will see if I can find this thing I read.
05:10:21 <bremner> oh right. I remember. Ex-linspire people?
05:10:50 <blackh> http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
05:10:52 <blackh> ^ I have not tried this.
05:11:10 <bremner> ohh, another one!
05:13:02 <blackh> bremner: I am using Ubuntu amd64 and I installed the ghc-6.10.1 binary off haskell.org and it works brilliantly.  That is, I'm not using Ubuntu packages.
05:14:11 <blackh> bremner: That link I gave you is ancient, by the look of it.
05:14:36 <chessguy> 'morning
05:14:48 <bremner> blackh: well, like I said, things are in experimental, so the process is moving
05:17:38 <guenni> my app is running way too fast, I need to build in some delays, how can I do that?
05:17:47 <dcoutts> blackh: there I was thinking we'd managed the 6.8 -> 6.10 transition pretty well. Perhaps you missed the transition from 6.6 -> 6.8 :-)
05:17:47 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
05:18:39 <bremner> in fairness, gcc updgrades are a pain too, but there is more eyes there
05:18:42 <Axman6> guenni: threadDelay
05:18:48 <Axman6> @hoogle threadDelay
05:18:48 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
05:18:59 <guenni> Axman6: thx
05:21:09 <blackh> dcoutts: Perhaps I am grumbling too much. I have a question on this: I used the latest cabal on 6.8.3 (if I recall correctly) and installed a package that depended on base >= 4. It downloaded the base 4 version and then failed (obviously)...
05:21:42 <blackh> dcoutts: I wondered if it might be clever and download the newest version that allowed base 3, but it didn't do that. Is it meant to do that?
05:22:22 <dcoutts> blackh: so the problem there is that when cabal-install looks at the latest version it notices it needs base 4, however it does not yet go and look at older ones that might work. That's on my TODO list for the next release.
05:23:06 <blackh> dcoutts: Cabal is already brilliant, but that will make it even brillianter!
05:23:09 <dcoutts> blackh: I'll do it by an initial bottom-up pass to filter out all the packages that cannot possibly build in your setup
05:23:27 <blackh> dcoutts
05:25:00 <blackh> (oops) - dcoutts: It seems it's sufficiently easy to accidentally upload stuff that won't build.  I did it once, and so did the maintainer of HsOpenSSL. I suppose it's pretty tricky to have Hackage check everything.
05:25:24 <dcoutts> blackh: we'd have to make uploads async for starters
05:25:45 <dcoutts> blackh: and just because it fails on one box doesn't mean it fails everywhere, eg if it needs C libs
05:25:50 <dcoutts> so it's a bit tricky
05:26:01 <Axman6> blackh: http://shootout.alioth.debian.org/u64q/iofile.php?test=pidigits&file=output now happy
05:26:05 <Axman6> not*
05:26:13 <blackh> Yes - A lot of my packages fail to build on hackage due to missing esoteric C libraries.
05:27:26 <blackh> Axman6: That's giving me a PHP error. This would *never* happen with Haskell!
05:28:35 <Axman6> exactly!
05:30:08 <dcoutts> blackh: with the new hackage server it'll not just be one box doing builds
05:30:18 <dcoutts> so the problem with C libs will be much less
05:30:38 <dcoutts> but on the other hand, making sense of the data will be more of a statistical affair
05:38:56 <pejo> dcoutts, is that new hackage server the one you demoed at .. ICFP?
05:39:04 <dcoutts> pejo: yes
05:39:13 * dcoutts is currently updating it to happstack
05:40:02 <Axman6> blackh: ok, i made something... uses way too much RAM though :(
05:40:55 <blackh> Axman6: It could easily just be that GHC bug we spotted.
05:41:14 <Axman6> ah yes, it could be. good point. i'll try with 6.8.3
05:42:10 <Axman6> yep, seems it is, excellent :)
05:42:17 <Axman6> thanks for reminding me!
05:42:42 <blackh> Axman6: I know how to speed it up even more: Unroll your recursive function!
05:42:56 <Axman6> haha, yes!
05:43:01 <hackage> Uploaded to hackage: barrie 0.4
05:43:28 <chessguy> hmm. what's up with http://en.wikibooks.org/wiki/Haskell/Arrows ? is it just me or is that code flat broken
05:43:43 <chessguy> (the first code snippet)
05:43:44 <Axman6> blackh: i get a slight speed up when using two threads too, but not much
05:44:23 <opqdonut> chessguy: yeah, seems so
05:45:02 <chessguy> wonder what they meant instead of -> and <-
05:45:04 <opqdonut> mmh, might not be actually
05:45:16 <chessguy> er, -> and -<
05:45:18 <blackh> Axman6: Well, that's good. Remember we're doing 2.7x the winner's time so any speed-up you get is a great achievement.
05:45:23 <chessguy> opqdonut, really?
05:47:04 <blackh> Axman6: The graph is telling (http://shootout.alioth.debian.org/u64q/benchmark.php?test=pidigits&lang=all&box=1). Note that 11 languages are almost exactly the same speed - there's a flat bit on the graph...
05:47:11 <chessguy> @hoogle (-<)
05:47:12 <lambdabot> No results found
05:47:12 <Axman6> blackh: bah, no faster than the current one when using 6.8.3 :(
05:47:45 <C-Otto> i'd like to have a new wiki account, can you help me?
05:47:56 <blackh> Axman6: Haskell is taking about 10% longer than these, and my theory is this: There's nothing inefficient in the code, except for a slight overhead on function calls that other languages don't have.  I could be wrong, though...
05:48:20 <blackh> Axman6: The way to verify it is to unroll the "loop"
05:48:55 <opqdonut> chessguy: yeah it works, you just have to start ghci with -farrows
05:49:08 <chessguy> opqdonut, err, why?
05:49:23 <Axman6> blackh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1599#a1599
05:49:29 <opqdonut> chessguy: to enable the arrow syntax, proc a -> etc
05:49:31 <blackh> C-Otto: This question has been asked a few times by various people but I haven't seen the answer to it - you'll have to track down the admins of the wiki page, I suspect.
05:50:14 <chessguy> @let idA = proc a -> returnA -< a
05:50:14 <lambdabot>   Parse error
05:50:32 <chessguy> opqdonut, but that doesn't even make sense, as 'a' is undefined there
05:50:59 <opqdonut> chessguy: "proc a ->" is an arrow abstraction
05:51:03 <maltem> C-Otto: There's someone you can mail for an account, but I've forgot who
05:51:11 <Axman6> chessguy: i think it's psudo code
05:51:14 <opqdonut> kinda like "\a ->" except instead of defining a function you define an arrow
05:51:25 <C-Otto> hm.
05:51:31 <opqdonut> it's special syntax, that's why you have to enable it with a flag
05:51:45 <pejo> blackh, why are function calls particularly expensive?
05:51:48 <chessguy> well that's silly
05:52:04 <zachk> are arrow. i know these are really bad words. but do are monads a subset of arrows. anything i can do with monads i can do with arrows. correct?
05:52:25 <blackh> Axman6: You could try writing i2c as chr . (+???) . ord and inlining it
05:52:29 <opqdonut> zachk: yeah, in a sense
05:52:52 <blackh> Axman6: I wonder if the case might be slow.
05:53:03 <Cheshire> :t ((+)`on`ord) 'x'
05:53:04 <lambdabot> Char -> Int
05:53:14 <Cheshire> :t (chr .) . ((+)`on`ord)
05:53:15 <lambdabot> Char -> Char -> Char
05:53:40 <blackh> pejo: This is theory based on some experimentation... In the binary-trees benchmark from the shootout, I was able to speed things up by turning a recursive function...
05:54:20 <blackh> pejo: that traversed the tree into three functions that called each other in turn, and inlining the 2nd and 3rd of them.  This eliminated 2/3rds of the function call overhead.
05:54:53 <blackh> pejo: The speed-up was more than I expected. I looked at the generated code... and managed to make *some* sense out of it...
05:55:26 <pejo> blackh, you started out with one big function, and split it into 3 functions, and then you inlined 2 of those 3 functions into the first one?
05:55:35 <Axman6> blackh: i2c = chr . (+48)
05:55:52 <blackh> pejo: GHC handles the stack in its own way.  This gives the cheap threads, but - so my theory goes - has a small cost.
05:56:03 <blackh> pejo: I'll paste you the code...
05:56:17 <zachk> what does data F=F !Integer !Integer !Integer !Integer do to the integers. make them faster?
05:56:40 <mokus> zachk: makes them strict
05:56:55 <mokus> which can make them faster and/or make them available to be boxed
05:56:59 <mokus> er, unboxed
05:57:03 <Axman6> zachk: means they can't be thunks, they have to always be avaluated
05:57:13 <pejo> blackh, well, it's hard to argue with hard numbers. But still, not really intuitive.
05:58:31 <blackh> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1510#a1510
05:59:21 <Axman6> blackh: good call on the chr thing, saved about 2 seconds
05:59:40 <blackh> pejo: Note that 'check' does not have much actual work to do, so function call overhead will slow things down a lot.
06:01:08 <zachk> I think the reason haskell is slower is it is doing all those IO calls in the loop. I know IO calls incur overheard. It would be faster if one constructed a list.took the list to a string. then did one IO call
06:01:35 <Axman6> zachk: in my code?
06:01:46 <zachk> http://shootout.alioth.debian.org/u64q/benchmark.php?test=pidigits&lang=ghc&id=1
06:01:48 <zachk> that
06:01:54 <bremner> oh, it turns out ghc6.10 is in debian unstable now,  but maybe some of the libraries I need are not there yet
06:01:57 <Axman6> right
06:02:27 <Axman6> zachk: yeah, i should try making my thing build the string, then print it at the end
06:03:12 <zachk> yeah and you want to slurp in the whole file. though I dont know if there is a fast way to do that
06:03:29 <pejo> blackh, that benchmark could easily be deforested away, check is basically some oddball "sum" function that takes a tree.
06:04:04 <pejo> blackh, I'm guessing that would disqualify haskell from the benchmark though.
06:04:30 <blackh> pejo: I think this change breaks the "no unrolling loops" rule. I am getting some figures for you...
06:05:16 <pejo> blackh, what was your change though? Creating check, check2 and check3?
06:07:02 <blackh> pejo: There's one other change in that source code, which is the 'parMap rnf id $', but ignore that for now.
06:07:41 <blackh> pejo: Just the unrolling of "check" makes it faster by 12.6%
06:08:34 <blackh> pejo: That is, the whole benchmark is faster by 12.6% and it's doing rather a lot of memory allocation.
06:08:59 <Axman6> blackh: well, my current code is about 2.2 times slower than the C
06:09:03 <Axman6> for pidigits
06:09:12 <blackh> pejo: The function call overhead seems to be quite a significant factor, therefore, but you could get more accurate with it than I have been.
06:09:21 <Axman6> but apparently the current entry is faster than mine (using 6.8.3)
06:10:06 <blackh> Axman6: My feeling is that the current Haskell entry in the shootout is pretty well optimized and you'd be doing really well if you could get it much faster.
06:11:08 <blackh> Axman6: pidigits, I'm talking about, of course.
06:11:18 <Axman6> yeah
06:12:15 <Axman6> hmm, there's no version of Integer that's unsigned is there?
06:12:23 <Axman6> Word is bounded right?
06:12:29 <Axman6> > maxBound :: Word
06:12:31 <lambdabot>   18446744073709551615
06:12:37 <Axman6> lame
06:13:52 <blackh> Axman6: The Integer values in pidigits are huge.
06:14:05 <Axman6> yeah, i know
06:14:32 <Axman6> just wondering if there was an unsigned version. the C entry seems to use unsigned gmp integers
06:17:12 <blackh> Good night!
06:17:20 <Axman6> night man
06:17:31 <Axman6> need to sleep too, uni starts on monday
06:19:24 <mokus> Axman6: would foreign calls to gmp be illegal? ;-)
06:23:43 <Axman6> mokus: probably, though that is in a sense what a lot of the other languages are doing
06:24:11 <mokus> well, Haskell is too - it just makes it look pretty
06:24:29 <Axman6> yeah
06:30:17 <dcoutts> @seen Lemmih
06:30:17 <lambdabot> Lemmih is in #haskell-in-depth and #haskell. I don't know when Lemmih last spoke.
06:37:15 <hallongrottan> @src map
06:37:15 <lambdabot> map _ []     = []
06:37:15 <lambdabot> map f (x:xs) = f x : map f xs
06:40:34 <vincenz> : t foldl ((:) . f)
06:40:41 <vincenz> :t foldl ((:) . f)
06:40:43 <lambdabot> forall b. (SimpleReflect.FromExpr b, Show b) => [b] -> [[b]] -> [b]
06:48:48 <jeffwheeler> If I import a module with a bunch of name collisions with my current file qualified/renamed ('import qualified Data.List.PointedList as PL'), is there any way to re-export those functions without having the 'PL' as part of their name? I can export PL.focus, but the users of my file then have to do the same.
06:49:18 <Cheshire> why don't you import it with the name you want to export it with ?
06:49:57 <jeffwheeler> I want to re-export some of the file as if it was written in my file --- without any name.
06:50:55 <jeffwheeler> I suppose I could have two imports: the unqualified import restricted to only non-colliding names, and the qualified import for which I don't want to re-export anything anyways.
06:51:38 <SamB> well, just use qualified as and then re-export the full name?
06:51:50 <SamB> with module Foo.Bar in your export list
06:52:15 <sauf_> hi, is it known that quickCheck (ghc 6.6) is bugged for recursive fonctions ?
06:52:55 <jeffwheeler> SamB: I only want to re-export certain non-colliding names, and export my alternatives of the rest. If I re-export, say, PL.focus, files using it have to use 'PL.focus' too, not just 'focus'.
06:52:56 <SamB> and if you wanted to export ALL of them, you could put module PL in your export list
06:53:46 <SamB> jeffwheeler: don't worry -- putting module Foo.Bar in the export list won't export the names from the "qualified ... as PL" import
06:55:08 <SamB> and I'm pretty sure you aren't allowed to export names qualified
06:55:12 <jeffwheeler> SamB: Interesting; that seems to work. So, it just re-exports the things I've imported from that file under that name?
06:55:27 <SamB> well, anything you've imported under that name
06:55:34 <jeffwheeler> Yeah
06:55:42 <jeffwheeler> neat; thanks
06:55:43 <SamB> if you had imported another module "as" that name, it would work too ;-)
06:56:04 <SamB> (assuming you didn't have any ambiguous names, of course)
06:58:37 <sauf_> *Test Test.QuickCheck> quickCheck myProperty Falsifiable, after 5 tests: 2 -2 -4 4 -2 -1 *Test Test.QuickCheck> myProperty 2 (-2) (-4) 4 (-2) (-1) False *Test Test.QuickCheck> :r *Test >myProperty 2 (-2) (-4) 4 (-2) (-1) True
06:58:45 <skorpan> @pl \t point begin end -> f point begin end t
06:58:45 <lambdabot> flip (flip . (flip .) . f)
06:59:44 <sauf_> oups, missing some "\n"
07:00:59 <sauf_> False , True are results from ghci
07:01:21 <sauf_> and they are different !
07:02:44 <SamB> ooh
07:02:56 <SamB> ohloh has opened-up their SCM library
07:03:21 <Cheshire> @pl \g a b c d e f -> a b c d e f g
07:03:21 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .))
07:03:31 <Cheshire> @pl \g a b c d e f -> a b c d e g f
07:03:31 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .))
07:03:38 <Cheshire> @pl \g a b c d e f -> a b c d g e f
07:03:38 <lambdabot> flip (flip . ((flip . (flip .)) .))
07:03:52 <xinming> @pl \g a s d f g -> h j k l ;
07:03:52 <lambdabot> (line 1, column 25):
07:03:52 <lambdabot> unexpected ";"
07:03:52 <lambdabot> expecting variable, "(", operator or end of input
07:04:20 <xinming> @pl \g a s d f g -> g f d s a
07:04:21 <lambdabot> const (flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
07:04:24 <xinming> :-)
07:07:06 <augustss> @pl \ a b c d e f g h i j k l m n o p q r s t u v w x y z -> h e l l o w o r l d
07:07:10 <lambdabot> const (const (const (((const . const . (const .)) .) . ((const .) .) . ((const .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . (((((const .) .) .) .) .
07:07:10 <lambdabot> ) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . flip (flip . (
07:07:10 <lambdabot> flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((flip .) .) .) . flip flip id . (flip .) . ((ap .
07:07:10 <lambdabot> ) .) . (((flip .) .) .) . flip flip id . (ap .) . flip id))))
07:07:11 <lambdabot> optimization suspended, use @pl-resume to continue.
07:07:50 <Cheshire> @pl \[a,b,c] -> c b a
07:07:51 <lambdabot> (line 1, column 2):
07:07:51 <lambdabot> unexpected "["
07:07:51 <lambdabot> expecting pattern
07:09:03 <SamB> heh, look at this commit name:
07:09:06 <SamB> Add color combinators that toke ANSIColor
07:09:21 <SamB> http://github.com/batterseapower/ansi-wl-pprint/commit/b8628ffd418855c7fcc3ca73168eab9c5b6a39ed
07:09:27 * SamB wonders if that was intentional
07:09:56 <raf_kig> @\a:b:c:[] -> c b a
07:09:56 <lambdabot> Unknown command, try @list
07:10:02 <raf_kig> @pl \a:b:c:[] -> c b a
07:10:02 <lambdabot> (line 1, column 8):
07:10:02 <lambdabot> unexpected "["
07:10:02 <lambdabot> expecting "()", natural, identifier, "_" or "("
07:10:14 <raf_kig> @pl \a:b:c:_ -> c b a
07:10:14 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . (const .)) .) . flip (flip . flip id) . head) tail
07:11:06 <gwern> > (40/51) * 100
07:11:08 <lambdabot>   78.43137254901961
07:13:04 <sauf_> forget it, quickCheck has no bug : I fogot to :m +Test.QuickCheck  somewhere
07:26:39 <maltem> Since I don't really like export lists, what do people think of an alternative, imaginary module syntax that goes something like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1600
07:27:35 <koeien> maltem: you would get one biiiiiiiiig file
07:28:04 <maltem> koeien: oh, the idea is that I would still have multiple files :)
07:28:29 <koeien> it seems complicated to me
07:29:11 <maltem> ah really? It looks so simple to me
07:29:36 <maltem> maybe not as simple as current hierarchical modules
07:30:38 <SamB> maltem: you don't need export lists ...
07:31:03 * SamB sometimes thinks he would like it if you could indicate at the place of definiton whether or not to export a thing, though
07:31:31 <Cheshire> maltem, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1600#a1601
07:32:09 <Taejo> can I tell GHCi not to print the result of a monadic assignment?
07:32:42 <maltem> SamB: How do you do an abstract data type without export lists?
07:32:50 <maltem> Cheshire: heh, interesting
07:33:02 <SamB> maltem: oh, well, you can't
07:33:26 <maltem> Taejo: you mean "<-"? yes, somehow :)
07:33:39 <Taejo> maltem: yes
07:33:45 <SamB> -fno-print-bind-result
07:33:50 <SamB> from my .ghci
07:33:59 <SamB> the whole line is this:
07:34:01 <SamB> :set -ignore-package lang-1.0 -fno-print-bind-result
07:34:14 <Taejo> SamB: thanks
07:34:17 <SamB> but I dunno if the first bit is at all relevant anymore
07:34:33 <SamB> :def b (return . (":browse "++))
07:34:39 <SamB> I also have that, if anyone wants it
07:34:48 <maltem> Taejo: ah actually in ghci 6.10 that's default
07:34:53 <SamB> if you miss using :b for browsing, not setting breakpoints
07:35:09 <edwardk> hrmm does anyone remember tim newsham's nick?
07:35:15 <Cheshire> newsham
07:35:32 <edwardk> hah problem with skimming a list of 631 people is you can never find any of them ;)
07:35:57 <edwardk> @seen newsham
07:35:57 <lambdabot> newsham is in #haskell, #haskell-blah and #haskell-in-depth. I last heard newsham speak 7h 38m 25s ago.
07:54:59 <CTA> Is it best to use Haskell on Linux/Mac to Windows?
07:55:22 <Elly> Can you rephrase your question in English?
07:55:35 <CTA> that makes sense
07:55:42 <Cheshire> no it doesn't
07:55:54 <Cheshire> I will take a wild guess though:  Yes
07:55:59 <Elly> did you mean "Is it better to use Haskell on Linux/Mac than Windows"?
07:56:02 <Elly> If so, probably yes
07:56:09 <CTA> On a mac osx/linux os system compared to windows?
07:56:25 <CTA> just im thinking about getting a vm for linux
07:56:54 <Elly> it's probably better to do most things on linux than windows :)
07:57:14 <raf_kig> os wars :-)
07:57:23 <koeien> go do that in #hurd
07:57:25 <koeien> :P
07:57:33 <raf_kig> ;-)
07:58:09 <CTA> haha lol, I might dual boot vista ;)
08:06:36 <Cheshire> in a pattern match like
08:06:41 <Cheshire> f x y (C z w) e = ...
08:06:52 <Cheshire> what do you call each of these 'x' or 'C z w' parts?
08:07:19 <EvilTerran> Cheshire, well, each one's a pattern
08:07:56 <akow> is it illegal to use something like x:y:xs for pattern matching? I cant make it work =( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1602
08:08:14 <Cheshire> akow, use ()'s
08:09:05 <Taejo> :t fromMaybe
08:09:06 <lambdabot> forall a. a -> Maybe a -> a
08:09:44 <edwardk> @tell newsham you can't just discard the continuation's result parameter in your Classial.hs or you admit unsound members like  CProp (const ()) :: Prop FALSE  -- for a fix see http://comonad.com/reader/2008/rotten-bananas/
08:09:44 <lambdabot> Consider it noted.
08:11:25 <johnbs> Is there any way of hiding a class instance when importing a module?  Or of hiding a re-exported module (eg, if I import Text.Parsec, which re-exports Text.Parsec.ByteString, can I exclude that whole module?)
08:11:50 <dolio> No.
08:11:53 <johnbs> pity
08:11:54 <edwardk> johnbs: nope. thats the problem with defining the class in the same place as the instances
08:12:16 <edwardk> hence why Control.Monad.Reader.Class, etc. exist
08:12:24 <edwardk> kinda hacky
08:12:41 <akow> Cheshire: thanks! hehe, now i remember =D
08:13:01 <dolio> Is that why it exists?
08:13:37 <dolio> That seems incorrect.
08:13:50 <edwardk> ?
08:14:01 <dolio> Control.Monad.State.Class clearly exists so that both Strict and Lazy can implement it.
08:14:10 <dolio> And Reader.Class is just following that convention.
08:14:28 <edwardk> i think there are both reasons for its existence
08:15:48 <CTA> I have a good for when I reach college mwha - as in programming in Haskell goal
08:16:53 <edwardk> My reasoning for making things like Control.Comonad.Context.Class was explicitly so you could decide if you wanted the named context comonad to be available or not
08:17:52 <dolio> It also cleared up a problem in my own little mtl replacement, as it happens.
08:17:53 <edwardk> State.Lazy and State.Strict could both exist in the same source file if we were less er... lazy about wanting to change lots of source code when we waffled between them ;)
08:18:02 <dolio> Because I defined all the normal monads as MonadT Identity.
08:18:38 <dolio> But that would lead to circular dependencies if I wanted to import all the classes to be defined for IdentityT.
08:19:09 <dolio> I guess that's a similar situation.
08:19:10 <edwardk> heh, btw- i'm having fun defining my monad transformers in kata, because my identity monad is really the identity monad, and hence there is no constructor noise for using a monad transformer over identity ;)
08:19:26 <CTA> I want to make a copy of notepad, then use my copy to code Haskell in =(
08:19:28 <CTA> *=)
08:19:34 <dolio> Yeah. That's nice in Agda, too.
08:20:52 <Taejo> > fmap (+1) (Right 0)
08:20:53 <lambdabot>   Right 1
08:20:58 <Taejo> > fmap (+1) (Left "fail")
08:20:59 <pejo> CTA, are you aware of Yi?
08:20:59 <lambdabot>   Left "fail"
08:21:12 <edwardk> right now i'm beating my head against trying to make sure that everything that should be a category can subclass off of it. (setoids, posets, monoids, kata, cat, etc.)
08:23:01 <edwardk> which is surprisingly difficult even in my 'duck typed' setting
08:23:12 <dolio> Heh.
08:23:36 <dolio> At least you won't have to implement universe polymorphism.
08:24:11 <edwardk> my universe is like the real one, a muddled heap of stuff without rhyme or reason
08:24:18 <dolio> :)
08:24:57 <dolio> Come to think of it, universe polymorphism might fix my beef with the indexed monads in Agda.
08:25:05 <dolio> I wonder when it'll get that. :)
08:25:17 <edwardk> heh, kata doesn't need to distinguish between indexed and regular ones ;)
08:25:28 <edwardk> just don't make a type error coz i won't be able to help you =)
08:26:28 <dolio> They picked value-indexed monads for some reason. But all the one's I've ever seen were type indexed.
08:27:02 <dolio> And seeing as there's no automatically populated type-rep type, that's not really the same.
08:27:12 <edwardk> yeah
08:27:22 <kosmikus> dolio: for all things practical, what's your problem with --type-in-type ?
08:27:50 <dolio> This isn't really a practical objection. :)
08:28:06 <edwardk> whats a paradox or two between friends?
08:28:26 <dolio> It's not like I'm using Agda besides playing in my spare time anyway.
08:29:21 <edwardk> Hurkens never hurt anyone who didn't have it coming to them ;)
08:31:51 <Taejo> is # valid in constructor names? F# is nicer than FSharp
08:32:34 <trofi> > let >#< = show in >#< 1
08:32:35 <lambdabot>   <no location info>: parse error on input `>#<'
08:33:01 <edwardk> > let f# = 1 in f#
08:33:02 <lambdabot>   1
08:33:06 <Taejo> sweet
08:33:13 <edwardk> its valid in ghc, but not iirc in haskell98 officially
08:33:23 <edwardk> they use it to mark up primitive types
08:33:38 <edwardk> i.e. Int#, etc.
08:33:50 <Taejo> edwardk: oh, of course
08:33:58 <Taejo> do I need a language extension flag?
08:34:24 <edwardk> yeah -fglasgow-exts will get it
08:34:43 <edwardk> i'm sure there is some newfangled -XDontHurtMe kinda thing around ;)
08:34:52 <dolio> -XMagicHash
08:34:56 <edwardk> ah
08:35:06 <Taejo> dolio, edwardk: thanks
08:35:16 * edwardk sounded like he was about to say "get off my lawn"
08:35:22 <Taejo> :i Enum
08:35:35 * Cheshire wonders what is automatically populated type-rep type?
08:35:37 <johnbs> Magic hash?  Is there an -XMagicMushroom too?
08:36:00 <Taejo> what is a minimal declaration of Enum?
08:37:05 <edwardk> toEnum fromEnum
08:37:18 <dolio> data TypeRep : Set -> Set where Nat : TypeRep Nat ; Vec : {n : Nat} -> TypeRep a -> TypeRep (Vec a n) ; ...
08:37:21 <Taejo> edwardk: thanks
08:37:45 <dolio> And it gets a new constructor each time you define a new datatype.
08:37:55 <Cheshire> dolio, and what is this used for?
08:38:05 <Taejo> @hoogle [a] -> a -> Int
08:38:05 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
08:38:05 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
08:38:05 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:38:27 <Cheshire> can we write
08:38:32 <Cheshire> "Nat" : TypeRep Nat  or something
08:38:35 <dolio> Using value-indexed things as if they were type-indexed.
08:38:36 <Cheshire> (less confusing)
08:40:00 <conal> @seen jamii
08:40:00 <lambdabot> jamii is in #haskell. I last heard jamii speak 15h 11m 44s ago.
08:41:15 <dolio> Anyhow, it's how jhc does type-classes, and how it could do dynamics without unsafeCoerce.
08:41:20 <edwardk>  /msg dolio make sense?
08:41:23 <dolio> More or less.
08:41:31 <edwardk> er. woops
08:41:38 <conal> @tell jamii i might change VectorSpace back from associated types to using functional dependencies, to eliminate the numerous explicit equality constraints.  any objections?
08:41:38 <lambdabot> Consider it noted.
08:41:55 <Taejo> > -1 `mod` 12
08:41:56 <lambdabot>   -1
08:41:56 <eu-prleu-peupeu> hey conal, when is the next version of reactive going to come out ? :)
08:41:59 <Taejo> > -1 `rem` 12
08:42:00 <lambdabot>   -1
08:42:08 <dolio> Sorry about that. Private messages from you don't ping me for some reason. I'll look now. :)
08:42:10 <gwern> eu-prleu-peupeu: about 10 blog posts from now
08:42:13 <edwardk> hah
08:42:25 <conal> eu-prleu-peupeu: after the icfp deadline.
08:42:29 <m0nkfish> > 10 `mod` 3
08:42:30 <lambdabot>   1
08:42:36 <m0nkfish> > 10 `rem` 3
08:42:37 <lambdabot>   1
08:42:39 <m0nkfish> :S
08:42:39 <conal> eu-prleu-peupeu: which is march 2
08:43:09 <gwern> m0nkfish: we call that sort of thing 'referential transparency'
08:43:09 <Cheshire> dolio, it's possible to write functions a -> TypeRep and TypeRep -> TypeRep I guess, but not TypeRep -> a?
08:43:21 <m0nkfish> :]
08:43:48 <Cheshire> (considering it as some abstract type which the implementation extends when you declare new data)
08:44:35 <dolio> Well, you'd want...
08:44:48 <dolio> a -> TypeRep (give me the value representing this type).
08:45:03 <Cheshire> wouldn't that be Set -> TypeRep?
08:45:26 <dolio> Yeah, maybe.
08:45:34 <Cheshire> dolio, interesting thing about something like that is, it's let you prove things like  Bool == Direction -> False  (data Direction = Left | Right)
08:45:40 <dolio> Oh, yeah.
08:45:41 <Cheshire> which would not be provable normally
08:45:59 <dolio> a -> TypeRep would be, "give me the representation of the type of this value".
08:46:43 <dolio> Anyhow, you also want TypeRep -> Set, which gives you back the type given the rep.
08:46:44 <Cheshire> I wonder what the normal form of   \n:N -> \v:Vector Foo n -> typeOf v   would be?
08:47:20 <Cheshire> i.e. with n:N and v:Vector Foo n hypothesis, what is typeOf v?
08:49:05 <Cheshire> (although you could only prove Bool == Direction -> False given TypeRep elimination, so maybe without that it's still conservative ...?)
08:55:23 <conal> hm.  i just noticed that fixity declarations can go in class declarations.
09:06:56 <BONUS> i just found out about (\(a :: SomeType) -> ...)
09:06:57 <BONUS> o_O
09:09:52 <newsham> edwardk: hello
09:09:52 <lambdabot> newsham: You have 1 new message. '/msg lambdabot @messages' to read it.
09:10:00 <jeffwheeler> > let apply [] x = x ; apply (f:fs) x = f (apply fs x) in apply [("a"++), ("b"++)] "c"
09:10:02 <lambdabot>   "abc"
09:10:10 <jeffwheeler> Is there a standard function that does something like that?
09:10:20 <Cheshire> > sequence [("a"++), ("b"++)] "c"
09:10:21 <lambdabot>   ["ac","bc"]
09:10:34 <Cheshire> > map ($"c") [("a"++), ("b"++)]
09:10:34 <jeffwheeler> @type sequence
09:10:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:10:36 <lambdabot>   ["ac","bc"]
09:10:48 <Cheshire> > foldr (.) ($"c") [("a"++), ("b"++)]
09:10:48 <lambdabot>       Overlapping instances for Show (([Char] -> [Char]) -> [Char])
09:10:49 <lambdabot>        ar...
09:10:59 <Cheshire> > (foldr (.) (const "c") [("a"++), ("b"++)]) ()
09:11:01 <lambdabot>   "abc"
09:11:15 <Cheshire> > (foldr (.) id [("a"++), ("b"++)]) "c"
09:11:16 <lambdabot>   "abc"
09:11:26 <jeffwheeler> I'm not sure that's prettier. :-/
09:12:00 <Olathe> > let apply fs = foldr ($) x fs in apply [("a"++), ("b"++)] "c"
09:12:01 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Char]'
09:12:06 <Olathe> > let apply fs x = foldr ($) x fs in apply [("a"++), ("b"++)] "c"
09:12:08 <lambdabot>   "abc"
09:12:18 <Olathe> > let apply fs x = foldl' ($) x fs in apply [("a"++), ("b"++)] "c"
09:12:19 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
09:12:19 <lambdabot>      Proba...
09:12:28 <Olathe> > let apply fs x = foldl' (id) x fs in apply [("a"++), ("b"++)] "c"
09:12:29 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> a
09:12:29 <lambdabot>      Proba...
09:12:33 <Olathe> Something.
09:12:45 <Olathe> @type foldl'
09:12:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:13:02 <Olathe> > let apply fs x = foldl' (flip id) x fs in apply [("a"++), ("b"++)] "c"
09:13:03 <lambdabot>   "bac"
09:14:06 <wa1> hi everybody ;)
09:14:16 <wa1> i'm elena
09:14:35 <Cheshire> hi
09:14:49 <wa1> how r u?
09:14:57 <Cheshire> quixotic
09:15:03 <Olathe> @vixen how r u?
09:15:03 <lambdabot> doing good
09:15:05 <thegravian> caffinated
09:15:10 <wa1> cool
09:15:22 <newsham> ability/syntax/language?
09:15:29 <thegravian> XD
09:15:29 <wa1> cretins
09:16:08 <newsham> arguments/syntax/lambdas?
09:16:41 <wa1> type of function plz
09:16:54 <paper_cc> a -> a
09:16:58 <paper_cc> or a -> b
09:17:08 <jeffwheeler> No! [a -> a] -> a -> a!
09:17:42 <jeffwheeler> @type foldl' (flip id) x fs
09:17:43 <lambdabot> Not in scope: `fs'
09:17:55 <jeffwheeler> @type \fs x -> foldl' (flip id) x fs
09:17:56 <lambdabot> forall c. [c -> c] -> c -> c
09:17:59 <newsham> (a -> c, b -> c) -> Either a b -> c
09:18:04 <jeffwheeler> Err, why c?
09:19:23 <gwern> @quote chocolate
09:19:23 <lambdabot> No quotes match. My pet ferret can type better than you!
09:19:39 <BONUS> hmmm strange, i cant get haskell to recognize \(a::Int) -> a +1 even though i did {-# LANGUAGE ScopedTypeVariables -#}
09:19:44 <gwern> @remember SimonBrenner 2kg of chocolate 'thunks' to 'force' really might 'blow your stack' later on.
09:19:44 <lambdabot> It is stored.
09:19:47 <gwern> @quote chocolate
09:19:47 <lambdabot> SimonBrenner says: 2kg of chocolate 'thunks' to 'force' really might 'blow your stack' later on.
09:20:02 <Cheshire> @quoot
09:20:02 <lambdabot> Maybe you meant: quit quote
09:20:04 <Cheshire> @quoote
09:20:04 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:20:07 <Cheshire> @quoote
09:20:07 <lambdabot> DRMacIver says: So basically the lambda calculus is a demonstration that verbing weirds language? :)
09:20:57 <gwern> @quote apocalypse
09:20:57 <lambdabot> KetilMalde says: No, those are quite outdated by now.  The new horsemen of the programming apocalypse are, of course, IO, MutableState, LazyMemoryLeak, and Bottom.
09:21:07 <gwern> @quote lyah
09:21:07 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
09:21:14 <gwern> @quote pooper
09:21:15 <lambdabot> No quotes match.
09:21:53 <BONUS> :]
09:22:49 <gwern> @remember byorgey ⊥.... is a party pooper
09:22:49 <lambdabot> Okay.
09:23:00 <gwern> @quote supplements
09:23:00 <lambdabot> idnar says: enlarge your context in just seven days with all-natural herbal supplements!
09:23:11 <gwern> @quote stmt
09:23:11 <lambdabot> ghc says: Exotic Stmt in meta brackets
09:23:14 <gwern> @quote stmt
09:23:14 <lambdabot> mmorrow says: gah, i'm so used to haskell i forgot a return stmt in C and was trying to figure out where the  segfault was happening for 20 minutes
09:23:21 <gwern> @flush
09:23:22 <gwern> @flush
09:23:30 <shapr> @vacuum
09:23:30 <lambdabot> Unknown command, try @list
09:23:53 <Olathe> @unclog
09:23:53 <lambdabot> Unknown command, try @list
09:24:03 <EvilTerran> @clean
09:24:03 <lambdabot> http://www.haskell.org/learning.html
09:24:07 <Cheshire> hi shapr
09:24:47 <newsham> cant all the quote stuff go to -blah?
09:25:11 <gwern> it could, except I'm not in -blah
09:25:24 <newsham> (if only the bot accepted messages)
09:25:41 <Cheshire> so.....
09:25:48 <pejo> newsham, it does?
09:25:50 <shapr> hiya Cheshire, smile!
09:25:55 <jeffwheeler> Yeah, lambdabot should totally accept room invites from anybody.
09:26:08 <jeffwheeler> I like showing off Haskell to random people in the privacy of my own room.
09:26:12 <thegravian> o/ #haskell room, I have a question.  Is the reader monad generally more desirable for computations that involve say...symbol tables?  vs. the State monad
09:26:19 <jeffwheeler> That way if I say something dumb, nobody ever knows. :)
09:27:01 <jeffwheeler> I like to go to some random room, like #teachingmatthaskell that nobody will know about, and invite the other person. It would be great if I could have lambdabot come too.
09:27:02 <peres> jeffwheeler: what about logs ;)
09:27:12 <jeffwheeler> peres: nobody reads those. :P
09:27:12 <newsham> thegravian: the state monad is more powerful than the reader, but if you use the reader you are demonstrating that the data is read-only
09:27:23 <jeffwheeler> peres: and if they do, it'll be too late for them to correct me.
09:27:33 <newsham> thegravian: so if you want the type system to enforce that, and ot convey to readers of your code, then you can pick the stricter type
09:27:40 <Cheshire> shapr grumble I still I didn't think of something constructive to do today
09:27:48 <peres> jeffwheeler: they may publish them on some well known website, together with your picture :P
09:27:50 <shapr> Cheshire: Binary parsing?
09:27:54 <newsham> but if you dont midn being fast and loose and want flexibility you can pick the less strict type
09:27:57 <gwern> Cheshire: I have a lengthy todo list if you need some help
09:28:05 <jeffwheeler> peres: hmm :-/
09:28:16 <jeffwheeler> peres: I like the thought of privacy :)
09:28:33 <gwern> Cheshire: pick a random task in the haskell section of http://community.haskell.org/~gwern/wiki/TODO.page and set to!
09:28:36 <shapr> gwern: Is your list online?
09:28:43 <peres> :)
09:28:52 <asgaroth> Where is the `memoize' defined that is used in this example on the wiki? http://www.haskell.org/haskellwiki/Memoization#Memoizing_fix_point_operator
09:29:19 <thegravian> newsham: thanks, I'm kind of new to all this...trying to write haskell as my first non-imperative language...I wrote a section of a compiler with it sans-monads, and it's quite ugly.  I'm trying to clean it up by learning/incorporating some monads
09:29:50 <newsham> the great thing is that once you're using one monad, there's not too much rewriting ifyou decide to switch between them
09:30:06 <newsham> as long as you abstract which monad you're using by giving it a type declaration.
09:30:12 <Cheshire> shapr, ill you tell me abit about it what you're doing with binary formats?
09:30:13 <thegravian> yeah, I'm just faceplanting into the learning curve atm
09:30:21 <conal> BONUS: try PatternSignatures
09:30:23 <newsham> ie:   type MyType = Reader String
09:30:54 <newsham> thegravian: *nod* its a big curve, but its a very fun ride.
09:31:05 <BONUS> conal thanks. i wonder why GHC keeps telling me to use ScopedTypeVariables
09:31:11 <thegravian> newsham: agreed, ^_^
09:31:22 <conal> BONUS: oh, wow.  sounds like a bug.
09:31:33 <shapr> Cheshire: I want to write one of those mp3 tagging programs that handles FLAC.
09:31:50 <BONUS> hehe i have 6.10.1, just load up ghci and try doing (\(a::Int) -> a)
09:31:57 <Cheshire> hm I dunno what mp3 tagging is
09:32:02 <thegravian> you mean like Last.fm?
09:32:24 <Cheshire> shapr, is there one in haskell and you're going to add FLAC support ?
09:32:50 <gwern> Cheshire: tags are little text fields in the file, like 'title' 'album' 'composer' etc
09:32:55 <Cheshire> ok
09:33:03 <shapr> Cheshire: I download a bunch of music from http://bt.etree.org/ and it usually includes a .txt file giving the artist and name of the song. But that information isn't in the file itself, for purposes of last.fm info saving.
09:33:03 <thegravian> oof like ID3 tags
09:33:09 <shapr> right!
09:33:26 <thegravian> does Flac have something like ID3 support?
09:33:40 <shapr> Sure!
09:33:45 <Cheshire> eeps
09:33:45 <Cheshire> http://flac.sourceforge.net/format.html
09:33:50 <thegravian> ty
09:33:59 <shapr> Cheshire: Exactly, that was fast :-)
09:34:03 <whpearson> Is there any move to try and make the Haskell libraries sane?  E.g. make things that implement monads also implement functors, etc. Also something to try and create a common type class for arrays and lists?
09:34:27 <Cheshire> shapr do you really want a haskell parser for this format.. it' looks scary, I'd probably call on a command line tool that did the tagging
09:34:38 <BONUS> whpearson: haskell prime
09:34:40 <shapr> Cheshire: Well, that's what I want to write.
09:34:48 <xcthulhu> Does anyone here know where I can find Awodey's book on Haskell?
09:34:52 <asgaroth> Where is the `memoize' defined that is used in this example on the wiki? http://www.haskell.org/haskellwiki/Memoization#Memoizing_fix_point_operator
09:35:09 <shapr> xcthulhu: What book is that?
09:35:23 <Cheshire> shapr,
09:35:24 <Cheshire>  SUBFRAME_VERBATIM
09:35:24 <Cheshire> <n*i> 	Unencoded subblock; n = frame's bits-per-sample, i = frame's blocksize.
09:35:25 <whpearson> BONUS: I had a look at the haskell' website I couldn't see much about that sort of thing.
09:35:29 <Cheshire> dependent types :p
09:35:54 <shapr> You think it'll require DTs?
09:35:59 <Cheshire> well no
09:36:02 <Cheshire> but it could
09:36:09 <xcthulhu> shapr:  Steve Awodey from CMU has an intermediate level Category Theory text.
09:36:14 <jdavis> Is there a reason why Haskell doesn't support subtyping? Is there a document explaining this already?
09:36:17 <EvilTerran> asgaroth, well, it's not on that page... have you tried some of the urls it links to?
09:36:30 <xcthulhu> There's a few copies of it kicking around online since it was just a PDF he used to teach his class before he published it
09:36:36 <EvilTerran> asgaroth, for instance, those under "For further and detailed explanations, see..."?
09:36:39 <Cheshire> shapr, did you see newshams paper
09:36:39 <BONUS> man what the heck. can anyone get (\(a::Int) -> a) to work on GHC 6.10.1
09:36:40 <Cheshire> ?
09:36:43 <shapr> xcthulhu: Ah, no wonder I haven't heard of it as a Haskell book :-)
09:36:45 <Cheshire> about serialization
09:36:50 <shapr> Cheshire: Which paper? marshalling?
09:36:53 <Cheshire> yes
09:36:53 <TomMD> Does anyone else have trouble compiling GHC head due to some issue with the extensible exceptions library?
09:37:11 <mmorrow> TomMD: what version of ghc are you building it with?
09:37:13 <shapr> Cheshire: In fact, I have that in my inbox, that's exactly what I want to use for binary parsing.
09:37:17 <TomMD> 6.10.1
09:37:30 <mmorrow> TomMD: hmm, i'm not sure then
09:37:31 <shapr> Cheshire: psst, let's move over to in-depth for this..
09:37:32 <Cheshire> shapr, it seems a good fit yeah
09:37:53 <newsham> jdavis: in haskell you can create classes that depend on other classes.
09:37:54 <pejo> jdavis, there are design decisions that need to be made for any type system extension. (O'Haskell had subtyping though).
09:38:11 <newsham> and instances that depend on other instances
09:38:22 <mmorrow> ,  (\(a::Int) -> a) 42
09:38:25 <lunabot>  luna: Illegal signature in pattern: Int
09:38:42 <EvilTerran> BONUS, it works in ghci for me, with -XScopedTypeVariables or with -XPatternSignatures (altho the latter gives me a deprecation warning)
09:38:43 <mmorrow> BONUS: iirc you have to turn pattern sigs on
09:38:47 <EvilTerran> (using 6.10.1)
09:38:54 <BONUS> hmm let's see
09:38:59 <mmorrow> luna uses 6.10.1
09:39:01 <skorpan> i'm in quotes of the week! awesome!
09:39:02 <jdavis> newsham: is that equivalent to making a type that is a proper subset of the domain of another type?
09:39:03 <mmorrow> *lunabot
09:39:06 <shapr> skorpan: yay!
09:39:13 <mmorrow> err, actually lunabot's using 6.10.0.something
09:39:20 <newsham> jdavis: i dont know
09:40:10 <BONUS> i do {-# LANGUAGE ScopedTypeVariables #-} and it still tells me:
09:40:11 <BONUS>     Illegal signature in pattern: Int
09:40:13 <BONUS>         Use -XScopedTypeVariables to permit it
09:40:19 <xcthulhu> shapr:  Found it.  Just google "Categories for Everybody".  It's written under the assumption that people who aren't strictly mathematicians might find it useful...
09:40:28 <BONUS> it doesnt work with OPTIONS_GHC either
09:40:31 <BONUS> says the smae thing
09:40:46 <jdavis> newsham: I'm new to Haskell, but it looks like typeclasses are more like interfaces than domains.
09:41:03 <jeffwheeler> Having QuickCheck actually find errors feels so good.
09:41:16 <BONUS> hmm wait nvm
09:42:52 <Cheshire> is there a mailing list about datatype generic/polytripic programming?
09:42:55 <shapr> xcthulhu: Sound sneat
09:43:02 <mmorrow> ,  (\a -> (a::Int)) 42
09:43:04 <lunabot>  42
09:43:16 <newsham> jdavis: whats the different between an interface that specifies certain allowable operations and a domain that is defined by those operations?
09:43:23 <BONUS> strange, if i do :set -XScopedTypeVariables it works but if i just load up a file in ghci that has {-# LANGUAGE ScopedTypeVariables #-} at the top it says i need to turn on scoped type variables
09:43:43 <mmorrow> Cheshire: polytripic? is that kinda like programming while on at least two hallucinogens?
09:44:17 <jdavis> newsham: a domain is a set of values. How can operators define the set of values that make up a domain? (this is a serious question, I'm not trying to be argumentative)
09:44:24 <edwardk> heya newsham
09:45:15 <mmorrow> Cheshire: or perhaps being on just one and being on an airplane while programming would qualify too
09:45:15 <newsham> jdavis: well, for example, the Num class represents the set of objects for which (+), (-) etc make sense.
09:45:23 <Cheshire> heh
09:45:33 <newsham> jdavis: they seem like different concepts, but they seem fairly closely tied together
09:45:35 <SamB> @google hscope
09:45:36 <pejo> jdavis, trying to shoehorn a design meant for a language with subtyping into haskell is probably not going to be very elegant, no. If you have a particular problem in mind this channel is usually very helpful with suggesting reasonable designs though.
09:45:36 <lambdabot> http://www.geocities.com/caitlinl_69/hscope.html
09:45:36 <lambdabot> Title: hscope
09:45:42 <SamB> @google hscope haskell
09:45:43 <lambdabot> No Result Found.
09:45:47 <SamB> aww
09:45:51 <Twey> Can I get GHC to do only the desugaring pass?
09:45:54 * SamB wants cscope, only for Haskell
09:45:58 <newsham> edwardk: i'm still trying to wade through your blog post but honestly its a bit above me, I may need to ask for some help fixing the article when i'm done
09:46:01 <shapr> Twey: Are you on a diet?
09:46:12 * Twey laughs.
09:46:13 <SamB> Twey: you can use -ddump-desugared or something
09:46:17 <Twey> Yes, soy only
09:46:18 <pejo> Twey, you can get external core, and there's a bunch of -ddump-<keyword> flags.
09:46:19 <Twey> Thanks :)
09:46:45 <SamB> -ddump-ds
09:47:00 <mmorrow> on the -ddump topic, this is somewhat amusing in ghci: $ ghci -ddump-bcos
09:47:05 <SamB> pejo: external core is WAY further along than he seems to have asked for
09:47:05 <Twey> Woah crap
09:47:13 <edwardk> newsham: no problem. the general idea is that you need to 'close' the CProp with a forall when you're all done building it up as CProp r a.
09:47:15 * Twey laughs.
09:47:17 <mmorrow> every stmt you enter gets its bytecode dumped first
09:47:18 <SamB> Twey: what ?
09:47:24 <Twey> Even -ddump-ds is a bit further than I meant :-P
09:47:40 <SamB> Twey: what did you mean then ?
09:47:44 <Twey> I thought it would just transform it to, y'know, braces and case statements
09:47:51 <newsham> edwardk: is that the only requirement that needs to be made when embedding?
09:47:53 <Twey> I'll parse this through, though :)  Thanks
09:47:54 <edwardk> newsham: because if you leave the CProp () a approximation that you are using in there right now then I can hand you that trivial Prop FALSE i mentioned
09:48:09 <mmorrow> Twey: in ghc, "desugaring" means transforming to Core
09:48:18 <Twey> Mmm
09:48:31 <mmorrow> (from HsSyn)
09:48:38 <pejo> Twey, http://haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html has all the flags.
09:48:52 <jdavis> pejo: ok, I'll have to do some more research then and I'll see if I can ask a more specific question. I think that my design (still designing) lends itself toward subtyping, but perhaps it's not required.
09:49:02 <SamB> mmorrow: it does ?
09:49:06 <SamB> huh
09:49:11 * SamB forgot
09:49:12 <mmorrow> yes
09:49:24 <SamB> we call that E.FromHs
09:49:49 <mmorrow> that reminds me, i've been meaning to look at the Grin AST
09:50:06 <SamB> it probably isn't documented too well at the moment
09:50:18 <mmorrow> the code is the documentation!
09:50:24 <mmorrow> :)
09:50:44 <SamB> sometimes it's good to know what you were TRYING to do
09:50:48 <Twey> pejo: Thanks :)
09:50:53 <SamB> sometimes it helps you to figure out why it isn't working
09:51:04 <SamB> sometimes it just makes you think "how stupid am I?"
09:51:27 <Olathe> The documentation is the code !
09:51:35 <edwardk> well, one way to make it suck less to use is to do what i do in there for the weirich/washburn stuff. then you'd replace your proposition type combinators with functors. data (a :/\ b) r = And (CProp r a) (CProp r b) and use some creative type definitions to let you combine them uniformly
09:51:36 <Olathe> That's what we need :)
09:51:40 <SamB> anyway, what about inter-modular interfaces ?
09:51:41 <mmorrow> SamB: sure, i'm just joking. but in my case i meant i've been meaning to look at the haskell data decls for Grin in {l,j}hc
09:51:48 <SamB> mmorrow: ah.
09:51:50 <edwardk> without having to mention the superfluous r terms
09:52:21 <SamB> feel free to file a bug if you can't understand anything
09:52:36 <SamB> it would please me muchly
09:52:38 <mmorrow> SamB: will do
09:53:31 <edwardk> basically what you need is that your entire classical expression needs to share an continuation result type r. then you can seal the expression by quantifying over r, so you know that the only inhabitants you are left with are ones that can work for any r.
09:53:52 <SamB> edwardk: reminds me of ST
09:54:01 <SamB> only without the magical primitives
09:55:16 <SamB> hmm, Haddock's synopsis isn't very synoptic
09:55:25 <SamB> http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/FrontEnd-HsSyn.html
09:56:34 <mmorrow> oh nice, lhc haddocks WITH source links
09:56:45 <mmorrow> haddock source links are key
09:57:18 <edwardk> samb: it is very much so the same idea, the universal quantification keeps you from doing bad things, just like with ST.
09:57:55 <mmorrow> SamB: is that url going to be valid for a while?
09:58:04 <andy_n> Quick question for emacs users: how can I pass a selection to a GHCi buffer (running in inf mode)?
09:59:11 <SamB> mmorrow: except while my computer is spontaneously rebooting, yeah ;-P
09:59:27 <mmorrow> SamB: cool
09:59:51 <mmorrow> i should just build my own haddocks..
09:59:53 <SamB> mmorrow: you could generate them too if you installed all our dependencies, including the HEAD versions of derive and haddock ...
10:00:01 <mmorrow> i do
10:00:27 <SamB> (the HEAD version of derive is only important for haddock)
10:01:08 <mmorrow> this is my current incantation of choice:
10:01:10 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
10:01:23 <SamB> what is the --html needed for ?
10:01:31 <mmorrow> probably unneeded
10:01:39 <SamB> oh, so you can get hoogle and html output maybe ?
10:01:52 * SamB should do that too
10:02:00 <mmorrow> but it's a placeholder for other options so i can keep the "--haddock-options" in there so i won't forget aboiut it
10:02:20 <mmorrow> the --hoogle flag just spits out <pkgname>.txt
10:02:33 <mmorrow> which you then have to hoogle --convert=<..>.txt
10:03:31 <mmorrow> speaking of that, here's hoogle output for ghc-6.11.about-a-month-ago:
10:03:52 <mmorrow> well, here're ghc haddocks with source links:
10:03:53 <mmorrow> http://moonpatio.com/docs/ghc/
10:03:58 <mmorrow> ghc-6.11.20090103
10:04:03 <mmorrow> and the hoogle file:
10:04:10 <mmorrow> http://moonpatio.com/docs/ghc/ghc.txt
10:04:37 <mmorrow> super handy
10:05:44 <SamB> for what ?
10:06:05 <mmorrow> for using hoogle with ghc src
10:06:15 <newsham> edwardk: you're suggesting "type Prop = forall a. CProp a" in place of the current "type Prop = CProp ()" ?
10:06:48 <SamB> oh, I guess that will be handy when I'm stealing their ideas
10:07:03 <SamB> mmorrow: they should build those for snapshots ...
10:08:26 <mmorrow> SamB: yeah, that would be super helpful if they did
10:08:50 <mmorrow> (in case anyone is wondering wtf to do with that ghc.txt)
10:08:57 <mmorrow> hoogle --convert=ghc.txt
10:09:04 <mmorrow> hoogle --data=ghc.hoo BCO  # e.g.
10:15:42 <CTA> Heyy, btw is lol :: (a, b) -> c               the same as lol :: a -> b -> c?
10:16:08 <glguy> you can use curry and uncurry to switch between the two
10:16:10 <glguy> :t curry
10:16:11 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:16:12 <glguy> :t uncurry
10:16:13 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:16:51 <CTA> so is what I said the same or? Just the first one is clearer than the second
10:16:57 <edwardk> newsham: to a gross simplification, yes. you can't define propCC on that type though, hence the more complicated machinery required to still work with excluded middle
10:17:13 <EvilTerran> CTA, they're not the same, but they're similar
10:17:35 <CTA> I mean, do they do the same thing?
10:17:36 <EvilTerran> if f :: (a,b) -> c, then you write "f (a,b)"; if f :: a -> b -> c, you write "f a b"
10:17:42 <EvilTerran> (when invoking f)
10:18:07 <CTA> do they do the same job, just to know for future use
10:18:13 <EvilTerran> they do very similar things in different ways
10:18:29 <ToRA> qq, is swapMVar(_) 'atomic' ?
10:18:32 <CTA> so wait.. is it best to do lol :: a -> b -> c or..?
10:18:38 <EvilTerran> "a -> b -> c" (or whatever) is the conventional way of writing it in haskell
10:18:55 <CTA> I'll do that then
10:18:55 <ToRA> sorry, i mean modifyMVar
10:19:15 <newsham> edwardk: this all is a little over my head.  I added a comment noting the deficiency in my article, and I'd like to address it, but I'm not sure I understand how to do it.
10:19:40 <newsham> the added comment right now "There's a problem here. If there's any fixed type such as "()" we can trivially come up with a contradiction by manually constructing "CProp (\k -> ()) :: Prop FALSE". I'm working on addressing this point."
10:19:52 <edwardk> the Prop = forall a. CProp a is isomorphic to Yoneda Identity, it is the same size as the Identity monad, which is the same size as Hask, so it doesn't have the power to implement callCC/propCC, hence why you have to work with 'r' open when you want to use the property of the excluded middle.
10:19:52 <CTA> so like I would do: add :: Int -> Int -> Int add x y = x + y ?
10:20:15 <EvilTerran> CTA, that looks right, yeah
10:20:34 <newsham> what kind of machinery do I need to be able to define exclMiddle and prohibit someone introducing inconsistency?
10:20:42 <newsham> could I just pick some uninhabited type instead of () ?
10:20:47 <Cheshire> exclMiddle ??
10:20:54 <newsham> cheshire: re: http://www.thenewsh.com/~newsham/formal/curryhoward/
10:20:57 <Cheshire> SML
10:21:22 <edwardk> think of it this way, CProp 's that share an 'r' can interfere with each other. if r is ever fixed to a single value you can always just substitute one you have lying around
10:21:43 <edwardk> when it is quantified over you have to proceed more honestly
10:21:52 <edwardk> but that prevents the double negation games
10:22:05 <newsham> do they interfere by merely sharing the same type, or does that shared type have to be inhabited?
10:22:28 <newsham> if I defined an uninhabited type and defined "type Prop = CProp Uninhabited" would that be a fix?
10:22:32 <augustss> newsham: did you try using djinn to generate the code you have on that page?
10:22:54 <edwardk> you could go one step further with this flawed approximation by making an empty type, but bottom still inhabits it. i'd argue that that is a closer-to-correct but still flawed model.
10:22:57 <newsham> augustss: I played with djinn a little while writing it, this was a while ago.
10:23:16 <newsham> edwardk: the article points out the presence of bottom ruins everything.
10:23:26 <newsham> see the first red comment towards the top.
10:23:27 <edwardk> newsham: sure.
10:23:34 <augustss> newsham: It got all of the first half, of course.  But in the continuation version it just cheats and implements everything with ()
10:23:55 <edwardk> yeah that was what i was pointing out. =)
10:24:35 <augustss> if you use Void instead of () you get weird code, not what you'd want.
10:25:01 <newsham> what if I declare    data Uninhabited = UninhabitedDontUseMe   and didnt export the constructor?
10:25:22 <newsham> slightly cheating but morally correct?
10:25:25 <edwardk> newsham: well if you're going there use EmptyDataDecls and just say data Void
10:25:32 <augustss> newsham: newtype Void = Void Void
10:25:38 <newsham> augustss just said Void gets weird code.
10:26:16 <augustss> newsham: afaik the only way for djinn to generate the right code for the continuation version is to leave r free
10:27:22 <newsham> i'm primarily interested in making the article accurate, the code having as few inconsistencies as possible, and as much as possible explaining how it works
10:27:25 <edwardk> newsham: and then come along afterwards and box it back up by quantifying over it. you can think of it as permitting classical reasoning while r is free and you can then reason intuitionstically about those closed classical universe boxes
10:27:45 <newsham> (btw, someone linked the article in from wikipedia so lots of peopel current view this description of c-h)
10:28:15 <Cheshire> I don't understadn why dyou haskell though
10:28:15 <newsham> edwardk: I dont understand.
10:28:54 <newsham> cheshire: i wrote it originally to understand how c-h worked and how it applied to haskell.
10:29:00 <edwardk> lets put it this way. the yoneda lemma says that 'forall b. (a -> b) -> f b'  is isomorphic to 'f a'  it has the same power as reasoning directly in Hask.
10:29:01 <newsham> i understand that haskell's type system is not sound
10:29:15 <Cheshire> I know you know that newsham, that's why I don't get that you used haskell :p
10:29:41 <edwardk> Yoneda Identity has no more power than reasoning with haskell types in the first place.
10:29:46 <newsham> cheshire: its still an important concept to know, even in haskell.
10:29:58 <Cheshire> it's useless in terms of haskell
10:30:14 <edwardk> On the other hand when you are living in a world of double negation, like Cont, you have the power to use the devil's bargain, which is valid in both intuitionistic and classical settings.
10:30:14 <EvilTerran> it's not useless, just less useful
10:30:15 <Cheshire> by that I mean there is no application
10:30:35 <SamB> Cheshire: them's fightin' words!
10:30:35 <edwardk> ~~a -> a isn't sound in hask, but ~~~a -> ~a IS.
10:30:45 <Cheshire> oh sorry
10:30:49 <SamB> someone is liable to come up with one just to prove you wrong ;-P
10:30:51 <newsham> I dont know what yoneda's lemma is and I dont understand the significance of "forall b. (a -> b) -> f b" being isomorphic to "f a"
10:30:58 <edwardk> callCC is basically using that to do its dirty work
10:31:09 <newsham> this is why I'm having a hard time following what you're saying
10:31:38 <SamB> Cheshire: (think fun fight, not flamewar fight ;-)
10:31:41 <edwardk> http://blog.sigfpe.com/2006/11/yoneda-lemma.html is homework for later, but i'll take a different tack ;)
10:31:49 <Cheshire> oh cool
10:32:02 <newsham> [08:30] < edwardk> ~~a -> a isn't sound in hask, but ~~~a -> ~a IS.
10:32:05 <newsham> ok, that made some sense to me
10:34:20 <edwardk> this is why you can generate classical 'proof' in Cont, because your goal is ~~a. so you can turn ~~~~a into ~~a. Its a bit bigger space than floating around in Hask.
10:34:34 <mmorrow> , src ''Yoneda
10:34:38 <lunabot>  newtype Yoneda f a = Yoneda {runYoneda :: (forall b . (a -> b) ->
10:34:38 <lunabot>                                                        f b)}
10:34:50 <SamB> yeah, all decent constructive logics are like that
10:34:53 <mmorrow> , 'Yoneda
10:34:54 <Cheshire> @src Handle
10:34:54 <lambdabot> Source not found. Wrong!  You cheating scum!
10:34:55 <lunabot>  Control.Functor.Yoneda.Yoneda
10:35:18 <Cheshire> you should see this article by CC Shan
10:35:34 <pumpkin_> yawn
10:35:50 <newsham> so, how do I fix my article?
10:35:59 <ddarius> Curses, djinn can't do higher rank types.
10:36:16 <pumpkin_> ncurses
10:36:16 <edwardk> its hard to do so without breaking a lot of the elegance of it
10:36:24 <mmorrow> ddarius: ddjinn?
10:36:35 <Cheshire> @go From shift and reset to polarized linear logic
10:36:36 <lambdabot> http://lambda-the-ultimate.org/node/756
10:36:36 <lambdabot> Title: From shift and reset to polarized linear logic | Lambda the Ultimate
10:36:53 <Cheshire> this is agood read on the subject
10:37:39 <newsham> if its hard to fix, is there a way I can just explain the inconsistency it introduces and how to avoid it?
10:37:42 <Cheshire> is this error ok:
10:37:42 <Cheshire>     Couldn't match expected type `Handle'
10:37:42 <Cheshire>            against inferred type `[Char]'
10:37:43 <Cheshire> ?
10:37:43 <dsrogers> how do I eliminate the warning "Defaulting the following constraint(s) to type `Integer'?
10:37:57 <Cheshire> dsrogers, try turing off monomorphism restriction
10:37:58 <ddarius> dsrogers: Put in an explicit type signature.
10:38:16 <edwardk> the approach i mentioned in the rotten bananas article lets you work with an unbound r while you are working classically and bind up the result by quantifying over it, to yield propositions that stand alone. you can reason about those intuitionistically. you can think of the quantification as the boundary for interference. just like ST uses it.
10:38:19 <newsham> I don't want to mislead people who are reading the article, but I also dont want to get into stuff that's too scary either.
10:38:20 <ddarius> Better yet, add 'default ()' under your import statements and fix all the type errors.
10:38:28 <mmorrow> Cheshire: um, what do you mean ok?
10:38:38 <Cheshire> newsham, what's the message of this article?
10:38:45 <mmorrow> (looks like you're s/foo/hFoo/)
10:39:09 <newsham> cheshire: explaining the correspondence between haskell programs and types and logic and proofs
10:39:15 <Cheshire> mmorrow, oh I see
10:39:18 <edwardk> the simplest fix is to just use 'data Void' instead of () and say 'don't put a bottom there!'
10:39:22 <Cheshire> newsham, but there isn't one
10:39:29 <edwardk> but thats a bit of a hack
10:39:31 <dsrogers> ddarius: so the function has a type signature.  The particular expression it's complaining about is "arising from a use of `^' "  do I need a type for the (^)?
10:39:32 <newsham> cheshire: yes there is.  its just inconsistent.
10:39:54 <Cheshire> newsham, why dont' you use system F ...
10:40:02 <Cheshire> it's an actual meaningful correspondance there
10:40:17 <Cheshire> (it could be System F with haskell syntax)
10:40:57 <newsham> cheshire: I didnt.  the article already exists.  *shrug*
10:41:04 <edwardk> newsham: the alternative i'm proposing just eliminates the use of a particular Void type and replaces it with universal quantification, so ultimately you can craft the same 'bad proposition'
10:41:18 <trez> 21.02.09 19:22:10 finns det ngot alls som kan f dig att trilla omkull?
10:41:18 <trez> 21.02.09 19:27:45 frsker du f mig p rygg?!
10:41:29 <newsham> edwardk: I understand the idea of using quantification.  whatI dont understand is how to unify that with things like exclMiddle
10:41:41 <ddarius> dsrogers: You need to fix the type somehow.
10:41:53 <Cheshire> dsrogers, did you try what I said
10:42:17 <dsrogers> ahh.  I think I get it.  The expression is 10^6 and that needs to pick a type...
10:42:20 <ddarius> edwardk: Using the Void type doesn't seem like a hack to me.
10:42:23 <edwardk> newsham: the idea is that while you are working with excluded middle you are working in CProp r a.
10:42:28 <ddarius> not a = a -> Void
10:42:57 <newsham> so basically all proofs using excl middle would have a slightly messier type signature that includes the extra type arg
10:42:59 <mmorrow> anyone know off-hand if Axman6 ever figure out how to convert Igloo's prog to new TH syntax?
10:43:01 <hackage> Uploaded to hackage: pointedlist 0.2
10:43:04 <mmorrow> *figured
10:43:23 <edwardk> newsham: yeah, which you could clean up with some creative type aliases. which was why i pointed you to my article
10:44:50 <Cheshire> dsrogers I guess I'm ignored or something thn
10:45:08 <dsrogers> Cheshire, I do'nt want to remove the monomorphism restriction.
10:45:30 <Cheshire> dsrogers, oh so you can hear me.. kinda makes me wonder like who I should try and offer advice to and who not when people ignore me
10:45:40 <Cheshire> dsrogers, something you can't know in advace though
10:45:45 <ddarius> Cheshire: The monomorphism restriction would have made no difference.
10:48:42 <edwardk> another thought would be to define newtype Prop a = Prop (Not (Not a)) -- with the Not having the forall b. a -> b or a -> Void interpretations.
10:48:55 <edwardk> er forall b. Prop a -> b
10:49:00 <glguy> Cheshire, his problem was probably something like x^2 where (^) :: (Num a, Integral b) => a -> b -> a, so there is nothing to force the "2" to a specific type
10:49:12 <newsham> ok, I updated the article to use Void and had a small description of why its using an uninhabited type.
10:49:24 <Cheshire> :t \x -> x^2
10:49:25 <lambdabot> forall a. (Num a) => a -> a
10:49:26 <redditbot> Compiling Haskell To LLVM
10:49:26 <redditbot> AVar released (three times)
10:49:26 <redditbot> Haskell Weekly News: February 21, 2009
10:49:32 <edwardk> that should have the right operational interpretation
10:49:43 <glguy> Cheshire, lambdabot doesn't have -Wall
10:49:49 <newsham> edwardk: thanks for pointing this out and the patience to explain the details to me.
10:49:51 <edwardk> and you can prove it up from ~~~a -> ~a
10:50:00 <Cheshire> @go Compiling Haskell To LLVM
10:50:01 <lambdabot> No Result Found.
10:50:39 <edwardk> newsham: not a problem. i really liked your article, i was just concerned with the fixing the return type of the continuation.
10:51:10 <Cheshire> I don't understand the point of view
10:51:10 <Heffalump> Cheshire: LHC plans to do that
10:51:13 <newsham> :: Prop False   seems like a pretty important concern :)
10:51:19 <edwardk> hah
10:51:19 <elandy_123> hi
10:51:31 <elandy_123>  http://codepad.org/Ncor5EA8 could you tell me why i get an error?
10:51:34 <dsrogers> if I have an orphan instance that I cannot practically unorphan, is the only solution to disable that warning?
10:51:39 <newsham> cheshire: thikn of it as a gateway drug.
10:51:40 <mmorrow> Heffalump: so now LHC _is_ going to use LLVM?
10:51:40 <elandy_123> in line 52
10:51:56 <Cheshire> how appropriate since Haskell is named after Haskell Curry, the "Curry" in "Curry-Howard"
10:52:45 <edwardk> so the data Prop a = Prop (Not (Not a)) and type Prop = CProp Void  interpretations should be basically equivalent, it all depends on how you want to become classical.
10:53:17 <Cheshire> newsham don't you mention that  data  decls have to be strictly positive too
10:53:37 <newsham> I dont.  what does "strictly positive" mean?
10:53:54 <Heffalump> mmorrow: yep
10:54:05 <mmorrow> i think ehc plans to use LLVM, but from what i've seen ehc has no garbage collector or rts to speak of really atm
10:54:34 <elandy_123>  http://codepad.org/Ncor5EA8 could you tell me why i get an error in line 52?
10:55:11 <Cale> elandy_123: indentation
10:55:12 <newsham> oh, thats one of the thing edwardk's article was talking about.
10:55:24 <edwardk> newsham: positive occurrences occur on the left hand side of an even # of ->'s
10:55:27 <Cale> elandy_123: You should ensure there are never any tab characters in your Haskell source files.
10:55:35 <mmorrow> Heffalump: do you have a link/source for that? i haven't heard/seen that
10:55:43 <Cale> elandy_123: Most decent editors can be configured to convert them to spaces for you automatically.
10:55:44 <sjanssen> elandy_123: do you have your tabs set to display less than 8 characters?
10:56:18 <elandy_123> yes
10:56:24 <sjanssen> elandy_123: don't do that
10:56:37 <Cale> The Haskell compiler will always treat tabs as aligning to the nearest 8-space boundary, but it's safer just to ensure there are never any tabs.
10:56:43 <newsham> so if you have a datatype that isnt strictly positive it can also lead to logical inconsistencies?
10:56:52 <mmorrow> Heffalump: (in fact, i thought that LHC was _not_ going to use LLVM)
10:57:18 <Cheshire> the question is now:  What else have we forgotten?
10:57:23 <newsham> yes
10:57:25 <edwardk> newsham: http://books.google.com/books?id=jfxBvmH9ZcwC&pg=PA343&lpg=PA343&dq=weak+positivity+condition+coq&source=bl&ots=hWwTul_9V1&sig=XbMMScEiYI9N2cGg5__Za5isjHs&hl=en&ei=YE6gSZOUFZPHtgeO4PGEDQ&sa=X&oi=book_result&resnum=3&ct=result#PPA340,M1 probably won't work but i'll try pasting it anyways, look on p340 ;)
10:58:00 <Cale> If you use vim, then the expandtab and smarttab options are what you want to set.
10:58:13 <elandy_123> i use notepad++, how can i delete all the tabs?
10:58:13 <newsham> url works
10:58:56 <Cale> I'd have to look at the documentation... see if there's an option to convert tabs to spaces.
10:59:27 <newsham> you could write a haskell program to retab :)
10:59:30 <skorpan> in notepad++ that's a checkbox away
10:59:47 <skorpan> iirc it's in some toplevel menu
10:59:47 <glguy> notepad++ is a weird way to write "vim" ;)
11:00:07 <sjanssen> notepad--
11:00:13 <sjanssen> notepad--
11:00:16 <sjanssen> notepad--
11:00:27 <Cale> hehe
11:00:29 <sjanssen> @karma notepad
11:00:29 <lambdabot> notepad has a karma of 19
11:00:32 <sjanssen> yikes!
11:00:37 <skorpan> @karma emacs
11:00:37 <lambdabot> emacs has a karma of 1
11:00:38 <Cale> hehehe
11:00:40 <skorpan> what the...
11:00:44 <sjanssen> @karma vim
11:00:44 <lambdabot> vim has a karma of 4
11:00:45 <skorpan> @karma yi
11:00:45 <lambdabot> yi has a karma of 2
11:00:49 <Cheshire> emacs-- painful to use
11:00:55 <Cale> skorpan: It's because there's an editor called notepad++
11:00:55 <mmorrow> yi++
11:01:10 <skorpan> [20:00] <fsbot> We aren't gonna lie. Emacs sucks. Some of us tolerate it, but we can't tell you if YOU'LL be able to. Try it and make up your own mind.
11:01:12 <mmorrow> notepad--
11:01:36 <mmorrow> @karma c
11:01:36 <lambdabot> c has a karma of 0
11:01:48 <skorpan> @karma skorpan
11:01:48 <lambdabot> You have a karma of 1
11:01:48 <Deewiant> preflex: karma c
11:01:49 <preflex>  c: 65020
11:01:49 <mmorrow> @karma php
11:01:50 <lambdabot> php has a karma of 0
11:01:56 <newsham> emacs: the crippled lispmachine that outlived them all
11:02:01 <mmorrow> lol preflex
11:02:30 <mmorrow> preflex: karma c++
11:02:31 <preflex>  c++: -29
11:02:34 <mmorrow> lol
11:02:59 <mmorrow> preflex++
11:03:05 <sjanssen> lambdabot has workarounds specifically for C
11:03:10 <sjanssen> and C++
11:03:13 <newsham> edwardk: what branch of study do the concepts in yoru blog post come from?  are those from category theory?
11:03:16 <elandy_123> done
11:03:29 <elandy_123> i checked the box to show all the characters and deleted it
11:04:05 <edwardk> newsham: the kan extension, yoneda lemma stuff is all category theory. the morphism stuff is 'constructive algorithmics' as i believe the squiggol folks like to call it.
11:04:12 * mmorrow likes spaces and tabs to be visible
11:04:28 <edwardk> which is really just a branch of category theory
11:04:45 <mmorrow> which makes reading code with a bunch or errant spaces/tabs extremely painful (as it should be!! :)
11:05:01 <elandy_123> http://codepad.org/RznZPqdG now it runs, but doesn't evaluate the expression correctly
11:05:07 <newsham> is constructive algorithmics related to constructive logic?
11:05:28 <edwardk> not really.
11:05:43 <elandy_123> i think the error is in the crearArbol function
11:05:50 <edwardk> its mostly about how to compose programs in a more logical way using combinators rather than ad-hoc recursion
11:06:00 <mmorrow> edwardk: what exactly is squiggol?? does any trace of it actually still exist?
11:06:06 <monochrom> tabs are problematic because different programmers "customize" them to different widths in their editors. (Programmers are such customization whores, if editors let them "customize" the meaning of space, they would use it!)
11:06:09 * mmorrow has looked 
11:06:28 <newsham> ty, i gotta bunch of homework to do it seems
11:06:34 <edwardk> mmorrow: its a semi-joking term uses to refer to a school of thought by richard bird and lambert meertens
11:06:43 <AllNight^> skorpan - what can we do to make emacs suck less?
11:06:45 <AllNight^> :)
11:06:50 * AllNight^ open to suggestions!
11:07:05 <mmorrow> edwardk: ahhh. i started to figure something along those lines.
11:07:18 <mmorrow> as in, it doesn't and never did exist as a programming lang
11:07:20 <Cale> elandy_123: Just so you know, there are still tabs in it...
11:07:28 <edwardk> mmorrow: its not actually a concrete language. a lot of birds old papers used to use a consistent set of notation which was later evolved into the foomorphism stuff by erik meijer and company
11:07:50 <mmorrow> edwardk: interesting. i've been wondering about this for a while now
11:07:57 <skorpan> AllNight^: don't worry, i'm a hardcore (f*ck yeah) emacs user, i don't have any complaints!
11:08:16 <wli> Squiggol was referred to as a language in FP with Bananas, Lenses, Envelopes, and Barbed WIre.
11:08:23 <edwardk> i had an opportunity to talk to erik meijer and tarmo uustalu about it on separate occasions a few months back.
11:08:29 <Cale> elandy_123: The explicit semicolons are preventing it from being a problem for the moment though :)
11:08:37 <mmorrow> sed -r 's/\t/        /g'
11:08:42 <AllNight^> skorpan - so am I - but I still think there's scope for improvement ... I'd like support for multi-threading for starters...
11:08:51 <AllNight^> and can we please have a nicer language than elisp? (Haskell?)
11:08:51 <AllNight^> :)
11:08:56 <edwardk> er erik meijer re squiggol and uustalu about the evolution of the whole grecomorphism thing ;)
11:08:57 <mmorrow> yi++
11:09:01 <AllNight^> seriously elisp is _old_ & it shows
11:09:03 <monochrom> emacs doesn't suck.
11:09:06 <elandy_123>  http://codepad.org/UHS9HKLV i think now i erased all of them
11:09:10 <elandy_123> *deleted
11:09:12 <mmorrow> heh, grecomorphism
11:09:33 <edwardk> you can blame the foomorphism convention on lambert meertens
11:09:38 <Cale> elandy_123: yeah, that's better. :)
11:10:10 <Cale> elandy_123: You'll also want to set it so that it enters an appropriate number of spaces when you press tab
11:10:18 <mmorrow> which is 8
11:10:25 * monochrom considers to begin using "it's all English to me" to derogatorily refer to vague/meaningless speak.
11:10:26 <edwardk> http://www.kestrel.edu/home/people/meertens/diverse/calc.pdf might be informative
11:10:29 <elandy_123> but the crearArbol function doesn't correctly creates the evaluation tree
11:10:45 <mmorrow> well, actually you can have it insert however many spaces you want
11:10:52 <Cale> elandy_123: okay
11:11:13 <mmorrow> but when converting haskell code that uses tabs to code with spaces, you *need* to map \t to 8 spaces or else you'll get errors
11:11:53 <edwardk> both in the mindset of the squiggol formalism and to see his penchant for er.. lingua obscura
11:11:56 <elandy_123> yes, i set the tab to 8 spaces in preferences dialog
11:11:58 <bremner> monochrom: it's all Haskell to me...
11:12:04 <monochrom> unixes have "expand" program to convert tabs to spaces correctly. don't do it manually.
11:12:27 <monochrom> Neural networks are not to be trusted.
11:12:53 <mmorrow> does expand always insert 8 spaces for tabs?
11:12:53 <Cale> elandy_123: Well, one strange thing is that you're parsing numbers in reverse.
11:13:17 <wli> It's not precisely 8 spaces. It's 8 column tabstops.
11:13:22 <monochrom> expand doesn't replace every tab by 8 spaces. that is part of its correctness!
11:13:37 <monochrom> and what wli says.
11:13:39 <mmorrow> monochrom: the haskell layout rules specify tab:=8 spaces
11:13:53 <Cale> mmorrow: Not quite
11:13:56 <monochrom> No, haskell says what wli says, too.
11:14:05 <Cale> mmorrow: It says that a tab aligns to the next multiple of 8 spaces.
11:14:06 <elandy_123> and what does that mean?
11:14:06 <mmorrow> iirc it ways that exactly, but i may not recall correctly
11:14:13 <mmorrow> Cale: ahh
11:14:23 <newsham> I see HWEB thing on the haskell weekly news.  whats the reason for this vs. existing .lhs type programming?
11:14:55 <mmorrow> so then i take it that that's what "expand" does?
11:15:08 <edwardk> @djinn Not (Not (Not a) -> Not a
11:15:09 <lambdabot> Cannot parse command
11:15:21 <elandy_123> http://codepad.org/UHS9HKLV
11:15:22 <wli> Tabstops are set at various columns. A tab character is a command to seek right to the nearest tabstop. If you're sitting at a tabstop, you move one tabstop over to the right.
11:15:23 <edwardk> @djinn Not (Not (Not a)) -> Not a
11:15:23 <lambdabot> f a b = void (a (\ c -> c b))
11:15:25 <edwardk> better =)
11:15:54 <wli> It is, in effect, not a printable character per se.
11:16:07 <mmorrow> wli: hmm. so i'm confused as to whether that is or isn't consistent with the layout rules for tabs->spaces
11:16:08 <wli> It's a cursor motion command.
11:16:17 <wli> mmorrow: It is consistent.
11:16:21 <mmorrow> ok. :)
11:16:35 <Cale> I think hard tab characters should just be treated as a lexical error.
11:16:36 * mmorrow uses expand from now on 
11:16:47 <edwardk> nextTab x = x + (8 - (x-1) `mod` 8)
11:16:57 <Cale> There's no good reason for them to occur in source files.
11:16:58 <monochrom> Section 9.3. "Tab stops are 8 characters apart." Note this does not mean 1 tab character to 8 space characters! It's talking about tab stops. Next statement: "A tab character causes the insertion of enough spaces to align the current position with the next tab stop."
11:16:58 <mmorrow> Cale: i wouldn't lose any sleep if that was the case
11:16:58 <elandy_123> crearArbol should be recursive, but its called only once
11:17:31 <mmorrow> monochrom: yes, we just cleared that up
11:17:49 <monochrom> mmorrow: I'm talking to Mr. Speaker.
11:18:09 <wli> Yeah, the cursor motion is implemented by filling with space characters when dealing with files. Terminals (or typewriters) may have other ways of accomplishing it.
11:18:50 <mmorrow> monochrom: did you forget to take your schizophrenia meds this morning? ;)
11:19:04 <Cale> *Main> crearArbol "16+9"
11:19:04 <Cale> (Hoja 61,"+9")
11:19:18 <Cale> elandy_123: There appear to be a number of issues here :)
11:19:37 <elandy_123> oops
11:19:40 <elandy_123> let me see
11:20:05 <edwardk> newsham: one last way you could keep anyone from slipping you a CProp (const ()) is by just not exporting the CProp constructor from your newtype ;)
11:20:18 <monochrom> mmorrow: I take that as an insult.
11:20:20 <Cale> also try  crearArbol "15"  which gives a non-exhaustive patterns in obtenerNumero' error.
11:20:28 * wli would keep an ordered set of programmable tabstops around.
11:20:29 <edwardk> then propCC return and bind would be the only tools for constructing them
11:20:57 <mmorrow> monochrom: i'm insulted that you're insulted.
11:21:16 <newsham> [08:24] < newsham> what if I declare    data Uninhabited = UninhabitedDontUseMe and didnt export the constructor?
11:21:18 <Cheshire> hi
11:21:34 <edwardk> newsham: not for Void, but for CProp itself
11:21:37 <Cale> mmorrow: I'm insulted that you're insulted that he's insulted!
11:21:38 <newsham> ahh, you were saying for CProp
11:21:39 <newsham> yah
11:21:55 <mmorrow> Cale: oh you've done it now!
11:23:13 <newsham> edwardk: that kinda feels like cheating though -- ie "my module could (if it wanted to) do illegal stuff, but yours cant"
11:23:25 <newsham> similar feel to   exclMiddle = undefined
11:23:35 <newsham> axiom!
11:23:37 <elandy_123> Cale: crearArbol "15" doesn't work because "15" is not well-formed
11:23:51 <elandy_123> Cale: it must have at least one operator
11:24:03 <Cheshire> it's all cheating and deciet
11:24:19 <newsham> I know, i'm living in sin.
11:24:28 <wli> nextTabStop = do tsSet <- gets tabstops ; col <- gets column ; let (before, after) = split column tsSet in return $ minView after
11:24:33 <edwardk> newsham: thats why i like the Prop a = Not (Not a) formulation. then again i like that version mostly because thats how i think about classical logic. ;)
11:24:50 <Cheshire> I think about classical logic in terms of truth tables
11:24:59 <wli> s/split column tsSet/split col tsSet/
11:25:00 <newsham> edwardk: I like it a lot too.  perhaps if I get a chance to rewrite this article at some point I'll do it better going that way.
11:25:03 <Cheshire> evaluating formuales and such
11:25:31 <elandy_123> solved the reverse numbers issue
11:25:45 <Cheshire> and then int. logic in terms of bijections and so on
11:25:56 <elandy_123> code pasted here: http://codepad.org/ymbJOHCM
11:26:00 <wli> Tabstops aren't required to be set at regular intervals.
11:26:30 <wli> Oh, I better use splitMember
11:26:38 <elandy_123> but still, crearArbol is called once, when it should be recursive
11:26:48 <edwardk> newsham: other fun ways to play are to think about Peirce's law.
11:26:57 <edwardk> and other equivalent formulations
11:27:51 <wli> nextTabStop = do tsSet <- gets tabstops ; col <- gets column ; let (before, atTS, after) = splitMember col tsSet in return . fmap fst $ minView after
11:27:52 <edwardk> which is basically callcc
11:29:26 <wli> keeping close tabs
11:29:53 <newsham> i closed my tab
11:30:54 <wli> Usually things programmed into a tty/pty are slow (or impossible) to query, so things like ncurses cache the programmed settings i.e. tty/pty state.
11:32:54 <elandy_123> can you help me with the definition of crearArbol?
11:33:08 <skorpan> where can i read more about `many'? i don't get it.
11:33:56 <ddarius> skorpan: Which 'many'?
11:34:06 <pumpkin_> the one from parsec?
11:34:21 <skorpan> yeah i just noticed there are many `many', i mean Control.Applicative i *think*
11:34:32 <monochrom> hahaha
11:34:59 <monochrom> @remember skorpan i just noticed there are many `many'
11:34:59 <lambdabot> It is stored.
11:35:26 <skorpan> :)
11:35:46 <Cheshire> surely there is more info about typed generic programming than like .. 3 research papers
11:35:46 <Cheshire> ?
11:37:34 <skorpan> okay, i'm fairly sure i mean Control.Applicative.many. where can i read more about it?
11:38:04 <skorpan> "zero or more" tells me very little
11:38:09 <ddarius> Possibly the idiom paper.
11:38:18 <skorpan> For more details, see Applicative Programming with Effects, by Conor McBride and Ross Paterson, online at http://www.soi.city.ac.uk/~ross/papers/Applicative.html.
11:38:21 <skorpan> i should rtfm more often
11:38:47 <ddarius> skorpan: It seems only useful for "parser-like" Applicatives (where it is more or less the same as, e.g. Parsec's many)
11:39:08 <skorpan> ddarius: this is indeed used in parsing
11:40:00 <pilkarn> http://sob.apotheon.org/?p=935
11:40:10 <pilkarn> ^^ did OOP do this to us?
11:41:51 <pilkarn> anyway, can someone help me clear out my thoughts. I find that largely that fucntional vs OOP is flat vs hierarchical architecture. functional programming goes one step further in modularity and decouples methods from types/structures( or more exactly doesnt add them in the first place).
11:43:44 <pilkarn> im currently working on a Java-game for the Android(started with it in Scheme but just very slightly). this will be an interestin exercise because I will write a game in a functional language too and then I will see the difference. games are good because they incorporate  a lot of different stuff and do have a lot of state(at least how they are traditionally made).
11:47:32 <elandy_123> what is the name of what my program do? is it a parser?
11:47:58 <monochrom> Yes, I think so.
11:49:26 <redditbot> Lemmih: LHC - past, present and future
11:49:26 <redditbot> ASTM updates
11:51:58 <jamii> pilkarn: Snap. I just started planning a game too.
11:51:58 <lambdabot> jamii: You have 1 new message. '/msg lambdabot @messages' to read it.
11:52:25 <jamii> @seen conal
11:52:26 <lambdabot> conal is in #haskell, #ghc and #haskell-in-depth. I last heard conal speak 2h 21m 4s ago.
11:52:28 <byorgey> elandy_123: in the definition of 'isOp', note that instead of 'if blah then True else False' you can just write 'blah'
11:52:46 <conal> jamii: hi
11:53:02 <jamii> conal: Ive been wrestling with the associated types all day
11:53:07 <byorgey> elandy_123: (c=='+') || (c=='*') is already a Bool
11:53:15 <conal> jamii: oh?
11:53:24 <elandy_123> yeah.. that was redundant
11:53:40 <jamii> The problem is that Basis is a type rather than data - so I cant do something like HasFiniteBasis v where basis :: [Basis v]
11:53:52 <elandy_123> the problem is crearArbol, i f***ed up with the tuples
11:54:06 <conal> jamii: why not?
11:54:08 <jamii> The worst thing is it doesnt tell you that when you define the class, it just causes really obscure type errors further down the line
11:54:37 <jamii> conal: Because two vector spaces might have the same type of basis element, so basis is ambiguous
11:54:52 <conal> jamii: that part i get.
11:55:27 <jamii> Hang on, Ill chuck the offending code into hpaste
11:55:28 <conal> jamii: for that reason, i'm changing linear maps to a newtype.
11:55:32 <conal> k
11:55:48 <byorgey> elandy_123: what's the problem?  do you get a type error, or it compiles but just doesn't work?
11:55:53 <jamii> conal: A newtype for basis would be more useful
11:56:01 <SamB> is there an hpaste "API"?
11:56:08 <conal> jamii: it eliminate ambiguity during type-checking.
11:56:22 <conal> jamii: for the reason you said: Basis needn't be injective.
11:57:00 <newsham> byorgey: great job on getting hwn out pretty regularly even when you've got lots of other work to do.
11:57:14 <conal> jamii: so you could use [Basis v], but solving [Basis u] == [Basis u'] does not imply u == u'
11:57:30 <elandy_123> byorgey: it compiles, but doesn't evaluate the expression correctly
11:57:39 <byorgey> newsham: thanks.  dunno how long I'll be able to keep it up, but for now it's not too bad.
11:58:00 <conal> jamii: i didn't get that until manuel tweeted me yesterday.
11:58:10 <elandy_123> byorgey: the crearArbol should create the expression tree recursively, but its just called once
11:58:21 <elandy_123> crearArbol = createTree
11:58:23 <byorgey> elandy_123: what is an example of a String it does not correctly process?
11:58:29 <jamii> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1609#a1609
11:58:40 <elandy_123> "3+4*5"
11:58:44 * conal looks
11:59:06 <byorgey> elandy_123: well, crearArbol seems to expect expressions to begin with a (
11:59:09 <ddarius> conal: Have you seen the LtU post on your draft?
11:59:26 <jamii> conal: If you stick gradient in ghci, get the inferred type and then stick it back in it doesnt typecheck. Head-desk moments all round
11:59:26 <byorgey> elandy_123: note the only case in which it actually creates a Nodo is if x == '('
11:59:46 <conal> jamii: are you on twitter?
11:59:57 <elandy_123> the '(' case is just one case
12:00:10 <jamii> conal: No. Can be, no effort
12:00:12 <murocan> Enter text here...
12:00:26 <byorgey> elandy_123: does it work if you give it "((3+4)*5)"?
12:00:43 <conal> jamii: http://hackage.haskell.org/trac/ghc/ticket/1897
12:01:22 <elandy_123> oops
12:01:23 <elandy_123> it worked
12:02:03 <conal> jamii: especially http://www.haskell.org/pipermail/haskell-cafe/2008-April/041397.html
12:02:26 <elandy_123> but what if i want to evaluate "2+2" ?
12:02:33 <jamii> conal: Yeah, I have the same problem upgrading gmap. Can get everything to typecheck except the testsuite, so I dont know if I did it right yet
12:04:00 <jamii> conal: But even without that there is a problem. recompose' f = recompose (zip basis $ map f basis). here the output vector is well defined but basis can be anything with the same Basis type
12:04:47 <jamii> ie if Basis u == Basis v then: recompose (zip (basis :: [Basis u]) $ map f (basis :: [Basis v])) is a possible
12:04:48 <conal> hm.  yeah.
12:06:09 <byorgey> elandy_123: it's much more complicated if you want to make the parentheses optional.
12:06:10 <jamii> I tried taking Basis out altogether and just returning vectors with type Basis v = v but I didnt like it. I think newtype is the way forward, annoying as it is
12:06:44 <conal> jamii: hm.  i guess my making :-* a newtype just avoids *one* symptom of this problem.
12:06:48 <byorgey> elandy_123: at some point it would make sense to use a standard parsing library like Parsec instead of writing your own parser from scratch.
12:06:56 <conal> jamii: i also started converting Basis to an associated data type.
12:07:23 <conal> jamii: it not only got ugly, but also broke memoizability
12:08:14 <jamii> conal: Howso? I havent really looked at memotrie.
12:08:59 <conal> jamii: the Basis definitions use familiar types: (), pairs & sums.  all memoizable.
12:09:09 <monochrom> Eh? The HWN is early this time!
12:09:14 <jamii> conal: I got so frustrated with the AT bugs I started learning ocaml instead! I came back here to complain about how dead the ocaml room was :-)
12:09:31 <jamii> conal: I see - you would have to declare HasTrie for every Basis
12:09:36 <jamii> conal: That would suck
12:09:40 <conal> jamii: exactly.
12:09:49 <conal> jamii: and they're all derivable.
12:10:05 <byorgey> monochrom: define "early"?
12:10:24 <monochrom> earlier than past averaging
12:10:26 <jamii> conal: Dependent types wouldnt solve the problem with basis :: [Basis v]
12:10:30 <conal> jamii: but i don't think "deriving" works in an associated data type.  will try again...
12:10:31 <monochrom> s/averaging/average/
12:11:02 <elandy_123> thanks for the help!
12:11:11 <jamii> conal: If it doesnt you can probably just make a data family instead? I dont know if it would be treated differently...
12:11:28 <byorgey> monochrom: heh, I don't know what the average is, I just do it "sometime on Saturday"
12:11:33 <sjanssen> jamii: what version of GHC were you using when you had trouble with type families?
12:11:36 <jamii> conal: This is what comes from having too much magic in the language.
12:11:44 <conal> jamii: hm.  didn't think of that.  i've never tried them.
12:11:48 <jamii> sjanssen: Latest stable version, as of this morning
12:12:23 <jamii> sjanssen: Was a bit shocked, I thought they were more or less stable now. I still cant get them to work in gmap either.
12:12:24 <sjanssen> jamii: 6.10.1?  I ask because the version still in many Linux distributions (6.8) is very bad wrt. type families
12:13:11 <jamii> sjanssen: ghc-6.10.1.20090220. I gave up on the packaged version a long time ago :-)
12:13:35 * wli has no clue what's going on with type families or what a type family is.
12:14:53 <jamii> sjanssen: Havent tried Head though. Not worth the hassle switching just to get this working
12:15:57 <sjanssen> wli: they perform many of the same tasks as functional dependencies, but are much nicer (in my opinion)
12:16:54 <jamii> wli: Believe me, you are so much better off that way. Theyre so close to working it maddening...
12:16:59 <jamii> *its maddening
12:17:17 <conal> jamii: have you actually found any AT bugs?  or maybe you mean bugs in your code due to ambiguity?
12:17:26 <conal> jamii: there sure were bugs earlier.
12:17:55 <jamii> sjanssen: Much nicer. With DT gmap has type signatures exponential in the level of nesting 8)
12:18:17 <Cheshire> jamaii, what's DT?
12:19:06 <jamii> conal: Refusing to typecheck when supplied with the ghci inferred type. The rest I can put down to ambiguity (and bad error messages)
12:19:16 <jamii> Cheshire: Dependent Types
12:19:38 <jamii> Cheshire: I had a moment of abbrevieamania. Im much better now
12:19:49 <conal> jamii: yeah.
12:19:50 <Cheshire> jamii, in that case why don't you compute the exponential type from the informative content?
12:20:14 <mae> what is the point of XMLMetaData for HSP pages
12:20:18 <jamii> Cheshire: Because the type is used to control the behaviour of the map
12:20:39 <Cheshire> jamii, do you have some code so that I can see clearly what you mean?
12:21:20 <jamii> Cheshire: eg fromAssocs xs :: OrdMap [Int] Int     vs    fromAssocs xs :: CacheKeys (Trie IntMap Int Int)
12:21:56 * jeffwheeler just found Text.Show.Functions
12:22:08 <jamii> Cheshire: Check out the gmap package on hackage
12:22:21 <Cheshire> @hackage gmap
12:22:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gmap
12:23:23 <pumpkin_> dons: what does BUArr stand for btw?
12:23:34 <Cheshire> jamii, ok and I'm curious what dependent types have to do with it
12:24:06 <dons> ByteArray#
12:24:10 <dons>  Unboxed Array
12:24:59 <jamii> Cheshire: Hang on, let me go find an example
12:25:48 <jamii> So the main class is : class Eq k => Map map k | map -> k
12:26:35 <jamii> Heres a typical instance for Sum types.
12:26:37 <jamii> Choice2Map mapL mapR kL kR a
12:26:48 <jamii> (Map mapL kL, Map mapR kR) => Functor (Choice2Map mapL mapR kL kR)
12:26:52 <jamii> oops
12:27:05 <jamii> instance (Map mapL kL, Map mapR kR) => Map (Choice2Map mapL mapR kL kR) (Choice2 kL kR)
12:27:15 <Cheshire> jamii, is the idea of having these various maps so that one could build a map corresponding to any ADT?
12:28:04 <Cheshire> (structurally corresponding, not literally corresponding)
12:28:08 <jamii> Cheshire: Yep. Also you can swap in specialised maps, like the really fast IntMap that Adrian Hey wrote. Or have map transformers like CacheKeys that affect how the map behaves
12:28:21 <Cheshire> ok
12:28:38 <Cheshire> (sorry to interrupt just wanted to check I was following)
12:28:43 <pumpkin_> @hoogle flushWriteBuffer
12:28:43 <lambdabot> No results found
12:29:14 <jamii> So the above instance was with dependent types. Notice how Choice2Map needs to have kL and kR in its type even though they can be inferred from mapL and mapR
12:29:40 <jamii> Its the only way to convince ghc that its not breaking the dependency mp->k
12:30:05 <jamii> With associated types all the code is the same but the map transformer looks like
12:30:12 <Viking667> yo. How many programs are out there that are coded with Haskell at the moment?
12:30:15 <pumpkin_> anyone know much about flushWriteBuffer?
12:30:30 <Viking667> i.e. editors, web browsers, music players, etc?
12:30:42 <jamii> data Choice2Map mapL mapR a
12:31:04 <jamii> instance (Map mapL, Map mapR) => Map (Choice2Map mapL mapR) where
12:31:05 <jamii> 	type Key (Choice2Map mapL mapR) = Choice2 (Key mapL) (Key mapR)
12:31:25 <Cheshire> ok
12:31:42 <jamii> We can keep the key types out of the map. Not a big deal for just one transformer but if you want to build up a complicated type you have to repeat the key type at every level
12:31:58 <jamii> And the types of the keys themselves are getting longer
12:32:00 <pejo> Viking, there's a list on haskell.org, and you can browse hackage.haskell.org.
12:32:19 <Cheshire> and the moral is,  type families are useful ?
12:32:41 <Cheshire> jamii, I think this is linear increase in size though, not exponential
12:32:50 <Cheshire> or is it ...
12:33:00 <Cheshire> jamii, maybe it is quadratic
12:34:08 <Viking667> pejo: thank you. I'll go have a browse.
12:34:16 <pilkarn> is there a xbox dev channel?
12:34:27 <dufflebunk> I have a program which outputs <<loop>>. Does anyone have any suggestions on how to track down what the loop is?
12:34:30 <pilkarn> what do you guys think of fsharp? im thinking of using it for xboxdeving
12:34:35 <jamii> Cheshire: Hmmm. It is quadratic. I thought size of key type ~ nesting level and jumped straight to exponential
12:35:04 <dufflebunk> Since I didn't tell it to print "<<loop>>" I'm assuming it's some error message ghc put in there.
12:35:26 <jamii> Cheshire: Expanded over 10k lines of code it starts to feel exponential :-)
12:36:26 * Cheshire yucks at http://www.haskell.org/haskellwiki/The_Monad.Reader/Previous_issues
12:36:32 <jamii> Anyway, I was busy jumping ship to ocaml. I should get back to that
12:36:45 <Cheshire> someone should swizzle names/titles on The Monad.Reader Issue 11
12:37:08 <jamii> Conal: jamiiecb on twitter
12:38:37 <conal> jamii: thx.
12:39:51 * Viking667 gets the impression haskell mainly gets used in back-end programs/libraries/the-like... just from perusal of the first nine sections of hackage...
12:39:54 <jamii> Not that I really know what to do with it
12:40:29 <conal> jamii: hm.  not seeing jamiiecb on twitter.
12:40:36 <roconnor> Viking667: I'm not sure about that.  I usually write libs, and just use ghci :)
12:41:01 <jamii> conal: Maybe it will take a while? I just registered
12:41:01 <pejo> Viking, does window managers and compilers count as frontend programs?
12:41:27 <jamii> Wow. There are so many twitter clients for android. Anyone know a good one?
12:42:01 <conal> jamii: oh, okay.  meanwhile, i'm http://twitter.com/conal.  you can find some other haskellers in my following list
12:42:36 <Viking667> lol. More twitterererers here.
12:43:11 <conal> i'm enjoying TweetDeck's continuous search feature.
12:43:20 * pumpkin_ is getting his hands dirty deep in the guts of uvector :P
12:44:38 <pumpkin_> we need a wiki page for haskellers on twitter
12:44:56 <pumpkin_> there was a blog post but there's no reason we should have to go through a third party to let the world know we tweet about haskell
12:44:59 * monochrom is not on twitter. purist.
12:45:01 <conal> pumpkin_: good idea
12:45:48 * jamii was not on twitter. lazy
12:45:56 <conal> pumpkin_: it could start as a copy of the info in bos's post plus a broadcast invitation for people to add themselves.
12:46:00 <pumpkin_> "MutableByteArray# RealWorld" scares me
12:46:09 <pumpkin_> conal: that seems reasonable
12:46:55 <pumpkin_> I can set up a page on the haskell wiki if you want
12:47:05 <pumpkin_> unless you're already doing it :)
12:47:06 <Viking667> "haskell" wiki?
12:47:17 <conal> pumpkin_: would you, please.
12:47:18 <monochrom> www.haskell.org is using wiki
12:47:27 <conal> pumpkin_: i still have my dose buried in writing
12:47:42 <pumpkin_> your dose! do you have a cold?
12:48:03 <conal> oh!  i did say that.  heh
12:48:15 <conal> strange typo.
12:48:34 <jamii> Wow. I already forgot my twitter password. Thats a new low
12:48:39 <pumpkin_> oh no :P
12:48:52 <monochrom> what is with facebook? what is with twitter?
12:48:54 <Viking667> Right. I've got a package from hackage, to be installed presumably into the ghc collection. How does Cabal work?
12:49:09 <Viking667> I also have hugs98
12:49:27 <redditbot> Simplifying code
12:49:27 <redditbot> AVar released (three times) - Data.Random
12:49:30 <pumpkin_> what is with purist programmers being all nonconformist for the sake of nonconformity and calling facebook/twitter "back in my day we didn't have any of these newfangled 'social' sites"
12:49:30 <jpcooper> bloody Twitter
12:49:32 <pumpkin_> :P
12:49:40 <jpcooper> but seriously
12:49:43 <jpcooper> do you REALLY need it?
12:49:49 <jpcooper> does anyone REALLY care?
12:49:51 <pumpkin_> jpcooper: do you REALLY need your computer?
12:49:57 <Viking667> back before twitter, there WERE news groups...
12:49:59 <jamii> monochrom: facebook is cool for photos. like a timeline of your life.
12:50:19 <pumpkin_> jpcooper: it's all about making things more convenient
12:50:22 <jpcooper> pumpkin, of course I do. I use it for...university study!
12:50:29 <pumpkin_> sure, we could just email everything instead of using IRC
12:50:32 <jamii> ...and porn
12:50:37 <jpcooper> yeah mostly for porn
12:50:58 <jamii> i need to have that soundbite assigned to a shortcut
12:50:59 * maltem doesn't get the hang of twitter either though
12:51:04 <monochrom> If the installation instruction says "use Setup.hs to build and install", the package was prepared with Cabal. But you don't need to know it, you just have to follow instructions. The package author needs to know it.
12:52:17 <jamii> http://www.youtube.com/watch?v=W31ue-9u4z4&feature=related
12:52:45 <pumpkin_> conal: think it's worth including the other FP (non-haskell) people that bos included?
12:53:02 <patco444> Proactol is a groundbreaking development in weight loss treatment, and is exactly what over weight people have been waiting for - http://track.moreniche.com/hit.php?w=119443&s=38
12:53:21 <pumpkin_> heh
12:53:23 <conal> pumpkin_: no
12:54:16 <Viking667> far out. No wonder the excess flood.
12:54:57 <ozy`> http://echo.rsmw.net/blag/wry.html <- hey guys does this count as a blog?
12:56:03 <Botje> where's the chinese spammers hawking WOW GOLD !!!!111?
12:56:43 <Viking667> geez. Can't see a need for that sort of editor, unless you're trying to be desperate. I make too many mistakes, and I end up re-editing several times, sometimes majorly.
12:56:45 <Botje> ozy`: I only follow blogs through RSS nowadays
12:56:53 <Viking667> My blog posts aren't short either...
12:57:08 <ozy`> Viking667: editing is obviously permissible after the productivity part is done
12:57:10 <Viking667> minimum of say, four paragraphs, quite often longer.
12:57:11 <Botje> so for me, "a site with an RSS feed" would be the minimum to count as a blog
12:57:16 <jeffwheeler> ozy`: that looks fun to use.
12:57:24 <Viking667> ozy`: for me, the editing is PART of the productivity.
12:57:50 <Botje> Viking667: dunno, i find myself tempted to get the layout right before writing the content
12:57:54 <Viking667> I don't stop having good ideas just because I'm out of the "production" and into the "Editing" phase.
12:57:58 <ozy`> jeffwheeler: it's a lot like that one editor
12:58:06 <Viking667> Botje: yeah, that's one I get caught out on too...
12:58:12 <jeffwheeler> ozy`: yes, that one.
12:58:27 <Botje> it would be neat to have an editor only allow edits in a top-to-bottom fashion
12:58:39 <Botje> that way you'd have to re-read all the rest first
12:58:46 <ozy`> Viking667: well naturally you can insert new text at any time during the editing process. the idea is to write and -then- edit, though. and obviously not everyone has a use for that
12:58:49 <Viking667> doesn't work...
12:59:27 <pumpkin_> conal: http://haskell.org/haskellwiki/Twitter
12:59:49 <Viking667> err, sorry... Botje: wouldn't work for me.. if you make a correction 90% through the text that affects the validity of something at the start of the text, then you're back to the beginning, and you've had to do two runs through.
13:00:13 <Botje> hmm, i see
13:00:19 <Viking667> I jump around a bit too.
13:00:21 <conal> pumpkin_: sweet! thanks a bunch. :)  how about a haskell-cafe note?
13:00:23 <Botje> yeah
13:00:27 <ozy`> Viking667: this is a personal itch I'm scratching because even a program as minimal as vim is too (visually) distracting for me a lot of the time
13:00:27 <Botje> perhaps some kind of heatmap?
13:00:33 <Viking667> I.e. I get out the main bulk of stuff out, then get the editing.
13:00:40 <pumpkin_> conal: I'm scared of posting on haskell-cafe :P no one knows who I am
13:00:43 <Viking667> ozy`: huh??? You.... hell, dude. Use ed
13:01:00 <ozy`> Viking667: it doesn't have word wrap :p
13:01:15 <Viking667> exactly. You want less distraction? That's the way to get it
13:01:19 <pumpkin_> allbery_b: bos listed you on the twitter list but you don't seem to be on twitter... did you cancel your account?
13:01:25 <pumpkin_> or is there just a typo in the twitter username
13:02:20 <pejo> ozy, do you need to write lots of formulas?
13:02:26 <monochrom> ed is more distracting than vim. vim sometimes hide the : prompt, ed shows it always.
13:02:36 <conal> pumpkin_: np.  word will get around.
13:02:47 <pumpkin_> maybe I'll muster up the courage to though :P
13:03:00 <allbery_b> I'm there, you won't find me with search though (I have a bug report open with them)
13:03:06 <ozy`> pejo: no. I write fiction sometimes but not as much as I'd like... because I can't keep my attention on the text for long enough
13:03:09 * jeffwheeler just found out it's possible to change the twitter username. For some reason I used 'nokrev' years ago; changed it to 'jeffwheeler'.
13:03:10 <Botje> pumpkin_: mail from your pumpkinpat.ch email address!
13:03:12 <allbery_b> http://twitter.com/allbery_b
13:03:25 <mdiin> There's always ex editor :)
13:03:31 <ozy`> pejo: again, it's not like this would be an all-purpose text editor. it's an upgraded cat.
13:03:35 <pumpkin_> aha, allbery_b not allberry_b :)
13:03:38 <pumpkin_> I'll fix it
13:03:40 <ozy`> (I use cat a lot.)
13:03:45 <allbery_b> heh
13:03:50 <pumpkin_> Botje: I never bothered setting up an mx on that domain :P
13:03:50 <pejo> ozy, for mac there is a software called 'scrivener'. It has a full screen mode. I think there are similar programs for Windows (they recommend a bunch on their homepage).
13:03:57 <conal> pumpkin_: hey -- i don't see you on the twitter list.
13:03:57 <monochrom> "cat > myfile.hs" and "copy con: myfile.hs" are pretty much the bare minimum.
13:04:00 <Botje> pumpkin_: now you have a reason :p
13:04:17 <pumpkin_> conal: hah, I'll add myself, didn't think of that
13:04:42 <ozy`> pejo: I know about scrivener and it's still too distracting. even if I don't see any of the controls or window decorations, the ability to jump around and edit the text still messes up my productivity level
13:05:17 <pumpkin_> Botje: scary though :P
13:05:34 <pumpkin_> conal: added myself :)
13:05:38 <pejo> ozy, hardcore.
13:05:40 <conal> :)
13:06:56 <erikc> ozy: Write Room ? :)
13:07:34 <ozy`> erikc: see above :p
13:15:33 <pumpkin_> conal: I even sent a mailing out to the list (*tremble*)
13:17:37 <conal> pumpkin_: great!  sometimes it helps to push our comfort zone.
13:18:57 <conal> pumpkin_: nice note :)
13:19:26 <dons> hey guys. while i'm making distro packages, i'm trying to simultaneously help people find out what is updated on hackage each week. see the arch news here: http://archhaskell.wordpress.com/2009/02/21/arch-haskell-news-feb-21-2009/
13:19:29 <pumpkin_> hah thanks :)
13:19:34 <dons> i'd appreciate feedback on how to make that content more generally useful
13:19:45 <dons> for example, i started breaking down releases by category
13:20:02 <dons> but what would it take to really help people understand what's new and updated in haskell land?
13:20:38 <pumpkin_> having changelogs on individual packages is something I've always wanted
13:20:47 <pumpkin_> I see that someone's uploaded x-v2
13:20:52 <pumpkin_> but I have no idea what's changed in it
13:21:03 <dons> right. that's a different issue. something we'll need to address on hackage
13:21:04 <pumpkin_> this is on hackage, not specific to distro packages though
13:21:05 <pumpkin_> yeah
13:25:36 <dsrogers> what is the most concise way of splitting on a ":"?
13:25:40 <dsrogers> can I do that in a pattern?
13:25:48 <Viking667> so. What should I install a "hackage" package into, and what tool do I use to install? I'm getting the impression hackage doesn't seem to run like CPAN/ruby/CTAN
13:26:10 <paper_cc> Viking: you use cabal-install
13:26:25 <jeffwheeler> dons: I just uploaded pointedlist-0.3.1 which should fix the tests; I removed the hook, so now they must be run with `runhaskell tests/PL.hs`, unfortunately.
13:26:38 <dons> thanks!
13:26:38 <jeffwheeler> dons: thanks for the email.
13:26:44 <dons> yes, its good not to install test binaries, btw
13:27:12 <pumpkin_> does haskell-cafe not relay us emails we send?
13:27:16 <jeffwheeler> It seems like there should be some easier way to hook into `cabal test`, but it was too much of a pain for now.
13:27:54 <Viking667> thanks.
13:28:11 <Viking667> hm. No "cabal-install" here...
13:28:40 <Viking667> ... though there is a /usr/sbin/cabal
13:29:02 <dcoutts> Viking667 sbin? that seems very odd, might not be the same thing
13:29:10 <Viking667> it isn't.
13:29:22 <Viking667> some hangover from SourceMage
13:29:36 <Cale> Viking667: You can download it from hackage if you don't have it. There's a bootstrap script which is included that should get you up and running.
13:29:41 <dcoutts> Viking667: hackage is like cpan, it uses the 'cabal' program from the cabal-install package.
13:29:44 <sjanssen> jeffwheeler: check out xmonad's .cabal file and darcs test hook for another option
13:29:46 <Viking667> right.
13:29:54 <sjanssen> @botsnack
13:29:54 <lambdabot> :)
13:29:54 <lunabot>  :)
13:30:16 <jeffwheeler> sjanssen: will do; thanks
13:30:23 <pumpkin_> @hoogle bufWPtr
13:30:23 <lambdabot> No results found
13:30:25 <pumpkin_> boo :P
13:31:01 <pumpkin_> this stuff isn't very well documented :P
13:31:56 <pumpkin_> I'm guessing bufWPtr is for writing and RPtr is for reading
13:32:23 <pumpkin_> or the last offset that was written from, and last one that was written to
13:32:23 <logout> I am doing Exercise 4.4 in YAHT, where I have to construct a data type for a Quad where the first and last two data types must be the same type...  Can anyone explain why this is illegal? data Quadruple a a b b = Quadruple a a b b
13:32:27 <pumpkin_> *read from
13:32:44 <logout> using a b c d works, but I would have though what I had written would work..
13:33:19 <ozy`> @pl pl n = u . pl' n . l
13:33:20 <lambdabot> pl = (u .) . (. l) . pl'
13:33:27 <erikc> i get to pitch Haskell for build pipeline tools this week, should be an interesting battle
13:33:36 <Cale> logout: Because on the left of the = sign, you give a name to the *type* and its parameters.
13:34:02 <Cale> logout: For clarity let me write it like  data Quadruple a b = Quad a a b b
13:34:17 <logout> Cale: Oh I see, thank you :)
13:34:18 <Cale> logout: You can think of Quadruple as a function which takes two types and gives a new type.
13:34:45 <Cale> whose values look like Quad x y z w where x, y :: a and z, w :: b
13:34:56 <pilkarn> i did soem stuff with the netflix data set before and just laoding a few file as they were repped into memeory soared up and used all memory, what could ahve been the error?
13:35:56 <Cale> logout: Since Quadruple and Quad live in completely different namespaces (Quadruple is at the type level, Quad is at the value level) they could be named the same, but this can be confusing when you're starting out :)
13:35:59 <pilkarn> I mean you can load the entire dataste into 200MB if you are clever with C++. but there I used haskell when I was a haskell noob, didnt optimize anything, used data-structs and stored everything quite verbosely but after just a few 100 files(17K total) it ate up all my 1GB ram
13:36:04 <pumpkin_> aha, I think I've found the source of a uvector bug :D
13:36:56 <logout> Cale:  Right, I remember it saying they were just named the same for convenience.
13:37:12 <sizur> Is Eric J. Roode here?
13:37:20 <dons> pumpkin_: interesting.
13:37:23 <pumpkin_> but I'm not sure how to fix it :P
13:37:48 <pumpkin_> it's not a very critical bug, just one that showed up from the testsuite
13:39:47 <pumpkin_> dons: the issue is that for the pair productions of UArr, hPutU just writes the two halves one after the other, but when reading it back in, it's hard to say where one half ends and the next one starts
13:39:57 <dons> mmm
13:40:01 <dons> yes, the IO stuff is gunky
13:40:08 <dons> its a proxy till i get it working nicely with Dat.aBinary
13:40:23 <pumpkin_> ah okay, so it's not worth spending too long trying to fix it?
13:41:33 <wli> I finally got upper triangularization working after a few hours of pain.
13:41:51 <wli> It's polymorphic, so rational arithmetic flew.
13:43:02 <hackage> Uploaded to hackage: pointedlist 0.3.1
13:43:02 <hackage> Uploaded to hackage: pointedlist 0.3
13:45:34 <RayNbow> dons: received my msg (via lambdabot)? :)
13:46:07 <wli> I guess if I had more brain cells left I could do a proper LU factorization.
13:46:45 <wli> I've not even got backsubstitution going.
13:49:02 <dons> RayNbow: re. parallel programs? yes!
13:50:13 <Cheshire> what should I code in haskell
13:50:36 <Raevel> this is a good question
13:50:37 <dons> something from http://www.reddit.com/r/haskell_proposals/
13:50:44 <RayNbow> dons: http://www.mediafire.com/file/zdyinjzzn2t/ParallelProgrammingAssignments.zip
13:51:00 <wli> I think there's a naive procedure for fraction-free Gaussian elimination that isn't so difficult.
13:51:36 <Maddas> Cheshire: Revive Conjure!
13:51:46 <Cheshire> what's conjure
13:52:10 <erikc> thats a fun a list
13:53:29 <eu-prleu-peupeu> hey dons
13:53:39 <Cale> Cheshire: It's a bittorrent client, iirc.
13:55:33 <wli> Find the smallest nonzero matrix element. Carry out n-way egcd on the rows whose corresponding column element is nonzero, carrying along their other columns in the various multiplications. Eventually the n-way gcd of all those will reduce all but one column element to 0, with the n-way gcd as the last thing standing. With permutations and integer linear combination row operations, you cut down the matrix by one row/column.
13:55:46 <eu-prleu-peupeu> i think i need an haskell godfather, to teach me out how to program
13:56:07 <Cheshire> I did one of the things on the list already but none of the others are really interestning to me
13:56:09 <Cheshire> :/
13:58:12 <eu-prleu-peupeu> check it out: http://www.businessweek.com/innovate/content/feb2009/id20090218_337947.htm
13:58:25 <Cheshire> no thanks because t's obvious not related to haskell at all
13:58:28 <Cheshire> like everything you link to
13:59:05 <eu-prleu-peupeu> its about "how to keep inovating"
13:59:21 <eu-prleu-peupeu> it has some weak link to haskell
13:59:24 <Cheshire> I guess it covers innovative spelling
13:59:26 <eu-prleu-peupeu> because haskell is inovation
13:59:37 <eu-prleu-peupeu> :P
13:59:41 <eu-prleu-peupeu> yes
14:00:25 <ddarius> @seen conal
14:00:25 <lambdabot> conal is in #haskell, #ghc and #haskell-in-depth. I last heard conal speak 41m 28s ago.
14:00:51 <conal> ddarius: hi
14:01:16 <wli> I'm not sure how to do the bookkeeping for the pivoting.
14:02:14 <ddarius> conal: About that LtU post, I'm wondering what you think of my replies or if you have some response to Matt M (or just if you'd find his questions useful). http://lambda-the-ultimate.org/node/3215
14:02:35 <conal> ddarius: oh, thanks.  i haven't seen the comments.  looking now.
14:04:24 <eu-prleu-peupeu> hey conal, do you want to be my haskell godfather ?
14:07:17 <Cheshire> is there a tutorial that needs written or something (I am trying to not be bored)
14:09:15 <jpcooper> @hoogle (a -> m a) -> a -> m ()
14:09:15 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
14:09:15 <lambdabot> Data.Generics.Basics gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
14:09:15 <lambdabot> Data.Generics.Basics gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
14:09:34 <eu-prleu-peupeu> Cheshire: you can help me out learning haskell
14:09:36 <jpcooper> I'd like something like iterate but for monads
14:09:45 <Cheshire> not directly
14:10:21 <jpcooper> I guess I'll use iterate with sequence
14:10:33 <jpcooper> sequence_
14:10:42 <pumpkin_> eu-prleu-peupeu: why do you need someone to teach you programming? can't you learn without a teacher? :)
14:10:53 <pumpkin_> gotta be independent!
14:11:07 <eu-prleu-peupeu> pumpkin, well... im too lazy i guess
14:11:21 <Cheshire> I think you have no interested in haskell
14:11:22 <pumpkin_> aha, so waste someone else's time because you're too lazy to put effort into it :P
14:11:34 <eu-prleu-peupeu> :D
14:11:41 <eu-prleu-peupeu> i have
14:11:46 <eu-prleu-peupeu> im trying to learn haskell
14:11:51 <conal> oops.  lost my connection.
14:11:52 <Cheshire> no you aren't
14:11:54 <eu-prleu-peupeu> i want to be l33t
14:12:02 <eu-prleu-peupeu> i will go to the hackaton
14:12:06 <conal> ddarius: i like your replies!  thanks. :)
14:12:09 <eu-prleu-peupeu> to learn how to be l33t
14:12:13 <Gracenotes> @hoogle iterateM
14:12:13 <lambdabot> No results found
14:12:21 <Gracenotes> @hoogle mfix
14:12:21 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
14:12:52 <pumpkin_> dons: the one issue I see with using Data.Binary is that Float/Double have enormous (inefficient) representations there :/
14:13:15 <dons> we don't nec. have  to use the Binary class
14:13:19 <pumpkin_> ah
14:13:24 <dons> but Get / Put   to create uvectors from bytestrings
14:13:29 <pumpkin_> hmm, I see
14:13:45 <pumpkin_> would also make testing easier :P my tests currently make an unsafePerformIO'ed temporary file
14:13:59 <Plouj> hi
14:14:08 <Cheshire> hi
14:14:15 <Plouj> how can I get the same functionality as @check in my local GHCi?
14:14:23 <Cheshire> use lambdabot
14:14:27 <Cheshire> locally
14:14:35 <Heffalump> can't you just import Test.QuickCheck?
14:14:42 <Saizan> yeah, you can
14:14:50 <Saizan> then then use quickCheck
14:17:22 <Plouj> can I?
14:17:33 <Plouj> what do I do after importing Test.QuickCheck ?
14:18:26 <jpcooper> @hoogle (a -> m a) -> a -> [m a]
14:18:26 <lambdabot> Data.Generics.Basics gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
14:18:26 <lambdabot> Data.Generics.Basics gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
14:18:26 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
14:18:49 <pumpkin_> <interactive>: internal error: scavenge_one: strange object 0
14:18:53 <pumpkin_> awesome
14:19:02 <eu-prleu-peupeu> is it good to pass class types to all my functions with loads of inputs in haskell ?
14:19:37 <eu-prleu-peupeu> i mean, like... with type classes its possible to get lots of ninja stuff from the function inputs, like optional arguments and all
14:19:52 <eu-prleu-peupeu> but they are boring like hell
14:20:10 <pumpkin_> can you give a concrete example of what you want?
14:20:14 <Viking667> Right. I seem to have Cabal-1.2.4.0, I'm assuming an install of 1.6.0.2 over the top of the currently installed setup will screw things over?
14:20:23 <dons> 1.2 ?
14:20:24 <dons> hmm.
14:20:33 <dons> Viking667: it should probably be just fine, actually
14:20:39 * Viking667 blinks.
14:20:40 <Viking667> Right.
14:21:11 <eu-prleu-peupeu> what is the difference between type classes and type families ?
14:21:20 <Viking667> It's the version (1.2.x) that came with ghc-6.8.3
14:21:33 <Viking667> ... and I don't know if it's the same thing as cabal-install.
14:22:31 <eu-prleu-peupeu> i am going to develop the greatest l33tzor 3d engine in haskle!
14:22:33 <pumpkin_> eu-prleu-peupeu: I'd stick to type classes for now :) they're more common
14:22:52 <pumpkin_> eu-prleu-peupeu: do you make a point of misspelling haskell every time?
14:22:55 <eu-prleu-peupeu> okey, let me try to build some...
14:23:04 <blackh> Plouj: quickCheck (\x -> x == reverse x)
14:23:28 <eu-prleu-peupeu> haskle easier to type, and sound better
14:23:35 <pumpkin_> um
14:23:35 <BONUS> hmm been at this all day
14:23:36 <Viking667> eu-prleu-peupeu: bull.
14:23:48 <pumpkin_> eu-prleu-peupeu: I'll call you youpryoupyoupyou then
14:23:55 <eu-prleu-peupeu> :)
14:23:59 <Viking667> peti-peu
14:24:04 <BONUS> how come when i do :set -XScopedTypeVariables i can do (\(a::Int) -> a)
14:24:26 <Viking667> dict.org:  petit-peu: little brain.
14:24:29 <BONUS> but if i do {-# LANGUAGE ScopedTypeVariables #-} in a script and then load it, it says i need to turn on -XScopedTypeVariables
14:24:48 <Viking667> </sarcasm>
14:26:44 <Plouj> whooo!
14:26:45 <Plouj> thanks!
14:26:58 <Plouj> Test.QuickCheck.quickCheck (\x-> null x || Data.List.transpose x == transpose x)
14:27:01 <Plouj> OK, passed 100 tests.
14:27:21 <RayNbow> http://thumbs.reddit.com/t5_2qh36.png?v=224314f174ab68f9c74ba30d9f21acae <-- YEAAAAH! :D
14:27:22 <pumpkin_> how do I ask quickcheck for more than 100 tests?
14:27:41 <vincenz> > Data.List.transpose []
14:27:41 <eu-prleu-peupeu> can i specify default values in data type constructors ?
14:27:42 <lambdabot>   []
14:27:43 <RayNbow> (when did the Haskell reddit image change? :p)
14:27:49 <eu-prleu-peupeu> like a type with a default value :P
14:28:00 <eu-prleu-peupeu> does this makes any sense ?
14:28:01 <Plouj> vincenz: I'm still working on that function :)
14:28:20 <pumpkin_> eu-prleu-peupeu: not really
14:28:34 <pumpkin_> eu-prleu-peupeu: functions have fixed number of arguments unless you do some crazy hackery
14:28:48 <pumpkin_> so omitting an argument means you get another function, usually
14:29:20 <TomMD> pumpkin_: There is an alternate function that you can pass config info into quickcheck.
14:29:28 <pumpkin_> ah, I'll look for it
14:30:53 <TomMD> pumpkin_: I think its 'check', judging by the type signature.
14:31:06 <monochrom> BONUS: That is strange because I get "try -XPatternSignatures". In fact PatternSignatures is the appropriate option, ScopedTypeVariables is something else.
14:31:22 <TomMD> Just use: check (defaultConfig { {- change arguments here -} }) prop_x
14:31:37 <pumpkin_> @index check
14:31:37 <lambdabot> Control.Concurrent.STM, Test.QuickCheck, Debug.QuickCheck
14:31:40 <BONUS> if i do PatternSignatures it says it's deprecated and i should use ScopedTypeVariable
14:31:43 <BONUS> s
14:31:56 <BONUS> event hough pattern signatures makes more sense cause it says pattern signatures right there in the name
14:31:58 <pumpkin_> hmm, I can't find the function check in the docs
14:32:08 <TomMD> > check (defaultConfig { maxTests = 500 }) (const True)
14:32:09 <lambdabot>   Not in scope: `check'Not in scope: `defaultConfig'Not in scope: `maxTests'
14:32:24 <TomMD> right, its IO, silly of me.
14:32:47 <monochrom> In fact there is no scoped type variables (and no type variables at all) in \(a::Int) -> a
14:33:11 <BONUS> Warning: -XPatternSignatures is deprecated: use -XScopedTypeVariables or pragma {-# LANGUAGE ScopedTypeVariables#-}
14:33:11 <monochrom> I'm using 6.8.2. Are you at 6.10.x?
14:33:17 <BONUS> yeah im @ 6.10.1
14:33:18 <BONUS> :[
14:33:56 * monochrom celebrates again for his wise decision to avoid 6.10.1
14:34:13 <BONUS> @seen dons
14:34:13 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 13m 33s ago.
14:34:43 <monochrom> One day someone will say in retrospect: "GHC is like Star Trek movies, alternating good and bad releases." :)
14:34:53 <BONUS> hahaha
14:36:54 <dons> BONUS: ?
14:39:09 <monochrom> dons: We have strange GHC 6.10.1 suggestion "use -XScopedTypeVariable" for code "\(a::Int) -> a".  Where is the type variable?
14:40:04 <monochrom> It also says "PatternSignatures deprecated, use ScopedTypeVariables". We don't understand it. The two are supposed to be orthogonal.
14:40:20 <Saizan> does it work with ScopedTypeVariables on?
14:40:27 <Saizan> in 6.10
14:40:55 <monochrom> Oh that's the fun part. If you use -X on the command line, it accepts. If you use LANGUAGE pragma, it rejects.
14:41:40 <crutcher> hey, where's the Either String monad declared?
14:41:48 <crutcher> I can't find it with hoogle
14:41:53 <monochrom> Control.Monad.Error
14:41:55 <pumpkin_> Error
14:42:02 <Saizan> or .Instances
14:42:31 <BONUS> dons: yeah i was wondering if you knew about pattern signatures
14:42:44 <BONUS> basically if i do :set -XScopedTypeVariables they work
14:43:04 <BONUS> but if i load a .hs that has the matching LANGUAGE pragma, i get an error that i need to turn on -XScopedTypeVariables
14:45:38 <Saizan> {-# LANGUAGE ScopedTypeVariables #-}
14:45:38 <Saizan> foo = \(x :: Int) -> x
14:45:46 <Saizan> this works here with 6.10.1
14:46:06 <crutcher> Nope, not in Instances or Error.
14:46:21 <crutcher> The Either Functor is in Instances
14:46:39 <crutcher> what would I search for to look for instances of a class on hoogle?
14:47:25 <BONUS> Saizan: really? wow, strange
14:47:48 <Saizan> Control.Monad.Error Prelude> fail "foo" :: Either String ()
14:47:49 <Saizan> Left "foo"
14:48:07 <BONUS> Saizan: but what if you declare the lambda in ghci
14:48:27 <Saizan> BONUS: the LANGUAGE pragma in the source doesn't extend to what you declare in ghci
14:48:34 <Saizan> BONUS: you've to enable it also for ghci
14:48:41 <BONUS> oh of course
14:48:42 <BONUS> doh
14:48:55 <BONUS> how silly of me ugh
14:50:47 <monochrom> @stab BONUS
14:50:48 * lambdabot karate-chops BONUS into two equally sized halves
14:50:55 <crutcher> Saizan: okay. I'm looking at the docs, and I don't understand _how_ it gets declared
14:50:55 <monochrom> tee hee hee
14:50:55 <Cheshire> woah
14:51:06 <Cheshire> now he is twice as powerful!
14:51:17 <monochrom> twice as half powerful
14:51:35 * Cheshire is reinterpreting "equally sized" for the purpose of this joke
14:51:37 <wli> I've got some crud to do row reduction but it doesn't have a good idea of how to loop.
14:51:47 <crutcher> its through this, isn't it: Error e => MonadError e (Either e)
14:52:18 <wli> Or, rather, one step of row reduction.
14:52:22 <monochrom> Cheshire: lambdabot can do that too, but it will say something about Tarski-Banach when it does so.
14:52:29 <Saizan> crutcher: the instance is Error e => Monad (Either e), but it's not listed in the sources
14:52:42 <crutcher> So, where does it come from?
14:52:52 <Saizan> s/sources/haddock documentation/
14:52:56 <Saizan> doh
14:53:13 <Saizan> @source Control.Monad.Error
14:53:13 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
14:53:54 <crutcher> a) thanks.
14:54:05 <crutcher> b) This sort of thing is really starting to bug me about haddok
14:54:21 <wli> It's not got a very good idea of how to pass along what it did to reduce, esp. the permutations of rows/cols.
14:54:36 <Saizan> crutcher: yeah, it doesn't work well with orphan instances
14:54:57 <crutcher> Saizan: it doesn't work well with most haskell code.
14:55:05 <Saizan> most?
14:55:20 <crutcher> Saizan: people generally don't document 'trivial' methods, which just compose a few things
14:55:30 <crutcher> so more code is undocumented than documented.
14:55:47 <crutcher> I'd prefer it if Haddok showed me the code
14:56:02 <wli> It's also completely untested.
14:56:21 <tehgeekmeister> @type (\f a -> fmap (fmap f) a)
14:56:22 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f1 (f a) -> f1 (f b)
14:56:32 <crutcher> If I ever need to hit the Source link, haddok has failed to do its job
14:56:38 <tehgeekmeister> the typeclassopedia is amazing.  =]
14:56:48 <Saizan> crutcher: well, haddock can link to the sources
14:56:54 <tehgeekmeister> i now understand fmap!
14:56:54 <chessguy_> @pl \f m -> m' (l f) m
14:56:54 <lambdabot> m' . l
14:56:56 <Cheshire> is there a link to it ?
14:57:08 <Saizan> crutcher: i don't understand you then
14:57:11 <tehgeekmeister> @pl  (\f a -> fmap (fmap f) a)
14:57:11 <lambdabot> fmap . fmap
14:57:21 <Saizan> crutcher: you said you want the source shown but now linked to it?
14:57:23 <tehgeekmeister> @ type fmap fmap
14:57:30 <tehgeekmeister> @type fmap fmap
14:57:31 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
14:57:34 <wli> http://pastebin.com/m55b57a86 <-- a stab at fraction-free Gaussian elimination
14:57:45 <crutcher> Saizan: I want the haddock dock to be _more_ informative than reading the raw source, not less.
14:57:47 <chessguy_> @src Arrow
14:57:47 <lambdabot> class Arrow a where
14:57:47 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:57:47 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:57:47 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:57:47 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:57:49 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:57:51 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:57:55 <BONUS> fmap fmap fmap (*3) [[1,2,3],[4,5,6],[7,8,9]]
14:57:57 <pumpkin_> is there some way I can "jump into" a library for debugging in ghci? I want to be able to pretend I'm inside each module
14:57:59 <BONUS> > fmap fmap fmap (*3) [[1,2,3],[4,5,6],[7,8,9]]
14:58:00 <lambdabot>   [[3,6,9],[12,15,18],[21,24,27]]
14:58:20 <crutcher> I want it to find all the known instances of a new class, and link to them. Show me the source, tell me where it gets used
14:58:21 <chrisdone> @src first
14:58:21 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:58:25 <Saizan> crutcher: source links with anchor links like on hackage seem the best solution for when the developer didn't bother to add documentation
14:58:32 <chessguy_> i don't get this Arrow interface. it would seem that whenever you apply most of the functions in the class, your sort of 'stuck' in the sense that you can't apply another arrow-ish function to the result
14:58:37 <crutcher> _and_ give me nicely formated docs, whenever people get arround to writing them
14:58:48 <chrisdone> first = flip (&&&) id?
14:58:52 <crutcher> Saizan: better than showing the source in-line?
14:59:12 <sclv> chessguy: huh?
14:59:19 <Saizan> crutcher: most of the time the source in-line is not needed, and if it's long it's a big waste of space
14:59:29 <chrisdone> :t flip (&&&) id
14:59:29 <lambdabot> forall b c. (b -> c) -> b -> (c, b)
14:59:30 <Saizan> heck, lots of time is not useful either
14:59:34 <chrisdone> ah, no
14:59:49 <tehgeekmeister> BONUS: how does that work?
14:59:53 <crutcher> Saizan: if the method is short, it frequently needs no more docs than showing its structure.
15:00:04 <tehgeekmeister> @type fmap fmap fmap
15:00:04 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:00:06 <crutcher> Saizan: if the method is long, the docs may not be sufficient
15:00:15 <BONUS> tehgeekmeister: because functions are monads (and functors), fmap is actually . for them
15:00:25 <BONUS> so fmap fmap fmap is fmap `fmap` fmap, which is (fmap . fmap)
15:00:32 <tehgeekmeister> okay
15:00:40 <crutcher> Haddock frequently leaves me frustrated. I'm not trying to convince you that _you_ should be, I'm telling you that I _am_
15:00:42 <BONUS> so you can think of that like map . map
15:00:45 <chessguy_> sclv:  i'm not sure how else to explain my question. it just doesn't seem like Arrow combinators should compose well because any time you apply most of them, you wind up with tuples in the result, which it doesn't seem like you can apply another arrow combinator to
15:00:48 <Saizan> crutcher: still showing the source in API documentation looks just like an abstraction breakage, rather than useful
15:00:53 <sclv> chessguy: it helps if you think of the "a" in arrow type signatures as (~>) (i.e., some "function" that translates b to c but isn't necessarily of type (b->c)
15:01:00 <BONUS> > (map . map) (*3) [[1,2,3],[3,4,5]]
15:01:01 <lambdabot>   [[3,6,9],[9,12,15]]
15:01:06 <olsner> @ty let fap = fmap in fap fap fap
15:01:07 <sclv> --i.e. needs an explicit "apply" method)
15:01:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:01:17 <chessguy_> sclv:  i understand that part
15:01:21 <tehgeekmeister> BONUS: it make sense now that i know the second fmap is equivalent to composition in this context
15:01:25 <wli> (1) find the smallest nonzero element of the matrix with other nonzero elements in the same column; if none exist, terminate (2) move it to the upper left corner (3) let (q, r) = (a ! (1, j)) `divMod` (a ! (1, 1)) and then subtract q times the first row from the j-th row (4) go to (1)
15:01:27 <Saizan> crutcher: i'm just saying that it's more a fault of developers not writing documentation
15:01:36 <sclv> so if you get a (b,c) (d,e) then you have another arrow, just an arrow between tuples.
15:01:41 <sclv> and the arrow combinators still apply.
15:01:43 <tehgeekmeister> BONUS: it also makes sense now that i know what a functor is and can finally understand the type signature
15:01:49 <BONUS> hehe nice :]
15:01:57 <chessguy> sclv:  oh, so tuples are arrows too
15:02:01 <Saizan> crutcher: and that i concur that instances should be handled better
15:02:07 <sclv> tuples can be components of arrows.
15:02:20 <GrayShade> Saizan: I liked the "Source" links that haddock outputs sometimes
15:02:21 <Saizan> crutcher: btw, http://trac.haskell.org/haddock/report/1
15:02:22 <crutcher> Saizan: and I'm saying I don't care how naughty the developers are or aren't, haddock should be built for who we are, not who we wished we were
15:03:08 <sclv> if you look at how arrow notation desugars you see that tuples are fundamental to doing useful things with arrows -- rather than keeping state in, e.g., a state monad, state gets kept explicitly at each step by being a component of the tuple/tuple stack that you're threading from arrow operator to arrow operator.
15:03:12 <Saizan> GrayShade: me too
15:03:16 <monochrom> In practice I use the do-proc notation for Arrows and it will do all the tuple construction and tuple deconstruction for me.
15:03:22 <chrisdone> :t \f s -> first f >>> second s
15:03:23 <lambdabot> forall (a :: * -> * -> *) b c d c1. (Arrow a) => a b c -> a d c1 -> a (b, d) (c, c1)
15:03:29 <Saizan> GrayShade: but i'd find the source in-line horrible
15:03:32 * tehgeekmeister wonders why none of the haskell tutorials he read back in the day mentioned what a functor was at all.  or if they did, why he didn't notice it...
15:03:33 <chrisdone> is this a correct definition of ***?
15:03:40 <crutcher> Saizan: yes, I'd love to help. I still don't know what I'm doing, but I'm working on that. Hence my frustration with haddock
15:03:50 <GrayShade> Saizan: too bad they're not everywhere in the ghc docs
15:04:02 <chessguy> @pl \f s -> first f >>> second s
15:04:02 <lambdabot> (. second) . (>>>) . first
15:04:07 <sclv> chrisdone: looks reasonable to me? 90% of the arrow methods have defaults as i recall and are just in the typeclass so you can override for efficiency.
15:04:30 <chrisdone> sclv: ah, I was about to ask why (***) is in the type class at all. but I guess that answers it
15:04:33 <wli> I'm surprised no one's very interested in fraction-free Gaussian elimination.
15:04:43 <Saizan> crutcher: reporting what you consider a bug or suggesting an improvement is a great way to help too
15:05:16 <sclv> it always seemed to me that we could get a better conceptual seperation between the tuple stuff and the "variable over the ~>" stuff.
15:05:17 <chrisdone> sclv: arrows kind of remind me of stack languages
15:05:20 <pumpkin_>     Unacceptable argument type in foreign declaration:
15:05:24 <crutcher> Saizan: yes, the first bug on that list is mine.
15:05:40 <chessguy> sclv:  what is ~>
15:05:42 <sclv> i think there was a blog post about that chrisdone -- forget where. a stack language in ten lines of arrow combinators or something.
15:05:53 <chrisdone> sclv: haha, sweet
15:06:02 <sclv> chessguy: just a free infix type variable
15:06:05 <crutcher> Saizan: But some of the problems aren't specific. They are more "what is haddock for" sort of problems, and I can't point to a specific solution.
15:06:17 <sclv> a b c === b ~> c
15:06:39 <chessguy> wow, i didn't know you could have non-alpha type variables
15:06:43 <sclv> just a bit easier to think with sometimes, once you get your head around it. conal started that notation i think.
15:06:50 <sclv> it needs some extension or another.
15:07:02 <chrisdone> InfixTypeVariables? (guess)
15:07:21 <crutcher> Saizan: I expect ghc to do a lot of work for me. I'd like to see haddock work as hard. I know people work hard on it, I'd just like to talk about the scope. Is haddock a tool for Literate program documentation, or is it something more agressive?
15:07:26 <ozy`> chessguy: you can have non-alpha type names, too... e.g. "data (:$$$) = Cent | Dollar | ..."
15:07:41 <chessguy> wow
15:07:48 <chessguy> that seems...sadistic somehow
15:07:51 <monochrom> Haddock is just like Javadoc.
15:07:51 <ozy`> yes
15:08:07 <pumpkin_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1610#a1610 anyone know what this is?
15:08:14 <chrisdone> ozy`: is the colon required?
15:08:21 <monochrom> Like Javadoc or something more conservative.
15:08:24 <ozy`> chrisdone: yes
15:08:32 <chrisdone> why?
15:08:36 <sclv> crutcher: for literate programming you should use lhs (or, i guess, HWEB)
15:08:39 <Saizan> haddock is not even for literate programming
15:09:45 <monochrom> The same reason alphabetical type names start with capital letters.
15:09:49 <ozy`> chrisdone: because haskell distinguishes between "consyms" and "varsyms," the latter being normal operators
15:09:50 <sclv> the colon is just part of the syntax, to distinguish rigid from free terms.
15:10:06 <monochrom> And the reason is ease of distinction between constructors and variables.
15:10:30 <ozy`> I suppose : is capital punctuation
15:10:37 <pumpkin_> MutableByteArray is from GHC.Prim
15:10:38 <monochrom> Yeah, that's the way to think.
15:10:51 <crutcher> Anyway, I'm gonna stop bitching about it until I understand enough to help
15:11:40 <sclv> spj submitted a proposal for changing infix and type syntax otherwise about two months ago... don't recall the discussion much.
15:11:44 <conal> TypeOperators
15:12:44 <conal> i asked for that grammar change a while back.  spj said it simplified the grammar.
15:13:02 <pumpkin_> boo :(
15:13:23 <logout> I've just completed an exercise out of YAHT, but my answer seems to be a little verbose.  Can anyone tell me if I've missed some shorter way of representing this, or is it fine for a beginner.. http://pastie.org/396327
15:14:04 <monochrom> YAHT exercises are verbose by design.
15:14:11 <logout> Heh, I see.
15:14:33 <pumpkin_> what makes a type acceptable in a foreign import?
15:14:47 <crutcher> logout: well, this is pretty good.
15:14:56 <Zao> pumpkin_: Storability?
15:14:58 <cognominal> when one does may   :l +SomeModule   in ghci he gets a very long prompt. How to avoid that?
15:15:15 <crutcher> logout: you can use a '_' instead of variables for pattern positions you don't need to bind
15:15:21 <sclv> cognominal: there's some way to change the default prompt as i recall
15:15:21 <chessguy> logout:  well, you might have been able to do better with TH, but i suppose this is ok. (i'm just kidding, this is fine)
15:15:28 <chrisdone> is it called a phantom type when you have: data Foo a = Bar?
15:15:30 <cognominal> ouch
15:15:30 <logout> Yay
15:15:32 <pumpkin_> Zao: when I try to compile in ghci, it complains about that being illegal, but in normal compilation it says fine
15:15:45 <pumpkin_> chrisdone: I think so
15:15:47 <crutcher> logout: so, for instance: third (Three _ _ x) = Just x
15:16:08 <Tigran> cognominal: :set prompt blah
15:16:08 <Zao> cognominal: :set prompt "lol>"
15:16:10 <chessguy> logout:  crutcher  makes a good point
15:16:15 <Tigran> Snap Zao
15:16:20 <logout> crutcher:  Right, I forgot about doing that, in that case, but then did it below.
15:16:41 <cognominal> thx Tigran, Zao
15:16:53 <chrisdone> echo ':set prompt "Haskell> "' > ~/.ghci
15:16:58 <chrisdone> >_>
15:17:04 <Zao> pumpkin_: Doesn't it require -fffi or so?
15:17:05 <crutcher> logout: well, you seem to use it for the whole parameter, but its useful to remember it for the parts of a pattern as well
15:17:28 <pumpkin_> Zao: I have XForeignFunctionInterface
15:17:55 <logout> crutcher: Yeah it is quite similar to erlang with those, which I was doing earlier this year.
15:18:12 <monochrom> FFI defines which types you will get, and there are only a few, no?
15:18:32 <pumpkin_> monochrom: yet this foreign delcaration seems to work fine if I compile it normally
15:18:34 <pumpkin_> just not in ghci
15:18:40 <pumpkin_> and it's a primitive ghc type
15:19:01 <monochrom> :set -fffi ?
15:19:24 <pumpkin_> it's deprecated and I already have XForeignFunctionInterface instead of it
15:19:27 <crutcher> pumpkin: have you tried compiling the module to a .o file, then loading it in ghci?
15:19:33 <monochrom> oops
15:20:04 <crutcher> pumpkin_:  I've deffinately seen different behaviour when I do that
15:20:15 <monochrom> primitive ghc types are not part of FFI. primitive ghc types are to be enabled with some other options.
15:20:36 <pumpkin_> crutcher: it's hard to do that way, I'm trying to get past its exported interface
15:21:00 <monochrom> unless it's another 6.10.1 oddity.
15:31:25 <Gracenotes> hm, I have an idea: a typeclass MonadIO m => MonadFork m where fork :: m () -> m ()
15:31:49 <Gracenotes> it allows monadic computations to be forked (to another thread)
15:32:05 <Gracenotes> for instance, a Reader would work there.
15:32:34 <Gracenotes> sounds not-totally-insane...? ;)
15:34:04 <BONUS> sounds interssting
15:34:13 <Gracenotes> er, ReaderT with IO, that is
15:34:17 <BONUS> yeah
15:34:29 <Saizan> mmh
15:34:40 <Saizan> though it works almost only for ReaderT
15:35:08 <Gracenotes> hm. That's true :) I have three instances where it would work in my code, but they're all newtype'd around ReaderT somehow
15:35:38 <marcot> Is there a function like withDir :: FilePath -> IO a -> IO a, that does something in a directory, then leaves it?
15:36:01 <Saizan> i use something similar to test IO code with a non-IO model, but in the latter the forking is faked
15:37:21 <Gracenotes> @where hayoo
15:37:21 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:37:50 <Gracenotes> I have a feeling its GoogleRank would be better if it were hosted on haskell.org
15:38:43 <Gracenotes> marcot: not that I know of.. though, it's a short four-or-five-liner
15:40:19 <Gracenotes> withDir fp' action = do { fp <- getCurrentDirectory; setCurrentDirectory fp'; action; setCurrentDirectory fp}
15:40:21 <marcot> Gracenotes: yes, I'm writing it.
15:42:43 <marcot> Gracenotes: I think using Control.Exception.bracket_ is better.
15:43:36 <pumpkin_> mmorrow: indeed, it all works flawlessly on my 64-bit machine
15:43:58 <Gracenotes> marcot: ah, sure. And notifying the caller of the error, right?
15:44:18 <chrisdone> Gracenotes: that sounds like a good idea
15:44:44 <chrisdone> Gracenotes: I actually needed that a while back when writing code using the State monad and needed to fork
15:44:55 <marcot> Gracenotes: notifying how?
15:45:06 <marcot> withDir :: FilePath -> IO a -> IO a
15:45:06 <marcot> withDir dir action
15:45:06 <marcot>   = do
15:45:10 <pumpkin_> mmorrow: I guess it's conceivable that my tests are somehow flawed, I'm tempted to say it's a uvector issue
15:45:14 <chrisdone> I had to write a forkBlah function that used 'get' with the whole state and evalState'd
15:45:15 <marcot>     (current :: FilePath) <- getCurretDirectory
15:45:16 <marcot>     bracket_ (setCurrentDirectory dir) (setCurrentDirectory current) action
15:45:17 <Gracenotes> marcot: reraising the exception, I suppose. I'm not entirely familiar with exceptions, though
15:45:50 <chrisdone> Saizan: it also has use for ErrorT
15:46:06 <Gracenotes> chrisdone: yeah. I'm writing something a bit less sophisticated: newtype ThreadState s m a = ThreadState (ReaderT (MVar s) m a)
15:46:16 <Gracenotes> with instance MonadIO m => MonadState s (ThreadState s m)
15:46:26 <chrisdone> Saizan: oh, wait. no it doesn't
15:47:59 <Gracenotes> marcot: never mind, actually. bracket_ does it automatically
15:48:39 <chrisdone> Gracenotes: mhm
15:48:45 <Saizan> chrisdone: for ErrorT you can ignore the error, not sure how sensible that is
15:48:48 <pumpkin_> mmorrow: found it, I think
15:49:01 <chrisdone> Saizan: yeah
15:49:20 <mmorrow> pumpkin_: nice
15:49:26 <mmorrow> pumpkin_: what was/is it?
15:49:31 <Gracenotes> chrisdone: the modified state sounds nice, although the main problem with that is the existence of two simultaneous states unaware of each other
15:49:43 <chrisdone> Saizan: how are you testing IO code in another model? I was only recently considering an IO-ish class which IO could implement and then another type which pretends to do IO actions but really doesn't, or gives random input with QuickCheck somehow..
15:49:49 <Gracenotes> which may not be a problem :)
15:50:02 <pumpkin_> it's using ALIGNMENT_ instead of SIZEOF, and using it to compute size of elements. on my machine #define SIZEOF_UNSIGNED_LONG_LONG 8, but #define ALIGNMENT_UNSIGNED_LONG_LONG 4
15:50:53 <chrisdone> Gracenotes: yeah, I guess you could make the state modification functions actually access TVars under the hood and abstract that with some functions, but I guess it depends on your application
15:51:09 <Saizan> chrisdone: something like that, but rather than using a class i change the imports
15:51:14 <pumpkin_> mmorrow: testing it now, to see if it fixes it :P
15:51:36 <chrisdone> Saizan: what changes do you make?
15:51:43 <chrisdone> Saizan: do you have an example I can look at?
15:51:45 <tehgeekmeister> would the pointed instance for ((->) e) be id?
15:51:46 <pumpkin_> mmorrow: except http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg16036.html is what changed that
15:51:52 <pumpkin_> mmorrow: so maybe I'm confused
15:52:00 <ozy`> hmm, can I write "... where f | n > 0 = ..." in a scope where n is already defined?
15:52:09 <ozy`> or do I have to actually match against something?
15:52:12 <pumpkin_> mmorrow: yes, with SIZEOF_ it works fine
15:52:17 <dobblego> tehgeekmeister, const iirc
15:52:19 <pumpkin_> dons, are you around?
15:52:20 <monochrom> ozy`: Yes you can.
15:52:37 <tehgeekmeister> @src const
15:52:37 <lambdabot> const x _ = x
15:52:45 <Saizan> chrisdone: e.g. i have some primitives, and a monad Fake, then i can import PrimitivesIO to get the real work, or import PrimitivesFake to get the testable model
15:52:50 <tehgeekmeister> oh, that makes more sense
15:52:53 <tehgeekmeister> okay
15:52:53 * BMeph_ saw "Objective-C for Rubyists" and immediately thought of "Ruby-C for Objectivists"...
15:52:53 <chrisdone> > let f = 1 in x where x | f == 1 = "yay"
15:52:54 <lambdabot>   Add a type signature
15:53:04 <ozy`> monochrom: awesome
15:53:28 <skorpan> "objective-c for rubyists..." i don't know a single person except for myself who knows ruby or objective-c
15:53:29 <chrisdone> Saizan: ahhh, I see
15:53:32 <Saizan> chrisdone: since we lack parametrized modules :)
15:53:35 <Gracenotes> Yes We Can have guards in wheres!
15:53:42 <Gracenotes> Yes We Can!
15:53:49 <chrisdone> Saizan: what are parametrized modules?
15:53:50 <mmorrow> pumpkin_: sweet
15:54:19 <pumpkin_> mmorrow: but now I'm doubting myself because it would make that patch basically a regression (on tests that didn't exist at the time, but still)
15:54:30 <Saizan> chrisdone: modules that take other modules as arguments, so you don't need to edit the source of them to achieve this effect
15:55:07 <chessguy> skorpan:  i know an iphone developer that knows objective-c
15:55:10 <chrisdone> Saizan: oh, very clever. will haskell ever support that, do you think?
15:55:54 <Saizan> chrisdone: i think so, but since they somehow overlap with typeclasses we need a way to proper integrate the two features
15:56:01 <chessguy> it's hard to know what haskell will support, with the rather stagnant haskell-prime process
15:56:05 <Saizan> *properly
15:56:32 <Saizan> haskell' has always been about standardizing what's already implemented, though
15:57:03 <Gracenotes> Saizan: is that part of the famous ML module system?
15:57:15 <chrisdone> Saizan: what kind of behaviour do you give to your fake IO functions?
15:57:20 <mmorrow> pumpkin_: hmm, i guess that patch very well could have made an assumption which isn't always true
15:57:30 <pumpkin_> mmorrow: that alignment == sizeof in all cases?
15:57:31 <pumpkin_> I guess
15:57:57 <pumpkin_> I'm doubting myself mostly because I don't have a way of testing what he says is the issue, that too much memory is being allocated
15:58:02 <mmorrow> i dunno
15:58:25 <skorpan> what is this "TH" that people speak of in cafe?
15:58:31 <chrisdone> template haskell
15:58:33 <mmorrow> template-haskell
15:58:52 <mmorrow> , [|\x->x|]
15:58:53 <Saizan> chrisdone: in my case the primitives are about manipulating files, so i just have a State (Map FilePath Content) and edit that like a filesystem
15:58:55 <lunabot>  LamE [VarP x_0] (VarE x_0)
15:58:58 <Saizan> Gracenotes: right
15:59:02 <mmorrow> , $([|\x->x|]) 42
15:59:03 <lunabot>  42
15:59:19 <skorpan> is that TH?
15:59:22 <mmorrow> , $([ |42|] )
15:59:23 <lunabot>  luna: parse error on input `|'
15:59:23 <mmorrow> yes
15:59:28 <mmorrow> , $([| 42|] )
15:59:29 <lunabot>  42
15:59:46 <skorpan> looks weird
15:59:49 <mmorrow> heh
16:00:06 <mmorrow> it lets you construct the AST for haskell code at compile-time
16:00:13 <mmorrow> and use haskell to do it
16:00:50 <skorpan> cool
16:00:53 <mmorrow> so you can programmatically generate/derive/whatever code for various purposes
16:01:08 <skorpan> and i suppose this is often used as a sort of optimization?
16:01:26 <monochrom> you could but I don't think anyone does it yet.
16:01:33 <pumpkin_> oh sweet, I can get darcs with cabal-install
16:01:35 <mmorrow> so for instance, you can auto-derive instances, or generate FFI import/export decls, or optimize/specialize code, ...
16:01:48 <Saizan> the most common use is to avoid writing boilerplate
16:01:52 <chrisdone> Saizan: right, that seems reasonable. have you thought about how to make a kind of story board for your IO functions? let's say I want to give completely random input (like QuickCheck inputs) to my IO functions. but of course then the program just won't ever get started. so you have to incrementally say "this works right" and then start providing it valid data. otherwise you could run 1000 tests and still never completely test the
16:01:52 <chrisdone> program because it never gets past the first step. do you follow me?
16:01:53 <monochrom> more people use it to replace repetitive work.
16:01:53 <mmorrow> and you can do IO with TH too, so that opens up huge possibilities
16:01:59 <pumpkin_> like playing movies
16:02:09 <monochrom> hehe
16:10:51 <eu-prleu-peupeu> :/
16:10:54 <pumpkin_> mmorrow: alright, I've convinced myself that I'm right
16:11:00 * pumpkin_ applauds himself
16:11:16 <eu-prleu-peupeu> i wish i could understand the opengl binding
16:11:26 <pumpkin_> eu-prleu-peupeu: you can wish, or you can do :)
16:11:30 <eu-prleu-peupeu> is the $= like an accessor to a state monad ?
16:11:57 <eu-prleu-peupeu> eh
16:12:10 <eu-prleu-peupeu> anyway, i only need to set a very small ammount of state, the rest will be shaders
16:13:09 <chrisdone> dons: http://www.cse.unsw.edu.au/~dons/images/notprogramming.png
16:13:20 <chrisdone> dons: I said this a while ago. I noticed the exact same thing. very annoying
16:13:58 <pumpkin_> mmorrow, dons: woot, I got all the uvector tests to pass :)
16:14:12 <Saizan> chrisdone: have you looked at MonadPrompt?
16:14:37 <dons> pumpkin_: well done
16:14:39 <dons> chrisdone: haha
16:14:53 <dons> i don't care anymore. however, i think a reminder now and again in simple form can't hurt
16:15:05 <dons> btw, anyone like the haskell reddit logo? http://www.reddit.com/r/haskell/ :)
16:15:14 <pumpkin_> it's cute :)
16:15:15 <Gracenotes> :D
16:15:21 <Gracenotes> FUCK YEAH HASKELL
16:15:23 <dons> :)
16:15:59 <pumpkin_> the latest working version is up at http://patch-tag.com:5003/publicrepos/pumpkin-uvector
16:16:57 <chrisdone> Saizan: no, I will
16:17:17 <chrisdone> dons: haha, very good
16:17:18 <Gracenotes> hm... It's convenient using a ReaderT to pass around an MVar, but I'd also like to the use the MVar outside of the ReaderT, so it nearly seems against the point of using the monad in the first place :\
16:17:25 <Saizan> chrisdone: the thread on -cafe about it started with something very similar to what you described
16:17:37 <chrisdone> Saizan: sounds very interesting, I'll look for it
16:22:03 <BONUS> managed to kind of grok the "An Extensible Dynamically-Typed Hierarchy of Exceptions" paper. the combiation of existentials and typeables to achieve an exception hierarchy is simply genius
16:23:41 <Cale> It seems like a good idea, but in practice I've found the new exceptions to be annoying.
16:24:13 <BONUS> ah, haven't tried it too much in practice as of yet
16:24:33 <Cale> You basically can't do anything without providing explicit type signatures for your exception handlers
16:24:46 <Cale> which makes the infix `catch` style of things basically impossible
16:25:02 <BONUS> although it seems cool to be able to catch exceptions easily and defining new ones that aren't hierarchical but just direct sons of SomeExceptions seems simple enough
16:26:32 <pgs31> Hello Haskellers!
16:26:38 <BONUS> hallo
16:26:47 <pgs31> I am making my first venture into your murky world..
16:26:56 <pgs31> and have got myself a bit stuck
16:27:06 <BONUS> what seems to be the problem
16:27:10 <skorpan> is it possible to ban people from the mailing list?
16:27:22 <pgs31> have you used data.binary?
16:27:38 <pgs31> I have got a binary file which is a list of pairs of doubles
16:27:38 <roconnor> > sqrt (0.9*1.3)
16:27:39 <lambdabot>   1.0816653826391969
16:27:58 <pgs31> I can read them out as Word32s or Word64s
16:28:11 <pgs31> but am struggling to correctly read them as double
16:28:31 <pgs31> I've spent all day in the data.binary source and have got myself a bit lost ;)
16:28:47 <BONUS> try using fromIntegral
16:28:49 <BONUS> for instance
16:29:01 <BONUS> let's say we have a number that's of the type Word32
16:29:06 <BONUS> > 100 :: Word32
16:29:06 <pgs31> so that will take a nice integer number and make it into a float, right
16:29:07 <lambdabot>   100
16:29:28 <pgs31> but would that actually use the rights bits of the double to give it its correct value?
16:29:32 <BONUS> fromIntegral takes any integral type (like Word32) and converts it into another numberic type
16:29:51 <BONUS> > fromIntegral (100 :: Word32) :: Double
16:29:53 <lambdabot>   100.0
16:30:25 <pgs31> cool
16:30:28 <BONUS> depends on how you have the numbers represented in your file
16:30:48 <pilkarn> hmm the haskell way of pure and impure division fo a program makes so much sense. there must be a lot less ways a program can branch and you have them all in once or a few places whereas a Java program can blow anywhere. somehow haskell feels more honest. you pass things around explicitly instead of behind your back. it makes the whole program more see-through.
16:30:50 <pgs31> The numbers are just doubles dumped from memory from a C program
16:30:58 <dons> http://www.haskell.org/pipermail/haskell-cafe/2009-February/056368.html
16:32:07 <pumpkin_> *cheer*
16:32:18 <pgs31> BONUS: ooh it looks like that might work
16:32:40 <pumpkin_> although it would've been nice if someone other than dons had done it, because now bulat will just get even more antagonistic to dons
16:33:01 <pgs31> I had assumed that it was just for making integers like 42 into 42.0, but not actually reinterpreting what the bits mean ;)
16:33:03 <BONUS> pgs31: i dont know the details of your problem, but it might do the trick :]
16:33:26 <pgs31> hehe it's a long story
16:34:12 <pgs31> I've been pestering dcoutts about it (he's a friend of mine from doing silly pantos)
16:34:46 * pgs31 waves at dcoutts
16:35:13 <BONUS> i mean if it's an IEEE754 double in binary form then you can't just use fromIntegral
16:35:43 <BONUS> re: bulat - http://i39.tinypic.com/mr4to2.jpg <- first time i've had this happen haha
16:35:55 <pgs31> ah
16:36:00 <pgs31> that is what it is likely to be
16:37:24 <pgs31> Does this mean I have to write my own equivialant of getWord32be
16:37:27 <dons> pumpkin_: yeah, i know. igloo's come up with a better solution
16:37:50 <BONUS> ah hmm ... i dont know of an easy way of transforming a field of bits that represent an IEE754 number into a double
16:38:02 <pgs31> Somebody must have done this sort of thing before, but I can't find much online
16:38:03 <BONUS> short of making an IEEE754 implementation yourself
16:38:19 <pgs31> Does haskell not store doubles internally in that format?
16:38:46 <chessguy> this is so freaking stupid
16:38:48 <chessguy> if people are still interested enough in a thread on -cafe to be contributing to it, why should a few people unilaterally decide that the thread needs to be blocked?
16:39:12 <dolio> What format are the bits in initially?
16:39:15 <dolio> bytestring?
16:39:24 <pgs31> that is how I am reading them
16:39:27 <chessguy> i personally could care less about that particular thread either way, but i think it's been handled horrendously
16:39:46 <dolio> Binary might have a proper implementation for that.
16:39:56 <dolio> Otherwise you can read them into a Word64 and unsafeCoerce.
16:39:57 <pgs31> but the file itself is just literally a dump of a C array of doubles.
16:40:12 <dolio> Which is evil, but it'd probably work.
16:40:14 <dons> chessguy: because, like IRC, its not a free-forall
16:40:25 <chessguy> dons:  fine, then define the rules
16:40:26 <pgs31> dolio: ohh I've not come across that function before
16:40:32 <dons> http://haskell.org/haskellwiki/Protect_the_community
16:40:32 <chessguy> dons:  i'm not opposed to rules
16:40:37 <chessguy> those aren't rules
16:40:44 <pgs31> dolio: I've looked all through the Get.hs source file
16:40:48 <dons> i know, we've never tried to do this on mailing lists before
16:40:53 <chessguy> they're vague guidelines
16:40:55 <dons> that's the only stuff i have, other than the IRC
16:40:57 <dons> rules
16:41:07 <pgs31> lots of things for getting words of different lengths and endianness, but no mention of doubles ;)
16:41:10 <dons> maybe we can come up with some rules now
16:41:24 <chessguy> dons:  fine, but they should be decided on as a community
16:41:29 <dons> yep.
16:41:35 <dolio> Ah. Well, I admit I've not used it with Doubles at all.
16:41:49 <pgs31> ahh well, thank you for the tip
16:41:58 <pgs31> I will try this unsafeCorece of which you speak
16:42:02 <chessguy> dons:  for the first rule, i propose "if a thread has sparked enough interest that lots of people are still contributing to it, it shall not be muted" :)
16:42:05 <dons> bulat's not realised the thread is blocked. he's still posting 1 a minute
16:42:16 <dons> chessguy: contributing /= nooise
16:42:19 <RayNbow> btw dons, are the pdfs useful?
16:42:21 <chessguy> so?
16:42:24 <chessguy> who cares?
16:42:33 <dons> see earlier link.
16:42:36 <chessguy> there are ways to not hear the noise
16:42:41 <dons> once you start driving people away, we're screwed
16:42:41 <skorpan> i think it's been pretty entertaining with some heat in the cafe
16:43:01 <dolio> pgs31: Double is an instance of Binary, by the way. You might want to try that first.
16:43:18 <chessguy> dons: once you start muting discussions people are interested, we're also screwed
16:43:24 <chessguy> s/you/we/
16:43:34 <dons> yep. did it run its course, do you think?
16:43:40 <chessguy> clearly not
16:43:41 <dons> if there's some thread to tease out, you can start a new discussion on it
16:43:50 <dons> well, bulat hasn't run his course
16:43:53 <chessguy> if it had run its course, people would have stopped contributing
16:43:53 <dons> not sure if the content has
16:44:04 <dons> ok. we'll let bulat keep flaming everything that pops up
16:44:11 <tehgeekmeister> why do we use list for nondeterministic computations instead of Data.Set?  just out of curiousity.
16:44:12 <dons> actually, wait, no.
16:44:12 <pgs31> dolio: I saw that, but my haskell skills have let me down
16:44:15 * chessguy shrugs
16:44:22 <pgs31> dons: there's no nice getDouble method in get.hs
16:44:24 <chessguy> if he's not being obscene or rude
16:44:28 <dons> ah
16:44:28 <Cale> tehgeekmeister: Because it's an instance of Monad
16:44:30 <tehgeekmeister> the ZipList usage of list seems to be more natural an interpretation of list to me
16:44:33 <pgs31> How do I make a Get monad to read it?
16:44:33 <dons> pgs31: yeah
16:44:36 <chessguy> (i haven't actually read the thread for a while)
16:44:38 <dons> pgs31: we could do 'host doubles'
16:44:43 <dolio> pgs31: Doesn't look like it's straight writing the bytes, though.
16:44:47 <dons> but otherwise we need a decent ieee encoding/decoding
16:45:10 <tehgeekmeister> Cale: right, but i'm saying why not define Data.Set to be that same sort of monad?
16:45:12 <Igloo> dons: Huh? Bulat's only posted twice
16:45:18 * pgs31 rubs his chin
16:45:24 <chessguy> dons:  also, is it possible to mute sub-threads?
16:45:31 <dons> Igloo: yeah. he's so busy replying he's not seen the thread has halted
16:45:33 <tehgeekmeister> because lists are already used a lot more?
16:45:38 <dons> chessguy: i think so.
16:45:54 <chessguy> dons:  i would reach for that option LONG before muting the whole thread
16:45:56 <Cale> tehgeekmeister: Try it and see ;)
16:46:01 <dolio> pgs31: Word64 is straight bytes, though.
16:46:03 <Igloo> chessguy: On certain topics, people will keep saying "Yes it is" "No it isn't" forever
16:46:04 <dons> these are all good ideas.
16:46:07 <Cale> tehgeekmeister: The trouble is that Set operations need Ord
16:46:13 <tehgeekmeister> Cale: oh right
16:46:20 <Cale> tehgeekmeister: and >>= doesn't allow you to assume there's an Ord instance
16:46:23 * tehgeekmeister is reading the typeclassopedia right now
16:46:25 <pgs31> dolio: so read it as a word64
16:46:35 <tehgeekmeister> i'm learning so much that i wish had been covered in the other haskell tutorials i'd read.
16:46:38 <Igloo> chessguy: What's easy, and even what's possible, are limited with the tools we have available
16:47:00 <tehgeekmeister> Cale: that's because of the implementation of Data.Set as a tree, right?
16:47:06 <pgs31> Then I have a nice word64, what is the magic to convince that it is a Double?
16:47:12 <chessguy> Igloo:  understood. and the rules should be written in terms of those tools
16:47:15 <dons> what's bizarre is that we've never really tried to improve the signal/noise on haskell-cafe
16:47:17 <Cale> tehgeekmeister: Yes, which is what makes access more efficient.
16:47:20 <Igloo> chessguy: Also, if people having something new and interesting to say, they can start a new thread. Hopefully they won't do so just to continue the argument, though
16:47:25 <dons> despite good contributors leaving all over
16:47:25 <tehgeekmeister> Cale: okay
16:47:28 <BONUS> haha the haskell facebook page has only 145 members tsk tsk
16:47:30 <Cale> tehgeekmeister: Also you need at least Eq for a set implementation.
16:47:40 <Cale> tehgeekmeister: So it might as well be Ord.
16:48:02 <chessguy> dons:  another instance of the curse of success? :)
16:48:03 <tehgeekmeister> BONUS: make that 146, now!
16:48:07 <BONUS> hehe
16:48:09 <Cale> tehgeekmeister: The other reason that we use lists is that lists deal better with cases where there are extremely large numbers of possibilities.
16:48:22 <Cale> tehgeekmeister: Because they are lazy :)
16:48:34 <thesz> A generic question (or a question about generics). I have a class Size a where { sizeOf :: a -> Int}. (fmap sizeOf . cast) don't typecheck, while (fmap show . cast) does.
16:48:38 <Raynes> BONUS: Probably because no one knows about the Haskell facebook page. And a lot of programmers don't give a shit about facebook (me)
16:48:43 <thesz> Why? (ghc 6.10.1)
16:48:47 <BONUS> also if you have something that can be Eq, chances are that it can be made an Ord, even if not in a very meaningful way
16:48:51 <tehgeekmeister> Cale: and i'm not sure how often the ZipList interpretation would be used compared to that, really...
16:48:52 <Cale> tehgeekmeister: Sets, by the nature of the tree balancing, are strict.
16:49:03 <Cale> ZipList isn't a monad even...
16:49:06 <Cale> yeah
16:49:16 <Cale> and it's not as common a thing to want
16:49:28 <redditbot> Functional Reactive Programming: Tying together a few recent experiments
16:49:38 <tehgeekmeister> yeah, i haven't gotten past applicative yet in the typeclassopedia
16:49:43 <monochrom> social websites erode privacy.
16:49:44 <raxas> facebook is for people who can't understand irc
16:49:47 <tehgeekmeister> so i am not quite up on monads yet, 'cept knowing how to use them
16:49:48 <dolio> pgs31: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=1614#a1614
16:49:51 <BONUS> why doesnt redditbot give links aghh
16:49:51 <Raynes> raxas: Right on.
16:50:08 <tehgeekmeister> raxas: or people who like to interface with people who don't understand/use irc
16:50:44 <monochrom> That goes without saying.
16:51:21 <monochrom> It's implied by the "for", e.g., "I'm doing it _for_ you!"
16:51:32 <idnar> it's not /for/ you!
16:51:38 <Raynes> tehgeekmeister: "Interface with" Stop using those OOP words. They are swear words.
16:51:43 <pgs31> dolio oohh thanks, I just tried the unsafeCoerce and got some strange numbers out ;)
16:51:46 <monochrom> hahahaha
16:52:04 <pilkarn> is Xwindows the way to go for making haskell guis? can you make games in xWindows? does it nteract with opengl?
16:52:07 <tehgeekmeister> Raynes: i swear i didn't get that from OOP!
16:52:26 <Axman6> pilkarn: gtk2hs usually
16:52:28 <monochrom> ∞P
16:52:33 <idnar> "interface" predates OOP by a pretty long while
16:52:43 <raxas> however, for past decades, comparatively to other languages mlists (with which cafe is comparable), cafe is distinguishedly civilized
16:52:45 <raxas> it is so almost perfect I believe any regulation could make it's status only worse
16:53:09 <pilkarn> NromalLanguageInterface extends JavaInterface {100K LOC }
16:53:09 <monochrom> Yeah it dates back to "interfacing with Dr. Frankenstein's creature"  <duck>
16:53:13 <idnar> I don't know of any other language lists similar to haskell-cafe
16:53:34 <Axman6> raxas: did you see the ghc vs gcc thread?
16:53:47 <tehgeekmeister> @type pure (+)
16:53:48 <lambdabot> forall a (f :: * -> *). (Applicative f, Num a) => f (a -> a -> a)
16:53:54 <monochrom> ghc-gcc = g(h-c)c.
16:54:09 <tehgeekmeister> @type pure (+) <*>
16:54:10 <lambdabot> parse error (possibly incorrect indentation)
16:54:16 <Raynes> idnar: The term "interface" predates programming in general. Interface can easily be linked with OOP now-a-days.
16:54:33 <idnar> Raynes: that's just silly
16:54:52 <dolio> pgs31: I make no guarantees about whether that will actually work cross platform and whatnot. :)
16:54:54 <tehgeekmeister> @type (+)  <$>
16:54:55 <lambdabot> parse error (possibly incorrect indentation)
16:55:00 <tehgeekmeister> @type <$>
16:55:01 <lambdabot> parse error on input `<$>'
16:55:17 <tehgeekmeister> @type (<$>)
16:55:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:55:21 <ddarius> idnar: OOP is pretty old.
16:55:36 <idnar> Raynes: what should I call a "user interface" then?
16:55:55 <Axman6> a user ooperface
16:56:03 <Raynes> idnar: I /directly/ related my comment to OOP, explain how anyone could miss my pun?
16:56:08 <tehgeekmeister> @type (+) <$> [2,3,4]
16:56:09 <lambdabot> forall a. (Num a) => [a -> a]
16:56:13 <Raynes> idnar: Stop trying to be an asshole. :|
16:56:24 <tehgeekmeister> @type (<*>)
16:56:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:56:42 <idnar> Raynes: sorry, I thought you were being serious
16:56:53 <tehgeekmeister> wow, applicative is cool
16:56:54 * Raynes hugs idnar
16:57:07 <raxas> Axman6: I have seen much worse things on c++ boost ml long time ago :)
16:57:16 * Raynes waves to everyone and heads off to bed.
16:57:21 <Axman6> raxas: :)
16:57:27 <Axman6> night Raynes
16:57:39 <Ralith> hey guys, I'm having trouble with my plugin system
16:57:42 <Ralith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1615#a1615
16:57:51 <Ralith>     Couldn't match expected type `IO b'
16:57:51 <Ralith>            against inferred type `[IO ThreadId]'
16:58:02 <Ralith> on line 6 of the paste
16:58:47 <monochrom> use mapM_ instead of map, maybe?
16:59:08 <cytzol> what's the type of dispatch?
16:59:38 * monochrom admits not having looked at the code. But the error message occurs frequently lately.
16:59:47 <Ralith> that worked.
16:59:54 <Ralith> dispatch :: a1 -> [a1 -> a -> IO ()] -> a -> IO ()
16:59:55 <Axman6> :t mapM putStrLn
16:59:56 <lambdabot> [String] -> IO [()]
17:00:18 <Ralith> thanks!
17:00:29 <Axman6> :t mapM_ putStrLn
17:00:30 <lambdabot> [String] -> IO ()
17:01:20 <Ralith> cytzol: that type is after using mapM_, mind
17:01:30 <Ralith> also
17:01:41 <Ralith> will mapM_ (forkIO$) do what I think it will?
17:01:48 <Ralith> i.e. evaluate all the funcs in the argument in parallel
17:02:09 <Axman6> possibly... but i'd use parMAp
17:02:13 <Axman6> parMap*
17:02:41 <Ralith> what's that do?
17:02:43 <Ralith> :t parMap
17:02:44 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
17:02:55 <monochrom> mapM_ (forkIO $) will do what you think it will.
17:03:08 <Ralith> yay!
17:03:13 <pumpkin_> why do you need $ there?
17:03:16 <monochrom> parMap is useful for non-IO things.
17:03:19 <Axman6> parMap is like map, but it'll map in parallel
17:03:30 <monochrom> Oh haha, $ can be omitted, yeah.
17:03:31 <Ralith> pumpkin_: good question
17:03:41 <pumpkin_> :)
17:03:49 <pumpkin_> nice thing about parMap is that you have fancy strategies too
17:03:55 <Ralith> like what?
17:04:01 <pumpkin_> like break the list into chunks
17:04:02 <monochrom> If you have threads that emphatically do IO, parMap doesn't help.
17:04:09 <pumpkin_> oh yeah
17:04:18 <pumpkin_> I didn't know what the situation was :)
17:04:21 <pumpkin_> I just got back
17:04:26 <dons> monochrom: well, we could use parMap on io , for interleaved io fun :)
17:04:50 <Ralith> well, my threads are all likely (although not guaranteed) to do IO, so I think I'll stick with what I've got
17:05:17 <Ralith> thanks again
17:05:26 <cytzol> quit
17:05:29 <cytzol> whoops
17:05:43 <pumpkin_> Ralith: mmorrow wrote an awesome parMapN_ too :)
17:05:55 <tehgeekmeister> @type (<*>)
17:05:56 <Ralith> N?
17:05:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:06:00 <pumpkin_> Ralith: takes a list of IOs and runs n of them at a time
17:06:03 <tehgeekmeister> @type (>>=)
17:06:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:06:07 <pumpkin_> as soon as one finishes another one starts
17:06:13 <Ralith> hehe, neat
17:06:19 <tehgeekmeister> @type (=<<)
17:06:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:06:23 <Ralith> I don't see any reason not to run all of mine at the same time, though
17:06:27 <Axman6> pumpkin_: using MVars?
17:06:31 <Ralith> and mapM_ seems to do that
17:06:31 <pumpkin_> Axman6: yeah
17:06:38 <Axman6> nice
17:06:48 <Ralith> haskell is addictive
17:06:50 <dons> we need an NFData IO
17:06:51 <pumpkin_> Ralith: fair enough :)
17:06:53 <Ralith> I have not had this much fun programming ever
17:07:04 <pumpkin_> unsafePerformIO?
17:08:34 <idnar> unsafeExplodeBrain
17:10:11 <tehgeekmeister> aw there's a sentence that just cuts off in the middle in typeclassopedia
17:11:49 <lhoersten> sup archwild1
17:12:06 <monochrom> pair troll
17:12:15 <archwild1> hello
17:12:37 <dons> monochrom: do we need ops?
17:13:26 <Sekaino> Hey guys, where can I find a good QuickCheck tutorial/reference that deals with how to make instances of Arbitrary effectively?
17:13:47 <monochrom> I'm just applying my highly accurate heuristic. No strong evidence yet.
17:14:05 <idnar> tehgeekmeister: perhaps they said candlejack while th
17:14:09 <archwild1> I have a question about defining my own infix function, in this bit of code: http://pastebin.com/d1ca4be00, why does the first function (initials) not compile, while the second function (+++) does?
17:14:18 <dons> Sekaino: hmm. RWH?
17:14:22 <dons> chapter .. 13, iirc
17:14:29 <Sekaino> Thanks dons
17:14:31 <dobblego> Sekaino, just use the fact that Arbitrary is a type-class (therefore instance) and a Monad -- therefore, creating your own from existing values is done accordingly
17:15:15 <tehgeekmeister> idnar: no, something about how _ >> m = m would be a type correct implementation of (>>)
17:15:23 <tehgeekmeister> idnar: but the sentence never finishes.
17:17:14 <libre> i read on the net that installing and using haskell on debian is a pain compared to other linux distros.. is this true? it doesnt make sense.
17:17:44 <chrisdone> it was easy on ubuntu, if that tells you anything
17:18:07 <gwern> Sekaino: actually I just read the chapter of RWH which covers that reasonably well
17:18:07 <saml> https://svn.cs.uu.nl:12443/repos/EHC/trunk/EHC/src/ehc/Silly/ToLLVM.cag
17:18:10 <gwern> Sekaino: so look there
17:18:29 <chrisdone> archwild1: the () syntax is only for operators. "initials" is not an operator
17:18:38 <saml> do you think that code uses LLVM ? or is it hand generating llvm assembly?
17:18:39 <Sekaino> gwem, do you remember which chapter it was?
17:18:59 <archwild1> libre, this did it for me (Ubuntu):  apt-get install ghc6 libghc6-mtl-dev
17:19:07 <lhoersten> chrisdone: so you can't make your own operators, only inifx functions?
17:19:11 <alatter> archwild1: also, if you want to use a function as infix which doesn't begin with symbols, you need to enclose it in back-quotes
17:19:27 <libre> chris and arch it was installed on my debian with xmonad without problems but i havent used it yet.
17:19:27 <tehgeekmeister> libre: i have it on a debian system no problem.
17:19:42 <libre> how about using it tehgeek?
17:19:48 <tehgeekmeister> works fine
17:19:57 <Sekaino> Ah found it, nevermind.
17:19:58 <tehgeekmeister> i think it's lenny i'm on?  not sure.
17:19:59 <chrisdone> lhoersten: what is an operator?
17:20:21 <lhoersten> (07:18:29 PM) chrisdone: archwild1: the () syntax is only for operators. "initials" is not an operator
17:20:26 <libre> yes so that person who wrote that must have had a messy installation
17:20:39 <tehgeekmeister> yeah, it works just fine.
17:20:40 <alatter> lhoersten: I think chrisdone was being socratic ...
17:20:56 <tehgeekmeister> note, however, that ghc has some evil problems running under certain versions of xen
17:20:57 <libre> thanks for all your feedback
17:20:59 <lhoersten> i dont understand
17:21:16 <chrisdone> lhoersten: can you tell me what you mean by an operator?
17:21:27 <lhoersten> chrisdone: whatever you meant by operator
17:21:31 <alatter> ^_^
17:22:06 <fsanches> does Haskell have operators? I thought it only had reserved words
17:22:19 <lhoersten> fsanches: that's what i'm trying to figure out
17:22:26 <tehgeekmeister> haskell has infix functions
17:22:29 <tehgeekmeister> you can define your own
17:22:34 <archwild1> +++ and 'initials' didn't exist before I defined them - why does the one work and the other doesn't (both defined as infix operators)
17:22:37 <tehgeekmeister> that's what (i think) everyone is meaning by operators
17:22:39 <lhoersten> so is (+) an infix funciton?
17:22:51 <tehgeekmeister> yep!
17:22:55 <tehgeekmeister> @info (+)
17:22:55 <lambdabot> (+)
17:23:00 <monochrom> "function" is a special case of "operator"
17:23:08 <lhoersten> then why is (+++) allowed?
17:23:08 <tehgeekmeister> lambdabot doesn't give fixity info?
17:23:19 <dons> the only vaguely 'built in' operator is (:) and whitespace, i guess
17:23:23 <alatter> archwild1: you need to use backquotes when using a regular name in the infix position
17:23:28 <dons> unary (-) is a bit magic too
17:23:40 <EvilTerran> > 7 `divMod` 3
17:23:48 <monochrom> > not `map` [True, False]
17:23:54 <EvilTerran> ?bot
17:23:54 <lhoersten> so if the name starts with a symbol, can you make it infixed with the () syntax?
17:23:58 <tehgeekmeister> dons: that's defined as function?  i'd figure it'd just be part of the syntax.
17:23:58 <lambdabot>   thread killed
17:23:58 <lambdabot> :)
17:24:04 <lambdabot>   thread killed
17:24:06 <EvilTerran> , 7 `divMod` 3
17:24:08 <lunabot>  (2,1)
17:24:09 <monochrom> eww
17:24:11 <tehgeekmeister> lhoersten: you make it infix with a fixity declaration
17:24:22 <tehgeekmeister> @src (+)
17:24:23 <lambdabot> Source not found. Do you think like you type?
17:24:27 <alatter> lhoersten: if a name starts with a symbol, you make it non-infix with parens
17:24:29 <tehgeekmeister> @src (++)
17:24:31 <EvilTerran> , (`divMod`) 7 3 -- divMod made infix, made prefix again
17:24:31 <lhoersten> tehgeekmeister: we didn't have to do that with (+++)
17:24:32 <lunabot>  luna: parse error on input `)'
17:24:32 <lambdabot> []     ++ ys = ys
17:24:32 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:24:32 <lambdabot> -- OR
17:24:32 <lambdabot> xs ++ ys = foldr (:) ys xs
17:24:37 <EvilTerran> , (`divMod`) 7 3 {- divMod made infix, made prefix again -}
17:24:37 <alatter> lhoersten:  so I can type "(+) 1 1"
17:24:39 <lunabot>  luna: parse error on input `)'
17:24:43 <EvilTerran> grr
17:25:02 <monochrom> > {- this defines an operator and uses it -} let x+++y = x*y+1 in 4+++5
17:25:06 <lambdabot>   21
17:25:06 <lhoersten> please stop doing the bot thing. I have an interpreter open
17:25:06 <tehgeekmeister> lhoersten: oh, i guess ghc gives you a default fixity.  but you'd probably want to set one anyway.  just so you know what you've got.
17:25:24 <EvilTerran> tehgeekmeister, it defaults to infixl 9, i believe
17:25:30 <chrisdone> a function can be named by alphanumeric characters, or by symbols, the former is an identifier, the latter is an operator symbol
17:25:48 <lhoersten> i tried a fixity declaration and it still didn't allow me to use () notation in the type declaration like I was able to with (+++)
17:26:03 <Axman6> lhoersten: we always use lambdabot
17:26:14 <EvilTerran> lhoersten, what exactly did you try?
17:26:14 <lhoersten> also... what is a fixity declaration? a function or a special keyword or something?
17:26:17 <alatter> lhoersten: that's because the parens in the type decaration only works for symbols
17:26:34 <lhoersten> alatter: entirely of symbols... got it =) thanks
17:26:50 <alatter> lhoersten: np.
17:26:51 <chrisdone> alatter: despite being effective generally, socratic questioning on busy IRC channels generally fails sadly
17:26:56 <monochrom> You write x+++y or (+++) x y.  Don't write x(+++)y.
17:26:58 <tehgeekmeister> does anyone happen to know if SICP covers continuations at all?  out of curiousity
17:27:13 <alatter> chrisdone:  apparently :-)
17:28:13 <lhoersten> so an operator in haskell is a special case of a function where its name is comprised entirely of symbols?
17:28:30 <dons> yeah
17:28:37 <lhoersten> is the infixr a special function then or how is it seen to the compiler
17:28:38 <chrisdone> that's whut ahh seyd
17:28:44 <lhoersten> no
17:28:50 <dons> infixr is a bit of syntax to help the parser
17:29:13 <pgs31> dolio: we have success, thanks ever so much!
17:29:14 <ddarius> tehgeekmeister: I don't think it does, but it's been a long time.
17:29:17 <chrisdone> tehgeekmeister: I don't recall it, but it might be in there somewhere
17:29:21 <lhoersten> dons: so its not a function or type?
17:29:22 <dolio> No problem.
17:29:24 <dons> right
17:29:26 <lhoersten> thanks
17:29:27 <dons> :t infixr
17:29:30 <lambdabot> parse error on input `infixr'
17:29:32 <lhoersten> yup
17:29:35 <lhoersten> i noticed that
17:29:42 <lhoersten> because it looks like a function
17:29:59 <tehgeekmeister> ddarius, chrisdone: either of you know of another one of those great books that does cover it?  or some great tutorial about them?  i've been trying to wrap my head around them for a long time now.
17:30:00 <Axman6> lambdabot: if you cheecked the hackell standard, you'd see it's one of the reserved words for the language, like case, of, module etc.
17:30:00 <monochrom> I said the other way round. function is special case of operator.
17:31:06 <monochrom> hackell :)
17:31:21 <chrisdone> > Just 1 >>= return
17:31:24 <lambdabot>   Just 1
17:31:26 <chrisdone> ^ is return a continuation?
17:31:46 <monochrom> I bet no.
17:32:14 <alatter> I bet yes.  because the RHS of (>>=) is usually wirten 'k'  :-)
17:32:28 <chrisdone> tehgeekmeister: I can't remember where I learned continuations from
17:32:42 <monochrom> I think I lost. :)
17:32:46 <pgs31> dolio: Next challenge, turning a double which means "number of seconds since 7pm 31Dec69" into a sensible time/date format! joy.
17:32:49 <lhoersten> how many other keywords like "infixr"?
17:32:54 <idnar> @type let ?r = return in Just 1 >>= ?r
17:32:55 <lambdabot> forall b. (Num b) => Maybe b
17:33:03 <lhoersten> infixr is kinda like a macro which modifies the AST?
17:33:04 <idnar> meh, no
17:33:08 <pgs31> dolio: But I will have a go at that myself before I come back to bother ya'll ;)
17:33:17 <idnar> @type Just 1 >>= (return `asTypeOf` ?x)
17:33:18 <dolio> :)
17:33:19 <lambdabot> forall a. (?x::a -> Maybe a, Num a) => Maybe a
17:33:44 <chrisdone> just look at the type of (>>=)
17:33:48 <chrisdone> :t (>>=)
17:33:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:34:12 <tehgeekmeister> @type (\f -> join . fmap f)
17:34:14 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f a) -> f a1 -> f a
17:34:31 <tehgeekmeister> heh!  i just made bind.
17:34:32 <idnar> @type (\f -> join . liftM f)
17:34:34 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
17:34:54 <idnar> @pl (\f -> join . liftM f)
17:34:54 <lambdabot> (=<<)
17:34:59 <tehgeekmeister> well, i made =<<
17:35:08 <bigua> hi im writing a prog in haskell this if you type [3] its return [3,3,3,]
17:35:09 <idnar> @pl (\f -> join . fmap f)
17:35:09 <lambdabot> (=<<)
17:35:10 <tehgeekmeister> close enough
17:35:11 <chrisdone> you made flip (>>=) :P
17:35:39 <tehgeekmeister> @type (\m f -> join . fmap f m)
17:35:40 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a2 -> a1) -> (a1 -> m (m a)) -> a2 -> m a
17:35:55 <chrisdone> bigua: why?
17:35:58 <tehgeekmeister> @type (\m f -> join $ fmap f m)
17:36:00 <lambdabot> forall (m :: * -> *) a a1. (Functor m, Monad m) => m a1 -> (a1 -> m a) -> m a
17:36:03 <tehgeekmeister> there!
17:36:05 <tehgeekmeister> bind.
17:36:12 <bigua> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1513#a1513
17:36:12 <chrisdone> @src join
17:36:12 <lambdabot> join x =  x >>= id
17:36:21 <chrisdone> you defined bind in terms of bind :P
17:36:23 <bigua> chrisdone its my code and didnt working ;[
17:36:37 <tehgeekmeister> chrisdone: yeah, but the typeclassopedia told me to.  i can't help if it gave me a silly exercise.
17:37:33 <tehgeekmeister> can you use <*> in place of ap in an arbitrary monad?
17:37:51 <tehgeekmeister> or are there some monads that are not instances of Applicative for some reason or another?
17:38:00 <chrisdone> the monad would have to implement Applicative
17:38:08 <chrisdone> :t <*>
17:38:10 <lambdabot> parse error on input `<*>'
17:38:13 <chrisdone> :t (<*>)
17:38:14 <Axman6> all monads should be afaik, but whether they are in a different matter
17:38:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:38:14 <pumpkin_> moo
17:38:23 <tehgeekmeister> i'd expect most would, by default
17:38:33 <tehgeekmeister> hopefully all?
17:38:43 <chrisdone> a few surprisingly don't
17:38:54 <chrisdone> but it's easy to define instances for them, so not a big deal
17:39:11 <tehgeekmeister> @src sequence
17:39:11 <lambdabot> sequence []     = return []
17:39:11 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:39:11 <lambdabot> --OR
17:39:11 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:39:32 <chrisdone> :t sequenceA -- ❤♥❤
17:39:34 <lambdabot> Not in scope: `sequenceA'
17:39:39 <chrisdone> wat
17:39:49 <chrisdone> :hoogle sequenceA
17:39:53 <chrisdone> @hoogle sequenceA
17:39:53 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
17:39:53 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
17:39:58 <tehgeekmeister> sequence can't be done with foldl (>>)?
17:40:03 <tehgeekmeister> @type foldl (>>)
17:40:05 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [m b] -> m b
17:40:08 <tehgeekmeister> oh noooo
17:40:11 <tehgeekmeister> that wouldn't do.
17:40:21 <Axman6> @src sequence
17:40:21 <lambdabot> sequence []     = return []
17:40:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:40:21 <lambdabot> --OR
17:40:21 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:40:53 <chrisdone> the latter definition is nice imo
17:41:12 <Axman6> takes some getting used to, but makes sense
17:42:06 <chrisdone> :t unfoldr
17:42:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:42:39 <chrisdone> :t bool
17:42:40 <lambdabot> Not in scope: `bool'
17:43:06 * idnar ponders unfoldM :: (Monad m) => (b -> m (a, b)) -> b -> m a
17:43:10 <ddarius> Axman6: Given the first definition, you can just "pattern match out" the second one.
17:43:18 <idnar> @src unfoldr
17:43:18 <lambdabot> unfoldr f b  = case f b of
17:43:18 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
17:43:18 <lambdabot>    Nothing        -> []
17:43:30 <pumpkin_> moo
17:43:35 <pumpkin_> whoops
17:43:36 <Axman6> ddarius: not sure what you mean
17:43:38 <pumpkin_> I doublecowed
17:43:54 <Axman6> moof!
17:43:56 <idnar> @type maybe
17:43:57 <chrisdone> @let bool false true p v = if p v then true v else false v
17:43:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:43:59 <lambdabot>  Defined.
17:44:04 <chrisdone> :t bool
17:44:06 <lambdabot> forall t t1. (t -> t1) -> (t -> t1) -> (t -> Bool) -> t -> t1
17:44:37 <ddarius> Axman6: Anything of the form: f [] = z; f (x:xs) = ... f ... should suggest a foldr.  It isn't necessarily, but it's a good indication that you should look for one.
17:44:40 <idnar> @type let unfoldr f b = maybe [] (\(a,new_b) -> (a : unfoldr f new_b) in unfoldr
17:44:42 <lambdabot> parse error on input `in'
17:44:49 <idnar> @type let unfoldr f b = maybe [] (\(a,new_b) -> (a : unfoldr f new_b)) in unfoldr
17:44:51 <lambdabot>     Couldn't match expected type `[a]'
17:44:51 <lambdabot>            against inferred type `Maybe (a, t) -> [a]'
17:44:51 <lambdabot>     In the expression: maybe [] (\ (a, new_b) -> (a : unfoldr f new_b))
17:45:17 <ddarius> Axman6: To verify it, you need to see if the only use of 'xs' is of the form 'f xs'.
17:45:22 <defun> hey, how one go about printing colored output to the terminal?
17:45:41 <ddarius> So for sequence we see that the only use of 'xs' is the 'sequence xs' so we have a right fold.
17:45:45 <idnar> @type let unfoldr f b = maybe [] (\(a,new_b) -> (a : unfoldr f new_b)) (f b) in unfoldr
17:45:47 <lambdabot> forall t a. (t -> Maybe (a, t)) -> t -> [a]
17:45:56 <bremner> defun: maybe look at HsColour on hackage
17:46:43 <defun> thanks, mate.
17:47:08 <ddarius> Axman6: So we rewrite: sequence = foldr (\x sequence_xs -> do v <- x; vs <- sequence_xs; return (v:vs)) (return []).  From there simplify.
17:47:29 <Axman6> rightio
17:47:43 <Axman6> sorry, i've not had enough sleep to be taking this all in
17:47:45 <chrisdone> idnar: do you know about arrows?
17:47:53 <chrisdone> @type let unfoldr f b = maybe [] (uncurry (:) . second (unfoldr f)) (f b) in unfoldr
17:47:55 <lambdabot> forall b d. (b -> Maybe (d, b)) -> b -> [d]
17:48:21 <idnar> @type let unfoldM f b = (f b) >>= (\(a,new_b) -> msum [(return a),unfoldM f new_b]) in unfoldM
17:48:23 <lambdabot> forall t (m :: * -> *) t1. (MonadPlus m) => (t -> m (t1, t)) -> t -> m t1
17:49:20 <chrisdone> @type let unfoldr f = maybe [] (uncurry (:) . second (unfoldr f)) . f in unfoldr
17:49:22 <lambdabot> forall a d. (a -> Maybe (d, a)) -> a -> [d]
17:49:25 <idnar> @type let unfoldM f b = (f b) >>= (\(a,new_b) -> (return a) `mplus` unfoldM f new_b) in unfoldM
17:49:27 <lambdabot> forall t (m :: * -> *) t1. (MonadPlus m) => (t -> m (t1, t)) -> t -> m t1
17:49:28 <redditbot> Building a multithreaded web server in Haskell
17:49:28 <redditbot> Haskell Weekly News: February 21, 2009
17:49:32 <idnar> not sure if that does anything useful, though
17:52:05 <Axman6> haha, when did the haskell subreddit get a new ogo?
17:52:05 <Axman6> logo*
17:52:25 <pumpkin_> Axman6: today I think
17:52:34 <Axman6> awesome :)
17:52:43 <pumpkin_> Axman6: I updated my uvector repo :D
17:52:58 <Axman6> nice. is it on hackage by any chance?
17:53:00 <pumpkin_> you should use it in a n-bodies thing
17:53:06 <pumpkin_> Axman6: nope
17:53:28 <pumpkin_> it's no faster or better than the one on hackage though :) just a little more tested and has a couple of minor bugs fixed
17:53:30 * Axman6 thinks you should rename it to pumpkin's uvector, or puvector for short >_>
17:53:33 <pumpkin_> lol
17:53:42 <pumpkin_> most of the code isn't mine :P
17:53:52 * ddarius considers making a box package containing the module Data.Box
17:54:15 <pumpkin_> it would contain alternate implementations of I# and friends? :P
17:54:48 <Axman6> anyone know if there's a binding to gmp? seems there's some things it can do that Integer doesn
17:54:51 <Axman6> t
17:54:58 <Axman6> like, having unsigned integers
17:55:14 <pumpkin_> not that I know of
17:55:24 <ozy`> Axman6: that particular example is not terribly compelling
17:55:26 <sw17ch> @seen dons
17:55:26 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 21m 40s ago.
17:55:27 <ddarius> pumpkin: It would consist of the sole data type, data Box a = Box a deriving ( ... everything under the sun ... )
17:55:35 <tehgeekmeister> ah man is that narwhal the new official logo?
17:55:45 <ozy`> OH SHI-
17:55:47 <sw17ch> tehgeekmeister: one can hope :)
17:55:55 <tehgeekmeister> sw17ch: or hope not.  =[
17:55:57 <Axman6> ozy`: could be helpful for the pidigits benchmark though, if the unsigned versions are any faster
17:56:00 <sw17ch> XD
17:56:10 <tehgeekmeister> sw17ch: i preferred the lambda + bind ones
17:56:23 <tehgeekmeister> either way, it's better than the old one
17:56:30 <alatter> Axman6: I'd heard that there are difficulties getting GHC to do bindings to gmp, because of the way it's used internally.
17:56:44 <Axman6> ah, you're probably right
17:56:44 <alatter> maybe that was a while ago, though
17:57:30 <sw17ch> tehgeekmeister: actually, me too
17:57:41 <sw17ch> i mean
17:57:43 <sw17ch> uhh...
17:57:51 <sw17ch> the >>= one with the hard edges in earth tones
17:57:55 <Axman6> anyone else see http://www.ternarysoftware.com/blogs/2009/02/21/playing-with-haskell-http-server/ ? seems the logger thing doesn't make any sense...
17:58:04 <Axman6> logger :: Handle -> Chan B.ByteString -> IO ()
17:58:04 <Axman6> logger h msgs = do msg  Chan B.ByteString -> IO ()
17:58:22 <ozy`> I hope the narwhal logo is used for an april fools' joke
17:58:39 <tehgeekmeister> the lambda lambda half a bind one is what i dug.
17:58:39 <ddarius> ozy`: You can make that happen.
18:00:44 <ozy`> lambdabot: can haskell ....?
18:04:21 <tehgeekmeister> @src sequence_
18:04:21 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
18:04:37 * SamB ponders what to do with his .emacs directory
18:04:41 * Nafai listens to Lennart's interview
18:05:00 <tehgeekmeister> Nafai: where's that?  what on?
18:05:21 * SamB supposes he'll leave it where it is and add a warning to his .emacs.d that it isn't in the load path
18:05:34 <Axman6> :t let seqs f xs = foldr ((>>).f) xs in seqs
18:05:35 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> m a1) -> m b -> [a] -> m b
18:05:49 <Axman6> :t let seqs f xs = foldr ((>>=).f) xs in seqs
18:05:51 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
18:05:51 <lambdabot>     Probable cause: `.' is applied to too many arguments
18:05:51 <lambdabot>     In the first argument of `foldr', namely `((>>=) . f)'
18:06:35 <Nafai> tehgeekmeister: http://www.infoq.com/interviews/DSL-Haskell-Lennart-Augustsson
18:06:40 <Nafai> tehgeekmeister: DSLs in Haskell
18:06:44 <tehgeekmeister> oh nice
18:07:19 <BMeph_> Axman6: So seqs takes three arguments? Because otherwise, your defn is missing one for foldr. :)
18:07:38 <Axman6> BMeph_: no idea, just playing :)
18:07:58 <chessguy> this is kind of vague, but i wonder if this class reminds anyone of anything: http://codepad.org/cJHpIA5V
18:08:03 <BMeph> Axman6: Okay, play on then. :)
18:08:31 <dons> sw17ch: yo
18:09:08 <tehgeekmeister> is there a function of type (m a -> m b) -> m a -> m b
18:09:08 <tehgeekmeister> ?
18:09:18 <tehgeekmeister> i've found myself wanting it a few times lately.
18:09:25 <chessguy> @hoogle (m a -> m b) -> m a -> m b
18:09:26 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d
18:09:45 <alatter> :t ap
18:09:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:09:59 <chessguy> @type ($)
18:10:01 <lambdabot> forall a b. (a -> b) -> a -> b
18:10:06 <alatter> ^_^
18:10:18 <alatter> that would do it
18:10:20 <chessguy> @type (($) :: (m a -> m b) -> m a -> m b)
18:10:21 <lambdabot> forall (m :: * -> *) a b. (m a -> m b) -> m a -> m b
18:10:24 <chessguy> :)
18:10:48 <ddarius> :t id :: (m a -> m b) -> m a -> m b
18:10:50 <lambdabot> forall (m :: * -> *) a b. (m a -> m b) -> m a -> m b
18:10:58 <chessguy> that too
18:11:19 <tehgeekmeister> $ can work over actions in a monad?
18:12:06 <chessguy> sure
18:12:25 <chessguy> they're just values :)
18:12:38 <tehgeekmeister> wow that could simplify some of my code.
18:12:52 <chessguy> tehgeekmeister:  now whether or not it does what you want it to do is another question
18:13:08 <tehgeekmeister> good point.
18:13:11 <ddarius> tehgeekmeister: I don't think anyone actually knows what you want that function to do.
18:13:53 <tehgeekmeister> take a function from a value in a monad to another value in that monad, and take a value in that monad, and apply the function to it
18:14:08 <tehgeekmeister> yielding yet another value in that monad
18:14:20 <idnar> tehgeekmeister: that's <$> aka fmap aka liftM
18:14:30 <tehgeekmeister> oh yeah it is.
18:14:34 <chessguy> @type liftM
18:14:35 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:14:41 <chessguy> ermm, not really
18:14:43 <idnar> tehgeekmeister: well, assuming I decoded what you meant
18:14:46 <tehgeekmeister> oh, no, not quite
18:14:53 <chessguy> in that case, the function isn't in the monad
18:15:00 <ddarius> tehgeekmeister: Why wouldn't that just be normal function application?
18:15:20 <idnar> uhm, I guess if you meant exactly what you said, then that is just normal function application, so ($) would work
18:15:22 <ddarius> Alternatively, why do you want functions (m a -> m b) rather than just (a -> m b) ?
18:15:36 <alatter> :t forever
18:15:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
18:16:42 <jrockway> heh, i love having a ghci in emacs; i typed "getCurr" + M-/, and it completed to "getCurrentDirectory" because someone mentioned it on IRC earlier today :)
18:16:56 <jrockway> "Completion found in #haskell"
18:17:20 <alatter> jrockway: that could get interesting
18:17:31 <idnar> nice
18:17:38 <Gracenotes> tehgeekmeister: hm. liftM2?
18:17:47 <Nafai> jrockway: Heh, nice :)
18:17:59 <jrockway> it also works nicely when you have the docs for something open in w3m
18:18:35 <Gracenotes> oh, never mind, liftM, I suppose. *parsing failed*
18:18:48 <Gracenotes> or just >>=
18:21:45 <chessguy> jrockway:  haha
18:21:49 <chessguy> that's awesome
18:22:56 <jrockway> one of the advantages of using emacs as your desktop environment ;)
18:23:00 <jrockway> The One True Way
18:23:45 <Axman6> ew
18:24:51 <Cale> jrockway: However, just pressing tab will normally complete against everything in scope anyway.
18:25:05 <jrockway> yeah, except that comint is broken in that respect
18:25:17 <jrockway> at some point, i will write a real haskell repl mode for emacs, but this works for now
18:25:22 <jrockway> (unless i switch to yi ;)
18:26:41 <tehgeekmeister> ddarius: i ended up with some functions (m a -> m b) (iirc) in my last program, and so i wanted an easy way to use them.
18:27:02 <tehgeekmeister> but i think i got some of this wrong, it was more complicated than that, i think.
18:29:28 <tehgeekmeister> actually, come to look at it, what i ended up using in my code was far simpler.
18:29:50 <tehgeekmeister> (\f xs -> xs >>= mapM f)
18:30:07 <tehgeekmeister> that's the bit that got me thinking about this, but that's not the type i quoted to you guys at all.
18:30:20 <Axman6> @pl (\f xs -> xs >>= mapM f)
18:30:20 <lambdabot> (=<<) . mapM
18:30:35 <tehgeekmeister> yeah i liked the readability of the lambda better.
18:31:09 <tehgeekmeister> (=<<) . mapM confuses me.
18:33:56 <idnar> @type (=<<) . mapM
18:33:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
18:34:32 <idnar> @type join . fmap . mapM
18:34:33 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f [a])
18:34:33 <lambdabot>     Probable cause: `.' is applied to too many arguments
18:34:33 <lambdabot>     In the second argument of `(.)', namely `fmap . mapM'
18:34:37 <idnar> hrm, no
18:35:09 <tehgeekmeister> @type join . (fmap mapM)
18:35:10 <tehgeekmeister> ?
18:35:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ([a] -> a -> m b) -> [a] -> m [b]
18:35:20 <tehgeekmeister> no.
18:39:21 <pumpkin_> ack, ST monad is being annoying :P
18:41:28 <jsn> pumpkin_: annoying?
18:41:37 <pumpkin_> well, I'm doing it wrong :P
18:41:40 <pumpkin_> and it's not letting me
18:41:55 <Gracenotes> name the phantom type "fuckyou" to take your anger out
18:42:04 <pumpkin_> maybe
18:43:12 <crutcher> hmm, just notice this in the grammar
18:43:29 <crutcher> the export/import list for modules permits a trailing comma
18:43:54 <crutcher> but list constructor and type fields don't
18:47:34 <alatter> crutcher: type fields?
18:47:55 <crutcher> data Foo = F { a :: Int, b :: String }
18:48:00 <alatter> ah
18:48:08 <crutcher> f (Foo {a = x, b = y} = x
18:48:23 <crutcher> should be better about my vocab
18:48:38 <alatter> record syntax, maybe?
18:48:40 <crutcher> um, field declerations and patterns
18:48:56 <alatter> that's how I think of it, at least.
18:50:36 <pumpkin_> w00t
18:50:40 <pumpkin_> increasing HPC
18:53:05 <crutcher> pumpkin_: ?
18:53:22 <pumpkin_> getting the HPC coverage percentages up on uvector
18:53:26 <pumpkin_> it feels good :)
18:54:27 <crutcher> ah
19:04:50 <ksf> dumb question: can TH express type signatures? if yes, why are people complaining that there aren't type-level integer constants?
19:05:41 <jsn> i don't know that i actually want to write TH for a Vector 1
19:05:44 <ksf> (... and got killed by a ravaging mob of scientists who suddenly discovered that the one thing they really can't stand is a smart alec)
19:06:13 <halberd> hitchhiker's guide
19:06:42 <ksf> I've got e* in my geekcode, after all.
19:07:52 <ksf> (which could use an update. larvae nowadays don't know what vms is)
19:08:58 <ksf> ...anyway, type-level programming, all that stuff dependent types are useful for and metaprogramming are more or less exactly the same.
19:10:29 <ksf> I don't blame the language if my metaprogram doesn't terminate, so why should I blame a dependent typechecker if it doesn't terminate?
19:11:04 <ksf> otoh, dependently typed programs are so damn mathematical it's a strain.
19:11:13 <ksf> s/programs/languages
19:11:29 <ksf> (hear a kid spoiled by scheme talking)
19:11:30 <Axman6> , [$ty|map|]
19:11:33 <monochrom> You should blame nothing.
19:11:34 <lunabot>  forall a b . (b -> a) -> [] b -> [] a
19:11:57 <Axman6> ksf: that what you're after?
19:14:52 <ksf> , [$ty|(a,(a,a))|]
19:14:55 <lunabot>  (Expr, (Expr, Expr))
19:15:08 <ksf> I guess that's a two.
19:15:21 <ksf> errr... one.
19:16:23 <ksf> , [$ty|Just(Just(Nothing))|]
19:16:25 <lunabot>  forall a . Maybe (Maybe (Maybe a))
19:17:38 <ksf> newtype Nat = Nat (Maybe Nat)
19:21:13 <pilkarn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1622#a1622 <- whats wrong with that?
19:22:09 <Ralith> @src unwords
19:22:09 <lambdabot> unwords [] = ""
19:22:09 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
19:22:26 <Ralith> foldr1?
19:23:05 <crutcher> newtype Complex = Complex (Rational a, Imaginary b)
19:23:14 <crutcher> you left the constructor off the newtype
19:23:29 <glguy> pilkarn, "type"s don't derive typeclasses and newtypes need constructors
19:24:07 <ksf> > sqrt( -1 ) :: Complex
19:24:08 <lambdabot>       `Complex' is not applied to enough type arguments
19:24:08 <lambdabot>      Expected kind `?...
19:24:15 <ksf> > sqrt( -1 ) :: Complex CReal
19:24:17 <lambdabot>   0.0 :+ 1.0
19:24:23 <ksf> why reinvent the wheel?
19:24:42 <crutcher> newtype Complex = Complex (Rational, Imaginary)
19:25:08 <ksf> you can't have Rational as a type, it's a class.
19:26:00 <ksf> the build-in Complex looks like this: data Complex a = a :+ a
19:26:13 <crutcher> ksf: well, it works
19:26:21 <ksf> ...which, unlike the newtype, introduces a new bottom.
19:26:50 <Axman6> @src Complex
19:26:50 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
19:26:53 * ksf hides under a stone after noticing the a after rational.
19:27:45 <crutcher> This works:
19:27:46 <crutcher> type Imaginary = Rational
19:27:46 <crutcher> newtype Complex = Complex (Rational, Imaginary)
19:27:46 <crutcher>   deriving (Show)
19:28:01 <Axman6> seanl_: G'day. haven't seen many people from UNSW on here before :)
19:28:05 <crutcher> and you can construct values as: Complex (1, 2)
19:28:18 <ksf> > 1 :+ 2
19:28:20 <lambdabot>   1.0 :+ 2.0
19:28:28 <Axman6> > cis pi
19:28:29 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
19:28:36 <Axman6> > cis pi :: Complex CReal
19:28:37 <lambdabot>   (-1.0) :+ 0.0
19:28:46 <Axman6> > cis (pi/4) :: Complex CReal
19:28:48 <lambdabot>   0.7071067811865475244008443621048490392848 :+ 0.707106781186547524400844362...
19:29:08 <crutcher> ksf: ahh, this is because Rational is a type, not a class
19:29:33 <ksf> :t %
19:29:34 <lambdabot> parse error on input `%'
19:29:38 <ksf> :t (%)
19:29:39 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
19:29:47 <glguy> type Rational = Ratio Integer
19:29:58 <ksf> now that makes sense.
19:30:54 <ksf> anyway, I don't like the idea of saying that the real and imaginary parts have different types.
19:32:05 <ksf> both are numbers, one being multiplied by i, and expressing that is what the product type is for.
19:33:50 <crutcher> well, just using type instead of newtype doesn't really give you an protection against the sort of bugs you'd care about anyway
19:34:07 <crutcher> so if you are going to do it, you should probs go all the way
19:35:27 <monochrom> no one says the real part and the imaginary part are different types.
19:36:21 <crutcher> monochrom: actually, some people _do_ say that. And there is a case for asking the type system to enforce it. But its such a pita to do
19:36:39 <pilkarn> Complex :: (Rational, Imaginary) -> Complex
19:36:59 <monochrom> oops
19:40:38 <pilkarn> how do I efine a Tree for any type?
19:40:43 <pilkarn> data Tree =
19:40:43 <pilkarn>     Empty | Leaf Int | Node Tree Tree
19:40:47 <pilkarn> instead of that?
19:41:14 <Axman6> data Tree a = Empty| Leaf a | Node (Tree a) (Tree a)
19:41:23 <Axman6> or
19:41:39 <Axman6> data Tree a = Empty| Leaf a | Node a (Tree a) (Tree a) -- if you want to hold things in the nodes
19:41:44 <BMeph> pilkarn: 1) Replace "Tree" with "Tree a" (or "Tree q" if that floats your boat.)
19:42:07 <BMeph> 2) Replace "Leaf Int" with "Leaf a"
19:42:11 <BMeph> 3) ?????
19:42:20 <BMeph> 4) ...well, you know. ;p
19:44:31 <dons> pilkarn: make sense?
19:45:26 <pilkarn> Node a (Tree a) (Tree a)
19:45:30 <pilkarn> how do i call that?
19:45:54 <Axman6> wht do you mean?
19:46:05 <Axman6> what*
19:46:17 <pumpkin_> Node 5 Empty Empty
19:46:21 <Axman6> Node a (Tree a) (Tree a) contains an a, and two trees of type A
19:46:23 <Axman6> a*
19:47:17 <glguy> Leaf a is unnecessary, you already have Node a Empty Empty
19:47:48 <Axman6> aye
19:47:50 <dons> pilkarn: you're describing a data structure (like a struct in C)
19:48:02 <Axman6> but, the original had Node Tree Tree, no a in it
19:48:19 <glguy> ah, I have ot PgUp to see that part
19:58:09 <jberryman> how do I figure out the fixity of haskell operators?
19:58:25 <glguy> in GHCi, you can do   :i +
19:58:27 <dons> :info in ghci
19:58:27 <glguy> for example
19:58:31 <dons> jinx
19:58:44 <jberryman> thanks
19:58:59 <Axman6> i've found :i to be very very handy recently
20:01:38 <chrisdone> dons: I like that your non-programming post has made it to the top of "What's Hot" on proggit :P it demonstrates the point well
20:03:09 <dons> mwhaha
20:03:28 <dons> i   think the consequence of this will be more aggressive downvoting of non-prog stuff
20:03:54 <monochrom> which is it?
20:03:56 <chrisdone> that would be nice
20:04:02 <alatter_> sometimes I upvote non-prog stuff
20:04:09 <chrisdone> monochrom: http://www.reddit.com/r/programming/comments/7z9j1/why_the_programming_subreddit_sucks/
20:04:40 <monochrom> found. hahaha
20:04:48 <dons> seems ayrnieu still hates me too. cool cats.
20:05:09 <dons> i wish all points were easy to make with a screenshot and some crude scribbles.
20:05:13 <dons> its such a fun medium to work in
20:05:21 <chrisdone> alatter: I used to bitch in the thread in question about how it isn't programming, and actually got plenty of upvotes. made my wonder if split personality redditers were upvoting the post and upvoting me, too
20:05:47 <dons> i wonder if we could do ICFP paper reviews with a green pen and a red pen and a sharpie for comments
20:05:54 <alatter_> chrisdone: well, hypothetically you're supposed to upvote comments which further discussion
20:06:12 <dons> up votes	434
20:06:12 <alatter_> chrisdone: I don't think that's what most people do, though
20:06:12 <dons> down votes	270
20:06:19 <dons> probably the most popular post i've ever submitted
20:06:29 <chrisdone> hahaha
20:06:42 <gwern> red pen: "This is 'it's', not 'its' - didn't they teach you how to write in CS grad school?" green pen: "Excellent use of simile, Dan!"
20:07:00 <chrisdone> dons: "look at this haskell stuff!"
20:07:02 <chrisdone> reddit: "I prefer it when you're whining. what's annoying you today?"
20:07:40 <alatter_> well, whining certainy has a broader base
20:08:11 <gwern> a well-done flame is very enjoyable
20:08:28 <gwern> much more enjoyable than a random technique demo
20:08:53 <chrisdone> An innocent proggiter decides to post a non-programming article on proggit. Now he has two problems.
20:09:23 <SamB> what was the first one ?
20:09:31 <alatter> redditing at work?
20:09:32 <chrisdone> being a proggiter
20:10:18 * gwern frowns at chrisdone. a good parody/allusion maintains the same rythmic scheme and syllable count as the original
20:10:58 <chrisdone> I can't actually remember the original
20:11:00 <chrisdone> something about awk?
20:11:08 * SamB laughs at dons' scribbling on the screen
20:11:16 <dons> sed?
20:11:24 <dons> regexen?
20:11:28 <chrisdone> perl?
20:11:37 <gwern> no, it was jamie zawinski
20:11:42 <chrisdone> unsafePerformIO?
20:11:49 <dons> jamie zawinski was two problems?
20:11:52 <gwern> 'some people when faced with a problem say, I know, I'll use regexps. Now they have two problems.'
20:12:17 <gwern> although iirc jamie may've just popularized it, borrowing it from a lisper. (erik naggum, maybe...)
20:12:28 <alatter> http://regex.info/blog/2006-09-15/247
20:12:36 <gwern> wonder whether -cafe will ever be blessed with a naggum
20:12:47 <gwern> or a xah lee!
20:12:54 <bos> i sure hope not.
20:12:58 <bos> bulat alone is enough.
20:13:00 <SamB> gwern: TH is often like that
20:13:03 <Axman6> heh
20:13:38 <dons> yeah, its been a good day
20:14:12 <gwern> SamB: no need to tell me about it. I've wrangled with th enough myself
20:14:24 <Axman6> dons: how so? (missed something earlier i'm sure)
20:14:28 <gwern> hm. that'd be a good quote
20:14:35 <Gracenotes> @src MonadState
20:14:35 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:14:43 <Gracenotes> :/
20:15:01 * pumpkin_ is enjoying his bugswatting-fu
20:15:06 <gwern> 'some people, with faced with a Haskell problem, say I know - I'll use Template Haskell! Now they have two problems.'
20:15:17 <Gracenotes> anyway, it would nice if modify and gets were actually part of MonadState instead of utility functions
20:15:29 * gwern sometimes wonders how bad things are in the ML compile-time frameworks, or whetehr TH is just implemented poorly
20:15:38 <Gracenotes> for some implementations, modify can actually be an atomic action, rather than a getting-then-putting
20:15:53 <dons> typed macros for a large syntax are going to be complicated
20:16:04 <Axman6> pumpkin_: have you done anything with your uvector stuff, more than just having it in a repo? (like given the changes to dons)
20:16:14 <chrisdone> “whenever faced with a problem, some Haskellers say `Let's use monads!'. Now, they have no problems.”
20:16:15 <Gracenotes> so that's why modify and gets should be part of MonadState, blah blah blah
20:16:24 <pumpkin_> Axman6: of course :) I'm a good citizen, but I'm also still working on it
20:16:31 <Axman6> heh, good :)
20:16:53 <monochrom> Some people say, "I know, http://lmgtfy.com/". Now they face two problems.
20:17:14 <Axman6> http://addictedtor.free.fr/graphiques/graphiques/graph_143.png <- R can do some crazy stuff :|
20:17:28 <gwern> dons: well, the issues in TH prevent me from saying whether th is bad or it's just hard
20:17:52 <gwern> Axman6: oh no, the Angel is taking over the Magi!
20:18:01 <Axman6> haha :D
20:18:01 <gwern> Axman6: but srsly, what is that supposed to be?
20:18:18 <chrisdone> I was playing about with s-expr'd haskell and decided I didn't actually like it all that much and was sad
20:18:24 <Axman6> http://addictedtor.free.fr/graphiques/thumbs.php?sort=votes examples of R graphs with source (via proggit)
20:18:35 <chrisdone> I had a sad :-(
20:18:54 <gwern> and a little more of chrisdone's childhood dreams slip away
20:19:03 <Axman6> heh
20:19:09 <Axman6> chrisdone: was it a big sad?
20:19:19 <gwern> @remember gwern some people, with faced with a Haskell problem, say I know - I'll use Template Haskell! Now they have two problems.
20:19:19 <lambdabot> It is stored.
20:19:24 <chrisdone> <----> this big
20:19:25 <gwern> @remember gwern some people, with faced with a Haskell problem, say I know - I'll use Template Haskell! Now they have two problems.
20:19:26 <lambdabot> It is forever etched in my memory.
20:19:33 <gwern> doh
20:19:41 <gwern> @remember chrisdone whenever faced with a problem, some Haskellers say `Let's use monads!'. Now, they have no problems.
20:19:41 <lambdabot> It is forever etched in my memory.
20:19:42 <Axman6> gwern: know any other good anime? need to see more ghost in the shell
20:19:44 <gwern> @quote chrisdone
20:19:45 <lambdabot> chrisdone says: whenever faced with a problem, some Haskellers say `Let's use monads!'. Now, they have no problems.
20:19:54 <chrisdone> heh
20:19:54 <ozy`> well
20:20:02 <gwern> Axman6: well, SAC is highly regarded, and I certainly liked the 1st 2 seasons
20:20:13 <ozy`> I think this is the nastiest hack I've ever written
20:20:29 <Axman6> yeah, we've seen the second season (got to get the first from a friend of mine)
20:20:41 <chrisdone> I'm not into anime but I liked Ghost in the Shell
20:20:44 <Gracenotes> Whenever faced with a problem with a monad transformer stack, some Haskellers say "Let's switch around these two items on the stack!". Then, their brains explode.
20:20:45 <pumpkin_> I haz found dat the Bool implementation of uvector is suzpizious
20:20:49 <Gracenotes> :(
20:20:55 <Axman6> chrisdone: should check out neon genesis
20:21:02 <gwern> Axman6: and I recently watched the old sf movie _They Were Eleven_ and thought it was pretty awesome
20:21:19 <Axman6> i'll check it out
20:21:42 <ozy`> Axman6: the title of NGE is supposed to be greek... the creators' greek was about as good as their sanskrit.
20:21:57 <gwern> as for recent stuff? I've watched some tora-dora, and it's pretty good for as overdone a genre highschool romance (I also finished clannad, but I'm of mixed feelings - it was both really great and really terrible, if you know what I mean)
20:22:05 <Axman6> ozy`: o.O
20:22:39 <gwern> ozy`: true dat. as a producer said, they chucked the biblical stuff in because it was cool and no japanese had done that yet
20:22:45 <Axman6> gwern: sounds like BSG to me. it disappoints me that it has so much promise, yet rarely delivers :(
20:23:00 <chrisdone> gwern: what is this, Schrödinger's movie review?
20:23:17 <gwern> Axman6: I actually haven't watched any BSG. with that, heroes, and lost, I have put them on my calendar to torrent after they are good and finished
20:23:39 <Axman6> urgh, not a fan of lost. haven't seen any heros
20:23:43 <pumpkin_> woot, I haz passed 90% test coverage
20:23:48 <gwern> chrisdone: oh come on, have you never watched anything where you were entertained and enthralled while watching it, but on reflection afterwards you realized it was terrible in a fundamental way?
20:23:50 <Axman6> pumpkin_: whoot :)
20:23:51 <chrisdone> gwern: do you watch series in bulk?
20:24:05 <gwern> chrisdone: I also got this feeling while watching _Slumdog Millionaire_, if that helps
20:24:14 <ozy`> hmmmmm, I think for tonight I will give up on my misguided attempt to enhance cat
20:24:18 * Saizan points everyone to #haskell-blah
20:24:36 <Axman6> yes, this is rather blah isn't it
20:24:38 <pumpkin_> Saizan: mine was haskell-related!
20:24:43 <gwern> chrisdone: yes. much more efficient. no commercials, watch'em back to back, and as your ears adapt you can slowly speed them up
20:24:54 <ozy`> you see... monads are like gundams
20:24:59 <araujo> gwern, mmm... what is that movie about?
20:25:07 <Axman6> ozy`: haha
20:25:17 * araujo been watching references to it in several places and now even in here
20:25:21 <araujo> so i had to ask
20:25:33 <gwern> araujo: just go look at the wp article; it'll tell you everything you want to know
20:25:37 * ozy` hides his face in vain from the oncoming artillery fire
20:25:41 <ozy`> "NOOOO NOT LIFTM"
20:25:50 * ozy` explodes
20:25:53 <Axman6> sequence those missiles!
20:26:05 <gwern> ozy`: so would FPers be the Newtypes?
20:26:06 <Axman6> parMap the torpedos!
20:26:20 <araujo> gwern, wp?
20:26:26 <gwern> we think and fly circles around the outdated imperative thinkers
20:26:29 <gwern> araujo: wikipedia
20:26:35 <araujo> opo oooh
20:26:39 <chrisdone> @pl (\x k t -> t * (x * x * (k * x)))
20:26:39 <lambdabot> ((*) .) . ap ((.) . (*) . join (*)) (*)
20:26:39 <ozy`> gwern: I think "newtype" might be a Newtype....
20:27:06 <gwern> ozy`: but better might something like Transformers for IO monad - people get in the parts and the parts shift and combine but don't come out
20:27:19 <ozy`> D:
20:27:57 <dolio> "Shinseiki" *is* pretty bad Greek.
20:28:19 <chrisdone> Magnimus - NO!
20:28:26 <gwern> or we could liken the limbs to the functions of the monad typeclass! because every robotic warrior *has* to have 2 arms, 2 legs, and a head; just like a monad needs bind, return, and sequence...
20:28:51 <gwern> if it doesn't have all of that implemented it is neither mechanism nor monad1
20:28:56 <gwern> *!
20:30:08 <gwern> dolio: the title is even more confusing when you consider the early plot outlines for Eva, where the angels were called apostles - it kind of raises the question of who precisely is conveying the evangelion...
20:30:13 <SamB> dons: what is this "karma loophole" thing ?
20:30:20 <Axman6> oh no, he forkIO'd my arm!
20:31:20 <chrisdone> unsafePerformDisassemble
20:31:31 <pumpkin_> chrisdone: sounds like my latest project!
20:31:32 <pumpkin_> :P
20:31:34 <ozy`> dolio: rather, "neon" and "genesis" don't make a whole lot of sense there.
20:31:39 <gwern> (oh no, what's the fluid leaking out of the pilot chambers?'
20:31:55 <pumpkin_> I thought this was -blah'ed?
20:32:24 * gwern feels it dave. i feel my mind going. (time to turn in for the night)
20:33:16 <chrisdone> @users
20:33:17 <lambdabot> Maximum users seen in #haskell: 665, currently: 595 (89.5%), active: 17 (2.9%)
20:33:24 <monochrom> You have an unmatched open parenthesis and an unmatched close quote.
20:33:33 <dolio> Huh, maximum users is down 1.
20:33:48 <repnop> dolio: the bot found christ
20:34:20 <chrisdone> I remember when the average was 300 and I was showing off to a friend about how popular Haskell must be and how it must be worth learning for the community. that was a year ago (I started learning new year's eve)
20:34:50 <Axman6> i started learning about this time last year
20:35:09 <Axman6> i'm pretty happy that it's been a less than a yeah, and i'm already on planet haskell :)
20:35:10 <chrisdone> Axman6: gonna eat your brains and gain your knowledge
20:35:12 * SamB thinks we need better IRC logs
20:35:28 <pumpkin_> serchubul
20:35:33 <SamB> yeah
20:35:39 <SamB> could use parallelism
20:35:42 <chrisdone> Axman6: do you know arrows yet?
20:35:46 <SamB> be good demo, maybe
20:36:06 <pumpkin_> pff arrows
20:36:10 <pumpkin_> who needs 'em
20:36:17 <Axman6> chrisdone: not really, but they don't seem that hard. i can;t see what's so useful about them though (apart from first and second)
20:36:34 <chrisdone> all the combinators are awesome
20:36:45 <Axman6> tell me about them :)
20:36:47 <SamB> the class sucks, though
20:36:57 <pumpkin_> I just dislike the arr function
20:37:00 <TomMD> @where hooya
20:37:00 <lambdabot> I know nothing about hooya.
20:37:04 <Axman6> :t arr
20:37:05 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
20:37:20 <Axman6> don't see the point of arr...
20:37:27 <Axman6> i mean, isn't (->) an Arrow?
20:37:29 <chrisdone> well, a *** b = first a . second b
20:37:31 <pumpkin_> it seems to almost force your arrow to be basically a function, which defeats the purpose
20:37:35 <chrisdone> for when you can't be bothered typing both out
20:37:37 <pumpkin_> unless I'm missing something
20:37:39 <SamB> the thing to do is figure out how to get the combinators without pure/arr
20:37:40 <chrisdone> s/./>>>
20:37:44 <SamB> pumpkin: that's the way I feel too
20:38:17 <SamB> Axman6: it is, but not every arrow is (->)
20:38:38 <chrisdone> Axman6: &&& is also cool, I use that all the time
20:38:48 <chrisdone> I use arrows all the time, really. let me grab a line from a real project
20:38:50 <Axman6> :t (&&&)
20:38:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:39:15 <chrisdone> pageToHtml :: Blog -> FilePath -> [String] -> String -> Html
20:39:15 <chrisdone> pageToHtml blog fname tags =
20:39:15 <chrisdone>     html . second write . (getTitle &&& highlight) . read where
20:39:17 <chrisdone> yeah, bitch!
20:39:22 <pumpkin_> I use first/second/&&&/*** all the time, and occasionally >>>, but only with the function instance of arrow
20:39:30 <pumpkin_> as much as I'd love to make other instances :P
20:39:45 <Axman6> so, (f :: b -> c) &&& (g :: b -> d) :: b -> (c,d)
20:39:49 <Axman6> seems useful
20:39:58 <SamB> Axman6: yeah
20:40:06 <SamB> the combinators are all cool
20:40:11 <pumpkin_> > snd &&& fst $ (1, 2)
20:40:12 <lambdabot>   (2,1)
20:40:14 <Axman6> but mainly for saving typing (not an unworthy cause!)
20:40:15 <SamB> but it'd be nicer if we could get them without pure/arr
20:40:58 <dolio> Why do monads have return? Isn't (\t -> t) a monad?
20:42:15 <SamB> dolio: heck no
20:42:17 <SamB> it's a value!
20:42:53 <dolio> That was a type function.
20:43:13 <SamB> oh.
20:43:19 <SamB> wouldn't that be a comonad ?
20:43:26 <chrisdone> what's a type function? how is it different to a kind?
20:43:28 <Saizan> return = id ?
20:43:44 <dolio> Yes, the identity functor is also a comonad.
20:43:44 <Saizan> chrisdone: a kind is the type of a type function
20:43:50 <chrisdone> oh, sorry
20:44:02 <pumpkin_> we need kind functions
20:44:02 <SamB> oh, the identity
20:44:25 <Gracenotes> so you can make an Either a b into an Either b a?
20:44:34 <Gracenotes> or something like
20:44:40 <Saizan> pumpkin_: \x:Kind -> x
20:44:48 <dibblego> @type either
20:44:49 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
20:44:55 <dibblego> @type either Right Left
20:44:56 <lambdabot> forall a a1. Either a a1 -> Either a1 a
20:45:10 <Gracenotes> can you do that in type signatures? ;)
20:45:10 * chrisdone makes a whip noise
20:45:26 <dolio> @type Either Right Left
20:45:27 <lambdabot> Not in scope: data constructor `Either'
20:45:31 <dolio> @type either Right Left
20:45:32 <lambdabot> forall a a1. Either a a1 -> Either a1 a
20:45:39 <Gracenotes> really, I am curious to know what pumpkin means by kind functions
20:45:49 <Gracenotes> tell us, or we shall put you in the comfy chair
20:45:56 <pumpkin_> not the comfy chair!
20:46:00 <chrisdone> mein kamfy chair?
20:46:01 <dolio> , [$ty| either Right Left |]
20:46:02 <pumpkin_> if I do import System.Process hiding (i'mprettysurethisisn'tafunctionbuti'llhideitanyway)
20:46:04 <lunabot>  forall a a . Either a a -> Either a a
20:46:12 <dolio> Well, that's not right.
20:46:18 <dolio> mmorrow: ^^
20:46:49 <Axman6> pumpkin_: i wish more functions were named like that, we wouldn't ever need documentation then
20:46:59 <pumpkin_> :P
20:47:03 <ksf> does anyone have a copy of http://www.coverproject.org/TalksUntilSpring2004/DependentTypesInHaskell.pdf ? server appears to be down.
20:47:09 <pumpkin_> the implied question was: if I hide something that isn't there, will it break?
20:47:19 <Saizan> pumpkin_: yes
20:47:23 <pumpkin_> :(
20:47:33 <Gracenotes> too bad no one could write a simple test case
20:47:50 <Axman6> mapIsAFunctionThatTakesAFunctionFromAToBAndAListOfAsAndTurnsThemIntoAListOfBs :: (a -> b) -> [a] -> [b]
20:48:05 <mmorrow> @type either Right Left
20:48:06 <lambdabot> forall a a1. Either a a1 -> Either a1 a
20:48:29 <mmorrow> dolio: weird. that's straight from ghc too, so my name-prettifier must be botching that
20:48:34 <mmorrow> but i don't know how..
20:48:36 <Saizan> Axman6: ..ThisIsAlsoCalledFmap
20:48:53 <pumpkin_> Axman6: starting to look like cocoa now :P
20:49:01 <mmorrow> , [$ty| \x -> either Right Left x|]
20:49:02 <chrisdone> is haskell syntactically inconsistent in its letting you omit parentheses sometimes for lists of things if it's only one item, but requiring when it's more?
20:49:03 <lunabot>  forall a a . Either a a -> Either a a
20:49:06 <Axman6> mapIsAFunctionThatTakesAFunctionFromAToBAndAListOfAsAndTurnsThemIntoAListOfBs'ThisUsedToBeCalledFmapButTheyChangedItWithHaskell98 :: (a -> b) -> [a] -> [b]
20:49:11 <mmorrow> "forall a a."
20:49:13 <Axman6> pumpkin_: yes indeed :P
20:49:21 <mmorrow> , typ "either Right Left"
20:49:23 <lunabot>  "forall a a. Data.Either.Either a a -> Data.Either.Either a a"
20:49:30 <redditbot> If the integers from 1 to 999,999,999 are written as words, sorted alphabetically, and concatenated, what is the 51 billionth letter?
20:49:35 <dolio> Does it not replace names like "a" maybe?
20:49:36 <Axman6> mmorrow: uhoh
20:49:45 <dolio> And then when it goes to replace a1, it grabs a from its fresh list?
20:49:47 <chrisdone> import Foo (blah)
20:49:47 <chrisdone> import Foo hiding (blah)
20:49:47 <chrisdone> data Foo = Foo deriving Blah -- wait, what
20:49:51 <dolio> Not noticing that it's used?
20:49:54 <drhodes> why is redditbot posting solutions to interview problems.
20:50:01 <mmorrow> it uses ["a"..."z","aa"...,"zz",...] as a renaming source
20:50:11 <mmorrow> so it should never reuse a name, which is weird
20:50:27 <Gracenotes> I think it reuses a name!
20:50:33 <Gracenotes> O:
20:50:43 <Axman6> mmorrow: oh no, the impossible hapened!
20:50:45 <Axman6> pp*
20:50:45 <mmorrow> , typ "\\x -> x"
20:50:48 <lunabot>  "forall t_aadX. t_aadX -> t_aadX"
20:50:55 <chrisdone> Axman6: go to ... to report a bug
20:51:00 <mmorrow> `typ' does _no_ renaming
20:51:05 <mmorrow> so this is weird:
20:51:07 <pumpkin_> failuna
20:51:07 <mmorrow> , typ "either Right Left"
20:51:09 <lunabot>  "forall a a. Data.Either.Either a a -> Data.Either.Either a a"
20:51:16 <mmorrow> that's literally what ghc is saying
20:51:20 <chrisdone> lunabotched
20:51:21 <dons> huh. did my 'proggit sucks' post get moderated by reddit gods?
20:51:21 <dolio> Huh.
20:51:30 <dolio> That's pretty weird.
20:51:36 <mmorrow> that's super weird
20:51:36 <pumpkin_> mmorrow: except my ghci disagrees :P
20:51:45 <mmorrow> yeah, this is using the ghc-api
20:51:50 <monochrom> There is no reddit god.
20:51:54 * Axman6 thinks bos might be a little drunk
20:51:57 <dibblego> dons, it appears so
20:51:58 <Gracenotes> http://www.reddit.com/r/programming/comments/7z9j1/why_the_programming_subreddit_sucks/
20:52:12 <Axman6> pumpkin_: you use twitteriffic?
20:52:15 <dons> yeah its still there. just not on the page at all.
20:52:16 <pumpkin_> Axman6: yup
20:52:18 <chrisdone> dons: it looks like it did... it's got the same number of up/down votes as before... but gone from the front page
20:52:19 <dons> super weird
20:52:24 <pumpkin_> Axman6: and twinkle on my iphone
20:52:26 <mmorrow> , typ "(\\l r x -> case x of Left a -> l a; Right b -> r b) Right Left"
20:52:28 <chrisdone> that's creepy
20:52:28 <lunabot>  "forall t_aaem a.\nData.Either.Either t_aaem a -> Data.Either.Either a t_...
20:52:34 <dibblego> dons, it also does not show up in search
20:52:35 <Axman6> pumpkin_: i han haz ifone pls?
20:52:37 <dons> so spez or ketralnis must'a killed it
20:52:44 <Gracenotes> dons: do you have any messages?
20:52:46 <mmorrow> , text $ typ "(\\l r x -> case x of Left a -> l a; Right b -> r b) Right Left"
20:52:48 <pumpkin_> Axman6: I do have a spare... but I'm not going to send it to you :P
20:52:48 <dons> nope
20:52:49 <lunabot>  forall t_aagi a.
20:52:49 <lunabot>  Data.Either.Either t_aagi a -> Data.Either.Either a t_aagi
20:52:57 <mmorrow> , typ "either Right Left"
20:52:58 <Axman6> pumpkin_: you're a terrible friend
20:52:59 <lunabot>  "forall a a. Data.Either.Either a a -> Data.Either.Either a a"
20:53:02 <pumpkin_> sry
20:53:18 <dons> maybe they don't like "why *reddit sucks"  posts now these days
20:53:25 <dons> or ones that show the use of adblock?
20:53:28 <mmorrow> , typ "let f = Right; g = Left in either f g"
20:53:31 <chrisdone> quits: dons (n=dons@archlinux/developer/dons): "spez was here"
20:53:31 <lunabot>  "forall a a. Data.Either.Either a a -> Data.Either.Either a a"
20:53:35 <monochrom> I guess the moderators read the title but not the content. Just like every reddit user and slashdot user.
20:53:38 <mmorrow> , typ "let f = Right; g = Left in (f,g)"
20:53:40 <lunabot>  "forall b a a b.\n(b -> Data.Either.Either a b, a -> Data.Either.Either a...
20:53:45 <dons> i don't think i've ever seen this happen on proggit
20:53:47 <dolio> , text $ typ "either Right"
20:53:50 <lunabot>  forall a a b.
20:53:50 <lunabot>  (b -> Data.Either.Either a a)
20:53:50 <lunabot>  -> Data.Either.Either a b
20:53:55 <mmorrow> wuh
20:54:06 <dolio> Yeah.
20:54:10 <Axman6> ha
20:54:35 <mmorrow> , either Right Left
20:54:36 <lunabot>  luna: No instance for (GHC.Show.Show
20:54:39 <mmorrow> gah
20:55:05 <bos> Axman6: que?
20:55:08 <mmorrow> , either Right Left (Left 42 :: Either Int Double)
20:55:09 <lunabot>  Right 42
20:55:22 <chrisdone> dons: did you get a message from the admins about it?
20:55:52 <Axman6> bos: your last twitter seemed rather strange is all. just put it and "Too. Many. Margaritas." together :)
20:55:55 <pumpkin_> bos: estás borracho?
20:55:56 <dons> nope
20:56:12 <bos> Axman6: it's the lyrics of a Frightened Rabbit song :-)
20:56:22 <Axman6> ah :)
20:56:37 <chrisdone> dons: they're oppressing your free speeches!!1 [241 upvotes]
20:57:11 <dolio> mmorrow: It doesn't seem to rename any of the variables when combining "either :: forall a b c. (a -> c) (b -> c) -> Either a b -> c" and "Right :: forall b a. b -> Either a b"
20:57:19 <mmorrow> dolio: maybe it's some weird reaction with the fact i'm using unsafePerformIO, since iirc ghc's uniq var supply also is using unsafePErformIO
20:57:29 <dolio> So the b from Right becomes an a.
20:57:34 <mmorrow> hmm, weird
20:58:00 <dolio> And you end up with two as (one from Right, one from either).
20:58:03 <Axman6> "Audio Rollendurchmesserzeitsammler" what and... awesome name for a garbage collector
20:58:28 <chrisdone> has anyone used my blawg software? it's rudimentary, but I'm wondering if anyone tried it
20:58:46 <dolio> At least, that's a guess.
20:59:05 <dolio> If you naively tried to figure out the type, that'd be the likely mistake in coming up with the type it displays.
20:59:36 <dons> hehe
21:00:51 <mmorrow> dolio: here's the code for `ty' (and typ). http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1514
21:01:05 <mmorrow> dolio: but i'm not doing anything in `typ'
21:01:12 <mmorrow> that's straight from ghc
21:02:23 <mmorrow> which makes me think that something super weird and/or random is happening with somewhere in the bowels of hscTcExpr
21:02:40 <mmorrow> *... happening somewhere ...
21:02:45 <dolio> What do I import to get the ghc api?
21:02:51 <dolio> In, say, ghci.
21:03:05 <mmorrow> you have to $ ghci -package ghc
21:03:14 <monochrom> You have to unhide the ghc package or do that.
21:03:17 <mmorrow> (but that code uses an `Env' type that's from "luna"
21:03:18 <mmorrow> )
21:03:44 <monochrom> And then something like "import GHC". There may be other modules of interest too.
21:03:46 <mmorrow> so you'd have to set up your environment differently
21:03:58 <mmorrow> (which is a pita to get right)
21:04:27 <dolio> Hmm...
21:04:36 <mmorrow> dolio: if you have 6.10.1 though, this would make it relatively easy: http://moonpatio.com/repos/luna/
21:04:47 <mmorrow> to get an Env, just do
21:04:53 <mmorrow> ghci> env <- defaultEnv
21:04:58 <mmorrow> and you're good to go
21:05:29 <mmorrow> (you'll probably have to change some of the package versions in the (hardcoded!! :( ) imports in Luna.Config
21:05:31 <mmorrow> )
21:05:33 <mmorrow> (too)
21:05:58 <mmorrow> (newtype Env = Env (MVar HscEnv))
21:07:08 <mmorrow> oh, actually that "typ" code just uses "myEnv" directly
21:09:59 <dolio> Well, I what I was going for was to see how easy it was to get the ghc api to dump out a type for "either Right" without anything you've written.
21:10:06 <dolio> To see if it's a bug in it.
21:10:13 <dolio> But clearly that's not a simple proposition.
21:11:06 <Axman6> mmorrow: Env looks a lot like mt AVar stuff, maybe it could be useful?
21:11:30 <dolio> Oh, wait...
21:11:53 <mmorrow> dolio: heh, definitely not very. (i just tried to make a short paste with just the essentials until i realized it'd take me a solid 15 minutes (and i'm already familiar with the process))
21:12:18 <dolio> Heh.
21:12:27 <pumpkin_> when did Exception become OldException?
21:12:31 <pumpkin_> 6.9?
21:12:45 <dolio> Yeah, 'runGhc Nothing $  exprType "either Right"' has the type, but it doesn't work.
21:12:50 * Axman6 would say 6.10
21:12:53 <mmorrow> dolio: it shouldn't be super hard though if you have 6.10.1 and manage to install luna (and change Luna.Config in the obvious way)
21:13:14 <mmorrow> dolio: oh sweet you go tit?
21:13:19 <mmorrow> *got it
21:13:33 <dolio> That just prints out "ghc: missing -B<dir> option"
21:13:34 <mmorrow> doesn't work how?
21:13:44 <mmorrow> oh, yeah so you have to initialize your env
21:13:47 <pumpkin_> so what's a good way to write something that's compatible with 6.10 and 6.8, that uses exceptions? do I need to use CPP or is there a nicer way?
21:14:08 <araujo> gwern, seems interesting ...
21:14:09 <mmorrow> dolio: what is "exprType" ?
21:14:31 <dolio> The ghc api docs say "Get the type of an expression".
21:14:48 <mmorrow> ah
21:14:54 <mmorrow> dolio: what ghc version do you have?
21:15:01 <dolio> 6.10.1
21:15:07 <Axman6> this compiling haskell to LLVM stuff is pretty interesting
21:15:25 <mmorrow> sweet, i'm gonna suck it up and make a minimally working snippet to get setup in ghc-api
21:15:39 <mmorrow> i need to refresh my memory anyways
21:16:12 <dons> Axman6: yeah
21:16:35 <dons> so when's someone going to upload a MiniHask LLVM layer?
21:16:37 <Axman6> dons: i'd be interested to see if it could be made to work with GHC. seems like there are some great benefits
21:16:42 <dons> a small typed FP on llvm to get us started.
21:17:39 <dons> i think we should declare the haskell narwhal logo the "alternate" logo of haskell
21:17:47 <dons> after we pick the true one in the next few weeks
21:18:18 <jsn> i was hoping for leonidas
21:18:39 <pumpkin_> is there an accepted GHC version macro I can use in CPP?
21:18:43 <jsn> that narwhal is already on the haskell reddit
21:18:46 <pumpkin_> or I guess a base version
21:19:05 <dons> jsn: yeah, i'm going to walk through the logo candidates via the reddit
21:19:09 <dons> up until the voting opens
21:19:15 <Axman6> dons: link?
21:19:22 <dons> for?
21:19:44 <Axman6> oh, thought you were saying there was a reddit for voting for the logos
21:19:47 <dons> ah no.
21:19:58 <dons> looks like we're going to use the internet condorcet voting service
21:20:09 <Axman6> nice
21:28:03 <dolio> Wow, do I have to fill in an entire DynFlags record by hand?
21:28:21 <alatter> dolio: I don't think so ...
21:28:47 <dolio> I don't see a default one in the docs.
21:28:49 <alatter> dolio: although I was just loading packages, not compiling new things ...
21:30:04 <ozy`> what the f... what language is this? O_o http://stsdas.stsci.edu/cgi-bin/gethelp.cgi?tail.src
21:33:53 <Gracenotes> the famed Src language
21:34:03 <glguy> pascal?
21:34:14 <ozy`> it's not pascal
21:34:19 <ozy`> but I don't know what it -is-
21:34:33 * Axman6 guesses B
21:34:34 <Axman6> >_>
21:34:48 <Draconx|Laptop> it's not B.
21:34:48 <araujo> many c-like languages out there
21:34:48 <ozy`> "src" isn't seriously a programming language, is it?
21:35:04 <Gracenotes> not really :(
21:35:10 <Draconx|Laptop> it looks kindof halfway between pascal and pre-ANSI C.
21:35:11 <ozy`> what it looks like is random bits of C, pascal, and perl syntax smashed together
21:37:00 <araujo> it doesn't seem like a popular language
21:37:20 <araujo> there are plenty of those ...
21:37:32 <araujo> (no, Haskell is out of that category already)
21:37:39 <Gracenotes> seems to be a science-y language
21:37:54 <Axman6> it isn't FORTRAN is it?
21:38:01 <araujo> no
21:39:03 <araujo> it seems to me like Icon
21:39:43 <Gracenotes> it's SPP
21:39:52 <Axman6> SPP?
21:40:03 <Gracenotes> The native IRAF language is SPP (Subset Pre-Processor), a portable pre-processor language which resembles C.
21:40:04 <Gracenotes> http://iraf.noao.edu/faq/FAQsec12.html
21:40:27 <Gracenotes> doesn't shed much light, but it has a name
21:41:49 <dsrogers> are there file path manipulating functions in haskell?  Like File::Spec from perl?
21:41:51 <Axman6> wtf is IRAF
21:42:05 <pumpkin_> dsrogers: certainly!
21:42:14 <inimino> it's used for analyzing Hubble Space Telescope data, apparently
21:42:28 <dsrogers> pumpkin: name or link?
21:42:28 <Gracenotes> here's the source of an interpreter for it: http://www.ir.isas.jaxa.jp/AKARI/iris_data/trac/iraf64/browser/trunk/src/iraf/math/interp?rev=23
21:42:33 <dolio> mmorrow: "runGhc (Just "/usr/local/lib/ghc-6.10.1/") $ exprType "either Right"" would probably be right, except either and Right aren't in scope.
21:42:36 <pumpkin_> dsrogers: System.Filepath
21:42:41 <pumpkin_> *FilePath
21:42:46 <Gracenotes> the .x files
21:42:54 <Axman6> http://iraf.noao.edu/faq/FAQsec01.html#1001 apparently
21:43:04 <Gracenotes> least descriptive source file names ever
21:43:12 <dolio> And I apparently can't load the prelude without setting the DynFlags, and handing it bottom doesn't work. :)
21:43:14 <inimino> http://en.wikipedia.org/wiki/IRAF
21:43:20 <dsrogers> thanks.
21:45:05 * wli tries to remember what he needed fraction-free Gaussian elimination for now that he's got plausible code to implement it.
21:45:26 <Gracenotes> fractions ain't never hurt nobody
21:46:16 <wli> It's for systems of linear equations whose coefficients are integers and whose solutions are required to be integers.
21:47:12 <wli> Is there an alternative to Data.Array for mutable arrays with more convenient API's?
21:48:02 <Gracenotes> people should write some :(
21:48:06 <Gracenotes> darn people
21:48:31 <pumpkin_> wli: you should look at MUArr in uvector
21:48:39 <pumpkin_> I wouldn't say it has particularly convenient APIs
21:48:44 <pumpkin_> but at least it's 0-indexed :P
21:48:57 <pumpkin_> I respect the flexible indexing, but it also bothers me
21:49:05 <pumpkin_> (of regular arrays)
21:49:13 <wli> 0-indexing is actually not particularly advantageous. The flexible indexing in Data.Array actually helps me crucially.
21:49:20 <pumpkin_> ah, then no :)
21:49:47 <wli> The aggravation centers around runSTArray requiring a return value of an array.
21:51:05 <Gracenotes> what would you prefer to return?
21:51:08 <wli> Being able to do general mutable array crud in an ordinary ST monad instead of some weird monad-like thing that can't have anything done with it is more of what I'm on about.
21:51:19 <wli> Gracenotes: Whatever the linear algebra ends up determining.
21:51:32 <dolio> Then use runST?
21:51:53 <Gracenotes> yeah, I ended up using runST with my STArray
21:51:59 <dsrogers> does anyone know what character set windows uses for filename encoding?  or how to portably handle this detail in haskell?
21:52:05 <wli> The monads are incompatible with runST as far as I can tell. If runST can work with STArrays I'd love to see how.
21:52:06 <Axman6> pumpkin_: where are MUArrs anyway?
21:52:14 <pumpkin_> Axman6: mutable UArrs :)
21:52:19 <ddarius> :t newSTArray
21:52:20 <lambdabot> Not in scope: `newSTArray'
21:52:28 <ddarius> @hoogle newSTArray
21:52:28 <lambdabot> No results found
21:52:29 <Axman6> where. but i found it, Data.Array.Vector
21:52:35 <pumpkin_> , [ty| newMU |]
21:52:36 <lunabot>  luna: parse error on input `|]'
21:52:40 <pumpkin_> , [$ty| newMU |]
21:52:41 <Gracenotes> wli: I added this to wikibooks in hope it would be helpful :) http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays#Freezing_and_thawing
21:52:43 <lunabot>  forall a b . UA a => Int -> ST b (MUArr a b)
21:52:56 <dolio> @type newArray
21:52:57 <lambdabot> Not in scope: `newArray'
21:52:58 <ddarius> wli: The monad that is used with STArarys -is- ST (?)
21:53:10 <dolio> Anyhow, newArray can get you a new STArray.
21:53:17 <ddarius> dolio: Yeah, I remembered but that won't help me because it's a class method.
21:53:27 <Gracenotes> wli: so you can freeze it before runST, but you can also choose to use another result
21:53:46 <wli> There is some sort of wrapping going on that screws it up.
21:53:56 <Axman6> pumpkin_: what sort of indexing functions do MUArrs have?
21:54:05 <pumpkin_> Axman6: readMU? :P
21:54:12 <pumpkin_> you pass it an index and it tells you what's there
21:54:12 <Axman6> heh, ok
21:54:12 <pumpkin_> :P
21:54:24 <pumpkin_> the MU api is pretty sparse
21:54:37 <wli> GraceNotes: That helps a lot.
21:54:39 <Axman6> pumpkin_: seems i could try and use it for the n-bodies thing
21:54:41 <pumpkin_> but very well tested!
21:54:43 <pumpkin_> ;)
21:54:48 <pumpkin_> Axman6: damn right!
21:54:52 <Axman6> like you've been saying all along :P
21:55:00 <pumpkin_> do it do it!
21:55:02 <Axman6> just the interface looked strange to me
21:55:18 <pumpkin_> if you can use the immutable ones, it's pretty listlike
21:55:49 <Axman6> not sure how the performance of immutable ones would go (probably allocate a lot...)
21:56:25 <pumpkin_> well the nice thing is that they fuse a lot
21:57:12 <Axman6> not sure that fusion would help here much though
21:57:15 <dolio> The immutable arrays in uvector are totally for stream fusion. Using them like UArrays in the standard libraries will get you bad results.
21:57:18 <wli> The only linear algebra problem I have to do right now is fiddling with piecewise rational functions in such a way where I drop an order of continuity to regain a degree of freedom so that the denominators can be ensured to be nonsingular.
21:58:21 <pumpkin_> Axman6: why not?
21:58:57 <Axman6> well it involves a lot of updating the array based on the other elements in the array
21:59:02 <wli> The basic idea is to maintain a moving average by modelling the signal as a piecewise rational and then integrating to find a moving average.
22:00:14 <wli> The only plausible idea I've got right now is to minimize variance and do it as a sort of Lagrange multiplier problem.
22:01:23 <wli> Oh, I've got another linear algebra problem: division of algebraic numbers.
22:01:38 <wli> That one really wants arbitrary-precision rational arithmetic.
22:02:05 <pumpkin_> Axman6: well if you want to play with them, try my version out, as the docs are a lot more complete :)
22:02:35 <Axman6> pumpkin_: there's no bounds checking with MUArrs i assume?
22:02:53 <sjanssen> preflex: seen dons
22:02:53 <preflex>  dons was last seen on #haskell 42 minutes and 55 seconds ago, saying: looks like we're going to use the internet condorcet voting service
22:03:03 <pumpkin_> Axman6: in most cases there's not much bounds checking, and if there is, it's only enabled when you enable the safe flag
22:03:09 <sjanssen> dons: so are the U suffixes on all the uvector ops a permanent thing?
22:03:14 <Axman6> ah ha
22:03:42 <pumpkin_> Axman6: those crashes I mentioned a while back are because of me thinking zipU behaved like List.zip, and cutting off the longer array to the length of the second one in the resulting production
22:03:49 <wli> Ooh, speaking of internet condorcet voting, I wanted to try to write a CPO-STV internet webvoting app, but couldn't understand the basics of STV.
22:03:58 <Axman6> pumpkin_: ah, heh
22:04:03 <pumpkin_> but instead the length of the production is always the length of the first array
22:04:48 <pumpkin_> now that I think about it, the representation of zipped UArrs isn't particularly cache-friendly
22:04:49 <Gracenotes> Can you program FP? (Yeah you know me)
22:05:20 <Gracenotes> actually, that's a bit redundant, isn't it
22:05:37 <wli> If anyone can figure out Meek's method or Warren's method of surplus transfers, I'm all ears.
22:05:51 <pumpkin_> sjanssen: I've grown to like those suffixes now :P
22:06:10 <pumpkin_> except in the case where it introduces ambiguity
22:06:37 <sjanssen> pumpkin_: it's kind of annoying that every other library in the world uses qualified modules, but uvector uses the U suffix
22:06:50 <sjanssen> mind, I haven't actually written any code with uvector
22:06:54 <pumpkin_> i.e., if I wanted a mapM for UArrs, would it be called mapMU? that overlaps with mapMU which doesn't exist yet :P
22:07:07 <pumpkin_> (for MUArrs)
22:07:09 * wli just does crap like import Data.Set ; import qualified Data.Set as Set
22:07:42 <pumpkin_> sjanssen: then again, I'm not a big fan of that qualified imports with overlapping names approach
22:07:52 * wli often hides a lot of crap in the unqualified imports.
22:07:52 <pumpkin_> a typeclass for those situations would be nicer, I think
22:08:26 <pumpkin_> sjanssen: also, several of the uvector operations differ from the list operations with the same name
22:08:38 <pumpkin_> ...slightly
22:08:49 <sjanssen> pumpkin_: oh?
22:09:30 <pumpkin_> like the zipU example I gave, or the scans
22:09:36 <Axman6> pumpkin_: what flags should i pass ghc?
22:10:03 <pumpkin_> Axman6: for best performance, they recommend -O2 -fvia-C -optc-O3
22:10:04 <Axman6> when compiling somehting using MUArrs8
22:11:01 <sjanssen> pumpkin_: oh yes, the zipped arrays seem a bit broken
22:11:28 <pumpkin_> sjanssen: well, I can see why they'd do that, and there is a warning if you have safe mode on, in some cases
22:11:41 <pumpkin_> the issue is that the warning isn't when you zip the arrays, it's when you ask for the zipped array's length
22:11:43 <sjanssen> pumpkin_: safe mode?
22:11:45 * wli tries to finish off Gaussian elimination.
22:11:49 <Axman6> pumpkin_: lame, not getting the right numbers :(
22:11:49 <sjanssen> is this library one massive wtf?
22:11:50 <pumpkin_> there's a safe flag you can pass to cabal
22:12:08 <pumpkin_> sjanssen: it enables some bounds checking
22:12:24 * wli is stumped by the need to do bookkeeping to figure out the permutations of rows and columns.
22:12:40 <sjanssen> pumpkin_: bounds checking is off by default?!
22:12:42 <pumpkin_> sjanssen: I still quite like it :P
22:12:44 <pumpkin_> sjanssen: of course! :P
22:12:48 <sjanssen> BOOOO!
22:12:56 <Axman6> sjanssen: the libraries for speed
22:13:00 <sjanssen> I suppose it segfaults on a bad index?
22:13:06 <sjanssen> Axman6: I don't care, that is simply wrong
22:13:10 <pumpkin_> sjanssen: depends how far off the end you go :)
22:13:34 <Axman6> pumpkin_: damn, not bad, it's about the same speed as my STUArray version, but gets the wrong answers
22:13:37 <sjanssen> we're supposed to be better than the competition, guys
22:13:43 <pumpkin_> Axman6: lol
22:13:49 <sjanssen> no deals with the devil, etc.
22:13:57 <pumpkin_> sjanssen: maybe the default should be on
22:13:59 <Axman6> which i've seen happen before, and never knew why it happened
22:14:03 <pumpkin_> and then you can turn it off if you're careful
22:14:21 <pumpkin_> sjanssen: but I have put big warnings in the docs for functions that can overrun their buffers
22:14:56 <sjanssen> pumpkin_: bounds-checked indexing should be the default, with a different function (with unsafe in the name) used for unchecked bounds
22:15:24 <pumpkin_> hmm
22:15:25 <sjanssen> and the unchecked bounds function should only be used when you've proven it correct
22:15:44 <sjanssen> pumpkin_: "overrun their buffers" ... I feel like I've slipped into a parallel Haskell universe
22:15:46 <pumpkin_> presumably by providing a mapping from your function to an agda one?
22:15:55 <sjanssen> pumpkin_: an informal proof is fine
22:15:56 <pumpkin_> sjanssen: hey, this **** is fast :P
22:16:10 <sjanssen> or, if you're too lazy to write a proof, you accept that the code might segfault
22:16:52 <pumpkin_> sjanssen: I'm wary of making any big changes to the architecture of the library :) it's dons' lib, but you should bring it up with him
22:17:19 <sjanssen> dons: the fact that uarrays are not bounds checked is not mentioned any where in the docs
22:17:22 <pumpkin_> I've been tidying it up, writing tests, and documenting it
22:17:38 <sjanssen> dons: IMO this lack of bounds checking is a really bad idea, and totally antithetical to Haskell's ideals
22:17:43 <glguy> bounds checking is for c programmers!
22:18:37 <pumpkin_> sjanssen: it's not all terrible, and maybe he intends for it to be bounds-checked
22:18:40 <pumpkin_> , (toU [1..5]) `indexU` 7
22:18:41 <wli> Algebraic extensions of Q(x) (univariate rational functions with rational coefficients), e.g. extending Q(x) by y(x) such that \sum_{k=0}^n p_k(x)(y(x))^k = 0 where p_k(x) are all polynomials with rational coefficients, is another situation where the polymorphic linear algebra crops up.
22:18:42 <lunabot>  luna: Data.Array.Vector.Stream.indexS: index too large
22:18:48 <pumpkin_> that kind of thing gets caught
22:19:05 <wli> What package is Data.Array.Vector in?
22:19:05 <Axman6> pumpkin_: interestingly, without -fvia-C is faster than with it
22:19:11 <pumpkin_> wli: uvector
22:19:12 <sjanssen> oh shit, don't tell me that it is only caught when -O is on!
22:19:24 <pumpkin_> sjanssen: nah, it catches it all the time :)
22:19:39 <wli> I wonder if there's some other linear algebra package out there.
22:19:41 <pumpkin_> , replicateEachU 1 (toU [10]) (toU [1])
22:19:42 <lunabot>  toU [1.0,4.3168914423e-314,1.0,6.438887233e-314,2.121995791e-314,2.660234...
22:19:45 <pumpkin_> :)
22:19:54 <pumpkin_> that kind of thing doesn't get caught though
22:20:05 <glguy> uvector can be compiled with our without bounds checking iirc. you have to decide at the library installation level
22:20:21 <pumpkin_> glguy: yeah, but even with bounds checking, a lot of the functions don't check yet
22:20:29 <pumpkin_> it's still very much a work in progress I think
22:20:57 <sjanssen> hmm, looks like I'll stick with Data.Array for now
22:21:03 <pumpkin_> , fromU $ zipU (toU [1..10]) (toU [1])
22:21:04 <lunabot>  [1.0 :*: 1.0,2.0 :*: 4.3168914423e-314,3.0 :*: -9.482974354150337e-54,4.0...
22:21:17 <Axman6> ha
22:21:33 <pumpkin_> that one will get caught if safe mode is on
22:21:42 <pumpkin_> the one I wrote above won't
22:22:11 <pumpkin_> sjanssen: if you want really fast code though, it's awesome :P
22:22:16 <pumpkin_> my big number crunching loves it
22:22:54 <sjanssen> , indexU (zipU (toU [0 .. 2^15 - 1]) (toU [1])) (2^15 - 1)
22:22:55 <lunabot>  32767.0 :*: 3.252922975372763e-86
22:23:11 <sjanssen> hmm, how big do we have to get to pass a page boundary?
22:23:18 <sjanssen> hmm, how big do we have to get to pass a page boundary?
22:23:19 <sjanssen> , indexU (zipU (toU [0 .. 2^15 - 1]) (toU [1])) (2^15 - 1)
22:23:20 <lunabot>  32767.0 :*: 0.0
22:23:33 <sjanssen> pumpkin_: what's up with the defaulting to floating point?
22:23:37 <wli> Is it possible to stack monad transformers with mutable array stuff?
22:23:39 <pumpkin_> sjanssen: no clue :)
22:23:49 <sjanssen> mmorrow: ?
22:23:50 <pumpkin_> , indexU (zipU (toU [0 .. 2^15 - 1 :: Int64]) (toU [1])) (2^15 - 1)
22:23:52 <lunabot>  32767 :*: 1.49835e-319
22:24:00 <pumpkin_> , indexU (zipU (toU [0 .. 2^15 - 1 :: Int64]) (toU [1 :: Int64])) (2^15 - 1)
22:24:02 <lunabot>  32767 :*: 11012363255832
22:24:10 <glguy> wli, you can transform with ST or IO as the base monads
22:24:17 <pumpkin_> we're reading mmorrow's uninitialized memory
22:24:23 <glguy> if that's what you meant
22:24:24 <pumpkin_> he's dared me to use it to read his /etc/passwd
22:24:42 <dolio> , newU 1 (\arr -> readMU arr (2^15)) :: UArr Int
22:24:43 <lunabot>  luna: Couldn't match expected type `()'
22:24:43 <mmorrow> dolio: oh snap, i just condensed (the eval + Env + typ part of) luna into a single easy-to-use module:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1515
22:24:58 <dolio> , newU 1 (\arr -> readMU arr (2^15) >> return ()) :: UArr Int
22:24:59 <lunabot>  toU [-1267263922]
22:25:04 <mmorrow> pumpkin: heh
22:25:24 <mmorrow> pumpkin_: i told you, $10 bounty on my /etc/passwd
22:25:29 <pumpkin_> yup :)
22:25:44 <sjanssen> , indexU (toU [0 .. 2^10 - 1 :: Int64]) 1
22:25:45 <lunabot>  1/bin/sh: line 1: 10013 Segmentation fault      ./luna +RTS -N2 -RTS 2>&1
22:25:48 <mmorrow> heh
22:25:49 <sjanssen> why?
22:26:05 <mmorrow> i guess uvector has a bug
22:26:06 <Axman6> ha
22:26:15 <pumpkin_> that's the bug I squashed today
22:26:20 <pumpkin_> actually
22:26:21 <mmorrow> or that i'm just allowing an unsafe function unknowingly
22:26:23 <mmorrow> ah, nice
22:26:23 <Axman6> pumpkin_: this seems to working nicely
22:26:36 <sjanssen> mmorrow: so lunabot isn't in any sort of sandbox?
22:26:48 <mmorrow> sjanssen: the evaluator is in a separate proc
22:26:48 <pumpkin_> mmorrow: is lunabot running on a 32-bit machine?
22:26:49 <wli> glguy: Hmm. If I can pull that off maybe I could use a writer monad to log permutations or some such.
22:26:53 <sjanssen> mmorrow: this memory corruption stuff means an enterprising person can run arbitrary machine code
22:27:00 <mmorrow> that runs and dies for each expression
22:27:02 <dolio> , maxBound :: Int
22:27:03 <lunabot>  2147483647
22:27:08 <pumpkin_> I guess so :)
22:27:08 <Axman6> pumpkin_: and it's almost exactly the same speed as my STUArray version
22:27:18 <mmorrow> sjanssen: well i'll have to update uvector :)
22:27:20 <pumpkin_> Axman6: now you need to coax some fusion out of it :P
22:27:33 <sjanssen> mmorrow: from pumpkin_'s description it seems endemic
22:27:34 <pumpkin_> mmorrow: you can pull from my patch-tag repo :P
22:27:35 <Axman6> not sure if it'll fuse all that well
22:27:51 <mmorrow> pumpkin: cool
22:28:08 <pumpkin_> but yeah, a few of the functions are still dangerous
22:28:19 <mmorrow> which ones?
22:28:30 <pumpkin_> replicateEachU
22:28:31 <sjanssen> pumpkin_: do mutable array writes check bounds?  If not, game over
22:28:48 <pumpkin_> I haven't played with mutable arrays that much, but dolio has :)
22:28:56 <dolio> mmorrow: Where are defaultDynFlags?
22:29:06 <glguy> whatsaMatterU?
22:29:17 <mmorrow> dolio: they're listed a little lower down
22:29:20 <pumpkin_> enumFromToEachU is also dangerous
22:29:34 <dolio> They are?
22:29:37 <mmorrow> dolio: oh, oops. those are the ghc default set
22:29:43 <pumpkin_> , enumFromToEachU 1 (toU [3 :*: 6, 8 :*: 10])
22:29:44 <lunabot>  luna: Ambiguous occurrence `:*:'
22:29:48 <dolio> Right. I didn't see them in the docs.
22:29:50 <mmorrow> dolio: basically, it's vanilla haskell
22:29:58 <mmorrow> dolio: lemme find em
22:30:18 <dolio> But there are like 60 modules, so...
22:30:26 <pumpkin_> http://patch-tag.com/repo/pumpkin-uvector/home is my updated one if anyone wants it
22:30:35 <mmorrow> dolio: http://moonpatio.com/docs/ghc/src/DynFlags.html#defaultDynFlags
22:30:42 * wli tries to get polymorphic Gaussian elimination implemented all the way through.
22:30:57 <mmorrow> pumpkin_: so what would you say is the easiest way for me to hide the unsafe functions?
22:31:10 <mmorrow> (or do whatever to make the bot not vulnerable)
22:31:14 <dolio> Well, in DynFlags. I guess that should have been obvious.
22:31:21 <mmorrow> hehe
22:32:04 <sjanssen> > runST (do v <- newMU 1; forM_ [0 :: Int, -1 ..] $ \i -> writeMU v i i)
22:32:04 <sjanssen> Segmentation fault
22:32:05 <lambdabot>   Not in scope: `newMU'Not in scope: `writeMU'
22:32:06 <sjanssen> fail.
22:32:11 <pumpkin_> mmorrow: installing uvector with the safe cabal flag will be a good start, but I need to think of which ones are dangerous in a writey way, and which are dangerous in a ready way
22:32:17 <mmorrow> dolio: oh, btw here's the ghc hoogle file (jsut do hoogle --convert=ghc.txt .... then  hoogle --data=ghc.hoo DynFlags (e.g.))  http://moonpatio.com/docs/ghc/ghc.txt
22:32:23 <sjanssen> , runST (do v <- newMU 1; forM_ [0 :: Int, -1 ..] $ \i -> writeMU v i i)
22:32:24 <lunabot>  Killed.
22:32:30 <pumpkin_> hah
22:32:39 <pumpkin_> sjanssen is not amused
22:33:03 <pumpkin_> let me check if writeMU is checking bounds with safe on
22:33:09 <sjanssen> mmorrow: if you care about your machine's security, you should probably not use uvector
22:33:19 <mmorrow> ok, so do you suggest i just not import uvector for now, or is the safe flag enough?
22:33:28 <mmorrow> sjanssen: ok
22:33:32 * mmorrow does this
22:33:59 <pumpkin_> sjanssen: yeah, writeMU does check
22:34:02 <pumpkin_> if you have safe enabled
22:34:16 <pumpkin_> mmorrow: if you're paranoid, I'd avoid uvector altogether for now :(
22:34:23 <pumpkin_> but otherwise, the safe flag will raise the bar a little bit :)
22:34:25 <sjanssen> mmorrow: maybe the safe flag is enough, I dunno.  But any lack of memory safety on writes is pretty much game over
22:34:36 <pumpkin_> I'll make a list of the unsafe ones
22:34:41 <Axman6> pumpkin_: i'm a little cut this isn't actually any faster tbh :(
22:34:55 <pumpkin_> Axman6: if it doesn't fuse, it's no faster than any other unboxed array :P
22:35:08 <Axman6> pumpkin_: tips on making things fuse?
22:35:42 <pumpkin_> inline things, be direct :P
22:35:48 <pumpkin_> not sure how to be more specific
22:36:29 <sjanssen> pumpkin_: sometimes the advice is "don't inline things" :)
22:36:44 <pumpkin_> hmm
22:36:56 <mmorrow> pumpkin_, sjanssen: yeah, i'm just gonna avoid it for the moment until we get this sorted
22:36:59 <pumpkin_> well, you basically want to make sure that ghc can see the "next-to" ness
22:37:59 <mmorrow> , indexU (toU [0 .. 2^10 - 1 :: Int64]) 1
22:38:00 <lunabot>  luna: Not in scope: `indexU'
22:38:00 <pumpkin_> for example, I was sad about the lack of a partitionU, so I wrote one that returned its two partitioned arrays in a strict pair (:*:)... it worked fine, but this was preventing ghc from seeing that it could fuse the filter I was using inside the partition with the functions I was using on the components of the strict pair... writing it as two filters sped things up considerably
22:38:28 <pumpkin_> I suppose it may be possible to add some more rules to help it out in my case
22:38:35 <mmorrow> dolio: so that works for you i take it :)
22:39:01 <dolio> No. Even when I call setSessionDynFlags defaultDynFlags, I still get the error telling me to call setSessionDynFlags.
22:39:08 <sjanssen> pumpkin_: consuming or producing multiple arrays is generally a problem for fusion
22:39:15 <pumpkin_> yeah :)
22:39:30 <pumpkin_> I don't expect it to be able to iterate over the source array only once
22:39:39 <pumpkin_> but the "two halves" are individually fusible
22:40:39 <mmorrow> dolio: gah!
22:40:51 <dolio> I didn't try your stuff. I'll try that later.
22:40:55 <dolio> I need some sleep.
22:40:55 <mmorrow> ohh
22:41:23 <mmorrow> dolio: that paste is a single file that should work out-of-the-box
22:41:28 <mmorrow> dolio: cool
22:41:52 <mmorrow> it has "typ" as expType
22:42:24 <mmorrow> ghci -package ghc GHCAPI.hs
22:42:26 <mmorrow> expType "either Right Left"
22:42:28 <mmorrow> and that's it
22:42:48 <mmorrow> it also has eval
22:42:50 <mmorrow> , eval "42"
22:42:53 <lunabot>  <<Integer>>
22:42:53 <mmorrow> this one
22:47:37 <pumpkin_> sjanssen: most UArr functions are perfectly safe, and still crazy fast, btw :)
22:47:47 <pumpkin_> all the list-derived ones like mapU foldU etc.
22:52:03 <Gracenotes> crazy fast dude
22:54:22 <Axman6> how do you get the nice hpc output from a hpc file again?
22:54:27 <Axman6> the html output*
23:04:48 * wli is at a total loss to smoke out how the bookkeeping works for row/column pivoting in Gaussian elimination.
23:24:53 <jeffwheeler> The xml package on Hackage has a very unique cleanliness to it, for an xml package.
23:25:36 <paulvisschers> @djinn a -> a
23:25:36 <lambdabot> f a = a
23:25:51 <jeffwheeler> I was able to parse OS X's plist files with no trouble at all: http://paste2.org/p/151722
23:26:02 <paulvisschers> @djinn ((a -> b) -> c -> d) -> (a -> Maybe b) -> c -> Maybe d
23:26:03 <lambdabot> f _ _ _ = Nothing
23:26:05 <pumpkin_> how about binary plists? :P
23:26:21 <paulvisschers> that was helpful :(
23:26:47 <jeffwheeler> pumpkin_: Isn't there a tool that comes with OS X to convert them? I just want to read iTunes' XML. :)
23:26:51 <Cheshire> paulvisschers, I think it's impossible to make use of the (a -> Maybe b)
23:27:03 <pumpkin_> jeffwheeler: yup
23:27:09 <paulvisschers> Cheshire: :(
23:27:27 <paulvisschers> Cheshire: I have a version now with fromJust, but that isn't what I want
23:27:46 <jeffwheeler> I remember trying to parse the same files years ago with CDuce, an OCaml XML thing, but I had tons of trouble because of plist's horrible style.
23:28:01 <jeffwheeler> For some reason, <key> and related elements are merely sequential, and not tied in any other way.
23:28:29 * jeffwheeler realizes Yi needs an XML mode
23:29:38 <Axman6> @djinn (a -> Bool) -> a -> Either a a
23:29:38 <lambdabot> f a b =
23:29:38 <lambdabot>     case a b of
23:29:38 <lambdabot>     False -> Left b
23:29:38 <lambdabot>     True -> Right b
23:30:03 <Axman6> @djinn (a -> Bool) -> (a -> b) -> (a -> c) ->  a -> Either b c
23:30:03 <lambdabot> f a b c d =
23:30:04 <lambdabot>     case a d of
23:30:04 <lambdabot>     False -> Left (b d)
23:30:04 <lambdabot>     True -> Right (c d)
23:30:33 <david_> hello
23:31:01 <Axman6> o/
23:31:05 <david_> I have a function whom I'd like to use with a filter, the problem is that my function takes two arguments
23:31:30 <david_> myFunc x = filter foo [1 .. 10]
23:31:39 <david_> I'd like to pass x to the foo function
23:31:43 <david_> how do I do that?
23:31:50 <ivanm> david_: filter (myFunc foo) list
23:31:51 <Cheshire> (foo x)
23:31:54 <Axman6> filter (foo x)
23:32:01 <ivanm> or whatever it is ;-)
23:32:11 * ivanm fails at reading functions on IRC :(
23:34:43 <david_> ehm, it complains when I do "myFunc x = filter (foo x) [1 .. x]" (it worked with "myFunc x = filter (foo x) [1 .. 10]")
23:35:04 <jeffwheeler> What does it say?
23:35:21 <david_>     Probable cause: `x' is applied to too few arguments
23:35:35 <jeffwheeler> What's the actual error, above that?
23:35:47 <david_>  Occurs check: cannot construct the infinite type:      a = (a1 -> a1 -> a1) -> a -> a2
23:36:28 <jeffwheeler> What type is (or what do you expect for) x?
23:36:35 <david_> int
23:36:50 <david_> I haven't declared any types yet though
23:36:54 <david_> perhaps that would solve it
23:41:51 <dons> sjanssen: -fsafe is really until i work out a good way to make it safe + fast
23:42:00 <wli> No instance for (MArray IOArray Rational (WriterT [(Int, Int)] IO))
23:42:07 <wli> This is not going well.
23:42:40 <dons> sjanssen: uvector , i guess you mean. its 'experimental'. the U suffixes should go, it needs bytestring intro forms.
23:43:03 <hackage> Uploaded to hackage: Chart 0.10
23:43:42 <pumpkin_> dons: I can work on a Data.Binary instance if you'd like
23:45:14 <dons> i'd like a copying and non-copying way to build them from strict bytestrings, and a fused way to fill them from Data.Binary (so a Binary instance)
23:45:26 <pumpkin_> that makes sense
23:45:42 <dons> then pretty much done. 'cept for good functions on mutable ones
23:45:49 <pumpkin_> it seems necessary though to prefix the data with a length
23:45:57 <pumpkin_> unlike the current UIO implementation
23:47:50 <Gracenotes> @hoogle Monad m => m a -> m ()
23:47:51 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
23:47:51 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
23:47:51 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
23:48:34 <Gracenotes> hm, >> return ()
23:49:36 <pumpkin_> I've also been making a list of all the unsafe functions in uvector
23:49:48 <pumpkin_> so someone can decide what to do about them :)
23:51:32 <Axman6> pumpkin_: put them in the docs of course
23:51:36 <ivanm> pumpkin_: surely that would be as simple as looking for all functions that start with "unsafe"?
23:51:38 <ivanm> ;-)
23:52:10 <ivanm> dons: what was the post that you reddited that was deleted and someone screenshotted and "altered"?
23:52:37 <mmorrow> pumpkin_: i'm actually all for not labeling each and every function with "UNSAFE!!@" that doesn't check bounds, just as long as i know which functions those are
23:53:06 <mmorrow> since the lib's purpose is speed
23:53:11 <trofi> :t (1/0, 1/1)
23:53:12 <lambdabot> forall t t1. (Fractional t1, Fractional t) => (t, t1)
23:53:51 <ivanm> mmorrow: oh, I thought pumpkin meant "unsafe" as in unsafePerformIO :s
23:53:58 <ivanm> not ones that might chuck an out of bounds error, etc.
23:54:22 <mmorrow> unsafe as in you can segfault if you try to read out-of-bounds (instead of throwing an exception in pure code)
23:54:31 <ivanm> ahhh
23:55:17 <__nfw> Hey guys, Haskell newbie here. I'm getting an error in a school assignment saying ERROR "Ass3.hs":21 - Equations give different arities for "canonical"
23:55:27 <__nfw> What are "arities"?
23:55:30 <mmorrow> but if you're scanning an array indexing into it sequentially, and the array is 100000 elems long, if you bounds check by default, that means 100000 bounds checks
23:55:50 <Axman6> __nfw: paste the code and error on hpaste
23:55:54 <Axman6> @where hpaste
23:55:54 <lambdabot> http://hpaste.org/
23:55:56 <Cheshire> __nfw, a length/sequence of elements
23:55:57 <ivanm> __nfw: my guess is that you've defined a function that takes in n arguments, but you're giving it more than n
23:55:57 <Axman6> ^^
23:56:16 <ivanm> Axman6: oh, I thought hpaste was dead :s
23:56:30 <Axman6> nope, it's using hpaste2 now :)
23:56:36 <ivanm> ahhh
23:57:03 <__nfw> Thanks guys
23:57:15 <mmorrow> i think it's a case of:
23:57:16 <__nfw> hpaste is a place to post code for review by others?
23:57:24 <mmorrow> foo n | blah n = ...
23:57:24 <ivanm> __nfw: well, haskell code ;-)
23:57:27 <Axman6> __nfw: well, it's a paste bin
23:57:27 <mmorrow> foo = ...
23:57:32 <Axman6> like any other
23:57:33 <ivanm> otherwise, use a generic paste site like dpaste, etc.
23:57:40 <mmorrow> i wish you could do that all the time
23:57:44 <__nfw> Oh okay, never heard of the concept before
23:57:49 <__nfw> Sorry for the ignorance :)
23:57:50 <mle> Is anyone using wxhaskell on osx?  It builds, and HelloWorld.hs links, but the resulting window isn't selectable in any way...
23:58:03 <__nfw> Anyway, thanks a lot for the help guys
23:58:04 <ivanm> mmorrow: do what all the time?
23:58:09 <Axman6> __nfw: which school btw? wondering where else haskell is being used
23:58:09 <mle> well, it's closable, but that's it
23:58:12 <mmorrow> be able to do:
23:58:16 <mmorrow> foo n | blah n = ...
23:58:17 <mmorrow> foo = ...
23:58:34 <ivanm> oh, can't you do that everywhere?
23:58:43 <pumpkin_> mmorrow: I'm not advocating putting unsafe prefixes on it, just making a list for use somewhere :) I've already documented a few cases of it in the haddock (with N.B: markings) but want to make a more comprehensive list
23:58:47 <mmorrow> it gives you the error that __nfw is getting
23:58:49 <__nfw> University of Victoria
23:59:01 <ivanm> there's a University of Victoria?
23:59:08 <mmorrow> pumpkin_: oh totally, i'm agreeing with you :)
23:59:09 <ivanm> I thought there was just unimelb, rmit, etc. :s
23:59:12 <__nfw> Pretty sure :)
23:59:12 <pumpkin_> yay
23:59:15 <mmorrow> heh
23:59:24 <Axman6> __nfw: Aus?
23:59:25 <shapr> yay Oz!
23:59:26 <__nfw> It's just a section on functional programming
23:59:29 <__nfw> No
23:59:30 <__nfw> Canada
23:59:33 <shapr> oh
23:59:34 <Axman6> lame
23:59:35 <Axman6> :P
23:59:40 <Axman6> shapr: you're not an aussie are you?
23:59:40 <__nfw> lol
23:59:41 <__nfw> sorry
23:59:46 * ivanm agrees with Axman6 
23:59:47 <__nfw> No, Canadian
23:59:52 <ivanm> stupid canadarians :@
23:59:53 <shapr> Axman6: Nah, I'm in Boston, hoping to move to Canada.
23:59:53 <ivanm> ;-)
23:59:56 <pumpkin_> mmorrow: is there any kind of analysis ghc does that makes mutable operations immutable ones if it can determine that the old version is never used again?
