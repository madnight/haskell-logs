00:02:23 <wli> Weird...
00:07:49 <wli> Eulerian numbers of the first kind are stumping me.
00:08:17 <wli> > let eulerFirst n k | k == 0 = 1 | k < 0 || k >= n = error "out of bounds" | k == n - 1 = 1 | otherwise = (n - k) * eulerFirst (n - 1) (k - 1) + (k + 1) * eulerFirst n (k - 1) in [n `eulerFirst` 1 :: Integer | n <- [2 .. 10]]
00:08:19 <lambdabot>   [1,4,5,6,7,8,9,10,11]
00:08:35 <wli> That's not correct.
00:17:32 <boegel> @src foldl'
00:17:32 <lambdabot> foldl' f a []     = a
00:17:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
00:17:37 <boegel> @src foldr
00:17:37 <lambdabot> foldr f z []     = z
00:17:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:18:18 <boegel> am I right to conclude from this that foldl' is more space efficient than foldr is?
00:19:13 <augustss_> boegel: that depends
00:19:20 <boegel> augustss_: on? :)
00:19:34 <augustss_> boegel: if f is strict
00:19:55 <boegel> augustss_: if it is, then there's not much difference?
00:21:37 <boegel> > foldr (+) 0 [1,2,3]
00:21:38 <lambdabot>   6
00:21:39 <augustss_> No, if f is strict foldl' is better
00:22:03 <boegel> how do you make lambabot show the expansion of a fold?
00:22:12 <boegel> I've seen that pass by here...
00:22:19 <Axman6> > foldl f x [a,b,c]
00:22:20 <lambdabot>   f (f (f x a) b) c
00:22:26 <Axman6> > foldr f x [a,b,c]
00:22:27 <lambdabot>   f a (f b (f c x))
00:22:38 <boegel> > foldl' f x [a,b,c]
00:22:39 <lambdabot>   f (f (f x a) b) c
00:22:53 <augustss_> boegel: foldr is not tail recursive, so it will use stack if f is strict
00:22:54 <Gracenotes> > iterate reduce (foldr (+) 0 [1..3])
00:22:55 <lambdabot>   [1 + (2 + (3 + 0)),1 + (2 + 3),1 + 5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,...
00:23:02 <Gracenotes> > iterate reduce (foldl (+) 0 [1..3])
00:23:04 <lambdabot>   [0 + 1 + 2 + 3,1 + 2 + 3,3 + 3,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,...
00:23:09 <boegel> augustss_: hmm, hence the stack overflow I'm seeing
00:23:22 <Axman6> :t reduce
00:23:23 <lambdabot> Expr -> Expr
00:23:26 <boegel> Gracenotes: hmm, thanks, that helps
00:23:30 <wli> @src reduce
00:23:30 <lambdabot> reduce _ 0 = undefined
00:23:30 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
00:23:30 <lambdabot>     where d = gcd x y
00:23:57 <Axman6> :\
00:24:10 <Axman6> > reduce (x + y + z)
00:24:11 <lambdabot>   x + y + z
00:24:18 <Axman6> > reduce (x + y + y)
00:24:19 <lambdabot>   x + y + y
00:24:20 <boegel> is there a strict version of foldlM?
00:24:26 * wli tries to smoke out reduce.
00:24:34 <wli> Or where reduce is defined.
00:24:52 <Gracenotes> it makes Num a => Expr a's simplify instead of just looking pretty
00:24:52 <boegel> @src foldlM
00:24:52 <lambdabot> Source not found. Sorry.
00:24:54 <Axman6> sounds like it should be in simple-reflect
00:25:02 <boegel> @src Data.Foldable.foldlM
00:25:02 <lambdabot> Source not found.
00:25:10 <Axman6> > reduce (1 + 2 + 3)
00:25:11 <lambdabot>   3 + 3
00:25:27 <wli> Data.Ratio I'd expect.
00:25:45 <augustss_> :t reduce
00:25:46 <lambdabot> Expr -> Expr
00:26:20 <boegel> hmm, no foldlM' it seems... any reason why?
00:26:38 <Gracenotes> @src foldM
00:26:38 <lambdabot> foldM _ a []     = return a
00:26:38 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
00:28:24 <Gracenotes> > iterate reduce (foldl (/) 0 [1..4])
00:28:25 <lambdabot>   [0 / 1 / 2 / 3 / 4,0.0 / 2 / 3 / 4,0.0 / 3 / 4,0.0 / 4,0.0,0.0,0.0,0.0,0.0,...
00:28:36 <boegel> Gracenotes: does >>= enforce strictness?
00:28:55 <Gracenotes> It depends on the monad instance
00:29:36 <boegel> Gracenotes: in my case, it's IO
00:29:52 <pumpkin_> it enforces sequencing
00:29:57 <pumpkin_> :P
00:30:22 <boegel> pumpkin_: so? :)
00:30:26 <Gracenotes> lazy IO actions -- they can happen at any time, when you least expect it! :X
00:30:46 <Gracenotes> so strictness there.
00:30:49 <boegel> sorry if I seem clueless here
00:31:47 <Gracenotes> in a lazy language like Haskell, laziness is nice because things don't happen unless they need to
00:32:22 <Gracenotes> unfortunately, that's not a good way of dealing with IO. If you want to send an HTTP request, you want to send it now, so that the side effects are available
00:32:23 <boegel> Gracenotes: yeah, I'm aware of that
00:32:27 <Axman6> well, sometimes nice
00:32:40 <boegel> Gracenotes: but because I'm dealing with a lot of data, I need the stuff I read in to be strict
00:32:51 <pumpkin_> then seq things :)
00:33:19 <Axman6> could use strict bytestrings
00:33:21 <boegel> pumpkin_: I am :)
00:33:22 <Gracenotes> boegel: sorry :)
00:33:29 <boegel> Axman6: I am too :)
00:33:34 <boegel> Gracenotes: that's ok ;-)
00:33:46 <boegel> Gracenotes: you never know, I might learn something ;-)
00:34:19 <boegel> getting Haskell to perform as I wanted to (memory-wise), is harder than I anticipated
00:37:19 <boegel> goddamned, how long can inserting 10x100 pairs in an IntMap take?!?!
00:37:32 <boegel> and it's taking >500M
00:37:34 * boegel runs
00:37:52 <dons> try doing it all at once, not incrementally
00:38:08 * boegel spots an error
00:38:18 <boegel> dons: yeah, I've come to that conclusion too
00:38:25 <Axman6> yeah, incrementally would probably produce a new IntMap each time you insert right?
00:38:44 <boegel> dons: I've changed my data type, now I'm using an IntMap of movie ids to user/rating pairs (both encoded in seperate ByteStrings)
00:39:20 <boegel> dons: that should lower the overhead of the IntMap, and will allow me to construct the ByteStrings for an IntMap entry in one pass, instead of building it one 'element' at a time
00:39:24 <sjanssen> boegel: are you inserting the items strictly?
00:39:50 <pumpkin_> I'm still not convinced a ByteString is the best structure for what you're doing
00:39:52 <boegel> sjanssen: yeah
00:40:23 * boegel spots an error in his function to generate a list of random numbers, and smashes his head on his desk
00:40:46 <Gracenotes> > (  :[    ]  )(                                                                        )
00:40:47 <lambdabot>   [()]
00:40:50 <boegel> pumpkin_: well, neither am I, but atleast then I'm somewhat sure I'm only uses the exact amount of bytes I need to be using
00:41:35 <Gracenotes> > (  :[    ]  )(                                                                                                                                                                                                                                                            )
00:41:36 <lambdabot>   [()]
00:41:59 <Axman6> Gracenotes: super tall angry monkey?
00:42:23 <boegel> ok, now we're talking
00:42:42 <boegel> instead of generating a list of n random numbers, I was generating an infinite list, which doesn't really help
00:43:21 <Axman6> heh
00:44:51 <boegel> ok, inserting ~1M ratings in the IntMap now needs 150M, which seems somewhat reasonable
00:45:12 <boegel> ~10M => 250M
00:45:30 <boegel> it's seems like now we're getting there :)
00:45:36 <Axman6> boegel: what datatype are the ratings?
00:45:55 <boegel> Axman6: well, I encode them in a ByteString now
00:46:05 <Axman6> :\
00:46:08 <boegel> Axman6: they can only be number 1 through 5
00:46:25 <boegel> Axman6: seems like overkill, but I might change that back to a UArray of Word8's
00:46:30 <Axman6> i'd just use an Int8
00:46:40 <Axman6> or Word8
00:46:41 <pumpkin_> I vaguely remember someone saying that a UArray of Bools was bit-encoded
00:46:53 <sjanssen> pumpkin_: it is
00:46:57 <pumpkin_> so it seems strange for a Word8 UArray to use 4 bytes per element
00:47:10 <sjanssen> hmm, that doesn't sound right
00:47:15 <pumpkin_> someone should make a Word4 :P
00:47:21 <pumpkin_> and deal with the nybble unpacking for you
00:48:18 <boegel> it seemed strange to me too, so I posted it on the list
00:48:37 <boegel> maybe it's specific to IntMap, although that would be even stranger somehow
00:48:48 <mdiin> @src (&&&)
00:48:48 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
00:49:01 <boegel> ~90M ratings => 550M
00:49:02 <boegel> w00!
00:49:17 <boegel> now let's see what happens if I use UArrays
00:49:19 <pumpkin_> that's not a very clear definition of &&&
00:49:21 <pumpkin_> :P
00:49:31 <mdiin> Not really, no :)
00:49:43 <pumpkin_> > f &&& g $ a
00:49:45 <lambdabot>   Add a type signature
00:49:50 <pumpkin_> > f &&& g $ a :: (Expr, Expr)
00:49:51 <lambdabot>   (f a,g a)
00:49:55 <pumpkin_> there :P
00:50:02 <redditbot> Paper: Beautiful differentiation
00:50:37 <Gracenotes> @src ***
00:50:38 <lambdabot> f *** g = first f >>> second g
00:50:49 <pumpkin_> that one's clearer at least
00:50:49 <Gracenotes> IMPRESSIVE DEAR SIR
00:51:07 <mdiin> I'm curious as to how the arrow signature of (&&&) can take functions... Anyway, before I start asking questions I'll read up on it properly first. :)
00:51:08 <Axman6> :t (&&&)
00:51:09 <Gracenotes> @src first -- rabbit hole?
00:51:09 <lambdabot> Source not found. Do you think like you type?
00:51:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:51:16 <sjanssen> UArray Word8 uses indexWord8Array#, does anyone know how to find out how this primop works?
00:51:18 <Gracenotes> nope, no deeper
00:51:19 <Axman6> :t (***)
00:51:20 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:51:38 <pumpkin_> sjanssen: I was poking around in there a couple of days ago, let me see if I can find it again
00:52:04 <sjanssen> boegel: how large are your UArrays?
00:52:25 <boegel> sjanssen: in the code I posted on the list, somewhere between 10-10,000
00:52:42 <boegel> sjanssen: now, it's more like 1000-10,000
00:52:47 <boegel> sjanssen: and the IntMap is a lot smaller
00:53:09 <boegel> sjanssen: the former one had 480k keys in the IntMap, the one now has 17,770 keys
00:53:55 <sjanssen> boegel: anyway, I'm fairly certain your hypothesis about UArray Word8 is not correct
00:54:15 <boegel> sjanssen: could be, I'm only saying what I'm observing :)
00:54:29 <dmwit> mdiin: Well, the function type constructor is an instance of Arrow.
00:54:34 <dmwit> mdiin: That's about all there is to it.
00:54:53 <boegel> sjanssen: I didn't see any rise in memory usage when I was using UArray Int Int, which seems mighty strange to me
00:55:47 <boegel> ByteString encoded, ~90M ratings => 548M, UArray of Word8, ~90M ratings => 537M
00:55:50 <boegel> so about the same
00:55:57 <boegel> let's try UArray of Int :)
00:58:27 <pumpkin_> looks to me like it should be using 1 byte per entry
00:58:33 <pumpkin_> still poking around though
00:58:42 <boegel> ah, that gives me 800M
00:59:44 <boegel> maybe I wasn't seeing any difference with the former implementation because I was mainly seeing UArray/IntMap overhead
01:00:08 <boegel> the IntMap had 480k entries, which means 480k keys, 480k UArrays, ...
01:00:16 <boegel> might make sense
01:01:38 <boegel> pumpkin_: try lower the amount of (possible) keys, i.e. the 480,109 in the code
01:01:48 <pumpkin_> ?
01:01:57 <boegel> pumpkin_: that'll yield a smaller IntMap, and larger UArrays
01:02:05 <pumpkin_> oh, I'm just looking around in GHC :)
01:02:09 <boegel> pumpkin_: ah
01:02:30 <boegel> pumpkin_: well, with my current implementation, I'm seeing a big difference between a Word8/Int UArray
01:02:36 <boegel> pumpkin_: i.e. 540M vs 800M
01:03:11 <pumpkin_> that would make sense
01:04:11 <dmorti> Sorry about the newbie question, but can anyone tell me how to upgrade ghc to the latest version?
01:04:25 <quicksilver> dmorti: download a binary package for your OS, is the recommended way.
01:04:46 <dmorti> quicksilver: cheers
01:04:51 <quicksilver> if you use haskell libraries heavily you might first check that all your libraries are supported on the new version as a sensible precaution.
01:05:31 <pumpkin_> sjanssen: I've "tracked down" the primop's functionality :P
01:05:36 <pumpkin_> it's not exactly legible though
01:09:11 <boegel> how much overhead does a plain list have in terms of the number of elements?
01:09:26 <boegel> is it like one word for each element, i.e. a pointer to the tail?
01:09:28 <quicksilver> about 24 bytes per element on a 64 bit platform, IIRC
01:09:36 <quicksilver> 16 bytes on a 32 bit platform.
01:10:46 <boegel> quicksilver: and where does it go to?
01:10:56 <quicksilver> well it's not actually a tax
01:11:02 <quicksilver> the memory stays in your computer
01:11:06 <pumpkin_> lol
01:11:19 <quicksilver> boegel: sorry, I'm not quite sure what you mean?
01:11:32 <pumpkin_> dammit, I'd already sent one of my memory modules off to SPJ
01:12:24 <boegel> quicksilver: why does each element have an overhead over 24 bytes? where is it spent? pointers to the tail of the list, ...
01:12:36 <pumpkin_> you don't get pointers to the tail of the list
01:12:51 <boegel> pumpkin_: I was giving a naive example :)
01:13:48 <quicksilver> boegel: I don't remember the details. The bytestring guys followed it through carefully.
01:14:03 <quicksilver> 1 word for the pointer to the head, 1 word for the pointer to the tail, and 1 word indirection
01:14:12 <quicksilver> that would add up to 24 bytes, on a 64bit system
01:14:14 <quicksilver> could be right.
01:14:42 <boegel> quicksilver: well, you don't get a pointer to the head, right?
01:14:47 <boegel> ah, well, whatever :)
01:15:21 <quicksilver> boegel: sure you get a pointer to the head
01:15:24 <quicksilver> everything is a pointer!
01:15:30 <quicksilver> (except unboxed things)
01:16:06 <boegel> hmmk
01:19:25 <mdiin> dmwit: Okay, thanks. That makes sense
01:19:47 <boegel> using [Word8] instead of UArray Int Word8 (which needs 500M) consumes 2.6G so far, and it still running
01:19:54 <pumpkin_> hah
01:19:55 <boegel> s/it/it's
01:20:13 <Axman6> urgh, TCL/C apps should be banned >_<
01:20:24 <pumpkin_> with a Word8 in a list, the ratio of cruft to content must be huge
01:20:26 <pumpkin_> Axman6: ?
01:21:00 <Axman6> pumpkin_: my uni uses a CPU simulator they wrote for one of my courses, and i'm trying to get it to compile, but it ain't happ'nin
01:21:02 <mmorrow> boegel: you have much more patience than me, i would have resorted to mallocing memory and poke/peek 'ing by now
01:21:05 <boegel> pumpkin_: yeah :) 3/1 or so
01:21:09 <Axman6> well, it compiles, but doesn't run
01:21:25 <boegel> mmorrow: I've decided to go with a Haskell only solution, so... :)
01:21:27 <pumpkin_> boegel: if it's what quicksilver said, 16/24 to 1?
01:21:39 <pumpkin_> boegel: you can do what mmorrow said in "haskell" :P
01:21:40 <mmorrow> boegel: that is a haskell solution! :)
01:21:41 <boegel> pumpkin_: err, right
01:21:44 <quicksilver> pumpkin_: that's neglecting the overhead on the Word8 itself.
01:21:49 <pumpkin_> true
01:22:03 <boegel> pumpkin_: mallocing memory in Haskell?
01:22:17 <mmorrow> foreign import unsafe ccall "malloc" ...
01:22:17 <boegel> quicksilver: howso?
01:22:19 <pumpkin_> boegel: you ask for a region of memory as a ByteArray or something
01:22:21 <mmorrow> or if you'd like
01:22:24 <boegel> mmorrow: hell no! :)
01:22:24 <quicksilver> boegel: well, a Word8 takes more than 1 byte
01:22:27 <mmorrow> foreign import unsafe ccall "mmap" ...
01:22:34 <quicksilver> boegel: even ignoring the fact it's store in a list.
01:22:37 <mmorrow> and mmap /dev/zero\
01:22:43 <mmorrow> s/\\//
01:22:47 <boegel> quicksilver: oh?
01:23:07 <boegel> quicksilver: but I just want the one byte, nothing more! :P
01:23:20 <pumpkin_> you need an unboxed list ;)
01:23:23 <quicksilver> then use a UArray
01:23:24 <quicksilver> :P\
01:23:37 <boegel> quicksilver: however, when I use a UArray of Word8, then each Word8 costs only 1 byte (approx.), right?
01:23:42 <quicksilver> yes.
01:23:47 <boegel> quicksilver: k, great :)
01:23:52 <pumpkin_> an unboxed list where the next pointer is implied, and always points at the element address + element size
01:24:14 <quicksilver> I would say when you're trying to manage your memory this carefully, you *will* need to manage it by hand
01:24:18 <mmorrow> (ghc is either mmapping or mallocing the mem one way or another, why let ghc make all the decisions about how you do thing..)
01:24:20 <quicksilver> that is as true in haskell as it is in C
01:24:28 <quicksilver> (or C++ or whatever)
01:24:43 <mmorrow> you're still using haskell any way you cut it
01:24:57 <pumpkin_> unless you don't
01:25:07 <pumpkin_> :)
01:25:09 <boegel> quicksilver: well, let's say I don't want to use any dirty hacks :P
01:25:13 <mmorrow> heh
01:25:25 <boegel> quicksilver: well, I just want to use a reasonable amount of memory
01:25:31 <pumpkin_> boegel: what you're using is using "dirty hacks" under the hood anyway
01:25:38 <pumpkin_> the UArray is using ByteArray#
01:25:41 <quicksilver> manual memory management isn't a dirty hack.
01:25:48 <quicksilver> it's just a programming technique.
01:25:52 <boegel> quicksilver: the way it's looking now, I should be able to push the data in an "IntMap (UArray Int Int, UArray Int Word8)" in less than 700M
01:26:19 <quicksilver> If you're trying to use your computer's memory efficiently, then you need to design and use an efficient in-memory structure for it.
01:26:23 <boegel> well, then, let's say I don't like the word "unsafe" :)
01:26:36 <pumpkin_> boegel: none of it even needs to be unsafe! :D
01:26:59 <pumpkin_> for some definitions of unsafe
01:27:00 * boegel starts crying "I just want cleanish code, wheeeeeeeeeeeei"
01:27:14 <mmorrow> hehe
01:27:20 <pumpkin_> I do agree that filling code up with # makes it a little hard to read
01:28:14 <pumpkin_> I wonder what happened to centrinia
01:28:18 <pumpkin_> @seen centrinia
01:28:18 <lambdabot> I saw centrinia leaving #haskell 1m 2d 16h 47m 43s ago, and .
01:28:53 <mmorrow> > help
01:28:54 <lambdabot>   Segmentation fault
01:29:01 <pumpkin_> lol
01:29:02 <loop> :O
01:29:09 <mmorrow> hehe
01:29:30 <mmorrow>  @let help = text "Segmentation fault"
01:29:49 <pumpkin_> mmorrow: how long have you been haskelling?
01:30:00 <mmorrow> hmm
01:30:12 <mmorrow> almost a year and a half
01:30:34 <mmorrow> (of relatively heavy use)
01:30:37 <quicksilver> that's pretty depressing.
01:30:39 <pumpkin_> cool
01:31:14 <mmorrow> quicksilver: :)
01:32:53 <pumpkin_> quicksilver: how about you?
01:35:35 <quicksilver> pumpkin_: I'm not entirely surely. 8 years perhaps?
01:37:15 <quicksilver> my first post to -cafe was in 2004
01:37:25 <quicksilver> and I'd been toying with haskell for some years by then
01:39:15 <pumpkin_> :)
01:43:13 <hackage> Uploaded to hackage: AERN-RnToRm 0.4.9.1
01:43:22 * boegel starts crying "I just want cleanish code, wheeeeeeeeeeeei"
01:43:35 <pumpkin_> :)
01:44:13 <boegel> I didn't mean to repeat that...
01:47:37 <fasta> Why is it impossible to specify QuickCheck-2.1.0.1 in the build-depends field in Cabal?
01:47:55 <pumpkin_> it is?
01:48:12 <pumpkin_> you need to specify packagename <relation> version
01:48:52 <fasta> pumpkin_:  Parse of field 'build-depends' failed.
01:49:17 <pumpkin_> what did you put in it?
01:50:01 <fasta> pumpkin_: a list containing QuickCheck-2.1.0.1 as the last element. The list is specified as package1, package2,  QuickCheck-2.1.0.1
01:50:54 <pumpkin_> quickcheck >= 2.1.* maybe?
01:50:56 <int-e> fasta: try QuickCheck == 2.1.0.1
01:51:17 <pumpkin_> that's what I meant by relation version, sorry :)
01:51:17 <fasta> Oh, right, that's the relation pumpkin was talking about.
01:51:21 <fasta> Thanks
01:51:26 <pumpkin_> not the clearest notation :P
01:51:57 <pumpkin_> anyway, bedtime for me
01:52:21 <fasta> Quite a pain to specify all the dependencies ;)
01:55:31 <fasta> There should be a script which runs cabal install until no errors occur while adding all the hidden packages to the cabal file.
01:56:11 <dmwit> I think there is.
01:57:39 <fasta> dmwit: there is mkcabal, which was the only reason, together with scion that I cabalized in the first place.
01:58:08 <fasta> dmwit: but I don't know of any other one.
01:59:50 <shimuaar> Could anyone help me with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1700 ?
02:00:02 <shimuaar> I'm completely puzzled with error message
02:00:16 <toliko_smoren> hey is there a way to read a file with ignoring newline characters?
02:01:04 <dmwit> fmap (concat . lines) (readFile "foo")
02:01:34 <fasta> Also, it seems that Cabal doesn't take the union of extensions specified in the cabal file and in the files themselves like GHC does when compiling.
02:01:37 <shimuaar> filter (/= '\n') will do too
02:01:41 <fasta> Is there a way to get around that?
02:01:52 <dmwit> shimuaar: Ah, yes, that's much better.
02:02:02 <quicksilver> shimuaar: it's not the same "a"
02:02:03 <dmwit> shimuaar: Perhaps you want the ScopedTypeVariables extension.
02:02:23 <fasta> In other words, Cabal completely ignores whatever you have written in the extensions field when you also have file specific extensions.
02:02:24 <quicksilver> shimuaar: that is, the "a" in (undefined::a) is not the "a" introduced in the line before.
02:03:01 <quicksilver> shimuaar: the simplest solution would be
02:03:14 <fasta> dcoutts: can you elaborate on the above?
02:03:18 <quicksilver> scoped type variables
02:03:43 <shimuaar> Oh, thank you. I'll look into them
02:05:33 <toliko_smoren> thanks
02:05:42 <fasta> Hmm, that's not even true. For modules for which no extensions are listed in the module, even the extensions in the extensions field are being ignored.
02:10:36 <mmorrow> fasta: try adding a "forall a." to the typesig. i just found out earlier today that's how i could finally get the frigging `a' in the sig the match up with the `a' in my sizeOf(undefined::a)
02:11:02 <mmorrow> s/the/to/
02:11:07 <fasta> mmorrow: what are you talking about?
02:11:24 <dmwit> mmorrow: That still requires the ScopedTypeVariables extension, of course.
02:11:32 <dmwit> fasta: He was talking to shimuaar.
02:11:39 <mmorrow> um oops, yeah
02:12:02 <mmorrow> dmwit: but just ScopedTyVars alone aren't enough
02:12:11 <dmwit> Right, that's true.
02:12:14 <artyoms> @type readFile
02:12:15 <lambdabot> FilePath -> IO String
02:12:24 <mmorrow> this was driving me crazy until earlier
02:12:27 <mmorrow> (today)
02:13:00 <mmorrow> i kept needing the `a' for a sizeOf, but it wasn't associating it with the `a' in the sig
02:13:35 <mmorrow> but apparently the forall a. is the goods
02:14:17 <quicksilver> the h98 solution is "asTypeOf"
02:14:30 <quicksilver> but that requires you to be able to construct an expression of those types
02:14:35 <dmwit>  asTypeOf doesn't cut it if you don't have a value of the appropriate type.
02:14:37 <quicksilver> which is not easy with empty data decls
02:14:37 <dmwit> right
02:14:48 <dmwit> And even if it were non-empty, you don't want to demand a constructor.
02:14:48 <quicksilver> however, you can always define stupid functions to provide types for you
02:14:55 <quicksilver> in this example,
02:14:57 <mmorrow> quicksilver: heh, i even tried that ;), but the thing was is that is had a:
02:15:00 <quicksilver> stupid :: Succ a -> a
02:15:02 <quicksilver> stupid = undefined
02:15:07 <mmorrow> :: f a -> ...
02:15:13 <quicksilver> toInt x = toInt (stupid x) + 1
02:15:21 <quicksilver> would do the trick, I think ?
02:15:21 <dmwit> quicksilver: =/
02:15:21 <mmorrow> ..... sizeOf(undefined::a)
02:15:22 <mmorrow> ..
02:15:36 <mmorrow> quicksilver: oh nice
02:16:00 <quicksilver> import Data.Stupid
02:16:03 <mmorrow> yeah, i guess youd could just use any dummy function
02:18:44 <toliko_smoren> hey, i am looking for a simple text/font graphics display library, anyone know of one? Should support stuff like bold, and tables would be a nice addition
02:19:50 <jeffz`> toliko_smoren: html?
02:20:45 <toliko_smoren> well i would like to write a simple html rendering engine
02:20:50 <toliko_smoren> i already wrote the parser
02:21:00 <toliko_smoren> so i would not want something that does the work for me
02:21:45 <toliko_smoren> basically i would like simple functions like drawText Text Size Bold
02:21:50 <dmwit> Are you writing your own parser on purpose? =P
02:22:10 <toliko_smoren> yes
02:22:16 <toliko_smoren> it was an assigment
02:22:17 <dmwit> Anyway, the usual GUI library is Gtk2Hs.
02:22:40 <dmwit> Or you could send a call out to dzen, if you're feeling *nix-y.
02:22:57 <toliko_smoren> thanks
02:24:33 <toliko_smoren> dmwit: i am unixophobic unfortunately
02:27:34 <boegel> toliko_smoren: unixphobic? why?
02:27:54 <boegel> toliko_smoren: next to naked chicks, it's the best thing ever
02:28:20 <artyoms> toliko_smoren: could you give some details on what you are trying to accomplish?
02:29:41 <dmwit> boegel: Dunno, I've had some pretty good drugs.
02:31:33 <whpearson> Has anyone implemented a listlike typeclass? Not that it'd be ideal, ideally all things that relied on [a] would be (Listlike m) => m a.
02:31:47 <dmwit> Check out Foldable, Traversable, and their ilk.
02:31:57 <quicksilver> whpearson: Yes.
02:32:20 <quicksilver> whpearson: somebody implemented listlike, (john goerzen) under that name
02:32:28 <quicksilver> also there are other classes as dmwit suggests.
02:32:37 <quicksilver> and I believe the edison library has some typefaces.
02:32:44 <quicksilver> I'm not sure it's such a great idea, to be honest.
02:32:54 <quicksilver> typeclasses are not interfaces or module signatures.
02:33:06 <quicksilver> they're a mechanism for overloading.
02:33:26 <daf> also: just use a list
02:33:37 <daf> it's a great interface for list-like things
02:34:13 <whpearson> quicksilver, I want to newtype deriving (listlike) and then instance a different monoid for lists.
02:34:25 <whpearson> A couple of times.
02:35:20 <dmwit> Sounds like a good idea to me.
02:35:28 <dmwit> Don't let these jokers discourage you. ;-)
02:35:48 <whpearson> So I am using lists, just wrapped up and I don't want to have to unwrap them to do work with them.
02:36:59 <quicksilver> sure. That's overloading.
02:37:10 <quicksilver> knock up a quick typeclass for the operations you need ;)
02:37:41 <quicksilver> alternatively, you could actually jsut use lists
02:37:48 <quicksilver> and pass your monoid operations around explicitly.
02:37:50 <quicksilver> Your cal.
02:39:35 <whpearson> I kinda want to have my cake and eat it too. As in have the newtypes be able to be used as lists or monoids wherever lists and monoids are currently defined.
02:40:28 <dmwit> Well, wishing that the standard libraries used something other than list is probably a bit much to hope for.
02:40:32 <dmwit> Since that's not true.
02:41:16 <dmwit> However!
02:41:27 <whpearson> Indeed, maybe I can write some funky template haskell to automatically rewrite the standard librairies :P
02:41:35 <dmwit> If your typeclass includes fromList/toList, you can write a HOF.
02:41:51 <boegel> w00! using an IntMap (UArray Int Int, UArray Int Word8) data type, I was able to read in the Netflix data set consuming only 640M of RAM, in 26m on my uber-slow PowerBook G4
02:41:55 * boegel does a little dance
02:42:12 <quicksilver> how large is it on disk?
02:42:17 <dmwit> Something like (fromListFunc :: ListLike l => ([a] -> b) -> l a -> b
02:42:23 <dmwit> or...
02:42:33 <dmwit> Something like (fromListFunc :: ListLike l => ([a] -> [b]) -> l a -> l b -- maybe this instead
02:42:34 <boegel> quicksilver: over 2G, but I'm not reading in the time stamps
02:42:41 * quicksilver nods
02:42:46 <fasta> What is the Kolmogorov complexity of the data set? ;)
02:42:56 * boegel has no clue
02:43:07 <boegel> fasta: green?
02:43:13 <quicksilver> 42
02:43:30 <boegel> yeah, that's the answer to everything
02:43:39 <whpearson> dmwit: Hmm, interesting.
02:45:07 <fasta> It would be really funny, if somehow they determined that it is impossible to better than 9.999999999%. :D
02:46:45 <boegel> fasta: it's never impossible, you might get lucky sometimes
02:47:03 <boegel> fasta: with ratings only ranging from 1-5, you're bound to just get lucky sometimes
02:47:23 <fasta> boegel: do they simply test it on one constant test dataset?
02:47:25 <boegel> fasta: or maybe they already did determine that, and they are not telling us
02:47:34 <boegel> fasta: yes
02:47:59 <boegel> fasta: but you only get one number, i.e. the overall RMSE of a _subset_, and you're only allowed one submission each day
02:48:06 <boegel> fasta: so guessing is out of the question :
02:48:15 <Axman6> gahh, C is so frustrating >_<
02:48:27 <Axman6> ... for someone who doesn't know how to use it >_>
02:48:28 <fasta> boegel: ok, so it is possible in theory to win, but they could have rigged it in such a way that any sane program (i.e. a general one) would never be able to win.
02:48:29 <boegel> Axman6: sometimes Haskell is frustrating too
02:48:58 <dmwit> boegel: NEVER
02:48:58 <boegel> fasta: maybe
02:49:32 <boegel> fasta: but, to win the $1M, you don't need to come up with a general program, just one that beats their algorithm by 10% and that particular data set
02:49:52 <boegel> fasta: so screw a general program, just find one that does better on that particular data set
02:49:59 <boegel> that's actually my goal :)
02:50:11 <boegel> stealing the money from them, without giving something useful in return :P
02:50:16 <fasta> boegel: but you don't have that particular data set, or do you?
02:50:28 <dmwit> Absolutely not.
02:50:34 <fasta> boegel: it's some unknown test data set, right?
02:50:44 <dmwit> If you had the data set they were testing against, writing a program to generate its answers would be trivial.
02:50:58 <boegel> fasta: well, we have a data set of 100M known ratings, and a quiz of 2.8M ratings to predict
02:51:30 <boegel> fasta: what most teams, imho, are trying to do, is come up with an algorithm that works good in general
02:51:53 <dmwit> Well, there's only 5^2.8M possible answers...
02:51:57 <boegel> fasta: i.e. their techniques, i.e. SVD, try to estimate ALL possible ratings well, and then they just pick the ratings that are in the quiz set
02:52:17 <boegel> fasta: which is horribly wrong imho
02:52:20 <fasta> But is the quiz set constant or not?
02:52:38 <boegel> fasta: besides, estimating all ratings well with only 1.2% of the data available, is bound to go wrong if you ask me
02:52:49 <boegel> fasta: the quiz set is constant, yes
02:53:14 <boegel> fasta: they take a subset of the quiz to determine if your eligible for a thorough evaluation, afaik
02:53:38 <fasta> boegel: if the evaluation is everytime in the same order, you can easily win.
02:53:52 <boegel> fasta: the RMSE posted on the leaderboard are just for a subset of the 2.8M-ratings quiz
02:54:06 <fasta> boegel: oh, there goes my plan ;)
02:54:15 <boegel> fasta: you only get numbers for a subset of the quiz, and you don't know what subset :)
02:54:25 <boegel> s/numbers/one RMSE
02:54:27 --- mode: irc.freenode.net set +o ChanServ
02:54:36 <boegel> hi ChanServ!
02:54:47 * boegel snickers
03:05:29 --- mode: irc.freenode.net set +o ChanServ
03:19:46 <PeakerWork> @hoogle hGetLine
03:19:47 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
03:19:47 <lambdabot> System.IO hGetLine :: Handle -> IO String
03:19:47 <lambdabot> Data.ByteString.Char8 hGetLine :: Handle -> IO ByteString
03:25:31 <PeakerWork> @hoogle stdin
03:25:31 <lambdabot> System.IO stdin :: Handle
03:26:29 <dmorti> I have another newbie question: I've installed GHC 6.10.1 and cabal.
03:26:50 <dmorti> according to cabal, HUnit is installed, but when I try 'import HUnit'
03:27:21 <dmorti> it fails to load.
03:27:43 <Axman6> @hoogle HUnit
03:27:44 <lambdabot> package HUnit
03:27:44 <lambdabot> module Test.HUnit
03:27:59 <Axman6> import Test.HUnit
03:28:32 <dmorti> thanks; that worked.
03:32:37 <PeakerWork> @hoogle EOF
03:32:37 <lambdabot> Text.Read EOF :: Lexeme
03:32:37 <lambdabot> Language.Haskell.Lexer EOF :: Token
03:32:37 <lambdabot> Text.Read.Lex EOF :: Lexeme
03:32:43 <PeakerWork> @hoogle EndOfFile
03:32:43 <lambdabot> No results found
03:32:50 <PeakerWork> where's the eof exception?
03:35:01 <Axman6> @hoogle End
03:35:02 <lambdabot> System.Posix.Internals end_of_dir :: CInt
03:35:02 <lambdabot> Text.Parsec.Combinator endBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
03:35:02 <lambdabot> Text.ParserCombinators.ReadP endBy :: ReadP a -> ReadP sep -> ReadP [a]
03:39:03 <dmwit> ?hoogle iseof
03:39:03 <lambdabot> System.IO isEOF :: IO Bool
03:39:03 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
03:39:03 <lambdabot> System.IO.Error isEOFErrorType :: IOErrorType -> Bool
03:39:20 <dmwit> PeakerWork: ^^
03:39:30 <dmwit> :t catch
03:39:32 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
03:39:39 <dmwit> :t hIsEOF
03:39:40 <lambdabot> Not in scope: `hIsEOF'
03:39:56 <dmwit> :t System.IO.hIsEOF
03:39:57 <lambdabot> GHC.IOBase.Handle -> IO Bool
03:43:01 <Taejo> is it possible to get cabal to always generate documentation?
03:43:55 <ivanm> Taejo: you mean cabal-the-library or cabal-install?
03:44:02 <ivanm> and by documentation, you mean haddock docs?
03:44:13 <Taejo> ivanm: cabal-install, and yes
03:44:38 <Taejo> I'd like "cabal install foo" to generate haddock docs for foo and put them in a standard place
03:44:42 <ivanm> cabal install --docdir maybe?
03:44:56 <ivanm> Taejo: just check, are they in ~/.cabal/doc or something already?
03:45:43 <Taejo> ivanm: ~/.cabal/share/doc has LICENSE files in it only
03:45:52 <ivanm> @seen dcoutts
03:45:53 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 5m 9s ago.
03:45:59 <ivanm> dcoutts: get in here!
03:46:14 <dcoutts> @arr!
03:46:14 <lambdabot> I want me grog!
03:46:23 <PeakerWork> dmwit: thanks
03:46:28 <ivanm> dcoutts: Taejo wants to know if cabal-install can always generate haddock docs by default
03:46:39 <dcoutts> Taejo: edit your ~/.cabal/config file and turn doc generation on
03:47:08 <Taejo> dcoutts: thanks
03:47:40 <dcoutts> it can also be turned on/off from the command line, but to make it persistent it goes in the config file
03:47:52 <ivanm> or an alias? :p
03:48:06 <dcoutts> huh?
03:48:25 <ivanm> a bash alias ;-)
03:48:30 <dcoutts> bah
03:48:33 <ivanm> (if you can do it from the command line)
03:48:35 <ivanm> heh
03:48:45 <ivanm> dcoutts: how bout a humbug whilst you're at it?
03:48:52 <ivanm> :p
03:48:58 * dcoutts grins
03:50:04 <redditbot> Installing GHC, Gtk2HS & Cabal on Ubuntu 8.04
03:50:24 <ivanm> step 1) get a decent distro?
03:50:25 <ivanm> :p
03:50:45 <dmwit> Ubuntu is decent.
03:50:53 <boegel> is calling Haskell's type system 'strong' correct?
03:51:01 <dmwit> I had no trouble with Gtk2Hs, Cabal, or GHC when I was on Ubuntu.
03:51:14 <Axman6> boegel: it's a strong static typing system
03:51:16 <dmwit> boegel: I've never heard of a strong type system.
03:51:33 <ivanm> dmwit: yes, but if you need a blog post to help you work out how to install a few simple packages... *shrug*
03:51:37 <Axman6> ivanm: step 2) get a decent OS
03:51:57 * Maddas ducks and takes cover
03:52:07 <ivanm> Axman6: why, what do you use?
03:52:16 <Axman6> anything not linux :)
03:52:18 <Maddas> (Arguing about OSs *and* type systems at the same time cannot end well!)
03:52:19 <boegel> dmwit: hmm, what should it be called then?
03:52:25 <boegel> dmwit: static, what else?
03:52:25 <Axman6> sick of it, always pisses me off
03:52:31 <pejo> Are you guys kind of drifting into an OS war now?
03:52:31 <ivanm> Axman6: heh
03:52:38 <ivanm> pejo: skirting the edges of
03:52:51 <Axman6> the BSD's don't seem to piss me off anywhere near as much
03:52:56 <ivanm> we could always make it a trifecta and bring up choice of editors... ;-)
03:53:04 <Axman6> and of course OS X
03:53:59 <dmwit> boegel: Never mind me, apparently "strong" is a perfectly good word to apply to type systems.
03:54:31 <Maddas> ivanm: I'm not very opinionated about editors as long as they run well under Emacs.
03:54:39 * Maddas smirks
03:54:53 <ivanm> dmwit: though one explanation of types says that "strong" means that the type system you prefer is best :s
03:54:58 <ivanm> Maddas: heh
03:55:21 <Waleee> hi, is it possible to write 2-dimensional array comprehension (not a recursive array generation) in haskell?
03:55:39 <ivanm> Waleee: it's not possible to write an any dimensional array comprehension
03:55:47 <ivanm> list comprehensions are a different story, however
03:56:05 <boegel> dmwit: ah, k, you confused me a bit there :)
03:56:24 <dmwit> > [[(x, y) | x <- [1..5]] | y <- [6..10]] -- 2D list comprehensions are of course possible
03:56:26 <lambdabot>   [[(1,6),(2,6),(3,6),(4,6),(5,6)],[(1,7),(2,7),(3,7),(4,7),(5,7)],[(1,8),(2,...
03:56:59 <Waleee> ok, i figured it would be possible that a haskell version would be similar to Clean array-comprehensions
03:57:07 <Axman6> > let f xss = [x | xs <- xss, x <- xs] in f ["test","hello"]
03:57:08 <lambdabot>   "testhello"
03:57:08 <Waleee> thanks
03:58:23 <Axman6> > let f xss = [(xs,x) | xs <- xss, x <- xs] in f ["test","hello"]
03:58:24 <lambdabot>   [("test",'t'),("test",'e'),("test",'s'),("test",'t'),("hello",'h'),("hello"...
03:58:28 <Waleee> and since the Clean channel have been dead as long as i remember it's pretty useless to ask there
03:58:53 <pejo> boegel/dmwit, people invent their own terminology to fit their purposes. I think one of the first chapters in TAPL point out that there is no consensus what strong means.
03:58:55 <ivanm> Waleee: I don't know what clean says, but in Haskell lists /= arrays
03:59:13 <Axman6> ok, sleep time. night all
03:59:36 <Waleee> I know that, but the syntax forl lists is as far as I can tell fairly similar
03:59:40 <Waleee> *for
04:02:19 <dmwit> Why good morning, my good byorgey!
04:02:38 <boegel> is there a Drupal module which will allow one to create nice blog posts on Haskell code?
04:02:53 <ivanm> dmwit: so where is your evil byorgey then?
04:02:54 <ivanm> ;-)
04:03:34 <dmwit> I keep him in the closet.
04:03:46 <dmwit> It's getting hard these days to find enough flesh to feed it. ;-)
04:04:25 <ivanm> heh
04:05:17 <zem-> 'ello
04:05:45 <dmwit> Hiya!
04:07:32 * zem- needs some help installing hieroglyph - cabal fails with a bunch of "not in scope: type constructor or class `Gtk.Event'" and suchlike
04:07:54 <zem-> but gtk2hs installed cheerfully enough
04:08:08 <dcoutts> zem-: is that definitely the latest version of hieroglyph?
04:08:22 <zem-> not sure, it's the one off cabal
04:08:22 <dcoutts> it may not yet have been updated for gtk2hs-0.10
04:08:50 <zem-> hm - will check the website
04:08:58 <dcoutts> well if it's the latest one on hackage then then you're probably out of luck, ask the maintainers
04:09:27 <zem-> will do, was wondering if i was missing some dependency
04:10:09 <dcoutts> zem-: no, just some minor api changes in the gtk package
04:10:14 <ivanm> zem-: how are you attempting to install hieroglyph?
04:10:28 <dcoutts> zem-: you could probably fix it by editing the code to import an extra module
04:10:34 <zem-> tried both the arch package and cabal install
04:10:43 <toliko_smoren> hey i get a linking error when trying to use gtk2hs 0.9.3 in ghci
04:10:46 <zem-> (i think the arch package just called cabal anyway)
04:10:58 <ivanm> ahhhh.... deps would probably be right then
04:10:59 <dcoutts> toliko_smoren: pthreads?
04:11:02 <ivanm> just an API issue
04:11:39 <toliko_smoren> Unknown PEi386 section name ".reloc"
04:11:50 <toliko_smoren> panic impossible happened
04:11:54 <zem-> will email jeff and ask
04:11:54 <toliko_smoren> i am using the  provided demos
04:14:59 <juhp__> does lambdabot read hackage?
04:15:18 <ivanm> juhp__: no
04:16:09 <toliko_smoren> i just read that i should
04:16:10 <toliko_smoren>    * when linking, ignore unknown .reloc section that appeared in gcc, how can I do that
04:31:04 <bassgeweih> join #macscene
04:31:19 <daf> no
04:38:35 <rmoss> is there a better way to write: any ((ord x)==) ([65..90]++[97..122])
04:39:04 <rmoss> without using isLetters or isAlpha :p
04:40:05 <BONUS> why without using isLetters or isAlpha
04:40:30 <rmoss> because I'm defining myIsLetters
04:40:54 <ivanm> rmoss: maybe using two seperate ranges rather than ++, to save on concatenation?
04:40:58 <BONUS> yeah
04:41:20 <ivanm> or have the concatenation defined elsewhere, which makes it compiled down rather than occur each time you use the function
04:41:48 <BONUS> also
04:41:49 <ivanm> though having (x => 65 && x <= 90) etc. should be cheaper than checking list elements
04:41:49 <BONUS> @src elem
04:41:50 <lambdabot> elem x    =  any (== x)
04:41:53 <ivanm> functions not data! ;-)
04:44:27 <BONUS> myIsLetters x = let x' = ord x in x' => 65 && x' <= 90 || x' => 97 && x' <= 122
04:44:44 <ivanm> BONUS: even better, define a range function!
04:44:52 <BONUS> yeah i was thinking about that
04:45:48 <ivanm> > let range min max x = x >= min && x <= max; myIsLetters x = (range 65 90 x) || (range 97 122 x) in myIsLetters 23
04:45:49 <lambdabot>   False
04:46:05 <ivanm> @type range min max x = x >= min && x <= max
04:46:06 <lambdabot> parse error on input `='
04:46:09 <BONUS> :t inIntervals intervals x = any (\(a,b) -> x >= a && x <= b) intervals
04:46:10 <lambdabot> parse error on input `='
04:46:13 <BONUS> whoops
04:46:22 <BONUS> :t \intervals x -> any (\(a,b) -> x >= a && x <= b) intervals
04:46:23 <lambdabot> forall a. (Ord a) => [(a, a)] -> a -> Bool
04:47:04 <BONUS> > let inIntervals intervals x = any (\(a,b) -> x >= a && x <= b) intervals in inIntervals 10 [(9,11),(20,22)]
04:47:05 <lambdabot>       No instance for (Num [([(t, t1)], [(t, t1)])])
04:47:05 <lambdabot>        arising from the ...
04:47:10 <BONUS> > let inIntervals intervals x = any (\(a,b) -> x >= a && x <= b) intervals in inIntervals [(9,11),(20,22)] 10
04:47:11 <lambdabot>   True
04:47:31 <ivanm> well, it'd be something like (Ord a) => a -> a -> a -> Bool
04:47:51 <BONUS> myIsLetters = inIntervals [(65,90),(97,122)] . ord
04:50:06 <saml> > [..]
04:50:07 <lambdabot>   <no location info>: parse error on input `..'
05:07:45 <klibbigt> if i have /Matrix/Matrix.hs and /Topology/Homology.hs , how do I import Matrix ? /Matrix and /Homology being on the same level
05:08:18 <quicksilver> klibbigt: import Matrix.Matrix
05:13:27 <klibbigt> quicksilver: doesnt work
05:13:55 <klibbigt> its ghc/ghc-6.10.1/progs/Matrix/ ghc/ghc-6.10.1/progs/Topology
05:14:45 <klibbigt> where does ghc start looking?
05:15:52 <SamB_XP> klibbigt: I'm not familiar with that part of the GHC source tree
05:17:05 <fasta> klibbigt: there are multiple ways. One way is to just add the directories to the search path.
05:17:20 <fasta> klibbigt: -L, IIRC, but man ghc will tell you for sure
05:18:11 <fasta> klibbigt: a "better" way is if you name your module Foo.Bar.Baz in a consistent way.
05:18:41 <fasta> klibbigt: where Foo is a directory name, Bar is a directory name and Baz.hs exists below these directories.
05:18:59 <klibbigt> from some basedir?
05:19:06 <klibbigt> but how does ghc no where the base is?
05:19:23 <dmwit> -I
05:19:41 <klibbigt> when compiling I pass -I and basedir?
05:20:03 * dmwit reads back to make sure he's talking about appropriate things
05:20:43 <dmwit> Are you writing Matrix, or are you installing it?
05:28:24 <klibbigt> i have written it
05:29:41 <dmwit> Okay, then yeah, -I is probably what you want.
05:29:56 <dmwit> Keep in mind that you must have "module" declarations that match their locations relative to the base directory.
05:29:57 <klibbigt> unreocnied flags
05:30:02 <dmwit> uh
05:30:33 <klibbigt> unrecognied
05:31:04 <klibbigt> spells like a donk klibbigt does
05:31:23 <dmwit> sorry, -i
05:31:42 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#search-path
05:32:11 <Taejo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1708#a1708 -- is there a way to write this function without explicit recursion? Is it a fold? Is it an unfold?
05:32:47 <dmwit> I doubt that even parses.
05:33:30 <Taejo> dmwit: a minor issue :-)
05:33:31 <dmwit> But it looks like a simple map/filter combo to me.
05:33:57 <dmwit> transpose delta xs = [x - delta | Right x <- xs]
05:34:49 <Taejo> dmwit: no. delta changes as it recurses through the list
05:35:06 <klibbigt> C:\ghc\ghc-6.10.1\progs\Topology>ghc --make -i C:/ghc/ghc-6.10.1/progs/ -O2 Main
05:35:06 <klibbigt> .hs
05:35:17 <klibbigt> Main.hs:2:7:
05:35:17 <klibbigt>     Could not find module `Topology.Homology':
05:35:17 <klibbigt>       it is not a module in the current program, or in any known package.
05:35:24 <dmwit> Taejo: Ah, you're right, I wasn't paying close attention.
05:36:04 <dmwit> klibbigt: Oh, boy.
05:36:18 <dmwit> klibbigt: -i is colon-separated, which is totally horrible for poor Windows people.
05:36:34 <dmwit> klibbigt: Try giving a relative path instead of an absolute one.
05:36:51 <dmwit> ghc --make -i ../ghc/ghc-6.10.1/progs -O2 Main.hs # or something like that
05:38:15 <dmwit> Taejo: If you really want to de-recursion that, here's what I would suggest.
05:38:46 <dmwit> Taejo: First fold [Either Int Int] to [(Int, Int)], where each element of the latter list is a (delta, Right-value) pair.
05:38:55 <dmwit> Taejo: Then map (uncurry (-)).
05:39:09 <dmwit> Taejo: You could probably also do it with a single fold, but the code would be messy.
05:39:16 <klibbigt> this is annoying as fuck
05:39:25 <klibbigt> cant i cave the direct paths then to compile?
05:39:51 <dmwit> Taejo: On the other hand, just changing the second case to be "transpose _ (Left delta : xs) = transpose delta xs" would be readable enough; do you really need to remove the recursion?
05:40:11 <dmwit> :t foldr
05:40:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:40:44 <Taejo> dmwit: I don't need to; I was just curious
05:40:49 <Taejo> thanks for your help
05:42:10 <quicksilver> klibbigt: in 8 years of haskell use I've never used -i.
05:42:24 <quicksilver> klibbigt: I either have modules in my current directory or I install them 'properly' as packages.
05:46:41 <pejo> JaffaCake, does GHC do something clever for deriving Eq-instances for lists, or is it pretty much according to Wadler & Blott?
05:47:41 <JaffaCake> pejo: nothing special AFAIK - what did you have in mind?
05:47:48 <chrisdone> I use setCurrentDirectory at lot in GHCi
05:48:30 <klibbigt> quicksilver: how do I install them properly then?
05:48:44 <klibbigt> it is just that Matrix.hs is still udnder development
05:49:38 <quicksilver> then I'd put it in the current directory of your current project
05:50:00 <klibbigt> well id did
05:50:08 <klibbigt> anyway how do i dod packages?
05:50:52 <kohwj> just wondering- what projects do you all work on?
05:51:11 <quicksilver> klibbigt: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
05:51:24 <klibbigt> if i have a data-structure that i want to do some stuff to, like set 3 poitns in a matrix, can i chain it through these competitions somehow elegantly?
05:52:21 <Raevel> klibbigt: Are you perhaps thinking of, Constructor . doStuff . deconstructor ?
05:52:33 <pejo> JaffaCake, a naive translation for eqList will take apart the dictionary, and then reassemble a new one for the recursive call. (Been trying to -ddump-deriv with GHC but unable to interpret the output).
05:52:54 <Raevel> (where deconstructor = \(Constructor x) -> x)
05:53:21 <JaffaCake> pejo: I'm pretty sure we share the dictionary construction
05:54:17 <pejo> JaffaCake, (they suggest that "it's easy for the compiler to perform beta reductions to transform terms ..")
05:54:27 <klibbigt> i have function f like = f m x y and i want to apply f to m-instance sveeral tiems with different x and y. so: doto m f =>> 10 10 =>> 10 20 =>> 30 40, etc?
05:55:08 <lilac> Taejo: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=1708#a1709
05:56:11 <toliko_smoren> hey how can i check if something is of certain type, for example if (isType a Tag), is there a way of not doing it manually
05:56:24 <dmwit> klibbigt: zipWith (f m) [10, 10, 30] [10, 20, 40]
05:56:26 <Taejo> lilac: nice
05:56:54 <dmwit> toliko_smoren: Type information does not exist at runtime.
05:57:01 <Botje> toliko_smoren: the type system enforces types.
05:57:13 <Botje> toliko_smoren: do you mean which tag you have?
05:57:18 <dmwit> toliko_smoren: It generally isn't needed, since types are know statically.
05:57:21 <toliko_smoren> for example i have
05:58:03 <toliko_smoren> data Node = Element Tag [Attr] [Node]
05:58:03 <toliko_smoren>           | Text String  and wish to check whether a certain thing is an element or a text inside the function(after pattern matching)
05:58:20 <Botje> but you know that because you pattern matched?
05:58:24 <toliko_smoren> no i dont
05:58:29 <dmwit> Why not?
05:58:38 <Botje> toliko_smoren: can you put example code on hpaste?
05:58:42 <toliko_smoren> sure
05:58:50 <Ferdirand> use case with a pattern match
05:59:16 <toliko_smoren> i can use case, thanks,
05:59:24 <toliko_smoren> ah i cant
05:59:26 <toliko_smoren> i want to filter
05:59:39 <lilac> @check let transpose1 _ [] = []; transpose1 _ (Left x:xs) = transpose1 x xs; transpose1 d (Right x:xs) = x-d:transpose1 d xs; transpose2 d xs = foldl go (d, id) xs `snd` [] where go (d, f) (Left x) = (x, f); go (d, f) (Right x) = (d, f . (x-d:)) in \n xs -> transpose1 n xs == transpose2 n xs -- Taejo
05:59:40 <lambdabot>   "OK, passed 500 tests."
05:59:53 <dmwit> Look, this is exactly what pattern matching was made for.  So you better paste some code.
05:59:57 <toliko_smoren> code want make sense to you, is there a way without manually writing a helper function, to filter a list based on the types of the things in it
05:59:57 <Botje> toliko_smoren: you could write an isElement function that returns true for ...
06:00:12 <toliko_smoren> ok, I just thought that there might a more elegant way of doing it
06:00:21 <paper_cc1> toliko: filter (\n -> case n of Element _ _ _ -> True, Text _ -> False) nodes
06:00:30 <Botje> toliko_smoren: one way is [ x | x@(Element _ _ _) <- list ]
06:00:43 <toliko_smoren> thanks
06:00:46 <Botje> but with a helper function you get filter isElement list
06:00:47 <Taejo> lilac: glad to know how to do it, but I'm going to stick with my variant for now
06:00:53 <lilac> toliko_smoren: if you want runtime type tagging, you can either use a 'data' wrapper (data X = X1 X1 | X2 X2 | ...) or a typeclass (one of your own or *shudder* Data.Typeable)
06:00:59 <Botje> so if you have to do the same thing multiple times, better write a helper function
06:01:20 <dmwit> I often write catamorphisms for my types.
06:01:33 <dmwit> It's pretty handy for this sort of thing.
06:01:37 <klibbigt> dmwit: no that is not what i want at all
06:02:25 <lilac> Taejo: you're building your return type from right to left but passing data from left to right; this makes neither foldl nor foldr 'natural'
06:02:40 <Botje> reverse state monad!
06:02:41 <Taejo> lilac: right
06:02:41 * Botje runs
06:03:03 <lilac> Taejo: so you can cheat and build a function to compute the answer by composition instead of by recursion :)
06:03:31 <dmwit> klibbigt: You'd better explain again what you want, then, since I didn't understand the last explanation.
06:04:02 <lilac> Botje: hmm, foldM over the reverse state monad might work pretty nicely :)
06:06:39 <klibbigt> dmwit: setAt m 3 4 1 then  setAt m 3 3 1
06:06:59 <klibbigt> if i could pass along m through setAt several times
06:07:29 <dmwit> :t zipWithM
06:07:30 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:07:31 <dmwit> :t sequence
06:07:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:07:34 <dmwit> :t zipWith3
06:07:35 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:08:09 <dmwit> I think your claim that it was not what you wanted *at all* was too strong. ;-)
06:08:36 <klibbigt> i tried zip3
06:08:47 <klibbigt> zipWith3 and it is not what i want
06:08:54 <klibbigt> it does not do that at all
06:10:45 <pejo> JaffaCake, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1710#a1710 is what I end up with after dumping; is the dictionary for the recursive call hidden? (Sorry about all the questions, ghc is somewhat mysterious to me).
06:11:07 <lilac> klibbigt: sounds like the state monad might help you
06:11:34 <JaffaCake> pejo: is that -ddump-deriv or something?  you might want to try -ddump-simpl
06:13:42 <drdozer> can cabal be convinced to recursively build profile libraries?
06:13:44 <dmwit> klibbigt: I'm still having trouble understanding exactly what question you're asking.
06:13:53 <lilac> klibbigt: then 'setAt x y v = modify (\m -> Matrix.setAt n x y v)', and you can say "do setAt 3 4 1; setAt 3 3 1 `execState` m"
06:14:00 <dmwit> klibbigt: Maybe you could post a longer code snippet showing how to do it "the hard way."
06:14:10 <dmwit> Then we could help suggest ways to make it less painful.
06:14:15 <dcoutts> drdozer: not automatically, we cannot yet track profiles libs separately from normal ones
06:14:31 <lilac> dmwit: i believe what klibbigt wants is implicit chaining of a data structure through a number of functions which return modified versions of that structure
06:14:52 <drdozer> dcoutts: pitty - it's a bit painful to chase these things down
06:14:55 <dmwit> I've got to run.
06:14:57 <klibbigt> where is modify?
06:14:59 <dmwit> Good luck, all!
06:15:03 <dcoutts> drdozer: yeah I know :-(
06:15:04 <lilac> klibbigt: Control.Monad.State.Class
06:15:28 <drdozer> dcoutts: seems like each thing you can build can produce multiple artefacts - documentation, the lib, the profiled lib and so on
06:15:44 <dcoutts> drdozer: indeed and should be tracked separately
06:15:48 <lilac> @index modify
06:15:49 <lambdabot> Control.Monad.State, Control.Monad.RWS
06:16:03 <drdozer> dcoutts: yeah, and the list is probably open-world
06:16:31 <dcoutts> drdozer: yes, that's the plan for ghc-6.12, to modify the installed package info to list a "way"
06:16:36 <dcoutts> which would be open
06:16:50 <drdozer> kk#
06:17:31 <drdozer> right, time to find out (with the use of the profiler) why my program runs fine with 1E5 iterations but runs out of stack with 1E6
06:17:34 <pejo> JaffaCake, ah, was bitten by some kind of specialisation as well. Ok, on track now, thanks! (Yes, that was -ddump-deriv, was hoping for some short output).
06:22:05 <klibbigt> how can i destructrue a 3 elem list? (\(x:y:z) then z is expected to be [Int] it seems
06:22:38 <dmead> klibbigt, what do you mean?
06:22:51 <Ferdirand> (x:y:z:[]) ?
06:23:08 <dmead> y and z can be  nil
06:23:10 <dmead> []
06:23:55 <klibbigt> Couldn't match expected type `Double' against inferred type `Int' , wtf!?
06:24:11 <klibbigt>  Couldn't match expected type `Double' against inferred type `Int'
06:24:12 <klibbigt>  In the fourth argument of `M.setAt', namely `(z :: Double)'
06:24:27 <dmead> ?pastbin
06:24:27 <lambdabot> Unknown command, try @list
06:24:32 <dmead> ?paste
06:24:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:24:37 <dmead> paste your code
06:24:54 * boegel finally finished his blog post on winning the Netflix Prize with Haskell
06:25:05 <boegel> I'm too much of a perfectionist to do this type of thing :(
06:25:06 <dmead> boegel, you won the netflix prize?
06:25:25 <boegel> dmead: I wish :)
06:25:27 <dmead> ;p
06:25:33 <boegel> dmead: I'm trying too though
06:25:36 <dmead> i know people trying to do it with ruby
06:25:43 <lilac> > let at k = do {v <- get; return (v!k)}; set k v = modify (// [(k,v)]); runArray = flip execState in  runArray (array (1,3) $ zip [1..] [1,5,9]) $ do v1 <- at 2; set 1 v1; set 3 (2*v1)
06:25:44 <lambdabot>   array (1,3) [(1,5),(2,5),(3,10)]
06:25:56 <lilac> klibbigt: ^^ there you go (using Array not Matrix, but...)
06:26:37 <lilac> klibbigt: destructure a three-element list with: \[x,y,z] ->
06:27:03 <lilac> klibbigt: but if you're doing that, you should probably be using a three-tuple or a data type instead :)
06:27:09 <paper_cc> > (\[x,y,z] -> x ++ y ++ z) ["hello", " ", "world"]
06:27:11 <lambdabot>   "hello world"
06:27:44 <klibbigt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1711#a1711
06:28:36 <chessguy_work> 'morning
06:28:38 <lilac> klibbigt: lists are homogenous
06:28:49 <lilac> klibbigt: that means that if you force z to be :: Double, then x :: Double and y :: Double too
06:29:15 <lilac> klibbigt: the type of M.setAt presumably requires x :: Int and y :: Int
06:29:46 * boegel does a little dance
06:29:54 <lilac> klibbigt: use a 3-tuple not a list of three elements and you'll be OK (tuples are heterogenous)
06:30:28 <klibbigt> no that doesnt help
06:31:17 <lilac> klibbigt: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=1711#a1713
06:33:38 <klibbigt> man it is always like this with haskell
06:33:45 <drdozer> kk, I've found the three functions that are burning up all the time in this app
06:33:45 <chessguy_work> lol
06:34:06 <klibbigt> everyone is all hanky-doory and awesome until you run into some really annoying retarded problemw itht he typesystem
06:34:08 <boegel> klibbigt: don't feel obliged to use Haskell if you don't need it :)
06:34:09 <drdozer> the profile names things like: sample_a6H2
06:34:16 <lilac> klibbigt: it gets easier
06:34:21 <lilac> klibbigt: (much much easier)
06:34:36 <lilac> klibbigt: haskell's learning curve is like this: |
06:34:38 <chessguy_work> and then you realize that of course the type system is right and you were being silly...
06:34:41 <drdozer> is there a way to go back from this to the line in a file, or the particular implementation that provides 'sample', or do I have to guess?
06:34:48 <boegel> lilac: :D
06:35:03 <boegel> @quote lilac haskell's learning curve is like this: |
06:35:03 <lambdabot> lilac says: @type let in let wtf (In wft) = In wtf in wtf
06:35:13 <boegel> @add-quote lilac haskell's learning curve is like this: |
06:35:13 <lambdabot> Unknown command, try @list
06:35:16 <boegel> @lisr
06:35:16 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:35:18 <boegel> @list
06:35:18 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:35:24 <klibbigt> boegel: but it is so elegant it always sucks me back (and then spits me out)
06:35:30 <lilac> is it @quote-add ?
06:35:39 <boegel> @remember lilac haskell's learning curve is like this: |
06:35:39 <lambdabot> I will never forget.
06:35:44 <kohwj> I don't know if this is just part of generally accepted haskell programming style- but why does so much source code out there not use namespaces (for example, "startEditor" instead of "Yi.Core.startEditor" or "yic.startEditor") to make sure that people who read the code know which module contain the functions being used
06:35:46 <boegel> @quote lilac
06:35:46 <lambdabot> lilac says: is happpy with his infinite type. it's ducks all the way across and down.
06:35:53 <int-e> boegel: this? http://en.wikipedia.org/wiki/Dirac_delta_function
06:36:02 <boegel> int-e: eh?
06:36:04 <chessguy_work> boegel, it's @remember
06:36:17 <int-e> oh. that was meant for lilac I guess
06:36:30 <boegel> chessguy_work: yeah, figured it out
06:36:34 <boegel> int-e: I guess so :)
06:36:36 <Botje> kohwj: namespaces don't add much if you are using system packages
06:36:40 <chessguy_work> oh, missed it
06:36:57 <bombshelter13> kohwj: maybe dots already look like function composition, so by avoiding dotted function names you reduce confustion?
06:36:58 <Botje> kohwj: and if it's really necessary, people do qualified imports
06:37:26 <lilac> int-e: i was more thinking of the Heaviside (sp?) function
06:37:40 <senxhnsshp> ah wait, how do i destructuire a tuple?
06:37:44 <lilac> int-e: but i like the idea of a learning curve which looks like _|_
06:37:56 <Botje> senxhnsshp: the same way you construct it
06:37:57 <bombshelter13> senxhnsshp: secondelem (x,y,z) = y
06:37:57 <chessguy_work> senxhnsshp, use lambdas
06:38:04 <int-e> lilac: I like the idea that it's infinitely high
06:38:08 <chessguy_work> @type \(a,b,c,d) -> c
06:38:09 <lambdabot> forall t t1 t2 t3. (t, t1, t2, t3) -> t2
06:38:12 <int-e> (but the view from the top must be great!)
06:38:16 <SamB> int-e: but the let down!
06:38:26 <SamB> also you don't get to see it for too long do you ?
06:38:40 <int-e> SamB: you just have to know when to stop ;)
06:39:30 <chessguy_work> i like this flowchart of how one guy thinks in haskell: http://www.zonetora.co.uk/NonBlog/blogImages/haskellvsjava1.png
06:39:32 <lilac> int-e: in our lifetimes, we will never summit her. true haskell zen is entrancing but unattainable
06:40:02 <int-e> SamB: really, my idea was that if it's infinitely high, you'll never get to the other side anyway.
06:40:12 <chessguy_work> lilac, as is mathematical zen i suppose
06:40:58 <drdozer> freq = map (\i -> (head i, length i)) . group . sort
06:40:59 <kohwj> Botje: hm, i guess that boils down to how familiar one is to those functions
06:41:06 <drdozer> this doesn't scale very well to working with very long lists
06:41:21 <drdozer> as the 'group . sort' forces all of the data to be in memory
06:41:24 <Botje> kohwj: ghc warns you if you have conflicting names
06:41:25 <kohwj> bombshelter13: dunno... aren't they often used with spaces in between?
06:41:27 <dmwit> Hehehe, "Was blog post a monad tutorial" has only "yes" coming out of it. =P
06:41:30 <chessguy_work> @pl \i -> (h i, l i)
06:41:30 <lambdabot> liftM2 (,) h l
06:42:13 <chessguy_work> dmwit,  :)
06:42:22 <dmwit> > liftM (:) (+) 3 [succ]
06:42:23 <lambdabot>       Overlapping instances for Show (a -> a)
06:42:23 <lambdabot>        arising from a use of `s...
06:42:36 <dmwit> :t liftM (:) (+) 3 [succ]
06:42:37 <lambdabot> forall a. (Enum a, Num a) => [a -> a]
06:42:51 <dmwit> > liftM (:) (+) 3 [succ] 1
06:42:52 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a1]'
06:42:54 <SamB> preflex: 8ball was blog post a monad tutorial
06:42:54 <preflex>  my reply is no
06:42:54 <lilac> chessguy_work: nice. i'm especially proud that i was able to figure out what 'the answer' does without touching GHC :)
06:42:56 <dmwit> > liftM (:) (+) 3 [succ] [1]
06:42:58 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a1]'
06:43:04 <dmwit> argh
06:43:17 <dmwit> > fmap ($1) $ liftM (:) (+) 3 [succ]
06:43:18 <lambdabot>   [4,2]
06:43:19 <kohwj> Botje: yup, but I find it a little inconvenient for beginners- maybe because I'm not so familiar with all those functions
06:43:25 <drdozer> so I guess I need to re-write it in terms of foldr
06:44:01 <dmwit> :t ?liftM (:) (+) 3 [succ]
06:44:02 <lambdabot> forall t a a1 t1 a2. (Enum a2, Num t1, Num a1, ?liftM::(a -> [a] -> [a]) -> (a1 -> a1 -> a1) -> t1 -> [a2 -> a2] -> t) => t
06:44:15 <SamB> > the answer
06:44:16 <lambdabot>   Not in scope: `the'Not in scope: `answer'
06:44:38 <klibbigt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1711#a1715
06:44:41 <Botje> kohwj: give it time ;)
06:44:43 <klibbigt> ^^ so why si this bitchin?
06:44:49 <lilac> liftM (:) (+) 3 [succ] = [(3+), succ]
06:45:06 <skorpan> (f *** g) ~(a,b) = (f a,g b) <- what does ~ mean here?
06:45:22 <pejo> kohwj, do other languages do it that way?
06:45:22 <Botje> klibbigt: foldl wants two arguments
06:45:26 <chessguy_work> skorpan, it's an irrefutable pattern
06:45:27 <lilac> klibbigt: the first argument to foldl is supposed to be a function of two arguments
06:45:27 <Botje> well, the lambda
06:45:39 <Deewiant> > let (f *** g) ~(a,b) = (f a,g b) in ((+1) *** (+1)) undefined
06:45:40 <lambdabot>   (* Exception: Prelude.undefined
06:45:44 <Deewiant> > let (f *** g) (a,b) = (f a,g b) in ((+1) *** (+1)) undefined
06:45:46 <lambdabot>   * Exception: Prelude.undefined
06:45:54 <skorpan> ...okay?
06:45:57 <chessguy_work> skorpan, the tuple will always match (like _), and it will throw an error when you use anything that gets bound there if it's not of the right form
06:46:01 <Deewiant> skorpan: it says whether there's a ( there or not ;-)
06:46:17 <skorpan> i don't get it at all
06:46:18 <dmwit> skorpan: ~ is a lazy pattern match.
06:46:24 <michaelcdever> anyone know if there is functionality within gtk2HS for context menus? i.e. right click menu?
06:46:24 <klibbigt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1716#a1716
06:46:32 <kohwj> pejo: what are you referring to- function composition or making sure that module names are clear (that's necessarily not a language feature, but a reader-considerate action)?
06:46:33 <dmwit> skorpan: It says to the compiler: "assume the match succeeds, just trust me".
06:46:41 <Deewiant> skorpan: so basically, it's lazy, the match is always true and it only fails when you try to use one of the variables in it
06:46:46 <kohwj> Botje: i certainly will- i plan to write a substantial haskell project in March, and I'm thinking of ideas
06:46:48 <skorpan> oh
06:46:51 <skorpan> that's weird
06:46:52 <dmwit> skorpan: So, even if the value is undefined, your pattern will "see" a constructor there.
06:46:57 <pejo> kohwj, forcing people to write out the module names.
06:46:58 <Deewiant> skorpan: in the above example it means that *** on undefined is known to be a pair
06:47:01 <Botje> have fun :)
06:47:11 <doserj> > let f (a,b) = 2 in f undefined
06:47:13 <lambdabot>   * Exception: Prelude.undefined
06:47:18 <doserj> > let f ~(a,b) = 2 in f undefined
06:47:19 <lambdabot>   2
06:47:20 <skorpan> weirdie weird weird!
06:47:22 <Deewiant> skorpan: if it's not irrefutable, it first tries to match (a,b) to undefined and fails
06:47:24 <klibbigt> ah ofc
06:47:26 <klibbigt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1716#a1717 <- but still dosnt work
06:47:30 <skorpan> but yeah i think i get it, thanks
06:47:40 <kohwj> pejo: no language i know of does that. but i just think that it's just a good practice to do so- i makes code (slightly) easier to understand
06:47:40 <chessguy_work> skorpan, the idea is, if you pass something else in as that parameter, you'll get a real error instead of it saying that the patterns are incomplete
06:48:06 <skorpan> but in this particular example, how does "lazy" pattern matching help? a and b are both used
06:48:14 <kohwj> pejo: i.e. in Python, one could do a "import * from Blah", but i read that that's not encouraged
06:48:25 <chessguy_work> skorpan, i suspect it's pseudo-code in this instance
06:48:34 <skorpan> chessguy_work: this is in the Yi parser code
06:48:48 <klibbigt> wait it shouldnt work
06:48:50 <klibbigt> perhaps
06:48:51 <chessguy_work> @type ?f *** ?g
06:48:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a, ?g::a b' c', ?f::a b c) => a (b, b') (c, c')
06:48:59 <klibbigt> hmm
06:49:04 <skorpan> the comment says "Local versions of our Control.Arrow friends (also make sure they are lazy enough)"
06:49:11 <kohwj> pejo: i mean "from Blah import *"
06:49:27 <chessguy_work> skorpan, ok, yeah, so it doesn't evaluate the tuple thunk
06:49:59 <chessguy_work> skorpan, i.e., if you pass in a thunk that would evaluate to a tuple, it remains a thunk
06:50:05 <skorpan> okay...
06:50:05 <redditbot> AVar released (three times) - Data.Random
06:50:46 <dmead> klibbigt, you got it?
06:50:55 <klibbigt> why isnt foldl (\(a, (b,c,d)) -> a*b*c*d) 1 [(1,2,3),(4,5,6)] allowed? cannot construc tinfite type
06:51:10 <klibbigt> dmead: no my connections sucks
06:51:21 <Deewiant> ?ty foldl
06:51:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:51:33 <Deewiant> ?ty \(a, (b,c,d)) -> a*b*c*d
06:51:34 <chessguy_work> skorpan, making sense?
06:51:34 <lambdabot> forall t. (Num t) => (t, (t, t, t)) -> t
06:51:41 <Deewiant> klibbigt: that doesn't match a -> b -> a
06:51:54 <Deewiant> ?ty \a (b,c,d) -> a*b*c*d
06:51:55 <lambdabot> forall a. (Num a) => a -> (a, a, a) -> a
06:52:00 <Deewiant> klibbigt: that's probably what you wanted
06:52:03 <dmead> klibbigt, your defintition of seta takes a mapping, not a tuple
06:52:19 <skorpan> chessguy_work: yeah, a bit
06:52:31 <skorpan> chessguy_work: in this particular case i still don't see why ~ is being used though
06:52:54 <klibbigt> dmead: so what do i do?
06:52:54 <dmead> klibbigt, and not a list
06:53:07 <dmead> what are you trying to do?
06:53:19 <dmead> i don't understand what this code does, but the types are clearly not matching
06:53:49 <dmwit> skorpan: For deep recursion and folds, ~ matching on tuples is absolutely critical.
06:54:04 <dmead> klibbigt, oh  i see
06:54:06 <dmwit> skorpan: You'll blow your stack otherwise.
06:54:08 <lilac> klibbigt: (\(a,(b,c,d)) -> ...) is a function of /one/ argument (which is a tuple)
06:54:17 <dmead> get rid of the M
06:54:19 <lilac> klibbigt: (\a (b,c,d) -> ...) is a function of /two/ arguments
06:54:19 <dmead> m
06:54:25 <klibbigt> apply f to m with args x,y,z then do it again with new args x,y,z
06:54:26 <dmead> why is the m there
06:54:40 <dmead> remove the m
06:54:46 <dmead> no?
06:54:52 <drdozer> @src foldr
06:54:52 <lambdabot> foldr f z []     = z
06:54:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:55:02 <dmead> you aren't useing foldl correctly
06:55:08 <klibbigt> are you checking the m?
06:55:16 <dmead> > foldl (+) 0 [1..10]
06:55:17 <klibbigt> chekcign the last one i Mean?
06:55:17 <lambdabot>   55
06:55:19 <drdozer> @paste
06:55:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:55:26 <klibbigt> makeA = let m = M.matrix0 10 10 in
06:55:27 <klibbigt>         foldl (\(mtrx, (x,y,z)) -> M.setAt mtrx x y z)
06:55:27 <klibbigt>               m [(0,0,1.0),(1,1,1.0)]
06:55:53 <klibbigt> the m is the 0 in foldl (+) 0 [1..10]
06:56:10 <chessguy_work> skorpan, because what's being passed to the "(f *** g)" is an arrow, so if it didn't use an irrefutable patterns, it would have to evaluate the arrow to see if it's a tuple or not
06:56:32 <skorpan> okay
06:56:33 <dmwit> klibbigt: You probably want foldl (\mtrx (x,y,z) -> M.setAt mtrx x y z).
06:56:47 <chessguy_work> @type (f *** g) h
06:56:48 <lambdabot>     No instance for (SimpleReflect.FromExpr (b, b'))
06:56:48 <lambdabot>       arising from a use of `h' at <interactive>:1:10
06:56:48 <lambdabot>     Possible fix:
06:56:50 <dmead> klibbigt, still, your quad-tuple isn't matching to anything
06:56:59 <chessguy_work> @type (?f *** ?g) ?h
06:57:00 <lambdabot> forall b c b' c'. (?h::(b, b'), ?g::b' -> c', ?f::b -> c) => (c, c')
06:57:27 <chessguy_work> then again, i could be full of hogwash
06:57:32 <dmwit> klibbigt: Have you worked through the difference between the two types ((a, b) -> c) and (a -> b -> c)?
06:57:32 <dmead> klibbigt, do you really mean setAt :: Matrix repr -> (Int, Int, Double) -> Matrix repr1
06:57:34 <klibbigt> dmwit: ah yes
06:57:42 <klibbigt> no w i see i was just oassing one arg
06:57:43 <klibbigt> duhh
06:57:51 <dmwit> klibbigt: It's one of the most mind-blowing experiences, the first time you realize what exactly is going on with those two types. =)
06:57:53 <dmead> no, you want to pass one arg
06:58:00 <dmead> but your function is curried for 4
06:58:08 <dmead> -> -> ->
06:58:10 <dmead> where you want
06:58:13 <dmead> (,,,)
06:58:39 <chessguy_work> ah right, well it would still have to evaluate the tuple thunk enough to break the two components out of it, which decreases the laziness of it. the irrefutable pattern allows you to write the RHS in terms of the components without doing that
06:58:52 <dmwit> (,,,)      (,,,)    -- bear claws!
06:58:57 <dmead> rawr!
06:59:06 <klibbigt> (a -> b -> c) is a function that takes a and b and rsults in c. ((a,b) ->) is a function that takes a 2-tuple and returns a c
06:59:18 <dmead> haskell bear will construct your type
06:59:19 <dmead> !
06:59:35 <dmead> klibbigt, correct
06:59:38 <dmwit> klibbigt: Well, that's one way to think of it.  Another way is to think of (a -> b -> c) as being a function that takes an a and returns another function (!) from b to c.
06:59:45 <dmead> but you don't wrote the other parens in a->b->c
07:00:06 <paper_cc> though you may
07:00:11 <dmead> aye
07:00:19 <dmead> i guess thats a style choice
07:00:25 <klibbigt> it works now if i wasnt clear, dmwit did what i wanted
07:00:32 <dmwit> klibbigt: This is the key insight in functional programming: functions can be values, and can be passed to functions or returned from functions.
07:00:58 <chessguy_work> @type (?f *** ?g) *** ?h
07:00:59 <lambdabot> forall (a :: * -> * -> *) b c b' c' b'1 c'1. (?h::a b'1 c'1, Arrow a, ?g::a b' c', ?f::a b c) => a ((b, b'), b'1) ((c, c'), c'1)
07:01:00 <dmwit> Well... *a* key insight, I guess. =)
07:01:21 <dmwit> Not needing state is pretty neat, too. =)
07:01:29 <chessguy_work> yay for tuples!
07:02:00 <dmead> do you guys know why cross products in type sigs weren't included in haskell?
07:02:09 <dmead> i guess instead we have typles
07:02:15 <dmead> *tuples
07:02:18 <chessguy_work> and ADTs
07:02:24 <dmead> ML has cross products and ADTs
07:02:33 <dmead> haskell doesn't have an ADT?
07:02:45 <dmead> wot you talkin bout bruh
07:02:50 <chessguy_work> sure it does
07:02:54 <byorgey> dmead: Haskell has cross products too, they're called tuples.  it's just syntax.
07:03:27 <dmead> thats what i thought
07:03:28 <dmead> etc
07:03:33 <dmead> i mean, i know that
07:03:42 <dmead> well
07:03:45 <dmead> it's not just syntax
07:03:58 <byorgey> how's that?
07:03:58 <drdozer> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=1718#a1718
07:04:09 <dmead> tuples are like logical AND but i'm not sure cross products mean AND
07:04:09 <drdozer> any ideas how I can fix this to work on arbitrary length lists?
07:04:24 <drdozer> cross products mean 'also'
07:04:29 <dmead> thats what phillip wadler says, that tuples are like logical and
07:04:35 <dmead> cross products are not AND
07:04:52 <dmwit> dmead: Err, what?
07:04:56 <quicksilver> this usage of the phrase 'cross product' is unfamiliar to me in this context
07:05:08 <quicksilver> 'cross product' is something you do with vectors.
07:05:21 <quicksilver> 'cartesian product' - often denoted by an 'x' - is AND, though.
07:05:47 <chessguy_work> it's like in an ADT if you have data Foo = Bar | Baz Int String
07:05:55 <chessguy_work> the | is like addition
07:06:03 <chessguy_work> and the Int/String combination is like multiplication
07:06:12 <dmead> hmmmm
07:06:15 <drhodes> @hoogle String -> IO String
07:06:16 <lambdabot> System.Environment getEnv :: String -> IO String
07:06:16 <lambdabot> Prelude readFile :: FilePath -> IO String
07:06:16 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
07:06:17 <chessguy_work> (cross-product)
07:06:32 <mattam> dmead: what's a cross-product in ML?
07:06:41 <dmead> quicksilver, yea i guess people abuse terms of cross and cartesian product sometimes
07:06:45 <boegel> how do you guys ever get work done if you hang around here all day long? :)
07:06:47 <chessguy_work> and "Baz Int String" is isomorphic to Baz (Int, String) of course
07:06:56 <dmead> mattam, like a tuple type in haskell
07:07:10 <dmead> boegel, my code is compiling, come back later
07:07:12 <byorgey> which is the same as  Baz of Int * String  in ML, IIRC
07:07:13 <dmead> thats how
07:07:24 <chessguy_work> byorgey, yes, that's my understanding too
07:07:30 <chessguy_work> but i couldn't remember the syntax
07:07:37 <dmwit> drdozer: Do you know the range of inputs ahead of time?
07:07:45 <dmwit> drdozer: If so, a single accumArray would be quite nice for this.
07:08:19 <drdozer> dmwit: the input list is generated from [] to the head elsewhere in the program (in MonadRandom)
07:08:20 <boegel> dmead: :D
07:08:26 <quicksilver> chessguy_work: ignoring _|_, at least. But that's required to stay sane.
07:08:40 <chessguy_work> yes, bottom is a party pooper
07:08:51 <dmwit> drdozer: I don't know what that means.
07:09:26 <drdozer> dmwit: I have a function that generates the input array by sampling some random numbers
07:10:21 <dmwit> Okay.  I'm asking if the range of those numbers is small enough that you could have an array of Ints, using the values of the input list as indices.
07:10:42 <dmwit> i.e. is the range smaller than, say, a million?
07:11:04 <drdozer> dmwit: ah, ok - the range is 'small' in my current application, yes
07:11:09 <dmwit> Okay.
07:11:15 <dmwit> :t accumArray
07:11:16 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
07:12:24 <maltem> boegel: Out of curiosity, how did the UArray thing turn out?
07:13:06 <drdozer> dmwit: the list is being generated by a call to replicateM - so perhaps that's my problem
07:13:16 <boegel> maltem: see my blog post :)
07:13:22 <dmwit> :t \min max xs -> accumArray (\n _ -> succ n) 0 (min, max) (zip xs (repeat ())
07:13:22 <maltem> ah ok
07:13:23 <lambdabot> parse error (possibly incorrect indentation)
07:13:32 <boegel> maltem: see http://boegel.kejo.be :)
07:13:35 <drhodes> so a channel in silicon wide enough that the wave function of an
07:13:35 <chessguy_work> ah, the netflix problem
07:13:49 <dmwit> :t \min max xs -> accumArray (\n _ -> succ n) 0 (min, max) (zip xs (repeat ()))
07:13:50 <lambdabot> forall e i. (Ix i, Num e, Enum e) => i -> i -> [i] -> Array i e
07:13:52 <boegel> chessguy_work: :)
07:14:04 <dmwit> :t assocs
07:14:05 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
07:14:19 <dmwit> :t \min max xs -> assocs $ accumArray (\n _ -> succ n) 0 (min, max) (zip xs (repeat ()))
07:14:20 <lambdabot> forall i e. (Num e, Enum e, Ix i) => i -> i -> [i] -> [(i, e)]
07:14:46 <dmwit> drdozer: Something like the above might be worth a shot.
07:15:01 <drdozer> dmwit: thx
07:15:05 * boegel plans on winning the $1M and laughing his ass off knowing you guys could've done it too
07:15:33 <klibbigt> can soemone give a simple example of using >>= ?
07:15:50 <dmwit> readFile "foo" >>= print
07:16:14 <dmwit> readFile "foo" >>= putStr -- probably better
07:16:26 <klibbigt> dmwit: but with pure functions
07:16:43 <dmwit> readFile and putStr are pure functions.
07:16:47 <maltem> boegel: But, hasn't there been a problem with that data structure being larger than it should?
07:16:54 <dmwit> Or: (>>=) is not for pure functions.  Depending on what you mean by pure.
07:17:02 <klibbigt> boegel: yeah beating exerienced machine learnign specialisst that work on netflix prize daily is easy
07:17:03 <skorpan> > Just 'a' >>= Nothing
07:17:04 <lambdabot>   Couldn't match expected type `Char -> Maybe b'
07:17:08 <skorpan> .....
07:17:12 <drdozer> @src replicateM
07:17:13 <lambdabot> replicateM n x = sequence (replicate n x)
07:17:20 <dmwit> > Just 'a' >>= const Nothing
07:17:21 <lambdabot>   Nothing
07:17:26 <skorpan> ah of course
07:17:34 <skorpan> > Just 'a' >>= const $ Just 'b'
07:17:35 <lambdabot>   Couldn't match expected type `a -> a1'
07:17:39 <skorpan> oh come on!
07:17:51 <dmwit> > Just 'a' >>= (const $ Just 'b')
07:17:52 <lambdabot>   Just 'b'
07:18:04 <skorpan> there's always something
07:18:06 <dmwit> =)
07:18:13 <doserj> > [1,2,3] >>= return . (+2)
07:18:14 <lambdabot>   [3,4,5]
07:18:40 <dmwit> > [1..3] >>= sequence [(+2), (*7)]
07:18:41 <lambdabot>   [3,7,4,14,5,21]
07:18:54 <dmwit> It's so simple! ;-)
07:23:29 <klibbigt> boegel: so what technique do you plan on using? i guess if you think you really can win(i notice now you have PhD so I guess you know your shit) you don't want to share it(yet)...
07:23:57 <klibbigt> btw, grat explanation of svd in what it actually does on the netlix set, i have been trying to read and while
07:24:18 <klibbigt> been trying to udnerstand in very basic terms what it is about but wasnt able to really grok it until now
07:25:08 <cads> klibbigt: are you referring to a post somewhere, or an in channel conversation
07:25:25 <klibbigt> i mean understand what it spits out
07:25:58 <boegel> klibbigt: a) I don't have a Phd yet, I'm still working towards it
07:26:07 <boegel> klibbigt: stay tuned on my blog for more :)
07:26:29 <boegel> klibbigt: I have no idea if I can actually win it, but I have some ideas
07:27:19 <boegel> maltem: yes, that was the case when I used user IDs as a key in the IntMap
07:27:43 <boegel> maltem: I think I was seeing the overhead of the IntMap, combined with the overhead of the UArrays (which were very small)
07:28:09 <boegel> maltem: I think the saving in terms of space when using Word8 was hidden behind the overhead
07:28:41 <boegel> maltem: if I would use Int now for the ratings, instead of Word8, then the memory usage would be like 1G, I tried it this morning
07:29:13 <boegel> klibbigt: I'm not saying that beating ML specialists is easy, I just think I have a different view on things
07:29:19 <klibbigt> what is word8? a "word" in the bytesense?
07:29:33 <quicksilver> it's a 8-bit word
07:29:36 <quicksilver> also known as a byte :)
07:29:41 <boegel> klibbigt: an 8-bit word
07:29:43 <cads> Does netflix wish to own the algorithm that wins the netflix contest?
07:29:49 <boegel> cads: yes
07:29:54 <boegel> cads: that's part of the rules
07:30:26 <klibbigt> boegel: how would you restructure the data? like do you have 1 array of movies which each movie point to an array of reviews and then one array with users that each ahve a pointer to all their ratings(using pointer not in the C sense)
07:30:34 <boegel> cads: if you manage to come up with something that's eligible for winning money (progress prize or grand prize), they require you to write a paper on it, and share the code with everyone (including them, duh)
07:31:13 <boegel> klibbigt: well, right now, it's an IntMap of movie IDs to a pair of UArrays, one with user IDs, one with ratings
07:31:20 <cads> so the algorithm then goes to the public domain?
07:31:31 <boegel> cads: I think so, yes
07:31:40 <cads> that almost sounds altruistic of them :)
07:31:47 <boegel> cads: as long as they can use it, and gain money with it, they're fine :)
07:32:01 <quicksilver> cads: algorithms are in any case not copyrightable.
07:32:10 <quicksilver> and according to some people, at least, they're not patentable.
07:32:12 <cads> patentable
07:32:13 <boegel> cads: if one does manage to come up with an algorithm that significantly outperforms theirs, then they gain a lot more than $1M
07:32:16 <quicksilver> although other people disagree quite strongly.
07:32:23 <cads> here in the united states they are
07:32:41 * boegel doesn't give a fuck what happens to his code, just give me the $1M :)
07:32:43 <klibbigt> boegel: so the UArrays contians multiple entries of the same key?
07:32:44 <quicksilver> being in the public domain doesn't stop the algorithm being patented, though.
07:32:54 <boegel> klibbigt: one UArray doesn't no
07:33:01 <quicksilver> it ought to count as prior art, but the patent office are incapable of following their own rules.
07:33:03 <p_l> cads: Fortunately USA != World
07:33:11 <boegel> klibbigt: but one user ID will be in multiple UArrays
07:33:22 <cads> p_l: amen
07:33:31 <maltem> boegel: Ah, so you reversed the IntMap to get larger arrays. Ok that makes sense, good to hear that there was a simple solution. (You don't often hear of people doing large calculations in Haskell, so I get a little anxious about performance problems :)
07:33:38 <boegel> klibbigt: there's not much to gain there, replacing a uid with a pointer would also cost 4 bytes, at least
07:33:41 <klibbigt> cads: I suspect having the worls top ML researchers working for you for free for a couple of years then perhaps paying them 1 million dollars is probably cheap
07:33:52 <lilac> by curry-howard, proofs are patentable. this proof that proofs are patentable is patent-pending.
07:34:01 <boegel> maltem: I think that's the main reason for the drop in memory usage, yes
07:34:36 <boegel> maltem: both less overhead of the IntMap (because fewer keys), and less overhead for the UArrays, because there are fewer, and they are bigger
07:34:55 <boegel> maltem: I went from 480k keys and UArrays to just ~18k :)
07:35:01 <dmead> lilac, *facepalm*
07:35:06 <boegel> maltem: so that kills a lot of the overhead
07:35:24 <drdozer> @src accuml
07:35:24 <lambdabot> Source not found. :(
07:35:29 * p_l has simple answer to patent issues. "You can pay me now for harassment or I can test-drive my railgun"
07:35:31 <drdozer> @src accum
07:35:31 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:35:46 <paper_cc> @src mapAccumL
07:35:46 <lambdabot> mapAccumL _ s []        =  (s, [])
07:35:46 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
07:35:46 <lambdabot>    where (s', y ) = f s x
07:35:46 <lambdabot>          (s'',ys) = mapAccumL f s' xs
07:38:54 <cads> @type mapAccumL
07:38:55 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:41:02 <fasta> quicksilver: you cannot have copyright on an algorithm? Is an algorithm defined then to be something which could never ever work on a real computer?
07:41:20 <quicksilver> fasta: you can only copyright the expression of an algorithm - the precise source code.
07:41:43 <drdozer> fasta: depends where you live
07:41:44 <quicksilver> fasta: if someone else wrote the same algorithm using different source code - or they described it in plain english - that would not be a copyright violation.
07:41:53 <quicksilver> drdozer: I don't think it does.
07:42:02 <quicksilver> copyright protects the expression of an idea, not the idea itself.
07:42:15 <quicksilver> (patents protect ideas themselves, to the extent that they apply)
07:42:15 <fasta> quicksilver: but what if you read the description of the algorithm and follow the code very carefully and port it to another language?
07:43:00 <cads> in mapaccuml, f can be a function that simply maps x through a function and perturbs the accumulator somehow, where that's just like a fold and a map side by side... but if it's something that operates on x with the accumulator, what would we call that kind of function?
07:43:21 <fasta> quicksilver: well, I think those lawyer games don't work anyway, since a human can be considered to be a system in itself, so all it does is derived from the environment. So, it is impossible not to "break" copyright in this sense.
07:43:39 <p_l> patents in the beginning protected certain implementation at the price of being required to publish all the data necessary to replicate it. Copyright might cover the publication in which an algorithm is described, though
07:44:18 <quicksilver> fasta: reductionism like that does not apply to law.
07:44:37 <quicksilver> fasta: law is about 'principles' and 'reasonable judgment'
07:44:38 <drdozer> agreed, but how that is interpreted wrt sourcecode varies between the US and Europe e.g. how different something is and is still considered derivative
07:44:52 <fasta> quicksilver: I know, and they are bogus, imho.
07:45:03 <quicksilver> fasta: yes, you can quite reasonably say that law is entirely ridiculous.
07:45:04 <lilac> patent is a mutually-beneficial agreement between innovator and society to encourage publishing of ideas
07:45:07 <quicksilver> nonetheless it exists ;)
07:45:26 <p_l> as for patent law... I recall Polish Patent Office stating that they are completely opposed to any kind of patents on software, because math is not patentable
07:45:36 <paper_cc> lilac: ideally :(
07:45:36 <lilac> copyright is a gift from society to creator which exists basically to allow creators of original expression to profit from their expression
07:46:04 <p_l> lilac: A gift limited in time, too. At least in normal countries :)
07:46:07 <lilac> paper_cc: the law is an imperfect mapping from concepts to restrictions ;-)
07:46:21 <fasta> "Creativity" is something which was not known how to build until recently. So, in that sense the laws made sense. But technology just caught up with law.
07:46:44 <lilac> p_l: yep. sadly, some people seem to think that copyright is somehow inherent rather than a gift, and have forgotten why it exists (grr term extensions)
07:47:02 <fasta> It's not really a binary thing, but over time there won't be anything man-made which can be considered to be creative from the machine point of view at least.
07:47:35 <fasta> What we puny humans do will be considered trivial and a joke.
07:47:37 <klibbigt> how do you build creativity?
07:47:57 <p_l> fasta: As someone who struggles with writing, I can tell you that chances for something to be truly new are _very_ small
07:48:37 <lilac> klibbigt: i think the height of creative machines at the moment is imitating and generalizing creativity observed from humans
07:48:45 <skorpan> > getDirectoryContents
07:48:46 <lambdabot>   Not in scope: `getDirectoryContents'
07:48:49 <skorpan> :(
07:48:51 <cads> hehe, soon we will be traiding monetary units of of pure information theoretic novelty
07:48:54 <fasta> klibbigt: Search for godel machine and read all papers surrounding the subject.
07:49:07 <paper_cc> @ty getDirectoryContents
07:49:07 <lilac> > runST . unsafeIOToST $ getDirectoryContents
07:49:08 <lambdabot> Not in scope: `getDirectoryContents'
07:49:08 <lambdabot>   Not in scope: `unsafeIOToST'Not in scope: `getDirectoryContents'
07:49:10 <fasta> cads: right, that would be a sane economy.
07:49:17 <p_l> cads: I think we will be trading energy :)
07:49:24 <klibbigt> fasta: what the hell are you talking about? AI is still a joke, the successfukl part is machien elarning which ahs nothign to do with creativity. just linear algebra and statistics
07:49:32 <lilac> cads: we'd need to specify which novelty we're paying for
07:49:33 <fasta> Too bad computers are still way too slow to do these things.
07:49:42 <lilac> cads: i don't want to pay for arbitrary background images in TV shows
07:49:56 <cads> fasta: except you and I will be worth very little there, unless we try very hard to become computer entities
07:50:08 <fasta> klibbigt: AI is not a joke anymore. We just learned that AI requires a lot of CPU power.
07:50:40 <cads> lilac: you pay for arbitrary units of currency representing random work, when you work for money
07:51:05 <p_l> Well, AI is available and widespread. AGI isn't
07:51:29 <cads> as long as it can get you the resource you need done when you spend it, currency is useful... I think that's called fungibility
07:51:59 <lilac> cads: i don't think trading on information has much of a future
07:52:14 <lilac> i think we're one clever innovation away from it being completely impossible to enforce
07:52:16 <fasta> p_l: yes, but I was saying that laws based on copyright are basically useless, since by the moment you consume the input, and make some later output, you are basically in breach of copyright.
07:52:40 <lilac> cads: unless we can apply a linear type system to the universe ;-)
07:52:47 <cads> har
07:52:49 <cads> ;)
07:52:51 <fasta> p_l: because you read some facts X, do thought process Y on it and publish it as Z.
07:53:36 <cads> fasta, unless we have a transcendant kernel to our being, which adds to genuine novelty to all that we do
07:53:44 <cads> ;D
07:53:55 <cads> you'd reduce us all to less than turing machines
07:54:12 <cads> eh, which is not so bad
07:54:20 <fasta> cads: the universe is probably finite, Turing machines are infinite, so we are even less.
07:54:33 <doserj> http://ansuz.sooke.bc.ca/lawpoli/colour/2004061001.php is a nice read related to this discussion
07:54:35 <p_l> cads: Nah, we are already a set of turing machines, quuite possibly even not universal...
07:54:50 * cads is waiting for a trick of physics that lets us design a oracle
07:54:57 <quicksilver> doserj: yes, that's a classic essay.
07:55:08 <quicksilver> doserj: should be required reader for all lawyers and all hackers.
07:55:16 <fasta> cads: yes, me too. There is a guy who wrote a paper on Instant Computing, which does that.
07:55:40 <fasta> cads: but he wrote it using MS Word, which implies the credibility factor goes down by 10.
07:55:58 <cads> :P
07:56:10 <senxhnsshp> fsta: just learned? no. but now we have computers that can compute as ast as our brains and still we are nowhere in that regard
07:56:38 <fasta> senxhnsshp: we don't have computers that compute as fast as our brains
07:57:01 <cads> fasta, have you read Stross' singularity scifi novel, Accelerando?
07:57:24 <p_l> fasta: Yes, we've got much faster computers
07:57:34 <cads> in a data/novelty economy humans become obsolete _quick_
07:57:36 <fasta> p_l: no, we don't.
07:57:45 <cads> humans just don't make all that much novelty
07:58:11 <p_l> fasta: Actually, we have. It's just that humanity has a lot of specialised circuits which computers have to emulate in software (and there's no JIT for those!)
07:58:27 <cads> we'd have humans preserved in little simulated pocket universe zoos just in the off chance that they do come up with something novel.. maybe that is where we already live
07:58:30 <fasta> p_l: there is also no FPGA of this size.
07:58:34 <senxhnsshp> fasta: what are ou a 15-year-old that read soem stuff from yudkowsky and became a fanboy?
07:58:50 <p_l> fasta: Even our fpgas are faster
07:59:02 <fasta> senxhnsshp: haha, no. I don't think  yudkowsky invented anything ever.
07:59:07 <p_l> the problem is the 'G' part in AGI
07:59:07 <fasta> senxhnsshp: what did he invent?
07:59:44 <p_l> Yudkowsky works on Friendly AI theory, afaik. Which is a very good thing to work on. I don't want an unFriendly AI
07:59:52 <fasta> senxhnsshp: yudkowsky just does "research" while not ever producing anything.
08:00:03 <cads> he produces papers :P
08:00:10 <fasta> cads: he does?
08:00:21 <fasta> Did anyone have the crazyness to publish one?
08:00:30 <fasta> Oh, wait, I know someone who was that crazy.
08:00:44 <fasta> I skipped that part of the book.
08:00:49 <p_l> fasta: "If we knew what we are doing it wouldn't be called research"
08:01:07 <boegel> p_l: heh, nice one
08:01:15 <p_l> Seen during AI exam
08:01:16 <fasta> I have never ever read anything interesting written by Yudkowsky.
08:01:26 <cads> eeh, I think i might have been thinking of a different crazy ai researcher
08:01:47 <cads> gotta go
08:01:58 <p_l> cads: When you combine nanotech and AI, there's no way to avoid craziness
08:02:05 * cads uploads himself into a sentient cluster of seagulls
08:03:03 <skorpan> is it possible to install package X of an older version in cabal?
08:03:15 <skorpan> specifically data-accessor 0.1.4
08:03:31 <dolio> You can try cabal install data-accessor-0.1.4.
08:03:34 <dolio> If that's what you mean.
08:03:39 <skorpan> oh
08:03:41 <skorpan> that sounds easy :P
08:03:52 <dolio> I think you can specify version number with it.
08:04:06 <fasta> p_l: our FPGAS are faster, but don't have the same size obviously.
08:04:42 <wli> Try Fibonacci n-step numbers.
08:05:29 <p_l> fasta: Not for long. By current research, we should be able to pack the brain into few cm^3
08:05:48 <skorpan> thanks dolio
08:05:55 <fasta> p_l: I would be very interested in seeing that kind of hardware.
08:06:01 <idnar> p_l: it wouldn't be as robust, though
08:06:13 <fasta> p_l: and I suspect just about everyone else.
08:06:51 <p_l> idnar: Well, it would have to be cooled well (mechanical nanocomputers have problems with temperatures)
08:07:34 <p_l> But brain has similar problem. Also, ever since I had to learn exactly how neurons transmit signals, I was appaled by how bad it was
08:07:47 <BMeph>  quicksilver: Have you checked out spj's paper on a different record system?
08:07:56 <BMeph> wli: Was that for me? :
08:10:46 <quicksilver> BMeph: yes, I have.
08:13:08 <skorpan> i just found happiness in haskell:
08:13:09 <skorpan> otherwise = (f (tokenToStroke t) :)
08:13:46 <p_l> ...
08:14:34 <cads> fasta, p_l, imo if ai gets to reviewing the sum of human knowledge and catches an interest in our more lofty and transcendental writings and manages to investigate and find some truth about understanding an awareness, and turning off the ego... then we'll do just fine
08:15:15 <p_l> cads: If we manage to get the goal system right. Which is not easy
08:15:32 <cads> yeah
08:15:33 <wli> > let fibnsteps n = let xs = take n (let is = [0,1,1] in is ++ unfoldr (\js -> Just (sum js, js ++ [sum js])) is) ++  map sum (transpose . take n $ tails xs) in xs in [take 10 $ fibnsteps n :: [Integer] | n <- [2 .. 10]]
08:15:35 <lambdabot>   [[0,1,1,2,3,5,8,13,21,34],[0,1,1,2,4,7,13,24,44,81],[0,1,1,2,4,8,15,29,56,1...
08:15:36 <fasta> cads: turning of the ego? Do you want to turn into a Borg? ;)
08:15:59 <cads> fasta, borgs still have very powerful collective ego...
08:16:05 <wli> compare to the fibonacci n-step number page on wolfram.com at http://mathworld.wolfram.com/Fibonaccin-StepNumber.html
08:16:14 <mm_freak_> how can i create a haskellwiki account?
08:16:29 <p_l> fasta: actually it won't be like our ego anymore... that's part of the problem
08:16:37 <p_l> We do not "turn off the ego".
08:17:41 <cads> It's something entirely new then.. but if it's deriving from our desire to reduce everything to value judgements and symbols, I don't think it'll be pretty
08:17:58 <cads> hehe, and that's kind of the idea of a goal system
08:18:24 <p_l> cads: Basically one of the biggest fallacies people have towards AI is that they think it would be similar to human intelligence...
08:18:55 <Cheshire> p_l, but you somehow know this is a fallacy?
08:19:39 <cads> I think in a happy scenario is that something would be created that definitely needs it own space, but is present enough not destroy us to get it.. it'd just go off an leave us alone
08:20:03 <p_l> Cheshire: The first paper that we discussed in our AI class was about AI already being there :)
08:20:22 <fasta> p_l: which one was that?
08:21:14 <cads> if seed ai comes out of some mindless system designed say for controlling warfare, who knows what kind of skewed identifications it would have about the world
08:21:17 <p_l> fasta: I don't have it with me at the moment, but it basically was about the fact that "weak" AI is there already and everywhere
08:21:49 <raxas> the key power of intellect is intention, not valuation nor judgment
08:22:08 <p_l> cads: The thing is, AGI + nanofactories = Deus Ex Machina :)
08:22:25 <cads> AGI?
08:23:12 <BMeph> quicksilver: Does it have anything helpful to add to your lens-using module (if you ever did finish it anyway...)?
08:23:38 <p_l> cads: Artificial General Intelligence. Aka "Strong" AI
08:23:56 <cads> hehe, ai able to create new physics?
08:24:13 <p_l> cads: If it finds reflection api to universe, yes :P
08:24:21 <quicksilver> BMeph: I don't find them strongly comparable.
08:24:35 <cads> well how strong does it have to be to be considered "strong" ai?
08:24:40 <p_l> (unless you meant research and find new laws - that of course it could)
08:24:46 <fasta> cads: stronger than yourself :)
08:24:55 <cads> p_l, that's what I meant
08:25:07 <p_l> cads: Self improvement, ability to take on concepts it was not designed to handle etc
08:25:17 <cads> but how far can it take it?
08:25:20 <p_l> cads: Even with todays hw it would be much, much better than humans
08:25:42 <fasta> cads: it will grow with the speed of light in a warp-bubble absorbing anything in its way ;)
08:26:02 <fasta> cads: and then somewhat faster, probably
08:26:07 <p_l> afk - battery running out
08:26:44 <fasta> cads: a more likely scenario is that we have WW3 before that and we all die :)
08:28:53 <cads> there's the concept of an AI which once started will deduce all possible knowledge after a certain time..
08:28:53 * cads thinks that a universal tendency towards such a system can be found as a law of the universe
08:28:54 <cads> is why we're here
08:29:00 <BMeph> quicksilver: As in they solve different problems, or they just work in different parts of the "problem space", so to speak?
08:29:41 <senxhnsshp> yeah but what kind of research does he actually do?
08:29:41 <fasta> cads: read about the speed prior, you will probably find it interesting.
08:29:49 <senxhnsshp> they seem more like self-appointed experts to me
08:30:42 <cads> fasta, what about doing speed?
08:31:01 <cads> is that a book title?
08:31:11 <fasta> cads: google "speed prior"
08:31:24 <wli> Cleaner is fibnsteps n = let xs = take n (if n <= 3 then [0,1,1] else fibnsteps $ n - 1) ++  map sum (transpose . take n $ tails xs) in xs
08:31:30 <quicksilver> BMeph: different problems.
08:32:05 <quicksilver> BMeph: first class modules are probably not things you modify
08:32:05 <cads> oh god it's similar to Kolmogorov Complexity
08:32:20 <quicksilver> (even in the immutable sense of 'modify')
08:32:24 * cads runs out of the room in a panic .... to go get some breakfast
08:32:40 <cads> later
08:32:57 <quicksilver> BMeph: whereas lenses are very much about that "modificaton"
08:34:44 <BMeph> quicksilver: Right. Looks like I'll need to sit down and reread^W finish that Boomerang paper.
08:35:26 <klibbigt> (!) :: Ord k => Map k a -> k -> a how do i use that?
08:35:36 <quicksilver> BMeph: I am curious to know why SPJ's record proposal never got implemented. He must have thought it was worth something when he wrote the paper.
08:35:41 <quicksilver> BMeph: but evidently he hasn't, since.
08:36:19 <idnar> cads: isn't that Laplace's Daemon? :P
08:37:06 <klibbigt> spj can defeat any crazy AI
08:37:52 <BMeph> klibbigt: The same way that you use (!!) with lists. :)
08:40:15 <wli> quicksiver: Which record proposal?
08:40:40 <klibbigt> how do I insert into a Map? like: assoc {1:2,3:4} 1 inc 1 which would mean insert into the hashmap 1:2,3:4 for the key 1 add 1 if it exists otherwise set it to 1
08:41:18 <quicksilver> :t Data.Map.insert
08:41:19 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
08:41:40 <wli> klibbigt: insert key value map and insertWith combine key value map
08:41:58 <quicksilver> wli: http://research.microsoft.com/en-us/um/people/simonpj/papers/records.htm
08:42:27 <klibbigt> yeah i get insert
08:42:28 <klibbigt> but not how to use insertWith
08:42:35 <quicksilver> for example insertWith (+)
08:42:40 <wli> klibbigt: Also unionWith combine map (fromListWith combine [(key1,val1),...,(keyN,valN)]
08:42:41 <quicksilver> would add the new value to the existing one
08:42:44 <quicksilver> (if there was an existing one)
08:43:15 <wli> klibbigt: Easy multisets are maps from elements to multiplicities.
08:43:46 <malcolmw> quicksilver: there were lots of competing proposals for improved record systems, but no clear principle to declare a winner amongst them
08:43:56 <wli> klibbigt: insertWith (+) element 1 does insertion, unionWith (+) does unions.
08:43:58 <klibbigt> Possible fix: add an instance declaration for (Num (M.Map t t1))
08:43:58 <klibbigt>     In the first argument of `M.insertWith', namely `(+)'
08:45:53 <wli> update (\multipicity -> if multipicity == 1 then Nothing else Just (multiplicity - 1)) does multiset deletion
08:45:54 <Cheshire> :t ?f \x -> x
08:45:55 <lambdabot> parse error on input `\'
08:45:59 <Cheshire> :t ?f (\x -> x)
08:46:00 <lambdabot> forall t t1. (?f::(t1 -> t1) -> t) => t
08:46:04 <Cheshire> why do you have to write these brackets?
08:46:44 <quicksilver> Cheshire: boring parser reasons
08:46:54 <quicksilver> Cheshire: that's just how they chose to write it.
08:47:11 <BMeph> malcolmw: Do they all need to modify the core or something? I.e., couldn't we make extentions for them all, and play around?
08:47:16 <quicksilver> there are quite a few places where parens could be unambiguously omitted but haskell requires them
08:47:29 <quicksilver> > negate if True then 1 else 2
08:47:30 <lambdabot>   <no location info>: parse error on input `if'
08:47:43 <quicksilver> ^^ that could be unambigously accepted
08:47:47 * quicksilver shrugs
08:48:34 <malcolmw> BMeph: the idea of having lots of incompatible syntaxes for different extensions is unappealing
08:48:51 <quicksilver> malcolmw: interesting.
08:49:10 <quicksilver> malcolmw: but still, some keen proponents of one of the systems could have simply done it.
08:49:19 <quicksilver> malcolmw: controversiality has never blocked GHC extensions
08:49:20 <wli> > negate $ if True then 1 else 2
08:49:21 <lambdabot>   -1
08:49:30 <quicksilver> just look at the funny SQL query extensions to list comps.
08:49:40 * malcolmw shudders
08:49:53 <wli> quicksilver: what???
08:49:54 <Saizan> i guess the SQL extensions are much easier to implement
08:50:05 <redditbot> Momentum builds as we approach Happstack 0.2
08:50:05 <redditbot> Vancouver Lisp Users Group meeting for March 2009 - Haskell for Lisp Programmers
08:50:05 <redditbot> GHC on SPARC: Bugfixes and pretty graphs
08:50:05 <redditbot> EDSL for Debugging in Haskell and Diffs
08:50:05 <redditbot> Literate solutions to Real World Haskell exercises
08:50:10 <quicksilver> that's certainly true, but it was only an example.
08:50:14 <BMeph> malcolmw: I think your idea of "unappealing" is subtily different from many others in the community. "Not that there's anything wrong with that..." ;)
08:50:37 <drdozer> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=1719#a1719
08:50:47 <drdozer> are the ghc profile outputs expected to be this variable?
08:51:37 <NameAlreadyInUse> why do i sometimes read that heap allocation is O(1) in a garbage collected memory model?
08:51:45 <NameAlreadyInUse> is it true? it sounds suspiciously like a free lunch
08:51:47 <malcolmw> BMeph: ultimately it comes down to whether someone implements it or not.  If you implemented a new record system extension in ghc, and published the patches, it might catch on by default
08:52:34 * wli has tried and failed to implement things in ghc.
08:53:58 <repnop> NameAlreadyInUse: if you do all the hard work during gc, allocation can be simple eh?
08:53:59 <wli> NameAlreadyInUse: Amortized O(1)?
08:54:11 <Saizan> NameAlreadyInUse: with a compacting collector you don't have to search for a suitable piece of memory, you just take the next
08:55:01 <wli> You could try a treadmill algorithm.
08:55:15 <klibbigt> so how do I do when ByteString and Prelude has a namespacecollision(and why the hello do they when it is imported with qualify)?
08:55:35 <nanothief> So its a free lunch, that you paid for before you got to the cafe?
08:56:25 <NameAlreadyInUse> so most of the work is done behind the scenes, and not at allocation?
08:57:02 <Saizan> klibbigt: you usually "import qualified Data.ByteString as B" and then use B.foo for every ByteString function
08:57:40 <klibbigt> yes
08:57:49 <klibbigt> andnow i get ambigous occurcne
08:57:54 <klibbigt> when suign preludes readFile
08:58:17 <Saizan> that means you've imported something else without the qualified attribute
08:58:23 <Saizan> that's clashing
08:58:44 <Saizan> NameAlreadyInUse: that's my limited understanding
08:59:57 <drdozer> my program is still running out of stack
09:00:06 <drdozer> I've been through and replaced everything that I can see with tail-recursive versions
09:00:32 <drdozer> I'm not findingthe .prof file very helpful in telling me where to look next
09:00:39 <drdozer> any hints?
09:00:47 <BMeph> drdozer: Mind if we pick over the victim? :)
09:01:13 <Saizan> drdozer: tail recursive versions with a strict accumulator?
09:01:28 <klibbigt> ouldn't match expected type `String'
09:01:28 <klibbigt>            against inferred type `IO String'
09:01:45 <klibbigt> bah so where do i do that? i thought i could use a pure function ina main = do-construct
09:01:47 <drdozer> Saizan: hum - possibly not - do I prefix the (x+1) with a bang or something?
09:01:54 <Cheshire> drdozer, rerwiting programs tail recursive doesn't help
09:02:06 <Cheshire> drdozer, well I guess you already found that out
09:02:08 <NameAlreadyInUse> Saizan: is there a reason it is specific garbage collection? couldn't the compaction also be handled on calls to free, for instance?
09:02:16 <BMeph> drdozer: Never mind, found your link in scroll-back.
09:02:42 <Saizan> drdozer: pattern matching like that is enough
09:03:01 <Saizan> drdozer: but with more complex datatype it might not
09:04:29 <Saizan> NameAlreadyInUse: you'd have to pay a most of the costs of garbage collection to perform that
09:05:10 <Saizan> since you at least have to update the pointers of the things you've moved
09:05:56 <NameAlreadyInUse> Saizan: ah, that is true
09:06:39 <drdozer> BMeph: you can find the code in svn here: http://metagenome.ncl.ac.uk/subversion/ondex/genprog  but you probably won't be able to build it
09:07:02 <drdozer> the main file is: CygraphNeighboursProb.hs
09:07:11 <Saizan> drdozer: it requires a login
09:07:33 <drdozer> damn - let me try to make it world-read/anonymous
09:09:59 --- mode: irc.freenode.net set +o ChanServ
09:12:39 <wli> klibbigt: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1578#a1578
09:17:00 <tromp_> > take 50 $ nubBy(\x y->y`mod`x==0)[2..]
09:17:01 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:17:37 <tromp_> > 58*60
09:17:38 <lambdabot>   3480
09:23:28 <drdozer> the repo should be readable now
09:24:17 <drdozer> amazing timing - I now have to run
09:34:35 <asgaroth> @pl \(a,b) (c,d) -> (c-a,d-b)
09:34:35 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. subtract) . flip . (((.) . (,)) .) . subtract)
09:35:49 <klibbigt> how do I sortBy the second item in a list of tuples?
09:36:02 <whpearson> Is flip (.)  and id another monoid on (->)?
09:36:07 <wli> sortBy (comparing snd)
09:36:26 <ddarius> whpearson: On a -> a, yes.
09:36:32 <wli> comparing is in Data.Ord
09:36:38 <ddarius> whpearson: It's Dual (Endo a)
09:37:06 <whpearson> ddarius: Ah, I forgot about Dual.
09:37:22 <whpearson> Thanks
09:52:07 <toliko_smoren> hey, im trying to use Gtk2Hs, and currently produce 2 layouts with some words, how do I make them not print over each other? Here is the paste http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1579#a1579 thanks
09:55:25 <klibbigt> is there some built in to count the nbr of occurances of x in xs?
09:55:46 <Cale> klibbigt: length . filter (== x)
09:55:47 <Deewiant> length (filter (== x) xs)
09:55:50 <maltem> toliko_smoren: you wouldn't use a drawing area
09:56:04 <toliko_smoren> hm no? pango demo used it
09:56:05 <maltem> toliko_smoren: but a different container, HBox, VBox or similar
09:56:22 <maltem> toliko_smoren: oh wait, it's pango
09:56:30 <maltem> toliko_smoren: I didn't look at it exactly :)
09:57:08 <dcoutts_> toliko_smoren: right, so you want to move on by the size of the laout
09:57:17 <toliko_smoren> yes
09:57:27 <toliko_smoren> how do i do that?
09:58:07 <lambdapants> hello.  I am trying to compile the latest ghc and I get this messag on make.
09:58:09 <lambdapants> cabal-bin: ghc-pkg dump failed
09:59:14 <lambdapants> however ghc-pkg dump works, well at least to my eye.
10:00:10 <toliko_smoren> how do i move on the layout print position?
10:02:00 <dcoutts_> toliko_smoren: I expect you need to use layoutGetExtents or layoutGetPixelExtents
10:02:06 <dcoutts_> toliko_smoren: and then use the cairo moveTo
10:02:39 <dcoutts_> probably layoutGetExtents because cairo does not work in pixel units
10:03:02 <toliko_smoren> thanks
10:03:23 <lilac> is there some Olegian trick to define all types to be instances of some typeclass, but with a special instance for some finite set?
10:03:38 <lilac> i know there's some way to do this if your special instance is for functions (but I don't recall how)
10:03:50 <dcoutts_> toliko_smoren: but you might like to check other pango tutorials to check if that's the right approach, the api will be more or less the same in Haskell as what you find in other turorials
10:03:57 <lilac> (this is, without using overlapping instances or similar)
10:04:05 <olsner> you might need IncomprehensibleInstances
10:04:52 <toliko_smoren> i am basically trying to write a simple html render engine, so i need to be able to position texts under different tags in different places and to style it differently so I thought this is the best approach
10:05:45 <dcoutts_> toliko_smoren: I expect you're right. You need to use pango layouts to work out the size of the text
10:06:10 <dcoutts_> toliko_smoren: you may find you need lower level access than a layout, because a layout is a whole paragraph
10:06:24 <dcoutts_> toliko_smoren: but pango gives you access to the lines and spans
10:06:26 <dcoutts_> erm runs
10:07:03 <toliko_smoren> well is there a difference if i use a layout to print lines or i use pango spans/lines to print lines?
10:07:38 <dcoutts_> toliko_smoren: you have more control in the latter case
10:08:04 <toliko_smoren> i will look into it
10:08:05 <toliko_smoren> thanks
10:08:06 <dcoutts_> toliko_smoren: if your area for paragraphs is always rectangular then a layout is probably ok
10:08:11 <toliko_smoren> however i tried
10:08:30 <toliko_smoren> Gtk.moveTo 122.2 122.2 and it said moveTo is not in scope
10:08:36 <dcoutts_> toliko_smoren: you should really read the pango documentation though, text layout is a slightly tricky business
10:09:01 <toliko_smoren> i am going through gtk2hs documention
10:09:07 <toliko_smoren> but they dont have too many examples
10:09:22 <dcoutts_> toliko_smoren: right, see the original docs for pango for the concepts
10:09:31 <toliko_smoren> ok
10:09:36 <toliko_smoren>  i will
10:09:37 <dcoutts_> oh and check your imports, and look at the gtk2hs/demo/pango/Layout.hs
10:09:46 <toliko_smoren> thanks
10:12:07 <lambdapants> I gather than when ghc is compiled it sees which packages you already have.  maybe if I can turn this facility off, it won't complain that it can't dump the packages.  Is that an idea, or should I file a bug?
10:14:28 <toliko_smoren> hm sorry to be bothering you but puting relMoveTo 20.0 5.0 into my code makes the app close as soon as it loads?
10:17:16 <rio> whats the straight way to apply a function n times? e.g: f.f.f.f.f.f
10:17:50 <rio> i could write my own operator to do this using iterate or fold and repeat, but maybe theres something existing
10:17:59 <Deewiant> (!! n) . iterate f
10:18:29 <Cheshire> rio, data N = O | S N ; foldN zero succ O = zero ; foldN zero succ (S n) = succ (foldN zero succ n) ; instance Num N where ... ; nTimes f = foldN id f
10:19:01 <Cheshire> rio, oops \x -> foldN x f
10:19:24 <rio> Cheshire: yes, thats really short and what i was asking for, an existing implementation
10:19:37 <Cheshire> rio, it's not short
10:20:06 <rio> and neither already existing
10:20:28 <rio> Deewiant: yeah, that was one of the variants i thought about
10:20:57 <Cheshire> rio, it does already exist
10:21:10 <lambdapants> random interesting tidbit: well if anyone else gets a "cabal-bin: ghc-pkg dump failed" on building ghc, just recompile cabal-bin in the libraries folder and it'll work a treat :)
10:21:22 <Deewiant> rio: I'd say mine is the most understandable alternative but of course I'm biased ;-)
10:22:08 <lambdapants> I forgot to make clean.  heh.  that'd be why...
10:25:21 <BMeph> I'd still make a "times n = foldr (.) id . replicate n", myself. :)
10:30:24 <Gracenotes_away> BMeph: disappointed one doesn't exist :/
10:30:39 <Gracenotes_away> away eh ;;
10:36:39 <lilac> Cheshire: bah. instance Num ((a -> a) -> (a -> a)) where ...
10:36:58 <Cheshire> clevel lilac
10:37:01 <Cheshire> clever*
10:37:03 <Cheshire> I like that
10:38:13 <lilac> you can't implement negate or (-), and the Show and Eq superclasses are problematic, but...
10:38:58 <lilac> it'd be nicer if you could say 'instance Num (forall a. (a -> a) -> (a -> a))'
10:41:55 <byorgey> lilac: you could do that if you wrapped it up in a data type.  But I guess that ends up missing the point.
10:42:39 <toliko_smoren> hey what is the correct way to pattern match this
10:42:40 <toliko_smoren> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1720#a1720
10:42:41 <toliko_smoren> ?
10:43:18 <glguy> Would one of the consequences of STM being an arrow (without ArrowApply) be that the atomic blocks could be more intelligently scheduled?
10:43:32 <Lenny222> i have a stupid Maybe question:
10:43:39 <glguy> that the atomic sections would be able to be inspected to see how they would interact without running htem
10:43:40 <Lenny222> given a functionaddPage :: Maybe PDFRect -> PDF (PDFReference PDFPage)
10:43:44 <Valodim> toliko_smoren: an IO type to a double..?
10:43:46 <Lenny222> addPage :: Maybe PDFRect -> PDF (PDFReference PDFPage)
10:44:14 <Lenny222> i try to call it this way:  addPage Just $ PDFRect 0 0 100 100
10:44:21 <Lenny222> but i get an error
10:44:22 <byorgey> toliko_smoren: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1720#a1721
10:44:51 <Lenny222>     Couldn't match expected type `Maybe PDFRect'
10:44:51 <Lenny222>            against inferred type `a -> Maybe a'
10:44:52 <mauke> Lenny222: insert '.' between 'addPage' and 'Just'
10:45:03 <toliko_smoren> byorgey:thanks
10:45:08 <byorgey> Lenny222: that's getting parsed as (addPage Just) (PDFRect 0 0 100 100)
10:46:02 <byorgey> Lenny222: remember that function application has higher precedence than anything else.
10:46:17 <lilac> glguy: no, i don't think so -- you'd have visibility into where the STM primitive arrows are used and how, but i think you still allow the code to dynamically choose which TVars it modifies
10:46:21 <Lenny222> wow, works. thanks mauke and byorgey
10:47:06 <glguy> lilac, well, you'd have to pick a static set of vars to modify (aka no storing vars in vars)
10:47:16 <glguy> but ArrowChoice would allow you to make some decisions about what you read
10:47:39 <lilac> glguy: yeah. you need to significantly revise how you represent TVars.
10:47:58 <kaol> > floor $ sqrt $ fromIntegral (-1)
10:47:59 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
10:48:06 <lilac> (i guess i mean, you can't just use the Kleisli arrow of the existing STM monad)
10:48:20 <kaol> > sqrt $ fromIntegral (-1)
10:48:21 <lambdabot>   NaN
10:48:25 <glguy> lilac, oh, certainly
10:49:20 <lilac> glguy: possibly if you represent your mutable values as some arbitrary point on a cycle created by an ArrowLoop instance
10:49:21 <kaol> someone filed a bug about floor's behaviour with NaN on the ghc package in Debian... I'm not quite sure what he expected.
10:49:22 <tromp_> :t sqrt
10:49:23 <lambdabot> forall a. (Floating a) => a -> a
10:49:32 <tromp_> :t floor
10:49:33 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
10:49:49 <mauke> kaol: error "Not a number"
10:50:09 <lilac> glguy: but i think being able to insert TVars into arbitrary data structures is quite important, and i'm not sure how you're going to model that
10:50:25 <lilac> > floor (0/0 :: Double)
10:50:26 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
10:51:07 <glguy> lilac, you could parametrize the atomic block from values outside the atomic block still
10:51:15 <lilac> kaol: i'd expect "f NaN == f" with f almost any primitive numeric operator.
10:51:18 <glguy> lilac, but recursively following tvars would be impaired
10:51:20 <tromp_> > length $ show $  floor (0/0 :: Double)
10:51:21 <lambdabot>   310
10:51:57 <lilac> glguy: good point. but that seems tantamount to deciding which TVars are modified by making an explicit list of them :)
10:52:16 <lilac> (or rather making the user of the STM arrow make an explicit list)
10:52:36 <glguy> well, automatically generating the list from the computation
10:52:43 <glguy> rather than asking for a separate specification
10:52:56 <lilac> glguy: this seems quite similar to alias analysis (which compilers for impure languages already do)
10:53:19 <glguy> lilac, I was thinking it might be closer to what rdbms can do with sql queries
10:54:39 <kaol> :t isNaN
10:54:40 <lambdabot> forall a. (RealFloat a) => a -> Bool
10:55:28 <mauke> isNaN = join (/=)
10:58:28 <ziman> > (join (/=) &&& id) (1/0)
10:58:30 <lambdabot>   (False,Infinity)
10:58:49 <jkff> Hi. I'm trying to create typeclasses for monad-mutable collections based on Edison, and I'm confronted with the question: should one provide also "semi-pure" analogues for mutators? Like, provide not only "retainD :: (a -> Bool) -> f a -> m ()" but also "filter :: (a -> Bool) -> f a -> m (f a)" which returns a completely independent datastructure? I'm mostly concerned with functions that are not mutators, like, various partitionings and views of maps:
10:58:49 <lambdabot> jkff: You have 1 new message. '/msg lambdabot @messages' to read it.
10:59:16 <ziman> > join (==) (1/0)
10:59:17 <lambdabot>   True
11:00:11 <kaol> looks like NaN silenty gets cast as a RealFrac before being passed to floor, and RealFrac doesn't have NaN, only RealFloat has. "class (RealFrac a, Floating a) => RealFloat a where ..."
11:00:44 <kaol> NaN gets mungled into something weird in the process
11:01:28 <jkff> On one hand, I wouldn't like to completely drop the partitionings and views from the mutable interface; on the other hand, they are pretty different. Probably I should start from the collection design principles that one has in impure languages, but in these one usually doesn't have these higher-order operations at all..
11:01:48 <centrinia> Is there an instance of RealFrac that is not an instance  of RealFloat?
11:02:01 <whpearson> @instances RealFrac
11:02:02 <lambdabot> Double, Float
11:02:06 <whpearson> @instances RealFloat
11:02:07 <lambdabot> Double, Float
11:02:12 <centrinia> Guess not. :p
11:02:31 <whpearson> Not in that lambdabot knows about anyway.
11:03:02 <dolio> @instances-importing Data.Ratio RealFrac
11:03:02 <lambdabot> Double, Float, Ratio a
11:04:05 <whpearson> @type 1/0
11:04:06 <lambdabot> forall t. (Fractional t) => t
11:05:27 <Apocalisp> Is there anything like a List that enforces uniqueness of elements?
11:05:34 <jkff> Apocalisp: Data.Set
11:05:46 <Apocalisp> Data.Set is not like a list
11:05:48 <Apocalisp> :)
11:05:57 <pumpkin> UniqList
11:06:00 <pumpkin> that you're about to write
11:06:03 <pumpkin> :P
11:06:05 <Apocalisp> hah
11:06:06 <jkff> Then make your requirements more precise :)
11:06:18 <centrinia> An ordered set?
11:06:32 <pumpkin> OMG it's centrinia
11:06:38 <pumpkin> I was just wondering yesterday where you'd disappeared to
11:06:41 <centrinia> Hi pumpkin.
11:06:50 <Apocalisp> A set that remembers insertion order.
11:06:52 <centrinia> That's why I'm back. :p
11:07:04 <pumpkin> really? :o
11:07:05 <whpearson> Apocalisp: Make it a instance of listlike! -> http://software.complete.org/software/projects/show/listlike
11:07:07 <jkff> Apocalisp: Just take an ordered set and impose an insertion ordering on it.
11:07:32 <mauke> List × Set
11:07:36 <Apocalisp> ListLike, me like!
11:07:57 <jkff> Apocalisp: Or make it an instance of Data.Edison.Seq! -> http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison-Seq.html
11:08:12 <centrinia> You might also get away with a (Map a Int) somehow.
11:09:04 <Apocalisp> A tree map that associates the map size with keys? That's an idea.
11:09:26 <jkff> data InsertionOrder a = a `InsertedAt` Int ; instance (Ord a) => Ord (InsertionOrder a) where .... ; and then use a Data.Map (InsertionOrder a) ().
11:10:01 <jkff> More precisely, a (Data.Map (InsertionOrder a) (), nextTimestamp :: Int)
11:10:16 <mauke> data T a = C [a] (Set a)
11:10:25 <mauke> empty = C [] S.empty
11:10:39 <pumpkin> centrinia: do you know someone else in here outside of IRC and they told you I was wondering where you went? :o
11:11:22 <mauke> insert x c@(C xs ss) = if S.member x ss then c else C (x : xs) (S.insert x ss)
11:11:55 <centrinia> pumpkin, no. I can read minds.
11:12:02 <pumpkin> ahh ok
11:15:59 <jkff> OK, another question. What's the hottest public darcs repository where I can have a comfortable place for my stuff?
11:16:19 <lilac> jkff: darxxx has some pretty hawt contents
11:16:51 <Saizan> jkff: patch-tag maybe? it's not so hot but it's promising
11:16:57 <jkff> Probably too hot to be related with Haskell?
11:17:07 <lilac> depends what turns you on i guess
11:17:19 <centrinia> afterdarcsex is even hawter. :O
11:17:20 <monochrom> hot is not comfortable
11:17:46 <lilac> monochrom: i would postulate that 'warm' is the greatest level of heat which is comfortable :)
11:17:47 <erikc> AFTERDARCSEX.COM is available!
11:17:53 <dolle> I'd like to understand more about writing monads and monad transformers. Does anyone know some good exercises to solve?
11:18:34 <lilac> dolle: hmm. you could try implementing some standard monad transformers for yourself
11:18:36 <jkff> Saizan: Having a look.
11:18:36 <Saizan> dolle: have you read "all about monads"?
11:19:39 <dolle> I have read the chapters about monads in Real World Haskell.
11:20:26 <jkff> Saizan: Have you read the stuff on http://spbhug.folding-maps.org/wiki/MonadsEn (which is down at the moment :) ) ? I can probably send it you by email if you like. That's my tutorial that in a sense concentrates on writing custom monads, like parsers and statistical distributions.
11:20:33 <jkff> Oops, not Saizan, but dolle
11:20:42 <lilac> dolle: what i find helpful when /implementing/ monad instances is "x >>= f = do v <- x; f v"; i often find it's easier to write what the latter should do
11:21:16 <dolle> jkff: thanks :) I'll look into it when it comes online again ;)
11:22:46 <dolle> lilac: Yeah, I'm also struggling a little bit with the notation now, but rewriting the expression sure helps understanding what's going on
11:23:14 <lilac> dolle: my take on burritos is here: http://metafoo.co.uk/practical-monads.txt
11:24:22 <Valodim> http://user.cs.tu-berlin.de/~magr/pub/Transformers.en.html
11:24:22 <Valodim> dolle: That's a pretty good introducion imo, helped me a lot :)
11:25:30 <dolle> thanks for the links everyone :)
11:28:25 <mdmkolbe> I just installed Yi with cabal as a user.  What does this error mean? "yi: Can't find package.conf as /usr/lib/ghc-6.6/driver/package.conf.inplace"
11:29:00 <dcoutts_> ghc-6.6?
11:29:07 <dcoutts_> that's a bit old
11:29:14 <dcoutts_> especially for yi
11:29:23 <mdmkolbe> dcoutts_: that is odd considering "ghc -V" shows 6.10
11:29:33 <dcoutts_> well quite :-)
11:29:34 <pumpkin> is there a way to search hackage by uploader/maintainer?
11:29:44 <dcoutts_> pumpkin: yes, if you write it! :-)
11:29:49 <dcoutts_> we're accepting patches :-)
11:30:02 <pumpkin> maybe I will!
11:30:28 <pumpkin> but I need to wash my hands after messing around with GHC's guts for so long
11:30:34 <dcoutts_> pumpkin: at least in cabal-install it's the general issue of searching by things other than name
11:30:51 <centrinia> pumpkin: You hacked GHC?
11:30:55 <pumpkin> would you want some sort of fulltext index? or just something naive
11:31:10 <pumpkin> centrinia: I wouldn't say that :P I broke 6.6 on my mac, for now :)
11:31:23 <centrinia> That's pretty old. :p
11:31:23 <dcoutts_> pumpkin: http://hackage.haskell.org/trac/hackage/ticket/457
11:31:57 <dcoutts_> pumpkin: the approach I was thinking of was after downloading the hackage list, to generate a local index file that can be searched more quickly
11:31:57 <pumpkin> centrinia: it's easier to build unsupported configurations on it though
11:32:34 <dcoutts_> pumpkin: reading the hackage index is very quick if you just need to lookup by name, but anything else requires parsing every .cabal file in the index, and that is slow because the .cabal file parser is slow.
11:32:39 <pumpkin> dcoutts_: definitely seems reasonable, I'll see if I can come up with something
11:32:58 <dcoutts_> pumpkin: so the idea would be do it once when we cabal update, then cache the info in a way that can be read back faster
11:33:35 <dcoutts_> pumpkin: or at least an auxiliary mapping of stuff -> package id, so we can end up only parsing the few files that we need to display.
11:33:41 <pumpkin> so some sort of disk-based inverted index
11:33:52 <pumpkin> without adding a dependency
11:33:55 <dcoutts_> pumpkin: right, beware of read/show and we cannot depend on binary either
11:34:07 <dcoutts_> pumpkin: we can only use bytestring, map etc
11:34:53 <dcoutts_> pumpkin: reading a lot of data isn't necessarily a problem, it's just parsing that's slow
11:34:54 <pumpkin> what's the issue with binary?
11:35:14 <dcoutts_> we cannot depend on it, because adding deps to cabal-install causes everyone pain
11:35:22 <pumpkin> ah okay, yeah
11:35:29 <dcoutts_> at least until bootstrapping is easier, via the platform installer
11:35:44 <dcoutts_> pumpkin: so the .tar file reading is really quick, that just uses bytestring
11:35:54 <pumpkin> yeah
11:35:58 <dcoutts_> even though the .tar file is several Mb
11:36:04 <pumpkin> well the most hackish thing I can think of
11:36:11 <pumpkin> is using a directory tree to represent a trie :P
11:36:15 <rio> how to divide to Ints truncating the decimals if any?
11:36:16 <dcoutts_> eew :-)
11:36:17 <pumpkin> but that may be too ugly :P
11:36:21 <dcoutts_> pumpkin: now that would be slow
11:36:33 <rio> lets say 20/3 = 6
11:36:42 <pumpkin> at least it's not linear in the number of packages :)
11:36:45 <dcoutts_> pumpkin: contiguous files are quick, seeks are not
11:36:51 <pumpkin> but yeah, I'll try to think of something nicer
11:37:32 <dcoutts_> pumpkin: even a linear scan would be quick, so long as the parsing is cheap
11:37:41 <pumpkin> yeah
11:37:52 <dcoutts_> eg length prefixed records
11:38:03 <dcoutts_> containing a sequence of length prefixed string values
11:38:22 <pumpkin> yeah
11:39:01 <pumpkin> alright, I'll give it a go :)
11:39:13 <pumpkin> maybe not until this weekend if I'm unlucky
11:39:22 <dcoutts_> whenever, there's no rush
11:39:34 <pumpkin> one more thing
11:39:43 <pumpkin> do we support internationalization in cabal?
11:39:43 <wli> > 20 `div` 3
11:39:44 <lambdabot>   6
11:39:55 <wli> rio: div
11:39:58 <dcoutts_> pumpkin: there's no need for the format to be portable or extensible since it's only used locally. So long as we can recognise when we cannot recognise it!
11:40:08 <dcoutts_> pumpkin: what kind of internationalization?
11:40:18 <pumpkin> dcoutts_: only reason I'm wondering is if I need to deal with utf8 issues in pacage descriptions, and the like
11:40:22 <pumpkin> package
11:40:25 <dcoutts_> pumpkin: we do yes
11:40:29 <pumpkin> okay
11:40:36 <dcoutts_> pumpkin: the .cabal file parser also decodes utf8
11:41:03 <pumpkin> I guess I'll just avoid making assumptions about the data going into it
11:41:15 <dcoutts_> pumpkin: so the Strings you get back in a PackageDescription are genuine Unicode Chars
11:41:25 <pumpkin> alright, so truncating = bad :)
11:41:42 <dcoutts_> yep, but you can just store them as Char, ie 32bit
11:42:08 <pumpkin> sounds good
11:42:15 <dcoutts_> no need for it to be compact so long as it is fast
11:42:28 <dcoutts_> though obviously more compact may be faster
11:42:32 <pumpkin> yeah
11:42:44 <dcoutts_> can always use gzip if we care
11:42:49 <dcoutts_> gzip -1
11:42:57 <chrisdone> is there a channel where I'll be able to ask about libpng?
11:43:13 <dcoutts_> chrisdone: the C lib or something related to Haskell?
11:43:18 <chrisdone> the c lib
11:43:31 <dcoutts_> oh, check the png home page, see if they have an irc chanel
11:44:08 <chrisdone> I'm accessing my webcam from Haskell using vgrabbj, but I need to hack vgrabbj to display some additional info. about the png output
11:47:45 <dcoutts_> pumpkin: may also be worth thinking about storing all the .cabal info in a parsed form in a local cache, not just an aux index
11:48:20 <dcoutts_> pumpkin: eg we have the problem that new .cabal files get uploaded to hackage that older cabal-install cannot read
11:48:57 <dcoutts_> pumpkin: if we read the hackage list when we downloaded it, we'd find which ones we cannot read and we'd just ignore them, not enter them into the local cache/index
11:49:20 <pumpkin> makes sense
11:49:53 <mdmkolbe> How do I uninstall a cabal installed package?
11:50:04 <dolio> rm
11:50:15 <dolio> And ghc-pkg unregister.
11:50:32 <dcoutts_> and if someone wants to work on that issue then that'd be great :-)
11:50:40 <MyCatVerbs> dolio: do you mean cabal rm foo, or /bin/rm foo?
11:50:53 <dolio>  /bin/rm
11:50:58 <dcoutts_> we all want cabal uninstall blah
11:50:59 <mdmkolbe> dolio: it was installed with "cabal install" so the parts are spread around a bit
11:51:57 <dcoutts_> if someone wants to work on it, it's probably not that tricky
11:52:18 <dcoutts_> we just need to run Setup copy --destdir=$tmp/whatever
11:52:25 <dcoutts_> and then generate a file list from that
11:52:48 <dcoutts_> actually install the files and keep the file list somewhere so we know what to uninstall later
11:54:42 <pumpkin> dcoutts_: can I rely on Arrow? I'm not sure when that went into the standard lib
11:55:10 <dolio> It's been around for quite some time.
11:55:14 <dcoutts_> pumpkin: lemme check, our baseline for cabal-install is ghc-6.6
11:56:06 <dcoutts_> pumpkin: it's there, however I think there have been some minor api changes so watch out
11:56:25 <pumpkin> alright, well I have a 6.6 instance lying around now so I can test :)
12:00:09 <skorpan> what the heck is this?
12:00:10 <skorpan> $(derive makeFoldable ''Tree)
12:00:16 <skorpan> TH?
12:00:20 <pumpkin> it's from Data.Derive
12:00:20 <pumpkin> yeah
12:00:42 <idnar> whee
12:00:44 <pumpkin> http://hackage.haskell.org/packages/archive/derive/0.1.1/doc/html/Data-DeriveTH.html
12:01:31 <skorpan> i'm getting weird deja vus now
12:03:05 <jganetsk>  let { x = NO_CCS :! [y z]; } in  ...
12:03:11 <jganetsk> i'm understanding that as list cons
12:03:31 <trofi> :t (:!)
12:03:32 <lambdabot> Not in scope: data constructor `:!'
12:03:41 <trofi> @hoogle (:!)
12:03:41 <lambdabot> Warning: Unknown type :!
12:03:41 <lambdabot> Prelude undefined :: a
12:03:41 <lambdabot> Data.Array.Base arrEleBottom :: a
12:03:51 <jganetsk> that's STG
12:03:53 <jganetsk> it's not haksell
12:04:09 <trofi> stg?
12:05:03 <monochrom> stg is one intermediate code during haskell compilation.
12:05:35 <monochrom> or lazy functional language compilation.
12:05:51 <trofi> ah
12:06:28 <jganetsk> sorry, i meant to preface that
12:07:23 <mm_freak_> how can i create a haskellwiki account?
12:08:10 <wli> I never did get the hang of how abstract machines come about from language semantics. Someone mentioned at one point there was actually some way to derive them from the language.
12:09:00 <rio> heh is just did Enum Eq Show Ord Num Peano numbers!
12:09:14 <monochrom> Graham Hutton does one such derivation. IIRC there is another.
12:09:24 <wli> The paper describing the method blew me away and I was going straight downhill from there.
12:09:38 <pejo> wli, look at Olivier Danvys lecture notes for AFP'08
12:09:57 <wli> The only thing I absorbed was that it had something to do with continuation-passing style.
12:10:13 <monochrom> First translate denotational semantics into recursive code in the dumbest way.
12:10:35 <monochrom> (denotations semantics is itself a bunch of recursive functions anyway.)
12:10:51 <monochrom> Then turn recursive code into CPS code.
12:11:05 <chessguy_> ok, #haskell, time to entertain me during this boring meeting
12:11:15 <beelsebob> monochrom: true, but occasionally it's written in a way that can't easily be transcribed
12:11:32 <beelsebob> I guess the best comparison I can make is context sensitive vs contxet free
12:11:43 <beelsebob> the denotational semantics often has part of the rule on the left hand side
12:11:56 <monochrom> Then you say "w00t, though I use continuations, in the actual code it is not used in full generality, there are only like 4 cases..."
12:12:30 <wli> Well, understanding that needs you to have some idea of how that ends up translating to machine instructions.
12:12:38 <monochrom> So you replace the actual continuations in the code by your own data structure to represenet those 4 cases.
12:12:40 <dolio> Man, this paper has all its question marks replaced with Γ.
12:13:58 <monochrom> Your data structure ends up being somewhat list-like. You say "hey I'll further replace it by a stack".
12:14:14 <monochrom> That is all.
12:14:40 <mauke> o rlyΓ
12:15:14 <dolio> yarlyΞ
12:15:30 <mauke> excellentΦ
12:15:52 <Nafai> dcoutts_: Got it working? :)
12:16:36 <Twey> lolzγ
12:16:36 <dcoutts_> Nafai: yes :-) http://darcs.haskell.org/buildbot/all/builders/sparky%20head
12:16:50 <wli> Sort of creating a function table for the continuations?
12:17:01 <Nafai> dcoutts_: Yay!
12:17:39 <monochrom> The data structure looks like cons-list or even stack because it came from the special continuations you have, and the special continuations came from using CPS to eliminate non-tail recursion, i.e., stack again.
12:17:56 <monochrom> Yes wli, a function table for the continuations, exactly that.
12:18:28 <wli> It's also because you're recursing down a tree via structural induction.
12:19:12 <monochrom> For the same reason the table is finite, i.e., there are only so many cases.
12:19:23 <wli> (If I understand properly the bit about denotational semantics.)
12:19:33 <monochrom> Yes.
12:20:05 <wli> That explanation actually made sense.
12:20:26 <wli> You could almost skip the CPS step when doing it by hand.
12:20:31 <monochrom> (If it didn't make sense I couldn't remember it. :) )
12:21:05 <wli> Well, it made sense to me, which is astounding given that I've turned into Forrest Gump over the past few years.
12:22:04 * wli is actually unsure that a spare degree of freedom is enough.
12:22:19 <wli> (That is, to ensure nonsingular denominators.)
12:22:38 <rio> any comments :)? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1722#a1722
12:22:47 <CTA> Hey guys
12:23:52 <wli> s/nonsingular/nonvanishing/
12:24:16 <CTA> I'm thinking about getting RWH soon
12:25:24 <chessguy_> cta: definitely worth your while
12:25:40 <CTA> tbh I find LYAH better, but I want a book
12:26:02 <CTA> I'm chuffed because I can do nooby things like doubleMe :: (Num a) => a -> a                 doubleMe x = x *2 =P
12:26:02 * wli suspects 2 may be required.
12:26:11 <chessguy_> RWH has much more depth
12:26:46 <CTA> at the night ive been reading/skimming through LYAH each night about like lists and stuff
12:27:41 <BONUS> i always recommend RWH to people after they're finished with LYAH
12:28:06 <CTA> so should I do that?
12:28:08 <BONUS> although LYAH is far from completed, but still, it focuses more on getting to grips with the language instead of doing a lot of real world stuff
12:28:23 <BONUS> RWH is awesome, i'd recommend it to anyone, yeah
12:28:28 <chessguy_> yeah, I think that was the intent for LYAH
12:29:03 <StoneToad> LYAH?
12:29:09 <CTA> learn you a haskell
12:29:11 <dolio> BONUS would, presumably, know.
12:29:16 <CTA> (for great good) .com
12:29:18 <BONUS> haha
12:29:26 <StoneToad> lol
12:29:28 <StoneToad> great name
12:30:08 <CTA> factorial == fac - tor - ial?
12:30:09 <chessguy_> oh. I always forget who wrote it
12:30:17 <CTA> factor - ial?
12:30:29 <CTA> fak - tor - ee - al?
12:30:30 <BONUS> also LYAH will be great if you speak chinese/czech/portugese because it's also being translated to those languages by some great guys :]
12:30:42 <BONUS> and here i am slacking off instead of writing more chapters haha
12:31:19 * wli wonders if he'll ever be able to implement division of algebraic numbers.
12:32:05 <CTA> When I go to college I'll want to learn Haskell as in course but I probs won't be able to find one/get into that college
12:32:07 <FunctorSalad> how do you represent them wli?
12:32:42 <dolio> Why would you want to take a course on learning it if you already know it?
12:32:53 <BONUS> for free points i guess haha
12:32:59 <dolio> Heh.
12:33:10 <BONUS> but yeah there's so many resources on haskell that you don't need uni to learn it
12:33:13 <dolio> Better to test out of the course (if possible).
12:33:32 <wli> FunctorSalad: Lists of powers of a root of a polynomial of arbitrary length, reduced in length using the minimal polynomial floating around in a Reader monad.
12:33:34 <BONUS> although i'd like to visit a uni that has a good functional programming department or whatever
12:33:45 <CTA> wouldn't you need some qualifications in Haskell programming to get a career using it though?
12:33:49 <rio> wli: im going to do that, implementing peano numbers
12:33:49 <skorpan> CTA: come read computer engineering at chalmers, our first course was in haskell
12:33:52 <mopped> i think chalmers in sweden is ok BONUS?
12:34:03 <skorpan> yes, chalmers is awesome :)
12:34:22 <BONUS> really? i'll look into czeching it out. can you go there if you don't speak swedish though?
12:34:27 <mopped> I know my university only offers two FP courses, sucks!
12:34:31 <mopped> no idea bonus
12:34:36 <wli> FunctorSalad: Mostly I've lost too many brain cells to implement Gaussian elimination.
12:34:36 <skorpan> mopped: so does chalmers :P
12:34:43 <mopped> hm
12:34:46 <skorpan> but i've used haskell in probably five or six courses
12:34:52 <BONUS> CTA: nah, not really
12:34:56 <mopped> My university teaches ML instead of haskell ;(
12:35:10 <skorpan> intro-fp, advanced fp, programming languages, compiler construction, programming paradigms, cryptography... those are the ones i come to think of right now.
12:35:14 <wli> mopped: CMU?
12:35:20 <rio> wli: do you need gaussian elim to implement div?
12:35:33 <wli> rio: For algebraic numbers, yes.
12:35:40 <mopped> nope (I'm not sure what CMU is!)
12:35:51 <wli> Carnegie-Mellon University
12:35:57 * sw17ch wants to go to CMU :(
12:36:04 <Zao> One of those silly ivy unis.
12:36:08 <mopped> nah, I'm british!
12:36:08 <BONUS> i don't think there are any haskell certificates or such and i dont think there should be
12:36:11 <BONUS> hehe
12:36:20 <Stinger> MSCH
12:36:47 <wli> FunctorSalad: I'm not sure if there's a better way to implement it all.
12:37:24 <wli> e.g. using the various conjugates as a basis leaves me clueless as to how to carry out reductions at all.
12:37:44 <mopped> How can you guage the strength of a compsci degree at a certain university? I'm not completely sure between which of two I'd like to attend, apart from one is more theory based than the other
12:38:10 <FunctorSalad> wli: I don't know a better way, I was just curious :) though I don't the list thing, I would have expected you just save a polynomial of which the number is a root, and somehow specify which root it is
12:38:11 <Eridius> screw the degree, go to the place you think you'll learn more at
12:38:12 <Eridius> or be happier at
12:38:40 <Eridius> hell, I went to my school for 3.5 years (off and on) and then dropped out without a degree, because I learned all I could there
12:38:43 <BMeph> Yeah, listen to dolio: Whenever possible, test out of classes. It's easier on your wallet, especially that invisible wallet where all your time sits. :)
12:38:46 <FunctorSalad> *I don't _understand_ (missing word)
12:39:03 <BONUS> a degree is just a piece of paper yeah, learning is more important :]
12:39:16 <wli> FunctorSalad: I do that without ever bothering to specify which root it is.
12:39:18 <mopped> sorry, by strength of degree = strength of teaching
12:39:19 <CTA> whats a enum again? i think i can remember in c++ (maybe..) that like enum a { a = 1, b} meaning b = 2?
12:39:22 <chrisdone> hmm
12:40:06 <Zao> CTA: Enumerants in C++ are increasing by one unless explicitly assigned something else.
12:40:17 <Zao> And start from 0 unless indicated otherwise.
12:40:34 <whpearson> Is there anyway to tie the kinds of two things together in an instance. E.g. You want to instance a monad or something else with kind * -> * , and you want to do it with a combination of things of kind *->*, say a tuple.
12:41:02 <CTA> And they are what in Haskell?
12:41:50 <Cale> CTA: Types in the Enum class are roughly those types which the list enumeration syntax will work for
12:41:51 <chrisdone> I have a polymorphic function which is in a let expression. when I write it as "foo = x :: Read a => Foo -> a" it gives my type errors elsewhere because a type has been inferred for the read instance and conflicts with another use of it (Int and Int64). but when I write it "foo :: Read a -> Foo -> a; foo = x" it is properly polymorphic. what's all that about?
12:41:52 <rio> haskell has no "enum" and doesnt need it, since you can just use parameterless constructors
12:41:54 <BONUS> CTA: data Day = Monday | Tuesday | .. | Saturday | Sunday deriving (Enum)
12:41:54 <Cale> :t enumFromThenTo
12:41:55 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
12:42:02 <BONUS> and then you can do [Tuesday..Friday]
12:42:05 <BONUS> and stuff like that
12:42:07 <Cale> enumFromThenTo 'a' 'c' 'z'
12:42:09 <Cale> > enumFromThenTo 'a' 'c' 'z'
12:42:10 <lambdabot>   "acegikmoqsuwy"
12:42:13 <BONUS> basically a thing that has a successor and a predecessor
12:42:29 <Cale> > ['a','c'..'z']
12:42:30 <lambdabot>   "acegikmoqsuwy"
12:42:49 <wli> I don't know what the reduction rule is when using the conjugates. It must be more complex because, for instance, x^2-2 is Galois over Q but the conjugates aren't linearly independent.
12:42:52 <Cale> Enum is a class in the prelude, you can look it up to see what its methods are.
12:43:07 <chrisdone> Cale: ['a','c'..'z'] works but ['c'..'z','a'] does not work. why?
12:43:14 <hackage> Uploaded to hackage: Hieroglyph 1.2
12:43:14 <hackage> Uploaded to hackage: Hieroglyph 1.1
12:43:25 <rio> chrisdone: because the syntax is [a,b..c]
12:43:32 <chrisdone> rio: why?
12:43:49 <rio> chrisdone: a,b define how the list starts, c defines the end
12:43:49 <kryptiskt_> mopped: filter (\x->(languageAt x)/=Java) schools
12:43:58 <Cale> chrisdone: You specify the first and second element which defines a step size, and then the last element to define an upper bound.
12:44:10 <Cale> > [1,3..20]
12:44:11 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
12:44:25 <wli> In like fashion whenever a pair of conjugates are rational mutiples of each other.
12:44:26 <Cale> (note that 20 is not actually an element of that list)
12:44:52 <chrisdone> oh
12:45:12 <FunctorSalad> > [1,1.1 .. 2] -- feeling lucky it rounds correctly :)
12:45:13 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
12:45:17 <chrisdone> anyone know why my polymorphic function is only polymorphic when I declare a type annotation and not when I annotate the function code?
12:45:17 <wli> (in particular negatives of each other)
12:45:23 <FunctorSalad> > last [1,1.1 .. 2]
12:45:24 <lambdabot>   2.000000000000001
12:45:37 <wli> chrisdone: The Dreaded Monomorphism Restriction (DMR).
12:45:41 <chrisdone> --      readPacked :: (Read a) => ByteString -> a
12:45:41 <chrisdone>       readPacked = read . Char8.unpack -- :: (Read a) => ByteString -> a
12:45:41 <chrisdone>  
12:45:57 <CTA> enums very useful?
12:46:19 <chrisdone> why does the first annotation make readPacked polymorphic, whereas the second doesn't?
12:46:21 <Zao> They're useful for the sorts of things you tend to use Enum in.
12:46:27 <mauke>  <wli> chrisdone: The Dreaded Monomorphism Restriction (DMR).
12:46:31 <chrisdone> why?
12:46:37 <CTA> ...
12:47:02 <CTA> lol
12:47:06 <p_l> I wonder what Ritchie would say about this... :P
12:47:18 <FunctorSalad> apparently it kicks in when the LHS is just a variable, even if you make it polymorphic on the RHS
12:47:25 <FunctorSalad> ?
12:48:11 <centrinia> Does it make sense to talk about radii in ultrametric spaces (where every triangle is isosceles)?
12:48:48 <FunctorSalad> you can make a ball of radius r, sure
12:48:55 <chrisdone> well, whatever. it's a pain in the arse but it probably has a good reason I won't understand so w/e
12:49:18 <centrinia> Uh, I meant circumference. :">
12:49:25 <FunctorSalad> chrisdone: -XNoMonomorphismRestriction :D
12:49:40 <CTA> im swapping my old xp laptop for my dads new vista one (: so ill use the vista one just for coding mwha
12:49:48 <BMeph> p_l: Dennis Ritchie? Or Nicole Ritchie? ;p
12:50:09 <redditbot> New version of Hieroglyph released.
12:50:15 <mauke> Dreaded M. Ritchie
12:51:38 * BMeph now has a disturbing image of Dennis Ritchie in dredlocks...
12:51:57 <p_l> Well, I recognize dmr login name as Dennis M. Ritchie :P
12:52:28 <gnuvince> dredlocks or deadlocks?
12:52:48 <FunctorSalad> http://www.acronymfinder.com/DMR.html
12:53:02 <chrisdone> I read it as deadlocks and didn't think twice about it :\
12:53:26 <FunctorSalad> I tried to make some joke out of it but couldn't find any
12:54:40 <centrinia> Dextromethricin
12:55:02 <BMeph> gnuvince, chrisdone: I don't see how picturing "dmr" with _deadlocks_ in his hair would be disturbing. Poetic justice, maybe... ;p
12:55:21 <FunctorSalad> hmm... acronymfinder warns me that "NOTE: We don't accept made-up definitions."
12:55:33 <Olathe> Oh dear.
12:55:59 <FunctorSalad> (as if there was any other kind? :))
12:56:16 <rio> FunctorSalad: deducted definitions of course
12:56:37 <Badger> NOTE: We don't accept MUDs.
12:56:37 <rio> -t
12:56:41 <centrinia> What if it is deduced from something that is made up?
12:56:52 <FunctorSalad> centrinia was quicker
12:57:30 <mauke> NYJMUA
12:57:38 <rio> centrinia: than it will be accepted
12:57:42 <Badger> WAYTA
12:58:09 <rio> but there will be a need for a definition of the thing we are deducing from, and that will not be accepted :(
12:58:13 * centrinia makes up a Dreaded M. Ritchie and submits it to acronymfinder.com :)
12:58:51 * centrinia submits the acronym even. :p
13:10:26 <centrinia> Is a real function computer more powerful than a real computer?
13:10:59 <joga> huh?
13:12:25 <centrinia> A real function computer has words that can take on the value of any arbitrary function from the reals to the reals.
13:12:40 <FunctorSalad> long set is LONG
13:13:02 <augustss> centrinia: it's more powerful, because it seems to have infinite storage
13:13:30 <centrinia> A real computer also has infinite storage.
13:13:32 <toliko_smoren> hey, why does this
13:13:32 <toliko_smoren> getX :: IO (Gtk.Rectangle,Gtk.Rectangle) -> Double
13:13:32 <toliko_smoren> getX m = do
13:13:32 <toliko_smoren>     return 2.0 return a type error saying i am inferring it something of type a b?
13:13:46 <BMeph> centrinia: If it wouldn't be misunderstood, I'd say that that computer sounds...Complex. <ducks>
13:13:49 <FunctorSalad> centrinia: R^R has still larger cardinality than R though
13:13:50 <augustss> centrinia: your definition of real computer is different from mine. ;)
13:14:53 <centrinia> A real computer has words that can take on any arbitrary real value.
13:15:01 <augustss> i'm typing this on a real computer, you seem to have a dream computer in mind :)
13:15:54 <toliko_smoren> thanks guys, i solved after 3 hours, i was sending it a double instead of IO (Double)
13:16:29 <augustss> centrinia: does the real function computer come with some handy prestored values?  like the function that solves the halting problem.
13:16:32 <FunctorSalad> centrinia: what is the input/output type of such a computer?
13:16:50 <centrinia> Real numbers?
13:17:11 <centrinia> augustss: I hope so. :)
13:17:27 <augustss> centrinia: and what instructions does it have?
13:18:18 <centrinia> A set of functions from the reals to the reals cross product the state set perhaps?
13:18:44 <centrinia> Cartesian product even.
13:20:06 <FunctorSalad> if you have one instruction for *every* function from R to R then every program will be equivalent to a program with a single instruciton
13:20:20 <augustss> unless it has some non-computable functions as instructions i'm not sure it's more powerful than an ordinary computer
13:21:12 <augustss> FunctorSalad: the ultimate VLIW
13:21:22 <p_l> augustss: Well, it could have all operations executed in single cycle ;-)
13:21:36 <p_l> i.e. RSA's doom
13:21:38 <dolio> One might expect it to at least decide ordering of real numbers.
13:21:40 <centrinia> Yeah, all operations.
13:22:19 <augustss> p_i: but what about my Turing machine that executes every instruction in half the time of the previous one?
13:23:04 <tromp_> http://econpapers.repec.org/paper/wopsafiwp/93-04-018.htm
13:23:08 <p_l> augustss: What if you hit time quantum?
13:23:33 <augustss> p_i: we are obviously not concerned about physics here
13:23:36 <centrinia> Is there such a thing as a time quantum?
13:23:40 <FunctorSalad> you whack it with the unsafe quantum splitting hammer
13:23:43 <centrinia> augustss is right.
13:24:00 <Olathe> FunctorSalad: That's not safe.
13:24:24 <augustss> unsafeQuantumSplittingHammer
13:24:41 <sw17ch> :t Rational
13:24:42 <p_l> centrinia: there's one, it seems. as well as minimal distance quantum. And everything is moot cause we might be a holographic projection of a 2D plane
13:24:42 <lambdabot> Not in scope: data constructor `Rational'
13:25:06 <Olathe> :t 3 % 4
13:25:07 <lambdabot> forall t. (Integral t) => Ratio t
13:25:19 <augustss> that real computer will be a bitch to write assembly code for.  how do you spell out the instructions?
13:25:28 <centrinia> @let unsafeQuantumSplittingHammer :: QSH a -> a
13:25:29 <lambdabot>  <local>:5:0: Not in scope: `unsafeQuantumSplittingHammer'
13:25:29 <lambdabot>  
13:25:29 <lambdabot>  <local>:5:32: N...
13:25:37 <centrinia> Sorry.
13:25:42 <p_l> augustss: somehow along the lines of "ftaghn"
13:25:59 <centrinia> augustss: You need a real editor for that.
13:26:05 <augustss> but you can only get access to a countable number of instructions
13:26:17 <Olathe> Yeah, real men use real editors.
13:26:21 <augustss> ah, the real editor
13:26:23 <centrinia> Why limit yourself to a countable set of instructions?
13:26:26 <augustss> like emacs
13:26:47 <mdmkolbe> centrinia: because if the input is text then the input is countable
13:26:50 <augustss> centrinia: i didn't realize the system came with a real editor
13:26:53 <beelsebob> has anyone tried Objective-C binding any time recently?
13:26:54 <rio> augustss: no, a _real_ editor, like vim
13:27:17 <p_l> a real editor, like MIT TECO
13:27:27 <augustss> ed is the editor
13:27:29 <Olathe> A real editor, like edit.com.
13:27:40 <rio> are those real real editors?
13:27:41 <FunctorSalad> cat is fine too
13:27:51 <augustss> FunctorSalad: real cat
13:27:53 <p_l> FunctorSalad: nya
13:27:56 <Olathe> Cats are too finicky.
13:27:57 <sw17ch> FunctorSalad: woo
13:28:00 <sw17ch> cat > myfile
13:28:02 <idnar> dd
13:28:05 <sw17ch> don't make mistakes :)
13:28:06 <Adamant> lies! inode editing with butterflies is the one true way!
13:28:10 <mdmkolbe> augustss: http://xkcd.com/378/
13:28:13 <rio> dont start bothering real cats now
13:28:15 <p_l> M-x butterflies?
13:28:18 <idnar> M-x butter... heh
13:28:37 <Olathe> Writing an editor in MIPS machine code by hand and using that.
13:28:42 <Olathe> That's a real editor.
13:29:04 <rio> Olathe: what editor to use for the machine code?
13:29:12 <pumpkin> a magnetized needle?
13:29:14 <Olathe> The switches on the front of your machine.
13:29:21 <p_l> Olathe: No, that would be using switches on console to write your code into memory. already compiled, of course
13:29:24 <Adamant> MIPS is not a real machine though
13:29:46 <Adamant> it's for students and second-rate embedded hardware manufacturers
13:29:54 <Olathe> You use your brain as an editor and put the machine code out to your program by using the patch cables.
13:29:59 <rio> Olathe: oh i really wrote some programs using switches in school, unique feeling :D
13:30:04 <Olathe> Heheh
13:30:05 <augustss> Olathe: I wrote one in TMS9900 machine code
13:30:11 <Olathe> Eww
13:30:21 <rio> for the good old intel 8085
13:30:22 <augustss> Olathe: and the assembler
13:30:28 <sw17ch> my first program was in PHP :(
13:30:41 <augustss> Olathe: then I could write the C compiler in assembly code :)
13:30:45 <p_l> Adamant: MIPS64 is also when you want tons of computing power and little energy usage :)
13:30:45 <Olathe> Heheh
13:30:54 <augustss> Umm, I wrote the OS before that.
13:31:02 <Olathe> And then you wrote the Haskell compiler on top of that ?
13:31:08 <rio> sw17ch: now thats not a program
13:31:18 <sw17ch> rio: i know... :(
13:31:26 <Adamant> p_l: thought that was ARM :p
13:31:33 <Adamant> MIPS is alright
13:31:45 <rio> you write the haskell compiler in haskell and act as a haskell interpreter to compile the compiler source using itself as interpreter input
13:31:49 <augustss> Olathe: I actually wrote most of the functional language stuff on a VAX, so it had those tools already
13:31:50 <p_l> Adamant: Have you seen SiCortex machines?
13:32:06 <Heffalump> byorgey: ping?
13:32:08 <rio> if you get that done, we will talk
13:32:08 <p_l> Adamant: 72 cores, 48 (or 96) GiB or RAM, 300W PSU :D
13:32:23 <Adamant> p_l: ARM Cortex or the network processor type MIPS64?
13:33:03 <p_l> Adamant: no, MIPS64 as architecture. SiCortex makes low-power, high-performance MIPS64 cpus :)
13:33:04 <Olathe> Ahh :)
13:33:30 <Adamant> p_l: ah, so it's like the Atom and ARM supercomputers
13:33:53 <Adamant> I liked PPC for low energy high speed
13:34:06 <Adamant> too bad Apple bough PA Semi
13:34:09 <p_l> Adamant: Except Atom is slightly upgraded P54, and ARM afaik didn't get that much in hpc market
13:34:12 <yowgi> hello! I have a “style” question. I'm trying to transform ["abc"] into ["a", "b", "c"]. which one of these would you use? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1580
13:34:19 <augustss> PPC is a very unelegant RISC
13:34:31 <p_l> augustss: PPC or Power? :)
13:34:32 <beelsebob> PPC is not risc
13:34:33 <beelsebob> not any more
13:34:40 <Adamant> I think RISC's elegance in general is overrated
13:34:46 <beelsebob> with the addition of alti-vec it became *very* CISC
13:34:48 <p_l> I think the name is wrongly used
13:34:54 <augustss> beelsebob: they claim the R is for Reasonable
13:35:00 <Saizan> yowgi: neither, i'd use map (:[])
13:35:00 <Adamant> but some of the people in here have far more experience than me
13:35:03 <beelsebob> augustss: haha
13:35:20 <beelsebob> augustss: when the G4 started taking 17 cycles for certain instructions it stopped being RISC
13:35:22 <Adamant> I don't see why everyone hates x86 so much except the lack of registers, for instance
13:35:39 <augustss> Adamant: that's enough reason
13:35:39 <p_l> IIRC correct spelling of RISC is Reduced Instruction Set Complexity :)
13:35:43 <beelsebob> well, x86_64 even has a lot of registers
13:35:47 <yowgi> Saizan, that's not exactly it, even though it looks great :)
13:35:51 <beelsebob> p_l: Reduced instruction Set Computer
13:35:53 <beelsebob> not complexity
13:35:54 <Adamant> x86-64 has enough finally
13:36:05 <p_l> beelsebob: I personally use "load-store" :)
13:36:09 <Botje> yowgi: uh, separate [x] is not a correct pattern
13:36:09 <yowgi> oh, on head.
13:36:18 <centrinia> I hate the x86 because I  can't access the microarchitecture of most implementations. :(
13:36:19 <Botje> and you forgot map return
13:36:24 <augustss> Adamant: also, the s86 has 8 special purpose registers.  it's difficult to generate code for
13:36:29 <Botje> or, indeed, EVilRobotMonkey
13:36:33 <augustss> s/s86/x86/
13:36:51 <p_l> centrinia: AMD tried giving access to underlying microarch in K5. No-one used it
13:37:20 <centrinia> Hmm.
13:37:25 <Adamant> augustss: I'm used to doing it by hand. I haven't tried doing it for a compiler backend so I don't know how annoying it is there
13:37:32 <Adamant> since you have I'll take your word for it
13:37:50 <augustss> Adamant: good :)
13:38:24 <p_l> as for real reduced instruction set, I guess the closest to the idea (of _desktop_ machines) were Alpha, MIPS and ARM
13:38:49 <augustss> 88K
13:39:05 <p_l> ah, yes, m88k too
13:39:23 <p_l> Alpha took simplicity and ran away with it, though :)
13:39:37 <augustss> yeah, and it worked for a while
13:39:57 <augustss> SPARC is mostly RICS too
13:40:06 <p_l> augustss: Well, the decisions to kill the project weren't technical :)
13:40:14 <p_l> damn, I forgot about SPARC
13:40:37 <augustss> p_l: so has everyone else :)
13:41:08 <augustss> who is gonna buy Sun?
13:41:11 <p_l> augustss: I'm actually trying to get some SPARC machines (since they are probably most available)
13:42:11 <Heffalump> the Haskell community has a nice 64-way machine now
13:42:17 <pejo> augustss, aren't they simply going for a different part of the market now that they've "switched" to x86-64?
13:42:41 <augustss> they are still in trouble
13:42:58 <augustss> Heffalump: and soon ghc will work on it!
13:43:08 <p_l> pejo: They haven't switched - intel-compatible cpus were used by Solaris since I think 2.4, and certainly by 2.6
13:43:14 <Adamant> Alpha died for political, not technical reasons
13:43:42 <augustss> yeah
13:43:45 <pejo> p_l, but Sun wasn't selling x86 until recently.
13:43:56 <b0fh_ua> Hello there! Can somebody please advice, is it possible to read several integers from the standard input, in the same way as it is done with "scanf" function in C?
13:44:03 <augustss> pejo: they've dabbled with x86 many years
13:44:12 <Botje> b0fh_ua: yes!
13:44:35 <b0fh_ua> Botje: thanks, so I need to ask "how" next ;)
13:44:35 <p_l> pejo: I doubt there would be many Sun clients that would have chosen x86 machine before Opterons became available
13:45:06 <Botje> b0fh_ua: nums <- (map read . words) `fmap` getLine
13:45:28 <augustss> > read "[1,2,3]" :: [Double]
13:45:29 <lambdabot>   [1.0,2.0,3.0]
13:45:57 <augustss> but none of these are exactly like scanf
13:46:44 <augustss> perhaps we need a Text.Scanf
13:46:49 <b0fh_ua> okay, thanks
13:46:55 <p_l> pejo: I worked for a company that avoided x86 in it's production network.
13:46:59 <b0fh_ua> that's would be enough for now
13:48:02 <p_l> pejo: When we were told someone was looking for an x86-64 server that was borrowed some time ago the first reaction was "this is a rare machine" :)
13:48:50 <Adamant> p_l: what did you tend to use?
13:49:00 <Adamant> SPARCs and POWERs?
13:49:27 <b0fh_ua> sorry, guys - is it a right place to ask very stupid questions about programming in Haskell? I just started to learn it
13:49:33 <Botje> sure :)
13:49:39 <p_l> Adamant: SPARCs and POWER, yes. At the time I was working, we were phasing out Alphas (EV7z and EV68)
13:50:05 <Saizan> b0fh_ua: yeah, it is :) don't be scared by other discussions :)
13:50:28 <Adamant> p_l: what was the logic behind it? only advantage I can see is maybe shellcode is less available or "harder" to write
13:50:39 <Adamant> so somewhat less generic security problems
13:50:48 <b0fh_ua> okay, if I have the list of integers - can I print it somehow with using the "map" function (keyword?)?
13:50:50 <p_l> the few x86-64 were used for webservers (fbsd) or office support (those were maintained by subcontractor with Win2k3)
13:51:44 <Saizan> b0fh_ua: you need mapM instead of map
13:51:49 <p_l> Adamant: or maybe the fact that they had quite powerful I/O and had 64bits before Opterons arrived :)
13:51:56 <Adamant> p_l: ah
13:52:04 <Saizan> b0fh_ua: since print (or any function that deals with I/O) is monadic
13:52:10 <Saizan> ?type mapM
13:52:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:52:16 <b0fh_ua> hmm, looks like i need to read about monads first
13:52:28 <Saizan> ?type mapM print
13:52:30 <lambdabot> forall a. (Show a) => [a] -> IO [()]
13:52:33 <p_l> Adamant: Also, it seems that x86 is one of the worst offenders when it comes to energy usage
13:52:39 <pejo> Adamant, even fairly old verisons of Solaris supported 64-bit CPU's, if something breaks and you have support contracts, sun is happy to take your call. They have been supporting netboot and automated installs without people having to hack their own for a long time, etc.
13:53:18 <Saizan> ?wiki Monads as computation
13:53:19 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
13:53:48 <p_l> Adamant: Also, no BIOS faggotry. OpenFirmware and SRM is much better than emulating a 16bit IBM-PC, thank you very much
13:54:16 <Saizan> b0fh_ua: that's a good place to start ^^^
13:54:28 <Adamant> p_l: I don't want to ask what the company was doing, so I didn't want to ask too many question, but a lot of companies with a old school mindset kept buying SPARCs and POWERs for things that commodity hardware could do better
13:54:33 <b0fh_ua> Saizan: thanks, I'm reading it right now
13:54:42 <p_l> Adamant: High-profile telco
13:54:49 <Adamant> or at least the same but cheaper
13:54:57 <Adamant> p_l: ah, might make sense there
13:55:08 <b0fh_ua> damn, I feel like my 7 years in doing Java programming don't give me any help ;)
13:55:10 <p_l> Adamant: And I wouldn't be surprised if TCO of x86 wasn't all that less :-)
13:55:25 <Adamant> p_l: it generally is considerably less
13:55:34 <Adamant> people don't use it for fun
13:55:40 <Adamant> they use it because it's cheap
13:55:41 <pejo> Adamant, if all your other machines are of a certain architecture, it might be worth having a slightly slower thing that is the same as the rest.
13:55:50 <Adamant> pejo: I agree there
13:56:08 <pejo> Adamant, the price of the hardware is just a small part of the TCO.
13:56:12 <Adamant> no Itanics and VMS?
13:56:15 <p_l> Adamant: x86 didn't got popular because it was good, but because it's cheap.
13:56:32 <Adamant> p_l: it was cheap, then it got good
13:56:34 * b0fh_ua found it too complicated and got back to the Haskell tutorial
13:56:35 <p_l> Adamant: There was said to be some lone VMS doing SMS processing that everyone forgot :)
13:56:39 <Adamant> and faster than most everything else
13:57:01 <Adamant> anyway, BIOS's are slowly dying now
13:57:44 <augustss> good riddance!
13:57:47 <Adamant> pejo: I agree, but e.g. even Red Hat is cheaper than Solaris
13:58:14 <p_l> Adamant: It's not necessarily faster (SiCortex), it's not necessarily better (Xeon and NetBurst die, die, die), it's not necessarily cheaper in TCO (imagine a server farm of NetBurst cpus...)
13:58:52 <Adamant> p_l: Atom clusters are doing fine, I agree there on Netburst, but Netburst is dead
13:58:53 <b0fh_ua> btw - as far as I found, most computations are being done as a recursive function calls. Having in mind all those stack things and overhead - how efficient the resulting native code is?
13:58:56 <p_l> Adamant: EFI isn't all that good. I don't like firmware that is given special rights to interrupt whatever happens in a way that is not blockable
13:59:05 <chrisdone> b0fh_ua: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1726
13:59:13 <Adamant> p_l: they're moving on to a EFI successor now IIRC
13:59:24 <p_l> Adamant: They first need to move to EFI ;P
13:59:31 <Adamant> p_l: true!
13:59:39 <p_l> and SMM is going to stay
13:59:44 <Adamant> I liked OpenFirmware on the old PPC Macs.
14:00:05 <p_l> Also, there seems to be nothing newer than EFI (oh, they did change name to UEFI, but that's not much)
14:00:19 <Adamant> p_l: there is, Intel is putting it together now
14:00:27 <Adamant> it's in the active research stages
14:00:39 <p_l> Adamant: I fear what kind of monster they will release
14:00:57 <Adamant> p_l: from what I've heard, sounds really good so far
14:01:06 <Adamant> who knows what the result will be
14:01:30 <Adamant> b0fh_ua: tail call optimization and lazy evaluation are both important
14:01:39 <zprrnqbsl> b0fh_ua - a tail recursive call reuses the stack frame. In other words, it compiles to a GOTO. Recursive calls that are not tail recursive can be slow.
14:01:45 <Adamant> to giving some degree of efficency
14:02:03 <pejo> Adamant, time is really expensive. Running legacy software without a vendor that is actively supporting ABI-compatibility is a nightmare. The OS cost is really a minor thing. (And usually when you buy hardware from Sun you get an OS license bundled).
14:02:22 <Adamant> pejo: Solaris admins aren't cheap
14:03:07 <p_l> As for Atom... it's not that cracked up as people make it seem. For HPC it's not good, due to being a rather old design (1994), for high "thruput", Niagara gives you more threads...
14:03:16 <pejo> Adamant, I charged the same amount per hour regardless of solaris/linux.
14:03:26 <Adamant> pejo: you might, but other people don't
14:03:46 <p_l> Adamant: Also, Solaris as of now costs only the support package (base OS licence is free as in beer&freedom)
14:04:04 <Adamant> right, but support is not cheap
14:04:13 <Adamant> don't get me wrong, I like Solaris more than Linux
14:04:54 <p_l> Adamant: No support that allows you to have live feedback of technician getting packed with parts into an airplane just after you called is cheap
14:05:07 <mdmkolbe> Was ""Scrap Your Boilerplate" Revolutions" ever turned into a standard library?  Or does it only exist as research/sample code?
14:05:18 <Adamant> p_l: right, and a telco needs that, but a lot of other companies don't
14:05:19 <pejo> Adamant, I'm guessing there is a quality differnce between your expensive solaris admin and the cheap linux guy as well.
14:05:32 <Adamant> pejo: not necessarily
14:05:39 <Adamant> there is a scarcity different
14:05:42 <Adamant> *difference
14:05:44 <p_l> Adamant: Also, apparently we had bigger problem _finding_ people than paying them
14:05:52 <Adamant> p_l: right
14:05:59 <Adamant> that's why they can charge more
14:06:12 <p_l> Adamant: How otherwise would you explain the fact that I got hired just after leaving HS? :)
14:06:31 <Adamant> any really good Unix admin can do both Linux and Solaris easy
14:07:01 <Adamant> but there aren't a lot of really good Unix admins
14:07:33 <p_l> Adamant: Anyone who knows how to RTFM can do it
14:07:40 <Adamant> p_l: you'd think
14:07:56 <p_l> Adamant: I think RTFM is much rarer skill :)
14:08:11 <Adamant> just remember killall in Solaris and Linux do very different things :)
14:08:20 <pejo> Adamant, but if that good admin has to build all the infrastructure to bootstrap a new architecture it's soon very expensive to take in just one(ten) oddball machine(s).
14:08:22 <p_l> Adamant: Yeah :D
14:09:26 <Adamant> you don't want to be the Solaris guy equivalent to the new Linux admin that used to do Windows and fixed problems by power cycling all the time
14:09:54 <chrisdone> is map a . map b . map c = map (a . b . c)?
14:10:00 <Heffalump> chrisdone: yes
14:10:12 <chrisdone> is the former more computationally expensive than the latter?
14:10:25 <Heffalump> chrisdone: in theory, but GHC optimisations should make the two equivalent
14:10:36 <chrisdone> cool
14:11:47 <p_l> Adamant: Another thing - I managed to surprise them during hiring by having VMS on Alpha in my CV :P
14:13:08 <FunctorSalad> Heffalump: hmm does GHC do that out of the box? thought it was related to the stream fusion package
14:13:22 <FunctorSalad> (buy maybe that's the fold/unfold thing)
14:13:35 <FunctorSalad> *but
14:13:51 <dtisdall> new here (and pretty new to Haskell), and I have what I *hope* is a simple question. I've writtengroup :: Int -> [a] -> [[a]]
14:13:52 <dtisdall> group n [] = replicate n []
14:13:52 <dtisdall> group n ls = zipWith (:) (take n ls) (group n (drop n ls))
14:13:59 <dtisdall> whoops... sorry about that.
14:14:00 <Heffalump> FunctorSalad: foldr/build should do it
14:14:19 <dtisdall> Anyway, that functions isn't tail recursive, and I'm puzzling about how to make it so.
14:14:28 <dtisdall> So that's my poorly-formatted question. :)
14:16:48 <dtisdall> I should say, I *think* I can see how to make it tail recursive using (++), but my understanding is that there's a performance penalty to pay for that. So I fee like I'm missing something obvious here.
14:18:04 <bremner> dtisdall: often one needs to add extra parameters (accumulators) to make functions tail recursive
14:18:12 <pumpkin> @hoogle uncons
14:18:13 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
14:18:13 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
14:18:13 <lambdabot> Data.ByteString.Lazy uncons :: ByteString -> Maybe (Word8, ByteString)
14:19:25 <dtisdall> bremner: I guess I can't find a way to accumulate this that doesn't involve sticking stuff on the end of the accumulating lists with (++)
14:20:02 <dtisdall> bremner: and I'm not sure if using (++) everywhere is a silly way to solve the problem.
14:20:39 <whpearson> The reason why ++ is bad is that it is order n on the first parameter.
14:20:46 <whpearson> @src (++)
14:20:46 <lambdabot> []     ++ ys = ys
14:20:46 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:20:46 <lambdabot> -- OR
14:20:46 <lambdabot> xs ++ ys = foldr (:) ys xs
14:21:14 <pumpkin> @hoogle concatMaybes
14:21:14 <lambdabot> No results found
14:21:28 <pumpkin> is that a real function or just one people tend to define on lambdabot?
14:21:31 <bremner> dtisdall: I'm just spouting ideas without analyising your function, but reversing lists sometimes helps
14:22:04 <Saizan> ?type catMaybes -- ?
14:22:05 <lambdabot> forall a. [Maybe a] -> [a]
14:22:11 <pumpkin> aha
14:22:17 <pumpkin> @index catMaybes
14:22:18 <lambdabot> Data.Maybe
14:22:19 <pumpkin> meow :)
14:22:20 <pumpkin> thanks
14:23:39 <sw17ch> can you pattern match on operators-as-constructors?
14:23:42 <dolio> @type concatMap maybeToList
14:23:44 <lambdabot> forall a. [Maybe a] -> [a]
14:23:44 <sw17ch> i know yu can with (:)
14:23:49 <sw17ch> but can you with (%) and friends?
14:23:50 <Heffalump> sw17ch: yes
14:23:51 <dtisdall> bremner: I'll take a shot at accumulating the lists backwards and then reversing them at the end, see how that goes for me.
14:24:00 <Gracenotes> any constructor
14:24:00 <Heffalump> :%, you mean?
14:24:15 <dtisdall> I just wanted to be sure I wasn't reinventing to obvious combination of library functions (or a single library function....)
14:24:16 <sw17ch> Heffalump: is that the Ratio constructor?
14:24:17 <Gracenotes> things beginning witth :'s are constructors, often
14:24:19 <sw17ch> @type (%)
14:24:20 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
14:24:35 <Gracenotes> I don't think :% is available, is it?
14:24:40 <Gracenotes> it's hidden
14:24:50 <Heffalump> sw17ch: yes, but sadly it's hidden as Gracenotes says
14:24:54 <Gracenotes> :t (:%)
14:24:55 <lambdabot> Not in scope: data constructor `:%'
14:24:56 <sw17ch> i wasn't aware of said syntax...
14:25:34 <sw17ch> if it was exposed, i could pattern match liek this?
14:25:40 <sw17ch> f (a :% b) = b
14:25:40 <sw17ch> ?
14:26:14 <Gracenotes> yeah
14:26:27 <Gracenotes> of course, you could make your own wrapper, like (,). Not sure how that would go though
14:26:50 <FunctorSalad> > 1 :% 2 == 2:%4
14:26:51 <lambdabot>   Not in scope: data constructor `:%'Not in scope: data constructor `:%'
14:26:54 <Gracenotes> except, there are issues. if you had 1%2, would it pattern match against 2:%4?
14:27:15 <Gracenotes> since :% is just a constructor like Just or :, it wouldn't
14:27:18 <FunctorSalad> , 1 :% 2 == 2:%4
14:27:22 <lunabot>  luna: Not in scope: data constructor `:%'
14:27:30 <Gracenotes> % is a way of wrapping :% to keep invariants, afaik
14:27:31 <FunctorSalad> meh...
14:27:42 <Gracenotes> however, you can do guard-pattern-matching
14:27:52 <FunctorSalad> Gracenotes: or a view pattern
14:27:53 <Gracenotes> f rat | rat == 1%2 = .. so on
14:28:04 <Gracenotes> FunctorSalad: yes. You could even just use (,) :)
14:28:05 <kerlo> @hoogle :%
14:28:05 <lambdabot> Parse error:
14:28:05 <lambdabot>   --count=20 :%
14:28:05 <lambdabot>              ^
14:28:15 <kerlo> @hoogle (:%)
14:28:15 <lambdabot> Warning: Unknown type :%
14:28:15 <lambdabot> Prelude undefined :: a
14:28:15 <lambdabot> Data.Array.Base arrEleBottom :: a
14:28:20 <kerlo> Huh.
14:28:27 <kerlo> arrEleBottom?
14:28:35 <kerlo> @docs Data.Array.Base
14:28:35 <lambdabot> Data.Array.Base not available
14:28:41 <byorgey> Heffalump: pong?
14:29:13 <Gracenotes> in GHC.Real: data  (Integral a)      => Ratio a = !a :% !a  deriving (Eq)
14:29:58 <Gracenotes> for instance, negate (x:%y)       =  (-x) :% y
14:30:09 <Gracenotes> but :% ain't exported
14:34:13 <Heffalump> byorgey: I've been playing with diagrams and I had some questions/complaints :-)
14:34:29 <byorgey> Heffalump: great! let's hear them. =)
14:34:57 <Heffalump> ok. So here's a question. I want to make an arrow, i.e. a line with two more short lines meeting at one end of the first line
14:35:02 <Apocalisp> We should have comonad appreciation day. Seriously.
14:35:08 <Heffalump> and I want to be able to make it pointing in any direction
14:35:28 <byorgey> ok.
14:35:37 <Heffalump> so I can't do this with one path
14:35:54 <Heffalump> and I have to use rotPath to rotate the lines before joining them up, otherwise the bounding boxes are all wrong
14:36:17 <Heffalump> so I wind up having to compute the values to feed to position manually, and I don't even manage to get it right
14:36:27 <byorgey> Heffalump: ah, yeah, that's super annoying.
14:36:34 <byorgey> Heffalump: built-in support for drawing arrows is something I'd like to add in future versions.
14:36:49 <byorgey> Heffalump: but there may be some nice generalization lurking here as well.
14:36:53 <Cheshire> this will require  trigology
14:37:00 <Heffalump> Cheshire: you what?
14:37:14 <Heffalump> byorgey: that'd be nice, but I have similar problems with other things
14:37:20 <Heffalump> so now I want to put text at the ends of my arrow
14:37:28 <Heffalump> and the text should be horizontal no matter what way the arrow points
14:37:48 <Heffalump> I think there needs to be some abstraction for distinguishing specific points in a diagram
14:37:53 <Heffalump> so you can join things up based on those points
14:37:59 <byorgey> Heffalump: yes, that's exactly what I want to add. =)
14:38:13 <Heffalump> oh good :-)
14:38:20 <Heffalump> do you have a concrete plan?
14:38:57 <byorgey> Heffalump: I have some ideas, and some lessons learned from a previous failed attempt to implement it.
14:39:21 <byorgey> Heffalump: if you have ideas on how to do it, or how the interface should look, I'd love to hear them
14:39:35 <Heffalump> I don't have any more specific ones that what I said above.
14:40:03 <Heffalump> oh, I also got some error about a matrix while I was furiously hacking at something else so I didn't save it to report, but I could probably reproduce it if you haven't heard of it before.
14:40:07 <Heffalump> This was in diagrams-0.2 I think.
14:40:44 <byorgey> Heffalump: huh. I'd be very interested in that error message, if you can reproduce it.  I've never heard of such an error before.
14:40:58 <Heffalump> ok, will do so.
14:41:49 <byorgey> Heffalump: My idea for an interface is a function  label :: Point -> String -> Diagram -> Diagram (something like that, along with suitable common special cases) that lets you assign labels to points of diagrams
14:41:54 <Heffalump> btw, I notice that text renders really badly when I use "display" from ImageMagick or the SVG viewer in Firefox.
14:41:56 <byorgey> then later you can refer to those labels.
14:42:19 <Heffalump> that interface sounds good
14:42:29 <Heffalump> need something to namespace all the labels in a diagram too
14:42:42 <byorgey> ah, yeah, you're right.
14:43:02 <byorgey> so if you use ten copies of a diagram you can refer to the labels separately.
14:43:07 <Heffalump> right
14:43:53 <Heffalump> anyway, that's my complaining done with. Thanks for diagrams, it's just what I need modulo those issues.
14:44:06 <Igloo> byorgey: You probably also want an equivalent of metapost's tl/tr/...
14:44:14 <byorgey> Heffalump: glad you're enjoying it, and thanks for the complaints =)
14:44:23 <Heffalump> what are tl/tr? top-left etc?
14:44:27 <Igloo> Yup
14:44:34 <Heffalump> he already has that kind of thing
14:44:37 <Igloo> OK
14:44:41 <Heffalump> it's just not very useful when working with arbitrarily rotated things
14:44:48 <byorgey> Igloo: right.  that's what I meant by 'suitable common special cases'.
14:47:18 <drguildo> is there a preferred sqlite library?
14:47:42 <drguildo> or is there a practical reason for each of them existing
14:50:32 <Cale> drguildo: Not counting the bindings for other database libraries, there appear to be 2...
14:51:49 <drguildo> $ cabal list sqlite | grep "^*" | uniq | wc -l
14:51:49 <drguildo> 7
14:52:13 <Cale> drguildo: the hsSqlite3 package seems to be sort of low-level, and sqlite seems perhaps a bit higher level.
14:52:35 <Cale> The rest of the entries are all bindings for other generic database libraries to use sqlite as a backend.
14:52:56 <drguildo> haskelldb-hdbc-sqlite3 won't even install, great
14:53:08 <dcoutts> drguildo: more reliable: cabal list sqlite --simple-output | cut -d' ' -f1 | uniq | wc -l
14:53:24 <jeffwheeler> drguildo: I've spent the last two days getting SQLite working, but I think I finally have it after playing a ton.
14:53:30 <drguildo> and that's the one covered in real world haskell
14:53:45 <dcoutts> drguildo: none of the haskelldb packages have been updated for ages
14:53:49 <jeffwheeler> drguildo: I first spent forever going with hsql instead of hdbc, but then had more luck with hdbc.
14:53:52 <infoe|wk> cabal?
14:54:09 <dcoutts> drguildo: really? I thought RWH covered HDBC, not haskelldb
14:54:18 <jeffwheeler> It does.
14:54:28 <dcoutts> right, good
14:54:31 <drguildo> haskelldb-hdbc-sqlite3
14:54:36 <drguildo> that's what i was looking at
14:54:50 <dcoutts> drguildo: yes, you don't want haskelldb
14:55:00 <drguildo> what do i want?
14:55:03 <dcoutts> hdbc
14:55:11 <Cale> HDBC-sqlite3 probably
14:55:11 <dcoutts> HDBC-sqlite3
14:55:28 <Cale> I'm just cabal-installing that now.
14:55:42 <drguildo> ok
14:55:54 <drguildo> that won't install either
14:55:55 <jeffwheeler> Just two example files of using modern haskelldb would make it so much easier . . .
14:55:57 <Cale> The problem installing haskelldb-hdbc-sqlite3 looks minor.
14:56:24 <Cale> HDBC-sqlite3 installed fine for me
14:56:31 <Cale> What error do you get?
14:56:39 <Cale> cabal install HDBC-sqlite3
14:56:40 <drguildo> i guess i need the c header files
14:56:46 <jeffwheeler> drguildo: for sqlite3, yes
14:58:31 <jeffwheeler> Does anybody have an example of the introspected modules that it creates? That doesn't work for sqlite3 (it doesn't support sql's DESCRIBE, I guess?), and I'm not sure how to create them by hand.
14:58:46 <dcoutts> drguildo: btw, if you use the latest version of cabal-install then it's much clearer when things fail due to needing C libs
14:59:22 <drguildo> dcoutts: latest as in the last few days?
14:59:38 <dcoutts> drguildo: version 0.6.2 about a week ago
14:59:47 <drguildo> dcoutts: that's what i have
14:59:51 <dcoutts> ok
15:00:18 <dcoutts> drguildo: was the error message for HDBC-squlite3 not clear then?
15:00:48 <drguildo> cabal: Error: some packages failed to install:
15:00:48 <drguildo> HDBC-sqlite3-2.1.0.0 failed during the building phase. The exception was:
15:00:48 <drguildo> exit: ExitFailure 1
15:00:55 <drguildo> i had to scan the scrollback to find "Statement.hsc:41:21: error: sqlite3.h: No such file or directory"
15:01:28 <dcoutts> drguildo: oh, hmm, does your cabal --version say it's using the Cabal lib 1.6.0.2 or .1 ?
15:01:39 <drguildo> .1
15:01:44 <dcoutts> ah, rebuild
15:01:54 <dcoutts> cabal install Cabal cabal-install
15:01:56 <dcoutts> :-)
15:02:10 <drguildo> ok, thanks
15:02:40 <Cale> It's great how that works. I also love how I can upgrade GHC and then use my old cabal-install to get my packages back :)
15:03:20 <Cale> (But it would be even better if cabal-install simply came with GHC)
15:03:32 <adekoba> hi, what can I do to prevent jarbled input/output with these functions? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1733#a1733
15:03:49 <dcoutts> Cale: Peter Robinson has been working on adding a world file so that it's even easier to get back the packages when you upgrade ghc
15:03:56 <jeffwheeler> I have a feeling I'm connecting wrong: http://paste2.org/p/153520 ; that dies after "a"
15:04:19 * jeffwheeler wishes GNOME-Do could paste to hpaste automatically, instead of that crappy site
15:04:29 <Cale> adekoba: Print a newline after the getChar
15:04:42 <adekoba> Cale: righto. Thanks.
15:05:05 <adekoba> Cale: and are the hFlush's standard procedure for this type of thing?
15:05:21 <adekoba> Cale: e.g. input after output
15:05:33 <Cale> adekoba: Yeah, they're necessary if you want to maintain line buffering.
15:05:42 <Cale> Which is necessary if you want backspace to work.
15:05:46 * ddarius makes an ation library so we can have cabal install ation which make libation.a
15:06:10 <dcoutts> ddarius: sorry, it'll be libHSation.a :-)
15:06:25 <ddarius> cbits ho
15:06:27 <Cale> Er actually, I wonder if setting just stdout to NoBuffering would work too.
15:06:32 <Cale> Yeah, that ought to.
15:06:34 <jeffwheeler> @google libation
15:06:35 <lambdabot> http://www.libationnyc.com/
15:06:35 <lambdabot> Title: Libation,restaurant & lounge
15:06:47 <jeffwheeler> Err, that's different than my first result . . . :-/
15:09:15 <toliko_smoren> hey I am writing a text function that goes through a list and displays layouts one after the other. However only the first time it is moved, does not work after that, any idea why? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1734#a1734
15:09:16 <adekoba> Cale: i've revised it and still have the same problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1733#a1735
15:10:14 * BMeph drinks to ddarius' success!
15:10:52 <Cale> jeffwheeler: maybe try connectSqlite3 instead? I don't see the documentation for sqliteConnect...
15:11:32 <Cale> adekoba: er, oh
15:12:12 <jeffwheeler> Cale: http://hackage.haskell.org/packages/archive/haskelldb-hdbc-sqlite3/0.12/doc/html/Database-HaskellDB-HDBC-SQLite3.html is where I see that
15:12:28 <jeffwheeler> Cale: where is connectSqlite3?
15:12:29 <Cale> adekoba: yeah, I see why
15:13:11 <Cale> adekoba: It's that input is line buffered. So input is only seen by getChar once you hit Enter, but then the newline is eaten by the following getLine, and it finishes too.
15:13:50 <Cale> adekoba: So perhaps what you need is a getChar that turns off input buffering temporarily.
15:14:27 <pchiusano> hello
15:14:35 <adekoba> Cale: ok. Strange though, I always remember getChar as having no buffering. Must have changed recently.
15:15:03 <pchiusano> I am trying to understand differentiation of data types, so far it has not clicked, hoping someone can help me
15:15:19 <Cale> adekoba: It might be an oddity of using ghci too...
15:15:25 <Cheshire> pchiusano: does anyone understand it ? :p
15:15:30 <Cale> I understand it.
15:15:33 <Cheshire> pchiusano: .. I don't ven know what to use a zipper for
15:15:41 <Cheshire> pchiusano: there's not many programs out there which do
15:15:54 <pchiusano> so, take the type - data Tree a = Leaf a | Branch (Tree a) (Tree a)
15:16:11 <pchiusano> I understand there is (somehow) an associated polynomial for this type
15:16:11 <Cheshire> Ta = a + Ta * Ta
15:16:32 <Cale> it's, not exactly a polynomial in that case
15:16:36 <Cale> Because the type is recursive.
15:16:39 <adekoba> Cale: no, I just compiled it and the problem persists. However, I tried your suggestion of removing the buffering and it now works! Thanks.
15:16:53 <pchiusano> and that differentiating this polynomial (symbolically) somehow gives us a type which is analogous to a zipper context
15:17:04 <Cheshire> Cale, I think it's a polynomial in 'Tree a'
15:17:06 <Cheshire> e.g. mu X. a + X * X
15:17:17 <Cale> pchiusano: You can get a recursive equation for the derivative by implicit differentiation
15:17:20 <pchiusano> Cale: but there is some equation associated with that type
15:17:37 <Cheshire> pchiusano: Do you know what to do with a zipper once you have it?
15:17:38 <pchiusano> Cale: can you unpack what you just said
15:17:50 <pchiusano> Cheshire, yes
15:18:08 <Cale> pchiusano: Unpack? Well, suppose you have the function:
15:18:13 <Cheshire> oh like what?
15:18:20 <Cheshire> I am curious what you can do with them
15:18:22 <Cale> er
15:18:27 <Cale> Suppose you have a function f such that
15:18:28 <Cale> f(x) = x + f(x)^2
15:18:42 <Cale> (pretend this is ordinary 1st year calculus for a moment)
15:18:43 <pchiusano> Cheshire: have you read http://www.haskell.org/haskellwiki/Zipper
15:18:50 <Cheshire> Cale, it's more like   a + x^2/dx  iirc
15:18:52 <pchiusano> Cale: ok
15:18:58 <Cheshire> pchiusano, I've read pages and pages on this crap....
15:19:01 <Cale> Can you get an equation which f'(x) must satisfy?
15:19:17 <comex> holy hell I have to figure out this differentiation stuff
15:19:23 <comex> derivatives?  in a programming language?
15:19:47 <ddarius> @google "synthetic topology"
15:19:50 <lambdabot> http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf
15:19:50 <lambdabot> Title: Synthetic topology
15:19:52 <pchiusano> Cale: uh, D(f) = 1 + 2 f(x)(D(f))
15:20:03 <Cheshire> oh I'm wrong
15:20:25 <Cale> pchiusano: right.
15:20:27 <pchiusano> Cheshire: you can use a zipper if you have a tree structure that you want to move around on and possibly modify
15:20:47 <Cheshire> pchiusano, yeah does anyone actually have a program that does that?
15:20:58 <Cheshire> when do you want to zip around a tree?
15:21:06 <ddarius> Cheshire: An extreme example would be a structure editor.
15:21:19 <Cale> pchiusano: So, going back to the tree equation, we have T a = a + T a * T a, and similarly, T' a = 1 + T' a * T a + T a * T' a
15:21:35 <pchiusano> Cale - yes, I can follow that
15:21:43 <Cale> pchiusano: So that's the derivative.
15:21:55 <pchiusano> Cale: but it's recursive...
15:22:03 <ddarius> pchiusano: So?
15:22:32 <Cale> data Tree' a = Leaf' | BranchL' (Tree' a) (Tree a) | BranchR' (Tree a) (Tree' a)
15:22:35 <FunctorSalad> I guess it means you can unfold a T' a into the right hand side
15:22:55 <Cale> pchiusano: All we need is a recursive equation in order to make a data declaration.
15:23:01 <ddarius> data Tree' a = Leaf' | BranchL Bool (Tree a) (Tree' a)
15:23:05 <pchiusano> Cale: Ahhhhh!
15:23:07 <ddarius> -L
15:23:25 <Cale> Well, there are countless other ways to express the derivative type.
15:23:25 <pchiusano> i think it just clicked for me
15:23:58 <FunctorSalad> so what does this derivative mean? ;)
15:23:58 <pchiusano> I mean, I don't understand why that works
15:23:58 <ddarius> Cale: I think there are only countably many other ways.
15:24:05 <Cale> ddarius: hehe
15:24:10 <Cale> ddarius: Yeah, seems so.
15:24:27 <pchiusano> Cale: how do you know to associate 1 with a singleton type?
15:24:55 <Valodim> what would be the haskell way to do basically this:
15:24:55 <Valodim> data Stuff = Stuff [ClassSomething]
15:24:55 <Valodim> where ClassSomething is a class? It doesn't work that way I know, but how would I implement this concept?
15:25:01 <pchiusano> and how do you know that the type a + b means you need to give a separate ctor name to both a and b
15:25:03 <Cale> pchiusano: Well... it's the unit under multiplication
15:25:13 <Cheshire> Valodim,  data Stuff a = Stuff [a]
15:25:18 <FunctorSalad> up to teh isomorphism
15:25:32 <Cheshire> Valodim, and then you do e.g.    Stuff [3,3,5] and you get  Num n => Stuff n
15:25:47 <Saizan> Valodim: the list is supposed to able to contain values of different types together?
15:25:56 <FunctorSalad> Cale, is there any alternative description of this derivative that would be insightful?
15:25:56 <Valodim> can I put class restraints on the type?
15:26:03 <Cale> pchiusano: Addition corresponds to making a choice between two things, multiplication corresponds to taking both of them.
15:26:22 <Cheshire> Valodim, what I did gets the class constraint inferred
15:26:27 <Cale> FunctorSalad: I suppose there's a very close connection with generating series.
15:26:46 <Valodim> hum. ok will try, thanks
15:26:54 <FunctorSalad> hmmm
15:27:00 <pchiusano> Cale: thank you very much for you explanation
15:27:28 <Cale> These ideas are actually quite old...
15:27:48 <pchiusano> god, it must have been so mind blowing to write down the rules for creating a one-hole context from a datatype and realizing it was the same as differentiation!!!
15:28:02 <pchiusano> Cale: how so?
15:28:05 <Cale> Well... it was unsurprising to me actually. :)
15:28:17 <Cale> I'd been doing the same thing in my combinatorics courses. :)
15:28:48 <Cale> Which isn't really concerned with datatypes, but combinatorial structures, which are more-or-less the same thing.
15:29:15 <pchiusano> interesting
15:29:16 <Cale> and we have generating series, which are series describing (usually at least) the number of structures of a given size
15:29:33 <Cale> The coefficients give the count, and the exponents give the size...
15:30:03 <Cale> Like 1 + 2 x + 5 x^2 would be the series for a set of objects with one object of 0-size, two of size 1, and 5 of size 2.
15:30:57 <Saizan> how do you interpret the derivative there?
15:31:08 <Cale> Differentiating a series corresponds to 'deleting' one of the subobjects which gives it its size, in all possible ways
15:31:19 <Cale> (if it can be done in a canonical way)
15:32:04 <Cale> So for example, if you have a generating series for graphs in terms of the number of vertices
15:32:10 <dolio> L' a = a * L' a + L a...
15:32:17 <dolio> That's not really the way you usually see it.
15:32:27 <Cale> and you decide that deleting a vertex is supposed to do the obvious thing and remove all the edges connected to it as well
15:32:55 <Cheshire> why do derivatives have something to do with deleting objects though?
15:32:59 <Cale> Then the derivative of the series gives you the series for all the ways of deleting a vertex from each of the graphs counted by the first series.
15:33:07 <jeffwheeler> I just got a verbose error from the code before: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1736#a1736; now it's specifically a segfault
15:33:12 <Cale> Well, take x^3 for example
15:33:19 <Cale> It's x * x * x
15:33:38 <Cale> There are three x's we could delete, and each time we will get x^2 as the result
15:33:50 <Cale> and so the derivative is 3 x^2
15:34:05 <Cale> ;)
15:34:12 <Cheshire> basically it's a coincidence
15:34:18 <omnihil> there are no coincidences in math
15:34:26 <Pseudonym> omnihil: That's not true.
15:34:38 <Pseudonym> Goedel's Theorem states that there are plenty of things which could be accidentally true.
15:34:40 <Cheshire> ***non-coincidence that nobody has explained (such that I understand the relation)
15:34:51 <Valodim> Pseudonym: coincidence = incidence we haven't yet figured out
15:34:51 <Cale> Whether it's a coincidence or not is up to you :)
15:34:56 <Valodim> uh, yeah what he said :P
15:35:02 <Cale> anyway, dinner :)
15:35:09 <Gracenotes> how does printf work with varargs?
15:35:10 <Cheshire> what do you mean 'up to you'?
15:35:10 <Pseudonym> I thought that coincidence is the formal dual of incidence.
15:35:11 <Valodim> duh, it just now comes to me that lists are homogenous and I can't put a bunch of types that aren't all the same but only of the same class into a list. ugh.
15:35:14 <pchiusano> it's not a coincidence, there must be some set of axioms that both systems satisfy
15:35:21 <Valodim> I'm too used to OO :(
15:35:26 <Gracenotes> @hoogle printf
15:35:26 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
15:35:26 <lambdabot> module Text.Printf
15:35:26 <lambdabot> package printf-mauke
15:35:35 <Pseudonym> But it's true that this isn't a coincidence.
15:35:42 <dolio> Valodim: You can write an existential wrapper.
15:35:49 <Pseudonym> Generating series/functions and combinatorics have a long and noble history together.
15:35:49 <araujo> Valodim, that is a very good thing :)
15:35:49 <Cheshire> Pseudonym: how come?
15:35:51 <Gracenotes> hrm. PrintfType is a typeclass of functions, I guess...? :0
15:35:58 <dolio> data Wrap = forall a. Class a => Con a
15:36:21 <Valodim> any link on the matter?
15:36:25 <Cheshire> I suppose this is juts math that I have not studied then
15:36:29 <Botje> Gracenotes: look up polyvariadic functions in haskell
15:36:48 <Botje> printftype is an implementation of that proposal to allow multiple arguments
15:36:49 <Valodim> araujo: better than imperative but still at times it's annoying when dealing with haskell :P
15:36:54 <Botje> well, variable # of arguments
15:37:14 <Pseudonym> Valodim: http://en.wikipedia.org/wiki/Zipper_(data_structure)
15:37:18 <Twey> Gracenotes: Not just functions — also String, IO (), and everything else printf takes
15:37:24 <FunctorSalad> btw there's also the safer Text.Printf.TH
15:37:35 <Gracenotes> huh, funny
15:37:36 <araujo> Valodim, it is .. when you first start .. after a while it all makes sense
15:37:40 <Pseudonym> However, it goes back at least to 1964:
15:37:42 <Pseudonym> http://portal.acm.org/citation.cfm?id=321249
15:37:44 <Pseudonym> Probably earlier.
15:37:48 <Saizan> @google existential types wikibook
15:37:49 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
15:37:58 <Cheshire> "Maybe astonishingly, this mechanical application of a concept borrowed from a distant field of mathematics will yield a fruitful result"
15:38:05 <Valodim> great, thanks guys
15:38:08 * Valodim goes read :P
15:39:02 <Saizan> Valodim: i should warn you that there's probably a more haskelly way to solve your problem :)
15:39:23 <rmoss> i'm trying to take a list of strings and make a binary search tree out of it, here is what I have so far http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1737#a1737 but I don't know how to deal with the empty list
15:39:40 <Valodim> if I can get it to work that's plenty for now. to have it work with nice code is kinda a secondary goal
15:40:06 <dobblego> rmoss, data BSTree a = Empty | Node a (BSTree a) (BSTree a)
15:41:00 <rmoss> nice one thanks
15:41:18 * BMeph makes a data WrapDirection object, so he can have a Con a West...
15:42:04 <FunctorSalad> parse error
15:52:12 <Cale> pchiusano: Well, yes
15:52:31 <Cale> pchiusano: Specifically, the product rule for differentiation is what's important here.
15:52:42 <Cale> pchiusano: and the linearity
15:54:17 <Cale> A linear operator (one which preserves addition, and multiplication by a constant) which satisfies a product rule like D(f * g) = Df * g + f * Dg will have a lot in common with the usual derivative.
15:56:10 <FunctorSalad> so.... is every type a limit of polynomial types? :D
15:56:22 <jeffwheeler> For anyone curious about my segfault from earlier, here's the fix: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1736#a1739
15:56:29 <pchiusano> Cale: interesting
15:56:37 <Pseudonym> Cale: You also need the existence of constants, which are objects c such that Dc = 0.
15:56:51 <Pseudonym> But that's a minor technical point.
15:57:10 <FunctorSalad> don't you need a stronger thing, that all the mono-types *are* constants?
15:57:46 <Pseudonym> FunctorSalad: Partial derivatives make sense in bifunctors.
15:57:50 <Cale> Well, it depends on what you want to say...
15:58:14 <Pseudonym> In that case, you pretend that x is a constant if you're taking the derivative with respect to y.
15:58:39 <Pseudonym> That's really two differential operators.  For D_x, y is a constant and for D_y, x is a constant.
15:59:14 <FunctorSalad> where do the bifunctors come in?
15:59:30 <Pseudonym> A pair is a bifunctor.
15:59:39 <Pseudonym> There's a left fmap and a right fmap.
15:59:44 <FunctorSalad> *nod*
16:00:58 <Pseudonym> A more interesting example, though, is Either.
16:01:07 <Pseudonym> Either a b is, more or less, a + b
16:01:25 <BMeph> Pseudonym: A cobifunctor? :)
16:01:41 <Saizan> (container types are usually the fixpoint of a bifunctor)
16:01:57 <Pseudonym> Right.
16:02:08 <FunctorSalad> is my statement even true, that non-polymorphic types have derivative zero?
16:02:59 <FunctorSalad> (I'm slightly confused between polymorphism and recursive type definitions right now ;))
16:03:01 <edwardk> bmeph: actually Either is just a bifunctor
16:03:28 <edwardk> there is a 'left and right map'  for for either as well.
16:03:29 <Saizan> uhm, what's the derivative of mu X. 1 + X ? i.e. Nat
16:04:12 <FunctorSalad> well, d/da Nat = 0 ;)
16:04:23 <FunctorSalad> (in the Tree case we did d/da)
16:04:31 <edwardk> in fact any category's notion of product, sum, exponential, and coexponential is just a bifunctor in the end.
16:05:33 <Pseudonym> Right.  There are no free variables in mu X. 1 + X
16:05:37 <Pseudonym> since X is bound by mu.
16:06:03 <FunctorSalad> hmm ok so is the derivative of a two-argument type some sort of linear functional Hask^2 -> Hask? ;)
16:06:19 <FunctorSalad> (polymorphic with two type vars, I mean)
16:07:04 <edwardk> FunctorSalad: i missed the beginning of the conversation, but you said something about about polynomial types. polynomial types skip exponentials which in hask are data types that use ->.
16:08:01 <FunctorSalad> edwardk: yes, I was semi-jokingly making an analogy to the stone-weierstrass theorem that any function [0,1] -> R is a uniform limit of polynomials :)
16:08:28 <FunctorSalad> then we could continuously extend the derivative to function types
16:09:10 <FunctorSalad> *any *continuous* function
16:09:17 <edwardk> data Exp a = Lam (a -> a) | Ap a a -- isn't a functor because of the negative occurence of a, but can be made a functor over the subcategory formed by all left invertible functions in hask, or more correctly by the groupoid formed by isomorphisms in hask
16:10:16 <edwardk> er s/groupoid formed by/groupoid of/
16:10:55 <edwardk> one sec while i mine through the tunes.org log to find out what you were talking about when i showed up ;)
16:10:59 <FunctorSalad> edwardk: hmm not quite following... why would you expect that type to be a functor?
16:11:24 <FunctorSalad> (to my knowledge "Exp" should be a synonym for (->))
16:11:30 <edwardk> well, its an endofunctor, just over the wrong category.
16:11:33 <FunctorSalad> oh or you mean "expression" I guess
16:11:38 <edwardk> yeah
16:12:00 <edwardk> Mu Exp there is just an explicitly recursive lambda calculus
16:12:17 <FunctorSalad> edwardk: the context was that Cale has explained derivatives of types :)
16:12:25 <edwardk> ah
16:12:50 <FunctorSalad> (for types of the form Mu X. polynomial(X))
16:12:56 <edwardk> there are a ton of bifunctor combinators in category-extras explicitly so i could build up derivatives automatically, but then i never got around to implementing the derivative stuff ;)
16:13:04 <FunctorSalad> (so I was wondering how to extend it to arbitrary types, but a bit tongue-in-cheek)
16:14:04 <edwardk> fair enough. well, start playing with the d/dx e^x = e^x and see where it goes ;)
16:15:26 <edwardk> you may wind up having to take a logarithm in there though, so i think you're screwed ;)
16:16:49 <FunctorSalad> just thought that too
16:17:26 <edwardk> did you ever read http://comonad.com/reader/2008/generatingfunctorology/ ?
16:17:55 <FunctorSalad> will have a look :)
16:18:07 <edwardk> in there i give a definition for e^x type-wise in terms of its generating function, but i don't think it maps onto exponentials in the category
16:19:06 <edwardk> that reminds me i keep meaning to define a Data.Bag and Data.Cycle  data types that only permit randomized extraction. then they can be nice haskell functors, etc.
16:19:30 <Cale> edwardk: You mean in terms of an exponential generating series?
16:19:56 <Cale> oh, I see.
16:20:16 <Cale> Yeah, these things roughly are "exponential" already. :)
16:20:28 <edwardk> cale: yeah haskell data types are ordinary generating functions, you can get the full gamut of species from exponential generating functions
16:20:43 <edwardk> er haskell polynomial data types
16:21:24 <FunctorSalad> one interpretation was "T'(a) = ways to make a hole in place of of one of the a's"?
16:23:21 <edwardk> the generating functions i used there were "how distinguishable ways the constructors can be arranged to housing n values" as the nth term in the generating function.
16:23:46 <Cale> edwardk: Well, what I mean is that it looks like they have to be intererpreted exponentially anyway to make the composition mean the right thing, even with standard ones no?
16:24:22 <Cale> hmm
16:24:46 <edwardk> cale: ordinary generating functions should be closed under the operations you'd want to perform on them.
16:25:08 <Cale> series ;)
16:25:56 <edwardk> in the terminology of http://en.wikipedia.org/wiki/Generating_function and wilf's generatingfunctionology, function ;)
16:26:08 <Cale> Hehe, my combinatorics prof was always adamant about using the term generating series rather than generating function, because you're basically never interested in their analytic properties.
16:26:17 <edwardk> fair enough
16:26:24 <Cale> And many of them don't even converge anywhere except 0
16:26:36 <edwardk> sure
16:26:55 <Cale> I really wish there was a better free text on this stuff.
16:27:36 <Cale> I should write one perhaps ;)
16:27:40 <edwardk> i've just stuck with the generating function terminology because that was how i learned it. i took a classical analysis course that covered it and a friend of mine learned them straight from wilf (strangely enough while in a class room with richard garriot of magic the gathering fame)
16:28:13 <Cale> generatingfunctionology has such a strange presentation
16:28:19 <edwardk> yeah
16:28:24 <edwardk> i enjoyed it though
16:29:35 <Cale> It seems intent on obscuring the simple connection between operations on structures and operations on series... I recall it had this bizarre and unintuitive derivation of the exponential generating series for sets of nonempty sets.
16:30:03 <Cale> Whereas that's just a direct consequence of the composition lemma.
16:30:10 <Cale> e^(e^x - 1)
16:30:34 <Gracenotes> :X
16:30:48 <Gracenotes> > :X
16:30:49 <lambdabot>   <no location info>: parse error on input `:'
16:30:58 <Gracenotes> > ):
16:30:58 <lambdabot>   <no location info>: parse error on input `)'
16:31:03 <edwardk> so, can you come up with any new notion of data types by interpreting poisson generating series, lambert series, dirichlet series, or bell series? ;)
16:31:51 <Cale> Well, the important thing which makes the various types of series distinct is the connection coefficients for the basis elements.
16:32:06 <edwardk> *nods*
16:33:10 <Cale> That is, for some basis {b_i} how you express b_n b_m as a sum of the basis elements determines the weight and kinds of combinations that are produced when you combine an object of weight n with an object of weight m
16:33:47 <Cale> So different kinds of series would have to correspond to different kinds of 'multiplication' on data structures.
16:33:55 <Cale> (or types)
16:34:59 <edwardk> anything exponential can be accounted for by joyal's species. just can't think of any intuition for how anything more general would operate.
16:35:07 <mauke> anyone have a url handy that sends source as something other than text/plain (e.g. text/x-hs or whatever)?
16:35:58 <omnihil> mauke, www.google.com
16:36:01 <omnihil> it returns text/html
16:36:16 <mauke> er, I meant source code
16:36:21 <mauke> as in programs, not html
16:36:37 <omnihil> oh
16:36:44 <skorpan> try this one: http://jjfoerch.com/git/conkerorrc/shell.js
16:36:47 <skorpan> not sure, but...
16:36:57 <mauke> no, that displays fine
16:37:11 <omnihil> skorpan, that's text/html
16:37:55 <Cale> Well, starting with ordinary generating series, we have that x^n x^m = x^(n+m) which is a basis element already, so for each pair of objects of weight n and m respectively in the original sets, we have a single object of weight n+m in the product. So it suffices to let the interpretation on the level of sets be the Cartesian product and the weight of a pair to be the sum of the weights of its parts.
16:38:19 <mauke> google--
16:38:23 <edwardk> sure
16:38:46 <Cale> With the exponential generating series, we have (x^n/n!)(x^m/m!) = (n+m)!/(n! m!) x^(n+m)/(n+m)! = (n+m;n) x^(n+m)/(n+m)!
16:39:23 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Graph.html anyone know if there's a good way to get a list of vertices adjacent to a given vertex in there?
16:39:31 <edwardk> alright, still with you.
16:39:37 <edwardk> the rest of them are somewhat opaque to me
16:39:50 <edwardk> mainly because i've managed to forget most of the math involved in them ;)
16:40:07 <Cale> So to interpret that as some operation on sets, we deal with labelled objects (you're probably completely familiar, but just a review :)
16:40:50 <pumpkin> oh, it's a Table
16:40:53 <Cale> For a pair of objects with weight n and m respectively from the original sets, we need (n+m;n) new objects in the combined set of weight n+m
16:40:57 <edwardk> feel free, its helping to shake off the rust ;)
16:41:50 <Cale> So we think of the sub-parts of our combinatorial objects as being labelled somehow with numbers from 1 up to the weight (each occurring just once)
16:42:16 <Cale> but (x,y) where x and y are labelled objects of this sort isn't going to have a valid labelling right off
16:42:52 <Cale> So we want to apply the labels from 1 up to n+m to x and y
16:43:13 <Cale> (n+m;n) corresponds to the number of ways to decide which of the n+m labels go to the first component
16:43:29 <Cale> (and thus which go to the second)
16:43:37 <Cale> and then we can just apply them in order
16:43:44 <Cale> make sense?
16:44:00 <edwardk> so far so good
16:44:25 <edwardk> that fits with my mental model pretty closely, modulo some choice of terminology ;)
16:44:32 * SamB wonders why debian's "firebug 1.3.0-1" is showing up as 1.2.0b6 in the About box
16:45:11 <Cale> So if we have two permutations, say, ([1,3,2], [1,5,2,3,4]) and from {1..8} we choose {2,4,6} to go to the first component, the labelling will be ([2,6,4],[1,8,3,5,6])
16:45:51 <Cale> okay
16:45:57 <Cale> So, Dirichlet series...
16:46:08 <edwardk> not to interrupt, but as a random aside, any objection to Bag as a randomized nondeterminism monad?
16:46:33 <Cale> hmm... "randomised"?
16:46:43 <edwardk> since you have to give me the StdGen to extract from it anyways, i'm thinking i can shuffle during the bind steps as well
16:46:52 <Cale> oh
16:46:54 <SamB> hmm, community.haskell.org could use a logo ...
16:47:18 <jeffwheeler> SamB: I think _Haskell_ could use a logo first. :P
16:47:19 <Cale> Well, there are two types of Dirichlet series we could use, but they're equivalent combinatorially.
16:47:37 <SamB> jeffwheeler: I was under the impression the thing to do now was pick one ?
16:47:40 <Cale> One has the basis elements n^x, the other has n^(-x)
16:47:48 <SamB> has the voting opened yet?
16:47:54 <Cale> Note that n^x m^x = (nm)^x
16:47:56 <jeffwheeler> SamB: Yes . . . but that seems to have been awfully slow. :-/
16:48:00 <jeffwheeler> SamB: It's not yet open.
16:48:01 <edwardk> alright, the n^s one is what i'm familiar with
16:48:15 <Cale> (the other one is more useful for analysis)
16:48:27 <Cale> (this one is just simpler to write)
16:49:01 <Cale> So for two objects with weight n and m respectively, they combine to give an object of weight nm in the product.
16:49:24 <Cale> So we can again use just a plain Cartesian product, but the weight of (x,y) is the product of the weights of x and y.
16:50:02 <Cale> In the case of data structures, this will probably mean that we'll want to have an "element" of the product for each pair of elements of the original objects.
16:50:41 <edwardk> thinking about that.
16:50:52 <Cale> (element in the sense of a value of the parameter type)
16:50:57 <edwardk> alright.
16:51:37 <Cale> So, I can imagine what we might do for something like a pair of tree types.
16:52:34 <Cale> We'd want a new tree type where each location in the new tree type corresponds to a pair of locations in the original types.
16:53:02 <edwardk> yeah, doesn't joyal have a connector like that actually?
16:53:43 <Cale> It's likely. To be honest, I haven't got the chance to read much of Joyal's presentation, apart from the Wikipedia article.
16:53:44 <edwardk> oh wait, no its different
16:54:02 <edwardk> the one i'm thinking of is where you take two structures of the same size and have each of them hold the same element set
16:54:07 <edwardk> not quite the same
16:54:42 <edwardk> on the other hand, if you applied that operator to the cartesian product of the elements contained in the original set it would have the right size
16:54:51 <Cale> While on the one hand, Joyal's presentation is a beautiful application of category theory, the involvement of category theory is a little bit frivolous at the same time :)
16:54:57 <edwardk> yeah
16:55:23 <edwardk> i just reconstructed it from the combinatoric properties of the objects it works with
16:55:34 <edwardk> and kinda kicked the category theory tot he curb ;)
16:56:12 <Cale> Yeah, that's basically like the presentation we were given at Waterloo. It's very similar to Joyal's, but no mention of categories. :)
16:56:25 <Cale> (or even functors)
16:56:45 <Cale> But lots of bijection arrows ;)
16:56:57 <edwardk> to me what they are is clear from the exponential generating functions (er... series ;) ) that result =)
16:56:59 <Cale> and operations on combinatorial sets
16:57:30 <monochrom> Damn Waterloo and their combinatorical explosion.
16:58:05 <edwardk> hrmm, ugh. to be anal retentive i can't really allow you to open a cycle with a stdgen or you could distinguish cycles. ;)
16:58:11 <Cale> So yeah, all the various types of generating series are just ways of getting appropriate connection coefficients for the kind of combination of species you want to support.
16:58:18 <edwardk> but requiring IO seems rather draconian
16:59:26 <Cale> So if you can think of an operation which combines two types in some fanciful way, you can hope that there's some ring and basis such that multiplication of basis elements corresponds to that operation on types :)
17:00:07 <edwardk> or at least semiring
17:00:22 <edwardk> unless you want abstract species ;)
17:00:49 <Cale> Well, yeah, we usually don't worry if the coefficient ring of our ring is too large.
17:01:14 <Cale> If we want complex coefficients for some reason, that's not a problem -- it's just only some of the elements of the ring will have combinatorial interpretations.
17:03:25 <Cale> If your operation on types is associative, then you have a monoid ring which works for you right away, but since it encodes everything which is going on, is probably too large to say much about.
17:03:52 <Cale> So you're then looking for homomorphisms to throw away lots of that structure while keeping enough to solve the problems you're interested in.
17:04:34 <Cale> (which is what the usual approach to generating series which only keeps the sizes of the objects does)
17:05:09 <edwardk> cale: either you're getting better at explaining things or i'm getting better at understanding them ;)
17:05:13 <Cale> :)
17:09:22 * SamB wondered when aptitide started supporting the mouse under screen ...
17:10:29 <SamB> is planetplanet *supposed* to be using around 30% CPU on community.haskell.org ?
17:10:57 <Cale> planetplanet?
17:11:16 <SamB> apparnatly it's the software for Planet Haskell
17:11:22 <Cale> ah
17:11:36 <SamB> at least, it's the software for loads of Planet aggregators
17:11:54 <monochrom> "the Planet monad". "join :: Planet (Planet haskell) -> Planet haskell"
17:12:40 <edwardk> so do you like data Bag a = Bag (StdGen -> [a]) or Bag a = Bag (StdGen -> ([a],StdGen)) -- i.e. the state or modified reader version? the state version lets me avoid splitting and its bad i'm not sure this can exist properties.
17:13:52 <edwardk> (in the end the stdgen gets locked away behind the monad machinery and not exposed by cloising the constructor so it doesn't really matter that they are both 'too large'
17:13:52 <Cale> The planet planet is obviously Magrathea.
17:14:14 <monochrom> I like the state version. unless the reader version gives an infinite stream of [a] and that is all I need.
17:14:18 <Cale> Magrathea would have been a much better name for this software ;)
17:14:24 <edwardk> type Magrathea a = Planet (Planet a)
17:14:36 <skorpan> infinite type, no?
17:14:39 <skorpan> no
17:14:41 <skorpan> no?
17:14:47 <Cale> skorpan: what?
17:14:50 <monochrom> Wait, if all I need is an infinite stream, I would like a state monad using that stream as state!
17:14:53 <Botje> edwardk: hmm, you left out [Missile] somewhere
17:14:56 <skorpan> edwardk's snippet, isn't that an infinite type?
17:15:11 <Botje> skorpan: no, because you don't repeat Magrathea on the RHS
17:15:14 <skorpan> right
17:15:17 <edwardk> skorpan: how?
17:15:22 <skorpan> never mind, i'm being silly
17:15:26 <edwardk> k
17:16:14 <Cale> edwardk: I would have expected something like  data Bag a = Bag (Map a Nat), but perhaps those aren't large enough?
17:17:46 <edwardk> cale: well, i was sticking to the list interpretation because it fit nicely with the existing list-as-nondeterminism paradigm
17:18:30 <Cale> edwardk: So a bag is its random selection procedure? I suppose that works :)
17:19:19 <edwardk> and then i just expose the Bag a -> IO [a] evaluator
17:19:29 <Cale> hmm... I think the reader version works well, but of course you're not going to want to thread it like reader.
17:19:35 <edwardk> yeah
17:19:43 <edwardk> i already worked out that big, its fairly easy
17:19:45 <edwardk> er bit
17:19:54 <edwardk> same with its monadplus instance
17:20:52 <byorgey> what's the preferred adjective: "categorical", "category-theoretic", or "category-theoretical"?  or maybe "categoryish"?
17:20:55 <edwardk> i just don't like the fact that i have to keep calling split, mainly because i've yet to be convinced that split is all that safe mathematically on stdgen
17:21:11 <dolio> One of the first two.
17:21:11 <edwardk> categorical or category-theoretic i would say
17:21:16 <mmorrow> byorgey: catlike?
17:21:20 <toliko_smoren> hey i am trying to use gtk2hs, and i am using cairo to draw pango layouts, however i want to draw a formatted layout, but layoutSetAttributes returns an IO instead of an layout that can be drawn using Cairo? Help please?
17:21:27 <byorgey> mmorrow: hehe, excellent
17:21:38 <Cale> toliko_smoren: so, run the IO action?
17:21:41 <byorgey> I am going to start referring to isomorphisms as "catlike reflexes"
17:21:48 <mmorrow> "the reflexes of a cat, and the speed of a mongoose"
17:22:03 <Cale> toliko_smoren: What's the type of layoutSetAttributes?
17:22:14 <dcoutts> toliko_smoren: it's basically an imperative api, setting the attributes modifies the layout, you have to query afterwards
17:22:22 <toliko_smoren> layoutSetAtributes takes an layout and returns an IO
17:22:28 <Cale> IO ()?
17:22:32 <toliko_smoren> yes
17:22:49 <roconnor> does agda have a logo?
17:22:53 <Cale> (dcoutts knows better than I do :)
17:23:02 <toliko_smoren> Cale: i need to use Cairo as I am using MoveTo to position the printing location
17:23:18 <Cale> toliko_smoren: So you'll have to run that action, and then... get the current layout somehow?
17:23:51 <dcoutts> toliko_smoren: you can lift IO actions into the Render monad, or you can set up your layout first before entering the Render monad
17:24:07 <toliko_smoren> how do you lift IO actions into the Render?
17:24:10 <Cale> liftIO
17:24:48 <gueux> hi :-)
17:25:22 <gueux> I try to use IORef
17:25:27 <gueux> I have:
17:25:29 <gueux> data Database = IORef [String]
17:25:29 <gueux> createdb :: IO Database
17:25:29 <gueux> createdb = newIORef []
17:25:46 <gueux> but it gives me an error
17:25:47 <toliko_smoren> i am looking at the Gtk2Hs and there is not liftIO function described although it is listed in the index
17:25:47 <mauke> did you mean s/data/type/?
17:25:55 <gueux> arg
17:25:58 <gueux> thanks
17:26:14 <Cale> toliko_smoren: It's in Control.Monad.Trans
17:26:14 <dcoutts> toliko_smoren: it's a standard function, not defined in gtk2hs
17:26:17 <dcoutts> toliko_smoren: use hoogle
17:26:22 <dcoutts> @hoogle liftio
17:26:22 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
17:27:22 <gueux> and to create a database, is there a "better" solution than that type?
17:27:45 <Cale> gueux: Than a list of strings? Well...
17:27:58 <Cale> gueux: I suppose it depends on what data you have :)
17:28:02 <byorgey> gueux: it depends what you want to do.
17:29:52 <gueux> in fact, I want to have a database of games and to be able to put a modification in a game (when someone plays), to add a new game, to remove a game
17:30:14 <toliko_smoren> sorry I am completely confused now, how could i use liftIO to change the IO () into a render?
17:30:37 <Cale> toliko_smoren: By applying liftIO to it, which will turn it into a Render ()
17:31:12 <toliko_smoren> it compiles but nothing is drawn
17:31:22 <Cale> hmm
17:31:30 <gueux> with an imperative language I would have taken a Hashtable with the names of the games as keys
17:32:00 <edwardk> heh, i just realized i can't just use ++ in the monadplus instance i have to actually merge the two shuffled results
17:32:42 <toliko_smoren> here is the paste of the function, please take a look at it
17:32:43 <toliko_smoren> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1742#a1742
17:33:02 <toliko_smoren> this whole thing has been annoying me the whole day
17:34:12 <toliko_smoren> the function takes a list of layouts and draws them one next to each other recursively by constantly adding the x value, however now that i try to apply attributes to it it does not work
17:34:12 <Saizan> gueux: use a Data.Map.Map then
17:35:26 <dcoutts> toliko_smoren: does the attribute list contain the text too?
17:36:19 <toliko_smoren> no, i have it in the tuple
17:36:22 <toliko_smoren> [((IO (Gtk.PangoLayout)),[Gtk.PangoAttribute])]
17:36:56 <gueux> ok
17:36:58 <gueux> thanks
17:37:22 <dcoutts> toliko_smoren: so if you don't set the attributes then you get a non-0 corX right? and if you do it's 0? is that what's happening?
17:38:58 <toliko_smoren> dcoutss: no, i have layouts with text, i get the size of the layout, add the length of the thing to the x, set the cursor at the point x+lenght, and than apply the attributes to the layout and want to print the layout at the position
17:40:07 <toliko_smoren> i tried hard coding a single attribute
17:40:11 <toliko_smoren> and the thing is still not shown
17:40:38 <dcoutts> toliko_smoren: have you tried with layoutSetMarkup?
17:41:07 <dcoutts> toliko_smoren: if that works and setting attributes does not then perhaps there is a bug in the binding for the set attributes function
17:42:06 <conal> are there Foreign.Storable instances for tuples lying around somewhere handy?
17:42:37 <toliko_smoren> markup does not show anything as well
17:43:04 <toliko_smoren> the whole liftIO thing does not seem to do anything
17:45:29 <dcoutts> toliko_smoren: sounds like you should post to the gtk2hs users list
17:45:43 <dcoutts> toliko_smoren: try as small an example that does not work that you think should work
17:46:27 <jre2> is there a good BMP reading library?
17:47:22 <toliko_smoren> my code is small, i pasted the most important function
17:48:16 <edwardk> hrmm, dilemma with >>= and ++ on a random bag. ideally you'd like the resulting list to be perfectly shuffled, but also to support infinite bags. these goals seem to be somewhat at odds.
17:48:46 <edwardk> i need to know the size of the result list to perfectly shuffle, which rules out infinite lists
17:49:08 <edwardk> and interleaving biases the distribution
17:49:24 <pumpkin> I want an infinite bag of chips
17:49:58 <edwardk> because bag [a,b,c,d] `mplus` bag [e] will interleave e near the front. leaking information about placement
17:49:59 <toliko_smoren> is there a way to render at a certain position without using cairo?
17:50:11 <redditbot> HCL: High-level library for building command line interfaces.
17:50:14 <regulate> pumpkin: so take lazily
17:50:42 <edwardk> you can have an infinite bag of potato chips as long as you only eat a finite number.
17:51:03 <pumpkin> can it be a very large finite number?
17:51:27 <StoneToad> hmm 10^10^10^10 potato chips...
17:51:34 <regulate> dont outeat your memory
17:52:03 <StoneToad> I think we'd all die of over consumption  before then :)
17:52:39 <shapr> edwardk: d00d
17:53:07 <edwardk> heya shapr
17:54:13 <edwardk> just bound his consumption by just denying him water or something ;)
17:54:35 <edwardk> or worse, an infinite bag of stale chips
17:55:19 <pumpkin> that would make me unboundedly sad
17:56:10 <monochrom> I'm an unsound bag.
17:56:23 <dcoutts> toliko_smoren: hmm, all the examples in the pango tarball use cairo too, or win32
17:56:49 <toliko_smoren> yeah, so how am i supposed to draw formatted text
17:56:51 <toliko_smoren> with cairo?
17:56:52 <pumpkin> DAWGs are still hard to do in haskell :P
17:57:03 <pumpkin> would be easier if I had a graph library I liked
17:57:04 <shapr> Who let the ...
17:57:05 <shapr> oh nm
17:57:08 <toliko_smoren> if the liftIO does not seem to work?
17:57:11 <shapr> pumpkin: You don't like Erwig's libs?
17:57:11 <pumpkin> :)
17:57:25 <pumpkin> shapr: I've read his paper and like the idea, but the API kinda scares me
17:57:27 <edwardk> yo dawg. i heard you like haskell, so i put a haskell in your haskell so you can eval while you eval.
17:57:34 <pumpkin> I'll give it a better look when I'm not so tired
17:58:01 <pumpkin> there are lots of tries everywhere, but not enough DAWGs
17:58:13 <pumpkin> so I put a trie in your trie so you can prefix search while you suffix search
17:59:27 <dcoutts> toliko_smoren: it's nothing to do with liftIO, that works fine
17:59:48 <dcoutts> toliko_smoren: I modified the gtk2hs/demo/pango/Layout demo to use layoutSetMarkup
17:59:48 <toliko_smoren> hm the thing doesnt want to get shown
17:59:56 <dcoutts> toliko_smoren: that test case works for me
18:00:02 <toliko_smoren> could you paste it to me please?
18:00:34 <dcoutts> hunk ./demo/pango/Layout.hs 29
18:00:34 <dcoutts> -  lay <- layoutText ctxt loremIpsum
18:00:34 <dcoutts> +  lay <- layoutEmpty ctxt
18:00:34 <dcoutts> +  layoutSetMarkup lay loremIpsum
18:00:52 <Olathe> You dawg, I heard you like bop, so I put the bopshoe in your bopshoebop, so you can dipdedipdedip while you ramalamadingdong.
18:01:05 <dcoutts> toliko_smoren: then you can modify the loremIpsum string to include things like "<b>bold</b>" etc
18:01:41 <dcoutts> toliko_smoren: you've got the ./demo/pango/Layout.hs right? from the gtk2hs tarball
18:01:45 <toliko_smoren> yes
18:03:38 <toliko_smoren> thanks
18:03:42 <toliko_smoren> i will try that
18:07:49 <edwardk> @seen cale
18:07:49 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 36m 27s ago.
18:08:26 <edwardk> cale: the map/intmap approach is starting to appeal if only because i can know the length and combine them and shuffle the output fairly readily
18:19:08 <toliko_smoren> i figured it out, i had a random space in the middle of nowhere that stopped the do from reaching the end, thanks for all the patience
18:20:23 <dcoutts> toliko_smoren: great!
18:27:23 <gueux> hi again :-)
18:27:36 <gueux> I have:
18:27:44 <gueux> type Net = ReaderT Bot IO
18:27:44 <gueux> data Bot = Bot { socket :: Handle, database :: Database, starttime :: ClockTime }
18:28:21 <gueux> if I want to access to one of the fields of Bot, I use "ask"
18:28:36 <gueux> can I write a new value to one of these fields?
18:29:21 <Gracenotes> gueux: what new value do you want to write?
18:29:21 <gueux> (inside the Net monad I mean)
18:29:28 <gueux> database
18:29:55 <mauke> only locally, that is for some subcomputation
18:29:55 <rovar> sure
18:30:02 <Gracenotes> is database an IO database? If so, just liftIO
18:30:23 <mauke> or that
18:30:31 <gueux> database is just a Map String String
18:30:31 <rovar> note, if you're modifying the database, you might want it in a StateT
18:31:25 <Gracenotes> gueux: hm. In my opinion a great type for IRC bots is StateT MutableIRCData (ReaderT ImmutableConnectionData IO), or something like that
18:31:33 <rovar> gueux, you'd use  >  h <- asks database   from inside the Net monad
18:31:37 <Gracenotes> might be a little complicated though >_>
18:32:03 <gueux> wooao
18:32:08 <Gracenotes> either way, ReaderT is like a function that takes an initial parameter. In fact, it really is just a wrapper around a function (e -> a)
18:32:12 <gueux> what a complicated type
18:32:31 <Gracenotes> gueux: well, ImmutableConnectionData isn't an actual type ;) It could just be a Handle
18:32:36 <mauke> function: the naked reader
18:33:05 <gueux> in fact I'd like my bot to have a database and then allow the users of the chatroom to modify this database
18:33:24 <mauke> I'd put the database in a separate program
18:33:30 <rovar> I use:  > data Stuff = Stuff { rnd :: StdGen, db :: DB.Db BS.ByteString PC } ; ... type Net = ReaderT Bot (StateT Stuff IO)
18:33:32 <Gracenotes> in that case a StateT is probably what you're looking for
18:33:50 <rovar> which does exactly that.
18:33:55 <Gracenotes> having nested monad transformers might be a little complicated at first
18:34:21 <rovar> the only thing about nested monad transformerers is setting them up, imo :)
18:34:30 <gueux> mauke: but the users have to access to the same database
18:34:34 <Gracenotes> just (StateT Stuff IO) is fine
18:34:38 <mauke> yes
18:34:43 <gueux> and there might be some conflicts
18:34:44 <gueux> no?
18:34:54 <mauke> the bot can communicate with the db server over a socket
18:35:01 <gueux> ok
18:35:06 <gueux> I've tried that
18:35:07 <Gracenotes> it would involve mixing together connection data and IRC-related state, but that's not criminal
18:35:11 <gueux> at the beginning
18:35:20 <gueux> but I was lost in the sockets :-)
18:35:27 <rovar> if it's just state Stuff then you'll have to put the socket in the Stuff record as well.
18:35:40 <mauke> sockets? did you have more than two?
18:35:51 <gueux> only two
18:36:01 <gueux> but it was too much for me :-)
18:36:02 <mauke> good
18:36:13 <gueux> it should be the best solution
18:36:36 <gueux> like that I could access to the database with other interfaces
18:36:40 <logout> How can I raise a number to a fractional exponent? ie 2 ** ( some_int / 12.0)
18:36:59 <Gracenotes> for an IRC thing I'm writing I'm using newtype'd transformers, the overall type being ReaderT (MVar IRCState) (ReaderT ConnectionState IO)
18:37:03 <mauke> logout: convert the Int to a Double first, using fromIntegral
18:37:22 <logout> mauke: thanks
18:37:23 <rovar> logout: that seems good like that.
18:37:32 <gueux> so, I would have to put another socket into Bot?
18:37:40 <Gracenotes> @type ((**), (^^), (^))
18:37:41 <lambdabot> forall a a1 b a2 b1. (Integral b1, Num a2, Integral b, Fractional a1, Floating a) => (a -> a -> a, a1 -> b -> a1, a2 -> b1 -> a2)
18:38:00 <mauke> IMHO the main advantage is that even crashing bugs in your bot don't cause data loss :-)
18:38:19 <mauke> preflex++
18:38:23 <rovar> gueux, no. You need to change your ReaderT to a StateT, then you can store your socket and database together
18:38:24 <logout> rovar:  You're right, now that I type that into ghci, that does work... I wonder what I'm actually doing wrong..
18:39:04 <rovar> gueux, otherwise you won't be able to modify the database
18:39:12 <gueux> rovar: I mean, if I have a server for the database
18:39:51 <gueux> if I use mauke's solution
18:40:13 <rovar> if your database solution is in the IO monad, then yea, you can use it in the reader
18:40:55 <roconnor> whew, motivating dependent type theory from the logic/math side is a lot more work than from the CS side.
18:41:34 <gueux> ok
18:41:45 <rovar> roconnor: is that because in CS the computer does the work of validating dependents?
18:42:11 <gueux> I may ask you some help again soon :-)
18:42:20 <roconnor> with CS it is just: take typed function programs, remove general recursion, add steriods
18:43:23 <rovar> anyone know of someone who's ported Limp to haskell?
18:43:27 <roconnor> with math/logic is is: introduce natural deduction, add constructive connectives, add proof objects, add data types, add dependent types, add induction, there you go.
18:43:57 <rovar> roconnor: you lost me at add constructive connectives.
18:43:59 <dolio> Those are motivations?
18:44:03 <rovar> heh
18:44:06 <roconnor> rovar: :)
18:44:34 <roconnor> dolio: er, I guess I mean explaining rather than motivating
18:45:14 <dolio> Of course, motivating might be easier, too.
18:45:19 <byorgey> rovar: like "and", "or", and "implies"
18:45:25 <dolio> In CS, it's "our types aren't good enough. Let's make better ones."
18:45:43 <roconnor> the motivations for the two are fairly simple:  CS gets certified programs and math gets automatic proofs
18:46:51 <dejones> Hello, I'm getting some linker errors with GHC and Gtk2Hs, any suggestions?  ThreadViewer.o: In function `r4bt_info':
18:46:51 <dejones> (.text+0x1d4): undefined reference to `gtkzm0zi10zi0_GraphicsziUIziGtkziTypes_zdf663_closure'
18:47:08 <dejones> Is there a way I can ensure that the Gtk2Hs libraries are being linked?
18:47:21 <dcoutts> dejones: --make
18:47:22 <rovar> dejones:  are you using --make?
18:47:34 <dejones> dcoutts, rovar: Yes, I am using --make.
18:47:47 <rovar> damn, that's all I got on that one :/
18:47:52 <dejones> heh.
18:48:06 <rovar> --make-please?
18:48:13 <dcoutts> dejones: you've cleaned the program you're trying to build right?
18:48:27 <dcoutts> got rid of stale .o and .hi files
18:48:59 <dejones> dcoutts: Yep, I've done that, just tried it again.. no help.  :(
18:50:11 <redditbot> All About Monads - another Monad tutorial
18:50:13 <dcoutts> dejones: I guess you can see if the libHSgtk.a actually exports that symbol
18:50:38 <dejones> dcoutts: Hmm.  I forget how to do that...
18:50:38 * wli ponders C types.
18:50:46 <dcoutts> dejones: nm
18:50:53 <dcoutts> and grep
18:51:00 <dejones> dcoutts: thanks, I'll try that.
18:51:17 <dejones> dcoutts: I think I may have had this issue before and it required me to --disable-split-objs with Gtk2Hs
18:52:36 <dejones> dcoutts: Yea, it seems that those symbols are not exported. :(
18:52:50 <logout> I am not sure why I can't use the Int result from fromEnum in an exponent... http://pastie.org/399337  Can anyone help?
18:53:10 <dejones> dcoutts: I am going to try recompiling Gtk2Hs with --disable-split-objs
18:53:15 <dcoutts> dejones: good idea
18:53:17 <dejones> :)
18:53:48 <rovar> blakh, you about?
18:53:54 <rovar> blackh, you about?
18:54:51 <blackh> I'm about
18:56:12 <drhodes> logout: wild guess, but maybe try ^^ instead of ** ?
18:56:28 <logout> Actually, on second try mauke's answer worked.
18:56:33 <logout> fromIntegral
18:56:38 <logout> Thank you guys.
18:56:47 <blackh> rovar: I am totally about!
18:56:59 <rovar> blackh: sorry.. baby emergency..
18:57:02 * shapr boings quietly
18:57:43 <rovar> blackh, i'm converting from Data.BerkeleyDB to Database.BerkeleyDB, had a question, but I may have solved it
18:58:05 <Nafai> SHAPR!
18:59:06 <blackh> rovar: Maybe you discovered the C++ dependency. Unfortunately you have to compile - you can't 'runhaskell'
18:59:29 <rovar> yea, I think I sent you an email WRT a week ago
19:00:22 <rovar> nah, looking more closely at capitals.hs answered it.  I was doing something dumb.
19:01:05 <blackh> rovar: Oh that was you! Hello!
19:01:14 <rovar> :)
19:01:23 <rovar> hello
19:01:37 <rovar> did you write the MUD example?
19:01:47 <blackh> rovar: Yes. I had fun with that.
19:01:52 <rovar> me too :)
19:02:01 <gwern> aw man. using data.binary was going so well, such a simple switch - but it gives me file locking issues :(
19:02:04 <gwern> bad data.binary!
19:02:06 <wli> Ooh, a MUD?
19:02:10 <wli> URL?
19:02:27 <rovar> it's an example in BerkeleyDBXML
19:03:03 <gwern> oh, and it makes yi eat all my memory
19:03:05 <gwern> (what the heck)
19:03:17 <dejones> dcoutts: --disable-split-objs worked.  :)  Maybe I should submit a bug report?
19:03:29 <dcoutts> dejones: to ghc? :-)
19:03:38 <rovar> wli: it's pretty mind blowing, a multi-player capable mud, including disk serialization in 468 lines of code including lots of comments
19:03:41 <dcoutts> dejones: what platform are you on?
19:03:49 <gwern> is data.binary grotesquely inefficient with Data.Sequence or something?
19:03:52 <rovar> granted, there isn't any combat..
19:04:43 <gueux> when I add only one server to listen to, I had a function listen: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1743#a1743 [+]
19:05:03 <dejones> dcoutts: I don't know if it is a bug in GHC or Gtk2Hs.  I am on Debian Linux and building Gtk2Hs with GHC version 6.11.20090221
19:05:06 <wli> rovar: oooh do tell?
19:05:35 <blackh> wli, rovar: Haskell + BerkeleyDBXML ... we stand on the shoulders of giants, and all that
19:05:41 <gueux> do I have to put "s <- init `fmap` io (hGetLine h, hGetLine g)"  (g is my other socket)
19:06:01 <twb> Cabal question: after doing "cabal configure --prefix=/usr" and "cabal build", how do I tell cabal install to actually install the files into debian/tmp/ instead of /?
19:06:10 <gueux> to listen to the two sockets simulaneously?
19:06:54 <gwern> twb: aren't you lying to cabal when you say --prefix/usr then?
19:07:05 <dcoutts> twb: cabal copy --destdir=whatever
19:07:13 <twb> dcoutts: thanks.
19:07:13 <rovar> blackh, I think if you used BerkeleyDB, you could use DeriveTH and cut out all of the pickling code :)
19:07:19 <twb> gwern: no.
19:07:30 <twb> gwern: strictly speaking, I'm lying to cabal install.
19:07:32 <rovar> Binary and DeriveTH
19:07:34 <dcoutts> twb: copy is the correct way to prepare distro package images
19:07:42 <twb> dcoutts: righto, I'll use that.
19:07:50 <dcoutts> twb: don't use install because that registers
19:07:53 <gwern> what sort of horrible person lies to an innocent program like that?
19:08:06 <dcoutts> twb: you need to call register with the flag to give you the package info or script
19:08:13 <twb> dcoutts: oh actually, I'm using "./Setup copy", because libcabal is installed but cabal-install might not be
19:08:27 <dcoutts> twb: yep, that's fine
19:08:36 <twb> OK, testing time
19:08:39 <dcoutts> they have more or less the same command line interface
19:08:49 <blackh> rovar: True. DBXML gives fancy querying, but you don't really need it for this app.
19:08:58 <dcoutts> twb: distro packages should use Setup.hs not cabal-install
19:09:39 <twb> dcoutts: is e.g. "./Setup test" a no-op if there are no tests defined?
19:09:48 <dcoutts> twb: probably
19:10:14 <dejones> dcoutts: Think it is a GHC bug?
19:10:25 <rovar> blackh, so I'm using the ReaderT, but I'm not sure where to put the DB shutdown code.
19:10:55 <dcoutts> dejones: could be that ghc doesn't like your gcc version. Do you build ghc with split objs on your box?
19:11:16 * bos is baffled by a linking bug
19:11:34 <blackh> rovar: Shutdown? Do you want to close everything when your app exits?
19:11:51 <rovar> blackh: I notice there isn't any such code in adventure.hs.  Yea, It's polite to close berkeleyDB, ya?
19:12:04 <blackh> rovar: adventure.hs never exits
19:12:06 <dejones> dcoutts: Ohhh, I think I remember what the bug is... It is a GHC bug where I did a debug build and that doesn't support split-objs but gives no error when trying to build with split-objs.
19:12:12 <pumpkin> baffled bos!
19:12:20 <dcoutts> dejones: oh, could be
19:12:20 <bos> yeah, it doesn't happen often,
19:12:30 <wli> rovar: Where is this code? It sounds awesome.
19:12:31 <bos> i'm usually infallible, sort of like the pope.
19:12:34 <bos> only irish.
19:12:46 * pumpkin 's worldview collapses
19:12:56 <dejones> dcoutts: Yea, I remember running into this previously, it's an issue that my GHC build doesn't support split-objs, but gives no error when attempting to build split-objs.
19:13:07 <dcoutts> dejones: right, ok
19:13:09 <pumpkin> what's the linking bug?
19:13:09 <rovar> wli, http://www.haskell.org/haskellwiki/BerkeleyDBXML   get the tarball from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BerkeleyDBXML-0.6.1
19:13:12 <bos> i am stuck grubbing through readelf output to see why a program is failing to link.
19:13:14 <blackh> wli: It's in the BerkeleyDBXML package at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BerkeleyDBXML
19:13:43 <bos> oh, shit.
19:13:53 <pumpkin> ah yeah, I know that bug all too well
19:15:04 <fjkdlsjkl> I have a question that's difficult to find the answer to.  I like running "ghci blah.hs" and running individual functions I've written.  However, if I have defined a main function, my prompt is "Prelude Main>" instead of "*Main>" and I can no longer run my functions.  How can I run my individual functions in ghci with a main function?
19:15:20 <gueux> is "a >>= b" equivalent to "do a b"?
19:15:28 <pumpkin> fjkdlsjkl: one quick answer might be to type :r
19:15:29 <bos> oh, that's horrible.
19:15:41 <rovar> gueux,  do
19:15:43 <rovar> a
19:15:44 <bos> the icu library uses preprocessor macros to rename all of the symbols it exports.
19:15:45 <rovar> b
19:15:50 <mmorrow> gueux: do x <- a; b a
19:15:50 <pumpkin> gueux: do x <- a; b x
19:15:52 <Gracenotes> do x <- a; b x
19:15:54 <mmorrow> heh
19:16:00 <mmorrow> s/a/x/
19:16:05 <pumpkin> Gracenotes: get out of my head!
19:16:17 <gueux> ok
19:16:21 <gueux> thanks
19:16:31 <Gracenotes> pumpkin: I know you like the x. *wink*
19:16:39 <mmorrow> pumpkin: not if there's seeds in there!
19:16:42 <dejones> dcoutts: yep, I submitted the GHC bug before, haha.  -- http://hackage.haskell.org/trac/ghc/ticket/2832
19:17:00 <gueux> is there a >>= notation if I have two arguments to give to b?
19:17:04 <dcoutts> dejones: I think I remember it now too
19:17:10 <dejones> :)
19:17:29 <dejones> dcoutts: thanks for the help.
19:17:33 <dcoutts> np
19:17:39 <gueux> I mean "do\n x <- a\n y <- c\n b x y"
19:17:43 <mmorrow> @pl \x -> a >>= \y -> b x y
19:17:43 <lambdabot> (a >>=) . b
19:18:00 <pumpkin> gueux: liftM2
19:18:02 <fjkdlsjkl> Hmm, thanks, I can't always reproduce it though.. Hmm.
19:18:13 <pumpkin> or wait
19:18:23 <pumpkin> @src liftM2
19:18:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:18:47 <pumpkin> guess not :)
19:19:07 <gueux> wasn't it that?
19:19:09 <mmorrow> gueux
19:19:14 <pumpkin> that one has a return
19:19:15 <gueux> ok
19:19:24 <mmorrow> gueux: depends how you're getting the other arg to `b'
19:19:34 <mmorrow> yeah, and the return too
19:20:42 <shapr> Nafai!
19:20:50 <Nafai> How's it going man?
19:20:51 <mmorrow> gueux: (a >>=) . b $ x ==> (a >>=) (b x) ==> a >>= \y -> b x y
19:21:19 <gueux> wow
19:21:31 <Gracenotes> oh, how I love the ==> operator
19:21:35 <gueux> I may use the do notation :-)
19:21:37 <gueux> thanks
19:21:38 <gueux> :-)
19:21:41 <mmorrow> :)
19:24:28 <mmorrow> oh i just noticed how you're getting the `x'
19:24:57 <gueux> if I have a tuple and if I do something like (a { x = "toto" }, x a)
19:25:11 <gueux> will x a give me "toto"?
19:25:11 <mmorrow> err, what i was just going to suggest doesn't help clarity ;)
19:25:46 <mmorrow> gueux: no
19:26:51 <mmorrow> look at it like:
19:26:55 <gueux> so, I have to do a "let aux = a { x = "toto" } in (aux, x aux)
19:27:15 <mmorrow> foo (A x y) = (A "toto" y, x)
19:27:32 <gueux> ok
19:33:15 <gueux> for my function "listen", if I do something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1743#a1744 [+]
19:34:08 <gueux> and if nothing is written on the first socket, does listen listen to both sockets?
19:35:28 <Saizan> gueux: no, it won't read from the second until the getLine on the first returns
19:35:28 <Gracenotes> gueux: why do you have three parameters expected, but two in the type?
19:35:50 * Gracenotes must be missing something
19:35:54 <gueux> Gracenotes: sorry
19:36:02 <gueux> the "db" does not exist
19:36:42 <gueux> so, do I have to do?
19:36:46 <gueux> +how
19:36:47 <gueux> :-)
19:37:01 <bremner> what is an easy way to read a file of lines of integers  into a list of lists
19:37:11 <gueux> I'd like to listen to the two sockets at the same time
19:37:28 <rovar> gueux, that seems that in order to listen on two sockets you need two threads.
19:37:47 <rovar> unless there is a polling mechanism I'm not aware of
19:38:01 <rovar> just a wild ass guess, btw
19:38:05 <gwern> bremner: read . readFile?
19:38:40 <Gracenotes> bremner: well, get a function to read a one-line string into a list. You can chain things from there.
19:39:16 <Gracenotes> something like: map yourfunc . lines . readFile
19:40:02 <Gracenotes> filtering out the lines that can't be parsed. It depends on how much you trust the input
19:40:23 <gueux> rovar: do you have an example?
19:40:30 <bremner> the input is perfect (toy setup)
19:41:00 <glguy> for those that don't follow my twitter :-D http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1741
19:41:01 <BMeph> bremner: Makes no difference. :)
19:41:03 <gueux> I'm as much familiar with sockets as with threads :-)
19:41:35 <glguy> *Main> runAuto counter (take 10 (cycle [one,zero]))
19:41:35 <glguy> [0000,0001,0001,0010,0010,0011,0011,0100,0100,0101]
19:41:48 <Gracenotes> bremner: okay, might want to leave a comment 'assumes well-formed input'
19:42:04 <gueux> but threads frightened me since I've heard about Alice and Bob
19:42:05 <Gracenotes> now just write yourfunc (named nicely)
19:43:00 <Gracenotes> what, Alice and Bob have their own threads now? Are they still "just friends", too? Aggravates me to no end.
19:43:27 <gwern> anyone know how to strictify reading a Seq using data.binary?
19:43:30 * bremner discovers break
19:43:49 <Gracenotes> bremner: you've seen reads, too?
19:43:52 <Gracenotes> @type reads
19:43:53 <lambdabot> forall a. (Read a) => String -> [(a, String)]
19:44:20 <Gracenotes> and words, for that matter? :)
19:44:21 <bremner> Gracenotes: ahh, maybe that is even easier
19:44:30 <Gracenotes> @type words
19:44:31 <lambdabot> String -> [String]
19:44:43 <Gracenotes> > words "a b c d e f ohgodwhatisthisidon'teven"
19:44:45 <lambdabot>   ["a","b","c","d","e","f","ohgodwhatisthisidon'teven"]
19:45:19 <rovar> gueux, nope, sorry
19:45:23 <Saizan> gueux: oh, wait, you're using the same handle for both hGetLine, is that right?
19:45:38 <gueux> no
19:45:40 <rovar> if you search for concurrent haskell there are some examples, not sure about with sockets though
19:45:58 <gueux> I thought the conclusion was that I needed two handles :-)
19:46:15 <rovar> question, I'm using DeriveTH makeBinary. but the binary string I'm generating needs to be qualified with B.
19:46:27 <gueux> one to listen to the chat room and another to communicate with the database server
19:46:41 <leimy> Haskell has no "select"?
19:46:55 <Saizan> leimy: not exposed
19:47:03 <Gracenotes> select...?
19:47:10 <Saizan> unix's select
19:47:19 <leimy> Right but does it even have "alt" or some way to pull a socket from a collection?
19:47:20 <Saizan> well, i guess you could FFI it
19:47:49 <Saizan> leimy: no, the rationale is that you should use threads instead
19:47:55 <blackh> leimy: The only reason why you need select is to conserve OS thread memory. Haskell doesn't have this problem, so you don't need select.
19:48:14 <leimy> that's not the only reason to use select :-)
19:48:20 <leimy> not at all actually
19:48:41 <blackh> leimy: Perhaps I should say "the only reason why I ever needed select..." :)
19:48:47 <leimy> :-)
19:50:11 <leimy> Is there not some kind of choice operator Conal has that could apply as a select
19:50:12 <redditbot> Simple Cabal parsing
19:50:12 <leimy> ?
19:50:23 <leimy> from reactive or something?
19:50:42 <Cale> It wouldn't be so hard to write your own with forkIO, I would expect.
19:50:55 <Saizan> it's trivial with TChans
19:51:46 <roconnor> > 3^14
19:51:51 <lambdabot>   4782969
19:52:02 <roconnor> > 4^14
19:52:03 <lambdabot>   268435456
19:52:21 <roconnor> that's close to 20 000 000
19:52:28 <roconnor> er
19:52:30 <roconnor> no
19:52:37 <roconnor> > 4^13
19:52:38 <lambdabot>   67108864
19:52:57 <leimy> hmmm unamb?
19:53:11 <leimy> http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice/
19:53:26 <leimy> Could one consider the values from a socket to be "more defined" than others?
19:53:34 <leimy> by the fact that a socket has data vs doesn't.
19:53:51 <gueux> do you know how I should do to use two threads to listen to the two sockets on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1743#a1745 [+] (the last revision)
19:53:58 <gueux> ?
19:54:14 <newsham> select les you choose from IO progress from several different sources.  unambiguous choice lets you pick the first of several computations that yields identical results
19:54:17 <Saizan> leimy: you're likely to lose data that way
19:54:17 <newsham> not quite the same thing
19:54:26 <gueux> is that in my "run" function?
19:54:45 <leimy> newsham: true... but it was just a passing thought... never really used unamb.
19:55:26 <rovar> i need a [Char] -> [Word8]  hoogle was not helpful
19:55:50 <newsham> > map (toEnum.fromEnum) "this is a test" :: [Word8]
19:55:52 <lambdabot>   [116,104,105,115,32,105,115,32,97,32,116,101,115,116]
19:55:54 <bremner> Gracenotes:  parseInput  = map (map read . words)  . lines  -- needs type signature
19:55:57 <sw17ch> hello all
19:56:14 <newsham> > map (fromIntegral.fromEnum) "this is a test" :: [Word8]
19:56:16 <lambdabot>   [116,104,105,115,32,105,115,32,97,32,116,101,115,116]
19:56:18 <rovar> doesn't such a function already exist?
19:56:20 <gueux> should I do something like "makeThread (ask socket >>= listen)" and then "makeThread (ask gamesocket >>= listen2)
19:56:25 <roconnor> rovar: be aware not all Chars fit into a Word8
19:56:42 <roconnor> (hence such a function does not exist)
19:56:48 <Saizan> gueux: something like that, where makeThread is actually called forkIO
19:56:48 <newsham> rovar: is this because you are using bytestrings?  because if so, there are bytestrings that will work with Char directly.
19:56:51 <roconnor> (otherwise people would be tempted to use it)
19:57:13 <gueux> ok
19:57:56 <rovar> newsham I'm encoding to Binary
19:57:57 <Saizan> gueux: only one of those should be forkIO'ed, probably, otherwise run will return and the program will end
19:58:05 <rovar> actually..nm
19:58:06 <sw17ch> map (toEnum.fromEnum) "this is a test" :: [Word8]
19:58:09 <sw17ch> > map (toEnum.fromEnum) "this is a test" :: [Word8]
19:58:11 <lambdabot>   [116,104,105,115,32,105,115,32,97,32,116,101,115,116]
19:58:33 <newsham> rovar: Data.Binary?  Char is an instance of Data.Binary.Binary.  you can use "get" and "put"
19:58:36 * sw17ch needs to read farther back before saying stuff
19:58:38 <niet> how do I read a line from the dos command prompt?
19:58:45 <Saizan> gueux: s/one of/the first/
19:58:47 <niet> i mean when run as binary
19:58:51 <rovar> yea.. I am passed a string but need a ByteString
19:59:00 <rovar> the Binary is for the value, which is being handled
19:59:12 <newsham> rovar: where did you get your String from?
19:59:12 <niet> getLine
19:59:15 <Saizan> niet: do line <- getLine; ...
19:59:27 <rovar> newsham; my own API.
19:59:31 <newsham> you might be able to get a ByteString directly.
19:59:45 <newsham> if not,  use Data.ByteString.Lazy.Char8's "pack" function
19:59:56 <newsham> ?type Data.ByteString.Lazy.Char8.pack
19:59:58 <lambdabot> [Char] -> BSLC.ByteString
19:59:58 <rovar> somewhere it needs to be converted, because I'm pretty sure I read a String, not a ByteString from the socket
20:00:19 <Saizan> you can read a ByteString from the socket too
20:00:19 <newsham> there's a library on hackage that can do socket IO using bytestrings.  I havent used it myself yet
20:00:27 <rovar> sweet
20:00:33 <rovar> I'll get to that next :)
20:00:51 <niet> test <- readFile getLine , whats wrong with that?
20:00:51 <niet> Prelude> :t readFile
20:00:51 <niet> readFile :: FilePath -> IO String
20:00:51 <niet> Prelude> :t getLine
20:00:51 <niet> getLine :: IO String
20:00:53 <newsham> but the Char8 "pack" is what you want right now I think
20:00:57 <niet> Couldn't match expected type `FilePath'
20:00:57 <niet>            against inferred type `IO String'
20:00:57 <niet>     In the first argument of `readFile', namely `getLine'
20:00:58 <niet>     In a stmt of a 'do' expression: test <- readFile getLine
20:01:14 <newsham> niet: for multi-line pastes, please use hpaste.org in the future.
20:01:51 <newsham> getLine is of type "IO String" not of type "String".  readFile needs an argument of type String.
20:01:52 <Saizan> niet: test <- do file <- getLine; readFile file
20:02:02 <niet> import qualified Data.ByteString.Lazy.Char8 as B; B.split ' ' $ B.pack "hello there"; -> ["hello","there"]
20:02:05 <rovar> so how do I convert from lazy to nonlazy bytestring?
20:02:30 <newsham> did you want a strict bytestring to start with?
20:02:36 <newsham> ?type Data.ByteString.Char8.pack
20:02:38 <lambdabot> String -> BSC.ByteString
20:02:42 <newsham> use that one instead.
20:02:49 <rovar> yea.
20:03:09 <blackh> rovar: fromChunks and toChunks (I think)
20:03:23 <leimy> @users
20:03:23 <lambdabot> Maximum users seen in #haskell: 658, currently: 599 (91.0%), active: 18 (3.0%)
20:03:31 <Saizan> B.concat . BL.toChunks
20:04:09 <rovar>     Couldn't match expected type `BS.ByteString'
20:04:10 <rovar>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
20:04:31 <newsham> rovar: try Data.ByteString.Char8 instead of Data.ByteString.Lazy.Char8
20:04:41 <rovar> I am using it.
20:04:55 <rovar>     Couldn't match expected type `BS.ByteString'
20:04:57 <rovar>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
20:04:58 <rovar>     Couldn't match expected type `BS.ByteString'
20:04:59 <gwern> shoot, what is this bullshit? I read a Show-generated file in as Seq String, I check the length and everything is fine, I use data.binary to write it out, and it's fine, and then I use data.binary to read it in and it gives me stack overflow? wth it's 97 items long and just 9 megabytes in size
20:05:00 <rovar>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
20:05:02 <rovar> bleh.. sorry
20:05:17 <rovar> import qualified Data.ByteString.Char8 as C8  ;  C8.pack(s)
20:05:18 <gwern> how could that possibly stack overflow >.<
20:05:28 <gwern> does ghci bork data.binary or something?
20:05:43 <newsham> gwern: :(
20:06:07 * gwern is not pleased with data.binary
20:06:19 <newsham> rovar: and the type error is reguarding the value you got from C8.pack s?
20:06:20 <rovar> @toChunks
20:06:20 <lambdabot> Unknown command, try @list
20:06:22 <gueux> "forkIO (asks socket >>= listen)" is not good because of listen type (Handle -> ReaderT Bot IO)
20:06:23 <newsham> going into what function?
20:06:29 <rovar> @ :t toChunks
20:06:39 <rovar> newsham, yes
20:06:48 <rovar> @:t toChunks
20:06:50 <lambdabot>  fd:7: hClose: resource vanished (Broken pipe)
20:07:00 <newsham> ?type Data.ByteString.Lazy.Char8.toChunks
20:07:02 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
20:07:09 <gueux> forkIO needs a IO ()
20:07:13 <Saizan> gueux: do bot <- ask; forkIO (runReaderT (asks socket >>= listen) bot)
20:07:18 <niet> there must be a way to compile a module not named Main but containing a main method into an exe right(not a .o but .exe)?
20:07:22 <rovar> right.. converts a bytestring to an array of bytestrings.
20:07:29 <gueux> ok
20:07:30 <gueux> thanks
20:07:35 <Saizan> niet: -main-is
20:07:45 <rovar> i'll have a look for that lib that socket io bytestring lib
20:07:59 <newsham> rovar: you should be able to do this without that lib, though.
20:08:14 <newsham> what is the function that is expecting a strict bytestring and is getting  a lazy bytestring?
20:08:18 <gueux> Saizan: bot <- ask; ?
20:08:33 <gueux> what is ask?
20:08:48 <Saizan> ?type ask
20:08:49 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
20:08:53 <rovar> ah..
20:09:00 <Saizan> gueux: ask = asks id
20:09:11 <rovar> newsham, it's (encode pc)
20:09:13 <Saizan> gueux: btw, i forgot a liftIO there
20:09:13 <gueux> thanks :-)
20:09:22 <rovar> pc is my object, and encode is a derived makeBinary
20:09:30 <Saizan> do bot <- ask; liftIO (forkIO (runReaderT (asks socket >>= listen) bot))
20:09:33 <monochrom> "don't ask to ask, just ask" gets a new meaning.
20:09:41 <jeffwheelerPhone> @src ask
20:09:41 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:09:53 <Saizan> @src Reader ask
20:09:54 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:10:02 <niet> >ghc --make -O2 -main-is Spamfilter.hs Spamfilter.hs -> Spamfilter.hs:1:0:
20:10:02 <niet>     The main function `hs' is not defined in module `Spamfilter'
20:10:15 <niet> it is
20:10:29 <Saizan> niet: -main-is Spamfilter.main
20:10:45 <newsham> rovar: comment out that line, run ghci, use ":type" to see the types of encode and pc?
20:11:54 * Saizan is not sure that calling the two bytestring types with the same name has been a good choice
20:12:50 <gwern> auuugh! I encodeFile foo, then I do bar <- decodeFile foo, and foo == bar gives me stack overflow!
20:13:17 <gwern> despair! despair! this world of misbehaving data.binary functions has driven me to despair!
20:13:21 * gwern goes and hangs self
20:13:41 <seliopou> Can anybody point me to the latest paper on the STG? Something about adding tags... ?
20:14:02 <Saizan> gwern: try fmap decode . readFile instead
20:14:12 <rovar>    Couldn't match expected type `BS.ByteString'
20:14:14 <rovar>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
20:14:15 <rovar>     In the fifth argument of `db_put', namely `(encode pc)'
20:14:17 <_dolio> @go faster laziness pointer tagging
20:14:18 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/
20:14:18 <lambdabot> Title: Faster laziness using dynamic pointer tagging
20:14:42 <newsham> gwern: I've had trouble like that before.  I was able to work around it by using a newtype and defining my own marshalling primitive for the data typ ein question
20:14:44 <rovar> i'm ugessing encode is of type Data.ByteString.Lazy.Internal.ByteString, so I just need to convert from lazy to strict.
20:15:00 <_dolio> Man, is research.microsoft.com still down?
20:15:14 <gwern> Saizan: readFile being the BS one?
20:15:17 <newsham> (IIRC the problem happened for me because data was encoded as (len,data), so I broke it up into smaller chunks of (len,data) terminated by a zero len)
20:15:21 <seliopou> _dolio: thanks!
20:15:33 <seliopou> hopefully there's a reference the technical report in there
20:15:45 <gwern> newsham: suicide sounds like an easier solution than that
20:15:46 <newsham> rovar: Data.ByteString.Char8.pack should giveyou a strict BS
20:16:06 <mmorrow> leimy: ping
20:16:10 <Saizan> gwern: yeah
20:16:12 <newsham> gwern: the final solution?
20:16:24 <newsham> sure, take the easy way out
20:16:29 <rovar> newsham, encode returns Lazy though.
20:16:34 <leimy> mmorrow: yes?
20:16:36 <rovar> it's a derived type.
20:16:55 <dolio> seliopou: If you google search yourself you can get the paper from the second link. That one doesn't seem to work here.
20:16:56 <gwern> Saizan: well, with 'bar <- (fmap decode $ Data.ByteString.Lazy.Char8.readFile "/home/gwern/foo") :: IO (Seq String)', foo does == bar
20:17:00 <gwern> Saizan: what does this mean?
20:17:06 <newsham> rovar: oh.  I see.   you can definitely convert back and forth but might make more sense to figure out how to work entirely w/ one or the other
20:17:10 <mmorrow> leimy: i snaked a select binding from oleg's ZFS. intending to clean it up/extend it and it only does reads atm, but maybe you'd find it useful. i'll paste it
20:17:24 <leimy> mmorrow: interesting
20:17:31 <mmorrow> it certainly works :)
20:17:42 <leimy> It just seems a waste to use an even lightweight thread for what select can do :-)
20:17:48 <newsham> gwern: btw, you can use parallel strategies stuff ("using" and rnf) to force stack overflow earlier if you want :)
20:17:49 <rovar> newsham, no can do, I BerkeleyDB takes a ByteString.
20:18:12 <newsham> rovar: ahh, then by all means, write up helper that converts using strict concat and lazy toChunks
20:18:18 <gwern> newsham: 'my latest patches make the program crash in just 5ms!'
20:18:45 <Saizan> gwern: no stack overflow? it means that the fact that decodeFile checks that you've consumed all the BS is screwing your laziness
20:18:48 <newsham> gwern: what is the performance gain over earlier versions?
20:19:22 <gwern> newsham: dunno. perhaps 10ms
20:19:43 <newsham> gwern: race to the bottom.
20:20:06 <mmorrow> leimy: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1587#a1587
20:20:13 <mmorrow> leimy: yeah, i totally agree
20:20:33 <leimy> mmorrow: thanks for the post... and agreeing! :-)
20:20:38 <mmorrow> hehe :)
20:21:05 <mmorrow> let me know if you end up adding anything, i'll do likewise :)
20:22:04 <leimy> Cool I've marked it.
20:22:10 <rovar> ?type concat
20:22:11 <lambdabot> forall a. [[a]] -> [a]
20:22:14 <leimy> read is the primary case.  error would be the next most useful for me. :-)
20:22:45 <rovar> newsham what is this strict concat of which you speak?L
20:23:14 <newsham> ?type Data.ByteString.Char8.concat -- not sure, this one maybe?
20:23:16 <lambdabot> [BSC.ByteString] -> BSC.ByteString
20:23:42 <newsham> ?type Data.ByteString.Char8.concat . Data.ByteString.Lazy.Char8.toChunks
20:23:43 <lambdabot> BSLC.ByteString -> BSC.ByteString
20:24:04 <rovar> we have a winner
20:24:10 <newsham> ?type Data.ByteString.Lazy.Char8.fromChunks . return
20:24:12 <lambdabot> BSC.ByteString -> BSLC.ByteString
20:25:10 <newsham> (lazy bytestring is just a list of strict bytestrings I think)
20:25:57 <jfredett_> whats the config-sans-recompile packaget that makes Xmonads Config.hs work?
20:26:50 <rovar> newsham, that worked
20:26:57 <newsham> awesome
20:27:32 <glguy> desugared arrow notation gets unwieldy! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1741
20:27:45 <newsham> yah, you dont wanna play w/ raw arrows :)
20:28:25 <gwern> jfredett_: xmonad-light?
20:29:12 <newsham> time flies like an arrow, category theorists like an arrow.
20:29:15 <dmead_home> hey channel
20:29:20 * dmead_home got laid off today
20:29:21 <jfredett_> gwern: thats the thing that lets me change my Config.hs, then restart Xmonad without recompileing?
20:29:23 <dmead_home> bottoms up!
20:29:31 <newsham> dmead: :(
20:29:37 <newsham> (on bright side, more haskell time now?)
20:29:43 <dmead_home> yes :p
20:29:44 <jfredett_> dmead_home: boo, that sucks.
20:30:03 <dmead_home> i worked for a hardware company... that can't afford to make hardware for anything but embedded OSes now
20:30:08 <gwern> jfredett_: dunno. check.
20:30:16 <jfredett_> been trying...
20:30:18 <dmead_home> i need me some TARP money
20:30:36 <jfredett_> it's hard to look for things when you don't know what your looking for. :/
20:30:48 <glguy> dmead_home, do you already have billions in assets?
20:30:49 <newsham> dmead: I recommend you lend me lots of money and I declare bankruptcy after spending it all
20:30:51 <jfredett_> dmead_home: start a bank, then ask the govt.
20:31:02 <dmead_home> maybe i should just lend somebody a dollar
20:31:05 <chessguy_work> dmead_home, sorry, dude :(
20:31:05 <dmead_home> and qualify to be a bank
20:31:13 <dmead_home> eh
20:31:17 <dmead_home> i'm sure i'll get another job
20:31:22 <dmead_home> just a pain in the arse
20:31:28 <chessguy_work> yeah
20:31:31 <chessguy_work> been there, done that
20:31:36 <newsham> recessions are great times for forming startups
20:31:43 <newsham> got any great haskell startup ideas?
20:31:54 <chessguy_work> i was laid off in may. it turned into a 30% for me ;)
20:32:07 <chessguy_work> and a much better job, to boot
20:32:20 <wli> newsham: Do whatever you were going to in Haskell instead.
20:32:23 <chessguy_work> uh, that's "a 30% raise"
20:32:44 <chessguy_work> newsham, a commercial symbolic chess AI :)
20:32:45 <newsham> reboot time, bbl.
20:34:39 <gueux> Saizan: ok, it worked :-)
20:34:43 <gueux> thanks a lot
20:34:50 <gueux> !
20:34:53 <Saizan> np
20:35:49 <dmead_home> chessguy_work, a 30%?
20:36:00 <dmead_home> oh
20:36:02 <rovar> what pattern would match IO (Maybe ByteString) ?
20:36:06 <chessguy_work> dmead_home, sorry, long day
20:36:10 <dmead_home> np
20:36:14 <dmead_home> yea, tell me about it
20:36:17 <rovar> I tried Just myvar -> blah
20:36:17 <dmead_home> actually
20:36:19 <chessguy_work> @type liftM read
20:36:20 <glguy> rovar, that's probably the wrong question :)
20:36:21 <lambdabot> forall a (m :: * -> *). (Monad m, Read a) => m String -> m a
20:36:24 <dmead_home> i hate industry
20:36:29 <dmead_home> i wanna teach
20:36:35 <chessguy_work> dmead_home, oh, cool
20:36:37 <rovar> glguy: yea probably
20:37:01 <glguy> rovar, how about: do mbBs <- yourM ; case mbBs of Just bs -> ...; Nothing -> ...
20:37:10 <chessguy_work> dmead_home, getting laid off is a great opportunity for taking a good hard look at your career and where you want to go
20:37:26 <chessguy_work> it's so hard to look for work while you work
20:37:45 * pumpkin_ looks forward to having his dawg package working, so he can release the first yodawg package on hackage
20:37:59 * glguy cries
20:38:00 <wli> I don't know if it's possible to be quite so optimistic about it in this economy.
20:38:08 <rovar> glguy: yea, I see your point, I was trying to use the return value of the function directly
20:38:38 <gueux> oh, in fact I have a new problem... when a user enter a command into the chat room, I'd like the bot to remind who is that user, to send the command to the database server (that's ok), but then I'd like the answer of the server to be sent only to the people who entered the command
20:39:00 <gueux> I'd need the two threads to communicate, no?
20:39:18 <niet> map (\x -> case (pos x) of (Just v) = v  Nothing = 0), how do i do that?
20:40:00 <niet> map (\x -> case (pos x) of (Just v) = v  Nothing = 0), how do i do that?
20:40:47 <niet> I have:  [(Just 7,Nothing),(Just 7,Just 2)] , and I want to sum the left of all tupels and then sum the right side, how?
20:40:47 <chessguy_work> niet, um, i think you just did....?
20:40:53 <niet> it doesnt work
20:40:55 <dmead_home> chessguy_work, yea it's depressing today
20:40:58 <dmead_home> but i'm sure i'll get over it
20:41:22 <dmead_home> i either need a legitimatly interesting job, or to go teach
20:41:32 <chessguy_work> dmead_home, you will, trust me
20:41:44 <Saizan> gueux: yeah, you can use Control.Concurrent.MVar for that
20:41:45 <niet> dmead: what did you do before?
20:41:47 <chessguy_work> a few months down the road you'll look back and be glad
20:41:56 <dmead_home> yeaaa
20:41:58 <dmead_home> this job had no windows
20:42:01 <dmead_home> and stuff air
20:42:03 <chessguy_work> lol
20:42:05 <dmead_home> and boring work
20:42:07 <dmead_home> zzz
20:42:11 <Saizan> gueux: though i'm not sure why you want to constantly trying to read from the database socket
20:42:24 <Saizan> gueux: isn't enough to read from it when you've made a request?
20:42:30 <rovar> ?type Data.ByteString.Char8.toChunks
20:42:31 <lambdabot> Not in scope: `Data.ByteString.Char8.toChunks'
20:42:33 <chessguy_work> i remember being SOOO frustrated the day i had to get all my stuff together and say goodbye to everyone
20:42:48 * monochrom thought "why would you want windows" and then "oh, that kind of windows" :)
20:43:02 <chessguy_work> i was ready to smack the smug little VP that did the deed
20:43:05 <toliko_smoren> hey, what is the easiest way to show a picture using cairo, none of the examples or the documentation are helpfull enough. Thanks
20:43:11 <gueux> Saizan: I'm not sure :-)
20:43:49 <dmead_home> chessguy_work, i can relate
20:43:56 <chessguy_work> niet, i'm not at all sure what you're trying to do. what resulut do you want to get from that list?
20:44:09 <mdmkolbe> Already in the Haskell library? newtype LitShow = LitShow { unLitShow :: String }; instance Show LitShow where show = unLitShow  (I'd rather not reinvent the wheel if I don't have to)
20:44:14 <glguy> rovar, only the lazy bytestrings deal in chunks
20:44:15 <chessguy_work> dmead_home, but now, looking back, i think the joke is on them :)
20:44:22 <dmead_home> chessguy_work, whys that?
20:44:31 <gueux> ok
20:44:33 <rovar> glguy: I need to convert from Bytestring to lazy bytestring
20:44:36 <gueux> you're right
20:44:47 <niet> ah
20:44:48 <niet> sumOn pos xs = sum $ map (\x -> case (pos x) of (Just v) -> v
20:44:48 <niet>                                                 Nothing -> 0)
20:44:48 <niet>                xs
20:44:51 <niet> -> not =
20:44:52 <glguy> rovar, Data.ByteString.Lazy.fromChunks [yourBs]
20:44:54 <chessguy_work> dmead_home, i got a big raise, took a better job that makes me more marketable, and the company that laid me off is in the toilet
20:45:04 <gueux> Saizan: so, I would not need threads?
20:45:06 <dmead_home> chessguy_work, cool cool
20:45:15 <chessguy_work> dmead_home, and very nearly scored a MS job in the process
20:45:27 <Saizan> gueux: in that case no
20:45:31 <dmead_home> chessguy_work, i know somebody who just got a internship at MS
20:45:44 <gueux> I may do two versions :-)
20:45:48 <chessguy_work> well, i wouldn't want just any MS job, but this one sounded pretty cool
20:45:49 <dmead_home> chessguy_work, he's a big web guy so he'll probably work on web services
20:45:52 <chessguy_work> on live search
20:46:12 <gueux> one for turn by turn games and another for real time ones :-)
20:46:21 <chessguy> dmead_home, WCF is pretty cool
20:47:14 <chessguy> though it can be a BIG pain in the butt, too
20:47:30 <dmead_home> wcf?
20:47:58 <chessguy> microsoft's "one communication framework to rule them all"
20:47:59 <gueux> wtf?
20:48:02 <gueux> :-)
20:48:15 <dmead_home> ah
20:48:25 <chessguy> an abstraction for named pipes, remoting, web services, and anything else
20:48:52 <chessguy> message queueing
20:49:40 <pumpkin_> Windows Transaction Framework?
20:49:48 <pumpkin_>  / Foundation?
20:49:52 <zprrnqbsl> \q
20:49:57 <chessguy> heh
20:50:00 <chessguy> on that note....
20:50:07 <chessguy> i'm hitting the sack
20:50:10 <chessguy> 'night all
20:51:01 <gueux> Saizan: but if the database server does not answer immediately, will the other commands (in the chat room) be lost?
20:51:46 <pchiusano_> hello
20:51:56 <pchiusano_> @seen Cale
20:51:57 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 1m 14s ago.
20:52:08 <Saizan> gueux: they will be queued
20:52:16 <gueux> ok
20:52:18 <gueux> great
20:52:19 <Cale> pchiusano_: hello
20:52:28 <pchiusano_> Cale: hi
20:52:40 <pchiusano_> I have another question about differentiating data types
20:52:50 <Saizan> gueux: so the UI is not responsive while you're waiting for data from the database
20:53:14 <pchiusano_> Cale: when I differentiate data Tree a = Leaf a | Branch (Tree a) (Tree a), I get
20:53:20 <Saizan> that's another use of threads.
20:54:06 <gueux> it may be better to send simultaneously several commands to the database server
20:54:09 <pchiusano_> Top | L (Ctx a) (Tree a) | R (Ctx a) (Tree a)
20:54:22 <gueux> no?
20:54:44 <pchiusano_> and that type naturally supports moving the focus around
20:54:56 <tippit> wow, haskell is incredibly succinct and elegant: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1747#a1747 <- 27 line spamfilter
20:55:01 <pchiusano_> but when I differentiate the List data type, I get:
20:55:35 <pchiusano_> List' a = Rest (List a) | L a (List' a)
20:55:36 <Saizan> gueux: yeah, though then it's harder to tell where you should use each result
20:55:56 <pchiusano_> ... which doesn't seem to make it easy to move the focus around
20:55:56 <Saizan> gueux: it depends on how complex you want this to be, maybe you should start simple
20:56:07 <gueux> yes :-)
20:56:11 <gueux> you're right
20:56:25 <tippit> can it be done better ? ^^
20:56:42 <rovar> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1748#a1748
20:57:01 <rovar> I need a bit of guidance, I know basically what needs to happen.. I'm just hoping that there is an easy way.
20:57:05 <Saizan> pchiusano_: in that List' the recursion is usually unrolled to get ([a],[a])
20:57:08 <gueux> with a thread by command? (each will be waiting for its answer)
20:58:00 <Saizan> gueux: that works if you don't care about the order in which commands will be performed
20:58:11 <pchiusano_> Saizan: yes, I know, but that isn't quite the same type
20:58:27 <gueux> you're right again :-)
20:58:27 <Saizan> gueux: or if you synchronize them properly
20:58:45 <gueux> there are two players by game
20:59:22 <Saizan> pchiusano_: assuming the definition is inductive they are isomorphic
20:59:29 <gueux> I must not reverse the turns
20:59:43 <pchiusano_> I am wondering if there is any mechanical way of going from List' to the version that is more efficient if you are shifting the focus
20:59:44 <newsham> rovar: the "maybe" and "fromMaybe" functions are convenient for working with Maybe returns
20:59:55 <Cale> pchiusano_: "moving the focus around easily" isn't really a property of the derivative on its own
21:00:00 <sm> evening all
21:00:15 <newsham> and fmap/ap or <$>/<*> are nice for working for values coming out of monads like IO
21:00:21 <sm> which of the libs on hackage or elsewhere should I be using to make test-driven development easier ?
21:00:32 <gueux> I may remind the number of the current turn
21:00:38 <Cale> pchiusano_: The type you get should still be a list with a hole in it somewhere.
21:00:46 <rovar> newsham, how can I run the necessary stuff of getPC inside the Net monad?
21:00:56 <newsham> I dont know the Net monad.
21:00:57 <monochrom> sm: QuickCheck
21:01:20 <sm> I've heard quickcheck works well for some code and not others
21:01:31 <rovar> oh sorry;  type Net = ReaderT Bot (MS.StateT Stuff IO)
21:01:32 <Saizan> rovar: liftIO, probably
21:01:33 <sm> most of my tests are hunit so far
21:01:43 <pchiusano_> Cale: is there some well defined operation that converts the List' definition to ([a], [a])
21:02:08 <Cale> pchiusano_: yes, and it's natural (doesn't look at the elements of the list) and invertible
21:02:25 <pchiusano_> Cale: ok, what is it?
21:02:44 <newsham> and getPC is?
21:02:44 <Saizan> sm: we use testpack (or a clone) in happstack
21:03:11 <Cale> f (Rest xs) = ([],xs)
21:03:12 <rovar> String -> IO (Maybe PC)
21:03:16 <rovar> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1748#a1748
21:03:17 <sm> thanks Saizan.. you find it helps ?
21:03:32 <Saizan> sm: i'm not the one writing tests :)
21:03:32 <newsham> so yah, as saizan says, use "liftIO"
21:03:33 <tippit> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1747#a1749 <- 30 line haskell spamfilter
21:03:33 <tippit> can I do something like "infer and annotype the types of all functions in a file" in  emacs?
21:03:36 <Cale> f (L x xs) = let (us,vs) = f xs in (x:us,vs)
21:03:36 <rovar> I need to be in IO in order to access BerkeleyDB
21:03:44 <newsham> it will turn your IO (Maybe PC) into a Net (Maybe PC)
21:03:56 <Cale> (to use your type)
21:04:13 <pchiusano_> Cale: I was thinking of something not specific to the type
21:04:39 <Saizan> tippit: C-u C-c C-t annotates the function the cursor is over
21:04:44 <rovar> okay I don't entirely follow the logic of liftIO in this case.
21:04:46 <Saizan> tippit: if you've haskell-mode
21:05:12 <newsham> rovar: you have this big fancy monad that has an IO wrapped in there somewhere.
21:05:15 <Cale> There's also an inverse: f ([],ys) = Rest ys; f (x:xs,ys) = L x (f (xs,ys))
21:05:16 <pchiusano_> Cale: like something that brings the hole in the data structure to the "outside"
21:05:20 <newsham> liftIO lets you use IO actions in that monad.
21:05:23 <newsham> ?type liftIO
21:05:25 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
21:05:37 <newsham> so,  IO a -> Net a   for example
21:05:46 <Cale> pchiusano_: The fact that these functions are inverses of each other is proof that the two types are isomorphic.
21:05:54 <sm> it seems to me there are three "helper" testing libs here: HTF, test-framework, and testpack. And the last is J. Goerzen's, so I reckon that will be good enough for me
21:06:10 <newsham> so:  do { ...some NET stuff...;  x <- liftIO (getPC arg); ... more net stuff ... }
21:06:24 <pchiusano_> Cale: I believe  you ... BUT.. I am asking, how in general would you derive the appropriate isomorphic type?
21:06:25 <wli> Is this instruction emulation?
21:06:53 <Cale> pchiusano_: Well, depends what you consider to be appropriate I suppose.
21:06:57 <pchiusano_> Cale: do you just have to figure it out? or is there some operation  on the type that would do it?
21:08:05 <Cale> I don't think there's a general way.
21:08:08 <newsham> rovar: make sense?
21:08:46 <pchiusano_> Cale: you sure?
21:09:01 <Cale> pchiusano_: Well, maybe for specific cases, like trees.
21:09:29 <pchiusano_> Cale: it seemms like you could formulate something based on the requirement that the hole be out the "outside"
21:09:43 <Cale> But in general, which representation would be good is something that you have to decide yourself :)
21:09:57 <Saizan> pchiusano_: i think that there's a more complex operation based on derivatives that gives you only a one-hole-context, so that Zipper f = (Context f,f), in that case you don't have this problem
21:09:58 <Gracenotes> bremner: oh, sorry, was away for the past hour
21:10:06 <Cale> What does it mean for a hole to be on the 'outside' for things like graph types?
21:10:14 <rovar> newsham: I think so, this  seems to compile:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1748#a1750
21:10:17 <rovar> revision
21:11:13 <pchiusano_> Cale: aren't graph types indistinguishable from tree-like types at the type level?
21:11:20 <Cale> ?
21:11:23 <Cale> I don't think so.
21:11:39 <Cale> They don't arise as fixed points of polynomial functors though.
21:11:52 <Cale> So their derivative is something a little stranger.
21:12:25 <pchiusano_> Cale: data Graph a = Node a [Graph a] | Empty
21:12:46 <Cale> pchiusano_: Huh? That's a tree.
21:13:08 <pchiusano_> Cale: what makes it a tree vs a graph?
21:13:13 <newsham> rovar: i'd recommend writing small functions for things like "(C8.concat . CL8.toChunks)" with meaningful names
21:13:19 <mmorrow> , src ''Tree
21:13:22 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
21:13:25 <Saizan> pchiusano_: http://en.wikibooks.org/wiki/Haskell/Zippers
21:13:27 <rovar> newsham, yea, I'll get to that :)
21:13:28 <mmorrow> , src ''Forest
21:13:30 <lunabot>  type Forest a = [Tree a]
21:13:35 <Cale> Well, here's a decent graph representation... something like data Graph = G (Map Vertex (Set Vertex))
21:13:47 <Cale> (mapping from vertices to sets of neighbours)
21:13:56 <mmorrow> Graph a === [(a, [a])] === Map a (Set a)
21:14:12 <mmorrow> err, that first === i meant to be a :=
21:14:17 <Cale> mmorrow: Well, that's... not *quite* the same
21:14:24 <mmorrow> "eqivalent"
21:14:27 <Cale> [(a,[a])] has an order.
21:14:35 <mmorrow> but it's ignored
21:14:57 <mmorrow> a Map has an ordering too, it's just irrelevant/ignored
21:15:04 <newsham> rovar: btw, your use of the Maybe result to generate another Maybe value can be done using the Maybe monad.
21:15:13 <Cale> Map discards information about the ordering explicitly
21:15:31 <mmorrow> but it retains that in its structure
21:15:40 <mmorrow> (different ordering, yeah)
21:15:44 <Cale> also, you can have multiple entries in the list with the same vertex
21:15:45 <mmorrow> well, not necessarily
21:15:49 <Cale> which you can't do with the Map
21:15:55 <mmorrow> Cale: those are ignored too
21:16:02 <Cale> mmorrow: By what?
21:16:04 <mmorrow> me
21:16:05 <mmorrow> :)
21:16:13 <Cale> mmorrow: You can hide them with a module boundary and a newtype.
21:16:21 <mmorrow> or that, sure
21:16:35 <Cale> (but we're talking about whether types are formally isomorphic...)
21:16:47 <pchiusano_> Cale: given data Graph a = Node a [Graph a] | Empty, I can have a loop graph as let f = [Node a [f]] in f
21:17:00 <Cale> pchiusano_: no, that's just an infinite tree ;)
21:17:02 <mmorrow> anyways...
21:17:11 <newsham> case mx of (Just x) -> Just (f x); Nothing -> Nothing    can be written    f `fmap` mx
21:17:16 <newsham> or  f <$> mx
21:17:28 <pchiusano_> Cale: you say it's an infinite tree, I say it's a loop! :)
21:17:48 <mmorrow> pchiusano: but you can't mutate that graph. in [(a,[a])] or Map a (Set a) the links are explicit and at the haskell level
21:17:48 <pchiusano_> aren't we just interpreting the same data in different ways
21:17:49 <Gracenotes> (>$_$)>
21:17:53 <Cale> pchiusano_: That's a bad representation for graphs, because there's no way to tell that it's a loop.
21:17:53 <Gracenotes> <($_$<)
21:17:58 <mmorrow> rather than being at the rts level
21:18:06 <pchiusano_> Cale: I agree it is a bad representation
21:18:24 <pchiusano_> I am just saying, that type can certainly represent graphs
21:18:24 <Cale> (and it's also not equivalent to my graph type :)
21:18:24 <mmorrow> , levels $ fix (\me -> Node () [me, me])
21:18:26 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
21:18:53 <Cale> Or, for a simpler example, something like Set a
21:18:53 <mmorrow> , [(0,[0,0])]
21:18:54 <lunabot>  [(0,[0,0])]
21:19:07 <Gracenotes> ?type levels
21:19:08 <lambdabot> forall a. Tree a -> [[a]]
21:19:14 <dmead_home> guys is there not an ML channel?
21:19:24 <Cale> actually, Set is its own derivative :)
21:19:32 <Gracenotes> #sml
21:19:33 <toliko_smoren> hey can anyone give me a quick example of showing pictures using cairo?
21:19:39 <rovar> newsham, glguy: thanks for your help
21:19:43 <Gracenotes> ^ ML channel, #sml
21:19:45 <mmorrow> , levels (Node 0 [Node 1 [], Node 2 []]) {- Gracenotes -}
21:19:46 <lunabot>  [[0],[1,2]]
21:19:50 <newsham> np
21:20:28 <pchiusano_> data Graph a = Node a [Graph a] | Empty can be a graph if there is appropriate sharing, right
21:20:31 <Gracenotes> mmorrow: ah, I see.
21:20:47 <Gracenotes> , levels (Node 0 [])
21:20:49 <lunabot>  [[0]]
21:20:57 <mmorrow> pchiusano: by that same token you can say that every haskell piece of data is a graph though
21:21:04 <Cale> pchiusano_: I think when thinking about this stuff it's best to ignore sharing altogether.
21:21:08 <Gracenotes> , levels (Node 0 [Node 1 [Node 2 [Node 3 []]]])
21:21:09 <lunabot>  [[0],[1],[2],[3]]
21:21:17 <sm> all: is there any reason I shouldn't split up hledger into multiple orthogonal hledger-* packages on hackage ?
21:21:21 <pchiusano_> ok
21:21:21 <mmorrow> , let xs = 0 : xs in xs
21:21:22 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:21:25 <newsham> pch: thats how you'd usually represent a graph in imperative languages
21:21:27 <mmorrow> , fix (0:)
21:21:28 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:21:37 <newsham> s/usually/often/
21:22:04 <mmorrow> yeah, but since you can't mutate it doesn't work in haskell
21:22:10 <mmorrow> otoh you could use Refs
21:22:28 <Gracenotes> pssh, why not use Ptrs? :P
21:22:43 <mmorrow> == a ref essentially
21:23:02 <Gracenotes> SEGFAULT TEIM
21:23:10 <pchiusano_> Cale: ok, well I still think this operation of bringing the hole to the outside might be perfectly well defined for all derivative types... I am going to think about it some more and get back to you
21:23:37 <Cale> pchiusano_: There might be a way for all fixed points of polynomial functors
21:23:48 <Cale> But I think that's the best you can do.
21:23:57 <Cale> (that is, all algebraic data types)
21:24:08 <pchiusano_> Cale: what is a polynomial functor?
21:24:17 <pchiusano_> you mean just using union and product?
21:24:20 <Cale> yeah
21:24:24 <Cale> and then fixed points
21:24:36 <Cale> So things like List, Tree, etc.
21:24:38 <pchiusano_> "and then fixed points"?
21:24:56 <Cale> List a = mu X. 1 + a * X
21:24:57 <mmorrow> data Foo a = Foo a (Foo a)
21:25:05 <pkhuong> ok, so I'm building the image for this year's CS Games (any canadian undergrad around?). I asked apt-get to install pretty much everything that looked ghc-related. What else should I put in there, esp for docs, considering they won't have net access?
21:26:16 <pchiusano_> Cale: basically the type may occur somewhere in the polynomial
21:26:35 <Cale> pchiusano_: Yeah...
21:28:19 <pchiusano_> Cale: ok, thanks, this has been helpful :)
21:33:34 <niet> if I want to do a binding to a C or C++ lib , is that possible(thinking libsvm)?
21:34:48 <Saizan_> C is quite easy using the Foreign Function Interface aka FFI
21:35:03 <Saizan_> @where FFI
21:35:03 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:35:12 <monochrom> convert c++ to c first.
21:35:38 <Gracenotes> does Haskell even have a C++ interface to speak of?
21:35:46 <Gracenotes> Difficult to use however it may be?
21:36:01 <pkhuong> Gracenotes: pretty much only C++ has a C++ interface.
21:36:18 <Gracenotes> heh
21:40:45 <brool> What's the Haskell way to do something like a map function that carries around state?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1754 would do it but I'm sure there's a better way.
21:41:07 <toliko_smoren> can anyone help me write a simple function which shows a picture using cairo?
21:42:15 <niet> how do I try catch in haskell? maybe doent work here:
21:42:15 <niet> *** Exception: a: openFile: does not exist (No such file or directory)
21:42:18 <blackh> brool: You can scan* or use mapM with a State monad.
21:42:51 <travisbrady> how does one read a Double from a ByteString?
21:43:29 <brool> blackh: I'll look into that, thanks
21:44:04 <newsham> do you want to parse an ascii string as a double or do you want to take some bytes and turn them into a double?
21:45:09 <Gracenotes> > evalState (mapM (\a -> do { j <- get; put (j+a); return (j+a) }) [1,2,3,4,5]) 0 -- brool
21:45:10 <lambdabot>   [1,3,6,10,15]
21:45:17 <blackh> brool: Here's a nice example for you:
21:45:20 <blackh> > flip runState 0 $ forM [0..10] $ do {\idx -> do modify (2+); return $ idx*100}
21:45:22 <lambdabot>   ([0,100,200,300,400,500,600,700,800,900,1000],22)
21:45:30 <Gracenotes> two examples :D
21:45:45 <Gracenotes> the first was the triangle numbers.
21:45:59 <BMeph> brool: You may also want to check out the various "mapAccum" functions. :)
21:46:03 <Gracenotes> > evalState (mapM (\a -> do { j <- get; put (j+a); return (j+a) }) [1..]) 0
21:46:04 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
21:46:20 <Gracenotes> note that infinite lists will only work if you use the lazy state monad
21:46:42 <Gracenotes> I think, anyway. It's the default either way.
21:46:51 <brool> tyvm, all!  that helps immensely
21:47:11 <Gracenotes> @type mapAccum
21:47:12 <lambdabot> Not in scope: `mapAccum'
21:47:25 <Gracenotes> probably L and R ..?
21:47:29 <Gracenotes> @hoogle mapAccum
21:47:29 <lambdabot> Data.IntMap mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
21:47:29 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
21:47:29 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:47:39 <blackh> > flip runState 0 $ forM [0..10] $ \idx -> do {modify (2+); return $ idx*100}
21:47:40 <Gracenotes> @hoogle mapAccumL
21:47:40 <lambdabot>   ([0,100,200,300,400,500,600,700,800,900,1000],22)
21:47:40 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:47:40 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:47:40 <lambdabot> Data.ByteString.Char8 mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
21:47:46 <blackh> That's what I *meant* to say.
21:48:50 <kohwj> howdy
21:50:13 <redditbot> Neil Mitchell's Haskell Blog: Hoogle package search
21:52:31 <roconnor> anyone know which is Conor's paper that explains which colours go with what things in dependent type theory?
22:03:28 <lifflander> Hey, everyone.
22:03:42 <lifflander> I wrote a program that uses a REPL type interface and it works fine in GHCI.
22:04:25 <lifflander> When compiled the prompt does not print until the command is entered. I assume that the buffer is not getting flushed or putStr is lazy?
22:05:25 <lifflander> Anyone run into this before?
22:07:04 <mmorrow> lifflander: try hFlush
22:07:11 <mmorrow> @type hFlush
22:07:12 <lambdabot> Not in scope: `hFlush'
22:07:21 <mmorrow> :: Handle -> IO ()
22:07:30 <lifflander> Okay, is the handle stdout?
22:07:36 <mmorrow> yes
22:08:14 <mmorrow> there's also hSetBuffering, but i'm not positive that NoBuffering actually does what it says
22:11:58 <sm> how do I specify imports when using ghc -e ?
22:12:08 <newsham> so now that MSFT has cut the entire flight simulator crew, is there a market for someone to make an awesome haskell fsim? :)
22:13:06 <mmorrow> sm: i'm not sure, but just fully qualifying every ident works
22:13:20 <erikc> newsham: nope
22:13:33 <sm> mmorrow: wow, you're right, thanks
22:14:04 <mmorrow> sm: it gets pretty annoying after a while though... :)
22:14:10 <sm> yes
22:14:21 <seliopou> question: how maintains hug, if it's even maintained at all?
22:14:25 <seliopou> who, rather
22:15:32 <mmorrow> oh wow, i remember playing flight simulator on DOS, i think it's the first computer game i ever played actually (not counting nintendo)
22:15:43 <newsham> i used to have it for my c64
22:16:15 <mmorrow> landing at oakland was a bitch! ;)
22:17:59 <mmorrow> i have no idea why i remember that, or even why i was trying to land there
22:18:54 <toliko_smoren> can anyone tell me whats wrong with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1756#a1756
22:19:07 <toliko_smoren> as in why does it now show a picture
22:23:17 * wli tries to find real dirt on exponentially-weighted moving averages.
22:24:16 <newsham> like  avg[n+1] = 0.6 * x[n+1] + 0.4 * avg[n]   ?
22:24:38 <wli> Well, more sophisticated alternatives to that.
22:25:21 <Adamant> mmorrow: were you taking hostile fire? :p
22:27:11 <monochrom> I played a flight simulator on DOS too. Apple DOS. Apple ][.
22:28:15 <newsham> apple ][ was the original FS, no?
22:28:28 <monochrom> I guess.
22:29:19 <newsham> http://www.amazon.com/Applied-Concepts-Microcomputer-Graphics-Artwick/dp/0130393223
22:29:34 <monochrom> My second one was F-19 on PC. My third was F-117 on PC. Do you see a trend? I like to sneak in.
22:31:41 <monochrom> The very word "microcomputer" is nostalgic.
22:32:21 <niet> how can I get the current dir?
22:33:25 <monochrom> Does System.Directory help?
22:33:39 <newsham> System.Directory.getCurrentDirectory
22:34:14 <monochrom> We now don't say "micro", "mini", "main frame". We say "gaming PC" and "server", and both are fearsome.
22:34:18 <lifflander> The flush worked, thanks.
22:34:56 <newsham> laptop, desktop, server, mediacenter
22:35:14 <newsham> some people still say mainframe and pay lots of money to say it :)
22:35:25 <newsham> http://www-03.ibm.com/systems/z/
22:35:59 <lifflander> monochrom: What is your background in computers/programming?
22:36:35 <monochrom> It's a long story. I guess it suffices to say I started with BASIC.
22:36:52 <lifflander> Are you a student?
22:37:28 <monochrom> Yes.
22:37:44 <lifflander> Where do you go to school?
22:37:52 <monochrom> Toronto
22:38:38 <lifflander> Great, I'm a student in Washington State right now finishing up by BS in CS.
22:38:56 <newsham> mono: all the cool commodore 64 people were from toronto :)
22:39:11 <newsham> what were you doing w/ apple?
22:39:43 <monochrom> I was in Hong Kong. Pirated Apple hardware and software were cheap.
22:39:52 <newsham> ahh
22:40:13 <dons> "I have been reading the book “Haskell for real programmers” and am presently on
22:40:16 <dons> chapter 03.
22:40:18 <dons> "
22:40:25 <dons> anyone know what book he's referring to? bad translation of RWH?
22:40:31 * p_l prefers Atari 65XE/130/800 to C64 :P
22:40:32 <monochrom> As it happens, my highschool had Commodore 64 and I tried it for a few hours too. But I spent more time on Apple ][.
22:40:40 <niet> how can I pass a command to a haskellprogram at the command line?
22:40:56 <monochrom> No, not Commodore 64. There was some PET thing wasn't there? It was likely PET rather.
22:41:00 <dons> import System.Environment
22:41:10 <dons> main = do fs <- getArgs ; print f
22:41:12 <dons> s
22:41:29 <mmorrow> Adamant: heh, i think that must have been it.
22:41:51 <newsham> yes, PET and CBM machines before vic20, c64, c128.
22:42:16 <Sekaino> dons, Good work on RWH by the way.  I've been reading it off and on and it's quite helpful.
22:42:28 <newsham> yes, RWH is most excellent.
22:42:32 <monochrom> My highschool later got Atari 800 and that was used when I took the official programming classes.
22:42:40 <newsham> sorely need, glad its arived
22:42:46 <dons> thanks guys
22:42:58 <p_l> atari 800 was a sweet machine, grossly underrated by many
22:43:33 <newsham> from what i know about it seemed fairly decent, though i didnt care for the color aliasing stuff that atari, apple and pc's did.
22:44:33 <p_l> newsham: it was very extensible despite not looking like that. And had installable drivers in its OS xD
22:45:18 <newsham> i kinda had an atari.. i bought an amiga.  made by the same engineers.
22:45:44 <p_l> newsham: I'm not sure if it was made by the same people...
22:45:58 <monochrom> I will scare you by telling you that I still have cassette tapes storing software! I haven't thrown them away yet.
22:47:00 <p_l> monochrom: and I have a book which includes information about how to build a papertape IO system for your computer (which you build from transistors!)
22:47:04 <newsham> p_l: http://en.wikipedia.org/wiki/Amiga_Corporation
22:47:33 <monochrom> Here is why if there is time travel to the past I wouldn't do it. There was no Haskell back then. There was no computer capable of running Haskell either. What a dark age.
22:47:33 <newsham> mono: i wish i did.  i threw out my old stuff.  oldest stuff I have now are disk images from my amiga machine.
22:47:52 <p_l> newsham: Right, my error :)
22:47:59 <newsham> mono: you could still buy a lisp machine. ;-)
22:48:04 <p_l> monochrom: PDP-10?
22:48:21 <monochrom> lisp just doesn't cut it.
22:48:28 <p_l> also, you could program a Haskell for Symbolics machine
22:48:38 <newsham> you could write a small haskell in lisp on your symbolics
22:48:51 <p_l> newsham: pretty big haskell too :P
22:49:23 <monochrom> My cassette tapes are for Casio FX-702P, Casio FX-602P, and Sharp PC-1500.
22:49:25 <p_l> lispm actually supported C and Fortran too
22:49:31 <quicksilver> a haskell interpreter would not be a problem even on rather old hardware
22:49:35 <monochrom> 702P and 1500 did BASIC.
22:49:42 <quicksilver> a haskell compiler in the style of GHC would be pretty unfeasible.
22:49:54 <quicksilver> GHC's compile times are just far too long.
22:50:03 * glguy is buying 2 more gigs of ram to compile thigns like ghc without going into swap
22:50:08 <Axman6> unless you were überl33t
22:50:10 <glguy> how much did older computers have??
22:50:12 <glguy> ;)
22:50:19 <quicksilver> then again, there are other ways to write haskell compilers :)
22:50:19 <monochrom> 4KB?
22:50:22 <p_l> glguy: Depends on the machine in question
22:50:33 <newsham> my laptop isnt really that much faster than a cray xmp.
22:50:36 <monochrom> Apple ][e had 64KB.
22:50:39 <newsham> you could get a cray xmp in the mid 80's :)
22:51:04 * Axman6 would prefer to have the laptop on his lap though
22:51:26 * p_l would like a system that would have clustering like VMS
22:51:47 <newsham> amusing, I'm just about to boot vms. :)
22:52:06 <p_l> newsham: what hw?
22:52:13 <newsham> simh on my laptop
22:52:54 * p_l got VMS 6.1 on Alpha. Can't upgrade cause he can't find memory for it, and 8.3 won't start without 128MB for installer
22:53:12 <p_l> mind you, it works quite well with 32MB of RAM
22:53:56 <Axman6> alphas are the ones that had hot swappable CPU's right?
22:54:19 <p_l> Axman6: Not only Alpha has hot-swap cpus
22:54:34 <Axman6> ok, one of the ones* :)
22:54:35 <p_l> but AFAIK multiprocessor vaxes were rare
22:55:04 <p_l> but VMS had quite powerful clustering support
22:55:51 <Axman6> VMS sounds like a really awesome system. there's a few on the web you can just log into and play around with too
22:57:26 <p_l> Axman6: And if you can get your hand on install media... :3
22:57:27 <monochrom> I am most impressed by VMS's versioning file system.
22:57:55 <p_l> monochrom: nah, versioning was easy. Everyone except Unix and micros did that
22:58:23 <monochrom> Yes.
22:58:31 <Axman6> obviously it's a flawed feature then
22:58:32 <Axman6> >_>
22:59:02 <p_l> Axman6: Actually, later Unices that aren't forced to fit in 32k of ram also have similar features :)
22:59:10 <monochrom> VMS is most suitable for education because "my dog ate my file" would not work. :)
22:59:46 <p_l> and If only HP allowed anonymous downloads...
23:01:34 <p_l> (although if you whine long enough, sometimes you get info on how to access client-only FTP with bootable images to install from)
23:01:38 <vha4> HP does allow anonymous downloads
23:02:19 <p_l> vha4: Where? Hobbyist Program actually reports that despite asking about that, they are never allowed
23:02:40 <vha4> er, sorry, misread, you're talking about install media
23:02:52 <p_l> vha4: You can get access to some of the kits, true
23:03:12 <p_l> but media are client-only
23:03:20 <vha4> i'm running 8.3 on ia64
23:03:26 <vha4> just have to know the right people i suppose
23:04:27 <niet> how do I try-catch in Haskell? or what is the equivalent of catcing Exception?
23:04:36 <niet> like when your ed a file and the fiel doesnt exist
23:04:39 <Axman6> :t try
23:04:40 <lambdabot> Not in scope: `try'
23:04:42 <p_l> vha4: You own an ia64?
23:04:43 <Axman6> :t catch
23:04:44 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
23:04:45 <Axman6> lame
23:05:01 <vha4> friend of mine yes but i do the sysadmin crap on it
23:05:26 <Axman6> niet: try is probably what you want
23:05:34 <Axman6> :t Control.Exception.try
23:05:35 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
23:05:43 <vha4> i didn't want to pay shipping for it
23:05:52 <p_l> I hope Linux finally gets some of the clustering support OSes like VMS have
23:06:04 <vha4> i don't
23:06:15 <p_l> Right now only DragonFlyBSD seems to have it in goals
23:06:18 <vha4> it'll probably be convoluted and will barely work for the first few years
23:06:40 <p_l> vha4: *nix already is convoluted and contradictory
23:07:08 <p_l> Mosix worked quite well, from what I heard
23:07:34 <newsham> "Welcome to OpenVMS (TM) VAX Operating System, Version V7.3" ;-)
23:07:38 <vha4> the thing is, everyone wants various aspects of VMS put into different operating systems
23:07:48 <vha4> it ends up that they just want VMS
23:08:01 <vha4> newsham: i ran that too on a vax
23:08:34 <p_l> newsham: You've got install media? :)
23:08:46 <newsham> p_l: yah, i signed up for the hobbyist program
23:10:31 <niet> is it easier to write a compiler for functional languages? or should isay, an optimizing compiler?
23:11:44 <niet> isit correct to say that imperative languages gives the programmer more pwoer to write faster programs on a lowr level but functional languages can be optimized much more ona higher level? so with small memory and processors imperative can be faster but as memory and processors become abundant the pros of functional wins?
23:11:48 <monochrom> very hard to say
23:12:00 <vha4> what are these, homework questions?
23:16:00 <p_l> vha4: My dream OS is combination of VMS, Plan 9/B and L4 :)
23:16:45 <niet> actually haskell seems to give good error messages it self so no need to try catch
23:17:40 <vha4> VMS is quite nice, it doesn't get in the way of me trying to get anything done
23:21:30 <niet> is there Infinity?
23:25:10 <niet> if i call a pure method sveeral times it will be optimzied away right?
23:25:13 <niet> if i do:
23:25:26 <dobblego> no
23:25:37 <niet> if x > veryExpensiveCompuation then x else eryExpensiveCompuation
23:25:42 <niet> is that as fast as:
23:26:02 <niet> let res = veryExpensiveCompuation; if x > res then x else res
23:26:03 <niet> ?
23:26:37 <daf> I *think* so
23:26:46 <daf> you can look at GHC's core to be sure
23:27:35 <niet> dobblego seems to disagree
23:27:55 <newsham> p_l: no offense, but that sounds like it would be the duck-billed platypus of systems.
23:28:05 <Cale> niet: no, it's not
23:28:07 <newsham> not entirely concordant systems :)
23:28:17 <p_l> newsham: Don't make platypus angry :)
23:28:19 <Cale> niet: CSE isn't done automatically
23:28:19 <BMeph> niet: s/;/in/ is more "idiomatic".
23:28:45 <Cale> niet: While it's technically a valid transformation to do, it can make space performance worse.
23:29:13 <w0lter_> I s there anyone who read the book "  OReilly.Real.World.Haskell" ?
23:29:37 <Cale> niet: So only a trivial amount of CSE is done... I think perhaps if you have a nested case with the same expression, then they'll be commoned -- it was something unusual like that.
23:30:14 <Cale> w0lter_: Sure, it's available online for free if you'd like to check it out :)
23:30:26 <Cale> http://book.realworldhaskell.org/read/
23:31:42 <p_l> newsham: Basically from VMS, i would take fully asynchronous API, clustering and resource sharing, L4 would form kernel, Plan 9/Plan B -> everything is a filesystem, automatic search of resources, most of the API (with I/O being async.), TOMOYO Linux -> Security layer :)
23:33:10 <dreixel> does anyone know of any tool to perform source lines of code analysis for Haskell code? It would be particularly useful if it counted  logical LoC...
23:34:10 <w0lter_> Cale: thanks. I am reading it. but I wonder -- file: ch04/IntParse.hs which turn decimal string into Integer.
23:34:26 <niet> Cale: ok I thought such things happened automatically(not that it matters here normally you'd use let anyway), I thought that was an optimization that was easy to do because of referential transparency
23:34:51 <Cale> niet: It's easy to do, but not always a good thing to do, and determining if it will be good is very hard.
23:35:19 <Cale> w0lter_: okay
23:36:18 <niet> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1757#a1757 <- comment on my haskell-skills plz, it a 35 line spamfilter
23:36:41 <newsham> and from the duck a bill and webbed feet, and from mammals mammary glands
23:37:07 <monochrom> CSE + laziness is not as likely to win as CSE + eagerness.
23:38:30 <p_l> newsham: Don't forget very powerful poison and being overall dangerous :)
23:39:04 <Cale> (\x -> case (pos x) of (Just v) -> v; Nothing -> 0) = maybe 0 id . pos = fromMaybe 0 . pos
23:39:46 <Cale> Or, another way to write that... sumOn pos xs = sum [v | Just v <- map pos xs]
23:40:01 <Cale> Just some ideas there :)
23:40:15 <newsham> filterMaybes
23:40:36 <Cale> Ah, there's that too... or catMaybes?
23:40:38 <Cale> :t catMaybes
23:40:39 <lambdabot> forall a. [Maybe a] -> [a]
23:40:42 <newsham> err, yes
23:41:35 <niet> Cale: why is it not good? because it increases memory-use because of caching all function-calls?
23:41:35 <newsham> ?type mapMaybe
23:41:36 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
23:41:56 <Cale> niet: Well, roughly. It's not quite as bad as that would be.
23:41:56 <w0lter_> Cale: the max number the program asInt can trasverse is quite limited. only 9 digit.
23:42:01 <niet> what does cse stand for?
23:42:08 <Cale> niet: Common subexpression elimination
23:42:23 <Cale> (the transformation you're talking about)
23:42:51 <Cale> w0lter_: Well, Int is not very large.
23:43:03 <niet> ok
23:43:14 <Cale> w0lter_: If you replace Int with Integer, then it should work with unbounded integers.
23:43:14 <w0lter_> Cale: Is that limited by haskell? for exampl "123456789" -> 123456789 but "123456789012" is “baba baba"
23:43:26 <Cale> w0lter_: ?
23:43:54 <Cale> w0lter_: The 'Int' type refers to a machine integer, which is either 32 or 64 bits depending on your computer.
23:44:19 <Cale> w0lter_: Integer is an arbitrary size integer which is only bounded by the amount of memory you have.
23:45:23 <w0lter_> "123456789012"  will be -1097262572.    I see
23:45:27 <Cale> w0lter_: Using Int is in general not all that good a policy if you ask me -- it's fast, but quickly becomes incorrect if numbers get too large.
23:45:49 <w0lter_> Cale: which type ?
23:45:56 <w0lter_> is better
23:46:02 <Cale> > 123456789012 `mod` (2^32)
23:46:03 <lambdabot>   3197704724
23:46:12 <Cale> > (-1097262572) `mod` (2^32)
23:46:13 <lambdabot>   3197704724
23:46:31 <Cale> w0lter_: Integer
23:47:00 <Cale> > 2^1024 :: Int
23:47:02 <lambdabot>   0
23:47:05 <Cale> > 2^1024 :: Integer
23:47:07 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
23:47:10 <w0lter_> understand
23:47:22 <w0lter_> thanks, :)
23:48:35 <w0lter_> I was thought Int is the same to Integer
23:48:41 <Axman6> no
23:48:48 <Cale> No, they're very different :)
23:48:57 <Axman6> > maxBound :: Int
23:48:57 <w0lter_> :)
23:48:58 <lambdabot>   9223372036854775807
23:48:59 <Axman6> > maxBound :: Integer
23:49:00 <lambdabot>       No instance for (Bounded Integer)
23:49:00 <lambdabot>        arising from a use of `maxBoun...
23:49:49 <Axman6> > 2 ^65 :: Int
23:49:50 <lambdabot>   0
23:49:53 <Axman6> > 2 ^65 :: Integer
23:49:54 <lambdabot>   36893488147419103232
23:50:59 <w0lter_> import Data.Char (digitToInt)
23:51:01 <w0lter_> asInt :: String -> Integer
23:51:02 <w0lter_> asInt [] = 0
23:51:04 <w0lter_> asInt xs = loop 0 xs
23:51:05 <w0lter_> loop :: Integer -> String -> Integer
23:51:07 <w0lter_> loop acc [] = acc
23:51:09 <w0lter_> loop acc (x:xs) = let acc' = acc * 10 + digitToInt x
23:51:10 <w0lter_>                    in loop acc' xs
23:51:17 <w0lter_> Prelude> :load myIntParse.hs
23:51:18 <w0lter_> [1 of 1] Compiling Main             ( myIntParse.hs, interpreted )
23:51:20 <w0lter_> myIntParse.hs:9:40:
23:51:21 <w0lter_>     Couldn't match expected type `Integer' against inferred type `Int'
23:51:23 <w0lter_>     In the second argument of `(+)', namely `digitToInt x'
23:51:24 <w0lter_>     In the expression: acc * 10 + digitToInt x
23:51:26 <w0lter_>     In the definition of `acc'': acc' = acc * 10 + digitToInt x
23:51:28 <w0lter_> Failed, modules loaded: none.
23:52:08 <w0lter_> digitToInt need to be digitToInteger?
23:52:09 <Cale> w0lter_: You should use a pastebin like hpaste...
23:52:25 <Cale> http://hpaste.org/new
23:52:28 <Cale> er
23:52:36 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/new
23:52:37 <Cale> rather :)
23:52:39 <w0lter_> yes
23:53:06 <Cale> Right, digitToInt produces an Int, so you'll have to convert it.
23:53:24 <Cale> You can use fromIntegral to convert any integer-like type to any numeric type.
23:53:33 <niet> sumOn pos xs = sum [v | Just v <- map pos xs] ;; thta is neat, but how does it filter out the Nothings?
23:53:54 <w0lter_> Cale: understand, thanks and thank for the http://hpaste.org/fastcgi/hpaste.fcgi/new
23:53:56 <Cale> niet: That desugars into a concatMap with a case expression.
23:55:05 <Cale> Something like   sum (concatMap (\u -> case u of Just v -> [v]; _ -> []) (map pos xs))
23:56:32 <niet> (\x -> case (pos x) of (Just v) -> v; Nothing -> 0) = maybe 0 id . pos = fromMaybe 0 . pos that doesnt work for me
23:57:23 <Cale> niet: hm?
23:57:35 <Cale> What do you mean "doesn't work"?
23:58:34 <niet> that i dont get how to use it anduse it straught off doesnt work
23:58:57 <BMeph> niet: Those "="s are signs that each of those three functions are equivalent. They all do the same thing. :)
