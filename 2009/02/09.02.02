00:00:10 <_Jordan_> so I made a typeclass Item, and a couple instances like Weapon etc.
00:00:34 <ski_> do you need different `Item' types ?
00:00:35 <wli> The ontologies for such things can get tricky.
00:01:17 <Olathe> data Item = Weapon WeaponData | ... would allow [Item]s
00:01:40 <_Jordan_> ski_: I... think so? I would in OO languages which is all I know. This is my first Haskell attempt
00:01:41 * wli would suggest more of a relational model.
00:02:00 <Olathe> If you have a different type for each item, it makes it hard to have an [Item]
00:02:35 <Olathe> I'm not sure how important that is.
00:03:14 <_Jordan_> I guess I could just have separate data structures for each type of item
00:03:28 <ski_> (`[SomeItem]' is still possible)
00:03:30 <_Jordan_> I guess it's just not how I'm used to doing it. Sorry for bugging you guys
00:03:52 <ski_> _Jordan_ : don't be sorry. that's one of the main points of the channel
00:04:21 <Olathe> ski_: Ahh, yes.
00:04:41 <ski_> _Jordan_ : i'm not sure whether have one, or several item types would be best .. just wondered why
00:04:43 <somnolence> how can I cast a double into an Integer
00:04:49 <somnolence> fromDouble doesn't exist? :(
00:04:54 <Olathe> round
00:04:56 <glguy> :t round
00:04:57 <pumpkinbot> forall a b. (Integral b, RealFrac a) => a -> b
00:04:58 <somnolence> right
00:04:58 <somnolence> ><
00:04:59 <somnolence> zz
00:05:01 <somnolence> nevermind me
00:05:18 <glguy> o.O
00:05:19 <ski_> .. argh
00:05:33 <wli> [Item 99 `IsA` Weapon, Item 99 `HasA` Name, Item 99 `IsCalled` "Sword"]
00:06:11 <_Jordan_> ski_: Yeah, I really don't know yet either. My idea was just, "hey, each room can have some items lying around. An item is defined as a weapon or armor or..."
00:06:22 <wli> One may wish to index the relations more efficiently.
00:06:22 <_Jordan_> I think I'm still too noun-oriented :)
00:07:35 <ski_> *one* possible rendering of "An item is defined as a weapon or armor or..." is `data Item = Weapon ... | Armor ... | ...'
00:07:57 <glguy> data Item = Item { itemType :: ItemType , itemValue :: Int , itemName :: String, ... }
00:08:13 <glguy> data ItemType = Weapon | Armor | Potion ...
00:08:48 * ski_ wondered yesterday whether GADT-records would make sense
00:09:16 <ski_> .. and i think they could do .. but i'm not sure how useful they'd be
00:09:20 <_Jordan_> yeah, that works fine. I'm not sure why I wanted to get typeclasses involved :)
00:09:31 <glguy> !tell somnolence feel free to stick around after asking questions!
00:09:38 <glguy> @tell somnolence feel free to stick around after asking questions!
00:09:38 <pumpkinbot> Consider it noted.
00:09:48 <glguy> I've been using a different bot more often, lately
00:10:22 <glguy> _Jordan_, have you done much Java or C# programming?
00:10:37 <_Jordan_> glguy: yeah
00:10:54 <glguy> and you are used to programming to interfaces?
00:11:11 <_Jordan_> exactly. I want to learn Haskell because it hurts my poor small brain
00:11:54 <glguy> _Jordan_, I was working a C# job before I switched over
00:12:06 <glguy> I wanted to use typeclasses like a drop-in interface replacement
00:12:27 <_Jordan_> I guess it seems like they do resemble each other
00:13:05 <ski_>   codata Foo :: * -> * where Bar :: Foo Bool -> (Bool,Foo Int); Baz :: Foo Int -> String; Quux :: Foo a -> (a,a)
00:14:24 <zenhacker> byorgey: can I write something like this: data (IntLit a) => Literal a = NewLiteral a
00:14:52 <ski_> zenhacker : yes, but you probably don't want to
00:14:54 <byorgey> zenhacker: no, not unless IntLit is a type class
00:15:05 <zenhacker> aha, i thought so
00:15:08 <byorgey> even if it was, that probably wouldn't do what you intended =)
00:15:19 <zenhacker> :)
00:15:26 <zenhacker> byorgey: was just wondering :)
00:15:31 <byorgey> sure =)
00:15:54 <glguy> if you want constructors to carry along their typeclass constraints, you'll need to use GADT syntax
00:17:01 <zenhacker> byorgey: i also suppose there is no way to overload type constructors so I can keep the same name, but with different parameters
00:17:17 <zenhacker> byorgey: data constructors
00:17:23 <byorgey> zenhacker: you suppose correctly =)
00:17:56 <zenhacker> byorgey: :)
00:25:27 <Olathe> Is there a better way of doing this: \(x:xs) -> foldl' (\ac el -> ac >> put el) (put x) xs
00:26:50 <ski_> which monad ?
00:26:55 <Olathe> Binary.Put
00:27:04 <Olathe> Data.Binary.Put
00:27:28 <ski_> is there a point to forcing actions in that monad ?
00:28:07 <Olathe> I'm trying to put each item without putting a list, since I'm writing a PNG chunk.
00:28:21 <pumpkin> \o/
00:28:29 <dmwit> Olathe: Is that just mapM?
00:28:34 <Olathe> I'm not sure.
00:28:35 <dmwit> mapM_
00:28:35 <ski_> i'm not sure what "put each item without putting a list" means
00:28:38 <Olathe> @src mapM
00:28:38 <pumpkinbot> mapM f as = sequence (map f as)
00:28:41 <Olathe> @src mapM_
00:28:41 <pumpkinbot> mapM_ f as = sequence_ (map f as)
00:28:52 <dmwit> ?src sequence_
00:28:52 <pumpkinbot> sequence_ ms = foldr (>>) (return ()) ms
00:29:06 <Olathe> Well, if you do put (x:xs), it length encodes it.
00:29:09 <slava> I'm curious what a purely-functional word wrapping algorithm looks like
00:29:11 <ski_> Olathe asked for a function that fails on the empty list
00:29:21 <Olathe> If it length encodes it, that's bad.
00:29:30 <slava> if its possible to implement it with standard higher-order functions on lists
00:29:30 <dmwit> slava: I have one hanging around here somewhere, give me half a tick.
00:29:48 <Olathe> @src sequence
00:29:48 <pumpkinbot> sequence []     = return []
00:29:48 <pumpkinbot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:29:48 <pumpkinbot> --OR
00:29:48 <pumpkinbot> sequence xs = foldr (liftM2 (:)) (return []) xs
00:30:03 <Olathe> Hmm...
00:30:06 <Olathe> @type mapM
00:30:08 <pumpkinbot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:30:37 <dmwit> oy, hpaste is down
00:30:58 <ski_> @where hpaste2
00:30:58 <pumpkinbot> I know nothing about hpaste2.
00:30:59 <jeffz`> hpaste has been dead for a week or so I think
00:31:04 <ski_> pumpkinbot : liar
00:31:16 <Olathe> @type mapM put
00:31:17 <dmwit> slava: http://rafb.net/p/51tkLW25.html
00:31:17 <pumpkinbot> forall a (m :: * -> *). (MonadState a m) => [a] -> m [()]
00:31:17 <pumpkin> :o
00:31:21 <ski_> @where+ hpaste2 http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
00:31:21 <pumpkinbot> Good to know.
00:31:28 <Olathe> @type put
00:31:29 <pumpkinbot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
00:31:35 <dmwit> slava: I wrote that a while ago, so it might not be pretty.
00:31:36 <pumpkin> ski_ pumpkinbot never lies!
00:31:49 <slava> dmwit: thanks
00:31:57 <ski_> pumpkin : well, either a liar or forgetful, i suppose
00:32:10 <pumpkin> ski_: it's not lambdabot :/ they don't share state
00:32:13 <Olathe> @type \(x:xs) -> foldl' (\ac el -> ac >> Data.Binary.put el) (Data.Binary.put x) xs
00:32:15 <pumpkinbot> forall b. (Data.Binary.Binary b) => [b] -> Data.Binary.Put.PutM ()
00:32:16 <slava> dmwit: does it use lazyness?
00:32:22 <dmwit> slava: Now that I look at it, it might also be wrong.
00:32:34 <dmwit> slava: i.e. it might not preserve weird spacing if you have something like "a     b"
00:32:35 <ski_> pumpkin : they don't even talk to each other ? even though they're siblings ?
00:32:42 <pumpkin> ski_: unfortunately not :/
00:32:55 <Olathe> @type mapM Data.Binary.put
00:32:56 <pumpkinbot> forall a. (Data.Binary.Binary a) => [a] -> Data.Binary.Put.PutM [()]
00:33:09 <dmwit> slava: It should be partially lazy.
00:33:22 <Olathe> @type mapM_ Data.Binary.put
00:33:23 <pumpkinbot> forall a. (Data.Binary.Binary a) => [a] -> Data.Binary.Put.PutM ()
00:33:40 <dmwit> slava: Maximal laziness was not one of my goals when writing it, though. =P
00:34:22 <Olathe> dmwit: mapM_ looks promising. Thanks.
00:38:19 <dmwit> slava: I think if I were writing it today, it would be mostly the same, but the first line would be "wrap n = wrap' n . words where" instead of "wrap n ss = ss >>= wrap' n . words where".
00:39:35 <mmorrow> @type put (put (put (put put)))
00:39:36 <pumpkinbot> forall s (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) (m3 :: * -> *) (m4 :: * -> *). (MonadState (m3 ()) m4, MonadState (m2 ()) m3, MonadState (m1 ()) m2, MonadState (s -> m ()) m1, MonadState s m) =>
00:39:36 <pumpkinbot>  m4 ()
00:40:15 <dmwit> :t unfoldr
00:40:17 <pumpkinbot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:40:24 <Baughn> Is there any way at all I can extract the actual value of errno from an IOException?
00:43:22 <mmorrow> Baughn: i don't think it's explicitly retained
00:44:07 <Baughn> mmorrow: I really, really need to find out /why/ connect is failing; I'm using it to check for the possible existence of a daemon
00:44:19 <Baughn> I'll rewrite GHC if I have to. Don't make me use my editor!
00:44:47 <dmwit> Wow, you really do need that.
00:44:49 <dmwit> geez
00:45:17 <Baughn> You're talking like that's a surprise. :P
00:45:31 <Baughn> I suppose I should patch throwErrno and friends to stick it in the exception
00:46:21 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/errno
00:46:36 <slava> dmwit: thanks for all the help, I'm just cleaning up some ugly old imperitive code of mine :)
00:46:41 <pumpkin> not sure if it does what you need
00:46:41 <Baughn> Hold on. It *does* store errno, in a nice symbolic form at that
00:46:43 <pumpkin> but it looked handy
00:46:48 <Baughn> Just doesn't seem to be documented
00:47:05 <Baughn> pumpkin: Thanks anyway, but GHC has its own machinery
00:47:11 <pumpkin> cool, how does that work?
00:48:11 <Baughn> pumpkin: In, apparently, undocumented ways. I'm trying to figure that out.
00:48:46 <gordongecko> i need to translate a python algorithm to haskell
00:48:58 <mmorrow> Baughn: get ready for the pain! i wanted to be to use accept in a non-supported-by-Network.Socket way the other week, and came to the conclusion that i'd have to write my own binding to the C. which is a total pita due to all the structs (but definitely doable, and something i want to do at some point)
00:49:03 <gordongecko> it uses several and nested for loops
00:49:26 <dmwit> We use map and foldr instead of for.
00:49:29 <dmwit> :t amp
00:49:31 <pumpkinbot> Not in scope: `amp'
00:49:32 <dmwit> urk
00:49:35 <dmwit> :t (map, foldr)
00:49:36 <pumpkinbot> forall a b a1 b1. ((a -> b) -> [a] -> [b], (a1 -> b1 -> b1) -> b1 -> [a1] -> b1)
00:49:41 <gordongecko> http://rafb.net/p/vmVGUX84.html
00:49:45 <pumpkin> :t urk
00:49:46 <pumpkinbot> Not in scope: `urk'
00:49:51 <dmwit> ugh
00:50:01 <pumpkin> @let urk = fmap ((,) a) f
00:50:02 <pumpkinbot>  <local>:10:19:
00:50:02 <pumpkinbot>      No instance for (SimpleReflect.FromExpr (f a))
00:50:02 <pumpkinbot>        ar...
00:50:08 <pumpkin> @let urk (a, f) = fmap ((,) a) f
00:50:08 <mmorrow> Baughn: all the throwsErrorIf* were crashing my party
00:50:10 <pumpkinbot>  Defined.
00:50:12 <dmwit> Maybe the first question we should ask is: *why* doe you need to do this translation?
00:50:24 <Baughn> mmorrow: In my case, it seems fairly simple
00:50:39 <mmorrow> Baughn: nice. what did you work out?
00:50:40 <gordongecko> :t dmwit :: Know -> It -> All -> Besserwisser
00:50:41 <pumpkinbot> Not in scope: `dmwit'
00:50:41 <pumpkinbot> Not in scope: type constructor or class `Know'
00:50:41 <pumpkinbot> Not in scope: type constructor or class `It'
00:51:01 <Baughn> mmorrow: throwErrno (well, errnoToIOError) already stores all the information I need, the appropriate constructors just aren't exported
00:51:05 <dmwit> ;-)
00:51:10 <gordongecko> let f x = f 10 in f $ f x
00:51:16 <mmorrow> Baughn: interesting
00:51:36 <Baughn> mmorrow: See ghc/libraries/base/Foreign/C/Error.hs, the very last definition
00:51:50 <gordongecko> http://rafb.net/p/vmVGUX84.html <- gauss jordan to haskell, nesting map seems a bit messy, is there nothing better?
00:53:05 <mmorrow> Baughn: hmm, this might be nice
00:53:06 <dmwit> Most of those loops have clean equivalents in Haskell.
00:53:10 <pumpkin> gordongecko: you need to decide how to represent your matrices first
00:53:40 <pumpkin> gordongecko: some things are very clean, though
00:53:43 <gordongecko> [[1,2,3],[4,5,6],[7,8,9]], t slow?
00:53:48 <pumpkin> one of the nested loops is just finding the max
00:53:55 <pumpkin> i.e., maximum
00:53:56 <gordongecko> DA.listArray?
00:54:10 <slava> the thing is, he's mutating the array
00:54:23 <pumpkin> I'd use a pair-indexed mutable array in ST, probably
00:54:44 <pumpkin> but what I would do isn't that useful to you, as I'm not that clueful :)
00:55:41 <Baughn> mmorrow: Guess I'll open a ticket
00:55:48 <pumpkin> all the eps calculations can be wrapped up nicely in the approximate equality package that's on hackage
00:56:05 <pumpkin> actually, eps is only used once
00:56:07 <pumpkin> who cares
00:56:34 <Baughn> On that note, while git lets me download ghc itself, it lacks the boot libraries. Is this fixable a better way than pulling them all with darcs?
00:59:16 <pumpkin> maybe there's a git submodule for the base?
00:59:34 <Baughn> Not that I can see. Guess it's darcs for me.
00:59:39 <Baughn> 's not so bad.
00:59:49 <pumpkin> someone needs to write a git-darcs
00:59:52 <pumpkin> like git-svn
01:00:04 <Baughn> Someone alrady has, but it's succumbed to bit-rot
01:00:10 <pumpkin> ah
01:01:12 <chrisdone> mmorrow: I finally got that unifier working that I wanted to do ages ago: http://paste.lisp.org/display/74713 evalUnify "(?x ?x)" "((a ?y c) (a b ?z))" => Right ((a b c) (a b c))
01:01:35 <chrisdone> mmorrow: I think now that I understand it better, and now that I recently learned about ST, I can try to use vixey's library to implement it
01:01:49 <mmorrow> chrisdone: awesome.
01:02:29 <chrisdone> ^_^!
01:04:16 <ac> what kind of data structure would be a good choice for an ordered IntMap that contains 5 to 20 elements?
01:04:28 <Baughn> A list
01:04:41 <Baughn> Alist or plist, either would be fine
01:04:48 <slava> i'd use a sorted array
01:04:53 <slava> binary search is really fast
01:05:03 <pumpkin> might as well search linearly
01:05:05 <pumpkin> at that size
01:05:09 <slava> pumpkin: its a lot slower
01:05:28 <pumpkin> 5 elements?
01:05:42 <Baughn> An array might work
01:05:56 <Baughn> Search that linearly, and you don't need to chase pointers
01:05:57 <ac> I want to be able to randomly remove elements and append new ones on the end
01:06:08 <pumpkin> ah
01:06:12 <pumpkin> then I'd stick with a list
01:06:16 <Baughn> Or a map
01:06:21 <pumpkin> and search it linearly (if you know it'll be short)
01:06:23 <Baughn> Really, chances are it won't matter
01:06:47 <Baughn> If it's used enough that its performance /does/ matter, you'll have an opportunity to find out which is best. ;)
01:06:51 <ac> well, by "good" I really meant "fewest lines to write"
01:07:01 <Baughn> Map.
01:07:16 <Baughn> IntMap, rather.
01:07:31 <ac> so the order would just be in the value?
01:08:01 <Baughn> An IntMap is ordered by key.. is that not what you want?
01:08:14 <ac> I want an order independent of the key
01:09:05 <Baughn> What kind of order, exactly? Do you have anything to order /by/?
01:09:20 <Baughn> Otherwise, I guess a list would be simplest after all
01:10:04 <slava> pumpkin: if he's searching that 5-element list millions of times, then yeah, it matters whether you use a binary search over an array, or a linear traversal of a list
01:10:18 <pumpkin> oh yeah, linear traversal of a list would make a difference
01:10:29 <Baughn> ac: *Are* you searching the list millions of times?
01:10:29 <pumpkin> but linear iteration over a 5-element array vs. binary search of that array
01:10:48 <pumpkin> I can't see those two being very different
01:11:01 <luqui> how can I render a .lhs file to html?
01:11:18 <chrisdone> luqui: HsColour?
01:11:19 <Baughn> luqui: You may be looking for Haddock
01:11:44 <luqui> Baughn, no, not exactly.
01:11:52 <slava> pumpkin: main difference is searching a list will be 2x the memory accesses
01:11:56 <slava> pumpkin: and he said 5-20 elements not 5
01:11:58 <ac> Baughn: yeah, the independent order should be the order the elements were inserted in
01:12:04 <luqui> chrisdone, is there a way to tell it not to color the comment parts?
01:12:30 <slava> pumpkin: binary search over 20 elements is 5 memory loads worst case, linear search is 40 memory loads worst case, that's 8x the memory ops
01:12:45 <ac> specifically there will always be the same number of elements, and the one I'm replacing should always be the oldest one
01:12:50 <slava> pumpkin: also 5 conditionals -vs- 20 conditionals
01:12:57 <slava> pumpkin: conditionals and memory load/store is the most expensive operation on a cpu
01:13:09 <luqui> chrisdone, yes!  -lit.  :-)
01:13:13 <pumpkin> slava: the former depends on the CPU :P
01:13:18 <mc__> is there a function like words but which takes the sign to split at as a parameter?
01:13:27 <pumpkin> but yeah, all I said is that it wouldn't make that much of a difference, not that the binary search wouldn't be faster
01:13:30 <slava> pumpkin: i'm talking about your typical mainstream cpu
01:13:36 <augustss> slava: do you access memory as double words?  I'd say 10 memory accesses
01:13:44 <pumpkin> slava: I'd call ARM pretty mainstream :P
01:13:55 <slava> pumpkin: conditionals aren't particularly cheap on arm
01:14:09 <pumpkin> conditionals are built into every opcode
01:14:20 <ac> my first inclination was to use an IntMap and a list, but the problem is I'd have to update both with each operation
01:14:23 <slava> sure, but that doesn't mean an unconditional insn executes at the same speed as a conditional insn
01:14:34 <slava> pumpkin: after decoding it still has to do branch prediction and such
01:14:40 <slava> and a mispredicted branch is a pipeline stall
01:15:01 <augustss> ac: before you try to be clever you should measure the simple solutions.
01:15:08 <slava> of course arms have short pipelines, and they're not too fast to begin with, so...
01:15:18 <pumpkin> branch prediction? the whole point of sticking the conditionals into the mnemonics was to avoid that wasn't it?
01:15:25 <ac> augustss: measure? As in write them and see how many lines of code there are? I'm definitely not concerned with performance
01:15:28 <slava> pumpkin: nope
01:15:44 <augustss> ac: oh, I see
01:15:45 <slava> pumpkin: it just reduces code size
01:15:46 <pozic> Why is there no maxBound for Double or Float? I would like to detect overflow.
01:16:20 <augustss> pozic: they go to Infinity on overflow
01:17:13 <Peaker> @localtime conal
01:17:18 <pumpkin> slava: I'm not sure I buy that
01:17:53 <slava> pumpkin: in our list traversal example, conditioanl opcodes don't win you anything performance-wise
01:18:01 <slava> in some cases they can be a win
01:18:23 <pumpkin> slava: they save you the jumping around you'd need on an x86 without cmov
01:18:28 <pumpkin> not that it's very expensive :)
01:18:38 <augustss> pumpkin: many design decision in the ARM were taken when silicon was scarce, that's no longer true, so the arch has some oddities
01:18:46 <pumpkin> augustss: certainly
01:18:52 <wli> Fewer longer basic blocks are useful in a number of ways.
01:18:54 <slava> pumpkin: sure, but you can't do everything with cmov :)
01:19:07 <pumpkin> but I don't think branch prediction has much place when there are no branches
01:19:15 <pumpkin> just conditional execution of individual instructions
01:19:27 <slava> what if you have conditioanl execution of a jump?
01:19:32 <pumpkin> that's a branch :P
01:19:44 <augustss> but you only want to do that when there's very few conditional instructions
01:19:59 <wli> Silicon is still scarce. It's just that the CPU isn't where the pressure of that scarcity lies, it's the memory hierarchy.
01:19:59 <pumpkin> but the point is I can do an STRGT val, max;
01:20:05 <pumpkin> or something along those lines
01:20:38 <augustss> wli: memory is special since it can consume any amount of silicon
01:21:16 <ac> is there a special version of IntMap that lets you index elements by order of insertion? ;)
01:21:31 <mc__> is there a function like words but which takes the character to split at as a parameter?
01:21:49 <augustss> ac: what's wrong with a list if you don't care about performance?
01:21:56 <dobblego> mc__, see Data.List.Split
01:21:58 <pumpkin> mc__: in the split package on hackage
01:22:06 <ac> mc__: partition might sort of be what you're looking for
01:22:20 <mc__> thanks, I'll take a look at those
01:22:21 <pumpkin> partition takes a predicate that doesn't know the position
01:22:27 <pumpkin> unless you zip the position in
01:22:57 <wli> augustss: Kind of. TLB, channels to memory, fanout of the register file, etc.
01:23:20 <pumpkin> bah, I wanna go to sleep
01:24:16 <paolino> hi, I'm trying to make a list of a where
01:24:17 <paolino> class Operator a cf c l where
01:24:17 <paolino> 	operation 	:: a -> Operation cf c l
01:24:23 <pumpkin> paolone!
01:24:30 <ac> augustss: nothing really...
01:24:33 <ac> @hoogle AList
01:24:33 <pumpkinbot> Distribution.ParseUtils commaListField :: String -> (a -> Doc) -> ReadP [a] a -> (b -> [a]) -> ([a] -> b -> b) -> FieldDescr b
01:24:33 <pumpkinbot> Distribution.ParseUtils parseCommaList :: ReadP r a -> ReadP r [a]
01:24:33 <pumpkinbot> Distribution.ParseUtils parseOptCommaList :: ReadP r a -> ReadP r [a]
01:24:45 <pumpkin> AList?
01:24:59 <pumpkin> type AList = [(a, b)] :P
01:25:06 <paolino> I've tried
01:25:07 <paolino> data OperatorBox = forall a cf c l. Operator a cf c l => OperatorBox a
01:25:52 <wli> I guess that's not silicon, it's constraints of some sort on more power in very specific areas (NFI what those constraints are).
01:26:12 <ski_> paolino : and ?
01:26:14 <ac> pumpkin: I was hoping for some handy functions, like for removing an element... not quite complicated enough to be in a library I imagine
01:26:21 <slava> thing that pisses me off most about arm is the small size of immediate operands
01:26:25 <slava> 8 bits? wtf
01:26:39 <paolino> ski_: and I have instances error when I add an operator
01:26:39 <augustss> wli: oh, there's plenty of other constraints
01:26:41 <pumpkin> slava: yeah :P but they're spaced nonlinearly at least :)
01:26:48 <paolino> box :: [OperatorBox]
01:26:48 <paolino> box = [OperatorBox Strictman]
01:26:49 <pumpkin> s/at least/what the fuck/
01:26:53 <pumpkin> :P
01:26:57 <slava> yeah, you can use the shifter to cook up larger values
01:27:00 <slava> but its a pain
01:27:30 <wli> s/more power/more computational elements/
01:27:33 <pumpkin> it's a quirky arch, but imho is a lot prettier than intel (although that doesn't take much)
01:27:44 <pumpkin> it's a lot more pleasant to read, that's for sure
01:27:45 <slava> nah, i prefer doing intel codegen to arm
01:27:52 <paolino> ski_: in particular
01:27:52 <paolino> instance NFData l =>  Operator Strictman cf c l where
01:27:52 <paolino> 	operation Strictman ps = parMap r0 rnf ps `seq` return ps
01:27:54 <augustss> paolino: looks like all those type variables can cause ambiguities
01:28:01 <paolino> right
01:28:05 <slava> instruction selection is virtually impossible to do in anything that approaches an optimal manner on arm
01:28:11 <paolino> I miss NFData then
01:28:20 <wli> Intel tries to displace x86 with IA64 and ends up doing it with ARM.
01:28:24 <mc__> why does splitAt take an Int as first parameter? my list is a string and I want to spit at ' '
01:28:25 <augustss> paolino: no FD you can use?
01:28:43 <paolino> functional deps ?
01:28:51 <pumpkin> slava: how so?
01:28:53 <augustss> yes
01:28:57 <Peaker> Does something have to pass some threshold of maturity, usability or usefulness before it can be put on hackage?
01:28:59 <ski_> paolino : probably you have to fix the `cf',`c',`l' types when defining `box'
01:29:12 <pumpkin> slava: I can't say I've ever written much arm, but I've read many megabytes of it I bet :P
01:29:13 <slava> pumpkin: how do you do instruction selection taking into account the barrel shifter and the fact that any instruction can be conditionalized?
01:29:27 <slava> pumpkin: i'm talking about compilers that target arm, not writing it by hnd
01:29:42 <paolino> augustss: well I believe a implies all of cf c and l
01:29:52 <pumpkin> yeah :) I meant that I've never had to think about choice of instructions (except when remarking that the compiler was stupid to do a particular thing)
01:29:55 <augustss> paolino: then say so!
01:30:14 <ac> pumpkin: indexing is easy: get i xs = find ((==i) . fst) xs -- but removing an element isn't coming immediately to mind
01:30:15 <wli> Predication is weird wrt. optimization; I know very little about how it's dealt with.
01:30:22 <pumpkin> ac: filter
01:30:24 <augustss> slava: very good code generation for the ARM is not easy
01:30:29 <slava> yeah
01:30:32 <slava> its a lot harder than x86
01:30:39 <pumpkin> sounds like an interesting problem
01:30:45 <pumpkin> I'm a big fan of the arch :)
01:30:53 <wli> Isn't ARM moderately register-starved also?
01:30:53 <pumpkin> (in case you hadn't noticed)
01:31:00 <slava> wli: 16 registers, not too bad
01:31:05 <pumpkin> it has 14ish general purpose ones
01:31:06 <pumpkin> yeah
01:31:12 <pumpkin> you can get 15 if you're careful
01:31:22 <slava> 13, really, unless you're messing with the link register
01:31:29 <pumpkin> yeah, which is fine
01:31:31 <wli> slava: That's moderately starved if you ask me.
01:31:38 <slava> wli: as starved as x86-64
01:31:43 <paolino> augustss: now Coverage Condition fails
01:32:05 <wli> slava: Yeah, I wasn't impressed with x86-64's double-wide register trailer.
01:32:21 <slava> i love x86-64
01:33:02 <slava> 16 integer and fp registers is enough
01:33:12 <paolino> augustss: and still  Ambiguous type variable `l' in the constraint:
01:33:13 <paolino>       `NFData l'
01:34:08 <pumpkin> on the iphone you even get "32" FP regs :D
01:34:33 * wli just doesn't understand how these CPU/arch designers screw things up so badly.
01:34:46 <slava> who screwed up what?
01:35:11 <idnar> what's a register trailer?
01:35:15 <chrisdone> BMeph: Haskell> evalUnify "?x" "(?x)" => Right ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((C-cC-cInterrupted
01:35:19 <pumpkin> it would be neat if someone could come up with a variable length instruction coding that meant you could find your way unambiguously if you jumped into the middle of an instruction, but still supported variable length instructions
01:35:19 <idnar> it sounds like something you tow around
01:35:25 <paolino> ski_: I don't know how to fix them
01:35:26 <opqdonut> idnar: just the set of registers :)
01:35:32 <opqdonut> a big one, at that
01:35:48 <slava> pumpkin: like utf8?
01:36:05 <chrisdone> BMeph: unsafePerformUnificationWithoutOccursCheck
01:36:05 <wli> Unsolvable problems all over compiling to their instruction sets, interrupt controllers and MMU's with numerous gross inefficiencies required of software users, etc.
01:36:12 <pumpkin> slava: something similar, yeah
01:36:14 <ski_> paolino : it is not clear to me what you want
01:36:41 <ski_> paolino : to get the current code to compile, you must disambiguate `cf',`c',`l'
01:37:35 <pumpkin> slava: are you the factor slava?
01:37:58 <slava> yup
01:38:06 <pumpkin> cool :)
01:38:51 <elly> wli: that's actually just x86
01:39:01 <elly> wli: compiling to arm or mips is easy and fun :)
01:39:03 * elly -> sleep
01:39:10 <slava> elly: compiling to arm is really hard actually
01:39:19 <slava> if you want good code that is
01:39:22 <paolino> ski_: I cannot know the constraints each operator will put on those types
01:39:28 <pumpkin> what percentage of intel processors is dedicated to decoding the instructions?
01:39:35 <slava> pumpkin: a tiny percentage
01:39:38 <wli> Nah, the RISC CPU's all got screwed up in various ways.
01:39:50 <slava> pumpkin: most of the cpu is cache and branch prediction
01:40:04 <pumpkin> ah
01:40:15 <slava> all the integer and simd units take up a lot of space too
01:40:26 <slava> the decoder is irrelevant in comparison
01:40:34 <elly> on the old pentiums like 40% of the silicon used to be decoding, I heard
01:40:47 <augustss> that's in the past
01:40:52 <pumpkin> then again, they were tiny compared to modern processors
01:40:56 <wli> They're big compared to various other arches, but not a dominant factor.
01:40:57 <slava> are you sure that was just decoding, or decoding and scheduling?
01:41:02 <ski_> paolino : in `instance NFData l => Operator Strictman cf c l', any types `cf',`c' at all are allowed .. is that what you intend ?
01:41:10 <elly> on a P1 there isn't a whole lot of scheduling to do
01:41:20 <elly> that was fetch and decode logic though
01:41:20 <slava> its funny that powerpc g5 decodes instructions into micro-ops just like x86 chips do these days
01:41:29 * elly -> sleep
01:41:34 <hackage> Uploaded to hackage: hexpat 0.3
01:41:37 <pumpkin> elly: not allowed!
01:41:41 <paolino> ski yes
01:41:45 * elly >>= sleep :)
01:41:49 <augustss> the PPC was never a proper RISC
01:42:07 <slava> yeah, rlwinm
01:42:10 <pumpkin> we need GHC on cell
01:42:14 <chrisdone> (☞ﾟ∀ﾟ)☞
01:42:33 <ray> ghc would make my phone explode, i think
01:42:54 <pumpkin> I still want to be able to cross-compile to iphone :)
01:43:13 <ski_> paolino : so, after you pick out an element of `[OperatorBox]' (e.g. `Strictman') you expect to be able to use it with `operation :: a -> Operation cf c l' for *any* choise of `cf',`c', yes ?
01:43:17 <augustss> I tried compiling Hugs on my phone.
01:43:17 <ray> i want to be able to cross-compile to haskell machine
01:43:27 <augustss> not cross-compile ;)
01:43:29 <pumpkin> augustss: it's already on cydia
01:43:33 <pumpkin> ah :)
01:43:41 <slava> i used to have factor running on my windows ce phone with arm cpu
01:43:43 <augustss> pumpkin: oh, cool.  it wasn't when i tried
01:44:07 <pumpkin> ah
01:44:18 <pumpkin> yeah, the guy who runs cydia likes haskell a lot
01:44:44 <augustss> I like how you can just download all development tools to the iphone, ssh to it, and run
01:45:03 <slava> only if you jailbreak right?
01:45:05 <paolino> ski_: I'm not understanding that any probably
01:45:07 <pumpkin> yeah :/
01:45:08 <augustss> right
01:45:17 <ray> my googling for haskell machine is not giving me the expected results
01:45:44 <slava> i don't see the point of running dev tools on the phone itself, cross compilation seems much saner
01:46:10 <pumpkin> slava: mostly just because you can :P except when gcc tries to use more memory than the iphone is willing to give
01:46:14 <ray> ray the grump says "so much for google", ray the level-headed says "well, it doesn't exist"
01:46:15 <pumpkin> and springboard starts crashing
01:46:16 <augustss> I just think it's so much cooler
01:46:20 <paolino> ski_: and each operator is going to put different constraints on cf c and l
01:46:31 <ski_> paolino : it would help if you could explain, or show code, about how you want to *use* an element of `[OperatorBox]'
01:46:41 <ray> i actually got hit by the oom-killer when running ghc on olpc
01:46:46 <slava> with apple's tools, you can do stuff like run the app on the phone, collect profiling results, and analyze them on your desktop
01:46:49 <slava> very nice
01:47:06 <ray> now i have swap space, which people say is bad on solid state devices
01:47:11 <augustss> slava: slick, yes
01:47:59 <pumpkin> ray: probably is :P
01:48:06 <pumpkin> slava: you still get those with jailbreak :)
01:48:10 <ray> i don't see it
01:48:15 <pumpkin> but you can run gdb locally, ps, and sift around the filesystem too
01:48:19 <ray> lifespan schmifespan
01:48:25 <paolino> ski_: I want to use operation :: a -> Operation cf c l  on those elements where cf c and l are fixed by each operator constraint
01:48:25 <ray> i write to the thing anyway
01:48:56 <ski_> paolino : but you just said before that `cf' and `c' is not fixed, e.g., if `a = Strictman'
01:49:40 <pumpkin> slava: jailbreak is strictly greater than apple's official solution except when it comes to OS updates
01:50:02 <paolino> ski_: this is right for that operator only which operates on l only
01:50:55 <ski_> paolino : then it sounds like you maybe have misdesigned `Operator'
01:50:56 <p_l> to those hit by OOM, I recommend working with OOM-killer disabled :)
01:51:22 <ski_> (hard to tell, since i have no clue what this's about)
01:51:34 <ray> i agree in principle. but that can't solve genuinely being out of memory, of course
01:51:55 <paolino> ski_: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1125#a1125
01:52:24 <pumpkin> the iphone is a pretty remarkable little piece of hardware though... so much goodness in it waiting to be unleashed, and apple's just sitting on it :(
01:52:36 <p_l> ray: Yes, but it would be nice if it worked with overcommit disabled by default. After all, malloc can fail for a reason...
01:52:45 <paolino> ski_: I need a type to identify each Operator instance to read its actual configuration
01:53:18 <paolino> I use that type to index a HList
01:53:51 <p_l> pumpkin: I find parts of the iPhone really maddening (lack of ports, no SD etc.), but I agree that the iphone OS destroys most of possible greatness :)
01:54:07 <pumpkin> yeah
01:54:38 <paolino> ski_: that is why I put an additional type a around an Operation and give it a class to exctract the real Operation
01:54:39 <pumpkin> but it has nice crypto hardware, decent graphics, reasonably fast CPU, plenty of memory, a few nice sensors
01:54:49 * p_l spent few hours with iPhone 3G and couldn't force himself to like it, after using Windows Mobile on HTC phones
01:55:00 <jkff> Look what I've found: a book named "Topology and category theory in computer science" - http://www.amazon.com/exec/obidos/tg/detail/-/0198537603/ref=pd_luc_mri?_encoding=UTF8&m=ATVPDKIKX0DER&v=glance . Here's a review http://logcom.oxfordjournals.org/cgi/reprint/3/6/687.pdf . Sounds interesting to me. Anyone read this?
01:55:01 * ski_ uh-uhs at the mention of `HList'
01:55:11 <ray> i don't see myself liking the iphone just based on the design
01:55:25 <paolino> ski_: maybe is a DList I don't remember
01:55:31 <ray> i have greasy fingers. forgive me
01:55:34 <pumpkin> I'm just talking about hardware-wise :)
01:55:42 <ray> screens are hardware too!
01:55:45 <pumpkin> I like the GUI, but I can see why people wouldn't
01:55:49 <Peaker> paolino: HList is a crazy type-class based compile time list
01:56:11 <paolino> well I used them enough now
01:56:13 <ray> when they cure greasy fingertips i will be first in line
01:56:13 <Peaker> I think the iPhone interface is awesome :P
01:56:23 <ray> first in line for the cure, i mean, not for an iphone necessarily
01:56:39 <Peaker> ray: you could use a plastic pen instead of your hands?
01:56:39 <pumpkin> :)
01:56:50 <paolino> Peaker: my problem now is existentials probably
01:56:55 <augustss> Peaker: I think it's awesome too
01:57:02 <pumpkin> Peaker: that doesn't work
01:57:22 <p_l> I found iPhone's GUI maddening. Where is handwriting recognition? Why the hell scrolling is done different to everything? Why the hell _everything_ must be animated, when I just want it to change right away? And it's on-screen keyboard sucks
01:57:23 <opqdonut> jkff: interesting indeed
01:57:28 <Peaker> augustss: hehe, it may be. I've looked at the paper, when I thought it was a solution to my problem. Then I found a much simpler solution, that doesn't even use any ghc extensions :)
01:57:36 <ray> i'd lose it :(
01:57:45 <ray> well, i haven't lost my DS touch pen yet
01:57:47 <pumpkin> p_l: the on-screen kb takes getting used to, but I can type really fast on it now
01:57:47 <p_l> afk
01:57:51 <ray> i have lost some of the internal parts though
01:58:04 <Peaker> p_l: animation is great -- you don't disorient over what's happening. the animation is fast enough to be useful.  scrolling is *awesome*
01:58:09 <Peaker> p_l: I think everyone should scroll that way
01:58:12 <pumpkin> p_l: when was the last time you "handwrote" with your finger?
01:58:35 <pumpkin> I don't think it would be any more intuitive to have handwriting recog on a touchscreen
01:58:59 <augustss> p_l: don't get an iPhone then. :)  For me, it's the first phone with a useable interface.  It still has flaws, but I find it much ahead of anything else I've used.
01:59:02 <Peaker> p_l: if the animation is fast enough (i.e less than 1/5 of a second to get stuff to "happen", and you can immediately continue as if they did), then its purely helpful
01:59:03 <znutar> we need cameras with dign language recognition
01:59:11 <pumpkin> yeah :)
01:59:20 <pumpkin> the camera and mic, on the other hand, suck :)
01:59:23 <ray> what happened to controlling devices with subtle eye movements
01:59:26 <augustss> the iPhoe has the only scrolling I've seen that makes sense.
01:59:32 <ray> i thought that was the wave of the future
01:59:43 <Peaker> augustss: I enthusiastically concur!
01:59:54 <pumpkin> me too :)
02:00:15 <ski_> (jkff : looks nice .. haven't read it, though)
02:00:38 <Peaker> I am still stuck with an old Nokia, though.. the Nokia UI designers are a bit stupid :-(
02:00:40 <jkff> By the way, does anyone know of any good introductory material on topology? Something that would provide me with intuition about the basic glossary, with a lot of examples etc.?
02:01:13 <pumpkin> jkff: aren't you afraid you might bite on coffee mugs in the morning, by mistake, instead of donuts?
02:01:16 <augustss> Peaker: the Nokia guys are well ahead of the Motorola guys :)
02:01:28 <Peaker> augustss: its amazing how much stupidity can control a field :)
02:01:41 <jkff> pumpkin: There's nothing to be afraid of, since they are no different :)
02:02:37 <Peaker> augustss: for example, Nokia has a "disconnect call" button. When you dial someone, the button that normally means "Speaker" when the call is active is overloaded to *also* be a "disconnect call" button until the call is connected.  So when you really need the speaker, because you don't have your hands free, that's when they want you to pay most attention to the phone, wait for it to connect, and then press speaker.  If you miss, you disconnect!
02:02:41 <jkff> However, I mean something that would provide intuition not just for geometrical stuff, but for more abstract things. I, for one, don't intuitively understand even the concept of an open set; I need more examples than just open pointsets in space.
02:02:54 <Peaker> augustss: e.g: when driving
02:02:55 <ski_> jkff : not sure if it's introductary, but "Topology Via Logic" by Steven Vickers is interesting
02:03:06 <Peaker> augustss: I am sure Nokia killed a few drivers that way...
02:03:07 <jkff> Like, how would one specify the topology of a given graph: which sets would be open?
02:03:22 <jkff> ski_: Thanks, I'll have a look at it
02:03:43 <Peaker> augustss: I thought this was a UI glitch many years ago - but they have consistently replicated this design to newer phones.. what can they be thinking?
02:04:23 <ski_> jkff : there's also <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/> <http://math.andrej.com/2005/07/27/the-dedekind-reals-in-abstract-stone-duality/> <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/> <http://www.monad.me.uk/ASD/> <http://www.mta.ca/~cat-dist/archive/2007/07-8> which might be interesting
02:05:02 <jkff> Wow! I read the second and the fourth one, but thanks very much for the others!
02:06:38 <jkff> ski_: The first thing looks very cool
02:06:54 <ski_> (jkff : in the last link, search for `Paul Taylor' to get a description of abstract stone duality)
02:07:15 <lilac> jkff: asking which objects would be open in a given context is like asking what mappend should do
02:08:13 <lilac> jkff: it depends on which topology you're dealing with (and it's more "oh look, this thing is a topology" than "i wonder how i can make this thing a topology")
02:08:47 <jkff> lilac: Makes sense; what are the ways I can make a given graph a topology?
02:09:21 <ski_> well, there's always the discrete and the codiscrete topology over a set
02:10:47 <jkff> How could I reflect the connectivity structure of a graph by posing a topology onto the set of its nodes?
02:11:25 <jkff> (And would, for example, graph isomorphisms translate to homotopies?)
02:12:22 * ski_ doesn't know whether there's any natural functors from `Graph' to `Top'
02:12:53 <ski_> i suppose you could say that every edge induces an open containing the source and target of the edge
02:13:24 <ski_> hm
02:13:28 <jkff> ski_: Makes sense. So, the open sets would correspond to connected subgraphs, in general?
02:13:40 <jkff> (Including subgraphs of 1 or 0 nodes)
02:14:03 <jkff> But that doesn't reflect self-loops, for instance.
02:14:13 <ski_> (let's consider finite graphs, for the moment, i think)
02:15:12 <ski_> we have finite intersection and arbitrary union
02:17:34 <ski_> (jkff : "reflect self-loops" meaning ?)
02:19:19 <jkff> ski_: A graph that has a loop at a given node seems to me topologically different from one that hasn't, yet this aspect can't be taken into account by introducing an open set of 2 vertices for that edge, since that would be only 1 vertex, which was anyway already open.
02:19:55 <ac> @hoogle (a -> Bool) -> [a] -> ([a], [a])
02:19:56 <pumpkinbot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
02:19:56 <pumpkinbot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
02:19:56 <pumpkinbot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
02:20:23 <ski_> (jkff : well, at least as i was sketching, it wasn't necessarily open)
02:20:34 <luqui> :t partition
02:20:36 <pumpkinbot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:21:47 <lilac> jkff: sorry, shower. a neat topology over a graph says a set X is open iff forall edges a -> b in the graph, a is in X implies b is in X
02:22:30 <lilac> generally, the statement "X is open iff a in X implies f(a) in X" forms a topology.
02:22:32 <ski_> hm, that might be more useful
02:24:01 <jkff> lilac: Looks nice and useful, thanks.
02:26:21 <lilac> in a sense, that's very similar to the reals, where we say "X is open iff a in X implies (some small ball around a) in X"
02:27:03 <lilac> and we can generalize to say that f(a) can be different for different open sets X, so long as finite intersections of those values are still ok
02:27:41 <lilac> (for the reals, we can find different balls around a, because their intersection will still be a non-trivial ball around a)
02:28:19 <jkff> lilac: That also reminds me something of Kripke models
02:28:52 <jkff> There was some stuff like 'forall edges a -> b in the graph, a is in X implies b is in X'
02:29:15 <lilac> the latter generalization is, i think, equivalent to the definition of a topology, but i could be mistaken.
02:34:42 <pozic> Where is the listOf function implemented? It should be somewhere in QuickCheck, but which module of which package?
02:35:06 <Lemmih> pozic: Try :i listOf in ghci.
02:35:29 <ac> why doesn't Data.Sequence have filter and find?
02:35:31 <pozic> Lemmih: not in scope, as I expected.
02:36:19 <Lemmih> pozic: :m Test.QuickCheck
02:36:24 <ski_> @index listOf
02:36:24 <pumpkinbot> bzzt
02:36:36 <pozic> Lemmih: same result
02:36:38 <ski_> @hoogle listOf
02:36:38 <pumpkinbot> No results found
02:36:42 <ski_> bah
02:36:52 <Lemmih> Prelude Test.QuickCheck> :i listOf
02:36:52 <Lemmih> listOf :: Gen a -> Gen [a] 	-- Defined in Test.QuickCheck.Gen
02:36:54 <hugo___> hello
02:37:19 <pozic> Lemmih: which version of QuickCheck do you have and where did you get it?
02:38:28 <Lemmih> pozic: 2.1.0.1 from hackage.
02:39:48 <jkff> hugo__: hi
02:41:04 <pozic> For some reason cabal installs 1.2 instead of 2.0 even though I have updated.
02:41:44 <Lemmih> pozic: Ask it to install version 2.
02:42:42 <pozic> Lemmih: already done, and it seems to be working
02:43:05 <pozic> Lemmih: thank you
02:46:26 <mc__> foo returns a tuple, can I write something like (a,b) = foo bar ?
02:46:39 <koeien> yes
02:47:38 <koeien> (,) is not special is this regard
02:48:24 <ski_> > a * b  where (a,b) = divMod 17 7
02:48:25 <pumpkinbot>   6
02:49:08 <mc__> well, i have this in my code "(a,b) = (break (s==) xs"  and it says "parser error on input ="
02:49:28 <koeien> the error is probably earlier in your code
02:49:38 <koeien> also check out the layout rule
02:49:47 <koeien> do you have enough closing parentheses?
02:51:44 <mc__> koeien: I think so
02:51:47 <mc__> this is my code http://gist.github.com/56874
02:52:42 <augustss> mc__: you need a let ... in ...
02:52:59 <augustss> or a ... where ...
02:55:11 <ivanm> I take it lambdabot is dead?
02:55:20 <mc__> ah, thank you augustss
02:56:00 <pumpkin> ivanm: yeah
02:56:07 <ksf> @seen conal
02:56:07 <pumpkinbot> I saw conal leaving #haskell 5h 51m 17s ago, and .
02:56:08 <pumpkin> long live lambdabot!
02:56:24 <ivanm> s/lambda/pumpkin/
03:01:17 <mc__> what do you think, is my simple safeTail function a good solution or a hack? http://gist.github.com/56874 (usign tail instead of safeTail in the split function would throw an exception)
03:03:49 <ski_> (mc__ : i might call it `truncatingTail' or something ..)
03:04:12 <yottis> yeah, i'd expect safeTail to return Maybe [a]
03:05:04 <nikki93> Well, I started 'Real World Haskell' but got bored halfway through. :(
03:05:18 <nikki93> You guys could suggest some other learning resources?
03:05:18 <mc__> yottis: but wouldn't that only complicate its usage, whats the advantage of using Maybe?
03:05:29 <idnar> mc__: safeTail = drop 1
03:05:54 <idnar> your version, anyhow
03:06:19 <ski_> nikki93 : YAHT ?
03:06:20 <yottis> well, sometimes it's not ok to just return the original empty list if you ask for the tail
03:06:21 <idnar> the advantage of [a] -> Maybe [a] is that you can differentiate an empty tail from a missing tail
03:06:58 <mc__> nikki93: http://www.amazon.com/Introduction-Functional-Programming-using-Haskell/dp/0134843460 this book is quite good - though it was a lot cheaper when i bought it some months ago
03:07:23 <mc__> idnar: now I see the advantage, thank you
03:07:39 <idnar> mc__:  of course, if you don't care about separating those cases, then drop 1 works just fine
03:07:53 <yitz> nikki93: try "Learn Yourself a Haskell"?
03:08:05 <yottis> and you can use fmap or >>= on it and maybe merge the results with maybe in the end
03:08:44 <yitz> @go Learn Yourself a Haskell
03:08:45 <pumpkinbot> http://learnyouahaskell.com/faq
03:08:45 <pumpkinbot> Title: Learn You a Haskell for Great Good! - FAQ
03:09:08 <Peaker> idnar: I'd prefer it if we had a non-recursive fold on lists:  b -> (a -> [a] -> b) -> [a] -> b -- then just use the tail from the head/tail args, and also handle the empty case, like you'd have to handle the Nothing case
03:09:46 <Peaker> @type let f nil _ [] = nil ; f _ cons (x:xs) = cons x xs in f
03:09:47 <pumpkinbot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
03:09:51 <ski_> (Peaker : .. then it's not a fold)
03:10:01 <Peaker> ski_: Is it still considered a catamorphism?
03:10:10 <ski_> it is not
03:10:10 <idnar> hmm, I wonder what you would call a "non-recursive" fold
03:10:15 <Peaker> ski_: any good name for it then?
03:10:20 <ski_> case ?
03:10:30 <Peaker> ski_: I want it to be a function I can compose
03:10:37 <idnar> it seems a bit esoteric, though
03:10:40 <Peaker> well, foldr should be implemented in terms of that function
03:10:52 <idnar> I imagine you'd use the Maybe version in a monadic way
03:10:55 <ski_>   caseList :: r -> (a -> [a] -> r) -> ([a] -> r)
03:11:35 <ski_> alternatively
03:11:46 <ski_>   caseList :: (Maybe (a,[a]) -> r) -> ([a] -> r)
03:12:31 <yitz> Peaker: it's called maybe . safeUncons
03:12:59 <Peaker> idnar: I want to write a TH record creation macro that creates accessors for fields.  I guess if you have multiple data constructors, it would be nice if for each data constructor, an automatic function:   (fieldsOfConstructor -> b) -> Type -> Maybe b    was created.  Then, for list it would be:   cons :: [a] -> Maybe (a, [a])   and you could use  (result . fmap) snd cons
03:13:09 <Peaker> yitz: "safeUncons" can really be auto-generated for all data constructors
03:14:20 <yitz> Peaker: mm, well, I'm not sure what the type should be in general.
03:14:56 <Thunder> Peaker: Do you mean something like "\x1 f -> foldr (\x -> case Nothing -> x1; _ -> fmap f x)  Nothing"
03:14:59 <Peaker> yitz: I don't think it can have a single type... Just the above:   unConstructorName :: (fieldsInThatConstructor -> b) -> Type -> Maybe b
03:15:28 <yitz> Peaker: ok, I see.
03:15:58 <Peaker> Thunder: flipped
03:16:27 <Peaker> @type \x1 f -> foldr (\x -> case Nothing -> x1; _ -> fmap f x)  Nothing
03:16:28 <pumpkinbot> parse error on input `->'
03:16:36 <Peaker> @type (\x1 f -> foldr (\x -> case Nothing -> x1; _ -> fmap f x)  Nothing)
03:16:37 <pumpkinbot> parse error on input `->'
03:16:46 <Thunder> Peaker: So you are looking for a "safeWarpper" for fold.
03:17:01 <Peaker> @type let func x1 f = foldr (\x -> case Nothing -> x1; _ -> fmap f x)  Nothing in func
03:17:02 <pumpkinbot> parse error on input `->'
03:17:08 <Peaker> oh
03:17:13 <Thunder> You need {}
03:17:29 <Thunder> And case x of { ... }
03:17:32 <Peaker> missing "x of .."
03:17:39 <Peaker> @type \x1 f -> foldr (\x -> case x of Nothing -> x1; _ -> fmap f x)  Nothing
03:17:41 <pumpkinbot>     Couldn't match expected type `b -> a'
03:17:41 <pumpkinbot>            against inferred type `Maybe t'
03:17:41 <pumpkinbot>     In the second argument of `fmap', namely `x'
03:17:50 <Peaker> Thunder: can you show me the type of your decl?
03:18:16 <Thunder> Peaker: I just tried to express your motivation.
03:19:13 <Peaker> Thunder: I'm actually not sure I meant your function - I am not sure what your function does -- shouldn't it give a two-arg function to foldr? Or is x1 not a list type but a function type?
03:24:37 <Thunder> @type \f x1 -> foldr (\x y -> case y of {Nothing -> Just x1; Just y -> Just $ f x y}) Nothing
03:24:38 <pumpkinbot> forall a a1. (a -> a1 -> a1) -> a1 -> [a] -> Maybe a1
03:27:10 <Peaker> @type foldr1
03:27:11 <pumpkinbot> forall a. (a -> a -> a) -> [a] -> a
03:28:39 <Peaker> @let foldrSafeWrapper f x1 = foldr (\x y -> case y of {Nothing -> Just x1; Just y -> Just $ f x y}) Nothing
03:28:41 <pumpkinbot>  Defined.
03:28:52 <Peaker> > foldrSafeWrapper (*) 1 [1,2,3]
03:28:54 <pumpkinbot>   Just 2
03:28:58 <ski_> @type foldrSafeWrapper
03:28:59 <pumpkinbot> forall a a1. (a -> a1 -> a1) -> a1 -> [a] -> Maybe a1
03:29:11 <Peaker> > foldrSafeWrapper (*) 1 []
03:29:12 <pumpkinbot>   Nothing
03:29:16 <Peaker> > foldrSafeWrapper (*) 2 [1]
03:29:17 <pumpkinbot>   Just 2
03:29:26 <Peaker> > foldrSafeWrapper (*) 2 [1,2]
03:29:28 <pumpkinbot>   Just 2
03:30:22 <idnar> that's more like foldr1, isn't it?
03:30:30 <idnar> hmm, no
03:30:31 <Peaker> > foldrSafeWrapper (*) 2 [2]
03:30:33 <pumpkinbot>   Just 2
03:30:37 <idnar> don't mind me
03:30:39 <Peaker> its a foldr that ignores the last element :P
03:30:43 <Thunder> s/Just x1/Just $ f x x1/
03:30:58 <Peaker> @undef
03:31:08 <Peaker> @let foldrSafeWrapper f x1 = foldr (\x y -> case y of {Nothing -> Just $ f x x1; Just y -> Just $ f x y}) Nothing
03:31:09 <Thunder> We have two(!) initital Arguments
03:31:09 <ski_> > foldrSafeWrapper (:) [10,20] [1,2]
03:31:09 <pumpkinbot>  Defined.
03:31:10 <pumpkinbot>   mueval: Prelude.read: no parse
03:31:10 <idnar> Peaker: heh
03:31:22 <Peaker> > foldrSafeWrapper (*) 2 [2]
03:31:24 <pumpkinbot>   Just 4
03:31:25 <Peaker> > foldrSafeWrapper (*) 2 []
03:31:27 <pumpkinbot>   Nothing
03:31:31 <Peaker> > foldrSafeWrapper (*) 2 [1,2,3]
03:31:32 <pumpkinbot>   Just 12
03:31:46 <ski_> > foldrSafeWrapper (:) [10,20] [1,2]
03:31:48 <pumpkinbot>   Just [1,2,10,20]
03:31:51 <ski_> > foldrSafeWrapper (:) [10,20] []
03:31:53 <pumpkinbot>   Nothing
03:32:16 <Peaker> Thunder: why not replace Maybe a and Nothing with a and x1 ?
03:32:22 <ski_> why `foldrSafeWrapper' ?
03:32:28 <Thunder> Peaker: It's up to you
03:32:47 <Peaker> Thunder: well, its not the function I had in mind
03:33:03 <Thunder> Then please specify your problem again
03:33:13 <Peaker> this is what I have in mind, except I'd like it to be auto-generated:
03:33:53 <Peaker> @let unnil [] = Just () ; unnil _ = Nothing ; uncons (x:xs) = Just (x,xs) ; uncons _ = Nothing
03:33:54 <pumpkinbot>  Defined.
03:33:59 <Peaker> (and for every other data constructor in existence)
03:34:03 <Peaker> @type unnil
03:34:04 <pumpkinbot> forall t. [t] -> Maybe ()
03:34:10 <Peaker> @type uncons
03:34:11 <pumpkinbot> forall t. [t] -> Maybe (t, [t])
03:34:29 <Peaker> @let safeTail = fmap snd uncons
03:34:30 <pumpkinbot>  Couldn't match expected type `(a, b)'
03:34:32 <Thunder> Peaker: You might abstract it to Monoid
03:34:39 <Peaker> @let result = (.)
03:34:40 <pumpkinbot>  Defined.
03:34:44 <ski_> Peaker : what do you intend to do with `data Foo a b = forall x. MkFoo x ((x,a) -> (x,b))', e.g. ?
03:34:45 <Peaker> @let safeTail = (result . fmap) snd uncons
03:34:45 <pumpkinbot>  Defined.
03:35:02 <Peaker> Thunder: how?
03:35:39 <ski_> (/me thinks Thunder might intend s/Monoid/MonadPlus/)
03:35:42 <Thunder> Peaker: Using scanr and take the second last result (if exists)
03:35:43 <Peaker> ski_: Add (exists a. ...) to the language :)
03:36:05 <athos> > safeTail []
03:36:06 <ski_> Peaker : count me on for that
03:36:06 <pumpkinbot>   Nothing
03:36:11 <athos> !
03:36:16 <Peaker> Thunder: Not trying to find a way to express that pattern match as a fold, though
03:36:41 <Peaker> athos: ?
03:36:49 <athos> ? :)
03:37:01 <Peaker> athos: Are you impressed, surprised, or what? :)
03:37:07 <ski_> .
03:37:24 <athos> satisfied
03:37:26 <Peaker> athos: (result . fmap) changes the functor content of a function result via the given function (the functor here is a Maybe)
03:38:21 <athos> :t ((.).fmap)
03:38:22 <pumpkinbot> forall a a1 b (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> f a1) -> a -> f b
03:41:49 <Peaker> @go semantic editor combinators
03:41:50 <pumpkinbot> http://conal.net/blog/posts/semantic-editor-combinators/
03:41:50 <pumpkinbot> Title: Conal Elliott » Semantic editor combinators
03:41:53 <idnar> uhm
03:42:19 <idnar> oh right
03:42:24 <idnar> @type fmap`fmap`fmap
03:42:25 <pumpkinbot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
03:42:29 <lilac> > let safeTail x = snd <$> uncons x in safeTail []
03:42:30 <pumpkinbot>   mueval: Prelude.read: no parse
03:43:03 <lilac> @type fmap fmap fmap fmap fmap
03:43:04 <pumpkinbot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
03:43:16 <lilac> neat!
03:43:31 <idnar> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap mushroom mushroom
03:43:44 <idnar> @type fmap fmap fmap fmap
03:43:45 <pumpkinbot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
03:43:51 <idnar> eeeek
03:43:54 <lilac> > fmap fmap fmap fmap fmap (*2) (+1) [1,2,3,4,5]
03:43:55 <pumpkinbot>   [4,6,8,10,12]
03:43:58 <idnar> @type fmap fmap fmap fmap fmap fmap
03:43:59 <pumpkinbot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
03:44:10 <idnar> @type fmap fmap fmap fmap fmap fmap fmap
03:44:11 <pumpkinbot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
03:44:17 <idnar> @type fmap fmap fmap fmap fmap fmap fmap fmap
03:44:18 <pumpkinbot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
03:44:34 <lilac> @type fmap ap fmap ap fmap ap fmap ap fmap ap fmap ap fmap
03:44:35 <pumpkinbot>     Occurs check: cannot construct the infinite type:
03:44:35 <pumpkinbot>       a = f a -> f (t -> a1 -> t1 -> t2 -> t3 -> t4 -> t5 -> t6)
03:44:35 <pumpkinbot>     Probable cause: `fmap' is applied to too few arguments
03:44:48 <ski_> hm, no rank-2 in pumpkinbot ?
03:45:18 <idnar> can you do @type with lunabot?
03:45:23 <SamB_XP> ski_: don't you need to be somewhat explicit about rank-2?
03:45:45 <mc__> I want to write a little interpreter in haskell, do you think this data structure is suited for representing the parse tree "data Node = Node String [String] Node"  (I hope I'm not double posting this - my wlan connection recently died)
03:46:11 <ski_> @let tluser :: (forall a. (a -> b0) -> (a -> b1)) -> (b0 -> b1); tluser f = f id
03:46:12 <pumpkinbot>  <local>:4:19:
03:46:12 <pumpkinbot>      Illegal operator `.' in type `forall a . ((a -> b0) -> (a...
03:46:17 <ski_> see ?
03:46:20 <Peaker> Lemmih: you there?
03:46:31 <Lemmih> Peaker: Maybe.
03:46:39 <idnar> sneaky
03:46:48 <Peaker> Lemmih: do you intend to upload a new version of SDL-ttf with my patch soon?
03:48:19 <Lemmih> Peaker: Just tried. It doesn't look like a darcs patch.
03:48:43 <Peaker> Lemmih: right, just patch -p1 < the.patch ?
03:49:07 <Peaker> Lemmih: I applied it to SDL-ttf-0.5.2 as it is in hackage
03:49:16 <SamB_XP> Peaker: why not darcs ?
03:49:28 <Peaker> SamB_XP: I already had the SDL-ttf package in my ~/.cabal/packages directory
03:49:31 <Peaker> easier to just patch that
03:50:07 <SamB_XP> Lemmih: hmm, you don't seem to list the repository or a website in your .cabal file
03:50:28 <lilac> mc__: that doesn't look like a tree to me. looks more like an infinite list of (String, [String])
03:51:06 <Lemmih> SamB_XP: Feel free to send me a patch for that (:
03:51:22 <Lemmih> Peaker: Pushed.
03:51:27 <lilac> mc__: you might want something more like "data Node = Node String [Node]" or even "data Node a = Node a [Node]"
03:51:37 <SamB_XP> Lemmih: I was just pointing out things that might have demotivated Peaker from seaking out your repository ;-)
03:51:38 <Peaker> Lemmih: thanks
03:51:56 <lilac> @src Data.Tree.Tree
03:51:56 <pumpkinbot> Source not found. The more you drive -- the dumber you get.
03:52:35 <mc__> yeah, you're right, at least I need [Node]
03:52:37 <Peaker> Lemmih: did you bump the version number? cabal upgrade sdl-ttf says nothing has to be upgraded
03:52:50 <SamB_XP> Peaker: did you cabal update ?
03:52:58 <SamB_XP> Peaker: plus maybe it's not "preferred"
03:53:05 <Lemmih> Peaker: I only updated the darcs repo.
03:53:09 <Peaker> Lemmih: oh
03:53:17 <Peaker> Lemmih: does that automatically go to hackage somehow?
03:53:21 <SamB_XP> no ...
03:54:17 <Peaker> Lemmih: sorry to be such a nag, but do you plan to put it on hackage soon? :-)
03:54:19 <Thunder> @define  let safe f a = f (\x -> Left . a x . either id id) . Right
03:54:33 <Thunder> @define safe f a = f (\x -> Left . a x . either id id) . Right
03:55:10 <Thunder> @let safe f a = f (\x -> Left . a x . either id id) . Right
03:55:11 <pumpkinbot>  Defined.
03:55:26 <lilac> @type let safe x y = unsafePerformIO (evaluate x `catch` \_ -> evaluate y) in safe
03:55:27 <pumpkinbot> Not in scope: `unsafePerformIO'
03:55:44 <Thunder> > safe foldr (*) 2  [1..3]
03:55:45 <pumpkinbot>   Left 12
03:55:53 <Thunder> safe foldr (*) 2 []
03:56:02 <Thunder> > safe foldr (*) 2 []
03:56:03 <pumpkinbot>   Right 2
03:56:23 <Lemmih> Peaker: Should be online in a few minutes.
03:56:32 <ski_> @type safe
03:56:33 <pumpkinbot> forall t b1 c b a1 a c1. ((t -> Either b1 b1 -> Either c b) -> Either a1 a -> c1) -> (t -> b1 -> c) -> a -> c1
03:57:04 <Thunder> Either is used to distinguish between initial data and applied data
03:57:21 <edbond> How can I rid of IO monad? System.Directory.doesDirectoryExist returns IO Bool. I want to use it in &&.
03:57:22 <ski_> why do you want to distinguish between those ?
03:57:36 <ski_> edbond : `myBool <- System.Directory.doesDirectoryExist'
03:57:37 <Peaker> Lemmih: oh, great, thanks!
03:57:41 <Thunder> So if nothing happend, you can detect this case afterwards
03:57:56 <ski_> (edbond : also, you can't get out of the `IO' monad)
03:58:00 <lilac> @hoogle (a -> c) -> (b -> c) -> (Either a b -> c)
03:58:00 <pumpkinbot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
03:58:00 <pumpkinbot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
03:58:11 <lilac> @hoogle Either a a -> a
03:58:11 <pumpkinbot> Distribution.ReadE ReadE :: String -> Either ErrorMsg a -> ReadE a
03:58:11 <pumpkinbot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
03:58:11 <pumpkinbot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
03:58:38 <RayNbow`> @hoogle IO a -> a
03:58:38 <pumpkinbot> Foreign unsafePerformIO :: IO a -> a
03:58:38 <pumpkinbot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
03:58:38 <pumpkinbot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:59:40 <chrisdone> in Freenode #haskell, Monads get YOU!
04:00:27 <SamB_XP> that must save a lot of time
04:00:32 <lilac> in soviet #haskell, the IO monad cannot escape from YOU?
04:00:56 <chrisdone> haha
04:01:29 <Thunder> @let safeL _ [] = Nothing; safeL f xs = Just $ f xs
04:01:29 <pumpkinbot>  Defined.
04:01:38 <Thunder> >safeL tail ""
04:02:13 <Thunder> Peaker: Which of those safe functions are you looking for?
04:02:23 <lilac> let m a = an understanding of monads and a. if m a -> b, then m a -> m b
04:02:49 <lilac> now all we need is a way of adding an understanding of monads to an arbitrary knowledge base, and understanding of monads forms a monad
04:02:53 <ski_> lilac : but that's comonadic ..
04:03:18 <lilac> ski_: understanding monads is comonadic? well, that explains a /lot/
04:03:22 <ski_> ("if m a -> b, then m a -> m b", i.e.)
04:03:29 <Peaker> Thunder: I defined the family of functions I was looking for, example:   uncons :: [a] -> Maybe (a, [a]) ; uncons (x:xs) = Just (x,xs) ; uncons _ = Nothing
04:03:34 <lilac> ski_: yeah, too early in the morning for me :)
04:03:35 <ski_> @type (=<<)
04:03:36 <pumpkinbot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
04:04:08 <SamB_XP> ski_: that's just flipped bind
04:04:13 <Thunder> lilac: @type flip (>>=)
04:04:22 <ski_> SamB_XP : yes, and .. ?
04:04:40 <SamB_XP> it's not comonadic ...
04:04:51 <ski_> no, but "if m a -> b, then m a -> m b" is
04:05:06 <lilac> SamB_XP: we have m a -> b implies m a -> m b, and m a -> a
04:08:26 <cizra> I've seen GHC runtime take command-line arguments.
04:08:28 <cizra> Can this feature be turned off in case I need absolute control over command-line arguments for myself?
04:08:45 <cizra> (I don't actually need it right now, just curious)
04:11:19 <MarcWeber> cizra I don't get your question. Can you give some more context?
04:12:35 <cizra> MarcWeber: Well, if you compile something with GHC, you can give the resulting program some command-line arguments that get automagically used by it, without having to write the code for them.
04:13:01 <MarcWeber> Ah the +RTS etc ..
04:13:05 <cizra> Yea
04:13:09 <Peaker> if I want to upload my widget set library to hackage -- how do I do this?
04:13:26 <MarcWeber> cizra: Try #ghc or the mailinglist. I don't konw. I don't even know wether this is desirable
04:14:08 <hugo___> i feel sexy today
04:14:16 <fasta> cizra: I doubt the value, but if you really want, you can just compile your own GHC while removing all of the command line parsing +RTS stuff.
04:14:18 <pejo> Peaker, have you got a hackage user?
04:14:24 <ben_h> hugo___: lovely
04:14:29 <hugo___> :)
04:14:31 <byorgey> cizra: apparently if you give a first argument of --RTS all the remaining arguments will go to your program, regardless of whether any of them are +RTS or not
04:14:41 <Peaker> pejo: I don't think so
04:14:44 <cizra> fasta: Now that would be extreme
04:14:49 <hugo___> haskell coders are sexy people
04:14:51 <byorgey> which isn't quite what you are asking about, but close
04:14:53 <cizra> byorgey: A partial solution, but a solution nonetheless.
04:15:01 <fasta> cizra: it is the only way if you want a real solution
04:15:09 <pejo> Peaker, once you have the user it's fairly straightforward. Mail someone to get a user, the instructions are somewhere on hackage.
04:15:41 <ski_> @vixen do you find hugo___ sexy?
04:15:41 <pumpkinbot> me, sexy? i do my best :)
04:16:02 <cizra> fasta: Actually I don't want a real solution, I wanted to know if it exists. But I'll keep it in mind. Thank you all.
04:16:05 <Peaker> pejo: I think I did get a user on code.haskell.org - is that the same?
04:16:06 <SamB_XP> @vixen asl
04:16:06 <pumpkinbot> 19/f/California
04:16:17 <hugo___> @vixen i love you
04:16:17 <pumpkinbot> you love me? you don't even know me
04:16:30 <SamB_XP> Peaker: no, that isn't the same as hackage
04:16:34 <byorgey> Peaker: no, the Hackage accounts are separate
04:16:48 <SamB_XP> I don't think the hackage accounts are Unix accounts, for one
04:16:52 <hugo___> is this the new lambdabot ?
04:16:54 <ski_> @vixen asr
04:16:54 <pumpkinbot> ever feel like you're going around in circles?
04:17:11 <byorgey> Peaker: http://hackage.haskell.org/packages/accounts.html
04:17:11 <SamB_XP> for two, hackage is on a different machine
04:17:16 <hugo___> @vixen make love
04:17:16 <pumpkinbot> blah
04:17:38 <hugo___> i guess it does not parse makefiles :)
04:17:42 <ben_h> pumpkinbot: http://xkcd.com/537/ sometimes.
04:18:53 <ski_> hugo___ : pumpkinbot is lambdabot's substitute, during her vacation
04:19:22 <hugo___> oh nice :)
04:19:24 <Peaker> byorgey: thanks. I mailed him.  Now I need to see how to create a .cabal build system for my package
04:20:44 <hugo___> did lambdabot went on vacations with hpaste ?
04:22:16 <ski_> after, i think
04:22:25 <SamB_XP> hmm, why is hpaste still in the topic anyway ?
04:22:28 <hugo___> i really liked hpaste... :( the design was clean and simple...
04:22:39 <SamB_XP> @go hpaste2
04:22:39 <hugo___> isn't it going to come back after the dead ?
04:22:40 <pumpkinbot> http://twitter.com/shapr
04:22:40 <pumpkinbot> Title: Twitter / shapr
04:22:42 <SamB_XP> hmm.
04:22:45 <SamB_XP> not quite!
04:22:48 <hugo___> hmm
04:22:49 <SamB_XP> @go hpastetwo
04:22:50 <pumpkinbot> No Result Found.
04:22:55 <SamB_XP> @where hpaste2
04:22:56 <pumpkinbot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
04:23:00 <SamB_XP> anyway, go there!
04:23:06 <hugo___> but that one is ugly :(
04:23:11 <hugo___> i prefer pastebin :(
04:23:40 <SamB_XP> @tell mmorrow hugo___ thinks your hpaste is ugly
04:23:40 <pumpkinbot> Consider it noted.
04:28:10 <Peaker> is it alright to name my SDL wrapper HaskGame (in the spirit of the SDL wrapper for Python called Pygame)?
04:28:38 <ozy`> hugo___: d00d y u th1nk 1s t3h 00gl3???
04:28:44 <SamB_XP> nobody is going to lynch you
04:28:45 <Peaker> Graphics.UI.HaskGame doesn't yet completely abstract SDL away, though
04:28:56 <SamB_XP> does Pygame ?
04:29:00 <Peaker> SamB_XP: Yeah
04:29:08 <Peaker> I plan for it to completely hide SDL, but its not yet there
04:29:16 <Peaker> I wonder if its okay to upload a half-arsed wrapper so I can upload LUI which depends on it
04:29:28 <SamB_XP> well, stick a .SDL in the non-abstracted parts
04:29:42 <ozy`> hugo___: in all seriousness, the hpase2 UI isn't any more cluttered than the hpaste layout, from what I can see
04:29:55 <SamB_XP> hugo___: so what are your complaints ?
04:30:39 <Peaker> SamB_XP: the non-abstracted stuff are SDL types that I didn't create isomorphic types for, yet
04:31:46 <hugo___> i dont like the color, it is ugly
04:32:08 <SamB_XP> hugo___: the color
04:32:35 <SamB_XP> Peaker: well, doesn't that make sense to put in Graphics.UI.Haskgame.SDL ?
04:32:51 <Peaker> SamB_XP: they're already in Graphics.UI.SDL
04:32:58 <SamB_XP> Peaker: oh
04:33:00 <SamB_XP> that wasn't taken ?
04:33:12 <Peaker> SamB_XP: They're in SDL, not in my library, I don't wrap them
04:33:18 <SamB_XP> ah!
04:33:26 <SamB_XP> well, half-done wrappers are fine, sure
04:33:49 <Peaker> SamB_XP: I do have: getEvents that has a result: SDL.Event rather than some Event type of mine, I'd hate to put the function in a separate namespace for this though
04:34:20 <Peaker> I have: type Event = Graphics.UI.SDL.Event   in my wrapper
04:34:31 <Peaker> And I export this fake wrapper
04:34:37 <Peaker> but you're supposed to use SDL for now to deal with it
04:38:43 <inbuninbu> newbie question: suppose i have a vector, or a point, that i want to use with a function... but i want one function to handle different dimensions of it... 1,2,3, etc.... is there an elegant way to do this, without relying on lists, which might have too few elements, and thus doesn't seem especially type-safe?
04:39:13 <FunctorSalad> inbuninbu: the "vec" package does exactly that :)
04:39:28 <FunctorSalad> you have a seperate type for every n
04:40:01 <FunctorSalad> (won't work if n is only known at runtime though, AFAIK)
04:40:36 <hynek> map hi channel
04:40:39 <nikki93> @src elem
04:40:39 <pumpkinbot> elem x    =  any (== x)
04:40:50 <inbuninbu> FunctorSalad: thanks!
04:40:55 <nikki93> @src any
04:40:55 <pumpkinbot> any p =  or . map p
04:41:07 <inbuninbu> @karma+ FunctorSalad
04:41:07 <pumpkinbot> FunctorSalad's karma raised to 1.
04:41:17 <nikki93> @src or
04:41:17 <pumpkinbot> or    =  foldr (||) False
04:41:20 <Peaker> oh please!  channelUsers "#haskell" >>= mapM sayHi
04:41:27 <FunctorSalad> :)
04:41:34 <hackage> Uploaded to hackage: hexpat-pickle 0.1
04:41:34 <hackage> Uploaded to hackage: SDL-ttf 0.5.5
04:42:19 <hynek> Peaker: Didn't know there is a new API!!1!
04:42:35 <Peaker> hynek: IRC is not purely functional :)
04:43:17 <hynek> Are we just inventing the "Greeting Monad"?
04:43:30 <hynek> .o0( Greet () )
04:46:06 <hugo___> FunctorSalad: nice nick :)
04:46:27 <Peaker> > [1280*800,1300*720]
04:46:28 <pumpkinbot>   [1024000,936000]
04:47:05 <boegel> yo gang
04:47:32 <boegel> is there a readily available function in the Prelude, or Data.List or something, that returns all the unique elements of a given list?
04:47:54 <Saizan> nub
04:47:55 <dobblego> > nub [1, 1, 2, 3, 2, 1, 4, 3, 2, 3, 5]
04:47:56 <pumpkinbot>   [1,2,3,4,5]
04:47:57 <boegel> it's not that hard to implement it myself, but why reinvent the wheel, right..
04:48:07 <boegel> nub? what kind of name is that?!? :)
04:48:13 <boegel> no wonder I couldn't find it
04:48:18 <boegel> @src nub
04:48:18 <pumpkinbot> nub = nubBy (==)
04:48:21 <Saizan> it's O(n^2), because it works with Eq
04:48:29 <dobblego> @hoogle (Eq a) => [a] -> [a]
04:48:31 <pumpkinbot> Data.List nub :: Eq a => [a] -> [a]
04:48:31 <pumpkinbot> Data.List delete :: Eq a => a -> [a] -> [a]
04:48:31 <pumpkinbot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
04:48:32 <boegel> Saizan: hmm, i see
04:48:43 <dobblego> you couldn't find it because you didn't use hoogle :)
04:48:51 <boegel> Saizan: so it's worthwhile to implement a better one?
04:48:57 <Axman6> if you need better performance, map head . group . sort might be quicker
04:49:08 <boegel> dobblego: well, I didn't think of using the (Eq a) part
04:49:09 <Saizan> map head . group . sort is slower
04:49:16 <Axman6> maphead group sort... something sounds sus there
04:49:20 <BONUS> just cram it into a set
04:49:30 <BONUS> if you don't need the ordering
04:49:32 <Saizan> even a Set is not lazy enough :P
04:49:42 <Axman6> yeah, toList . fromList
04:49:45 <FunctorSalad> boegel: "1594, variant of dialectal knub, probably a variant of knob. Figurative meaning "point, gist" first recorded 1834."
04:49:52 <Saizan> you want to accumulate seen elements in a Set and test membership there
04:50:10 <Saizan> boegel: it's worthwile only if your list is quite large, i think
04:50:20 <boegel> Saizan: define large :)
04:50:26 <boegel> Saizan: mine is 11,000 elements
04:50:42 <boegel> Saizan: and I do care about the order of the elements
04:51:00 <boegel> Saizan: so, I'd use nub . sort, unless implement my own nub would be quicker
04:51:37 <Saizan> ah, you want to sort the elments anyway?
04:52:06 <FunctorSalad> can you specialise an already-compiled function like nub?
04:52:28 <Saizan> with RULES, maybe?
04:52:36 <FunctorSalad> ah, right
04:52:56 <Saizan> boegel: if you need/want to sort the list then map head . group . sort is fine
04:54:13 <boegel> Saizan: k, good, thanks
04:54:20 * boegel looks into group
04:55:30 <boegel> hmm, group is bloody interesting for my purposes...
04:55:46 <byorgey> @seen dcoutts
04:55:46 <pumpkinbot> dcoutts is in #haskell. I last heard dcoutts speak 10h 34m 4s ago.
04:56:42 <Saizan> (btw my comment earlier saying "(map head . group . sort) is slower" is quite sloppy, the point is that it has to traverse the whole list before returining any result)
04:58:37 <boegel> @src group
04:58:37 <pumpkinbot> group = groupBy (==)
04:59:37 <Peaker> cabal-install doesn't recognize the GPL or LGPL license?
04:59:58 <byorgey> @ask dcoutts what would it take to get cairo split out into its own package and cabalised?
04:59:58 <pumpkinbot> Consider it noted.
05:00:13 <Peaker> why is BSD3 a known license, but neither GPL3 or LGPL3 are known?
05:00:20 <FunctorSalad> Peaker: I thought you can just use your own LICENSE file
05:00:29 <ivanm> byorgey: in general, dcoutts has said that for gtk2hs to be cabalised, c2hs needs updating to work with cabal
05:00:41 <ivanm> Peaker: because of backwards compatability
05:00:44 <FunctorSalad> Peaker: "license-file: LICENSE:
05:00:53 <FunctorSalad> "license-file: LICENSE"
05:00:55 <ivanm> they licenses listed are those that were there from the beginning
05:01:04 <byorgey> ivanm: I see.  I wonder if that applies to cairo in particular.
05:01:09 <Peaker> FunctorSalad: I guess I'll just release it BSD for now. I can always switch to GPL later, nobody will close-source my current version :)
05:01:11 <ivanm> but dcoutts tells me that they're going to make it more flexible for cabal-2
05:01:17 <ivanm> byorgey: *shrug*
05:13:17 <BONUS> ((+) `on` (+1)) 2 3
05:13:21 <BONUS> > ((+) `on` (+1)) 2 3
05:13:22 <pumpkinbot>   7
05:14:24 <guenni> hi, how do I have to "lift" or "fmap" this to make it work: dropWhile doesFileExists listOfFilenames ?
05:14:55 <BONUS> what's the type of doesFileExists
05:14:58 <BONUS> and listOfFilenames
05:15:12 <guenni> BONUS: a -> IO Bool
05:15:28 <guenni> list of filenames = [FilePath]
05:15:34 <BONUS> aha, hmm let's see
05:15:42 <Thunder> @src on
05:15:43 <pumpkinbot> (*) `on` f = \x y -> f x * f y
05:16:35 * cizra male, 23, looking for a GUI library for short-term relationships
05:17:14 <Axman6> chessguy_work: i hear gtk2hs is looking for a new somebody
05:17:22 <Axman6> uhm cizra even
05:17:27 <chessguy_work> hm?
05:17:32 <chessguy_work> oh
05:18:00 <BONUS> guenni: i'd mapM doesFileExists over listOfFilenames
05:18:08 <BONUS> and then you'd have an IO [Bool] and [FilePath]
05:18:53 <BONUS> and then bind the IO [Bool] to a [Bool], zip them, and then do a return . dropWhile fst
05:19:03 <guenni> BONUS: well the list is infinite, so that's not really an option
05:19:03 <cizra> Axman6: Actually, I want to write a simple game, SDL sounded ideal. But it lacks things like UI widgets, which kinda causes unnecessary work. Ideas?
05:19:06 <earthy> or you could apply   liftM dropWhile
05:19:12 <BONUS> ah i see
05:19:29 <mc__> I'm trying to port a little interpreter I wrote in ruby to haskell. In ruby I had an expression base class from which all the expressions derive. Now I'm trying to model something like that in haskell. I have a data type for representing the information contained in each expression and a typeclass with only one function, namely "evaluate". But I'm somehow stuck. I need different expressions to behave differently, do I need  
05:19:51 <guenni> earthy: for some reason that doesn't seem to work, that was my first try
05:20:40 <scook0> if you map doesFileExists you'll get a [IO Bool]
05:20:40 <BONUS> then you might have to do it all in the IO monad then
05:21:09 <scook0> then if you write a monadic version of dropWhile
05:21:46 <guenni> scook0: so there is no way of lifting of fmap-ing?
05:21:54 <scook0> though I guess you'll still end up with a [IO Bool], which is probably not what you want
05:22:56 <scook0> what do you want to end up with? the infinite tail of the list of paths beginning with the first nonexistent one?
05:23:01 <pejo> mc, I'd use a function "evaluate" that takes an expression and returns a value (or expression).
05:23:27 <guenni> scook0:  exactly and from that I use the head
05:23:27 <chessguy_work> mc__, we would usually model something like that with an algebraic data type
05:23:49 <earthy> guenni: why not use filter and head?
05:24:05 <earthy> (as filterM does exist)
05:24:14 <guenni> guenni: because doesFileEcxist is in the IO Monad
05:24:27 <guenni> earthy: because doesFileEcxist is in the IO Monad
05:24:34 <earthy> @type filterM doesFileExist ["a","b"]
05:24:35 <chessguy_work> guenni, are you talkign to yourself? :)
05:24:36 <pumpkinbot> Not in scope: `doesFileExist'
05:24:40 <earthy> oh, right.
05:24:54 <chessguy_work> @hoogle doesFileExist
05:24:54 <pumpkinbot> System.Directory doesFileExist :: FilePath -> IO Bool
05:25:04 <earthy> @hoogle filterM
05:25:04 <pumpkinbot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
05:25:14 <earthy> @type filterM System.Directory.doesFileExist ["a","b"]
05:25:15 <pumpkinbot> IO [FilePath]
05:25:16 <wdong> I want to load an immutable unboxed array from a binary file for numerical computation.  How can I easily implement hLoadArray::Handle->Int->IO UArray Int Float ?
05:25:43 <BONUS> guenni i wrote a dropWhileM
05:25:46 <BONUS> czech this out
05:25:55 <guenni> chessguy_work: actually sometime I do
05:26:02 <BONUS> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1132#a1132
05:26:03 <chessguy_work> guenni,  :)
05:26:05 <BONUS> see if this works for you
05:26:35 <BONUS> fromFirstNonExisting <- dropWhileM doesFileExist FileNames
05:27:01 <fasta> Peaker: PyGame is LGPL, btw.
05:27:18 <Peaker> fasta: I'll be BSD3 for now
05:27:27 * Peaker is restructuring the widget set for appropriateness as a hackage package
05:27:30 <guenni> BONUS: thx, I'm sure it does, I had hoped being able to recycle existing code though
05:27:35 <Peaker> I have a working HaskGame package that builds with cabal
05:27:49 <BONUS> yeah that's always better if you can :\
05:28:01 <Saizan> wdong: with the Storable class i think
05:28:17 <bastl> what is the difference between a constructor and a function ? are constructors first class citizens too?
05:28:17 <guenni> BONUS: ie not writing my own, just plumbing existing functions with fmap or liftM or something
05:28:28 <scook0> @nopaste
05:28:28 <pumpkinbot> Haskell pastebin: http://hpaste.org/new
05:28:33 <wdong> Saizan: thanks a lot, I'll check it out.
05:28:43 <BONUS> i wonder if this could be done with fmapping or <*> or whatever
05:28:57 <yitz> Saizan, wdong what about Data.Binary.Strict?
05:29:52 <mc__> pejo: but when I have a lot of different expressions that function would become bloated
05:30:05 <bastl> anyone ?
05:30:16 <mc__> chessguy_work: isn't Node an ADT ?
05:30:27 <scook0> http://haskell.pastebin.com/f62de806a
05:30:34 <chessguy_work> mc__, Node?
05:30:45 <scook0> guenni: something like that?
05:30:59 <scook0> (extracting the pattern to a more general monadic function is left as an exercise)
05:31:10 <mc__> chessguy_work: the type I declared in my code "data Node = Node String [String] Node [Node]"
05:31:13 <BONUS> scook0: yeah i pasted a dropWhileM :)
05:31:17 <Saizan> yitz: yeah, that too, i thought there was an instance Storabe (UArray ..) though
05:31:33 <chessguy_work> mc__, sorry, did you paste your code somewhere? if so, i missed it
05:31:36 <scook0> oh, too slow :(
05:31:48 <BONUS> if you have functions with predicates (a -> m Bool), you have to convert them to monadic versions on your own sometimes i think
05:31:50 <mc__> chessguy_work: here it is http://gist.github.com/56910
05:32:29 <wdong> yitz: Do you mean the Binary package which is not in the standard library?
05:32:36 <chessguy_work> mc__, ok, yes, i would call that an ADT
05:32:42 <guenni> scook0: I'm sure that works too, as I said I did want to recycle what's there though instead of writing a new version
05:32:43 <BONUS> otherwise with stuff where you have just m a somewhere, you can use sequence to your advantage
05:33:13 <chessguy_work> mc__, but i would just write evaluate :: Node -> ...
05:33:24 <guenni> scook0: thx though
05:33:29 <mc__> chessguy_work: I just made that correction
05:33:34 <yitz> Saizan: not sure if there is. but even if so - how does that help?
05:33:56 <chessguy_work> mc__, another idea: consider using record syntax for Node
05:34:05 <chessguy_work> mc__, to label what the different parts are for
05:34:20 <yitz> wdong: Data.Binary (the lazy one) and Data.Binary.Strict are on hackage. Question is, which one to use.
05:34:48 <mc__> chessguy_work: good idea
05:35:25 <chessguy_work> mc__, also, i really doubt you need to write your own split function. there's probably something in preslude that will do what you want. if not, the Split library will undoubtedly be able to handle it
05:35:29 <chessguy_work> @hoogle [a] -> [[a]]
05:35:29 <pumpkinbot> Data.List inits :: [a] -> [[a]]
05:35:29 <pumpkinbot> Data.List tails :: [a] -> [[a]]
05:35:29 <pumpkinbot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
05:35:41 <yitz> wdong: with lazy, you could probably just use the usual functions for constructing an array. with strict, you may need something like what Saizan says to interpret your binary glob of data in memory as an array.
05:35:43 <chessguy_work> @hoogle+
05:35:44 <pumpkinbot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
05:35:44 <pumpkinbot> Data.List group :: Eq a => [a] -> [[a]]
05:35:44 <pumpkinbot> Control.Applicative many :: Alternative f => f a -> f [a]
05:36:09 <wdong> yitz: I'm sure I'll touch every bit of the data, so I think it is Data.Binary.Strict.  The problem is I want to avoid any kind of parsing but directly load the data to memory.  I have gigs of Floats and I guess parsing would be slow.
05:36:18 <yitz> wdong: Foreign.Marshal.Array
05:37:09 <yitz> wdong: yeah. but lazy is not necessarily bad here even so. it's probably simpler.
05:37:29 <Axman6> wdong: maybe if you write a program to parse them into their binary reps, and then could save that as a binary, you might be ok?
05:37:35 <yitz> wdong: problem is, Data.Binary.Strict and Data.Binary api are not compatible :(
05:37:36 <mc__> chessguy_work: I did not find anything suitable that comes with haskell, the definition is very simpel anyways
05:37:59 <yitz> Axman6: I think the binary packages will do that for him automatically
05:38:10 <chessguy_work> > words "abc de fghij"
05:38:11 <pumpkinbot>   ["abc","de","fghij"]
05:38:18 <Axman6> probably, but i was thinking that if he did it once, he might save some time
05:38:27 <mc__> chessguy_work: words also splits on other characters than space
05:38:30 <yitz> Axman6: how so?
05:38:58 <chessguy_work> @hoogle a -> [a] -> [[a]]
05:38:58 <pumpkinbot> Data.List intersperse :: a -> [a] -> [a]
05:38:58 <pumpkinbot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
05:38:58 <pumpkinbot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
05:39:03 <Axman6> well, conferting from text to float on gigs of data can't be that efficient can it?
05:39:04 <chessguy_work> @hoogle+
05:39:04 <pumpkinbot> Data.List insert :: Ord a => a -> [a] -> [a]
05:39:04 <pumpkinbot> Data.List delete :: Eq a => a -> [a] -> [a]
05:39:04 <pumpkinbot> Prelude (++) :: [a] -> [a] -> [a]
05:39:18 <wdong> Axman6: That's a good idea.  I'm a newbie and I've no idea what class you are talking about.
05:39:26 <chessguy_work> hm
05:39:32 <yitz> Axman6: no the binary packages will read them as binary, as wdong says he already has on disk
05:39:46 <yitz> he or she
05:39:58 <Axman6> but they were saying that they needed parsing...
05:40:09 <SamB> yitz: that sounds pretty non-portable :-(
05:40:16 <bastl> Is there a generic way to get the name of a constructor of a value as String ?
05:40:43 <yitz> SamB: I think we should all move over to #haskell.lojban
05:40:43 <SamB> bastl: well, you could try using Data ...
05:41:06 <SamB> I don't even know lojban
05:41:32 <yitz> SamB: oh, you mean the binary file? well, wdong, what format is your data in currently?
05:41:34 <hackage> Uploaded to hackage: HsOpenSSL 0.5.1
05:41:34 <hackage> Uploaded to hackage: SDL 0.5.5
05:41:34 <hackage> Uploaded to hackage: logfloat 0.11.0.1
05:41:36 <bastl> SamB :Data ... ?
05:41:43 <FunctorSalad> bastl: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Data.html#v%3AtoConstr
05:43:24 <yitz> wdong: are your gigs of floats in some binary format on disk?
05:43:53 <yitz> wdong: and you're sure they'll all fit in memory?
05:44:06 <FunctorSalad> bastl: you'll have to use the -XDeriveDataTypeable flag and derive (Data,Typeable) for your type
05:44:20 <wdong> yitz: Just consecutively stored 32bit float numbers.
05:46:14 <wdong> yitz: they are high dimensional feature vectors, about 1~2G in size and I want to scan them.
05:46:32 <bastl> FunctorSalad: thanks, am experimenting already ...
05:48:06 <wdong> yitz: Since I only want an one-pass scan, memory won't be a problem. But parsing would surely add a lot of overhead.
05:48:26 <yitz> yeah
05:51:00 <Saizan> pumpkinbot: @join #haskell.it
05:51:55 <Thunder> Somebody had looked for a more relaxing nub: @let nub2 member insert empty = catMaybes . tail . map fst . scanl (\(_,s) x -> if x `member` s then (Nothing, s) else (Just x, x `insert` s)) (undefined, empty)
05:54:07 <wdong> yitz, Saizan, Axman6, SamB:  Thank you guys a lot for providing the information.  I know which part of the library to look into now.
05:54:30 <Axman6> wdong: sounds like interesting stuff btw :)
05:55:08 <yitz> wdong: ok good luck. come back later, there are people who have done stuff like this. e.g., dons would know the right way to do this
05:55:59 <Axman6> dons would know the right way to do anything though
05:58:02 <Saizan> ?seen dcoutts
05:58:02 <pumpkinbot> dcoutts is in #haskell. I last heard dcoutts speak 11h 36m 20s ago.
06:02:18 <mc__> I dont get whats wrong with this http://gist.github.com/56920
06:04:39 <lilac> mc__: you put the context in the wrong place
06:05:01 <lilac> your code says that, with n :: Node, expression n :: Expression a => a
06:05:22 <lilac> which means that /for all instances of Expression a/, expression n is of type a
06:05:26 <jkff> mc___: Nothing is wrong, the compiler tells you what it means in the most precise way possible. However, you seem to be solving the task with the wrong tool; namely, you are using OOP-style polymorphism in a functional language.
06:05:40 <lilac> what you want, i think, is that /for some instance of Expression a/, expression n is of type a
06:05:44 <Axman6> oh hooray! i'm responsible for HsColour 1.12!
06:05:59 <lilac> mc__: for that, you need to put the context /before/ the 'Node'
06:06:11 <lilac> data Node = Expression a => Node a Node [Node]
06:07:04 <malcolmw> Axman6: although I do wonder how many complaints I might get, from people who upgrade blindly and wonder why their code suddenly loses its colouring :-)
06:08:15 <Axman6> malcolmw: heh, yeah, i was thinking it might be a good idea to maybe have it use class="blah hs-blah", and stick a notice somewhere warning of the coming change. but i'd still be having my problem in that case :\
06:08:30 <inbuninbu> newbie question: i'm having problems with the following...
06:08:33 <inbuninbu> data TypeA = TypeA Float
06:08:33 <inbuninbu> data TypeB = TypeB Float
06:08:34 <inbuninbu> data TypeAorB = TypeA | TypeB
06:08:43 <inbuninbu> any advice on what i'm missing?
06:08:53 <lilac> inbuninbu: constructor names for TypeAorB
06:08:55 <Axman6> thanks for the reply by the way, this is my first real contribution to a haskell project (even if it is really minor)
06:09:05 <lilac> inbuninbu: data TypeAorB = A TypeA | B TypeB
06:09:58 <Axman6> inbuninbu: also, you almost always want to be using Doubles instead of floats :)
06:09:59 <tehgeekmeister> i remember i once used replicateM to generate all permutations of a list of ints from one to n, anyone know how i did it?
06:10:11 <inbuninbu> thanks!
06:10:22 <inbuninbu> i'm not quite getting it though; it's a name clash?
06:10:53 <inbuninbu> A is the type constructor for a TypeAorB of TypeA?
06:10:59 <Axman6> whoot! i found chocolate on my desk!
06:11:19 <inbuninbu> and B for the TypeAorB of Type B?
06:11:48 <tehgeekmeister> oh, replicateM by itself doesn't seem to do that
06:12:12 <inbuninbu> ah, i get it now! thanks!
06:12:36 <inbuninbu> @karma+ lilac
06:12:36 <pumpkinbot> lilac's karma raised to 1.
06:12:50 <inbuninbu> @karma+ Axman6
06:12:50 <pumpkinbot> Axman6's karma raised to 1.
06:13:01 <Axman6> @karma
06:13:01 <pumpkinbot> You have a karma of 1
06:13:08 <Axman6> damn it pumpkinbot!
06:13:21 * Axman6 has a karma of like 5 on lambdabot.
06:13:26 <Axman6> or i used to :(
06:13:46 <Axman6> inbuninbu: thing++ is the usuall way to do that btw ;)
06:14:13 <inbuninbu> Axman6: ok, thanks. was your karma reset because of me?
06:14:19 <Axman6> nah
06:14:35 <Axman6> lambdabot is in hospital, so pumpkinbot is filling in
06:15:11 * Axman6 watches http://www.todaysbigthing.com/2009/01/30 again
06:15:20 <inbuninbu> right... random extra question
06:15:32 <inbuninbu> Prelude> [0.0,0.1..1.0]
06:15:32 <inbuninbu> [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.6000000000000001,0.7000000000000001,0.8,0.9,1.0]
06:15:42 <inbuninbu> why the imprecision?
06:15:50 <BONUS> it's just how floating points work
06:16:00 <BONUS> they don't have infinite precision
06:16:16 <BONUS> using enumerations of floating point ranges is usually not a good idea
06:16:21 <inbuninbu> shouldn't it be [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
06:16:25 <BONUS> > map (/10.0) [0...]
06:16:26 <jkff> And their *finite* precision is measured in binary digits, not in decimal ones
06:16:26 <pumpkinbot>   mueval: Prelude.read: no parse
06:16:49 <BONUS> > map (/10.0) [0...]
06:16:50 <pumpkinbot>   mueval: Prelude.read: no parse
06:16:50 <BONUS> > map (/10.0) [0..]
06:16:51 <jkff> inbuninbu: Try writing out the bits of 0.4 by hand and then convert that to decimal form
06:16:52 <pumpkinbot>   [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1....
06:16:52 <BONUS> oh whoops
06:17:18 <jkff> :t map (/10.0) [0..]
06:17:19 <pumpkinbot> forall a. (Enum a, Fractional a) => [a]
06:17:24 <mc__> lilac: thank you!
06:17:33 <jkff> > map (/10.0) [0..] :: [Double]
06:17:34 <pumpkinbot>   [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1....
06:17:40 <jkff> > map (/10.0) [0..] :: [Float]
06:17:41 <pumpkinbot>   [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1....
06:17:43 <jkff> Hmm
06:17:49 <inbuninbu> good idea, i'll try that. i do remember that 1/3 rounds up instead of down
06:18:10 <inbuninbu> well, not 1/3
06:18:18 <Axman6> > 1/10::Double
06:18:19 <pumpkinbot>   0.1
06:18:38 <Axman6> > 1/3::Double
06:18:39 <pumpkinbot>   0.3333333333333333
06:19:03 <FunctorSalad> > execStateT (replicateM 3 m) [] where m = do { x <- lift [1,2,3]; modify (x:) } -- tehgeekmeister
06:19:04 <pumpkinbot>   [[1,1,1],[2,1,1],[3,1,1],[1,2,1],[2,2,1],[3,2,1],[1,3,1],[2,3,1],[3,3,1],[1...
06:19:06 <jkff> Ah, that's it: [0,0.1..] loses more precision
06:19:11 <FunctorSalad> ;))
06:19:30 <jkff> I think the Show instance for floats shows the closest decimal number to the magnitude
06:20:00 <jkff> So, in case of map (/10) [0..], the closest decimal number turns out to be 0.*, and in the case of [0,0.1..] it turns out to be worse
06:20:26 <jkff> zipWith (-) (map (/10) [0..]) [0,0.1..] :: [Float]
06:20:34 <jkff> > zipWith (-) (map (/10) [0..]) [0,0.1..] :: [Float]
06:20:35 <pumpkinbot>   [0.0,0.0,0.0,0.0,0.0,0.0,0.0,-5.9604645e-8,-5.9604645e-8,-1.1920929e-7,-1.1...
06:20:45 <jkff> > zipWith (-) (map (/10) [0..]) [0,0.1..] :: [Double]
06:20:46 <pumpkinbot>   [0.0,0.0,0.0,-5.551115123125783e-17,0.0,0.0,0.0,0.0,1.1102230246251565e-16,...
06:21:10 <inbuninbu> thanks, that gives me a lot to chew on
06:21:22 <ordnungswidrig> :t lcm
06:21:23 <pumpkinbot> forall a. (Integral a) => a -> a -> a
06:22:10 <inbuninbu> @karma++ jkff FunctorSalad Axman6
06:22:11 <pumpkinbot> jkff's karma raised to 1.
06:22:25 <inbuninbu> @karma++ FunctorSalad
06:22:25 <pumpkinbot> FunctorSalad's karma raised to 2.
06:22:30 <Axman6> inbuninbu: it's Axman6++ :P
06:22:41 <inbuninbu> @karma Axman6++
06:22:42 <pumpkinbot> Axman6++ has a karma of 0
06:22:53 <Axman6> just Axman6++, nothing else XD
06:23:08 <inbuninbu> Axman6++
06:23:15 <inbuninbu> hmm
06:23:25 <Axman6> doesn't matter where you say it in a sentense either, i could just say inbuninbu++ and it should work
06:23:29 <Axman6> @karma inbuninbu
06:23:29 <pumpkinbot> inbuninbu has a karma of 1
06:23:45 <tehgeekmeister> FunctorSalad: that is definitely not what i did.  but a cool example, thanks!
06:24:01 <tehgeekmeister> FunctorSalad: i wasn't really generating permutations before, i've realized.
06:24:43 <BONUS> @karma
06:24:43 <pumpkinbot> You have a karma of 1
06:24:49 <BONUS> w00tha
06:24:56 <FunctorSalad> tehgeekmeister: I'm not either, you still have to filter out the ones with repetitions...
06:25:02 <tehgeekmeister> FunctorSalad: yeah, i just realized that
06:25:13 <tehgeekmeister> FunctorSalad: that does the same as what i was doing before
06:25:23 <tehgeekmeister> >replicateM 3 [1..3]
06:25:36 <tehgeekmeister> > replicateM 3 [1..3]
06:25:37 <pumpkinbot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
06:25:50 <ehird> @karma-- lambdabot
06:25:50 <pumpkinbot> lambdabot's karma lowered to 3.
06:25:54 <tehgeekmeister> except it orders them differently
06:26:36 <FunctorSalad> doh, was thinking of that one at first but thought it wouldn't work :(
06:27:06 <jamii> leksah would be easier to install if it depended on a version of gtk2hs that existed
06:27:44 <tehgeekmeister> FunctorSalad: any idea of how to filter for uniqueness?
06:28:04 <Peaker> I uploaded my first packages to hackage!  But now they're not installable - it complains that it cannot find the .cabal file, how come?
06:28:17 <Peaker> can anyone who knows cabal-install  install haskgame  and tell me if they know why it fails?
06:28:19 <jamii> code.haskell.org/gtk2hs is version 0.9.13 and leksah requires >=0.10.0
06:28:32 <lilac> > reverse <$> replicateM 3 [1..3]
06:28:33 <pumpkinbot>   [[1,1,1],[2,1,1],[3,1,1],[1,2,1],[2,2,1],[3,2,1],[1,3,1],[2,3,1],[3,3,1],[1...
06:28:36 <FunctorSalad> tehgeekmeister: (\x -> length x == length (nub x))? if perfomance matters I think I'd not even generate the non-permutations though
06:29:01 <tehgeekmeister> FunctorSalad: it doesn't really matter, i'm trying to generate permutations really quick to help me reason about some math
06:29:23 <lilac> > permutations [1..3]
06:29:24 <pumpkinbot>   mueval: Prelude.read: no parse
06:29:37 <lilac> > permutations [1..3] :: [[Int]]
06:29:38 <pumpkinbot>   mueval: Prelude.read: no parse
06:29:38 <FunctorSalad> > filter (\x -> x == nub x) (replicateM 3 [1..3])
06:29:39 <pumpkinbot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
06:29:43 <tehgeekmeister> oh!  in data.list
06:29:46 <Peaker> The ".cabal" file is in there, but cabal-install fails to find it, how come?
06:29:47 <tehgeekmeister> ther'es permutations
06:30:12 <lilac> @hoogle [a] -> [(a,[a])]
06:30:12 <pumpkinbot> Data.Char readLitChar :: ReadS Char
06:30:12 <pumpkinbot> Numeric readFloat :: RealFrac a => ReadS a
06:30:12 <pumpkinbot> Prelude reads :: Read a => ReadS a
06:30:17 <tehgeekmeister> @hoogle permutations
06:30:17 <pumpkinbot> No results found
06:30:37 <bastl> Using Data.Data, how would I apply a constructor to get a normal value ?
06:30:45 <bastl> @hoogle mkConstr
06:30:45 <pumpkinbot> Data.Generics.Basics mkConstr :: DataType -> String -> [String] -> Fixity -> Constr
06:31:05 <mopped> @src foldl
06:31:06 <pumpkinbot> foldl f z []     = z
06:31:06 <pumpkinbot> foldl f z (x:xs) = foldl f (f z x) xs
06:31:23 <lilac> > let drops [] = []; drops (x:xs) = (x,xs):(fmap.fmap.map) (x:) drops xs in drops [1,2,3]
06:31:24 <pumpkinbot>   Couldn't match expected type `(t, [t])' against inferred type `[b]'
06:31:41 <lilac> > let drops [] = []; drops (x:xs) = (x,xs):(fmap.fmap.fmap) (x:) drops xs in drops [1,2,3]
06:31:42 <pumpkinbot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
06:32:01 <jamii> Peaker: Not sure yet, but I do get the same error. Digging....
06:32:17 <lilac> > let drops [] = []; drops (x:xs) = (x,xs):(fmap.fmap.fmap) (x:) drops xs; permutations xs = drops xs >>= \(y,ys) -> y:permutations ys in permutations [1,2,3]
06:32:18 <pumpkinbot>   [1,2,3,3,2,2,1,3,3,1,3,1,2,2,1]
06:32:31 <cizra>   let (host, port) = case args of
06:32:31 <cizra>                           ["-s", port] -> ("", read port)
06:32:42 <cizra> -- read port fails because port is of an unknown type
06:32:51 <Peaker> jamii: oh maybe its the UID/GID ?
06:33:02 <cizra> How to add a type signature saying that port can be read?
06:33:05 <Peaker> ah, no,
06:33:14 <bastl>  @hoogle toConstr
06:33:19 <jamii> Peaker: I'm installing as root so it shouldnt matter
06:33:52 <jamii> The cabal file is readable but the directory where cabal install is looking (/tmp/TMPhaskgame) doesnt exist
06:34:15 <mopped> @src foldr
06:34:15 <pumpkinbot> foldr f z []     = z
06:34:15 <pumpkinbot> foldr f z (x:xs) = f x (foldr f z xs)
06:34:36 <Saizan> jamii: that gets deleted at the end
06:35:05 <tehgeekmeister> huh!  the cycles of a^n in [1..p] mod p where p is a prime, each transition is either one or another of the group elements, and the two elements always add up to identity (or the order if you don't use mod p arithmetic)
06:35:07 <tehgeekmeister> very cool
06:35:34 <bastl> @type fromConstrB
06:35:35 <pumpkinbot> forall a. (Data a) => (forall a1. (Data a1) => a1) -> Constr -> a
06:35:58 <mc__> lilac: sorry to bother you again, but  I'm still not really getting it. I dont understand how to combine the class constraint with the record syntax, this time I tried it so http://gist.github.com/56920
06:36:02 <jamii> Saizan: I put an unwriteable directory there and cabal didnt complain about not being able to write
06:36:18 <Peaker> Saizan: my package tarball has a .cabal file just like everyone else, but install on it fails because it can't find the .cabal file?
06:36:27 <jamii> Though Im not sure it would check for an error that obscure
06:37:18 <lilac> > let drops [] = []; drops (x:xs) = (x,xs):(fmap.fmap.fmap) (x:) drops xs; permutations [] = [[]]; permutations xs = drops xs >>= \(y,ys) -> (fmap fmap fmap) (y:) permutations ys in permutations [1,2,3]
06:37:19 <pumpkinbot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
06:38:04 <lilac> mc__: data Node = Expression a => Node { expression :: a, parent :: Node, children :: [Node] }
06:39:06 <Saizan> Peaker: if i get SDL to comple i'll try it too
06:39:14 <Peaker> Saizan: thanks
06:39:59 <mc__> lilac:  that gives me "Not in scope: type variable `a'"
06:40:52 <FunctorSalad> mc__: have -fglasgow-exts on?
06:41:07 <Thunder> lilac: Is this really efficient or just written to confuse the reader?
06:41:34 <hackage> Uploaded to hackage: lui 0.0.1
06:41:34 <hackage> Uploaded to hackage: haskgame 0.0.1
06:41:34 <hackage> Uploaded to hackage: hscolour 1.12
06:41:47 <mc__> FunctorSalad: yes
06:42:04 <lilac> mc__: ok, you need 'data Node = forall a. Expression a => ...'
06:42:19 <tehgeekmeister> hum, sorry to keep asking, i'm having problems thinking right now: how about generating differences between consecutive items in a list?
06:42:29 <lilac> mc__: and -XExistentialQuantification or something that implies it (such as -fglasgow-exts)
06:42:32 <jamii> Saizan: You dont need to compile SDL - it fails before it gets to checking the dependencies
06:42:39 <Saizan> Peaker: same error with cabal-install-0.6.0, with 0.6.1 works tough
06:42:53 <Peaker> Saizan: weird!
06:42:58 <Peaker> Saizan: I am not doing anything fancy, that I know of
06:42:59 <yitz> Thunder: search for permutations on the library list to see the thread where twan developed the efficient version that was recently added to Data.List.
06:43:03 <bastl> FunctorSalad: you know how to use Data.Data? I wanna construct new Constructors and use them to generate Values.
06:43:07 <yitz> Thunder: it's pretty amazing
06:43:29 <Saizan> Peaker: have you created the package with cabal sdist?
06:43:50 <FunctorSalad> bastl: you can't really add new constructors add runtime
06:43:59 <Peaker> Saizan: no
06:44:00 <mc__> yeah now it works, but why do I need that forall stuff? isn't something like this not doable in Haskell 98 ?
06:44:03 <Peaker> Saizan: didn't know that existed
06:44:10 <Cale> tehgeekmeister: zipWith (-) xs (tail xs)
06:44:16 <bastl> what does mkConstr do then?
06:44:18 <yitz> @type zipWith subtract `ap` tail -- tehgeekmeister
06:44:19 <pumpkinbot> forall a. (Num a) => [a] -> [a]
06:44:23 <bastl> @hoogle mkConstr
06:44:23 <Peaker> Saizan: Will do, thanks
06:44:24 <pumpkinbot> Data.Generics.Basics mkConstr :: DataType -> String -> [String] -> Fixity -> Constr
06:44:34 <tehgeekmeister> huh, that didn't work when i tried something similar, cale
06:44:39 <lilac> mc__: i'd imagine not. i /think/ haskell'98 is arranged so that all typeclasses can be erased at compile time
06:44:42 <tehgeekmeister> perhaps i made some subtle error
06:44:43 <tehgeekmeister> i'm sure i did
06:44:48 <rwbarton> mc__: Unless you have been meaning to write data Node a = Node { expression :: a, parent :: Node a, children :: [Node a] }, then no
06:44:50 <FunctorSalad> bastl: it is probably used in Data instances
06:44:53 <Cale> > let diffs xs = zipWith (-) xs (tail xs) in diffs [1,2,3,4]
06:44:54 <pumpkinbot>   [-1,-1,-1]
06:44:57 <yitz> > zipWith subtract `ap` tail [1,2,4,7,11]
06:44:58 <pumpkinbot>   Couldn't match expected type `[a] -> [a]'
06:45:01 <bastl> hmm
06:45:12 <Cale> > let diffs xs = zipWith subtract xs (tail xs) in diffs [1,2,3,4]
06:45:13 <pumpkinbot>   [1,1,1]
06:45:19 <lilac> > zipWith subtract `ap` tail $  [1,2,4,7,11]
06:45:20 <pumpkinbot>   [1,2,3,4]
06:45:21 <andun> how do i make a pointer to pointer in haskell ffi? (like [CInt] -> Ptr (Ptr CInt) or something)
06:45:21 <yitz> > (zipWith subtract `ap` tail) [1,2,4,7,11]
06:45:22 <pumpkinbot>   [1,2,3,4]
06:45:24 <Cale> (depending on which way you want it)
06:45:25 <mc__> rwbarton: alright
06:45:40 <Cale> > let diffs xs = zipWith subtract <*> tail in diffs [1,2,3,4]
06:45:41 <pumpkinbot>       Overlapping instances for Show ([a] -> [a])
06:45:41 <pumpkinbot>        arising from a use o...
06:45:48 <Cale> > let diffs = zipWith subtract <*> tail in diffs [1,2,3,4]
06:45:49 <pumpkinbot>   [1,1,1]
06:45:51 <mc__> thank you all for your help - you guys are all extraordinary helpful!
06:45:59 <rwbarton> andun: perhaps this will be helpful:
06:46:01 <yitz> Cale: I'm probably the 100th to ask, but - what's the prognosis for \bot?
06:46:02 <rwbarton> @hoogle withMany
06:46:02 <pumpkinbot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
06:46:17 <FunctorSalad> bastl: Constr just *represents* a constructor, it's not internal magic :)
06:46:18 <Cale> yitz: Yesterday I couldn't log in to lispy's machine. Let me check.
06:46:54 <FunctorSalad> bastl: the "deriving (Typeable,Data)" clause just generates code that returns the right Constr if you call toConstr
06:47:15 <Cale> yitz: ping codersbase.com -- when it comes back up, then lambdabot will be able to.
06:47:23 <andun> rwbarton: i'm trying to pass a CInt-array to a C function, so the C function can write to it
06:47:24 <yitz> sigh. ok.
06:47:29 <yitz> thanks
06:47:38 <FunctorSalad> bastl: you could use the "derive" or "DRiFT" packages if you'd like to see what the code for the Data instance looks like
06:47:47 <rwbarton> andun: can write to the array, or can write a new address to a pointer to an array?
06:48:37 <bastl> Why should that be interesting? Could i learn how to do it myself ?
06:49:25 <Axman6> i'm taking a look at http://www.haskell.org/haskellwiki/Performance/GHC#Core_by_example, and in the line k  n     = [ a1, a2, a3, a4, a5, a6, a7, a8, a9 ], should there be something between k and n?
06:49:38 <Axman6> i'm guessing ==?
06:49:50 <FunctorSalad> bastl: I don't think there's much point in writing the instances manually... I just wanted to point out that the Data mechanism has no special compiler support except for the "deriving" thing
06:50:07 <rwbarton> Axman6: the next sample has > there
06:50:16 <BONUS> Axman6: k lookslike a predicate
06:50:26 <Thunder> andun: withArray is perfect marshalling: C does use a continous space to store the values. It does not use pointers to pointers.
06:50:31 <BONUS> if n is a, then k looks like a -> Bool
06:50:41 <BONUS> oh wait hmm
06:50:45 <BONUS> but then it says k + 1
06:50:45 <Axman6> ah, so it does, i should fix that
06:50:45 <Axman6> and my internet should stop dying
06:50:45 <bastl> damnit that looked really good ...
06:51:40 <Axman6> | () !k !n !alt !a1 !a2 !a3 !a4 !a5 !a6 !a7 !a8 !a9 !False = undefined <- um what?
06:52:02 <Axman6> i've seen what they're trying to do on other pages done with `seq`, but... what?
06:52:29 <andun> rwbarton: can write to the array, so i can extract info from it later. in C: int foo[10]; bar(&foo), and then i want to access foo in haskell
06:52:34 <FunctorSalad> that one puzzled me too Axman6
06:52:45 <FunctorSalad> looks like ! meant seq at that time?
06:52:49 <Axman6> ah yes, where x ! y = x `seq` y
06:53:11 <ktne> hello everyone
06:53:17 <rwbarton> andun: there's no reason to write bar(&foo) and not bar(foo), is there?
06:53:18 <ktne> i'm trying to implement my own programming language :)
06:53:49 <andun> rwbarton: ah, right. :-P
06:53:53 <SParry> hello, im just installing Gtk2Hs and its complaining about me not having GHC 6.6.1 (I have 6.10.1) - is this still the case or can i just ignore and continue?
06:53:58 <ktne> is there some online resource about type checking?
06:54:04 <andun> rwbarton: thanks
06:54:05 <rwbarton> andun: Right, then withArray is what you want
06:54:11 <ktne> other than quick hacks
06:54:17 <ktne> which i did so far
06:54:18 <Axman6> damnit, all this high performance code is making me want to learn C :(
06:54:32 <int80_h> learn C!
06:54:58 <qebab> The cool thing about C is that it's so small, and terse. The problem with C is that it's so small and terse. :)
06:55:25 <Axman6> int80_h: i will be this semester :)
06:55:27 <orbitz> i would nto call C terse
06:55:31 <Axman6> need to find a good C book
06:55:34 <qebab> knowing a bit of C is good
06:55:42 <qebab> orbitz: well, potentially, it can be...
06:55:43 <jeffz`> Axman6: K&R is _the_ good C book
06:55:48 <int80_h> Axman6: k&6, second edition
06:55:49 <chrisdone> ktne: Types and Programming Languages
06:55:52 <Axman6> yeah, i'm planning on getting it
06:55:54 <orbitz> writign C code is not particular concise
06:55:55 <yitz> qebab: the cool thing and problem with C is that it's inherently tied to a very specific hardware architecture.
06:55:57 <int80_h> I mean K&R oops
06:55:58 <orbitz> nor brief
06:56:03 <inbuninbu> if i have a data type : data AorB = AB_A A | AB_B B, and i give a value of type AorB to a function, how do i tell whether it is A or B?
06:56:09 <qebab> yitz: nearly portable assembly :)
06:56:27 <Axman6> inbuninbu: pattern match
06:56:35 <chrisdone> not really portable assembly though is it
06:56:38 <rwbarton> inbuninbu: f :: AorB -> C; f (AB_A a) = ...; f (AB_B b) = ...
06:56:43 <yitz> qebab: vonNeumann
06:56:47 <ktne> chrisdone: thanks
06:56:51 <Axman6> f (AB_A x) = ...; f (AB_B X) = ...
06:57:01 <qebab> yitz: yeah
06:57:02 <Axman6> S/X/X
06:57:03 <tehgeekmeister> having problems with overlapping parsers in parsec; what is the general approach to avoiding such problems?
06:57:09 <Axman6> arch, caps
06:57:14 <Axman6> s/X/x
06:57:16 <Axman6> -_-
06:57:18 <tehgeekmeister> (not sure how to make them non-overlapping, so far all attempts have failed.)
06:57:38 <inbuninbu> rwbarton: thanks! (rwbarton++)
06:59:48 <mopped> I'm trying to do a simple function that returns the elements of a binary tree, i've commented a sample input and what i'd expect to be the output, but i'm not sure why my program wont compile, any tips? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1135
07:00:19 <mopped> oh, wait, it should call elementshelper perhaps..
07:00:36 <mopped> that doesnt work either :P
07:01:30 <ehird> Sure is a lot of web frameworks recently.
07:02:16 <ehird> 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
07:02:49 <Axman6> haq
07:02:51 <Axman6> -q*
07:03:15 <Axman6> @remember ehird 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
07:03:15 <pumpkinbot> Okay.
07:03:23 * ehird is famous
07:03:29 <Axman6> we need lambdabot back :(
07:03:33 <ehird> I agree.
07:03:46 <int80_h> why did it leave?
07:03:50 <ehird> We broke it.
07:03:55 <int80_h> I *neeeeeed* lambdabot
07:03:58 <ehird> Someone re-remember that quote when lambdabot's back so I don't have to and thereby look egotistical, thanks
07:03:59 <ehird> :P
07:04:31 <Thunder> mopped: Please look carefully on your  xxx : x : xxx construct
07:05:18 <Axman6> ehird: i'll try and remember
07:05:24 <ehird> hur hur
07:08:13 <mopped> it calls elements helper on the left/right, if they are a leaf they return x so I'd have x:x:x (and then back to elements) :[], what am i doing wrong :E
07:08:48 <Thunder> No, you'll concat two lists and an element.
07:09:15 <Axman6> :t (:)
07:09:16 <pumpkinbot> forall a. a -> [a] -> [a]
07:09:37 <Thunder> @type \x y z -> x :y:z
07:09:38 <pumpkinbot> forall a. a -> a -> [a] -> [a]
07:09:49 <Workybob> gah
07:09:55 <Workybob> <$> has the wrong precidence
07:10:15 <Workybob> f <$> Just . something $ x -- this should work
07:10:15 <Axman6> haskell could have prevented this! http://www.labnol.org/internet/microsoft-outlook-ruins-birthday-cake/6824/
07:10:23 <Workybob> (and be equiv to Just . f . something $ x)
07:10:36 <ehird> Axman6: actually, I think it improved the cake.
07:10:42 <ehird> that's awesome.
07:10:43 <Axman6> heh
07:10:48 <Workybob> I'd be proud to get that cake
07:10:58 <ehird> we should forbid the use of haskell for personalized cake services.
07:11:01 <ehird> put it in a EULA
07:11:29 <mopped> why will there be a list concating Thunder? surely there would just be a long string of x:x:x:... and then it leaves helper and becomes []?
07:11:38 <Thunder> Axmann: You prefer a cake with type errors printed on it?
07:11:49 <Axman6> indeed
07:12:15 <Thunder> mopped: elementsHelper :: BinaryTree a -> [a]
07:13:16 <mopped> hm.. does it? how does it become a list if its never consed onto a []
07:13:30 <flipflap> </cake>
07:14:25 <Workybob> mopped: because lists have two constructors – (:) and []
07:14:29 <Workybob> each is equally valid
07:14:52 <mopped> aha
07:14:58 <Workybob> > fix (5 :)
07:14:59 <pumpkinbot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
07:15:03 <mopped> so ++ [x] ++ would be better?
07:15:46 <Axman6> ++ is infixr right?
07:15:47 <Thunder> mopped: Try adding type annotations: elemens :: BinaryTree a -> [a] ... then list the cases directly. You do not need a helper.
07:16:19 <Thunder> mopped: Yes, (++) solves on of your mistakes
07:16:19 <mopped> right, got it thanks
07:16:20 <tehgeekmeister> foldl (++) "" [listostrings] is the efficient way to concat strings, right?  whereas foldr would be the slow way?
07:16:59 <Axman6> wtf named C C anyway huh? makes it hard to search for :(
07:17:07 <Axman6> There has been an error!
07:17:08 <Axman6> You must supply a search string longer than two characters.
07:17:12 <Thunder> thegeekmeister: No. The efficient way is foldr (.) id . map (++)
07:17:46 <Axman6> tehgeekmeister: foldr is the fast way i think
07:17:57 <Axman6> > foldr f z [a,b,c,d]
07:17:58 <Thunder> Axman6: It's the successor of B, so the name C is perfect
07:17:58 <pumpkinbot>   f a (f b (f c (f d z)))
07:18:01 <PeterK> i think it was either dennis or ritchie
07:18:18 <tehgeekmeister> Axman6: oh, thanks
07:18:33 <jeffz`> Axman6: http://www.iso-9899.info/ is a good place for C stuff.
07:18:39 <Axman6> foldr cons nil remember
07:19:50 <Axman6> how good is the K&R book at teaching you C?
07:21:20 <PeterK> any book will do it pretty well if you write a lot too... as a reference it might be superior tho.
07:21:50 <mstr> K&R is good
07:22:21 <flipflap> Isn't K&R a bit.. outdated by now?
07:23:08 <jeffz`> flipflap: why would it be outdated?
07:23:24 <mstr> just a brainfart?
07:23:33 <flipflap> Because it has been written a while ago
07:23:48 <jeffz`> flipflap: C hasn't really changed since then.
07:24:10 <flipflap> That might be true
07:24:16 <flipflap> But the way people are writing code may have changed
07:24:19 <flipflap> Common idoms
07:24:29 <flipflap> New way to do things?
07:24:48 <mstr> I believe that was a "yes"
07:25:23 <jeffz`> flipflap: it teaches the language, not idioms or style.
07:25:27 <Baughn> pumpkin: Oh, and the IO exception stuff /is/ exported, via GHC.IOBase. There isn't a more general interface, apparently.
07:25:28 <cads> flipflap: check out some sample CUDA code
07:25:46 * Baughn shrugs. Must-use-ghc isn't much of a constraint.
07:25:48 <flipflap> That's just a personal guess, I haven't really gotten into C
07:26:15 <cognominal> I don't  quite get the difference between the keywords type and data
07:26:19 <cognominal> help!
07:26:28 <mstr> type is just alias?
07:26:31 <ksandstr> "type" is like c's typedef. data is like c's struct
07:26:35 <Olathe> data lets you make up a data type, type just does aliases.
07:26:48 <cognominal> thx
07:26:49 <mopped> What would a fold function for a binary tree do? Qualitively
07:26:51 <flipflap> type is defining a synonme
07:27:15 <flipflap> While you could use SuperAwesomeStringOfCharacters for a String, the compiler won't care at all
07:27:19 <Olathe> mopped: Take each element and combine it into the result using the function.
07:27:22 <flipflap> if you used just String
07:27:25 <Baughn> mopped: Same as a fold for anything else - feed a function every value in a structure, with an accumulator
07:27:45 <cads> mopped: imagine first flattening the tree, then giving it to the normal fold function
07:28:15 <mopped> is there a typical order? or is that for me to decide
07:28:28 <Baughn> There's foldl and foldr, but..
07:28:46 <Baughn> You need both
07:29:31 <Olathe> mopped: You can make foldLIn, foldLPre, foldLPost, and the corresponding foldrs.
07:29:48 <Olathe> If the data is always on a leaf, you can just do foldl and foldr.
07:31:13 <Saizan> why not foldTree :: (b -> b -> b) -> (a -> b) -> Tree a -> b? for data Tree a = Branch (Tree a) (Tree a) | Leaf a
07:31:17 <rwbarton> The natural fold for a tree (catamorphism) takes a function that takes the values computed from the two subtrees and the data in the node and returns the value for the entire tree
07:31:34 <rwbarton> (and another function to deal with leaves)
07:31:51 <Olathe> Ahh, foldb.
07:31:56 <Saizan> and you can derive both orders from that
07:33:02 <Saizan> folding is not something specific to lists or linear structures
07:33:13 <stevan> hi, is it possible to implement a quickcheck prop :: IO Bool without unsafepio? thanks.
07:33:22 <rwbarton> Basically instead of the consistent nesting of a `f` (b `f` (c `f` ...)) you get an expression whose parenthesization reflects the tree structure
07:33:34 <Olathe> @bot
07:33:34 <pumpkinbot> :)
07:33:34 <lunabot>  :)
07:33:43 <cads> rwbarton: that is a pretty thought
07:34:07 <Thunder> stevan: No
07:34:27 <cads> mopped:http://en.wikipedia.org/wiki/Tree_traversal
07:35:15 <Olathe> > Leaf 5
07:35:17 <pumpkinbot>   mueval: Prelude.read: no parse
07:35:25 <Olathe> If only lambdabot had some sort of Tree.
07:35:40 <inbuninbu> data DataType = DataType Double ... what's the most concise way to pull the double out of the datatype in a function?
07:35:52 <ehird> Is there a simple, embeddable Haskell web server?
07:35:58 <inbuninbu> if there's a pattern-matching way, i can't figure it out
07:35:59 <ehird> inbuninbu: foo (DataType d) = ...
07:36:01 <Olathe> inbuninbu: (\Double b -> b)
07:36:10 <ehird> Olathe: er. no
07:36:14 <ehird> DataType
07:36:25 <Olathe> Oh :)
07:36:32 <Olathe> inbuninbu: (\DataType b -> b)
07:36:46 <ehird> but if you're just passing it to a func,foo (DataType d) = ...
07:36:46 <inbuninbu> thanks!
07:36:47 <Thunder> @hoogle Tree
07:36:48 <pumpkinbot> module Data.Tree
07:36:48 <pumpkinbot> Data.Tree data Tree a
07:36:48 <pumpkinbot> Text.XHtml.Debug treeColors :: [String]
07:36:48 <Olathe> getDouble (DataType d) = d
07:37:08 <Thunder> @type Data.Tree.empty
07:37:10 <pumpkinbot> Not in scope: `Data.Tree.empty'
07:37:23 <inbuninbu> thanks, that helps... i was wondering what the backslash did... Olathe++
07:37:59 <Olathe> You're welcome.
07:38:17 <Olathe> Hmm, the definition of foldTree is nice and concise.
07:38:25 <Axman6> inbuninbu: never heard of lambda expressions?
07:38:34 <flipflap> The more I get into haskell, the more I think it won't be a good language for my general programming :(
07:38:46 <inbuninbu> heard of them ;-) seemed like black magic
07:39:02 <wchogg> flipflap : I think those are fighting words to people around here. :p
07:39:19 <mopped> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1136 Is that inorder or preorder? It computes the value of the left tree and the node, and then the right tree? I've never really seen/used binary trees before so im a bit confused :P
07:39:21 <ehird> flipflap: you're wrong ;-)
07:39:56 <flipflap> While I can see it could be great for maths, it's really a mess if you need to carry around states, or highly IO depending things where you basically never get out of the IO monad (network applications as I like to create)
07:39:57 <Axman6> flipflap: what makes you think that?
07:40:08 <leadnose> mopped, that's inorder (I think)
07:40:24 <Axman6> flipflap: there are many people who would say it's excallent for that
07:40:40 <leadnose> at least my implementation of inorder walking was almost the same
07:40:46 <Olathe> The fold is preorder.
07:40:59 <Olathe> It has branch left right.
07:41:10 <flipflap> :/
07:41:19 <leadnose> oh, I was just looking at the "elements"
07:41:20 <mopped> inorder would just be swapping x and (fold f z l)?
07:41:31 <Olathe> Yep.
07:41:32 <lilac> inbuninbu: an easy way to extract the value is to write your type as 'data DataType = DataType { getDouble :: Double }'. this automatically generates a function 'getDouble :: DataType -> Double' for you.
07:41:34 <hackage> Uploaded to hackage: HaXml 1.19.5
07:41:36 <Cale> flipflap: Concurrency is really easy in Haskell, which is something you might appreciate for such applications.
07:41:37 <Olathe> You can check it with (++)
07:42:14 <Olathe> fold (++) "" (Branch (Node "b") "a" (Node "C))
07:42:30 <PeterK> i think maybe there's a difference between haskell being good for your everday programming and haskell being good for the way you already do your everyday programming. i know there is a difference for me.
07:42:38 <Olathe> preorder: "abc", inorder: "bac", postorder: "bca"
07:42:43 <leadnose> by the way, i was thinking whether it's inefficient to fold a tree by first "listifying" it by walking and then feeding it to the standard fold?
07:42:53 <Cale> flipflap: And IO is perhaps nicer than many imperative languages, even if it's not Haskell's particular strong point. One of the nice things about Haskell's way of handling IO is that actions are first class -- you can put them in data structures and pass them around without causing them to occur.
07:43:17 <Cale> flipflap: This means that you can effectively invent control structures as you need them.
07:43:23 <flipflap> Passing stuff around works with any kind of data in haskell, since it's lazy, no?
07:43:24 <Olathe> leadnose: With foldr, it will be minimized.
07:43:27 <inbuninbu> lilac: thanks, i've encountered that. unfortunately, i have several types based on Vectors, and having a thousand functions to pull them out of their wrapper types seems a little burdensome
07:43:35 <Olathe> leadnose: But it's best to do it without a list.
07:43:46 <Cale> flipflap: Well, the point here is not so much laziness...
07:43:49 <leadnose> Olathe, ok, thanks
07:43:55 <Cale> flipflap: as the fact that IO actions are values.
07:44:15 <Cale> (as are functions)
07:44:18 <lilac> inbuninbu: are you aware of generalized newtype deriving? it might help you out, depending on exactly what you're doing.
07:44:40 <ehird> guess not
07:45:18 <inbuninbu> lilac: i've seen it in some modules i was looking at, but haven't gotten to that part of Real World Haskell yet
07:45:57 <Cale> flipflap: Basically, IO works in Haskell by representing stuff to be done as values of a particular type. Normal Haskell evaluation (which reduces expressions into values) doesn't cause those things to happen. Eventually the 'main' of your program is such an action, and it gets carried out.
07:46:15 <inbuninbu> i know it makes two or more types from one, but how that differs from general datatypes, i have yet to learn
07:46:34 <cads> can anyone explain simply the notion of the derivative of a list or a tree?
07:46:46 <lilac> inbuninbu: when you have "data X = Y Z" (note, one constructor with one argument), you can write "newtype X = Y Z" instead
07:46:57 <lilac> inbuninbu: this is almost exactly the same, semantically.
07:46:58 <flipflap> I just need to find any good introducing tutorial, because Real World Haskell (the name reflects what I want) is SO long, I need a heckload of time to read one chapter, and by the end of that chapter, all is forgotten again, or I just skip it because there's too much talk about the same stuff over and over again. And all other tutorials are too academical..
07:47:20 <Olathe> I've started to think of IO as actions that you wrap with more and more things to do to the IO input.
07:47:30 <flipflap> "Learn yourself a Haskell" is really nice, but it's incomplete
07:47:30 <lilac> inbuninbu: as an extension (-XNewtypeDeriving), you can say "newtype X = Y Z deriving (...)" where ... is a list of typeclasses which Z is an instance of.
07:47:38 <cads> flipflap: what other languages have you played with?
07:47:57 <lilac> inbuninbu: and GHC will generate instances for type X of each of those classes
07:48:01 <flipflap> D
07:48:14 <flipflap> And some ruby, but ruby was boring agian
07:48:38 <Cthulhon> cads: http://homepage.mac.com/sigfpe/Computing/diff.html
07:48:47 <Olathe> Yeah, since I've restarted with Haskell lately, I don't like Ruby except for quick calculations and Haskell code generation.
07:48:49 <inbuninbu> lilac: i just skipped ahead a bit, and it looks like that is a bit better
07:49:36 <inbuninbu> "Beyond this, there's another important difference between
07:49:36 <inbuninbu> data and newtype. A type created with the data keyword has a bookkeeping cost at runtime, for example, in order to track which constructor created a value. A newtype value, on the other hand, can have only one constructor and so does not need this overhead. This makes it more space- and time-efficient at runtime. "
07:50:40 <Olathe> Does anyone know if Haskell' is using the new boxy types by default ?
07:51:33 <rwbarton> inbuninbu: in a way, newtype is "between" data and type
07:51:55 <rwbarton> inbuninbu: like data, it defines a new type which is distinct from any other type as far as the type checker is concerned
07:52:22 <cads> Olathe: what kind of framework do you use for generating haskell code from ruby?
07:52:37 <guenni> sry, what's the flag again for compiling an exe without the dos window poping up?
07:52:43 <cads> Cthulhon: that is the same paper I could not grok a year ago :D
07:52:54 <rwbarton> inbuninbu: but at runtime the representation of the newtype is identical to that of the underlying type, so after type checking it's kinda like a type synonym
07:52:55 <cads> I will try once more
07:53:03 <Olathe> cads: I just use the string with #{ } notation since it's simpler than a bunch of ++s or printfs in Haskell.
07:53:14 <Olathe> I wish Haskell had it.
07:53:44 <rwbarton> Olathe: Get mmorrow to implement it with quasiquotation
07:53:49 <rwbarton> if it hasn't been already
07:54:06 <Olathe> Hmm, I've never heard of that.
07:54:11 <Olathe> Let me look into it :)
07:54:29 <Thunder> Olathe: Whats wrong with funcional style using ShowS?
07:54:31 <rwbarton> Another question is, why do you need to generate Haskell code anyways :)
07:54:32 <inbuninbu> rwbarton: so if i want to make wrappers to keep different uses of the same data distinct, but still be able to use (derived) functions with it, i can use newtype...
07:55:05 <bastl> FunctorSalad: conversion from and to Trees of constructors: http://www.cs.vu.nl/boilerplate/testsuite/tree/Main.hs very valuable for dealing with ASTs and the like
07:55:43 <cognominal> listening the second part of spj presnetation at OSCON 2007 and it answers very well to my question on the difference between type and data
07:55:44 <rwbarton> inbuninbu: Right, newtype is good for saying "this String represents SQL and this String represents HTML and I want to keep them separate"
07:56:20 <Saizan> @bot
07:56:20 <pumpkinbot> :)
07:56:20 <lunabot>  :)
07:56:27 <rwbarton> inbuninbu: the the places where you wrap or unwrap the newtype are what you have to check to make sure you're manipulating the data sensibly
07:57:25 <BrokenClockwork> Okay, I want to generate randomly a list of Bools with n-length: gen <- getStdGen  \n
07:57:25 <BrokenClockwork> putStrLn $ take 5 $ randoms gen ... but where do I define, that I want to have Bools?
07:57:43 <inbuninbu> rwbarton: great, thanks for the explanation! that really helps. what a great tool. actually if i implement a typeclass(or just use Data.Vec), i don't think i'd even need to unwrap it
07:57:45 <Olathe> Thunder: I've never heard of ShowS.
07:59:07 <nikki93> Hey guys!
07:59:23 <rwbarton> inbuninbu: right, if the underlying type belongs to a type class, and you decide the operations of that class make sense for the wrapped type as well, you can use generalized newtype deriving
08:00:23 <Thunder> Olathe: http://www.haskell.org/tutorial/stdclasses.html -> 8.3 short description what the problem with (++) is and how it can be solved
08:00:28 <rwbarton> (for example, it probably doesn't make sense to have mappend concatenate two SQL statements)
08:01:02 <inbuninbu> rwbarton: right, that makes perfect sense. i'm liking haskell more and more every day
08:01:42 <inbuninbu> wow. 1am and i've got an interview tomorrow. thanks everyone, i feel like i'm getting my head around things a bit... rwbarton++ lilac++
08:01:43 <ehird> la la la woooooooooooooooooooooooooooooooo britain.
08:02:09 <int80_h> is there a way to add simple fractions, while retaining the same form?
08:02:31 <int80_h> ex. 1/4 + 1/2 = 3/4 not .75
08:02:48 <rwbarton> > 1%4 + 1%2
08:02:49 <pumpkinbot>   3%4
08:02:54 <rwbarton> :t (%)
08:02:55 <pumpkinbot> forall a. (Integral a) => a -> a -> Ratio a
08:03:02 <int80_h> nice~!
08:03:09 <FunctorSalad> @src Ratio
08:03:09 <pumpkinbot> data (Integral a) => Ratio a = !a :% !a
08:03:10 <rwbarton> and Rational = Ratio Integer
08:03:41 <FunctorSalad> is that why they're called rationals? :O
08:04:10 <FunctorSalad> seriously, I never made that connection
08:04:14 <nikki93> > "la la la w" ++ replicate 5 "o" ++ " britain."
08:04:16 <pumpkinbot>   Couldn't match expected type `Char' against inferred type `[Char]'
08:04:19 <rwbarton> Because they're ratios?  Stop the presses! :)
08:04:25 <nikki93> ??
08:04:31 <nikki93> pumpkinbot?
08:04:48 <rwbarton> "o" should be 'o'
08:04:54 <nikki93> rwbarton: Noticed.
08:04:57 <FunctorSalad> in my defense, "ratio" is not in my native lang ;)
08:05:08 <nikki93> > "la la la w" ++ replicate 5 'o' ++ " britain."
08:05:09 <pumpkinbot>   "la la la wooooo britain."
08:05:25 <FunctorSalad> I thought they were called "rational" because they're more rationally comprehendible than irrational numbers
08:05:28 <nikki93> For ehird. :)
08:06:07 <Olathe> > shows 5 ""
08:06:09 <pumpkinbot>   "5"
08:08:00 <FunctorSalad> the different linear algebra types in hackage should be unified :(
08:08:11 <Olathe> > let f :: [forall a. (Show a) => a]; f = foldr shows "" in f [0, 5, "hello"]
08:08:13 <pumpkinbot>   Couldn't match expected type `[forall a. (Show a) => a]'
08:08:20 <FunctorSalad> I know at least three sets: hmatrix, vec, vector-space
08:08:44 <Olathe> > let f :: forall a. (Show a) => [a] -> String; f = foldr shows "" in f [0, 5, "hello"]
08:08:45 <pumpkinbot>       No instance for (Num [Char])
08:08:45 <pumpkinbot>        arising from the literal `0' at <in...
08:08:47 <FunctorSalad> think it would do to just make the former two instances of vector-space's VectorSpace?
08:08:55 <Olathe> > let f :: [forall a. (Show a) => a] -> String; f = foldr shows "" in f [0, 5, "hello"]
08:08:56 <pumpkinbot>       No instance for (Show (forall a. (Show a) => a))
08:08:56 <pumpkinbot>        arising from a ...
08:09:05 <Saizan> Olathe: it doesn't work that way
08:09:06 <Olathe> Heh
08:09:30 <BrokenClockwork> I want a random list of Bools, I came so far: take 5 $ randoms getStdGen ... but where do I add, that I want [Bools] ?
08:09:44 <Saizan> you'd want f :: [exists a. Show a => a] -> String
08:10:01 <Saizan> but you've to encode that with an existential wrapper or the church encoding equivalent
08:10:09 <FunctorSalad> @type randoms
08:10:11 <pumpkinbot> forall g a. (RandomGen g, Random a) => g -> [a]
08:10:30 <rwbarton> @type getStdGen
08:10:30 <Saizan> like data AnyShow = forall a. Show a => AnyShow a; f :: [AnyShow] -> String
08:10:31 <pumpkinbot> IO StdGen
08:10:52 <FunctorSalad> BrokenClockwork: (randoms =<< getStdGen) :: IO [Bool]
08:11:13 <FunctorSalad> BrokenClockwork: or just do something with the list that makes it clear it must be [Bool] ;)
08:11:29 <Olathe> Ahh.
08:11:30 <FunctorSalad> err sorry
08:11:38 <Olathe> Thanks.
08:11:48 <FunctorSalad> (liftM randoms getStdGen) :: IO [Bool]
08:12:15 <lilac> "data IShow = forall a. Show a => IShow a"
08:12:16 * lilac ducks
08:12:43 <FunctorSalad> why "I"?
08:13:07 <lilac> FunctorSalad: interface (a la COM)
08:13:25 <FunctorSalad> isn't that type pretty equivalent to "String"? ;)
08:13:38 <Saizan> yeah :
08:13:40 <Saizan> :)
08:13:41 <FunctorSalad> since 'show' is the only thing you can do with the innards
08:14:12 <rwbarton> showsPrec never gets any love... :)
08:14:13 <lilac> it's closer to (String -> String)
08:14:24 <lilac> or possibly (Int -> String -> String)
08:14:29 <rwbarton> Ooh, and showList :)
08:14:36 <FunctorSalad> right...
08:14:41 * rwbarton stops listing irrelevant things
08:14:41 <Saizan> showList is an hack
08:15:23 <lilac> not allowing a [Char] instance to override a [a] instance is to blame, ultimately.
08:15:35 <lilac> IMO C++ handles that better
08:15:57 <flipflap> When doing IO in haskell, it feel like going into another language.. imperative..
08:16:01 <Saizan> it depends if you want to keep sane separate compilation or not
08:16:05 <flipflap> At least for the do statements
08:16:08 <FunctorSalad> with -XOverlappingInstances it should be ok
08:16:28 <lilac> FunctorSalad: doesn't it depend on the context in which the instance is resolved?
08:16:48 <lilac> (that is, i thought there were cases when it would pick up the [a] isntance instead of the String one)
08:17:09 <Saizan> (yes, if you don't import the String one)
08:17:11 <FunctorSalad> lilac: I thought it has to take the most specific instance
08:17:19 <Cale> flipflap: Well, a sort-of imperative language is what do-expressions are intended to simulate.
08:17:29 <FunctorSalad> (OverlappingInstances allows only overlaps where there is a most specific)
08:17:34 <rwbarton> lilac: I think that behavior only occurs with IncoherentInstances, which is pure evil
08:17:37 <Cale> flipflap: Of course, they're really something more general than that.
08:17:48 <lilac> FunctorSalad: f xs :: Show a => [a] -> String; f xs = show xs
08:17:50 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
08:17:51 * rwbarton finally gets around to reading the documentation for OverlappingInstances
08:17:52 <pumpkinbot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
08:18:00 <lilac> ^^ i thought in that case it would never use Show [Char] even if a == Char
08:18:11 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
08:18:11 <cads> Cthulhon: It's beginning to dawn on me, thanks for the link
08:18:12 <pumpkinbot>   ("hello","olleh","HELLO")
08:18:16 <FunctorSalad> lilac: didn't think of that...
08:18:30 <Cale> flipflap: Different monads, different meanings :)
08:18:49 <FunctorSalad> lilac: wouldn't that function call the dictionary?
08:18:53 <Cale> flipflap: But for IO at least, thinking of it as a kind of imperative language makes sense.
08:18:56 <flipflap> I think I better switch back to D :(
08:19:02 <FunctorSalad> err, not "call the dictionary" but you know what I'm trying to say
08:19:06 <flipflap> Haskell is killing my brain
08:19:12 <Cale> flipflap: Is there something in particular you're having trouble with?
08:19:16 <Badger> it does that for a while
08:19:18 <lilac> FunctorSalad: i /think/ that function builds a Show [a] dictionary from the Show a dictionary using the Show a => Show [a] instance
08:19:20 <flipflap> It's the whole system
08:19:24 <flipflap> Monads
08:19:26 <Cale> flipflap: Everyone struggles for a while :)
08:19:29 <flipflap> How they work as IO
08:19:37 <Cale> Well, IO is just one monad.
08:19:41 <lilac> FunctorSalad: but i've not tried it :) it'd be interesting to find out what happens
08:19:53 <Cale> The fact that it's a monad can even be largely ignored when you're starting out.
08:20:05 <flipflap> And later, how the hell do I write a program that HAS to keep a state? (Examples are Servers, Bots or Daemons)
08:20:15 <Badger> heh
08:20:18 <Badger> always state
08:20:19 <flipflap> Can't go around passing a record all the time
08:20:20 <int80_h> @hoogle %
08:20:20 <pumpkinbot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
08:20:25 <Cale> flipflap: oh really?
08:20:28 <Cale> flipflap: Why can't you?
08:21:02 <Cale> flipflap: That would be one of the major techniques for handling state: just take the current state as a parameter all the time.
08:21:04 <flipflap> I could rather write an object in some other language that has those resources in it all the time :/
08:21:24 <Cale> Another way is just to use MVars or IORefs.
08:21:31 <rwbarton> flipflap: One common solution is to build your own monad on top of IO that keeps track of the state.  (This is much easier than it sounds thanks to monad transformers.)
08:21:52 <Cale> But I don't think just passing it around is really so bad.
08:21:58 <Cale> Do you?
08:22:09 <Cale> Can you give an example where you're stuck?
08:22:10 <cads> flipflap: don't panic!
08:22:19 <flipflap> :(
08:22:24 <Gracenotes> One thing I thought might work for IRC is a StateT YourState IO YourValue
08:22:29 <Cale> (if you don't have one yet, try it, and see if/where you get stuck)
08:22:41 <Gracenotes> you change the state, but do IO at the same time
08:22:55 <cads> flipflap: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
08:22:59 <Cale> Monad transformers are nice for constructing libraries, but I think they're overused.
08:23:04 <rwbarton> Gracenotes: Absolutely.  You might even find you don't really need StateT, and ReaderT is enough.
08:23:22 <rwbarton> The key is being able to change your mind later.
08:23:26 <cads> flipflap: monads are less scary once you've built a couple
08:23:31 <Gracenotes> rwbarton: hm. Just for keeping things like user lists updated, and such
08:23:51 <jeffersonheard> is there a way to change the associativity on operators that are infixed with backquotes?
08:23:56 <jeffersonheard> fixity, rather
08:24:08 <flipflap> infixr infixl ?
08:24:13 <rwbarton> Yes, infixl 4 `f`
08:24:15 <Saizan> Cale: well, why not use State instead of s -> (s,a) directly?
08:24:26 <drdozer> I'm writing a graph traversal framework which does one step of a computation each time a path is extended, but that computation may be suspended and queued up while a more promising path is looked at next
08:24:35 <drdozer> is there a nice abstraction for this?
08:25:26 <Cale> Saizan: That's true. But I think, especially for beginners, having the foresight to get just the monad you're looking for and apply it to your problem takes some experience.
08:25:40 <Cale> Saizan: It's good to see how to solve the problem directly.
08:25:44 <Gracenotes> drdozer: recursion..?
08:26:06 <lilac> FunctorSalad: you get an error when defining 'f' (overlapping instances, need -fallow-incoherent-instances)
08:26:09 <Gracenotes> not really a helpful suggestion, sorry :/
08:26:11 <flipflap> As a beginner, it's REALLY hard to adapt solutions you've done in, other languages before, in haskell
08:26:18 <jeffersonheard> basically, I want x `over` y `over` z to resolve to x `over` (y `over` z)  and that odesn't seem to be the default
08:26:23 <lilac> FunctorSalad: so i think it's ok if all relevant instances are always in scope
08:26:26 <Saizan> flipflap: that's half the point :)
08:26:36 <rwbarton> jeffersonheard: infixr 9 `over`
08:26:43 <jeffersonheard> rwbarton, thanks
08:26:55 <byorgey> flipflap: yes, Haskell embodies a radically different way of thinking about programming, so that's not surprising.
08:26:57 <flipflap> In D I was able to write an IRC bot that could (almost) dynamically load plugins and was 100% object based. Now in Haskell I'm lost even knowing how to connect to IRC
08:27:08 <lilac> flipflap: take a look at lambdabot
08:27:19 <rwbarton> flipflap: or much simpler, something like rss2irc
08:27:20 <lilac> flipflap: it's an IRC bot which can dynamically load plugins
08:27:22 <flipflap> Not that I'm surprised it's a whole lot different, but IO is really a pain at times
08:27:23 <zachk> jeffersonheard: just change the order,
08:27:29 <Cale> flipflap: The best way to treat learning Haskell is just to pretend that you know nothing about programming yet.
08:27:29 <byorgey> flipflap: in fact, it's not particularly recommended to try porting existing code you've written in imperative languages to Haskell; you're likely to just get frustrated and not really learn much Haskell.
08:27:39 * Gracenotes was very lost when first looking at lambdabot... got lost in all the monad transformers >_>
08:27:47 <Cale> flipflap: Later, your experience with imperative programming languages might come in handy.
08:28:08 <zachk> byorgey: i tried with a cs lab from one of my java classes i got it in haskell and it made me quit java :D
08:28:11 <guenni> sry, what's the flag again for compiling an exe without the dos window poping up?
08:28:23 <flipflap> -q ?
08:28:27 <zachk> i love the dos window
08:28:30 <lilac> experience with Haskell makes imperative programming easier, but the converse doesn't happen nearly as much
08:28:44 <byorgey> zachk: hehe, that's the other danger of porting code from other languages to Haskell, you might discover that those languages suck ;)
08:28:45 <fasta> How can QuickCheck-1.2 and QuickCheck-2.0 coexist? I defined an Arbitrary instance for the 2.0 version of Arbitrary, but it is complaining that it cannot find the 1.2 version. But, AFAIK, there is no way to refer to packages within source code. Defining it another time in the module complaining about it gives duplicate instances.
08:28:46 <guenni> zachk: me not so much
08:28:48 <jeffz`> guenni: it's a console window not a dos window, could be -mwindows that you're after
08:28:57 <byorgey> flipflap: you may be interested in this page: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
08:28:59 <guenni> jeffz`: thx
08:29:18 <flipflap> The problem is just, I don't have any idea how to start learning it. Learning by doing might be a good start, but I have yet to find some good things to start programming
08:29:25 <flipflap> Small learning programs
08:29:40 <flipflap> byorgey: When that page started on monads, I was totally lost.
08:29:42 <Cale> Initially, there is this massive shift in the way that programs are thought about... Instead of writing a program to *do* the steps of solving a problem, it's much more about defining what the solution to the problem *is*.
08:29:54 <byorgey> flipflap: ok, fair enough. =)
08:29:58 <zachk> flipflap: byorgey's link is amazing, with that tutorial and a bit of learning you can just pull programs into an irc bot with no major hassle
08:30:11 <dancor> what's the best way to represent (a, b, a, b, .., a)?  data Intercal a b = Intercal a b (Intercal a b) | Interend a
08:30:11 <flipflap> Calling "asks socket" makes no sense. Is it calling a socket from the heavens?
08:30:20 <flipflap> I read "globally read-only socket handle"
08:30:24 <flipflap> But where does it come from?
08:30:26 <flipflap> Hells!
08:30:28 <byorgey> flipflap: yes, the heavens of the Reader monad =)
08:30:32 <rwbarton> flipflap: it comes from the monad you defined
08:30:33 <Cale> flipflap: From the call to runReaderT?
08:30:33 <Cheshire> because Haskell is made of denotational semantics instead of operational
08:30:54 <jeffz`> guenni: if not, try -optl-mwindows
08:31:01 <byorgey> flipflap: perhaps you would be interested in trying to do some of the Project Euler problems with Haskell?
08:31:03 <Cale> flipflap: When you call runReaderT, you pass in something which presumably 'socket' can be applied to in order to get the appropriate value.
08:31:19 <byorgey> that seems to be a popular and suitably gently "learn by doing" approach
08:31:23 <byorgey> *gentle
08:31:30 <flipflap> Euler? Sounds math-ish
08:31:34 <byorgey> it is.
08:31:46 <byorgey> flipflap: do you not like math?
08:31:46 <rwbarton> "math-ish", that's actually a perfect description :)
08:31:49 <dancor> euler is kwl but actually having your own problems you need to solve, math-y or practical, is kwlr
08:31:50 <flipflap> I know Euler's number, at least I know that the e is called like that
08:31:56 <Cheshire> hehe rwbarton
08:31:59 <flipflap> But I never liked math alot
08:32:08 <flipflap> Maybe that's the reason I'm failing at .hs
08:32:12 <zachk> flipflap: just get a feel with the io monad, its rough, but think of things in the do block of io as "io actions" then maybe try Maybe and the list monad is quite nice
08:32:14 <BrokenClockwork> FunctorSalad: Thanks mate, it works now :)
08:32:24 <Cale> I actually really don't like that they named it Project Euler... it's a bit of a disservice to Euler's name.
08:32:30 <drdozer> flipflap - what is it you would like to code up?
08:32:31 <Cale> ;)
08:32:51 <byorgey> flipflap: well, Haskell does have rather mathematical foundations, it's true.  however, that's not a fundamental impediment to learning it.
08:33:05 <flipflap> In the languages before I did a lot of string manipulations, and socket stuff
08:33:10 <flipflap> Network applications :/
08:33:11 <byorgey> you'll just end up learning some math by learning Haskell, without knowing it =)
08:33:40 <rwbarton> drdozer: in response to your earlier question, you may be interested in "delimited continuations", though I don't pretend to understand them in the least
08:33:40 <flipflap> I already tried "read every second line from a file and write those lines back into another file"
08:33:43 <flipflap> Needless to say, failed
08:34:01 <Cale> flipflap: How many days/weeks have you been studying Haskell already?
08:34:01 <guenni> jeffz`: sry, would that be ghc --make someMain.hs -mwindows?
08:34:15 <dancor> flipflap: how did "read one line from a file and print it" go
08:34:30 <dancor> just break the problem down and see where it's failing
08:35:11 <jeffz`> guenni: ghc --make -optl-mwindows
08:35:14 <Cale> flipflap: Network apps aren't the easiest place to begin, I'm afraid, but small file I/O things like that shouldn't be too hard once you have the basics.
08:35:24 <guenni> jeffz`: and thx again :)
08:35:54 <Cale> flipflap: First of all, I would recommend writing the function which takes a String representing the input file, and produces a String representing the desired output file.
08:36:05 <Cale> flipflap: Then worry about wrapping the necessary I/O around that.
08:36:18 <flipflap> I wanted to learn it a long time now, like 6 months now, never really got into it.. interest re-grew like a week ago, and I decided to read "Real World Haskell", while it is a great book, it's SO LONG and bloated, I almost fell asleep at one third of each chapter. "Learn yourself a Haskell" was great and helped me a lot in understanding lambdas and list comprehensions
08:36:28 <flipflap> However when I needed to know about monads, it let me down by being imcomplete :(
08:36:38 <Cale> To that end, I would recommend the 'lines' function as a good starting point...
08:36:42 <cads> is a homomorphism at all like when you fondle a guy to make him overreact and seem insecure about his masculinity, so you can seduce his girlfriend?
08:36:51 <Cale> > lines "abc\ndef\nghi"
08:36:52 <pumpkinbot>   ["abc","def","ghi"]
08:37:09 <Cale> cads: no, it's a structure preserving function.
08:37:20 <zachk> flipflap: ok the brutal truth is monads are hard its like learning what an Object is in OO languages. takes a bit to sink in. eveything in haskell is math. if you want a good book get "programming in haskell" and tinker around, id say haskell takes at least 3 months to have an idea. but hey you can deal with infinities and you get a real compiler. and your code size goes way down as you improve. i wrote a program that was 3
08:37:44 <cads> Cale: heh, thanks.
08:37:52 <Cale> I think the main reason that monads are hard to learn would be that everyone tells you they're hard to learn ;)
08:38:25 <Cale> Really, most of what it takes is some playing around with examples
08:38:25 <cads> "the biggest mistake we made with the haskell programming language was calling them monads instead of 'warm fuzzy thing' "
08:38:28 <zachk> my exgirlfriend kept thinking i was talking about gonads
08:38:55 <cads> don't explain monads to girlfriends, I find
08:38:58 <byorgey> no, it's because they're quite abstract.  if you're not used to thinking at very high levels of abstraction, monads can take a long time to fully grok.
08:39:03 <flipflap> > filter [ x | x <- (lines "foo\nbar\nbaz"), y <- [1..], even y]
08:39:04 <pumpkinbot>   Couldn't match expected type `a -> Bool'
08:39:07 <leadnose> cads, OTOH, the some slogan of haskell is "avoid success at all costs", so go figure :P
08:39:18 * byorgey finds this 'monads really aren't very hard' meme unhelpful
08:39:24 <Cale> flipflap: ah, you're quite close!
08:39:35 <Cale> flipflap: You probably want to zip [1..] with the lines of the file
08:39:36 <rwbarton> @unmtl StateT s (Error e) a
08:39:36 <pumpkinbot> s -> Error e (a, s)
08:39:53 <flipflap> Mhh Booly bool
08:40:00 <rwbarton> @unmtl ErrorT r (State s) a
08:40:00 <pumpkinbot> s -> (Either r a, s)
08:40:03 <Cale> > [x | (k,x) <- zip [0..] (lines "foo\nbar\nbaz"), even k]
08:40:05 <pumpkinbot>   ["foo","baz"]
08:40:29 <Cale> > zip [0..] (lines "foo\nbar\nbaz")
08:40:31 <pumpkinbot>   [(0,"foo"),(1,"bar"),(2,"baz")]
08:40:44 <Cale> ^^ handy idiom that one
08:40:46 <flipflap> :t zipWith
08:40:47 <pumpkinbot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
08:41:05 <cads> byorgey: I don't think it's that hard to conceptualize a monad, if you take it from the axioms, avoid the do notation to begin with, and show how to implement and use a few simple monads
08:41:14 <Cale> > zipWith (+) [1,2,3] [40,50,60]
08:41:16 <pumpkinbot>   [41,52,63]
08:41:30 <flipflap> > zipWith (\(n,s) -> even n) [1..] (lines "foo\nbar\nbaz")
08:41:31 <pumpkinbot>   Couldn't match expected type `b -> c' against inferred type `Bool'
08:41:36 <byorgey> cads: sure, I agree that is a good approach.  my point is that can still take a while.
08:41:36 <flipflap> Aww
08:41:39 <cads> byorgey: similarly objects in OO programming are simple to conceptualize to begin with
08:41:46 <Cale> > zipWith (\n s -> even n) [1..] (lines "foo\nbar\nbaz")
08:41:48 <pumpkinbot>   [False,True,False]
08:41:55 <rwbarton> @unmtl StateT s [] a
08:41:55 <pumpkinbot> s -> [(a, s)]
08:42:35 <cytzol> unmtl?
08:42:42 <byorgey> I guess the problem here is what we mean by 'hard': 'fundamentally intellectually difficult', or 'requiring sustained effort'.
08:42:44 <flipflap> Hhhhhhhhhmmm
08:42:59 <byorgey> my contention is that while monads may not be hard in the first sense, they are certainly hard in the second.
08:43:08 <Cale> zipWith always produces a list whose length is the shorter of the two lists you give it
08:43:31 <SamB_irssi> byorgey: you mean like the difference between your typical Java program and your typical Haskell program ?
08:43:47 <flipflap> Would be bad if not.. infinite indexers
08:43:57 <byorgey> SamB_irssi: I'm not sure what you mean.
08:44:01 <Cale> flipflap: right :)
08:44:13 <flipflap> > [1,10..]
08:44:15 <pumpkinbot>   [1,10,19,28,37,46,55,64,73,82,91,100,109,118,127,136,145,154,163,172,181,19...
08:44:19 <flipflap> Huh
08:44:21 <Cheshire> I wonder if it would be a clearer approach to start with functors and then have monads defined with return/join
08:44:22 <flipflap> > [0,10..]
08:44:24 <pumpkinbot>   [0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,2...
08:44:26 <Cale> flipflap: zip [0..] is an often underappreciated use of an infinite list :)
08:44:26 <flipflap> Ah!
08:44:32 <byorgey> Cheshire: I certainly think so.
08:44:33 <Cheshire> like what you see in books
08:44:44 <cads> flipflap, the difference between grokking a simple monad and an advanced abstraction through one, or using monad combinators and junk, I'd liken to the difference between being able to use an object in OO, and being able to fully use class inheritance and reflection and metaprogramming
08:44:45 <flipflap> Oh, I like zipping with infinites
08:44:57 <byorgey> Cheshire: well, but that may be my mathematical bias =)
08:45:07 <flipflap> > zip [1..] ["this","way","i","can","index","stuff"]
08:45:09 <pumpkinbot>   [(1,"this"),(2,"way"),(3,"i"),(4,"can"),(5,"index"),(6,"stuff")]
08:45:10 <byorgey> Cheshire: at the very least, it can certainly be helpful to see that point of view.
08:45:15 <fasta> Ah, the smell of rotting libraries...
08:45:15 <Cale> > [x | (k,x) <- zip [0..] "abracadabra", even k]
08:45:17 <pumpkinbot>   "arcdba"
08:45:41 <cads> Cheshire: monads seem to be the hot ticket though :D
08:45:45 <Cale> > [y | (k,x) <- zip [1..] "stutter", y <- replicate k x]
08:45:46 <pumpkinbot>   "sttuuuttttttttteeeeeerrrrrrr"
08:46:01 <cads> byorgey: have you noticed the meme of calling everything a meme, going around?
08:46:30 <flipflap> > [x*y | x <- [1..5], y <- [1..x]]
08:46:32 <pumpkinbot>   [1,2,4,3,6,9,4,8,12,16,5,10,15,20,25]
08:46:40 <fasta> Cale: I always name that one zip_naturals (and thereby I start a war amongst people whether it should start at zero or one ;) )
08:46:57 <byorgey> cads: ...not particularly?
08:47:04 <Cale> fasta: I never name it.
08:47:15 <Cale> fasta: zip [0..] is shorter than most names you could give it.
08:47:21 <Cale> (and clearer!)
08:47:29 <flipflap> Looks my linux distribution has a great haskell support
08:48:16 <byorgey> cads: it's a useful word, when used to mean what it actually means, as opposed to stupid chain letters on livejournal =)
08:48:22 <cads> byorgey, it's a deep internet meme, the self recursive meme of the joy of identifying trivial memes, aka "lols, mudkips are now a meme!"
08:48:34 <flipflap> So i herd...
08:49:11 <athos> hi
08:49:41 <byorgey> flipflap: which linux distro is that?
08:49:43 <byorgey> hi athos
08:50:05 <flipflap> byorgey: Arch Linux
08:50:30 <int80_h> yeah, I had to go with arch linux because of the haskell support
08:50:36 <cads> orly? what version of ghc does it have?
08:50:54 <byorgey> flipflap: ah, yes, that has excellent haskell support indeed, thanks to the indefatigable dons =)
08:50:58 <flipflap> I think the repos always have the newest
08:51:06 <cads> gentoo also has good support i'm led to believe
08:51:10 <flipflap> Also a special [haskell] repo
08:51:41 <cads> debian is passable but for anything serious you want to build your own
08:51:57 <cads> you guys know if there are up to date packages available?
08:52:19 <rwbarton> cads: for debian?
08:52:38 <cads> yes
08:53:23 <flipflap> I also got XMonad on that system :(
08:53:24 <flipflap> :(
08:53:26 <flipflap> :)**
08:54:33 <rwbarton> cads: I believe someone posted to one of the haskell mailing lists a while ago (maybe a few months?) about his company's public debian repository of haskell-related packages
08:54:54 <rwbarton> cads: I just roll my own everything at this point though
08:55:20 <cads> you in deb?
08:55:23 <rwbarton> Yeah
08:56:05 <rwbarton> debian provides the things I expect to work all the time.  I don't expect ghc-6.11.20090107 to work all the time. :)
08:56:24 <cads> tired of rolling my own stuff here, thinking of moving to gentoo, where although it'll be a radical change, I'll get the benefit of source builds with the consistency of something managed by a package system
08:56:31 <SamB_irssi> rwbarton: that's probably a bit MORE up-to-date than he meant ;-P
08:56:45 <SamB_irssi> I think he meant, say, GHC 6.10.2 :-P
08:56:51 * SamB_irssi knows that isn't out yet
08:57:10 <FliPPehArch> Yay for pidgin IRC
08:57:21 <int80_h> hmm, debian or arch linux?
08:57:24 <fasta> cads: Compiling OpenOffice.org is no fun.
08:57:31 <int80_h> show of hands? I can still change my mind here
08:57:33 <FliPPehArch> Arch
08:57:47 <int80_h> yeah, for haskell dev is what I want it for
08:57:54 <cads> int80_h: debian does the "just works" better than arch
08:58:11 <FliPPehArch> Arch is not supposed to just work
08:58:21 <FliPPehArch> :)
08:58:22 <cads> i know
08:58:22 <rwbarton> SamB_irssi: Sure, but I'm willing to accept that the haskell ecosystem is moving too quickly for debian to keep up at the moment
08:58:26 <int80_h> hmm, cads that's a good point. I want to minimize the fidgeting and spend time working
08:58:40 <mopped> CPS is quite confusing, is it the normal method that programmers use, or is it just A method?
08:58:41 <rwbarton> SamB_irssi: If the problem wasn't ghc-6.10.1, it would be cabal-install-0.6.0, etc.
08:58:53 <SamB_irssi> rwbarton: anything much faster than a dead slug does THAT
08:58:57 <Cheshire> mopped, normal method for what?
08:59:02 <beelsebob> mopped: it's just a method – but it's a nice one to get the hang of, it can be very useful
08:59:26 <cads> I wonder what the situation is like in debian unstable
08:59:33 <mopped> i dont know, for anything I guess Cheshire
08:59:37 <SamB_irssi> cads: afaict it's no better
08:59:50 <int80_h> so, with arch I'll need to futz around making sure I have this and that correct library?
09:00:01 <rwbarton> cads: identical as far as ghc is concerned I think
09:00:12 <FunctorSalad> cads: I accidentally the whole meme :(
09:00:51 <Cheshire> mopped, I think there are only specific problems I would attack using CPS
09:01:01 <SamB_irssi> FunctorSalad: what whole meme ?
09:01:40 <cads> int80_h: no, it does have dependency resolution in pacman, and you won't have to worry about installing by hand your cabal and and ghc, it's just you'll have to manually write your own mount table and stuff, the operating system starts out as a commandline
09:01:44 <FunctorSalad> SamB_irssi: I forgot
09:01:59 <rwbarton> cads: there is a ghc6-6.10.1 in experimental.  I don't know what to make of that, it might have lots of dependencies you don't want, for instance
09:02:07 <int80_h> cads: oh that's not so bad
09:02:10 * SamB_irssi knows better than to ask what comes after "accidentally"
09:02:20 <int80_h> cads: I just don't like playing "find the dependency"
09:02:34 <hugo___> what should i use if i want really fast string manipulation in haskell ?
09:02:36 <FunctorSalad> SamB_irssi: I think that nonsensicality is the point of the meme :)
09:03:01 <cads> FunctorSalad: was it mudkips?
09:03:16 <FunctorSalad> cads: maybe milkips
09:03:30 <cads> where people manage to bring up mudkips in the conversation for little reason
09:03:42 <cads> yes I realize i am falling prey to it right now
09:03:44 <BMeph> FunctorSalad: I made a verb for your meme, but I eated it. ;p
09:04:46 * cads likes to visualize his memes as ethereal jellyfish attached to his brain, floating around his head in a little cloud, pulsating
09:05:13 <FliPPehArch> Yay, gedit syntax for haskell is a beauty
09:05:13 <Cale> cads: Like... metroids then?
09:05:34 <cads> Cale that would be another meme wouldn't it?
09:05:48 <cads> but yes, exactly like metroids.
09:06:22 <cads> what are we without our memetic code?
09:06:30 <FunctorSalad> sane?
09:06:52 <cads> points of awareness?
09:08:04 <BMeph> Wishing someone would make cars with little steering wheels on the big one? ;p
09:08:59 <cads> monad to the bone!
09:09:08 <FunctorSalad> I was about to illustrate the meme issue with a car analogy ;)
09:09:21 <cads> m m m m m monad..
09:09:46 <cads> sorry
09:09:51 <drhodes> metroids consume energy
09:10:22 <FliPPehArch> Any good Haskell IDE for gnome?
09:12:06 <lilac> > Just 1 `mplus` Just 2
09:12:08 <pumpkinbot>   Just 1
09:12:19 <cads> flippeh, there's something like eclipseFS
09:12:33 <cads> an addon for eclipse
09:13:01 <cads> i'd say that the haskell ide is emacs
09:13:06 <BrokenClockwork> I want to overwrite a list with another list, but only every n-th item, has someone a nice advice?
09:13:06 <BMeph> Cale: Do you ever think that Haskell should exchange the definitions for MonadPlus and Monoid? :)
09:13:19 <Cale> BMeph: hm?
09:13:23 <lilac> > Left "1" `mplus` Left "2"
09:13:23 <Cale> exchange?
09:13:24 <pumpkinbot>   Left "2"
09:13:54 <asgaroth> @pl \x -> if x then a else b
09:13:54 <pumpkinbot> flip (flip if' a) b
09:14:06 <BMeph> Cale: For some reason, I imagine that MonadPlus should work the way we have Monoids, and vice-versa.
09:14:25 <Cale> BMeph: I don't really understand...
09:14:42 <cads> FliPPehArch: I think haskell's motto has classically been 'avoid success at all costs', so you don't really see expansive enterprise style IDEs for it
09:14:47 <Cale> BMeph: A MonadPlus is a monad with an additional monoid structure that agrees with the monad operations.
09:14:48 <Saizan> Cale: i think he refers to the instances for e.g. Maybe
09:15:08 <asgaroth> What's the reason for if being defined as a special syntax construct instead of a function?
09:15:21 <Cale> cads: There's another reason for that too.
09:15:31 <fasta> asgaroth: they wanted to save a few parens.
09:15:41 <asgaroth> ah
09:16:05 <fasta> asgaroth: if you don't like it you can always write a preprocessor ;)
09:16:14 <cads> what is it, cale?
09:16:19 <Saizan> or use a function..
09:16:30 <asgaroth> fasta: well, if' p a b = if p then a else b suffices
09:16:34 <Cale> cads: The philosophy of Haskell agrees more with the notion that if you need extra tools to help you write source code, that's a sign of weakness in the language.
09:16:35 <FliPPehArch> cads: no need for enterpris
09:16:45 <FliPPehArch> Do you know SciTE?
09:16:52 <asgaroth> I think that's what lambdabot does as well
09:16:52 <beelsebob> asgaroth: p a b?
09:16:57 <FliPPehArch> Quite a nice little editor on windows with hotkey support
09:16:57 <FunctorSalad> personally I'd like an IDE too... getting everything in emacs to work is like herding cats or something
09:16:58 <asgaroth> @src if'
09:16:58 <pumpkinbot> Source not found. You type like i drive.
09:17:09 <FunctorSalad> (like jumping to definitions)
09:17:24 <lilac> asgaroth: if' True a b = a; if' False a b = b (this is an @pl extension)
09:17:27 <Cale> cads: So, if you feel that you need an IDE to generate boilerplate code for you, something is wrong with your language, and it needs to be fixed.
09:17:28 <cads> FliPPehArch: scite's in gnome too
09:17:32 <FliPPehArch> vim: !ghc -o file.hs;./file
09:17:39 * glguy would love an editor with good automated support for working with Haskell files
09:17:40 <beelsebob> FunctorSalad: watching a colegue working with emacs only reinforces that view for me
09:17:47 <FliPPehArch> Whoo
09:17:49 <beelsebob> they spend more time cursing emacs than actually doing anything useful
09:17:49 <BMeph> Cale: Sorry, I'm trying to figure out how to explain what the heck I mean, and it's a little tricky. :)
09:17:51 <cads> Cale: i can respect that
09:17:57 * drhodes puts in request for slime for haskell
09:18:01 <opqdonut> this is probably old, but I discovered it just a minute ago:
09:18:02 <opqdonut> > let f (x:xs) (_:_:ys) = let (a,b) = f xs ys in (x:a,b); f xs _ = ([],xs); g xs = f xs xs  in g [1..11]
09:18:04 <pumpkinbot>   ([1,2,3,4,5],[6,7,8,9,10,11])
09:18:34 <FunctorSalad> beelsebob: :D
09:18:35 <lilac> opqdonut: yep, i've done that before.
09:18:39 <glguy> a good editor could help maintain your type declarations, add class contraints, rename types, variables
09:18:45 <lilac> opqdonut: it's a neat trick.
09:18:48 <opqdonut> yeah
09:19:05 <opqdonut> i think the mutually-recursive evens and odds are still a nicer way to split a list
09:19:12 <opqdonut> (for example for mergesort)
09:19:13 <glguy> you use "get" and it offers to populate the StateM constraint up
09:19:29 <fasta> Every few years there is someone who starts a Haskell IDE project and then gives up after a few years.
09:19:41 <mopped> I'm trying to write map in CPS form, and i've frankly got no clue where to begin - can anyone explain it a bit? I dont really follow the explanation in YAHT
09:19:41 <glguy> use a function that isn't imported and it automates the addition
09:20:00 <Cheshire> mopped, do you know how to write first-order non-recursive functions into CPS?
09:20:05 <Cheshire> mopped, (start easy)
09:20:16 <SamB_irssi> glguy: how would it know which one to import ?
09:20:17 <asgaroth> glguy: That could be annoying especially since there are often several functions of the same name
09:20:17 <mopped> not at all
09:20:35 <glguy> yeah, if only we had some kind of menu or list ot choose from
09:20:43 <glguy> and we could use haskell's types to narrow the search
09:20:43 <FunctorSalad> fasta: is there any IDE that's far enough that it would be better to understand an use it than to start from scratch?
09:20:48 <mopped> It shows fold in CPS, shows how to create foldl/r out of themm, and then tells me to write map and filter!
09:20:56 <SamB_irssi> I suppose it could go and find you all the different things there are with that name, and tell you which sets of modules export each ...
09:21:04 <cads> cale, still, there are things the language is not responsible for, say build management, documentation management, which would be nice to have in a clean looking modern app. Not to mention neat features like code completion and stuff..
09:21:09 <SamB_irssi> types might not help
09:21:16 <glguy> SamB_irssi, but they might
09:21:18 <SamB_irssi> you might have used it incorrectly
09:21:26 <SamB_irssi> obviously the menu should list the types, though
09:21:29 <Saizan> FunctorSalad: scion, probably
09:21:32 <glguy> arguing that Haskell couldn't benefit from a good IDE is arguing that you haven\t written enough code
09:21:44 <Cale> cads: yes... Haskell also opens up some new possibilities for IDEs. Having types checked as you input the code would be nice.
09:21:45 <opqdonut> lleksah is nice enough
09:21:49 <opqdonut> but i still use emacs
09:21:56 <cads> cale, not that any of that stuff is beyond the reach of emacs
09:22:00 <opqdonut> which offers quite much IDEness already
09:22:17 <cads> cale, does flymake do that for you?
09:22:23 <asgaroth> We can also wait what yi has to offer when it's more complete
09:22:26 <Cheshire> mopped, k (add (square x) (square y)) is an easier example
09:22:49 <cads> opqdonut: is lleksah usable?
09:22:58 <opqdonut> to the extent i tried it
09:23:04 <BMeph> Cale: Certain Monoids are instanced by (Monoid a) => Monoid f a, where the monoidal structure of a is used in determining the structure of  f a. However, MonadPlus doesn't examine any monoidal characteristics of the type used in the Monad.
09:23:16 <Cheshire> mopped, square'cps x $ \x'squared -> square'cps y $ \y'squared -> sum'cps x'squared y'squared k
09:23:48 <Cheshire> mopped, do you think that makes sense?
09:23:50 <Cale> BMeph: it can't.
09:23:55 <lilac> MonadPlus is all about monadic failure; mplus takes the first non-failing value.
09:24:03 <Cale> BMeph: It's 'f' which is the MonadPlus instance.
09:24:03 <mopped> *whoosh*
09:24:05 <Cale> lilac: er...
09:24:13 <Badger> heh
09:24:20 <glguy> lilac, mplus doesn't have to take a single value
09:24:21 <mopped> no idea there Cheshire
09:24:22 <Cheshire> mopped, no? you know what $ and \_ -> _ are?
09:24:35 <glguy> > [1] `mplus` [2]
09:24:35 <cads> I am sorry all, the meme made me do it http://ihasahotdog.files.wordpress.com/2008/01/funny-dog-pictures-loldogs-wharrgarbl.jpg
09:24:37 <pumpkinbot>   [1,2]
09:24:39 <mopped> $ is function application, \_ -> are lambdas right?
09:24:41 <lunabot>  luna: parse error on input `)'
09:24:42 <Cheshire> yes
09:24:50 <SamB_irssi> yeah, it's unfortunate that constructor classes are unable to constrain their arguments ever ...
09:25:11 <BMeph> Cale: Oh, huh - that makes sense now. Okay, thanks. :)
09:25:15 <cadsEATETH> food time
09:25:19 <wy> hey, anyone use emacs here?
09:25:21 <SamB_irssi> (or I guess it's unfortunate that the constructors can't)
09:25:29 <glguy> SamB_irssi, can't what?
09:25:33 <Cheshire> wy, did you try #emacs though?
09:25:46 <lilac> glguy: if you think of [] as nondeterminism, then it's still effectively the first non-failing value in some sense.
09:25:51 <wy> Cheshire: tried.
09:25:58 <mopped> I guess I don't understand the lambda within lambda, how can you have \x'squared -> square'cps y?
09:26:04 <dskippy> I am having a difficult time with the type checker in my list comprehension.  For some reason I can't get it to allow c == truncate c because it won't compare and int to a double. http://pastebin.com/d697ae43e
09:26:18 <glguy> lilac, single result isn't part of the requirement, however
09:26:27 <glguy> multiple result behaviors make sense in terms of the laws
09:26:36 <Cheshire> mopped, maybe this is easier to read:  square'cps x (\x'squared -> square'cps y (\y'squared -> sum'cps x'squared y'squared k))
09:27:09 <Cheshire> mopped, for all the primitive functions, square, add.. you can assume a cps version which takes a continuation
09:27:51 <mopped> what's k, a function?
09:27:52 <FunctorSalad> Saizan: cool, didn't know about scion at all
09:28:17 <Cheshire> mopped, yeah the original was: k (sum (square x) (square y))
09:28:35 <int80_h> @t compare
09:28:35 <pumpkinbot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:28:45 <int80_h> @type compare
09:28:47 <pumpkinbot> forall a. (Ord a) => a -> a -> Ordering
09:30:09 <FliPPehArch> http://www.leksah.org/images/AtWork.png
09:30:15 <FliPPehArch> Haskell IDE :)
09:30:16 <nikki93> A 'quick' method to read from a file?
09:30:31 <nikki93> FliPPehArch: Bah. gvim ftw.
09:30:48 <FliPPehArch> nikki93: readFile
09:30:53 <mopped> How should i try to read the cps statement?
09:31:15 <Cheshire> mopped, if  sum x y ~> x + y,  then sum'cps x y k ~> k (x + y)
09:31:48 <nikki93> FliPPehArch: I can't use it in a pure function right?
09:31:52 <Cheshire> mopped, is it squares x and throws the result into the first lambda (which binds it to x'squared), then it squares y, then ...
09:31:56 <lilac> glguy: ok, fair point.
09:32:06 <FliPPehArch> It's IO after all, nikki93
09:32:16 <nikki93> FliPPehArch: I know. :(
09:32:21 <nikki93> FliPPehArch: IO sucks. :P
09:32:30 <FliPPehArch> I know :(
09:32:54 <nikki93> FliPPehArch: Don't worry, one day we'll win the IO wars and be able to use computers without interacting with 'em.
09:33:10 <SamB_irssi> heh
09:33:43 <wchogg> @seen conal
09:33:43 <pumpkinbot> I saw conal leaving #haskell 12h 28m 53s ago, and .
09:33:45 * drhodes is one with the borg
09:34:05 <glguy> SamB_irssi, If I understand what you were talking about, you can do that with GADT syntax
09:34:14 <nikki93> s/pumpkin/lambda/
09:34:18 <Cheshire> @let sum'cps x y k = k (x + y)
09:34:20 <pumpkinbot>  Defined.
09:34:23 <SamB_irssi> glguy: I meant the type constructor though
09:34:26 <Cheshire> @let square'cps x k = k (x * x)
09:34:28 <pumpkinbot>  Defined.
09:34:52 <Cheshire> :t let  pythagoras'cps x y k = square'cps x (\x'squared -> square'cps y (\y'squared -> sum'cps x'squared y'squared k)) in pythagoras'cps
09:34:53 <pumpkinbot> forall a t. (Num a) => a -> a -> (a -> t) -> t
09:35:10 <Cheshire> :t let pythagoras x y = x*x + y*y
09:35:11 <pumpkinbot> <no location info>:
09:35:11 <pumpkinbot>     not an expression: `let pythagoras x y = x*x + y*y'
09:35:12 <Cheshire> :t let pythagoras x y = x*x + y*y in pythagoras
09:35:14 <pumpkinbot> forall a. (Num a) => a -> a -> a
09:35:15 <Cheshire> :t pythagoras
09:35:16 <pumpkinbot> Not in scope: `pythagoras'
09:36:00 <Cheshire> mopped, if you see the types there.. you can compute the cps type from the initial type. So for CPS converting something more complex, you can have the types direct you
09:36:42 <Cheshire> mopped, say if you wanted to CPS convert: twice f x = f (f x)
09:37:29 <mopped> wouldnt it be twice' f x g = g (f (f x)) or so?
09:37:45 <int80_h> I want to make a list of all numbers in the form a^b where a < 100 and b < 100. Is a list comprehension justified or unnessecary?
09:37:45 <Cheshire> no that's not in CPS form because there are nested applications there
09:37:58 <nikki93> @src foldl
09:37:58 <pumpkinbot> foldl f z []     = z
09:37:58 <pumpkinbot> foldl f z (x:xs) = foldl f (f z x) xs
09:38:34 <Cheshire> mopped, the type of twice :: (a -> a) -> a -> a,  so the CPSd versions type will be  (a -> (a -> r1) -> r1) -> (a -> r2) -> r2
09:40:42 <Cheshire> mopped, sorry that was not accurate, it should be:  (a -> (a -> r1) -> r1) -> a -> (a -> r1) -> r1
09:41:14 <nikki93> @type max
09:41:15 <pumpkinbot> forall a. (Ord a) => a -> a -> a
09:41:26 <nikki93> @src max
09:41:26 <pumpkinbot> max x y = if x <= y then y else x
09:41:32 <nikki93> @src maximum
09:41:33 <pumpkinbot> maximum [] = undefined
09:41:33 <pumpkinbot> maximum xs = foldl1 max xs
09:41:35 <hackage> Uploaded to hackage: Hieroglyph 0.99
09:41:47 <nikki93> Gotta love haskell
09:43:05 <mopped> so twice takes three arguments, first is a function that takes two arguments, second is an item, third a third function, i'm not used to types and i'm a bit confused how they can tell me how to structure the CPS form
09:45:23 <FunctorSalad> isn't the template haskell linking bug fixed yet? :(
09:45:52 <mopped> i just cant see of another way tahn g (f (f x
09:46:05 <hugo___> check it out: http://www.nwizard.ro/wordpress/wp-content/uploads/2008/03/100-at-work.jpg
09:46:15 <Cheshire> mopped, you should assume the CPS form doesn't take f but instead it takes f'cps
09:46:36 <Cheshire> so f :: a -> a, but f'cps :: a -> (a -> r1) -> r1
09:47:12 <mopped> ok sure
09:50:49 <mopped> why would f output something of type r1, if it's input is a?
09:51:34 <Cheshire> mopped, in CPS, conceptually, nothing even outputs
09:51:53 <Cheshire> so instead of being a -> a,  it's now a -> ContinuationThatTakesAn a
09:52:27 <mopped> so the function input also changes, ok
09:52:45 <Cheshire> can you write  twice'cps f'cps a k = ... ? :)
09:52:45 <thom__> is >>= something that you have to call explictly or does the compiler use it implicitly while compiling a function call?
09:52:55 <Cheshire> and you already have the type to check if you got it correct
09:53:26 <opqdonut> thom__: you call it explicitly
09:53:33 <opqdonut> thom__: in a do-block it gets used "implicitly"
09:53:46 <thom__> thanks
09:56:09 <mopped> no, i don't know how i'd apply f'cps twice if it now outputs something of a different type than it accepts
09:56:43 <Cheshire> mopped, f (f a) changes into  f'cps a (\f'a -> f'cps f'a (\f'f'a -> ...
09:57:11 <Cheshire> mopped, (similarly,  f (g a) changes into  g'cps a (\f'a -> f'cps f'a (\f'f'a -> ... )
09:59:36 <mopped> I don't follow at all, i might tackle it again after a bit more exp with haskell
09:59:57 <jeffersonheard> Alright folks... that functional frontend to Cairo is out
10:00:05 <jeffersonheard> it won't satisfy everyone's needs just yet
10:00:07 <jeffersonheard> but I'm working on it
10:00:10 <jeffersonheard> it's a good first cut
10:00:14 <Cheshire> mopped, ok, but what things don't make sense?
10:00:31 <dons_> wooo!!!
10:00:31 <jeffersonheard> Tested with GHC 6.8.3 and Gtk2Hs 0.9.13
10:00:34 <dons_> go jeffersonheard
10:00:35 <wjt> jeffersonheard: what's that?
10:00:44 <wjt> jeffersonheard: sounds like something i would enjoy using in Bustle.
10:00:58 <jeffersonheard> I'm going to upload some tutorial material on it to my blog
10:01:00 <Cheshire> mopped, (because maybe we should update the bit on the wiki about CPS, so that anyone can understand it?)
10:01:05 <jeffersonheard> as well as discuss the design
10:01:21 <mopped> All of it pretty much, i'm not sure how embedded lambdas are executed, or why you'd structure them like that
10:01:40 <mopped> i'm working through YAHT, it seems a bit out of place, quite early on
10:01:47 <mopped> i'll have a look at the wiki
10:02:00 <Cheshire> oh I thought you were reading the wiki, there's an out of place bit about CPS there too :p
10:02:08 <Cheshire> maybe it's a wikibook version of YAHT
10:02:58 <jeffersonheard> wjt, what's bustle?
10:03:00 <mopped> well, atleast it's under advanced haskell on the wiki, i'm firmly in the noob column
10:03:10 <wjt> jeffersonheard: thing i wrote to draw sequence diagrams of D-Bus activity
10:03:21 <mopped> or wait.. wrong wiki it seems
10:03:52 <wjt> jeffersonheard: http://resiak.livejournal.com/59590.html
10:03:55 <Cheshire> mopped, this is the one I came across before http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
10:04:23 <jeffersonheard> thx
10:04:40 <mopped> ah taht's what I was checking
10:04:47 <mopped> YAHT shows it with fold and that's it
10:05:13 <skorpan> where can i read about this whole "sum of types" thing?
10:05:27 <hasMeta> Hello guys, could sby please have a look at this code? I'm fighting with it for several days now :-( http://www.2shared.com/file/4783640/80867615/wikitar.html
10:06:26 <vegai> hasMeta: site doesn't work
10:07:04 <tromp__> nobody's gonna download a tar to look at your src
10:07:21 <vegai> better use something like hpaste
10:07:22 <vegai> @paste
10:07:22 <pumpkinbot> Haskell pastebin: http://hpaste.org/new
10:07:41 <vegai> hah, perhaps not that. Try http://paste.factorcode.org
10:08:34 <Saizan> @where hpaste2
10:08:34 <pumpkinbot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
10:08:38 <hasMeta> hmm, okay, I'll try to copy'n'paste the relevant code
10:09:41 <Cheshire> I think I will try and improve http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style a bit
10:13:56 <hasMeta> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1137#a1137
10:14:08 <hasMeta> line 24 throws the compiler error
10:14:37 <loadquo> Hmm, if I curry a function with a mutable array, and then use it later, which state of the array will it use?
10:14:38 <hasMeta> I'm somewhat familiar with monads, IO actions ... but I don't see an elegant way to fix this, the original code is not mine
10:15:09 <Cheshire> loadquo, (s/curry/partially apply/ :)
10:15:42 <loadquo> Okay, partially apply then, I'm guessing not?
10:15:48 <Cheshire> loadquo, it should be similar to IO, if you let x = print "foo" ..., then you can use 'x' to print "foo" as many times as you like (in different IO states)
10:16:25 <Cheshire> so if you go let x = <some array operation> in ..., then the context you use x in will determine it
10:16:59 <tromp__> does readFile need to be lifted?
10:17:09 <tromp__> :t readFile
10:17:10 <pumpkinbot> FilePath -> IO String
10:17:11 <jeffersonheard> wjt, looks nice
10:17:17 <wjt> jeffersonheard: thanks :)
10:17:19 <tromp__> yes, looks like it
10:17:24 <wjt> jeffersonheard: needs a lot of work still
10:17:49 <tromp__> :t liftM
10:17:51 <pumpkinbot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:18:30 <hasMeta> nobody? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1137#a1137
10:18:52 <tromp__> hasMeta, put a liftM in there
10:19:08 <Saizan> hasMeta: you need to use liftIO
10:19:14 <hasMeta> where?
10:19:16 <tromp__> :t liftIO
10:19:17 <pumpkinbot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
10:19:37 <Saizan> html <- readFile $ name ++ "/" ++ name ++ ".html"
10:19:46 <Saizan> ---> html <- liftIO $ readFile $ name ++ "/" ++ name ++ ".html"
10:19:57 <hasMeta> it's "transforming" an IO action into a MonadIO?
10:19:58 <hasMeta> *reading*
10:20:04 <Saizan> yeah
10:20:35 <Saizan> readFile returns an IO-action, that you want to promote to a FileProducer action
10:21:00 <hasMeta> gosh, that worked
10:21:03 <Saizan> and there are instances of MonadIO for WriterT and ReaderT, so you can just use liftIO
10:21:20 <Saizan> the alternative is to use lift enough times
10:21:51 <Saizan> html <- lift $ lift $ readFile $ name ++ "/" ++ name ++ ".html"
10:21:51 <hasMeta> is there a short explanation what exactly the difference between IO and MonadIO is?
10:22:03 <Saizan> IO is a type
10:22:08 <hasMeta> ok
10:22:08 <Saizan> while MonadIO is a class
10:22:26 <hasMeta> I see
10:22:29 <wchogg> The MonadIO type class lets you lift IO computations through multiple monadic layers with liftIO
10:22:35 <Saizan> that's instanced by all the monads that support IO actions
10:22:40 <Cale> hasMeta: IO is a monad, MonadIO is the class of monads m which support an operation  IO a -> m a
10:22:49 <hasMeta> great, thanks so much guys
10:22:58 <beelsebob> @seen lambdabot
10:22:58 <pumpkinbot> Last time I saw lambdabot was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-
10:22:58 <pumpkinbot> books, #haskell-hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru,
10:22:58 <pumpkinbot>  #haskell.se, #haskell_ru, #jhc, #jtiger, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 3m 23d 3h 58m 59s ago.
10:23:11 <beelsebob> :/
10:23:15 <pumpkin> that's not meaningful :)
10:23:23 <pumpkin> pumpkinbot's only around when matlab isn't :/
10:23:27 <pumpkin> bah
10:23:29 <pumpkin> lambdabot
10:23:29 <beelsebob> yep
10:23:39 <pumpkin> damn matlab polluting my screen and mind
10:23:48 <beelsebob> the :/ was more about \bot having buggered off for the evening
10:23:57 <beelsebob> aww *hugs*
10:23:58 <pumpkin> it's been gone for a while now
10:24:07 <beelsebob> yeh, I know
10:24:13 <beelsebob> is there a problem with her?
10:24:22 <pumpkin> Cale's host went offline I think
10:24:26 <beelsebob> ah, I see
10:24:27 <pumpkin> dons grew a tail!
10:24:30 <int80_h> is this true? Since the first argument of foldl takes (a -> b-> c), and the type of zipWith is  (a -> b -> c) -> [a] -> [b] -> [c], foldl cannot take zipWith as am argument?
10:25:00 <pumpkin> it could, it would just cause a and c to be equal
10:25:06 <beelsebob> int80_h: no, that's not true
10:25:17 <pumpkin> :t foldl
10:25:18 <pumpkinbot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:25:24 <augustss> :t foldl zipWith
10:25:26 <pumpkinbot>     Couldn't match expected type `b -> c' against inferred type `[c]'
10:25:26 <pumpkinbot>     Probable cause: `zipWith' is applied to too many arguments
10:25:26 <pumpkinbot>     In the first argument of `foldl', namely `zipWith'
10:25:28 <Cale> pumpkin: lispy's host, to be more precise.
10:25:43 <pumpkin> Cale: ah :) I thought you ran the machine, sorry
10:26:04 <pumpkin> :t foldl (zipWith (+))
10:26:06 <pumpkinbot> forall a. (Num a) => [a] -> [[a]] -> [a]
10:26:10 <lilac> int80_h: the first arg of foldl is (x -> y -> x). so if you use zipWith, x = (a -> b -> c), y = [a], x = [b]
10:26:13 <int80_h> pumpkin:; okay I'm just messing up syntax then
10:26:19 <Saizan> pumpkinbot: btw, it should be immune to 'fix id' attacks if you upgrade to the latest mueval on hackage
10:26:30 <lilac> int80_h: since [b] can't unify with (a -> b -> c), you can't use zipWith as the first argument of foldl
10:26:36 * beelsebob notes that zipWith should really be called liftA2
10:26:40 <pumpkin> Saizan: I thought it already was, but I'll do that a bit later, thanks
10:27:07 <int80_h> pumpkin says "yes" lilac says "no"
10:27:09 <int80_h> hmmm
10:27:10 <Saizan> pumpkin: ah, maybe it is :)
10:27:24 <pumpkin> int80_h: not on its own, but you can use it with a function parameter as I gave an example of
10:27:39 <int80_h> pumpkin: ah okay
10:27:55 <rwbarton> int80_h: the problem might be that your premise is false :)
10:27:56 <rwbarton> @type foldl
10:27:58 <pumpkinbot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:28:16 <rwbarton> a -> b -> a is not a -> b -> c
10:28:32 <trygvis> so, what's the best library for picking out some objects of an xml document? atom documents in particular
10:28:38 <dons> rss
10:28:44 <dons> oh, atom? use the feed library
10:28:55 <dons> universal feed parsing and manipulation
10:29:33 <killerboy> preflex???
10:29:45 <killerboy> ok
10:30:06 <lilac> > foldl (zipWith (+)) [1,2,3] [[4,5,6],[7,8,9],[10,11,12]]
10:30:08 <pumpkinbot>   [22,26,30]
10:31:08 <int80_h> hmm, that didn't do what I wanted
10:31:28 <methos> looks right to me
10:31:29 <wchogg> conal : I was following the thread on h-cafe about designing a widget system.  Did you have any specific ideas for the semantics of one?
10:31:34 <lilac> int80_h: what did you want?
10:32:05 <ehird> Anyone here used Pandoc?
10:32:13 <conal> ehird: i hvae
10:32:16 <int80_h> I was trying to get every element from list [1,2,3] added to every element to list [1,2,3]. resulting in [2,3,4,3,4,5,4,5,6]
10:32:25 <mopped> What does the @ operator do in pattern matching?
10:32:26 <ehird> I'm wondering how to make it write out HTML that doesn't have the weird Lispy structure.
10:32:40 <conal> wchogg: i have a bunch of ideas from mulling over this question for years.
10:32:41 <pumpkin> mopped: it binds the entire expression to a name
10:33:03 <int80_h> lilac: I was trying to get every element from list [1,2,3] added to every element to list [1,2,3]. resulting in [2,3,4,3,4,5,4,5,6]
10:33:05 <conal> mopped: it additionally binds a variable.
10:33:06 <pumpkin> mopped: so if you write list@(head:tail), and match [1,2,3] on it, you get list = [1,2,3], head = 1, tail = [2,3]
10:33:20 <conal> mopped: p@(x,y) binds p to the pair and x & y to the elements.
10:33:30 <byorgey> > liftA2 (+) [1,2,3] [1,2,3]
10:33:31 <pumpkinbot>   [2,3,4,3,4,5,4,5,6]
10:33:40 <mopped> aha
10:33:44 <int80_h> lift! ah I haven't covered lifting yet
10:33:57 <pumpkin> int80_h: careful, it can be heavy
10:34:02 <conal> mopped: it's a restricted form of "pattern conjunction": p&p'
10:34:18 <byorgey> > [1,2,3] >>= \x -> [1,2,3] >>= \y -> x + y
10:34:20 <pumpkinbot>       No instance for (Num [b])
10:34:20 <pumpkinbot>        arising from the literal `1' at <inter...
10:34:26 <int80_h> is there a solution using map,zip, things like that?
10:34:27 <byorgey> > [1,2,3] >>= \x -> [1,2,3] >>= \y -> [x + y]
10:34:29 <pumpkinbot>   [2,3,4,3,4,5,4,5,6]
10:34:43 <int80_h> no monads! :)
10:34:54 <pumpkin> int80_h: map.zip is basically equivalent to zipWith
10:35:00 <wks> > [x+y | x <- [1,2,3] , y <- [1,2,3]]
10:35:02 <pumpkinbot>   [2,3,4,3,4,5,4,5,6]
10:35:22 <SamB_irssi> :t zipWith . uncurry
10:35:23 <pumpkinbot> forall b c a b1. (a -> b1 -> b -> c) -> [(a, b1)] -> [b] -> [c]
10:35:29 <int80_h> wks: that is it right there. I was wondering if a list comprehension would be neccesary
10:35:29 <SamB_irssi> :t zipWith . curry
10:35:31 <pumpkinbot> forall a b c. ((a, b) -> c) -> [a] -> [b] -> [c]
10:35:36 <SamB_irssi> :t map . zip
10:35:37 <pumpkinbot> forall a b. [a] -> [[b]] -> [[(a, b)]]
10:35:49 <SamB_irssi> pumpkin: no it isn't!
10:35:56 <conal> Peaker: ping
10:36:02 <byorgey> int80_h: you can do it without a list comprehension, using concatMap.  but a list comprehension is probably the nicest way to do it.
10:36:02 <pumpkin> :P
10:36:10 <jberryman> am I right that you can't make a generic record update function for a datatype and pass the record name? e.g. update d rec x = d{rec=x}
10:36:20 <byorgey> int80_h: list comprehensions are just syntactic sugar, after all.
10:36:31 <rwbarton> @undo [x+y | x <- [1,2,3] , y <- [1,2,3]]
10:36:31 <pumpkinbot> concatMap (\ x -> concatMap (\ y -> [x + y]) [1, 2, 3]) [1, 2, 3]
10:36:42 <wks> int80_h, list comprehension is just a shortcut for the do block, i think
10:36:59 <byorgey> jberryman: not like that, no, although there are ways to do that sort of thing (functional references, etc.)
10:37:04 <Saizan> (DirectoryPath,(</>),"./") is a monoid, right?
10:37:32 <SamB_irssi> :t (map .) . zip
10:37:33 <pumpkinbot>     Couldn't match expected type `a -> b'
10:37:33 <pumpkinbot>            against inferred type `[(a1, b1)]'
10:37:33 <pumpkinbot>     Probable cause: `zip' is applied to too many arguments
10:37:45 <SamB_irssi> :t map (. (.)) zip
10:37:47 <pumpkinbot>     Couldn't match expected type `[((a -> b) -> a -> c1) -> c]'
10:37:47 <pumpkinbot>            against inferred type `[a1] -> [b1] -> [(a1, b1)]'
10:37:47 <pumpkinbot>     In the second argument of `map', namely `zip'
10:37:51 <SamB_irssi> :t map ((.) .) zip
10:37:53 <pumpkinbot>     Couldn't match expected type `[a -> b -> c]'
10:37:53 <pumpkinbot>            against inferred type `[a1] -> [b1] -> [(a1, b1)]'
10:37:53 <pumpkinbot>     In the second argument of `map', namely `zip'
10:37:57 <SamB_irssi> how does that go ?
10:38:05 <asgaroth> Saizan: I'd say yes, the laws seem to apply
10:38:06 <wks> > do x <- [1,2,3] ; y <- [1,2,3]; return (x+y)
10:38:08 <pumpkinbot>   [2,3,4,3,4,5,4,5,6]
10:38:14 <SamB_irssi> @pl \f -> map f . zip
10:38:14 <pumpkinbot> (. zip) . map
10:38:25 <SamB_irssi> :t (. zip) . map
10:38:26 <pumpkinbot>     Couldn't match expected type `[b] -> [(a, b)]'
10:38:26 <pumpkinbot>            against inferred type `[a1]'
10:38:26 <pumpkinbot>       Expected type: (a1 -> b1) -> ([b] -> [(a, b)]) -> c
10:38:29 <rwbarton> > "/foo/bar" </> "baz"
10:38:30 <pumpkinbot>   mueval: Prelude.read: no parse
10:38:33 <rwbarton> , "/foo/bar" </> "baz"
10:38:34 <lunabot>  luna: Not in scope: `</>'
10:39:06 <lilac> @pl \f xs ys -> map f $ zip xs ys
10:39:06 <pumpkinbot> zipWith . curry
10:39:10 <SamB_irssi> @pl \f x y-> map f (zip x y)
10:39:11 <pumpkinbot> zipWith . curry
10:39:25 <lilac> hah, neat :)
10:39:47 <int80_h> woah, I just changed + to ^ for the range [2..99]
10:39:48 <lilac> pl is cleverer than i thought :)
10:39:48 <rwbarton> @pl \f xs ys -> map' f $ zip' xs ys
10:39:48 <pumpkinbot> (. zip') . (.) . map'
10:40:03 <SamB_irssi> lilac: I wish I could tell it "no don't go that way!"
10:40:08 <SamB_irssi> when I wanted to see something else
10:40:20 * SamB_irssi goes to eat lunch before class
10:40:22 <lilac> SamB_irssi: use rwbarton's trick; give it a function it doesn't know about
10:40:32 <int80_h> woah, I just changed + to ^ for the range/domain of [2..99]
10:41:03 <ehird> @hoogle [a] -> [a] -> [a] -> [a]
10:41:04 <pumpkinbot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
10:41:04 <pumpkinbot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:41:04 <pumpkinbot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:41:04 <lilac> SamB_irssi: but i'd say @pl gave the right answer there. mapping over the result of a zip is zipWith territory
10:41:09 <ehird> Not what I was looking for :-)
10:41:14 <ehird> ("Replace substrings")
10:41:33 <lilac> @hoogle Eq a => [a] -> [a] -> [a] -> [a]
10:41:33 <pumpkinbot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
10:41:33 <pumpkinbot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:41:33 <pumpkinbot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:41:53 <lilac> ehird: use Data.List.Split
10:42:02 <lilac> plus intercalate
10:42:18 <ehird> @type intercalate
10:42:19 <pumpkinbot> forall a. [a] -> [[a]] -> [a]
10:42:29 <ehird> @hoogle Eq a => a -> a -> [a] -> [a]
10:42:29 <pumpkinbot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
10:42:29 <pumpkinbot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
10:42:29 <pumpkinbot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
10:42:37 <ehird> ... not even an atomic replace ...
10:42:47 <lilac> > intercalate " " ["Hello", "world"]
10:42:49 <pumpkinbot>   "Hello world"
10:42:57 <ehird> yeah
10:42:58 <redditbot> Graham scan algorithm in Haskell
10:42:58 <redditbot> GHC on SPARC: Join Points
10:43:01 <ehird> I know _that_ :)
10:43:17 <ehird> ok, how could I use Data.List.Split for this?
10:43:18 <lilac> @hoogle Data.List.Split
10:43:18 <pumpkinbot> Data.List splitAt :: Int -> [a] -> ([a], [a])
10:43:18 <pumpkinbot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
10:43:25 <Badger> @hoogle atomically
10:43:25 <pumpkinbot> Control.Exception NestedAtomically :: Exception
10:43:34 <ehird> ah, onSublist
10:43:47 <ehird> split (onSublist "foobar") str
10:44:09 <lilac> > intercalate "\n" (splitOn " " "Hello world")
10:44:10 <pumpkinbot>   mueval: Prelude.read: no parse
10:44:29 <rwbarton> , splitOn " " "Hello world"
10:44:29 <Will\> hello
10:44:30 <lunabot>  ["Hello","world"]
10:44:33 <Will\> what's the !! operator please
10:44:47 <Will\> (asking on behalf of a non-irc friend.. I am no haskell programmer)
10:44:49 <lilac> ehird: splitOn = split . dropDelims . onSublist
10:45:02 <rwbarton> , intercalate "---" (splitOn " " "Hello world")
10:45:03 <lunabot>  "Hello---world"
10:45:07 <ehird> yeah, not what I want
10:45:08 <Badger> @src !!
10:45:08 <pumpkinbot> xs     !! n | n < 0 = undefined
10:45:09 <pumpkinbot> []     !! _         = undefined
10:45:09 <pumpkinbot> (x:_)  !! 0         = x
10:45:09 <pumpkinbot> (_:xs) !! n         = xs !! (n-1)
10:45:11 <ehird> I've got it though
10:45:33 <Will\> passed along, thanks Badger
10:45:34 <rwbarton> Will\: a !! n is the nth element of the list a
10:45:54 <Will\> 0 based it would seem?
10:45:58 <evv> Will\: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:!!
10:46:00 <Will\> I think he's feeling stupid for not working it out now
10:48:26 <mathijs> ?pl \x -> x < 100 && even x
10:48:26 <pumpkinbot> liftM2 (&&) (< 100) even
10:49:01 <asgaroth> I like (&&) <$> (< 100) <*> even better
10:49:47 <lilac> @type (<100) <^(&&)^> even
10:49:49 <pumpkinbot> Not in scope: `<^'
10:49:49 <pumpkinbot> Not in scope: `^>'
10:49:52 <lilac> :(
10:51:13 <skorpan> where can i read about this whole "sum/product of types" thing?
10:51:19 <beelsebob> @let f <^ a = fmap f a
10:51:21 <pumpkinbot>  Defined.
10:51:29 <beelsebob> @let f ^> a = f <*> a
10:51:31 <pumpkinbot>  Defined.
10:51:40 <beelsebob> @type (<100) <^(&&)^> even
10:51:41 <pumpkinbot>     Couldn't match expected type `a -> b' against inferred type `Bool'
10:51:41 <pumpkinbot>     In the first argument of `(<^)', namely `(< 100)'
10:51:41 <pumpkinbot>     In the first argument of `(^>)', namely `(< 100) <^ (&&)'
10:52:27 <beelsebob> oh, woops
10:52:31 <beelsebob> @let a <^ f = fmap f a
10:52:32 <pumpkinbot>  <local>:22:2:
10:52:32 <pumpkinbot>      Multiple declarations of `L.<^'
10:52:32 <pumpkinbot>      Declared at: <local>...
10:52:35 <beelsebob> @undef
10:52:39 <beelsebob> @let a <^ f = fmap f a
10:52:40 <pumpkinbot>  Defined.
10:52:44 <beelsebob> @let f ^> a = f <*> a
10:52:47 <pumpkinbot>  Defined.
10:52:48 <beelsebob> @type (<100) <^(&&)^> even
10:52:49 <pumpkinbot> forall a. (Integral a) => a -> Bool
10:53:08 <Badger> oh the symbols D:
10:53:09 <Will\> thanks again guys
10:53:12 <ehird> :t getContents
10:53:13 <pumpkinbot> IO String
10:53:19 <lilac> beelsebob: nicer as: (<^) = flip (<$>); (^>) = (<*>)
10:53:31 <beelsebob> lilac: yep, but lambdabot doesn't accept them
10:53:36 <lilac> MR?
10:53:44 <beelsebob> that's how I defined them in InfixApplicative
10:54:03 <beelsebob> @undef
10:54:09 <beelsebob> @let (<^) = flip fmap
10:54:10 <pumpkinbot>  <local>:1:12:
10:54:10 <pumpkinbot>      Ambiguous type variable `f' in the constraint:
10:54:10 <pumpkinbot>        `Fu...
10:54:40 <ehird> @hoogle FileName
10:54:40 <pumpkinbot> System.FilePath.Posix dropFileName :: FilePath -> FilePath
10:54:40 <pumpkinbot> System.FilePath.Windows dropFileName :: FilePath -> FilePath
10:54:40 <pumpkinbot> System.IO.Error ioeGetFileName :: IOError -> Maybe FilePath
10:54:41 <lilac> @let {-# LANGUAGE NoMonomorphismRestriction #-} (<^) = flip (<$>)
10:54:41 <pumpkinbot>  <local>:1:55:
10:54:41 <pumpkinbot>      Ambiguous type variable `f' in the constraint:
10:54:42 <pumpkinbot>        `Fu...
10:54:47 <ehird> I'm sure there's an alias for that somewhere
10:54:49 <ehird> ah, FilePath
10:55:50 <leimy> Think I'm hitting some threading/strictness issues.
10:56:02 <leimy> where laziness is not desired, and seemingly difficult to turn off.
10:56:20 <beelsebob> leimy: is it?
10:56:27 <beelsebob> use $! and bang patterns
10:56:30 <leimy> I've got channel driven processing
10:56:32 <dons> leimy: it is always possible to turn it off
10:56:41 <leimy> dons: Yes "possible" :-)
10:56:42 <dons> leimy: e.g. by using a strict Chan
10:56:48 <leimy> but without making the code looking yucky? :-)
10:56:50 <dons> or a strict box
10:56:53 <leimy> hmmm strict chan?
10:56:57 <dons> you using Chan?
10:57:07 <leimy> Yep
10:57:07 <dons> there's a strict version.
10:57:13 * leimy looks
10:57:15 <dons> which is actually preferred, imo
10:57:26 <dons> since lazy ones make little sense
10:57:37 <dons> http://hackage.haskell.org/packages/archive/strict-concurrency/0.2/doc/html/Control-Concurrent-Chan-Strict.html
10:57:54 <Olathe> Yay for Debug.Trace :)
10:58:06 <leimy> Debug Trace is showing that it's working lazily :-)
10:58:08 <mathijs> is there something I need to import (except for Control.Monad) to get 'liftM2 (&&) (<100) even' working?
10:58:24 <leimy> dons: so, I'm not seeing that in the base libs.
10:58:37 <ehird> @hoogle Date
10:58:37 <pumpkinbot> Distribution.Simple.SrcDist dateToSnapshotNumber :: CalendarTime -> Int
10:58:37 <pumpkinbot> Data.Time.Calendar.OrdinalDate fromOrdinalDate :: Integer -> Int -> Day
10:58:37 <pumpkinbot> Data.Time.Calendar.WeekDate fromWeekDate :: Integer -> Int -> Int -> Day
10:58:41 <ehird> :s
10:58:43 <leimy> http://haskell.org/ghc/docs/latest/html/libraries/base/
10:58:48 <leimy> Just Control.Concurrent.Chan
10:58:53 <Olathe> @type liftM2 (&&) (<100)
10:58:55 <pumpkinbot> forall a. (Ord a, Num a) => (a -> Bool) -> a -> Bool
10:59:06 <Olathe> @type liftM2 (&&) (<100) even
10:59:07 <pumpkinbot> forall a. (Integral a) => a -> Bool
10:59:10 <leimy> dons: does this mean I need to cabal-install it?
10:59:41 <Olathe> > liftM2 (&&) (<100) even 5
10:59:43 <pumpkinbot>   False
10:59:44 <dons> leimy: sure
10:59:45 <Olathe> > liftM2 (&&) (<100) even 6
10:59:46 <pumpkinbot>   True
11:00:04 <leimy> dons: argh... ok I was hoping I had my dependencies figured out by now.
11:00:17 <dons> cabal install strict-concurrency
11:00:19 <dons> 'nuf said.
11:00:37 <leimy> thx
11:00:44 <leimy> I need to do that for 3 build environments
11:00:55 <mathijs> Olathe: I'm getting an error when I say 'let t = liftM2 (&&) (<100) even'
11:00:59 <leimy> this thing is "supported" on windows, mac and linux
11:01:14 <Olathe> mathijs: What error ?
11:01:22 <rwbarton> leimy: in theory it should be as simple as writeChan chan $! value ...
11:01:44 * leimy tries that first.
11:01:48 <rwbarton> ... depending on how much you need to force the value
11:01:51 <mathijs>     No instance for (Monad ((->) a))
11:01:51 <mathijs>       arising from a use of `liftM2' at <interactive>:1:8-30
11:01:51 <mathijs>     Possible fix: add an instance declaration for (Monad ((->) a))
11:01:51 <mathijs>     In the expression: liftM2 (&&) (< 100) even
11:01:51 <mathijs>     In the definition of `t': t = liftM2 (&&) (< 100) even
11:01:59 <leimy> I had my $! in the wrong place it seems
11:02:01 <sjanssen> import Control.Monad.Instances
11:02:26 <mathijs> sjanssen: thanks
11:02:44 <ehird> what type should I use for a date?
11:02:56 <Olathe> ehird: NiceRestaurant
11:03:00 <evv> protection
11:03:04 <ehird> hur hur hur
11:03:10 <mathijs> sjanssen: How could I have known that myself? I looked at hayoo and found Control.Monad. I would expect that to import stuff it needs itself?
11:04:08 <ehird> but, seriously.
11:04:38 <skorpan> is there any tool for converting lhs to hs?
11:05:55 <beelsebob> skorpan: sed s/$/-- /g | sed s/$> //g
11:06:00 <beelsebob> or something to that effect
11:06:21 <Saizan> skorpan: GHC can, iirc
11:06:34 <skorpan> ralf hinze has published his source code for "generics for the masses" in lhs for some reason
11:07:01 <sjanssen> skorpan: yes, there is a tool packaged with GHC
11:07:06 <ehird> are there no good datetime libs...?
11:07:17 <sjanssen> mathijs: well, Control.Monad doesn't actually need that instance
11:07:50 <Olathe> dons: Would it be acceptable for Data.Binary to have unbounded lists by interpreting a list of length maxBound to be a list of that length concatenated with the following encoded list ?
11:08:35 <sjanssen> mathijs: the instance for functions is in a seperate module because Haskell '98 doesn't have that instance in the Prelude and instances are exported transitively
11:08:37 <leimy> Chan.Strict has NFData requirements
11:08:50 <leimy> that I'm apparently not meeting.
11:08:57 <int80_h> @type show
11:08:58 <pumpkinbot> forall a. (Show a) => a -> String
11:09:08 <int80_h> @src show
11:09:09 <pumpkinbot> show x = shows x ""
11:09:23 <mathijs> sjanssen: thanks I get it
11:09:23 <rwbarton> leimy: the NFData class is about how much you want to force your values
11:09:53 <ehird> Anyone? :\
11:09:54 <ehird> Guess not.
11:10:41 <leimy> rwbarton: So I have to define rnf for my class basically
11:10:43 <leimy> er my data
11:14:13 <ehird> pandoc users: is there a way to apply just smart typography to a string and no other formatting?
11:15:09 <mmorrow> Olathe: you could do some encoding analogous to http chunked
11:15:09 <pumpkinbot> mmorrow: You have 1 new message. '/msg pumpkinbot @messages' to read it.
11:15:36 <Olathe> mmorrow: How does that work ?
11:15:41 <mmorrow> |nbytes|data|   |nbytes|data|  ....
11:15:54 <Olathe> Ahh.
11:16:08 <mmorrow> (where in http nbytes is a hex string ending in \r\n
11:16:10 <mmorrow> )
11:16:52 <mmorrow> that way cgi/whatever progs can send data as they produce it
11:16:53 <Cheshire> I updated everything before the section on callCC here: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
11:17:06 <Cheshire> Do you think my change is improvement or not?
11:19:40 <mmorrow> Olathe: (and in http a msg would terminate with  |0||)
11:20:03 <mmorrow> so the receiver doesn't know how much data it will eventually get
11:20:24 <Cheshire> (also I guess the callCC section needs updated but I'm not sure what to put there)
11:20:58 <mmorrow> (well, actually there can be a footer section with some headers in http, but that's not really relevant to the analogy)
11:21:57 <Olathe> I think something like that might be nice for Integers.
11:22:50 <guenni> how can I determine the directory of the executable?
11:22:52 <Cheshire> Olathe, like cryptol?
11:23:10 <mmorrow> yeah, it definitely could be (although i hadn't thought about Integers in particular). it'd be nice for lists too of course.
11:23:49 <Cheshire> mopped, are you still here?
11:23:55 <mmorrow> omg, so apparently Doubles encode to 25 bytes with Data.Binary
11:24:29 <mopped> yes, hi Cheshire
11:25:15 <mmorrow> i don't understand why that is
11:25:17 <Cheshire> mopped, hey, will you tell me if the first two sections (everything before callCC) makes sense here please?: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
11:26:32 <mmorrow> guenni: search for it in the PATH?
11:26:45 <mopped> i'll have a look Cheshire
11:26:52 <Olathe> Are there any GUI text editors for Windows that have Haskell syntax highlighting with monospace fonts that are actually monospace even when some text is bold and some isn't ?
11:27:11 <evv> vim and emacs
11:27:14 <dons> notepad?
11:27:17 <Olathe> ScITE is pretty annoying with its nonmonospace stuff.
11:27:27 <Olathe> That doesn't have syntax highlighting.
11:27:33 <mmorrow> guenni: i bet cabal and/or most compilers'd have code to do that somehow
11:28:26 <mopped> > \x -> x + 2 $ 5
11:28:27 <pumpkinbot>       Overlapping instances for Show ((a -> b) -> b)
11:28:27 <pumpkinbot>        arising from a us...
11:28:49 <mmorrow> dons: why are Doubles 25 bytes encoded with Data.Binary?
11:29:22 <mathijs> is there any work underway to make ghc aware of mathematical/logical rules? for example map (\x -> x^2 < 100) would execute faster when doing map (\x -> x < 10). Also, when using quicksort on a finite list, using filter (<100) on it could be interpreted as takeWhile (<100) if the compiler somehow knows that the result is ordered. These 2 examples can both be detected at compile-time, so the RTS won't get extra overhead.
11:29:48 <guenni> mmorrow: Hi, nice to hear from you again
11:30:06 <mmorrow> you too
11:30:34 <dons> mmorrow: pick a portable encoding.
11:30:40 <dons> > encodeFloat pi
11:30:41 <pumpkinbot>       Overlapping instances for Show (Int -> a)
11:30:41 <pumpkinbot>        arising from a use of ...
11:31:03 <dons> > decodeFloat pi
11:31:04 <pumpkinbot>   (7074237752028440,-51)
11:31:07 <rtra> i tried do do a tail recursive length, but it still overflows on big lists:  http://codepad.org/QKK7nBHU  -- why?
11:31:11 <dons> now, encode that.
11:31:14 <mmorrow> hmm, i see.
11:31:32 <mmorrow> i can't imagine it'd be too hard to do better than 25 bytes
11:31:35 * mmorrow will try
11:31:36 <dons> Data.Binary is /not/ space optimised. use compress . encode
11:31:38 <dons> if you care.
11:31:42 <Olathe> Ahh, it appears the problem was with the font, not the editor.
11:31:47 <mmorrow> ah
11:31:55 <dons> its FAQ.
11:32:12 <dons> it is primiarly a portable encoder, then a fast one, then an space optimised one.
11:32:14 <koeien> rtra: try c `seq` in the recursive case
11:32:51 <rtra> oh, of course!
11:33:03 <rtra> now that i read seq'
11:33:12 <rtra> s doc, i remembered lazyness
11:34:01 <Olathe> > decodeFloat (pi :: Double)
11:34:02 <pumpkinbot>   (7074237752028440,-51)
11:34:03 <rwbarton> > decodeFloat (0/0)
11:34:05 <pumpkinbot>   (-6755399441055744,972)
11:34:18 <Olathe> @type decodeFloat (pi :: Double)
11:34:19 <pumpkinbot> (Integer, Int)
11:34:21 <rwbarton> > encodeFloat (-6755399441055744,972)
11:34:22 <pumpkinbot>   Couldn't match expected type `Integer'
11:34:26 <Olathe> @type decodeFloat
11:34:27 <pumpkinbot> forall a. (RealFloat a) => a -> (Integer, Int)
11:34:27 <rwbarton> :t encodeFloat
11:34:29 <pumpkinbot> forall a. (RealFloat a) => Integer -> Int -> a
11:34:33 <rwbarton> > uncurry encodeFloat (-6755399441055744,972)
11:34:34 <Olathe> Hmmm
11:34:34 <pumpkinbot>   -Infinity
11:34:42 <rwbarton> > 0/0
11:34:43 <rtra> btw, I'm on ch03 of RWH and i'm thinking of buying the pdf. Is it alright? Will I be able to read it in any pdf reader?
11:34:44 <pumpkinbot>   NaN
11:34:52 <dons> rtra: yes.
11:34:55 <ehird> > drop 1 [1,2,3]
11:34:56 <pumpkinbot>   [2,3]
11:34:58 <mopped> ah I finally understand whats going on Cheshire
11:35:02 <ehird> > dropEnd 1 [1,2,3]
11:35:03 <pumpkinbot>   mueval: Prelude.read: no parse
11:35:12 <mopped> i was trying to read the statement backwards, like i would most haskell code sort of
11:35:16 <Cheshire> mopped, ok great!
11:35:28 <mopped> and i wasnt sure where things were coming from
11:35:38 <Cheshire> mopped, so it's mostly ok?
11:35:46 <mopped> yep
11:36:52 <Olathe> > fromIntegral (-51 :: Int64) :: Word64
11:36:53 <pumpkinbot>   18446744073709551565
11:37:00 <leimy> still having an issue somehow.
11:38:28 <Olathe> > decodeFloat' x = shiftL ma 64 .|. ((fromIntegral ex) :: Word64) where (ma, ex) = decodeFloat x in decodeFloat' pi
11:38:29 <pumpkinbot>   mueval: Prelude.read: no parse
11:38:32 <Olathe> > let decodeFloat' x = shiftL ma 64 .|. ((fromIntegral ex) :: Word64) where (ma, ex) = decodeFloat x in decodeFloat' pi
11:38:33 <pumpkinbot>   Couldn't match expected type `Integer'
11:38:37 <Olathe> Lies.
11:38:43 <Olathe> > let decodeFloat' x = shiftL ma 64 .|. fromIntegral ((fromIntegral ex) :: Word64) where (ma, ex) = decodeFloat x in decodeFloat' pi
11:38:45 <pumpkinbot>   130496653328243024573100180589510605
11:38:59 <beelsebob> @hoogle on
11:38:59 <pumpkinbot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:38:59 <pumpkinbot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
11:38:59 <pumpkinbot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
11:40:35 <Olathe> > let encodeFloat' x = encodeFloat (shiftR x 64, fromIntegral (fromIntegral x :: Word64)) in encodeFloat' 130496653328243024573100180589510605
11:40:36 <pumpkinbot>   Couldn't match expected type `Integer'
11:40:42 <leimy> I think it might be because some of my response channel stuff is "Nothing"
11:40:48 <leimy> and it may not mean anything to send nothing?
11:40:57 <leimy> on a channel I mean.
11:41:03 <ehird> this program is turning out really nicely :)
11:41:11 <Olathe> @type encodeFloat
11:41:12 <pumpkinbot> forall a. (RealFloat a) => Integer -> Int -> a
11:41:26 <Olathe> > let encodeFloat' x = encodeFloat (shiftR x 64) $ fromIntegral (fromIntegral x :: Word64)) in encodeFloat' 130496653328243024573100180589510605
11:41:27 <pumpkinbot>   mueval: Prelude.read: no parse
11:41:37 <leimy> Yeah... Maybe is screwing with my strictness I think... interesting
11:42:18 <ehird> @hoogle strip
11:42:19 <pumpkinbot> Distribution.Simple.LocalBuildInfo stripExes :: LocalBuildInfo -> Bool
11:42:19 <pumpkinbot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
11:42:19 <pumpkinbot> Distribution.Simple.Program stripProgram :: Program
11:42:23 <ehird> @hoogle chomp
11:42:23 <pumpkinbot> No results found
11:42:30 <ehird> (trying to remove starting + ending whitespace)
11:42:59 <redditbot> Flask: a reactive programming language for sensor networks as a Haskell EDSL
11:43:24 <mopped> Cheshire: is return just standard notation for monad things?
11:43:35 <mmorrow> ehird: i think the best you can do is a double reverse
11:43:35 <Cheshire> mopped, yeah,  return :: a -> m a
11:43:39 <Olathe> > let encodeFloat' x = encodeFloat (shiftR x 64) (fromIntegral (fromIntegral x :: Word64) :: Int) in encodeFloat' 130496653328243024573100180589510605
11:43:40 <pumpkinbot>   3.141592653589793
11:43:46 <Cheshire> mopped, it's one of the monad primitives
11:43:46 <ehird> mmorrow: and use what on the reversed?
11:44:23 <Cheshire> mopped, so in Maybe monad,  return 3 ~> Just 3,  in List, return 3 ~> [3], in Cont.. I guess that return 3 throws 3 into the continuation
11:44:32 <mmorrow> triml = dropWhile isSpace;  trim = reverse . triml . reverse . triml
11:44:52 <mmorrow> hmm
11:45:02 <ehird> ok, thanks :)
11:45:10 <mopped> Why is runCont (a -> r) -> r, when it takes two arguments?
11:45:21 <mopped> might be more monad magic
11:46:00 <rwbarton> @type runCont
11:46:01 <pumpkinbot> forall r a. Cont r a -> (a -> r) -> r
11:46:05 <rwbarton> just record syntax maic
11:46:07 <rwbarton> *magic
11:46:53 <mopped> ah, bad reading from myself
11:47:11 <dons> dcoutts: gtk2hs head is building nicely. is a release immenent?
11:47:15 <dons> however that is spelled, gwern?
11:47:17 <mopped> does a function become a cont, purely from its type declaration?
11:47:21 <ehird> @hoogle FilePath -> String -> IO ()
11:47:22 <pumpkinbot> Prelude appendFile :: FilePath -> String -> IO ()
11:47:22 <pumpkinbot> Prelude writeFile :: FilePath -> String -> IO ()
11:47:22 <pumpkinbot> System.IO appendFile :: FilePath -> String -> IO ()
11:48:11 <mmorrow> , let trimr = let go acc [] = []; go acc (c:cs) | isSpace c = go (c:acc) cs | otherwise = reverse acc ++ [c] ++ go [] cs in go [] in trimr "aaaaaaa      aaaa    aaaaaa                 "
11:48:12 <lunabot>  "aaaaaaa aaaa aaaaaa"
11:48:17 <mmorrow> argh
11:48:53 <beelsebob> @hoogle toRational
11:48:53 <pumpkinbot> Prelude toRational :: Real a => a -> Rational
11:51:22 <mmorrow> um, i'm not seeing how that's not doing what it's supposed to
11:53:54 <rwbarton> , "   aaa  aaaa    aaaaaaaaaaaa         "
11:53:55 <lunabot>  " aaa aaaa aaaaaaaaaaaa "
11:54:01 <rwbarton> there's your problem :)
11:54:04 <mmorrow> ummmmm
11:54:10 <beelsebob> @hoogle a -> Double
11:54:10 <pumpkinbot> Prelude id :: a -> a
11:54:10 <pumpkinbot> Data.Function id :: a -> a
11:54:10 <pumpkinbot> Unsafe.Coerce unsafeCoerce :: a -> b
11:54:13 <rtra> is it ok to use 2 seq's to strictly eval 2 function args? is there a more compact way, using only one seq, without doing a dummy operation on them?
11:54:18 <mmorrow> rwbarton: !
11:54:22 <rwbarton> , map (:[]) "   aaa  aaaa    aaaaaaaaaaaa         "
11:54:23 <lunabot>  [" ","a","a","a"," ","a","a","a","a"," ","a","a","a","a","a","a","a","a",...
11:54:27 <rwbarton> input problem
11:54:32 <mmorrow> whoa!
11:54:45 <mmorrow> that's super weird
11:55:32 <methos> @src lookup
11:55:32 <pumpkinbot> lookup _key []          =  Nothing
11:55:32 <pumpkinbot> lookup  key ((x,y):xys) | key == x  = Just y
11:55:32 <pumpkinbot>                         | otherwise = lookup key xys
11:56:45 <Cale> mmorrow: Are you words'ing the input somewhere?
11:56:50 <rwbarton> rtra: you might like  (f $! x) $! y
11:57:19 <mmorrow> Cale: i'm not sure. i'm interested to find out what's causing this though
11:57:40 <mmorrow> ohhhhh
11:57:43 <mmorrow> yes i am
11:57:47 <mmorrow> nice call
11:59:47 <mopped> What does the !! operator do?
11:59:57 <mmorrow> , [0..9] !! 4
11:59:58 <lunabot>  4
12:00:09 <mmorrow> , ['a'..'z'] !! 4
12:00:10 <lunabot>  'e'
12:00:16 <mopped> aha
12:01:49 <methos> cool ... (silence) :D
12:03:00 <Gracenotes> @pl \f -> uncurry f . zip [0..]
12:03:00 <pumpkinbot> (. zip [0..]) . uncurry
12:03:27 <papermachine> If I have a list of functions, how do I apply the same argument to each of them?
12:03:58 <papermachine> I want to map, but I don't know what function to put in map's first argument :/
12:04:11 <Gracenotes> > map ($4) [(*3), negate, (-1)]
12:04:12 <pumpkinbot>       No instance for (Num (a -> a))
12:04:12 <pumpkinbot>        arising from a use of `negate' at...
12:04:14 <arjanb> map ($ x)
12:04:17 <Gracenotes> eek :X
12:04:20 <papermachine> ahhh
12:04:27 <Gracenotes> ah, negate is the odd one out
12:04:36 <pumpkin> moo
12:04:37 <rwbarton> nope, (-1)
12:04:44 <Gracenotes> oh.. I see! Tricksy.
12:04:46 <koeien> Gracenotes: (-1) != (\x -> x -1)
12:04:50 <Gracenotes> > map ($4) [(*3), negate, (subtract 1)]
12:04:51 <pumpkinbot>   [12,-4,3]
12:04:53 <koeien> i hate hate hate unary minus
12:04:55 <Gracenotes> success!
12:04:59 <pumpkin> koeien: != /= /=
12:05:03 <pumpkin> :P
12:05:16 <rwbarton> x -1, that means x $ -1 right? :)
12:05:17 <koeien> whoops
12:05:49 <Badger> @src negate
12:05:49 <pumpkinbot> negate x = 0 - x
12:06:20 <kerlo> pumpkin: != /= (!=) and /= /= (/=)
12:06:21 <Gracenotes> I wonder why pumpkinbot pointed out negate as the unusual one
12:06:23 <kerlo> :-)
12:06:26 <pumpkin> !
12:06:46 <Gracenotes> given that the first element of the list is a -> a, the second is a -> a, and the third is a. <= Num a
12:07:04 <Olathe> > shiftR (-1) 1
12:07:05 <pumpkinbot>   Add a type signature
12:07:08 <Olathe> > shiftR (-1) 1 :: Integer
12:07:09 <pumpkinbot>   -1
12:07:23 <Gracenotes> it seems ghci has a special weakness for wanting functions to be numbers
12:07:30 <Olathe> > shiftR (-240) 8 :: Integer
12:07:31 <pumpkinbot>   -1
12:07:39 <skorpan> does anyone know of any examples of emgm in use?
12:07:50 <tromp__> question about haskell wiki: does anyone known a user "EndreyMark" ?
12:08:10 <tromp__> http://www.haskell.org/haskellwiki/User:EndreyMark
12:08:14 <kerlo> So, we still don't have ++ patterns, do we.
12:08:25 <tromp__> i want to contact him, but see no contact info
12:08:40 <skorpan> nvm
12:09:06 <Gracenotes> kerlo: eh... y:o:u: :c:a:n: :s:t:i:l:l: :d:o:t:h:i:s:::P
12:09:15 <kerlo> 'T':'
12:09:18 <kerlo> Rather...
12:09:24 <pumpkin> phailnotes
12:09:29 <kerlo> 'T':'r':'u':'e':'.':[]
12:09:31 <pumpkin> :P
12:09:33 <Gracenotes> :"with this at the end"
12:09:50 <kerlo> 'T':"his is a whole lot more concise."
12:10:44 * kerlo ponders a "drop two words" function
12:10:47 <Gracenotes> 'I':' ':'c':'a':'n':''':'t':' ':'t':'i':'m':'e':' ':'t':'o':' ':' ':'t':'h':'e':' ':'t':'ime':' ':'t':'o':' ':'a':'d':'d':' ':'c':'h':'a':'r':'a':'c':'t':'e':'r':' ':'q':'u':'o':'t':'e':'s':[]
12:11:13 <Gracenotes> 'F':'a':'r':' ':'t':'o':'o':' ':'t':'e':'d':'i':'o':'u':'s':[]
12:11:18 <kerlo> 'ime' is a weird character.
12:11:24 <pumpkin> PHAIL
12:11:30 <Gracenotes> :D
12:11:32 <Olathe> > let convert = ('\'':) . (++"':") . intercalate "\':\'" . map (:[]) in convert "omgkthx"
12:11:33 <pumpkinbot>   "'o':'m':'g':'k':'t':'h':'x':"
12:11:44 <kerlo> Must be ASCII CONTROL CHARACTER END OF TIME.
12:12:00 <Gracenotes> kerlo: I don't know what you're talking about. I use ime all the time in my flagship enterprise C++ applications
12:12:29 <olsner> multi-character literals are a dubious feature
12:12:34 <ehird> Is there a way to make Text.XHtml output HTML?
12:12:48 <olsner> (which is why, obviously, C++ has them)
12:12:56 <Gracenotes> olsner: they're not even well-defined, are they?
12:13:16 <olsner> it's not well-defined what they *mean*, but they're mentioned in the standard anyway
12:13:30 <Gracenotes> yeah.
12:13:32 <olsner> iirc, apple gcc uses them to build fourcc-codes
12:13:41 <mopped> is there a bit array type in haskell? or a matrix? something that would support getting values from adjoining cells easy :P
12:13:54 <mmorrow> ehird: renderHtml ?
12:14:02 <Gracenotes> also, ''' is a weird character
12:14:13 <rwbarton> > '''
12:14:14 <pumpkinbot>       lexical error in string/character literal at character '\''
12:14:17 <kerlo> Anyway, I'm looking to break "one two three four five" into ("one","two","three four five").
12:14:20 <rwbarton> > ''
12:14:21 <pumpkinbot>       lexical error in string/character literal at character '\''
12:14:21 <ehird> mmorrow: HTML vs XHTML
12:14:22 <Gracenotes> heh.
12:14:23 <ehird> I want HTML
12:14:24 <loadquo> Mopped, an array of bools is efficient I believe.
12:14:31 <beelsebob> Does anyone have a good way of dealing with my AffineSpace instance overlapping with *everything* here? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1140#a1140
12:14:38 <Gracenotes> you were looking for ''', and pumpkinbot gave you what you meant :)
12:14:42 <Gracenotes> '\''
12:14:43 <kerlo> @hoogle break
12:14:44 <pumpkinbot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
12:14:44 <pumpkinbot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
12:14:44 <pumpkinbot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
12:14:47 <mopped> Yeah, I was just wondering how i'd implement it, code wise ;P
12:14:51 <kerlo> Great.
12:14:52 <tromp__> > words "one two three four five"
12:14:53 <pumpkinbot>   ["one","two","three","four","five"]
12:15:06 <olsner> > intercalate ":" . (++["[]"]) . map show $ "test"
12:15:07 <Gracenotes> @src words
12:15:07 <pumpkinbot> words s = case dropWhile isSpace s of
12:15:07 <pumpkinbot>     "" -> []
12:15:07 <pumpkinbot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:15:08 <kerlo> > break isSpace "one two three four five"
12:15:08 <pumpkinbot>   "'t':'e':'s':'t':[]"
12:15:09 <pumpkinbot>   ("one"," two three four five")
12:15:16 <mmorrow> ehird: oh. i don't think so
12:15:18 <kerlo> Hmm, close enough.
12:15:25 <mmorrow> ehird: you could use the html pkg though
12:15:26 <loadquo> Mopped, do you need it to change much?
12:15:59 <mmorrow> ehird: i think the interface is similar/nearly identical (although i've never used html personally)
12:16:03 <mopped> the array wouldn't change, but i'd need to find the data from surrounding cells
12:16:08 <ehird> mmorrow: I can't tell Pandoc to use that.
12:16:18 <mopped> in python i'd implement a list of lists (for each row), i'm not sure how in haskell
12:16:29 <mmorrow> ehird: looks like you're in a pickle
12:16:53 <mmorrow> that's a bizarre saying now that i think of it
12:17:02 <ehird> well, that sucks.
12:17:09 <ehird> I don't want XHTML...
12:17:18 <mmorrow> I WANT A PONY!!
12:17:26 <mmorrow> :)
12:17:28 <SubStack> poe knees
12:18:23 <ehird> @hoogle Int -> Integer -> String
12:18:24 <pumpkinbot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
12:18:24 <pumpkinbot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
12:18:24 <pumpkinbot> Prelude flip :: (a -> b -> c) -> b -> a -> c
12:19:31 <mmorrow> isn't xhtml == html other than the header-header ?
12:19:39 <mmorrow> (or something)
12:19:44 <loadquo> mopped, use an IArray of IArray bools. I think that'd work. Or you could go old school and treat a singal dimensional array as two dimensional using appropriate arithmetic to figure out the indices.
12:20:14 <mopped> the latter is what i would have done
12:20:21 <mopped> i'll look into IArray
12:20:34 <ehird> <mmorrow> isn't xhtml == html other than the header-header ?
12:20:34 <rwbarton> or if your grid is rectangular, you can just use a two-dimensional array
12:20:35 <ehird> <br/>
12:20:39 <ehird> is XHTML
12:20:41 <ehird> <br> is HTML.
12:20:48 <mmorrow> ooh, tidy ftw!
12:20:48 <rwbarton> ehird: so you're saying you want the inverse of tagsoup
12:20:56 <mmorrow>  -ashtml             force XHTML to well formed HTML
12:21:02 <mmorrow> -asxml, -asxhtml    convert HTML to well formed XHTML
12:21:05 <ehird> I _could_ s/\/>/>/ :-P
12:21:06 <tromp__> you can index an IArray with (Int,Int)
12:21:17 <ehird> rwbarton: hrm?
12:21:20 <mmorrow> [m@ganon ~]$ tidy -v
12:21:20 <mmorrow> HTML Tidy for Linux/x86 released on 14 June 2007
12:21:30 <rwbarton> ehird: convert well-formed XHTML to a random pile of <>s
12:21:32 <ehird> mmorrow: I know what HTML tidy is.
12:21:39 <Gracenotes> @hoogle untilM
12:21:39 <pumpkinbot> No results found
12:21:41 <mmorrow> ehird: ok
12:22:10 <Gracenotes> @src until
12:22:10 <pumpkinbot> until p f x | p x       = x
12:22:10 <pumpkinbot>             | otherwise = until p f (f x)
12:22:12 <ehird> rwbarton: Er, that's a very XML-centric view. Well-formed HTML5 is every bit as precise as well-formed XHTML.
12:22:23 <ehird> (And doesn't violate Postel's Law &co.)
12:23:08 <zever> hi guys, can someone tell me why I get this parse error and how to solve it? http://pastebin.com/m153c72c7
12:23:11 <mmorrow> ehird: maybe just hack pandoc to do what you want
12:23:23 <ehird> I think I'll just replace /> with >.
12:23:27 <mmorrow> heh
12:23:28 <rwbarton> ehird: I think your use case must just be beyond my imagination
12:23:43 <ehird> rwbarton: I want to generate HTML, Pandoc gives me XHTML.
12:23:49 <ehird> I ... don't really think that's complicated. :P
12:23:58 <rwbarton> ehird: See for me, that would be "problem solved!" :)
12:24:06 <ehird> Hm>
12:24:09 <ehird> *Hm?
12:24:29 <mmorrow> is s/\/>/>/ the only difference?
12:24:37 <ehird> mmorrow: For my purposes, yes.
12:24:40 <rwbarton> Because when I want HTML I really want "something that browsers will display"
12:24:45 <rwbarton> Obviously your purposes are different
12:24:51 <ehird> rwbarton: i'm a stickler ;)
12:25:38 * ehird wonders how to display a number with padded 0s, e.g. 5 -> 005
12:26:01 <rwbarton> > printf "%03d" 5 :: String
12:26:02 <pumpkinbot>   "005"
12:26:09 <koeien> printf is the easier
12:26:12 <koeien> easiest*
12:26:29 <mmorrow> let padl n s = replicate (max 0 (n-length s)) '0' ++ s
12:27:08 <mmorrow> , let padl n s = replicate (max 0 (n-length s)) '0' ++ s in fmap (flip padl "asdf") [0..]
12:27:09 <lunabot>  ["asdf","asdf","asdf","asdf","asdf","0asdf","00asdf","000asdf","0000asdf"...
12:27:11 <koeien> > replicate (-37) 0
12:27:12 <rwbarton> printf is doing something about equally explicit as that
12:27:13 <pumpkinbot>   []
12:27:19 <koeien> mmorrow: no max 0 necessary
12:27:22 <mmorrow> koeien: good point
12:27:32 <mmorrow> , let padl n s = replicate (n-length s) '0' ++ s in fmap (flip padl "asdf") [0..]
12:27:33 <lunabot>  ["asdf","asdf","asdf","asdf","asdf","0asdf","00asdf","000asdf","0000asdf"...
12:27:43 * mmorrow has been coding C too much recently
12:28:05 <ehird> thanks :)
12:29:51 <ehird> @type intercalate
12:29:51 <mmorrow> oops, i meant
12:29:52 <pumpkinbot> forall a. [a] -> [[a]] -> [a]
12:30:16 <mmorrow> oh, n/m
12:30:35 <mmorrow> that was what i meant
12:30:36 <guenni> mmorrow: how do you do that?
12:30:42 <mmorrow> do what?
12:30:55 <guenni> finding the exes path
12:31:01 <rwbarton> , "aa   aa"
12:31:02 <lunabot>  "aa aa"
12:31:29 <mmorrow> oh. i had in mind looking at the $PATH env var (or windows equiv) and parsing it
12:31:41 <mmorrow> then searching for the filename
12:31:59 <rwbarton> zever: You need a 'do' after then 'then'
12:32:15 <mmorrow> or you could readProcess "which" ["foo"] i guess on unix
12:32:42 <zever> rwbarton: I tried but then I get indentation problems :)
12:32:50 <guenni> mmorrow: that won't work here, the exe is a gui and does not in the path. Is there another way an exe can find out where it is?
12:33:35 <mmorrow> guenni: yuk. hmm, i can't think of anything other than exhaustive search (which really isn't something :)
12:33:59 <guenni> mmorrow: ok, thx
12:34:10 <mmorrow> guenni: maybe you can somehow look at the running procs and extract the info from that?
12:34:20 <rwbarton> zever: then the second line of the then has to be indented three more spaces
12:34:31 <guenni> mmorrow: sucks, kinda
12:34:37 <mmorrow> yeah totally
12:35:26 <ehird> :t writeFile
12:35:27 <pumpkinbot> FilePath -> String -> IO ()
12:36:15 <zever> rwbarton: http://pastebin.com/m2b95a493
12:36:22 <ehird> @hoogle liftIO
12:36:22 <pumpkinbot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
12:37:33 <rwbarton> zever: line 22 has unbalanced parentheses :)
12:38:17 <guenni> mmorrow: found something, wxhaskell has a getApplicationPath, I'm saved  :D
12:38:49 <zever> rwbarton: lol, oops, copy pasting ftl :s
12:39:18 <skorpan> where can i read about sum types?
12:39:31 <Cheshire> what's a sum type?
12:39:43 <skorpan> that's what i want to know!
12:39:47 <SubStack> o_O
12:39:58 <SubStack> perhaps you meant "some types"?
12:39:59 <Cheshire> skorpan, did you hear it somewhere? where?
12:40:12 <SubStack> sumwhere
12:40:22 <mmorrow> guenni: nice
12:40:37 <skorpan> Cheshire: reading the paper on generics for the masses by ralf hinze. he uses sum types and product types.
12:40:48 <Cheshire> skorpan, in that case it means Either
12:40:50 <skorpan> i don't want to resort to using wikipedia for this :|
12:40:55 <Cheshire> Either a b sometimes gets written a + b
12:41:00 <Cheshire> and (a,b) written a * b
12:41:34 <skorpan> so why has hinze even introduced the :+: datatype?
12:41:35 <hackage> Uploaded to hackage: regex-posix 0.94.1
12:41:35 <hackage> Uploaded to hackage: regex-posix-unittest 1.0
12:41:35 <hackage> Uploaded to hackage: regex-tdfa 0.97.1
12:41:35 <hackage> Uploaded to hackage: regex-posix 0.94.0
12:41:43 <Cheshire> with Void for 0, and () for 1 you can sort of see  t + 0 = t  and t * 1 = t  (roughly)
12:42:08 <Cheshire> Either a (Either b (Either c Void)) vs a :+: b :+: c :+: Void
12:43:45 <skorpan> Cheshire: thanks, i'll keep this in mind and try to understand..
12:46:35 <_Jordan_> howdy folks
12:53:21 <adekoba> is there a way to make a derived instance (e.g. Show or Read) of a GADT?
12:53:44 <kerlo> It would be just silly if there weren't.
12:53:45 <dancor> should i feel bad for using [] for something that should always be at least length 1
12:53:59 <dancor> should i use like data NonemptyList
12:54:01 <mmorrow> dons: haha, cool gofer-prelude :)
12:54:24 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gofer-prelude
12:54:25 <kerlo> dancor: only if you feel like reimplementing all of Data.List for it.
12:54:43 <adekoba> kerlo: I keep getting errors for trying to make a derived instance of a "non-Haskell-98 constructor"
12:54:49 <dancor> hm
12:54:56 <dancor> that is a big tradeoff
12:55:05 <mmorrow> wow, i daily wish that ord/chr were in prelude..
12:55:20 <adekoba> kerlo: the only way to make it work is by using "instance ..." but that would be very tedious in my particular case
12:55:29 <mmorrow> nice, and there's fst3/snd3/thd3
12:55:47 <dancor> mmorrow: you could put them in MmorrowUtil and include that in all your stuff or somthengi..
12:55:51 <kerlo> adekoba: yes, unfortunately, I don't actually know how to do it.
12:56:27 <dancor> MMissingH
12:56:29 <mmorrow> dancor: i could, but that's not quite the same as being in Prelude
12:56:34 <dancor> mm
12:57:00 <Raevel> dancor: you could do type NonemptyList a = [a] also, to make it at least a little clearer
12:57:31 <mstr> hmm, would anyone know an example how to return a n-long list of random numbers: 1-n, 1-(n-1), 1-(n-2) etc?
12:57:44 <dancor> Raevel: maybe i will do that
12:57:46 <Raevel> dancor: and make a custom "constructor"
12:57:53 <Cheshire> Raevel, what a terrible lie
12:57:59 <Raevel> Cheshire: wha?
12:58:04 <dancor> clarity vs lies
12:58:06 <dancor> another trade-off
12:58:10 <Cheshire> Raevel, data NonEmptyList a = Cons a [a]
12:59:09 <beelsebob> mstr: those numbers don't seem to be very random?
12:59:28 * dancor is doing NonemptyList since nonempty is a scrabble word
12:59:29 <beelsebob> also ... f n = [1-n .. 1]
12:59:30 <mstr> beelsebob: read "1-n" as "random number between 1 and n
12:59:36 <beelsebob> oh, okay
13:01:13 <beelsebob> > let f n s = map rand [n,n-1..1] where rand n = randomR (1,n) s in f 5 (mkStdGen 42)
13:01:15 <pumpkinbot>   [(2,1720602 40692),(4,1720602 40692),(3,1720602 40692),(2,1720602 40692),(1...
13:01:34 <beelsebob> oh woops, that should be a fold
13:01:54 <beelsebob> need to fold the seed down the list
13:01:58 <beelsebob> but you get the idea
13:02:03 <beelsebob> hmm actually
13:02:19 <TuringTest> Is anyone running GHC on something more exotic than Linux or OS X?
13:02:39 <dancor> haskell-beos
13:02:49 <TuringTest> dancor: I disbelieve
13:02:52 <trygvis> TuringTest: yah, solaris 11
13:02:57 <dancor> TuringTest: you pass the test!
13:03:00 <trygvis> and solaris 10 I guess
13:03:05 <pumpkin> TuringTest: I've compiled GHC in GHC on a mote
13:03:40 <TuringTest> trygvis: I just posted to hackage a package called regex-posix-unittest .  You see regex-posix comes with GHC and uses the OS C library's "regex.h"
13:03:47 <TuringTest> And these are often buggy
13:04:11 <beelsebob> > let f n s = zipWith (/) (randomRs (1,n) s) [m / n | m <- [1..n]] in f 5 (mkStdGen 42)
13:04:12 <pumpkinbot>   [7.20814025313783,10.953984927258915,3.7185475630806484,5.156940413035206,3...
13:04:20 <beelsebob> obviously not >.<
13:04:22 <TuringTest> trygvis: If you install and run regex-posix-unittest it will run some unittests on Solaris and these can be posed to the wiki for comparison
13:04:48 <beelsebob> > randomRs (1,5) (mkStdGen 42)
13:04:49 <pumpkinbot>   [2,2,3,5,2,2,4,2,4,1,1,5,2,4,5,1,3,2,4,2,2,5,3,5,2,5,1,4,4,5,5,1,3,3,2,4,5,...
13:04:58 <beelsebob> oh, divide >.<
13:05:04 <beelsebob> > let f n s = zipWith (*) (randomRs (1,n) s) [m / n | m <- [1..n]] in f 5 (mkStdGen 42)
13:05:05 <pumpkinbot>   [0.2883256101255132,1.7526375883614265,1.3386771227090333,3.300441864342532...
13:05:13 <beelsebob> and that's backwards >.<
13:05:18 <TuringTest> The goal is to at least document the bugs in the operating systems GHC runs on.
13:05:30 <TuringTest> Well, the bugs in "regex.h" anyway.
13:06:32 <TuringTest> OS X and FreeBSD and NetBSD share a nasty nasty bug.  Linux's GLIBC does not even try.  The wiki page at http://www.haskell.org/haskellwiki/Regex_Posix discusses some of the bugs exposed by regex-posix-unittest
13:06:49 <TuringTest> Hmm...is dons online?
13:06:59 <TuringTest> dons: Are you still running OpenBSD anywhere?
13:07:05 <methos> @seen dons
13:07:05 <pumpkinbot> dons is in #haskell. I last heard dons speak 1h 19m 50s ago.
13:07:37 <TuringTest> Hmm...Lunch time on west coast.
13:08:04 <methos> bed time in Austria ^^
13:08:09 <trygvis> TuringTest: yah, just not now. busy busy
13:09:06 <TuringTest> trygvis: Of course, carry on.  There is no hurry at all.  Mainly just intense curiousity disguised as a desire for better documentation.
13:09:34 <TuringTest> I am so curious I put the tests on hackage.
13:09:45 <TuringTest> Is something wrong with me?
13:09:49 <Badger> yes
13:09:57 <TuringTest> Badger: Thanks, I needed that.
13:10:02 <methos> lol
13:10:05 <Badger> you're welcome
13:10:23 <_Jordan_> General question: do you always use Haskell when you have the chance (e.g. employer doesn't make you use Language X), or do you tend to use one language for certain projects, Haskell for others?
13:10:51 <TuringTest> _Jordan_: I use haskell when I think it is the quickest way to achieve my goal.
13:10:56 <Baughn> "Goals of man: Get out of lion. Get out of africa. Get out of earth. Get out of solar system. Get out of galaxy. Get out of local group. Get out of earth-visible universe. Get out of universe. Get out of haskell program."
13:11:05 <koeien> _Jordan_: Haskell mostly. or shell for trivial plumbing stuff
13:11:09 <evv> _Jordan_: i participated in the global game jam this weekend and made a game in 48 hours. i could have used whatever language i wanted but did not choose haskell
13:11:15 <osfameron> @src foldl
13:11:15 <pumpkinbot> foldl f z []     = z
13:11:15 <pumpkinbot> foldl f z (x:xs) = foldl f (f z x) xs
13:11:20 <Baughn> evv: How did that go?
13:11:20 <osfameron> @src foldr
13:11:20 <pumpkinbot> foldr f z []     = z
13:11:20 <pumpkinbot> foldr f z (x:xs) = f x (foldr f z xs)
13:11:27 <evv> Baughn: it was awesome!
13:11:28 <Badger> evv: cos you couldn't have done it in 48hrs? :P
13:11:37 <_Jordan_> evv: what did you use?
13:12:11 <evv> the current state of haskell was just not optimal for the task
13:12:23 <evv> _Jordan_: i used python and pygame library
13:12:43 <evv> maybe in a few years haskell will be ready to tackle such a challenge though
13:13:21 <_Jordan_> evv: When you say "current state of Haskell," do you mean library-wise, or something more inherent?
13:13:27 <dancor> i made a brickbreaker clone for a halloween party in three hours
13:13:40 <dancor> that was my shining moment for haskell gaming
13:14:10 <dancor> it was close tho, i was almost late
13:14:12 <SubStack> glut bindings for haskell are pretty nifty
13:14:23 <Baughn> ..still GLUT, though
13:14:24 <evv> dancor: nice, but i am willing to bet that you could have had more success with a different language
13:15:06 <dancor> maybe python
13:15:08 <evv> the SDL and OpenGL bindings for haskell are excellent and i do believe that amazing things are possible
13:15:09 <dancor> i'm not sure
13:15:23 <Baughn> evv: So, what exactly about Haskell got in your way?
13:15:25 <olivierp> hi, is there a way to specify that e.g. a field of a record must be of an instance of type class C, _or_ of type A ? (Type A being () in my particular case) ?
13:15:26 <SubStack> you can pass around monads that modify the gl matrix stack instead of doing lots of vector maths
13:15:31 <SubStack> pretty nifty
13:15:42 <SubStack> open scene graph is pretty fun too
13:16:06 <Gracenotes> @index on
13:16:06 <pumpkinbot> bzzt
13:16:18 <Gracenotes> @hoogle on
13:16:18 <pumpkinbot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:16:18 <pumpkinbot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
13:16:18 <pumpkinbot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
13:16:34 <Gracenotes> Data.Function? hrm :\
13:20:09 <ehird> :t writeFile
13:20:10 <pumpkinbot> FilePath -> String -> IO ()
13:20:13 <dancor> functions are data, just largely inaccessible/nonintrospectable data
13:21:31 <BONUS> hmm. has anyone ever tried serializing functions in haskell?
13:22:47 <dancor> mmorrow: for chr/ord not being in Prelude, another possibly nicer "workaround" is to have a tool that adds guessable import's for you.  i started making one a while back http://dzl.no-ip.org:81/gitweb/?p=himp.git;a=blob;f=src/Main.hs
13:23:04 <Gracenotes> dancor: I mean, it seems like a useful function. Is Data.Function basically a "miscellaneous polymorphic functions" module?
13:23:07 * osfameron fails to "aha!" on how to write foldl in terms on foldr
13:23:30 <Cheshire> A function is an abstract data type with one operation: application
13:23:39 <dancor> Gracenotes: on is super-useful.  no, it's like List:Data.List::functions:Data.Function
13:24:04 <Gracenotes> it seems like there should be more there :)
13:24:07 <leadnose_> @src foldr
13:24:07 <pumpkinbot> foldr f z []     = z
13:24:08 <pumpkinbot> foldr f z (x:xs) = f x (foldr f z xs)
13:24:18 <dancor> yeah but like what can you do with such a closed data type
13:24:30 <dancor> there are some on variants that could be there
13:24:32 <Gracenotes> just move on and fix to Prelude
13:24:43 <Gracenotes> or, well, add more.
13:25:03 <dancor> yeah it does seem strange right now, and i have no idea what direction it's headed in of those two
13:25:17 <dancor> time will tell!
13:25:20 <dancor> Data.Time
13:25:21 <trygvis> ok, newbie question .. if I have a data type Person with a few fields, how can I change the name of the person? (like copy all of the fields and get a new object with a new name)
13:25:36 <dons> let foo = person
13:25:42 <Gracenotes> tediously :\
13:25:46 <mmorrow> dancor: hey, that's a great idea (to parse a module and figure out the (minimal/whatever) imports)
13:25:57 <dons> let foo = person { name = "foo" }
13:26:06 <dons> where person is the old object.
13:26:13 <dons> Gracenotes: why tediously? use the record update syntax
13:26:14 <trygvis> cool, thanks!
13:26:25 <dancor> mmorrow: yeah i haven't had too many wrong-guess disasters.  biggest problem is that hoogle doesn't have everything.  hayoo has more but it's like weirdly more closed-api-ish
13:26:39 <Gracenotes> I can't say I was previously aware of the record update syntax... did RWH mention it? Must have glossed..
13:26:53 <Raevel> pretty sure it did
13:27:11 <leadnose_> you don't really _change_ anything
13:27:16 <dons> ch14-monads.xml
13:28:12 * Gracenotes can't find it
13:29:05 <dons> i don't think we say much on record update syntax.
13:29:16 <Heffalump> cos it's so embarrassing? :-)
13:29:29 <Raevel> is there much *to* say?
13:29:46 <Gracenotes> oh, I see
13:29:58 <dons> ?quote record
13:29:59 <pumpkinbot> ozone says: dons: hey, i have a 100% track record for "things i started in haskell and other people implemented" so far ;)
13:30:01 <dons> ?quote syntax
13:30:01 <pumpkinbot> SyntaxNinja says: <SyntaxNinja> I think that the compiler authors will fly here from england just to kill me if I did that
13:30:05 <dons> ?quote update
13:30:06 <pumpkinbot> ghc says: Empty record update
13:30:07 <Heffalump> "the precedence is all wrong, and it's not first order, but other than that it can be useful"
13:30:09 <Gracenotes> "Record syntax may not exhibit Haskell's usual elegance, but it at least gets the job done. No comments."
13:30:10 <dons> ?quote pumpkin
13:30:10 <pumpkinbot> No quotes match.
13:30:15 <Gracenotes> :)
13:30:20 <dons> record update syntax rocks
13:30:23 <pumpkin> :P
13:30:29 <pumpkin> my bot doesn't know me
13:30:46 <Gracenotes> @where pumpkin
13:30:46 <pumpkinbot> I know nothing about pumpkin.
13:30:52 <Gracenotes> awwww.
13:30:58 <Badger> @vixen who's pumpkin?
13:30:58 <pumpkinbot> that's a good question, who?
13:31:58 <andun> zsh: segmentation fault  ./kt +RTS -P -hc -skt.summary -K8388608000; :0
13:35:01 * edwardk tries and fails to construct a use case for #haskell-in-depth over #haskell-overflow
13:35:51 <dancor> it's just meant to fractionate the would-be overthrowers
13:36:00 <edwardk> ah
13:41:23 <Olathe> @paste
13:41:23 <pumpkinbot> Haskell pastebin: http://hpaste.org/new
13:43:16 <Olathe> I found a way to reduce Doubles to 16 bytes in Binary.
13:43:24 <Olathe> http://www.unsafecoerce.com:8080/fastcgi/hpaste.fcgi/view?id=1141#a1141
13:43:27 <Heffalump> Olathe: hmm :-)
13:43:29 <Olathe> Integers are smaller, too.
13:43:50 <Heffalump> that's great, but for things that are naturally 4 bytes, still quite sad
13:43:58 <Olathe> Well, yes :)
13:44:24 <guenni> mmorrow: about that function from wxhaskell, the one with the paths ...
13:44:46 <Heffalump> IM 8 bytes, of course.
13:45:08 <Heffalump> Is there any particular difficulty with getting down to 8 bytes?
13:45:22 <mmorrow> guenni: ?
13:45:44 <Olathe> If we could assume the float exponent was small enough, sure.
13:45:52 <mmorrow> i don't see why the ieee encoding isn't portable
13:45:53 <guenni> mmorrow: IT'S NOT BLOODY WOKRING EITHER!!!!!
13:45:59 <mmorrow> guenni: heh
13:46:02 <guenni> mmorrow: aaaaaaaaaaahhhh
13:46:16 <guenni> mmorrow: I'm screwed
13:46:36 <mmorrow> you need a "do-what-i-want" button
13:46:45 <mmorrow> maybe wxhaskell has a widget for that?
13:46:54 <mmorrow> ;)
13:46:56 <Olathe> Right now, Binary puts out 8 bytes for the exponent, which is quite large.
13:46:56 <guenni> dunno
13:47:38 <dancor> it does but the widget doesn't work the way you would expect it to
13:48:02 <Olathe> > isNegativeZero
13:48:03 <pumpkinbot>       Overlapping instances for Show (a -> Bool)
13:48:03 <pumpkinbot>        arising from a use of...
13:48:03 <Heffalump> hmm, the annoyance is that Double isn't guaranteed to be any fixed size, just that it should be at least IEEE double.
13:48:15 <mmorrow> hmm
13:48:33 <Olathe> > dropWhile (not.isNegativeZero) . iterate (/2) $ -1
13:48:34 <pumpkinbot>   [-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0,-0.0...
13:48:50 <Olathe> > decodeFloat . head . dropWhile (not.isNegativeZero) . iterate (/2) $ -1
13:48:51 <mmorrow> well 1 + sizeof(double) bytes then
13:48:51 <pumpkinbot>   (0,0)
13:48:53 <insane> i've got a higher order function foo which takes as a parameter a predicate of type (a -> Bool). Then i'm making the inner function using where and try to use that predicate in it. while trying to execute my program haskell interpreter complains that types a and a1 doesn't match. how to express that those types are isomorphic?
13:49:01 <Olathe> > decodeFloat 0
13:49:02 <pumpkinbot>   (0,0)
13:49:11 <Olathe> Bah, even that's not portable.
13:49:11 <mmorrow> where the first byte encodes whatever info is needed
13:49:20 <Heffalump> mmorrow: what's sizeof(double)?
13:49:23 <mmorrow> what is "portable" here
13:49:39 <Olathe> Portable means that it gets the exact value over to the other side.
13:49:40 <dancor> is MyData A B generally kwlr than MyData (A, B)
13:49:45 <mmorrow> Heffalump: specified in the first byte
13:49:48 <Heffalump> of course the writer could just error out if the value is outside IEEE double
13:49:52 <Heffalump> mmorrow: no, I mean how do you work it out
13:49:53 <mmorrow> yeah
13:50:10 <mmorrow> Heffalump: you read the info in the first byte, then act accordingly
13:50:17 <rwbarton> insane: did you write a type signature for the "inner" function?
13:50:23 <Heffalump> mmorrow: not when reading, when writing
13:50:31 <Heffalump> how do I know what sizeof(double) is on a given platform
13:50:41 <insane> rwbarton: yes
13:50:45 <Olathe> Oh yeah, I forgot. The code I put allows unbounded Integers now.
13:50:47 <mmorrow> Heffalump: you'd encode the size of the doubles you're writing in the first byte
13:50:54 <mmorrow> (or something)
13:50:54 <rwbarton> insane: either delete it, and it will be inferred automatically
13:50:59 <Heffalump> mmorrow: yes, but what *IS* that size?
13:51:08 <insane> rwbarton: yes but that's not the solution right? ;]
13:51:10 <mmorrow> Heffalump: whatever it is on your machine
13:51:13 <dancor> Heffalump: how does Data.Binary do it, or use Data.Binary to do it heh
13:51:17 <mmorrow> whatever you want it to be really
13:51:20 <Heffalump> and how do I know what it is on my machine???
13:51:34 <mmorrow> check?
13:51:39 <rwbarton> insane: or turn on -XScopedTypeVariables, and add "forall a1 a2 ... an." to your outer type signature, where a1 ... an are the free variables in its type
13:51:43 * Heffalump substitutes a brick wall for mmorrow as there seems to be no observable difference :-)
13:51:46 <Heffalump> check how? :-)
13:51:46 <rwbarton> insane: The first is the Haskell 98 solution.
13:51:57 <Olathe> printf("It's %d !\n", sizeof((double) 0.0));
13:52:11 <Heffalump> that's what it is in the C compiler on my machine...
13:52:20 <Heffalump> what is it in the Haskell compiler on my machine?
13:52:35 <int-e> why would it be different?
13:52:42 <dancor> isn't it a property of the processor
13:52:43 <mmorrow> Heffalump: echo -ne '#include <stdio.h>\nmain(){printf("%d\n",sizeof(double));}\n' > 0.c; gcc 0.c; ./a.out
13:52:48 <Heffalump> because we're trying to be portable, not make random assumptions!
13:53:00 <Heffalump> if we're making random assumptions, IEEE double size (i.e. 8 bytes) is the answer.
13:53:02 <mmorrow> sizeOf(undefined::Double)
13:53:07 <ziman> @bot
13:53:07 <pumpkinbot> :)
13:53:07 <lunabot>  :)
13:53:16 <Heffalump> is sizeOf a real function?
13:53:20 <mmorrow> i'm just not understanding what the issue here is
13:53:25 <Olathe> Heffalump: It should be.
13:53:32 <rwbarton> @hoogle sizeof
13:53:32 <pumpkinbot> Foreign.Storable sizeOf :: Storable a => a -> Int
13:53:32 <pumpkinbot> System.Posix.Internals sizeof_stat :: Int
13:53:35 <mmorrow> oh, yeah i meant 8 bytes earlier
13:53:41 <mmorrow> (not 4)
13:53:42 <mmorrow> oops
13:53:44 <int-e>         -- Defined in Foreign.Storable
13:53:45 <Olathe> Heffalump: http://en.wikipedia.org/wiki/Sizeof
13:53:50 <dancor> > sizeOf (0 :: Double)
13:53:51 <pumpkinbot>   mueval: Prelude.read: no parse
13:53:58 <Heffalump> right, thank you.
13:54:10 <Olathe> It's C, not Haskell.
13:54:23 <Heffalump> Foreign.Storable is a good answer to my question.
13:54:32 <yitz> > maxBound :: Double
13:54:33 <pumpkinbot>       No instance for (Bounded Double)
13:54:33 <pumpkinbot>        arising from a use of `maxBound...
13:54:40 <rwbarton> But I think Foreign.Storable.sizeOf has more to do with the size of doubles in your C compiler.
13:54:52 <TuringTest> I just update http://www.haskell.org/haskellwiki/Regex_Posix with Solaris 10 results from Christian Maeder, and Solaris 10 has a critical bug in "regex.h" matching.
13:55:05 <TuringTest> The details are on the wiki page
13:55:10 <Heffalump> I hope that if double in my C compiler and Double in my Haskell compiler didn't match up (which is actually highly unlikely), then it'd follow the latter.
13:55:14 <yitz> TuringTest: sounds like par for the course
13:55:23 <mmorrow> ok, so i don't get why doubles need be more than 8 bytes for portability's sake
13:55:40 <mmorrow> (they're currently 25)
13:55:40 <Olathe> @type decodeFloat
13:55:41 <pumpkinbot> forall a. (RealFloat a) => a -> (Integer, Int)
13:55:43 <TuringTest> yitz: Not really.  Bugs yes, but this is a failure to find the longest match which is more critical
13:55:47 <Heffalump> because the Haskell standard doesn't say they are limited to 8 bytes
13:55:53 <mmorrow> ohhhh. ok.
13:55:56 <Olathe> I think for RealFloats that are better than Double.
13:55:57 <int-e> Heffalump: it probably would follow the C compiler. Which is ok - the size of doubles on the Haskell size is not really observable.
13:56:01 <Heffalump> I think erroring out if they aren't so limited is fine, though.
13:56:18 <Heffalump> int-e: it is observable, that's what Foreign.Storable does.
13:56:22 <int-e> Heffalump: the size becomes observable when you use FFI. and that's where Storable comes in
13:56:25 <Heffalump> And that's a very good way of making the observation.
13:56:31 <Olathe> You could get it down to 9 bytes if you had a length byte.
13:56:33 <Heffalump> well, FFI is part of the standard.
13:57:11 <andun> is it possible to get the last element in a *very* long list and let the GC collect earlier elements?
13:57:21 <yitz> TuringTest: it would be interesting to run the tests against other regex libs, besides the native C lib and Chris' libs. Like perl, python, java, etc.
13:57:24 <koeien> > last [1..1000000]
13:57:25 <pumpkinbot>   1000000
13:57:32 <mmorrow> well, but even then, i don't see a need for more than 1+sizeof(double) (as determined by the writer) bytes for a double then. 1 byte for the number of bytes to follow, and n bytes for the double encoded as per the ieee
13:57:33 <andun> koeien: that's not long at all
13:57:45 <int-e> andun: only if you let go of the head of the list.
13:57:47 <koeien> > last (replicate 1000 1 ++ [undefined] ++ replicate 10000000 20)
13:57:47 <Heffalump> mmorrow: yes, agreed.
13:57:49 <pumpkinbot>   20
13:57:51 <TuringTest> yitz: Perl regular expressions (and libpcre) are very different from Posix extended regular expressions.
13:57:54 <koeien> > last (replicate 1000 1 ++ [undefined] ++ replicate 1000000000 20)
13:58:00 <pumpkinbot>   mueval: Prelude.read: no parse
13:58:05 <koeien> it's O(N)
13:58:28 <yitz> TuringTest: hmm, true. the tests would need to be adapted. still, it would be interesting.
13:59:29 <TuringTest> yitz: The Perl matching semantics are left-biased which is much easier to program with backtracking.  And Perl has a gigantic test regression test suite, and Perl really cares about regular expressions. So I assume without further study that Perl is right.
14:00:09 <rwbarton> > [ (x, uncurry encodeFloat . decodeFloat $ x) | x <- [0/0, -0.0] ]
14:00:10 <abbe> hi everyone
14:00:11 <pumpkinbot>   [(NaN,-Infinity),(-0.0,0.0)]
14:00:12 <abbe> I'm facing a problem with a haskell code I've written.
14:00:16 <abbe> It is throwing an exception, and I'm unable to figure out where it is.
14:00:52 <yitz> TuringTest: you can actually adjust the bias. but yeah, perl would be in trouble with broken regexps. but I still say - it would be interesting.
14:01:23 <yitz> abbe: what's the exception?
14:01:50 <andun> int-e: which means never using the reference again, right?
14:01:54 <ozy`> abbe: it's on line 404
14:02:14 <abbe> yitz, *** Exception: Prelude.head: empty list
14:02:19 <ozy`> abbe: seriously, though, show us the code and the exception and we'll have a look ;)
14:02:20 <ozy`> ah
14:02:31 <ozy`> abbe: rule of thumb. don't use head.
14:02:33 <abbe> oh, sure wait a minute, ozy`
14:02:35 <int-e> andun: pretty much, yes.
14:02:59 <ozy`> abbe: instead, pattern match on (x:xs) and []
14:03:04 <ozy`> abbe: and handle the latter manually
14:03:18 <yitz> > head . dropWhile (not . isInfinity) . map (10^) $ [1..] :: Double
14:03:19 <pumpkinbot>   mueval: Prelude.read: no parse
14:03:49 <CyberGarp> Is it possible to have an infinite list in the IO Monad? I.e. brownianStep :: RNG -> Double -> IO [Double]
14:03:51 <yitz> > (head . dropWhile (not . isInfinity) . map (10^) $ [1..]) :: Double
14:03:52 <pumpkinbot>   mueval: Prelude.read: no parse
14:03:53 <TuringTest> abbe: Or write a version of head that takes a custom error string, and use that with a custom string message at each site where head is currently used.
14:04:06 <TuringTest> abbe: Or use ghci and the new shiny breakpoints to get an idea where it goes wrong.
14:04:33 <ozy`> by the way you guys, I'm looking at Fortress and I like what I see so far
14:05:14 <TuringTest> abbe: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
14:05:33 <yitz> CyberGarp: yes, but you probably wouldn't do that in IO
14:05:45 <CyberGarp> IO tries to realize it.
14:05:51 <CyberGarp> Problem is the gsl-random is all in IO.
14:05:53 <yitz> realize?
14:06:00 <int-e> andun: what is that long list? maybe you can turn it into a pair of its length and a function that computes its i-th element?
14:06:07 <CyberGarp> Goes from lazy to evaling the whole thing.
14:06:09 <yitz> CyberGarp: ah you're using an external rng?
14:06:12 <CyberGarp> stack overflow.
14:06:25 <CyberGarp> Yeah, it's got all the other crazy distributions I need.
14:06:50 * abbe has pasted his code at http://paste.lisp.org/display/74739
14:07:02 <CyberGarp> I guess another way to ask the question is can one have a lazy infinite list in the IO Monad?
14:07:14 <CyberGarp> lazy being the key workd
14:07:19 <rwbarton> CyberGarp: You can't have an IO action that has an infinite list and needs to perform some effects before producing each element.
14:07:25 <rwbarton> s/has/returns
14:07:35 <yitz> CyberGarp: so is that function a haskell function, or the ffi thing that access your rng?
14:07:40 <CyberGarp> rwbarton, that's what I feared.
14:07:47 <rwbarton> CyberGarp: Because it performs them all before returning a value due to the semantics of IO.
14:07:52 <CyberGarp> ffi, that accesses the gsl
14:07:59 <int-e> CyberGarp: using unsafeInterleaveIO, like getContents - yes, you can produce an infinite list that way.
14:08:00 <abbe> ozy`, http://paste.lisp.org/display/74739
14:08:14 <Badger> @src unsafeInterleaveIO
14:08:14 <pumpkinbot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
14:08:32 <TuringTest> abbe: One of the B.ByteString is empty and causing head to fail
14:08:32 <int-e> CyberGarp: you probably shouldn't do it, but that's a different question.
14:08:33 <CyberGarp> so I'm feeling like unsafe computing I could get away with it.
14:08:42 <CyberGarp> Doesn't sound, well, uh, safe.
14:09:07 <abbe> TuringTest, yeah, but where ? is it possible to get a stack trace at the location of exception in ghci
14:09:12 <yitz> CyberGarp: it isn't safe, but this very well may be one of those rare instances where you should indeed use it
14:09:22 <CyberGarp> hmmm.
14:09:23 <TuringTest> abbe: Yes (kind of) use the ghci debugger
14:09:44 <andun> int-e: it's all the individials in all generations in my evolutionary AI system, so i don't necessarily know which i want
14:09:57 <lamby> I have a [Char] containing a representation of an unsigned integer (eg. "\x01\x01" represents 513) - are there nicer ways of parsing that to an Int without excessive use of ord and bit-twiddling?
14:09:59 <CyberGarp> I'll give it a spin in unsafe, but consider it an experiment.
14:10:28 <TuringTest> abbe: but a better fix is the write your code not to fail on empty input.  Change the code to check for empty input and either do the right thing or print a good error.
14:10:30 <andun> int-e: i have a function returning an infinite list, and maybe i'll save some generations here and there, or just take the last one, or whatever
14:11:07 <yitz> CyberGarp: you need to think about whether the rng satisfies the conditions that would make this usage of unsafeInterleaveIO safe.
14:11:22 <CyberGarp> yitz, that's what I'm reading now.
14:11:26 <yitz> ok
14:11:45 <yitz> lamby: read
14:11:52 <yitz> oh wait
14:12:01 <rwbarton> abbe: e.g. rewrite parseBDictionary' as parseBDictionary' xs ('e':rest) = (xs, rest); parseBDictionary' xs string = ...
14:12:06 <yitz> why does that rep. 513?
14:12:18 <int-e> andun: if you can just filter the list, keeping a limited number of the generations, that could be fine. but I think you'll have to look at each element and decide whether to discard or keep it, before looking further.
14:12:27 <rwbarton> abbe: oh, I see you have bytestrings involved... hmm
14:13:16 <abbe> TuringTest, okay. Thanks for the debugger link
14:14:24 * TuringTest waves goodbye
14:14:47 <rwbarton> andun: if your infinite list looks like  iterate evolve initialState,  then (assuming evolve is strict) you might cause a stack overflow by trying to evaluate the nth element of the list for large n.
14:15:24 <andun> rwbarton: i just started thinking about the same. trying to make this strict right now :)
14:17:53 <andun> is there some general trick to force the evaluation of a list? foldr seq?
14:18:43 <litb> oh wait, this channel has grown since i last visited it by 100 ppl i think
14:18:44 <rwbarton> @src iterate
14:18:44 <pumpkinbot> iterate f x =  x : iterate f (f x)
14:18:56 <hasMeta> urgh -> Could not find module `System.FilePath': on debian
14:19:01 <Heffalump> andun: that should work, though you might as well just use the RNF class to save effort.
14:19:18 <_Jordan_> litb: You're one of my stack overflow heroes
14:19:22 <andun> rwbarton: this is in a monad
14:19:59 <abbe> hasMeta, I think that is System.IO.FilePath
14:20:20 <hasMeta> abbe: it's compiling fine on ubuntu
14:20:44 <litb> _Jordan_: haha, great :p and now you be my haskell hero k?
14:20:50 <abbe> hasMeta, oh, okay.
14:20:53 <FunctorSalad> "foldlr seq" scares me
14:20:59 <FunctorSalad> *foldr
14:21:10 <abbe> hasMeta, oops, that exists on my box too ;)
14:21:27 <_Jordan_> litb: I'm far from heroic in a lot of things, but especially haskell :P
14:21:30 <abbe> hasMeta, dpkg -L <haskell-package>
14:22:17 <int-e> > last $ foldr (\a as -> a `seq` a:as) [] $ take 1000000 (iterate succ 0)
14:22:17 <rwbarton> hasMeta: dpkg -L ghc6 | grep FilePath  shows it for me.
14:22:19 <pumpkinbot>   999999
14:22:29 <litb> k, then im dropping down too :)
14:22:41 <hasMeta> hmm
14:22:41 <andun> OK. i'm pretty sure everything is strict now, and the problem is still here, so i'll search for something else. thanks, guys :)
14:22:44 <hasMeta> dpkg -L ghc6 | grep FilePath
14:22:46 <hasMeta> eh sorry
14:22:51 <int-e> > last $ take 1000000 (iterate succ 0)
14:22:53 <pumpkinbot>   mueval: Prelude.read: no parse
14:22:53 <pumpkinbot>  mueval: *** Exception: stack overflow
14:23:02 <hasMeta> -> /usr/lib/ghc-6.6/imports/Distribution/Compat/FilePath.hi
14:23:15 <rwbarton> Ah you're in an ancient age :)
14:23:22 <FunctorSalad> is there some safe replacement for seq?
14:23:40 <Saizan> safe?
14:23:47 <yitz> FunctorSalad: yes, keep it lazy
14:23:48 <FunctorSalad> ("safe" as in "don't have to think about evaluation order", though maybe that's a contradiction in itself)
14:24:09 <Cheshire> > case undefined of () -> ()
14:24:11 <pumpkinbot>   mueval: Prelude.read: no parse
14:24:11 <pumpkinbot>  mueval: *** Exception: Prelude.undefined
14:24:13 <Cheshire> > case () of () -> ()
14:24:15 <pumpkinbot>   ()
14:24:38 <Gracenotes> is there a right foldM? Or will I have to reverse the list first?
14:24:45 <glguy> reverse
14:24:47 <Cheshire> FunctorSalad, I suppose you could implement Normalize typeclass
14:24:48 <int-e> FunctorSalad: you have to think about the evaluation order, I think. you can only make one value at least as strict as one other - force evaluation with respect to another - and that's what seq does.
14:24:54 <hasMeta> hmm, why does apt-get ghc6 does not include System.FilePath?
14:24:56 <Gracenotes> hrm, all right
14:25:00 <int-e> @index rnf
14:25:00 <pumpkinbot> Control.Parallel.Strategies
14:25:06 <ziman> :t foldr seq
14:25:07 <pumpkinbot> forall a b. b -> [a] -> b
14:25:12 <int-e> FunctorSalad: ok, you may want rnf and friends.
14:25:27 <hasMeta> oh, it's a hugs lib
14:25:42 <Saizan> hasMeta: libghc6-filepath-dev ?
14:25:54 <FunctorSalad> hmmm
14:26:06 <int-e> hasMeta: presumably because it's an extra lib, not a core lib
14:26:20 <FunctorSalad> Cheshire: different from NFData?
14:26:22 <int-e> hmm or not
14:26:47 <int-e> hasMeta: dunno. ask the debian packager :)
14:27:02 <rwbarton> libghc6-filepath-dev is separate in debian stable, merged into ghc6 as of debian testing
14:27:14 <hasMeta> confusing, on my ubuntu box there's no such package
14:27:33 <hasMeta> ok
14:27:37 <rwbarton> That's probably because your ubuntu box isn't running a 3 year old version of ubuntu
14:27:46 <rwbarton> (or so)
14:27:53 <hasMeta> really? actually it's running 8.10 :D
14:28:01 <Saizan> ghc-pkg list filepath ?
14:28:09 <FunctorSalad> but I really don't think my question made much sense ;)
14:28:19 <rwbarton> hasMeta: There's no libghc6-filepath-dev in debian testing either.
14:28:50 <FunctorSalad> (modifying the evaluation order can't be "inside" the normal haskell semantics)
14:29:23 <lispy> Cale: sorry my server was down.  It's is safe to run lambdabot from there again :)
14:29:36 <yitz> lispy: yay!
14:29:56 <yitz> preflex: seen Cale
14:29:56 <preflex>  Cale was last seen on #haskell 2 hours, 33 minutes and 11 seconds ago, saying: mmorrow: Are you words'ing the input somewhere?
14:30:31 <Gracenotes> @hoogle a -> [a]
14:30:31 <pumpkinbot> Prelude repeat :: a -> [a]
14:30:31 <pumpkinbot> Data.List repeat :: a -> [a]
14:30:31 <pumpkinbot> Prelude iterate :: (a -> a) -> a -> [a]
14:30:39 <lispy> preflex: tell Cale Sorry about the unexpected down time.  It is safe to start the lambdabot process again.  Thanks!
14:30:40 <preflex>  Consider it noted.
14:32:00 * ray will miss bumpkinbot
14:32:54 <islon_s> is there a function to check if a string starts with a substring?
14:32:56 <yitz> @vixen we're going to miss you
14:32:56 <pumpkinbot> Whatever
14:33:10 <loadquo> @type isPrefixOf
14:33:11 <pumpkinbot> forall a. (Eq a) => [a] -> [a] -> Bool
14:33:19 <islon_s> thanks!
14:33:37 <yitz> @hoogle isPrefixOf
14:33:37 <pumpkinbot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
14:33:37 <pumpkinbot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
14:33:37 <pumpkinbot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
14:34:15 <zloog> I just started moving from using ghci for everything into trying to produce compiled code. Do most people just use gnu make for the build chain or is there another standard?
14:34:18 <islon_s> i was looking for "startsWith", damn java
14:34:34 <Heffalump> zloog: there's gnu make, ghc --make, or cabal
14:34:38 <tromp__> > log 0.9
14:34:39 <pumpkinbot>   -0.10536051565782628
14:34:40 <Heffalump> those are the three most popular choices, anyway
14:35:01 <zloog> Heffalump: Ahh thanks, I didnt know ghc had a make
14:35:01 <tromp__> > log 0.00001 / log 0.9
14:35:03 <pumpkinbot>   109.27172663391418
14:35:08 <zloog> Heffalump: I'll go look that up
14:35:09 <Heffalump> cabal is good for distributing stuff, but poor for incremental rebuilds
14:35:33 <Heffalump> ghc --make is nice and simple, but does a little extra work on each rebuild and doesn't integrate well with non-Haskell stuff
14:35:52 <Heffalump> gnu make is more pain to maintain (though ghc -M helps a lot) but most flexible and best at incremental stuff
14:36:04 <ozy`> zloog: the neat thing about ghc --make is that it detects library dependencies. naturally, this doesn't translate to non-haskell stuff
14:36:10 <loadquo> islon_s a good way of finding functions is to use hoogle. E.g.
14:36:30 <loadquo> @hoogle [a] -> [a] -> Bool
14:36:30 <pumpkinbot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
14:36:30 <pumpkinbot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
14:36:30 <pumpkinbot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
14:36:44 <islon_s> loadquo, yeah, but i was searching for "startsWith"
14:36:54 <loadquo> Use the type signature :P
14:37:00 <zloog> ozy`: Yea, I just did my first manual haskell build and while it did make the code a ton faster than ghci, I never want to do that by hand again
14:37:09 <islon_s> i'll remember
14:37:42 <ozy`> zloog: so long as you're working only with haskell source files, ghc --make should be all you need :p
14:37:57 <yitz> zloog: if you're just starting out, use ghc --make
14:37:58 <Heffalump> ghc --make interacts really badly with a preprocessor
14:38:05 <Heffalump> an external preprocessor, that is
14:38:19 <Heffalump> cos it preprocesses everything on each run
14:40:10 <islon_s> can't i do "ln | "add " `isPrefixOf` ln ->" in a case of expression?
14:40:43 <rwbarton> Yes...
14:40:44 <int-e> islon_s: you can.
14:41:00 <mopped> > (\x y -> [(i, j) | i <- [(x-1) .. (x+1)], j <- [(y-1) .. (y+1), i >= 0, j >= 0]) 2 2
14:41:01 <pumpkinbot>   mueval: Prelude.read: no parse
14:41:22 <mopped> > (\x y -> [(i, j) | i <- [(x-1) .. (x+1)], j <- [(y-1) .. (y+1)], i >= 0, j >= 0]) 2 2
14:41:24 <pumpkinbot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:42:00 <int-e> > let foo a | "abc" `isPrefixOf` a = Nothing | otherwise = Just a in (foo "abcdef", foo "xyz")
14:42:01 <pumpkinbot>   (Nothing,Just "xyz")
14:42:12 <mopped> How do I exclude things such as, (1, 1) (3, 3) etc ie, value that increment/decrease i AND j? I only want values that have increased/decreased one or the other
14:42:42 <Cheshire> mopped, add i /= j
14:43:03 <redditbot> Parallel Rewrite System : Luke Palmer
14:43:04 <hasMeta> where's "Data.List" especially stripprefix hiding?
14:43:19 <mopped> but what if x and y have different initial values
14:43:38 <yitz> > case "abcdef" of {x | "abc" isPrefixOf x -> "yes"; _ -> "no"}
14:43:39 <pumpkinbot>   Couldn't match expected type `t -> t1 -> Bool'
14:44:18 <opqdonut> > (\x y -> [(x+dx,y+dy) | dx<-[-1..1], dy<-[-1..1], dx /= dy]) 10 2
14:44:19 <pumpkinbot>   [(9,2),(9,3),(10,1),(10,3),(11,1),(11,2)]
14:44:23 <opqdonut> mopped: see that
14:44:26 <int-e> yitz: where'd the `` go?
14:44:29 <yitz> > case "abcdef" of {x | "abc" `isPrefixOf` x -> "yes"; _ -> "no"}
14:44:31 <pumpkinbot>   "yes"
14:44:44 <yitz> int-e: oops
14:45:16 <opqdonut> mopped: or maybe you really wanted abs i /= abs j
14:45:27 <mopped> aha
14:48:11 <pao> I've been suggested by ghc to use -fvia-C because of a FunPtr ... it surely knows better than me... but ... should I avoid it by trying to implement the deallocator in haskell?
14:48:23 <yitz> > let dropLike (_:xs) (_:ys) = dropLike xs ys; dropLike _ ys = ys in dropLike "xyz" "abcdef"
14:48:24 <pumpkinbot>   "def"
14:51:13 <enoksrd> @pl \x y -> (length x) < (length y)
14:51:13 <pumpkinbot> (. length) . (<) . length
14:51:46 <yitz> > ((<) on length) "ab" "cde"
14:51:47 <pumpkinbot>   Couldn't match expected type `b -> b -> c'
14:51:53 <yitz> > ((<) `on` length) "ab" "cde"
14:51:54 <pumpkinbot>   True
14:52:05 <enoksrd> yitz: thanks!
14:52:05 <yitz> my backtick key finger is stuck today
14:53:08 <ozy`> @src on
14:53:08 <pumpkinbot> (*) `on` f = \x y -> f x * f y
14:53:35 <yitz> @where on
14:53:35 <pumpkinbot> I know nothing about on.
14:53:46 <yitz> well, it's in Data.Function
14:53:48 <hasMeta> -> where's "Data.List" especially stripprefix hiding?
14:54:13 <yitz> hasMeta: see my "dropLike" above
14:54:24 * Cheshire just read about a purely functional OS based on type theory
14:54:42 <whoppix> Cheshire, URL?
14:54:49 <Cheshire> http://lukepalmer.wordpress.com/2009/01/24/the-third-virtue/
14:54:57 <enoksrd> yitz: found it with hoogle
14:55:07 <Cheshire> whoppix, (of course it doesn't actually exist..)
14:55:11 <yitz> enoksrd: good idea
14:55:24 <yitz> @hoogle on
14:55:24 <pumpkinbot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:55:24 <pumpkinbot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
14:55:24 <pumpkinbot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:55:24 <whoppix> Cheshire, interesting, though.
14:56:21 <yitz> ping Cale
14:56:27 <hasMeta> yitz: I don't understand
14:56:31 <hasMeta> ah ok
14:56:32 <hasMeta> sorry
14:56:45 * loadquo wants a strongly typed shell
14:56:45 <rwbarton> hasMeta: for i in array base bytestring cabal containers directory filepath haskell98 hpc old-locale old-time packedstring pretty process random readline rts template-haskell unix; do sudo apt-get install libghc6-$i-dev; done
14:56:57 <ddarius> loadquo: Use Powershell.
14:56:59 <enoksrd> does haskell have a sort function that uses a key function instead of a comparator (like sortBy)?
14:57:19 <rwbarton> (those are the packages that ghc6 provides in debian testing)
14:57:30 <ddarius> :t sortBy . comparing
14:57:31 <pumpkinbot> forall b a. (Ord a) => (b -> a) -> [b] -> [b]
14:57:43 <islon_s> how i delete an element from a list by the index?
14:58:05 <yitz> @type splitAt
14:58:07 <pumpkinbot> forall a. Int -> [a] -> ([a], [a])
14:58:15 <hasMeta> rwbarton: already got these packages
14:58:23 <ddarius> islon_s: You make a new list without the element.  There is no standard function to do this as it is not something you want to do much.
14:58:30 <hasMeta> rwbarton: all of them
14:59:27 <loadquo> ddarius: Microsoft haven't released it for linux yet ;).
14:59:49 <islon_s> ddarius, yeah i want a function that returns a new list without the element index i
15:00:16 <ddarius> loadquo: Do you know what the code name for Powershell was?
15:00:38 * monochrom knows. :)
15:01:06 <loadquo> Monad, yup :) I hadn't heard of it since it was stopped being called that.
15:01:38 <Badger> hah!
15:01:48 * loadquo serendipitously found this http://nellardo.com/lang/haskell/hash/ while looking for the best way to do hashes in haskell
15:01:50 <yitz> > let dropIndex i xs = (let (h, _:t) = splitAt i xs in h ++ t) in dropIndex 3 [2,4..10]
15:01:52 <pumpkinbot>   [2,4,6,10]
15:02:10 <tromp__> why do you want to delete at a particular index??
15:02:19 <tromp__> can't you use \\ ?
15:02:24 <tromp__> :t (\\)
15:02:25 <pumpkinbot> forall a. (Eq a) => [a] -> [a] -> [a]
15:02:43 <islon_s> because its a list of todos and the user want to remove the item i
15:03:06 <yitz> loadquo: generally the best way to do hashes in haskell is don't
15:03:10 <tromp__> but does the user specify the item or iits index?
15:03:25 <islon_s> the user specifies the number
15:03:54 <paczesiowa> > uncurry (++) $ (splitAt 4 >>> second tail) [1..10]
15:03:55 <pumpkinbot>   mueval: Prelude.read: no parse
15:04:17 <rwbarton> :t uncurry (++) $ (splitAt 4 >>> second tail) [1..10]
15:04:19 <pumpkinbot> forall a. (Enum a, Num a) => [a]
15:04:25 <paczesiowa> > 2+2
15:04:26 <pumpkinbot>   4
15:04:31 <rwbarton> , uncurry (++) $ (splitAt 4 >>> second tail) [1..10]
15:04:32 <lunabot>  luna: Not in scope: `>>>'
15:04:38 <Olathe> @src concat
15:04:38 <pumpkinbot> concat = foldr (++) []
15:05:18 <loadquo> The link I posted was to someone doing a haskell shell. About hashes, well I had thought that Data.Maps were the way to get that functionality... I need O(1) in membership tests.
15:05:57 <loadquo> Doing in 1999, unfortunately.
15:06:14 <paczesiowa> what happend to lambdabot?
15:06:43 <yitz> paczesiowa: lispy's machine was down for a while. back up now, we're waiting for Cale to appear and restart \bot
15:06:57 <Cale> yitz: oh, thanks for the notice :)
15:06:57 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
15:07:35 <paczesiowa> > uncurry (++) $ (splitAt 4 >>> second tail) [1..10]
15:07:36 <pumpkinbot>   mueval: Prelude.read: no parse
15:08:02 <Badger> @bot
15:08:02 <pumpkinbot> :)
15:08:02 <lunabot>  :)
15:08:06 <Cale> oops, part of the state is broken, one moment
15:08:10 <paczesiowa> pumpkinbot can't even read?
15:08:31 <yitz> ping pumpkin
15:08:40 <yitz> preflex seen pumpkin
15:08:41 <preflex>  pumpkin was last seen on #haskell 1 hour, 38 minutes and 12 seconds ago, saying: my bot doesn't know me
15:08:54 <monochrom> hash table operations are O(log n) on modern netbooks.
15:09:31 <Cale> > 2^100
15:09:32 <pumpkinbot>   1267650600228229401496703205376
15:09:37 <lambdabot>   1267650600228229401496703205376
15:09:48 <evv> > 2^101
15:09:49 <pumpkinbot>   2535301200456458802993406410752
15:09:50 <yitz> @botsnack
15:09:51 <pumpkinbot> :)
15:09:51 <lunabot>  :)
15:09:53 <lambdabot>   2535301200456458802993406410752
15:09:55 <lambdabot> :)
15:10:12 <paczesiowa> is it possible to timeout a computation from a stack of monads without turning it upside down to make IO top monad?
15:10:38 <Cale> upside down?
15:10:44 <evv> can someone figure out how to get the bot to respond to a command in such a way as that it's respone will be to give a command to the other bot, and so on recursively? :)
15:11:04 <yitz> evv: we try to make sure that's not possible
15:11:09 <SamB_irssi> evv: that's an old favorite activity here ;-)
15:11:27 <loadquo> Some form of quine then...
15:11:36 <paczesiowa> Cale: I have ErrorT . WriterT . IO, and I don't know how to timeout (or even fork) it
15:11:38 <monochrom> The output syntaxes of the bots are designed to forbid it.
15:11:43 <int-e> @quote state
15:11:43 <pumpkinbot> state says: ?. ++ . read . show . state ?. ++ . read . show . state
15:11:44 <SamB_irssi> a slightly-less-old tradition is the tradition of quickly plugging the holes that allowed it ;-)
15:11:51 <lambdabot> state says: ?. ++ . read . show . state ?. ++ . read . show . state
15:11:53 <enoksrd> ddarius: your (sortBy . comparing) does what I want, thanks, but may cause a bunch of unnecessary applications of the key function, yeah?  Doesn't matter most of the time though.
15:11:58 <Cale> For the most part, lambdabot tries to prefix responses with one or more spaces, and not respond to things which are prefixed with spaces, but I wouldn't bet on it being impossible :)
15:12:06 <evv> monochrom: where can i find the proof?
15:12:12 <yitz> evv: one layer of protection is that every bot always prefixes every response with a space, and ignores messages that start with a space
15:12:17 <monochrom> source code
15:12:21 <SamB_irssi> evv: there is no PROOF
15:12:34 <SamB_irssi> if there was a proof, it wouldn't be an old favorite activity ;-)
15:12:41 <mopped> I'm having trouble solving this problem functionally, I have a 2d-array symbolising a maze, and I want to write a program that 'solves' the maze. I've got a function that grabs valid adjacent cells from x, y coordinates, and another function that states wether a given cell is a junction. The plan is to convert all of these junctions into nodes, connect connected junctions and use djikstra.. the problem is.. how would I find out what junctions are ...
15:12:42 <Spark> funny how nobody bothers with notices
15:12:47 <mopped> ... connected? How can I journey the map? :)
15:12:50 <mopped> map = maze
15:12:52 <Spark> mainly because irc clients never really 'got' notices
15:12:52 <SamB_irssi> Spark: it was tried
15:12:56 <Cale> Spark: Too many IRC clients mismanage them.
15:13:00 <Spark> and made them irritating
15:13:11 <SamB_irssi> yeah, that's the experiment failed :-(
15:13:15 <SamB_irssi> +why
15:13:23 <ehird> <evv> can someone figure out how to get the bot to respond to a command in such a way as that it's respone will be to give a command to the other bot, and so on recursively? :)
15:13:25 <monochrom> It there were no proof, it would not be an old favourite activity, it would still be a current favourite activity.
15:13:25 <ehird> "Botloops".
15:13:29 <monochrom> s/It/If/
15:13:31 <ehird> They're pretty easy, really.
15:13:45 <ehird> It's just an iterating quine. #esoteric gets them every month or so.
15:13:53 <ehird> It's kind of annoying if the bot owners are asleep and can't stop it, though.
15:13:59 <Cale> Notices should look the same as normal messages, but there seem to be some stupid clients which even go so far as to pop up a dialog box when they get a NOTICE.
15:14:00 <Spark> +b
15:14:01 <Spark> problem solved
15:14:21 <SamB_irssi> Cale: maybe not exactly the same
15:14:31 <SamB_irssi> maybe a slightly different color or something ...
15:14:35 <Cale> SamB_irssi: sure
15:14:44 <Spark> they should be inline with the rest of the chat
15:14:45 <monochrom> The users of those clients clearly love popups. Why avoid it.
15:14:50 <Spark> and they should not be intrusive
15:14:51 <Cale> hehe
15:14:56 <pao> @seen dons
15:14:56 <pumpkinbot> dons is in #haskell. I last heard dons speak 1h 44m 36s ago.
15:14:56 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
15:14:59 <ehird> Spark: It's kind of annoying if, additionally, there's only 1-2 ops that haven't fallen of the face of the earth, they almost never use their op power, and they're asleep :-)
15:15:00 <SamB_irssi> but it should not be inconcievable to switch their handling with that of PRIVMSGs
15:15:14 * Gracenotes added a section on freezing+thawing to wikibooks -- http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays#Freezing_and_thawing
15:15:15 <Cale> pumpkinbot: @part #haskell
15:15:35 <Gracenotes> based on the fun I had trying to figure it out myself :)
15:15:52 <pao> dons: do I disturb you?
15:17:23 <Olathe> @type replicateM
15:17:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:17:33 <SamB_irssi> @hpaste
15:17:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:17:42 <SamB_irssi> Cale: didn't you get my patch ???
15:17:43 <pao> @type sequence
15:17:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:17:49 <SamB_irssi> @hpaste2
15:17:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:18:05 <Cale> I did, I should recompile :)
15:18:09 <BONUS> i was just thinking today that the standard library could use more functions that end with M
15:18:21 <Gracenotes> untilM, ifM...
15:18:22 <yitz> enoksrd: true. if that is a problem, do a schwartzian.
15:18:56 <monochrom> unsafePerformIOM
15:18:57 <BONUS> especially in functions where the monad is the result of a predicate or higher order function
15:19:02 <BONUS> like dropWhileM
15:19:13 <monochrom> Hell, unsafePerformM
15:19:14 <SamB_irssi> monochrom: what would be the type of that ?
15:19:15 <BONUS> cause that can't be done with just combining it with sequence
15:19:18 <BONUS> haha
15:19:22 <SamB_irssi> the IO one
15:19:30 <Cheshire> is  m a -> a  an m-algebra?
15:19:34 <monochrom> IO a -> m a
15:19:58 <rwbarton> Cheshire: Yes
15:20:50 <BONUS> i wonder if there is such a function that will transform dropWhile into dropWhileM, filter into filterM, etc.
15:21:00 <BONUS> i assumenot
15:21:04 <Gracenotes> monochrom: unsafeDropIO, if m is a MonadIO
15:21:30 <paczesiowa> :i MonadIO
15:21:37 <monochrom> unsafeDoWantIMean
15:21:37 <paczesiowa> @info MonadIO
15:21:37 <lambdabot> MonadIO
15:21:47 <Gracenotes> @src MonadIO
15:21:47 <lambdabot> Source not found. My pet ferret can type better than you!
15:21:57 <Gracenotes> Wanna bet?
15:22:17 <monochrom> unsafeFireFox  {- "you have to think in Russian!" -}
15:22:17 <rwbarton> @vixen how well can your pet ferret type?
15:22:18 <lambdabot> however you want
15:22:38 <paczesiowa> MonadIO instances should have smth to thread them inside IO
15:22:41 <BONUS> oh man lambdabot is back
15:22:42 <BONUS> w00t
15:23:07 <monochrom>  @info is the new identity function :)
15:23:12 <Cale> mm... lambdabot now requires base 4 for some reason?
15:23:19 <Cale> I wonder what caused that.
15:23:37 <yitz> Cale: exceptions?
15:23:38 <Cale> Lispy's machine doesn't have a new enough GHC for that.
15:23:40 <SamB_irssi> Cale: it wasn't me!
15:23:45 <loadquo> @type mapM
15:23:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:23:54 <loadquo> @type map
15:23:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:23:56 <SamB_irssi> Cale: if it's exceptions, use the extensible-exceptions package instead
15:24:26 <ehird> <Axman6> @remember ehird 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop. <ehird> Someone re-remember that quote when lambdabot's back so I don't have to and thereby look egotistical, thanks
15:24:31 * ehird looks egotistical
15:24:32 <ehird> @remember ehird 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
15:24:32 <lambdabot> It is stored.
15:24:34 <Cale> oh, it's haskell-src-exts
15:24:49 <Gracenotes> @type sequence . iterate
15:24:50 <lambdabot>     Couldn't match expected type `[m a]'
15:24:50 <lambdabot>            against inferred type `a1 -> [a1]'
15:24:50 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
15:24:55 <Gracenotes> :X
15:24:55 <Cale> Oh well...
15:25:02 <litb> are you all archlinux fans? i think i recall that you haskell guys like archlinux?
15:25:11 <Cale> litb: dons is
15:25:22 <Gracenotes> @type \f x -> sequence (iterate f x)
15:25:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> m a) -> m a -> m [a]
15:25:26 <litb> ah right. he was that one
15:25:27 <loadquo> @type dropWhile
15:25:28 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:25:33 <SamB_irssi> Cale: what verion of that needs base4?
15:25:51 <Gracenotes> @type \f xs -> sequence (dropWhile f xs)
15:25:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> Bool) -> [m a] -> m [a]
15:26:02 <Cale> I use Ubuntu, I used to use Debian. There are a fair number of debian people.
15:26:03 <yitz> @type fixM
15:26:04 <Gracenotes> probably not what you're looking for, though...
15:26:04 <lambdabot> Not in scope: `fixM'
15:26:05 <Cale> cabal: cannot configure haskell-src-exts-0.4.8. It requires base >=4
15:26:06 <sjanssen> SamB_irssi: the current version, for one
15:26:14 <Gracenotes> @type iterateM
15:26:15 <lambdabot> Not in scope: `iterateM'
15:26:17 <yitz> @type mfix
15:26:17 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
15:26:29 <Gracenotes> @type scanM
15:26:30 <lambdabot> Not in scope: `scanM'
15:26:33 <Gracenotes> :\
15:26:36 <SamB_irssi> well, more to the point, why would cabal-install be picking that version when base4 isn't available ?
15:26:44 <SamB_irssi> also WHY ?
15:27:04 <Cale> haskell-src-exts>=0.4.8 is listed in the build-depends
15:27:10 <Cale> for whatever reason
15:27:21 <SamB_irssi> oh
15:27:26 <sjanssen> Mon Jan 19 13:05:51 CST 2009  gwern0@gmail.com * update haskell-src-exts usage & imports for GHC 6.10
15:27:34 <sjanssen> Cale: I bet you can just rollback that change
15:27:47 <sjanssen> gwern: also, perhaps you should check with Cale before making compatibility changes?
15:27:50 <abbe> I've fixed my issue, and it is problem with UTF-8 encoding which I'm using, whereas I'm supposed to use an ASCII like encoding.
15:27:50 <Cale> Or I could just wait for lispy to update.
15:28:01 <andun> rwbarton: i thik i found it. it was a space leak caused by a State thing hanging around
15:28:04 <abbe> Any ideas, how to improve this code, http://paste.lisp.org/display/74739#1
15:28:22 <Cale> @tell lispy Could we get GHC 6.10.1 on olive?
15:28:23 <lambdabot> Consider it noted.
15:28:58 <enoksrd> @pl (\x -> (length x, x))
15:28:58 <lambdabot> (,) =<< length
15:29:44 <yitz> @type (,) `ap` length
15:29:45 <lambdabot> forall a. [a] -> ([a], Int)
15:29:58 <SamB_irssi> Cale: I really think you should try to get it buildable with 6.8 if that's the only issue
15:30:31 <Cale> abbe: You seem to be branching on the first character of the string a whole lot... maybe something to abstract over that.
15:31:00 <abbe> Cale, oh, okay but it is ByteString
15:31:08 <enoksrd> @type ap
15:31:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:31:32 <yitz> SamB_irssi: it pays to hear from lispy about whether a 6.10 upgrade is imminent.
15:31:36 <abbe> Cale, so I can't include that in parameters
15:31:45 <Cale> abbe: I know. I wonder how this would look written in parsec.
15:31:50 <enoksrd> @type =<<
15:31:51 <lambdabot> parse error on input `=<<'
15:32:01 <enoksrd> @type (=<<)
15:32:02 <SamB_irssi> yitz: what about would-be contributors ?
15:32:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:32:03 <abbe> Cale, parsec ?
15:32:05 <Olathe> @type rangeSize
15:32:06 <lambdabot> forall a. (Ix a) => (a, a) -> Int
15:32:46 <sjanssen> SamB_irssi: the fix looks trivial, "okay (HsTypeSig   {}) = True" for old versions of haskell-src-exts "okay (Hs.TypeSig   {}) = True" in new versions
15:32:58 <pumpkin> yitz: ?
15:32:59 <yitz> SamB_irssi: also true. empirical evidence from cafe/here seems to indicate most people are on 6.10
15:33:24 <yitz> pumpkin: hi. lambdabot is back. pumpkinbot was asked to part.
15:33:28 <pumpkin> oh okay :)
15:34:14 <pumpkin> lambdabot: welcome back!
15:34:27 <yitz> @vixen welcome back!
15:34:27 <lambdabot> Let's change the subject
15:35:08 <Cale> abbe: yes, it's a parser combinator library
15:35:35 <abbe> Cale, okay, thanks, I'll look at it :)
15:35:41 <termos> how can i convert 3.0 into an Integer type? truncate floor and round etc. gives me some strange things i don't understand
15:36:07 <yitz> termos: what's strange?
15:36:11 <int-e> @type floor
15:36:12 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
15:36:17 <Cale> abbe: also, it seems that parseTorrent is needlessly in the IO monad.
15:36:17 <rwbarton> > round 3.0 :: Integer
15:36:18 <lambdabot>   3
15:36:32 <termos> something to do with RealFrac
15:36:57 <pumpkin> @seen dons
15:36:57 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
15:37:00 <termos> "No instance for (RealFrac Integer)"
15:37:05 <mmorrow> evv: there's currently a way to do that which if there're ever two lambdabots in one channel would make them go botnuts
15:37:13 <yitz> termos: hmm. what type is your 3.0?
15:37:19 <Cale> abbe: You probably want  parseTorrent :: ByteString -> Maybe Torrent, and then  readTorrent handle = fmap parseTorrent (B.hGetContents handle)
15:37:20 * mmorrow looks in his one-liners file
15:37:22 <augustss> termos: so you already have an integer
15:37:54 <yitz> > round (3.0 :: Integer)
15:37:55 <lambdabot>       No instance for (RealFrac Integer)
15:37:55 <lambdabot>        arising from a use of `round'...
15:38:16 <int-e> > 3.0 :: Integer
15:38:17 <lambdabot>       No instance for (Fractional Integer)
15:38:17 <lambdabot>        arising from the literal `3...
15:38:38 <sjanssen> @where+ loop @where loop
15:38:39 <lambdabot> I will never forget.
15:38:40 <rwbarton> termos: You're probably doing something else wrong
15:38:40 <sjanssen> @where loop
15:38:41 <lambdabot>  @where loop
15:38:47 <sjanssen> ooh, somebody fixed that
15:38:54 <mmorrow> @source > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in
15:38:54 <lambdabot> > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
15:38:57 <termos> yitz & augustss: i'm diving an even number by 2, so i didn't think i had to worry about it changing type
15:39:06 <mmorrow> @source , let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in
15:39:06 <lambdabot> , let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
15:39:08 <lunabot>  @source , let not = text . (++" in") . ap(++)show; available = "@source ,...
15:39:20 <termos> No instance for (Fractional Integer) arising from a use of `/'
15:39:23 <augustss> termos: how are you dividing it? with /
15:39:24 <yitz> termos: sounds like it didnt change type
15:39:31 <mmorrow> but lunabot properly puts a space there, and a single lambdabot won't respond to commands from itself
15:39:41 <mmorrow> so you'd need two lambdabots
15:39:53 <termos> augustss: yes
15:39:58 <rwbarton> > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
15:39:59 <lambdabot>   @source , let not = text . (++" in") . ap(++)show; available = "@source , l...
15:40:08 <enoksrd> > ((,) `ap` length) [1]
15:40:10 <lambdabot>   ([1],1)
15:40:21 <augustss> termos: we need to see more of your code to diagnose it
15:40:26 <abbe> Cale, okay.
15:40:32 <evv> mmorrow: what is the main difference between lunabot and lambdabot?
15:40:34 <rwbarton> termos: nothing ever "changes types"
15:40:39 <SamB_irssi> bring back pumpkinbot ?
15:40:50 <rwbarton> termos: If you're trying to divide an integer you know is even by 2, use `div`
15:40:57 <enoksrd> yitz: ((,) `ap` length) [1] doesn't work in my ghci
15:41:11 <yitz> enoksrd: :m Data.Function
15:41:18 <yitz> enoksrd: :m +Data.Function
15:41:21 <pumpkin> SamB_irssi: why?
15:41:34 <sjanssen> idea to prevent botloops: insert a non-printing Unicode character before each line the bot outputs, ignore all lines starting with that character
15:41:34 <abbe> Cale, but are there any other differences in both the ways ?
15:41:40 <enoksrd> yitz: oh, i imported that, it complains about a type error
15:41:40 <mmorrow> evv: lunabot has some other language extensions available in eval + some other imports, and lunabot just does eval rather than have a bunch of plugins like lambdabot
15:41:49 <termos> rwbarton: oh thanks that worked
15:41:50 <enoksrd> yitz: i'm on 6.8.2, should thaqt matter
15:41:59 <int-e> enoksrd: import Control.Monad.Reader
15:42:01 <Cale> abbe: hm?
15:42:26 <evv> mmorrow: ok cool. can you please get an additional lambdabot in this channel?
15:42:41 <mmorrow> evv: heh, i'm waiting for that to happen ;)
15:42:43 <yitz> int-e: oh right. Or Control.Monad.Instances
15:42:47 <enoksrd> int-e: "could not find module"
15:42:55 <int-e> yitz: which is too new, I believe
15:43:03 <yitz> int-e: is it?
15:43:15 <enoksrd> yits, int-e: i do have *.Instances
15:43:28 <int-e> yitz: hmm, it isn't.
15:44:02 <enoksrd> yitz, int-e: thanks, now it works
15:45:07 <abbe> Cale, anyways I'll RTFM, thanks though.
15:45:09 <int-e> yitz: Ok, I don't know what I mixed up, even ghc 6.6.1 had that module. 6.4.2 didn't.
15:45:38 <yitz> int-e: we need a good change log
15:45:48 <Cale> abbe: let me quickly rewrite it in parsec, and I'll show you how it'll look :)
15:46:23 <mmorrow> ReadP!
15:46:27 <abbe> Cale, cool :) here is the original spec: http://www.bittorrent.org/beps/bep_0003.html
15:47:31 <mmorrow> (there's a bytestringreadp pkg on hackage too)
15:48:01 <pumpkin> it'd be nice to have a typeclass that String and all ByteString variants were instances of
15:48:10 <pumpkin> so we could have a single generic way to work with them
15:48:29 <pumpkin> without having to use qualified imports
15:48:38 <yitz> john goerzen's ListLike
15:48:48 <mmorrow> it'd be nice if there was some "syntactic class" thing so we could pattern match on bytestrings as if they were lists
15:48:56 <Cheshire> pumpkin, like  f 0 = True, f has type Num n => n -> Bool, so f "foo" = ... would have type String s => s -> .. ?
15:49:08 <sjanssen> mmorrow: I suppose viewpatterns are the closest thing we have now
15:49:40 <monochrom> f "foo" would cause the compiler to think: how come String becomes a Num instance?
15:49:45 <mmorrow> foo (c:cs) = ... ====> foo s | c <- unsafeHead s, cs <- unsafeTail s = ...
15:49:46 <kerm|t> whats a better upgrade from AWK, python or haskell?
15:49:52 <pumpkin> Cheshire: having the literals be generic would be even nicer, but even just a "let's write a typeclass and make instances" without excessive GHC hackery would be nice
15:49:56 <yitz> or use bytestring comprehensions
15:50:01 <pumpkin> kerm|t: o.O
15:50:03 <mmorrow> sjanssen: yeah, or pattern guards
15:50:12 <yitz> kerm|t: perl
15:50:45 <mmorrow> once TH gets the Pat type extended to include pattern guards, things like that could be implemented by QuasiQuoters
15:51:46 <mmorrow> case s of [$rx|[0-7]{,3}r?.+|] -> 42; [$rx|HA[IS]?|] -> 99; _ -> 0
15:52:01 <mmorrow> (is currently not possible atm)
15:52:07 <mmorrow> but would be
15:52:18 <mmorrow> and
15:52:23 <mmorrow> foo (c:cs) = ... ====> foo s | c <- unsafeHead s, cs <- unsafeTail s = ...
15:52:28 <mmorrow> could be implemented verbatim
15:52:40 <mmorrow> well, it'd look like
15:52:58 <mmorrow> foo [$foo|(c:cs)|] = ....
15:53:12 <mmorrow> err, coincidence that both those idents were `foo'
15:53:28 <mmorrow> that'd be an error
15:54:11 <pumpkin> no such thing as coincidence
15:54:33 <monochrom> everything is a coincidence
15:54:44 <rwbarton> Cheshire: that exists today, -XOverloadedStrings and the IsString type class
15:54:53 <pumpkin> ooh
15:55:01 <rwbarton> or maybe pumpkin: :)
15:55:07 <mmorrow> oh yeah, i nearly forgot about that
15:55:09 <yitz> > "case s of " ++ (take 20 $ randomRs ('!','~') (mkStdGen 1)) -- mmorrow
15:55:10 <lambdabot>   "case s of :s&.'\"}6M1R2{B%r9?1u"
15:55:45 <mmorrow> yeah, you can always gen the entire expression
15:55:52 <mmorrow> but in pattern-context you're limited
15:55:59 <mmorrow> by the limitations of
15:56:01 <mmorrow> , src ''Pat
15:56:05 <lunabot>  data Pat = LitP Lit
15:56:05 <lunabot>           | VarP Name
15:56:05 <lunabot>           | TupP ([Pat])
15:56:08 <mmorrow> ...
15:56:10 <rwbarton> , randE ()
15:56:12 <lunabot>  ()
15:56:16 <mmorrow> heh, oh yeah
15:56:19 <mmorrow> , randE()
15:56:21 <lunabot>  let { "This is " | x4 = x10 where { 7 :: (->) = - 8 where { x10 x0 = x1}}...
15:56:51 <rwbarton> > let "foo" | 1 == 2 = "bar" in "blah"
15:56:52 <lambdabot>   "blah"
15:56:59 <mmorrow> it'd be sweet if this was cleaned up/extended to actually produce interesting (and syntactically/type correct) exps
15:57:16 <mmorrow> haha
15:57:25 <mmorrow> oh
15:57:48 <mmorrow> > let "foo" | 1 == 1 = "bar" in "blah"
15:57:50 <lambdabot>   "blah"
15:57:54 <mmorrow> > let "foo" | 1 == 1 = "bar" in "foo"
15:57:55 <lambdabot>   "foo"
15:58:06 <mmorrow> hmm
15:58:15 <mmorrow> > let 1 = 2 in 1
15:58:16 <lambdabot>   1
15:58:33 <rwbarton> , randE ()
15:58:35 <lunabot>  (x0) x8 ((case x4 of { x9 | x3 -> x2}) (x0 6)) :: ()
15:58:48 <mmorrow> , randE()
15:58:50 <lunabot>  case [] of { x2 -> x0; x2 -> x1}
15:59:04 <rwbarton> :t (?x0) ?x8 ((case ?x4 of { x9 | ?x3 -> ?x2}) (?x0 6)) :: ()
15:59:05 <lambdabot> forall t t1 t2. (Num t2, ?x0::t2 -> t -> (), ?x2::(t -> ()) -> t, ?x3::Bool, ?x4::t1, ?x8::t2) => ()
15:59:08 <rwbarton> woo!
15:59:12 <mmorrow> heh
15:59:31 <mmorrow> yeah, TH needs implicit params too
15:59:55 <mmorrow> (and GADTs, type/data families (and assoc types/datas), ...)
16:00:17 <mmorrow> the ability to splice everywhere, ...
16:00:41 <mmorrow> imports, extports, why not entire modules too, ..
16:01:04 <mmorrow> the ability to create little earth swallowing blackholes, ...
16:01:19 <byorgey> oooh
16:02:16 <mmorrow> blackHoleQ :: Q a -- never returns
16:02:38 <SamB_irssi> Cale: well, I figured out why haskell-src-exts now depends on base 4
16:02:38 <rwbarton> Real Haskell programmers create black holes in the type system.
16:02:48 <SamB_irssi> I also wrote a patch to allow building with base 3
16:02:53 <SamB_irssi> in addition to base 4
16:02:53 <Cale> abbe: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1142#a1142 -- try this and see if it's right
16:03:10 <mmorrow> blackHoleQ :: Q Type -- once spliced, never returns
16:06:43 <SamB_irssi> Cale: oh, the reason was that it derives Data for the AST types (at least, on GHC it does)
16:07:59 <abbe> Cale, installing haskell-parsec
16:08:14 <sjanssen> SamB_irssi: hmm, can't they use a conditional in the Cabal file to work with either version of base?
16:08:36 <SamB_irssi> sjanssen: that's exactly what I do in my patch, yes
16:14:49 <abbe> Cale, that works, thanks :)
16:17:32 <Cale> abbe: So you can see how it's a good bit more descriptive :)
16:18:02 <abbe> Cale, yes, I'll try and study your code, thanks for your time and help :)
16:19:09 <Cale> There's only one thing which I'm mildly annoyed by in this code -- there ought to be a way to eat n characters from the input in Parsec, since for ByteStrings, it would be more efficient than  replicateM n anyChar
16:19:28 <Cale> (one could implement it with splitAt)
16:25:12 <mmorrow> here's that parser using ReadP http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1142#a1144
16:25:32 <mmorrow> (the bytestringreadp on hackage, not Text.Parsercombinators.ReadP in the base pkg)
16:25:35 * pumpkin axes Axman6
16:26:38 <Axman6> urgh!
16:27:16 <Axman6> so sick of my ISP's crap. i should not have to put up with significant packet loss (to the point i can't connect to anything at all), for two weeks right?
16:27:25 <mmorrow> Cale: indeed with bytestringreadP there is a way to do that efficiently
16:27:42 <mmorrow> (some combo of look, length, and unsafeTail)
16:27:47 <Adamant> Axman6: you checked to be sure it's not a local problem?
16:27:48 <mmorrow> (and skip)
16:28:01 <Adamant> by that I mean, bad cable or something like that
16:28:15 <Axman6> Adamant: yes, i've run mtr, and i can see exactly where the problem is
16:28:23 <SamB_irssi> mtr ?
16:28:27 <Adamant> ah, ok
16:28:31 <mmorrow> (and munch is nice because it returns a /ByteString/, rather than a [Word8] (resp. [Char]))
16:28:33 <Axman6> well it suddenly started working again, without me doing anything
16:28:48 <Adamant> I had a craptastic connection due to bad cable the cable company laid
16:28:59 <Axman6> SamB_irssi: http://www.bitwizard.nl/mtr/ <-- very useful for network problems
16:29:25 <Adamant> fixed some connectors, got the cable relaid with new stuff, and it worked fine
16:29:41 <Axman6> Adamant: well they seems to be having the same kind of problems. first one of their routers died, and since then, it's just been pathetic
16:29:51 <Adamant> yeah
16:30:11 <Adamant> then it's unlikely to be cable suddenly rotting
16:30:16 <Adamant> but don't rule it out
16:30:25 <Axman6> it's all fibre too
16:30:29 <Adamant> ah
16:30:29 <Axman6> though not to our house
16:30:40 <Adamant> well I meant the "to house" connection
16:31:00 <Adamant> which is usually cable/ADSL/Ethernet
16:31:07 <Adamant> sometimes fiber
16:31:17 <Axman6> ADSL, and it's worked fine for the last 6 years or so
16:32:45 <Cale> unless I'm mistaken, that page for mtr is rather old...
16:33:07 <Cale> But mtr is really cool. :)
16:40:48 <Axman6> Cale: yep and yep :)
16:41:36 <hackage> Uploaded to hackage: colour 2.2.1
16:43:10 <redditbot> abhorrent: a bittorrent library for Haskell
16:43:43 <dancor> do you still have do silly rule-splitting to parse like Expr -> Expr "+" Expr, Expr -> Expr "*" Expr in parsec
16:43:56 <dancor> or are there sweet wrappers to avoid the left-recursion
16:44:19 <dancor> and maybe do the precedence while they're at it
16:47:20 <dancor> buildExpressionParser looks promising
16:49:07 * ksf would like to have some yi documentation besides the haddock, which doesn't appear to build right now.
16:52:49 <Philippa_> dancor: the chain* funcs are good too
16:53:53 <monochrom> I swear by buildExpressionParser now. Why write your own parser. In fact, why write your own grammar.
16:56:34 <Axman6> ttp://www.nrbook.com/a/bookcpdf/c1-1.pdf that's blank for other people too right?
16:56:53 <jeffz`> Axman6: requires a password
16:57:01 <Axman6> hmm
16:57:43 <Axman6> how lame, screw that
17:00:12 * SamB_irssi suggests maybe rot13 ?
17:02:20 <monochrom> ttp://www.nrbook.com/a/bookcpdf/c1-1.pdf  leads to "Firefox doesn't know how to open this address, because the protocol (ttp) isn't associated with any program."  <duck>
17:02:44 * monochrom notes that "... , because ..." the comma there should be deleted.
17:03:11 <monochrom> The pdf file says password required.
17:04:00 <chrisdone> where is vixey~_~
17:06:11 <Olathe> </duck> ;)
17:06:37 <monochrom> Mine was not a tag!
17:07:22 <Axman6> but you were forcing other people to duck, and tyey coud have bad backs!
17:07:23 <Olathe> Ahh.
17:07:28 <Olathe> My typechecking is failing.
17:07:30 <Axman6> h*
17:07:50 <SamB_irssi> monochrom: I guess you should have said <duck/>
17:09:12 <monochrom> I was stating that I ducked. I did not force people to duck. It was not an xml tag, it did not need closing. Even Dirac's bra does not need a closing ket.
17:09:45 <SamB_irssi> monochrom: why the heck does he wear a bra anyway ?
17:10:21 <byorgey> a closing ket, is that what they call those bra fastening doohickeys?
17:11:58 <Axman6> anyone know any C books that are good for high performance computing? i don't so much care about writing servers or parsers or what hve you
17:12:02 <Axman6> have*
17:12:23 <erikc> numerical recipes in C?
17:12:35 * Axman6 *glares*
17:12:53 <ksf> Axman6, the assembly docs of you processor?
17:13:01 <monochrom> int main(void) { return 0; }  is C high performance computing.
17:13:10 <erikc> http://www.fizyka.umk.pl/nrbook/bookcpdf.html
17:13:19 <SamB_irssi> monochrom: that's a bit bloated
17:13:26 <SamB_irssi> I've seen smaller!
17:13:44 <ksf> start: mov rax, 1 ; int 0x80 is faster.
17:14:11 <monochrom> Mine is the most portable.
17:14:32 <Axman6> erikc: huh, that one works fine
17:14:34 <SamB_irssi> monochrom: high-performance computing is not about portability
17:14:54 <SamB_irssi> (only)
17:15:01 <ddarius> SamB_irssi: No programming is about portability.
17:15:02 <SamB_irssi> certainly not for such a trivial program
17:15:09 <erikc> or you should just read Hennessy & Patterson and then your target platform's hardware docs
17:15:27 <SamB_irssi> why, any implementation of true that has it's own image is probably too slow
17:15:46 <ksf> mine runs on every amd64 linux system, _regardless_ of clib version.
17:16:33 <SamB_irssi> ksf: is that faster than the 32-bit version ?
17:16:39 <ksf> ...and propably on other nixes, too, dunno their syscall semantics.
17:17:03 <ksf> If your kernel is 64bit, I would think so.
17:17:57 <ksf> ...maybe you should use xor rax, rax ; inc rax or similar.
17:18:13 * SamB_irssi doesn't even have an amd64 CP
17:18:15 <SamB_irssi> U
17:20:42 * SamB_irssi goes home now ...
17:27:57 <ksf> @seen dcoutts
17:27:57 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
17:28:14 <dcoutts> @yarr!
17:28:14 <lambdabot> Well Ahoy! thar.
17:28:23 <ksf> dcoutts, yi-darcs, for example, pulls cabal 1.7
17:28:40 <dcoutts> ksf: you talking about gentoo?
17:28:45 <ksf> nah, cabal.
17:28:59 <ksf> but then, I'm using a gentoo.
17:29:11 <conal> anyone have online references for exact real arithmetic methods?
17:29:40 <ksf> my point is that cabal install tends to work exactly like cabal upgrade iff you use sufficiently bleeding edge packages.
17:29:58 <Axman6> lambdabot!
17:30:06 <monochrom> My teeth are bleeding edge.
17:30:07 <ksf> ...that is, tends to lead to borkage within a month or so.
17:30:22 <dcoutts> ksf: yes, I'm inclined to disable it
17:30:26 <Axman6> @remember ehird 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
17:30:27 <lambdabot> Done.
17:30:31 <Axman6> hoorah
17:30:38 <ksf> disable cabal install?
17:30:44 <dcoutts> ksf: no, upgrade
17:30:48 <Axman6> @quote ehird
17:30:49 <lambdabot> ehird says: 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
17:31:00 <ksf> that won't help to fix the cause of the problem.
17:31:30 <dcoutts> ksf: which problem are you referring to?
17:31:38 <Debugger> It's always the year of the linux desktop..
17:31:51 <ksf> ghc depending on two versions of the same package.
17:32:52 <dcoutts> ksf: do you mean http://hackage.haskell.org/trac/hackage/ticket/474 or the symptom?
17:33:33 <ksf> yes, but only similar.
17:33:47 <ksf> there are actually packages that don't work with cabal 1.6
17:34:10 <ksf> so they're bound to pull an incompatible version.
17:34:47 <dcoutts> ksf: I'm not quite sure what point you are making
17:35:07 <dcoutts> ksf: are you reporting a particular bug, asking advice or suggesting a fix?
17:35:28 <ksf> That I successfully broke my package database by cabal install'ing yi-darcs.
17:36:01 <ksf> I'm merely pointing out that not using cabal upgrade doesn't fix things. it only fixes the common cause.
17:36:02 <dcoutts> ksf: ok, so you got ghc depending on two versions of process?
17:36:08 <dcoutts> ksf: yes, indeed
17:36:16 <ksf> nope, on two versions of cabal.
17:36:33 <dcoutts> ksf: ah, do you know why you ended up with two versions of it?
17:36:52 <dcoutts> ksf: oh, you needed 1.7, you said.
17:37:08 <dcoutts> that shouldn't be a problem usually
17:39:52 <FunctorSalad> are you being serious about 2009 and haskell web apps? :)
17:40:14 <ddarius> monochrom: You should floss more.
17:40:28 * ksf gives up to find a dedicated haskell job ad somewhere around hamburg and goes for those that mention haskell, instead.
17:40:42 <mmorrow> can anyone think what lib `openpty' is in?
17:41:02 <monochrom> hehe
17:41:18 <mmorrow>  / does anyone know?
17:41:23 <sjanssen> mmorrow: unix, I would think
17:41:30 <mmorrow> i mean in /usr/lib
17:41:31 <sjanssen> if there are bindings at all?
17:41:34 <sjanssen> oh
17:41:56 <FunctorSalad> ksf: sigh... I'd love a haskell job too
17:42:07 <mmorrow> heh, it's usage in unix is what i'm trying to resolve it for.. (i'm trying hackish things)
17:43:02 <mmorrow> whatev, i'll just define it myself for now since it's not necessary for what i'm doing
17:44:32 <guenni> can I access windows resource files from haskell?
17:45:02 <jeffz`> guenni: what do you mean access them?  you can link against them if that's what you want.
17:45:41 <guenni> jeffz`: well with accessing them I mean can I read the content from haskell code
17:46:03 <jeffz`> guenni: yes, I don't see why not.
17:46:37 <guenni> jeffz`: not sure how I'd do that though, never seen that mentioned
17:47:01 <jeffz`> guenni: it's embedded in the executable, you need to figure out how to extract the resources
17:47:58 <guenni> jeffz`: ok but how do I refernce the objects, I really got no clue
17:48:21 <mmorrow> ah, -lutil did it
17:49:13 <jeffz`> guenni: oh, you'd need to use the windows api
17:50:04 <guenni> so I can do that for as long as I use a lib that provides haskell wrappers to that functionality
17:50:09 <jeffz`> guenni: doesn't look like there is any binding to the resource functions already written, so you'd need to write your own
17:50:26 <jeffz`> guenni: yes, look at the Win32 package for an example of existing bindings to some of win32
17:50:51 <guenni> well there might, I'm using wxhaskell, there might be something
17:51:12 <ksf> why don't you just open a file, like everybody else?
17:51:15 <guenni> jeffz`: the idea is just totally new that I can do that
17:51:25 <ksf> there's no need to pack everything into the binary.
17:51:28 <jeffz`> guenni: http://msdn.microsoft.com/en-us/library/ms674623(VS.85).aspx
17:51:59 <guenni> ksf: well several reason: 1. I can't find the files because I can't figure out the execs directory
17:52:37 <mmorrow> i'd rather not have to rely on the existence of an external file(s) if i didn't have to either
17:52:45 <guenni> ksf: 2. I might want some of the stuff to be a little protected
17:53:00 <jeffz`> guenni: if you want to find where your executable is you can use GetModuleFileName http://msdn.microsoft.com/en-us/library/ms683197(VS.85).aspx
17:53:42 <guenni> jeffz`: the page is not found
17:53:59 <jeffz`> works for me
17:55:14 <guenni> thanks jeffz` I was looking for exactly that all day, almost went nuts
17:56:04 <jeffz`> guenni: import System.Win32
17:56:04 <guenni> just dead ends
17:56:07 <jeffz`> guenni: main = getModuleFileName nullPtr >>= putStrLn
17:57:24 <drhodes> I've got a vector-like type which should allow (scalar * thing) and (thing * thing), is there a built-in typeclass which would be good to derive from?
17:57:25 <guenni> jeffz`: I LOVE YOU
17:57:48 <guenni> jeffz`: THANKS!
17:57:55 <ksf> there's already Data.Complex
17:57:56 <guenni> I'd almost given up
17:58:05 <Olathe> drhodes: Not really. (*) won't allow two different types.
17:58:12 <drhodes> :[
17:58:13 <Cale> drhodes: I would recommend naming scalar and vector multiplication differently
17:58:25 <Olathe> .* is common, I think.
17:58:36 <Olathe> Something like that.
17:58:50 <Cale> drhodes: not because it's impossible to achieve with typeclasses, but because it's more convenient in terms of type inference
17:59:57 <Cale> (it's really easy to have ambiguous types with that kind of overloading)
18:00:41 <lispy> Cale: you need ghc6.10?  I thought you installed it before
18:00:41 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
18:00:43 <ddarius> Sounds like an algebra not a vector space...
18:00:46 <drhodes> then .* is a good alternative, thanks guys
18:00:48 <lispy> ?message
18:00:48 <lambdabot> Maybe you meant: messages messages?
18:00:51 <lispy> ?messages
18:00:51 <lambdabot> Cale said 2h 32m 29s ago: Could we get GHC 6.10.1 on olive?
18:00:56 <mmorrow> i just realized one way to be able to set/modify the +RTS options the rts gets is to have a c function "my_main(int argc, char **argv){....parse args in argv/etc...; main(argc',argv');}" and pass the linker "--entry=my_main"
18:01:08 * drhodes goes forward trusting in #haskell
18:01:22 <lispy> #haskell is usually pretty solid on advice
18:01:40 <gwern> sjanssen: if cale or lispy don't have recent src-exts, then they can just use hackage lb which sets an upper bound to src-exts and uses the old api
18:01:44 <ddarius> lispy: Nice circular advice there.
18:02:10 <lispy> fix $ \#haskell -> ....
18:02:28 <dolio> Dude, your magic hash is in the wrong place.
18:02:29 * drhodes changed his nick from dublpaws because he started to forget his real name.
18:03:27 <lispy> Cale: I don't think debian has packages for ghc that are new enough
18:04:21 <ksf> drhodes, http://www.haskell.org/haskellwiki/Vector-space ?
18:05:04 <drhodes> thanks ksf
18:05:07 <pumpkin> dolio: looks like your patch to uvector made it in :P
18:05:18 <dolio> Apparently. :)
18:06:53 <sjanssen> gwern: at any rate, it would be nice if lambdabot could still be buildable with GHC 6.10
18:07:13 <sjanssen> gwern: it generally isn't too hard to maintain compatibility, and lots of people are still on 6.8
18:07:41 <gwern> sjanssen: what, was I supposed to throw in a CPP pragma to switch between old and new haskell-src-exts?
18:08:26 <drhodes> damn vector-space depends on 6.10, I guess it's time to bite the bullet.
18:08:52 <ksf> all of conal's stuff depends on fairly recent ghc's.
18:09:04 <ksf> ...unamb on an unreased one.
18:09:15 <sjanssen> gwern: yeah, I do see your point
18:09:33 <sjanssen> gwern: backwards compatibility can be annoying, but it is appreciated
18:09:54 <gwern> sjanssen: but again, such people can use the hackage lb
18:09:56 * mmorrow reminds himself never to use /dev/shm to dl and build a ghc then forget it's there and shut the computer down
18:10:12 <gwern> iirc, the only difference between hackage and darcs lb is that and... some really minor changes
18:10:17 <gwern> a state/ update too, I think
18:10:28 <sjanssen> gwern: don't we want to encourage lambdabot hackers?
18:10:44 <sjanssen> it is also good for the actuall #haskell lambdabot to be able to run the latest version
18:10:56 <gwern> sjanssen: I'd mention I *was* encouraging a lb hacker
18:11:18 <sjanssen> gwern: did lambdabot not build on 6.10 before those patches?
18:11:18 <mornfall> mmorrow: You do have a lot of memory, don't you?
18:11:43 <gwern> sjanssen: dunno. my TH is borked so I can't build lb all the way
18:11:47 <mmorrow> depending on what kind of mem you mean, no and no ;)
18:12:16 <mmorrow> gwern: did cabal-install reinstall it at some point?
18:12:21 <dobblego> does lambdaabot install through cabal install?
18:12:23 <somnolence> javascript?
18:12:39 <mmorrow> javascript?
18:12:53 <lispy> I don't think you can install lambdabot through javascript
18:12:59 <gwern> mmorrow: TH? yes, I remember some inpleasant things
18:13:01 <pumpkin> dobblego: yeah
18:13:01 * ksf is starting to hallucinate.
18:13:06 <ksf> I'm smelling coffee.
18:13:14 <lispy> I'm smelling tired.
18:13:20 <ksf> But I went cold turkey long ago.
18:13:23 <gwern> I'm smelling... victory.
18:13:26 <mmorrow> gwern: so that's a yes, cabal-install reinstalled your template-haskell pkg?
18:13:32 <gwern> think so
18:13:35 <mmorrow> i smell napalm
18:13:43 <gwern> or maybe I hand-reinstalled it myself because cabal-install phailed
18:13:45 <pumpkin> I'm smelling the word synesthesia
18:13:52 <lispy> I smell lambdas and types!
18:14:57 <Olathe> I smell.
18:15:14 * lispy hands Olathe some old lambda spice
18:15:29 <Olathe> Thanks :)
18:15:31 <mmorrow> gwern: that's the reason i don't use cabal-install super often, since it bases the decision to "reinstall/upgrade" things based on the possibly arbitrary version numbers the author of a .cabal file attaches to deps
18:16:13 <mmorrow> (aside from the fact that there are certain pkgs you just can't rebuild without epic fail)
18:16:20 <Olathe> Hmm, I think I have an idea to make Data.Binary list sending lazier.
18:16:51 <lispy> What's lazier than a Haskell programmer?
18:17:06 <sjanssen> mmorrow: hmm, cabal-install should get some failsafes for those packages
18:17:13 <lispy> A: Nothing!
18:17:17 <mmorrow> sjanssen: totally
18:21:12 <Olathe> @src splitAt
18:21:12 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
18:21:36 <Olathe> Does that actually go through n items twice ?
18:22:10 <lispy> Olathe: well, that's an illustrative example
18:22:10 <Gracenotes> not if only one of them is needed ;)
18:22:34 <lispy> Olathe: you should check the GHC source to see if it's representative of what we really use
18:23:01 <Olathe> Ahh.
18:23:04 <Olathe> Gracenotes: Haha
18:23:08 <lispy> Olathe: http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/src/GHC-List.html
18:23:12 <Olathe> Thanks :)
18:23:15 <lispy> Olathe: yeah, it really does what you feared.
18:23:27 <gwern> 'A bit more than 4 years ago, you wrote:' lol
18:23:41 <gwern> let no one say stefan monnier doesn't answer his emails! (eventually)
18:23:43 <Gracenotes> I can't find splitAt in the List.hs source
18:23:57 <lispy> Gracenotes: I just pasted the link to Olathe
18:23:57 <Gracenotes> at least, the version I have. genericSplitAt is there, though
18:24:13 <drhodes> Darcs or stable that is the question. To sip the bloody edge or bask in assurance of tested work, be it far nobler to report troubles from the trenches than pass and wave by the tired and torn. Choose darcs, Choose honor.
18:24:17 <Gracenotes> then again, I'm looking at Data.List
18:24:23 <Olathe> Wow.
18:24:30 <Olathe> The version it uses is all hackish.
18:24:51 <lispy> Olathe: Oh, yeah I see.  The real version is crazy
18:24:51 <gwern> drhodes: 'use darcs. because we're none of us getting out alive anyway.'
18:24:58 <lispy> I didn't see the #ifdef
18:25:10 <Olathe> I wonder if there's a splitAtWithLength
18:25:21 <Gracenotes> ah, the splitAt (I# n#) ls one?
18:25:40 <Olathe> Ahh, it uses recursion.
18:25:54 <Olathe> With tuples.
18:25:57 <lispy> Those haskell programmers and their recursion
18:26:02 <Olathe> If that's good enough for ghc, it's good enough for me.
18:26:07 <ksf> w00t! ghc finished compiling
18:26:28 <ksf> ...and I just noticed I forgot to pass the right prefix to configure.
18:26:51 <gwern> lispy: yo dawg...
18:27:29 <ksf> YO DAWG I HEARD YOU LIKE MODULARITY SO I PUT A PREFIX IN YOUR PREFIX SO YOU CAN CONFIGURE WHILE YOU CONFIGURE
18:27:34 <Olathe> Is xs@[], so that I can use xs instead of creating a new [] an evil hack ?
18:27:50 <ddarius> Olathe: No, it's pointless.
18:27:58 <Olathe> ghc will figure it out ?
18:28:05 <ddarius> Olathe: No, there is only one [] anyway.
18:28:08 <Olathe> Oh.
18:28:11 <Olathe> Alright :)
18:28:26 <Olathe> Hmm, Data.List.splitAt uses that trick.
18:28:34 <Olathe> splitAt# _ xs@[] = (xs, xs)
18:28:46 <Gracenotes> > let splitAt n ls = if n<0 then ([],ls) else splitAt' n ls where splitAt' 0 xs = ([],xs); splitAt' _ [] = ([],[]); splitAt' m (x:xs) = (x:xs', xs'') where (xs', xs'') = splitAt' (m-1) xs in splitAt 5 [1..10]
18:28:48 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
18:28:52 <Olathe> I think I'll avoid it for spiffyness, but.
18:28:54 <Gracenotes> the GHC implementation. But without the primitives.
18:29:19 <ksf> Olathe, see that magic hash?
18:29:37 <Gracenotes> what does the magic hash do? :3
18:29:58 <gwern> unboxed, isn't it?
18:30:14 <ksf> divide the pure from whe world.
18:30:37 <ddarius> It doesn't "do" anything.
18:30:51 <Gracenotes> perhaps we need a more magic hash, then
18:31:17 <sjanssen> the magic hash extension makes # into a special character that can be used in identifiers and literals
18:31:39 <blackdog> man, having to use ',' as a separator in lists and records kinda blows. wish haskell did it the perl way.
18:31:45 <ksf> ...so that you can acutally mention all those magic identifiers that eg. GHC.Prim exports.
18:31:59 <blackdog> (and yes, i recognise that this is like bitching that jessica alba has ugly feet)
18:32:15 <ksf> things like unsafeShootMyCat# and the ilk
18:32:36 <gwern> blackdog: she does?
18:32:50 <Olathe> Can anyone see any nice improvements to http://www.unsafecoerce.com:8080/fastcgi/hpaste.fcgi/view?id=1145#a1145 ?
18:33:30 <Olathe> Except for the nextLen bug.
18:33:49 <ksf> blackdog, you'd need more parens otherwise.
18:34:02 <sjanssen> blackdog: how does Perl do it?
18:34:16 <ksf> ...at least with records. list literals usually don't contain expressions
18:34:28 <ddarius> ksf: They don't.
18:34:29 <ddarius> ?
18:35:36 <ksf> still, haskell pioneered the highly readable style of aligning "," under the opening bracket.
18:35:40 <ksf> everyone should do that.
18:36:06 <blackdog> sjanssen: you'd allow [a,b,c,d,]
18:36:19 <blackdog> or Constructor { foo = blah, baz = bar, }
18:36:33 <ksf> blackdo, what for?
18:36:35 <blackdog> means that when they're vertical you can cut by line and not have to come back and fiddle with syntax
18:36:55 <sjanssen> blackdog: ah, trailing comma would be nice
18:37:03 <ksf> just write Foo\n{ blah\n, blah\n, blah\n}
18:37:10 <Olathe> Gracenotes: Magic hash ?
18:37:28 <ksf> the comma goes at the start of the line.
18:37:53 <blackdog> ksf: that's a neat trick.
18:37:57 <sjanssen> ksf: you do still have to fix edits involving the first line
18:38:04 <ksf> same goes for longer adt's, where you align the |'s under the =.
18:38:52 <Nafai> Sheesh guys
18:39:11 <Nafai> Enough mail to -cafe today?
18:39:23 <ksf> If you don't like it, dress up in asbestos and write a h' proposal.
18:39:24 * ddarius composes an email.
18:40:37 <gwern> Nafai: there will never be enough emails to -cafe until all the heathen are converted
18:40:42 <sjanssen> ksf: it has been proposed before, I don't know what came of it
18:40:45 <blackdog> Nafai: that's easy - just mail them asking to stop sending so much. if a few people join in, i'm sure you'll fix the problem in no time.
18:41:06 <sjanssen> of course I'd rather keep [,] available for list section syntax, mwahahaha
18:41:54 <ddarius> Have [,], [,,], and [,,,] etc. ?
18:42:04 <Nafai> blackdog: Haha
18:42:09 <sjanssen> ddarius: something like that
18:42:09 <Nafai> I'm not really complaining
18:42:18 <sjanssen> [1,,3] 2 == [1, 2, 3]
18:42:21 <Nafai> Just more to catch up on :)
18:42:30 <ddarius> Oh god, it's worse than I thought.
18:42:53 <ksf> code organisation, lesson 1: don't require more than compiling one .o and linking one binary if all that changed is either the install prefix or version number.
18:42:58 <sjanssen> it's evil for lists, but it would be pretty handy for tuples
18:43:10 <sjanssen> how often have you written: map (flip (,) x)?
18:43:31 <ddarius> Not too often, actually.
18:44:03 <blackdog> http://pastie.org/377993
18:44:07 <ddarius> Admittedly, I'd probably use such a sectioning syntax more than list comprehensions.
18:44:26 <TomMD> Nafai: I know it seems random, but are you 'the' Nafai in portland?
18:44:40 <blackdog> i think i may be going about this bass-ackwards - i'd like to write a generic Operations module that encapsulates some of the operations a Map-like interface should support
18:45:18 <ksf> uhmmm... typeclasses?
18:45:29 <ksf> seems like you're trying to reinvent them.
18:45:32 <Nafai> TomMD: Nope, not me.  Sorry.
18:45:43 <blackdog> ... possibly. still not my go-to tool, i should probably fix that.
18:45:47 <Gracenotes> @hoogle proc
18:45:47 <lambdabot> module System.Process
18:45:47 <lambdabot> package process
18:45:47 <lambdabot> System.Posix.Types type ProcessGroupID = CPid
18:45:55 <ddarius> blackdog: If the Nothings are meant to indicate defaults, simply make a default record and update that.
18:45:56 <Nafai> TomMD: I live in Utah
18:45:59 <Gracenotes> hm :/
18:46:08 <TomMD> Nafai: Ok, just had to ask.
18:46:10 <blackdog> so make MapOps a typeclass, provide an implementation in each file and robert's your mother's brother?
18:46:19 <Nafai> np
18:46:23 <blackdog> ddarius: not quite - Nothing is meant to indicate that the data type doesn't support it
18:46:31 <ddarius> blackdog: That's sinful.
18:46:39 <blackdog> ie, a perfect-hashing library wouldn't support insertion
18:46:43 <blackdog> ddarius: how so?
18:47:22 <sjanssen> blackdog: in that case, multiple type classes would be better
18:47:47 <ddarius> blackdog: If it doesn't actually support the operations of the interface, why would you say it would?
18:48:04 <Olathe> @src replicateM
18:48:04 <lambdabot> replicateM n x = sequence (replicate n x)
18:48:28 <blackdog> ddarius: this is just for benchmarking - i want to make it easy to plug a new datatype in and have the benchmarker just skip over the unsupported operations
18:48:35 <blackdog> multiple typeclasses wouldn't help me much there
18:49:00 <blackdog> (again, entirely possible i'm going about this badly, or reinventing wheels)
18:49:16 <sjanssen> blackdog: in that case, your interface seems okay :)
18:49:31 <sjanssen> just as long as you aren't planning on using this sort of thing for general programming
18:49:38 <blackdog> sjanssen: oh dear god no :)
18:50:36 <blackdog> heh, and coincidentally when i shift it to a typeclass impl, my bitch about commas becomes null too
19:10:09 <mmorrow> @pl \c a b -> f a b c
19:10:09 <lambdabot> flip (flip . f)
19:11:42 <dobblego> cabal install lambdabot -> "lambdabot-4.2.2.1 depends on haskell-src-exts-0.3.12 which failed to install."
19:12:21 * ksf wants a raid
19:12:34 <ksf> and a quadcore
19:13:53 <mmorrow> hmm, this might be nice in some situations http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1146#a1146
19:14:24 <mmorrow> a Map record where the type of the Map (m :: * -> * -> *) is existential
19:14:38 <mmorrow> kind of "object"-ish
19:15:23 <Twey> mmorrow: "object"-ish?
19:15:32 <Twey> How so?
19:15:42 <roconnor> @type Maybe
19:15:43 <lambdabot> Not in scope: data constructor `Maybe'
19:15:45 <roconnor> @type maybe
19:15:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:15:51 <mmorrow> since the data and the functions on the data are both included in the existential package
19:15:54 <roconnor> @type fromMaybe
19:15:55 <lambdabot> forall a. a -> Maybe a -> a
19:16:19 <mmorrow> you can't actually know the type of the map if you have one of those
19:16:43 <mmorrow> (so you can't actually use the record selectors among other things)
19:17:04 <mmorrow> (but they're handy as labels while defining a (:->))
19:17:50 <mmorrow> you could have a list [a :-> b] where the type of the maps inside each (a :-> b) are different
19:18:29 <ksf> now that's what I call syntax highlighting.
19:18:58 <ksf> yi displays -> as → and \ as λ and so on.
19:19:25 <mmorrow> oh oops, i forgot the Data.Map import
19:20:02 <roconnor> @type iterate
19:20:03 <lambdabot> forall a. (a -> a) -> a -> [a]
19:21:31 <mmorrow> i think this method is very similar to how ghc implements type classes
19:21:38 <mmorrow> i can't recall the specifics though
19:22:29 <mmorrow> (something like every class instance is represented by a record of functions (the dictionary) with existential type and <i can't remember the rest>)
19:23:10 <ddarius> mmorrow: There is no need for existential types in the translation of type classes.
19:23:14 <mmorrow> but the data isn't put _inside_ the dicts
19:23:34 <mmorrow> ddarius: there may not be, but i think this is how ghc does it
19:23:51 <ddarius> mmorrow: I'm pretty certain that it is not how GHC does.
19:23:54 <ddarius> it
19:23:58 * mmorrow is looking for the comment describing how it works
19:24:26 <mmorrow> err, i might be using "existential" incorrectly here
19:24:37 <mmorrow> i mean whatever the proper term is in:
19:25:21 <mmorrow> data Dict = Dict {foo :: a -> (forall b. -> ...) -> c ... }
19:25:29 <mmorrow> i guess "second order" or something
19:25:47 <mmorrow> anyways, we'll find out shortly
19:26:55 <ddarius> mmorrow: Constructor classes can require rank 2 types (universals), but it's not an aspect of type classes generally and the quantified variables are the -free- variables, not the ones bound by the class declaration.
19:27:24 <mmorrow> yes, "rank 2 types" is what i meant
19:27:39 <ddarius> E.g. the dictionary for Monad looks like, data MonadDict m = MonadDict { return :: forall a. a -> m a, ... }
19:27:44 <hassanslash> Anyone used weka before?
19:27:59 <pumpkin> hassanslash: isn't that java?
19:28:02 <mmorrow> ah yeah, that's it
19:28:32 <hassanslash> pumpkin: yes it is, but I didn't know where else to ask.
19:28:40 <pumpkin> what's the question?
19:28:45 <dobblego> what is the format of passwd.rc for lambdabot?
19:29:38 <hassanslash> pumpkin: I'm using their ID3 algorithm implementation, using NetBeans, its all working fine BUT... I don't know where to begin in terms of specifying my own data to be mined.
19:30:00 <pumpkin> oh, I have no clue :) I thought you were gonna ask how to implement something like that in haskell :P
19:30:34 <hassanslash> if I was going to, how would I find out which class (amongst a tonne) is to be edited?
19:31:05 <mmorrow> ddarius: found that comment: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1148#a1148
19:31:29 <hassanslash> mmorrow: hi again :)
19:31:37 <mmorrow> yeah, /universal/ type
19:31:42 <mmorrow> hassanslash: hi
19:32:19 <ddarius> mmorrow: Your Map type -is- using an existential and that is what makes it -different- from type classes.
19:32:22 <mmorrow> oh wait, no
19:32:27 <mmorrow> ddarius: yes
19:32:36 <SamB> does anyone know where I can contact waern ?
19:32:55 <mmorrow> ddarius: it's dual
19:33:11 <ddarius> mmorrow: That's probably too strong.
19:33:18 <mmorrow> heh, fair enough
19:33:24 * ddarius oversteeped his tea.
19:33:33 <mmorrow> but close enough
19:33:54 <ddarius> mmorrow: You'd have to justify that (for me to accept it)
19:33:58 <SamB> dcoutts: hey, shouldn't waern have ownership of /srv/trac/haddock/db ?
19:34:28 <mmorrow> ddarius: i think i could (to what extent i'm not sure yet), but i'll have to think it through
19:35:20 <ddarius> mmorrow: Actually I know you are "wrong" at least in one sense.
19:35:21 <mmorrow> hmm, actually there's a little hiccup in the duality
19:35:27 <ddarius> There's one way to see this.
19:35:53 <ddarius> One way to get a duality is to negate, that swaps universals and existentials but it also swaps other things.
19:36:03 <ddarius> For example, products and sums.
19:36:40 <mmorrow> data F f = forall a. F (f a)       data G g = G (forall a. g a)
19:36:50 <ddarius> So the dual of your objecty type would look more like an algebraic type (with multiple cases) rather than a type class or some such.
19:37:11 <mmorrow> but  data a :-> b = forall m. Map (m a b) which is neither of those
19:37:12 <ddarius> (And indeed, there is just such a duality.)
19:38:29 <mmorrow> but  MonadDict m = MonadDict (forall a. ... m a .... )
19:40:09 <ddarius> mmorrow: Just to be clear, MonadDict is more like MonadDict (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)
19:40:19 <mmorrow> yes
19:41:24 <gwern> @ask dcoutts
19:41:25 <lambdabot> Consider it noted.
19:41:31 <gwern> er.
19:41:44 * gwern wonders what will come of that
19:41:45 <gwern> @seen dcoutts
19:41:45 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 2h 4m 37s ago.
19:41:46 <pumpkin> @tell gwern
19:41:46 <lambdabot> Consider it noted.
19:42:07 <ddarius> I guess you could still pull the foralls out a bit (by introducing a tuple)
19:42:08 <mmorrow> it'd be interesting to work out the/an algo to compute the dual (wrt existential/universal and ?) construction (also a data decl) given a haskell data declaration
19:42:12 <blackdog> ok. so if i have a typeclass Mappable, how do i iterate over a list of Mappable things? they're going to have different types, so i can't just whack them in a list...
19:42:38 <ddarius> blackdog: You use an existential type.
19:42:55 <pumpkin> how does Mappable differ from Traversable?
19:43:00 <gwern> foo
19:43:00 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
19:43:05 <gwern> @messages
19:43:06 <lambdabot> pumpkin said 1m 19s ago:
19:43:15 <pumpkin> @tell gwern off
19:43:15 <lambdabot> Consider it noted.
19:43:18 <gwern> hm. that shouldn't be allowed :)
19:43:19 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
19:43:26 <pumpkin> :)
19:43:35 <gwern> @messages
19:43:35 <lambdabot> pumpkin said 20s ago: off
19:43:36 <blackdog> ddarius: thanks, i'll look it up.
19:43:48 <gwern> pumpkin: your message seems to've gotten lost
19:43:57 <pumpkin> :o
19:44:02 <blackdog> pumpkin: in almost every way.
19:44:14 <pumpkin> fair enough :)
19:44:15 <blackdog> pumpkin: maybe it's a bad name - i mean something like Map in Data.Map
19:44:22 <pumpkin> aha
19:44:24 <ddarius> mmorrow: Basically, just push a negation all the way through.  The only ? part is, what is Not Int.
19:44:31 <blackdog> nomenclature's so tricky
19:44:34 <gwern> @ask dcoutts is there an existing bug for making hackage immediately generate haddocks? today's email was far from the first time I've seen someone confused about it, and warnings on pages are both not working and seem like a hack anyway
19:44:34 <lambdabot> Consider it noted.
19:44:40 <mriou> hi, building question: is there better than cabal by way of Distribution.Simple to build a Haskell project?
19:45:20 <mmorrow> ddarius: yeah, i guess it'd only apply to decls that have at least one existential or universal type somewhere (or something)
19:45:25 <mriou> the thing seems rather primitive...
19:45:39 <ddarius> mmorrow: Why?  Not (a,b) == Either (Not a) (Not b)
19:45:43 <mmorrow> or i guess even better would be to say that Int is self-dual
19:45:51 <mmorrow> ah, yeah that too
19:45:56 <gwern> mriou: your comments are too vague to be meaningfully replied to
19:46:08 <ddarius> mmorrow: Yes, that's one choice.  I'm abusing "Not" here to piggy-back on it's formal rules.
19:46:09 <mmorrow> wrt  existential/universal, product/sum, .. ?
19:46:41 <pumpkin> mriou: if you have any specific questions about things that you think cabal is too primitive to handle, maybe we can give you pointers on the way it's typically done
19:47:10 <mriou> gwern, pumpkin: oh I think cabal is very good as a packaging / dependency mechanism
19:47:39 <gwern> it suddenly occurs to me to wonder - are email address case-sensitive?
19:47:40 <ksf> it only appears primitive because it's so sophisticated that it's undistingushable from magic.
19:47:50 * gwern should've written down this email more carefully...
19:47:52 <mriou> but for building, in most other languages you have pre-built facilities to copy stuff around, generate some dumb files or similar things
19:48:02 <pumpkin> gwern: not that I've ever seen
19:48:09 <ksf> mriou, it's all there.
19:48:15 * SamB emails waern about trac spam on the haddock trac
19:48:32 <mriou> ksf: I must have missed it then, probably my bad
19:48:45 <ksf> to copy stuff you just have to list it, to generate stuff you use a custom build type and hook up your generators in your custom Setup.hs
19:49:20 <ksf> you can also read that as "you won't get far without reading the haddock"
19:49:52 <Olathe> Yay !
19:49:59 <mriou> ksf: I actually did and it pretty much says that the hooks are experimental and relying on them isn't adviced
19:51:10 <Gracenotes> @hoogle FiniteMap
19:51:10 <lambdabot> package FiniteMap
19:51:12 <ksf> I read it as "fix your cabal dependency to some particular version if you want a proper error message in case the api changes"
19:51:18 <Gracenotes> ..kthx
19:51:33 <pumpkin> Gracenotes: the online hoogle would have a link
19:51:50 <Gracenotes> "This is the deprecated Data.FiniteMap library"
19:51:51 <SamB> if they release another version and it still works, you can switch to a range and re-upload
19:52:02 <SamB> Gracenotes: use Data.Map
19:52:12 <Gracenotes> ah. Sounds good.
19:52:35 <SamB> FiniteMap isn't even deprecated anymore, it's just gone
19:52:43 <SamB> has been for a while now
19:52:55 <gwern> there's a fintemap-in-map on hackage
19:53:01 <SamB> since 6.6 or 6.8 ...
19:53:10 <gwern> useful sucker when one is feeling too indolent to rewrite into data.map
19:53:27 <gwern> although that isn't too hard with a cheatsheet. mostly just renaming and exchanging paramteter position
19:53:33 <SamB> next, someone should upload a tool to inline a particular hackage package into your code
19:53:37 * gwern has done both in the past
19:54:06 <ksf> that's exactly the kind of refactoring we should have tool support for.
19:54:44 <Olathe> I've figured out how to fix Data.Binary's list instance. It used to check the length of the list before sending even one element, which might take a while with a list that's several million elements long and is being slowly generated lazily. Now, it sends in blocks of 255 elements, so it's much better with lazy lists and works for the first time with infinite lists.
19:54:47 <ksf> ...changing to a slightly different interface that is, not necessarily inlining.
19:54:55 <Olathe> Who should I send the fixed version to ?
19:55:01 <SamB> so, has anyone else seen trac spam on code.haskell.org ?
19:55:03 <Gracenotes> @quote
19:55:03 <lambdabot> faxathisia says: /msg lambdabot > fun (cycle "\3\&5de\3\&3su ") :: Expr
19:55:18 <Gracenotes> okay, then..
19:55:24 <SamB> Olathe: well, er, you can't.
19:55:27 <SamB> it would break the code.
19:55:28 <Olathe> I can't what ?
19:55:37 <Olathe> Oh, sure, it's not backward compatible.
19:55:38 <SamB> er, I mean, it would break poor @vixen!
19:56:03 <Olathe> But it's unstable anyway and this is a nice Haskelly fix, I think.
19:56:05 <ksf> we can't allow @vixen to get heart-broke.
19:56:06 <Gracenotes> @type fun
19:56:07 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
19:56:11 <SamB> I won't help you until you add versioning!
19:56:28 <Olathe> Maybe.
19:56:38 <Olathe> I'm not sure how to do that.
19:56:44 <sjanssen> Olathe: upstream will not want to apply your code
19:56:48 <SamB> they already broke poor vixen once with their lack of verioning
19:56:50 <ksf> @vixen, you're a nice girl, don't listen to them
19:56:50 <lambdabot> do i seem  un-feminine to you?
19:56:52 <Olathe> Who is upstream ?
19:57:07 <ksf> see, now she's got an existential crisis, again.
19:57:08 <sjanssen> Olathe: the maintainers of binary, kolmodin_, dons et al
19:57:11 <SamB> the poeple who already broke her once
19:57:12 <Olathe> Ahh.
19:57:13 <ddarius> Olathe: That solution is very well known.
19:57:17 <ddarius> (and discussed)
19:57:18 <SamB> ksf: quick! add more foralls!
19:57:23 <Olathe> Which solution ?
19:57:35 <sjanssen> Olathe: if you want different behavior, you'll just have to avoid the Binary instance for []
19:57:39 <SamB> ddarius: what about the versioning ?
19:57:39 <ddarius> SamB: So that she'll have a universal crisis as well?
19:58:04 <SamB> ddarius: I meant in the appropriate places to solve the existential one
19:58:20 <ksf> @vixen, forall a. #hasell a => a `loves` vixen
19:58:20 <lambdabot> i am a bit of a vixen :)
19:58:22 <ddarius> Olathe: Chunking the list instance of Binary.
19:58:28 <Olathe> Oh.
20:00:19 <Gracenotes> @vixen How do you feel about being a tree?
20:00:19 <lambdabot> maybe. do you?
20:00:22 <mmorrow> Olathe: looks like you need to write your own binary lib :)
20:00:33 <Gracenotes> @vixen sometimes
20:00:33 <lambdabot> why not always?
20:00:50 <Olathe> Yes, I'm thinking of that.
20:01:01 <Olathe> A nice way to avoid backwards compatibility: rename the library.
20:01:44 <sjanssen> Olathe: don't go so far as to rename the library -- just use a different class
20:01:48 <mmorrow> and hack it relentlessly :)
20:02:18 <sjanssen> it would require just a little boilerplate to use the Binary instances you like, while giving you all the flexibility you need
20:02:18 <SamB> yeah, writing another library using the fundamental functions from Binary should work fine
20:02:25 <Olathe> With chunking and using Integer as the default length type for stuff, you avoid lots of forward compatibility problems, I think.
20:03:05 <Gracenotes> @poll-list
20:03:05 <lambdabot> ["logoVotingMethod"]
20:03:23 <Olathe> SamB: That sounds decent.
20:03:31 <Gracenotes> @poll-show logoVotingMethod
20:03:31 <lambdabot> ["Schulze"]
20:03:35 <Gracenotes> ..
20:03:56 <Gracenotes> @poll-result logoVotingMethod
20:03:56 <lambdabot> Poll results for logoVotingMethod (Open): Schulze=1
20:03:58 <SamB> Olathe: of course, check Hackage to make sure nobody already wrote the one you want
20:03:58 <Olathe> Where has chunking been discussed before ?
20:04:05 <Olathe> Ahh, they might have.
20:04:15 <Olathe> I want to see if there are better ideas for chunking than I hav.
20:04:24 <mmorrow> Olathe: it may have been discussed, but it's surely unimplemented in the existing lib
20:04:27 <SamB> there are a lot of binary libraries on hackage
20:04:35 <SamB> mmorrow: well, in THAT one
20:04:47 <mmorrow> SamB: yes, binary in particular
20:04:55 <SamB> mmorrow: grep hackage for binary sometime ;-)
20:05:10 <ddarius> @google site:haskell.org inurl:pipermail "Data.Binary" "lazy list"
20:05:11 <lambdabot> No Result Found.
20:05:25 <mmorrow> SamB: i'm sure that it's implemented many times over in different places
20:05:29 <SamB> @google site:haskell.org inurl:pipermail binary "lazy list"
20:05:30 <lambdabot> No Result Found.
20:05:34 <SamB> @google site:haskell.org inurl:pipermail binary lazy
20:05:35 <lambdabot> No Result Found.
20:05:41 <SamB> @google site:haskell.org binary lazy
20:05:42 <lambdabot> No Result Found.
20:05:53 <mmorrow> but if i'm going to use a non-standard pkg for something, i'd much prefer that it be mine
20:05:55 <SamB> not working, is it ?
20:05:59 <ddarius> http://www.haskell.org/pipermail/haskell-cafe/2007-November/034755.html
20:06:14 <Gracenotes> what's $(plugin "Name")?
20:06:29 <pumpkin> TH?
20:06:35 <mmorrow> Gracenotes: it's a template-haskell splice
20:06:35 <ddarius> SamB: It works, there's just some issue lambdabot has sometimes, but I'm not sure what it is.
20:06:52 <Gracenotes> mmorrow: ah. Is it necessary for the module system to work?
20:06:53 <blasdelf> @pl \a b -> c $ ((+) . d . e f) a b
20:06:53 <lambdabot> (c .) . (+) . d . e f
20:07:04 <Olathe> ddarius: Ahh, thanks.
20:07:20 <ddarius> Olathe: There are almost certainly other instances of it being discussed.
20:07:46 <mmorrow> Gracenotes: the function plugin generates the necessary declarations for the plugin "Name" refered to by "\"Name\""
20:07:50 <ddarius> Olathe: One solution often brought up is to have a Lazy newtype to specifically request lazy behaviors.
20:08:00 <mmorrow> and $(....) splices that code into that module
20:08:36 <SamB> ddarius: maybe it's lispy's fault ?
20:08:43 <MexiNerd> When an Asian woman has a baby with a Negro, she is closer related DNA-wise to the Mexican or White kid next door than to her own shitskin child, due to the fact that blacks have more DNA differences from everybody else.  Learn even more facts about nnniiiiggggers by joining Chimpout!  http://www.chimpout.com/forum/index.php  All races except for Negroids are welcome!
20:08:51 <pumpkin> o.O
20:08:54 <SamB> lispy: is lambdabot running into a firewall or something ?
20:09:08 <pumpkin> @where ops
20:09:08 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
20:09:17 --- mode: ChanServ set +o glguy
20:09:19 <ddarius> SamB: I don't see how that would block only some google results.
20:09:19 --- mode: glguy set +b *!*@ip72-207-23-205.sd.sd.cox.net
20:09:26 <SamB> MexiNerd: you do realize that the internet can't tell what color you are ?
20:09:38 <Debugger> I don't see that kind of crap often on freenode
20:09:45 <pumpkin> it happens a fair amount
20:09:54 <Gracenotes> SamB: one of the disadvantages of having a large channel
20:09:56 <SamB> I've seen that same shit once before at least
20:10:03 <Debugger> I used to IRC on undernet... was ten times as worse
20:10:45 <SamB> MexiNerd: why, you could be purple for all I know!
20:11:15 <lispy> SamB: what's up?
20:11:35 <SamB> lispy: I was just wondering about why lambdabot's googling wasn't working too well :-(
20:11:41 <SamB> @google site:haskell.org binary lazy
20:11:41 <lambdabot> No Result Found.
20:12:04 <SamB> lispy: and I heard you were hosting her
20:12:25 <lispy> SamB: aye, interesting.  I had to move to a new datacenter and I was able to ping out to google when I left it
20:12:32 <lispy> SamB: but maybe some setting is still not quite right
20:12:39 <SamB> ddarius said it works sometimes just now ...
20:12:56 <SamB> ddarius: what queries work?
20:13:32 <ddarius> SamB: I don't know what makes some work and others not.
20:13:35 <ddarius> @google haskell
20:13:36 <lambdabot> http://www.haskell.org/
20:13:36 <lambdabot> Title: Haskell - HaskellWiki
20:13:39 <mmorrow> i wouldn't call it "lazy" per se (as in only produced when demanded), but "chunked" (as in /online/)
20:13:49 <Gracenotes> @instances Quasi
20:13:50 <lambdabot> Couldn't find class `Quasi'. Try @instances-importing
20:13:54 <SamB> I meant "give some examples of ones that work"
20:14:19 <SamB> @insances-importing Language.Haskell.TH Quasi
20:14:19 <lambdabot> Couldn't find class `Quasi'. Try @instances-importing
20:14:26 <SamB> @hoogle TH
20:14:26 <lambdabot> module Language.Haskell.TH
20:14:26 <lambdabot> Text.XHtml.Frameset th :: Html -> Html
20:14:26 <lambdabot> Text.XHtml.Strict th :: Html -> Html
20:14:32 <SamB> @insances-importing Language.Haskell.TH.Lib Quasi
20:14:33 <lambdabot> Couldn't find class `Quasi'. Try @instances-importing
20:14:35 <Gracenotes> hm. only IO..
20:14:39 <mmorrow> , src ''Quasi
20:14:39 <ddarius> @google site:haskell.org inurl:pipermail adjunction
20:14:40 <lambdabot> No Result Found.
20:14:41 <lunabot>  class (Monad m, Functor m) => Quasi m where
20:14:41 <lunabot>          qNewName :: String -> m Name
20:14:41 <lunabot>          qReport :: Bool -> String -> m ()
20:14:49 <mmorrow> ..
20:14:50 <Gracenotes> and Q.
20:14:52 <mmorrow> hmm
20:15:00 <SamB> Gracenotes: the real one is in GHC
20:15:01 <mmorrow> , unQ location
20:15:02 <lunabot>  Template Haskell error: Can't do `currentLocation' in the IO monad
20:15:02 <lunabot>  luna: user error (Template Haskell failure)
20:15:10 <mmorrow> , $(lift =<< unQ location)
20:15:11 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Q a'
20:15:13 <mmorrow> , $(lift =<< location)
20:15:15 <lunabot>  luna: No instance for (Language.Haskell.TH.Syntax.Lift
20:15:22 <mmorrow> , src ''Location
20:15:23 <lunabot>  luna: Not in scope: type constructor or class `Location'
20:15:24 <Gracenotes> SamB: what do you mean..? I'm looking through the GHC source at the moment
20:15:25 <mmorrow> , src ''Loc
20:15:27 <SamB> Gracenotes: the magic of dictionary passing makes it possible to use without loading it
20:15:28 <lunabot>  data Loc = Loc {loc_filename :: String,
20:15:28 <lunabot>                  loc_package :: String,
20:15:28 <lunabot>                  loc_module :: String,
20:15:31 <ddarius> @google site:haskell.org adjunction
20:15:32 <lambdabot> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Adjunction-HigherOrder.html
20:15:32 <lambdabot> Title: Control.Functor.Adjunction.HigherOrder
20:15:45 <roconnor> @type partition
20:15:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:15:53 <SamB> Gracenotes: grep for 'instance Quasi'
20:16:29 <allbery_b> @index Quasi
20:16:30 <lambdabot> Language.Haskell.TH.Syntax
20:16:35 <mmorrow> , $(let liftLoc loc = lift (fmap ($ loc) [loc_filename, loc_package, loc_module]) in liftLoc =<< location)
20:16:36 <lunabot>  ["<interactive>","main",":Interactive"]
20:16:38 <mmorrow> heh
20:16:55 <allbery_b> @instances-importing Language.Haskell.TH.Syntax Quasi
20:16:56 <lambdabot> IO, Q
20:16:56 <Gracenotes> SamB: again, all I can find is IO and Q...
20:17:02 <SamB> hmm
20:17:16 <SamB> oh, you need a .*
20:17:18 <Gracenotes> that's not all?
20:17:20 <mmorrow> and TcM
20:17:22 <Gracenotes> SamB: did that.
20:17:36 <SamB> % grep 'instance.*Quasi' -r compiler/
20:17:36 <SamB> compiler/hsSyn/HsPat.lhs:instance OutputableBndr id => Outputable (HsQuasiQuote id) where
20:17:36 <SamB> compiler/typecheck/TcSplice.lhs:  * The TcM monad is an instance of Quasi (see TcSplice), and it implements
20:17:36 <SamB> compiler/typecheck/TcSplice.lhs:To call runQ in the Tc monad, we need to make TcM an instance of Quasi:
20:17:36 <SamB> compiler/typecheck/TcSplice.lhs:instance TH.Quasi (IOEnv (Env TcGblEnv TcLclEnv)) where
20:17:41 <Gracenotes> besides 642:instance TH.Quasi (IOEnv (Env TcGblEnv TcLclEnv)) where
20:17:53 <Gracenotes> yeah... is that an important line? :\
20:18:10 <SamB> hmm, I guess it's 642, yes
20:18:36 <SamB> only in my file it's actually on line 727
20:18:54 <ddarius> It's within an order of magnitude, what more do you want?
20:19:29 <SamB> anyway, THAT is the instance that GHC uses to run your actual splices ;-)
20:19:50 <mmorrow> type TcM a = TcRn a
20:19:56 <mmorrow> type TcRn a = TcRnIf TcGblEnv TcLclEnv a
20:20:01 <mmorrow> type TcRnIf a b c = IOEnv (Env a b) c
20:20:03 <Gracenotes> I take it IOEnv, TcGlbEnv et al are pretty important?
20:20:15 <SamB> Gracenotes: no doubt they are!
20:20:19 <mmorrow> TcM = IOEnv (Env TcGblEnv TcLclEnv) a
20:20:20 <SamB> but why do you care ?
20:20:33 <mmorrow> newtype IOEnv env a = IOEnv.IOEnv (env -> IO a)
20:20:35 <dino-> I have a cabal question: I see that programs installed with cabal have /usr/local/share/doc/<appname>/LICENSE installed as well..
20:20:43 <dino-> Can I have additional things installed there?
20:20:44 <Gracenotes> just looking at the internals of TH. Probably not the best place to start learning, though.
20:20:50 <mmorrow> it's just a ReaderT IO specialized
20:20:56 <SamB> dino-: dunno!
20:21:04 <dino-> I mean, in a new project, can I have other dirs/files go in there with LICENSE
20:21:11 <mmorrow> Gracenotes: no way, it's the best way to start learning
20:21:40 <Gracenotes> looking at source is a difficult way to tell which functions are "important" ;)
20:21:49 <mmorrow> the source of Language.Haskell.TH.Syntax has a bunch of excellent comments
20:21:59 <dino-> I'm getting the impression this is not what data-files and data-dir is for.
20:21:59 <Gracenotes> mm, have that open
20:23:01 <mmorrow> Gracenotes: it'll give you insight into what's happening, but only hacking around with TH'll tell you what functions are important (like anything)
20:23:07 <Gracenotes> hm. It would be interesting to generate a graph of which functions call or use each other in a Haskell file
20:23:19 <Gracenotes> or a group of Haskell files
20:23:34 <SamB> dino-: probably not!
20:23:48 <SamB> dino-: I'm looking in the source actually ;-)
20:23:53 <SamB> you read the documentation
20:24:12 <mmorrow> Gracenotes: totally. you could do this with (1) haskell-src-exts, (2) for each of  Exp, Dec, .... => fvs :: _ -> [Name], and (3) your choice of graph lib
20:24:31 <mmorrow> you can do it with modules and imports as well
20:24:46 <mmorrow> and also data decls
20:24:48 <dino-> SamB: Well, bah!
20:24:55 <dino-> ty :)
20:24:56 <Gracenotes> @hackage haskell-src-exts
20:24:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-exts
20:25:35 <Gracenotes> decl(aration)s?
20:26:39 <mmorrow> yes, wrt type dependencies
20:26:54 <mmorrow> , src ''Exp
20:26:57 <lunabot>  data Exp = VarE Name
20:26:57 <lunabot>           | ConE Name
20:26:57 <lunabot>           | LitE Lit
20:27:14 <mmorrow> would have edges to [Name, Lit, ...]
20:27:31 <mmorrow> (..., Dec, Stmt, Pat, Type, ...)
20:28:06 <mmorrow> the dep graph for data decls is more interesting than that for modules (but not necessarily that for expressions) since it can have (and has many) cycles
20:29:17 <rwbarton> mmorrow: you don't need haskell-src-exts, you can do it from TH with reify, right?
20:29:34 <mmorrow> rwbarton: totally (for the data decls case)
20:29:45 <rwbarton> oh
20:29:47 <rwbarton> Right
20:29:54 <mmorrow> i actually have code to do this, am generating pretty pictures via graphviz to link to now
20:30:05 <rwbarton> Well, for modules you can run TH on the haskell-src-exts source.
20:30:16 <mmorrow> (i'm gonna include this code in haskell-src-meta soon)
20:30:34 <Olathe> Ahh, I see.
20:30:42 <mmorrow> rwbarton: i have code for modules too, but you need to parse them since TH doesn't know about imports/exports
20:30:45 <Gracenotes> cabal: cannot configure haskell-src-exts-0.4.6. It requires base >=4. lovely
20:30:59 <Olathe> The chunking and so on was, I think, in the internals, rather than the instances.
20:31:10 <Olathe> I could be wrong, though.
20:31:40 <mmorrow> (and a sweet program (comes with graphviz) is `tred' which computes the trasitive _reduction_ of a graph, which hugely cleans graphs up for viewing)
20:33:22 --- mode: glguy set -o glguy
20:33:39 <Olathe> Ahh, no, I was wrong.
20:34:24 <rwbarton> mmorrow: Ohh... I misread what you were doing (kind of).
20:35:10 <Gracenotes> any ideas about the base dependency? Do I need to update GHC, actually?
20:37:49 <mmorrow> rwbarton, Olathe: here are some graphs for data decls: http://moonpatio.com/graphs/
20:38:09 <mmorrow> (Type and Exp have a graph of just their SCC as well)
20:38:13 <roconnor> @type isNothing
20:38:14 <lambdabot> forall a. Maybe a -> Bool
20:38:19 <SamB> Gracenotes: oh, I has a patch
20:38:23 <SamB> what is your email ?
20:38:42 <mmorrow> oops, the SCC's also include any constructors directly mentioned in any type therein as well
20:38:47 <thom__> question, I am starting to "get" monads however they still seem a little complicated. Now I started reading about combining monads and my head is spinning. My question is at some point do monads start seeming "easy"?
20:38:52 <Gracenotes> wi ki gracenotes  at [gma] il.com
20:38:55 <mmorrow> (which is why [], (,), etc are in there)
20:39:10 <mmorrow> this one's pretty http://moonpatio.com/graphs/Exp_SCC.png
20:39:23 <dino-> ooo, UserHooks postInst
20:39:25 <dino-> I bet I can use that
20:39:37 <SamB> do I just take out all the spaces before the @ ?
20:39:37 <Gracenotes> SamB: eh, PM would have been better. >_> I don't think at times. I think updating GHC might be better, though
20:39:48 <erikc> hrm, is there an hpaste that works on 6.10?
20:39:50 <Gracenotes> yeah, everything except for the letters and .
20:39:55 <ddarius> thom__: Right when you stop viewing them as hard.
20:40:14 <mmorrow> i haven't done code for the callgraphs of expressions/functions yet but i want to
20:40:14 <Gracenotes> SamB: is the patch for the base problem?
20:40:21 <SamB> Gracenotes: yes!
20:40:29 <Gracenotes> okay :) I'd be glad to have it
20:40:48 <dino-> Or copyHook
20:40:51 <SamB> I sent it to the maintainer already, but that was only a few hours ago
20:40:53 <rwbarton> mmorrow: I wonder if you could label the edges with the constructor name(s) involved
20:41:09 <tehgeekmeister> trying to wrap my mind around how to implement a combinator like between from parsec, but where instead of a parser for the start and beginning, it accepts a list of parsers, and if the nth element matches on the left side, it's used to match on the right side, and if it doesn't match on the right side, the whole match fails
20:41:23 <SamB> Gracenotes: the repo is at http://code.haskell.org/HSP/haskell-src-exts if you don't know
20:41:24 <mmorrow> rwbarton: oh, sweet idea. i've been trying to think of a way to incorporate constructors.
20:41:30 <thom__> ddarius.... Wel the individual bits seem easy enough... struggling to put them all together at this point :)
20:41:35 <tehgeekmeister> can't figure out how to manage this with the monadic cruft in my way
20:41:37 <hackage> Uploaded to hackage: LslPlus 0.3.0
20:41:37 <tehgeekmeister> =P
20:42:13 <rwbarton> mmorrow: another possibility is to have nodes for both types and constructors
20:42:23 <rwbarton> mmorrow: and put edges from a type to a constructor, from a constructor to its fields
20:42:31 <rwbarton> mmorrow: that might get really complicated though
20:44:27 <Olathe> Does Data.Binary send uncomplete frames every so many milliseconds ?
20:44:34 <mmorrow> rwbarton: here's the code for the data decl graph gen http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1149
20:44:34 <rwbarton> mmorrow: are these the types from TH?
20:44:38 <mmorrow> yes
20:44:59 <mmorrow> reify is used to find all reachable types
20:45:05 <mmorrow> started from a supplied Name
20:45:08 <mmorrow> *starting
20:45:20 <Gracenotes> SamB: okay, thanks :)
20:45:59 <mmorrow> rwbarton: and it's run like
20:46:02 <mmorrow> ghci> toDepGraphDot "Exp_SCC" $(lift =<< tyConDepGraphSCCQ ''Exp)
20:46:05 <mmorrow> or
20:46:12 <mmorrow> ghci> toDepGraphDot "Exp" $(lift =<< tyConDepGraphQ ''Exp)
20:47:01 <rwbarton> mmorrow: there's something wrong with your SCC computation, because the graph in Exp_SCC.png is definitely not strongly connected
20:47:15 <sjanssen> Olathe: yes, it outputs when a buffer fills or when a 'flush' instruction is used
20:47:20 <mmorrow> yeah, i'm adding in addition to the SCC all direct types reachable
20:47:23 <rwbarton> mmorrow: actually, I guess it has the SCC plus all its immediate dependencies
20:47:27 <mmorrow> yes
20:47:52 <SamB> isn't that just the closure of dependency ?
20:48:32 <mmorrow> (i was doing this for (trying to thus far) figure out all the types i need to generate decls for a type to use KURE (on hackage))
20:48:50 <mmorrow> ("it" := the modified SCC)
20:48:55 <Gracenotes> how can haskell-src-exts and TH be used together?
20:49:13 <SamB> Gracenotes: hmm ?
20:49:17 <mmorrow> Gracenotes: the pkg haskell-src-meta on hackage has a (partial) translation haskell-src-exts -> TH
20:49:19 <Gracenotes> if at all, that is
20:49:31 <mmorrow> , parseExp "\\x -> x"
20:49:32 <lunabot>  Right (LamE [VarP x] (VarE x))
20:49:33 <Gracenotes> does TH have its own parser, then?
20:49:36 <mmorrow> no
20:49:41 <SamB> it's own AST
20:49:43 <Gracenotes> mm.
20:49:46 <Gracenotes> yeah.
20:50:02 <rwbarton> , CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) []]
20:50:03 <lunabot>  CaseE (LitE (StringL "foo")) [Match WildP (NormalB (LitE (StringL "bar"))...
20:50:07 <rwbarton> , ppr $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) []]
20:50:08 <lunabot>  luna: Not in scope: `ppr'
20:50:09 <mmorrow> haskell-src-meta uses haskell-src-exts' parser by translating the ASTs
20:50:24 <mmorrow> pprint or ppDoc
20:50:24 <rwbarton> how do I make it look like haskell source?
20:50:26 <rwbarton> , pprint $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) []]
20:50:27 <lunabot>  luna: Not in scope: `pprint'
20:50:30 <mmorrow> ppDoc
20:50:31 <rwbarton> , ppDoc $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) []]
20:50:32 <lunabot>  case "foo" of
20:50:32 <lunabot>      _ -> "bar"
20:50:34 <mmorrow> :)
20:51:04 <mmorrow> ppDoc = text . pprint . cleanNames
20:51:10 <rwbarton> , $( return $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) []] )
20:51:11 <lunabot>  "bar"
20:52:32 <rwbarton> , ppDoc $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) [Instance [] (AppT (ConT $ mkName "Foo") (ConT $ mkName "Bar"))]]
20:52:33 <lunabot>  luna: Not in scope: data constructor `Instance'
20:52:38 <ksf> do you know these kind of situations where you implemented code more naive than you planned, discover that it works as well as the non-naive version you actually planned, and don't know whether you should figure out why?
20:52:40 <rwbarton> , ppDoc $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) [InstanceD [] (AppT (ConT $ mkName "Foo") (ConT $ mkName "Bar"))]]
20:52:41 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Dec'
20:53:04 <rwbarton> , ppDoc $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) [InstanceD [] (AppT (ConT $ mkName "Foo") (ConT $ mkName "Bar")) []]]
20:53:05 <lunabot>  case "foo" of
20:53:05 <lunabot>      _ -> "bar"
20:53:05 <lunabot>          where instance Foo Bar
20:53:16 <rwbarton> , $( return $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) [InstanceD [] (AppT (ConT $ mkName "Foo") (ConT $ mkName "Bar")) []]] )
20:53:17 <lunabot>  luna: Illegal kind of declaration in where clause instance Foo Bar
20:53:46 <rwbarton> > case "foo" of _ -> "bar" where instance Foo Bar
20:53:47 <lambdabot>   <no location info>: parse error on input `instance'
20:54:05 <Olathe> Is there a do-nothing action ?
20:54:17 <Gracenotes> return ()?
20:54:32 <Olathe> That sometimes throws away previous actions, I think.
20:54:44 <Olathe> I'm not sure.
20:54:48 <mmorrow> rwbarton: ah, i forgot to paste the `Run' module: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1149#a1152
20:54:51 <Olathe> @src when
20:54:51 <lambdabot> when p s = if p then s else return ()
20:54:54 <sjanssen> Olathe: not usually
20:54:56 <Olathe> Hmm...
20:55:03 <Olathe> I suppose if when uses it, it's alright.
20:55:13 <rwbarton> Olathe: Proof by authority
20:55:16 <Olathe> Heheh
20:55:17 <Olathe> Yes.
20:55:51 <ksf> someone should have told me that one needs to run autoreconf on gtk2hs-darcs, not autoconf and automake
20:55:59 <Gracenotes> @src (>>)
20:55:59 <lambdabot> m >> k      = m >>= \_ -> k
20:56:57 <rwbarton> , return $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) []]
20:56:58 <lunabot>  luna: No instance for (GHC.Show.Show (m Language.Haskell.TH.Syntax.Exp))
20:57:33 <rwbarton> , [|2+2|]
20:57:34 <lunabot>  InfixE (Just (LitE (IntegerL 2))) (VarE +) (Just (LitE (IntegerL 2)))
20:58:26 <mmorrow> , (return $ CaseE (LitE (StringL "foo")) [Match WildP (NormalB $ LitE (StringL "bar")) []]) :: Q Exp
20:58:27 <lunabot>  CaseE (LitE (StringL "foo")) [Match WildP (NormalB (LitE (StringL "bar"))...
20:58:32 <djwonk> it seems like Haskell accepts [] as a list of lists (e.g. [[a]]).  I don't understand. why?
20:58:34 <rwbarton> ah right
20:58:41 <djwonk> g :: [[a]] -> Bool
20:58:45 <mmorrow> @type [] :: [[]]
20:58:46 <lambdabot>     `[]' is not applied to enough type arguments
20:58:46 <lambdabot>     Expected kind `*', but `[]' has kind `* -> *'
20:58:46 <lambdabot>     In the type `[[]]'
20:58:49 <mmorrow> @type [] :: [[a]]
20:58:50 <lambdabot> forall a. [[a]]
20:58:53 <djwonk> g _ = True
20:58:58 <ddarius> djahandarie: It's the empty list of lists.
20:59:03 <mmorrow> @type [[]] :: [[a]]
20:59:04 <lambdabot> forall a. [[a]]
20:59:06 <ksf> djwonk, why not?
20:59:12 <mmorrow> , [[],[[]]]
20:59:13 <lunabot>  [[],[[]]]
20:59:17 <ksf> you can also say Maybe Maybe Bool
20:59:18 <djwonk> ddarius: thanks, the empty list of lists
20:59:28 <ksf> Maybe (Maybe Bool) , that is.
20:59:37 <djwonk> ksf: well, one view is that [] is a list, but not a list of lists
20:59:47 <Gracenotes> > [ [], [[]], [[[]]], [[[[]]]] ]
20:59:48 <lambdabot>   [[],[[]],[[[]]],[[[[]]]]]
20:59:49 <ksf> it's a list of anything...
21:00:12 <Gracenotes> @type [ [], [[]], [[[]]], [[[[]]]] ]
21:00:13 <lambdabot> forall a. [[[[[a]]]]]
21:00:18 <ksf> :t Just Nothing
21:00:19 <lambdabot> forall a. Maybe (Maybe a)
21:00:28 <mmorrow> <rwbarton> mmorrow: another possibility is to have nodes for both types and constructors
21:00:28 <mmorrow> <rwbarton> mmorrow: and put edges from a type to a constructor, from a constructor to its fields
21:01:06 <mmorrow> yeah totally, i was thinking of having two subgraphs, then edges between the two mapping between cons and types the cons and the types
21:01:33 <djwonk> ksf: i suppose i could make a type for a list of at least one non-empty list?
21:02:10 <ksf> that's [[]]
21:02:25 <ksf> but [] is a valid member, of course, as is [[],[]]
21:02:32 <mmorrow> another thing that'd be really cool is, using how graphviz can output images+html imagemaps, put links to other such pages in the imagemaps and you could interactively walk the graph of whatever
21:02:44 <ksf> ah wait... nope, non-empty lists aren't that simple.
21:02:55 <mmorrow> (walk between different views with that given node as focus (or something))
21:03:07 <djwonk> ksf: yeah, i'm missing something here
21:03:46 <ksf> it's just how the standard lists work, they can be anywhere in size from 0 to infinity.
21:04:14 <Gracenotes> If you have [], then it's always of type [a]. Of course, a could be a [b], so [] :: [[b]]
21:04:16 <ksf> if you want to add contstraints, you either have to do run-time checks or code up your own list type.
21:05:18 <ksf> but then, maybe what you want is just as simple as (a,[a]) or something isomorphic.
21:05:30 <djwonk> Gracenotes, ksf: thanks
21:06:51 * ksf can't believe he's actually compiling gtk2hs for ghc 6.10
21:06:56 <ksf> ...successfully, so far.
21:08:06 <augustss> ksf: !!!
21:08:42 * ksf glances around innocently
21:08:50 <travisbrady> @undo do dc <- getDirectoryContents dd; return (length dc)
21:08:50 <lambdabot> getDirectoryContents dd >>= \ dc -> return (length dc)
21:09:12 <Olathe> Ahhh...
21:09:22 <augustss> @pl getDirectoryContents dd >>= \ dc -> return (length dc)
21:09:23 <lambdabot> length `fmap` getDirectoryContents dd
21:09:25 <Olathe> Data.Binary doesn't flush every so often.
21:09:49 <ksf> length <$> getDirectoryContents
21:10:19 <travisbrady> augustss: thank you, what is pl?
21:10:25 <ksf> ...conal has fixed me on an applicative-trip.
21:10:38 <ksf> @help pl
21:10:39 <lambdabot> pointless <expr>. Play with pointfree code.
21:10:41 <augustss> travisbrady: it changes an expression to point free form
21:10:48 <conal> :)
21:11:23 <tehgeekmeister> why does this function not work?  it's meant to parse any parser p in between matching parsers on either end
21:11:24 <tehgeekmeister> http://pastebin.com/d7258579c
21:11:42 <tehgeekmeister> i'll append the error i get
21:12:26 <tehgeekmeister> http://pastebin.com/d31d1c31
21:12:35 <tehgeekmeister> (new url for an append, apparently?)
21:13:16 <ksf> in other news, foldr'ing sections over lists is fun.
21:15:28 * ksf recompiles gtk2hs as he forgot to set the prefix, as usual.
21:15:30 <augustss> tehgeekmeister: doesn't notFollowedBy take a Char parser rather than a String parser?
21:16:13 <tehgeekmeister> augustss: notFollowedBy  :: Show tok => GenParser tok st tok -> GenParser tok st ()
21:16:22 <tehgeekmeister> doesn't look like it to me
21:16:37 <tehgeekmeister> but i don't understand parsec type signatures, they're confusing to me
21:16:41 <augustss> And you're using String as your tok type?
21:17:09 <rwbarton> mmorrow: haskell-src-meta doesn't build for me.  "Constructor `Hs.PatBind' should have 4 arguments, but has been given 5"
21:17:29 <tehgeekmeister> well, that's just testing it real quickly;; i'd like this to work for any parser p and any list of parsers xs
21:17:39 <mmorrow> rwbarton: looks like you don't have the newest haskell-src-exts
21:17:41 <rwbarton> mmorrow: on the plus side, you didn't actually use it.
21:17:50 <augustss> tehgeekmeister: Using the string combinator fixes the token type to Char, I think
21:17:53 <mmorrow> rwbarton: heh, i was wondering about that
21:18:24 <mmorrow> err, actually if you want to view the stuff from ghci you'll need the Lift instances in src-meta
21:18:34 <ksf> fsck
21:18:41 <augustss> tehgeekmeister: try [char '-', char '%'] as your list instead
21:18:42 <Gracenotes> :t lookup
21:18:43 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
21:18:50 <mmorrow> since you use the $(lift =<< tyConDepGraphQ ''Exp) trick
21:19:00 <ksf> the gtk2hs configure script is using my system-wide ghc, which seriously fucks things up.
21:19:20 <mmorrow> or else you get the infamous "can't do reify in the IO monad" error msg
21:19:29 <travisbrady> @undo do dc <- getDirectoryContents dataDir; return $ filter (\x -> takeExtension x == ".paste") dc
21:19:29 <lambdabot> getDirectoryContents dataDir >>= \ dc -> return $ filter (\ x -> takeExtension x == ".paste") dc
21:19:38 <augustss> ksf: so you've not really been compiling with 6.10
21:19:43 <blasdelf> @pl \x -> f $ x `mod` y
21:19:43 <lambdabot> f . (`mod` y)
21:20:04 <ksf> I did, instead of using 6.10.1.20090202
21:20:22 <augustss> ah
21:20:24 <Olathe> Is it possible to flush a ByteString every 100 ms or so ?
21:20:35 <mmorrow> flush?
21:20:43 <tehgeekmeister> augustss: no type error now, but the parser still doesn't work
21:20:44 <mmorrow> you mean a Handle?
21:21:23 <Olathe> Well, to flush the contents of a lazy ByteString to whatever it's writing to.
21:21:34 <Olathe> I'm not sure what a Handle is.
21:22:24 <Olathe> Using writeFile, for instance.
21:22:33 * ksf is seriously confused
21:22:35 <sjanssen> Olathe: no
21:22:43 <mmorrow> ah, since it's using unsafeInterleaveIO then probably not
21:22:49 <ksf> I actually managed to install ghc-pkg, but don't have ghc itself.
21:23:01 <sjanssen> mmorrow: writeFile doesn't use unsafeInterleaveIO
21:23:12 <mmorrow> oops, yeah true
21:23:26 <glguy> Olathe, writeFile is a oneshot deal
21:23:37 <Olathe> Ahh.
21:23:38 <glguy> there is no periodic flushing to do
21:23:42 <augustss> tehgeekmeister: you are aware that notFollowedBy doesn't consume any input?
21:23:51 <tehgeekmeister> augustss: don't really want it to
21:24:06 <Olathe> Is there a way to do periodic flushing using hPut or something ?
21:24:19 <tehgeekmeister> augustss: the problem is that without using notFollowedBy p and x can't be overlapping at all
21:24:22 <sjanssen> hPut will write all its data right away
21:24:27 <Olathe> Hmmm...
21:24:28 <tehgeekmeister> tehgeekmeister: i don't want that restriction
21:24:32 <mmorrow> err, well don't lazy bytestrings still need to use unsafeInterleaveIO though because of what they are?
21:24:35 <sjanssen> Olathe: but I suspect your question has nothing to do with IO and everything to do with Data.Binary
21:25:35 <Olathe> Well, yes, that's the immediate purpose.
21:25:52 <sjanssen> Olathe: if you want to get more frequent output from Put, you'll need to explicitly flush more often
21:26:35 <rwbarton> @src find
21:26:35 <lambdabot> find p          = listToMaybe . filter p
21:26:45 <rwbarton> mmorrow: ^^ is your "first"
21:26:48 * ksf does a make clean in ghc's source directory and reflects on the fact that ghc 6.10 is way slower than 6.8
21:26:56 <Olathe> So, you build a bytestring and then hPut it.
21:27:43 <mmorrow> rwbarton: haha, i didn't even know there was a `find'
21:27:46 <Olathe> Hmm....
21:27:52 <sjanssen> that will ensure that the entire ByteString will be output immediately, but it says nothing about when specific chunks of that ByteString will be output
21:27:54 <mmorrow> @index find
21:27:54 <lambdabot> Data.List
21:27:58 <Olathe> Sure.
21:28:38 <rwbarton> , reify (mkName "Maybe")
21:28:39 <lunabot>  luna: No instance for (GHC.Show.Show
21:28:45 * mmorrow wonders what else is hiding in Data.List he didn't know about
21:28:57 <Olathe> There must be some way of storing the unsent bytestring in state. Have one thread adding to it and another flushing it every so often.
21:29:06 <rwbarton> What does reify do if a name is both a type constructor and a data constructor?
21:29:08 <mmorrow> , show `fmap` reify (mkName "Maybe")
21:29:10 <lunabot>  Template Haskell error: Can't do `reify' in the IO monad
21:29:10 <lunabot>  luna: user error (Template Haskell failure)
21:29:14 <sjanssen> Olathe: the questions you're asking make me curious what you're trying to do with Data.Binary
21:29:15 <Olathe> Flushing and replacing it with a new bytestring, I mean.
21:29:18 <mmorrow> , $(lift =<< reify (mkName "Maybe"))
21:29:20 <lunabot>  TyConI (DataD [] Data.Maybe.Maybe [a_1627417675] [NormalC Data.Maybe.Noth...
21:29:24 <mmorrow> , $(lift =<< reify ''Name)
21:29:26 <lunabot>  TyConI (DataD [] Language.Haskell.TH.Syntax.Name [] [NormalC Language.Has...
21:29:27 <mmorrow> , $(lift =<< reify ''Maybe)
21:29:29 <lunabot>  TyConI (DataD [] Data.Maybe.Maybe [a_1627417679] [NormalC Data.Maybe.Noth...
21:29:37 <rwbarton> , $(lift =<< reify ''Reader)
21:29:38 <lunabot>  luna: Not in scope: type constructor or class `Reader'
21:29:42 <rwbarton> oh
21:29:43 <sjanssen> Olathe: the flush has to come from the function actually constructing the ByteString in the Put Monad
21:30:01 <mmorrow> ah yeah, so you need to use either ' or '' to distinguish the ones that are both types and datacons
21:30:10 <rwbarton> how does that work with mkName?
21:30:10 <mmorrow> , $(lift =<< reify ''())
21:30:12 <lunabot>  TyConI (DataD [] GHC.Unit.() [] [NormalC GHC.Unit.() []] [])
21:30:13 <mmorrow> , $(lift =<< reify '())
21:30:14 <lunabot>  DataConI GHC.Unit.() (ConT GHC.Unit.()) GHC.Unit.() (Fixity 9 InfixL)
21:30:26 <Gracenotes> > logBase 2 1627417679
21:30:27 <lambdabot>   30.59993742219918
21:30:34 <rwbarton> , $(lift =<< reify (mkName "()"))
21:30:36 <lunabot>  TyConI (DataD [] GHC.Unit.() [] [NormalC GHC.Unit.() []] [])
21:30:43 <conal> roconnor: ping
21:30:51 <mmorrow> i don't think there's a way to specify using just mkName (ghc apparently always will choose the tycon over the datacon)
21:31:11 <mmorrow> rwbarton: you'd have to manufacture the Name correctly if you built it manually
21:31:15 <mmorrow> , src ''Name
21:31:18 <Gracenotes> an interesting number..
21:31:18 <lunabot>  data Name = Name OccName NameFlavour
21:31:21 <mmorrow> , src ''NameFlavour
21:31:24 <lunabot>  data NameFlavour = NameS
21:31:24 <lunabot>                   | NameQ ModName
21:31:24 <lunabot>                   | NameU Int#
21:31:31 <Olathe> sjanssen: Could that function get its data from some sort of shared state ?
21:31:45 <rwbarton> mmorrow: hmm, OK.  it doesn't actually matter to me right now
21:31:50 <sjanssen> Olathe: possibly
21:32:14 <mmorrow>                  | NameU Int#
21:32:14 <mmorrow>                  | NameL Int#
21:32:14 <mmorrow>                  | NameG NameSpace PkgName ModName
21:32:20 <Olathe> sjanssen: Well, if it used a multithreaded queue, you could have one thread adding Put monad stuff and one thread adding flushes.
21:32:21 <sjanssen> Olathe: but the questions you ask don't entirely make sense, perhaps you should step back and approach the problem from another direction?
21:32:29 <Olathe> sjanssen: Maybe.
21:32:35 <mmorrow> , src ''ModName
21:32:35 <ksf> conal, if I do \e::Event a -> e `mappend` e, do I end up with the double amount of events, or is there some notion of equality? If yes, are also events that have already been fmapped to a different type equal?
21:32:37 <lunabot>  type ModName = PackedString
21:32:45 <mmorrow> , src ''NameSpace
21:32:48 <lunabot>  data NameSpace = VarName | DataName | TcClsName
21:32:57 <mmorrow> dang, we need a graph for Name
21:33:15 <mmorrow> actually, we need the dual type/cons graph
21:33:21 <Olathe> sjanssen: If I was doing this in some horrid language like Java, I'd use a multithreaded queue and a flushing thread.
21:33:33 <Olathe> sjanssen: There must be something like that in Haskell.
21:33:42 <conal> ksf: you'll get double occurences.  about the "If yes" part, i'm not sure "yes" to which question.
21:33:43 <pumpkin> Chan?
21:33:46 <sjanssen> Olathe: you can do something like this in Haskell, but you wouldn't be able to use Data.Binary any more, you'd have to rewrite it
21:33:46 <sbahra> Can't you do this with Chan, Olathe?
21:34:01 <Olathe> sjanssen: That would be fine, I think.
21:34:07 <Olathe> sbahra: I'm not sure.
21:34:11 <ksf> ...if there's no double occurences.
21:34:25 <conal> ksf: merging occurrences would (a) require Eq, and (b) create funny semantic discontinuities.
21:34:51 <sjanssen> Olathe: Data.Binary doesn't let you flush the buffer from an external thread for two reasons: thread syncrhonization is expensive, and Binary is supposed to have a referentially transparent interface
21:34:52 <sbahra> Olathe, I think so. :)
21:35:30 <Eridius> Can anyone help me with a cabal install problem? I'm trying to install gsl-random, which depends on the gsl library, which I've installed into /opt/local/lib/libgsl.0.dylib. However, when I install gsl-random after setting CFLAGS=-L/opt/local/lib, I can't use it because libgsl can't be found at runtime
21:35:34 * sbahra doesn't understand why Haskell doesn't have a library for simple mutual exclusion primitives. 
21:35:34 <Olathe> sbahra: Ahh, that looks nice :)
21:35:44 <mmorrow> Olathe: you could rewrite it to use Strict ByteStrings, and an oleg-iteratee interface
21:35:46 <sjanssen> Olathe: by the way, I'm still rather curious what sort of application you're writing :)
21:36:04 <sbahra> Something similar to MVar, except not something like get/put interface (read/write with no synch from software).
21:36:41 <sbahra> lock >> function_expecting_locked >> unlock
21:36:45 <mmorrow> which is really just a foldl where between every elem you'd write out the ByteString produced by the function passed to myFoldl for that elem
21:37:01 <sbahra> lock >>= function_expecting_locked >>= unlock
21:37:20 <mmorrow> err, well that'd be for reading
21:37:29 <mmorrow> for writing you'd have something like
21:37:32 * ksf just noticed that his examples didn't show duplicate events because the program terminated beforehand and isn't confused, anymore.
21:37:42 <Olathe> sjanssen: I was just thinking that you could easily get both slow lazy lists and 1 GB/sec on fast stuff without the programmer having to flush all the time.
21:37:46 <mmorrow> data Step m a = Done | Step a (m (Step m a))
21:38:15 <mmorrow> and you'd walk it until Done, writing out the `a' at each Step
21:38:18 <sbahra> mmorrow, why wouldn't the above be valid for writing? IO Lock
21:38:24 <Olathe> sjanssen: If you can fill the buffer in less than 100 ms, it gets sent nice and full and efficient. Otherwise, even slow stuff gets through efficiently without manual flushes.
21:38:37 <ksf> which means that I'm going to have to part with that wonderful confusing
21:38:41 <ksf> braidE f ss i = foldr g mzero ss
21:38:42 <ksf>     where g s = (`mappend` fmap (h s) i)
21:38:43 <ksf>           h s a = s (f a) a
21:38:52 <mmorrow> sbahra: i was thinking more that there'd be no explicit thing you're folding over
21:38:56 <mmorrow> when writing
21:39:04 <mmorrow> (while reading you're folding over the input)
21:39:05 <Eridius> oh ugh, nevermind. I solved it by downloading the source and editing the gsl-random.buildinfo file after the failed configure :/
21:39:33 <mmorrow> sbahra: so not that it wouldn't work, but just that that analogy wasn't exactly accurate for the writing part
21:39:39 <sjanssen> Olathe: yeah, binary's assumptions are mostly based on the idea that computation will be much faster than IO (and this is usually true)
21:39:51 <Olathe> Ahh.
21:39:57 <sjanssen> Olathe: but with laziness, you might have some hidden expensive thunks in the structure you're serializing
21:40:04 <Olathe> Yeah, that's true.
21:40:38 <sjanssen> the actual serialization will always be very cheap, and always faster than IO, but the time costs associated with the input could be anything
21:41:30 <Olathe> I was going to try to do distributed processing or something with Data.Binary, I think.
21:42:20 <mmorrow> sbahra: hmm, just to clarify, i was refering to my foldl/oleg comment and not your MVar/lock suggestion (i'm not clear on what exactly you were asking me about now that i think about it)
21:42:46 <sbahra> mmorrow, ah, ok :)
21:42:51 <mmorrow> heh, ok :)
21:42:53 <sbahra> I was not asking you.
21:42:53 <Olathe> I could just do flushes all the time, but the thing I like about Data.Binary is its promise of efficiency + simplicity.
21:42:56 <sbahra> Just thinking aloud.
21:43:09 <sbahra> Since I wanted a simple read/write synchronization primitive.
21:43:10 <mmorrow> ohh, i got confused for a second there
21:43:10 <Olathe> And flushes kind of ruin part of the simplicity.
21:43:15 <sbahra> I ended up using something ugly (Chan of MVars).
21:43:21 <sjanssen> Olathe: so I think you just need to rearrange your problem
21:43:29 <Olathe> Maybe.
21:44:28 <sjanssen> you've got one process outputting values, and you need to put those values in the most live fashion possible
21:44:49 <sjanssen> ideally outputting in chunks for efficiency where possible
21:44:55 <Olathe> Sure.
21:45:21 <sjanssen> I'd use two Haskell threads for this, communicating with a size-bounded queue
21:46:07 <sjanssen> have the data generating thread fully evaluate elements one by one, writing each to the shared queue
21:46:55 <sjanssen> have another thread that does non-blocking reads on the queue, serializes the elements it finds, writes that data to a Handle and repeats
21:47:46 <Olathe> How does it know how long to wait between reads ?
21:47:52 <Olathe> Or does it just keep cycling ?
21:47:57 <glguy> non-blocking reads?
21:48:01 <Olathe> Yeah.
21:48:02 <sjanssen> it shouldn't wait at all
21:48:04 <Olathe> Ahh.
21:48:22 <sjanssen> but perhaps block for X time units when there are no elements in the queue
21:48:36 <Olathe> Are there any queues that have blockForAtMostNSeconds ?
21:48:42 <kyagrd> Hi, has anyone tried out typing (1+n) in the a type argument of GADT definition?
21:48:47 <sjanssen> nah, but it's all easy to write with STM
21:48:52 <Olathe> Ahh.
21:49:25 <kyagrd> I wasn't expecting this to work but it just works with the magical extension -fglasgow-exts :)
21:49:28 <Olathe> I don't mind doing that, but my concern is that by constantly doing nonblocking reads, I'll max out the processor.
21:49:37 <__nfw> Hey guy, sorry to interrupt
21:49:39 <__nfw> guys*
21:49:44 <__nfw> I have a quick Haskell q
21:50:00 <__nfw> I'm trying to implement a drop function
21:50:04 <sjanssen> Olathe: well, your Handle will probably become saturated before that happens
21:50:23 <kyagrd> Drop function is defined in the prelude and the source is available online at haskell.org
21:50:28 <conal> ping Axman6
21:50:29 <sjanssen> remember that IO will block when the operating system buffer associated with that resource is full
21:50:37 <__nfw> myDrop :: Int -> [a] -> [a]
21:50:37 <__nfw> myDrop 0 [x] = [x]
21:50:37 <__nfw> myDrop 1 (x:xs) = xs
21:50:37 <__nfw> myDrop a (x:xs) = myDrop (a-1) xs
21:50:49 <__nfw> The 0 line doesn't pattern match
21:50:52 <Olathe> I mean if the data producer is very slow, I'll be reading from the queue a lot.
21:50:54 <pumpkin> why put it in?
21:51:12 <glguy> __nfw, it would only match if the remainder of the list is a single element
21:51:21 <rwbarton> __nfw: Your 0 case only applies to a single-element list.  That's probably not what you want
21:51:22 <sjanssen> Olathe: yes, you will.  But don't you want that, in order to assure timely delivery of the available data?
21:51:26 <mmorrow> Olathe: you could also use System.Timeout + readChan
21:51:33 <Olathe> sjanssen: Sure, if it's the only way.
21:51:35 <glguy> __nfw, myDrop 0 xs = xs
21:51:44 <mmorrow> to get a "blockForAtMostNSeconds"
21:51:48 <conal> @tell Axman6 would you mind adding a second "t" to my last name ("Elliott") in your http://axman6.homeip.net/blog/2009/01/hello-world.html .  And thanks for the link.
21:51:48 <lambdabot> Consider it noted.
21:51:50 <__nfw> Thanks a lot
21:51:56 <__nfw> I appreciate it guys
21:51:58 <Olathe> mmorrow: Ahh, I'll look into that. Thanks :)
21:52:03 <glguy> __nfw, also, your "1" line isn't really necessary
21:52:06 <sjanssen> Olathe: and yes, you could add some more sophistication to the algorithm
21:52:15 <__nfw> why is that?
21:52:22 <__nfw> so xs will match a list?
21:52:25 <rwbarton> , fail "foo" :: Q Exp
21:52:26 <lunabot>  Template Haskell error: foo
21:52:26 <lunabot>  luna: user error (Q monad failure)
21:52:26 <__nfw> I don't need the []
21:52:28 <__nfw> ?
21:52:40 <glguy> __nfw, right, when you match with [] you are matching the elements of the list
21:52:59 <rwbarton> __nfw: [x] is a one-element list, just like [x,y] is a two-element list
21:53:02 <kyagrd> xs patterns covers all [], (_:_)
21:53:06 <sjanssen> perhaps have the reader block until X elements are available or N time units have passed, whichever comes first
21:53:22 <kyagrd> Consult the standard prelude definition it will help.
21:54:16 <kyagrd> Or, if you have Hutton's book "Programming in Haskell" it has a detailed explanation how to define recursive functions, and it acutally has the example for drop!!!
21:54:18 <augustss> Hmmm, so 1 is a type in ghc.
21:54:35 <ddarius> :k 1
21:54:36 <lambdabot> *
21:54:38 <rwbarton> with -XGenerics, right?
21:54:50 <rwbarton> hmm, with no extensions even
21:54:51 <dolio> :t () :: 1
21:54:52 <__nfw> Thanks a million guys, really helpful bunch here
21:54:52 <lambdabot>     Couldn't match expected type `Unit' against inferred type `()'
21:54:54 <sjanssen> augustss: yeah, it's left over from Generic Haskell or something like that
21:55:07 <kyagrd> Right, GHC.Genereics what is that and is it even documented?
21:55:24 <ddarius> It's documented in the user's manual where everything else is documented.
21:55:28 <rwbarton> This is my favorite:
21:55:29 <rwbarton> :k 2
21:55:30 <lambdabot> Only unit numeric type pattern is valid
21:55:42 <sjanssen> rwbarton: excellent error messag!
21:55:58 <augustss> Such a shame.  I want numeric types.
21:55:58 * sjanssen wants more numeric type literals!
21:55:59 <pumpkin> __nfw: please feel free to stick around!
21:56:09 <ksf_> ...now I'd like to know how to kick myself.
21:56:20 <pumpkin> ksf_: you can use /ns ghost
21:56:28 <pumpkin> if you registered your nick
21:56:40 <sbahra> ksf_, /msg nickserv ghost <your password>
21:56:46 <sbahra> err
21:56:50 <sbahra> ksf_, /msg nickserv ghost ksf <your password>
21:57:00 <mmorrow> yeah, numeric type literals would rock
21:57:13 <sjanssen> augustss: I wonder if we would see more use of tricks like statically bounded arrays with a nicer syntax
21:57:31 <pumpkin> @seen dons
21:57:31 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
21:57:32 <sjanssen> Succ (Succ (Succ Zero)) -- just doesn't cut it
21:57:36 <augustss> sjanssen: I'd use them more.  They are ugly now.
21:57:38 <pumpkin> it Succs!
21:57:45 <mmorrow> instead of  S (S (S (S (S (S (S Nil)))))))) we could just say 7!
21:57:49 <augustss> sjanssen: I use decimal
21:57:54 <rwbarton> type-level has types like D7
21:57:56 <ksf> you don't even have to supply a password if you're already identified.
21:58:06 <sjanssen> augustss: even that isn't very good
21:58:09 <__nfw> pumpkin: thanks!
21:58:17 <augustss> sjanssen: No, it's still vey ugly
21:58:27 <sjanssen> augustss: it would also be nice if the compiler could special-case arithmetic on the type level numbers
21:58:48 <augustss> sjanssen: I've thought of adding numeric type literals to ghc, but I can't decide if I want to give them some meaning.
21:58:55 <sjanssen> type family n :+ m -- wired into the compiler
21:59:21 <rwbarton> of course linking against type-level gives you a 6 megabyte executable file full of information about all these D12345 types...
21:59:28 <mmorrow> hehe
21:59:50 <pumpkin> I thought the types didn't usually make it into the final executable?
22:00:12 <sjanssen> augustss: I think you'd want the types to be abstract, rather than exposing some specific binary/decimal/peano representation
22:00:13 <rwbarton> pumpkin: I think they might be instances
22:00:20 <augustss> sjanssen: just having uninterpreted literals doesn't allow you to write any interesting type level functions.  And it's too early to build something in
22:00:23 <pumpkin> ah
22:00:39 <ddarius> pumpkin: Type erasure is not as erasingy as the name might suggest.
22:00:57 <augustss> sjanssen: I need to add, subtract, compare, ...
22:01:00 <pumpkin> ah, interesting
22:01:07 <kyagrd> augustss: It is already built in and that's why I was surprised ... interpreting + ad a type variable of course !!!
22:01:11 <mmorrow> , ppDco `fmap` let ntype n = TupT [fmap (\c -> ConT (mkName ("_"++[c]))) (show n)] in ntype 112358
22:01:12 <lunabot>  luna: Not in scope: `ppDco'
22:01:13 <pumpkin> I have yet to disassemble ghc's output to see how it actually structures it
22:01:15 <mmorrow> , ppDoc `fmap` let ntype n = TupT [fmap (\c -> ConT (mkName ("_"++[c]))) (show n)] in ntype 112358
22:01:17 <lunabot>  luna: Not in scope: data constructor `TupT'
22:01:20 <mmorrow> , ppDoc `fmap` let ntype n = TupleT [fmap (\c -> ConT (mkName ("_"++[c]))) (show n)] in ntype 112358
22:01:22 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
22:01:23 <ddarius> pumpkin: An extreme case is Intensional Type Analysis where a "type erasure" semantics is little more than word-play.
22:01:23 <mmorrow> aww
22:01:30 <sjanssen> augustss: yes, of course.  Those would be type families wired into the compiler
22:01:51 <rwbarton> lots of symbols with names like typezmlevelzm0zi2zi2_DataziTypeLevelziNumziAliases_d2269_info
22:01:53 <sjanssen> (or perhaps written in normal Haskell source operating on an abstract representation)
22:02:09 <augustss> sjanssen: not having numbers be inductive in any way is a mistake, I think.  That's what we did in Bluespec.
22:04:12 <sjanssen> augustss: I suppose one could make the types appear inductive, while having a more clever implementation behind the scenes?
22:04:23 <pumpkin> preflex: zdec typezmlevelzm0zi2zi2_DataziTypeLevelziNumziAliases_d2269_info
22:04:23 <preflex>  type-level-0.2.2_Data.TypeLevel.Num.Aliases_d2269_info
22:04:33 <pumpkin> I've noticed that GHC's mangling isn't particularly interesting
22:04:43 <pumpkin> it seems to just stick zi in thte place of dots?
22:04:44 <mmorrow> , ppDoc (let ntype n = let xs = fmap (\c -> ConT (mkName ("_"++[c]))) (show n) in foldl AppT (TupleT (length xs)) xs in ntype 112358)
22:04:46 <lunabot>  (_1, _1, _2, _3, _5, _8)
22:05:07 <mmorrow> , ppDoc (let ntype n = let xs = fmap (\c -> ConT (mkName ("_"++[c]))) (show n) in ConT (mkName "Vec") `AppT` foldl AppT (TupleT (length xs)) xs in ntype 112358)
22:05:09 <lunabot>  Vec ((_1, _1, _2, _3, _5, _8))
22:05:13 <augustss> pumpkin: I'd be hard pressed to find mangling interesting in general ;)
22:05:20 <ddarius> pumpkin: Why do you want it to be "interesting"?
22:05:38 <rwbarton> mmorrow: I think there is TH code along these lines in type-level to generate all the aliases
22:05:57 <pumpkin> I never said I did :P I guess it's mildly more interesting than C's, but I'm used to c++ or objc's crazy stuf
22:06:05 <pumpkin> +f
22:06:31 <augustss> sjanssen: as soon as you start going down this road you can also ask if it's not better to just bite it and do dependent types instead
22:06:45 <mmorrow> doesn't C++ encode type info in the names via mangling (or something)?
22:06:50 <pumpkin> yeah
22:07:16 <Olathe> Ooh, STM timeout: http://hackage.haskell.org/packages/archive/control-timeout/0.1.2/doc/html/Control-Timeout.html#v:addTimeoutAtomic
22:07:26 <pumpkin> there are a few difference mangling schemes too, in case you thought it was too easy
22:07:29 <pumpkin> different
22:09:01 <rwbarton> , [|undefined :: 1|]
22:09:03 <lunabot>  luna: Number types (for generics) not (yet) handled by Template Haskell 1
22:09:16 <pumpkin> aw
22:09:34 <mmorrow> heh, i like the parenthetical clarifications
22:09:36 <kyagrd> you can allwas define your own QQ and handle that :)
22:10:59 <sjanssen> augustss: I think it's an extension that has quite a lot of bang for the buck, as it were
22:11:08 <sjanssen> augustss: it could even start as pure syntactic sugar
22:11:15 <mmorrow> it'd be nice if QQs also had declaration and type contexts in addition to pattern and expression
22:11:58 <augustss> sjanssen: I'd be inclined to make it syntactic sugar for something like type-level (the package) numbers.
22:11:59 <kyagrd> mmorrow: I thought of the same thing. Then it would be easier to try out some new ideas for type extension in a more lightweighted approach
22:12:02 <mmorrow> then you could  "module Foo where import Blah [$zomg| ....... (1000 lines) ....... |]"
22:12:23 <pumpkin> hah
22:12:25 <mmorrow> and if TH had a rep for imports/exports and modules....
22:12:33 <sjanssen> @type 1234 -- seems like the parsing work is already done in GHC
22:12:34 <lambdabot> forall t. (Num t) => t
22:12:35 <pumpkin> wouldn't 1000 lines never compile?
22:12:37 <mmorrow> (and there was a "module context" in QQs)
22:12:45 <mmorrow> pumpkin: haha, probably not
22:12:46 <sjanssen> @kind 1234
22:12:47 <lambdabot> Only unit numeric type pattern is valid
22:12:48 <sjanssen> (oops)
22:13:00 <mmorrow> pumpkin: which would be nice motivation for it to
22:13:29 <mmorrow> well, it'd eventually get there, unless you were just generating massive amounts of code
22:13:47 <pumpkin> isn't having a nonquadratic-space compiler already good enough motivation on its own?
22:14:00 <mmorrow> (like, your 1000 lines of QuasiQuoted code made 10000 lines for a single case expression or something)
22:14:07 <rwbarton> sjanssen: if we had a Num kind class, everyone could define their own overloaded numeric type literals :)
22:14:29 <Gracenotes> the ever-useful base 36, perhaps
22:15:13 <augustss> rwbarton: first we need kind variables :)
22:15:16 <mmorrow> kyagrd: totally
22:15:34 <pumpkin> what types will those kind variables have?
22:15:35 <pumpkin> metakind?
22:15:42 <mmorrow> Expression
22:15:50 <pumpkin> :(
22:15:51 <sjanssen> rwbarton: luckily type-level programming is practically untyped and type functions are open, so we can have any number of competing number representations!
22:15:54 <mmorrow> :)
22:16:04 <kyagrd> It seems that we should eventually infent something like *0, *1, *2, *3, ...
22:16:13 <augustss> pumpkin: we could start with a single kind, like BOX
22:16:16 <kyagrd> where * = *0
22:16:56 <augustss> pumpkin: single kind-kind, I mean
22:16:58 <sjanssen> what is a kind variable and what would I use it for?
22:17:16 <augustss> sjanssen: you already need them while doing kind inference
22:18:28 <augustss> And when we want polymorphic kinds...
22:18:42 <augustss> It's not often that I miss that, though
22:18:48 <Gracenotes> is there a way to stop the new ghci from saying "Loading package ghc-prim ... linking ... done." every time I start it? Was that a config option..?
22:19:20 <Eridius> Gracenotes: you don't like being told when it's linking in a library?
22:19:32 <sjanssen> oh, I would like to be able to declare new kinds
22:20:07 <sjanssen> "kind Peano = Zero | Succ Peano; type family (:+:) :: Peano -> Peano -> Peano"
22:20:32 <Gracenotes> well... I'm not sure why it's doing it now :) In general it's good, but it seems clear that base, ghc-prim etc. will be linked on startup
22:20:46 <sjanssen> augustss: okay, I now understand where kind variables would be useful
22:20:49 <augustss> sjanssen: absolutely!  But I think it's madness to introduce the whole machinery again one level up.  Just lift the existing one.
22:20:58 <Gracenotes> I suppose it's more of a feature than a bug, so meh.
22:21:36 <rwbarton> sjanssen: with this hypothetical "kind Peano = Zero | Succ Peano", I assume Zero and Succ become type constructors; does the Zero type have any values?
22:21:43 <augustss> Gracenotes: why is it good?  If all goes well I don't really care if it's loading libraries.
22:21:48 * sjanssen really ought to try a dependent language some time
22:21:50 <kyagrd> polymophic kinds are good, but there is a problem that type level programs are really like functional logic programs, but the value level programs are sequential.
22:21:52 <rwbarton> sjanssen: or do values all have types of kind *, and Peano /= * so the question is meaningless?
22:22:07 <sjanssen> rwbarton: I would say Zero should have no values
22:22:24 <kyagrd> There is a subtle semantic difference, say guarded pattern matching is not liklely to work in the type level programs :)
22:22:29 <augustss> rwbarton: you'd probably want Peano /= *
22:23:12 <sjanssen> rwbarton: yeah, Peano should definitely not be equal to *
22:23:26 <sjanssen> (but could it be a subkind?  Do subkinds make any sense?)
22:23:27 <rwbarton> Yeah, I like the situation described in my second question
22:23:57 <rwbarton> I assume since we don't have subtypes, we also wouldn't have subkinds
22:24:14 <augustss> Except that ghc already does have subkinds
22:24:23 <sjanssen> @kind (->)
22:24:24 <lambdabot> ?? -> ? -> *
22:24:31 <rwbarton> Well, yeah.  But that's kind of an implementation detail.
22:24:56 <augustss> rwbarton: umm, yes, but one that needs to be sorted out
22:25:19 <rwbarton> I'm happy to think about these questions in a language (like, say, Haskell :) without kinds like # and ? and so on
22:26:11 <augustss> But a kind for unboxed types is very useful
22:27:12 <augustss> Perhaps the right thing is to make -> overloaded.  So we need kind classes for kind level overloading!
22:28:25 <sjanssen> hmm
22:28:57 <sjanssen> is function application on an unboxed argument really the same as application on a regular value?
22:29:11 <mmorrow> -XOverlappingKindInstances
22:29:19 <rwbarton> Hmm, if I have kind Peano = Zero | Succ Peano, then I could write data Vec :: Peano -> * -> * where Empty :: Vec Zero a; Cons :: a -> Vec p a -> Vec (Succ p) a
22:29:20 <augustss> No, but it uses the same type syntax
22:29:26 <sjanssen> or does GHC just pretend that it is for convenience?
22:29:59 <augustss> sjanssen: well, what do you mean by "the same"?
22:30:45 <sjanssen> augustss: I'm not really sure
22:30:46 <augustss> You can treat many aspects of it in a similar way during code generation.
22:30:53 <augustss> But not all.
22:31:14 <augustss> So in some sense they are not the same.
22:31:56 <augustss> I think ghc's treatment of unboxed types is ugly.  They are second class citizens.
22:32:39 <augustss> I guess I want them to belong to *. :)
22:33:10 <sjanssen> also, does it make any sense for Int# and Double# to have the same kind?
22:33:45 <sjanssen> data X (a# :: #) b = X a b -- can't actually work, can it?
22:33:51 <augustss> sjanssen: well, they are similar.  But if you think the kind should reflect the size, then no.
22:34:07 <sjanssen> I suppose GHC has some restrictions on that sort of thing
22:36:29 <sjanssen> "The main restriction is that you can't pass a primitive value to a polymorphic function or store one in a polymorphic data type." from the manual
22:36:47 <augustss> Yes, and that sucks.
22:37:01 <augustss> It doesn't have to be that way.
22:38:48 <mmorrow> what level of the compiler would allowing that be handled at?
22:39:38 <dolio> j/lhc might not have that restriction.
22:40:21 <mmorrow> hmm, maybe the question i should be asking is what about how ghc does things necessitates this reqtriction
22:40:22 <dolio> Since you add unboxed types by adding kind constants in the pure type system.
22:41:04 <dons> wow, are you guys following what is happening in the happs world?
22:41:04 <lambdabot> dons: You have 6 new messages. '/msg lambdabot @messages' to read them.
22:41:15 <dons> things are moving very very quickly
22:41:18 <dons> http://www.reddit.com/r/haskell/comments/7ug41/mathew_elder_joins_patchtagcom_as_a_partner_the/c07frjk
22:41:41 <mmorrow> ah, so this is only at the type-checking level and a matter of how data is represented in memory?
22:41:52 <mmorrow> (or would it be at both)
22:42:18 <sjanssen> mmorrow: both, I think
22:43:00 <sjanssen> data X (a# :: #) = X a -- GHC can't allow this because different types for 'a#' will have different representations
22:43:14 <redditbot> Mathew Elder joins patch-tag.com as a partner: the Happstack startup rolls on!
22:44:05 <dolio> Oh, yeah, I should say that j/lhc might not have the restriction on polymorphic functions.
22:44:10 <dolio> I don't know how it implements datatypes.
22:44:23 <mmorrow> hmm
22:45:19 <dolio> But there's nothing wrong in a pure type system with something like (t : #) -> (t -> t -> t) -> t -> t
22:45:23 <dolio> If # is just another kind.
22:47:02 <sjanssen> it's hard to grasp how that could actually be compiled
22:47:25 <dolio> Probably generating different code for each type.
22:47:26 <mmorrow> everything with # would be strict (i think)
22:47:30 <sjanssen> would kind-polymorphic functions be specialized to specific kinds?
22:48:27 <sjanssen> (assuming that we give a different kind for each different representation)
22:48:44 <mmorrow> (it'd be sweet to have a polymorphic (+)/etc for #'s to hand unboxed doubles/etc)
22:49:06 <dolio> Well, kind polymorphism is potentially another matter.
22:49:47 <dolio> In the standard lambda cube setup I don't think you could do it, because there's no level above [].
22:49:47 <mmorrow> err, well i mean a (+') :: (Num# a) => (a::#) -> a -> a
22:50:36 <sjanssen> I think we need kind polymorphism, (->) makes no sense without it
22:51:14 <dolio> Well.
22:51:47 <dolio> By kind polymorphism I mean variables with sort [].
22:52:05 * mmorrow has to read up on kinds and pts's
22:52:05 <ddarius> sjanssen: Control.Category.Category could actually benefit from kind polymorphism.
22:52:23 <dolio> So, like, (k : []) (t : k) -> (t -> t -> t) -> t -> t
22:52:43 <dolio> That'd be able to be instantiated for kinds * and #.
22:52:51 <sjanssen> dolio: what should I read to understand what 'sort' and '[]' mean in this context?
22:52:54 <dolio> And then any particular type belonging to those kinds.
22:53:09 <dolio> [] (box) is the level above * and #.
22:53:26 <dolio> So, 2 : Int, Int : *, * : []
22:53:32 <mmorrow> oh, so [] is kinda like a single "kind variable"
22:53:38 <dolio> And 2# : Int#, Int# : #, # : []
22:53:48 <dolio> Presumably.
22:54:06 <ddarius> The lambda cube is rather restrictive.
22:54:09 <sjanssen> ah, I see
22:54:30 <dolio> But in the lambda cube there's no level above [], so you can't quantify over it like you can with * and such.
22:54:33 <wli> A type is a sort of values, a kind is a sort of types, a [] is a sort of kinds.
22:54:34 <mmorrow> and what is ? in ([] : ?)
22:54:37 <mmorrow> ?
22:55:19 <wli> Is that lambda cube restriction innate?
22:55:23 <_Jordan_> guys, mapping and filtering is making me giddy
22:55:23 <dolio> mmorrow: There isn't one in the lambda cube. It just cuts off, and you can't really talk about [].
22:55:41 <sjanssen> _Jordan_: great, welcome to Haskell!
22:55:45 <dolio> wli: There are systems (Coq, Agda, etc.) that have an infinite hierarchy.
22:55:54 <_Jordan_> :)
22:55:59 <mmorrow> i don't really dig the infinite hierarchy
22:56:01 <dolio> So, 2 : Int, Int : Set, Set : Set1, Set1 : Set2 ...
22:56:10 <wli> dolio: That sounds like a "no." ;)
22:56:20 <dolio> Or, perhaps even SetN : SetM for N < M.
22:56:46 <mmorrow> i feel like there could be some way to do things where ... something like how category their only needs "morphism"
22:56:51 <mmorrow> nothing else
22:56:59 <glguy> dolio, but Coq kind of works that out on its own, right?
22:57:04 <mmorrow> (functors and nats are morhisms)
22:57:04 <glguy> the interface is Set : Set
22:57:18 <dolio> Yeah, it hides the levels if it can, I think.
22:57:26 <dolio> Coq calls it Type, I think.
22:57:34 <dolio> Set is something else there.
22:57:45 <mmorrow> a morhism could be a natural trans of functors between the category of functors of natural trans of ....
22:57:46 <dolio> And they have Prop, too.
22:57:50 <wli> Stratified types are Whitehead & whoever -like things.
22:58:09 <mmorrow> ... morhisms from Z -> Z
22:58:13 <mmorrow> or whatever
22:58:16 <dolio> I haven't really studied Coq.
22:58:46 <mmorrow> gah, my 'p' key is sly
22:58:49 * wli can't get agda to install on gentoo.
22:58:53 <mmorrow> *morphisms
23:01:16 <wli> IIRC stratified type things have some strange, more general than expected method of set comprehension.
23:01:56 <mmorrow> or maybe a better way to say it is that the objects in a category could themselves be categories of arbitrary complexity, and the category you're "in" could be an object in another category embedded somewhere else (or even in your own category), but you can still use the same basic primitives to describe the relations between everything
23:02:52 <wli> Stratified types come closer to that than it sounds like they do.
23:03:34 <mmorrow> but they have a Type_0, which can't itself be a (Type_99 -> Type_4)
23:04:13 <mmorrow> i'm not really sure what i'm getting at exactly, just a vague notion of something i can't put my finger on
23:05:07 <wli> mmorrow: I think it looks sort of like polymorphism in the set comprehension, so there's only a constraint on the difference of the levels of hierarchy where the left and right sides could be instantiated vs. pinning them down to specific levels.
23:06:14 <mmorrow> wli: interesting, yeah i think that's part of it
23:07:13 <sjanssen> I'd like to try a dependently typed programming language, which one should I try?
23:08:12 <pumpkin> does dependent typing allow us to guarantee at compile time that array indices will always be in bounds, without having to put in a runtime check?
23:08:17 <pumpkin> or is that too much?
23:09:55 <ddarius> To the extent possible, you can do that.
23:10:17 <dolio> You obviously can't prove that runtime input satisfies that.
23:10:30 <dolio> But you can prove that your program properly checks the runtime input and such.
23:10:35 <pumpkin> ah
23:10:45 <pumpkin> that makes sense :)
23:10:50 <pumpkin> I was hoping for secret impossible awesomeness
23:13:03 <glguy> pumpkin, instead of runtime failure, your program will fail to compile
23:13:45 <ksf> sjanssen, agda.
23:14:25 <ksf> ...and you might want to take a look at http://www.cs.nott.ac.uk/~txa/publ/pisigma.pdf
23:15:11 <sjanssen> ksf: that's the one I arbitrarly chose when I saw the download instructions included 'darcs get' :)
23:15:34 <ksf> it compiles to haskell :)
23:15:50 <ksf> ...using a hell a lot of unsafeCoerce's.
23:16:04 <dons> here's a test.
23:16:14 <dons> how well do you know your haskell web frameworks, guys?
23:16:22 <dons> how many haskell web frameworks can you name....
23:16:33 <dons> 2? 4?
23:16:35 <ksf> "no, really, you may cast from Int to Nat here, I already proved it"
23:16:42 <dons> 6?
23:16:52 <pumpkin> dons: all of them, cause I just read your post :P
23:16:53 <dons> anyone want to try to name 6 haskell web frameworks?
23:17:00 <dons> > 6 ?
23:17:00 <pumpkin> so /me stays out of it
23:17:00 <lambdabot>   <no location info>: parse error on input `;'
23:17:05 <sjanssen> turbinado, happs, happstack
23:17:14 <ksf> wash
23:17:17 <dons> ok. 4.
23:17:27 <dons> i can think of 5 more...
23:17:38 <sjanssen> does fastcgi count?
23:17:41 <dons> 6 more?
23:17:43 <dons> 7 more!
23:17:51 <dons> fastcgi, sure. hpaste2 is written "in" it.
23:17:54 <glguy> fastcgi is not a "web framework"
23:18:03 <dons> its sort of the foundation of one branch of web apps
23:18:08 <dons> so i'll pay it.
23:18:08 <glguy> and I wrote hpaste2 in it :-p
23:18:11 <dons> still another 5 to go.
23:18:23 <Herald> hi all, im trying to write a function to generate the cartesian product of n lists
23:18:34 <dons> Herald: not a web framework? I'm disappointed :)
23:18:40 <dons> salvia...
23:18:45 <Herald> lol, no i dont know any sorry
23:18:48 <dons> perpubplat ...
23:18:54 <Herald> so to get from lists [a, b, c] [c, d, e] [f, g, h]
23:18:56 <dons> kibro ...
23:19:02 <dons> yesod ...
23:19:02 <Herald> to [acf, acg, ach, adf, adg, adh, aef, aeg, aeh, bcf, bcg, ..
23:19:08 <dons> ella ...
23:19:13 <dons> riviera!
23:19:18 <_Jordan_> is there a clean way of expressing "map with a limit"? e.g. "map f over a max of n elements in list l"
23:19:39 <sjanssen> Herald: what are you stuck on?
23:19:40 <roconnor> > sequence [[a, b, c], [c, d, e], [f, g, h]]
23:19:41 <lambdabot>   [[a,c,f],[a,c,g],[a,c,h],[a,d,f],[a,d,g],[a,d,h],[a,e,f],[a,e,g],[a,e,h],[b...
23:19:45 <mmorrow> yhcjs (kinda if you stretch the def)
23:19:46 <earthy> jordan: map f . take n
23:19:50 <sjanssen> _Jordan_: take
23:20:02 <_Jordan_> thanks!
23:20:16 <Herald> i want to be able to get the cartesian for any number of lists
23:20:25 <pumpkin> Herald: that does it
23:20:29 <roconnor> > sequence [[a, b, c], [c, d, e], [f, g, h]]
23:20:30 <lambdabot>   [[a,c,f],[a,c,g],[a,c,h],[a,d,f],[a,d,g],[a,d,h],[a,e,f],[a,e,g],[a,e,h],[b...
23:20:46 <pumpkin> they don't have to be the same size either
23:20:50 <Herald> yeah, then cartesian from those
23:20:54 <roconnor> > sequence [[a, b, c], [c, d, e], [f, g]]
23:20:55 <lambdabot>   [[a,c,f],[a,c,g],[a,d,f],[a,d,g],[a,e,f],[a,e,g],[b,c,f],[b,c,g],[b,d,f],[b...
23:21:02 <pumpkin> Herald: ?
23:21:11 <dons> glguy: as wchogg pointed out in #happs, writing a haskell web apps is redeemable for one (1) job as a commercial functional programmer.
23:21:16 <pumpkin> > sequence . sequence $ [[a, b, c], [c, d, e], [f, g, h]]
23:21:17 <lambdabot>   [[a,a,a,a,a,a,a,a,a,b,b,b,b,b,b,b,b,b,c,c,c,c,c,c,c,c,c],[a,a,a,a,a,a,a,a,a...
23:21:18 <dons> worked for a few people now.
23:21:23 <Herald> sequence
23:21:27 <Herald> ive not heard of that function before
23:21:42 <roconnor> sequence does everything
23:21:53 <pumpkin> @src sequence
23:21:53 <lambdabot> sequence []     = return []
23:21:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:21:53 <lambdabot> --OR
23:21:53 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:21:54 <thetallguy> Herald: it seems to get overlooked in favor of mapM_
23:21:56 <mmorrow> , sequence [Just 99, Just 12]
23:21:59 <lunabot>  Just [99,12]
23:22:04 <mmorrow> , sequence [Just 99, Nothing]
23:22:05 <lunabot>  Nothing
23:22:14 <roconnor> > sequence [id, negate, succ] 7
23:22:15 <lambdabot>   [7,-7,8]
23:22:23 <mmorrow> @type sequence
23:22:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:22:43 <pumpkin> that last one is pretty awesome
23:29:46 * bos suffers a ghc crash while running quickcheck tests :-(
23:29:53 <pumpkin> aw
23:29:58 <pumpkin> on what?
23:32:21 * ksf grins
23:32:33 <ksf> I've got a working gtk frontend for yi on ghc 6.10
23:33:01 <kerm|t> for doing some accounting, where i won't easily notice bugs but i cant tolerate any, is haskell appropriate?
23:33:29 <ksf> ...though I like the vty one better.
23:33:31 <pumpkin> it's better than many alternatives
23:34:18 <pumpkin> kerm|t: it's not easy bein green, eh
23:37:02 <Herald> Instance of Num [[[Int]]] required for definition
23:37:06 <Herald> never understood that error
23:37:30 <pumpkin> you using hugs?
23:37:33 <Herald> yeah
23:37:50 <pumpkin> it means you're treating a list of lists of lists as a number
23:37:51 <ksf> It's telling you that a 3d-list of Ints isn't a number.
23:38:01 <pumpkin> adding it, subtracting it, taking its absolute value, or something
23:39:35 <Herald> http://pastebin.com/d52202ba7
23:39:39 <Herald> does that not make sense>
23:39:40 <Herald> ?
23:40:02 <ksf> if the typechecker says so, it doesn't.
23:40:20 <Herald> returning [] for [[[Int]]] is valid, right?
23:40:30 <sjanssen> Herald: yes
23:41:15 <ksf> try parens around iterCountDown-1
23:41:41 <Herald> haha, that was it
23:41:43 <Herald> thanks for that
23:42:13 <ksf> there's nothing binding more tightly than whitespace.
23:42:26 <ksf> I did'nt say that.
23:42:40 <ksf> don't listen to me, I'm confused.
23:42:54 <Herald> ah i see, it was trying to subtract one from [[[Int]]]
23:44:25 <ksf> I think you can leave out the other parens, though, : should bind loosely.
23:44:34 <ksf> I'm never shure of precedence, though.
23:45:37 <ktne> hello
23:45:53 <ktne> is there a programming language with an expressive type system that supports macros?
23:45:59 <pumpkin> sounds like haskell
23:46:03 <ktne> hmm
23:46:06 <ktne> i was not aware of that
23:46:17 <pumpkin> template haskell is the second bit
23:46:21 <Herald> common lisp ?
23:46:36 <ktne> can it take an arbitrary string as input for the macro?
23:46:39 <ksf> that'd be no type system.
23:46:50 <Herald> ah
23:47:29 <ksf> haskell templates are just haskell functions that generate code, they can take any input you can parse.
23:47:46 <ktne> i see
23:47:56 <ktne> but how is type checking done across that code?
23:48:22 <ksf> the template is checked, then run, then the resulting code is checked.
23:48:38 <ktne> i see
23:48:47 <ktne> thanks
23:49:29 <ksf> oleg once did a limited type system for TH, he likes to do that kind of stuff.
23:52:02 <int80_h> herro
23:52:12 <pumpkin> oherro2u
23:52:14 <_Jordan_> If I have a function taking several Ints, and I want to ensure they are all >= 0, is there a clean way besides using a guard and a bunch of &&'s?
23:52:35 <pumpkin> all (>=0) ints
23:52:51 <pumpkin> what do you do if they aren't all greater?
23:53:07 <ksf> Word32?
23:53:10 <int80_h> launch missles?
23:53:10 <_Jordan_> I just want it to error if any of them are negative
23:53:20 <int80_h> I liked my idea better
23:53:26 <ksf> I like mine.
23:53:29 <int80_h> that's what we have monads for, after all
23:53:30 <pumpkin> warmonger
23:53:36 <pumpkin> really?
23:53:38 <ksf> haskell really should have a Nat type.
23:53:39 <int80_h> missiles of love, of course
23:53:46 <pumpkin> no haz monad
23:54:14 <int80_h> ksf: what would it take to make your own?
23:54:45 <ksf> Word32 and the ilk for a start, dependent typing for the Real Thing
23:55:21 <ksf> ...you can, of course, use raw peano numbers, but I can't stand such stuff.
23:57:13 <_Jordan_> pumpkin: thanks!
