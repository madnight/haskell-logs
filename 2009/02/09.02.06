00:04:14 <mib_sq1v77> i'm not the one to be solving this, i make a hash of paths and privileges all the time.  but you can see readline in /home/.../.cabal/bin
00:04:33 <cizra> no
00:04:41 <cizra> readline isn't a program, it's a lib anyway
00:04:49 <mib_sq1v77> yeah
00:05:06 <mib_sq1v77> i mean the installed hackage package
00:05:13 <cizra> .cabal/lib/readline-1.0.1.0/ghc-6.10.1/libHSreadline-1.0.1.0.a
00:05:16 <cizra> this thing exists
00:06:16 <mib_sq1v77> i see right.  the only reason i was asking, is in ubuntu i've occasionally set up new versions of cabal install so i had a secret .cabal somewhere else and  me and the root
00:06:23 <mib_sq1v77> would fight over who got what
00:07:10 <mib_sq1v77> which can baffle since the ghc knows about all of them
00:07:42 <cizra> haha
00:07:52 <gio123> does there exist prolog with types?
00:08:33 <mib_sq1v77> so if i was just doing runhaskell, id get the home .cabal  and if i was sudo su guy, i'd get the others, but what if i wanted both...
00:08:55 <cizra> heheh. Well, I'm reinstalling the whole cabal thing now.
00:37:26 <jbapple> ﻿﻿Does anyone know how to make ghc's -auto-all provide useful names for instances of class functions?
00:41:04 <porges> jbapple: you could just add the declarations manually?
00:41:46 <jbapple> Well, I can't get that to work either, actually, but I only discovered that after battling the first problem.
00:41:52 <hackage> Uploaded to hackage: Wired 0.2.1
00:41:54 <jbapple> The problem is, I have many, many instances
00:42:22 <jbapple> I don't want to litter my code with profiling annotations because of an opaque name-mangler!
00:42:23 <porges> ah. :P
00:43:39 <Lemmih> jbapple: -auto-all does provide semi-intelligible names for class methods.
00:43:54 <redditbot> Mathew Elder joins patch-tag.com as a partner: the Happstack startup rolls on!
00:44:18 <jbapple> Lemmih: not for me, with 6.10.1
00:44:51 <jbapple> Lemmih: I have a class method named "syntax"
00:45:11 <jbapple> and I end up with a bunch of cost centers named things like "syntax_a2LJ"
00:45:20 <Lemmih> Exactly.
00:45:25 <jbapple> and "syntax_a2e7"
00:46:11 <jbapple> So, I know the problem is in syntax, because my whole program is in syntax!
00:46:12 <Lemmih> That surely is a semi-intelligible name (:
00:46:23 <jbapple> I need to know *which* instance
00:48:47 <jbapple> What I ended up doing is making every instance just dispatch to an appropriately named center
00:49:20 <jbapple> instance Syntax Block where syntax x = syntaxBlock x
00:49:39 <jbapple> *sad trombone sound*
00:52:01 <porges> Ok, so if fmap should "really" be (class (Category (↱), Category(↳)) ⇒ Functor f (↱) (↳) where fmap :: (x ↱ y) → (f x ↳ f y))
00:52:33 <porges> then presumable applicative's (<*>) should be f (x ↱ y) → (f x ↳ f y)
00:52:50 <porges> is pure then still (a → f a)
00:53:28 <porges> i think I need to check Applicative's laws or something ...
00:56:04 <porges> category-extras just has (<*>) as f(a->b)->f a->f b
01:01:15 <porges> Applicative can be defined as pure/<*> or unit/zip... category-extras has (Zip f) but it isn't based on their categorical functor type :/
01:14:05 <alexeevg> @users
01:14:06 <lambdabot> Maximum users seen in #haskell: 699, currently: 610 (87.3%), active: 10 (1.6%)
01:15:03 <hackybg> http://myspace.com/hackybg
01:15:38 <ivanm> hackybg: any particular reason for sharing your myspace page with us?
01:20:06 <hackybg> http://myspace.com/hackybg
01:20:08 <hackybg> http://myspace.com/hackybg
01:20:10 <hackybg> http://myspace.com/hackybg
01:21:25 <alexeevg> @seen Saizan
01:21:25 <lambdabot> I saw Saizan leaving #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell 2h 8m 31s ago, and .
01:23:10 <hugo___> hello
01:23:25 <alexeevg> hello, hugo__
01:32:57 <cads> hey, where can I find a casual expert on the freebsd license at the hour? should the #freebsd channel be my first stop?
01:34:00 <cads> I wrote a plain english paraphrase to the bsd license which the average person should be able to understand.
01:34:48 <pejo> cads, you need a lawyer to check that.
01:34:56 <ivanm> cads: freeBSD license == 2-Clause BSD license?
01:35:13 <cads> the 3 clause one
01:35:34 <cads> third clause about not using the names of the contributors in any kind of promotion campaign
01:35:57 <ivanm> cads: I beg to differ: http://www.freebsd.org/copyright/freebsd-license.html
01:36:05 <ivanm> that looks like the 2-Clause BSD license to me
01:36:29 <cads> hmm, I got mine from the wiki page: http://en.wikipedia.org/wiki/Bsd_license
01:36:45 <ivanm> cads: yeah, but that's not the freeBSD license
01:37:08 <ivanm> FreeBSD uses something similar to 2-Clause
01:37:17 <cads> ah, so it's that they use a different license
01:37:31 <cads> so asking in #freebsd would be silly
01:37:38 <ivanm> yup
01:37:43 <cads> well lemme put it up on paste first
01:37:48 * ivanm doesn't get the point of the third clause tbh
01:37:52 <cads> and i'll ask in a general help
01:38:06 <ivanm> cads: yeah, here's probably not the best place...
01:38:15 <ivanm> let's try to avoid the license wars flaring up again :p
01:39:06 <cads> I think they want to make sure that I don't put "ivanm developed it, ivanm says it's great!" on a billboard, if I've gotten some of your code and it's going to hurt people's computers :D
01:39:31 <ivanm> yeah, I get that... but the requirement and wording is a bit weird/stupid
01:39:40 <ivanm> IIRC, KDE won't accept 3-Clause, only 2-Clause
01:40:08 <cads> very interesting stuff I'm learning about these license thingies
01:40:48 <cads> been investigating since I read conal's request for help
01:40:51 <sior|oifig> good morning bos =)
01:41:06 <cads> top'o the maarnin' to ya!
01:42:00 <sior|oifig> you, too, cads =)
01:45:04 * ivanm doesn't understand why people are talking about "morning" when it's quite clearly night-time
01:45:06 <ivanm> ;-)
01:49:43 <cads> ooo, that's right.. the reason I'm up at this hour was not to investigate the bsd license, but because I couldn't sleep because I was wondering what a monoid is.
01:49:46 * cads wikifies
01:50:58 <ivanm> @src Monoid
01:50:59 <ivanm> ;-)
01:50:59 <lambdabot> class Monoid a where
01:50:59 <lambdabot>     mempty  :: a
01:50:59 <lambdabot>     mappend :: a -> a -> a
01:50:59 <lambdabot>     mconcat :: [a] -> a
01:51:11 <ivanm> cads: ^^ that's what a monoid is :p
01:51:23 <ivanm> @instances Monoid
01:51:26 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:51:42 <ivanm> > (mempty :: (a -> b)) 1
01:51:45 <lambdabot>       Could not deduce (Monoid b) from the context ()
01:51:45 <lambdabot>        arising from a u...
01:51:53 <ivanm> @src (a -> b) mempty
01:51:53 <cads> a monoid is something you can cons onto?
01:51:53 <lambdabot> Source not found. That's something I cannot allow to happen.
01:52:04 <ivanm> cads: yeah, something like that IIRC
01:52:24 <ivanm> > (mempty :: (a -> b))
01:52:26 <lambdabot>       Overlapping instances for Show (a -> b)
01:52:26 <lambdabot>        arising from a use of `s...
01:53:03 <cads> I'm sure the axiomatic definition will tell me more, but right now it sounds like at the simplest, a monoid is just a list
01:54:44 <porges> I don't like the names
01:54:57 <cads> okay, monoid is a set with an associative operator, and an identity element
01:54:58 <porges> call mappend ++ and mempty zero :)
01:55:21 <porges> zero ++ x = x, x ++ zero = x
01:55:29 <ivanm> porges: you can't call mappend (++), as it breaks the report
01:55:36 <porges> yeah I know
01:55:43 <ivanm> so it might be applicable for haskell'...
01:55:46 <porges> the report is  wrong ;)
01:55:51 <ivanm> @slap porges
01:55:52 <lambdabot> I'd rather not; porges looks rather dangerous.
01:55:53 <ivanm> how dare you!
01:55:54 <ivanm> :p
01:56:02 <ivanm> lambdabot: grrrr.....
01:56:10 <porges> good boy
01:56:15 * porges pats lambdabot
01:56:25 <ivanm> porges: lambdabot is female...
01:56:39 <porges> all IRC bots are eunuchs
01:56:46 <cads> nowai!
01:56:54 <ivanm> porges: no, lambdabot is femail
01:56:57 <ivanm> *female
01:57:10 <ivanm> check out her homepage
01:57:12 <ivanm> @where lambdabot
01:57:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:57:45 <cads> I didn't know it was a she... but I would be against the idea of gelding an IRC bot
01:58:14 <porges> it's more they start gelded and you need to ungeld them
01:58:35 <cads> in time, in time, give it 20 years
01:58:53 <porges> ungeld :: Bot Eunuch -> Either (Bot Boy) (Bot Girl)
02:00:02 <cads> So a simple monoid is the natural numbers under plain addition.
02:00:21 <cads> In fact, that's stronger than it needs to be in order to be a monoid, because addition is commutative
02:00:39 <porges> yes, but also under multiplication
02:00:47 <porges> so you need to indicate which one you want :)
02:00:48 <Snark> cads, think about "words" and concatenation
02:00:50 <cads> so lets see how the haskell interface to a monoid works for (N,+)
02:01:15 <cads> @src monoid
02:01:16 <lambdabot> Source not found. :(
02:01:26 <cads> @src Monoid
02:01:26 <lambdabot> class Monoid a where
02:01:27 <lambdabot>     mempty  :: a
02:01:27 <lambdabot>     mappend :: a -> a -> a
02:01:27 <lambdabot>     mconcat :: [a] -> a
02:02:09 <cads> mempty = 0, mappend = +, mconcat = foldl + 0, whee!
02:03:30 <cads> For Strings: mempty = "",  mappend = ++, mconcat = foldl ++ ""
02:03:40 <porges> > getSum $ mconcat $ map Sum [1..100]
02:03:42 <lambdabot>   5050
02:03:52 <porges> > getProduct $ mconcat $ map Product [1..100]
02:03:54 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
02:04:44 <cads> ... clearly i'm not grokking how type classes work yet! :D
02:05:04 <cads> > map Sum [1..100]
02:05:05 <lambdabot>   [Sum {getSum = 1},Sum {getSum = 2},Sum {getSum = 3},Sum {getSum = 4},Sum {g...
02:05:17 <porges> that's a newtype
02:05:38 <porges> because there are two possible definitions for (Num a) => Monoid a
02:05:53 <porges> we wrap Num in either Sum or Product
02:06:10 <cads> > mconcat (map Sum [1..100])
02:06:12 <lambdabot>   Sum {getSum = 5050}
02:06:28 <porges> see more on the page: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
02:07:08 <cads> yeah, I'm afraid I've got to figure out the motivation for that
02:08:08 <cads> getMoose (Moose {getMoose = "caboose"})
02:08:13 <cads> > getMoose (Moose {getMoose = "caboose"})
02:08:14 <lambdabot>   Not in scope: `getMoose'Not in scope: data constructor `Moose'Not in scope:...
02:08:46 <cads> sh sh sh! I don't need to know!
02:08:50 * cads reads
02:10:05 <porges> > mconcat $ map Last [Nothing,Just 1,Just 2, Nothing, Just 3, Nothing]
02:10:05 <cads> @type Sum
02:10:07 <lambdabot>   Last {getLast = Just 3}
02:10:07 <lambdabot> forall a. a -> Sum a
02:10:12 <porges> > mconcat $ map First [Nothing,Just 1,Just 2, Nothing, Just 3, Nothing]
02:10:14 <lambdabot>   First {getFirst = Just 1}
02:10:38 <porges> > mconcat $ map First [1,3,4,5]
02:10:39 <lambdabot>       No instance for (Num (Maybe a))
02:10:39 <lambdabot>        arising from the literal `1' at ...
02:10:48 <porges> aww :)
02:13:23 <cads> @type Just
02:13:25 <lambdabot> forall a. a -> Maybe a
02:13:26 <Peaker> @src First mappend
02:13:27 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:14:20 <cads> these things, Just, Sum, Product, First, Last... they have the same type as a monad
02:15:12 <cads> I remember now that a monad is a monoid with the extra few axioms, I think
02:16:07 <Peaker> cads: I think this is true in CT, but in Haskell Monoid in Monad are not that close - except every Monad also forms at least one Monoid
02:16:20 <Peaker> Every Applicative does too
02:16:40 <Peaker> cads: "same type as a monad" -- what do you mean? Monad is a type-class, not a type?
02:17:36 <cads> hrm
02:17:45 <cads> @type Maybe
02:17:47 <lambdabot> Not in scope: data constructor `Maybe'
02:17:55 <cads> o
02:18:15 <cads> @src Just
02:18:16 <lambdabot> Source not found. My brain just exploded
02:18:27 <doserj> @src Maybe
02:18:28 <lambdabot> data Maybe a = Nothing | Just a
02:19:09 <marcot> Hello, has anyone seen my mail to haskell-cafe about ./set --enable-library-profiling --disable-library-vanilla?
02:19:27 <marcot> I've tested here with ghc 6 6.8.2dfsg1-1 and it's working.
02:20:06 <cads> in   Maybe a = Nothing | Just a, what are Nothing and Just?
02:20:18 <marcot> cads: type constructors.
02:20:19 <doserj> data constructors
02:20:57 <doserj> Maybe is a type constructor, Nothing and Just are data constructors
02:21:03 <cads> are they defined elsewhere, or can they be used from nothing just as names?
02:21:30 <doserj> they are defined right there
02:22:10 <cads> so I can define Maybe a = Nada | Only a
02:22:30 <doserj> ignoring conflicting names, yes
02:23:27 <marcot> cads: do you speak portuguese?
02:24:13 <cads> sorry marcot, I was just using Nada as a synonym for nothing
02:24:26 <marcot> cads: ok.
02:24:46 <cads> does it also mean nothing in spanish?
02:24:54 <marcot> cads: I think yes.
02:25:09 <cads> are you portuguese?
02:25:56 <cads> I know it would be a more human hour over there
02:26:57 <marcot> cads: I'm brazilian.
02:27:14 <marcot> cads: here it's 8h27'
02:27:40 <Peaker> heh didn't know you could write unsafeCoerce using unsafePerformIO and IORefs
02:27:40 <hugo___1> :)
02:27:46 <hugo___1> im portuguese
02:28:00 * sior|oifig always finds reading foreign-language code interesting
02:28:14 <sior|oifig> it reminds me what a bias we have in using english-only keyword names
02:28:16 <cads> wow I did not know brazil went that far east; it is 5h here on the east coast of america
02:28:30 * sior|oifig should write programming languages that use only obscure languages for their keywords
02:28:41 <sior|oifig> like Elvish
02:29:00 <cads> sior|oifig: I've often wondered how little of a language we would need to learn in order to be able to read math papers in that language
02:29:29 <sior|oifig> cads, depends on the person, I guess, as I can't read maths papers in English =p
02:29:31 <cads> a lot of math being symbols that are international anyways
02:29:53 <ivanm> sior|oifig: use welsh, and keep the vowels for variables ;-)
02:31:15 <cads> did the welsh say "we'll devise a language where you never need to open your mouth fully" ?
02:31:16 <pejo> cads, a friend did his master thesis on continuous nowhere differentiable functions. Apparently a lot of the papers he "read" were in french, german and russian.
02:32:19 <cads> I don't believe it would be possible without knowing a little bit of french, german and russian :)
02:32:45 <pejo> cads, lots of babelfish I think, and a dictionary.
02:33:03 <cads> ooh, that's really good!
02:33:23 <cads> hadn't thought of that.. and your friend must be dedicated
02:33:32 <porges> sior|oifig: I had an idea to make Haskell completely language-neutral
02:33:52 <cads> porges: isn't it?
02:33:57 <mc__> May someone explain the ghc error to me? http://gist.github.com/59299 I always have problems understanding them
02:34:01 <porges> well, the standard libraries aren't
02:34:01 <Ferdirand> replace all keywords with operators ?
02:34:06 <pejo> cads, incredibly. He went on to do a phd in analysis. :-)
02:34:30 <porges> you could store everything in a non-human readable format so that everything has a unique identifier
02:34:38 <porges> you'd need to have a nice IDE for it :)
02:35:17 <cads> solve the problem of international illegibility by universal illegibility :D
02:35:20 <porges> it would make refactoring and so on much easier to implement as well though; rename an identifier and it's automagically got a new name everywhere,
02:35:43 <doserj> mc__: your class declaration say that evaluate con return any type b, but your instance declaration can only return a String
02:35:56 <cads> porges, such a database model of programs sounds appealing after watching the subtext videos
02:36:49 <porges> then you have (say in xml format) <constructor><names><n lang="fr">Juste</n><n lang="en">Just</n>...
02:37:03 <doserj> mc__: you probably want tor change your class declaration.
02:37:21 <porges> I actually wrote a small XML schema for it and an XSLT transform to transform it back to normal haskell code :P
02:37:28 <cads> you can create other "views" of your program database to allow visual/tactile programming
02:37:30 <porges> (for compilation)
02:37:57 <cads> porges: that sounds very interesting!
02:38:19 <cads> I could translate haskell code and send it to my romanian cousin
02:39:14 <cads> do you intend on publishing your work?
02:39:46 <cads> or is it just a personal toy?
02:39:51 <porges> just a toy
02:40:00 <porges> you'd need a good interface to editing first
02:40:11 <porges> and I'm not sure if I'm up to coding that in Haskell
02:40:47 <cads> I'd say just being able to transform a haskell program between languages would be neat
02:41:43 <cads> you'd just need a tiny app to translate it back to english as you compile
02:41:49 <porges> You could probably do fairly well just with some kind of lookup table
02:42:17 <porges> parse the code with GHC's api then just go over it replacing the identifiers with the 'equivalents' in the target language
02:43:21 <cads> even simpler than having to build a list of identifiers and doing it with straight text processing: much less error prone
02:43:33 <mc__> doserj: could I fix the problem with an additional instance declaration?
02:43:55 <porges> could even make a little command-line utility...
02:43:55 <porges> $ htranslate fr Thing.hs
02:43:55 <porges> htranslate> What should I call "Maybe" in French?
02:43:55 <porges> htranslate> What should I call "Just" in French?
02:43:58 <lunabot>  luna: Not in scope: `htranslate'
02:44:06 <porges> shush lunabot :P
02:44:08 <doserj> mc__: no. how would that instance declaration look like?
02:45:13 <osfameron> "Bof" and "Bien" ? ;-)
02:45:22 <boxbeat> how do i do partial in haskell?
02:45:27 <mc__> doserj: something like "instance Expression a where ..." ?
02:45:46 <cads> porges, I read about an obfuscator that basically rewrites a program's syntax tree to use gibberish names for variables and functions, then turns the tree back into sourcecode with as little formatting as possible :D
02:46:07 <cads> our application is similar to that, except it's useful
02:46:22 <doserj> mc__: how would you implement evaluate there?
02:47:01 <boxbeat> in python i can do f = lambda x,y,z = x*x+y*y+z*z, then import functools as ft; p = ft.partial(f, 10,20); p(30) -> 1400
02:47:18 <boxbeat> wait i see haskell does automaticing aprtial application?
02:47:24 <boxbeat> *Matrix> let f x y z = x*x+y*y+z*z
02:47:31 <mc__> doserj: the same whay it is implemented now
02:47:33 <Deewiant> > let f x y z = x*x + y*y + z*z; p = f 10 20 in p 30
02:47:34 <mc__> way*
02:47:35 <lambdabot>   1400
02:47:40 <boxbeat> *Matrix> let a = f 10 20;*Matrix> a 30
02:47:41 <boxbeat> let f x y z = x*x+y*y+z*z
02:47:41 <cads> porges: I might just have to kick my cousin's butt about haskell, and see if he and I can slap together a romanian haskell
02:47:45 <cads> I'd call it....
02:47:48 <cads> Romaskell!
02:48:11 <boxbeat> let f x y z = x*x+y*y+z*z in let p = 10 20 in p 30
02:48:13 <doserj> mc__: evaluate x = x has type "a -> a". The class declaration requires the type "a -> b". do you see the difference?
02:48:20 <cads> but in all seriousness, aren't such things done already, to promote the language in other countries?
02:48:23 <adrian_> boxbeat: yes, haskell does that all the time
02:48:43 <boxbeat> what is the difference between partial applicationa nd currying?
02:48:52 <adrian_> boxbeat: let partialPlus = (+4) in map partialPlus [1..10]
02:49:17 <mc__> doserj: yeah I see difference, but I thought  a -> b means that that type a and b *can* be different, not that they must be a different, so I'm wrong with that assumption I guess?
02:49:22 <porges> cads: there are very few languages without an english base
02:49:41 <boxbeat> > let f x y z = x*x+y*y+z*z in let p = 10 20 in p 30
02:49:41 <adrian_> boxbeat: currying turns functions with n arguments into functions with one argument
02:49:43 <lambdabot>       No instance for (Num (t -> t1 -> a))
02:49:43 <lambdabot>        arising from the literal `1...
02:49:50 <cads> boxbeat: in this case partial application is possible only because the functions in haskell are in fully curried form already
02:50:00 <doserj> mc__: yes, they *can* be different. But your implementation doesn't allow that they can be different.
02:50:48 <cognominal> when someone export a name Foo, it exports both the type and the constructor by that name if any?
02:51:04 <porges> cognominal: no
02:51:06 <Deewiant> no, only the type
02:51:10 <mc__> doserj: can I fix that by simply writing an explicit type signature for the implementation?
02:51:33 <cognominal> suppose I also want to export the constructor, how do I do it?
02:51:39 <doserj> mc__: no. evaluate x = x just does not have the type a -> b. Even if you claim it does.
02:51:49 <porges> cognominal: the syntax is module Thing (Foo(Foo,OtherConstructor))
02:51:57 <cognominal> thx
02:52:08 <cognominal> (haskell planet)++ # btw
02:52:11 <porges> or just Foo(..) to export all of them
02:52:34 <mc__> doserj: hm, guess I should re-read something about typeclasses :) thanks for your help!
02:52:50 <doserj> mc__: your problem is not with type classes. It is with types.
02:53:14 <cads> boxbeat: a function f::a->b->c->d   in most languages will be in the form  f::(aXbXc) -> d, which can be read as mapping a 3 position tuple (a,b,c) to d, hence most languages' function call form f(a,b,c)
02:53:38 <marcot> hugo___1: do you think a ##haskell-pt channel would be cool?
02:54:05 <cads> but in haskell we can read f as literally "the function that takes a value of type a, and returns a function of type (b->c) -> d
02:54:30 <doserj> b->(c->d)
02:54:54 <hugo___1> marcot: yes, i think we should make an effort to gather up the pt people that code haskell... i know some people who code in it, and some other who are very interested in it
02:55:03 <cads> yes, doserj, that was more accurate :D
02:55:20 <cads> boxbeat: are you following us?
02:55:33 <porges> mc__: if the "b" is fixed for each type "a", you can create the class with a functional dependency to show this
02:55:56 <porges> say you have (class Expression a b | a -> b where evaluate :: a -> b)
02:55:57 <marcot> HugoDaniel: So /j ##haskell-pt
02:56:26 <porges> that reads as (Expression is a class with two variables, where if you know a, you know b. (It also has a function to get from a to b))
02:56:41 <boxbeat> yes im following
02:57:57 <cads> boxbeat, you missed on thing I said earlier: partial application is possible in a trivial way because haskell functions are fully curried by default
02:58:35 <cads> in essence, a function only ever takes one argument
02:58:49 <marcot> Can someone include "New channel for portuguese speakers: ##haskell-pt" in topic?
02:59:16 <cads> it takes one argument and returns another function ready to take the next argument
02:59:53 <cads> or the final value of the function if all the arguments have been given
03:00:53 <mc__> porges: I'm with you so far. but what I want is a function which can either return the same type as it's parameter or a different one. is there a way to accomplish this or do I have to rethink everything?
03:00:58 <cads> boxbeat: in a language like python or ruby you can do partial application but it takes a little bit of jockeying, but here it's implicit
03:02:13 <porges> mc__: functions only return one type
03:02:39 <porges> mc__: but, say if you have two types and you could return either, you can use the Either datatype
03:03:18 <mc__> that might exactly be what I'm looking for, I'll have a look at it, thank you!
03:04:09 <porges> so like (f x = if x > 10 then Left "BIGGGGGGGG" else Right 12345)
03:04:22 <porges> this is f :: Int -> Either String Int
03:11:58 <enoksrd> I'm trying to make functions of type (Enum a, Bounded a => a -> a) instances of Eq by checking that they agree on all points of there domains
03:12:18 <enoksrd> but the compiler ghci complains and tells me some extensions to enable
03:12:27 <enoksrd> but then I get the same errors again
03:12:41 <enoksrd> anybody know how to make this work? (not useful, just for fun)
03:12:59 <pejo> enoksrd, sounds like ghci isn't picking up the extensions that you enabled. How did you enable them?
03:13:22 <enoksrd> I put a {-# LANGUAGE FlexibleInstances, FlexibleContexts #-} comment in my file
03:13:24 <enoksrd> then did :r
03:14:30 <enoksrd> pejo: oh, the comment wasn't at the top of the file, when I put it there I get different errors
03:14:37 <augustss_> @seen JoshTriplett
03:14:38 <lambdabot> I saw JoshTriplett leaving #haskell 8h 4m 39s ago, and .
03:15:49 <cognominal> in planet haskell, I don't see how I can get to older posts :(
03:16:56 <enoksrd> hmmm, tried adding TypeSynonymInstances as well (from the real world haskell book), still no luck
03:17:16 <enoksrd> anybody know if this can be made to work:
03:17:31 <enoksrd> instance Eq ((Bounded a, Enum a) => a -> a) where
03:17:34 <enoksrd> f == g = all [f x == g x | x <- [minBound .. maxBound]]
03:17:49 <porges> you've messed up the syntax, that's all
03:17:49 <Deewiant> that instance declaration looks weird
03:18:02 <Deewiant> you sure you don't want 'instance (Bounded a, Enum a) => Eq (a -> a) where'
03:18:07 <porges> should be instance (Eq a, Bounded a, Enum a) => Eq (a -> a)
03:18:23 <enoksrd> oh, ok, thanks
03:19:00 <porges> you'll also need FlexibleInstances
03:20:27 <enoksrd> (and my "all" should be "and")
03:22:41 <lilac> enoksrd: that instance doesn't do what you think it does, i suspect
03:23:05 <enoksrd> lilac: hmmm, yeah, now that it compiles, it still doesn't work
03:23:15 <lilac> enoksrd: it says "/all/ functions from 'a' to 'a' are instances of Eq, and it's a compile-time error if 'a' isn't an instance of Eq, Bounded and Enum"
03:23:50 <lilac> (note that this is not the same as saying "if a is an instance of Eq, Bounded and Enum, then a -> a is an instance of Eq)
03:23:55 <lilac> +"
03:24:09 <enoksrd> lilac: right, so two questions then
03:24:16 <enoksrd> 1. is there a way to say that instead?
03:24:22 <lilac> sadly not
03:24:40 <lilac> you can get pretty close by turning on -XOverlappingInstances and perhaps -XUndecidableInstances
03:25:22 <porges> instance (Eq a, Enum a, Bounded a) => Eq (a -> a) where (==) = (==) `on` (<$> [minBound..maxBound])
03:25:22 <enoksrd> 2. (question 2 just solved itself)
03:25:45 <lilac> porges: neat formulation :)
03:26:23 <enoksrd> @pl \f g -> and [f x == g x | x <- [minBound .. maxBound]]
03:26:23 <lambdabot> (and .) . flip flip [] . ((:) .) . (. ((<- [minBound..maxBound]) . (| x) . ($ x))) . (==) . ($ x)
03:26:43 <enoksrd> porges: hahaha, yeah, you win, lambdabot loses
03:26:52 <cads> porges, I've wondered before, why don't we see localized versions of programming languages where the keywords, especially those describing keywords, are translated for easier language comprehension for native speakers?
03:26:59 <porges> @let instance (Eq a, Enum a, Bounded a) => Eq (a -> a) where (==) = (==) `on` (<$> [minBound..maxBound])
03:26:59 <Deewiant> the @pl doesn't understand list comprehensions
03:27:00 <lambdabot>  Invalid declaration
03:27:08 <lilac> @pl \f g -> map f [minBound..maxBound] == map g [minBound..maxBound]
03:27:08 <lambdabot> (. flip map [minBound..maxBound]) . (==) . flip map [minBound..maxBound]
03:27:09 <osfameron> cads: because when it's done, it's horrible? ;-)
03:27:11 <osfameron> see also Excel
03:27:12 <Deewiant> @. pl undo \f g -> and [f x == g x | x <- [minBound .. maxBound]]
03:27:13 <lambdabot> flip flip [minBound..maxBound] . (and (=<<) .) . flip flip [] . ((flip . ((:) .)) .) . liftM2 (==)
03:27:15 <porges> @let instance (Eq a, Enum a, Bounded a) => Eq (a -> a) where (==) = (==) `on` (`fmap` [minBound..maxBound])
03:27:16 <lambdabot>  Invalid declaration
03:27:17 <cads> porges: replace second instance of keywords with idioms
03:27:40 <cads> osfameron: horrible for english readers?
03:27:52 <porges> cads: there's no demand because no one's really done it
03:27:54 <osfameron> cads: horrible for portability of the spreadsheet
03:28:10 <porges> i suspect that once it's done mainstreamly then people will want it more
03:28:18 <osfameron> what's more mainstream than Excel?
03:28:28 <osfameron> it's the most used functional programming language in the world, and real people use it.
03:28:42 <cads> eeeeh..
03:28:46 <porges> but as you note it wasn't implemented well :P
03:28:48 <SamB> TI basic ?
03:28:54 <enoksrd> @type <$>
03:28:55 <cads> it's a microsoft product
03:28:56 <lambdabot> parse error on input `<$>'
03:28:58 <SamB> er.
03:29:02 <SamB> well, not the basic bit.
03:29:04 <enoksrd> @type (<$>)
03:29:06 <osfameron> You go to the Spanish office and can't edit your work.  The Spanish come over and can't edit theirs (sure, they might know English better than you know Spanish, but they don't know what the functions are translated as)
03:29:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:29:07 <porges> enoksrd: <$> = fmap
03:29:12 <osfameron> (lingua francas)++
03:29:18 <SamB> but TI-calulatorese
03:29:31 <cads> osfameron: that sounds like a lingua-fracas :D
03:29:38 <osfameron> and with a programming language that can define functions, it's even worse
03:29:46 <osfameron> either you have hundreds of reserved words...
03:29:54 <porges> some interesting pages come up with a google searhc for "localized keywords"
03:30:06 <osfameron> or what do you do when someone in language X defined a function that's reserved in your translation?
03:30:23 <koala_man> what is it that makes excel a programming language, but not arithmetic expressions?
03:30:41 <porges> osfameron: that's why I said that names are stored merely as identifiers
03:30:45 <cads> porges: send me any link you find interesting. Someone is uploading on the network so the only thing it can handle for me is IRC :!
03:30:58 <porges> osfameron: you attach the names to the identifiers when you present it to the user
03:31:12 <osfameron> porges: and what happens when they've clashed with a user-defined function?
03:31:52 <porges> well first you'd tell the user when they define the function, and secondly we have namespaces to deal with such :)
03:32:02 <porges> you can always auto-qualify the names
03:32:15 <cads> well I wouldn't be thinking of converting existing codebases already coded with function names in language x, rather getting people that speak language x coding haskell
03:32:37 <porges> say they import Data.Map and Data.Set then the names could be automatically qualified to Map.contains and Set.contains
03:32:37 <cads> or coding at all
03:33:08 <porges> since to the computer Map.contains and Set.contains have numerical identifiers, it doesn't really matter except for presentation
03:35:03 <cads> osfameron: I think the interop issues could be handled by a simple layer that handles keyword name substitution in a syntax tree
03:35:49 <cads> I don't think that english is naturally better suited for keyword names than any other fairly modern language
03:36:15 <osfameron> cads: so if Data.Map is translated as "Data.Foo" in Spanish, and the original programmer has a custom module called "Data.Foo" what do you doo?
03:36:25 <osfameron> cads: well of course it's not
03:36:31 <osfameron> but it's a lingua franca
03:36:50 <SamB> a while back, it would have been latin
03:37:02 <SamB> which would probably be worse
03:37:06 <cads> osfameron: the original programmer would have learned to program haskell with Data.Foo
03:37:11 <osfameron> you've seen Lingua::Perligata? ;-)
03:37:38 <osfameron> cads: you're not getting me.  Data.Map and Data.Foo are used in the original program.  Then we translate it into Spanish.  Boom.
03:37:59 <cads> oh, translating
03:38:11 <cads> yeah that's a good point
03:38:37 <osfameron> anyway, nothing that can't be resolved and I'm sure it's a fun project.  Just not convinced it's useful or desirable in the real world.
03:38:55 <osfameron> which shouldn't stop you from playing with it if you think it'd be fun ;-)
03:39:06 <cads> we'd have to automatically rename the non-canonical english Data.Foo
03:39:33 <cads> yeah, I think it could help out people learning the language
03:39:50 <cads> also it would help my romanian
03:39:58 <cads> and lojban, if I did that ;)
03:40:36 <cads> I haven't heard of any romanian haskell programmers (well maybe one company)
03:40:41 <osfameron> thing is, what do you do with word-order / grammar etc.
03:41:42 <cads> well for one thing, with romanian I'm fairly confident that none of the keywords or functions in haskell are already romanian words
03:42:36 <cads> and I don't understand the question of word order, but for the grammer, the answer is you'd use it correctly?
03:43:07 <pejo> cads, having a multi language prelude will give lots of headaches. It means you can't read augustss blog posts and copy code from them because he would be using the swedish prelude.
03:43:14 <lilac> {-# LANGUAGE Romanian #-} ?
03:44:32 <cads> it's funny in ruby we say  Object.is_a?(:Array) to test if an object is a array (no way!)... but someone realized that was grammatically incorrect and wrote an is_an function for those cases :D
03:44:38 <SamB> speaking of automatic renaming, get a load of these type signatures: http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/E-Type.html#v%3AtvrInfo_s
03:45:11 <C-Keen> Can I use Language.C to generate a callgraph?
03:45:31 <SamB> pejo: I think augustss is too sensible to do that? also isn't his blog in English ?
03:45:48 <SamB> C-Keen: probably
03:46:22 <SamB> you'd need to write the code to turn the C ASTs into a call graph, though
03:46:25 <cads> lilac point out that it could be as simple as putting a tag in your sourcecode and having internationalization support in the compiler.
03:46:41 <SamB> and you wouldn't catch indirect calls
03:47:11 <pejo> SamB, he probably is, but my point still remains: it's one more thing that can go wrong, and it's already really really hard to program - we shouldn't make it harder.
03:47:18 <ivanm> matthew-_: ping!
03:47:21 <lilac> cads: of course, you can't really internationalize the first LANGUAGE pragma in your file that way, but I think tha't's probably acceptable
03:47:49 <idnar> pejo: just use a source code representation that doesn't directly contain any names
03:47:51 <lilac> ... or maybe you can? :)
03:48:09 <C-Keen> SamB: yeah indirect calls are a bit hard
03:48:09 <cads> lilac: I don't know enough about how source is parsed
03:48:27 <idnar> pejo: so when you read the code, you see Data.Foo; when I read it, I see Daten.Foo
03:48:30 <idnar> (or whatever)
03:48:47 <osfameron> just curry your ghc executable to have {-# LANGUAGE foo #-} already set
03:49:21 <cads> idnar: that suggestion made by porges is what got this conversation started
03:49:28 <SamB> pejo: yeah, I guess I'm just saying augustss is smart enough to know that it's a stupid idea ;-P
03:49:53 <cads> hehe
03:50:27 <cads> maybe stupid.. but definitely fun sounding
03:50:42 <cads> anyways.
03:51:24 <pejo> cads, Microsoft has already done this with VBA though, and it means that my script don't work on my coworkers machine, because we have different language packs installed.
03:51:27 <ivanm> @ask matthew-_ have you updated graphviz since september? if so, can I have a snapshot of the changes so I can apply my updates (which I haven't gotten around to yet :s ) ?
03:51:28 <lambdabot> Consider it noted.
03:51:47 <SamB> pejo: nasty!
03:53:08 <SamB> pejo: at least when they do this in Smalltalk, different images still run the same code ...
03:53:15 <cads> pejo: second mention of a microsoft programming product with terrible internationalization support. I can surmise that at least they try, eh? hah, even if they can't get it right
03:55:47 <cads> pejo, I might play around more with this
03:55:51 <inbuninbu> newbie question: in Parsec, 'Parser' does not keep track of any state at all, including how far it's read? Is this correct?
03:56:05 <cads> but first I'll ask some foreign non-coders what they think
03:56:19 <cads> hrm, not non-coders, even...
03:56:48 <cads> I'll ask my cousin, who is only just getting experienced with java
03:57:26 <Toxaris> inbuninbu: what do you mean? the execution of the Parser will keep track of the current position, but the Parser itself just describes what to parse, and does not do the parsing itself, kind of
03:57:47 <Toxaris> inbuninbu: what do you try to do?
03:57:54 <lilac> inbuninbu: your question is like asking if the /definition/ of a function keeps around values of stack variables
03:58:51 <inbuninbu> well i guess obviously the operational side has to... but i was wanting to peek at it
03:59:00 <inbuninbu> i'm trying to read a binary file that has offsets
03:59:39 <lilac> inbuninbu: if you want to keep your /own/ state while you parse, you can do that with ParserT
04:00:24 <jeffz`> inbuninbu: you might use getInput to return the unprocessed input along with the information your parser wants to return
04:02:03 <inbuninbu> ok, thanks guys. you gave enough hints that i think i know where to look... no info on ParserT in the tutorial i was reading...
04:02:54 <matthew-_> ivanm: pong
04:02:55 <lambdabot> matthew-_: You have 1 new message. '/msg lambdabot @messages' to read it.
04:03:11 <ivanm> well, lambdabot knows what I wanted to ask you :p
04:03:21 <matthew-_> ivanm: no, I've not changed it at all
04:03:28 <ivanm> matthew-_: OK
04:03:43 <ivanm> if I get off my lazy behind, I"ll hopefully have some patches for you by the end of the weekend
04:03:54 <inbuninbu> lilac++ Toxaris++ jeffz++
04:09:21 <osfameron> cads: bear in mind that MS has massive resources, amongst which are some very clever people, and a lot of testers...
04:10:28 <ivanm> osfameron: but aren't the clever people overwhelmed by the extremely unclever people?
04:10:33 <ivanm> (like management? :P )
04:10:41 <cads> still that logic hinges on "MS managed to cock it up, therefore it's unworkable", which feels a little suspect
04:11:16 <SamB> I'm pretty sure it's been done better than that in Smalltalks
04:11:17 <osfameron> nah, more like "MS cocked it up so Here Be Dragons"
04:11:32 <SamB> osfameron: hmm, that still doesn't sound quite right
04:12:18 <jimi__hendrix> 2 questions 1) do you access elements in a list the lisp way (keep asking for tail until you get the element you want at the start then do head) 2) what is haskell good for
04:13:32 <SamB> jimi__hendrix: well, our lists are made up of what we refer to verbally as cons and nil
04:13:39 <SamB> though they are written (:) and []
04:13:52 <jimi__hendrix> right
04:14:09 <SamB> so, yeah, you can get access elements in the same basic way
04:14:32 <SamB> well, as for what is Haskell good for... it seems like a fun language to write compilers in ;-)
04:15:00 <jimi__hendrix> ok cool
04:15:25 <jimi__hendrix> too bad vim doesnt give me auto indenting with haskell
04:15:53 <SamB> Eh, the Emacs indenting isn't all that great either. At least, not the default one on Debian ...
04:16:30 <jeffz`> personally, I don't mind hitting tab a few times repeatedly
04:16:51 <jimi__hendrix> i do...but also i dont know if my tabs are set right
04:17:08 <jeffz`> yeah, sorry, I meant with haskell-mode for emacs
04:17:52 <SamB> jeffz`: I still think it's a bit crazy!
04:18:04 <SamB> sometimes I don't like any of it's proposed indentation
04:18:05 <SamB> s
04:18:05 <cads> jimi, doood, lists are laaame, functional and all, but laaame
04:19:03 <jimi__hendrix> cads: lol
04:19:49 <cads> also, to your question 2), I start singing   Haskell.... Huhn!.... what it is it goooood for...
04:20:27 <cads> but I'd say the answer is not absolutely nothing
04:20:45 <cads> compared to lisp, it is much better for learning functional programming
04:21:00 <jimi__hendrix> with vim tabs i get syntax errors
04:21:16 <SamB> jimi__hendrix: don't use tabs in your files
04:21:41 <SamB> or if you do, tab stops are every 8 columns
04:22:14 <jimi__hendrix> ok
04:22:20 <jimi__hendrix> haskell is 4 if i recall?
04:22:28 <SamB> what ?
04:22:50 <SamB> (I mean, for purposes of tab characters)
04:23:12 <jimi__hendrix> 4 spaces
04:23:15 <jimi__hendrix> for an indent
04:23:45 <SamB> it's, er, a bit more complicated than that
04:23:54 <cads> god, there aren't haskell-0's, 1's and 2's are there?
04:24:42 <SamB> cads: what ?
04:24:54 <SamB> Haskell isn't at 2.0 yet
04:25:04 <cads> similar to lisp-0, lisp-1, lisp-2
04:25:11 <SamB> 3.11 for Workgroups notwithstanding
04:25:15 <jimi__hendrix> SamB: then how should i indent
04:25:32 <cads> lisp-0 has the same namespace for its variables and functions, as haskell could be said to
04:25:32 <SamB> @where report
04:25:33 <lambdabot> http://www.haskell.org/onlinereport/
04:25:40 <SamB> cads: that's what I call a 1-lisp
04:25:46 <SamB> like Python, for instance
04:28:08 <cads> I don't remember the explanation of what the extra namespaces in lisp-2 or 3 or n would be for, but I'd definitely say haskell is 0 in that you don't tell apart identifiers with a function defined on them and those with just a value
04:28:45 <cads> samB, you use the nomenclature for languages other than lisp?
04:29:06 <Lemmih> @seen Heffalump
04:29:07 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 5h 53m 41s ago.
04:29:12 <cads> ruby would be a lisp-1, too, then
04:29:31 <p_l> cads: Isn't that Lisp-1 behaviour? one namespace for everything (plus scope)
04:29:47 <Lemmih> ?ask Heffalump Is the London HUG still active?
04:29:47 <lambdabot> Consider it noted.
04:30:14 <cads> oh there I went zero indexing stuff that should be one-indexed :/
04:30:29 <p_l> Lisp-2 simply introduced separate namespace for functions (both approaches have good and bad sides)
04:30:52 <inbuninbu> followup question: ParsecT s u m a is a parser with stream type s, user state type u, underlying monad m and return type a. that seems to make sense to me.
04:31:05 <inbuninbu> but 'underlying monad m', i don't understand what it should be
04:31:19 <cads> in python I may not define a function that has a variable already named the same?
04:31:43 <p_l> cads: I think so
04:31:50 <cads> hm
04:32:12 <p_l> that's afaik due to the fancy way the scope is represented.
04:32:21 <SamB> I think unlambda could count as a 0-lisp ;-P
04:32:27 <p_l> (everything is in a sense a dict)
04:32:47 <cads> I had conjectured that highly functional languages benefit from L-1, while those with mutable variables do better with L-2
04:33:17 <p_l> cads: AFAIK main reasons for split were related to chaos it created with certain macroconstructions
04:33:25 <p_l> but I might be wrong
04:34:23 <p_l> also, you can still pull the same tricks, except that in L-2 you need to explicitly say that you are treating this as a function
04:34:34 <cads> p_l, the CL cats defend 2 pretty strongly for mainly normal programming reasons, but I have heard similar things about the macros
04:34:44 <SamB> #' FTW
04:35:10 <cads> p_l, it's the extra #' syntax for functional stuff that turned me off to learning CL
04:35:33 <cads> but maybe it's more unambiguous
04:35:46 <p_l> cads: afaik most "normal" reasons can be avoided with L-1, while advanced macros are said to make hell with it
04:36:01 * SamB was kidding
04:36:06 * SamB doesn't like #' either
04:36:28 <p_l> that's one of the things afaik that are the driving force between various "hygienic macros" packages for scheme
04:36:36 <cads> p_l, I'll have to ask the clojure guys about it
04:37:00 <p_l> cads: heh, clojure is another beast :-)
04:37:04 <cads> eh, I feel like scheme guys would give me the company line :)
04:37:59 * p_l is cool with either of them... only Visual Basic, MUMPS or something like that might be a problem
04:38:47 <cads> yeah I'm not sure what to think about clojure and its macros yet.. definitely very new and feels somewhat inelegant so far, but its community are very humble and sincere
04:40:38 <p_l> yeah, it's especially interesting for me when I'll get to send binary jars together with sourcecode for my assignment ^_^
04:43:16 <PierpolJak> DuClare
04:43:21 <PierpolJak> aa
04:43:25 <DuClare> Yes?
04:43:27 <PierpolJak> sorry
04:43:34 <PierpolJak> my keyboard is crazy now
04:43:52 <PierpolJak> what about this server? and this channel?
04:43:54 <DuClare> Sounds like you have to buy the Kinesis Contoured Advantage.
04:44:05 <PierpolJak> perhaps...
04:44:06 <PierpolJak> lol
04:44:15 <PierpolJak> what`s mean Haskell?
04:44:24 <DuClare> How did you end up here?
04:44:34 <DuClare> It's a programming language, in this context.
04:44:44 <PierpolJak> ahm ok ok sorry
04:44:55 <PierpolJak> i was searching a server to practice a little of enlgish
04:44:58 <PierpolJak> but i think that i mistake :D
04:45:11 <DuClare> PierpolJak, Try ##english
04:45:17 <PierpolJak> yeah
04:45:19 <PierpolJak> thanks friend
04:45:31 <methos> ^^
04:45:35 <methos> wtf
04:45:54 <DuClare> Yeah.
04:46:06 <DuClare> How can one end up on freenode AND on #haskell without knowing where he is? ^^
04:46:35 <methos> he must live somewhere without tv, people and restrictive internet filtering ^^
04:46:36 <p_l> the probability wasn't 0
05:01:57 <inbuninbu> lilac: if you don't mind, can you direct me to an example of ParsecT? i'm having a lot of trouble finding one. primarily I can't figure out what i should put for the 'underlying monad'
05:23:54 <marcot> Is it a problem if a ./setup clean fail when running before a ./setup configure?
05:38:43 <lilac> inbuninbu: if you want your parser to carry state with it, then use State for the underlying monad.
05:54:10 <beatbox> could someone give me a good example of a useful Functor?
05:54:25 <chessguy_work> @instances-importing Functor
05:54:27 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:54:32 <opqdonut> :)
05:54:48 <opqdonut> beatbox: lists, trees, maybe, etc
05:54:54 <opqdonut> almost everything is a functor
05:55:13 <chessguy_work> except monads (by default)
05:55:29 <opqdonut> well monads are functors
05:55:29 * chessguy_work rolls his eyes
05:55:36 <opqdonut> they might not be Functor instances :)
05:55:41 <chessguy_work> well yeah
05:55:50 <chessguy_work> they're functors but not Functors
05:57:44 <mmorrow> beatbox: the standard "turn-your-mind-off-and-start-writing-boilerplate" code for, say "data A ..... a = A ... a .. | B ... a .. | C" is "instance Functor (A ...) where fmap f (A ... a ..) = A .. (f a) ...; fmap f (B .. a ..) = B .. (f a) ..; fmap _ C = C"
05:59:12 <mmorrow> then you can do    fmap show (x :: A ... Int) :: A ... String
05:59:23 <mmorrow> (or whatever)
06:00:07 <mmorrow> fmap (fmap show) (x :: A ... [Int]) :: A ... [String]
06:00:17 <mmorrow> == (fmap . fmap) show (x :: A ... [Int]) :: A ... [String]
06:00:49 <mmorrow> @type [Node [42] []]
06:00:51 <lambdabot> forall t. (Num t) => [Tree [t]]
06:01:00 <mmorrow> @type (fmap . fmap . fmap) show [Node [42] []]
06:01:01 <lambdabot> [Tree [String]]
06:01:10 <mmorrow> > (fmap . fmap . fmap) show [Node [42] []]
06:01:12 <lambdabot>   [Node {rootLabel = ["42"], subForest = []}]
06:01:12 <beatbox> but how is map and fmap different?
06:01:18 <beatbox> *Matrix> fmap (\x -> x*x) [1..10]
06:01:18 <beatbox> [1,4,9,16,25,36,49,64,81,100]
06:01:27 <mmorrow> map is the particular fmap for lists
06:02:13 <mmorrow> too bad the identifier "map" isn't used for fmap
06:02:27 <byorgey> beatbox: the Functor instance for list defines fmap = map, in fact
06:02:43 <byorgey> > fmap (+3) (Just 2)
06:02:45 <lambdabot>   Just 5
06:02:49 <byorgey> > fmap (+3) Nothing
06:02:50 <lambdabot>   Nothing
06:03:16 <mmorrow> personally, i just use fmap everywhere i could use map because i like the consistency
06:03:37 <mmorrow> at this point it's a habit and i don't even think about it anymore
06:03:55 <asgaroth> and <$> (which is fmap) is even nicer to read in my opinion.
06:10:44 <inbuninbu> lilac: thanks. i'm still not quite getting it, but i'm working on it :-)
06:12:02 <hynek> anybody else having this issue with ghci 6.10 and emacs, that it prints "^J" instead of newlines? any remedies?
06:13:20 <asgaroth> hynek: Yes, put a file with "cat | ghci $*" in your PATH and set emacs to use that as the ghci binary
06:13:29 <anakreon> I am trying to apply two functions on a two element list, obtained by hxt arrows. The function's code is lrun = listA run >>> arrL (apply [exp_link, exp_link])
06:13:29 <anakreon>  where run returns two links. exp_link is defined as: exp_link = proc r -> do
06:13:29 <anakreon>              url   <- getAttrValue "href"             -< r
06:13:29 <anakreon>              returnA -< takeWhile (/= '#') . reverse . takeWhile (/= '=') . reverse $ url
06:13:32 <anakreon>  and apply is: apply (f : fs) (x : xs) = f x : apply fs xs
06:13:44 <anakreon> This does not compile.
06:13:45 <asgaroth> hynek: (and set it to executable of course)
06:14:20 <hynek> asgaroth: thanks, i'll try it
06:15:29 <doserj> anakreon: try to hpaste the code and the error message somewher
06:15:57 <hynek> Works wonderful, thank you!
06:17:18 <anakreon> http://hpaste.org/ is not working. I can place the code in a publicly accessable resource.
06:17:44 <chessguy_work> @where moonpaste
06:17:45 <lambdabot> I know nothing about moonpaste.
06:17:48 <chessguy_work> @where moonpaste2
06:17:48 <lambdabot> I know nothing about moonpaste2.
06:17:51 <chessguy_work> wtf
06:17:53 <doserj> @where hpaste2
06:17:54 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
06:18:07 <chessguy_work> anakreon, ^^
06:19:29 <anakreon> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1215#a1215
06:20:15 <doserj> anakreon: and the error message?
06:20:28 <anakreon> import.hs:41:34:
06:20:28 <anakreon>     No instance for (ArrowXml (->))
06:20:28 <anakreon>       arising from a use of `exp_link' at import.hs:41:34-41
06:20:28 <anakreon>     Possible fix: add an instance declaration for (ArrowXml (->))
06:20:31 <anakreon>     In the expression: exp_link
06:20:36 <anakreon>     In the first argument of `apply', namely `[exp_link, exp_link]'
06:20:37 <anakreon>     In the first argument of `arrL', namely
06:20:39 <anakreon>         `(apply [exp_link, exp_link])'
06:20:43 <anakreon>  
06:21:06 <anakreon> @t proc
06:21:07 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:21:32 <anakreon> @where proc
06:21:33 <lambdabot> I know nothing about proc.
06:21:40 <Gracenotes> hm... Haskell doesn't really autopromote types, per se... it just assumes the default Num type is Integer
06:22:13 <doserj> or Double
06:22:34 <Gracenotes> yes
06:22:40 <byorgey> Gracenotes: it can also default to Double, if there are class constraints (like Fractional) in addition to Num
06:22:44 <Gracenotes> I mean for bignum calculations :)
06:23:03 <byorgey> Gracenotes: right.  if you start with Int, then you're stuck with Int. =)
06:23:08 <Gracenotes> default (Integer, Double)
06:23:21 <mmorrow> , (id::(Fractional a)=>a->a) (42::Integer)
06:23:23 <lunabot>  luna: No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
06:24:20 <Gracenotes> obviously a Double would be appropriate where inferred it's needed, but the fact that int-operations can by-default go to arbitrary lengths is because they start as arbitrary-length types
06:25:25 <Gracenotes> that's neat :) not sure what other solution there is, though
06:26:09 <mmorrow> @type (^1000) . fromIntegral :: Int -> Integer -- ;)
06:26:10 <lambdabot> Int -> Integer
06:27:18 <Gracenotes> yes. And thank goodness most code is not littered with fromIntegral
06:27:51 <mmorrow> i like to make the def "fi = fromIntegral" in any module where i have to use fromIntegral a lot
06:28:14 <byorgey> Gracenotes: the only things you have to watch out for are functions like !!, length, and so on, which can suddenly turn everything into an Int =(
06:28:20 <mmorrow> since fromIntegral is unbearably verbose when you have to use once, let alone 10 times in a function
06:28:27 <byorgey> it's like the opposite of King Midas
06:28:37 <Gracenotes> byorgey: yeah. At least the library provides genericXXX and such :)
06:28:54 <byorgey> yup
06:29:05 <Gracenotes> although list `genericTake` 5... not the same ring :)
06:29:23 <Gracenotes> er, hm... that's the other way around, I think? Anyway.
06:29:31 <mmorrow> , length "(fi . take)"
06:29:32 <lunabot>  11
06:29:36 <Gracenotes> :t genericTake
06:29:38 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
06:29:38 <mmorrow> , length "genericTake"
06:29:39 <byorgey> hehe, I was about to say "especially since it doesn't typecheck" ;)
06:29:39 <lunabot>  11
06:29:42 <mmorrow> awww
06:29:50 <mmorrow> damn parens
06:29:58 <mmorrow> oh, wait
06:30:00 <byorgey> , length "(fi.take)"  -- who needs spaces?
06:30:01 <lunabot>  luna: parse error (possibly incorrect indentation)
06:30:02 <mmorrow> , length "(fi.take)"
06:30:03 <lunabot>  9
06:30:08 <mmorrow> hehe
06:30:17 <byorgey> who needs comments?
06:30:24 <mmorrow> hehe
06:30:34 <idnar> @type fromIntegral
06:30:36 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:30:42 <idnar> @type fromInteger
06:30:44 <lambdabot> forall a. (Num a) => Integer -> a
06:30:45 <Badger> @src random
06:30:46 <lambdabot> Source not found. My mind is going. I can feel it.
06:30:59 <Gracenotes> it's weird how the arguments for (!!) and take are switched
06:31:36 <Gracenotes> @pl flip take
06:31:37 <lambdabot> flip take
06:31:38 <mmorrow> oh oops
06:31:40 <Gracenotes> @pl flip (!!)
06:31:41 <lambdabot> flip (!!)
06:31:45 <mmorrow> , length "((fi.).take)"
06:31:46 <lunabot>  12
06:31:47 <idnar> flipflipflip
06:31:49 <mmorrow> crap
06:42:41 * Badger wonders how to strip the IO from things.
06:42:50 <Philippa_> you don't
06:43:01 <Philippa_> you have the IO pass the things into pure stuff
06:43:18 <Badger> in that case I'm simply doing it wrong :)
06:43:38 * Badger can't figure out how to use System.Random.
06:43:43 <asgaroth> You could use unsafePerformIO, but you really shouldn't.
06:43:46 <sior|oifig> Badger, your result has to be in the IO monad
06:43:58 <Philippa_> do f <- readFile "foo"; i <- return (read f::Int); writeFile ...
06:44:19 <sior|oifig> Badger, generally the form is do {n <- getmyrandomnum; use n for something; return result}
06:44:31 <Badger> sorry, I'm just being silly here and doing
06:44:36 <Badger> r <- newMTGen
06:44:41 <Badger> random r
06:44:49 <Badger> which is an incorrect use of random
06:44:56 <Badger> but I'm not sure what a correct one is :P
06:56:56 <gwern> oh dear. gitit has some serious memory issues
06:58:25 * byorgey makes blueberry-banana-lambda smoothies
06:59:43 <gwern> and by serious memory issues I mean 'eats all my ram for a single operation' -_-
06:59:56 <edbond> how can I say compiler 'stop here' and not compile later functions? I need to test first two, other functions don't compile yet.
07:00:29 <z0d> comment the out?
07:00:39 <Raevel> ^--
07:00:48 <loadquo> {-- --} are your friends
07:00:51 <z0d> Not manually, or course
07:00:58 <z0d> of*
07:01:36 <edbond> loadquo: thanks. I will comment them out.
07:02:08 <chessguy_work> is it possible to provide the ability to pattern match against an ADT but not construct values of that type via the constructor?
07:03:29 <Gracenotes> uh.. type signatures?
07:04:04 <chessguy_work> huh?
07:04:36 <chessguy_work> no, i mean i want to export my type such that modules that import can pattern match against my values, but not construct new values
07:04:40 <chessguy_work> via the constructor
07:06:07 <doserj> chessguy_work: not possible, unfortunately. Maybe you can work around it using view patterns, though?
07:07:08 <Gracenotes> yeah.. it seems a bit of a catch-22
07:08:13 <bastl> hello. are these dots in a data declaration allowed? data XMI = XMI XMI_Attrs (Maybe XMI.header) (Maybe XMI.content) [XMI.difference] [XMI.extensions]
07:09:29 <chessguy_work> hm, i can't seem to find a very good overall description of view patterns
07:10:00 <mmorrow> bastl: yes (i'm assuming XMI is a module name or alias for one)
07:10:12 <mmorrow> oh wait
07:10:14 <chessguy_work> mmorrow, it doesn't look like it is
07:10:21 <mmorrow> what is "header"
07:10:23 <bastl> mmorrow, dont think so, it got generated from Dtd2Haskell
07:10:30 <mmorrow> oh, i'm not sure
07:11:08 <saml> > herror
07:11:09 <lambdabot>   Not in scope: `herror'
07:11:12 <mmorrow> slash the chars after the dots can't be lower-case
07:11:23 <mmorrow> in that context
07:11:26 <chessguy_work> > error
07:11:27 <lambdabot>       Overlapping instances for Show ([Char] -> a)
07:11:27 <lambdabot>        arising from a use ...
07:12:07 <saml> > let d = 1; _ = 1; b = 1 in d-_-b
07:12:09 <lambdabot>   Pattern syntax in expression context: _
07:12:30 <saml> > import BASIC
07:12:32 <lambdabot>   <no location info>: parse error on input `import'
07:13:09 <saml> http://augustss.blogspot.com/2009/02/regression-they-say-that-as-you-get.html  how does this work?
07:13:17 <saml> 10 LET X =: 1
07:13:42 <saml> wait.. LET should be data constructor
07:13:45 <saml> so is X
07:13:46 <mmorrow> you'd need to know the def of (=:), LET, and X
07:14:06 <mmorrow> also, looks like something funny with the Num class too
07:14:18 <doserj> chessguy_work: basically, define and export a datatype isomorphic to your current one, implement a function "view" from the old to the new datatype, and then pattern match using "view -> pattern"
07:14:18 <mmorrow> (funny := tricksy)
07:15:39 <blueonyx> is there a list function which just keeps the first appearance of an Eq element?
07:15:53 <mmorrow> , 'find
07:15:54 <lunabot>  Data.List.find
07:16:00 <Gracenotes> doserj: that sounds too hacky to be given a pretty name like "view pattern" :)
07:16:48 <doserj> Gracenotes: tell that to the GHC HQ :)
07:17:13 <blueonyx> erm i mean the element in the list should become uniq
07:17:17 <blueonyx> *elements
07:17:33 <doserj> > nub [1,1,2,2,4,4,1,1,2]
07:17:36 <lambdabot>   [1,2,4]
07:17:48 <blueonyx> thanks :)
07:18:53 <lilac> > map head . group . sort $ [1,1,2,2,4,4,1,1,2]
07:18:54 <lambdabot>   [1,2,4]
07:20:24 <Gracenotes> > nub . sort $ [1,1,2,2,4,4,1,1,2]
07:20:26 <lambdabot>   [1,2,4]
07:21:32 <blueonyx> > nub . reverse $ [1,1,2,2,4,4,1,1,2]
07:21:33 <lambdabot>   [2,1,4]
07:22:10 <inbuninbu> does haskell ever stop making your brain bleed?
07:22:32 <Botje> it stops when the blood gets replaced by liquid lambdas :)
07:22:59 <inbuninbu> hahaha
07:27:32 <bastl> malcolmw: i try to compile this dtd to haskell: http://www.jeckle.de/files/99-10-05.dtd but get "multiple declarations" errors when loading the module. is the dtd erroneous, or is it a issue with Dtd2Haskell ?
07:28:13 <bastl> i use the latest version from hackage and ghc 6.10.1
07:28:42 <blueonyx> what does '*** Exception: Data/Graph/Partition.hs:87:8-58: Irrefutable pattern failed for pattern (before, (largest : after))' mean?
07:28:56 <blueonyx> oh hgal
07:34:25 <blueonyx> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1216#a1216 does i mean (largest:after) is matched against the empty list?
07:34:33 <blueonyx> s/i/it/
07:34:54 <doserj> yes
07:37:50 <blueonyx> but how can that be?
07:38:07 <apfelmus> blueonyx: looks like  list  was empty
07:39:06 <doserj> > break undefined []
07:39:08 <lambdabot>   ([],[])
07:39:31 <apfelmus> i.e. extracting the largest element of the empty obviously has to fail
07:39:40 <apfelmus> *empty list
07:46:27 <liwp> does my type have to have a type variable if i want to implement a Foldable instance for it?
07:46:42 <liwp> :t Data.Foldable.foldl
07:46:43 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> a) -> a -> t b -> a
07:47:44 <liwp> AFAICT the Foldable type t in the above must be parametrized with a type b...
07:47:55 <apfelmus> liwp: yes.
07:48:21 <liwp> hmmm
07:48:24 <apfelmus> it's actually called "type constructor"
07:48:30 <liwp> ok
07:49:08 <liwp> i'm want to parse java class files
07:49:13 <apfelmus> I mean, just like you fold elements  a  of a list [a]
07:49:49 <apfelmus> ok. what do you want the Foldable instance for?
07:50:01 <liwp> you can sort of treat a class file as a tree so i was hoping to implement Foldable and Traversable for it, but the type constructor is confusing me
07:50:05 <Cheshire> liwp, why don't you use javap or whatever then?
07:50:29 <liwp> it's a hobby project
07:50:53 <Cheshire> to what end?
07:50:58 <liwp> i want to then do a transformation on the method bytecode and i thought it would be cool to do in haskell
07:51:42 <apfelmus> liwp: well, what exactly would you be folding, then?
07:51:47 <Cheshire> liwp, oh I meant something like, hack javap to print out a haskell code
07:51:49 <apfelmus> i.e. what's the type b in your case?
07:52:08 <liwp> a friend of mine is working on a java coroutine library called kilim and i was hoping to implement the byte code transformation in haskell just for fun: http://www.malhar.net/sriram/kilim/
07:52:30 <liwp> apfelmus: i'm more interested in traversable
07:52:37 <liwp> which requires foldable
07:53:04 <liwp> Cheshire: ahh, i'll have to have a look at that
07:53:25 <apfelmus> liwp: yes. well, you'd still need to have an idea about the b in
07:53:27 <apfelmus> :t traverse
07:53:29 <lambdabot> Not in scope: `traverse'
07:53:32 <liwp> apfelmus: i don't know what by b is at the moment ;)
07:53:57 <apfelmus> liwp: hehe, well that's worth thinking about, then. ;)
07:54:02 <liwp> :t Data.Travesable
07:54:04 <lambdabot> Couldn't find qualified module.
07:54:08 <liwp> :t Data.Traversable
07:54:10 <lambdabot> Couldn't find qualified module.
07:54:14 <liwp> hmph
07:54:16 <apfelmus> :t Data.Traversable.traverse
07:54:17 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
07:54:52 <apfelmus> liwp: maybe you want to do generics instead?
07:55:15 <liwp> anyhow, i'm only at the stage of parsing the class file at the moment, so I can look at providing instances for some type classes later on
07:55:34 <liwp> apfelmus: you mean generic programming?
07:55:58 <apfelmus> liwp: yes, like http://hackage.haskell.org/packages/archive/pkg-list.html#cat:generics
07:56:38 <apfelmus> scrap your boilerplate (syb) is one approach
07:56:52 <apfelmus> there are slightly differen ones as well.
07:56:54 <liwp> apfelmus: i've been reading one of the strafunski papers
07:57:14 <apfelmus> yes, something like that.
07:57:24 <liwp> it's unclear to me which one of the many frameworks is the 'best', for some definition of best
07:57:45 <apfelmus> i don't know either :D
07:58:02 <liwp> also, most of the frameworks seem to require a preprocessing stage for automatic instance derivation
07:58:21 <apfelmus> unless you want to code the instances yourself, yes
07:58:24 <liwp> which isn't necessarily a bad thing, just another thing to think about
07:58:29 <apfelmus> most support template haskell
07:58:47 <liwp> OTOH, i've got very few types at the moment, so maybe i can write instances myself
07:58:49 <apfelmus> and Data.Generics is baked into ghc, I think
07:59:12 <liwp> is Data.Generics based on the SYB papers then?
07:59:12 <skorpan> syb makes use of Data.Data, but i can't find that module. where is it?
07:59:14 <apfelmus> writing instances is boring ;)
07:59:20 <liwp> true
07:59:21 <SamB_irssi> apfelmus: well, the Data and Typeable classes are
07:59:38 <SamB_irssi> skorpan: in base 4
07:59:54 <apfelmus> liwp: maybe you can start with http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uniplate
08:00:03 <SamB_irssi> (the stuff from syb was included in base3)
08:00:15 <apfelmus> i think it's the simplest generics approach around.
08:00:23 <liwp> ok, good to know
08:00:31 <liwp> simple is good at this point :)
08:00:35 <Cheshire> I am not especially pleased with any of the generic programming methods yet
08:00:42 <SamB_irssi> does syb work with anything besides GHC ?
08:00:56 <liwp> some other generics package was released this or last week
08:01:13 <liwp> some four letter acronym starting with e i think
08:01:23 <Cheshire> I made my own way up but it is not good either
08:01:50 <Cheshire> generics seems to be very awkward without computation in types..
08:02:17 <apfelmus> liwp: emgm?
08:02:24 <liwp> probably
08:02:57 <liwp> again, how is emgm different from uniplate, and how is either of those different from SYB?
08:03:13 <apfelmus> don't know exactly, but it looks like it's based on hinze's "generics for the masses"
08:03:19 <jeffersonheard> argh.  I published an old version of the sparkline tutorial and Thomas Davie just now caught it
08:03:20 <Cale> Cheshire: I agree. I think generics need actual language support to some extent and not just library support to be elegant.
08:03:24 <SamB_irssi> Cheshire: even with they aren't exactly easy
08:03:35 <skorpan> SamB_irssi: you don't happen to know whether the "cast" function in syb happens to be in there?
08:03:58 <SamB_irssi> @hoogle cast
08:03:58 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
08:03:58 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
08:03:58 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
08:04:11 <apfelmus> liwp: emgm seems to be more the "sums of products" approach
08:04:13 <SamB_irssi> well, that cast is in base
08:04:30 <apfelmus> liwp: which is useful for things like generic zippers or memo tables
08:04:38 <SamB_irssi> skorpan: what version of GHC do you have ?
08:04:39 <liwp> anyhow, i thought supporting generics would make it easy to implement bytecode transformations
08:04:52 <apfelmus> liwp: but it's less useful if you only have one data type with many nested constructors
08:04:55 <skorpan> SamB_irssi: 6.10.1
08:05:06 <liwp> apfelmus: sum of products does not mean much to me at the moment, i'll have to look into it
08:05:39 <liwp> at the moment i've got different types for the nested elements, e.g. class, field, method are all different types
08:06:08 <apfelmus> liwp: yes, though recursing on each other, I'd suppose.
08:06:19 <apfelmus> in any case, I'd go with uniplate
08:06:19 <Cale> liwp: Sum of products is how Haskell data declarations effectively look at the moment. A product of types is like a tuple, and a sum of types is a disjoint union.
08:06:25 <liwp> and those types then have other elements, e.g. a class had access flags, a name, a super class name etc.
08:07:08 <liwp> apfelmus: thanks for all the help
08:07:17 <apfelmus> ^^
08:07:45 <liwp> Cale: ahh, ok
08:11:27 <Cheshire> Cale, you can capture that sum of products notion in haskell with a GADT, and then add in lots of extra parameters -- with the extra parameters you can compute types and that is one way to write a generic program, of course this method doesn't work for GADTs so you need GGADTs to write generic programs on GADTs... :)
08:12:00 <Cale> Hmm, what's the second generalisation?
08:12:01 <Cheshire> by compute types I mean these extra parameters build up some kind of 'shape' which gets specialized by different data types
08:12:43 <drigz> how can i profile a program without needing profiling versions of libraries it uses?
08:12:47 <Cheshire> Cale, oh GGADTs I just made up because infinite regression is funny.. I think you can actually close the loop by having GADTs + type lambda
08:12:48 <apfelmus> Cale: gadts are not sums of products, so how to describe them?
08:13:00 <drigz> alternative question: how can i install the profiling version of a cabal library?
08:13:03 <Cheshire> ADTs => GADTs => GGADTs
08:13:25 <Cale> apfelmus: I wasn't really considering them before, but that's a good question.
08:13:26 <apfelmus> drigz: cabal install --profile ?
08:14:02 <Cale> It's -p or --enable-library-profiling
08:14:07 <Cheshire> there's a sort of categorical notion of GADT as the fixed point of a functor
08:14:09 <Cale> (for the cabal install command)
08:14:14 <fasta> apfelmus: it rarely is that easy.
08:14:30 <apfelmus> Cale: aye. That's what Cheshire means, ggadts are this (hypothetical) description
08:15:02 <apfelmus> fasta: in the Haskell world, it is. ;) (or should be)
08:15:19 <fasta> apfelmus: I missed the alternative question.
08:15:31 <apfelmus> ah, ok :)
08:16:06 <Cale> GADTs are the initial algebras of functors (|C| -> C) -> (|C| -> C), where |C| is the discrete category derived from C.
08:16:29 <fasta> For example GTK2HS does not compile with profiling options with the same flags as without profiling.
08:16:31 <byorgey> Cale: ah, I'm just reading that paper =)
08:17:40 <drigz> apfelmus, Cale: seems to be working. is there a reinstall --recursive flag?
08:17:46 <drigz> or similar
08:17:54 <Cale> drigz: mm... I don't know
08:18:25 <apfelmus> drigz: maybe the -p does that automatically?
08:18:50 <apfelmus> i mean, it should because -p will fail if the dependencies aren't compiled with -p as well?
08:19:00 <Cale> It's basically a fancy way of expressing what phantom types are :)
08:19:01 <drigz> apfelmus: nah, -p needs --reinstall
08:19:12 <apfelmus> ah. no idea then.
08:19:26 <michaelcdever> anyone here familiar with gtk2hs?
08:20:53 <Cale> Any function on the objects of C induces a functor |C| -> C.
08:21:44 <fasta> michaelcdever: you would have to ask a real question.
08:22:14 <michaelcdever> or does anyone know how I can turn a function of return type GHC.IOBase to IO()
08:22:47 <lilac> @hoogle GHC.IOBase -> IO ()
08:22:48 <lambdabot> Parse error:
08:22:48 <lambdabot>   --count=20 "GHC.IOBase -> IO ()"
08:22:48 <lambdabot>                 ^
08:23:08 <Saizan_> GHC.IOBase is a module iirc
08:23:22 <michaelcdever> yeah sorry, it returns GHC.IOBase.ExitCode
08:23:48 <Cale> michaelcdever: exitWith?
08:23:49 <drhodes> :t GHC.IOBase.ExitCode
08:23:51 <lambdabot>     Not in scope: data constructor `GHC.IOBase.ExitCode'
08:23:58 <lilac> @hoogle ExitCode
08:23:58 <lambdabot> System.Exit data ExitCode
08:23:58 <lambdabot> System.Process getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
08:24:02 <Cale> :t System.Exit.exitWith
08:24:04 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
08:24:20 <lilac> michaelcdever: what do you want to do with this exit code?
08:24:31 <Cale> It's really annoying, btw, how types aren't defined in the modules which they appear to be.
08:24:47 <SamB_irssi> Cale: yes, it is.
08:24:51 <michaelcdever> im trying to trigger a function using `onToolButtonClicked` but that requires a function of return IO() to be passed and my function returns GHC.IOBase.ExitCode
08:24:53 <SamB_irssi> but do you know what happens when they ARE?
08:25:07 <Cale> SamB_irssi: heh, I can imagine there are problems.
08:25:12 <michaelcdever> im doing nothing with the exit code, its just a side effect of what i'm doing
08:25:19 <michaelcdever> the result is being ignored
08:25:28 <SamB_irssi> Cale: it takes forever to compile because all the modules have to import eachother. basically.
08:25:42 <Cale> michaelcdever: Well... what do you want to do when the tool button is clicked?
08:25:49 <Cale> michaelcdever: That's what the IO action is for.
08:25:56 <liwp> michaelcdever: what's the type of your function?
08:26:48 <lilac> michaelcdever: if your function returns GHC.IOBase.ExitCode and you don't want the exit code, then you have no need to call the function
08:26:59 <michaelcdever> hang on, ill trow it up on hpaste, but basically, when the button is clicked, i want to perform an action on a file using System.Cmd.rawSystem
08:27:11 <lilac> michaelcdever: therefore i suspect your function actually is of type (something) -> IO ExitCode
08:27:12 <michaelcdever> but the function must execute when the button is pressed
08:27:23 <michaelcdever> yeah ioll throw it up now
08:27:29 <SamB_irssi> lilac: what about the effects ?
08:28:04 <michaelcdever> oh hpaste is down
08:28:21 <liwp> michaelcdever: you can ignore the ExitCode with something like this: foo = do { myfunc; return () }
08:28:33 <liwp> (add fun args as requied)
08:29:01 <doserj> @type System.Cmd.rawSystem "killall" ["init"] >> return ()
08:29:03 <lambdabot> IO ()
08:29:55 <michaelcdever> http://pastebin.com/d69555c4c
08:30:01 <michaelcdever> theres a paste of it
08:31:13 <liwp> add 'return ()' to the end of the function and the type will change to IO ()
08:31:55 <Cheshire> michaelcdever, I think you should try to divide your program into small procedures
08:32:09 <michaelcdever> doserj: thanks, that solved it :D
08:32:18 <michaelcdever> liwp: thanks! :D
08:32:19 <drigz> can HGL block all threads?
08:32:43 <michaelcdever> Cheshire: I intend to, I just want to get it working first
08:32:46 <michaelcdever> ;)
08:32:47 <lilac> SamB_irssi: did i accidentally bang my head and slip into a wacky world where Haskell is referentially transparent?
08:32:57 <Cheshire> yeah yeah I believe you :p
08:33:40 <michaelcdever> Cheshire: SRSLY?
08:35:14 <SamB_irssi> lilac: monadic values often have effects
08:35:23 <SamB_irssi> but not when evaluated -- only when run
08:35:43 <bastl> :e
08:35:46 <ehird> does gtk2hs build on ghc 6.10?
08:35:46 <bastl> oops
08:36:31 <bastl> ehird: i had also problems with that.
08:36:40 <ehird> darn
08:36:42 <bastl> there is a prerelease of gtk2hs 0.10. IIRC
08:36:59 <SamB_irssi> michaelcdever: it's usually better to divide first ;-)
08:37:27 <ehird> bastl: oh?
08:37:35 <malcolmw> bastl: just had a look at your DTD
08:37:51 <bastl> ehird: http://code.haskell.org/~pgavin/gtk2hs-0.10.0/gtk2hs-0.10.0-rc-20090119.tar.gz
08:37:51 <bastl>  
08:38:01 <ehird> thanks
08:38:04 <bastl> np
08:38:11 <lilac> SamB_irssi: indeed, but michaelcdever said his function returned GHC.IOBase.ExitCode, which is /not/ a monadic value
08:38:14 <ehird> 16:38:30 ERROR 404: Not Found.
08:38:15 <malcolmw> bastl: the errors in the code generated by DtdToHaskell are an unfortunate consequence of its internal naming scheme
08:38:21 <ehird> bastl: 404'd
08:38:31 <ehird> http://code.haskell.org/~pgavin/gtk2hs-0.10.0/gtk2hs-0.10.0.tar.gz
08:38:47 <bastl> http://code.haskell.org/~pgavin/gtk2hs-0.10.0/
08:38:53 <ehird> yep
08:39:25 <ehird> Reading package info from stdin ... ghc-pkg: 14: Parse of field 'include-dirs' failed.
08:39:34 <malcolmw> e.g. there is both an ELEMENT UML:ModelElement.visibility, and separately an ELEMENT UML:ModelElement that happens to have an attribute called 'visibility'
08:39:36 <ehird> :\
08:40:02 <malcolmw> bastl: DtdToHaskell is mapping them to the same identifier in Haskell, but of course they are really different types
08:40:02 <lilac> SamB_irssi: hence my suggestion that the function does not in fact return ExitCode but instead returns IO ExitCode
08:40:08 <SamB_irssi> lilac: AH!
08:40:15 * SamB_irssi feels silly now
08:40:22 <bastl> malcolmw. hmm
08:40:34 <ehird> bastl: did you have that problem?
08:40:58 <bastl> so this is the problem of that parser that was documentend somewhere. like uppercase/lowercase issues, right !?
08:41:09 <bastl> ehird: no
08:41:12 <ehird> :( ok
08:41:14 <malcolmw> bastl: I think it is probably straightforward to fix - but means changing the way DtdToHaskell generates identifiers, just a little bit.
08:42:04 <bastl> malcolmw: ill try myself if you give me some pointers.
08:42:32 * SamB_irssi hands bastl nullPtrs of various types
08:42:45 <bastl> ehird: but i could send you the RC i used.
08:43:01 * bastl looks at the holes in his hands ...
08:43:18 <Pippo_61> ciao
08:43:28 <ehird> bastl: that'd be nice :)
08:43:33 <Pippo_61> !list
08:43:41 <ehird> Pippo_61: not a warez channel
08:43:49 <ehird> weren't you i n here a few days ago doing that?
08:43:51 <bastl> ehird, priveded i find it on my disk
08:43:54 <ehird> bastl: :-)
08:43:57 <redditbot> Regression : Lennart Augustsson
08:44:26 <Cale> Pippo_61: Why would you even bother to type !list?
08:44:44 <pumpkin> @bot
08:44:44 <lunabot>  :)
08:44:45 <lambdabot> :)
08:44:45 <pumpkin> lol
08:44:46 <lambdabot> pumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
08:44:51 * Cale lists off some l33t Haskell w4r3z DCCz.
08:44:59 <ehird> Cale: last time he came he said he didn't know english.
08:45:01 <Gracenotes> speaking of which, when is augustss going to release the travesty that is the HBASIC source code :?
08:45:07 <ehird> i don't know wtf makes him come here and keep doing that.
08:45:36 <augustss> Gracenotes: It was JoshTriplett's idea, I'll let him release his first :)
08:45:37 <doserj> Cale, !list should return hackage and the ghc/hugs/nhc/lhc download page, etc.
08:46:06 <ehird> doserj: lol :-)
08:46:12 <Gracenotes> now announcing Enterprise HBASIC(TM)
08:47:37 <pumpkin> visual hbasic!
08:47:44 * pumpkin tries to pronounce it and fails
08:47:46 <Gracenotes> .NET
08:48:12 <Gracenotes> Visual HBASIC#.NET 6
08:48:16 <ehird> visual haysick
08:48:21 <malcolmw> bastl: so, in HaXml/src/Text/XML/HaXml/DtdToHaskell/TypeDef.hs, at the end of the file is a function called "deColonify".  It converts colon to single-quote, and hyphen and dot into underscore.  I suggest converting all of them to single-quote instead.
08:48:27 <Saizan_> how do you do record concatenation with lenses?
08:49:42 <fasta> Saizan_: where is 'lenses' packaged?
08:49:47 <Kamina> Hello, has someone experiences with writing binary files in Haskell?
08:50:06 <Kamina> I tried to find a function in System.IO, but there is only hPutBuf with a strange type signature
08:50:07 <bastl> malcomw: thanks alot. what about deriving data,typeable? i guess its too OT for you?
08:50:09 <Kamina> :t hPutBuf
08:50:11 <lambdabot> Not in scope: `hPutBuf'
08:50:26 <Badger> @hoogle hPutBuf
08:50:26 <drhodes> if I've cabal installed quickCheck without warning, should it be importable from ghci with import QuickCheck? much of the information I've found shows it used with Hugs - also, is there supposed to be a cmd line utility bundled with it?
08:50:27 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
08:50:27 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
08:50:42 <Kamina> so
08:50:53 <Kamina> i don't know how to create a Ptr a structure..
08:51:06 <pumpkin> don't use that
08:51:11 <lilac> someone want to set up their IRC client to offer GHC over DCC if someone types !list? :)
08:51:13 <pumpkin> use a ByteString
08:51:31 <liwp> and have a look at data.binary
08:51:35 <lilac> or possibly some harder stuff.. Oleg papers?
08:51:41 <Kamina> ahh
08:51:49 <pumpkin> hPut
08:51:53 <Kamina> there is a hPutStr in Data.ByteString!
08:51:57 <Saizan_> fasta: not sure, maybe here http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
08:52:04 <Gracenotes> new haskell warez channel: #hazkell
08:52:07 <Kamina> i was just looking at the wrong place
08:52:08 <cognominal> I can't ever remember, in infixl/r declarations, lower number meens tighter or not?
08:52:14 <pumpkin> Gracenotes: not k3ll?
08:52:24 <pumpkin> cognominal: means lower precedence
08:52:31 <Gracenotes> good idea. new haskell warez channel: #hazk3ll
08:52:45 <Kamina> thanks for the help...
08:52:50 <cognominal> lower number means looser precedence?
08:52:54 <Gracenotes> ask for functional programming papers, pirate copies of TAPL, etc.
08:53:01 <Gracenotes> +d
08:53:14 <fasta> Saizan_:What is 'lenses' according to you? I used data-accessor already.
08:53:17 <Badger> I've heard someone say that their proxy blocked hackage because it was related to "illegal activities" :)
08:53:28 <bastl> bye
08:53:33 <doserj> Gracenotes: you mean h4zk3ll, or h4zk311
08:53:58 <fasta> Badger: it could be, if you work for an ISP.
08:54:16 <fasta> It's the perfect MITM attack scenario.
08:54:35 <Gracenotes> good idea. new haskell warez channel: #h4zk3ll
08:54:42 <koeien> lol
08:54:43 <Gracenotes> (the ones are overkill)
08:54:50 <roconnor> fasta: a -> (b,b->a) is a lens ?
08:55:02 <fasta> roconnor: I don't know. Is it?
08:55:17 <roconnor> that what I was calling a lens yesterday
08:55:32 <Saizan_> fasta: http://www.haskell.org/pipermail/haskell-cafe/2007-November/035263.html
08:55:51 <Saizan_> yeah, that
08:56:54 <Cheshire> a <- (b,b->a) is eval
08:57:20 <BMeph> Is there an Oleg post explaining the whole "Iteratee" thing? :)
08:57:54 <Saizan_> BMeph: there are slides
08:59:01 <roconnor> (^.) :: r -> T r a -> a
08:59:02 <BMeph> Saizan_: Yeah, I've seen those. I feel like I'm missing half of the presentation. :)
08:59:07 <roconnor> get as infix operator. This lets us write record^.field^.subfield. This imitates Modula II syntax.
08:59:13 <roconnor> awsome
08:59:19 <gwern> mm. 'hacskill'. the language of choice for the discerning cracker :)
08:59:43 <augustss> More BASIC!
09:00:10 <roconnor> augustss: what happened to the "GOTO" keyword in your IF statement?
09:00:35 <augustss> roconnor: Well, that would be an error in Dartmouth BASIC.
09:00:43 <roconnor> oh
09:01:33 * jeffersonheard tries to imagine a Haskell with a GOTO statement.
09:01:52 <gwern> it's not hard if you try
09:01:56 <augustss> roconnor: It's blazingly fast in my new implementation. :)
09:01:59 <gwern> below us lambda, above us sky
09:02:06 <Cheshire> above us ski
09:02:25 <fasta> I found either a dark corner in Haskell or a bug in GHC. What's the semantics of exporting ModuleName in ModuleName.hs?
09:02:33 <gwern> ((Imagine there's          no memory leaks)
09:02:41 <gwern> (It isn't hard to do)
09:02:42 <gwern>                                   (Nothing to malloc(3)
09:02:42 <gwern>                                         or free(3) for)
09:02:43 <gwern>                                    (And no (void *) too)
09:02:53 <jeffersonheard> gwern: I see a space leak in your last statement
09:03:05 <augustss> fasta: it should export everything from the module
09:04:39 * rwbarton ponders doing the ICFP contest in BASIC in Haskell
09:07:17 <Gracenotes> there was a blog post about Ruby in Haskell :)
09:07:24 <chessguy_work> > let foo [Just 1, Just x] = x in foo [Just 1, Just 3]
09:07:26 <lambdabot>   3
09:07:36 <jeffersonheard> now we just need PHP in Haskell...
09:07:38 <chessguy_work> > let foo [Just 1, Just x] = x in foo [Just 2, Just 3]
09:07:40 <lambdabot>   * Exception: /tmp/3646282691478155286:71:48-71: Non-exhaustive patterns in ...
09:08:01 <Gracenotes> > let a.b = b a in [3,6,2,3,5,2].sort.group.head
09:08:02 <lambdabot>   [2,2]
09:08:13 <chessguy_work> > let foo [Just y, Just y, Just x] = x in foo [Just 2, Just 2, Just 3]
09:08:14 <lambdabot>       Conflicting definitions for `y'
09:08:14 <lambdabot>      In the definition of `foo'
09:08:15 <osfameron> or a PHP backend to Haskell
09:08:22 <osfameron> then it could run everywhere
09:08:34 <Gracenotes> or a Java backend to Haskell. Then it could run more everywhere.
09:08:41 <Gracenotes> >_>
09:08:46 <chessguy_work> that should totall be legal :(
09:08:49 <osfameron> PHP probably runs on more webservers
09:09:02 <gwern> lambdavm etc., no one cares enough to really get haskell onto the jvm it seems
09:09:03 <Gracenotes> but the market, man! Think about the market!!!!
09:09:10 <jeffersonheard> or a C++ backend to Haskell, so it would refuse to compile even more often, and our error messages could be more verbose and less useful
09:09:12 <gwern> despite this being a research topic since... like '98
09:09:34 <Gracenotes> it shouldn't be *that* hard to compile Haskell to Java bytecode, I should think
09:09:44 <osfameron> well, java*script* backend might make more sense actually
09:09:48 <augustss> Gracenotes: it's not.  getting it efficient is.
09:09:59 <roconnor> osfameron: doesn't that already exist
09:10:05 <Gracenotes> yeah :)
09:10:10 <osfameron> ooo, does it?
09:10:18 <Gracenotes> not to mention, you have to do tail recursion from the Square Zero
09:10:22 <Gracenotes> -the
09:10:26 <roconnor> isn't there javascript backend for Yhc?
09:10:27 <augustss> there's a YHC backand for generating Javascript
09:10:30 <osfameron> ah
09:10:33 <rwbarton> osfameron: YHC has a javascript backend, and there is work to port it to hugs
09:10:34 <Gracenotes> or is that Square One. Either way, it'd be difficult.
09:10:43 <dzrk> I have [[a]] and [a], how can I append that last [a] to the [[a]]?
09:11:00 <chessguy_work> dzrk, (:)
09:11:15 <osfameron> that's prepend
09:11:26 <roconnor> > [3] : [[4],[5,6]
09:11:28 <lambdabot>   <no location info>: parse error on input `;'
09:11:29 <roconnor> > [3] : [[4],[5,6]]
09:11:30 <lambdabot>   [[3],[4],[5,6]]
09:11:32 <Gracenotes> or if you want to append it on the end, 2d++[1d]
09:11:33 <chessguy_work> dzrk, or if you want it on the end, put your [a] in a list, and concatenate
09:11:42 <roconnor> > [[4],[5,6]]++[  [3]  ]
09:11:43 <lambdabot>   [[4],[5,6],[3]]
09:11:48 <chessguy_work> yeah, what gracenotes said
09:11:58 <dzrk> ah, bingo
09:12:02 <chessguy_work> roconnor, got whitespace
09:12:11 <roconnor> just trying to emphasize
09:12:11 <doserj> if you want to append to the end of a list, you are doing sth wrong... *cough*
09:12:25 <chessguy_work> doserj, hear, hear
09:12:52 <Gracenotes> appending to the end of a list is somewhat convenient in that you don't have to crawl the entire list until you actually use it, but the thunk still takes up space
09:12:56 <roconnor> dzrk: doserj is possibly right.  appending to the end of a list is usually (but not always) a sign of an unhaskelly design.
09:13:23 <chessguy_work> roconnor, i'd like to see a case where it was a good design :)
09:13:28 <chessguy_work> +of
09:13:40 <dzrk> just working on RWH's splitWith exercise, and was trying to see if I could do it with a foldr, since it does look like a fold type of problem.  I've done it already with explicit recursion.
09:14:18 <roconnor> chessguy_work: maybe it is never a good design, but it is acceptable in a one-off program because it is easy.
09:14:28 <chessguy_work> bah
09:14:35 <roconnor> heh
09:14:39 <roconnor> fair point
09:14:40 <Gracenotes> chessguy_work: well, I had written this only a few weeks in learning Haskell, but: main=interact$(\g->unlines$map(\a->replicate(g-a)' '++replicate(a*2-1)'*')$[1..g]++[1]).(read::[Char]->Int)
09:14:47 <augustss> Sometime you just need to stick that thing at the end of the list. :)
09:14:51 <chessguy_work> bah, i say. bah!
09:15:04 <Gracenotes> and then you can "echo 6 | runhaskell printtree.hs"
09:15:17 <Gracenotes> it prints a Christmas tree with height 6. the [1] is needed for the stub at the bottom :)
09:15:24 <Zao> reverse $ a : (reverse as)
09:15:32 <Zao> See, using : to put things at the end of a list :P
09:15:37 <Gracenotes> not much better in terms of performance :)
09:15:39 <chessguy_work> haha
09:16:21 <Gracenotes> see, [1..g]++[1] prints out a Christmas tree with widths 1,3,5,..(2*g-1), and then finally the bottom of the tree with width 1
09:16:46 <Gracenotes> it's not exactly useful.. but, well, I think the design is okay for that
09:19:02 <saml> > [1..g] ++ [1]
09:19:04 <lambdabot>   Add a type signature
09:20:05 <chessguy_work> > [1..g] ++ [1] :: Expr
09:20:06 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[t]'
09:20:11 <Gracenotes> > [a..g] :: Expr
09:20:12 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
09:20:19 <chessguy_work> > [1..g] ++ [1] :: [Expr]
09:20:21 <lambdabot>   * Exception: not a number
09:20:27 <chessguy_work> good point
09:20:30 <Gracenotes> > enumFromTo a g :: [Expr]
09:20:33 <lambdabot>   * Exception: not a number
09:20:45 <Gracenotes> pssh, then why make Expr an Enum?
09:21:00 <Gracenotes> > minBound :: Expr
09:21:02 <lambdabot>   minBound
09:21:11 <tromp__> > succ a
09:21:11 <chessguy_work> > [f..g] :: Expr
09:21:14 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
09:21:14 <lambdabot>   succ a
09:21:22 <chessguy_work> > [f..g] :: [Expr]
09:21:24 <lambdabot>   * Exception: not a number
09:21:52 <ehird> Yay! gtk2hs finally compiles.
09:21:54 <Gracenotes> but, anyway, g is bound to the argument passed through stdin :)
09:22:50 <roconnor> ehird: I'm sure there will be further problems
09:23:09 <ehird> roconnor: Oh, of course, but I fixed the "passes an invalid package to ghc-pkg" thing.
09:23:13 <athos> is there some easy way to install some package installed with cabal install? because i did some updates on some programs (which forced e.g. ncurses to update), yi prompts me with: Launching custom yi: "/home/phil/.yi/yi-i386-freebsd"
09:23:19 <athos> /libexec/ld-elf.so.1: Shared object "libncurses.so.5.6" not found, required by "yi-i386-freebsd"
09:23:24 <Gracenotes> gtk2hs makes my packaging system sad
09:23:25 <athos> but --reinstall didn't help
09:23:26 <ehird> I imagine future issues will be caused by the fact that I'm using gtk-quartz as a Framework on os x.
09:23:42 <ehird> All I want is a non-console yi... :P
09:24:22 <bos> @seen dons
09:24:23 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 9h 59m 56s ago.
09:24:42 <athos> or is it possible that cabal got broken, too?
09:25:15 <drigz> Does anyone know why my HGL window only updates when I move my mouse over it?
09:25:20 <athos> actually i thought cabal install yi --reinstall would force it to "reconfigure", so that it knows that there is a new ncurses/no ncurses.5.6 anymore
09:27:58 <bos> @seen dcoutts
09:27:58 <lambdabot> dcoutts is in #haskell-in-depth, #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I don't know when dcoutts last spoke.
09:30:05 <athos> > cycle [1,2]
09:30:08 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
09:30:55 <mmorrow> here's my attempt at "BASIC" (from augustss' blog post). i'm not sure how he did his, i can't seem to get rid of the parens i have to add in 40: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1219#a1219
09:31:14 <lispy> since GHC uses dictionaries to implement type classes, is there any reason why would couldn't instance a type class dynamically?
09:31:40 <mmorrow> other than the extra occasional parens in IF .... (THEN ...) it works similarly i think
09:32:32 <mmorrow> lispy: but then you couldn't tell statically whether or not "fmap"/whatever exists for a type
09:32:40 <Cheshire> mmorrow, I was expecting GOTO implemented in terms of Cont (ContT IO)
09:32:57 <mmorrow> Cheshire: oh, i'm just trying to reproduce it syntactically
09:33:10 <cadr> @seen Lemmih
09:33:10 <lambdabot> Lemmih is in #haskell-in-depth and #haskell. I last heard Lemmih speak 5h 3m 21s ago.
09:33:10 <Cheshire> well I haven't seen any implementation of this
09:33:10 <mmorrow> independent of however you'd choose to implem it
09:33:21 <mmorrow> look at augustss' new blog post :)
09:33:31 <mmorrow> (he's generating asm via llvm)
09:33:36 <mmorrow> (from BASIC :)
09:33:40 <Stettro> http://irc.lv/video?id=8ly6FeQQdR8A
09:33:40 -Stettro(n=Deeed@213.175.96.104)- http://irc.lv/video?id=8ly6FeQQdR8A
09:33:51 <lispy> mmorrow: Yeah, I guess that is a pretty big draw back
09:34:02 <mauke> creative spam
09:34:15 <ehird> W00t! gtk2hs  compiled
09:34:18 <ehird> /crossfingers... make install
09:35:13 <Eridius|lappy> woot! When I installed it on my desktop it got the linker flags wrong and I can't actually use it :/
09:35:24 <mauke> ehird: are you using ghc-6.10?
09:35:33 <ehird> mauke: yeah.
09:35:34 <ehird> Oh sheesh.
09:35:40 <ehird> The hello world gtk2hs demo segfaults
09:35:42 <ehird> :-(
09:36:01 <ehird> not good not good
09:36:06 <chessguy_work> it's a feature, not a bug
09:36:23 <drhodes> OO enforces explicitly a convention, obj.method(arg) -- (note the ordering). Is there a haskell convention that say (method obj arg) or (function arg1 arg2) where arg1 is the thing to be adjuest in some way by arg2?
09:36:40 <drhodes> adjusted
09:36:46 <mmorrow> augustss: ping (how did you get the BASIC to work (syntactically) without any parens??)
09:36:50 <ehird> drhodes: The thing to "adjust" generally comes last.
09:36:55 <ehird> For currying, e.g.:
09:37:02 <ehird> sum = foldl' (+) 0
09:37:06 <ehird> then you can do sum [1,2,3]
09:37:21 <drhodes> ok, grat ehird, thanks!
09:37:24 <ehird> :)
09:38:06 <augustss> mmorrow: smoke and mirrors!
09:38:12 <Gracenotes> or sum', to distinguish
09:38:24 <chessguy_work> @src sum
09:38:24 <lambdabot> sum = foldl (+) 0
09:38:28 <Gracenotes> oh, kinda not the point here. never mind >_>
09:38:29 <mmorrow> augustss: grrrr!! :)
09:38:45 <augustss> mmorrow: I'll leave that as a puzzle. :)
09:39:07 <ehird> mmorrow: typeclass magic?
09:39:18 <mmorrow> hehe, i've almost got it but IF .. THEN .. is killing me, (and a few other places too)
09:39:28 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1219#a1219
09:39:29 <ehird> hrm... I wonder why it crashed
09:39:37 <augustss> ehird: Even IncoherentInstances
09:39:46 <ehird> augustss: good lord.
09:39:54 <mmorrow> ooh, i haven't gone there yet
09:40:01 <ehird> augustss: I... I think you should apologize.
09:40:09 <mmorrow> good clue
09:40:21 <Gracenotes> mmorrow: yeah, you don't use any extensions :)
09:40:32 <Gracenotes> not yet anyhow >_>
09:40:56 <dancor> @. pl undo do{a<-f;b<-g;h;return(f,g)}
09:40:56 <lambdabot> f >> (g >> (h >> return (f, g)))
09:41:01 <Toxaris> drhodes: I tend to think more of functions then of values. Lets consider "cons :: a -> [a] -> [a]; cons = (:)". one could read that as "given an element and a list, cons returns a new list with the element in front". I read it as "given an element, cons returns a list-changing function which adds the element in front", that is: "a -> ([a] -> [a])"
09:41:04 <dancor> @. pl undo do{a<-f;b<-g;h;return(a,b)}
09:41:05 <lambdabot> (g >>=) . (((h >>) . return) .) . (,) =<< f
09:41:46 * dancor is sure there's a nice way to do n independent monadic things and return m of them
09:42:33 <dancor> well they're not independent the order does matter
09:42:41 <augustss> mmorrow: You have to be able to handle '100 PRINT 2+2' :)
09:43:22 <mmorrow> crap
09:43:25 <rwbarton> augustss: Does your BASIC handle arbitrary combinations of features you've used, like  40 IF X + 1 <> 12 THEN 20 ?
09:43:56 <augustss> rwbarton: I don't know without testing.  lol
09:44:00 <mmorrow> i'm thinking of trying the printf class strategy thing (either literally or "somehow")
09:44:05 <drhodes> so tossing around partial applications is only possible if the last arg is the returned-thing.
09:44:07 <rwbarton> I wondered if that might be the answer. :)
09:44:15 <mmorrow> heh
09:45:22 <dancor> drhodes: well there's always like flip
09:45:30 <drigz> dancor: mapM [a,b] >>= (\[x,y]->(x,y))?
09:45:50 <augustss> rwbarton: it does!  I'm amazed!
09:46:00 <mmorrow> nice
09:47:14 <augustss> mmorrow: The thing I'm pondering now is how to do e.g. '10 PRINT "X is "; X'
09:48:59 <mmorrow> hmm, too bad a comma can't be used in syms, or ":," would almost look like it
09:49:09 <mmorrow> err, i guess though you'd need parens
09:49:28 <chessguy_work> rofl @ implementing BASIC in haskell and comparing the speed to c
09:49:32 <chessguy_work> augustss++
09:49:40 <augustss> mmorrow: BASIC also allows 'PRINT X,Y'.  Which is impossible.
09:50:12 <mmorrow> augustss: ooh, for "; X" maybe you could just have a single X/whatnot |-> PRINT X
09:50:21 <mmorrow> then you could stick a real ';' in there
09:50:52 <mmorrow> err, but then you couldn't have a numeric label
09:51:26 <cypher-> hi!
09:51:49 <mmorrow> well, you could somehow merge "40 ; X" into a single "40 PRINT X" afterwards i guess (or something)
09:52:01 <augustss> mmorrow: I think the ; is possible, but I'd have to change my monad totally
09:52:10 <mmorrow> ah
09:53:09 <mmorrow> Language.Haskell.TH.Quote.QuasiQuoter++ :)
09:53:40 <Saizan_> that's cheating
09:53:55 <mmorrow> ;)
09:54:42 <mauke> success has been achieved
09:54:53 <mauke> % ./helloworld
09:54:54 <mauke> Hello World
09:54:54 <mauke> A "clicked"-handler to say "destroy"
09:54:58 <augustss> chessguy_work: I'm glad my blog post had the intended reaction from you.  Not everyone has a twisted sense of humor.
09:55:47 <mmorrow> yeah, that was a nice touch, a little salt in the wound
09:57:12 <ehird> mauke: Yeah, well...
09:57:17 <ehird> gtk works, I've discoevered.
09:57:19 <ehird> so it's gtk2hs :(
09:57:59 <mauke> are you using the darcs version?
09:58:06 <ehird> Nope.
09:58:10 <mauke> I am
09:58:14 <ehird> 0.10 RC. And, uh, on OS X, using quartz gtk.
09:58:17 <ehird> So, rather unconventional setup.
09:58:22 <ehird> I'm not surprised it's breaking.
09:58:35 <ehird> The error seems to be in pango, clearlooks is calling it and it's trying to do *NULL.
10:03:54 <ehird> i wonder what the issue is
10:04:06 <ehird> I can't see how gtk2hs could break it
10:04:50 <athos> :t append
10:04:51 <lambdabot> Not in scope: `append'
10:04:55 <athos> :t mappend
10:04:56 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:05:24 <athos> @index mappend
10:05:24 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
10:09:33 <lispy> I'm reading Fun with Functional Dependencies and realizing just how backwards type class based computations are
10:09:46 <cypher-> I'm trying to write a small CL-evaluator, what would be the best way to encode the order of evaluation in the reduction function?
10:10:18 <lispy> cypher-: not sure what you mean
10:10:43 <ddarius> cypher-: If you use a monadic style, it will be trivial.
10:10:50 <ddarius> (or rather, you won't have a choice)
10:10:53 <cypher-> lispy: I want to have for example one fn. that evaluates using CBV and another that does CBN
10:11:20 <augustss> lispy: backwards?  it's just Prolog-like :)
10:11:22 <cypher-> continuations seemed vaguely reasonable, should I just pack it in the continuations monad?
10:12:07 <ddarius> cypher-: The simplest thing would be to write all your functions to handle CBN and simply model CBV as functions that force their arguments first.
10:12:41 <athos> > let f = [[1,2,3],[4,5,6],[7,8,9]]; b = [48,51,54] in zipWith (++) (map init f) (map (:[]) $ reverse b)
10:12:43 <lambdabot>   [[1,2,54],[4,5,51],[7,8,48]]
10:12:49 <lispy> This athor gives multiplication like this, mul Zero b = b; mul (Succ a) b = add b (mul a b).  Now in type classes that is: class Mul a b c | a b -> c where; instance Mul Zero b Zero; instance (Mul a b c, Add b c d) => Mul (Succ a) b d.  The last bit make sense if you spend time on it, but it's hard to figure out :)
10:12:53 <athos> hmm, is there a nicer way for doing this?
10:12:55 <lispy> augustss: ^^
10:13:22 <athos> so what it actually does is drop last elements from each list of f, and insert the elements of b there instead
10:13:45 <lispy> augustss: it's not the prolog aspect so much (I don't think), but that you have to name your recursive call on the left hand side of the =>
10:13:58 <ddarius> cypher-: This can be noted that a CBV translation of a function space into a monadic semantics turns a -> b into a -> m b and a CBN version turns a -> b into m a -> m b and you go from the latter to the former by precomposing with return.
10:14:04 <lispy> augustss: Where they say, Add b c d, to bind d to the result of adding b and c
10:14:17 <cypher-> ddarius: sounds like a good idea
10:14:22 <cypher-> ddarius: thanks!
10:14:26 <augustss> lispy: it's the relational way of programming
10:14:40 <ehird> Yi/UI/Gtk/ProjectTree.hs:19:40:
10:14:40 <ehird>     Module `Graphics.UI.Gtk' does not export `Event'
10:14:44 <ehird> Goddarnit
10:14:59 <ddarius> Many logic languages allow the equivalent of both: f(X) :- b(X) and b(X) -: f(X).
10:15:00 <lispy> augustss: to be fair, my complaints are probably predominantly syntatic
10:15:33 <augustss> lispy: yes, it's a bit bizarre :)
10:17:01 <lispy> Also, I suck at prolog
10:17:20 <Gracenotes> A public service announcement: if you find yourself overusing the Writer monad, tell (Sum 1)
10:17:26 <lispy> This author showed me even/odd in prolog and I really strugled with it
10:17:33 <lispy> Gracenotes: heh
10:17:35 <cadr> Hi all:  I'm trying to make a patch for SDL-Mixer.  Don sent fixed code to a mailing list a while pack, and I'm trying to make a patch of that.  But am having a few problems.
10:17:47 <lispy> Gracenotes: or tell (sum ones)
10:17:56 <lispy> > sum ones
10:17:57 <ddarius> even/odd in Prolog should look pretty much just like the Haskell definition.
10:17:58 <lambdabot>   Not in scope: `ones'
10:18:07 <cadr> First - what is the darcs repo for things in hackage?
10:18:21 <lispy> ddarius: horn clauses or whatever the -: thing in prolog is called is odd to me
10:18:22 <pumpkin> many of them are on code.haskell.org
10:18:26 <Cheshire> lispy, here:  data Polarity p where Zero :: Polarity Even; ESucc :: Polarity Even -> Polarity Odd; OSucc :: Polarity Odd -> Polarity Even
10:18:36 <cadr> pumpkin: but not all?
10:18:50 <ddarius> lispy: Just read it as = and you will get many logic programs.
10:18:59 <Olathe> (a+1)*b = b+a*b
10:19:02 <Cheshire> lispy, so if you confuse ESucc and OSucc, you can easily figure out say:  the type of  (Succ (Succ (Succ Zero)))  as well as all the inhabitants of  Polarity Odd
10:19:06 <pumpkin> cadr: some keep their source on github or the owners' sites
10:19:13 <Saizan_> cadr: each author gets to choose where he keeps the code
10:19:21 <Gracenotes> is even/odd in prolog somewhat like that in the lambda calculus?
10:19:22 <lispy> ddarius: but isn't it really a backwards implication arrow?
10:19:27 <BMeph> @remember Gracenotes A public service announcement: if you find yourself overusing the Writer monad, tell (Sum 1)
10:19:28 <lambdabot> It is stored.
10:19:29 <Gracenotes> take True, keep switching as you go down to zero?
10:19:31 <cadr> hm.  ok.
10:19:32 <ddarius> Oh, and I guess you'd also have to get used to "output" variables rather than return values.
10:19:54 <Cheshire> p :- q.  means  RuleX :: q -> p
10:19:59 <Cheshire> sorry
10:20:03 <Cheshire> p :- q.  means  RuleX :: Q -> P
10:20:17 <Gracenotes> hm... you could probably ask for help using Reader, but that doesn't compile >_>
10:20:21 <ddarius> lispy: Yes, :- is reverse implication.
10:21:43 <Olathe> Ahh, you can rewrite it.
10:21:45 <ddarius> lispy: Anyway, append [] ys = ys; append (x:xs) ys = x:append xs ys;  append([],Ys,Ys).  append([X|Xs],Ys,[X|Zs]) :- append(Xs, Ys, Zs).  You should be able to see the similarities.
10:21:58 <Gracenotes> in untyped -- iseven = \n . (\s z . s z) (\a . a (\s z . z) (\s z . s)) (\s z . s)
10:22:42 <Cheshire> iseven n = n not true   ?
10:22:48 <Cheshire> oops
10:22:55 <Gracenotes> er. actually, replace (\s z . s z) with n
10:23:05 <Gracenotes> yeah, I just copy-pasted from testing it with one
10:23:22 <Cheshire> foldN succ zero = ...; isEven = foldN not True
10:24:29 <chessguy_work> @quote GraceNotes
10:24:30 <lambdabot> No quotes match. I feel much better now.
10:24:35 <chessguy_work> @quote Gracenotes
10:24:36 <lambdabot> Gracenotes says: You are likely to be eaten by a poset
10:24:45 <chessguy_work> @quote Gracenotes
10:24:46 <lambdabot> Gracenotes says: You are likely to be eaten by a poset
10:24:59 <chessguy_work> @flush
10:25:00 <lambdabot> Not enough privileges
10:26:02 <mauke> @flush
10:26:02 <lambdabot> Not enough privileges
10:26:05 <mauke> bah
10:26:11 * chessguy_work snickers
10:26:42 <mauke> @flush
10:26:55 * mauke snickers
10:28:46 <olivierp> Hi all! In type inference, does the context part of function declarations (type classes) get propagated at all to callers?
10:29:06 <mauke> what do you mean?
10:29:21 <lispy> :t \x -> show x
10:29:22 <Olathe> > let rewrite xs = f' (reverse xs) where f' (x:xs) = f'' x ++ " where " ++ (intercalate "; " . map f'') xs; f'' = f''' . words; f''' xs = unwords (last xs:"=":init xs) in rewrite ["Mul a b c", "Add b c d", "Mul (Succ a) b d"]
10:29:23 <lambdabot> forall a. (Show a) => a -> String
10:29:24 <lambdabot>   "d = Mul (Succ a) b where d = Add b c; c = Mul a b"
10:29:30 <lispy> olivierp: does that help?
10:30:15 <Olathe> Hmm, close.
10:30:30 <JoshTriplett> I'd like to have a BitStream type, analogous to a lazy ByteString but supporting operations that peel off N bits as an integer.  What representation should I use for reasonable efficiency?  Right now I lean towards something like BitStream { position :: Integer, partial :: Word8, stream :: L.ByteString }.  Any better representation?
10:30:35 <olivierp> lispy: not really, this much i knw
10:30:47 <lispy> olivierp: I guess I didn't quite understand the question
10:30:53 <Gracenotes> really, though, the Writer monad is useful for in seeing how many computations are required to calculate recursive fibonacci
10:31:13 <Gracenotes> the answer, as expected.. a lot :/
10:32:12 <Gracenotes> > 2692537/1346269 -- calculations/final answer
10:32:14 <lambdabot>   1.9999992572063978
10:32:23 <Gracenotes> o-o
10:32:24 <olivierp> mauke, lispy: it's a bit hard to get to the gist of it without dumping all my code on you... i'm gonna try
10:32:45 <Gracenotes> oh, I see. The calculation trees are nearly duplicated all the way down
10:32:52 <olivierp> JoinMonad.hs:147:9:
10:32:52 <olivierp>     Could not deduce (J.Assign (VAR (J.Sync r)) v')
10:32:52 <olivierp>       from the context (SyncArg a, J.CollectArgs (J.Sync r))
10:32:52 <olivierp>       arising from a use of `lookupVar' at JoinMonad.hs:147:9-33
10:32:53 <olivierp>     Possible fix:
10:32:53 <olivierp>       add (J.Assign (VAR (J.Sync r)) v') to the context of
10:32:54 <olivierp>         the constructor `SC'
10:32:56 <olivierp>       or add an instance declaration for (J.Assign (VAR (J.Sync r)) v')
10:32:58 <olivierp>     In the expression: lookupVar name resultVars
10:33:03 <Botje> put it on a pastebin :(
10:33:13 <Cheshire> oliverep, what are you programming?
10:33:15 <olivierp> basically
10:33:46 <olivierp> i'm surprised by what the context has
10:33:52 <mauke> type inference is all around us. it's in the air you breathe, it's there when you stare out of the window, when you go to church, when you pay your taxes
10:34:18 <elbar> dejavu?
10:34:22 <Gracenotes> what about atheists? Do we have the unit type?
10:34:22 <olivierp> i was expecting more things in it
10:35:04 <lispy> olivierp: your error message may have incomplete types
10:35:16 <olivierp> (sorry about typing speed switched to dvorak yesterday)
10:35:22 <lispy> dvorak++
10:35:36 <mauke> ａｏｅｕ
10:35:37 <lament> i ljvu dvjrox
10:35:38 <lament> oops
10:37:50 <olivierp> pastebin and hpaste seem to be down
10:38:07 <mauke> @where hpaste2
10:38:07 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
10:38:44 <olivierp> oops, wrong tld
10:39:37 <Gracenotes> I think fibonacci just crashed my computer :(
10:40:28 <Gracenotes> it's like a fork bomb or something.
10:41:33 <olivierp> http://pastebin.com/m12596198
10:42:01 <olivierp> hopefully this is enough
10:42:10 <Kamina> an 807 year old fork bomb....
10:42:29 <Olathe> > let rewrite = concat . f . reverse where f (x:xs) = (g . reverse . words) x:" where ":intersperse "; " (map (h . reverse . words) xs); g (x:xs) = unwords (reverse (x:"=":xs)); h (x:xs) = unwords (x:"=":reverse xs) in rewrite ["Mul a b c", "Add b c d", "Mul (Succ a) b d"]
10:42:30 <lambdabot>   "Mul (Succ a) b = d where d = Add b c; c = Mul a b"
10:42:33 <Olathe> There we are.
10:43:58 <redditbot> Galois' Blog : Equivalence and Safety Checking in Cryptol
10:44:46 <BMeph> My breath smells fresher, when I rinse with Cryptol. ;p
10:44:54 <Cale> Kamina: 807 year old?
10:44:55 <Gracenotes> > 7049155/3524578
10:44:57 <lambdabot>   1.9999997162780907
10:45:44 <dons> ?yow
10:45:44 <lambdabot> Spreading peanut butter reminds me of opera!!  I wonder why?
10:47:27 <augustss> Well all wonder why.
10:47:33 <Kamina> the fibonacci numbers are as old i think
10:48:00 <Cale> Kamina: ah :)
10:48:13 <Cale> Kamina: figured it had to be something of that nature :)
10:48:29 <olivierp> (actually my Join.Join is that one : http://hackage.haskell.org/packages/archive/join/0.2/doc/html/src/Join-Join.html)
10:48:33 <Cale> oh, I missed Gracenotes' remark :)
10:50:08 <Gracenotes> I'm doing a sort of Russian Roulette: how much of fibonacci can my computer handle before it's too much
10:50:20 <Gracenotes> right now I'm doing 33. I think it might crash on this one.
10:51:02 <Gracenotes> > 11405773/5702887
10:51:04 <lambdabot>   1.9999998246502166
10:51:23 <augustss> 33?  that's not much
10:52:02 <Gracenotes> well, I'm also using it with the Writer monad, to get the number of calculations done
10:52:13 <Gracenotes> hm. Writer is lazy by default, right?
10:52:39 <dons> if you have not read this, read   it now: http://www.reddit.com/r/programming/comments/7vfgv/urk_only_a_basic_programmer_could_appreciate_this/
10:52:45 <dons> the power of EDSLs, in careful hands.
10:53:21 <Gracenotes> yes.. it must be.
10:53:37 <sm_> lol!
10:53:39 <mathijs> Hi all, I'm trying out QuickCheck, but I'd like to keep my testing code separate from the real/implementation code. The thing I'm testing is a library and I don't export everything in there. Is there a way to import everything just for testing?
10:54:31 <augustss> mathijs: I've not yet seen a satisfactory way of using QC (from that point of view)
10:55:01 <mathijs> augustss: so it's best to put the test code into the real code?
10:55:22 <mathijs> I mean: in the same source file
10:55:33 <augustss> mathijs: I guess so.  And then use CPP to avoid code bloat if you worry about that.
10:55:39 <Gracenotes> augustss: well, 40 crashed my computer
10:55:45 <bd_> mathijs: one option is to have some internal modules that export everything, then have some public use modules that re-export only the public API
10:55:58 <bd_> your test scripts then can directly import the internal modules
10:56:42 <mathijs> bd_: so basically put an 'api' layer inbetween?
10:57:13 <bd_> pretty much
10:58:45 <mathijs> bd_: sounds ok. is this a common standard? what about packaging? I mean say I have MyLib_internal.hs and Mylib.hs, Nothing stops people from importing Mylib_internal.hs.
10:59:18 <bd_> mathijs: Hmm, you ight be able to restrict it by not listing the internal one in your cabal file
10:59:21 <bd_> not sure though
10:59:22 <Cale> mathijs: The package can.
10:59:44 <Cale> mathijs: If Mylib_internal is not an exposed module of the package, it won't be visible.
10:59:50 <mathijs> bd_: well, at least they will know it's not safe to do in case I change my implementation.  Anyway, is there a naming-convention for this extra layer?
11:00:22 <bd_> I have no idea :)
11:00:23 <Gracenotes> okay. 34 it is...
11:00:25 <Cale> Mylib.Internal is more likely ;)
11:00:25 <mathijs> Cale: ok, but Mylib itself can still import Mylib_internal?
11:00:30 <Cale> mathijs: yes.
11:00:49 <mathijs> Cale: ok thanks. I'll to it that way.
11:00:56 <Cale> (Underscores are ugly! :)
11:01:15 <mathijs> I know, picked up that habbit in Ruby :)
11:01:52 <mathijs> but 13-character operators like haskell is ugly too :D
11:03:41 <olivierp> right, I need to be off, if anyone has an idea about my problem please drop me a line: o.pernet@gmail.com
11:03:44 <Gracenotes> #^^<*.*>^^#
11:04:08 * Gracenotes hang glides through ghci
11:04:36 <augustss> olivierp: what is your problem?
11:05:00 <augustss> olivierp: oh, i see it now
11:05:10 <lispy> augustss: that he didn't email haskell-cafe instead :)
11:06:10 <olivierp> augustss, lispy: yes should have done that in hindsight
11:06:47 <olivierp> anyway, thanks for your help. bye
11:06:57 <sjanssen> http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html is a blog post for the ages
11:08:28 <augustss> sjanssen: :)
11:10:41 <ehird> sjanssen: it's amazing.
11:10:53 <ehird> give the source to BASIC.hs! :D
11:11:49 <augustss> ehird: Nah!  I have found the killer app.  Now I'm gonna make a fortune selling it.
11:11:57 <ehird> I'll buy it.
11:12:00 <ehird> How much?
11:12:32 <ehird> Hey...
11:12:33 <ehird>     50 IF I <> 100000000 THEN 30
11:12:34 <ehird> should be
11:12:36 <ehird>     50 IF I <> 100000000 THEN GOTO 30
11:12:38 <ehird> no?
11:12:47 <Nafai> Haha
11:12:48 <augustss> No
11:12:58 <ehird> augustss: It's meant to be basic is it not?
11:13:09 <augustss> I'm using original Dartmouth BASIC
11:13:13 <ehird> Ouch.
11:13:23 <lament> augustss: you're my hero.
11:13:29 <dons> world's fastest BASIC?
11:13:36 <augustss> could be :)
11:13:45 <ehird> augustss: Does it use template haskell to open the source file it's imported in and writes out equivalent haskell after parsing it and then kills the compiler before it meddles with it?
11:13:47 <ehird> I bet it does.
11:13:50 <ehird> You're tricking us all.
11:14:01 <dons> llvm, surely.
11:14:05 <augustss> ehird: not template Haskell.  You see all the source right there.
11:14:06 <dons> with lots of lennart-style overloading
11:14:13 <ehird> augustss: What I meant is,
11:14:15 <dons> the asm doesn't look like GHCs
11:14:22 <ehird> it uses template haskell to run haskell at compile time
11:14:23 <dons> at least, the labels are funky.
11:14:33 <augustss> ehird: No TH
11:14:34 <ehird> which then greps for the file you're compiling
11:14:38 <ehird> and parses the basic part
11:14:41 <int-e> augustss: llvm?
11:14:41 <ehird> and writes out its own binary
11:14:44 <ehird> then quits the compiler
11:14:46 <ehird> :D
11:14:52 <augustss> int-e: yes, LLVM
11:15:07 <dons> llvm is a haskell edsl killer app
11:15:49 <lament> does BASIC actually use =: ?
11:15:57 <augustss> lament: no :(
11:16:07 <dons> augustss: going to write a functional pearl for the HW? :)
11:16:09 <augustss> lament: it uses =
11:16:18 <lament> augustss: oh :(
11:16:23 <ehird> augustss: just use an equivalent-looking unicode char
11:16:23 <ehird> :-D
11:16:33 <augustss> dons: pearl?  or puke?
11:16:39 <dons> hehe...
11:17:31 <augustss> dons: not a bad idea, actually.  I might do that.
11:18:25 <dons> I think summarising the state of the art of: overloading, small EDSLs, llvm would be very useful and fun
11:18:31 <dskippy> I'm having a hard time getting a simple isInteger function to work. The type checker doesn't like it. I'm basically trying to do truncate(r) == r. I have my code here. Is there a way to check if a Float is an integer value without my own function? Here's my code: http://pastebin.com/d305f1691
11:19:23 <tromp__> get the fractional part?
11:19:55 <drigz> @type \r -> (fromIntegral $ truncate r) == r
11:19:57 <lambdabot> forall a. (RealFrac a) => a -> Bool
11:20:29 <ehird> dskippy: the two arguments to == aren't of the same type
11:20:34 <ehird> you can't do that
11:20:39 <ehird> what drigz said is right
11:20:58 <dskippy> drigz, why apply strictly with $ in that expression?
11:20:58 <Olathe> @type truncate
11:21:00 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:21:12 <twanvl> ?type \r -> snd (properFraction r) == 0
11:21:14 <lambdabot> forall b. (RealFrac b) => b -> Bool
11:21:22 <drigz> dskippy: 'strictly'?
11:21:37 <dskippy> $. Doesn't that mean strict not lazy application?
11:21:38 <lunabot>  luna: parse error on input `)'
11:21:44 <tromp__> > properFraction 5.43
11:21:45 <drigz> dskippy: no, just function application
11:21:46 <lambdabot>   (5,0.4299999999999997)
11:21:54 <koeien> dskippy: ($!) is what you mean
11:21:57 <dskippy> Oh.
11:22:02 <drigz> @pl f $ g a
11:22:03 <lambdabot> f (g a)
11:22:17 <Olathe> @type properFraction
11:22:18 <dskippy> Just a way to avoid the annoying left association.
11:22:19 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
11:22:33 <lschn00> @type concat
11:22:34 <tromp__> > properFraction -5.43
11:22:35 <lambdabot> forall a. [[a]] -> [a]
11:22:35 <lambdabot>       No instance for (Fractional (a -> (b, a)))
11:22:36 <lambdabot>        arising from the lite...
11:22:43 <tromp__> > properFraction (-5.43)
11:22:44 <lambdabot>   (-5,-0.4299999999999997)
11:23:25 <drigz> @type \r -> (snd $ properFraction r) == 0
11:23:27 <lambdabot> forall b. (RealFrac b) => b -> Bool
11:23:40 <tromp__> @let isIntegral = (==0.0) . snd . properFraction
11:23:42 <lambdabot>  Defined.
11:23:52 <tromp__> > isIntegral  5.12
11:23:53 <lambdabot>   False
11:23:56 <tromp__> > isIntegral  5.0
11:23:57 <lambdabot>   True
11:24:06 <drigz> tromp__: i don't think you need 0.0 there?
11:24:09 <lschn00> @type (>>=)
11:24:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:24:12 <Olathe> > isIntegral (0/0)
11:24:14 <lambdabot>   True
11:24:17 <int-e> > isIntegral $ pi^50
11:24:19 <lambdabot>   True
11:24:19 <Olathe> > isIntegral (1/0)
11:24:21 <lambdabot>   True
11:24:42 <tromp__> > pi^50
11:24:44 <lambdabot>   7.202671944715793e24
11:24:59 <tromp__> yep, looks integral to me:)
11:25:05 <Olathe> @src properFraction
11:25:06 <lambdabot> Source not found. My brain just exploded
11:26:02 <tromp__> > isIntegral  0.0000000000000000000000000000000000000001
11:26:03 <lambdabot>   False
11:26:11 <lilac> > exp 1 ** pi - pi :: CReal
11:26:12 <lambdabot>   19.9990999791894757672664429846690444960689
11:27:05 <drigz> >properFraction $ pi^50
11:27:17 <drigz> > properFraction $ pi^50
11:27:19 <lambdabot>   (7202671944715793137139712,0.0)
11:27:23 <lilac> > properFraction $ exp 1 ** pi - pi
11:27:25 <lambdabot>   (19,0.9990999791894701)
11:28:26 <tromp__> > 1.32 `mod` 1
11:28:27 <lambdabot>   Add a type signature
11:28:41 <tromp__> > 1.32 `mod` 1 :: Double
11:28:42 <lambdabot>       No instance for (Integral Double)
11:28:43 <lambdabot>        arising from a use of `mod' at...
11:28:52 <tromp__> > 1.32 `rem` 1 :: Double
11:28:54 <lambdabot>       No instance for (Integral Double)
11:28:54 <lambdabot>        arising from a use of `rem' at...
11:29:22 <drigz> > 1.32 `Data.Fixed.mod'` 1
11:29:24 <lambdabot>   0.32000000000000006
11:29:48 <asgaroth> Can anyone explain what callCC is used for besides providing a shortcut for exiting the computation?
11:33:10 <lament> asgaroth: re-entering the computation
11:33:47 <lament> asgaroth: a web server is a good example. Save a continuation for every page a user visits. When they click the Back button, you resurrect the old continuation - it's as if they never went to the next page.
11:34:31 <asgaroth> lament: Thanks
11:36:10 <augustss> lament: good example!  I have to remember that
11:36:14 <pastah> i have [ IO () ] and want it to be a IO ()
11:36:22 <pastah> sequence_?
11:36:27 <pastah> @type sequence_
11:36:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
11:36:29 <Cale> pastah: yes
11:36:48 <pastah> this is gonna be awsum. thanks cale :)
11:36:51 <Cale> pastah: If you want to run each of the actions in the list.
11:37:09 <pastorn> indeed i do :)
11:37:13 <mmorrow> the PLT scheme webserver paper is a good one
11:38:25 <mmorrow> http://www.cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/
11:38:52 <Cale> Though... I'm not sure that the ContT monad transformer really suffices for a continuation-based webserver, does it?
11:39:17 <Cale> Don't you also need a way to serialise continuations?
11:39:43 <dolio> Probably depends how robust you want it to be.
11:39:45 <mmorrow> iirc the plt webserver stores continuations in a table (which are closures of scheme code (txt?))
11:40:10 <mmorrow> and unique id nums in the url refer to particular continuations
11:40:24 <dolio> If you don't mind losing everything when your program shuts down, you could store continuations in a map with a unique id while it's running. :)
11:40:44 <mmorrow> totally! i've played with doing that in a fastcgi program
11:41:09 <mmorrow> but i never really went beyond messing around with it
11:41:37 <lament> i don't know whether Seaside serializes continuations
11:41:48 <ehird> it doesn't
11:41:50 <dskippy> This is still not working for me. I'm getting "No instance for (Floating Integer) arising from use of 'sqrt'" but I thought putting a fromItegral around the argument to sqrt should solve that problem. http://pastebin.com/d3ad0cec9
11:42:03 <ehird> continuation frameworks seem nice, but then ugh.
11:42:38 <waern> augustss: what do you think about this notation for math: http://www1.chapman.edu/~jipsen/asciimath.html - Is it too limited for what you do at work?
11:43:05 <mauke> dskippy: b is not an Integer
11:43:40 <dskippy> mauke: I know. Where am I using it as an Integer?
11:43:46 <mauke> dskippy: in line 5
11:43:56 <dskippy> Ah!
11:44:00 <redditbot> The power of EDSLs: BASIC / GCC / Haskell / LLVM (?) Oh my, Lennart!
11:44:30 <dskippy> Thank you.
11:45:02 <lament> that's a pretty horrible title
11:47:27 <thetallgu1> anyone know if you can derive a class instance post-hoc in 6.10?
11:47:47 <thetallgu1> that is, if in a library there is a definition  data Foo = ...
11:48:10 <thetallgu1> can I get ghc to derive an instance of Show in another module?
11:48:48 <mauke> deriving instance Show Foo
11:49:02 <thetallgu1> mauke: thanks.
11:49:50 <cadr> I'm trying to get rid of a package I installed via cabal.  I saw some reference to using 'ghc-pkg unregister', but it doesn't seem to work for me.  When I do "ghc-pkg list SDL-mixer", it lists things, but when I do "ghc-pkg unregister SDL-mixer", it says "cannot find package SDL-mixer".  Any thoughts?
11:50:21 <mauke> how does it list things?
11:50:37 <Lemmih> cadr: Try with --user
11:51:42 <cadr> Lemmih: ah, thanks
11:53:05 <cadr> Lemmih: is it then safe to delete the files from "~/.cabal/packages/hackage.haskell.org/SDL-mixer"?
11:53:51 <Lemmih> cadr: Yes.
11:53:58 <cadr> cool
11:54:21 <Philonous> Strange. ever since I reinstalled ghc on my box I get "Loading package process-1.0.1.1 ... linking ... <interactive>: internal error: R_X86_64_PC32 relocation out of range: (noname) = 0x7c18012a8 " every time I try to start system commands in ghci.
11:54:23 <hcube> Lemmih: do you know any project uses hode?
11:54:35 <Lemmih> hcube: I do not.
11:55:14 <Lemmih> hcube: Then again, people only tell me they use my code when they find a bug.
11:55:42 <hcube> ok
11:56:52 <Lemmih> hode might be hugely popular and bug-free. Although, completely unknown and broken to the bone is more likely. (:
11:57:00 <athos> hmm, is there a "nicer" way of writing map (:[]) (last x) or [ [y] | y <- last x ]?
11:57:20 <athos> at least map (:[]) looks really ugly
11:57:34 <pastorn> @type last
11:57:35 <lambdabot> forall a. [a] -> a
11:57:44 <Cheshire> return = (:[])
11:57:56 <mauke> map return
11:58:08 <pastorn> map (head . reverse)
11:58:15 <pastorn> athos: is that correct?
11:58:26 <pastorn> athos: or maybe (take 1)
11:58:31 <Cale> er
11:58:39 <mauke> liftM (liftM return) last
11:58:44 <athos> yeah, map (head . reverse) wouold be last
11:58:50 <athos> *would*
11:58:54 <athos> oh
11:58:56 <athos> map.. wait! :)
11:59:10 <pastorn> athos: but you have [y], so maybe take 1 is what you want if you need to have the same type
11:59:16 <Gracenotes> > (:[]).(:[]).(:[]).(:[]).(:[]).(:[])      $0.0   --don't let the robot monkeys catch you!
11:59:18 <lambdabot>   [[[[[[0.0]]]]]]
11:59:28 <pastorn> Gracenotes: beautiful
12:00:15 <Cale> athos: What's wrong with what you've got?
12:01:14 <athos> Cale: nothing, but it looked kinda strange/ugly to me and i want to avoid writing crappy code (eventually there *will* be some crappy code i think :))
12:01:25 <tromp__> > iterate return 0.0
12:01:26 <lambdabot>       Occurs check: cannot construct the infinite type: a = m a
12:01:26 <lambdabot>        Expect...
12:01:26 <augustss> waern: it's not a matter of the notation being adequate or not.  people know LaTeX and that's how they want to write formulae.
12:01:39 <Cale> athos: Well... you might try to avoid using the last function entirely in general.
12:01:54 <ehird> :t uncurry
12:01:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:02:04 <Cale> athos: But to avoid the use of last requires a wider view of what's going on.
12:02:23 <Cale> (and there will always be times where it's difficult to avoid)
12:03:48 <athos> Cale: well, i managed to avoid it now
12:04:21 <athos> because my list has fixed length, i can easily use: x !! num :)
12:04:26 <Cale> athos: Generally, any operation which involves skipping lots of elements of a list is a bit questionable.
12:04:29 <Cale> !! is as well..
12:04:36 <Cale> last would be better than !!
12:04:41 <athos> oh
12:05:18 <Cale> But if there's a way to arrange that the element you're interested is at the start of the list, that would be better.
12:05:46 <tromp__> some reverse thinking:)
12:05:58 <athos> Cale: is head.reverse any better? ;)
12:06:20 <tromp__> i think that shld be the definition of last
12:06:28 <tromp__> @src last
12:06:28 <lambdabot> last [x]    = x
12:06:28 <lambdabot> last (_:xs) = last xs
12:06:28 <lambdabot> last []     = undefined
12:06:52 <tromp__> @src reverse
12:06:52 <lambdabot> reverse = foldl (flip (:)) []
12:06:54 <Gracenotes> reverse does all sorts of stuff you might not want
12:07:10 <Gracenotes> for one, it builds a list :)
12:07:13 <tromp__> nothing that last doesn't do
12:07:38 <Philonous> Cale: Why is shuffling the list better than searching it? Or did you mean building the list differently in the first place?
12:07:54 <Cale> Building it differently in the first place.
12:07:55 <mauke> I'd expect head.reverse to use more memory
12:07:58 <athos> hmpf, well, i can't think of a better way. the list i'm working with i a simple 3x3 list, so something like [[1..3],[10..12],[5,9,7]]
12:08:12 <Cheshire> > foldr (maybe Just (const . Just)) Nothing "fooobar"
12:08:14 <lambdabot>       Occurs check: cannot construct the infinite type: a = Maybe a
12:08:14 <lambdabot>        Ex...
12:08:20 <tromp__> > foldl f z [a,b,c]
12:08:22 <lambdabot>   f (f (f z a) b) c
12:08:22 <Cale> athos: Oh, if the list has a small fixed size, it's not so bad.
12:08:24 <Cheshire> :t maybe Just
12:08:26 <lambdabot> forall a a1. (a1 -> a -> Maybe a) -> Maybe a1 -> a -> Maybe a
12:08:33 <Cheshire> > foldr (maybe (const . Just) Just) Nothing "fooobar"
12:08:34 <Cale> athos: Don't worry about using last in that case.
12:08:34 <lambdabot>   Couldn't match expected type `a -> b -> Maybe a'
12:08:40 <athos> Cale: okay!
12:08:48 <Cheshire> > foldr (flip (maybe (const . Just) Just)) Nothing "fooobar"
12:08:50 <lambdabot>   Couldn't match expected type `a -> b -> Maybe a'
12:08:51 <Cale> athos: It's just that reverse, last, !!, are all O(n) operations
12:09:02 <waern> augustss: right. Then there's also those that don't know LaTeX :) But I guess people using a math-related library will have a tendency to know LaTeX anyway
12:09:15 <athos> Cale: ah, good to know
12:09:19 <tromp__> head.reverse doesn't build a list, Gracenotes
12:10:02 <augustss> waern: it's not a big deal, we can have our local haddock copy, but it might be something useful for others too.
12:10:06 <tromp__> it only builds a big thunk:(
12:10:39 <athos> maybe i'll notice this "bad" O(n) behaviour, because eventually i'll do lots of shuffling on 6 of such 3x3 lists
12:10:41 <Gracenotes> tromp__: you build the list as you deconstruct it ;)
12:11:28 <Gracenotes> oh, actually, you're right. It only requests the head.
12:12:16 <Gracenotes> so, there's no reason to worry about the built-up-list's tail and just use last's definition
12:14:52 <Gracenotes> athos: is there some way for you to switch it around to make the head the most frequently accessed element?
12:15:34 <Apocalisp> Do you recommend "Basic Category Theory for Computer Scientists" by Benjamin Pierce?
12:16:12 <defun> what is the point of parameterised types?
12:16:42 <waern> augustss: as I said on haskell-cafe@ I don't mind adding the LaTeX patch. As you say people know LaTeX and want to use it.
12:17:19 <waern> augustss: It would be nicer with MathML output than pictures, but that's just a future improvement
12:17:41 <athos> Gracenotes: well, i'd have to reverse my 3x3 lists, which would !! 2 (or last) turn into head, but i also use init quite often
12:17:50 <athos> so i don't know if that would pay off
12:17:59 <augustss> waern: if there's something that renders MathML then that's great.
12:18:39 <athos> but my code is no way finished, so i can't tell anything about performance. actually i try to implement some basic stuff, which seems HIGHLY repetitive
12:18:42 <Gracenotes> athos: init would just turn into "tail", no?
12:18:53 <athos> yeah
12:18:57 <athos> you're right
12:19:16 <defun> what would one use parameterized types for? I understand them, but I can't see what their application would be.
12:19:32 <mauke> defun: ever used lists?
12:19:37 <defun> yes
12:19:41 <mauke> there you go
12:20:05 <defun> ok, i see.
12:20:09 <defun> thnx
12:20:23 <waern> augustss: I think pandoc uses this: http://www.maths.nottingham.ac.uk/personal/drw/lm.html
12:21:08 <Gracenotes> anyway, you can't really use parametric polymorphism for anything, in and of itself. You have to use real types to utilize the abstractions provided by it :)
12:21:48 <pastorn> i'm trying to instance MonadState for my deep embedding
12:21:56 <pastorn> but i always get a kind error
12:22:13 <pastorn> i have a specific state S that is the only state allowed for this monad
12:23:01 <mauke> ok
12:23:05 <pastorn> @hpaste
12:23:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:25:44 <pastorn> http://paste.lisp.org/display/74988
12:26:47 <pastorn> i've tried adding paretheses here and there but i can't get it to work
12:27:05 <mauke> instance MonadState TState Program
12:27:10 <pumpkin> uppercase function names?
12:27:15 <mauke> wait, no
12:27:27 <mauke> oh, yes :-)
12:27:40 <thetallgu1> augustss: is that BASIC module of yours published somewhere?
12:27:54 <augustss> thetallgu1: not yet
12:28:14 <thetallgu1> augustss:  There are some nice puzzles in there
12:28:22 <pastorn>   Illegal instance declaration for `MonadState TState Program'
12:28:24 <pastorn>         (Only one type can be given in an instance head.
12:28:26 <pastorn>          Use -XMultiParamTypeClasses if you want to allow more.)
12:28:28 <pastorn>     In the instance declaration for `MonadState TState Program'
12:28:40 <mauke> {-# LANGUAGE MultiParamTypeClasses #-}
12:28:44 <pastorn> mauke: could you please append the paste?
12:28:44 <thetallgu1> augustss:  There's no preprocessor, right?
12:28:49 <augustss> thetallgu1: yes, something to puzzle over :)
12:28:56 <pastorn> mauke: i HAVE to have that?
12:29:00 <mauke> yes
12:29:05 <pastorn> fail
12:29:09 <mauke> how else are you going to use MonadState?
12:29:09 <augustss> thetallgu1: No.  You see all of the code.  And it's just compiled with ghc.
12:29:15 <mauke> it's a multiparam typeclass
12:29:25 <pastorn> well
12:29:27 <thetallgu1> augustss: I had thought that something like '10 LET ...' was impossible without `LET`
12:29:28 <pastorn> yeah...
12:29:44 <pastorn> mauke: still silly :/
12:29:49 <thetallgu1> augustss: now I have something to think about.
12:29:52 <augustss> thetallgu1: you might think so...  but it works
12:29:52 <mauke> thetallgu1: you can make functions numbers
12:30:37 <augustss> thetallgu1: remember that all numeric literals have an implicit fromInteger
12:31:00 <mauke> .oO( http://mauke.ath.cx/stuff/haskell/fun.hs )
12:31:11 <Gracenotes> augustss: at least those without decimal points..?
12:31:28 <thetallgu1> augustss: thanks for the hint
12:31:29 <augustss> Gracenotes: ok, they have a fromRational
12:31:45 <Gracenotes> @src Rational
12:31:45 <lambdabot> type Rational = Ratio Integer
12:31:54 <thetallgu1> mauke: Thanks, I'll look at that in a minute.
12:31:58 <Gracenotes> @src Fractional
12:31:59 <lambdabot> class  (Num a) => Fractional a  where
12:31:59 <lambdabot>     (/)             :: a -> a -> a
12:31:59 <lambdabot>     recip           :: a -> a
12:31:59 <lambdabot>     fromRational    :: Rational -> a
12:32:19 <Gracenotes> okay :)
12:32:53 <Gracenotes> > (fromRational $ 100 + 9543892%10) :: CReal
12:32:54 <lambdabot>   954489.2
12:33:13 <Gracenotes> > (fromRational $ 100 + 9543892%10000000) :: CReal
12:33:14 <lambdabot>   100.9543892
12:33:24 <Gracenotes> there we go ;)
12:33:34 <Gracenotes> mm... that's interesting.
12:34:35 <Gracenotes> > (fromRational $ (100.9543892 :: Double)) :: CReal
12:34:37 <lambdabot>   Couldn't match expected type `Rational'
12:35:00 <Gracenotes> > (fromRational $ (100.9543892 :: Ratio Integer)) :: CReal
12:35:02 <lambdabot>   100.9543892
12:35:22 <augustss> > 100.9543892 :: Rational
12:35:23 <lambdabot>   252385973%2500000
12:37:49 <mle> what is CReal?
12:38:00 <pumpkin> computable reals
12:38:29 <mle> hm.
12:38:36 <Gracenotes> fromRat (n :% d) | n > 0 = fromRat' (n :% d) | n < 0 = - fromRat' ((-n) :% d) | otherwise = encodeFloat 0 0
12:39:05 <Gracenotes> where fromRat' :: (RealFloat a) => Rational -> a
12:40:14 <mauke> CReal: part of this complete breakfast ...
12:41:44 <Gracenotes> hm... why is there a default () in Bool's source code? There are no implicit numbers, are there?
12:42:02 <Gracenotes> it's just data Bool = False | True :)
12:42:15 <jfoutz> is there a way to tell the link phase to use less memory? i'm recompiling a thing on a xen host, and it starts using swap, so it goes very slowly.
12:44:32 <Gracenotes> whoa... >>= for [] is actually defined in terms of foldr. Did not know that.
12:45:34 <CyberGarp> Anyone got an idea why I can use unicode in my haskell variables like δ, σ, and π, but uppercase Δ (Delta) causes: "Not in scope: data constructor `Δ'"
12:45:42 <chessguy_work> @src concatMap
12:45:43 <lambdabot> concatMap f = foldr ((++) . f) []
12:45:54 <mauke> CyberGarp: becayse variables can't start with uppercase letters
12:45:57 <mauke> s/ay/au/
12:45:59 <Gracenotes> .-.
12:46:00 <CyberGarp> DOH!
12:46:04 * CyberGarp slaps head
12:46:23 <mauke> MASTER of the OBVIOUS!
12:46:37 <Gracenotes> that is some weird map fusion going on up there
12:46:56 <Gracenotes> well, maybe not weird. but it's map fusion, omfg.
12:47:29 <chessguy_work> Gracenotes, in one sense of map fusion, yes. it's a different sense from the GHC pragmas, as i understand it
12:47:45 <CyberGarp> mauke, it's too damn nice outside for me to focus....
12:47:57 * CyberGarp the big blue room beckons.
12:49:06 <Gracenotes> chessguy_work: pragmas?
12:49:18 <dolio> You can probably write concat and map so it'll fuse into something like that.
12:49:25 <dolio> But doing it by hand is safer.
12:49:56 <Gracenotes> @src concat
12:49:57 <lambdabot> concat = foldr (++) []
12:49:57 <chessguy_work> Gracenotes, you can set up special GHC rules to tell it to try to fuse things
12:50:17 <Gracenotes> ah, I see.
12:51:33 <dolio> map f l = build (\c z -> foldr (c . f) z l)
12:52:25 <dolio> concat (map f l) = foldr (++) [] (build (\c z -> foldr (c . f) z l)) =fusion=> foldr ((++) . f) [] l
12:52:37 <chessguy_work> @hoogle build
12:52:38 <lambdabot> Distribution.Simple.Build build :: PackageDescription -> LocalBuildInfo -> BuildFlags -> [PPSuffixHandler] -> IO ()
12:52:38 <lambdabot> Distribution.Simple.GHC build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
12:52:38 <lambdabot> Distribution.Simple.Hugs build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
12:53:11 <Gracenotes> it's neat that GHC does fusion automatically, although I was more referring to the identities themselves
12:53:31 <Gracenotes> which GHC utilizes :)
12:53:57 <dolio> The fusion rule being: foldr c z (build g) ==> g c z
12:55:39 <BMeph> What's up with the hoogle module - did someone drop it on the floor and crack it? (Metaphorically speaking)
12:55:56 <chessguy_work> @hoogle liftM
12:55:57 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
12:55:57 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:55:57 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
12:56:08 <chessguy_work> looks ok to me
12:56:33 <chessguy_work> @hoogle second
12:56:33 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
12:56:34 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
12:56:34 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
13:00:25 <Riastradh> Boo!
13:00:51 <nelhage> I can only assume that was directed at me.
13:00:58 <nelhage> Hi there
13:01:01 <FliPPeh> dudes guises dudes
13:01:34 * FliPPeh puts the porn in porngramming
13:01:56 <Riastradh> That's an accurate assumption, nelhage.
13:01:58 <FliPPeh> SCNR
13:04:51 <chessguy_work> @vera SCNR
13:04:52 <lambdabot> *** "scnr" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
13:04:52 <lambdabot> SCNR
13:04:52 <lambdabot>      Sorry, Could Not Resist (telecommunication-slang, Usenet)
13:04:52 <lambdabot>  
13:05:22 <chessguy_work> @go virtual entity of relevant acronyms
13:05:24 <lambdabot> http://www.delorie.com/gnu/docs/vera/vera_toc.html
13:05:24 <lambdabot> Title: V.E.R.A. -- Virtual Entity of Relevant Acronyms
13:05:42 * chessguy_work so needs a lambdabot module for his brain
13:05:44 <lilac> @vera vera
13:05:45 <lambdabot> *** "vera" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
13:05:45 <lambdabot> VERA
13:05:45 <lambdabot>      Just playing around, huh?
13:05:45 <lambdabot>  
13:05:54 <chessguy_work> lol
13:06:25 <chessguy_work> @vera lilac
13:06:26 <lambdabot> No match for "lilac".
13:06:34 <chessguy_work> @vera chess
13:06:35 <lambdabot> No match for "chess".
13:06:38 <chessguy_work> boo
13:06:45 <dolio> @fact chessguy
13:06:46 <lambdabot> I know nothing about chessguy
13:06:51 <dolio> What?!
13:06:52 <pumpkin> @fact pumpkin
13:06:52 <lambdabot> I know nothing about pumpkin
13:06:53 <chessguy_work> @fact dolio
13:06:54 <lambdabot> I know nothing about dolio
13:06:55 <pumpkin> :(
13:07:00 <pumpkin> @fact lambdabot
13:07:01 <lambdabot> I know nothing about lambdabot
13:07:03 <chessguy_work> @quote pumpkin
13:07:04 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
13:07:06 <mauke> preflex: quote chessguy
13:07:06 <preflex>  no quotes found for chessguy
13:07:06 <pumpkin> fail
13:07:09 <dolio> Lambdabot has a poor memory.
13:07:11 <mauke> preflex: quote pumpkin
13:07:12 <preflex>  no quotes found for pumpkin
13:07:28 * pumpkin kicks his frankenmac
13:07:37 <dolio> @quote xahlee
13:07:38 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
13:07:49 <lilac> @quote the
13:07:50 <lambdabot> monochrom says: (<3) is the Haskell love operator :)
13:07:50 <chessguy_work> wow
13:08:28 <dolio> All my work the other day fishing up good xahlee quotes, all for naught.
13:08:39 <chessguy_work> @quote xahlee
13:08:40 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
13:08:54 <chessguy_work> @seen xahlee
13:08:54 <pumpkin> dolio: maybe you taught them to pumpkinbot?
13:08:54 <lambdabot> I haven't seen xahlee.
13:09:03 <mauke> dolio: add them to preflex :-)
13:09:09 <chessguy_work> @quote xahlee
13:09:09 <dolio> I taught one to pumpkinbot, but the rest were lambdabot.
13:09:09 <ehird_> @quote xahlee
13:09:09 <lilac> preflex: seen xahlee
13:09:09 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
13:09:09 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
13:09:10 <preflex>  xahlee was last seen on #css 47 days, 15 hours, 40 minutes and 9 seconds ago, saying: reisio: have you tried second life yet?
13:09:20 <ehird_> xahlee is hilarious
13:09:26 <pumpkin> preflex: seen xah_lee
13:09:27 <preflex>  xah_lee was last seen on ##php 23 days, 4 hours, 51 minutes and 31 seconds ago, saying: i guess charset is in the mine header already right?
13:09:34 <lament> so what's the deal with the haskell logo?
13:09:40 <pumpkin> I saw xah_lee in here the other day
13:09:42 <chessguy_work> i just found out today my company is interfacing with second life. pretty cool
13:09:44 <ehird_> I like the current logo
13:09:44 <mauke> lament: it's got lambdas and stuff
13:09:49 <ehird_> Who cares about flashiness.
13:09:52 <dolio> Yeah, he got auto-banned by chanserv.
13:10:01 <ehird_> dolio: Haha! Really?
13:10:15 <dolio> Yeah. I don't recall him actually making trouble here, either.
13:10:20 <lilac> how does one get auto-banned?
13:10:24 <dolio> But I guess I'm not around all the time.
13:10:25 <ehird_> I think banning xahlee as a general principle is reasonable, dolio.
13:10:27 <ehird_> @hoogle IO Bool
13:10:28 <lambdabot> Did you mean: :: IO Bool /count=20
13:10:28 <lambdabot> No results found
13:10:31 <ehird_> o_O
13:10:36 <ehird_> @hoogle :: IO Bool /count=20
13:10:36 <lambdabot> Control.Concurrent isCurrentThreadBound :: IO Bool
13:10:37 <lambdabot> System.IO isEOF :: IO Bool
13:10:37 <lambdabot> System.IO hGetEcho :: Handle -> IO Bool
13:10:40 <chessguy_work> wtf
13:10:41 <ehird_> ...
13:10:43 <dolio> Well, a while back he'd sometimes lurk without saying anything.
13:10:45 <ehird_> Well.
13:11:13 <lilac> @hoogle Int -> IO Int
13:11:14 <lambdabot> Control.Exception evaluate :: a -> IO a
13:11:14 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
13:11:14 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
13:11:26 <ehird_> @hoogle :: IO Bool /count=20
13:11:27 <lambdabot> Control.Concurrent isCurrentThreadBound :: IO Bool
13:11:27 <lambdabot> System.IO isEOF :: IO Bool
13:11:27 <lambdabot> System.IO hGetEcho :: Handle -> IO Bool
13:11:30 <ehird_> Queer.
13:11:38 <mop> http://www.cs.nott.ac.uk/~gmh/book.html <- Somebody reccomended me this book, I was wondering if anybody has used it/has an opinion on it?
13:12:47 <Cale> mop: That book is supposed to be a really good way to begin. I haven't read it myself, but I've heard lots of good things about it.
13:15:08 <mop> I've done YAHT, LYAH and real world haskelll until monads (due to being busy, then returning few months later) should I press on with YAHT or would you reccomend the book?
13:16:00 <nj32> the book
13:24:06 <thetallgu1> augustss: okay, got the gist of this.  Looking forward to seeing your source.
13:26:26 <Gracenotes> yay, I rotated a tree using the State monad. But it's totally fucking with my mind... I don't even completely see how it works.
13:26:32 <Gracenotes> rotatet tree = let (value, (last, old)) = runState (rotateTree tree) (old, last) in value
13:26:35 <Gracenotes> rotateTree :: Tree a -> State (a, a) (Tree a)
13:26:41 <Cheshire> what does it mean to rotate a tree?
13:26:57 <Cheshire> Gracenotes, is that like taking the list of leaves and shifting it around one?
13:27:02 <Gracenotes> in this case, move all elements to the next spot inorder, and move the last one to the first
13:27:04 <Gracenotes> yeah
13:27:12 <Cheshire> what is the definition of tree?
13:27:20 <Gracenotes> data Tree a = Leaf | Branch (Tree a) a (Tree a) deriving Show
13:27:23 <mauke> heh, a reference cycle
13:27:33 <Gracenotes> I'm pretty sure my definition does it in one pass. And it works... fucking weird.
13:27:48 <Cheshire> Your definition is much better than one I would write
13:28:00 <Cheshire> oh
13:28:04 <Cheshire> I didn't read it properly
13:28:10 <Cheshire> you haven't pasted what rotateTree does
13:28:22 <Cheshire> what is the def of rotateTree?
13:29:05 <AllNight^> hello :)
13:29:24 <dolio> I don't think you should need an (a, a) state.
13:29:29 <dolio> Just an a should be sufficient.
13:29:48 <Botje> hello AllNight^ !
13:29:58 <AllNight^> hi Botje :)
13:30:36 <Gracenotes> oh, really.. lemme try that. But, here's what I have so far: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1221#a1221
13:30:40 <dolio> let (value, s) = runState (rotateTree tree) s in value
13:32:00 <Gracenotes> oh, you're right :) so I can just reuse the shiftTree definition
13:32:43 <Gracenotes> still... it's extremely hard to track >_> the thunk goes quite deep
13:33:28 <Gracenotes> jeez, the things you can do...
13:34:19 <tehgeekmeister> can't import the data constructors i defined in WikimediaParser -- what's going on here?  this is my first time really working with modules or making a cabalized build.  are constructors not exportable?
13:34:24 <dolio> Yeah. Doing find-and-replaces in one pass is pretty cute.
13:34:45 <gwern> wikimediaparser?
13:34:47 <Gracenotes> Cheshire: hm.. I somehow doubt it could be a one-liner
13:35:15 <Cheshire> Gracenotes, maybe with enough machinery it could be I'm not sure
13:35:17 <tehgeekmeister> gwern: yeah, just uploaded to hackage
13:35:42 <tehgeekmeister> gwern: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/WikimediaParser-0.1
13:35:53 <gwern> why is it called wikimediaparser?
13:35:54 <dolio> rotateTree (Leaf a) = do a' <- get ; put a ; return (Leaf a) ; rotateTree (Node a l r) = do l' <- rotateTree l ; a' <- get ; put a ; Node a l <$> rotateTree r
13:35:57 <dolio> Or something like that.
13:36:04 <tehgeekmeister> gwern: because it parses wikimedia style markup?
13:36:23 <dolio> Oops, that should be a' and l' at the end.
13:36:35 <gwern> tehgeekmeister: wikimedia is a charitable foundation
13:36:48 <Gracenotes> dolio: yeah... that's just about what I had, except you inlined the get/put calls
13:37:01 <gwern> perhaps you meant mediawiki...
13:37:21 <tehgeekmeister> gwern: ouch, gotta change that name
13:37:33 <gwern> :)
13:38:03 <tehgeekmeister> gwern: do you know why data constructors defined in a module wouldn't be importable?
13:38:10 <dolio> Actually, if you used "Node l a r" you could do it all applicative style with a name for the get-put thing.
13:38:17 <ehird_> @hoogle getArgs
13:38:18 <lambdabot> System.Environment getArgs :: IO [String]
13:38:30 <mauke> ah, my evil twin
13:38:39 <gwern> tehgeekmeister: I guess if you didn't export the containing data type?
13:38:41 <dolio> rotateTree (Leaf a) = Leaf <$> shift a ; rotateTree (Node l a r) = Node <$> rotateTree l <*> shift a <*> rotateTree r
13:39:07 <tehgeekmeister> gwern: i thot everything was exported unless specified otherwise?
13:39:33 * gwern shrugs then
13:39:49 <Gracenotes> hm... applicative and monads... applicative and monads... *thinks*
13:40:23 <nj32> how can one flatten arbitrarily nested lists like [ [[1,2], [3,4]], [[5]], [] ]   to [1,2,3,4,5] ?
13:40:57 <mauke> call concat an appropriate number of times
13:41:31 <jimi__hendrix> what editors do you guys use for haskell...my usual vim is not doing indenting for haskell for some reason
13:41:40 <asgaroth> jimi__hendrix: emacs
13:41:42 <nj32> recursing concat on sublists fails type checking
13:41:47 <gwern> jimi__hendrix: I use yi, but that's because I'm a masochist
13:41:52 <mauke> jimi__hendrix: vim
13:41:53 <hackage> Uploaded to hackage: dequeue 0.1.1
13:41:53 <hackage> Uploaded to hackage: dequeue 0.1
13:41:53 <hackage> Uploaded to hackage: zoneinfo 0.1.0.0
13:41:53 <hackage> Uploaded to hackage: terminfo 0.3.0.1
13:41:53 <hackage> Uploaded to hackage: haskeline 0.6.1
13:41:57 <dolio> @type concat . concat . concat
13:41:58 <mauke> nj32: there's no point in recursing
13:41:58 <lambdabot> forall a. [[[[a]]]] -> [a]
13:42:10 <thetallgu1> > concat $ concat [ [[1,2], [3,4]], [[5]], [] ]
13:42:12 <lambdabot>   [1,2,3,4,5]
13:42:25 <nj32> oh, i don't know how the depth of nesting
13:42:33 <dolio> Yes you do.
13:42:36 <thetallgu1> nj32: it's not like scheme
13:42:39 <mauke> nj32: where are you going to get a list with an unknown nesting depth?
13:42:46 <asgaroth> nj32: How else could you define a list then?
13:43:19 <thetallgu1> >[1,[1,2],[[1,2,3]]]
13:43:22 <nj32> say a list is stored in a file and i want to read it and flatten it
13:43:30 <asgaroth> thetallgu1: list have to be homogenous
13:43:34 <jimi__hendrix> mauke: does it do autoindenting for .hs files for you?
13:43:35 <asgaroth> *lists
13:43:38 <mauke> nj32: how are you going to read it?
13:43:51 <mauke> jimi__hendrix: no (unless you mean :set ai)
13:43:57 <thetallgu1> asgaroth: yes, I was trying to point that out to nj32, but the bot won't show an error message
13:44:08 <mauke> thetallgu1: needs more spaces
13:44:12 <asgaroth> thetallgu1: because you forgot the space between > and [
13:44:17 <nj32> i understand that the list has to be homogenous
13:44:17 <asgaroth> > [1,[]]
13:44:17 <thetallgu1> urg
13:44:19 <lambdabot>       No instance for (Num [a])
13:44:19 <lambdabot>        arising from the literal `1' at <inter...
13:44:46 <thetallgu1> nj32: are you a Lisp programmer?
13:44:55 <asgaroth> nj32: that means that all elements have the same nesting depth and the type of each expression is known at compile-time. therefore you know the depth
13:44:59 <gwern> jimi__hendrix: no editor does fool-proof indenting of haskell (since indentsare semantically important), but the one that is best in that respect is yi
13:45:02 <ehird_> @hoogle m Bool -> m () -> m ()
13:45:03 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:45:03 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:45:03 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
13:45:05 <nj32> thetallgu1: no but have done a little scheme
13:45:21 <mauke> lisp "lists" are actually trees
13:45:38 <jimi__hendrix> mauke: what does set ai do?
13:45:38 <thetallgu1> nj32: if that's your mental model of lists, then you need to adjust a bit.
13:45:53 <mauke> jimi__hendrix: :help 'ai
13:45:55 <jimi__hendrix> gwern: yi?
13:46:14 <asgaroth> @hackage yi
13:46:15 <gwern> yes
13:46:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/yi
13:46:21 <gwern> @where yi
13:46:22 <lambdabot> http://www.haskell.org/haskellwiki/Yi
13:46:48 <jimi__hendrix> is this some vim rip off?
13:46:50 <asgaroth> Is yi usable as a day-to-day haskell editor yet?
13:46:52 <nj32> thetallgul: i want to write a function that works on 4 level nests and 5 level nests and so on
13:46:59 <ehird_> nope, jimi__hendrix
13:47:05 <ehird_> yi supports both haskell and vi keybindings, yes
13:47:08 <nj32> i understand the nest by itself has to be homogenous
13:47:08 <ehird_> but it's written in haskell
13:47:08 <mauke> nj32: why?
13:47:14 <ehird_> it's as extensible as emacs, but in haskell.
13:47:32 <nj32> mauke: my friend just asked me and i am new to haskell, so what do i reply
13:47:38 <Cale> nj32: Then it must be typeclass polymorphic.
13:47:51 <thetallgu1> nj32: then what you want will look more like a tree.  You need tags (i.e., constructors).
13:47:54 <Cale> nj32: Something like...
13:47:56 <gwern> asgaroth: I think so
13:48:01 <nj32> Cale: bit more
13:48:14 <gwern> asgaroth: as long as you can build with the ghc api and bind some of the more advanced features
13:48:14 <jimi__hendrix> so its vi in haskell
13:48:16 <Cale> class Foo a where foo :: [a] -> Something
13:48:31 <Cale> instance Foo Integer where ...
13:48:39 <Cale> instance Foo a => Foo [a] where ...
13:48:53 <Cale> Or something like that.
13:49:01 <asgaroth> gwern: Hmm, I wanted to learn that some day anyway, so I guess I'll try yi then.
13:49:08 <gwern> jimi__hendrix: not really. imo, the emacs keybindings are probably more complete, as there's less modal strangeness to deal with
13:49:22 <nj32> Cale: and how will my function look like?
13:49:25 <jimi__hendrix> ok
13:49:28 <gwern> asgaroth: the usual advice applies - use everything from darcs
13:49:30 <mauke> I see MPTCs in your future
13:49:35 <Cale> nj32: I don't know what the function is supposed to do.
13:49:48 <asgaroth> gwern: Will do, thanks.
13:50:07 <nj32> Cale: it's supposed to take a nested list and flatten it out
13:50:13 <Cale> nj32: oh...
13:50:18 <jimi__hendrix> i thought that haskell indenting was regular with 4 spaces
13:51:15 * Trafalgards looks confused.
13:51:44 <Trafalgards> My project in eclipse stopped building, and by that, I mean, it's no longer showing compiling errors or anything
13:51:53 <Trafalgards> but it's no longer making the exe or updating the .o files
13:51:56 <Cale> nj32: I suppose that can be done. The simplest way I can think of involves MPTCs or type families though.
13:52:04 <mauke> jimi__hendrix: haskell isn't so much about indentation as making things line up
13:52:12 <gwern> jimi__hendrix: not really. also, what about all the other stuff? suppose you have a do expression and you remove a letter/add a letter to one of the function args - now everything might be out of alignment. yi can automatically move the entire expression in/out one letter
13:52:17 <nj32> what is MPTCs?
13:53:00 <Cale> Multiparameter type classes
13:53:08 <nj32> okay
13:53:12 <jimi__hendrix> ok
13:53:19 <Trafalgards> so I tried to compile the .hs files manually with GHC inside msys (I'm on windows), but apparently I don't quite know how, because it's acting... odd. When I tried to compile them all at once (ghc -o somenamefortheexe *.hs) it said Failed to load interface for `somerandomclassofmine'
13:53:46 <Trafalgards> but when I told it to compile individual .hs files, for some it named another one that it failed to load interface for
13:53:53 <Trafalgards> but those all exist
13:54:13 <jimi__hendrix> and last question
13:54:44 <jimi__hendrix> how do i install yi (the page you guys showed me just told me to configure and make it and such but not which files to run to configure it)
13:55:00 <mauke> Trafalgards: I don't know, I just randomly add --make
13:55:03 <Trafalgards> and let's say, I try to compile A.hs, and it says failed to load interface for B, so I try to compile B.hs to B.o and that works fine. Then I try to compile A.hs again and it works fine
13:55:17 <Trafalgards> and so now doing that I have all but two of them compiled
13:55:35 <Trafalgards> as far as I can tell if a file imports another the one it imports has to be built first
13:55:43 <nburlett> hpaste is down?
13:55:49 <Trafalgards> and for some bizarre stupid reason GHC can't figure out to compile the one being imported first
13:55:53 <Saizan> ?where hpaste2
13:55:54 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
13:55:59 <pao> I was comparing a bunch of IO library... I've realized that haskell doesn't type check write operations on handles opened in read mode...
13:56:02 <Trafalgards> problem is...
13:56:12 <Trafalgards> I have two .hs files which import each other
13:56:14 <nburlett> Saizan: someone should update the topic then...
13:56:23 <gwern> jimi__hendrix: look in yi/Yi/Users for example configs
13:56:25 <Trafalgards> I can't compile them
13:56:33 <Trafalgards> I figure this is probably why eclipse broke too
13:56:50 <nburlett> I know there has to be a better way to write this function: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1222#a1222
13:57:02 <mauke> Trafalgards: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
13:57:03 --- mode: ChanServ set +o Saizan
13:57:11 <nburlett> any suggestions?
13:57:11 <Cale> nj32: Ah, and I can't see doing it without undecidable instances as well, since you're basically guaranteed to have bad overlapping with the base case.
13:57:17 <Trafalgards> thanks
13:57:18 <asgaroth> pao: Afaik, that has nothing to with type checking, since how a handle is opened, doesn't reflect in its type.
13:57:23 <Gracenotes> Saizan: updating the paste URL? :)
13:57:50 --- topic: set to '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]' by Saizan
13:57:52 <jimi__hendrix> gwern: ok
13:57:59 --- mode: Saizan set -o Saizan
13:58:00 <pao> asgaroth: it a API design use... java doesn't compile if you try to write on a file opened for reading...
13:58:00 <Gracenotes> :D
13:58:06 <pao> *it's
13:58:21 <nj32> Cale: i was getting infinite type errors when tried writing recursive concats
13:58:56 <pao> asgaroth: ... I was wondering what's the best IO API for a statically checked language
13:59:01 <nj32> Cale: do you mean the same with 'undecideable instances'?
13:59:07 <Cale> nj32: no
13:59:16 <nj32> Cale: what is that?
13:59:27 <pao> asgaroth: it is a library design issue ... I cannot write properly tonight ;-)
13:59:51 <Cale> nj32: It relaxes the rules with regard to what class instances you're allowed to have.
13:59:57 <pao> asgaroth: java API is "unreceivable" ;-)
14:00:09 <nj32> Cale: ok
14:03:55 <Cheshire> Gracenotes, I tried to do it as a fold but it doesn't work
14:04:55 <mmorrow> dolio, Cale: re fastcgi/contmap/plt-scheme: i re-coded the general idea i tried before with fastcgi up (i can't seem to find the original code): http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1223#a1223
14:05:13 <Gracenotes> Cheshire: oh :(
14:05:26 <mmorrow> i used STM though before, but it seemed slow compared to just MVars. i dunno though
14:07:15 <Cheshire> Gracenotes oh I got a new idea!
14:07:22 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1224#a1224
14:07:32 <Gracenotes> what?
14:07:33 <Cale> ... where did nj32 go?
14:08:18 <Gracenotes> Cale: ah, I had thought that required some weird typeclass... GHC complained when I tried to do it though :)
14:08:30 <Cale> Gracenotes: what?
14:08:38 <litb> hello all
14:09:07 <Gracenotes> Cale: the multiparameter typeclass
14:09:55 <Cale> Actually, I declared functional dependencies there, but didn't end up needing them.
14:14:06 <pao> Cale: sorry to bother ... AFAYK has it been ever considered to type check operation (read/write) against handles?
14:14:19 <Cheshire> Gracenotes, which direction around should the leaves rotate?
14:14:27 <Cheshire> Gracenotes, I'm not sure it's possible to do both
14:14:30 <Cale> pao: hm?
14:14:33 <Gracenotes> Cheshire: probably inorder
14:14:45 <Cheshire> -- *Main> rotate ex (Branch (Branch Leaf 'a' Leaf) 'b' (Branch Leaf 'c' Leaf))
14:14:45 <Cheshire> -- Branch (Branch Leaf 'c' Leaf) 'a' (Branch Leaf 'b' Leaf)
14:14:46 <Gracenotes> left-center-right
14:14:48 <Cheshire> is that the wrong order?
14:14:54 <Gracenotes> that looks right
14:15:05 <Cheshire> ok I can't figure out how to do the other way
14:15:28 <Gracenotes> rotating a list and rotating a tree are pretty similar, I'd think... it depends on the order in which you recurse.
14:16:17 <pao> Cale: if you have data ReadHandle then you can typecheck write operations against it... at compile time you can detect attempt to write on a file opened for reading...
14:16:18 <Gracenotes> Cheshire: so you got it working :D how?
14:16:21 <dolio> Cheshire: You do the same thing, only traverse right-center-left.
14:16:56 <Cale> pao: Yes, I suppose you can.
14:17:28 <Cale> pao: Another option is just to apply the read or write operation to the handle beforehand, and pass that along instead of the Handle itself.
14:19:31 <pao> Cale: clear... i was just considering API design... it struck me that java has (albeit orrible) API that prevents wrong operations while haskell has not... I was wondering if it is anything really worthwhile
14:19:57 <pao> *horrible
14:20:07 <Cheshire> skip Leaf leaves k = k Leaf leaves
14:20:07 <Cheshire> skip (Branch l o r) leaves k =
14:20:07 <Cheshire>  skip l leaves $ \l' leaves' ->
14:20:07 <Cheshire>  skip r (o:leaves') $ \r' leaves'' ->
14:20:07 <Cheshire>  k (Branch l' (head leaves') r') leaves''
14:20:16 <Cheshire> Gracenotes, so rotate tree = let (t,e) = skip tree e (,) in t
14:20:43 <Gracenotes> ah, continuations. muy impressive.
14:20:46 <Cale> pao: It certainly seems something worth considering when designing an IO API. I haven't found myself too unhappy with the current design, but it's possible there are better ways to go;
14:20:52 <Cale> s/;/./
14:21:23 <dolio> rotateTree r <**> shift <**> rotateTree l <**> pure Node
14:21:27 <pao> Cale: thanks for your point of view :-)
14:21:39 <dolio> Assuming <**> does what I think it doees.
14:22:13 <asgaroth> I installed a package using cabal install (as a user) and it is correctly displayed by ghc-pkg list, but trying to configure another package that needs it, it is still reported as missing.
14:22:25 * ddarius rarely reads to a write-only handle or vice versa.
14:23:26 <dcoutts> asgaroth: use cabal configure not runghc Setup configure
14:23:35 <asgaroth> dcoutts: Ah, thanks
14:24:00 <Gracenotes> Cheshire: cool... I'll try to comprehend it now ;)
14:24:12 <dcoutts> asgaroth: the reason is the cabal command uses --user by default, runghc Setup uses --global by default.
14:24:33 <dcoutts> asgaroth: and global packages cannot use user packages, so when configuring for global then user packages are ignored
14:24:40 <asgaroth> dcoutts: Ok, thanks for the explanation.
14:25:14 <Gracenotes> the interesting thing is that the list seemingly comes out of nowhere
14:27:42 * ddarius thinks Cheshire is using CPS just to return a tuple...
14:28:01 <dolio> It looks like CPSed State.
14:28:07 <dolio> With all the definitions inlined.
14:28:33 <dolio> Which means the list probably isn't necessary.
14:28:56 <ddarius> dolio: Indeed, it's state passing.  The continuation aspect is completely superfluous.
14:29:02 <Cheshire> ddarius, I use CPS so that I /don't/ return a tuple :)
14:29:29 <ddarius> There's little or no harm in using a tuple.
14:32:50 <dolio> > let return a s k = k s a ; (m >>= f) s k = m s (\s a -> f a s k) ; run s m = m s (,) ; get s k = k s s ; put a s k = k a () in run 2 (get >>= \a -> put (a+1) >>= \_ -> get >>= \b -> return (a,b))
14:32:52 <lambdabot>   (3,(2,3))
14:33:10 <ddarius> Abstracting from the particular implementation, you get: skip Leaf = return Leaf; skip (Branch l o r) = do l' <- skip' l; o' <- gets head; modify (o:); r' <- skip r; return (Branch l' o' r')
14:36:44 <mmorrow> cps state is a lot faster than the standard State monad
14:37:32 <mmorrow> using a tuple actually does hurt
14:37:58 <FunctorSalad> just curious... why has my function with  left-hand side "d2f !(D# d)" strictness type "U(L)m" (lazy)?
14:38:02 <ehird_> @hoogle m a -> m b -> m a
14:38:03 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
14:38:03 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
14:38:03 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
14:38:42 * mmorrow is reading about the SML module system and is green with envy
14:39:31 <FunctorSalad> (a Double-to-Float converter should better be strict, right?)
14:39:41 <augustss> mmorrow: it's cool, but too complex
14:40:03 <lispy> mmorrow: But, is'n the SML module system really just a complex way to do OO designs?
14:40:16 <augustss> no
14:40:19 <ehird_> haskell is so great
14:40:35 <Badger> as great as befunge? :P
14:40:37 <BMeph> lispy: Invert those concepts, and you're getting close. ;)
14:40:40 <mmorrow> augustss: what about it is too complex compared wrt what would be your "ideal" module system?
14:40:46 <lispy> BMeph: heh
14:40:56 <mmorrow> *..too complex compared to what ...
14:41:48 <augustss> mmorrow: Derek Dryer has a module system with something like 5 primitives.  From those all 20 (or whatever) of SML constructs can be made.
14:42:07 <mmorrow> hmm, /me googles Derek Dryer
14:42:28 <augustss> mmorrow: I don't know if it has been published yet.
14:42:34 <Heffalump> Derek Dreyer
14:42:41 <BMeph> Aaugh!
14:42:43 <augustss> yes, sorry
14:42:46 <Heffalump> unless augustss is talking about a different person to the one I assume he is
14:44:29 <mmorrow> augustss: his research page has a bunch of related-looking stuff
14:45:09 <augustss> mmorrow: his thesis has some of it, I think.  But he has something simpler now.
14:45:29 <tromp__> > iterate show []
14:45:33 <BMeph> augustss: You're a huge (intellectual) tease, you know that, right? ;p
14:45:39 <Cheshire> I wish I understood what is good about these module systems
14:46:01 <BMeph> Cheshire: Which module systems? :)
14:46:26 <augustss> Cheshire: you'll understand when you need them :)
14:46:39 <FunctorSalad> well, we have typeclasses :D but iirc augustss wrote a blog post where they're awkward
14:46:42 <mmorrow> augustss: is it "Mixin' Up the ML Module System." ICFP '08 ?
14:46:42 <lambdabot>   ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\...
14:46:44 <FunctorSalad> or was it someone else?
14:46:59 <Gracenotes> > iterate show undefined
14:47:01 <lambdabot>   ["* Exception: Prelude.undefined
14:47:29 <mmorrow> that seems to be his newest one related to ML modules on that page
14:47:44 <augustss> mmorrow: Perhaps.  My brain can no longer keep all these things apart. :)  But that sounds about right.
14:48:22 <augustss> mmorrow: I heard him talk at a non-public meeting, so it could be some newer stuff I'm thinking of.
14:48:36 <mmorrow> ah cool
14:48:45 <Gracenotes> > let m = show m in m
14:48:47 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:49:04 <Gracenotes> I'm surprised that compiles
14:49:09 <mmorrow> @src fix
14:49:10 <lambdabot> fix f = let x = f x in x
14:49:11 <sm_> I have a utf8-encoded script file, which should putStrLn some non-ascii strings, but they appear misencoded in the output - is there something special I have to do to specify the encoding ?
14:49:13 <Gracenotes> :t let m = show m in m
14:49:15 <lambdabot> String
14:49:24 <mmorrow> , fix show
14:49:25 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\...
14:49:32 <ddarius> :t show :: String -> String
14:49:34 <lambdabot> String -> String
14:49:34 <ddarius> :t fix
14:49:36 <lambdabot> forall a. (a -> a) -> a
14:49:47 <Gracenotes> aha.
14:49:49 <FunctorSalad> , map length (group (fix show))
14:49:53 <lunabot>  luna: out of memory (requested 1048576 bytes)
14:50:09 <FunctorSalad> :( thought that would be a great way to calc powers of two
14:50:16 <mmorrow> hmm, that should work
14:50:26 <mmorrow> i guess the rlimits are too low for that or something
14:50:38 <FunctorSalad> maybe group is global, not just adjacent groups
14:50:45 <augustss> , take 5 $ map length (group (fix show))
14:50:46 <lunabot>  [1,1,1,3,1]
14:50:47 <mmorrow> > fmap ((+1) . length) . group . fix $ show
14:50:50 <sm_> maybe I need the recent ghc unicode support for this ?
14:50:51 <mmorrow> , fmap ((+1) . length) . group . fix $ show
14:50:54 <lunabot>  luna: out of memory (requested 1048576 bytes)
14:51:14 <FunctorSalad> , group "aba"
14:51:15 <lunabot>  ["a","b","a"]
14:51:16 <ddarius> You need to drop every other element as well.
14:51:20 <mmorrow> it probably gets so huge before the cutoff
14:51:36 <ddarius> mmorrow: It does grow exponentially.
14:51:42 <augustss> , take 5 $ filter (/= 1) $ map length (group (fix show))
14:51:42 <mmorrow> heh
14:51:43 <lunabot>  [3,7,15,31,63]
14:51:59 <FunctorSalad> ++
14:52:12 <augustss> , take 10 $ map succ $ filter (/= 1) $ map length (group (fix show))
14:52:12 <lambdabot>   thread killed
14:52:13 <lunabot>  [4,8,16,32,64,128,256,512,1024,2048]
14:53:22 <augustss> An even more stupid way to compute 2^n than the factorial I should at my guest lecture today. :)
14:53:50 <mmorrow> , iterate (*2) 1
14:53:51 <lunabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
14:54:20 <augustss> :t dif
14:54:24 <lambdabot> Not in scope: `dif'
14:54:41 <mmorrow> , group (replicate (2^16) '\\')
14:54:42 <lunabot>  ["\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
14:54:54 <mmorrow> , length (replicate (2^17) '\\')
14:54:55 <lunabot>  131072
14:54:56 <FunctorSalad> augustss: it counts the number of n-permutations (filtered from all n-sequences)? ;)
14:54:59 <ispiked> anyone who's setup haskellmode for vim, is there anything else I need to do besides install the .vba script here? http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
14:55:05 <int-e> > take 5 $ map head $ iterate (tail . tail) $ tail $ map length $ group $ fix show
14:55:05 <ispiked> :make is not working for me
14:55:08 <lambdabot>   [1,3,7,15,31]
14:55:14 <ddarius> , '\\':intersperse '\\' (concatMap pred (map (flip replicate '\\') $ iterate (2*) 1)
14:55:15 <lunabot>  luna: parse error (possibly incorrect indentation)
14:55:21 <ispiked> I get the following error: make: *** No targets specified and no makefile found.  Stop.
14:55:23 <augustss> FunctorSalad: it computes the n:th derivative of x^n
14:55:25 <ddarius> , '\\':intersperse '\\' (concatMap pred (map (flip replicate '\\') $ iterate (2*) 1))
14:55:26 <lunabot>  luna: No instance for (GHC.Enum.Enum [GHC.Types.Char])
14:55:27 <mmorrow> , fmap (length . flip replicate '\\') . iterate (*2) $ 1
14:55:32 <FunctorSalad> augustss: :D
14:55:33 <lunabot>  Killed.
14:56:09 <ispiked> I guess everyone uses emacs here
14:56:33 <FunctorSalad> ... in viper-mode, recently ;)
14:56:33 <shortc|desk> I run a site named Rosetta Code, and I need the Haskell community's input on something.  An anonymous user made a change to the Haskell section of one of our pages, removing what he called "irrelevant aspects".  My dilemma is that if the code he removed serves to illustrate how Haskell works in comparison with other languages, then I don't think it should have been removed.  On the other hand, I don't know enough about Haskell to ev
14:56:33 <shortc|desk> en make an educated guess.
14:56:39 <augustss> ispiked: not all.  there are some weirdos here
14:57:06 <zimbatm> hi
14:57:12 <shortc|desk> If someone could give me input on this change, I'd be very appreciative: http://rosettacode.org/w/index.php?title=Amb&curid=2774&diff=21990&oldid=21275&rcid=22188
14:57:41 <zimbatm> does haskell have some parse-time mechanism ?
14:58:16 <Heffalump> zimbatm: there's Template Haskell, and quasiquotation
14:58:20 <zimbatm> I'd like to include some data as a constant, from a text file
14:58:22 <Cheshire> shortc|desk, I gave you input in #rosettacode
14:58:25 <mmorrow> augustss: oh sweet, it looks like he's got a website for "MixML": http://www.mpi-sws.org/~rossberg/mixml/
14:58:38 <zimbatm> thx for the pointer Heffalump
14:58:45 <thetallgu1> zimbatm: Template Haskell can do that for you
14:58:49 <chessguy_work> @quote pointer
14:58:50 <lambdabot> musasabi says: reallyUnsafePointerEq# seems unsafe.
14:59:08 <Gracenotes> @quote segfault
14:59:08 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
15:00:27 <mmorrow> zimbatm:    $(runIO (readFile "foo.csv")) :: String
15:01:03 <mmorrow> you could put that in a top-level def (or anywhere really), and it'd be a String in the compiled program
15:01:45 <mmorrow> (you'd need  import Language.Haskell.TH.Syntax)
15:02:06 <thetallgu1> zimbatm: along with {-# LANGUAGE TemplateHaskell #-} at the top as well as the import
15:02:12 <BMeph> Every time I see "unsafeCoerce", I always mentally follow it with "high school girls." Probably because of this, I never use it in my programs. ;p
15:02:23 <mmorrow> thetallgu1: ah, good call
15:02:25 <Botje> BMeph: why not? :]
15:02:42 <opqdonut> indeed
15:02:59 <BMeph> Botje, opqdonut: ;p
15:04:24 <thetallgu1> also, that code seems incomplete to me.  The ::String trick doesn't work for me.  Sure you don't need a lift in there?
15:04:58 <thetallgu1> Bummer, hpaste is down.
15:05:13 <tromp__> has been for a while
15:05:14 <thetallgu1> has it gone by the wayside?
15:05:25 <zimbatm> thx mmorrow, thetallgu1
15:05:52 <thetallgu1> zimbatm: here's a working example, in pieces
15:06:18 <thetallgu1> {-# LANGUAGE TemplateHaskell #-}\nimport Language.Haskell.TH (runIO)\nimport Language.Haskell.TH.Syntax (lift)
15:06:37 <BMeph> augustss: Weren't you going to front mmorrow some space in the hpaste.org server-space? :)
15:06:37 <thetallgu1> hosts :: String\nhosts = $(runIO (readFile "/etc/hosts") >>= lift)\nmain = putStrLn hosts
15:07:06 <augustss> BMeph: huh? not me
15:07:18 <thetallgu1> expand the \n's and that will compile with ghc 6.10
15:07:57 <thetallgu1> BMeph: how much space does it need?
15:08:05 <BMeph> Hmm, who owns "hpaste.org" (the domain name) I wonder?
15:08:16 <thetallgu1> shapr, I think
15:08:27 <augustss> BMeph: I can offer space on ginntonic.org
15:09:15 <int-e> BMeph: bos does.
15:09:44 <drhodes> a recursive function with base case (Just 0), recurring case (Just 1 + <CALL>), the error case is Nothing which isn't a problem. I don't get how to prevent nested monads from happening, >>they can't be added<<, so does the value get scooped out with (<-) somehow right before the call?
15:09:48 <BMeph> int-e: Hmm, okay, so it's bos we need to <poke>, then. :)
15:09:58 <bos> what?
15:10:17 <bos> i'm waiting on a poke from mmorrow, who's currently running hpaste2
15:10:25 <shteou> Excellent domain, augustss.
15:10:27 * Heffalump spies a chain of pokes developing
15:10:34 <BMeph> drhodes: 'fmap (+)' should be fine for it. ;)
15:10:47 <BMeph> s/(+)/succ/
15:10:57 <Gracenotes> Heffalump: a thunk of pokes, you mean :)
15:11:03 <drhodes> but I really like my recursive function, it took awhile to write :>
15:11:05 * BMeph pokes mmorrow twice
15:11:08 <eric_j> is there an IO no-op value?
15:11:16 <pumpkin> BMeph: *doublepoke
15:11:16 <int-e> eric_j: return ()
15:11:17 <Zao> return ()
15:11:19 <Gracenotes> return ()
15:11:22 <pumpkin> lol
15:11:24 <pumpkin> return ()
15:11:32 <Gracenotes> heh.
15:11:32 * drhodes reluctantly considers fmap
15:11:33 <geezusfreeek> return ()
15:11:46 <Gracenotes> Yeah, as in:
15:11:46 <BMeph> pumpkin: No, 'twice poke', of course. ;)
15:11:49 <Gracenotes> @src when
15:11:50 <lambdabot> when p s = if p then s else return ()
15:11:50 <eric_j> thanks
15:11:59 <mmorrow> BMeph: ouch
15:12:13 <Gracenotes> eric_j: if you're considering doing an operation only under a certain condition, try using when or until
15:12:22 <mmorrow> oh!
15:12:29 <Gracenotes> when performs the action when the boolean is true; until when it's false
15:12:31 <ddarius> :t until
15:12:34 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
15:12:40 <ddarius> until does something rather different
15:12:42 <Gracenotes> erm.
15:12:46 <Gracenotes> unless.
15:12:48 <Gracenotes> sorry.
15:12:54 <mmorrow> bos: hey, i'll try to get that done now (i've just gotta get hpaste2 setup on this other box, it's 80% done)
15:12:55 <geezusfreeek> () <$ do ...
15:13:00 * Gracenotes smiles politely
15:13:02 <BMeph> mmorrow: The longer we all have to field all of those "Why haven't you changed the intro message" questions, mmorrow... ;)
15:13:35 <drhodes> :t fmap
15:13:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:14:13 <BMeph> > succ `fmap` (Just 1)
15:14:15 <lambdabot>   Just 2
15:14:30 <eric_j> Gracenotes: nah, i was trying to write exactly that function, but i was trying to write it as \x -> ((),x)
15:15:32 <drhodes> :t succ
15:15:34 <lambdabot> forall a. (Enum a) => a -> a
15:15:43 <Gracenotes> :t untilM
15:15:45 <lambdabot> Not in scope: `untilM'
15:15:58 <Gracenotes> eric_j: mm.. which function?
15:18:06 <ehird> @pl reverse . tail . reverse
15:18:07 <lambdabot> reverse . tail . reverse
15:18:11 <ehird> > (reverse . tail . reverse) "abc"
15:18:13 <lambdabot>   "ab"
15:18:21 <drhodes> excellent, thank you very much BMeph
15:18:22 <Cheshire> @pl (reverse . tail . reverse) "abc"
15:18:22 <lambdabot> reverse (tail (reverse "abc"))
15:19:00 <ehird> > (reverse . tail . reverse) "abc"
15:19:01 <ehird> err
15:19:02 <lambdabot>   "ab"
15:19:17 <pumpkin> :o
15:19:22 <pumpkin> > init "abc"
15:19:24 <lambdabot>   "ab"
15:19:38 <eric_j> i am trying to print a list: foldr (\x st -> do st; print x) (return ()) [2,3,4]
15:19:47 <eric_j> it comes out backwards. i "know" why but i'm still trying to grok it
15:20:08 <Cheshire> eric_j, try do print x; st
15:20:29 <eric_j> right
15:20:32 <pumpkin> or just mapM_ print [2,3,4]
15:20:40 <pumpkin> but maybe you didn't want tat
15:20:43 <Cheshire> eric_j, so it just prints them out in the order you say
15:20:45 <pumpkin> that
15:21:22 <eric_j> i know the mechanics of it; i'm just trying to get a handle on why haskell lists seem "backwards"
15:21:23 <Gracenotes> eric_j: you might be interested in Debug.Trace if you're debugging
15:21:29 <ehird> does parsec let you get the string left over after parsing?
15:21:40 <Cheshire> eric_j, they don't seem backwards...
15:21:41 <Gracenotes> it's basically an unsafe IO print action, but it works nicely for learning
15:22:01 <Gracenotes> (especially learning why a program doesn't work :)
15:22:08 <pumpkin> it can also help you figure out when things actually happen
15:22:17 <pumpkin> as it isn't necessarily the order you write them in
15:22:37 <Gracenotes> I've also found this function useful: traceId x = trace (show x) x
15:22:49 <ddarius> ehird: In a round about way, yes.
15:22:55 <int-e> @type Debug.Trace.traceShow
15:22:56 <lambdabot> Not in scope: `Debug.Trace.traceShow'
15:23:11 <ehird> ddarius: Ok. How? :-)
15:23:21 <pumpkin> Gracenotes: traceShow does that :) I tend to do join traceShow
15:23:32 <Gracenotes> eh. Too verbose :P
15:23:36 <pumpkin> I mean
15:23:39 <pumpkin> ts = join traceShow
15:23:52 <pumpkin> and then just stick ts all over the place
15:24:11 <Gracenotes> ah, that'd work. what's the type signature...?
15:24:15 <Gracenotes> @hoogle traceShow
15:24:16 <lambdabot> No results found
15:24:21 <ddarius> ehird: Use getInput and return it alongside the result
15:24:25 <pumpkin> (Show a) => a -> a
15:24:38 <ehird> ddarius: Oh, you mean I have to hack the parser?
15:24:40 <int-e> oh, traceShow is new in base 3.0.3 (ghc 6.10.1)
15:24:41 <Gracenotes> ah.
15:24:50 <pumpkin> , traceShow
15:24:51 <lunabot>  luna: Not in scope: `traceShow'
15:24:52 <Gracenotes> that must be why I don't have it :)
15:24:59 <BMeph> traceShow :: Show a => a -> b -> b
15:25:11 <pumpkin> oh yeah :)
15:25:17 <int-e> Debug.Trace.traceShow :: (Show a) => a -> b -> b
15:25:21 <BMeph> int-e: That'd be base 4. :)
15:25:27 <pumpkin> I guess I was thinking of my ts :P
15:25:37 <ddarius> ehird: All you have to do is write: do a <- theParser; s <- getInput; return (a,s)
15:25:41 <Gracenotes> eric_j: so with Debug.Trace, foldr (\x st -> trace (string you want to print) (result of computation)) 0 [2,3,4], or something like that
15:25:45 <int-e> BMeph: it's both.
15:25:57 <Cheshire> why would you trace it :(
15:26:12 <ehird> ddarius: ah
15:26:12 <ehird> thanks
15:26:15 <int-e> BMeph: base 3.0.3 is the compat layer with the old exception system that they wrapped around base 4.0
15:27:12 <Gracenotes> Cheshire: you don't know what kind of havoc it wrought the last time it escaped..!
15:27:20 <BMeph> int-e: Okay, then I'll just say it's a 6.10 thing. :)
15:27:41 <Raevel> köpte samtidigt som machbooke
15:27:45 <Raevel> oops
15:27:59 <Raevel> i don't like irssi
15:28:14 <Gracenotes> copy+paste rather limited
15:28:17 <Botje> then don't use it ;)
15:28:23 <Raevel> not copy paste
15:28:35 <Raevel> type + accidentally change window + return
15:31:16 <Raevel> also, irssi is bad but still the best :-(
15:31:31 <Botje> there's weechat :p
15:32:25 <Raevel> never heard of it!
15:32:55 <Botje> it's actively updated, unlike irssi :)
15:33:14 <Zao> Botje: Maybe irssi doesn't have to be updated.
15:33:39 <Botje> then they better slap a 1.0 label on it :)
15:34:21 * Gracenotes used to have a quit message that read "Telnet - The client of the future"
15:34:31 <Zao> Gracenotes: Future-proof.
15:35:22 <Raevel> the battle.net protocol seems to be made for telnet, every message that doesn't begin with / goes to the current channel
15:36:08 <repnop> it's just really old ;)
15:37:16 <zimbatm> what's the easiest way to build a list from X down to zero ?
15:37:30 <kaol> > [10..0]
15:37:32 <lambdabot>   []
15:37:34 <zimbatm> using the range construct, only works from small to big numbers
15:37:37 <kaol> > [10,9..0]
15:37:39 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
15:37:55 <zimbatm> kaol: what is 10 is a variable ?
15:38:10 <Toxaris> > let n = 10 in [n, n-1 .. 0]
15:38:13 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
15:38:38 <zimbatm> hm ok but isn't there something like a method, where I don't need to give the step ?
15:38:56 <zimbatm> because right now, I'm using it in a list comprehension, so the let would be really ugly
15:39:39 <lispy> > reverse [0..10]
15:39:41 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
15:39:41 <Raevel> reverse . enumFromTo
15:39:53 <kaol> > (\n -> [n,n-1..0]) 10
15:39:55 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
15:40:00 <zimbatm> perfect, thx a lot !
15:40:30 <Toxaris> zimbatm: you could write your own function downTo with    4 `downto` 0 = [4, 3, 2, 1, 0]  etc
15:41:18 <zimbatm> I'll use the reverse, this is just for a hack
15:41:54 <Toxaris> hmm, and "downto a b = [a, pred a .. b]" is too much work for a hack?
15:42:31 <zimbatm> hem, not
15:42:37 <kaol> > [True,False..True]
15:42:39 <lambdabot>       Failed to load interface for `False':
15:42:39 <lambdabot>        Use -v to see a list of th...
15:42:50 <kaol> > [True,False .. True]
15:42:52 <lambdabot>   [True]
15:43:07 <Toxaris> > pred False
15:43:09 <lambdabot>   * Exception: Prelude.Enum.Bool.pred: bad argument
15:43:19 <Toxaris> ok, it is too hacky for a hack
15:43:41 <Gracenotes> Toxaris: you wouldn't expect the first element of downto to be the lower possible one, right?
15:43:41 <kaol> > [(),() .. ()]
15:43:43 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
15:43:47 <pumpkin> @seen dons
15:43:48 <lambdabot> dons is in #arch-haskell, #haskell, #ghc, #xmonad, #concatenative, #darcs and #haskell-in-depth. I don't know when dons last spoke.
15:43:49 <Gracenotes> *lowset
15:43:52 <Gracenotes> *lowest
15:44:20 <Cheshire> @src () Enum
15:44:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:44:24 <Cheshire> @src Enum ()
15:44:24 <lambdabot> Source not found.
15:44:27 <sauf_> > pred True
15:44:29 <lambdabot>   False
15:44:32 <Gracenotes> succ = (), pred = ()
15:44:38 <Toxaris> Gracenotes: I expect big `downto` small, but   False `downto` False shouldnt throw an exception
15:45:01 <Gracenotes> ah/
15:45:16 <Gracenotes> then make a special case :)
15:45:38 <Gracenotes> that's part of what minBound is for
15:46:04 <Gracenotes> I think it might be, anyway
15:46:07 <Toxaris> > take <*> iterate pred $ 10
15:46:09 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
15:46:22 <Toxaris> hmm zero is missing :(
15:46:49 <Toxaris> Gracenotes: but for unbounded types, I want to be able to call pred for ever
15:47:19 <ehird> @hoogle Integer -> [a] -> [[a]]
15:47:20 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
15:47:20 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
15:47:20 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:47:25 <ehird> hrmph
15:47:43 <ehird> ah, splitEvery
15:47:44 <Gracenotes> ehird: replicate..?
15:47:48 <Gracenotes> nvm >_>
15:48:24 <mmorrow> bos: ping
15:48:45 <Gracenotes> Toxaris: so what happens if e.g. you reach minBound?
15:48:46 <mmorrow> bos: hpaste2 is at 64.131.71.66 permanently
15:49:41 <BMeph> > take . succ<*> iterate pred $ 10
15:49:43 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
15:49:51 <BMeph> Toxaris: :)
15:49:54 <ehird> @hoogle flatten
15:49:54 <lambdabot> Data.Tree flatten :: Tree a -> [a]
15:49:55 <lambdabot> Distribution.PackageDescription.Configuration flattenPackageDescription :: GenericPackageDescription -> PackageDescription
15:49:55 <lambdabot> Data.Graph flattenSCC :: SCC vertex -> [vertex]
15:49:56 <mmorrow> @tell bos hpaste2 is at 64.131.71.66 permanently
15:49:56 <lambdabot> Consider it noted.
15:49:58 <mreh> could someone tell me what this type constructor "Floating Num" is all about?
15:50:02 <ehird> > join [[1,2],[3,4]]
15:50:03 <lambdabot>   [1,2,3,4]
15:50:09 <mreh> > :type pi
15:50:10 <lambdabot>   <no location info>: parse error on input `:'
15:50:19 <mreh> > @type pi
15:50:21 <lambdabot>   <no location info>: parse error on input `@'
15:50:30 <mreh> fiddlesticks
15:50:34 <BMeph> @ty pi
15:50:36 <lambdabot> forall a. (Floating a) => a
15:50:42 <BMeph> mreh: :)
15:51:09 <Toxaris> BMeph: nice.
15:51:42 <mreh> i dont understand the definition...
15:51:45 <Gracenotes> mreh: there are a bunch of Floating types, like Double, Float, etc. All of them have a pi defined for them.
15:51:51 <mreh> oh
15:52:11 <Heffalump> > pi :: Rational
15:52:13 <lambdabot>       No instance for (Floating Rational)
15:52:13 <lambdabot>        arising from a use of `pi' a...
15:52:22 <Heffalump> shame :-0
15:52:25 <Gracenotes> mreh: it's part of the Floating typeclass.
15:52:28 <int-e> > toRational pi
15:52:29 <Toxaris> mreh: Floating is not a type constructor, but a type class, so many types can be a member of Floating, if they provide an implementation for the Floating methods
15:52:30 <lambdabot>   884279719003555%281474976710656
15:52:33 <BMeph> @instances-importing Floating
15:52:34 <lambdabot> Double, Float
15:52:59 * BMeph shakes his head in sad disappointment...
15:53:02 <Gracenotes> int-e: hurrah, we have finally found pi in rational form... at least, pi-as-a-double in rational form...
15:53:20 <int-e> unsurprisingly, 281474976710656 is a power of two
15:53:26 <Gracenotes> BMeph: well, Floatings also have to have functions like atan, sinh, sqrt, etc.
15:53:36 <Gracenotes> not so easy for rational :)
15:53:52 <mreh> it tells me - has no implementation for the Floating type
15:54:32 <BMeph> mreh: You're trying to make some number both a Floating type and another, incompatible, type. :)
15:54:34 <mreh> actually it tells me it has no implementation for Floating Int
15:54:37 <Toxaris> mreh: that probably means that you use a function which wants a type in the Floating class (like Float or Double) but you give it a type which is not in that class (like Int or Integer)
15:55:25 <bos> mmorrow: dns fixed
15:55:25 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
15:55:36 <mmorrow> bos: sweetness :)
15:55:38 <Toxaris> @type sqrt (1 :: Int) -- mreh: like this
15:55:39 <lambdabot>     No instance for (Floating Int)
15:55:40 <lambdabot>       arising from a use of `sqrt' at <interactive>:1:0-14
15:55:40 <lambdabot>     Possible fix: add an instance declaration for (Floating Int)
15:56:06 <BMeph> mreh: Or rather, you use a function which wants a type in the Floating class (like Float or Double), and a function which wants an Int type.
15:56:17 <pumpkin> is there a way to ask ghc --make to perform multiple tasks simultaneously? (like make -jN)
15:56:31 <pumpkin> ideally an env var I can set
15:56:37 <kumma> why Ix's index gives Int and not Integer?
15:56:37 <Toxaris> > sqrt (fromIntegral (1 :: Int)) -- mreh: but now it works, because fromIntegral can convert from Int to e.g. Float or Double
15:56:39 <lambdabot>   1.0
15:57:10 <pumpkin> kumma: on machines where you could conceivably run out of 32-bit indices, Int is 64 bits
15:57:24 <pumpkin> just a guess though
15:57:27 <pumpkin> :)
15:57:52 <kumma> I just did
15:58:03 <pumpkin> ?
15:58:06 <zimbatm> what kind of haskell reference do you guys use ?
15:58:11 <pumpkin> you ran out of indices?
15:58:18 <BMeph> kumma, pumpkin: Because Integers can't be unboxed, maybe? :)
15:58:19 <zimbatm> I kinda like Zvon but it is incomplete
15:58:19 <mmorrow> @where hpaste2
15:58:20 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
15:58:26 <mmorrow> @where+ hpaste2 http://hpaste.org/
15:58:26 <lambdabot> Good to know.
15:58:44 <BMeph> zimbatm: Use hoogle.org :)
15:58:58 <pumpkin> hooooooooooooooooooogle
15:59:00 <lispy> hoogle.org?  I thought it was haskell.org/hoogle
15:59:01 <Gracenotes> *op change topic :)
15:59:06 <BMeph> zimbatm: Or Hayoo. :)
15:59:21 <pumpkin> hoogle.org is weird
15:59:22 * BMeph pokes mmorrow
15:59:35 <sm_> haskell.org/hoogle
15:59:37 <Gracenotes> pumpkin: I feel awkward typing "Hoogle" in public
15:59:44 <int-e> hmm. can you wait the 24 hours that it'll take for the old hpaste.org entries to expire from caching name servers?
15:59:58 <mmorrow> BMeph: heya
16:00:21 <zimbatm> from hoogle.org: "Are you a Lesbian that smokes? Would you like to quit smoking?" .. wtf ?
16:00:38 <int-e> (for now, people may have better luck with www.hpaste.org because that was never advertised, I think.)
16:00:42 <mmorrow> int-e: it's still at the other one too, but the db's will begin to diverge as of 10 minutes ago
16:00:44 <sm_> is there a list somewhere of the common "might break" functions - like head, read, etc. ?
16:01:08 <Toxaris> zimbatm: like everyone, I use http://haskell.org/hoogle/ as an entry point to documentation which belongs to ghc (for base libs) or to libs on hackage. hoogle is also available as a stand-alone executable.
16:01:15 <int-e> mmorrow: the other one (65.254.53.221) gives me Service Temporarily Unavailable
16:01:27 <mmorrow> oh crap, oops
16:01:32 <mmorrow> i'll fix
16:01:45 <mmorrow> int-e: oh, wait
16:01:54 <mmorrow> are you talking about hpaste.org ?
16:02:00 <int-e> yes
16:02:00 <mmorrow> (it's been down for weeks)
16:02:04 <sm_> zimbatm: also, if you use emacs I highly recommend the integration for hoogling function names from your source
16:02:05 * BMeph has never seen, but would like to see, a "flaming lesbian"
16:02:07 <int-e> I know
16:02:22 <mmorrow> int-e: oh, i'm confused then on what you're asking me
16:02:36 <int-e> mmorrow: I know you updated the name server. which works, but will not affect cached entries for up to 24 hours.
16:02:41 <mmorrow> (bos owns the name hpaste.org)
16:03:07 <zimbatm> heh, hoogle looks nice
16:03:21 <int-e> mmorrow: sorry, bos did. right.
16:03:36 <sm_> it doesn't find as much as hayoo though
16:03:51 <zimbatm> I would be nice if the methods had more accompanying example
16:03:59 <mmorrow> (also, i'm clueless about these matters, so if you're still asking me to do something, you'll need to be explicit about what :)
16:04:00 <BMeph> Off to spend my paycheck -- bbiab. :)
16:04:02 <int-e> oh well, I guess 24 hours of confusion won't be too bad.
16:04:09 <pumpkin> so no option to ask for parallel builds on ghc?
16:04:23 <pumpkin> http://hackage.haskell.org/trac/ghc/ticket/910
16:04:25 <Gracenotes> tsk tsk... brothels are so unbecoming of BMeph
16:04:27 <pumpkin> guess not
16:04:54 <int-e> mmorrow: I was wondering about waiting 24 hours before advertising the hpaste.org URL again, because by then the old DNS entries will have expired.
16:05:42 <mmorrow> int-e: ohhh, i see. ok
16:10:47 <Saizan_> so i've changed the url in the topic the same day you redirected the old domain?:)
16:12:49 <michaelcdever> hey all, quick question, i have a list of filepaths, and i want to use System.FilePath.splitFileName to split them, how would i go about that, and getting a [(_, name)] as a result?
16:13:19 <Saizan_> ?type splitFileName
16:13:21 <lambdabot> Not in scope: `splitFileName'
16:13:35 <Saizan_> ?hoogle splitFileName
16:13:35 <lambdabot> System.FilePath.Posix splitFileName :: FilePath -> (String, String)
16:13:36 <lambdabot> System.FilePath.Windows splitFileName :: FilePath -> (String, String)
16:13:48 <Saizan_> michaelcdever: map splitFileName ?
16:17:11 <michaelcdever> Saizan: cool thanks that worked!
16:17:25 <michaelcdever> you wouldnt believe how long ive been trying to do that
16:17:53 <pumpkin> OMG augustss is writing superfast BASIC
16:26:05 <ozy`> let foldl'2 op1 op2 xs = case xs of { [lh,rh] -> op1 lh rh; (lh:rh:rest) -> (op1 lh rh) `op2` foldl'2 op1 op2 (rh:rest); _ -> error "whoops" } in foldl'2 (<) (&&) [1..10]
16:26:08 <ozy`> gaaahhh
16:26:11 <ozy`> > let foldl'2 op1 op2 xs = case xs of { [lh,rh] -> op1 lh rh; (lh:rh:rest) -> (op1 lh rh) `op2` foldl'2 op1 op2 (rh:rest); _ -> error "whoops" } in foldl'2 (<) (&&) [1..10]
16:26:13 <lambdabot>   True
16:26:25 <ozy`> ^ is there a better name for this?
16:27:00 <pumpkin> oh my
16:27:54 <pumpkin> it's a pairwise fold?
16:27:57 <ozy`> yup
16:30:04 <ozy`> I guess foldlPw works
16:30:11 <ozy`> it's a little less confusing-looking
16:30:14 <bos> At what point do assertions get dropped by ghc?
16:30:23 <pumpkin> why not generalize it to an n-long sliding window?
16:30:35 <ozy`> pumpkin: because this is all I need
16:30:36 <mmorrow> @type \(<>) (><) -> foldr1 (><) . fmap (uncurry (<>)) . (zip`ap`tail)
16:30:37 <lambdabot> forall c a. (a -> a -> c) -> (c -> c -> c) -> [a] -> c
16:30:54 <mmorrow> , (\(<>) (><) -> foldr1 (><) . fmap (uncurry (<>)) . (zip`ap`tail)) (<) (&&) [1..10]
16:30:55 <lunabot>  True
16:31:04 <ozy`> what the hizazzy is this (<>) (><) (?!?) shiznat
16:31:09 <mmorrow> zip`ap`tail rulz
16:31:17 <pumpkin> great naming
16:31:24 <mmorrow> @quote zip`ap`tail
16:31:24 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:31:43 <ozy`> @index ap
16:31:44 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
16:31:44 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
16:31:51 <mmorrow> @type ap
16:31:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:32:04 <mmorrow> , (zip`ap`tail) [0..9]
16:32:05 <lunabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)]
16:32:41 <mmorrow> @pl \xs -> zip xs (tail xs)
16:32:42 <lambdabot> ap zip tail
16:32:47 <whee> ...I could've used that a week ago :(
16:33:01 <mmorrow> heh
16:33:21 <pumpkin> in that sense `ap` could be thought of as a pronoun :P
16:33:59 <ozy`> > let foldlPw op hop = foldl1 hop . ap (zipWith op) tail in foldlPw (<) (&&) [1..10]
16:34:01 <lambdabot>   True
16:34:06 <ozy`> awesome
16:34:55 <mmorrow> but then you don't get to say "zip`ap`tail" ;)
16:35:07 <ozy`> I don't mind
16:35:10 <mmorrow> hehe
16:35:33 <ozy`> zip`ap`tail is pretty awesome but this is fine for what I'm... you know... actually trying to accomplish
16:35:51 <Gracenotes> > 5*7 :: Expr
16:35:51 <mmorrow> zipWith does rool though..
16:35:52 <lambdabot>   5 * 7
16:36:09 <ozy`> > zip `ap` tail :: Expr
16:36:11 <lambdabot>   Couldn't match expected type `Expr'
16:36:14 <ozy`> bah
16:36:33 <mmorrow> @pl \(<>) xs ys -> fmap (uncurry (<>)) (zip xs ys)
16:36:34 <lambdabot> (line 1, column 3):
16:36:34 <lambdabot> unexpected "<"
16:36:34 <lambdabot> expecting pattern
16:36:40 <mmorrow> @pl \f xs ys -> fmap (uncurry f) (zip xs ys)
16:36:41 <lambdabot> (. zip) . (.) . fmap . uncurry
16:37:16 <mmorrow> @let myZipWith = (. zip) . (.) . fmap . uncurry
16:37:18 <lambdabot>  Defined.
16:38:03 <mmorrow> > myZipWith zip (replicate 2 [0..3]) [42..]
16:38:05 <lambdabot>       No instance for (Enum [b])
16:38:05 <lambdabot>        arising from the arithmetic sequence ...
16:38:10 <mmorrow> > myZipWith zip (replicate 2 [0..3]) (repeat [42..])
16:38:12 <whee> I completely don't understand how zip `ap` tail works
16:38:12 <lambdabot>   [[(0,42),(1,43),(2,44),(3,45)],[(0,42),(1,43),(2,44),(3,45)]]
16:38:25 <mstr> What does "Just" mean?
16:38:28 <mmorrow> it does (\xs -> zip xs (tail xs)
16:38:30 <mmorrow> )
16:38:38 <int-e> @src Maybe
16:38:39 <lambdabot> data Maybe a = Nothing | Just a
16:38:43 <mmorrow> , ([0..3], tail [0..3])
16:38:44 <lunabot>  ([0,1,2,3],[1,2,3])
16:38:53 <mstr> yea, that's exactly where I saw it'
16:38:54 <ozy`> mstr: "Just x" is haskell-ese for "x, which is not null"
16:38:59 <mmorrow> , zip [0..3] (tail [0..3])
16:39:00 <lunabot>  [(0,1),(1,2),(2,3)]
16:39:03 <int-e> mstr: it's a data constructor
16:39:05 <ozy`> mstr: as opposed to "Nothing", which is "null"
16:39:06 <whee> oh, I see
16:39:13 <mstr> ozy`: why can't it be "x" instead of "Just x" ?
16:39:20 <mmorrow> @pl \xs -> zip xs (tail xs)
16:39:20 <lambdabot> ap zip tail
16:39:25 <whee> the type of ap confused me :\
16:39:37 <mmorrow> yeah, it's a trickster
16:39:40 <ozy`> mstr: because you can't have null values for arbitrary types
16:39:42 <int-e> mstr: x  has a different type than  Just x
16:39:49 <ozy`> mstr: mainly because that's almost always meaningless
16:39:58 <Gracenotes> > zip =<< tail $ [0..3]
16:40:00 <lambdabot>   [(1,0),(2,1),(3,2)]
16:40:08 <Gracenotes> to switch around the pairs
16:40:12 <ozy`> so, there's a (generic) wrapper for "null" values
16:40:22 <mstr> @type Just
16:40:23 <lambdabot> forall a. a -> Maybe a
16:40:28 <mmorrow> @pl \(a,b) -> (b,a)
16:40:29 <lambdabot> uncurry (flip (,))
16:41:02 <mmorrow> @pl \(a,(b,c)) -> ((a,b),c)
16:41:02 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (,))
16:41:05 <mstr> Just a means Maybe a, and Maybe a means Just a or Nothing?
16:41:10 <mstr> wat? :D
16:41:12 <mmorrow> @pl \((a,b),c) -> (a,(b,c))
16:41:13 <lambdabot> uncurry (uncurry ((. (,)) . (.) . (,)))
16:41:46 <mmorrow> @pl uncurry ((`ap` snd) . (. fst) . ((,) .) . (,)) . uncurry (uncurry ((. (,)) . (.) . (,)))
16:41:47 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (,)) . uncurry (uncurry ((. (,)) . (.) . (,)))
16:41:48 <int-e> mstr: Maybe a  is the type.  Just b  has type  Maybe a  if  b   has type  a. Nothing has type  Maybe a  for any type  a.
16:41:53 <mmorrow> @unpl uncurry ((`ap` snd) . (. fst) . ((,) .) . (,)) . uncurry (uncurry ((. (,)) . (.) . (,)))
16:41:53 <lambdabot> (\ j -> uncurry (\ m -> (\ ab -> ((,)) (((,)) m (fst ab))) >>= \ aj -> snd >>= \ ai -> return (aj ai)) (uncurry (uncurry (\ v ah g -> ((,)) v (((,)) ah g))) j))
16:42:53 <mmorrow> > (uncurry ((`ap` snd) . (. fst) . ((,) .) . (,)) . uncurry (uncurry ((. (,)) . (.) . (,)))) ((0,1),2)
16:42:55 <lambdabot>   ((0,1),2)
16:43:20 <int-e> mstr: and all values of type  Maybe a  are either bottom (i.e. undefined; some kind of error),  Just x  where  x  has type  a, or Nothing.
16:43:33 <int-e> mstr: note that you can have types like  Maybe (Maybe a)
16:43:48 <mstr> Just a "converts" a to type Maybe a ?
16:43:49 <int-e> @type Just (Just (Just "hello!")))
16:43:50 <lambdabot> parse error on input `)'
16:43:54 <int-e> @type Just (Just (Just "hello!"))
16:43:55 <ozy`> mstr: Maybe is the type name. Just and Nothing are actual values of type Maybe.
16:43:56 <lambdabot> Maybe (Maybe (Maybe [Char]))
16:44:22 <mmorrow> > (zip`ap`tails) [0..4]
16:44:24 <lambdabot>   [(0,[0,1,2,3,4]),(1,[1,2,3,4]),(2,[2,3,4]),(3,[3,4]),(4,[4])]
16:45:10 <mmorrow> > (zip`ap`inits) [0..4]
16:45:11 <lambdabot>   [(0,[]),(1,[0]),(2,[0,1]),(3,[0,1,2]),(4,[0,1,2,3])]
16:45:39 <mmorrow> > (zip`ap`(tail.inits)) [0..4]
16:45:41 <lambdabot>   [(0,[0]),(1,[0,1]),(2,[0,1,2]),(3,[0,1,2,3]),(4,[0,1,2,3,4])]
16:45:43 <Gracenotes> mstr: for example, consider the function called "lookup"
16:45:45 <Gracenotes> @type lookup
16:45:47 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:45:51 <int-e> mstr: I guess you could say that, but it's misleading. 'Just' is a single argument data constructor. A data constructor generally takes zero or more arguments, and returns a value of the corresponding algebraic data type.  data Foo = Bar Int Int <-- here, Bar 0 0 will construct a value of type Foo.
16:45:52 <Gracenotes> lookup tries to find an element in a list of pairs
16:46:03 <Gracenotes> > lookup "banana" [("apple", 4), ("orange", 93), ("banana", 32)]
16:46:05 <lambdabot>   Just 32
16:46:15 <Gracenotes> > lookup "pineapple" [("apple", 4), ("orange", 93), ("banana", 32)]
16:46:16 <lambdabot>   Nothing
16:46:28 <Gracenotes> the function doesn't know beforehand if the value you give it is in the list.
16:46:32 <mmorrow> @pl \xs -> zip (inits xs) (tails xs)
16:46:32 <lambdabot> liftM2 zip inits tails
16:46:34 <int-e> mstr: So in the case of 'Just' it only looks like a conversion because there is only one argument.
16:46:50 <athos> :t join
16:46:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:48:03 <mmorrow> @let k << (f, g) = liftM2 k f g
16:48:04 <lambdabot>  Defined.
16:48:24 <mmorrow> > (zip << (inits, tails)) [0..4]
16:48:25 <lambdabot>   [([],[0,1,2,3,4]),([0],[1,2,3,4]),([0,1],[2,3,4]),([0,1,2],[3,4]),([0,1,2,3...
16:50:29 <drguildo> can someone please explain why http://pastebin.com/m5c5e41e0 doesn't work?
16:50:54 <mmorrow> > vcat . fmap (text . show) $ (zip << (inits, tails)) [0..1]
16:50:56 <lambdabot>   ([],[0,1])
16:50:56 <lambdabot>  ([0],[1])
16:50:56 <lambdabot>  ([0,1],[])
16:51:30 <Gracenotes> @type vcat
16:51:32 <lambdabot> [Doc] -> Doc
16:51:37 <int-e> drguildo: "doesn't work" is not very specific
16:52:10 <drguildo> it's specific enough
16:52:13 <int-e> drguildo: but you're missing a 'do' after 'else'
16:52:42 <int-e> drguildo: no, if you'd have provided the type error with the paste I wouldn't have had to copy the file and fire up ghci to see the error.
16:52:50 <Gracenotes> O:
16:53:15 <drguildo> sorry
16:53:16 <drguildo> thanks
16:53:17 <drguildo> bye
16:53:25 <pumpkin> o.O
16:54:20 <int-e> I guess I could've phrased that more politely, sorry.
16:54:48 <mmorrow> , (\f argv stmts -> text "function" <+> text f <> parens (hcat . punctuate comma . fmap text $ argv) <+> text "{" $+$ nest 2 (vcat . fmap ((<>semi).text) $ stmts) $+$ text "}") "const" ["x","y"] ["return(x)"]
16:54:49 <lunabot>  function const(x,y) {
16:54:49 <lunabot>    return(x);
16:54:49 <lunabot>  }
16:55:15 <pumpkin> int-e: I was o.Oing at his attitude more than yours :P
16:56:38 <ozy`> mmorrow: wh... what?
16:56:47 <ozy`> @_@
16:58:33 <mmorrow> Text.PrettyPrint ftw
16:58:41 <athos> how does lambdabot's check work?
16:58:48 <pumpkin> it's quickcheck
16:58:50 <thoughtpolice> athos: it uses quickcheck
16:59:24 <athos> same syntax?
16:59:47 <pumpkin> it's just haskell
17:00:12 <pumpkin> it wants functions that return Testable instances iirc
17:00:14 <athos> @check reverse xs == (reverse $ reverse $ reverse xs)
17:00:15 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
17:00:24 <lispy> ?check \x -> x == (x :: Bool)
17:00:27 <lambdabot>   "OK, passed 500 tests."
17:00:39 <athos> ah.
17:00:44 <ddarius> @check \x -> x == (x :: Double)
17:00:46 <mmorrow> , foldr (.) id (concatMap (replicate 4) [braces, parens, brackets]) (int 42)
17:00:46 <lambdabot>   "OK, passed 500 tests."
17:00:47 <lunabot>  {{{{(((([[[[42]]]]))))}}}}
17:00:48 <ddarius> Lies!
17:00:56 <whee> @check \xs -> xs == sort xs
17:00:57 <lambdabot>   "OK, passed 500 tests."
17:01:11 <lispy> athos: it has some pretty bad default types tho, so make sure to tell it what types you want.  I think for example that lists default to [()]
17:01:33 <lispy> ?check \xs -> xs == sort (xs :: [Int])
17:01:35 <lambdabot>   "Falsifiable, after 4 tests:\n[3,3,-3,-3]\n"
17:01:41 <pumpkin> how often does the Double arbitrary instance generate NaN or infinity?
17:01:50 <pumpkin> @check \x -> x == (x :: Double)
17:01:52 <lambdabot>   "OK, passed 500 tests."
17:01:58 <mmorrow> @check \x -> x == (x+pi-pi::Double)
17:02:00 <lambdabot>   "Falsifiable, after 0 tests:\n0.3333333333333333\n"
17:02:02 <ddarius> pumpkin: I'm pretty sure it doesn't.
17:02:12 <pumpkin> ddarius: ever? :(
17:02:16 <pumpkin> that seems sad
17:02:38 <ddarius> @scheck \x -> x == (x :: Double)
17:02:40 <lambdabot>   "OK, passed 500 tests."
17:02:51 <ddarius> Curses
17:03:09 <int-e> @scheck \x -> x/x == (x/x :: Double)
17:03:11 <lambdabot>   "Falsifiable, after 0 tests:\n0.0\n"
17:04:47 <athos> @bot
17:04:47 <lunabot>  :)
17:04:51 <dagit> mmorrow: neat example showing that (==) for floating point types is tricky :)
17:04:53 <mmorrow> um, i think lambdabot just looped
17:04:54 <athos> whoops
17:05:03 <lambdabot> :)
17:05:09 <dagit> No the server lambdabot is on is having troubles
17:05:10 <mmorrow> dagit: (+) also isn't associative
17:05:15 <mmorrow> dagit: ah
17:05:28 <dagit> That's why I'm using this nick at the moment :)
17:05:31 <dagit> (my normal nick is lispy)
17:05:43 <mmorrow> (+)/(-) by tiny amounts is super unstable (numerically)
17:05:47 <mmorrow> @check \x -> x == (x+0.0000000003-0.0000000003::Double)
17:05:48 <lambdabot>   "OK, passed 500 tests."
17:05:50 <mmorrow> @check \x -> x == (x+0.0000000003-0.0000000003::Double)
17:05:52 <lambdabot>   "OK, passed 500 tests."
17:05:54 <mmorrow> grr
17:06:14 <mmorrow> @check \x -> x == (x+0.0000000003-0.0000000003::Double)
17:06:15 <lambdabot>   "Falsifiable, after 107 tests:\n16.0\n"
17:06:35 <dagit> mmorrow: yeah, and I think that's a cool way to demonstrate it.  We do a lot of engineering calcs where I work and I sometimes struggle explainning to co-workers why straight up equality tests on computed doubles/floats is bad
17:07:24 <mmorrow> dagit: yeah, @check is a pretty awesome way to see that
17:07:53 <dagit> The other thing that we don't have at work that we should is libraries for managing the physical units in our calcs.  It could help us catch lots of typo related bugs before they make it into production
17:08:16 <ddarius> Bah, people should just learn the algebra of floating point arithmetic and write code that will produce exact answers in it.
17:09:07 <mmorrow> dagit: oh that's a cool idea. a lib for unit conversion where proper conversion is enforced by the types
17:09:27 <dagit> mmorrow: well we have to libs for that in haskell.  Dimensional and Dimensionalized Numbers
17:09:36 <dagit> mmorrow: but I don't use Haskell at work :)
17:09:41 <mmorrow> oh rly? cool
17:09:53 <mmorrow> dagit: what lang?
17:09:55 <ddarius> dagit: Use F#.  They apparently have that built in.
17:10:06 <ddarius> I'm sure there are also similar things for C++.
17:10:17 <mmorrow> what, like furlongToNauticalMile ??
17:11:15 <mmorrow> @go furlong to nautical mile
17:11:17 <lambdabot> http://www.metric-conversions.org/length/furlongs-to-nautical-miles.htm
17:11:17 <lambdabot> Title: Furlongs to Nautical Miles conversion calculator
17:11:41 <mmorrow> too bad @go doesn't grab the google calc results
17:11:45 <pumpkin> I think google can convert them too
17:11:46 <ddarius> @google 1 furlong to nautical miles
17:11:48 <lambdabot> http://www.navmetoccom.navy.mil/educate/neptune/lesson/math/nautical.htm
17:11:48 <lambdabot> Title: NEPTUNE'S WEB - Oceanography Lesson Plans for Math; Nautical Measurements, Conve ...
17:12:05 <ddarius> @google 1 furlong in nautical miles
17:12:07 <lambdabot> http://www.navmetoccom.navy.mil/educate/neptune/lesson/math/nautical.htm
17:12:07 <lambdabot> Title: NEPTUNE'S WEB - Oceanography Lesson Plans for Math; Nautical Measurements, Conve ...
17:12:11 <ddarius> Oh well
17:13:05 <dagit> ddarius: sadly, We mainly use python.  Sometimes .NET but they execpt .NET to be C# and VB :)
17:14:14 <dagit> I think realistically the closest I can come to using Haskell to make the python code better is to either 1) make a code analysis tool for python in haskell, 2) make a haskell to python translator
17:14:47 <mmorrow> you could use haskell to /generate/ python code
17:14:53 <dagit> #2 sounds the most attractive to me.  I can program with the power and strength of haskell's static types and then generate the python :)
17:15:03 <dagit> mmorrow: I guess that's what I mean by #2
17:15:27 <dagit> Either via a DSL or full source to source translation
17:15:28 <mmorrow> i think generating code would both play to haskell's strengths and show the most per unit of work
17:15:58 * geezusfreeek needs more excuses to use haskell at work too
17:16:06 <dagit> mmorrow: so you're thinking that I would use an embedded domain specific language?
17:16:15 <mmorrow> i'm thinking purely generative, like a DSL i guess. parsing the python, then transforming it would be a huge hassle (up front at least)
17:16:33 <dagit> I would parse Haskell and translate to python if I did parsing
17:16:45 <_kit_> why
17:16:49 * _kit_ works in Python everyday
17:16:56 <mmorrow> like constructing python ASTs, with the power of zipWith, fmap, etc..
17:17:18 <_kit_> funcutils ?
17:17:19 <dagit> _kit_: mostly for the static analysis and having a lightweight proof assistant.  You don't have that with python
17:17:44 * _kit_ nods.. function annotations will make some of the static analysis stuff easier
17:17:57 <_kit_> once more libs support Py3000,
17:18:17 <geezusfreeek> hmm... now i'm tempted to make a dsl for C kernel code
17:18:25 <_kit_> just curious.. I love haskell & Python, but I tend to use them for completely different things
17:18:51 <mmorrow> , (vcat . fmap ppDoc) `fmap` (let f n | n == 1 = mkName "." | n > 1 = mkName (replicate (n-1) '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in mapM dots [5..6])
17:18:53 <lunabot>  (....:) = (.) . ((.) . ((.) . ((.) . (.))))
17:18:53 <lunabot>  (.....:) = (.) . ((.) . ((.) . ((.) . ((.) . (.)))))
17:18:57 <mmorrow> stuff like that
17:19:24 <mmorrow> you could do that over [2..1000] and generate 998 decls (e.g. and being sensational ;)
17:19:51 <dagit> _kit_: right.  python tends to do well as glue code because dynamic typing is handy there.
17:19:53 <mmorrow> (that's just the one-liner i had closest at-hand)
17:20:11 <jberryman> is it more efficient to use record syntax for updating, rather than say: f (Foo a _) c = (Foo a c) ?
17:20:28 <mmorrow> just s/template-haskell/your-new-leet-template-python-in-haskell/
17:20:31 <dagit> _kit_: in my experience, Haskell is annoying when using COM but python is pretty efficient in terms of developer time
17:20:32 <jberryman> in particular I'm storing partially-applied types
17:22:24 <mmorrow> i remember reading about some company that reimplemented their <something-related-to-controlling-cars> system in haskell and reduced their loc massively, the most relevant part of this being they still implemented it in C and just use haskell to /generate/ all the C
17:22:43 <mmorrow> 10s of thousands of loc reduction
17:23:02 <Gracenotes> > let a = (5::Int) in a/0
17:23:04 <lambdabot>       No instance for (Fractional Int)
17:23:04 <lambdabot>        arising from a use of `/' at <i...
17:23:19 <Gracenotes> oh, I see what GHC did there. x-x
17:23:34 <geezusfreeek> i'm already using tons of preprocessor macros in the project i'm working on right now. all i have to do is convince myself to start using haskell to do the same thing :)
17:23:46 <Gracenotes> odd, there's a DivideByZero error in GHC.Err. Not sure if it ever gets used...
17:24:47 <pumpkin> why wouldn't it?
17:24:55 <pumpkin> > (1 :: Int) / 0
17:24:57 <lambdabot>       No instance for (Fractional Int)
17:24:57 <lambdabot>        arising from a use of `/' at <i...
17:25:01 <Gracenotes> where, then?
17:25:05 <pumpkin> > (1 :: Int) `div` 0
17:25:06 <lambdabot>   * Exception: divide by zero
17:25:29 <Gracenotes> are you sure that's it?
17:25:37 <pumpkin> no, but I'd imagine that would be it
17:26:27 <Gracenotes> aha
17:26:34 <Gracenotes> divMod  x@(I8# x#) y@(I8# y#)
17:26:36 <Gracenotes> | y == 0                     = divZeroError
17:26:40 <Gracenotes> you are correct :)
17:26:41 <dagit> It was fun chatting about Haskell and code generators, but I need to get going.  Talk to you guys later!
17:27:13 <Gracenotes> bye, dagit :D
17:27:28 <mmorrow> seeya
17:27:34 <Gracenotes> er... or I could have just grepped for divZeroError >_>
17:27:57 <pumpkin> grep fail
17:36:05 <jberryman> is there a way to profile code so that every named function has its own cost center?
17:36:13 <pumpkin> -auto-all
17:36:16 <dancor> @pl f `ignoring` g = f >>= \ r -> g >> return r
17:36:17 <lambdabot> (line 1, column 16):
17:36:17 <lambdabot> unexpected "="
17:36:17 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
17:36:32 <dancor> @let f `ignoring` g = f >>= \ r -> g >> return r
17:36:34 <lambdabot>  Defined.
17:36:46 <dancor> @pl f `ignoring` g
17:36:47 <lambdabot> f `ignoring` g
17:36:49 <dancor> heh
17:37:01 <dancor> @pl \ f g -> f >>= \ r -> g >> return r
17:37:02 <lambdabot> (. ((. return) . (>>))) . (>>=)
17:37:18 <jberryman> pumpkin: sorry, I mean even sub-expressions in where clauses, etc
17:37:23 <pumpkin> oh
17:37:35 <pumpkin> I think you need to litter it with cost centers yourself
17:38:27 <jberryman> okay, thanks
17:40:34 <dancor> what's a better name than ignoring for that
17:41:07 <ddarius> dancor: (<*)
17:41:11 <dancor> lol
17:41:34 <ddarius> :t (<*)
17:41:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:41:52 <dancor> :t (*>)
17:41:52 <ddarius> :t ignoring
17:41:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
17:41:54 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> m a1 -> m a
17:42:19 <ddarius> :t liftM2 const
17:42:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
17:42:49 <dancor> my whole concept of programming has collapsed into a densely connected graph
17:44:33 <lepassive> is it me or http://pastebin.com/d28ee59c6 isn't really good code ?
17:46:09 <Saizan> yeah, it's full of repetitions
17:46:23 <Saizan> that you can eliminate by making a monad
17:47:08 <Gracenotes> the code is refactored in a later chapter using a monad, actually
17:47:08 <lepassive> Saizan, wasn't that case study should be discussed after Monads chapter at least :(
17:47:30 <Gracenotes> so don't worry about it -- chapter 14 covers how to make that better code :)
17:47:53 <Gracenotes> (and many other resources as well)
17:48:00 <lepassive> Gracenotes, I hope i guess i'll drop that chapter for now
17:48:24 <defun> hey. I'm asked by a friend to explain datatypes to him. Would it be correct if I told him that they are containers of data (he's never programmed b4)?
17:49:04 <Gracenotes> lepassive: learning about monads is not at all necessary for successfully finishing the case study... it's your choice
17:49:47 <Saizan> defun: they more generally represent data/information
17:50:14 <lepassive> Gracenotes, hmmm I guess I'll check the refractored code and keep going
17:50:18 <defun> right. many thanks, saizan.
17:50:32 <Saizan> lepassive: you could write combinators to abstract away the repetitions even without knowing about monads
17:51:09 <lepassive> btw, why the author declared (>>?) isn't >>= in Maybe monad enough ?
17:54:09 <Gracenotes> the name >>= is already taken :)
17:55:07 <Gracenotes> (>>?), or whatever you choose to call it, is just a way of chaining computations. (It so happens that this chaining can be generalized.)
17:55:38 <lepassive> Gracenotes, that's my point, doesn't Maybe monad supports the bind operation ?
17:56:44 <defun> perhaps a dumb question, but is this (g . f) the same as this (f >>= g)?
17:57:39 <Gracenotes> lepassive: it does. In fact, the code should compile if you use >>= instead of >>?. However, perhaps you can humor the authors and use their notation :)
17:57:44 <ddarius> defun: No
17:58:01 <defun> k
17:58:27 <lepassive> Gracenotes, Thanks god I thought i should re-visit the Monads to know the point of using >>?
18:01:30 <sereven> hmm, anyone help me with better way to write this key io to cycle a list? http://www.unsafecoerce.com:8080/fastcgi/hpaste.fcgi/view?id=1227
18:06:17 <augustss_> @users
18:06:18 <lambdabot> Maximum users seen in #haskell: 699, currently: 641 (91.7%), active: 11 (1.7%)
18:06:43 <raxeax> @user
18:06:44 <lambdabot> Maximum users seen in #haskell: 699, currently: 641 (91.7%), active: 12 (1.9%)
18:07:03 <augustss_> @use
18:07:03 <lambdabot> Maximum users seen in #haskell: 699, currently: 641 (91.7%), active: 12 (1.9%)
18:07:09 <raxeax> @u
18:07:09 <lambdabot> Maybe you meant: undefine undo unlambda unmtl unpf unpl unpointless uptime url users . ? @ v
18:07:21 <sereven> @us
18:07:21 <lambdabot> Maximum users seen in #haskell: 699, currently: 641 (91.7%), active: 12 (1.9%)
18:07:26 <sereven> cause we're us
18:07:32 <raxeax> haha
18:07:38 <raxeax> @uptime
18:07:38 <lambdabot> uptime: 1d 13h 53m 44s, longest uptime: 1m 10d 23h 44m 29s
18:10:01 <ivanm> augustss_: is that BASIC library of yours meant to be serious, or just a bit of fun?
18:10:03 <sereven> or more specifically regarding the code I pasted. What is haskelly way to do io cases rather than 'case () of'? Maybe I'll try refactoring whole thing to use guards somehow.
18:10:41 <ozy`> @let (isComputerOn = return True) :: IO Bool
18:10:41 <lambdabot>   Parse error
18:11:11 <sereven> ozy`: right o, duh, thanks
18:11:12 <ozy`> sereven: IO cases? what?
18:11:16 <lepassive> w2c :: Word8 -> Char \n w2c = chr . fromIntegral ... is the Word8 arg is implicitly passed ?
18:11:32 <ozy`> sereven: ignore what I just wrote, it's nonsense.
18:11:43 <Saizan> ?src (.)
18:11:43 <lambdabot> (f . g) x = f (g x)
18:12:04 <ozy`> sereven: now, what are you actually asking? do you want to have two consecutive IO actions, with one returning (), and ignore that return value?
18:12:23 <Saizan> lepassive: when you've something like f x = g x, you can eliminate x from both sides
18:12:51 <Saizan> here f is w2c and g is (chr . fromIntegral)
18:13:09 <lepassive> Saizan, that's reasonable
18:13:43 <sereven> ozy`: http://www.unsafecoerce.com:8080/fastcgi/hpaste.fcgi/view?id=1227 -- a sequence of IO actions each returning 'X ()'
18:13:49 <int-e> ozy`: you can use   let foo | ... = doStack (n+1) | ... = doStack (n-1)  and then use foo
18:14:17 <int-e> ozy`: it seems more natural than using case to me, but it's really about the same
18:14:42 <ozy`> sereven: what int-e said (I think he meant to address you :p)
18:14:54 <int-e> I did.
18:15:18 <sereven> int-e: yeah, that's what ozy` 's IO Bool example made me think of even though wasn't exactly what wrote
18:15:40 <sereven> thanks folks
18:16:10 <mmorrow> heh, someone found unsafecoerce.com
18:16:21 <mmorrow> :)
18:16:37 <mmorrow> almost forgot about that
18:17:04 <sereven> moonpatio was down or slow or something, so this one showed up on google hpaste2 and now is top of vimperator completions
18:17:29 <ozy`> > let isComputerOn :: IO Bool; isComputerOn = return True in getLine >> isComputerOn -- this is in the IO monad because it's dependent on outside information.
18:17:31 <lambdabot>   * Exception: "<IO Bool>"
18:18:08 * BMeph goes to see if "http://www.unsafecoersehighschoolgirls.com" connects anywhere...
18:18:45 <mmorrow> sereven: unsafecoerce.com actually points to moonpatio.com
18:18:51 <Gracenotes> only if the individual who registered it has the same spelling foibles you do :)
18:19:04 <mmorrow> i was messing with stuff earlier though on moonpatio.com, maybe that was it
18:19:15 <lepassive> I want to know if i'm getting this right "m a -> (a -> m b) -> m b" means we got a monad m has value of type a when it's binded to other monad (m has wraps value b) it passes the *a* to the m b and returns a monad wraps a new value of type b ?
18:19:31 <mmorrow> also, hpaste.org is back up (which points to an (as of an hour or so ago) clone of moonpatio.com
18:19:34 <mmorrow> 's hpaste2))
18:19:49 <Cale> lepassive: "The monad" always refers to the type constructor, in this case m
18:20:36 <Cale> lepassive: The values in any particular monad are usually called actions or computations (or monadic values, more neutrally)
18:21:11 <Cale> So it takes an action producing a value of type a, and a function from values of type a to actions producing values of type b, and gives an action producing values of type b
18:21:33 <int-e> lepassive: in x >>= f, f is a function. what >>= does is "run" the action x (what that means depends on the monad) and pass the result(s) to the function f; that gives another monad action which is then run as well.
18:21:43 <Cale> yes
18:22:01 <Cale> If you're already familiar with do-notation, or even if you're not, it's worth noting that:
18:22:11 <Cale> x >>= f  is the same as  do v <- x; f v
18:22:42 <lepassive> Cale, looks like I got it but didn't express it right right ?
18:22:49 <Cale> lepassive: I think so...
18:23:29 <lepassive> yahooo Cale, int-e(hope you move to a double-e :P)  thanks alot
18:23:35 <dancor> why don't ppl use *> instead of >> more
18:23:43 <Cale> :t (*>)
18:23:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
18:24:43 <ddarius> dancor: (*>) is quite a bit newer than (>>) and also to use it you'd have to make your monad an instance of Applicative.
18:24:57 <Cale> (and import Control.Applicative)
18:25:01 <lepassive> now I've to do some boring PHP for work. see you later guys
18:25:01 <dancor> Cale: seems to go along with your other idea of doing f . g $ h x instead of f $ g $ h x because it has more general infixes
18:25:12 <dancor> s/infixes/substrings
18:25:28 <int-e> dancor: not f . g . h $ x?
18:25:35 <Gracenotes> g'bye, lepassive
18:25:36 <dancor> maybe
18:25:38 <Cale> dancor: I'm pretty sure it's equivalent to (>>) when the functor in question happens to be a monad.
18:25:55 <int-e> @src (*>)
18:25:55 <lambdabot> (*>) = liftA2 (const id)
18:25:58 <performance> > let notnonnegative dval = if dval >= 0::Real then 0 else 1
18:25:58 <Cale> (but it does have a more general type)
18:25:59 <lambdabot>   <no location info>: parse error on input `;'
18:26:16 <dancor> i guess you could get weirder errors using overgeneral types
18:26:39 <int-e> @type liftM2 (const id)
18:26:40 <ddarius> You'd get pretty much the same errors.
18:26:40 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => m a1 -> m a -> m a
18:27:28 <dancor> i've used *> some places in my program where there are analagous <* uses nearby, and now i feel weird bc i have both << and <* 's in my program.. :/
18:27:48 <int-e> << is odd.
18:27:49 <dancor> i meant ">> and *>" at the end there
18:29:04 * dancor is going to stop obsessing
18:40:58 <amberjon> i am looking to recruit a good coder to help me port something from PHP to haskell
18:41:04 <amberjon> it's open source, no money involved by design
18:41:13 <amberjon> and uh
18:41:18 <amberjon> an important advancement for humanity ;)
18:41:40 <cjb> amberjon: you could post about it to the haskell lists
18:41:53 <Zao> The mere concept of something whose domain overlaps both PHP and Haskell boggles my mind.
18:42:00 <ozy`> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1228#a1228 <== I should've known this would break the inference engine...
18:42:02 <pumpkin> a webapp?
18:42:03 <amberjon> Zao: it's mostly functional php
18:42:18 <amberjon> 'functional'
18:42:23 <ozy`> amberjon: that's amazing. how did you get this PHP program to function?
18:43:08 <pumpkin> ozy`: you made the updated haskell module for textmate, right?
18:43:12 <amberjon> injections of bovine growth hormone
18:43:14 <ozy`> pumpkin: yep
18:43:21 <ozy`> I should check in on that
18:43:43 <pumpkin> ozy`: do you have the whole updated module somewhere? I'm on a new computer and just installed textmate
18:43:43 <ozy`> pumpkin: any criticisms? I'd really like to know what more needs fixing :p
18:43:52 <ozy`> uhhh somewhere yeah
18:43:54 <ozy`> hang on
18:44:02 <pumpkin> ozy`: it's looked nicer so far, but haven't done much coding since I got it
18:46:41 * jberryman is getting a headache trying to write a pretty print function for a binary tree
18:47:04 <dancor> jberryman: like /\ form?
18:47:27 <dancor> that's pretty verbose right
18:47:45 <dancor> i.e. need a large screen for not that large tree
18:47:57 <dancor> kwl problem tho
18:48:48 <jberryman> dancor: actually right now I'm just trying to get the nodes to be spaced properly relative to each other (i.e. without any / \ lines)
18:50:07 <ozy`> pumpkin: http://www.rsmw.net/ergo/hsbundle.tgz <-- I take no responsibility for what might break horribly
18:50:19 <pumpkin> AHA!
18:50:24 <pumpkin> :P
18:50:31 <pumpkin> where do I stick it again?
18:50:58 <ozy`> ~/Library/Application Support/TextMate/Bundles/
18:51:40 <pumpkin> whee thanks
18:54:01 <ozy`> no sweat
19:12:07 <ozy`> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1228#a1229 <== I'm having just a bit of trouble with this
19:15:33 <int-e> ozy`: you need a Monad m => context at least.
19:16:03 <ozy`> int-e: it actually detects that part.
19:16:50 <jasondew> anyone able to compile Hieroglyph on ghc 6.10?
19:17:05 <int-e> ozy`: and mapM unpack is wrong, or perhaps unpack should have type Exp -> m a ?
19:17:45 <int-e> *Expr
19:18:41 <ozy`> int-e: ahhhh that's what's wrong
19:19:05 <ozy`> good eye
19:19:06 <ozy`> thanks
19:20:39 <int-e> :)
19:28:08 <jeffwheeler> I'm utterly confused about wrapping monads. I _think_ what I'm trying to do is write a function that will take an action, and turn it into an action of some arbitrary monad. And I have no idea what I'm talking about, so I don't expect anybody to know what I'm trying to do.
19:28:40 <jeffwheeler> But I think what I want has the type signature ThingM a -> m a.
19:29:26 <chessguy> jeffwheeler, can you give a little context?
19:29:40 <jeffwheeler> chessguy: I can upload my project. :)
19:30:00 <chessguy> jeffwheeler, all you have to do is use 'return' to get an arbitrary monad
19:30:11 <chessguy> err, to lift a value into an arbitrary monad
19:30:30 <jeffwheeler> chessguy: that makes sense. Let me play with it a little bit more and see where I get.
19:30:51 <chessguy> @type let foo (Node x []) = return x
19:30:53 <lambdabot> <no location info>:
19:30:53 <lambdabot>     not an expression: `let foo (Node x []) = return x'
19:30:55 <chessguy> @type let foo (Node x []) = return x in foo
19:30:57 <lambdabot> forall t (m :: * -> *). (Monad m) => Tree t -> m t
19:31:02 <chessguy> there ya go
19:31:29 <Gracenotes> chessguy: when you press the red button, this value will be lifted into an arbitrary monad. No one can know which monad it is until it's too late to change it. Do you wish to proceed?
19:31:32 <jeffwheeler> chessguy: hmm, alright, that makes sense. Thanks. :)
19:32:57 <chessguy> Gracenotes, it's ok, universal quantification is your friend :)
19:33:06 <Taejo> > Data.Map.union (Data.Map.singleton 1 'a') (Data.Map.singleton 1 'b')
19:33:07 <lambdabot>   /tmp/8132539877888989753:70:40: Not in scope: `Data.Map.union'/tmp/81325398...
19:33:13 <Taejo> lambdabot: :(
19:33:43 <chessguy> @type let foo (Just x) = return x in foo
19:33:46 <lambdabot> forall t (m :: * -> *). (Monad m) => Maybe t -> m t
19:34:18 <chessguy> interesting that that still assumes the Monad is arbitrary, rather than that it's Just
19:34:19 <Gracenotes> > Map.singleton 3 2
19:34:20 <lambdabot>   fromList [(3,2)]
19:34:25 <chessguy> err, s/Just/Maybe
19:34:48 <SamB> chessguy: it isn't funny
19:34:52 <SamB> it makes perfect sense
19:34:57 <chessguy> who said funny?
19:34:58 <Gracenotes> Taejo: and union is left-biased, so it'll be 'a', I think
19:35:04 <SamB> or interesting even
19:35:09 <Taejo> Gracenotes: yeah, I looked it up
19:35:27 * SamB has just been filling in hundreds of missing type signatures in LHC ...
19:35:29 <chessguy> @type let foo (Just x) = return x in (foo :: Maybe a -> Maybe a)
19:35:31 <lambdabot> forall a. Maybe a -> Maybe a
19:35:32 <Gracenotes> the left-biased feature is verrrry usefulish for partial application :D
19:35:40 <chessguy> SamB well it's interesting to me :)
19:35:42 * SamB has seen much more complicated stuff going on
19:35:52 * chessguy sticks his tongue out at SamB
19:36:08 <Gracenotes> well, except when it's not. In which case there's flip >_>
19:36:27 * chessguy things SamB should do http://blog.tmorris.net/20-intermediate-haskell-exercises/
19:36:32 <chessguy> *thinks
19:36:57 <chessguy> @type flip (>_>)
19:36:58 <lambdabot> parse error on input `)'
19:38:02 <SamB> chessguy: well, that's easier than the BASIC challange
19:38:05 <chessguy> SamB i'm still gathering the implications of universal vs. existential quantification. don't mock my n00biness
19:38:06 <rwbarton> @src flip
19:38:06 <lambdabot> flip f x y = f y x
19:40:21 <Taejo> @hoogle fromMaybe
19:40:22 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
19:44:05 <redditbot> A chicken monad
19:47:59 <chrisdone> a chicken monad?
19:48:05 <chrisdone> a chicken monad‽
19:48:14 <chrisdone> ؟what¿
19:49:02 <jeffwheeler> @src seq
19:49:03 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:49:54 <chessguy_work> jeffwheeler, how goes
19:50:15 <jeffwheeler> chessguy_work: not there yet, but I'm learning.
19:50:33 <jeffwheeler> Is seq the same as sequence? I can't seem to find it defined anywhere, but I think it's somewhere obvious.
19:50:38 <jeffwheeler> @hoogle seq
19:50:39 <lambdabot> Data.Sequence data Seq a
19:50:39 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
19:50:39 <lambdabot> Control.Parallel.Strategies seqList :: Strategy a -> Strategy [a]
19:50:41 <chessguy> no, it's unrleated
19:51:02 <chessguy> @type seq
19:51:03 <lambdabot> forall a t. a -> t -> t
19:51:08 <SamB> @google haskell report seq
19:51:10 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
19:51:10 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
19:51:10 <chessguy> @type sequence
19:51:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:51:18 <juhp_> wonder if anyone has built/tried leksah?
19:51:54 <SamB> http://www.haskell.org/onlinereport/basic.html#sect6.2
19:52:18 <juhp_> the gtk2hs-0.10 dep is tough
19:52:25 <rwbarton> It really seems that hoogle should have found seq.
19:52:35 <chessguy> juhp_ yeah, i'm kinda waiting on that
19:52:56 <chessguy> rwbarton, yeah, i think hoogle is acting slightly weird lately
19:53:14 <chessguy> @index seq
19:53:15 <lambdabot> Prelude, Control.Parallel
19:53:26 <chessguy> @hoogle Prelude.seq
19:53:26 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:53:26 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
19:53:26 <lambdabot> package simseq
19:53:32 <juhp_> suppose I could roll myself a snapshot...
19:53:37 <rwbarton> actually, Hoogle just doesn't know about seq at all (not the web version nor the version I cabal installed a while ago)
19:53:48 <chessguy> odd
19:55:44 <juhp_> aha I see there is a release candidate though
19:59:47 <SamB> seq
19:59:47 <SamB> 1 (Function)	Prelude, GHC.Exts
19:59:47 <SamB> 2 (Function)	GHC.Prim
19:59:47 <SamB> 3 (Function)	Control.Parallel
20:00:17 <SamB> 2nd hit for seq on http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html
20:01:27 <rwbarton> But there's actually no mention of seq on the Prelude page
20:01:52 <SamB> I guess they forgot the type signature
20:02:03 <gwern> @quote ducks
20:02:04 <lambdabot> No quotes match.
20:02:09 <rwbarton> There are also no source links, so we'll never know. :)
20:02:12 <gwern> @remember lilac is happpy with his infinite type. it's ducks all the way across and down.
20:02:13 <lambdabot> It is stored.
20:02:19 <gwern> @quote posset
20:02:19 <lambdabot> No quotes match. stty: unknown mode: doofus
20:02:27 <gwern> @remember Gracenotes You are likely to be eaten by a poset
20:02:28 <lambdabot> Okay.
20:02:32 <gwern> @quote poset
20:02:33 <lambdabot> Gracenotes says: You are likely to be eaten by a poset
20:02:36 <gwern> @quote poset
20:02:37 <lambdabot> Gracenotes says: You are likely to be eaten by a poset
20:02:45 <gwern> @quote 64-bit
20:02:45 <lambdabot> ghc says: GHCi's bytecode generation machinery can't handle 64-bit code properly yet.
20:02:48 <SamB> see, the links are broken when there isn't actually any documentation entry for a specific name ...
20:02:48 <gwern> @quote 64-bit
20:02:49 <lambdabot> RossMellgren says: Apparently 64-bit GHC is sufficiently advanced to be indistinguishable from magic.
20:02:59 <gwern> @quote IOVar
20:03:00 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
20:03:12 <gwern> @remember cjb It's all fun and games until somebody loses an IOVar.
20:03:13 <lambdabot> Done.
20:03:25 <gwern> @quote Ritalin
20:03:25 <lambdabot> No quotes match. It can only be attributed to human error.
20:03:32 <gwern> @remember sigfpe If I took some Ritalin, maybe I could write an entire book on Haskell and algebra.
20:03:33 <lambdabot> I will remember.
20:03:41 <gwern> @quote ddarius
20:03:42 <lambdabot> ddarius says: In the spirit of that article on monoids, we should drop the term "tree" and replace it with the term "free pointed magma"
20:03:44 <gwern> @quote ddarius
20:03:45 <lambdabot> ddarius says: higher order of lambdabot deployment and management engineers or HOLDME
20:03:47 <gwern> @quote ddarius
20:03:48 <lambdabot> ddarius says: You need to spawn children to wash your dishes in parallel.
20:03:51 <gwern> @quote ddarius
20:03:52 <lambdabot> ddarius says: isJust . unsafeCoerce
20:03:52 <chessguy> um
20:03:54 <gwern> bah
20:04:00 <gwern> @quote evaluated
20:04:00 <chessguy> take it to /msg
20:04:01 <lambdabot> <ddarius> says: mmorrow: Nothing is evaluated until it is
20:04:15 <gwern> there we go
20:04:17 <gwern> @flush
20:06:19 <SamB> actually ... I think it's because Haddock doesn't handle things being re-exported between packages well right now
20:06:44 <SamB> (it might be a GHC-side probablem, and so take longer to fix)
20:07:28 <rwbarton> I was actually bemoaning the lack of links to HsColour output
20:07:42 <Taejo> are there cases with type families where GHC can't tell that something is an instance of a class?
20:07:43 <gwern> isn't --hscolour a haddock option?
20:07:52 <rwbarton> for the last 4 months I've been changing "latest" to "6.8.2" every time I want to see some source code
20:07:57 <Taejo> (in GHC 6.8)
20:08:28 <SamB> gwern: when I complained about it they said something about hscolour perhaps not having been installed on the machine they built the 6.10.1 docs on ...
20:08:29 <ivanm> Taejo: if the module where it's made an instance is imported, then ghc knows
20:09:43 <SamB> (recall that seq is a primitive, and is therefore not defined in base anymore, but in ghc-prim)
20:10:38 <Taejo> SamB: isn't seq defined as (\a b -> case a of _ -> b) ?
20:10:41 <rwbarton> oh, so it's a cross-package import now?  hmm
20:10:50 <gwern> SamB: did they fix that?
20:10:51 <SamB> Taejo: it CAN'T be defined that way in Haskell
20:11:01 <SamB> gwern: fix what ?
20:11:08 <Taejo> SamB: am I thinking of ghc core?
20:11:12 <SamB> gwern: they promised to do it right next time
20:11:16 <SamB> Taejo: possibly!
20:11:31 <SamB> That's what I said "in Haskell", anyway, since it might work differently there
20:11:44 <Taejo> so case doesn't always reduce its scrutinee to WHNF?
20:11:51 <SamB> indeed
20:11:59 <Taejo> good to know
20:12:11 <rwbarton> Taejo: I believe case does work that way in ghc core
20:12:25 <Taejo> rwbarton: thanks
20:12:35 <SamB> if it did, they'd wouldn't have written it like this in the Report Prelude:
20:12:37 <SamB> seq :: a -> b -> b
20:12:37 <SamB> seq = ...       -- Primitive
20:12:51 <Taejo> fair enough
20:13:02 <SamB> they'd have used a case if case did that in Haskell
20:13:20 <rwbarton> does anyone ever use seq on functions?
20:13:38 <chrisdone> :t seq
20:13:39 <lambdabot> forall a t. a -> t -> t
20:13:54 <Taejo> rwbarton: if you're not using seq on functions, then you can define it yourself
20:14:30 <rwbarton> yeah and I think you get better algebraic properties with unlifted function types
20:14:43 <SamB> Taejo: can you now ?
20:14:46 <Taejo> rwbarton: indeed
20:15:07 <SamB> you can only define it on one type per definition ...
20:15:24 <Taejo> SamB: well, yes
20:15:44 <Taejo> you could have a typeclass NotFunction, with a method seq
20:16:01 <Taejo> and it's easily derivable
20:16:15 <Taejo> that's close enough for me
20:18:44 <dolio> That's the reason polymorphic seq exists, though.
20:19:11 <dolio> Not because people use it on functions, but because people didn't want to have to write "NotFunction a =>" in front of all their types when adding strictness.
20:19:51 <rwbarton> It's too bad seq can't just ignore its first argument when it is of a function type.
20:20:04 <Taejo> dolio: surely semantic differences are more important than syntactic ones?
20:20:23 <Taejo> rwbarton: it could, if people had chosen to define it that way?
20:20:30 <chipdude> Objection: Counsel is leading the witness
20:21:09 <dolio> Taejo: Apparently eta reduction isn't as important as some keystrokes. :)
20:21:40 <rwbarton> Taejo: Well, then what is undefined `seq` (), without any type annotations
20:25:39 <sw17ch> @seen dons
20:25:39 <lambdabot> dons is in #arch-haskell, #haskell, #ghc, #xmonad, #concatenative, #darcs and #haskell-in-depth. I don't know when dons last spoke.
20:25:51 <gwern> chipdude: objection overruled. Let's see where counsel is going with this.
20:25:51 <pumpkin_> :(
20:27:27 <Gracenotes> and now for for something completely different: my pillows have gotten most unfluffy lately.
20:27:41 <dancor> you know what you need to do
20:27:48 <dolio> Hire a fluffer.
20:27:57 <dancor> @brain
20:27:57 <lambdabot> I think so, Brain, but culottes have a tendency to ride up so.
20:28:10 <gwern> dolio: are you jesting or are you familiar with the actual job of that name?
20:28:32 <Gracenotes> there are nice pictures on Wikipedia about fluffing.
20:28:34 <dolio> You'll just have to figure that one out yourself.
20:28:49 <pumpkin_> lol
20:29:01 <gwern>  @yow
20:29:03 <sw17ch> import Data.Fluffy
20:29:06 <gwern> yow! In the grim future of Hello Kitty 40K - THERE IS ONLY WAR
20:29:35 <Gracenotes> wait, what?! Someone removed the picture?!
20:30:16 <Gracenotes> aww... someone deleted [[Image:The making of an adult film 9 by David Shankbone.JPG]], depicting the act of fluffing. :(
20:30:35 <gwern> copyright?
20:30:37 <Gracenotes> now I shall never know how to fluff my pillows.
20:31:03 <dolio> Shankbone's a pretty good studio name.
20:31:06 <Gracenotes> User request: Courtesy delete per request of uploader
20:31:18 <Gracenotes> by, uh, Jimbo
20:32:05 <gwern> Gracenotes: jimbo? yeah, I can see why he'd sanitize that particular contribution...
20:32:48 <Gracenotes> perhaps one of the actors in the film was miraculously de-gayed and requested the removal of the pictures from Wikipedia due to personality rights?
20:33:56 <gwern> hm. I could've sworn I once saw a site which had a lot of SICP worked through in haskell
20:34:33 <wli> gwern: ISR such a site existing, but never looking at it in any detail.
20:35:24 <ddarius> http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages
20:35:37 <wli> Gracenotes: You must not be talking about me; there's more of a chance of that happening with Jeff Palmer.
20:36:19 <gwern> ddarius: ah, that must be it, thanks
20:36:21 * Gracenotes wishes he didn't know who he was
20:36:34 <Gracenotes> Jeff, that is. :\
20:36:39 <jeffwheeler> What?
20:36:50 * gwern doesn't know jeff, I suppose I should be thankfull?
20:36:52 <Gracenotes> not you :)
20:37:03 <jeffwheeler> :P
20:37:47 <jeffwheeler> So I posted my confusion earlier, and I'm still stuck. Unfortunately I'm not smart enough to simplify the code, so I've uploaded the darcs repo to code.haskell.org, which currently fails to compile
20:37:49 <jeffwheeler> http://code.haskell.org/~jeffwheeler/aggregate/
20:37:53 <Gracenotes> anyways. *codes haskell, lying upon his flat pillows*
20:38:11 <jeffwheeler> Most all of the core is ripped from Yi, much of the monad stuff I don't understand.
20:38:24 <gwern> jeffwheeler: what on earth are you doing?
20:38:36 <jeffwheeler> gwern: RSS aggregator!
20:38:40 <gwern> feed aggregator?
20:38:52 <jeffwheeler> gwern: exactly.
20:38:52 <gwern> did you just copy the display code -_-
20:39:05 <gwern> jeffwheeler: you know, you probably want to start with riot, not yi
20:39:06 <jeffwheeler> gwern: I copied most all of it. I'm just learning how Yi works in this process. :)
20:39:37 * gwern writhes at agony at that confession of copy-pasta
20:39:57 <jeffwheeler> gwern: no copy/paste, technically speaking. The Yi code is on my other computer. ;)
20:40:06 <jeffwheeler> gwern: I just stared at it while trying to figure out what to do next. :P
20:40:41 <gwern> it's a little ironic that yi was based on riot, which was written by tuomov
20:40:49 <jeffwheeler> Huh?
20:40:50 <gwern> crazy tuomov of ion fame
20:41:14 <gwern> jeffwheeler: anyway my point is that yi is complex and accreted, and you may want to start with the simple ancestor of yi, riot
20:41:19 <gwern> @where riot
20:41:20 <lambdabot> http://iki.fi/tuomov/riot/
20:41:20 * dancor wonders if the irony is that he doesn't know what the irony is
20:41:36 <jeffwheeler> gwern: that seems like a reasonable suggestion.
20:41:43 <Elly> what's yi?
20:41:48 <gwern> 'Riot has an interface resembling those of slrn and mutt and all text editing is done with an external editor: Riot is simply a nice-to-use browser for collections of text. '
20:41:52 <gwern> @where yi
20:41:53 <lambdabot> http://www.haskell.org/haskellwiki/Yi
20:42:00 <Gracenotes> dancor: beware, you may get caught in a volatile cycle of not-irony
20:42:02 <jeffwheeler> gwern: I had a good version working on Vty, but it fell apart when I tried to make the keymap more extensible without using Yi's complexity.
20:42:40 <wli> (n)curses in Haskell is tricky
20:42:49 <gwern> jeffwheeler: alternately... maybe be based on hledger
20:43:19 <gwern> there have been a number of curses-based apps in haskell, but offhand I can't quite remember them
20:43:41 <jeffwheeler> I simply picked Yi because I was most familiar with its core already . . . but your suggestion is certainly valid.
20:43:41 <wli> The RTS makes proper signal propagation/handling/etc. difficult.
20:43:54 * dancor still can't use F4 in Yi
20:44:56 <wli> When I see "F4" I think of Grobner basis algorithms.
20:45:30 * gwern thinks of fighter jets
20:45:42 * jeffwheeler thinks of "Alt+F4" on Windows.
20:45:55 <dancor> what's an F for
20:46:35 <jeffwheeler> gwern: by the way, what do you think of using integrating pointedlist (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointedlist) into Yi.WindowSet?
20:46:48 <jeffwheeler> It's almost exactly the same, but generalized so that I could use it elsewhere.
20:47:16 <gwern> jeffwheeler: or maybe you could look at byorgey's zipeditor
20:47:58 <jeffwheeler> gwern: I found that a zipper is slightly different, though, in that it permits an empty list. WindowSet and a pointed list do not.
20:48:41 <gwern> zipeditor for aggreator
20:49:01 <jeffwheeler> What?
20:49:49 <gwern> was pointedlist based directly on the windowset code?
20:50:12 <jeffwheeler> gwern: and discussion in this room, and the Zipper library currently on Hackage.
20:50:17 <jeffwheeler> Not directly on any of them.
20:50:31 <gwern> jeffwheeler: ah. so the license can indeed be bsd and not yi's GPL then
20:50:54 <gwern> jeffwheeler: it seems like a good idea to me. at yi we're always looking to use external libs. why not file a bug for this?
20:50:58 <jeffwheeler> gwern: ah, I honestly don't really care about the license. I just tried to be as open as I could.
20:51:12 * gwern cares that the license is correct
20:51:37 <jeffwheeler> I'm willing to change it to GPL, if you want.
20:51:43 <gwern> no, bsd is fine
20:51:55 <gwern> if it doesn't directly copy any code
20:52:00 <gwern> *didn't
20:52:37 <jeffwheeler> I don't think so, but I'll change it anyways.
20:52:47 <gwern> no no, leave it
20:52:55 <jeffwheeler> okay
20:53:00 <gwern> take that time and file a bug report/request instead
20:53:30 <jeffwheeler> Alright. For all I care, all the code I publish to Haskell projects can be in the public domain . . . I'm completely indifferent to license debates.
20:56:35 <sjanssen> jeffwheeler: if you want the license with the least drama in the Haskell world, stick with BSD3
20:56:49 <sjanssen> GPL is tricky due to GHC's static linking
20:59:09 <SamB> yeah, BSD3 is pretty damn close to PD
21:01:58 <jeffwheeler> sjanssen: that was the license that brought the drama to me :)
21:02:27 <sjanssen> jeffwheeler: oh, what sort of problem did you have?
21:03:26 <jeffwheeler> sjanssen: gwern was warning that I might need to use GPL because the code was much inspired by the same code in Yi (I was essentially generalizing it to be used anywhere)
21:03:36 <sjanssen> jeffwheeler: oh, right
21:03:49 <sjanssen> yes, you do always need to be careful of derivative works
21:03:49 <wli> They are and aren't. Intensional affairs are possible with function pointers.
21:06:26 <Cale> Is yi really under the GPL?
21:06:34 <Cale> hmm...
21:07:33 <gwern> Cale: oh yeah. riot was GPL, and yi was riot, so...
21:07:50 <Cale> Riot?
21:07:56 <gwern> by this point it'd be terribly difficult to relicense. tuomov might refuse relicensing just for the hell of it
21:08:06 <gwern> @where riot
21:08:07 <lambdabot> http://iki.fi/tuomov/riot/
21:08:11 <Cale> I was just thinking that yi was one of dons' projects.
21:08:33 <sjanssen> Cale: it was, but it was also derived from riot
21:12:17 <sm> heh: "I may rewrite Riot in the good old trusty and stable C (plus Lua) that does not come bundled with a religion and an operating-system-within-operating-system (unlike Haskell)"
21:13:17 <sjanssen> sm: ooh, source?
21:13:27 * sjanssen always gets a kick out of that character
21:13:27 <sm> http://modeemi.fi/~tuomov/riot/
21:14:12 <sjanssen> never change, Tuomo, never change
21:16:22 <JN_> newbie with haskell.  is there any decent haskell editor or syntax mode.  I'm primarily interested in syntax highlighting as an aid to understanding code
21:16:59 <juhp_> JN_: any particular editor?
21:17:08 <jeffwheeler> JN_: Yi!
21:17:11 <chessguy> JN_, there are modes for emacs and vim
21:17:34 <JN_> how about something that's not text-oriented?
21:17:44 <JN_> I mean.. curses
21:18:01 <jeffwheeler> Emacs, Vim, and Yi all have GUIs. :)
21:18:03 <monochrom> iPod Touch has a touch-oriented note jotting applet.
21:18:08 <chessguy> curses would be pretty text-oriented...
21:18:10 <juhp_> gedit?
21:18:21 <jeffwheeler> TextMate?
21:18:28 <Cale> JN_: Nearly every editor has a Haskell syntax highlighter...
21:18:51 <monochrom> You can also try Eclipse plus EMF. Very untext.
21:18:57 <Cale> JN_: Any editor which can replace tabs with spaces for you automatically should do.
21:19:01 <chessguy> monochrom, what's EMF?
21:19:26 <monochrom> "eclipse modelling framework". gui for drawing box diagrams.
21:19:35 <juhp_> hehe
21:19:44 <JN_> not a fan of eclipse or emacs.. :I
21:20:07 <Cale> Personally, I mostly use vim, though emacs is occasionally nice :)
21:20:13 * raxas adds "Haskell, because it comes bundled with a religion and operating-system-within-operating-system" in his list of witty argumentations
21:20:14 <juhp_> JN_: it is probably easier if you state what you like...
21:20:15 <monochrom> It is rather contradictory that you are a fan of untext but not eclipse.
21:20:24 <chessguy> heh
21:20:37 <monochrom> Oh, perhaps you expect Visual Studio.
21:20:48 * chessguy was waiting for that comment
21:20:59 <JN_> I'd like a lightweight text editor which is gui-based and does syntax highlighting.. not simply highlighting key words that it recognizes, but understands the structure of haskell code and highlights accordingly.
21:21:08 <monochrom> gvim
21:21:22 <juhp_> JN_: which OS?
21:21:26 <JN_> Windows
21:21:27 <jeffwheeler> JN_: Yi?
21:21:32 <jeffwheeler> oh, that might limit you
21:21:34 <JN_> I thought Yi was text-bsed
21:21:45 <jeffwheeler> JN_: it has UIs for Pango, too
21:21:56 <Cale> I'm not sure I'd even recommend Yi... it's almost usable.
21:21:59 <arw> "understanding the syntax" is a very difficult requirement.
21:22:10 <chessguy> Cale, i'm curious what sorts of tasks you switch to emacs for
21:22:37 <chessguy> arw, not as difficult as "understanding the semantics" :)
21:22:37 <Cale> Yeah, I don't know that there's any editor which 'understands' Haskell syntax in that it actually parses it. Syntax highlighters are mostly based on regular expression matches.
21:22:41 <JN_> arw:  yeah.. but if it didn't, it wouldn't be very good at syntax highlighting, now would it? :)
21:22:52 <monochrom> do-blocks in yellow, let-expressions in white, class declarations in blue and instance declarations in green?
21:23:34 <arw> JN_: it would. as cale says, its mostly just regex, not the "real" grammar the language uses.
21:24:00 <jeffwheeler> Even Yi disappoints me there . . .
21:24:01 <arw> mostly it doesn't really matter, but some languages do weird things...
21:24:48 <Cale> chessguy: That's hard to qualify, but I generally wouldn't fire up emacs for just something small. If I'm using emacs, I'll be using it for something that I know is going to take some time.
21:24:59 <monochrom> emacs and eclipse are about the only two platforms that could be programmed to do that. but you have ruled them out.
21:25:02 <chessguy> Cale, interesting.
21:25:02 <arw> mostly you get limitations like "can only highlight nested blocks up to 50 levels deep" or so.
21:25:13 <monochrom> "your answer set is empty. please enter a new query"
21:25:16 <Nafai> I use vim for quick-n-dirty edits for sys-admin type things.  I use Emacs for everything else.
21:25:36 <juhp_> JN_: I assume you would be happy with just basic highlighting?
21:25:38 <chessguy> heh. if you're nesting that deeply, you've got way bigger problems than choosing an editor...
21:26:00 <jeffwheeler> monochrom: Emacs, properly parsing semantics?
21:26:04 <arw> chessguy: yep, thats why its usually not a problem.
21:26:18 <JN_> juhp:  I was hoping for intelligent highlighting.. if I can't find that, then I'd probably just use my preferred editor without any form of highlighting
21:26:43 <Cale> JN_: Highlighting which was based on the actual grammar unmodified would be broken anyway.
21:26:57 <Cale> (because when you're editing, you break the parse regularly)
21:27:03 <monochrom> emacs and eclipse come with bloodily Turing-complete languages. You can tell them to play mp3 files for every terminating function seen in your source code.
21:27:12 <gwern> Cale: I'm fairly sure yi is actually parsing the haskell, and not doing regexp hacks like emacs/vim/the others
21:27:24 <gwern> monochrom: 'every'? hm...
21:27:44 <Cale> gwern: I was fairly sure it wasn't... but it's been a long time since I last looked at it.
21:27:47 <jeffwheeler> monochrom: except Emacs still lacks a decent, consistent semantic parser.
21:27:48 <gwern> Cale: yi has recently started changing highlighting based on whether the syntax is broken, actually...
21:27:48 <monochrom> Note that I carefully do not promise the dual, "for every non-terminating functions".
21:27:57 <Cale> mm
21:28:00 <gwern> darn
21:28:03 <chipdude> yi?
21:28:16 <Nafai> Wow
21:28:25 <Nafai> I have 562 unpulled patches for Yi :)
21:28:25 <Cale> You need some kind of parser which is resumable to handle syntax highlighting correctly.
21:28:27 <arw> and eclipse does evil things like compiling as you type and analyzing the code through the compiler.
21:28:27 <chipdude> n/m http://www.haskell.org/haskellwiki/Yi
21:28:29 <jeffwheeler> Cale: To start, it uses alex to parse, and then I'm not sure beyond that
21:28:38 <jeffwheeler> s/parse/lex/
21:28:48 <JN_> oh well.. thanks for the suggestions.  I'm just going to use a simple text editor for now
21:28:55 <chessguy> is there a technical difference between parsing and lexing?
21:28:56 <Cale> Yeah, alex is just a lexer, which I think only uses regular expressions anyway.
21:29:02 <ddarius> chessguy: Yes.
21:29:20 <jeffwheeler> Roughly regular expressions, I think.
21:29:29 <Cale> JN_: If you're on windows, I think lots of windows people use TextPad
21:29:33 <jeffwheeler> They're a simplified version of such
21:29:40 <chessguy> ddarius, what is it?
21:29:46 <monochrom> I thought of using Oleg et al's delimited continuations to obtain resumable parsers with little work (apart from normal parser work). I became lazy and suspended the thought. (Pun!)
21:29:58 <JN_> Cale: yeah I have textpad open. I don't see any syntax highlighting for haskell built in
21:30:01 <jeffwheeler> chessguy: lexers form a stream of tokens, parsers create a tree structure representing the contents
21:30:08 <chessguy> aha
21:30:14 <chessguy> gotcha
21:30:16 <Cale> JN_: Oh, I'm sure someone must have done something.
21:30:55 <Cale> ah, the textpad website has syntax highlighting files for Haskell.
21:31:01 <JN_> Cale: you're right.. I see they have a contrib section and there are 2 different haskell defs
21:31:24 <chessguy> ok, time to go off to try to sleep
21:31:35 <monochrom> Another way may be to give Parsec a very strange Stream instance to obtain a resumable parser. Perhaps the strange Stream instance also uses continuations.
21:32:47 <Cale> Actually, I would just be happy if the editor properly understood the offside rule.
21:33:09 <monochrom> Oh, it is said that "the devil is in the offside rule".
21:33:12 <Cale> Moving one of the layout keywords should cause the block it contains to move along with it.
21:33:43 <Cale> (and recursively so)
21:34:13 <JN_> what are the haskell source code file extensions (suffix)
21:34:20 <Cale> .hs and .lhs
21:34:24 <JN_> thanks
21:34:30 <mmorrow> .hsc
21:34:37 <jeffwheeler> Cale: Yi does that.
21:34:45 <Cale> jeffwheeler: But not very well...
21:34:55 <jeffwheeler> Cale: Ha, a matter of opinion. :D
21:35:00 <Cale> jeffwheeler: At least, when I tried it, it was easy to confuse it.
21:35:06 <jeffwheeler> Cale: . . . but you're right.
21:35:14 <Cale> Like, adding a newline before 'do', for instance.
21:35:17 <mmorrow> JN_: maybe do .y and .x too (unless you've already got those assigned for C)
21:35:39 <mmorrow> err, actually i haven't seen a proper syntax highlighter for the haskell versions of either of those ..
21:35:56 <mmorrow> just the C one which botches is bad
21:35:57 * juhp_ builds the gtk2hs-0.10.0 RC
21:43:32 <Taejo> @where hpaste2
21:43:32 <lambdabot> http://hpaste.org/
21:44:01 <Taejo> yay! hpaste.org is back up
21:47:04 <Taejo> or not: "500 Internal Server Error\n58030 5: Unable to close due to unfinalised statements"
21:49:41 <Taejo> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1230#a1231 -- I'm pretty sure that (NoArgs -> BasicProg ()) *is* an instance of Num
21:51:43 <noZone> Why did hpaste go belly up till now?
21:51:51 <Taejo> can I see if two types are equal in GHCi?
21:53:02 <rwbarton> (x :: t1) :: t2 should tell you
21:53:18 <rwbarton> It looks here like the difference is () vs. t?
21:53:44 <ddarius> rwbarton: That won't quite tell you.  It will tell you if they are unifyable.
21:54:24 <ddarius> Though, I guess if you put the more general one on the outside it will work out.
21:54:40 <rwbarton> if there are no type variables involved, that will be the same, right?
21:54:46 <ddarius> rwbarton: Yes.
21:55:21 <ddarius> (So making what I first said more accurate, that will tell you if t2 is an instance of t1.)
21:55:31 <pumpkin_> how about if you sandwich it?
21:55:33 <rwbarton> > ([] :: [Integer]) :: [a]
21:55:35 <lambdabot>   Couldn't match expected type `a' against inferred type `Integer'
21:55:39 <rwbarton> > ([] :: [a]) :: [Integer]
21:55:41 <lambdabot>   []
21:55:45 <rwbarton> > (([] :: [a]) :: [Integer]) :: [a]
21:55:47 <lambdabot>   Couldn't match expected type `a' against inferred type `Integer'
21:55:53 <rwbarton> would that always work?
21:56:02 <ddarius> rwbarton: Yes.
21:56:33 <rwbarton> Hmm.  Maybe I should learn about this ghc macro facility. :)
21:56:38 <rwbarton> *gchi
21:56:39 <rwbarton> *ghci
21:56:48 <ddarius> macro?
21:56:58 * ddarius wouldn't consider :def a macro.
21:57:27 <Taejo> rwbarton: right, so I have an instance for (OneArg -> [Char] -> BasicProg t), only for t=(), but why do I need a polymorphic version?
21:58:58 <rwbarton> Taejo: Same reason if I write read "5" it doesn't assume I mean read "5" :: Int just because there happens to be a Read Int instance
21:59:09 <Taejo> fair enough
21:59:34 <Taejo> ack. BasicProg only has kind * -> * because I want to use do notation
21:59:39 <rwbarton> I wonder whether augustss is using -XNoImplicitPrelude.  It doesn't look like it, but it would make things a lot easier
22:00:11 <rwbarton> For example, you could fix this problem by changing the type of >>=
22:00:17 <Taejo> indeed
22:01:17 <rwbarton> you can also probably give Rest a second type parameter t and define type Rest Noargs t = BasicProg t and so on
22:01:47 <Taejo> good idea
22:02:00 <ivanm> @ask matthew-_ would you mind if I re-arrange GraphViz to have a separate Types module? This would let me avoid having a whole bunch of extra stuff in the main module file just because it needs to know what a DotGraph is :s
22:02:00 <lambdabot> Consider it noted.
22:03:35 * rwbarton wonders how many man-hours will be spent writing BASIC in Haskell
22:03:41 <Taejo> lol
22:03:53 <Taejo> rwbarton: have you done it yourself?
22:04:55 <rwbarton> No, I've just been making a few suggestions here in #haskell
22:05:31 <Taejo> who else is working on it?
22:06:39 <rwbarton> JoshTriplett brought up the idea about a week ago, since then augustss has made an implementation, and mmorrow has also posted some code to hpaste2
22:07:53 <JN_> BASIC in Haskell for what purpose?
22:08:13 <ddarius> JN_: It's there.
22:08:45 <JN_> where
22:09:22 <Taejo> JN_: ddarius means "because we can"
22:09:24 <pumpkin_> JN_: on augustss' blog for now
22:09:31 <JN_> ok I see
22:09:44 <JN_> two different interpretations
22:10:08 <JN_> was just wondering if there were some practical purpose, or if just for fun
22:11:15 <pumpkin_> don't think basic is ever practical
22:11:16 <Taejo> JN_: one might consider it a user-friendly interface to LLVM
22:11:18 <pumpkin_> htese days
22:11:35 <JN_> pumpkin: hence my wonderment
22:11:52 <Taejo> well, my implementation is "interpreted", but it appears that augustss is compiling it to LLVM
22:19:22 <Elly> hm, emerging yi didn't go well
22:19:32 <Elly> it tried to install vty, then failed because -fffi is deprecated
22:19:42 <Taejo> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1230#a1232 -- why does GHC think dummy and dummy1 are different?
22:19:55 <idnar> why would a deprecation cause a failure?
22:20:17 <Elly> because of -Werror
22:20:24 <Elly> the warning about it being deprecated became an error
22:21:35 <idnar> oh ,ouch
22:25:27 <rwbarton> Taejo: oh, I know why this is happening.  Let me see if I can find the trac ticket about it.  (It's not really a bug.)
22:29:05 <rwbarton> Taejo: I think http://hackage.haskell.org/trac/ghc/ticket/2855 is the closest to this issue
22:30:05 <rwbarton> Taejo: Short version, type families need not be injective so ghc cannot determine from types alone that you want to apply the (StmtMaker a dummy) instance with the same dummy as in Num (a -> Rest a dummy)
22:30:14 <rwbarton> because dummy appears only as a parameter to a type synonym
22:31:25 <Taejo> so if I made toStmt take a parameter of type dummy, that would work?
22:32:05 <rwbarton> I think so.
22:32:56 <Taejo> alas, not -- at least if with "fromInteger n = toStmt (undefined::b) (fromInteger n)"
22:33:10 <Taejo> but I think I can eliminate the type family
22:33:31 <rwbarton> Might need ScopedTypeVariables?
22:33:51 <Taejo> I'll try
22:34:22 <Taejo> yay, that works
22:34:46 <Taejo> never mind
22:34:52 <Taejo> still No instance for (Num (OneArg -> [Char] -> BasicProg t))
22:35:04 <rwbarton> that's back to the original error?
22:35:21 <Taejo> yeah, I had main commented out while I worked out the other issues
22:35:26 <Taejo> now the rest compiles
22:36:04 <Taejo> but I think I'm going to eliminate the associated type, and hopefully life will get easie
22:40:42 <Taejo> rwbarton: it works!
23:03:48 <zloog_> Is there a way i can make it so that hGetLine will read things in CR/LF format?
23:04:57 <Taejo> zloog: run your program on Windows :)
23:05:15 <Taejo> zloog_: in other words, no
23:05:29 <zloog_> Taejo: :(
23:05:44 <zloog_> Taejo: thanks
23:05:46 <Taejo> zloog_: but you can easily write a wrapper
23:06:12 <zloog_> Taejo: Yea, but the only way i can think to do it would be to reverse the list 2x
23:06:22 <zloog_> Taejo: But i havent been thinking too hard about it
23:06:44 <Taejo> why would you reverse the list?
23:08:13 <travisbrady> is there some way to call an IO action in a case ala 'case doesFileExist "/home/me/whatever"' of?
23:08:20 <ski_> just define an alternate `hGetLine' using `hGetChar' ?
23:08:44 <thoughtpolice> @seen augustss
23:08:44 <lambdabot> augustss is in #haskell and #haskell-in-depth. I last heard augustss speak 8h 16s ago.
23:08:46 <ski_> travisbrady : sadly, no
23:08:48 <Taejo> ski_: wouldn't that be slower
23:09:02 <ski_> slower than what ?
23:09:10 <travisbrady> ski_: thank you
23:09:13 <Taejo> than a straight getLine
23:09:29 <Taejo> travisbrady: not so fast, ski_ is mistaken
23:09:55 <zloog_> Taejo: Yea, now that I think of it there is no reason to reverse.
23:10:07 <thoughtpolice> @tell augustss ok, i got the llvm bindings working again by commenting out a cpp-options line (related to GetPointerToGlobal) and then the examples/ dir builds but, here on OS X, a lot of them fail with a bus error :(
23:10:07 <lambdabot> Consider it noted.
23:10:08 <ski_> Taejo : i believe Taejo is not interested in the internals of e.g. GHC `IO', here ..
23:10:22 <Taejo> case (doesFileExist "/home/me/whatever) of {True -> putStrLn "It exists.; False -> return ()}
23:11:16 <ski_> @type case System.Directory.doesFileExist "/home/me/whatever" of True -> putStrLn "It exists.; False -> return ()
23:11:17 <Taejo> ski_: I *am* Taejo
23:11:18 <lambdabot> lexical error in string/character literal at end of input
23:11:51 <ski_> Taejo : sorry, i meant "travisbrady" for the latter "Taejo"
23:11:53 <travisbrady> Taejo: hmm, i get "Couldn't match expected type `IO Bool' against inferred type `Bool'"
23:11:55 <ski_> @type case System.Directory.doesFileExist "/home/me/whatever" of True -> putStrLn "It exists."; False -> return ()
23:11:56 <lambdabot>     Couldn't match expected type `IO Bool' against inferred type `Bool'
23:11:56 <lambdabot>     In the pattern: True
23:11:56 <lambdabot>     In a case alternative: True -> putStrLn "It exists."
23:11:59 <Taejo> uyes
23:12:06 <ski_> Taejo : there you have your type error
23:12:07 <Taejo> travisbrady: oh, right, I see what you mean
23:12:29 <Taejo> I was thought you were talking about IO actions in the branches, not the scrutinee
23:12:30 <Taejo> sorry
23:12:58 <travisbrady> i was just reading this http://neilmitchell.blogspot.com/2009/01/small-scripts-with-haskell.html and noticed "forM_ files $ \file -> when (takeExtension file == ".txt") $ do", what does the '->' do in this?
23:13:13 <travisbrady> ahh, 'scrutinee', i was curious about what you'd call that
23:13:42 <ski_> `\file -> ..file..' creates a function that takes `file' as argument and returns `..file..'
23:14:19 <ski_> `forM_' is passed `files' and this function, and executes the function on every file in `files'
23:14:54 <travisbrady> ski_: how do you read the '->' ?
23:14:56 <ski_> so, each file in `files' is bound to `file', in turn, and the `..file..' code is executed for it
23:15:14 * Taejo </3 the Num class -- specifically, the fact that Show is a superclass
23:15:17 <ski_> "mapsto" or "gives", e.g.
23:15:21 <travisbrady> oh wait it's just a lambda
23:15:29 <ski_> yes
23:15:47 <travisbrady> i'm not used to seeing them in the middle of a monad
23:16:05 <ski_> the point here is to be unintrusive
23:16:12 <travisbrady> i'm more accustomed to filter (\x -> x=="blah") someList
23:16:51 <ski_> the important point to think of here is doing `..file..' for each `file' in `files' .. this happens to be achieved by passing a lambda-expression to `mapM_', but that's a detail
23:17:27 <travisbrady> yeah, this code actually looks very imperative to me now
23:17:37 <ski_> (and so it is :)
23:20:18 <Taejo> travisbrady: Haskell is the best imperative language :)
23:20:54 <travisbrady> Taejo: yes, i saw it playing BASIC earlier today
23:21:19 <Taejo> travisbrady: that literally made me laugh out loud
23:23:14 <travisbrady> Taejo: haha, that was one of those things that was stupidly awesome
23:23:36 <Taejo> travisbrady: which is why I'm trying to write my own version of the BASIC module
23:24:20 <Taejo> I've just hit against the precedence-of-= problem
23:24:35 <Taejo> and now I see why augustss chose =: instead of :=
23:24:36 <travisbrady> how was he able to get the compiler to accept lines beginning with integers?
23:25:07 <Taejo> travisbrady: what is the type of the literal `10'?
23:25:36 <Taejo> @type 10
23:25:37 <lambdabot> forall t. (Num t) => t
23:26:06 <Taejo> so basically, you add a whole bunch of very strange Num instances (I have instance ToExpr t => Num (OneArg -> t -> BasicProg a))
23:26:36 <idnar> s/strange/insane/ *efg*
23:26:43 <shapr> bos owns hpaste.org
23:26:51 <Taejo> with correspondingly strange/insane definitions of fromInteger
23:27:18 <pumpkin_> yay, hpaste is up
23:27:58 <travisbrady> wow, mindbending
23:28:09 <travisbrady> i've been playing with Haskell for a year and i still feel so far behind
23:28:27 <travisbrady> when i started with Python i felt i grasped it within a few weeks
23:28:51 <Taejo> travisbrady: I've got to the stage where when I saw augustss' post I thought it was "obvious" how it was done, but it turns out to be fairly tricky
23:29:04 <Taejo> travisbrady: what was your background coming to Python?
23:29:35 <idnar> heh, I basically knew everything there was to know about 6 months after I started playing with Python
23:29:48 <idnar> one of the things I love about Haskell is that there's so much more depth
23:29:58 <travisbrady> Taejo: nothing really, i studied economics and needed a tool for doing simulations and processing big piles of data, i'd used perl a bit previously
23:30:15 <Taejo> ok
23:30:20 <idnar> I'm still not really yet at the point where I can write "real" Haskell code, though
23:30:39 <travisbrady> being honest I don't use metaclasses in Python and don't really know what they're used for
23:30:45 <idnar> if I'd started off with any functional programming familiarity, I probably would be there by now
23:31:17 <idnar> I knew about (Python) metaclasses pretty early on, didn't actually use them until much later on
23:31:27 <travisbrady> i've only written one "real" thing in haskell http://github.com/travisbrady/shabonkie/tree/master
23:31:32 <travisbrady> and that was after a year
23:31:37 <Taejo> I've never used a metaclass in 3.5 years of Python
23:31:54 <travisbrady> i think my Haskell code is probably too imperative and ugly to real Haskellers
23:32:03 <Taejo> well, I've used a class that had a metaclass (e.g. in SQLAlchemy), but never written a class with one
23:32:08 <idnar> Python has pretty much been my language of choice for the last while
23:32:11 <shapr> Taejo: I used metaclasses in Python!
23:32:23 <idnar> in the future, I'd like Haskell to be that language of choice
23:32:35 <shapr> But after that, I'd sucked all the interestingness out of Python, had to go learn Haskell.
23:32:43 <idnar> but it remains to be seen how that'll work out
23:33:41 <idnar> Python doesn't really have much interestingness as a language, it's all in the libraries and frameworks and whatnot
23:33:41 <shapr> I also hacked up x++ in Python to work like it does in C, when that was first possible :-)
23:33:55 <shapr> er, ++x ?
23:33:56 <Taejo> shapr: that's possible?
23:33:59 <idnar> shapr: ++x, you mean?
23:33:59 <idnar> ah
23:34:01 <shapr> right
23:34:03 <shapr> sorry
23:34:08 <idnar> Taejo: unary plus is an overloadable operator
23:34:18 <Taejo> oh, right
23:34:28 <idnar> so ++x is +(+x), and you make +x do dastardly things
23:34:32 <shapr> exactly!
23:34:53 <shapr> But I was really desperately trying to find entertainment at that point.
23:35:00 <idnar> someone also implemented goto / comefrom as an April Fool's Joke
23:35:07 <shapr> Oh that's cool
23:35:12 <idnar> (the implementation was real, but I think it used debug tracehooks)
23:35:13 <Taejo> don't you end up having +x;+x being the same as ++x ?
23:35:27 <shapr> Taejo: Nah, count the increments, divide by two.
23:35:29 <idnar> Taejo: it depends on how dastardly you get
23:36:03 <idnar> Taejo: you could check source lines or something if you really wanted to be evil
23:36:12 <shapr> I never saw anything that evil.
23:36:30 <shapr> I remember there being some way you could tell if unary plus was being called directly after unary plus.
23:36:33 <shapr> But I forget what.
23:36:44 <cads> do you guys think that in haskell, a well integrated lazy game-tree encoding all the games of chess in a type that's traversable through a simple exposed interface... would it be a chess monad?
23:37:01 <idnar> shapr: I guess you could set a flag and clear it in __getattribute__ or something
23:37:12 <Taejo> cads: monads have kind * -> *
23:37:15 <idnar> hrm, that still won't detect +(+x)
23:37:16 <travisbrady> what is the idiomatic way to handle potential list indexing errors (index too large) in Haskell?
23:37:22 <idnar> oh! have +x return a special wrapper value
23:37:36 <shapr> In any case, making ++x work in Python isn't remotely as cool as embedding BASIC in Haskell.
23:37:39 <idnar> and then unary plus on that would do the actual increment, or something insane
23:38:02 <shapr> Now, if stackless had had serializable first class continuations, I would have hung around longer... but that never materialized.
23:38:21 <idnar> it has serializable coroutines :P
23:38:31 <shapr> That's the tasklet stuff, yeah?
23:38:34 <idnar> yeah
23:38:40 <idnar> as long as there's no C on your stack
23:38:54 <idnar> (well, I assume so anyway)
23:39:20 <cads> Taejo: I think I could construct a function morphism between the classic coupled functions approach into a sleeker single object, probably in a monad
23:39:43 <shapr> I made a living off of Python for a few years, but I've preferred Haskell for the past seven or so years.
23:40:12 <Taejo> cads: well you're not going to get a monad until you have something that has the same kind as a monad
23:40:21 <idnar> my preference for Haskell is newer
23:40:37 <idnar> I think it only really came into focus when I started thinking about all the different "alternative" languages I was considering
23:40:43 <idnar> Erlang, Haskell, E, etc.
23:40:53 <shapr> Taejo: Could you treat the game tree as a non-determinism monad?
23:40:58 <idnar> I basically came to the conclusion that all of the strengths of the others were realisable in Haskell
23:41:17 <idnar> so Haskell was the logical language to start focusing on
23:41:22 <shapr> Hm, E and Erlang have some cool features that would be very hard to do in Haskell.
23:41:23 <idnar> (ugh, no pun intended)
23:42:21 <idnar> shapr: what do you have in mind?
23:42:25 <Taejo> shapr: yes, but I'm shooting for some precision here. People call me a pedant
23:42:30 <Gracenotes> is a non-determinism monad anything like the list monad?
23:42:37 <shapr> Gracenotes: Yeah, same thing.
23:42:54 <shapr> Just that non-determinism (to me at least) implies the whole backtracking along a tree of possibilities.
23:43:11 <idnar> in Erlang's case, it's not so much the /features/ as the fact that the runtime is seriously awesome (and OTP / whatever give you a really nice base platform)
23:43:12 <Gracenotes> okay :) Yeah, I plan on implementing (as many have probably done before) an NFA evaluator using the [] monad
23:44:03 <Gracenotes> one possible problem, though, is the duplicates :\ Is there a Set monad of sorts out there?
23:44:04 <shapr> So I think cads got it right, a lazy chess game-tree would be a monad.
23:44:18 <idnar> then my interest in E tends towards the security stuff; and, sure, you can't really do "object capability" in Haskell, but I think you can do things that are essentially equivalent
23:44:28 <shapr> idnar: That's true.
23:44:47 <shapr> idnar: Erlang has hot code loading with multiple running versions, that's way hard to do in Haskell.
23:45:08 <shapr> Admittedly, the dynamic code reloading that started with lambdabot proves it's not impossible...
23:45:11 <idnar> shapr: yeah, that's a runtime thing, though
23:45:15 <shapr> true
23:45:15 <erikc_> yea, erlang is an engineering/implementation success more than a language design success
23:45:19 <travisbrady> shapr: are people working on that, hot code loading that is?
23:45:33 <idnar> shapr: you can hack something up in almost any language, it's just a matter of how slow and painful to use it is :P
23:45:42 <cads> idnar: erlang /is/ very attractive for a lot of things
23:45:54 <shapr> travisbrady: Not that I've heard.
23:46:09 <shapr> travisbrady: Not unless you count dons' work with dynamic runtime reloading.
23:46:33 <shapr> travisbrady: The difference is that Erlang's runtime upgrading doesn't require unloading all instance of the older version of the code.
23:46:34 <travisbrady> shapr: ahh, that's what I was thinking of, noticed that the other day
23:46:38 <idnar> it doesn't seem like there's a fundamental barrier to implementing, say, hot code loading etc. in Haskell, though
23:46:45 <cads> I've been thinking a distributed chess engine could be built at least using erlang for communication between distant processes
23:46:57 <shapr> cads: You could do the same with Haskell though, yeah?
23:46:58 <travisbrady> we use a ton of erlang where i work, people like it and it makes making things distributed very easy
23:47:03 <shapr> idnar: True
23:47:03 <Gracenotes> apparently a set monad is somewhat difficult to produce: http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
23:47:16 <cads> shapr: I think the core would be easier to build in haskell as a strong type
23:47:31 <shapr> cads: I agree.
23:47:57 <shapr> But then, dissenters against that opinion surely would not frequent #haskell
23:48:35 <cads> erlang folk I've met have been using it to build interesting distributed game systems, which is pretty interesting
23:49:42 <cads> for all the issues of nondeterminism and trust a distributed poker engine would have to handle, for example
23:49:57 <idnar> shapr: anyhow, that's not to say that I wouldn't consider using E or Erlang for any particular project
23:50:25 <idnar> shapr: it's just that long-term, I could see Haskell performing at least reasonably well in those areas, so it's most likely to become my favourite hammer :P
23:50:37 <shapr> That's what happened to me.
23:50:58 <shapr> I sort of meant to go on and learn more about Erlang and lots of others after learning Haskell.
23:51:10 <shapr> My excuse is that I'm not done learning Haskell yet.
23:51:17 <ski_> hahaha :)
23:51:27 <ski_> god morgon shapr
23:51:42 <shapr> god morgon ski_! hur mår du?
23:51:59 <ski_> rtt bra, f.n.
23:52:11 <idnar> shapr: heh
23:52:23 <shapr> I've never reached the point where I had to search for something new and nifty and mind bending in Haskell...
23:52:29 <idnar> shapr: well, so far, Project Euler problems are about as far as I've gotten when actually writing Haskell code
23:52:31 <shapr> it's hard enough to keep up :-)
23:52:46 <idnar> I haven't read much /real/ code, either
23:52:49 <shapr> I actually had a Haskell job for awhile.
23:52:59 <shapr> I'm thinking of going after another such.
23:53:03 <idnar> still working my way through RWH, though, and I plan to do some Darcs hacking at some point
23:53:36 <jsn> shapr: i recently lost my haskell job
23:53:43 <shapr> jsn: What happened?
23:54:07 <jsn> the founder provided all the funding for a year
23:54:24 <jsn> no one else was interested and in december we couldn't get external funding
23:54:28 <shapr> :-(
23:54:39 <jsn> basically, we tried to figure out how to make a pitch way, way too late
23:54:51 <shapr> sorry to hear that
23:55:16 <jsn> so now i am re-learning ruby on rails :(
23:55:29 <Taejo> > read "1.2" :: Int
23:55:31 <lambdabot>   * Exception: Prelude.read: no parse
23:55:33 <shapr> Hopefully you'll get a second Haskell job soon :-)
23:55:52 <ski_> > (reads :: ReadS Int) "1.2"
23:55:54 <lambdabot>   []
23:56:50 <Taejo> > (reads :: ReadS Int) "12"
23:56:52 <lambdabot>   [(12,"")]
23:56:55 <Taejo> > (reads :: ReadS Int) "1 2"
23:56:57 <lambdabot>   [(1," 2")]
23:57:04 <Taejo> > (reads :: ReadS Int) "1.2"
23:57:06 <lambdabot>   []
23:57:16 <ski_> > (reads :: ReadS Int) "1 .2"
23:57:17 <lambdabot>   [(1," .2")]
23:57:50 <ski_> apparently the reader for `Int' insists on no trailing `.' character
23:57:56 <jsn> shapr: somehow, i don't think of the bay area as the right place for haskell jobs :)
23:58:03 <Taejo> > (reads :: ReadS Int) "1a2"
23:58:05 <lambdabot>   [(1,"a2")]
23:58:31 <shapr> jsn: Come to Boston!
23:58:32 <ski_> @src Int readsPrec
23:58:32 <lambdabot> Source not found. It can only be attributed to human error.
23:58:37 <shapr> OR move to Portland
23:59:20 * ski_ doesn't really like parsers refusing to succeed when there's something present which they won't eat anyway ..
23:59:21 <jsn> shapr: do you know folks who i could send my resume to in boston?
23:59:41 <shapr> Yeah, BlueSpec, Nokia Research, and that company that begins with a P... I forget their name.
23:59:49 <jsn> hmm
