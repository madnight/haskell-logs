00:03:51 <mathijs> dmwit: I can't find the chunk function you mentioned. it's just for bytestrings?
00:03:55 <tehgeekmeister> so now i ended with a weird problem
00:04:03 <dmwit> mathijs: Everybody writes it at least once. =/
00:04:08 <tehgeekmeister> the program grows to about 50mb and exits
00:04:14 <tehgeekmeister> with no output at all
00:04:23 <dmwit> mathijs: Here: http://www.dmwit.com/programming/Dmwit.hs
00:04:25 <mathijs> dmwit: hahaha ok, I'll have a try :P
00:12:39 <tehgeekmeister> yay constant memory usage again!
00:12:40 <tehgeekmeister> =]
00:14:47 <cognominal> why existential type are introduced by "forall"?
00:15:04 <tehgeekmeister> spoke way too soon, apparently
00:15:09 <pumpkin> tehgeekmeister: lol
00:15:10 <tehgeekmeister> it grows even faster now!
00:15:11 <pao> hi all
00:15:19 <pumpkin> cognominal: it's a little confusing
00:15:32 <pumpkin> http://www.haskell.org/haskellwiki/Existential_type
00:15:38 <tehgeekmeister> it seems to be constant memory for a bit, and then it explodes
00:15:41 <Cale> cognominal: The forall is placed outside the data constructor in that syntax.
00:15:48 <tehgeekmeister> i noticed my cpu fans kicking up to high and i knew something was wrong
00:15:55 <Cale> cognominal: If it were inside instead, then it would need to be exists.
00:16:55 <cognominal> Cale, thx, I will meditate that :)
00:17:01 <Cale> cognominal: that is,  data Foo = forall a. Foo a  is the same as  data Foo = Foo (exists a. a), but the latter syntax isn't supported.
00:17:19 <tehgeekmeister> pumpkin: limit it to a smaller chunk of the input and profile that?
00:17:33 <pumpkin> tehgeekmeister: that could be good, yeah
00:17:34 <Cale> It's sort of like you're introducing a data constructor for each type a.
00:17:52 <pumpkin> tehgeekmeister: you could also use Debug.Trace to figure out what's happening when, but profiling with well placed cost centers might tell you more
00:18:13 <tehgeekmeister> pumpkin: what are these cost centers?
00:18:29 <Cale> But they all have the same name, so once you've applied it to a value, you only know that some type a exists which is the type of value it's been applied at.
00:18:29 <pumpkin> {-# SCC "name" #-} in your code
00:18:32 <tehgeekmeister> pumpkin: i've only used the profiler once, and i think i used some option to set cost centers everywhere
00:18:43 <Cale> cognominal: I find the GADT syntax much less confusing also.
00:18:48 <olsner> Cale: is there a corresponding rule in normal logic with quantifiers?
00:18:50 <pumpkin> tehgeekmeister: it allows you to ask the profiler to keep a look out for that chunk of code
00:19:11 <pumpkin> so if you add a cost center it can keep track of how many times that piece of code was called, what memory it allocated, etc.
00:19:40 <olsner> I always find it confusing that forall means both universal and existential quantification in haskell
00:20:34 <Cale> It doesn't.
00:20:41 <Cale> It always means universal.
00:21:27 <pumpkin> I got excited when I went to the MR wiki page and thought there was an example of the supposed biting
00:21:39 <tehgeekmeister> -prof for profiling?
00:21:58 <Cale> Suppose we have  data Foo = forall a. F a
00:22:02 <pumpkin> it looks like an example of someone being bitten by the limitation rather than by the double evaluation
00:22:06 <Cale> Then  F :: forall a. a -> Foo
00:22:23 <Cale> But if you have a value  F x :: Foo, then x :: exists a. a
00:22:39 <Cale> Which is the reason for the name 'existential'
00:22:55 <pumpkin> Cale: the two examples on http://www.haskell.org/haskellwiki/Monomorphism_restriction aren't what SPJ was asking for, right?
00:23:04 <cognominal> ok
00:23:46 <Cale> pumpkin: Asking for?
00:23:58 <pumpkin> I think it'd be useful to collect a set of examples of the Monormorphism Restriction biting people in an unexpected way. This may help to inform the debate over the MR by giving real-life examples. Add more examples here if (an only if) they constitute an unexpected MR-related incident in your life or someone else's. No invented examples! -- Simon Peyton Jones
00:24:07 <pumpkin> the two examples following there
00:24:14 <olsner> hmm, so... something like, you can put all types in the Foo, but given a value Foo it only contains one value of one type?
00:24:21 <pumpkin> are the MR's effect, not what MR is trying to protect against
00:24:25 <pumpkin> it seems?
00:25:01 <Cale> Oh, he's asking for examples where the MR being applied was a nuisance.
00:25:34 <Cale> Probably also examples where it not being applied was a problem would be interesting as well.
00:25:38 <pumpkin> oh, I thought he was asking for examples of the "your function may be applied twice for different types, and cause you a headache" that MR was trying to protect against
00:25:54 <pumpkin> it seems a lot more interesting to ask for the latter
00:26:01 <Cale> That would be the lack of the MR biting people :)
00:26:03 <pumpkin> the former are quite common (as far as I can see)
00:26:08 <pumpkin> yeah, exactly :P
00:26:46 <pumpkin> I've yet to see an example of bad things happening with the MR off
00:28:00 <Cale> There are some rare annoying things involving numeric defaulting with it off.
00:28:15 <olsner> what happens when you pattern-match that (F x) value, e.g. what's the type of unF (F x) = x?
00:28:36 <Cale> olsner: it would have to be  unF :: exists a. Foo -> a
00:28:51 <pumpkin> which means you can't do much with it
00:28:56 <_dolio> You're not allowed to write that function.
00:29:02 <Cale> olsner: But that's not appropriate because we don't have first-class existentials, so you can't write it.
00:29:18 <Cale> My Foo type is pretty much useless, by the way :)
00:29:32 <Cale> It's more or less observationally the same as ()
00:29:42 <_dolio> Also, the type is unF :: Foo -> (exists a. a) which someone pointed out to me on the mailing list is not convertable to (exists a. F -> a).
00:30:56 <tehgeekmeister> how do i make ./foo +RTS -p play nicely with programs that require an argument?
00:31:01 <olsner> so, how can you actually use existential types? could I use something like data Foo = forall a . F a a (a -> Int)?
00:31:04 <_dolio> Depending on how you're allowed to open existentials, at the very least.
00:31:36 <pumpkin> what's an elegant way to split a list up like split [1..10] [1,4,6,8] = [[1,2,3],[4,5],[6,7],[8,9,10]] ?
00:31:37 <temoto> Where to read about few everyday practical stuff like reading files, splitting strings, etc?
00:31:47 <Cale> olsner: yes
00:31:47 <pumpkin> temoto: try RWH
00:31:49 <pumpkin> @where RWH
00:31:49 <lambdabot> is http://www.realworldhaskell.org/blog/
00:32:12 <olsner> and is that the only way to actually do something with the values, to send everything you need inside the environment of the forall?
00:32:13 <Cale> olsner: Or  data Showable = forall a. Show a => S a
00:32:20 <Cale> olsner: yeah
00:33:03 <olsner> so it's (as a metaphor) something like sending around void*'s and callbacks?
00:33:13 <temoto> pumpkin: i'm sure i've seen split function in book i've read.
00:33:18 <Cale> olsner: Essentially, types can be thought of as permissions regarding what can be done with the data. Existential types allow you to forget what type of data went into your constructor, and so you discard those permissions.
00:33:25 <pumpkin> dolio: you much done testing on UArrs with 64-bit values in it? (Int64, Word64, Double)
00:33:32 <pumpkin> *them
00:33:59 <dolio> pumpkin: I'm on a 64-bit platform, so all my sorting tests have been with 64-bit ints.
00:34:17 <olsner> I'm almost starting to believe I understand this
00:34:37 <pumpkin> dolio: but you've never explicitly tried the Int64/Word64 instances?
00:34:42 <pumpkin> I might just be doing something wrong
00:34:53 <Thunder> pumpkin: split xs (y:ys) = let (a,b) = partition (<y) xs in a : split ys b ...
00:34:54 <dolio> Can't really recall.
00:35:15 <pumpkin> Thunder: that makes sense :) thanks
00:35:40 <Thunder> There is a missing flip to avoid illegal copies ;-)
00:36:05 <pumpkin> lol
00:36:10 <tehgeekmeister> in the profiler output individual alloc percent includes when you alloc and dealloc nearly instantly, right?
00:36:18 <pumpkin> I see it, thanks :P
00:36:42 <olsner> tehgeekmeister: you don't dealloc, things just disappear from the heap :)
00:36:54 <cizra> Heeeey.. Flip could be used for partial application into non-first argument!
00:37:18 <olsner> but yeah, alloc counts allocs disregarding when the data gets collected
00:37:22 <tehgeekmeister> olsner: well right but the function in question constructs and deconstructs some data sequentially.  that's what i meant.  =P
00:37:40 <Thunder> @t (flip.).flip
00:37:41 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:37:43 <Cale> olsner: Whatever's left is a uniform interface for accessing the data. I tend to think of existential types as being at the heart of what OO programming is about -- because in OO programming (statically typed or not), you're often working with data which might be of any number of types, but you know there *exists* a type which has certain fields or messages that it responds to and describes that data.
00:37:50 <pumpkin> Thunder: illegal copies btw?
00:37:54 <pumpkin> how do you mean?
00:38:12 <olsner> Cale: *nod*
00:38:20 <tehgeekmeister> so if one function has 47% of the allocs by itself, is that where i need to look?  or is that not a problem if that's where i EXPECT a lot of allocation?
00:38:42 <Cale> (This is most commonly achieved by subtyping, where you end up knowing that whatever you have is an object of a subclass of some given class, and thus supports a given set of methods.)
00:38:50 <pumpkin> Thunder: actually, I can just use break instead of partition
00:39:08 <Thunder> pumpkin: Just kidding. I have to deal with some political statements at the moment ... i.e. https://st.icann.org/data/workspaces/summit-wg/attachments/wg5_background_material:20090217100746-0-5184/original/icann-wg5-censorship.pdf
00:39:10 <Cale> By contrast, FP seems to focus much more on universal quantification.
00:39:24 <pumpkin> aha :)
00:39:26 <Thunder> pumpkin: if your first list is sorted, yes
00:39:30 <pumpkin> yeah, it is :)
00:41:12 <olsner> tehgeekmeister: depends :) if this function is strict (or should be) and does mostly arithmetic, then maybe some tweaking will allow you to do more work on unboxed data without allocating thunks and boxes
00:41:57 <tehgeekmeister> olsner: it inserts an item into a map in state and adds it into a list, also
00:42:05 <tehgeekmeister> so really what it is doing is allocation, by design
00:42:12 <tehgeekmeister> but i'm trying to locate a space leak.
00:42:18 <tehgeekmeister> somewhere i'm taking up way too much data.
00:42:31 <tehgeekmeister> 1.5 gb of data from a 1mb text file is not reasonable.
00:43:16 <tehgeekmeister> oh wow
00:43:21 <tehgeekmeister> 4.6 gigabytes of allocation
00:43:22 <olsner> oh, you probably want to try one of the heap profiling modes then, to see what's being retained (and/or make the right things more strict - which is the classic problem with code like "for each line, insert in map")
00:43:24 <tehgeekmeister> that's a bottleneck
00:43:46 <tehgeekmeister> apparently i'm spending a LOT of time allocating things.
00:44:10 <Cale> Yeah, use heap profiling and then you can run hp2ps on the resulting .hp file to get a nice graph of where the things on the heap came from.
00:44:16 <olsner> if you're currently using insertWith, try using insertWith'
00:44:24 <tehgeekmeister> i'm using insertWith'
00:44:53 <temoto> show is like convert-anything-to-string?
00:45:06 <Cale> temoto: yeah
00:45:17 <tehgeekmeister> it's amazing it goes thru 4.6 gigabytes of data that quickly.  it only runs for about 30 seconds!
00:45:35 <Cale> temoto: anything for which there's an instance of the typeclass Show anyway
00:46:32 <olsner> the RTS is optimized for allocating lots of throw-away data though, so the total amount allocated may not be the most important value to look at
00:46:35 <temoto> tehgeekmeister: dd if=/dev/zero of=/dev/null bs=700K    gave 11gig/s on my job box
00:47:17 <temoto> tehgeekmeister: i guess it could be named as highest possible computing speed :)
00:47:18 <tehgeekmeister> temoto: huh.  the surprising part to me is that there's that much data at all, all of this is coming from one one megabyte text file.
00:49:06 <olsner> temoto: I got 14.2GB/s :D
00:50:01 <temoto> olsner: Gratz :) you can play with bs parameter to get alternative results.
00:50:21 <pumpkin> set it to 1 and watch it crawl
00:51:08 <tehgeekmeister> hmm, at about 24 seconds in the space consumed from one function grow at about 20mb/s
00:52:21 <tehgeekmeister> how do i make a use of modify stricter?
00:52:32 <tehgeekmeister> oh, it'll be strict in the strict state monad, won't it?
00:52:52 <olsner> are you using the lazy one? :D
00:53:06 <tehgeekmeister> imported the strict one?
00:53:20 <tehgeekmeister> so i don't think so?
00:53:41 <olsner> heh, no, that should indeed give you the strict one
00:54:01 <tehgeekmeister> so either i am in fact taking up that much space
00:54:04 <tehgeekmeister> which i think is not the case
00:54:12 <tehgeekmeister> or my update function is not strict enough
00:54:18 <olsner> what are you doing btw, counting words or something like that?
00:54:32 <tehgeekmeister> OH
00:54:41 <tehgeekmeister> well that's one thing i can fix right away
00:54:54 <tehgeekmeister> longList ++ shortList
00:55:38 <tehgeekmeister> olsner: figuring out optimal order in which to learn words so that you know the highest number of sentences possible at any given step
00:55:51 <olsner> hmm, if you do that for every word, you'll probably end up with one (++) thunk for each line in the file
00:55:55 <tehgeekmeister> the algorithm i've come up with gets really good results, it just doesn't do so very efficiently
00:56:06 <tehgeekmeister> oh, that's not strict?
00:56:09 <opqdonut> no
00:56:16 <tehgeekmeister> man
00:56:18 <tehgeekmeister> okay
00:56:19 <opqdonut> you might want to force the list
00:56:22 <opqdonut> or use data.sequence
00:56:26 <tehgeekmeister> laziness is blessing and a curse
00:57:00 <opqdonut> tehgeekmeister: of course, if you do your ++s right-associatively (a++(b++(c++...))), iterating through the result is steady linear-time
00:57:13 <opqdonut> but there's a bit of heap overhead when doing it
00:57:36 <opqdonut> because it needs to copy every element (exactly) once
00:57:47 <tehgeekmeister> opqdonut: i'm doing list ++ newItems over and over
00:57:48 <opqdonut> err, element as in cons-cell
00:57:54 <opqdonut> tehgeekmeister: that's bad
00:58:05 <tehgeekmeister> opqdonut: yeah, i know, but that's the order i want them in
00:58:13 <tehgeekmeister> and i didn't want to construct and reverse it
00:58:13 <opqdonut> why not reverse in the end?
00:58:30 <opqdonut> anyway, i think you should use either difference lists
00:58:31 <opqdonut> or sequences
00:58:36 <opqdonut> as you're catenating that much
00:58:55 <opqdonut> (difference lists are lists of type [a]->[a], (++) turns into (.))
00:59:12 <opqdonut> (cheap trick for less memory usage when catenating lots)
00:59:35 <AlinRadu> hello
00:59:42 <tehgeekmeister> i think i'll try sequences
00:59:47 <opqdonut> do that, they're spiffy
01:05:23 <tehgeekmeister> oh, but sequences aren't Traversable
01:05:24 <tehgeekmeister> =/
01:05:31 <tehgeekmeister> i kinda need that.
01:05:44 <dolio> They should be.
01:06:02 <tehgeekmeister> oh it is
01:06:04 <tehgeekmeister> i misread
01:06:06 <tehgeekmeister> *phew
01:08:28 <alinp> AlinRadu: this is a channel for Haskell programming languages
01:08:32 <alinp> *language
01:08:43 <alinp> so, it's not about gaming and stuff
01:09:40 <opqdonut> (alinp: did he saysomething?)
01:10:06 <tehgeekmeister> i'm very impressed with how quickly i could switch to a different datatype.  =]
01:10:40 <alinp> he thought that this is a gaming (WOW) channel
01:10:40 <alinp> :)
01:10:49 <alinp> he discussed with me in private
01:10:52 <opqdonut> ah
01:11:21 <dolio> This channel is actually about Eddie Haskell from Leave it to Beaver.
01:11:39 <tehgeekmeister> switching to Data.Sequence solved most of my problems
01:11:42 <tehgeekmeister> it seems
01:11:54 <alinp> lol
01:12:05 <opqdonut> :)
01:12:40 <tehgeekmeister> so i suppose Data.Sequence is the thing to use if you're making a big list and appending to it a lot?
01:12:46 <opqdonut> yeah
01:12:55 <opqdonut> it is design for concat
01:12:58 <opqdonut> *designed
01:15:32 <dolio> So, I was thinking, maybe we should have a nickname for Eddie Haskell, so that when we meet someone else from #haskell in a strange town, we'll be able to identify one another.
01:15:45 <dolio> How about, "The Man Who Rides Alone"?
01:15:48 <pumpkin> lol
01:16:55 <opqdonut> :)
01:20:56 <quicksilver> tehgeekmeister: that's one of the things that always impresses me about haskell code
01:21:07 <opqdonut> which is?
01:21:15 <quicksilver> tehgeekmeister: it's easier than you expect to switch a data type around
01:21:16 <tehgeekmeister> quicksilver: i only had to make three or four changes to switch data types entirely
01:21:19 <opqdonut> ah
01:21:27 <quicksilver> (and the compiler lets you know what you've missed, too)
01:21:44 <quicksilver> compare that to changing the convention about how you use a dictionary (python) or hash (perl) to structure information
01:22:22 <temoto> i've written   openFile "htest" WriteMode   in interpreter. Can i get handle somehow?
01:23:01 <quicksilver> not now, no
01:23:02 <temoto> In python special name  _  corresponds to last evaluated statement.
01:23:10 <quicksilver> hmm
01:23:18 <quicksilver> actually maybe "it" has that role in ghci
01:23:30 <quicksilver> yeah, try "it"
01:23:49 <opqdonut> something like let a = it
01:23:52 <temoto> Yes, it works, thanks.
01:24:16 <temoto> How do i know where to use =/<-/let = ?
01:24:17 <quicksilver> I've never used that, for some reason.
01:24:32 <opqdonut> temoto: a <- foo when foo is monadic
01:24:36 <opqdonut> let a = foo else
01:24:40 <opqdonut> in ghci, that is
01:24:52 <temoto> Isn't openFile result monadic?
01:25:13 <opqdonut> yes
01:25:20 <temoto> Why let a = it then?
01:25:21 <opqdonut> but ghci "opens" it
01:25:30 <opqdonut> and thus "it" is a non-monadic value :)
01:25:48 <opqdonut> this stuff is a lot more confusing in ghci than in normal code
01:25:58 <temoto> alright, thanks.
01:26:07 <Thunder> :t let a = openFile "fasel" in a
01:26:07 <lambdabot> Not in scope: `openFile'
01:26:18 <opqdonut> Thunder: nah, IO is hidden
01:27:24 <temoto> What it means hidden?
01:27:39 <temoto> hidden for bot?
01:27:42 <opqdonut> temoto: it's hidden in lambdabot
01:27:43 <opqdonut> yeah
01:27:54 <opqdonut> to keep things safe
01:28:03 <mathijs> Hi all, I'm playing with parallelization http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1462 - somehow if I increase the numbers I keep on running out of memory, so I suspect I do something wrong and bypass laziness somehow.
01:28:15 <quicksilver> :t let a = System.IO.openFile "fasel" in a
01:28:16 <lambdabot> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
01:28:22 <quicksilver> ^^ it's not that well hidden, really.
01:28:32 <temoto> hClose it ; it    > ()    like hClose returns nothing?
01:28:35 <quicksilver> it's just not imported into the root namespace because it's not very useful.
01:29:09 <opqdonut> temoto: yeah
01:29:36 <temoto> opqdonut: alright, that's familiar :)
01:30:00 <opqdonut> many IO actions are of type something -> IO ()
01:30:09 <opqdonut> because they're needed only for their side effects
01:30:47 <temoto> What do you know it really did put data in the file.
01:31:45 * Thunder screems and run in circles: Side effects are evil! They will pull us from our warm, neat, and fuzzy ivory towers.
01:32:13 <quicksilver> side effects properly controlled and regulated by the type system are perfectly welcome in my ivory tower
01:32:14 * boegel hits Thunder with a lightning bolt
01:32:25 <quicksilver> its unrestricted side effects I won't permit.
01:33:04 * boegel flashes his unrestricted side effect at quicksilver 
01:34:06 <temoto> i guess i'm missing some great settings for editing haskell sources in vim
01:35:23 <dolio> temoto: Do you have this: http://www.vim.org/scripts/script.php?script_id=1968
01:36:48 <temoto> dolio: i expected that, thanks.
01:37:02 <dolio> There's other, fancier stuff out there.
01:37:18 <dolio> But that at least indents your haskell pretty well.
01:39:11 <opqdonut> cue emacs...
01:39:46 <temoto> Could you believe it... i've written a program and it compiled.
01:39:50 <pejo> JaffaCake, in Santos thesis he mentions that the number of free variables in a closure, which decreases the size of the closure, and this matters for the STG machine. Is this still true for GHC today?
01:40:26 <pejo> JaffaCake, which decreases = affects. Doh.
01:40:29 <mlesniak> Wikipedia has a downloadable Version of the Haskell Wiki. Is there something like this for the haskell-wiki, too? (Being offline sometimes I'd like to have to read something)
01:40:38 <JaffaCake> pejo: yes
01:40:53 <pejo> JaffaCake, so smaller = better?
01:41:01 <JaffaCake> yes
01:41:06 <pejo> JaffaCake, thank you.
01:41:16 <JaffaCake> no problem :) easy question to answer
01:42:13 <CTA> Hey, I'm on reading LYAH, it says: doubleMe x = x + x  -- type this in to your favourite editor, but when i do i need main, and module Main? I had all sorts of errors before, can someone tell me exactly what to put it please?
01:42:52 <CTA> omg now it works via GHCi..
01:43:02 <temoto> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1464#a1464
01:43:23 <opqdonut> CTA: you don't need a module definition or anything
01:43:28 <opqdonut> you can just have that one definition in a file
01:43:44 <CTA> but is that only when im running via GHCi?
01:43:54 <CTA> Just when I did ghc --make example.hs is shouted at me
01:44:04 <CTA> but when I did :l example it say OKAY
01:45:41 <quicksilver> CTA: "main" is required to compile a complete program, such as with ghc --make
01:45:55 <quicksilver> CTA: however, ghci will happily load modules (not complete programs) and let you play with them.
01:46:28 <CTA> ah ok thanks
01:46:53 <CTA> I don't know how I shuld present my code, like my format :/
01:55:29 <temoto> Why this file-writer performs slower than python? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1464#a1465
01:56:20 <temoto> i used ghc --make and it produces binary ht file. I expected it to outrun interpreted language.
01:57:10 <quicksilver> temoto: GHC's string representation is not particularly efficient.
01:57:20 <quicksilver> replace that with ByteStrings and it will be very fast.
01:57:44 <temoto> quicksilver: could you please point exact change?
01:57:56 <temoto> It's my first two hours coding haskell
01:58:45 <tehgeekmeister> > sort [3,1,5]
01:58:46 <lambdabot>   [1,3,5]
01:58:55 <temoto> And maybe i could define that string at some outer level so it won't be evaluated again and again?
01:59:07 <temoto> like define a constant function
01:59:18 <quicksilver> that happens automatically.
01:59:26 <quicksilver> the compiler does constant hoisting.
02:00:17 <osfameron> I thought dependency resolution got "constant hoisting" for free?
02:00:28 <quicksilver> add "import qualified Data.ByteString.Char8 as B" to the top of the file, replace "hPutStrLn" with "B.hPutStrLn" and replace the string "could you believe it" with (B.pack "could you believe it")
02:01:04 <ziman> there is some info on bytestrings in Chapter 8 of RWH, too
02:03:28 <temoto> quicksilver: it became twice slower
02:03:46 <temoto> well almost twice. 2.7s -> 4.4s
02:03:51 <quicksilver> temoto: are you compiling with optimisation?
02:04:01 <temoto> i guess no
02:04:04 <pumpkin_> heh
02:04:04 <temoto> ghc --make
02:04:09 <quicksilver> ah well that's your problem them.
02:04:13 <quicksilver> ghc -O2 --make
02:04:17 <temoto> Thanks.
02:04:18 <quicksilver> and rerun the test :)
02:04:32 <quicksilver> you could also switch back to plain strings and see how that does with optimisations on
02:04:35 <pumpkin_> you can doubleoptimize it too! -fvia-C -optc-O3
02:04:37 <pumpkin_> :P
02:04:44 <quicksilver> ignore pumpkin.
02:04:51 <pumpkin_> :(
02:06:01 <temoto> Slightly faster. Still slower than plain strings. Still slower than python.
02:06:15 <pumpkin_> what is your code doing?
02:06:26 <temoto> Why this file-writer performs slower than python? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1464#a1465
02:06:43 <temoto> it creates 21MB file
02:06:54 <daf> like quicksilver said, String is slow
02:08:14 * quicksilver doesn't understand how bytestring could be slower than string there.
02:08:22 <quicksilver> did it actually recompile the file?
02:08:42 <daf> oh, he changed it
02:08:46 <temoto> I'll remove it.
02:09:42 <temoto> i guess no
02:09:58 <temoto> i just recompiled old strings with optimization, it works faster than python
02:10:10 <pumpkin_> now try bytestring :D
02:11:01 <temoto> Yes, now bytestring performs even faster.
02:11:16 <doserj> I get half the running time if I put B.pack "..." on the top-level, instead of in the loop (with -O2)
02:12:41 <temoto> Isn't there an option to force recompiling?
02:13:25 <pumpkin_> ghc will recompile if the file changes
02:13:29 <pumpkin_> it's a bit like a make
02:14:25 <quicksilver> temoto: -fforce-recomp
02:14:32 <temoto> quicksilver: thank you.
02:14:36 <quicksilver> pumpkin_: but not if only the compile options change.
02:15:03 <quicksilver> doserj: that's odd. I wonder why that doesn't get hoisted out.
02:15:39 <quicksilver> doserj: I thought GHC hoisted all constant expressions, in all cases, that's why core is so full of top-level bindings.
02:15:52 <temoto> Thank you all gotta go back coding nonpure web :)
02:16:33 <ziman> temoto, this is what I get: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1464#a1466
02:16:46 <ziman> is 0.4s fast enough?
02:17:05 <doserj> quicksilver: I might be because I am still on ghc 6.8.2, though.
02:19:07 <temoto> ziman: i got 1.0-1.2s compared to python 2.2-2.6
02:20:07 <quicksilver> doserj: I thought GHC had lifted all constant bindings to the toplevel since forever
02:20:16 <temoto> ziman: btw you're making line with \n and using putStrLn so it does double \n
02:20:23 <quicksilver> doserj: I first noticed it when examining core for 6.6
02:20:50 <quicksilver> doserj: e.g, the constant list [1,2,3] generates four top-level CAFS, as in "a = 1:b; b = 2:c; c = 3:d; d = [];"
02:24:26 <doserj> quicksilver: what is the core-output to look at? -ddump-simpl?
02:24:29 <tehgeekmeister> is there a general alphabetical style sort in some library?
02:24:41 <tehgeekmeister> i want to do alphabetical style sort on a list of lists.
02:25:42 <ziman> > sort ["foo", "bar", "bazz"]
02:25:43 <lambdabot>   ["bar","bazz","foo"]
02:26:07 <ziman> Ord a => [a] is an instance of Ord
02:26:10 <tehgeekmeister> sort [[1,2],[1,3],[2,3]]
02:26:16 <quicksilver> doserj: yes, or install dons' core package wich prettifies it slightly.
02:26:23 <tehgeekmeister> oh well that's cool
02:26:27 <ziman> > sort [[1,2],[1,3],[2,3]]
02:26:28 <lambdabot>   [[1,2],[1,3],[2,3]]
02:28:00 * tehgeekmeister is cursing himself-two-days-ago for structuring his code like this
02:28:21 <tehgeekmeister> ([(String, Int)], Int)
02:28:41 <tehgeekmeister> and i'm trying to sort it on the Int in the tuple in the list in the tuple.
02:28:43 <tehgeekmeister> =P
02:29:36 <beelsebob> tehgeekmeister: fmap . fmap . fmap time
02:29:48 <tehgeekmeister> huh?
02:29:56 <beelsebob> well no, not quite, but close
02:29:59 <pejo> JaffaCake, (after thinking some more) does this mean GHC always creates a closure, and always have to dereference a pointer to make a function call?
02:30:00 <tehgeekmeister> @type fmap . fmap . fmap time
02:30:01 <lambdabot> Not in scope: `time'
02:30:06 <beelsebob> there should be a similar abstraction for doing that
02:30:11 <beelsebob> @type fmap . fmap . fmap
02:30:12 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
02:30:15 <tehgeekmeister> @type fmap . fmap . fmap
02:30:16 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
02:30:29 <JaffaCake> pejo: no, if the function can be determined statically, we jump directly to the code
02:30:35 <JaffaCake> that's a very important optimisation
02:30:36 <beelsebob> repeated applications of fmap push you through successive layers of data structures
02:30:54 <tehgeekmeister> beelsebob: how does it know which element of the tuple to go to?
02:31:15 <beelsebob> tehgeekmeister: fmap applies in the second element â€“ if you don't like that, use first
02:31:27 <beelsebob> (or second if you want fmap but lazy and stil go for the second one)
02:31:28 <tehgeekmeister> okay
02:32:03 <pumpkin_> or use first and second
02:32:15 <beelsebob> > (fmap . first . fmap . second) (+1) [([(1,2)],3)]
02:32:16 <lambdabot>   [([(1,3)],3)]
02:33:35 <doserj> quicksilver: sigh. now I get the same timings. Must have been a latency issue somewhere (real 0.705s, user 0.276s in that run. 0.5s unaccounted for.)
02:33:48 <quicksilver> OK, that reassures me :)
02:34:01 <doserj> quicksilver: core output looks alpha-equivalent, too :)
02:34:07 * quicksilver nods
02:34:11 <quicksilver> that's what I'd expect.
02:34:21 <pejo> JaffaCake, ok, there's something I don't understand here. Suppose it can be determined statically, how does the function find its free variables?
02:34:37 <JaffaCake> oh, it still needs a closure
02:34:48 <JaffaCake> just that we don't indirect through the closure to get to the code
02:36:05 <pejo> JaffaCake, so the function takes its closure as an extra parameter?
02:36:54 <JaffaCake> yes, every function takes a closure as its first argument, except in the case of top-level functions where there's no need to pass a closure
02:40:12 <quicksilver> JaffaCake: and conversely, every function which doesn't need a closure is promoted to the top-level, right?
02:40:28 <quicksilver> JaffaCake: making it a CAF and globally shared.
02:40:56 <JaffaCake> right, though we don't usually call top-level functions CAFs
02:41:27 <quicksilver> JaffaCake: ah well, I was imagining a case where some work might be done outside the lamba
02:41:31 <pejo> JaffaCake, so lambda-lifting is a performance optimization, basically?
02:41:34 <quicksilver> f = let foo = bar in \x -> ....
02:42:12 <JaffaCake> pejo: in GHC yes, in some systems it is a necessity because the underlying evaluation model can only handle top-level functions
02:43:08 <JaffaCake> e.g. hbc did lambda lifting, IIRC
02:47:39 <pejo> JaffaCake, do you have good approximations when you should lambda lift or not in GHC/is it well understood?
02:48:33 <pejo> (The relative cost of indirect jumps should have changed since the early papers on lambda lifting I assume).
02:49:00 <JaffaCake> pejo: I don't think anyone has looked at this since Santos
02:49:15 <JaffaCake> pejo: indirect jumps are still expensive - see the pointer tagging paper
02:51:59 <pejo> JaffaCake, ok, thanks again.
02:52:57 <JaffaCake> no problem
02:54:04 <tehgeekmeister> >sort [("z",1),("a",5)]
02:54:25 <tehgeekmeister> > sort [("z",1),("a",5)]
02:54:26 <lambdabot>   [("a",5),("z",1)]
03:06:37 <lilac> @tell sauf_ yes, i'm somewhat interested in OpenAL, but mostly I was trying to learn more about Reactive
03:06:37 <lambdabot> Consider it noted.
03:07:27 <ivanm> @seen matthew-_
03:07:27 <lambdabot> matthew-_ is in #ghc, #haskell-blah and #haskell. I don't know when matthew-_ last spoke.
03:22:37 <Athas> I'm on Debian and trying to compile a Haskell program (flask).  It requires something called ghc-prim, but I can't seem to find such a package anywhere (whether with cabal-install or just a tarball somewhere).
03:27:12 <cognominal> anything besides http://homepages.paradise.net.nz/warrickg/haskell/http/  to learn to use the Network.Browser package?
03:28:35 <cognominal> hum, maybe the end of the page is sufficient to get me started
03:36:16 <lilac> @seen conal
03:36:17 <lambdabot> I saw conal leaving #haskell, #ghc and #haskell-in-depth 6h 37m 15s ago, and .
03:37:51 <lilac> @tell conal "Type Class Morphisms": section 5.1, your semantic instances are incorrect; \mu (+) = ... should read \mu (ma + mb) = ... in the second and third occurrances
03:37:51 <lambdabot> Consider it noted.
03:50:20 <lilac> @tell conal 5.4: "liftA2 h u v = fmap h (*) u (*) v" is not correct; it's "liftA2 h u v = fmap h u (*) v"
03:50:21 <lambdabot> Consider it noted.
03:55:25 <fasta> Is anyone using a tool to refactor Haskell code? Like renaming a field? I know there have been "research projects", but I can imagine they are all in a broken state.
03:55:27 <jtxx000> is there any way to get at argv[0] from haskell?
03:55:56 <temoto> Please give "Why haskell" link with that tree photo on top.
03:56:18 <temoto> some blog on blogspot
03:56:24 <temoto> name starts with 's'
03:56:26 <fasta> jtxx000: getProgName
03:57:05 <jtxx000> fasta: doesn't that only return the executable name and not the directory?
03:57:46 <fasta> jtxx000: doesn't C also do that?
03:57:49 <cognominal> jtxx000,  head getArgs
03:58:18 <cognominal> or argv[0] is the executable name? I don't remember...
03:58:31 <event>     http://www.sexyemilie.com/?id=1359994
03:58:41 <fasta> cognominal: no, he wants argv[0], which is indeed the executable name.
04:00:04 <cognominal> getProgName :: IO String
04:00:18 <fasta> cognominal: which is already what I said.
04:00:42 <jtxx000> right, but if you invoke the prog like "/some/path/executable" then getProgName only returns executable
04:00:59 <jtxx000> rather than /some/path/executable
04:02:03 <cognominal> I guess you can work it out from your PATH
04:02:51 <cognominal> too bad if it has been launched from an absolute path :)
04:03:51 <fasta> jtxx000: System.FilePath contains functionality to help with that I think, but you should try to figure it out of yourself.
04:05:01 <Asztal> I'm confused about the order of the type arguments to MonadLib's BaseM type class
04:06:00 <Asztal> it seems it would be better if the base monad were the first argument, then you could do "deriving (BaseM IO, ...)", or is there something I'm missing?
04:06:11 <jtxx000> fasta: the executable directory doesn't seem to be included in getSearchPath
04:07:28 <fasta> jtxx000: if System.FilePath cannot help you, just implement the functionality yourself.
04:07:43 <jtxx000> in c/c++?
04:08:58 <fasta> jtxx000: no, why would you do that?
04:09:53 <jtxx000> fasta: because i don't see any way to get at the full path of the executable in pure haskell
04:11:21 <sjanssen> jtxx000: I think you have to use C or FFI
04:11:23 <jtxx000> getProgName only works if the executable is in the current working directory
04:11:23 <matthew-_> ivanm: I'm here
04:11:36 <ivanm> matthew-_: did you have a chance to go over the code?
04:11:38 <fasta> jtxx000: I can see a few ways, but none of them are elegant. Maybe the API is not really complete.
04:11:42 <matthew-_> nope
04:11:47 <matthew-_> but I've received the email!
04:12:48 <CTA> how do i make this right, i get parse error '='
04:12:49 <CTA> addTen x =
04:12:49 <CTA>   x = x + 10
04:12:57 <CTA> *not in scope
04:13:27 <byorgey_> CTA: just say  addTen x = x + 10
04:13:28 <ivanm> matthew-_: well, that's a start :p
04:13:34 <byorgey_> CTA: you can't destructively update x.
04:13:43 <matthew-_> ivanm: quite
04:13:47 <byorgey_> you can only return a new value which is ten more than x was.
04:13:51 <temoto> I found it again. It's not "why haskell", it's "why not haskell". http://offthelip.org/?p=125  very good article
04:13:53 <matthew-_> ivanm: I may actually have some free time this weekend to look at it
04:13:54 <jtxx000> fasta: i can deal with a hack... as long as it works on windows
04:13:57 <ivanm> \o/
04:13:57 <CTA> thanks byor, i did that just and it worked, like before you said :)
04:14:14 <whpearson> CTA or say addTen = ((+) 10)
04:14:17 <ivanm> I just don't want to start wark on updating my stuff until you've approved it, so the API doesn't suddenly change :p
04:14:42 <CTA> addTen x = x + 10 looks nicer imho
04:15:10 <ivanm> whpearson: why the extra braces?
04:15:26 <ivanm> addTen = (+) 10 <-- this should work as well
04:15:33 <whpearson> ivanm: bad habits :(
04:15:36 <ivanm> heh
04:15:46 <Thunder> :t (10+)
04:15:47 <lambdabot> forall t. (Num t) => t -> t
04:15:49 <ivanm> or, if you're perverse: addTen = flip (+) 10
04:15:50 <fasta> jtxx000: if you are willing to give up platform independence, I would just pass the absolute path to the Haskell application and use some kind of start script. My other solutions are of theoretical nature that do work, but I am sure would not be acceptable to you.
04:15:51 <ivanm> ;-)
04:15:51 <CTA> tbh ((+) 10) looks nicer than (+) 10
04:16:05 <ivanm> Thunder: depends if you want to emphasise the 10 or not, I suppose...
04:16:09 <ivanm> CTA: why is that?
04:16:16 <CTA> idk
04:16:16 <ivanm> looks messier IMHO
04:16:19 <ivanm> heh
04:16:20 <CTA> personal opinion
04:16:31 <ivanm> let's try and not look like lisp if we can :p
04:16:33 <CTA> well actually, i don't mind either
04:17:04 * Thunder hat the problem with some "adult sites". I read (18+) commonly as "transform your age to a safe one" instead of reading a requirment
04:17:12 <CTA> just trying to remember what I read, Haskell = Statically typed, that means that Haskell knows if a digit/string is being inputted?
04:17:22 <Botje> no
04:17:28 <CTA> :/
04:17:30 <ivanm> CTA: it means that you can't magically change what kind of value something is
04:17:31 <CTA> what then
04:17:32 <Raynes> (+ 10) <3 LISP
04:17:36 <ivanm> (roughly)
04:18:00 <Athas> When I try to install 'base' via Cabal, I get: config.status: error: cannot find input file: include/HsBaseConfig.h.in
04:18:02 <dolio> But in lisp, (+ 10) = 10
04:18:04 <Botje> CTA: it means you can't take a number and take its fifth element, for example
04:18:07 <jtxx000> fasta: oh well, never mind then... this was supposed to be a one-off script anyways.  it would be just as easy to reimplement the entire thing in c++
04:18:08 <Athas> This seems circular.
04:18:11 <CTA> Haskell is statically typed. When you compile your program, the compiler knows which piece of code is a number, which is a string and so on
04:18:18 <Raynes> CTA: Haskell knowing what a type is by looking at what it is is called type inference.
04:18:22 <Botje> CTA: oh. that's not the same as "inputted"
04:18:25 <ivanm> Athas: any particular reason you're trying to install base?
04:18:32 <whpearson> > x = (10:: Int) + (10 :: Integer)
04:18:33 <sjanssen> Athas: you're not supposed to install base, it won't work
04:18:33 <lambdabot>   <no location info>: parse error on input `='
04:18:35 <CTA> LYAH said that ^^
04:18:35 <Botje> if you put a string or a number in your code, haskell knows its type
04:18:37 <ivanm> since base cames _with_ ghc
04:18:39 <whpearson> > (10:: Int) + (10 :: Integer)
04:18:40 <sjanssen> Athas: your copy of GHC should have come with base
04:18:40 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
04:18:42 <Botje> but that doesn't have much to do with static typing
04:19:01 <Thunder> Botje: extractDigit i = (mod 10) . (div (10^i))
04:19:03 <Botje> if you use a program to read some data from stdin, haskell won't magically know which type it is
04:19:09 <Botje> smartass :)
04:19:14 <Athas> sjanssen: it doesn't seem like it did, for some reason, or at least it didn't put in the header files.  I just got the binary package and did 'make install'.
04:19:18 <CTA> is this "infix"? 1 'div' 2?
04:19:23 <Botje> yes
04:19:27 <Athas> I read INSTALL but it didn't mention anything interesting.
04:19:29 <Botje> well
04:19:31 <Botje> 1 `div` 2
04:19:37 <Botje> 'div' is a syntax error
04:19:39 <CTA> does it have to be `'s?
04:19:43 <ivanm> CTA: yes
04:19:46 <CTA> kk
04:19:51 <ivanm>  '1' is a character
04:19:52 <sjanssen> Athas: ghc-pkg list base
04:19:58 <CTA> so, can any function be infixed?
04:20:11 <Botje> yes
04:20:17 <Athas> sjanssen: base-3.0.3.0, base-4.0.0.0
04:20:19 <ivanm> except for things like succ, etc.
04:20:19 <Botje> simply sprinkle some  `` and you're good
04:20:22 <ivanm> (without extensions)
04:20:36 <CTA> but do you have to have 2 parametres to infix it?
04:20:41 <Thunder> ivanm: 1 is a function.
04:20:44 <sjanssen> Athas: yep, looks good.  Were you having some other problem?
04:20:45 <Thunder> :t 1
04:20:45 <lambdabot> forall t. (Num t) => t
04:20:46 <ivanm> Thunder: is it?
04:20:50 <ivanm> it's a value, not a function
04:20:54 <ivanm> a function takes inputs
04:20:58 <ivanm> well, at least one input
04:21:16 <ivanm> (I believe this is an old argument, btw :p )
04:21:16 <Thunder> ivanm: Depends on the definition. A value has a type.
04:21:24 <Athas> sjanssen: yes, I get the same error about include/HsBaseConfig.h.in missing when trying to use Cabal to install some program called 'alex'.
04:21:27 <ivanm> OK, it's a constant
04:21:29 <ivanm> a literal
04:21:30 <sjanssen> (functions are values)
04:21:31 <ivanm> whatever ;-)
04:21:33 <dolio> It's a function from dictionaries to values of a type. :)
04:21:45 <ivanm> dolio: wtf? :s
04:21:50 <sjanssen> Athas: hmm
04:22:04 <Athas> sjanssen: My GHC is installed in /usr/local, do I have to inform Cabal of this in some special way?
04:22:09 <Athas> My Cabal is in /usr/local too.
04:22:34 <ivanm> Athas: is ghc in your PATH?
04:22:39 <ivanm> if so, I don't think so...
04:22:46 <dolio> ivanm: 1 numDict = numDict.fromInteger oneInteger
04:23:06 <sjanssen> Athas: look at the output of 'ghc-pkg describe base', do the paths look correct?
04:23:07 <ivanm> ummm..... how does that work?
04:23:26 <dolio> It doesn't in atual haskell, but that's how GHC implements it.
04:23:31 <dolio> Roughly.
04:23:40 <dolio> Actual, even.
04:24:07 <ivanm> dolio: a slightly different case then, is it not?
04:24:08 <ivanm> ;-)
04:24:10 <Athas> sjanssen: Yeah, looks fine to me.
04:24:22 <dolio> Eh.
04:25:13 <Athas> I have HsBaseConfig.h, not HsBaseConfig.h.in.  I am not familiar with what the latter is supposed to be.
04:25:18 <quicksilver> except that GHC fairly agressively inlines and discards dictionaries.
04:25:39 <dolio> Of course, from another perspective, 1 is a function from types of a certain kind to values.
04:26:05 <dolio> 1 : (n : Num) -> n
04:26:41 <quicksilver> which is roughly how JHC implements it.
04:27:09 <Thunder> :src 1
04:27:29 <Thunder> @src 1
04:27:29 <lambdabot> Source not found. :(
04:27:39 <dolio> Yeah. And it aggressively eliminates explicit type passing. :)
04:29:16 <ivanm> dolio: so is there a seperate "function" for each literal number?
04:29:22 <ivanm> or does 1 represent all of them?
04:32:23 <dolio> ivanm: Each literal n = fromInteger nInteger.
04:32:39 <dolio> Where the reference to fromInteger depends on a hidden dictionary argument.
04:32:41 <ivanm> dolio: all possible integers, or just all possible Int values?
04:32:57 <dolio> @type fromInteger
04:32:58 <lambdabot> forall a. (Num a) => Integer -> a
04:33:25 <sjanssen> "1" compiles to "fromInteger (S# 1#)"
04:33:26 <dolio> It has to be Integer. Otherwise you wouldn't be able to have literals for anything Int can't handle.
04:33:36 <ivanm> dolio: yes, but isn't Integer infinite?
04:33:45 <ivanm> (theoretically, anyway)
04:34:00 <opqdonut> well, arbitarily large
04:34:03 <Athas> How are these .in files made from .h files?
04:34:22 <dolio> Yeah, well, it's not like they're all written down in some file.
04:34:31 <ivanm> *phew*
04:34:44 <opqdonut> :P
04:34:54 <sjanssen> Athas: a .h is generally generated from an .h.in by a preprocessor (like autoconf)
04:35:18 <sjanssen> Athas: it sounds like GHC's makefile went rather wrong for you, I'd start from there
04:35:54 <Athas> In that case, I shall reinstall ghc.
04:42:21 <Athas> Damn, that didn't make a difference.
04:42:53 <Athas> In my ghc tarball dir itself, the .in files aren't generated either.
04:46:09 <CTA> Is Haskell's GUI as bad as WIN32?
04:47:09 <Zao> CTA: Depends on which GUI library you use.
04:47:28 <Zao> There's bindings to regular GTK and wx I believe. As well as shiny declarative ones built on top of those.
04:47:40 <CTA> I would use one of the most popular?
04:47:41 <Zao> Not to mention the X11 and Win32 bindings that are just FFI wrappers, kind of.
04:48:04 <Zao> Try gtk2hs perhaps?
04:48:27 <Zao> Probably helps to have some GTK knowledge though.
04:48:33 <CTA> function = do -- do i have to add that to every function? just i get errors i think
04:48:39 <Zao> I'm sure there's a GUI section on Hackage.
04:48:54 <Zao> CTA: Show what you have on hpaste.org?
04:50:03 <CTA> nevermind, i think i was just opening functions via GHCi
04:50:49 <CTA> wierd, it works now
04:51:07 <CTA> is it best to add 'do' to every function?
04:51:18 <Axman6> no
04:51:24 <CTA> why
04:51:28 <Axman6> only monadic functions can use do
04:51:33 <Axman6> like IO
04:51:50 <Axman6> for now, just accept that only IO functions can use do
04:52:05 <Thunder> :t do return
04:52:06 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
04:52:24 <Zao> do is handy sugar for executing several actions in sequence.
04:52:24 <Thunder> That's the problem. You do can't leave the do.
04:52:54 <CTA> shower, then ill clean room and read LYAH
04:52:59 <CTA> ./away
04:53:13 <Zao> > let f x y = putStrLn x >> putStrLn y in f "omg" "wtf"
04:53:14 <lambdabot>   * Exception: "<IO ()>"
04:53:24 <Axman6> so i bought my uni books today. managed to get off cheap. $200AU for three textbooks
04:54:04 <Igloo> dons: Is your 70M on a 32-bit platform?
04:54:07 * Botje hasn't bought textbooks since his first year
04:54:20 <CTA> whats the msot "famous" thing made in Haskell@
04:54:36 <wli> All my books are in storage. :(
04:55:02 <whpearson> CTA: ghc :P ?
04:55:22 <Axman6> got C Programming, a modern approach, Java Se 6 the complete reference, some personal programming process book (ok, it's called something totally different)
04:55:43 <Axman6> CTA: probably either darcs, or happs maybe
04:56:01 <Botje> Axman6: my concolences :)
04:56:04 <Botje> *condolences
04:56:17 <Axman6> yeah :\
04:56:20 <Botje> on the plus side
04:56:22 <Axman6> the C book is wuite nice though
04:56:25 <Axman6> q*
04:56:29 <Botje> you'll have lots of free time to hack on haskell :)
04:56:45 <Axman6> heh
04:57:01 <Axman6> i'm hoping that knowing haskell will make mt C better, more functional
04:57:04 <Igloo> dons: Also, Debian's sizes assume a block size of 1k, so may vary from arch's sizes
04:57:40 <wli> C is not likely to change in such a manner.
04:57:54 <Botje> Axman6: don't count on it
04:58:05 <Axman6> well, i mean, breaking things down into smaller functions and such
04:58:08 <Botje> the most important thing you'll be able to take away from C is pointers
04:58:17 <Axman6> yeah
04:58:22 <daf> I wish somebody would take pointers away from my C
04:58:25 <Botje> and composing functions generally entails passing pointers and pointers-to-pointers around
04:58:31 <Axman6> this book doesn't get to pointers until chapter 12 i think
04:58:33 <Axman6> or later
04:58:46 <whpearson> Does it cover function pointers?
04:59:17 <Athas> Does anyone here use http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html?
04:59:30 <Athas> How does Debian-users install and manage their Haskell packages?
04:59:48 <Athas> At this point, I only care about making it work...
05:00:25 <Axman6> Athas: i think the recommended way to install any haskell package is with cabal-install, but i could be wrong
05:00:33 <Athas> What about GHC itself?
05:01:47 <wli> Pointers aren't that far out.
05:02:09 <blackh1> Athas: I am using Ubuntu 8.10 and I downloaded the binary for 6.10.1 and I use the latest cabal.  It works perfectly.
05:02:25 <blackh1> Athas: That is, I'm not using the Ubuntu packages - but then I need 6.10.1 features.
05:02:33 <Athas> The tarball binary from haskell.org/ghc?
05:02:51 <Athas> Which architecture are you?
05:02:56 <blackh1> Athas: That's it. You just have to get the libedit version right. I'm on amd64.
05:03:23 <wli> Cmdline editing on 6.10.x got to me.
05:03:26 <CTA> haskell is very different for me seen as iv been around c based languages ALOT
05:03:56 <blackh1> CTA: Same here
05:04:00 * Twey allots CTA the task of reading SICP.
05:04:11 <Athas> Do you have a file named /usr/local/lib/ghc-6.10.1/base-4.0.0.0/include/HsBaseConfig.h.in?
05:04:12 <CTA> SICP?
05:04:19 * wli does C for pay.
05:04:22 <Axman6> CTA: google it
05:04:43 <CTA> I'm 15, I wanna be a games dev lol.. So hopfully I can be with Haskell :S
05:05:05 <wli> Abelsen and Sussman "Structure and Interpretation of Computer Programs."
05:05:10 <CTA> Structure and Interpretation of Computer Programs, ?
05:05:15 <Axman6> yes
05:05:27 <Axman6> all 15 year olds these days want to make games
05:05:28 <Twey> Read that
05:05:31 <Twey> Do the exercises
05:05:35 <Twey> It'll teach you how to program
05:05:40 <blackh1> CTA: Haskell has huge potential for writing games, IMO
05:05:43 <wli> What MIT used before they gutted their CS curriculum.
05:05:47 <Axman6> and become a wizard too
05:06:00 <CTA> No i'm serious about it
05:06:09 <roconnor> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
05:06:34 <daf> wli: gutted?
05:06:37 <wli> I don't know about Haskell's potential for writing games. It could have some, but I just don't know enough about what games do to say.
05:07:02 <wli> daf: Yeah. They dumped Scheme. Not sure if for Java or what.
05:07:06 <Botje> CTA: thinking structurally about programming is more important than knowing the language you're writing it in
05:07:09 <Botje> wli: python, i think
05:07:14 <Botje> so it's not a total loss
05:07:22 <blackh> CTA: Take a look at all the reactive animation stuff. This is an ingenious way of writing animations.
05:07:49 <wli> python seems like a weird choice to me, but anyway.
05:08:10 <daf> wli: I'm not sure that replacing one class is "gutting"
05:08:48 <wli> I think it went along with changes to other classes in a similar vein.
05:08:58 <CTA> So what should I do? Get a knowledge of Haskell then study design patterns?
05:09:15 <CTA> and btw, if Haskell knows what type something is in fraps why is this here:
05:09:16 <CTA> kTextures :: Int
05:09:16 <CTA> kTextures    = 1
05:09:27 <Botje> documentation.
05:09:31 <wli> CTA: Please, not design patterns.
05:09:43 <CTA> I was just asking
05:09:52 <Botje> design patterns are useless
05:09:53 <CTA> Then what, I'll read RWH/LYAH and then what
05:09:57 <blackh> CTA: The type signature here is optional, but it's good practice to put them in.
05:10:01 <wli> CTA: Algorithms.
05:10:05 <Botje> they're just names for common occurrences.
05:10:07 <whpearson> CTA: Typeclassopedia!
05:10:12 <CTA> Kk, don't you learn them in CS?
05:10:34 <daf> design patterns are not that interesting
05:10:39 <wli> CTA: They're not really good CS.
05:10:41 <CTA> are algorithms?
05:10:51 <daf> CTA: I think the single most important thing is practice
05:10:52 <wli> CTA: Algorithms are good CS.
05:11:14 <wli> daf is right.
05:11:15 <daf> CTA: other things will help you be a good programmer
05:11:26 <daf> CTA: but nothing substitutes for writing programs
05:11:37 <mathijs> CTA: design patterns are very useful when doing OOP, but in FL's like haskell, you can abstract the design patterns away most of the time and think about higher-order structures.
05:11:45 <CTA> so, I read some books on Haskell and hopefully get a good understanding, practise ALOT then get some algorithm books?
05:11:47 <daf> though reading programs is also good
05:12:41 <wli> Reading is very important. I need to get better at that myself.
05:12:57 <daf> yeah, I think that's one thing that CS curricula tend to miss out
05:13:09 <CTA> I need to read more
05:13:14 <daf> CTA: I don't know about algorithms books
05:13:28 <CTA> I'll be taking math and further math A level, Haskell is good for math i've heard/
05:13:31 <CTA> *?
05:13:45 <Axman6> CTA: do whatever you want to do, it's not up to us. you're young enough to choose to do whatever you want. you're not going to be making games by 18, so relax :)
05:13:46 <daf> a lot of the algorithms / data structures stuff you pick up in other contexts, I think
05:14:05 <daf> CTA: I did that and got two Ds :)
05:14:24 <CTA> haha lol
05:14:58 <CTA> I'm doing GCSE atm, done one math exam and got A, classed as the easiest one though :/
05:15:06 <daf> I still love maths, but for whatever reasons, it didn't work out ofr me at A level
05:15:24 <Axman6> i'm assuming you mean distinctions daf?
05:15:47 <daf> Axman6: A level = exams at 18 in British schools
05:16:08 <daf> Axman6: as opposed to GCSEs, exams at 16
05:16:10 <Axman6> so 'two Ds' /= 2 distinctions
05:16:17 <daf> Axman6: indeed :)
05:16:23 <CTA> distiniction == 'A'?
05:16:25 <Axman6> ok :)
05:16:29 <CTA> idk
05:16:35 <Axman6> probably more b-b+
05:16:41 <daf> CTA: I think the best advice I can give you is to do what you enjoy
05:16:43 <Axman6> b to b+*
05:16:54 <CTA> I like math and computers lol
05:17:23 <Axman6> well, learn haskell. get good at it. get reallt good at it, and you'll uderstand both very well :)
05:17:28 <Axman6> y*
05:17:29 <CTA> i want to take math and programming at college, but i hear only a couple do haskell, and there like hard to get in to, and im not the "brighest spark"
05:18:05 <Axman6> you don't need to do haskell at uni
05:18:15 <whpearson> I wish I had come across haskell when I was young, I might be better with abstract maths concepts....
05:18:21 <daf> CTA: mm. It's worth remembering that your education doesn't have to coincide with your schooling
05:18:43 <Axman6> whpearson: luckily they taught it to us in first semester of uni :)
05:19:04 <daf> CTA: you could not do CS at A level and Univeristy, and still get a job doing it
05:19:09 <chessguy> heh, my grades in school weren't the best because i more interested in my education :)
05:19:18 <daf> CTA: certainly when I'm looking at job candidates, I don't really look at their education
05:19:29 <daf> CTA: I look at what they have done
05:19:29 <whpearson> I got given C++ at uni :(
05:20:01 <Axman6> i'm doing C, asm and java this semester (in different courses)
05:20:04 <CTA> so, even if I did not take Haskell at college/uni - but had years and years of experience - i could get job?
05:20:10 <chessguy> so when everyone else was doing they're silly requirements documents, i was off reading about cellular automata and genetic programming :)
05:20:27 <daf> CTA: absolutely
05:20:55 <Botje> CTA: if you are even remotely interested in haskell, you're already better suited than 90% of the programmers out there
05:21:05 <Axman6> CTA: any programming experience will get you a job if you're good at it
05:21:12 <Botje> chessguy: so you let your genetic algorithms generate them? :)
05:22:05 <chessguy> heh, no. i just threw it together at the last minute :)
05:22:12 <CTA> at A level math etc do they let you bring a laptop and you jsut type the work?
05:22:38 <Raevel> what's A level?
05:22:49 <CTA> college?
05:22:57 <CTA> after comp school?
05:23:03 <Twey> CTA: Most colleges will let you, yes
05:23:16 <CTA> cool, just i prefer that (:
05:23:25 <CTA> haskell work fine on macS?
05:23:25 <Twey> Just don't get mugged :-P
05:23:29 <Twey> Yeah
05:23:37 <Raevel> our professor in number theory forces us to hand in hand-written documents, since he's "not so good with computers" :-)
05:23:53 <CTA> print them out lol?
05:23:55 <Twey> Raevel: He's so bad with them that he can't even read printed text?
05:24:00 <Raevel> Twey: correct
05:24:10 <Twey> 'Ah!  A computer touched this!  It'll infect me with viruses!'
05:24:21 <Raevel> well :-P probably not that bad, but he wants them hand-written
05:24:51 <Raevel> CTA: works fine on macs, yes
05:24:56 <Axman6> CTA: i'm on a mac, i have o issues
05:24:59 <Axman6> no*
05:25:18 <Axman6> sadly it;s not 64-bit, but oh well, you don't lose much
05:25:54 <CTA> cool, I'm thinking about getting a macbook pro for college, but for decent one = £2000~
05:25:59 <mathijs> Axman6: isn't 64bit supported for mac? on linux it is
05:26:21 <Axman6> mathijs: not with ghc. it's supposed to be fixed by 6.12 :\
05:26:24 <Twey> You can always install Linux on a MacBook.
05:26:31 <Axman6> no thank you
05:26:38 <temoto> and minix
05:26:40 <CTA> MacBook Pro + VM - Windows - = win
05:27:00 <Raevel> heh, then you might as well save 50% off the cost and buy another laptop
05:27:06 <Twey> :-P
05:27:11 <lilac> Raevel: maybe your prof's girlfriend ran off with a computer once?
05:27:18 <Twey> I'm tempted to shell out for an EEEPC or something
05:27:38 <Axman6> i have used Arch in VMware before, but i don;t have the hdd space really, and i got no benefits using Arch over OS X
05:28:03 <Raevel> lilac: i can only imagine the soap opera that is academia
05:28:03 <mathijs> Twey: I got one recently (well, an msi netbook). it's very nice, especially with xmonad.
05:28:10 <CTA> I might not get a mac though, £2k mac book pro specs = £500~ windows
05:28:24 <Dybber> I have a .cabal file which among other things contains a list of dependencies. How do I use cabal-install to get these dependencies installed?
05:28:41 <Axman6> CTA: but then you end up with windows
05:28:48 <CTA> shh
05:28:52 <Axman6> and miss out on OS X and all its goodness
05:28:56 <CTA> windows + hackintosh?
05:29:07 <Axman6> no
05:29:10 <Botje> OSX .. goodness ...
05:29:13 <Twey> You can always install Linux on it
05:29:19 <Twey> mathijs: They seem ideally suited for note-taking and stuff
05:29:20 * Botje resists the temptation to flame
05:29:21 <CTA> windows + linux then?
05:29:34 <dcoutts> Dybber: use: cabal install foo bar baz  -- the list of packages you want to install
05:29:45 * Axman6 hates hackintosh users with a passion
05:29:55 <dcoutts> Dybber: or just in your package dir, use cabal install on it's own, that installs all deps and your package in one go
05:30:02 <Twey> CTA: Why waste disk-space on Windows?
05:30:29 <CTA> i like windows
05:30:30 <mathijs> Twey: they are, or trying stuff out quickly. I also have HSDPA internet everywhere, which makes it useful for even more stuff.
05:30:33 <Dybber> dcoutts: Thanks, it was the last thing without arguments i wanted :)
05:30:33 <Axman6> no one needs windows, they just think they do
05:31:14 <mathijs> CTA: for programming (almost any language) you are far better of on a posix OS.
05:31:47 * Axman6 agrees
05:31:54 <Twey> mathijs: How's the battery life on yours?
05:32:04 * Twey also agrees.
05:32:14 <CTA> posix?
05:32:26 <Dybber> dcoutts: it couldn't find the "happy" package when issueing "cabal install", but there was no problem when i specifically said "cabal install happy"
05:32:33 <Axman6> i've got a friend who (tries) to use his EeePC for not taking. it doesn't work very well. the keyboards are pathetic
05:32:39 <Raevel> today on the pirate bay trial: "Is Oded involved in the technical aspects?" "No, he's not very good with that part. He uses Windows."
05:32:39 <Dybber> dcoutts: Are you sure "cabal install" installs dependencies?
05:32:43 <pejo> Windows is quite POSIX, even NT 3.51 was fairly posix compliant iirc.
05:32:44 <Botje> i have an eee1000
05:32:48 <Botje> the keyboard is fine
05:32:52 <mathijs> Twey: I ordered a do-it-yourself touchscreen-kit for it, works very good too... I keep it in my car and use it with open-source navigation software, connected it to the car-stereo so I can listen to all music I want. Battery is the only thing that's bad... 1.5 - 2 hours at most
05:33:05 <dcoutts> Dybber: aye, it does not track dependencies on build tools yet, only on library dependencies
05:33:07 <Botje> i get ~ 4 hrs on battery
05:33:08 <Axman6> Botje: that's one of the larget ones right?
05:33:10 <Twey> mathijs: Not going to last for a whole day at college then...
05:33:11 <Botje> yes
05:33:17 <Twey> Botje: What've you got?
05:33:17 <Dybber> dcoutts: ah okay :-)
05:33:18 <Botje> i chose it especially for the keyboard
05:33:18 * Axman6 used to get 4 hours battery life on his MBP
05:33:20 <Twey> The EEE?
05:33:25 <Botje> EEE1000H
05:33:34 <Axman6> H? :(
05:33:35 <Twey> Are the batteries heavy?
05:33:36 <koeien> my battery only lasts 15 minutes
05:33:40 <Twey> Could you reasonably carry a spare?
05:33:42 <koeien> 4 yr old laptop
05:33:44 <Botje> http://www.laptopshop.nl/product/58496/asus-eee-pc-1000h-wit.html
05:33:47 <Botje> this one
05:33:59 <Botje> (except in black)
05:34:22 <Botje> spare battery wouldn't weigh too much i think
05:34:30 <Botje> but they've announced the 1000HE
05:34:33 <Botje> which gets 9+ hours
05:34:44 <Twey> Woah
05:35:13 <mathijs> Twey: I did get it to 4 hours when disabling harddrive and lower screen brightness, but you have to make sure no daemon processes try the harddisk.  I think, with the screen off, you can get even longer times, but in that case you can probably only use it to record audio, which can be useful.
05:35:18 <Axman6> bah, more copying of Apple. they were doing 8 hours first
05:35:19 <Axman6> >_>
05:35:27 <Axman6> yes it was a joke guys, relax
05:35:29 <blackh> Brilliant! I am having another "Haskell is totally amazing" moment.
05:35:32 * Twey laughs.
05:35:39 <Twey> blackh: Oh, you get lots of those
05:35:50 <Axman6> blackh: care to elaborate?
05:36:02 <blackh> Twey: "Haskell is totally amazing" is old news, I knwo!
05:36:30 <mathijs> CTA: posix = unix-like, like linux, *bsd, macosX. It's a kind of standard/api.
05:36:40 <blackh> Axman6: I have just figured out that as long as I carefully ensure referential transparency, I can make my database look like a map or something and use it in pure code.
05:36:56 <Axman6> sounds good :)
05:37:08 <Axman6> just, make sure you're careful! :P
05:37:13 <Twey> It is a standard :-P
05:37:15 <blackh> Axman6: I'm doing this with unsafePerformIO and rnf from Control.Parallel.Strategies to make sure the result is evaluated
05:37:16 <Botje> Twey: http://promos.asus.com/US/1000HE/ASUS/index.html
05:37:36 <Twey> Wow, 9.5?
05:37:44 <blackh> Axman6: I have to be careful, of course, but I only have to be careful in one small area.
05:37:52 <Axman6> nice :)
05:38:02 <Twey> USD$400
05:38:03 <Axman6> blackh: would make a great hackage package when you're done
05:38:10 <Twey> What's that nowadays, Â£0.50?
05:38:42 <blackh> Axman6: My app started off being very monadic, since I was new to FP, and it's gradually becoming purer and purer.
05:38:44 <opqdonut> which is again 0.20 euros or so ;)
05:38:44 <Axman6> Twey: give it a few months
05:39:09 <mathijs> Twey: you might be able to get a spare, they aren't that heavy either. But having to swap them requires either AC power, or shutting down/hibernating, which is kind of cumbersome I think.
05:39:17 <blackh> That's about 5434573948573457398735 New Zealand dollars
05:39:38 <Axman6> so about 4345739485734573987350 AUD :)
05:40:11 <Twey> mathijs: That doesn't bother me much â€” easy to swap in between classes
05:41:19 <lilac>  $ - £ - EUR exchange rates are all pretty close to 1 these days
05:41:25 <mathijs> Twey: even then.... you need at least 3 spares for an 8-hour day, which I think is quite expensive.
05:41:41 <blackh> lilac: They're preparing to merge the two currencies.
05:41:51 <Twey> Which two?
05:42:06 <tomh> any dutchies here who already did a master thesis?
05:42:12 <blackh> USD and EUR (I am joking)
05:43:33 * CTA has just put aftershave in his eye
05:44:11 <gwern> @remember KetilMalde No, those are quite outdated by now.  The new horsemen of the programming apocalypse are, of course, IO, MutableState, LazyMemoryLeak, and Bottom.
05:44:11 <lambdabot> It is stored.
05:44:19 <gwern> @flush
05:44:38 <roconnor> boy, my old old Zimbabwe $100 note is worth so very little.
05:45:25 <Twey> CTA: You're doing it wrong.
05:45:27 <roconnor> oh crap
05:45:39 <roconnor> as of this month it is an old old old Zimbabwe $100 note
05:45:48 <opqdonut> :D
05:45:53 <Twey> Hahaha
05:46:20 <Twey> mathijs: So the EEE1000HE is worth it, you reckon?
05:46:42 <Axman6> roconnor: i think quite literally, the paper it is printed on is worth more than the monetary value
05:46:43 <Twey> blackh: Don't fear the monads
05:46:48 <Twey> blackh: Only IO is impure.  :)
05:47:02 <Axman6> i mean, they were hitting the 64bit int limits in their databases in some cases
05:47:10 <Axman6> > maxBound Int64
05:47:11 <lambdabot>   Not in scope: data constructor `Int64'
05:47:15 <Axman6> > maxBound :: Int64
05:47:16 <lambdabot>   9223372036854775807
05:48:06 <blackh> Twey: I have taken that to heart and I sprinkle my code with state monads.
05:48:14 <roconnor> in modern Zimbabwe dollars it is worth $100 * 10^-12 * 10^-10 * 10^-3
05:48:16 * Twey laughs.
05:48:47 <roconnor> so that is $10^-23
05:48:54 <redditbot> Denotational design with type class morphisms
05:49:31 <mathijs> Twey: that looks really nice with 9.5 yes
05:50:17 * Twey nods.
05:50:17 <Petrosian> Can anyone enlighten me as to what the acronym "CAF" stands for?
05:50:38 <Axman6> constant applicative form i think
05:50:49 <Petrosian> Cheers Axman6
05:50:57 <Axman6> it's on the wiki too
05:51:12 <Petrosian> Even better
05:51:20 <mathijs> Twey: any detailed specs known? like harddisk and dvi out maybe?
05:52:45 <roconnor> Axman6: I think it works out to about USD $3*10^-31 at the moment
05:52:49 <Botje> don't count on DVI out
05:53:07 <roconnor> Axman6: though I'm not sure I've done the USD conversion properly
05:53:16 <Axman6> heh
05:53:18 <mathijs> Twey: looks like they ship with windows?  let's hope linux is supported without any strange drivers...
05:53:19 <Twey> mathijs: *shakes head*
05:53:42 <roconnor> Axman6: that seems like a very small amount of currency
05:54:06 <Axman6> i was say the paper is definitely worth more then :)
05:54:36 <roconnor> :)
05:56:41 <roconnor> "As a country, we have come to terms with this stubborn reality that we were put under economic sanctions by Germany, which unilaterally cut a 50-year-old contract to supply us with currency printing paper, machinery, spare parts and inks without notice in July last year."
05:56:50 <roconnor> ah sorry
05:57:04 <roconnor> enough with my distraction
05:57:59 <lilac> IO, MutableState, LazyMemoryLeak, and Bottom? Who's been renaming Jupiter's moons?
05:58:36 * lilac pledges to name his next three monads Europa, Ganymede and Callisto
05:58:44 <Axman6> heh
05:59:31 <Axman6> roconnor: that was zimbabwe?
06:01:27 <roconnor> Axman6: yes
06:01:35 <Axman6> how interesting
06:01:50 <Axman6> maybe the paper is worth a _lot_ more then :D
06:02:11 <roconnor> Axman6: see #haskell-blah
06:29:45 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1473#a1473 Which instance do I have to provide to make use of the GeneralizedNewtypeDeriving extension for my MonadLogger?
06:32:40 <rohan> what type of environment is haskell suited for? e.g. php is for web, java for applets, C for system programming etc (speaking roughly)
06:33:10 <LeCamarade> All of them. Except maybe kernels.
06:33:16 <Cheshire> rohan as a substitute for transplanting your brain with dynamite
06:33:32 <LeCamarade> It's just not explored.
06:33:40 <rohan> LeCamarade: ok, and where has it mainly used?
06:33:42 <Axman6> LeCamarade: there's kernels written usig haskell
06:33:42 <Axman6> using*
06:34:00 <rohan> are there many practical "stuffs" using haskell? i know of one RCS - darcs
06:34:26 <Axman6> happs (now knows as happstack)
06:34:29 <LeCamarade> Axman6: Yes. I posted the Rddit links mostly. But it wouldn't beat C at it.
06:34:30 <Axman6> GHC of course
06:34:54 <rohan> oh yes, but a compiler doesn't count
06:35:00 <LeCamarade> rohan: Much practical stuff stays within niche communities.
06:35:02 <Botje> rohan: Haskell is suited for writing programs that are expected to work correctly the first time :)
06:35:14 <rohan> LeCamarade: niche communities including?
06:35:28 <LeCamarade> Haskell (and SML) are suited to writing programs where testing resources are very limited.
06:35:40 <LeCamarade> Because they pack a testingsuite out of the box.
06:35:42 <Axman6> LeCamarade: depends how you define 'beat'. there's one kernel, L4.verified, that has a haskell reference implementation, which is supposed to be provably correct, ie, it'll never crash
06:35:48 <ozy`> rohan: a compiler is an excellent demonstration of any language's power.
06:36:02 <rohan> ozy`: of course, but i meant "end user" applications
06:36:10 <pejo> Axman, ..assuming the hardware does not have any bugs.
06:36:12 <ozy`> I suspect xmonad is actually the most widely used "normal" haskell program
06:36:24 <rohan> for example, if someone asked me "tell me one biggest win of C", i'd say linux. what would i say for haskell?
06:36:31 <Axman6> pejo: well, yes, that was ourside of the scope of the research :)
06:36:40 <rohan> please understand i'm not trying to be a troll, i'm just interested in haskell and finding out more about it
06:36:48 <Axman6> i'd say unix, not linux
06:36:56 <ozy`> rohan: software transactional memory
06:36:58 <SamB> the hardware usually has bugs ;-P
06:37:01 <Cheshire> 10,876 articles found for: recursion scheme
06:37:03 <ozy`> rohan: you heard of that? ;)
06:37:08 <LeCamarade> rohan: Yes, those are nice questions. I remember them being asked of Perl in 1987.
06:37:16 <LeCamarade> And of C in 1970.
06:37:19 <rohan> ozy`: no, i haven't
06:37:25 <quicksilver> rohan: there is a fairly good list at http://www.haskell.org/haskellwiki/Applications_and_libraries
06:37:29 <rohan> LeCamarade: ok, you mean that haskell is relatively new
06:37:31 <LeCamarade> :o)
06:37:36 <rohan> quicksilver: thanks :)
06:37:59 <ozy`> rohan: STM (among other techniques) is a way of writing parallel/concurrent programs with automatically managed synchronization.
06:38:14 <Axman6> rohan: haskell is excellent for parallel and concurrent programming
06:38:18 <SamB> LeCamarade: so ... what is the answer for perl ?
06:38:20 <LeCamarade> Not new. Just unexplored. Nobody has used it to build a guestbook (as in, in a sufficiently-big number). Yet they say "Where are the guestbooks?"
06:38:24 <LeCamarade> Et cetera. :-)
06:38:24 <SamB> or an answer at least?
06:38:47 <ozy`> I guess someone could write a guestbook in haskell with very little effort
06:39:00 * SamB tries to remember what a guestbook is
06:39:17 <LeCamarade> Yes, minimal effort. But they ain't tried.
06:39:32 <SamB> (well, okay, actually I do remember. but I haven't seen too many lately ...)
06:39:36 <ozy`> rohan: speaking of perl, the first reference perl 6 implementation (pugs) was written in haskell.
06:39:40 <LeCamarade> Circular dependency: show me code before I can write code. And since GHC usually doesn't count ... :-|
06:39:47 * SamB thinks maybe blog comments took over that role ?
06:40:11 <rohan> ozy`: oh ok
06:40:15 <SamB> LeCamarade: well, it certainly isn't the best source for style tips ;-P
06:40:32 <ozy`> SamB: yeah. guestbooks were never really useful.... when people did use them, they treated them like blogs or forums
06:40:50 <LeCamarade> Yes, Pugs should be a good argument for Haskel, but they say "Compiler. Again."
06:41:25 <SamB> ozy`: well, they may have used them to write stuff about particular other pages on the site
06:41:39 <ozy`> people write compilers in haskell because haskell makes them fun to write
06:41:39 <SamB> ozy`: which would be much nicer if they could write on that page
06:41:57 <rohan> could one write a C compiler in haskell?
06:42:02 <SamB> so ... blog comments work a lot better for that
06:42:03 <Zao> rohan: Yes.
06:42:05 <ozy`> rohan: of course.
06:42:10 <SamB> or perhaps wiki Talk: pages
06:42:17 <SamB> if you have a non-serial site
06:42:42 <ozy`> SamB: bah, anyone who had anything useful to say before the invention of blogs posted it to a forum or a mailing list
06:42:45 <SamB> (and don't let others modify the main pages)
06:42:46 <ozy`> :p
06:42:57 <SamB> ozy`: well, what if it was about a personal site?
06:43:11 <rohan> SamB: what about haskell makes compilers fun to write in it?
06:43:17 <ozy`> SamB: then it consisted of unicorns and I wasn't reading it anyway
06:43:32 <SamB> rohan: the algebraic datatypes, the laziness, the typeclasses
06:43:41 * Axman6 is downloading the 50 most essential pieces of classical music from iTunes for uni
06:43:57 <rohan> SamB:
06:44:06 <drhodes> Axman6: are you a guitarist?
06:44:06 <SamB> ozy`: what if it had lots of (implied) sex and (explicit) violence ?
06:44:07 <rohan> SamB: "laziness"?
06:44:18 <Axman6> drhodes: i am, or was
06:44:22 <SamB> > hr
06:44:24 <lambdabot>   "--------------------------------------------------------------------------...
06:44:40 <SamB> > length hr
06:44:42 <ozy`> SamB: I have no idea where you're going with this....
06:44:44 <ozy`> :p
06:44:55 <lambdabot>   thread killed
06:45:09 <Philippa_> laziness isn't such a big deal for compiler writing compared to typeclasses and ADTs, admittedly
06:45:18 <SamB> well, okay
06:45:21 <Axman6> drhodes: why do you ask?
06:45:26 <SamB> that was just the order I thought of 'em in
06:45:33 <rohan> ok well it's definitely interesting - is real world haskell a good place to start with?
06:45:40 <ozy`> rohan: yes
06:45:43 <Philippa_> and by now, I'd really like more developed polytypism. But that's after having used Haskell for more than half a decade for it
06:46:01 <SamB> Philippa: what do you mean ?
06:46:10 <drhodes> Axman6: because your nick is Axman6, or Axe Man. A guitar is sometimes referred to as an "Axe"
06:46:30 <Philippa_> (in particular, I want to be able to readily derive types from other types and get operations exploiting their relationship cheaply)
06:46:49 <SamB> Philippa: ah.
06:46:51 <ozy`> rohan: you might also take a look at the "write yourself a Scheme in 48 hours" tutorial
06:46:59 <SamB> like zippers ?
06:47:22 <rohan> ozy`: isn't Scheme language different from haskell
06:47:23 <rohan> ?
06:47:26 <ozy`> rohan: it's exactly what it says on the tin... a bit less time consuming than going through all of RWH
06:47:43 <SamB> rohan: well, yes, but it's about writing a Scheme interpreter in Haskell
06:47:47 <ozy`> rohan: yes, but in the tutorial you write an interpreter for it
06:47:59 <Philippa_> SamB: zippers and bindings are the first that come to mind, yeah
06:48:19 <SamB> I got bogged down trying to support R5RS or R6RS numeric literals, personally ;-P
06:48:20 <rohan> ok, thanks SamB , ozy`
06:48:28 <Philippa_> (a binding is roughly speaking what you get when you shave all the 'node data' off an AST type and parameterise on a replacement for it
06:48:29 <Philippa_> )
06:48:42 <rohan> how is ghc bootstrapped?
06:48:48 <ozy`> SamB: meh, I skipped over that part :p
06:48:53 <Philippa_> (only really I want the variant for mutually recursive sets of types)
06:48:57 <Thunder> rohan: viaC
06:49:04 <SamB> rohan: with much blood and sweat
06:49:13 <SamB> it might also involve virgin sacrifice
06:49:20 <Cheshire> Philippa, well to compute types from types and (generic) functions from types to values ...
06:49:29 <rohan> so a compiler was compiled using C, then that was used to compile the "final" version of the compiler?
06:49:30 <Thunder> rohan: The real initial bootstrap was via hbc
06:49:38 <SamB> 'tis a very esoteric process ;-P
06:49:38 <ozy`> rohan: the usual approach to building GHC is to download an older GHC binary and build it with that. it's possible to bootstrap it from C, though.
06:50:01 * SamB is talking about how you get GHC on a new OS/arch combination
06:50:04 <Philippa_> Cheshire: yeah, I know, I can get off my arse and write large chunks of TH
06:50:17 <Cheshire> that's not what I meant :p
06:50:20 <SamB> Cheshire: that really doesn't solve the problem
06:50:22 <SamB> oh, good
06:50:27 <ozy`> IIRC, the C bootstrapping process uses an interpreter at some stage
06:50:30 <ozy`> am I wrong?
06:50:33 <Thunder> rohan: No. on a system with a working ghc the *.hc files are generated. Then the whole tree is copied to the destination system and compiled thre.
06:50:36 <SamB> you didn't mean TH
06:50:48 <SamB> because when you use TH, you get *two* problems
06:50:50 <SamB> (at least)
06:51:04 <Philippa_> Cheshire: I also don't need it on all types, it's okay to limit it to algebraic ones
06:51:32 <rohan> Thunder: so how did a system with a working ghc come in the first place?
06:51:33 <Thunder> SamB: In this case, you run the *configure* scripts on the new architecture, copy the result to a differnent system, compile there to *.hc, copy back and finish compiling.
06:52:18 <Thunder> This process is iterated for each stage (1,2) of the compiler as well as both stages of the libraries excluding the system specific parts you have to add at your own
06:52:30 <ozy`> rohan: in the early stages of haskell development, there was only an interpreter, which was written in C, I believe
06:52:41 <Thunder> All those five steps are magically interleaved
06:53:03 <rohan> ok thanks ,i was just curious
06:53:04 <SamB> ozy`: not Miranda ?
06:53:20 <ozy`> SamB: did miranda have a compiler at the time?
06:53:25 * ozy` googles
06:53:28 <SamB> I don't know
06:54:11 <Thunder> rohan: GHC can not be compiled without an Haskell compiler. The first GHC was compiled using hbc (a Haskell compiler). hbc was compiled using Miranda compiler and the miranda compiler was initially compiled by hand.
06:54:11 <Cheshire> http://www.cs.nott.ac.uk/~txa/publ/ssgp06.pdf
06:54:13 * SamB shares one of his problems with TH: http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/E-Type.html#v%3AtvrInfo_s
06:54:29 <rohan> Thunder: umm what does "compiling by hand" mean?
06:54:54 <cizra> rohan: in asm, probably?
06:54:56 <Thunder> rohan: Writing the equvalent C code of the miranda code
06:55:04 <cizra> oh. Hm.
06:55:05 <ozy`> rohan: "(re)written in assembly"
06:55:08 <ozy`> or that
06:55:12 <SamB> rohan: it used to involve pencil and paper
06:55:12 <Thunder> rohan: That is, write two compilers.
06:55:24 <SamB> but things improved
06:55:29 <Cheshire> invariants* :p
06:55:36 <rohan> Thunder: i still don't understand how hand compiling would work
06:55:43 <Thunder> SamB: Yes, now we have at least one system with a working Haskell compiler ;-)
06:55:54 <Philippa_> most literally, "hand-compiling" is running the compiler by hand (presumably on pencil and paper)
06:56:08 <SamB> Thunder: I meant that there are now online text editors
06:56:13 <SamB> that don't even waste paper
06:56:33 <asgaroth> rohan: you just write an equivalent assembly program and let that be translated to actual machine code.
06:56:34 <SamB> Philippa: running the compiler, or performing it's function ?
06:56:37 <ozy`> rohan: if you have the input code, and you know how the compiler will transform it, you can do that in your head.
06:56:45 <Cheshire> "We are now based on a PTS" ?
06:56:49 <Thunder> rohan: The compiler follows an algroithm to translate a higher language to a lower one. This process is described in the source code of the compiler. You can do all those steps on a sheet of paper. This was done iniitially
06:56:49 <SamB> (Where by function I'm not talking about the maths concept ...)
06:56:58 <Cheshire> why is it (LHCs core) based on a PTS?
06:57:01 <rohan> ah ok, that makes sense, thanks
06:57:09 <SamB> Cheshire: why not ?
06:57:21 <Cheshire> um.........................
06:57:29 <Cheshire> SamB: I don't really have any good reason why not
06:57:31 <Stew_a> hi, i'm pretty new to haskell, and i'm trying to write some search functions. For some reason my depth first search function throws an error about infinite types a->[a] but I can't see why, can anyone help out please? http://stew.pastey.net/108564
06:57:38 <SamB> why is GHC's based on System F?
06:57:39 <Cheshire> I would like to know if there are some advantages about it though  ....
06:57:56 <Thunder> SamB: Hysterical raisons
06:58:16 <SamB> well, the reason is that JHC's was when it was forked into LHC
06:58:49 <SamB> I don't know why john used a PTS, but it seems nice enough not to be worth changing
06:58:57 <Cheshire> is there any justification about it or is this just some hackers trying to put together a program?
06:59:15 <Thunder> Stew: What does "next :: a -> [a]" ?
06:59:18 <rohan> ok thanks everyone, i'll look into haskell. bye.
06:59:27 <Cheshire> Stew_a, state is just a single a
06:59:34 <SamB> the LHC team does not need to justify it, since we didn't choose a PTS
06:59:37 <Cheshire> Stew_a, but in the type signature, you put a list of a
06:59:41 <ozy`> Stew_a: you're trying to use a list value in a place where it expects a member of the list, or vice versa
07:00:04 <Cheshire> Stew_a, actually that was not true (what I said ..)
07:00:27 <SamB> in retrospect, running s/jhc/lhc/ over the whole compiler source may not have been the best way to get sensible comments ;-)
07:00:38 <Cheshire> Stew_a, the actual reason is that you have ((next state):states rather than (next state ++ states)
07:01:04 <Cheshire> SamB: this LHC thing is endlessly confusing to me
07:01:10 <Thunder> Stew: Essential your program does:  listToMaybe . filter goal . iterate next $ state
07:01:12 <whpearson> @type (:)
07:01:14 <Stew_a> Cheshire: thats the one, thanks :-), though'd i'd already tried that but apparently not
07:01:14 <lambdabot> forall a. a -> [a] -> [a]
07:01:19 <whpearson> @type (++)
07:01:21 <lambdabot> forall a. [a] -> [a] -> [a]
07:01:23 <Cheshire> it doesn't have any goals .. it doesn't have any design ...
07:01:25 <SamB> Cheshire: anyway, the problem I'm referring to is the really really ugly type there
07:01:30 <SamB> Cheshire: goals ?
07:01:42 <SamB> and we are working on a design, honest!
07:01:50 <SamB> we've just got to figure out what we've got *now*
07:01:50 <Cheshire> I've asked people why they are working on LHC and they say "it might become fun"
07:02:03 <Cheshire> also the initial codebase (JHC) is horrendous
07:02:13 <Cheshire> I can't imagine why it's better to fork than start from scratch
07:02:20 <Thunder> Stew: If your are working over a set of states, you might use <*>
07:02:24 <Cheshire> honestly I just get the impression this project is to spite someone...
07:02:32 <SamB> it's fun to be able to break the build (of base, not the compiler itself) and claim that it is an improvement ;-P
07:02:48 <SamB> personally, I like it
07:03:01 <SamB> it's a lot easier to figure out what to do than if I started from scratch
07:03:08 <ozy`> Cheshire: I sort of got that impression too
07:03:21 <ozy`> but I have faith in the republic!
07:03:23 <Cheshire> oh yeah I am not saying it wont go anywhere, it might well
07:03:32 <SamB> I don't *think* it's to spite john. I just got fed up with him becaue he wasn't responsive enough ;-P
07:03:35 <dmead> must
07:03:35 <dmead> not
07:03:36 * ozy` pays his daily tribute to the Ministry of Safety and Happiness
07:03:38 <dmead> drink
07:03:41 <dmead> coffee
07:03:46 <SamB> or, well, actually that's not quite how it worked
07:03:50 <Cheshire> dmead, oh good ide
07:03:52 <ozy`> dmead: I thought you were gonna say "kool-aid"
07:03:52 <Cheshire> a
07:03:57 * ozy` goes to get coffee
07:04:05 <ozy`> (do they put kool-aid in the coffee?)
07:04:08 <dmead> :P
07:04:11 <SamB> I was attracted to LHC because they had actually made some changes in the past few months
07:04:13 <dmead> cocaine probably
07:04:37 <Cheshire> SamB, does it say /which/ PTS it's based on?
07:04:44 <SamB> Cheshire: yes
07:05:02 <SamB> Cheshire: somewhere!
07:05:07 <ksf> agda is way cool.
07:05:33 <SamB> Cheshire: here, in fact, but the formatting is messed up: http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/E-TypeCheck.html
07:05:39 <ksf> ...modulo excessive use of unicode symbols.
07:05:52 <SamB> so look here instead:
07:05:54 <SamB> http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/src/E-TypeCheck.html
07:06:02 <Axman6> dmead: http://www.dailymotion.com/video/x6jluj_le-cafe-oldelaf-english-subtitles_music
07:07:10 <Cheshire> so it allows functions from types to types .. can you compute zippers in LHC?
07:07:36 <SamB> Cheshire: the frontend doesn't support it, sorry
07:08:47 <dmead> Axman6, hah
07:09:12 <dmead> Axman6, ah, dude melted
07:09:16 <dmead> i don't want to melt :x
07:09:30 <SamB> on the bright side, I think I'm on the verge of getting LHC to support turning the Monomorphism Restriction both on and off
07:09:34 <Axman6> see what happens?!?!? ZOMG!!!!
07:09:39 <Axman6> shit,t oo much coffee
07:10:08 <SamB> a couple of days ago, if you left it on defaulting didn't work right
07:10:23 <Ferdirand> these guys rock, watch the one with the superheroes
07:10:30 <C-Keen> :t Functor
07:10:32 <lambdabot> Not in scope: data constructor `Functor'
07:10:35 <SamB> but if you turned it off, everything worked fine
07:10:45 <C-Keen> :t <*>
07:10:46 <lambdabot> parse error on input `<*>'
07:10:52 <C-Keen> hm..
07:11:02 <cizra> :t (<*>)
07:11:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:11:08 <cizra> :t (^_^)
07:11:09 <lambdabot> parse error on input `)'
07:11:13 <C-Keen> cizra: thanks
07:11:17 <cizra> :t (=
07:11:18 <lambdabot> parse error on input `='
07:11:22 <SamB> then I made it so that it worked when it was on, but this broke -fno-monomorphism-restriction ... so now I've added a test for it in the toplevel defaulting function ... and it seems to work.
07:11:26 <C-Keen> cizra++
07:11:36 <cizra> @karma cizra
07:11:37 <lambdabot> You have a karma of 1
07:11:39 <cizra> \o/
07:12:01 * SamB wonders what should happen if you have mutually recursive modules, one of which has NoMonomorphismRestriction and one of which doesn't
07:12:14 <SamB> (not that LHC has LANGUAGE pragma support yet)
07:12:53 <CosmicRay> arjanoosting: ping
07:14:04 <cizra> LHC? Large.. Haskell Compiler?
07:14:13 <quicksilver> SamB: doesn't sound like a problem to me.
07:14:26 <SamB> quicksilver: what doesn
07:14:27 <quicksilver> SamB: NoMonomorphismRestriction works fine as a lexical pragma.
07:14:28 <SamB> 't?
07:14:29 <Axman6> cizra: yes, it runs using haskell
07:14:41 <quicksilver> so, only those things in the file it was in, would have it turned off.
07:14:57 <SamB> quicksilver: well, the tricky bit is what happens if you have a binding group involving functions in both modules?
07:15:02 <ozy`> @karma perl
07:15:02 <lambdabot> perl has a karma of 1
07:16:45 <quicksilver> SamB: I don't see the problem, maybe I'm missing something
07:17:05 <quicksilver> you just don't enforce it on the parts which were under the NMR.
07:17:09 <quicksilver> and you do on the others
07:18:08 <SamB> quicksilver: the monomorphism restriction is enforced at the binding group level, though, as far as I can see
07:18:16 <SamB> do you know what a binding group is ?
07:20:15 <quicksilver> SamB: Yes.
07:20:22 <quicksilver> SamB: OK, that's just a quirk of LHC's implementation.
07:20:31 <quicksilver> I though you were suggesting there was a deep type-checking issue here
07:20:38 <Philippa_> mutually recursive modules give you binding groups 'outside' module scope
07:20:42 <quicksilver> that it didn't make *sense* to apply the NMR to only part of a binding group.
07:21:01 <quicksilver> I can believe ther is a implementation issue based on an assumption made in existing code.
07:21:28 <Philippa_> GHC ducks the issue by requiring full type annotations
07:26:27 <SamB> anyone good with Haddock formatting ?
07:27:06 * Philippa_ wonders where Snaffu got the second f from
07:28:18 <Snaffu> self descriptive nick :^)
07:28:59 <Philippa_> so we'll assume the first f is the adverb form? :-)
07:29:32 <Snaffu> lol ... yah you could say that
07:34:11 <angerman> wow, haskell has fewer, but more active users then python, great!
07:34:25 <Cheshire> o_o
07:34:28 <Cheshire> this Dana thing has made it to ltu .. wtf
07:35:52 <BMeph> Cheshire: ...is that bad?
07:36:13 <Cheshire> I guess it doesn't make a difference
07:36:29 <Philippa_> Cheshire: I think it's pretty appropriate. FRP as a whole is definitely LtU-worthy news, and Dana certainly seems worth mentioning /as news/
07:37:26 <Philippa_> it's definitely a change from the shift into being a forum that LtU's trying to avoid
07:38:19 <Cheshire> not so much a forum but like a .. collab. to design BitC
07:38:33 <Cheshire> (but no other languages)
07:39:40 <Philippa_> Shap's tended to pose a slightly different kind of question, to be fair
07:39:56 <Philippa_> and all the genuinely BitC-specific description etc's been off-site
07:41:37 <drhodes> given an x such that (x :: Either String PNGImage)  is (rights [x]) the only way to get at the PNGImage?
07:42:33 <cnwdup> drhodes, you can use pattern matching
07:42:44 <drhodes> ok cnwdup, thanks
07:42:50 <hackage> Uploaded to hackage: cabal-install 0.6.2
07:42:50 <hackage> Uploaded to hackage: Cabal 1.6.0.2
07:42:58 <dcoutts> @arr!
07:42:58 <lambdabot> Aye Aye Cap'n
07:43:11 <drhodes> cabal install cabal?
07:43:19 <dcoutts>   $ cabal update
07:43:19 <dcoutts>   $ cabal install Cabal cabal-install
07:43:55 <drhodes> say that five times fast
07:44:03 <dcoutts> :-)
07:44:31 <lilac> drhodes: "Either String" is a functor, applicative and monad, one of those is probably the easiest way to manipulate the PNGImage
07:50:00 <pejo> Cheshire, I think a lot of shap's question have been interesting. There are other posters that are less well prepared I think.
07:51:39 <Philippa_> he's also fed back an amount of useful community commentary
07:55:44 <drhodes> lilac: I'm not there yet, but thanks, it's ruminating.
08:01:02 <sauf_> hi,  can someone help me fasten my program :
08:01:02 <lambdabot> sauf_: You have 1 new message. '/msg lambdabot @messages' to read it.
08:01:04 <sauf_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1538
08:01:21 <sauf_> for the moment, I get  :
08:01:29 <sauf_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1545
08:03:36 <lilac> drhodes: well, if you have an "Either String PNGImage" and a function for processing the image, f :: "PNGImage -> YourResult"...
08:03:58 <quicksilver> sauf_: you might try -fvia-C -optc-O3 as an alternative
08:04:04 <lilac> drhodes: and you want to call your function if x is a PNGImage and just return the error otherwise...
08:04:12 <lilac> drhodes: then you want 'fmap f x'
08:04:14 <quicksilver> sauf_: GHC doesn't always produce as good floating point code as GCC
08:04:52 <sauf_> lilac: thanks for the answer. Maybe Reactive could me too ?
08:05:29 <sauf_> quicksilver: thx, I will try soon
08:06:25 <lilac> sauf_: depends what you're doing. but there is (was?) a GHC RTS bug which made reactive not quite able to be as good as it might be, so beware...
08:06:50 <sauf_> quicksilver: do you think I should try unboxed things ?
08:07:10 <lilac> drhodes: f :: PNGImage -> YourResult, x :: Either String PNGImage => fmap f x :: Either String YourResult
08:07:19 <sauf_> lilac: I'm trying to re-write haskore !
08:08:01 <sauf_> lilac: ok, I will be cautious !
08:08:16 <quicksilver> sauf_: you should hope that GHC unboxes enough for you ;)
08:08:25 <drhodes> lilac: AHAH!
08:08:27 <quicksilver> using unboxed types is not normally recommended and it's definitely fiddly.
08:10:45 <hlynur> exit
08:20:31 <sauf_> quicksilver: nearly the same with -fvia-C -optc-O3 . It's strange that GHC needs more than 2 seconds to process 2*4*44100 samples which is not a huge number
08:21:20 <quicksilver> are you sure some of that isn't fixed startup costs?
08:21:24 <quicksilver> it does sound quite high.
08:22:29 <sauf_> quicksilver: sorry, what do you mean ?
08:24:03 <jeltsch> Hello, can anyone tell me how constructors of associated data types are exported?
08:24:19 <sauf_> quicksilver: ALUT things ?
08:24:27 <jeltsch> class C a where { data D a :: * }
08:24:46 <jeltsch> instance C Int where { data D Int = DInt }
08:24:58 <jeltsch> How is DInt stated in an export list?
08:25:25 <conal> jeltsch: i've been wondering the same.
08:25:25 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:25:38 <Saizan_> D(DInt) doesn't work, i guess?
08:26:17 <jeltsch> Saizan: No, this only works for non-associated data families.
08:27:23 <Nafai> @users
08:27:23 <lambdabot> Maximum users seen in #haskell: 665, currently: 623 (93.7%), active: 13 (2.1%)
08:27:26 <Nafai> Wow
08:29:52 <SamB> does anyone know a nicer way to mark this up: http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/E-TypeCheck.html ?
08:30:07 <SamB> using Haddock markup, if that isn't obvious ?
08:31:49 <quicksilver> sauf_: just generally of the app as a whole.
08:32:32 <sauf_> quicksilver: you're right : all the time is spent on the allocation 	[ptrR,ptrL] <- sequence [newArray c |c <- collec]    I will think it again.  Thanks  !
08:33:24 <sauf_> quicksilver: (by the way, have you got any idea ?)
08:34:10 <quicksilver> sauf_: not specifically, no.
08:34:24 <quicksilver> your profile suggests the hard work is being done in the calculations.
08:34:28 <quicksilver> which is the right place for it.
08:35:37 <rwbarton> jeltsch: I had a hard time working this out.  I think it's just D(..)
08:35:47 <sauf_> quicksilver: yes but thanks to you, I've just added some print to see that    [ptrR,ptrL] <- sequence [newArray c |c <- collec]  was the most time-consummer
08:36:17 <conal> lilac: thanks for the typo alerts!
08:36:47 <rwbarton> jeltsch: hmm, if you wanted only DInt, I'd have thought D(DInt) would work
08:37:19 <sauf_> quicksilver:   (calculating the samples is actually nearly intantaneous which can't be seen on the profile, or I don't know how to read it)
08:37:37 <jeltsch> Saizan: Sorry, I was wrong. D (DInt) seems to work. It just gave me a warning, since D was already exported and I mistook this warning for an error.
08:37:50 <lilac> conal: no problem :)
08:37:51 <rwbarton> jeltsch: yes, that warning is quite annoying
08:44:51 <lilac> conal: 9.1  : "5 * sqrt f, which can mean \x -> sqrt (f x)" -- surely you mean "\x -> 5 * sqrt (f x)" ?
08:46:02 <conal> lilac: yeah.  thanks. :)
08:46:09 <lilac> (in any case, that's a little dangerous since "(\x -> 5 x) == const 5")
08:47:02 <conal> lilac: dangerous?
08:47:48 <lilac> only in the sense that "2 x + 1" might not do what people expect ;-)
08:48:17 <conal> oh, yeah.
08:48:50 <lilac> i wonder whether it'd be nice to have liftA0 as a synonym for 'pure' and liftA1 as a synonym for 'fmap'?
08:49:06 <conal> yeah.
08:49:06 <asgaroth> @type liftA
08:49:07 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
08:49:10 <mauke> +1
08:55:27 <Muzzleflash> Hi all.... I'm in the process of learning Haskell with Real World Haskell.  But I can't seem to understand the sample file "ch04/InteractWith.hs"... For example, what is the purpose of this: "main = mainWith myFunction   where mainWith function"??? And why can't you just remove it and write myFunction down in the line " [input,output] -> interactWith function input output" instead of function?
08:59:00 <saml> where is InteractWith.hs?
08:59:35 <joga> http://book.realworldhaskell.org/read/functional-programming.html
09:00:18 <doserj> Muzzleflash: don't you understand how it works, or don't you understand why it is written this way?
09:00:44 <doserj> Muzzleflash: of course it could have been written differently.
09:01:36 <saml> Muzzleflash, i think that way you can pass your function to main
09:02:08 <rwbarton> Muzzleflash: I think it's written this way to emphasize that you could replace myFunction with another function to write a different program.
09:02:20 <saml> int main() {  callUserMainFunction(userFunction); return 0; }
09:02:36 <rwbarton> Muzzleflash: myFunction is right there on the "main = ..." line rather than being buried within a bunch of code
09:03:44 <Muzzleflash> rwbarton: Yes, I can figure that out.. But I don't understand why you cannot replace function longer down with myFunction directly thereby removing all the code before the do "statement" (yes I know statements don't really exists in haskell)
09:05:14 <doserj> Muzzleflash: who says that you cannot?
09:05:28 <rwbarton> Muzzleflash: Of course you could.
09:05:43 <rwbarton> Muzzleflash: But there's also lots of code in that definition that you probably shouldn't change.
09:06:24 <Muzzleflash> doserj: I've tried. It wouldn't compile, something about "Could not infer (type t)" or something like that.. I'll try and do it again
09:08:38 <Muzzleflash> I get parse error on the definition of myFunction.. Line: "myFunction = fixLines"
09:09:45 <jyaan> Anybody know what's going on? I just started reading Haskell for C programmers, but putting anything from the examples gives an error
09:09:47 <rwbarton> Muzzleflash: Can you paste your code?  http://hpaste.org/
09:09:56 <jyaan> IN ghci
09:10:03 <jyaan> Um, code like x=5
09:10:10 <mauke> jyaan: yes, that's not valid in ghci
09:10:28 <jyaan> -.-
09:10:37 <Muzzleflash> rwbarton: Actually I've just corrected it. It was the indenting. With the "where" clause removed, I've had to move the line back..
09:10:44 <rwbarton> Muzzleflash: ah yes
09:11:12 <jyaan> Do I need 'let' or something?
09:11:28 <rwbarton> jyaan: In this case you can write  let x = 5
09:11:28 <jyaan> I've never used functional languages before
09:11:37 <doserj> jyaan: write the code in a file, and load that file. Or use let for simple things
09:11:44 <mauke> this is unrelated to 'functional' or 'language'
09:11:52 <mauke> it's an implementation issue in ghci
09:12:03 <jyaan> Oh
09:12:23 <jyaan> So hugs might be a better idea for interpreter?
09:12:24 <Muzzleflash> rwbarton: But I still don't understand how the "where" clause works in this particular example. Yesterday I was so confused I actually thought withMain was a keyword, doh. I've read the the where clause either introduce a new class or module or it binds a local variable. However, I can't seem to get it to fit either description
09:12:39 <rwbarton> Muzzleflash: where can bind several variables
09:12:41 <mauke> jyaan: hugs can't even do 'let x = 5'
09:12:50 <jyaan> eep
09:13:01 <rwbarton> Muzzleflash: if their names are aligned vertically
09:13:24 <mauke> jyaan: seriously, just put your code in a file
09:13:44 <Muzzleflash> rwbarton: So myFunction is function?
09:14:16 <rwbarton> Muzzleflash: Oh, you can also write function bindings in a where clause.
09:14:47 <rwbarton> Muzzleflash: So function is the name of the argument of mainWith, and it gets passed myFunction by main.
09:16:38 <rwbarton> Muzzleflash: In this case it would make no difference to take the definition of mainWith and move it to the top level.
09:17:14 <Muzzleflash> rwbarton: This is what It appears to me: I replace myFunction with whatever it is for clarity, then I get: mainWith fixLines where mainWith interactWith function input output  ... Assuming valid input
09:18:13 <saml> > product [1..100]
09:18:14 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
09:18:19 <sm> morning all
09:18:24 <saml> hi sm
09:19:56 <sm> hmm, clients have slowed up, so today I get to look for a new gig
09:20:21 <sm> and I'm thinking, let's make it a haskell gig!
09:20:48 <Vq^> good choice :)
09:20:52 <saml> or a heavy metal gig
09:21:06 <sm> or both.. nice
09:21:11 <sm> has anyone got tips on where to look, who to talk to ?
09:21:26 * shepheb just pictured a combination of a lambda and \m/
09:21:30 <Muzzleflash> rwbarton: I think I've got it now.
09:22:57 <Cheshire> can anyone tell me some examples of haskell programs/codes that use HOAS?
09:23:26 <mathijs> I'm learning profiling and parallelization (chapters 24 and 25 RWH), but I can't seem to figure out what I'm doing wrong. Can someone please have a look at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1474
09:24:48 <rwbarton> mathijs: (...+1)+1 thunk buildup
09:24:58 <rwbarton> perhaps
09:25:03 <rwbarton> are you compiling with -O2?
09:25:09 <mathijs> rwbarton: yes
09:25:44 <mathijs> rwbarton: 1+1+1 might be the problem, I'll make that stricter
09:25:53 <rwbarton> hmm, well it ought to catch the strictness for you I'd think, but...
09:26:17 <mathijs> rwbarton: maybe not if I compile with profiling stuff?
09:26:30 <quicksilver> mathijs: the high memory usage is expected, isn't it?
09:26:41 <quicksilver> parMap keeps the whole chunk alive at once
09:26:53 <quicksilver> while a sequential process allows it to be gc'ed as it goes.
09:27:13 <quicksilver> sorry, I said that wrong.
09:27:18 <quicksilver> parMap keeps *all* the chunks alive
09:27:21 <quicksilver> I should have said.
09:27:38 <mathijs> quicksilver: didn't know that
09:27:47 <quicksilver> it's not a magic trick
09:27:56 <quicksilver> it's a consequence of what your programs asks for.
09:28:05 <quicksilver> You have a list of 4 million elts, divided into 10 chunks of 400K
09:28:20 <quicksilver> your sequential version processes it sequentially - so it can be GCed as it goes along.
09:28:30 <quicksilver> your parallel version tries to work in parallel on those 10 chunks
09:28:35 <quicksilver> so, of course, it makes them all live
09:28:38 <quicksilver> it has to, to work on them.
09:29:37 <mathijs> quicksilver: but why are the chunks evaluated in full? I mean if I have 4 threads, I would expect 4 times the memory usage. it seems it constructs the full chunk before processing it
09:30:01 <mathijs> quicksilver: can't it process them lazily?
09:30:01 <Muzzleflash> rwbarton: Yes I get it know, but this kind of style is going to take me some time to get used to. Thank you for your assistance :)
09:30:23 <quicksilver> mathijs: the 400,001 element of the list doesn't exist until it has made the first 400,000 exist.
09:30:31 <quicksilver> mathijs: lists are a recursive data structure.
09:30:50 <quicksilver> your 10th chunk wants a reference to the 3,600,001'th element to start its work
09:31:02 <quicksilver> it has to calculate the previous 3,600,000 elts to get there
09:31:09 <quicksilver> meanwhile your 1st chunk is still working on the 1st element
09:31:19 <quicksilver> so the whole list (except the last little bit) is live at once.
09:32:03 <mathijs> quicksilver: got it... I think.  But why is it starting on the 10th chunk before the first few are completed?
09:32:23 <quicksilver> because you asked it to!
09:32:27 <Olathe> It breaks the list into chunks, not interleaved strips.
09:32:33 <quicksilver> parMap - run these calculations in parallel.
09:32:38 <rwbarton> mathijs: if it didn't, it would be serial.
09:32:49 <quicksilver> it doesn't necessarily work on the 10th, to be fair
09:32:56 <quicksilver> parMap doesn't promise to parallelise completely
09:33:00 <mathijs> quicksilver: yeah but I read parallel meant "only fork when a core is free"
09:33:05 <quicksilver> but you can be sure it's working on some other chunks than the first.
09:33:09 <rwbarton> mathijs: You can use parBuffer to get more control over when new tasks are started
09:33:56 <Olathe> Is there a way to give [1, 5..] to the first thread, [2, 6..] to the second, and so on ?
09:34:06 <quicksilver> mathijs: it forks (sparks) rather eagerly and then executes sparks if/when there are free cores
09:34:09 <mathijs> quicksilver, rwbarton: ok maybe parBuffer might help, but the core of the problem here is because of chunk right?
09:34:17 <quicksilver> Olathe: sure, there are all sorts of other strategies in C.P.Strategies
09:34:21 <Olathe> Ahh :)
09:34:21 <quicksilver> Olathe: interleaving is one of them
09:34:23 <quicksilver> IIRC>
09:36:25 <mathijs> what would be a better way to 'feed' the numbers to each thread? Like you mentioned, if the 10th chunk starts, if has to get the prepending 9 chunks to memory first.
09:36:39 <quicksilver> smaller chunks perhaps
09:36:49 <quicksilver> have a look at the other combinators in strategies
09:37:01 <rwbarton> mathijs: you could create a list of "ranges" [(1,400000),(400001,800000),...] and parMap over that
09:37:23 <rwbarton> mathijs: do the enumFromTo inside the task that's running in parallel
09:38:10 <HugoDaniel> anyone here uses freebsd ?
09:38:31 <mathijs> rwbarton: that sounds better. there is no reason for the original list to be 1 piece, each thread just needs to know where to start and where to end.
09:38:34 <HugoDaniel> when is ghc going to be updated in ports ?
09:39:25 * dcoutts_ recommends everyone does $ cabal update && cabal install Cabal cabal-install
09:39:27 <mathijs> quicksilver, rwbarton: thanks for helping... I'm sure I can fix it now :)
09:39:47 <Zao> dcoutts_: Anything broken or insecure?
09:40:06 <dcoutts_> Zao: no, but many bug fixes and improvements
09:40:13 <dcoutts_> new releases
09:49:04 <wli> let zero = Algebraic (0, []) ; x = Algebraic (2,[1,1]) ; y = Algebraic (2,[1,-1]) in flip runReader (Algebraic (3,[1,0,1])) $ sequence [mul x x, mul x y, mul y y] >>= foldM add zero :: Algebraic Integer
09:49:32 <wli> That would be a bit more concise if I figured out how to do division over algebraic integers.
09:49:36 <reqamst> > 1 ++ 1
09:49:37 <lambdabot>       No instance for (Num [a])
09:49:37 <lambdabot>        arising from the literal `1' at <inter...
09:49:53 <wli> This is a different matter entirely.
09:50:37 <wli> Here :t add == (Num t, MonadReader (Algebraic t) m) => Algebraic t -> Algebraic t -> m (Algebraic t)
09:50:46 <wli> mul has the same type.
09:51:52 <Cheshire> what is Algebraic?
09:52:18 <wli> newtype Algebraic t = Algebraic (Int, [t])
09:52:49 <Cale> wli: Well, division for algebraic integers is tricky, because you need to consider divisibility...
09:52:52 <Cheshire> is there oa function from Algebraic t -> t?
09:53:09 <Cale> (at least, if it's the sort of algebraic integer I'm thinking of)
09:53:40 <wli> Cale: I'd introduce MonadError constraints on the operations' monad types.
09:54:12 <wli> Cheshire: You could make one; it's not opaque. It wouldn't be very meaningful.
09:54:51 <Cale> Or I suppose you could move to using the field of algebraic numbers, and have a test to see if something is indeed an algebraic integer.
09:55:14 <wli> Cale: If divisibility should fail, or division by a zero divisor occur, throwError.
09:55:47 <Cale> Er, it's an integral domain at least.
09:55:52 <wli> Cale: Well, the way it's done now there isn't much of a distinction yet.
09:56:59 <wli> Cale: There's no way to enforce the conditions on the polynomial to prevent zero divisors in Z[x]/(p(x))
09:57:15 <wli> So if the algorithm trips over a zero divisor, throwError.
09:57:17 <Cale> Oh, you're considering quotients.
09:57:21 <Cale> Okay, sure.
09:57:31 <wli> Not really quotients per se.
09:57:34 <CTA> Heyy :)
09:57:52 <wli> Heck, there aren't even checks for p(x) being monic.
09:57:55 <Cale> er...
09:58:11 <wli> Well, quotient rings vs. rings of quotients.
09:58:24 <rwbarton> wli: Algebraic represents an algebraic integer by its minimal polynomial?
09:58:36 <wli> rwbarton: Yeah.
09:58:36 <Cale> CTA: hello
09:59:25 <wli> rwbarton: Well, the ring by its minimal polynomial. The elements are just polynomials mod the minimal polynomial.
09:59:36 <rwbarton> Oh, I see
10:00:05 <wli> The code is on the net.
10:00:41 <wli> http://pastebin.com/m4a55fec <-- algebraic number module
10:02:01 <CTA> how do i : toLower?
10:02:19 <wli> Division stumps me at the moment.
10:03:47 <wli> If it's a field extension one kind of linear algebra is required; otherwise, if it's an extension of an integral domain, another is required.
10:03:53 <dons> ?yow
10:03:53 <lambdabot> I'm having a RELIGIOUS EXPERIENCE ... and I don't take any DRUGS
10:04:33 <wli> In both cases I have a lot of trouble writing the linear algebra required.
10:04:35 <CTA> I'm getting the hang of functions (:
10:06:01 <tero-> hi. I'm having some trouble blitting alpha blended textures with hssdl and hopengl
10:06:01 <dcoutts_> g'morning dons
10:06:08 <tero-> rings any bells?
10:06:26 <wli> I'm guessing fraction-free Gauss-Jordan would cut it, but I have trouble with that, too.
10:06:56 <Cale> CTA: toLower is a function in Data.Char
10:06:59 <Cale> :t toLower
10:07:00 <lambdabot> Char -> Char
10:07:15 <Cale> CTA: If you want to apply it to a whole string, you can use map
10:07:19 <Cale> :t map toLower
10:07:19 <lambdabot> [Char] -> [Char]
10:08:13 <CTA> talk x =
10:08:14 <CTA>   case x of
10:08:14 <CTA>     1 -> "You entered 1 as a parameter!"
10:08:14 <CTA> 	2 -> "You entered 2 as a parameter!"
10:08:23 <CTA> why do i get parse error for -> ?
10:08:29 <tero-> neither the sprite demo works (http://www.haskell.org/~pairwise/HOpenGL/HOpenGL.html)
10:08:30 <rwbarton> CTA: don't use tabs
10:08:35 <Botje> CTA: you're mixing spaces and tabs
10:08:40 <Botje> pick one kind and stick to it
10:08:45 <rwbarton> pick spaces
10:08:46 <rwbarton> :)
10:08:46 <CTA> i'm not
10:08:52 <Botje> yes you are :)
10:08:53 <CTA> i'm indenting by 2 spaces
10:08:55 <Cale> CTA: The cases have to line up.
10:09:03 <rwbarton> Yes, my IRC client shows that you pasted a tab character :)
10:09:06 <Botje> i see a tab character in front of your 2
10:09:10 <Nafai> Yeah
10:09:25 <cizra> Haskell doesn't like tabs.
10:09:26 <Cale> CTA: Which editor are you using?
10:09:39 <mathijs> here comes....
10:09:53 <Cale> It's possible to configure most text editors to convert tabs to spaces automatically.
10:10:01 <Cale> In vim, it's :set expandtab
10:10:16 <CTA> notepad++
10:10:18 <CTA> example.hs:11:6: parse error on input `->'
10:10:18 <CTA> Failed, modules loaded: none.
10:10:19 <rwbarton> Probably not vim, given the pasted tab
10:10:32 <rwbarton> Wait, I don't know what I'm talking about, never mind.
10:10:39 <Cale> hehe
10:10:47 <mathijs> CTA: is that even better than notepad itself?
10:11:04 <ac> theoretical question: if I were to write an online shopping cart system in Haskell, which web framework/libraries would be recommended?
10:11:10 * wli says that tabs are 8-columns worth, and properly-formed whitespace matches the regex ('\t')*(' ')* where the suffix of spaces is of length strictly less than 8, but other conventions are vocally espoused on this IRC channel.
10:11:11 <true\false> mathijs: Yes.. It keeps indentation.
10:11:12 <CTA> yes
10:11:31 <true\false> So much for C# then CTA? :)
10:12:03 <CTA> haha lol..
10:12:09 <Cale> wli: While that works, it's difficult to maintain.
10:12:12 <CTA> I got a C# book and all lol, just hmm i dunno
10:12:27 <true\false> C# is better for British education than Haskell really
10:12:31 <wli> Others' mileage may vary.
10:12:31 <CTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1546#a1546
10:12:46 <CTA> idk, I might go back to C# just seeing what there is out there.. :)
10:12:49 <Cale> wli: It's hard to be sure when editing code (unless you use visible tabs) that you never have an accidental space in that initial group of tabs.
10:12:58 * wli guesses he could write a tab normalizer.
10:13:15 <CTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1546#a1546 how can I fix?
10:13:23 <Cale> wli: It's easiest just to stick with spaces, because if you're going to always treat the tabs as 8 spaces anyway, it's not like the extra disk usage is going to kill you.
10:13:26 <true\false> CTA: You were just told, twice :s
10:13:28 <wli> Cale: indent(1) -like utilities, etc.
10:13:29 <ac> (there seem to be several on Hackage now)
10:13:38 <sjanssen> wli: maintaining that convention is more trouble than it is worth in Haskell
10:13:46 <CTA> my cases line up?
10:14:11 <wli> Cale: I usually find that it saves keystrokes when dealing with alignment columns etc.
10:14:33 <Cale> wli: You can often also configure your editor to treat multiple spaces as if they were a tab.
10:14:37 <CTA> iv lined them up and all sorts, i still get parse error '->'
10:14:42 <rwbarton> CTA: no you haven't
10:14:46 <rwbarton> CTA: don't use tabs :P
10:14:55 <Cale> CTA: They don't line up because there is a tab character before the 2
10:14:57 <rwbarton> CTA: (or, set your editor to display tabs as 8 spaces)
10:15:10 <wli> Cale: yes, to enforce the convention I described.
10:15:11 <CTA> i don't use the tab button
10:15:16 <CTA> i indent via 2 spaces
10:15:27 <Cale> CTA: But your editor has inserted a tab character somehow.
10:15:30 <rwbarton> CTA: look at your paste! it's not lined up!
10:15:55 <Cale> CTA: Look for an option in the settings to replace all tabs with spaces.
10:15:57 <CTA> I know on the paste it's not but in the editor it is!
10:16:01 <wli> Tabs aren't 8 spaces per se; they seek horizontally to the next tabstop.
10:16:13 <rwbarton> CTA: Haskell doesn't care what your editor thinks your code looks like.
10:16:30 <Cale> CTA: That's because your editor is treating tabs as aligning to the nearest 2 or perhaps 4 space boundary rather than 8 spaces which is what the Haskell compiler sees.
10:16:53 <Cale> CTA: It's easiest to simply configure your editor to ensure that no tab characters are stored into the file.
10:17:47 <Cale> (I don't know how to do it specifically for Notepad++, but any decent editor will have such an option)
10:17:49 <mathijs> CTA: emacs has whitespace-mode which can automatically remove tabs and trailing spaces.
10:17:55 <rwbarton> And yeah, vim is evil because when you copy and paste out of vim running in a terminal, it changes tabs into spaces.
10:18:03 <Cale> rwbarton: Really?
10:18:07 <wli> The standard tabstop config is one tabstop every 8 columns.
10:18:22 <rwbarton> More accurately, it draws spaces to your terminal and not tabs.
10:18:25 <CTA> ill download that when i come back in
10:18:26 <CTA> im off
10:18:32 <rwbarton> Probably because it wants to control tab stops itself?
10:18:37 <Cale> I think the tab character should just be abolished :)
10:19:01 <Cale> It doesn't do a good job of what it's supposed to do.
10:19:40 <rwbarton> That's why you can always tell vim users are the people who have alignment issues and then when they paste their code, there are no tabs.
10:19:42 <Cale> and I think anything which would be a good job is probably too complicated for inclusion in a character set.
10:19:44 <wli> No, the vim cut/paste affair is because the tab isn't represented directly on the terminal. The way it's represented there is by filling the tty/pty with blank characters until the next tabstop.
10:19:44 <rwbarton> But this paste has a tab.
10:19:57 <rwbarton> But the terminal *can* represent a tab.  At least, mine can.
10:20:03 <rwbarton> vim just chooses to send spaces instead.
10:20:16 <Cale> rwbarton: I use vim and cut/paste doesn't include tabs, as far as I can see..
10:20:19 <wli> It's not sending spaces.
10:20:28 <rwbarton> If I cat a file with a tab and then paste it somewhere, there is a tab.
10:20:32 <wli> The tab character is not directly interpreted by most terminal types.
10:20:38 <ac> I guess my question is not appropriate for the current topic of whitespace :-P
10:20:49 <rwbarton> wli: Well, vim and terminal versions may differ.  This is the behavior on my system.
10:20:54 <wli> You'll get some representation like ^I
10:21:13 <Cale> ac: Oh, I think it's just that perhaps the people here don't feel qualified to talk about web libraries.
10:21:34 <Cale> ac: Personally I haven't done a lot of web stuff in Haskell. I can point you at the existing projects, but I don't have any preference.
10:21:45 <wli> It's also unclear if ncurses knows how to program tabstops, or if vim knows how to use ncurses to do so if it does.
10:22:04 <ac> I was hoping for biased opinions :)
10:22:40 <rwbarton> Cale: right, whereas if you used emacs (even emacs -nw) you could put a tab in a buffer and copy and paste it to another window as a tab.
10:22:48 <mathijs> ac: HAppStack
10:22:50 <rwbarton> Or, I can, at least. :)
10:22:55 <Cale> rwbarton: ah, I never have any tab characters, so I wouldn't know.
10:23:06 <rwbarton> Cale: Yes, but the people with indentation problems do. :)
10:23:08 <Cale> rwbarton: and I don't miss them when they're destroyed anyway :)
10:23:09 <Cale> ah
10:23:19 <Cale> Let me try...
10:23:20 <wli> You basically would have to save the tabstop settings on the tty/pty, set things so the editor's tabstops work, and then use the tabstops to seek. But then there's the question of whether they erase and/or fill with blanks when they seek.
10:23:21 <inimino> ac: if you're genuinely interested in writing a shopping cart, I doubt much of the current Haskell web landscape will appeal to you
10:23:26 * Cale turns off expandtab...
10:24:03 <rwbarton> Cale: And so vim contributes to their confusion because copying and pasting out of their buffer isn't the same as saving the buffer.
10:24:10 <wli> I cat and cut and paste to expand tabs for transmission to the tab-unfriendly world.
10:24:20 <ac> inimino: why's that?
10:24:21 <true\false> Any suggestions for a quick little project to do between LYAH and RWH?
10:24:27 <Cheshire> why don't you not insert tabs in the first place then
10:24:40 <wli> They're convenient to me.
10:25:27 <rwbarton> wli: yes, if I use xterm, it works as you describe.  The terminal converts tabs to spaces and then they can be selected individually
10:26:11 <wli> It doesn't seem difficult to work locally with tabs the way I want them, then convert to transmit to where the convention differs. I don't seem to have the issues described as characteristic of tab/vim users.
10:26:56 <inimino> ac: I just don't expect there to me much overlap between the sets of people interested in shopping carts and of people willing to tolerate low-level details of the current crop of Haskell Web development frameworks
10:27:17 <Cale> rwbarton: actually, I'm not seeing that behaviour
10:27:48 <Cale> rwbarton: I turned off expandtab and smarttab, wrote some tabs, and then copied and pasted (via the primary) into gEdit, and it preserved the tabs.
10:28:38 <Cale> Perhaps it's also dependent on the terminal being used?
10:28:55 <rwbarton> Cale: Could be, or vim version
10:28:58 <wli> The tty/pty is a 2D array of character cells, so there is some question of what the tty/pty does with tabs. Seeking to alignment columns is not representible as a character, '\t' or otherwise. It's a cursor motion.
10:28:59 <ac> inimino: honestly I don't think I'm genuinely interested, just a little curious, as I'm working on deploying such a system right now. I'll probably use OFBiz
10:29:12 <Cale> For what it's worth, I'm using gnome-terminal and vim 7.1
10:30:34 <rwbarton> Cale: huh, weird.  Can you select individual spaces of the tab character with your mouse?
10:30:40 <Cale> rwbarton: no
10:31:01 <inimino> vim has X extensions that handle interaction with the clipboard
10:31:27 <rwbarton> inimino: even if it's running in a terminal?
10:31:36 <inimino> if the terminal emulator supports it
10:31:46 <inimino> which the Gnome one does, as well as xterm
10:31:55 <Cale> rwbarton: When you select some characters, does the mode change to -- (insert) VISUAL -- ?
10:32:07 <Cale> (or VISUAL)
10:32:20 <rwbarton> Cale: no, it doesn't change at all
10:32:33 <rwbarton> I bet you have the vim equivalent of xterm-mouse-mode in emacs turned on?
10:32:36 <inimino> then your vim or your terminal doesn't support that
10:33:01 <Cale> rwbarton: Yes...
10:33:02 <inimino> it's on by default when compiled in IIRC, but yeah
10:33:02 <Cale> set ttymouse=xterm2
10:33:02 <Cale> set mouse=a
10:33:31 <rwbarton> Cale: Ah, E538: No mouse support: mouse=a
10:33:39 <rwbarton> OK, well that explains everything
10:34:40 <rwbarton> So if you turn that off, I guess you'll see the behavior I did
10:34:45 <Cale> yeah
10:34:52 <Cale> Otherwise, I think there's no way to copy and paste a tab character from the terminal...
10:35:05 <Cale> Well, I'm not sure...
10:35:15 <inimino> you can, I think
10:35:23 <rwbarton> Depends on the terminal.  I can in urxvt but not in xterm.
10:35:51 <inimino> u
10:35:56 <inimino> oops
10:36:20 <inimino> yeah, I can in urxvt as well
10:36:24 <Cale> okay, you can in gnome-terminal, if the tab was written directly. It's probably just that vim wants more control over how tabs are displayed, so it can't just directly write tab characters to the terminal.
10:36:36 <rwbarton> exactly
10:36:54 <Cale> But the same would presumably happen with any editor.
10:37:20 <rwbarton> Well, maybe emacs is being clever and using the underlying tabs in the case that the tab stop is 8.
10:39:08 --- mode: Cale set -o Cale
10:39:20 <Cale> (just realised I still had ops :P)
10:39:37 <Cale> That sort of cleverness would certainly explain it...
10:39:42 <sbahra> Power tripper
10:42:47 <rwbarton> Cale: Oh, actually, emacs in a terminal does the same thing, once you refresh the screen.
10:42:51 <hackage> Uploaded to hackage: haskeline 0.6.1.3
10:43:04 <Cale> rwbarton: Interesting :)
10:43:18 <rwbarton> Cale: Seems pretty broken to me :P
10:43:35 <Cale> In other news, we desperately need a modern terminal architecture.
10:43:49 <inimino> hear, hear
10:48:57 <redditbot> The strict danger of switching from pure to monadic Template Haskell
10:48:57 <redditbot> Cabal-1.6.0.2 and cabal-install-0.6.2
10:51:33 <dcoutts_> dons: ta :-)
10:52:01 <dons> :)
10:52:26 <pumpkin> dons: did my patch arrive? it's my first time using darcs send to actually email rather than using -o and emailing it myself
10:52:35 <dons> yep. got it.
10:52:45 <pumpkin> yay, I can trust darcs :D
10:56:43 * BMeph giggled at the thought of a "pumpkin patch" travelling over the Internet
10:56:54 <pumpkin> http://pumpkinpat.ch ;)
10:57:20 <pumpkin> I've pre-empted you!
10:57:26 * pumpkin cackles evilly
10:59:12 <BMeph> pumpkin: That's almost as good as dot@dotat.at :)
10:59:31 * Twey laughs at the Zibri tales.
11:01:22 <ksf> Could not deduce (Functor (IterateeGM Word8 m)) from the context (Monad m) arising from a use of `fmap'
11:01:29 <ksf> ...sometimes, I just hate oleg.
11:01:42 <pumpkin> Twey: you know of zibri?
11:02:01 <Twey> Who doesn't?  :-P
11:03:24 <tero-> could somebody test if the sprite transparency works in the tutorial's example? http://www.haskell.org/~pairwise/HOpenGL/SpritingDemo.tar.gz
11:03:50 <tero-> with ghc 6.8.2 & co. it doesn't
11:03:55 <pumpkin> Twey: lol
11:04:02 <pumpkin> Twey: makes me kinda sad :P
11:08:19 <Cale> ksf: It looks like switching to liftM would solve the problem there.
11:08:40 <Cale> It's because Monad is stupidly not a subclass of Functor.
11:09:04 <Cale> well... I'm assuming a bit about what the instances for IterateeGM look like :)
11:09:26 <ksf> it's also because oleg's too transcended to bother about elegance.
11:10:30 <dons> :)
11:10:35 <ksf> in some sense, his code looks like binary code, no matter which language it happens to be in.
11:11:46 <ksf> mov eax, %magic, jmp %incantation
11:12:19 <Botje> Cale: ah, so my always using liftM in monad context isn't always superfluous, yay!
11:12:55 <ksf> if we had a sane hierarchy, we could write (.)!
11:13:15 <Botje> that would be both nice and scary at the same time
11:13:26 <Botje> lines . getContents ... *shiver*
11:13:36 <ksf> well, you can use map, if you prefer.
11:13:53 <Cale> Botje: It basically only matters if there's a missing instance.
11:13:59 <monochrom> &#73;&#32;&#100;&#105;&#115;&#97;&#103;&#114;&#101;&#101;
11:15:18 <Botje> :)
11:16:51 <pumpkin> would parallel builds (make -jN style) require changing cabal-install, or the general cabal framework?
11:17:09 <dcoutts_> pumpkin: the general cabal framework
11:17:25 <dcoutts_> though you could build multiple packages in parallel with changes just in cabal-install
11:17:35 <dcoutts_> that's much less of an advantage however
11:17:50 <pumpkin> would it be a major refactoring? how daunting of a project is it?
11:17:58 <arshad> any one wana chat me in private
11:18:05 <pumpkin> arshad: probably not
11:18:22 <arshad> y nt ?
11:18:38 <pumpkin> arshad: if it's a haskell question, it'll probably be beneficial to have it in public
11:18:44 <arshad> m i a ghost?
11:18:54 <pumpkin> if it isn't, then people in #haskell might not to talk about it :)
11:19:14 <pumpkin> *want
11:20:11 <arshad> there all people chat in private
11:20:15 <dcoutts_> pumpkin: it's a major undertaking, yes. Though not because of the parallelism, but the changes needed to use a dependency graph.
11:20:30 <pumpkin> dcoutts_: ah, ok
11:20:59 <arshad> where 's from u belong?
11:21:25 <monochrom> Technically private chat is equivalent to channel chat. Look at the IRC protocol commands, they're both PRIV. :)
11:21:54 <pumpkin> arshad: maybe try #haskell-blah :)
11:22:02 <lispy> monochrom: yeah, that surprised me
11:22:15 <arshad> ok
11:22:25 <Philippa_> monochrom: in fact, one could argue that chans are conceptually echo bots with additional privileged commands via the protocol
11:22:41 <pumpkin> IRC theory!
11:23:05 <monochrom> Channel chat is private chat with 600 people at the same time!
11:23:06 <Botje> theory of trolls!
11:23:41 * lispy waits for the philosophical debate of the meaning of "private"
11:23:55 * pumpkin points down
11:28:01 <lispy> I wonder.  Was there a specific paper published when Haskeller's decided that "forall" was a good way to implement "exsits?"
11:28:13 <lispy> I know the GHC manual talks about it, but any other papers?
11:30:05 <monochrom> avoiding a new keyword was the only consideration, really.
11:30:42 <lispy> monochrom: That's pretty reasonable, but I was hoping to find the equivalence talked about in a paper.  I grok it, but something citable :)
11:30:55 <lispy> The GHC manual doesn't seem to cite anything
11:31:06 <lispy> Other than the Odersky paper
11:31:14 <lispy> I guess I should look at it
11:31:16 <ksf> you could also argue that cellars can be easily modelled in terms of clothing lines.
11:31:31 <monochrom> No publisher wants to publish a paper that comes down to arguing the merit of using fewer keywords, don't you think?
11:32:00 <lispy> monochrom: I would anticipate that it is more of a footnote within some large body of published work...
11:32:02 <edbond> how to split list in list of two items? [1,2,3,4] -> [[1,2],[3,4]]
11:32:19 <lilac> one fewer keyword at the expense of having to add newtypes for existentials :(
11:32:21 <ksf> edbond, partition, split... have a look at Data.List
11:32:48 <pumpkin> > let x list = zipWith (\x y -> [x, y]) list (tail list) in  x [1,2,3,4]
11:32:50 <lambdabot>   [[1,2],[2,3],[3,4]]
11:32:53 <ksf> dropWhile, takeWhile...
11:32:53 <pumpkin> whoops
11:33:01 <pumpkin> wrong problem
11:33:02 <pumpkin> :)
11:33:30 <lilac> monochrom: correct me if i'm wrong, but ACTION only works in channels and not in privmsg, doesn't it?
11:33:49 <lilac> (/me in privmsg is implemented via some other mechanism iirc)
11:34:33 * BMeph plans to write an NSF-sponsored grant to determine whether too many frivolous papers are being written
11:35:07 <Toxaris> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1, 2, 3, 4]
11:35:08 <lambdabot>   [[1,2],[3,4]]
11:35:08 * BMeph wants, rather, to write a proposal for the study
11:35:24 <lilac> > let x list = zipWith (\x y -> [x, y]) `ap` tail in sum <$> fix ((1:) . (2:) . x)
11:35:24 <lambdabot>   Couldn't match expected type `[t]'
11:36:01 <monochrom> action is in fact a ctcp extension. the story gets messy.
11:36:35 <lilac> > let x list = zipWith (\x y -> [x, y]) list (tail list) in fix ((0:) . (1:) . fmap sum . x)
11:36:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:36:47 <Toxaris> I find it easier to conceptually understand private chat as channel chat with only two people around, then the other way around
11:38:22 <lilac> monochrom: in privmsg it's a normal message of the form '\SOHACTION <action here>\SOH'
11:38:41 <Cale> Users are just channels which you can send messages to but not join :)
11:39:32 <monochrom> In channel it's too.  PRIVMSG #haskell \SOHACTION <action here>\SOH
11:39:54 <monochrom> My exact syntax may be off.
11:40:14 <lilac> monochrom: hmm, right you are.
11:40:27 <lilac> you're missing the ':' but other than that, that's what my client's sending
11:40:49 * lilac has memory fail
11:41:26 <lilac> > fail "memory" :: Either String IrcFact
11:41:26 <lambdabot>       Not in scope: type constructor or class `IrcFact'
11:46:05 <ksf> -XcorrectTypos
11:46:16 <monochrom> Hahahaha
11:46:21 <ziman> -XIncorrectTypos
11:46:41 <ksf> -XundecidableTypos
11:47:07 <dons> dcoutts_: http://twitter.com/littleantyant/statuses/1227384852
11:47:37 <monochrom> -XErrorCorrectingCode
11:47:40 <dcoutts_> dons: :-)
11:48:17 <koeien> hey #haskell, trying out type families, why do i get this error message? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1477#a1477
11:48:41 <pumpkin> that's a cute twitter nick
11:51:52 <ksf> -XnoMonomorphismRestrictionEspeciallyIfTheFunctionIsUnreachable
11:59:49 <Cale> -XNoMonomorphismRestriction -XDontAskMeThisAgain
12:02:12 <Twey> -XNoReally -XTurnItOff
12:02:40 <pumpkin> benl23: did you get everything working on my vps?
12:04:12 <Cheshire> lets fork GHC wth monomorphism off by default :p
12:04:40 <pumpkin> I added to the monomorphism restriction page asking for real instances in which having it _off_ has caused problems
12:04:47 <pumpkin> (on haskell wiki)
12:05:05 <roconnor> pumpkin: I had oneish
12:05:30 <vincenz> Ok, for some reason when I install cabal packges the manual way, I get the wrong perms for files
12:05:42 <pumpkin> roconnor: you should put it up! :P http://www.haskell.org/haskellwiki/?title=Monomorphism_restriction
12:05:46 <pumpkin> roconnor: but I'm curious
12:05:52 <dcoutts_> vincenz: with what Cabal version?
12:06:06 <roconnor> pumpkin: but there might have been a workaround to get what I wanted in the MR off
12:06:07 <vincenz> dcoutts_: well I'm trying to install the new cabal version
12:06:14 <vincenz> @paste
12:06:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:06:14 <dcoutts_> vincenz: and what two methods are you comparing exactly?
12:06:16 <roconnor> pumpkin: I don't know it well enough to put it on the wiki
12:06:23 <pumpkin> ah
12:06:35 <Cale> Cheshire: And lots of other things fixed :)
12:06:40 <roconnor> pumpkin: but the problem was I wanted to restrict the use of a polymorphic function f to the same instance when I used it twice
12:06:52 <vincenz> dcoutts_: well I want to instal lcabal-install, but that requires a few cabal packages, so I started installing the new Cabal-1.6.0.2
12:06:58 <roconnor> pumpkin: to help make sure the function was being used properly
12:07:03 <dcoutts_> vincenz: I did make some changes to file permissions in the latest version, so I'm interested what you're seeing.
12:07:12 <pumpkin> well my understanding of the dangers of not having the MR is that in some cases you might use the same function for two different types in the same context, expecting it to run once, but it'll run twice or more times
12:07:19 <roconnor> pumpkin: the MMR gave me this for free.
12:07:24 <pumpkin> yeah
12:07:43 <pumpkin> I'm still not convinced it's worth it, if that's the only cost though
12:07:44 <roconnor> pumpkin: it wasn't a performance issue
12:07:51 <pumpkin> ah
12:07:54 <roconnor> pumpkin: it was more like a safety issue
12:07:57 <Cheshire> if I want to restrict a functions type I write a type signature
12:08:03 <vincenz> dcoutts_: http://rafb.net/p/8KGEIc44.html
12:08:06 <roconnor> pumpkin: too bad I don't remember the details
12:08:09 <vincenz> dcoutts_: I was installing with the older of the two Cabal
12:08:11 <pumpkin> yeah :/
12:08:13 <roconnor> pumpkin: it would be worth a careful look
12:08:18 <Cale> pumpkin: Well, it's really if the function is used at the *same* type which is the problem.
12:08:21 * ksf doesn't trust these so-called "Iteratees". They work suspiciously flawlessly.
12:08:29 <pumpkin> Cale: hmm
12:08:29 <Cale> s/function/value/
12:08:38 <thoughtpolice> ksf: hehe, they are nice :]
12:09:10 <Cale> pumpkin: Because with the MR on, it'll be monomorphic and computed only once, and with it off, it'll secretly become a function and be computed each time it's needed, as a function of the typeclass dictionary.
12:09:16 <ksf> actually, they feel like Data.Binary.Get on steroids.
12:09:27 <Cale> If you always happen to pass the same dictionary, that's a loss of performance.
12:09:27 <pumpkin> I see
12:09:46 <pumpkin> I'm still not convinced that warrants having it on by default
12:09:52 <pumpkin> but I dunno :)
12:09:54 <Cale> But it's just as easy to add a type signature.
12:09:55 <Cale> yeah
12:09:56 <pumpkin> I'm still a noob :)
12:09:57 <roconnor> pumpkin: I'm sure I could have gotten what I wanted if I could use type variables across multiple type signatures
12:10:25 <Cale> I think the last several years of pain at the hands of the MR have been evidence enough that it's not worth it. :)
12:10:26 <roconnor> pumpkin: and probably also with very careful use of asTypeOf and a bunch of craziness
12:10:46 <roconnor> pumpkin: but ya, MR still sucks, even if I used it once.
12:11:46 <roconnor> #lhc isn't what I wanted.
12:11:50 <vincenz> dcoutts_: any other info I can provide?
12:11:50 <roconnor> :)
12:12:03 <pumpkin>  #lhc-compiler :)
12:12:04 <Eridius> does anybody know where I can find an exact definition of how fixity is handled? http://www.haskell.org/onlinereport/decls.html#fixity talks about how to declare fixity, but I'm still not certain of the exact definition
12:12:09 <dcoutts_> vincenz: I'm just trying to reproduce it
12:12:12 <roconnor> hi vincenz
12:12:18 <vincenz> Hey roconnor :)
12:13:13 <Eridius> oh hrm, http://en.wikipedia.org/wiki/Associative might help
12:13:27 <Eridius> well actually, http://en.wikipedia.org/wiki/Operator_associativity
12:13:27 <pumpkin> Eridius: do you have a particular part of it you're confused about?
12:13:48 <Eridius> pumpkin: I think I understand how right- and left-associativity works but I want to know how non-associativity works
12:13:56 <vincenz> roconnor: how's life in utrecht?
12:13:59 <Eridius> or at least, I understand a useful approximation that gives the same results
12:14:08 <roconnor> vincenz: I moved to Canada last year ;(
12:14:15 <roconnor> vincenz: no hackaton for me this year
12:14:15 <vincenz> roconnor: how's life in canada?
12:14:19 <vincenz> :|
12:14:37 <roconnor> vincenz: I feel somewhat distant from my functional brothern
12:14:43 <roconnor> I guess Cale is close by
12:14:57 <vincenz> roconnor: Well you're online :)
12:15:14 <roconnor> that's true
12:15:16 <roconnor> :)
12:15:17 <Eridius> hrm, the wikipedia article says "Operators with the same precedence always have the same associativity." Err, what if you declare operators with the same precedence to *not* have the same associativity?
12:15:38 <jkff> Eridius: You get an error when you mix them
12:15:38 <lambdabot> jkff: You have 1 new message. '/msg lambdabot @messages' to read it.
12:15:44 <Eridius> jkff: huh, ok
12:15:46 <roconnor> > True `id` True `const` True
12:15:47 <lambdabot>   Couldn't match expected type `Bool -> a'
12:15:50 <Eridius> that at least resolves some of my confusion
12:16:18 * vincenz will be in california soon
12:16:30 <roconnor> > id `const` True `id` True
12:16:31 <lambdabot>   True
12:17:00 <ksf> hmmm... I think I'm going to have that parser construct a parser...
12:17:33 <Eridius> ok, that wikipedia article basically ignored non-associativity, except a single note about Prolog's infix :- operator. Am I to understand that non-associative operators simply produce an error when used to gether?
12:17:36 <Eridius> *together
12:17:57 <ksf> if they've got the same precedence, yes.
12:18:04 <Eridius> ok
12:18:21 <Eridius> I really wish either the haskell online report or the tutorials would mention how associativity works when talking about fixity. Or at least link to that wikipedia page
12:18:28 * Eridius is going to see if he can get "Fixity" to be associated with that wikipedia page as well
12:18:56 * ksf never wondered about it.
12:19:08 <ksf> but then, I've written parsers before.
12:19:18 <Eridius> is the word "Fixity" to mean operator associativity a Haskell-specific terminology?
12:19:33 <Eridius> ksf: heh. I've never had to parse operators, so I've never looked up exact definitions of associativity
12:19:38 <Eridius> and since most languages don't let you define it...
12:20:18 <ksf> there's only infix-right and infix-left in haskell, and functions are prefix-right.
12:20:25 <pumpkin> it's basically saying a+b+c being parsed as (a+b)+c vs. a+(b+c) vs. throwing an error saying you can't mix them
12:20:54 * ksf thinks h' should have mixfix.
12:21:00 <ksf> it's just so darn cute.
12:21:08 <pumpkin> mixfix?
12:21:18 <pumpkin> surrounding ?
12:21:31 <ksf> like if_then_else_ :: Bool -> a -> a -> a
12:21:38 <ksf> agda has them.
12:21:41 <pumpkin> ah
12:21:49 <pumpkin> why in that order?
12:21:59 <ksf> huh?
12:22:01 <ksf> what order?
12:22:06 <pumpkin> oh I see
12:22:16 <pumpkin> just me  being stupid :)
12:22:23 <Cale> pumpkin: The _'s presumably turn into parameters :)
12:22:27 <pumpkin> yeah
12:22:29 <mauke> I don't like "mixfix"
12:22:35 <mauke> it should be circumfix
12:22:41 <pumpkin> I'd like to be able to define |_|
12:22:42 <pumpkin> for abs
12:22:48 <pumpkin> but I'm not sure it's worth it :P
12:22:51 <ksf> in agda, you can.
12:23:41 <Cale> If we were a little stricter about how spaces were used with operators, stuff like that could be done unambiguously, but it allows for some things which would be tricky for humans to parse :)
12:24:02 <Cale> Also, how the multiple parameter version plays with currying is a little questionable :)
12:24:31 <ksf> well, agda is dependent, you can do sum 1 2 3 0 as well as sum 1 2 0
12:25:29 <ksf> actually, oleg has done that in haskell.
12:25:32 <Cale> Yeah, but I mean if you define something like if_then_else_ there's the question of how it might be applied to just one of its parameters.
12:25:32 <sema4r> i followed this howto http://sites.google.com/site/haskell/notes/cabal-on-debian to get cabal running. now cabal complains about missing dependencies ghc-prim -any, Integer -any.
12:25:47 <Cale> (but maybe that doesn't even matter)
12:26:00 <pumpkin> I still just prefer getting rid of the if then else altogether
12:26:07 <pumpkin> it bothers me
12:26:13 <ksf> (if_then_else_) True 1 2 ?
12:26:20 <dcoutts_> sema4r: what are you trying to do exactly?
12:26:32 <pumpkin> just have a function bool :: Bool -> a -> a -> a
12:26:33 <ksf> _?_:_ :: Bool -> a -> a -> a
12:26:59 <vincenz> That's not so complicated, I've done that before
12:27:01 <dcoutts_> sema4r: oh, if you're following those instructions then you're using a very old version.
12:27:03 <vincenz> Just have two operators
12:27:12 <vincenz> And make sure the fixity is correct
12:27:23 <ksf> i've been known to use more ?:'s than ifelses in java.
12:27:34 <pumpkin> it's more "functional"
12:27:39 <vincenz> ksf: http://oasis.yi.org/oasis/ChristophePoucet
12:28:49 <Eridius> looking for a better way to say the following thing: Non-associative operators are operators where it is an error to mix them in an expression.
12:29:00 <ksf> err, yes, : is a constructor.
12:29:33 <pumpkin> to mix them if they have the same precedence
12:29:41 <sema4r> dcoutts: yeah. but since i'm using ghc 6.8.2 i probably have to go that route. as is explained in that howto, newer versions of cabal-install do not work with that.
12:30:13 <Eridius> pumpkin: well yeah, associativity is irrelevant if precedence is different
12:30:14 <ksf> hmmm... I bet you can come up with cases where associative operators can't be combined, too.
12:30:16 <vincenz> ksf: check that likn
12:30:23 <dcoutts_> sema4r: that's not true. The newer versions work fine with older ghc, back to 6.6.x
12:30:25 <ksf> vincenz, I did, saw it before.
12:30:30 <Eridius> hrm, how about: Non-associative operators are operators that have no defined behavior when used together in an expression.
12:30:39 <Eridius> this is then followed up by an example in Prolog that is a syntax error
12:31:07 <elandy_123> hi!
12:31:13 <dibblego> where is (>=>) defined?
12:31:15 <Eridius> ksf: if operators have a fixity, then isn't there always an unambiguous definition of how to combine them, regardless of whether it actually makes practical sense?
12:31:17 <ksf> Eridius, how about writing a parser?
12:31:29 <mauke> @index (>=>)
12:31:29 <lambdabot> bzzt
12:31:30 <ksf> you'll soon know.
12:31:36 <pumpkin> dibblego: Control.Monada ?
12:31:40 <pumpkin> -a
12:31:42 <Eridius> ksf: heh
12:31:43 <hallongrottan> dibblego: Control.Monad
12:31:59 <dibblego> oh yes sorry
12:32:01 <elandy_123> i need some help writing a huffman coder/decoder
12:32:48 <vincenz> dcoutts_: Could this be due to standard permissions?
12:32:58 <ksf> elandy_123, help with the huffman or the haskell part?
12:32:59 <dcoutts_> vincenz: hmm?
12:33:15 <dcoutts_> vincenz: you mean the umask?
12:33:20 <vincenz> dcoutts_: Yes
12:33:28 <mathijs> I'm looking to implement a fixed-size cache as a memoization for certain functions. It has to store input -> output pairs every time a function is called, so I will probably need an alist internally. I'm affraid that'll be too slow though. any suggestions?
12:33:34 <sema4r> dcoutts: damn, one hour wasted for nothing. thx for explaining. you can't trust tutorials even if they are on the first google page ;)
12:33:36 <elandy_123> the haskell part
12:33:38 <dcoutts_> vincenz: it should not, we explicitly set the permissions of installed files
12:33:48 <elandy_123> i have it almost done
12:33:59 <vincenz> dcoutts_: Even in Cabal-1.2.3.0 ?
12:34:16 <dcoutts_> vincenz: but you're not using 1.2.3.0, you're using 1.6.0.2.
12:34:23 <roconnor> mathijs: that cannot be done without using a monad, or using something like unsafePerformIO.
12:34:31 <vincenz> dcoutts_: I was using the former to install the latter, no?
12:34:41 <roconnor> mathijs: although such use of unsafePerformIO would probably be safe
12:34:45 <dcoutts_> vincenz: you were running runhaskell Setup.hs in the 1.6.0.2 dir. So it uses the local files not any previously installed package.
12:34:49 <mathijs> roconnor: that sounds unsafe?
12:34:51 * vincenz ahs
12:35:06 <elandy_123> what does the @ mean in a pattern matching?
12:35:10 <mathijs> roconnor: is it needed for mutability in this case?
12:35:39 <dcoutts_> vincenz: try something else with the new Cabal you've got, do you get the same? is it the same bad perms for a sudo install as a user install etc
12:35:55 <vincenz> dcoutts_: well I can't use the new cabal due to its perms
12:36:13 <dcoutts_> vincenz: I'm sure you can fix that with a chmod o+r -R
12:36:31 <mooism> elandy_123: it means you can give a name to something and pattern match it into its constituent parts at the same time
12:37:19 * BMeph really likes the smooth nigh-self-referentiality of 'cabal install cabal-install'
12:37:23 <roconnor> mathijs: it is needed to "sequence" access to the cache.
12:37:26 <elandy_123> for example: lx@((x, cx) : cxs)
12:37:39 <cocon> haddock crashes with "Maybe.fromJust: Nothing" on a tree that is not mine... is there a way I can tell which file it got offended by?
12:37:52 <roconnor> mathijs: there is no "most recently used" without some sense of order of access.
12:38:40 <vincenz> dcoutts_: same when installing parsec-3.0.0
12:38:45 <vincenz> -rw-r----- 1 root root 5865 Feb 19 21:38 Parsec.hi
12:38:46 <mooism> elandy_123: then lx = ((x, cx) : cxs)
12:39:01 <elandy_123> lx@((x, cx) : cxs)  is a pattern matching for a [(Char,String)]
12:39:11 <dcoutts_> vincenz: ok, how about installing something without using sudo
12:39:28 <elandy_123> mooism: got it
12:39:30 <mooism> elandy_123: lx refers to the whole list,
12:39:30 <cocon> any haddock experts around?
12:39:31 <elandy_123> thanks
12:39:36 <vincenz> dcoutts_: how would it install in /usr/local then?
12:40:12 <dcoutts_> vincenz: you'd have to select a different prefix, eg in /tmp
12:40:46 <Saizan_> cocon: is it using TemplateHaskell?
12:40:49 <mooism> I have a cabal-install problem... when I run `cabal upgrade` it claims it can't configure syb because there is no suitable version of base.
12:40:52 <vincenz> dcoutts_: runhaskell Setup.hs configure --prefix=/tmp
12:41:17 <vincenz> dcoutts_: Unable to rename "/usr/lib/ghc-6.8.2/package.conf" to "/usr/lib/ghc-6.8.2/package.conf.old"
12:41:52 <rohan> i'm following the haskell in 5 steps guide, but when i try to compile the A.hs program, i get - Could not find module `Control.Parallel':
12:41:59 <vincenz> dcoutts_: -rw-r----- 1 poucet eng 5865 Feb 19 21:41 Parsec.hi
12:42:03 <rohan> i am using ubuntu 8.04 which has ghc 6.8.x
12:42:10 <vincenz> I did an install --user
12:42:13 <rohan> what package do i need to install, to get that module?
12:42:22 <mathijs> roconnor: what if I just use a list and prepend new inp->out pairs to that? in that case the function just needs to perform a lookup and if it gets Nothing, perform the real calculation and prepend it.
12:43:05 <mooism> Any cabal-install experts around?
12:43:28 <pumpkin> mooism: probably :) ask away
12:43:31 <cocon> Saizan_: how can I tell?
12:43:35 <roconnor> mathijs: the real problem is dropping things from the cache
12:43:37 <cocon> it's HAppS-Data
12:43:48 <mathijs> roconnor: But maybe lookups are slow. And I don't think there's a way to 'cut off' the last pieces when it reaches a certain size
12:43:51 <mooism> When I run `cabal upgrade` it claims it can't configure syb because there is no suitable version of base.
12:43:56 <Saizan_> cocon: then it does
12:44:02 <mathijs> roconnor: yeah... I was affraid of that.
12:44:05 <pumpkin> mooism: I think cabal upgrade is discouraged and they even took it out of the latest cabal-install
12:44:23 <dcoutts_> vincenz: ok, thanks. I'm rather confused by this. We explicitly set the file permissions to 644 ie -rw-r--r--
12:44:48 <Eridius> huh, `cabal upgrade --dry-run` isn't listing Cabal itself
12:44:53 <Saizan_> cocon: it's an haddock bug that will hopefully be fixed with the next ghc release
12:45:09 <mooism> pumpkin: Ah
12:45:17 <dcoutts_> Eridius: did you cabal update?
12:45:19 <pumpkin> but I may be wrong
12:45:22 <Eridius> dcoutts_: yep
12:45:27 <cocon> Saizan_: is there no way for me to get the doc then?
12:45:28 <Eridius> dcoutts_: `cabal list Cabal` shows 1.6.0.2
12:45:40 <Eridius> (as available, 1.6.0.1 as installed)
12:45:55 <tero-> has anybody used opengl with haskell?
12:46:00 <Eridius> just did `sudo cabal install Cabal` to upgrade manually, but I would expect `cabal upgrade --dry-run` to show it
12:46:22 <pumpkin> anyone know how far associated types are from working (i.e., showing up) in haddock?
12:46:40 <mmorrow> cocon: you'll have to go into the code and hack out every top-level template-haskell splice, while still maintining a file that will pass the typechecker :/
12:46:51 <mmorrow> it's not fun
12:46:52 <dcoutts_> Eridius: you mean it didn't list et even before you upgraded Cabal
12:46:53 <Eridius> dcoutts_: after Cabal 1.6.0.2 finished installing, `cabal --version` still lists 1.6.0.1
12:46:57 <Eridius> dcoutts_: right
12:47:10 <Eridius> and it's also listing "cabal-install version 0.6.0" even though the cabal-install package isn't installed
12:47:29 <mmorrow> haddock even picks up splices that have been commented out!
12:47:40 <mmorrow> so you'll have to comment them out + delete the '$' char
12:47:45 <dcoutts_> Eridius: the cabal-install package is installed, that's what provides the 'cabal' program.
12:47:50 <Saizan_> mmorrow: really?
12:47:55 <mmorrow> i think
12:47:58 <mmorrow> it's weird
12:48:03 <Eridius> `cabal list cabal-install` doesn't show it as being installed
12:48:06 <Eridius> ok now I'm confused
12:48:13 <mmorrow> i'm not 100%, but i'm 90% sure that's what's happening
12:48:14 <pumpkin> ghc-pkg list
12:48:17 <mmorrow> ooh, actually wait
12:48:25 <pumpkin> oh wow
12:48:26 <mmorrow> that's not what's happening
12:48:28 <pumpkin> cabal has a list command
12:48:35 <pumpkin> is that new?
12:48:38 <Eridius> only "Cabal" in my `ghc-pkg list` is Cabal-1.6.0.{1,2}
12:48:48 <mmorrow> it's becase the bare '$' in the comment needs to be escaped
12:49:00 <mmorrow> (it just occurred to me)
12:49:02 <Eridius> I think I probably screwed myself over when converting from user installs to global installs
12:49:09 <dcoutts_> Eridius: cabal-install package provides a program not a library, so it's not listed by ghc-pkg
12:49:17 <Eridius> ah
12:49:24 <vincenz> dcoutts_: cabal-install does the proper thing
12:49:32 <Eridius> dcoutts_: is it just the binary that's provided? So I can delete the old one and it'll work?
12:49:43 <Eridius> since I now have it installed in 2 locations (one in ~/.cabal/bin and the new one in /usr/local/bin`
12:49:43 <dcoutts_> vincenz: what version of the Cabal lib is it using 1.6.0.1 or .2 ?
12:49:46 <Eridius> s/`/)/
12:50:02 <vincenz> dcoutts_: Cabal-1.6.0.2
12:50:12 <dcoutts_> vincenz: that makes no sense at all :-)
12:50:12 <Eridius> ah, `cabal --version` now works properly
12:50:18 <Eridius> so what's new in 1.6.0.2 (and 0.6.2)?
12:50:26 <dcoutts_> Eridius: check the release notes
12:50:31 <Eridius> where are they?
12:50:41 <dcoutts_> in the announcement and in the changelog in the tarball
12:50:59 <dcoutts_> vincenz: since it's the same code used in both cases
12:51:14 <dcoutts_> vincenz: I'm still trying to reproduce it
12:51:15 <Eridius> didn't see announcement, I just checked since you mentioned it yesterday. As for tarball, does cabal give me any way to copy that to my current dir or do I have to find it in ~/.cabal/packages ?
12:51:21 <vincenz> dcoutts_: are you sure that it wasn't using the old lib?
12:51:26 <vincenz> when I just did runhaskell Setuop
12:51:50 <dcoutts_> vincenz: you can check, runhaskell Setup --help
12:52:19 <dcoutts_> vincenz: or perhaps I mean --version
12:52:23 * vincenz uninstalled the old one
12:52:30 <dcoutts_> hmm, actually, when bootstrapping that doesn't work
12:53:22 <vincenz> dcoutts_: let me try manually installing another package now that I've unregistered the old one
12:53:44 <dcoutts_> vincenz: you can specify the version, ghc --make Setup -package Cabal-1.6.0.2
12:53:50 <dcoutts_> vincenz: then ./Setup configure etc
12:53:57 <Eridius> dcoutts_: hrm, the new `cabal upgrade` warning says it's generally not recommended to upgrade core packages. Any way cabal could be kind enough to tell me which ones are core packages so I don't accidentally upgrade them?
12:54:00 <dcoutts_> vincenz: for any package other than Cabal itself.
12:54:21 <dcoutts_> Eridius: that's part of the problem. Cabal does not know that information.
12:54:26 <Eridius> ahh
12:54:37 <dcoutts_> Eridius: but it's the ones that come with ghc and other low level ones, network etc
12:55:15 <Eridius> yeah, well, since I install everything system-wide right now, I can't use `ghc-pkg` to show me what was bundled with ghc anymore :/
12:55:17 <mmorrow> Saizan_: well, but even then that would be weird, since "-- $(.....)" isn't a comment haddock would pay any attention to?
12:55:30 <mmorrow> or is it?
12:56:15 <vincenz> dcoutts_: nope, still a problem if I do the manual process
12:56:46 <dcoutts_> vincenz: and compare that to building Setup using -package Cabal-1.6.0.1
12:56:57 <Saizan_> mmorrow: maybe the parser dies trying to determine that
12:57:06 <tero-> well, I'll try writing to hopengl mailing list then
12:57:12 <mmorrow> Saizan_: heh
12:57:13 <vincenz> dcoutts_: is there a similar --global flag for cabal update?
12:57:36 <Matt324> Are there any suggested pronounciations for &&& and *** (in the same way that >>= is "bind")?
12:58:07 <bos> Matt324: "aaaaand" and "staaaaar" :-)
12:58:09 <Eridius> andandand, splatsplatsplat?
12:58:13 <mmorrow> i say "andandand" and "ralph" :)
12:58:23 <mmorrow> s/:)/;)/
12:58:25 <roconnor> presumably one of those is tensor
12:58:34 <dcoutts_> vincenz: update just downloads the package list, it's not an installing operation so no --local/--global
12:58:35 <roconnor> @type (***)
12:58:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:58:38 <vincenz> dcoutts_: out of curiousity, what is base >=
12:58:46 <roconnor> I'd say that one
12:58:46 <vincenz> base >= 4
12:59:15 <dcoutts_> vincenz: it means the base package greater or equal to version 4
12:59:23 <vincenz> That's GHC 6.10 ?
12:59:59 <Matt324> mmorrow: ralph??
13:00:11 <skorpan> :t (\k m -> k m)
13:00:12 <lambdabot> forall t t1. (t -> t1) -> t -> t1
13:00:12 <mmorrow> Matt324: hehe
13:00:41 <Matt324> I like splatsplatsplat, but andandand sounds like a speech impediment
13:01:11 <skorpan> i'm trying to figure out something here... if i have: newtype Rec = R (String -> Progress) (String -> Progress), is R (\k input -> k input) then partially applied?
13:01:42 <roconnor> @pl (\k m -> k m)
13:01:42 <lambdabot> id
13:02:01 <mmorrow> skorpan: polish parsing?
13:02:04 <skorpan> mmorrow: indeed
13:02:06 <mmorrow> :)
13:02:20 <skorpan> oh, i think i get it now
13:02:29 <skorpan> R (\k input -> k input) = R id
13:02:37 <glguy> Is there really no way to know generically that bitSize will return error when calling it?
13:02:43 <skorpan> and that was the definition of rSucceed
13:02:44 <Asztal> I think R ($) makes more sense
13:02:52 <skorpan> which is the recognizer which always succeeds
13:02:59 <skorpan> so it *is* partially applied?
13:03:04 <glguy> The standard instance for integer just returns error..
13:04:38 <skorpan> but i guess i should be able to say it's partially applied looking only at the parentheses, right?
13:05:13 <skorpan> uhm, i completely misread the type of Rec
13:05:20 <B1t1ng7ree5e22et> what does $ do?
13:05:27 <skorpan> B1t1ng7ree5e22et: function application
13:05:31 <mmorrow> skorpan: hmm, what do you mean "partially applied"?
13:05:38 <B1t1ng7ree5e22et> skorpan: how do you use it?
13:05:46 <B1t1ng7ree5e22et> $ do ...
13:05:47 <B1t1ng7ree5e22et> ?
13:05:48 <lunabot>  luna: Empty 'do' construct
13:06:08 <mmorrow> , zipWith ($) [(*2), const 0, id] [1..]
13:06:09 <lunabot>  [2,0,3]
13:06:11 <skorpan> mmorrow: i meant, e.g. if i have (+5), then + has been "partially applied"
13:06:13 <B1t1ng7ree5e22et> ah
13:06:15 <mauke> > sqrt $ 2
13:06:15 <B1t1ng7ree5e22et> sweet
13:06:16 <lambdabot>   1.4142135623730951
13:06:55 <skorpan> mmorrow: does that make sense to you?
13:06:59 <mmorrow> skorpan: oh, so then whether `R' has been partially applied?
13:07:09 <skorpan> yes
13:07:19 <skorpan> the definition of rSucceed boggles my mind
13:07:45 <mmorrow> i would think so, since R (\k inp -> k inp) :: (String -> Progress) -> Rec
13:07:55 <skorpan> yes
13:08:00 <skorpan> thanks for confirming this :)
13:08:02 <mmorrow> :)
13:09:05 <skorpan> mmorrow: do you have any better terminology for "partially applied"? i'm not really sure where i heard that first.
13:11:04 <skorpan> never mind, found it on haskell wiki
13:11:19 <mmorrow> skorpan: no, i was just confused on what you were wondering was being partially applied
13:11:32 <skorpan> okay
13:14:50 <Hynek> hi
13:15:20 <Cale> hi
13:15:36 <saml> hi
13:16:05 <Cale> ã“ã‚“ã«ã¡ã¯
13:16:53 <Hynek> i'm still beginning and i've just stumbled over something probably really simple...is it possible to express somthing like this using guards: "procRes (ids, ds, bs) (NewId id) = (id:ids, ds, bs)"?
13:17:25 <Hynek> (the NewId id part is what puzzles me)
13:17:31 <Cale> Using guards?
13:17:37 <saml> Hynek, NewId is a data constructor
13:17:40 <Eridius> Hynek: what's the issue - the id variable should be of type NewId?
13:17:44 <mauke>  ãƒã‚¹ã‚±ãƒ«
13:17:48 <Cale> Guards are conditions that are applied after pattern matching to determine whether the definition applies.
13:17:50 <saml> ë°”ë³´
13:20:32 <Hynek> hm, my problem is that i have several such lines and it's a bit annoying to write "procRes (ids, ds, bs" all the time...i'd like somthing like "procRes (ids, bs,ds) r | NewId id == r = (id:ids, bs,ds)" or something like that (i know that this example can't  work :))
13:21:13 <Cale> procRes (ids,bs,ds) = procRes'
13:21:32 <Cale>   where procRes' (NewId id) = (id:ids, bs, ds)
13:21:36 <Eridius> Hynek: what exactly are you trying to do?
13:21:42 <Cale>        procRes' ... = ...
13:21:52 <Hynek> hm i'll give you the whole source, that'll be easier :)
13:21:59 <Cale> Hynek: you could do something like that
13:22:01 <Cale> Or even...
13:22:04 <Hynek> my program works fine but there are some parts, i don't like
13:22:16 <Cale>   where procRes' x = case x of ...
13:22:37 <Cale> and then you don't have to write the procRes' bit over and over.
13:22:48 <Cale> Oh, or just:
13:22:59 <Cale> procRes (ids,bs,ds) x = case x of ...
13:23:11 <Cale> and then put the cases underneath
13:23:15 <mmorrow> or pattern guards
13:23:37 <dcoutts_> vincenz: I cannot reproduce your results. I get the correct permissions each time, sudo or not, and irrespective of umask.
13:24:45 <Hynek> the code is at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1478#a1478 - pls be patient with my n00bstyle...anaLine will be the next thing to be streamlined
13:25:19 <Eridius> Hynek: ah, then either of Cale's suggestions is probably what you want
13:25:49 <Hynek> ok, i'll try to understand them then. :)
13:25:59 <skorpan> okay, i'm having trouble with rSuccess again... what the heck does it do? newtype Rec = R (String -> Progress) -> (String -> Progress) and rSuccess = R (\k m -> k m)... then rSuccess is of kind (* -> * -> *) -> * , but (String -> Progress) doesn't fit that kind, does it?
13:26:12 <Hynek> mmorrow: yeah,pattern guards worked as far as i tried them but i didn't want to use non-standard stuff :)
13:26:19 <skorpan> okay, i'm mistaken as usual. but i still don't get it.
13:26:27 <Eridius> Hynek: I would also recommend using a case for Boring rather than _ as Boring is the only one not matched by the other cases, and this way you'll get a warning if you add yet another value to the AnaResult datatype and don't handle it in procRes (if you use _ then you won't get a warning if you forget to handle it)
13:27:30 <Eridius> skorpan: your lambda there (\k m -> k m) doesn't match (String -> Progress)
13:27:36 <skorpan> Eridius: exactly!
13:27:40 <skorpan> what's up with that?
13:27:44 <Eridius> well, unless Progress is of type (a -> b)
13:27:49 <skorpan> Progress isn't
13:28:08 <skorpan> data Progress = Shift Progress | Done | Fail
13:28:15 <Hynek> Eridius: there are more cases then Boring...they might be Success or Bounce but with foreign ids
13:28:21 <Eridius> skorpan: have you typed rSuccess as a Rec?
13:28:37 <Eridius> Hynek: ah, I didn't read closely enough to see the guards
13:28:41 <skorpan> Eridius: this is verbatim from hughes' and swierstra's paper on polish parsers
13:28:43 <dcoutts_> sema4r: did you get things installed ok in the end?
13:28:54 <Hynek> (the program analyzes a exim log file btw...i'm actually using it ;))
13:29:02 <skorpan> rSuccess = R (\k input -> k input)
13:29:24 <vincenz> dcoutts_: Alright, thanks
13:29:41 <Eridius> skorpan: ah hah, I think we're doing the incorrect association on the newtype
13:30:01 <skorpan> Eridius: is "input" the String in the other (String -> Progress)?
13:30:03 <Eridius> Rec = R ((String -> Progress) -> (String -> Progress)) is I think what's going on here, just one pair of parens is omitted
13:30:17 <Eridius> which means (\k m -> k m) actually does match the type (String -> Progress) -> String -> Progress
13:30:27 <skorpan> so k :: String -> Progress and m :: String?
13:30:34 <Eridius> yep
13:30:37 <skorpan> cool
13:30:39 <ksf> why am I using conv_stream instead of concatMap?
13:30:59 <dcoutts_> vincenz: the fact that it's apparently different between the lib on it's own and via cabal-install is probably relevant. I wonder if we're just doing something silly.
13:31:00 <skorpan> this has confused me for some time now... thanks for the explanation Eridius
13:31:21 <Eridius> skorpan: np
13:31:27 <ksf> Iteratees, stream fusion and even somehow FRP are too similar to be distinct, for my tastes.
13:32:08 <dcoutts_> vincenz: what is your user and sudo umask ooi? Also, I wonder if we're sure there's just the one Cabal-1.6.0.2 installed and that it really came from the new tarball and not from a darcs pre-release.
13:32:19 <skorpan> let newtype Rec = R (a -> b) -> (a -> b)
13:32:19 <tehgeekmeister> are there any generally agreed upon best places to start for trying to learn about arrows?
13:32:25 <skorpan> > let newtype Rec = R (a -> b) -> (a -> b)
13:32:25 <tehgeekmeister> tutorials, papers, whatnot?
13:32:26 <lambdabot>   <no location info>: parse error on input `newtype'
13:32:42 <ksf> tehgeekmeister, yampa, grapefruit?
13:33:04 <ksf> Personally, I don't care about arrows until I want to use any of the two.
13:33:18 <tibbe> ksf: I agree, there's something left to be discovered in the area of iteratees
13:33:26 <tehgeekmeister> ksf: those are both FRP things, not arrows in general, aren't they?
13:33:27 <tibbe> ksf: their current definition annoys me
13:33:49 <vincenz> dcoutts_: umask 0027, sudo su; umask: 0022
13:33:51 <ksf> tehgeekmeister, yes.
13:34:25 <tehgeekmeister> ksf: i'm just interested in learning about arrows for now.  i keep running into them in useful solutions to problems i'm working on, so i figure they'd be good to know in general.
13:34:30 <ksf> tehgeekmeister, are you sure that you don't want to use a plain monad, or, *gasp* a functor, maybe even a non-applicative one?
13:34:38 <tehgeekmeister> ksf: no?
13:34:52 <ksf> then follow occlam's razor.
13:34:56 <tehgeekmeister> ksf: i just know there are cool things that i've found useful in Control.Arrow, and hence i assume they are arrows.
13:35:13 <dcoutts_> vincenz: so on the face of it, it looks like the files are getting created with your default umask and not set explicitly. That is exactly the old behaviour prior to 1.6.0.1
13:35:17 <ksf> they might also work on monads or other stuff.
13:35:29 <vincenz> dcoutts_: funky
13:35:47 <dcoutts_> vincenz: what used to happen is the files would be created in the build tree with your user umask, and then on install they'd be copied and the perms copied too.
13:35:48 <vincenz> dcoutts_: I unregistered the old Cabal library
13:36:15 <dcoutts_> vincenz: so you'd get exactly the behaviour you're observing. So it does make me wonder if we're somehow using the wrong version.
13:36:51 <vincenz> dcoutts_: But I unregistered the old version from ghc, and then retried manually installing ,same behaviour
13:36:53 <ksf> concerning iteratees: I'm not even sure about what is the minimum set of stream tokens and atoms in the Iteratee ADT to support everything useful.
13:36:55 <vincenz> cabal install, otoh, works fine
13:37:10 <vincenz> the only tihng that bugs me of cabal install, is that you have to sudo it, but then it installs the cabal package list in /root/.cabal
13:37:20 <vincenz> I wish it'd store that somewhere in /usr/local
13:37:41 <ksf> john lato eg. sped up iteratees a lot by replacing the random-IO mvar with IE_seek.
13:37:50 <dcoutts_> vincenz: you can use the root-cmd=sudo option to build as you and install as root
13:38:12 <ksf> ...and all that stuff threads back into the monad instance, so it should be really complete.
13:38:21 <vincenz> dcoutts_: thanks
13:38:23 <tibbe> ksf: there seems to be a lot of people working on iteratee stuff around now, we should share some ideas
13:38:25 <dcoutts_> vincenz: are you sure there is only the one version of Cabal-1.6.0.2 registered? not registered globally and per-user ?
13:38:40 <vincenz> dcoutts_: yes
13:39:18 <tibbe> ksf: the presence of >>== and liftI in Oleg's defition of iteratees bothers me, and also what seems to be a need of defining the chunk as a type class
13:39:36 <dcoutts_> vincenz: do you get the same behaviour if you run with cabal install whatever --build-log=build.log
13:39:52 <ksf> 1) random IO support by default 2) use mmap'ed IO 3) abstract away stream type to foldable or something 4) ....
13:40:08 <ksf> I _did_ know what 4 was before I thought of 3.
13:40:18 <dcoutts_> vincenz: I ask because that forces it to compile the Setup.hs and not use the internal code. So it should be equivalent to you compiling Setup.hs directly using -package Cabal-1.6.0.2
13:40:28 <tibbe> ksf: if the stream type is foldable we have some find of fold in a fold since enumerators are folds themselves
13:40:36 <vincenz> dcoutts_: cabal install works fine for me
13:40:48 <ksf> yes.
13:40:49 <vincenz> dcoutts_: it's only manually doing the runhaskell Setup ... path that breaks the permissions
13:40:53 <Hynek> uhm, is it somehow possible to add guards to case patterns? something like "Success id | id `elem` ids = (ids, ds+1, bs)"  -- sry for interrupting the advanced flow here ;) in erlang IIRC it's possible to add guards
13:41:04 <dcoutts_> vincenz: yes, that's why I'm asking you to try with --build-log=build.log
13:41:04 <tibbe> ksf: need to run
13:41:05 <Heffalump> Hynek: yes
13:41:07 <tibbe> ksf: sorr
13:41:15 <Heffalump> Success id | id `elem` ids -> (ids, ...)
13:41:33 <Heffalump> it's just like adding guards to equational definitions of a function
13:41:33 <ksf> well, I don't like that there's no painless way to do a non-monadic Iteratee that works on more than one element.
13:42:04 <Hynek> Heffalump: ah thanks, i've had a typo so the test didn't work (wrote = instead of ->). thanks again
13:42:27 <vincenz> dcoutts_: ok, any suggestion for an interesting package?
13:42:42 <dcoutts_> vincenz: shouldn't really matter, any small lib
13:42:58 <ksf> also, the type of EnumeratorN smells like coJoin.
13:43:36 <vincenz> building
13:43:52 <vincenz> dcoutts_: that seems fine
13:44:17 <dcoutts_> vincenz: ok, that makes me all the more suspicious that we're doing something different in the manual case.
13:44:46 <dcoutts_> vincenz: because when it does --build-log, it has to compile the Setup using the installed Cabal lib and then run that
13:45:04 <dcoutts_> which should be exactly the same as the case where you do it manually which does not work for you
13:45:33 <dcoutts_> vincenz: can we try the same package but this time compiling the Setup.hs manually
13:45:42 <vincenz> sure
13:45:47 <vincenz> how do I uninstall it firsT?
13:45:55 <dcoutts_> vincenz: no need to
13:46:08 <mmorrow> skorpan: yeah, i was just thinking about that and realized it's _not_ partially applied ..
13:46:25 <skorpan> mmorrow: it is quite confusing
13:46:29 <dcoutts_> vincenz: ghc --make Setup -package Cabal-1.6.0.2 && ./Setup clean && ./Setup configure && ./Setup build && sudo ./Setup install
13:46:29 <mmorrow> totally :)
13:46:42 <skorpan> i don't see why they chose that notation...
13:46:48 <skorpan> it's far from intuitive
13:46:54 <vincenz> bah, it won't install
13:47:05 <vincenz> Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
13:47:06 <mmorrow> skorpan: yeah. there's also a couple of errors in the code in that paper iirc
13:47:25 <mmorrow> skorpan: i worked through it at one point, but didn't get to the Rec stuff.
13:47:27 <skorpan> mmorrow: i've only noticed a typo in a function name so far
13:47:30 <dcoutts_> vincenz: actually if you configure with -v it'll tell you which version of Cabal it is useing, just so we can confirm it really is 1.6.0.2
13:47:36 <mmorrow> skorpan: i have a paste, lemme try to dig it up
13:47:37 <Hynek> Cale: thanks for the hint with using case, looks much better now :)
13:47:41 <mmorrow> hpaste2 search++
13:47:42 <skorpan> mmorrow: that'd be nice
13:47:46 <dcoutts_> vincenz: won't install? why?
13:47:50 <vincenz> dcoutts_: ok, doing that without the -package blah breaks it again
13:48:03 <vincenz> dcoutts_: it was just a warning, it did build and install
13:48:07 <vincenz> let me do with --make Setup -package
13:48:24 <dcoutts_> vincenz: wait, what did you do before, I'm getting lost
13:48:37 <mmorrow> skorpan: i added the full ReadP interface on top of it: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=501
13:48:48 <vincenz> runhaskell Setup.hs configure && runhaskell Setup.hs build && sudo runhaskell Setup.hs install
13:48:57 <mmorrow> many (among possibly others) don't work as-is
13:49:04 <mmorrow> many := `many'
13:49:05 <dcoutts_> vincenz: and that failed you say, it installed with the wrong perms
13:49:11 <vincenz> dcoutts_: your command line gives the same, still o-r
13:49:11 <skorpan> thanks a lot mmorrow, that could prove very useful
13:49:22 <vincenz> dcoutts_: yes, both cases, both my way and your way cause it to install with o-r
13:49:33 <vincenz> cabal install causes it to install with o+r
13:49:40 <dcoutts_> vincenz: and what did ./Setup configure -v say about the version of Cabal it was using
13:49:46 <mmorrow> skorpan: let me know if you add some stuff/whatever. i'm always looking for cool parsing libs :)
13:49:55 <vincenz> Using Cabal-1.6.0.2 compiled by ghc-6.8
13:50:20 <skorpan> mmorrow: i'm reading this for my yi javascript-mode, which is my master thesis projet
13:50:23 <skorpan> project*
13:50:39 <mmorrow> skorpan: ohh, nice. yi rocks.
13:50:39 <dcoutts_> vincenz: and you were doing the install by sudo ./Setup install  right? not via runhaskell
13:50:46 <vincenz> dcoutts_: yes
13:50:52 <skorpan> mmorrow: yeah, i'll make it rock even harder i hope :)
13:50:53 <vincenz> dcoutts_: I copy pated your line
13:50:59 <mmorrow> skorpan: good luck!
13:51:03 <skorpan> thanks
13:51:12 * dcoutts_ is stumped
13:51:14 <Hynek> anyone a hint how to streamline anaLine in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1478#a1478 ? (line 43pp) i'd like to have some list with tuples of a pattern and a constructor that is used when the pattern matches...any cues constructs to look at?
13:52:36 <dcoutts_> vincenz: got time to try some more things? this time in ghci
13:53:04 <vincenz> dcoutts_: sure
13:53:17 <dcoutts_> vincenz: ok go to some empty dir, ghci -package Cabal-1.6.0.2
13:53:32 <dcoutts_> vincenz: oh, wait sorry, touch a file 'foo' before lanuching ghci
13:53:37 <Peaker> is Yi basically emacs re-done, in Haskell instead of ELisp? :)
13:53:52 <dcoutts_> vincenz: we're going to install ./foo to ./bar and check the perms of each
13:54:00 <vincenz> done
13:54:36 <dcoutts_> vincenz: ok, now in ghci -package Cabal-1.6.0.2, :m Distribution.Simple.Utils Distribution.Verbosity
13:54:53 <dcoutts_> vincenz: and we want to copyFileVerbose verbose "foo" "bar"
13:55:08 <shadid> Hello all
13:55:14 <vincenz> dcoutts_: done
13:55:16 <vincenz> dcoutts_: privm?
13:55:18 <dcoutts_> vincenz: then we want to exist ghci and check the perms
13:55:21 <dcoutts_> vincenz: ok
13:55:50 <shadid> hey all
13:56:11 <shadid> I was wondering if anyone could help me with some javascript?
13:59:42 * glguy heads to the bar while GHC 6.10.1 flails about pathetically on the lists of large constants...
14:01:02 <wolverian> Peaker: are you asking whether it has any features that emacs doesn't? the context-sensitive parsing to ASTs is I think only in yi
14:01:26 <wolverian> Peaker: I don't think yi is aiming at having a mail client in the editor very soon either...
14:01:41 <Peaker> wolverian, I guess also if its extensible emacs-wise, like defining a new editor function in Haskell easily and binding it to a key
14:02:07 <wolverian> well, yes, except emacs isn't completely elisp, whereas yi is completely haskell
14:02:16 <wolverian> (besides the vty bindings and such...)
14:02:48 <wolverian> but in that case it's more accurate to just say "yi aims to be extensible in its own language", I think, than comparing to emacs
14:03:07 <p_l> wolverian: That's only because the GNU Emacs has a VM written in C and certain crazy developer as head
14:03:27 <mmorrow> Peaker: it's in the style of xmonad, so you add stuff to your personal yi.hs, bind keys to arbitrary actions written in haskell, etc, and every time you run yi, your yi.hs is compiled and run
14:03:40 <wolverian> (if it's changed)
14:03:54 <Peaker> mmorrow, its not dynamic like emacs, where you can eval new functions as you go?
14:04:13 <wolverian> not sure.
14:04:18 <mmorrow> Peaker: well it could be, with some help from the ghc-api
14:04:51 <mmorrow> Peaker: but as-is, you just recompile your yi.hs, just like how you can recompile xmonad.hs while it's running
14:05:04 <Peaker> I think I tried running yi at some point but it just crashed on startup.. is it less rough around the edges now?
14:05:16 <mmorrow> not positive about whether state persists though across recompilations as it does with xmonad though
14:05:17 <skorpan> :t ((a .) . b . c)
14:05:18 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Expr'
14:05:18 <lambdabot>     In the first argument of `(.)', namely `a'
14:05:18 <lambdabot>     In the first argument of `(.)', namely `(a .)'
14:05:18 <wolverian> Peaker: worksforme.
14:05:31 <wolverian> Peaker: (on a recent GHC 6.11 HEAD, no less)
14:06:02 <mmorrow> Peaker: it's not a program that's easy to use unless you know haskell and to some extent the yi code itself
14:06:13 <Peaker> :t \a b c -> ((a .) . b . c)
14:06:13 <lambdabot> forall b c a b1 a1. (b -> c) -> (b1 -> a -> b) -> (a1 -> b1) -> a1 -> a -> c
14:06:45 <mmorrow> but i don't see any reason it would crash on startup
14:06:53 <mmorrow> unless you botch your yi.hs that is
14:07:03 <mmorrow> $HOME/.yi/yi.hs
14:07:04 <lunabot>  luna: Not in scope: data constructor `HOME'
14:07:06 <mmorrow> gah
14:07:20 <wolverian> reminds me, I need to write some vim functions for it
14:07:25 <ksf> what we need is a proper U-turn.
14:07:31 <thaldyron> dcoutts: Hi, just a quick note that I've completed the patch for the world-file support for cabal
14:07:33 <wolverian> ci" is absolutely necessary :)
14:07:42 <ksf> ...between structures and co-structures.
14:07:47 <dcoutts_> thaldyron: oh great
14:08:01 <wolverian> oh, wait, it already has ci".
14:08:09 <dcoutts_> thaldyron: so what behaviour have you gone for in the end?
14:08:18 <dcoutts_> thaldyron: and what about the user interface?
14:08:20 <ksf> ...that reduces everything that can be stuffed into it to linear space.
14:08:32 <ksf> errr.... linear time, constant space.
14:08:44 <ksf> ...that is, flattenes time and keeps space constant.
14:08:55 <thaldyron> dcoutts_: well if you already have a world file you simple type "cabal install world" on compiler upgrade
14:08:59 <mmorrow> $foo
14:09:11 <mmorrow> , 42
14:09:12 <lunabot>  42
14:09:16 <ksf> (phew. I shouldn't claim knowing how to turn NP into O(n))
14:09:20 <thaldyron> dcoutts_: if not, you can regenerate the world file with "cabal regenerate"
14:09:45 <thaldyron> dcoutts_: which simply writes the packages from a package DB to the world file
14:09:47 <glguy> emacs has a c vm, but yi, compiled with GHC has a c rts
14:09:49 <dcoutts_> thetallguy: oh, what does that do? surely the world file is stored data that cannot be regenerated?
14:09:58 <dcoutts_> oopes
14:10:13 <mmorrow> glguy: emacs has a C vm??!
14:10:23 <glguy> mmorrow, That's what someone said above
14:10:28 <glguy> I have no idea if that was incorrect
14:10:30 <ksf> emacs-lisp is interpreted by c.
14:10:32 * mmorrow doesn't know much about emacs apparently
14:10:34 <mmorrow> oh
14:10:37 <mmorrow> i see
14:10:38 <ozy`> emacs has a buggy elisp VM implemented in C.
14:10:50 <thaldyron> dcoutts_: well the only thing that can be regenerated is the package name, not any specific version or user flags
14:11:00 <thaldyron> dcoutts_: better than nothing I guess
14:11:01 <mmorrow> i thought what was being said was that emacs had a vm that _interprets_ C
14:11:04 <dcoutts_> thaldyron: you mean just based on it being installed?
14:11:23 <mathijs> for a program that needs to perform fast, I'm using Int instead of Integer. Since I run on 64bit, I don't think the bounds will ever be reached. But if it ever will happen and I forgot there's Ints, is there a way to make sure the program crashes when a bit 'falls off' instead of giving me wrong values?
14:11:25 <Botje> how's that emacs in common lisp thing going?
14:11:28 <ozy`> mmorrow: I'm sure there's one out there
14:11:40 <ozy`> Botje: who would ever use it?
14:11:47 <dcoutts_> thaldyron: but being installed and being in the world file are independent. the world only records things we asked to install right? not all their uninteresting dependencies.
14:11:54 <mmorrow> ozy`: a C interpreter? i'd be amazed (and thrilled)
14:11:59 <Botje> people who want to use common lisp stuff inside emacs?
14:12:01 <thaldyron> dcoutts_: yes
14:12:04 <thetallguy> dcoutts_: Was that a misdirection?
14:12:05 <mmorrow> (interpreter := not using gcc)
14:12:11 <dcoutts_> thetallguy: it was, sorry.
14:12:12 <ozy`> Botje: on the upside, elisp is getting inexorably closer to CL, so it'll happen eventually
14:12:19 <Botje> :)
14:12:23 <ozy`> mmorrow: yeah. those exist, by the way.
14:12:33 <thaldyron> dcoutts_: that's why regeneration is a sort of compromise
14:12:35 <dcoutts_> thetallguy: the<tab> vs tha<tab>, my silly fault :-)
14:12:35 <thetallguy> dcoutts_: no problem, nice little puzzle
14:12:38 <ksf> this search for an IO/fusion framework with perfect performance is isomorphic to convincing a dependently-typed language that your program terminates.
14:12:48 <mathijs> is there a way to use unsigned ints?
14:12:50 <ozy`> mmorrow: I mean, there are several of them outside the emacs omniculture
14:12:53 <mmorrow> ozy`: sure, but that are useable? i know of maybe one
14:13:01 <mmorrow> and that one doesn't have gnu extensions
14:13:04 <dcoutts_> thaldyron: to be honest I don't think we should bother with regenerating the world file.
14:13:07 <mmorrow> :(
14:13:09 <tibbe> dcoutts: where is `config` documented?
14:13:26 <ksf> that is, the only way to work with infinite recursion is not to recurse on it.
14:13:42 <thaldyron> dcoutts_: yeah, that's what I thought after I've written it... :) btw: "cabal upgrade world" also works
14:13:46 <dcoutts_> thaldyron: if someone deletes it it's no big deal, and it's their own silly fault. Adding an extra top level command to the user interface has its costs too in terms of complicating the UI
14:14:08 <mmorrow> oh, and i should qualify that with "one open source C interpreter" ..
14:14:21 <dcoutts_> tibbe: in the file itself. If you've got an old one that's not documented then move it out the way, let it be recreated and merge back any changes you made.
14:14:35 <mmorrow> found it: http://root.cern.ch/drupal/content/cint
14:14:52 <mmorrow> "CINT is written in C++ itself, with slightly less than 400,000 lines of code."
14:14:54 <mmorrow> gah!!
14:14:54 <tibbe> dcoutts_: done, thanks
14:14:58 <ksf> mmorrow, if you want a c interpreter, you might want to write a say arm interpreter in haskell and just target that...
14:15:05 <thaldyron> dcoutts_: yeah, that's what I thought after I've written it... :) btw: "cabal upgrade world" also works
14:15:06 <lament> 399,997
14:15:22 <dcoutts_> thaldyron: ok, lets leave it out then.
14:15:42 <mmorrow> ksf: heh, wasn't someone working on an ARM interp/sim ?
14:15:46 <mmorrow> (a haskell one)
14:15:50 <ksf> dunno.
14:16:02 <dcoutts_> thaldyron: so send your current patch to the list or attach it to the ticket and I'll review it properly.
14:16:21 <thaldyron> dcoutts_: Ok I'll
14:16:24 <ksf> but interpreting/recompiling foreign binaries would be a kind of must-have feature for a serious haskell os.
14:16:24 <mmorrow> jeez, CINT is 400,000 loc. ghc is around 150,000 last time i did a quick-and-dirty wc -l
14:16:39 <dcoutts_> thaldyron: we ought to be able to get it into the next release. I'm hoping to do a short release cycle for cabal-install 0.6.4
14:16:40 <thaldyron> dcoutts_: shall I remove the regeneration stuff first?
14:16:58 <dcoutts_> thaldyron: might as well, make it simpler for me to review
14:17:05 <thaldyron> dcoutts_: ok
14:17:07 * Heffalump wonders why the Cabal version wasn't bumped properly for this release, given that it has breaking changes
14:17:23 <dcoutts_> Heffalump: it does not have breaking changes in the api
14:17:40 <dcoutts_> Heffalump: the packages that now break were already broken, eg with ghc-6.8
14:17:55 <Heffalump> ah, right, so the policy just refers to the Haskell API?
14:17:59 <mmorrow> i wonder how many loc gcc is (just the core C compiler)
14:18:00 <Peaker> ozy`, what bugs does the C implementation of elisp have?
14:18:09 * mmorrow guesses 1 million +
14:18:19 <ozy`> Peaker: all of them
14:18:27 * ksf thinks that not distinguishing between finite and infinite lists is a bad idea, in the long run.
14:18:40 <dcoutts_> Heffalump: there was actually only one package where the new check broke a legit package and even that was arguable and I judged that the benefit outweighed the cost of the fix.
14:18:50 <ozy`> ksf: in haskell?
14:19:07 <ksf> in the context of iteratees/stream fusion...
14:19:11 <ksf> ...so yes, in haskell.
14:19:25 <Peaker> ksf, if its a different type than list then you want take/drop/etc to be methods rather than functions, probably
14:19:33 <dcoutts_> Heffalump: I try in general not to make big behaviour changes in stable versions but there was a lot of demand for this and the cost does not seem to have been too bad.
14:19:47 <ksf> the point is that you (may) have infinte structures as input and output, but never in between of those two.
14:20:08 <ksf> ...as you would'nt be terminating then.
14:20:10 <Heffalump> I'm not arguing you shouldn't have done it, I was just a bit surprised you didn't bump the earlier bits of the version number
14:20:23 <dcoutts_> right
14:20:47 <ksf> take and drop are already in foldable, aren't they?
14:20:54 <ksf> anyway, adding a typeclass isn't that hard.
14:20:58 <Botje> @pl \nam -> (,) nam =<< next "LAB"
14:20:58 <lambdabot> (next "LAB" >>=) . (,)
14:21:16 <ozy`> Peaker: to be serious... I've heard (from people who are much more familiar with emacs than I ever want to be) that different modes interact with each other in poorly defined ways, which are no longer problematic if the functionality is reimplemented in C
14:21:39 <ozy`> of course, this frailty might just be due to the design of elisp itself
14:21:42 <dcoutts_> Heffalump: I think it's arguable either way. It'd be ok to have called it 1.6.1.0. Perhaps in retrospect I should have done that.
14:21:57 <Peaker> ozy`, elisp and emacs architecture are pretty horrible by design, but I think the implementation is faithful to the horrible design and not that buggy :)
14:22:10 <ozy`> Peaker: heh, well all right :p
14:22:36 <ksf> back when dynamic scope was considered a useful feature...
14:22:43 <ozy`> yeah :|
14:22:57 <mm_freak_> well, the architecture of emacs/elisp is very old and has never been revised
14:23:04 <ddarius> ksf: Dynamic scope is a use feature.
14:23:04 <mm_freak_> for that it works quite well
14:23:13 <ozy`> that would be my guess for "single design attribute most responsible for shittiness"
14:23:59 <tibbe> ksf: I wonder if we could get rid of the chunks for enumerators and still have them be efficient using stream fusion
14:24:30 <PhilRod> mmorrow: I have to use CINT every day, and every day I curse it to hell
14:24:30 * wli is a heretic in endorsing modal editors.
14:24:40 <ksf> tibbe, that, and skip/yield can implement conv_stream.
14:25:03 <tibbe> ksf: what do you mean?
14:25:11 <ksf> otoh, skip is implitit in iteratees, they just don't care.
14:25:14 <ddarius> wli: There are plenty of people who, at least implicitly, endorse modal editors.
14:26:03 <ksf> ...the operation I dub "concatMap" in my head, mapping some a -> [b] over an [a] and getting a [b]
14:26:17 <tibbe> ksf: I see
14:26:50 <idnar> @type concatMap
14:26:51 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
14:27:04 <roconnor> @src [] (>>=)
14:27:04 <lambdabot> xs >>= f     = concatMap f xs
14:27:16 <tibbe> ksf: iteratees have error in their stream ADT instead of skip
14:27:22 <ksf> that is, just using them together isn't the best thing we can do, but I fail to see how they fit exactly into each other.
14:27:37 <ksf> uhh.... Err String and EOF are Done.
14:27:39 <p_l> As for Lisp - I heard there was a lot of friction once in getting bigger changes into GNU Emacs.
14:27:46 <p_l> *elisp
14:28:55 <tibbe> ksf: yes I guess you can see both Eof and Err as Done
14:29:18 <Peaker> ddarius, All editors are modal - surely different key bindings make sense in different situations
14:30:05 <ddarius> Peaker: I agree that all editors are modal.
14:30:42 <jeffwheelerPhone> @users
14:30:42 <lambdabot> Maximum users seen in #haskell: 665, currently: 636 (95.6%), active: 32 (5.0%)
14:30:48 <ksf> but then, we _don't_ want Chuck to be replaced by multiple Yields, as Chunk may be a UArr or something.
14:31:04 <ksf> ...it can be a backpointer to an mmap'ed file, for all you care.
14:31:05 <tibbe> ksf: right
14:31:34 <ksf> wheras [1..] doesn't really support seeking.
14:32:04 <tibbe> ksf: I think one of the nice things lazy bytestring does is to expose an interface that byte-by-byte while the implementation is chunk by chunk
14:32:09 <ksf> ...so we could have iteratees request a chunk size.
14:32:24 <wli> Maintain a rank-ordered sorted list via a rank-ordered binary search tree for O(lg(n)) seeks.
14:33:04 <wli> Lots of STRef garbage I guess.
14:33:20 <ksf> ...and alignment. with a 16-bit window into a stream and a 16-bit window into a stream, offset by 8 bits, just being a different view.
14:33:24 <wli> Mind you, I couldn't code such a thing to save my life.
14:34:09 <ksf> uh... aren't seeks O(1)?
14:34:28 <ksf> 1 being avg(ram_seek, disk_seek) * overhead.
14:34:47 <tibbe> ksf: I wonder if we can abstract over the chunk type without introducing a whole new stream type class
14:38:49 <ksf> something needs to implode in my head.
14:41:49 <tibbe> ksf: in mine too
14:42:18 <ksf> trying to make oleg's code non-recursive could be interesting.
14:43:26 <tibbe> ksf: yes
14:48:38 <amaron> what is most complete cross platform gui library for haskell? gtk2hs, wxHaskell, HToolKit... ?
14:48:47 <dons> gtk2hs
14:49:09 <dons> followed by wxHaskell. you may also wish to try various apis layered on top of gtk/cairo/wx now available.
14:49:32 <dons> particularly for certain domain specific guis
14:49:40 <amaron> dons: even they say it's incomplete?
14:50:36 <amaron> I'm reading gtk2hs site, they say its still in development and incomplete
14:51:09 <TomMD> amaron: I've developed a number of apps with gtk2hs and haven't had issues (though my gui needs are very basic)
14:52:31 <amaron> TomMD: nice, I've done alot with pygtk, I hope I can have same level of functionality and ease of development
14:53:24 <dons> amaron: i think gtk is growing faster than the gtk2hs bindings, but they're as complete as we have - i.e. pretty huge
14:53:40 <amaron> regarding those high level libraries, aren't they just experimental, none of them is in usable state for development of complex gui applications
14:54:01 <roconnor> amaron: if you have a simple UI, you might want to try out one of the higher level ui systems.
14:54:11 <acidjnk> hello
14:54:28 <dons> we need a comparative review of the (oh so many) gui layers now
14:54:38 <dons> i did a simple table for the dbs'
14:54:39 <roconnor> oh, dons already meantion this
14:54:50 <dons> http://archhaskell.wordpress.com/2009/02/16/haskelldb-high-level-type-safe-database-queries-for-haskell/
14:55:02 <dons> something like that for the current active gui thingies (+ graphics thingies)
14:55:03 <acidjnk> Where is "chop" defined?
14:55:12 <dons> TomMD: hey btw, you in town yet?
14:55:13 <roconnor> @hoogle chop
14:55:13 <lambdabot> No results found
14:55:18 <roconnor> :(
14:55:38 <acidjnk> Hm. What could I mean?
14:55:48 <roconnor> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:chop
15:00:45 <amaron> roconnor: what high level gui libs did you tried?
15:01:05 <dons> _dolio: http://lindstroem.wordpress.com/2009/02/19/using-mutable-arrays-for-faster-sorting/
15:01:18 <dons> might be fun to try that streaming lists to uvectors, sorting them, then reconstructing..
15:01:36 <Fredrik> @pl (\x y -> fromInteger x / fromInteger y)
15:01:38 <lambdabot> (. fromInteger) . (/) . fromInteger
15:02:24 <jpcooper> acidjnk, do you want to separate a list by a certain element?
15:02:50 <acidjnk> I have an exercise here to redefine "chop8" or "chop 8" using a given fuction unfold
15:05:26 <Fredrik> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
15:05:26 <Fredrik> @let gold = zipWith (\x y -> fromInteger x / fromInteger y) fibs (tail fibs)
15:05:26 <Fredrik> >gold !! 50
15:05:27 <lambdabot>  Defined.
15:05:28 <lambdabot>  Defined.
15:05:37 <Fredrik> > gold !! 50
15:05:38 <lambdabot>   0.6180339887498949
15:05:50 <Fredrik> (sqrt(5) - 1) / 2
15:05:52 <Fredrik> > (sqrt(5) - 1) / 2
15:05:53 <lambdabot>   0.6180339887498949
15:05:57 <Fredrik> > gold !! 50
15:05:58 <lambdabot>   0.6180339887498949
15:06:02 <Fredrik> cool
15:06:18 <ddarius> @let phi = (sqrt 5 - 1) / 2
15:06:18 <lambdabot>  Defined.
15:06:25 <wli> That's actuall ythe reciprocal of the golden ratio.
15:06:29 <ddarius> > sqrt phi
15:06:31 <lambdabot>   0.7861513777574233
15:06:38 <ddarius> > phi + 1
15:06:39 <lambdabot>   1.618033988749895
15:06:43 <ddarius> > phi * phi
15:06:43 <Fredrik> yeah i like numbers between 0 and 1 better than between 1 and 2. there's more of them ;)
15:06:44 <lambdabot>   0.3819660112501052
15:06:45 <wli> Those are BTW the convergents of the continued fraction of phi.
15:06:46 <mmorrow> acidjnk:   chop [] = []; chop "\n" = []; chop (c:cs) = c : chop cs
15:06:53 <mmorrow> acidjnk: that `chop'?
15:06:55 <ddarius> > recip $ phi * phi
15:06:56 <lambdabot>   2.6180339887498945
15:06:59 <pumpkin> dons: I think that's what dolio's uvector algorithms is already doing isn't it? except he has fancier sorts than mergesort
15:07:06 <acidjnk> Who knows, maybe? thanks
15:07:09 <mmorrow> acidjnk: oh, oops. i just saw that this is an excercise with unfold
15:07:13 <Axman6> Fredrik: i think there are many people who'd disagree with you there :P
15:07:22 <dons> pumpkin: kinda. since its streamable. so we should measure it!
15:07:33 <acidjnk> found it
15:07:33 <Fredrik> i mean in ieee754 of course ;)
15:07:36 <pumpkin> yeah!
15:07:36 <mmorrow> , [$ty| sort |]
15:07:42 <lunabot>  forall a b . (UA b, Ord b) => MUArr b a -> ST a ()
15:07:44 <acidjnk> Sorry, it is in the chapter for the exercise. I just read it three months ago and forgot.
15:07:52 <pumpkin> having a good list of performance numbers for uvector would be awesome
15:07:58 <acidjnk> It's exercise 7, and I need more than a week for some exercises.
15:07:59 <dons> mmm
15:08:26 <wli> > let fibs :: [Integer] = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 $ zipWith ((/) `on` fromIntegral) (drop 2 fibs) (tail fibs) :: [Rational]
15:08:27 <lambdabot>   [1%1,2%1,3%2,5%3,8%5,13%8,21%13,34%21,55%34,89%55]
15:09:08 <monochrom> @hoogle [Either x y] -> ([x],[y])
15:09:08 <lambdabot> No results found
15:09:15 <Fredrik> :t on
15:09:16 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:09:20 <monochrom> @hoogle [Either x y] -> [x]
15:09:20 <lambdabot> Data.Generics.Basics dataCast2 :: (Data a, Typeable2 t) => c (t a b) -> Maybe (c a)
15:09:20 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
15:09:20 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
15:09:21 <mmorrow> , 'partitionEithers
15:09:22 <lunabot>  Data.Either.partitionEithers
15:09:32 <mmorrow> , [$ty| partitionEithers |]
15:09:35 <lunabot>  forall a b . [] (Either b a) -> ([] b, [] a)
15:09:39 <pumpkin> , [$ty| apply |]
15:09:41 <lunabot>  forall a . UA a => (forall b . MUArr a b -> ST b ()) ->
15:09:41 <lunabot>                     UArr a -> UArr a
15:10:09 <mmorrow> , 'apply
15:10:10 <lunabot>  Data.Array.Vector.Algorithms.Immutable.apply
15:10:11 <monochrom> My 6.8.2 doesn't have it.
15:11:38 <wli> phi^2 = phi + 1 ---> phi = 1 + 1/phi = 1 + 1/(1 + 1/(1 + 1/(1 + ...
15:12:46 <Axman6> @pl \x -> 1 + 1/x
15:12:46 <lambdabot> (1 +) . (1 /)
15:13:00 <Axman6> > iterate ((1 +) . (1 /)) 1
15:13:01 <lambdabot>   [1.0,2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.619047619047...
15:13:14 <Axman6> > drop 100 . iterate ((1 +) . (1 /)) $ 1
15:13:15 <lambdabot>   [1.618033988749895,1.618033988749895,1.618033988749895,1.618033988749895,1....
15:13:29 <Axman6> > phi + 1
15:13:30 <lambdabot>   1.618033988749895
15:13:39 <Axman6> > phi + 1 :: CReal
15:13:40 <lambdabot>   1.6180339887498948482045868343656381177203
15:13:44 <jpcooper> > drop 1000000000000000000000 . iterate ((1 +) . (1 /)) $ 1
15:13:51 <lambdabot>   mueval: Prelude.read: no parse
15:14:00 <wli> The definition of phi is wrong; what you've actually got is 1/phi = phi - 1
15:14:05 <Axman6> > (!! 100) . iterate ((1 +) . (1 /)) $ ( 1 :: CReal)
15:14:09 <lambdabot>   1.6180339887498948482045868343656381177203
15:14:18 <Axman6> nice
15:14:24 <jpcooper> I'm quite amazed that it got that so quickly
15:14:26 <ddarius> wli: I've heard both referred to as phi, but I never disagreed with you.
15:14:33 <jpcooper> what is !!?
15:14:38 <Fredrik> element at
15:14:42 <jpcooper> > !! 10
15:14:43 <Axman6> '[1..10 !! 5
15:14:43 <lambdabot>   <no location info>: parse error on input `!!'
15:14:45 <wli> @src (!!)
15:14:45 <lambdabot> xs     !! n | n < 0 = undefined
15:14:45 <lambdabot> []     !! _         = undefined
15:14:45 <lambdabot> (x:_)  !! 0         = x
15:14:45 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:14:50 <Axman6> > [1..10] !! 5
15:14:50 <jpcooper> oh, I remember
15:14:51 <lambdabot>   6
15:14:53 <Fredrik> "hello world" !! 4
15:14:56 <Fredrik> > "hello world" !! 4
15:14:57 <lambdabot>   'o'
15:15:16 <jpcooper> I just went blank for a second and thought it was factorial
15:15:23 <jpcooper> > drop 10000000000000000000000000000000000. iterate ((1 +) . (1 /)) $ 1
15:15:26 <Axman6> heh
15:15:31 <jpcooper> > drop 10000000000000000000000000000000000 . iterate ((1 +) . (1 /)) $ 1
15:15:33 <Alpounet> heh
15:15:36 <wli> There are recurrences to compute more continued fractions.
15:15:37 <lambdabot>   mueval: Prelude.read: no parse
15:15:44 <Axman6> :t drop
15:15:48 <lambdabot>   mueval: Prelude.read: no parse
15:15:51 <lambdabot> forall a. Int -> [a] -> [a]
15:15:54 <Axman6> > maxBound Int
15:15:55 <jpcooper> why no parse and not some other error?
15:15:56 <lambdabot>   Not in scope: data constructor `Int'
15:15:58 <Axman6> > maxBound :: Int
15:16:00 <lambdabot>   9223372036854775807
15:16:03 <jpcooper> aah
15:16:10 <jpcooper> of course
15:16:15 <Axman6> > (!! 9223372036854775807) . iterate ((1 +) . (1 /)) $ ( 1 :: CReal)
15:16:19 <pumpkin> > ord maxBound
15:16:23 <lambdabot>   mueval: Prelude.read: no parse
15:16:27 <lambdabot>   1114111
15:16:30 <Axman6> ain't gonna happen...
15:16:39 <chessguy_work> 'evening
15:16:41 <grahamhutton> is this really a spectator sport?
15:16:42 <pumpkin> why not just write !! maxBound in there?
15:16:47 <jpcooper> > (!! 9223372036854775806) . iterate ((1 +) . (1 /)) $ ( 1 :: CReal)
15:16:48 <Fredrik> :t fix
15:16:54 <lambdabot>   mueval: Prelude.read: no parse
15:16:56 <lambdabot> forall a. (a -> a) -> a
15:17:22 <Fredrik> What is this "forall a." ?
15:17:29 <mmorrow> grahamhutton: it definitely could be :)
15:17:45 <Axman6> on your marks...
15:17:47 <pumpkin> Fredrik: all it cares about is that the as are the same
15:17:48 <Axman6> get set...
15:17:51 <pumpkin> Fredrik: not what the a is
15:17:54 <Axman6> GO!
15:17:57 <tony_tony_tony_t> can anyone tell me anything about this error:  Occurs check: cannot construct the infinite type:  ?
15:18:14 <Cheshire> tony_tony_tony_t, what would you want to know about it?
15:18:18 <Axman6> tony_tony_tony_t: means the code doesn't make sense according to the type system
15:18:21 <jpcooper> grahamhutton, are you the poor guy whose CPU cycles are being wasted by this? :)
15:18:31 <pumpkin> tony_tony_tony_t: you probably tried to cons a list backwards, or put tuples into a tuple or something :)
15:18:40 <Fredrik> > fix (1:)
15:18:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:19:11 <monochrom> "tony_tony_tony_t..." is an infinite type :)
15:19:27 <Fredrik> > fix (1+)
15:19:28 <lambdabot>   * Exception: stack overflow
15:19:35 <mmorrow> , (\x -> x x)
15:19:36 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = t -> t1
15:19:37 <grahamhutton> jpcooper: no, i'm just bemused that Â£haskell at the moment seems to have decended into an eval-print loop.
15:20:06 <jpcooper> grahamhutton, well it is getting rather late
15:20:22 <grahamhutton> jpcooper: depends on your time zone :-)
15:20:24 <monochrom> It is now a mature time for a wiki page on infinite types. It comes down to having too many or too few []'s, too many or too few ->'s, etc.
15:20:35 <veckt_> hello. can somebody give me a quick answer what is haskell pros? (in comparison to other languages like c?)
15:20:45 <Fredrik> lol
15:20:45 <jpcooper> grahamhutton, I know that we're in the same one at least
15:20:47 <Fredrik> google
15:20:50 <Fredrik> wikipedia
15:20:52 <Fredrik> haskell.org
15:21:04 <Axman6> veckt_: haskell's better for everything, even speed sometimes
15:21:09 * ddarius has quite definitely had infinite types that did not come down t having "too many or too few" of any type constructors.
15:21:12 <grahamhutton> monochrom: btw, there is no theoretical reason to prohibit infinite types.  the HM inference system has cope with these fine.
15:21:16 <pumpkin> veckt_: it's completely different, it's hard to compare them directly
15:21:38 <mmorrow> you can actually derive the newtype needed to pass the typechecker given the error output for "cannot ... the infinite type .."
15:22:12 * ddarius wonders if HaRe has a "wrap in newtype" refactoring.
15:22:41 <pumpkin> hare isn't on cabal :o
15:22:46 <pumpkin> *hackage
15:22:53 <monochrom> Yes, I suspect that is why GHC error messages for that are not "improved" yet. One day it may be legit non-error.
15:23:18 <ddarius> monochrom: Unlikely.
15:23:25 <veckt_> can something be easily implemented in haskell that can't lets say in c? (sorry about these questions, my professor started to write in haskell today and i was like WTF is this?)
15:23:26 <mmorrow> i wrote a TH function to auto-derive the newtype, but it's semi-broken and i haven't revisited it to fix it yet: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=560
15:23:44 <Botje> veckt_: haskell is a much much higher level language than C.
15:24:05 <Botje> so most problems are easier to solve than in C
15:24:18 <mmorrow> it breaks when a tyvar shows up in the rhs of the "t = ..." that isn't on the lhs
15:24:22 <jpcooper> mmorrow, what is TH?
15:24:28 <mmorrow> template-haskell
15:24:32 <jpcooper> Botje, can it solve the P = NP problem? :p
15:24:34 <mmorrow> , [|42|]
15:24:36 <lunabot>  LitE (IntegerL 42)
15:24:39 <mmorrow> , $( [|42|] )
15:24:41 <lunabot>  42
15:24:45 <Botje> jpcooper: yes, but only if C can do it >:)
15:24:46 <jpcooper> aah
15:24:48 <mmorrow> , [|\x -> x|]
15:24:49 <lunabot>  LamE [VarP x_0] (VarE x_0)
15:24:57 <jpcooper> damn it
15:25:06 <mmorrow> , $(fmaps 6) (*2) [[[Node [Just 42] []]]]
15:25:08 <lunabot>  [[[Node {rootLabel = [Just 84], subForest = []}]]]
15:25:12 <mmorrow> , ppDoc `fmap` fmaps 6
15:25:14 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . fmap))))
15:25:19 <mmorrow> , ppDoc `fmap` fmaps 10
15:25:21 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fm...
15:25:25 <grahamhutton> time to leave....
15:25:35 <pumpkin> wow
15:25:42 <pumpkin> someone's in a good mood
15:25:47 <mmorrow> heh
15:25:51 <Axman6> :\
15:26:14 <Cheshire> this channel is so spammy
15:26:25 <pumpkin> that's why people made the #haskell-in-depth
15:26:25 <mmorrow> like omglol
15:26:33 <monochrom> you people are so yummy
15:26:42 <pumpkin> monochrom: cannibal
15:26:55 <jpcooper> that's why people made #sexual-deviants
15:27:00 <Botje> all the sugar lambdas are just to fatten us up :(
15:27:04 <Axman6> omlolg
15:27:17 <roconnor> Cheshire: did you get my thoughts on your Universes for discrimination
15:27:45 <Cheshire> roconnor, I think I understand the meaning of it now
15:27:50 <monochrom> Cheshire: In fact I had the same feeling two years ago too on people experimenting with the bots at extended length, like "why aren't you taking it to pm already?"  Now I'm indifferent.
15:27:54 <Cheshire> roconnor, do you have any comments about it?
15:27:59 <Cheshire> ooh
15:28:36 <roconnor> Cheshire: it seemed like something trivial
15:28:44 <roconnor> Cheshire: and there also looked like there was a small type
15:28:46 <roconnor> typo
15:28:51 <Cheshire> roconnor, I didn't get any comment or email or anything
15:29:12 <Cheshire> roconnor, but yes I agree it's trivial -- basically that the sets aren't equal is a trivial metatheorem, but it's impossible to reflect it back into U0
15:29:45 <Cheshire> (well it maybe possible by adding something like a quote operator, but the implications of that are probably horrible so I didn't think about it much)
15:29:47 <wli> > let cf (b0, cs) = case cs of { [] -> [b0] ; (a1,b1):cs' -> let recur (prev, cur) (an, bn) = (cur, an*prev + bn*cur) ;  as = scanl recur (b0, b1*b0+a1) cs' ; bs = scanl recur (1, b1) cs' in zipWith ((/) `on` fst) as bs } in take 10 $ cf (3, [(let t = 2*k-1 in t*t,6) | k <- [1..]]) :: [Double]
15:29:49 <lambdabot>   [3.0,3.1666666666666665,3.1333333333333333,3.145238095238095,3.139682539682...
15:29:50 <roconnor> it does seem impossible
15:29:51 <mmorrow> i think the people that get their panties in a bunch about collaborative bot-use need to have a wahmbulance called for them
15:29:57 <pumpkin> yeah, me too
15:30:01 <pumpkin> sometimes it's excessive
15:30:09 <pumpkin> but a lot of the time people do semi-interesting stuff
15:30:13 * pumpkin points up
15:30:36 <pumpkin> things like making recursive HAHA generators don't amuse me as much :P
15:30:44 * pumpkin stares at nikki93
15:30:51 <pumpkin> oh
15:30:52 <pumpkin> not here
15:31:06 <wli> So, the Fibonacci numbers and continued fractions get even more interesting. They're the slowest-converging continued fraction possible.
15:32:21 <roconnor> wli: you mean phi
15:32:37 <wli> There's more to the story, too. The way continued fractions are evaluated there is actually a really bad way to get numerical results.
15:32:41 <wli> Well, sure.
15:33:05 <wli> Getting good numerical results is actually somewhat nontrivial.
15:33:25 * Axman6 is listening to The Valkyrie: Ride of the Valkyries -- Motzart
15:33:30 <roconnor> I think that is why people don't use continued fractions in general
15:33:34 <Fredrik> > exp 1 ** pi - pi
15:33:35 <lambdabot>   19.99909997918947
15:33:39 <pumpkin> Axman6: I'm not sure that tag is correct :P
15:33:42 <Axman6> this was an excellent album to purchase
15:34:02 <wli> When push comes to shove, people actually do use them for the evaluation of special functions.
15:34:05 <vininim> wat
15:34:15 <roconnor> wli: ya
15:34:17 <Axman6> hmm, me either. went off what the iTunes icon told me when i right clicked it
15:34:23 <Axman6> pumpkin: Concerto for Piano and Orchestra No. 21 in C Major, K. 467: II. Andante
15:34:24 <pumpkin> Axman6: Motzart? Valkyries? :P it's Wagner
15:34:26 <pumpkin> oh
15:34:31 <pumpkin> then that is mozart :)
15:34:40 <vininim> oh I missed the exp
15:35:00 <Axman6> oh ha, had the wrong song selected, it is wagner
15:35:20 <koeien> mahler > mozart imo :)
15:35:27 <pumpkin> beethoven > mahler imo
15:35:34 <wli> I need to evaluate E_1(z) at complex arguments. The only way to really do it is via continued fractions.
15:35:44 <mmorrow> Cheshire: what is this "universes of discrimination"?
15:36:01 <Axman6> bought 'The 50 Most Essential Pieces of Classical Music' on iTunes for $20.99 AU last night
15:36:02 <wli> roconnor: Convergence criteria are also a bit hairier.
15:36:10 <pumpkin> Axman6: aw, no :'(
15:36:23 <Axman6> hmm?
15:36:23 <nominolo> @seen MarcWeber
15:36:23 <lambdabot> MarcWeber is in #haskell and #ghc. I don't know when MarcWeber last spoke.
15:36:24 <Cheshire> mmorrow, something was bugging me that if you have  data Bool = True | False  and  data Choice = Yes | No  for example you couldn't prove they are equal and you couldn't prove they are not equal
15:37:03 <Cheshire> mmorrow, so I tried some stuff out to understand it a bit more ( http://muaddibspace.blogspot.com/2009/02/universes-for-discrimination-proofs.html ) but I don't think I really got anywhere
15:37:04 <mmorrow> couldn't you use the tailor series expansion about z or something
15:37:05 <monochrom> Perhaps that is the intention. To tell users they couldn't prove anything.
15:37:12 <mmorrow> wli: couldn't you use the tailor series expansion about z or something
15:37:29 <wli> Actually, what I need is to evaluate \int_x^y \frac{pt+q}{t^2+at+b}e^{Kt}dt
15:37:43 <pumpkin> Axman6: this is probably more #haskell-blah ish actually :P
15:37:46 <mmorrow> Cheshire: what do you mean "equal"?
15:37:47 <Cheshire> mmorrow, it's not really clear what equality stated between sets means , esp. interaction with universe heirerchy
15:37:47 <Fredrik> @pl (a*b*c*d)
15:37:48 <lambdabot> a * b * c * d
15:37:51 <wli> mmorrow: Not about z, nor about 0 since it's singular at 0.
15:37:59 <mmorrow> wli: hmm
15:38:00 <Fredrik> @pl (\a b c d -> a*b*c*d)
15:38:00 <lambdabot> ((((*) .) . (*)) .) . (*)
15:38:04 <Cheshire> mmorrow, data Eq (T : Set) : T -> T -> Set where refl : (t : T) -> Eq T t t
15:38:23 <Fredrik> @pl (\a b c d e f g -> a*b*c*d*e*f*g)
15:38:24 <lambdabot> ((((((((((*) .) . (*)) .) . (*)) .) . (*)) .) . (*)) .) . (*)
15:38:27 <Fredrik> lol
15:38:33 <wli> mmorrow: Around 1 might be plausible, but leads to cancellation problems for arguments near 1 in the complex plane.
15:38:43 <mmorrow> Cheshire: well while they may be isomorphic, they're not equal by definition
15:38:47 <MarcWeber> nominolo Whats up?
15:38:55 <Cheshire> mmorrow, things like cardinality are definable just given any set, so you can show that Bool <> Direction (with constructors North South East West)
15:39:12 <nominolo> I'm polishing up scion to finally get the release out
15:39:39 <nominolo> MarcWeber: how hard do you think would it be to implement the existing Emacs server on top of your changes?
15:40:00 <wli> mmorrow: Actually the singularity at 0 is logarithmic and there is a series expansion around 0 that's usable, but it needs sufficiently small arguments to be useful. When the arguments are large enough, you want to switch to the continued fractoin.
15:40:16 <nominolo> MarcWeber: I wonder whether i should release 0.1 and then integrate and release 0.2 as soon as Vim works or whether I should work.
15:40:21 <mmorrow> wli: interesting. i'm not very familiar with using continued fractions
15:40:47 <wli> mmorrow: It's largely plug-and-chug in this area of things.
15:41:06 <mmorrow> hehe, i haven't heard the saying "plug-and-chug" for quite a while :)
15:41:13 <nominolo> MarcWeber: er, "... whether should wait."
15:41:26 <MarcWeber> nominolo I've started a bigger branch: I'm working on a daemon - scion instance solution. One instance for a project. Basically it does work... So probably you should just release it.
15:41:42 <pumpkin> back when I was a wee lad, it was quite common to hear plug and chug
15:43:07 <Axman6> plug and chug?
15:43:11 <Axman6> wut?
15:43:38 * Axman6 suspects he may have just failed at being a uni student
15:43:50 <Fredrik> @pl (\x -> x * x)
15:43:50 <lambdabot> join (*)
15:43:55 <Fredrik> :t join
15:43:55 <pumpkin> you should chug and chug
15:43:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:43:57 <nominolo> MarcWeber: how will the deamon work?  Will it just spawn a new process for each new project?
15:45:23 <MarcWeber> nominolo Exactly. Basically its the same. The daemon will only reply to simple requests such as which packages or modules are availible. Whenever some recompilation/ checking should take place the request is forwarded to a separate process (cause a thread won't do due to IORefs..)
15:45:47 <jpcooper> Axman6, your failure might actually mean success
15:45:55 <Axman6> indeed :)
15:46:24 <monochrom> "avoid success at all cost, for it may be success"?
15:46:55 <nominolo> MarcWeber: ah, so the deamon itself will be a GHC API process
15:47:43 <MarcWeber> nominolo: yes. But its main task is forwarding requests and absract over different client connections (emacs, vim, ..)
15:47:54 <nominolo> ah, I see
15:48:08 <nominolo> seems like a good idea
15:49:01 <redditbot> Announcing the Bay Area Haskell Users Group
15:49:01 <redditbot> Muad`Dib: Universes for discrimination proofs
15:49:01 <redditbot> Using Mutable Arrays for Faster Sorting
15:53:36 <nominolo> MarcWeber: Once this all works well enough I want to work on keeping track of file state on the Haskell site, too.  Do you know whether Vim can send out commands after each edit?
15:53:58 <nominolo> MarcWeber: i.e. something like (Insert 4 54 "foobar") ?
15:55:37 <wli> I wonder if continued fractions whose elements are Gaussian integers have properties anything like ordinary continued fractions.
15:56:14 <ksf> I wonder if there'll ever be an Applicative instance for that beast.
15:56:45 <ksf> I would be utterly lame if I were to write the Applicative instance in terms of that Monad instance.
15:57:00 <ksf> (which, luckily, isn't written, yet)
16:00:05 <ksf> uhmm... is there a known kind of monad that can be derived from Applicative and Alternative?
16:00:37 <ksf> (just curious)
16:00:45 <Cale> ksf: Well, something can be Applicative and Alternative without being a monad.
16:01:46 <ksf> I assume I'm confused.
16:03:43 <Cale> In order for it to be possible to define a Monad instance, you need a way to define join :: m (m a) -> m a, which means that if all the functions you have preserve the number of m's in the type rather than reducing them, you won't be able to directly define a Monad instance.
16:04:54 <NameAlreadyInUse> what is the difference between "newtype NInt = NInt Int" and "data NInt = NInt Int"?
16:05:06 <Botje> newtype gets compiled away
16:05:11 <Botje> data is a pointer indirection
16:05:23 <NameAlreadyInUse> got it
16:05:29 <ksf> thank's for painfully driving that one home, again. (seriously). That's what I'm trying to do in <*>, right now.
16:05:34 <dons> Pseudonym, ddarius do you guys remember where/when Okasaki made his recommendations on preferred parameter order for functions?
16:05:54 <ksf> (which works for empty, at least ....)
16:07:03 <ksf> I don't seem to know what I want.
16:07:33 <ksf> ...I should get to terms with Alternative, first.
16:08:23 <dons> Cale: you might remember
16:08:37 <dons> does anyone remember okasaki arguing for a particular parameter order in Hasklel?
16:09:11 <Gracenotes> that sounds interesting :)
16:09:18 <Cale> dons: The order should always be increasing in frequency of change. But I don't know about anything Okasaki said.
16:09:27 <Gracenotes> presumably the one which makes partial application the easiest
16:10:42 <dons> ah ha.
16:11:09 <dons> http://article.gmane.org/gmane.comp.lang.haskell.libraries/3650/
16:11:35 <Gracenotes> an interesting ordering I've found is that union in Data.Map is biased towards the first argument.. but incidentally, I've only had to use that order :)
16:12:07 <BONUS> not only that, putting the data structure last allows for nice foldring
16:12:35 <BONUS> foldr insert someSet [1,2,3] etc
16:12:54 <dons> the entire thread,
16:12:57 <dons>  http://thread.gmane.org/gmane.comp.lang.haskell.libraries/3622/focus=3650
16:13:06 <dons> should be linked from http://haskell.org/haskellwiki/Parameter_order
16:13:25 <Saizan> BONUS: there you actually want foldl' so you end up using flip insert
16:13:41 <BONUS> hmm
16:14:44 <Gracenotes> is there any info about type order? ;) for kinds and such
16:14:54 <Cale> Gracenotes: same thing.
16:15:04 <wli> 3/5 + 4*i/5 breaks the attempt to do similar with Gaussian integers.
16:15:05 <Gracenotes> for monads it's particularly important
16:15:08 <Cale> Gracenotes: yes
16:15:13 <dons> galois is fun. dave macqueen just casually wanders by
16:15:26 <Gracenotes> and functors. and applicatives. etc. only... there's no flipping for types
16:15:30 <wli> Basically anything on the unit circle will break the analogue in any cyclotomic extension of Z.
16:18:11 <augustss_> say hi to dave :)
16:18:55 <pumpkin_> hi dave
16:18:57 <pumpkin_> oh wait
16:19:16 <wli> ergh, any cyclotomic extension of Q
16:19:52 <dons> augustss_: :)
16:21:48 <olsner> who's dave?
16:22:14 <augustss_> the only dave mentioned in the last few minutes.  MacQueen
16:23:48 <sema4r> i have some trouble to get happy and alex installed via cabal. cabal install seems to work without errors, but cabal info doesn't know about an installed version of these packages afterwards. why is that ?
16:23:54 <olsner> but, weren't you the first to refer to dave? and that line said only "dave" without further qualification...
16:24:10 <Saizan> sema4r: because they are only executables
16:24:28 <Saizan> sema4r: you probably want to add ~/.cabal/bin to PATH
16:24:32 <augustss_> olsner: dons 9 minutes ago
16:24:39 <Saizan> sema4r: so that they can be found automatically
16:26:01 <olsner> augustss_: aaah, there! now I see it... so I gather he's a famous guy who works at galois then?
16:26:40 <augustss_> olsner: I'd be surprised if he works for galois, but he is famous
16:26:43 <sema4r> Saizan: did that already, but sudo gives a * about that.
16:28:47 <TomMD> dons: ping
16:28:59 <dons> TomMD: pong
16:29:27 <TomMD> hey dons - I just downloaded Cryptol and wanted to compile the MD6 implementation (benchmark against C for fun)
16:29:37 <TomMD> dons: but cryptol doesn't seem to like arch
16:29:44 <TomMD> I extracted the rpm using rpmextract
16:30:20 <dons> what goes wrong?
16:30:20 <TomMD> but the binary immediately exits with "bash: ./cryptol: No such file Or directory"
16:30:29 <dons> there's a new release due today, iirc
16:30:36 <TomMD> oh, I will try that
16:30:37 <dons> so i'll report this upstream, and let you know when its up
16:30:50 <TomMD> ok - just figured I'd ask seeing as I know you use arch.
16:30:59 <MarcWeber> nominolo Yes, there is a insert mode leave autocommand which you can use to trigger any action
16:31:38 <jberryman> speaking of Map: it isn't stable so can't do duplicate keys, correct? has anyone wished for that functionality?
16:32:25 <MarcWeber> nominolo: I've comitted my work now. Don't expect it to be either usabele or compilabel by now
16:32:44 <MarcWeber> (branch server_and_instances)
16:33:21 <MarcWeber> src-scion-daemon/Scion/Daemon/Types.hs defines the protocol
16:34:37 * BMeph thinks that "someone" needs to write up a cookbook to help guide the poor Java/Python folks to see how higher-order functions are better than control flow doodads.
16:35:20 * BMeph almost wishes he were competent enough to be that "someone", just so it would get done sometime this decade...
16:36:15 <nominolo> BMeph: why not start with something and then let others chime in?
16:37:46 <mmorrow> dons: are there plans to open-souce cryptol at any point?
16:38:23 <dons> i'm not sure of the precise plans. we do want the language to be the standard notation for cryptography though.
16:38:23 <MarcWeber> nominolo: About the compilation result: I 'll have to introduce a data type to pass the error lines over to the server. How much infomation is needed? Is the first error location enough or shall I try passing es much information as possible (list of error ranges) ?
16:39:01 <mmorrow> dons: interesting, so i take that as a "possibly" :)
16:39:25 <vincenz> :t mouseDrag
16:39:26 <lambdabot> Not in scope: `mouseDrag'
16:39:31 <vincenz> @hoogle mouseDrag
16:39:31 <lambdabot> No results found
16:39:33 <nominolo> dons: ambitious
16:39:41 <vincenz> @hayoo mouseDrag
16:39:41 <lambdabot> Unknown command, try @list
16:39:44 <nominolo> MarcWeber: what's the use case?
16:39:51 <dons> mmorrow: its possible the interpreter implementation could be, yes.
16:40:11 <nomeata> Hi. With haddock2, can anyone tell me whether the interface files are architecture depenent or not?
16:40:11 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
16:40:29 <dons> since the language itself is already out there, open and free.
16:40:36 <dons> you can implement it yourself
16:40:40 <mmorrow> dons: but the compiler itself would remain closed?
16:40:41 <MarcWeber> nominolo Passing error locations from the instance doing the syntax checking over to the daemon serving the client. I can't just use Read, Show cause not all contsructors are exported :-(
16:40:48 <mmorrow> dons: oh? cool. i'll have to get the spec
16:40:51 <nominolo> MarcWeber: We have no guarantee to have a unique mapping from source location to error messages
16:40:52 <dons> mmorrow: well, galois has a few compilers, and an interpreter
16:41:04 <dons> the verifying compiler is absolutely staying closed, i would say
16:41:12 <mmorrow> dons: well, what i'm really wondering about is the FPGA related code :)
16:41:17 <dons> since verifying cryptol against hand written C or VHDL is kinda valuable
16:41:19 <nomeata> lambdabot: @tell gwern that it should be working, and that I donâ€™t check my lambdabot messages regulary :-)
16:41:20 <lambdabot> Consider it noted.
16:41:31 <dons> mmorrow: that's more case-by-case currently, depending on what you want to do.
16:41:47 <nominolo> MarcWeber: Adding a wrapper type would probably not be a bad idea
16:42:08 <mmorrow> dons: hmm, i'm not sure at this point
16:42:20 <MarcWeber> nominolo Ok. I'll try to do the most simple type first. We can extend it later.
16:42:27 <dons> you want to generate fast FPGAs doing streamy/mathy/crypto/DSP-ish stuff?
16:42:31 <nominolo> MarcWeber: I.e., use an internal type for error messages.  This also allows us to put any magic (like classification of the message) into the conversion step
16:42:43 <mmorrow> dons: i want to generate FPGAs in general
16:42:51 <dons> then the cryptol tool chain is kinda good for that. depends on if you're doing research or commerce, i think, how it gets licensed.
16:43:03 <mmorrow> dons: ah, i see
16:43:10 <pumpkin_> how bout academia?
16:43:20 <dons> i'm not an expert on that stuff. you might just want to contact the cryptol dev team
16:43:25 <nominolo> MarcWeber: yep, start simple
16:43:33 <pumpkin_> ok
16:43:34 <dons> pumpkin_: pretty sure we make it available to anyone doing research
16:43:46 <pumpkin_> cool :)
16:43:49 <nominolo> MarcWeber: that's a good strategy in almost every case :)
16:43:51 <mmorrow> dons: but, are these tools made available with source? or just in binary form?
16:44:17 <dons> not sure. source in some cases, i imagine. but you best ping the team
16:44:18 <mmorrow> (with whatever the license happens to be, etc)
16:44:33 <dons> you want to validate the compiler on itself? :)
16:45:03 <mmorrow> dons: hehe
16:45:34 <mmorrow> dons: i'm interesting in reduceron-type stuff in particular
16:46:13 <dons> we've thought about that. the AST is a bit hard to do in FPGAs
16:46:35 <dons> but if you can reformulate an SKI machine as a streaming algorithm, it might be easy
16:46:50 <mmorrow> interesting
16:47:28 <mmorrow> i wonder what a massively parallel bytecode-executing VM would look like
16:47:33 <dons> mm
16:49:04 <redditbot> the Patch-Tag blog
16:49:16 <ksf> donss, mmorrow, http://www.youtube.com/watch?v=w8ubXgXM7kk
16:50:12 <olsner> argh, stop sending interesting stuff at bedtime :)
16:50:43 <ksf> it's easy-going, you can watch it half-asleep.
16:50:50 <ksf> but very fascinating.
16:50:54 <ozy`> mmorrow: http://www.youtube.com/watch?v=qyXFN4ocN_o <- I'm gonna guess this...
16:51:22 * ozy` makes a note to avoid total non-sequiturs in the future
16:51:46 <mmorrow> ksf: sweet
16:52:01 <mmorrow> ozy`: nice! your codez on FPGAs?
16:52:02 <dons> there's some guy who on every haskell post about why its ready brings up the overloaded record labels issue
16:52:14 <dons> people are weird
16:52:14 <mmorrow> heh
16:52:36 <Philippa_> to be fair, it's one of the first things to leap out at people as clearly, unambiguously painful
16:52:59 <ksf> YO DAWG I HEARD YOU LIKE FPS SO I BROUGHT YOU A CAN OF GPU TO FIX YOUR GPU
16:53:17 <pumpkin_> dons: the Muri guy and his "proof" that haskell is doomed to failure?
16:53:48 <ozy`> dons: was that the same guy who was totally obsessed with C++? (and who then went into #c++ and talked nonstop about haskell?)
16:54:21 <Philippa_> it's also one of the first things I'd put on the todo list if I were to design a "better Haskell than Haskell" that aimed to take advantage of the sketched-out design space while starting from a clean slate
16:54:29 <TomMD> ksf: Yo Dawg, SPJ heard you like type inferencing, so he put a type in your type so now you can inference after you've inferenced.
16:54:49 <pumpkin_> after??
16:54:51 <pumpkin_> that's just wrong.
16:54:54 <Philippa_> while, surely
16:55:30 <mmorrow> SML records rock
16:55:42 <newsham> dons: easy soln, put all your records in different modules :)
16:56:09 <chessguy_> is there a way to do a Monoid constraint like this? http://codepad.org/k5v4NTzF
16:56:11 <mmorrow> {x=42, omg="lol"} : {x : int, omg : string}
16:56:29 <mmorrow> {x=42, lol="lol"} : {x : int, lol : string}
16:56:39 <mmorrow> etc
16:56:53 <ksf> didn't we sort this out in the cafe? fixing records by allowing inline modules?
16:57:00 <wli> What rock about SML records?
16:57:07 <ksf> someone needs do claim that spj can't implement it.
16:57:19 <mmorrow> that the record labels are part of the type is what i like
16:57:41 <mmorrow> and you can dynamically records with new labels
16:57:48 <mmorrow> (is what i think is cool)
16:57:53 <dons> augustss_: next stop: implement Lisp in Haskell on LLVM and rule the interwebs. (see e.g. http://paste.lisp.org/display/74068 )
16:58:01 <ozy`> mmorrow: did you accidentally a verb there?
16:58:48 <mmorrow> ozy`: no, just extending my deverbification initiative to irc
16:59:13 <ozy`> mmorrow:
16:59:25 <ksf> w00t! I read about rediciously depentent types before dons reditted it!
16:59:40 <mmorrow> ozy`: perfect
16:59:44 <chessguy_> @here hpaste2
16:59:45 <lambdabot> http://hpaste.org/
16:59:50 <ozy`> ksf: that's only because he was busy fighting a gang of ninjas
17:00:10 <mmorrow> teh foot clan
17:00:23 <ozy`> (by which I mean "performing top-secret assassinations on behalf of the ministry of safety and happiness")
17:00:36 <chessguy_> can someone explain this error message to me? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1552#a1552
17:01:13 <chessguy_> i intended s to be of kind * -> * -> *
17:01:20 <mmorrow> chessguy_: since Monoid (s a), the kind is infered as being :: * -> *
17:01:24 <chessguy_> @kind Data.Map.Map
17:01:25 <lambdabot> * -> * -> *
17:01:48 <chessguy_> mmorrow:  the kid of s, or of "s a"?
17:01:49 <BMeph> How sad...
17:01:50 <ksf> errr.... s is * -> * .
17:01:58 <mmorrow> @kind forall m. Monoid m => m
17:01:59 <lambdabot> *
17:02:00 <ksf> did you mean S a b -> a -> b?
17:02:28 <chessguy_> ksf:  S is a class
17:02:28 <mmorrow> yeah, the kind of `s'
17:02:49 <mmorrow> so "s a b" isn't valid
17:02:56 <chessguy_> err
17:02:56 <BMeph> I look away from the screen for ten measley minutes, and y'all go out an "Sup dawg" someone.
17:03:14 <chessguy_> herm
17:03:15 <mmorrow> but it would be if you said "Monoid (s a b)"
17:03:32 <mmorrow> but it might complain about the `b' there
17:03:35 <mmorrow> (or not?)
17:03:42 <chessguy_> hm, that's not what i want
17:04:01 <chessguy_> i want s to be of kind * -> * -> *
17:04:07 <chessguy_> and s a to be of kind * -> *
17:04:14 <mmorrow> exactly
17:04:19 <mmorrow> so you want Monoid (s a b)
17:04:21 <chessguy_> so that then "s a" can be a monoid
17:04:27 <mmorrow> @kind forall m. Monoid m => m
17:04:28 <lambdabot> *
17:04:34 <mmorrow> s a :: * -> *
17:04:58 <chessguy_> but the m in "Monoid m" is * -> *
17:05:08 <mmorrow> @kind forall m. Monoid m => m
17:05:09 <lambdabot> *
17:05:10 <mmorrow> :)
17:05:15 <chessguy_> err
17:05:26 <mmorrow> you mean Monad?
17:05:30 <chessguy_> no
17:05:32 <chessguy_> i mean Monoid
17:05:38 <mmorrow> MonadPlus?
17:05:45 <mmorrow> @kind forall m. MonadPlus m => m
17:05:46 <lambdabot>     `m' is not applied to enough type arguments
17:05:46 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
17:05:49 <mmorrow> @kind forall m. MonadPlus m => m a
17:05:50 <lambdabot> Not in scope: type variable `a'
17:05:52 <mmorrow> gah
17:05:54 <chessguy_> dude
17:05:55 <mmorrow> m :: * -> *
17:05:59 <chessguy_> i mean Monoid, trust me :)
17:06:08 <mmorrow> then that doesn't work
17:06:19 <mmorrow> because the m in Monoid m is :: *
17:06:28 <chessguy_> @kind []
17:06:29 <lambdabot> * -> *
17:06:42 <mmorrow> instance Monoid [a] where ...
17:06:49 <chessguy_> oh!
17:07:11 <ksf> instance Mongol GenghisKahn where loot = burn = repeat
17:07:24 <chessguy_> but in the case of Monad, it would be instance Monoid [] ?
17:07:33 <chessguy_> err, instance Monad []
17:07:35 <mmorrow> instance Monad [] where ...
17:07:38 <mmorrow> exactyly
17:07:39 <chessguy_> ok
17:07:56 <chessguy_> ok, that makes more sense
17:07:58 <chessguy_> i think
17:08:13 <chessguy_> @src Monoid
17:08:14 <lambdabot> class Monoid a where
17:08:14 <lambdabot>     mempty  :: a
17:08:14 <lambdabot>     mappend :: a -> a -> a
17:08:14 <lambdabot>     mconcat :: [a] -> a
17:08:46 <mmorrow> and the default for mconcat = foldr mappend mempty
17:09:08 <mmorrow> (which is wrong for Sum, etc)
17:09:30 <chessguy_> but it does complain about the b then
17:09:34 <mmorrow> ie wrong for mappends that are infixl
17:09:34 <chessguy_> :(
17:09:41 <nominolo> mmorrow: the difficulties with SML-style records are manyfold:  records are structurally typed (hence equal up to permuntation), but in the presence of _|_ order can make a difference
17:10:25 <nominolo> mmorrow: also, the main issue is that SPJ would like to only change the frontend (i.e. parser + typechecker), but not Core
17:11:37 <chessguy_> @src arrow
17:11:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:11:41 <chessguy_> @src Arrow
17:11:41 <lambdabot> class Arrow a where
17:11:41 <lambdabot>     arr, pure   :: (b -> c) -> a b c
17:11:41 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
17:11:41 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
17:11:41 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
17:11:43 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
17:11:45 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
17:11:49 <chessguy_> take that, rutabaga!
17:11:57 <mmorrow> nominolo: yeah, i think the core would need changing for such records, as well as for ML-like modules
17:13:03 <mmorrow> so i guess i'm not necessarily saying that this is feasible for haskell since it would require a different language definition
17:13:18 <nominolo> I was planning to start a GHC branch once the switch to Git is complete.  As it is, it's extremely tiresome to maintain a long-runninng fork in darcs
17:13:44 <mmorrow> someone said yesterday they git cloned ghc in like a minute and a half
17:13:47 <mmorrow> !
17:13:52 <dibblego> @src (>=>)
17:13:52 <lambdabot> Source not found. That's something I cannot allow to happen.
17:13:57 <dibblego> @src Control.Monad.(>=>)
17:13:58 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:14:02 <nominolo> mmorrow: we have a mirror since last summer
17:14:10 <mmorrow> where is it, i don't recall
17:14:12 <mmorrow> ?
17:14:34 <mmorrow> http://darcs.haskell.org/ghc.git/
17:14:36 <mmorrow> heh
17:14:38 <nominolo> mmorrow: but main development is still in darcs.  the switch is supposed to happen after 6.10.2, so that backporting isn't an issue anymore
17:15:09 <mmorrow> ah, so what's not actually a mirror of HEAD then i take it (?)
17:15:15 <mmorrow> s/what's/that's/
17:15:23 <nominolo> mmorrow: yeah, i should update the sync-script, lots of "Ignore-this: blah" shows up in the commit messages
17:15:31 <nominolo> mmorrow: it is
17:15:38 <mmorrow> oh, cool
17:15:48 <mmorrow> gah, gotta run
17:15:54 <nominolo> mmorrow: but the built-tools are not yet updated to work well with it
17:17:46 <dons> http://community.bartdesmet.net/blogs/bart/archive/2009/02/19/type-theory-essentials-in-pictures-part-1-quiz.aspx
17:18:04 <dons> that i'm not so sure about
17:18:18 <dons> i was really hoping for type theory in pictures
17:25:13 <dibblego> how is (>=>) pronounced?
17:25:21 <dibblego> kleisli operator?
17:29:00 <shapr> dibblego: rocket ship?
17:29:08 <dibblego> ha
17:29:26 <shapr> firework?
17:29:59 * shapr goes back to working on his STM presentation.
17:30:02 <BMeph> "The Kleene Arrow"? <ducks>
17:35:02 <Cale> dibblego: Kleisli composition.
17:35:10 <Cale> BMeph: not Kleene!
17:35:28 <Cale> Wrong mathematician :)
17:35:48 <BMeph> Cale: Thanks. They're all "stars" to me. ;p
17:36:20 <Cale> heh
17:36:34 <dibblego> Cale, thanks
17:40:28 <wli> I guess since there's no such thing as a positive Gaussian integer, the problems go away when you choose the Gaussian integer nearest to the element of Q(i).
17:40:48 <mauke> so I wrote a unicode by name lookup thing in javascript: http://mauke.ath.cx/stuff/javascript/unicode.html
17:40:58 <mauke> does this seem useful?
17:42:06 <BMeph> wli: What's your defn of "near"? :)
17:43:20 <wli> BMeph: The square of the distance from x + i*y to x' + i*y' is (x-x')^2 + (y-y')^2
17:48:20 <roconnor> > abs (x' :+ y' -  (x :+ i*y))
17:48:21 <lambdabot>   Not in scope: `x''    precedence parsing error
17:48:21 <lambdabot>          cannot mix `(:+)' [...
17:48:31 <roconnor> > abs (a :+ b -  (x :+ y))
17:48:32 <lambdabot>       precedence parsing error
17:48:32 <lambdabot>          cannot mix `(:+)' [infix 6] and `(-)'...
17:48:43 <roconnor> > abs ((a :+ b) -  (x :+ y))
17:48:44 <lambdabot>       No instance for (RealFloat Expr)
17:48:44 <lambdabot>        arising from a use of `-' at <i...
17:48:47 <wli> Well, this is Q(i)/Z[i] stuff.
17:49:02 <roconnor> aww
17:49:07 <roconnor> stupid Complex
17:49:09 <tehgeekmeister> @type (=<< mapM_)
17:49:10 <lambdabot> forall b a (m :: * -> *) b1. (Monad m) => (([a] -> m ()) -> (a -> m b1) -> b) -> (a -> m b1) -> b
17:49:13 <monochrom> mauke: GNOME has a "character map" program that also does a similar search (plus other things like Windows "character pallete" functions).
17:49:18 <wli> It's finding continued fraction expansions of things in Q(i) analogous to those for Q in the real case.
17:49:24 <tehgeekmeister> @type (>>= mapM_)
17:49:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ([a] -> a -> m b) -> [a] -> m ()
17:49:35 <monochrom> I suppose your web page is useful to those who are on KDE.  <duck>
17:50:05 <tehgeekmeister> @type (\f xs -> xs >>= mapM_ f)
17:50:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m ()
17:50:25 <tehgeekmeister> @type (\f xs -> xs >>= forM_ f)
17:50:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> m (a -> m b) -> m ()
17:50:39 <tehgeekmeister> @pl (\f xs -> xs >>= forM_ f)
17:50:39 <lambdabot> (=<<) . forM_
17:51:23 <tehgeekmeister> @pl  (\f xs -> xs >>= mapM_ f)
17:51:23 <lambdabot> (=<<) . mapM_
17:55:51 <mmorrow> mauke: sweet. the reverse lookup would be nice too (where e.g. "alpha" would return greek alpha)
17:56:07 <mmorrow> mauke: this might be relevant/useful too http://darcs.haskell.org/yhc/src/translator/js/lib/javascript/JUCD.js
17:56:07 <mauke> er, it does?
17:56:22 <mmorrow> mauke: oh sweet, i didn't try it yet
17:56:38 <mauke> U+1f8f  (8079): GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI [á¾]
17:56:42 <mauke> you know you want it
17:56:59 <mmorrow> heh
17:57:08 <mmorrow> i just tried "alpha" and  nothing came back
17:57:15 <hotaru2k3> i have a bit of code that looks like this: f (g . h $ div a b) (h $ mod a b)
17:57:26 <hotaru2k3> is there a good way to use divMod instead of div and mod?
17:57:41 <mauke> mmorrow: your firefox is too old
17:57:48 <mmorrow> mauke: grrr
17:57:48 <mauke> because I was lazy and used map()
17:58:14 <mmorrow> i have to bite the bullet anyways and upgrade from fedora8 sooner or later...
17:59:13 <mmorrow> mauke: oh nice, i didn't scroll all the way down in the code at first
17:59:41 <mmorrow> mauke: this would be a killer thing to add to preflex
17:59:54 <mmorrow> preflex: u alpha
18:00:14 <mauke>  â¶
18:00:22 <mmorrow> it worked!
18:00:26 <monochrom> GNOME "character map" can search both directions.
18:00:30 <mauke> this is actually a port of the script integrated into my irc client :-)
18:00:45 <ksf> hotaru2k3, let (d, m) = divMod a b in f (g. h d) (h m)
18:00:57 <mmorrow> monochrom: oh sweet, news to me
18:01:09 <ksf> ...or is ghc smart enough, anyway?
18:01:14 <BMeph> mauke: Not to rain on your parade, but is it intentional that your combining glyphs combine with the open (square) bracket? :)
18:01:52 <mauke> BMeph: it's an accidental feature :-)
18:02:14 <BMeph> mauke: WOOT! It's a Feature! ;p
18:02:26 <mmorrow> "damnit! it's not a bug it's a feature!!"
18:02:54 <tehgeekmeister> is there some document of some sort somewhere that can help me understand laziness a bit more in depth?  i want to know better how to design my code to take advantage of laziness.
18:03:21 * ksf resists the temptation to recommend sicp
18:03:48 <tehgeekmeister> i want to read that anyway, but i don't think it's quite so focused
18:03:54 <tehgeekmeister> as what i'm looking for
18:04:03 <BMeph> tehgeekmeister: If you find one, let me know - figuring out when things get evaluated (or not) in Lisp drives me nuts. :\
18:04:17 <ksf> but it's got good sections on laziness.
18:04:29 <ksf> explicit laziness, though.
18:04:36 <BMeph> ksf: I'll keep plugging away at "sick-up" then, thanks. :)
18:05:13 <ksf> ...and, afair, an exercise that tells you to rewrite the given compiler into a lazy one...
18:05:22 <ksf> ...or maybe only the interpreter.
18:05:33 * BMeph now wants a T-shirt that has, in three layers: "Parental Advisory", "HASKELL", "Explicit Lazyness"
18:06:18 <ksf> haskell definitely needs a book that has exercises like "develop a proof engine for dependent typing on the type level"
18:06:47 <tehgeekmeister> hmm i think i made a constant space infinite loop.
18:07:07 <NameAlreadyInUse> is that harder than it sounds?
18:07:26 <ksf> it is, usually haskell just throws <<loop>> at you.
18:08:07 <tehgeekmeister> i didn't try to, that's for sure.
18:08:12 <tehgeekmeister> it should've terminated by now.
18:09:16 <ksf> nah, I guess oleg is taking his daily 5-minute sleep, so he can't evaluate your program.
18:13:33 <tehgeekmeister> oh, yeah, i did make an infinite loop.
18:13:42 <tehgeekmeister> pretty spiffy.
18:19:41 <necroforest> Is there a haskell function that takes a list of lists and flips the "rows" and "columns"? I.e, if you have [[a,b],[c,d]] it would produce[[a,c],[b,d]]
18:20:02 <sjanssen> > transpose ["ab", "cd"]
18:20:03 <lambdabot>   ["ac","bd"]
18:20:09 <necroforest> thanks!
18:20:21 <MyCatVerbs> @index transpose
18:20:21 <lambdabot> Data.List
18:20:35 <mauke> > transpose [[a,b],[c,d]]
18:20:36 <lambdabot>   [[a,c],[b,d]]
18:20:38 <mmorrow> @src transpose
18:20:39 <lambdabot> transpose []             = []
18:20:39 <lambdabot> transpose ([]   : xss)   = transpose xss
18:20:39 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
18:20:40 <mauke> tee hee
18:20:44 <MyCatVerbs> So that's where that ba... um, function was hiding.
18:23:20 <necroforest> next question.. is there a function that takes a list and  number and splits it up, i.e "abcde" 2 -> "ab", "cd", "e" ?
18:24:22 <mauke> not in the standard libraries
18:35:01 <jberryma1> necroforest: try unfoldr with splitAt maybe?
18:35:41 <MyCatVerbs> necroforest: I find myself wanting that surprisingly often.
18:35:48 <MyCatVerbs> @bot
18:35:48 <lambdabot> :)
18:35:48 <lunabot>  :)
18:36:11 <realtime> :)
18:36:57 <meatloaf> hi, i have a "thinking functionally" question. if i have a "Box" object that i organize as a collection of functions that take a value, where do i hold the value?
18:37:13 <meatloaf> like. myBox.x(p)
18:37:22 <necroforest> that transpose function doesn't do quite what i thought it did..
18:37:39 <necroforest> transposing ["ab","cd","ef","gh","ij","kl","mn","op"] yeilds ["acegikmo","bdfhjlnp"]
18:37:48 <necroforest> well
18:37:50 <necroforest> nevermind
18:38:03 <necroforest> i'm stupid
18:38:28 <MyCatVerbs> necroforest: I kinda doubt it.
18:38:41 <MyCatVerbs> > let chunks n l = case splitAt n l of { ([],_) -> [] ; (front,back) -> front : chunks n back; } in chunks 2 ['a'..'z']
18:38:42 <lambdabot>   ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
18:39:06 <jberryma1> meatloaf: can you explain a bit more?
18:39:13 <MyCatVerbs> I'm now sure why that isn't in Data.List already, to be honest.
18:40:21 <meatloaf> jberryma1: hi. well my "Box class" is more like a module i guess, if i want to create an instance, how do i do that? sorry for the oop speak :/
18:41:07 <MyCatVerbs> meatloaf: usually what you'd do in Haskell is make a data type that stores all of the data that you want bundled up together into an object, and then define a bunch of functions that take it as a parameter and return things from it.
18:41:38 <wli> chunk n = unfoldr (\xs -> do guard . not $ null xs ; return $ splitAt n xs)
18:41:43 <angerman> oh boy there is so little doc on com... haha. who would want to work with com in the first place ;) :/
18:42:03 <MyCatVerbs> You can just about map C++-style OO into Haskell, but it isn't entirely pretty, IMO.
18:42:33 <meatloaf> MyCatVerbs: i guess i was thinking, those group data types could be functions as well
18:42:43 <meatloaf> or collections of functions
18:42:53 <hackage> Uploaded to hackage: monad-loops 0.3.0.2
18:42:54 <jberryma1> is there really no function that tests a value and applies a function (a->a) to it if true and nothing if False?
18:43:08 <jberryma1> I've wanted to use that like 3 times in the last hour
18:43:32 <MyCatVerbs> jberryma1: you're talking the Monad instance for Maybe, by the sound of it.
18:44:26 <MyCatVerbs> jberryma1: you want to take a function f :: (a -> a), and a value of type Maybe x, and have Nothing yield Nothing and Just x yield Just (f x), right?
18:44:43 <wli> chunk = unfoldr . ap ((>>) . guard . not . null) . (return .) . splitAt
18:44:58 <llayland> or (\
18:45:07 <llayland> I hate this keyboard
18:45:20 <necroforest> can you split a string into multiple lines? like the \ at the en dof the line in C?
18:45:30 <llayland> or did you mean (\p f -> if p then f else id)?
18:45:31 <MyCatVerbs> jberryma1: there's a Functor instance for the Maybe datatype that does just that. You can "lift" ordinary functions to make them work on things wrapped in Maybes by using fmap.
18:45:33 <hotaru2k3> > let chunk n l = case l of {[] -> []; _ -> take n l : (chunk n $ drop n l)} in chunk 2 ['a'..'z']
18:45:34 <lambdabot>   ["ab","cd","ef","gh","ij","kl","mn","op","qr","st","uv","wx","yz"]
18:45:42 <MyCatVerbs> necroforest: there's a function called "lines" in the Prelude.
18:45:58 <necroforest> oops, i mean in your source code
18:46:01 <necroforest> i guess you can just use ++
18:46:04 <chessguy> @src Arrow
18:46:04 <lambdabot> class Arrow a where
18:46:04 <lambdabot>     arr, pure   :: (b -> c) -> a b c
18:46:04 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
18:46:04 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
18:46:04 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
18:46:06 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
18:46:08 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
18:46:20 <wli> I still like chunk n = unfoldr (\xs -> do guard . not $ null xs ; return $ splitAt n xs)
18:46:40 <meatloaf> MyCatVerbs: thanks, i think i have a clearer idea now
18:46:53 <jberryma1> MyCatVerbs: thanks, I know about maybe. I'd like to say map over a list and apply a function to only elements that the Bool function returns True on
18:46:55 <MyCatVerbs> necroforest: oh, heh. AFAIK you have to use (++), but don't quote me on that.
18:47:57 <MyCatVerbs> jberryma1: ah! There's nothing that does that straight off in the standard libraries, but you can write it easily.
18:48:44 <MyCatVerbs> > let perhapsMap function predicate = map (\x -> if predicate x then f x else x) in perhapsMap (+1) odd [1..10]
18:48:45 <lambdabot>   Add a type signature
18:48:52 <MyCatVerbs> > let perhapsMap function predicate = map (\x -> if predicate x then f x else x) in perhapsMap (+1) odd [1..10::Int]
18:48:53 <lambdabot>       No instance for (SimpleReflect.FromExpr Int)
18:48:53 <lambdabot>        arising from a use ...
18:49:03 <MyCatVerbs> > let perhapsMap function predicate = map (\x -> if predicate x then function x else x) in perhapsMap (+1) odd [1..10::Int]
18:49:05 <lambdabot>   [2,2,4,4,6,6,8,8,10,10]
18:49:12 * MyCatVerbs grumbles.
18:49:37 <MyCatVerbs> Damn alpha equivalence, always bitin' me in the butt.
18:50:06 <MyCatVerbs> meatloaf: oh yay. Good luck. ^^
18:50:15 <wli> chunk n = unfoldr \l -> guard (not $ null l) >> (return $ splitAt n l)
18:50:24 <wli> Same number of characters as the case version.
18:50:39 <MyCatVerbs> wli: that's eating away at the inside of your skull now, isn't it?
18:50:43 <jberryma1> MyCatVerbs: yeah, I suppose even better would be eitherApply :: (a->b) -> (a->b) -> (a->Bool) -> a -> b
18:51:07 <jberryma1> could pass id when I want what you just wrote
18:51:16 <wli> MyCatVerbs: Not really. Golfing is kind of mindless.
18:51:56 <MyCatVerbs> > let eitherApply f g p = map (\x -> if p x then f x else g x) in eitherApply (+1) (2*) odd [1..10]
18:51:57 <lambdabot>   [2,4,4,8,6,12,8,16,10,20]
18:52:01 <wli> Maybe better to use s vs. l
18:52:36 <MyCatVerbs> wli: I'm curious as to which way is faster, though - unfoldr or the explicit recursion.
18:53:08 <wli> chunk n = unfoldr \s -> guard (not $ null s) >> return (splitAt n s) -- 2 chars shorter than case
18:53:43 <MyCatVerbs> wli: you're optimizing for the wrong thing. Golf on identifiers, not characters. :D
18:53:48 <dolio> dons: If you have an immutable array algorithm that needs a sort, you just put "apply sort" in the pipeline.
18:54:11 <wli> MyCatVerbs: Not too worried about that.
18:54:43 <dolio> dons: Apply currently uses, essentially, "newU (length iarr) (\marr -> copyMU marr iarr >> ...)". Is that good enough to fuse well, or do I need to look at unstreamMU?
18:54:55 <wli> Just getting monad goodness going in such a manner as to pass the terseness criterion.
18:55:09 <MyCatVerbs> wli: aw c'mon. Live up the alpha equivalence. :)
18:55:43 <wli> I wonder if there could be an unfoldr in such a manner as to use MonadZero.
18:58:05 <dolio> wli: It needs to detect the zeros somehow, which MonadZero doesn't provide for. So I doubt it.
18:58:27 <wli> Yeah, I wonder how the heck to use MonadZero.
18:58:38 <wli> Or MonadPlus, I guess.
19:01:03 <dolio> @type let u f s = (f s >>= \(e,s') -> (e:) <$> u f s') `mplus` return [] in u
19:01:04 <lambdabot> forall t (m :: * -> *) t1. (MonadPlus m, Functor m) => (t -> m (t1, t)) -> t -> m [t1]
19:02:45 <dolio> > let u f s = (f s >>= \(e,s') -> (e:) <$> u f s') `mplus` return [] in u (\n -> if n < 10 then Just (n,n+1) else Nothing) 0
19:02:47 <lambdabot>   Just [0,1,2,3,4,5,6,7,8,9]
19:03:08 <dolio> > let u f s = (f s >>= \(e,s') -> (e:) <$> u f s') `mplus` return [] in u (\n -> Just (n,n+1)) 0
19:03:11 <lambdabot>   * Exception: stack overflow
19:04:01 <mmorrow> , [$ty| apply sort |]
19:04:05 <lunabot>  forall a . (UA a, Ord a) => UArr a -> UArr a
19:04:13 <mmorrow> , [$ty| sort |]
19:04:15 <dolio> > let u f s = (f s >>= \(e,s') -> (e:) <$> u f s') `mplus` return [] in u (\n -> if n < 10 then [(n,n+1)] else []) 0
19:04:16 <lunabot>  forall a b . (UA b, Ord b) => MUArr b a -> ST a ()
19:04:16 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9],[0,1,2,3,4,5,6,7,8],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6...
19:12:46 <wli> > let primes = nubBy (((>1) .) . gcd) [2..] ; unfoldM f x = do { (y, x') <- f x ; ys <- unfoldM f x' ; return $ y : ys } `mplus` return [] ; chunk n = unfoldM $ \s -> guard (not $ null s) >> return (splitAt n s) in liftM catMaybes $ unfoldM (\(n, ~(p:ps)) -> let (q, r) = n `divMod` p in guard (n /= 1) >> return (if r == 0 then (Just p, (q, p:ps)) else (Nothing, (n, ps)))) (31*47*53, primes) :: Maybe [Integer]
19:12:48 <lambdabot>   Just [31,47,53]
19:13:23 <mmorrow> , [$ty| fromU . apply sort . toU |]
19:13:25 <lunabot>  forall a . (UA a, Ord a) => [] a -> [] a
19:13:59 <mmorrow> i wonder if/when that'd be faster than Data.List.Sort
19:14:28 <mmorrow> (fast wrt clock-time)
19:14:32 <mmorrow> *faster
19:18:59 <angerman> does anyone have some experience with the com module?
19:26:02 <wli> Strange thing shappen with [[Integer]] instead of Maybe Integer
19:26:22 <wli> > let primes = nubBy (((>1) .) . gcd) [2..] ; unfoldM f x = do { (y, x') <- f x ; ys <- unfoldM f x' ; return $ y : ys } `mplus` return [] ; chunk n = unfoldM $ \s -> guard (not $ null s) >> return (splitAt n s) in liftM catMaybes $ unfoldM (\(n, ~(p:ps)) -> let (q, r) = n `divMod` p in guard (n /= 1) >> return (if r == 0 then (Just p, (q, p:ps)) else (Nothing, (n, ps)))) (31*47*53, primes) :: [[Integer]]
19:26:23 <lambdabot>   [[31,47,53],[31,47],[31,47],[31],[31],[31],[31],[31],[],[],[],[],[],[],[],[...
19:26:41 <wli> The outermost list is finite.
19:28:46 * jberryma1 is happy to finally have a simple pretty print function for his tree module
19:29:18 <jberryma1> if anyone wants to see it, it's here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1555#a1555
19:32:01 * stepcut is still trying to test the ixset patch :(
19:38:50 <mmorrow> jberryma1: i've stolen this function many times over http://www.haskell.org/ghc/dist/current/docs/libraries/containers/src/Data-Tree.html#drawTree
19:38:56 <mmorrow> it's a nice one
19:40:12 <mmorrow> , text . drawTree . fmap show $ (Node 0 [Node 1 [], Node 2 []])
19:40:13 <lunabot>  0
19:40:13 <lunabot>  |
19:40:13 <lunabot>  +- 1
19:40:26 <mmorrow> |
19:40:28 <mmorrow> `- 2
19:45:21 <Gracenotes> unlambda seems thoroughly... useless :/
19:45:29 <Gracenotes> other than for theoretical purposes
19:46:34 * tehgeekmeister shudders at mention of unlambda
19:46:38 <tehgeekmeister> it's worth than brainfuck
19:46:46 <tehgeekmeister> *worse
19:47:02 <ozy`> Gracenotes: it's the leading FP entry in the turing tarpit genre
19:47:21 <ozy`> I say "genre" because these languages are more prank than program....
19:47:22 <dolio> Worse than brainfuck? Really?
19:47:39 <SamB> ozy`: shouldn't that be the church tarpit ?
19:47:40 <tehgeekmeister> dolio: i think so
19:48:01 <dolio> Not that I've studied either very closely.
19:48:18 <tehgeekmeister> of course they're both pretty bad.
19:48:20 <Gracenotes> hm. The basic lambda calculus shouldn't be terribly difficult to implement
19:48:24 <SamB> brainfuck doesn't have call/cc
19:48:35 <dolio> That's a positive?
19:48:40 <SamB> yes!
19:48:43 <tehgeekmeister> i've never really used either, but i could imagine doing something in brainfuck, but i can't imagine doing anything with unlambda
19:48:45 <Gracenotes> there's (, ), \, and .
19:48:59 <Gracenotes> four characters. hm, and function application :/ spaces, then
19:49:03 <monochrom> hehe, turing tarpit is for imperative pranks, church tarpit is for functional pranks.
19:49:11 <SamB> Gracenotes: what about variables ?
19:49:24 <Gracenotes> SamB: variables are any number of periods
19:49:39 <SamB> Gracenotes: oh
19:49:57 <Gracenotes> \.\..(.)(..) <-> \x -> \y -> x y. Or something like that. probably needs some refinement
19:49:58 <SamB> that sounds ... far too readable
19:50:03 <SamB> unlambda is much worse
19:50:23 <SamB> ... you do realize this is the same language category as INTERCAL is in, yes?
19:50:37 <SamB> "worse is better" has a whole different meaning in this category
19:50:44 <Gracenotes> heh
19:50:59 <dolio> Now INTERCAL, there's a language.
19:51:02 <Gracenotes> I never got what was so brain-damaging about INTERCAL. (Then again I never learned it)
19:51:04 <dolio> Computed COME FROM.
19:51:07 <ozy`> SamB, monochrom: I approve of that terminology
19:51:08 * wli should develop his own language at some point.
19:51:23 <dolio> Way better than call/cc.
19:51:52 <Gracenotes> I've made my own psuedo-language :) it's a lambda calculus implemented via RPN
19:52:46 <Adamant> I think the best one is Malbolge
19:52:53 <SamB> actually, come to think of it, BF wasn't really an intentional entry into this category
19:52:56 <Gracenotes> this computes the 1000th fibonacci number (with a boolean/integer extension): >f >x >x @ @ #x >f >x >x @ @ #x @ #f >n ?0 >a >f >b @ >a >b + @ >n -1 @ ? #n #b #a #f @ 0 @ 1 @ 1000 @
19:53:02 <Adamant> when you have to apply cryptanalytic techniques to use the language...
19:53:12 <SamB> it was an excercise in compiler tininess
19:53:58 <SamB> Adamant: is that one proven to be even in the tarpit?
19:54:15 <monochrom> Alice-Bob-Charles tarpit is the cryptanalysis :)
19:54:24 <Adamant> it's a very difficult esolang
19:54:27 <monochrom> s/the/for/
19:54:34 <SamB> I mean, is it turing-complete ?
19:54:38 <Adamant> I'm not worried about the tarpit bit
19:54:41 <Adamant> SamB: I think so
19:55:19 <Gracenotes> I won't believe it until I see a Turing machine emulator in Malbodge!
19:55:24 <monochrom> "execution time is EXPTIME because the computer has to crack the encrypted program first..."
19:55:29 <Gracenotes> *Malbolge, ergh
19:55:39 <mmorrow> just write a brainfuck interpreter in it
19:55:46 <Pseudonym> I don't think that Malbolge has been proven to be Turing-hard yet.
19:55:55 <monochrom> There is probability a zero-knowledge proof that the language is Turing-complete.  <duck>
19:56:04 <monochrom> s/probability/likely/
19:56:07 <Adamant> hmm, not Turing complete
19:56:32 <bombshelter13> Adamant: That just means you have to write another slightly less cryptic one that compiles down to the cryptic one
19:56:36 <Adamant> there are extensions that allow it
19:56:45 <Adamant> the only real problem is bounded memory size
19:57:10 <Adamant> that's what keeps it from being Turing complete
19:57:29 <monochrom> Oh, if we know there is a bound but we don't know what bound it is, that counts as a zero-knowledge proof. :)
19:57:47 <Adamant> no, there's an explict bound IIRC
19:58:29 <Adamant> has 3^10 memory locations
20:03:02 <ozy`> @src getLine
20:03:02 <lambdabot> getLine = hGetLine stdin
20:03:08 <ozy`> @src hGetLine
20:03:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:03:12 <ozy`> psh
20:05:20 <dejones> I'm trying to install a new version of cabal-install, but it says parsec is missing, although from ghc-pkg list, I can see parsec-3.0.0
20:05:23 <dejones> Any ideas?
20:07:44 <dejones> :(
20:09:12 <ozy`> dejones: check your $PATH
20:09:21 <dejones> ozy`: for what?
20:09:34 <ozy`> Â¯\O_o/Â¯
20:09:46 <ozy`> I forget what your specific problem probably is.
20:09:51 <ozy`> I had the same problem though
20:09:52 <dejones> I'm trying to install a new version of cabal-install, but it says parsec is missing, although from ghc-pkg list, I can see parsec-3.0.0
20:10:05 <dejones> Maybe I don't have the the location of the parsec binary in my PATH?
20:10:09 <ozy`> no, I mean I forget what exactly -causes- the problem.
20:10:13 <ozy`> that might be it
20:10:19 <ozy`> I don't remember for sure
20:10:28 <Gracenotes> (of course, you don't need to know what the problem is to solve it)
20:10:32 <dejones> heh
20:10:50 <dejones> ozy`: do you know where parsec is normally installed?  can you do "whereis parsec" for me?
20:11:58 <ozy`> it's not an executable binary
20:14:25 <dejones> hmm
20:14:54 <ozy`> I have it in /opt/local/lib/ghc-6.10.1
20:15:51 <dejones> Mine is in /usr/local/lib/parsec-3.0.0
20:19:48 * wli bites off far more than he can chew with a minilanguage.
20:20:36 <SamB> could it be that cabal-install wants parsec 2?
20:20:54 <dejones> SamB: Yep!
20:21:05 <dejones> SamB: I had to look in the bootstrap.sh to figure that out
20:21:44 <SamB> hmm, how does it want it anyway ?
20:21:46 <dejones> SamB: The error message doesn't mention needing parsec 2.x.x
20:22:00 <dejones> But it does check for parsec version 2.x.x
20:22:21 <dejones> dcoutts: Maybe add an error message to cabal install about the parsec version?
20:22:45 <dejones> :)
20:22:51 <SamB> this script is a heck of a lot longer than it used to be!
20:22:55 <dejones> lol
20:23:31 <SamB>     echo "The Haskell package '${PKG}' is required but it is not installed."
20:23:34 * wli is clueless wrt. implementing module systems or even type systems (i.e. user-defined types).
20:23:35 <SamB> that line is wrong
20:24:42 * wli starts over.
20:25:16 <dejones> SamB: Yep, that line shoudl mention the package version ;)
20:25:28 <dejones> or accept version 3.0.0 ;)
20:25:51 <tehgeekmeister> oh that might be why my function isn't lazy
20:25:54 <tehgeekmeister> i'm using the strict state monad
20:25:55 <tehgeekmeister> =P
20:27:21 <mmorrow> wli: these two papers are good: http://www.cs.uu.nl/research/techreps/repo/CS-2002/2002-031.pdf       and       http://www.mpi-sws.org/~rossberg/mixml/
20:28:47 <tehgeekmeister> annnnd when i switch to the lazy state monad my program blows up in less than twenty seconds.
20:30:17 <wli> I'm trying to cram user-defined types and modules into a mini-language.
20:30:38 <wli> Like the stupidest language possible with the feature set.
20:31:03 <edwardk> wli: sounds like one of my projects
20:31:15 <Gracenotes> hm. It might be possible to combine the lazy and strict state monad, if you had more than one bind... :/
20:31:37 <Saizan> edwardk: how is it going?
20:31:50 <edwardk> saizan: with me or the project? ;)
20:32:01 <edwardk> saizan: rather well in both respects
20:32:32 <edwardk> saizan: figured out a near module system, trying to implement it now
20:32:35 <edwardk> er neat
20:32:41 <Saizan> oh, nice
20:32:43 <shapr> edwardk: Dude, I can't read that file.
20:32:53 <wli> Well, the idea here is some sort of dumb language project. I can't even come up with a set of data types to describe user-defined types and/or modules.
20:32:55 <Saizan> any description of it somewhere?
20:32:57 <Gracenotes> hm.. combining em might get messy rather quickly. It's definitely possible though
20:32:57 <edwardk> shapr: its for one note
20:33:00 <edwardk> saizan: not yet
20:33:09 <tehgeekmeister> Gracenotes: i want the function to generate a lazy list, but something or another about how i'm doing it causes it to blow up if i use the lazy state monad.  and the strict state monad just makes it inconveniently slow.
20:33:22 <shapr> edwardk: right, but I don't have one note for debian.
20:33:25 <edwardk> we should probably move that kinda scary stuff off to #haskell-in-depth
20:33:27 * Saizan has to implement a toy interpreter for uni and can't decide on the language
20:33:31 <edwardk> shapr: then you're out of luck ;)
20:33:36 <shapr> oh well
20:33:55 <edwardk> shapr: i'll generate a text version of it at work tomorrow
20:33:58 <shapr> yay!
20:34:11 <edwardk> currently gutting yet another haskell parser to parse it
20:34:18 <Gracenotes> Saizan: Befunge? :)
20:34:33 <Gracenotes> hard as hell to write a compiler for, easy enough to write an interpreter for
20:34:37 * edwardk has discombobulated Language.Haskell so many times now it seems like a nervous habit
20:35:37 <Saizan> Gracenotes: i'm already on the LC+Hindley Milner bandwagon, i've to decide what to add to it :)
20:36:05 <Saizan> or i could go for the pattern calculus
20:36:17 <Gracenotes> a simply typed lambda calculus with Hindley-Milner... in 2 dimensions! :X
20:37:04 <Gracenotes> tehgeekmeister: just what does it do?
20:37:25 <gwern> (hm. so happstack has gzip support now... wonder how hard it'd be to switch gitit over to it)
20:37:25 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
20:37:37 <gwern> @messages
20:37:37 <lambdabot> nomeata said 3h 56m 18s ago: that it should be working, and that I donâ€™t check my lambdabot messages regulary :-)
20:37:53 * gwern wonders what that was in reply to
20:38:22 <tehgeekmeister> Gracenotes: easier to just show you code
20:39:58 <tehgeekmeister> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1485#a1485
20:40:10 <tehgeekmeister> only need to focus on makeNextBestReader and code it calls
20:40:25 <tehgeekmeister> the rest is helper functions for other approaches i'm not currently using
20:42:49 <tehgeekmeister> the issue is that makeNextBestReader is generating the entire reader before printReader gets any of it.  which i can get by by merging the two, but i'd like to just make nextBestReader appropriately lazy.
20:43:21 <Saizan> , [| if True then 1 else 2 |]
20:43:22 <lunabot>  CondE (ConE True) (LitE (IntegerL 1)) (LitE (IntegerL 2))
20:44:20 <Gracenotes> tehgeekmeister: hm... what does it do?
20:44:57 <tehgeekmeister> Gracenotes: reads a morphological parsing of the greek new testament, and orders which words to learn so as to optimize the number of sentences readable at any given point
20:45:25 <mmorrow> wli: the template-haskell Type type is a nice example
20:45:34 <tehgeekmeister> Gracenotes: nextBest finds the next best word to learn
20:45:43 <mmorrow> as are the many ASTs in ghc..
20:45:46 <Gracenotes> by frequency, or somethinglike?
20:46:13 <tehgeekmeister> Gracenotes: then we append that item to the reader, and check for targets which are known now (sentences), and append them to the reader
20:47:08 <tehgeekmeister> Gracenotes: not quite.  for each word that is unknown we add 1/(x^2) to it's score for each sentence it occurs in, where x is the number of other unknown words in that sentence
20:47:36 <tehgeekmeister> Gracenotes: this biases us both towards words that are used in a lot of sentences and to words which will make a lot of sentences readable shortly
20:48:08 <tehgeekmeister> Gracenotes: if you're interested in more about it there's a semi-active google group on graded readers, which is where i got the idea i'm using.
20:48:13 <mmorrow> , (fmap conName . decCons . cleanNames . fromJust . fromTyConI) $(lift =<< reify ''Type)
20:48:14 <lunabot>  [ForallT,VarT,ConT,TupleT,ArrowT,ListT,AppT]
20:48:22 <Gracenotes> wow :) neat.
20:48:24 <mmorrow> , (fmap conName . decCons . cleanNames . fromJust . fromTyConI) $(lift =<< reify ''Exp)
20:48:27 <lunabot>  [VarE,ConE,LitE,AppE,InfixE,LamE,TupE,CondE,LetE,CaseE,DoE,CompE,ArithSeq...
20:48:31 <mmorrow> , (fmap conName . decCons . cleanNames . fromJust . fromTyConI) $(lift =<< reify ''Dec)
20:48:32 <lunabot>  [FunD,ValD,DataD,NewtypeD,TySynD,ClassD,InstanceD,SigD,ForeignD]
20:48:34 * Gracenotes can't really dig the Reader problem out of it, though
20:48:52 <tehgeekmeister> the reader is basically entirely in nextBest
20:49:17 <tehgeekmeister> all the rest is bookkeeping to make it work right
20:49:27 <tehgeekmeister> and so i can actually view the result later.  =P
20:49:54 <Axman6> , [|\x -> if x then 1 else 2|]
20:49:56 <lunabot>  LamE [VarP x_0] (CondE (VarE x_0) (LitE (IntegerL 1)) (LitE (IntegerL 2)))
20:50:07 <mmorrow> , [t|forall a. (a -> a) -> a|]
20:50:08 <lunabot>  ForallT [a_0] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT a_0)) (VarT ...
20:50:13 <Gracenotes> well, you can always replace a reader with just functions :)
20:50:30 <Gracenotes> so I'm not if that's the problem
20:50:38 <tehgeekmeister> i'm using State
20:50:41 <tehgeekmeister> not Reader
20:50:54 <tehgeekmeister> the only issue i'm having with it now is that makeNextBestReader generates then entire reader before printReader prints any of it, which means the code has to run for a long time before i get to see any output, which means i can't make quick changes to improve it
20:50:58 <mmorrow> , (\e -> [|\x -> $e x|]) [|\x -> (x, 42)|]
20:50:59 <lunabot>  LamE [VarP x_0] (AppE (LamE [VarP x_1] (TupE [VarE x_1,LitE (IntegerL 42)...
20:51:12 <mmorrow> , $((\e -> [|\x -> $e x|]) [|\x -> (x, 42)|]) 99
20:51:13 <lunabot>  (99,42)
20:51:15 <Gracenotes> ah, yes... Reader* -/> Reader
20:52:15 <mmorrow> , ppDoc `fmap` (let f n e | n < 1 = e; f n e = [|show $(f (n-1) e)|] in f 4 [|42|])
20:52:15 <tehgeekmeister> yeah, i'm making a Graded Reader
20:52:16 <lunabot>  show (show (show (show 42)))
20:52:19 <tehgeekmeister> not using said monad
20:52:23 <mmorrow> , $(let f n e | n < 1 = e; f n e = [|show $(f (n-1) e)|] in f 4 [|42|])
20:52:25 <lunabot>  "\"\\\"\\\\\\\"42\\\\\\\"\\\"\""
20:53:13 <mmorrow> splicing ExpQ's into other ExpQ's is one of the most powerful parts of TH
20:53:35 <Gracenotes> tehgeekmeister: maybe you need to stuff more things in the monad? :)
20:53:50 <mmorrow> g |.| f = [|$g . $f|]
20:53:51 <tehgeekmeister> Gracenotes: what do you mean?
20:53:52 <mmorrow> etc
20:54:19 <mmorrow> (i made (|.|) up, it's not in the TH lib)
20:54:39 <dolio> , let g |.| f = [| $g . $f |] in [$ty| (|.|) |]
20:54:41 <Gracenotes> tehgeekmeister: instead of doing your calculations and then printing it, interleave the IO with calculations via the monad transformer? Then again, it could just be that it's a huge problem and that you have to wait to get results
20:54:42 <lunabot>  ExpQ -> ExpQ -> ExpQ
20:54:52 <mmorrow> it's actually already defined in lunabot
20:55:08 <mmorrow> , [$ty| (|$|) |]
20:55:10 <lunabot>  ExpQ -> ExpQ -> ExpQ
20:55:26 <tehgeekmeister> Gracenotes: it shouldn't take that long, i've implemented essentially the same algorithm before and had it start printing output fairly quickly
20:55:41 <mmorrow> , let a |*| b = [|($a, $b)|] in [$ty| (|*|) |]
20:55:43 <lunabot>  luna: Exception when trying to run compile-time code:
20:55:44 <tehgeekmeister> Gracenotes: but i see what you mean.  i just don't want to duplicate logic for printing.
20:55:45 <mmorrow> heh
20:55:55 <mmorrow> , [$ty| let a |*| b = [|($a, $b)\|] in (|*|) |]
20:55:58 <lunabot>  ExpQ -> ExpQ -> ExpQ
20:55:58 <Gracenotes> tehgeekmeister: what was your problem using lazy state..?
20:56:22 <tehgeekmeister> Gracenotes: there wasn't a problem before, but since i've refactored the code it blows up to 700 or so mb in less than thirty seconds
20:56:53 <mmorrow> couldn't the (haskell) parser just count matching "[|" ... "|]" 's to not have to require an escape for "|]" ??
20:57:16 <mmorrow> it just searches for the next "|]", which is super annoying
20:57:20 <Gracenotes> ah. Well, I guess that's one of the /things/ about using a lazy language...
20:57:32 <Gracenotes> :(
20:57:43 <tehgeekmeister> if i could figure out where it was being too lazy i could fix it
20:57:55 <tehgeekmeister> but i don't know where the problem really is, even
20:58:39 <Axman6> ok, i just realised that whenever someone asks what famous things are written in haskell, people always forget Xmonad. thinking of putting a new @where thing listing all the nice things haskell
20:58:44 <Axman6> 's used for*
20:59:35 <Cale> I wonder how hard it would be to implement my RTS idea...
20:59:49 <Saizan> being?
21:00:01 <mmorrow> oh snap! a QuasiQuoter takes a haskell expression of type (ExpQ -> ExpQ), and which gets passed *itself*, would be pretty cool
21:00:09 <mmorrow> *.. that takes...
21:00:12 <Gracenotes> awsum
21:00:35 <Cale> Basically you control one type of unit, which is a sort of fluid, and you do it by brushing force fields over the map.
21:01:15 <Cale> I'm thinking it would be good enough to just simulate it with some particles and springs.
21:01:17 <mmorrow> [$me| \me -> do LamE [VarP x] e <- me; ..... x .... e .... |]
21:02:29 <Cale> and the idea is basically that the faster your goo is moving the more damage it does when it collides with your opponent's goo.
21:03:28 <mmorrow> hmm, well i guess it can't search for matching "[|" .. "|]" 's actually..
21:03:47 * BMeph shakes his head, puts down the "Run-Time System" thoughts, and picks up the "Real-Time Strategy" bin...
21:03:59 <Cale> and there should perhaps be a way to trade speed vs. resistance to damage -- turning some bits into walls, or speeding some bits up to do lots of damage but die quickly.
21:04:31 <BMeph> mmorrow: Why now? It can match comment delimiters, why not QQ ones? :)
21:05:05 <Axman6> Cale: i haven't been reading too carefully, but this sounds like chipmunk stuff?
21:05:29 <mmorrow> BMeph: because what if the quoted language allows an unmatched "[|" or a "|]" with no preceeding matching "[|"
21:05:30 <Cale> Axman6: yeah, possibly :)
21:05:31 <SamB> , [$id| [$x| Hello, World! |] |]
21:05:32 <lunabot>  luna: parse error on input `|]'
21:05:42 <pumpkin_> I look forward to getting a 64-bit ghc on mac os
21:05:56 <Axman6> pumpkin_: slated for 6.12 though :\
21:05:58 <SamB> mmorrow: well, the latter isn't going to work is it ?
21:06:02 <pumpkin_> Axman6: yeah :/
21:06:06 <mmorrow> , [$ty| [$ty| fix \|] |]
21:06:09 <Axman6> i wish they'd bring it up
21:06:11 <lunabot>  Doc
21:06:18 <mmorrow> SamB: why not? the quoted lang is arbitrary
21:06:22 <Axman6> doesn't sound like something that should take all that long
21:06:37 <mmorrow> SamB: it doesn't even have to be a language
21:06:49 <Cale> I wonder, does chipmunk do springs?
21:06:59 * Cale looks...
21:07:01 <Axman6> you could emulate them i guess
21:07:23 <pumpkin_> the chipmunk binding looked nice, but all the functions are in IO :(
21:07:36 <pumpkin_> that makes me sad
21:07:52 <Cale> Sad pumpkin...
21:09:00 <pumpkin_> sad pumpkin is sad
21:09:08 <Axman6> http://tinyurl.com/d49nbg
21:09:10 <pumpkin_> lucky there are other haskell things tom ake me happy
21:09:11 <Axman6> :(
21:09:26 <pumpkin_> omg how did you find my picture?
21:09:45 <Axman6> do not underestimate Axman's google fu!
21:10:10 <pumpkin_> stalker
21:10:23 <shapr> truly
21:11:18 <Cale> Grr, I hate this stupid router... 30 minutes after being on a torrent and it's still struggling to make new connections.
21:11:40 <lowlycoder> how do I get the first two chars of a string
21:11:43 <lowlycoder> like substring (0 2)
21:11:49 <Cale> lowlycoder: take 2
21:11:53 <Cale> > take 2 "hello"
21:11:54 <lambdabot>   "he"
21:11:58 <shapr> lowlycoder: How do you get the first two items in a list?
21:12:01 <mae> gah, what are the layout rules for quasiquoting [| and |] expressions in TH
21:12:10 <mae> it doesn't like my trailing |] no matter what
21:16:54 <Sekaino> Hey guys - another oddball question for you.
21:16:59 <Axman6> pumpkin_: that comic you tweeted about... o.O
21:18:17 <pumpkin_> Axman6: yeah
21:18:23 <Sekaino> I'm making a newtype called ComplexPolar that redefines the show method to show it in polar form properly.  I used GeneralizedNewTypeDeriving to autoderive all its typeclass instances.  Now what if I want to have all the functions in the Complex module also operate on ComplexPolar?
21:18:31 <Axman6> did not see that one coming
21:19:36 <Axman6> @src Complex
21:19:36 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
21:19:52 <Sekaino> Just a strict algebraic datatype.
21:20:00 <pumpkin_> wow, a type with a constraint
21:20:01 <mmorrow> Sekaino: you need to manually duplicate them, by e.g. import qualified Data.Complex as C ..... .   foo (MyComplex z) = MyComplex (C.foo z)
21:20:06 <pumpkin_> don't see those often
21:20:13 <visof> hi
21:20:28 <Sekaino> mmorrow, I was afraid of that.
21:20:37 <Axman6> pumpkin_: sure you do, f it makes sense
21:20:39 <dolio> Yeah, Complex is pretty crazy.
21:20:46 <Axman6> if*
21:21:08 <Sekaino> It seems like this could be something that would be easily autoderived?
21:21:08 <Axman6> @hoogle Complex
21:21:08 <lambdabot> module Data.Complex
21:21:08 <lambdabot> Data.Complex data RealFloat a => Complex a
21:21:08 <lambdabot> package storable-complex
21:21:09 <pumpkin_> Axman6: I've never seen one before :) only constraints on functions operating on the type, but I guess being an instance of Num etc. makes it hard for it to put constraints on those, so they used constraints on the type
21:21:15 <Axman6> @hoogle+
21:21:24 <Axman6> hmm
21:21:30 <visof> i want to translate something like this into Haskell : do sum [1..] till you get 445
21:21:38 <Axman6> @src RealFrac
21:21:39 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
21:21:39 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
21:21:39 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
21:21:44 <mmorrow> Sekaino: i've totally wanted this exact thing before
21:21:54 <mmorrow> Sekaino: (== autoderiving this)
21:22:05 <pumpkin_> visof: head . takeWhile (< 445) . scanl1 (+) $ [1..]
21:22:13 <mmorrow> s/deriving/generating code for/
21:22:16 <pumpkin_> > head . takeWhile (< 445) . scanl1 (+) $ [1..]
21:22:17 <lambdabot>   1
21:22:19 <pumpkin_> lol
21:22:21 <Axman6> or takeWhile (/= 445)
21:22:26 <pumpkin_> > last . takeWhile (< 445) . scanl1 (+) $ [1..]
21:22:28 <lambdabot>   435
21:22:29 <Cale> dropWhile ?
21:22:39 <pumpkin_> that would make more sense :)
21:22:45 <Cale> Well... depends on exactly which one you mean.
21:22:48 <pumpkin_> > head . dropWhile (< 445) . scanl1 (+) $ [1..]
21:22:50 <lambdabot>   465
21:23:23 <Axman6> > sum . takeWhile (/= 445) $ [1..]
21:23:24 <lambdabot>   98790
21:23:36 <pumpkin_> lol
21:23:59 <pumpkin_> visof: did one of those answer your question?
21:24:07 <visof> yeah
21:24:09 <visof> thanks man
21:24:13 <Sekaino> mmorrow, I can see why.  The only reason I'm doing this dance instead of just using a "showPolar" function is that ComplexPolar will be one instance of a ComplexAlg type that can be dropped in as a backend, and all the types should have a uniform interface.
21:24:41 <pumpkin_> ComplexPolarBear
21:24:45 <pumpkin_> IsComplex
21:24:51 <Axman6> SimpleDropBear
21:25:00 <Axman6> IsEatingYou
21:26:14 <Sekaino> How about an extension to ghc or something that says:  newtype ComplexPolar = Polar Complex variant Complex ?
21:26:23 <mae> mae
21:26:51 <pumpkin_> pumpkin
21:26:54 <Sekaino> Such that anything you implement manually in the same module is taken as is, but anything you don't implement manually is autoderived to marshall automatically to Complex?
21:27:18 <Cale> å‰
21:27:19 <pumpkin_> Sekaino: uniform interface as in being instances of Num?
21:27:30 <pumpkin_> å¾Œã‚
21:27:36 <Sekaino> instances of ComplexAlg, which is an instance of Num plus a few more operations.
21:27:53 <Sekaino> (like the adjoint)
21:30:45 <Sekaino> I guess I'll just extend my definition of the ComplexAlg typeclass to include all the functions I want, and then specify the marshalling in the instance definitions.
21:32:04 <dolio> class ComplexAlg c where { toComplex :: c a -> Complex a ; fromComplex :: Complex a -> c a ; ... }
21:37:59 <visof> how can i use C code inside haskell ?
21:38:16 <pumpkin_> use the FFI to call it
21:39:41 <visof> pumpkin_ how ?
21:40:45 <pumpkin_> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
21:43:46 <Axman6> visof: http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html might be handy too
21:43:48 <visof> i'll show what i want exactly: i have program has written in C and i want to use this program inside Haskell code
21:44:03 <Axman6> @where+ C-DCT http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
21:44:03 <lambdabot> It is forever etched in my memory.
21:44:09 <Axman6> @where+ FFI-DCT http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
21:44:09 <lambdabot> Good to know.
21:44:23 <Axman6> (just because i'll never remember which one i used)
21:46:12 <lowlycoder> why does uncommenting the --changeScreen gives me an error in: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1563#a1563
21:47:26 <Axman6> lowlycoder: you need to be more specific
21:48:21 <lowlycoder> i'm pating in the wrong window, haskell not xmonad
21:48:26 <rwbarton> lowlycoder: probably you need a do block there?
21:48:36 <Axman6> ah
21:56:57 <poliquin> Newbie question on package installation ..
21:57:15 <djwonk> to simplify my problem -- i think i'm trying to have data A = A B ...and... data B = B A
21:57:27 <djwonk> this seems like a bad idea, but this is sort of what is happening to me right now
21:57:33 <poliquin> Tried to install a package  reactive-fieldtrip using 'cabal install ..') It said it needed fieldtrip, got it but it failed to build.
21:57:57 <poliquin> Ifound a patch for fieldtrip and installed it manually using runghc Setup configure.....
21:57:59 <djwonk> i want a Table to contain [Philosopher] but I want each Philosopher to refer back to the Table
21:58:19 <poliquin> That worked, and ghc-pkg list .. said it was there.
21:58:22 * djwonk found this http://www.cs.ioc.ee/~tarmo/papers/tfp06.pdf -- not sure if it is going to help
21:58:56 <poliquin> I tried to install reactive-fieldtrip again using cabal install ... and it thought it wasn't installed !
21:59:21 <poliquin> It downloaded it again and failed (since the online version doesn't have the patch)
21:59:22 <djwonk> if I'm way off base, suggestions (or whacks to the head) would be appreciated
21:59:23 <Heffalump> is cabal install trying to install the profiling libs too or something?
21:59:38 <Heffalump> hmm, no
21:59:44 <poliquin> Ah.. yes ..
21:59:53 <Heffalump> oh, ok :-)
22:00:16 <Heffalump> anyway, you can use 'cabal install' (no other arguments) in the fieldtrip directory to install it from there with the standard cabal setup
22:00:27 <Heffalump> you might need --reinstall now that you've done it once
22:00:42 <poliquin> But I thought they built from the same source .. (profiled and unprofiled)
22:01:08 <Heffalump> yes, but if profiled isn't installed then it needs to be somehow
22:02:09 <poliquin> Heffalump, Thanks a lot .. let me go try ..
22:02:37 <Heffalump> (what made you say "Ah.. yes .." re my profiling suggestion?
22:02:49 <Heffalump> I withdrew it because I thought the symptoms would be different to what I described
22:04:07 <rwbarton> djwonk: that's totally fine
22:04:11 <poliquin> Heffalump, Well I've been having other problems with the -p (profiling) option and you seemed to zero in on that right away. So I thought that might be the problem .. Does that make sense?
22:04:38 <Heffalump> poliquin: not certain. cabal install on the patched version is worth a try, anyway
22:04:42 <djwonk> rwbarton: ok, good to hear.  but how would i actually use the constructor in practice?
22:04:45 <rwbarton> djwonk: however, if you are thinking of having a circular strcture, it does it difficult to modify
22:04:56 <rwbarton> djwonk: I think I missed the beginning of your problem possibly :)
22:05:08 <Heffalump> if not profiling, there might be some other configuration difference which explains the problem
22:05:12 * Heffalump disappears for a bit
22:05:33 <djwonk> rwbarton: 1st part was saying that, to simplify my problem, i end up with data A = A B and data B = B A
22:05:40 <poliquin> Heffalump, So, I went to the patched directory and typed 'cabal install' and it did cool things.
22:05:58 <djwonk> rwbarton: this is just a gross simplification of what I'm running into while writing a dining philosophers problem
22:06:12 <rwbarton> djwonk: Well, in that case there's not much you can do with it, but you can write let {x = A y; y = B x} in x
22:06:31 <poliquin> Heffalump, Woopee! That worked like a champ .. Thanks a bunch!
22:06:50 <poliquin> Heffalump, Did I mispell Woopee? (Whoopee?)
22:07:04 <djwonk> rwbarton: is that generally considered a bad idea -- a sign that I've got a bad design?  (a code smell?)
22:07:49 <rwbarton> djwonk: Well cyclic structures are difficult to modify generally speaking
22:07:53 <BMeph> djwonk: Relax, you're in #haskell. We like circular programming here! ;)
22:07:56 <Axman6> @instances Ord
22:07:57 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
22:08:30 <djwonk> BMeph: :)
22:08:33 <Axman6> > compare True False
22:08:34 <lambdabot>   GT
22:08:41 <djwonk> rwbarton: thanks I will try that
22:09:24 <rwbarton> djwonk: what about the dining philosopher problem are you modelling?
22:10:07 <djwonk> rwbarton: well, I wrote a Ruby version.  now i'm working on a haskell version.  very basic.  nothing fancy with concurrency.  just figuring out how to not think in OO style
22:10:21 <mmorrow> djwonk: you can always replace all links to other things by "Ptr"s to them, where type Ptr = Int, and type Mem a = IntMap a
22:10:31 <djwonk> getting comfortable with the basics of types, actually
22:10:40 <mmorrow> that way you can modify and be circular with no problems
22:10:44 <rwbarton> djwonk: or you can <whisper>use IORefs</whisper>
22:10:58 <mmorrow> yeah, or just do everything in IO
22:11:03 <mmorrow> or ST for that matter
22:11:23 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 99; readSTRef x)
22:11:26 <lunabot>  99
22:11:27 <djwonk> mmorrow: ok, will add that to the idea list, thanks. wanted to try to be purely functional if possible
22:11:54 <mmorrow> djwonk: storing refs to everything in an IntMap is a good way to do that
22:12:34 <djwonk> mmorrow: i'm chewing my way through the R.W. Haskell book (and my sanity, to some degree).  do you think it covers this concept at some point?
22:13:20 <djwonk> i get the feeling that this was covered, sort of, i just haven't grokked it yet.  that's exactly why i'm writing little programs to see if i can do basic stuff
22:13:30 <BMeph> @go tying the knot
22:13:31 <lambdabot> http://www.tyingtheknot.net/
22:13:31 <lambdabot> Title: BEBB | Studios
22:13:53 <mmorrow> so, instead of  List a = Nil | Cons a (List a), you have  List a = Nil | Cons a (Ptr (List a)).....  type Ptr a = Int .....  Mem a = IntMap a
22:14:06 <mmorrow> a graph is just   IntMap IntSet
22:14:26 <mmorrow> slash   Map Int (Set Int)
22:15:01 <mmorrow> @type \m -> (m Map.!)
22:15:02 <lambdabot> Couldn't find qualified module.
22:15:05 <mmorrow> @type \m -> (m M.!)
22:15:06 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
22:15:21 <BMeph> Got it:
22:15:27 <BMeph> @go haskell knot
22:15:27 <dolio> @type (M.!)
22:15:28 <lambdabot> http://katlas.math.toronto.edu/wiki/The_Kauffman_Bracket_using_Haskell
22:15:28 <lambdabot> Title: The Kauffman Bracket using Haskell - Knot Atlas
22:15:29 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
22:15:47 <BMeph> EH?!? o.O
22:17:29 <mmorrow> crap, my history down the drain with an accidental ^q
22:17:49 <pumpkin_> aw
22:18:06 * mmorrow beats up a kitten
22:18:19 <pumpkin_> don't forget to club the seal
22:18:20 * mmorrow feels better now
22:18:29 * mmorrow clubs a baby tortoise
22:18:42 * BMeph has a moment of silence for mmorrow's lost history. And the sleeping wife. But mostly for the history. ;)
22:19:03 <mmorrow> :)
22:19:04 <pumpkin_> mmorrow: is it smaller than a raspberry?
22:19:15 <djwonk> mmorrow: thanks, will give that a shot
22:19:32 <mmorrow> pumpkin: yes
22:19:40 <mmorrow> djwonk: np
22:20:38 <BMeph> djwonk: Also, try http://www.haskell.org/haskellwiki/Tying_the_Knot for more pointers. :)
22:21:10 <djwonk> BMeph: oh, that was for me!  (oblivious i was)
22:21:12 <BMeph> djwonk: Or maybe a spaniel, they're friendly, too. ;p
22:21:53 <harblcat> So, haskell.. Are you any good with SDL?
22:21:54 * djwonk tries for a follow up... and fails
22:22:32 * erikc doesnt use SDL cause of the SDL_main headaches
22:23:09 <mmorrow> djwonk: this is a good description of the other strategy http://www.haskell.org/pipermail/haskell-cafe/2009-January/052795.html
22:23:14 <harblcat> erikc: is it awkward?
22:23:35 <djwonk> mmorrow: sweet.  i'll offer up various species of dog for you to club in celebration
22:23:43 <mmorrow> yes!!
22:24:08 <erikc> harblcat: the library is fine, but getting going is a headache cause SDL expects to own main(), and so does ghc by default
22:24:38 <harblcat> hrm
22:24:46 <erikc> on mac its particularly annoying cause you wind up with an objc part of the app that has to kick off a c part of the app that has to kick off ghc
22:25:27 <erikc> i should package up a cabal 'starter' package or sumthin
22:25:32 <harblcat> crazy
22:27:47 <djwonk> mmorrow: works great, as long as I don't try to display the knotted data structure! (duh!)
22:28:11 <pumpkin_> is there a simple library for symbolic manipulation of mathematical expressions? all I need is basic arithmetic and some simple form of simplification
22:29:18 <mmorrow> , levels $ fix (\me -> Node () [me, me])
22:29:20 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
22:29:32 <mmorrow> , flatten $ fix (\me -> Node () [me, me])
22:29:33 <lunabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
22:30:59 <Heffalump> poliquin: cool
22:31:26 <pumpkin_> mmorrow: fancy
22:31:56 <mmorrow> , levels $ fix (\me -> (\n -> Node n [me (n+1), me (n+1)])) 0
22:31:57 <lunabot>  [[0],[1,1],[2,2,2,2],[3,3,3,3,3,3,3,3],[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],...
22:32:09 <mmorrow> , flatten $ fix (\me -> (\n -> Node n [me (n+1), me (n+1)])) 0
22:32:10 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
22:32:58 <Cale> djwonk: While you *can* tie the knot if you want things to refer to one another, it's often more flexible not to do things like that. If you need graph structure, it's often best represented explicitly using something like a Data.Map from vertices to sets or lists of neighbours.
22:34:00 <Cale> djwonk: Or in a case like this, you could probably just keep the Table and Philosophers alongside one another.
22:34:40 <djwonk> Cale: the RWHaskell book talks about Maps, i'll take a look at that
22:34:41 <Cale> (Unless there's really a need for each Philosopher to contain a Table ;)
22:35:04 <djwonk> Cale: right, a philosophers doesn't need to contain a table.  that would the Dining Philosophers in Hilbert's Hotel perhaps
22:35:09 <Cale> hehe :)
22:35:53 <mmorrow> , levels $ fix (\me -> (\s -> Node s [me (s++"l"), me (s++"r")])) []
22:35:54 <lunabot>  [[""],["l","r"],["ll","lr","rl","rr"],["lll","llr","lrl","lrr","rll","rlr...
22:35:58 <djwonk> Cale: my first couple of tries didn't pan out.  the problem is that slots (fork slots) are shared.  not a big surprise in retrospect
22:36:28 <djwonk> mmorrow: i get the feeling that you are giving me hints, but I'm not quite getting them :)
22:36:33 <mmorrow> wow, that fix thing with the Tree looks promising
22:37:00 <mmorrow> djwonk: i did it at first to do that (since it's tying the knot ==> the
22:37:08 <mmorrow> "me" is the eventual result)
22:37:24 <mmorrow> but then i figured out how to pass info down the tree
22:37:32 <mmorrow> i never saw that before :)
22:37:59 <mmorrow> (saw := saw how to do that)
22:38:54 <Cale> Then again, with dining philosophers... I would almost expect the forks to be MVars.
22:39:27 <djwonk> Cale: yeah, i think this is a lesson that a bad data structure leads to much gnashing of teeth
22:39:31 <Cale> Unless you're just doing some sort of formal simulation.
22:39:47 <mmorrow> djwonk: definitely
22:40:06 <djwonk> Cale: i would like to see if I can do it completely purely.  need sleep soon.  will try again another day
22:40:33 <visof> what "rem" and "quot" methods so ?
22:40:36 <djwonk> Cale: the idea of a Slot (i.e. a fork slot) is a nice abstraction
22:40:37 * mmorrow mumbles something about "another level of indirection ... "
22:40:57 <Cale> visof: They're similar to div and mod, but deal with negative values a little differently.
22:41:14 <Cale> visof: They stand for quotient and remainder.
22:41:37 <visof> ah
22:41:38 <dolio> > 2 `mod` (-3)
22:41:39 <lambdabot>   -1
22:43:39 <djwonk> random useless bits of information: TX, OK, and VA (and probably others) have cities named Haskell
22:44:36 <djwonk> if they have user groups, it would lead to some repetitive names
22:51:46 <mmorrow> preflex: seen dcoutts_
22:51:46 <preflex>  dcoutts_ was last seen on #haskell 8 hours, 30 minutes and 4 seconds ago, saying: Heffalump: I think it's arguable either way. It'd be ok to have called it 1.6.1.0. Perhaps in retrospect I should have done that.
22:51:49 <mmorrow> preflex: seen dcoutts
22:51:49 <preflex>  dcoutts was last seen on #ghc 13 hours, 44 minutes and 2 seconds ago, saying:   $ cabal install Cabal cabal-install
22:52:44 <mmorrow> @tell dcoutts_ i'm reading this currently, and thought you might find it interesting (re: build systems/cabal) http://www.acm.org/pubs/citations/journals/toplas/1999-21-4/p813-blume/
22:52:44 <lambdabot> Consider it noted.
22:52:54 <mmorrow> @tell dcoutts i'm reading this currently, and thought you might find it interesting (re: build systems/cabal) http://www.acm.org/pubs/citations/journals/toplas/1999-21-4/p813-blume/
22:52:54 <lambdabot> Consider it noted.
22:53:32 <mmorrow> this is cool http://www.acm.org/pubs/citations/journals/toplas/1999-21-4/p813-blume/
22:53:38 <mmorrow> shit, broken link!
22:53:52 <mmorrow> this http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.2571
22:54:10 <mmorrow> @tell dcoutts err, sorry that link doesn't work :-) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.2571
22:54:10 <lambdabot> Consider it noted.
22:55:24 <mmorrow> i'm constantly being amazed by how slick smlnj/related components are
22:55:43 <mmorrow> (that paper has to do with its CM (compilation manager))
22:56:20 <mmorrow> and especially since most of this stuff is from the 90s
22:57:20 <Gracenotes> @hoogle deriv
22:57:20 <lambdabot> package derive
22:57:20 <lambdabot> Distribution.Extension DeriveDataTypeable :: Extension
22:57:20 <lambdabot> Language.Haskell.Extension DeriveDataTypeable :: Extension
22:57:27 <Gracenotes> :/
22:57:35 <Gracenotes> @hoogle differentiate
22:57:35 <lambdabot> No results found
22:57:50 <Gracenotes> @hoogle diff
22:57:50 <lambdabot> package Diff
22:57:50 <lambdabot> module Data.Array.Diff
22:57:50 <lambdabot> Data.Time.Clock.TAI diffAbsoluteTime :: AbsoluteTime -> AbsoluteTime -> DiffTime
22:59:18 <mmorrow> Gracenotes: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
22:59:35 <Gracenotes> ah, thanks
23:22:58 <erikc> sigh, i wish c/c++ had decent literal array syntax, haskell has spoiled me :)
23:23:24 <Axman6> what do you mean?
23:24:17 <erikc> so that i could have a function like "void point(int[3])" and call it with point({x, y, ,z})
23:24:55 <Axman6> ah, heh
23:25:13 <Gracenotes> yeah :/ well at least you can do it in two lines: int points[] = {x, y, z}, then pass points
23:25:13 <angerman> erikc: iirc arrays are just a bit syntactic sugar on pointers.
23:25:24 <Draconx|Laptop> erikc, you almost get that in C: point((int[]){x, y, z})
23:25:47 <Gracenotes> oh. hmm
23:27:25 <Draconx|Laptop> angerman, not really.
23:28:38 <kohwj> i read http://www.haskell.org/all_about_monads/html/analogy.html which uses an chopstick assembly line as an analogy of monads. "assemblyLine w = (return w) >>= makeChopsticks >>= polishChopsticks >>= wrapChopsticks". Isn't this just a way to sequence functions in a specific order?
23:29:31 <harblcat> kohwj: Isn't that what a monad does?
23:30:06 <kohwj> harblcat: is that all there is to what a monad is?
23:30:22 <erikc> draconx: slick, it didnt occur to me that would work, i use a similar idiom with unions/structs and c99 designated initializers
23:30:56 <kohwj> pseudo-imperative style?
23:31:23 * Gracenotes admires harblcat's harbl
23:33:53 <NameAlreadyInUse> kohwj: sort of
23:36:25 <Clarious> Hello everyone, I am having a problem with WinHugs, I can't use functions that are in Prelude, if I use ":l Prelude" it said Prelude is already loaded, but I still can't use its function. Check "Browse -> Name" show Prelude functions too. Do I have to use any prefix to use the functions?
23:36:36 <harblcat> to be honest, I still don't comprehend monads.
23:37:17 <loop> read http://groups.csail.mit.edu/pag/reading-group/wadler-monads.pdf ? :-)
23:37:50 <NameAlreadyInUse> harblcat: i think i am on the edge of comprehending them
23:40:45 <Saizan_> kohwj: right, a monad is just a particular way of composing functions with some kind of enriched result, but that's not limited to mere sequencing as in imperative languages
23:42:25 <harblcat> NameAlreadyInUse: Woo, educational material! :)
23:44:51 <kohwj> Saizan_: i see. glad that i'm on my way to better understanding them :)
23:49:08 <redditbot> Ask Proggramming Reddit: I've heard that Haskell's FFI is much better than OCaml's. If so, can you explain why?
