00:01:16 <Ralith> @src words
00:01:16 <lambdabot> words s = case dropWhile isSpace s of
00:01:16 <lambdabot>     "" -> []
00:01:16 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:03:30 <Eridius> huh, didn't know lambdabot could get source for things hoogle doesn't list the Source link on
00:03:31 <Eridius> @src length
00:03:31 <lambdabot> Source not found. My pet ferret can type better than you!
00:03:33 <Eridius> haha
00:03:57 <Ralith> Anyone have any thoughts on a good [(a, b)] -> a -> b function?
00:04:13 <Ralith> I guess the best you can do is just iterate.
00:04:26 <Eridius> Ralith: I'm confused as to what a function with that type signature is supposed to do
00:04:51 <dolio> @type lookup
00:04:53 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:05:04 <Ralith> dolio: perfect!
00:05:04 <Ralith> thanks
00:05:15 <Eridius> ahh, ok
00:07:25 <Ralith> if I refer a function defined in a 'where' clause several times in the function body, will it be cached?
00:11:34 <Gracenotes> Ralith: will what be cached?
00:11:45 <Ralith> Gracenotes: the where function's value
00:11:57 <Ralith> assuming fixed input
00:12:06 <Ralith> (or no input)
00:12:21 <Eridius> Ralith: if there's no input, then it's not a function, it's just a thunk
00:12:57 <Ralith> great
00:14:13 <Gracenotes> if you're using the result of a function-with-arguments more than once in a function body, though, what might be best to keep in a where clause
00:14:31 <Ralith> I'm talking about doing that
00:14:38 <Gracenotes> :/
00:14:50 <Ralith> that is, the function-with-arguments itself is in the where clause.
00:14:52 <Ralith> I see your point though
00:14:59 <Ralith> and that's actually what I ended up doing
00:15:10 <Gracenotes> well... try: let m = [1..10000000], and then last m several times
00:15:14 <Gracenotes> "last m"
00:15:30 <Gracenotes> as opposed to let m x = [x..10000000], then doing (last m 1) several times (in ghci)
00:16:15 <Gracenotes> except if you do n = m 1, which is close enough to the first performance-wise
00:16:39 <cizra> Gracenotes: They take similar time here.
00:17:30 <Gracenotes> cizra: hm. Well, it should take the same time at first, but subsequent calls should return almost immediately in the first and third examples
00:17:48 <cizra> In ghci? Not here.
00:18:09 <cizra> Gracenotes: Ohh, right. Yes.
00:18:25 <cizra> Gracenotes: let foo = ... in last foo works slowly every time.
00:18:43 <Gracenotes> yep :)
00:21:00 <Gracenotes> (of course, for a big enough y in [x..y], it still might take a long time, but at least the spine of the list has already been constructed)
00:22:17 <cizra> Hmm, does this mean it's better to use monadic lists, performance-wise?
00:23:19 <cizra> let ... in last m + last m works twice as slowly, by the way.
00:23:38 <Gracenotes> hm.. what sort of monadic lists do you mean?
00:25:55 <Gracenotes> hm, this is some odd behavior, actually.. ghci is pausing for large amounts of time in subsequent (last m) calls, but reports the time as (0.00 secs, 0 bytes)
00:26:04 <Axman6> is there any way to tell cabal install not to upgrade certain libraries?
00:26:32 <Axman6> i don't want process to be updated, because it breaks cabal upgrade
00:29:21 <Axman6> gahh, even not upgrading process means i can't use cabal upgrade!
00:39:22 <Ralith> @src second
00:39:22 <lambdabot> Source not found. There are some things that I just don't know.
00:39:42 <pumpkin> it's in Arrow
00:39:44 <Axman6> :t first
00:39:45 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
00:39:56 <pumpkin> and it applies a given function to snd of a pair, leaving the fst intact
00:40:16 <pumpkin> it actually applies a given arrow to snd :P
00:40:31 <pumpkin> but the only interesting instance of arrow seems to be a function :P
00:40:45 <pumpkin> and kleisli, which I don't really get
00:40:56 <Axman6> @instances Control.Arrow.Arrow
00:40:56 <lambdabot> Couldn't find class `Control.Arrow.Arrow'. Try @instances-importing
00:41:02 <Axman6> @instances Control.Arrow
00:41:02 <lambdabot> Couldn't find class `Control.Arrow'. Try @instances-importing
00:41:10 <pumpkin> @instances Arrow
00:41:10 <lambdabot> (->), Kleisli m
00:41:11 <Axman6> @instances-importing Control.Arrow Arrow
00:41:11 <lambdabot> (->), Kleisli m
00:41:36 <Axman6> heh, right, that does make sense -_-
00:41:42 <Axman6> pumpkin: did you see my ASTM thing?
00:41:55 <pumpkin> nope
00:41:57 <pumpkin> ?
00:42:18 <Axman6> sec
00:42:21 <Gracenotes> apparently arr is quite the straitjacket
00:42:27 <Axman6> maybe...
00:42:34 <Axman6> @go ASTM axman
00:42:35 <lambdabot> http://axman6.homeip.net/blog/2009/02/astm-redundant-stmish-fun.html
00:42:35 <lambdabot> Title: ASTM: redundant STMish fun - Data.Random
00:42:43 <Axman6> whoot, go google
00:42:59 <Gracenotes> anyone know any Arrows that could be implemented without arr?
00:43:16 <Gracenotes> i.e. if arr weren't a requirement
00:43:44 <opqdonut> Gracenotes: are you sure you're not looking for the Category class
00:44:19 <opqdonut> or rather, some of its subclasses
00:44:36 <ski_> Gracenotes : invertible functions
00:44:37 <Gracenotes> nope, specific to using 2-tuples to model computation
00:44:46 <Gracenotes> I've heard that arr is evil, etc :x
00:45:19 <Gracenotes> ski_: do you have a sample implementation of that somewhere? (with arr as error "something or another")
00:45:55 <ski_>   data Inv a b = PromiseInverses (a -> b) (b -> a)
00:46:09 <ski_>   aid = PromiseInverses id id
00:46:58 <ski_>   PromiseInverses fwd0 bwd0 >>> PromiseInverses fwd1 bwd1 = PromiseInverses (fwd1 . fwd0) (bwd0 . bwd1)
00:47:38 <ski_>   arr f = PromiseInverses f (error "we lied. there possibly isn't an inverse")
00:48:25 <Gracenotes> right. How about, say, first?
00:48:35 <ski_>   first (PromiseInverses fwd bwd) = PromiseInverses (first fwd) (first bwd)
00:48:56 <Gracenotes> mm... interesting
00:50:25 <Gracenotes> ski_: I see the general idea... what does this model, though? :)
00:50:36 <Petrosian> Good morning
00:50:45 <Petrosian> Quick question regarding type classes
00:51:03 <pumpkin> good morning!
00:51:11 <pumpkin> quick answer regarding type classes coming up!
00:51:12 <pumpkin> :P
00:51:28 <Petrosian> How does the compiler (in general) determine the kind of the type variable in the definition of a new class
00:51:42 <Petrosian> For example, the kind of `a' in `class A a where'
00:51:58 <ski_> Gracenotes : invertible functions
00:52:12 * pumpkin blinks
00:52:14 <pumpkin> deja vu!
00:52:35 <ski_> Petrosian : it looks at methods to see how `a' is used .. it defaults to `*'
00:52:40 <Axman6> Petrosian: if there's no restrictions put on it, it should infer that it can be anything i think
00:52:45 <ski_> e.g.
00:52:46 <Gracenotes> hrm.
00:52:55 <pumpkin> ski_: I wrote a pseudoarrow minus the arr once that allowed me to write that promiseinverse
00:52:57 <ski_>   class Foo a b
00:52:59 <ski_>     where
00:53:02 <pumpkin> but it wasn't very interesting
00:53:06 <Gracenotes> I suppose this might apply to, say, a series of changes to a document one might wish to undo
00:53:12 <Gracenotes> or a transaction of sorts
00:53:19 <opqdonut> isn't arrow - arr something like a CCC?
00:53:23 <Petrosian> ski_: I see, thanks
00:53:24 <ski_>   m :: a (b Bool) -> Int
00:53:50 <pumpkin> opqdonut: a CCC?
00:53:55 <Petrosian> I was mainly wondering about the defaulting, but you cleared that issue up in the first answer!
00:53:56 <opqdonut> cartesian closed category
00:54:00 <ski_> will infer `b :: * -> k0' and `a :: k0 -> *', and then `k0' is defaulted to `*'
00:54:07 <ski_> (roughly that, anyways)
00:54:11 <pumpkin> opqdonut: *whoosh* /me watches over his head
00:54:22 <pumpkin> :)
00:54:57 <opqdonut> hmm, or maybe just a cartesian category
00:55:04 <Gracenotes> a category closed under the operation of cartesian product of objects?
00:55:08 <opqdonut> look at http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian.html, the typesigs might make some sense
00:55:42 <pumpkin> omg functional dependencies
00:55:53 <ski_> `closed' refers to exponential objects
00:55:57 <dolio> pumpkin: A CCC has objects that represent morphisms in the category, roughly.
00:56:10 <pumpkin> hmm
00:56:18 <ski_> (rather objects that represent morphism classes ..)
00:56:27 <opqdonut> and a precartesian category has something roughly like tuples :)
00:56:28 <Gracenotes> it's getting scary when all the functions listed don't actually take arguments -- they *are* their type
00:56:29 <dolio> Right.
00:56:40 <opqdonut> so when you put these together you could have something like first for Arrows
00:57:01 <ski_> opqdonut : hm, so what's the definition of `precartesian' ?
00:57:09 <ski_> opqdonut : anything like `premonoidal' ?
00:57:11 <pumpkin> before descartes was born?
00:57:24 <pumpkin> :)
00:57:30 <opqdonut> ski_: i'm just using control.category.cartesian as a cheat-sheet
00:57:36 <opqdonut> i don't really remember any of this stuff
00:57:49 * ski_ has no idea what's in `Control.Category.Cartesian'
00:58:04 <opqdonut> ski_: well i pasted the haddock link up there ^
00:58:14 * ski_ glances upwards
00:58:23 <ski_> oh .. didn't notice that, sir
00:58:29 <opqdonut> :)
00:59:04 <Axman6> @hoogle IORef
00:59:04 <lambdabot> module Data.IORef
00:59:04 <lambdabot> Data.IORef data IORef a
00:59:04 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
01:01:42 <Axman6> what reasons are there to use IORefs over MVars?
01:02:12 <dolio> IORefs are faster.
01:02:30 <Gracenotes> how fast are STRefs comparatively?
01:02:32 * ski_ wonders what laws the operations in said module must satisfy
01:02:43 <dolio> Should be the same, I imagine.
01:02:44 <ski_> the same, i'd think
01:03:03 <opqdonut> ski_: it's a shame laws aren't haddocked that well
01:03:19 <Gracenotes> mm. And are IORefs thread safe? i.e. a simultaneous read/write won't yield corrupted data?
01:03:24 <Ralith> @src words
01:03:24 <lambdabot> words s = case dropWhile isSpace s of
01:03:24 <lambdabot>     "" -> []
01:03:24 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
01:03:31 <Ralith> @src lines
01:03:32 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:05:18 * Gracenotes has a deeply rooted phobia of corrupted data in concurrent situations. Currently going through professional therapy
01:05:30 <Gracenotes> >_>
01:06:48 <Axman6> IORefs are implemented using STRefs
01:07:18 <Gracenotes> unsafeSTtoIO and vice versa, and the like
01:07:40 <Axman6> just stToIO
01:07:41 <Gracenotes> unless it's just stToIO, I forget
01:07:49 <Axman6> file:///Users/Axman/usr/share/doc/ghc/libraries/base/src/GHC-IOBase.html#IORef
01:07:57 <Axman6> uh, forgot that was a local file
01:08:22 <Gracenotes> aha! I have discovered that your true name is Axman!
01:08:36 <Axman6> bum bum bummmm!
01:08:47 <Axman6> it's just Axman :(
01:09:03 <ski_> (this `6' was just a ruse, then)
01:09:09 <Axman6> :'(
01:09:45 <Axman6> this STM library i'm writing could turn out to be rather interesting
01:09:50 <Axman6> and very simple
01:10:06 <Ralith> grah
01:10:07 <Gracenotes> well, which is it?
01:10:11 <Ralith> why is a simple tokenizer eluding me
01:10:17 <Axman6> uses forkIO'd processes to emulate a mutable variable
01:10:58 <Gracenotes> so you have to use IO to access said variable?
01:11:22 <Axman6> Gracenotes: this one: http://www.reddit.com/r/haskell/comments/7xt11/astm_redundant_stmish_fun_datarandom/
01:12:32 <Gracenotes> mm. What does Atom do?
01:12:59 <Gracenotes> oh, conditional modification, then
01:13:04 <Axman6> yep
01:13:36 <Axman6> adding some more actions to it now
01:14:11 <Axman6> not sure how it could be useful, but whatever. it's fun to play with
01:14:17 * Axman6 needs to test the speed of it
01:14:49 * beelsebob pokes Axman6 in the nostril
01:14:51 <Axman6> i've put some exception handling into it too
01:15:04 * Axman6 licks the finger and watches you all squirm!
01:15:11 <beelsebob> hah
01:15:12 <beelsebob> a
01:15:30 <pumpkin> lol
01:15:36 <ski_> Axman6 : feels like Erlang
01:15:38 * beelsebob is not too sure that a bunch of geeks will squirm too much at eating snot
01:15:47 <Axman6> ski_: yeah, i get that feeling too
01:15:54 <pumpkin> Axman6: looks neat
01:16:07 <Gracenotes> Herlang
01:16:13 <Axman6> yeah!
01:16:20 <pumpkin> there's already a lib on hackage for that :P
01:16:25 <Gracenotes> "I'm going to program Herlang" "That's what she said!"
01:16:43 <Axman6> yeah, i was working on a joke too :P
01:18:04 <beelsebob> does look funky indeed
01:19:04 <Axman6> what? but it's mutable state! you hate that shit!
01:20:06 <beelsebob> I do, means I won't use it... doesn't stop it being funky
01:20:46 <ski_> Axman6 : could you generalize `Atom' to execute any `a -> (a,b)' for any `b', on the state, and pass the `b' as result "back" ?
01:21:09 <Axman6> ski_: and put the a back 'into' the var?
01:21:15 <ski_> yes
01:21:47 <ski_> e.g. `a -> (a,Bool)' would correspond to your current `(a -> Bool,a -> a,a -> a)' case
01:21:53 <Axman6> sure. might make it a new Transaction (because i haven't thought this thing through very well)
01:22:19 * beelsebob would be tempted to say that would be bloat
01:22:28 <beelsebob> you already have actions that do both those operations
01:22:53 <beelsebob> although in a seperate module containing utilities it might be an idea
01:22:57 <dcoutts> Axman6: try using cabal install instead of cabal upgrade
01:22:59 <ski_> beelsebob : `Mod', yes .. hence "generalize"
01:23:12 <ski_> er, `Atom'
01:23:14 <ski_> not `Mod'
01:23:42 <Axman6> i;ve added a Swap a (MVar a) transaction, which puts the current value in the mvar, and sets the value to the a
01:23:46 <beelsebob> ski_: I'm not sure that's generalising – I think it's specialising to the task of modifications that also give a useful result, and also making it less orthogonal
01:23:51 <ski_> (this generalization i'm thinking of would of course be atomic)
01:24:32 <ski_> (`Swap' could easily be implemented with my operation suggestion)
01:24:37 <Axman6> one thing i like about the way i'm doing things is you can say put a value into the var, and go on without having to wait for it
01:24:52 <blackh> Hi there all. Hi Axman6! How's it going?
01:25:00 <Axman6> ski_: hmm, actually i think what you're suggesting could be very handy
01:25:23 <Axman6> hey blackh :) we're discussing my new ASTM libraryhttp://www.reddit.com/r/haskell/comments/7xt11/astm_redundant_stmish_fun_datarandom/
01:25:35 <ski_> beelsebob : if you could compose small transactions into larger transactions, then yes
01:25:48 <Axman6> ski_: got a good name for the transaction?
01:26:32 <beelsebob> ski_: then I think the correct suggestion is to add compositionality, not remove orthogonality ;)
01:26:42 <capt> what do we mean by 1UL<<order???
01:26:53 <Axman6> huh?
01:27:04 <Axman6> wut?
01:27:18 <capt> dont u know abt this....
01:27:35 <Gracenotes> 1UL .. is that unsigned long?
01:27:41 <ski_> Axman6 : something with `modify'
01:27:41 <Gracenotes> if so you may be in the wrong channel
01:27:53 <Axman6> i have no idea what you're on about
01:28:19 <capt> can u suggest me a channel for C programming
01:28:20 <ski_> beelsebob : yes .. but i'm not sure whether Axman6's currently willing to try tackle that or not :)
01:28:30 <Gracenotes> ##c is the C channel
01:28:35 <capt> ok
01:28:39 <capt> thnx
01:28:50 <Gracenotes> no problem
01:29:15 <beelsebob> ski_: I'd be surprised if he wasn't willing to look at something that'll make his toy much much cooler
01:29:39 <blackh> Axman6: Ah - interesting - I see how it works. I love the threading model in GHC - and this is another example of the cool stuff you can do.
01:30:28 <ski_> (blackh : Erlang does the same all the time)
01:31:06 <Gracenotes> now, just a distributed systems model in GHC, and we'll be set
01:31:40 <Axman6> yeah, we really do need a nice distributed model for GHC
01:31:44 <blackh> ski_: Interesting. I'm a big fan of event-based programming, and I'm fairly new to functional programming.  I discovered I've got a 1988 book on functional programming that's been gathering dust for 20 years. :)
01:32:06 <blackh> When I learnt it at University I thought "What would you want to do this stuff for??"
01:32:07 <ski_> blackh : named ?
01:32:20 <Axman6> ha :)
01:33:06 <blackh> ski_: Functional Programming by Anthony J. Field and Peter G. Harrison.
01:33:22 <blackh> ski_: It uses a language called Hope. Haskell is the only functional language I've heard of. :)
01:33:54 <Axman6> ski_: one problem i have with that way of doing things is that i can't handle exceptions nearly as well
01:34:19 <ski_> please elaborate
01:34:21 <Gracenotes> you can catch exceptions in IO. tis all though
01:34:42 <blackh> I have a question for a cabal expert: How can I install a package as if I'm installing from hackage? That is, I want to test all the dependencies and versions before I upload
01:34:43 <Gracenotes> it seems an odd trait that exceptions can be thrown anywhere but only caught in IO
01:35:10 <dcoutts> blackh: go to the dir and cabal install
01:35:14 <ski_> it's to ensure purity
01:35:29 <ski_> if you want to catch exceptions otherwise, use `Either e'
01:35:32 <Axman6> ski_: check out http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1478#a1478 where i've added some exception handling
01:35:56 <Gracenotes> ski_: throwing exceptions via 'error' in the first place isn't terribly pure, I don't think ;)
01:36:06 <Gracenotes> practically, I'm glad Haskell has it
01:36:26 <blackh> dcoutts: But that uses the latest base, right? I want it use the same logic as it would if installing from hackage. (Same conversation as yesterday, almost.)
01:36:34 <ski_> (and damn `instance Error e => Monad (Either e)')
01:37:03 <dcoutts> blackh: no, it's the same as cabal install <pkgname-from-hackage>
01:38:13 <Axman6> ski_: ah yeah, i could indeed just use Either :)
01:38:38 <blackh> dcoutts: Thank you!
01:38:49 * blackh will fix HsOpenSSL!
01:38:58 <ski_> why not `MVar (Maybe E.SomeException)' for `Mod' ?
01:39:20 <ski_> then you could reraise the exception on the receiving end
01:39:30 <Axman6> yeah, that would work too
01:40:07 <Axman6> Nothing would be ok, and Just error as the error right?
01:40:41 <ski_> also, since you're in `IO' anyway, maybe you should consider passing `a -> IO a' or somesuch
01:40:57 <ski_> (and then the sender could use `evaluate' should they so wish)
01:41:14 <ski_> Axman6, yes
01:42:05 <ski_> (`MVar (Either E.SomeException result)' for the modify with result case)
01:42:21 <Axman6> yeah, i like that better
01:43:17 <ski_> swap new = Mod' (\old -> (new,old))
01:43:43 <ski_> also, does that data type definition in the paste really type-check ?
01:43:53 <ski_> (`b' appears not in scope)
01:46:21 <Axman6> hmmm... ok, now i have problems :(
01:46:47 <Axman6> i ca't get the b in there safely from what i can tell
01:47:30 <Axman6>     | Mod' (a -> (a,b)) (MVar (Either E.SomeException b))
01:47:35 <Axman6> won't typecheck :(
01:47:44 <ski_> hide `e'
01:47:53 <Axman6> huh?
01:48:23 <ski_> all `handler' needs to know is that there exists some type `b' (same for the function as for the `MVar')
01:49:37 <ski_>     | Mod' (exists b. (a -> (a,b),MVar (Either E.SomeException b)))
01:49:41 <ski_> or, properly
01:49:54 <ski_>     | forall b. Mod' (a -> (a,b)) (MVar (Either E.SomeException b))
01:49:54 <Gracenotes> eek
01:50:08 <ski_> if you prefer, you can use GADT syntax
01:50:33 <ski_>     Mod' :: (a -> (a,b)) -> MVar (Either E.SomeException b) -> Transaction a
01:50:55 <ski_> (the `forall b.' (as well as `forall a.' is optional, there)
01:51:10 <Axman6> whoot, got it to typecheck, thanks ski_ :)
01:51:36 <ski_> is this your first existential ?
01:51:47 <Axman6> i think so...
01:53:29 <ski_> (anyway, i would probably change this to either use `a -> IO (a,b)' or use `Either e'-style exceptions)
01:53:55 <ski_> (possibly hidden behind some generalized interface)
01:55:00 <Axman6> i'd like to keep the interface as 'functional' as i can, so modifications only need functions of type a -> a
01:56:19 <mornfall> Hm, is it possible to tell cabal to always install profiling-enabled libs?
01:56:27 <mornfall> (Without remembering to pass -p all the time...)
01:56:33 <dcoutts> mornfall: yep, in the ~/.cabal/config
01:57:04 <loadquo> Can someone give me an example of using ((->)r) as a functor?
01:57:07 <mornfall> Right, but how? :) cabal-install page in trac says the config lists everything that's valid, and I don't see anything that would resemble options or such.
01:57:18 <mornfall> Ah, hm.
01:57:25 <dcoutts> mornfall: ah, you've got a config file generated by an older version.
01:57:29 <mornfall> Could be.
01:57:33 * mornfall removes.
01:57:40 <dcoutts> mornfall: move it out the way, let it be re-created and merge back any changes
01:57:47 <mornfall> Ah!
01:57:47 <mornfall> Great.
01:57:48 <mornfall> Thanks.
01:57:54 <Axman6> loadquo: (f ::b->c) `fmap` (g :: a -> b) == f.g
01:58:10 <ski_> Axman6 : ok .. so no `a -> Either e a', then ?
01:58:20 <Axman6> ski_: i'd prefer not to
01:58:41 * ski_ would prefer such to `evaluate', he thinks
01:58:59 <loadquo> Thanks Axman6
01:59:12 <Axman6> @src (->) functor
01:59:12 <lambdabot> Source not found. That's something I cannot allow to happen.
01:59:16 <Axman6> @src (->) Functor
01:59:16 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:59:19 <Axman6> bah
01:59:30 <ski_> > (do x <- sin; y <- cos; return (x + y)) (pi / 4)  -- loadquo
01:59:31 <lambdabot>   1.414213562373095
01:59:42 <Axman6> o.O
01:59:57 <Axman6> ski_: technically isn't that Monad, not Functor?
02:00:05 <Axman6> @src (->) fmap
02:00:05 <lambdabot> fmap = (.)
02:00:10 <mornfall> dcoutts: While you are here, is it possible to override the /tmp location?
02:00:19 <mornfall> It doesn't seem to pick up $TMP nor $TEMP.
02:00:27 <ski_> every instance of `Monad' is (i.e. ought to be) a functor
02:00:57 <ski_> (but, yes, i didn't directly use `fmap' or `liftM', there)
02:01:15 <loadquo> I was interested in its functor-iness.
02:01:34 <ski_> ok
02:07:17 <moozilla> hey, I'm new to linux and I'm trying to get some code working that worked on windows
02:07:34 <moozilla> it says it can't find Control.Monad.Reader
02:07:49 <mornfall> You're probably missing the mtl package.
02:07:51 <moozilla> I thought that was a standard library
02:07:56 <blackh> moozilla: What Linux distribution are you using?
02:08:02 <moozilla> debian
02:08:03 <quicksilver> apt-get install libghc6-mtl-dev
02:08:14 <moozilla> thank you
02:08:34 <blackh> moozilla: The ghc libraries are thoroughly fragmented on debian so you have to install lots of bits and pieces to get standard stuff.
02:08:38 <quicksilver> moozilla: it's technically an "extra" library - it comes bundled with the large installer packages but not the small lean downloads.
02:08:51 <moozilla> also, this is probably a dumb quesiton, what do I do to get out of ghci
02:08:55 <quicksilver> :quit
02:09:00 <moozilla> thanks
02:09:01 <blackh> moozilla: or ctrl-D
02:09:10 <quicksilver> or C-x k
02:09:17 <quicksilver> (if you run ghci in emacs like a sane person!)
02:09:18 <quicksilver> ;)
02:09:30 <moozilla> I'm REALLY new to linux
02:09:30 <ski_> (possibly `C-z' on windows ..)
02:09:38 <blackh> moozilla: Remember ctrl-D - it will be very helpful on Linux.
02:09:39 <moozilla> I'm ssh-ing through putty
02:09:44 <hotaru2k3> no sane person uses emacs
02:09:53 <moozilla> alright
02:10:17 <ski_> (moozilla : i hope you've found screen as your personal saviour, then ?)
02:10:34 <moozilla> I have used screen a little bit
02:11:10 <moozilla> ok that seemed to work for the Control.Monad.Reader
02:11:16 <moozilla> but now it can't find Network >_>
02:11:40 <loadquo> @hoogle Network
02:11:40 <lambdabot> package network
02:11:40 <lambdabot> package network-bytestring
02:11:40 <lambdabot> package network-connection
02:11:55 <doserj> apt-get install libghc6-network-dev
02:12:01 <blackh> moozilla: Try this command:  apt-cache pkgnames | grep '^libghc' | sort
02:12:02 <moozilla> libghc6-network-dev?
02:12:14 <moozilla> my friend told me about apt-cache search
02:13:05 <quicksilver> no need to guess
02:13:06 <quicksilver> look at
02:13:07 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
02:13:15 <quicksilver> you see the right-hand column? that's the package name.
02:13:33 <quicksilver> AFAIK, debian package will always be "libghc6-pkgname-dev"
02:13:52 <quicksilver> e.g. alongside Control.Monad.Reader you see mtl
02:13:57 <quicksilver> (plus a version number which you can ignore)
02:13:58 <moozilla> yay it works :)
02:14:01 * ski_ has `http://www.haskell.org/ghc/docs/latest/html' hardwired into brain
02:14:25 <moozilla> thank you all
02:14:39 <moozilla> #haskell is the best
02:14:42 <quicksilver> ski_: that one doesn't have source links.
02:14:52 <quicksilver> ski_: the one I pasted (dist/current) does
02:15:19 <ski_> ok .. it was awhile since i manually followed the links from the main page
02:15:40 <quicksilver> nothing wrong with your link
02:15:45 <quicksilver> it's just haddock barfed when it ran on that one
02:15:49 <quicksilver> and the soruce links all broke
02:15:55 <ski_> ic
02:15:57 <quicksilver> so I've taken to using one of the others
02:16:23 <quicksilver> disadvantage with mine is it is current, so it reflects library changes which might be later than what I have installed
02:16:29 <quicksilver> but I don't worry about that too much
02:22:22 <ski_> @vixen do you worry?
02:22:22 <lambdabot> maybe. do you?
02:23:03 <ski_> @vixen what, me worry?
02:23:03 <lambdabot> let's don't talk about that
02:23:17 <Axman6> s/don't/not
02:25:47 <Axman6> how interesting. wrote a benchmarking function for this ASTM thing, and it's a _lot_ slower when compiled with -threaded, even without specifying -Nn
02:26:39 <ski_> (possibly due to the use of `MVar')
02:26:49 <quicksilver> Axman6: well the threaded RTS is more complex, but still that sounds like something JaffaCake and/or glasgow-haskell-users (the mailing list) would like to hear about
02:27:21 <Axman6> ok, i'll see what i can say about it and post something  :)
02:27:21 <JaffaCake> Axman6: if you have communication between the main thread and other threads, that will be slower
02:27:25 <pumpkin> wow, Regular-sized Jaffa Cakes are circular, approximately 54 mm (2⅛ inches) in diameter.
02:27:54 <JaffaCake> Axman6: rule of thumb is to move all your work out of the main thread, unless you really need to use bound threads
02:28:28 <Axman6> JaffaCake: i'm using Chans. i was kind of hoping they'd be a little nicer than they appear to be though :(
02:28:40 <JaffaCake> nicer in what way?
02:29:02 <pumpkin> Chans are awesome
02:29:37 <Axman6> not sure... heh. but i'm finding that using -threaded has _massive_ speed differences
02:30:02 <MyCatVerbs> Axman6: -threaded without -N greater than one will be slower than non-threaded.
02:30:28 <Axman6> MyCatVerbs: yeah, that's fair enough, but i wasn't expecting it to be this much slower
02:30:46 <JaffaCake> Axman6: it should be no more than a few percent, as long as you're not communicating between bound and unbound threads
02:31:11 <JaffaCake> that's the biggest pitfall
02:31:20 <MyCatVerbs> Axman6: with -threaded, the Haskell runtime has to use synchronization primitives suitable for multiprocessing, which are quite slow. Like, every synchronization point can take as long as an L2 cache miss.
02:32:13 <Axman6> well, i'm using a forkIO'd 'variable' (see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1478#a1478). but the difference is 0.639s without -threaded, and 19.240s with.
02:32:19 <MyCatVerbs> Axman6: without it, the synchronization primitives merely involve a quick trip through the RTS; because there's only one OS thread of execution, the runtime just multiplexes your forkIO threads across it.
02:32:25 <JaffaCake> MyCatVerbs: depends on the processor, recent processors are getting better at implementing atomic instructions
02:33:14 <JaffaCake> Axman6: don't use the main thread for anything, forkIO a worker thread to do the work
02:33:17 <p_l> JaffaCake: Yeah, with i7 it even intel sucks less than it used to (cache sync ftw)
02:33:28 <MyCatVerbs> JaffaCake: oh really? I'm surprised it's not getting worse, considering that core counts are increasing. Good to know, I guess, though I don't think it'd be safe to rely on that.
02:34:11 <JaffaCake> e.g the Sparc T2 is *much* better than Intel, we recently discovered
02:34:12 <Axman6> JaffaCake: i'm not sure what you mean
02:34:15 <quicksilver> MyCatVerbs: nothign about processors is safe to rely on these days :)
02:34:27 <MyCatVerbs> Axman6: programs that hit a lot of synchronization points with very little work in between them will always suck on multiprocessing machines.
02:34:30 <Axman6> JaffaCake: been working with Benl?
02:34:39 <JaffaCake> yes
02:34:40 <ski_> Axman6 : `forkIO' the part communicating with the state thread
02:35:06 <JaffaCake> Axman6: in your main function, use forkIO to create a worker thread, and do all your work in that thread
02:35:58 <JaffaCake> the problem is that the main thread is a "bound" thread, and communicating with bound threads is the same as communicating between full OS threads, i.e. very expensive
02:36:24 <Axman6> ah, i see
02:37:18 <Axman6> JaffaCake: oh excellent, around 19 times faster once i've done that :)
02:37:18 <JaffaCake> Axman6: oh, and that catch in the handler function is very suspicious
02:37:31 <Axman6> JaffaCake: how so?
02:37:51 <JaffaCake> catching SomeException is usually wrong, and tail-calling out of the handler is a very bad idea
02:38:05 <MyCatVerbs> quicksilver: I'm remaining pretty confident about all those things that come about as a result of physics. Like, the speed of light. :P
02:38:32 <Axman6> well, this is my first time playing with exceptions, so i'm bound it get it wrong. maybe i want bracket or something?
02:38:59 <JaffaCake> depends what you're trying to do...
02:39:41 <Axman6> well, i'd like to be able to handle any exception the functions passed to my 'var' might produce
02:39:43 <ski_> (JaffaCake : i think possibly in this case Axman6 wants to capture all but asynchronous exceptions, and reraist the caught ones on the other end of the channel)
02:39:46 <JaffaCake> Axman6: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Exception.html#3
02:39:59 <JaffaCake> that's the latest docs for Control.Exception, with some hints about how to use catch
02:40:13 <Axman6> ah, excellent, i'll take a loot at those :)
02:40:19 <p_l> MyCatVerbs: Except that c != speed of light ;-)
02:41:35 <Axman6> JaffaCake: do you have any suggestions for what would be a more appropriate way of doing what i'm doing?
02:41:40 <MyCatVerbs> p_l: meh. Travel time is o(1/c), which is a good enough bound for me. :)
02:41:52 <ski_> (JaffaCake : or, oh .. you're talking about `handler' being inside the dynamic extent of the `catch' .. yes, that's bad)
02:42:15 <Axman6> wait, i know how i can fix that
02:42:34 <JaffaCake> ski_: right
02:42:36 <Axman6> maybe...
02:42:55 <JaffaCake> Axman6: use 'try', if possible
02:43:04 <ski_> exceptional syntax ftw !
02:43:55 <ski_> catchBind :: Exception e => IO a -> (e -> IO b) -> (a -> IO b) IO b
02:44:04 <ski_> er
02:44:07 <ski_> catchBind :: Exception e => IO a -> (e -> IO b) -> (a -> IO b) -> IO b
02:44:14 <ski_> is what we need
02:45:30 <ski_> (you can build it with returning `IO (Either e a)' or `IO (IO b)' ..)
02:46:59 <JaffaCake> ski_: how is that better than using 'try' and 'either'?
02:47:50 <ski_> no extra `Either' to model the alternatives
02:47:54 <quicksilver> JaffaCake: oh, you fixed the docs!
02:48:09 <quicksilver> JaffaCake: for ages that page had correct method signatures but out-of-date docs.
02:48:32 <ski_> (it's conceptually irritating to make a value of `Either' just to eliminate it almost directly again .. possibly there's some performance improvement, too)
02:48:41 <idesperado> hi,there.I newly run into xmonad and find it's a great  thing.After paste and copy Mr.John Goerzen's config from his  tutorial and my box goes well...but I don't know how to move on  and proceed...any suggestions?
02:48:41 <JaffaCake> Igloo did the fixing I think, I just added the section on "catching exceptions", and some other tweaks
02:49:00 <Axman6> JaffaCake: is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1478#a1480 better?
02:49:18 <idesperado> I thought it's kinda related to haskell...so ask here..
02:49:28 <quicksilver> cool.
02:49:29 <Axman6> idesperado: #xmonad might be better
02:49:37 <JaffaCake> Axman6: yes, though using 'try' would be slightly cleaner
02:50:20 <idesperado> Axman6: I thought writing config of xmonad is haskell thing...so ask here...just wanna some suggestions
02:50:44 <Axman6> idesperado: well, they'd be able to help you with xmonad issues better, and they'll all know haskell quite well
02:51:51 <ski_> (though, it would be nice with more syntax integration like <http://martin.jambon.free.fr/extend-ocaml-syntax.html#lettry> .. however that would probably be part of reflective monad syntax ..)
02:52:03 <JaffaCake> ski_: it's hard to sell catchBind, when people won't understand why "catchBind x y z" cannot just be written "catch (x>>=z) y"
02:52:28 <ski_> `z' should not be in the dynamic extent of the exception handler
02:53:04 <JaffaCake> right, but it's hard to see why z would be outside the dynamic scope
02:54:35 <JaffaCake> ski_: IMO try is much clearer, because the execution continues in the enclosing 'do', it's obvious we've left the scope of the catch
02:55:26 <ski_> `try' is ok
02:56:09 <ski_> (but still, i'd prefer having both)
02:56:51 <JaffaCake> as you say, you can build it using the existing functions
02:57:49 <ski_> ("having" as in the library .. i meant ;)
02:58:31 <JaffaCake> feel free to propose it on libraries@
02:59:01 <JaffaCake> I wouldn't object too strongly ;)
03:00:10 <quicksilver> the fiddliness of using exceptions correctly is often enough to convince me not to use them ;)
03:00:16 <quicksilver> opting instead for something like Either.
03:00:41 <quicksilver> I think I only really use exceptions for genuinely asynchronous stuff
03:00:45 <quicksilver> such as throwTo
03:01:04 <JaffaCake> isn't throwTo great? :)
03:07:08 <Axman6> argh, i'm struggling to convert this thing from my original catch version to using try :(
03:08:30 <Axman6> getting a very strange error, and i can't see how what i have now is any different to what i had before
03:08:32 <Peaker> Exceptions are a really problematic mechanism -- implicit propagation of all exceptions is almost always the wrong thing to do, especially as the meaning of exception types may change when propagated from context to context
03:09:47 <Axman6> how is what i have here different from the commented out version using catch? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1478#a1481
03:10:50 <quicksilver> rule of thumb: any code using evaluate is incorrectly designed
03:11:00 <quicksilver> rule fo thumb: don't throw exceptions from pure functions
03:11:08 <quicksilver> but I'm not quite sure what you're trying to do here.
03:11:20 <Axman6> i'm not planing to, but functions used with this may well do
03:11:55 <quicksilver> you do realise that evaluate will only push out those exceptions encountered when forcing to WHNF?
03:12:10 <quicksilver> that it will completely ignore the exception in "Just (throw blah)" for example?
03:12:30 <quicksilver> or (\a -> throw blah)
03:12:31 <Axman6> i think that's fine for what i'm trying to do
03:13:08 <quicksilver> which two versions am I supposed to be comparing?
03:13:31 <Axman6> in that last paste? just what;s commented out and the code underneath it
03:15:05 <quicksilver> wasn't JaffaCake saying the tail call from the handler was a bad thing?
03:15:33 <Axman6> i thought he was saying it was a bad idea inside the catch
03:15:40 <quicksilver> that's what I mean, yes
03:15:46 <quicksilver> both branchs of your catch recurse on 'handler'
03:15:51 <quicksilver> before they actually return
03:15:57 <quicksilver> (I assume this is recursion?)
03:15:59 <Axman6> well, they need to
03:16:01 <Axman6> yes
03:16:17 <quicksilver> in particular "handler chan a" is still in the scope of the catch
03:16:22 <quicksilver> so any exceptions in there will get caught
03:16:25 <ski_> Axman6 : i think you need `Left e -> do putMVar mvar (Left e); ...'
03:16:26 <Axman6> i'm emulating a mutable veriable using a function
03:16:31 <quicksilver> this is quite different from your second case
03:16:45 <quicksilver> in your second case it's *only* exceptions int he WHNF of y that are caught
03:16:58 <quicksilver> in the first case, you're catching any exceptions in 'handler chan a' as well
03:17:05 <Axman6> quicksilver: which is what i want
03:17:13 <ski_> the former `Left e' has type `Either E.SomeException (a,b)', the latter `Either E.SomeException b'
03:17:15 <quicksilver> well they are different.
03:17:19 <Axman6> the second case
03:17:40 <quicksilver> ski_: \Left e -> Left e is the same as \e -> e
03:17:46 <ski_> no
03:17:50 <quicksilver> he's just not being consistent with his naming
03:17:52 <Axman6> well, yes, but i want them to act the same. i don't want to be catching exceptions in the handler, because there shouldn't be any really
03:18:01 <ski_> @type \(Left e) -> Left e
03:18:02 <lambdabot> forall t t1 b. Either t1 t -> Either t1 b
03:18:14 <ski_> `t' and `b' there can be different
03:18:15 <Axman6> ski_: huh, seems that worked, thanks :)
03:18:17 <quicksilver> ah right
03:18:19 <quicksilver> yes.
03:18:21 <ski_> (and are so in this case)
03:18:34 <quicksilver> Axman6: you had a compile error ?!?!?!
03:18:39 <Axman6> yes
03:18:39 <quicksilver> Axman6: wtf didn't you tell us?
03:18:43 <quicksilver> I was looking for a smenatic bug.
03:18:57 <quicksilver> how dare you do that without telling us what the compile error was?
03:19:03 <quicksilver> @slap Axman6
03:19:03 * lambdabot smashes a lamp on Axman6's head
03:19:04 <quicksilver> :P
03:19:06 <Axman6> oh, sorry, yes i really should have put that there. but i thought it might mean pasting the whole code
03:19:07 <idnar> ouch :P
03:19:21 <Axman6> sorry quicksilver :)
03:19:42 <ski_> if we had extensible variants like O'Caml, or refinement types, then the system might know that when the `Right _' pattern failed, it could replace the `(a,b)' part of `Either E.SomeException (a,b)' with a fresh type variable
03:22:39 <quicksilver> ski_: I'm not entirely sure if I'd want that.
03:22:49 <quicksilver> ski_: the current system makes sense to me, even though it just caught me out ;)
03:24:53 <dolio> Is the code for \Left a -> Left a as good as for \e -> e? That's all that matters. :)
03:25:22 <ski_> (well, it's not because it's partial)
03:25:43 <dolio> Well, true, not there.
03:25:45 <ski_> (but, apart from that detail, it's the same in this context)
03:26:11 <dolio> But in 'f (Right _) = ... ; f e = e'.
03:26:14 <Deewiant> Can I ask GHC to generate an x86 executable instead of an x86-64 executable?
03:26:21 <ski_> dolio : *nod*
03:27:06 <Deewiant> Or do I need to have an x86 version of GHC for that purpose?
03:27:37 <dolio> You probably need at least a 32-bit environemnt in which to link.
03:27:48 <Deewiant> I have a 32-bit chroot.
03:28:16 * ski_ ponders whether one could do such a type-system without extensible variants or refinement types or the like
03:28:55 <pejo> Deewiant, it doesn't cross-compile, no.
03:29:16 <Deewiant> Alright, thanks.
03:29:20 <pejo> Deewiant, how much work is it to do the 32-bit chroot? (Can you run your webbrowser there?)
03:29:36 <Deewiant> I do run my webbrowser there.
03:29:47 <Deewiant> You mean, to set it up? Not much.
03:30:08 <z0d> pejo: debootstrap for the win
03:30:20 <ski_> if a type parameter is only mentioned in types of constructors, all of which has already failed matching, then one could reset that type parameter to fresh for the rest of the matching, it seems to me
03:30:49 <ski_> so in
03:30:59 <pejo> z0d, does that do it automatically?
03:31:13 <ski_>   data Either a b = Left a | Right b | Right2 b
03:31:52 <ski_> you'd need to remove both the `Right' and `Right2' cases before being allowed to reset the second type parameter of the scrutinee, for the course of the matching
03:32:08 <z0d> pejo: It downloads a minimal system, which you can chroot to and start installing software via apt-get
03:33:46 <ski_> (quicksilver : any specific reason you'd prefer the current system to something like what i sketched above ?)
03:33:52 <ski_> (assuming it would work)
03:35:03 <ski_> maybe that (static) semantics of matching clauses would depend more on order than currently ?
03:35:32 <ski_>   data Foo a b = F0 a | F1 a b | F2 b
03:35:49 * ski_ ponders
03:36:36 <quicksilver> ski_: harder to explain static semantics, I think.
03:36:40 <ski_>   foo :: Foo a -> ..
03:36:55 <ski_> hm
03:37:12 <ski_> actually, my example would be obvious with `Either' too, i note
03:37:20 <ski_>   foo :: Either a b -> ..
03:37:33 <ski_>   foo x@(Left a) -> ..
03:37:41 <ski_>   foo  (Right a) -> ..
03:37:52 <ski_> `x' has different type, if you change order
03:38:18 <ski_> quicksilver : ok
03:38:30 <quicksilver> and limited application?
03:38:37 <quicksilver> I don't find this situation arises all that often.
03:38:57 <dolio> It couldn't generalize the type of x if it knew it was a Left?
03:39:00 <ski_> (though one could handle all cases with no "catch-all" "on the same level" to remedy this in this example)
03:39:47 <ski_> dolio : in the above case, it wouldn't know yet that `x' couldn't be `Right ..' and so couldn't replace `b' with `b2'
03:39:56 <ski_> (in my intended static semantics, i mean)
03:40:10 <ski_> but, if you changed the order, then it would do it
03:40:40 <dolio> If you're matching against Left in that case, how does it not know it can't be a Right?
03:40:51 <ski_> quicksilver : mayhaps .. though every time i hit it, i'm irritated
03:41:27 <ski_> yes, as i mumbled, probably it could be smarter than this
03:41:44 <dolio> Okay.
03:42:17 <ski_> you're suggesting that all type variables not in the matched constructor gets replaces if that matches
03:43:27 <ski_> (ok, i now realize the extension i wanted is subsumed / best expressed by your idea)
03:43:59 <ski_> (the extension of the type system feature extension we're discussing, i mean)
03:44:19 <dolio> It'd be a bit weird with phantom types.
03:44:31 <ski_> point
03:45:09 <ski_> though, with phantom types, it's already the writers responsibility to restrain the type parameters
03:45:18 <dolio> Yeah.
04:08:27 <Axman6> ski_: if i were to refer to you in a blog post at some point, would you prefer to be named by your real name?
04:09:08 <augustss_> He has a name? ;)
04:09:37 <Axman6> presumably... but this is the internet...
04:14:07 <ski_> Axman6 : either `ski on #haskell' or my real name (as from `/whois') would be ok
04:14:26 <Axman6> ok, thanks
04:18:37 <Axman6> quicksilver: what about you, do you have a real name i can refer to you as in a blog post?
04:18:41 <wman> hi, is there someone who could create an account for haskell wiki for me ? build info on leksah is outdated, so I thought I'd update it, but account creation is disabled and no info on how to request an account is provided
04:19:05 <Axman6> JaffaCake: you too, if you don't mind :) (see above if you don;t get this right away)
04:19:23 <JaffaCake> Axman6: see my info
04:19:35 <blackh> Axman6: Did you see the shiny new graph on the shootout? It's much clearer how fast each language is - Haskell is just slightly behind Java. It's very nice.
04:19:53 <quicksilver> Axman6: generally people refer to me a quicksilver on #haskell
04:19:54 <ivanm> Axman6: you've tried /whois I presume?
04:19:58 <quicksilver> my real name is not a secret, though.
04:20:14 <Axman6> blackh: i haven't, but i will do now :)
04:20:49 <quicksilver> even my bank statements are addressed to 'quicksilver on #haskell'
04:20:57 <Axman6> JaffaCake, quicksilver: thanks, got it :)
04:21:16 <Axman6> quicksilver: would you prefer quicksilver on #haskell to your real name?
04:21:23 <quicksilver> yes.
04:21:38 <blackh> Axman6: Do "all languages" / "all benchmarks" then click Show... Then select the first few languages down the bottom and click Show again - otherwise it misses several out.
04:22:10 <blackh> Axman6: Ah - you have to click "calculate" at the bottom.
04:23:16 <Axman6> blackh: heh, not sure it is that much clearer, maybe i have too many language selected though
04:23:20 <blackh> Axman6: So Haskell is slightly behind Java and then there's a small gap, then C# Mono and O'Caml.  So why couldn't I get my hash tables faster than O'Caml? Hmm. :)
04:24:34 <ivanm> hash tables? what hash tables?
04:24:53 <blackh> ivanm: k-nucleotide benchmark, which is the one I had a go at
04:25:22 <ivanm> but you used hash tables?
04:25:23 <moozilla> haskell can
04:25:28 <moozilla> not be behind java
04:25:30 <ivanm> :s
04:25:40 <ivanm> moozilla: it obviously is though...
04:25:48 <blackh> moozilla: If you choose "full data" then Haskell is faster than Java
04:25:56 <moozilla> ah
04:26:25 <Axman6> moozilla: sure it can. jave can be very fast, and things like the hotspot JVM can make is reallt fast
04:26:27 <ivanm> mainly because (/me hasn't checked it now, but this is the general versions I've heard of) 1) they use java server, which is faster; 2) the java submissions have been updated since the haskell ones have been (i.e. they've tweaked them to beat haskell)
04:26:48 <moozilla> ah
04:27:24 <moozilla> yeah i thought haskell was almost as fast as c if you do it right
04:27:32 <ivanm> Java is mainly slow in the jvm start up time... the server option has a much reduced startup time, which is why ti's faster
04:27:41 <ivanm> moozilla: yes, but that's usually too much effort for not enough gain
04:29:33 <andun> it's basically a benchmark of crazy optimized code, isn't it?
04:29:54 <ivanm> yup
04:29:59 <andun> doesn't really say anything about what to expect when you write code "casually"
04:30:12 <ivanm> with the haskell stuff usually being over-optimized and thus non-idiomatic
04:30:17 <ivanm> andun: excactly
04:30:18 <andun> right.
04:30:23 <ivanm> but then again, it says that IIRC
04:30:27 <Axman6> andun: the code is supposed to be readable and understandale too though
04:30:46 <SamB> maybe there should be another Haskell category for idiomatic Haskell ?
04:31:01 <SamB> but of course they won't let us write that stuff, will they ...
04:31:21 <SamB> "using bitpacked arrays is cheating!" they say ...
04:31:24 <blackh> IMO the point of it is just to show people that might adopt Haskell that they won't encounter performance headaches.
04:31:27 <Axman6> well, that's what i've tried to do woth mt n-bodies stuff, but it's not as fast
04:32:17 <blackh> I can speed up the binary-trees benchmark by turning a recursive function into three functions, but that's equivalent to unrolling a loop, so I haven't done it.
04:32:39 <blackh> I think there's a bit of a performance penalty in function applications...
04:32:59 <Axman6> blackh: have you checked with them whether you can use that version?
04:33:05 <blackh> in many cases inlining fixes it, but if it's a recursive function that iterates over a tree, you have to turn it into three or so functions.
04:33:19 <Axman6> better to submit it and have it rejected than not do it, and never have it compete
04:33:28 <andun> i do have a recent experience at school where i wrote in haskell and some buddies wrote in lisp and python, and my code outperformed theirs by an order of magnitude, although we basically used the same algorithms. to me, that is much more valuable than benchmarks like that
04:33:57 <blackh> Axman6: So do I say "Hey, we're doing the equivalent of unrolling a loop here"? Or do I keep quiet?
04:33:58 <SamB> andun: and they compiled theirs ?
04:34:08 <andun> SamB: the lisp guys, yes.
04:34:22 <Axman6> blackh: keep it quiet >_> :P
04:34:24 <blackh> Axman6: I have gained 10% by parallelizing and it would be worth submitting just for that reason.
04:34:29 <SamB> did the Python guys use psyco?
04:34:33 <Axman6> blackh: yes indeed :)
04:34:47 <blackh> Axman6: But then my conscience would bother me!
04:35:00 <Axman6> gimme the code, i'll do it!
04:35:00 <andun> SamB: no, normal python with some C stuff to speed up parts
04:35:01 <blackh> Axman6: Perhaps I can have it removed.
04:35:04 <Axman6> :P
04:35:10 <SamB> andun: uh
04:35:11 <SamB> okay
04:35:25 <SamB> how did they decide which parts /
04:35:33 <SamB> were they sure it helped ?
04:35:39 <Axman6> it is any faster with the parallelism, and without the unrolling?
04:35:53 <andun> SamB: cython iirc
04:36:11 <SamB> andun: cython?
04:36:12 <blackh> Axman6: You can submit it if you want - I'll send you what I've done so far.
04:36:25 * SamB thought it was called CPython
04:36:27 <andun> SamB: they didn't afaik.
04:36:34 <andun> or, s/they/he/
04:36:43 <andun> cython is something else
04:36:46 <blackh> Axman6: Total time is no different, but elapsed time is 10% better on my dual core. I believe there's some lock contention in memory allocation in GHC, but it should be better than 10% on their quad core.
04:36:48 <Axman6> blackh: nah, i'd rather leave it up to you what to do with it
04:37:14 <andun> SamB: but i used the ghc profiler (which is _great_, imo) to find parts to optimize somewhat
04:37:45 <blackh> Axman6: But I don't know what to do!  I'd rather not cheat, if only because I think Haskell is trying to be the best, not the fastest
04:37:48 <SamB> ah, cython.
04:37:57 * SamB finds it in the apt listings
04:38:11 <SamB> oh, based on Pyrex is it?
04:38:18 <andun> i have no idea
04:38:36 <SamB> well, it says so in the package description ;-P
04:38:40 <andun> :P
04:39:11 <andun> well, the java guys did better than me, though. but i think they put more effort into their algorithms too
04:39:43 <SamB> that doesn't sound very characteristic of Java guys
04:40:22 <andun> haha. they are good :)
04:44:16 <blackh> Axman6: Some time I will submit the parallelism change to binary-trees, which only requires adding "parMap rnf id $ ", which I thought was rather cool.
04:44:32 <Axman6> heh, awesome :)
04:44:34 * SamB grumbles about http://trac.haskell.org/robots.txt
04:49:42 * cizra laughs at http://learnyouahaskell.com/listmonster.png
05:01:15 <ksf> hmmm... am I hoping right if I hope that iteratees hold a weak enough ref to their underlying iteratee to avoid large chunks being held in memory as I seek to the end of the file by traversing its top structure?
05:01:44 <ksf> I want to be lazy in both length and depth of the file, that is.
05:03:19 <quicksilver> ksf: that's not really a property of the framework as a whole
05:03:30 <quicksilver> it would be a property of how you wrote a particular iteratee
05:03:51 <quicksilver> but it's certainly something you'd hope to get right.
05:03:59 <quicksilver> in a way, that's the whole point of them.
05:04:10 <quicksilver> to allow efficient resource usage without unsound lazy IO
05:05:17 <blackh> ksf: What package is this that you're talking about?
05:05:45 <ksf> I'm not aware of any iteratee packages, only of oleg's code.
05:06:34 <blackh> Well, it sounds good.
05:07:04 <ksf> what I want to do, though, is isomorphic to having an iteratee for each xml element I come across, and seeking randomly into the file as I force different parts of the structure they return.
05:08:03 <ivanm> citeproc-hs's cabal file mentions a Paths_citeproc_hs ... any idea where that file would be located, because it isn't located in the source tarball :s
05:08:13 <ivanm> (and is Paths_ a "special" location?)
05:09:56 <doserj> http://www.haskell.org/cabal/release/latest/doc/users-guide/authors.html#paths-module
05:11:13 <ivanm> thanks doserj
05:14:24 <cytzol> Hi #haskell. GHC is giving me a type signature, then refuses to accept it when I use it - http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1434
05:14:57 <cytzol> I found a thread on haskell-cafe that tries to explain it but it's still kind of confusing. Can anyone help?
05:14:59 <ivanm> cytzol: you're using the correct extensions I take it?
05:15:18 <cytzol> ivanm: multiparamtypeclasses, functionaldependencies
05:15:30 <ksf> gragh. read. I'd rather use mmap.
05:16:33 <ivanm> in that case, my guess is that it isn't sure which type of lCompare it's going to be using after the && bit :s
05:16:45 <ivanm> not sure why it's thinking that, but still...
05:17:08 <doserj> well, there is nothing that fixes the type variable a
05:17:10 <ivanm> cytzol: because you haven't specified which type 'a' to use
05:17:22 <ivanm> doserj: yeah, I just spotted that myself... but you beat me to saying so!
05:17:30 <doserj> sorry :)
05:17:49 <ivanm> dammit, this would have been my first chance to help someone out with "advanced" haskell stuff :@
05:17:50 <ivanm> ;-)
05:18:59 <cytzol> I use 'a', just not in this function
05:19:16 <ivanm> cytzol: well, you only know how 'b' works if you know which 'a' fixes it
05:19:23 <doserj> so maybe ScopedTypeVariables, explicitely quantifying over a and b in the type signature of lCompare, and ascribing a type signature to the recursive use of lCompare helps.
05:19:28 <ivanm> so it doesn't know which matchToken type to use
05:19:56 <ksf> is there any other iteratee code except oleg's?
05:20:47 <cytzol> doserj: I tried adding "forall a b." but it didn't change, if that is what you mean.
05:21:27 <doserj> cytzol: you would also have to assign a type signature to the calls to matchToken and lCompare, so that the a's can unify.
05:21:44 <doserj> But I'm also just guessing...
05:22:33 <doserj> what is the type of "fromOne" anyways?
05:22:54 <ivanm> @hoogle fromOne
05:22:55 <lambdabot> No results found
05:23:05 <cytzol> data Token a = One {fromOne :: a} | Many
05:23:33 <doserj> ok.
05:24:07 <ivanm> so Token == renamed Maybe with a record-based accessor?
05:24:19 <cytzol> yes
05:24:29 <cytzol> and fromOne is like fromJust.
05:24:40 <ivanm> in that case, why not use Maybe and fromJust?
05:24:48 <ivanm> give it a type alias if you want, but why reinvent the wheel?
05:25:00 <ivanm> (unless, of course, you want a non-circular wheel...)
05:25:27 <koeien> oh no! an invasion of haskellers into holland in april
05:25:46 <cytzol> I did for a while, but then I had functions that take Maybes and return Maybes, and I lost track of which Maybe acted like a Token and which acted like a Maybe.
05:25:46 <ivanm> koeien: so there goes all the dykes?
05:26:02 <ivanm> cytzol: hmmmm...
05:26:03 <koeien> ivanm: yeah. gah
05:26:07 <koeien> ;)
05:26:45 * ivanm lends koeien some rubber boots to help survive the eventual flood
05:27:11 <koeien> ivanm: in fact i'm more to the east, about sea level here :)
05:27:30 <ivanm> heh
05:29:04 <doserj> just wait some dozen years, and you will live on the coast...
05:30:38 <cizra> @s maximum
05:30:38 <lambdabot> Maybe you meant: seen shootout show slap smack source spell spell-all src . ? @ v
05:30:46 <cizra> @src maximum
05:30:46 <lambdabot> maximum [] = undefined
05:30:46 <lambdabot> maximum xs = foldl1 max xs
05:31:05 <cizra> Hmmm, clever. I think this is the simplest example ox foldl I've seen yet.
05:31:11 <cizra> @t foldl1
05:31:12 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:31:15 <cizra> @type foldl1
05:31:17 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
05:31:20 <cizra> @type foldl
05:31:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:31:41 <Axman6> @src and
05:31:41 <lambdabot> and   =  foldr (&&) True
05:31:44 <Axman6> @src or
05:31:44 <lambdabot> or    =  foldr (||) False
05:31:59 <cizra> @type and
05:32:00 <lambdabot> [Bool] -> Bool
05:32:12 <cizra> Why right, not left?
05:32:37 <boegel> cizra: foldr is strict, while foldl is lazy
05:32:38 <Ferdirand> so you get to short-circuit ?
05:32:40 <rmoss> is there a simpler way to write this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1482#a1482
05:32:45 <boegel> cizra: is you want to use left, use foldl'
05:32:54 <boegel> cizra: which is a strict version of foldl
05:33:01 <cizra> boegel: Didn't know that about laziness
05:33:08 <cytzol> rmoss: try looking at elem
05:33:22 <doserj> > foldr (&&) True [False..]
05:33:23 <lambdabot>   <no location info>: parse error on input `]'
05:33:24 <ski_> > foldr (&&) True (False : repeat undefined)
05:33:25 <lambdabot>   False
05:33:29 <ski_> > foldl (&&) True (False : repeat undefined)
05:33:30 <Axman6> > foldl f x [a,b,c]
05:33:33 <lambdabot>   f (f (f x a) b) c
05:33:35 <Axman6> > foldr f x [a,b,c]
05:33:52 <lambdabot>   thread killed
05:33:52 <lambdabot>   thread killed
05:33:58 <cytzol> > "Then" `elem` ["If, "Then", "Else"]
05:34:00 <lambdabot>   <no location info>:
05:34:00 <lambdabot>      lexical error in string/character literal at chara...
05:34:05 <boegel> cizra: now you do :)
05:34:09 <cytzol> > "Then" `elem` ["If", "Then", "Else"]
05:34:11 <lambdabot>   True
05:34:13 <cizra> boegel: yea.. Will I remember it, though?
05:34:15 <boegel> cizra: see the great book "Real World Haskell"
05:34:22 <boegel> cizra: you should :)
05:34:32 <cizra> boegel: Seen it. I even made a version of it for offline reading.
05:34:38 <rmoss> thanks
05:34:43 <boegel> cizra: you mean you bought it? :)
05:34:44 <Axman6> > foldr f x [a,b,c]
05:34:44 <ski_> > let x = 0 in x /= 0 && 10 `div` x > 3
05:34:46 <lambdabot>   f a (f b (f c x))
05:34:47 <lambdabot>   False
05:35:44 <cizra> boegel: No, I downloaded it with wget, removed some junk, converted the links for offline usage, tarballed it. It's CC-licensed, so it's legal n' ethical n' stuff. Want it?
05:36:54 <Axman6> cizra: most of us would probably still prefer it if you bought it. we all know the authors quite well, and they're great guys, and deserve the cash really :)
05:37:01 <boegel> cizra: erm, actually, yeah :)
05:37:25 <cizra> Axman6: I'm sure, but I'm hard pressed for money right now (preparing for getting wed, woo hoo!)
05:37:34 <boegel> Axman6: well, we bought it already for our lab library
05:37:44 <boegel> Axman6: but now we're fighting over it :)
05:37:47 <Axman6> heh
05:38:06 <cytzol> I got the lazy edition, which only arrived after I started to read it.
05:38:09 <cizra> Axman6: Also, I suggested it for the next batch of books-to-buy. The deciders didn't get ignited, though.
05:38:16 <cizra> cytzol: haha
05:41:13 <boegel> cytzol: :D
05:43:12 <Axman6> hmm, is there any way to put the type of something into the Show instance? i've got this mutable variable thing, and i'd like to have show avar = "AVar " ++ showType a (with avar :: AVar a)
05:43:36 <Botje> @hoogle typeOf
05:43:36 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
05:43:36 <lambdabot> package typeof
05:43:36 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
05:44:00 <Botje> > show (typeOf (1,2,3,"foo"))
05:44:01 <lambdabot>   "(Integer,Integer,Integer,[Char])"
05:44:10 <Axman6> ah, excellent :)
05:44:32 <Axman6> heh, i guess i could just use show . typeOf
05:46:11 <Axman6> or not
05:48:05 <Axman6> ok, maybe i'll skip a show instance for AVars
05:48:50 <Axman6> time to learn haddock i think
05:53:15 <paper_cc> GHC installation produces a nice local Haddock documentation tree in $PREFIX/doc. how can I install libraries so that their documentation will be merged into this tree?
05:54:50 <Axman6> paper_cc: i'd love to know how to do that too
05:55:00 <Axman6> but afaik, i can't be done (easily)
05:55:06 <McManiaC> is it valid to always use foldl' instead of foldl ? or do you need foldl too sometimes?
05:56:12 <Axman6> i've never seen a use for foldl, i've heard people say they've only ever seen one use for it over foldl'
05:56:35 <paper_cc> Axman6: :( thank you
05:56:41 <McManiaC> so foldl' all the time?
05:58:22 <paper_cc> Axman6: the trick is that the prebundled Ubuntu packages have their documentation installed in the right place, so this can be done, at least theoretically
06:03:09 <ski_> > typeOf (1,2,3,"foo")
06:03:10 <lambdabot>   (Integer,Integer,Integer,[Char])
06:03:21 <Axman6> someone reckon they could try posting a comment on my blog for me? i think people have been trying to, but akismet was broken in my blog
06:03:26 <ski_> > fix typeOf
06:03:28 <lambdabot>   TypeRep
06:05:48 <Botje> heh :]
06:09:20 <Zao> Axman6: Meh, wants me to sign up or sign in.
06:09:47 <Axman6> Zao: hmm, yeah i'd like it not to do that, i'll see what i can do (i thought i changed that)
06:12:40 <cizra> > 0.7 + 0.2
06:12:41 <lambdabot>   0.8999999999999999
06:13:10 <cizra> While I know this ↑ crap is mathematically equivalent to 0.9 (assuming the 9s continue to infinity), it still looks fugly.
06:13:41 <Axman6> > 0.7+0.2 :: CReal
06:13:43 <lambdabot>   0.9
06:13:57 <cizra> What's that?
06:14:06 <SamB> http://trac.haskell.org/
06:14:12 <Axman6> infinite precision floating point numbers
06:14:20 <Axman6> > showCReal 100 pi
06:14:22 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
06:14:27 <doserj> > 0.7 + 0.2 :: Float
06:14:28 <lambdabot>   0.9
06:14:34 <SamB> huh, two bots fetched it I think
06:14:40 <cizra> Oh. Interesting. How 'bout rational numbers? Does Haskell support them out-of-some-box?
06:14:48 <earthy> yes
06:14:54 <SamB> [Tue Feb 17 09:14:06 2009] [error] [client 131.252.208.118] PythonHandler trac.web.modpython_frontend: Traceback (most recent call last):
06:14:56 <doserj> > 0.7 + 0.2 :: Rational
06:14:58 <lambdabot>   9%10
06:14:59 <earthy> > 3 % 2 :: Rational
06:15:01 <lambdabot>   3%2
06:15:15 <SamB> [Tue Feb 17 09:14:07 2009] [error] [client 121.98.136.241] PythonHandler trac.web.modpython_frontend: Traceback (most recent call last):
06:15:27 <cizra> Ooh, cool.
06:16:16 <Axman6> Zao: should be all fixed now (i hope, if not, let me know :))
06:16:27 <ski_> > 3 % 2
06:16:29 <lambdabot>   3%2
06:16:43 <earthy> > 1.5
06:16:45 <lambdabot>   1.5
06:16:51 <earthy> > 1.5 :: Rational
06:16:53 <lambdabot>   3%2
06:16:58 <Zao> Axman6: This ASTM, what's that?
06:17:02 <cizra> > pi :: Rational
06:17:04 <lambdabot>       No instance for (Floating Rational)
06:17:04 <lambdabot>        arising from a use of `pi' a...
06:17:13 <cizra> gah. I hoped to revolutionalize math.
06:17:17 * earthy laughs
06:17:37 <Axman6> it's a form of mutable variables, with a queue like way of working with them
06:17:38 <doserj> > toRational (pi::Float)
06:17:40 <lambdabot>   13176795%4194304
06:17:45 <doserj> > toRational (pi::Double)
06:17:46 <lambdabot>   884279719003555%281474976710656
06:17:52 <cizra> Oh shit
06:17:57 <Raynes> Oh shit
06:18:02 <cizra> ❤Haskell❥ is way cooler than I thought.
06:18:10 <Axman6> > 884279719003555 / 281474976710656
06:18:11 <lambdabot>   3.141592653589793
06:18:16 <Axman6> > 884279719003555 / 281474976710656 :: CReal
06:18:17 <lambdabot>   3.1415926535897931159979634685441851615906
06:18:22 <p_l> at least you didn't divide by zero.... :P
06:18:30 <SamB> > pi :: CReal
06:18:31 <lambdabot>   3.1415926535897932384626433832795028841972
06:18:42 <SamB> > 884279719003555 / 281474976710656 :: CReal
06:18:43 <lambdabot>   3.1415926535897931159979634685441851615906
06:18:54 <Axman6> > toRational (pi :: CReal)
06:18:55 <lambdabot>   * Exception: CReal.toRational
06:19:01 <Axman6> :(
06:19:11 <cizra> > (pi :: CReal) - (884279719003555 / 281474976710656 :: CReal)
06:19:13 <lambdabot>   0.0000000000000001224646799147353177226066
06:19:15 <cizra> haa
06:19:19 * earthy grins
06:20:20 <cizra> > (pi :: CReal) - (toRational (pi::Float) :: CReal)
06:20:22 <lambdabot>   Couldn't match expected type `CReal'
06:20:35 <skorpan> how do i get the command line arguments in haskell?
06:20:35 <cizra> > (pi :: CReal) - (13176795 / 4194304 :: CReal)
06:20:37 <lambdabot>   -0.0000000874227800037248566167204971158028
06:20:42 <cizra> skorpan: import System
06:20:50 <SamB> @hoogle getArgs
06:20:50 <lambdabot> System.Environment getArgs :: IO [String]
06:20:52 <cizra> skorpan: main = do args <- getArgs
06:20:58 <skorpan> cizra: thanks
06:21:04 <Axman6> Zao: whoops, i need to republish my site for the changes to work, if you refresh, it should be ok now
06:22:19 <skorpan> any ideas on a nice way to let input = <getArgs if not null, otherwise getContents>?
06:23:31 <cizra> args <- getArgs; input = if null args then foo else getContents
06:23:48 <ferret_0667> wow, I really need to learn some more Haskell if I am to make much use of XMonad
06:23:50 <skorpan> but getContents is IO String
06:24:16 <cizra> ferret_0667: Why so? I've used XMonad for ages now, and I only recently made my first real programs in it.
06:24:17 <ferret_0667> that IM layout is slick
06:24:36 <ferret_0667> cizra: I don't know what .|. means, for example
06:24:51 <ferret_0667> I forget what $ means, and I have yet more stuff I don't know
06:24:57 <Axman6> it's or
06:25:02 <Axman6> :t (.|.)
06:25:04 <lambdabot> forall a. (Bits a) => a -> a -> a
06:25:09 <Axman6> butwise or
06:25:20 <ferret_0667> I don't know what Bitwise or is
06:25:22 <Axman6> > 3 .|. 4
06:25:23 <lambdabot>   Add a type signature
06:25:26 <ferret_0667> I'm in 9th grade
06:25:30 <Axman6> > 3 .|. 4 :: Integer
06:25:32 <lambdabot>   7
06:25:39 <Axman6> ferret_0667: you know about binary?
06:25:46 <Zao> Axman6: Commenting works.
06:25:47 <ferret_0667> Axman6: I need to learn binary
06:25:52 <Axman6> heh
06:26:32 <Axman6> Zao: thanks for that, really appeciate it :)
06:26:33 <ferret_0667> how do I learn binary?
06:26:46 <Axman6> by googling it i guess
06:26:59 <Axman6> you don't know about binary number systems? bits and bytes?
06:27:04 <ferret_0667> is Wikipedia a good source of info on this topic (how bitwise ops work and everything)
06:27:05 <Zao> I bet wikipedia has a rather exhaustive article.
06:27:08 <ferret_0667> Axman6: I do
06:27:22 <doserj> http://en.wikipedia.org/wiki/Binary_numeral_system
06:27:30 <ferret_0667> Axman6: It's just I don't know about how to convert from decimal to binary and back again
06:27:47 <ferret_0667> nor do I know how bitwise ops work
06:27:50 <Axman6> 0011 .|. 0100 -> 0111
06:28:06 <Axman6> 0011 .&. 0100 -> 0000
06:28:16 <Axman6> 0011 .&. 0110 -> 0010
06:28:18 <ferret_0667> oh
06:28:18 <Black> Hey again..
06:28:25 <Axman6> o/
06:28:35 <blackh> Morning!
06:28:36 <Black> Btw I know how to compile code etc.. but now it won't create a .exe?
06:28:46 <ski_> > exp pi - pi :: CReal
06:28:48 <lambdabot>   19.9990999791894757672664429846690444960689
06:29:02 <Black> C:\Users\Alan\Code\Haskell>ghc --make AnotherHelloWorld.hs
06:29:03 <Black> [1 of 1] Compiling Craig            ( AnotherHelloWorld.hs, AnotherHelloWorld.o
06:29:03 <Black> )                ... no .exe
06:29:28 <blackh> Black: I think you need to add -o AnotherHelloWorld.exe
06:29:28 <ferret_0667> or sets the bits that where different from each other to 1, and and sets the values that where different from each other to 0
06:29:33 <ferret_0667> Axman6: is that it?
06:29:46 <andun> Black: AnotherHelloWorld.hs must contain "module Main where main = ..."
06:29:53 <ski_> Black : did you start the file by `module Main' ?
06:29:55 <ferret_0667> Axman6: I didn't even read the Wikipedia article again, I just remember this or figured it out
06:30:10 <Black> I have now.. It was module Craig where
06:30:12 <blackh> Black: Ignore me. I'm wrong.
06:30:19 <doserj> ferret_0567: you remembered wrong
06:30:31 <Black> it works now thanks..
06:30:32 <cytzol> > sum $ takeWhile (>0) $ map (\a -> 1 / (product [1..a])) [0..]
06:30:33 <lambdabot>   2.7182818284590455
06:30:39 <ferret_0667> doserj: huh?
06:30:44 <ferret_0667> doserj: that's how it seems to work
06:31:09 <ferret_0667> > 0011 .|. 0100
06:31:11 <lambdabot>   Add a type signature
06:31:16 <ferret_0667> :(
06:31:19 <doserj> ferret_0567: what about the other cases?
06:31:20 <ferret_0667> > 0011 .|. 0100 :: Integer
06:31:21 <lambdabot>   111
06:31:43 <ferret_0667> > 0011 .|. 0100 :: Bits
06:31:44 <lambdabot>       Class `Bits' used as a type
06:31:44 <lambdabot>      In the type `Bits'
06:31:44 <lambdabot>      In an expressi...
06:31:57 <ferret_0667> doserj: what other cases?
06:32:14 <doserj> ferret_0567: if the bits are the same?
06:32:39 <quicksilver> > 0011 + 0011
06:32:40 <ferret_0667> doserj: they remain unchanged, it seems
06:32:44 <lambdabot>   22
06:32:55 <quicksilver> "0011" is not a binary number, in haskell
06:33:02 <quicksilver> it's a decimal number eleven (11)
06:33:06 <ferret_0667> oh
06:33:19 <quicksilver> the binary number "0011" is represented in haskell source as "3".
06:33:20 <ferret_0667> then uh...what is the type for binary?
06:33:32 <Deewiant> > 0b0011
06:33:33 <lambdabot>   Not in scope: `b0011'
06:33:36 <quicksilver> this isn't about type, it's about representation in a source file.
06:33:40 <ferret_0667> oh
06:33:45 <quicksilver> there is no built in binary literal syntax.
06:33:51 <Deewiant> O_o
06:33:54 <Deewiant> I could have sworn there was
06:34:02 <skorpan> if i have a list of files, fs = ["hello.txt", "howdy.bat"] and i want to read the contents from all of them and concatenate the result, what is the best way? foldM and then concat?
06:34:09 <quicksilver> You might choose to represent Binary explicitly by "data Bit = One | Zero; type Binary = [Bit]"
06:34:49 <ferret_0667> ok, I'll do that then
06:35:03 <daf> adopting 0b syntax would be a nice addition for H'
06:36:06 <xci> hey guys, what was _the_ recommended package for vim when coding haskell
06:37:31 <Axman6> the vim haskell mode?
06:37:35 <Zao> xci: Someone mentioned Shim the other day http://www.vim.org/scripts/script.php?script_id=2356
06:39:39 * ferret_0667 needs break
06:42:04 <ski_> @type break
06:42:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:42:39 <ski_> > isSpace `break` "ferret_0667 needs break"
06:42:41 <lambdabot>   ("ferret_0667"," needs break")
06:45:26 <Invisible> @yarr
06:45:26 <lambdabot> Avast!
06:45:57 <skorpan> i don't suppose there is something like bytestring but which can deal with utf-8?
06:46:03 <ray> @faq Can Haskell swab my decks?
06:46:03 <lambdabot> The answer is: Yes! Haskell can do that.
06:46:16 <Invisible> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:46:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:46:39 <Deewiant> ?hackage utf8-string -- skorpan
06:46:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string -- skorpan
06:47:18 <skorpan> i wonder if alex can deal with that
06:47:39 <Invisible> > let pascal = [1,1] : zipWith (zipWith (\x y -> zipWith (+) x (0:y)) pascal pascal
06:47:40 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:47:46 <Invisible> > let pascal = [1,1] : zipWith (zipWith (\x y -> zipWith (+) x (0:y)) pascal pascal in pascal
06:47:47 <lambdabot>   <no location info>: parse error on input `in'
06:48:00 <sioraiocht> skorpan: there is a unicode version of bytestring coming out soon
06:48:00 <Invisible> > let pascal = [1,1] : zipWith (zipWith (\x y -> zipWith (+) x (0:y))) pascal pascal in pascal
06:48:02 <lambdabot>       No instance for (Num [a])
06:48:04 <lambdabot>        arising from the literal `1' at <inter...
06:48:06 <ray> > let fibs = fromJust $ getSequenceByID "A000045" in fibs
06:48:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:48:13 <sioraiocht> skorpan: it is not bytestring, but inspired by it
06:48:21 <sioraiocht> and much faster than String
06:48:24 <skorpan> nice
06:49:52 <Invisible> let pascal = [1,1] : map (\x -> zipWith (+) x (0:x)) pascal in pascal
06:49:57 <Invisible> > let pascal = [1,1] : map (\x -> zipWith (+) x (0:x)) pascal in pascal
06:49:58 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[1,11],[1,12]...
06:50:29 <Invisible> > let pascal = [1,1] : map (\x -> zipWith (+) x (0:x) ++ [1]) pascal in pascal
06:50:30 <lambdabot>   [[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,...
06:50:38 * Invisible wins
06:50:47 <quicksilver> Invisible: or, zipWith (+) (x ++ [0]) (0 : x)
06:51:00 <quicksilver> Invisible: zipWith trims to the shortest so you have to add at each end.
06:51:09 * Invisible is instantly beaten :(
06:51:24 <daf> only if it's a zero-sum game :)
06:51:30 <doserj> Invisible: you forgot the first line...
06:51:49 <sioraiocht> skorpan: look for the release of Data.Text soon, that's the library's name
06:51:52 <Invisible> doserj: I didn't "forget", it's just easier this way ;)
06:52:03 <sioraiocht> there is a darcs repository for it on code.haskell.org
06:52:03 <doserj>  > let pascal = [1] : map (\x -> zipWith (+) x (0:x) ++ [1]) pascal in pascal
06:52:07 <doserj> > let pascal = [1] : map (\x -> zipWith (+) x (0:x) ++ [1]) pascal in pascal
06:52:08 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
06:52:09 <Invisible> > zipWith (+) (x ++ [0]) (0 : x)
06:52:10 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
06:52:27 <lupsyn> hi all..
06:52:48 <lupsyn> can someone help me with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1459#a1483 and the solution with foldrq  in the first \ expr ?
06:52:52 <Invisible> > let haskell = world domination in 2009
06:52:53 <lambdabot>   Not in scope: `world'Not in scope: `domination'
06:53:17 <Invisible> "world" is beyond Haskell's scope?
06:53:20 <Invisible> oh dear.
06:53:44 <idnar> heehee
06:53:52 <SamB> Invisible: you didn't import it yet
06:54:04 <tromp> @let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
06:54:04 <lambdabot>  Defined.
06:54:07 <SamB> well, it's not in scope here because it wouldn't be safe
06:54:22 <SamB> we can't have just anyone taking over the world here!
06:54:32 <ray> > unsafePerformIO dominateWorld
06:54:33 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `dominateWorld'
06:54:52 <ray> > safePerformIO dominateWorld -- maybe this'll work
06:54:53 <lambdabot>   Not in scope: `safePerformIO'Not in scope: `dominateWorld'
06:56:15 <Invisible> @seen dons
06:56:15 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
06:56:19 <Deewiant> > fix $ ([1]:) . map (ap (zipWith (+) . (++[0])) (0:))
06:56:20 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
06:56:34 <Invisible> :t fix
06:56:35 <lambdabot> forall a. (a -> a) -> a
06:56:40 <Invisible> so, so wrong...
06:56:48 <cytzol> Invisible: let pascal = [1,1] : map (\x -> zipWith (+) (x ++ [0]) (0:x)) pascal in mapM_ putStrLn $ map (map (\x -> if even x then ' ' else '#')) pascal
06:57:57 <Invisible> > fix (\x -> if x < 8 then x+1 else 8)
06:58:12 <lambdabot>   thread killed
06:58:39 <Invisible> hmm.
06:58:52 <Deewiant> > fix (0:)
06:58:54 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:59:05 <Invisible> fix MSWord
06:59:12 <Deewiant> _|_
06:59:20 <Invisible> Deewaint: nice.
07:00:37 <Invisible> > fix my reputation
07:00:38 <lambdabot>   Not in scope: `my'Not in scope: `reputation'
07:00:49 <Invisible> oh well, worth a go :S
07:01:06 <Invisible> apparently the whole of haskell-cafe thinks I'm a troll... :(
07:01:25 <cytzol> "in fix"
07:01:48 <Axman6> > fix (+1)
07:02:03 <lambdabot>   thread killed
07:02:32 <McManiaC> asInt_either ('-':xs)   = either id negate (asInt_either xs)
07:02:41 <McManiaC> asInt_either :: String -> Either String Int
07:02:42 <Invisible> > fix (\x -> if x < 8 then x+1 else x) 1
07:02:43 <lambdabot>       No instance for (Ord (t -> a))
07:02:43 <lambdabot>        arising from a use of `<' at <int...
07:02:49 <McManiaC> Couldn't match expected type `[Char]' against inferred type `Int'
07:02:52 <McManiaC> any ideas? :S
07:03:25 <SamB> McManiaC: it looks like you are trying to compare a String and an Int
07:03:25 <Deewiant> (negate.read)
07:03:40 <SamB> or, er, otherwise use a string as an int
07:03:54 <SamB> or vice-versa
07:04:12 <McManiaC> the Right of asInt_either should be an Int tho?
07:04:30 <quicksilver> "either" deconstructs Eithers
07:04:32 <quicksilver> it does not build them
07:04:35 <quicksilver> :t either
07:04:35 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
07:04:50 <quicksilver> unless of course you use Left and Right in the branches :)
07:04:56 <quicksilver> :t either Right Left
07:04:57 <lambdabot> forall a a1. Either a a1 -> Either a1 a
07:05:15 <SamB> McManiaC: try "fmap" instead of "either id"?
07:05:15 <Axman6> > fix (\f x -> if x < 10 then x else f (x+1)) 1
07:05:16 <lambdabot>   1
07:05:22 <Axman6> > fix (\f x -> if x > 10 then x else f (x+1)) 1
07:05:23 <lambdabot>   11
07:05:38 <Axman6> wow... my first fix!
07:05:52 <SamB> @instances Functor
07:05:53 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:06:59 <McManiaC> well i thought
07:07:26 <McManiaC> asInt_either xs is an Int if its "Right"
07:07:34 <McManiaC> so i can use negate on it?
07:08:11 <Deewiant> McManiaC: the problem is that asInt_either does not return an Either.
07:08:28 <Deewiant> you say it does, but it doesn't actually.
07:08:50 <McManiaC> well it does if i remove that one line
07:08:51 <McManiaC> ^^
07:09:07 <McManiaC> aaaah
07:09:07 <Saizan> Axman6: aaah, i wish i were still that young!
07:09:14 <McManiaC> asInt_either ('-':xs)   = either Left (Right . negate) (asInt_either xs)
07:09:16 <McManiaC> works =)
07:09:17 <Deewiant> yep
07:09:19 <Axman6> Saizan: heh :)
07:09:32 <lupsyn> can someone help me with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1459#a1483 and the solution with foldrq  in the first \ expr ?
07:09:40 * Invisible thinks about the Church numerals and the lambda calculus...
07:09:49 <McManiaC> Axman6: whats a fix? ^^
07:10:03 <Axman6> :t fix
07:10:04 <lambdabot> forall a. (a -> a) -> a
07:10:09 <Invisible> McManiaC: it's a way to BREAK YOUR MIND.
07:10:16 <ski_> > fix (1:)
07:10:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:10:19 <Axman6> > fix (\f x -> if x > 10 then x else f (x+1)) 1
07:10:20 <lambdabot>   11
07:10:20 <ski_> > fix show
07:10:22 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
07:10:44 <Invisible> ski_: ooo, nice...
07:10:45 <McManiaC> O.o
07:10:52 <cytzol> @where fix
07:10:52 <lambdabot> I know nothing about fix.
07:10:55 <Invisible> McManiaC: is your mind broken yet?
07:10:58 <ski_> @src fix
07:10:58 <lambdabot> fix f = let x = f x in x
07:11:00 <cytzol> ta
07:11:11 <McManiaC> Invisible: im not sure :D
07:11:12 <Axman6> > text "a\na\nc\nd\ne\nf"
07:11:13 <lambdabot>   a
07:11:13 <lambdabot>  a
07:11:13 <lambdabot>  c
07:11:13 <lambdabot>  d
07:11:13 <lambdabot>  e
07:11:15 <lambdabot>  f
07:11:26 <Axman6> hmm, there should be a limit on that
07:11:54 <Deewiant> that looks exploitable
07:12:05 <Axman6> aye...
07:12:07 <McManiaC> hehe
07:12:11 <Deewiant> unless it's limited in the same way the normal output is?
07:12:17 <Invisible> :i text
07:12:18 <Deewiant> in which case it'll max out at 100 lines or so :-P
07:12:19 <daf> I expect it is
07:12:20 <Axman6> > text $ replicate 10 '\n'
07:12:21 <lambdabot>   mueval: Prelude.read: no parse
07:12:25 <McManiaC> "lambdabot gets kicked..."
07:12:26 <McManiaC> :D
07:12:27 <daf> but a 100 lines is a lot
07:12:29 <Deewiant> I'll try in query
07:12:33 <Invisible> :t text
07:12:34 <lambdabot> String -> Doc
07:12:36 <Axman6> > replicate 10 '\n'
07:12:37 <lambdabot>   "\n\n\n\n\n\n\n\n\n\n"
07:12:40 <Invisible> @where text
07:12:40 <lambdabot> I know nothing about text.
07:12:46 <Axman6> > text $ replicate 10 '\n'
07:12:47 <skorpan> @where sex
07:12:47 <lambdabot> I know nothing about sex.
07:12:47 <lambdabot>   mueval: Prelude.read: no parse
07:12:55 <Axman6> o.O
07:12:57 <Invisible> > putStr $ replicate 100 '\n'
07:12:58 <lambdabot>   * Exception: "<IO ()>"
07:13:20 <Invisible> I know nothing about that either...
07:13:35 <daf> > putStr $ repeat '\n'
07:13:36 <lambdabot>   * Exception: "<IO ()>"
07:13:49 <Deewiant> Ah, no sweat
07:13:54 <Deewiant> It just said [foo @more lines]
07:14:01 <daf> > putStr $ cycle " \n"
07:14:02 <lambdabot>   * Exception: "<IO ()>"
07:14:03 <ski_> @where fyra
07:14:03 <lambdabot> I know nothing about fyra.
07:14:10 <Invisible> > text $ replicate 100 '\n'
07:14:14 <lambdabot>   mueval: Prelude.read: no parse
07:14:15 <Deewiant> > text (concat $ zipWith (++) (map return ['\0'..'\x7f']) (repeat "\n"))
07:14:16 <lambdabot>  ...
07:14:43 <Deewiant> oh, now it behaves differently here, that's odd
07:14:43 <Axman6> > text . concat . replicate 10 $ "x\n"
07:14:44 <lambdabot>   x
07:14:44 <lambdabot>  x
07:14:44 <lambdabot>  x
07:14:44 <lambdabot>  x
07:14:44 <lambdabot>  x
07:14:45 <Invisible> @destroy superman!
07:14:46 <lambdabot> [5 @more lines]
07:14:48 <lambdabot> Unknown command, try @list
07:14:50 <Axman6> ah, good
07:15:42 <Invisible> @vixen hi
07:15:42 <lambdabot> how're you?
07:15:52 * Invisible needs to get out more...
07:16:12 <Axman6> @vixen would you like a drink?
07:16:12 <lambdabot> the question isn't would i, but should i
07:16:23 <Invisible> o_O
07:16:27 <Axman6> @vixen i think you should, it'll make you feel good
07:16:28 <lambdabot> i'm glad, i'm good too
07:16:54 <Axman6> @vixen that's good to hear
07:16:54 <lambdabot> yeah... bordering on great!
07:17:06 * Invisible wonders what would happen if you used "fix" and the CPS monad at the same time...
07:17:19 <Axman6> @vixen so, want to come back to my place?
07:17:19 <lambdabot> whoa whoa whoa, one question at a time!
07:17:39 <Invisible> lol! simpleton.
07:19:21 <Invisible> ...and now I'm wondering if you could program an artificial neural network to parse text and construct replies to it, and make that into an IRC bot. ;)
07:21:05 <ski_> <http://markmail.org/message/lvblntvnzailxnen> ".. The closest I know of an mfix for the continuation monad was designed by Magnus Carlsson. .."
07:21:43 <ski_> (but i can't find it at <http://www.cs.chalmers.se/~magnus/> from quick browsing)
07:22:08 <cantor> http://pastebin.com/m38644825
07:22:19 <cantor> parse error in the last line
07:23:16 <ski_> `pos' doesn't take two arguments
07:23:19 <quicksilver> ski_: http://www.mail-archive.com/haskell-cafe@haskell.org/msg09081.html
07:23:33 <quicksilver> ski_: is presumably the discussion by magnus being referred to.
07:23:44 <ski_> probably you want `==' instead of `='
07:23:53 <ski_> also, you don't want `putStr'
07:24:38 <ski_> quicksilver : ah, there the slides are ! i knew i'd seen them somewhere, ty :)
07:26:02 <ski_> (ok .. `ogi' .. that explains why i didn't find anything at `chalmers')
07:26:52 <cantor> ski_: if i take "==" for comparison in the last line i get
07:26:53 <cantor> No instance for (Eq (IO ()))
07:26:53 <cantor>       arising from a use of `==' at /misc/fib.hs:101:22-77
07:26:54 <cantor>     Possible fix: add an instance declaration for (Eq (IO ()))
07:27:08 <ski_> hrm .. someone wants lambdabot in #haskell-in-depth
07:27:21 <ski_> <ski_> also, you don't want `putStr'
07:27:28 <ski_> cantor : ^
07:27:47 <cantor> ski_: i want to convert the string back to an integer
07:28:03 <cantor> and putStr is the only function i know
07:28:14 <ski_> `putStr' doesn't convert back to an integer
07:28:19 <ski_> try `read' instead
07:28:26 <cantor> k
07:28:53 <Invisible> I have a premonition you'll get a type ambiguity...
07:29:22 <ski_> (also, there's no point in using `read' there on the right part where you have `show' outermost)
07:29:50 <ski_> > read (show 42) == 42
07:29:51 <lambdabot>   True
07:30:02 <ski_> @check \x -> read (show x) == x
07:30:03 <lambdabot>   "OK, passed 500 tests."
07:30:08 <ski_> @check \x -> read (show x) == x + 0
07:30:09 <lambdabot>   "OK, passed 500 tests."
07:30:10 <ski_> :)
07:30:23 <Invisible> ski_: you can *do* that??
07:30:23 <cantor> ski_: thats the sense
07:30:24 <Invisible> neat!
07:30:49 <ski_> Invisible : yes, if the context determines the result, there's no ambiguity
07:30:56 <Invisible> @check x^2 > x^3
07:30:57 <lambdabot>   "Falsifiable, after 0 tests:\n"
07:30:59 <ski_> s/result/result type/
07:31:03 <lupsyn> can someone help me with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1459#a1483 and the solution of the occurencies problem with foldrq ?
07:31:07 <Invisible> ski_: no, I meant use quickcheck from lambdabot
07:31:09 <ski_> @check \x -> x^2 > x^3
07:31:10 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
07:31:18 <ski_> @check \x -> x^2 >= x^3
07:31:19 <lambdabot>   "Falsifiable, after 16 tests:\n5\n"
07:31:28 <ski_> @help check
07:31:29 <lambdabot> check <expr>
07:31:29 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
07:31:30 <ski_> @help scheck
07:31:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:31:32 <Invisible> @check x^2 <= x^3
07:31:33 <lambdabot>   "OK, passed 500 tests."
07:31:45 <ski_> unfortunately SmallCheck appears gone, though
07:31:50 <dmead> i'll bet doctor kliner from halflife programs in lisp
07:32:03 <ski_> Invisible : please use `\x ->' in front
07:32:10 <ski_> otherwise you'll test
07:32:12 <ski_> > x
07:32:13 <lambdabot>   x
07:32:15 <ski_> @type x
07:32:15 <lambdabot> Expr
07:32:21 <ski_> which is probably not what you want
07:32:23 <doserj> > (-1)^2 <= (-1)^3
07:32:24 <lambdabot>   False
07:32:51 <Invisible> @check \x -> x^2 <= x^3
07:32:52 <lambdabot>   "Falsifiable, after 3 tests:\n-2\n"
07:33:05 <ski_> @. read check \x -> x^2 <= x^3
07:33:07 <lambdabot>  Falsifiable, after 3 tests:-2
07:33:09 <Invisible> @check \x -> x >= 0
07:33:10 <lambdabot>   "Falsifiable, after 1 tests:\n-2\n"
07:33:13 <ski_> hm, nicer
07:33:17 <Invisible> @check \x -> x^2 >= 0
07:33:18 <lambdabot>   "OK, passed 500 tests."
07:33:34 <ski_> @. read check \x y -> x == y + 0
07:33:35 <lambdabot>  Falsifiable, after 3 tests:-12
07:33:42 <ski_> @check \x y -> x == y + 0
07:33:43 <lambdabot>   "Falsifiable, after 1 tests:\n1\n-1\n"
07:33:52 <ski_> (maybe not so goog, after all)
07:34:23 <Invisible> so how is SmallCheck different from QuickCheck?
07:34:58 <ski_> SmallCheck tries to minimize a failing test case to the minimum failing it can find, using step-wise shrinking of the test case
07:35:10 <Deewiant> QuickCheck 2 does that as well
07:35:12 <ski_> that can remove lots of irrelevant garbage
07:35:14 <quicksilver> erm, I don't think that's true, ski?
07:35:20 <daf> “SmallCheck is similar to QuickCheck (Claessen and Hughes 2000-) but instead of testing for a sample of randomly generated values, SmallCheck tests properties for all the finitely many values up to some depth, progressively increasing the depth used.”
07:35:28 <quicksilver> smallcheck proceeds by exhaustive enumation of all cases
07:35:30 <earthy> smallcheck tests *all* values up to a given size
07:35:37 <quicksilver> what you are describing is QC2 shrinking.
07:35:45 <earthy> which necessarily is 'smallish'
07:35:45 <ski_> quicksilver : ah .. i'll probably confusing it with some other variant of QC, then
07:35:53 * quicksilver nods
07:36:00 <daf> Lazy SmallCheck is really quite cunning
07:36:02 <ski_> quicksilver : that's what i thought `scheck' was doing, anyway
07:36:07 <quicksilver> shrinking was described in the first QC paper, IIRC, but actually implemented in QC2.
07:36:08 <ski_> quicksilver : ty for the correction
07:36:14 <Invisible> AFAIK, QC starts with small tests and gradually tries larger ones...
07:36:23 <Invisible> (for a user-defined meaning of "small")
07:36:49 <Invisible> so the essential difference is that QC is randomised testing, and SC is deterministic/exhaustive?
07:36:58 <quicksilver> yes.
07:36:59 <Deewiant> yep
07:37:15 <Invisible> right... and HUnit fits into this picture, how? :}
07:37:23 <Deewiant> HUnit is unit testing
07:37:30 <quicksilver> different picture.
07:37:40 <quicksilver> You could use quickcheck for some of your unit tests if you wanted.
07:37:44 <Deewiant> it doesn't generate anything, it just runs what you tell it to
07:37:49 <daf> *Check tries to disprove your invariants
07:38:02 <Deewiant> @check True
07:38:03 <lambdabot>   "OK, passed 500 tests."
07:38:06 <Invisible> ...so HUnit is a framework for running testscripts?
07:38:09 <quicksilver> yes.
07:38:10 <daf> HUnit tests are just a series of assertions
07:38:10 <Deewiant> 500 tests of that is a bit of a waste IMHO :-P
07:38:10 <earthy> exactly
07:38:19 <quicksilver> Deewiant: can't be too careful.
07:38:24 <earthy> deewiant: it's quick though. :)
07:38:39 <Invisible> 3 > 4 for large 3
07:38:45 <Deewiant> earthy: not when the number is 5000 and you've got 500 of them :-P
07:39:09 <earthy> deewiant: well, it's still quicker than doing them by hand...
07:39:20 * ski_ wonders whether one could hook up SC with Martin Escardo's infinite search in finite time monad ..
07:39:25 <Deewiant> earthy: but slower than HUnit, which would run each one only once.
07:39:37 <ski_> <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/> A Haskell monad for infinite search in finite time
07:40:27 <Invisible> I used QuickCheck when I wrote a binary serialise/deserialise monad
07:40:42 <Invisible> it's a fast way to discover that you fluffed up ;)
07:41:01 <Invisible> sometimes hard to say whether the code or the QC property is wrong though o_O
07:42:20 <ManateeLazyCat> How any command-line program support regexp search? Hoogle doesn't support regexp search.
07:42:21 * Invisible wonders why the GHC testsuite uses Python rather than HUnit
07:42:32 <quicksilver> there are only two kinds of bug: missing tests and buggy tests.
07:42:42 <quicksilver> GHC's testsuite predates HUnit.
07:42:52 <Invisible> ...good reason. :)
07:42:59 <quicksilver> mind you, I think there was a secret agenda to incorporate as many programming languages as possible into GHC
07:43:17 <Invisible> er, yeah. WTH is with that anyway?
07:43:39 <Invisible> we've got Pyhton, Perl, bash scripts, sed scripts, makefiles... oh, and a sprinkling of Haskell.
07:43:56 <Invisible> not forgetting... C
07:44:30 <Deewiant> and C--
07:44:51 <Invisible> Is there any actual C-- mode? I thought there's autogen stuff, but no hand-written C--
07:44:52 <drdozer> is there a class that represents a measure (as in measure theory)?
07:45:37 <Deewiant> Invisible: there is some.
07:45:38 <Invisible> I kept looking at GHC's build system and thinking "oh my God! why don't you just throw this away and build something from scratch with Haskell"...
07:45:50 <Invisible> but then, the GHC devels *presumably* know a tad more about it than me.
07:45:51 <Deewiant> drdozer: I doubt it.
07:45:59 <olidu> Could someone give me a hint?  I want to write a program X which read a text file Y, Y is actually a haskell fragement in which a function say 'foo' must be defined, after X read Y, X call 'foo' and get returned value. How do I do it?
07:46:24 <drdozer> Deewiant: I was coming to that conclusion
07:46:25 <Invisible> Deewaint: oh, ok. what's it do?
07:46:30 <earthy> olidu: link to GHC as a library
07:46:46 <Deewiant> Invisible: your tab completion is broken
07:46:50 <earthy> earthy: but this is pretty advanced stuff
07:47:00 <earthy> olidu: but this is pretty advanced stuff
07:47:07 <olidu> earthy, how?
07:47:10 <Invisible> ..tab...completion...?
07:47:11 <pejo> Invisible, there is a new build system in the works.
07:47:16 <earthy> http://www.haskell.org/haskellwiki/GHC/As_a_library
07:47:20 <Deewiant> Invisible: (you keep misspelling my nick)
07:47:34 <olidu> earthy, this is quite easy in python...
07:47:36 <Invisible> Deewiant: oh, sorry. I kinda suck at typing... :S
07:47:48 <Invisible> pejo: yes, so I hear.
07:47:48 <Deewiant> Invisible: anyhoo, there's some C-- in the runtime system. does fairly lowlevel stuff with thunks and such.
07:48:03 <Deewiant> I don't really understand any of that stuff and haven't looked at it much :-)
07:48:22 <earthy> olidu: python is not normally a compiled language
07:48:27 <Invisible> Deewiant: well of course! is your name Simon?? ;)
07:48:27 <earthy> olidu: haskell is
07:48:46 <Deewiant> Invisible: 'fraid not :-)
07:48:48 <olidu> earthy, I see your point
07:48:55 <earthy> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/InteractiveEval.html
07:49:07 <earthy> it is possible though
07:49:16 <earthy> but it kinda requires linking in the entire compiler.
07:49:42 <olidu> earthy, yes, looks like what I want.
07:49:43 <drdozer> Deewiant: I keep running into mathematical things that operate over or defined on sets/intervals, rather than the set elements, which is quite awquard to model in haskell
07:49:44 * Invisible thinks a lightweight Haskell interpretter library would be nice for embedding into other apps...
07:49:46 <earthy> whereas in Python you already have the interpreter available once your code is running
07:50:17 <earthy> invisible: one could embed e.g. hugs
07:50:39 <earthy> invisible: but then you'd lose some of the extensions, and the interpreted code would be pretty slow
07:50:46 <quicksilver> ghci, despite being the opposite of lightweight, is still workably embeddable
07:50:51 <quicksilver> see hint, plugins, etc.
07:51:07 <quicksilver> earthy: if you embed hugs you lose binary compatibility with your host program.
07:51:30 <earthy> quicksilver: we weren't looking at binary compatibility as far as I can see
07:52:01 <quicksilver> normally when you embed an interpreter you need to pass values to/from it
07:52:19 * earthy nods
07:52:21 <quicksilver> there is no library that I know of for marshalling to/from hugs' internal representation of haskell values.
07:52:29 <quicksilver> if you embed GHC it's a no-op
07:52:29 <earthy> the interface to do so is fairly easy for python
07:52:30 <olidu> thanks earthy and everyone
07:52:34 <quicksilver> because the representations match.
07:52:41 <earthy> ah. right. ofcourse.
07:52:56 <quicksilver> sure, if you were embedding hugs in C that's fine (the interface is not too bad)
07:53:02 * earthy nods
07:53:03 <Invisible> quicksilver: I tried the GHC API once... I nearly didn't survive! o_O
07:53:05 <quicksilver> but if you're embedding hugs in haskell you have to remarshall.
07:53:10 * earthy nods
07:53:14 <earthy> through C probably
07:53:18 * quicksilver nods
07:53:20 <earthy> I'd fully expect that
07:53:27 <quicksilver> and worry about GC across the boundary, etc.
07:53:49 <Invisible> I gather the new GHC API is much nicer...
07:53:51 <earthy> I actually would've expected that for linking in GHC as a library and then using InteractiveEval
07:54:11 <earthy> if that is not the case then big bonus for GHC as a lib
07:54:20 <earthy> haven't looked into it too deeply yet
07:54:34 <Invisible> I guess it depends on what you want to do... there's always ghc -e and some pipes if you only want to do something trivial.
07:54:42 <earthy> uhuh
07:55:07 <Invisible> sandboxing is still an issue...
07:55:26 <quicksilver> embeddings GHC fails on the sandboxing front
07:55:31 <quicksilver> pros and cons of sharing the RTS :)
07:55:42 <quicksilver> on the up-side you get easy data and GC sharing
07:55:48 <Invisible> well, I don't know - if you use the GHC API, you can check types and stuff before you even run it ;)
07:55:49 <quicksilver> on the down-side, there is no sandbox barrier to speak of.
07:56:03 <quicksilver> But haskell is relatively amenable to 'static' sandboxing, yes.
07:56:09 <quicksilver> although that doesn't help resource usage.
07:56:19 * Invisible nods
07:56:41 <Invisible> actually, I was thinking that some way to divide up the heap based on what could possibly be "reachable" might be nice
07:57:01 <Invisible> like, if you know, statically, that structure X cannot possibly reference structure Y, run a seperate heap for each?
07:57:09 <Invisible> no idea how you'd implement or use that tho...
07:58:28 <Invisible> if all else fails, run multiple seperate binaries and use IPC to communicate between them ;)
08:00:19 <Invisible> hmm, way to kill a thread :-}
08:00:29 <Taejo> is there a better (less pointy) way to write (case xs of {[] -> Nothing; _ -> Just xs})
08:01:01 <Invisible> yes... there's a library function for this...
08:01:05 <Invisible> name escapes me...
08:01:10 <quicksilver> Taejo: listToMaybe
08:01:20 <quicksilver> no, that's not right.
08:01:26 <quicksilver> close, though ;)
08:01:31 <Invisible> ...quicksilver has it.
08:01:32 <Taejo> quicksilver: I'm looking for [a] -> Maybe [a]
08:01:38 <Taejo> not [a] -> Maybe a
08:01:46 <quicksilver> Yes, I realised that after I wrote it.
08:02:23 <Invisible> does anybody where have a PhD?
08:02:28 <Invisible> *here
08:02:45 <quicksilver> More than one, I should imagine.
08:02:46 <ksf> Taejo, Just?
08:02:49 <ksf> :t Just
08:02:50 <lambdabot> forall a. a -> Maybe a
08:02:56 <Cheshire> > sequence "" :: Maybe Char
08:02:57 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `Char'
08:02:58 <Taejo> ksf: :)
08:03:00 <ksf> :t Just []
08:03:01 <lambdabot> forall a. Maybe [a]
08:03:05 <Cheshire> > sequence (map return "") :: Maybe Char
08:03:06 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
08:03:14 <Cheshire> > sequence (map return "") :: Maybe [Char]
08:03:16 <lambdabot>   Just ""
08:03:45 <Invisible> some dudes are trying to tell me I should do a PhD.
08:03:52 <Invisible> presumably I am insufficiently intelligent though...
08:03:57 <Cheshire> @go Why you should never do a PhD
08:03:58 <lambdabot> http://www.nigels.com/jokes/phd1.pdf
08:03:58 <lambdabot> Title: SO YOU WANT TO DO A PhD?
08:04:21 * Invisible reads
08:04:24 <ksf> anyway, wrapping a list in a maybe is superfluous information.
08:04:31 <rwbarton> @type guard (not $ null ?xs) >> Just xs
08:04:32 <lambdabot> Not in scope: `xs'
08:04:34 <rwbarton> @type guard (not $ null ?xs) >> Just ?xs
08:04:35 <lambdabot> forall a. (?xs::[a]) => Maybe [a]
08:04:37 <ksf> just use safeHead or something.
08:04:46 <Cheshire> Taejo, yeah since I can't think of a good way I'm gonna move the goal posts
08:04:49 <rwbarton> @pl \xs -> guard (not $ null xs) >> Just xs
08:04:49 <lambdabot> ap ((>>) . guard . not . null) Just
08:05:23 <Taejo> ksf: unfoldr demands a Maybe
08:05:24 <Cheshire> Taejo, like data Liste a = Nil a | Cons a (Liste a) and then [a] -> Maybe (Liste a)
08:05:56 <Cheshire> (maybe there is a better name for List with a bit on the end ..)
08:06:06 * Invisible LOLs and continues reading
08:07:45 <Cheshire> @go Peter Hancock Doing a thesis
08:07:46 <lambdabot> No Result Found.
08:08:05 <Cheshire> @go Doing a thesis hancock
08:08:06 <lambdabot> No Result Found.
08:08:13 <Cheshire> http://www.dcs.ed.ac.uk/home/pgh/thesis.html
08:09:06 <boegel> Cheshire: nice one (the Phd one), and mostly true actually :)
08:09:24 * boegel boings off
08:09:42 <chessguy_work> @type fix
08:09:43 <lambdabot> forall a. (a -> a) -> a
08:10:02 <Invisible> @type phd thesis
08:10:02 <lambdabot> Not in scope: `phd'
08:10:02 <lambdabot> Not in scope: `thesis'
08:10:42 <Cheshire> @let phdThesis = "a bloody and painful Caesarian. In a cow-shed. Using a piece of scaffolding."
08:10:43 <lambdabot>  Defined.
08:11:36 <michaelcdever> anyone want to review my gtk2hs file manager for me?
08:11:47 <quicksilver> having witnessed both a PhD and a Caesarean
08:11:55 <quicksilver> I would personally opt for a PhD, personally
08:12:04 <quicksilver> although the final outcome of the Caesarean was better.
08:13:00 <lilac> Cheshire: I'd call that type a NonEmptyList :)
08:13:28 <Invisible> lol @ quicksilver
08:13:52 <Invisible> if it's anything like my final year degree project, it can't be much fun.
08:14:03 <Invisible> I spent ages reading about stuff, and I had a clear idea in my head.
08:14:15 <Invisible> but from what I wrote and the presentation I gave, you'd think I had *no clue*...
08:14:21 <Axman6> Caesarean?
08:14:32 <quicksilver> my PhD was probably the best three years of my life
08:14:46 <quicksilver> although not entirely because of the PhD itself.
08:14:48 <Invisible> quicksilver: what was the subject?
08:14:54 <quicksilver> But I enjoyed that too.
08:14:58 <quicksilver> mathematical logic.
08:15:21 <Invisible> OK.
08:15:23 <quicksilver> assuming you're funded (I was) it's three years where you can really read about and think about stuff you find interesting.
08:15:40 <Invisible> as far as I can tell, that's borderline between the stuff that makes sense, and the stuff that doesn't.
08:15:40 <quicksilver> spend time with smart people listening to what they find interesting
08:16:01 <Invisible> quicksilver: this is what these guys are trying to tell me... that it's this really fun thing.
08:16:12 <Invisible> OTOH, I have no money, no time, and no subject...
08:16:14 <quicksilver> I'm sure it doesn't suit everyone.
08:16:28 <Axman6> i'd like to write one one day
08:16:32 <quicksilver> a funded PhD gives you time. Unless there are other demands on your life.
08:16:40 <Axman6> but, i have a ot of learning to do first :)
08:16:44 <quicksilver> an unfunded one - well that would be hard work.
08:16:45 <Invisible> I'm currently working.
08:16:49 <Invisible> for peanuts, you understand...
08:16:50 <ski_> <http://pharyngula.org/index/weblog/comments/grad_school_was_great_i_recommend_it_to_everyone/> Grad school was great! I recommend it to everyone!
08:17:33 <Invisible> right now, I'm supposed to be working rather than chatting on IRC! ;)
08:18:48 <Invisible> I'd love to have a job that pays actual money, but I don't see any way of achieving this
08:18:50 <Axman6> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all&d=ndata&calc=calculate&icpp=on&gcc=on&icc=on&gpp=on&dlang=on&ghc=on&java=on&sbcl=on&csharp=on&hipe=on&mzscheme=on&vw=on&lua=on&python=on&perl=on&php=on&javascript=on&ruby=on&box=1 we're not doing too badly
08:18:58 <Axman6> oh god that's a long url :|
08:19:00 <Invisible> certainly I can't think of a way that involves Haskell ;)
08:22:16 <ski_> ("The son-of-a-bitch actually died on me before my final Ph.D. defense, which I thought was terribly unfair of him. I half expected to see his rotting corpse pounding at the door of the seminar room, like something out of EC comics, and that he'd point a bony finger at me and demand that I derive the Goldman equation for him, or join him in hell. Didn't happen. I even kinda missed him. Oh, well." :)
08:22:41 <hallongrottan> @pl fetchAddr >>= (readMemory >=> adc)
08:22:41 <lambdabot> readMemory >=> adc =<< fetchAddr
08:22:45 <hallongrottan> lol
08:23:18 <Peaker> @type (>=>)
08:23:19 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:23:20 <rwbarton> parenthesesfree
08:24:07 <Axman6> >=> is just >>= applied twice?
08:24:20 <earthy> nope
08:24:23 <Peaker> Axman6, seems to be klesili arrow composition -- or more simply: action composition
08:24:26 <michaelcdever> noone?
08:24:31 <Axman6> like x >>= f >>= g == f >=> g x?
08:24:31 <earthy> peaker: exactly
08:24:47 <earthy> axman6: there's a return missing there
08:25:11 <Axman6> there is?
08:25:30 <ski_> (f >=> g) x = f x >>= g
08:25:46 <earthy> return a >>= f >>= g == (f >=> g) a
08:25:50 <Peaker> @type (\f g -> (>>=g) . f)
08:25:51 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a1 -> m a) -> (a -> m b) -> a1 -> m b
08:25:53 <Axman6> ski_: oh, so it is
08:26:03 <Black> heyy, i can finally program hello world in GHC not ghci XD
08:26:22 <Axman6> Black: you mean compiled?
08:26:54 <CTA> Yeah XD
08:27:00 <ski_> f >=> g = (=<< g) . f  -- alternative
08:27:17 <ski_> (=<<) :: Monad m => (a -> m b) -> (m a -> m b)
08:27:41 <CTA> is it best to: main :: IO () ... main = .. or just main = ?
08:27:51 <hallongrottan> doesnt >=> work sorta like . but for monads?
08:27:59 <byorgey> CTA: for main, it probably doesn't matter so much.
08:28:06 <ski_> CTA : i don't think it usually matters
08:28:17 <byorgey> hallongrottan: indeed, >=> composes functions of type  (a -> m b)  where m is an instance of Monad
08:28:38 <hallongrottan> ah yes
08:28:45 <ski_> Kleisli f >>> Kleisli g = Kleisli (f >=> g)
08:29:27 <chessguy_work> > zipWith3 ($) (cycle [const,flip const]) "hai! haha!"
08:29:27 <chessguy_work>  "yarlysotense!"
08:29:28 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
08:29:28 <lambdabot>        arising from a...
08:29:38 <byorgey> also, someone (*ahem Cale*) should tell lambdabot to join #haskell-in-depth
08:29:38 <CTA> so, haskell is "functional programming", so what, C/C++/C#/Java arn't, someone explain pls?
08:29:46 <hallongrottan> hey byorgey, I read parts of your typeclassopedia, it looked really gooi
08:29:48 <hallongrottan> good!
08:29:48 <chessguy_work> > zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
08:29:50 <lambdabot>   "hail satan"
08:29:55 <byorgey> thanks hallongrottan =)
08:29:56 <earthy> CTA: C/C++/C#/Java are 'imperative programming'
08:30:09 <Cheshire> or procedural
08:30:25 <ski_> (or dysfunctional ..)
08:30:31 <Cheshire> hehe
08:30:34 <earthy> CTA: the 'functional' indicates the pervasive use of functions (and only functions) to describe calculations
08:30:54 <earthy> rather than the commands that make a machine perform the calculations
08:30:59 <Invisible> "nonfunctional"
08:31:00 <CTA> so wait, you saying you can't do 1 + 1, it has to be add 1 1?
08:31:17 <earthy> CTA: actually, it's the other way around. ;)
08:31:23 * ski_ gives byorgey an `@ask' command
08:31:54 <earthy> CTA: think of it as taking the expressions from e.g. C# and then doing *all* your programming with just expessions
08:31:58 <earthy> +r
08:31:58 <CTA> how do i output 1 + 1 (outcome not string)? i tried putStrLn 1 + 1
08:32:09 <earthy> putStrLn (show (1 + 1))
08:32:16 <ski_> print (1 + 1)
08:32:25 <ski_> @src print
08:32:25 <lambdabot> print x = putStrLn (show x)
08:32:30 <byorgey> ski_: ?
08:32:47 <ski_> byorgey : re lambdabot ..
08:32:52 <earthy> CTA: the show translates everything that can be shown into a string
08:32:57 <byorgey> ski_: ah =)
08:32:59 <earthy> (which is handy in other places as well)
08:33:14 <byorgey> @ask Cale could you tell lambdabot to join #haskell-in-depth? pretty please?
08:33:14 <lambdabot> Consider it noted.
08:33:33 <earthy> oh, yeah, byorgey, your typeclassopedia is neat
08:33:41 <earthy> does have a few kinks though
08:33:41 <ski_> @where typeclassopedia
08:33:41 <lambdabot> I know nothing about typeclassopedia.
08:33:49 <byorgey> thanks earthy
08:33:50 <Peaker> @go typeclassopedia
08:33:51 <lambdabot> http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
08:33:51 <lambdabot> Title: The Typeclassopedia — request for feedback « blog :: Brent -> [String]
08:33:54 <quicksilver> earthy: a kinky typeclassopedia? even better.
08:33:59 <byorgey> haha
08:34:25 <Invisible> byorgey: yeah, typeclassopedia is pretty neat. I sent some comments to haskell-cafe, but the moderators haven't released it yet... :(
08:34:29 <byorgey> I'm hoping to get most of the kinks worked out within the next couple weeks.  thanks to the great feedback I've been getting, it shouldn't be hard.
08:34:43 <byorgey> Invisible: oh? are you not subscribed?
08:35:03 <Invisible> byorgey: no, I'm subscribed, but lately all my posts get moderated.
08:35:03 <earthy> oh, and it'd be nice if the 'exercises' were more clearly marked
08:35:03 <byorgey> Invisible: you can also just send them directly to me
08:35:19 <ski_> byorgey : Uustalu and Vene for some papers on Comonads
08:35:21 <earthy> and it'd also be nice to (in time) have worked explanations for the exercises. :)
08:35:24 <byorgey> Invisible: that's strange.  are you absolutely sure that you are subscribed under the same address that your emails look like they're coming from?
08:35:31 <hallongrottan> @src (<=<)
08:35:31 <lambdabot> Source not found. Wrong!  You cheating scum!
08:35:34 <hallongrottan> :(
08:35:42 <Invisible> byorgey: it all worked fine, and then one week I suddenly started being moderated.
08:35:50 <byorgey> Invisible: weird.
08:35:54 <ski_> (byorgey : you might try searching LtU if you haven't done so)
08:36:01 <Invisible> byorgey: given that apparently people regard me as a troll, I presume somebody decided this was a good idea...
08:36:17 <byorgey> ski_: ah, thanks, good idea
08:36:21 * Invisible discovers the tab key...
08:36:26 <ski_> (:
08:36:36 <Invisible> [tab] [tab] [tab]
08:36:44 <earthy> oh, yeah, comonads, cool. especially the 'zipper' interpretation as a comonad.
08:36:45 <dons> how hard can it be to reimplement ruby, given http://code.macournoyer.com/tinyrb/ (2000 lines of C
08:37:00 <ski_> byorgey : right, sigfpe has some posts on it, too
08:37:10 <Invisible> OK, I should stop doing that now... ;)
08:37:26 <byorgey> yeah, by the time I got to Comonad I just wanted to get the damn thing finished =)
08:37:40 <earthy> that's obvious. :)
08:37:45 <ski_> In^I : doi^I wh^I ?
08:37:46 <byorgey> but in the next week or two I will take some time to do some more in-depth searching for good references.
08:37:51 <byorgey> ski_: thanks for the suggestions.
08:38:30 <ski_> (byorgey : there's also a certain paper by Dick Kieburtz (sp?) about `OI' .. that doesn't really work, unfortunately)
08:38:37 <earthy> http://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/ :)
08:38:55 <byorgey> thanks earthy =)
08:39:35 <dons> this is a pleasing article, http://offthelip.org/?p=125
08:39:50 <earthy> dons: yeah, it is
08:40:07 <chessguy_work> i think i finally figured out the types for what i'm trying to do (the first few definitions of http://codepad.org/a0kBVuL6). not sure yet if it's going to be generally useful
08:40:12 <earthy> anyway, back to VB.NET
08:40:40 <byorgey> earthy: also, I agree re: worked answers to exercises
08:40:45 <Invisible> ooo, hi dons.
08:40:48 <ski_> earthy : vade retro, satanos !
08:40:53 <earthy> ski: *what*?! :)
08:41:16 <earthy> it actually *helps* appreciating Haskell more!
08:41:33 <earthy> plus, all the one-offs and code-generation I do with Haskell
08:41:59 <earthy> just that the 'customer' likes his code to be understandable by the VB.NET wranglers in house
08:42:01 <byorgey> I do hope in time to maybe convert it into something on the wiki, as several people have suggested, at which point adding more exercises and solutions could make sense.
08:42:34 <earthy> byorgey: what would be equally neat is for this to be the basis of the documentation of the classes themselves
08:42:40 <hackage> Uploaded to hackage: algebra 0.0.0.0
08:43:02 <Invisible> dons: I sent a reply to your email, but it hasn't showed up on cafe yet.
08:43:12 <chessguy_work> heh, i thought i clicked on dons' link above, but knew i had clicked the wrong when when i saw category theory :)
08:43:12 <byorgey> earthy: sure, the existing Haddock docs could certainly use a major facelift.
08:43:19 * earthy nods
08:43:35 <earthy> especially the likes of Foldable and Traversable
08:44:15 <earthy> your doc actually made the 'okay, Foldable drops the structure down to a basic list and then combines' intuition that I had and ties it neatly to monoids
08:44:28 <earthy> +clearer (somewhere)
08:44:32 * chessguy_work idly wonders of data Foo a = D a | P (Foo a -> Foo a) is isomorphic to anything simpler
08:44:33 <ski_> chessguy_work : no, you misunderstand. that means you've clicked *right*
08:44:38 <chessguy_work> ski_ :)
08:44:49 <byorgey> anyway, in general the idea is that I wanted to publish it first in a form that would (a) help me focus on elegance and good writing, and (b) give me a deadline so I would actually get it done.
08:45:15 <chessguy_work> ski_ yeah, *right* into a headache
08:45:20 <byorgey> but later I hope to open it up, convert to different formats, and let others improve it/ use it to improve the library documentation/whatever
08:45:26 <ski_> (chessguy_work : probably not .. that looks like untyped lambda calculus with a base type)
08:45:33 <fasta> dons: but the title is awful, it is engineered to draw lots of attention. It's like "Why Haskell sucks?", but then doesn't talk about that ^^
08:45:46 <dons> titles are like that.
08:46:04 <fasta> dons: no, blog post titles are like that.
08:46:09 <Taejo> :t ap
08:46:10 <byorgey> earthy: yeah, Foldable and Traversable are underappreciated.  I actually learned a lot about them just by writing this.
08:46:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:46:11 <dons> shrug.
08:48:03 * byorgey goes off to class
08:48:07 <Taejo> :t (==) `on` fst
08:48:07 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
08:48:15 <dons> ?hoogle equating
08:48:16 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
08:48:24 <dons> ?hoogle comparing
08:48:24 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:48:24 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:48:31 <redditbot> Haskell Weekly News: February 17, 2009
08:48:31 <redditbot> Comonads in everyday life
08:48:31 <redditbot> Interview: Lennart Augustsson on DSLs Written in Haskell
08:48:31 <redditbot> Lemmih: LHC - past, present and future
08:48:31 <redditbot> GHC on SPARC: Thunderbirds are go
08:48:37 <dons> so equating didn't make it into Data.Function ?
08:48:54 <Taejo> @pl \(x, y) -> (x-y) ^ 2
08:48:54 <lambdabot> uncurry (flip flip 2 . ((^) .) . (-))
08:49:06 <Taejo> :t flip flip
08:49:07 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
08:49:22 <Taejo> :t flip flip 2
08:49:23 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
08:49:56 <Taejo> subtract 2 1
08:49:59 <Taejo> > subtract 2 1
08:50:00 <lambdabot>   -1
08:50:22 * chessguy_work really needs to lock into some names for his data types
08:52:33 * Invisible leaves for home...
08:53:27 <njbartlett> Hey I didn't know Lennart left Credit Suisse...
08:58:14 <chessguy_work> preflex, @seen conal
08:58:15 <preflex>  conal was last seen on #haskell 7 days, 14 hours, 9 minutes and 54 seconds ago, saying: Cale: oops -- dinner time.  i gotta go.  will look for you tomorrow.  thx for the help so far.
08:58:28 <chessguy_work> wow, long dinner :)
08:59:00 <Peaker> Long tomorrow :)
08:59:51 <chessguy_work> man, codepad is making it way too easy for me to code haskell at work, when i should be working instead
09:00:44 <chessguy_work> @pl \(x, y) -> (x - y) * (x - y)
09:00:44 <lambdabot> uncurry (ap (ap . ((*) .) . (-)) (-))
09:00:54 <Peaker> I made a cursory attempt at breaking codepad -- but they use kernel-level syscall prevention, it seems
09:01:12 <chessguy_work> wow
09:01:15 <chessguy_work> what a stupid thing to do
09:01:25 <chessguy_work> @pl \(x, y) -> (*) (x - y) (x - y)
09:01:26 <lambdabot> uncurry (ap (ap . ((*) .) . (-)) (-))
09:01:43 <Peaker> Cheshire, what is a stupid thing to do?
09:01:49 <Peaker> chessguy_work, that is
09:01:53 <chessguy_work> try to break codepad
09:01:59 <Cheshire> what
09:02:00 <Taejo> :t (^2) . uncurry subtract
09:02:01 <lambdabot> forall a. (Num a) => (a, a) -> a
09:02:03 <Peaker> heh why? I thought it was an interesting challenge
09:02:10 <Peaker> Cheshire, accidental completion. xchat's default completion sucks
09:02:23 <chessguy_work> Cheshire, you and i look way too much alike
09:02:47 <chessguy_work> peaker it's a great service, and you're likely to piss off the owner if you hack his site
09:03:19 <quicksilver> better that peaker tries it than a real hacker tries it
09:03:20 <Peaker> chessguy_work, If I had broken it, you realize I'd be more likely to mail him about how its broken rather than rm -rf / or something :)
09:03:29 <quicksilver> because if it's possible, a real hacker will do it sooner or later
09:03:31 <quicksilver> probably sooner
09:03:44 <quicksilver> security by "I'll be nice and not do that" is not security ;)
09:03:48 <Peaker> I thought it was interesting that it let you execute arbitrary C code
09:03:55 <chessguy_work> peaker still, he'd be more likely to shut it down than try to fix it
09:03:58 <Peaker> so I casted a char array to a function and called it :)
09:04:02 <chessguy_work> judging from the fact that it still runs on hugs...
09:04:46 <Peaker> I did that because it links against a fake glibc that does not really syscall
09:05:16 <quicksilver> Peaker: and what happens when you jump to a char array?
09:05:50 <Peaker> quicksilver, it executes it as you'd expect - but if you try to syscall in there, you get "SYS CALL BLOCKED" messages or something like that
09:06:04 <quicksilver> oh, cool
09:06:07 <Zao> Peaker: Codepad uses geordi for protection, I believe.
09:06:07 <Peaker> some kernel thing blocks it
09:06:08 <chessguy_work> nice
09:06:12 <Taejo> how do I set up \bot in GHCi?
09:06:14 <quicksilver> so you can actually dynamically generate assembly and jump to it?
09:06:20 <quicksilver> it should be able to Harpy then!
09:06:22 <Peaker> quicksilver, yeah
09:06:24 <chessguy_work> Taejo, google "haskell acid"
09:06:32 <Zao> Peaker: Which is Eelis' sneaky ptrace Haskell-based supervisor.
09:07:13 <quicksilver> Code execution is handled by a supervisor based on geordi. The strategy is to run everything under ptrace, with many system calls disallowed or ignored. Compilers and final executables are both executed in a chroot jail, with strict resource limits. The supervisor is written in Haskell.
09:07:13 <Zao> Any syscalls are routed to the parent process via ptrace which can do whatever it wants in userspace about them.
09:07:18 <Peaker> Zao, cool
09:07:23 <Zao> Same concept as strace and truss.
09:07:51 <chessguy_work> Eelis++
09:08:19 <Peaker> I wonder what holes that strategy has. Unix is full of holes :)
09:08:27 <chessguy_work> heh. i just thought i heard someone say "co-bob" when it was actually "kabob". i've been spending way too much time in here
09:08:28 <Eelis> Peaker: i wonder, too ;)
09:08:28 <quicksilver> @where+ geordi http://www.xs4all.nl/~weegen/eelis/geordi/
09:08:28 <lambdabot> Nice!
09:08:42 <chessguy_work> lol, lambdabot is pretty excited about that
09:09:32 <quicksilver> rightly so.
09:09:35 <quicksilver> clevers tuff it is.
09:10:43 <Peaker> does harpy have MonadFix for jumping forwards?
09:10:49 <fasta> Peaker: do you know a platform-independent hack that will work on any conforming Unix implementation? ;)
09:10:54 <chessguy_work> yes, i don't know why i still under-estimate lambdabot's sentience
09:10:57 <pumpkin> Peaker: jumping?
09:11:12 <quicksilver> Peaker: you'd hope so, wouldn't you? Should be easy to implement.
09:11:21 <Peaker> fasta, not anymore, but there used to be ones :) sending a print job with "delete afterwards" option and printing /etc/passwd, :)
09:11:37 <fasta> Peaker: ouch!
09:11:52 <Peaker> fasta, Lots of instances of "The Confused Deputy"
09:12:01 <Peaker> Its one of the main reasons to use capabilities
09:12:39 <pumpkin> oh I see, you meant for code gen
09:13:41 <rwbarton> Peaker: ISTR it's more awkward, you create the label before you need to jump to it, and assign it an address when you get to where it should jump to
09:14:37 <Peaker> rwbarton, I think maybe Monad is not the right construct for this at all?
09:15:38 <Peaker> I am not sure what a better alternative would be, but it seems Monad is used only for "do" sugar :)
09:15:47 <Peaker> (and not because it makes an awful lot of sense here)
09:16:08 <ski_> > allC $ \xs -> xs !! 0 /= xs !! 3
09:16:09 <lambdabot>   False
09:16:19 <ski_> > allC $ \xs -> xs !! 0 /= xs !! 0
09:16:19 <Cheshire> :t allC
09:16:20 <lambdabot>   False
09:16:21 <lambdabot> ([Bool] -> Bool) -> Bool
09:16:33 <Taejo> chessguy_work: I googled "haskell acid", and found this "A. WEIL KILLED BY PRUSSIC ACID; Senior Member of Weil, Haskell & Co. Took Overdose of Medicine Containing It."
09:16:35 <ski_> > findC $ \xs -> xs !! 0 == xs !! 3
09:16:36 <lambdabot>   Just [False,False,False,False,False,False,False,False,False,False,False,Fal...
09:16:44 <chessguy_work> hahaha
09:16:45 <ski_> > findC $ \xs -> xs !! 0 /= xs !! 3
09:16:46 <lambdabot>   Just [False,False,False,True,False,False,False,False,False,False,False,Fals...
09:16:56 <ski_> > findC $ \xs -> xs !! 0 /= xs !! 0
09:16:57 <lambdabot>   Nothing
09:17:06 <ski_> @type anyC
09:17:07 <lambdabot> Not in scope: `anyC'
09:17:12 <ski_> @type someC
09:17:13 <lambdabot> ([Bool] -> Bool) -> Bool
09:17:15 <Cheshire> > allC $ \xs -> head xs || not (head xs)
09:17:17 <lambdabot>   True
09:17:39 <chessguy_work> Taejo, did you also find what you were looking for?
09:18:17 <Taejo> chessguy_work: Chris Done's blog seems to be the place, but I'm getting 500 error
09:18:33 <ski_> hm, would be nice if one could quantify over tails ..
09:18:42 <Apocalisp> Haskell Acid: HsO2
09:18:42 <chessguy_work> Taejo, yeah, i just noticed that. you can try playing with this: http://www.cse.unsw.edu.au/~dons/code/goa/
09:19:05 <rwbarton> > findC $ \xs -> and (zipWith (/=) (take 10 xs) (tail xs))
09:19:06 <lambdabot>   Just [False,True,False,True,False,True,False,True,False,True,False,False,Fa...
09:19:39 <ski_> (btw, these are all infinite streams)
09:20:09 <Taejo> chessguy_work: I see there is a package on hackage... is there a compelling reason to get it from Don's repo?
09:20:24 <rwbarton> > findC (!! 10000)
09:20:26 <lambdabot>   Just [False,False,False,False,False,False,False,False,False,False,False,Fal...
09:20:46 <pumpkin> that chipmunk physics lib looks cool, but it would be nice if the haskell binding were more pure :/
09:20:56 <pumpkin> every function is in IO :/
09:20:57 <ski_> (also, you may not it defaults with `False')
09:21:03 <ski_> (s/not/note/)
09:21:04 <chessguy_work> Taejo, not necessarily, no
09:21:10 <chessguy_work> Taejo, i didn't realize it was on hackage, sorry
09:21:21 <chessguy_work> @type findC
09:21:22 <lambdabot> ([Bool] -> Bool) -> Maybe [Bool]
09:21:25 <rwbarton> > findC and
09:21:30 <ski_> hehe :)
09:21:33 <chessguy_work> @index findC
09:21:33 <lambdabot> bzzt
09:21:36 * ski_ already tried that
09:21:37 <pumpkin> :t findC
09:21:38 <rwbarton> Do you have the non-Maybe version?
09:21:39 <lambdabot> ([Bool] -> Bool) -> Maybe [Bool]
09:21:40 <lambdabot>   thread killed
09:21:46 <Cheshire> > findC or
09:21:47 <ski_> a moment
09:22:01 <chessguy_work> @hoogle findC
09:22:01 <lambdabot> No results found
09:22:01 <lambdabot>   thread killed
09:22:13 <rwbarton> > findC (not . and)
09:22:15 <lambdabot>   Just [False,False,False,False,False,False,False,False,False,False,False,Fal...
09:22:22 <Cheshire> > findC (not . or)
09:22:38 <lambdabot>   thread killed
09:22:41 <ski_> @type getC
09:22:42 <lambdabot> ([Bool] -> Bool) -> [Bool]
09:22:47 <rwbarton> > getC and
09:22:50 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
09:22:57 <ski_> interesting
09:22:58 <rwbarton> process of elimination :)
09:23:14 <pumpkin> lol
09:23:21 <Taejo> chessguy_work: "this is broken with recent Lambdabots."
09:23:23 <ski_> > findC or
09:23:38 <lambdabot>   thread killed
09:23:39 <ski_> > getC or
09:23:54 <lambdabot>   thread killed
09:23:55 <chessguy_work> @pl \xs ys -> xs ++ ys
09:23:55 <lambdabot> (++)
09:24:03 <rwbarton> the "first thing" either findC or getC does is evaluate f (repeat False)
09:24:21 <chessguy_work> @type (++) ?x
09:24:22 <lambdabot> forall a. (?x::[a]) => [a] -> [a]
09:25:22 <rwbarton> @bot
09:25:22 <lambdabot> :)
09:25:22 <lunabot>  :)
09:25:44 <ski_> (for the curious, i mentioned a link earlier today which talks about these `allC',`someC',`findC',`getC')
09:26:04 <Saizan> @type findC
09:26:06 <lambdabot> ([Bool] -> Bool) -> Maybe [Bool]
09:26:16 <Saizan> @type getC
09:26:18 <lambdabot> ([Bool] -> Bool) -> [Bool]
09:26:23 <ski_> (and `C' stands for "Cantor")
09:27:12 <chessguy_work> how cool does this sound: computations with strongly re-ified versions of their own future :)
09:27:27 <ski_> what does it mean ?
09:27:39 <chessguy_work> ski_ http://codepad.org/QCg1WrKa
09:27:48 <Apocalisp> data flow programming?
09:28:03 <pejo> Can darcs somehow not notice that there are patches missing to the current repository?
09:28:11 <chessguy_work> ski_ just a fancy title for some crap i've been fiddling with
09:28:27 <rwbarton> ski_: chessguy_work asked how cool it sounded, not how cool it was
09:29:11 <chessguy_work> rwbarton, if ski_ wants to comment on how c{ool,rappy} it is, his opinion is always welcome
09:29:25 <ski_> (the `extract' make me think of comonads .. but i have not idea if it could be made into one somehow)
09:29:27 <rwbarton> chessguy_work: fair enough :)
09:29:40 <C-Keen> pejo: it should pull all dependencies correctly when you cherry pick
09:29:49 <chessguy_work> ski_ does anything not make you think of comonads? :)
09:30:26 <ski_> chessguy_work : yes, e.g. reflective syntax for equality proofs
09:30:43 <chessguy_work> heh. naturally
09:31:24 <chessguy_work> ski_ i have no idea if this is generally useful, but i tend to over-generalize when i'm coding something, and this is what is falling out
09:31:31 <ski_> (rwbarton : yes, but i need to compare with what it means to tell if it's sounding cool or not ;)
09:31:51 <ski_> (rwbarton : i invented that on the spot, if you're wondering)
09:32:46 <ski_> chessguy_work : you're in good company
09:32:49 * ski_ over-generalizes all the time
09:33:03 <chessguy_work> it's just so bloody easy in haskell
09:33:07 <Axman6> oh cool, 6.10.2 RC expected by the end of the week
09:33:26 <augustss_> yay!
09:33:42 <ski_> `RC' ?
09:33:56 <ski_> oh, release candidate
09:34:08 <pejo> C-Keen, I have just pulled and edited files in this repository. (never commited)
09:34:16 <ski_> (thought it was some revision control system or something)
09:34:37 * ski_ should go back to trying to figure out how reflective equality syntax wants to work ..
09:34:53 <chessguy_work> Apocalisp, is data flow programming something real, or just a cheesy name people throw around?
09:34:58 <ksf> does anyone have a brain softener?
09:35:14 <ksf> I need to fit my head around oleg's code and it doesn't bend enough.
09:35:21 <C-Keen> pejo: then there is no patch darcs can miss because it does not know about your changes unless you commit. But maybe I am not fully understanding your use case
09:35:23 <Axman6> ksf: a good smack to the head'll fix what ales ya
09:36:37 <ski_> (chessguy_work : Lucid, Lustre, Esterel, ...)
09:36:41 * chessguy_work readies his 2x4
09:36:47 <Apocalisp> chessguy_work: http://lambda-the-ultimate.org/node/988
09:37:11 <ski_> Apocalisp :)
09:37:25 <ski_> "The essence of Dataflow Programming by Tarmo Uustalu and Varmo Vene"
09:37:25 <chessguy_work> speaking of needing brain-softener...
09:37:46 <ski_> (relates dataflow to comonads, yum !)
09:38:05 <Axman6> > 13251023850803 .|. 1250403204598735 :: Integer
09:38:11 <lambdabot>   1263601907650559
09:38:39 <chessguy_work> @hoogle (.|.)
09:38:39 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
09:38:52 <Axman6> > 13251023850803 .&. 1250403204598735 :: Integer
09:38:56 <lambdabot>       Ambiguous occurrence `.&.'
09:38:56 <lambdabot>      It could refer to either `Data.Bits..&....
09:38:57 <chessguy_work> oh, THAT (.|.)
09:39:12 <Axman6> > 13251023850803 (Data.Bits..&.) 1250403204598735 :: Integer
09:39:15 <lambdabot>       No instance for (Num ((a -> a -> a) -> t -> Integer))
09:39:15 <lambdabot>        arising fr...
09:39:15 <chessguy_work> haskell, the language of pornographic operators
09:39:25 <Axman6> > 13251023850803 (Data.Bits.(.&.)) 1250403204598735 :: Integer
09:39:28 <lambdabot>       Failed to load interface for `Data':
09:39:28 <lambdabot>        Use -v to see a list of the...
09:39:46 <Axman6> :t (.&.)
09:39:47 <rwbarton> Axman6: no parens at all
09:39:50 <lambdabot>     Ambiguous occurrence `.&.'
09:39:50 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
09:39:50 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
09:40:02 <Olathe> > Data.Bits..&.
09:40:03 <Axman6> > 13251023850803 Data.Bits..&. 1250403204598735 :: Integer
09:40:08 <lambdabot>   <no location info>: parse error on input `Data.Bits..&.'
09:40:10 <lambdabot>   52320798979
09:40:33 <Olathe> > 13251023850803 Test.QuickCheck..&. 1250403204598735 :: Integer
09:40:36 <lambdabot>   Couldn't match expected type `Integer'
09:40:49 <Axman6> :t Test.Quickcheck..&.
09:40:55 <lambdabot> parse error on input `Test.Quickcheck..&.'
09:40:59 <Olathe> :t (Test.Quickcheck..&.)
09:41:01 <lambdabot> Couldn't find qualified module.
09:41:10 <Apocalisp> @let (_Y_) = (_Y_)
09:41:16 <lambdabot>  Defined.
09:41:24 <Axman6> > _Y_
09:41:28 <lambdabot>       No instance for (Show GHC.Prim.Any)
09:41:28 <lambdabot>        arising from a use of `show'...
09:42:09 <Pegazus> Hi! How do you call a set which has more than one element? How do you call a "thing" that takes a 2 dimension vectorial space, to a 3 dimension vectorial space (the "inverse" of a projection, obviously it's not an inverse beause it's not reversible, the projection looses data, but you probably get what i mean)...
09:42:40 <hallongrottan> @pl  gets pc >>= \pc -> fetch >>= \op -> bcc (pc + fromIntegral op)
09:42:40 <lambdabot> (fetch >>=) . (bcc .) . (. fromIntegral) . (+) =<< gets pc
09:42:49 <rwbarton> Pegazus: "a set which has more than one element"; "linear transformation"
09:42:51 <hallongrottan> hmm...
09:43:13 <hallongrottan> is there an easier way to get rid of the binding of op?
09:43:32 <pumpkin> linear?
09:43:45 <quicksilver> hallongrottan: bbc . (pc+). fromIntegral
09:44:01 <hallongrottan> aha
09:44:05 <hallongrottan> thanks quicksilver
09:44:12 <quicksilver> (to the right of the final >>=)
09:44:17 <hallongrottan> yes :)
09:44:28 <Olathe> > (Test.Quickcheck..&.)
09:44:31 <lambdabot>       Failed to load interface for `Test.Quickcheck':
09:44:31 <lambdabot>        Use -v to see a ...
09:44:35 <michaelcdever> hey has anyone got gtk2hs installed on ubuntu? or know of a decent guide for installing it?
09:44:43 <Olathe> > (Data.Bits..&.)
09:44:46 <lambdabot>       Overlapping instances for Show (a -> a -> a)
09:44:46 <lambdabot>        arising from a use ...
09:44:58 <rwbarton> hallongrottan: bcc <$> (liftM2 (+) (gets pc) (fromIntegral <$> fetch))
09:45:15 <hallongrottan> well yes rwbarton that works, but its hardly readable
09:45:26 <Apocalisp> Pegazus: a thing that takes a 2 dimensional space to a 3-dimensional space; "Extend"
09:46:02 <rwbarton> Pegazus: or "embedding"
09:46:02 <quicksilver> bcc <$> (gets pc <^( + )^> (fromIntegral <$> fetch))
09:46:16 <gnuvince> :info (<$>)
09:46:23 <gnuvince> :t (<$>)
09:46:24 <hallongrottan> lol
09:46:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:46:28 * quicksilver wins points for use of the 'BEND OVER' combinator.
09:47:06 <michaelcdever> ???
09:47:17 <MyCatVerbs> quicksilver: what in the name of goatse are you up to?
09:47:38 <MyCatVerbs> quicksilver: what on Earth did you bind <^ and ^> to?
09:47:42 <Apocalisp> @hoogle (a -> b -> c) -> (d -> c) -> (a -> b -> d -> c)
09:47:43 <lambdabot> No results found
09:47:54 <quicksilver> MyCatVerbs: InfixApplicative from hackage
09:48:00 <Apocalisp> @djinn (a -> b -> c) -> (d -> c) -> (a -> b -> d -> c)
09:48:00 <lambdabot> f a _ b c _ = a b c
09:48:13 <quicksilver> http://hackage.haskell.org/packages/archive/InfixApplicative/1.0.1/doc/html/Control-Applicative-Infix.html
09:48:37 <MyCatVerbs> quicksilver: I think you win... something. Not necessarily the internet, but something big.
09:48:49 <quicksilver> bigger than the internet?
09:48:52 <MyCatVerbs> quicksilver: and red, and round, and hollow, and with a wedding ring next to it.
09:48:52 <quicksilver> a doughnut!
09:55:12 <Apocalisp> @type flip $ flip . (,,)
09:55:15 <lambdabot> forall a a1 b. b -> a -> a1 -> (a, a1, b)
09:57:44 * cytzol dances the all-my-types-check dance
09:58:04 <walski> hi
09:58:16 <drhodes> can -threaded run eight threads on intel's quad core i7?
09:58:51 <jganetsk> hey does ghc have a parallel garbage collector?
09:58:58 <walski> Can somebody tell me how the "->" and "=>" in a method declaration is called correctly? Is there any page where all the "correct names" for haskells keywords/keysymbols are listed?
09:59:19 <rwbarton> jganetsk: yes, as of GHC 6.10.1
09:59:24 <pumpkin> drhodes: it just runs as many threads as you ask it to, with +RTS -N8
09:59:56 * Axman6 would use -N9
09:59:56 <fookal> help -> on a debian machine using ghc6 -> "Not in scope: stripPrefix"
10:00:17 <Axman6> fookal: is stripPrefix in scope?
10:00:25 <pumpkin> on thing I actually found (may be a bug) was doing -N8 on my quad core machine caused 400% cpu usage but the program was doing almost nothing
10:00:41 <fookal> Axman6: yes
10:00:41 <drhodes> pumpkin: I remember reading that it doesn't utilize hyperthreading, not sure if the new architecture changes anythings from the P4 regarding hyperthreading.
10:00:55 <Axman6> fookal: you sure?
10:01:15 <fookal> it's compiling smoothly on my ubuntu system
10:01:20 <Axman6> drhodes: well, they're real cores, not hyperthreaded ones
10:01:21 <rwbarton> fookal: you have to import Data.List, and stripPrefix may have been added in ghc 6.8
10:02:00 <drhodes> Axman6: the core i7 have 4 cores, but runs 8 threads.
10:02:09 <Axman6> ah, i see, nice :)
10:02:37 <pumpkin> drhodes: isn't that handled on the OS level though?
10:02:40 <fookal> rwbarton: it's a ghc6.6 installation :-/
10:02:55 <pumpkin> if you were writing a pthread-based program, would you need to do something special to use the hyperthreading?
10:03:04 <jpcooper> how can I do output on a command-line application without having the output affect what is being input?
10:03:13 <drhodes> pumpkin: I think it's lower lever because there's an option in the BIOS to turn it off.
10:03:40 <beelsebob> pumpkin: the CPU presents itself as 8-core to the OS
10:03:46 <beelsebob> even though there's only 4 physical ones
10:03:47 <pumpkin> then there's no issue
10:03:51 <pumpkin> right?
10:03:58 <pumpkin> +RTS -N8 will do what you want
10:04:17 <beelsebob> I would imagine so, but -N9
10:04:52 <Axman6> i haven't actially found a good example of using the parallelism in haskell to speed things up
10:04:55 <rwbarton> fookal: then it's probably too old for lots of stuff.  you might want to upgrade to debian testing, or install ghc manually
10:05:09 <pumpkin> Axman6: find a good paralellizable algorithm and implement it in haskell :)
10:05:22 <beelsebob> Axman6: try ray tracing as a good example
10:05:32 <rwbarton> fookal: or of course you can steal the stripPrefix source from here: http://haskell.org/ghc/docs/6.8.2/html/libraries/base/src/Data-List.html#stripPrefix
10:05:41 <fookal> rwbarton: urgh ... so I have to add the debian testing apt repo and update ghc?
10:06:00 <pumpkin> fookal: or just include the code in your own source :P
10:06:06 <fookal> sounds good
10:06:07 <Axman6> fookal: just checking, but you know that 6.6 is really old right?
10:06:07 <rwbarton> fookal: yes, and it will quite likely pull in lots of other upgrades
10:06:16 <pumpkin> Axman6: tell the debian people
10:06:28 <pumpkin> actually they just released a new one yesterday, so maybe it has 6.10 now
10:06:41 <rwbarton> oh yeah! hmm.
10:06:47 <Axman6> well, i wasn't saying it was his fault he was using 6.6, just saying that it is infact very old
10:06:54 <fookal> I'm fine with adding the code, if this is the only modification
10:06:54 <bremner> ghc6.10 is in debian experimental
10:07:04 <rwbarton> fookal: lenny (which is now stable) has 6.8.2
10:07:23 <Axman6> "22 months of solid development"
10:07:25 <pumpkin> wow, they just released it
10:07:31 <pumpkin> couldn't they have put 6.10.1 in?
10:07:33 <fookal> don't want to upgrade my vserv to lenny :-/
10:07:33 <bremner> is there some kind of web sandbox for playing with ghci?
10:07:34 <mightybyte> What's the standard haskell approach for dealing with duplicated accessor function names for data types?  Separate the types into different modules, or use a naming convention to disambiguate?
10:07:56 <bremner> pumpkin: well, nobody did the work
10:07:59 <pumpkin> mightybyte: naming convention, unfortunately
10:08:02 <mightybyte> ...or just general function names
10:08:14 <pumpkin> mightybyte: you mean for record syntax?
10:08:27 <rwbarton> mightybyte: Either one.
10:08:28 <pumpkin> mightybyte: if you want to write "accessors" yourself you can make typeclasses for them
10:08:37 <mightybyte> That's the specific situation I have in mind, but it could generally apply to all function names.
10:09:19 <rwbarton> fookal: If you want to run something older than Debian stable, don't be surprised if you have to do some extra work to run modern software :)
10:09:21 <michaelcdever> anyone know of a guide for installing gtk2hs on ubuntu
10:09:24 <Peaker> Why is linking haddock so heavy? Its thrashing for a long while now
10:09:41 <Axman6> Peaker: i think i remember that being a bug
10:09:46 <mightybyte> I have a 90 line file with several data types that have the potential to use similar names.
10:09:48 <rwbarton> Hey, maybe this means SPOJ will be updated
10:09:52 <dcoutts_> michaelcdever: just build it from source in the standard, documented way. There's nothing special about Ubuntu in this context.
10:10:07 <Cheshire> mightybyte do you know GADTs?
10:10:15 <michaelcdever> ah ok, no handy package like fedora :D
10:10:16 <pumpkin> does anyone here have an idea of what it would take to make an iphone ghc btw? we have ARM output and mach-o output, but nothing that uses them together right now...
10:10:16 <mightybyte> I've heard the term.
10:10:30 <bremner> pumpkin: I think someone already ported it
10:10:33 <pumpkin> bremner: no
10:10:34 <Axman6> there's nothing special about ubuntu, except in the retarded sense...
10:10:34 <mightybyte> Cheshire: But I don't know how they would apply to this question.
10:10:35 <Axman6> >_>
10:10:42 <pumpkin> bremner: there's hugs on it
10:10:44 <Cheshire> mightybyte, if you have  data Polarity = Odd | Even and Personality = Normal | Odd e.g.
10:10:47 <pumpkin> which is easy
10:10:54 <michaelcdever> heh
10:11:10 <Cheshire> mightybyte, you might redefine it as  data Polarity ; data Personality -- zero constructor types are used as symbols
10:11:12 <bremner> well, cross compilation should be possible?
10:11:25 <pumpkin> bremner: I agree, but it isn't right now :P
10:11:47 <Cheshire> mightbyte, data U t where Even :: U Polarity ; Odd :: U a ; Normal :: U Personality
10:11:49 <mightybyte> Cheshire: Interesting
10:12:07 <dcoutts_> michaelcdever: there are debian packages for an older release.
10:12:33 <Cheshire> here a can be any type with kind * though, instead of just one of these two
10:12:39 <michaelcdever> i tried installing one of those before, but i got dependancy errors
10:13:07 <michaelcdever> i might build a package for ubuntu, if i get it to install properly
10:13:20 <Cheshire> (this is one place where types dependening on values would give you more expressivity ...)
10:13:34 <Cheshire> expressiveness*
10:14:34 <bremner> michaelcdever: are you sure no package on ubuntu? apt-cache search gtk2hs returns a mess of results
10:14:53 <bremner> oh, I see you want the latest. nvm
10:14:55 * mightybyte mulls it over
10:23:19 <ksf> someone pass me a frame, I finally grokked monads.
10:23:53 <ksf> (for the, say, tenth time, but this time for real)
10:24:08 <SamB_irssi> ksf: what the heck?
10:24:22 <loadquo_> ksf, can you write liftM2 in terms of fmap and ap?
10:24:36 <ksf> they should be explained in terms of applicative.
10:24:45 <ksf> anything else is lies for kids.
10:24:54 <ski_> `liftA',`(<*>)'
10:24:57 <SamB_irssi> oh come on
10:25:06 <SamB_irssi> I don't know Applicative and I get monads!
10:26:13 <ksf> the path is Pointed -> Functor -> Applicative -> Monad, and I'm going to celebrate it with a beer and some code.
10:26:27 <Axman6> beelsebob: i still would like you to write a post about where applicative should be used instead of monad (with plenty of examples if possible)
10:26:41 <Cheshire> @instances Pointed
10:26:42 <lambdabot> Couldn't find class `Pointed'. Try @instances-importing
10:26:46 * SamB_irssi doesn't remember Functor being a subclass of Pointed -- thought they were independant
10:26:51 <Cheshire> @hoogle Pointed
10:26:52 <lambdabot> No results found
10:27:16 <ksf> pointed is pure, functor adds fmap, applicative <*>, and monad >>=
10:27:26 <ksf> where return == pure
10:27:31 <SamB_irssi> um
10:27:34 <Cheshire> :t pure
10:27:34 <ksf> (which is a much better name, anyway)
10:27:35 <SamB_irssi> functor doesn't have pure
10:27:35 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:27:36 <rwbarton> but functor doesn't have pure
10:27:48 <rwbarton> if anything it should be functor -> pointed -> applicative -> ...
10:27:53 <Cheshire> whhat's the use of pure on it's own?
10:28:01 <ksf> they don't?
10:28:08 <SamB_irssi> Cheshire: use ?
10:28:09 <rwbarton> @src Functor
10:28:09 <lambdabot> class  Functor f  where
10:28:09 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
10:28:31 <ksf> then how do you get a singleton functor?
10:28:40 <SamB_irssi> ksf: what's that ?
10:28:44 <idnar> a what?
10:28:52 <ksf> injection predates selection.
10:29:08 <ksf> > pure 1 ::[Int]
10:29:09 <lambdabot>       Ambiguous occurrence `pure'
10:29:09 <lambdabot>      It could refer to either `Control.Appl...
10:29:21 <ksf> > Control.Applicative.pure 1 ::[Int]
10:29:22 <lambdabot>   [1]
10:29:22 <Vq^> ksf: sounds like you want a n applicative functor
10:29:29 <dancor> functor and pointed separately -> applicative right
10:29:33 <idnar> how about having functor and pointed separate
10:29:35 <dancor> anyway pointed is worthless
10:29:37 <idnar> heh.
10:29:39 <pumpkin> @instances Functor
10:29:39 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:30:06 <ksf> fmap without a function to get something into a functor doesn't make any sense.
10:30:19 <ksf> ...and pure is exactly that.
10:30:22 <pumpkin> @instances Applicative
10:30:23 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:30:30 <rwbarton> ksf: fmap on ((,) w) doesn't make any sense?
10:31:06 <SamB_irssi> @instances Applicative
10:31:06 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:31:11 <pumpkin> @instances-importing Control.Applicative Applicative
10:31:11 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
10:31:15 <ksf> well, pure x = (undefined, x)
10:31:18 <ksf> uhhhmmm...
10:31:23 <Vq^> ksf: i could agree that pure/return/arr should get moved to a single typeclass
10:31:24 * SamB_irssi was trying to do that but accidentally pasted the newline
10:31:39 <SamB_irssi> Vq^: but they have different types?
10:31:50 <SamB_irssi> at least, arr and pure/return
10:32:17 <Axman6> :r ((,) 1)
10:32:20 <Axman6> :t ((,) 1)
10:32:20 <ksf> tuples need one functor instance for every tuple to map over, anyway.
10:32:21 <lambdabot> forall t b. (Num t) => b -> (t, b)
10:32:27 <Vq^> SamB_irssi: my mistake, forget arr
10:32:34 <ksf> s/tuple/element
10:32:53 <ksf> I don't like fmap being rightmost-only.
10:33:10 <SamB_irssi> ksf: it can't help it
10:33:13 <pumpkin> it has to be
10:33:17 <ksf> I know, typing.
10:33:26 <rwbarton> ksf: it's regrettable (kind of) that (,a) is not a functor but surely that doesn't stop (a,) from being one?
10:33:33 <Cheshire> Hi does anyone have some examples of generating HOAS code?
10:33:52 <ksf> If lists had and infinite type with many, many, a's, things would look different.
10:34:01 <Cheshire> do you usually create a first order representation and reify it ? or build HOAS directly
10:34:09 <Cheshire> (or other approaches..?)
10:34:25 <SamB_irssi> it'd be nice if you could somehow create a class that somehow used type-level arithmatic to allow functors on arbitrary type arguments ...
10:34:30 <ksf> rwbarton, I don't mind it being a functor, but in real life, I always want to map over the wrong element of tuples.
10:34:59 <ksf> the current scheme is... murphy-agnostic.
10:35:10 <rwbarton> ksf: if you set pure x = (undefined, x) then you can't write the Monoid w => Monad ((,) w) instance
10:35:27 <Cheshire> rwbarton, I would like to add a type level lambda and see how much it screws up the language
10:35:33 <Cheshire> it might be fine you know ?
10:35:38 <rwbarton> ksf: the proper thing to do is PointedType w => Pointed ((,) w)
10:35:49 <rwbarton> ksf: but ((,) w) is a functor regardless of any structure on w
10:36:01 <ksf> what about foo :: ((a,b) -> (a,b)) -> (b,a) -> (b,a) ?
10:36:15 <Cheshire> ksf, "foo"?
10:36:31 <ksf> "withMangledTuple"?
10:36:31 <Cheshire> nobody uses HOAS I guess..
10:36:57 <rwbarton> Cheshire: I hope you enjoy telling the compiler exactly how to unify types :)
10:37:11 <ksf> ...there should be c's and d's in that type.
10:37:20 <Cheshire> rwbarton, I am curious to what extend that inference would still wor
10:37:22 <Cheshire> work
10:37:44 * bremner goes for coffee while darcs downloads yhc
10:38:19 <ksf> let's just all write or own preludes and determine the winner with http://corewar.co.uk/
10:38:23 <rwbarton> Cheshire: suppose I compose a function a -> b and a function m c -> d
10:38:35 <rwbarton> Cheshire: all I can infer is m is some type-level function such that m c is b
10:38:52 <Cheshire> well you have  m c = b  ok
10:39:01 <Deewiant> ksf: what, the prelude which is the most powerful haskell-redcode polyglot is the best? :-P
10:39:14 <Cheshire> rwbarton, do these functions have definitions?
10:39:17 <rwbarton> Cheshire: Maybe this isn't as much of a problem as I'm imagining
10:39:49 <Cheshire> rwbarton, It's really really hard to guess this - on the other it's completely non-obvious how to prototype it ..
10:39:59 <rwbarton> especially if you don't try to have type classes
10:40:57 <ski_> (forall a. Maybe (f a)) -> Maybe (forall a. f a)
10:41:22 <Cheshire> ski_, m I think that is uninhabited (other than trivially)
10:41:40 <Cheshire> for the same reason as (a -> Maybe b) -> Maybe (a -> b)
10:41:49 <ski_> but should it be implementable ?
10:42:04 <ski_> (because of parametricity, i.e.)
10:42:37 <ski_> (s/should it/ought it to/ ..)
10:42:43 <Cheshire> @free test :: (forall a. Maybe (f a)) -> Maybe (forall a. f a)
10:42:44 <lambdabot> Plugin `free' failed with: /tmp/ghc25834_0/ghc25834_64.hspp:(152,16)-(160,44): Non-exhaustive patterns in case
10:42:58 <rwbarton> Cheshire: e.g., you won't be able to use the Functor type class, since you can never infer what f is in a use of fmap
10:42:58 <Deewiant> @djinn (a -> Maybe b) -> Maybe (a -> b)
10:42:59 <lambdabot> f _ = Nothing
10:43:15 <jauaor> hello
10:43:16 <jauaor> :)
10:43:19 <rwbarton> Cheshire: but not having type classes isn't the end of the world or anything
10:43:20 <Cheshire> rwbarton, why don't you just leave it as  Functor f => ... ?
10:43:35 <ski_> Deewiant : well, it should be the inverse of `Maybe (a -> b) -> (a -> Maybe b)', too
10:43:36 <rwbarton> Cheshire: you need some kind of explicit type application
10:43:45 <rwbarton> Cheshire: in which case maybe you should do the dictionary passing yourself
10:43:46 <Cheshire> rwbarton, anyway I wanted to prototype it but I don't know how to do e.g. implicit polymorphism in lambda prolog
10:43:59 <lilac> Haskell can not has epic fail, a proof: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1490
10:44:59 <rwbarton> lilac: haha
10:45:42 <michaelcdever> bremner i didnt know about apt-cach well i'm looking for gtk2hs 0.9.13
10:46:03 <rwbarton> lilac: but didn't you actually prove Haskell can has epic fail?
10:46:03 <lilac> rwbarton: i particularly like how both EpicFailMonad types are such epic failures as monads :)
10:46:33 <lilac> rwbarton: "Haskell can not has non-trivial epic fail" just isn't as punchy
10:47:02 <pumpkin> lilac: lol
10:47:06 <lilac> maybe Haskell can has epic fail, but only if you too can has epic fail
10:47:46 <lilac> Haskell can has epic fail kthxbye
10:48:15 <pumpkin> newtype EpicFailMonad' = EpicFailMonad' EpicFailMonad'
10:48:16 <lilac> yo dawg i herd you like epic fail so i put a newtype in your newtype... ?
10:48:21 <pumpkin> o.O
10:48:32 <redditbot> How To Not Teach Programming (Haskell)
10:48:34 <lilac> pumpkin: as far as i'm aware, that's the only way to make a type with no bottom :)
10:48:54 <pumpkin> lilac: how about a type with no top? :o
10:49:07 <lilac> isn't that 'data EpicFailMonad'
10:49:09 <lilac> ?
10:49:13 <roconnor> Is a pointed functor a functor with a function (a -> f a) or one with a function (f a -> a) ?
10:49:16 <augustss_> that's can't be a monad, it's a kind error.  what an epic fail
10:49:26 <monochrom> haha
10:49:39 <lilac> roconnor: Applicative => Pointed
10:49:40 <pumpkin> lilac can haz epic fail?
10:49:41 <lament> what does it take for redditbot to announce an article?
10:49:54 <pumpkin> for it to appear on the haskell reddit?
10:49:58 <lilac> pumpkin: lilac can haz epic epic fail fail
10:50:01 <jkff> Hi. I am again doing some microbenchmarks and cant get a wordcount program in haskell to outperform awk: the program is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1491#a1491 . Is there any faster way to store a map from bytestrings to ints? I, ehm, "tried" bytestring-trie, but it is even twice slower than Data.Map here.
10:50:02 <roconnor> lilac: so a "pointed list" is really a copointed list?
10:50:04 <pumpkin> onoes
10:50:05 <ksf> roconnor, the latter is CoPointed.
10:50:15 <ksf> ...also know as "runXXX"
10:50:19 <lilac> roconnor: "a -> f a" is Pointed
10:50:38 <CTA> is string an alais for [char] ?
10:50:52 <roconnor> so ([a],a,[a]) should be called a copointed list?
10:50:53 <jkff> And the awk is: awk -F\  '{for(i=1; i<NF; i++){a[$i]++}} END{for(w in a) printf "%s\t%d\n", w, a[w]}' |sort -n -k2
10:50:56 <lilac> CTA: no, but String is an alias for [Char] :-)
10:51:05 <lilac> @src String
10:51:05 <lambdabot> type String = [Char]
10:51:11 <pumpkin> jkff: so it's an individual word count program?
10:51:18 <jkff> Yes, it counts word frequencies
10:51:24 <jkff> And awk works 3x faster
10:51:38 <pumpkin> you're compiling with -O2?
10:51:46 <jkff> Yes
10:51:49 <lilac> roconnor: hmm. i'd say that type is a pointed list, which happens to also be a copointed functor :)
10:51:57 <roconnor> lilac: heh, okay
10:52:02 <roconnor> very confusing
10:52:14 <roconnor> I fear my hard drive will die soon
10:52:15 <lilac> roconnor: i'd only say that to confuse you, though :)
10:52:19 <Eridius> arg articles about Haskell are so hard to read without a solid grounding in mathematical theory :/
10:52:19 <roconnor> maybe I should make a backup
10:52:29 <pumpkin> jkff: sortBy?
10:52:37 <jkff> pumpkin: the program even runs in 80kb max residency (I fed it a text that has not so many unique words)
10:52:41 <pumpkin> oh I guess that's just to present it
10:52:42 <lilac> roconnor: follow the haskell creed: be lazy, make a backup only when you find you've lost your data
10:52:46 <jkff> Profiling shows that frequencies is the bottleneck
10:52:47 <ski_> (Eridius : like ?)
10:52:48 <jkff> 75% of the time
10:52:50 <Cale> Eridius: Probably depends on which articles you're trying to read :P
10:52:51 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:53:07 <Eridius> like the link above about epic fail. I had to look up what epimorphism was. And the wikipedia article just left me even more confused :/
10:53:12 <Cale> lambdabot: @join #haskell-in-depth
10:53:19 <Eridius> I'm still not sure what a plain old morphism is
10:53:31 <pumpkin> jkff: you sure you were using bytestring-trie correctly?
10:53:57 <Lemmih> @seen dcoutts
10:53:57 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 8h 56m 17s ago.
10:53:58 <Cale> Eridius: Well, it wouldn't be funny if it didn't use terminology :)
10:54:03 <Lemmih> @seen dcoutts_
10:54:03 <lambdabot> dcoutts_ is in #ghc and #haskell. I last heard dcoutts_ speak 41m 56s ago.
10:54:05 <jkff> Well.. I think so :) What are the possible ways of using it incorrectly?
10:54:09 <Eridius> I love that Haskell teaches me some mathematical theory, but I hate how frequently I end up saying "I just can't even understand this" and trying to look up what I'm confused about just uses more terminology I don't understand
10:54:25 <beelsebob> http://use.perl.org/~Ovid/journal/38501?from=rss <-- this guy's actually making a really good point
10:54:27 <pumpkin> jkff: I dunno, it seems strange for it to be slower than a regular Map
10:54:46 <dcoutts_> hia Lemmih
10:54:51 * ksf thinks h' should _drastically_ clean up that typeclass mess.
10:54:52 <monochrom> The learning curve is a logistic curve.
10:54:59 <jkff> The only suitable method to increase frequency for a word is to use 'adjust', I fed it the strict (+) to avoid leaks, and it worked 2x slower
10:54:59 <Cheshire> Eridius, I am upset when I don't have anything interesting just around the corner to study
10:55:12 <jkff> Oh. I mean, alterBy
10:55:28 <Cale> Eridius: The joke is that epimorphisms are referred to as 'epic'
10:55:29 <Eridius> Cheshire: I don't mind studying as long as I can end up understanding something
10:55:33 <dcoutts_> Lemmih: I'll be back in a minute, just getting some tea :-)
10:55:36 <Eridius> but it's when the study itself just leaves me confused that I get annoyed
10:55:55 <jkff> Probably trie is not that fast because the words are rather short and Map copes with them well
10:55:55 <Cale> Eridius: If you'd like, I can explain what a category is, which would probably help...
10:55:59 <Eridius> Cale: I got that much, but I still don't know what a morphism is
10:56:15 <nominolo> @src foldrM
10:56:16 <lambdabot> Source not found. Maybe if you used more than just two fingers...
10:56:22 <nominolo> @src Data.Foldable.foldrM
10:56:22 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:56:27 <Cale> Eridius: morphism is more or less another word for function, with the implication that it's structure preserving in some way.
10:57:02 <Eridius> you mean it's like a -> a?
10:57:12 <pumpkin> jkff: yeah, the api on trie looks a little sparse for now :/
10:57:31 <Cale> Not necessarily... it might be between two different things.
10:57:32 <pumpkin> a fromListWith would be helpful I think
10:57:49 <jkff> By the way, it's sad that Data.Map does not have a fromListWith'
10:57:49 <dmwit> Eridius: Usually, Hask is the category where types are objects and morphisms are functions between types.
10:58:00 <dmwit> Eridius: So "id" is a morphism between the objects "a" and "a".
10:58:02 <dcoutts_> Lemmih: btw, I'll almost certainly be at your London HUG talk
10:58:19 <roconnor> dmwit: ignoring seq
10:58:22 <pumpkin> jkff: ' functions aren't in h98 I think
10:58:27 <roconnor> which ought to be ignored
10:58:30 <dmwit> roconnor: *nod*
10:58:33 <gueux> hi :-)
10:58:36 <dmwit> roconnor: ignoring "undefined", too, I guess
10:58:45 <ksf> ...and polymorphism.
10:58:54 <Eridius> dmwit: so what's the "structure-preserving" part?
10:58:55 <ski_> lo gueux
10:59:05 <Cale> Eridius: Well, in this case, it's not much.
10:59:29 <ski_> Eridius : continuity/computability
10:59:30 <Cale> Eridius: I suppose there's a condition dealing with computability.
10:59:32 <dmwit> Eridius: There is no requirement that morphisms preserve structure in general.
10:59:37 <jkff> pumpkin: But it has insertWith'
10:59:46 <dmwit> Eridius: In most categories, the morphisms happen to preserve some structure.
10:59:53 <ksf> functors preserve structure.
10:59:55 <ski_> (Homotopy is not concrete !)
10:59:59 <gueux> I defined a class "Board a", now I'd like that class to derive from Show a. I mean: to instanciate a Board a,  the user has to give a definition for show... I've done a "class Show a => Board a where ... show::a->String"
10:59:59 <Eridius> the wikipedia page on morphisms said they did, not "usually" did
11:00:02 <Cale> I usually prefer the term 'arrow' but it doesn't help the joke here.
11:00:15 <Cale> Eridius: Okay, do you happen to know what a vector space is?
11:00:27 <ksf> gueux, instance Show Board where show =
11:00:30 <Eridius> Cale: probably, but I've forgotten. It's been a while since I did anything with math
11:00:30 <gueux> and then I try to instanciate SquareBoard as the Board
11:00:47 <gueux> ksf: ok
11:00:48 <lilac> Applicative functors seem to fall into two categories: those that are Monads, and those where <*> takes the 'intersection' of the 'structures' of the function and argument (whatever that means). Does anyone know of any counterexamples to this?
11:01:05 <Cale> Eridius: Okay, I'm just trying to figure out what sort of example I should give :)
11:01:13 <dmwit> ksf: instance Show a => Show (Board a) where show = ...
11:01:16 <ksf> don't use unecessary inheritance, it's evil.
11:01:26 <Eridius> hehe
11:01:42 <dmwit> gueux: But, it's probably easier to just put "deriving Show" at the end of your data definition for Board. ;-)
11:01:44 <Cale> Eridius: "morphism" means something different in different contexts.
11:02:01 <lilac> (that is, Applicatives either have a join over the structure or an intersection over the structure)
11:02:04 <Cale> Eridius: So, exactly what structure is preserved is up to the context.
11:02:22 <Eridius> heh
11:02:35 <dmwit> Eridius: A monoid is a set with a 0 and a + operation.
11:02:45 <dmwit> Eridius: That's all we require of the set, ok?
11:02:49 <gueux> hum
11:03:00 <lilac> dmwit: we require that + be associative
11:03:02 <Cale> Eridius: A monoid is a set M together with a binary operation which is associative and has an identity. That is, if a,b,c are any elements of M, we have that (a*b)*c = a*(b*c) and there's an element 1 in M so that 1*a = a*1 = a
11:03:02 <gueux> and then I have an error: Class `Board' used as a type
11:03:06 <ksf> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1435#a1435 <-- this is how it should be.
11:03:14 <lilac> dmwit: and that 0 be an identity for +
11:03:15 <dmwit> lilac: Yes, yes.
11:03:16 <Cale> oh, it seems dmwit had the same idea :P
11:03:19 <dmwit> lilac: I know.
11:03:28 <Eridius> I know about Monoids in Haskell, but I don't know about any math concepts behind them
11:03:36 <dmwit> lilac: I was hoping to gloss over these things in favor of abusing the notation to imply those properties.
11:03:44 <Cale> Eridius: a monoid morphism is a function f: M -> N such that f(a*b) = f(a) * f(b)
11:03:45 <Eridius> although I'm unsure of your usage of the terminology "Set" here
11:03:46 <dmwit> Anyway, I'll leave it to Cale, he's much more patient than me. =)
11:03:49 <lilac> dmwit: sorry for ruining your example :)
11:03:49 <ksf> ("coPure" being a synonym for "hackishlyAccess")
11:03:49 <Cale> and so that f(1) = 1
11:04:04 <Cale> (where the first 1 is the 1 in M and the second is the 1 in N)
11:04:18 <dmwit> Eridius: It's the usual meaning of set.  Nothing to do with Haskell.
11:04:26 <lilac> type Copure = forall a. IO a
11:04:47 <Eridius> dmwit: my usual definition of "set" is "unordered collection of unique objects"
11:04:51 <Cale> As an example of such a thing, we have that lists of characters form a monoid under concatenation (with the empty string being the identity element)
11:04:52 <dmwit> Eridius: correct
11:04:56 <Cheshire> there is a problem for matrices A B in Rn*Rm,  f(AB) = f(A)f(B)  f bijection => m = n
11:05:22 <Cheshire> although it tursn out totally different to the f(1) = 1 thing
11:05:35 <Cale> Note that (xs ++ ys) ++ zs = xs ++ (ys ++ zs)
11:05:39 <Eridius> oh so in this case a set might be "all objects of type Foo"
11:05:44 <Cale> and that "" ++ xs = xs ++ "" = xs
11:05:48 <ski_> @check \xs -> [] ++ xs == (xs :: [Int])
11:05:48 <Cale> yes
11:05:49 <lambdabot>   "OK, passed 500 tests."
11:05:49 <lilac> for all f, concatMap f is a monoid morphism
11:05:57 <ski_> @check \xs -> xs ++ [] == (xs :: [Int])
11:05:58 <lambdabot>   "OK, passed 500 tests."
11:06:15 <Cale> Eridius: Another example of a monoid is the natural numbers under addition, with 0 being the identity element
11:06:19 <ski_> @check \xs ys zs -> (xs ++ ys) ++ zs == (xs :: [Int]) ++ (ys ++ zs)
11:06:20 <lambdabot>   "OK, passed 500 tests."
11:06:23 <ksf> actually, the only reason pointed is a superclass of applicative is the fefinition of <$>, which needs pure to be defined in terms of <*>.
11:06:34 <Eridius> there really should be a "mathematical terminology useful in Haskell for Dummies"
11:06:41 <Cale> and an example of a monoid homomorphism between the two is the function which gives the length of the string
11:06:51 <dmwit> Eridius: Check out the Typeclassopedia!  Just launched like a day or two ago...
11:06:53 <Eridius> homomorphism?
11:06:53 <ksf> ...which makes it appear somewhere in its laws.
11:07:03 <dmwit> Eridius: morphism
11:07:03 <Cale> Eridius: morphism is short for homomorphism
11:07:11 <Eridius> ah
11:07:14 <dmwit> Eridius: It's just tiring to type "homo" all the time. ;-)
11:07:17 <Eridius> hehe
11:07:29 <Eridius> I assume the "homo" prefix refers to the structure-preserving nature?
11:07:36 <dmwit> right
11:07:38 <Cale> That's because  length (xs ++ ys) = length xs + length ys
11:07:47 <lilac> Eridius: there is a more general notion of 'morphism' which is not important right now
11:07:52 * ski_ thought `homomorphims' was used when the morphisms in question actually did preserve some structure
11:07:53 <Eridius> ok
11:08:07 <chessguy_work> weird, i thought homomorphisms were a particular kind of morphism
11:08:09 <dmwit> lilac: Yeah, I think that's what we're building up to.
11:08:14 <chessguy_work> yeah, what ski_ said
11:08:14 <Cale> So it turns the operation in one monoid, concatenation, into the operation in the other, addition.
11:08:23 <lilac> dmwit: are we teaching category theory here then? :)
11:08:26 * dmwit nods
11:08:49 <Cale> Some more examples...
11:08:51 <dmwit> lilac: Isn't this fun? =D
11:09:01 <ksf> the problem isn't missing material, but brokeage in the typeclass hierarchy.
11:09:12 <Cale> We have a monoid of real numbers under multiplication, with 1 as the identity
11:09:15 <lilac> dmwit: hold on... having read the scrollback it looks like we're trying to explain the 'epic fail' joke?
11:09:19 <ksf> thats' why the typeclassopedia is so cool, it doesn't even attempt to justify the mess.
11:09:22 <Cale> and a monoid of real numbers under addition, with 0 as the identity
11:09:26 <chessguy_work> @tell mmorrow i think you were the one i was talking to about continuations where the functions are more strongly reified? i think i'm getting the types close to where i like them: http://codepad.org/4pzL5Ecu
11:09:26 <lambdabot> Consider it noted.
11:09:57 <Cale> The logarithm is a homomorphism between these two, since log(ab) = log(a) + log(b), and log(1) = 0
11:10:10 <dmwit> lilac: Oh, I didn't even see that joke.  Time to scroll back...
11:10:11 <Eridius> huh
11:10:20 <Eridius> ok so what's an epimorphism?
11:10:24 <Cale> well, more correctly, it's only defined on the positive real numbers -- but they're a monoid under multiplication anyway
11:10:42 <chessguy_work> lilac, epoch fail?
11:11:02 <Cale> An epimorphism is a morphism which can be cancelled in equations on the right...
11:11:04 <lilac> chessguy_work: that has potential, but wasn't the joke :)
11:11:16 <chessguy_work> lilac, it's an xkcd joke :)
11:11:23 <Eridius> cancelled?
11:11:50 <Cale> That is, f is an epimorphism if whenever we have g . f = h . f
11:11:53 <Cale> then g = h
11:12:01 <dmwit> If h is an epimorphism, and g . f = h . f, then g = h.
11:12:03 <Cale> Where . is function composition
11:12:10 <dmwit> whoa
11:12:15 <dmwit> I actually got the direction right.
11:12:19 <lilac> Eridius: similarly to how we defined monoids, a 'category' is a set of objects, a set of 'arrows' between objects, and an operator '.' which takes two arrows to one
11:12:35 <lilac> Eridius: there are various rules (which aren't really important to the point)
11:12:36 <chessguy_work> lilac, http://xkcd.com/376/
11:12:49 <Eridius> arrows?
11:12:56 <dmwit> Eridius: morphisms
11:13:03 <ksf> like this : ->
11:13:03 <lilac> chessguy_work: nice :)
11:13:03 <Eridius> I know about first and second, but I don't know about arrows in general
11:13:12 <ksf> nah, not arrows.
11:13:18 <ksf> these: -> <-
11:13:22 <Cale> Okay, if we're going to introduce categories, perhaps we should do it properly.
11:13:25 <Cale> :)
11:13:29 <lilac> Eridius: 'arrows' is another name for 'morphisms'
11:13:40 <chessguy_work> and maybe it should be done in in-depth or -overflow :)
11:13:48 <ksf> "arrow" is another name for "a line with a hat on one side"
11:13:49 <Cale> A category C consists of the following bunch of data:
11:13:53 <chessguy_work> i mean, i don't care, it's just a suggestion
11:14:04 <Cale> * A collection of objects of C (these can be anything at all)
11:14:14 <lilac> Cale: yeah, sorry for saying 'set' ;-)
11:14:17 <Eridius> I should probably stop trying to do this while playing an fps...
11:14:28 <monochrom> Someone should record Cale's lectures and replay them periodically in #haskell-in-depth :)
11:14:37 <chessguy_work> +1
11:14:45 <Cale> * For any two objects A and B, a collection of morphisms, or arrows, often written Hom(A,B)
11:14:59 <Cale> If f is an arrow in Hom(A,B) we write f: A -> B
11:15:39 <monochrom> After Cale dies, "The Cale Lectures" will enjoy the same status as "The Feynman Lectures"!
11:15:45 <gueux> in fact, what I would like is: the user has to define a function show to define a Board and then, this function show overrides the function Prelude.show
11:15:45 <Cale> * An operation called composition which for any three objects A, B, C, takes an arrow f: A -> B, and an arrow g: B -> C, and gives an arrow g.f: A -> C
11:16:15 <lilac> monochrom: we're all dying in 2038 anyway, when all the code crashes. hopefully Cale will live that long :)
11:16:29 <Cale> Moreover, composition is required to be associative: f.(g.h) = (f.g).h whenever either is defined.
11:16:48 <ksf> this is the point where you know what a category is, note that it's quite trivial, and wonder why the rest isn't equally easily grokkable.
11:17:28 <monochrom> Don't grok, just play. Like Chess.
11:17:32 <Cale> And for each object A, there is an arrow, often called id_A: A -> A (or simply id, when it's obvious which object), such that id_A . f = f, and g . id_A = g for any f and g which will compose with it.
11:17:42 <lilac> gueux: do you want Board to be a type, or a type class?
11:17:44 <Cale> And that's it...
11:17:51 <chessguy_work> eh?
11:17:54 <gueux> lilac: a class
11:18:01 <Cale> Examples include the category whose objects are sets, and whose arrows are functions between those sets.
11:18:23 <ksf> note that because we have an id_A for every A, we don't need the objects, anymore.
11:18:25 <Cale> Or the category whose objects are Haskell types, and whose arrows/morphisms are the computable functions between those types.
11:18:32 <Cheshire> monochrom :)
11:18:35 <lilac> gueux: then 'class Show a => Board a where ... (Board stuff)...' should be fine
11:19:29 <Cale> Eridius: That definition is a mouthful, but hopefully it wasn't completely unclear :)
11:20:15 <lilac> Eridius: it might help to realise that mathematical sets and functions form a category, as do haskell types and functions
11:20:20 <Eridius> my brain hurts...
11:20:23 <lilac> and to look at some more exotic examples
11:20:26 <Cale> Eridius: Any monoid can also be treated as a category, with just one object, and where the elements of the monoid are the arrows from that object to itself.
11:21:01 <ksf> To come back to me grokking monads: I just realised that Iteratees can't only be Applicative Functors without crippling composability, that's all.
11:21:07 <gueux> but when I want to declare a function show, ghci says that it is already defined
11:21:12 <Cale> The objects of the category just serve to remind us which arrows can be composed and which can't.
11:21:23 <Cale> If all the arrows will compose with each other, then we have only one object.
11:21:32 <ksf> incidentely, the types of join and Enumerator look quite similar.
11:21:36 <lilac> Eridius: any ordered set can be treated as a category, with an arrow from a to b meaning 'a <= b'
11:22:22 <ksf> ...which actually make the Iteratee monad a CoEnumerator.
11:22:44 <Eridius> I'm still unclear on the definition of category, but my attention is split right now :/
11:23:03 <lilac> gueux: you need to say "instance Show SquareBoard where show = ..." rather than "instance Board SquareBoard where show = ..."
11:23:04 <hallongrottan> u
11:23:05 <jpcooper> how can I clear what has been written on a getline and also add to it?
11:23:06 <hallongrottan> oops
11:23:16 <lilac> gueux: and likewise, don't list 'show' as a member of class Board
11:23:24 <Cale> Eridius: Which FPS, btw?
11:23:32 <ksf> jpcooper, there's a readline package somewhere, ghci uses it.
11:23:39 <jpcooper> thanks ksf
11:23:40 <Eridius> Call of Duty: World at War
11:23:43 <Eridius> multiplayer
11:23:44 * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
11:23:46 <Cale> ksf: or it did, at one point.
11:23:47 <monochrom> Functional Programmer Shooter
11:23:51 <Cale> Heh.
11:23:52 <chessguy_work> haha
11:24:09 <ksf> ... "If in doubt, snarf some code."
11:24:12 <Cale> I'm more of a Q3A person...
11:24:14 <chessguy_work> @remember lilac * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
11:24:14 <lambdabot> Good to know.
11:24:35 <monochrom> It's very apt that "first-person shooting" and "frames per second" are both FPS. :)
11:24:48 <coco`> is there a cabal package for parsing command line arguments?
11:24:48 <Eridius> hehe
11:25:01 <jpcooper> ksf, do you know how to make file://localhost/home/justin/Dev/Haskell/Docs/libraries/editline/System-Console-Editline.html block until enter is pressed?
11:25:07 <jpcooper> or maybe I should look for something else
11:25:11 <dons> coco`: GetOpt is in the base lib
11:25:27 <dcoutts_> coco`: import System.Console.GetOpt
11:25:33 <Cale> Eridius: If you'd like some more help with it when you're free, just ping me :)
11:25:39 <coco`> thanks
11:25:41 <jpcooper> oh I think I've found what I need now actually
11:25:41 <Eridius> Cale: ok, thanks
11:25:46 <Cale> Eridius: I rather enjoy explaining this stuff, anyway :)
11:26:04 <MyCatVerbs> jpcooper: the commands in Makefiles get passed to your shell. You could put in "read x".
11:26:10 <Eridius> Cale: glad to hear it. I really want to understand better, I'm just struggling with the basic terminology
11:26:41 <chessguy_work> gueux, whatcha working on?
11:27:59 <Cale> Eridius: yeah... there's a little bit of a trouble with introductions to category theory at the moment, because up until quite recently, it was the sort of thing which was mostly limited to graduate students of pure mathematics and research mathematicians. One way to look at it is the game where the pieces you play with are the other branches of mathematics.
11:28:21 <Eridius> haha
11:28:25 * ksf |-|aX0Rz himself into jpcooper's box to help him with his code.
11:28:35 <Cale> So a lot of the introductory material will assume you already have at least a Bachelor's degree.
11:28:49 <jpcooper> ksf, I've found System.Console.Editline.Readline
11:28:52 <jpcooper> seems to be fine
11:29:03 <Cale> But since it's been found to be useful outside mathematics now, there's just starting to be some good resources.
11:29:35 <jpcooper> ksf, what I'd like to do is be able to output stuff and have the line stay at the bottom and not be affected by what is output
11:29:56 <ksf> uhh... I guess you're going to need a proper tty library for that.
11:30:01 <ksf> like vty or ncurses.
11:30:03 <jpcooper> right
11:30:15 <gueux> lilac: with "instance Show SquareBoard where show ..." I have an error:
11:30:26 <yrlnry> The Lawvere book is aimed at high school students, and it's pretty good.
11:30:31 <wli> Something I tried and failed at like everything else.
11:30:46 <gueux>     Kind error: `Show' is applied to too many type arguments
11:30:48 <gueux>     Kind error: `Show' is applied to too many type arguments
11:31:14 <gueux> chessguy_work: a little game
11:31:31 <Eridius> arg who the hell goes AFK for minutes at a time in a multiplayer console fps?
11:31:38 <chessguy_work> gueux, i guessed that much ;)
11:31:51 <eu-prleu-peupeu> hi
11:31:54 <eu-prleu-peupeu> 'sup ?
11:32:06 <gueux> I should ultimately provide a web interface to play
11:32:08 <gueux> :-)
11:32:33 <chessguy_work> what game is it?
11:32:36 <Eridius> is this the Typeclassopedia that was referenced? http://www.cis.upenn.edu/~byorgey/papers/typeclassopedia-draft-090216.pdf
11:32:40 <Eridius> Call of Duty: World at War
11:32:41 <gueux> the game is called crossway if you are interested
11:32:50 <gueux> by Mark Steere
11:32:52 <Eridius> in War mode, which means having 2 guys afk was a death sentence for our team
11:32:53 <mreh> what function should I use to round float to int?
11:33:27 <monochrom> Perhaps your team has a Rambo and he will do miracles. :)
11:33:34 <Eridius> naw, we lost
11:33:37 <loadquo> mreh: truncate?
11:33:38 <Eridius> but we did quite well for ourselves considering
11:33:49 <davidL> > round 2.5
11:33:50 <lambdabot>   2
11:33:55 <Eridius> > round -2.5
11:33:56 <lambdabot>       No instance for (Fractional (a -> b))
11:33:56 <lambdabot>        arising from the literal `...
11:33:57 <tromp> :t fmap fmap fmap
11:33:58 <chessguy_work> gueux, thanks. i'm a bit of a game-theorist-wannabe
11:33:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:34:00 <Eridius> oops
11:34:02 <Eridius> > round (-2.5)
11:34:03 <monochrom> "don't category-theorize and shoot"
11:34:03 <lambdabot>   -2
11:34:13 <loadquo> > truncate (-2.5)
11:34:15 <lambdabot>   -2
11:34:19 <gueux> but now I try to define what is a boardgame to simplify the future coding of other games
11:34:22 <tromp> :t fmap fmap fmap fmap
11:34:23 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
11:34:26 <mreh> 2.5 = 3
11:34:45 <tromp> :t fmap fmap fmap fmap fmap  fmap
11:34:46 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
11:34:46 <loadquo> > ceil (2.5)
11:34:47 <lambdabot>   Not in scope: `ceil'
11:35:08 <loadquo> @hoogle Float -> Int
11:35:09 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
11:35:09 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
11:35:09 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
11:35:12 <chessguy_work> gueux, looks interesting
11:35:34 <gueux> yesterday, I've coded the game
11:35:39 <gueux> so it works now
11:35:47 <tromp> :t wtf
11:35:48 <lambdabot> Not in scope: `wtf'
11:35:54 <loadquo> @type truncate
11:35:55 <gueux> I can play with a simple interface
11:35:55 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:36:20 <BONUS> > fmap fmap fmap (*2) [[1,2,3],[2,3,4]]
11:36:21 <lambdabot>   [[2,4,6],[4,6,8]]
11:36:26 <gueux> but now I have to code the server: I don't know what to use
11:36:30 <loadquo> @hoogle (Integral b, RealFrac a) => a -> b
11:36:30 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
11:36:31 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
11:36:31 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
11:36:35 <chessguy_work> gueux, is the theory of this game known? looks like the complexity of go, with simpler rules
11:36:41 <chessguy_work> (game-complexity)
11:36:47 <loadquo> > ceiling (2.5)
11:36:49 <lambdabot>   3
11:36:52 <gueux> I've understood :-)
11:36:59 <gueux> I'm not sure
11:37:00 <mreh> > ceiling 2.2
11:37:01 <lambdabot>   3
11:37:13 <mreh> i'll make my own rounding function i think
11:37:15 <Eridius> for those interested, Call of Duty: World at War is an exceptionally fun multiplayer game... as long as you have no lag. It has *horrible* lag mitigation
11:37:20 <Eridius> *multiplayer fps
11:37:20 <gueux> it seems to be difficult enough
11:37:33 <chessguy_work> gueux, certainly
11:37:37 <gueux> :-)
11:37:41 <chessguy_work> like a cross between go and connect-4
11:37:54 <gueux> after I would like to code a little ai
11:38:03 <chessguy_work> gueux, nice
11:38:18 <Pegazus> thanks you all for your help
11:38:31 <chessguy_work> gueux, i've been fiddling with representations for composable game-playing strategies
11:38:51 <RayNbow> http://haskell.org/haskellwiki/Haskell_programming_tips#Don.27t_overuse_lambdas <-- isn't sortKey in section 2.5 the same as GHC.Exts.sortWith?
11:39:18 <gueux> chessguy_work: great!
11:40:04 <chessguy_work> gueux, do you twitter?
11:40:34 <gueux> I don't know it
11:40:41 <chessguy_work> oh ok
11:40:45 <gueux> but I've heard that it was very good
11:40:54 <chessguy_work> it can be fun
11:40:59 <chessguy_work> i mostly mutter incoherently on there
11:41:15 <tromp> crossway is more of a cross between hex and go
11:41:36 <mathijs> I have a question about the way ghc compiles. When I define a function that acts on lists of any type, but all I ever use it for is for lists of Ints, will it still compile to some generic thingy, or optimize knowing it's just for Ints?
11:41:37 <chessguy_work> tromp, ah, thanks for the clarification. i'm sure i've heard of hex, but don't recall it off-hand
11:42:19 <tromp> actually, it's not much like go except for the board topology
11:42:53 <chessguy_work> sounds like a fair assessment
11:43:04 <tromp> it's hex on a square grid with a forbidden pattern to enforce a winner
11:43:11 <gueux> yes, it is very neer from hex
11:43:45 <gueux> there is another game on his webpage which is a generalized hex
11:43:49 <tromp> or more concisely, no-crosscut-hex
11:43:51 <gueux> atol
11:43:59 <gueux> or one of these
11:44:27 <loadquo> Can you think of games as tree constructors?
11:44:39 <Cheshire> no
11:44:51 <chessguy_work> a legal-move-generator is just an unfoldTree
11:45:04 <chessguy_work> if that's what you mean
11:45:13 <loadquo> Probably...
11:45:18 <conal> chessguy_work: hi
11:45:21 <chessguy_work> @type unfoldTre
11:45:22 <lambdabot> Not in scope: `unfoldTre'
11:45:24 <chessguy_work> hiya conal
11:45:28 <chessguy_work> @type unfoldTree
11:45:29 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
11:45:37 <conal> chessguy_work: how's tricks?
11:45:46 <chessguy_work> conal, not bad, not bad
11:46:08 <chessguy_work> conal, been working hard on simplifying the semantic domain for my latest idea
11:46:15 <conal> chessguy_work: sweet!
11:46:18 <chessguy_work> conal, i'd love to hear your thoughts: http://codepad.org/4pzL5Ecu
11:46:33 * conal looks
11:47:05 <conal> chessguy_work: btw, i'm writing a paper "Denotational design with type class morphisms"
11:47:20 <chessguy_work> sweet. sounds like fun
11:47:24 <pejo> conal, for icfp?
11:47:50 <conal> pejo: yeah.  i have a couple in the works, and hopefully a third.
11:48:07 <monochrom> Hahahah dons gets a fan letter on haskell reddit!
11:48:42 <conal> chessguy_work: is the semantic domain in that post?
11:48:57 <pejo> conal, wow, that's a lot.
11:49:00 <chessguy_work> conal, well, it's code
11:49:03 * Nafai reads the Typeclassopedia
11:49:23 <chessguy_work> conal, the semantic domain is still in my head :)
11:49:44 <pumpkin> > iterate (1:) []
11:49:45 <lambdabot>   [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[...
11:49:52 <conal> chessguy_work: oh, okay.  i like to code up the semantic domain and semantic function also, even if it has some non-implementable pieces.
11:50:20 <chessguy_work> conal, i think that would still be pretty hard for me to express
11:50:39 <conal> chessguy_work: then that's where to focus.  it'll inform everything else.
11:51:23 <conal> chessguy_work: and it's the first thing i always want to know when i look at code.
11:51:34 <chessguy_work> ok
11:51:38 * chessguy_work is duly chastened
11:52:05 <Eridius> hrm, Typeclassopedia prompts the following question
11:52:07 <chessguy_work> haskell code *is* pretty close to the semantic domain, though :)
11:52:07 <Eridius> @t ***
11:52:08 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:52:09 <conal> chessguy_work: oops.  i didn't mean it to come out that way at all.  what i meant to say is that's where my curiosity goes.
11:52:11 <Eridius> @type ***
11:52:12 <lambdabot> parse error on input `***'
11:52:15 <Eridius> hrm...
11:52:17 <jganetsk> pumpkin, strange, i was looking at exactly that
11:52:23 <pumpkin> :)
11:52:25 <jganetsk> in haskell programming tips
11:52:25 <paper_cc> @type (***)
11:52:26 <pumpkin> where?
11:52:26 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:52:27 <chessguy_work> conal, i meant chastened in a good way
11:52:31 <paper_cc> Eridius: ^^
11:52:53 <pumpkin> jganetsk: ah, probably because someone posted the link :) I was bored so started reading it too
11:53:07 <Cheshire> ADTs are domain equations
11:53:21 <conal> chessguy_work: :)  ... so if the semantics isn't spelled out, i look to the implementation to give me hints.  usually implementations aren't optimized to answer that question.
11:53:21 <Eridius> haha
11:53:22 <pumpkin> > (+1) *** (+2) $ (1,2)
11:53:24 <lambdabot>   (2,4)
11:54:06 <pumpkin> > snd *** fst $ (1,2)
11:54:07 <lambdabot>       No instance for (Num (a, b))
11:54:07 <lambdabot>        arising from the literal `1' at <in...
11:54:08 * chessguy_work nods
11:54:12 <pumpkin> oh duh
11:54:16 <pumpkin> > snd &&& fst $ (1,2)
11:54:17 <lambdabot>   (2,1)
11:54:48 <asgaroth> @pl \(a,b) -> (a+b)/2
11:54:48 <lambdabot> uncurry (flip flip 2 . ((/) .) . (+))
11:55:10 <chessguy_work> conal, does the semantic domain i have come across at all in that code?
11:55:12 <pumpkin> ack
11:55:13 <pumpkin> flip flip
11:55:29 <conal> chessguy_work: not to me
11:55:35 <chessguy_work> :(
11:55:54 <conal> chessguy_work: i didn't try very hard.
11:56:22 <chessguy_work> conal, the idea is a sort of continuation where the function being 'continued' is more strongly reified
11:56:44 <pumpkin> asgaroth: there's a much nicer one for that, not sure why it's so ugl
11:56:44 <pumpkin> y
11:56:54 <chessguy_work> conal, that is, you're able to examine it to see what it's doing, and modify it more easily
11:57:06 <pumpkin> @check \x@(a,b) -> (a+b)/2 == ((/2) . uncurry (+) $ x)
11:57:07 <lambdabot>   "OK, passed 500 tests."
11:57:21 <pumpkin> asgaroth: (/2) . uncurry (+)
11:58:35 <conal> chessguy_work: sounds like a neat project :)
11:58:49 <chessguy_work> conal, it's an interesting idea
11:59:15 <chessguy_work> i think it could provide some new techniques for symbolic AI
12:00:11 <Deewiant> @check \x@(a,b) -> (a+b)/2 == (uncurry (+) . join (***) (/2) $ x)
12:00:12 <lambdabot>   "OK, passed 500 tests."
12:00:30 <Nafai> What does byorgey mean when he says that "the kind of f must be * -> *"
12:00:42 <Nafai> I'm not sure I understand what the asterisks are signifying here
12:00:49 <Deewiant> ?kind Int
12:00:50 <lambdabot> *
12:00:50 <Eridius> kind is like a type's type
12:00:51 <Deewiant> ?kind Maybe
12:00:52 <lambdabot> * -> *
12:00:58 <conal> chessguy_work: neat.  sorry i don't have the cycles to look deeply right now.  back to writing for me.  icfp deadline is march 4 and lots more work to do.
12:01:01 <Deewiant> ?kind IO
12:01:02 <lambdabot> * -> *
12:01:07 <Deewiant> ?kind Either
12:01:08 <lambdabot> * -> * -> *
12:01:13 <Deewiant> etc.
12:01:24 <Cheshire> Nafai, * is the kind of a type which may have values
12:01:45 <gueux> I would like to do a type "SquareBoard n" where n is the size of the board, and to instanciate SquareBoard as a Board. When I write "instance Board SquareBoard n" I have an error because Board does not know what is this n
12:02:16 <Saizan> instance Board (SquareBoard n)
12:02:21 <Nafai> What are the alternatives to *?
12:02:25 <Saizan> but n must be a type
12:02:26 <Nafai> And how would one read "* -> *"
12:02:36 <gueux> Board.hs:67:21: Not in scope: `n'
12:02:37 <chessguy_work> conal, sure, i understand
12:02:37 <Deewiant> Nafai: AFAIK there's only #, which denotes unboxed types.
12:02:47 <gueux> Saizan: with instance Board (SquareBoard n)
12:02:52 <Cheshire> just read it as * -> *
12:02:55 <C-Keen> gueux: You want to use Int for example I think
12:02:58 <doserj> @kind (->)
12:02:59 <lambdabot> ?? -> ? -> *
12:03:09 <Eridius> o_O
12:03:15 <chessguy_work> conal, you re-focused me on the semantic domain, which already made a simplification pop out to me
12:03:15 <Deewiant> ? just means that it can be either * or #
12:03:26 <chessguy_work> conal, (man i wish i knew how you do that)
12:03:48 <Eridius> So what is #?
12:04:23 <pumpkin> Eridius: unboxed types
12:04:35 <Deewiant> Eridius: I only said it about two minutes ago ;-)
12:04:36 <Eridius> can you give an example?
12:04:37 <pumpkin> @src Int
12:04:37 <lambdabot> data Int = I# Int#
12:04:45 <Deewiant> Eridius: Int#
12:04:54 <Saizan_> Nafai: Foo :: * -> * reads as Foo is a type constructor that takes a type as argument
12:04:59 <pumpkin> Eridius: an Int is an Int# in an I# constructor :P
12:05:03 <Eridius> o_O
12:05:09 <Deewiant> Eridius: in other words, nothing that you'd ever run into in normal haskell code
12:05:13 <Eridius> ok
12:05:17 <gueux> C-Keen: but I need n as a parameter
12:05:20 <conal> chessguy_work: :)
12:05:24 <Deewiant> only stuff like the base library and the occasional highly optimized code
12:05:41 <pumpkin> it's called MagicHash isn't it?
12:05:46 <pumpkin> or something involving Hash :D
12:05:59 <Deewiant> MagicHash, yes
12:06:09 <Nafai> Saizan_: Okay, thanks.
12:06:11 <pumpkin> What makes it magic?
12:06:17 <Nafai> Saizan_: Thanks for always been so helpful :)
12:06:27 <Deewiant> It's an operator character but isn't?
12:06:31 <Deewiant> I don't know. :-P
12:08:10 <pumpkin> "Compilation time will be slower, especially with -O2.
12:08:10 <pumpkin> At present, -O2 is nearly indistinguishable from -O."
12:08:23 <chessguy_work> wow, this is a monoid...
12:08:32 * chessguy_work scratches his head
12:08:33 <pumpkin> chessguy_work: what is?
12:08:46 <Cheshire> If you have some expressions build up of functions and constants and wanted to compare equality ... how do you it other than reducing both to normal form and compare syntactic equality, i.e. how do you not expand all definitions?
12:08:56 <chessguy_work> pumpkin, don't mind me, i'm muttering in be-bafflement
12:08:59 <pumpkin> :)
12:09:35 <chessguy_work> man, i *just* got done overhauling this code, now i get to do it again :)
12:13:17 <RayNbow> > let isLowerLimit x = all (x<=) in isLowerLimit 0 [1..]
12:13:32 <lambdabot>   thread killed
12:13:46 <asgaroth> pumpkin: thanks(a bit late, I know)
12:13:57 <pumpkin> no problem :)
12:21:46 <Eridius> can you ask lambdabot for the @src of a particular instance?
12:21:59 <pumpkin> @src [] fmap
12:21:59 <lambdabot> fmap = map
12:22:11 <pumpkin> @src (->) fmap
12:22:11 <lambdabot> fmap = (.)
12:22:17 <Eridius> huh, that syntax looks a bit odd
12:22:19 <Eridius> @src Either fmap
12:22:19 <lambdabot> fmap _ (Left x) = Left x
12:22:19 <lambdabot> fmap f (Right y) = Right (f y)
12:22:31 <Eridius> ok, that's what I expected
12:23:32 <Eridius> anybody know who maintains Hoogle? it's getting increasingly annoying how broken its hyperlinks are (it never gets the anchor right)
12:26:27 <sjanssen> Eridius: Neil Mitchell
12:26:56 <Eridius> to be fair, half of the brokenness is on the Haskell docs side, though that could be worked around on the Hoogle side
12:27:10 <Eridius> the two problems here are Hoogle uses v:Foo fragments even for types (which should be t:Foo)
12:27:27 <Eridius> the other problem is the docs percent-escape all non-alphabetic characters in anchors, so Hoogle *really* should be using v%3AFoo
12:28:05 <pumpkin> wow, I just halved my program's execution time by changing compiler flags (I already had -O2)
12:28:41 <sjanssen> pumpkin: what was the magic flag?
12:28:44 <Eridius> ooh, hoogle actually has a bug tracker. I should have looked at it earlier ;)
12:28:47 * sjanssen bets it was -funbox-strict-fields
12:29:03 <pumpkin> excess precision :)
12:29:07 <pumpkin> I already had unbox-strict-fields
12:29:11 <sjanssen> ah, that will also do it
12:29:13 <pumpkin> and vic-C O3
12:29:17 <pumpkin> via
12:29:40 <pumpkin> trying with msse2 now
12:29:51 <pumpkin> seeing if I can squeeze any more performance out of it with no work
12:30:07 <pumpkin> guess not :)
12:30:21 <monochrom> I think it's about as good as you can get.
12:30:26 <titusg> can someone point me to a simple example that uses unboxed ints, including the imports etc needed?
12:31:10 <sjanssen> titusg: http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
12:31:17 <pumpkin> maybe I should move to Float from Double
12:31:18 <sjanssen> import GHC.Exts
12:31:26 <pumpkin> I know they say not to do it
12:31:37 <pumpkin> but I do have epic quantities of data sitting around, in unboxed arrays
12:31:47 <pumpkin> so it might be one of those cases where it actually helps
12:33:03 <monochrom> Just remember that on x86 the only benefit of Float is save memory and memory bandwidth. No arithmetic speedup.
12:33:07 <pumpkin> yeah
12:33:11 <titusg> sjanssen: thanks, I read that but couldn't get the simplest example working, eg add1 :: Int# -> Int#
12:33:12 <pumpkin> but memory is an issue :)
12:33:29 <pumpkin> I'm loading a gig of floating point numbers into memory
12:33:30 <sjanssen> add1 x = 1# +# x
12:33:47 <monochrom> eww, no wonder!
12:34:24 <sjanssen> titusg: have you imported GHC.Exts and turned on the necessary GHC extensions?
12:35:12 <titusg> sjanssen: I'm importing GHC.Prim & GHC.Ext and used :set -XMagicHash in ghci -- I get     Not in scope: data constructor `Int#'
12:35:14 <pumpkin> you need magic hash! I know a dude down the street
12:35:16 <Eridius> @src ((,) a) fmap
12:35:16 <lambdabot> Source not found.
12:35:17 <Eridius> hehe
12:35:19 <pumpkin> ah
12:35:27 <pumpkin> @src (,) fmap
12:35:27 <lambdabot> fmap f (x,y) = (x, f y)
12:35:31 <Eridius> pfft
12:35:40 <sjanssen> titusg: there is no data constructor called Int#
12:35:55 <pumpkin> there's I#
12:36:10 <sjanssen> titusg: also, GHC.Prim is deprecated, you're supposed to use GHC.Exts now
12:37:25 <gueux> I would like to do something like that: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1492#a1492
12:37:47 <gueux> but I have a error: Board.hs:45:43: Not in scope: `n'
12:37:48 <titusg> sjanssen: thanks, that's working now
12:38:32 <sjanssen> gueux: types are not values
12:38:38 <sjanssen> values are not types
12:39:07 <sjanssen> "
12:39:07 <sjanssen> "
12:39:07 <sjanssen> data SquareBoard size = SquareBoard {board::[[Square]], size::Int}
12:40:03 <sjanssen> huh, I wonder why it pasted like that.  Anyway, the 'size' in 'data SquareBoard size' and the 'size' in 'size :: Int' exist in different namespaces and have no relation
12:40:45 <monochrom> Similarly, "instance Board_ (SquareBoard n)" and "emptyBoard n"  the two n's are unrelated.
12:41:06 <gueux> so, is it possible to instanciate a SquareBoard Int as a Board_
12:41:13 <asgaroth> I'm trying to memoize a function with an infinite list as in lst = [foobar n | n <- [1..]]. If I access lst !! x, will that also compute all the previous elements or is ghc able to figure out that they aren't needed?
12:41:22 <paper_cc> gueux: as well as SquareBoard String or SquareBoard IO
12:41:30 <paper_cc> oops
12:41:32 <sjanssen> not IO, it has the wrong kind
12:41:40 <paper_cc> SquareBoard (IO ()) rather
12:41:59 <sjanssen> asgaroth: it will allocate thunks for the previous elements, but won't evaluate them
12:42:42 <hackage> Uploaded to hackage: zoneinfo 0.3
12:42:42 <hackage> Uploaded to hackage: Stream 0.3.1
12:42:52 <asgaroth> sjanssen: thanks
12:43:10 <pumpkin> hackage needs a reddit account
12:43:20 <pumpkin> I visit the what's new page quite often
12:43:23 <sjanssen> gueux: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1492#a1493 you can do this
12:43:25 <pumpkin> I mean
12:43:27 <pumpkin> a twitter account
12:43:38 <paper_cc> gueux: unlike C++ templates, you can't have a non-type parameter for a type
12:43:43 <sjanssen> pumpkin: it has RSS
12:43:49 <pumpkin> sjanssen: not as cool :P
12:43:59 <pumpkin> sjanssen: whee, I made it even faster :D
12:44:03 <pumpkin> that code I was talking about
12:44:05 <michaelcdever> hey im trying to install gtk2hs on ubuntu, but i keep getting errors about not having "mtl"?
12:44:20 <paper_cc> michaelcdever: install mtl then =)
12:44:25 <michaelcdever> how :D
12:44:28 <paper_cc> it's the Monad Transformer Library
12:44:33 <sjanssen> michaelcdever: apt-get install libghc6-mtl-dev
12:44:33 <michaelcdever> ah
12:44:36 <dcoutts_> michaelcdever: install it using the ubuntu package manager
12:44:37 <paper_cc>  $ cabal install mtl
12:44:46 <paper_cc> if you have cabal-install of course
12:44:51 <dcoutts_> michaelcdever: it'll be called something like libghc6-mtl-dev
12:45:22 <sjanssen> s/something like //
12:45:24 <sjanssen> :)
12:45:44 <titusg> sjanssen: what about unboxing (fromIntegral x / 2.5)? /# is not in scope
12:45:51 <Eridius> oh this is just bizarre. The Typeclassopedia PDF renders beautifully in Safari, but it renders oddly in Preview. It's using an entirely different font, and selection behaves oddly. WTF
12:45:54 <michaelcdever> cool got it, now its asking about glib?
12:46:02 <michaelcdever> and gobject
12:46:13 <Eridius> oh there we go, reopening it fixed the font
12:46:15 <Eridius> and selection
12:46:17 <Eridius> WTF again
12:46:23 <sjanssen> titusg: I think the function is called something else.  Try skimming through the output of :browse GHC.Exts in ghci
12:46:42 <michaelcdever> is 2.7-1 ok?
12:47:04 <michaelcdever> *glibc 2.71
12:47:08 <paper_cc> michaelcdever: dependences in the package description mention versions
12:47:12 <pumpkin> @google fdicts-cheap
12:47:13 <lambdabot> No Result Found.
12:47:23 <sjanssen> titusg: if you haven't noticed, unboxed types aren't really intended as an end user feature.  Are you sure you really need them?
12:47:31 <paper_cc> michaelcdever: look it up on hackage or in the package itself (.cabal file)
12:47:34 <asgaroth> Is anyone else getting a ghc panic when trying to compile Crypto 4.1? (ghc-6.10.1)
12:47:57 <sjanssen> asgaroth: yes, it's a known issue
12:48:09 <sjanssen> the workaround is to compile with -fregs-graph or something like that
12:48:13 <pumpkin> anyone know what fdicts-cheap does?
12:48:15 <titusg> sjanssen: I am just playing around, seeing how much difference it makes
12:48:20 <asgaroth> okay, thanks
12:48:24 <dcoutts_> michaelcdever: you should not be installing any ubuntu package that requires you to change the version of glibc.
12:48:35 <Eridius> huh, Typeclassopedia's definition for Pointed doesn't match the one in category-extras (different name for the function)
12:49:03 <dcoutts_> michaelcdever: if the mtl package you found requires that then ignore it, it's clearly not from the right package repository for your system.
12:49:09 <chessguy_work> Eridius, artistic license?
12:49:11 <sjanssen> michaelcdever: hmm, are you on some strange setup?
12:49:21 <michaelcdever> nope default ubuntu install
12:49:24 <Eridius> chessguy_work: it's just curious since Typeclassopedia pointed out category-extras in the first place
12:49:29 <lifflander> Hey, I've got a question -- writing an AI agent for a game in Haskell.
12:49:33 <sjanssen> michaelcdever: intrepid?
12:49:43 <doserj> dcoutts: I guess it wants libglib, not glibc
12:49:51 <paper_cc> oh, by the way, is it possible to compile haddock on the latest ghc-6.11.20090215? it gives a compile error for me
12:50:00 <lifflander> I using a do statement and I want to do something like this:
12:50:00 <lifflander> do a <- f b
12:50:04 <michaelcdever> ran sudo apt-get install ghc, then downloaded the gtk2hs source and am working my way through ./configure
12:50:09 <michaelcdever> and its hardy
12:50:11 <chessguy_work> Eridius,  yes, but it only brought up Pointed so that it could define other typeclasses in terms of it, for which pure is a better name
12:50:11 <dcoutts_> doserj: I think he was installing mtl, not gtk
12:50:17 <Eridius> ok
12:50:18 <paper_cc> doserj: dcoutts: or even the glib _binding_
12:50:21 <chessguy_work> (i think pure is what was used?)
12:50:24 <Eridius> yeah
12:51:10 <michaelcdever> i installed mtl, mtl went fine it's ./configure thats telling me about glibc
12:51:28 <sjanssen> michaelcdever: oh, I bet you're missing development headers
12:51:34 <michaelcdever> ??
12:51:50 <mathijs> install build-essential
12:51:54 <paper_cc> sudo apt-get install build-essentials
12:52:30 <paper_cc> s/ials/ial/
12:52:38 <titusg> sjanssen: it seems to be divideFloat#, thanks for the tip
12:52:44 <michaelcdever> nope, its still asking for glib
12:52:47 <michaelcdever> ill do a paste
12:53:19 <sjanssen> michaelcdever: you're not being consistent, is it asking for glib or glibc?
12:53:24 <dcoutts_> michaelcdever: you confused us by talking about glibc rather than glib
12:53:39 <dcoutts_> they're quite different, though similar names
12:53:51 <michaelcdever> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1494
12:54:13 <dcoutts_> michaelcdever: see the bit "Perhaps you need to install glib or glib-devel"
12:54:28 <sjanssen> michaelcdever: apt-get install libglib-dev
12:54:50 <sjanssen> michaelcdever: you'll need to install several -dev packages
12:55:23 <dcoutts_> the gtk-dev one should pull in most of the interesting ones
12:55:48 <dcoutts_> oh, and glade
12:55:56 <thetallguy> Hmm...  Maybe I should advertise stepcut's new tool:  apt-get-build-depends
12:56:23 <sjanssen> thetallguy: ooh, what is that?
12:56:29 <thetallguy> unlike 'apt-get build-depends', which looks at the package source entry in the archive...
12:56:42 <thetallguy> ...apt-get-build-depends looks at the control file in the debian directory.
12:56:54 <michaelcdever> nope, that didn't solve it...
12:57:47 <sjanssen> michaelcdever: same error or different error?
12:57:50 <michaelcdever> ah got it, libglib2.0-dev
12:57:59 <michaelcdever> now im getting gtk errors
12:58:28 <mathijs> libgtk2.0-dev
12:58:39 <sjanssen> michaelcdever: 'apt-get build-dep libghc6-gtk-dev' might save you some time
12:59:30 <kaol> michaelcdever: if you can wait a week or two, Debian will hopefully get ghc 6.10.1 sorted out in unstable and Ubuntu can sync on that
12:59:31 * paper_cc doesn't remember gtk2hs in hardy
12:59:56 * kaol doesn't know anything about ubuntu beyond that, sorry
13:00:33 <roconnor> @seen shapr
13:00:33 <lambdabot> shapr is in #haskell-in-depth, #haskell-blah and #haskell. I last heard shapr speak 8h 20m 55s ago.
13:00:38 <mathijs> kaol: ubuntu is like debian, but without having to wait 5 years for new features :P
13:01:23 <bremner> like debian unstable, but they call it stable, so people are happier :-)
13:01:27 <michaelcdever> heh, cheers! i think its sorted!
13:02:29 <kaol> mathijs: not when they depend on us doing the work
13:02:30 <mathijs> bremner: hehe :)  well I had some unable-to-boot times sticking to unstable.  but in the end, they are all quite alike.
13:02:30 <asgaroth> the 6-month release cycle of ubuntu would still piss me off compared to debian unstable though
13:02:30 <roconnor> doesn't Ubuntu have a more consistent set of packages than Debian?
13:02:51 <Heffalump> dcoutts_: did you say a cabal-install release is imminent?
13:03:08 <sjanssen> asgaroth: in what way?  Would releases be too frequent or not frequent enough?
13:03:15 <dcoutts_> Heffalump: yes
13:03:33 <michaelcdever> wow, it was a lot easier to install on fedora :D
13:03:34 <asgaroth> sjanssen: not frequent enough. (at least for me on a desktop)
13:03:38 <Orphi> dcoutts_: I never did get round to trying out cabal-install...
13:03:50 <sjanssen> asgaroth: it actually doesn't bother me
13:03:51 <dcoutts_> Heffalump: I'd guess Thursday. I've got two fixes to do and then re-test for regressions.
13:03:53 <asgaroth> updating the package individually seems a better approach to me
13:04:03 <sjanssen> asgaroth: of course I'm not your average desktop user :)
13:04:38 <sjanssen> vim and urxvt don't get very frequent releases, and the releases are usually boring :)
13:04:41 <thetallguy> sjanssen:  http://src.seereason.com/ghc610/haskell-debian-3/
13:05:00 <asgaroth> sjanssen: yes, probably not. but for example ghc-6.10 was available rather quickly after xmonad compiled with it. with ubuntu one might have to wait longer or have some extra fuss getting it
13:05:26 <mathijs> asgaroth, sjanssen: I find ubuntu (with xmonad, no gnome and stuff)'s release cycle just ok for most stuff, but for developers, it's too slow in certain areas. I mean I do need to keep my own ghc and ruby in /opt because waiting for 6 months is just not gonna work.
13:06:09 <sjanssen> asgaroth: right.  I'm not even sure if GHC 6.10 will be in the upcoming release in April
13:06:21 <Heffalump> does someone maintain it in ubuntu separately from debian?
13:06:28 <mathijs> for basic kernel/libs/X11/desktop stuff 6 months is just about right (for me)
13:06:55 <Nafai> mathijs: Agreed.
13:07:08 <Nafai> The developer tools are the only things I miss
13:07:51 <mathijs> Nafai: and that's not really a problem, since -as developers- we like to do that stuff ourselves anyway, no distribution can do it right :)
13:07:54 <sjanssen> Heffalump: I don't think much maintenance is involved.  Basically someone just has to periodically pull the new GHC from Debian and make sure all the libraries are updated
13:08:23 <Nafai> mathijs: True.  I just purged all of the Haskell packages from Ubuntu on my system and went all ghc 6.10 and cabal-install
13:08:36 <Nafai> Sadly, that misses out on the distro updating the packages and such
13:11:52 <sjanssen> I'm just doing without GHC 6.10 for now.  I can't say that I've missed it very much
13:16:18 <jacobian> anyone else here use observe in hugs?  I find that it deconstructs strings into head character and tail: 'a':"sdf"  is there some way to get it to stop this behaviour?
13:16:32 <Eridius> @src (<**>)
13:16:32 <lambdabot> (<**>) = liftA2 (flip ($))
13:16:49 <thetallguy> sjanssen: we have it debianized now...
13:18:43 <bremner> thetallguy: is installing it from experimental and providing feedback helpful?
13:19:27 <thetallguy> bremner: we're not using Debian's current work yet, we did our own.
13:20:21 <pumpkin> sjanssen: I'm amazed at how removing unnecessary exports from my module improved performance btw
13:21:07 <pumpkin> the compiler flags got me from 4:40 to 2:17, and removing unnecessary exports (I guess to facilitate inlining) took me down to 1:40ish
13:21:19 <thetallguy> bremner: they are catching up, which is nice, but we felt we needed to run ahead.
13:21:19 <Nafai> thetallguy: "We" as in Ubuntu?
13:21:25 <pumpkin> all after I already had -O2 enabled :D
13:21:28 <pumpkin> makes me happy
13:21:38 * Heffalump decides that building a statically linked cabal binary isn't as easy as it sounds
13:21:48 <yitz> pumpkin: what additional flags?
13:21:53 <thetallguy> Nafai: seereason.com.  We used to be the core OS team at Lindows/Linspire, so we have our own tools
13:22:05 <Nafai> thetallguy: Oh, awesome
13:22:12 <dcoutts_> Heffalump: no? what makes it tricky?
13:22:15 <thetallguy> Nafai: although we now generally build our packages for Ubuntu, because that's what we use.
13:22:24 <pumpkin> yitz: via-C O3, excess-precision, sse2, mostly
13:22:27 <sjanssen> pumpkin: you're exactly right on the exports/inlining thing.  It's a well known but tricky thing
13:22:33 <Nafai> thetallguy: Are these available anywhere?
13:22:44 <thetallguy> src.seereson.com
13:22:47 <thetallguy> deb.seereason.com
13:22:52 <pumpkin> yitz: I'm doing a lot of uvector work, which is supposed to be a lot better in via-C
13:22:57 <Nafai> thetallguy: Also, do you guys need any volunteer help?  I'd love to see the story for Haskell on Debian/Ubuntu to be better
13:23:08 <yitz> pumpkin: ok got it. do you think sse2 did something for your app?
13:23:09 <Heffalump> dcoutts_: (a) for some reason it moans about not having loads of stuff from pthreads, and -optl-lpthread doesn't help, and (b) even if I can fix that, there's this issue: http://www.gnu.org/software/libc/FAQ.html#s-2.22
13:23:10 <thetallguy> I'm working on our website now, and I'll put up some faqs about this.
13:23:23 <michaelcdever> great folks, thanks a mill, tis working properly now, or seems to be
13:23:34 <michaelcdever> well see what happens when i throw my file manager at it
13:23:42 <thetallguy> Nafai: sure.  Use it, log bugs at bugzilla.seereason.com, send patches to logic@seereason.com
13:23:44 <Heffalump> thetallguy/Nafai: the debian-haskell list is presumably the sensible place to coordinate
13:24:02 <Nafai> Heffalump: Yeah, I'm currently lurking there
13:24:28 <thetallguy> Heffalump: yes, although that is focussed on Debian's efforts and they tend not to pick up our stuff.
13:24:52 <Heffalump> thetallguy: I guess they're sort of orthogonal
13:25:05 <Heffalump> but in theory your stuff should help the Debian packaging effort a lot
13:25:30 <dcoutts_> Heffalump: perhaps it's ok for it not to be fully static, eg linking to gmp and zlib is probably ok isn't it?
13:26:03 <thetallguy> Heffalump: they don't have to be, but Debian likes to do their own work, in general.
13:26:04 <Heffalump> well, I think it needs to link to libc6 to get round (b), and perhaps pthread because that might be quite system specific
13:26:36 <Heffalump> I'd rather other stuff were compiled in, though in theory doing that with libgmp would leave me needing to comply with the GPL and make the source available
13:26:39 <Heffalump> s/GPL/LGPL/
13:27:01 <thetallguy> pumpkin: on that export speedup, does that affect compile time or run time as well?
13:27:05 <Heffalump> but anyway, this is why it's not as easy as it sounds, particularly since I don't know how to statically link in just some libraries
13:27:09 <roconnor> nice post about ultrafinitism http://dialinf.wordpress.com/2009/02/16/achilles-tortoise-and-yessenin-volpin/
13:28:25 <pumpkin> thetallguy: it affects runtime, haven't paid much attention to compile time
13:29:44 <pejo> Heffalump, on unix you can work around linker deficiencies by simply just having the shared libgmp.so available, and only the .a's for the other libraries.
13:29:47 <thetallguy> pumpkin: runtime of a compiled app?
13:29:53 <pumpkin> thetallguy: yes
13:30:03 <michaelcdever> i dont need to keep the source folder do i?
13:30:08 <Heffalump> pejo: i.e. hack around in /usr/lib temporarily?
13:30:28 <Heffalump> anyway, unless I can figure out a nice easy recipe I'm going to give up
13:30:34 <pejo> Heffalump, ouch. /usr/lib will be painful to get around.
13:31:08 <Heffalump> the linker may well be able to just link some in, but I don't know the options to do it and my experience with ld options is that they take quite a bit of understanding
13:31:21 <pumpkin> lol, I wrote an NFData instance for UArr
13:31:22 <pumpkin> not sure why
13:32:03 <Heffalump> pumpkin: so it can be used generically?
13:32:13 <pejo> Heffalump, agreed, and order matters. And you need to pipe that through ghc as well, I guess.
13:32:37 <pumpkin> Heffalump: I guess :)
13:33:44 <michaelcdever> hmm, ghc can't find Text.Regex.Posix... how can i fix this?
13:33:59 <pumpkin> michaelcdever: install it
13:34:18 <pumpkin> cabal install regex-posix ?
13:35:24 <michaelcdever> i need libghc6-cabal-dev for cabal?
13:35:45 <paper_cc> cabal-install isn't packaged afaik
13:35:54 <paper_cc> you still need cabal-dev though
13:37:32 <michaelcdever> hmm cabal-dev wont install cause of broken dependencies
13:39:49 <pumpkin> yitz: nothing that I can separate, really :) it seems to be going about a second faster, but that could just be random
13:40:19 <yitz> pumpkin: do your uvectors contain doubles?
13:40:25 <pumpkin> yitz: yeah
13:40:27 <pumpkin> why?
13:40:31 <yitz> so could be
13:40:43 <pumpkin> I've been tempted to rewrite using Floats
13:40:51 <pumpkin> simply because I have a lot of Doubles and they take lots of memory
13:41:13 <yitz> pumpkin: hoping for more cache hits?
13:41:24 <michaelcdever> can other people access haskell.org/cabal/download.html
13:41:32 <pumpkin> yitz: mostly trying to avoid maxing out my RAM :P
13:41:37 <pumpkin> but some of the functions I'm using aren't polymorphic and expect a Double
13:41:37 <thetallguy> pumpkin, sjanssen: is there a reference for that bit about limiting exports for speedups?
13:41:46 <pumpkin> thetallguy: I read it on the wiki :)
13:41:47 <yitz> pumpkin: rewrite to a type alias. then you can play at will
13:42:03 <pejo> michael, I'm having trouble browsing other parts of haskell.org right now.
13:42:26 <pumpkin> yitz: well, I'm using statistics-fusion, which is already compiled for Double... I'm tempted to add Float versions of those functions
13:42:31 <gueux> if I've understood well, it is impossible to declare something which take a value as argument and which returns a class
13:42:37 <thetallguy> pumpkin: not sure how I've missed that.
13:42:41 <pumpkin> gueux: returns a class?
13:42:42 <hackage> Uploaded to hackage: barrie 0.3.1
13:42:45 <pumpkin> thetallguy: you found it?
13:42:54 <pumpkin> thetallguy: I'll dig up a link if you didn't
13:42:55 <gueux> I really nead something like ml modules
13:42:57 <gueux> :-)
13:43:02 <michaelcdever> ah ok, cheers pejo
13:43:43 <pumpkin> yitz: then again, the statistics-fusion module is pretty tiny (and I wrote a couple of the functions myself) so I could just include Float versions in my own code :P
13:43:49 <gueux> pumpkin: I've defined what is a Board as a class. Then, I'd like to define what is a Game
13:43:49 <yitz> pumpkin: oh i see
13:44:04 * glguy wants to be able to use do-notation with applicatives where the named results are not allowed to be used in impure ways
13:44:07 <yitz> writing R in haskell are you
13:44:37 <glguy> like how arrow notation distinuishes between arrow notation with and without ArrowApply
13:44:56 <Heffalump> glguy: so how could they be used? Only in a final "return"?
13:44:59 <gueux> a Game should have an "init function" (function may not be the good word) which takes a value (the parameters of the games) and returns a board
13:45:02 <glguy> Heffalump, yeah
13:45:04 <thetallguy> pumpkin: not yet
13:45:32 <yitz> gueux: function is our favorite word here :)
13:45:38 <gueux> :-)
13:45:46 <Heffalump> you could implement >>= by passing undefined to the function, and hope for the best :-)
13:46:56 <gueux> with ml I had modules and parametrized modules which could do that
13:47:17 <gueux> but with haskell I can't see how to do it
13:47:51 <gueux> with ml, a game would have been a module signature
13:48:14 <gueux> with haskell, it may be a class, no?
13:48:33 <sjanssen> gueux: a game might just be a data type in Haskell
13:48:42 <sjanssen> do different games share some common interface?
13:48:49 <gueux> ok
13:48:57 <thetallguy> pumpkin: this?  For best results, use an explicit export list. If you do, GHC can inline any non-exported functions that are only called once, even if they are very big. Without an explicit export list, GHC must assume that every function is exported, and hence (to avoid code bloat) is more conservative about inlining.
13:48:57 <newsham> ?seen bmeph
13:48:57 <lambdabot> bmeph is in #haskell-in-depth, #haskell-blah, #ghc, #concatenative, #haskell-overflow and #haskell. I don't know when bmeph last spoke.
13:49:12 <Cheshire> do you think now is a better time to ask about HOAS?
13:49:13 <pumpkin> thetallguy: yes
13:49:15 <gueux> and so, a board would be a data type too
13:49:28 <pumpkin> thetallguy: and it shaved 30 seconds off my runtime :)
13:49:29 <newsham> ?tell bmeph loeb :: (Functor f) => f (f b -> b) -> f b
13:49:30 <lambdabot> Consider it noted.
13:49:32 <pumpkin> obviously YMMV
13:50:00 <thetallguy> pumpkin: okay, I did know about that.  I had leapt to the idea that it was another mechanism at work.
13:50:06 <pumpkin> yitz: I think I will "fuse" statistics-fusion into my code and see if I can make it more efficient with Floats
13:50:16 <Deewiant> ?djinn Maybe (Maybe b -> b) -> Maybe b
13:50:17 <lambdabot> f a =
13:50:17 <lambdabot>     case a of
13:50:18 <lambdabot>     Nothing -> Nothing
13:50:20 <lambdabot>     Just b -> Just (b (Just (b Nothing)))
13:50:44 <kerlo> loeb looks scary.
13:50:47 <gueux> and a type could have functions into its definition?
13:50:55 <yitz> pumpkin: ok, have fun
13:51:00 <sjanssen> gueux: they can, yes
13:51:02 <pumpkin> :D
13:52:46 <gueux> could you give me a very little example? :-)
13:53:11 <michaelcdever> arrgh
13:53:11 <sjanssen> gueux: I'm still not quite sure what you want
13:53:15 <Cheshire> @go cartoon guide to lobs theorem
13:53:16 <tehgeekmeister> is there a really really easy to use graph/plot generation library for haskell?
13:53:18 <lambdabot> http://www.overcomingbias.com/2008/08/lobs-theorem.html
13:53:18 <lambdabot> Title: Overcoming Bias: The Cartoon Guide to Löb's Theorem
13:53:19 <michaelcdever> cabal install doesnt install properly
13:53:19 <gueux> ok
13:53:59 <Heffalump> michaelcdever: doesn't install what properly?
13:54:02 <gueux> I want to code a game
13:54:32 <sjanssen> gueux: we're starting from this, right? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1492#a1492
13:54:56 <gueux> sjanssen: yes
13:54:58 <sjanssen> gueux: I suspect that Board_ shouldn't be a class, it should be a data type
13:55:29 <sjanssen> data Board = Board [[Square]]
13:55:58 <sjanssen> or possibly data Board = Board (Map Pos Square)
13:56:16 <sjanssen> gueux: what is the defn. of Pos?
13:56:30 <gueux> Pos is just (Int, Int)
13:56:39 <sjanssen> okay
13:57:08 <sjanssen> so you've already tied yourself to a rectangular coordinate system, it doesn't make much sense to me to abstract Board
13:57:26 <gueux> but, to me, data Board = Board [[Square]] would have been a particular Board
13:57:54 <gueux> ok, let's say that I could change the type of Pos to Int
13:57:59 <sjanssen> what other definitions can you imagine?
13:58:14 <sjanssen> gueux: but you can't do that with the current definition
13:58:28 <gueux> for example if I would like to play on a hexagon
13:58:35 <gueux> yes
13:58:42 <gueux> I am trying to change it :-)
13:59:05 <coco`> is there a way to expose the internal representation of a Double, i.e. getting mantissa and exponent?
13:59:21 <pumpkin> whee, I halved my memory use and shaved another 15 seconds off my runtime :D
13:59:42 <sjanssen> gueux: I think you're trying to hard to generalize things
14:00:01 <sjanssen> it doesn't seem useful to have the same interface for hexagonal and rectangular boards
14:00:02 <Draconx|Laptop> coco`, what, like the significand and exponent functions in the Prelude?
14:00:19 <michaelcdever> Heffalump: cabal-install-0.6.0
14:00:24 <gueux> It could be, after I would like to code a game server
14:01:03 <gueux> so it would only need to take a Game and then would provide an Interface
14:01:56 <gueux> I don't want to duplicate almost the same code depending on what type of board I use
14:02:26 <tromp> see my go code for some board representations
14:02:47 <Botje> @pl (\x -> (length (divisors x)) > 500)
14:02:48 <lambdabot> (> 500) . length . divisors
14:03:07 <Cheshire> @let over limit = (> limit)
14:03:09 <lambdabot>  Defined.
14:03:43 <michaelcdever> god, nothing is easy
14:03:46 <brutopia> hey, how do I remove item from some index with lists
14:03:55 <sjanssen> gueux: in the case of a game server, I think you want to abstract over games rather than over boards
14:04:01 <gueux> tromp: could you give me a link please?
14:04:06 <mauke> splitAt, (++)
14:04:08 <Cheshire> brutopia, write a function to do it then use that function
14:04:11 <gueux> sjanssen: yes, of course
14:04:23 <gueux> boards would be a first step
14:04:30 <sjanssen> gueux: the exact representation of a board is really an issue internal to the particular game
14:04:34 <tromp> see the 2 haskell links on http://homepages.cwi.nl/~tromp/go.html
14:04:58 <Deewiant> > let removeAt n x = let (a,b) = splitAt n x in a ++ drop 1 b in removeAt 4 "abcdef"
14:05:00 <lambdabot>   "abcdf"
14:05:26 <jganetsk> question, i'm looking at the standard prelude in the haskell 98 report
14:05:27 <jganetsk> and
14:05:31 <jganetsk> length seems to be O(n) in stack
14:05:35 <nothingmuch> i think i need help understanding Foreign.StablePtr better
14:05:39 <jganetsk> where n is the length of the list
14:05:41 <brutopia> Deewiant: thanks, but why it isn't included in list api
14:05:45 <jganetsk> why would they do that?
14:05:54 <Cheshire> jganetsk, not if you use e.g.  Nat = O | S Nat
14:05:55 * roconnor reviews http://homepages.cwi.nl/~tromp/go/Go.hs
14:06:04 <Deewiant> brutopia: I don't know, probably because it's not considered important?
14:06:04 <nothingmuch> i'm getting zombie threads, and i suspect it's because the Chan is being garbage collected and therefor the thread cannot have any more observable output
14:06:13 <brutopia> ok, thanks
14:06:23 <nothingmuch> the chan is being used in a Network.Curl callback
14:06:23 <Cheshire> jganetsk, oops that's impossible nvm
14:06:30 <jganetsk> Cheshire: but the type of the return value is Int
14:06:45 <Heffalump> michaelcdever: what goes wrong?
14:06:59 <Cheshire> jganetsk, it probably gets compiled into something sensible
14:07:25 <roconnor> @src Ix
14:07:25 <lambdabot> class (Ord a) => Ix a where
14:07:25 <lambdabot>     range           :: (a,a) -> [a]
14:07:25 <lambdabot>     index           :: (a,a) -> a -> Int
14:07:25 <lambdabot>     inRange         :: (a,a) -> a -> Bool
14:07:25 <lambdabot>     rangeSize       :: (a,a) -> Int
14:07:25 <gueux> sjanssen: yes, but there are a lot of games which are played on a go board, for example
14:07:38 <gueux> only the rules change
14:07:43 <nothingmuch> i use deRefStablePtr chanPtr in the callback, and then write to it
14:07:47 <nothingmuch> is that the correct usage?
14:07:58 <roconnor> > range ((0,0),(3,3))
14:07:59 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
14:08:41 <michaelcdever> Heffalump: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1496
14:09:00 <sjanssen> gueux: all of those games would still use a concrete implementation of a go board
14:09:22 <pumpkin> whee, another 15 seconds shaved off by an inline pragma
14:09:48 <roconnor> instance (Point p) => Eq (Position p) where
14:09:49 <roconnor>   p == q = showpos p == showpos q
14:09:50 <gueux> so, I was thinking in a Game::Board *the board*->(Board->Board->Bool) *the authorized moves*-> Interface
14:09:51 <roconnor> how bizarre
14:10:13 <kerlo> @src length
14:10:13 <lambdabot> Source not found. Take a stress pill and think things over.
14:10:40 <Heffalump> michaelcdever: what kind of filesystem are you on?
14:10:40 <roconnor> tromp: why no arrays?
14:10:47 <Heffalump> if tar doesn't work, something bad is happening!
14:10:50 <mathijs> can anyone tell me how to fix this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1497 - probably some 6.10 thingy that RWH didn't account for
14:11:00 <gueux> sjanssen: not necessarly, if I have access functions to the board (neighbours, ...)
14:11:34 <tromp> roconnor: i was too lazy to write explicit position equality
14:11:38 <michaelcdever> Hefalump: ext3 methinks
14:12:08 <Heffalump> tar -xzvf zlib-0.4.0.4.tar.gz is failing with utime errors, it seems
14:12:22 <Heffalump> which is nothing to do with cabal-install
14:12:30 <michaelcdever> any idea of how to get around it?
14:12:36 <tromp> roconnor: or do you object to newtype Position p = Position (p -> Color)?
14:12:37 <Heffalump> try in /tmp ?
14:12:45 <Heffalump> I have no real idea what could cause that error
14:12:47 <gueux> (getContent::Pos->Board->Content, putContent::Pos->Board->Content->Board,...)
14:12:55 <Heffalump> oh, hangon.
14:13:06 <Heffalump> I think it's installib zlib anyway
14:13:14 <roconnor> tromp: no, but I'm inclined to think arrarys would be more approriate
14:13:23 <Heffalump> is this a Debian system?
14:13:29 <michaelcdever> yep, ubuntu
14:13:29 <Heffalump> or ubuntu etc
14:13:40 <Heffalump> ok, then your problem is that you are missing the native packages for network and parsec
14:13:46 <roconnor> tromp: also, typically boards are allowed to repeat if it is a different player's turn, depending on the rules you go by.
14:13:46 <michaelcdever> ah ok
14:13:50 <Heffalump> apt-get install libghc6-network-dev libghc6-parsec-dev
14:13:55 <Heffalump> then try again
14:14:01 <tromp> roconnor: it's not meant to be efficient, but to be simple and clear
14:14:04 <Heffalump> in a "normal" GHC install those come with GHC proper
14:14:12 <gueux> tromp: maybe I'm trying something like you did :-)
14:14:30 <tromp> roconnor: i'm obviously going by my own rules, which use superko
14:14:39 <tromp> roconnor: i mean positional superko
14:14:41 <pumpkin> sjanssen: if I don't explicitly write a module definition at the top of my file, does ghc assume no functions are exported and not have any trouble inlining?
14:14:48 <roconnor> tromp: ok
14:15:36 <sjanssen> pumpkin: you mean in the case of a Main module?
14:15:39 <pumpkin> yeah
14:15:40 <kmeyer> how do I grab fields out of records?
14:15:54 <mathijs> what is GHC.Prim.Any ?
14:16:02 <sjanssen> pumpkin: I believe 'module Main (main) where' is implicitly inserted
14:16:06 <tromp> roconnor: i agree the equality could be done clearer
14:16:22 <roconnor> tromp: return (Left Occupied) -- it may possibly be better to use ErrorT (State ([Position p])) then this would be "throw Occupied"
14:17:05 <pumpkin> sjanssen: ah :)
14:17:08 <sjanssen> gueux: maybe a game should be: gamestate -> move -> Maybe gamestate?
14:17:08 <roconnor> tromp: but if you find monad transformers confusing, then stick with what you have.
14:17:35 <michaelcdever> Heffalump: thanks very much
14:17:55 <sjanssen> gueux: in which case you could use a MPTC "class Game gamestate move | gamestate -> move where ..."
14:18:38 <Heffalump> mathijs: I think it's something GHC uses to instantiate polymorphic types if they remain polymorphic once the whole program has been seen
14:18:52 <tromp> i tried ErrorT at some point, but it would be less for ppl unfamiliar with haskell
14:19:00 <pumpkin> can anyone think of a way to do partitionU over UArrs, without iterating over the vector twice (in a fast/fusible manner)
14:19:14 <roconnor> tromp: that is fair
14:19:21 <tromp> there was another reason
14:19:42 <tromp> when playing a whole game, i don't want to bomb out on first error
14:19:57 <roconnor> tromp: oh, sorry I see your compent about PSK
14:19:58 <gueux> what does
14:19:59 <tromp> but just show message and continue processinf moves
14:20:02 <sjanssen> pumpkin: you could make partitionU a good consumer, but I don't see how to make it a good producer without traversing the array twice
14:20:13 <gueux> MPTC "class Game gamestate move | gamestate -> move
14:20:15 <gueux> mean?
14:20:16 <mathijs> Heffalump: so this might be a problem on ghci if it can't infer what I'm after?
14:20:17 <pumpkin> sjanssen: yeah :/
14:20:27 <roconnor> <tromp> when playing a whole game, i don't want to bomb out on first error
14:20:33 <Heffalump> mathijs: possibly
14:20:38 <roconnor> using ErrorT is exactly the same as what you are doing
14:20:43 <tehgeekmeister> how do i sort a list by the second item in a pair?  i want foo :: [(a,b)] -> [(a,b)]  where it ends up sorted.  i tried doing this with sortBy but am having no luck so far.
14:20:53 <Heffalump> tehgeekmeister: sortBy (compare `on` snd)
14:21:00 <roconnor> tromp: so it wouldn't bomb out any more than what you have
14:21:01 <gueux> Game would be the class
14:21:04 <mathijs> Heffalump: well, even if I tell it what I expect (using ::) it keeps telling me that... please see 5/Supply.hs GeneralizedNewtypeDeriving
14:21:05 <sjanssen> pumpkin: I don't think stream fusion can consume one stream and produce two
14:21:07 <Heffalump> on is in Data.Function in GHC 6.8+ (IIRC)
14:21:13 <tromp> oh, then i'm confused with the time i tried calling error instead:(
14:21:14 <sjanssen> gueux: Game is a class with two parameters
14:21:18 <pumpkin> sjanssen: makes sense :)
14:21:20 <mathijs> Heffalump: oops, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1497 that was
14:21:22 <yitz> > sortBy (comparing snd) [(1,5),(2,4),(3,2)]
14:21:24 <lambdabot>   [(3,2),(2,4),(1,5)]
14:21:26 <gueux> oh, ok
14:21:30 <roconnor> tromp: but I agree that monad transformers can be more difficult to understand
14:21:37 <gueux> you put a '|' to say that?
14:21:41 <sjanssen> gueux: the "| gamestae -> move" part means that the gamestate parameter chooses the move parameter
14:21:43 <yitz> @type comparing
14:21:45 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:21:46 <tehgeekmeister> Heffalump: on is a weird looking function, but i'll just use it and be happy and not try to understand it for now.
14:21:53 <roconnor> tromp: ya calling error would be bad :D
14:22:01 <sjanssen> gueux: ie. if we know what sort of game we're playing, we know what a move looks like
14:22:11 <yitz> @src comparing
14:22:11 <lambdabot> Source not found. stty: unknown mode: doofus
14:22:38 <yitz> @type on compare
14:22:39 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
14:22:44 <gueux> ok
14:22:51 <tehgeekmeister> @src on
14:22:51 <lambdabot> (*) `on` f = \x y -> f x * f y
14:23:00 <tehgeekmeister> @src *
14:23:00 <lambdabot> Source not found. You untyped fool!
14:23:05 <tehgeekmeister> @src (*)
14:23:05 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:23:28 <yitz> tehgeekmeister: (*) is a variable in that definition
14:23:37 <tehgeekmeister> yitz: that's allowed?
14:23:45 <yitz> looks like it
14:23:51 <tehgeekmeister> weird.
14:23:58 <Heffalump> mathijs: try adding NoMonomorphismRestriction to the LANGUAGE pragma
14:24:12 <tehgeekmeister> oh i get how it works now
14:24:14 <tehgeekmeister> that's a cool function
14:24:16 <tehgeekmeister> i often want it
14:24:18 <yitz> yep
14:24:23 <tromp> @pl \x->x
14:24:23 <lambdabot> id
14:24:24 <tehgeekmeister> now i have it.
14:24:33 <tromp> @pl \x->f x == gx
14:24:33 <lambdabot> (gx ==) . f
14:24:39 <tromp> @pl \x->f x == g x
14:24:39 <lambdabot> liftM2 (==) f g
14:24:47 <mathijs> Heffalump: thanks, works
14:24:55 <tehgeekmeister> is there a reverse compare?
14:25:01 <tehgeekmeister> i don't want to do reverse . sort
14:25:05 <mathijs> Heffalump: I guess the writers have that on by default maybe
14:25:08 <Heffalump> mathijs: ok, so it seems GHC is defaulting types to Any for some reason
14:25:21 <yitz> tehgeekmeister: sortBy (flip compare)
14:25:47 <tehgeekmeister> so in my case sortBy ((flip compare) `on` snd)
14:25:54 <tehgeekmeister> (making sure i combine that all right)
14:26:10 <yitz> looks good
14:26:43 <yitz> tehgeekmeister: on is in Data.Function
14:26:52 <tehgeekmeister> yeah, i imported it
14:26:54 <tehgeekmeister> =]
14:26:55 <tehgeekmeister> thanks
14:27:28 <yitz> tehgeekmeister: you don't need the parens around flip compare
14:27:31 <augustss_> tehgeekmeister: no need for the extra parens, sortBy (flip compare `on` snd)
14:27:42 <tehgeekmeister> oh yeah, that's true
14:27:42 <yitz> heh. hi augustss_
14:27:49 <tehgeekmeister> i always add extra parens when in doubt
14:27:51 <augustss_> Stereo!
14:27:51 <tehgeekmeister> but you're right
14:28:09 <augustss_> @quote stereo
14:28:09 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
14:28:47 <tromp> roconnor: you prefer this Equality instance?
14:29:09 <ziman> @quote fugues
14:29:09 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:29:38 <michaelcdever> Heffalump: cheers, got my program working properly now :D
14:30:20 <Heffalump> michaelcdever: cool
14:30:21 <augustss_> @quote mono
14:30:21 <lambdabot> kilimanjaro says: the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in like
14:30:21 <lambdabot> 10 days!"
14:32:31 <pumpkin> wow, epic speedup
14:33:03 <roconnor> tromp: I didn't object to your old Eq instance.  I just found it bizarre. :)
14:33:14 <roconnor> or striking
14:33:18 <roconnor> or notable
14:33:24 <roconnor> or something like that
14:33:31 <tromp> so is this one less bizarre?
14:33:36 <roconnor> maybe unusual is the right word
14:33:43 <tromp> i updated it
14:33:53 <roconnor> tromp: that would be more normal
14:33:56 <roconnor> @src any
14:33:56 <lambdabot> any p =  or . map p
14:34:00 <roconnor> @src all
14:34:00 <lambdabot> all p =  and . map p
14:34:10 <roconnor> you can use all instead of and . map p
14:34:26 <tromp> ah yes, thx
14:35:01 * pumpkin loves haskell... took an already pretty decent runtime from 4:40 to 0:40 with very little work
14:36:15 <conal> pumpkin: woot!
14:36:32 <pumpkin> and this was after I was already using -O2 and fusion :)
14:36:40 <pumpkin> I made more things fusible, changed command-line parameters, and bam
14:38:06 <kyagrd> Hi, any of you guys using lhs2TeX in Windows?
14:38:17 <kyagrd> with MikTeX of course ...
14:38:39 <conal> kosmikus: ping
14:39:14 <kyagrd> I'm havin an issue co-working with my prof somehow in his machine strange error comes out related to \SetToFmtEnd :(
14:40:23 <conal> kosmikus: in lhs2TeX, i added "..." under a list of GADT constructors, and it made my constructors all centered.  only when the "..." is aligned with the constructors.  am i triggering a feature?
14:41:00 <sbahra> kosmikus = author?
14:41:26 <sbahra> Appears so. :)
14:45:42 <kmeyer> anyone know of an LGPL or GPL package on Hackage?
14:47:25 <glguy> hdbc?
14:47:33 <kmeyer> readline is GPL :)
14:48:24 * Heffalump has been fixing up HAllInOne
14:48:28 <mathijs> what does fmap do for the IO monad?
14:48:37 <Cheshire> what's HAllInOne?
14:48:45 <Heffalump> it merges Haskell modules into a single module
14:49:00 <Heffalump> unfortunately, it's licensed under the big-kazooba-ritual licence, which might preclude me hackaging it
14:49:57 <monochrom> fmap for IO does this: fmap f m = do { y <- m; return (f y) }.
14:50:02 <Draconx|Laptop> mathijs, same thing as liftM.
14:50:10 <ddarius> Yes, there was a big hubbub about the license a long while ago.
14:50:17 <mathijs> Draconx|Laptop, monochrom: thanks
14:50:21 <monochrom> Oh yeah fmap is liftM.
14:51:14 <augustss_> who wrote it?
14:51:21 <ddarius> Hal Daume III
14:51:37 <augustss_> Ah, ok
14:52:29 <sjanssen> Heffalump: big-kazooba-ritual?
14:53:10 <Heffalump> google it
14:53:59 <sjanssen> Heffalump: huh
14:54:02 <Heffalump> it has a big, you end up standing on one leg
14:54:05 <Heffalump> s/big/bug/
14:54:17 <yitz> @go big-kazooba-ritual
14:54:18 <lambdabot> No Result Found.
14:54:19 <gueux> ok, I've forgotten my ideas of generalize the definition of a game :-)
14:54:26 <yitz> @go big-kazooba-ritual
14:54:26 <lambdabot> No Result Found.
14:54:30 <sjanssen> the author should know that licenses are Serious Business
14:54:33 <gueux> now, I'd like to code a little server for my game
14:54:36 <Heffalump> bottom of http://www.mail-archive.com/haskell-cafe@haskell.org/msg03051.html
14:54:40 <gueux> what should I use?
14:54:59 <Heffalump> I did email him last week and ask if I could perhaps perform a mega-kazooba-ritual to discharge the conditions once and for all, but no reply
14:55:00 <yitz> gueux: haskell
14:55:27 <gueux> yitz: :-)
14:55:36 <monochrom> Yay! May I draft my own license requiring you to join my religion first? :)
14:55:48 <gueux> I mean is there a library to do that? :-)
14:56:18 <yitz> gueux: various, depending on exactly what you want to do
14:56:21 <sOpen> How would I provide a sandbox for users to submit Haskell code to run?
14:56:24 <Heffalump> monochrom: have you written any useful software?
14:56:32 <monochrom> General definition of game: [a] -> [a]
14:56:46 <monochrom> Yes.
14:56:48 <Heffalump> HAllInOne turns out to be somewhat buggy and a bit hard to fix, so I think if I have a continuing need for it I will just rewrite it anyway.
14:56:55 <Heffalump> monochrom: then yes :-)
14:57:20 <kyagrd> I found out the reason
14:57:23 <gueux> yitz: I ultimately want to do a web-based turn by turn game
14:57:56 <thetallguy> argh, some has turned 'point-free' into a verb:  As a rule of thumb, once your expression becomes too long to easily be point-freed, it probably deserves a name anyway.
14:58:11 <kyagrd> On windows, if you install lhs2TeX using cabal and use it with MikTeX, MikTeX do not seem to find the style file.
14:58:47 <kyagrd> So, you should copy the fmt. sty files of lhs2TeX to your document directory or somewhere MikTeX can see
14:58:58 <sOpen> I've tried googling "haskell sandbox" and related terms but so far haven't found anything useful. It must have been done before, though, right?
14:59:04 <gueux> my game is coded, now I want to do a server such that a I will be able to code a web client later
14:59:22 <yitz> gueux: fast cgi is "simplest" in a certain sense. HApps (they changed the name, what's it called now?) is a general platform for building servers ala Python twisted. various other things in between.
14:59:32 <pejo> kyagrd, on unix you can set the environment variable TEXINPUTS to make it look in more directories, but I've never used miktex.
14:59:46 <yitz> thetallguy: the first to turn it into a verb was lambdabot
15:00:04 <gueux> yitz: ok
15:00:09 <Lemmih> sOpen: There's not a lot to it. Don't allow IO and impose limits on memory and CPU usage.
15:00:12 <gueux> let's try fast cgi
15:00:14 <gueux> :-)
15:00:52 <Heffalump> sOpen: basically you have to work with source, and you need to fork
15:00:52 <Saizan> there was a page on the wiki about gotchas in sandboxing haskell
15:01:06 <sOpen> Lemmih, so I need to parse the Haskell to disallow IO? then throw it in a new process with caps on resources? Or is there already a "safeEval" fn somewhere?
15:02:07 <thetallguy> yitz: the end is near
15:02:08 <Saizan> sOpen: mueval is such a sandbox, though the limiting of resources is not enabled by default since the haskell binding to rlimits seem to segfault on many machines
15:02:18 <Saizan> sOpen: you can find it on hackage
15:02:25 <sOpen> Saizan, !!! awesome
15:02:57 <yitz> thetallguy: the singularity is coming :0
15:03:09 <Saizan> sOpen: to disallow IO you just need to force the result to be of a pure type, and make sure you're not importing things like unsafePerformIO, unsafeIOtoST etc..
15:03:34 <McManiaC> i dont really get what seq does... why does it take 2 arguments? it looks to me as if the first is getting totally ignored?
15:03:53 <monochrom> The first is evaluated and ignored.
15:03:56 <augustss_> McManiaC: evaluated, then ignored
15:04:22 <yitz> McManiaC: you won't feel like it is ignored if it hangs, or throws an exception
15:04:46 <augustss_> > seq (error "BOO") 42
15:04:46 <Saizan> "e = a `seq` b" means that the outermost constructor of 'a' must be evaluated before you can look at the value of 'e'
15:04:47 <lambdabot>   * Exception: BOO
15:04:56 <McManiaC> yitz: so the first is like a "validation" evaluation for the second?
15:05:16 <augustss_> > let notSeq a b = b in notSeq (error "BOO") 42
15:05:17 <lambdabot>   42
15:05:29 <yitz> McManiaC: yes, but it is usually used more as a way to override laziness
15:06:27 <Draconx|Laptop> @src ($!)
15:06:27 <lambdabot> f $! x = x `seq` f x
15:06:29 <gueux> I have an error when I try to install fastcgi
15:06:31 <gueux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1498#a1498 [+]
15:07:08 <tehgeekmeister> does the prelude have analogs of fst snd and whatnot for larger sized tuples?
15:07:17 <yitz> tehgeekmeister: nope
15:07:34 <lament> cddddddar
15:07:36 <augustss_> tehgeekmeister: if you feel you need that, you should be using a record
15:07:51 <McManiaC> :S
15:08:00 <monochrom> Here is a typical use of seq: the two parameters you give are actually related. For example 「let x=3+5 in seq x [x]」.
15:08:20 <tehgeekmeister> augustss_: yeah you're probably right, but it's quick hacking so i'm not inclined to do that.
15:08:23 <monochrom> The first parameter is part of the second. That's when seq really flies.
15:08:23 <augustss_> monochrom: snazzy quotes!
15:08:37 <Heffalump> tehgeekmeister: that kind of thinking leaves you with 12-tuples :-)
15:08:52 <tehgeekmeister> Heffalump: i'm only at 3-tuples so far.  =P
15:08:55 * augustss_ admits guilt.
15:09:37 <yitz> gueux: as tu un servier avec fastcgi? oops, english
15:09:43 <tehgeekmeister> i tried to just use a list, since that would've served my needs
15:09:56 <tehgeekmeister> but the switch from a list to a tuple caused problems for some reason
15:10:01 <tehgeekmeister> err, vice versa
15:10:16 <tromp> did you leave credit suisse, augustss?
15:10:20 <tehgeekmeister> apparently sortBy (compare `on` head) doesn't work
15:10:21 <pejo> @hoogle unzip3
15:10:21 <lambdabot> Prelude unzip3 :: [(a, b, c)] -> ([a], [b], [c])
15:10:21 <lambdabot> Data.List unzip3 :: [(a, b, c)] -> ([a], [b], [c])
15:10:31 <pejo> Clearly we're meant to write triples!
15:10:32 <augustss_> tromp: I did
15:10:35 <Heffalump> tehgeekmeister: in what way doesn't it work?
15:10:40 <tromp> voluntarily?
15:10:53 <yitz> tromp: personal question
15:11:03 <tromp> yes, rather
15:11:07 <augustss_> tromp: yes, before the big bad times
15:11:09 <tehgeekmeister> Heffalump: it gave me an error about trying to construct an infinite type
15:11:26 <Heffalump> @type sortBy (compare `on` head)
15:11:27 <lambdabot> forall a. (Ord a) => [[a]] -> [[a]]
15:11:29 <tehgeekmeister> *wishes he understood all these type errors
15:11:31 <Heffalump> looks ok to me
15:11:36 <ddarius> Heffalump: I would recommend rewriting HAllInOne if you do care to include it in Hackage.
15:11:38 <augustss_> tehgeekmeister: if you're sorting lists of lists it should work
15:11:38 <gueux> yitz: en français ça va aussi :-)
15:11:39 <Heffalump> so whatever error you had was elsewhere
15:11:46 <tromp> any trouble finding a new job?
15:11:47 <tehgeekmeister> but i found a copy of TAPL, so i should be able to understand better soon.
15:11:50 <tehgeekmeister> augustss_: i was.
15:11:53 <yitz> @type sortBy (comparing head)
15:11:54 <lambdabot> forall a. (Ord a) => [[a]] -> [[a]]
15:12:01 <Heffalump> ddarius: well, I can hardly upload it to Hackage with that licence, unless I can persuade the archive maintainers to undergo the ritual...
15:12:20 <Liskni_si> is there any particular reason why executables in a cabal package need to recompile all modules even though they're in a library exported by that package?
15:12:26 <augustss_> > sortBy (compare `on`head) ["a","ba"]
15:12:27 <lambdabot>   ["a","ba"]
15:12:35 <yitz> gueux: but that would have to be in #haskell.fr :)
15:14:12 <coco`> pumpkin: did you use excess precision as a pgragma or on the command line/
15:14:14 <coco`> ?
15:15:19 <gueux> yitz: I haven't thought to that problem
15:15:26 <yitz> gueux: from the hackage page for fastcgi: "The FastCGI C development kit is required to build this library."
15:16:00 <yitz> gueux: so you need that to compile your haskell. then you need a fastcgi server to run it on. :)
15:16:25 <tehgeekmeister> augustss_: so i must've been doing something else weird too?
15:16:43 <augustss_> tehgeekmeister: yes
15:19:53 <jacobian> is there a way to do debugging printing in hugs?  I'm currently using observe but it only prints out a short string.
15:20:17 <dmwit> ghci has a proper debugger...
15:20:32 <dmwit> I don't know much about Hugs; does it have Debug.Trace?
15:20:56 <ddarius> Debug.Trace is cross-platform
15:21:20 <tehgeekmeister> has anyone here used happs-ixset outside of happs?
15:23:04 <gueux> in fact the server would have to: .start a game when two clients are connected to the same game .send the datas to the clients concerning the actual game (status->ended or not,winner, board, turn,...) .transmit the moves chosen by the clients to the game
15:23:22 <gueux> is fastcgi the good thing to do that?
15:24:01 <gueux> tromp: have you coded such a thing for your go game?
15:25:01 <tromp> nope, geux
15:25:07 <yitz> gueux: hmm. you would need to store the state of your game somewhere, and restart the game each time someone hits the server.
15:33:23 <Saizan> ?seen mmorrow
15:33:23 <lambdabot> I saw mmorrow leaving #ghc and #haskell 23d 4h 9m 31s ago, and .
15:33:31 <Saizan> preflex: seen mmorrow
15:33:32 <preflex>  mmorrow was last seen on #haskell 18 hours, 49 minutes and 34 seconds ago, saying: A
15:36:47 <ksf> shouldn't Functors be generalised over arity like functions are?
15:37:17 <monochrom> Bifunctor, Trifunctor, ...
15:37:44 <dibblego> what's a common example of a Trifunctor?
15:37:48 <dibblego> besides (,,)
15:37:55 <ksf> add2, add3, add4, add5...
15:38:01 <dibblego> @type add2
15:38:02 <lambdabot> Not in scope: `add2'
15:38:05 <monochrom> somehow only functor and bifunctor have found uses.
15:38:36 <ksf> well, there are functions with triple return values, so trifunctors have a use.
15:39:19 <dibblego> I could imagine Either a (Either b c)
15:39:34 <ksf> that's a double bifunktor.
15:39:56 <ksf> ...and that's were the generalisation is.
15:40:03 <dibblego> newtype Z a b c = Z Either a (Either b c)
15:40:18 <ksf> (,,) is the same as (,(,)), modulo _|_.
15:40:26 <dibblego> right
15:40:36 <ddarius> What we need are product kinds.
15:40:38 <ksf> ...and ((,),)
15:41:23 * Heffalump wants kind aliaes
15:41:25 <Heffalump> aliases
15:41:39 * ddarius wants System Fω.
15:42:02 <ksf> there's http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html#t%3ABifunctor
15:42:26 <ddarius> Actually, I want more than System Fω.
15:43:17 * ddarius wants the polymorphic lambda calculus with products and such at the type level.
15:43:45 <ksf> at some point, making a difference between code and types becomes as hilarious as the "difference" between code and data.
15:44:05 <ksf> ...as every schemer who ever used tagged-list knows.
15:44:24 <ddarius> A tagged list isn't typed.
15:44:45 <moonlite_> ksf: what is a tagged list?
15:45:01 <moonlite_> (if it is easily explained :))
15:45:12 <ksf> basically, [(Key,Value)]
15:45:19 <moonlite_> ah
15:45:23 <Japsu> Data.Map
15:46:21 <ksf> Maybe I should start taking learning agda seriously.
15:47:39 <monochrom> System-Fω-Fu
15:48:52 <pumpkin> coco`: command-line
15:48:59 <pumpkin> why?
15:49:09 <silkarn> what would have to happen for a pure haskell function to fail? hardware error?
15:49:29 <pumpkin> silkarn: not necessarily
15:49:31 <pumpkin> silkarn: what's failing?
15:50:09 <moonlite_> > head []
15:50:10 <lambdabot>   * Exception: Prelude.head: empty list
15:50:24 <skorpan> well...
15:50:29 <moonlite_> silkarn: not all functions are defined for all possible inputs. Head for example
15:50:41 <skorpan> doesn't head use "error" explicitly?
15:50:49 <cocacolaloca> can some one help me  figure out a program
15:51:09 <ddarius> > let head (x:_) = x in head []
15:51:10 <lambdabot>   * Exception: /tmp/7748203728606223960:71:36-49: Non-exhaustive patterns in ...
15:51:18 <skorpan> yeah, that's more like it!
15:52:15 <cocacolaloca> I need to figure out the calculations needed for a program that displays the weeks days and hours a person worked from an input of hours
15:52:50 <ddarius> Divide by 24, divide by 7
15:53:39 <cocacolaloca> example if the input is 135 the program should display 3 weeks, 0 days, 15 hours
15:54:23 <moonlite_> cocacolaloca: use a combination of "div" and "mod".
15:54:32 <moonlite_> (together with 24 and 7)
15:54:34 <ddarius> such as divMod
15:54:46 <ddarius> moonlite_: Apparently he is using 40 hour work-weeks.
15:54:51 <moonlite_> ddarius: ah
15:54:58 <moonlite_> and ah again
15:55:08 <cocacolaloca> yeah
15:55:30 <shapr> roconnor: You called?
15:55:48 <cocacolaloca>  can you give me an example of code
15:56:16 <moonlite_> cocacolaloca: any example would be a finished implementation, is this school work?
15:56:32 <monochrom> It is in fact safe to give the Haskell code for that, friends. For the question appeared originally in #math and c++ code was asked for. No harm in giving Haskell code!
15:56:51 <moonlite_> ah
15:57:22 <cocacolaloca> yeah I'm learning C++, at Devry online
15:58:03 <monochrom> But yeah how is 135 hours more than 3 weeks?
15:58:27 <monochrom> Should I just divide 135 by 40?
15:58:27 <cocacolaloca> is haskell another computer language?
15:58:32 <moonlite_> monochrom: 40 hour work weeks apparently
15:58:39 <cocacolaloca> yeah
15:59:20 <ksf> dammit, what's the module called that gives me /dev/lp0? i've got parport, but nothing is showing up...
15:59:21 <cocacolaloca> if i divide 135 by 40 I should get 3.5
15:59:33 <newsham> ?seen bmeph
15:59:33 <lambdabot> bmeph is in #haskell-in-depth, #haskell-blah, #ghc, #concatenative, #haskell-overflow and #haskell. I don't know when bmeph last spoke.
16:00:04 <cocacolaloca> but that's not a good value for the week output
16:00:38 <monochrom> > let {(weeks,remains) = 135 `divMod` 40; (days,hours) = remains `divMod` 24} in (weeks,days,hours)
16:00:39 <lambdabot>   (3,0,15)
16:01:03 <ddarius> monochrom: Now run it through @pl
16:01:04 <monochrom> But it's really odd that you use 40 hours a week but not 8 hours a day.
16:01:29 <monochrom> @pl \x y -> let {(weeks,remains) = x `divMod` y; (days,hours) = remains `divMod` 24} in (weeks,days,hours)
16:01:29 <lambdabot> (line 1, column 13):
16:01:29 <lambdabot> unexpected "{"
16:01:29 <lambdabot> expecting "()", natural, identifier or "in"
16:01:38 <cocacolaloca> you're right is 8 hour days
16:01:46 <monochrom> It doesn't know { !
16:02:00 <monochrom> @pl \x y -> let (weeks,remains) = x `divMod` y in let (days,hours) = remains `divMod` 24 in (weeks,days,hours)
16:02:00 <lambdabot> (line 1, column 13):
16:02:00 <lambdabot> unexpected "("
16:02:00 <lambdabot> expecting "()", natural, identifier or "in"
16:02:09 <monochrom> It doesn't know stuff.
16:02:20 <monochrom> > let {(weeks,remains) = 135 `divMod` 40; (days,hours) = remains `divMod` 8} in (weeks,days,hours)
16:02:21 <lambdabot>   (3,1,7)
16:02:36 <monochrom> 3 weeks 1 day 7 hours.  (Almost 3 weeks 2 days.)
16:03:18 <cocacolaloca> is divmod the same as the % operator in C++ ?
16:03:42 <lament> :t divmod
16:03:43 <lambdabot> Not in scope: `divmod'
16:03:48 <lament> oh
16:03:53 <lament> :t divMod
16:03:54 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
16:03:54 <monochrom> No. divMod is the same as doing both / and % in C++ at the same time. Except of course C++ is incapable of that "same time" part.
16:04:15 <monochrom> > 10 `divMod` 3
16:04:16 <lambdabot>   (3,1)
16:04:21 <lament> cocacolaloca: i think the C++ operator works for floats as well as integers.
16:04:25 <monochrom> quotient 3, remainder 1.
16:05:22 <ozy`> @src div
16:05:22 <lambdabot> Source not found. Maybe you made a typo?
16:05:26 <ozy`> psh
16:05:32 <ozy`> @src divMod
16:05:32 <lambdabot> Source not found. Do you think like you type?
16:05:44 <monochrom> It doesn't know a lot of the source code.
16:05:47 <ozy`> I figured one might be defined in terms of the other
16:05:49 <ozy`> oh well
16:06:05 <ksf> menuconfig needs a text search. urgently.
16:06:07 <monochrom> You are right.
16:07:46 <cocacolaloca> thanks mono that was helpful
16:08:58 <dsrogers> does runghc have a -e option for taking your program from the command line?
16:09:07 <dsrogers> or runhaskell even?
16:09:30 <int-e> dsrogers: ghc itself does.
16:10:08 * dsrogers goes and looks
16:10:08 <dsrogers> thanks
16:11:53 <ozy`> dsrogers: ghc -e 'putStrLn $ cycle "DESU "'
16:12:26 <pumpkin> what's with the DESU?
16:12:53 <pumpkin> > "DESU " ++ cycle "NEE? "
16:12:54 <lambdabot>   "DESU NEE? NEE? NEE? NEE? NEE? NEE? NEE? NEE? NEE? NEE? NEE? NEE? NEE? NEE?...
16:12:55 <skorpan> say that i want to take a list of 100 million Ints and sort it, how would i do that without thrashing my computer?
16:13:39 <int-e> skorpan: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/external-sort perhaps (I've never looked at it)
16:13:51 <int-e> (only saw the announcement)
16:14:03 <JavamobileHlp> hey guys. Glad to find a programming chat room. Could someone help me. I have some knowledge in java, and i could use some free ebooks or tutorials on java-based programs for mobile phones. I tried Google but i didnt had much luck. Could anyone help me out please?
16:14:40 <pumpkin> JavamobileHlp: this is not a programming chat room, it's a haskell chat room :P
16:15:06 <int-e> skorpan: I guess mutable, unboxed arrays will do the trick, too. but with lists that is pretty hopeless - you'll need a few gigs of memory (4? 8? or more?).
16:15:16 <monochrom> I recommend learning Haskell first. Then Java is easy.
16:15:42 <int-e> monochrom: no, it'll be hard to learn that programs generally don't work just because they compile ;)
16:15:42 <skorpan> int-e: right, "list" was my generic term for "container with an order" :)
16:15:53 <JavamobileHlp> uh im sorry for wrong room. I know Java already and i need just some basics how to do it on mobile phones :)
16:16:07 <skorpan> JavamobileHlp: go to ##java
16:16:12 <JavamobileHlp> ok thank you
16:16:45 <pumpkin> how do people type /join #haskell and not think something's funny when they ask about java
16:16:52 <pumpkin> :)
16:17:06 <skorpan> i thought it was a troll
16:17:54 * ksf prints the pisigma paper
16:18:33 <ksf> actually, he was in the right room. I happen to be a j2me expert.
16:19:00 <dsrogers> yeah, I could have given loads on java.
16:19:07 * dsrogers points out he's not in #java
16:20:07 <ksf> ...the most interesting thing I could talk about is preprocessing java into something without objects, to save jar size and have better run-time performance.
16:20:17 <ksf> it's funny that a jvm sucks at managing objects.
16:20:27 <nikanj> He must've heard you braggin'
16:21:01 <JavamobileHlp> can someone tell me server and port of this chat room?
16:21:03 <JavamobileHlp> =)
16:21:39 <lament> can somebody tell me what century is it?
16:21:39 <int-e> http://freenode.net/irc_servers.shtml
16:21:40 <dsrogers> it's not unique.
16:21:55 <dsrogers> lament: 21st.
16:21:58 <ksf> 127.0.0.1:31137
16:22:16 <JavamobileHlp> ah programmers humor...
16:22:51 <NameAlreadyInUse> what is the idea behind liftM, etc?
16:23:01 <ksf> @src liftM
16:23:01 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:23:10 <pumpkin> NameAlreadyInUse: do you get fmap?
16:23:15 <dsrogers> it's fmap.
16:23:25 <dsrogers> "do this function inside the container"
16:23:30 <NameAlreadyInUse> pumpkin: no
16:23:31 <NameAlreadyInUse> oh ok
16:23:49 <NameAlreadyInUse> but doesn't bind do that?
16:23:52 <dsrogers> no.
16:24:25 <dsrogers> bind ties two actions together.  fmap takes a pure function and sticks it inside your container.
16:24:38 <dsrogers> you can fmap on a list, for example.  That's just map.
16:24:59 <wli> fmap used to be called map
16:25:04 <NameAlreadyInUse> and bind is concatMap?
16:25:10 <pumpkin> NameAlreadyInUse: only for lists
16:25:29 <NameAlreadyInUse> yeah, i know
16:26:06 <Olathe> @pl \f x -> x >>= return . f
16:26:06 <lambdabot> fmap
16:26:15 <wli> The Great Polymorphic Scare of H98 screwed up the standard Prelude beyond repair.
16:26:25 <dsrogers> huh?
16:26:26 <Olathe> zomg polymorphism !
16:26:28 <Olathe> RUN !
16:26:41 <NameAlreadyInUse> what do you mean, wli?
16:26:43 <wli> It will probably take another language outright to repair it.
16:26:44 <dsrogers> you mean the reason there is liftM and fmap and map?
16:26:49 <ksf> as in "ZOMG people could discover List is a Functor!"
16:26:55 <Olathe> They could have made map work on more than lists.
16:27:02 <Olathe> And all sorts of other fun things, too.
16:27:17 <ksf> http://www.haskell.org/haskellwiki/The_Other_Prelude
16:27:23 <ksf> notice (.) = map
16:27:29 <silkarn> what would have to happen for a pure haskell function to fail? hardware error? <- I mean to fail during execution. obv it fails given the wrong input or input it isnt designed for
16:28:00 <ksf> silkarn, that's the point. haskell function's aren't total.
16:28:04 <fortranhelp> Anyone here familiar with fortran
16:28:08 <fortranhelp> I need help
16:28:28 <pumpkin> are you serious?
16:28:38 <pumpkin> is #haskell listed somewhere as the generic programming help channel? :P
16:28:44 <wli> instance Functor Maybe where fmap f x = case x of Just x' -> Just f x' ; Nothing -> Nothing
16:28:55 <fortranhelp> haha no
16:28:59 <ksf> another thing that can trip you up is the wrong kind of concurrency, infinite loops (same topic as totality), and ...
16:29:04 * ksf forgot something.
16:29:12 <fortranhelp> But if you know of a programming help site
16:29:15 <banisterfiend> what's going on inside my pants i can't explain
16:29:22 <fortranhelp> Id greatly apprecite u giving me it
16:29:25 <NameAlreadyInUse> i'm pretty sure there is a fortran channel
16:29:27 <Olathe> > let f undefined = 5 in f undefined
16:29:28 <lambdabot>   5
16:29:28 <pumpkin> fortranhelp: a few minutes ago someone called Javamobilehlp came in here asking for java help :P this is haskell/sparta!
16:29:32 <Olathe> Yay !
16:29:39 <Olathe> > let f undefined = 5; f x = 6 in f undefined
16:29:40 <lambdabot>   mueval: Prelude.read: no parse
16:29:40 <lambdabot>  mueval: UnknownError "GHC reported errors a...
16:29:44 <Olathe> Aww :(
16:30:01 <pumpkin> Olathe: the first undefined is not the value undefined :P
16:30:09 <Olathe> Ehh ?
16:30:14 <pumpkin> it's just a bound name :P
16:30:20 <sub_zenith> ?DCC SEND "ff???f?" 0 0 0
16:30:20 <lambdabot> Unknown command, try @list
16:30:24 <Olathe> Ahh.
16:30:28 <pumpkin> bah
16:30:42 <pumpkin> did sub_zenith just kill all those people?
16:30:48 <sub_zenith> ?DCC SEND "ff???f?" 0 0 0
16:30:48 <lambdabot> Unknown command, try @list
16:30:53 <sub_zenith> lawlawlawl
16:30:53 <pumpkin> wow
16:30:55 <pumpkin> @where ops
16:30:55 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
16:30:57 <sub_zenith>   _   _ ___ ____  ____ _____ ____  ____
16:30:57 <sub_zenith>  | \ | |_ _/ ___|/ ___| ____|  _ \/ ___|
16:30:57 <sub_zenith>  |  \| || | |  _| |  _|  _| | |_) \___ \
16:30:57 <sub_zenith>  | |\  || | |_| | |_| | |___|  _ < ___) |
16:31:01 --- mode: ChanServ set +o Cale
16:31:02 <sub_zenith>  |_| \_|___\____|\____|_____|_| \_\____/
16:31:05 --- mode: Cale set +b *!*@dyn56-188.res-hall.ndsu.NoDak.edu
16:31:05 --- kick: sub_zenith was kicked by Cale (Cale)
16:31:09 <NameAlreadyInUse> lol
16:31:19 <banisterfiend> pumpkin: no longer see you in #ruby-lang, is #haskell your new home? :)
16:31:25 <pumpkin> banisterfiend: yeah :)
16:31:25 <skorpan> *** sub_zenith is on channel(s): ##c++
16:31:30 <pumpkin> got tired of zenspider ;)
16:31:41 <banisterfiend> pumpkin: what's haskell like?
16:31:49 <pumpkin> banisterfiend: best thing since orgasms
16:31:53 <banisterfiend> hehe
16:32:07 <glguy> benny, /whois sub_zenith
16:32:08 <ksf> banisterfiend, http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
16:32:13 <banisterfiend> what are you using it for? purely academic/intellectual things or are you actually writing projects/a  project in it?
16:32:14 <glguy> ...
16:32:31 <pumpkin> banisterfiend: both :)
16:32:43 <skorpan> i've only used it for academical purposes so far, but i'm currently doing my master thesis about a javascript-mode for the yi editor... okay, i guess that's academical too.
16:32:43 <banisterfiend> what you working on?
16:32:53 <banisterfiend> hehe
16:32:55 <skorpan> but i have started writing a syntax highlighter for the conkeror web browser in haskell
16:33:19 <pumpkin> banisterfiend: machine learning stuff for research, and a bunch of sekrit side projects in the two minutes of free time I get a day (fine, fine, I IRC a lot too)
16:33:20 <NameAlreadyInUse> @src foldM
16:33:20 <lambdabot> foldM _ a []     = return a
16:33:20 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:34:17 <yitz> banisterfiend: pumpkin integrated a useful irc bot written in haskell
16:34:26 <pumpkin> I did? :o
16:34:44 <banisterfiend> cool
16:34:51 * pumpkin looks confused
16:34:54 <banisterfiend> pumpkin: how long you been learning haskell?
16:34:56 <yitz> hehe
16:35:10 <pumpkin> banisterfiend: just passed my 2-month mark :)
16:35:31 <skorpan> you've been using haskell for TWO MONTHS?
16:35:35 <banisterfiend> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html seems more like a nerd fantasy....which computer nerds do you know have a 'hot exotic girl' as well as a 'regular one' ?! hehe, funny reading nonetheless :)
16:35:56 <skorpan> i first started learning haskell almost five years ago and i still don't get it :P
16:35:56 <pumpkin> skorpan: am I slow?
16:35:59 <pumpkin> ah lol
16:36:04 <ozy`> banisterfiend: does green hair count as "exotic?"
16:36:09 <banisterfiend> yep!
16:36:15 <ozy`> >_>
16:36:16 <ozy`> <_<
16:36:21 <banisterfiend> hehe
16:37:04 * ozy` refreshes
16:37:06 <ozy`> aww, still in memphis
16:37:08 * ozy` refreshes
16:37:10 <pumpkin> , [$ty| foldlU |]
16:37:11 <ozy`> aww, still in memphis
16:37:12 <NameAlreadyInUse> can someone give me a simple example of foldM?
16:37:13 <lunabot>  forall a b . UA a => (b -> a -> b) -> b -> UArr a -> b
16:37:15 <NameAlreadyInUse> (in use)
16:38:31 <bremner> what is the deal with ghc-extralibs? do most people build them?
16:38:37 <yitz> @type foldM
16:38:38 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:39:00 <NameAlreadyInUse> i know the type, i just can't picture its use
16:39:21 <skorpan> i almost made use of it today
16:39:25 <dobblego> I used it the other for traversing a tree in IO
16:39:29 <dobblego> *the other day
16:39:34 <skorpan> i wanted to read the contents from a list of file names and concat the results
16:39:44 <skorpan> couldn't figure out the arguments so i failed :(
16:41:22 <NameAlreadyInUse> ok, i think i've got it now
16:41:37 <skorpan> i'm actually not sure foldM is usable for my case, because as i said, i failed at using it
16:42:02 <skorpan> :t foldM
16:42:03 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:42:06 <NameAlreadyInUse> skorpan: yes, have managed to get it to work but i have no idea what it might be used for
16:42:09 <skorpan> :t foldl
16:42:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:42:29 <skorpan> so basically it's useful for any cases where you use foldl, but for monadic functions
16:42:43 <hackage> Uploaded to hackage: xcb-types 0.4.0
16:42:44 <pumpkin> > foldM (\x y -> [x + y]) 0 [1..10]
16:42:45 <pumpkin> :P
16:42:45 <lambdabot>   [55]
16:42:51 <helgim_> > 0.8 + 5.6
16:42:52 <lambdabot>   6.3999999999999995
16:42:55 <pumpkin> completely uninteresting example :)
16:43:04 <skorpan> pumpkin: seriously, two months? :o
16:43:17 <skorpan> i'm impressed
16:43:24 <NameAlreadyInUse> pumpkin: any interesting examples for us? :)
16:43:27 <pumpkin> skorpan: lol, thanks
16:43:40 <pumpkin> NameAlreadyInUse: hmm
16:43:49 <Olathe> @src Functor
16:43:49 <lambdabot> class  Functor f  where
16:43:49 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:44:05 <Olathe> Ah hah !
16:44:36 <banisterfiend> is lazy evaluation the same as 'normal order' for parameter passing (as opposed to applicative order)
16:44:49 <pumpkin> NameAlreadyInUse: here's a bad example
16:44:50 <pumpkin> foldM (\x y -> putStrLn ("you typed " ++ x) >> getLine) "nothing" [1..10]
16:44:55 <ddarius> banisterfiend: It's an implementation method for normal order evaluation.
16:45:05 <yitz> > runState (foldM (\x y -> do modify (+y); return (y:x)) [] [1..10]) 0
16:45:06 <lambdabot>   ([10,9,8,7,6,5,4,3,2,1],55)
16:45:32 <skorpan> @pl \x y -> putStrLn ("you typed " ++ x) >> getLine
16:45:33 <lambdabot> const . (>> getLine) . putStrLn . ("you typed " ++)
16:45:37 <skorpan> that's better
16:45:49 <pumpkin> if you say so :P
16:46:08 <NameAlreadyInUse> pumpkin: cool
16:46:23 <helgim_> Let's say I actually wanted 0.8+5.6 to be evaluated to 6.4 - what does one do?
16:46:34 <pumpkin> helgim_: try CReal
16:46:35 <banisterfiend> ddarius: who do you think would win in a fight, haskell or scheme
16:46:36 <monochrom> lazy evaluation contains both normal order and a constraint on how many times an expression is evaluated.
16:46:40 <pumpkin> > 0.8 + 5.6 :: CReal
16:46:41 <lambdabot>   6.4
16:46:53 <helgim_> Ah. thanks :)
16:46:54 <ozy`> > 0.8 :: Ratio
16:46:55 <lambdabot>       `Ratio' is not applied to enough type arguments
16:46:55 <lambdabot>      Expected kind `?',...
16:46:57 <yitz> banisterfiend: see the great language shootout
16:46:57 <ozy`> whoops
16:47:00 <ozy`> > 0.8 :: Rational
16:47:01 <lambdabot>   4%5
16:47:02 <pumpkin> in fact, rational is probably even better
16:47:14 <ozy`> > (0.8 + 5.6) :: Rational
16:47:15 <lambdabot>   32%5
16:47:36 <monochrom> I think Scheme already wins because it has successfully avoided success.
16:48:08 <ozy`> monochrom: well, for a certain value of "success," sure. it's only been used to teach programming for a couple decades...
16:48:28 <monochrom> Haskell has avoided success in avoiding success. :)
16:48:48 * wli ponders mapAccumR (\borrowIn (x, y) -> let u, v :: Word64 ; u = fromIntegral x ; v = fromIntegral y ; (q, r) = (2^(32::Int) + u - v - borrowIn) `divMod` (2^(32::Int)) in (1 - q, fromIntegral r :: Word32)) 0
16:48:54 <ozy`> banisterfiend: I don't think any scheme implementation has the kind of performance GHC gives us... that, and haskell is just so much more expressive :p
16:49:06 <ddarius> monochrom: The game's not up yet.
16:49:08 <yitz> ozy`: it's still the default scripting language for a number of apps.
16:49:14 <NameAlreadyInUse> i saw an article linked on reddit about a guy who wrote malware in scheme
16:49:23 <banisterfiend> ozy`: does haskell have anything like the power of lisp macros though
16:49:27 <NameAlreadyInUse> well, i'm not sure how much was actually written in scheme
16:49:29 <monochrom> There is no game. Only do's and dont's.
16:50:06 <monochrom> OK, seriously, why is the game not up yet? What is the game?
16:50:08 <ozy`> banisterfiend: yep! in a couple of different senses.
16:50:21 <banisterfiend> ozy`: cool, can haskell manipulate its own ast?
16:50:22 <yitz> NameAlreadyInUse: what did the malware do? every time you open Word it fills the document with parentheses?
16:50:25 <ozy`> yitz: yeah, but it's also... well... stuff
16:50:28 <pumpkin> banisterfiend: with TH, yes
16:50:33 <pumpkin> template haskell, that is
16:50:47 <pumpkin> well, at compile time
16:50:49 <monochrom> Do you mean something like most computers don't have 16 cores yet?
16:50:50 <banisterfiend> is TH part of the standard haskell compiler though
16:51:04 <pumpkin> banisterfiend: yeah
16:51:05 <ozy`> banisterfiend: yes, TH is an extension included with GHC
16:51:14 <ozy`> banisterfiend: you have to turn it on with a compiler flag
16:51:37 <monochrom> Did you know that with TH you can tell the compiler to play a movie when it compiles your code?
16:51:38 <banisterfiend> ok thx
16:52:03 <pumpkin> monochrom: awesome!
16:52:06 <ozy`> banisterfiend: TH aside, lazy evaluation alone gives you a LOT of expressive power. you can pass a complete expression into another thread to be evaluated, for example
16:52:15 <yitz> banisterfiend: it's not used that often though. most of things that you would need macros for in lisp are easily done other ways in haskell.
16:52:20 <banisterfiend> ozy`: can you turn lazy evaluation off too
16:52:36 <NameAlreadyInUse> yitz: here is the article: http://philosecurity.org/2009/01/12/interview-with-an-adware-author
16:52:42 <ozy`> banisterfiend: you can force evaluation of an expression with the seq function
16:52:48 <monochrom> "Thank you for using GHC to build GHC. While you wait, please enjoy this complimentary movie from the Catsters!"
16:52:55 <ozy`> > [1..] `seq` "This will never print"
16:52:56 <lambdabot>   "This will never print"
16:53:00 <ozy`> WHAT
16:53:01 <ozy`> oh right
16:53:05 <ozy`> > length [1..] `seq` "This will never print"
16:53:14 <lambdabot>   mueval: Prelude.read: no parse
16:53:14 <banisterfiend> bhahah
16:53:31 <banisterfiend> > length[1..] "This will never print"
16:53:33 <lambdabot>   Couldn't match expected type `[Char] -> t'
16:53:44 <ozy`> banisterfiend: you need the `seq` in there
16:54:03 <banisterfiend> yeah but i was hoping withtout the `seq` it would generat an infinte list
16:54:04 <banisterfiend> hehe
16:54:10 <ozy`> > [1..]
16:54:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:54:16 <ozy`> it does :p
16:54:19 <kmeyer> anyone familiar with how to format the current time?
16:54:20 <banisterfiend> cool
16:54:29 <yitz> kmeyer: Data.Time
16:54:44 <ozy`> "seq a b" (or "a `seq` b") means "evaluate 'a', and then return 'b'"
16:55:32 <ozy`> of course, if you try to evaluate a list like I just did, it'll only evaluate the head :p
16:55:59 <ozy`> but evaluating a return value that examines the entire length of the list will work.
16:56:00 <tehgeekmeister> hmm, how is it possible to make a median that works on both ints and reals?
16:56:13 <ozy`> :t div
16:56:14 <lambdabot> forall a. (Integral a) => a -> a -> a
16:56:28 <pumpkin> tehgeekmeister: use Num, Ord as constraints?
16:56:28 <ozy`> tehgeekmeister: use a typeclass?
16:56:38 <ozy`> @src Num
16:56:38 <lambdabot> class  (Eq a, Show a) => Num a  where
16:56:38 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:56:38 <lambdabot>     negate, abs, signum     :: a -> a
16:56:38 <lambdabot>     fromInteger             :: Integer -> a
16:56:56 <yitz> tehgeekmeister: what do you want the median of [1,2] to be?
16:57:03 <tehgeekmeister> 1.5
16:57:19 <monochrom> Assume you will never see [1,2]. Assume you're given even ints.
16:57:42 <tehgeekmeister> i've already written median :: (Integral a, Fractional b) => [a] -> b
16:57:55 <pumpkin> why not just Num, Ord ?
16:57:55 <yitz> median x y = (realToFrac x + realToFrac y) / 2
16:57:59 <monochrom> median xs | exists odd xs = error "precondition fail"
16:58:01 <tehgeekmeister> but then i tried to use it on some non ints and it didn't work too well.
16:58:06 <tehgeekmeister> =P
16:58:16 <yitz> @type (realToFrac x + realToFrac y) / 2
16:58:17 <lambdabot> forall b. (Fractional b) => b
16:58:26 <yitz> @type median x y = (realToFrac x + realToFrac y) / 2
16:58:27 <lambdabot> parse error on input `='
16:58:27 <tehgeekmeister> pumpkin: because i'm using fromIntegral to cope with the ints
16:58:34 <tehgeekmeister> pumpkin: that i was originally using this on
16:58:37 <yitz> @type \ x y -> (realToFrac x + realToFrac y) / 2
16:58:39 <lambdabot> forall a b a1. (Real a1, Fractional b, Real a) => a -> a1 -> b
16:59:09 <tehgeekmeister> :t realToFrac
16:59:10 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
16:59:11 <pumpkin> tehgeekmeister: all you really need though is to find the central element, which just needs an Ord, and if you have two, you take the mean, which needs Num
16:59:22 <yitz> > let median x y = (realToFrac x + realToFrac y) / 2 in median (1::Int) (2::Int)
16:59:24 <lambdabot>   1.5
16:59:38 <yitz> > let median x y = (realToFrac x + realToFrac y) / 2 in median (1.3) (2.4)
16:59:39 <lambdabot>   1.85
16:59:40 <monochrom> Num can't do mean.
16:59:51 <pumpkin> I guess :)
16:59:57 <pumpkin> mean 1 3 = 2, mean 1 2 = 1
16:59:57 <pumpkin> :P
17:00:00 <ozy`> :t (/)
17:00:01 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:00:05 <ozy`> yeeeah.
17:00:45 <dobblego> is ((->) t) an instance of Traversable?
17:00:46 <monochrom> Write a median for Fractional. If someone wants to do it on [Integer], tell him about map fromIntegral.
17:01:28 <tehgeekmeister> monochrom: good thinking.
17:01:30 <monochrom> If using map fromIntegral leads to some type error, use map (fromIntegral :: Integer -> Double)
17:02:02 <monochrom> or s/Double/Rational/ or whichever you see fit.
17:02:05 <yitz> @src realToFrac
17:02:05 <lambdabot> realToFrac = fromRational . toRational
17:02:17 <ddarius> @src fromIntegral
17:02:17 <lambdabot> fromIntegral = fromInteger . toInteger
17:02:26 <NameAlreadyInUse> why doesn't "map (putStrLn . show) [1..10]" do what i expect it to do?
17:02:26 <monochrom> is realToFrac is better choice?
17:02:40 <ddarius> :t map print [1..10]
17:02:41 <lambdabot> [IO ()]
17:02:48 <yitz> NameAlreadyInUse: use mapM_
17:02:54 <pumpkin> NameAlreadyInUse: you can call sequence_ on the output
17:03:01 <pumpkin> and get what you expect, but mapM_ is a better choice
17:03:13 <ddarius> @src print
17:03:13 <lambdabot> print x = putStrLn (show x)
17:03:14 <NameAlreadyInUse> ok, thanks
17:03:36 <dsrogers> NameAlreadyInUse: it's because you're just creating IO actions, without running them.
17:04:00 <NameAlreadyInUse> dsrogers: yeah, i see now
17:04:14 <monochrom> map (putStrLn . show) [1..10] doesn't have the type you expect, too.
17:04:28 <ozy`> classic newbie mistake :)
17:04:54 * pumpkin tries to think of how to continue his streak of epic optimization
17:05:09 <pumpkin> I have my test down from 4:40 to 46 seconds
17:05:13 * wli successfully implements subtraction.
17:05:30 <monochrom> When I was a newbie I wasn't a classic newbie.
17:05:44 <dsrogers> pumpkin: there is a chapter in real world haskell on optimizing.
17:06:00 <monochrom> My secret of success is I ran a virtual machine in my brain to learn Haskell.
17:06:01 * yitz was classic long before encountering haskell
17:06:02 <pumpkin> dsrogers: ah, I'll check it out later and see if I missed anything
17:06:05 <Toxaris_> monochrom: constructive newbie?
17:06:22 <monochrom> Yeah, I was constructivist :)
17:07:05 <Toxaris_> the law of the excluded newbie doesn't hold in #haskell anyway
17:07:19 <bremner> you must be new here
17:07:22 <dsrogers> what is the law of the excluded newbie?
17:07:44 <monochrom> "we aren't exclusionary to newbies" :)
17:07:59 <yitz> dsrogers: pls discuss that on #haskell-in-depth only
17:08:01 <dsrogers> so two newbies can be in the same state?
17:08:13 <dsrogers> newbies are bosons...
17:08:18 <Toxaris_> maybe the same person can be newbie and expert at once
17:08:19 <dsrogers> does that mean they are force carriers?
17:08:31 <monochrom> haha
17:08:41 <yitz> aha, now i understand what LHC has to do with haskell
17:08:48 <monochrom> hahaha
17:08:57 <dsrogers> they're looking for a newbie.
17:09:00 <Olathe> The Large Haskell Compiler
17:09:17 <dsrogers> a very elusive, highly energetic newbie.
17:09:21 <monochrom> It's now the Late Hadron Collider :)
17:09:39 <Olathe> It's dead ?
17:09:46 <dsrogers> it esploded
17:09:53 <dsrogers> slightly
17:09:55 <yitz> eaten by a black hole
17:10:01 <monochrom> not "the late". just "late". Its dates keep getting postponed.
17:10:02 <dsrogers> so they turned it off.
17:10:04 <chessguy> @quote eaten
17:10:04 <lambdabot> ari says: The problem I have with grues is that although I know that currently, if it is very dark I am likely to be eaten by one... but how can I tell if grue suddenly became benign at, say, the
17:10:04 <lambdabot> year 2010? The evidence I've gathered so far can't support the idea that that *wouldn't* happen.~
17:10:39 <hansfbaier> @quote sophisticated
17:10:39 <lambdabot> No quotes match. Where did you learn to type?
17:10:47 <hansfbaier> :)
17:11:10 <yitz> @quote simpleton
17:11:10 <lambdabot> No quotes match. Sorry.
17:11:10 <dolio> @quote qwe1234
17:11:11 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
17:11:22 <dsrogers> lol
17:11:32 <hansfbaier> :)
17:11:35 <Toxaris_> is that stephenson's ari?
17:12:06 <Toxaris_> the quote seems so familiar
17:12:19 <dsrogers> MC Frontalot
17:12:22 <dsrogers> it's a song.
17:12:46 <walski> What does the . in "shorten = filter ((>= 4) . length . snd)" mean?
17:12:57 <dolio> Function composition.
17:13:37 <pumpkin> why would someone do a parMap with a strategy not derived from rnf?
17:14:14 <dolio> Because they have a devil-may-care attitude?
17:14:22 <NameAlreadyInUse> heh
17:14:31 <Olathe> @src (.)
17:14:31 <lambdabot> (f . g) x = f (g x)
17:16:07 <ozy`> walski: ((>= 4) . length . snd) x = length (snd x) >= 4
17:16:25 <walski> thanks
17:16:35 <pumpkin> is there a good way to figure out why my parMap is only using about half of the CPU time it could be using? clearly there's a dependency I'm missing somewhere
17:16:59 <wli> >> Nat (2,[0]) - Nat (1,[])
17:16:59 <wli> Nat (1,[4294967295])
17:17:12 <wli> Looks like borrowing happens the way it's supposed to.
17:17:14 <dsrogers> http://www.youtube.com/watch?v=4nigRT2KmCE
17:17:40 <dsrogers> Toxaris: that's for you
17:18:27 <augustss_> wli: how are your Nats doing?
17:19:06 <wli> augustss: It's taking me forever to write but they're coming along. OTOH the real test of whether I'm getting anything done is division.
17:20:34 <augustss_> wli: So these are efficient lazy Nats somehow?
17:21:15 <wli> augustss: Vaguely efficient. More efficient than unary Nats.
17:21:36 <augustss_> wli: what's the representation?
17:22:03 <wli> newtype Nat = Nat (Word32, [Word32])
17:22:17 <augustss_> And those are?
17:22:34 <monochrom> length of list, list of digits
17:22:59 <wli> No, most significant digit and remaining digits.
17:23:00 <augustss_> ummm, and how are they lazy?
17:23:07 <wli> It might be smart to cache the length of the list.
17:23:14 <wli> They're not lazy.
17:23:19 <augustss_> oh
17:23:34 <augustss_> wli: So why are you doing all this work instead of using Integer?
17:24:05 <wli> The nonnegativity invariant, pedagogical programming practice, not much else.
17:24:42 <augustss_> pedagogical is a great reason
17:25:14 <augustss_> I don't think keeping the first digit separate is a good idea.  Sounds like it will just complicate your recursion
17:25:20 <tehgeekmeister> can i put a type constraint into a datatype definition?
17:25:34 <augustss_> tehgeekmeister: yes, but don't
17:25:37 <wli> It's to enforce a nonemptiness invariant for the list.
17:25:41 <tehgeekmeister> augustss_: do what instead?
17:25:49 <pumpkin> tehgeekmeister: put it in the functions that operate on ti
17:25:50 <pumpkin> it
17:25:52 <augustss_> wli: why should it be non-empty?
17:25:57 <tehgeekmeister> okay
17:26:14 <wli> 0 is uniquely represented as Nat (0, [])
17:26:33 <augustss_> and otherwise it woule be uniquely represented as Nat []
17:26:38 <wli> augustss: It's not all that compelling.
17:26:40 <silkarn> ksf: what do you mean haskells functions aren't total?
17:27:07 <silkarn> what would have to happen for a pure haskell function to fail? hardware error? <- I mean to fail during execution. obv it fails given the wrong input or input it isnt designed for
17:27:08 <augustss_> wli: It's just my gut feeling that it will make things more complicated.
17:27:19 <wli> augustss: It probably does.
17:27:33 <monochrom> My gut feeling is otherwise.
17:27:36 <silkarn> btw: http://news.ycombinator.com/item?id=485012 <- formal proofs and computer proofs, I think people here would be interested
17:28:23 <roconnor> > chr $ ord 'r' + ord 'm' - ord 'g'
17:28:24 <lambdabot>   'x'
17:28:55 <dolio> Every (lifted) haskell type contains a value _|_ that is, semantically, what a pure returns when it fails.
17:28:57 <monochrom> You just need an infinite loop to get a non-total function.
17:29:33 <yitz> > 1 `div` 0
17:29:34 <lambdabot>   * Exception: divide by zero
17:29:40 <augustss_> Ban non-total functions!
17:29:42 <yitz> > error "oops"
17:29:43 <lambdabot>   * Exception: oops
17:29:54 <chessguy> dolio:  what do you mean by a 'lifted' type here?
17:29:55 <yitz> > undefined
17:29:56 <lambdabot>   * Exception: Prelude.undefined
17:30:09 <dolio> chessguy: Uh, has bottom? :)
17:30:13 <newsham> augustss: termination proofs for all functions?
17:30:17 <chessguy> lol
17:30:29 <silkarn> but basically a pure function never needs an exception(except for Either monad perhaps)?
17:30:31 <augustss_> newsham: absolutely!
17:30:35 <TomMD> dolio: Is this similar to saying 'boxed' then?
17:31:08 <dolio> chessguy: Technically, newtypes are unlifted, because there is no _|_ distinct from Con _|_, but I guess the latter is still bottom.
17:31:54 <augustss_> I don't actually believe non-total functions should be banned.  But I do think they belong in some non-termination monad
17:32:10 <dolio> Lifted would mean that there is such a distinct _|_.
17:32:23 <TomMD> augustss_: So all other code must have a termination proof to compile?
17:32:25 <ddarius> In Cayenne you had non-total functions in the type system.
17:32:43 <Axman6> > fst (1,undefined)
17:32:44 <lambdabot>   1
17:32:46 <dolio> And boxed has to do with the compiler's representation of values of the type.
17:32:53 <monochrom> I advocate for formal proofs but I am not obsessed with them. I am obsessed with replacing humans by computers. Formal proofs are one way and are not a waste of computer's time. Formal proofs provide valuable heuristics to writing programs.
17:32:57 <wli> I should probably use the first element of the pair to represent list length and use a descending significance digit list for the rest of the number.
17:33:02 <augustss_> TomMD: yeah, but there are quite clever termination checkers these days
17:33:23 <augustss_> ddarius: I'm allowed to change my mind. :)
17:33:36 <dolio> Technically, I think you can find some stuff in the GHC docs that says that unboxed types are also unlifted, but you can still write infinite loops with them (and use error, I think), so who knows?
17:34:12 <augustss_> dolio: yeah, unboxed types are weird creatures
17:34:22 <newsham> mono: so I work in computer security and i'm a big fan of formal methods (or, more like fan boy, since I dont use them myself much)
17:34:36 <newsham> and I'm trying to think of ways to apply formal methods to some of the problems I see
17:34:44 <wli> So normalize (Nat (n, xs)) = let (pfx, sfx) = span (== 0) xs in Nat (n - length pfx, sfx)
17:34:47 <ddarius> dolio: Well, for strict languages their types are usually modelled as unlifted, but the function arrow lifts its target.
17:34:54 <coco`> when C is a newtype constructor, can ghc optimize `map C` away?
17:35:08 <augustss_> wli: when do you need the length?
17:35:13 <dolio> I suppose that makes sense.
17:35:16 <newsham> but I must admit I havent had much luck
17:35:29 <wli> Looks cleaner as normalize (Nat (n, xs)) | (pfx, sfx) <- span (== 0) xs = Nat (n - length pfx, sfx)
17:35:46 <wli> augustss: Padding the digit lists with 0's for addition and subtraction.
17:36:26 <augustss_> wli: maybe you should have the list reversed
17:36:34 <monochrom> "security" is broad. when you actually translate security requirements into specifications/properties according to formal methods, you will find that there is no unifying theme.
17:36:56 <newsham> much of the work I do is in auditing web applications and suggesting fixes
17:37:14 <monochrom> There are maybe 5 or 10 unrelated themes.
17:37:15 <newsham> I would love to say "you can use this technique to elimiante this class of problem with thismuch effort"
17:37:33 <pumpkin> I do "security" too :P
17:37:47 <newsham> but one problem I see is that a lot of the semantics are not well defined and implemented by these huge browsers that dont all behave the same way
17:37:56 <newsham> pumpkin: cool
17:38:26 <monochrom> Right, a problem is security people don't have semantics like formal methods people do.
17:38:31 <pumpkin> in some of my free time, at least
17:38:56 <augustss_> wli: how do you add two Word32 to get the carry anyway?  convert to Word64?
17:38:57 <monochrom> It's all just semantics! No semantics, no point.
17:39:11 <newsham> i would love to come up with a manageable size security project where I can implement something real and useful using some formal or semi formal methods and use it to show people "see, this is what you should be doing"
17:39:13 <wli> Nat (xL, xs) + Nat (yL, ys) = let mL = xL `max` yL ; (z, zs) = mapAccumR (\carryIn (x, y) -> let (q, r) = (fromIntegral x + fromIntegral y + carryIn) `divMod` (2^(32::Int)) in (q, fromIntegral r :: Word32) 0 $ zip (replicate (mL - xL) 0 ++ xs) (replicate (mL - yL) 0 ++ ys) in normalize $ Nat (fromIntegral z, zs)
17:39:35 <wli> augustss: Yeah, conversion to Word64
17:39:36 <newsham> augstss: one way is to detect overflow manually after the add by checking if the value you get after adding is smaller.
17:39:50 <wli> Though that's not sufficiently-well-typed for it.
17:40:15 <gueux> I am trying to use that code: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
17:40:19 <wli> The 0 needs to be (0 :: Word64)
17:40:33 <gueux> I get an error:
17:40:34 <pumpkin> epic optimization is epic. my program went from taking 180 minutes to 7, on a slower computer :P
17:40:37 <pumpkin> and less memory
17:40:49 <pilkarn> A or not A . true? Isn't that George Busg logic? and thus false.
17:40:58 <Axman6> pumpkin: heh, what'd you do? (love it when that happens!)
17:41:26 <gueux> Ambiguous type variable `b' in the constraint: `Exception b' arising from a use of `catch'
17:41:48 <gueux> it is the catch into the function main
17:41:50 <monochrom> George Busg?
17:41:51 <pumpkin> Axman6: made my algorithm easier for fusion in uvector, changed some compiler flags (the fusion ended up dwarfing the compiler flag benefits, but they helped too), and helped GHC inline better
17:41:58 <Axman6> gueux: might need to import Control.Exception.OldException
17:41:59 <augustss_> newsham: I know, but that might be slower
17:42:07 <newsham> *nod*
17:42:31 <pumpkin> oh, and switched from Double to Float
17:42:33 <pumpkin> to save memory
17:42:38 <wli> I have to use double precision because the multiplication case ends up adding more than 2 things together.
17:42:38 <Axman6> @hoogle OldException
17:42:38 <lambdabot> No results found
17:42:44 <augustss_> Georg Busg?
17:42:48 <gueux> Axman6: something has changed?
17:42:58 <monochrom> Mai program haz Busg Error!
17:43:03 <Axman6> gueux: yes, the exception stuff in 6.10 is quite different apparently
17:43:21 <wli> The let z = x + y in if z < max x y trick won't fly there.
17:43:38 <Axman6> pumpkin: that's usually not a great move, but i guess if you really needed the space benefit. how does it perform when using Doubles?
17:43:38 <gueux> do you know how to adapt it?
17:43:53 <gueux> to the new exeptions I mean
17:43:57 <wli> I could do it for addition.
17:44:01 <Axman6> 2hoogle Exception
17:44:06 <Axman6> @hoogle Exception
17:44:06 <lambdabot> module Control.Exception
17:44:06 <lambdabot> Control.Exception data Exception
17:44:06 <lambdabot> Control.Exception ArithException :: ArithException -> Exception
17:44:14 <wli> Just to special-case it and be faster by avoiding the division.
17:44:15 <augustss_> wli: Word64 is the right way, if the code generator is good (ghc's isn't)
17:44:18 <newsham> wli: you're going to support long-multiplication?  do you know wiz bang FFT method?
17:44:29 <pumpkin> Axman6: the performance is mostly the same, but considering I'm dealing with millions of floats, space actually matters
17:44:38 <pumpkin> NTT!
17:44:41 <pumpkin> (docomo)
17:44:42 <wli> newsham: I know what it is but am not capable of coding it.
17:44:44 <pumpkin> number-theoretic  transform
17:44:48 <Axman6> gueux: you need Control.OldException, sorry
17:44:48 <coco`> pumpkin: sorry for late answer, I read somewhere it only works at pragma
17:44:50 <augustss_> newsham: FFT only pays for really large numbers
17:45:07 <monochrom> wiz bang hehe
17:45:12 <gueux> ok
17:45:20 <wli> augustss: Well, then multiplication would need a Word128, which I don't believe is there.
17:45:24 <Axman6> i think...
17:45:51 <gueux> arg
17:46:00 <augustss_> wli: no, I mean you're doing the right way.  With Word32 and converting to Word64
17:46:02 <gueux> cabal does not find the package
17:46:04 <newsham> you could always write small asm stubs that do the add/mul's and return value plus overflow
17:46:07 <wli> Oh, okay.
17:46:07 <newsham> and ffi to them
17:46:12 <gueux> is that oldexception?
17:46:38 <wli> I'm basically staring down quotRem at this point.
17:46:49 <shapr> hej pilkarn!
17:46:59 <helgim_> is there a built-in method that'd make it simpler for me to make a list of X+2 length, that looks like: [1,4,2,4,2,4,2..1] - where 4 and 2 are repeating X times,but the list begins and ends with 1 ?
17:47:27 <wli> Oh, yeah, the Nat thing here is supposed to be some sort of practice for ArbFloat (which is itself pedagogical as well).
17:47:29 <augustss_> wli: for multiplication I'd stick with naive multiplication up to some cutoff and then switch to Karatsuba.  And for really large numbers you do something fancy like FFT (or something else)
17:47:48 <monochrom> > [1] ++ replicate 5 [4,2] ++ [1]
17:47:49 <lambdabot>       No instance for (Num [t])
17:47:49 <lambdabot>        arising from the literal `1' at <inter...
17:47:54 <ddarius> wli: Handling floating point is rather different than integers.
17:47:57 <monochrom> :t replicate
17:47:58 <wli> auustss: I'm having enough trouble programming at all that I'll stick with grade school algorithms.
17:47:58 <lambdabot> forall a. Int -> a -> [a]
17:48:13 <pumpkin> > [1] ++ (concat . replicate 5 $ [4,2]) ++ [1]
17:48:14 <lambdabot>   [1,4,2,4,2,4,2,4,2,4,2,1]
17:48:14 <newsham> > replicate 5 [4,2]
17:48:15 <lambdabot>   [[4,2],[4,2],[4,2],[4,2],[4,2]]
17:48:25 <Olathe> > let f x = 1:(concat . replicate x) [4, 2] ++ [1] in f 5
17:48:27 <lambdabot>   [1,4,2,4,2,4,2,4,2,4,2,1]
17:48:30 <ddarius> (Though I guess you'll still need a way to perform arithmetic on large numbers.)
17:48:31 <augustss_> wli: you should at least look at Karatsuba, because it's a neat trick
17:48:40 <helgim_> ah yes of course concat :) thanks
17:49:01 <wli> ddarius: Yeah, but IIRC it needs some of the same treatments of integers (e.g. this is part of why I chose most-significant-first for Nat).
17:49:10 <Olathe> Let's see.
17:49:31 <Olathe> > liftM2 (*) [a, b, c] [d, e]
17:49:32 <lambdabot>   [a * d,a * e,b * d,b * e,c * d,c * e]
17:52:12 <dsrogers> @src mapReaderT
17:52:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:52:41 <wli> Karatsuba I can actually understand, but I don't think I could code it.
17:54:54 <coco`> how can I tell if a function gets optimized away, e.g. `map id'?
17:55:36 <augustss_> coco`: you'd have to turn on some debug flags and look at the transformed program.
17:56:01 * Nafai tries to figure out how to change explicit recursion into something with HOF
17:56:05 <pumpkin> coco`: cabal install ghc-core
17:56:20 <coco`> augustss_: in which language is the transformed program written?
17:56:28 <pumpkin> Nafai: what is your explicit recursion?
17:56:32 <augustss_> coco`: ghc core
17:56:48 <pumpkin> coco`: looks mostly like haskell
17:56:50 <augustss_> coco`: kind of a subset of Haskell.  Extended subset
17:57:20 <coco`> wow, looks promising (and unreadable at first sight)
17:57:44 <Nafai> pumpkin: http://gist.github.com/66138
17:57:52 <augustss_> coco`: it's not very readable :(
17:57:59 <Nafai> pumpkin: I'm reading "Haskell Programming Tips" on the wiki, and that was a suggestion.
17:58:08 <Nafai> pumpkin: Trying to figure out how to improve my code
17:58:21 <pumpkin> Nafai: can you give a high-level overview first?
17:58:21 <newsham> is the recursion in the form of a fold or a map?
17:58:53 <Nafai> It's essentially a filter
17:59:10 <NameAlreadyInUse> is there any sort of "null IO" value that is of type IO () and does nothing?
17:59:18 <newsham> return ()
17:59:18 <Olathe> return ()
17:59:28 <NameAlreadyInUse> oh, of course
17:59:29 <NameAlreadyInUse> thanks
17:59:30 <Nafai> mapping over all of the elements in items, returning only those items that haven't been seen before, and the map that is created in the process
17:59:57 <ddarius> Sounds like a fold.
18:00:08 <augustss_> Nafai: you could use foldl
18:00:26 <augustss_> Nafai: but I'm not sure it's such a big improvement
18:00:35 <newsham> as imperative programmre the first thing that comes to mind is "its a for loop with an accumulator" which screams out "fold"
18:00:55 <newsham> and "my accumulator seems to be a list of items and a map"
18:01:32 <augustss_> Nafai: also, you could factor it into a map, a filter, and a fold
18:01:41 <pilkarn> A or not A. is it so?
18:01:41 <NameAlreadyInUse> Nafai: what do you mean by "returning only those items that haven't been seen before"? that the function is to discard duplicates?
18:01:48 <coco`> augustss_, pumpkin: this looks pretty much like assembler
18:01:49 <pumpkin> mmm haskell-related postdoc at yale
18:01:53 <pumpkin> now if only I had a phd :P
18:01:55 <augustss_> pilkarn: depends on A
18:01:56 <andresj> http://book.realworldhaskell.org/read/functional-programming.html#fp.foldl
18:02:12 <andresj> > help
18:02:13 <lambdabot>   Not in scope: `help'
18:02:19 <pumpkin> coco`: the names are obscure, but it's still more haskell-like than asm-like :)
18:02:22 <newsham> pilkarn:  A or not A is called the law of the excluded middle, and it is true in some but not all logic systems
18:02:49 <Nafai> NameAlreadyInUse: Discard duplicates, given a prior history in a map
18:02:54 <augustss_> newsham: it true constructively if A is decidable
18:03:10 <Nafai> NameAlreadyInUse: So, duplicates across runs
18:03:12 <coco`> pumpkin: but I see lots of "jmp" and "mov" things
18:03:28 <augustss_> coco`: maybe you dumped the wrong thing
18:03:54 <newsham> ?djinn Either a (a -> b)
18:03:55 <lambdabot> -- f cannot be realized.
18:04:00 <newsham> :(
18:04:07 <coco`> augustss_: how can I tell? I just did "ghc-core Test.hs"
18:04:08 <pumpkin> coco`: use the ghc-core program
18:04:12 <pumpkin> hmm
18:04:18 * ddarius would probably find core less readable than assembly...
18:04:23 <newsham> augustss: didnt know that.
18:04:23 <Olathe> > let zomg f = nubBy (\a b -> f a == f b) in zomg (take 5) ["hello, how are you", "hello"]
18:04:24 <lambdabot>   ["hello, how are you"]
18:04:27 * Axman6 wouldn't
18:04:40 <augustss_> coco`: I can't help you with the ghc-core program.  it doesn't run on MacOS :(
18:04:44 <pilkarn> augustss_: but not according to logic? can something only be: A or not A?
18:04:52 <pumpkin> augustss_: really? I thought I had it running
18:04:57 <Axman6> @djinn (a -> c) -> (b -> c) -> Either a b -> c
18:04:57 <lambdabot> f a b c =
18:04:57 <lambdabot>     case c of
18:04:57 <lambdabot>     Left d -> a d
18:04:57 <lambdabot>     Right e -> b e
18:05:02 <augustss_> pilkarn: what logic?
18:05:07 <dobblego> mind block - how do you generate each pair in a list?
18:05:23 <augustss_> pumpkin: it can't find pcre.h
18:05:26 <coco`> there are actually --- Core --- and --- Assembly --- sections
18:05:26 <ddarius> dobblego: liftM2 (,) (for one meaning of "each pair")
18:05:33 <Nafai> I just find the recursion to be awkward
18:05:37 <dobblego> ddarius, of course thanks
18:05:37 <pumpkin> augustss_: oh, doesn't macports have that?
18:05:45 <Axman6> dobblego: zip `ap` tail i think
18:05:55 <Axman6> ah, that way, ok
18:05:55 <mmorrow> @quote aztec
18:05:55 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
18:05:59 <augustss_> pumpkin: probably.  but nothing told me to install it
18:05:59 <ddarius> > join (liftM2 (,)) [1,2,3]
18:06:00 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:06:17 <kmeyer> hey, how do I call out to the shell?
18:06:26 <mmorrow> :! halt
18:06:26 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:07:01 <newsham> kmeyer: http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html
18:07:06 <mmorrow> oh
18:07:06 <kmeyer> thanks
18:07:19 <newsham> "system" being the most likely choice
18:07:22 <mmorrow> @hoogle readProcess
18:07:22 <lambdabot> No results found
18:07:26 <NameAlreadyInUse> how can i say "let f = IO's return"?
18:07:47 <newsham> name:  f <- <action>    in a do-block
18:07:47 <augustss_> Nafai: you should rewrite without recursion then
18:07:49 <pilkarn> augustss_: first order logic?
18:08:01 <Olathe> > let pairs = map (\(a:b:_) -> (a, b)) . takeWhile (not . null) . iterate (drop 2) in pairs [1..10]
18:08:02 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
18:08:04 <kmeyer> readProcess looks like what I want, thanks
18:08:16 <augustss_> pilkarn: classical or constructive?
18:08:53 <pumpkin> wow, augustss_, you have a wikipedia page :o
18:09:05 * Nafai thinks about how to do so
18:09:08 <augustss_> pilkarn: in classical logic it's always true, in constructive logic it may be true depending on what A is
18:09:21 <augustss_> pumpkin: and I don't know who wrote it :)
18:09:33 <pumpkin> augustss_: that's the best part of wikipedia pages :D
18:09:37 <Olathe> > let pairs (a:b:xs) = (a, b):pairs xs; pairs _ = [] in pairs [1..10]
18:09:38 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
18:09:54 <mmorrow> , fft (fmap fromIntegral [0..2^14-1])
18:09:56 <lunabot>  [1.34209536e8 :+ 0.0,(-8192.000000011176) :+ 4.27228291999282e7,(-8192.0)...
18:10:03 <augustss_> pilkarn: if by "true" you mean provable
18:10:35 <augustss_> fft?!?!
18:10:41 <newsham> ?type fft
18:10:42 <lambdabot> Not in scope: `fft'
18:10:44 <pumpkin> augustss_: sudo port install pcre &&  cabal install ghc-core --extra-include-dirs=/opt/local/include --extra-lib-dirs=/opt/local/lib
18:10:51 <mmorrow> it's "pure-fft" on hackage
18:11:04 <mmorrow> i actually have a better version i should upload...
18:11:12 <mmorrow> (it's short)
18:11:21 <SamB> pilkarn: in constructive logic, you need a decision procedure for A in able to say "A or not A"
18:11:26 <augustss_> pumpkin: I wish cabal-install suppored showing some file when the build fails.  containing tips
18:11:38 <pumpkin> augustss_: yeah :/
18:12:16 <SamB> s/in/to be/
18:12:27 <augustss_> pumpkin: port: Command not found
18:12:34 <Olathe> > let pairs (a:b:xs) = (a, b):pairs (b:xs); pairs _ = [] in pairs [1..10]
18:12:35 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
18:12:37 <pumpkin> http://www.macports.org/ :)
18:13:01 <augustss_> I could have sworn I had installed ports
18:13:18 <SamB> augustss_: maybe only if you include ticket numbers in the text ;-P
18:13:53 <pumpkin> augustss_: sometimes the installer doesn't put /opt/local/bin into your PATH correctly
18:13:58 <pumpkin> check /opt/local/bin/port
18:14:01 <mmorrow> here's fft src: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=515
18:14:03 <andresj> > :t (-1)
18:14:04 <lambdabot>   <no location info>: parse error on input `:'
18:14:11 <Olathe> > let pairs (a:xxs@(b:xs)) = (a, b):pairs xxs; pairs _ = [] in pairs [1..10]
18:14:12 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
18:14:14 <andresj> :t (-1)
18:14:15 <lambdabot> forall a. (Num a) => a
18:14:23 <andresj> :t (-)
18:14:24 <lambdabot> forall a. (Num a) => a -> a -> a
18:14:57 <mmorrow> , [$ty| fft |]
18:15:00 <lunabot>  [] (Complex Double) -> [] (Complex Double)
18:15:00 <pumpkin> mmorrow: is it really worth defining *** to use it once? :P at least do join (***) fft :P
18:15:27 <mmorrow> pumpkin: but if i use join i have to import Control.Monad! ;)
18:15:27 <coco`> any strong opinions on multi-param type classes?
18:15:33 <pumpkin> onoes!
18:15:42 <lowmagnet> I have a Question Re: http://haskell.org/haskellwiki/Haskell_programming_tips : section 2.2
18:15:43 <mmorrow> teh horrors!
18:15:55 <Svrog> is my memory failing me or did data X = X followed by instance Show X used to be the same as data X = X deriving Show
18:16:31 <pilkarn> augustss_: do you work/worked in Lund?
18:16:37 <lowmagnet> text says "Just write 'raise x ys = map (x+) ys' or even 'raise x = map (x+)'
18:16:42 <augustss_> pilkarn: nope
18:16:45 <mmorrow> pumpkin: being serious though, (fft***fft) is prettier than (join(***)fft) imo
18:16:47 <lowmagnet> can someone explain how one would use the second version of that?
18:16:56 <pumpkin> mmorrow: but repetition!! :P
18:17:04 <dmwit> lowmagnet: In exactly the same way as you would use the other versions.
18:17:14 <augustss_> pumpkin: repetition that makes it shorter!
18:17:21 <pumpkin> augustss_: but repetition nonetheless!
18:17:27 <dolio> fft *** fft is also (potentially) a different type than join (***) fft.
18:17:28 <pumpkin> Arrow needs a both function
18:17:28 <Svrog> right now the former causes stack overflow in ghci and no warnings about show not being implemented while the latter works correctly
18:17:36 * mmorrow tries to make `fft' into a one-liner
18:17:54 <pumpkin> dolio: because of the arrowness?
18:18:07 <augustss_> mmorrow: there is no limit on line length in Haskell
18:18:07 <lowmagnet> dmwit: that answer was somewhat non-responsive?
18:18:24 <mmorrow> augustss_: heh. the bots have a limit though :(
18:18:30 <dmwit> > let raise x = map (x+) in raise 32 [0..5] -- lowmagnet
18:18:31 <lambdabot>   [32,33,34,35,36,37]
18:18:31 <mmorrow> well, at least lambdabot
18:18:32 <Svrog> hi conal
18:18:33 * SamB thinks it would make more sense for Haddock's lexer to be passed into GHC as a function, as opposed to the current hard-wiring ...
18:18:33 <dolio> Because fft *** fft may be (a,a') ~> (b,b'), while join (***) fft :: (a,a) ~> (b,b).
18:18:37 <newsham> lowmagnet: the two definitions are identical and used in the same way
18:18:46 <dmwit> Hiya, conal!
18:18:57 <lowmagnet> oh so you have to let .. in
18:19:01 <dmwit> FieldTrip is really cool.
18:19:10 <chessguy> hm
18:19:13 <dmwit> lowmagnet: Only in ghci/lambdabot; in a file you of course just use it.
18:19:15 <augustss_> pumpkin: I have now install pcre.  It still can't find pcre.h
18:19:22 <pumpkin> dolio: why would  fft *** fft have a, a' ?
18:19:23 * SamB also thinks that of the parser
18:19:35 <pumpkin> augustss_: you passed it the --extra-include-dirs ?
18:19:46 <dolio> Because the two ffts can be instantiated to different types if they're polymorphic.
18:19:54 <augustss_> pumpkin: of course not :)
18:19:55 <pumpkin> oh, I see
18:19:55 <conal> Svrog, dmwit: hi!
18:20:13 <conal> dmwit: thanks :)
18:20:15 <pumpkin> conal: the end result of my epic optimization was 180 minutes down to 6
18:20:18 <pumpkin> conal: I'm quite happy
18:20:26 <conal> pumpkin: wowzers!!
18:20:27 <dolio> @type join (***) id
18:20:28 <lambdabot> forall c. (c, c) -> (c, c)
18:20:32 <dolio> @type id *** id
18:20:33 <lambdabot> forall a b'. (a, b') -> (a, b')
18:20:43 <pumpkin> dolio: makes sense now :) cool
18:20:45 <Axman6> pumpkin: blog about it!
18:20:45 <augustss_> pumpkin: I thought we had these cabal files so you wouldn't have to type so much on the command line...
18:20:51 <conal> pumpkin: do you blog?  i'd be interested in reading about your adventure.  i bet others would also.
18:20:51 <pumpkin> Axman6: no haz blog :(
18:20:54 <dmwit> conal: I have actually run into a weird problem with FieldTrip... but I don't think it's FieldTrip's fault. =P
18:20:55 <conal> oh
18:21:04 <Axman6> pumpkin: you could have an account on mine if you wanted it :)
18:21:10 <pumpkin> conal: maybe I'll give in to the peer pressure and set one up soon
18:21:17 <pumpkin> but I'm afraid of the iphone fanbois who would follow me :P
18:21:25 <augustss_> pumpkin: no blog?  even I have blog
18:21:25 <chessguy> haha
18:21:49 * pumpkin looks down in shame
18:22:01 * mmorrow slowly sidesteps away
18:22:08 <dmwit> Blogs are too high maintenance.
18:22:13 <pumpkin> mmorrow: get a blog!
18:22:17 <pumpkin> dmwit: get a blog!
18:22:18 <mmorrow> !
18:22:23 * pumpkin passes on the peer pressure
18:22:26 <Axman6> pumpkin: want an account? you could either post to my Data.Random blog (which is basically a haskell blog), or you could have your own blog
18:22:32 <dmwit> pumpkin: No thanks!
18:22:42 <dmwit> Updating my website twice a year is enough for me.
18:23:02 <pumpkin> you can see my epic website skillz0rz here: http://pumpkinpat.ch/
18:23:02 <Axman6> heh
18:23:19 <ozy`> wat
18:23:21 <newsham> <- card carrying member of "programmers without blogs"
18:23:28 <Axman6> pumpkin: ... oh man...
18:23:42 <pumpkin> :P
18:23:43 <Ikkebr> newsham that's a nice club to be member of
18:23:47 <ozy`> pumpkin: http://www.rsmw.net/ <- even -my- site is neater looking
18:23:51 <newsham> programmeurs sans blogs
18:23:54 <pumpkin> Axman6: admittedly, I didn't actually mean for that to be seen much
18:24:01 <augustss_> dmwit: blogs only needs as much maintenance as you want to give them
18:24:05 <dmwit> I'm a member of that club... but no card. =/
18:24:32 <newsham> I tried and failed.  http://www.thenewsh.com/~newsham/blog/
18:24:43 <pumpkin> 332986500 floats in memory, lol
18:24:57 <pumpkin> newsham: your latest post is quite illuminating
18:25:11 <augustss_> newsham: looks like you need twitter
18:25:22 <pumpkin> yeah, even I do twitter
18:25:26 <chessguy> twitter is fun
18:25:29 <dmwit> bird bird bird
18:25:30 <dmwit> bird is a word
18:25:32 <newsham> there is no rss feed to my life
18:25:36 <chessguy> though i tend to just mutter incoherently on it
18:25:49 <pumpkin> chessguy: at least you don't tell people you're taking a dump
18:25:55 <chessguy> haha
18:26:18 <conal> chessguy: am i following you on twitter?  if not, what's your twitter handle?
18:26:20 <augustss_> i blog instead of writing papers
18:26:21 <Axman6> newsham: ha, nice work
18:26:36 <augustss_> no quality control! hahaha
18:26:38 <Axman6> i just blog about what i'm doing with haskell
18:26:45 <chessguy> conal:  i'm not sure if you're following me. i know i'm following you - i'm arwagner
18:26:56 <conal> chessguy: thx.  i'll look.
18:26:58 <Axman6> newsham: you know blog posts are supposed to have more than 10 words right?
18:27:11 <pumpkin> newsham uses his blog like twitter
18:27:18 <newsham> axman: notice the disclaimer near the top
18:27:19 <Axman6> chessguy: you're a wanger? o.O
18:27:24 <chessguy> ahem
18:27:25 <newsham> i admit its not very blog like
18:27:40 <pumpkin> Axman6: I think you misspelled something
18:27:43 <newsham> fwiw, the web log links to long articles
18:27:47 <Axman6> most likely :)
18:28:06 <conal> chessguy: thx.  now i'm stalking you.
18:28:11 <chessguy> yay
18:28:12 <pumpkin> :o
18:28:15 <pumpkin> epic stalkage
18:28:39 <Axman6> for those interested in getting a blog, i highly recomment movable type. using it with SQLite in the backend just makes installation so much easier
18:28:44 <Olathe> Corn stalks.
18:29:06 <chessguy> i have a blog on blogspot.com, but it rather...err...sucks
18:29:12 <newsham> time flies like an arrow.  fruit flies like a banana.
18:29:13 <pumpkin> Axman6: btw, thanks for the offer, but I doubt I'd write much just yet :) I'll get a blog when I feel I have something interesting to contribute (and am not too lazy to write), maybe :P
18:29:24 <NameAlreadyInUse> whats the idea with MonadPlus?
18:29:42 <pumpkin> NameAlreadyInUse: it's like a monad and a monoid!
18:29:42 <newsham> name: it lets you represent a computation that may fail and try alternatives.
18:29:48 <pumpkin> or something like that
18:29:55 <chessguy> conal:  by the way, my continuation-ish idea fell apart. which i think will be a good thing once i put it back together
18:30:02 <Axman6> pumpkin: well, the reason i offered you an account on mine was so that you wouldn't feel you had to keep up with the content, you can just post when there's something interesting to say. but s'all good :)
18:30:08 <newsham> with mzero representing the failure and mplus tying together a failing computation with an alternative to try when it fails
18:30:14 <NameAlreadyInUse> newsham: like backtracking? =\
18:30:16 <newsham> yup
18:30:32 <Axman6> @src [] MonadPlus
18:30:32 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:30:36 <Axman6> bah
18:30:42 <Axman6> @src [] mzero
18:30:43 <lambdabot> mzero = []
18:30:46 <Axman6> @src [] mplus
18:30:46 <lambdabot> mplus = (++)
18:30:50 <conal> chessguy: "Failures, repeated failures, are finger posts on the road to achievement.  One fails forward toward success." - Charles F. Kettering
18:30:50 <conal>  
18:30:50 <conal>  
18:30:52 <newsham> but in an abstract way, so you can reuse some generic code in whatever contet you wish
18:30:56 <Axman6> @src Either mplus
18:30:56 <lambdabot> Left _ `mplus` n = n
18:30:56 <lambdabot> m      `mplus` _ = m
18:31:03 <chessguy> conal:  nice
18:31:05 <newsham> ie. you can backtrack till you find a single solution (Maybe) or backtrack and find all solutions ([])
18:31:16 <conal> also, "I did not fail two thousand times.  I merely found two thousand ways not to make a lightbulb." - Thomas Edison
18:31:48 <chessguy> much better-known
18:31:53 <TomMD> I did not fail two thousand times.  I merely found two thousand ways not to earn a PhD.
18:31:56 <TomMD> No, wait.
18:32:03 * chessguy chuckles
18:32:29 <newsham> conal: strangely relevant to monadplus.
18:32:35 <conal> heh
18:32:38 <chessguy> conal:  i suspect that i have two inter-dependent types in my semantic domain, and i need to get them untangled in my head
18:33:25 <conal> i'm using the trick of a GADT for type equality.  does anyone know the origin of that trick?  The type is
18:33:26 <conal> data EQ :: * -> * -> * where  Refl :: EQ a a
18:33:34 <necroforest> Hi, I have a function that is declared as: f :: String -> String
18:33:36 <necroforest> it consists of :
18:33:53 <dolio> conal: Dependent type theory? :)
18:33:56 <newsham> conal: thats from martin lof per's type theory, no?
18:34:05 <necroforest> f s = map (g s) [0..25], where g :: String -> Int -> String
18:34:15 <Nafai> I'm having problems re-writing this function in a non-recursive style because my map would constantly be changing
18:34:26 <necroforest> I get a GHCI error that it expects (g s) to be Int -> Char instead of Int -> String
18:34:32 <conal> thx for those pointers.  how about its use in haskell, with gadts?
18:34:47 <newsham> i've never seen in w/ gadts myself
18:35:15 <newsham> but its used in agda and coq among others
18:35:16 <augustss_> conal: it's used in type theory, but it could go back to Automath,  many of these things do.
18:36:14 <conal> i'm using EQ to encode a typed first-order syntax as a gadt, with variable look-up in an environment that holds bindings of mixed type.
18:36:15 <dolio> You usually don't see it used with types in Agda and Coq (from my limited experience at least), but types are the only things you can index GADTs by, so...
18:36:31 <conal> it works out very nicely, and i suspect it's been done before, but i don't know of a reference.
18:36:48 <augustss_> you'd have to encode it in Automath, of course.  I first saw in in Martin-Löf's intentional type theory
18:36:57 <ddarius> Most of the GADT papers include such an example.
18:37:59 * stepcut wonders if he uses <$> too much
18:38:08 <newsham> stepcut: bah!
18:38:08 <dolio> Didn't someone show that that GADT is the only one you need to implement to get the full power of GADTs?
18:38:21 <stepcut> newsham: I'm starting to wish it was in Prelude ;)
18:38:21 * conal wonders how much <$> is exactly the right amount.
18:38:33 <newsham> stepcut: I love it. and <*>.
18:38:57 <ddarius> dolio: See "Initial Algebra Semantics is Enough"
18:39:11 * stepcut ponders what function he would be willing to cut from Prelude so that there is room for <$>
18:39:17 <dolio> I have. Maybe that's where I saw it.
18:39:23 <Olathe> @src <*>
18:39:23 <lambdabot> Source not found.
18:39:29 <Olathe> @type (<*>)
18:39:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:39:34 <Olathe> @src (<*>)
18:39:34 <lambdabot> Source not found. :(
18:39:41 <pumpkin> am I allowed to pick a package name for hackage that's never used within the module hierarchy in that package?
18:39:47 <Olathe> @type (<$>)
18:39:48 <newsham> stepcut: why not just make a User.Stepcut.Prelude that imports all your favorites?
18:39:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:40:18 <stepcut> newsham: because then I have to keep importing User.Stepcut.Prelude ;)
18:40:23 <dolio> Google says that Foundations of Structured Programming with GADTs may be where I saw the claim more obviously.
18:40:40 <Olathe> @src [] (<*>)
18:40:40 <lambdabot> (<*>) = ap
18:40:41 <dolio> ddarius: On second thought, isn't Initial Algebra Semnatics are Enough just about non-regular types?
18:40:59 <ddarius> dolio: No.
18:41:19 <Olathe> > [(*2), (+1)] <*> [1..10]
18:41:21 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,2,3,4,5,6,7,8,9,10,11]
18:41:26 <NameAlreadyInUse> where is <$> from?
18:41:33 <pumpkin> NameAlreadyInUse: applicative
18:41:34 <Axman6> Applicative
18:41:36 <Olathe> @src Applicative
18:41:36 <lambdabot> class Functor f => Applicative f where
18:41:36 <lambdabot>     pure  :: a -> f a
18:41:36 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:41:37 <pumpkin> Control.Applicative, that is
18:41:46 <newsham> stepcut: sure, but just one thing
18:41:52 <Olathe> > pure 5 :: [Int]
18:41:53 <lambdabot>       Ambiguous occurrence `pure'
18:41:53 <lambdabot>      It could refer to either `Control.Appl...
18:42:02 <newsham> is there a cmd line flag for ghc to specify pre-imports?
18:42:03 <newsham> :)
18:42:43 <hackage> Uploaded to hackage: LslPlus 0.3.2
18:43:01 <kmeyer> anyone have ideas for creating a temporary working directory?
18:43:17 <augustss_> dolio: you need the EQ GADT and existentials.  it's in Neil Ghani's 2008 POPL paper
18:43:38 <NameAlreadyInUse> what does pure do?
18:43:47 <drhodes> > read "\NUL" :: Int
18:43:49 <lambdabot>   * Exception: Prelude.read: no parse
18:43:49 <dolio> Yeah. I saw that you need existentials too, but forgot to mention it.
18:43:50 <newsham> Control.Applicative.pure?
18:43:58 <NameAlreadyInUse> newsham: yes, i mean
18:44:11 <newsham> ?type pure
18:44:11 <SamB> > pure
18:44:12 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
18:44:12 <lambdabot>       Ambiguous occurrence `pure'
18:44:12 <lambdabot>      It could refer to either `Control.Appl...
18:44:13 <dolio> I'm trying to find Initial Algebra... in my mess of saved papers.
18:44:25 <ddarius> dolio: But it doesn't seem to be what I wanted.
18:44:25 <NameAlreadyInUse> but, what is it actually used for?
18:44:43 <newsham> it takes a "pure" value a, and returns it "wrapped" in a functor.
18:44:49 <newsham> > pure 3 :: [Int]
18:44:50 <lambdabot>       Ambiguous occurrence `pure'
18:44:50 <lambdabot>      It could refer to either `Control.Appl...
18:44:50 <pumpkin> NameAlreadyInUse: it "puts a value into the applicative"
18:44:54 <NameAlreadyInUse> ah
18:44:58 <newsham> > Control.Applicative.pure 3 :: [Int]
18:44:58 <NameAlreadyInUse> ok, i see
18:44:59 <lambdabot>   [3]
18:45:00 <pumpkin> it's like return
18:45:04 <newsham> > Control.Applicative.pure 3 :: Maybe Int
18:45:05 <lambdabot>   Just 3
18:45:14 <Olathe> > (pure (*2)) <*> (pure 3)
18:45:15 <lambdabot>       Ambiguous occurrence `pure'
18:45:15 <lambdabot>      It could refer to either `Control.Appl...
18:45:23 <pumpkin> meh
18:45:25 <Olathe> > let pure = Control.Applicative.pure in (pure (*2)) <*> (pure 3)
18:45:25 <lambdabot>       No instance for (Show (f a))
18:45:25 <lambdabot>        arising from a use of `show' at <in...
18:45:33 <ddarius> "Foundations for Structured Programming with GADTs" is what I wanted
18:45:46 <Olathe> > let pure = Control.Applicative.pure in (pure (*2)) <*> (pure 3) :: [Int]
18:45:47 <lambdabot>   [6]
18:45:49 <dolio> Okay.
18:45:56 <gwern> @quote yarlysotense
18:45:56 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
18:46:08 <gwern> @remember chrisdone zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
18:46:08 <lambdabot> It is stored.
18:46:12 <gwern> > zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
18:46:13 <lambdabot>   "hail satan"
18:46:22 <Olathe> O-o
18:46:26 * gwern is shocked, shocked!
18:46:34 <gwern> @quote emacs
18:46:34 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
18:46:37 <gwern> @quote emacs
18:46:37 <lambdabot> Philippa says: because emacs wasn't a good enough OS after all
18:46:41 <gwern> @quote emacs
18:46:41 <lambdabot> kyevan says: Emacs makes my head hurt almost as much as haskell!
18:46:57 <Axman6> @quote vim
18:46:57 <lambdabot> lament says: "go, the vim of games"
18:47:02 <Olathe> > zipWith3 ($) (cycle [flip const,const]) "hai! haha!" "yarlysotense!"
18:47:03 <lambdabot>   "yar!yhohe!"
18:47:08 <Olathe> Yarr ~!
18:47:21 <Olathe> Eee ho hey !
18:47:31 <chessguy> @yarr
18:47:31 <lambdabot> Aye Aye Cap'n
18:48:20 <Olathe> Spongebob ?
18:48:28 <chessguy> @quote sponge
18:48:28 <lambdabot> No quotes match. There are some things that I just don't know.
18:50:05 <gwern> @quote roconnor don't let Float do your finance homework for you.
18:50:05 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
18:50:06 <gwern> @remember roconnor don't let Float do your finance homework for you.
18:50:07 <lambdabot> I will never forget.
18:50:42 <dmwit> > 7^3
18:50:43 <lambdabot>   343
18:50:47 <dmwit> > 7^4
18:50:48 <lambdabot>   2401
18:51:00 <dmwit> > 6 * 7^4
18:51:02 <lambdabot>   14406
18:51:15 <gwern> @quote drhodes We're sorry Mr. Thunk, but this program is on a need to run basis, and you don't need to run. Now go away before I call the garbage collector.
18:51:15 <lambdabot> No quotes for this person. I am sorry.
18:51:17 <gwern> @remember drhodes We're sorry Mr. Thunk, but this program is on a need to run basis, and you don't need to run. Now go away before I call the garbage collector.
18:51:17 <lambdabot> I will never forget.
18:51:19 <dmwit> Welp, I guess FieldTrip can't handle 14k Geometry3's all that smoothly. =P
18:51:24 <gwern> @flush
18:51:31 <dmwit> ?quote drhodes We're sorry
18:51:31 <lambdabot> drhodes says: We're sorry Mr. Thunk, but this program is on a need to run basis, and you don't need to run. Now go away before I call the garbage collector.
18:51:35 <newsham> gwern: are you just readding all the quotes from last weeks hwn?
18:51:50 <dmwit> newsham: He's been doing it every week, where have you been?
18:51:51 <dmwit> ;-)
18:52:19 <newsham> i thought the bot was the src of the hwn quotes
18:52:22 <gwern> newsham: last week's?
18:52:23 <ddarius> newsham wields +1 Bouncing Baby
18:52:33 * gwern is abruptly dislocated in time. WHEN AM I???
18:52:52 <newsham> gwern: the late last week one that appeared this week
18:53:02 <Olathe> gwern: You're at the dawning of the age of Aquarius.
18:53:04 <newsham> sealed w/ a kiss
18:53:15 <Nafai> Is there something equivalent to catMaybes $ map ... ?  That seems to be a common pattern for me
18:53:26 <Olathe> @src catMaybes
18:53:26 <lambdabot> catMaybes ls = [x | Just x <- ls]
18:53:27 <gwern> Olathe: no, we're in pisces now
18:53:33 <drhodes> 2012 is the end of pisces
18:53:48 <Olathe> gwern: Are you saying that my radio is lying to me ?
18:54:02 <chessguy> what in the world are you guys talking about?
18:54:11 <Olathe> > catMaybes [1..10]
18:54:12 <lambdabot>       No instance for (Enum (Maybe a))
18:54:12 <lambdabot>        arising from the arithmetic seq...
18:54:14 <drhodes> end of the mayen calender, end of days chessguy
18:54:24 * drhodes prepares soul for reaping
18:54:32 <Olathe> > catMaybes [Nothing, Just 5]
18:54:33 <lambdabot>   [5]
18:54:41 <Olathe> > catMaybes [Nothing, Just 5, Nothing, Just 10]
18:54:41 <newsham> ?hoogle (a -> Maybe b) -> [a] -> [b]
18:54:42 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
18:54:42 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
18:54:42 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
18:54:42 <lambdabot>   [5,10]
18:54:45 <Olathe> Ah hah !
18:54:55 <Nafai> Yay for hoogle
18:54:56 <twb> In RWH ch 5, the authors utilize less-than and greater-than comparisons on the Char type do decide if a character is printable.
18:54:58 <Nafai> I forgot about that
18:55:14 <twb> In languages like C this is a boo-boo, because the compiler might be using e.g. EBCDIC.
18:55:20 <Nafai> So which is preferable?  mapMaybe or mapM?
18:55:36 <ddarius> @hoogle is
18:55:36 <lambdabot> System.FilePath.Posix isAbsolute :: FilePath -> Bool
18:55:36 <lambdabot> System.FilePath.Windows isAbsolute :: FilePath -> Bool
18:55:36 <lambdabot> Data.Generics.Basics isAlgType :: DataType -> Bool
18:55:42 <ddarius> @hoogle isPrintable
18:55:42 <lambdabot> No results found
18:55:42 <twb> Is it safe to assume that Char (i.e. unicode codepoints) are always going to be ordered in a particular fashion?
18:55:43 <newsham> mapM isnt the same thing, nefai.
18:55:44 <dmwit> :t mapMaybe
18:55:45 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
18:55:51 <dmwit> :t mapM
18:55:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:55:56 <newsham> it will do  (a -> Maybe b) -> [a] -> Maybe [b]
18:55:57 <dmwit> Nafai: It depends which type you want, I guess.
18:55:58 <pumpkin> twb: yeah
18:56:00 <twb> ddarius: I use "printable" in a vague manner
18:56:01 <wli> I think division is a mapAccumL
18:56:01 <Olathe> mapMaybe
18:56:07 <Nafai> Oh yeah
18:56:13 <Nafai> I prefer mapMaybe
18:56:14 <newsham> and Maybe [b] will be Nothing or Just [....]
18:56:16 <dmwit> Nafai: They don't really do the same thing.
18:56:29 <Nafai> Sorry I wasn't looking close enough :)
18:56:32 <Olathe> > mapMaybe (\x -> if even x then Nothing else Just (div (x - 1) 2)) [1..10]
18:56:33 <lambdabot>   [0,1,2,3,4]
18:56:40 <pumpkin> twb: collation is another issue though
18:56:51 <newsham> isnt there a Traversable thing that is kinda like mapMaybe/catMaybes too?
18:56:57 <newsham> I'm still green on the Traversable stuff
18:57:00 <chessguy> @src mapMaybe
18:57:00 <lambdabot> Source not found. My brain just exploded
18:57:05 <chessguy> @type mapMaybe
18:57:06 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
18:57:09 <newsham> or maybe thats closer to the mapM case
18:57:10 <dmwit> > mapM (\x -> if even x then Nothing else Just (div (x-1) 2)) [1..10]
18:57:11 <lambdabot>   Nothing
18:58:23 <twb> pumpkin: because of locales?
18:59:17 <twb> Why does RWH Ch.5 call the "astral" function "astral"?
18:59:34 <Olathe> Is it a projection ?
18:59:42 <twb> Olathe: that's what I was wondering
18:59:51 <twb> It seems implausible.
18:59:55 <newsham> are there any haskell implementations on machines that use ebcdic?
18:59:58 <pumpkin> twb: well, different writing systems have different ordering rules, and they aren't always simple
19:00:07 <Olathe> What does astral do ?
19:00:41 <twb> Olathe: some bit-shifting to (essentially) show a number as hex digits.
19:01:10 <twb> pumpkin: they aren't even standardized, cf. North and South Korea.  But I was thinking of LC_COLLATE.
19:01:35 <newsham> twb: just wild guess, but a reference to it being applicable to astronomically large numbers?
19:02:16 <twb> newsham: nope, they aren't even bignums.
19:02:27 <twb> They're unicode codepoints.
19:02:45 <newsham> *nod*
19:02:47 <bombshelter13> in what file should the source for the IO monad be?
19:03:35 <pumpkin> twb: but if you're just talking about the code points themselves without a linguistic context, I think the ordering is pretty fixed :)
19:03:42 <sjanssen> @info IO
19:03:42 <lambdabot> IO
19:03:48 <pumpkin> that's illuminating
19:03:49 <twb> pumpkin: okey dokey
19:03:53 <Olathe> @info doesn't exist.
19:03:53 <lambdabot> (doesn't exist .)
19:04:00 <sjanssen> bombshelter13: GHC.IOBase
19:04:00 <Olathe> @undo doesn't exist
19:04:00 <lambdabot> doesn't exist
19:04:07 <Olathe> Hmm...
19:04:08 <bombshelter13> sjanssen: thanks
19:04:10 <twb> pumpkin: I wasn't sure if the Unicode consortium promised anything along those lines
19:04:18 <Olathe> @unpl doesn't exist.
19:04:18 <lambdabot> (\ a d -> doesn't exist (a d))
19:04:37 <pumpkin> that seems random
19:04:47 <drhodes> unicode -> unicorn -> astral plane
19:04:48 <Olathe> > let doesn't = not in doesn't . even $ 5
19:04:49 <pumpkin> oh I see
19:04:49 <lambdabot>   True
19:04:53 <Olathe> Neat
19:04:54 <pumpkin> it's taking the . as composition
19:05:51 <Olathe> > let can't x = fail "can't" in can't . putStrLn "hello"
19:05:52 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `IO ()'
19:06:17 <bombshelter13> sjanssen: huh, is the definition of >>= it uses somewhere else?
19:07:20 <pilkarn> can you do immutable OO and still call it OO? perhaps state is the real evil and OO not so bad?
19:08:09 <newsham> isnt one of the main ideas of OO is having objects that carry around mutable state?
19:08:21 <dolio> Immutable OO is functional programming. :)
19:08:32 <Olathe> Well, you do copy on write.
19:08:34 <conal> ddarius: "Most of the GADT papers include such an example." (of EQ or of multi-type variable environments; not sure which).  do you have a reference?  i don't see it in.
19:08:35 <Olathe> COW OO
19:08:36 <Olathe> MOO
19:08:44 <pumpkin> #moo
19:08:52 <ozy`> pilkarn: sure, just write all your function calls like this: "(div 4) `map` someList"
19:08:59 <conal> ddarius: in "simple unification-based type inference for GADTs"
19:09:13 <twb> OO is objects that have functions inside them.  Closures are functions that have objects inside them.  FP is just functions.
19:09:15 <Olathe> Copy-on-write objects are a bit like data declarations in Haskell, I think.
19:09:17 <aujgoljkf> <pilkarn> can you do immutable OO and still call it OO? ---> sure you can...
19:09:54 <Olathe> You could probably use the pure state monad or something to do "mutability"
19:09:56 <twb> I think immutable OO is stuff like Slate, Self and (I'm told) Javascript.
19:09:58 <aujgoljkf> in fact if you do OO properly, most of your objects will be inmutables...
19:12:56 <pumpkin> o.O
19:12:56 <twb> @google prototype-based object system
19:12:56 <lambdabot> http://en.wikipedia.org/wiki/Prototype-based_programming
19:12:56 <lambdabot> Title: Prototype-based programming - Wikipedia, the free encyclopedia
19:12:56 <Olathe> Prototypes are the only types ! In the worrrrld !
19:12:56 <ozy`> pilkarn: seriously though, the main reason haskell isn't called OO is that functions are (mostly) defined separately from their argument types
19:12:56 <ozy`> pilkarn: apart from that, all the stuff you'd expect to find in a (functional) OO language is there in haskell, and then some
19:12:56 <kerlo> I don't think JavaScript's objects are immutable.
19:12:56 <bombshelter13> I am trying to find the main definition of >>=... does anyone know where this is?
19:12:56 <twb> ISTR that Forcer implemented a purely functional prototype-based object system in Scheme48.
19:13:00 <pumpkin> bombshelter13: there isn't one
19:13:05 <pumpkin> each instance of the Monad class provides one
19:13:09 <aujgoljkf> kerlo: you make objects immutable, when you don't implement any message able to modify them....
19:13:16 <pumpkin> that (supposedly) obeys some laws
19:13:23 <pumpkin> @src Monad
19:13:23 <lambdabot> class  Monad m  where
19:13:23 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:13:23 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:13:23 <lambdabot>     return      :: a -> m a
19:13:23 <lambdabot>     fail        :: String -> m a
19:13:25 <bombshelter13> pumpkin: hm, i'm probably interested in the IO monad's version
19:13:25 <twb> Not that it really matters, because OO is confusing and sucky and hard to debug
19:13:34 <pumpkin> bombshelter13: that's kinda voodoo
19:13:35 <aujgoljkf> twb: why's that?
19:14:03 <pumpkin> you can try though
19:14:03 <kerlo> bombshelter13: ask your compiler. :-)
19:14:03 <newsham> bomb: there are different definitions for different class instances
19:14:03 <twb> aujgoljkf: because it's not as modular as FP.
19:14:03 <pumpkin> @src IO (>>=)
19:14:03 <lambdabot> m >>= k     = bindIO m k
19:14:03 <pumpkin> ??
19:14:03 <pumpkin> :P
19:14:03 <pumpkin> there you go
19:14:03 <bombshelter13> pumpkin:  why's it voodoo to wanna read it?
19:14:03 <pumpkin> bindIO!
19:14:03 <aujgoljkf> what do you call "modular"?
19:14:03 <kerlo> Wow.
19:14:04 <twb> aujgoljkf: with FP you can deal with each function in isolation.
19:14:09 <pumpkin> bombshelter13: because it's implemented in your compiler
19:14:12 <bombshelter13> pumpkin:  cool, think i actually saw bindIO in there.
19:14:14 <ozy`> bombshelter13: technically the IO version of >>= is not possible to implement in haskell
19:14:29 <dolio> @src bindIO
19:14:30 <lambdabot> bindIO (IO m) k = IO ( \ s ->
19:14:30 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
19:14:37 <bombshelter13> pumpkin: yeah, but I should still be able to read it and figure out how it works conceptually, right?
19:14:49 <pumpkin> bombshelter13: sure, GHC's source is in haskell too :)
19:15:33 <aujgoljkf> twb: you might have a lot of functions to check :). You could say in OO you could work with each class of objects in isolation....
19:15:37 <bombshelter13> ozy`: Hm, might not bother me - purely for kicks I'm trying to implement something like the IO monad in python, and I have something that aaaalmost works, just trying to figure out where I'm going wrong 'cause something's definately wrong with my version of '>>='. :)
19:15:41 <kerlo> bombshelter13: it's kind of like asking to see the definition of function application. Ultimately, it's nothing but a language primitive that isn't defined in terms of simpler things.
19:15:42 <Olathe> @type unIO
19:15:43 <lambdabot> Not in scope: `unIO'
19:15:50 <kerlo> @src unIO
19:15:50 <lambdabot> Source not found. Maybe you made a typo?
19:15:54 <kerlo> Aww.
19:16:13 <twb> aujgoljkf: you can't work with classes at all in OO, you have to instantiate them.
19:16:14 <pumpkin> bombshelter13: you know what it's supposed to do, how that's done depends on the language
19:16:29 <aujgoljkf> twb: yes, but you can test each class independently...
19:17:23 <kerlo> So, when GHC does >>= in IO, does it actually do that (k a) stuff and all?
19:17:45 <dolio> Yes.
19:17:57 <newsham> bomb: you can implement the state monad and pretend that it is the IO monad.
19:18:59 <newsham> bomb: there are a few monad impls in python already.  I have my own toy (http://www.thenewsh.com/~newsham/x/machine/monad.py) and this one plays some fun hacks to do something like "do" notation (http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html)
19:20:08 <kerlo> return = lambda x: lambda: x
19:20:25 <bombshelter13> newsham: yeah, I looked at some of those, but I'm trying to avoid directly copying one - though I stole some of the hacks to emulate the appearance of do notation. I'm trying to, as much as I can, do it from my own understanding, only taking directly from someone else's implementation when necesasry... part of the point of the exercise is to test my understanding :)
19:20:36 <kerlo> bind = lambda (x, f): lambda: f(x())()
19:20:42 <newsham> *nod*
19:20:49 <newsham> kerl: return is a keyword
19:20:57 <kerlo> Oh.
19:21:07 <kerlo> You'll have to misspell it, then.
19:21:42 <aujgoljkf> use return_ :p
19:21:44 <kerlo> retern, or, if you're British, retonne.
19:22:06 <ozy`> someone should try to implement "monads" in java in under 30,000 lines of code
19:22:15 <newsham> bomb: I personally like my syntax better than the hack using generators.  the syntax is nearly as clear and without the hack the code itself is clearer
19:22:17 <kerlo> Sounds fun.
19:22:29 <pilkarn> im doing opengl in scheme(well very basic so far) and im just starting to think on how to model really complex interactiosn and drawings. using classes seems like a natural way to do such things where each enemy or object has a drawing funciton and life  and bullets etc where appropriate.
19:22:33 <newsham> basically using normal operator overloading to define infix operators for monads
19:22:40 * bombshelter13 already made something that gets passed his monad class and returns a 'return' for it, which got bound to 'rio' cause it's nice and short.
19:22:49 <Axman6> hmm, trying to use the BSD licence, but i have nothing to out in the ORGANISATION place. what should i do with it?
19:23:02 <pilkarn> when writing ina functional style i would declare a data or defstruct carrying some info then copy-update it?
19:23:03 <bombshelter13> newsham: hm, the hack I was talking about stealing was the one involving overloading __rshift__
19:23:15 <ozy`> Axman6: put "Internet Superheroes International (ltd.)
19:23:15 <ozy`> "
19:23:17 <kerlo> pilkarn: sounds right.
19:23:23 <newsham> bomb:ahh, thats more or less what i'm advocating
19:23:36 * pumpkin is puzzled by augustss_'s interview on DSLs
19:23:39 <newsham> you should look at the other url I pasted at sometime to see the other approach, which is amusing and interesting
19:24:01 <Nafai> So close to getting this right
19:24:06 <Nafai> Just need to get it to compile :)
19:24:27 <Axman6> ozy`: heh
19:24:41 <bombshelter13> newsham: *looks at it*
19:24:50 <Axman6> but seriously, what do i put there? :\
19:25:06 <newsham> axman: why not just put your name or elide it?
19:25:21 <Axman6> yeah, i guess that'll work :\
19:25:37 <Axman6> maybe Axman6...
19:25:58 <Olathe> Organization: Source files for use with a Haskell compiler
19:26:31 <Olathe> Organization: Scattered about my hard drive
19:26:52 <lispy> Olathe: You put the big "O" in organization.
19:27:15 <ozy`> Axman6: or how about #haskell ;)
19:27:30 * SamB has been known to put "Messy" on web forms
19:27:38 <SamB> well, to myself, anyway
19:27:54 <SamB> or possibly that was Windows installers ...
19:28:03 <Olathe> lispy: Haha
19:28:47 <lispy> Olathe: the only problem with that joke is that if you say it to non CS geeks then it will sound lewd :)
19:29:07 <Olathe> We can use that for advertising.
19:29:43 * inimino will never look at big-O notation the same way again
19:29:47 <Nafai> Dang it
19:29:54 <Nafai> I'm struggling to use bracket
19:30:01 <lispy> :t bracket
19:30:02 <lambdabot> Not in scope: `bracket'
19:30:07 <lispy> ?hoogle bracket
19:30:08 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
19:30:08 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
19:30:08 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
19:30:28 <Olathe> @src bracket-
19:30:29 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:30:30 <Olathe> @src bracket
19:30:30 <lambdabot> bracket before after thing = block $ do
19:30:30 <lambdabot>     a <- before
19:30:30 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
19:30:30 <lambdabot>     after a
19:30:31 <lambdabot>     return r
19:30:33 <lispy> are parens missing in that type?
19:30:50 <ozy`> big-O notation has its own theme song: http://www.youtube.com/watch?v=AdA6iRk94Hc
19:30:58 <Nafai> lispy: I think so
19:31:16 <Nafai> It should be IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:31:30 <lispy> That is unfortunate
19:31:38 <lispy> ozy`: thanks!
19:32:01 <Olathe> @type bracket
19:32:02 <lambdabot> Not in scope: `bracket'
19:32:28 <lispy> ?type Control.Exception.bracket
19:32:29 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:33:35 <roconnor> do gmane links expire after a while?
19:33:37 <newsham> bracket allocateThing freeThing useThing
19:33:47 <lispy> Oh right, so example usage.  before creates something like a file handle, then thing uses it and after releases it
19:34:29 <Nafai> Yeah
19:34:36 <pumpkin> did cayenne get rolled into agda?
19:34:51 <lispy> pumpkin: someone was playing with cayenne just a couple months ago in here
19:34:56 <lispy> pumpkin: I want to say it was vixey
19:35:06 <pumpkin> ah
19:35:22 <lispy> But, that doesn't mean cayenne still exists :)
19:35:27 <pumpkin> was just checking the cayenne page and it said "check the agda page"
19:35:30 <lispy> Sometimes people just dig up antiques
19:35:32 <mmorrow> i tried to cabalify cayenne, but cabal bested me.
19:35:52 <mmorrow> cayenne very much works and you can use it
19:35:57 <dolio> I'm pretty sure there's no cayenne in agda.
19:36:05 <lispy> ?remember mmorrow i tried to cabalify cayenne, but cabal bested me.
19:36:06 <lambdabot> Nice!
19:36:15 <mmorrow> heh
19:36:37 * lispy has done his daily good deed and leaves
19:36:39 <lispy> see ya
19:37:46 <dolio> They have similar design goals, though.
19:38:02 <mmorrow> i think it would actually be relatively easy to just use cabal's "make" build type, and wrap it with that
19:38:16 <pumpkin> dolio: only thing that made think it was that the cayenne page tells you to check the agda page because the cayenne page hasn't been updated in ages
19:38:43 <mmorrow> i was trying to essentially use cabal itself to do what the Makefiles were doing, and it turned into a hellish epic
19:38:54 <pumpkin> haha "maybe you shouldn't be programming if you don't know anything about computer science" -augustss
19:39:11 <Olathe> ozy`: That's a lovely theme song :)
19:39:15 <Nafai> Yay
19:39:17 <Nafai> It compiled
19:39:21 <Nafai> Now let's see if it works
19:39:25 <dolio> Where's that from?
19:39:34 <pumpkin> dolio: http://www.infoq.com/interviews/DSL-Haskell-Lennart-Augustsson
19:39:43 <pumpkin> dolio: imo some of the questions were rather awkward
19:40:23 <ozy`> Olathe: when I took an algorithms class in college, I very nearly put that song on a stereo so I could play it whenever the professor talked about big-O notation
19:41:30 <Olathe> Hahaha
19:41:39 <Nafai> Hrm
19:41:43 <Nafai> This didn't do what I wanted :(
19:41:45 * ozy` is a gigantic nerd
19:42:00 <Nafai> Though it's not very clear
19:43:01 <Nafai> Oh well
19:43:06 <Nafai> That was a fun exercise while it lasted
19:43:09 <gnut> ll
19:43:15 * mmorrow 's firefox flash plugin just went into a loop where the interviewer is forever repeating "tell us tell us tell us tell us ....."
19:43:28 <mmorrow> i should record this
19:43:39 <mmorrow> ok, actually it gets old quick
19:43:44 <monochrom> hahaha
19:44:14 <dolio> What's the JVC compiler?
19:44:31 <mmorrow> this is what's looping npviewer.bin
19:44:37 <mmorrow> i killed firefox and it still lives!
19:45:09 * mmorrow dirt-naps it with killall -9
19:48:23 <mmorrow> dolio: what is JVC?
19:48:37 <redditbot> barrie: Pure Gtk GUI library for state based, user-driven interfaces
19:48:52 <dolio> In that article pumpkin posted, augustss is quoted as saying that "JVC" is the most used Haskell implementation.
19:49:02 <dolio> Which I assume is a misquote.
19:49:37 <tehgeekmeister> in StateT using mapM_ to print items in a list, do i lift the print or lift mapM_
19:49:42 <tehgeekmeister> ?
19:49:55 <pumpkin> dolio: yeah, 4:30
19:49:59 <pumpkin> he says GHC :)
19:50:20 <dolio> I'm just reading the transcript.
19:50:23 <mmorrow> dolio: oh, weird. i'm still downloading..
19:50:25 <mmorrow> oh
19:50:38 <pumpkin> dolio: aha, that way you avoid the awkwardness :P
19:50:59 <dolio> The first one about monads is still pretty bad.
19:51:09 <SamB> is code.haskell.org crawling for anyone else ?
19:51:09 <Axman6> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AVar hooray :)
19:51:19 <pumpkin> SamB: I couldn't even get it to load
19:51:23 <Axman6> hmm, how do i tell hackage to build docs?
19:51:29 <pumpkin> Axman6: it does so once a day
19:51:31 <SamB> pumpkin: give it a good 11 minutes ?
19:51:42 <Axman6> pumpkin: ah, right, thanks
19:51:53 <Axman6> so it doesn't build them when the package is uploaded?
19:51:53 <pumpkin> SamB: nah, I gave up :) maybe it isn't fully dead after all
19:51:57 <pumpkin> Axman6: nope
19:52:05 <Axman6> ok
19:52:12 <pumpkin> Axman6: your second package on hackage?
19:52:19 <Axman6> yep
19:52:27 <pumpkin> I need to get moving!
19:52:29 <pumpkin> I'm still at zero
19:52:42 <Axman6> the first one didn't have any docs, so didn't know how that stuff worked
19:53:40 <Axman6> heh, apparently it does have docs
19:53:44 <Axman6> the HARM one
19:54:05 <SamB> http://haskell.org/haskellwiki/Image:Trac-crawling.png
19:55:01 <SamB> pumpkin: see?
19:55:10 <SamB> it does actually finish loading eventually
19:55:12 <pumpkin> wow
19:55:13 <tehgeekmeister> printTargets st = mapM_ ((lift print) . S.toList . fromJust . flip M.lookup (targetMap st)) $ IS.toList $ checkForTargets st
19:55:15 <pumpkin> ddos?
19:55:20 <SamB> it just takes far too long to be anything useful
19:55:22 <tehgeekmeister> this is giving me an awfully confusing kind error
19:55:26 <SamB> pumpkin: doesn't look like
19:55:43 <Saizan> wow, implementing LC with closures is much nicer than with substitution, assuming i got it right..
19:55:43 <tehgeekmeister> checkForTargets st evaluates to an IS.IntSet
19:55:53 <SamB> neither tailing /var/log/apache2/access.log nor top gives any indication of DDoS
19:56:12 <tehgeekmeister> what's going on there?
19:56:39 <pumpkin> SamB: oh, they give ssh access?
19:56:51 <mmorrow> whenever i enable firebug, firefox will go into a loop every 20 minutes or so at 100% (of only one processor ;) until i kill it
19:56:59 <SamB> pumpkin: how else are we supposed to upload to our repositories and so forth?
19:57:37 <mmorrow> Saizan: ooh, interesting. code snippets anywhere?
19:58:38 <SamB> dcoutts: Igloo: any ideas ?
19:58:48 <pumpkin> SamB: in many cases people set up an ssh without a shell on the other side, that only allows one service through
19:59:00 <SamB> pumpkin: for darcs ?
19:59:03 <pumpkin> I have no idea :)
19:59:08 <pumpkin> I'm a darcs noob
19:59:20 <SamB> anyway, how would we edit our trac.ini files then ?
19:59:30 <Saizan> mmorrow: in prolog, http://pastebin.com/m1d65a371
19:59:31 * pumpkin shrugs :)
19:59:46 <mmorrow> Saizan: the sml-nj rts/exec model is super cool/clean. this is a good description: http://ncstrl.cs.princeton.edu/expand.php?id=TR-220-89
20:00:00 <_Jordan_> is there a function that takes a list of functions and an argument for those functions, and returns a list of the results? Something like [(a -> b)] -> a -> [b]
20:00:02 <mmorrow> err, this link if that one doesn't work: http://www.cs.princeton.edu/research/techreps/TR-220-89
20:00:26 <erikc> ooo fun
20:00:38 <mmorrow> heh, i've gotta learn prolog one of these days
20:00:50 <SamB> does anyone know who else has root on community.haskell.org ?
20:01:19 <Olathe> @pl \xs y -> map (\f -> f y) xs
20:01:20 <lambdabot> flip (map . flip id)
20:01:32 <kerlo> _Jordan_: what Olathe said.
20:01:37 <mmorrow> this is awesome too: http://www.cs.princeton.edu/~appel/papers/hotslide.ps
20:01:46 <Olathe> > flip (map . flip id) [(+1), (*2)] 3
20:01:47 <lambdabot>   [4,6]
20:01:50 <mmorrow> "Hot-sliding in ML."
20:01:57 <_Jordan_> thanks :)
20:02:17 <kerlo> Olathe, how dare you think in lambdas instead of combinators? :-P
20:02:20 <mmorrow> actually, just scan this page http://www.cs.princeton.edu/~appel/papers/
20:02:40 <mmorrow> , [$ski|SKIKSIKIKISKISKSSSKKSK|]
20:02:46 <lunabot>  S :$ K
20:02:49 <mmorrow> haha
20:02:50 <gwern> SamB: that's horrible! at least half those requests should be cacheable!
20:03:02 * gwern is looking at the firebug output
20:03:04 <SamB> gwern: which of them ?
20:03:06 <dsrogers> if I defined an instance for Monad m => Monad (MyMonad m) and an instance for MonadError m => Monad (MyMonad m) will haskell pick the more specific one when possible?
20:03:10 <Sekaino> _Jordan_:  alternately,   foo fs x = fs >>= return ($ x)
20:03:13 <Olathe> @undo do { f <- xs; return (f y) }
20:03:13 <lambdabot> xs >>= \ f -> return (f y)
20:03:25 <Olathe> @pl \xs y -> xs >>= \ f -> return (f y)
20:03:25 <lambdabot> flip (fmap . flip id)
20:03:31 <rwbarton> dsrogers: no
20:03:31 <Olathe> There we go :)
20:03:34 <pumpkin> that's pretty lame
20:03:43 <gwern> SamB: oh, the gifs and pngs absolutely,the js likely, and I don't see why the redirect
20:03:45 <erikc> heh, i remember borrowing Compiling with Continuations from the library after university and being completely bewildered, i should revisit it
20:03:48 <SamB> gwern: possibly they had expired from the cache when I killed firefox unexpectedly ?
20:03:52 <rwbarton> dsrogers: contexts are completely irrelevant to instance selection
20:04:11 <SamB> gwern: the redirect was because I typed the URL without a trailing /
20:04:14 <dsrogers> ah.  so it will bitch about overlapping instances?
20:04:16 <mmorrow> dsrogers: iirc when you're using overlapping instances it'll resort to whichever comes first in the file or some other nasty heuristic (iirc)
20:04:19 <gwern> SamB: well the obvious thing to do is to visit the page again, or look at the headers and see whether any cache or expire headers are there
20:04:19 <rwbarton> dsrogers: yup
20:04:40 <SamB> gwern: the really awful part is the part where it took nearly 35 minutes to load the page ???
20:04:49 <kerlo> I once tried to use GHC as a theorem prover, but it apparently wasn't smart enough.
20:05:17 <gwern> SamB: well I am a little perplexed how just he redirect took 12 minutes
20:05:21 <kerlo> I think it gave me three overlapping instances-style error messages at once.
20:05:28 <kerlo> @ghc instances
20:05:28 <lambdabot> ghc says: Use -fallow-incoherent-instances
20:05:38 <rwbarton> Don't do what it says!!1
20:05:38 <kerlo> That was one of them.
20:05:57 <dsrogers> if I wrote an instance like Monad m => Monad (MyMonad (ErrorT m)) would it know how to distinguish?
20:06:14 <Pseudonym> GHC should also -fallow-incoherent-programmer
20:06:18 <kerlo> @ghc instances
20:06:18 <lambdabot> ghc says: Use -fallow-incoherent-instances
20:06:21 <kerlo> Aww.
20:06:24 <mmorrow> @ghc
20:06:24 <lambdabot> ghc says: Simplifier reached fixed point
20:06:31 <mmorrow> @ghc
20:06:31 <lambdabot> ghc says: yi-static: internal error: TSO object entered!
20:06:37 <mmorrow> @ghc
20:06:37 <lambdabot> ghc says: Ambiguous constraint
20:06:48 <rwbarton> dsrogers: only if the other instance is of the form Monad (MyMonad (X m)) for some other X, or more generally something that can't unify with the first instance
20:06:51 <kerlo> ghc: well, all that means is that you can make it really, really simple!
20:07:21 <dsrogers> if the other instance is Monad (MyMonad m) it will complain?
20:07:26 <SamB> kerlo: which, the fixed point one ?
20:07:34 <rwbarton> dsrogers: yes
20:07:38 <mmorrow> > let infixr 99999999 . in 42
20:07:38 <kerlo> SamB: yep.
20:07:39 <lambdabot>   <no location info>: Precedence out of range
20:07:55 * kerlo blinks
20:08:09 <SamB> let infixr 10 . in 42
20:08:17 <mmorrow> interesting:
20:08:18 <mmorrow> ghc says: Warning: you can make GHC diverge by using SPECIALISE INLINE on an ordinarily-recursive function.
20:08:20 <SamB> > let infixr 10 . in 42
20:08:21 <lambdabot>   <no location info>: Precedence out of range
20:08:36 <SamB> > let infixr 9 . in 42
20:08:37 <lambdabot>   Not in scope: `.'
20:08:41 <rwbarton> > let infixr 9.5 . in 42
20:08:42 <lambdabot>   <no location info>: parse error on input `9.5'
20:08:47 <SamB> hmm, that error is a bit wierd
20:08:48 <mmorrow> ghc says: NEVER use commas within those string literals, cpp will ruin your day
20:08:58 <kerlo> ghc says: internal error: Riemann hypothesis failed to hold
20:09:28 <SamB> it should say ". not defined in this binding construct" or something
20:09:30 <dsrogers> kerlo: your ghc just won a million dollars for you
20:09:46 <kerlo> (P.S. The encrypted proof is found at ~ghc/proof. Please send it to the GHC team for examination.)
20:09:47 <rwbarton> I'm not sure you can also get $1M for proving not RH
20:09:52 <SamB> dsrogers: it turned out to be in error
20:10:49 <kerlo> > let x = 5; infixr x . in 42
20:10:50 <lambdabot>   <no location info>: parse error on input `x'
20:11:31 <rwbarton> , [| let infixr 9 . in 42 |]
20:11:32 <lunabot>  luna: The fixity declaration for `.' lacks an accompanying binding
20:11:44 <rwbarton> , let infixr 9 . in 42
20:11:45 <lunabot>  luna: The fixity declaration for `.' lacks an accompanying binding
20:11:49 <rwbarton> SamB: looks like they did improve it!
20:11:58 <dsrogers> how do I make orphaned instance warnings go away?
20:12:13 <pumpkin> dsrogers: don't make orphan instances? :P
20:12:20 <SamB> -fno-warn-orph... something or other
20:12:24 <pumpkin> but I don't reallly know :)
20:12:33 <dsrogers> what is an orphaned instance?
20:12:37 <kerlo> @ghc proof
20:12:37 <lambdabot> No quotes match. Just what do you think you're doing Dave?
20:12:41 <dsrogers> I mean, I can't remove it from a file.
20:12:47 <pumpkin> dsrogers: one where neither the class nor the datatype implementing it is in the module
20:12:52 <SamB> oh, an instance in a module that neither defines the class nor the type
20:13:07 <dsrogers> why is this a problem?
20:13:07 <SamB> it's nothing wrong with your code, it just compiles slower maybe
20:13:12 <dsrogers> ah
20:13:13 <dsrogers> ok
20:13:17 <kerlo> Can I get a list of all the @ghc quotes, or are they Better Enjoyed This Way?
20:13:29 <pumpkin> dsrogers: different modules could make instances that overlap, I think
20:13:37 <SamB> GHC might have to recompile more things or look in more interface files or something
20:13:50 <pumpkin> in some cases it seems necessary
20:14:11 <pumpkin> like making Arbitrary instances for types that don't come with them
20:14:13 <dsrogers> :t fail
20:14:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
20:14:22 <mmorrow> kerlo: they're probably in the lambdabot darcs repo somewhere
20:14:58 <dsrogers> :info Arbitrary
20:15:12 <kerlo> @ghc
20:15:14 <lambdabot> ghc says: the eta-reduction property does not hold
20:15:19 <kerlo> I could search Google.
20:15:38 <rwbarton> @quote ghc phd
20:15:38 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
20:16:18 <SamB> mmorrow: yeah, they would be
20:16:22 <ozy`> @ let id = seq undefined
20:16:25 <ozy`> whoops
20:16:29 <SamB> I think there are even @messages in the repo ;-P
20:16:46 <pumpkin> yeah, it seems strange to put those in there
20:16:47 <SamB> thankfully, I don't think any of them are for me
20:17:01 <pumpkin> I don't think people use it much for private communication but I didn't read them just in case
20:17:43 * SamB wonders how to report a bug in Haskell-mode
20:19:29 <lepassive> is there a good reference on IORef ?
20:20:04 <pumpkin> lepassive: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
20:20:15 <pumpkin> it's just a mutable variable, really
20:20:45 <lepassive> pumpkin, I saw the docs, but i don't get how it's used in write yourself a scheme
20:20:59 <pumpkin> url?
20:21:00 <lepassive> pumpkin, aren't variables mutable in haskell?
20:21:09 <pumpkin> nope
20:21:20 <kerlo> Did GHC ever actually say that last one?
20:21:44 <SamB> kerlo: probably it was in the source code somewhere
20:22:07 <dsrogers> what's the best way to date string?
20:22:08 <lepassive> pumpkin, http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Adding_Variables_and_Assignment
20:22:34 <pumpkin> lepassive: which bit don't you get?
20:22:35 <SamB> dsrogers: ask king steve
20:22:54 <dsrogers> ...
20:23:04 <dsrogers> err, get a stringified date.
20:23:12 <SamB> oh, no idea
20:23:13 <pumpkin> lol
20:23:14 <dsrogers> king steve?  won't you please tell me?
20:23:22 <SamB> but at least I can understand that question
20:23:31 <SamB> @go 8-bit theater
20:23:32 <lepassive> pumpkin, that part actuall type Env = IORef [(String, IORef LispVal)]
20:23:32 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
20:23:37 <lepassive> actually*
20:23:40 <SamB> @go nuklear power
20:23:43 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
20:23:57 <pumpkin> lepassive: that's a mutable association list of name bindings to mutable variables :P
20:24:06 <pumpkin> the list itself is not mutable
20:24:23 <pumpkin> not sure that made much sense though :P
20:24:25 <andresj> @version
20:24:25 <lambdabot> lambdabot 4.2.2
20:24:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:24:36 <lepassive> pumpkin, no it didn't actually :(
20:24:36 * pumpkin is half asleep
20:24:46 <ozy`> lepassive: any time you see "IORef x," that's a mutable variable which can contain a (probably immutable) value of type x
20:25:03 <pumpkin> lepassive: so say you do (define var 1) in scheme
20:25:10 <kerlo> They say that random data has special healing powers.
20:25:11 <SamB> http://www.nuklearpower.com/daily.php?date=041104
20:25:15 <kerlo> @go Xb+l2`9[zp['.N"}Vi#8hfXJS"\FEy$(O[^)IN%T\$vjQZ$:G*qN{HAP$uyIT}#
20:25:16 <lambdabot> No Result Found.
20:25:22 <kerlo> See? No error message.
20:25:30 <SamB> dsrogers: that page contains both king steve and string
20:25:33 <pumpkin> that's would lead to [("var", <an IORef pointing to the Int 1>)]
20:25:37 <SamB> it probably isn't the only one
20:25:49 <lepassive> ozy`, how can a mutable variable hold an immutable value ?
20:25:55 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 99; readSTRef x)
20:25:56 <lunabot>  99
20:26:05 <Olathe> kerlo: What sort of evil is that ?
20:26:10 <pumpkin> lepassive: do you know c?
20:26:19 <mmorrow> @let x := a = writeSTRef x a
20:26:20 <lambdabot>  <local>:18:20:
20:26:20 <lambdabot>      Ambiguous occurrence `x'
20:26:20 <lambdabot>      It could refer to either `...
20:26:24 <mmorrow> @let x .= a = writeSTRef x a
20:26:24 <lepassive> pumpkin, yes
20:26:25 <lambdabot>  Defined.
20:26:44 <pumpkin> lepassive: think of an IORef as a pointer to a value, maybe
20:26:50 <mmorrow> @let (#) = readSTRef
20:26:50 <lambdabot>   Parse error
20:26:59 <mmorrow> @let (!!!) = readSTRef
20:27:00 <lambdabot>  Defined.
20:27:02 <ozy`> lepassive: in C, for example, a numeric value is immutable (you can't say 3 = 4 like in fortran) but a variable that holds it is mutable
20:27:03 <kerlo> Olathe: my root password, of course.
20:27:12 <mmorrow> @let ref = newSTRef
20:27:13 <lambdabot>  Defined.
20:27:19 <rwbarton> Parse error?
20:27:31 <mmorrow> > runST (do x <-ref 42; x .= 99; (x!!!))
20:27:32 * pumpkin braces himself for epic mmorrow ST action
20:27:32 <lambdabot>   /tmp/2541233949568578173:70:48: Not in scope: `runST'
20:27:36 <lepassive> pumpkin, ozy`, aha i get it now thanks so much
20:27:37 <mmorrow> gah!
20:27:48 <Saizan> ozy`: you can say 3 = 4 in fortran?
20:27:56 <ozy`> Saizan: in older versions, yes
20:28:09 <mmorrow> ozy`: what happens?
20:28:09 <pumpkin> mmorrow: why not :=, or is that not a valid operator?
20:28:22 <mmorrow> pumpkin: it's a datacon/tycon :/
20:28:29 <pumpkin> oh, duh
20:28:30 <pumpkin> :(
20:28:32 <Saizan> : is considered uppercase
20:28:34 <lepassive> ozy`, isn't 3=4 something like test for equality not assignment ?
20:28:40 <mmorrow> pumpkin: heh, i always forget too
20:28:44 <ozy`> mmorrow: exactly what it looks like. from that point on, any use of the constant 3 will produce the value 4 instead
20:28:53 <mmorrow> ozy`: heh
20:28:54 <ozy`> lepassive: ....in fortran?
20:29:18 <rwbarton> Fortran gave us .EQ. for equality
20:29:18 <Saizan> that's a really large value of 3
20:29:23 <lepassive> ozy`, yes. i don't get how 3=4 ?
20:29:25 <kerlo> 3 = 4 ought to say something like "Inconsistent; exiting.
20:29:30 <rwbarton> We threw it away pretty quickly
20:29:47 <kerlo> Let me finish that.
20:29:59 <mmorrow> rwbarton: i think the parse error is because @let has -XCPP on
20:30:09 <ozy`> lepassive: it's an assignment statement in fortran.
20:30:24 <mmorrow> > let (#) = (+) in 4
20:30:25 <lambdabot>   <no location info>: parse error on input `)'
20:30:27 <Saizan> > let 3 = 4 in 3
20:30:28 <lambdabot>   3
20:30:32 <rwbarton> mmorrow: good theory... but it doesn't affect let (#) = id in (new) ghci
20:30:47 <rwbarton> mmorrow: or ghci-6.8.2
20:30:51 <mmorrow> rwbarton: oh! i think it's unboxed tuples
20:30:54 <lepassive> Saizan, can i say damn in #haskell ?
20:31:01 <mmorrow> -fglasgow-exts
20:31:03 <rwbarton> mmorrow: :set -XMagicHash also has no effect
20:31:13 <rwbarton> mmorrow: ah bingo
20:31:16 <ozy`> lepassive: you can even say "the winslow" in #haskell!
20:31:21 <kerlo> "Inconsistent; exiting. Please send the attached disproof to the program developers." Or, if the program is empty, "Inconsistent; exiting. Please send the attached disproof to the Clay Mathematics Institute."
20:31:25 <rwbarton> -XUnboxedTuples, I didn't realize that was a separate option.
20:32:07 <mmorrow> rwbarton: i actually had this happen to me once. i couldn't figure out wtf was happening, and Igloo thought of it in #ghc
20:32:22 <rwbarton> > (# 3, 4 #)
20:32:23 <lambdabot>       Illegal binding of unboxed tuple e_134 :: (# t_a2yT, t_a2yV #)
20:32:24 <lepassive> ozy`, :D
20:32:38 <mmorrow> , let x = (# 3,4 #) in 2
20:32:39 <lunabot>  luna: A section must be enclosed in parentheses thus: (# 3)
20:32:46 <mmorrow> wuh
20:32:47 <rwbarton> > let x = (# 3, 4 #) in 2
20:32:48 <lambdabot>       Illegal binding of unboxed tuple x :: (# t_a2zp, t_a2zr #)
20:32:48 <lambdabot>      In the ...
20:32:57 <rwbarton> > let (# x, y #) = (# 3, 4 #) in 2
20:32:57 <mmorrow> i must not have unboxed tuples on
20:32:58 <lambdabot>   2
20:33:04 <lepassive> here is my understanding test IORef [(String, IORef LispVal)] means we got assoc list can be modified with immutable keys and mutable values is that right ?
20:33:07 <rwbarton> > id (# 3, 4 #)
20:33:08 <lambdabot>   Couldn't match kind `(#)' against `*'
20:33:08 <mmorrow> , let (#) = (+) in 2
20:33:09 <lunabot>  2
20:33:52 <SamB> lepassive: it means, among other things, that you should stock up on aspirins ;-P
20:34:09 <ozy`> lepassive: it's important to note that the list itself can never be modified. instead, you're copying the altered parts of the list, creating a new list, and assigning a reference to that new list as the new value of the IORef
20:34:41 <kerlo> > (# 3, 4 #)
20:34:42 <lambdabot>       Illegal binding of unboxed tuple e_134 :: (# t_a2yT, t_a2yV #)
20:34:57 <rwbarton> > let x# = 3 in x#
20:34:58 <lambdabot>   3
20:35:00 <lepassive> aha i see
20:35:10 <kerlo> > (# 3, t_a2tT #)
20:35:11 <lambdabot>   Not in scope: `t_a2tT'
20:35:11 <lepassive> well thanks again folks
20:35:14 <kerlo> Aww.
20:35:19 <mmorrow> > let ## = 3 in ##
20:35:20 <lambdabot>   <no location info>: parse error on input `##'
20:35:26 <mmorrow> > let _## = 3 in _##
20:35:28 <lambdabot>   3
20:35:42 <mmorrow> > let _' = 3 in _'
20:35:43 <lambdabot>   3
20:35:54 <mmorrow> > let _'_ = 3 in _'_
20:35:55 <lambdabot>   3
20:36:00 <SamB> kerlo: that was a type variable!
20:36:08 <SamB> , (# 3, 4 #)
20:36:09 <lunabot>  luna: A section must be enclosed in parentheses thus: (# 3)
20:36:17 <mmorrow> lunabot doesn't have unboxed tuples on
20:36:25 <SamB> mmorrow: so I see!
20:36:41 <mmorrow> i don't believe you
20:36:50 <mmorrow> :)
20:36:55 <rwbarton> > let proc = id in proc 3
20:36:56 <lambdabot>   3
20:37:08 <SamB> mmorrow: why else would it give me that error message instead of something about not being able to show an unboxed tuple ?
20:37:25 <mmorrow> SamB: because this is the twilight zone.
20:37:31 <rwbarton> I like that "A section must ..." error, it's well crafted
20:37:57 <mmorrow> yeah, the "thus" is a nice touch
20:38:02 <rwbarton> , [ # 3 ]
20:38:03 <lunabot>  luna: A section must be enclosed in parentheses thus: (# 3)
20:38:26 <coco`> the ghc manual says that unboxed types can't be used with anything
20:38:26 <coco`> 	polymorphic ... is there a way around this?
20:38:30 <rwbarton> @ghc rigid
20:38:30 <lambdabot> No quotes match. My pet ferret can type better than you!
20:38:32 <dsrogers> can haskell do multiline string constants?
20:38:37 <kerlo> SamB: you mean types *still* aren't values in Haskell? :-)
20:38:38 <SamB> coco`: nope!
20:38:39 <rwbarton> dsrogers: "yes"! :)
20:38:49 <kerlo> "ye\
20:38:50 <kerlo> \s"
20:38:53 <rwbarton> dsrogers: wait, actually yes
20:38:54 <kerlo> Or something like that, anyway.
20:39:03 <coco`> SamB: doesn't that make them quite useless, if you can't even have lists of them? what about arrays?
20:39:24 * wli keeps getting bad subtractions.
20:39:26 <kerlo> coco`: put them in a data constructor.
20:39:33 <kerlo> @src Int
20:39:33 <lambdabot> data Int = I# Int#
20:39:36 <kerlo> Like that.
20:39:39 <SamB> coco`: they aren't called low-level for no reason!
20:40:33 <coco`> kerlo: so you suggest re-boxing them to put them in a list?
20:40:43 <kerlo> I guess.
20:40:54 <kerlo> Though that's what non-unboxed types are for.
20:41:02 <kerlo> As far as I can tell, unboxed types are useless. :-)
20:42:13 <pumpkin> coco`: usually the easiest way to work with them is to make a strict data X = X !Int !Int !Int (or whatever you need) and add -funbox-strict-fields
20:42:44 <hackage> Uploaded to hackage: AVar 0.0.1
20:42:49 <lepassive> Prelude Data.IORef> let x=newIORef 4 . ican't view what value x refs to using readIORef ?
20:43:06 <coco`> pumpkin: does that option do anything for data X = X !a ?
20:43:21 <Saizan> lepassive: x <- newIORef 4
20:43:27 <pumpkin> coco`: if a isn't polymrphic and is unboxable, sure
20:43:49 <Saizan> lepassive: in your example 'x' is just an action that will create an IORef, not an IORef per se
20:43:54 <coco`> sorry, I meant data X a = X a, so I guess no
20:43:56 <rwbarton> lepassive: let x = newIORef 4 means quite literally x equals newIORef 4
20:44:06 <rwbarton> lepassive: there are no tricks in haskell :)
20:44:08 <coco`> X !a
20:44:10 <lepassive> Saizan, it works now thanks
20:44:20 <pumpkin> gotta run, bbl
20:44:21 <coco`> pumpkin: data X a = X !a
20:44:38 <lepassive> rwbarton, yep i got it it means run action newIORef 4 and give me the result of it
20:44:42 <coco`> bye
20:46:58 <rwbarton> what's a good name for the value of type (Applicative a) => a () ?
20:47:32 <dolio> unit?
20:47:43 <rwbarton> That was my leaning also
20:51:28 <andresj> hey is there already a website that allows one to evaluate Haskell expressions?
20:52:04 <ozy`> codepad.org
20:52:38 <ozy`> > foldl1 (+) [1..10] -- there's also lambdabot
20:52:39 <lambdabot>   55
20:53:13 <Olathe> http://codepad.org/srsalROZ
20:53:52 <lifflander> Why does the "let" inside of the "do" construct no use an "in"? Isn't that inconsistant?
20:54:34 <Olathe> No, it means something else.
20:54:40 <ozy`> lifflander: an "in" gets inserted by the compiler when the do block is "unwrapped"
20:55:12 <ozy`> @undo do { let x = 3; putStrLn "pizza" }
20:55:12 <lambdabot>  Parse error at "}" (column 34)
20:55:15 <Olathe> > let f xs = do { x <- xs; let y = x + 2 in return y } in f [1..10]
20:55:16 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
20:55:17 <ozy`> @undo do { let x = 3; putStrLn "pizza"; }
20:55:17 <lambdabot>  Parse error at ";" (column 33)
20:55:22 <ozy`> hruuuugh
20:55:25 <Olathe> That uses the normal in syntax.
20:55:32 <ozy`> oh wait
20:55:39 <ozy`> @undo do { let {x = 3}; putStrLn "pizza"; }
20:55:39 <lambdabot> let { x = 3} in putStrLn "pizza"
20:55:59 <lepassive> what is IO Port ?
20:56:05 <lifflander> Okay, thanks, I wonder why they have the compiler do that?
20:56:25 <rwbarton> the binding scopes over the entire rest of the do block
20:56:42 <rwbarton> so it wouldn't really make sense to write "in" anywhere
20:56:55 <ozy`> lifflander: because there's no sane way to leave the "in" there without messing up the layout semantics of the do block
20:57:10 <lifflander> Okay, thanks for the explanation.
20:57:16 <Olathe> If you write in, it should only go to the next semicolon, I think.
20:57:34 <lifflander> What kind of programming do you guys normally do in haskell?
20:57:49 <dobblego> backward-baseball-hate programming
20:57:52 <dobblego> *hat
20:58:00 <lifflander> What does that mean?
20:58:11 <ozy`> I program lions
20:58:14 * ozy` gets in the car
20:58:17 <dobblego> turn your baseball hat backward and program haskell
20:58:34 <monochrom> I eat my hat before I write programs.
20:58:45 <lifflander> I am writing an AI agent that gauges the difficultly of Minesweeper configurations...
20:58:52 <dobblego> lifflander, the question pre-supposes the formation of the concept of "kinds of programming
20:59:06 <andresj> hahaha lol i knew there had to be one! lol i was thinking of making one myself... i might still. There is something nice about http://somehaskell.org/t/reverse and http://somehaskell.org/e/reverse%20"some%20text"....
20:59:36 * wli fails division.
20:59:40 <Olathe> I make programs that give secret messages: http://codepad.org/srsalROZ
20:59:56 <erikc> lifflander: i write tools for game pipelines + write all my game code in haskell first (then I translate it to C++)
21:00:58 <lifflander> A better question would be: What programs have you written or are writing in haskell?
21:01:22 <lifflander> Last year, I finished a full first-order predicate logic theorem prover based on sequent calculus in haskell.
21:02:40 <monochrom> nice
21:03:09 * wli is bombing basic arithmetic. Logic is a bit of a stretch.
21:03:37 <monochrom> I'm writing a translator from a simple notation I need to use in my course into PVS notation. I don't want to burden my students with manual translation or learning PVS.
21:03:40 <lifflander> It was huge project. I ended up writing the front end in F#. Any F# programmers around?
21:03:48 <lifflander> Or SML?
21:03:58 <monochrom> I also implemented some factoring algorithms.
21:04:22 <lifflander> Like algebra factoring?
21:04:34 <monochrom> Like 6=2*3.
21:05:04 * wli has lost enough brain cells to make basic arithmetic require heroic effort if it's even possible. Factoring in any nontrivial way is hopeless.
21:05:06 <lifflander> Isn't that a one-liner in haskell (not optimized)?
21:05:36 <monochrom> You mean «main = putStrLn "2*3"»? Yes.
21:05:58 <lifflander> No...pulling up GHCI for an example...
21:08:23 <monochrom> I also wrote a program to delete stuff in Nautilus's metafiles. They're in XML and I want to parse, delete useless nodes, save.
21:09:56 <wli> > let primes = nubBy (((>1) .) . gcd) [2..] ; factor' ~(p:ps) n = if n == 1 then [] else let (q, r) = n `divMod` p in if r == 0 then p : factor' (p:ps) q else factor' ps n ; factor = factor' primes in factor 6
21:09:57 <lambdabot>   [2,3]
21:10:22 <lifflander> let factors x = [a | a <- [1..x], x `mod` a == 0]
21:10:42 <lifflander> Really should only go to the square root...
21:11:25 <lifflander> How to I target the "lambdabot"?
21:11:36 <mmorrow> > fix error
21:11:37 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
21:11:40 <lifflander> >let factors x = [a | a <- [1..x], x `mod` a == 0] in factors 6
21:11:50 <mmorrow> you need a space
21:11:58 <lifflander> > let factors x = [a | a <- [1..x], x `mod` a == 0] in factors 6
21:11:58 <mmorrow> > 4
21:12:00 <lambdabot>   [1,2,3,6]
21:12:00 <lambdabot>   4
21:12:01 <wli> Those would be divisors, but anyway.
21:12:19 <lifflander> Right...
21:12:59 <wli> Quick checks would be factoring the Euclid numbers.
21:14:12 <wli> euc | n == 1 = 2 | otherwise = product [e k | k <- [1 .. n - 1]] + 1
21:15:09 <lifflander> > let factors x = [(a, (x `div` a)) | a <- [1..(floor . sqrt . fromIntegral $ x)], x `mod` a == 0] in factors 6
21:15:10 <lambdabot>   [(1,6),(2,3)]
21:17:29 <miloshh>  let factors x = [(a, (x `div` a)) | a <- [1..(floor . sqrt . fromIntegral $ x)], x `mod` a == 0] in factors 123456789
21:18:04 <lifflander> I agree, not the most efficient.
21:18:53 <lifflander> But, that shouldn't take too long...
21:19:03 <lifflander> > let factors x = [(a, (x `div` a)) | a <- [1..(floor . sqrt . fromIntegral $ x)], x `mod` a == 0] in factors 123456789
21:19:04 <lambdabot>   [(1,123456789),(3,41152263),(9,13717421),(3607,34227),(3803,32463),(10821,1...
21:19:13 <lifflander> > let factors x = [(a, (x `div` a)) | a <- [1..(floor . sqrt . fromIntegral $ x)], x `mod` a == 0] in factors 1234567899
21:19:14 <lambdabot>   [(1,1234567899),(3,411522633),(9,137174211),(27,45724737),(81,15241579),(10...
21:19:25 <lifflander> > let factors x = [(a, (x `div` a)) | a <- [1..(floor . sqrt . fromIntegral $ x)], x `mod` a == 0] in factors 12345678999
21:19:26 <lambdabot>   [(1,12345678999),(3,4115226333),(9,1371742111)]
21:19:38 <lifflander> Not too bad...
21:19:58 <miloshh> interesting, the factorization has primes like 3607 and 3803 :)
21:21:27 <lifflander> I'm leaving, bye.
21:22:12 <andresj> @hoogle nubBy
21:22:12 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
21:23:27 <monochrom> Obsession with known poor algorithms just because they're one-liners is sick.
21:24:32 <monochrom> "here is a bad sorting algorithm, but it's so short!" "here is a bad factoring algorithm, but it's so short!"
21:24:51 <monochrom> Here is an infinite loop that wastes memory, but it's so short!
21:25:40 <wli> > let factors :: Integer -> [(Integer, Int)] ; factors n = map (\ps -> (head ps, length ps)) . group . catMaybes $ unfoldr (\(k, qs) -> if k == 1 then Nothing else case qs of { [] -> Just (Just k, (1, [])) ; p:ps -> Just $ let (q, r) = k `divMod` p in if r == 0 then (Just p, (q, p:ps)) else (Nothing, (k, ps))}) (n, [2..n-1]) ; euc :: Integer -> Integer ; euc 1 = 2 ; euc n = product (map euc [1 .. n - 1]) + 1 in [let e = euc k in (e, factors e) | k <- [1 ..
21:25:41 <lambdabot>   <no location info>: parse error on input `;'
21:25:48 <wli> etc.
21:27:03 <monochrom> I should consider re-subscribing to haskell-cafe to complain about that sickness.
21:29:18 <rwbarton> monochrom: I don't see it as a problem, a nice thing about haskell is that it should take about the same amount of text to describe a problem in haskell or in english, but of course, if you want a clever efficient algorithm, that will take more text in either language.
21:31:53 <miloshh> monochrom: so many people in this world spend their days implementing english one-liners in thousands of lines of C++
21:32:02 <monochrom> Don't tell me that «sort (x:xs) = sort (filter (<=x) xs) ++ x ++ sort (filter (>x) xs)» describes the problem of sorting. It emphatically describes a known poor solution.
21:33:02 <rwbarton> monochrom: I honestly have no idea what it is that bothers you
21:33:49 <rwbarton> monochrom: is it somehow bad that haskell lets you write both inefficient short programs and efficient longer programs?
21:34:09 <kmeyer> anyone know how big all the packages in hackage (just current versions) combined is?
21:34:20 <monochrom> I thought I stated my concern clearly.
21:34:24 <rwbarton> short and obviously correct programs, at that.
21:34:30 <monochrom> <monochrom> Obsession with known poor algorithms just because they're one-liners is sick.
21:35:00 <monochrom> I'm clearly talking about an obsession. Hell the sentence begins with the very word "obsession".  Obsession is attributed to people.
21:35:10 * mmorrow is reminded that he wanted to one-liner-w/in-bot-length-restrictions his fft
21:35:20 <monochrom> I'm talking about what some people do, not what Haskell lets people do.
21:35:29 <rwbarton> I don't see this obsession that you do
21:35:59 <rwbarton> of course no one is going to implement an in-place quicksort algorithm in an IRC chat window
21:36:39 <Pseudonym> That's because in-place algorithms are unnecessarily verbose.
21:36:42 <mmorrow> a sweet program would be one that takes a prog as input, and spits out the shortest one-liner it can manage
21:36:43 <monochrom> Did you see that after I mentioned "I implemented some factoring algorithms" there was a response "isn't it a one-liner?" and then a lengthy session spewing out more and more inefficient one-liners? That is evidence of obsession.
21:37:26 <wli> Is that directed at me?
21:37:43 <monochrom> Not just you. There were two people.
21:38:29 <wli> I was trying to make the point that the inefficiency was bad enough to prevent usage in the interesting obvious case of Euclid numbers.
21:39:16 <mmorrow> well, i'm sure implementing an in-place quicksort is possible in an irc window, and to do so would take skill (and i would definitely add that to my #haskell-bot-one-liners file should someone manage it)
21:39:47 <ddarius> \n -> filter ((n ==) . uncurry (*)) (liftM2 (,) [1..n] [1..n])
21:39:48 <rwbarton> monochrom: You didn't quote the whole response
21:39:51 <mmorrow> one-liners are like any other programs. they can be trivial or not, efficient or not
21:44:43 * ddarius proposes trying to find the combination of shortest and least efficient (but terminating) program.
21:45:11 <wli> let u = u in u
21:45:23 <ddarius> wli: That does not terminate.
21:45:42 <ddarius> And to be explicit, to solve a given task.
21:45:58 <wli> let u | False = u in u
21:47:05 <ddarius> wli: That either "doesn't terminate" or it is not very inefficient.  Either way to doesn't solve any task.
21:47:33 <mmorrow> ddarius: that is a hopeless task, because it could always be made less efficient (wrt clock time)
21:47:44 <mmorrow> you need to say wrt complexity
21:47:48 <ddarius> mmorrow: "combination of shortest and least efficient"
21:48:04 <mmorrow> i don't see how that changes things
21:48:10 <rwbarton> foldr (^) [2..99] `seq` whatever  should slow things down a bit
21:48:15 <mmorrow> you could always do "busy work"
21:48:15 <rwbarton> *foldr1
21:48:20 <monochrom> You can fix a computer and let people compete.
21:48:21 <mmorrow> that O(2^n)
21:48:26 <ddarius> mmorrow: You are capable of making any given program -shorter- -and- less efficient?
21:48:29 <mmorrow> *that's .. (the busy work)
21:48:48 <rwbarton> Hell, I'd settle for just shorter :)
21:48:52 <mmorrow> ddarius: well, if it's already compressed to max shortness, then no
21:49:25 <jfredett_> heya, fun question, dunno if I should ask here or at -in-depth. I just typed "let f = f in f" into ghci, and it crashed my machine
21:49:35 * mmorrow resumes one-linerifying fft
21:49:50 <jfredett_> what the hell does "let f = f in f" mean? I mean- how is it interpreted by ghc?
21:50:04 <mmorrow> it means "while(1);"
21:50:15 <wli> I forgot the | False guard.
21:50:21 <thoughtpolice> cloning ghc with git only took 1m 44s. *whoosh*
21:50:35 <jfredett_> oh! that makes sense. looks just like the forever = do forever thing for monads...
21:50:45 <dons> jfredett_: :L1 ; goto L1
21:50:55 <Botje> jmp $$
21:50:55 <rwbarton> int f(void) { return f(); }
21:50:57 <ddarius> jfredett: fix id
21:51:00 <jfredett_> hehe, thats fun, it looks fairly innocuous... :)
21:51:10 <mmorrow> go: jmp go
21:51:26 <jfredett_> it completely locked my other machine, I had to hard restart it...
21:51:30 <rwbarton> jfredett_: so does :(){ :|:& };:
21:51:33 <monochrom> runBASIC (do {10 GOTO 10})
21:51:43 <jfredett_> I was playing with fmap fmap fmap ...
21:52:29 <ddarius> 0xEB00
21:52:39 <wli> let euc 1 = 2 ; euc n = product [euc k | k <- [1 .. n - 1]] + 1 in [let e = euc k in (e, factors e) | k <- [1..10]] seems to have a tough time here.
21:52:56 <monochrom> That is odd. If you did it in ghci, you just had to ctrl-c or kill ghci. If you compiled it, you just had to kill the process. Are you sure you aren't using DOS or something?
21:53:10 <jfredett_> nope, Arch linux
21:53:18 <jfredett_> i think it might have been because I was over ssh
21:53:32 <wli> I used a "true Euclid" one-liner for the list of primes and factoring based on searching the list of all primes.
21:53:47 <rwbarton> ghc-6.10.1 has issues with let f = f in f for some reason.  You should still be able to ^Z and then kill it though
21:53:55 <miloshh> a generally good way to construct slow programs would be to iterate through natural numbers, checking if the number encodes a valid proof of something...
21:54:15 <mmorrow> we totally need to catalog all the ways to let x = x in x
21:54:17 <ddarius> miloshh: Now do that in one-line.
21:54:25 <mmorrow> in every language
21:54:37 <wli> 683 character one-liner
21:54:57 <miloshh> yeah.. proof checking is generally much easier than proof construction, but maybe not as easy as one line
21:55:05 <rwbarton> mmorrow: to replace the "write a function which increments an integer" page? :)
21:55:15 <monochrom> decoding number to proof is messy
21:55:30 <miloshh> you could deserialize ByteString, maybe
21:56:01 <miloshh> but that would take some plumbing
21:58:22 <wli> You could have the proof be in some quasi-programming-language format, and then Goedelize by saying the list of characters via hGetContents/etc. in that format encodes the radix 256 digits of some number, and then if that number is the k-th such number counting from 0 that's the program's Goedel number.
21:59:52 <jfredett> wli: you say some of the coolest stuff I don't understand.
22:00:34 <wli> I guess you'd have to tabulate all possible files of the format in order of file size to go from a number to a text representation of a proof. Probably better to do something via induction on the structure of proofs (i.e. AST's).
22:01:40 <wli> jfredett: That's a roundabout way of describing ordinary Goedelization that I thought had some meaningfulness.
22:01:48 <miloshh> ok, how about something easier - implementing (++) by iterating over all lists in lexical order, and checking the prefix and suffix
22:02:10 <jfredett> wli: thats okay, i was mostly impressed with how cool it sounded.
22:02:27 <jfredett> all them fancy words and whatnot.
22:03:02 <wli> Working on the AST's is probably better but I don't know how to make sure the induction comes out right.
22:04:00 <wli> If it were a data structure with n different unary constructors, you'd just make it a radix n expansion, but I don't know how to handle constructors of higher arity.
22:04:56 <kosmikus> conal: [centering of constructors in lhs2TeX] yes, you have triggered a feature; you can either use \aligncolumn (see user's guide), or you can say %format DOTS = ... and then use DOTS rather than ...
22:05:37 <conal> kosmikus: neat!  i'll check out that feature.  thanks. :)
22:07:31 <monochrom> I saw the announcement of the Barrie library and I thought Barbie.
22:08:05 <conal> Barrie library?  as in james barrie?
22:09:08 <Pseudonym> Every time you program in Java, a fary dies.
22:09:11 <mmorrow> got it!
22:09:12 <Pseudonym> fairy
22:09:14 <mmorrow> @let dft xs=let{l=length xs;i=0:+1;fi=fromIntegral;go l k xs=foldl'(+)0.flip fmap[0..l-1]$ \n->(xs!!n)*exp(negate(2*pi*i*fi n*fi k)/fi l)}in zipWith(go l)[0..l-1](repeat xs)in dft
22:09:15 <lambdabot>   Parse error
22:09:18 <mmorrow> grr
22:09:25 <mmorrow> , 0 :+ 1
22:09:26 <lunabot>  0.0 :+ 1.0
22:09:27 <wli> Aha, alternate between the max number of arities A and the number of constructors C. Then g(...) = A*C*k + sum [A*j*g(c) | (j,c) <- zip [0..] (children(...))]
22:09:27 <mmorrow> > 0 :+ 1
22:09:28 <lambdabot>   0.0 :+ 1.0
22:10:23 <mmorrow> @let dft xs=let{l=length xs;i=0:+1;fi=fromIntegral;go l k xs=foldl'(+)0.flip fmap[0..l-1]$ \n->(xs !! n)*exp(negate(2*pi*i*fi n*fi k)/fi l)}in zipWith(go l)[0..l-1](repeat xs)
22:10:24 <lambdabot>  Defined.
22:10:41 <conal> Pseudonym: :)
22:10:56 <mmorrow> @let fft[]=[];fft[x,y]=dft[x,y];fft xs=let{i=0:+1;fi=fromIntegral;(f***g)(x,y)=(f x,g y);de=unzip.p;p[]=[];p(x:y:zs)=(x,y):p zs;p _=[];(ys,zs)=((fft***fft).de)xs;l=length ys;zap=zipWith(flip id);c k l=exp(negate(2*pi*i*fi k)/fi(l*2));f l k x y=x+y*c k l;g l k x y=x-y*c k l;go l xs ys ks=zap(ys++ys)(zap(xs++xs)(fmap(f l)ks++fmap(g l) ks))}in go l ys zs[0..l*2-1]
22:10:58 <lambdabot>  Defined.
22:11:12 <mmorrow> > fft (fmap fromIntegral [0..2^14-1])
22:11:16 <lambdabot>   [1.34209536e8 :+ 0.0,(-8192.00000000797) :+ 4.272282919992819e7,(-8192.0000...
22:11:23 <mmorrow> !!!:)
22:11:42 <mmorrow> import Data.List(foldl') import Data.Complex(Complex(..))
22:12:29 <mmorrow> that dft could be merged into the fft since it duplicates a bunch of code
22:22:50 <wli> I think it may be radix C^A
22:24:01 <wli> No, I still can't smoke out how to arithmetically encode an algebraic data type.
22:25:28 <mmorrow> wli: what conditions are you imposing on the encoded datatype?
22:26:04 <mmorrow> or, maybe i should ask ... what do you mean by "arithmetically encode"?
22:26:12 <wli> mmorrow: Just an easily computed bijection between natural numbers and the algebraic data type.
22:26:29 <mmorrow> ohh
22:27:32 <wli> Or maybe the initial algebra of a constellation of algebraic data types.
22:28:04 <wli> (vaguely the same thing)
22:28:37 <mmorrow> i guess you can think of datatypes as polynomials over Z
22:28:44 <wli> I had a vague idea you could do it as numbers in some radix.
22:29:20 <mmorrow> data A a b = A a a b | B b b a ==> a*a*b + b*b*a
22:29:39 <mmorrow> data A a b = A a a b | B b b a | C a a b ==> 2*a*a*b + b*b*a ?
22:29:59 <mmorrow> then A and C are indistinguishable.. :/
22:30:09 <Elly> I don't think that will give you an unambiguous representation
22:30:22 <mmorrow> well, you can just add a tag to each con
22:30:24 <wli> I'm not sure how I get from those polynomials to the elements.
22:30:33 <mmorrow> yeah, i'm not sure either
22:30:54 <Elly> if you have N types, you could use numbers base N to represent them
22:31:02 <Elly> then they can be unambiguously encoded at least
22:31:10 <Elly> you also don't gain much from this trick though
22:31:17 <wli> I'm not encoding the types but the elements of the type.
22:31:39 <Elly> what information precisely are you trying to store?
22:31:55 <wli> Proofs can basically be represented as an algebraic data type, so it's encoding proofs as natural numbers.
22:32:02 <Elly> oh
22:32:10 <Elly> err...
22:32:11 <Elly> wait
22:32:12 <Elly> can that work?
22:32:26 <Elly> are there countably many proofs?
22:32:47 <monochrom> No. There exists unwritable proofs.
22:33:25 <wli> Well, I can think of a way to make it happen by representing them as text in some theorem prover language, then using the string representation of the file to get a Goedel number, but that's somewhat arduous to encode and decode.
22:33:28 <dolio> There do?
22:33:33 <wli> monochrom: Depends on the logic.
22:33:40 <monochrom> I'm trolling. Proofs can be injected into Strings and so they are countable.
22:34:04 <monochrom> There is an implicit assumption that a proof has finite length.
22:34:22 * wli rereads monochrom's statement and slaps forehead.
22:36:00 <dons> wysiwyg wikis are addictive
22:36:02 <dons> beware kids!
22:37:13 <monochrom> there are wysiwyg wikis?
22:39:53 <monochrom> edit wars will take on a new level with wysiwyg wikis
22:40:30 <tehgeekmeister> does everyone go thru a phase of painfully ugly coding in haskell
22:40:38 <tehgeekmeister> before it becomes tolerable?
22:41:00 <monochrom> not painfully ugly, just a bit ugly.
22:41:17 <tehgeekmeister> when the code is elegant, it's really elegant
22:41:28 <tehgeekmeister> but a program i'm working on now in haskell
22:41:43 <monochrom> Oh, and then there is nothing to tolerate because I found better ways.
22:41:46 <dsrogers> so cabal builds a file that contains my version string, yes?
22:41:51 <tehgeekmeister> if i'd written it in python, would've been far, far simpler and taken fewer lines and such.
22:41:58 <dsrogers> how do I access it from within my cabal built library?
22:42:02 <tehgeekmeister> i'm just hoping it'll get better
22:42:11 <Cale> tehgeekmeister: What sort of program is it? Probably there's a good way.
22:42:11 <tehgeekmeister> because i really like haskell and want to keep using it for most of my projects
22:42:17 <tehgeekmeister> but it's slowing me down right now
22:42:56 <lament> sounds like you're missing some primitives and should refactor
22:43:02 <dons> ah tehgeekmeister.
22:43:11 <Cale> tehgeekmeister: It was about 2 months before I felt like I could really use Haskell to do stuff, and about a year before I felt comfortable, for what it's worth. Then again, I was mostly studying mathematics in that time rather than programming...
22:43:13 <dons> dsrogers: yep
22:43:21 <tehgeekmeister> Cale: ordering words to learn in a natural language in order to maximize sentences readable at any given time.  need to query/iterate over/update many various maps/sets/sets inside of maps all the time
22:43:34 <dons> mm
22:43:36 <dsrogers> dons: how do I use it?   I want an error message to output a string for me.
22:43:44 <dsrogers> *version string
22:43:53 <tehgeekmeister> Cale: i have just gotten to a point where i can do anything i need to in haskell, but it's sometimes very, very painful
22:43:58 <Cale> tehgeekmeister: Well, that sounds like a nice pure problem.
22:44:04 <lament> tehgeekmeister: heh, neat idea
22:44:21 <dons> dsrogers: its in the Paths_foo.hs
22:44:26 <dons> looks in dist/build
22:44:29 <tehgeekmeister> lament: thanks, it turned out the best solution so far was a really, really simple one.
22:44:36 <Cale> tehgeekmeister: I can imagine that there's a very pretty program which does it.
22:44:45 <dons> tehgeekmeister: you have reached zen level 1, young grasshopper
22:44:46 <dsrogers> I referenced that in my library, but when I went to use my library I got a link error saying it couldn't find it.
22:45:03 <dons> with time, all code will flow as water through your fingers
22:45:15 <dons> the very lambdas will dance for you
22:45:33 <dsrogers> that's call bleeding
22:45:38 <monochrom> haha
22:45:46 <dsrogers> the lambdas are sacrificing you
22:45:47 <tehgeekmeister> heh; that's encouraging.  i have been seriously considering going back to python, but i just love haskell so much i don't want to.
22:45:54 <dons> dsrogers: i don't think we had to do anything weird in xmonad to ues the Paths_*
22:45:55 <monochrom> and you will be bleeding water, not blood, too.
22:46:04 <dons> tehgeekmeister: what's the problem though?
22:46:14 <dons> just feeling slowed down by new techniques?
22:46:25 <tehgeekmeister> dons: state is clumsy, basically
22:46:37 <dons> global state?
22:46:49 <dons> oh, threading haskell state?
22:46:59 <tehgeekmeister> don't have global state, but that'd sure be nice.  that and maps/sets can be a bit awkward.
22:47:06 <tehgeekmeister> at least how i'm using them.
22:47:08 <dons> well, you can have global state if you really need it
22:47:17 <dons> mutable. wouldn't make much sense for a Map though, (or would it?)
22:47:18 <tehgeekmeister> i bet there's a better way to write what i've made.
22:47:27 <dons> x :: IORef Map -- evil sure.
22:47:38 <dons> you could ask for design help on -cafe2?
22:47:40 <dons> -cafe@
22:47:41 <monochrom> The awk/perl/python/php approach to all problems in the world is "slurp input into sets, maps, hashes..."  It is not really a universally optimal approach.
22:47:55 <dons> well, i usually slurp all input into [a] or Map a
22:47:57 <dons> or Set a
22:48:10 <dons> for scripts
22:48:12 <wli> Approach to what?
22:48:22 <tehgeekmeister> monochrom: at least maps are basically absolutely necessary for this problem.
22:48:25 <dons> scripting jobs, i guess, data processing
22:48:33 <tehgeekmeister> monochrom: depending on approach, sometimes multiple.
22:48:36 <dons> extraction, reporting
22:48:51 <monochrom> wli: They really use it to solve all the world's problems!
22:48:57 <jekor> I don't think I understand laziness. I'm querying a database with HDBC's quickQuery (lazily returns results) and then mapping an output (HTML) function over the list...which displays nothing. If I trace the list, it will display. Shouldn't the display function at some point force evaluation of the list items?
22:48:59 <wli> I usually have more irritating formats and data.
22:49:19 <tehgeekmeister> jekor: are you using postgresql?
22:49:28 <jekor> Yes.
22:49:47 <tehgeekmeister> jekor: quickQuery and such are not truly lazy with postgresql, and it's postgresql's fault.
22:50:05 <dons> jekor: mm
22:50:14 <dons> ah
22:50:18 <tehgeekmeister> jekor: i can show you a snippet that i used to get around it, or you can switch databases if you want.
22:50:18 <jekor> :/ So what can I do? I like being able to "limit" later on without having to work it into the query.
22:50:26 <dons> force it with seq / rnf ?
22:50:31 <dons> mm
22:50:44 <jekor> tehgeekmeister: I'd appreciate the snippet. Which databases handle it better? I'm not a fan of MySQL.
22:50:49 <dons> we're getting interesting questions tonight
22:50:55 <jekor> dons: I tried $!, but it didn't seem to help.
22:51:02 <jekor> Might not be using it in the right place.
22:51:03 <tehgeekmeister> jekor: i'm not sure it has a problem with any others
22:51:06 * mmorrow shakes his fist at mysql
22:51:20 <tehgeekmeister> jekor: postgresql returns the whole result set by default, that's the issue
22:51:54 <jekor> Oh...so what I'm doing is actually overworking PostgreSQL, it sounds like.
22:52:16 <jekor> Can it be reconfigured?
22:52:30 <tehgeekmeister> jekor: http://tinyurl.com/d7gam8
22:52:40 <tehgeekmeister> the postgresql manual says you should use a cursor
22:52:41 <sjanssen> wli: proof of concept http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1504#a1504
22:52:56 <sjanssen> wli: recall that all types may be expressed as sums and products
22:53:07 <tehgeekmeister> i was going to write up a patch for that and send it to the maintainer but i haven't gotten around to it
22:53:14 <jekor> Hah. I thought Postgres was an attempt to get away from non-relational access.
22:53:16 <tehgeekmeister> hdbc could do it transparently
22:53:44 <tehgeekmeister> jekor: mind that if you use specifically that implementation you need to import HDBC hiding (fetchAllRows)
22:54:01 <tehgeekmeister> and it requires a sane number for n to start with.
22:54:10 <jekor> Looks interesting. Any value of n you find to be somewhat optimal?
22:54:22 <tehgeekmeister> jekor: 0
22:54:29 <wli> sjansen: That could do it.
22:54:33 <tehgeekmeister> oh, i forgot to mention
22:54:38 <tehgeekmeister> you have to modify your statements if you use that
22:54:45 <sjanssen> wli: oh, damnit.  This won't work for recursive types
22:54:59 <tehgeekmeister> "SELECT blahblahblah LIMIT ?"
22:55:09 <tehgeekmeister> you prepare that sort of a statement
22:55:19 <tehgeekmeister> oh wait, no
22:55:20 <tehgeekmeister> sorry
22:55:25 <tehgeekmeister> haven't done this in a while
22:55:34 <wli> sjanssen: I can't tell offhand.
22:55:41 <tehgeekmeister> SELECT query OFFSET ? LIMIT 1
22:55:42 <jekor> Er, rather than n, I mean, any value other than n+1?
22:55:46 <tehgeekmeister> your query needs to be of that form
22:56:02 <jekor> Seems like retrieving 1 row at a time would be slow over a TCP link.
22:56:09 * wli usually goes diving through /proc/ for data to parse/etc.
22:56:15 <tehgeekmeister> you could change the limit, sure
22:56:17 <tehgeekmeister> that should work
22:56:20 <tehgeekmeister> but i haven't tried it
22:56:23 <jekor> I might just go back to the strict versions :/
22:56:45 <sjanssen> wli: it won't, because the number of bits taken up by any type must be known statically
22:56:47 <tehgeekmeister> i beat my head on this for a good week before i found out what the problem is
22:56:51 <tehgeekmeister> i'm glad i was around to save you the pain
22:56:59 <jekor> Thank goodness!
22:57:02 <sjanssen> wli: a list, for example, can take up any number of bits
22:57:06 <wli> sjanssen: So much for that. :(
22:57:58 <pervonisse> this might be a silly question but is there a specific "declarative" way of building GUI's?
22:58:06 <pervonisse> (GUI programs that is)
22:58:26 * tehgeekmeister just realized he just wrote his first 100+ line haskell program
22:58:53 <tehgeekmeister> (the bad part is that the equivalent program in python took like 30 or 40 lines.  i'm sure i'm not doing it as well as i could in the haskell version.)
22:58:58 <jekor> I wonder what Debug.trace is doing to force the reading. It would seem like that would work.
22:59:03 <monochrom> There are several declarative ways. There is functional reactive programming. There is tangible values.
22:59:11 <tehgeekmeister> jekor: unsafeIO stuff
22:59:41 <tehgeekmeister> jekor: fetchAllRows uses unsafeInterleaveIO
22:59:45 <pervonisse> monochrom which is the most developed/popular one?
23:00:04 <sjanssen> wli: I'm having a hard time imagining a bijection between ADTs and naturals
23:00:07 <sjanssen> it might not exist
23:00:25 <monochrom> I don't know.
23:00:57 <jekor> Ah. I need to study IO more.
23:01:08 <sjanssen> no, it must exist
23:02:12 <tehgeekmeister> jekor: in general you should try to avoid the unsafeIO stuff, they are called unsafe for a reason.
23:02:41 <tehgeekmeister> jekor: but apparently sometimes they are necessary.  i've only used them in that snippet i showed you and for debugging (and i hear there are better ways to do that now)
23:03:05 <jekor> Is there a version of the GHC libraries documentation that includes source links?
23:03:26 <tehgeekmeister> you mean so you can see the source of the builtins and whatnot?
23:03:37 <tehgeekmeister> it's not all implemented in haskell
23:03:40 <tehgeekmeister> best i can tell you is
23:03:43 <jekor> At least the standard library functions.
23:03:45 <tehgeekmeister> @src fold
23:03:45 <lambdabot> Source not found. It can only be attributed to human error.
23:03:50 <tehgeekmeister> what?
23:03:52 <rwbarton> jekor: I change /latest/ in the URL to /6.8.2/
23:04:01 <tehgeekmeister> @src tail
23:04:01 <lambdabot> tail (_:xs) = xs
23:04:01 <lambdabot> tail []     = undefined
23:04:07 <tehgeekmeister> @src foldr
23:04:07 <lambdabot> foldr f z []     = z
23:04:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:04:15 <jekor> rwbarton: Perfect!
23:04:15 <tehgeekmeister> see?  lambdabot helps.
23:04:37 <NameAlreadyInUse> is it necessary to use do notation?
23:04:41 <jekor> lambdabot is awesome. But I'd rather not spam the channel ;)
23:04:51 <tehgeekmeister> heh, i understand
23:04:51 <jekor> NameAlreadyInUse: Nope. Just convenient sometimes.
23:05:09 <rwbarton> Also, lambdabot lies sometimes
23:05:17 <tehgeekmeister> rwbarton: oh?
23:05:23 <wli> sjanssen: If not a bijection then at least an injection.
23:05:31 <tehgeekmeister> i'd say do notation is nearly necessary if you want to avoid insanity.  at least in some cases.
23:05:41 <tehgeekmeister> but i may just be too much of a n00b.
23:06:00 <NameAlreadyInUse> do notation is difficult for me to understand
23:06:00 <luqui> three cheers for ICL!  I just wrote a dependent typechecker in 75 lines!
23:06:01 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
23:06:04 <jekor> For a while I didn't use do notation just to get familiar with monads.
23:06:21 <rwbarton> @src head
23:06:21 <lambdabot> head (x:_) = x
23:06:21 <lambdabot> head []    = undefined
23:06:31 <rwbarton> e.g., it's not really undefined there
23:06:38 <tehgeekmeister> NameAlreadyInUse: do notation isn't that bad once you get used to it.  it is the least of my complaints about haskell.
23:06:45 <ski_> sjanssen : `bijection' !?
23:07:00 <tehgeekmeister> NameAlreadyInUse: but it is obviously very different than other approaches.  and it's important to remember what do notation represents, as well.
23:07:10 <wli> sjanssen: foldr (\u v -> 256*fromIntegral (Data.Char.ord u) + v :: Integer) 0 . show
23:07:24 <sjanssen> wli: injection is easy -- just treat the list of words returned from Data.Binary as a natural
23:07:25 <monochrom> SmallCheck has to enumerate exhaustively all "small" examples. You may find inspiration.
23:07:26 <glguy> programmable do-notation is one of Haskell's strengths! (certainly not something you just learn to bear)
23:07:48 <wli> sjanssen: Yeah, I only needed an injection.
23:08:29 <NameAlreadyInUse> well what is the cost in brevity if i avoid do-notation?
23:08:33 <ski_> isn't `A' countable if it's empty or there's a surjection from `Nat' into it ?
23:09:06 <sjanssen> @undo do x <- foo; y <- bar; baz x y
23:09:06 <lambdabot> foo >>= \ x -> bar >>= \ y -> baz x y
23:09:08 <glguy> wli, did you mean to multiply v by 256?
23:09:13 <sjanssen> NameAlreadyInUse: an example ^^
23:09:20 <glguy> wli, or are you just mapping (*256) and summing?
23:09:50 * ski_ thinks one can probably do some kind of diagonal enumeration ..
23:10:00 <tehgeekmeister> http://tinyurl.com/cl3mzx <== anyone have any obvious suggestions for how to clean up any parts of this code
23:10:05 <wli> glguy: I meant to treat the characters as digits in a radix 256 represntation of a number.
23:10:18 <wli> glguy: Then the foldr was to compute the number.
23:10:18 <tehgeekmeister> a lot of the functions aren't being used anymore because they ended up being unnecessary in the final iteration
23:10:18 <monochrom> Avoiding do-notation may actually buy you conciseness because you're deleting a lot of spaces...
23:10:25 <tehgeekmeister> but i'd like to improve it all just to learn
23:10:44 <glguy> wli, I just meant that it looked like it should be .... + 256 * v) 0 . show
23:10:52 <wli> monochrom: Hence monad comprehensions.
23:11:11 <tehgeekmeister> monad comprehensions?
23:11:12 <ski_> (`toNat x = fromJust (findIndex (x ==) inhabitants)' .. hm)
23:11:18 <wli> glguy: Yeah, that's what it should've been.
23:11:24 <wli> ski: Right.
23:11:47 <banisterfiend> wli: do you like r kells
23:11:52 <ski_> obviously one would like improvement, though
23:12:35 <ski_> tehgeekmeister : `do lines <- (liftM LC.lines $ L.readFile file)', brackets unneeded
23:12:46 <wli> ski: Right, the idea is to go directly to/from the number from the AST, which I guess Data.Binary comes closer to.
23:13:17 <tehgeekmeister> ski_: thanks, that makes sense
23:14:36 <ski_> (tehgeekmeister : you also have a lot of `blah :: (...)' where brackets not needed)
23:14:57 <sjanssen> wli: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1504#a1505 will actually work
23:15:36 <tehgeekmeister> ski_: sometimes that's for readability for my own sake, but other times it's because i'm trying to avoid getting hung up on some error related to that.  i tend towards extra parens, but thank you; good to know i can get rid of some of them.  they get unwieldy quickly.
23:16:25 <tehgeekmeister> what bothered me was the nested folds and maps, i really didn't like that.
23:16:31 <ski_> tehgeekmeister : if it's for you own sake, then leave it in until/when you feel comfortable removing them
23:16:51 <tehgeekmeister> and all the manual threading of state, that gets cumbersome
23:17:03 <ski_>   liftM LC.lines $ L.readFile file
23:17:07 <ski_> could be
23:17:15 <ski_>   LC.lines `liftM` L.readFile file
23:17:33 <tehgeekmeister> oh, huh
23:17:37 <tehgeekmeister> cool way of doing it
23:17:48 <glguy> if you are optimizing, liftM -> fmap saves a character
23:17:55 <wli> sjanssen: I'm not sure how type recursion plays out.
23:18:13 <glguy> and then you can bring out <$>
23:18:32 <ski_> (i was talking about code clarity, here)
23:20:46 <ski_> why do you use `get' in `makeMap' ?
23:21:30 <ski_> the only use of `makeMap' appears to be `let maps = execState (makeMap pairs) emptyReaderMaps'
23:21:48 <ski_> and `execState' will discard the monadic result of `makeMap pairs', anyway
23:21:58 * wli forgets how symbol tables are efficiently maintained in the presence of nested scopes.
23:22:06 <ski_> so i'd remove the `>> get >>= return' part in `makeMap'
23:22:40 <ski_> @type Control.Monad.State.execState
23:22:41 <lambdabot> forall s a. State s a -> s -> s
23:22:44 <tehgeekmeister> ski_: i just didn't know what i needed to have in that place to make the types right, so i played around until it worked
23:23:10 <ski_>   makeMap :: (MonadState (ReaderMaps a) m, Fractional a, Real a) => [(Int, String)] -> m ()
23:23:21 <jekor> tehgeekmeister: Apparently lazy reading requires reading the entire result, so it doesn't give me the effect I was going for. Ah well...
23:23:26 <ski_> would be the type, accomodated to this change
23:23:29 <jekor> (So says RWH.)
23:24:02 <tehgeekmeister> jekor: wait, are you trying to lazily read just a single row?
23:24:19 * wli also forgets how the heck he did cancellation for expressions involving (+), subtract, negate, (*), (^), factorial, and variables.
23:24:23 <tehgeekmeister> jekor: you can lazily read all rows, but you have to read one entire row at a time
23:24:39 <mmorrow> wli: a zipper on a tree of (Map sym a) is nice
23:24:53 * wli has no idea what a zipper is.
23:25:02 <jekor> Yeh. But the "make the search function generic" and "use drop/take to offset/limit the results elsewhere" approach doesn't seem to be doable.
23:25:15 <wli> mmorrow: I'm speaking of symbolic algebra, but anyway.
23:25:30 <mmorrow> re: symtabs with nested scopes
23:25:30 <jekor> MySQL has a similar problem with unbuffered queries. So it would seem both databases suffer from the problem.
23:26:02 <wli> mmorrow: What's a zipper end up doing?
23:26:52 <mmorrow> basically lets you keep your position in the tree
23:27:15 <ski_> wli : a zipper roughly describes a datastructure together with a "position" inside it .. usually replacing values in that position, and moving the position small steps are assumed to be efficient
23:27:25 <tehgeekmeister> jekor: hmm, the maintainer said he had no problems using other databases and lazily fetching
23:27:25 <mmorrow> similar to     Loc a = Top a | Cxt a (a -> Loc a)
23:27:33 <tehgeekmeister> jekor: but i've only used postgresql with it, so i don't know
23:27:55 <ski_> wli : a zipper for a list `[0,1,2,3,4,5]' on the `3' element could be represented as `([2,1,0],3,[4,5])'
23:28:22 <wli> Okay, I don't see how it applies.
23:28:23 <mmorrow> and with a (rose) tree zipper, you use a list zipper for the subforest, and add the additional bits to handle the tree
23:28:55 <ski_> wli : for a tree, a zipper on a subtree (node), would consist of that sub-tree, and a context, describing everything "above" this node .. where the path from the node up to the root is "reversed" (parallel subtrees are not reversed)
23:29:33 <jekor> tehgeekmeister: Interesting. I know that with PHP+MySQL PHP will by default fetch all rows to a buffer. When using unbuffered queries the entire result set needs to be read or the connection needs to be manually reset in some way. Real World Haskell says the same thing about HDBC without reference to any specific database. No big deal for me, I'll just go back to strict queries which are easier to understand anyway.
23:29:44 <MacTavish> hopefully a quick question, not necessarily directly haskell related:  cabal upgrade base, does not upgrade base... yet cabal upgrade keeps telling me I can't upgrade because requires base >=4
23:29:48 <wli> I guess I see how that plays out, but not wh it's useful for the nested symbol table.
23:30:03 <wli> Or, rather, symbol tables with nested scopes.
23:30:15 <tehgeekmeister> jekor: fetchAllRows, according to the maintainer and other users, IS lazy with other databases.
23:30:43 <tehgeekmeister> jekor: and i personally prefer lazy lists.  they're pretty sweet.  but of course use what is best fo ryou.
23:31:06 <tehgeekmeister> jekor: in any case, i don't know much more about this subject than just some limited experience of my own
23:31:17 <jekor> tehgeekmeister: Interesting. I'll have to check it out sometime. But for now my program is already heavily mired in Postgres.
23:31:25 <jekor> What you had was helpful, thanks.
23:31:53 <tehgeekmeister> jekor: if it'd be useful enough to you i could take a go at fixing fetchAllRows sometime tomorrow?
23:32:11 <ski_> tehgeekmeister : um .. right, the stuff in the base case of `makeMap' is just a final finishing up of the state, right ?
23:32:13 <tehgeekmeister> i've been putting off fixing it but intended to anyway
23:32:34 <tehgeekmeister> ski_: yeah
23:32:59 <ski_> tehgeekmeister : so, you could move that to after the `makeMap' loop, and have `return ()' in the base case
23:32:59 <tehgeekmeister> ski_: can't generate that until all the other stuff is done, and since i'm using execState i care about the final state
23:33:00 <jekor> tehgeekmeister: Only if you really want to do it for yourself. I'll probably have forgotten about this all by tomorrow and be on to other parts of the program :)
23:33:37 <tehgeekmeister> ski_: oh, cool, i didn't think about that.
23:33:48 <ski_> tehgeekmeister : and *then* your `makeMap' is just `sequence_' or `mapM_' on a list !
23:33:54 <ski_> @src mapM_
23:33:55 <lambdabot> mapM_ f as = sequence_ (map f as)
23:33:59 <ski_> @src sequence_
23:33:59 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
23:34:06 <ski_> i.e.
23:34:19 <ski_>   makeMapAux [] = do return ()
23:34:25 <tehgeekmeister> oh wow!
23:34:26 <tehgeekmeister> it is.
23:34:31 <ski_>   makeMapAux (x:xs) = do addPair x
23:34:44 <ski_>                          mapMapAux xs
23:34:50 <ski_> can be shortened to
23:35:10 <ski_>   makeMapAux xs = forM_ xs addPair
23:35:14 <ski_> i.e.
23:35:27 <ski_>   makeMap xs = do forM_ xs addPair
23:35:38 <ski_>                   finishing stuff
23:35:53 <ski_> and then you can inline `addPair'
23:36:10 <ski_>   forM_ xs $ \x -> do
23:36:19 <ski_>     modify (\st -> st ...)
23:36:22 <sjanssen> wli: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1504#a1506
23:36:24 <ski_>   finishing stuff
23:36:45 <tehgeekmeister> nice
23:36:46 <sjanssen> wli: Peano is a recursive type, all others should work as well
23:36:58 <ski_> tehgeekmeister : i.e. for each element `x' of `xs' you do the `modify ...' action .. then do some finishing up
23:38:30 <ski_> tehgeekmeister : all i've said about `makeMap' so far appears to be true of `makeFrequencyMap' as well, except that this doesn't have the `finishing stuff' part
23:39:01 <tehgeekmeister> i'm glad to see this can be cleaned up so well
23:39:07 <tehgeekmeister> thanks
23:40:06 <ski_> (btw, some of those lines are awfully long .. i'd indent them over several lines, for clarity)
23:40:50 <tehgeekmeister> i always end up doing that later on, but i probably should do it earlier
23:40:56 <tehgeekmeister> i'd probably make quicker progress if i did
23:41:06 <ski_> also in `(foo . bar . baz) $ quux' the brackets can be removed
23:43:05 <ski_> replace `else return =<< do' with `else do'
23:43:42 <tehgeekmeister> ski_: tried adding all those changes you suggested to makeMap and it doesn't compile
23:43:54 <tehgeekmeister> i'm sure i misunderstood something
23:44:19 <ski_> @hpaste
23:44:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:44:22 <ski_> @hpaste2
23:44:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:44:28 <ski_> hmhm
23:44:47 <ski_> try pasting the parts you've changed ?
23:45:05 <ski_> (also the compile error, of course)
23:45:22 <ski_> well, make an annotation to the existing paste
23:45:45 <tehgeekmeister> oh wait, the error went away with commenting my old type signature
23:45:50 <ski_> (for some reason i thought this was another paste service without annotation feature ..)
23:45:52 <tehgeekmeister> this has a new type, i guess?
23:46:35 <ski_> yes
23:46:37 <ski_> <ski_>   makeMap :: (MonadState (ReaderMaps a) m, Fractional a, Real a) => [(Int, String)] -> m ()
23:47:05 <ski_> <ski_> would be the type, accomodated to this change
23:47:45 <tehgeekmeister> okay, sorry i didn't catch that
23:47:51 <ski_> np
23:47:54 <tehgeekmeister> i'm also doing some of my own cleaning while following your suggestions
23:54:09 <ski_> `S.empty ==' can probably be replaced with `S.null'
23:55:21 <ski_> `printReaderStats' should also not use `get', and can be written with `forM_' as above
23:56:55 <ski_> you might prefer `parseGNT . head =<< getArgs' instead of `getArgs >>= (parseGNT . head)'
23:57:59 <ski_> `modify (\(is,i) -> (IS.union newItems is,i+1))' might be written `modify (IS.union newItems *** (+1))'
23:58:15 <ski_> @index (***)
23:58:15 <lambdabot> Control.Arrow
