00:04:30 <pumpkin> moo
00:05:16 <lament> what's the best library for polling keypresses?
00:06:41 <jedahu> any HOC devs here?
00:52:04 <adrian_> hello
00:52:20 <adrian_> does anyone know of a graph of np complete problems?
00:52:30 <adrian_> like the one I'm drawing here: http://page.mi.fu-berlin.de/aneumann/npc.html
00:53:12 <adrian_> or at least a good source on npc problems with lots of proofs and references to the original papers?
00:53:57 <adrian_> I heard there are over 3000 of them. There has to be something like the complexity zoo
00:56:23 <adrian_> something like this: http://www.math.ucdavis.edu/~greg/zoology/diagram.xml but for npc problems
00:58:24 <kerm|t> @karma+ Choko
00:58:24 <lambdabot> Choko's karma raised to 1.
00:59:00 <kerm|t> has anyone considered making that automatic by parsing for nick: .*thank.* ?
01:00:31 <int80_h>  so e = ["16","17,"18"]
01:00:41 <int80_h> I'm trying to sum those digits
01:00:55 <int80_h> and I figure the way to go is a map fusion using map and foldl'
01:01:02 <int80_h> this is what I try
01:01:21 <int80_h> foldl' (map digitToInt) [] e
01:01:27 <int80_h> of course, that doesn't work
01:02:05 <int80_h> any ideas?
01:02:28 <adrian_> why not foldl' (\a s -> a+(read s)) 0
01:03:49 <int80_h> hmm, never encountered read. I figured I need to use map and fold together because I was using a [String]
01:04:42 <int80_h> adrian_ oh the first step of the summing is to convert the strings into Ints
01:04:58 <ordnungswidrig> int80_h: want to sum the digits or the numbers?
01:05:07 <int80_h> I want to summ the digits
01:05:24 <ordnungswidrig> so ["16","17","18"] -> 24?
01:05:55 <idnar> do you mean ["16","17,"18"] -> "161718" -> 1 + 6 + 1 + 7 + 1 + 8?
01:06:02 <int80_h> no it would be ["16","27","18] -> [7,9,9]
01:06:33 <adrian_> ah
01:06:36 <idnar> okay, so that's "map sumDigits"
01:06:53 <int80_h> @type sumDigits
01:06:54 <lambdabot> Not in scope: `sumDigits'
01:07:00 <int80_h> ah, I write it
01:07:02 <int80_h> okay
01:07:15 <idnar> for sumDigits, you want to turn each character into a digit, and then add them up
01:07:45 <ordnungswidrig> > sum . map read $ ["16","17","18"]
01:07:46 <lambdabot>   51
01:07:48 <int80_h> idnar, but then would I want to not reduce the [String] for each stringed number?
01:08:04 <idnar> int80_h: well, I'd probably do sumDigits = sum . map digitToInt
01:08:14 <adrian_> map (foldl (\a s -> a+(digitToInt s)) 0)
01:08:22 <adrian_> if you want to use foldl
01:08:22 <idnar> giving you map (sum . map digitToInt) for the whole thing
01:08:30 <ordnungswidrig> map read "16"
01:08:42 <int80_h> oooh two maps
01:08:56 <int80_h> okay that would make sense, I want to end with a [Int]
01:09:03 <idnar> but you can always do let sumDigits = sum . map digitToInt in map sumDigits
01:09:35 <int80_h> ah there's that partial application again
01:09:47 <int80_h> okay I'll try that
01:09:57 <idnar> it's sumDigits xs = sum (map digitToInt xs) in pointful form
01:11:56 <int80_h> hmm, type error
01:12:20 <int80_h> okay I fixed the type error,
01:12:33 <int80_h> but what's the difference between Int and Integer
01:12:57 <int80_h> because I think I need an Integer, but this only works when I used Int
01:13:06 <int80_h> I mean, it compiles
01:13:49 <_Jordan_> int80_h: Integer doesn't overflow
01:14:27 <int80_h> well I'll be using numbers as big as 99^99
01:14:33 <int80_h> Int will overflow eh
01:14:35 <ordnungswidrig> _Jordan_: at some point it will?
01:14:45 <ordnungswidrig> or at least rais some error
01:14:54 <daf> > 99^99 :: Int
01:14:55 <lambdabot>   -7394533151961528133
01:15:09 <daf> no error, just overflow
01:15:13 <int80_h> yeah that's all screwy
01:15:33 <int80_h> okay I need to figure out how to use Integer then without getting a type error
01:15:45 <int80_h> I have a three line program, can I paste it in the room ?
01:16:04 <_Jordan_> don't see why not
01:16:13 <int80_h> sumExpDigits :: [String] -> [Int]
01:16:13 <int80_h> sumExpDigits = let sumDigits = sum . map digitToInt
01:16:13 <int80_h> sumExpDigits = let sumDigits = sum . map digitToInt                   in map sumDigits
01:16:39 <int80_h> so when I change the function type to [String] -> [Integer] I get a type error
01:16:49 <int80_h> but [Integer] is what I need
01:17:17 <int80_h> is there a intToInteger?
01:17:37 <dolio> fromIntegral
01:17:37 <int80_h> @hoogle Intger
01:17:37 <lambdabot> No results found
01:17:41 <ksf> there's fromIntegral
01:17:46 <int80_h> ahhh
01:18:38 <idnar> @type fromIntegral . digitToInt
01:18:39 <lambdabot> forall b. (Num b) => Char -> b
01:19:03 <idnar> which will give you sumExpDigits :: (Num a) => [String] -> [a]
01:20:00 <int80_h> oops
01:20:17 <xenoblitz> guys is anyone here experienced in embedding languages in haskell?
01:20:30 <int80_h> et sumDigits = sum . map fromIntegral . digitToInt
01:20:41 <int80_h> sumExpDigits :: [String] -> [Int]
01:20:43 <int80_h> sumExpDigits = let sumDigits = sum . map fromIntegral . digitToInt in map sumDigits
01:20:46 <idnar> int80_h: sum . map (fromIntegral . digitToInt)
01:20:55 <idnar> otherwise it's sum . (map fromIntegral) . digitToInt
01:22:19 <int80_h> does sum . map $ fromIntegral . digitToInt mean the same thing?
01:22:34 <int80_h> I thought it did, I guess I don't understand $ yet
01:23:18 <idnar> int80_h: sum . map $ fromIntegral . digitToInt is (sum . map) (fromIntegral . digitToInt)
01:23:26 <int80_h> oh that would do (fromIntgral) not (fromItegral . digitToInt)
01:23:39 <int80_h> oooh
01:23:41 <_Jordan_> $ trumps (.)
01:23:42 <lunabot>  luna: Not in scope: `trumps'
01:24:50 <int80_h> would using $ be (1) possible (2) more idiomatic?
01:25:25 <adrian_> who is this lunabot?
01:25:38 <adrian_> $ 5+8
01:25:40 <lunabot>  13
01:25:50 <adrian_> $ map (+1) [1..]
01:25:51 <lunabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:25:53 <ksf> I like the paren version.
01:26:02 <ksf> It makes the composition stick out.
01:26:10 <ray> i liked lunabot better when it listened to comma
01:27:35 <_Jordan_> int80_h: this might help -- http://stackoverflow.com/questions/395995/when-should-i-use-and-can-it-always-be-replaced-with-parentheses
01:32:03 <dcoutts> Eridius: did you get the problem with gsl worked out?
01:32:12 <int80_h> _Jordan_ thanks
01:33:33 <_Jordan_> int80_h: no problemo
01:33:37 <_Jordan_> night all
01:44:06 <MarcWeber> Is it possible to change the library name based on cabal flags? Eg name : mylibname-${string_type} ?
01:45:48 <dcoutts> MarcWeber: no
01:46:02 <dcoutts> the library name follows the package name
01:46:14 <dcoutts> the package name cannot change or it becomes useless as an identifier
01:46:55 <dcoutts> there is no support for package templates where you generate multiple packages from a single parametrised template, but you could hack something up
01:47:25 <dcoutts> but you could only build or distribute the result, not the original template
01:49:22 <MarcWeber> Hi niksnut !
01:50:45 <MarcWeber> dcoutts: I've send a mail to haskell-cafe now illustrating a use case
01:54:24 <Baughn> "ne derivatives trader says she's working on a contract that will have a clearly defined value in the event that aliens wipe out the entire human species, but she says it's going to take a few hours and I say she's on crack." <-- Opinions?
01:54:28 <Baughn> *One
01:55:00 <osfameron> sounds like a good plot for a short stoy
01:55:22 <Baughn> Well, only if you can figure out a contract that actually makes any kind of sense at all
01:55:47 <Baughn> (This is a short story, but the extinction of humankind is not in the cards. Kind of.)
01:56:23 <osfameron> not sure whom the contract would be with of course
01:56:32 <osfameron> or who would remain for it to be valuable to
01:56:37 <Baughn> Hmm. The aliens, maybe?
01:58:29 <osfameron> is the derivatives trader an alien?
01:58:40 <Baughn> Well,no.
01:59:37 <FunctorSalad> that's not weird unless the contract *specifically* mentions that alien event
01:59:45 <Baughn> http://www.overcomingbias.com/2009/01/the-babyeating-aliens.html <-- Actually, I'll just give you a link
01:59:57 <Baughn> I'm pretty sure this market has just gone bananas
02:01:29 <FunctorSalad> I mean, even the trivial contract would be well-defined in case of alien-induced oblivion
02:02:11 <Peaker> If I put my StateT computation inside a MaybeT and "fail" anywhere, it should "break" the computation all the way out, right?
02:07:31 <FunctorSalad> Peaker: I hope it breaks rather than threading the "Nothing" through every step :)
02:12:10 <hynek> hi
02:12:11 <preflex>  hynek: you have 1 new message. '/msg preflex messages' to read it.
02:18:41 <tom`> i'm getting an error on "import Parsec" with GHC. I thought i was included? Do a need a compiler option or i sit something else?
02:19:02 <Peaker> @hoogle Parsec
02:19:02 <lambdabot> module Text.Parsec
02:19:02 <lambdabot> module Text.ParserCombinators.Parsec
02:19:02 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
02:19:04 <Baughn> tom`: It's Text.Parsec
02:19:19 <tom`> aha! thanks
02:19:39 <tom`> I'd totally forgotten about hoogle as well, been a few months since i've touched haskell (mores the pity)
02:23:47 <Peaker> maybe everyone on hackage should switch to a date-based version scheme?
02:24:39 <Peaker> package-9.2.3
02:24:59 <MarcWeber> Peaker: What makes you requesting this?
02:25:46 <Peaker> MarcWeber: I just think its a good idea.  Can help with automation, and help users understand relations between releases of different packages
02:25:59 <Peaker> And its less arbitrary
02:26:27 <Peaker> I keep using silly versioning schemes like 0.0.1 in each package I release, and then a bit later I end up switching to date-based releases
02:26:53 <MarcWeber> You gain the ability to compare release dates. You'll loose the ability to see wether it's a major or a minor update
02:27:30 <MarcWeber> Peaker: read this first: http://haskell.org/haskellwiki/Package_versioning_policy
02:27:35 <MarcWeber> Its not that arbitrary at all
02:28:56 <Peaker> yay! my package is on hackage and it works :-)
02:29:02 <Peaker> My first hackage package!
02:29:15 <Peaker> "cabal install lui" :-)
02:31:42 <SParry> congrats
02:35:31 <mstr> http://pastebin.com/f60e8715d
02:35:40 <mstr> hmm, I can't figure out what's wrong
02:40:03 <blackh> mstr: Ah, good old occurs check!
02:41:06 <mstr> blackh: please tell me more :)
02:41:30 <mstr> I guess it's some kind of a type mismatch, but I just can't see it
02:41:38 <hackage> Uploaded to hackage: lui 0.0.2
02:41:38 <hackage> Uploaded to hackage: haskgame 0.0.2
02:42:19 <blackh> mstr: I am trying to nut it out. I find it's a good idea to put type signatures in in these situations. I suggest add one for rndIndex
02:44:33 <blackh> mstr: Your list will be the left arg of rndIndex
02:45:31 <blackh> mstr: I can't figure out what you're trying to do. What are you trying to do?
02:47:11 <blackh> mstr: shuffleIndexes :: RandomGen g => Int -> g -> [Int] ?
02:47:30 <tom`> In parsec i have something like this 'parseTest (sepBy1 (reservedOp "*") decimal) "2"' but it fails unless i change it to 'parseTest (sepBy1 (try $ reservedOp "*") decimal) "2"'. I don't really understand why though, surely reservedOp already fails without consuming any input?
02:49:04 <blackh> mstr: You will need to pass your rng through your fold, or you'll get the same number each time.  Random numbers are very educational in Haskell.
02:50:02 <xenoblitz> is there anyone here who can help me with some work related to embedded languages embedded in Haskell?
02:50:08 <augustss> weeee!
02:50:44 <blackh> xenoblitz: I might be able to help, or then again I might not. What's the question?
02:50:45 <tom`> never mind, I'm reversing the arguments to sepBy1
02:51:29 <xenoblitz> blackh: I am trying to write a scripting language in haskell and am having problems with the sequence construct
02:52:01 <blackh> xenoblitz: What's the nature of the problem you're having?
02:52:09 <mstr> blackh: which list did you mean?
02:52:24 <mstr> the list [n..1] or the acc ?
02:53:05 <blackh> mstr: The type of rndIndex will be something like :: [Int] -> Int -> [Int]
02:53:45 <blackh> mstr: So you might need to swap the 'acc' and 'x' arguments.  I assume 'acc' is the accumulated output list and x is the elt of [n,n-1,..,1] that you're up to.
02:53:54 <lilac> mstr: rndIndex's arguments are backwards
02:54:51 <lilac> @type randomR
02:54:52 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
02:56:11 <mstr> but foldr:s type signature is (a -> b -> b) -> b -> [a] -> b
02:56:16 <FunctorSalad_> Baughn: funny story :)
02:56:18 <mstr> isn't b the accumulator?
02:56:22 <blackh> mstr: You're using foldl
02:56:48 <mstr> oh, the arguments are reversed :D
02:57:06 <lilac> and you're returning the wrong type. perhaps you meant: shuffleIndexes n rnd = tail $ foldl rndIndex [(undefined, rnd)] [n,n-1..1] where rndIndex xx@((_,rng):xs) k = randomR (1,k) rng:xx
02:57:11 <mstr> "never assume anything" learned once more ;P
02:57:26 <lilac> (note that rndIndex should be returning a list if you want this to work)
02:57:45 <lilac> @type let shuffleIndexes n rnd = tail $ foldl rndIndex [(undefined, rnd)] [n,n-1..1] where rndIndex xx@((_,rng):xs) k = randomR (1,k) rng:xx in shuffleIndexes
02:57:46 <lambdabot> forall t t1. (Enum t, RandomGen t1, Random t, Num t) => t -> t1 -> [(t, t1)]
02:58:04 <lilac> @type stdGen
02:58:05 <lambdabot> Not in scope: `stdGen'
02:58:13 <lilac> @type let shuffleIndexes n rnd = tail $ foldl rndIndex [(undefined, rnd)] [n,n-1..1] where rndIndex xx@((_,rng):xs) k = randomR (1,k) rng:xx in shuffleIndexes 10 (mkStdGen 12345)
02:58:14 <lambdabot> forall t. (Enum t, Random t, Num t) => [(t, StdGen)]
02:58:23 <lilac> > let shuffleIndexes n rnd = map fst . tail $ foldl rndIndex [(undefined, rnd)] [n,n-1..1] where rndIndex xx@((_,rng):xs) k = randomR (1,k) rng:xx in shuffleIndexes 10 (mkStdGen 12345)
02:58:24 <lambdabot>   [2,1,3,4,2,4,3,9,4,* Exception: Prelude.undefined
02:58:40 <lilac> > let shuffleIndexes n rnd = map fst . init $ foldl rndIndex [(undefined, rnd)] [n,n-1..1] where rndIndex xx@((_,rng):xs) k = randomR (1,k) rng:xx in shuffleIndexes 10 (mkStdGen 12345)
02:58:41 <lambdabot>   [1,2,1,3,4,2,4,3,9,4]
02:59:02 <roderyk> I'm taking a shot at rewriting my haskell raytrace; the last one had terrible performance. Since I don't have working code yet to profile, I'm just curious about two things: if I have a large list of [Triangles] which are some tuple of floats and floats of tuples, is there a noticeable performance boost to use newtype instead of Data? And second, should I be storing the [Triangles] in some other manner than as a list that gets passed aroun
02:59:03 <roderyk> d (after initial setup, the list is never modified.. just mapped over lots of times w/ different functions)
03:00:18 <mstr> lilac: ah, yeah. already changed it to return a list
03:00:30 <lilac> roderyk: do you use a BSP tree or similar for storing your primitives? if not, i think that's probably the first thing i'd look into
03:00:41 <augustss> roderyk: if all you do is map over the list, then it's a good choice
03:00:52 <Peaker> roderyk: if you're writing a ray tracer, why are you using Triangles as your data structure?
03:01:00 <Peaker> roderyk: as your model shape, that is
03:01:31 <roderyk> Peaker: little confused by the question, I'm tracing a triangle-mesh
03:01:56 <Peaker> roderyk: don't you want spheres and other nice shapes in your 3d model?
03:02:34 <roderyk> Peaker: no, I'm just optimizing for triangular meshes :-)  (at least for now...)
03:04:22 <roderyk> lilac: I will be looking into BSP trees, I was not particularly pleased with my current tracer from a architecture view (and was having some trouble with the shading), so I decided I would just code up a base alternative in a couple hours.. you know, a fresh start kind of thing :-)
03:05:30 <yitz> roderyk: if you don't need laziness, newtypes are always good where you can use them.
03:05:50 <Peaker> is it okay for a cabal package to install its example in your ~/.cabal/bin
03:06:00 <Peaker> or is that pollution?
03:06:09 <yitz> roderyk: you probably also want strict tuples (or perhaps even unboxed, but I don't know much about those)
03:06:23 <augustss> Peaker: sounds like pollution
03:06:24 <lilac> Peaker: is the example useful in and of itself?
03:06:37 <lilac> Peaker: that is, would i want it in my $PATH?
03:06:39 <Peaker> lilac, augustss: I guess I can make a useful example, instead :)
03:06:54 <Peaker> A simple CSV editor to demonstrate my widget set! :-)
03:07:53 <Toxaris> Peaker: is the example there for running and looking at it, or for looking at the code
03:08:06 <Peaker> Toxaris: for both
03:08:08 <roderyk> yitz: I was wondering about this, can newtypes be specified as strict? (the notation I understand with '!' I thought was limited to Data constructors)
03:08:12 <Peaker> brb
03:08:24 <yitz> roderyk: newtypes are strict by definition
03:08:29 <roderyk> ah, ok
03:09:55 <Toxaris> Peaker: making the example useful is a nice idea (may well be a better example then), but its still pollution. install a library, get an executable :(
03:12:14 <FunctorSalad_> debian tends to put them into $PREFIX/share/doc/$foo/examples
03:13:24 <FunctorSalad_> which I think is $DOCDIR/examples in cabal
03:15:05 <lilac> roderyk: newtype strictness is different from data strictness. In "data X = X !Int", you get "_|_" but no "X _|_". In "newtype X = X Int", you get "X _|_" but no "_|_".
03:15:20 <mstr> hmm, I still failed
03:15:21 <mstr> http://pastebin.com/f74d32119
03:16:14 <yitz> lilac: doesn't the report say that X _|_ == _|_ ?
03:16:33 <yitz> for newtype
03:16:39 <dolio> > State undefined `seq` ()
03:16:40 <lambdabot>   * Exception: Prelude.undefined
03:17:00 <doserj> mstr: snd. last $ acc ?
03:17:02 <dolio> > case undefined of (State _) -> ()
03:17:03 <lambdabot>   ()
03:17:07 <lilac> yitz: i'm not sure how the report words it :)
03:17:07 <dolio> It depends what you're doing.
03:17:34 <mstr> doserj: acc should have (random,randomgen) pairs
03:17:34 <lilac> > undefined :: State
03:17:35 <lambdabot>       `State' is not applied to enough type arguments
03:17:35 <lambdabot>      Expected kind `?',...
03:17:44 <FunctorSalad_> didn't you guys say that the truth is that there is no newtype?
03:17:45 <lilac> > undefined :: State Int Int
03:17:46 <lambdabot>       No instance for (Show (State Int Int))
03:17:46 <lambdabot>        arising from a use of `sh...
03:17:51 <mstr> so I take the latest randomgen. ?
03:18:04 <FunctorSalad_> so X _|_ = _|_ anyway after compililation
03:18:04 <dolio> All pattern matches on newtypes essentially have an implicit ~.
03:18:19 <dolio> But seq is magic, so it doesn't apply there.
03:18:20 <lilac> mstr: snd . last acc == \x -> snd (last acc x)
03:18:37 <lilac> mstr: you want: snd (last acc) == snd $ last acc == snd . last $ acc
03:19:13 <doserj> mstr: (snd . last acc) gets parsed as (snd . (last acc)) But I guess you want ((snd . last) acc)
03:19:38 <lilac> mstr: remember that function application has the highest precedence
03:19:39 <mstr> ah I see
03:20:17 <yitz> lilac: I think the distinction is that with data X !Int is a different type but the constructor is strict, while newtype is just an alias for Int that is allowed to have different class instances than Int itself (which only matters at compile time).
03:20:43 <yitz> while in practice, ghc may optimize both of them to be the same thing
03:21:21 <dolio> newtype is not an alias, it's a different type.
03:21:25 <FunctorSalad_> is there some collection of guidelines when you should make arguments or fields strict?
03:21:40 <lilac> yitz: my point was that you can tell them apart by pattern matching on _|_
03:21:41 <dolio> You can't call a function of type X -> Whatever with an Int.
03:21:55 <FunctorSalad_> (still confused by "on which level am I making things strict with this")
03:21:57 <mstr> it works :)
03:22:12 <mstr> blackh, lilac, doserj : thank you very much :)
03:22:48 <FunctorSalad_> should I make an argument x strict if I can say that "noone would reasonably call this function with x = undefined and expect an result"?
03:22:56 <yitz> dolio: it's a different type syntactically (and hence for type inference), but they compile to the same representation.
03:23:15 <FunctorSalad_> or is it "with x *containing* undefined somewhere deeper down"
03:23:49 <lilac> FunctorSalad_: explicit strictness annotations can be good for solving space leaks and sometimes for improving performance by not building and tearing down thunks
03:24:03 <yitz> dolio: whereas strict data is allowed to have a different representation - though I think in practice it doesn't for ghc
03:24:44 <dolio> Well, that depends.
03:24:57 <dolio> On whether you UNPACK, probably.
03:25:13 <dolio> Although I'm not certain.
03:25:20 <lilac> FunctorSalad_: if you make an element of a data structure strict, you're saying 'never put a thunk here -- i always want this value when i force this structure'
03:25:21 <yitz> makes sense
03:25:48 <dolio> I mean, if you restrict yourself to 1-field datas, then you could probably do the same optimization.
03:25:53 <dolio> But then why not just recommend newtype?
03:26:27 <lilac> FunctorSalad_: if you make a function argument strict, you're probably achieving nothing since the strictness analyzer in GHC is very good :)
03:27:16 <xenoblitz> guys is hpaste dead?
03:27:34 <Cale> moonpatio.com:8080
03:27:49 <xenoblitz> thanks
03:27:50 <yitz> lilac: there are plenty of situations where in principle there is no way for the compiler to know whether you want it to be strict
03:28:07 <yitz> @where hpaste2
03:28:07 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
03:28:19 <lilac> yitz: sure. hence 'probably' :)
03:28:28 <yitz> hmm, perhaps that should be changed to what Cale wrote?
03:28:39 <dolio> The strictness analyzer in GHC is very good?
03:29:11 <yitz> @where+ hpaste2 http://moonpatio.com:8080/
03:29:11 <lambdabot> It is forever etched in my memory.
03:29:18 <yitz> @where hpaste2
03:29:19 <lambdabot> http://moonpatio.com:8080/
03:30:16 <yitz> @where hpastetwo
03:30:16 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
03:30:28 <yitz> @where+ hpastetwo http://moonpatio.com:8080/
03:30:28 <lambdabot> Okay.
03:31:59 <FunctorSalad_> lilac++ that makes sense... (strict field = no thunk there)
03:32:21 <FunctorSalad_> the thing in the field may still contain a thunk somewhere though as I understand it now
03:32:47 <lilac> yes. but not at the top level.
03:33:46 <lilac> places where there can be a thunk == places where there can be a _|_, basically
03:33:48 <FunctorSalad_> is calculating thunks a real function call or does ghc implement its own stack?
03:35:29 <yitz> FunctorSalad_: good question. the answer is probably - whichever is faster
03:37:02 <yitz> FunctorSalad_: when unravelling thunks causes a stack overflow, you get a ghc runtime "stack overflow" and not a crash, so probably its own stack.
03:38:15 <FunctorSalad_> hmm, yes
03:38:17 <Axman6> @tell conal Sorry about the typo, it's all fixed now :)
03:38:17 <lambdabot> Consider it noted.
03:38:52 <Cale> I wonder what sorts of fair dice with uniform mass density there are whose symmetry group acts intransitively on the faces? :)
03:39:21 <Axman6> Cale: yeah, i've always wondered that...
03:39:45 <Cale> So they're fair, but not obviously fair.
03:40:05 <Cale> Hard to calculate, I think
03:40:40 <FunctorSalad_> uniform mass density? doesn't that fix one solution already
03:40:49 <FunctorSalad_> unless you also count the paint ;)
03:40:59 <tom`> bit of  a general question here, but what Monad should I use to keep track of a syntax table? I remember there's one that has a stack and I can push it down and add new values then pop the whole layer later on
03:41:06 <Cale> FunctorSalad_: They're arbitrary polyhedra.
03:41:12 <Cale> (not necessarily regular)
03:41:13 <Philippa_> tom`: Reader
03:41:17 <tom`> I'm sure I could use the State monad, but I remember there being a standard one perfect for this
03:41:20 <FunctorSalad_> Cale: ah, I thought just cubes
03:41:22 <tom`> Thansk Philippa_
03:41:38 <hackage> Uploaded to hackage: haskgame 0.0.3
03:51:48 <Axman6> Workybob_: you wanted me?
03:52:00 <Workybob_> Axman6: I think I'm covered
03:52:05 <Workybob_> I'm having another go with TM
03:52:14 <Axman6> TextMate?
03:52:15 <Workybob_> took a lot of hacking to get its Haskell mode acceptable
03:52:20 <Workybob_> but it's certainly got some nice features
03:52:37 <Axman6> Workybob_: you should check out ozy`'s changes
03:52:39 <Axman6> sec
03:53:35 <Axman6> http://www.rsmw.net/ergo/Haskell.plist copy that into the haskell language dedinition, in the bundle editor (cmd-opt-ctrl-b, or keyboardjam-p)
03:53:50 <Axman6> makes the syntax highlighting a lot nicer
03:54:21 <Axman6> which features do you like btw? i've always found TM not all that great for haskell, compared to most of the bigger languages
03:56:22 <Workybob_> well, I've got tab completion of things like if/case/let working correctly with indenting coming out right now
03:56:25 <Workybob_> which is rather nice
03:56:43 <Workybob_> and limitted code folding, though recognising the end of the definition is not perfect
03:57:28 <Axman6> Workybob_: so you're working on improving the bundle?
03:57:34 <Workybob_> a little bit yeh
03:58:01 <Workybob_> my code folding changes appear to cause it to segfault reasonably often though
03:58:05 <Workybob_> I need to figure out why >.>
03:58:09 * Workybob_ runs off for lunch
03:58:10 <Axman6> haha
03:58:49 <Axman6> Workybob_: well when you're back, be sure to let allan know about your changes in ##textmate (or Infininight)
04:01:02 <tom`> #haskell
04:01:17 <tom`> pardon me
04:01:42 <tom`> another probably quite silly question, i've got "import Control.Monad.Reader" and it's saying can't find module. Any idea why?
04:02:39 <adrian_> tom: which version of ghc are you using?
04:03:16 <tom`> 6.8.2 (ubuntu intrepid ibex package)
04:03:47 <adrian_> does ":m Control.Monad.Reader" work in ghci?
04:04:03 <tom`> no: "Could not find module `Control.Monad.Reader':"
04:04:17 <adrian_> hm that's strange
04:04:32 <tom`> good, thought I was just being an idiot ;)
04:04:52 <tom`> do I maybe need to enable extensions or something like that?
04:05:04 <adrian_> it works for me without anything special
04:05:05 <bastl> hi, i installed ghc 6.10 locally, but now i dont have GTk-bindings anymore. what package do i have to install ?
04:05:17 <adrian_> but i'm on ghc 6.10
04:05:40 <adrian_> basti: gtk2hs?
04:06:48 <bastl> cabal: THere is no package
04:06:56 <tom`> aha! ubuntu has a libghc6-mtl-dev package
04:06:59 <bastl> named gtk2hs
04:14:56 <Axman6> argh, why is IRC so dead tonight
04:15:30 <yitz> bastl: gtk2hs still has not been cabalized. you need to install a package on your platform if available, or download it and build it.
04:15:42 <bastl> yitz: thanks i just tried that
04:15:53 <yitz> bastl: i'm not sure what the deal is with gtk2hs on ghc 6.10.* though
04:16:25 <bastl> but it doesnt recognize my ghc: --with-hc /path/to/my/ghc -> machine `/opt/bin/ghc' not recognized
04:16:33 <yitz> bastl: the official release, from 8 months ago, only promises 6.8.3
04:16:43 <bastl> hm
04:17:42 <yitz> bastl: you may need the darcs version
04:17:53 <bastl> of gtk2hs?
04:18:02 <bastl> k, gonna try that .
04:19:10 <ivanm> yitz: there are rumours of pre-releases... >_>
04:19:39 * yitz eagerly accepts such rumors
04:20:38 <ivanm> whilst you're at it, do you want a rumour of a beta fork of ghc that turns C code into completely readable, idiomatic documented Haskell and then out-performs the original C version?
04:20:43 <ivanm> ;-)
04:21:14 * yitz has his limits
04:21:35 <ivanm> heh
04:22:04 <Axman6> omg! i can't wait :D
04:22:24 <yitz> i'm really stuck with gtk2hs right now - i'm using macports, which is at 6.10.1, so the gtk2hs has been broken for a long time.
04:22:56 <ivanm> and nudging dcoutts about it doesn't help, since he's busy hacking on cabal (and I don't know who else is working on gtk2hs)
04:22:58 <ivanm> :(
04:23:03 <bastl> ehm, there is no configure script in the darcs version of gtk2hs !?
04:23:26 <ivanm> bastl: no makefile?
04:23:32 <ivanm> :o
04:23:41 <yitz> bastl: maybe you need to run auto<something> to get it?
04:23:51 <bastl> only these inputs for autoconf, which i dont know how to use
04:23:59 <bastl> :-/
04:24:06 <yitz> bastl: type autoconf and see what happens
04:24:21 <bastl> getting errors
04:24:31 <yitz> bastl: no INSTALL or README?
04:24:43 <bastl> INSTALL refers to ./configure :-/
04:24:50 <yitz> heh
04:25:17 <yitz> @seen dcoutts
04:25:17 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 58m 37s ago.
04:25:18 <Axman6> hmm, would foldr seq () be a reasonable definition for rnf for lists?
04:26:22 <yitz> Axman6: hnf
04:26:24 <ivanm> Axman6: it only does it the spine, so it's only wrnf or whatever the acronym is
04:26:51 <yitz> oh, yeah more than hnf. but less than rnf
04:26:51 <ivanm> Axman6: i.e. it creates the list, but none of the elements _in_ the list (they're still thunks)
04:26:54 <ivanm> in general that is
04:26:57 <ehird> How can I get the current year, month and day?
04:27:01 <ivanm> whnf maybe?
04:27:15 <yitz> ehird: type 'date' at the command line
04:27:19 <opqdonut> ivanm: doesn't it seq the elements?
04:27:26 <ehird> yitz: sigh...
04:27:29 <ivanm> ehird: System.Time?
04:27:32 <opqdonut> ivanm: but of course it doesn't deep-seq them
04:27:36 <ivanm> opqdonut: exactly
04:27:54 <opqdonut> so it does more than, for instance, length
04:28:02 <ivanm> so IIRC, ints, etc. would be fully evaluated, but nothing with an actual constructor
04:28:03 <ehird> ivanm: Thanks, that looks right.
04:28:19 <ivanm> ehird: there's another package that offers more functionality, but I can't remember which one
04:28:25 <ivanm> see RWH, it has a section on dates
04:28:39 <ehird> I don't need more :-)
04:28:40 <ivanm> (not on how to get a relationship-style date, unfortunately :( )
04:28:43 <ivanm> heh
04:28:51 <yitz> ehird: that's the old time pkg. see Date.Time.getCurrentTime
04:29:07 <ivanm> yitz: there's finally a _new_ time package? :o
04:29:22 <ehird> Well...
04:29:22 <ehird> http://haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Calendar.html
04:29:28 <ehird> I see no y,m,d stuff.
04:29:42 * ivanm can't find Data.Time in his ghc docs...
04:30:00 <ivanm> ehird: yeah, you need to use it with some locale library IIRC
04:30:08 <ivanm> as I said, RWH has a section on it
04:30:12 <ehird> I think I'll use old-time.
04:30:17 <ivanm> System.Locale
04:30:34 <yitz> ehird: toGregorian
04:30:35 <ivanm> ehird: oh, you mean new time doesn't?
04:30:46 <ehird> ivanm: yeah
04:31:03 <ivanm> yitz: does it have a toJulian as well? ;-)
04:31:53 <yitz> toModifiedJulianDay
04:32:02 <Philonous> Is there an ETA for GHC 6.10.2?
04:32:18 <yitz> "The Modified Julian Day is a standard count of days, with zero being the day 1858-11-17."
04:32:29 <ivanm> Philonous: "someday soon" ? ;-)
04:32:45 <ivanm> what was the package where they said that each time someone asked when it would be released, they added a week?
04:32:50 <Philonous> Ah, "real soon now" ...
04:32:50 <yitz> ehird: old-time is deprecated, and has quirks
04:32:58 <ehird> uh oh... /me gets the "I Am 100% Positive Calendar Is Not Spelled Calendar" syndrome
04:33:00 <ivanm> yitz: most packages have quirks...
04:33:10 <ivanm> @spell calendar
04:33:22 <ehird> yitz: it has CalendarTime and a way to get the current one
04:33:22 <ivanm> hmmm.... I thought lambdabot had a @spell plugin...
04:33:22 <ehird> WFM
04:33:49 <yitz> ivanm: it used to
04:33:54 <ivanm> oh
04:33:54 <Thunder> ivanm: Lamdabot is still booting. You may use the plugin in the next few weeks.
04:33:58 <yitz> @dict calendar
04:33:58 <lambdabot> Supported dictionary-lookup commands:
04:33:58 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
04:33:58 <lambdabot> Use "dict-help [cmd...]" for more.
04:34:15 <ivanm> Thunder: nah, lambdabot will crash before that :s
04:34:16 <yitz> @wn calendar
04:34:17 <lambdabot> *** "calendar" wn "WordNet (r) 2.0"
04:34:17 <lambdabot> calendar
04:34:17 <lambdabot>      n 1: a system of timekeeping that defines the beginning and
04:34:17 <lambdabot>           length and divisions of the year
04:34:17 <lambdabot>      2: a list or register of events (appointments or social events
04:34:19 <lambdabot> [4 @more lines]
04:34:27 <yitz> @more
04:34:27 <lambdabot>         or court cases etc); "I have you on my calendar for next
04:34:27 <lambdabot>         Monday"
04:34:27 <lambdabot>      3: a tabular array of the days (usually for one year)
04:34:27 <lambdabot>      v : enter into a calendar
04:34:56 <yitz> I am going to calendar that definition
04:35:41 <ivanm> heh
04:35:51 <ehird> @hoogle [String] -> IO ()
04:35:51 <lambdabot> Distribution.Make defaultMainArgs :: [String] -> IO ()
04:35:51 <lambdabot> Distribution.Simple defaultMainArgs :: [String] -> IO ()
04:35:51 <lambdabot> Distribution.Simple.Command noExtraFlags :: [String] -> IO ()
04:35:54 <ivanm> @hoogle date
04:35:54 <lambdabot> Distribution.Simple.SrcDist dateToSnapshotNumber :: CalendarTime -> Int
04:35:54 <lambdabot> Data.Time.Calendar.OrdinalDate fromOrdinalDate :: Integer -> Int -> Day
04:35:54 <lambdabot> Data.Time.Calendar.WeekDate fromWeekDate :: Integer -> Int -> Int -> Day
04:36:30 <ivanm> so either hoogle doesn't now about new-time, or else new-time doesn't have a function whose name contains the word "date"
04:36:43 <ivanm> oh, wait, System.Time is the old time and Data.Time is the new one
04:36:45 <ivanm> my mistake
04:36:54 <yitz> ivanm: it's called Day
04:36:59 <yitz> @hoogle Day
04:36:59 <lambdabot> Data.Time.Calendar newtype Day
04:36:59 <lambdabot> Data.Time.LocalTime dayFractionToTimeOfDay :: Rational -> TimeOfDay
04:36:59 <lambdabot> Data.Time.Calendar.MonthDay dayOfYearToMonthAndDay :: Bool -> Int -> (Int, Int)
04:37:45 <ivanm> @hoogle Night
04:37:45 <lambdabot> Data.Time.LocalTime midnight :: TimeOfDay
04:37:48 <ivanm> :o
04:38:00 <ivanm> > Data.Time.LocalTime.midnight
04:38:01 <lambdabot>   /tmp/4018215434702909449:70:32:
04:38:01 <lambdabot>      Not in scope: `Data.Time.LocalTime.mid...
04:38:04 <ivanm> :(
04:38:14 <ivanm> @slap mueval
04:38:14 * lambdabot pulls mueval through the Evil Mangler
04:38:20 <ehird> :t ifM
04:38:21 <lambdabot> Not in scope: `ifM'
04:38:26 <ivanm> heh, which is semi appropriate
04:38:26 <ehird> :t condM
04:38:27 <lambdabot> Not in scope: `condM'
04:38:35 <ivanm> @hoogle ifM
04:38:36 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
04:38:36 <lambdabot> Distribution.Simple.Utils createDirectoryIfMissingVerbose :: Verbosity -> Bool -> FilePath -> IO ()
04:38:36 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
04:38:45 <ivanm> ehird: which library is ifM in?
04:38:56 <ehird> dunno.
04:38:59 <ehird> :-)
04:39:00 <ivanm> heh
04:39:02 <ehird> I was looking for it.
04:39:15 <Workybob_> Axman6: they know – they were helping me out
04:39:16 <ivanm> ehird: try hayoo, which IIRC indexes all libraries on hackage
04:39:23 <ehird> @hoogle (Monad m) => Bool -> m () -> m ()
04:39:23 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
04:39:23 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
04:39:23 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
04:39:24 <Axman6> Workybob_: i oticed :)
04:39:28 <ehird> "when"
04:39:46 <Workybob_> gah
04:39:54 <Axman6> n*
04:39:56 <Workybob_> yet another function that should be Applicative m =>
04:39:59 <ivanm> > (when True return fail) 1 :: Maybe Int
04:40:00 <Workybob_> no Monad m =>
04:40:01 <lambdabot>   Couldn't match expected type `()' against inferred type `m a'
04:40:01 <ehird> *g*
04:40:07 <ivanm> oh, duh
04:40:31 <ivanm> @hoogle Applicative
04:40:32 <lambdabot> module Control.Applicative
04:40:32 <lambdabot> Control.Applicative class Functor f => Applicative f
04:40:32 <lambdabot> package applicative-extras
04:40:44 <ivanm> @src Applicative
04:40:45 <lambdabot> class Functor f => Applicative f where
04:40:45 <lambdabot>     pure  :: a -> f a
04:40:45 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
04:41:00 <ivanm> what's pure for? functor equivalent of return?
04:41:03 <Peaker> Toxaris: was away, I agree -- I meant by "making the example useful" that I want it as a separate package
04:41:08 <ivanm> > pure 1 :: Maybe Int
04:41:09 <lambdabot>       Ambiguous occurrence `pure'
04:41:09 <lambdabot>      It could refer to either `Control.Appl...
04:41:10 <Workybob_> ivanm: applicative return
04:41:19 <ivanm> Workybob_: *nod*
04:41:22 <Workybob_> > Control.Applicative.pure 1 :: Maybe Int
04:41:24 <lambdabot>   Just 1
04:41:36 <Toxaris> Peaker: that sounds reasonable!
04:41:36 <yitz> @hoogle pure
04:41:36 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
04:41:36 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
04:41:36 <lambdabot> package pureMD5
04:41:38 <Workybob_> actually
04:41:43 <ivanm> which functors _aren't_ monads (in the standard library)?
04:41:44 <Workybob_> when doesn't even need applicative does it
04:41:51 <Workybob_> it needs only Functor
04:41:57 <ivanm> @src when
04:41:57 <lambdabot> when p s = if p then s else return ()
04:42:06 <Workybob_> or does it
04:42:11 <Workybob_> no, it needs applicative
04:42:35 <ivanm> hmmm..... I misread when's type to have an extra -> m () on the end...
04:42:44 <Baughn> FunctorSalad_: Actually, the ironic lack of a funny story to go with your "funny story" exclamation was only moderately amusing.
04:43:15 * Workybob_ ponders if he can think of functors which are not monads in the standard library
04:43:19 <Workybob_> I know of at least one outside them
04:43:22 <Workybob_> Behavior from reactive
04:43:34 <ivanm> *nod*
04:43:35 <Axman6> (,)
04:43:56 <Axman6> @instances Functor
04:43:57 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:44:00 <Axman6> @instances Monad
04:44:00 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
04:44:07 <Workybob_> well done Axman6
04:44:09 <Axman6> :)
04:44:23 <Workybob_> ((,) a) isn't even an applicative
04:44:37 <Workybob_> @instances Applicative
04:44:38 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
04:44:49 <Workybob_> @instances-importing Control.Applicative Applicative
04:44:49 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
04:44:57 <Workybob_> oh, yes it is!
04:45:01 * Workybob_ wonders what pure looks like
04:45:05 <Workybob_> @src ((,) a) pure
04:45:05 <lambdabot> Source not found. You speak an infinite deal of nothing
04:45:12 <Workybob_> @src pure ((,) a)
04:45:12 <lambdabot> Source not found. There are some things that I just don't know.
04:45:14 <Workybob_> bah
04:45:30 <ivanm> why can't ((,) a) be a monad?
04:45:40 <Workybob_> well I can't think what return looks like
04:45:41 <ivanm> @src ((,) a) Applicative
04:45:41 <lambdabot> Source not found. Are you on drugs?
04:45:48 <ivanm> Workybob_: same as pure?
04:45:49 <Workybob_> but if there's pure, there's return
04:45:55 <Workybob_> ivanm: indeed – I just can't think what pure is
04:46:18 <Axman6> instance Applicative f => Monad f where return = pure?
04:46:18 <Workybob_> oh hang on – I know why
04:46:23 <ivanm> > pure 2 :: (Int, Int)
04:46:24 <lambdabot>       Ambiguous occurrence `pure'
04:46:24 <lambdabot>      It could refer to either `Control.Appl...
04:46:34 <ivanm> > Control.Applicative.pure 2 :: (Int, Int)
04:46:35 <lambdabot>       No instance for (Monoid Int)
04:46:36 <lambdabot>        arising from a use of `Control.Appl...
04:46:41 <Workybob_> ahhhhhh!
04:46:41 <ivanm> > Control.Applicative.pure 2 :: ((), Int)
04:46:43 <lambdabot>   ((),2)
04:46:59 <ivanm> yeah, the a bit is weird... you need a default value
04:47:26 <ivanm> Axman6: so now we need bind and fail... if all else "fails" ( :p ), then fail = error
04:47:46 <ivanm> I'd say that bind is pretty obvious as well
04:47:51 <Workybob_> yeh
04:48:08 <Workybob_> (_,v) >>= f = f v
04:48:20 <Workybob_> although this does make it a very boring monad
04:48:26 <ivanm> @type (>>=)
04:48:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:48:41 <ivanm> couldn't remember which bit was monad and which wasn't :s
04:48:49 <ivanm> Workybob_: aren't quite a few monads boring>
04:48:52 <ivanm> ?
04:48:54 <yitz> > Tree "foo"
04:48:54 <lambdabot>   Not in scope: data constructor `Tree'
04:48:56 <ivanm> @src [] Monad
04:48:57 <lambdabot> Source not found. I feel much better now.
04:49:03 <yitz> > Data.Tree.Tree "foo"
04:49:03 <Workybob_> alternatively... (x,v) >>= f = let (y,v') = f v in (x `mappend` y, v')
04:49:04 <lambdabot>   Not in scope: data constructor `Data.Tree.Tree'
04:49:06 <Workybob_> that's more interesting
04:49:07 <ivanm> @src Maybe Monad
04:49:07 <lambdabot> Source not found. It can only be attributed to human error.
04:49:10 <Axman6> (x,y) >>= f = let (_,y') = f y in (x,y')?
04:49:12 <ivanm> grrr....
04:49:23 <Workybob_> but I don't know if it respects monad laws
04:49:25 <Axman6> ah lame Workybob_, basically beat me to it
04:49:32 <ivanm> Axman6: nah, I think what Workybob_ had would do it
04:49:35 <ivanm> Workybob_: true
04:49:36 <blathijs> Is there any function to map a function onto a tuple? Ie, (a -> b) -> (a, a) -> (b, b)
04:49:41 <ivanm> and atm, I don't really care :p
04:49:50 <ivanm> blathijs: check the arrow library...
04:49:53 <Workybob_> blathijs: &&&
04:49:55 <ivanm> since tuples are arrows
04:49:58 <Workybob_> f &&& f
04:50:09 <yitz> > Node "foo"
04:50:10 <lambdabot>       Overlapping instances for Show (Forest [Char] -> Tree [Char])
04:50:10 <lambdabot>        ar...
04:50:13 <ivanm> @hoogle (a -> b) -> (a,a) -> (b,b)
04:50:13 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
04:50:13 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
04:50:13 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
04:50:33 <ivanm> nah, they're all wrong
04:50:52 <yitz> > Node "foo" []
04:50:54 <lambdabot>   Node {rootLabel = "foo", subForest = []}
04:50:55 <ivanm> @pl f &&& f
04:50:55 <lambdabot> f &&& f
04:51:07 <ivanm> oh, I thought there'd be an ap approach or something...
04:51:17 <Workybob_> @pl \f -> f &&& f
04:51:18 <lambdabot> join (&&&)
04:51:32 <ivanm> yeah, I just realised that I hadn't provided a parameter myself ;-)
04:52:01 <Workybob_> gah
04:52:06 <Workybob_> TextMate just crashed on me again
04:52:14 <ivanm> @slap TextMate
04:52:14 * lambdabot submits TextMate's email address to a dozen spam lists
04:53:41 <yitz> > let n3 a b c = Node a [Node b [], Node c []] in n3 (n3 "a" "b" "c") (n3 "d" "e" "f") (n3 "g" "h" "i") >>= id
04:53:42 <lambdabot>   Node {rootLabel = "a", subForest = [Node {rootLabel = "b", subForest = []},...
04:54:10 <Thunder> @src Node
04:54:11 <lambdabot> Source not found. There are some things that I just don't know.
04:54:27 <yitz> Thunder: it's the contructor for Tree
04:54:32 <yitz> constructor
04:54:44 <Workybob_> yeh, Axman6, this is why I think I'm going back to SEE
04:54:46 <Workybob_> http://www.cs.kent.ac.uk/people/rpg/tatd2/mate.png
04:55:07 <Thunder> I just want to know which module lambdabot uses
04:55:22 <Axman6> wtf did you do?
04:55:28 <ivanm> @hoogle Node
04:55:29 <lambdabot> Data.Tree Node :: a -> Forest a -> Tree a
04:55:29 <lambdabot> Test.HUnit.Base data Node
04:55:29 <lambdabot> Distribution.PackageDescription CondNode :: a -> c -> [(Condition v, CondTree v c a, Maybe (CondTree v c a))] -> CondTree v c a
04:55:36 <ivanm> Thunder: ^^ that's how you tell
04:55:47 <Axman6> Workybob_: seriously, i've been using it for years now, and i've never had any of these problems
04:56:05 <ivanm> hmmmm..... I thought @hoogle looked up constructors...
04:56:13 <ivanm> maybe I'm thinking of :info ...
04:56:16 <ivanm> :info Node
04:56:22 <ivanm> does lambdabot support :info ?
04:56:28 <Thunder> @info Node
04:56:28 <lambdabot> Node
04:58:16 <yitz> > let showTree x ts = show x++showForest ts; showForest=show.map showTree; n3 a b c = Node a [Node b [], Node c []] in showTree $ n3 (n3 "a" "b" "c") (n3 "d" "e" "f") (n3 "g" "h" "i") >>= id
04:58:17 <lambdabot>       Overlapping instances for Show ([Tree [Char]] -> [Char])
04:58:17 <lambdabot>        arising...
04:58:45 <yitz> > let showTree (Node x ts) = show x++showForest ts; showForest=show.map showTree; n3 a b c = Node a [Node b [], Node c []] in showTree $ n3 (n3 "a" "b" "c") (n3 "d" "e" "f") (n3 "g" "h" "i") >>= id
04:58:46 <lambdabot>   "\"a\"[\"\\\"b\\\"[]\",\"\\\"c\\\"[]\",\"\\\"d\\\"[\\\"\\\\\\\"e\\\\\\\"[]\...
04:58:58 <BrokenClockwork> BONUS: Hey, do you work with Vim or GVim?
04:59:43 <blathijs> ivanm: I've looked at arrows, but I'm not completely sure how to use them. Am I looking to apply an arrow to a tuple, or is the construction of the tuple in some way an arrow?
04:59:46 <yitz> > let showTree (Node x ts) = show x++showForest ts; showForest=show.map showTree; n3 a b c = Node a [Node b [], Node c []] in showTree $ n3 (n3 1 2 3) (n3 4 5 6) (n3 7 8 9) >>= id
04:59:47 <lambdabot>   "1[\"2[]\",\"3[]\",\"4[\\\"5[]\\\",\\\"6[]\\\"]\",\"7[\\\"8[]\\\",\\\"9[]\\...
05:00:14 <ivanm> blathijs: the tuple is the arrow
05:00:21 <ivanm> @hoogle (***)
05:00:21 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:00:43 <ivanm> blathijs: ^^ Arrow a => a b c === (b, c) when using tuples
05:01:56 <yitz> > let showTree (Node x ts) = show x++showForest ts; showForest='[':concat(intersperse "," $map showTree)++"]"; n3 a b c = Node a [Node b [], Node c []] in showTree $ n3 (n3 1 2 3) (n3 4 5 6) (n3 7 8 9) >>= id
05:01:57 <lambdabot>   Couldn't match expected type `[[Char]]'
05:02:28 <blathijs> ivanm: But shouldn't an arrow map all b's to a c, like the b -> c arrow does? A single tuple can only map a single value (ie, I'm probably missing something here :-)
05:02:28 <yitz> > let showTree (Node x ts) = show x++showForest ts; showForest ts='[':concat(intersperse "," $map showTree ts)++"]"; n3 a b c = Node a [Node b [], Node c []] in showTree $ n3 (n3 1 2 3) (n3 4 5 6) (n3 7 8 9) >>= id
05:02:30 <lambdabot>   "1[2[],3[],4[5[],6[]],7[8[],9[]]]"
05:02:55 <ivanm> blathijs: I just use it (mainly from @pl results), I have no idea how it works ;-)
05:03:37 <yitz> Tree has a Monad instance, but it is very ad hoc. It really only has a natural Functor and Applicative instance.
05:04:53 <ehird> @Hoogle Enum a => a -> Integer
05:04:53 <lambdabot> Maybe you meant: google hoogle
05:04:55 <ehird> @hoogle Enum a => a -> Integer
05:04:56 <lambdabot> Prelude pred :: Enum a => a -> a
05:04:56 <lambdabot> Prelude succ :: Enum a => a -> a
05:04:56 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
05:05:11 <blathijs> @help pl
05:05:11 <lambdabot> pointless <expr>. Play with pointfree code.
05:05:21 <blathijs> uh?
05:05:25 <ehird> @pl \a -> a
05:05:25 <lambdabot> id
05:05:29 <ehird> @pl \a b -> b a
05:05:29 <lambdabot> flip id
05:05:33 <ehird> @src liftM
05:05:33 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:05:38 <ehird> @pl \f m1 = do { x1 <- m1; return (f x1) }
05:05:39 <lambdabot> (line 1, column 7):
05:05:39 <lambdabot> unexpected "="
05:05:39 <lambdabot> expecting pattern or "->"
05:05:52 <ehird> @pl \f m1 = m1 >>= \a -> return (f a)
05:05:52 <lambdabot> (line 1, column 7):
05:05:52 <lambdabot> unexpected "="
05:05:52 <lambdabot> expecting pattern or "->"
05:05:57 <ehird> @pl \f m1 = m1 >>= (\a -> return (f a))
05:05:57 <lambdabot> (line 1, column 7):
05:05:57 <lambdabot> unexpected "="
05:05:57 <lambdabot> expecting pattern or "->"
05:06:01 <ehird> ... oh
05:06:04 <ehird> @pl \f m1 -> m1 >>= (\a -> return (f a))
05:06:04 <lambdabot> fmap
05:06:07 <ehird> blathijs: it removes points from code.
05:06:32 <yitz> @pl \p x -> guard (p x) >> return x
05:06:32 <lambdabot> (`ap` return) . (((>>) . guard) .)
05:06:35 <Thunder> points are "variable names"
05:07:17 <Thunder> Therefore "pointfree" notation is the code with the huge amount of point literals
05:08:10 <Aska`Tokyo> hello
05:08:17 <yitz> hi Aska`Tokyo
05:08:19 <blathijs> Thunder: Ah
05:08:24 <blathijs> > ((***) (+1) (+1)) (0, 1)
05:08:26 <lambdabot>   (1,2)
05:08:31 <ksf> you don't need dots for pointfree.
05:08:45 <opqdonut> yeah, you can use fmap ;)
05:08:50 <blathijs> ivanm: So I could do something like that, I guess
05:09:08 <ivanm> yeah
05:09:43 <blathijs> Though I was hoping for a simpler "mapTuple" function :-)
05:09:58 <yitz> @pl \(x,y) -> (x+1,y+1)
05:09:58 <lambdabot> (1 +) *** (1 +)
05:10:06 <ksf> you can also foldr (.) (f `fmap`)
05:10:37 <Axman6> :t foldr (.) (fmap ?f)
05:10:38 <lambdabot> forall a b (f :: * -> *). (Functor f, ?f::a -> b) => [f b -> f b] -> f a -> f b
05:10:59 <Axman6> :t foldr (.) (fmap ?g)
05:11:00 <lambdabot> forall a b (f :: * -> *). (Functor f, ?g::a -> b) => [f b -> f b] -> f a -> f b
05:11:09 <Axman6> just to clear things up...
05:11:47 <yitz> Axman6: applying some alpha
05:12:01 <Axman6> eh?
05:12:07 <ksf> :t foldr (.) (`fmap` ?f)
05:12:08 <lambdabot> forall a b (f :: * -> *). (Functor f, ?f::f a) => [f b -> f b] -> (a -> b) -> f b
05:12:16 <yitz> alpha substitution - replacing f by g
05:12:33 <Aska`Tokyo> I have just started learning Haskell, and its still fuzzy for me, if you have any advice about how to learn list management (feeds, sort, delete, order, ...) , it will be welcome
05:12:34 <blathijs> > fmap (+1) (0,1)
05:12:35 <lambdabot>   (0,2)
05:12:40 <yitz> it's a lambda calculus concept
05:12:48 <blathijs> Hah, fmap just works for two tuples :-)
05:12:54 <Peaker> does anyone here manage to have SDL installed on OSX?
05:12:56 <blathijs> > fmap (+1) (0,1,2)
05:12:56 <lambdabot>       No instance for (Functor ((,,) t t1))
05:12:56 <lambdabot>        arising from a use of `fma...
05:13:04 <blathijs> That should do :-)
05:13:09 <blathijs> Thanks for the pointers!
05:13:11 <Peaker> its sad that N-tuple types exist in the first place :P
05:13:15 <Axman6> ah, well, unlike most haskell users, i don't have a degree in lambda calculus or category theory :)
05:13:27 <yitz> Aska`Tokyo: is there a specific problem you have?
05:13:30 <ivanm> Aska`Tokyo: feeds?
05:13:30 <ksf> > (fmap.fmap) (+1) (0,(1,2))
05:13:31 <lambdabot>   (0,(1,3))
05:14:08 <ksf> > fmap (*2) [1..]
05:14:09 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
05:14:13 <Workybob_> Peaker: I'm rapidly coming to the conclusions that ADTs in general need scrapped too
05:14:21 <Workybob_> but I'm gonna have a mega-blog entry about that at some point
05:14:44 <Workybob_> (well, not ADTs, but Haskell's rather arbitrarily designed ones)
05:14:47 <Peaker> Workybob_: in favor of what?
05:14:50 <ksf> they certainly suck in terms of expandability.
05:15:01 <blathijs> Peaker: The alternative for (,,) a b c would be (,) a ((,) b c) ?
05:15:03 <Peaker> Workybob_: I think we need to separate type products from type sums, and products should never introduce new bottoms
05:15:20 <Peaker> blathijs: that's one possibility.. Also HList
05:15:26 <Workybob_> in favor of ones that are based on simpler concepts, like ADT ::= Empty | Unit | Sum ADT ADT | Product ADT ADT
05:15:41 <Workybob_> oh, and probably the ocasional variable thrown about
05:15:45 <Aska`Tokyo> yitz: I made a list like "data Blocs = Blocs String String Int" "Lists = [Blocs]" and I am trying to feed it with an input file... (I am trying with interacts and lines... but I don't get it)
05:15:55 <Peaker> Workybob_: are you sure all 4 are necessary?
05:15:59 <Workybob_> Peaker: that's *exactly* what I'm thinking about
05:16:06 <Workybob_> (the no extra bottoms)
05:16:12 <Workybob_> and yes, I'm sure all 4 are necessary
05:16:14 <Workybob_> it's really 2 pairs
05:16:23 <Workybob_> 2 operations and their identities
05:16:31 <ivanm> anyone else here using haskell-mode for emacs note that (presumably due to the new libedit) that after you enter a value at the ghci prompt, it echos it with a ^J appended?
05:17:02 <Peaker> Workybob_: If "newtype" is allowed to have more than one field, then "data" can still be used for products as well as sums for convenience, but whenever you have one constructor, newtype can be encouraged
05:17:09 <yitz> Aska`Tokyo: do you have a function of type String -> Bloc that parses one line from your input file into a Bloc?
05:17:17 * ksf bets it's because of emacs attempting to be a terminal and failing.
05:17:27 <ivanm> ksf: yeah
05:17:32 <Peaker> Workybob_: If you have an ADT that is just a Product of itself and itself, then it is Empty, right?
05:17:34 <ivanm> since ^J == newline IIRC
05:17:42 <liwp> ivanm: are you on windows?
05:17:50 <ivanm> liwp: nope
05:18:06 <yitz> Aska`Tokyo: oops, String -> Blocs
05:18:17 <Peaker> Workybob_: that way, newtype is used for products, and "data" is used for sums, and you don't get new bottoms for products
05:18:48 <Workybob_> interesting idea
05:18:55 <liwp> I'm running ghci from emacs on OS X without any problems
05:19:11 <Workybob_> in all honesty, I want a more flexible method of defining these without newtype at all
05:19:11 <yitz> Peaker: you mean dataSum and dataProduct? newtype does something else.
05:19:13 <ivanm> liwp: with 6.10?
05:19:30 <liwp> yeah...
05:19:34 <Peaker> yitz: why is newtype not just a type product?
05:19:52 <Peaker> yitz: when it has just one field, it can be optimized to nothing, surely, but that's an implementation detail?
05:20:19 <ivanm> liwp: which version of emacs and haskell-mode do you have?
05:20:22 <liwp> and haskell-mode 2.4
05:20:34 <yitz> Peaker: well currently it is not even that. It's like an alias, but syntactically it defines a "different type" so that you can give it a different set of class instances
05:20:41 <Workybob_> I wanna be able to say something like data Jam a = (Ham × a × (a + Int)) + (Spam × Int × Jam a)
05:20:44 <liwp> I'm running Aquamacs which I think is a branch from Emacs23
05:20:53 <yitz> Peaker: no, not a detail, that's the whole point
05:21:08 <ivanm> well, I'm using emacs built from cvs, and a haskell-mode snapshot from august...
05:21:11 <yitz> Peaker: anyway I like your idea
05:21:12 <Workybob_> so × :: (* -> *) -> * -> *
05:21:15 <Peaker> yitz: yeah, but if you allow more than 1 field in a "newtype", then the single-field case can optimize the same way it does now. Multi-fields can allow bottom-less product
05:21:15 <Workybob_> as does +
05:21:43 <Peaker> yitz: if you introduce dataProduct in addition to data and newtype, it will really be the same as newtype for the single-field case, so why have both?
05:22:09 <Peaker> Workybob_: maybe | instead of + ?
05:22:16 <Workybob_> this also allows for other interesting things – like being able to have a function of type (Int + String) -> String -- not sure what you would write as the definition
05:22:53 <yitz> Peaker: data with a single unary contructor and a strictness bang is already pretty much the same thing as newtype
05:23:13 <Peaker> yitz: not exactly, though
05:23:37 <Peaker> yitz: http://www.haskell.org/haskellwiki/Newtype
05:23:44 <yitz> Peaker: just without the same optimization guarantee, but in fact I think they're the same in ghc
05:24:36 <Peaker> yitz: check out x2,x3,y2,y3 in those examples
05:25:25 <yitz> Peaker: ah, ok.
05:25:52 <Peaker> yitz: type products in general should behave like newtype, no need to lift the values and introduce new bottoms for a non-existent choice
05:26:04 <bastl> still no luck to get gtk2hs running under ghc 6.10 :-/
05:26:18 <roderyk> profiling-101, given +RTS -p -hc : intRayTriangle       Main          317    97700000  70.8   98.7    70.8   98.7
05:26:44 <roderyk> ignoring the %time (this function should be cpu-bound) does the 98.7 mean it's also the real worker allocating memory?
05:27:20 <yitz> Peaker: that's an interesting approach. I don't think it will ever be Haskell though. It could be in Haskell's successor.
05:27:24 <roderyk> does this mean it's generating a lot of thunks... or just that it's constantly pushing and popping lots of temp variables off the stack?
05:27:38 <Peaker> yitz: Haskell'?
05:27:46 <yitz> Haskell''
05:27:49 <Peaker> :-)
05:27:53 <opqdonut> Haskell_\omega
05:28:54 <blathijs> Hmm, I should read lambdabot's output better
05:29:01 <blathijs> fmap doesn't work for tuples as I expected
05:29:08 <blathijs> > fmap (+1) (0,1)
05:29:09 <lambdabot>   (0,2)
05:29:31 <blathijs> It only works on the second element, apparently...
05:29:41 <Aska`Tokyo> yitz: not yet
05:30:41 <Peaker> Workybob_, yitz: I think it should make fmap and second equal, if tuples for example were just type products without bottom
05:31:02 <Workybob_> Peaker: it would indeed
05:31:13 <Workybob_> I had a long discussion on that on Haskell cafe a while back
05:31:24 <Peaker> and then it wouldn't make much sense to use fmap on tuples, except in the context of the writer monad
05:31:32 <Peaker> which would be great for readability :)
05:31:47 <Workybob_> it would also allow you to optimise all values of type () to ()
05:32:09 <blathijs> Let's just define my own tmap f (a, b) = (f a, f b) then..
05:32:22 <roderyk> http://pastebin.com/m669652f1  Could someone please take a look at this snippet? I've run out of ideas on how I can boost the speed. Or can someone atleast confirm that it's a cpu-bound issue, and I'm just going to have to rethink the algorithm?
05:32:25 <SamB_XP> blathijs: it can't help that
05:32:36 <yitz> Aska`Tokyo: ok, do that first. Then write a function that does what you want to do with the Blocs; let's say a function of type Blocs -> String. When you have those working, you can get a stream of lines from a file, feed it to those two functions, and then feed the results back into a different file. Is that what you want to do?
05:32:47 <SamB_XP> blathijs: the types don't work out for fmap to do anything else on tuples
05:33:18 <Peaker> I wonder if functional accessors/references can be composed of a getter and semantic editor combinator instead of getter and setter.. semantic editor combinator being (a -> b) -> (f a -> f b) for some "f", and setter being part -> whole -> whole
05:33:45 <Peaker> SamB_XP: you can have a Functor (a,a) instance :)
05:33:50 <blathijs> SamB_XP: Yeah, I see that now. I misunderstood (,) a to mean a tuple of two a's
05:33:53 <Peaker> (overlapping instances and all)
05:34:38 <sclv> roderyk: how big is the list of surfaces you pass?
05:35:20 <Aska`Tokyo> yitz: ok
05:35:45 <roderyk> sclv: small (<20)
05:35:48 <yitz> Aska`Tokyo: ok. so let's say those two functions are called parseBlocs and processBlocs.
05:35:54 <ksf> peaker, I wrote (a->b) -> (f a > f b) for Events.
05:36:18 <doserj> roderyk: does it help of you do not define Ray and Triangle using tuples?
05:36:52 <Peaker> ksf: the Events functor instance?
05:37:02 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1160#a1160
05:37:06 <ksf> ...and monoid.
05:37:16 <doserj> roderyk: i.e. data Ray = Ray a b instead of data Ray = Ray (a,b)
05:37:35 <roderyk> doserj: ah. I'm using newtype Ray = Ray (a,b)
05:37:59 <yitz> Aska`Tokyo: so then your program will be: main = do f <- readFile "input_file"; writeFile "output_file" . unlines . map (processBlocs . parseBlocs) . lines $ f
05:38:04 <ksf> ...actually, Splice looks a bit different, but it should be the same principle.
05:38:10 <roderyk> I've dropped all data references, hoping it'd be faster. (could that have been premature optimization?)
05:38:23 <doserj> roderyk: ok
05:38:26 <sclv> roderyk:  and you're using hmatrix?
05:39:03 <blathijs> Interesting. I thought I needed a (a -> b) -> (a, a) -> (b, b), but the tuples I'm working with have different element types... Though both of them are lists of lists of different things, so I want to concat each of them...
05:39:16 <yitz> Aska`Tokyo: it's just two steps of IO: read a file, then write a file after passing everything through some pure functions.
05:39:23 <mmorrow> what are (<**>) and (*.) ?
05:39:23 <yitz> Aska`Tokyo: does this make sense?
05:40:55 <roderyk> sclv: no, I didn't think of that since I wasn't doing any _really_ fancy math yet. I should probably look into that, eh?
05:41:05 * ksf decided that data declarations are evil.
05:41:06 <sclv> then what are <**> and *. ?
05:41:09 <mmorrow> roderyk: maybe also try   {-# OPTIONS_GHC  -funbox-strict-fields -O2 #-} ..... data Ray = Ray {-# UNPACK #-} !Double {-# UNPACK #-} !Double
05:41:17 <roderyk> sclv: just my own functions
05:41:36 <doserj> roderyk: how is Number defined?
05:41:48 <sclv> looks like you're just getting lots of gc churn in intRayTriangle...
05:41:58 <mmorrow> roderyk: you might want to profile (<**>) and (*.) as well
05:41:59 <roderyk> doserj: type Number = Float   (I was curious whether Float or Double made significant difference)
05:42:42 <roderyk> mmorrow: I ran -prof-all (and they didn't even really show up..)
05:42:45 <ksf> without vectorizing, they should be similar in performance.
05:43:13 <roderyk> sclv: that's what I was afraid of. thanks for confirming. I presume that the hmatrix vector is unboxed ala mmorrow's suggestion?
05:43:38 <sclv> not necessarily -- i was just curious.
05:44:17 <Aska`Tokyo> yitz: yes
05:44:51 <sclv> I assume you're using -O2 (sorry, just checking).
05:45:10 <mmorrow> roderyk: hmatrix binds to LAPACK, gsl, and various custom C-code
05:45:21 <roderyk> sclv: yes (all suggestions welcome... I'm sure I'm missing something silly)
05:45:30 <yitz> Aska`Tokyo: ok, good luck. let us know how it goes.
05:46:59 <Aska`Tokyo> yitz: no worry, I will, I want to finish this tonight ^^
05:47:03 <roderyk> mmorrow: I will go skim the hmatrix tutorial.  I realize the algorithm needs more work (spatial trees, etc.) but there will also be more rays casted in the final version... so I was hoping for much better performance from this skeleton
05:47:17 <sclv> i've found increasing unfolding can help as well, to help more optimizations fire. outside of that, not sure, besides trying something like hmatrix which has bindings and mutation under the covers, or introducing your own mutation.
05:47:26 <yitz> Aska`Tokyo: ok.
05:48:00 <roderyk> sclv: thanks for the pointers, I'll be sure to speak up when I figure something out. And I'm sure I'll be back with more questions ;-)
05:48:01 <sclv> and yeah, moving from tuples to unpacked types.
05:49:59 <SamB> roderyk: no, no, the pointers are in Foreign.Ptr!
05:50:19 <inbuninbu> is anyone very familiar with Data.Vec?
05:51:14 <SamB> @google "Data.Vec"
05:51:15 <lambdabot> http://www.vec.virginia.gov/vecportal/about_vec.cfm
05:51:15 <lambdabot> Title: About the VEC
05:51:22 <SamB> @google "Data.Vec" hackage
05:51:23 <lambdabot> http://hackage.haskell.org/packages/archive/Vec/0.9.5/doc/html/Data-Vec.html
05:51:23 <lambdabot> Title: Data.Vec
05:51:59 <SamB> inbuninbu: what about it?
05:53:12 <SamB> inbuninbu: it looks heavily haddocked
05:53:19 <inbuninbu> i've taken a look at the api, and some of the source, but i can't seem to find a way to do scalar multiplication on a vector; i'm guessing there's some function that maps a function to each element of the vector, but i'm having trouble figuring out which it is
05:53:37 <roderyk> There will come a day when googling "hayoo" actually points to hayoo and not yahoo....
05:54:13 <inbuninbu> and i'm not good enough at grokking type signatures yet to figure it out just from that
05:55:04 <Axman6> inbuninbu: what sorts of things do you want to do?
05:55:35 <SamB> Axman6: he wants to do a scalar multiply on a vector
05:55:47 <SamB> that is, multiply all the components by the same thing
05:55:56 <SamB> there really SHOULD be a function for it ...
05:55:59 <Axman6> well, i was windering what other tasks, because i think there's better modules for that
05:56:19 <Saizan> Data.Vec.Base.map
05:56:23 <inbuninbu> well i'm going to need to invert matrices
05:56:30 <inbuninbu> (later)
05:56:54 <Saizan> inbuninbu: looked here? http://hackage.haskell.org/packages/archive/Vec/0.9.5/doc/html/Data-Vec-Base.html
05:57:02 <roderyk> inbuninbu: looks like Data.Vec is implemented as lists, intended for functions like map, zipWith...
05:57:07 <Axman6> might find hmatrix better for that
05:57:13 <mmorrow> inbuninbu: it looks like  "Data.Vec.Base.map (*c) vec" would do it
05:57:24 <SamB> you'd expect there to be a scalar multiply convenience function, though!
05:57:39 <inbuninbu> SamB: ....yeah, that threw me off
05:57:45 <inbuninbu> but map works
05:57:45 <inbuninbu> *Main> V.map ((*) 3) x
05:57:46 <inbuninbu> (9):.(6):.(3):.()
05:57:57 <mmorrow> (on account of Vec* a being an instance of Map (since Vec* a is just a (a :. (a :. (..... :. a))))
05:59:30 <mmorrow> (( and (a :. a) is an instance of Map ))
05:59:44 <Saizan> using GADTs you'd need less classes for such operations
06:00:03 <mmorrow> yeah, i've begun to really like GADTs
06:00:31 <inbuninbu> anway, thanks! Axman6++ Saizan++ SamB++ mmorrow++
06:00:38 <Axman6> heh
06:00:41 <Axman6> @karma
06:00:42 <lambdabot> You have a karma of 6
06:00:49 <SamB> @karma
06:00:49 <mmorrow> especially great is that they can remember the class context for different constructor enabling you to not have to write the contexts all over your functions
06:00:49 <lambdabot> You have a karma of 2
06:00:49 <Axman6> whoot, she remembered!
06:00:55 <SamB> huh
06:01:09 <SamB> I really wish I'd actually said "I bet mine is 2" before doing that
06:01:16 <Peaker> @karma
06:01:16 <lambdabot> You have a karma of 0
06:01:28 <SamB> I've had a good deal higher than that
06:01:42 <alexeevg> @karma
06:01:42 <lambdabot> You have a karma of 1
06:02:28 <Saizan> mmorrow: you can have that without gadts
06:03:35 <Peaker> sshfs really really sucks :P
06:03:44 <SamB> Saizan: well, I think you need to use a GADT-style definition at least
06:03:45 <Peaker> Does Haskell have fuse bindings?
06:03:58 <Lemmih> Peaker: Yes.
06:04:11 <Peaker> Lemmih: Then I think I'll rewrite sshfs with Haskell
06:04:11 <Saizan> SamB: data Foo a = forall a. Bar a => Bar a, suffices
06:04:23 <Peaker> Lemmih: it can
06:04:25 <SamB> Peaker: can't you use google ?
06:04:27 <Peaker> 't possibly have to be this slow
06:04:33 <SamB> @google fuse hackage
06:04:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HFuse
06:04:34 <lambdabot> Title: HackageDB: HFuse-0.2.1
06:04:45 <Axman6> Peaker: could always use -C :)
06:04:48 <Peaker> SamB: Sorry :)
06:05:45 <Peaker> SamB: you could direct me to: http://tinyurl.com/cd29p7
06:06:17 <jpcooper> could anyone recommend a good visual diff viewer?
06:07:05 <SamB> that's even better than justfuckinggoogleit.com
06:07:25 <Peaker> SamB: its far better :)
06:07:28 <ehird> yes, it is
06:07:43 <SamB> jpcooper: visual how ?
06:07:59 <ehird> http://live.lmgtfy.com/
06:08:19 <jpcooper> yeah, I googled it
06:08:31 <jpcooper> meld
06:08:56 <Axman6> jpcooper: what OS?
06:09:04 <jpcooper> Linux
06:09:07 <jpcooper> I'm going to try meld
06:09:12 <Axman6> bah, no then
06:09:43 <SamB> jpcooper: that "let me google it for you" wasn't for you ;-)
06:09:55 <SamB> yours sounds like a question too complicated for google
06:10:13 <jpcooper> yes okay we get that it would have been better for me to have googled it first
06:10:37 <jpcooper> I thought that maybe something that a few people could agree on might be good
06:10:43 <Axman6> jpcooper: the google stuff wasn't for you
06:10:53 <jpcooper> right
06:11:05 <SamB> jpcooper: what did you mean by "visual diff viewer"?
06:11:17 <SamB> did you mean you want to see the two files side by side or top-to-bottom
06:11:23 <SamB> with changes highlighted ?
06:11:23 <jpcooper> there  was a nice tool on Mac OSX
06:11:28 <jpcooper> side by side
06:11:33 <jpcooper> I think it was in its developer tools
06:11:45 <Axman6> yeah, File Marge
06:11:52 <Axman6> excellent diff tool
06:11:53 <SamB> @go "File Marge"
06:11:53 <lambdabot> No Result Found.
06:11:54 <jpcooper> I'd like to be able to use one of these things with git status
06:12:07 <Axman6> @go file merge OS x
06:12:08 <lambdabot> No Result Found.
06:12:21 <doserj> meld is fine
06:12:33 <jpcooper> doserj, know how to use it with git diff?
06:12:36 <ehird> file merge is great
06:12:40 <jpcooper> (I meant git diff)
06:12:45 <SamB> you mean the name isn't really "file marge"
06:12:46 <lilac> jpcooper: iirc kdiff3 is pretty good
06:13:03 <doserj> jpcooper: never used git :)
06:13:15 <lilac> or possibly i mean kompare?
06:13:30 <jpcooper> maybe to get meld to takes its output
06:13:58 <jpcooper> once again, google yields results
06:14:01 <SamB> try git diff | meld - ?
06:14:16 <Axman6> http://michaelgalloy.com/wp-content/uploads/2008/01/opendiff-screenshot.png <-- filemerge.app
06:15:13 <jpcooper> Axman6, if only I could justify buying a mac to myself :)
06:15:15 <Axman6> the nicest thing is you can click the diff in the middle column, and use the arrow keys to move to the next/orev diff, and left/right to select which side you want
06:15:32 <SamB> oh, that IS nice looking
06:15:36 <SamB> http://the.taoofmac.com/space/apps/FileMerge
06:15:54 <Axman6> jpcooper: well it'll run anything you want, comes with a great OS, and you get great hardware :)
06:16:02 <Axman6> justified!
06:16:09 <SamB> meld DOES look like a decent clone
06:16:14 <Axman6> stmi: heh, those are old pics, it looks better now :P
06:16:25 <SamB> well, almost
06:16:29 <Axman6> uh, SamB, not stmi
06:16:35 <jpcooper> Axman6, I know! I used them over summer. It's just that I still have a working T60 :)
06:16:53 <Axman6> that's that small thinkpad right?
06:17:01 <jpcooper> a pleasure to work on
06:17:02 <Axman6> if it is, i wants it so bad
06:17:04 <jpcooper> mid-size
06:17:12 <jpcooper> the small ones are the X series
06:17:23 <arw> T60 is 15" iirc.
06:17:25 <SamB> Axman6: which, FileMerge or meld ? I'm hoping you mean meld ?
06:17:30 <SamB> and I expect it is better now
06:17:39 <Axman6> SamB: File Merge
06:17:49 <Axman6> jpcooper: i hate you :(
06:17:50 <SamB> what was wrong with that one ?
06:18:05 <SamB> anyway, that was the first pic I could find
06:18:21 <Axman6> i love my MBP, but i also thinkpads. compared to all the dell and HP shiny bullshit out there, they're beautiful
06:18:21 <jpcooper> arw, and 14.1". I have this one
06:18:56 <jpcooper> it's hell to code on such a small screen at 1024x768. I can't wait to get some money for a large wide screen
06:19:04 <SamB> now, obviously the NeXT picture is kinda old
06:19:09 <jpcooper> but I love the nipple
06:19:14 <Axman6> SamB: well the other one is pretty old too
06:19:19 <SamB> but I don't really see an issue with either the NeXT or the OS X picture, they both look way cool
06:19:23 <Axman6> jpcooper: clit mouse?
06:19:35 <jpcooper> yep
06:20:48 <jpcooper> @hoogle arg
06:20:48 <lambdabot> System.Console.GetOpt data ArgDescr a
06:20:48 <lambdabot> System.Console.GetOpt data ArgOrder a
06:20:48 <lambdabot> Distribution.Simple.Command type ArgPlaceHolder = String
06:20:57 <jpcooper> @hoogle getArgs
06:20:58 <lambdabot> System.Environment getArgs :: IO [String]
06:21:14 <Axman6> SamB: you know, File Merge is almost worth buying a mac for in itself. they've just got it so damn right
06:21:26 <Axman6> maybe not, but still, it's so well designed
06:21:45 <FunctorSalad_> Baughn: what?
06:21:55 <SamB> Axman6: so where can I see a more recent picture ?
06:22:04 <Axman6> i'll upload one soon if you like
06:22:36 <roderyk> is it just me, or is hmatrix missing a cross product?
06:23:49 <SamB> hmm, the hackage entry should have a link directly to the Index page for a package
06:24:03 <SamB> since, you know, it serves as the Contents page
06:27:18 <Axman6> SamB: http://axman6.homeip.net/images/FileMarge.png
06:27:23 <Axman6> might take a while to download
06:28:03 <SamB> not really
06:28:13 <SamB> it's not that complicated a png
06:28:50 <SamB> it is, after all, mostly white :-P
06:28:59 <Axman6> heh, yeah
06:29:37 <SamB> hmm, the orange bits look a bit jarring
06:30:17 <SamB> around newlines in particular
06:30:23 <Axman6> yeah, i just changed the colour, trying to find something better than what i had
06:30:51 <SamB> it's not that it's orange so much as that it extends to the beginning or end of the line
06:31:16 <SamB> possibly the fact that it's the background doesn't help either
06:31:34 <SamB> but at least the code isn't also syntax highlighted ;-)
06:35:00 <hynek> ehm i'm a bit wondering...."Text.Regex.Posix"  does understand "\w" but doesn't "\d"? Is there some replacement for \d? I need it quiet often and [0-9] is a bit cumbersome...
06:43:19 <redditbot> Hieroglyph HOWTO Part 1: Functional 2D drawing using Cairo.
06:43:48 <Peaker> Lemmih: you there? Do you see a problem with unsafePerformIO'ing away the font size computation functions?
06:52:32 <Lemmih> Peaker: In what context?
06:52:52 <Peaker> Lemmih: I want a pure   Font -> String -> Size  function
06:53:24 <Peaker> Lemmih: but Graphics.UI.SDL.TTF.tryTextSize is in both Maybe and IO
06:56:48 <bastl> i have a degenerated tree which is essentially a list. every node with label "(:)" should disappear, and the children moved one level higher. This seems to be a kind of fold, but i never did that and have difficulties in understanding whats going on there ...
06:58:01 <Lemmih> Peaker: It should be safe. None of those attributes should vary.
06:58:12 <Peaker> Lemmih: great, thanks!
06:58:41 <lilac> bastl: what's your tree data type look like?
06:58:52 <bastl> Data.Tree String
06:59:12 <lilac> @src Data.Tree.Tree
06:59:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:59:53 <bastl> (:) is the list constructor, but i want a "virtual" constructor that looks like "List elm1 elm2 elm3 ...", where elm1-n is the list of children of constructor "List"
07:00:17 <bastl> @src Data.Tree Node
07:00:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:00:26 <bastl> @src Data.Tree.Node
07:00:27 <lambdabot> Source not found. My brain just exploded
07:00:37 <Cale> @src only has certain things in it
07:00:37 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:00:44 <bastl> :-)
07:01:06 <Cale> data Tree a = Node {rootLabel :: a, subForest :: Forest a}
07:01:18 <Cale> type Forest a = [Tree a]
07:02:14 <Peaker> I dislike the   Forest a   type
07:02:24 <Peaker> [Tree a] is shorter and more informative
07:02:33 <bastl> true.
07:02:46 <lilac> so you want "children (Tree "(:)" xs) = xs >>= children; children a = a; flatten (Tree a xs) = Tree a (flatten <$> children xs)
07:03:19 <bastl> what the heck !? to many operators i dont know. So: perhaps :-)
07:03:46 <kyagrd> Hi guys, is there a library for type level lists in Haskell (of course with lost of GHC extensions)?
07:03:48 <Peaker> bastl: there's only >>= and <$> in there, Monad bind and Functor fmap
07:03:59 <Peaker> kyagrd: HList
07:04:02 <lilac> bastl: (<$>) = fmap
07:04:04 <Workybob> @hoogle (<<)
07:04:04 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => Html -> b -> a -> b
07:04:04 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => Html -> b -> a -> b
07:04:04 <lambdabot> Text.XHtml.Transitional (<<) :: HTML a => Html -> b -> a -> b
07:04:12 <lilac> bastl: in this case, fmap = map
07:04:22 <lilac> so flatten (Tree a xs) = Tree a (map flatten (children xs))
07:04:46 <kyagrd> Isn't HList heterogenious lists for values?
07:05:18 <bastl> lilac: what is the semicolon then?
07:05:36 <lilac> bastl: that's just a separator (think of it as a newline)
07:06:02 <bastl> ah
07:06:23 <lilac> bastl: haskell lets you use {, } and ; instead of whitespace if you want
07:06:41 <Peaker> kyagrd: yeah, with type-level indexing, and type-level list operations. I thought that's what you meant. I don't think you can have an actual list of types
07:07:04 <bastl> what does xs >>=children do? Until now i only used monadic io. never used the "Tree monad" !?
07:07:13 <lilac> bastl: that's the list monad
07:07:19 <lilac> bastl: so it's concatMap
07:07:31 <Cale> It's funny how people seem to worry about operator symbols that they don't know more than they do about other library functions they don't know :)
07:08:02 <lilac> bastl: basically, when you see 'Tree "(:)" xs', you take the xs, run 'children' on each one, then concat the results
07:08:40 <kyagrd> hmm I just want to use that index thing :*: thanks, might be possible
07:11:13 <bastl> lilac: sorry, phone call. so >>= means in the list monad "concatMap". got that. thanks for now
07:14:11 <lilac> bastl: yep. "xs >>= f = concat (map f xs)" in the list monad.
07:14:57 <bastl> cool, my first attempt at monadic programming :-)
07:17:55 <bastl> lilac: what is the type of the children function !?
07:19:22 <lilac> children :: Tree String -> [Tree String]
07:20:31 <bastl> then it should be children a = [a], i guess... ok.
07:20:33 <lilac> children (Tree "(:)" xs) = xs >>= children; children a = [a]; flatten (Tree a xs) = Tree a (flatten <$> children =<< xs)
07:20:45 <lilac> bastl: yep. sorry about that :)
07:24:03 * lilac notes the constructor is called Node and not Tree, and that <$> is higher precedence than =<<. alas
07:24:18 <mmorrow> @type subForest
07:24:19 <lambdabot> forall a. Tree a -> Forest a
07:24:27 <mmorrow> @src Forest
07:24:28 <lambdabot> Source not found. You type like i drive.
07:24:32 <mmorrow> , src ''Forest
07:24:36 <lunabot>  type Forest a = [Tree a]
07:24:52 <mmorrow> , src ''Tree
07:24:54 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
07:25:15 <bastl> @src <$>
07:25:15 <lambdabot> f <$> a = fmap f a
07:25:25 <bastl> @type fmap
07:25:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:26:21 <mmorrow> @type let f = flip splitAt [0..9] in f
07:26:22 <lambdabot> forall a. (Enum a, Num a) => Int -> ([a], [a])
07:27:17 <edwardk> I have yet to really get used to typing <$> rather than just saying `fmap`
07:28:21 <mmorrow> yeah, i like fmap myself (this might have something to do with how i'm not a huge fan of ops <_> w/ _ = whatever)
07:28:28 <Peaker> I think Haskell needs a consistent/thought-out scheme to name operators so that you easily figure out from the operator name which arg is wrapped and which is pure, etc
07:28:31 <mmorrow> but i love (<>)
07:28:39 <Peaker> @type (<>)
07:28:40 <lambdabot> Doc -> Doc -> Doc
07:28:48 <mmorrow> i mean when i define it myself
07:28:52 <bastl> lilac: i got it nearly running now, but thats not what i wanted :-/. it removes the (:) but doesnt lift the children up one level ...
07:29:08 <lilac> bastl: how do you mean?
07:29:21 <mmorrow> , let foo (<>) f g = \x -> f x <> g x in foo in foo (,) (*2) show 43
07:29:21 <edwardk> i mostly just try to avoid introducing operators. names tell the person how to read the code outloud
07:29:22 <lunabot>  luna: parse error on input `in'
07:29:28 <mmorrow> , let foo (<>) f g = \x -> f x <> g x in foo (,) (*2) show 43
07:29:29 <lunabot>  (86,"43")
07:29:50 <bastl> the children of (:) should be moved one level higher ...
07:30:10 <lilac> bastl: if the (:) is removed, then the children will be one level higher, no?
07:30:18 <mmorrow> @src []
07:30:18 <lambdabot> data [] a = [] | a : [a]
07:30:25 <lilac> flatten (Node "x" [Node "(:)" [Node "y" []]])
07:30:33 <lilac> -> Node {rootLabel = "x", subForest = [Node {rootLabel = "y", subForest = []}]}
07:30:39 <bastl> right, sorry
07:30:50 <lilac> do you want the children two levels higher?
07:31:47 <mmorrow> , let listToForest [] = []; listToForest (x:xs) = [Node x (listToForest xs)] in text . drawForest . (fmap . fmap) show $ listToForest [0..3]
07:31:48 <lunabot>  0
07:31:48 <lunabot>  |
07:31:48 <lunabot>  `- 1
07:32:06 <mmorrow> a list is basically just a boring tree :)
07:32:18 <bastl> imagine the trees for list-constructors: (a:(b:c:[])). I want convert that to (Node "List" [a,b,c])
07:32:32 <lilac> , let children (Node "(:)" xs) = xs >>= children; children a = [a]; flatten (Node a xs) = Node a (flatten <$> (children =<< xs)) in flatten (Node "x" [Node "(:)" [Node "y" []]])
07:32:33 <lunabot>  Node {rootLabel = "x", subForest = [Node {rootLabel = "y", subForest = []}]}
07:33:21 <lilac> bastl: hmm, that's not the same thing at all :)
07:33:24 <mmorrow> @type let foo a = (typeOf a, a) in foo
07:33:25 <lambdabot> forall a. (Typeable a) => a -> (TypeRep, a)
07:33:34 <mmorrow> , let foo a = (typeOf a, a) in foo [0..4]
07:33:35 <lunabot>  ([Integer],[0,1,2,3,4])
07:33:53 <bastl> yeah, but the trees for lists constructed by ":" are ugly to read :-)
07:34:00 <mmorrow> , let foo a = (typeOf a, a) in foo [Node (Just (42,"")) []]
07:34:01 <lunabot>  ([Tree (Maybe (Integer,[Char]))],[Node {rootLabel = Just (42,""), subFore...
07:34:19 <mmorrow> just make a
07:34:34 <mmorrow> data T a = Tip | T (T a) (T a)
07:34:48 <mmorrow> then turn all applications into a "T"
07:34:53 <Axman6> that doesn't lool very useful...
07:34:58 <Axman6> look*
07:35:09 <Axman6> Tip a maybe?
07:36:20 <mmorrow> , foldl appE [|id|] (replicate 4 [|()|])
07:36:21 <lunabot>  AppE (AppE (AppE (AppE (VarE id) (ConE ())) (ConE ())) (ConE ())) (ConE ())
07:36:27 <mmorrow> , ppDoc `fmap` foldl appE [|id|] (replicate 4 [|()|])
07:36:28 <lunabot>  id () () () ()
07:36:32 <mmorrow> oops
07:36:55 <mmorrow> , ppDoc `fmap` foldr (|$|) [|()|] (replicate 4 [|id|])
07:36:57 <lunabot>  id (id (id (id ())))
07:37:42 <mmorrow> let go (e `AppE` e') = go e `T` go e'; go e = Tip e in go (unQ (foldr (|$|) [|()|] (replicate 4 [|id|])))
07:37:56 <mmorrow> , foldr (|$|) [|()|] (replicate 4 [|id|])
07:37:57 <lunabot>  AppE (VarE id) (AppE (VarE id) (AppE (VarE id) (AppE (VarE id) (ConE ()))))
07:38:09 <mmorrow> ooh, there's actually a "T" in scope
07:38:13 <mmorrow> , let go (e `AppE` e') = go e `T` go e'; go e = Tip e in go (unQ (foldr (|$|) [|()|] (replicate 4 [|id|])))
07:38:14 <lunabot>  luna: Occurs check: cannot construct the infinite type: b = Luna.T.T a b
07:38:17 <mmorrow> grr
07:38:36 <lilac> , let evalList (Node "(:)" [a,b]) = a:children b; evalList (Node "[]" []) = []; flatten a@(Node "(:)" _) = Node "List" (flatten <$> eval a); flatten (Node s xs) = Node s (flatten <$> xs) in flatten (Node "(:)" [Node "a" [], Node "(:)" [Node "[]" []]])
07:38:38 <lunabot>  luna: Not in scope: `children'
07:38:47 <mmorrow> oh, it's the wrong T
07:38:50 <lilac> , let evalList (Node "(:)" [a,b]) = a:evalList b; evalList (Node "[]" []) = []; flatten a@(Node "(:)" _) = Node "List" (flatten <$> eval a); flatten (Node s xs) = Node s (flatten <$> xs) in flatten (Node "(:)" [Node "a" [], Node "(:)" [Node "[]" []]])
07:38:52 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
07:39:01 <mmorrow> , foldr (|$|) [|()|] (replicate 4 [|id|])
07:39:02 <lunabot>  AppE (VarE id) (AppE (VarE id) (AppE (VarE id) (AppE (VarE id) (ConE ()))))
07:39:05 <mmorrow> ==>
07:39:25 <mmorrow> (id `T` (id `T` .... (Tip ()))))
07:39:59 <mmorrow> so that `go' would turn the expression AST into a (binary) tree, making the tree structure of it explicit
07:40:21 <mmorrow> T <==> [|($)|]
07:40:38 <mmorrow> well, literally   T <==> AppE
07:41:08 <mmorrow> , parseExp "f x"
07:41:10 <lunabot>  Right (AppE (VarE f) (VarE x))
07:41:25 <bastl> mmorrow: i use http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB for expecit ASTs
07:41:35 <bastl> s/expecit/explicit
07:41:41 <lilac> , let evalList (Node "(:)" [a,b]) = a:evalList b; evalList (Node "[]" []) = []; flatten a@(Node "(:)" _) = Node "List" (flatten <$> evalList a); flatten (Node s xs) = Node s (flatten <$> xs) in text . drawTree $ flatten (Node "(:)" [Node "a" [], Node "(:)" [Node "b" [], Node "[]" []]])
07:41:43 <lunabot>  List
07:41:43 <lunabot>  |
07:41:43 <lunabot>  +- a
07:42:41 <mmorrow> bastl: `everywhere' + `mkT' are nice for non-context-sensitive manipulations
07:43:05 <bastl> mmorrow: http://www.cs.vu.nl/boilerplate/testsuite/tree/Main.hs
07:43:33 <bastl> sorry, i just want to use it. i dont understand how these things are made internally ...
07:44:34 <mmorrow> essentially it's just playing off the fact that every datatype in haskell has the same structure
07:45:18 <Saizan> the papers are a very nice read
07:45:22 <mmorrow> data TyCon = TyCon Name [DataCon]
07:45:41 <mmorrow> data DataCon = DataCon Name [TyCon]
07:45:48 <mmorrow> err, extend TyCon with
07:46:09 <mmorrow> data Type = Var Name | TyCon Name [DataCon]
07:46:15 <mmorrow> data DataCon = DataCon Name [Type]
07:47:10 <lupsyn> excuse me why it gives me this error ?     Probable fix: give these definition(s) an explicit type signature
07:47:10 <lupsyn> 		  or use -fno-monomorphism-restriction
07:47:10 <lupsyn>  
07:47:10 <mmorrow> the syb library then just uses the Typeable class to get the corresponding tree for a type, and then the Data class to walk it
07:47:15 <lupsyn> in dia Void = (-1,-1)
07:47:15 <lupsyn> dia (Node _ l r) = (dr `max` dl `max` 2 + hl +hr,1 max hl hr  )
07:47:15 <lupsyn> 	where
07:47:17 <lupsyn> 			(dl,hl) = dia l
07:47:19 <lupsyn> 			(dr,hr) = dia r
07:47:21 <lupsyn> ?
07:48:26 <mmorrow> it can't figure out what type it's supposed to be, so it needs help by you giving an explicit type signature
07:48:55 <mmorrow> (or you can do at the top of your file  {-# LANGUAGE NoMonomorphismRestriction #-}
07:48:57 <mmorrow> )
08:01:44 <roderyk> now, if I understand correctly newtype goes away at compile time, correct? So newtype Vect = Vect Vector Double, just turns into Vector Double everywhere?
08:02:32 <Saizan> roderyk: yes
08:02:42 <Saizan> assuming Vect (Vector Double)
08:03:49 <roderyk> sclv: mmorrow: I converted my primitive datatypes to use the hmatrix Vectors... and the performance is horrendous! (I'm shocked :)) I must have done something seriously wrong, essentially all the time is spent on running hmatrix internals (eg. multiplyAux)
08:07:37 <mstr> is there a standard function to get the "tail" of a list starting from k:th item?
08:08:05 <Saizan> ?type splitAt
08:08:06 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:08:07 <roderyk> I'm going to have to track it down, there's got to be a major bug for this slowdown... One thing I was struggling with is eg. something like this:  let [a0, a1, a2] = toList v1  in Vector (do some math)
08:08:16 <Saizan> > splitAt 5 [1..10]
08:08:17 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
08:08:44 <roderyk> so basically, what is the correct way to deconstruct/construct the hmatrix vectors?
08:08:46 <mstr> ty
08:12:43 <mstr> > let sl x k = x !! k-1 : (init list1) ++ list2 where (list1, list2) = splitAt k x
08:12:43 <lambdabot>   <no location info>: parse error on input `;'
08:13:11 <mstr> > let sl x k = x !! k-1 : (init list1) ++ list2 where (list1, list2) = splitAt k x
08:13:12 <lambdabot>   <no location info>: parse error on input `;'
08:13:17 <mstr> ; ?
08:13:47 <Axman6> mstr: you need to use lef f = ... in f z
08:13:53 <Axman6> let*
08:14:13 <mstr> > let sl x k = x !! k-1 : (init list1) ++ list2 where (list1, list2) = splitAt k x in sl [1..10] 4
08:14:14 <lambdabot>   [4,1,2,3,5,6,7,8,9,10]
08:15:00 <mstr> \o/
08:15:37 <lilac> mstr: for what it's worth, i don't think knuth's list randomization method is very good on singly-linked lists :(
08:16:16 <mstr> lilac: no worries. it's just a school exercise ;P
08:16:56 * lilac wonders if there's a neat linear-time list shuffling method which doesn't go via an array
08:17:05 <Peaker> conal: pong
08:24:20 <mightybyte> Could someone explain "combine :: (Applicative f, Monad m, Monoid a1, Applicative f1) =>
08:24:20 <mightybyte>            (t -> m (f (a -> b)), f1 a1, FormContentType)
08:24:20 <mightybyte>            -> (t -> m (f a), f1 a1, FormContentType)
08:24:20 <mightybyte>            -> (t -> m (f b), f1 a1, FormContentType)
08:24:26 <mightybyte> Oops, sorry about that.
08:24:42 <mightybyte> Could someone explain "instance Applicative ((->) a) where
08:24:47 <mightybyte> ...in English?
08:25:09 <Cheshire> you can read ((->) a) as (a -> _)
08:25:11 <mightybyte> I've tried to understand it by doing :t ((->) a) in ghci, but that gives an error
08:25:17 <Cheshire> :k ((->) a)
08:25:18 <lambdabot> Not in scope: type variable `a'
08:25:23 <Cheshire> hmf..
08:25:26 <idnar> :k ((->) ?)
08:25:26 <lambdabot> parse error on input `)'
08:25:27 <Cheshire> :k ((->) ())
08:25:28 <lambdabot> ? -> *
08:25:34 <idnar> oops
08:25:37 <Cheshire> since it is a type, it has a kind rather than a type
08:26:03 <mightybyte> Cheshire: Yeah, I understand that much.  This is obviously declaring something to be an instance of Applicative.
08:26:24 <mightybyte> Ahhh
08:26:28 <Cheshire> it's polymorphic over a,
08:26:38 <Cheshire> so any type starting with anything, is an applicative
08:26:39 <edbond> how do I get ceiling of sqrt of integer?
08:26:48 <idnar> ((->) a) is a type constructor for functions from a to something
08:27:06 <mightybyte> So this is declaring all functions of a single argument to be an instance of Applicative?
08:27:22 <doserj> @quote fromIntegral
08:27:22 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
08:27:45 <idnar> mightybyte: yes. also note that all Haskell functions are, in fact, functions of a single argument
08:27:46 <doserj> edball: ^^^
08:27:54 <mightybyte> idnar: Yes, I realize that.
08:28:11 <mightybyte> Cheshire: I don't understand the difference between a type and a kind.
08:28:21 <idnar> mightybyte: values have types, types have kinds
08:28:38 <mightybyte> Oh, ok.
08:29:13 <mightybyte> idnar: Is there a more in-depth tutorial on kinds somewhere?
08:29:31 <rwbarton> More precisely, type constructors have kinds.  Types all have kind * (in Haskell 98 at least).
08:29:54 <rwbarton> mightybyte: There is a section on kinds in the Haskell report.
08:30:31 <mightybyte> rwbarton: Ok.
08:30:36 <doserj> mightybyte: there is not much to it. It basically just counts how many arguments a type-constructor needs to be fully applied
08:30:51 <Cale> (and what kinds they have)
08:31:02 <Cale> :k StateT
08:31:03 <lambdabot> * -> (* -> *) -> * -> *
08:31:10 <idnar> fun with * # ? ??
08:31:23 <Cale> For unboxed types, there are some other kinds.
08:31:37 <Cale> (If you care about unboxed types)
08:31:37 <mightybyte> doserj: Oh, so anything without a type argument has kind *?
08:31:47 <Cale> mightybyte: right
08:32:16 <conal> Peaker: nm.  i passed my comments on to you via email.
08:32:16 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
08:32:32 <mightybyte> So is the following analogy accurate?
08:32:39 <conal> ping jeffersonheard
08:32:53 <mightybyte> Kinds : Type constructors as types : functions?
08:32:55 <jeffersonheard> hey conal
08:32:58 <Peaker> conal: Ah, was wondering if you had an answer for the implementation problem. But I guess eventually the answer is to just unsafePerformIO the IO away
08:33:07 <jeffersonheard> won't be here long
08:33:34 <conal> jeffersonheard: hi.  thanks for the ack in http://vis.renci.org/jeff/?p=112 . would you please add a second "t" to my last name ("Elliott")?
08:33:44 <jeffersonheard> Gah.  Of course
08:33:47 <jeffersonheard> darn typo
08:34:00 <conal> jeffersonheard: thx :)
08:34:16 <maltem> mightybyte: yeah that's right
08:34:19 <jeffersonheard> that one shouldn't be published yet, though
08:34:21 <jeffersonheard> I'm still editing it
08:34:26 <jeffersonheard> darn wordpress
08:35:13 <Saizan> mightybyte: though the whole thing is that  values : types  as  types : kinds
08:35:18 <Cale> mightybyte: Or types : values
08:35:19 <Peaker> conal: Did it annoy you that I directed the implementation question to you?
08:35:25 <conal> Peaker: we could answer that implementation question, but for me it's a distraction from shifting from implementation to semantic thinking.
08:35:47 <mightybyte> Cale: Right
08:35:59 <conal> Peaker: no, not annoyed.  a bit disappointed.
08:36:42 <Cale> mightybyte: In the future, Haskell will probably develop a more serious system of kinds, as a number of other research functional languages have.
08:36:49 <mightybyte> Saizan: Yeah, I get the values : types part, but the types : kinds is clearer to me when stated "type constructors : kinds".  Probably just some obscure artifact of my mental model.
08:36:52 <D_Traka> http://www.myspace.com/tetrapakbeats
08:36:58 <Peaker> conal: I understand the "semantic thinking" idea, but its not worthwhile if its not actually implementable in practice. :-) Of course it is, but there are difficulties that have probably arised for others who have taken this approach before
08:37:04 <mightybyte> Cale: Ahhh, interesting.
08:37:11 <Cale> mightybyte: Those who are doing type level programming have the misfortune of programming in what is almost an untyped language at the moment.
08:37:22 <Peaker> conal: So I was hoping that this implementation difficulty already had a clear answer from previous attempts, that's all
08:37:31 <mightybyte> Cale: Yeah, I can see that.
08:37:42 <Cheshire> hi Cale
08:37:47 <Cale> hello Cheshire
08:37:51 <mightybyte> What is type lever programming being used for?
08:38:01 <mightybyte> s/lever/level/
08:38:11 <Cheshire> I was playing with modalities a bit for something and I found it's monadic
08:38:21 <conal> Peaker: yes, the implementation question has an answer.
08:39:08 <jeffersonheard> There, fixed, and I went ahead and published it since people seemed to already be looking at it
08:39:14 <maltem> mightybyte: for example one might want a type for an array of a specified length
08:39:20 <Peaker> conal: Would it help if I /nick PeakerImpl when I distract you with implementation difficulties? :-)
08:39:21 <Cale> mightybyte: Well, it's sufficiently awkward at the moment that most of the real type-level hackery is somewhat experimental. You'll be interested to see HList, a library for typed heterogeneous lists and various operations on those
08:39:41 <mightybyte> Cale: Ahhhh
08:39:44 <conal> Peaker: no, but thanks.
08:39:58 <Cale> In fact the paper describing HList is a pretty good intro to type level programming in Haskell.
08:40:18 <mightybyte> Cale: Yeah, just looking at it.
08:40:20 <Cale> Though, I'd perhaps like to see the translation to using type families.
08:40:42 <Cale> (It uses multiparameter typeclasses and functional dependencies to encode type-level functions)
08:40:47 <asgaroth> The Monad.Reader issue which solves some logic puzzle in the type system is also interesting
08:40:58 <Peaker> conal: well, anyhow, thanks for the suggestions so far. Hope I haven't made you lose all interest for advice in the future
08:41:32 <maltem> oh, looks like "type-level programming" is used in a sense different from "doing fancy things with the type system"?
08:41:35 <conal> Peaker: these implementation problems *always* have solutions (unless you run up against theoretical non-computability).  that's why i don't want to get distracted with them.  it's easy to work on solving an implementation question that doesn't have a semantic foundation, and so is wasted effort.
08:41:48 <Cale> Cheshire: yes, monads can be viewed as particular modalities
08:42:07 <Cale> Cheshire: (as can comonads -- they're slightly different ones :)
08:42:31 <Peaker> conal: not only theoretical non-computability, also performance issues, existing library limitations, etc
08:42:43 <Cale> maltem: That's pretty much what I've been meaning by it.
08:43:20 <redditbot> Introducing Hieroglyph, 2D visualization in Haskell based on Cairo.
08:43:47 <newsham> why do we say "co-monad" but "wo-man"?
08:43:55 <Cheshire> I consider writing  data W m n o = Q ... | ...  is type level programming, data W :: (* -> *) -> * where Q :: ... -> ... even moreso
08:44:14 <conal> Peaker: sigh.  i think you're on a different path from mine for the time being.
08:44:45 <maltem> Cale: I was wondering because HList looks like it's evolved around Data.Typeable
08:45:24 <maltem> Cale: But actually, having further looks at the paper, things are revealed that look indeed like "doing fancy things with the type system" :)
08:46:19 <conal> wow -- http://www.goodnightbush.com/
08:47:47 <maltem> conal: doesn't smell like an FRP application really? :)
08:48:27 <Cale> Though the book with draggable pages might make a good FRP demo :)
08:48:44 <Peaker> conal: I appreciate your goals and method very much, but it seems reasonable to me that as my focus naturally shifted to the difficulties I encountered when implementing - on how to keep the semantics clean of abstraction leaks - the questions would also shift towards implementation issues - and when I get back to designing the next phase, the questions will shift to be about semantic design again.  I didn't know you would find questions regarding impleme
08:48:45 <Peaker> ntation so disappointing or worse, I will know to direct these questions elsewhere in the future
08:49:21 <wchogg> Eh, I didn't like the page flicking too much actually.  I would have thought it would be better if it had a real feeling of velocity & a quick mouse movement would have thrown the page to the other side.
08:49:27 <conal> Peaker: thanks.  the thing is i've developed a lot of trust in my semantic design process.  if you want to suspend disbelief and go with it for a while you might also develop that trust.  if not, i'd be putting effort into convincing you, which isn't worth it to me.
08:50:13 <Cale> wchogg: yeah, the way the pages fall back if you don't turn them far enough is a bit annoying
08:50:40 <Peaker> conal: I'm willing to accept it -- I am not sure what you suggest I do - do the design and not implement it at all?
08:51:17 <conal> Peaker: yes exactly.  followed by implementing it.
08:51:37 <Peaker> conal: well, I thought I already was in that second phase?
08:52:18 <conal> Peaker: oh.  that explains some of the disconnect.
09:01:33 <newsham> good night constitution and good night evolution.
09:03:08 <conal> newsham: :)
09:05:13 * maltem wonders if FRP could evolve into a suitable basis for automatic control systems
09:09:18 <wchogg> conal : You pointed me to the Fruit paper yesterday.  Are you still of the opinion that GUI objects are best represented as arrows?
09:10:34 <conal> wchogg: hm.  i don't know what it means to represent something as an arrow.  could we work on that question?
09:12:34 <conal> wchogg: i think there are at least two questions in there.
09:12:43 <wchogg> conal : Sorry.  I mean that in the paper you identify a GUI with a Signal Function, and let all of the compositional properties of a GUI follow directly from Arrows.  I just meant do you still feel like Arrows are the right "mathematical" primitive for the model.
09:12:52 <marcot> Hello, I'm trying to make a generic function to replace xmlGetWidget from gtk2hs.  The type is: http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Glade.html#v%3AxmlGetWidget
09:13:20 <marcot> WidgetClass widget => GladeXML -> (GObject -> widget) -> String -> IO widget
09:13:34 <marcot> I've made a class Cast to make this easier:
09:14:07 <conal> wchogg: oh.  thanks.  i think i get what you mean: we used not only the arrow *interface* but its *semantics* (laws) as well.  is that it?
09:14:26 <marcot> http://pastebin.com/m1d9cfc8f
09:14:31 <conal> wchogg: i was confused about what Arrow had to do with semantics.
09:15:14 <marcot> But when I try to use it in more than one object, it converts it to the same type, even when I explictly say it shouldn't, using PatternSignatures.
09:15:44 <wchogg> conal : Right.  That's what I meant.
09:16:30 <Saizan> marcot: can you give an example of that too?
09:16:35 <marcot> How can I make a really generic function.
09:16:41 <marcot> http://pastebin.com/d7dbb6c4e
09:17:36 <Cale> marcot: That error seems unrelated.
09:17:56 <Saizan> yeah
09:18:04 <Cale> marcot: Did you perhaps mean  onActivateLeaf edit $ ... ?
09:18:19 <marcot> Sure..
09:18:21 <marcot> Sorry. =)
09:18:24 <marcot> Thanks.
09:18:39 <marcot> Sometimes it's difficult to read what you wrote.
09:19:15 <conal> wchogg: those laws are applicable, which is nice.  other interfaces & laws are also.  so i of Arrow as useful and not central.
09:19:47 <conal> wchogg: i think of the semantics as central.
09:20:53 <conal> ksf: ping
09:25:24 <burp_> hi
09:26:04 <jgrimes> I'm trying to use cabal install -p to install/build profiling libs, but it is telling me that no more packages need to be installed. Ideas?
09:26:43 <maltem> jgrimes: use --reinstall
09:26:48 <burp_> someone using hmatrix here? (I know it's a meta question, but it makes no sense to ask my question if not)
09:27:14 <SamB_irssi> burp_: why, how long is your other question?
09:27:25 <burp_> well ok
09:27:28 <maltem> jgrimes: cabal fails to recognize you didn't install profiling libs if you do have installed non-profiling libs
09:27:37 <jgrimes> maltem, ah, thanks.
09:28:13 <burp_> I want to solve an integral with hmatrix (uses gsl), the integrand gets complex above its "exakt" range
09:28:28 <burp_> not the c version works with the "exact" range: http://paste.railsbox.eu/show/28/
09:28:34 <burp_> from xmin(9) to xmax(9)
09:28:43 <burp_> but not the haskell version which uses the same version:
09:28:47 <burp_> http://paste.railsbox.eu/show/29/
09:28:49 <dons> ?yow
09:28:49 <lambdabot> I'll eat ANYTHING that's BRIGHT BLUE!!
09:28:53 <burp_> (integrateQNG 1E-9 (integrand 9) ((xmin 9)+0.01) ((xmax 9)-0.01)) <- works
09:29:02 <burp_> (integrateQNG 1E-9 (integrand 9) ((xmin 9)+0.001) ((xmax 9)-0.001)) <- does not work
09:29:17 <burp_> I want to cirvumvent the complex behaviour with this addition of 0.001
09:29:37 <burp_> but well.. as far as I understood the hmatrix source everything is the same
09:30:21 <burp_> erm.. c works, haskell doesn't
09:30:33 <burp_> if that isn't clear from above ;)
09:30:43 <beelsebob> does anyone have any suggestion as to why this is installing into the wrong lib directory?
09:30:44 <beelsebob> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1162#a1162
09:30:58 <beelsebob> cleaned/reconfigured to no avail
09:30:58 <burp_> but call to gsl_integration_qags from haskell is the same
09:31:29 <beelsebob> it's not registering the package with ghc either
09:33:55 <burp_> so I think this is out of interest for someone who doesn't use hmatrix ;)
09:34:05 <Cale> burp_: I'll have a look at it.
09:34:30 <burp_> ok thanks, just launch my two examples (c,haskell)
09:35:43 <burp_> and in the haskell example adjust 0.01 to 0.001
09:37:00 <lilac> suppose someone you don't know or trust gives you some arbitrary haskell code containing a function :: Int -> Int. what would you need to check to ensure this code isn't going to 0wnz0r your machine?
09:37:31 <jgrimes> now... I'm trying to profile my program, and it creates a Main.prof, but it is empty. Are there constraints on what is profilable?
09:37:32 <Peaker> lilac: DOS is not pwnage, right?
09:38:12 <Peaker> lilac: because (let x = [0..] ; sum x) kind of DoS's a machine to death (at least without optimizations, surely you can thrash memory with optimizations on too)
09:39:13 <jkff> jgrimes: You should have compiled the program with -prof --auto-all (the latter is optional, but then you need {-# SCC "foo" #-} pragmas in source) and ran it with +RTS -p
09:39:15 <Peaker> lilac: For IO stuff, I guess you just need to make sure there's no unsafePerformIO, unsafeIOtoST or their derivatives
09:39:21 <Peaker> but I don't know if that's complete
09:39:53 <Cale> burp_: okay, I see you're getting an error from one of the numerical algorithms...
09:39:59 <burp_> yup
09:40:16 <burp_> which doesn't occur in the c-version, which is in my opinion the same
09:41:06 <Cale> In the C version you're not adding anything to xmin and xmax...
09:41:31 <burp_> yup, because it is not needed
09:41:57 <burp_> the integral gets complex for values lower xmin(9) and higher xmax(9)
09:42:08 <burp_> and I don't need to add something to the c-version
09:42:23 <jgrimes> jkff, I've compiled it with -prof and -auto-all. I also run it with +RTS -p
09:43:20 <redditbot> Ready for testing: Direct Unicode support for Handle I/O
09:43:37 <burp_> I suspect some rounding error, but can't locate it.. and I'm not sure
09:43:49 <jkff> jgrimes: Try compiling another program (like, Hello World) with the same options and see if it yields an empty .prof too
09:45:11 <burp_> if you have time and look into hmatrix/lib/Numeric/GSL/Integration.hs and gsl-aux.c
09:45:22 <burp_> you will see that the call is the same
09:45:33 <burp_> of gsl_integration_qags
09:45:47 <jgrimes> jkff, it gave the expected profiling results.
09:45:54 <roconnor> @seen conal
09:45:54 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 25m 1s ago.
09:45:55 <maltem> jgrimes: maybe you got fooled by --enable-executable-profiling vs. --enable-library-profiling
09:46:05 <jgrimes> maltem, hm. maybe
09:46:09 <conal> roconnor: hi
09:46:23 <Cale> burp_: hmm, it's calling integrate_qags from gsl-aux.h
09:46:35 <roconnor> conal: are you interested in the theory of constructive real numbers, or interested in approaches to implemenations?
09:46:48 <burp_> Cale, thats a wrapper that calls gsl_integration_qags
09:46:50 <burp_> in gsl-aux.c
09:47:10 <Cale> What is the wrapper doing?
09:47:23 <burp_> I can paste gsl-aux.c if you want
09:47:38 <Cale> I'll get it from the hmatrix package...
09:47:42 <burp_> http://paste.railsbox.eu/show/31/
09:47:43 <burp_> ok
09:49:05 <conal> roconnor: at this point, implementation approaches -- and enough of the theory to understand what the implementations are accomplishing and why they're correct.  in the process, i may get more interested in the theory.
09:49:06 <Cale> hmm, okay
09:49:13 <Cale> That does look pretty much the same.
09:49:30 <burp_> yup I think so too
09:50:43 <conal> Peaker: you have qualms about using unsafePerformIO in an implementation, right?  are you clear about why?  clarity will help in choosing when to and when not to.
09:50:59 <conal> Peaker: the answer might be to use safePerformIO.
09:51:16 <Peaker> conal: Well, I explained why I can't do that..
09:51:38 <conal> Peaker: you did? i might have missed it.
09:51:45 <L11> I have a problem for one of my classes - we have to compute the binary sum and product of a list of boolean values using no builtin arithmetic. Wouldn't it be necessary to have to lists to add? And how would I go about seeing if the values are 1 or 0 in haskell?
09:52:13 <conal> Peaker: did you you notice "safePerformIO", rather than "unsafePerformIO"?
09:52:19 <Cale> L11: Boolean values are represented by True and False in Haskell.
09:52:27 <beelsebob> L11: 1 and 0 aren't boolean values
09:52:34 <roconnor> conal: hmm,  Unfortunately I don't know of a good survey article. I can probably rattle off the major approaches, and might even be able to give you some references to them.
09:52:44 <Peaker> conal: by safePerformIO you meant just binding it normally, right?
09:52:59 <L11> ah alright, used to being able to use 1 and 0
09:53:11 <beelsebob> L11: data Bool = True | False
09:53:12 <Cale> L11: You could use Integers, but why? :)
09:53:14 <conal> Peaker: "binding it normally"??
09:53:23 <beelsebob> also, why does using Ints make it any easier?
09:53:30 <L11> Cale: just part of the assignment
09:53:35 <Cheshire> data Bit = I | O
09:53:46 <beelsebob> L11: the assignment specifies that they must be 1s and 0s?
09:53:48 <Peaker> conal: is there an actual function "safePerformIO"?
09:53:56 <Cale> L11: The basic boolean functions just use pattern matching:
09:53:59 <Cale> @src not
09:53:59 <lambdabot> not True   =  False
09:53:59 <lambdabot> not False  =  True
09:54:02 <L11> beelsebob: no just says boolean values.
09:54:06 <Cale> @src (&&)
09:54:06 <lambdabot> True  && x = x
09:54:06 <lambdabot> False && _ = False
09:54:40 <conal> Peaker: yes.  safePerformIO is unsafePerformIO on a restricted domain.
09:54:45 <L11> hm alright let me go tinker with this for a bit
09:54:47 <L11> thanks :)
09:55:07 <Peaker> conal: oh, sorry, I misunderstood what you meant.. I'm not familiar with that, where can I find information about it?
09:55:24 <roconnor> data Bit = O | I  ?
09:55:35 <paczesiowa> | FileNotFound
09:55:56 <conal> Peaker: you can ask me, for starters.  i don't have any other refs yet.
09:56:45 <Peaker> conal: ah, so by "restricted domain" do you mean just IO actions we can somehow know that are safe to perform in a pure computation?
09:57:04 <conal> Peaker: exactly :)
09:57:38 <Peaker> conal: But how can I know this about an action that is exported from a library like SDL? I mean, perhaps it is unsafe because it performs the operation over the network, for example?
09:58:02 <Cheshire> Why don't you use a Monad instead of unsafe operations?
09:58:12 <Peaker> conal: (Maybe it asks X, potentially over the network, to compute the size of the text with a particular font)
09:58:51 <conal> Peaker: yes!  replace "but" with "and", and you'll have the sort of questions I want you to be asking.
09:58:53 <Peaker> Cheshire: because I should be able to purely render fonts/get font text sizes without resorting to monads
09:59:10 <Cheshire> you say 'resort' like using monads is not desirable, but why not?
09:59:32 <lament> is there a reasonably cross-platform way to have a callback (or in the worst case to be able to poll) for key press / key release events?
09:59:36 <Peaker> conal: I think the relaxed answer is "check what SDL does now", but the strict answer is "It cannot be verified reliably"
09:59:49 <ddarius> Using monads is not desirable if there is a more applicative way, but there is no conflict between using monads and "purely rendering"
10:01:46 <conal> Peaker: (every time i hear/see a "but", i lose motivation.)
10:02:04 <Peaker> conal: Okay, I'll try to avoid using "but"
10:02:14 <conal> Peaker: do you know why?
10:02:23 <Peaker> conal: Not sure, no
10:03:36 <roconnor> @hackage hieroglyph
10:03:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hieroglyph
10:03:48 <Peaker> Cheshire, ddarius: Well, I really want the render types to be as simple as possible, i.e:  Font -> String -> (Image, Size)   --  and not something like: Font -> String -> SomeMonad (Image, Size)  -- because the latter is unnecessarily more complicated
10:03:52 <conal> Peaker: i hear "but" as a giving up on having the best of two things/viewpoints.  e.g., "semantics is great, but one has to be practical".  as if the two were in conflict.  the attitude becomes a self-fulfilling prophecy.
10:04:00 <roconnor> @hackage Hieroglyph
10:04:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Hieroglyph
10:04:20 <ddarius> Peaker: That's only true -if- it -is- "unnecessarily" more complicated.
10:04:42 <conal> Peaker: try on "and" in place of "but", and mean it.
10:04:53 <roconnor> I wonder if Hieroglyph compete with diagrams
10:04:55 <Peaker> conal: okay
10:05:05 <conal> Peaker: thx :)
10:05:16 <conal> Peaker: back to your comment about SDL.  you're missing an important semantic guarantee from your underlying implementation library.  right?
10:05:28 <Peaker> conal: Yep
10:05:39 <Cheshire> Peaker, "use of a Monad" does not mean that programs would be written in do notation and have Monad m => ... -> m ... in the type
10:05:58 <conal> Peaker: which is a defect in that library -- incomplete specification.
10:06:09 <int80_h> hi #haskell :)
10:07:13 <Peaker> Cheshire: Yeah, I know. I currently have a monad there, and I want to get rid of it :)
10:07:16 <conal> Peaker: it's a typical sort of defect.
10:07:21 <Peaker> conal: I agree
10:08:08 <Peaker> conal: I can't think of a reasonable way to violate the purity guarantee, except in throwing errors (allocation failures, or network errors if future versions go over a network)
10:08:17 <Peaker> conal: a reasonable way for SDL to violate it, I mean
10:08:21 <ddarius> Solution: Program to interfaces not particular implementations.  Then, if SDL can implement the interface, yay, otherwise it's at least up to the user to accept the abstraction failure.
10:08:26 <Cale> burp_: I don't think the problem is with the integrand becoming complex...
10:08:43 <conal> Peaker: and even pure values can throw errors.
10:08:46 <Peaker> ddarius: yeah, that's reasonable
10:08:51 <Cale> burp_: At least, so long as integrateQNG doesn't call it outside the bounds...
10:08:53 <conal> Peaker: which semantically == _|_
10:09:04 <dons> Axman6: want your blog on planet.haskell ?
10:09:09 <Cale> burp_: because it seems defined at the boundaries.
10:09:38 <Cale> er, hang on
10:09:40 <conal> Peaker: maybe the key question is: Is SDL's text rendering function referentially transparent?
10:10:10 <Cale> burp_: You're calling integrateQNG rather than integrateQAGS...
10:10:21 <Peaker> conal: I think so
10:10:25 <burp_> ooh
10:10:26 <conal> Peaker: or perhaps: is there another way to compute sizes of things without rendering them.
10:10:33 <Cale> aha!
10:10:34 <burp_> well.. let me check
10:10:38 <Cale> yes, that's exactly the problem
10:10:41 <burp_> QAGS can handle singularities
10:10:46 <burp_> while QNG cannot
10:10:51 <conal> Peaker: if text rendering is referentially transparent, then you get to use safePerformIO.
10:10:51 <Cale> It works fine if you call the QAGS version
10:11:03 <burp_> Cale, omg.. thanks
10:11:03 <sjanssen> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-February/016558.html !!!!!!
10:11:11 <conal> Peaker: it's the same reason that GHC gets to implement int addition via safePerformIO.
10:11:12 <Peaker> conal: btw, what happens right now if allocation fails? Is it considered a program crash, and thereby an error you don't have to deal with in pure code?  Because I think that's the only error that can occur in that SDL function
10:11:18 <BrokenClockwork> d
10:11:19 <burp_> I think I got confused with my function f and the debug example
10:11:20 <dons> http://www.reddit.com/r/haskell/comments/7ukk7/ready_for_testing_direct_unicode_support_for/ !!
10:11:23 <dons> !!!
10:11:35 <sjanssen> JaffaCake++ we've needed this feature for so very long
10:11:44 <conal> Peaker: does (:) has the same issue?
10:11:51 <Cale> In other news, it's a pain in the ass how the GSL exception isn't rethrown as a proper Haskell exception.
10:11:59 <Cale> ghci gets killed...
10:12:00 <dons> make it so?
10:12:13 <burp_> Cale, yes thats not nice
10:12:13 <Peaker> conal: My guess is that allocations are assumed to always succeed
10:12:15 <conal> Cale: ouch :/
10:12:18 <Peaker> conal: so, no
10:13:11 <conal> Peaker: sometimes my pure computations run out of memory.
10:13:23 <skorpan> @hoogle [a] -> (a -> m Bool) -> (a, a)
10:13:23 <lambdabot> No results found
10:13:40 <Peaker> conal: yeah, and no bottoms are introduced by that, right? The entire computation just dies, afaik
10:14:14 <conal> Peaker: bigger picture: i hope you see that we've shifted the inquiry from implementation to semantics by replacing the question "Do we use unsafePerformIO?" with "is the meaning of text rendering referentially transparent?" .
10:14:14 <skorpan> @hoogle [a] -> (a -> Bool) -> (a, a)
10:14:14 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
10:15:00 <skorpan> does anyone know what the function is called which takes a list of elements, a unary conditional function and returns a tuple with the ones which was "True" and the ones which were "False"?
10:15:13 <ddarius> :t partition
10:15:14 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:15:25 <Peaker> conal: Yeah, and I asked the SDL bindings author this question, too.  I think the only problem with the current SDL interface is that it will expose memory allocation failure as a bottom/pure exception, rather than as a whole-program-crash
10:15:26 <skorpan> oh, my type signature was messed up. thanks!
10:15:48 <conal> Peaker: in denotational terms, bottom.  in operational terms, dies.
10:15:50 <Peaker> conal: in that sense it is not referentially transparent
10:16:05 <conal> Peaker: whether bottom or dies is just perspective.
10:16:57 <conal> Peaker: oh, i see.  interesting.
10:16:59 <Peaker> conal: Yeah, okay, I will proceed in that direction then. I will try to think about the semantic/meaning of GUI animations
10:17:31 <marcot> Is there a way to call python functions from haskell?
10:17:48 <conal> Peaker: sounds good.
10:18:20 <Peaker> conal: preliminary thoughts direct me towards replacing the model -> (Image, Map Event model) representation with   model -> modeldiff -> (Animation, Map Event modeldiff)   or something like that
10:18:28 <Peaker> conal: but modeldiff is a turnoff
10:19:36 <jberryman> how would you go about creating a tree that points back to a node higher up (similar to cycle on lists)? All I can think of is a tree with a seperate constructor for holding a function back up the zipper we are in.
10:20:09 <sjanssen> jberryman: you can use a trick called "tying the knot"
10:20:55 <Badger> marcot: perhaps http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MissingPy
10:20:57 <erikc> or you can stop worrying and love the IO
10:21:13 <ddarius> If you want to make edits to this tree, an approach that splits these up my be preferable.
10:21:39 <marcot> Badger: great!
10:21:42 <skorpan> is there really no function which takes a FilePath representing a directory and returns the "innermost" directory? e.g. /etc/X11 -> X11
10:21:49 <jberryman> sjanssen: thanks, I will google
10:22:12 <paczesiowa> > takeFileName "/etc/X11"
10:22:13 <lambdabot>   Not in scope: `takeFileName'
10:22:29 <paczesiowa> > System.Directory.takeFileName "/etc/X11"
10:22:30 <lambdabot>   Not in scope: `System.Directory.takeFileName'
10:22:35 <Badger> @hoogle takeFileName
10:22:35 <lambdabot> System.FilePath.Posix takeFileName :: FilePath -> FilePath
10:22:35 <lambdabot> System.FilePath.Windows takeFileName :: FilePath -> FilePath
10:22:38 <skorpan> oh, so that one *did* work after all
10:22:41 <skorpan> then i have some other bug :(
10:22:42 <paczesiowa> > System.FilePath.takeFileName "/etc/X11"
10:22:43 <lambdabot>   /tmp/7676006122280512606:70:40:
10:22:43 <lambdabot>      Not in scope: `System.FilePath.takeFil...
10:23:51 <skorpan> oh, it doesn't work if there's a trailing /
10:24:01 <harovali> is someone doing things in meta haskell?
10:24:53 <paczesiowa> skorpan: stripSuffix
10:25:11 <skorpan> paczesiowa: i used dropTrailingPathSeparator
10:25:36 <pumpkin> @seen dons
10:25:36 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 13m 36s ago.
10:25:46 <skorpan> paczesiowa: where did you find stripSuffix?
10:26:00 <paczesiowa> dropTrailingPathSeparator is so long name that you could write fib and fact in the same space
10:26:31 <elbar> @hoogle stripsuffix
10:26:32 <lambdabot> No results found
10:26:38 <elbar> @hoogle stripSuffix
10:26:38 <lambdabot> No results found
10:26:40 <skorpan> seeing as i can't find any other function for it, i'm going to go for that :P
10:26:43 <elbar> typical ;)
10:26:59 <paczesiowa> it's not that hard to write it yourself
10:27:19 <skorpan> uh, yeah, but then again i could just alias it :P
10:27:34 <skorpan> i'm not going to start creating my own custom functions because the existing ones have too long names
10:28:23 <paczesiowa> you have to be careful not to end up with dropTrailingPathSeparatorFactoryDriverManagerFactory
10:29:25 <skorpan> yeah, better write my own funtion dTPSFDMF i guess
10:30:41 <JoshTriplett> @undo do x <- [1,2,3] ; y <- [4,5,6] ; return (x,y)
10:30:41 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5, 6] >>= \ y -> return (x, y)
10:30:47 <JoshTriplett> @undo do Just x <- [1,2,3] ; y <- [4,5,6] ; return (x,y)
10:30:47 <lambdabot> [1, 2, 3] >>= \ a -> case a of { Just x -> [4, 5, 6] >>= \ y -> return (x, y); _ -> fail ""}
10:30:54 <erikc> paczesiowa: you forgot Singleton
10:30:58 <JoshTriplett> Ah.
10:31:12 <paczesiowa> marcot: could you tell me what is that "buffer" in interleavableIO package?
10:31:24 <JoshTriplett> @hoogle buffer
10:31:24 <lambdabot> System.IO data BufferMode
10:31:24 <lambdabot> System.IO BlockBuffering :: Maybe Int -> BufferMode
10:31:24 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
10:31:48 <marcot> paczesiowa: it's a place where the data in the Monad is store.
10:31:51 <marcot> stored.
10:33:07 <paczesiowa> marcot: what data and which monad? are there any examples? I read that post by Jules Bean and I still have no idea how to use that
10:33:35 <marcot> paczesiowa: The examples are the instances in this same package.
10:33:43 <ozy`> :t Nothing
10:33:44 <lambdabot> forall a. Maybe a
10:34:20 <marcot> paczesiowa: You'll need to use it, for instance, when calling a X (from XMonad) function from a callback defined in gtk2hs.
10:36:01 <paczesiowa> marcot: got any real life examples (gtk2hs would be great)?
10:38:13 <paczesiowa> marcot: or can you tell me if I have a function timeout:: Int->IO a -> IO a, can I make it work with my stack of monads (based on IO) using that interleavableIO package?
10:38:18 <marcot> paczesiowa: Using it you would be able to call a gtk2hs function, like initGUI, inside the X monad.  And then, you'll be able to make a gtk2hs program that calls a X function.  Like, if you want a GTK program that when you click the button, it moves to the next workspace.
10:38:30 <marcot> paczesiowa: yes.
10:39:18 <paczesiowa> marcot: great, at least I know it's worth to understand that now. thanks
10:39:20 <marcot> paczesiowa: another good use is to use Control.Exception with any MonadIO.
10:39:32 <marcot> paczesiowa: check interleavableGen
10:39:37 <marcot> it's useful.
10:40:45 <paczesiowa> marcot: oh, didin't see all those other packages.
10:41:59 <marcot> paczesiowa: I think it's only iException and interleavableGen
10:42:18 <paczesiowa> oh god, those signatues are even more scary...
10:42:28 <paczesiowa> (InterleavableIO IO trans buffer, InterleavableIO IO trans1 buffer, InterleavableIO IO trans2 buffer, InterleavableIO IO trans3 buffer) => trans1 a -> (a -> trans2 result) -> (a -> trans3 result1) -> trans result1
10:43:21 <redditbot> N-bodies speedup (50%!)
10:43:21 <redditbot> Category theory and Haskell : Part 2
10:43:21 <redditbot> Heiroglyph HOWTO Part II: Simple interactivity.
10:43:56 <marcot> paczesiowa: don't worry very much about this, it's simple in the end.
10:44:07 <marcot> paczesiowa: they're just big because they're too general.
10:44:29 <lilac> Peaker: custom (non-derived) Typeable instances can lead to 0wnage too. i'm sure there are others... :(
10:44:57 <Cheshire> It's too bad you can't implement typeable without unsafeCoerce
10:45:44 <edwardk> yow. just saw that module for the first time. InterleavableIO has some cheerful looking signatures.
10:46:11 <Saizan> "cheerful"?
10:46:27 <lilac> Cheshire: it might be possible to arrange things so the unsafeCoerce goes in the derived instance
10:46:37 <paczesiowa> those signatures are so long, they should be broken up in couple of modules
10:47:06 <edwardk> i suppose i've written worse. just trying to figure out where to start when it comes to parsing them
10:48:08 <paczesiowa> (innerFunction resultFunction -> innerCaller resultCaller) what is innerFunction? it's named as a function but it in monad-like position
10:49:17 <Saizan> ?hackage InterleavableIO
10:49:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InterleavableIO
10:50:39 <Saizan> paczesiowa: the Function/Caller suffixes look like just primitive namespacing
10:51:26 <marcot> paczesiowa: Maybe the names are not the best choices.
10:55:34 <paczesiowa> ok, so how about this: how do I forkIO x :: WriterT String IO ()
10:56:20 <lilac> liftIO (forkIO x) ?
10:56:55 <Philonous> Why does ghc-pkg -list show some packages in curly braces?
10:57:00 <paczesiowa> lilac: x :: WriterT String IO (), I want to forkIO whole x
10:57:14 <Cale> paczesiowa: you'd have to runWriterT
10:58:16 <paczesiowa> Cale: if I understand correctly that package should help with turning my stack monad into IO only, doing smth, and reconstructing stack again
10:58:19 <Saizan> Philonous: those are broken somehow
10:58:31 <lilac> @type do (a, w) <- forkIO $ runWriterT (?x :: WriterT String IO ()); put w; return a
10:58:32 <lambdabot> Not in scope: `forkIO'
10:58:51 <lilac> @type do (a, w) <- (?forkIO :: IO a -> IO ()) $ runWriterT (?x :: WriterT String IO ()); put w; return a
10:58:52 <lambdabot>     Couldn't match expected type `()' against inferred type `(a, b)'
10:58:53 <lambdabot>     In the pattern: (a, w)
10:58:53 <lambdabot>     In a stmt of a 'do' expression:
10:59:36 <lilac> paczesiowa: right, that's the problem. how is your forked writer supposed to write?
10:59:52 <Saizan> you need a MVar, but it'll get synchronized then
11:00:34 <lilac> paczesiowa: you could use IO and a Chan rather than WriterT String IO
11:01:44 <lilac> it's probably possible to convert back and forth between that representation and WriterT String IO, but the semantics will be different
11:02:58 <paczesiowa> lilac: I want to timeout that computation with WriterT, timeout function is based on forkIO
11:04:11 <Cale> paczesiowa: What's wrong with just calling runWriterT first?
11:04:21 <L11> I've been tinkering with this for a while. I need to "write functions to compute the binary sum and product of a list of boolean values". Does this mean I need two separate lists?
11:04:49 <Cale> L11: separate lists of what?
11:05:08 <Cale> L11: It sounds like you have an input list, and your result is a boolean value?
11:05:17 <lilac> paczesiowa: ah, i see. then you'll need an MVar or similar for it to write its result to
11:05:25 <Cale> (in each case)
11:05:44 <L11> Cale: that's what I thought. But I thought it could mean like you have two lists of Boolean values representing a binary string and you add them together
11:06:29 <L11> in either case, I tried doing it with just one list and came up with this http://pastebin.com/d744f7185
11:06:37 <Cale> L11: Perhaps do both. They're both relatively simple.
11:06:50 <lgas> clojure
11:06:53 <lilac> paczesiowa: something like: do m <- liftIO $ newMVar; forkIO $ (runWriterT x >>= putMVar m); (wait for m with timeout); (a, w) <- takeMVar m; put w; return a
11:07:02 <Cale> lgas: what about it?
11:07:13 <lgas> sorry was trying to switch channels and hit the wrong key in emacs
11:07:22 <Cale> L11: What about the empty list? :)
11:07:41 <L11> oops forgot that :P
11:07:44 <L11> let me add it in
11:07:55 <L11> besides that fact, should this figure out the sum?
11:08:02 <Cale> L11: You won't need the one-element-list case once you can handle the empty list
11:08:24 <Cale> Also, you have some needless parens there: bSum(xs) is the same as bSum xs
11:08:41 <L11> ah C habit
11:08:44 <paczesiowa> Cale: the point is that InterleavableIO instance for WriterT already does runWriterT, I just don't know how to use that
11:09:07 <Cale> paczesiowa: I suppose. I've never used that library.
11:09:14 <lilac> L11: by sum you mean, sum treating boolean values as isomorphic to Z2?
11:09:35 <Peaker> lilac: Well, cast, unsafe array stuff, etc  should probably be in some Unsafe monad?   Then you can just forbid importing of unsafePerform* (for IO, that monad, etc)
11:09:35 <L11> lilac: i'm not sure what you mean by that
11:09:40 <marcot> paczesiowa: have you looked at interleavableGen?
11:09:58 <Cale> It looks like bSum = and
11:10:01 <lilac> Peaker: that sounds nice, but the point of unsafePerformIO is monadic escape, so i think it's impractical
11:10:09 <L11> Honestly, i'm not even sure what the question is asking - I guess its like an 'and'
11:10:34 <L11> At first I thought it wanted me to pass it two lists representing binary numbers and then do binary addition. However it specifies only one list, so i'm not sure
11:10:38 <Cale> L11: 'sum' is often used to mean exclusive or, and 'product' for and.
11:10:46 <Peaker> lilac: Yeah, its a problem. I'm sure there's a nicer solution than forbidding tons of specific things though
11:10:47 <Cale> L11: But it's not clear.
11:10:49 <lilac> L11: well, sum on boolean values could mean one of: "or" them all together, two boolean lists -> one boolean list (sum with carry), "xor" them, or...
11:11:02 <Cale> L11: I suppose the hope here is that you can get clarification from your prof ;)
11:11:16 <ehird> Is there an STM tutorial anywhere?
11:11:22 <L11> Yea, well I did this assignment last week on the day it was given out
11:11:39 <L11> then realized today (due at 11:59 PM) that somehow had gotten a different assignment from the website :-/
11:11:39 <lilac> Peaker: i actually /like/ unsafePerformIO (and not just pragmatically)
11:11:43 <marcot> paczesiowa: you should use forkIO' f = embed $ \buffer -> forkIO (callback buffer f)
11:11:53 <marcot> paczesiowa: then, you'll be able to call forkIO' x
11:11:56 <L11> kind of sucks :P Particularly since i'm not that familiar with haskell
11:12:12 <ehird> lilac: why?
11:12:15 <Peaker> lilac: Sure -- but it would be nice if code that used it was tagged somehow, so you can reject it as a security policy
11:12:21 <Badger> when do you use unsafeperformIO? when would one need to perform IO unsafely? :P
11:12:24 <Cale> L11: Is the website publically accessible?
11:12:29 <ehird> Badger: unsafePerformIO :: IO a -> a
11:12:32 <lilac> i like it specifically in the cases where it allows you to write a more efficient implementation of something which is referentially transparent
11:12:33 <ehird> I think you can see the problem.
11:12:40 <Peaker> lilac: I'm basically suggesting this as a security feature, not a safety feature
11:12:47 <L11> Cale: blocked with htaccess
11:12:53 <L11> The assignment is all that is up though
11:13:00 <Badger> ehird: is it just me, or does that look a little bit dangerous
11:13:05 <lilac> like the ST monad or some kinds of memoization
11:13:08 <ehird> Badger: That would be the "unsafe" part.
11:13:14 <Cale> I was thinking that perhaps with more context it would be clearer what was meant.
11:13:23 <beelsebob> Badger: getting a value out of IO is sometimes useful – but it's usually not safe
11:13:28 <beelsebob> unsafePerformIO is a rather bad name
11:13:28 <L11> Yea, all that was provided was a link to a PDF
11:13:36 <beelsebob> it should be called verifyItsSafeYourselfPerformIO
11:14:07 <Cheshire> When is it useful?
11:14:18 <beelsebob> usually when you want to add a type of literal to Haskell
11:14:22 <L11> I'm just going to try and knock out the sum and product and then just ask him after class today before the due time
11:14:22 <L11> in either case, my code should work for the 'and' (product?)
11:14:27 <beelsebob> e.g. when you want to treat the contents of a file as a literal
11:14:36 <Cale> L11: yes
11:14:36 <lilac> or iKnowHowTheCompilersOptimizationsAndRTSWorkAndIWantToExploitThatPerformIO
11:14:41 <Cale> L11: Do you know about foldr?
11:14:41 <ehird> you don't, in general, beelsebob, no?
11:14:51 <ehird> so Is there an STM tutorial anywhere?
11:14:57 <L11> Cale: never heard of it
11:15:03 <beelsebob> img = unsafePerformIO $ readImageFile "Resources/magic.png" -- that would be a common safe use
11:15:05 <Cale> L11: oh, okay
11:15:21 <Cheshire> beelsebob, that's crazy
11:15:22 <Cale> > foldr (&&) True [True, False, True]
11:15:23 <lambdabot>   False
11:15:24 <mauke> ehird: it's all intuitively obvious™ :-)
11:15:28 <beelsebob> Cheshire: why is that?
11:15:30 <ehird> mauke: Uh huh.
11:15:32 <Cale> > foldr (&&) True [True, True, True]
11:15:33 <lambdabot>   True
11:15:42 <ehird> <beelsebob> img = unsafePerformIO $ readImageFile "Resources/magic.png" -- that would be a common safe use
11:15:44 <ehird> I dislike this.
11:15:53 <Cale> L11: It captures the pattern of what you're doing with the list there.
11:15:58 <beelsebob> ehird: why – all it's doing is adding the "image" litteral type to the language
11:16:01 <Cale> L11: Well, more or less.
11:16:03 <lilac> ehird: you'd prefer the file embedded in the binary via TH?
11:16:05 <paczesiowa> marcot: ok, that forkIO' at least typechecks, thanks
11:16:15 <ehird> lilac: *g*
11:16:26 <mauke> beelsebob: except it's not a literal, and can actually change
11:16:33 <beelsebob> mauke: as can your source code
11:16:36 <lilac> ehird: at least then you know /when/ the file is read :)
11:16:36 <L11> hm let me check it out
11:16:42 <mauke> beelsebob: not while the program is running
11:16:44 <beelsebob> number = 5 -- this can change too
11:16:53 <Cale> L11: another thing you'll be interested in, perhaps, is zipWith
11:16:58 <edwardk> ah, ok, i have now parsed the interleaveIO stuff. cute.
11:17:07 <beelsebob> mauke: sure – but most people would say that their programs behavior is undefined if someone fucks with its resources while its running
11:17:10 <Cale> > zipWith (&&) [True, True, False, False] [True, False, True, False]
11:17:11 <lambdabot>   [True,False,False,False]
11:17:11 <beelsebob> so that's no real cost
11:17:41 <beelsebob> mauke: saying that is like saying "someone could fiddle with the machine code in your program while its running"
11:17:43 <Peaker> lilac: I think there are safety issues, and security issues.  Since language-level security is how I believe security should be done, unsafety is also insecurity.  To resolve normal insecure stuff, just forbid ambient-authority calls (inside various IO modules).  To resolve unsafe stuff, I think you have to tag values as "unsafe", and have an "unsafeToSafe" that only "trusted" code is allowed to use.  Then safety is probably a tag, but maybe its a type-ta
11:17:43 <Peaker> g/monad
11:17:45 <beelsebob> yes... it could happen
11:17:45 <marcot> paczesiowa: you're the first person that talked about interleavableIO, so good luck.
11:17:51 <beelsebob> but it's not very likely
11:18:01 <beelsebob> nor do you guarentee your program will work if someone does it
11:18:24 <Peaker> lilac: so your user code is allowed to indirectly call fast unsafe stuff because they unsafeToSafe. But it itself cannot do unsafe stuff directly
11:18:30 <L11> Cale: cool, thanks :)
11:18:35 <Peaker> lilac: (if you don't trust it with importing unsafeToSafe)
11:18:36 <Cale> L11: People often think that functional programming is all about recursion, but actually, we try to avoid it as much as possible, favouring the use of higher order functions. :)
11:19:02 <L11> Cale: yea, I honestly am not a fan of recurrsion. My prof loves it
11:19:06 <dons> and use fusion to get rid of as much recursion as possible :)
11:19:21 <L11> apparently you can't make a compiler without it. (he's one of the lead gcc developers)
11:19:25 <beelsebob> L11: try writing tree transformation code and then saying that
11:19:54 <L11> beelsebob: yea, I don't like it now but I can pretty much say i'll like it after this class :P
11:20:00 <paczesiowa> marcot: that's great, of all 3 people that "know" this library (you, me and quicksilver) 66% understand it! that's a lot:> and sorry for lowering the stats
11:20:09 <ehird> http://haskell.org/haskellwiki/STM -- not very helpful
11:20:45 <marcot> paczesiowa: I didn't knew quicksilver used this library, and anyone else. =)  It's good to know.
11:20:45 <L11> Cale: the empty set should just be false, correct?
11:20:47 <Cale> L11: Well, you need recursion in order to write the various higher-order functions in the first place.
11:20:53 <Cale> L11: in which case?
11:20:54 <dons> its a wiki. the ball is in your court now, ehird :)
11:21:10 <ehird> dons: I'd have to know about STM to improve it, which is exactly what I'm trying to learn...
11:21:23 <L11> Cale: in the product, the first code I pastebin'ed
11:21:43 <Saizan> ehird: one of the earlier papers is quite introductory
11:21:55 <Cale> L11: Generally, if you're combining the elements of a list with some operation, the empty list case is handled by the value which is an identity for that operation.
11:22:08 <Saizan> ehird: and easy to read
11:22:11 <Cale> L11: For example, the sum of an empty list is 0, or the product of an empty list is 1
11:22:15 <ehird> hm, ok
11:22:36 <chessguy_work> @src product
11:22:36 <lambdabot> product = foldl (*) 1
11:22:49 <Cale> L11: So in this case, the AND of an empty list is the value which leaves other things unaffected under AND'ing.
11:23:36 <Cale> L11: Which is True.
11:23:38 <L11> True :)
11:23:44 <L11> yea, just tested it out :P
11:23:58 <L11> so with foldr, I take it that the (&&) is the function you want to apply to the list?
11:24:17 <Cale> yeah, you're already aware how lists are built up from (:) and [] ?
11:24:29 <Cale> [1,2,3] = 1 : (2 : (3 : []))
11:24:33 <L11> yea, from doing the wrong assignment :P
11:24:49 <L11> was all about lists and concating strings and what not
11:24:49 <Cale> What foldr f z does is to replace each (:) with f, and the [] at the end with z
11:24:55 <Cale> > foldr f z [1,2,3]
11:24:56 <lambdabot>   f 1 (f 2 (f 3 z))
11:25:03 * roconnor reads about Huet's scars
11:25:15 <int80_h> dons: does fusion mean the passing of functions to other functions?
11:25:25 <Cheshire> beelsebob, (1) Since file system interaction goes beyond any simple model of pure haskell (I have a small framework to understand function application, abstractions etc..) -- with unsafePerformIO you open pandoras box
11:25:36 <Cale> So foldr (&&) True [True, False, True] = True && (False && (True && True))
11:25:37 <mauke> int80_h: no, it means turning two operations into one operation
11:25:58 <beelsebob> Cheshire: yes, you do indeed open pandora's box, and then you verify yourself that you're not going outside the realms of pure haskell
11:26:00 <L11> yea that's what i figured was going on, just wasn't sure
11:26:06 <Cheshire> beelsebob, (2) It seems to suggest that it's maybe easier or better in some way to not define sequential/stateful interaction monadically
11:26:08 <int80_h> ahh! I love this channel :)
11:26:16 <paczesiowa> marcot: I thought that you wrote it with his code as a base
11:26:17 <chessguy_work> int80_h, what you gave is basically a definition of higher-ordered functions
11:26:19 <L11> so instead of the && can I do say an or? or xor for the sum?
11:26:22 <Cheshire> beelsebob, but you are not the first to suggest (2) so I'm really curious where that is coming from
11:26:22 <chessguy_work> (HOF)
11:26:24 <beelsebob> Cheshire: it's not a sequential or stateful action
11:26:29 <beelsebob> it's a litteral
11:26:31 <mopped> if I have product1 x = foldl (*) 1 x, and product2 = foldl (*) 1, are they equivelent? are they interchangable in all places?
11:26:37 <dons> int80_h: nope
11:26:37 <mauke> hmm, is map f . map g === map (f . g) a form of fusion?
11:26:41 <int80_h> chessguy_work: yeah, I thought there was a relationship between first-order functions and fusion
11:27:06 <mauke> mopped: theoretically, yes. practially (in Haskell 98), no
11:27:33 <chessguy_work> mauke, what??
11:27:35 <mauke> the dreaded monomorphism restriction
11:27:37 <L11> ah, nvm figured it out :)
11:27:37 <roconnor> aww
11:27:43 <chessguy_work> mauke, you mean santa clause doesn't exist????
11:27:46 <roconnor> scars are less intresting than I had hoped
11:27:55 <int80_h> he does too! stop it!
11:27:55 <marcot> paczesiowa: quicksilver is Jules Bean?
11:28:13 <mopped> is one superior to another mauke? where should i beware about using one or the other
11:28:33 <paczesiowa> marcot: I think so
11:28:36 <Cale> mopped: if you give both of them type signatures, they will be equivalent
11:28:38 <mauke> mopped: the only difference is in the type that's inferred for them
11:28:41 <chessguy_work> mopped, just make sure you use type signatures, and you'll be fine
11:28:51 <Cale> mopped: or you can simply turn off the MR, because it's stupid anyway
11:28:55 <mauke> mopped: generally, you should disable the MR
11:29:10 <mauke> and use the latter version
11:29:22 <mauke> except it should be foldl' :-)
11:29:34 <koeien> mauke: depends on (*) :-)
11:30:07 <koeien> but for normal cases foldl' is better (strict)
11:30:16 <Cale> > foldr (/=) False [True, True, False, True]
11:30:17 <lambdabot>   True
11:30:18 <mopped> what would product2 type be? (Num a) => [a] -> Integer? Treat it the same as before?
11:30:22 <Cale> > foldr (/=) False [True, True, False, False]
11:30:23 <lambdabot>   False
11:30:34 <marcot> paczesiowa: ok then. =)
11:30:42 <koeien> mopped: Num a => [a] -> a
11:30:46 <mauke> mopped: [T] -> T for some constant type T
11:30:57 <mauke> mopped: the exact type chosen depends on how the rest of the program uses product2
11:31:07 <koeien> under the MR
11:31:18 <mopped> sorry, what is MR?
11:31:22 <koeien> monomorphism restriction
11:31:39 <jeffersonheard> roconnor, how do I extract the color components back out of an AlphaColour?
11:31:50 <jeffersonheard> assuming roconnor is still here
11:31:53 <chessguy_work> @hoogle AlphaColour
11:31:54 <lambdabot> No results found
11:31:55 <koeien> mopped: http://haskell.org/haskellwiki/Monomorphism_restriction
11:32:09 <roconnor> jeffersonheard: Hmm, I should document that process
11:32:19 <mopped> ok thanks
11:32:51 <Cheshire> beelsebob, it was very difficult to turn my anathema with that code into words, interesting..
11:33:03 <roconnor> jeffersonheard: step 1: produce pre-multiplied colour components by \ac -> ac `over` black  or (\ac -> ac `over` (mempty :: Colour a))
11:33:44 <L11> alright I think I should be good for now, but will probably be back later :)
11:33:50 <L11> thanks Cale, you where tons of help!
11:33:58 <int80_h> Cale is always a ton of help
11:33:59 <Cale> L11: no problem!
11:34:06 <roconnor> jeffersonheard: setp 2: divide by alpha  using (darken (recip (AlphaChannel ac)))
11:34:15 <BMeph> Step 3: ????  ;)
11:34:21 <roconnor> profit!
11:34:31 <Cheshire> beelsebob, but would you really use something like this in reality? as opposed to solving the problem of loading resources and so on in a self contained way?
11:34:35 <roconnor> jeffersonheard: check before dividing by 0 in step 2
11:34:36 <int80_h> Tep 3: Start a haskell start-up
11:34:40 <Cheshire> (it seem very quick and dirty)
11:34:42 <int80_h> Step^
11:35:12 <roconnor> jeffersonheard: if the AlphaColour is transparent, then you can pick whatever colour you want, typically black or (mempty :: Colour a)
11:35:27 <BMeph> int80_h: Step 3b: Hire dons, Cale, quicksilver and oleg as consultants. :)
11:35:55 <jeffersonheard> roconnor, but if I'm passing RGBA quadruplets along, I don't want to premultiply the alpha channel
11:35:58 <int80_h> BMeph: I'll make dons the man behind the curtain
11:36:07 <paczesiowa> BMeph: you want to make money or destroy the world?
11:36:11 <roconnor> jeffersonheard: hence the step 2
11:36:23 <jeffersonheard> ah right
11:36:25 <jeffersonheard> I see
11:36:38 <BMeph> paczesiowa: Why not both? ;)
11:37:03 <roconnor> jeffersonheard: I sort of deliberately make it hard to do because it is an operation I don't want people doing; however if you are interfacing with another lib, such as cairo, it is necessary.
11:37:35 <jeffersonheard> roconnor, when would you use Data.Color alone, though?
11:37:50 <roconnor> jeffersonheard: when using Heiroglyphs
11:38:05 <jeffersonheard> hah
11:38:10 <jeffersonheard> right
11:38:11 <roconnor> which will handle the coversion for you
11:38:22 <jeffersonheard> yes, of course :-)
11:38:26 <roconnor> :P
11:38:52 <paczesiowa> > let foo x = do return 0; let y = x; return y in foo 2
11:38:52 <lambdabot>   <no location info>: parse error on input `in'
11:39:49 <paczesiowa> how do I inline let?
11:40:19 <roconnor> > let foo x = do return 0; y = x; return y in foo 2
11:40:20 <lambdabot>   <no location info>: parse error on input `='
11:40:47 <roconnor> > let foo x = (do return 0; let y = x; return y) in foo 2
11:40:48 <lambdabot>   <no location info>: parse error on input `)'
11:40:55 <jeffersonheard> roconnor, what would be really useful would be a couple of ways to get stepped color intervals -- vectors of intermediates between color a and b
11:40:56 <roconnor> hmm
11:41:15 <jeffersonheard> or rather, not stepped, but a continuous color space from which one could sample
11:41:23 <roconnor> jeffersonheard: using blend?
11:41:32 <jeffersonheard> ues
11:41:54 <roconnor> you can use blend.
11:42:15 <roconnor> > let foo x = do {return 0; let y = x; return y} in foo 2
11:42:16 <lambdabot>   <no location info>: parse error on input `}'
11:42:42 <mauke> stop failing, please
11:42:48 <roconnor> mauke: make it work
11:42:59 <mauke> > let foo x = do return 0; let {y = x}; return y in foo 2 :: [Int]
11:43:00 <lambdabot>   [2]
11:43:02 <roconnor> I forget the stupid subtle thing that I'm missing
11:43:14 <mauke> let is followed by a block
11:43:22 <redditbot> Turbinado vs HAppS
11:43:43 <lilac> > let { foo x = do { return 0; let y = x; return y } } in foo 2
11:43:44 <lambdabot>   <no location info>: parse error on input `}'
11:43:47 <athos> > pi
11:43:48 <lambdabot>   3.141592653589793
11:43:52 <athos> > sqrt 10
11:43:53 <lambdabot>   3.1622776601683795
11:43:54 <roconnor> > pi :: CReal
11:43:55 <lambdabot>   3.1415926535897932384626433832795028841972
11:44:22 <roconnor> > deriv (\x -> x**x) x
11:44:23 <lambdabot>   (1 * recip x * x + log x * 1) * exp (log x * x)
11:44:50 <conal> fun
11:45:10 <conal> > deriv (\x -> x**x) (pi :: CReal)
11:45:11 <lambdabot>   78.2014834121896345036951435212340559438021
11:45:21 <conal> :)
11:45:43 <athos> :t antideriv
11:45:44 <lambdabot> Not in scope: `antideriv'
11:45:49 <athos> :>
11:45:51 <conal> > showCReal 100 $ deriv (\x -> x**x) pi
11:45:53 <lambdabot>   "78.20148341218963450369514352123405594380208423615935006160780714707411428...
11:46:03 <athos> :t deriv
11:46:03 <lilac> :t integ
11:46:04 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
11:46:05 <lambdabot> Not in scope: `integ'
11:46:25 <athos> , src ''Dif
11:46:28 <lunabot>  data Dif a = D a (Dif a)
11:46:34 <lilac> > deriv (exp (x**2))
11:46:35 <lambdabot>   Couldn't match expected type `Dif a -> Dif b'
11:46:41 <lilac> > deriv (\x -> exp (x**2)) x
11:46:42 <lambdabot>   1 * recip x * 2 * exp (log x * 2) * exp (exp (log x * 2))
11:47:03 <roconnor> > deriv (\x -> exp (x^2)) x
11:47:05 <lambdabot>   (1 * x + x * 1) * exp (x * x)
11:47:17 <conal> > deriv (deriv (\x -> exp (x**2))) x
11:47:18 <lambdabot>   (1 * negate (1 * recip x * recip x) * 2 * exp (log x * 2) + 1 * recip x * 2...
11:47:31 <athos> :>
11:47:36 <conal> nice
11:47:42 <mauke> > deriv (^2) x
11:47:43 <lambdabot>   1 * x + x * 1
11:47:51 <lilac> > deriv (**2) x
11:47:53 <lambdabot>   1 * recip x * 2 * exp (log x * 2)
11:47:55 <mauke> > case deriv (^2) x of D _ x -> x
11:47:56 <lambdabot>   Not in scope: data constructor `D'
11:48:05 <lilac> > deriv (^^2) x
11:48:06 <lambdabot>   1 * x + x * 1
11:48:12 <lilac> > deriv (^^7) x
11:48:13 <lambdabot>   ((1 * x + x * 1) * (x * x) + x * x * (1 * x + x * 1)) * (x * x * x) + x * x...
11:48:19 <Cheshire> > integral (join (**))x
11:48:20 <lambdabot>   Not in scope: `integral'
11:48:43 <lilac> > deriv (join (^^)) x
11:48:44 <lambdabot>       No instance for (Integral (Dif Expr))
11:48:44 <lambdabot>        arising from a use of `^^'...
11:48:47 <conal> roconnor: is this functionality (CReal & Dif) from the 'numbers' package?
11:48:54 <roconnor> yes
11:49:02 <roconnor> plus the simpl reflect
11:49:09 <conal> roconnor: yeah, nice.
11:49:11 <roconnor> which is different from the reflection in numbers
11:49:15 <roconnor> but similar
11:49:18 <conal> oh!  twey's?
11:49:21 <Cheshire> beelsebob, this reminds me of something -- Would you admit unsafePerfomMathematica or similar in theorem proving software?
11:49:29 <roconnor> conal: I don't know.  I suppose so.
11:50:12 <Philippa_> Cheshire: I wouldn't, though it's not directly analogous to unsafePerformIO
11:50:18 <conal> roconnor: i noticed that CReal uses a function rep (Int -> Integer) but not memoized.  i'd expect it to be inefficient without memoization.  lennart thought not.
11:50:35 <chessguy_work> hey conal, you should totally write a book. i'd stand in line to buy it
11:50:41 <Philippa_> or rather, the actual roles aren't however close it is via Curry-Howard
11:50:46 <conal> chessguy_work: thx! :)
11:50:55 <Cheshire> Philippa_, (me neither), it's a rough analogue yes
11:51:03 <conal> roconnor: e.g., pi gets recomputed each time it's used, right?
11:51:23 <lilac> conal: wouldn't it incur a significant space leak to do otherwise?
11:51:47 <chessguy_work> seriously, i love your ideas about figuring out the right semantics, and i think they would change the industry completely, if they weren't over everybody's heads :)
11:51:51 <conal> lilac: maybe.  hm.  same is true for Integer, i guess.
11:52:21 <ehird> :t untilM
11:52:22 <lambdabot> Not in scope: `untilM'
11:52:27 <conal> chessguy_work: then i have work to do: "You do not really understand something unless you can explain it to your grandmother."  - Albert Einstein
11:52:35 <Philippa_> Cheshire: the big difference being that Haskell isn't normally used for theorem proving purposes per se - and the consequences of a program involving unsafePerformIO are easier to list as a bunch of proof obligations because the metatheoretical consequences are minimal
11:52:49 <augustss> conal: what is it that you'd memoize?  the Int->Integer function?
11:52:56 <conal> augustss: yeah.
11:53:05 <chessguy_work> conal, well, if you didn't, then the book would be written already :)
11:53:07 <conal> augustss: e.g., with a patricia tree
11:53:23 <Cheshire> Philippa_, was relating  type safety/purity : haskell :: logical soundness : theorem proving
11:53:43 <conal> chessguy_work: yeah.
11:53:49 <augustss> conal: but for computing some particular value, like sin 1.2, you'd not use the same Int twice.
11:54:06 <roconnor> conal: well, memoization would only help in this representation when you ask for exactly the same precision.
11:54:12 <Philippa_> Cheshire: yeah. As I said, the difference is that unsafePerformIO is has much looser requirements for not screwing up the metatheory
11:54:25 <conal> oh -- that's what the argument is for.  nm then.  thx.
11:54:59 <conal> roconnor: do you know of an online ref (free or ACM) for this implementation?
11:55:13 <Philippa_> Cheshire: largely because Haskell's isn't particularly strong to start with
11:55:15 <augustss> roconnor: so all that lovely thesis work you did, is there a package on hackage for it?
11:56:26 <conal> roconnor: i've gotten to thinking about exact images again, filling in a missing piece in my story so far.  i've switched from discrete to continuous and finite to infinite.  next is approximate values (e.g., colors) to exact values.
11:56:51 <conal> roconnor: where the exact value is the exact average over a pixel's area, to infinite precision.
11:57:02 <conal> average over uncountably many points.
11:57:17 <conal> i think there's a nice, elegant & computable way to do it.
11:57:58 <conal> and one that uses unamb in a neat way in choosing a relatively cheap way to compute the next bit.
11:59:20 <Philippa_> conal: sounds like your model doesn't like dithering?
11:59:32 <conal> as usual, the exact notions (continuous, infinite, precise) are much more nicely composable.
11:59:40 <skorpan> anyone using libmpd here? i'm trying to figure out if it's at all possible to get a persistent connection to MPD with it or if a new connection has to be initiated every time.
11:59:40 <conal> Philippa_: gee, i don't know.
12:00:00 <lilac> Philippa_: i would think you could handle that after discretization
12:00:01 <Philippa_> conal: to put it another way, you might want to factor out how you sample a discrete image from the continuous one entirely
12:00:22 <conal> Philippa_: i don't think so.  it's about getting the semantically correct answer, not making error look prettier.
12:00:42 <conal> Philippa_: iiuc, that's what i've always done.
12:00:57 <Philippa_> well, there's a big question as to what 'semantically correct' means in the presence of inevitable sampling error
12:01:17 <paczesiowa> is there such a thing as monad stack overflow? I just got MonadError inside MonadError and I can't remember what I was trying to accomplish:/
12:01:23 <conal> Philippa_: really inevitable?
12:01:24 <Philippa_> which is why I'd generally rather factor sampling separately from the continuous semantics
12:01:36 <stepcut> I have a module that is supplied by two different packages, is there a way to tell runhaskell/ghc which package I want with out having to run ghc-pkg hide on the one I don't?
12:01:55 <Philippa_> conal: across continuous images in general? Pretty much, yeah.
12:02:07 <mauke> paczesiowa: STACK POINTER MONADIC OVERFLOW?!
12:02:09 <conal> Philippa_: continuous semantics with separated sampling is what i did with pan etc.
12:02:30 <conal> Philippa_: yes, in general.  i'm not sure error is inevitable.
12:02:49 <paczesiowa> mauke: no, stack of monads overflow
12:03:34 <lilac> paczesiowa: stack of monads? do you mean a stack of monad transformers?
12:03:36 <SubStack> those troublesome monads, always mutating the state
12:03:46 <conal> Philippa_: actually, i agree with you about general images.
12:03:51 <jeffersonheard> teenage mutant ninja monads
12:03:57 <Philippa_> conal: yeah. First thing to do's define perfection then, but I don't think 'averages' are the right operation for that - that smells of speccing a filter
12:03:59 <Philippa_> *nod*
12:04:04 <paczesiowa> lilac: yeah
12:04:16 <Philippa_> so the question becomes: do you have a special case where that's irrelevant?
12:04:21 <Philippa_> and if so, what does that buy you?
12:04:26 <Saizan> stepcut: cabal uses ghc --hide-all-packages -package foo-0.1 -package bar-0.2 ...; maybe there's also an --hide for hiding a single package
12:04:43 <stepcut> bah
12:05:04 <Saizan> stepcut: yeah, -hide-package name
12:05:43 <stepcut> ok, selectively hiding packages could work
12:05:44 <conal> oh -- i hadn't considered alternatives to computing the (exact) average of a (continuous) image over a pixel's area.
12:05:51 <Saizan> http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html
12:05:54 <stepcut> but not the other way, I depend on dozens of packages :)
12:06:24 <SamB_irssi> conal: the mean over a rectangle isn't the best way to go even in theory!
12:06:49 <conal> SamB_irssi: i know.  i just thought i'd start there.
12:07:06 <Philippa_> SamB_irssi: thanks, I don't know enough DSP to say what the right answers are here sadly :-( I do know that in theory the ideal's going to involve shaving off everything over Nyquist for example...
12:07:11 <conal> SamB_irssi: because the algorithmic question is fun even for that simple case.
12:07:18 <SamB_irssi> conal: true!
12:07:31 <conal> SamB_irssi: still i'd like suggestions about where to go next, after the mean.
12:09:48 <conal> SamB_irssi: i understand (a pinch) that pixels are non-square and even overlap.  are there additional issues to look at?
12:10:04 <Philippa_> conal: algorithmically, isn't what you're doing just the fusion of the continuous+sampling model?
12:10:06 * erikc registers monadoverflow.com
12:10:09 <SamB_irssi> conal: probably!
12:10:38 <conal> Philippa_: yes, algorithmically, it's about fusion.
12:10:45 <Philippa_> conal: you'd be after the 2d equivalent of sinc resampling, wouldn't you?
12:10:52 <ozy`> erikc: gonna make a haskell discussion site?
12:11:06 <_roconnor> conal: Lester (author of CReal aka ERA) documents his work in ``Real Number Calculations and Theorem Proving: Validation and Use of an Exact Arithmetic'' published in the proceedings of TPHOLs 2008
12:11:32 <Philippa_> you're into filtering turf, and I don't actually know as much as I'd like there
12:11:42 <conal> _roconnor: thx.  i'll look.  so far, i've had a hard time finding online docs.
12:11:42 <_roconnor> augustss: my lovely thesis work resulted in a Coq implementation.  There is a draft haskell version on my webpage, but not in hackage.
12:12:25 <int80_h> _rconnor, is your thesis online?
12:12:25 <augustss> _roconnor: there should be :)
12:16:06 <int80_h> ?
12:16:54 <conal> roconnor: are there exact real representations that are essentially bit streams?
12:17:17 <conal> roconnor: or bit zippers
12:17:23 <chrisdone> omg where is vixey~_~
12:17:50 <chrisdone> mmorrow: has vixey been around?
12:19:31 <Cheshire> chrisdone, here - why?
12:19:45 <chrisdone> oh!
12:20:20 <chrisdone> Cheshire: I wanted to ask you about your unifier class
12:20:51 <Surma> Guys, how can I convert the result of ``sqrt'' to an Int?
12:21:08 * chrisdone experiments more to formulate a question
12:21:15 <mauke> Surma: round
12:21:20 <Surma> I still don't get the whole type thing in Haskell
12:21:22 <Surma> ah k thx
12:22:54 <L11> hm any pointers on how to convert from binary to decimal and back again? Everything I try seems to break :/
12:22:58 <tromp__> :t round
12:22:59 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:23:04 <tromp__> :t truncate
12:23:05 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:23:06 <SamB_irssi> is there some kind of tool to convert haddock 0.x interface files to haddock 2 interface files ?
12:30:00 <mauke> L11: you go via Integer
12:30:45 <mauke> read/show use decimal by default
12:31:24 <mauke> there is no showBin/readBin, but a few useful functions in http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
12:31:39 <mauke> see also Data.Char for digitToInt and friends
12:31:48 <FunctorSalad> what's the question?
12:32:27 <mauke> convert from binary to decimal and vice versa
12:33:31 <L11> mauke: Not to complicate things further, but I can't use any built in arithmetic (part of a class assignment)
12:33:45 <mauke> what, no + or -?
12:33:49 <mauke> that's going to be hard
12:33:52 <roconnor> int80_h: http://r6.ca/thesis.pdf
12:34:21 <roconnor> augustss: are you saying my haskell draft should be in hackage?  (re: _roconnor: there should be :)
12:35:27 <augustss> roconnor: that's what I'm saying.  You can't hang out on #haskell with a package on hackage, you know. ;)
12:35:40 <sbahra> With a package on hackage?
12:36:35 <roconnor> @hackage colour
12:36:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour
12:36:41 <roconnor> augustss: I have that package :)
12:36:50 <conal> roconnor: not sure you got my previous question: are there exact real representations that are essentially bit streams (or bit zippers)?
12:37:07 <paczesiowa> @where hpaste
12:37:07 <lambdabot> http://hpaste.org/
12:37:10 <chrisdone> vicky: oh I think I get it
12:37:16 <augustss> conal: if you have digits -1,0,1
12:37:17 <roconnor> conal: yes, there are represenations as signed digit streams
12:37:39 <paczesiowa> hpaste is down:(
12:37:57 <conal> augustss, roconnor neat!  any info pointers?
12:37:58 <roconnor> conal: somtime -1 .. 1, sometimes -128..127, sometime Int32
12:38:08 <roconnor> conal: lemme see
12:38:12 <conal> sounds like what i'm looking for.
12:38:29 <conal> i had a hunch signed digits would be involved.
12:38:36 <roconnor> (you are right, these streams are memoized, but have some disadvantagess too)
12:38:50 * roconnor checks my .bib
12:38:55 <conal> :D
12:39:47 <roconnor> conal: BTW, chapter 11 in my thesis is on integration. (although it isn't a very good implementation)
12:39:57 <conal> roconnor: nice!
12:39:59 <augustss> conal: yes, you need signed digits, because when you've given a certain number of digits you need an epsilon up and down, not just up
12:40:01 <roconnor> conal: and chapter 12 talks abour rasterizing compact sets
12:40:16 <conal> roconnor: can i get your thesis?
12:40:30 <roconnor> conal: http://r6.ca/thesis.pdf
12:40:40 <roconnor> er I think I got it wrong,  It is chapter 12 and 13
12:40:45 <conal> thx!
12:40:49 <SamB_irssi> can someone explain the un-linked things listed at the top of http://naesten.dyndns.org:8080/lhc-doc/html/lhc/lhc/Stats.html ?
12:41:25 <SamB_irssi> that is, in the synopsis section ?
12:41:38 <roconnor> [Julien, 2008] Julien, N. (2008). Certiﬁed exact real arithmetic using co-induction in
12:41:40 <roconnor>    arbitrary integer base. In Functional and Logic Programming Symposium (FLOPS),
12:41:41 <roconnor>    LNCS. Springer.
12:41:44 <roconnor> conal: ^^
12:42:08 <SamB_irssi> oh, wait, I think those need type signatures ...
12:42:09 <roconnor> that is one implemenation of signed streams of digits
12:42:09 <conal> \o/
12:42:20 <roconnor> conal: I'm biased to implemenations in theorem provers.
12:42:37 <conal> oh, okay.
12:42:49 <conal> hurray, the julien paper has an on-line pdf!
12:43:06 <conal> oh -- slides, not paper.
12:43:21 * conal keeps looking
12:43:43 <Surma> guys, why doesn't this work:  fromIntegral (round (sqrt (length b)))
12:43:44 <Surma> (it's supposed to return an Int)
12:44:05 <roconnor> @type round
12:44:06 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:44:16 <koeien> rather,
12:44:19 <Twey> :t sqrt
12:44:20 <roconnor> Surma: you shouldn't need fromIntegral.
12:44:20 <koeien> @type sqrt
12:44:20 <lambdabot> forall a. (Floating a) => a -> a
12:44:21 <lambdabot> forall a. (Floating a) => a -> a
12:44:39 <roconnor> Surma: round is already polymorphic
12:44:46 <Twey> length :: [a] -> Int
12:44:57 <Twey> Int isn't an instance of Floating
12:44:59 <pumpkin> roconnor: what if you need the rounded value to be a non-integral?
12:45:12 <pumpkin> 6.0
12:45:18 <roconnor> oh right
12:45:33 <Cheshire> Surma, use  (isqrt . length) b  instead
12:45:37 <roconnor> Surma: you might need a type annotation (or just use fromInteger instead)
12:45:41 <pumpkin> sounds like he realy just needs an integer square root
12:45:48 <Twey> > isqrt $ length [1..10]
12:45:49 <lambdabot>   Not in scope: `isqrt'
12:45:53 <mauke> there is no isqrt
12:45:58 <Twey> Who is isqrt?
12:46:03 <augustss> I often want isqrt too
12:46:05 <Cheshire> @go How to computed the square root of an integer
12:46:06 <Cheshire> :P
12:46:07 <lambdabot> http://www.programming4scientists.com/2008/11/almost-the-square-root-of-2-rounding-errors-in-computer-code/
12:46:07 <lambdabot> Title: “Almost the square root of 2″ - rounding errors in computer code | Programmi ...
12:46:10 <pumpkin> there's an integer square root here http://www.polyomino.f2s.com/david/haskell/numbertheory.html
12:46:18 <paczesiowa> marcot: could you take a look at this: http://haskell.pastebin.com/m3cf83729 ? it works, but I have no idea how to use writer state from that killed thread, so if it runs for too long I loose all state
12:46:29 <conal> found the julien *paper* pdf : http://hal.inria.fr/inria-00202744  :)
12:47:09 <Twey> @let isqrt = sqrt . fromIntegral
12:47:10 <lambdabot>  Defined.
12:47:11 <FunctorSalad> > round . sqrt . genericLength $ [1,2,3,4] -- Surma
12:47:12 <lambdabot>   2
12:47:16 <FunctorSalad> ^^
12:47:20 <Twey> > isqrt $ length [1..10]
12:47:21 <lambdabot>   3.1622776601683795
12:47:41 <Twey> Ooh, yes, genericLength is good.
12:47:51 <mauke> I don't like genericLength
12:47:56 <sbahra> mauke, why not?
12:47:59 <pumpkin> FunctorSalad: but then you're limited by floating point arithmetic
12:48:10 <pumpkin> whereas the intSqrt I posted on that page is arbitrary precision
12:48:17 <L11> mauke: no i think we can use + or -
12:48:20 <L11> just specifies no functions
12:48:25 <L11> sorry was making me a meal :)
12:48:41 <FunctorSalad> @type sqrt -- why floatingpoint?
12:48:42 <lambdabot> forall a. (Floating a) => a -> a
12:48:44 <mauke> sbahra: it looks inefficient
12:48:45 <FunctorSalad> oh
12:48:59 <roconnor> conal: I assume Julian will reference other signed digit implemenations
12:49:08 <pumpkin> http://www.polyomino.f2s.com/david/haskell/hs/NumberTheoryFundamentals.hs.txt
12:49:31 <sbahra> @src genericLength
12:49:31 <lambdabot> genericLength []    = 0
12:49:31 <lambdabot> genericLength (_:l) = 1 + genericLength l
12:49:45 <sbahra> @src length
12:49:45 <lambdabot> Source not found. You untyped fool!
12:50:03 <marcot> paczesiowa: Isn't it being appended in the outside writer?
12:50:11 <sbahra> mauke, it doesn't need to be inefficient.
12:50:14 <conal> roconnor: yeah, thx.
12:50:16 <FunctorSalad> if length calculations are your bottleneck you should just keep track of the length seperately I think
12:50:29 <mauke> sbahra: how so?
12:50:43 <mauke> floating point addition is slower than plain Ints
12:50:56 <jeffersonheard> http://www.reddit.com/goto?id=7uecr -- since on the mailing list we're talking about CSS and layout atm
12:51:09 <sbahra> mauke, ah, ok. I see what you mean. :)
12:51:15 <Cheshire> chrisdone, what are you using it for?
12:51:20 <sbahra> mauke, I thought you meant it was inefficient compared to length even for integrals.
12:51:29 <FunctorSalad> how long would the list have to be for that to matter? better let the profiler speak ;)
12:51:42 <manicman> hi
12:51:48 <roconnor> don't use HTML for layout!!!
12:52:07 <FunctorSalad> well, I don't know how many cycles a float addition takes
12:52:48 <paczesiowa> marcot: now that you ask, I have no idea. if it succeeds, then it works, if it takes too long I get error without writer log. (I test with runErrorT . runWriterT )
12:52:55 <conal> jeffersonheard: author's conclusion: "And that is why, while CSS should be used for styling, tables should be used for layout."  alternatively, that's why to replace CSS & HTML with something more simple/powerful.
12:53:12 <roconnor> jeffersonheard: Have you seen byorgey's diagrams?  It seems similar to Heiroglyphs.
12:53:15 <beelsebob> conal: in your css thread on haskell-cafe, are we to assume we're starting from a) unstyled html b) something similar c) anything we fancy?
12:53:24 <roconnor> I'm thinking of eventually writing my own as well to add to the mix :)
12:53:26 <Twey> jeffersonheard: It's missing something, though
12:53:34 <Cheshire> beelsebob, you missed my question earlier
12:53:41 <beelsebob> Cheshire: hmm?
12:53:44 <Twey> Namely, the fact that that's not a flaw with CSS, but with IE
12:53:58 <conal> beelsebob: anything we fancy.  i'm happy to discard html in the process.
12:54:09 <Twey> CSS actually provides display: table-cell; and assorted other primitives that can be used to do the job properly.  They're just off-limits because IE doesn't support them.
12:54:15 <beelsebob> ah blast – that makes it a much harder problem
12:54:25 <jeffersonheard> roconnor, yes, I've seen it
12:54:26 <beelsebob> because I've been thinking about what a "document" is for a long time
12:54:50 <adamvo> is anybody acquainted with yi? I'm trying to remap a couple of keys for the vim layout, and I can't seem to find a simple way to do it, since those added keys need access to the 'count' which is hidden in Yi.Keymap.Vim
12:54:55 <marcot> paczesiowa: maybe you should try to see the output of the writer when it succeeds.
12:54:58 <conal> beelsebob: good!
12:54:59 <jeffersonheard> conal: agreed
12:55:26 <adamvo> none of the example user configurations seem to do that
12:55:32 <beelsebob> I was thinking down that line because LaTeX sucks, not because html sucks, but it probably kills two birds with one stone
12:55:57 <conal> one perspective is to start with the idea of iswim, but modernized to denotational Haskell (no IO).
12:56:17 <conal> (no IO, STM etc)
12:57:09 <paczesiowa> marcot: yeah, in case of success I get empty output writer
12:57:16 <paczesiowa> *writer's output
13:00:45 <paczesiowa> marcot: forkIO' should somehow tell to forked IO computation to share its "state" (writer's log) with main thread
13:01:59 <ichor> @pl \r -> (kf r) (kf r)
13:02:00 <lambdabot> ap kf kf
13:02:29 <mauke> @pl \kf r -> (kf r) (kf r)
13:02:29 <lambdabot> join ap
13:03:25 <baaba> :t \f x -> (f x) (f x)
13:03:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:03:26 <lambdabot>     Probable cause: `f' is applied to too few arguments
13:03:26 <lambdabot>     In the first argument of `(f x)', namely `(f x)'
13:03:26 <Cale> paczesiowa: That's unfortunately impossible, unless the main thread waits for the forked computation to finish.
13:03:41 <baaba> :t join ap
13:03:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
13:03:42 <lambdabot>       Expected type: m (a -> b) -> m (a -> b) -> a1
13:03:42 <lambdabot>       Inferred type: m (a -> b) -> m a -> m b
13:04:09 <SamB_irssi> how can I run GHCi on the modules of a cabal package without having to load everything interpreted or compile manually ???
13:04:17 <SamB_irssi> ('
13:04:22 <Cale> paczesiowa: I can think of a way to construct a monad which has a proper fork as well as writer-like capabilities.
13:04:25 <SamB_irssi> I've built it in this directory)
13:04:31 <Cale> paczesiowa: But not using WriterT
13:05:19 <roconnor> damn gtk2hs 0.10
13:05:36 <Cale> 0.10?
13:05:36 <paczesiowa> Cale: if it works, then WriterT instance for interleavableIO could be done in terms of that CaleMonad
13:05:53 <Cale> paczesiowa: The implementation of 'tell' would be different.
13:06:05 <Cale> paczesiowa: In particular, it would write to a Chan
13:06:33 <beelsebob> Cheshire: what was the question?
13:06:54 <roconnor> Cale: yes gtk-0.10.0
13:07:00 <Cheshire> beelsebob, Would you admit unsafePerfomMathematica or similar in theorem proving software?
13:07:18 <beelsebob> Cheshire: what would such a function do?
13:07:52 <Cale> beelsebob: Presumably evaluate/execute mathematica code? :)
13:08:01 <ichor> @pl \r -> (kf r) (ka r)
13:08:02 <lambdabot> ap kf ka
13:08:13 <Pegazus> Hi! I know it's not the channel but... Who created/invented/discovered or whatever Language Theory? (Automaton, finite machines, regular expressions, and all that stuff)?
13:08:31 <beelsebob> Cale: that's what I presume, but I'm just checking
13:08:56 <Cale> Pegazus: Lots of people...
13:09:44 <Pegazus> but who is the "father"? or the one who got the idea of an automaton first? or whatever? (i don't mean a turing machine, but a finite state automaton)
13:09:52 <beelsebob> Cheshire: assuming Cale's understanding is correct, then iff said mathematica code were referentially transparent
13:09:59 <BMeph> "The problem is particularly pernicious for layout. (One indication of this is how many CSS layout tutorials there are on the web.)" <-- Could the same be said for Monads? :)
13:10:00 <Cale> If you ask about one concept at a time, there are names... Turing obviously invented Turing machines, Church was a contemporary who invented the lambda calculus.
13:10:12 <Pegazus> and who invented the finite state machines?
13:10:36 <Gracenotes> the same guy who invented light switches, I think :P
13:10:47 <beelsebob> Gracenotes: no, surely fire
13:11:05 <edwardk> roconnor: good stuff (re: the thesis)
13:11:12 <Cale> My guess would be Turing as well, or one of his contemporaries, but that's just a guess. Various types of finite automata have names attached to them: Mealy and Moore come to mind.
13:11:15 <Gracenotes> imho, God invented finite state machines. Alive, Asleep, Coma, Dead.
13:11:19 <roconnor> edwardk: thanks
13:11:24 <Pegazus> O_o
13:11:26 <paczesiowa> marcot: do you think it would work with that writing to chan in instance for WriterT ?
13:11:27 <Cale> Kleene was responsible for a lot of the stuff dealing with regular languages.
13:11:33 <beelsebob> Pegazus: if by "language theory" you want to restrict yourself to state machine based things, and turing machines etc, then Alan Turing
13:11:41 <beelsebob> if you want any basis for functional programming, then Church
13:11:56 <Cale> Oh, and don't forget Emil Post
13:12:12 <beelsebob> but in reality, all sorts of people who invented all sorts of calculii that describe computation
13:12:17 <Pegazus> but i want to restrict myself to just finite state machines!
13:12:36 <beelsebob> well you're boring then ;)
13:12:37 <Pegazus> i don't care about describing computation, but about describing regular expressions
13:12:40 <Pegazus> -_-
13:12:51 <beelsebob> then you're going down the Turing line :)
13:13:08 <Cale> Well, Kleene is a big name there, regardless...
13:13:31 <Gracenotes> did Kleene 'invent' the Kleene star? Or was that Turing..?
13:13:36 <Cale> Kleene invented regular expressions
13:13:39 <beelsebob> Gracenotes: that was Turing
13:13:42 <Cale> along with the star
13:13:45 <conal> ichor: or kf <$> ka, which i prefer since Applicative is a more general/simple basis than Monad
13:13:49 <beelsebob> >.>
13:14:14 <beelsebob> conal: don't you mean <*>?
13:14:26 <conal> beelsebob: i sure do.  thanks!
13:14:40 <skorpan> @hoogle Gen a -> a
13:14:41 <lambdabot> Prelude id :: a -> a
13:14:41 <lambdabot> Data.Function id :: a -> a
13:14:41 <lambdabot> Test.QuickCheck generate :: Int -> StdGen -> Gen a -> a
13:14:47 <ichor> conal, thanks, but I'm proving the deduction theorem (in propositional logic), using the idea of the reader monad, so ap is fine.
13:15:22 <Cale> Hehe, "Kleeneliness is next to Gödeliness"
13:15:23 <conal> ichor: you could use the reader Applicative instead.  you might find it more elegant.
13:15:26 <xxxx19theking89x> hi
13:15:28 <xxxx19theking89x> !list
13:15:30 <beelsebob> Cale: BAD
13:15:41 <xxxx19theking89x> list!
13:15:49 <Cale> xxxx19theking89x: (x:xs)
13:15:51 <Gracenotes> ichor: is that modus ponens...?
13:16:00 * beelsebob rofls at Cale
13:16:03 <xxxx19theking89x> xs
13:16:12 <ichor> conal, that's an idea. But I've already written too much to change that decision.
13:16:12 <beelsebob> xxxx19theking89x: yes, xs is a list too
13:16:26 <conal> ichor: too bad.
13:16:27 <Gracenotes> it might be an empty though
13:16:28 <ichor> Gracenotes, more like the inverse, or dual to modus ponens.
13:16:29 <Gracenotes> -an
13:16:35 <xxxx19theking89x> where are the list?
13:16:36 <beelsebob> Gracenotes: still a list :)
13:16:47 <Cheshire> ichor, I thought deduction was a metatheorem
13:16:52 <beelsebob> xxxx19theking89x: Cale told you – (x:xs)
13:16:58 <Cale> xxxx19theking89x: They're ephemera, they don't exist at any particular location in space.
13:17:01 <conal> ichor: btw, ap == (<*>)
13:17:05 <xxxx19theking89x> italy
13:17:22 <Cale> xxxx19theking89x: Also, just so you're aware, this is not a warez channel ;)
13:17:27 <ichor> Cheshire, It is. I just get the feeling that what I'm doing is inverting the modus ponens.
13:17:27 <Gracenotes> ichor: ah, okay. b -> (a -> (a -> b))?
13:17:45 <Gracenotes> actually, not, b -> ((a -> b) -> a)
13:17:52 <conal> ichor: a substantive question is whether Applicative is sufficient, or you need Monad.
13:17:59 <Gracenotes> okay. That makes more sense >_>
13:18:20 <conal> ichor: specifically, can you use just fmap, ap & liftM, liftM2, ..., and eliminate all of your (>>=) uses.
13:19:05 <Gracenotes> hrm. Or I could just look it up on Wikipedia
13:19:39 * Heffalump wonders if building a lazy memo table of class dictionaries would work
13:19:48 <ichor> Gracenotes, the way I see modus ponens in haskell is that defining a constant is the same as using the reader monad.
13:20:01 <monadie> hpaste is broken?
13:20:11 <Cale> moonpatio.com:8080
13:20:37 <ichor> Gracenotes, so it is not just a function. It is transforming a program.
13:20:37 <Gracenotes> hm... well, (a -> b) -> a -> b == (a -> b) -> (a -> b)
13:21:14 <Cheshire> Gracenotes, if you can derive P from hypothesis G, then you can derive G -> P
13:21:33 <Cheshire> Gracenotes, {G} |- P => {} |- G -> P
13:21:52 <Cale> Modus ponens is function application, I suppose.
13:21:58 <conal> ichor: sounds like a neat project.  good luck.  a blog post when you're ready?
13:21:58 <Gracenotes> ah... I've seen something like that in type theory too :)
13:22:26 <Gracenotes> where G is the set of assumptions about the types
13:22:51 <ichor> conal, thanks, I dont have a blog currently. But it might be worth getting one just to post this and some similar stuff.
13:22:53 <Cale> Oh, you're talking about natural deduction?
13:23:18 <monadie> someone help me figure out how to use mutable array with state monad? i want to do something like: http://codepad.org/xyyt0OQC
13:23:26 <Cale> Heh, I suppose natural deduction is lambda :)
13:23:28 <Gracenotes> hm. That sounds interesting... Haskell is considerably rich
13:23:34 <conal> ichor: yeah!  and then get added to planet.haskell.org so your posts will pop up there.
13:23:42 <Cheshire> Gracenotes, rich how?
13:23:44 <roconnor> monadie: do you mean the ST monad?
13:23:46 <ichor> conal, i'll think about if Applicative is enough, though, it seems reasonable.
13:24:07 <monadie> roconnor: yes is ST = state transformer?
13:24:09 <Gracenotes> Cheshire: in terms of theory
13:24:16 <Cale> monadie: You apparently have not imported the appropriate libraries, in this case, import Data.Array.ST
13:24:26 <roconnor> @hoogle newArray
13:24:26 <lambdabot> Data.Array.Base newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:24:26 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:24:26 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:24:27 <Gracenotes> and Control.Monad.ST
13:24:31 <Cale> monadie: and you'll need  Control.Monad.ST as well
13:24:48 <Gracenotes> monadie: you won't need a state monad if you're dealing exclusively with STArrays
13:24:56 <Cale> get will be the wrong type there.
13:25:01 <conal> ichor: there's an easy way to find out.  restrict yourself to ap, liftM, ... (not (>>=)).  when it doesn't work, you'll know.
13:25:17 <Cale> s <- get  doesn't make sense. get is for the State monad, not ST.
13:25:23 <Gracenotes> monadie: although, if you want to use one, try StateT YourValue (ST s) (STArray s i e)
13:25:25 <Cale> (or StateT)
13:25:28 <conal> ichor: besides, your code will be more functional/applicative looking
13:25:31 <monadie> cale: how do i put stuff in then?
13:25:35 <Gracenotes> then you can do ST operations with lifting
13:25:45 <Cale> monadie: put stuff in?
13:25:56 <Cale> monadie: Take it as a function parameter?
13:26:01 <roconnor> damn.  darcs gtk2hs didn't build
13:26:03 <Cale> pair s = do ...
13:27:05 <CosmicRay> is there a way to get hackage to tell me what all depends on a given package?
13:27:12 <CosmicRay> sort of a "who uses this" sreen?
13:27:15 <CosmicRay> screen
13:27:17 <monadie> so i won't be able to modify the array and store some state as i traverse the array?
13:27:23 <conal> ichor: do you get something out of using Reader a b instead a -> b?
13:27:38 <Gracenotes> monadie: again, StateT YourValue (ST s) (STArray s i e), if you want to use some form of State for it
13:27:40 <roconnor> CosmicRay: me too
13:27:43 <Cale> monadie: you could use an STRef to store some state.
13:27:53 <Cale> monadie: But... I don't know what you're trying to do.
13:28:02 <Cale> State-transforming the ST monad sounds like the wrong thing to me.
13:28:13 <monadie> gracenotes: ok thanks that was what i was unsure of, i'm not quite sure what ST does on its own
13:28:39 <ichor> conal, I'm unsure, right now i'm just proving it using monadish functions. Afterwords I'll see how the meaning of the theorem changes if I change monad.
13:28:40 <Cale> monadie: It gives you an unbounded number of state variables called STRefs, and mutable arrays.
13:28:51 <Gracenotes> hm, entirely ST would work too. As a pair perhaps... your function could be of type ST s (STArray s i e, STRef s a)
13:28:58 <conal> ichor: nice!
13:29:04 <Cale> monadie: None of these are computation-global however, and references must be passed around.
13:29:44 <Cheshire> ichor, How do you state it in terms of monads?
13:29:44 <Cale> Gracenotes: ITYM  ST s (Int, Int)
13:30:09 <conal> ichor: and a reason to find out whether Applicative suffices, since you'll then be able to substitute different applicatives, not just different monads.  (there are more applicatives than monads.)
13:30:17 <Gracenotes> Cale: I mean, for storing both an array and extra state
13:30:27 <Gracenotes> that can be freely mutated in the ST monad
13:30:29 <conal> ichor: s/you'll/you'd/
13:30:29 <monadie> cool thanks for the help
13:30:47 * roconnor ponders type Context = Focus -> Object
13:30:56 <Cale> Gracenotes: well, okay. The combination of newArray with newSTref would give you a type like that.
13:31:16 <Cale> Gracenotes: but you wouldn't wrap them up like that, under ordinary circumstances :)
13:31:17 <Gracenotes> like it, I guess :)
13:31:35 <marcot> paczesiowa: Maybe you should test interleavableIO with forkIO' in some small tests in simple monads.
13:31:43 <Gracenotes> either way, you can do ST operations, extract them, and then runST
13:31:47 <marcot> paczesiowa: and check what happens when the computation is finished, and when it's not.
13:31:52 <Cheshire> ichor, I don't understand what you are doing
13:31:55 <Gracenotes> if it's in a StateT, just lift all the ST's
13:32:18 <marcot> paczesiowa: my guess is that it only writes to the outer writer when it finishes.
13:32:38 <ichor> Cheshire, I dont have the precise formulation in monads yet, but the central part is a transformation, than inserts ap and return in appropriate places.
13:33:04 <Cheshire> ichor, what is your input?
13:33:49 <ichor> Cheshire, sorry. At the moment I'm just proving the deduction theorem for a certain deduction system, which has haskell like syntax.
13:33:56 <Cale> StateT-transforming ST seems excessive. ReaderT would almost always do just as well.
13:34:09 <Cheshire> ichor, cool what system?
13:34:34 <Cale> But I caution against overuse of monad transformers.
13:35:17 <Cale> They're good when used carefully for constructing libraries, and there are some small local cases where they work well, but without some care, they easily turn things into a mess.
13:35:22 <ichor> Cheshire, a propositional calculus, with modus ponens as only inference rule.
13:35:35 <Cheshire> ok
13:36:18 <Gracenotes> Cale: hm... what kind of mess? Types and lifting all over the place?
13:36:23 <Cale> Gracenotes: yes
13:36:49 <ichor> Cheshire, the logical axioms are a set of simple functions, const, (,), fst, snd and so on.
13:36:58 <conal> ichor: btw, (ap,return) == (<*>,pure) == Applicative
13:37:00 <Cale> Basically, unless your use of the monad transformer only lasts about a line or so, you should be newtyping it.
13:37:22 <Cheshire> ichor, ok
13:37:39 <Cale> Monad transformers should almost never appear in the types of functions.
13:37:47 <Gracenotes> so long as both the non-transformed parts and transformed parts don't have to interface with too much shared functionality, it should be okay...
13:38:10 <paczesiowa> marcot: http://haskell.pastebin.com/m10a3aeea
13:38:32 <Gracenotes> but that is a good idea about the newtypes... I've seen it a lot, it would probably clean up type signatures in something I'm working on :)
13:38:46 <paczesiowa> marcot: oops, it chopped final character ('n') :)
13:38:50 <ichor> conal, then it seems I can do with Applicative. I haven't actually used it in haskell before. So it will be nice looking into it.
13:39:09 <Cale> Gracenotes: I wrote an article about it... http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
13:39:15 <paczesiowa> marcot: I never get any of those logs back
13:39:40 <conal> ichor: :)
13:39:43 <Cale> Gracenotes: The second thing you should do is to define all the operations of your transformed monad in terms of lift so that *no* lifts occur strewn throughout your code.
13:39:46 <Gracenotes> Cale: great, I shall read :)
13:39:49 <jvoorhis> conal: i finally read through the Simply Reactive paper and wondered if there is a predicate implementation for Reactive
13:40:02 <Cale> Gracenotes: They should all occur in the definitions of primitive computations of your new monad.
13:40:10 <conal> jvoorhis: as in Behavior Bool -> Event () ?
13:40:16 <ichor> Cheshire, I also would like to see what inductive types would be equivalent to in logic.
13:40:16 <marcot> paczesiowa: those logs with tell?
13:40:30 <paczesiowa> marcot: yeah
13:40:37 <Cale> paczesiowa: That's what I suspected would happen.
13:40:42 <conal> jvoorhis: e.g., implemented with interval analysis, as in Fran.  no, not yet.
13:40:57 <jvoorhis> conal: thanks, that's it
13:41:11 <paczesiowa> Cale: would it be easier to implement if we know that main thread always waits for subthreads?
13:41:16 <Cale> That, or you'd just hit bottom the minute there was a forkIO...
13:41:24 <Gracenotes> Cale: you mean, the functions to be used with the transformed monad should all begin with "do lift"? or something like?
13:41:26 <jvoorhis> conal: do you know of any other approach than IA?
13:41:29 <conal> jvoorhis: i'm about to play with interval analysis & derivatives again, for image rendering.  so maybe there'll be cross-over to Reactive.
13:41:40 <hackage> Uploaded to hackage: LslPlus 0.3.1
13:41:48 <Cale> Gracenotes: no -- I mean, you should pre-lift everything you plan on using and make new definitions
13:42:09 <conal> jvoorhis: well, there's affine analysis, etc.
13:42:14 <Cale> Gracenotes: and then wrap the whole thing up in a module so nobody can tell that you used monad transformers.
13:42:31 <conal> jvoorhis: and derivative-based root-finding methods.
13:42:46 <Cale> paczesiowa: Well... the trouble is, let's say just for concreteness that you're using the list monoid.
13:42:53 <ichor> \quit Cya!
13:43:04 <Gracenotes> Cale: makes sense. Does the article cover this?
13:43:09 <Cale> Gracenotes: yes
13:43:11 <Raynes> /fail
13:43:15 <Gracenotes> okay
13:43:24 <redditbot> Anyone tried this Haskell IDE ? How does it fare with emacs ?
13:43:41 <Cale> paczesiowa: What you'd probably want is for the elements of the resulting list to be an interleaving of the 'tell's from the subthread and from the main thread, but of course, the interleaving is nondeterministic.
13:43:45 <Gracenotes> even redditbot is doubting :3
13:44:13 <jvoorhis> conal: IA is probably the easiest for me to understand; is it still possible to download the Fran source?
13:44:23 <paczesiowa> Cale: in this particular example. there won't be anything logged from main thread
13:44:39 <Cale> well, okay, all the subthreads then.
13:44:43 <conal> jvoorhis: hm.  i don't know.  if so, it'd be from the old Fran page.
13:45:00 <jvoorhis> conal: i only found dead links to microsoft.com
13:45:03 <conal> jvoorhis: you could also pick up an IA lib on hackage.
13:45:10 <conal> jvoorhis: oops.
13:45:23 <paczesiowa> Cale: there is just one real subthread:>
13:45:34 <Cale> Oh, then you don't even need that much.
13:46:13 <Cale> There's little point in worrying about using forkIO in the WriterT transformed monad in that case.
13:46:39 <conal> btw, there's a fairly new subreddit for sharing your favorite pixels: http://www.reddit.com/r/pixels/
13:46:55 <beelsebob> @pl \x y -> liftA2 f x (sequence y)
13:46:55 <lambdabot> (. sequence) . liftA2 f
13:46:59 <paczesiowa> Cale: I wasn't worried, I just have no idea to make it work in easy case
13:46:59 <mstr> what does "Could not deduce (Num a) from the context ()" mean?
13:47:06 <Cale> paczesiowa: Okay...
13:47:29 <mauke> mstr: it probably means you used something as a number but didn't say so in the type signature
13:47:33 <Gracenotes> mstr: you may have to add a Num a =>
13:47:49 <Gracenotes> (possibly)
13:48:29 <conal> beelsebob: or (result.argument) sequence (liftA2 f)
13:48:56 <mstr> http://pastebin.com/f3da155a0
13:49:05 <mstr> I shouldn't have to add Num anywhere?
13:49:07 <Cale> paczesiowa: What is it that you're actually after?
13:49:36 <mstr> just can't figure out where I use something as a number
13:49:40 <Cale> paczesiowa: Limiting the amount of time that a WriterT w IO computation uses?
13:49:51 <Gracenotes> @src Num
13:49:52 <lambdabot> class  (Eq a, Show a) => Num a  where
13:49:52 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:49:52 <lambdabot>     negate, abs, signum     :: a -> a
13:49:52 <lambdabot>     fromInteger             :: Integer -> a
13:49:55 <paczesiowa> Cale: yes
13:50:13 <Cale> Presumably you have a timeout function which works for IO?
13:50:25 <eu-prleu-peupeu> hello
13:50:34 <paczesiowa> Cale: and there is some ErrorT in there. and later there can be more
13:50:43 <paczesiowa> Cale: yes
13:50:47 <Gracenotes> mstr: you probably used one of those... somewhere...
13:50:54 <eu-prleu-peupeu> how is teh hasking going ?
13:51:08 <Cale> My suggestion is just to run all the transformers before applying the timeout.
13:51:19 <Cale> Is there any reason that can't be done?
13:51:58 <mstr> error message isn't really helpful :P
13:51:59 <paczesiowa> Cale: but now I have "nice" generic code (MonadError e m, MonadIO m, MonadWriter m) =>, and if I write that timeout fun now, it will be fixed forever
13:52:06 <Cale> Presumably you've newtyped your monad transformer stack anyway, so the function used to run it won't change much.
13:52:15 <mauke> mstr: add more type signatures
13:52:29 <Tobsan> > Data.Bits.xor 5 6
13:52:30 <lambdabot>   Add a type signature
13:52:34 <Tobsan> gah
13:52:38 <int80_h> okay I have a map (+ x) [1..10]. I want to be able to change what x is but I can't visualize how that happens
13:52:43 <Tobsan> > Data.Bits.xor 5 6 :: Int8
13:52:44 <lambdabot>   3
13:52:48 <Tobsan> sweet!
13:52:54 <paczesiowa> Cale: I don't like newtypes, I limits me from what I can do. I just write code and use more and more features when I need them
13:53:02 <paczesiowa> *it limits
13:53:40 <Cale> Changing monads halfway through a project is like a miniature version of porting code from one language to another, and has a similar effect on code readability.
13:54:22 <int80_h> x in this case will be an incrementally od number. I need to control when it increments
13:54:48 <mauke> mstr: adding a type signature to swapWithHead will give you a big clue :-)
13:55:15 <Cale> (of course, it can be done, but usually work is needed to tidy things up when you do it regardless)
13:56:03 <Cale> Using the MTL classes is possible, but it's like paying for the mess up front, in that you end up with tons of horrible lifting everywhere, and types which are comparatively difficult to understand.
13:56:06 <mstr> mauke: I just did that and got a new error :)
13:56:38 <Cale> Better just to figure out which language you're going to write the thing in first, and then solve the problem.
13:56:52 <Cale> (at least, usually)
13:57:00 <Gracenotes> mstr: randomR :: RandomGen g => (a, a) -> g -> (a, g)
13:57:02 <paczesiowa> Cale: all those newtypes serve the purpose of limiting what we can do. I don't like that, I'd prefer some effect system, that knows I didn't touch that file, not because there is no such function in my monad, but because I didn't call that function.
13:57:08 <mauke> mstr: it's complaining about x !! k being used as a number
13:57:20 <mstr> mauke: !! binds to k, not (k - 1)?
13:57:25 <mauke> right
13:57:38 <paczesiowa> Cale: like checked exceptions in java combined with ddc
13:57:40 <Cale> paczesiowa: Well, you can always expose the full functionality of the underlying monads.
13:57:44 <mstr> ya, it compiled with parentheses. thx for the tip :)
13:57:58 <Cale> paczesiowa: They simply give you the ability to limit what can be done.
13:58:00 <mauke> more type signatures == better error messages
13:58:24 <Gracenotes> oh, the !! part is true... it should also seem that a would be inferred to be a Num by the randomR type signature, though
13:58:30 <Gracenotes> randomR (x,n-1)
13:58:38 <Gracenotes> type x == type (n-1)
13:58:43 <Gracenotes> unless I'm mistaken
13:58:49 <paczesiowa> Cale: creating final monad up front sounds great and is the right thing to do if you know what you are doing. I don't:)
13:59:05 <mauke> huh?
13:59:07 <Cale> paczesiowa: What is your problem space?
13:59:34 <mauke> in my experience, using a newtype lets you easily change the monad stack
13:59:36 <Cale> paczesiowa: Think of monads as libraries which just have a particular interface.
13:59:44 <Gracenotes> oh, never mind... shuffleIndexes doesn't deal with [a]'s, just Ints
13:59:52 <Gracenotes> my bad
14:00:17 <Cale> paczesiowa: You're writing a library to solve some problem... what kind of problem?
14:00:26 <paczesiowa> Cale: right now I have problem with my problem space:> right now I know I have to catch some exceptions, and carry some logs. but I don't know if later I won't need some state, or config
14:00:41 <Cale> (if you're constructing a new monad, you're writing a library)
14:01:07 <Cale> (of course, that's an opinion and not quite a fact :)
14:01:47 <paczesiowa> I'm basically writing smth so trivial it can be done in 10 lines of bash. but that's no fun, so I prefer to waste a few days and give up after writing few hundred lines of haskell
14:01:53 <mathijs> Hi all, is there some work underway to get ghc use some mathematical/logical rules? I mean 'filter (\x -> x^2 < 100)' will execute faster when ghc translates it to 'filter (\x -> x < 10)'. Also x `mod` 2 just needs to check the last bit of a number. And 'filter (<100) $ quicksort xs' can be improved to 'takeWhile (<100) $ quicksort xs' if ghc somehow recognizes that 'quicksort xs' is ordered. Al these optimizations would be possible at compile-t
14:01:56 <Cale> paczesiowa: hehe :)
14:02:03 <Cale> paczesiowa: What is the actual problem you're solving?
14:02:26 <paczesiowa> Cale: finding rar files in a directory:>
14:03:08 <mathijs> paczesiowa: http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html
14:03:19 <Cale> paczesiowa: Okay, so for some ideas of how that can be made simpler, you might look at the FilePath library by ndm, which generalises directory/file path construction and splitting.
14:03:55 <Cale> paczesiowa: It doesn't sound so monadic a problem space to me right away...
14:04:13 <Cale> paczesiowa: Other than the obvious file I/O, which you'd get out of the way right off.
14:05:06 <paczesiowa> Cale: it uses IO so it is monadic. there can be errors reading dir contents, (ErrorT, I hate IO Exceptions). I want to skip some read errors (but log them)
14:05:29 <paczesiowa> so I already have ErrorT and WriterT
14:05:33 <Cale> Why not just do all that in IO?
14:05:40 <_Jordan_> howdy folks
14:06:19 <Cale> The funny thing about monad transforming IO is that unless your transformer is ContT, you're probably not adding a whole lot that isn't already there in one way or another.
14:06:30 <paczesiowa> Cale: I think IO should be used for Input and Output. not for logging or error management
14:06:35 <Cale> Well, that's not entirely true
14:06:46 <Cale> ReaderT for instance...
14:07:02 <Cale> But a Chan would be fine for logging, especially if you're going to fork threads.
14:07:11 <mathijs> logging sounds IO to me. Read/write errors are IO too.
14:08:11 <paczesiowa> I want it to be done the right way. if I wanted it to be just done, I'd use find with -exec unrar :)
14:09:10 <Cale> Which way is the right way is dependent on the ways in which the code needs to be flexible.
14:09:33 <intoverflow> There's so much clever stuff in Haskell that it's easy to look at working code and deem it "unworthy"
14:09:50 <Cale> @quote initial
14:09:50 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
14:09:59 <Cale> ^^ this is relevant :)
14:10:27 <erikc> heh, nice quote
14:10:45 <Cheshire> what does initial mean?
14:10:47 <int80_h> initil?
14:10:49 <augustss> james mckinna?
14:10:52 <Cale> If you can solve your problem in a simple way which is easily projected into other spaces where you might need the solution, then you've done a good job. There's no need to consider those larger spaces all the time.
14:10:55 <int80_h> yeah I was thinking the same question
14:11:36 <Cale> In category theory, an initial object of a given category is one which has a unique arrow to any object.
14:12:01 <Cale> That is, an object A is initial, if for any object B, there is exactly one f: A -> B
14:12:55 <Cale> and thus, if you have an element of an initial object of your category, then you have an element of every other object of your category, by composing with the unique arrow.
14:13:40 <Gracenotes> not to mention, even in languages with side effects, cross-thread blocking queues are often used for logging. while multi-threaded I/O is kinda slow, logging I/O is slooooooooooow.
14:15:19 <Cale> I think McKinna's quote was originally in the context of using MonadPlus for failure vs. using Maybe for failure.
14:15:21 <Pegazus> Cale: I'd like to learn something about category theory (about monads really, but i understood it was extremely related)... Do you know any "brief" text, page, tutorial, book, or not too long thing that gives a "good introduction"? I already have backgrounds in computer science, math, haskell, etc...? (Papers are accepted if you know some good ones)... Would you mind advising me something to read? :)
14:15:42 <Cale> I can give you a great book PDF.
14:15:43 <marcot> paczesiowa: http://haskell.pastebin.com/m27f8825b
14:15:53 <Pegazus> thanks! what's the name?
14:15:58 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
14:15:59 <marcot> paczesiowa: This example show interleavableIO working, and not working with forkIO
14:16:07 <Cale> it's not short, but read as much as you like ;)
14:16:34 <Pegazus> ok.... i just want to know what categories and monads are all about... i don't really want to learn them right know... just to know what they are...
14:16:38 <Pegazus> and i can't access your link :(
14:16:39 <Cale> (apologies in advance for the slowness caused by any torrents I have running :)
14:16:40 <Cale> oh, okay
14:16:59 <Cale> I can describe what categories are.
14:17:03 <wli> What's it need the (++) in MonadPlus for? I'd expect it to need only Monad0.
14:17:05 <Adamant> Cale - link isn't orking
14:17:12 <int80_h> I don't see how you can know what a monad is without "learning them"
14:17:19 <mathijs> Adamant: it is here
14:17:21 <Cale> wli: It doesn't, but we no longer have MonadZero
14:17:23 <intoverflow> yeah, the link works
14:17:24 <Cale> Adamant: hmm
14:17:36 <wli> To learn monads, learn monad transformers.
14:17:37 <Adamant> Cale: I just tried again
14:17:41 <Adamant> it works now
14:17:43 <Pegazus> int80_h: you can know what graphs are, and what problems they help solve, and have an idea how, without knowing any graph algorithms....
14:17:46 <Cale> Adamant: okay.
14:17:53 <mathijs> let's labdadot Cale! :)
14:18:00 <Cale> Pegazus: based on others' experiences, maybe hammer it a bit :P
14:18:08 <Pegazus> hammer it? what do you mean?
14:18:17 <Badger> @botsnack
14:18:17 <lambdabot> :)
14:18:17 <lunabot>  :)
14:18:21 <Cale> Pegazus: try again until it works :)
14:18:26 <Pegazus> ahh. ok
14:18:42 <Pegazus> Dns unable to resolve cale.yi.org
14:18:43 <Cale> Pegazus: unless the DNS isn't resolving, in which case, it's probably a stupid DNS caching issue
14:18:46 <Cale> ah
14:18:47 <Pegazus> mind giving me an ip? :)
14:18:57 <wli> The std. Prelude is so clogged with legacy crap it's obstructing pedagogy.
14:19:11 <Badger> PING cale.yi.org (99.247.248.73) 56(84) bytes of data
14:19:23 <paczesiowa> marcot: thanks, I'll try to understand it
14:19:37 <Cale> 99.247.248.73 is correct
14:19:51 <Pegazus> http://99.247.248.73/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf seems to work :)
14:20:00 <Gracenotes> Pegazus: regarding knowing what graphs are... to the extend the analogy, you can probably say whether one problem can be modeled by a graph or not without knowing the specific algorithms
14:20:02 <Cale> great :)
14:20:03 <mathijs> wli: So what would be the solution? break with haskell98 compliance?
14:20:20 <Cale> Pegazus: okay, so perhaps join #haskell-overflow and I'll give an overview.
14:20:28 <wli> mathijs: Yes.
14:20:31 <Cale> (there's less scrolling there :)
14:20:32 <Pegazus> i don't want to know really how to solve problems with monads, but i want to know what problems can be solved with monads...
14:20:34 <Gracenotes> Pegazus: er, did I say what you said in another way? Either way, it's a good analogy :)
14:20:47 <Pegazus> so the day i have a problem they can solve, i search them, learn them, and use them :)
14:20:56 <Cale> Pegazus: But you should know that the category theoretic approach to monads won't give you a great idea of how they're used for programming.
14:21:28 <Pegazus> i want to know a little about both.... i find theory more usefull than most ppl i know :)
14:21:51 <mathijs> wli: is there any planning in that direction that you know of? I'm learning haskell and I find I'm a bit overwhelmed by the number of standard prelude functions that are almost the same, or that should not be used anymore.
14:22:22 <Pegazus> mathijs: while you are learning, it "might" be a good idea, to write all functions yourself...
14:22:25 <int80_h> Cale: I'll go to #haskell-overflow if you want to do that overview
14:22:26 <mopped> @src map
14:22:27 <lambdabot> map _ []     = []
14:22:27 <lambdabot> map f (x:xs) = f x : map f xs
14:22:29 <Pegazus> later on, you might start using the "std" ones....
14:22:40 <wli> mathijs: Everyone willing to work on it is not quite capable, and everyone capable of working on it is preoccupied with other things.
14:22:48 <Badger> "flib"
14:22:50 <Badger> e
14:22:50 <Pegazus> it's not good to "reinvent" the wheel every time, but it can be educative sometimes :)
14:22:53 <Badger> > "flib"
14:22:54 <lambdabot>   "flib"
14:23:03 <int80_h> educative?
14:23:21 <mopped> > map'cps f [] k = []; map'cps f (x:xs) k = (f x $ \f'x -> k f'x):(map'cps f xs k)
14:23:22 <lambdabot>   <no location info>: parse error on input `='
14:23:32 <mopped> what's wrong with that function?
14:23:36 <mathijs> wli: but isn't there some pre-alpha plan for a haskell2010 standard or something?
14:23:52 <Cale> int80_h: It's in progress...
14:24:08 <Adamant> Cale: thank you
14:24:10 <paczesiowa> mopped: map' cps f [] k = k [], I think
14:24:10 <Heffalump> rather stuttering progress!
14:24:33 <mopped> perhaps, but it doesnt even compile at the moment
14:25:09 <Cheshire> @let cons'cps x xs k = k (x:xs)
14:25:09 <lambdabot>  Defined.
14:25:29 <mopped> oh? does the continuation happen after everything?
14:25:42 <Gracenotes> it's simple-ish enough to write something as CPS, but actually using it seems rare..
14:25:55 <adekoba> how does one avoid needing dependent types? In this situation, I need GADT's, but along with that comes more type confusion.
14:26:01 <Cheshire> mopped, and map'cps should take CPSd parameters, like f'cps
14:26:12 <mopped> aha
14:26:29 <Cheshire> adekoba, why have you used the GADT(s) for? (paste it?)
14:26:32 <mmorrow> mapC f [] = []; mapC f (x:xs) = f x (\y -> y : mapC f xs)
14:27:19 <adekoba> Cheshire: my constructors have instrinsic properties (h/o, i'll paste)
14:28:39 <mmorrow> , let mapC f [] = []; mapC f (x:xs) = f x (\y -> y : mapC f xs) in mapC (\x k -> x : k x) [0..4]
14:28:40 <lunabot>  [0,0,1,1,2,2,3,3,4,4]
14:28:45 <adekoba> Cheshire: http://pastebin.com/m32c829d9
14:29:20 <Gracenotes> that's map.. :?
14:29:46 <roconnor> @type partitionEithers
14:29:47 <lambdabot> Not in scope: `partitionEithers'
14:29:52 <marcot> paczesiowa: I think forkIO is not good with IORef
14:29:53 <roconnor> @type partitionEithers
14:29:54 <lambdabot> Not in scope: `partitionEithers'
14:30:00 <roconnor> @hoogle partitionEithers
14:30:00 <lambdabot> No results found
14:30:04 <marcot> paczesiowa: maybe if interleavableIO uses MVar it could work.
14:30:06 <roconnor> @hoogle partitionEither
14:30:07 <lambdabot> No results found
14:30:22 <roconnor> @hoogle ([Either a b] -> ([a],[b])
14:30:22 <lambdabot> Parse error:
14:30:22 <lambdabot>   --count=20 "([Either a b] -> ([a],[b])"
14:30:22 <lambdabot>                                        ^
14:30:26 <roconnor> @hoogle [Either a b] -> ([a],[b])
14:30:27 <lambdabot> No results found
14:30:34 <roconnor> screw you
14:30:55 <Cheshire> :t map (either (first . (:)) (second . (:)))
14:30:56 <lambdabot> forall a b. [Either a b] -> [([a], [b]) -> ([a], [b])]
14:31:03 <tromp__> > foldr (\x->(x:).(x:)) [] [0..4]
14:31:05 <lambdabot>   [0,0,1,1,2,2,3,3,4,4]
14:32:00 <Deewiant> roconnor: Data.Either.partitionEithers :: [Either a b] -> ([a], [b])
14:32:10 <Deewiant> base >= 4
14:34:08 <Cheshire> @free compose :: [a -> a] -> (a -> a)
14:34:09 <lambdabot> (forall g. (forall h k. f . h = k . f                        =>                         g h = k)           =>            $map g xs = ys) => f . compose xs = compose ys . f
14:35:38 <Deewiant> white                               space
14:35:45 <int80_h> is #haskell-overflow logged?
14:36:03 <int80_h> cale is explaining category theory in there and I'd like to tget the benefit
14:36:34 <Gracenotes> oh, so it's not a flooding overflow channel... er :\
14:37:20 <paczesiowa> "cale is explaining category theory in there" that sounded like "neo is fighting morpheus"
14:37:45 <Cheshire> mopped, did you get it?
14:37:57 <BMeph> paczesiowa: More like "Paul Graham is calling something 'blub' in there" ;p
14:38:38 <glguy> int80_h, That seems like a good question to ask the people in #haskell-overflow ;)
14:39:59 <lament> neo is fighting paul graham
14:40:10 <BMeph> lament: I wish! ;)
14:40:29 <lament> BMeph: indeed, no amount of lisp mastery would save him :)
14:41:27 <mmorrow> , let mapC' f a [] = []; mapC' f a (x:xs) = f a x (\a -> mapC' f a xs) in mapC' (\a x k -> replicate a x : k (a+1)) 1 [0..5]
14:41:28 <lunabot>  [[0],[1,1],[2,2,2],[3,3,3,3],[4,4,4,4,4],[5,5,5,5,5,5]]
14:41:41 <hackage> Uploaded to hackage: llvm 0.6.2.0
14:42:19 <mmorrow> , let mapC' f a [] = []; mapC' f a (x:xs) = f a x (\a -> mapC' f a xs) in mapC' (\a x k -> let xs = replicate a x in xs : k (sum xs)) 1 [0..5]
14:42:21 <lunabot>  [[0],[],[],[],[],[]]
14:42:32 <mmorrow> , let mapC' f a [] = []; mapC' f a (x:xs) = f a x (\a -> mapC' f a xs) in mapC' (\a x k -> let xs = replicate a x in xs : k (sum xs)) 1 [1..5]
14:42:33 <lunabot>  [[1],[2],[3,3],[4,4,4,4,4,4],[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
14:43:16 <mmorrow> , let mapC' f a [] = []; mapC' f a (x:xs) = f a x (\a -> mapC' f a xs) in mapC' (\a x k -> let xs = replicate a x in xs : k (sum xs - a)) 1 [2..5]
14:43:17 <lunabot>  [[2],[3],[4,4],[5,5,5,5,5,5]]
14:43:25 <redditbot> Monomorphism and Defaulting
14:44:22 <ali_clark> , 4+2+4+2+4+2+4+2+4+2+4+2+4+2
14:44:24 <lunabot>  42
14:46:51 <sbahra> , 6 * 7
14:46:51 <lunabot>  42
14:47:36 <ali_clark> mine is a more elegant solution
14:48:54 <lament> category theory seems a lot more approacheable with examples from Hask...
14:49:18 <koeien> no i don't agree :)
14:49:22 <skorpan> is there any configuration for telling cabal to ignore upgrades for a specific package?
14:50:12 <byorgey> lament: it is if you already know Hask =)
14:50:17 <lament> koeien: the difference between different arrows from a to b certainly becomes obvious
14:50:29 <ehird> @hoogle unsafeCoerce
14:50:29 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:50:32 <lament> byorgey: well yeah...
14:50:34 <koeien> lament: why is this any different from Set
14:52:01 <koeien> lament: also, if you have a monoid, it defines a category with object * and arrows the elements
14:52:13 <koeien> lament: which is another example of a category with a lot of different meanings for the arrows
14:52:18 <lament> koeien: i guess it isn't, but the notation might be less ambiguous and easier to express over IRC when you just use haskell examples
14:52:42 <roconnor> @type callCC
14:52:43 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:53:11 <roconnor> @instances MonadCont
14:53:11 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
14:53:21 <koeien> lament: you can argue about that. i heard here that Hask is not the nicest category in the world. i would start with Set and a monoid instead of with Hask
14:53:23 <yitz> nice - unicode support for handles!
14:53:39 <dcoutts> skorpan: yes, use install instead of upgrade
14:53:52 <dcoutts> yitz: indeed :-)
14:54:09 <yitz> but can anyone explain this really weird type signature: hSetEncoding :: Handle -> TextEncoding -> IO ()
14:54:18 <roconnor> (a,a->r) -> r
14:55:04 <yitz> i mean - i would never expect to find in Haskell setCar :: [a] -> a -> IO (). so why this?
14:55:17 <Cheshire> yitz, hah
14:55:30 <glguy> yitz, it sets a property on the Handle
14:55:40 <ksf> CSS!
14:55:43 <glguy> that will be relevant next time you use that handle
14:55:50 <skorpan> dcoutts: but what if i want to upgrade every updated package except for this particular one?
14:55:53 <ksf> let's do workstation graphics with CSS!
14:55:56 <yitz> glguy: so how is that different than setting the head of a list?
14:56:04 <loadquo> yitz: It is similar to writeArray
14:56:05 <glguy> yitz, lists are immutable
14:56:06 * ksf collapses into a heap of facepalm
14:56:07 <dcoutts> skorpan: use --constraint=
14:56:18 <Cheshire> yitz, it's not
14:56:22 <loadquo> @type writeArray
14:56:23 <lambdabot> Not in scope: `writeArray'
14:56:25 <chessguy_work> 'ello
14:56:27 <dcoutts> skorpan: like --constraint="foo == 1.0"
14:56:30 <polveroj> yitz: it isn't really, but handles are already in IO so people don't feel bad about it.
14:56:56 <polveroj> (s/handles/most handle operations)
14:57:04 <Saizan> you'd want hSetEncoding :: Handle -> TextEncoding -> IO Handle?
14:57:08 <glguy> :t hGetChar
14:57:09 <lambdabot> Not in scope: `hGetChar'
14:57:17 <Cheshire> I can not force myself to write this parser :(
14:57:20 <Saizan> keeping the old Handle with the old encoding?
14:57:29 <glguy> hGetChar :: Handle -> IO Char
14:57:32 <Riastradh> Why not hWithEncoding :: Handle -> TextEncoding -> Handle?
14:57:34 <Saizan> and maybe at the same position in the file?:)
14:57:45 <glguy> would you have expected : hGetChar :: Handle -> IO (Char, Handle)?
14:57:56 <yitz> Saizan: yes, for example
14:57:59 <Saizan> Riastradh: because Handles are like IORefs
14:58:00 <glguy> or -IO rather
14:58:01 <Cheshire> the IO bindings are low level, they match the C library
14:58:12 <yitz> glguy: no, that would not be needed
14:58:15 <Cheshire> If you want a declarative IO -- what better to implement it in terms of?
14:58:18 <Saizan> they are just a reference for something that gets destructively changed
14:58:29 <dcoutts> yitz: that would almost work for read-only random access files
14:58:48 <Riastradh> Why does switching the encoding affect the external world?
14:58:49 <dcoutts> yitz: but it doesn't work for mutable files or files that are not seekable (pipes, sockets)
14:59:04 <dcoutts> Riastradh: it's a property of a mutable object, the handle
14:59:10 <Riastradh> Why, dcoutts?
14:59:22 <dcoutts> Riastradh: you mean why are Handles mutable objects?
14:59:31 <yitz> dcoutts: why - reading off a pipe changes its encoding?
14:59:52 <Riastradh> Why can't the handle be an immutable object that has a reference to mutable state, with multiple handles sharing common state but differing in, say, encoding?
15:00:05 <dcoutts> yitz: you cannot duplicate a Handle and have a different encoding
15:00:15 <glguy> I like being able to write: hSetEncoding stdin ...
15:00:33 <glguy> so that getLine does what I expect
15:01:08 <Riastradh> For example, if handles yielded only octets, then I could write:  data CodedHandle = CodedHandle Handle Codec.  And I could make several coded handles atop a common octet handle, each one decoding according to different codecs (and I'd use them at different times).
15:01:15 <dcoutts> yitz: what do you expect to happen when you getChar with the old handle and then again with the new Handle that has a different encoding?
15:01:29 <polveroj> There are models of file access (eg Iteratees) where encodings would be layerable, pure transformations.  Handles are unfortunately not such a model.
15:01:32 <dcoutts> yitz: do they interleave reading chars from the underling file in different encodings?
15:01:43 <Riastradh> Why shouldn't they interleave, dcoutts?
15:01:54 <yitz> A Handle is somewhere in between a file and my runtime. I guess I should think of it as being closer to the file.
15:01:58 <dcoutts> Riastradh: it's possible, it's just bonkers :-)
15:02:04 <Riastradh> Why is it bonkers?
15:02:22 <yitz> e.g. writeFile "foo" stuff also has type IO ()
15:02:36 * Philippa_ has an announcement to make
15:02:55 * dcoutts pauses to await Philippa_'s announcement
15:02:58 <Philippa_> there's a new Haskell channel - #haskell-in-depth
15:03:07 <Cheshire> Philippa, but it's dead
15:03:14 * sbahra wonders what #haskell-in-depth is for
15:03:43 <yitz> is this kind of the oposite of splitting off beginners from cafe?
15:04:02 <Philippa_> #haskell's getting pretty big these days, so #haskell-in-depth is for some of the discussions that it's difficult to find 'room' for in here now - in-depth discussion where people need room to think without finding 10KB of scrollback
15:04:16 <Philippa_> what shouldn't be in there is beginner explanations of monads :-)
15:04:19 <koeien> i'll join ;)
15:04:39 <Philippa_> Cheshire: it's not dead, it's birthing. That's why there's not a lot of people in there - and the nature of small chans is less conversation
15:05:27 * sbahra wonders why "slow discussions" can't be done here
15:05:39 <SamB_irssi> sbahra: look at the scroll rate!
15:05:41 <sbahra> slow-paced discussion, that is.
15:05:42 <mauke> @vixen
15:05:42 <lambdabot> love is all you need, you know?
15:06:05 <dcoutts> Riastradh: my specific example was bonkers, but more generally the properties of the Handle are tied to that handle, using multiple handles to read from the same underlying source is not useful and it is tricky to implement
15:06:18 <Philippa_> sbahra: just accept that not everyone's mind works the same as yours and some people have trouble handling it?
15:06:52 <sbahra> Philippa_, that isn't a relevant answer to my question.
15:07:16 <Philippa_> sbahra: it's a perfectly adequate explanation of why some people can't participate in such discussions in here
15:07:26 <Philippa_> that alone is a reason to look at another venue
15:07:27 <koeien> there is imo plenty of time to ask "larger questions". but sometimes it gets busy, that's true
15:07:34 <sbahra> Philippa_, ok.
15:07:37 <ksf> sbahara, sometimes #haskell has a scroll speed of 100 lines per second, that's not the atmosphere where you want to think before writing.
15:07:42 * sbahra just gets worried when resources are fragmented 
15:07:50 <yitz> until now, there was no problem thinking about a Handle as being closer to my runtime - I thought it represents a connection, but not the state in the connection. I can retrieve that state from the Handle, just as I can read data from the Handle.
15:07:51 <chessguy_work> Philippa_, isn't that what haskell-overflow was for?
15:08:01 <yitz> so there would be no problem in duplicating it.
15:08:29 <SamB_irssi> sbahra: personally, I'm more worried about the length of the name relative to my screen width back home ;-)
15:08:32 <yitz> in short, I thought of a Handle as a functional thing, that stands for an IO thing.
15:08:34 <Riastradh> dcoutts, tricky to implement?  All that one needs is a notion of a source of octets in order to implement a source of, say, Unicode code points by decoding UTF-8.
15:08:44 <yitz> but now we must think of it as being the IO thing itself
15:08:50 <Philippa_> chessguy_work: overflow's not very well-specified, and it doesn't really have much identity in its own right. We're hoping that -in-depth will be more viable in that regard, something that people seek to use in the first place
15:09:04 <dcoutts> Riastradh: yes but you're proposing to duplicate that each time you to a mutable operation on the handle
15:09:13 <Riastradh> Huh?
15:09:14 <conal> yitz: what is IO other than a functional value that stands for IO?
15:09:19 <Riastradh> When did I say anything about duplication?
15:09:23 <roconnor> @djinn (a,a->r) -> (b -> a) -> (b,b -> r)
15:09:23 <lambdabot> -- f cannot be realized.
15:09:26 <conal> yitz: i.e., for imperative computation.
15:09:32 <yitz> dcoutts: we're not duping the fd, we're duping the symbol that stands for it
15:09:32 <Riastradh> (duplication per mutable operation)
15:09:36 <dcoutts> Riastradh: you're proposing to duplicate the internal state of the handle when you hSetEncoding
15:09:48 <sbahra> chessguy_work, how is your logic library/tool going?
15:09:56 <dcoutts> Riastradh: the byte and character buffers in the Handle
15:09:58 <mathijs> Is there a way to find out if 2 functions are equal? I guess ghc might be able to find out if it compiles to exactly the same binary, so are there any functions/tools for this? Lots of times is refactor funtions (myFunc to myFunc') by writing them in terms of some other function, so I would like to be sure they do the same in the end.
15:10:08 <chessguy_work> sbahra, i just finally got my macbook back yesterday
15:10:09 <sbahra> mathijs, no
15:10:12 <Riastradh> dcoutts, why is there any need to duplicate buffers?
15:10:21 <chessguy_work> sbahra, and i'm a little swamped right now
15:10:24 <yitz> conal: does it stand for the IO itself, or a way to get at the IO?
15:10:25 <dcoutts> Riastradh: because different encodings cannot share them
15:10:35 <Riastradh> Why can't different coding systems share octet buffers?
15:10:37 <dcoutts> Riastradh: since they are mutable
15:10:47 <Saizan> mathijs: a good way is to write quickcheck properties for them
15:11:04 <conal> yitz: i don't know.  what's the IO?
15:11:04 <yitz> conal: until now that distinction wasn't important given the implementation
15:11:04 <Philonous> mathijs: This is an undecidable problem. Two functions might look completely different and yet be identical.
15:11:06 <mathijs> hm... just write some tests with different inputs and check if the output stays the same?
15:11:17 <Riastradh> dcoutts, as long as there is a getOctet :: OctetHandle -> IO Octet, why do the coding systems care about any octet buffers inside the OctetHandle?
15:11:19 <yitz> conal: so we weren't precise about the semantics
15:11:21 <chessguy_work> sbahra, also, someone pointed out that my implementation kind of sucks, and i haven't decided if/how i want to fix it
15:11:33 <dcoutts> Riastradh: it might be possible to share the byte buffers but it's a lot harder and its pointless, you cannot actually usefully read from the same handle interleaving two encodings like that
15:11:34 <sbahra> chessguy_work, several of us did.
15:11:38 <mathijs> Philonous: yeah, but there's a big chance a compiler will produce the same result in the end right?
15:11:51 <sbahra> chessguy_work, but it was still useful.
15:11:57 <dcoutts> Riastradh: but it's not that simple at all. You cannot build a Char layer on top of getOctet :: OctetHandle -> IO Octet
15:12:06 <Riastradh> Why not, dcoutts?
15:12:10 <dcoutts> Riastradh: getting a Char out of a Handle can pull many bytes
15:12:13 <Saizan> mathijs: yeah, or Test.QuickCheck properties, where the testcases are generated automatically
15:12:15 <Riastradh> Sure.
15:12:18 <chessguy_work> sbahra, uh, no, you pointed out some improvements, but not the main thing
15:12:30 <mathijs> Saizan: that sounds useful... I'll have a look
15:12:30 <dcoutts> Riastradh: and we still expect it to be atomic wrt other ops and we expect to be able to lookahead
15:12:31 <yitz> conal: there is a thing called a "file handle" that OSes provide. Is a haskell Handle a file handle, or is it a name for a file handle?
15:12:32 <Philonous> mathijs: That depends on how you build up the functions. It might produce the same code. So you might be able to identify them. But on the other hand you might not.
15:12:38 <chessguy_work> but you know what, if you think it sucks, then you can implement it yourself
15:12:42 <chessguy_work> have fun
15:12:48 <Riastradh> dcoutts, sorry, where did atomicity enter into this?
15:12:49 <dcoutts> Riastradh: and not peterb the state of the byte layer when we find an invalid char encoding
15:13:04 <dcoutts> Riastradh: you can read from a Handle from multiple threads
15:13:21 <sbahra> chessguy, you're too defensive (or nothing). :-/
15:13:25 <yitz> conal: if it's a file handle, you can't easily duplicate it just to change the encoding. but if it is only a name for one, you can have two different names that, when used, provide two different encodings
15:13:27 <sbahra> chessguy, s/or nothing/over nothing/
15:13:40 <sbahra> chessguy, I had issues with how you were handling interpretations.
15:13:56 <chessguy> sbahra, no doubt you'll fix them
15:14:00 <sbahra> chessguy, and in fact, the way you were handling them does not translate well from the formal definition of PL.
15:14:01 <yitz> conal: since encoding is not part of the meaning of the underlying OS file handle
15:14:02 <Riastradh> OK, so you need atomic transactions on the handles, and something slightly more complex than getOctet.  Don't we have fancy STM transactions these days?
15:14:03 <chessguy> sbahra, when you do it the right way
15:14:18 <sbahra> chessguy, :-/ Wow.
15:14:40 <conal> yitz: so a "name" might have some additional semantics, like conversion.  if so, i might look for an alternative to the word "name".
15:14:49 <yitz> conal: true
15:14:49 <dcoutts> Riastradh: right, you need access to the byte buffer so you can inspect bytes without draining the byte buffer. Then when we commit at the higher level we can remove them from the byte buffer.
15:15:02 <adekoba> i'm having difficulty with GADT's. How would I go about constructing a function like this: http://pastebin.com/m39dab89b
15:15:16 <dcoutts> Riastradh: this is all especially important if you expect to be able to share the underlying byte layer.
15:15:47 <FunctorSalad> do I fail at find/grep or is there not a single rewrite pragma in the standard libraries?
15:16:04 <FunctorSalad> (I expected things like the monoid laws...)
15:16:08 <skorpan> is there any way to make a .cabal file not --make but instead just -S or something?
15:16:19 <Cheshire> adekoba, it's not possible
15:16:23 <SamB_irssi> skorpan: hmm ?
15:16:29 <Saizan> adekoba: what error are you getting? maybe you just need to add dumbRead :: forall a. String -> Frame a
15:16:38 <yitz> dcoutts: so I see why it was done that way - in practice it could take a lot more work to support a higher-level view of handles, for some handle types.
15:16:40 <Cheshire> you need two reads
15:16:45 <SamB_irssi> skorpan: I don't think Cabal should be using --make anyway ...
15:16:53 <SamB_irssi> note the should!
15:17:00 <Cheshire> one that reads Frame Texts, one that reads Frame Numbers
15:17:05 <Riastradh> dcoutts, anyway, the critical implying complexity of handles sharing I/O devices, which didn't come up earlier, was the atomicity requirement.
15:17:09 <skorpan> SamB_irssi: when i use -S in the .cabal file and build, it tells me it can't --make and -S at the same time
15:17:12 <adekoba> Cheshire: not in that form, I agree, but is there some way to provide the same functionality?
15:17:30 <adekoba> Saizan: "Couldn't match expected type `Text' against inferred type `Number'"
15:17:30 <SamB_irssi> skorpan: when I say "should", I mean "someone should change the code"
15:17:32 <Cheshire> you could make a general thing that packages up the type into an existential, then when you destruct it you can choose what to do based on the type
15:17:44 <skorpan> SamB_irssi: ah, i get it! :)
15:18:13 <adekoba> Saizan: I get that even with the type signature
15:18:19 <Saizan> adekoba: you can write two instances of read, one for Frame Text and the other for Frame Number
15:18:22 <skorpan> is there any suitable major mode in emacs for cabal files?
15:18:39 <FunctorSalad> skorpan: haskell-mode has a cabal-mode included
15:18:40 --- mode: ChanServ set +o Philippa_
15:18:45 <FunctorSalad> I think...
15:18:46 <Saizan> adekoba: it moslty depends on how you want to use dumbRead
15:18:47 <yitz> oh oh
15:18:48 --- topic: set to '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell" "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by Philippa_
15:18:52 <skorpan> FunctorSalad: i didn't get cabal-mode included...
15:19:04 --- mode: Philippa_ set -o Philippa_
15:19:19 <adekoba> Saizan: that's a problem, however, because when I'm parsing a string, I don't know if it's a "Text" or a "Number"
15:19:26 <skorpan> FunctorSalad: actually, i did, sorry. just haven't loaded it.
15:19:32 <Philippa_> yitz: not every opping is for a kicking :-)
15:19:33 <adekoba> Saizan: so it would be impossible to direct it to the correct function
15:19:47 <yitz> Philippa_: if you're changing the topic, could you at least fix the missing comma please?
15:20:22 <Cheshire> adekoba, packing into an existential paired up with the code of a type fixes that...
15:20:22 <yitz> after reddit
15:20:42 <Saizan> adekoba: right, then you want an existential wrapper
15:20:48 --- mode: ChanServ set +o Philippa_
15:21:05 <dcoutts> Riastradh: yes, it's a bit subtle and does make it a good deal harder.
15:21:07 --- topic: set to '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by Philippa_
15:21:18 --- mode: Philippa_ set -o Philippa_
15:21:26 <benmachine> hurrah
15:21:58 <SamB_irssi> Philippa_: why still hpaste.org ?
15:22:02 <SamB_irssi> @hpaste
15:22:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:22:05 <SamB_irssi> hmm.
15:22:16 <SamB_irssi> oh, I guess cale didn't manage to rebuild her yet.
15:22:37 <yitz> SamB_irssi: this has been under discussion. was a decision reached?
15:22:51 <SamB_irssi> yitz: isn't hpaste.org still down ?
15:23:08 <SamB_irssi> a down site is not useful!
15:23:16 <adekoba> Cheshire, Saizan: :D. That would work.
15:23:26 <yitz> SamB_irssi: it is. one option is pointing hpaste.org to hpaste2. then we wouldn't change @hpaste
15:23:57 <yitz> SamB_irssi: it is down. it is not useful, right. :)
15:24:26 <yitz> SamB_irssi: anyway, in the meantime use @where
15:24:29 <Philippa_> SamB: because that's what's in the topic :-) I haven't been following the issue, probably better if another op takes it up
15:24:32 <yitz> @where hpaste2
15:24:32 <lambdabot> http://moonpatio.com:8080/
15:25:03 * SamB_irssi ponders hitting the big red @where op button
15:25:17 <yitz> SamB_irssi: you don't need to be an op for that.
15:25:42 <mopped> > map'cps f'cps (x:xs) k = f'cps x $ \f'cps'x -> k f'cps'x $ \k'f'cps'x -> cons'cps k'f'cps'x (map'cps f'cps xs k) k
15:25:43 <lambdabot>   <no location info>: parse error on input `='
15:26:07 <yitz> mopped: you deserve a parse error for that
15:26:20 <Cheshire> mopped, you shouldn't be using k twice though
15:26:50 <mopped> hm true
15:27:00 <mopped> When should k be applied?
15:27:04 <ddarius> @users
15:27:04 <lambdabot> Maximum users seen in #haskell: 678, currently: 648 (95.6%), active: 36 (5.6%)
15:27:06 <Cheshire> mopped, so starting with   k (cons (f x) (map f xs))
15:27:09 <Cheshire> you get
15:27:14 <Cheshire> f'cps x $ \f'x ->
15:27:24 <Cheshire> cons'cps f'x $ \cons'f'x ->
15:27:26 <Cheshire> ...
15:28:16 <SamB_irssi> you know, I think I just found a problem in the Haddock markup in Haddock ...
15:29:06 * roconnor tries to remember how to program without dependent types
15:29:38 <yitz> roconnor: program with values instead of types
15:30:00 <ddarius> roconnor: Just do what you did at the type level of the dependently typed language.
15:30:13 <roconnor> but every branch of your case statements have the same type.
15:30:18 <roconnor> it's so weird.
15:30:27 <ddarius> roconnor: Use GADTs.
15:30:30 <roconnor> ya
15:30:37 <yitz> roconnor: use existentials
15:30:56 <roconnor> yitz: same as using GADTs right?
15:31:00 <roconnor> well
15:31:03 <roconnor> included by
15:31:54 <yitz> roconnor: use olegese
15:32:03 <roconnor> that's what I'm thinkig
15:32:20 <roconnor> did oleg's OOHaskell use IORefs for objects?
15:32:38 <Saizan> yes, they were mutable
15:32:45 <roconnor> bah
15:32:52 <roconnor> screw OOP
15:33:12 <int80_h> okay, I have a function "foo" that I want to map the natural numbers over. I need one argument to be the next odd and another argument to be the next even. What does the call to map look like.
15:33:49 <mauke> map (\n -> foo (2 * n - 1) (2 * n))
15:34:15 <ddarius> They don't have to be mutable.
15:34:22 <yitz> zipWith foo ns (tail ns)
15:34:29 <roconnor> > [(1,2),(3,4)..]
15:34:30 <lambdabot>       No instance for (Enum (t, t1))
15:34:30 <lambdabot>        arising from the arithmetic seque...
15:34:31 <ozy`> > let forever f = f `seq` forever f in "not that this is useful"
15:34:32 <lambdabot>   "not that this is useful"
15:35:00 <int80_h> mauke : don't I need a list as the final argument to map?
15:35:07 <benmachine> > putStrLn "hi"
15:35:08 <int80_h> say [1,2..]
15:35:08 <lambdabot>   * Exception: "<IO ()>"
15:35:16 <benmachine> makes sense.
15:36:29 <int80_h> hmm, I could do this a simpler way. I just need to pass either an odd number or an even
15:42:15 <skorpan> so is there no way to make a .cabal file not automatically pass --make as a parameter to ghc?
15:42:34 <dcoutts> skorpan: no
15:42:38 <skorpan> gah! :(
15:42:43 <dcoutts> skorpan: it needs --make
15:42:50 <skorpan> why?
15:42:53 <dcoutts> otherwise it will not work :-)
15:43:01 <skorpan> why will it not work?
15:43:20 <dcoutts> skorpan: Cabal does not do its own module dependency chasing, that's what --make does
15:43:25 <redditbot> fmap.fmap.fmap
15:43:25 <redditbot> abhorrent: a bittorrent library for Haskell
15:43:27 <skorpan> ah...
15:43:54 <dcoutts> skorpan: if it did then Cabal would never use --make (and if someone did pass it, it'd all go wrong)
15:43:58 <SamB_irssi> dcoutts: GHC can't just be passed a bunch of modules and told to build them in dependency order ?
15:44:09 <dcoutts> SamB_irssi: that's what --make does
15:44:33 <SamB_irssi> dcoutts: well, I mean, and ONLY those
15:44:43 <skorpan> so basically i'm going to have to create my own little build system for this to be easier. :|
15:45:03 <SamB_irssi> what does -S do anyway?
15:45:15 <dcoutts> SamB_irssi: you could reset the search path so that when it looks for dependent modules that you forgot to specify that it will not find them locally.
15:45:34 <skorpan> SamB_irssi: it stops the compilation after the assembly code has been generated
15:45:45 <dcoutts> SamB_irssi: ie, use -i and -hide-all-packages and then pass all file names explicitly.
15:45:59 <SamB_irssi> dcoutts: uh huh.
15:46:13 <skorpan> i'm doing a master thesis on whether it's possible to make SYB faster with rewrite rules and such and the amount of code generated is of course one way to measure "speed".
15:46:18 <SamB_irssi> that sounds easier than doing dependency chasing
15:46:35 <SamB_irssi> but the error message would suck royally ...
15:47:50 <SamB_irssi> so are you going to include M4 support in cabal when you implement dep chasing ?
15:48:06 <SamB_irssi> (or are you just going to use the old-fashioned way for LHC still ?)
15:48:46 <dcoutts> skorpan: you could -keep-hc-files and use -fvia-C
15:49:12 <skorpan> dcoutts: O_o... those switches surely are not in ghc --help...
15:49:22 <skorpan> i wonder why i don't have the man page for ghc.
15:49:30 <SamB_irssi> skorpan: what distro are you on ?
15:49:39 <skorpan> arch
15:49:42 <dcoutts> skorpan: there are many not in ghc --help or the man page. Fortunately it has an excellent and comprehensive user guide.
15:50:13 <adekoba> Cheshire, Saizan: that does work, but I've reached another dilemna. While the dumbRead function does work, making a wrapper also deprives us of some other functionality: http://pastebin.com/m38b9c0
15:50:13 <SamB_irssi> ksksssss[D[B[C[A[B[D
15:50:13 <SamB_irssi> d
15:50:16 <SamB_irssi> erg
15:50:19 <SamB_irssi> sorry about that
15:50:42 <dcoutts> skorpan: or use -keep-s-files, should work find
15:50:42 <Cheshire> adekoba, this is not what I meant
15:50:43 <SamB_irssi> I'd somehow done something not entirely unlike ^S
15:50:53 <dcoutts> skorpan: erm, find/fine
15:51:06 <ozy`> > chr 1111
15:51:07 <lambdabot>   '\1111'
15:51:16 <skorpan> dcoutts: thanks, i'll look into it.
15:51:24 <adekoba> Cheshire: Saizan recommended a wrapper, what is it that you suggested?
15:51:26 <ozy`> lambdabot blows utf-8-encoded chunks :(
15:51:28 <SamB_irssi> dcoutts: what distro are YOU using ?
15:51:36 <dcoutts> SamB_irssi: gentoo
15:51:38 <skorpan> oh snap, i search for "ghc user manual" and i get "did you mean gcc user manual?"
15:51:42 <skorpan> @google ghc user manual
15:51:43 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/
15:51:43 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.10.1
15:51:53 <SamB_irssi> dcoutts: and how was it's manpage made ?
15:51:53 <skorpan> oh, well, lambdabot did it just fine apparently..
15:51:53 <Cheshire> adekoba, like this: http://muaddibspace.blogspot.com/2009/01/datadynamic-without-typeclasses-or.html
15:52:16 <SamB_irssi> skorpan: maybe bots don't get those "maybe you meant" things ;-)
15:52:22 <Cheshire> adekoba, something like DYNAMIC is what I meant by existential wrapper
15:52:32 <Saizan> adekoba: what about data Frame = forall a. Value a => Frame (IDInternal a) a ?
15:52:58 <Cheshire> adekoba, with this way you don't lose any functionality
15:53:00 <adekoba> Saizan: then I can't use dumbRead with Frame, which is it's entire purpose
15:53:57 <dcoutts> SamB_irssi: it's automatically installed by the ghc build system, the gentoo ebuild does nothing special.
15:54:10 <Saizan> adekoba: you can get an ID from dumbRead, then pattern-match against the IDInternal contained, and build your Frame out of that
15:54:32 <SamB_irssi> dcoutts: oh. mine is apparantly built using some debian-made XSL file
15:55:14 <adekoba> Cheshire: (/me is trying to wrap his head around it, thanks for pointing me in the right direction)
15:55:58 <adekoba> Saizan: will the type returned from some pattern matching function return an (IDInternal a), i.e. an unbound variable?
15:56:59 <Saizan> adekoba: it'll be existentially quantified, but by pattern-matching you can see if it's a Text or a Number
15:58:00 <Saizan> adn then produce a Frame with the right contained type
15:58:41 <Saizan> (note how the definition of Frame is basically identical to DYNAMIC)
15:59:06 <adekoba> Saizan: i'm just tring to think of a type signature for that. You mean something like: pattern :: forall a. (Value a) => ID -> IDInternal a
15:59:31 <cads> hey, no particularl reason I'm asking you guys this question, but do you guys know about methods for simulating the path of light through mediums where the index of refraction is variable based on position inside the medium?
15:59:44 <Saizan> adekoba: no
16:00:13 <Saizan> adekoba: you've to repack the IDInternal inside a Frame in the body of the case
16:00:56 <Japsu> cads: I'm not sure but to me this sounds quite much like numerical solving of differential equations
16:01:23 <adekoba> Saizan: that makes sense.
16:01:34 <cads> Japsu, I think it is a similar problem to simulating the path of light light a curved portion of spacetime, so yeah
16:02:07 <cads> hehe anything that involves geodesics involved PDEs and scares me so far
16:02:24 <Japsu> cads: at every step of length dt the direction to which we make the step is determined by a function of the index of refraction and latest direction, and the index of refraction again is a function of the location
16:02:49 <Saizan> adekoba: you can write a function of type "pattern :: ID -> (forall a. IDInternal a -> r) -> r"
16:03:08 <kerm|t> @where stats
16:03:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
16:03:10 <Saizan> adekoba: which is kind of the equivalent of foldr/maybe for ID
16:04:20 <cads> I am imagining such a volume where the index is determined by a wavy noise function, and it is a very tricky picture: total internal reflection would happen in certain places where the index gradient is high
16:04:56 <cads> I feel like getting such a simulation to be numerically stable and accurate would be difficult :D
16:05:06 <cads> But it would be neat!
16:07:30 <louislang> I need to pass two lists of Bools in, and calculate their binary sum and product. I'm having some trouble passing in two lists however
16:07:39 <louislang> can anyone give me a little advice on how to do this?
16:07:41 <Japsu> cads: my intuition would be to treat each step as though the light passed through a plane in straight angle dividing the space into two refraction indexes
16:09:18 <sjanssen> louislang: a function operating on two lists looks something like: twoListFunction xs ys = zipWith (+) xs ys
16:09:27 <sjanssen> that is a function that will add two lists of numbers
16:09:28 <cads> and apply the fresnell-huygens principle: http://www.phy.ntnu.edu.tw/ntnujava/index.php?topic=16.0
16:09:54 <louislang> let me give that a try, one second
16:10:00 <Japsu> cads: yeah, exactly
16:10:21 <Japsu> cads: at each step, determine the angle, and then just jump dt into that angle
16:10:44 <sjanssen> louislang: oh, and you would call that function like: twoListFunction [1, 2] [3, 4]
16:10:59 <louislang> http://pastebin.com/d223778d
16:11:02 <louislang> here's my code as of now
16:11:15 <louislang> i'm trying to pass in the two bool lists, then do like an or on them and come up with a new list
16:11:28 <louislang> keeps throwing an error "ouldn't match `[Bool]' against `t -> t1'"
16:11:39 <sjanssen> louislang: "binSum (x:x1)" is the wrong bit
16:11:55 <sjanssen> x is a [Bool] and xl is a [Bool], it doesn't make sense to cons them
16:12:07 <louislang> cons?
16:12:10 <sjanssen> louislang: what you mean is "binSum x x1"
16:12:32 <louislang> hm alright lemme give that a try
16:12:33 <sjanssen> louislang: (:) in English is cons, short for "construct"
16:13:07 <sjanssen> that will fix your type errors, but there are still other issues with this code
16:13:45 <louislang> hm yea that fixed the errors, it compiles now
16:14:02 <louislang> you mind giving me some pointers with this code? this is my second day of Haskell :P
16:14:08 <sjanssen> sure
16:14:50 <sjanssen> louislang: so one problem with this algorithm is that you don't handle carry-over
16:15:05 <louislang> oh that hadn't even occured to me
16:15:08 <sjanssen> eg. 1 + 1 = 10
16:15:54 <louislang> so what would be the best way to handle that?
16:16:15 <sjanssen> well, you can start by adding another argument to binSum, of type Bool
16:16:17 <grul> use an infinite base number system
16:16:23 <grul> and you'll never have to carry
16:16:34 <sjanssen> this will be the digit carried over from the previous place
16:17:04 <louislang> so like binSum x x1 x2 and the x2 will be the carry over?
16:17:19 <sjanssen> louislang: sure
16:17:47 <sjanssen> though I'd start thinking about using some names better than "x1, x2"
16:18:00 <louislang> hm yea, that may be a good idea :P
16:19:18 <louislang> so, in haskell what if that final carry over bool isn't given?
16:19:27 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1173#a1173
16:19:35 <sjanssen> louislang: it will give a type error
16:19:40 <int80_h> Would someone take at my euler project problem?
16:20:02 <sjanssen> the error will be something about "Not enough arguments applied"
16:20:04 <int80_h> it's a type error but I know what's causing it, and what I want to do. I am just having difficulty expressing that with haskell
16:20:41 <louislang> hm, sorry im still a bit confused. If I have three paramaters, and im only passing in two lists does the function get the carry over when its executed?
16:21:05 <sjanssen> louislang: no, you have to pass in three argument when you call the function
16:22:38 <mopped> How do I deal with the fact that i've got to apply k to the mapping of the rest of the list? f'cps x $ \f'x -> cons'cps f'x $ cons'f'x -> cons'f'x (map'cps f'cps xs k) k?
16:23:40 <islon_s> "handle (\_ -> putStrLn "not a number" >> loop content) $ do ..." gives me "ambiguous type variable e in the constraint" how do i fix that?
16:24:10 <int80_h> chessguy_ could you take a look?
16:24:13 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1173#a1173
16:24:17 <sjanssen> int80_h: length is a function, you're trying to compare a function and a number with (<=)
16:24:29 * chessguy wakes up
16:24:43 <louislang> well shouldn' the carry over be figured out during execution?
16:24:43 <louislang> i mean, you don't know the carry over
16:25:01 <travisbrady> ooh, new hpaste, anybody know what they're using for syntax highlighting?
16:25:10 <sjanssen> louislang: yes, you'll need to calculate the carry over and pass it in recursion
16:25:11 <dons> pygments
16:25:24 <dons> yeah, haskell<->python ffi.
16:25:37 <sjanssen> louislang: binSum x x1 (figure out new carry over)
16:25:42 <chessguy> int80_h, yeah, sjanssen is right (as usual), you need to take the length of some actual list, and compare _that_ to 500
16:26:11 <int80_h> oh, I was trying to use partial application
16:26:48 <int80_h> okay I made this change
16:26:48 <chessguy> @pl \x -> length x <= 500
16:26:48 <lambdabot> (<= 500) . length
16:26:50 <travisbrady> dons: cool, what ffi?  didn't know haskell could speak python or vice versa
16:27:40 <BMeph> travisbrady: A sprite with a Highlighter. ;)
16:29:15 <int80_h> @type (<= 500) . length x)
16:29:16 <lambdabot> parse error on input `)'
16:29:23 <chessguy_> @bot
16:29:23 <int80_h> @type (<= 500) . length x))
16:29:23 <lunabot>  :)
16:29:23 <lambdabot> :)
16:29:24 <lambdabot> parse error on input `)'
16:29:34 <int80_h> ugh
16:29:46 <int80_h> in takeWhile ((<= 500) . length x)
16:29:59 <chessguy_> @type (<= 500) . length
16:30:01 <lambdabot> forall a. [a] -> Bool
16:30:18 <islon_s> how can i fix a ambiguous type variable in a lambda expression?
16:30:58 <Saizan> islon_s: with a type annotation, usually
16:31:15 <Saizan> islon_s: or paste the code :)
16:31:21 <Saizan> @where hpaste2
16:31:21 <lambdabot> http://moonpatio.com:8080/
16:31:29 <islon_s> "Result signatures are no longer supported in pattern matches In a
16:31:29 <islon_s>  lambda abstraction: "
16:31:48 <int80_h> okay now I'm getting a different type error, made this change
16:31:52 <islon_s> handle (\_ -> putStrLn "not a number") $ do ...
16:31:58 <int80_h>                      in takeWhile ((<= 500) . length)
16:32:30 <int80_h> Couldn't match expected type `[Integer]' against inferred type `[[a]] -> [[a]]'
16:34:06 <Saizan> islon_s: handle (\(e :: SomeException)  -> ...) $ do ...
16:34:21 <Saizan> islon_s: with ScopedTypeVars
16:34:43 <Saizan> int80_h: i think you forgot an argument for takeWhile
16:34:49 <mopped> @src filter
16:34:49 <lambdabot> filter _ []     = []
16:34:49 <lambdabot> filter p (x:xs)
16:34:49 <lambdabot>     | p x       = x : filter p xs
16:34:49 <lambdabot>     | otherwise = filter p xs
16:35:00 <Saizan> int80_h: i.e. the list
16:35:05 <int80_h> Saizan, yeah I was missapplying partial application
16:35:08 <islon_s> the exception is "*** Exception: Prelude.read: no parse" wich type is this?
16:35:19 <int80_h> in takeWhile ((<= 500) . length x)
16:35:29 <int80_h>   Couldn't match expected type `a -> b' against inferred type `Int'
16:35:30 <int80_h>     In the second argument of `(.)', namely `length x'
16:35:31 <sjanssen> int80_h: ((<= 500) . length x) is not right either
16:35:42 <int80_h> yup, got another type err
16:35:54 <sjanssen> int80_h: there you're trying to compose a function (<= 500) with an Int (length x)
16:36:10 <mm_freak> what's the plural of calculus?  calculi?
16:36:16 <Saizan> islon_s: SomeException will catch them all, however that in particular is an ErrorCall, afaiu
16:36:26 <lament> mm_freak: yes.
16:36:30 <mm_freak> thanks
16:37:15 <Saizan> int80_h: there 'x' is given as an argument to length, but your're missing an argument for takeWhile
16:37:20 <islon_s> it would be good if ghci showed the exception type
16:37:23 <islon_s> thanks anyway =)
16:37:26 <int80_h> well, I was missing a list argument for length. I provided it
16:37:33 <int80_h> ahhh
16:39:17 <int80_h> yeah and takeWhile doesn't like the argument I gave it. I gave it list x
16:41:07 <int80_h> in takeWhile ((<= 500) . length x) x
16:41:25 <Saizan> no
16:41:27 <int80_h>     Couldn't match expected type `[Integer] -> b'
16:41:27 <int80_h>            against inferred type `Int'
16:41:34 <int80_h> still complaining about length x
16:41:46 <Saizan> it's takeWhile that gives the argument to length
16:41:58 <mopped> qualitively, how would filter in CPS work? would it preform the continuation on a result if it passed the predicate? like filterC p (x:xs) k | p x = k (consC (x) (filterC p xs k)); | otherwise = k (filterC p xs k)?
16:42:18 <int80_h> yes, it compiles :)
16:43:26 <redditbot> #haskell-in-depth IRC channel launched
16:43:51 <Saizan> mopped: filterCPS :: (a -> (Bool -> r) -> r) -> [a] -> ([b] -> r) -> r
16:45:11 <int80_h> okay the takeWhile doesn't terminate the spiral
16:45:12 <adekoba> Saizan: this may not be entirely what you meant, but it serves my needs well enough. http://pastebin.com/md6e7b7d
16:46:19 <adekoba> Saizan: and construct can build its own Value (Number, Text depending on context)
16:46:20 <int80_h> I did a re-write to include the use of m
16:46:33 <int80_h> createSpiral :: [Integer] -> [[Integer]]
16:46:43 <int80_h> createSpiral m = let x = map (createSpiral') m in takeWhile ((<= 500) . length ) x
16:47:19 <Saizan> adekoba: i don't see why you're using ID in Frame
16:47:32 <int80_h> my intent is that it's counting the number of lists in [[Integer]]
16:47:35 <Saizan> adekoba: but if it works for you :)
16:47:37 <mopped> what's the ([b] -> r) telling me Saizan?
16:47:39 <int80_h> when I have 500 lists, terminate
16:48:01 <sjanssen> int80_h: oh, that isn't what takeWhile means
16:48:02 <Saizan> mopped: ops sorry, that should have been ([a] -> r)
16:48:08 <sjanssen> int80_h: you want take
16:48:16 <int80_h> oooh!
16:48:19 <int80_h> same syntax?
16:48:26 <sjanssen> take n xs
16:48:37 <adekoba> Saizan: neither do I! hah. Just took it out.
16:48:38 <sjanssen> takes the first 'n' elements from 'xs'
16:49:09 <adekoba> Saizan: this what you had in mind?
16:49:32 <Japsu> cads: ...bah, ignore the "my intuition would be ..." part, that was silly
16:49:32 <int80_h> nice, now I need to concat all these lists :)
16:49:44 <int80_h> sum the terms and I'll be done
16:50:17 <Saizan> adekoba: more or less yes, i'd keep IDInternal in Frame so you can recover the concrete type of 'a', but maybe you don't need that?
16:51:00 <adekoba> Saizan: I just fixed that, and yes :D
16:51:03 <pumpkin> dpiponi: your blog is awesome :D
16:51:37 <Saizan> adekoba: ah, ok :)
16:52:36 <dpiponi> pumpkin: thanks! I'm glad it's of some use to someone else 'cos really it's just me straightening my thoughts out.
16:53:08 <cads> Japsu: i disagree, conceptually dividing it into infinitesimally small steps where locally the light path behaves as if it were going through flat interfaces between regions of differing indices... I'm sure that'd be a step in analyzing the problem and reducing it to a system of differential equations
16:53:47 <Japsu> cads: the problem is that no bending of the path occurs when you approach the surface in a right angle (90 dgr)
16:54:04 <Japsu> that is, when theta0 = 0.0, always theta1 = 0.0
16:54:35 <cads> I see. the angles of the planes would have to correspond to the direction of the index gradient, as well
16:55:50 <int80_h> okay, a is a [[Integer]]
16:56:01 <int80_h> I want to sum the concatination of a
16:56:07 <int80_h> and I thought it would look like this
16:56:12 <int80_h> sum . concat a
16:56:14 <Japsu> cads: here's what I've made up so far: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1176#a1176
16:56:17 <int80_h> but that's not right
16:56:37 <Japsu> int80_h: sum . concat $ a
16:56:47 <Japsu> > sum . concat $ [[1,2,3],[4,5,6]]
16:56:48 <lambdabot>   21
16:56:56 <cads> Japsu; if we naively did this step by step for some small dt, I think we'd have very bad problems of instability. So we have to be smart enough to see how some variational principle applies to yield a higher order solution (I'm not :D)
16:57:16 <Japsu> cads: there are so called predictor-corrector methods to help at the instability
16:57:28 <int80_h> Japsu: what does that expression evaluate to, using parens. I'm still trying to understand $
16:58:04 <Saizan> int80_h: (sum . concat) a
16:58:05 <cads> wow you're mocking up some code :)
16:58:13 <Japsu> cads: that means that you first take a step with a guess of the direction, then you backtrack using the point that would have been given if you had believed that guess
16:58:26 <Japsu> cads: the Runge-Kutta method of solving ODEs is an example of this
16:59:08 <Japsu> cads: http://en.wikipedia.org/wiki/Runge–Kutta_methods
16:59:45 <cads> yeah, i bet fourth order runge-kutta would give us an optically useful simulation
17:00:04 <Japsu> but we still need to solve the problem of determining the next angle
17:00:39 <Japsu> I mean, the guess (that is the next angle in Euler)
17:01:18 <cads> if we have a naive way of determining that then we don't have to worry about modelling the situation in terms of PDEs?
17:01:47 <cads> conceptualizing that is making my head spin :D
17:02:59 <Japsu> meh
17:03:06 <Japsu> why do I always start coding at 3AM
17:03:12 <CakeProphet> it's funny that STM is probably the most "eager" method of concurrency control, and its primary implementation is in Haskell.
17:03:28 <Japsu> cads: poke me when you solve it ;)
17:03:36 <Japsu> bed ->
17:03:39 <cads> Japsu: I'll work the problem with pen and paper
17:03:41 <Taejo> CakeProphet, it's lazy w.r.t. locking
17:03:57 <L11> hm i'm still rather stumped with this binary addition - can anyone provide me with additional hints to its implementation?
17:04:11 <cads> I don't know enough haskell to implement it in haskell... maybe I'll do a ruby version (ugh), and translate later
17:04:19 <CakeProphet> Taejo:  eager in the sense that it basically continually retries a transaction until it works.
17:04:35 <cads> good night Japsu, thanks for the code :D
17:04:37 <Taejo> CakeProphet, sure
17:05:00 <sjanssen> CakeProphet: except that GHC's implementation is actually lazy in that respect -- it won't retry until it could possibly succeed
17:05:16 <Japsu> cads: sorry, my haskell code probably wasn't the easiest to read because I'm relying on stuff like uncurry and partial evaluation ;)
17:05:20 <Saizan> L11: the lists have the less significant bits first, right?
17:05:27 <CakeProphet> sjanssen:  ah... how does it determine if it will succeed?
17:05:41 <cads> Japsu: I can read, just not write :D
17:05:46 <Japsu> ok :)
17:05:50 <sjanssen> CakeProphet: it will wait until any of the TVars read have changed
17:05:50 <CakeProphet> sjanssen:  locks?
17:05:55 <CakeProphet> ah.
17:06:06 <Taejo> has anybody actually benchmarked a locking implementation of STM?
17:06:11 <Gracenotes> @hoogle TVar
17:06:11 <lambdabot> module Control.Concurrent.STM.TVar
17:06:28 <cads> Japsu: I will start off in one dimension and extend to a general case of n dimensions :D
17:06:38 <Gracenotes> that was a somewhat higher-level concurrency primitive than MVar, no? *looks*
17:06:47 <Japsu> refraction in one dimension?
17:07:05 <cads> Sure, a light ray travelling down the number line at a variable speed.
17:07:08 <sjanssen> Gracenotes: stands for "transactional variable", the basic primitive of STM
17:07:31 <Japsu> light speed!
17:07:47 <Japsu> had I thought about it that way...
17:07:50 <Japsu> NO! not tonight!
17:08:11 <CakeProphet> Gracenotes:  it's pretty neat.
17:08:16 <Gracenotes> sjanssen: oh, nice. Somewhat like a synchronized block in Java?
17:08:37 <sjanssen> Gracenotes: I don't really know Java, but I bet it is entirely different
17:08:39 <Gracenotes> (although obviously the underlying model is entirely different)
17:08:52 <cads> Japsu: sleep is callin' :D
17:08:55 <Gracenotes> that is, does it use locks?
17:09:03 <cads> Japsu: thanks for the conversation.
17:09:05 <Gracenotes> Or does it use something like compare-and-swap?
17:09:16 <Gracenotes> or something else
17:09:35 <CakeProphet> Gracenotes:  it basically keeps a log of every read/write transaction and can "roll back" all the other transactions if the whole transaction fails.
17:09:57 <CakeProphet> Gracenotes:  thus allowing you to make "atomic" memory actions.
17:10:04 <CakeProphet> inspired by databases.
17:10:33 <Gracenotes> ah. That sounds like compare-and-swap. The JDK offers that as well, although it's just a direct interface to a machine code command (if the machine supports it)
17:11:06 <Gracenotes> CAS is reading data, modifying it, and sending two values: the old value, and the new value. If the old value matches up, then it's changed; otherwise, a signal is sent that the transaction failed
17:11:28 <Taejo> Gracenotes, they're not really comparable: CAS is an instruction, STM is a concurrency model
17:11:37 <CakeProphet> Gracenotes:  you can also manually make the transaction fail with the "retry" function, and there's a orElse which tries one action or, if that one fails, tries the second one... and if that fails, the whole thing retries.
17:11:45 <Taejo> CAS is very useful for *implementing* concurrency models, though
17:11:48 <ozy`> Gracenotes: STM is basically an entire field of research. CAS is one way to implement it, I'm sure
17:12:31 <Gracenotes> oh, neat. I'll play around with STM a bit, methinks
17:13:01 * Gracenotes has heard mostly good things about it
17:13:36 <ozy`> the "software" part of STM is a fairly recent development, because for a couple decades everyone thought you'd need special hardware to implement transactional memory
17:13:38 <L11> uhm is there a way to say like if something then tail(reverse x) and then do some more commands after that?
17:13:54 <CakeProphet> Gracenotes:  so each STM actions appears to every other thread as a single atomic action... no weirdness can occur from threads altering memory at the same time.
17:14:20 <ozy`> L11: in order to answer that question we'll have to know the context.
17:14:44 <int80_h> okay this is me not understanding $ again
17:14:44 <CakeProphet> Gracenotes:  (as long as you design your system in terms of atomic actions, that is)
17:14:46 <int80_h>  take 10 . reverse $ [x^x | x <- [1..1000]]
17:15:02 <L11> well im trying to get a binary sum to work. So I have two lists - I am comparing them, and then i need to remove the last element in the list so eventually i can terminate
17:15:13 <int80_h> I'm trying to get the last 10 digits,,,oh wait I need to make it into a string
17:15:19 <int80_h> nevermind I can do this
17:15:35 <L11> in c I can do something like binSum(list1, list2) { pop.list1; } or w/e
17:15:45 <L11> how would that implementation look in haskell?
17:15:45 <Gracenotes> CakeProphet: sounds cool :)
17:16:00 <sjanssen> L11: you're thinking too imperatively, methinks
17:16:05 <Saizan> L11: lists are not mutable in haskell
17:16:23 <pumpkin> you could write a mutable list but I'm not sure you'd want to
17:16:34 <Saizan> L11: but you can just pass e.g. (tail list1) to the recursive call
17:16:46 <Gracenotes> CakeProphet: of course, you still need to have parallelisable tasks for it to be effectively, although not having to deal with locks must help performance...
17:16:52 <Gracenotes> -ly
17:17:22 <Taejo> :t fmap fmap fmap
17:17:23 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:17:24 <L11> Saizan: yea that's what im doing, mind taking a look at my code?
17:17:30 <Taejo> :t fmap fmap fmap fmap
17:17:31 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
17:17:37 <CakeProphet> Gracenotes:  according to what I've read in most scenarios STM runs faster than lock-based concurrency.
17:17:37 <Saizan> @where hpaste2
17:17:37 <lambdabot> http://moonpatio.com:8080/
17:17:38 <Taejo> :t fmap fmap fmap fmap fmap
17:17:39 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
17:17:43 <CakeProphet> Gracenotes:  I forget why though
17:17:47 <Saizan> L11: paste it there ^^^
17:17:53 <Gracenotes> probably context-switching?
17:18:44 <L11> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1177#a1177
17:18:58 <L11> i'm not accounting for the carry over just yet, not exactly sure how to implement that
17:19:20 <Taejo> CakeProphet, in most programs, most access are uncontended, I believe
17:19:30 <Taejo> and locking is expensive
17:20:06 <ozy`> CakeProphet: it's just because fine-grained locking is really, really hard to do if you're manipulating locks by hand
17:20:16 <Gracenotes> L11: are you assuming that the lists are the same size?
17:20:41 <ozy`> whereas if you leave it all up to the STM system, it can be as fine-grained as it needs to be without making everything explode
17:21:00 <L11> yea, for now
17:21:02 <Saizan> L11: well, you're passing the list unchanged to the recursive call
17:21:09 <ozy`> (the "as it needs to be" part is probably the most contentious part of STM... figuring out what that is exactly is really difficult)
17:21:30 <Saizan> L11: or better, you're passing the same list, rather than a transformed one
17:21:32 <L11> Saizan: yea, I was hoping i could do like a 'pop' in C and just remove the last one
17:21:53 <Saizan> L11: also, you should decide the order of the bits
17:22:13 <Saizan> L11: it's easier if you remove elements from the front.
17:22:16 <CakeProphet> L11:  "init" will give you every element but the last... however
17:22:22 <CakeProphet> it is terrible on performance
17:22:29 <CakeProphet> each call to init traverses the /entire/ list.
17:22:56 <L11> can you give me a snippet of code to look at?
17:23:10 <Saizan> L11: and it seems you're using a different order for your arguments and the result
17:23:20 <Saizan> ?src init
17:23:20 <lambdabot> init [x]    = []
17:23:21 <lambdabot> init (x:xs) = x : init xs
17:23:21 <lambdabot> init []     = undefined
17:23:24 <Saizan> for example.
17:23:25 <L11> yea that's what I was tinkering with when I pasted that code
17:23:38 <Gracenotes> > let x = init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init $ [1..1000000000000] in "this code is so inefficient.."
17:23:39 <lambdabot>   "this code is so inefficient.."
17:23:42 <Gracenotes> :P
17:23:57 <chessguy> err
17:24:06 <chessguy> why is that code inefficient
17:24:08 <CakeProphet> Gracenotes:  heh, I think lazy evaluation killed your argument.
17:24:09 <ozy`> > let x = init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init $ [1..1000000000000] in x `seq` "this might never return D:"
17:24:10 <lambdabot>   "this might never return D:"
17:24:16 <Gracenotes> CakeProphet: it isn't
17:24:23 <ozy`> whoops
17:24:30 <ozy`> damn lazy evaluation
17:24:33 <L11> hm ok, let me test out this init
17:24:36 <Gracenotes> CakeProphet: er, the point is, a call to init doesn't traverse the entire list
17:24:40 <CakeProphet> L11:  ...don't.
17:24:41 <Gracenotes> as you might claim :)
17:24:47 <ozy`> > let x = last . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init . init $ [1..1000000000000] in x `seq` "this might never return D:"
17:24:54 <CakeProphet> L11:  pop from the front of the list, always.
17:24:58 <Gracenotes> CakeProphet: if you traverse the entire list, so does init
17:25:02 <L11> is there a pop function in haskell?
17:25:02 <lambdabot>   thread killed
17:25:08 <Gracenotes> so it's only as inefficient as traversing it yourself :)
17:25:18 <chessguy> > head [1..4]
17:25:20 <lambdabot>   1
17:25:22 <chessguy> L11:  ^^
17:25:35 <tromp__> pop is called tail:)
17:25:37 <L11> I was trying head earlier, it returns the first element and drops it off, correct?
17:25:42 <Saizan> L11: better yet, use pattern matching.
17:25:43 <L11> tried tail also :/
17:25:48 <ozy`> L11: there's no function for modifying the list. that's not possible in haskell.
17:25:52 <CakeProphet> > tail [1,2,3,4,5]
17:25:54 <lambdabot>   [2,3,4,5]
17:26:12 <L11> oh, i get it - so I need to pass the tail of the list into the function?
17:26:16 <CakeProphet> > let (x:xs) = [1.10] in (x, xs)
17:26:18 <lambdabot>   (1.1,[])
17:26:19 <ozy`> L11: exactly
17:26:19 <Philippa_> L11: what ozy` said. If you want the tail, use tail. Or a pattern-match, which is much better because you can handle the possibility the list's empty then
17:26:20 <int80_h> show . reverse $ [x^x | x <- [1..10]]
17:26:24 <CakeProphet> L11:  or use pattern matching like I just did
17:26:25 <int80_h> ^ that works
17:26:36 <Saizan> > let foo (x:xs) = "Here's the head: " ++ show x ++ ", here's the tail: " ++ show xs in f [1,2,3]
17:26:36 <CakeProphet> > let (x:xs) = [1..10] in (x, xs)
17:26:38 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
17:26:38 <lambdabot>   Add a type signature
17:26:39 <int80_h>  ["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News: h
17:26:42 <int80_h>              it off, correct?
17:26:58 <Saizan> > let foo (x:xs) = "Here's the head: " ++ show x ++ ", here's the tail: " ++ show xs in foo [1,2,3]
17:27:00 <int80_h> reverse . sum $ [x^x | x <- [1..1000]]
17:27:01 <lambdabot>   "Here's the head: 1, here's the tail: [2,3]"
17:27:11 <int80_h> ^^^ but this doesn't
17:27:20 <int80_h> I just don't understand
17:27:36 <CakeProphet> Gracenotes:  I'd still say repeatedly calling a function that unravels a list ( even if it does so lazily) incurs a performance hit when you do decide to access the elements of the list.
17:27:37 <L11> so since this is binary addition, how do you handle the carry over?
17:27:58 <chessguy> int80_h:  because sum doesn't return a list
17:27:58 <Saizan> ?type sum
17:28:00 <lambdabot> forall a. (Num a) => [a] -> a
17:28:11 <chessguy> int80_h:  so you can't reverse the result of it
17:28:21 <Saizan> L11: you need one more parameter to your binSum
17:28:36 <Saizan> L11: or define an helper function which has one
17:28:41 <Gracenotes> CakeProphet: that's true, especially if you apply init 25 times :) but in most cases, it's not overkill
17:28:41 <int80_h> ah okay, I'll put the sum in a list then
17:28:52 <chessguy> umm
17:28:58 <chessguy> i don't think that's what you're looking for
17:29:08 <CakeProphet> Gracenotes:  but yeah... if you're just finding the head of an init (I'm not sure why you'd ever do that)... no big performance penalty.
17:29:17 <chessguy> > reverse . (:[]) . sum $ [1..4]
17:29:19 <Saizan> int80_h: what do you think [x^x | x <- [1..1000]] is doing?
17:29:19 <lambdabot>   [10]
17:29:40 <chessguy> wha
17:29:51 * Gracenotes consumes chessguy (:[]) (:[]) (:[])
17:30:00 <chessguy> ack!
17:30:06 * chessguy flees from the const-monster
17:30:06 <ozy`> > reverse [4444]
17:30:07 <int80_h> Saizan, it's creating a list of x^2
17:30:08 <lambdabot>   [4444]
17:30:11 <chessguy> cons
17:30:16 <Gracenotes> [1..4] -> 10 -> [10] -> [10] -> result
17:30:20 <int80_h> where x <- [1..1000]
17:30:28 <Saizan> > [x^x | x <- [1..1000]]
17:30:30 <lambdabot>   [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,285311670611,8...
17:30:36 <int80_h> exactly
17:30:36 <ozy`> D:
17:30:39 <Saizan> > [x*x | x <- [1..1000]]
17:30:41 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
17:30:50 <Gracenotes> eek, I remember taking a derivative of that...
17:30:56 <Gracenotes> a long time ago, thankfully
17:31:01 <CakeProphet> map (^2) [1..1000]
17:31:02 <int80_h> oh wait, I meant x^x
17:31:05 <CakeProphet> > map (^2) [1..1000]
17:31:07 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
17:31:12 <int80_h> sorry, a little sleepy
17:31:21 <int80_h> anyway, ity's doing what I want
17:31:27 <Saizan> ok
17:32:03 <Gracenotes> does ghc optimize mapConcat ((:[]) . (^2)) list into map (^2) list, somehow? in list comprehensions
17:32:09 <int80_h> I need to sum that, put the sum in a list, reverse the list and take the last 10 digits out
17:32:27 <Saizan> what do you mean by put the sum in a list?
17:32:32 <Saizan> a singleton list?
17:32:41 <int80_h> say I have a sum 1234567
17:32:41 <Saizan> but reversing a singleton list does nothing
17:32:49 <int80_h> I will do this to it 1234567 : []
17:32:57 <ozy`> > reverse [x] -- for int80_h
17:32:59 <lambdabot>   [x]
17:33:25 <L11> ok one last question - how do you handle the carry over in the binary addition?
17:33:26 <int80_h> yeah, I'll need to make it a string
17:33:33 <Saizan> ah, ok
17:33:37 <int80_h> forgot to mention that step
17:33:38 <CakeProphet> map digitToInt "123456"
17:33:43 <CakeProphet> > map digitToInt "123456"
17:33:45 <lambdabot>   [1,2,3,4,5,6]
17:33:47 <ozy`> > reverse . show . 12345
17:33:48 <lambdabot>       Overlapping instances for Show (a -> [Char])
17:33:48 <lambdabot>        arising from a use ...
17:33:54 <ozy`> huuurraggghhh
17:33:59 <ozy`> > reverse . show . (12345 :: Int)
17:34:01 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Int'
17:34:02 <Saizan> > reverse . show $ 12345
17:34:04 <lambdabot>   "54321"
17:34:10 * ozy` facepalms
17:34:16 <Saizan> composition /= application
17:34:17 <Saizan> :)
17:34:20 <ozy`> I know ;_;
17:34:24 <ozy`> I always forget
17:34:41 <Gracenotes> that's okay, just use gratuitous parens and you'll never go wrong
17:34:49 <CakeProphet> int80_h:  do you plan on manipulating the digits as though they're characters or as though they're numbers?
17:34:57 <Saizan> unless you always represent your values as (() -> a)
17:35:12 <CakeProphet> > reverse . map digitToInt . show $ "123456"
17:35:12 <ozy`> Saizan: like in ocaml? :p
17:35:14 <lambdabot>   [* Exception: Char.digitToInt: not a digit '"'
17:35:26 <Saizan> L11: to implement carry, you need to pass the carry to the recursive call, right?
17:35:28 <CakeProphet> > reverse . map digitToInt . show $ 123456
17:35:30 <ozy`> :t \a()()()()()()()()() -> a
17:35:30 <lambdabot>   [6,5,4,3,2,1]
17:35:32 <lambdabot> forall t. t -> () -> () -> () -> () -> () -> () -> () -> () -> () -> t
17:35:35 <L11> Saizan: correct
17:35:47 <L11> so i need another parameter for my function?
17:35:52 <Saizan> L11: yes
17:35:54 <ozy`> @pl \a()()()()()()()()() -> a
17:35:54 <lambdabot> (line 1, column 21):
17:35:54 <lambdabot> unexpected " "
17:35:54 <lambdabot> expecting pattern or "->"
17:36:05 <ozy`> @pl (\a()()()()()()()()() -> a)
17:36:05 <lambdabot> (line 1, column 22):
17:36:05 <lambdabot> unexpected " "
17:36:05 <lambdabot> expecting pattern or "->"
17:36:08 <ozy`> :|
17:36:13 <ozy`> oh right
17:36:24 <L11> ok so say I have binSum, I only want to pass in two lists - and a third parameter only when necessary. Is this possible?
17:36:25 <ozy`> it can't pattern-match actual values
17:36:28 <Gracenotes> @pl \a-> a () () () () () () () () ()
17:36:28 <lambdabot> (line 1, column 10):
17:36:28 <lambdabot> unexpected " "
17:36:28 <lambdabot> expecting variable, "(", operator or end of input
17:36:39 <Gracenotes> I'm not sure it likes unit either...
17:36:53 <CakeProphet> L11:  make two functions... and make the 2-argument version call the with-carry version
17:36:55 <Gracenotes> @pl \a-> a u u u u u u u u u
17:36:55 <lambdabot> flip (flip (flip (flip (flip (flip (flip (flip ($ u) u) u) u) u) u) u) u) u
17:37:07 <Saizan> L11: no, but you can define binSumHelper, and then binSum xs ys = binSumHelper 0 xs ys
17:37:21 <CakeProphet> L11:  or what Saizan said
17:37:47 <L11> alright let me try that out
17:40:01 <Gracenotes> :t join . join . join . join . join . join . join . join
17:40:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m (m (m (m (m (m (m a)))))))) -> m a
17:40:54 <Gracenotes> :t join . join . join . join . join . join . join . join (*)
17:40:56 <lambdabot> forall a (m :: * -> *). (Num (m (m (m (m (m (m (m (m a)))))))), Monad m) => m (m (m (m (m (m (m (m a))))))) -> m a
17:40:57 <Gracenotes> eek
17:41:26 <Gracenotes> :t join . join . join . join . join . join . join $ join (*)
17:41:28 <lambdabot>     Occurs check: cannot construct the infinite type:
17:41:28 <lambdabot>       a = a -> a -> a -> a -> a -> a -> a -> a1
17:41:28 <lambdabot>     Probable cause: `*' is applied to too many arguments
17:41:48 <Gracenotes> :t join . join . join . join . join . join . join . join $ (*)
17:41:50 <lambdabot>     Occurs check: cannot construct the infinite type:
17:41:50 <lambdabot>       a = a -> a -> a -> a -> a -> a -> a -> a1
17:41:50 <lambdabot>     Probable cause: `*' is applied to too many arguments
17:41:57 <Gracenotes> never mind :\
17:42:23 <zloog_> Anyone know what the MUT time represents when I use +RTS on my program?
17:44:16 <CakeProphet> what's the standard lib time function?
17:48:11 <mhydronic> firstly, i'm very new to haskell - this is my second function. i'm supposed to write a function to find the sum of two lists of binary numbers. i'm mostly looking for direction
17:48:20 <mhydronic> i somehow need to keep up with a carry bit
17:48:52 <mhydronic> and i'm assuming i need to access the list in reverse order
17:51:07 <zloog_> mhydronic: How are you representing the binary numbers?
17:51:15 <zloog_> mhydronic: [Bool] ?
17:51:37 <mhydronic> yeah i.e. [1,0,1]
17:53:35 <kapil> does the Prelude have a functional construction like " functional a f = f a " ?
17:54:11 <zloog_> mhydronic: So you are doing this with list of Ints then? and you have to do it most siginficant first?
17:54:40 <mhydronic> Bools in haskell are not also represented as 0 and 1 ?
17:55:04 <zloog_> mhydronic: No bool is defined to be either True or False
17:55:21 <mhydronic> as long as the sum is computed correctly and i don't use any builtin arithmetic, the significance doesn't matter
17:55:27 <zloog_> mhydronic: If you've seen a data declaration yet "data Bool = True | False"
17:56:34 <mhydronic> ok
18:04:07 <ozy`> mhydronic: there aren't a whole lot of statically typed languages where boolean values are assumed to be the numbers 0 and 1.
18:04:41 <mhydronic> well i noticed that 1 /= 1 worked in the Prelude
18:05:06 <mhydronic> so i thought 0 and 1 could be substituted
18:05:23 <ozy`> > 1 /= 1
18:05:25 <lambdabot>   False
18:05:32 <SamB>  /= isn't anything to do with division
18:05:37 <ozy`> > "apples" /= "oranges"
18:05:39 <lambdabot>   True
18:05:54 <mhydronic> ah, well i thought it compared two Bools
18:06:13 <ozy`> mhydronic: it's equivalent to the != operator in C
18:06:43 <SamB> except with MORE POWA
18:06:54 <SamB> since we have more structural types than C has ;-P
18:07:21 <ozy`> it compares any two values that are the same type (so long as equality is defined for that type)
18:09:57 <mhydronic> is there something wrong in: int2bin n = n 'mod' 2 : int2bin (n 'div' 2)
18:10:24 <mhydronic> i get: lexical error in string/character literal
18:10:48 <ozy`> mhydronic: you're using the single quote when the backtick is what you want :p
18:11:05 <ozy`> mhydronic: you have a US keyboard? (if not this is gonna be a bit tough)
18:11:15 <mhydronic> below the ~ ?
18:11:19 <ozy`> yep
18:11:26 <mhydronic> k thanks
18:11:28 <ozy`> > 44 `mod` 2
18:11:29 <lambdabot>   0
18:11:47 <mhydronic> mod 44 2
18:12:03 <mhydronic> sum 2 3
18:12:08 <SamB> ozy`: well, you could have just told him to use the one at the end of your nick ;-P
18:12:23 <mhydronic> why don't those work with the bot?
18:12:28 <ozy`> SamB: yeah but I don't want him to have to rely on me being here or anything... :p
18:12:34 <ozy`> mhydronic: precede it with "> "
18:12:47 <mhydronic> > mod 44 2
18:12:48 <lambdabot>   0
18:12:54 <mhydronic> ah, i see
18:13:01 <ozy`> > (/0) `map` [1.0..]
18:13:02 <lambdabot>   [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,In...
18:13:26 <mhydronic> what does /0 do?
18:15:04 <conal> mhydronic: it's short for \ x -> x / o
18:15:10 <ozy`> mhydronic: any time you put an infix operator in parentheses, you can leave off one or both of the arguments to make it a curried function
18:15:10 <conal> s/o/0
18:15:24 <ozy`> :t (+ 1)
18:15:25 <lambdabot> forall a. (Num a) => a -> a
18:15:33 <ozy`> :t (2 + 1)
18:15:34 <lambdabot> forall t. (Num t) => t
18:15:48 <shukhov> :t (1 -)
18:15:49 <lambdabot> forall t. (Num t) => t -> t
18:17:34 <mhydronic> well for instance, what i'm trying to do.. i need to somehow include a carry bit but when someone types [1,0] + [1,1] there won't be a carry bit initially
18:20:11 <m3ga> anyone know of a module for parsing email messages into headers and body?
18:21:47 <blackh> m3ga: hsemail
18:22:32 <m3ga> blackh: i looked at that but is seems to be SMTP in the wire protocl, not smtp message parsing. Did I miss something?
18:23:33 <blackh> m3ga: I haven't used it to parse emails, but I am almost certain that it has parsers for the message format itself.
18:23:38 <m3ga> yes, i did. I looked at Rfc2234 and Rfc2821, not Rfc2882 which has what i'm looking for.
18:26:41 <L11> Ok i almost got it - but for some reason, if I have a carry to start off with, the code fails: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1179#a1179
18:26:52 <L11> can't seem to pinpoint the problem
18:27:18 <SamB> rewrite in Coq
18:27:26 <SamB> then try to prove your program correct ;-P
18:27:32 <L11> Coq?
18:27:41 <SamB> it's a proof tool/language
18:28:04 <L11> hm never heard of it :/
18:28:04 <SamB> I'm, uh, 90% kidding
18:28:27 <L11> lol
18:28:27 <L11> over my head I suppose
18:28:40 <ozy`> L11, mhydronic, are you guys in a class together or what?
18:28:41 <L11> But just at a glance, do you see the issue?
18:28:42 <SamB> I dunno.
18:28:49 <L11> no idea
18:28:53 <L11> lol do we have the same questions?
18:28:57 <ozy`> you're both at tamu.edu
18:29:00 <ozy`> yes
18:29:01 <SamB> have you heard of the curry-howard isomorphism ?
18:29:17 <SamB> L11: maybe you too should study together ;-)
18:29:25 <SamB> er, two
18:29:31 <L11> lol i'm in a room full of a bunch of guys :P
18:29:34 <L11> no one knows what's going on
18:29:35 <mhydronic> i think L11 is following this stuff quite a bit better than i
18:29:48 <L11> mhydronic: where are you at?
18:29:59 <mhydronic> a&m
18:30:02 <L11> we have a room full of guys from 314 up in bright
18:30:03 <ozy`> you're probably sitting right next to each other
18:30:12 <L11> lol no one next to me knows what IRC is . . .
18:30:18 <mhydronic> yeah, im at home
18:30:19 <SamB> L11: is #haskell a permitted resouurce in your lab ?
18:30:31 <bitrot> hey tamu dudes..say howdy to Dr. Daugherity
18:30:31 <SamB> or is it a study session ?
18:30:46 <L11> we're all just working on assignments in here
18:30:46 <mhydronic> haha dr daugherity
18:30:57 <mhydronic> L11 what room?
18:31:00 <L11> uhm one sec
18:31:23 <L11> 219
18:31:41 <mhydronic> L11: question before i head over there: did yall use the functions from the book for bin2int and vice versa ?
18:31:56 <L11> no
18:32:01 <L11> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1179#a1179
18:32:04 <L11> that's the code I have so far
18:32:51 * Axman6 has never met anyone from his uni on IRC, except pne of the researchers up at the observatory :(
18:32:56 <ozy`> L11: you need to learn about the case statement
18:33:05 <mhydronic> alright ill stop by
18:33:18 <L11> awesome got the binary sum :)
18:33:24 <L11> yea i just started haskell like ysterday
18:33:31 <L11> i presume its the same as c?
18:33:43 <Axman6> you mean C?
18:33:43 <SamB> "the same as C"?
18:33:51 <L11> yea
18:33:58 <Axman6> yeah, it's just like C, but toally different :)
18:34:03 <Axman6> totally*
18:34:10 <ozy`> L11: not quite. I'll show you... rewriting your huge ass-conditional
18:34:16 <L11> heh - haskell is a strange language
18:34:26 <SamB> Axman6: the language name isn't necessarily case sensitive, and should be unique in the firstt 6 chars ;-P
18:34:28 <L11> thanks ozy
18:34:32 <Axman6> haskell is a beautiful language
18:34:40 <ozy`> (actually I might just use guards)
18:34:49 <L11> yea i've seen some nice code, but the concepts are confusing to me at the moment
18:35:00 <Axman6> SamB: yeah, but people understnad C as being the language more than c
18:35:23 <SamB> L11: that's a good sign, actually
18:35:26 <Axman6> L11: once you pick them up, you'll really start to love haskell
18:36:00 <L11> yea, i'd never heard of it before a few weeks ago
18:36:17 <L11> its pretty cool, just don't understand a lot of the concepts - plus I tended to stay away from recursion in other languages
18:36:23 <Axman6> obviously not a reddit user then :P
18:36:33 <L11> not yet :P
18:36:43 <SamB> I wouldn't bother with reddit
18:36:55 <L11> not any good?
18:37:01 <Axman6> http://reddit.com/r/programming <-- lots of haskell stuff (/r/haskell has even more :o)
18:37:09 <Adamant> reddit has gone downhill
18:37:16 <Axman6> heh
18:37:22 <SamB> yeah, seriously
18:37:26 <Adamant> it's still worth picking out some good info from there
18:37:29 <Adamant> IMO
18:37:36 <Axman6> yeah
18:37:47 <Axman6> like mighty putty!
18:37:47 <Adamant> but others like SamB might have a different threshold
18:37:57 <L11> i'll check it out
18:38:05 <SamB> someone (dons) posted my first silly little blog post, for instance!
18:38:24 <Axman6> dons posts basically anything haskellish
18:38:28 <Axman6> though not my stuff
18:38:32 <SamB> well, I look at it occasionally
18:38:47 <Axman6> .... but! he did ask me at 5am this morning if i wanted to be on planet haskell :)
18:38:48 <SamB> Axman6: it's not my fault, honestly -- it's just 'cause it was on the LHC blog
18:39:14 <Axman6> eh?
18:40:10 <pumpkin> [21:38:28] <Axman6> though not my stuff
18:40:19 <pumpkin> N-bodies speedup (50%!) (axman6.homeip.net)
18:40:19 <pumpkin> submitted 8 hours ago by dons
18:40:21 <ozy`> L11: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1179#a1180 <-- check it out
18:40:29 <Axman6> :O
18:40:32 <Axman6> no wai!
18:40:37 <Axman6> GTFO
18:40:40 <Axman6> i'm famous!
18:40:43 <pumpkin> lol
18:41:04 <Axman6> zomg! i've got three upvotes!
18:41:12 <Axman6> woah, look at that, 4 now!
18:41:13 <Axman6> >_>
18:41:16 <pumpkin> omgz
18:41:23 * bitrot checks the sky...
18:41:35 <bitrot> it is not falling.
18:43:08 * Axman6 replies to the single comment
18:43:57 <ozy`> Axman6: hey, you never critiqued the latest version of my textmate grammar!
18:44:07 <Axman6> oh, i should do that too!
18:44:24 <Axman6> you couldn't write up a quick list of the changes you've made could you?
18:44:50 <ozy`> I don't remember them offhand
18:45:01 <ozy`> I'll post a diff patch somewhere
18:45:20 <SamB> http://www.reddit.com/domain/lhc-compiler.blogspot.com
18:45:55 <SamB> huh, my second blog entry got upvoted to 14!
18:46:08 <SamB> was it really that interesting ?
18:46:08 <Axman6> HEH
18:46:19 <Axman6> -caps*
18:46:28 <Axman6> which one was it?
18:46:47 <SamB> http://lhc-compiler.blogspot.com/2009/01/typeclasses-are-working-now-were.html
18:47:23 <Axman6> well, it's news people are interested in. peeps in the haskell comunity want to be abe to try another compiler
18:48:38 <pumpkin> damn right
18:51:41 <kwvarga> Has anyone had any experience in knapsack-type dynamic programming?
18:52:19 <glguy> kwvarga, did you have a more specific question about it?
18:52:23 <ozy`> Axman6: http://www.rsmw.net/ergo/Haskell.diff
18:52:32 <kwvarga> I am just trying to understand it a little bit more
18:53:03 <kwvarga> In more of how to code it as opposed to the variant I am trying to solve
18:53:28 <kwvarga> Typical knapsack problem you want to maximize price inside of a set container size (ie. weight < 50lbs)
18:53:33 <glguy> I like solving dy
18:53:56 <pumpkin> ozy`: AHA!
18:54:09 <kwvarga> However I am trying to do one where I want to minimize price with a weight >= 50lbs [50 is generic, would be variable)
18:54:09 <SamB_XP> glguy: what about poor little dx ?
18:54:12 <glguy> I like solving dynamic programming problems (at least for fun) with lazy arrays or the memotrie package
18:54:43 <ozy`> pumpkin: ...?
18:54:51 <pumpkin> ozy`: /ergo/
18:55:12 <Axman6> ozy`: heh, wish i could follow the changes :P
18:55:22 <Axman6> any idea when this will all be on svn?
18:55:42 <SamB_XP> Axman6: EWWWW
18:55:45 <SamB_XP> what's on SVN ?
18:55:56 <Axman6> textmate bundles
18:56:15 <Axman6> something that does need a central repository
18:56:44 <pumpkin> central repository schmentral repository
18:57:16 <SamB_XP> the need for a central repository doesn't justify the use of a centralized version control system!
18:58:29 <pumpkin> SamB_XP: you advocating any particular decentralized one?
18:58:41 <SamB_XP> pumpkin: well, certanly not TLA
18:58:44 <kwvarga> glguy: Lazy arrays in what way
18:59:04 <SamB_XP> git seems like it handles large things well ...
18:59:09 <pumpkin> :D
18:59:11 <pumpkin> yay
18:59:47 <glguy> tabulate bounds f = Array.array bounds [(i,f i) | i <- range bounds]
18:59:54 <glguy> ]dp bounds f = (memo Array.!) where memo = tabulate bounds (f (memo Array.!))
18:59:55 <lunabot>  luna: parse error on input `='
18:59:57 <SamB_XP> I think git has just about all of SVNs advantages without many of it's disadvantages ...
19:00:02 <Axman6> i think the main reason allan's using svn is because all macs with the dev tools come with svn
19:00:23 <glguy> kwvarga, I use "dp"
19:00:24 <SamB_XP> oh, it's true that git and OS X aren't the best of friends
19:00:42 <pumpkin> SamB_XP: really?
19:00:48 <pumpkin> I've never had any issues with it
19:00:52 <SamB_XP> maybe they fixed it
19:01:05 * SamB_XP heard something about it ...
19:01:11 <pumpkin> Axman6: still, it's a developer's text editor... he can expect people to know how to install something if they want to hack on his editor :P
19:01:41 <Axman6> pumpkin: updating the bundles is done via SVN, and not all TM users are developers
19:01:51 <pumpkin> they should be
19:01:56 <Axman6> ok, this is not cool >_< using way too much RAM here
19:02:01 <SamB_XP> what are the rest ?
19:02:10 <SamB_XP> Axman6: what, are you trying out LHC ?
19:02:17 <thom_logn> is there a standard function to turn a -> b into a -> m b?
19:02:34 <SamB_XP> thom__: (return .)
19:02:46 <thom_logn> ah! thank you
19:02:48 <SamB_XP> :t (return .)
19:02:49 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
19:02:57 <thom_logn> crazy
19:03:02 <Axman6> no, attempting to run my or liftM?
19:03:11 <pumpkin> ?
19:03:16 <SamB_XP> why the ?
19:03:25 <Axman6> ok... just used 2.5GB trying to run my first n-bodies program
19:03:33 <Axman6> whoops
19:03:35 <pumpkin> oh
19:03:39 <Axman6> i'd started writing something else
19:03:42 <Axman6> i meant to say liftM
19:03:46 <kwvarga> glguy: what if i am not working from a database
19:03:57 <pumpkin> SamB_XP: I was asking about Axman's question :)
19:04:29 <Axman6> i wondr how much of my 4GB i can use here...
19:04:31 <glguy> kwvarga, I don't know what you mean
19:04:47 * Axman6 quits Safari
19:04:48 <SamB_XP> pumpkin: I was asking Axman6 why HE had the ?
19:04:55 <pumpkin> oh :)
19:04:56 <ozy`> Axman6: http://www.rsmw.net/ergo/Haskell.diff.note
19:05:05 <kwvarga> I am unfamiliar with dp, so I am googling it and there is this "lazy mans database process utility"
19:05:14 <Axman6> ta, i'll check it out in a sec, like i said, just quit safari :P
19:05:15 <pumpkin> Axman6: you should get 32 gigs of ram just in case
19:05:31 <Axman6> it's not compiled 64 bit
19:05:31 <SamB_XP> kwvarga: usually if it's 3 or less letters it's a good idea to ask as you google ;-)
19:05:48 <kwvarga> yeah
19:05:50 <kwvarga> I see that :P
19:05:53 * SamB_XP only has a half gig on his dev box
19:05:55 <pumpkin> Axman6: phail!
19:05:59 <glguy> kwvarga, dp is the function's name that I pasted
19:06:04 <pumpkin> any news on 64-bit mac os ghc btw?
19:06:04 <kwvarga> Oh
19:06:08 <kwvarga> didn't see you posted a function
19:06:14 <pumpkin> I plan on upping my RAM to 16 gigs soon
19:06:21 <pumpkin> and would like to be able to use it
19:06:46 <SamB_XP> pumpkin: you could, uh, run 8 LHCs in parallel
19:07:06 <pumpkin> SamB_XP: or maybe just run one LHC on a larger program!
19:07:17 <SamB_XP> that was WITHOUT 64-bit
19:07:17 <pumpkin> I built myself a mac pro
19:07:21 <pumpkin> oh :)
19:07:22 <Axman6> ok, 3.13 GB before i killed it
19:08:32 <SamB_XP> pumpkin: also, you could run an LHC-compiled program for longer before it runs out of memory
19:08:54 <kwvarga> Okay, if I was too want to do this knapsack type problem where I am given a list of items (weight, cost) and a minimum weight of knapsack, how would i employ this dp function
19:09:04 <SamB_XP> (since they don't free memory at the moment ;-)
19:11:09 <pumpkin> ah :P
19:11:18 * SamB_XP suddenly realizes why all his \'s have turned to yens ... he's switched his character set to s_JIS or whatever the name is
19:12:48 <repnop> after years of being on such systems i dont even think about it
19:13:08 * ozy` clobbers Axman6 over the head with http://www.rsmw.net/ergo/Haskell.diff.note
19:13:22 <pumpkin> AHA!
19:13:28 <SamB_XP> repnop: I just wish it was a per-process setting
19:13:41 <ozy`> pumpkin: NO U
19:13:52 <repnop> samB_xp: it could be if the app you're using is IME aware.
19:14:08 <repnop> if all windows apps were you wouldn't need to change the default encoding for apps :)
19:14:19 <Axman6> ozy`: i'll get on it, don't worry :P i'm doing my n-bodies post first though
19:14:27 <ozy`> Axman6: heh, all right
19:14:49 * pumpkin does (n+1)-bodies to one-up Axman6
19:15:33 <SamB_XP> pumpkin: eh, you actually need to do n^2 bodies to one-up him!
19:15:52 <pumpkin> :o
19:15:57 <cakoose> I'm having trouble getting GHC to realize that my type synonym has an "Eq" instance.
19:16:16 <SamB_XP> cakoose: maybe it hasn't ?
19:17:10 <glguy> booo
19:17:15 <glguy> can't build memotrie on ghc 6.8
19:17:21 <glguy> via cabal at least
19:17:24 <glguy>     unknown flags in  {-# OPTIONS #-} pragma: -fenable-rewrite-rules
19:17:32 <cakoose> SamB_XP: Hmm... you might be right.  I tried creating a minimal test case and that ends up compiling fine.
19:17:53 <kwvarga> glguy did you see my last message
19:18:04 <SamB_XP> cakoose: did you put it in a module you haven't imported into the one you're trying to use it in ?
19:18:10 <glguy> kwvarga, nope :)
19:18:15 <glguy> kwvarga, I'll try to give an example
19:18:18 <kwvarga> Okay, if I was too want to do this knapsack type problem where I am given a list of items (weight, cost) and a minimum weight of knapsack, how would i employ this dp function
19:18:59 <cakoose> SamB_XP: Has something to do with synonyms.  I think the regular type has an Eq instance ("deriving Eq") but GHC complains that my type synonym doesn't have an Eq instance.
19:19:00 <glguy> kwvarga, do you have a working solution yet?
19:19:06 <glguy> kwvarga, however slow?
19:19:17 <cakoose> SamB_XP: Probably doing something stupid.  Lemme double check everything.
19:19:21 <kwvarga> I believe so
19:19:41 <kwvarga> A large test case (100 items, each item w/ 1:1 weight:cost ratio) takes > 30 minutes
19:20:01 <kwvarga> but I dont have any sort of caching of subset solutions
19:20:20 <glguy> kwvarga, do you have your testcase online somewhere
19:20:31 <kwvarga> The large one? I can post
19:21:23 <Taejo> kwvarga: that is probably a reasonable speed for a non-DP/non-memoized version
19:21:53 * gwern looks in despair at my inbox and TODO list. why do lambdabot and gitit/happs/filestore take up so much time?
19:22:17 <Taejo> kwvarga: actually, doing some calculations, it seems ridiculously *fast*
19:22:29 <kwvarga> it is greater than 30 minutes
19:22:33 <kwvarga> i never let it finish :p
19:22:45 <kwvarga> so it could be 2 days
19:22:53 <kwvarga> but i let it run 30 minutes while i researched some more
19:23:30 <Taejo> kwvarga: more like 400 gigacenturies :)
19:23:40 <kwvarga> or that
19:23:41 <kwvarga> lol
19:23:48 <kwvarga> http://pastebin.com/d30bad031
19:23:51 <kwvarga> is test case i am running
19:24:17 <Taejo> kwvarga: is the algorithm O(2^n) ?
19:24:37 <Taejo> (if you don't know any asymptotics, you could just point me to the code)
19:25:53 <kwvarga> I believe so, I order items by weight ascending, then go through a loop of using item[0] 0 to n, and reduce weight and call it without item[0] in the array
19:25:57 <glguy> kwvarga, what's the first line? for the rest, name, cost, weight?
19:26:07 <kwvarga> first line is minimum weight
19:26:15 <kwvarga> then it is ID COST WEIGHT
19:26:22 <Taejo> you mean maximum weight?
19:26:29 <kwvarga> no minimum weight
19:26:33 <kwvarga> its a variation of knapsack
19:26:46 <kwvarga> I need to minimize price of items to put in knapsack
19:27:00 <kwvarga> but atleast do X lbs
19:27:04 <Taejo> oh, ok
19:27:04 <Pegazus> kwvarga: approximately, or optimum?
19:27:15 <kwvarga> I believe optimum
19:27:24 <kwvarga> However i am interested in how to do both
19:27:57 <Pegazus> you know it's 2^n (until today) don't you?
19:28:12 <kwvarga> What I have been doing?
19:28:35 <kwvarga> I understand that my solution is incredibly inefficient.
19:28:42 <kwvarga> That is why I seek help :p
19:28:52 <Taejo> Pegazus: I think you are mistaken: classical knapsack take O(NC) time, where C is the capacity of the knapsack
19:29:08 <Taejo> it's only exponential in the number of bits of C
19:29:29 <Pegazus> mmmm, wasn't knapsack an np problem?
19:29:51 <Taejo> yes, but it's "hard" in C, not in N
19:30:08 <Pegazus> i mean exponential... no idea what C nor N are :p
19:30:31 <tony_> anyone ever use curry(the programming langauge)?
19:31:05 <Taejo> Pegazus: the running time is an exponential function, but what argument is it exponential in? It turns out that it's exponential in log(C), where C is the capacity of the knapsack. It's linear in N, the number of items.
19:32:31 <kwvarga> Okay so as far as me developing a solution to it, I have created a class Item which stores each item (weight, price)
19:32:34 <Pegazus> okay O_o
19:32:49 <Taejo> kwvarga: I don't think you want a class
19:32:52 <kwvarga> and then created an array of Items and sorted the Items with descending weight
19:32:59 <Taejo> assuming you are doing this in Haskell :)
19:33:00 <Pegazus> here it says empirical complexity is (log n)^2 O_o interesting...
19:33:14 <kwvarga> Does Haskell have structs?
19:33:41 <Pegazus> tuples? types?
19:33:56 <Taejo> kwvarga: I'd personally recommend learning to program in Haskell before learning to program an algorithm you don't know *in* Haskell
19:34:07 <Pegazus> may be he is programming that to learn haskell :)
19:34:23 <kwvarga> Well here is situation, most stuff I have uncovered have led me to haskell
19:34:36 <kwvarga> Honestly, I am a strong PHP/C++/Java coder
19:34:40 <Taejo> Pegazus: I see that, but like I said, I would personally not recommend it
19:34:46 <kwvarga> With very little haskell experience
19:34:59 <Pegazus> for me the best way to learn a language, is to make a project you want to do in it :)
19:35:06 <Taejo> kwvarga: have you ever coded any algorithmic problem like this in another language?
19:35:20 <kwvarga> I coded a regular knapsack in PHP
19:35:25 <Taejo> Pegazus: fair enough
19:35:37 <Pegazus> :)
19:35:39 <Taejo> kwvarga: DP, memoized or brute force?
19:36:12 <Pegazus> i doubt he knows :p
19:36:15 <kwvarga> lol
19:36:32 <kwvarga> let me see if i saved it at this point
19:36:36 <kwvarga> I believe it was memoized
19:36:53 <kwvarga> I had a vector of weights and item position
19:37:04 <Pegazus> kwvarga: do you know, or are used to, think "algorithms" in a recursive way?
19:37:13 <kwvarga> Yes
19:38:22 <Pegazus> good...
19:38:30 <Pegazus> and recursive types?
19:38:53 <Pegazus> List = [| List X List?
19:39:30 <Pegazus> List = Nil | Cons X List   ; i don't remember haskell sintaxis :p
19:39:58 <kwvarga> Not really.. I dont undderstand it atleast
19:40:11 <SamB_XP> Pegazus: ???
19:40:11 <ozy`> data List x = Nil | Cons x List -- that's obvious :p
19:40:13 <Pegazus> there you have a problem :/
19:40:18 <kwvarga> Its like a primitive node node.next() type position?
19:40:23 <SamB_XP> ozy`: kind error!
19:40:47 <ozy`> SamB_XP: I'd've figured it out eventually if I'd tried to make it compile...
19:40:48 <Pegazus> think it as an Empty list is a List.... And if you concatenate an element, with a List, you get another list...
19:40:50 <kwvarga> It stores both a value, and the next object
19:41:22 <Pegazus> i think it was called structural recursion definition, or something like that...
19:41:44 <Pegazus> hey haskellers!!! help me! :)
19:41:56 <ozy`> kwvarga: let's try a different approach. how are you with C++ templates?
19:42:39 <Pegazus> ozy`: you want to frighten the boy :/
19:42:54 <kwvarga> Lol actually i used that alot
19:42:57 <kwvarga> in C++
19:43:08 <Pegazus> do you know template metaprogramming techniques?
19:43:27 <redditbot> Haskell community still cool
19:43:29 <SamB_XP> can you do a quicksort in templates ?
19:43:30 <ozy`> kwvarga: you'll be fine with haskell types, then, soon as you get used to the syntax
19:43:31 <kwvarga> no
19:43:32 <Gracenotes> now you know!(TM)
19:43:45 <SamB_XP> kwvarga: er, I meant that in general!
19:43:53 <SamB_XP> I wasn't meaning to direct that at you
19:43:55 <kwvarga> pegazus: no
19:44:00 <kwvarga> lol k
19:44:11 <kwvarga> I was responding to pegasuz about metaprogramming techniques
19:44:12 <Axman6> my girlfriend hits me when i put meta infront of words. She did an english course that was full of post modernism. Scared her for life
19:44:14 <Pegazus> <SamB_XP> can you do a quicksort in templates ? ---> templates if the compiler has no "limit" on the depth, are at least a primitive recursive complete language
19:44:24 <Pegazus> and probably turing complete too...
19:44:25 <glguy> kwvarga, all of those costs are equal to their weights
19:44:34 <glguy> is that intentional?
19:44:37 <kwvarga> Yes
19:44:41 <glguy> ok :)
19:45:07 <kwvarga> I know it breaks my program as it was
19:45:12 <kwvarga> :P
19:45:32 <kwvarga> Atleast runtime wise
19:45:53 <geezusfreeek> i believe templates are known to be turing complete, actually
19:46:18 <Taejo> kwvarga: try something closer to 30 items
19:46:28 <Taejo> that should take on the order of a second
19:46:42 <Taejo> if you're doing a standard brute force
19:46:47 <kwvarga> I have smaller test cases
19:46:55 <Pegazus> <geezusfreeek> i believe templates are known to be turing complete, actually ---> how do you hangup some templates? :p
19:46:57 <kwvarga> that as they get bigger, take longer
19:47:02 <helpme> hey guys, got a vb.net question... any takers?
19:47:13 <kwvarga> and I have had brute-force working with small amount of items
19:47:56 <Axman6> helpme: you know where you are right?
19:48:04 <Taejo> helpme: what language is this channel devoted to? and what language are you asking about? are there two more different languages?
19:48:17 <SamB_XP> helpme: what, you heard they stole our Monad Comprehensions or something ?
19:48:26 <SamB_XP> LINC isn't actually monad comprehensions, though ...
19:48:29 <geezusfreeek> Pegazus, http://tinyurl.com/ccrobe
19:48:52 <mriou> hi, I was wondering if there's a way to make a type and instance of Num rely on monadic functions
19:49:10 <ozy`> helpme: no. just no.
19:49:10 <mriou> probably not but just in case...
19:49:23 <ozy`> SamB_XP: that's LINQ... :p
19:49:24 <geezusfreeek> wow, and of course the part that takes you to the search page wouldn't be working today...
19:49:29 <mriou> (a type _an_ instance sorry)
19:49:47 <glguy> kwvarga, am I doing something wrong, or are all of the items in that list not enough to make the minimum weight?
19:49:55 <SamB_XP> ozy`: hey, I DID remember it wasn't spelled with a K
19:49:56 <geezusfreeek> ah worked the second time, nevermind ;)
19:49:58 <ksf> six hours into the day, and basically all I did was getting irritated on the cafe.
19:49:59 <kwvarga> Oh yeah forgot to mention
19:50:02 <ksf> Something's wrong.
19:50:05 <ozy`> SamB_XP: the Q is for "query"
19:50:13 * erikc registers letmeletmegooglethatforyouforyou.com
19:50:22 <mriou> I'd like to avoid this: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1182#a1182
19:50:36 <Pegazus> geezusfreeek: you are right... i have just remember how to hang them up :)
19:50:41 <mriou> the nasty error
19:50:59 <kwvarga> There is an unlimited (or user-defined limit of ceill(item_weight / weight_to_lose)) of each item
19:51:52 <Axman6> > 14.46*60
19:51:54 <lambdabot>   867.6
19:52:08 <geezusfreeek> Pegazus, by "hang them up" do you mean devise something with templates that doesn't terminate?
19:52:32 <geezusfreeek> if so, then i don't know how
19:53:07 <ozy`> > let x = 5 in x * 6.0
19:53:08 <lambdabot>   30.0
19:53:11 <ozy`> oh
19:53:38 <Pegazus> geezusfreeek: template <int N> class C {
19:54:30 <Pegazus> geezusfreeek: template <int N> class C { typedef C<N + 1> lala; }
19:54:48 <geezusfreeek> oh boy
19:54:52 <Pegazus> (assuming int is infinite :p)
19:54:55 <pumpkin> ozy`: is it possible to override that horrendous indentation rule in the haskell textmate bundle?
19:55:25 <ozy`> pumpkin: that was the thing that drove me away from textmate.
19:55:42 <geezusfreeek> i like emacs' haskell mode indentation
19:55:52 <Pegazus> this is a real one: template <class T> class C { typedef C<C<T> > lala; }
19:55:53 <pumpkin> I wish he'd just release 2.0 already :P
19:56:02 <ozy`> pumpkin: you're hardly alone there :p
19:56:14 <pumpkin> ozy`: or at least let us know he's alive
19:56:20 <pumpkin> :P
19:56:23 <geezusfreeek> Pegazus, oh nice. yay for C++
19:56:27 <pumpkin> he seems to have forgotten about us all
19:56:31 <kwvarga> glguy - you see my message bout unlimited (theoretical) amount of each item
19:56:34 <geezusfreeek> @karma c
19:56:35 <lambdabot> c has a karma of 0
19:56:35 <pumpkin> I even paid for the program!
19:56:35 <ozy`> pumpkin: he's been teasing ##textmate lately
19:56:43 <pumpkin> :o
19:56:52 <ozy`> 2.0 might be out in... a year
19:56:58 <ozy`> less if we're lucky
19:56:59 <ozy`> :(
19:57:05 <Ringo48> I have these data structures: http://pastebin.com/d7c3ec23e
19:57:39 <pumpkin> ozy`: wow
19:58:06 <pumpkin> I guess I know how annoying it is to have people bugging you to release
19:58:07 <geezusfreeek> wait, are we talking about _textmate_ 2.0?
19:58:10 <pumpkin> but still
19:58:13 <Ringo48> I'm trying to convert a nondeterministic finite automata into a deterministic finite automata using the algorithm in the "Dragon book" on compilers
19:58:17 <pumpkin> yeah :)
19:58:33 <geezusfreeek> i remember hearing about work on it when i abandoned textmate forever ago!
19:58:45 <geezusfreeek> it's surprising to me that it is still unreleased
19:58:45 <pumpkin> aw
19:58:51 <Axman6> what're you using now geezusfreeek?
19:58:57 <geezusfreeek> emacs
19:59:00 <pumpkin> emin
19:59:09 <Axman6> :(
19:59:16 <Axman6> i find emacs painful to use
19:59:29 <geezusfreeek> takes getting used to
19:59:35 <SamB_XP> maybe he should do point releases ;-P
20:00:57 <Pegazus> Ringo48: what's your problem?
20:01:25 <SamB_XP> Ringo48: the algorithm -- is it not trivial ?
20:01:27 <kwvarga> glguy - you around?
20:01:46 <Ringo48> well, I'm trying to figure out how to phrase the question right :-\
20:01:57 <Pegazus> O_o
20:02:20 <Gracenotes> Ringo48: heh... I was just working on that today :)
20:02:32 <Gracenotes> right now I'm working in an NFA-to-DFA converter
20:02:34 <erikc> emacs + viper/vimpulse
20:02:40 <Ringo48> heh, same here
20:02:47 <Gracenotes> really?
20:02:53 <pumpkin> Gracenotes: isn't that what he said earlier?
20:03:02 <Gracenotes> ...he did? :\
20:03:06 <pumpkin> Ringo48: btw, the singular is automaton :P
20:03:11 <pumpkin> Gracenotes: isn't that what you responded to? :o
20:03:13 <Gracenotes> sorry, I opened the paste earlier and just closed enough tabs to find it again
20:03:21 <pumpkin> :)
20:03:29 <Ringo48> yeah, I have a RE parser that generates an NFA
20:03:48 <Gracenotes> oh. I don't have that :X
20:04:12 <Ringo48> I can get the (Set.Set State) that would be the start state in the DFA
20:05:02 <pumpkin> you should just use the list monad and operate directly on NFAs :D
20:05:18 <Gracenotes> pumpkin: that sounds nice until you take epsilons into account
20:05:19 <Ringo48> and I can generate a (Map.Map (Set.Set State) (Map.Map NfaChar Set.Set State)) for that first set
20:05:27 <pumpkin> Gracenotes: fair enough :)
20:05:54 <Ringo48> oops, should be: (Map.Map (Set.Set State) (Map.Map NfaChar (Set.Set State)))
20:06:07 <Gracenotes> Ringo48: so the states in your DFA will the subsets of states in the NFA
20:06:16 <Ringo48> yeah
20:06:39 <Gracenotes> perhaps you could implement it first without worrying about epsilons, and then add support for them
20:06:43 * geezusfreeek settles down and starts writing a pure haskell implementation of threads
20:07:14 <Pegazus> a NFA doesn't allow epsilon transitions
20:07:27 <Gracenotes> DFA?
20:07:32 <Pegazus> an Epsilon-NFA allows it...
20:07:35 <Ringo48> I need to use elements of the inner map as keys to the outer map
20:07:50 <Pegazus> usually you first turn Epsilon-NFA to NFA (without epsilons), and then into a DFA
20:08:13 <Pegazus> i think you are doing Epsilon-NFA --> DFA and it's a little more complicated....
20:08:23 <Gracenotes> not that much complicated, actually
20:08:37 <Pegazus> not that much, but it's a lot easier in 2 steps :)
20:08:58 <Ringo48> well, I more or less have the algorithms figured out I think
20:09:00 <Gracenotes> it just means that in the single-step evaluation, you'll be doing one step related to the epsilons, and another step related to the state transformation
20:09:08 <Ringo48> I'm sure I could implement it in C++
20:09:12 <Gracenotes> single in quotes :)
20:10:06 <Gracenotes> it might help to have an auxiliary function that takes a state and returns all states accessible from that state using only epsilon transitions (including the state itself)
20:10:22 <Gracenotes> is auxiliary the right word? Perhaps it is.
20:10:35 <Ringo48> I have that
20:11:30 <Gracenotes> okay... then write the types, I guess, and the functions will write themselves :P
20:11:38 <Pegazus> O_o
20:12:43 <Ringo48> http://pastebin.com/df7fc85f
20:12:50 <Ringo48> that's all that I have so far
20:13:12 <Ringo48> everything is more or less working except for that last function, toDfa
20:13:30 <Gracenotes> wow -o-
20:13:36 <Axman6> > 100 * 150/ (60*14.46957)
20:13:37 <lambdabot>   17.27763852001131
20:13:57 <Axman6> 100 - 17.2
20:14:01 <Axman6> > 100 - 17.2
20:14:02 <lambdabot>   82.8
20:14:17 <Ringo48> heh, I just realized I need to comment more
20:14:33 <Pegazus> I just realized I need to comment more ---> try reading about "Self documenting code"
20:15:25 <Gracenotes> pssh, Haskell is naturally self documenting. Why call a variable x when you can call is stringIterationsLeft?
20:15:30 <Gracenotes> .it
20:15:57 <Pegazus> Gracenotes: as you just said... You can call it x... So the language isn't self documenting... A programmer is :)
20:16:05 <SamB_XP> Gracenotes: well, how about n ?
20:16:14 <chessguy> test cases help, too :)
20:16:26 <Pegazus> let's all do TDD :)
20:16:30 <Taejo> @hoogle isSpace
20:16:30 <lambdabot> Data.Char isSpace :: Char -> Bool
20:16:30 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
20:16:30 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
20:16:41 <Taejo> > Data.Char.isSpace ' '
20:16:42 <lambdabot>   True
20:16:44 <Taejo> > Data.Char.isSpace '\t'
20:16:45 <lambdabot>   True
20:16:47 <Taejo> > Data.Char.isSpace '\n'
20:16:48 <lambdabot>   True
20:16:56 <Gracenotes> SamB_XP: that's true... lengths and n seem made for each other, for some odd reason
20:16:56 <SamB_XP> Pegazus: if you mean Type Driven Design ...
20:17:18 <Pegazus> Test Driven Development...
20:17:29 <chessguy> @quote test
20:17:29 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
20:17:46 <Pegazus> unlearning? O_o
20:18:01 <Ringo48> I think I just need to go to bed
20:18:25 <Nafai> Pegazus: You have to unlearn what you learned in writing imperative programs when you learn Haskell
20:18:31 <Nafai> Pegazus: And that's the hardest part
20:18:41 <chessguy> Ringo48, is this converting between NFAs and DFAs?
20:18:56 <Ringo48> well, it's going to
20:19:02 <SamB_XP> Ringo48: that helps in almost every language, yes ;-)
20:19:09 <Pegazus> Nafai: it's best to combine it :)
20:19:27 <Gracenotes> I know -- a DFA to NFA converter! Exciting, huh? :P
20:19:27 <SamB_XP> Pegazus: do what now ?
20:19:49 <Pegazus> i've enriched my programming skill with every paradigm and "decent" language i've learn :)
20:20:10 <pumpkin> Pegazus: you going to use your imperative-fu to ace the ST monad?
20:20:11 <Pegazus> some things are easier to think in imperative, some in functional, some in whatever you want...
20:20:16 <SamB_XP> :t M.map S.singleton
20:20:17 <lambdabot> forall a k. M.Map k a -> M.Map k (S.Set a)
20:20:21 <Pegazus> it depends on the problem...
20:20:25 <SamB_XP> Gracenotes: done!
20:20:27 <bos> Hey, kids!
20:20:32 <pumpkin> hey dad!
20:20:36 <bos> I'm writing up some OSCON talk proposals.
20:20:42 <chessguy> hiya bos :)
20:20:43 <Ringo48> I'll also need to map the (Set.Set State)s to Ints at some point
20:20:49 <bos> If you were going to OSCON, what would you want to hear about?
20:21:06 <SamB_XP> Ringo48: I was writing the reverse mapping ;-)
20:22:01 <pumpkin> SamB_XP: o.O
20:22:10 <pumpkin> DFA to NFA!
20:22:17 <Gracenotes> actually, I was using assoc lists instead of maps and lists instead of sets in my implementation... perhaps I should use more mathy datatypes :)
20:22:19 <pumpkin> sounds epicly hard, maybe even impossible
20:22:24 <pumpkin> ;)
20:22:41 <SamB_XP> pumpkin: I wrote it in two dang tokens!
20:22:56 <pumpkin> wow, epic skillz0rz
20:23:28 <Ringo48> I dunno, the book said "set", so that's what I used :-)
20:23:32 <Gracenotes> it's interesting that, although DFAs and NFAs are isomorphic, repeatly converting back and forth using the common methods will yield something extremely complicated
20:23:50 <SamB_XP> Gracenotes: what do you mean ?
20:24:12 <SamB_XP> oh, the nested sets ?
20:24:18 <Gracenotes> yeah
20:24:34 <Gracenotes> all of which will accept the same language :)
20:25:35 <pumpkin> now write an enumerator for their languages!
20:26:23 <Gracenotes> too difficult. *writes an edominator instead*
20:26:23 <chessguy> hmm. i gotta believe that all this code can be simplified somehow
20:26:42 <Gracenotes> edenominator, even
20:27:01 <pumpkin> chessguy: it's haskell, all it takes is 3 *** and you can write every function
20:27:32 <chessguy> for one thing, Dfa and Nfa are virtually the same type
20:28:03 <Ringo48> I was thinking of that
20:28:10 <SamB_XP> aren't there only 3 or so functions you can write using only 3 *** ?
20:28:24 <Ringo48> but didn't see any use
20:28:40 <SamB_XP> :t ((***) (***)) (***)
20:28:41 <lambdabot> forall (a :: * -> * -> *) b c b' c' (a1 :: * -> * -> *) b1 c1 b'1 c'1. (Arrow a1, Arrow a) => (a b c, a1 b1 c1) -> (a b' c' -> a (b, b') (c, c'), a1 b'1 c'1 -> a1 (b1, b'1) (c1, c'1))
20:28:51 <SamB_XP> :t ((***) (***) (***))
20:28:52 <lambdabot> forall (a :: * -> * -> *) b c b' c' (a1 :: * -> * -> *) b1 c1 b'1 c'1. (Arrow a1, Arrow a) => (a b c, a1 b1 c1) -> (a b' c' -> a (b, b') (c, c'), a1 b'1 c'1 -> a1 (b1, b'1) (c1, c'1))
20:28:56 <Taejo> @where =<<
20:28:56 <lambdabot> I know nothing about =<<.
20:29:04 <Taejo> @hoogle =<<
20:29:04 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
20:29:04 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
20:29:06 <SamB_XP> wait, that's the same one
20:29:14 <SamB_XP> :t (***) ((***) (***))
20:29:14 <lambdabot> forall (a :: * -> * -> *) b c b' c' b'1 c'1 b'2 c'2. (Arrow a) => (b'2 -> c'2) -> (b'1 -> c'1, b'2) -> ((a b c, b'1) -> (a b' c' -> a (b, b') (c, c'), c'1), c'2)
20:29:21 <SamB_XP> any more ?
20:29:34 <Taejo> @unpl zip =<< bestSequence model
20:29:35 <lambdabot> ((bestSequence model) >>= zip)
20:29:47 <chessguy> lol
20:30:03 <Ringo48> all of that is for NFA only right now
20:30:36 <Ringo48> a lot of it's specifically for converting from a regex to NFA
20:30:37 <chessguy> case (Map.lookup st (n_transitions fa)) of
20:30:37 <chessguy>                      Just x -> x
20:30:37 <chessguy>                      Nothing -> Map.empty
20:30:42 <chessguy> this is all over the place
20:30:54 <chessguy> you should pull that out
20:32:34 <Ringo48> is there a more convenient way to do a lookup in a Map?
20:32:53 <Ringo48> that's the one thing I really noticed that was more verbose than the C++ version
20:33:41 <chessguy> anyway, bedtime here
20:33:44 <Ringo48> in C++ I could do nfa[0]['a'].insert(2)
20:33:49 <Taejo> @pl resegment model xs = zip xs $ bestSequence model xs
20:33:49 <lambdabot> resegment = ap zip . bestSequence
20:33:59 <Ringo48> thanks for the help
20:34:01 <Taejo> :t ap zip
20:34:02 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
20:34:25 <chessguy> Ringo48, ping me sometime if you want any more help. seems like an interesting project
20:34:44 <Ringo48> chessguy: alright, thanks
20:35:39 <Gracenotes> wow, you've done so much it doesn't seem there's much point to me doing anything :P
20:36:12 <mm_freak> indexing an element has O(n) complexity, so indexing all elements has O(n²) complexity, even though it requires only (n² + n)/2 steps, right?
20:36:21 <Ringo48> ?
20:36:39 <Gracenotes> in a Data.Map? O(log n)
20:37:21 <mm_freak> because constant factors are not taken into account in complexity
20:37:22 <Gracenotes> iirc indexing all elements can possibly be done with one pass through the list, depending on what data structures you have available
20:37:32 <mm_freak> Gracenotes: that's not the point
20:38:05 <pumpkin> mm_freak: yeah
20:38:25 <Twey> Ringo48: In your case, yes — abstract it away
20:38:30 <mm_freak> if i were to index all elements of a list for whatever reason, and indexing a single element is an O(n) operation, then indexing all is O(n²), isn't it?
20:38:32 <pumpkin> all the O is saying is the asymptotic behavior
20:38:42 <mm_freak> ok, thanks
20:39:12 <pumpkin> zipWith (!!) list [0..] :D
20:41:41 <hackage> Uploaded to hackage: happstack-util 0.1
20:41:41 <hackage> Uploaded to hackage: happstack-state 0.1
20:41:41 <hackage> Uploaded to hackage: happstack-server 0.1
20:41:41 <hackage> Uploaded to hackage: happstack-ixset 0.1
20:41:41 <hackage> Uploaded to hackage: happstack-data 0.1
20:42:56 <pumpkin> epic happstack
20:43:28 <redditbot> happstack hits hackage!
20:43:37 <ozy`> with a shovel!
20:44:40 <SamB_XP> knock some sense into it, yes!
20:45:10 <geezusfreeek> woowoo happstack
20:45:28 <Axman6> :)
20:47:34 * ozy` gulps down some brandy and runs outside to shovel snow at ten minutes to midnight
20:50:22 <pumpkin> OMG AXMAN
20:50:27 <Axman6> ZOMG!
20:50:39 <Axman6> man, that last post, i've written essays smaller than that
20:51:43 <knapr> if id o (let [x (ref a)] ...) and then change x or a, i dont change the other rght?
20:52:59 <pumpkin> Axman6: move to MUArrs
20:53:09 <ksf> the crystal ball saiz: references aren't the abstraction you're looking for.
20:53:20 <Axman6> reckon they'll be faster?
20:53:34 <pumpkin> Axman6: possibly, depends how fusible it is
20:53:51 <Axman6> probably not that fusible, but i may try
20:53:59 <pumpkin> Axman6: also, you can stick bools into STUArrays and other unboxed containers
20:54:07 <L11> I have a binary multiplication, but i'm getting an "on-exhaustive patterns in function . . ." error I corrected a similar error previously, but can't seem to locate it in this code: http://pastebin.com/d5f548bb1
20:55:38 <Cale> L11: What if the first list is empty, but the second has 2 or more elements?
20:55:57 <knapr> @faq can haskell bend over for clojure?
20:55:57 <lambdabot> The answer is: Yes! Haskell can do that.
20:56:31 <pumpkin> knapr: that's why :)
20:57:48 <L11> I added in a case for it, but it still throws that error
20:57:55 <Axman6> ok, time to head out. ozy`: i'll blog about that stuff later, i promise :)
20:58:05 <Cale> L11: what case did you add?
20:58:20 <L11> binProduct [] _                 = []
20:58:28 <L11> not sure if that's correct
20:58:58 <Cale> Well... that certainly handles any leftover case when the first list is empty.
20:59:22 <L11> so should that handle my exhaustive cases?
20:59:44 <Cale> Well... together with the other cases you have, it should be exhaustive now at least.
20:59:53 <Cale> Are you sure the error is exactly the same?
21:00:33 <L11> hm it appears like it is
21:00:45 <Cale> binProduct [] _ will match all the cases when the first list is empty, and binProduct (x:xs) y will match all the cases when it's nonempty, so it should be impossible to have a pattern match failure.
21:00:57 <Cale> But how is binSum defined?
21:01:12 <Gracenotes> the GHC compiler informs if there are overlapping patterns, but is there some means to check if a "patterns exhausted" error may come up? Based on the types of the expressions?
21:01:18 <L11> it may be binSum, I have had problems with it
21:01:33 <Cale> L11: It should say which function is the problem.
21:01:35 <Gracenotes> it seems possible...
21:01:39 <Cale> Does it still say binProduct?
21:01:42 <L11> http://pastebin.com/d493292de
21:01:53 <L11> oh no it says binCarry!
21:01:57 <L11> i didn't notice that :P
21:02:00 <L11> let me check that out
21:02:04 <pumpkin> ack
21:02:14 <Cale> wow...
21:02:31 <Cale> There are indeed a lot of cases which are not handled by binCarry
21:02:42 <Cale> Like, for example,  binCarry [] [] 2
21:03:02 <pumpkin> bos: a stream fusion proposal for OSCON? :D
21:03:09 <bos> pumpkin: you betcha
21:03:12 <L11> well i just am using 0, and 1's does that matter?
21:03:13 <Cale> Also, you're laying out if/then/else a bit strangely.
21:03:14 <pumpkin> awesome
21:03:21 <Cale> if foo
21:03:24 <Cale>    then bar
21:03:27 <Cale>    else quux
21:03:29 <L11> yea, first few days of Haskell - not sure of the layout
21:03:32 <pumpkin> quux?
21:03:34 <L11> alright i'll correct that
21:03:48 <L11> so in binCarry can i just have binCarry [] [] _ like i did in product?
21:03:51 <cjb> pumpkin: foo->bar->baz->quux->flibble :)
21:04:09 <Cale> Well, if you're certain that the third parameter is never anything else...
21:04:18 <Cale> Then...
21:04:20 * ksf uses oomph and argh instead of flibble.
21:04:29 <L11> well it should only be 1's and 0's
21:06:19 <Cale> okay, I don't see the missing case
21:06:45 <Cale> oh!
21:06:53 <Cale> binCarry [x,y] [] 0
21:07:26 <Cale> and more generally, when the 3rd parameter is 0, one is empty and the other has more than one element.
21:19:10 <Axman6> ozy`: ok, blog done!
21:19:38 <L11> Cale: I think I got it :)
21:19:51 <L11> well, missing a few bits sometimes
21:20:04 <ozy`> Axman6: OH SHI-
21:20:21 <ozy`> Axman6: well I didn't realize you'd go and write a post about it, but cool :p
21:20:51 <ozy`> (what I really want is feedback though... on what's still missing from the bundle)
21:21:15 <ozy`> (but that can wait, because I'll be unconscious)
21:21:22 <ozy`> Axman6: anyway, cool :p
21:23:01 <thoughtpolice> @tell augustss another problem with llvm 0.6.2.0 - undefined GetPointerToGlobal symbol
21:23:01 <lambdabot> Consider it noted.
21:23:06 <ozy`> you know... those shootout benchmarks should include compile time
21:23:30 <pumpkin> lol
21:23:36 <pumpkin> no, please!
21:23:47 <ozy`> let's see your C++ now, punks!
21:24:03 <pumpkin> ghc isn't exactly a ferrari
21:29:21 <thoughtpolice> it's faster than LHC
21:29:24 <thoughtpolice> for now!
21:29:26 <thoughtpolice> :>
21:30:17 <ozy`> but is it faster than g++? that's all I'm wondering....
21:34:56 <dons> Axman6: did you decide on the blog?
21:35:20 <shapr> Foo, all the MIT folks I've contacted don't have suggestions for CHUG venues.
21:36:15 <ozy`> dons: he posted some stuff. seems to be gone for the time being though
21:36:25 <dons> ok
21:37:56 <pumpkin> dons: he was very happy you'd posted his entry on reddit
21:38:33 <dons> k.
21:40:16 <travisbrady> i love Haskell...just wanted to say that
21:41:27 <Axman6> dons: hmm, not sure if my blog is planet haskell worthy. but if you feel it is, then ok then :) oy umight like my second latest post: http://axman6.homeip.net/blog/2009/02/n-bodies-evolution.html
21:42:27 <dons> ok.
21:42:33 <dons> definitely "worthy"
21:43:20 <dons> stick it on reddit.
21:43:22 <dons> yay travisbrady
21:43:28 <redditbot> Happstack 0.1 Released (one day early!)
21:43:38 <pumpkin> Axman6: Bools can be stuck into unboxed containers :)
21:44:26 <travisbrady> and a yay to you dons, thank you for much useful code and for learning the world on strictness annotations, etc
21:44:43 <travisbrady> dons: btw, what's the web stack like at Galois?
21:45:09 <shapr> Ok, now I have to track down Bluespec folks.
21:45:40 <cads> hey, you guys know of any channels where people of different programming philosophies hang out and try to understand each other?
21:45:48 <shapr> Well, there's #haskell
21:46:21 <shapr> Most of the other channels aren't very tolerant.
21:46:21 <cads> it is one of the broadest minded channels I've encountered, true.
21:46:33 <Axman6> pumpkin: yeah, but i did read something along those lines, i should find it again (and i'll change the post). what'd you think of the post anyway?
21:46:44 <pumpkin> Axman6: it was interesting :)
21:46:49 <pumpkin> it's great you got it going so fast
21:46:49 <Axman6> :)
21:46:57 <Axman6> yeah, i'm really pleased
21:47:40 <shapr> I'm excited about happstack!
21:48:08 <Axman6> me too :)
21:48:09 <cads> shapr: I am more likely to field general CS questions in here than say EFNet's #compsci
21:48:57 <shapr> cads: Yeah, I honestly can't think of any other particularly tolerant programming language channels.
21:49:18 <shapr> My philosophy is that people should go learn lots of languages! And hopefully Haskell will be one of the languages they learn.
21:49:19 <cads> #lisp should be :P
21:49:39 <cads> but it's easier to have a discussion about generalized lisp in here than in there
21:49:57 <cads> they're really stuck in the CL frame of mind
21:49:57 <shapr> My interactions with the lisp community have rarely been rewarding.
21:50:27 <Pseudonym> @quote VerityStob
21:50:27 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
21:50:33 <shapr> right, exactly
21:50:35 <shapr> g'day Pseudonym
21:50:38 <Pseudonym> G'day.
21:50:44 <cads> #clojure is a breath of fresh air, they're kinda there doing there own thing, vibrating with the excitement of bringing to life a new language
21:50:49 <shapr> cads: awesome!
21:51:07 <Axman6> are either of you australian?
21:51:08 <shapr> Hopefully #haskell can be a good example!
21:51:14 <shapr> Axman6: I'm Alabamsk.
21:51:15 * Pseudonym raises hand
21:51:18 <cads> anyways, wanted to say, love you guys
21:51:21 <shapr> :-)
21:51:27 <shapr> cads: We're glad you're here!
21:51:28 <Pseudonym> shapr is also partly scanned in avian
21:51:31 <shapr> right!
21:51:34 <Pseudonym> But only by osmosis.
21:51:35 <Axman6> ah, wel G'day Pseudonym. and thanks again for the channel shapr :P
21:51:37 <Axman6> well*
21:51:47 <shapr> cads: #haskell is as cool as it is because of all the cool people that spend time here!
21:51:51 <shapr> cads: this means you!
21:51:56 <Pseudonym> Yes!
21:52:04 <Pseudonym> If you're here, and you haven't been kicked off yet, you're cool.
21:52:07 <shapr> haha
21:52:10 <geezusfreeek> cads, there is #oasis, but it rarely has the kind of traffic and overflowing goodness that #haskell has
21:52:18 <Pseudonym> We ban the uncool people./
21:52:31 <shapr> Yeah, I am the incarnation of the banhammer of doom.. or something like that.
21:52:46 <glguy> shapr, when is the last time you banned/
21:52:51 <shapr> ok ok, it's been awhile.
21:52:57 <shapr> Igloo's aliases are faster.
21:53:06 <cads> geezusfreeek: thanks!
21:53:18 <geezusfreeek> np
21:53:26 <cads> Pseudonym: it will be a while till I'm one of the
21:53:28 <sbahra> Ban ChanServ
21:53:30 <cads> cool people.. I'm sure
21:53:31 <Axman6> Pseudonym: where in aus are you from?
21:53:57 <Pseudonym> Axman: Melbourne.
21:54:15 <shapr> glguy: When was the last time you banned someone?
21:54:15 <Axman6> ah right. i'm up in Canberra :)
21:54:20 <Pseudonym> Ah, right.
21:54:25 <shapr> glguy: Maybe you're the new banhammer avatar?
21:54:29 <glguy> shapr, 92702 seconds ago
21:54:33 <shapr> whoa
21:54:40 <Pseudonym> One of the few places in Australia with more insane weather than Melbourne.
21:54:44 <shapr> Is that an irssi alias?
21:54:55 <glguy> no, i just looked it up
21:55:01 <shapr> wow
21:55:04 <Pseudonym> So you're at... ANU?
21:55:08 <Axman6> yep
21:55:17 <Pseudonym> Cool.
21:55:30 <Pseudonym> Is there a lot of FP going on there?
21:55:40 <dons> yeah, i think so.
21:55:49 <Axman6> and loving it. finally some schooling that fits with how i learn. i hever did well in school (never badly, just never excelled), but now i'm getting HD's and stuff
21:56:04 <Axman6> there's a little, much more at UNSW though
21:56:08 <Pseudonym> Sure.
21:56:24 <Pseudonym> John Shepherd taught me Miranda, back when he was at Unimelb.
21:56:32 <Pseudonym> I don't think he does FP any more.
21:57:42 <Axman6> hmm, i think that may have been my friend's comp lecturer
21:59:43 * Axman6 gets toast for him and his gf
22:00:14 <Pseudonym> Mmmm... toast.
22:02:10 <pumpkin> mmm I haven't had toast in so long
22:02:26 <shapr> vegemite?
22:02:33 <shapr> er wait, I'm sleeping, nm!
22:02:48 <Pseudonym> What's wrong with vegemite, hmm?
22:02:51 <nanothief> dreaming of vegemite?
22:03:04 <pumpkin> mmm vegemite
22:03:15 <pumpkin> strangely enough, I like both marmite and vegemite!
22:03:27 * QtPlatypus mmms at the idea of vegemite.
22:03:38 <Pseudonym> You can just imagine these Australians sitting around saying: "What is this brown, sticky, yeasty, salty mess down the bottom of the beer barrel?  I know!  Let's spread it on toast!"
22:03:58 <pumpkin> lol
22:04:03 <QtPlatypus> Pseudonym: They where most likely drunk at the time.
22:04:04 <pumpkin> is that how it was discovered/invented?
22:04:39 <QtPlatypus> I think it was invented as a cheep alternative to marmite.
22:04:45 <Pseudonym> Possibly.
22:05:09 <QtPlatypus> And a way to get rid of the sticky yeasty mess at the bottem of beer barrels.
22:05:21 <lepassive> I heard Linspire is using Haskell for its startup scripts is that true ?
22:05:23 <pumpkin> :)
22:06:11 <cads> do you guys know if category theory is ever used in textbooks as a fundamental framework for a subject where classically set theory has been used?
22:06:34 <ddarius> cads: Of course!
22:06:38 <cads> for example a text on anaylsis that starts out with some basics from cat theory, and builds the analysis of functions from it
22:07:02 <cads> ddarius: is category theory itself built on set theory?
22:07:35 <Pseudonym> cads: You can do it either way.
22:07:44 <ddarius> cads: That's usually the easiest and most practical way to present it, but it's not necessary.
22:07:45 <Pseudonym> Either build category theory on top of sets, or build set theory on top of categories.
22:08:06 <Pseudonym> The reason why they do it that way customarily is that people learning category theory usually already know what a set is.
22:08:24 <cads> so in a sense they equivalent?
22:08:27 <cads> ...
22:08:38 <cads> insert correct english, please..
22:08:57 <Pseudonym> I'm not sure if "equivalent" is quite the right term.
22:09:12 <Pseudonym> It's more like they're different bases.
22:09:19 <Pseudonym> You can build maths on the basis of category theory.
22:09:24 <Pseudonym> Or on the basis of set theory.
22:09:30 <Pseudonym> Sort of thing.
22:09:31 <cads> what I seem to gather about category theory is that it's a deeper, fundamentally more intuitive way of viewing the foundations of mathematics
22:09:44 <Pseudonym> I don't know about "more intuitive".
22:10:01 <cads> hehe, perhaps that's what the catsters would say :D
22:10:09 <Pseudonym> I think that any new way of viewing the foundations of mathematics will reveal new insights.
22:10:45 <rwbarton> I don't think providing foundations for mathematics is the primary goal of category theory though.
22:10:53 <ddarius> I mostly don't care about the foundations of mathematics.
22:11:17 <ddarius> Usually category theory is more presented as a organizational thing rather than "foundations"
22:11:21 <Pseudonym> Right.
22:11:25 <Pseudonym> It's like design patterns for maths.
22:12:01 <cads> well, I never got very deep into set theory or higher maths in general, and I would like to. It seems like using a theory of categories could make understanding and learning in various fields a more holistic thing.
22:12:06 <cads> ah
22:12:16 <cads> design patterns for math sounds like a good thing
22:12:45 <rwbarton> It is a good thing. :)
22:12:46 * Axman6 is back!
22:13:01 <cads> I've been wary of diving in an specializing in something, for fear of blocking myself off from another interesting subject
22:13:04 <Pseudonym> Yeah.  The idea is that if the same pattern keeps turning up in different areas, you define it formally and give it a name so you can reason about it independent of any particular implementation.
22:13:06 * pumpkin proposes to make Theory into a mathematical object
22:13:12 <pumpkin> to increase abstraction
22:13:21 <ddarius> Using CT does unify a lot, but this is regardless of whether it's "foundational" or not.
22:13:23 <rwbarton> pumpkin: I think Lawvere already did that.
22:13:23 <pumpkin> Axman6: welcome back!
22:13:27 <pumpkin> rwbarton: :(
22:13:36 <ddarius> Indeed
22:13:40 <ddarius> @googl "Lawvere theory"
22:13:43 <lambdabot> http://linkinghub.elsevier.com/retrieve/pii/S1571066106004002
22:13:43 <lambdabot> Title: ScienceDirect - Electronic Notes in Theoretical Computer Science : Countable Law ...
22:14:21 <pumpkin> cool
22:14:23 <dolio> @go functorial semantics of algebraic theories
22:14:24 <lambdabot> http://www.tac.mta.ca/tac/reprints/articles/5/tr5abs.html
22:14:24 <lambdabot> Title: Functorial Semantics of Algebraic Theories
22:14:41 <cads> ddarius: I'm not the kind of nitpicker that will really look too hard at the foundations, and to that end set theory doesn't seem very fun to do for its own end
22:15:07 <cads> category theory is one of those things that seems really useful in practice though
22:16:36 <cads> can you guys suggest some introductory texts that show category theory and how to use it in practice?
22:16:47 <kapil> pumpkin, you've been pre-empted. look at "toposes, triples and theories" by barr and wells
22:16:57 <dolio> cads: That thesis (by Lawvere) has some work on directly axiomatizing category theory.
22:17:07 <pumpkin> :(
22:17:08 <dolio> Which I thought was pretty interesting.
22:17:21 <pumpkin> kapil, ddarius, dolio: thanks :)
22:17:21 <cads> thanks dolio, ddarius
22:18:13 <ddarius> cads:  There are some lecture notes by Barr and Wells that are rather good if you are coming from a CS perspective.
22:18:14 <dolio> I don't if there's anything he wrote after that that's better.
22:18:23 <dolio> That's not even what the thesis is about.
22:18:41 <ddarius> @google "The Category of Categories as a foundation for mathematics"
22:18:43 <lambdabot> http://planetmath.org/encyclopedia/CategoryOfCategories.html
22:18:43 <lambdabot> Title: PlanetMath: William Francis Lawvere
22:18:52 <cads> I don't think I'm smart enough to be able to grok the vast majority of maths fields, but I think that being able to command more powerful abstractions will allow me to get more done where I am capable
22:19:10 <ddarius> cads: Goguen's "Categorical Manifesto" is a nice synopsis of what to use various categorical ideas for, but it doesn't explain them.
22:19:38 <ddarius> cads: http://www.let.uu.nl/esslli/Courses/barr-wells.html
22:19:52 <Axman6> pumpkin: guess what
22:20:05 <pumpkin> I guess... unicorns!
22:20:17 <cads> wow, I've got some reading!
22:20:19 <ddarius> cads: Cale has an electronic version of a book that is a great introduction.
22:20:26 * Axman6 <-- is on planet haskell now
22:20:32 <pumpkin> Axman6: yay!
22:20:36 <Axman6> :D
22:20:51 <pumpkin> congrats :)
22:21:25 <Axman6> i think i'm getting i too deep man
22:22:01 <jml> my RWH arrived.
22:22:04 <kapil> one of the ideas behind topos theory can be put naively as follows. any sufficiently rich category (read topos) generates/contains all (the rest of) mathematics.
22:22:15 <dolio> ddarius: Google seems to be having trouble finding that one.
22:22:22 <Axman6> jml: hooray
22:22:32 <jml> it's bigger than I thought it would be
22:22:40 <jml> I guess the real world is kind of complicated.
22:22:48 <Axman6> it was supposed to be 300 pages i think
22:23:38 <jml> also, it's been a while since I bought an O'Reilly book. Gosh I love their look & feel.
22:23:56 <ddarius> dolio: Which one?
22:24:02 <Axman6> yeah :)
22:24:19 <cads> kapil, that's wild
22:24:20 <dolio> ... as a Foundation for Mathematics
22:24:38 <ddarius> dolio: I don't believe there's a freely available online copy.
22:24:43 <dolio> Yeah.
22:25:04 <dolio> Oh well.
22:25:35 <ddarius> On the TACS preprints page (I believe) is a paper where he builds a categorical set theory.
22:26:04 <ddarius> s/pre/re
22:26:05 <kapil> cads, lawvere says that a topos can be used instead of the usual category of sets. so at least if you believe that set theory builds all of mathematics then so does topos theory.
22:26:39 <ddarius> http://www.tac.mta.ca/tac/reprints/articles/11/tr11abs.html
22:26:57 <cads> it's such a wide subject, it's hard to imagine a small kernel of it that could be used as a preface to another subject. But then, texts on set theory show that it too is very wide, but when detail about itself is not concerned, it's tiny.
22:27:12 <lepassive> when i should put or omit do in haskell ?
22:27:38 <mauke> when you want to use do notation
22:27:44 * cads is thinking of the 10 or so page chapter on preliminary concepts in his real analysis book
22:28:00 <Heffalump> lepassive: the do in a singleton statement, e.g. "do foo" is redundant
22:28:10 <Axman6> lepassive: use do when it's more clear to do so basically. i find things like xs >>= \x -> ys >>= \y -> return (x,y) pretty ugly, mugy nicer in do notation
22:28:30 <mauke> liftA2 (,) xs ys
22:28:48 <lepassive> I see thanks
22:30:24 <Gracenotes> hm. Tragically, my Java lab is canceled tomorrow...
22:30:35 <geezusfreeek> tragic
22:31:01 <ddarius> You can go to a COBOL lab instead now.
22:31:12 <Axman6> s/can/must
22:31:25 <Gracenotes> \
22:31:48 <Gracenotes> PUT COBOL-LEARNING IN TIME-SLOT
22:34:44 <geezusfreeek> ContT is magically delicious
22:35:53 <dolio> They're after me lucky charms!
22:42:59 <travisbrady> anyone have any pointers with this? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1183#a1183
22:43:31 <Lemmih> travisbrady: slashCount is wrong.
22:44:47 <ski_> (geezusfreeek : .. what are you cooking ?)
22:45:33 <travisbrady> Lemmih: oh yes, mixing pointless v non-pointless
23:03:47 <jre2> how would I go about making an interactive haskell prompt for a running program?
23:04:15 <vegai> If I have something like  miscValue = 10^6*500 defined on toplevel, will this be evaluated only once or every time I use the value?
23:04:17 <jre2> eg, a ghci-like prompt for the user who can then read/write to a tvar that the main program uses
23:04:37 <vegai> jre2: I use System.Console.Editline.Readline
23:04:58 <vegai> comes with ghc-6.10
23:05:19 <ddarius> vegai: It depends on the type you give it.
23:10:06 <Taejo> what is the pragma for GADTs?
23:10:28 <jre2> vegai: ah, that makes short work of the first part (the repl).  any suggestions for evaluating the strings it gets as code within the context of the running program though?
23:10:33 <rwbarton> {-# LANGUAGE GADTs #-}
23:11:11 <Taejo> rwbarton: thanks. I was trying GADT.
23:11:36 <Smokey`> offtopic, but very cool: http://www.overclockers.com.au/news.php?id=752855
23:14:10 <rwbarton> jre2: could you just use ghci itself?
23:15:29 <jre2> rwbarton: hmm, maybe
23:16:22 <rwbarton> handle <- startProgram, which starts a thread running your program, then write functions that talk to the program via the handle
23:17:13 <Axman6> jre2: the easiest way is interact
23:17:18 <Axman6> :t interact
23:17:19 <lambdabot> (String -> String) -> IO ()
23:18:13 <Axman6> takes a finction from String to String, and executes it on on each line read, and prints te output
23:18:16 <rwbarton> (handle can be a TVar or a TChan or whatever)
23:19:12 <jre2> rwbarton: how do you get ghci to background an executing thread??
23:19:20 <rwbarton> jre2: forkIO should do it
23:20:55 <david48> Smokey`: cool indeed.
23:21:36 <dsrogers> greetings.
23:24:05 <Taejo> is there a library for length-counted lists?
23:24:15 <rwbarton> jre2: a simple example of what I have in mind: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=1184#a1184
23:24:16 <dsrogers> so, suppose I have a 2 argument function,f:: a->b->c and two filter functions g:: a'->a and h:: b'->b.  Is there already a library function to use f g and h to create the function f' :: a'->b'->c?
23:24:18 <mauke> Data.Sequence?
23:24:50 <vegai> ddarius: so, which type would be evaluated only once?
23:24:57 <mauke> @djinn (a -> b -> c) -> (a' -> a) -> (b' -> b) -> (a' -> b' -> c)
23:24:57 <lambdabot> f a b c d e = a (b d) (c e)
23:25:01 <mauke> @. pl djinn (a -> b -> c) -> (a' -> a) -> (b' -> b) -> (a' -> b' -> c)
23:25:01 <lambdabot> f = ((flip . ((.) .)) .) . (.)
23:25:01 <Taejo> mauke: I mean statically. So something where "head []" doesn't typecheck
23:25:16 <dsrogers> flip (flip f . f') . g' would be the definition...
23:25:28 <Gracenotes> :t liftA2
23:25:29 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
23:25:37 <Gracenotes> hm... not quite
23:25:38 <mauke> Gracenotes: no, that's for a single argument
23:25:52 <Gracenotes> ah, yeah. I always confuse that and on :/
23:25:56 <Gracenotes> :t on
23:25:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
23:26:01 <rwbarton> Taejo: there's FSVec in the parameterized-data package http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parameterized-data
23:26:04 <Gracenotes> I dunno. :X
23:26:30 <mauke> :t curry $ uncurry ?f . (?g *** ?h)
23:26:31 <lambdabot> forall a b a1 b1 c. (?h::b -> b1, ?g::a -> a1, ?f::a1 -> b1 -> c) => a -> b -> c
23:26:56 <Taejo> :t unfold
23:26:57 <lambdabot> Not in scope: `unfold'
23:26:59 <Taejo> :t unfoldr
23:27:00 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:27:42 <pumpkin> mmm visor for mac os rules
23:27:53 <vegai> jre2: or perhaps build your own input language with parsec
23:28:18 <vegai> or if it's simple enough, just use pattern matching on strings
23:29:07 <Gracenotes> hm...
23:29:33 <jre2> vegai: that was the lame option I was going to settle with, but I'd much rather use haskell
23:30:08 <jre2> trying the stm+ghci method atm
23:30:29 --- mode: ChanServ set +b xah_lee!*@*
23:30:29 --- kick: xah_lee was kicked by ChanServ (Banned:)
23:30:56 <mauke> <3 ChanServ
23:31:10 <rwbarton> @quote xahlee
23:31:10 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
23:31:32 <dolio> Wow, really?
23:31:40 <dolio> I've never heard him actually cause trouble in here.
23:32:14 <pumpkin> wow, an automatic chanserv ban
23:33:31 <papermachine> xahlee = lol
23:34:36 <dolio> @remember xahlee Dear lispers, LOL.
23:34:36 <lambdabot> I will remember.
23:34:56 <papermachine> I don't really see anything on its site that points towards it knowing Haskell, though
23:35:11 <papermachine> So perhaps we are safe.
23:35:19 <dolio> He's still obsessed with lisp.
23:35:42 <papermachine> Well that should keep him busy until the singularity.
23:35:50 <mauke> lisp is blub
23:37:18 <dolio> He does cross post all his stuff to comp.lang.functional, though.
23:37:31 <dolio> He seems to have taken an interest in OCaml/F# lately, too.
23:37:32 <Taejo> :t mzero
23:37:33 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
23:37:38 <Taejo> :t mempty
23:37:39 <lambdabot> forall a. (Monoid a) => a
23:37:41 <dolio> Maybe to team up with Jon Harrop.
23:37:43 <Taejo> @where Monoid
23:37:43 <lambdabot> Monoid is used in Writer monad, (->) w (Writer Comonad?), FingerTrees, and Foldable.
23:37:58 <Taejo> @hoogle Monoid
23:37:58 <lambdabot> module Data.Monoid
23:37:58 <lambdabot> Data.Monoid class Monoid a
23:39:30 <PeakerWork> Why is Monoid not in the Prelude?
23:39:54 <dolio> It's not in the H98 report.
23:40:24 <Taejo> @paste
23:40:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:40:25 <dolio> And the prelude is kept H98 compatible.
23:40:36 <Taejo> @hpaste2
23:40:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:40:58 <cizra> hpaste has been down for ages now )= Any hope it'll be up again?
23:41:08 <dolio> @where hpaste2
23:41:08 <lambdabot> http://moonpatio.com:8080/
23:41:24 <Taejo> dolio: thanks
23:41:57 <cizra> dolio: thanks. Beautifully fast, but unfortunately doesn't have an old paste I was looking for.
23:42:05 <dolio> Ah, yeah.
23:42:12 <dolio> That would be an issue.
23:42:31 <dolio> I don't know what's wrong with hpaste. You could bug shapr about it when he's around.
23:43:07 <cizra> shapr: *bug* *bug* What's up (or rather down) with hpaste?
23:44:17 <dolio> @remember xahlee It says: "A curried function is a function which returns a function as its result." LOL. That is incorrect.
23:44:17 <lambdabot> Done.
23:44:35 <vegai> is that cool?
23:45:55 <dolio> @remember xahlee In fact, my logical analytic habit has made me unable to read most math texts
23:45:55 <lambdabot> Done.
23:45:58 <Taejo> there seems to be a bug in GHC's code-printer. is it still in new GHCs or should I file a bug (I'm on 6.8.2). Code at http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1185#a1185 -- error says "(Cons x xs) mappend ys" instead of "(Cons x xs) `mappend` ys"
23:48:06 <dolio> Taejo: Looks correct on 6.10.1 to me.
23:48:47 <Taejo> dolio: ok
23:48:52 <Taejo> thanks for checking
23:49:05 <dolio> The monoid instance will not work, by the way.
23:49:20 <dolio> Because the type of mappend is "m -> m -> m".
23:49:29 <Taejo> yeah, I know. I understood the error message, but just noticed the bug in how it was printed
23:49:38 <dolio> Ah.
23:49:59 <dolio> With that type, you can only return one list or the other, or pick elements from each or something.
23:50:04 <jre2> rwbarton: bah, missed your example and wound up writing my own
23:50:54 <Taejo> dolio: indeed. I'll leave out the Monoid instance unless I find a use for one of those
23:51:37 <dolio> mempty is a problem, too, of course. You have to conjure a list of N elements out of thin air. :)
23:52:01 <Taejo> replicate n undefined
23:52:07 <dolio> :)
23:52:20 <Taejo> or just undefined
23:53:46 <Taejo> There should be a LANGUAGE ModernHaskell, with all the "accepted" extensions like multiparameter typeclasses and flexible instances
23:54:27 <dolio> They're kind of a monoid indexed monoid, or something.
23:54:39 <dolio> mempty :: v 0
23:54:40 <jre2> rwbarton: came up with this: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=1186#a1186
23:54:51 <dolio> mplus :: v m -> v n -> v (m + n)
23:55:48 <dolio> Not sure if there's a name for that already, though.
23:56:04 <Taejo> dolio: is there a way to get nice-looking typelevel operators like that? I have mplus :: Plus m n => v m -> v n -> v (Sum m n)
23:56:23 <Workybob> so, where did hpaste go?  it's been down for an age
23:56:25 <dolio> Well, there's -XTypeOperators.
23:56:43 <dolio> But + is a type variable. So you'd have to use :+ or something.
23:57:39 <Taejo> dolio: but aren't ((Succ Zero) :+ Zero) and (Zero :+ (Succ Zero)) different types?
23:57:56 <dolio> I think SPJ has talked about relaxing the names of type constructors, so you could use +, but I don't think it's been done yet.
23:58:34 <dolio> Are Sum (Succ Zero) Zero and Sum Zero (Succ Zero) different types?
23:58:55 <Taejo> dolio: Sum is an associated type
23:59:05 <Taejo> so yes, they're the same
23:59:06 <dolio> Then make :+ an associated type.
23:59:10 <Taejo> d'oh
23:59:37 <Taejo> but I'm struggling to get it to work
