00:01:14 <mjrosenb> ski_: within a do block
00:02:10 <ski_> except from the last part, i think they should be the same
00:02:24 <ski_> do you have any example where with differing behaviour ?
00:02:46 <ski_> (the "last part" meaning the last "statement")
00:03:00 <pumpkin> whee, my tool is coming along
00:03:40 <wli> addAF, subAF, mulAF, divAF :: (MonadReader Tolerance m, MonadError AFError m) => ArbFloat -> ArbFloat -> m ArbFloat
00:03:41 <wli> sgnAF, absAF, logAF, expAF :: (MonadReader Tolerance m, MonadError AFError m) => ArbFloat -> m ArbFloat
00:03:45 <mjrosenb> ski_: when foo is an if statement
00:03:58 <mjrosenb> it seems to not want to parse
00:04:29 <ski_> > do {if True then return () else []; return 23}
00:04:31 <lambdabot>   [23]
00:04:38 * wli is now clueless how to implement any of this.
00:04:46 <ski_> probably you're hitting layout rules
00:04:52 <mjrosenb> ski_: probably
00:05:01 <mjrosenb> ski_: i had something like
00:06:07 <mjrosenb> do { let x = foo; if x == test then do modify bar else put 3; return x }
00:06:12 <mjrosenb> except no semis
00:06:19 <mjrosenb> and on separate lines
00:06:58 <wli> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1355#a1355
00:07:05 <ski_>   do let x = foo
00:07:14 <ski_>      if x == test then do
00:07:26 <ski_>          modify bar
00:07:34 <ski_>        else
00:07:39 <ski_>          put 3
00:07:42 <ski_>      return x
00:07:43 <ski_> ?
00:07:50 <mjrosenb> yeah
00:08:03 <mjrosenb> except your 'else' is indented a bit more than mine was
00:08:41 <ski_> ok, then possibly it's that as soon as it sees `else' indented not more than `if', it considers an implicit `;' at that point
00:09:10 <ski_> (istr suggestions about changing this slightly for `do'-notation .. but i don't recall whether anything has been done)
00:09:30 <mjrosenb> that seems to be a bit wrong
00:09:56 <mjrosenb> yeah, with an extra space, it parses fine
00:10:09 <mjrosenb> haskell-mode needs to be tweaked
00:11:57 <int-e> ztirf__: ow, greencard is in pretty bad shape
00:12:37 <pumpkin> does it make sense to use a State transformer on a parsec parser?
00:12:50 <pumpkin> hmm
00:13:08 <ztirf__> int-e: I'll say
00:13:15 <pumpkin> probably not hmm
00:13:21 <pumpkin> ah well, I'll think about this tomorrow
00:13:26 <ztirf__> I tried for an hour or so and gave up
00:16:29 <int-e> ztirf__: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1388#a1388
00:17:32 <int-e> ztirf__: with those changes it /appears/ to work (with ghc 6.10) ... I'm not sure whether I caught everything.
00:18:14 <ztirf__> k, I'll give it a try the next time my OCD acts up again
00:18:17 <ztirf__> thanks
00:18:37 <cads> alc, are you here?
00:19:00 <mornfall> pumpkin: Like if x then do a else do b? : - )
00:19:03 <mornfall> --> food!
00:19:18 <ski_> food for thought
00:19:42 * ski_ imagines a pauper waving such a sign
00:20:09 <int-e> ztirf__: for binding to C, you'll probably be better off with c2hs or hsc2hs anyway.
00:20:31 <int-e> @seen gwern
00:20:31 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 4h 56m 37s ago.
00:21:07 <ztirf__> int-e: at this stage I don't even think I need those: I just need some kind of preprocessor to write all the with* and foreign declarations
00:21:14 <wli> How many signed digits of radix 2^32 with magnitude strictly less than 2^32 do I need for an absolute tolerance of 2^^(-32*a) and a relative tolerance of 2^^(-32*r)? Hmm.
00:21:21 <ztirf__> because that stuff is boring and ugly
00:24:01 <ztirf__> argh tired brain shutting down
00:24:05 <ztirf__> good night everyone
00:31:39 <lepassive> guys it's my 3rd day and can't get it working http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1389#a1389
00:32:18 <mjrosenb> lepassive: what is it not doing that it should?
00:32:52 <lepassive> mjrosenb, first it only prints the contents as "FILE" and don't recurse
00:32:59 * wli isn't even sure what it means to execute a comparator within a given tolerance.
00:34:03 <rainmann> is there a foldlM?
00:34:15 <wli> foldM
00:34:23 <mjrosenb> wli: assume that any two numbers that are equal up to the first n bits are equal overall.
00:34:28 <wli> Control.Monad.foldM even.
00:34:30 <dobblego> in constant space?
00:35:30 <wli> mjrosenb: I'm not sure how to get the first n bits.
00:35:47 <int-e> lepassive: you need a full path for the 'doesDirectoryExist' call
00:35:58 <mjrosenb> lepassive: efb
00:36:15 <mjrosenb> lepassive: and getdirectorycontents
00:36:55 <mjrosenb> well not necessarialy a full path, but at least a relative path based on the cwd
00:37:43 <wli> sum [ds ! k * 2^(-32*k) | k <- [0 ..]] commits an error of at most some magnitude when ds' elements are bounded and ds is truncated somewhere.
00:38:15 <lepassive> I guess I can inject the base path using list comprehension
00:38:21 <mjrosenb> wli: what is !?
00:38:27 <wli> !!
00:38:30 <mjrosenb> :t !
00:38:32 <lambdabot> parse error (possibly incorrect indentation)
00:38:36 <mjrosenb> :t (!)
00:38:38 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
00:41:01 <mjrosenb> if i have states :: [s], and update :: State s v, is there an easy way to update the k'th element of states, and get it's return value?
00:41:37 <ski_> make a lens
00:42:16 <mjrosenb> ski_: lens?
00:42:19 <ski_> nth :: Int -> Lens [s] s
00:42:48 <ski_>   newtype Lens a b = MkLens {runLens :: a -> (b,b -> a)}
00:43:02 <ski_>   get :: Lens a b -> (a -> b)
00:43:24 <mjrosenb> ski_: is this online anywhere
00:43:26 <mjrosenb> ?
00:43:53 <ski_> there's Data.Accessor, which is more or less the same thing
00:43:55 <lepassive> now its working, it there some way to fetch the basename of an entry ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1390#a1390
00:44:16 <dobblego> @type \f k -> foldl' (\a b -> a >>= flip f b) (return k) -- is this anywhere in the library?
00:44:18 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
00:44:31 <ski_> this is also called "functional references", which you might also google for more info
00:45:54 <ski_>   modify :: Lens a b -> State b c -> State a c
00:46:27 <ski_>   modify (nth k :: Lens [s] s) (update :: State s v) :: State [s] v
00:47:27 <ski_> (i'm not sure if Data.Accessor has this `modify' above .. it should not be very hard to define, though)
00:47:47 <redditbot> Djinn, monotonic
00:47:47 <redditbot> The Syntactic Century: "Computation" considered harmful.
00:47:53 <mjrosenb> http://www.haskell.org/ghc/dist/current/docs/libraries/ does not seem to know about data.accessor
00:49:01 <ski_> <http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor>
00:49:27 <wli> The absolute value of sum [(ds !! k) * (2^^(-32*k)) | k <- [0..n]] and all ((<= (2^32-1) . abs) ds is (2^32-1)*(1-2^^(-32*(n+1))/(1-2^^(-32)) = 2^32 - 2^^(-32*n)
00:49:40 <wli> bounded by that rather
00:50:48 <wli> I guess the infinite sum is bounded by 2^32
00:51:17 <jeffz`> mjrosenb: is it shipped with 6.10.2?
00:51:44 * jeffz` gets ahead of himself, 6.10.1..
00:52:47 <Axman6> > x^10
00:52:49 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x)
00:53:31 <int-e> ((x * x) * (x * x)) * ((x * x) * (x * x)) * (x * x)  would be prettier in that case.
00:53:57 <int-e> Err, (((x * x) * (x * x)) * ((x * x) * (x * x))) * (x * x)
00:54:07 <ski_> (i see `lift :: Monad m => T r s -> State s a -> StateT r m a' in `Data.Accessor' .. doesn't seem to be a variant that gives `StateT r a' instead ..)
00:55:27 <ski_> (\y -> join (*) y * y) (join (*) x)
00:56:32 <ski_> (would be nice if this abstract evaluation could show such sharing)
00:56:35 <wli> let x3 = x * x * x in x3 * x3 * x
00:57:03 <wli> Not expanding let/where could be enough.
00:57:35 <dolio> augustss wrote a version that showed sharing.
00:58:00 <ski_> (that `x3' version has one more multiplication ..)
00:58:23 <ski_> dolio : using `unsafePtrEq' ?
00:58:35 <dolio> I think he used stable names and unsafePerformIO.
00:58:42 <ski_> ok
00:58:48 <int-e> ski_: really? I could 4 multiplications in both cases.
00:58:54 <trofi> @pl \a b c -> a+b+c
00:58:54 <lambdabot> ((+) .) . (+)
00:58:54 <rwbarton> stable names doesn't seem like a requirement
00:59:30 <int-e> ski_: oh, the exponents are different. never mind
00:59:32 <wli> let x2 = x * x ; x4 = x2 * x2 ; x8 = x4 * x4 in x8 * x2
01:00:07 <int-e> wli: x3 * x3 * x should be x3 * x3 * x3 * x  for x^10
01:00:10 <ski_> int-e : .. er, right
01:00:21 <ski_> (mea culpa)
01:00:23 <wli> Sorry, right.
01:01:06 <mjrosenb> gah, if i do this the 'fast' way, i'm going to end up with 3 levels of state.  fun.
01:02:01 * wli tries to smoke out brute-force for shortest addition chains.
01:02:23 <lepassive> I did finally http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1391#a1391 and It works :)
01:03:09 <lepassive> now i want to extract a function from let rippedEntries and entries part as it's duplicated?
01:03:26 <wli> Or otherwise the least number of multiplications needed to raise an integer to some power.
01:03:57 <mjrosenb> wli: same thing
01:04:22 <wli> I barely remember the definition of an addition chain.
01:05:40 <int-e> > takeFileName "jhklafjhf/dfskjhkafsd/afsdfsdasdf/dfssdfa/fs/foo"
01:05:41 <lambdabot>   Not in scope: `takeFileName'
01:05:50 <dolio> rwbarton: How else would you do it? Unique name generator?
01:05:54 <int-e> > System.FilePath.takeFileName "jsdfsdasdf/dfssdfa/fs/foo"
01:05:55 <lambdabot>   /tmp/2672754518149526208:70:32:
01:05:55 <lambdabot>      Not in scope: `System.FilePath.takeFil...
01:06:01 <int-e> :/
01:06:05 <int-e> , System.FilePath.takeFileName "jsdfsdasdf/dfssdfa/fs/foo"
01:06:08 <lunabot>  luna: Not in scope: `System.FilePath.takeFileName'
01:06:25 <int-e> , takeFileName "jsdfsdasdf/dfssdfa/fs/foo" {- last try -}
01:06:26 <lunabot>  luna: Not in scope: `takeFileName'
01:08:54 <lepassive> @src takeFileName
01:08:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:09:22 <lepassive> It works, I used it instead of writing my own function
01:21:21 <pervonisse> I have a question about the ghc compiler. Does it compile down to (and optimizes it) C and then compile the C code?
01:22:19 <int-e> pervonisse: it can do that (with -fvia-C) but nowadays it uses its own native code generator by default. (where available.)
01:22:20 <lepassive> pervonisse, my best guess is it has nothing to do with C as it 's written in haskell itself
01:22:38 <lepassive> tell me what you think here's a beautiful tree http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1392#a1392
01:22:52 <pervonisse> int-e I see, thanks!
01:27:54 <int-e> lepassive: the type signature of viewDir is oddly placed. and a hint for improving the output: you should replace the depth counter by a prefix string.
01:28:31 <int-e> lepassive: and personally, I'd call viewEntry from main.
01:30:06 <lepassive> hmmm well thanks, but what is so *odd* about viewDir signature? I do call viewEntry in main don't I ?
01:30:37 <doserj> lepassive: if you only call viewEntry in the flipped form, why not define it flipped?
01:30:59 <int-e> lepassive: look where the  viewDir ::String -> Int -> IO ()
01:31:05 <int-e> lepassive: is in your paste
01:31:17 <philipp> http://paste.debian.net/28331/ <- why are there 5 threads although I was using +RTS -N2?
01:31:25 <doserj> lepassive: strictly speaking, viewFile doesn't need the "do", but that is ok, I guess
01:31:58 <lepassive> doserj, well i had to flip it as i declared it that way -some guy in #haskell was kind enough to fix it for me-
01:32:35 <lepassive> int-e, but why? I takes the Dir and the depth and does some IO action right ?
01:32:45 <int-e> philipp: ideas: safe FFI calls, and perhaps even a foreign lib using its own threads
01:33:01 <philipp> int-e: thanks
01:33:39 <int-e> lepassive: Ok, let me spell it out: The viewDir type signature is followed by a definition of viewEntry. That's odd.
01:33:52 <int-e> lepassive: not wrong, mind you. but odd nevertheless
01:34:29 <lepassive> ahh sorry just ordering mistake
01:36:34 <doserj> main = getArgs >>= getEntriesFullName.head >>= mapM_ (viewEntry 1) -- is shorter :)
01:37:27 <gio123> does somebody has electronic version of Garrett Birkhoff, Lattice Theory. ?
01:38:12 <lepassive> doserj, very cute, but I'm learning Haskell smoothly not golfing yet :)
01:40:38 <doserj> that's fine. keep your code comfortable for you.
01:44:03 * int-e feels that doserj should put spaces around the dot.
01:56:38 <hcube> hi! I'd like to define two data structures A and B both with name::String attribute. why is this inpossible in haskell? http://pastebin.com/m43ad2f89
01:56:50 <ivanm> hcube: since they'll have different types
01:57:52 <hcube> i know. the problem is that ghc drops error for same named attributes in different structures
01:58:54 <ivanm> ummmmm..... what?
01:59:23 <hcube> have you checked the pastebin link what i give?
01:59:25 <ivanm> you can't have two data structures (record based I presume) both with a name field, as then you'll have name :: A -> String _and_ name :: B -> String
01:59:42 <ivanm> yes, I just told you why
01:59:47 <ivanm> they'll have different types
02:00:05 <hcube> ok, then i'll try to understand :p
02:00:06 <ivanm> basically, you've defined the "n" function twice
02:00:17 <Axman6> "Dude, that's not nuffy at all." <- on a reddit post about dyslexic programmers
02:00:22 * Axman6 is one of them by the way
02:00:28 <ivanm> hcube: if they absolutely _have_ to both have a n :: a -> String function, then you can use a class
02:00:34 <ivanm> Axman6: /me doesn't get it
02:00:51 <Axman6> nuffy = funny
02:01:49 <jhjhjhjh> does somebody has electronic version of Garrett Birkhoff, Lattice Theory. ?
02:01:57 <ivanm> hiredman: http://pastebin.com/d1bcc2e15
02:02:08 <ivanm> jhjhjhjh: google books?
02:02:12 <ivanm> Axman6: ahhh
02:02:18 <jhjhjhjh> no
02:02:20 <jhjhjhjh> warez
02:02:44 <ivanm> hmmm?
02:02:57 <jhjhjhjh> ja
02:02:58 <ivanm> hcube: http://pastebin.com/d1bcc2e15 <-- I meant this link for you, not hiredman
02:03:07 <ivanm> jhjhjhjh: I have no idea what you're talking about...
02:03:15 <ivanm> I presume Lattice Theory is a book...
02:04:40 <jhjhjhjh> ivanm: yes it is a book, and I need lectronic djvu verssion of this book
02:05:03 <hcube> ivanm: thank you! i've got it :)
02:05:37 <wli> > let chains (n :: Integer) | n == 1 = [[1]] | otherwise = do { (i, j) <- [(n - k, k) | k <- [1 .. div n 2]] ; if i == j then map (n:) $ chains i else map head . group . sort $ do { csi <- chains i ; csj <- chains j ; return $ n : (sortBy (flip compare) $ csi `union` csj) }} ; minChains = head . groupBy ((==) `on` length) . sortBy (comparing length) . chains in minChains 17
02:05:41 <lambdabot>   [[17,16,8,4,2,1],[17,9,8,4,2,1]]
02:07:16 <int-e> philipp: oh an idea I forgot: forkOS will generally also create a new OS thread.
02:07:32 <int-e> philipp: as opposed to forkIO
02:08:16 <Axman6> "Are there any agnostic insomniac dyslexics here? I feel lonely when I lay awake at night wondering if there's a Dog."
02:08:19 <Axman6> Dyslexics have more fnu!
02:09:51 <mjrosenb> is there any instance where fmap cannot be replaced with liftM?
02:10:32 <doserj> mjrosenb: yes. when the functor is not a monad
02:11:13 <dobblego> mjrosenb, not all functors are monads
02:12:40 <Axman6> ((,) a) for example
02:12:41 <mjrosenb> example?
02:12:49 <Axman6> @instances Monad
02:12:50 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:12:52 <Axman6> @instances Functor
02:12:53 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:13:22 <wli> mjrosenb: Arrays?
02:13:24 <Twey> @index unsafeCoerce
02:13:25 <lambdabot> bzzt
02:13:48 <Twey> 'When is a functor not a functor?  When it's a monad!'
02:14:25 <dobblego> newtype Accy o a = Acc o
02:15:40 <philipp> int-e: yeah, i figured if you use -Nx then you get 2x+1 threads, so one OS thread per thread and +1 garbage collector or so
02:17:15 <dobblego> @type \f x -> x >>= (return . f) -- doserj though all monads are functors
02:17:16 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
02:18:12 <Twey> All monads are functors, but not all Monads are Functors.
02:18:36 <Axman6> dobblego: you shoudl consider naming that mmap, to fuck with C and C++ users
02:18:40 <Axman6> should*
02:18:54 <Twey> It's a bit silly, and I'd ask if it was going to be fixed in Prime, but I've asked before and forgotten the answer, so I'd feel silly.
02:18:55 <int-e> philipp: the GC will run on the haskell worker threads.
02:19:06 <philipp> btw. how do you use threads if your program is using State heavily?
02:19:11 <int-e> philipp: (of which there'll be two with -N2)
02:19:41 <mjrosenb> philipp: State just threads a context around with everything else
02:19:41 <Twey> philipp: You don't — you use an MVar
02:19:52 <Twey> (when branching off)
02:19:53 <mjrosenb> philipp: there's thothing special about the State monad
02:20:13 <Twey> Otherwise the state will be split, no?
02:20:29 <Axman6> philipp: from what i understand of State, it's just a way of not having to explicitly pass around a parameter with your state in it
02:20:35 <philipp> well there is no parMapM ;-)
02:20:40 <wli> This is one case where I want a set monad or some such.
02:20:42 <Twey> (of course you can use runState again)
02:24:48 <ivanm> jhjhjhjh: have you tried google? and why djvu in particular?
02:32:04 * beelsebob ponders if Cale or byorgey or Peaker or anyone else involved last night are about
02:46:53 * wli is desperate for a Set monad.
02:49:03 <BONUS> afaik there's no sane way to make Set a monad :\
02:49:20 <wli> Not in Haskell as it now stands, no.
02:51:24 <wli> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1356#a1356
02:54:56 <dolio> Need some class families/associated classes.
02:56:17 <mjrosenb> strange... it seems like if i do
02:56:52 <mjrosenb> randomR (0,5) (mkStdGen x)
02:57:25 <mjrosenb> the result is always 5
02:57:37 <dolio> Are you always using the same x?
02:57:53 <mjrosenb> no
02:58:14 <dolio> Huh.
02:58:31 <dolio> > map (randomR (0,5) . mkStdGen) [1..10]
02:58:33 <lambdabot>   [(5,80028 40692),(5,120042 40692),(5,160056 40692),(5,200070 40692),(5,2400...
02:58:43 <dolio> Wow, that's pretty bad.
02:58:49 <dolio> > map (randomR (0,5) . mkStdGen) [11..20]
02:58:51 <lambdabot>   [(5,480168 40692),(5,520182 40692),(5,560196 40692),(5,600210 40692),(5,640...
02:59:17 <dolio> > dropWhile ((== 5) . fst) $ map (randomR (0,5) . mkStdGen) [1..]
02:59:19 <lambdabot>   [(4,27803 40692),(4,67817 40692),(4,107831 40692),(4,147845 40692),(4,18785...
02:59:50 <mjrosenb> ok, so it's not *always* 5
03:00:00 <dolio> > dropWhile ((== 5) . fst . randomR (0,5) . mkStdGen) [1..]
03:00:02 <lambdabot>   [53668,53669,53670,53671,53672,53673,53674,53675,53676,53677,53678,53679,53...
03:00:11 <dolio> Just the first 53667 times.
03:00:13 <mjrosenb> wtf
03:00:23 <dolio> Looks like it goes on to a string of 4s after that.
03:00:44 <Axman6> it used the xkcd randomisation algorithm
03:00:55 <mjrosenb> evidently, it was never meant to be used with a range of 6
03:02:53 <mjrosenb> >  map (fst . randomR (0,11) . mkStdGen) [0..200]
03:02:57 <lambdabot>   [5,5,11,5,11,5,11,5,11,5,11,5,11,5,11,5,11,5,11,5,11,5,11,5,11,5,11,5,11,5,...
03:03:03 <mjrosenb> oh...
03:03:36 <wli> Can AT's somehow do Set monads?
03:03:49 <mjrosenb> >  map (fst . randomR (0,17) . mkStdGen) [0..20]
03:03:51 <lambdabot>   [17,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]
03:05:53 <dolio> I don't associated types are what you'd typically use for set monads. Just multiparameter type classes.
03:06:32 <dolio> class Monad m a where return :: a -> m a ; (>>=) :: Monad m b => m a -> (a -> m b) -> m b
03:06:44 <int-e> > let step = snd . randomR undefined in map (fst . randomR (0,11) . step . step . step . mkStdGen) [0..200]
03:06:45 <mjrosenb> > take 10 . map length . group . map (fst . randomR (0,5) . mkStdGen) $ [0..]
03:06:46 <lambdabot>   Add a type signature
03:06:48 <dolio> But, if you could do associated classes, you could alternately do:
03:06:48 <lambdabot>   [53668,53668,53668,53669,53668,53668,53669,53668,53668,53669]
03:06:50 <doserj> > map (take 5 . randomRs (0,5) . mkStdGen) [1..100]
03:06:51 <lambdabot>   [[5,4,1,5,4],[5,3,0,4,3],[5,3,4,3,3],[5,2,2,1,3],[5,1,1,0,2],[5,0,5,5,2],[5...
03:07:21 <int-e> > let step = snd . randomR (0,0) in map (fst . randomR (0,11) . step . step . step . mkStdGen) [0..200]
03:07:23 <lambdabot>   [0,5,10,3,1,6,11,4,9,7,0,5,10,3,1,6,11,4,3,7,0,5,10,9,1,6,11,4,3,7,0,5,10,9...
03:07:44 <doserj> mjrosenb: just throw the first random value away :)
03:07:55 <mjrosenb> doserj: yes, but.....
03:07:55 <dolio> class Monad m where { class Obj a ; return :: Obj a => a -> m a ; (>>=) :: (Obj a, Obj b) => m a -> (a -> m b) -> m b }
03:08:19 <mjrosenb> > take 20 . map length . group . map (fst . randomR (0,5) . mkStdGen) $ [0..]
03:08:22 <dolio> In the former you do 'instance Ord a => Monad Set a where ...'
03:08:23 <lambdabot>   [53668,53668,53668,53669,53668,53668,53669,53668,53668,53669,53668,53668,53...
03:09:00 <dolio> In the latter, 'instance Monad Set where { class Ord a => Obj a ; instance Ord a => Obj a ; ... } or something like that.
03:09:03 <int-e> @src mkStdGen32
03:09:03 <lambdabot> Source not found. My brain just exploded
03:09:10 <int-e> @src mkStdGen
03:09:11 <lambdabot> Source not found. Take a stress pill and think things over.
03:09:47 <int-e> mkStdGen is a joke :/
03:10:10 <doserj> > map ((!!1) . randomRs (0,5) . mkStdGen) [1..100]
03:10:11 <lambdabot>   [4,3,3,2,1,0,0,5,4,3,3,2,1,0,0,5,4,3,3,2,1,0,0,5,4,3,3,2,1,0,0,5,4,3,3,2,1,...
03:10:45 <dolio> Nice.
03:10:58 <doserj> > map ((!!2) . randomRs (0,5) . mkStdGen) [1..100]
03:10:59 <lambdabot>   [1,0,4,2,1,5,3,2,0,5,3,1,0,4,2,1,5,4,2,0,5,3,1,0,4,3,1,5,4,2,0,5,3,2,0,4,3,...
03:11:01 <mjrosenb> > take 10 . map length . group . map (fst . randomR (0,6) . mkStdGen) $ [0..]
03:11:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
03:11:18 <mjrosenb> like really, it's just 6
03:11:40 <int-e> > cycle [4,3,3,2,1,0,0,5]
03:11:41 <lambdabot>   [4,3,3,2,1,0,0,5,4,3,3,2,1,0,0,5,4,3,3,2,1,0,0,5,4,3,3,2,1,0,0,5,4,3,3,2,1,...
03:11:49 <doserj> > map (take 5 . randomRs (0,6) . mkStdGen) [1..100]
03:11:51 <lambdabot>   [[2,5,6,3,0],[4,1,1,1,3],[6,5,2,6,0],[1,1,3,3,4],[3,4,5,1,0],[5,0,6,6,4],[0...
03:12:22 <Asztal> Anyone know why HaskellDB thinks id, zip, and return are keywords? (just curious)
03:12:47 <int-e> > transpose $ map (map (chr . (+48)) . take 5 . randomRs (0,6) . mkStdGen) [1..20]
03:12:49 <lambdabot>   ["24613502461350246135","51514040363625251414","61235602356023460234","3163...
03:13:23 <Asztal> it prefixes them with 'x' when generating haskell modules :(
03:13:58 <int-e> Asztal: they are part of the standard prelude ... not quite keywords
03:14:43 <Asztal> do you think it should import qualified Prelude in the generated modules if it needs them (which it doesn't seem to)?
03:21:21 <int-e> Asztal: Yes, I think it should do that. The list looks fairly random anyway - maybe collisions that the author experienced in real life
03:33:10 <paolino> which is the simplest library for console user interface, windows compatible ?
03:35:40 <jeffz`> paolino: not sure that there is one, you can either create bindings to the windows stuff or use the regular terminal stuff
03:37:15 <jeffz`> anything beyond reading and writing stdin,stdout,stderr diverges pretty quickly
03:44:09 <olsner> maybe you could use gtk2hs to implement a portable console to make your UI in :)
03:49:08 <paolino> is mingw simple to install, as haskeline claims to be windows compatible via mingw ?
03:49:13 <colin___> how can I create an account on the wiki? new account creation has been disabled
03:49:30 <ivanm> paolino: from memory, it's a lot easier to install than cygwin ;-)
03:50:32 <paolino> mhh, seems noone ever remember what windows was, what a new age :)
03:50:56 <ivanm> heh
03:52:00 <colin___> #xmonad
03:57:01 <maltem> How do I spawn an interactive process, but pretend towards that process that this is not a pipe, but rather a tty?
03:59:05 <colin___> I didn't see an answer - so I'll try again - does anyone know how to get an account on the haskell wiki? New account creation has been disabled for anti-spam
04:00:31 <maltem> (nvm, I think openPseudoTerminal is what I was looking for)
04:00:53 <Twey> :t foldl
04:00:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:00:58 <kelik> hi
04:01:06 <maltem> colin___: I think there is someone who you can email, mentioned in some recente Haskell Weekly News
04:02:26 <Twey> Oh, well that's user-friendly and not discouraging at all.
04:03:42 <kelik> hii
04:03:49 <wli> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1356#a1357 <--- more addition chain gobbledygook
04:03:50 <colin___> so where can I look this up?
04:04:28 <the_unmaker> hi ho haskelletters
04:04:35 <the_unmaker> haskelleteers?
04:04:58 <ivanm> hey the_unmaker
04:05:14 <Jarvellis> haskellites?
04:05:22 <ivanm> @go haskell weekly news
04:05:23 <lambdabot> http://sequence.complete.org/hwn
04:05:23 <lambdabot> Title: Haskell Weekly News | The Haskell Sequence
04:05:28 <ivanm> colin___: ^^ look there
04:07:18 <colin___> thanks ivanm - I have found it - it's Ashley Yakely
04:10:24 * wli isn't entirely sure if all the data structures are actually speeding things up but anyway.
04:10:59 <mathijs> Has anyone tried kdevelop for coding haskell?
04:11:20 <the_unmaker> hello gents
04:11:22 <the_unmaker> hows life
04:13:41 <maltem> So now I got the file descriptors from openPseudoTerminal, how do I put a process on the pty?
04:16:14 <mathijs> RWH tells me on (http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html - scroll down to "MVar and Chan are non-strict") that there's supposed to be a problem to look out for when using MVar in 2 threads. The code that's presented there runs fine here. Is there another way to trigger the problem that's being addressed?
04:18:27 <wli> Any comments on the addition chain code?
04:18:49 <the_unmaker> http://www.prevayler.org is happs mostly like this
04:20:57 <dolio> mathijs: It's not that the code doesn't work. It's that all the work is still done in one thread.
04:21:33 <dolio> Because the one thread gets forked, and then sticks an unevaluated thunk in the mvar, which only gets evaluated when it's actually used in the original thread.
04:22:27 <mathijs> dolio: ah... I was expecting the main thread to keep waiting for a result that never came
04:22:36 <wli> (Maybe one could generate code from such addition chains, perhaps when they're augmented with some information like the addends.)
04:22:59 <maltem> wli: ahem, that hpaste seems to trigger a site CSS bug in my firefox :)
04:23:16 <mathijs> dolio: I get it now.  So I have to watch out not to pass thunks through MVars
04:23:28 <wli> Oh come on...
04:24:51 <maltem> well, reading "singl", scrolling down, scrolling right, scrolling up, reading "ton 1" isn't exactly fun
04:24:59 <wli> maltem: Try http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1358#a1358
04:26:13 <wli> I don't know how to dodge the horizontal scrolling garbage.
04:27:05 <maltem> wli: it's strange, some hpastes have this, some don't
04:28:31 <maltem> the workaround is the download link I guess
04:47:51 <jeltsch> Hello, there used to be a webpage giving hints about what to do when releasing a Haskell package. Somthing like “Announce it on haskell-cafe”, “Blog about it”, etc. Alas, I cannot find this page via Google since the search terms I can use are to widespread and therefore give me many false positives. Can anyone give me a link?
04:50:02 <doserj> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Publicity ?
04:57:51 <jeltsch> doserj: That’s it. Thanks a lot.
05:04:42 <Alpounet> Hi
05:06:53 <arjanb> hi
05:13:45 * wli experiences space usage problems with his addition chain code.
05:15:25 <wli> It's eating 1.4GB at this point.
05:17:11 <wli> It may be better to start with larger sets and then try to delete things from them.
05:17:15 <wli> I don't know.
05:21:37 <Alpounet> wli, what are you doin' ?
05:22:10 <wli> Addition chains, such as are used to find the fewest number of multiplications necessary to raise a number to some specific power.
05:25:30 <mathijs> are the .hi files that ghc creates some kind of bytecode? or are they just describing the interface for the .o files to help linking?
05:25:42 * wli will soon go back to arbitrary-precision arithmetic.
05:31:56 <daf> mathijs: they describe interfaces, yes
05:32:06 <daf> mathijs: but they are not just for the .o files
05:33:36 <mathijs> daf: thanks, I found the piece of ghc documentation about them.
05:33:58 <mathijs> daf: do you know if there's something like 'haskell bytecode'?
05:35:37 <daf> there isn't a standard bytecode format, if that's what you mean
05:35:38 <mathijs> as in... something that's machine-independent but already processed very far?  I'm looking for a way to serialize (Data.Binary) IO actions and functions.
05:36:08 <mathijs> daf: ok thanks, yes that's what I meant.
05:42:13 <daf> mathijs: perhaps you can express your actions using pure structures, and serialize them?
05:42:41 <paolino> is it possible to derive an instance out of a data declaration  ?
05:43:54 <rdst> data List a = Node{ val :: a, next :: MVar (List a)} | Null     if I create long list and set the second Node to Null, is it some garbage in memory?
05:45:14 <paolino> if someone has forget to do it in the library, can I use deriving instead of handwriting the methods in the importing module ?
05:46:06 <daf> paolino: yes, but it's an extension
05:47:05 <daf> paolino: http://haskell.org/haskellwiki/GHC/StandAloneDeriving
05:47:05 <paolino>  XGeneralizedNewtypeDeriving ?
05:47:15 <paolino> ok
05:48:47 <philipp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1393#a1393 why doesn't 'fun2' run in parallel but 'fun' does?
05:55:57 <paolino> daf , I receive a parse error on the class name in ghc 6.10.1
05:57:15 <paolino> I put {-# LANGAUGE StandAloneDeriving #-} on top
05:57:39 <wjt> Are you sure that A should be capitalized
05:58:41 <paolino> deriving  Read for PublicKey
05:58:55 <paolino> wjt:  it makes no difference...
05:59:54 <ray> are you sure LANGUAGE should be misspelled like that
06:00:03 <wjt> :D
06:00:55 <paolino> ops
06:02:02 <paolino> no way to parse that line
06:03:55 <paolino> does it work for you ?
06:12:56 <drhodes> (123 meter)  is there some magic which could make that valid syntax?
06:13:47 <Cheshire> meter = Unit Meter :: Unit Integer
06:14:00 <Cheshire> instance Num (Unit a -> a) where ...
06:15:51 <beelsebob> > let meter = id in 123 `meter`
06:15:52 <lambdabot>   <no location info>: parse error on input `;'
06:15:59 <beelsebob> didn't think so
06:16:19 <drhodes> @let meter = Unit Meter :: Unit Integer
06:16:20 <lambdabot>  <local>:23:13: Not in scope: data constructor `Meter'
06:16:30 <drhodes> pfft bwaahahaha
06:16:38 <Cheshire> drhodes, you can define Unit like this:
06:17:14 <Cheshire> drhodes, oh just thinking abuot it properly.. it should be  meter = Meter :: Unit Integer
06:17:25 <Cheshire> data Unit t where
06:17:29 <Cheshire>  Meter :: Unit Integer
06:17:34 <Cheshire>  CM :: Unit Integer
06:17:35 <Cheshire>  ...
06:17:42 <drhodes> not to cloud the issue.  but  (arg function)
06:18:33 <drhodes> does what you say address the issue of reversed order?
06:19:02 <doserj> > let meter = id in (123 `meter`)
06:19:03 <lambdabot>   123
06:19:22 <doserj> the other possibility is to make 123 a function
06:19:55 <drhodes> well 123 would be user supplied and hopefully anything derived from Num
06:19:57 <ttt--> > let meter = const in (123 `meter`)
06:19:58 <lambdabot>       Overlapping instances for Show (b -> t)
06:19:58 <lambdabot>        arising from a use of `s...
06:23:08 <ttt--> > let {meter = id; inch = (3 *) } in (123 `meter`) + (123 `inch`)
06:23:09 <lambdabot>   492
06:23:25 <ttt--> woo
06:23:38 <doserj> an inch is 3 meters?
06:23:56 <drhodes> so functions that to look to the left instead of the right...
06:24:00 <z0d> 2.54 AFAIR
06:24:12 <drhodes> yep 2.52 cm in one in
06:24:16 <drhodes> 54
06:24:35 <doserj> > let {meter = id; inch = (0.0254 *) } in (123 `meter`) + (123 `inch`)
06:24:37 <lambdabot>   126.1242
06:25:37 <drhodes> (meter 3) is not so bad, they will just have to suck it up a grow a set.
06:35:49 <paolino> daf: thanks, I was reading ghc-docs which are broken on the syntax of standalone deriving
06:36:48 <paolino> now I see the wiki is different, well I made a small readP_to_S exercise in the meantime
06:38:20 <Cheshire> drhodes, you didn't understand my suggestion?
06:42:34 <Cheshire> drhodes:
06:42:35 <Cheshire> *Main> 2 Meter + 43 CM :: Integer
06:42:35 <Cheshire> 243
06:49:22 <maltem> Instance Num a => Num (SI a -> SI a) ?
06:50:57 <Cheshire> instance Num (Unit a -> a) where ...
06:51:17 <chrisdone> clever :-)
06:52:22 <drhodes> I didn't know types could be used like that. thanks Cheshire/
06:52:43 <drhodes> @karma+ Cheshire
06:52:43 <lambdabot> Cheshire's karma raised to 1.
06:52:57 <Cheshire> instance Num (Unit t -> t) where
06:52:57 <Cheshire>  fromInteger i Meter = 100 * i
06:52:57 <Cheshire>  fromInteger i CM = i
06:53:18 <Valodim> ..do I really have to convert little endian data myself when reading a file with Data.Binary? Can't find any operations for that :|
06:53:18 <gueux> hi :-)
06:53:24 <maltem> ah right, you only have length units
06:53:59 <gueux> I try to enable autoindent on vim
06:54:11 <Cheshire> maltem, you could newtype Length, Time, Weight, etc.. I suppose, and give that some treatment too
06:54:19 <gueux> so, I copied haskell.vim in /usr/share/vim/indent
06:54:28 <gueux> but it does not seem to work
06:54:49 <gueux> do somebody use haskell indent on vim?
06:54:57 <maltem> Valodim: doesn't getWord32le and friends fit you?
06:56:08 <maltem> gueux: I've once given up on installing a useful Haskell indent mode for vim...
06:57:32 <Valodim> ..dang, I really overlooked those. thanks.
06:58:44 <olsner> > (\x -> map head (groupBy (>) (0:reverse x)) [1,2,3,4]
06:58:48 <lambdabot>   <no location info>: parse error on input `;'
06:58:59 <olsner> > (\x -> map head (groupBy (>) (0:reverse x))) [1,2,3,4]
06:59:02 <lambdabot>   [0,4]
07:10:06 * EmielRegis http://i194.photobucket.com/albums/z194/texaspyro21/Picture2.jpg
07:13:09 <sereven> gueux: on my distro it just works, so don't know details about vim haskellmode, but if haven't seen it http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/ might have something helpful
07:14:57 <byorgey> @seen beelsebob
07:14:57 <lambdabot> beelsebob is in #macosxdev, #haskell-blah, #macosx and #haskell. I last heard beelsebob speak 32m 29s ago.
07:15:57 <gueux> sereven: thanks
07:16:01 * beelsebob pokes byorgey
07:16:10 <byorgey> hi beelsebob
07:16:17 <beelsebob> I had a thought which is rather unfortunate
07:16:21 <byorgey> what's that?
07:16:26 <beelsebob> with Monad, we can easily prove that all monads are applicatives
07:16:32 <byorgey> indeed
07:16:34 <beelsebob> by implementing applicative in monad opps
07:16:42 <beelsebob> we can prove all monads are branchies the same way
07:16:52 <byorgey> sure
07:16:57 <beelsebob> but proving all branchies are applicatives is an assumption
07:17:01 <beelsebob> which doesn't feel very clean at all
07:17:54 <beelsebob> I wonder if there are branchies which aren't applicatives (although this would require reformulating the laws)
07:17:56 <byorgey> well, keep in mind the only reason we can prove all monads are applicative is because there's too much in the monad type class.
07:18:03 <beelsebob> oh?
07:18:13 <beelsebob> oh, because return shouldn't be there
07:18:14 <byorgey> it ought to be something like  class Pointed m => Monad m where join :: m (m a) -> m a
07:18:17 <byorgey> right.
07:18:29 <beelsebob> hmm, true
07:18:33 <beelsebob> okay, that feels less horrible now
07:18:41 <byorgey> in fact, we just *defined* Branchies to be applicatives with this extra method
07:18:51 <beelsebob> I still wonder though if the Branchy concept applies elsewhere too
07:18:58 <beelsebob> someone pointed out that ArrowChoice is very similar
07:19:00 <byorgey> so I would be surprised if taking *only* that method would get you the entire power of applicative.
07:19:10 <beelsebob> yep
07:19:21 <beelsebob> but I'm not sure that method needs to be restricted to applicatives
07:20:11 <byorgey> I'm not sure what you mean
07:20:35 <beelsebob> well, the concept of "being able to make choices without evaluating everything" is pretty general
07:20:42 <HugoDaniel> hi
07:20:45 <beelsebob> certainly more general than only applying to applicatives
07:21:07 <byorgey> beelsebob: true, but I'm not sure how you would formulate it more generally
07:21:12 <byorgey> I don't know, perhaps you can
07:21:13 <beelsebob> yeh, ditto
07:21:16 <byorgey> hi HugoDaniel
07:21:22 <beelsebob> I hadn't got further than that thought
07:21:27 <byorgey> ok =)
07:21:42 <byorgey> it is very similar to ArrowChoice though.  I'll have to think more about the exact connection.
07:22:40 <beelsebob> I think I'll do a write up of what we discussed last night
07:22:47 <byorgey> great =)
07:22:49 <beelsebob> and see what the generalised comunity thinks
07:25:12 <beelsebob> Cale is Cale Gibbard, right?  Do you have a name you'd like to be cited by, and a link to link to?
07:26:06 <Saizan> Branchies?
07:26:22 <beelsebob> something Cale and byorgey and Peaker and I were investigating last night
07:26:42 <beelsebob> class Applicative b => Branchy b where { ifB :: b Bool -> b a -> b a -> b a }
07:26:58 <beelsebob> with the rules ifB (pure True) x y = x and ifB (pure False) x y = y
07:27:05 <beelsebob> and possibly more that we didn't get to
07:27:25 <Cheshire> beelsebob, Conor McBride uses this in the Epigram implementation
07:27:27 <beelsebob> the idea being that they're Applicatives but with the ability to make choices
07:27:30 <beelsebob> Cheshire: oh?
07:27:33 <beelsebob> got a link?
07:28:33 <byorgey> beelsebob: I'm Brent Yorgey, you can link to http://www.cis.upenn.edu/~byorgey/
07:28:42 <byorgey> beelsebob: and yes, Cale is Cale Gibbard
07:28:53 <chessguy> hmm, g2k2hs isn't on hackage?
07:29:03 <byorgey> chessguy: no, it isn't cabalized =(
07:29:10 <beelsebob> byorgey: other than you, cale and peaker, do you remember there being anyone else I should be citing?
07:29:11 <chessguy> wow
07:29:24 <Saizan> a nicer primitive is probably "f (Either a b) -> f (a -> c) -> f (b -> c) -> f c"
07:29:49 <byorgey> beelsebob: I think idnar was participating in the discussion as well, IIRC
07:30:03 <beelsebob> ah yeh, so he was
07:30:26 <beelsebob> Saizan: I'm not certain why that's nicer
07:30:35 <beelsebob> can't they both be implemented in terms of each other?
07:30:58 <byorgey> Saizan: ah, interesting.  that would make the connection with ArrowChoice much more obvious.
07:31:07 <Saizan> with mine you can implement ifB, i'm not seeing how you can do the inverse
07:31:45 <Saizan> ?src ArrowChoice
07:31:46 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:31:56 <byorgey> Sure you can, let's see here...
07:32:31 <beelsebob> eitherB x y = ifB isLeft (x . unLeft) (y . unRight)
07:32:32 <beelsebob> no?
07:32:50 <Cheshire> http://www.e-pig.org/darcs/epigram/src/Idiomatica.lhs
07:32:55 <beelsebob> cheers Cheshire
07:32:59 <byorgey> beelsebob: yeah, something like that
07:33:29 <Cheshire> chrisdone might like it too
07:33:35 <Cheshire> "I'm fed up writing"
07:35:08 <beelsebob> Cheshire: neat, he appears to see it as a Monadic op though
07:35:36 <Saizan> ?let ifB :: Applicative f => f Bool -> f a -> f a -> f a; ifB = undefined;
07:35:39 <lambdabot>  Defined.
07:35:41 <Cheshire> I thikn you cane replace Monad with Applicative and it still works
07:35:49 <beelsebob> you can't
07:36:07 <beelsebob> liftA3 if' evaluates both branches
07:36:12 <Cheshire> oh why?
07:36:29 <beelsebob> because applicatives don't let you make the choice before evaluating all the values
07:36:57 <beelsebob> you need bind to do that (or ifB)
07:38:18 <idnar> beelsebob: http://mithrandi.vox.com/ if you want a URL for me; although I think all I really contributed was tiredness-derived confusion :P
07:38:37 <beelsebob> heh, I was drunk, you can't have contributed less :P
07:38:47 <beelsebob> you got a name you'd like cited with, or just idnar?
07:39:02 <idnar> beelsebob: I'm Tristan Seligmann
07:39:06 <beelsebob> cool :)
07:39:13 <beelsebob> oh... I fail at reading
07:39:16 <Saizan> beelsebob: i'm not sure how you can have an isLeft to pass to ifB and also pass the value to the two branches without needing to perform the "f (Either a b)" twice
07:39:23 <kilp> are processor registers stacks?
07:39:41 <kilp> mov eax, 5  ; means move the value 5 into register eax right? and then it is on top of the registerstack?
07:40:21 <koala_man> no, they're just mutable variables
07:40:58 * trofi 've imagined 'mov eax, eax' meaning in stack case
07:41:27 <beelsebob> Saizan: minimal amount of caching, I'm not sure I see what you're getting at
07:42:16 <kilp> koala_man: answer to me?
07:42:29 <koala_man> kilp: yes
07:42:32 <kilp> how many values can a processor register hold?
07:42:40 <beelsebob> 1
07:42:40 <kilp> jsut one at a time?
07:42:48 <Saizan> beelsebob: i meant just in terms or the Applicative + Branchy methods.
07:42:57 <koala_man> kilp: yes, just one
07:42:58 <Saizan> not for a particular instance
07:43:26 <kilp> ah ok
07:43:27 <kilp> a light went on
07:44:25 <beelsebob> Saizan: I'm really missing something here... I don't get why you'd evaluate the Either twice
07:47:24 <Saizan> "eitherB fe fl fr = ifB (isLeft <$> fe) ((.fromLeft) <$> fl) ((.fromRight) <$> fr) $ fe" can you do something better than this?
07:47:41 <Saizan> where isLeft (Left _) = True; isLeft (Right _) = False
07:47:55 <Saizan> ops
07:48:08 <Saizan> "eitherB fe fl fr = ifB (isLeft <$> fe) ((.fromLeft) <$> fl) ((.fromRight) <$> fr) <*> fe
07:49:18 <Saizan> ?type fromLeft -- exists?
07:49:20 <lambdabot> Not in scope: `fromLeft'
07:49:36 <beelsebob> hmm
07:50:35 <Saizan> ?let fromLeft (Left x) = x; fromRight (Right x) = x
07:50:38 <lambdabot>  Defined.
07:50:57 <Saizan> ?type \fe fl fr -> ifB (isLeft <$> fe) ((.fromLeft) <$> fl) ((.fromRight) <$> fr) <*> fe
07:50:59 <lambdabot> forall t t1 (f :: * -> *) c. (Applicative f) => f (Either t t1) -> f (t -> c) -> f (t1 -> c) -> f c
07:51:19 <beelsebob> yeh, I think you're right
07:51:26 <beelsebob> I'm not certain though
07:52:28 <beelsebob> I'll add this to my writeup Saizan – got a name/url I can cite with?
07:53:31 <Saizan> Andrea Vezzosi
07:54:04 <beelsebob> cool, I'll add that in
07:54:53 <Cheshire> @src Applicative
07:54:54 <lambdabot> class Functor f => Applicative f where
07:54:54 <lambdabot>     pure  :: a -> f a
07:54:54 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
07:56:06 <edwardk> has shapr already run through here drumming up folks for his boston area haskell user group thingy?
07:59:03 <FunctorSalad> are there such things in germany as well?
07:59:51 <arjanb> see http://www.haskell.org/haskellwiki/User_groups
08:00:25 <edwardk> hah looks like he forgot to add it to that list
08:00:45 <edwardk> @tell shapr update http://www.haskell.org/haskellwiki/User_groups
08:00:45 <lambdabot> Consider it noted.
08:01:04 <edwardk> i would but i can't remember the link he has
08:02:04 <chessguy> @tell hey, out of curiousity, do you have any examples of using your astar hackage lying around?
08:02:05 <lambdabot> Consider it noted.
08:02:09 <chessguy> bah
08:02:35 <edwardk> hrmm i think that one will never get delivered ;)
08:02:50 <hey> why
08:03:06 <hey> oh
08:03:09 <edwardk> the ,
08:03:15 <chessguy> yeah
08:03:21 <chessguy> @tell Cale hey, out of curiousity, do you have any examples of using your astar hackage lying around?
08:03:22 <lambdabot> Consider it noted.
08:10:37 <tdanecker> what parser would you recommend for a haskell-like language? Parsec? Happy? something else?
08:11:03 <Cheshire> tdanecker, Parsec
08:11:09 <rovar> parsec for something that complex
08:12:30 <Cheshire> tdanecker, what are the differences from Haskell of the language?
08:13:15 <tdanecker> the most common thing is the syntax, semantic will be more lisp-like
08:13:16 <edwardk> hey does anyone have any thoughts on the idea of really lazy typechecking? i.e. only typechecking stuff transitively reachable from main?
08:13:24 <tdanecker> also, the language will be way simpler
08:13:45 <tdanecker> and is just for experimentation
08:13:54 <tdanecker> with type-systems and some other stuff
08:14:01 <Cheshire> edwardk, what is the purpose?
08:14:02 <edwardk> tdanecker: parsec is easy, happy works if you fit the straightjacket
08:14:20 <ksf> what's the most painless way to get my adt's pretty-printed?
08:14:27 <Cheshire> tdanecker, cool what sort of type stuff?
08:14:29 <rovar> tdanecker: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:14:32 <tdanecker> edwardk: k, will have a look at parsec, thx a lot
08:14:33 <rovar> live it
08:14:46 <Cheshire> ksf, I don't think there i one -- just have to write it manually with HughesPJ or whatever
08:15:11 <tdanecker> values will not really have "types" but some sort of "contracts"
08:15:26 <tdanecker> it also goes a little into dependable type systems
08:15:35 <tdanecker> but nothing concrete yet
08:15:36 <rovar> tdanecker: similar to E?
08:15:41 <edwardk> Cheshire: in my case? i've got simple haskell-like language with a module system and no typeclasses, but if i don't allow those modules to include stuff that doesn't get used then i wind up with a combinatorial explosion of names for them.
08:16:44 <tdanecker> rovar: yes, a bit like E, but I have a lot of ideas and now just want a very simple language very i can experiment with such stuff
08:16:53 <edwardk> Cheshire: i.e. i can have a parameterized List module that describes the extra functionality that List can add to a base module for manipulating a type. and if the base module is a Setoid (i.e. instance of Eq) then I want the equality for the list to be constructed accordingly, if it has an ordering then i want the lexicographical ordering for the list, etc.
08:17:31 <rovar> tdanecker: excellent.  I'm a big fan of cap systems.
08:17:32 <edwardk> if i'm not careful i wind up with a combinatorial explosion of different classes, so my current thought is to allow the definition of the other bits and pieces and they are safe as long as they aren't used in a bad way
08:17:34 <chessguy> > let (foo :: Int -> Int) = (+1); (bar :: [Int]) = [1..4] in map foo bar
08:17:36 <lambdabot>   [2,3,4,5]
08:18:57 <edwardk> Cheshire: that make sense?
08:19:09 <Cheshire> edwardk, so each time you instantiate a module, that creates new names?
08:19:43 <Cheshire> not completey
08:19:53 <edwardk> hrmm maybe should move this to #haskell-in-depth
08:19:56 <ksf> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ipprint
08:31:12 <Cale> beelsebob: One that I think might not be covered by the others is: f <*> ifB b x y = ifB b (f <*> x) (f <*> y)
08:31:12 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
08:31:43 <beelsebob> hmm
08:31:58 <Cale> chessguy: There's, if I recall correctly, a small example inside the astar code itself.
08:32:08 <beelsebob> the thing I'd wondered about was if your rule correctly enforced lazyness in all cases
08:32:15 <chessguy> Cale:  oh, hm. i looked, but didn't see one
08:32:17 <beelsebob> it deals with it in the pure case certainly
08:32:26 <beelsebob> but I'm not sure about the more complex case
08:32:27 <chessguy> let me look again
08:32:33 <Cale> chessguy: I don't recall if I left it in...
08:32:55 <beelsebob> Cale: do you have a URL to link to in citing you btw?
08:32:55 <Cale> chessguy: It wasn't exposed, you'll have to look at the source code.
08:33:05 <chessguy> Cale:  i did
08:33:40 <Cale> beelsebob: hmm... well, I have cale.yi.org -- that's only up when my computer is, but that's pretty much all the time.
08:33:58 <chessguy> Cale:  oh, the plane thing?
08:34:05 <Cale> chessguy: yeah
08:34:13 <beelsebob> Cale: which would you rather I did, not link, or link to that?
08:34:26 <chessguy> i didn't realize that was intended to be an example
08:34:57 <Cale> beelsebob: You can link to it if you want, but it's probably not terribly relevant :)
08:37:10 <beelsebob> okay, published http://noordering.wordpress.com/2009/02/14/between-applicative-and-monad/
08:37:15 <beelsebob> yell if I've missed something :)
08:37:55 <Cheshire> @src liftA3
08:37:55 <lambdabot> Source not found. There are some things that I just don't know.
08:38:05 <Cheshire> , src 'liftA3
08:38:10 <lunabot>  liftA3 :: forall f a b c d . Applicative f => (a -> b -> c -> d) ->
08:38:10 <lunabot>                                                f a -> f b -> f c -> f d
08:39:20 <xenoblitz> am reading it though I don't understand much tbh ... :) wanted to point out a little type in code-box 2 :) prue
08:39:28 <xenoblitz> oops
08:39:29 <xenoblitz> typo
08:39:30 <xenoblitz> hehe
08:39:59 <Cheshire> @src ZipList
08:39:59 <lambdabot> Source not found.
08:40:11 <Cheshire> why isn't ZipList a monad?
08:40:34 <Cheshire> newtype ZipList a = ZipList {
08:40:34 <Cheshire> getZipList :: [a]
08:40:34 <Cheshire> }
08:40:47 <beelsebob> because you don't know which elements pair up
08:40:55 * ksf thinks ipprint should be part of the standard libraries.
08:41:07 <byorgey> Cheshire: doesn't satisfy the laws.  I think the associative law in particular fails.
08:41:09 <ksf> actually, it should be the default mode for show.
08:41:28 <Cheshire> why can't yu just use the [a] instance
08:41:44 <byorgey> Cheshire: what do you mean?
08:41:47 <beelsebob> because that's not a zip list
08:41:57 <beelsebob> it does the cross product, not the zip
08:42:09 <mauke> return = repeat
08:42:12 <Cheshire> instance Applicative ZipList where
08:42:13 <Cheshire>         pure x = ZipList (repeat x)
08:42:13 <Cheshire>         ZipList fs <*> ZipList xs = ZipList (zipWith id fs xs)
08:43:42 <chessguy> i got like an hour into installing gtk2hs and then it blew up :(
08:43:49 <beelsebob> Cheshire: suppose you implement bind – which element of the zip list should the second argument combine its input with
08:44:05 <byorgey> chessguy: =(
08:44:19 <beelsebob> chessguy: :( I had that experience a few weeks ago, I got there in the end though
08:44:34 <ksf> ebml is a darn nice format. you can even interleave different doctypes element-wise without getting confused.
08:44:50 <chessguy> well, this is a new release of gtk2hs
08:46:19 <ksf> someone should do a dtd for dtd's and socket communication in the spirit of http.
08:47:48 <redditbot> Between Applicative and Monad
08:48:24 <Cheshire> so ZipList is a monad for finite lists?
08:48:28 <Cheshire> but not infinite?
08:50:48 <Cale> beelsebob: btw, your code gets cut off...
08:51:02 <beelsebob> hmm?
08:51:12 <Cale> beelsebob: in the instance of Branchy for ZipList, you'll probably want to move the = to the next line
08:51:20 <Cale> Because your blog appears to cut it off.
08:51:26 <beelsebob> oh hmm
08:51:35 <beelsebob> odd, must have different font settings or something
08:52:01 * beelsebob fixes it
08:53:19 <Cale> It may be because I have a minimum font size...
08:53:29 <tomh> anyone has read "beginning iphone development"?
08:53:45 <Cale> Er, turning that off didn't seem to help much though.
08:53:59 <beelsebob> plausable – I don't tend to see the effect of things like that – my browser scales the whole page, not just the text when I make it bigger
08:54:08 <beelsebob> but it should be fixed now
08:54:15 <chessguy> @type do { a <- return 1; b <- return 10; return $ a + b }
08:54:16 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => m a
08:55:09 <Cale> beelsebob: Well, I refreshed and the problem is still there... want me to take a screenshot?
08:55:24 <beelsebob> Cale: that'd be useful
08:56:05 <beelsebob> okay... this is wierd
08:56:20 <beelsebob> the changes just haven't taken any effect... but only when viewed in firefox
08:56:31 <Cale> http://cale.yi.org/share/Screenshot-Branchy.png
08:57:43 <beelsebob> odd, fixed now
08:57:50 <beelsebob> think I hit a wordpress bug or something
08:57:51 <rovar> beelsebob: while you're att it. terribly minor nitpick:  ifB (prue False) x y = y
08:58:10 <beelsebob> oh, damn!
08:58:13 <beelsebob> thanks
09:00:14 <rovar> can haskell be converted to C/C++ code easily?
09:00:23 <rovar> has anyone worked on this particular problem?
09:00:25 <beelsebob> define "easily"
09:00:33 <drhodes> @faq can haskell be converted to C/C++ code easily?
09:00:33 <lambdabot> The answer is: Yes! Haskell can do that.
09:00:37 <beelsebob> gcc can be made to generate really nasty C code
09:00:39 <beelsebob> ghc*
09:00:45 <beelsebob> but you'd never want to use it
09:01:01 <rovar> I am working on my 2nd iPhone app.
09:01:23 <rovar> it's a game, with some rather complex AI.  I am not looking forward to creating the rule system in obj-c.
09:01:23 <beelsebob> ah yeh, that would be problematic
09:01:48 <beelsebob> well, I know there's significant effort going into getting ghc outputting arm code
09:01:58 <mauke> @hoogle (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
09:01:59 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:01:59 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:01:59 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
09:02:03 <mauke> :-/
09:02:46 <rovar> beelsebob:  no can do.. or probably not. Two restrictions on official iPhone apps.  A. It must be compilable in XCode. B: It can't use GC. (unless it's the NS reference counting stuff)
09:03:00 <gueux> arg! the haskell indent script for vim does not take care of comments :(
09:03:15 <beelsebob> rovar: must be compilable with Xcode?  I didn't think I'd seen that restriction
09:03:24 <Twey> haskell-mode banzai!
09:03:27 <beelsebob> also, the C code that you get out of ghc will do GC too
09:03:32 <keseldude> @v hello world
09:03:32 <lambdabot> Exception: <<loop>>
09:03:35 <beelsebob> it'll just be rather explicit about how it's done
09:03:50 <beelsebob> you can't realistically have pure functional code without GC
09:03:58 <rovar> beelsebob: That might be good enough.. technically any type of memory management is GC :)
09:04:07 <beelsebob> indeed
09:04:24 <beelsebob> I'd wondered a couple of times about how far the no running arbitrary code limitation could be pushed
09:04:28 <rovar> beelsebob: yea, the restriction is that it must be built in xcode. statically linking to external libs is acceptable, as long as the linking is done by xcode
09:04:29 <beelsebob> i.e. calculators are obviously fine
09:04:37 <beelsebob> so... how about a really powerful graphing calculator
09:04:44 <beelsebob> that happens to have a decent functional language built in
09:05:21 <Twey> I suspect the boundary would be at IO
09:05:33 <beelsebob> yeh, that was my suspicion too
09:05:42 <rovar> i'm thinking: xcode uses either gcc or llvm (not sure if that includes the iphone version)  I could use that new haskel DSL for generating llvm bytecodes
09:05:45 <MyCatVerbs> gueux: verily, vim's Haskell support is not spectacular. Doesn't deal well at all with {- -}, for one thing.
09:06:00 <beelsebob> rovar: you may want to look at yhc too
09:06:08 <beelsebob> they have both a JVM and Javascript backend
09:07:13 <rovar> javascript backend? nifty.
09:07:15 <true\false> Am I right in assuming then, that partially applied functions actually return a function?
09:07:22 <beelsebob> yes true\false
09:07:30 <beelsebob> all functions in Haskell accept only 1 argument
09:07:37 <beelsebob> (some return functions)
09:07:44 * Twey nods.
09:07:58 <ulfdoz> Aber RESPEKT: Antwort per Mail innerhalb von 30min.
09:08:05 <ulfdoz> ewin, sorry.
09:08:12 <Twey> func arg1 arg2 arg3 means ((func arg1) arg2) arg3
09:08:12 <rovar> so one could theoretically create a C backend, though I would bet that both the jvm and js backend rely on native GC.
09:08:46 <beelsebob> rovar: come to think of it – yhc's default backend generates YHC bytecode
09:08:52 <pk_> hey
09:08:53 <beelsebob> which is interpretted in a C runtime
09:09:02 <beelsebob> so that may be your answer
09:09:03 <true\false> Hmm so: compare x y, will cause 'compare x' to return a function which would accept the y paramater?
09:09:10 <beelsebob> true\false: indeed
09:09:17 <pk_> Is there a monad ST tutorial ?
09:09:18 <beelsebob> and will compare things with x
09:09:23 <Twey> true\false: Semantically speaking, of course.
09:09:37 <Twey> It's probably optimised away at runtime if it's not used.
09:09:38 <true\false> Hmm, interesting..
09:09:48 <Twey> Or compile-time, maybe, for some cases?
09:09:53 <Twey> Smart people?
09:09:53 <rovar> beelsebob: can't have an interpreter of any sort.  :/  they're rather stodgy about this stuff
09:10:18 <beelsebob> rovar: so claim it's not an interpretter, it's just an AI runtime
09:10:27 <MyCatVerbs> pk_: this might help: http://www.haskell.org/haskellwiki/Monad/ST
09:10:57 <Cheshire> rovar, what??
09:11:03 <rovar> beelsebob: I don't think that's a foundation I'd want to place 6 months of work on only to have it rejected.
09:11:10 <rovar> Cheshire: what?
09:11:10 <beelsebob> rovar: fair point
09:11:12 <pk_> thx
09:11:22 <Cheshire> rovar, are the rules written down somewhere?
09:11:25 <rovar> yes
09:11:29 <Cheshire> that I can access
09:11:39 <beelsebob> Cheshire: in the agreement you sign up to when you get a dev account
09:11:45 <beelsebob> they're on connect.apple.com
09:12:28 <beelsebob> they ban interpretting code on the iPhone because it could do anything – and they're trying to make sure it's (a) not malicious (b) not breaking the other rules, like using the phone network eccessively
09:13:53 <rovar> let's see if this worked:
09:13:58 <rovar> 3.3.2
09:13:59 <rovar> An Application may not itself install or launch other executable code by any
09:14:00 <rovar> means, including without limitation through the use of a plug-in architecture, calling other
09:14:02 <rovar> frameworks, other APIs or otherwise. No interpreted code may be downloaded and used in
09:14:04 <rovar> an Application except for code that is interpreted and run by Apple's Published APIs and built-
09:14:05 <rovar> in interpreter(s).
09:14:25 <beelsebob> rovar: "downloaded and used"
09:14:26 <beelsebob> not used
09:14:28 <Cheshire> that means you can still have an interpreter
09:14:29 <MyCatVerbs> pk_: if you'll excuse the swearing at the type resolver, here's a quick example of a function that shuffles a list. http://www.cs.bris.ac.uk/home/rb6822/Shuffle.html
09:14:34 <Cheshire> internally
09:14:35 <ksf> they don't seem to like rpg's and adventures.
09:14:40 <rovar> maybe
09:14:57 <Twey> So... no Python?
09:14:59 <Cheshire> MyCatVerbs, because of the s in ST
09:15:33 <rovar> no dynamically linking, so likely no python.
09:15:50 <Twey> That's a bit... extreme
09:16:00 <MyCatVerbs> Cheshire: where the Hell were you thirteen months back when I wrote that first? ;D
09:16:15 <Twey> And they think this is more secure how, exactly?
09:16:20 <beelsebob> Twey: python is interpretted and run by apple's published apis
09:16:32 <beelsebob> Twey: it lets them check what the app does or doesn't do
09:16:47 <beelsebob> if it downloads arbitrary code, it can do anything
09:16:57 <Twey> Ah, I see
09:17:10 <Twey> What does that mean, exactly?  They have their own Python interpreter?
09:17:24 <beelsebob> well yes – the standard python interpretter
09:17:28 <beelsebob> the iPhone just runs OS X
09:17:30 <rovar> i'm sure they use the standard one.
09:17:40 <Twey> I see
09:18:14 <rovar> so If the licensce were friendly enough. I could statically link the york compiler and run haskell that way.
09:18:26 <Saizan_> MyCatVerbs: to solve the "in scope" problem you need ScopedTypeVars and use explicit forall in shuffle's signature
09:20:01 <MyCatVerbs> Saizan_: thanks. To Heck with pretending to stick within H98. ^_^
09:20:07 <Cheshire> :t runST
09:20:08 <lambdabot> forall a. (forall s. ST s a) -> a
09:20:32 <mauke> runST isn't H98 anyway
09:21:04 <Cheshire> who thought up that runST forall thing?
09:21:35 <ddarius> John Launchbury and Simon Peyton Jones presumably.
09:22:12 <Cheshire> @go Jones Lazy Functional State Threads
09:22:15 <lambdabot> http://citeseer.ist.psu.edu/launchbury94lazy.html
09:22:44 <wli> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1358#a1358 <-- eats up too much space to run on 29 here
09:22:47 <MyCatVerbs> Cheshire: eh, it's necessary, unless you *really* trust the programmer for some dumb reason. :)
09:28:32 <chessguy> > foldl f 1 [1..5]
09:28:34 <lambdabot>   Add a type signature
09:28:42 <chessguy> > foldl f 1 [1..5] :: Expr
09:28:43 <lambdabot>   f (f (f (f (f 1 1) 2) 3) 4) 5
09:28:56 <chessguy> > foldl' f 1 [1..5] :: Expr
09:28:58 <lambdabot>   f (f (f (f (f 1 1) 2) 3) 4) 5
09:29:17 <chessguy> > foldr f 1 [1..5] :: Expr
09:29:19 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 1))))
09:35:51 <roconnor> > zipWith3 if' (repeat True) (repeat ()) []
09:35:53 <lambdabot>   Not in scope: `if''
09:36:09 <roconnor> @let if' b x y = if b then x else y
09:36:12 <lambdabot>  Defined.
09:36:14 <roconnor> > zipWith3 if' (repeat True) (repeat ()) []
09:36:15 <lambdabot>   []
09:36:25 <roconnor> (repeat ())
09:36:55 <roconnor> > unZipList (pure True)
09:36:57 <lambdabot>   Not in scope: `unZipList'    Ambiguous occurrence `pure'
09:36:57 <lambdabot>      It could refe...
09:37:33 <roconnor> ifB (ZipList ps) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' ps xs ys doesn't seem like a proper branchy to me
09:37:58 <roconnor> Bas told me that Conor said that Branchy is a Monad, although I don't see how.
09:38:00 <chessguy> hm, where's twanvl's blog? i'm looking for where he describes the SimpleReflect stuff
09:38:15 <steveklabnik> hey everyone. I'm attempting to do some small file parsing, and I'm having an issue coming up with a nice way to do what I need to do, and I figured that maybe someone has done something similar before... I read a number m in, and then I need to read the next m lines. What's a good way to do this? I'm drawing a blank. Thanks in advance!
09:38:46 <twanvl> ?where SimpleReflect
09:38:47 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
09:38:53 <roconnor> @seen beelsebob
09:38:53 <lambdabot> beelsebob is in #macosxdev, #haskell-blah, #macosx and #haskell. I last heard beelsebob speak 21m 25s ago.
09:39:52 <BONUS> steveklabnik: just read the whole file, split it into lines and then take the first m lines of that
09:40:00 <BONUS> because of lazy IO, only the first m lines will actually be read
09:41:31 <steveklabnik> BONUS: okay, that sounds like a good strategy... let me toy around with that. thanks.
09:42:10 <steveklabnik> sometimes, I try to think TOO differently about a problem, and make it more complicated than it is
09:42:11 <BONUS> hehe cool
09:42:21 <BONUS> it's good to view files as streams
09:42:48 <steveklabnik> I'll keep that in mind
09:42:51 <BONUS> when you do contents <- hGetContents handle, think of contents as a stream of the contents, not the actual contents
09:42:55 <BONUS> :]
09:47:49 <redditbot> Fun with Folds - Matthew Podwysocki
09:47:49 <redditbot> The Syntactic Century: Pernicious Myth No. 1: The Container Fiction
09:47:49 <redditbot> Grapefruit: Functional Reactive Programming for GUIs on GTK
09:48:01 <Cheshire> @go The Syntactic Century: Pernicious Myth No. 1: The Container Fiction
09:48:03 <lambdabot> http://press.princeton.edu/chapters/i7897.html
09:48:03 <lambdabot> Title: Sample Chapter for Buckler, J.A.: Mapping St. Petersburg: Imperial Text and City ...
09:48:09 <Cheshire> redditbot--
09:48:17 * ksf wants a couple of Integer->Integer tries without coding a trie.
09:49:36 <mauke> if you don't care about performance, a trie is very simple
09:49:51 <pumpkin> yay tries
09:49:58 <ksf> I always care about performance.
09:50:11 <ksf> otherwise, i'd be using Data.Map.
09:50:35 <mauke> Data.Map doesn't help if your keys are generated one symbol at a time :-)
09:50:49 <MyCatVerbs> ksf: I'm *certain* there's already at least one really, really fast trie library on Hackage.
09:51:08 <ksf> I could just use Data.Trie.
09:51:09 <pumpkin> there's a bytestring trie package, but getting your integer into a bytestring is probably kinda slow
09:51:42 <pumpkin> oh no, we lost our trie
09:51:51 <ksf> ...while I currently got those integers as Integers, I've got to serialise and deserialise them anyway, so I can equally well use bytestrings.
09:52:11 <Cheshire> bleeeh
09:52:15 <Cheshire> that post was not about containers
09:53:30 <gio123> ivanm: yes it is a book, and I need lectronic djvu verssion of this book
09:53:36 <gio123> does somebody has electronic version of Garrett Birkhoff, Lattice Theory. ?
10:03:43 <idnar> @type maybe
10:03:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:04:31 <idnar> @type fromJust
10:04:33 <lambdabot> forall a. Maybe a -> a
10:04:34 <idnar> @type fromMaybe
10:04:34 <z0d> 'where' should be at the next line?
10:04:35 <lambdabot> forall a. a -> Maybe a -> a
10:04:37 <z0d> on*
10:07:08 <dridus> hey, does anyone know a way to get more informative errors out of Data.Binary than "too few bytes. Failed reading at byte position 8"? I've tried using mapException, but it seems like the error isn't generated until runGet, and then I don't know which get did the deed
10:07:41 <ksf> Debug.Trace
10:08:02 <ksf> ...for debugging, that is.
10:08:05 <z0d> lambdabot: x where x = 1
10:08:15 <z0d> > x where x = 1
10:08:17 <lambdabot>   1
10:08:25 <dridus> ugh yeah I was hoping for something more like <?> from parsec, where I could leave the code in and not have to go spelunking with debug.trace or the debugger
10:08:31 <ksf> using it (or unsafePerformIO, directly) in production code is considered evil.
10:08:49 <dridus> "it" -> "Debug.Trace"? yeah, I don't like leaving it in
10:08:53 <z0d> > [0..x] where x = 4
10:08:55 <lambdabot>   [0,1,2,3,4]
10:09:26 <ksf> parsec can be a bugger to debug, too.
10:09:37 <dridus> true enough
10:09:53 <ksf> "many applied to a parser that accepts empty input"
10:10:33 * mauke curses ReadP
10:10:41 <dridus> yeah, I'm not sure if I haven't learned the debug-fu for haskell well enough yet, or what. I really like how if it compiles it almost always works, it's just that remaining 20%
10:11:49 <dridus> well luckily all this Data.Binary code is generated by a TH splice, so I can turn on Debug.Trace when I build the splice, and then slog through the bojillion lines of output
10:12:20 <true\false> Suggested reading for after Learn you a haskell? RWH?
10:14:20 <ksf> rwh is always a good idea.
10:14:46 <chessguy> IIRC, the author of "Learn you a haskell" wrote it with the intent of leading into RWH
10:15:57 <true\false> Ah perhaps, I mean I've read some RWH up to chapter 7 or 8, but I just found parts of it a tad confusing
10:16:25 <dridus> could always ask for clarification here
10:16:35 <dridus> or on -cafe
10:17:15 <true\false> Sure, but there's a limit to how much you can ask really.. And I went from RWH to LYAH, so I'm hoping it's a little more fluent to me now.
10:18:24 <jdavis> I am trying to define some data types, and they naturally form subtypes and supertypes. However, when I define the supertype I find myself using a bunch of different names for the value constructors. For instance: "data A = A String" "data B = B Integer" "data C = A' A | B' B".
10:18:28 <ksf> haskell takes time to learn, not necessarily much effort.
10:18:38 <ksf> that is, there's a lot of stuff that has to sink in.
10:19:05 <true\false> Hmm, I think I'm noticing that
10:19:08 <jdavis> And then I have to write things like (A' (A "foo")) to get a value of type C. Are there better ways to do subtyping?
10:19:19 <ksf> data C = A String | B Integer
10:19:22 <true\false> The whole thing of indentation is racking my brains though
10:20:27 <jdavis> ksf: well, that works if it's practical to collapse all my types into one giant one, but what if A is actually a supertype of Y and Z?
10:20:35 <dridus> true\false the indentation thing is actually far simpler than it seems at first glance
10:20:55 <jdavis> ksf: and what if I want to pattern match to see if I have a type A value?
10:21:03 <true\false> I'm sure it is once you get used to it, but for now it's a bit of a nightmare :)
10:21:04 <paper_cc> true\false: it's works quite intuitively, I don't think you should worry about the actual rules
10:21:07 <dridus> true\false: it just inserts a ; between lines at the same indent level, and { for increasing indent
10:21:07 <asgaroth> true\false: from my experience you just have to indent it as you normally would anyway.
10:21:14 <gueux> is it possible to do something like a "case (compare ...) {EQ or LT -> ...; GT-> ...}"?
10:21:16 <asgaroth> except if/then/else
10:21:18 <Saizan_> dridus: -ddump-splices to see the TH-generated code
10:21:20 <gueux> +of
10:21:33 <dridus> true\false: I started out writing it with all the { } ;'s, then removed em once I got familiar
10:22:08 <ksf> designing adt's is an art I honestly never mastered.
10:22:12 <gueux> I know, I could do a "GT -> ...; _ ->..."
10:22:28 <dridus> Saizan_: yep, I use it extensively when GHC blows up with "obscure problem with code that doesn't really exist" ;-)
10:22:31 <asgaroth> Is it unrealitic to hope that the else won't have to be one level more indented than the if some day?
10:22:33 <gueux> but with more complicated types it would not work...
10:22:37 <ksf> I don't think I ever did a hierarchy that properly expressed everything.
10:22:55 <true\false> http://pastebin.com/m12bba73f As an example, what's wrong with this one? Compile time error thrown for the first |
10:23:15 <dridus> true\false: lose the = before the |
10:23:23 <true\false> Oh of course..
10:23:38 <true\false> Heh, thanks.. Silly error.
10:23:45 <jrockway> so... json is causing me some confusion; i have a json string that looks like {"foo":"bar","bar":0} and Test.JSON.String.decode won't parse that (since "bar" and 0 are different types)
10:23:49 <Saizan_> gueux: there's no such shorthand, but in some cases you could define an equivalent predicate and use a guard
10:23:56 <jrockway> am i missing some obvious way of parsing structures generically?
10:24:43 <Saizan_> ?hoogle Text.JSON.String.decode
10:24:44 <ksf> polymorphic lists are bad, mkey?
10:24:44 <lambdabot> No results found
10:24:44 <rwbarton> jrockway: you should be able to decode it with a JSValue result
10:25:07 <jrockway> ok
10:25:44 <jdavis> I guess what I'm asking is: how do I get substitutability for subtypes and supertypes?
10:26:59 <doserj> jdavis: haskell does not have subtyping
10:27:11 <jrockway> ah, i think i understand the problem, my call to fromJSObject was forcing things to be strings
10:27:20 <jrockway> it all makes sense now :)
10:27:53 <jdavis> doserj: Oh, I see. Is there some substitute that I'm missing? What I'm trying to do is a little awkward without it.
10:28:08 <pejo> doserj, his question is "Here's an obvious solution for my problem in a language with subtyping: .. How do I go from there to a solution in Haskell?".
10:28:22 <dridus> jdavis: describe what you're trying to do in more detail?
10:29:28 <doserj> pejo: yep. unfortunatley that is not easy to answer :)
10:29:41 <jdavis> dridus: I am trying to describe an expression, and I'd like to specially treat certain types of expressions. So, a big expression might have within it a relational expression, etc.
10:30:25 <Gracenotes> pattern matching?
10:31:18 <jdavis> Gracenotes: how do I represent a hierarchy of different special cases of expressions using pattern matching?
10:31:24 <dridus> jdvais: so like data Expr = StringLit String | IntLit Int | App Symbol Expr Expr | SubExpr Expr ?
10:31:28 <dridus> also, jdavis
10:32:06 <Gracenotes> oh, you're talking about function output, not input. Never mind :) Either way, having multiple constructors for one datatype allows you to a great amount of flexibility
10:32:14 <Gracenotes> -to
10:33:37 <jdavis> dridus: the problem I'm having is kind of an explosion of value constructor names. Maybe there are 20 types of literals, and I want to represent those as the literal type, and then I always have to do "Literal (StringLiteral (UnicodeStringLiteral "abc")))" or something (for example).
10:33:52 <doserj> jdavis: one way to simulate subtyping is using a type class Expression, and make RelationalExp, etc instances of this class
10:34:16 <jdavis> doserj: Ok, I'll look into that.
10:35:06 <rwbarton> write unicodeStringLiteral = Literal . StringLiteral . UnicodeStringLiteral ?
10:35:18 <dridus> jdavis: Template haskell does something a bit like this... data Lit = CharL Char | StringL String ..., then a typeclass Lift t with function lift x :: t -> Lit
10:35:18 <rwbarton> Chances are you want all those constructors there for pattern matching
10:35:31 <dridus> jdavis: not precisely what you're looking for, but makes wrapping them up a bit more brief
10:35:54 <dridus> jdavis: on the other end you can use view functions, and make that even more pleasant to use with view guards
10:36:03 <Gracenotes> jdavis: in JSON, though, there are only a few types of literals
10:36:23 <jdavis> dridus: I haven't used a view function before. I'll look into it.
10:36:26 <Gracenotes> if that's what you're parsing
10:36:53 <jdavis> Gracenotes: I'm not really writing a parser. I haven't decided what I'm writing, but a parser isn't it ;)
10:37:41 <doserj> jdavis: I would not necessarily suggest type classes, though. you can get a very long way with just using smart constructors and destructors.
10:38:00 <jdavis> doserj: can you elaborate?
10:38:03 <Gracenotes> okay. Well, instead of having Literal, StringLiteral, etc., try simplifying things by regrouping them into multiple constructors
10:38:15 <Gracenotes> e.g., make StringLiteral a constructor for type Literal
10:38:15 <dridus> doserj: but type classes have "class" in the name. makes us recovering OO-types feel at home ;-)
10:38:50 * maltem just came back and wonders what the discussion is about
10:39:01 <pejo> dridius, I think subtyping has its place, it's just that Haskell doesn't allow us to use it.
10:39:08 <Gracenotes> data Literal = ... | StringLiteral StringLiteralType | ...
10:39:44 <doserj> jdavis: smart constructors are what rwbarton suggested.
10:39:46 <rovar> what would be the appropriate use of Data.Map? I have a network application that is constantly receiving updates, and some of these updates might effect the local state.
10:39:51 <jdavis> Gracenotes: I'm not quite following. If you do that wouldn't it be back to the problem of "Expr (Literal (StringLiteral "foo"))"
10:39:51 <dridus> pejo: yeah I miss it sometimes, but usually find a pleasant enough way around it... if GHC wasn't such a huge gorilla, I would consider playing around with some of the alternates that have similar things (o'haskell?)
10:40:19 <rwbarton> jdavis: also I don't know (and I guess you don't either) what you are trying to write but do you really need to have an Expr AST that remembers whether the literal was given as a unicode literal or something else?
10:40:20 <dridus> jdavis: stringLitExp = Expr . Literal . StringLiteral ?
10:40:23 <rovar> i suppose I could simply update the Map and then pass it to the function as it recurses, but this seems like a job for a Monad. only I can't figure out how to apply it in this case
10:40:25 <doserj> jdavis: for pattern matching, you can use helper functions like "isUnicodeStringLiteral", and "getUnicodeStringLiteral".
10:40:33 <pejo> dridus, O'Haskell was a separate interpreter built on Hugs.
10:40:39 <rwbarton> jdavis: maybe you just want data Expr = ... | Literal Value | ...
10:41:22 <dridus> pejo: yeah I haven't looked into it in any detail. for me, GHC is just too awesome and well supported by libraries to consider trying other compilers
10:41:48 <mauke> we have OO in a library
10:41:55 <dridus> pejo: unless you're saying there's a desugarer that outputs standard haskell?
10:42:13 <rwbarton> rovar: sounds like you want a State s monad, or StateT s IO
10:42:16 <Gracenotes> jdavis: not really. Suppose you have, say, data LiteralInfo = ... | StringLiteral Bool [Char] | ..., and data Expr = ... | Literal LiteralInfo | ..., then you can do Literal (StringLiteral True "abc"), which would be of type Expr
10:42:35 <rovar> rwbarton, given that I'm in an io monad, I'm guessing StateT s IO
10:42:38 <rovar> --> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1359#a1359
10:42:50 <Gracenotes> where the Bool represents whether it's Unicode or not. (Could be generalized to another ADT)
10:43:09 <jdavis> rwbarton: ultimately what I'm looking to do is get a haskell expression to evaluate to an Expression type rather than a value. I'd like to basically evaluate a haskell expression my own way, if that makes any sense.
10:43:30 <rovar> rather a Net monad,
10:43:33 <pejo> dridus, not that I'm aware of, O'haskell is unsupported/abandoned as well.
10:44:13 <rwbarton> jdavis: ... oh.  Well, have you looked at Template Haskell?  You might find its ADT useful :)
10:44:29 <jdavis> rwbarton: I haven't yet, but I soon will.
10:44:40 <dridus> pejo: nod. I wish it were the future, where I understood the type system in haskell well enough to play with adding extensions ;-)
10:44:43 <jdavis> rwbarton: is that a library or a different implementation?
10:44:44 <rwbarton> , src ''Lit
10:45:02 <lunabot>  data Lit = CharL Char
10:45:02 <lunabot>           | StringL String
10:45:02 <lunabot>           | IntegerL Integer
10:45:30 <rwbarton> jdavis: it's a feature of GHC that lets you build up haskell expressions at compile time and splice them into your program
10:45:35 <rwbarton> , [| 2 + 2 |]
10:45:37 <lunabot>  InfixE (Just (LitE (IntegerL 2))) (VarE +) (Just (LitE (IntegerL 2)))
10:45:58 <mauke> (VarE +)? I think not
10:46:10 <dridus> mauke: why not?
10:46:11 <rwbarton> mauke: show fail
10:46:13 <jdavis> rwbarton: interesting.
10:46:29 <dridus> mauke: oh, without quotes, right. *slap self*
10:46:33 <jdavis> well, thanks very much, everyone. I have some research and experimentation to do.
10:46:36 <rwbarton> jdavis: It doesn't do any evaluation though, so you're on your own there :)
10:46:57 <rwbarton> jdavis: but it'll give you an ADT and a parser
10:47:13 <Gracenotes> Haskell interface to this, anyone? http://entertainment.slashdot.org/article.pl?sid=09/02/14/1514210
10:47:18 <jdavis> rwbarton: that's pretty much what I want, I think.
10:47:45 <rwbarton> jdavis: there's also another ADT and parser in the haskell-src-exts package which might be better since it's a haskell library and not part of the compiler
10:47:49 <redditbot> The Syntactic Century: Fixing Haskell IO
10:48:33 <jdavis> rwbarton: cool, I will look at that, too.
10:50:02 <narasim_7> Hello. I am learning gtk2hs (with glade). Can anyone let me know how to set up menu item handlers? I saw some tutorials and one of them talks about actions.
10:50:15 <rwbarton> rovar: I'm guessing Net = ReaderT r IO
10:55:02 <gwern> bah! be c,h,o stukk diwb/.'
10:55:10 <gwern> hm. that did not come out right
10:55:18 <Baughn> Note to self: strace -p `pidof X` is a very bad idea in an xterm
10:55:19 <gwern> *bah! be c.h.o still down?
10:55:44 <rwbarton> rovar: so you can add a StateT s layer, either in the definition of Net (and then you'll have to add a runStateT with the initial state where the runReaderT is), or right here, adding a runStateT before forever
10:57:21 <rovar> I'm experimenting with such things as we speak.
10:57:48 <rovar> so what's better idiomatically? put the two transformers together?
10:59:45 <rwbarton> yeah, usually, if you had a larger program and you wanted a single state to be passed between different top-level functions
11:00:44 <rwbarton> if the state was somehow specific to listen and no other function could possibly care about it, you'd just use a runStateT locally
11:04:53 <rovar> rwbarton: okay, so I am including data.map:
11:05:18 <rovar> import qualified Data.Map as Map
11:05:36 <rovar> so Net should now look like:
11:05:38 <rovar> type Net = ReaderT Bot (StateT Map.Map IO)
11:06:14 <rovar> where Bot is just a type that stores the socket
11:06:21 <rwbarton> It needs to be ... (StateT (Map.Map k v) IO) for some key and value types k and v
11:07:04 <mauke> .oO( kindly fix your types )
11:07:08 <rovar> righto, qualified type :)
11:07:40 <sjanssen> code.haskell.org is down?
11:07:42 <rovar> type Net = ReaderT Bot (StateT (Map.Map String PC) IO)
11:07:55 <Feuerbach> where can I read a complete set and semantics of Distribution.Simple commands (configure, build, install etc)?
11:08:16 <mauke> @unmtl ReaderT Bot (StateT (Map.Map String PC) IO)
11:08:16 <lambdabot> err: `ReaderT Bot (StateT (Map.Map String PC) IO)' is not applied to enough arguments, giving `/\A. Bot -> Map.Map String PC -> IO (A, Map.Map String PC)'
11:08:24 <mjrosenb> how can i add type constraints to a single argument to a function?
11:08:27 <dridus> rovar: shouldn't that be type Net a = ReaderT Bot (StateT (Map.Map String PC) IO) a?
11:08:43 <mjrosenb> or to a variable bound in a do block?
11:08:45 <mauke> dridus: same thing (well, almost)
11:09:06 <mathijs> Has anyone tried kdevelop for coding haskell?
11:09:16 <mauke> @unmtl ReaderT Bot (StateT (Map.Map String PC) IO) a
11:09:16 <lambdabot> Bot -> Map.Map String PC -> IO (a, Map.Map String PC)
11:09:54 <dridus> mjrosenb: ScopedTypeVariables?
11:10:08 <mauke> more like pattern signatures
11:10:10 <dridus> mauke: same thing as in what I said had the same problem?
11:10:34 <mjrosenb> wait... this feature doesn't exist in haskell98?
11:10:44 <rwbarton> dridus: both your definition and rovar's are valid
11:11:05 <rovar> all of the functions are typed as:  foo :: String -> Net ()
11:11:07 <dridus> rwbarton: oh, if you say type Net = ..., it'll result in * -> *?
11:11:13 <rwbarton> dridus: yes
11:11:33 <dridus> rwbarton: neat... I thought I had tried that previously and it didn't work out, but that's probably my own idiocy.
11:12:06 <rovar> and I just don't know what I'm doing :)
11:12:11 <rwbarton> dridus: moreover in Haskell 98 you can use Net as an argument to another type constructor only with the type Net = ... definition
11:12:39 <MyCatVerbs> Hah! I knew I'd end up hanging if I abused knot-tying for long enough. :)
11:13:06 <dridus> rwbarton: e.g. another tycon that expects a * -> * rather than *?
11:13:18 <rwbarton> dridus: right
11:15:42 <dridus> rwbarton: thanks. I'm glad I asked, even though it wasn't my question and my suggestion was wrong heheh
11:16:30 <t101> I was just wondering, what's the difference between let and where? (isn't one a substitute of the other?)
11:16:42 <sjanssen> rwbarton: are you that's Haskell '98?
11:16:52 <Twey> t101: where is available in guards
11:17:10 <rwbarton> sjanssen: not entirely
11:17:35 <Twey> 'I just accidentally a whole Haskell standard!'
11:17:45 <sjanssen> rwbarton: actually, you're right
11:17:47 <sjanssen> interesting
11:17:49 <rwbarton> sjanssen: what do you mean exactly?  the fact that I can write WriterT w Net with the non-expanded version, or the fact that I can't write it with the expanded version?
11:18:11 <t101> Twey, thanks for the quick answer
11:18:21 <sjanssen> rwbarton: type List = [] -- for example
11:19:43 <t101> Twey, ah got a good example here http://learnyouahaskell.com/syntax-in-functions#where
11:20:08 <Twey> t101: *nods*
11:20:56 <Twey> where is like a big let that scopes to the whole function definition (including all guards, which isn't possible with let) and has access to the parameters
11:21:50 <Twey> Er
11:22:01 <Twey> Yeah.  That's right.
11:22:04 <ksf> why isn't Put a Monoid?
11:22:43 <sjanssen> ksf: Put from Binary?
11:22:49 <ksf> yeah
11:22:52 <sjanssen> I suppose because Builder is the Monoid
11:23:03 <Twey> I was about to say that you could do the same thing without parameter access with a let enclosing the function, but of course function definitions must be top-level
11:23:07 <sjanssen> also, type Put = PutM ()
11:23:18 <chessguy> so what class of functions has a fixpoint?
11:23:27 <sjanssen> ksf: hard to say whether the instance should just be for PutM () or something more general
11:23:44 <chessguy> i.e., is there anything we can say "if a function ... then it has a fixpoint"
11:24:03 <rovar> rwbarton:      loop st    = catchIO (runStateT (runReaderT run st) (Map.fromList [])) (const $ return ())
11:24:26 <MyCatVerbs> chessguy: you mean as in Data.Function.fix? The class of functions that do not ever examine their first argument are included.
11:24:51 <monochrom> if X is a CPO, f:X->X has a fixpoint. there is also a requirement of "f monotonic", but in programming you get it for free.
11:25:05 <chessguy> what's a CPO?
11:25:12 <Feuerbach> chessguy: I think every function has, if you count _|_
11:25:16 <mauke> f x = \y -> [x, ()]
11:25:23 <Feuerbach> complete partial order
11:25:29 <chessguy> oh
11:25:43 <rovar> it seems that it thinks that I'm trying to define an IO that returns ( (), Map.Map String PC)
11:26:00 <rwbarton> rovar: oh yeah.
11:26:00 <rovar> i don't see how it's interpreting that
11:26:03 <rwbarton> @type runStateT
11:26:05 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
11:26:09 <rwbarton> @type execStateT
11:26:10 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
11:26:13 <rovar> oh yea
11:26:51 <monochrom> Perhaps you also get "X is a CPO" for free.
11:28:10 <rovar> oh wait.. i just want to return the (), not the state, to catchIO. How do I ditch it?
11:28:22 * rovar tries something silly
11:28:35 <rwbarton> @type evalStateT
11:28:36 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
11:28:41 <rwbarton> sorry, I meant that one! :)
11:29:29 <ksf> > let f n = (n - 1) in f 1
11:29:31 <lambdabot>   0
11:29:33 <ksf> bugger.
11:30:03 <rovar> rwbarton: cool.. so assuming I wanted to manually hack it out. I'd have to liftM fst, correct?
11:30:05 <ksf> ah, precedence, again.
11:30:11 <rovar> would that work?
11:30:32 <rwbarton> rovar: yeah... or just >> return ()
11:31:04 <rovar> i'm starting to get the hang of this :) but damn is there a lot to know
11:31:16 <wli> That's programming.
11:31:37 <kerlo> > 3;
11:31:39 <lambdabot>   3
11:31:44 <rovar> been coding C++ and other imperative languages for 10 years
11:31:54 <kerlo> So, data Wrap a = Wrap (Wrap a -> a). Is it useful?
11:32:14 <rovar> i don't recall having this much hassle, but I think my progress was much more gradual. Whereas now I expect myself to be an expert instantly.
11:32:31 <Cheshire> kerlo, why?
11:32:58 <mauke> reminds me of loeb
11:33:00 <kerlo> Cheshire: are you asking why I'm wondering whether it's useful?
11:33:02 <monochrom> If you were younger, you would learn faster with less hassle.
11:33:10 <Cheshire> kerlo, why is it useful
11:33:26 <chessguy> @pl \k -> k x
11:33:26 <lambdabot> ($ x)
11:33:30 <mauke> Cheshire: so it is useful?
11:33:38 <kerlo> I didn't say it was useful; I asked whether it was useful.
11:33:49 <Saizan__> kerlo: you can define the Y combinator with it, not sure if that counts :)
11:33:53 <chessguy> @pl \n -> c $ \k -> k (n ^ 2)
11:33:53 <lambdabot> c . flip id . (^ 2)
11:33:59 <kerlo> Indeed.
11:34:19 <monochrom> I started a virtual machine in my brain to learn haskell, and it was much easier.
11:34:57 <rovar> monochrom: I don't have the resources for that, so I've got to settle for an FSM.
11:35:10 <dridus> monochrom, rovar: I won't settle for anything less than full unification
11:35:36 <ksf> er... how do I get a strict bytestring if i have a lazy one?
11:35:50 <mauke> concat the chunks
11:35:52 <dridus> ksf ByteString.concat . LazyByteString.toChunks is what I've been using
11:35:56 <kerlo> If a = Void, then Wrap a = Not (Wrap a), effectively.
11:36:48 <thaldyron> does anyone know a library function in Cabal to retrieve the list of installed packages from the user package-DB?
11:38:54 <mjrosenb> right, so no haskell98 way of specifying the types of a variable that is bound as an argument, or in a do block?
11:39:20 <monochrom> right.
11:39:29 <Saizan> thaldyron: Distribution.Simple.Configure.getInstalledPackages
11:40:01 <rwbarton> > let f a = show a where b = a `asTypeOf` (undefined :: Double) in f 0
11:40:03 <lambdabot>   "0.0"
11:40:29 <mauke> > let f a = show (a :: Double) in f 0
11:40:31 <lambdabot>   "0.0"
11:40:40 <kerlo> > let fancy (x :: Double) = x in fancy 3
11:40:42 <Cheshire> > show (0 :: Double)
11:40:42 <lambdabot>   3.0
11:40:44 <lambdabot>   "0.0"
11:40:59 <mjrosenb> kerlo: that's not haskell98
11:41:04 * kerlo nods
11:41:20 <Cheshire> nobody uses haskell 98 :p
11:41:26 * mjrosenb does not know about the rest
11:41:36 <rwbarton> I think Oleg has a style using guards that puts the type signature closer to the function pattern
11:41:39 <chessguy> anybody have any suggested reading for when continuations are useful?
11:41:51 <chessguy> i've seen a number of trivial examples
11:42:40 <thaldyron> Saizan: Mhm that seems to return the packages of a supplied DB *plus* the ones in the GlobalDB
11:42:41 <mauke> > let f a | False = undefined (a :: Double); f a = show a in f 0
11:42:43 <lambdabot>   "0.0"
11:43:01 <rwbarton> right
11:43:47 <MyCatVerbs> chessguy: there's a website-makin' framework for Smalltalk called SeaSide that used to make pretty good use of full continuations. They've switched to partial continuations for performance reasons, since.
11:43:56 <thaldyron> Saizan: But I could call it twice I suppose - once with GlobalDB and once with UserDB and then take the difference
11:44:04 <MyCatVerbs> chessguy: ("partial continuations" being their name for what Oleg calls "delimited continuations")
11:45:40 <michaelcdever> silly question, but if i have a type say, box { height, width } how do i get the individual parts out of it again?
11:45:57 <mauke> with height and width
11:46:16 <paper_cc> michaelcdever: if you define it like Box { height :: Int, width :: Int }, then height and width are functions
11:46:37 <paper_cc> if you define it as Box Int Int, then you have to write your own accessors
11:46:46 <paper_cc> like width (Box w _) = w
11:46:50 <Saizan> thaldyron: yeah, but i think you'd get some problems with shadowing, if the same version of the same package is installed in both dbs
11:48:18 <mauke> data Result s a = Failure !(Set String) s | Success ([(a, s)] -> [(a, s)])
11:48:24 * mauke cries
11:48:41 <michaelcdever> ah ok, thanks
11:49:51 <ksf> chessguy, there's some fun stuff in advanced programming language design.
11:50:17 <chessguy> ksf:  i'm looking for something between trivial and advanced
11:51:00 <gueux> is it possible to specify a dependance for a type (for ex.: type Pair a b = (a,b) with a belongs to Eq)?
11:51:14 <ksf> ftp://ftp.aw.com/cseng/authors/finkel/apld/
11:51:24 <ksf> dunno what chapter, though.
11:51:28 <Cheshire> gueux just let it be inferred
11:51:29 <chessguy> ksf:  thanks
11:51:31 <ksf> the language is called "IO"
11:52:11 <thaldyron> Saizan: (globalPkgs ++ userPkgs) \\ globalPkgs shouldn't be a problem, even if there are multiples in the first list, right?
11:52:51 <gueux> Cheshire: I know that haskell can infer that without problem, but I was wondering if it was possible
11:53:19 <ksf> chapter 2, section 3.
11:53:35 <paper_cc> mauke: i'd say it's ErrorT (Set String) StateT [a] if not for the 's' in the Failure constructor. what can this mean?
11:53:46 * paper_cc is just curious how real-life Haskell is done
11:53:52 <Saizan> thaldyron: i don't think you'll get multiples, that's the problem, but i've never used that function directly so i can't be sure
11:54:02 <mauke> it's not a StateT
11:54:28 <mauke> paper_cc: I'm trying to write a parser
11:54:46 <paper_cc> err, ok... ErrorT (Set String) ReaderT a StateT [a]
11:54:59 <Cheshire> mauke using ReadP?
11:55:08 <paper_cc> or rather StateT [] a
11:55:28 <mauke> Cheshire: well, using the paper ReadP was based on
11:55:38 <mauke> Cheshire: now I'm trying to add error messages
11:55:46 <Cheshire> oo good luck
11:55:50 <jrockway> so is there a way to convert an Integer to an Int (truncating if necessary)?  JSON can only give me numbers as Rationals (Integer/Integer), but I need to use the value as a process exit code (which only accepts Int)
11:55:59 <mauke> fromIntegral
11:56:03 <Cheshire> mauke if you find a half decent way that would be really cool
11:56:19 <thaldyron> Saizan: Ah right, the GHC implementation calls getInstalledPackages' which is non-cumulative
11:56:34 <mauke> > fromIntegral 99999999999999999999999999999999 :: Int
11:56:36 <lambdabot>   -8814407033341083649
11:56:42 <mauke> :-|
11:57:25 <rwbarton> I doubt -8814407033341083649 is a valid exit code on your OS
11:57:39 <jrockway> mauke: thanks
11:57:41 <mauke> :t round
11:57:43 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:58:05 <mauke> > truncate (5/3 :: Rational) :: Int
11:58:06 <lambdabot>   1
11:58:07 <jrockway> for some reason, i thought that was only for converting from int types to floating point types... but i am wrong :)
11:58:16 <mauke> can't you just use truncate?
11:58:24 <rwbarton> > truncate (99999999999999999999999999999999 :: Rational) :: Int
11:58:26 <lambdabot>   -8814407033341083649
11:58:41 <jrockway> yeah
11:59:05 <monochrom> I misled you by emphasizing the floating point application.
11:59:29 <jrockway> truncate is the right approach
11:59:45 <kerlo> > fromInteger 9999999999999999999999999999999 :: Int
11:59:46 <jrockway> (better than assuming the denominator is always 1)
11:59:47 <lambdabot>   -4570789518076018689
11:59:56 <mauke> > let [lo, hi] = map fromIntegral [minBound :: Int, maxBound] in fromIntegral . max lo . min hi $ (99999999999999999999999999999999 :: Integer) :: Int
11:59:58 <lambdabot>   9223372036854775807
12:02:30 <chessguy>  ksf: are the continuations discussed in that PDF the same as continautions represented by Cont?
12:03:01 <ksf> I'd say so, but I'm not the one you should ask if you want a formal proof.
12:04:02 <ksf> somehow, bit arithmetic is more fun in c than in haskell.
12:10:10 <mauke> $#@$% SymbolBind
12:10:11 <lunabot>  luna: Not in scope: `#@$%'
12:10:27 <mmorrow> mauke: ooh nice, good luck on the error msg adding
12:10:46 <mmorrow> lunabot needs to drop the '$'
12:10:57 <paper_cc> is there a ListT anywhere?
12:11:06 <mmorrow> yes
12:11:19 <mmorrow> on the haskell wiki there're a few
12:11:40 <Cale> paper_cc: There's a broken one in the libraries that come with GHC.
12:12:00 <paper_cc> Cale: how is it broken?
12:12:04 <Cheshire> paper_cc, LogicT
12:12:24 <mmorrow> , foldr interleave [] (repeat [0..])
12:12:25 <lunabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16...
12:12:31 <Cale> paper_cc: It's not a proper monad transformer because the things it produces (usually) don't satisfy the monad laws.
12:12:33 * wli still hasn't figured out how to do the arbitrary precision arithmetic.
12:12:54 <Cale> paper_cc: If you want a proper nondeterminism monad transformer, look at LogicT, which is available on Hackage.
12:13:02 <Cale> (as Cheshire recommended :)
12:13:16 <mmorrow> yeah, i should have suggested LogicT
12:13:40 * mmorrow didn't make the connection
12:14:16 * paper_cc goes to understand the difference between LogicT and some imaginary ListT
12:15:04 <Saizan> ?google haskell ListT done right
12:15:06 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
12:15:06 <lambdabot> Title: ListT done right - HaskellWiki
12:24:44 * SamB wonders what's new in 0.46+2+b2 versus 0.46+2
12:24:52 <SamB> er.
12:24:59 <MyCatVerbs> SamB: of what...?
12:25:01 * SamB wonders what's new in *pandoc* 0.46+2+b2 versus 0.46+2
12:26:18 <mmorrow> mauke: here's my current personal "\"production\"" version of ReadP fwiw: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1248
12:26:53 <mmorrow> elimination of everything ReadS FTW!
12:27:16 <mauke> isn't the Functor instance unnecessarily complicated?
12:27:27 * mmorrow looks
12:27:53 <mmorrow> for P or ReadP ?
12:27:59 <mauke> both
12:28:13 <mmorrow> hmm, i'm not sure. how could it be simpler?
12:28:20 <mauke> instance Functor where fmap = liftM
12:28:56 <mmorrow> oh, heh, i suppose.
12:29:00 <mmorrow> :)
12:29:18 <mmorrow> i always write my Functor instances before the Monad instances
12:29:53 <mauke> between a z x = a *> x <* z
12:30:06 <monochrom> eww
12:30:12 <SamB> which is eww ?
12:30:32 <SamB> anyway, the *> <* version doesn't curry well
12:30:43 <monochrom> a *> x <* z is hard to implement
12:30:52 <mmorrow> what are (*>) and (<*) ??
12:30:57 <SamB> @hoogle (*>)
12:30:58 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
12:30:58 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:30:58 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:30:59 <mmorrow> @hoogle (<*)
12:31:00 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
12:31:00 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:31:00 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:31:02 <mauke> monochrom: ?
12:31:05 <mmorrow> innnnteresting
12:31:27 * SamB could tell they must be Applicative just from the look
12:31:36 <mmorrow> yeah, i figured as much
12:31:55 <SamB> and really they're basically what I'd have expected
12:32:18 * mmorrow hates the look of infix ops between '<' and '>'
12:32:36 <mmorrow> which is why i can't stand to use <$> and <*>
12:32:37 <SamB> I think I've seen "<<" used for a monadic version of <* before
12:32:51 <SamB> and which bothered me
12:32:55 <mauke> yeah, I used to define << before I learned about <*
12:33:05 <SamB> since I thought it should just be flip (>>)
12:33:46 <paper_cc> Oh mai. do these MonadIO, MonadCont, ... actually form a cyclic dependency between monadic transformers? :(
12:34:29 <SamB> paper_cc: what ?
12:34:30 <monochrom> Not that I heard of.
12:35:52 <paper_cc> "http://www.haskell.org/haskellwiki/ListT_done_right_alternative" contains things like instance (MonadIO m) => Monad IO (ListT m) which is apparently a cyclic dependency. that looks strange to me
12:36:19 <mauke> how is that cyclic?
12:37:04 <monochrom> show a cyclic dependency path. don't make mistakes.
12:37:06 <SamB> paper_cc: where'd that space between Monad and IO come from ?
12:37:26 <Saizan> it's recursive, not cyclic, the "size" of the type decreases
12:37:49 <paper_cc> SamB: yes, thanks. it should be MonadIO (ListT m)
12:38:48 <mauke> I think the basic parser operations I want are 'tag :: e -> Parser e s a -> Parser e s a' and 'try :: Parser e s a -> Parser e s a'
12:39:17 <paper_cc> Saizan: I say "cyclic" meaning that if I write my own monad X and a typeclass MonadX for operations on it, it'd have to implement, say, MonadX (ListT m) based on the internal details of the ListT implementation
12:39:50 <mmorrow> mauke: what are the semantics of `try' ?
12:40:02 <SamB> paper_cc: not really the internal details
12:40:03 <mauke> char c = tag (show c) . try $ symbol >>= \x -> when (x /= c) fail >> return x
12:40:15 <SamB> depends on what MonadX's methods are, though, I guess ...
12:40:21 <ddarius> SamB: Likely, you would.
12:40:29 <SamB> ddarius: well, okay, likely
12:40:38 <ddarius> But that's just the nature of the beast.  More likely, ListT wouldn't even be an instance.
12:40:38 <SamB> MonadIO is a bad example though
12:40:49 <mauke> mmorrow: reset error position for errors raised by the wrapped parser
12:40:50 <Saizan> paper_cc: it's known that the autolifting instances approach doesn't scale
12:40:52 <monochrom> MonadFix needs different implementations for different instances.
12:40:55 <SamB> because it's implemented as "lift" in all cases but one
12:40:55 <ddarius> MonadIO is not the same as the MonadState/MonadCont/etc. classes.
12:41:14 <mauke> mmorrow: so it looks like it didn't consume any input in case of failure
12:41:17 <SamB> monochrom: that's not a transformer-related class
12:41:21 <ddarius> A "real" MonadIO class would have things like putChar in it.
12:41:31 <SamB> there is no FixT
12:41:38 <mmorrow> mauke: (<++) ?
12:42:03 <SamB> there is, of course, also the O(n^2) number of instances mtl needs
12:42:22 <paper_cc> which apparently doesn't scale well
12:42:42 <paper_cc> (taking user-defined monads and monad transformers into account)
12:42:48 <SamB> especially since it's tricky to figure out what package to stuff a lot of them into!
12:43:06 <Saizan> mmtl might be the way to go
12:43:11 <paper_cc> SamB: that's what I meant by "cyclic dependency"
12:43:24 <SamB> it'd require, like, O(m^2) packages
12:43:50 <SamB> where m is the number of packages defining MonadFoo/Foo/FooT
12:44:35 <paper_cc> ... instance (MonadTrans t, MonadX m) => MonadX t m isn't implementable in general?
12:44:45 <paper_cc> s/MonadX t m/MonadX (t m)/
12:44:50 <Saizan> no
12:44:59 <mmorrow> mauke: yeah, this is the hard part about error messages and breadth-first search. in (a +++ b), a or b could fail and you still have a successful parse.... but say you have (a +++ (choice [b,c,d, (choice [d, e , f]))) and everything fails. the last parse you try is (d of e of f), but how do you deal with the error messages *if `a' is the error message that "matters"*?
12:45:08 <SamB> paper_cc: well, usually there's a few cases you DON'T want to use that on
12:45:11 <SamB> that it would match
12:45:22 <SamB> leading to extremely incoherent instances
12:45:28 <ddarius> s/DON'T/can't/
12:46:04 <mmorrow> mauke: i'm thinking maybe error msgs could be tagged with some sort of priority, and all errors are kept in a PQ or something.
12:46:18 <mmorrow> s/priority/severity/ or something
12:46:34 <mauke> blargh, now it's broken
12:46:50 <paper_cc> SamB: then the whole thing is still necessarily O(m^2) =(
12:46:53 <mmorrow> *but*, this might not capture what one wants still, because error severity could *depend* on the existence of other errors
12:47:01 <mauke> mmorrow: no, you keep a set of errors associated with each position in the input, and you only return the rightmost errors
12:47:19 <mmorrow> ah, that could work too
12:47:24 <Saizan> paper_cc: this tries to solve that problem: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=111
12:47:32 <mmorrow> mauke: hmm
12:48:05 <mauke> mmorrow: my current problem is that 'satisfy' has the wrong error position
12:48:08 <mmorrow> mauke: ohhhh, ok. so your `try' only operates on position-as-seen-by-error-messages
12:48:19 <mmorrow> mauke: hmm
12:49:46 <mauke> satisfy t p = tag t . try $ do c <- get; if p c then return c else pfail
12:50:16 <mauke> 'try' would make it look like the pfail occurred before the get, and 'tag' would replace the error of the inner parser
12:51:25 <mmorrow> interesting
12:53:37 <mmorrow> i've always looked at this from the pov of having `Fail' be `Fail [Errors] [Expected]` (or whatever) and trying the shoehorn error reporting into the existing ReadP monad (which is hard/impossible i've strted to believe, given its search strategy)
12:53:47 <RayNbow> http://www.reddit.com/r/programming/comments/7xe5p/give_it_up_reddit_python_c_print_njoin_joinn_for/c07o431 <-- can this small Haskell program be transformed into a (reasonably readable) one liner?
12:54:00 <mmorrow> wrapping in another monad like you're doing makes it much more do-able
12:54:12 <mauke> [Expected] is useless
12:54:18 <mmorrow> heh, totally
12:54:27 <Plouj> dang, the text transposing exercise in chapter 4 or RWH is hard...
12:55:50 <mauke> yay. I have an ugly implementation of try
12:56:31 <mauke> *> parse (char 'a' <|> fail "foo" <|> char 'b') "xyz"
12:56:31 <mauke> Failure (fromList ["foo","not 'a'","not 'b'"]) "xyz"
12:57:41 <michaelcdever> hey, can anyone take a look at this and tell me if theres a better way of doing it? i feel like it can be made better but cant see how http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1397
12:59:09 <mauke> == [] better written as null
12:59:30 <alatter> michaelcdever: that almost looks like a fold ...
12:59:41 <rovar> how would I use case to assign a value to a variable in the middle of a do block?
12:59:43 <mauke> do x <- foo; return x better written as foo
13:00:12 <paper_cc> @ty init
13:00:13 <lambdabot> forall a. [a] -> [a]
13:01:14 <paper_cc> @ty foldM
13:01:16 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:01:34 <alatter> michaelcdever: the entire top branch is just "TS.treeStoreGetValue store path" - no need for the 'do', the 'return' or the intermediate 'this'
13:01:48 <pumpkin> :t const
13:01:50 <lambdabot> forall a b. a -> b -> a
13:02:15 <rovar> nm
13:02:24 <RayNbow> I'm too afraid to feed this to lambdabot (7 lines of spam): say . tail $ let (*) = flip replicate; center w s = let mid = length s; left = (w - mid) `div` 2; right = w - mid - left; in replicate left ' ' ++ s ++ replicate right ' '; in id $ intercalate "\n" [(center 9.intercalate " ") ['*'*n | n <- t] | t <- [3,3]:[9]:map (:[]) [9,7..1]]
13:03:22 <Gracenotes> lambdabot tends to spam more in PM
13:03:22 <paper_cc> > inits [1..5]
13:03:23 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
13:03:44 <the_unmaker> lisp seems to have a less character happy way of writing lists
13:03:53 <the_unmaker> does it become a drag to type haskell lists like that
13:03:55 <the_unmaker> ?
13:04:00 <Cheshire> no
13:04:18 <Gracenotes> RayNbow: surely there are more concise ways to do that, though :D
13:04:26 <Gracenotes> very cute though. /me likes it
13:04:30 <the_unmaker> how is the feel of doing a haskell program differ from something like bash
13:04:40 <RayNbow> Gracenotes: I was inspired by the Python one liner posted on reddit
13:04:42 <the_unmaker> I only have done bash and I imagine procedural perl is same
13:04:43 <mauke> oh hai
13:04:54 --- mode: ChanServ set +o mauke
13:05:14 --- mode: mauke set +b *!n=g@*
13:05:23 <Gracenotes> RayNbow: yeah, but try it more tersely :D
13:05:24 <Cale> the_unmaker: Actually, bash pipelines are a lot like lazy functional programming, though, in Haskell, you have more types than just streams of characters.
13:05:34 <Cale> er...
13:05:36 <Gracenotes> even better, make a function that produces a heart of an arbitrary height
13:06:10 <Gracenotes> anyway, who am I to be nit-picking a heart on St. Valentine's day >_>
13:06:39 <SamB> mauke: how could you tell?
13:06:52 <sbahra> Cale, !
13:07:01 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html  shell pipelines
13:07:02 <Cale> sbahra: hello
13:07:02 <mauke> SamB: inane questions, n=g
13:07:07 <sbahra> Cale, hi
13:07:12 <michaelcdever> thanks!
13:07:15 --- mode: mauke set -o mauke
13:07:22 <sbahra> Cale, I'm trying to find a good first order translation of (f ∘ g).
13:07:28 <SamB> mauke: ah. n=g
13:07:37 <sbahra> Cale, failing miserably, all forms I come up require identity to prove things about associativity.
13:07:37 <RayNbow> Gracenotes: more terseness and variable height is left as an exercise for the reader ;) :p
13:07:38 <SamB> sbahra: heh
13:07:43 <Cale> sbahra: With what axioms?
13:07:45 <mauke> he's also used that exact hostmask before
13:07:47 <sbahra> Cale, oh, where "∘" is defined in ZFC.
13:07:51 <sbahra> Cale, ZFC axioms.
13:08:28 <sbahra> I have something in the form of \forall{x}\forall{z}\exists{y}[Gxy /\ Fyz], but this gets really icky once I start dealing with things like t ∘ (f ∘ g).
13:08:40 <monochrom> What do you require in a "first order translation"? For example what is the first order translation of f alone?
13:08:40 * SamB finds that funny because ∘ is higher-order
13:08:46 <Cale> Well, if A and B are sets then a function f: A -> B is a triple (A,B,G) with G a subset of AxB such that for each a in A, there is exactly one b in B such that (a,b) is in G.
13:08:52 <paper_cc> michaelcdever: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1397#a1398 should do the same
13:08:57 <sbahra> monochrom, any binary relation in ZFC.
13:09:13 <sbahra> monochrom, I see what you mean though.
13:09:23 <sbahra> :)
13:09:27 <paper_cc> michaelcdever: oops, i'm not quite right
13:09:37 <monochrom> I need to know what kind of formulas you're going after.
13:09:53 <monochrom> "first order translation" says little IMO.
13:10:09 <sbahra> monochrom, classic first order logic, is what I mean.
13:10:20 * sbahra is trying to keep all his proofs in FoL
13:10:27 <paper_cc> michaelcdever: now it should be OK
13:10:29 <sbahra> The problem is, this book uses natural language to define some things.
13:10:33 <monochrom> I need concrete examples, not philosophical essays.
13:11:15 <sbahra> monochrom, f is simply a binary relation. In ZFC, this is a set {(x, y) | R(x, y)}
13:11:25 <Cale> sbahra: So for each triple of sets (A,B,C), you're going to have a composition functions
13:11:28 <Cale> function*
13:11:51 <sbahra> monochrom, where they're all ordered.
13:12:00 <sbahra> Cale, sorry, let me carefully read what you wrote.
13:12:32 <monochrom> f ∘ g becomes { (x,y) | ∃z. R(x,z) ∧ S(z,y) }.  R corresponds to f, S corresponds to g.
13:13:01 <sbahra> dohhhhhh, yes, yes.
13:13:01 <monochrom> Perhaps I have the order reversed.
13:13:05 <sbahra> Yes, whatever. :)
13:13:31 <monochrom> f ∘ g becomes { (x,y) | ∃z. S(x,z) ∧ R(z,y) }.  R corresponds to f, S corresponds to g.
13:13:34 <sbahra> I wasn't treating sets properly in this case. It was clear in the definition in fact.
13:13:37 <sbahra> Thanks.
13:14:37 <monochrom> See, if you show me examples, I know how to build on them. Clear questions should never be asked in natural languages. :)
13:14:50 <Cale> If f = (A,B,G), g = (B,C,G'), then g.f = (A,C,{(x,z) : exists y in B such that (x,y) is in G, and (y,z) is in G'})
13:15:17 <mmorrow> mauke: let me know if/when you put up some code for this somewhere. i'm very interested.
13:15:50 <Cale> But of course, if you want to think of composition as a *function*, then it's really a whole bunch of related functions.
13:16:24 <pumpkin> whee, my arm disassembler is coming along
13:16:32 <mmorrow> pumpkin: nice
13:16:46 <pumpkin> I cover all the basic instructions, none of the coprocessor ones or thumb ones
13:17:47 <mmorrow> pumpkin: i've looked through binutils at different points and it seems to me that one could parse the .h files of opcode info and auto-generate something-or-other for haskell
13:18:08 <pumpkin> yeah, I've basically translated those big tables into a nicer format for haskell
13:18:15 <pumpkin> it could be done easily automatically
13:18:25 <mmorrow> yeah, that would be sweetness
13:18:32 <pumpkin> I'll eventually make a tool to convert their format to mine (they're pretty isomorphic)
13:18:34 <sbahra> Cale, makes sense.
13:21:00 <sbahra> Thanks Cale, monochrom.
13:23:21 <Gracenotes> Results 1 - 10 of about 508 for all_about_monads. (0.35 seconds)
13:23:23 <Gracenotes> Did you mean: all_about_me ads
13:23:28 <Gracenotes> :/
13:24:10 <mmorrow> pumpkin: also, a must-do for harpy useability is to hack your local copy to use the derived Show instance for Instruction rather than (extremely annoyingly) using showIntel for show. also, i added derived Show+Read+Ord+Eq to everything datatype i could
13:25:03 <lhoerste1> is Monad a classtype?
13:25:06 <lhoerste1> typeclass*
13:25:16 <Cheshire> yes
13:25:26 <lhoerste1> Cheshire: can I see where it's defined somehwere?
13:25:34 <SamB> @where report
13:25:34 <lambdabot> http://www.haskell.org/onlinereport/
13:25:50 <lhoerste1> Cheshire: is there something similar to :type on the interpreter to inspect typeclasses like Monad?
13:25:58 <SamB> :i Monad
13:26:02 <lhoerste1> thanks
13:26:30 <lhoerste1> awesome
13:26:48 <mmorrow> pumpkin: i think i've pasted this before too, but for quick reference here's code to write mach code into a buffer and call into it (using only Foreign)  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1360#a1360
13:27:06 <lhoerste1> so haskell reall just has types, typeclasses, and functions for organizing code?
13:27:21 <paczesiowa> lhoerste1: also modules
13:27:27 <lhoerste1> oh yeah
13:27:31 <lhoerste1> dude this language is amazing
13:27:33 <rwbarton> and, you know, values :)
13:27:37 <lhoerste1> of course =)
13:27:44 <rwbarton> (of which functions are a special case)
13:28:08 <paczesiowa> can I use tab-completion in ghci in Inf-Haskell buffer in emacs?
13:28:17 <lhoerste1> when I first tried learning it last year I totally could not wrap my head around Monads. But learning types, then type classes, then monads made it super easy
13:30:06 <Twey> lhoerste1: (stands for ':info')
13:30:22 <lhoerste1> Twey: yeah I was searching for it in :? thanks =)
13:31:02 <Twey> Personally I prefer to think of values as a special case of functions
13:31:07 <Twey> But whatever floats your boat :-P
13:31:25 <michaelcdever> does anyone know if its possible to create a context menu (right click menu) using gtk2hs?
13:31:26 <lhoerste1> an instance is an implementation of a typeclass?
13:31:38 <Twey> lhoerste1: For a particular type, aye
13:31:50 <lhoerste1> Twey: what do you mean?
13:32:43 --- mode: ChanServ set +o mauke
13:32:44 --- mode: mauke set -b *!n=g@*
13:32:45 <lhoerste1> so IO is an instance of Monad and Functor?
13:33:07 <Twey> IO has a Functor instance?
13:33:12 <Twey> But yes
13:33:15 <Twey> Right idea
13:33:23 <paczesiowa> isn't every monad a functor?
13:33:31 <lhoerste1> i'm still confused =) I'm just reading these out of :info Monad
13:33:46 <lhoerste1> and :info functor
13:33:46 <alatter> paczesiowa: morally, yes.  it isn't required, though.
13:33:54 <Twey> paczesiowa: Every monad is a functor, but not every Monad is a Functor.
13:34:03 <michaelcdever> ???
13:34:17 <lhoerste1> haha i'm lost
13:34:32 <Twey> lhoerste1: Don't worry about the ones you don't understand :)
13:34:44 --- mode: mauke set -o mauke
13:34:49 <Twey> You had it right.  IO is an instance of Monad.
13:34:49 <lhoerste1> RWH will eventually explain this I guess =)
13:35:06 <Twey> That is to say, (>>=) and return are defined on IO
13:35:14 <lhoerste1> gotcha
13:35:19 <Twey> (that being the minimum requirement for a Monad)
13:35:28 <lhoerste1> and fail it seems?
13:35:30 <lhoerste1> also >>
13:35:37 <Twey> I think fail has a default value
13:35:40 <Twey> So does >>
13:35:44 <lhoerste1> ah nifty
13:37:38 <wli> newtype NEL t = NEL (t, [t]) ; instance Functor NEL where NEL (x, xs) = NEL (f x, fmap f xs) ; instance Monad NEL where { return x = NEL (x, []) ; x >>= f = NEL (y, ys) where ~(y : ys) = concatMap f $ x : xs }
13:38:11 <pumpkin> mmorrow: yes, I already did that for harpy, but got annoyed with its representation of things so I moved to making my own ARM disassembler because I know ARM better :P
13:38:23 <lhoerste1> how does an instance of a type in haskell differ from an object of a class in OOP?
13:38:41 <pumpkin> mmorrow: that paste is cool :) I'd expect it to need mprotect though? I guess the heap is executable?
13:38:59 <mauke> lhoerste1: objects are values and runtime
13:39:08 <Cale> lhoerste1: What do you mean by 'instance' there?
13:39:32 <Cale> lhoerste1: Types are instances of typeclasses in Haskell... values are members of types.
13:39:35 <lhoerste1> Cale: i'm unsure. that's what the question is intended to help me figure out =)
13:39:58 <Cale> Okay...
13:40:01 <lhoerste1> values are members of types?
13:40:04 <Cheshire> data List1 a = Nil a | Cons a (List1 a)
13:40:10 <Cale> yes, like 5 is a member of the type Integer
13:40:18 <lhoerste1> ah
13:40:23 <mmorrow> pumpkin: it is, but i also have some ffi import code for mmap, munmap, and mprotect :):)
13:40:30 <pumpkin> ah cool
13:40:34 <mmorrow> i'll paste, but give me a sec to clean it up
13:40:43 <lhoerste1> Cale: could you say 5 is an instance of the type Integer?
13:40:54 <byorgey> lhoerste1: just like in, say, Java, new Integer(3) is an "instance of the class" (i.e. member of the type) Integer
13:41:12 <Cale> lhoerste1: I would normally stay away from the word 'instance' because it means something else.
13:41:12 <byorgey> lhoerste1: but in Java there are lots of other things that get lumped in with it too
13:41:29 <pumpkin> mmorrow: my main interest is disassembling stuff, although code ges is helpful (although not very useful until we get ghc running on ARM, for my module :P)
13:41:45 <Cale> lhoerste1: But other than that, I suppose it's okay.
13:41:48 <jeltsch> Hello.
13:41:59 <jeltsch> I did a cabal update && cabal upgrade today.
13:42:15 <jeltsch> This installed process-1.0.1.1 (with --user).
13:42:41 <jeltsch> The package ghc-6.10.1 was built against process-1.0.1.0.
13:42:43 <Cale> jeltsch: It's safer just to upgrade the packages you're interested in.
13:42:49 <lhoerste1> thanks guys
13:43:06 <jeltsch> When I now want to use cabal install, I get the following (strange) error message:
13:43:23 <jeltsch> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
13:43:37 <Cale> lhoerste1: In Haskell, typeclasses (or just 'classes') are predicates on types, which when they are true, provide some interface of functionality involving that type.
13:43:39 <jeltsch> How is this problem best fixed?
13:43:54 <Cale> lhoerste1: For example, there is a typeclass Eq for types which support (==)
13:44:04 <Cale> class Eq a where (==) :: a -> a -> Bool
13:44:18 <Saizan_> jeltsch: can you paste the output of "ghc-pkg list" somewhere?
13:44:18 <Cale> and then instances of this class say what it does for each type a.
13:44:46 * maltem wonders if I should put some constraints into .cabal/config so that I won't accidentally upgrade certain packages
13:45:10 <lhoerste1> Cale: so the "instance" is the implementation of the typeclass?
13:45:17 <Cale> lhoerste1: yeah
13:45:29 <mmorrow> pumpkin: hmm, actually a paste wouldn't be ideal for this. i've been meaning to stick this code in a repo anyways, i'm gonna do that now and i'll let you know. (it has read, write, send, recv, malloc, free, memset, memcpy, memmove, mmap, munmap, mprotect, fcntl, select, ...)
13:45:38 <rwbarton> lhoerste1: It's the implementation of the instance of the typeclass for a particular type.
13:45:44 <lhoerste1> whereas in OOP, instance is the class filled out with values as well as interface implementations right?
13:45:50 <pumpkin> mmorrow: those will be handy in general, thanks
13:45:54 <pumpkin> mmorrow: cabal it! :D
13:45:58 <mmorrow> super handy!
13:45:59 <pumpkin> or rather, hackage :P
13:46:04 <mmorrow> cabal for sure
13:46:04 <Cale> lhoerste1: Haskell typeclasses are closest to Java's 'interfaces'
13:46:07 <mmorrow> yeah that too
13:46:11 <mreh> can you still steal books of mirc these days?
13:46:27 <lhoerste1> Cale: awesome. so instance in java means something different than haskell right?
13:46:30 <mauke> I don't think there are books about mirc
13:46:34 <mreh> so many things newbish about what i just typed
13:46:35 <Cale> yes
13:46:40 <Cale> as does class
13:46:40 <lhoerste1> thanks thanks guys
13:46:49 <lhoerste1> right
13:47:00 <lhoerste1> awesome. this helps a lot hearing how these words are used
13:47:00 <mreh> can i still find and steal books from IRC these days
13:47:13 <Cheshire> mreh, seems irrelevant to haskell
13:47:14 <jeltsch> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1401
13:47:15 <mauke> no, you can't transmit books over IRC
13:47:22 <Ralith> yes you can
13:47:22 <mauke> IRC is a digital thing
13:47:23 <Ralith> DCC :>
13:47:30 <mreh> DCC yur :P
13:47:34 <mauke> Ralith: no
13:47:57 <mreh> are you being pedantic?
13:48:07 <mreh> XDCC was huge before napster
13:48:10 <Cheshire> mreh -- can we talk about something interesting?
13:48:15 <Cheshire> mreh -- bookwarez is boring
13:48:19 <mauke> ok, stop this, it's totally off topic
13:48:27 <mreh> i needz a book though
13:49:21 <mmorrow> mreh: hold up your local library?
13:49:38 <mmorrow> or get a library card..
13:49:39 <nikanj> haskell books at a local library?
13:49:46 <mreh> has anyone managed to write a concise solution to the kosh snowflake he propses in HSOE?
13:49:56 <mmorrow> nikanj: heh, doubtful
13:50:07 <Saizan_> jeltsch: you've haskell98-1.0.1.0 both in the global and in the user db and this confuses both cabal and ghc, the latter is compiled against process-1.0.1.1 i guess
13:50:34 <Saizan_> the haskell98-1.0.1.0 in the user db i mean
13:50:52 <Saizan_> jeltsch: so you should ghc-pkg --user unregister haskell98
13:52:15 <jeltsch> Saizan_: Why unregister haskell98?
13:52:37 <jeltsch> Saizan_: Oh sorry, I missed your second-last comment.
13:53:13 <Saizan_> jeltsch: haskell98 matters here because ghc depends on it
13:53:49 <jeltsch> Saizan_: Do you know why haskell98 was installed by cabal upgrade? I thought that cabal upgrade only installs stuff not already installed in this version. So this seems like a cabal-install bug to me.
13:55:03 <Saizan_> jeltsch: because "cabal upgrade" upgraded process and so built a new haskell98 against it, so that you could use it together with the new process
13:55:18 <Saizan_> jeltsch: but ghc can't be upgraded or rebuilt
13:56:16 <jeltsch> Saizan_: So not only new versions of packages are installed but packages that depend on them are rebuilt against the new version?
13:56:33 <Saizan_> jeltsch: maybe upgrade should add ad-hoc checks for cases like this..
13:57:17 <sjanssen> @pl p x y = any (`inRange` y) (rs !! x)
13:57:17 <lambdabot> p = flip (any . flip inRange) . (rs !!)
13:57:18 <Saizan_> jeltsch: yes, because the dependecy solver wants to find a consistent set of packages
13:59:57 <jeltsch> Saizan_: “Consistent” in the sense that only one version of each package is used by all other packages?
14:00:32 <Saizan_> jeltsch: yes
14:01:21 <lhoerste1> im out. thanks for all your help guys.
14:01:44 <jeltsch> Saizan_: So older versions of packages could always safely be removed (except when ghc-6.10.1 depends on them ;-) )?
14:02:32 <Saizan_> jeltsch: because of the pessimistic assumption that using two versions of the same package in a build will cause type errors
14:03:32 <Saizan_> jeltsch: uhm, i'm not sure about that
14:04:20 <mmorrow> we need SML-like modules/sigs + a crypto hash of the interface of a module. then such a pessimistic view wouldn't have to be taken.
14:04:52 <wli> mmorrow: Amen.
14:04:57 <mmorrow> (the hash would capture the structure of each type down to the constituent prims it's made of)
14:05:08 <mmorrow> wli: totally.
14:05:20 <wli> Preach it, my brother!
14:05:26 <mmorrow> :)
14:05:33 <Saizan_> mmorrow: what if the package has some constants that change between versions?
14:05:58 <monochrom> Haha Java had the same problem :)
14:06:38 <mmorrow> Saizan_: constants would need to be included in the sig (i'm thinking of the modified SML module system from this reference augustss gave me which merges signatures and structures)
14:06:49 <Saizan_> however yes, there's some ideas about having tools to check interfaces so you can tell if dependencies are "private" or "public"
14:06:52 * wli doesn't know if he'd play hashing games, but anyway.
14:07:13 <jeltsch> Saizan_: I’m just deinstalling process-1.0.1.1 as well as haskell98 from my --user package installations. I did ghc-pkg unregister --user and now I’m deleting package related files from ~/.cabal. Do I also have to delete stuff in ~/.cabal/packages/hackage.haskell.org or is this just a download cache?
14:07:18 <Saizan_> thus deciding more accurately if a type error is probable
14:07:25 <mmorrow> wli: yeah, me neither. i wonder if it would be necessary?
14:07:41 <wli> NFI.
14:07:45 <Saizan_> jeltsch: just a download cache
14:08:00 <mmorrow> Saizan_: we shouldn't stop there. we should be able to tell 100% for sure yes or no.
14:08:09 <wli> mmorrow: Something like .hi files should already be enough.
14:08:12 <jeltsch> Saizan_: Okay, thanks.
14:08:17 * monochrom trolls. The hash should be the hash of the concatenation of: the interface, the version, the license, the author's GPG key, ...
14:08:19 <mmorrow> wli: ooh, yeah true. hmm.
14:08:26 <jeltsch> Saizan_: There should really be a cabal uninstall.
14:09:11 <Saizan_> jeltsch: yup, there's a ticket about it, do you want to contribute? :)
14:09:42 <jeltsch> Saizan_: Contribute code? Now, I’m sorry. :-(  Too many other things I want to do.
14:10:02 <wli> mmorrow: AIUI the trickiness comes about from some sort of interaction of module-level namespace control and typeclasses' "open world" assumptions or otherwise somehow circumventing namespace control.
14:10:50 <mmorrow> wli: ah, yeah. typeclasses always seem to provide the catch with stuff like this.
14:10:51 <Saizan_> jeltsch: heh
14:11:13 <wli> mmorrow: But I'm not anyone who knows anything about this. I'm only repeating what I remember of what I heard long ago.
14:12:24 <chessguy_> so continuations allow you to basically "escape" from the current computation (by replacing the rest of it) or otherwise manipulate it. but there's only so much manipulation you can do with a function, right? i mean, you can't really see what it's doing
14:13:47 * kerlo renames sievePrimes and sieve to fakeFakeSievePrimes and fakeFakeSieve, respectively
14:14:11 <Saizan_> right, you can do things like calling it multiple times or storing it away, or avoid calling it and return a result of your own instead..
14:14:37 <geezusfreeek> callCC allows you to pass "what the program would have otherwise done had you not used callCC" as a function to another function
14:15:17 <chessguy_> so what i've been playing with is trying to add an aditional type to continuations
14:15:43 <chessguy_> so that you can put an ADT in there and take a look at what you're doing
14:16:17 <kerlo> It's not even a fake Sieve of Eratosthenes; it's trial divison.
14:16:19 <chessguy_> not working very well yet though
14:18:54 <chessguy_> i'm thinking the type would have to be a member of a class like class S s where eval :: s a -> (a -> a)
14:21:50 <Adamant> Real Sieve and Fake Sieve
14:22:28 <wli> Mostly you need a good priority queue.
14:27:01 <monochrom> chessguy_: If you have mutable variables and the continuation reads them, you can set different values and run the continuation, that is some kind of control (designed into it by the author).
14:27:26 <chessguy_> monochrom, hmm
14:27:42 <chessguy_> monochrom, a bit, but not much
14:29:51 <jeltsch> Hello, has anyone built successfully Leksah recently?
14:31:07 <jeltsch> I get a strange error during building Leksah, having to do with combo boxes.
14:34:38 <_dolio> geezusfreeek: Technically, with callCC, the part that gets passed always happens anyway. It just lets you escape to that part early from within the body of the function it gets passed to.
14:36:27 <dolio> (Although if you can get the continuation out, you can do fancier stuff with it.)
14:38:49 <Cale> It would be nice to see a fast implementation of finding just the nth prime in Haskell. Mathematica can find the billionth prime in a negligible amount of time, and the 10 billionth in about 2 and a half seconds.
14:39:41 <Heffalump> how?
14:39:52 <Heffalump> don't you have to enumerate them to do that/
14:39:59 <Cale> Apparently not.
14:40:30 <geezusfreeek> dolio, well, that is the case if the function you call into terminates
14:40:36 <Ralith> couldn't you just write a func to check if a number is prime
14:41:07 <Ralith> then use primeN x = (map yourfunc [1..]) !! x
14:41:10 <Cale> Ralith: Using such a function will require you to enumerate all the primes if you want to find the nth one.
14:41:15 <Olathe> I think they used the PrimePi formula to get it.
14:41:35 <Cale> Yeah, I think they're inverting some fast algorithm for finding pi(x) somehow.
14:41:46 <Cale> "Prime and PrimePi use sparse caching and sieving. For large n, the Lagarias-Miller-Odlyzko algorithm for PrimePi is used, based on asymptotic estimates of the density of primes, and is inverted to give Prime."
14:42:03 <Cale> That's all the documentation says.
14:42:09 <Cale> (about the implementation)
14:42:56 <chessguy> @type callCC
14:42:58 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:44:33 <dolio> geezusfreeek: True. I was thinking more of operators where 'control (\_ -> m) >>= f = m' whereas 'callCC (\_ -> m) >>= f = m >>= f'.
14:50:40 <monochrom> "sparse caching" means the algorithm knows (hardcoding or otherwise) such as "the 10000th prime is blah, the 20000th prime is blah", and so when you ask for the 14389th prime it knows which interval to sieve.
14:51:35 <Axman6> beelsebob: i see you wrote an applicative/monad port, good work :)
14:53:31 <ksf> someone please write a web browser that doesn't suck.
14:53:41 <Axman6> which OS?
14:53:49 <monochrom> Firefox doesn't suck. Safari doesn't suck. I like both and use both.
14:54:04 <mauke> firefox sucks. all other browsers are unusable.
14:54:08 <ksf> linux, but i don't mind if it works on other platforms, too.
14:54:14 <Axman6> firefox sucks on OS X, and only doesn't suck on other OS's because there's nothing better
14:54:20 <Axman6> </rant>
14:54:30 <ksf> both firefox and konqueror suck, for different reasons.
14:55:14 <kryptiskt> Opera sucks in unique and interesting ways.
14:55:31 <Axman6> heh, agreed
14:55:54 <mauke> <script type="text/javascript">while (true) alert("yes");</script>
14:55:54 <ksf> tbh, most gui programs suck.
14:56:10 <Axman6> i don't know why, but i can get over the fact that tabs are above the address bar on chrome, but not on opera
14:56:46 <monochrom> From my experience, when people say "____ sucks" and I actually press them to tell what's wrong, it comes down to something like "it doesn't let me customize the colour of the close-window button".
14:56:51 <ksf> i've got tabs above the adress bar, too.
14:56:54 <Cheshire> lol
14:56:57 <ksf> ...xmonad paints them.
14:57:39 <ksf> it comes down to rendering performance, memory leakage and plugin bugginess.
14:58:20 <dridus> my personal favorite firefox experience was when I had to nuke my profile and all the plugins because after a couple days of having it open it refused to load images and stylesheets
14:58:23 <dridus> until it got restarted
14:58:40 <ksf> a year ago or so, pages always scrolled smoothly.
14:59:09 <Axman6> beelsebob: i know you go on about it a lot, but i was wondering if you could wrute a blog post about using applicative instead of monad and such. something that highlights why it's nicer and more general or whatever
14:59:12 <ksf> i don't have that problem, it crashes reliably at least once per day.
14:59:40 <dridus> ksf: at least it's consistent? ;-)
15:00:46 <Nafai> Most of my firefox crashiness seems to be related to flash or java
15:01:07 <dridus> Nafai: flashblock ftw
15:01:12 * Axman6 manages to run Safari for weeks on end, with 45+ tabs constantly without problems (other than slow memory increase over a few days)
15:01:13 <monochrom> I know that some pages scroll too slowly. I look at the source of those pages, and it is their fault of using excessively too many style tags. Like specifying "choose the sans font" every ten words.
15:01:18 <ksf> I suspect my uptime to cause it.
15:01:54 <ksf> other people might just not notice bugs in their apps, because their os crashes beforehand.
15:02:37 <dridus> Axman6: I would use safari except it doesn't have flashblock, gestures, or tabmix plus (or workalikes) that I know of
15:02:49 <ksf> any sane rendering engine shouldn't bother about superfluous style specs.
15:03:17 <dridus> ksf: people write sane software? who? where? can I have it?
15:03:35 <ksf> ...anyway, the most problematic thing is position:fixed.
15:03:48 <monochrom> How does any computer program know what is superfluous and what is not?
15:04:12 <Axman6> dridus: things like saft can at least block flash (i use youtube too often to want to). what's tabmix plus do?
15:04:15 <monochrom> Any sane human wouldn't require it. Even insane humans like Godel wouldn't.
15:04:17 <ksf> because it knows it can ignore "write that word in black" if it paints all words black?
15:04:52 <Gracenotes> @hoogle String -> String
15:04:52 <lambdabot> Distribution.Simple.Utils dotToSep :: String -> String
15:04:52 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
15:04:52 <lambdabot> Distribution.Simple.Utils lowercase :: String -> String
15:04:57 <Gracenotes> leik wha
15:05:46 <gwern> most useful string utilities are generalized to [a]
15:06:00 <Gracenotes> yeah, I justed ended up doing reverse
15:06:01 <Gracenotes> -ed
15:06:04 <gwern> (fromUtf8 does confuse me a little tho)
15:06:17 <ksf> we need to have 3-ROT13 in the standard lib.
15:06:36 <Gracenotes> rot13 . rot13 . rot13
15:07:54 <gwern> then we can use a RULE to simplify it to rot13!
15:08:21 <Gracenotes> rot13 . rot13 . reverse . rot13 . reverse . rot13 . reverse . reverse . rot13
15:08:32 <Gracenotes> RULES to the rescue (????)
15:08:57 <Gracenotes> hm.. reversing the arguments in mappend for a Writer would probably break the monad rules for non-communative monoids :x
15:09:30 <Gracenotes> dontcha think? -.-
15:09:45 <gwern> well, let's see, you could simplify away reverse . reverse to reverse, if you don't mind strictness changes,
15:10:01 <gwern> hm, perhaps a rot13 . rot13 = id rule would be better
15:10:04 <mauke> or reversed strings everywhere
15:10:29 <Gracenotes> rot13 is on a character-by-character basis, so reversing the string then doing rot13 then reversing the string == rot13
15:10:30 <monochrom> ksf: I think it is more complicated than that. There are requirements about corresponding display and DOM, javascript requirements, and tradeoff between "pre-compute everything and store but use lots of memory" vs "use less memory but re-compute things" that makes sures that for all rendering approaches there exist killer pagers.
15:10:44 <gwern> 'rot13 . rot13 . reverse . rot13 . reverse . rot13 . reverse . reverse . rot13' becomes 'reverse . rot13 . reverse . rot13 . reverse . reverse . rot13'
15:10:45 <monochrom> s/pagers/pages/
15:10:59 <ksf> if I look at memory usage, they bleeding precalculate everything.
15:11:04 <gwern> then we undo 2 reverses to get 'reverse . rot13 . reverse . rot13 . rot13'
15:11:17 <gwern> which simplifys to 'reverse . rot13 . reverse'
15:11:34 <Gracenotes> unfortunately I don't think GHC can't optimize interleaved reverses
15:11:42 <gwern> hm. and I don't think we can use RULES to turn that into a single rot13
15:12:03 <mauke> reverse . rot13 ==> rot13 . reverse
15:12:05 <gwern> but it's been a while since I read the paper and I forget the rules about variables
15:12:05 <sjanssen> reverse . reverse doesn't equal id anyway
15:12:18 <ksf> try stuff like rot13 . reverse . rot13 = reverse
15:12:19 <Gracenotes> unless we have a rule for reverse . map f . reverse -> map f, and rot13 is defined in terms of map.. maybe? :/
15:12:39 <sjanssen> rot13 = map charRot13 -- this makes rules easier
15:12:54 <sjanssen> reverse . map f = map f . reverse
15:13:02 <Gracenotes> yes :)
15:13:44 <Toxaris> can reverse be dealt with in array fusion?
15:14:09 <Toxaris> e.g. (reverse . mapForward f . reverse) = mapBackward f
15:14:13 <Gracenotes> sjanssen: under which circumstances?
15:14:15 <Toxaris> but mapForward = mapBackward anyway
15:14:49 <sjanssen> Toxaris: I think array fusion can remove reverses, since arrays are supposed to be finite
15:15:12 <sjanssen> Gracenotes: repeat ()
15:15:15 <Gracenotes> oh, infinite lists
15:15:47 <sjanssen> or lists where the second argument to (:) is _|_
15:16:25 <Gracenotes> > reverse . reverse $ [1..]
15:16:46 <lambdabot>   thread killed
15:16:53 <sjanssen> > reverse . reverse $ 1 : undefined
15:17:06 <sjanssen> lambdabot: @botsnack
15:17:06 <lambdabot> :)
15:17:08 <lambdabot>   * Exception: Prelude.undefined
15:17:14 <sjanssen> > 1 : undefined
15:17:15 <lambdabot>   [1* Exception: Prelude.undefined
15:17:49 <Toxaris> sjanssen: I see.
15:20:27 <augustss_> total functional programming. that's all I have to say
15:20:55 <Cheshire> totally awesome
15:21:19 <augustss_> totally man
15:24:05 <monochrom> total proof of program correctness
15:24:52 <gwern> > (13 * 60) + 30
15:24:54 <lambdabot>   810
15:24:57 <gwern> > ((13 * 60) + 30)/2.5
15:24:59 <lambdabot>   324.0
15:25:45 <gwern> > 324 / 60
15:25:47 <lambdabot>   5.4
15:26:13 <Gracenotes> Enterprise Statistics(TM)
15:26:40 <drguildo> > 1 + 1
15:26:42 <lambdabot>   2
15:26:59 <drguildo> > 2 + 2 == 5
15:27:01 <lambdabot>   False
15:27:03 <drguildo> :-(
15:27:13 <augustss_> @quote enterprise
15:27:13 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
15:27:13 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
15:27:20 <gwern> > 2 + 2 == 5 -- I have a good feeling about this try!
15:27:22 <lambdabot>   False
15:27:27 <LegendaryPenguin> whats a good intro book on crypto
15:27:28 <drguildo> hehehe
15:27:31 <LegendaryPenguin> this wiki definition isnt going to cut it
15:27:33 <drguildo> third time lucky?
15:27:38 <LegendaryPenguin> oops wrong channel
15:28:10 <gwern> LegendaryPenguin: bruce scheeiers? cryptonomicon?
15:28:50 * gwern can never spell bruce's name aright
15:29:30 <drguildo> http://www.quadibloc.com/crypto/jscrypt.htm
15:30:00 <gwern> speaking of stephenson I need to get anathem at some point
15:30:11 * gwern wonders if ebooks of it are on the torrents yet
15:31:41 <gwern> 3 audiobook torrents, 1 video reading, and ... 1 ebook torrent which is totally dead
15:31:44 <gwern> wth
15:32:17 <drguildo> try rapidshare
15:32:23 <drguildo> that's pretty good for ebooks
15:32:45 <augustss_> perhaps you should pay for it
15:33:44 <Cale> monochrom: Somehow I don't think the sparse caching is what it's using for such large n, but I could be wrong.
15:34:06 <gwern> augustss_: madness
15:34:27 <gwern> augustss_: it's an ebook or an interlibrary loan. stephenson's successful enough he won't see a red cent from me
15:34:43 <Cale> monochrom: Maybe there's a way to make asymptotic approximations exact if you have close enough cached values though...
15:34:47 <monochrom> I have seen the code and I have seen it do that up to some extent. Of course, I don't understand what happens beyond.
15:35:47 <monochrom> Oh yeah, approximating the inverse of Pi may be helped much by that table.
15:36:06 <monochrom> But I have also seen interval-sieving in the code.
15:36:14 <Cale> You've seen Mathematica's code?
15:36:21 <monochrom> Many many years ago.
15:36:27 <Cale> Interesting :)
15:40:03 <Cheshire> what's that paper with the operators that reify effects using monads ?
15:40:34 <Cale> Cheshire: was it really colourful?
15:40:43 <Cheshire> no it was just black and white
15:40:56 <Cale> hmm, okay :)
15:41:12 <monochrom> Something by Filinski?
15:41:32 <Cheshire> ah thanks Filinski Representing Monads
15:41:40 <monochrom> nice
15:41:59 <koeien> LegendaryPenguin: i've learned it by 'introduction to cryptography' or something like that, by van tilborg
15:42:28 <hackage> Uploaded to hackage: HDBC-mysql 0.2
15:42:28 <hackage> Uploaded to hackage: haha 0.2
15:42:28 <hackage> Uploaded to hackage: haha 0.1
15:42:28 <hackage> Uploaded to hackage: hsp 0.4.5
15:42:48 <ddarius> Also see Representing Layered Monads.
15:47:51 <rovar> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1371#a1371
15:48:09 <rovar> my Data.Map in my StateT doesn't seem to be accumulating..
15:48:27 <rovar> type Net = ReaderT Bot (StateT (StdGen, Map.Map String PC) IO)
15:48:49 <dobblego> is there a type-class with forM/mapM/forM_/mapM_ on it?
15:49:05 <Cheshire> dobblego, Monad
15:49:56 <dobblego> no, on a type-class
15:50:08 <monochrom> Not typeclass methods.
15:51:39 <beelsebob> Axman6: it's actually less general
15:51:41 <beelsebob> just nicer
15:52:05 * monochrom trolls: let's set up a poll on: typeclass, type-class, type class. another poll on: fixpoint, fix point, fixed point, fixedpoint.
15:52:06 <beelsebob> also, the blog post is in the making – but it's actually about why monads are cool, when you don't use them like everyone else does
15:52:17 <rovar> two separate functions in the same monad should have access to the same "global" state, correct?
15:52:21 <byorgey_> dobblego: mapM_ is in Foldable, and mapM is in Traversable.
15:52:54 <monochrom> Yes rovar.
15:52:58 <dobblego> byorgey_, yeah I just realised, thanks
15:52:59 <byorgey_> monochrom: there's nothing to poll about the first one.  'type class' is correct. end of story.
15:53:15 <monochrom> Godawful. I hate "typeclass".
15:53:26 <byorgey_> see any early paper about Haskell + type classes.
15:53:27 <ddarius> monochrom: "fixedpoint" is silly, the rest of those are fine.  Both "type-class" and "type class" are fine.
15:53:44 <rovar> monochrom: so in that paste,  printPCs retrieves the state via get and attempts to print it.
15:54:39 <rovar> the putStrLn on line 14 correctly prints, however when attempting to either insert into the map on line 15, or print it out in line 5, doesn't work
15:55:33 <rovar> i expect to see each item being printed as its inserted into the map, and then it should print an accumulation of everything inserted into the map
15:55:43 <rovar> dunno what I'm doing wrong, but printPCs does nothing.
15:55:59 <monochrom> Strangely enough, I hate "typeclass" and I like "fixedpoint". I'm incomplete and inconsistent.
15:56:23 <chessguy> personally, i prefer 'class', just to piss off OO people
15:56:33 <monochrom> hahaha great
15:56:36 <ddarius> 'class' is what the Report primarily uses.
15:57:04 <monochrom> You should also say "polymorphism" to them alot because that one also piss them. :)
15:57:10 <pejo> chessguy, why deliberately confuse people when it's so easy to add 4 more letters?
15:57:24 <chessguy> because it's so much FUN
15:57:49 <ddarius> pejo: Those four letters doesn't unconfuse those who come into a language thinking it will be exactly like the last language they used.
15:58:02 <monochrom> Just delete four letters and you cause pain in other people. It's very cost-effective.
15:59:08 <monochrom> rovar: Hmm strange.
15:59:15 <Toxaris> I like a keyword - concept correspondence where possible and appropriate
15:59:19 * monochrom tries it. No more talking.
16:01:17 <ddarius> Consider this comment: 'Why is the scoping operator "::" strewn throughout? WTF? Oh, it's being used for types, not scopes.' from http://ripplingbrainwaves.blogspot.com/2009/02/haskell-comprehension-measured-through.html  It's just ridiculous.
16:01:41 <chessguy> ddarius: yeah, i enjoyed that one
16:02:33 <monochrom> Hmm what is PC?
16:02:49 <rovar> a collection
16:03:05 <rovar> data PC = PC {  name       :: String
16:03:07 <rovar> 	            , hps        :: Int
16:03:08 <rovar> 					  	, profession :: Profession
16:03:09 <rovar>               , level      :: Int} deriving (Show)
16:03:27 <pejo> ddarius, no, but it will uncofuse you if it's a language you haven't heard of, or a paper you don't recognize.
16:04:28 <rovar> monochrom: this is the output from line 14:
16:04:48 <ddarius> pejo: People who come into Haskell thinking that it is a language on its own and, in most cases, unlike any language they've previously used, won't have an issue with the terminology "class"
16:05:00 * rovar curses dvorak.
16:05:04 <rovar> PC {name = "@qoreQ", hps = 14, profession = Mage, level = 1}
16:05:06 <rovar> PC {name = "@chump", hps = 14, profession = Thief, level = 1}
16:05:07 <rovar> PC {name = "@cryptomail", hps = 18, profession = Warrior, level = 1}
16:05:20 <Axman6> http://aliaest.blogspot.com/2009/02/speed-of-light.html super deep mandelbrot zoom... just keeps going  and going :o
16:06:03 <rovar> so line 14 works. however, even :   io $ putStrLn $ show $ Map.size chars  doesn't print anything
16:07:23 <kpreid> ddarius: I'm inclined to think he has a point, though less of one than he thinks
16:07:43 <mauke> related: http://dis.4chan.org/read/prog/1234305209
16:07:45 <kpreid> :: is used for namespaces in Common Lisp, Perl, and C++, to name a few languages...
16:08:16 <SamB> kpreid: WTF?
16:08:19 <SamB> ::, seriously?
16:08:23 <SamB> I thought it was just :
16:08:25 <Toxaris> ddarius: I like that list of small insights into Haskell, even if I consider "WTF" a bit rude.
16:08:31 <ddarius> kpreid: And it's not used in C#, Java, Smalltalk, Prolog, Haskell, O'Caml, SML, Scheme, Python, Ruby, etc.  The first two are damning in my opinion.
16:08:33 <mauke> kpreid: isn't it just : in CL?
16:08:37 <kpreid> SamB: you mean in CL?
16:08:43 <SamB> yeah
16:08:52 <mauke> Perl also uses ' for namespaces
16:08:54 <ddarius> Toxaris: It's a decent list, but saying "WTF Haskell isn't C++?!" is a bit silly.
16:09:13 <ray> that list isn't a crime
16:09:19 <ray> don't know if it's valuable though
16:09:23 <Toxaris> ddarius: I'm currently doing some SML coding, and feel exactly the same. Why can't I write (foldl andalso ...). oh, andalso is a keyword, not a function name.
16:09:27 <SamB> ddarius: hey, where does he say C++?
16:09:37 <kpreid> SamB, mauke: in CL, : retrieves "external" symbols only and :: can give you "internal" (private) symbols
16:09:47 <altmattr> whether you had the same wtf moments, it is true I think that that is what learning haskell is like if it is your first functional language
16:09:51 <ddarius> C++ is the only language that came to mind to me when he talked about "::" being a scoping operator.
16:09:55 <kpreid> SamB: I thought it smelled like C++ too, so...
16:10:14 <SamB> well, it means C++ was one of the languages he knew
16:10:16 <SamB> probably
16:10:17 <altmattr> I had a nice easy time with a good teacher and other students to help and it was still all wtf all over the place
16:10:36 <SamB> and that he didn't know another language that used :: in a different way, I guess
16:10:58 <pejo> ddarius, what does clean/mercury/curry/gofer call it?
16:11:28 * wli only knows Mercury of those 4.
16:11:32 <ddarius> SamB: That's fine, but it's ridiculous to walk into a language, especially one advertised to be totally different from everything he knows, and expect it to be the same down to the syntactic foibles.  Learn the language as its own language.
16:11:46 <kpreid> in CL and Perl you'd say package prefix (I think), the C++ materials I've seen call :: the scope resolution operato
16:12:00 <wli> pejo: Mercury used one of '.' or ':' at one point and switched to the other in later language revisions.
16:12:02 <ddarius> pejo: Call what? The scoping operator?  It's . to the extent exists in any of those (excepting Mercury which I know little about)
16:12:17 <SamB> ddarius: he may have just encountered an example that had gotten loose at that point ;-P
16:12:19 <pejo> ddarius/wli, classes, I'm a bit slow. :-)
16:12:55 <ddarius> Gofer was just a Haskell + extensions.
16:13:01 * wli is probably alone in actually liking Mercury.
16:13:52 <ddarius> Clean doesn't have "classes" per se.  Mercury's type classes should be pretty much the same as Haskell's (modulo the whole LP aspect).
16:14:36 <rovar> monochrom: two things:  A: I'm an idiot, and B:  either  put (gen3, (Map.insert s pc chars))  or  put $ (gen3, (Map.insert s pc chars)) compiles
16:14:49 <pejo> ddarius, so Mercury calls them type classes?
16:14:56 <altmattr> wli: I am interested but don't have the time to look into it
16:15:03 <ddarius> pejo: Mercury quite explicitly took the idea from Haskell.
16:15:20 <altmattr> wli: also fascinating to think there is real pl work happening somewhere (else?) in aus
16:15:28 <Cale> ddarius: Don't newer versions of Clean have typeclasses now?
16:15:35 <Cale> Or am I mistaken?
16:16:02 <wli> Clean has/had something vaguely similar that only acted on one operator at a time.
16:16:04 <ddarius> http://www.cs.mu.oz.au/research/mercury/information/doc-release/mercury_ref/Type-classes.html#Type-classes
16:16:40 <ddarius> Cale: I haven't looked at Clean in a while, but I haven't heard anything like that unless by "newer" you mean "newer than eight years ago".
16:16:53 <mathijs> Hi all, as a first real haskell project, I'm going to replace some parsing/conversion code I did in ruby. Since it's text -> xml, I'm not using Data.Binary. I'm looking for a way to get ruby & haskell to communicate. I don't want to try FFI for now. atm I just start the haskell program as subprocess from ruby and stdin/out with it.
16:17:04 <monochrom> rovar: Do you mean you have resolved the problem? (Because I can't reproduce it.)
16:17:23 <ddarius> Clean has "type classes" that can only have one method.
16:17:25 <monochrom> evalStateT (runReaderT (insertPC "hello" >> insertPC "hi") undefined) (mkStdGen 42 , Map.empty)   does what I expect.
16:17:47 <rovar> well,  io $ putStrLn $ show $ Map.size chars  does indicate that the map is growing
16:17:57 <ddarius> http://clean.cs.ru.nl/About_Clean/tutorial/body_tutorial.html#classesandoverloading
16:18:01 <monochrom> chars is not a Map.
16:18:09 <rovar> however, printPC still does nothing, but at least I've isolated the problem
16:18:14 <monochrom> Err chars is a Map.
16:18:17 <rovar> yes
16:18:22 <ddarius> And apparently they use the terminology "class" and not "type class"
16:18:35 <monochrom> printPC prints out the generated "hello" and "hi" PC's fine for me.
16:18:54 <mathijs> Now, I would like to convert the haskell part to be more daemon-like (thus usable by multiple ruby projects without having a subprocess per ruby process), so I want to use a unix socket. Does anyone know what happens when multiple processes start using the same socket?
16:19:10 <rovar> ?
16:19:19 <monochrom> evalStateT (runReaderT (insertPC "hello" >> insertPC "hi") undefined) (mkStdGen 42 , Map.empty)
16:19:30 <monochrom> That's what I entered to the ghci prompt.
16:20:14 <monochrom> You see it does insertPC "hello" and then insertPC "hi" there. We kind of  know what output to expect. I get the expected output.
16:20:30 <monochrom> First time around there is only "hello" inserted and I saw it.
16:20:42 <monochrom> Second time around there are both "hello" and "hi" and I saw both.
16:20:44 <rovar> well it's good to know my code works somewhere :)
16:20:54 <monochrom> I even commented out line 14.
16:21:24 <rovar> okay, i think it does work
16:21:33 <monochrom> save, reload, reboot, restart, power-cycle, ...
16:21:36 <rovar> so yes. it's resolved, do to reasons A and B stated above.
16:21:41 <rovar> mostly A
16:22:05 <monochrom> Try to reboot the whole internet. It usually helps. :)
16:22:27 <pejo> ddarius, so to sum it up haskell and clean uses class, and mercury type class?
16:22:44 <monochrom> GHC should add the error message "The impossible has happened! Please reboot the internet and try again."
16:23:04 <chessguy> @ghc
16:23:04 <lambdabot> ghc says: Illegal unboxed tuple type as function argument
16:23:12 <rovar> it's true
16:24:21 <ddarius> pejo: I'm sure both "class" and "type class" are often used interchangeably in all of those communities.
16:25:03 <ddarius> While the Report primarily uses "class" it also uses the term "type class"
16:26:12 <monochrom> "Das Haskell sprachen und der typeclassen"  (pardon my German)
16:27:50 <pejo> ddarius, yes, within a small (sub-) community it is often obvious from context what someone means.
16:31:20 <mathijs> how can I create a socket file and start listening on it?  (just like the mysql socket file for example)   I looked at Network.Socket but that seems not to be it.
16:35:14 <Saizan_> mathijs: from Network, you can use listenOn to get a socket
16:35:50 <Saizan_> mathijs: and then use accept to get the new connections
16:35:56 <koeien> rotating-lambda ftw
16:36:03 <mathijs> Saizan_: and how can I make that into a socket file?
16:37:02 <mmorrow> mathijs: as in, you want the fd associated with the socket?
16:38:00 <mmorrow> @hoogle fdSocket
16:38:01 <lambdabot> No results found
16:38:01 <mathijs> mmorrow: I want a file on the filesystem to represent the socket. (just like mysql and X11 have socket files)
16:38:18 <mmorrow> oh, so an AF_UNIX one then
16:38:28 <mathijs> ah... sounds right indeed :)
16:38:36 <mmorrow> :)
16:40:15 <mathijs> mmorrow, Saizan_ : thanks for helping, found it... always better when knowing what term to search for :)
16:42:28 <hackage> Uploaded to hackage: probability 0.2.2
17:13:35 <Cale> http://csclub.uwaterloo.ca/~dtbartle/pantsless_paul_martin2.jpg -- ahaha, Paul Martin (former Finance/Prime Minister of Canada) standing with some Waterloo computer science club members on no pants day.
17:16:31 <Axman6> wow... so.. stereotypical
17:22:06 <Axman6> argh, the internet is dead -_- reddit has nothing interesting
17:22:48 <Adamant> Axman6: load up your RSS reader and start hopping blogs
17:22:55 <monochrom> The internet is dating.
17:23:08 <Adamant> I've got more interesting stuff than I have time to read, now
17:23:52 * Axman6 resorts to http://www.se-radio.net/podcast/2007-07/episode-61-internals-gcc
17:24:29 <Gracenotes> oh, that looks interesting
17:24:58 <sereven> Axman6: wish the article you requested of beelsebob was appearing on there. ;-)
17:34:18 <Gracenotes> Adamant: random question, but -- which RSS reader do you use?
17:34:34 <Adamant> Gracenotes: Google Reader
17:35:18 <Adamant> there are good native client and web-based readers
17:35:26 <Gracenotes> ah, I've heard good things about that... at the moment I just store everything in drop-down lists in my bookmarks toolbar
17:35:57 <Gracenotes> e.g. a list for news, technology, culture-ish things, webcomics, etc. I should probably catch up with the times ;)
17:36:23 <Adamant> yup, it's worth it on the boredom front
17:36:28 <Axman6> Gracenotes: i use Apple Mail. works great, i get rss feeds right in my inbox, just like emails
17:37:11 <Adamant> downside is you have to limit how often you read it, or rank sites somehow
17:37:26 <Adamant> because you can get a ton of sites
17:37:59 <Gracenotes> eh. The problem is that sometimes I'll want to skip over some posts. So I check interesting blogs more often, and less interesting blogs less often (reading several entries in one go)
17:38:26 <Adamant> I skip posts and still have too many to read
17:40:03 <Gracenotes> heh. people need more and more content nowadays :) It's like an addiction
17:40:23 <Gracenotes> I wonder if that's because the quality of everything is going down, or because we can just handle more content.
17:40:25 <Gracenotes> probably both.
17:45:23 <Adamant> Gracenotes: I think there's more good content out there now than ever
17:45:29 <Adamant> and also more bad
17:45:36 <Gracenotes> yep
17:46:03 <Adamant> reading blogs from acknowledged experts is much better than seeing it filtered through the media
17:47:02 <Gracenotes> heh. indeed. computer science is not (yet) suitable for mass feeding :)
17:47:12 <Adamant> but, for instance, the level of political discourse has either declined, or we just didn't give a voice to a lot of "Youtube comment page"-grade thinkers.
17:47:52 <redditbot> BHLog : Notes from PADL
17:48:17 <Gracenotes> there are some intelligent people who comment on YouTube
17:48:29 <Gracenotes> as far as I can tell they're few and far between, though :)
17:48:41 <Adamant> Gracenotes: true, but the S:N ratio is too awful for me to bother with it
17:49:08 <gwern> for rss, I just use rssfwd and read my email
17:49:27 <gwern> making sure to set the updates to 'weekly' so I only waste time on late saturday/early sunday
17:49:29 <Adamant> everything's more or less glorified email anyway
17:51:47 <Axman6> Gracenotes: i think i can caount on one hand the num,ber of intelligent comments i've read on youtueb
17:52:16 <Gracenotes> why, do you have them framed in your bedroom or something? :P
17:52:36 <Axman6> s/can/count
17:52:38 <Axman6> >_>
17:52:42 <Axman6> could*
17:52:44 <Axman6> urtgh
17:52:47 <Axman6> vrek,jfbvadjfbgadgh
17:53:10 <Gracenotes> really, though. In general I've found that tech videos seem to have polite-ish intelligent-ish comments
17:53:29 <Axman6> yeah
17:53:30 <altmattr> tech videos?
17:53:41 <Axman6> googl tech talks for example
17:53:41 <altmattr> on you tube?
17:53:41 <altmattr> you are having me on, right?
17:53:47 <Gracenotes> there's something about YouTube that makes arguments you agree with seem poorly written :/
17:54:29 <Axman6> http://www.youtube.com/user/googletechtalks
17:54:38 <Gracenotes> well, for one, http://www.youtube.com/googletechtalks
17:54:56 <Gracenotes> oops. too similar, too late ;)
17:56:03 <altmattr> i know, I am not being serious :)
17:56:03 <altmattr> just hard to find under all the skating dogs and falling children
17:56:03 <altmattr> and dubbed miming
17:56:03 <altmattr> and video responses
17:56:03 <altmattr> and ...
17:56:04 <altmattr> and beached whales
17:56:06 <altmattr> and....
17:56:08 <Gracenotes> hm... there's TheCasters, which is mathy..
17:56:08 <altmattr> nuff now :)
17:57:59 <Gracenotes> then there's this channel I used to follow that was about coding, albeit in JavA: http://www.youtube.com/user/codingkriggs
17:58:03 <Gracenotes> *a
17:58:36 <Gracenotes> hasn't posted anything in a long time
17:59:25 <Gracenotes> I don't agree with his points so much anymore, but the channel just popped into my mind, anyway
18:00:33 <Gracenotes> then there are random rants that programming-people make. That's all the compsci/programming videos YouTube has, I believe :(
18:01:35 * vijay4114 yawns
18:08:00 <mathijs> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1386#a1386 -- please have a look if this is ok. is it safe to use forkIO in this case and use the handle h? or should I use an MVar to pass it to the other thread?
18:13:25 <Saizan_> mathijs: i don't think you should bracket like that in the serverLoop function
18:14:41 <mathijs> Saizan_: what's wrong with it?
18:15:16 <Saizan_> mathijs: once you pass the handle to handleClient it's that thread responsiblity to close it i think
18:16:04 <Saizan_> mathijs: you also accumulate those exception handlers ad infinitum in serverLoop and that doesn't look good
18:16:39 <mathijs> Saizan_: ok, so move the hClose part inside forkIO?
18:17:28 <Saizan_> mathijs: yeah, with `finally`
18:18:18 <mathijs> Saizan_: ok. Thanks. What's wrong with 2 layers of brackets by the way/
18:18:52 <mathijs> Saizan_: ah... found what you mean
18:19:11 <Saizan_> mathijs: well bracket is intended for bracket <acquire resource> <dispose resource> <use resource>
18:19:26 <mathijs> what if I just move the tail recursion back 2 spaces? (serverLoop s)
18:19:47 <Saizan_> while your third argument goes on doing other things completely unrelated to that resource
18:20:23 <Saizan_> mathijs: that'll close the handle too soon i guess
18:20:25 <mathijs> yeah it shouldn't recursive while in the <use resource> part
18:20:59 <Saizan_> forkIO returns immediately, so handleClient would see a closed Handle, probably
18:21:14 <mathijs> Saizan_: got it... so the main thread gets the handle, starts a new thread that `finally` closes it handle
18:21:31 <Saizan_> yeah
18:21:37 <mathijs> cool thanks
18:21:58 <Saizan_> the main thread probably should still catch exceptions from accept
18:22:25 <mathijs> but still... is it safe to use h inside the forkIO part? or should I use an MVar?
18:22:35 <Saizan_> it's completely safe
18:23:10 <mathijs> aren't exceptions from accept caught by main's bracket?
18:23:34 <mathijs> ah... in that case the program terminates
18:24:10 <Saizan_> bracket rethrows them
18:24:25 <Saizan_> and yeah, the serverLoop will terminate
18:24:58 <Saizan_> it's up to you if you want your program to quit on such errors or not
18:25:00 <mathijs> yeah, but it's probably an exception that has no nice way of handling anyway. What can go wrong in accept?
18:25:46 <Saizan_> accept tries to determine the hostname and that can go wrong
18:25:59 <mathijs> on a local AF_UNIX socket?
18:26:00 <Saizan_> you might just ignore such exceptions and continue your loop
18:26:25 <Saizan_> ah, in that case probably not :)
18:26:40 <Saizan_> well, i guess you can test your program for a while and see
18:26:44 <tehgeekmeister> which is better style: define a datatype and an instance of ord to make a function elegant and concise, or add extra logic to that function that does the same thing essentially?
18:26:59 <mathijs> yeah that might be an option. but I'd like the program to crash on any such errors so I can investigate them and try to fix the problem that causes them.
18:27:12 <mathijs> Saizan_: thanks for your help
18:27:17 <Saizan_> mathijs: np
18:27:19 <Unstoppable> If you are tired of the shitskin nigggggers like I am, and recognize that the majority of them will never come close to the mental abilities of the great Swami Obama, join us at http://www.chimpout.com/forum .  At Chimpout we welcome all human races whether it be Asian, White, Semite, Indian, Amerindian, or non-negroid Hispanic!  At Chimpout we value diversity but hate NIIIGGGGGGERS!!!  http://www.chimpout.com/forum
18:27:44 --- mode: ChanServ set +o Saizan
18:27:51 --- mode: Saizan set +b *!*=IceChat7@201.170.132.*
18:27:51 --- kick: Unstoppable was kicked by Saizan (Saizan)
18:27:55 --- mode: Saizan set -o Saizan
18:28:17 <mathijs> so much for free speech :)
18:28:19 <mmorrow> does anyone know what header PAGESIZE is declared in?
18:28:28 <Saizan> tehgeekmeister: more types the better :)
18:28:45 <tehgeekmeister> Saizan: okay, thanks!
18:29:17 <tehgeekmeister> trickier question then, and i think the answer is no
18:29:50 <tehgeekmeister> can two different types that are in the ord class be compared, can i define a comparison for them?
18:30:12 <rwbarton> not directly
18:30:16 <rwbarton> @type (<)
18:30:19 <lambdabot> forall a. (Ord a) => a -> a -> Bool
18:30:29 <tehgeekmeister> okay, so i'll have to work around that anyway.
18:30:37 <tehgeekmeister> then the extra data type gains me nothing.  =/
18:30:42 <tehgeekmeister> oh well!
18:30:55 <rwbarton> you can use extra data types here too
18:31:01 <rwbarton> > Left 'x' < Right 36
18:31:03 <lambdabot>   True
18:31:22 <tehgeekmeister> oh wow how does that comparison work?
18:31:48 <tehgeekmeister> and why is either in ord?
18:31:50 <rwbarton> it just has Left (anything) < Right (anything)
18:32:05 <tehgeekmeister> okay
18:32:11 <rwbarton> You can derive a similar Ord instance for any data type you define where all the constructors' fields are in Ord
18:33:19 <Gracenotes> all you have to define for an Ord, if declaring an instance yourself, is <=, iirc (or compare)
18:33:39 <tehgeekmeister> in any case, it turns out the code i was thinking would end up complicated was really short and elegant
18:33:47 <tehgeekmeister> this has been happening to me a lot lately, i like that
18:33:51 <Cale> compare is usually the best thing to define
18:35:39 <tehgeekmeister> weird, i used :t foo in ghci to get the type for a function i had been working on and wanted a signature for
18:35:45 <tehgeekmeister> then pasted that signature into the file
18:35:58 <Gracenotes> :D
18:36:07 <tehgeekmeister> and now ghc is complaining it's not right?
18:36:13 <tehgeekmeister> i didn't change the function!
18:36:15 <Gracenotes> :x
18:36:22 <mmorrow> wtf, PAGESIZE and PAGE_SIZE are supposed to be in limits.h, but PAGE_SIZE (and no PAGESIZE) is in (at least) sys/user.h on my box (fedora)
18:36:23 <rwbarton> that can happen unfortunately
18:36:46 <Gracenotes> tehgeekmeister: hm, what was the compile error?
18:38:06 <tehgeekmeister> Gracenotes: http://tinyurl.com/bxyzsz
18:38:38 <Saizan> do what the error says :)
18:39:12 <tehgeekmeister> Saizan: but why did ghc allow this before i added the type signature?
18:40:34 <Saizan> tehgeekmeister: because the extension is about being able to write such signatures
18:41:24 <Gracenotes> i.e. {-# LANGUAGE FlexibleContexts #-}
18:41:25 <tehgeekmeister> hum, i'm going to have to read about this, i want to understand it
18:41:34 <Saizan> i'm not sure why they splitted multiparamter typeclasses support like that..
18:42:10 <Gracenotes> I've found relatively little documentation about GHC extensions :/
18:42:43 <Saizan> the standardization is discussed on the Haskell' wiki
18:44:50 <tehgeekmeister> hum, i just want to know why i am adding that magic to the top of my file
18:45:03 <tehgeekmeister> i don't care to understand alll of it
18:45:49 <Saizan_> in haskell98 typeclass constraint can only be of the form "Class typevariable"
18:46:07 <Saizan_> because typeclasses were quite new at the time and they wanted to be conservative
18:46:18 <tehgeekmeister> however, i've been considering that it might be useful to read a book on types in general (thinking of types and programming languages), do you all think this is true?
18:46:33 <Cale> tehgeekmeister: TaPL is definitely a good book.
18:46:55 <tehgeekmeister> Cale: for theoretical and practical value both?
18:47:35 <Cale> To be honest probably a little more theoretical value than practical, but some of each.
18:47:51 * SamB is having trouble with the distinction
18:48:13 <Cale> Well, yeah, I suppose it depends on what one defines as practical :)
18:48:40 <Cale> If you're implementing a compiler, say, there's a lot in it which is essential knowledge.
18:49:18 <tehgeekmeister> well, i'm interested in both theoretical and practical value
18:49:22 <tehgeekmeister> i like this sort of stuff in general
18:49:46 <tehgeekmeister> but i don't wanna spend time on it right away if it's not going to help me so much in practice, there are other things i could do first
18:49:51 <Gracenotes> TAPL has some OCaml code that you can translate into Haskell, if you're up to it
18:50:06 <SamB> tehgeekmeister: well, are you trying to write a compiler ?
18:50:09 * Gracenotes doesn't even know OCaml, but it's simple enough)
18:50:20 <tehgeekmeister> SamB: no, not at all.  but that'd be fun someday.
18:50:30 <Cale> Yeah, the only annoying thing about the OCaml code is that in places they've abused exceptions.
18:50:41 <tehgeekmeister> SamB: i'm just confused all the time by my type errors.  they're getting less mystical, but i want to get rid of all the  mystery.
18:51:02 <Gracenotes> Cale: eesh, tell me about it
18:51:23 <Gracenotes> the single-step evaluator uses an exception as a "stop evaluating" signal
18:51:23 <SamB> something like StopIteration in Python ?
18:51:39 <Gracenotes> yeah
18:51:56 * tehgeekmeister just realized that his error message problems were a result of not calling the function with all the necessary arguments
18:52:06 <tehgeekmeister> that gets you some really scary error messages
18:52:08 <Gracenotes> I ended up doing something like eval x = maybe x eval (evalSingleStep x)
18:52:22 <Cale> tehgeekmeister: hehe
18:52:23 <SamB> tehgeekmeister: the compiler didn't suggest that that might be the case ?
18:52:42 <tehgeekmeister> SamB: not this time
18:52:43 <Cale> A "cannot construct infinite type" perhaps?
18:52:50 <tehgeekmeister> nope
18:53:54 <tehgeekmeister> oh now i've run into something i really don't know about
18:54:45 <tehgeekmeister> http://tinyurl.com/bxyzsz
18:54:58 <tehgeekmeister> (oops, added it to my last error instead of a new paste, oh well.)
18:55:39 <Cale> tehgeekmeister: It doesn't know that > applies to the things you're applying it to.
18:55:44 <rwbarton> > abs (3 :+ 4)
18:55:47 <Cale> tehgeekmeister: What type signature have you given?
18:55:47 <lambdabot>   5.0 :+ 0.0
18:55:55 <rwbarton> how do I convert that to a Double?
18:56:10 <Cale> > magnitude (3 :+ 4)
18:56:11 <Saizan_> isn't Ord a superclass for Num, and so for Floating?
18:56:12 <tehgeekmeister> Cale: nextItem :: (Floating a) => M.Map String a -> String
18:56:12 <lambdabot>   5.0
18:56:17 <rwbarton> Cale: ooh
18:56:21 <Cale> Saizan_: no...
18:56:23 <Cale> Saizan_: Eq is.
18:56:29 <Saizan_> ah, right.
18:56:30 <Olathe> > real (5.0 :+ 0.0)
18:56:31 <lambdabot>   Not in scope: `real'
18:56:40 <Olathe> @hoogle Complex a -> a
18:56:40 <lambdabot> Data.Complex imagPart :: RealFloat a => Complex a -> a
18:56:40 <lambdabot> Data.Complex magnitude :: RealFloat a => Complex a -> a
18:56:40 <lambdabot> Data.Complex phase :: RealFloat a => Complex a -> a
18:56:43 <wli> @type realPart
18:56:43 <Cale> tehgeekmeister: Add Ord a to the context like it's asking you to
18:56:44 <lambdabot> forall a. (RealFloat a) => Complex a -> a
18:56:47 <Olathe> > realPart (5.0 :+ 0.0)
18:56:49 <lambdabot>   5.0
18:56:56 <Cale> tehgeekmeister: So that becomes  nextItem :: (Floating a, Ord a) => M.Map String a -> String
18:57:04 <kerlo> You know, I still don't know how to pronounce "Haskell".
18:57:11 <Cale> Haskl
18:57:16 <Olathe> > (\(a :+ _) -> a) (5.0 :+ 0.0)
18:57:18 <lambdabot>   5.0
18:57:38 <Olathe> It's like rascal.
18:57:39 <Twey> kerlo: [ˈhaskɫ]
18:57:56 <kerlo> Twey: is that UTF-8?
18:58:11 <Cale> Twey has fancy IPA magic :)
18:58:16 <tehgeekmeister> how else would you pronounce it?  hm, it'd never occurred to me there was an alternate pronunciation.
18:58:20 <Olathe> hass cull
18:58:22 <Twey> kerlo: Yes
18:58:36 <kerlo> For one, you could stress the other syllable.
18:58:41 <Gracenotes> That's how you goyim pronounce Haskell! You're forgetting the gutteral h
18:58:48 <Gracenotes> chaskell
18:58:51 <Olathe> Oh dear.
18:58:54 <tehgeekmeister> =D
18:59:06 <Twey> Olathe: Maybe your dialect is different, but here we pronounce 'rascal' as [ˈɹɑskɫ]
18:59:14 <Twey> With a long 'a' like in 'father'
18:59:25 <kerlo> We're all Americans in here.
18:59:30 <kerlo> By which I mean "I'm an American".
18:59:32 * Saizan_ pronouces the 'e', but he's italian..
18:59:46 <pumpkin> :o
19:00:03 <kerlo> I gave up trying to speak English a long time ago. :-P
19:00:04 <pumpkin> Saizan_: your english is really good :P
19:00:08 <tehgeekmeister> oops, i did something very wrong.  i expected a greek word as the result of my code, but i got an int, in string form.
19:00:12 <Twey> kerlo: Dialects still differ :-P
19:00:16 <thotypous> is rascal like pascal but with r?
19:00:23 <Twey> thotypous: No
19:00:27 <Cale> tehgeekmeister: :)
19:00:39 <tehgeekmeister> thotypous: it is in the seattle area
19:00:40 <Twey> 'Pascal' is a French name, and thus completely different again: it's stressed on the second syllable
19:00:54 <Cale> tehgeekmeister: Does it have any backslashes in it?
19:00:57 <Twey> [pasˈkal]
19:01:08 <Gracenotes> I fear that people will think I'm talking about Pascal when I'm talking about Haskell. Oh, the constant fear.
19:01:16 <thotypous> :P
19:01:18 <tehgeekmeister> Cale: no, i had two maps, and one should've had ints in strings in it, i think i folded over the wrong one.  =P
19:01:23 <Twey> Gracenotes: BTDT :(
19:01:23 <Cale> ah
19:01:26 <tehgeekmeister> Gracenotes: that's happened to me!
19:01:57 * Gracenotes adds BTDT to his list of not-obvious-at-first-acronyms
19:02:03 <Twey> thotypous: Why isn't it an IntMap?  :-P
19:02:06 <Gracenotes> but, yeah, most people around me seem to know what it is
19:02:09 <tehgeekmeister> Gracenotes: then they asked which implementation i used, and if i had a proprietary one.  and i was like, "i wasn't aware there was a proprietary haskell compiler?"
19:02:29 <Twey> Argh
19:02:32 <tehgeekmeister> i still don't get BTDT
19:02:34 <kerlo> Rascal: RAS-kl, first syllable sounds like "trap" or "bath". Pascal: pas-KAL, both syllables sound like "trap" or "bath".
19:02:39 <kerlo> In American English, anyway.
19:02:47 <Gracenotes> among other not-so-obvious acronyms as YMMV, HTH, TYVM, and ITYM
19:03:05 <Cale> TYVM?
19:03:10 <Gracenotes> thank you very much
19:03:12 <Cale> ah
19:03:23 <Gracenotes> oh, and FTFY
19:03:46 <Twey> You're right — apparently in the US it's pronounced with a short 'a' (according to Cambridge)
19:04:10 <pumpkin> who was talking about ARM in haskell? some package?
19:04:19 <kerlo> People who are more British than me: is the "a" of "Haskell" pronounced like the "a" of "trap" or the "a" of "bath"?
19:04:19 <vijay4114> YMMV?
19:04:23 <Twey> kerlo: Stick with just 'trap' to describe that sound.  If you say 'bath' you're only confusing the issue even more.  :-P
19:04:23 <pumpkin> oh HARM
19:04:31 <Twey> 'Trap'
19:04:31 <pumpkin> oh it was Axman6
19:04:58 <Cale> Hehe, it's fun to see which of cot, caught and court are pronounced the same by various people.
19:05:06 <Twey> Haha, yes
19:05:09 <kerlo> Twey: that's why I said "in American English".
19:05:16 <Twey> And 'Mary', 'merry', and 'marry'
19:05:51 <Twey> kerlo: But that doesn't help the people for whom GenAm isn't a native accent :-P
19:06:04 <kerlo> I can't easily speak for non-Americans.
19:06:05 <pumpkin> erikc: you there?
19:06:17 <Cale> kerlo: Not even all Americans have the same accent :P
19:06:21 <kerlo> I don't listen to BBC World Service as often as I could. :-P
19:06:30 <Twey> kerlo: If you use a slightly-more-universal vowel like 'trap', it would be less confusing
19:07:04 <Twey> Although of course it still differs: to an English ear, the General American pronunciation of 'trap' sounds kind of like 'trep' or 'treyp' :-P
19:07:08 <kerlo> Twey: well, I didn't know whether it was "trap" or "bath".
19:07:24 <Twey> Oh, with 'rascal' too?
19:07:36 <Twey> I see, pardon me.  :)
19:07:45 <kerlo> Actually, from what you said above, I would have thought "bath".
19:08:16 <Cale> Twey: Where I live, all three of those are the similar enough that you have to strain to hear the difference if any (Mary, merry and marry). I do pronounce merry just *slightly* differently.
19:08:27 <Twey> kerlo: Why's that?  I was talking about 'rascal' when I said that
19:08:38 <Twey> I didn't actually make any comments on 'Haskell' (except the IPA)
19:08:57 <Twey> Cale: Really?  I thought Canadians distinguished between their vowels more
19:09:16 <Cale> The Great Vowel Shift is up here as well.
19:09:53 <hiredman> http://www.omniglot.com/blog/2009/01/19/foreign-pronunciations/
19:10:03 * tehgeekmeister is starting to think that the more types he can add into his code, the easier it'll be to keep it bug free
19:10:17 <Cale> Err... not the "Great" one... what's it called? North American vowel shift?
19:10:23 <kerlo> Twey: maybe I'm wrong regarding the pronunciations of "trap" and "bath" in your dialect.
19:10:45 <ddarius> tehgeekmeister: The more the Maryer.
19:10:48 <kerlo> Accent, rather.
19:11:09 <kerlo> (I don't know what your accent is, for that matter.)
19:11:36 <Twey> Cale: Not only that, but you've presumably got Canadian raising, which *really* confuses the issue with vowels :-P
19:12:21 <monochrom> Cahnahdah? Caenaeda?
19:12:35 <kerlo> My belief is that "trap" is pretty similar to the American "trap", while "bath" has the "father"-like "a".
19:14:00 <Twey> Cale: Er, the Northern Cities vowel shift
19:14:42 <Cale> Yeah, that might be what I'm thinking of, but the wikipedia description sounds different...
19:16:06 <Cale> http://en.wikipedia.org/wiki/Phonological_history_of_English_low_back_vowels#Cot-caught_merger
19:17:11 <dancor> i guess there is going to be less such drifting in the future as we are more globalized?
19:17:13 <tehgeekmeister> can i declare a newtype for the same type twice?
19:17:28 <dancor> and more connected to past
19:17:37 <Cale> tehgeekmeister: you can make two different newtypes of the same type
19:17:44 <tehgeekmeister> yay!
19:17:51 <dancor> maybe not tho, maybe just more intentional/kwl shifts
19:17:57 <Twey> Cale: Yes, that's not a Vowel Shift as far as I'm aware
19:18:18 <Cale> Well, I suppose it's part of that Northern Cities one.
19:19:34 <Twey> I don't think so
19:20:08 <Cale> Oh, the shift does something more unusual to those words...
19:20:12 <Twey> It occurs in some places far south of the agreed area of the Northern Cities
19:20:17 <Cale> yeah
19:20:49 <Twey> Mind you, it does seem to result in something similar:
19:20:54 <Cale> Apparently the Northern Cities shift makes people pronounce caught the way that people without it would say cot.
19:21:07 <Twey> « The fronting of /ɑ/ leaves a blank space in Northerners' pronunciation that is filled by lowering /ɔ/ (the "aw" vowel, as in saw), which comes to be pronounced with the tongue in a lower position, closer to [ɑ]. As a result, people affected by the shift may pronounce caught the way speakers without the shift say cot. »
19:21:12 <Twey> Yeah
19:21:15 <Twey> Which is backwards
19:21:25 <Twey> The merger elsewhere causes them to pronounce 'cot' the way others pronounce 'caught'
19:22:02 <tehgeekmeister> Cale: okay i ran into a problem with that.  i newtyped the map type from Data.Map, but i still need to use the functions from Data.Map on it, how do i make that work?  =/
19:22:23 <Cale> tehgeekmeister: You'd have to apply them underneath the newtype data constructor.
19:22:30 <tehgeekmeister> fmap?
19:22:32 <Cale> tehgeekmeister: So pattern match
19:22:35 <Cale> Or fmap, sure
19:22:38 <tehgeekmeister> okay
19:22:47 <Cale> er, if you can write a functor instance.
19:22:56 <tehgeekmeister> oh right
19:23:08 <tehgeekmeister> i probably could if i knew what it did?
19:23:09 <Cale> If you make your newtype like  newtype Foo a = Foo a
19:23:28 <tehgeekmeister> newtype ItemsToTargets = ItemsToTargets (M.Map String (S.Set String)) deriving (Show, Eq)
19:23:37 <Cale> okay
19:23:38 <tehgeekmeister> that's the type in question
19:23:51 <Cale> So yeah, that's not a functor.
19:24:11 <tehgeekmeister> so i have to pattern match?  man, and everything was one liners, too
19:24:12 <tehgeekmeister> =/
19:24:12 <mmorrow> hmm, i just realized some TH code could hugely make life easier for wrapping a type, then lifting all its functions to operate on that newtype
19:24:17 <Cale> But you can write a function to extract the map and/or pattern match.
19:24:27 <Cale> tehgeekmeister: Is there a reason you absolutely need the newtype?
19:24:34 <tehgeekmeister> i don't need it at all
19:24:39 <tehgeekmeister> but i have two maps of the same type
19:24:42 <mmorrow> it's sooo annoying having to re-define all the functions on the newtype when you want that
19:24:42 <tehgeekmeister> and i was mixing them up
19:24:46 <Cale> ah, okay
19:24:47 <glguy> mmorrow, but the point of a newtype is to hide all of those old functions
19:24:55 <Cale> So yeah, that's a good way to keep them separate.
19:24:57 <mmorrow> glguy: not necessarily
19:25:13 <glguy> mmorrow, otherwise you'd use a type synonym
19:25:19 <Cale> But yes, the same thing which protects you from making those mistakes is what's creating the inconvenience.
19:25:29 <tehgeekmeister> yeah, i'm realizing that
19:25:31 <mmorrow> many times i use a newtype over, say, Data.Map to hide the implem, but still want insert/delete/singleton/etc
19:25:42 <tehgeekmeister> i think i won't use the newtype, actually
19:25:52 <mmorrow> but with a type syn, you can freely substitue a Data.Map, which i don't want
19:25:53 <glguy> mmorrow, if all of the functions operate on the new type, you haven't hidden the implementation :)
19:26:02 <tehgeekmeister> i'll just be very careful to use the right map
19:26:10 <mmorrow> glguy: why?
19:26:29 <bashyal> A quick question: I am getting a type error that I am not understanding. I'm just writing a function to get real roots of a quadratic equations. Any idea? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1404
19:26:35 <glguy> mmorrow, if the data.map functions operate on your new type
19:26:41 <mmorrow> insert :: k -> v -> MyMap k v
19:26:43 <glguy> you haven't hidden the fact that it is a new type
19:26:46 <Cale> mmorrow: heh, we need newtype for modules :)
19:27:12 <mmorrow> glguy: but they're not the Data.Map functions, they're the ones define over my MyMap
19:27:16 <mmorrow> Cale: yes!
19:27:28 <mmorrow> SML sigs/structs/functors
19:27:32 <Cale> Import an existing module, but qualified and such that all the types imported from it are treated as distinct from other imports of that module.
19:27:40 <rwbarton> bashyal: You're trying to take the square root of an Int
19:28:35 <bashyal> But "sqrt 16" works on the ghci prompt.
19:28:37 <Cale> fromIntegral will convert an Int to some other numeric type which sqrt will apply to
19:28:51 <Cale> bashyal: The type of 16 there will be defaulted to Double
19:29:06 <Cale> bashyal: Note that 16 :: (Num a) => a, by default.
19:29:08 <mmorrow> err, i meant insert :: k -> v -> (MyMap k v -> MyMap k v)
19:29:11 <monochrom> sqrt 16 is different from sqrt n.
19:29:11 <rwbarton> :t 16
19:29:13 <lambdabot> forall t. (Num t) => t
19:29:46 <SamB> but Cale said it was *a8
19:29:48 <SamB> er.
19:29:50 <SamB> *a*
19:29:55 <Cale> SamB: heh
19:30:18 <Cale> 16 :: (Num samB) => samB
19:30:18 * SamB supposes we'll have to invoke the "color rule"
19:30:31 <JasonFelice> I have a cabal package that won't go away.  I thought I deleted the lib, did "runghc Setup.hs unregister", but I can still load it in ghci.
19:31:20 <SamB> JasonFelice: are you still in the source directory?
19:31:50 <JasonFelice> I can be :)
19:32:04 <SamB> I mean, does it load even from other directories ?
19:32:11 <SamB> what does ghc-pkg list say ?
19:33:13 <JasonFelice> Eh, it says there's one installed in ~/.ghc.  That explains it.
19:33:39 <JasonFelice> Did I install it without sudo'ing once?
19:34:33 * SamB mumbles something about cabal-install possibly defaulting to --user ?
19:36:02 <JasonFelice> How does this ~/.ghc thing work?  It's just a package.conf, no libs or anything.  Is it using the libs in ~/.cabal?  I probably screwed it up because I was fighting with it for a bit.
19:38:00 <SamB> JasonFelice: read the package.conf ?
19:39:20 <JasonFelice> heh, duh.  Yes, it refers to the libs in .cabal.  I've got the phantom package thing solved now, thanks.
19:39:39 <erikc> pumpkin: whats up?
19:40:14 <pumpkin> erikc: you missed a couple of load commands in your mach-o module! :P but other than that it works wonderfully, thanks!
19:40:22 <tehgeekmeister> i can not do something like foo :: Left -> SomeType, can i?
19:40:31 <tehgeekmeister> have to do foo :: Either -> SomeType
19:42:18 <kerlo> tehgeekmeister: RIGHT.
19:42:29 <kerlo> Which is what caps lock does to a person.
19:42:32 <tehgeekmeister> hum, okay
19:43:06 <kerlo> Though it has to be some Either a b, of course, not plain old Either.
19:43:12 <erikc> pumpkin: o, which load commands?
19:43:17 <kerlo> Did you want Left -> SomeTime for anything in particular?
19:44:06 <pumpkin> erikc:
19:44:07 <pumpkin> getLoadCommand 0x0000001d mr lc fl mh = getLinkEditCommand mr lc LC_CODE_SIGNATURE
19:44:07 <pumpkin> getLoadCommand 0x0000001e mr lc fl mh = getLinkEditCommand mr lc LC_SEGMENT_SPLIT_INFO
19:44:09 <pumpkin> I added those two in
19:44:20 <pumpkin> it's pretty simple stuff, I'd send you a patch but it's a few lines
19:44:20 <tehgeekmeister> kerlo: i wanted something analogous.  I defined an ADT and i'd like to restrict some types to only one or the other of the constructors.  but it's not necessary, it'd just be nice
19:44:22 <pumpkin> if you want I ca n:)
19:45:12 <pumpkin> erikc: it was crashing on some of the things I tested it on because they contained code signature, and I got a non-exhaustive pattern match issue
19:45:40 <kerlo> tehgeekmeister: would using plain old a or b work?
19:46:11 <tehgeekmeister> kerlo: that's what i'm doing for now.  it's good enough.
19:46:14 * kerlo nods
19:47:44 <ferret_0567> are there DBus bindings for Haskell?
19:47:52 <redditbot> Ascii art on ANSI terminals
19:48:15 <ferret_0567> what was the command to redditbot?
19:48:22 <dolio> I think there's more than one set of bindings.
19:48:33 <ddarius> redditbot is autonomous.
19:48:40 <dolio> redditbot announces things that appear on the haskell reddit.
19:48:47 <ferret_0567> ah
19:48:51 <SamB> redditbot presumably wworks off RSS
19:49:17 <tehgeekmeister> oh boy you know you did something wrong when you get a different result with the same data and the same algorithm.
19:49:22 <bashyal> Cale: thanks. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1404 works now. I thought it auto promoted numeric types. I guess not. thanks again.
19:49:36 <ferret_0567> tehgeekmeister: oh yeah
19:50:01 <ferret_0567> tehgeekmeister: have you implemented a program in haskell that draws a triangle, a square, and a rectangle on a terminal?
19:50:12 <ferret_0567> tehgeekmeister: I have only done it in C++
19:50:32 <dolio> I wrote one that drew a mandelbrot set, I think.
19:50:32 <tehgeekmeister> ferret_0567: no, haven't tried to, but i'm sure it'd be easy enough if you just mean ascii art.
19:50:41 <tehgeekmeister> dolio: i was just thinking about doing that today
19:50:56 <pumpkin> whee, my disassembler can deal with the multi-reg instructions now
19:51:11 <erikc> pumpkin: interesting, code signature is not in the official mach-o pdf so i skipped it, ill add it, those sneaky apple folk
19:51:11 <ferret_0567> tehgeekmeister: yeah, ascii art
19:51:44 <pumpkin> erikc: ah, yeah, it's in recent loader.h files on mac os and iphone os, but they've added a few things since they last updated that official spec :/
19:51:47 <ferret_0567> tehgeekmeister: when I implement it in Haskell I will make it draw as many colors in as many different styles as possible for each row
19:52:00 <pumpkin> erikc: want me to send you my changes? it's pretty simple stuff
19:52:56 <erikc> sure, it'll be the first darcs patch i ever apply :)
19:53:19 <pumpkin> ack :P I'll see if I can submit a real darcs patch :P
19:54:01 <tehgeekmeister> it won't cause any problems to call a function that uses a state monad from inside another function in the state monad, will it?
19:54:32 <pumpkin> erikc: you didn't post a darcs repo to get from, as far as I can see
19:54:44 <pumpkin> I just unpacked the tarbal
19:55:12 <SamB> teach him how to put the repo in his package
19:55:44 <pumpkin> me? I don't know much about darcs myself, and have never made a package :) I'm more of a git person
19:56:00 <SamB> it's not about darcs vs. git
19:56:07 <SamB> it's about Cabal
19:56:21 <erikc> SamB :), i didnt have a repo at the time, i need to update all my packages accordingly
19:56:23 <SamB> if you can do it for darcs, you can do it for git and vice versa
19:56:48 <monochrom> tehgeekmeister: if I understand your question, yes.
19:56:57 <monochrom> I mean there is no problem.
19:57:01 <tehgeekmeister> monochrom: okay
20:00:39 <lepassive> I installed XMonad from synaptic and logged out, when i choose xmonad session X frozes .. #xmonad seems to be kinda down
20:06:07 <pumpkin> mmorrow: so I might be revising the decoder formats from binutils, as they don't carry much semantic information :/
20:06:23 <pumpkin> mmorrow: which will make it harder to autogenerate definitions
20:07:09 <pumpkin> their disassembler output seems to be exclusively for human consumption
20:08:38 <tehgeekmeister> is there a way to pattern match an empty map as in Data.Map?
20:09:16 <pumpkin> no
20:09:22 <pumpkin> but you can guard against it
20:10:55 <tehgeekmeister> that works
20:15:33 <tehgeekmeister> pumpkin: you can't access the state inside a guard, tho?  i'll need to do the branching inside the function, right?
20:15:45 <pumpkin> the state?
20:17:10 <tehgeekmeister> the function is in the state monad
20:18:33 <pumpkin> oh
20:18:54 <tehgeekmeister> so i should access the state inside the function using get
20:18:54 <pumpkin> I think it shoulds still work as normal
20:18:58 <tehgeekmeister> really?
20:19:09 <tehgeekmeister> i'll try it, that'd be cool if it did
20:19:11 <pumpkin> I don't think guards have a special status
20:19:19 <pumpkin> I think it's just sugar for a case expression
20:20:03 <rwbarton> but if f :: State s a needs to case on the value of the state then f isn't of the form f = case ... of ...
20:20:38 <tehgeekmeister> rwbarton: so i should branch inside the function?
20:21:16 <rwbarton> right, possibly inside a do block
20:22:16 <tehgeekmeister> okay
20:22:16 <rwbarton> or maybe you want to write a separate top-level function s -> (a, s) (or s -> a) and wrap it in State separately
20:23:08 <tehgeekmeister> rwbarton: i don't understand that?
20:33:57 <pumpkin> woo, it's nice to see the disassembler understand more instructions
20:34:40 <tehgeekmeister> let statements are allowed inside do blocks, right?
20:35:17 <pumpkin> yup, but they're slightly different
20:35:22 <tehgeekmeister> how so?
20:35:22 <pumpkin> no "in" is needed
20:35:30 <tehgeekmeister> oh, right
20:35:38 <tehgeekmeister> i knew that without consciously being aware of it
20:35:45 <tehgeekmeister> thanks tho
20:35:47 <pumpkin> :)
20:58:44 <tehgeekmeister> is there an easy way to do parallel mapping over lists already?
20:58:55 <tehgeekmeister> and if so is it more efficient than regular mapping?
20:58:58 <ddarius> Use parMap
20:59:04 <ddarius> It depends.
20:59:16 <tehgeekmeister> on what?
21:00:12 <ddarius> On a lot of things, just like parallelizing any code.
21:01:14 <tehgeekmeister> hum, okay
21:01:19 <tehgeekmeister> so time it and see, i guess?
21:01:30 <pumpkin> tehgeekmeister: there are various "strategies" you can use on parMap
21:01:43 <pumpkin> you can tell it to give chunks of the list to different threads
21:01:59 <rwbarton> It certainly won't be faster on a single processor (assuming you are cpu bound)
21:02:00 <pumpkin> and decide how strict you want it to be on each one
21:02:03 <ddarius> tehgeekmeister: Ultimately.  There are things you can do that will probably be of benefit (but then might not)
21:02:19 <ddarius> rwbarton: Even that is not necessarily true.
21:03:21 <ddarius> You'd think that parallelization would lead to worse efficiency with regards to CPU time but better real time usually, but it can change those in every possible way except I guess better CPU time and worse real time.
21:04:18 <rwbarton> Oh, it can change GC behavior
21:04:46 <ddarius> rwbarton: More commonly it can change cache behavior, sometimes significantly improving it.
21:04:54 <ddarius> (though more often significantly worsening it)
21:05:15 <Tidux> anyone feel like helping a newbie with libedit.so.0 problems?
21:06:20 * tehgeekmeister thinks undefined is a nifty part of the prelude
21:06:22 <mmorrow> Tidux: we'll know when you ask :)
21:06:28 <Tidux> lol
21:06:31 <Tidux> deserved that
21:07:06 <mmorrow> pumpkin: hmm, i'll have to refresh my memory on whats in those binutil headers
21:07:19 <Tidux> hang on a second
21:07:21 <Tidux> trying chmod
21:07:22 <mmorrow> Tidux: are you missing it or something?
21:07:31 <Tidux> it's installed in /usr/local/lib
21:07:32 <mmorrow> iirc different distros have one of two diff versions
21:07:36 <mmorrow> oh
21:07:40 <tehgeekmeister> i think i have made an infinite loop.
21:07:47 <pumpkin> mmorrow: basically they define their own rather complex printf-like "decoding strings" that specify what to print based on bit ranges in the instruction and so on
21:07:54 <mmorrow> Tidux: add that to you LD_LIBRARY_PATH ?
21:08:15 <Tidux> already done
21:08:19 <Tidux> ldd shows the file
21:08:22 <mmorrow> pumpkin: hmm
21:08:25 <pumpkin> mmorrow: but it's very string-oriented... they're format strings, so they contain things like \t, and don't have any explicit notion of "operand" or "opcode", or anything like that
21:08:35 <pumpkin> it just outputs straight to an output stream
21:08:47 <mmorrow> pumpkin: yuk, is all the info there at least that you could extract?
21:09:03 <mmorrow> Tidux: what is the problem exactly? ghci not using it?
21:09:05 <pumpkin> oh yeah, but it seems silly to parse the generated asm back in after making it
21:09:21 <mmorrow> pumpkin: couldn't you parse the C code in the .h?
21:09:22 <pumpkin> so I'm just going to augment the info with markers for operand and opcode etc.
21:09:26 <Tidux> I'm trying to install the Haskell X11 bindings
21:09:33 <pumpkin> mmorrow: ?
21:09:55 <Tidux> but running runhaskell Setup.hs configure --user --prefix=$HOME gives me that libedit error
21:10:10 <mmorrow> Tidux: oh, i'm not sure :(
21:10:23 <Tidux> it's Slamd64, if that makes a difference
21:10:30 <mmorrow> pumpkin: wait, what exactly are we talking about here? maybe i'm on another topic
21:10:54 <pumpkin> the binutils arm disassembler :)
21:11:29 <mmorrow> pumpkin: what i think we're talking about is a way to extract the opcode info from all the binutils headers and put that info into some (possibly different) format for use from haskell
21:11:38 <mmorrow> ?
21:12:09 <pumpkin> oh, yes, my point is that the info for decoding correctly is in those "format strings" but it's not "semantically tagged" in any way
21:12:11 <mmorrow> Tidux: maybe you have to pass in an option to cabal that it'll in turn hand to the linker, like -L/usr/local/lib
21:12:22 <pumpkin> they view disassembling as producing a string of asm
21:12:34 <mmorrow> pumpkin: ohh, ok. so you're going to extract the info that's there, then augment it.
21:12:37 <pumpkin> and I'd prefer to not have to produce a string and then parse it back in
21:12:43 <pumpkin> mmorrow: yeah, that's what I'm doing
21:12:47 <pumpkin> in one pass
21:12:47 <mmorrow> sweet
21:12:50 <mmorrow> woot
21:13:36 <pumpkin> :D
21:13:54 <mmorrow> Tidux: i think "runhaskell Setup.lhs help" will give you all the options
21:14:45 <Tidux> same error when I tried to do that o.0
21:15:30 <tehgeekmeister> if i use the IO monad inside state does that make the type of the function using both IO SomeType
21:15:38 <tehgeekmeister> or not?
21:17:21 <rwbarton> You can't mix actions in different monads.
21:17:32 <rwbarton> That's why we have monad transformers like StateT
21:17:52 <tehgeekmeister> i'm using StateT
21:18:05 <tehgeekmeister> but i'm getting an error message i don't understand
21:18:08 <SamB> you need to sue liftIO
21:18:53 <tehgeekmeister> SamB: that doesn't solve it
21:19:07 <SamB> well, maybe if you used it instead?
21:20:12 <tehgeekmeister> http://tinyurl.com/dkldfq
21:20:17 <tehgeekmeister> that's the error message
21:21:00 <Tidux> I figured it out
21:21:11 <Tidux> I was using the libedit.so.0 binary tarball
21:21:18 <Tidux> I'm on Slackware
21:21:24 <Tidux> so I need to compile from source
21:21:26 <SamB> :t reader
21:21:28 <lambdabot> Not in scope: `reader'
21:21:31 <SamB> @hoogle reader
21:21:32 <lambdabot> module Control.Monad.Reader
21:21:32 <lambdabot> Control.Monad.Reader newtype Reader r a
21:21:32 <lambdabot> Control.Monad.Reader Reader :: r -> a -> Reader r a
21:21:36 <tehgeekmeister> reader is defined in my code
21:21:39 <Tidux> there goes another day...
21:21:44 <Tidux> but thanks for the help
21:22:26 <tehgeekmeister> it's the selector for part of a datatype, the part i want to print.  type should be reader :: ReaderState -> [ReaderItems]
21:22:48 <rwbarton> @type execStateT
21:22:49 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
21:23:19 <tehgeekmeister> ReaderState should be the type of makeReader, after it's all done and has been fed its arguments
21:23:37 <rwbarton> but it's still an action in the underlying monad (I guess IO)
21:24:30 <rwbarton> (the result of execStateT, I mean) perhaps you want  print . reader =<< execStateT makeReader (...)
21:24:39 <TomMD> Alright - I'm registering for courses tomorrow and one of them is functional programming.  Good times.
21:25:01 <tehgeekmeister> rwbarton: i thot it might be that
21:25:48 <tehgeekmeister> that worked!
21:29:46 <JasonFelice> What's the best way to speed this up: http://paste.lisp.org/display/75505
21:30:49 <JasonFelice> It currently takes long enough for one image that I haven't waited for the results yet.  I have many to process.
21:31:13 <TomMD> Have you profiled yet?  If so, would you paste it?
21:31:32 <TomMD> Oh, non-termination.
21:31:41 <TomMD> Have you tried it on smaller pngs?
21:32:21 <JasonFelice> No (but eventually have to process the bigger ones).
21:32:39 <JasonFelice> (I'm trying anyway, out of curiosity)
21:33:35 <TomMD> At least the smaller one will finish and give a proper profile, thats all.
21:33:59 <SamB> unless you've got a real loop!
21:34:08 <TomMD> But it does look fairly low level, not sure if I'm just too tired but I don't see an obvious performance boost.
21:34:25 <TomMD> SamB: Exactly, and thats what the smaller image should give evidence of.
21:35:16 <rwbarton> Building up a list of 2 million Int32s probably isn't very efficient.  It might help to merge the getPixel and setPixel loops
21:35:40 * wli has had some efficiency problems with his addition chain code.
21:35:55 * wli tried to be efficient, but failed.
21:36:20 <JasonFelice> The images are 1920x1200.  But that should only add a constant factor anyhow.
21:36:53 <SamB> well, try a 10x10 ;-P
21:38:18 <JasonFelice> I just hung gimp. :P
21:39:21 <TomMD> a 10x10 should be small enough for you to step through via the debugger if needed.
21:42:07 <dsrogers> how do I force a particular instance of a class method to be chosen?
21:42:29 <hackage> Uploaded to hackage: macho 0.2
21:42:38 <pumpkin> erikc ftw
21:42:45 <SamB> dsrogers: by being specific about the type
21:43:44 <dsrogers> how do I do that?
21:44:17 <SamB> with ::
21:44:56 <dsrogers> ok... so I'm on the right track..
21:45:53 <dsrogers> but I'm still having trouble.  I'm trying to write a instance MonadWriter w m => MonadWriter w (MyT m) where...
21:45:59 <dsrogers> (lift MonadWriter)
21:46:21 <dsrogers> but ...
21:46:34 <dsrogers> when I finally get to my definition, I want to write...
21:46:47 <SamB> oh, I don't think you need :: there
21:46:59 <SamB> or want
21:47:16 <dsrogers> return (a,f) >>= pass >>= (\a -> return $ ...)
21:47:26 <dsrogers> and since (,) is an instance of MonadWriter.
21:47:43 <dsrogers> it's returning the wrong monad.
21:47:43 <ozy`> :t pass
21:47:45 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
21:48:07 <dsrogers> I want return to return m (a,f)
21:48:23 <dsrogers> but I don't know how to use :: to limit return to the polymorphic monad.
21:48:36 <rwbarton> it does... I think... I don't understand what you're saying really.  Can you hpaste?
21:49:40 <dsrogers> I can... it's part of a much larger file...
21:49:45 <dsrogers> But let me extract something
21:51:45 <rwbarton> oh, at least I see now why you're getting the (,) monad
21:52:07 <dsrogers> yes
21:52:15 <dsrogers> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1410#a1410
21:52:23 <dsrogers> that's missing some types.
21:52:39 <dsrogers> but at the bottom is where I'm working on my pass method
21:54:39 <dsrogers> I would like to write (return (a,f)::m (a,f))
21:54:44 <dsrogers> but ghc doesn't like that.
21:55:06 <rwbarton> this isn't a problem that adding a type signature will solve
21:55:12 <rwbarton> your program is just wrong on the term level :)
21:55:24 <rwbarton> do you mean pass (return (x,wf)) perhaps?
21:55:37 <dsrogers> oh dur.
21:56:28 <dsrogers> thaks!
21:56:36 <dsrogers> that was easier than I thought...
21:57:14 * rwbarton doesn't really understand the point of pass
21:57:49 <SamB> :t pass
21:57:51 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
21:58:13 <SamB> rwbarton: well, you get to alter the output in some way
21:58:19 <wli> I'm having speed problems with this:
21:58:26 <wli> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1358#a1358
21:58:33 <SamB> perhaps filtering something out ?
21:58:47 <dsrogers> rwbarton: it lets you filter the log.
21:59:30 <rwbarton> It seems like it has a weird type though, why not just (w -> w) -> m ()
22:00:31 <SamB> rwbarton: because it also lets you return a value
22:01:30 <wli> Actually, more of space problems than speed problems per se, but speed problems also.
22:01:41 <tehgeekmeister> off topic, does anyone else have problems with firefox hogging a lot of memory when you have many tabs open?
22:02:00 <SamB> tehgeekmeister: I thought it was a "feature"?
22:02:17 <SamB> the forward/back cache thing
22:02:28 <tehgeekmeister> SamB: oh i didn't think about that
22:02:36 <SamB> not that I approve
22:02:46 <tehgeekmeister> i now have a much better reason to not keep 100+ tabs open
22:02:46 <dsrogers> rwbarton: that's censor
22:02:55 <dsrogers> which is built with pass.
22:02:55 <tehgeekmeister> not that i had a good reason to keep that many before
22:02:59 <ozy`> :t (++ "\r\n" ++)
22:03:01 <lambdabot> parse error on input `)'
22:03:04 <ozy`> bah
22:03:53 <SamB> tehgeekmeister: why now ?
22:04:16 <rwbarton> dsrogers: could pass be built from the operation  (w -> w) -> m ()?
22:04:25 <trofi> :t ((++ "\r\n") ++)
22:04:27 <lambdabot>     The section `(++ "\r\n")' takes one argument,
22:04:27 <lambdabot>     but its type `[a]' has none
22:04:27 <lambdabot>     In the first argument of `(++)', namely `(++ "\r\n")'
22:04:27 <tehgeekmeister> SamB: because i understand more fully why it's taking so much memory, which is what's slowing my poor computer down, which i can't stand while coding.
22:04:46 <SamB> tehgeekmeister: no, I mean, why did you have 100+ open?
22:05:01 <tehgeekmeister> SamB: sheer laziness and SOME of the things i wanted to get back to.
22:05:08 <tehgeekmeister> SamB: so i wouldn't close any of them.
22:05:23 <tehgeekmeister> SamB: what i really need is a place to queue up links i want to check out again sometime soon.
22:06:12 <dsrogers> rwbarton: yes.  I don't know why pass was chosen as the class method instead of censor.
22:07:25 <ozy`> trofi: I saw "(++) . (++ blah)" and wondered if it could be written more succinctly
22:07:29 <dsrogers> m >>= (\a -> censor >> return a)
22:07:59 <dsrogers> maybe it's useful to be able to change a when writing monad transformers that lift WriterT
22:09:13 <SamB> @pl (++) . (++ blah)
22:09:13 <lambdabot> (++) . (++ blah)
22:09:26 <SamB> :t (++) . (++ ?blah)
22:09:27 <lambdabot> forall a. (?blah::[a]) => [a] -> [a] -> [a]
22:09:43 <rwbarton> @unpl (++) . (++ blah)
22:09:44 <lambdabot> (\ d -> (++) (d ++ blah))
22:09:57 <rwbarton> @unpl ((++) . (++ blah)) x y
22:09:57 <lambdabot> (x ++ blah) ++ y
22:11:18 <ozy`> > x ++ y ++ z
22:11:20 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
22:11:33 <ozy`> > [x] ++ [y] ++ [z]
22:11:35 <lambdabot>   [x,y,z]
22:11:41 <ozy`> well.
22:12:07 <Mr_Awesome> i'd tend to prefer (\ x y -> x ++ blah ++ y) to ((++) . (++ blah))
22:14:09 <geezusfreeek> > intercalate "blah" ["foo", "bar"]
22:14:11 <lambdabot>   "fooblahbar"
22:14:15 * SamB prefers (x ++ blah ++ y)
22:14:20 <SamB> er
22:14:21 <SamB> no
22:14:24 <SamB> (++ blah ++)
22:14:25 <geezusfreeek> :P
22:15:10 <geezusfreeek> @pl \x y -> intercalate blah [x, y]
22:15:11 <lambdabot> (intercalate blah .) . (. return) . (:)
22:15:14 <geezusfreeek> :(
22:16:54 <ozy`> Mr_Awesome: terse lambdas are preferred when writing folds.
22:17:55 <geezusfreeek> nothing wrong with using lambdas or let/where for clarity
22:17:55 <ozy`> of course, you can always refactor such functions with a where block
22:18:02 <ozy`> yeah
22:18:04 <Mr_Awesome> SamB: whoa, i didn't realize you could do that
22:18:16 <geezusfreeek> you can't, afaik :(
22:18:21 <SamB> Mr_Awesome: unfortunately, you can't!
22:18:27 <ozy`> Mr_Awesome: actually you--yeah.
22:18:31 <SamB> doesn't stop me from preferring it!
22:18:39 <geezusfreeek> > (++ "blah" ++) "foo" "bar"
22:18:41 <lambdabot>   <no location info>: parse error on input `)'
22:18:49 <Mr_Awesome> heh, fair enough.
22:18:49 <geezusfreeek> i wish it was possible as well
22:18:52 <ozy`> :t foldr ($)
22:18:53 <lambdabot> forall b. b -> [b -> b] -> b
22:21:02 <ozy`> > foldr ($) 0 [succ, pred, pred, succ, pred]
22:21:04 <lambdabot>   -1
22:21:37 <trofi> @pl \a b -> (a ++ " " ++ b)
22:21:38 <lambdabot> (. (' ' :)) . (++)
22:22:22 <trofi> @pl \a b -> (a ++ "  " ++ b)
22:22:22 <lambdabot> (. ("  " ++)) . (++)
22:26:09 <pumpkin> aha
22:26:22 <pumpkin> I can disassemble all the basic arm instructions now :D
22:29:03 <pumpkin> I'd like to be able to quickcheck this, but it's rather hard to make a statement about what's correct without using another disassembler
22:31:34 <bd_> pumpkin: if you have an assembler as well, you could do eg, \a -> (disassemble . assemble $ a) == a    (where a is a canonical representation of some sort)
22:32:08 <pumpkin> well, I could make an assembler out of this, but given that they're coming out of the same underlying table of stuff, it wouldn't catch mistakes there
22:32:32 <rwbarton> pumpkin: just treat any differences between that table and reality as a bug in your processor
22:32:36 <pumpkin> lol
22:32:42 <pumpkin> good idea
22:38:47 <harblcat> has anyone tried to develop a roguelike in haskell?
22:39:07 <Elly> I've been contemplating it :P
22:39:21 <harblcat> me too, but I don't know where to start...
22:39:23 <pumpkin> roguelike?
22:39:33 <Elly> pumpkin: check wikipedia
22:39:40 <Elly> essentially a curses turn-based game with permanent death
22:39:51 <pumpkin> aha
22:44:01 <ozy`> harblcat: there are a couple, IIRC
22:44:14 <Elly> oh?
22:44:20 <harblcat> oh?
22:44:21 <ozy`> I think there's a graphical one floating around somewhere
22:45:01 <ozy`> with smug little 3D versions of stuff from starcraft and star wars
22:45:26 <ozy`> "roguestar," unless my memory fails me
22:46:39 * Elly wants to see a curses one
22:47:15 <rwbarton> there's also LambdaHack which has both curses and gtk interfaces
22:47:51 <rwbarton> it's sufficiently like nethack to be slightly disorienting :)
22:47:53 <redditbot> A Neighborhood of Infinity: Beyond Monads
22:49:41 <ferret_0567> where is a good tutorial/book on Haskell? I tried learnyouahaskell.com and it doesn't seem too good
22:50:13 <rwbarton> The point-free nose hits you. You die ... --more--
22:52:01 <mauke> ferret_0567: what's bad about it?
22:52:19 <ferret_0567> mauke: I have not found any exercises in it yet
22:52:42 <mauke> preflex: ? rwh
22:52:43 <preflex>  http://book.realworldhaskell.org/
22:53:01 <jekor> I think I understand that I can make a monad an instance of Applicative by using pure = return; (<*>) = ap, but how do I make a monad an instance of Functor? I'm getting "No instance for (Functor (AppT IO)) arising from the superclasses of an instance declaration. In the instance declaration for `Applicative (AppT IO)'.".
22:53:25 <wli> liftM
22:53:27 <mauke> fmap = liftM
22:53:32 <jekor> Ah. Thanks.
22:54:07 <jekor> You guys are awesome.
23:04:00 <mauke> haha
23:04:12 --- mode: ChanServ set +o mauke
23:06:12 --- mode: mauke set -o mauke
23:17:44 <tehgeekmeister> http://tinyurl.com/b73zqb
23:17:50 <tehgeekmeister> anyone know what's causing that type error?
23:18:42 <mauke> your code?
23:19:08 <tehgeekmeister> lol
23:19:19 <tehgeekmeister> concise, but a bit too tautological
23:19:32 <mauke> well, I can't tell you more than what the error says
23:19:43 <tehgeekmeister> would seeing the code help?
23:19:47 <tehgeekmeister> i didn't think of that, for some reason
23:19:48 <tehgeekmeister> getting late here
23:19:49 <pumpkin> lol
23:20:29 <tehgeekmeister> it has the code now
23:23:02 <mauke> :t M.filter
23:23:04 <lambdabot> forall a k. (Ord k) => (a -> Bool) -> M.Map k a -> M.Map k a
23:24:30 <mauke> :t S.member
23:24:32 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
23:25:11 <mauke> well, there we go
23:25:37 <mauke> itemMap returns a Map String (Set Int), but known st :: Set String
23:26:43 <tehgeekmeister> and hence we're filtering based whether the keys from itemMap are in known
23:26:50 <tehgeekmeister> i don't see the problem?
23:27:20 <mauke> no
23:27:28 <mauke> M.filter uses the values
23:28:00 <tehgeekmeister> OH!
23:28:02 <tehgeekmeister> fail
23:30:33 <tehgeekmeister> i think that is a sign it's time to stop coding for the night
23:47:54 <redditbot> Incremental fold, a design pattern
23:47:54 <redditbot> Cabal ticket #500
23:57:36 <dancor> is there any work on structures for distributed conflict resolution
23:58:23 <dancor> you have hosts A and B that can only talk to the outside world W periodically.  you want to maintain various structures, one example being a set
23:59:16 <dancor> so if during one blackout period A adds {x,y} to the set and B adds {y,z} then the conflict resolution when A and B talk to W should leave the set being {x,y,z}
23:59:50 <dancor> if there are removals then the conflict resolution has to look at timestamps
23:59:51 <dancor> etc
